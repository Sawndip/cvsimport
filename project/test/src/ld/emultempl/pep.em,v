head	1.51;
access;
symbols
	binutils-2_24-branch:1.51.0.2
	binutils-2_24-branchpoint:1.51
	binutils-2_21_1:1.38.2.2
	binutils-2_23_2:1.48.2.1
	binutils-2_23_1:1.48.2.1
	binutils-2_23:1.48.2.1
	binutils-2_23-branch:1.48.0.2
	binutils-2_23-branchpoint:1.48
	binutils-2_22_branch:1.46.0.4
	binutils-2_22:1.46
	binutils-2_22-branch:1.46.0.2
	binutils-2_22-branchpoint:1.46
	binutils-2_21:1.38
	binutils-2_21-branch:1.38.0.2
	binutils-2_21-branchpoint:1.38
	binutils-2_20_1:1.27.4.1
	binutils-2_20:1.27.4.1
	binutils-arc-20081103-branch:1.16.0.4
	binutils-arc-20081103-branchpoint:1.16
	binutils-2_20-branch:1.27.0.4
	binutils-2_20-branchpoint:1.27
	dje-cgen-play1-branch:1.27.0.2
	dje-cgen-play1-branchpoint:1.27
	arc-20081103-branch:1.16.0.2
	arc-20081103-branchpoint:1.16
	binutils-2_19_1:1.12.2.1
	binutils-2_19:1.12.2.1
	binutils-2_19-branch:1.12.0.2
	binutils-2_19-branchpoint:1.12
	binutils-2_18:1.5
	binutils-2_18-branch:1.5.0.2
	binutils-2_18-branchpoint:1.5
	binutils_latest_snapshot:1.51;
locks; strict;
comment	@# @;


1.51
date	2013.03.05.11.54.29;	author corinna;	state Exp;
branches;
next	1.50;

1.50
date	2013.01.10.20.08.03;	author hjl;	state Exp;
branches;
next	1.49;

1.49
date	2012.08.06.22.27.52;	author macro;	state Exp;
branches;
next	1.48;

1.48
date	2012.05.14.19.45.28;	author jwlemke;	state Exp;
branches
	1.48.2.1;
next	1.47;

1.47
date	2012.03.05.22.43.40;	author amodra;	state Exp;
branches;
next	1.46;

1.46
date	2011.06.13.00.59.43;	author amodra;	state Exp;
branches;
next	1.45;

1.45
date	2011.03.10.10.20.26;	author davek;	state Exp;
branches;
next	1.44;

1.44
date	2011.02.28.18.34.52;	author ktietz;	state Exp;
branches;
next	1.43;

1.43
date	2011.01.14.12.37.17;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2011.01.13.13.06.22;	author amodra;	state Exp;
branches;
next	1.41;

1.41
date	2010.12.20.13.00.14;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2010.12.06.00.07.06;	author hjl;	state Exp;
branches;
next	1.39;

1.39
date	2010.11.15.22.01.17;	author amodra;	state Exp;
branches;
next	1.38;

1.38
date	2010.09.22.08.03.41;	author ktietz;	state Exp;
branches
	1.38.2.1;
next	1.37;

1.37
date	2010.05.25.10.03.01;	author ktietz;	state Exp;
branches;
next	1.36;

1.36
date	2010.05.15.19.50.44;	author ktietz;	state Exp;
branches;
next	1.35;

1.35
date	2010.05.11.17.46.22;	author ktietz;	state Exp;
branches;
next	1.34;

1.34
date	2010.04.05.09.04.09;	author ktietz;	state Exp;
branches;
next	1.33;

1.33
date	2010.01.14.04.56.11;	author dj;	state Exp;
branches;
next	1.32;

1.32
date	2009.11.15.07.52.44;	author ktietz;	state Exp;
branches;
next	1.31;

1.31
date	2009.11.04.18.13.05;	author ktietz;	state Exp;
branches;
next	1.30;

1.30
date	2009.10.28.17.34.14;	author ktietz;	state Exp;
branches;
next	1.29;

1.29
date	2009.10.16.15.15.39;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2009.09.13.07.19.18;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2009.05.15.14.22.35;	author amodra;	state Exp;
branches
	1.27.4.1;
next	1.26;

1.26
date	2009.05.14.02.21.45;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2009.04.02.14.42.41;	author davek;	state Exp;
branches;
next	1.24;

1.24
date	2009.03.14.03.30.26;	author davek;	state Exp;
branches;
next	1.23;

1.23
date	2009.03.03.18.22.11;	author davek;	state Exp;
branches;
next	1.22;

1.22
date	2009.02.18.18.23.07;	author davek;	state Exp;
branches;
next	1.21;

1.21
date	2009.02.16.07.25.52;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2009.01.08.13.28.48;	author ktietz;	state Exp;
branches;
next	1.19;

1.19
date	2009.01.05.12.17.43;	author ktietz;	state Exp;
branches;
next	1.18;

1.18
date	2009.01.03.18.04.16;	author davek;	state Exp;
branches;
next	1.17;

1.17
date	2008.11.14.15.13.05;	author ktietz;	state Exp;
branches;
next	1.16;

1.16
date	2008.10.20.12.14.29;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2008.10.04.06.08.59;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2008.10.03.09.40.49;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2008.09.09.09.45.31;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2008.08.17.03.12.50;	author amodra;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2008.07.30.04.34.57;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2008.05.09.11.56.31;	author ktietz;	state Exp;
branches;
next	1.9;

1.9
date	2008.02.15.03.35.53;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2007.11.06.12.28.57;	author ktietz;	state Exp;
branches;
next	1.7;

1.7
date	2007.10.04.13.55.25;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2007.10.01.09.54.58;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2007.08.06.14.32.08;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2007.07.19.19.56.10;	author roland;	state Exp;
branches;
next	1.3;

1.3
date	2007.07.06.14.09.42;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2007.04.26.14.46.59;	author amodra;	state Exp;
branches;
next	1.1;

1.1
date	2006.09.20.11.35.09;	author nickc;	state Exp;
branches;
next	;

1.48.2.1
date	2012.09.04.14.38.00;	author gingold;	state Exp;
branches;
next	;

1.38.2.1
date	2011.02.01.12.25.47;	author amodra;	state Exp;
branches;
next	1.38.2.2;

1.38.2.2
date	2011.05.29.04.51.49;	author amodra;	state Exp;
branches;
next	;

1.27.4.1
date	2009.09.13.07.20.06;	author amodra;	state Exp;
branches;
next	;

1.12.2.1
date	2008.09.09.09.49.56;	author nickc;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2009.03.02.13.32.56;	author amodra;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2009.03.02.13.34.03;	author amodra;	state Exp;
branches;
next	1.12.2.4;

1.12.2.4
date	2009.03.02.13.56.19;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.51
log
@	* configure.host: Add x86_64-*-cygwin* as valid host.
	* configure.tgt: Add x86_64-*-cygwin* as valid target.
	* emultempl/pep.em: Handle different requirements for Cygwin in terms
	of start addresses for executables and DLLs, based on memory model in
	http://cygwin.com/ml/cygwin-developers/2013-02/msg00027.html
@
text
@# This shell script emits a C file. -*- C -*-
# It does some substitutions.
if [ -z "$MACHINE" ]; then
  OUTPUT_ARCH=${ARCH}
else
  OUTPUT_ARCH=${ARCH}:${MACHINE}
fi

case ${target} in
  *-*-cygwin*)
    move_default_addr_high=1
    ;;
  *)
    move_default_addr_high=0;
    ;;
esac

rm -f e${EMULATION_NAME}.c
(echo;echo;echo;echo;echo)>e${EMULATION_NAME}.c # there, now line numbers match ;-)
fragment <<EOF
/* Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2012
   Free Software Foundation, Inc.
   Written by Kai Tietz, OneVision Software GmbH&CoKg.

   This file is part of the GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */


/* For WINDOWS_XP64 and higher */
/* Based on pe.em, but modified for 64 bit support.  */

#define TARGET_IS_${EMULATION_NAME}

#define COFF_IMAGE_WITH_PE
#define COFF_WITH_PE
#define COFF_WITH_pex64

#include "sysdep.h"
#include "bfd.h"
#include "bfdlink.h"
#include "getopt.h"
#include "libiberty.h"
#include "filenames.h"
#include "ld.h"
#include "ldmain.h"
#include "ldexp.h"
#include "ldlang.h"
#include "ldfile.h"
#include "ldemul.h"
#include <ldgram.h>
#include "ldlex.h"
#include "ldmisc.h"
#include "ldctor.h"
#include "coff/internal.h"

/* FIXME: See bfd/peXXigen.c for why we include an architecture specific
   header in generic PE code.  */
#include "coff/x86_64.h"
#include "coff/pe.h"

/* FIXME: This is a BFD internal header file, and we should not be
   using it here.  */
#include "../bfd/libcoff.h"

#undef  AOUTSZ
#define AOUTSZ		PEPAOUTSZ
#define PEAOUTHDR	PEPAOUTHDR

#include "deffile.h"
#include "pep-dll.h"
#include "safe-ctype.h"

/* Permit the emulation parameters to override the default section
   alignment by setting OVERRIDE_SECTION_ALIGNMENT.  FIXME: This makes
   it seem that include/coff/internal.h should not define
   PE_DEF_SECTION_ALIGNMENT.  */
#if PE_DEF_SECTION_ALIGNMENT != ${OVERRIDE_SECTION_ALIGNMENT:-PE_DEF_SECTION_ALIGNMENT}
#undef  PE_DEF_SECTION_ALIGNMENT
#define PE_DEF_SECTION_ALIGNMENT ${OVERRIDE_SECTION_ALIGNMENT}
#endif

#ifdef TARGET_IS_i386pep
#define DLL_SUPPORT
#endif

#if defined(TARGET_IS_i386pep) || ! defined(DLL_SUPPORT)
#define	PE_DEF_SUBSYSTEM		3
#undef NT_EXE_IMAGE_BASE
#define NT_EXE_IMAGE_BASE \
  ((bfd_vma) (${move_default_addr_high} ? 0x100400000LL \
					: 0x400000LL))
#undef NT_DLL_IMAGE_BASE
#define NT_DLL_IMAGE_BASE \
  ((bfd_vma) (${move_default_addr_high} ? 0x400000000LL \
					: 0x10000000LL))
#undef NT_DLL_AUTO_IMAGE_BASE
#define NT_DLL_AUTO_IMAGE_BASE \
  ((bfd_vma) (${move_default_addr_high} ? 0x400000000LL \
					: 0x61300000LL))
#undef NT_DLL_AUTO_IMAGE_MASK
#define NT_DLL_AUTO_IMAGE_MASK \
  ((bfd_vma) (${move_default_addr_high} ? 0x1ffff0000LL \
					: 0x0ffc0000LL))
#else
#undef  NT_EXE_IMAGE_BASE
#define NT_EXE_IMAGE_BASE \
  ((bfd_vma) (${move_default_addr_high} ? 0x100010000LL \
					: 0x10000LL))
#undef NT_DLL_IMAGE_BASE
#define NT_DLL_IMAGE_BASE \
  ((bfd_vma) (${move_default_addr_high} ? 0x110000000LL \
					: 0x10000000LL))
#undef NT_DLL_AUTO_IMAGE_BASE
#define NT_DLL_AUTO_IMAGE_BASE \
  ((bfd_vma) (${move_default_addr_high} ? 0x120000000LL \
					: 0x61300000LL))
#undef NT_DLL_AUTO_IMAGE_MASK
#define NT_DLL_AUTO_IMAGE_MASK \
  ((bfd_vma) (${move_default_addr_high} ? 0x0ffff0000LL \
					: 0x0ffc0000LL))
#undef  PE_DEF_SECTION_ALIGNMENT
#define	PE_DEF_SUBSYSTEM		2
#undef  PE_DEF_FILE_ALIGNMENT
#define PE_DEF_FILE_ALIGNMENT		0x00000200
#define PE_DEF_SECTION_ALIGNMENT	0x00000400
#endif

static struct internal_extra_pe_aouthdr pep;
static int dll;
static int pep_subsystem = ${SUBSYSTEM};
static flagword real_flags = IMAGE_FILE_LARGE_ADDRESS_AWARE;
static int support_old_code = 0;
static lang_assignment_statement_type *image_base_statement = 0;
static unsigned short pe_dll_characteristics = 0;

#ifdef DLL_SUPPORT
static int    pep_enable_stdcall_fixup = 1; /* 0=disable 1=enable (default).  */
static char * pep_out_def_filename = NULL;
static char * pep_implib_filename = NULL;
static int    pep_enable_auto_image_base = 0;
static char * pep_dll_search_prefix = NULL;
#endif

extern const char *output_filename;

static int is_underscoring (void)
{
  int u = 0;
  if (pep_leading_underscore != -1)
    return pep_leading_underscore;
  if (!bfd_get_target_info ("${OUTPUT_FORMAT}", NULL, NULL, &u, NULL))
    bfd_get_target_info ("${RELOCATEABLE_OUTPUT_FORMAT}", NULL, NULL, &u, NULL);

  if (u == -1)
    abort ();
  pep_leading_underscore = (u != 0 ? 1 : 0);
  return pep_leading_underscore;
}


static void
gld_${EMULATION_NAME}_before_parse (void)
{
  is_underscoring ();
  ldfile_set_output_arch ("${OUTPUT_ARCH}", bfd_arch_`echo ${ARCH} | sed -e 's/:.*//'`);
  output_filename = "${EXECUTABLE_NAME:-a.exe}";
#ifdef DLL_SUPPORT
  input_flags.dynamic = TRUE;
  config.has_shared = 1;
  link_info.pei386_auto_import = 1;
  link_info.pei386_runtime_pseudo_reloc = 2; /* Use by default version 2.  */
#endif
}

/* PE format extra command line options.  */

/* Used for setting flags in the PE header.  */
enum options
{
  OPTION_BASE_FILE = 300 + 1,
  OPTION_DLL,
  OPTION_FILE_ALIGNMENT,
  OPTION_IMAGE_BASE,
  OPTION_MAJOR_IMAGE_VERSION,
  OPTION_MAJOR_OS_VERSION,
  OPTION_MAJOR_SUBSYSTEM_VERSION,
  OPTION_MINOR_IMAGE_VERSION,
  OPTION_MINOR_OS_VERSION,
  OPTION_MINOR_SUBSYSTEM_VERSION,
  OPTION_SECTION_ALIGNMENT,
  OPTION_STACK,
  OPTION_SUBSYSTEM,
  OPTION_HEAP,
  OPTION_SUPPORT_OLD_CODE,
  OPTION_OUT_DEF,
  OPTION_EXPORT_ALL,
  OPTION_EXCLUDE_SYMBOLS,
  OPTION_EXCLUDE_ALL_SYMBOLS,
  OPTION_KILL_ATS,
  OPTION_STDCALL_ALIASES,
  OPTION_ENABLE_STDCALL_FIXUP,
  OPTION_DISABLE_STDCALL_FIXUP,
  OPTION_IMPLIB_FILENAME,
  OPTION_WARN_DUPLICATE_EXPORTS,
  OPTION_IMP_COMPAT,
  OPTION_ENABLE_AUTO_IMAGE_BASE,
  OPTION_DISABLE_AUTO_IMAGE_BASE,
  OPTION_DLL_SEARCH_PREFIX,
  OPTION_NO_DEFAULT_EXCLUDES,
  OPTION_DLL_ENABLE_AUTO_IMPORT,
  OPTION_DLL_DISABLE_AUTO_IMPORT,
  OPTION_ENABLE_EXTRA_PE_DEBUG,
  OPTION_EXCLUDE_LIBS,
  OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC,
  OPTION_DLL_DISABLE_RUNTIME_PSEUDO_RELOC,
  OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC_V2,
  OPTION_EXCLUDE_MODULES_FOR_IMPLIB,
  OPTION_USE_NUL_PREFIXED_IMPORT_TABLES,
  OPTION_NO_LEADING_UNDERSCORE,
  OPTION_LEADING_UNDERSCORE,
  OPTION_ENABLE_LONG_SECTION_NAMES,
  OPTION_DISABLE_LONG_SECTION_NAMES,
  OPTION_DYNAMIC_BASE,
  OPTION_FORCE_INTEGRITY,
  OPTION_NX_COMPAT,
  OPTION_NO_ISOLATION,
  OPTION_NO_SEH,
  OPTION_NO_BIND,
  OPTION_WDM_DRIVER,
  OPTION_TERMINAL_SERVER_AWARE
};

static void
gld${EMULATION_NAME}_add_options
  (int ns ATTRIBUTE_UNUSED,
   char **shortopts ATTRIBUTE_UNUSED,
   int nl,
   struct option **longopts,
   int nrl ATTRIBUTE_UNUSED,
   struct option **really_longopts ATTRIBUTE_UNUSED)
{
  static const struct option xtra_long[] =
  {
    /* PE options */
    {"base-file", required_argument, NULL, OPTION_BASE_FILE},
    {"dll", no_argument, NULL, OPTION_DLL},
    {"file-alignment", required_argument, NULL, OPTION_FILE_ALIGNMENT},
    {"heap", required_argument, NULL, OPTION_HEAP},
    {"image-base", required_argument, NULL, OPTION_IMAGE_BASE},
    {"major-image-version", required_argument, NULL, OPTION_MAJOR_IMAGE_VERSION},
    {"major-os-version", required_argument, NULL, OPTION_MAJOR_OS_VERSION},
    {"major-subsystem-version", required_argument, NULL, OPTION_MAJOR_SUBSYSTEM_VERSION},
    {"minor-image-version", required_argument, NULL, OPTION_MINOR_IMAGE_VERSION},
    {"minor-os-version", required_argument, NULL, OPTION_MINOR_OS_VERSION},
    {"minor-subsystem-version", required_argument, NULL, OPTION_MINOR_SUBSYSTEM_VERSION},
    {"section-alignment", required_argument, NULL, OPTION_SECTION_ALIGNMENT},
    {"stack", required_argument, NULL, OPTION_STACK},
    {"subsystem", required_argument, NULL, OPTION_SUBSYSTEM},
    {"support-old-code", no_argument, NULL, OPTION_SUPPORT_OLD_CODE},
    {"use-nul-prefixed-import-tables", no_argument, NULL,
     OPTION_USE_NUL_PREFIXED_IMPORT_TABLES},
    {"no-leading-underscore", no_argument, NULL, OPTION_NO_LEADING_UNDERSCORE},
    {"leading-underscore", no_argument, NULL, OPTION_LEADING_UNDERSCORE},
#ifdef DLL_SUPPORT
    /* getopt allows abbreviations, so we do this to stop it
       from treating -o as an abbreviation for this option.  */
    {"output-def", required_argument, NULL, OPTION_OUT_DEF},
    {"output-def", required_argument, NULL, OPTION_OUT_DEF},
    {"export-all-symbols", no_argument, NULL, OPTION_EXPORT_ALL},
    {"exclude-symbols", required_argument, NULL, OPTION_EXCLUDE_SYMBOLS},
    {"exclude-all-symbols", no_argument, NULL, OPTION_EXCLUDE_ALL_SYMBOLS},
    {"exclude-libs", required_argument, NULL, OPTION_EXCLUDE_LIBS},
    {"exclude-modules-for-implib", required_argument, NULL, OPTION_EXCLUDE_MODULES_FOR_IMPLIB},
    {"kill-at", no_argument, NULL, OPTION_KILL_ATS},
    {"add-stdcall-alias", no_argument, NULL, OPTION_STDCALL_ALIASES},
    {"enable-stdcall-fixup", no_argument, NULL, OPTION_ENABLE_STDCALL_FIXUP},
    {"disable-stdcall-fixup", no_argument, NULL, OPTION_DISABLE_STDCALL_FIXUP},
    {"out-implib", required_argument, NULL, OPTION_IMPLIB_FILENAME},
    {"warn-duplicate-exports", no_argument, NULL, OPTION_WARN_DUPLICATE_EXPORTS},
    /* getopt() allows abbreviations, so we do this to stop it from
       treating -c as an abbreviation for these --compat-implib.  */
    {"compat-implib", no_argument, NULL, OPTION_IMP_COMPAT},
    {"compat-implib", no_argument, NULL, OPTION_IMP_COMPAT},
    {"enable-auto-image-base", no_argument, NULL, OPTION_ENABLE_AUTO_IMAGE_BASE},
    {"disable-auto-image-base", no_argument, NULL, OPTION_DISABLE_AUTO_IMAGE_BASE},
    {"dll-search-prefix", required_argument, NULL, OPTION_DLL_SEARCH_PREFIX},
    {"no-default-excludes", no_argument, NULL, OPTION_NO_DEFAULT_EXCLUDES},
    {"enable-auto-import", no_argument, NULL, OPTION_DLL_ENABLE_AUTO_IMPORT},
    {"disable-auto-import", no_argument, NULL, OPTION_DLL_DISABLE_AUTO_IMPORT},
    {"enable-extra-pep-debug", no_argument, NULL, OPTION_ENABLE_EXTRA_PE_DEBUG},
    {"enable-runtime-pseudo-reloc", no_argument, NULL, OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC},
    {"disable-runtime-pseudo-reloc", no_argument, NULL, OPTION_DLL_DISABLE_RUNTIME_PSEUDO_RELOC},
    {"enable-runtime-pseudo-reloc-v2", no_argument, NULL, OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC_V2},
#endif
    {"enable-long-section-names", no_argument, NULL, OPTION_ENABLE_LONG_SECTION_NAMES},
    {"disable-long-section-names", no_argument, NULL, OPTION_DISABLE_LONG_SECTION_NAMES},
    {"dynamicbase",no_argument, NULL, OPTION_DYNAMIC_BASE},
    {"forceinteg", no_argument, NULL, OPTION_FORCE_INTEGRITY},
    {"nxcompat", no_argument, NULL, OPTION_NX_COMPAT},
    {"no-isolation", no_argument, NULL, OPTION_NO_ISOLATION},
    {"no-seh", no_argument, NULL, OPTION_NO_SEH},
    {"no-bind", no_argument, NULL, OPTION_NO_BIND},
    {"wdmdriver", no_argument, NULL, OPTION_WDM_DRIVER},
    {"tsaware", no_argument, NULL, OPTION_TERMINAL_SERVER_AWARE},
    {NULL, no_argument, NULL, 0}
  };

  *longopts
    = xrealloc (*longopts, nl * sizeof (struct option) + sizeof (xtra_long));
  memcpy (*longopts + nl, &xtra_long, sizeof (xtra_long));
}

/* PE/WIN32; added routines to get the subsystem type, heap and/or stack
   parameters which may be input from the command line.  */

typedef struct
{
  void *ptr;
  int size;
  bfd_vma value;
  char *symbol;
  int inited;
  /* FALSE for an assembly level symbol and TRUE for a C visible symbol.
     C visible symbols can be prefixed by underscore dependent on target's
     settings.  */
  bfd_boolean is_c_symbol;
} definfo;

#define GET_INIT_SYMBOL_NAME(IDX) \
  (init[(IDX)].symbol \
  + ((init[(IDX)].is_c_symbol == FALSE || (is_underscoring () == 1)) ? 0 : 1))

/* Decorates the C visible symbol by underscore, if target requires.  */
#define U(CSTR) \
  ((is_underscoring () == 0) ? CSTR : "_" CSTR)

/* Get size of constant string for a possible underscore prefixed
   C visible symbol.  */
#define U_SIZE(CSTR) \
  (sizeof (CSTR) + (is_underscoring () == 0 ? 0 : 1))

#define D(field,symbol,def,usc)  {&pep.field,sizeof(pep.field), def, symbol,0, usc}

static definfo init[] =
{
  /* imagebase must be first */
#define IMAGEBASEOFF 0
  D(ImageBase,"__image_base__", NT_EXE_IMAGE_BASE, FALSE),
#define DLLOFF 1
  {&dll, sizeof(dll), 0, "__dll__", 0, FALSE},
#define MSIMAGEBASEOFF	2
  D(ImageBase, "___ImageBase", NT_EXE_IMAGE_BASE, TRUE),
  D(SectionAlignment,"__section_alignment__", PE_DEF_SECTION_ALIGNMENT, FALSE),
  D(FileAlignment,"__file_alignment__", PE_DEF_FILE_ALIGNMENT, FALSE),
  D(MajorOperatingSystemVersion,"__major_os_version__", 4, FALSE),
  D(MinorOperatingSystemVersion,"__minor_os_version__", 0, FALSE),
  D(MajorImageVersion,"__major_image_version__", 0, FALSE),
  D(MinorImageVersion,"__minor_image_version__", 0, FALSE),
  D(MajorSubsystemVersion,"__major_subsystem_version__", 5, FALSE),
  D(MinorSubsystemVersion,"__minor_subsystem_version__", 2, FALSE),
  D(Subsystem,"__subsystem__", ${SUBSYSTEM}, FALSE),
  D(SizeOfStackReserve,"__size_of_stack_reserve__", 0x200000, FALSE),
  D(SizeOfStackCommit,"__size_of_stack_commit__", 0x1000, FALSE),
  D(SizeOfHeapReserve,"__size_of_heap_reserve__", 0x100000, FALSE),
  D(SizeOfHeapCommit,"__size_of_heap_commit__", 0x1000, FALSE),
  D(LoaderFlags,"__loader_flags__", 0x0, FALSE),
  D(DllCharacteristics, "__dll_characteristics__", 0x0, FALSE),
  { NULL, 0, 0, NULL, 0, FALSE}
};


static void
gld_${EMULATION_NAME}_list_options (FILE *file)
{
  fprintf (file, _("  --base_file <basefile>             Generate a base file for relocatable DLLs\n"));
  fprintf (file, _("  --dll                              Set image base to the default for DLLs\n"));
  fprintf (file, _("  --file-alignment <size>            Set file alignment\n"));
  fprintf (file, _("  --heap <size>                      Set initial size of the heap\n"));
  fprintf (file, _("  --image-base <address>             Set start address of the executable\n"));
  fprintf (file, _("  --major-image-version <number>     Set version number of the executable\n"));
  fprintf (file, _("  --major-os-version <number>        Set minimum required OS version\n"));
  fprintf (file, _("  --major-subsystem-version <number> Set minimum required OS subsystem version\n"));
  fprintf (file, _("  --minor-image-version <number>     Set revision number of the executable\n"));
  fprintf (file, _("  --minor-os-version <number>        Set minimum required OS revision\n"));
  fprintf (file, _("  --minor-subsystem-version <number> Set minimum required OS subsystem revision\n"));
  fprintf (file, _("  --section-alignment <size>         Set section alignment\n"));
  fprintf (file, _("  --stack <size>                     Set size of the initial stack\n"));
  fprintf (file, _("  --subsystem <name>[:<version>]     Set required OS subsystem [& version]\n"));
  fprintf (file, _("  --support-old-code                 Support interworking with old code\n"));
  fprintf (file, _("  --[no-]leading-underscore          Set explicit symbol underscore prefix mode\n"));
#ifdef DLL_SUPPORT
  fprintf (file, _("  --add-stdcall-alias                Export symbols with and without @@nn\n"));
  fprintf (file, _("  --disable-stdcall-fixup            Don't link _sym to _sym@@nn\n"));
  fprintf (file, _("  --enable-stdcall-fixup             Link _sym to _sym@@nn without warnings\n"));
  fprintf (file, _("  --exclude-symbols sym,sym,...      Exclude symbols from automatic export\n"));
  fprintf (file, _("  --exclude-all-symbols              Exclude all symbols from automatic export\n"));
  fprintf (file, _("  --exclude-libs lib,lib,...         Exclude libraries from automatic export\n"));
  fprintf (file, _("  --exclude-modules-for-implib mod,mod,...\n"));
  fprintf (file, _("                                     Exclude objects, archive members from auto\n"));
  fprintf (file, _("                                     export, place into import library instead.\n"));
  fprintf (file, _("  --export-all-symbols               Automatically export all globals to DLL\n"));
  fprintf (file, _("  --kill-at                          Remove @@nn from exported symbols\n"));
  fprintf (file, _("  --out-implib <file>                Generate import library\n"));
  fprintf (file, _("  --output-def <file>                Generate a .DEF file for the built DLL\n"));
  fprintf (file, _("  --warn-duplicate-exports           Warn about duplicate exports.\n"));
  fprintf (file, _("  --compat-implib                    Create backward compatible import libs;\n\
                                       create __imp_<SYMBOL> as well.\n"));
  fprintf (file, _("  --enable-auto-image-base           Automatically choose image base for DLLs\n\
                                       unless user specifies one\n"));
  fprintf (file, _("  --disable-auto-image-base          Do not auto-choose image base. (default)\n"));
  fprintf (file, _("  --dll-search-prefix=<string>       When linking dynamically to a dll without\n\
                                       an importlib, use <string><basename>.dll\n\
                                       in preference to lib<basename>.dll \n"));
  fprintf (file, _("  --enable-auto-import               Do sophisticated linking of _sym to\n\
                                       __imp_sym for DATA references\n"));
  fprintf (file, _("  --disable-auto-import              Do not auto-import DATA items from DLLs\n"));
  fprintf (file, _("  --enable-runtime-pseudo-reloc      Work around auto-import limitations by\n\
                                       adding pseudo-relocations resolved at\n\
                                       runtime.\n"));
  fprintf (file, _("  --disable-runtime-pseudo-reloc     Do not add runtime pseudo-relocations for\n\
                                       auto-imported DATA.\n"));
  fprintf (file, _("  --enable-extra-pep-debug            Enable verbose debug output when building\n\
                                       or linking to DLLs (esp. auto-import)\n"));
  fprintf (file, _("  --enable-long-section-names        Use long COFF section names even in\n\
                                       executable image files\n"));
  fprintf (file, _("  --disable-long-section-names       Never use long COFF section names, even\n\
                                       in object files\n"));
  fprintf (file, _("  --dynamicbase			 Image base address may be relocated using\n\
				       address space layout randomization (ASLR)\n"));
  fprintf (file, _("  --forceinteg		 Code integrity checks are enforced\n"));
  fprintf (file, _("  --nxcompat		 Image is compatible with data execution prevention\n"));
  fprintf (file, _("  --no-isolation		 Image understands isolation but do not isolate the image\n"));
  fprintf (file, _("  --no-seh			 Image does not use SEH. No SE handler may\n\
				       be called in this image\n"));
  fprintf (file, _("  --no-bind			 Do not bind this image\n"));
  fprintf (file, _("  --wdmdriver		 Driver uses the WDM model\n"));
  fprintf (file, _("  --tsaware                  Image is Terminal Server aware\n"));
#endif
}


static void
set_pep_name (char *name, bfd_vma val)
{
  int i;
  is_underscoring ();
  /* Find the name and set it.  */
  for (i = 0; init[i].ptr; i++)
    {
      if (strcmp (name, GET_INIT_SYMBOL_NAME (i)) == 0)
	{
	  init[i].value = val;
	  init[i].inited = 1;
	  if (strcmp (name,"__image_base__") == 0)
	    set_pep_name (U ("__ImageBase"), val);
	  return;
	}
    }
  abort ();
}

static void
set_entry_point (void)
{
  const char *entry;
  const char *initial_symbol_char;
  int i;

  static const struct
    {
      const int value;
      const char *entry;
    }
  v[] =
    {
      { 1, "NtProcessStartup"  },
      { 2, "WinMainCRTStartup" },
      { 3, "mainCRTStartup"    },
      { 7, "__PosixProcessStartup" },
      { 9, "WinMainCRTStartup" },
      {14, "mainCRTStartup"    },
      { 0, NULL          }
    };

  /* Entry point name for arbitrary subsystem numbers.  */
  static const char default_entry[] = "mainCRTStartup";

  if (link_info.shared || dll)
    {
      entry = "DllMainCRTStartup";
    }
  else
    {
      for (i = 0; v[i].entry; i++)
        if (v[i].value == pep_subsystem)
          break;

      /* If no match, use the default.  */
      if (v[i].entry != NULL)
        entry = v[i].entry;
      else
        entry = default_entry;
    }

  /* Now we check target's default for getting proper symbol_char.  */
  initial_symbol_char = (is_underscoring () != 0 ? "_" : "");

  if (*initial_symbol_char != '\0')
    {
      char *alc_entry;

      /* lang_default_entry expects its argument to be permanently
	 allocated, so we don't free this string.  */
      alc_entry = xmalloc (strlen (initial_symbol_char)
			   + strlen (entry)
			   + 1);
      strcpy (alc_entry, initial_symbol_char);
      strcat (alc_entry, entry);
      entry = alc_entry;
    }

  lang_default_entry (entry);
}

static void
set_pep_subsystem (void)
{
  const char *sver;
  char *end;
  int len;
  int i;
  unsigned long temp_subsystem;
  static const struct
    {
      const char *name;
      const int value;
    }
  v[] =
    {
      { "native",  1 },
      { "windows", 2 },
      { "console", 3 },
      { "posix",   7 },
      { "wince",   9 },
      { "xbox",   14 },
      { NULL, 0 }
    };

  /* Check for the presence of a version number.  */
  sver = strchr (optarg, ':');
  if (sver == NULL)
    len = strlen (optarg);
  else
    {
      len = sver - optarg;
      set_pep_name ("__major_subsystem_version__",
		    strtoul (sver + 1, &end, 0));
      if (*end == '.')
	set_pep_name ("__minor_subsystem_version__",
		      strtoul (end + 1, &end, 0));
      if (*end != '\0')
	einfo (_("%P: warning: bad version number in -subsystem option\n"));
    }

  /* Check for numeric subsystem.  */
  temp_subsystem = strtoul (optarg, & end, 0);
  if ((*end == ':' || *end == '\0') && (temp_subsystem < 65536))
    {
      /* Search list for a numeric match to use its entry point.  */
      for (i = 0; v[i].name; i++)
	if (v[i].value == (int) temp_subsystem)
	  break;

      /* Use this subsystem.  */
      pep_subsystem = (int) temp_subsystem;
    }
  else
    {
      /* Search for subsystem by name.  */
      for (i = 0; v[i].name; i++)
	if (strncmp (optarg, v[i].name, len) == 0
	    && v[i].name[len] == '\0')
	  break;

      if (v[i].name == NULL)
	{
	  einfo (_("%P%F: invalid subsystem type %s\n"), optarg);
	  return;
	}

      pep_subsystem = v[i].value;
    }

  set_pep_name ("__subsystem__", pep_subsystem);

  return;
}


static void
set_pep_value (char *name)
{
  char *end;

  set_pep_name (name,  (bfd_vma) strtoull (optarg, &end, 0));

  if (end == optarg)
    einfo (_("%P%F: invalid hex number for PE parameter '%s'\n"), optarg);

  optarg = end;
}


static void
set_pep_stack_heap (char *resname, char *comname)
{
  set_pep_value (resname);

  if (*optarg == ',')
    {
      optarg++;
      set_pep_value (comname);
    }
  else if (*optarg)
    einfo (_("%P%F: strange hex info for PE parameter '%s'\n"), optarg);
}


static bfd_boolean
gld${EMULATION_NAME}_handle_option (int optc)
{
  is_underscoring ();
  switch (optc)
    {
    default:
      return FALSE;

    case OPTION_BASE_FILE:
      link_info.base_file = fopen (optarg, FOPEN_WB);
      if (link_info.base_file == NULL)
	einfo (_("%F%P: cannot open base file %s\n"), optarg);
      break;

      /* PE options.  */
    case OPTION_HEAP:
      set_pep_stack_heap ("__size_of_heap_reserve__", "__size_of_heap_commit__");
      break;
    case OPTION_STACK:
      set_pep_stack_heap ("__size_of_stack_reserve__", "__size_of_stack_commit__");
      break;
    case OPTION_SUBSYSTEM:
      set_pep_subsystem ();
      break;
    case OPTION_MAJOR_OS_VERSION:
      set_pep_value ("__major_os_version__");
      break;
    case OPTION_MINOR_OS_VERSION:
      set_pep_value ("__minor_os_version__");
      break;
    case OPTION_MAJOR_SUBSYSTEM_VERSION:
      set_pep_value ("__major_subsystem_version__");
      break;
    case OPTION_MINOR_SUBSYSTEM_VERSION:
      set_pep_value ("__minor_subsystem_version__");
      break;
    case OPTION_MAJOR_IMAGE_VERSION:
      set_pep_value ("__major_image_version__");
      break;
    case OPTION_MINOR_IMAGE_VERSION:
      set_pep_value ("__minor_image_version__");
      break;
    case OPTION_FILE_ALIGNMENT:
      set_pep_value ("__file_alignment__");
      break;
    case OPTION_SECTION_ALIGNMENT:
      set_pep_value ("__section_alignment__");
      break;
    case OPTION_DLL:
      set_pep_name ("__dll__", 1);
      break;
    case OPTION_IMAGE_BASE:
      set_pep_value ("__image_base__");
      break;
    case OPTION_SUPPORT_OLD_CODE:
      support_old_code = 1;
      break;
    case OPTION_USE_NUL_PREFIXED_IMPORT_TABLES:
      pep_use_nul_prefixed_import_tables = TRUE;
      break;
    case OPTION_NO_LEADING_UNDERSCORE:
      pep_leading_underscore = 0;
      break;
    case OPTION_LEADING_UNDERSCORE:
      pep_leading_underscore = 1;
      break;
#ifdef DLL_SUPPORT
    case OPTION_OUT_DEF:
      pep_out_def_filename = xstrdup (optarg);
      break;
    case OPTION_EXPORT_ALL:
      pep_dll_export_everything = 1;
      break;
    case OPTION_EXCLUDE_SYMBOLS:
      pep_dll_add_excludes (optarg, EXCLUDESYMS);
      break;
    case OPTION_EXCLUDE_ALL_SYMBOLS:
      pep_dll_exclude_all_symbols = 1;
      break;
    case OPTION_EXCLUDE_LIBS:
      pep_dll_add_excludes (optarg, EXCLUDELIBS);
      break;
    case OPTION_EXCLUDE_MODULES_FOR_IMPLIB:
      pep_dll_add_excludes (optarg, EXCLUDEFORIMPLIB);
      break;
    case OPTION_KILL_ATS:
      pep_dll_kill_ats = 1;
      break;
    case OPTION_STDCALL_ALIASES:
      pep_dll_stdcall_aliases = 1;
      break;
    case OPTION_ENABLE_STDCALL_FIXUP:
      pep_enable_stdcall_fixup = 1;
      break;
    case OPTION_DISABLE_STDCALL_FIXUP:
      pep_enable_stdcall_fixup = 0;
      break;
    case OPTION_IMPLIB_FILENAME:
      pep_implib_filename = xstrdup (optarg);
      break;
    case OPTION_WARN_DUPLICATE_EXPORTS:
      pep_dll_warn_dup_exports = 1;
      break;
    case OPTION_IMP_COMPAT:
      pep_dll_compat_implib = 1;
      break;
    case OPTION_ENABLE_AUTO_IMAGE_BASE:
      pep_enable_auto_image_base = 1;
      break;
    case OPTION_DISABLE_AUTO_IMAGE_BASE:
      pep_enable_auto_image_base = 0;
      break;
    case OPTION_DLL_SEARCH_PREFIX:
      pep_dll_search_prefix = xstrdup (optarg);
      break;
    case OPTION_NO_DEFAULT_EXCLUDES:
      pep_dll_do_default_excludes = 0;
      break;
    case OPTION_DLL_ENABLE_AUTO_IMPORT:
      link_info.pei386_auto_import = 1;
      break;
    case OPTION_DLL_DISABLE_AUTO_IMPORT:
      link_info.pei386_auto_import = 0;
      break;
    case OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC:
      link_info.pei386_runtime_pseudo_reloc = 2;
      break;
    case OPTION_DLL_DISABLE_RUNTIME_PSEUDO_RELOC:
      link_info.pei386_runtime_pseudo_reloc = 0;
      break;
    case OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC_V2:
      link_info.pei386_runtime_pseudo_reloc = 2;
      break;
    case OPTION_ENABLE_EXTRA_PE_DEBUG:
      pep_dll_extra_pe_debug = 1;
      break;
#endif
    case OPTION_ENABLE_LONG_SECTION_NAMES:
      pep_use_coff_long_section_names = 1;
      break;
    case OPTION_DISABLE_LONG_SECTION_NAMES:
      pep_use_coff_long_section_names = 0;
      break;
    /*  Get DLLCharacteristics bits  */
    case OPTION_DYNAMIC_BASE:
      pe_dll_characteristics |= IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE;
      break;
    case OPTION_FORCE_INTEGRITY:
      pe_dll_characteristics |= IMAGE_DLL_CHARACTERISTICS_FORCE_INTEGRITY;
      break;
    case OPTION_NX_COMPAT:
      pe_dll_characteristics |= IMAGE_DLL_CHARACTERISTICS_NX_COMPAT;
      break;
    case OPTION_NO_ISOLATION:
      pe_dll_characteristics |= IMAGE_DLLCHARACTERISTICS_NO_ISOLATION;
      break;
    case OPTION_NO_SEH:
      pe_dll_characteristics |= IMAGE_DLLCHARACTERISTICS_NO_SEH;
      break;
    case OPTION_NO_BIND:
      pe_dll_characteristics |= IMAGE_DLLCHARACTERISTICS_NO_BIND;
      break;
    case OPTION_WDM_DRIVER:
      pe_dll_characteristics |= IMAGE_DLLCHARACTERISTICS_WDM_DRIVER;
      break;
    case OPTION_TERMINAL_SERVER_AWARE:
      pe_dll_characteristics |= IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE;
      break;
    }

  /*  Set DLLCharacteristics bits  */
  set_pep_name ("__dll_characteristics__", pe_dll_characteristics);

  return TRUE;
}


#ifdef DLL_SUPPORT
static unsigned long
strhash (const char *str)
{
  const unsigned char *s;
  unsigned long hash;
  unsigned int c;
  unsigned int len;

  hash = 0;
  len = 0;
  s = (const unsigned char *) str;
  while ((c = *s++) != '\0')
    {
      hash += c + (c << 17);
      hash ^= hash >> 2;
      ++len;
    }
  hash += len + (len << 17);
  hash ^= hash >> 2;

  return hash;
}

/* Use the output file to create a image base for relocatable DLLs.  */

static bfd_vma
compute_dll_image_base (const char *ofile)
{
  bfd_vma hash = (bfd_vma) strhash (ofile);
  return NT_DLL_AUTO_IMAGE_BASE + ((hash << 16) & NT_DLL_AUTO_IMAGE_MASK);
}
#endif

/* Assign values to the special symbols before the linker script is
   read.  */

static void
gld_${EMULATION_NAME}_set_symbols (void)
{
  /* Run through and invent symbols for all the
     names and insert the defaults.  */
  int j;

  is_underscoring ();

  if (!init[IMAGEBASEOFF].inited)
    {
      if (link_info.relocatable)
	init[IMAGEBASEOFF].value = 0;
      else if (init[DLLOFF].value || (link_info.shared && !link_info.pie))
	{
#ifdef DLL_SUPPORT
	  init[IMAGEBASEOFF].value = (pep_enable_auto_image_base
				      ? compute_dll_image_base (output_filename)
				      : NT_DLL_IMAGE_BASE);
#else
	  init[IMAGEBASEOFF].value = NT_DLL_IMAGE_BASE;
#endif
	}
      else
	init[IMAGEBASEOFF].value = NT_EXE_IMAGE_BASE;
      init[MSIMAGEBASEOFF].value = init[IMAGEBASEOFF].value;
    }

  /* Don't do any symbol assignments if this is a relocatable link.  */
  if (link_info.relocatable)
    return;

  /* Glue the assignments into the abs section.  */
  push_stat_ptr (&abs_output_section->children);

  for (j = 0; init[j].ptr; j++)
    {
      bfd_vma val = init[j].value;
      lang_assignment_statement_type *rv;

      rv = lang_add_assignment (exp_assign (GET_INIT_SYMBOL_NAME (j),
					    exp_intop (val), FALSE));
      if (init[j].size == sizeof (short))
	*(short *) init[j].ptr = (short) val;
      else if (init[j].size == sizeof (int))
	*(int *) init[j].ptr = (int) val;
      else if (init[j].size == sizeof (long))
	*(long *) init[j].ptr = (long) val;
      /* This might be a long long or other special type.  */
      else if (init[j].size == sizeof (bfd_vma))
	*(bfd_vma *) init[j].ptr = val;
      else	abort ();
      if (j == IMAGEBASEOFF)
	image_base_statement = rv;
    }
  /* Restore the pointer.  */
  pop_stat_ptr ();

  if (pep.FileAlignment > pep.SectionAlignment)
    {
      einfo (_("%P: warning, file alignment > section alignment.\n"));
    }
}

/* This is called after the linker script and the command line options
   have been read.  */

static void
gld_${EMULATION_NAME}_after_parse (void)
{
  /* PR ld/6744:  Warn the user if they have used an ELF-only
     option hoping it will work on PE+.  */
  if (link_info.export_dynamic)
    einfo (_("%P: warning: --export-dynamic is not supported for PE+ "
      "targets, did you mean --export-all-symbols?\n"));

  set_entry_point ();

  after_parse_default ();
}

/* pep-dll.c directly accesses pep_data_import_dll,
   so it must be defined outside of #ifdef DLL_SUPPORT.
   Note - this variable is deliberately not initialised.
   This allows it to be treated as a common varaible, and only
   exist in one incarnation in a multiple target enabled linker.  */
char * pep_data_import_dll;

#ifdef DLL_SUPPORT
static struct bfd_link_hash_entry *pep_undef_found_sym;

static bfd_boolean
pep_undef_cdecl_match (struct bfd_link_hash_entry *h, void *inf)
{
  int sl;
  char *string = inf;
  const char *hs = h->root.string;

  sl = strlen (string);
  if (h->type == bfd_link_hash_defined
      && ((*hs == '@@' && *string == '_'
		   && strncmp (hs + 1, string + 1, sl - 1) == 0)
		  || strncmp (hs, string, sl) == 0)
      && h->root.string[sl] == '@@')
    {
      pep_undef_found_sym = h;
      return FALSE;
    }
  return TRUE;
}

static void
pep_fixup_stdcalls (void)
{
  static int gave_warning_message = 0;
  struct bfd_link_hash_entry *undef, *sym;

  if (pep_dll_extra_pe_debug)
    printf ("%s\n", __FUNCTION__);

  for (undef = link_info.hash->undefs; undef; undef=undef->u.undef.next)
    if (undef->type == bfd_link_hash_undefined)
      {
	char* at = strchr (undef->root.string, '@@');
	int lead_at = (*undef->root.string == '@@');
	if (lead_at)
	  at = strchr (undef->root.string + 1, '@@');
	if (at || lead_at)
	  {
	    /* The symbol is a stdcall symbol, so let's look for a
	       cdecl symbol with the same name and resolve to that.  */
	    char *cname = xstrdup (undef->root.string);

	    if (lead_at)
	      *cname = '_';
	    at = strchr (cname, '@@');
	    if (at)
	      *at = 0;
	    sym = bfd_link_hash_lookup (link_info.hash, cname, 0, 0, 1);

	    if (sym && sym->type == bfd_link_hash_defined)
	      {
		undef->type = bfd_link_hash_defined;
		undef->u.def.value = sym->u.def.value;
		undef->u.def.section = sym->u.def.section;

		if (pep_enable_stdcall_fixup == -1)
		  {
		    einfo (_("Warning: resolving %s by linking to %s\n"),
			   undef->root.string, cname);
		    if (! gave_warning_message)
		      {
			gave_warning_message = 1;
			einfo (_("Use --enable-stdcall-fixup to disable these warnings\n"));
			einfo (_("Use --disable-stdcall-fixup to disable these fixups\n"));
		      }
		  }
	      }
	  }
	else
	  {
	    /* The symbol is a cdecl symbol, so we look for stdcall
	       symbols - which means scanning the whole symbol table.  */
	    pep_undef_found_sym = 0;
	    bfd_link_hash_traverse (link_info.hash, pep_undef_cdecl_match,
				    (char *) undef->root.string);
	    sym = pep_undef_found_sym;
	    if (sym)
	      {
		undef->type = bfd_link_hash_defined;
		undef->u.def.value = sym->u.def.value;
		undef->u.def.section = sym->u.def.section;

		if (pep_enable_stdcall_fixup == -1)
		  {
		    einfo (_("Warning: resolving %s by linking to %s\n"),
			   undef->root.string, sym->root.string);
		    if (! gave_warning_message)
		      {
			gave_warning_message = 1;
			einfo (_("Use --enable-stdcall-fixup to disable these warnings\n"));
			einfo (_("Use --disable-stdcall-fixup to disable these fixups\n"));
		      }
		  }
	      }
	  }
      }
}

static int
make_import_fixup (arelent *rel, asection *s)
{
  struct bfd_symbol *sym = *rel->sym_ptr_ptr;
  char addend[8];
  bfd_vma _addend = 0;
  int suc = 0;

  if (pep_dll_extra_pe_debug)
    printf ("arelent: %s@@%#lx: add=%li\n", sym->name,
	    (unsigned long) rel->address, (long) rel->addend);

  memset (addend, 0, sizeof (addend));
  switch ((rel->howto->bitsize))
    {
      case 8:
        suc = bfd_get_section_contents (s->owner, s, addend, rel->address, 1);
        if (suc && rel->howto->pc_relative)
          _addend = (bfd_vma) ((bfd_signed_vma) ((char) bfd_get_8 (s->owner, addend)));
        else if (suc)
          _addend = ((bfd_vma) bfd_get_8 (s->owner, addend)) & 0xff;
        break;
      case 16:
        suc = bfd_get_section_contents (s->owner, s, addend, rel->address, 2);
        if (suc && rel->howto->pc_relative)
          _addend = (bfd_vma) ((bfd_signed_vma) ((short) bfd_get_16 (s->owner, addend)));
        else if (suc)
          _addend = ((bfd_vma) bfd_get_16 (s->owner, addend)) & 0xffff;
        break;
      case 32:
        suc = bfd_get_section_contents (s->owner, s, addend, rel->address, 4);
        if (suc && rel->howto->pc_relative)
          _addend = (bfd_vma) ((bfd_signed_vma) ((int) bfd_get_32 (s->owner, addend)));
        else if (suc)
          _addend = ((bfd_vma) bfd_get_32 (s->owner, addend)) & 0xffffffff;
        break;
      case 64:
        suc = bfd_get_section_contents (s->owner, s, addend, rel->address, 8);
        if (suc)
          _addend = ((bfd_vma) bfd_get_64 (s->owner, addend));
        break;
    }
  if (! suc)
    einfo (_("%C: Cannot get section contents - auto-import exception\n"),
	   s->owner, s, rel->address);

  if (pep_dll_extra_pe_debug)
    {
      printf ("import of 0x%lx(0x%lx) sec_addr=0x%lx", (long) _addend, (long) rel->addend, (long) rel->address);
      if (rel->howto->pc_relative) printf (" pcrel");
      printf (" %d bit rel.\n",(int) rel->howto->bitsize);
  }
  pep_create_import_fixup (rel, s, _addend);

  return 1;
}

static void
pep_find_data_imports (void)
{
  struct bfd_link_hash_entry *undef, *sym;

  if (link_info.pei386_auto_import == 0)
    return;

  for (undef = link_info.hash->undefs; undef; undef=undef->u.undef.next)
    {
      if (undef->type == bfd_link_hash_undefined)
	{
	  /* C++ symbols are *long*.  */
	  char buf[4096];

	  if (pep_dll_extra_pe_debug)
	    printf ("%s:%s\n", __FUNCTION__, undef->root.string);

	  sprintf (buf, "__imp_%s", undef->root.string);

	  sym = bfd_link_hash_lookup (link_info.hash, buf, 0, 0, 1);

	  if (sym && sym->type == bfd_link_hash_defined)
	    {
	      bfd *b = sym->u.def.section->owner;
	      asymbol **symbols;
	      int nsyms, i;

	      if (!bfd_generic_link_read_symbols (b))
		{
		  einfo (_("%B%F: could not read symbols: %E\n"), b);
		  return;
		}

	      symbols = bfd_get_outsymbols (b);
	      nsyms = bfd_get_symcount (b);

	      for (i = 0; i < nsyms; i++)
		{
		  if (! CONST_STRNEQ (symbols[i]->name, U ("_head_")))
		    continue;

		  if (pep_dll_extra_pe_debug)
		    printf ("->%s\n", symbols[i]->name);

		  pep_data_import_dll = (char*) (symbols[i]->name +
						 U_SIZE ("_head_") - 1);
		  break;
		}

	      pep_walk_relocs_of_symbol (&link_info, undef->root.string,
					 make_import_fixup);

	      /* Let's differentiate it somehow from defined.  */
	      undef->type = bfd_link_hash_defweak;
	      /* We replace original name with __imp_ prefixed, this
		 1) may trash memory 2) leads to duplicate symbol generation.
		 Still, IMHO it's better than having name poluted.  */
	      undef->root.string = sym->root.string;
	      undef->u.def.value = sym->u.def.value;
	      undef->u.def.section = sym->u.def.section;
	    }
	}
    }
}

static bfd_boolean
pr_sym (struct bfd_hash_entry *h, void *inf ATTRIBUTE_UNUSED)
{
  printf ("+%s\n", h->string);

  return TRUE;
}
#endif /* DLL_SUPPORT */

static void
debug_section_p (bfd *abfd ATTRIBUTE_UNUSED, asection *sect, void *obj)
{
  int *found = (int *) obj;
  if (strncmp (".debug_", sect->name, sizeof (".debug_") - 1) == 0)
    *found = 1;
}

static void
gld_${EMULATION_NAME}_after_open (void)
{
  after_open_default ();

  is_underscoring ();
#ifdef DLL_SUPPORT
  if (pep_dll_extra_pe_debug)
    {
      bfd *a;
      struct bfd_link_hash_entry *sym;

      printf ("%s()\n", __FUNCTION__);

      for (sym = link_info.hash->undefs; sym; sym=sym->u.undef.next)
	printf ("-%s\n", sym->root.string);
      bfd_hash_traverse (&link_info.hash->table, pr_sym, NULL);

      for (a = link_info.input_bfds; a; a = a->link_next)
	printf ("*%s\n",a->filename);
    }
#endif

  /* Pass the wacky PE command line options into the output bfd.
     FIXME: This should be done via a function, rather than by
     including an internal BFD header.  */

  if (coff_data (link_info.output_bfd) == NULL
      || coff_data (link_info.output_bfd)->pe == 0)
    einfo (_("%F%P: cannot perform PE operations on non PE output file '%B'.\n"),
	   link_info.output_bfd);

  pe_data (link_info.output_bfd)->pe_opthdr = pep;
  pe_data (link_info.output_bfd)->dll = init[DLLOFF].value;
  pe_data (link_info.output_bfd)->real_flags |= real_flags;

  /* At this point we must decide whether to use long section names
     in the output or not.  If the user hasn't explicitly specified
     on the command line, we leave it to the default for the format
     (object files yes, image files no), except if there is debug
     information present; GDB relies on the long section names to
     find it, so enable it in that case.  */
  if (pep_use_coff_long_section_names < 0 && link_info.strip == strip_none)
    {
      /* Iterate over all sections of all input BFDs, checking
         for any that begin 'debug_' and are long names.  */
      LANG_FOR_EACH_INPUT_STATEMENT (is)
	{
	  int found_debug = 0;
	  bfd_map_over_sections (is->the_bfd, debug_section_p, &found_debug);
	  if (found_debug)
	    {
	      pep_use_coff_long_section_names = 1;
	      break;
	    }
	}
    }

  pep_output_file_set_long_section_names (link_info.output_bfd);

#ifdef DLL_SUPPORT
  if (pep_enable_stdcall_fixup) /* -1=warn or 1=disable */
    pep_fixup_stdcalls ();

  pep_process_import_defs (link_info.output_bfd, &link_info);

  pep_find_data_imports ();

  /* As possibly new symbols are added by imports, we rerun
     stdcall/fastcall fixup here.  */
  if (pep_enable_stdcall_fixup) /* -1=warn or 1=disable */
    pep_fixup_stdcalls ();

#ifndef TARGET_IS_i386pep
  if (link_info.shared)
#else
  if (!link_info.relocatable)
#endif
    pep_dll_build_sections (link_info.output_bfd, &link_info);

#ifndef TARGET_IS_i386pep
  else
    pep_exe_build_sections (link_info.output_bfd, &link_info);
#endif
#endif /* DLL_SUPPORT */

  {
    /* This next chunk of code tries to detect the case where you have
       two import libraries for the same DLL (specifically,
       symbolically linking libm.a and libc.a in cygwin to
       libcygwin.a).  In those cases, it's possible for function
       thunks from the second implib to be used but without the
       head/tail objects, causing an improper import table.  We detect
       those cases and rename the "other" import libraries to match
       the one the head/tail come from, so that the linker will sort
       things nicely and produce a valid import table.  */

    LANG_FOR_EACH_INPUT_STATEMENT (is)
      {
	if (is->the_bfd->my_archive)
	  {
	    int idata2 = 0, reloc_count=0, is_imp = 0;
	    asection *sec;

	    /* See if this is an import library thunk.  */
	    for (sec = is->the_bfd->sections; sec; sec = sec->next)
	      {
		if (strcmp (sec->name, ".idata\$2") == 0)
		  idata2 = 1;
		if (CONST_STRNEQ (sec->name, ".idata\$"))
		  is_imp = 1;
		reloc_count += sec->reloc_count;
	      }

	    if (is_imp && !idata2 && reloc_count)
	      {
		/* It is, look for the reference to head and see if it's
		   from our own library.  */
		for (sec = is->the_bfd->sections; sec; sec = sec->next)
		  {
		    int i;
		    long relsize;
		    asymbol **symbols;
		    arelent **relocs;
		    int nrelocs;

		    relsize = bfd_get_reloc_upper_bound (is->the_bfd, sec);
		    if (relsize < 1)
		      break;

		    if (!bfd_generic_link_read_symbols (is->the_bfd))
		      {
			einfo (_("%B%F: could not read symbols: %E\n"),
			       is->the_bfd);
			return;
		      }
		    symbols = bfd_get_outsymbols (is->the_bfd);

		    relocs = xmalloc ((size_t) relsize);
		    nrelocs = bfd_canonicalize_reloc (is->the_bfd, sec,
						      relocs, symbols);
		    if (nrelocs < 0)
		      {
			free (relocs);
			einfo ("%X%P: unable to process relocs: %E\n");
			return;
		      }

		    for (i = 0; i < nrelocs; i++)
		      {
			struct bfd_symbol *s;
			struct bfd_link_hash_entry * blhe;
			char *other_bfd_filename;
			char *n;

			s = (relocs[i]->sym_ptr_ptr)[0];

			if (s->flags & BSF_LOCAL)
			  continue;

			/* Thunk section with reloc to another bfd.  */
			blhe = bfd_link_hash_lookup (link_info.hash,
						     s->name,
						     FALSE, FALSE, TRUE);

			if (blhe == NULL
			    || blhe->type != bfd_link_hash_defined)
			  continue;

			other_bfd_filename
			  = blhe->u.def.section->owner->my_archive
			    ? bfd_get_filename (blhe->u.def.section->owner->my_archive)
			    : bfd_get_filename (blhe->u.def.section->owner);

			if (filename_cmp (bfd_get_filename
					    (is->the_bfd->my_archive),
					  other_bfd_filename) == 0)
			  continue;

			/* Rename this implib to match the other one.  */
			n = xmalloc (strlen (other_bfd_filename) + 1);
			strcpy (n, other_bfd_filename);
			is->the_bfd->my_archive->filename = n;
		      }

		    free (relocs);
		    /* Note - we do not free the symbols,
		       they are now cached in the BFD.  */
		  }
	      }
	  }
      }
  }

  {
    int is_ms_arch = 0;
    bfd *cur_arch = 0;
    lang_input_statement_type *is2;
    lang_input_statement_type *is3;

    /* Careful - this is a shell script.  Watch those dollar signs! */
    /* Microsoft import libraries have every member named the same,
       and not in the right order for us to link them correctly.  We
       must detect these and rename the members so that they'll link
       correctly.  There are three types of objects: the head, the
       thunks, and the sentinel(s).  The head is easy; it's the one
       with idata2.  We assume that the sentinels won't have relocs,
       and the thunks will.  It's easier than checking the symbol
       table for external references.  */
    LANG_FOR_EACH_INPUT_STATEMENT (is)
      {
	if (is->the_bfd->my_archive)
	  {
	    char *pnt;
	    bfd *arch = is->the_bfd->my_archive;

	    if (cur_arch != arch)
	      {
		cur_arch = arch;
		is_ms_arch = 1;

		for (is3 = is;
		     is3 && is3->the_bfd->my_archive == arch;
		     is3 = (lang_input_statement_type *) is3->next)
		  {
		    /* A MS dynamic import library can also contain static
		       members, so look for the first element with a .dll
		       extension, and use that for the remainder of the
		       comparisons.  */
		    pnt = strrchr (is3->the_bfd->filename, '.');
		    if (pnt != NULL && filename_cmp (pnt, ".dll") == 0)
		      break;
		  }

		if (is3 == NULL)
		  is_ms_arch = 0;
		else
		  {
		    /* OK, found one.  Now look to see if the remaining
		       (dynamic import) members use the same name.  */
		    for (is2 = is;
			 is2 && is2->the_bfd->my_archive == arch;
			 is2 = (lang_input_statement_type *) is2->next)
		      {
			/* Skip static members, ie anything with a .obj
			   extension.  */
			pnt = strrchr (is2->the_bfd->filename, '.');
			if (pnt != NULL && filename_cmp (pnt, ".obj") == 0)
			  continue;

			if (filename_cmp (is3->the_bfd->filename,
					  is2->the_bfd->filename))
			  {
			    is_ms_arch = 0;
			    break;
			  }
		      }
		  }
	      }

	    /* This fragment might have come from an .obj file in a Microsoft
	       import, and not an actual import record. If this is the case,
	       then leave the filename alone.  */
	    pnt = strrchr (is->the_bfd->filename, '.');

	    if (is_ms_arch && (filename_cmp (pnt, ".dll") == 0))
	      {
		int idata2 = 0, reloc_count=0;
		asection *sec;
		char *new_name, seq;

		for (sec = is->the_bfd->sections; sec; sec = sec->next)
		  {
		    if (strcmp (sec->name, ".idata\$2") == 0)
		      idata2 = 1;
		    reloc_count += sec->reloc_count;
		  }

		if (idata2) /* .idata2 is the TOC */
		  seq = 'a';
		else if (reloc_count > 0) /* thunks */
		  seq = 'b';
		else /* sentinel */
		  seq = 'c';

		new_name = xmalloc (strlen (is->the_bfd->filename) + 3);
		sprintf (new_name, "%s.%c", is->the_bfd->filename, seq);
		is->the_bfd->filename = new_name;

		new_name = xmalloc (strlen (is->filename) + 3);
		sprintf (new_name, "%s.%c", is->filename, seq);
		is->filename = new_name;
	      }
	  }
      }
  }
}

static void
gld_${EMULATION_NAME}_before_allocation (void)
{
  is_underscoring ();
  before_allocation_default ();
}

#ifdef DLL_SUPPORT
/* This is called when an input file isn't recognized as a BFD.  We
   check here for .DEF files and pull them in automatically.  */

static int
saw_option (char *option)
{
  int i;

  is_underscoring ();

  for (i = 0; init[i].ptr; i++)
    if (strcmp (GET_INIT_SYMBOL_NAME (i), option) == 0)
      return init[i].inited;
  return 0;
}
#endif /* DLL_SUPPORT */

static bfd_boolean
gld_${EMULATION_NAME}_unrecognized_file (lang_input_statement_type *entry ATTRIBUTE_UNUSED)
{
#ifdef DLL_SUPPORT
  const char *ext = entry->filename + strlen (entry->filename) - 4;

  if (filename_cmp (ext, ".def") == 0 || filename_cmp (ext, ".DEF") == 0)
    {
      pep_def_file = def_file_parse (entry->filename, pep_def_file);

      if (pep_def_file)
	{
	  int i, buflen=0, len;
	  char *buf;

	  for (i = 0; i < pep_def_file->num_exports; i++)
	    {
	      len = strlen (pep_def_file->exports[i].internal_name);
	      if (buflen < len + 2)
		buflen = len + 2;
	    }

	  buf = xmalloc (buflen);

	  for (i = 0; i < pep_def_file->num_exports; i++)
	    {
	      struct bfd_link_hash_entry *h;

	      sprintf (buf, "%s%s", U (""),
		       pep_def_file->exports[i].internal_name);

	      h = bfd_link_hash_lookup (link_info.hash, buf, TRUE, TRUE, TRUE);
	      if (h == (struct bfd_link_hash_entry *) NULL)
		einfo (_("%P%F: bfd_link_hash_lookup failed: %E\n"));
	      if (h->type == bfd_link_hash_new)
		{
		  h->type = bfd_link_hash_undefined;
		  h->u.undef.abfd = NULL;
		  bfd_link_add_undef (link_info.hash, h);
		}
	    }
	  free (buf);

	  /* def_file_print (stdout, pep_def_file); */
	  if (pep_def_file->is_dll == 1)
	    link_info.shared = 1;

	  if (pep_def_file->base_address != (bfd_vma)(-1))
	    {
	      pep.ImageBase
		= pe_data (link_info.output_bfd)->pe_opthdr.ImageBase
		= init[IMAGEBASEOFF].value
		= pep_def_file->base_address;
	      init[IMAGEBASEOFF].inited = 1;
	      if (image_base_statement)
		image_base_statement->exp
		  = exp_assign ("__image_base__", exp_intop (pep.ImageBase),
				FALSE);
	    }

	  if (pep_def_file->stack_reserve != -1
	      && ! saw_option ("__size_of_stack_reserve__"))
	    {
	      pep.SizeOfStackReserve = pep_def_file->stack_reserve;
	      if (pep_def_file->stack_commit != -1)
		pep.SizeOfStackCommit = pep_def_file->stack_commit;
	    }
	  if (pep_def_file->heap_reserve != -1
	      && ! saw_option ("__size_of_heap_reserve__"))
	    {
	      pep.SizeOfHeapReserve = pep_def_file->heap_reserve;
	      if (pep_def_file->heap_commit != -1)
		pep.SizeOfHeapCommit = pep_def_file->heap_commit;
	    }
	  return TRUE;
	}
    }
#endif
  return FALSE;
}

static bfd_boolean
gld_${EMULATION_NAME}_recognized_file (lang_input_statement_type *entry ATTRIBUTE_UNUSED)
{
  is_underscoring ();
#ifdef DLL_SUPPORT
#ifdef TARGET_IS_i386pep
  pep_dll_id_target ("pei-x86-64");
#endif
  if (pep_bfd_is_dll (entry->the_bfd))
    return pep_implied_import_dll (entry->filename);
#endif
  return FALSE;
}

static void
gld_${EMULATION_NAME}_finish (void)
{
  is_underscoring ();
  finish_default ();

#ifdef DLL_SUPPORT
  if (link_info.shared
      || (!link_info.relocatable && pep_def_file->num_exports != 0))
    {
      pep_dll_fill_sections (link_info.output_bfd, &link_info);
      if (pep_implib_filename)
	pep_dll_generate_implib (pep_def_file, pep_implib_filename, &link_info);
    }

  if (pep_out_def_filename)
    pep_dll_generate_def_file (pep_out_def_filename);
#endif /* DLL_SUPPORT */

  /* I don't know where .idata gets set as code, but it shouldn't be.  */
  {
    asection *asec = bfd_get_section_by_name (link_info.output_bfd, ".idata");

    if (asec)
      {
	asec->flags &= ~SEC_CODE;
	asec->flags |= SEC_DATA;
      }
  }
}


/* Place an orphan section.

   We use this to put sections in a reasonable place in the file, and
   to ensure that they are aligned as required.

   We handle grouped sections here as well.  A section named .foo\$nn
   goes into the output section .foo.  All grouped sections are sorted
   by name.

   Grouped sections for the default sections are handled by the
   default linker script using wildcards, and are sorted by
   sort_sections.  */

static lang_output_section_statement_type *
gld_${EMULATION_NAME}_place_orphan (asection *s,
				    const char *secname,
				    int constraint)
{
  const char *orig_secname = secname;
  char *dollar = NULL;
  lang_output_section_statement_type *os;
  lang_statement_list_type add_child;
  lang_output_section_statement_type *match_by_name = NULL;
  lang_statement_union_type **pl;

  /* Look through the script to see where to place this section.  */
  if (!link_info.relocatable
      && (dollar = strchr (secname, '\$')) != NULL)
    {
      size_t len = dollar - secname;
      char *newname = xmalloc (len + 1);
      memcpy (newname, secname, len);
      newname[len] = '\0';
      secname = newname;
    }

  lang_list_init (&add_child);

  os = NULL;
  if (constraint == 0)
    for (os = lang_output_section_find (secname);
	 os != NULL;
	 os = next_matching_output_section_statement (os, 0))
      {
	/* If we don't match an existing output section, tell
	   lang_insert_orphan to create a new output section.  */
	constraint = SPECIAL;

	if (os->bfd_section != NULL
	    && (os->bfd_section->flags == 0
		|| ((s->flags ^ os->bfd_section->flags)
		    & (SEC_LOAD | SEC_ALLOC)) == 0))
	  {
	    /* We already have an output section statement with this
	       name, and its bfd section has compatible flags.
	       If the section already exists but does not have any flags set,
	       then it has been created by the linker, probably as a result of
	       a --section-start command line switch.  */
	    lang_add_section (&add_child, s, NULL, os);
	    break;
	  }

	/* Save unused output sections in case we can match them
	   against orphans later.  */
	if (os->bfd_section == NULL)
	  match_by_name = os;
      }

  /* If we didn't match an active output section, see if we matched an
     unused one and use that.  */
  if (os == NULL && match_by_name)
    {
      lang_add_section (&match_by_name->children, s, NULL, match_by_name);
      return match_by_name;
    }

  if (os == NULL)
    {
      static struct orphan_save hold[] =
	{
	  { ".text",
	    SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_CODE,
	    0, 0, 0, 0 },
	  { ".idata",
	    SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_DATA,
	    0, 0, 0, 0 },
	  { ".rdata",
	    SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_DATA,
	    0, 0, 0, 0 },
	  { ".data",
	    SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_DATA,
	    0, 0, 0, 0 },
	  { ".bss",
	    SEC_ALLOC,
	    0, 0, 0, 0 }
	};
      enum orphan_save_index
	{
	  orphan_text = 0,
	  orphan_idata,
	  orphan_rodata,
	  orphan_data,
	  orphan_bss
	};
      static int orphan_init_done = 0;
      struct orphan_save *place;
      lang_output_section_statement_type *after;
      etree_type *address;

      if (!orphan_init_done)
	{
	  struct orphan_save *ho;
	  for (ho = hold; ho < hold + sizeof (hold) / sizeof (hold[0]); ++ho)
	    if (ho->name != NULL)
	      {
		ho->os = lang_output_section_find (ho->name);
		if (ho->os != NULL && ho->os->flags == 0)
		  ho->os->flags = ho->flags;
	      }
	  orphan_init_done = 1;
	}

      /* Try to put the new output section in a reasonable place based
	 on the section name and section flags.  */

      place = NULL;
      if ((s->flags & SEC_ALLOC) == 0)
	;
      else if ((s->flags & (SEC_LOAD | SEC_HAS_CONTENTS)) == 0)
	place = &hold[orphan_bss];
      else if ((s->flags & SEC_READONLY) == 0)
	place = &hold[orphan_data];
      else if ((s->flags & SEC_CODE) == 0)
	{
	  place = (!strncmp (secname, ".idata\$", 7) ? &hold[orphan_idata]
						     : &hold[orphan_rodata]);
	}
      else
	place = &hold[orphan_text];

      after = NULL;
      if (place != NULL)
	{
	  if (place->os == NULL)
	    place->os = lang_output_section_find (place->name);
	  after = place->os;
	  if (after == NULL)
	    after = lang_output_section_find_by_flags (s, &place->os, NULL);
	  if (after == NULL)
	    /* *ABS* is always the first output section statement.  */
	    after = (&lang_output_section_statement.head
		     ->output_section_statement);
	}

      /* All sections in an executable must be aligned to a page boundary.
	 In a relocatable link, just preserve the incoming alignment; the
	 address is discarded by lang_insert_orphan in that case, anyway.  */
      address = exp_unop (ALIGN_K, exp_nameop (NAME, "__section_alignment__"));
      os = lang_insert_orphan (s, secname, constraint, after, place, address,
			       &add_child);
      if (link_info.relocatable)
	{
	  os->section_alignment = s->alignment_power;
	  os->bfd_section->alignment_power = s->alignment_power;
	}
    }

  /* If the section name has a '\$', sort it with the other '\$'
     sections.  */
  for (pl = &os->children.head; *pl != NULL; pl = &(*pl)->header.next)
    {
      lang_input_section_type *ls;
      const char *lname;

      if ((*pl)->header.type != lang_input_section_enum)
	continue;

      ls = &(*pl)->input_section;

      lname = bfd_get_section_name (ls->section->owner, ls->section);
      if (strchr (lname, '\$') != NULL
	  && (dollar == NULL || strcmp (orig_secname, lname) < 0))
	break;
    }

  if (add_child.head != NULL)
    {
      *add_child.tail = *pl;
      *pl = add_child.head;
    }

  return os;
}

static bfd_boolean
gld_${EMULATION_NAME}_open_dynamic_archive
  (const char *arch ATTRIBUTE_UNUSED,
   search_dirs_type *search,
   lang_input_statement_type *entry)
{
  static const struct
    {
      const char * format;
      bfd_boolean use_prefix;
    }
  libname_fmt [] =
    {
      /* Preferred explicit import library for dll's.  */
      { "lib%s.dll.a", FALSE },
      /* Alternate explicit import library for dll's.  */
      { "%s.dll.a", FALSE },
      /* "libfoo.a" could be either an import lib or a static lib.
          For backwards compatibility, libfoo.a needs to precede
          libfoo.dll and foo.dll in the search.  */
      { "lib%s.a", FALSE },
      /* The 'native' spelling of an import lib name is "foo.lib".  */
      { "%s.lib", FALSE },
#ifdef DLL_SUPPORT
      /* Try "<prefix>foo.dll" (preferred dll name, if specified).  */
      {	"%s%s.dll", TRUE },
#endif
      /* Try "libfoo.dll" (default preferred dll name).  */
      {	"lib%s.dll", FALSE },
      /* Finally try 'native' dll name "foo.dll".  */
      {  "%s.dll", FALSE },
      /* Note: If adding more formats to this table, make sure to check to
	 see if their length is longer than libname_fmt[0].format, and if
	 so, update the call to xmalloc() below.  */
      { NULL, FALSE }
    };
  static unsigned int format_max_len = 0;
  const char * filename;
  char * full_string;
  char * base_string;
  unsigned int i;


  if (! entry->flags.maybe_archive)
    return FALSE;

  filename = entry->filename;

  if (format_max_len == 0)
    /* We need to allow space in the memory that we are going to allocate
       for the characters in the format string.  Since the format array is
       static we only need to calculate this information once.  In theory
       this value could also be computed statically, but this introduces
       the possibility for a discrepancy and hence a possible memory
       corruption.  The lengths we compute here will be too long because
       they will include any formating characters (%s) in the strings, but
       this will not matter.  */
    for (i = 0; libname_fmt[i].format; i++)
      if (format_max_len < strlen (libname_fmt[i].format))
	format_max_len = strlen (libname_fmt[i].format);

  full_string = xmalloc (strlen (search->name)
			 + strlen (filename)
			 + format_max_len
#ifdef DLL_SUPPORT
			 + (pep_dll_search_prefix
			    ? strlen (pep_dll_search_prefix) : 0)
#endif
			 /* Allow for the terminating NUL and for the path
			    separator character that is inserted between
			    search->name and the start of the format string.  */
			 + 2);

  sprintf (full_string, "%s/", search->name);
  base_string = full_string + strlen (full_string);

  for (i = 0; libname_fmt[i].format; i++)
    {
#ifdef DLL_SUPPORT
      if (libname_fmt[i].use_prefix)
	{
	  if (!pep_dll_search_prefix)
	    continue;
	  sprintf (base_string, libname_fmt[i].format, pep_dll_search_prefix, filename);
	}
      else
#endif
	sprintf (base_string, libname_fmt[i].format, filename);

      if (ldfile_try_open_bfd (full_string, entry))
	break;
    }

  if (!libname_fmt[i].format)
    {
      free (full_string);
      return FALSE;
    }

  entry->filename = full_string;

  return TRUE;
}

static int
gld_${EMULATION_NAME}_find_potential_libraries
  (char *name, lang_input_statement_type *entry)
{
  return ldfile_open_file_search (name, entry, "", ".lib");
}

static char *
gld_${EMULATION_NAME}_get_script (int *isfile)
EOF
# Scripts compiled in.
# sed commands to quote an ld script as a C string.
sc="-f stringify.sed"

fragment <<EOF
{
  *isfile = 0;

  if (link_info.relocatable && config.build_constructors)
    return
EOF
sed $sc ldscripts/${EMULATION_NAME}.xu			>> e${EMULATION_NAME}.c
echo '  ; else if (link_info.relocatable) return'	>> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xr			>> e${EMULATION_NAME}.c
echo '  ; else if (!config.text_read_only) return'	>> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xbn			>> e${EMULATION_NAME}.c
echo '  ; else if (!config.magic_demand_paged) return'	>> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xn			>> e${EMULATION_NAME}.c
if test -n "$GENERATE_AUTO_IMPORT_SCRIPT" ; then
echo '  ; else if (link_info.pei386_auto_import == 1 && link_info.pei386_runtime_pseudo_reloc != 2) return'	>> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xa			>> e${EMULATION_NAME}.c
fi
echo '  ; else return'					>> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.x			>> e${EMULATION_NAME}.c
echo '; }'						>> e${EMULATION_NAME}.c

fragment <<EOF


struct ld_emulation_xfer_struct ld_${EMULATION_NAME}_emulation =
{
  gld_${EMULATION_NAME}_before_parse,
  syslib_default,
  hll_default,
  gld_${EMULATION_NAME}_after_parse,
  gld_${EMULATION_NAME}_after_open,
  after_allocation_default,
  set_output_arch_default,
  ldemul_default_target,
  gld_${EMULATION_NAME}_before_allocation,
  gld_${EMULATION_NAME}_get_script,
  "${EMULATION_NAME}",
  "${OUTPUT_FORMAT}",
  gld_${EMULATION_NAME}_finish,
  NULL, /* Create output section statements.  */
  gld_${EMULATION_NAME}_open_dynamic_archive,
  gld_${EMULATION_NAME}_place_orphan,
  gld_${EMULATION_NAME}_set_symbols,
  NULL, /* parse_args */
  gld${EMULATION_NAME}_add_options,
  gld${EMULATION_NAME}_handle_option,
  gld_${EMULATION_NAME}_unrecognized_file,
  gld_${EMULATION_NAME}_list_options,
  gld_${EMULATION_NAME}_recognized_file,
  gld_${EMULATION_NAME}_find_potential_libraries,
  NULL	/* new_vers_pattern.  */
};
EOF
@


1.50
log
@Remove trailing white spaces in ld

	* deffilep.y: Remove trailing white spaces.
	* elf-hints-local.h: Likewise.
	* ldexp.c: Likewise.
	* ldlang.h: Likewise.
	* ldmisc.c: Likewise.
	* ldwrite.c: Likewise.
	* pe-dll.c: Likewise.
	* emulparams/criself.sh: Likewise.
	* emulparams/crislinux.sh: Likewise.
	* emulparams/elf32_tic6x_le.sh: Likewise.
	* emulparams/elf32bmipn32-defs.sh: Likewise.
	* emulparams/elf32mb_linux.sh: Likewise.
	* emulparams/elf32mep.sh: Likewise.
	* emulparams/elf32microblaze.sh: Likewise.
	* emulparams/elf32ppc.sh: Likewise.
	* emulparams/elf64_s390.sh: Likewise.
	* emulparams/elf64alpha.sh: Likewise.
	* emulparams/elf_s390.sh: Likewise.
	* emulparams/elf_x86_64.sh: Likewise.
	* emulparams/tic80coff.sh: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/cr16elf.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/tic6xdsbt.em: Likewise.
@
text
@d8 10
d102 16
d120 15
a134 1
#define NT_EXE_IMAGE_BASE		0x00010000
d851 1
a851 1
  return 0x61300000 + ((hash << 16) & 0x0FFC0000);
@


1.49
log
@	bfd/
	* elflink.c (bfd_elf_record_link_assignment): Remove --defsym
	symbols special case.

	ld/
	* ldexp.h (etree_union): Add defsym member to the assign member
	structure.
	(exp_assign): Add hidden argument to prototype.
	* ldexp.c (exp_fold_tree_1): Use the defsym member to handle
	--defsym symbols.
	(exp_assop): Add defsym argument, initialize the defsym member
	of the assign structure.
	(exp_assign): Handle hidden symbols.
	(exp_defsym): Update to use the defsym argument to exp_assop.
	(exp_provide): Update to handle the defsym argument to exp_assop.
	* ldlex.l (HIDDEN): New token.
	* ldgram.y (HIDDEN): Likewise.
	(assignment, section): Update calls to exp_assign.
	* ldctor.c (ldctor_build_sets): Likewise.
	* mri.c (mri_format): Likewise.
	* ldlang.c (lang_insert_orphan, lang_leave_overlay): Likewise.
	(open_input_bfds): Remove --defsym symbols special case.
	* emultempl/beos.em (gld_${EMULATION_NAME}_set_symbols): Update
	call to exp_assign.
	* emultempl/pe.em (gld_${EMULATION_NAME}_set_symbols): Likewise.
	* emultempl/pep.em (gld_${EMULATION_NAME}_set_symbols): Likewise.
	* emultempl/spuelf.em (spu_place_special_section): Likewise.
	* emultempl/xtensaelf.em (ld_xtensa_insert_page_offsets):
	Likewise.
	* ld.texinfo (Assigning Values to Symbols): Add HIDDEN.
	(HIDDEN): New subsection.
@
text
@d776 1
a776 1
 
d895 1
a895 1
  
d1139 1
a1139 1
static void 
@


1.48
log
@
Add support for PowerPC VLE.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	* NEWS:  Mention PowerPC VLE port.

2012-05-14  James Lemke <jwlemke@@codesourcery.com>
	    Catherine Moore  <clm@@codesourcery.com>

	bfd/
	* bfd.c (bfd_lookup_section_flags): Add section parm.
	* ecoff.c (bfd_debug_section): Remove flag_info initializer.
	* elf-bfd.h (bfd_elf_section_data): Move in section_flag_info.
	(bfd_elf_lookup_section_flags): Add section parm.
	* elf32-ppc.c (is_ppc_vle): New function.
	(ppc_elf_modify_segment_map): New function.
	(elf_backend_modify_segment_map): Define.
	(has_vle_insns): New define.
	* elf32-ppc.h (ppc_elf_modify_segment_map): Declare.
	* elflink.c (bfd_elf_lookup_section_flags): Add return value & parm.
	Move in logic to omit / include a section.
	* libbfd-in.h (bfd_link_info): Add section parm.
	(bfd_generic_lookup_section_flags): Likewise.
	* reloc.c (bfd_generic_lookup_section_flags): Likewise.
	* section.c (bfd_section): Move out section_flag_info.
	(BFD_FAKE_SECTION): Remove flag_info initializer.
	* targets.c (_bfd_lookup_section_flags): Add section parm.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	bfd/
	* archures.c (bfd_mach_ppc_vle): New.
	* bfd-in2.h: Regenerated.
	* cpu-powerpc.c (bfd_powerpc_archs): New entry for vle.
	* elf32-ppc.c (split16_format_type): New enumeration.
	(ppc_elf_vle_split16): New function.
	(HOWTO): Add entries for R_PPC_VLE relocations.
	(ppc_elf_reloc_type_lookup): Handle PPC_VLE relocations.
	(ppc_elf_section_flags): New function.
	(ppc_elf_lookup_section_flags): New function.
	(ppc_elf_section_processing): New function.
	(ppc_elf_check_relocs): Handle PPC_VLE relocations.
	(ppc_elf_relocation_section): Likewise.
	(elf_backend_lookup_section_flags_hook): Define.
	(elf_backend_section_flags): Define.
	(elf_backend_section_processing): Define.
	* elf32-ppc.h (ppc_elf_section_processing): Declare.
	* libbfd.h: Regenerated.
	* reloc.c (BFD_RELOC_PPC_VLE_REL8, BFD_RELOC_PPC_VLE_REL15,
	BFD_RELOC_PPC_VLE_REL24, BFD_RELOC_PPC_VLE_LO16A,
	BFD_RELOC_PPC_VLE_LO16D, BFD_RELOC_PPC_VLE_HI16A,
	BFD_RELOC_PPC_VLE_HI16D, BFD_RELOC_PPC_VLE_HA16A,
	BFD_RELOC_PPC_VLE_HA16D, BFD_RELOC_PPC_VLE_SDA21,
	BFD_RELOC_PPC_VLE_SDA21_LO, BFD_RELOC_PPC_VLE_SDAREL_LO16A,
	BFD_RELOC_PPC_VLE_SDAREL_LO16D, BFD_RELOC_PPC_VLE_SDAREL_HI16A,
	BFD_RELOC_PPC_VLE_SDAREL_HI16D, BFD_RELOC_PPC_VLE_SDAREL_HA16A,
	BFD_RELOC_PPC_VLE_SDAREL_HA16D): New bfd relocations.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	gas/
	* config/tc-ppc.c (insn_validate): New func of existing code to call..
	(ppc_setup_opcodes): ..from 2 places here.
	Revise for second (VLE) opcode table.
	Add #ifdef'd code to print opcode tables.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	gas/
	* config/tc-ppc.c (ppc_setup_opcodes): Allow out-of-order
	for the VLE conditional branches.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>

	gas/
	* config/tc-ppc.c (PPC_VLE_SPLIT16A): New macro.
	(PPC_VLE_SPLIT16D): New macro.
	(PPC_VLE_LO16A): New macro.
	(PPC_VLE_LO16D): New macro.
	(PPC_VLE_HI16A): New macro.
	(PPC_VLE_HI16D): New macro.
	(PPC_VLE_HA16A): New macro.
	(PPC_VLE_HA16D): New macro.
	(PPC_APUINFO_VLE): New definition.
	(md_chars_to_number): New function.
	(md_parse_option): Check for combinations of little
	endian and -mvle.
	(md_show_usage): Document -mvle.
	(ppc_arch): Recognize VLE.
	(ppc_mach): Recognize bfd_mach_ppc_vle.
	(ppc_setup_opcodes): Print the opcode table if
	* config/tc-ppc.h (ppc_frag_check): Declare.
	* doc/c-ppc.texi: Document -mvle.
	* NEWS:  Mention PowerPC VLE port.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	gas/
	* config/tc-ppc.h (ppc_dw2_line_min_insn_length): Declare.
	(DWARF2_LINE_MIN_INSN_LENGTH): Redefine.
	* config/tc-ppc.c (ppc_dw2_line_min_insn_length): New.
	* dwarf2dbg.c (scale_addr_delta): Handle values of 1
	for DWARF2_LINE_MIN_INSN_LENGTH.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>

	gas/testsuite/
	* gas/ppc/ppc.exp: Run new tests.
	* gas/ppc/vle-reloc.d: New test.
	* gas/ppc/vle-reloc.s: New test.
	* gas/ppc/vle-simple-1.d: New test.
	* gas/ppc/vle-simple-1.s: New test.
	* gas/ppc/vle-simple-2.d: New test.
	* gas/ppc/vle-simple-2.s: New test.
	* gas/ppc/vle-simple-3.d: New test.
	* gas/ppc/vle-simple-3.s: New test.
	* gas/ppc/vle-simple-4.d: New test.
	* gas/ppc/vle-simple-4.s: New test.
	* gas/ppc/vle-simple-5.d: New test.
	* gas/ppc/vle-simple-5.s: New test.
	* gas/ppc/vle-simple-6.d: New test.
	* gas/ppc/vle-simple-6.s: New test.
	* gas/ppc/vle.d: New test.
	* gas/ppc/vle.s: New test.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>
	include/elf/
	* ppc.h (SEC_PPC_VLE): Remove.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
	    James Lemke  <jwlemke@@codesourcery.com>

	include/elf/
	* ppc.h (R_PPC_VLE_REL8): New reloction.
	(R_PPC_VLE_REL15): Likewise.
	(R_PPC_VLE_REL24): Likewise.
	(R_PPC_VLE_LO16A): Likewise.
	(R_PPC_VLE_LO16D): Likewise.
	(R_PPC_VLE_HI16A): Likewise.
	(R_PPC_VLE_HI16D): Likewise.
	(R_PPC_VLE_HA16A): Likewise.
	(R_PPC_VLE_HA16D): Likewise.
	(R_PPC_VLE_SDA21): Likewise.
	(R_PPC_VLE_SDA21_LO): Likewise.
	(R_PPC_VLE_SDAREL_LO16A): Likewise.
	(R_PPC_VLE_SDAREL_LO16D): Likewise.
	(R_PPC_VLE_SDAREL_HI16A): Likewise.
	(R_PPC_VLE_SDAREL_HI16D): Likewise.
	(R_PPC_VLE_SDAREL_HA16A): Likewise.
	(R_PPC_VLE_SDAREL_HA16D): Likewise.
	(SEC_PPC_VLE): Remove.
	(PF_PPC_VLE): New program header flag.
	(SHF_PPC_VLE): New section header flag.
	(vle_opcodes, vle_num_opcodes): New.
	(VLE_OP): New macro.
	(VLE_OP_TO_SEG): New macro.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>

	include/opcode/
	* ppc.h (PPC_OPCODE_VLE): New definition.
	(PPC_OP_SA): New macro.
	(PPC_OP_SE_VLE): New macro.
	(PPC_OP): Use a variable shift amount.
	(powerpc_operand): Update comments.
	(PPC_OPSHIFT_INV): New macro.
	(PPC_OPERAND_CR): Replace with...
	(PPC_OPERAND_CR_BIT): ...this and
	(PPC_OPERAND_CR_REG): ...this.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	ld/
	* ldlang.c (walk_wild_consider_section): Don't copy section_flag_list.
	Pass it to callback.
	(walk_wild_section_general): Pass section_flag_list to callback.
	(lang_add_section): Add sflag_list parm.
	Move out logic to keep / omit a section & call bfd_lookup_section_flags.
	(output_section_callback_fast): Add sflag_list parm.
	Add new parm to lang_add_section calls.
	(output_section_callback): Likewise.
	(check_section_callback): Add sflag_list parm.
	(lang_place_orphans): Add new parm to lang_add_section calls.
	(gc_section_callback): Add sflag_list parm.
	(find_relro_section_callback): Likewise.
	* ldlang.h (callback_t): Add flag_info parm.
	(lang_add_section): Add sflag_list parm.
	* emultempl/armelf.em (elf32_arm_add_stub_section):
	Add lang_add_section parm.
	* emultempl/beos.em (gld*_place_orphan): Likewise.
	* emultempl/elf32.em (gld*_place_orphan): Likewise.
	* emultempl/hppaelf.em (hppaelf_add_stub_section): Likewise.
	* emultempl/m68hc1xelf.em (m68hc11elf_add_stub_section): Likewise.
	* emultempl/mipself.em (mips_add_stub_section): Likewise.
	* emultempl/mmo.em (mmo_place_orphan): Likewise.
	* emultempl/pe.em (gld_*_place_orphan): Likewise.
	* emultempl/pep.em (gld_*_place_orphan): Likewise.
	* emultempl/ppc64elf.em (ppc_add_stub_section): Likewise.
	* emultempl/spuelf.em (spu_place_special_section): Likewise.
	* emultempl/vms.em (vms_place_orphan): Likewise.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	ld/testsuite/
	* ld-powerpc/powerpc.exp: Create ppceabitests.
	* ld-powerpc/vle-multiseg.s: New.
	* ld-powerpc/vle-multiseg-1.d: New.
	* ld-powerpc/vle-multiseg-1.ld: New.
	* ld-powerpc/vle-multiseg-2.d: New.
	* ld-powerpc/vle-multiseg-2.ld: New.
	* ld-powerpc/vle-multiseg-3.d: New.
	* ld-powerpc/vle-multiseg-3.ld: New.
	* ld-powerpc/vle-multiseg-4.d: New.
	* ld-powerpc/vle-multiseg-4.ld: New.
	* ld-powerpc/vle-multiseg-5.d: New.
	* ld-powerpc/vle-multiseg-5.ld: New.
	* ld-powerpc/vle-multiseg-6.d: New.
	* ld-powerpc/vle-multiseg-6.ld: New.
	* ld-powerpc/vle-multiseg-6a.s: New.
	* ld-powerpc/vle-multiseg-6b.s: New.
	* ld-powerpc/vle-multiseg-6c.s: New.
	* ld-powerpc/vle-multiseg-6d.s: New.
	* ld-powerpc/powerpc.exp: Run new tests.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	ld/
	* NEWS:  Mention PowerPC VLE port.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	ld/testsuite/
	* ld-powerpc/apuinfo.rd: Update for VLE.
	* ld-powerpc/vle-reloc-1.d: New.
	* ld-powerpc/vle-reloc-1.s: New.
	* ld-powerpc/vle-reloc-2.d: New.
	* ld-powerpc/vle-reloc-2.s: New.
	* ld-powerpc/vle-reloc-3.d: New.
	* ld-powerpc/vle-reloc-3.s: New.
	* ld-powerpc/vle-reloc-def-1.s: New.
	* ld-powerpc/vle-reloc-def-2.s: New.
	* ld-powerpc/vle-reloc-def-3.s: New.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	opcodes/
	* ppc-dis.c (get_powerpc_dialect): Use is_ppc_vle.
	(PPC_OPCD_SEGS, VLE_OPCD_SEGS): New defines.
	(vle_opcd_indices): New array.
	(lookup_vle): New function.
	(disassemble_init_powerpc): Revise for second (VLE) opcode table.
	(print_insn_powerpc): Likewise.
	* ppc-opc.c: Likewise.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>
	    Nathan Froyd <froydnj@@codesourcery.com>

	opcodes/
	* ppc-opc.c (insert_arx, extract_arx): New functions.
	(insert_ary, extract_ary): New functions.
	(insert_li20, extract_li20): New functions.
	(insert_rx, extract_rx): New functions.
	(insert_ry, extract_ry): New functions.
	(insert_sci8, extract_sci8): New functions.
	(insert_sci8n, extract_sci8n): New functions.
	(insert_sd4h, extract_sd4h): New functions.
	(insert_sd4w, extract_sd4w): New functions.
	(insert_vlesi, extract_vlesi): New functions.
	(insert_vlensi, extract_vlensi): New functions.
	(insert_vleui, extract_vleui): New functions.
	(insert_vleil, extract_vleil): New functions.
 	(BI_MASK, BB_MASK, BT): Use PPC_OPERAND_CR_BIT.
 	(BI16, BI32, BO32, B8): New.
	(B15, B24, CRD32, CRS): New.
 	(CRD, OBF, BFA, CR, CRFS): Use PPC_OPERAND_CR_REG.
	(DB, IMM20, RD, Rx, ARX, RY, RZ): New.
	(ARY, SCLSCI8, SCLSCI8N, SE_SD, SE_SDH): New.
	(SH6_MASK): Use PPC_OPSHIFT_INV.
	(SI8, UI5, OIMM5, UI7, BO16): New.
	(VLESIMM, VLENSIMM, VLEUIMM, VLEUIMML): New.
	(XT6, XA6, XB6, XB6S, XC6): Use PPC_OPSHIFT_INV.
	(ALLOW8_SPRG): New.
	(insert_sprg, extract_sprg): Check ALLOW8_SPRG.
	(OPVUP, OPVUP_MASK OPVUP): New
	(BD8, BD8_MASK, BD8IO, BD8IO_MASK): New.
	(EBD8IO, EBD8IO1_MASK, EBD8IO2_MASK, EBD8IO3_MASK): New.
	(BD15, BD15_MASK, EBD15, EBD15_MASK, EBD15BI, EBD15BI_MASK): New.
	(BD24,BD24_MASK, C_LK, C_LK_MASK, C, C_MASK): New.
 	(IA16, IA16_MASK, I16A, I16A_MASK, I16L, I16L_MASK): New.
	(IM7, IM7_MASK, LI20, LI20_MASK, SCI8, SCI8_MASK): New.
	(SCI8BF, SCI8BF_MASK, SD4, SD4_MASK): New.
	(SE_IM5, SE_IM5_MASK): New.
	(SE_R, SE_R_MASK, SE_RR, SE_RR_MASK): New.
	(EX, EX_MASK, BO16F, BO16T, BO32F, BO32T): New.
	(BO32DNZ, BO32DZ): New.
	(NO371, PPCSPE, PPCISEL, PPCEFS, MULHW): Include PPC_OPCODE_VLE.
	(PPCVLE): New.
	(powerpc_opcodes): Add new VLE instructions.  Update existing
	instruction to include PPCVLE if supported.
	* ppc-dis.c (ppc_opts): Add vle entry.
	(get_powerpc_dialect): New function.
	(powerpc_init_dialect): VLE support.
	(print_insn_big_powerpc): Call get_powerpc_dialect.
	(print_insn_little_powerpc): Likewise.
	(operand_value_powerpc): Handle negative shift counts.
	(print_insn_powerpc): Handle 2-byte instruction lengths.
@
text
@d859 1
a859 1
					    exp_intop (val)));
d1525 3
a1527 2
		image_base_statement->exp = exp_assign ("__image_base__",
							exp_intop (pep.ImageBase));
@


1.48.2.1
log
@bfd/
2012-08-09  Maciej W. Rozycki  <macro@@codesourcery.com>

	* elfxx-mips.c (LA25_LUI_MICROMIPS_1, LA25_LUI_MICROMIPS_2):
	Remove macros, folding them into...
	(LA25_LUI_MICROMIPS): ... this new macro.
	(LA25_J_MICROMIPS_1, LA25_J_MICROMIPS_2): Likewise into...
	(LA25_J_MICROMIPS): ... this new macro.
	(LA25_ADDIU_MICROMIPS_1, LA25_ADDIU_MICROMIPS_2): Likewise
	into...
	(LA25_ADDIU_MICROMIPS): ... this new macro.
	(bfd_put_micromips_32, bfd_get_micromips_32): New functions.
	(mips_elf_create_la25_stub): Use them.
	(check_br32_dslot, check_br32, check_relocated_bzc): Likewise.
	(_bfd_mips_elf_relax_section): Likewise.

gas/
	* config/tc-mips.c (NO_ISA_COP, COP_INSN): Remove macros.
	(is_opcode_valid): Remove coprocessor instruction exclusions.
	Replace OPCODE_IS_MEMBER with opcode_is_member.
	(is_opcode_valid_16): Replace OPCODE_IS_MEMBER with
	opcode_is_member.
	(macro): Remove coprocessor instruction exclusions.

gas/
	* gas/mips/mips.exp: Set has_newabi for all Linux targets.
	* gas/mips/cfi-n64-1.d: Adjust for targets that do not infer the
	ISA from the ABI.
	* gas/mips/elf-rel-got-n32.d: Likewise.
	* gas/mips/elf-rel-got-n64.d: Likewise.
	* gas/mips/elf-rel-xgot-n32.d: Likewise.
	* gas/mips/elf-rel-xgot-n64.d: Likewise.
	* gas/mips/elf-rel18.d: Likewise.
	* gas/mips/elf-rel28-n32.d: Likewise.
	* gas/mips/elf-rel28-n64.d: Likewise.
	* gas/mips/jal-newabi.d: Likewise.
	* gas/mips/ldstla-n64-shared.d: Likewise.
	* gas/mips/ldstla-n64-sym32.d: Likewise.
	* gas/mips/ldstla-n64.d: Likewise.
	* gas/mips/macro-warn-1-n32.d: Likewise.
	* gas/mips/macro-warn-2-n32.d: Likewise.
	* gas/mips/n32-consec.d: Likewise.

include/
2012-08-13  Richard Sandiford  <rdsandiford@@googlemail.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips.h (mips_opcode): Add the exclusions field.
	(OPCODE_IS_MEMBER): Remove macro.
	(cpu_is_member): New inline function.
	(opcode_is_member): Likewise.

ld/
	* emulparams/elf32bmip.sh: Make _gp hidden.
	* emulparams/elf32bmipn32-defs.sh: Likewise.
	* emulparams/elf32mipswindiss.sh: Likewise.
	* scripttempl/mips.sc: Likewise.

ld/
2012-08-28  Maciej W. Rozycki  <macro@@codesourcery.com>

	* ld-elf/export-class.sd: New test.
	* ld-elf/export-class.vd: New test.
	* ld-elf/export-class-def.s: New test source.
	* ld-elf/export-class-dep.s: New test source.
	* ld-elf/export-class-lib.s: New test source.
	* ld-elf/export-class-ref.s: New test source.
	* ld-elf/export-class-lib.ver: New test version script.
	* ld-elf/export-class.exp: New test script.
	* ld-arm/arm-export-class.rd: New test.
	* ld-arm/arm-export-class.xd: New test.
	* ld-arm/export-class.exp: New test script.
	* ld-i386/i386-export-class.rd: New test.
	* ld-i386/i386-export-class.xd: New test.
	* ld-i386/export-class.exp: New test script.
	* ld-mips-elf/mips-32-export-class.rd: New test.
	* ld-mips-elf/mips-32-export-class.xd: New test.
	* ld-mips-elf/mips-64-export-class.rd: New test.
	* ld-mips-elf/mips-64-export-class.xd: New test.
	* ld-mips-elf/export-class.exp: New test script.
	* ld-powerpc/powerpc-32-export-class.rd: New test.
	* ld-powerpc/powerpc-32-export-class.xd: New test.
	* ld-powerpc/powerpc-64-export-class.rd: New test.
	* ld-powerpc/powerpc-64-export-class.xd: New test.
	* ld-powerpc/export-class.exp: New test script.
	* ld-x86-64/x86-64-64-export-class.rd: New test.
	* ld-x86-64/x86-64-x32-export-class.rd: New test.
	* ld-x86-64/export-class.exp: New test script.

opcodes/
2012-08-14  Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips-dis.c (print_insn_args): Add GET_OP and GET_OP_S local
	macros, use local variables for info struct member accesses,
	update the type of the variable used to hold the instruction
	word.
	(print_insn_mips, print_mips16_insn_arg): Likewise.
	(print_insn_mips16): Add GET_OP and GET_OP_S local macros, use
	local variables for info struct member accesses.
	(print_insn_micromips): Add GET_OP_S local macro.
	(_print_insn_mips): Update the type of the variable used to hold
	the instruction word.
@
text
@d859 1
a859 1
					    exp_intop (val), FALSE));
d1525 2
a1526 3
		image_base_statement->exp
		  = exp_assign ("__image_base__", exp_intop (pep.ImageBase),
				FALSE);
@


1.47
log
@	* ldlang.h (struct lang_input_statement_flags): New, extract from..
	(lang_input_statement_type): ..here.  New field "flags".
	(input_flags): Declare.
	(missing_file): Delete.
	* ldmain.h (whole_archive): Delete.
	(add_DT_NEEDED_for_regular, add_DT_NEEDED_for_dynamic): Delete.
	* ld.h (ld_config_type <dynamic_link>): Delete.
	* ldmain.c (whole_archive): Delete.
	(add_DT_NEEDED_for_regular, add_DT_NEEDED_for_dynamic): Delete.
	* ldlang.c (missing_file, ldlang_sysrooted_script): Delete.
	(input_flags): New variable.  Replace all uses of config.dynamic_link,
	missing_file, ldlang_sysrooted_script, whole_archive,
	add_DT_NEEDED_for_regular and add_DT_NEEDED_for_dynamic with fields
	from here.
	* ldfile.c: Likewise.
	* ldgram.y: Likewise.
	* ldmain.c: Likewise.
	* ldwrite.c: Likewise.
	* lexsup.c: Likewise.
	* plugin.c: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vms.em: Likewise.
	* ldlang.c (new_afile): Use memset to init zero fields.
	(load_symbols): Simplify save and restore of flags around command
	file processing.
	* ldfile.c (is_sysrooted_pathname): Tidy.
@
text
@d1654 1
a1654 1
	    lang_add_section (&add_child, s, os);
d1668 1
a1668 1
      lang_add_section (&match_by_name->children, s, match_by_name);
@


1.46
log
@	* ldlang.c (sort_def_symbol, lang_one_common): Don't handle
	warning symbols here.
	* emultempl/pe.em (pr_sym): Remove redundant test.
	* emultempl/pep.em (pr_sym): Likewise.
@
text
@d11 1
a11 1
/* Copyright 2006, 2007, 2008, 2009, 2010, 2011
d142 1
a142 1
  config.dynamic_link = TRUE;
d1833 1
a1833 1
  if (! entry->maybe_archive)
@


1.45
log
@[PATCH] Fix PE-COFF bug in orphan section alignment handling.

ld/ChangeLog:

2011-03-10  Dave Korn  <dave.korn.cygwin@@gmail.com>

	* emultempl/pe.em (gld_${EMULATION_NAME}_place_orphan): Preserve
	alignment of input sections when creating orphan output sections
	during relocatable link.
	* emultempl/pep.em (gld_${EMULATION_NAME}_place_orphan): Likewise.
@
text
@d1133 1
a1133 2
  if (pep_dll_extra_pe_debug)
    printf ("+%s\n", h->string);
@


1.44
log
@2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* emultempl/beos.em (sort_by_file_name): Use filename_(n)cmp.
	* emultempl/elf32.em (gld${EMULATION_NAME}_vercheck):
	Likewise.
	(gld${EMULATION_NAME}_stat_needed): Likewise.
	(gld${EMULATION_NAME}_check_needed): Likewise.
	* emultempl/pe.em (gld_${EMULATION_NAME}_after_open): Likewise.
	(gld_${EMULATION_NAME}_unrecognized_file): Likewise.
	* emultempl/pep.em (gld_${EMULATION_NAME}_after_open): Likewise.
	(gld_${EMULATION_NAME}_unrecognized_file): Likewise.
	* ldfile.c (ldfile_open_file): Likewise.
	* ldlang.c (wild_sort): Likewise.
	(lookup_name): Likewise.
	(check_excluded_libs): Likewise.
	* ldmisc.c (vfinfo): Likewise.
	* pe-dll.c (libnamencmp): Likewise.
	(auto_export): Likewise.
	(pe_dll_generate_implib): Likewise.
	* testplug.c (onclaim_file): Likewise.
@
text
@d1751 3
a1753 1
      /* All sections in an executable must be aligned to a page boundary.  */
d1757 5
@


1.43
log
@	* ldmain.c (main): Flush stdout before and stderr after printing
	message.
	* ldmisc.c (einfo): Similarly.
	* plugin.c (message): Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
	* emulparams/elf32mcore.sh: Use einfo rather than printf.
	* emultempl/beos.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
@
text
@d47 1
d1322 3
a1324 2
			if (strcmp (bfd_get_filename (is->the_bfd->my_archive),
				    other_bfd_filename) == 0)
d1378 1
a1378 1
		    if (pnt != NULL && strcmp (pnt, ".dll") == 0)
d1395 1
a1395 1
			if (pnt != NULL && strcmp (pnt, ".obj") == 0)
d1398 2
a1399 2
			if (strcmp (is3->the_bfd->filename,
				    is2->the_bfd->filename))
d1413 1
a1413 1
	    if (is_ms_arch && (strcmp (pnt, ".dll") == 0))
d1477 1
a1477 1
  if (strcmp (ext, ".def") == 0 || strcmp (ext, ".DEF") == 0)
@


1.42
log
@	PR ld/12356
	* ldexp.h (exp_assop): Delete.
	(exp_assign, exp_defsym): Declare.
	* ldexp.c (exp_assop): Make static, handle all assignment variations.
	(exp_assign, exp_defsym): New functions.
	(exp_provide): Use exp_assop.
	* ldgram.y (defsym_expr): Use exp_defsym.
	* ldctor.c, * ldgram.y, * ldlang.c, * mri.c, * emultempl/beos.em,
	* emultempl/pe.em, * emultempl/pep.em, * emultempl/spuelf.em,
	* emultempl/xtensaelf.em: Update exp_assop -> exp_assign.
@
text
@d614 1
a614 6
	{
	  /* xgettext:c-format */
	  fprintf (stderr, _("%s: Can't open base file %s\n"),
		   program_name, optarg);
	  xexit (1);
	}
@


1.41
log
@	* ld.texinfo (Expression Section): Describe treatment of numbers
	and absolute symbols.
	* ldemul.c (after_open_default): Look up __ld_compatibility.
	* ldexp.c (fold_name): Convert absolute symbols to numbers when
	inside output section definitions, or when __ld_compatibility >= 221.
	(exp_fold_tree_1): Convert numbers to absolute when not in output
	section definition and __ld_compatibility < 221.  Don't always
	convert values outside an output section definition to absolute.
	* ldexp.h (uses_defined): Comment.
	* ldlang.c (ld_compatibility): New variable.
	* ldlang.h (ld_compatibility): Declare.
	* emultempl/aix.em, * emultempl/armcoff.em, * emultempl/beos.em,
	* emultempl/elf32.em, * emultempl/genelf.em, * emultempl/lnk960.em,
	* emultempl/m68kcoff.em, * emultempl/mmo.em, * emultempl/pe.em,
	* emultempl/pep.em, * emultempl/sunos.em, * emultempl/z80.em: Call
	after_open_default from after_open function.
@
text
@d11 2
a12 1
/* Copyright 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
d862 2
a863 2
      rv = lang_add_assignment (exp_assop ('=', GET_INIT_SYMBOL_NAME (j),
					   exp_intop (val)));
d1529 2
a1530 2
		image_base_statement->exp = exp_assop ('=', "__image_base__",
						       exp_intop (pep.ImageBase));
@


1.40
log
@Replace is_archive with maybe_archive.

2010-12-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldfile.c (ldfile_open_file_search): Check maybe_archive instead
	of is_archive.
	* emultempl/aix.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vms.em: Likewise.

	* ldlang.c (new_afile): Set maybe_archive instead of is_archive..

	* ldlang.h (lang_input_statement_struct): Replace is_archive
	with maybe_archive.
@
text
@d1154 2
@


1.39
log
@	* emultempl/pe.em (_list_options): Correct typo.
	* emultempl/pep.em (_list_options): Likewise.
@
text
@d1827 1
a1827 1
  if (! entry->is_archive)
@


1.38
log
@2010-09-22  Kai Tietz  <kai.tietz@@onevision.com>

        * emultempl/pe.em (gld_${EMULATION_NAME}_place_orphan): Add
        idata to orphan set.
        * emultempl/pep.em: Likewise.
        * scripttempl/armcoff.sc: Separate idata
        and add __IAT_start__ and __IAT_end__ labels.
        * scripttempl/pe.sc: Likewise.
        * scripttempl/pep.sc: Likewise.
@
text
@d11 1
a11 1
/* Copyright 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d386 1
a386 1
  fprintf (file, _("  --enable-auto-import               Do sophistcated linking of _sym to\n\
@


1.38.2.1
log
@backport from mainline
@
text
@d11 1
a11 1
/* Copyright 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
d613 6
a618 1
	einfo (_("%F%P: cannot open base file %s\n"), optarg);
d861 2
a862 2
      rv = lang_add_assignment (exp_assign (GET_INIT_SYMBOL_NAME (j),
					    exp_intop (val)));
a1153 2
  after_open_default ();

d1526 2
a1527 2
		image_base_statement->exp = exp_assign ("__image_base__",
							exp_intop (pep.ImageBase));
d1827 1
a1827 1
  if (! entry->maybe_archive)
@


1.38.2.2
log
@	PR 12365
	PR 12613
	PR 12632
	PR 12739
	PR 12753
	PR 12760
	PR 12763
Apply fix from mainline along with assorted other small fixes.
@
text
@d1748 1
a1748 3
      /* All sections in an executable must be aligned to a page boundary.
	 In a relocatable link, just preserve the incoming alignment; the
	 address is discarded by lang_insert_orphan in that case, anyway.  */
a1751 5
      if (link_info.relocatable)
	{
	  os->section_alignment = s->alignment_power;
	  os->bfd_section->alignment_power = s->alignment_power;
	}
@


1.37
log
@2010-05-25  Kai Tietz  <kai.tietz@@onevision.com>

        * emultempl/pep.em (gld_${EMULATION_NAME}_before_parse): Enable by
        default auto_import.
        (gld${EMULATION_NAME}_handle_option): Warn about v1.
        (pep_find_data_imports): Remove superflous warnings about
        auto-import.
        (gld_${EMULATION_NAME}_get_script): Don't merge for auto-import
        and active pseudo-relocation-v2 rdata into data section.
@
text
@d1680 3
d1696 1
d1730 4
a1733 1
	place = &hold[orphan_rodata];
@


1.36
log
@2010-05-15  Kai Tietz  <kai.tietz@@onevision.com>

	* emultempl/pe.em (is_underscoring): New helper function.
	(gld_${EMULATION_NAME}_before_parse): Replace code
	for pe(p)_leading_underscore detection by is_underscoring.
	(U): Likewise.
	(GET_INIT_SYMBOL_NAME): Likewise.
	(U_SIZE): Likewise.
	(set_pe_name):
	(set_entry_point):
	(gld_${EMULATION_NAME}_set_symbols):
	* emultempl/pep.em: Likewise.
	* pe-dll.c (pe_detail_list): Set default
	underscoring for x64 target.
	(pe_dll_id_target): Add initialization of
	pe(p)_leading_underscore.
@
text
@d142 1
a142 1
  link_info.pei386_auto_import = -1;
a187 1
  OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC_V1,
a264 1
    {"enable-runtime-pseudo-reloc-v1", no_argument, NULL, OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC_V1},
a736 3
    case OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC_V1:
      link_info.pei386_runtime_pseudo_reloc = 1;
      break;
a1094 16
	      if (link_info.pei386_auto_import == -1)
		{
		  static bfd_boolean warned = FALSE;

		  info_msg (_("Info: resolving %s by linking to %s (auto-import)\n"),
			    undef->root.string, buf);

		  /* PR linker/4844.  */
		  if (! warned)
		    {
		      warned = TRUE;
		      einfo (_("%P: warning: auto-importing has been activated without --enable-auto-import specified on the command line.\n\
This should work unless it involves constant data structures referencing symbols from auto-imported DLLs.\n"));
		    }
		}

d1910 1
a1910 1
echo '  ; else if (link_info.pei386_auto_import == 1) return'	>> e${EMULATION_NAME}.c
@


1.35
log
@2010-05-11  Kai Tietz  <kai.tietz@@onevision.com>

        * emultempl/pe.em (gld_${EMULATION_NAME}_before_parse):
        Initialize pe(p)_leading_underscore variable.
        (set_pe_name): Likewise.
        * emultempl/pep.em: Likewise.
        Additional change default to non-underscore for
        pep_leading_underscore equal to -1.
@
text
@d118 1
a118 2
static void
gld_${EMULATION_NAME}_before_parse (void)
d120 4
a123 5
  int u;
  /* Now we check target's default for getting proper symbol_char.  */
  u = pep_leading_underscore;
  if (u == -1
      && !bfd_get_target_info ("${OUTPUT_FORMAT}", NULL, NULL, &u, NULL))
d128 3
a130 1
  pep_leading_underscore = u;
d132 5
d305 1
a305 1
  + ((init[(IDX)].is_c_symbol == FALSE || pep_leading_underscore == 1) ? 0 : 1))
d309 1
a309 1
  (pep_leading_underscore != 1 ? CSTR : "_" CSTR)
d314 1
a314 1
  (sizeof (CSTR) + pep_leading_underscore == 1 ? 0 : 1)
d419 2
a420 12
  int i, u;

  /* Now we check target's default for getting proper symbol_char.  */
  u = pep_leading_underscore;
  if (u == -1
      && !bfd_get_target_info ("${OUTPUT_FORMAT}", NULL, NULL, &u, NULL))
    bfd_get_target_info ("${RELOCATEABLE_OUTPUT_FORMAT}", NULL, NULL, &u, NULL);

  if (u == -1)
    abort ();
  pep_leading_underscore = u;

d441 1
a441 1
  int i, u = -1;
d480 1
a480 9
  u = pep_leading_underscore;
  if (u == -1
      && !bfd_get_target_info ("${OUTPUT_FORMAT}", NULL, NULL, &u, NULL))
    bfd_get_target_info ("${RELOCATEABLE_OUTPUT_FORMAT}", NULL, NULL, &u, NULL);

  if (u == -1)
    abort ();
  initial_symbol_char = (u == 1 ? "_" : "");
  pep_leading_underscore = u;
d606 1
d831 1
a831 6
  int j, u;
  /* Now we check target's default for getting proper symbol_char.  */
  u = pep_leading_underscore;
  if (u == -1
      && !bfd_get_target_info ("${OUTPUT_FORMAT}", NULL, NULL, &u, NULL))
    bfd_get_target_info ("${RELOCATEABLE_OUTPUT_FORMAT}", NULL, NULL, &u, NULL);
d833 1
a833 3
  if (u == -1)
    abort ();
  pep_leading_underscore = u;
d1175 1
d1470 1
d1483 2
d1575 1
d1589 1
@


1.34
log
@2010-04-05  Kai Tietz  <kai.tietz@@onevision.com>

	* emultempl/pep.em (U): Macro modified.
	(U_SIZE): New helper macro.
	(GET_INIT_SYMBOL_NAME): Likewise.
	(enum options): Add OPTION_NO_LEADING_UNDERSCORE
	and OPTION_LEADING_UNDERSCORE enumerator-values.
	(gld${EMULATION_NAME}_add_options): Add --(no-)leading-underscore
	option.
	(definfo): Add new member is_c_symbol.
	(D): Add to macro underscore mode parameter.
	(init): Add definition for is_c_symbol.
	(gld_${EMULATION_NAME}_list_options): Display new options.
	(set_pep_name): Adjust underscoring dependent fixed
	symbol handling.
	(gld_${EMULATION_NAME}_set_symbols): Likewise.
	(saw_option): Likewise.
	(gld_${EMULATION_NAME}_unrecognized_file): Likewise.
	(set_entry_point): Initial initial_symbol_char dependent to
	target's default and new option flag pep_leading_underscore.
	* emultempl/pe.em (U): Macro modified.
	(U_SIZE): New helper macro.
	(GET_INIT_SYMBOL_NAME): Likewise.
	(OPTION_LEADING_UNDERSCORE): Add new option define.
	(OPTION_NO_LEADING_UNDERSCORE): Likewise.
	(gld${EMULATION_NAME}_add_options): Add --(no-)leading-underscore
	option.
	(definfo): Add new member is_c_symbol.
	(D): Add to macro underscore mode parameter.
	(init): Add definition for is_c_symbol.
	(gld_${EMULATION_NAME}_list_options): Display new options.
	(set_pep_name): Adjust underscoring dependent fixed
	symbol handling.
	(gld_${EMULATION_NAME}_set_symbols): Likewise.
	(saw_option): Likewise.
	(gld_${EMULATION_NAME}_unrecognized_file): Likewise.
	(set_entry_point): Initial initial_symbol_char dependent to
	target's default and new option flag pep_leading_underscore.
	* pe-dll.c (pe_leading_underscore): New flag variable.
	(pe_detail_list): Remove const to allow modify of
	member underscore.
	(pe_dll_id_target): Initialize pe_details' underscore variable
	dependent to target's default and flag pe_leading_underscore.
	* pe-dll.h (pe_leading_underscore): Add extern declaration of
	option flag.
	* pep-dll.c (pe_leading_underscore): Add alias define for
	pep_leading_underscore.
	* pep-dll.h (pep_leading_underscore) Add extern declaration of
	option flag.
	* ld.texinfo: Add documentation for --(no-)leading-underscore
	option.
@
text
@d121 11
d300 1
a300 1
  + ((init[(IDX)].is_c_symbol == FALSE || pep_leading_underscore != 0) ? 0 : 1))
d304 1
a304 1
  (pep_leading_underscore == 0 ? CSTR : "_" CSTR)
d309 1
a309 1
  (sizeof (CSTR) + pep_leading_underscore == 0 ? 0 : 1)
d414 11
a424 1
  int i;
d486 2
a487 1
  if (u == -1 && !bfd_get_target_info ("${OUTPUT_FORMAT}", NULL, NULL, &u, NULL))
d490 1
a490 5
  if (u == 0)
    initial_symbol_char = "";
  else if (u != -1)
    initial_symbol_char = "_";
  else
d492 1
d843 10
a852 1
  int j;
@


1.33
log
@* emultempl/elf32.em (_place_orphan): If an input section doesn't
match an existing output section, but an unused output section
statement does match, use it.
* emultempl/pe.em (_place_orphan): Likewise.
* emultempl/pep.em (_place_orphan): Likewise.

* ld-elf/orphan4.d: New.
* ld-elf/orphan4.ld: New.
* ld-elf/orphan4.s: New.
@
text
@a99 2
#define U(S) ${INITIAL_SYMBOL_CHAR} S

d176 2
d219 2
d281 4
d287 14
a300 1
#define D(field,symbol,def)  {&pep.field,sizeof(pep.field), def, symbol,0}
d306 1
a306 1
  D(ImageBase,"__image_base__", NT_EXE_IMAGE_BASE),
d308 1
a308 1
  {&dll, sizeof(dll), 0, "__dll__", 0},
d310 17
a326 17
  D(ImageBase, U("__ImageBase"), NT_EXE_IMAGE_BASE),
  D(SectionAlignment,"__section_alignment__", PE_DEF_SECTION_ALIGNMENT),
  D(FileAlignment,"__file_alignment__", PE_DEF_FILE_ALIGNMENT),
  D(MajorOperatingSystemVersion,"__major_os_version__", 4),
  D(MinorOperatingSystemVersion,"__minor_os_version__", 0),
  D(MajorImageVersion,"__major_image_version__", 0),
  D(MinorImageVersion,"__minor_image_version__", 0),
  D(MajorSubsystemVersion,"__major_subsystem_version__", 5),
  D(MinorSubsystemVersion,"__minor_subsystem_version__", 2),
  D(Subsystem,"__subsystem__", ${SUBSYSTEM}),
  D(SizeOfStackReserve,"__size_of_stack_reserve__", 0x200000),
  D(SizeOfStackCommit,"__size_of_stack_commit__", 0x1000),
  D(SizeOfHeapReserve,"__size_of_heap_reserve__", 0x100000),
  D(SizeOfHeapCommit,"__size_of_heap_commit__", 0x1000),
  D(LoaderFlags,"__loader_flags__", 0x0),
  D(DllCharacteristics, "__dll_characteristics__", 0x0), 
  { NULL, 0, 0, NULL, 0 }
d348 1
d395 1
a395 1
  fprintf (file, _("  --tsaware       		 Image is Terminal Server aware\n"));
d408 1
a408 1
      if (strcmp (name, init[i].symbol) == 0)
d413 1
a413 1
	    set_pep_name ("___ImageBase", val);
d425 1
a425 1
  int i;
d463 13
a475 1
  initial_symbol_char = ${INITIAL_SYMBOL_CHAR};
d662 6
d856 2
a857 1
      rv = lang_add_assignment (exp_assop ('=', init[j].symbol,
d1118 1
a1118 1
		  if (! CONST_STRNEQ (symbols[i]->name, "__head_"))
d1125 1
a1125 1
						sizeof ("__head_") - 1);
d1473 1
a1473 1
    if (strcmp (init[i].symbol, option) == 0)
d1507 2
a1508 1
	      sprintf (buf, "_%s", pep_def_file->exports[i].internal_name);
@


1.32
log
@2009-11-15  Kai Tietz  <kai.tietz@@onevision.com>

	* pe-dll.c (pe_undef_alias_cdecl_match): New function.
	(pe_find_cdecl_alias_match): New function.
	(pe_process_import_defs): Add matching for import symbols
	declared as cdecl for fastcall/stdcall.
	* emultempl/pe.em (pe_undef_cdecl_match): Treat fastcall
	symbols, too.
	(pe_fixup_stdcalls): Likewise.
	(gld_XXX_after_open): Redo scanning for imported
	fastcall/stdcall symbols as cdecl one.
	* emultempl/pep.em (pep_undef_cdecl_match): Treat fastcall
	symbols, too.
	(pep_fixup_stdcalls): Likewise.
	(gld_XXX_after_open): Redo scanning for imported
	fastcall/stdcall symbols as cdecl one.

2009-11-15  Kai Tietz  <kai.tietz@@onevision.com>

	* ld-pe/direct2_client.c: New file.
	* ld-pe/direct2_dll.c: Likewise.
	* ld-pe/direct2_dll.def: Likewise.
	* ld-pe/pe-run2.exp: Likewise.
@
text
@d1585 1
d1624 5
d1631 8
@


1.31
log
@2009-11-04  Kai Tietz  <kai.tietz@@onevision.com>

        * emulparams/arm_epoc_pe.sh: Remove ENTRY.
        * emulparams/arm_wince_pe.sh: Likewise.
        * emulparams/i386pe.sh: Likewise.
        * emulparams/i386pe_posix.sh: Likewise.
        * emulparams/mcorepe.sh: Likewise.
        * emulparams/mipspe.sh: Likewise.
        * emulparams/ppcpe.sh: Likewise.
        * emulparams/armpe.sh: Likewise.
        * emulparams/i386pep.sh: Likewise.
        * emulparams/shpe.sh: Likewise.
        Additionally cleaned up double-defined
        variables SUBSYSTEM and INITIAL_SYMBOL_CHAR.
        * emultempl/pe.em: Remove use of ENTRY.
        (pe_subsystem): New local variable.
        (gld_XXX_before_parse): Don't set default
        entry point here.
        (set_entry_point): New function to set entry
        point.
        (set_pe_subsystem): Remove code for entry point.
        (gld_XXX_after_parse): Use set_entry_point here.
        * emultempl/pep.em: Likewise.
@
text
@d874 1
d878 3
a880 1
      && strncmp (h->root.string, string, sl) == 0
d903 3
a905 3
	/* For now, don't try to fixup fastcall symbols.  */

	if (at && !lead_at)
d909 4
a912 1
	    char *cname = xstrdup (undef->root.string /* + lead_at */);
d914 2
a915 1
	    *at = 0;
d1189 5
@


1.30
log
@2009-10-28  Kai Tietz  <kai.tietz@@onevision.com>

        * emultempl/pep.em (U): Define underscore macro.
        (init): Use for __ImageBase U macro.
@
text
@a2 1
test -z "${ENTRY}" && ENTRY="_mainCRTStartup"
d104 1
a129 6

#if (PE_DEF_SUBSYSTEM == 9) || (PE_DEF_SUBSYSTEM == 2)
  lang_default_entry ("_WinMainCRTStartup");
#else
  lang_default_entry ("${ENTRY}");
#endif
d400 60
a464 2
  const char *entry;
  const char *initial_symbol_char;
a467 1
  int subsystem;
a472 1
      const char *entry;
d476 7
a482 7
      { "native",  1, "NtProcessStartup" },
      { "windows", 2, "WinMainCRTStartup" },
      { "console", 3, "mainCRTStartup" },
      { "posix",   7, "__PosixProcessStartup"},
      { "wince",   9, "_WinMainCRTStartup" },
      { "xbox",   14, "mainCRTStartup" },
      { NULL, 0, NULL }
a483 2
  /* Entry point name for arbitrary subsystem numbers.  */
  static const char default_entry[] = "mainCRTStartup";
a509 6
      /* If no match, use the default.  */
      if (v[i].name != NULL)
	entry = v[i].entry;
      else
	entry = default_entry;

d511 1
a511 1
      subsystem = (int) temp_subsystem;
d527 1
a527 19
      entry = v[i].entry;
      subsystem = v[i].value;
    }

  set_pep_name ("__subsystem__", subsystem);

  initial_symbol_char = ${INITIAL_SYMBOL_CHAR};
  if (*initial_symbol_char != '\0')
    {
      char *alc_entry;

      /* lang_default_entry expects its argument to be permanently
	 allocated, so we don't free this string.  */
      alc_entry = xmalloc (strlen (initial_symbol_char)
			   + strlen (entry)
			   + 1);
      strcpy (alc_entry, initial_symbol_char);
      strcat (alc_entry, entry);
      entry = alc_entry;
d530 1
a530 1
  lang_default_entry (entry);
d854 2
@


1.29
log
@        * emultempl/pe.em (OPTION_EXCLUDE_ALL_SYMBOLS): New macro.
        (gld${EMULATION_NAME}_add_options): Add new --exclude-all-symbols option
        to exclude all symbols from automatic export.
        (gld_${EMULATION_NAME}_list_options): Describe it.
        (gld${EMULATION_NAME}_handle_option): Handle it.
        * emultempl/pep.em: Likewise to all the above.
        * pe-dll.c (pe_dll_exclude_all_symbols): New variable.
        (process_def_file_and_drectve): Use it.
        * pe-dll.h (pe_dll_exclude_all_symbols): Declare.
        * pep-dll.c (pep_dll_exclude_all_symbols): Define pep_ alias.
        * pep-dll.h (pe_dll_exclude_all_symbols): Declare.
        * NEWS: Mention the new feature.
        * ld.texinfo: Document the new command line switch.
@
text
@d101 1
d297 1
a297 1
  D(ImageBase,"___ImageBase", NT_EXE_IMAGE_BASE),
@


1.28
log
@     	PR ld/6766
	* lexsup.c (parse_args <-e>): Revert 2009-03-18 change.
	* ldemul.c (after_parse_default): Add entry symbol as undef.
	* emultempl/alphaelf.em (alpha_after_parse): Call after_parse_default.
	* emultempl/cr16elf.em (cr16elf_after_parse): Likewise.
	* emultempl/crxelf.em (crxelf_after_parse): Likewise.
	* emultempl/hppaelf.em (hppaelf_after_parse): Likewise.
	* emultempl/ia64elf.em (gld${EMULATION_NAME}_after_parse): Likewise.
	* emultempl/pe.em (gld_${EMULATION_NAME}_after_parse): Call
	after_parse_default and delete now duplicate code.
	* emultempl/pep.em (gld_${EMULATION_NAME}_after_parse): Likewise.
	* scripttempl/elf32cr16.sc: No need to make entry extern.
	* scripttempl/elf32cr16c.sc: Likewise.
	* scripttempl/elf32crx.sc: Likewise.
	* scripttempl/elf32xc16xs.sc: Only provide ENTRY on final link.
@
text
@d161 1
d231 1
d339 1
d615 3
@


1.27
log
@ld/
	* ldlang.c (lang_output_section_statement_lookup): Add function
	comment.  Make "name" non-const.  Ensure duplicate entries use
	the same string, allowing simple comparison in hash bucket loop.
	Tweak constraint check.
	(next_matching_output_section_statement): New function.
	* ldlang.h (lang_output_section_statement_lookup): Update.
	(next_matching_output_section_statement): Declare.
	* emultempl/elf32.em (gld${EMULATION_NAME}_place_orphan): Don't
	combine orphan sections when input sections flags differ in
	alloc or load.
	* emultempl/pe.em: Formatting throughout.
	(gld${EMULATION_NAME}_place_orphan): As for elf32.em.
	* emultempl/pep.em: Formatting throughout.
	(gld${EMULATION_NAME}_place_orphan): As for elf32.em.
ld/testsuite/
	* ld-elf/orphan3.d, * ld-elf/orphan3a.s, * ld-elf/orphan3b.s,
	* ld-elf/orphan3c.s, * ld-elf/orphan3d.s, * ld-elf/orphan3e.s,
	* ld-elf/orphan3f.s: New test.
	* ld-pe/orphan.d, * ld-pe/orphana.s, * ld-pe/orphanb.s,
	* ld-pe/orphand.s, * ld-pe/orphane.s: New test.
	* ld-pe/direct.exp: Use is_pecoff_format.
	* ld-pe/longsecn.exp: Delete.
	* ld-pe/pe.exp: Run new test and longsecn tests.
@
text
@a816 16
  /* The Windows libraries are designed for the linker to treat the
     entry point as an undefined symbol.  Otherwise, the .obj that
     defines mainCRTStartup is brought in because it is the first
     encountered in libc.lib and it has other symbols in it which will
     be pulled in by the link process.  To avoid this, we act as
     though the user specified -u with the entry point symbol.

     This function is called after the linker script and command line
     options have been read, so at this point we know the right entry
     point.  This function is called before the input files are
     opened, so registering the symbol as undefined will make a
     difference.  */

  if (! link_info.relocatable && entry_symbol.name != NULL)
    ldlang_add_undef (entry_symbol.name);

d822 2
@


1.27.4.1
log
@     	PR ld/6766
	* lexsup.c (parse_args <-e>): Revert 2009-03-18 change.
	* ldemul.c (after_parse_default): Add entry symbol as undef.
	* emultempl/alphaelf.em (alpha_after_parse): Call after_parse_default.
	* emultempl/cr16elf.em (cr16elf_after_parse): Likewise.
	* emultempl/crxelf.em (crxelf_after_parse): Likewise.
	* emultempl/hppaelf.em (hppaelf_after_parse): Likewise.
	* emultempl/ia64elf.em (gld${EMULATION_NAME}_after_parse): Likewise.
	* emultempl/pe.em (gld_${EMULATION_NAME}_after_parse): Call
	after_parse_default and delete now duplicate code.
	* emultempl/pep.em (gld_${EMULATION_NAME}_after_parse): Likewise.
	* scripttempl/elf32cr16.sc: No need to make entry extern.
	* scripttempl/elf32cr16c.sc: Likewise.
	* scripttempl/elf32crx.sc: Likewise.
	* scripttempl/elf32xc16xs.sc: Only provide ENTRY on final link.
@
text
@d817 16
a837 2

  after_parse_default ();
@


1.26
log
@	* ldlang.c (lang_insert_orphan): Add __start_<section> symbol
	assignment inside output section statement.  Ensure only one
	set of symbols per output section.
	* emultempl/pe.em (gld_${EMULATION_NAME}_place_orphan): Add non-
	dollar sections before dollar sections.  Correct add_child
	list insertion.
	* emultempl/pep.em (gld_${EMULATION_NAME}_place_orphan): Likewise.
@
text
@d263 2
a264 1
    {"tsaware", no_argument, NULL, OPTION_TERMINAL_SERVER_AWARE},    {NULL, no_argument, NULL, 0}
d267 2
a268 1
  *longopts = xrealloc (*longopts, nl * sizeof (struct option) + sizeof (xtra_long));
d375 1
a375 1
  fprintf (file, _("  --no-bind		 	 Do not bind this image\n"));
d762 1
d764 3
a766 2
	init[IMAGEBASEOFF].value = (pep_enable_auto_image_base) ?
	  compute_dll_image_base (output_filename) : NT_DLL_IMAGE_BASE;
d768 1
a768 1
	init[IMAGEBASEOFF].value = NT_DLL_IMAGE_BASE;
d770 1
d773 1
a773 1
	init[MSIMAGEBASEOFF].value = init[IMAGEBASEOFF].value;
d1065 1
a1065 1
					make_import_fixup);
d1569 26
a1594 15
  if (constraint == 0
      && (os = lang_output_section_find (secname)) != NULL
      && os->bfd_section != NULL
      && (os->bfd_section->flags == 0
	  || ((s->flags ^ os->bfd_section->flags)
	      & (SEC_LOAD | SEC_ALLOC)) == 0))
    {
      /* We already have an output section statement with this
	 name, and its bfd section has compatible flags.
	 If the section already exists but does not have any flags set,
	 then it has been created by the linker, probably as a result of
	 a --section-start command line switch.  */
      lang_add_section (&add_child, s, os);
    }
  else
@


1.25
log
@ld/ChangeLog

	PR ld/6744
	* ld.texinfo (--export-dynamic):  Mention --export-all-symbols.
	* emultempl/pe.em (gld_${EMULATION_NAME}_after_parse):  Issue
	warning if --export-dynamic was passed on command-line.
	* emultempl/pep.em (gld_${EMULATION_NAME}_after_parse):  Likewise.

ld/testsuite/ChangeLog

	PR ld/6744
	* ld-pe/export_dynamic_warning.d:  New test control file.
	* ld-pe/export_dynamic_warning.s:  New test source file.
	* ld-pe/pe.exp:  Also run export_dynamic_warning dump test.
@
text
@d1549 1
d1655 6
a1660 2
  {
    lang_statement_union_type **pl = &os->children.head;
d1662 2
a1663 11
    if (dollar != NULL)
      {
	bfd_boolean found_dollar;

	/* The section name has a '\$'.  Sort it with the other '\$'
	   sections.  */
	found_dollar = FALSE;
	for ( ; *pl != NULL; pl = &(*pl)->header.next)
	  {
	    lang_input_section_type *ls;
	    const char *lname;
d1665 1
a1665 2
	    if ((*pl)->header.type != lang_input_section_enum)
	      continue;
d1667 5
a1671 1
	    ls = &(*pl)->input_section;
d1673 5
a1677 21
	    lname = bfd_get_section_name (ls->section->owner, ls->section);
	    if (strchr (lname, '\$') == NULL)
	      {
		if (found_dollar)
		  break;
	      }
	    else
	      {
		found_dollar = TRUE;
		if (strcmp (orig_secname, lname) < 0)
		  break;
	      }
	  }
      }

    if (add_child.head != NULL)
      {
	add_child.head->header.next = *pl;
	*pl = add_child.head;
      }
  }
@


1.24
log
@include/ChangeLog
2009-03-12  Dave Korn  <dave.korn.cygwin@@gmail.com>

	* coff/internal.h (struct internal_extra_pe_aouthdr):  Correct type
	of DllCharacteristics flags field to unsigned.
	* coff/pe.h (IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE,
	IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE,
	IMAGE_DLL_CHARACTERISTICS_NX_COMPAT,
	IMAGE_DLLCHARACTERISTICS_NO_ISOLATION,
	IMAGE_DLLCHARACTERISTICS_NO_SEH,
	IMAGE_DLLCHARACTERISTICS_NO_BIND,
	IMAGE_DLLCHARACTERISTICS_WDM_DRIVER,
	IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE):  New macros to
	define flag bit values for DllCharacteristics field of PEAOUTHDR,
	PEPAOUTHDR.

ld/ChangeLog
2009-03-12  Dave Korn  <dave.korn.cygwin@@gmail.com>
            Danny Smith  <dannysmith@@users.sourceforge.net>

	* emultmpl/pe.em (pe_dll_characteristics): New variable.
	(OPTION_DYNAMIC_BASE, OPTION_FORCE_INTEGRITY, OPTION_NX_COMPAT,
	OPTION_NO_ISOLATION. OPTION_NO_SEH, OPTION_NO_BIND,
	OPTION_WDM_DRIVER, OPTION_TERMINAL_SERVER_AWARE):
	New macros for options to set DllCharacteristics flag bits.
	(gld${EMULATION_NAME}_add_options): Add dynamicbase, forceinteg,
	nxcompat, no-isolation, no-seh, no-bind, wdmdriver, tsaware options.
	(init): Add DllCharacteristics field.
	(gld_${EMULATION_NAME}_list_options): List new options.
	(gld${EMULATION_NAME}_handle_option): Handle new options.
	* emultmpl/pep.em (pe_dll_characteristics): New variable.
	(OPTION_DYNAMIC_BASE, OPTION_FORCE_INTEGRITY, OPTION_NX_COMPAT,
	OPTION_NO_ISOLATION. OPTION_NO_SEH, OPTION_NO_BIND,
	OPTION_WDM_DRIVER, OPTION_TERMINAL_SERVER_AWARE):
	New macros for options to set DllCharacteristics flags.
	(gld${EMULATION_NAME}_add_options): Add dynamicbase, forceinteg,
	nxcompat,no-isolation, no-seh, no-bind, wdmdriver, tsaware options.
	(init): Add DllCharacteristics field.
	(gld_${EMULATION_NAME}_list_options): List new options.
	(gld${EMULATION_NAME}_handle_option): Handle new options.
	* ldtexinfo : Document dynamicbase, forceinteg,	nxcompat,
	no-isolation, no-seh, no-bind, wdmdriver, tsaware options.
@
text
@d827 6
@


1.23
log
@	* emultempl/pe.em (debug_section_p):  New bfd_map_over_sections hook.
	(gld_${EMULATION_NAME}_after_open):  Use it to iterate all sections
	of all input BFDs, looking for debug info.  Enable long section names
	if any found.
	* emultempl/pe.em (debug_section_p):  Likewise.
	(gld_${EMULATION_NAME}_after_open):  Likewise.
	* NEWS:  Retrospectively adjust news announcement.
	* ld.texinfo:  Update documentation to mention new behaviour.
@
text
@d107 1
d183 9
a191 1
  OPTION_DISABLE_LONG_SECTION_NAMES
d256 8
a263 1
    {NULL, no_argument, NULL, 0}
d307 1
d366 10
d677 25
d703 4
@


1.22
log
@bfd/ChangeLog

	* coff-alpha.c (alpha_ecoff_backend_data):  Initialise fields which
	control long section name handling with ECOFF_NO_LONG_SECTION_NAMES.
	* coff-mips.c (mips_ecoff_backend_data):  Likewise.
	* coff-rs6000.c (bfd_xcoff_backend_data):  Initialise fields which
	control long section name handling with XCOFF_NO_LONG_SECTION_NAMES.
	(bfd_pmac_xcoff_backend_data):  Likewise.
	* coff64-rs6000.c (bfd_xcoff_backend_data):  Likewise.
	(bfd_xcoff_aix5_backend_data):  Likewise.
	(xcoff64_write_object_contents):  Delete unused long_section_names
	local variable.
	* coff-sh.c (bfd_coff_small_swap_table):  Initialise long section
	name members using COFF_DEFAULT_LONG_SECTION_NAMES and make entire
	struct non-const.
	* coffcode.h (documentation):  Update to describe long section names.
	(COFFLONGSECTIONCATHELPER):  New helper macro.
	(BLANKOR1TOODD):  Likewise.
	(COFF_ENABLE_LONG_SECTION_NAMES):  Likewise.
	(COFF_LONG_SECTION_NAMES_SETTER):  Likewise.
	(COFF_DEFAULT_LONG_SECTION_NAMES):  Likewise.
	(bfd_coff_set_long_section_names_allowed):  New function.
	(bfd_coff_set_long_section_names_disallowed):  Likewise.
	(struct bfd_coff_backend_data):  Add new backend hook function
	pointer _bfd_coff_set_long_section_names.
	(bfd_coff_set_long_section_names):  New backend hook.
	(coff_write_object_contents):  Only generate long section names if
	bfd_coff_long_section_names() indicates they are currently enabled.
	(bfd_coff_std_swap_table):  Make non-const, and initialise long
	section name fields using COFF_DEFAULT_LONG_SECTION_NAMES.
	(ticoff0_swap_table):  Likewise to both.
	(ticoff1_swap_table):  Again, likewise to both.
	* coffgen.c (make_a_section_from_file):  Allow long section names
	as inputs even if not currently allowed for outputs.
	* ecoff.c (_bfd_ecoff_no_long_sections):  New function.
	* efi-app-ia32.c (COFF_LONG_SECTION_NAMES):  Define to 0, not blank.
	* efi-app-ia64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-app-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-bsdrv-ia32.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-bsdrv-ia64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-bsdrv-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-rtdrv-ia32.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-rtdrv-ia64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-rtdrv-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-arm.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-i386.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-mcore.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-mips.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-ppc.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-sh.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* libcoff-in.h:  Update copyright year to cause updated copyright
	year in generated libcoff.h, and fix typo.
	* libcoff.h:  Regenerated.
	* libecoff.h (ECOFF_NO_LONG_SECTION_NAMES):  New macro.
	(_bfd_ecoff_no_long_sections):  Add prototype.
	* libxcoff.h (XCOFF_NO_LONG_SECTION_NAMES):  New macro.
	* pe-mips.c (COFF_LONG_SECTION_NAMES):  Define empty if not already
	defined by an including .c file.
	* ticoff.h (ticoff0_swap_table):  Make non-const, and initialise
	long section name fields using COFF_DEFAULT_LONG_SECTION_NAMES.
	(ticoff1_swap_table):  Likewise to both.

ld/ChangeLog

	* ld.texinfo:  Update to mention long section name options.
	* NEWS:  Mention new behaviour and command-line options.
	* pe-dll.c (pe_use_coff_long_section_names):  New global variable.
	(pe_output_file_set_long_section_names):  New function.
	(pe_dll_build_sections):  Call it on output BFDs.
	(pe_exe_build_sections):  Likewise.
	(pe_dll_fill_sections):  Likewise.
	(pe_exe_fill_sections):  Likewise.
	* pe-dll.h (pe_use_coff_long_section_names):  Declare extern.
	(pe_output_file_set_long_section_names):  Add prototype.
	* pep-dll.c (pe_use_coff_long_section_names):  Define pep_ alias.
	(pe_output_file_set_long_section_names):  Likewise.
	* pep-dll.h (pep_use_coff_long_section_names):  Declare extern.
	(pep_output_file_set_long_section_names):  Add prototype.
	* pe.em (OPTION_ENABLE_LONG_SECTION_NAMES):  New getopt value macro.
	(OPTION_DISABLE_LONG_SECTION_NAMES):  Likewise.
	(gld${EMULATION_NAME}_add_options):  Add new options to xtra_long[].
	(gld_${EMULATION_NAME}_list_options):  Describe them.
	(gld${EMULATION_NAME}_handle_option):  Set or clear global
	pe_use_coff_long_section_names flag when options recognised.
	(gld_${EMULATION_NAME}_after_open):  En/disable long section names
	for main output bfd by calling pe_output_file_set_long_section_names.
	* pep.em (enum options):  Extend enum with new getopt option values.
	(gld${EMULATION_NAME}_add_options):  Add new options to xtra_long[].
	(gld_${EMULATION_NAME}_list_options):  Describe them.
	(gld${EMULATION_NAME}_handle_option):  Set or clear global
	pe_use_coff_long_section_names flag when options recognised.
	(gld_${EMULATION_NAME}_after_open):  En/disable long section names
	for main output bfd by calling pep_output_file_set_long_section_names.

ld/testsuite/ChangeLog

	* ld-pe/longsecn-1.d:  New test file.
	* ld-pe/longsecn-2.d:  Likewise.
	* ld-pe/longsecn-3.d:  Likewise.
	* ld-pe/longsecn-4.d:  Likewise.
	* ld-pe/longsecn-5.d:  Likewise.
	* ld-pe/longsecn.d:  Likewise.
	* ld-pe/longsecn.exp:  New test control script.
	* ld-pe/longsecn.s:  New test source file.
@
text
@d1023 7
d1063 23
@


1.21
log
@	* ldlang.c (push_stat_ptr, pop_stat_ptr): New functions.
	(stat_save, stat_save_ptr): New variables.
	(lang_insert_orphan): Use push_stat_ptr and pop_stat_ptr.
	(load_symbols): Likewise.  Delete dead "bad_load" code.
	(open_input_bfds): Warn on script containing output sections.
	(lang_enter_output_section_statement): Use push_stat_ptr.
	(lang_enter_group): Likewise.
	(lang_leave_output_section_statement): Use pop_stat_ptr.
	(lang_leave_group): Likewise.
	* ldlang.h (push_stat_ptr, pop_stat_ptr): Declare.
	* ldctor.c (ldctor_build_sets): Use push_stat_ptr and pop_stat_ptr.
	* emultempl/beos.em (gld_${EMULATION_NAME}_set_symbols): Likewise.
	* emultempl/pe.em (gld_${EMULATION_NAME}_set_symbols): Likewise.
	* emultempl/pep.em (gld_${EMULATION_NAME}_set_symbols): Likewise.
	* emultempl/spuelf.em (spu_place_special_section): Likewise.
	* emultempl/xtensaelf.em (ld_xtensa_insert_page_offsets): Likewise.
@
text
@d180 3
a182 1
  OPTION_USE_NUL_PREFIXED_IMPORT_TABLES
d245 2
d345 4
d644 6
d1056 1
@


1.20
log
@2009-01-08  Kai Tietz  <kai.tietz@@onevision.com>

	* pe.em (OPTION_USE_NUL_PREFIXED_IMPORT_TABLES): New.
	(gld..._add_options): Add new option
	--use-nul-prefixed-import-tables.
	(gld..._handle_option): Likewise.
	* pep.em: Same as for pe.em.
	* ld.texinfo: Add new option documentation for
	--use-nul-prefixed-import-tables.
	* pe-dll.c (pe_use_nul_prefixed_import_tables): New.
	(make_head): Make prefix leading zero prefix element for
	idata$4 and idata$5 dependent to new flag.
	(make_import_fixup_entry): Remove idata4/5 prefix.
	* pe-dll.h (pe_use_nul_prefixed_import_tables): New.
	* pep-dll.c (pe_use_nul_prefixed_import_tables): New.
	* pep-dll.h (pep_use_nul_prefixed_import_tables): New.
	* NEWS: Add new option.
@
text
@d12 1
a12 1
/* Copyright 2006, 2007, 2008 Free Software Foundation, Inc.
a683 1
  lang_statement_list_type *save;
d706 1
a706 3
  save = stat_ptr;

  stat_ptr = &(abs_output_section->children);
d728 1
a728 1
  stat_ptr = save;
@


1.19
log
@2009-01-05  Kai Tietz  <kai.tietz@@onevision.com>

        * emultempl/pe.em: Prefix dollar characters to be outputed in
        generated C file.
        * emultempl/pep.em: Likewise.
@
text
@d179 2
a180 1
  OPTION_EXCLUDE_MODULES_FOR_IMPLIB
d210 2
d562 3
@


1.18
log
@	* NEWS:  Mention new feature --exclude-modules-for-implib.
	* ld.texinfo:  Document new --exclude-modules-for-implib option.
	* pe-dll.c (exclude_list_struct):  Change type member from int to
	new enumeration exclude_type.
	(pe_dll_add_excludes):  Accept exclude_type instead of int param.
	(auto_export):  Replace magic constants by exclude_type values and
	handle new choice EXCLUDEFORIMPLIB.
	(pe_dll_generate_implib):  Accept a pointer to the link_info and
	iterate all input BFDs looking for EXCLUDEFORIMPLIB modules; re-open
	fresh BFDs for any found and link into import lib archive chain.
	* pe-dll.h (exclude_type):  Add new enumerated type to replace magic
	constants previously used for exclude_list_struct type member.
	(pe_dll_add_excludes, pe_dll_generate_implib):  Update prototypes.
	* pep-dll.h (exclude_type, pe_dll_add_excludes,
	pe_dll_generate_implib):  Likewise to all the above.
	* emultempl/pe.em (OPTION_EXCLUDE_MODULES_FOR_IMPLIB):  Define new
	getopts long option code for new --exclude-modules-for-implib option.
	(gld${EMULATION_NAME}_add_options):  Add new entry to xtra_long[].
	(gld_${EMULATION_NAME}_list_options):  List usage for it.
	(gld${EMULATION_NAME}_handle_option):  Use exclude_type enumerated
	values when calling pe_dll_add_excludes, and handle EXCLUDEFORIMPLIB.
	(gld_${EMULATION_NAME}_finish):  Pass pointer to link_info when
	calling pe_dll_generate_implib.
	* emultempl/pep.em (options):  Define new enumerated value for getopts
	long option code for new --exclude-modules-for-implib option.
	(gld${EMULATION_NAME}_add_options, gld_${EMULATION_NAME}_list_options,
	gld${EMULATION_NAME}_handle_option, gld_${EMULATION_NAME}_finish):
	Again, likewise to all the above.
@
text
@d1422 1
a1422 1
   We handle grouped sections here as well.  A section named .foo$nn
d1442 1
a1442 1
      && (dollar = strchr (secname, '$')) != NULL)
d1551 1
a1551 1
	/* The section name has a '$'.  Sort it with the other '$'
d1565 1
a1565 1
	    if (strchr (lname, '$') == NULL)
@


1.17
log
@2008-11-14  Kai Tietz  <kai.tietz@@onevision.com>

	* emultempl/pep.em (..._before_parse): initialize
	pei386_runtime_pseudo_reloc by version 2.
	(OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC_V1): New option.
	(OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC_V2): New option.
	(make_import_fixup): Use relocation size to read addend.
	* emultempl/pe.em (..._before_parse): initialize
	pei386_runtime_pseudo_reloc by version 1.
	(OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC_V1): New option.
	(OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC_V2): New option.
	* pe-dll.c (pe-dll.h): Remove useless include.
	(make_runtime_pseudo_reloc): Change addend to use bfd_vma.
	Handle the two variants of pseudo-relocation.
	(pe_create_import_fixup): Change addend to type bfd_vma.
	Modify for the two pseudo_relocation variants.
	(runtime_pseudp_reloc_v2_init): New static variable.
	* pe-dll.h (pe_create_import_fixup): Change addend argument type
	to bfd_vma.
	* pep-dll.h (pep_create_import_fixup): Likewise.
	* NEWS: Add comment.
@
text
@d178 2
a179 1
  OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC_V2
d217 1
d312 3
d567 1
a567 1
      pep_dll_add_excludes (optarg, 0);
d570 4
a573 1
      pep_dll_add_excludes (optarg, 1);
d1397 1
a1397 1
	pep_dll_generate_implib (pep_def_file, pep_implib_filename);
@


1.16
log
@	* ldemul.h (ldemul_place_orphan): Update prototype.
	(struct ld_emulation_xfer_struct <place_orphan>): Likewise.
	* ldemul.c (ldemul_place_orphan): Return pointer to output
	section statement.
	* emultempl/beos.em (gld${EMULATION_NAME}_place_orphan): Likewise.
	* emultempl/elf32.em (gld${EMULATION_NAME}_place_orphan): Likewise.
	* emultempl/mmo.em (mmo_place_orphan): Likewise.
	* emultempl/pe.em (gld_${EMULATION_NAME}_place_orphan): Likewise.
	* emultempl/pep.em (gld_${EMULATION_NAME}_place_orphan): Likewise.
@
text
@d127 1
a127 1
  link_info.pei386_runtime_pseudo_reloc = -1;
d176 3
a178 1
  OPTION_DLL_DISABLE_RUNTIME_PSEUDO_RELOC
d235 2
d607 1
a607 1
      link_info.pei386_runtime_pseudo_reloc = 1;
d612 6
d853 3
a855 1
  char addend[4];
d861 31
a891 1
  if (! bfd_get_section_contents (s->owner, s, addend, rel->address, sizeof (addend)))
d895 7
a901 1
  pep_create_import_fixup (rel, s, bfd_get_32 (s->owner, addend));
@


1.15
log
@	* ldemul.c (ldemul_place_orphan): Add "constraint" param.
	* ldemul.h (ldemul_place_orphan): Update prototype.
	(struct ld_emulation_xfer_struct <place_orphan>): Likewise add param.
	* ldlang.c (unique_section_p): Make static.
	(lang_output_section_statement_lookup): Optimise creation of SPECIAL
	sections.
	(lang_insert_orphan): Add "constraint" param.  Pass to
	lang_enter_output_section_statement.
	(init_os): Don't use an existing bfd section for SPECIAL sections.
	(lang_place_orphans): Don't rename unique output sections, instead
	mark their output section statements SPECIAL.
	* ldlang.h (lang_insert_orphan): Update prototype.
	(unique_section_p): Delete.
	* emultempl/beos.em (place_orphan): Add "constraint" param.
	* emultempl/elf32.em (place_orphan): Likewise.  Don't match existing
	output sections if set.
	* emultempl/pe.em (place_orphan): Likewise.
	* emultempl/pep.em (place_orphan): Likewise.
	* emultempl/mmo.em (mmo_place_orphan): Update.
	* emultempl/spuelf.em (spu_place_special_section): Update.
@
text
@d1374 1
a1374 1
static bfd_boolean
d1530 1
a1530 1
  return TRUE;
@


1.14
log
@bfd/
	* elf.c (bfd_elf_set_group_contents): Assign sh_info for ld -r when
	the signature symbol is global.
	* elflink.c (elf_link_input_bfd): Ensure group signature symbol
	is output when ld -r.  Set group sh_info when local.
	* linker.c (default_indirect_link_order): Handle group sections
	specially.
ld/
	* ldemul.c (ldemul_place_orphan): Add "name" param.
	* ldemul.h (ldemul_place_orphan): Update prototype.
	(struct ld_emulation_xfer_struct <place_orphan>): Likewise.
	* ldlang.c (lang_place_orphans): Generate unique section names here..
	* emultempl/elf32.em (place_orphan): ..rather than here.  Don't
	directly use an existing output section statement that has no
	bfd section.
	* emultempl/pe.em (place_orphan): Likewise.
	* emultempl/pep.em (place_orphan): Likewise.
	* emultempl/beos.em (place_orphan): Adjust.
	* emultempl/spuelf.em (spu_place_special_section): Adjust
	place_orphan call.
	* emultempl/genelf.em (gld${EMULATION_NAME}_after_open): New function.
	(LDEMUL_AFTER_OPEN): Define.
@
text
@d1375 3
a1377 1
gld_${EMULATION_NAME}_place_orphan (asection *s, const char *secname)
a1394 2
  os = lang_output_section_find (secname);

d1397 2
a1398 1
  if (os != NULL
d1484 2
a1485 1
      os = lang_insert_orphan (s, secname, after, place, address, &add_child);
@


1.13
log
@* emultempl/pe.em (pe_find_data_imports): Add trailing newline
  to warning message.
  * emultempl/pep.em (pep_find_data_imports): Likewise.
@
text
@d1375 1
a1375 1
gld_${EMULATION_NAME}_place_orphan (asection *s)
d1377 1
a1377 2
  const char *secname;
  const char *orig_secname;
a1381 2
  secname = bfd_get_section_name (s->owner, s);

a1382 1
  orig_secname = secname;
d1386 1
a1386 1
      size_t len = dollar - orig_secname;
d1388 1
a1388 1
      memcpy (newname, orig_secname, len);
d1398 2
a1399 2
      && (os->bfd_section == NULL
	  || os->bfd_section->flags == 0
d1404 1
a1404 1
	 name, and its bfd section, if any, has compatible flags.
a1480 12
      /* Choose a unique name for the section.  This will be needed if the
	 same section name appears in the input file with different
	 loadable or allocatable characteristics.  */
      if (bfd_get_section_by_name (link_info.output_bfd, secname) != NULL)
	{
	  static int count = 1;
	  secname = bfd_get_unique_section_name (link_info.output_bfd,
						 secname, &count);
	  if (secname == NULL)
	    einfo ("%F%P: place_orphan failed: %E\n");
	}

@


1.12
log
@bfd/
	* bfd.c (struct _bfd): Correct outsymbols comment.
	* bfd-in2.h: Regenerate.
	* linker.c (bfd_generic_link_read_symbols): Renamed from..
	(generic_link_read_symbols): ..this, and made global.

include/
	* bfdlink.h (bfd_generic_link_read_symbols): Declare.
ld/
	PR 6478
	* ldcref.c (check_local_sym_xref): Use bfd_generic_link_read_symbols.
	Don't free symbol pointer array.
	(check_refs): Likewise.
	* ldmain.c (warning_callback): Likewise.
	* ldmisc.c (vfinfo): Likewise.
	* pe-dll.c (process_def_file): Likewise.
	(pe_walk_relocs_of_symbol, generate_reloc): Likewise.
	* emultempl/pe.em (pe_find_data_imports): Likewise.
	(gld_${EMULATION_NAME}_after_open): Likewise.
	* emultempl/pep.em (pep_find_data_imports): Likewise.
	(gld_${EMULATION_NAME}_after_open): Likewise.
	* ldlang.h (lang_input_statement_type): Delete asymbols, symbol_count,
	passive_position, closed.
	* ldlang.c (new_afile): Don't set asymbols and symbol_count.
	* ldmain.c (add_archive_element): xcalloc lang_input_statement_type.
@
text
@d898 1
a898 1
This should work unless it involves constant data structures referencing symbols from auto-imported DLLs."));
d1063 1
a1063 1
			einfo ("%X%P: unable to process relocs: %E");
@


1.12.2.1
log
@        * emultempl/pe.em (pe_find_data_imports): Add trailing newline
        to warning message.
        * emultempl/pep.em (pep_find_data_imports): Likewise.
@
text
@d898 1
a898 1
This should work unless it involves constant data structures referencing symbols from auto-imported DLLs.\n"));
d1063 1
a1063 1
			einfo ("%X%P: unable to process relocs: %E\n");
@


1.12.2.2
log
@backport 2008-10-03  Alan Modra  <amodra@@bigpond.net.au>
@
text
@d1375 1
a1375 1
gld_${EMULATION_NAME}_place_orphan (asection *s, const char *secname)
d1377 2
a1378 1
  const char *orig_secname = secname;
d1383 2
d1386 1
d1390 1
a1390 1
      size_t len = dollar - secname;
d1392 1
a1392 1
      memcpy (newname, secname, len);
d1402 2
a1403 2
      && os->bfd_section != NULL
      && (os->bfd_section->flags == 0
d1408 1
a1408 1
	 name, and its bfd section has compatible flags.
d1485 12
@


1.12.2.3
log
@backport 2008-10-04  Alan Modra  <amodra@@bigpond.net.au>
@
text
@d1375 1
a1375 3
gld_${EMULATION_NAME}_place_orphan (asection *s,
				    const char *secname,
				    int constraint)
d1393 2
d1397 1
a1397 2
  if (constraint == 0
      && (os = lang_output_section_find (secname)) != NULL
d1483 1
a1483 2
      os = lang_insert_orphan (s, secname, constraint, after, place, address,
			       &add_child);
@


1.12.2.4
log
@backport 2009-02-16  Alan Modra  <amodra@@bigpond.net.au>
@
text
@d12 1
a12 1
/* Copyright 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d660 1
d683 3
a685 1
  push_stat_ptr (&abs_output_section->children);
d707 1
a707 1
  pop_stat_ptr ();
@


1.11
log
@Silence gcc printf warnings
@
text
@d884 1
a884 1
	      int nsyms, symsize, i;
d902 8
a909 3
	      symsize = bfd_get_symtab_upper_bound (b);
	      symbols = xmalloc (symsize);
	      nsyms = bfd_canonicalize_symtab (b, symbols);
a1039 1
		    long symsize;
a1044 3
		    symsize = bfd_get_symtab_upper_bound (is->the_bfd);
		    if (symsize < 1)
		      break;
d1049 1
a1049 3
		    symbols = xmalloc (symsize);
		    symsize = bfd_canonicalize_symtab (is->the_bfd, symbols);
		    if (symsize < 0)
d1051 2
a1052 1
			einfo ("%X%P: unable to process symbols: %E");
d1055 1
@


1.10
log
@2008-05-09  Kai Tietz  <kai.tietz@@onevision.com>

	ld/PR6502
	* emultempl/pep.em (compute_dll_image_base): Use bfd_vma instead of long
	and change return type to bfd_vma.
	(definfo): Change type of address from long to bfd_vma.
	(set_pep_value): Replace strtoul to strtoull.
	(gld_${EMULATION_NAME}_set_symbols): use bfd_vma instead of long..
	* pe-dll.c (pe_dll_generate_def_file): Use fprintf_vma to print ImageBase.
	(quick_reloc): Change argument address from int to bfd_size_type.
@
text
@d847 1
a847 1
	    (long) rel->address, (long) rel->addend);
@


1.9
log
@include/
	* bfdlink.h (struct bfd_link_hash_table): Delete creator field.
	(struct bfd_link_info): Add output_bfd.
bfd/
	* elflink.c: Replace all accesses to hash->creator field with
	output_bfd->xvec.
	* cofflink.c: Likewise.
	* coff-h8300.c: Likewise.
	* ecoff.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfxx-mips.c: Likewise.
	* i386linux.c: Likewise.
	* m68klinux.c: Likewise.
	* sparclinux.c: Likewise.
	* sunos.c: Likewise.
	* xcofflink.c: Likewise.
	* linker.c: Likewise.
	(_bfd_link_hash_table_init): Don't store creator.
ld/
	* ldmain.h (output_bfd): Delete.
	* ldmain.c (output_bfd): Delete.
	Replace all occurrences of output_bfd with link_info.output_bfd.
	* ldcref.c: Likewise.
	* ldctor.c: Likewise.
	* ldemul.c: Likewise.
	* ldexp.c: Likewise.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldmisc.c: Likewise.
	* ldwrite.c: Likewise.
	* pe-dll.c: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/alphaelf.em: Likewise.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/elf-generic.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/irix.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/mmix-elfnmmo.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/sh64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
	* emultempl/z80.em: Likewise.
	* ldlang.c (open_output): Don't return output, instead write
	link_info_output_bfd directly.
	* emultempl/alphaelf.em: Replace occurrences of link_info.hash->creator
	with link_info.output_bfd->xvec.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
@
text
@d248 1
a248 1
  int value;
d334 1
a334 1
set_pep_name (char *name, long val)
d464 1
a464 1
  set_pep_name (name,  strtoul (optarg, &end, 0));
d643 1
a643 1
static unsigned long
d646 1
a646 1
  unsigned long hash = strhash (ofile);
d689 1
a689 1
      long val = init[j].value;
d694 1
a694 1
	*(short *) init[j].ptr = val;
d696 1
a696 1
	*(int *) init[j].ptr = val;
d698 1
a698 1
	*(long *) init[j].ptr = val;
@


1.8
log
@Add __ImageBase symbol to pe.em and pep.em.
@
text
@d12 1
a12 1
/* Copyright 2006, 2007 Free Software Foundation, Inc.
d970 8
a977 6
  if (coff_data (output_bfd) == NULL || coff_data (output_bfd)->pe == 0)
    einfo (_("%F%P: cannot perform PE operations on non PE output file '%B'.\n"), output_bfd);

  pe_data (output_bfd)->pe_opthdr = pep;
  pe_data (output_bfd)->dll = init[DLLOFF].value;
  pe_data (output_bfd)->real_flags |= real_flags;
d983 1
a983 1
  pep_process_import_defs (output_bfd, & link_info);
d992 1
a992 1
    pep_dll_build_sections (output_bfd, &link_info);
d996 1
a996 1
    pep_exe_build_sections (output_bfd, &link_info);
d1285 4
a1288 3
	      pep.ImageBase =
		pe_data (output_bfd)->pe_opthdr.ImageBase =
		init[IMAGEBASEOFF].value = pep_def_file->base_address;
d1291 2
a1292 2
		image_base_statement->exp =
		  exp_assop ('=', "__image_base__", exp_intop (pep.ImageBase));
d1338 1
a1338 1
      pep_dll_fill_sections (output_bfd, &link_info);
d1349 1
a1349 1
    asection *asec = bfd_get_section_by_name (output_bfd, ".idata");
d1487 1
a1487 1
      if (bfd_get_section_by_name (output_bfd, secname) != NULL)
d1490 2
a1491 1
	  secname = bfd_get_unique_section_name (output_bfd, secname, &count);
@


1.7
log
@PR linker/4844
* emultempl/pep.em (pep_find_data_imports): Issue a warning message if auto importing is triggered without
  --enable-auto-import having been specified on the command line.
* emultempl/pe.em (pe_find_data_imports): Likewise.
@
text
@d263 1
a263 1
  D(ImageBase,"__ImageBase", NT_EXE_IMAGE_BASE),
d346 1
a346 1
	    set_pep_name ("__ImageBase", val);
@


1.6
log
@PR linker/4844
* genscript.sh: Add support for generating a .xa script for use with the --auto-import option.
* ld.texinfo: Document the new behaviour of the --auto-import option.
* ldint.texinfo: Document new script generation.
* emulparams/i386pe.sh (GENERATE_AUTO_IMPORT): Define.
* emulparams/i386pe_posix.sh (GENERATE_AUTO_IMPORT): Define.
* emulparams/i386pep.sh (GENERATE_AUTO_IMPORT): Define.
* emultemp/pe.em (..._get_script): Support the use of the auto import script.
* scripttempl/pe.sc: Put the .rdata input sections into the .data output section when creating an auto import script.
* scripttempl/pep.sc: Likewise.
@
text
@d887 14
a900 2
		info_msg (_("Info: resolving %s by linking to %s (auto-import)\n"),
			  undef->root.string, buf);
@


1.5
log
@* emultempl/pep.em: (pep_enable_stdcall_fixup): Set to value 1.
  (gld_xxx_recognized_file): Use pep_bfd_is_dll for detection of shared objects.
* pe-dll.c: (autofilter_symbollist_i386): Define set for amd64 mingw target.
@
text
@d1662 4
@


1.4
log
@2007-07-19  Roland McGrath  <roland@@redhat.com>

	* genscripts.sh (source_em, fragment): New sh functions.
	Truncate e${EMULATION_NAME}.c file before .em script fills it.
	Use source_em in place of . for the .em script.
	* emultempl/generic.em: Use fragment and source_em functions.
	* emultempl/aix.em: Likewise.
	* emultempl/alphaelf.em: Likewise.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/cr16elf.em: Likewise.
	* emultempl/crxelf.em: Likewise.
	* emultempl/elf-generic.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/genelf.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/gld960c.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ia64elf.em: Likewise.
	* emultempl/irix.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/m68kcoff.em: Likewise.
	* emultempl/m68kelf.em: Likewise.
	* emultempl/mipsecoff.em: Likewise.
	* emultempl/mipself.em: Likewise.
	* emultempl/mmix-elfnmmo.em: Likewise.
	* emultempl/mmixelf.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/needrelax.em: Likewise.
	* emultempl/netbsd.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/sh64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/ticoff.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
	* emultempl/z80.em: Likewise.
@
text
@d109 1
a109 1
static int    pep_enable_stdcall_fixup = -1; /* 0=disable 1=enable.  */
d1308 2
a1309 13
  if (bfd_get_format (entry->the_bfd) == bfd_object)
    {
      char fbuf[LD_PATHMAX + 1];
      const char *ext;

      if (REALPATH (entry->filename, fbuf) == NULL)
	strncpy (fbuf, entry->filename, sizeof (fbuf));

      ext = fbuf + strlen (fbuf) - 4;

      if (strcmp (ext, ".dll") == 0 || strcmp (ext, ".DLL") == 0)
	return pep_implied_import_dll (fbuf);
    }
@


1.3
log
@Update sources to GPLv3
@
text
@d11 2
a12 2
cat >>e${EMULATION_NAME}.c <<EOF
/* Copyright 2006, 2007 Free Software Foundation, Inc.   
d1562 1
a1562 1
      /* The 'native' spelling of an import lib name is "foo.lib".  */  	
d1619 1
a1619 1
#ifdef DLL_SUPPORT 
d1659 1
a1659 1
cat >>e${EMULATION_NAME}.c <<EOF
d1677 1
a1677 1
cat >>e${EMULATION_NAME}.c <<EOF
@


1.2
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d12 4
a15 2
/* This file is part of GLD, the Gnu Linker.
   Copyright 2006, 2007 Free Software Foundation, Inc.
d19 1
a19 1
   the Free Software Foundation; either version 2 of the License, or
d29 3
a31 3
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
   
   Written by Kai Tietz, OneVision Software GmbH&CoKg.  */
@


1.1
log
@Add x86_64-mingw64 target
@
text
@d13 1
a13 1
   Copyright 2006 Free Software Foundation, Inc.
d40 1
a41 1
#include "sysdep.h"
@

