head	1.49;
access;
symbols
	binutils-2_24-branch:1.49.0.2
	binutils-2_24-branchpoint:1.49
	binutils-2_21_1:1.41.4.2
	binutils-2_23_2:1.47.2.1
	binutils-2_23_1:1.47.2.1
	binutils-2_23:1.47.2.1
	binutils-2_23-branch:1.47.0.2
	binutils-2_23-branchpoint:1.47
	binutils-2_22_branch:1.43.0.4
	binutils-2_22:1.43
	binutils-2_22-branch:1.43.0.2
	binutils-2_22-branchpoint:1.43
	binutils-2_21:1.41
	binutils-2_21-branch:1.41.0.4
	binutils-2_21-branchpoint:1.41
	binutils-2_20_1:1.41
	binutils-2_20:1.41
	binutils-arc-20081103-branch:1.28.0.4
	binutils-arc-20081103-branchpoint:1.28
	binutils-2_20-branch:1.41.0.2
	binutils-2_20-branchpoint:1.41
	dje-cgen-play1-branch:1.39.0.2
	dje-cgen-play1-branchpoint:1.39
	arc-20081103-branch:1.28.0.2
	arc-20081103-branchpoint:1.28
	binutils-2_19_1:1.26
	binutils-2_19:1.26
	binutils-2_19-branch:1.26.0.2
	binutils-2_19-branchpoint:1.26
	binutils-2_18:1.12
	binutils-2_18-branch:1.12.0.2
	binutils-2_18-branchpoint:1.12
	binutils_latest_snapshot:1.49;
locks; strict;
comment	@# @;


1.49
date	2013.01.10.20.08.03;	author hjl;	state Exp;
branches;
next	1.48;

1.48
date	2012.08.06.22.27.52;	author macro;	state Exp;
branches;
next	1.47;

1.47
date	2012.07.13.13.20.27;	author nickc;	state Exp;
branches
	1.47.2.1;
next	1.46;

1.46
date	2012.05.14.19.45.28;	author jwlemke;	state Exp;
branches;
next	1.45;

1.45
date	2012.03.05.22.43.40;	author amodra;	state Exp;
branches;
next	1.44;

1.44
date	2011.12.01.11.38.32;	author nickc;	state Exp;
branches;
next	1.43;

1.43
date	2011.01.13.13.06.22;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2010.11.05.17.20.17;	author rsandifo;	state Exp;
branches;
next	1.41;

1.41
date	2009.08.10.07.50.56;	author amodra;	state Exp;
branches
	1.41.4.1;
next	1.40;

1.40
date	2009.08.05.20.40.33;	author tsmigiel;	state Exp;
branches;
next	1.39;

1.39
date	2009.05.14.16.56.08;	author uweigand;	state Exp;
branches;
next	1.38;

1.38
date	2009.05.14.04.30.02;	author amodra;	state Exp;
branches;
next	1.37;

1.37
date	2009.04.09.13.55.35;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2009.03.19.07.04.12;	author amodra;	state Exp;
branches;
next	1.35;

1.35
date	2009.03.17.12.46.19;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2009.02.16.07.25.52;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2009.02.04.02.43.17;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2009.01.21.02.27.13;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2009.01.12.00.23.57;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2008.12.10.13.36.41;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2008.12.10.06.32.52;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2008.10.04.06.08.59;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2008.10.03.09.40.49;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2008.08.02.16.25.44;	author jkratoch;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	2008.07.31.05.27.54;	author jkratoch;	state Exp;
branches;
next	1.24;

1.24
date	2008.06.19.16.14.53;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2008.06.16.16.16.31;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2008.06.07.11.35.46;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2008.06.06.06.02.00;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2008.06.04.07.08.01;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2008.04.08.03.26.54;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2008.03.20.05.35.10;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2008.03.14.04.42.44;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2008.02.15.03.35.53;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2008.02.07.08.41.10;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2008.01.28.05.59.24;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2007.08.17.13.50.48;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2007.07.19.19.56.10;	author roland;	state Exp;
branches;
next	1.11;

1.11
date	2007.07.11.22.58.09;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2007.07.06.14.09.42;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2007.07.02.23.11.40;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2007.06.18.10.58.07;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2007.06.18.02.23.56;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2007.05.29.13.10.10;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2007.04.30.14.06.40;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2007.03.26.11.10.44;	author amodra;	state Exp;
branches;
next	1.3;

1.3
date	2007.02.27.08.33.25;	author amodra;	state Exp;
branches;
next	1.2;

1.2
date	2007.02.26.08.58.16;	author amodra;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.25.06.49.21;	author amodra;	state Exp;
branches;
next	;

1.47.2.1
date	2012.09.04.14.38.00;	author gingold;	state Exp;
branches;
next	;

1.41.4.1
date	2010.12.10.10.43.53;	author gingold;	state Exp;
branches;
next	1.41.4.2;

1.41.4.2
date	2011.02.01.12.25.47;	author amodra;	state Exp;
branches;
next	;

1.26.2.1
date	2009.03.02.13.32.56;	author amodra;	state Exp;
branches;
next	1.26.2.2;

1.26.2.2
date	2009.03.02.13.34.03;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.49
log
@Remove trailing white spaces in ld

	* deffilep.y: Remove trailing white spaces.
	* elf-hints-local.h: Likewise.
	* ldexp.c: Likewise.
	* ldlang.h: Likewise.
	* ldmisc.c: Likewise.
	* ldwrite.c: Likewise.
	* pe-dll.c: Likewise.
	* emulparams/criself.sh: Likewise.
	* emulparams/crislinux.sh: Likewise.
	* emulparams/elf32_tic6x_le.sh: Likewise.
	* emulparams/elf32bmipn32-defs.sh: Likewise.
	* emulparams/elf32mb_linux.sh: Likewise.
	* emulparams/elf32mep.sh: Likewise.
	* emulparams/elf32microblaze.sh: Likewise.
	* emulparams/elf32ppc.sh: Likewise.
	* emulparams/elf64_s390.sh: Likewise.
	* emulparams/elf64alpha.sh: Likewise.
	* emulparams/elf_s390.sh: Likewise.
	* emulparams/elf_x86_64.sh: Likewise.
	* emulparams/tic80coff.sh: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/cr16elf.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/tic6xdsbt.em: Likewise.
@
text
@# This shell script emits a C file. -*- C -*-
#   Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2012
#   Free Software Foundation, Inc.
#
# This file is part of the GNU Binutils.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
# MA 02110-1301, USA.
#

# This file is sourced from elf32.em, and defines extra spu specific
# features.
#
fragment <<EOF
#include "ldctor.h"
#include "elf32-spu.h"

static void spu_place_special_section (asection *, asection *, const char *);
static bfd_size_type spu_elf_load_ovl_mgr (void);
static FILE *spu_elf_open_overlay_script (void);
static void spu_elf_relink (void);

static struct spu_elf_params params =
{
  &spu_place_special_section,
  &spu_elf_load_ovl_mgr,
  &spu_elf_open_overlay_script,
  &spu_elf_relink,
  0, ovly_normal, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0x3ffff,
  1, 0, 16, 0, 0, 2000
};

static unsigned int no_overlays = 0;
static unsigned int num_lines_set = 0;
static unsigned int line_size_set = 0;
static char *auto_overlay_file = 0;
int my_argc;
char **my_argv;

static const char ovl_mgr[] = {
EOF

if ! cat ${srcdir}/emultempl/spu_ovl.o_c >> e${EMULATION_NAME}.c
then
  echo >&2 "Missing ${srcdir}/emultempl/spu_ovl.o_c"
  echo >&2 "You must build gas/as-new with --target=spu"
  exit 1
fi

fragment <<EOF
};

static const char icache_mgr[] = {
EOF

if ! cat ${srcdir}/emultempl/spu_icache.o_c >> e${EMULATION_NAME}.c
then
  echo >&2 "Missing ${srcdir}/emultempl/spu_icache.o_c"
  echo >&2 "You must build gas/as-new with --target=spu"
  exit 1
fi

fragment <<EOF
};

static const struct _ovl_stream ovl_mgr_stream = {
  ovl_mgr,
  ovl_mgr + sizeof (ovl_mgr)
};

static const struct _ovl_stream icache_mgr_stream = {
  icache_mgr,
  icache_mgr + sizeof (icache_mgr)
};


static int
is_spu_target (void)
{
  extern const bfd_target bfd_elf32_spu_vec;

  return link_info.output_bfd->xvec == &bfd_elf32_spu_vec;
}

/* Create our note section.  */

static void
spu_after_open (void)
{
  if (is_spu_target ())
    {
      /* Pass params to backend.  */
      if ((params.auto_overlay & AUTO_OVERLAY) == 0)
	params.auto_overlay = 0;
      params.emit_stub_syms |= link_info.emitrelocations;
      spu_elf_setup (&link_info, &params);

      if (link_info.relocatable)
	lang_add_unique (".text.ia.*");

      if (!link_info.relocatable
	  && link_info.input_bfds != NULL
	  && !spu_elf_create_sections (&link_info))
	einfo ("%X%P: can not create note section: %E\n");
    }

  gld${EMULATION_NAME}_after_open ();
}

/* If O is NULL, add section S at the end of output section OUTPUT_NAME.
   If O is not NULL, add section S at the beginning of output section O,
   except for soft-icache which adds to the end.

   Really, we should be duplicating ldlang.c map_input_to_output_sections
   logic here, ie. using the linker script to find where the section
   goes.  That's rather a lot of code, and we don't want to run
   map_input_to_output_sections again because most sections are already
   mapped.  So cheat, and put the section in a fixed place, ignoring any
   attempt via a linker script to put .stub, .ovtab, and built-in
   overlay manager code somewhere else.  */

static void
spu_place_special_section (asection *s, asection *o, const char *output_name)
{
  lang_output_section_statement_type *os;

  if (o != NULL)
    output_name = o->name;
  os = lang_output_section_find (output_name);
  if (os == NULL)
    {
      os = gld${EMULATION_NAME}_place_orphan (s, output_name, 0);
      os->addr_tree = NULL;
    }
  else if (params.ovly_flavour != ovly_soft_icache
	   && o != NULL && os->children.head != NULL)
    {
      lang_statement_list_type add;

      lang_list_init (&add);
      lang_add_section (&add, s, NULL, os);
      *add.tail = os->children.head;
      os->children.head = add.head;
    }
  else
    {
      if (params.ovly_flavour == ovly_soft_icache && o != NULL)
	{
	  /* Pad this stub section so that it finishes at the
	     end of the icache line.  */
	  etree_type *e_size;

	  push_stat_ptr (&os->children);
	  e_size = exp_intop (params.line_size - s->size);
	  lang_add_assignment (exp_assign (".", e_size, FALSE));
	  pop_stat_ptr ();
	}
      lang_add_section (&os->children, s, NULL, os);
    }

  s->output_section->size += s->size;
}

/* Load built-in overlay manager.  */

static bfd_size_type
spu_elf_load_ovl_mgr (void)
{
  struct elf_link_hash_entry *h;
  const char *ovly_mgr_entry;
  const struct _ovl_stream *mgr_stream;
  bfd_size_type total = 0;

  ovly_mgr_entry = "__ovly_load";
  mgr_stream = &ovl_mgr_stream;
  if (params.ovly_flavour == ovly_soft_icache)
    {
      ovly_mgr_entry = "__icache_br_handler";
      mgr_stream = &icache_mgr_stream;
    }
  h = elf_link_hash_lookup (elf_hash_table (&link_info),
			    ovly_mgr_entry, FALSE, FALSE, FALSE);

  if (h != NULL
      && (h->root.type == bfd_link_hash_defined
	  || h->root.type == bfd_link_hash_defweak)
      && h->def_regular)
    {
      /* User supplied __ovly_load.  */
    }
  else if (mgr_stream->start == mgr_stream->end)
    einfo ("%F%P: no built-in overlay manager\n");
  else
    {
      lang_input_statement_type *ovl_is;

      ovl_is = lang_add_input_file ("builtin ovl_mgr",
				    lang_input_file_is_file_enum,
				    NULL);

      if (!spu_elf_open_builtin_lib (&ovl_is->the_bfd, mgr_stream))
	einfo ("%X%P: can not open built-in overlay manager: %E\n");
      else
	{
	  asection *in;

	  if (!load_symbols (ovl_is, NULL))
	    einfo ("%X%P: can not load built-in overlay manager: %E\n");

	  /* Map overlay manager sections to output sections.
	     First try for a matching output section name, if that
	     fails then try mapping .abc.xyz to .abc, otherwise map
	     to .text.  */
	  for (in = ovl_is->the_bfd->sections; in != NULL; in = in->next)
	    if ((in->flags & (SEC_ALLOC | SEC_LOAD))
		== (SEC_ALLOC | SEC_LOAD))
	      {
		const char *oname = in->name;
		if (strncmp (in->name, ".ovl.init", 9) != 0)
		  {
		    total += in->size;
		    if (!lang_output_section_find (oname))
		      {
			lang_output_section_statement_type *os = NULL;
			char *p = strchr (oname + 1, '.');
			if (p != NULL)
			  {
			    size_t len = p - oname;
			    p = memcpy (xmalloc (len + 1), oname, len);
			    p[len] = '\0';
			    os = lang_output_section_find (p);
			    free (p);
			  }
			if (os != NULL)
			  oname = os->name;
			else
			  oname = ".text";
		      }
		  }

		spu_place_special_section (in, NULL, oname);
	      }
	}
    }
  return total;
}

/* Go find if we need to do anything special for overlays.  */

static void
spu_before_allocation (void)
{
  if (is_spu_target ()
      && !link_info.relocatable
      && !no_overlays)
    {
      int ret;

      /* Size the sections.  This is premature, but we need to know the
	 rough layout so that overlays can be found.  */
      expld.phase = lang_mark_phase_enum;
      expld.dataseg.phase = exp_dataseg_none;
      one_lang_size_sections_pass (NULL, TRUE);

      /* Find overlays by inspecting section vmas.  */
      ret = spu_elf_find_overlays (&link_info);
      if (ret == 0)
	einfo ("%X%P: can not find overlays: %E\n");
      else if (ret == 2)
	{
	  lang_output_section_statement_type *os;

	  if (params.auto_overlay != 0)
	    {
	      einfo ("%P: --auto-overlay ignored with user overlay script\n");
	      params.auto_overlay = 0;
	    }

	  /* Ensure alignment of overlay sections is sufficient.  */
	  for (os = &lang_output_section_statement.head->output_section_statement;
	       os != NULL;
	       os = os->next)
	    if (os->bfd_section != NULL
		&& spu_elf_section_data (os->bfd_section) != NULL
		&& spu_elf_section_data (os->bfd_section)->u.o.ovl_index != 0)
	      {
		if (os->bfd_section->alignment_power < 4)
		  os->bfd_section->alignment_power = 4;

		/* Also ensure size rounds up.  */
		os->block_value = 16;
	      }

	  ret = spu_elf_size_stubs (&link_info);
	  if (ret == 0)
	    einfo ("%X%P: can not size overlay stubs: %E\n");
	  else if (ret == 2)
	    spu_elf_load_ovl_mgr ();

	  spu_elf_place_overlay_data (&link_info);
	}

      /* We must not cache anything from the preliminary sizing.  */
      lang_reset_memory_regions ();
    }

  if (is_spu_target ()
      && !link_info.relocatable)
    spu_elf_size_sections (link_info.output_bfd, &link_info);

  gld${EMULATION_NAME}_before_allocation ();
}

struct tflist {
  struct tflist *next;
  char name[9];
};

static struct tflist *tmp_file_list;

static void clean_tmp (void)
{
  for (; tmp_file_list != NULL; tmp_file_list = tmp_file_list->next)
    unlink (tmp_file_list->name);
}

static int
new_tmp_file (char **fname)
{
  struct tflist *tf;
  int fd;

  if (tmp_file_list == NULL)
    atexit (clean_tmp);
  tf = xmalloc (sizeof (*tf));
  tf->next = tmp_file_list;
  tmp_file_list = tf;
  memcpy (tf->name, "ldXXXXXX", sizeof (tf->name));
  *fname = tf->name;
#ifdef HAVE_MKSTEMP
  fd = mkstemp (*fname);
#else
  *fname = mktemp (*fname);
  if (*fname == NULL)
    return -1;
  fd = open (*fname, O_RDWR | O_CREAT | O_EXCL, 0600);
#endif
  return fd;
}

static FILE *
spu_elf_open_overlay_script (void)
{
  FILE *script = NULL;

  if (auto_overlay_file == NULL)
    {
      int fd = new_tmp_file (&auto_overlay_file);
      if (fd == -1)
	goto file_err;
      script = fdopen (fd, "w");
    }
  else
    script = fopen (auto_overlay_file, "w");

  if (script == NULL)
    {
    file_err:
      einfo ("%F%P: can not open script: %E\n");
    }
  return script;
}

#include <errno.h>

static void
spu_elf_relink (void)
{
  const char *pex_return;
  int status;
  char **argv = xmalloc ((my_argc + 4) * sizeof (*argv));

  memcpy (argv, my_argv, my_argc * sizeof (*argv));
  argv[my_argc++] = "--no-auto-overlay";
  if (tmp_file_list->name == auto_overlay_file)
    argv[my_argc - 1] = concat (argv[my_argc - 1], "=",
				auto_overlay_file, (const char *) NULL);
  argv[my_argc++] = "-T";
  argv[my_argc++] = auto_overlay_file;
  argv[my_argc] = 0;

  pex_return = pex_one (PEX_SEARCH | PEX_LAST, (const char *) argv[0],
			(char * const *) argv, (const char *) argv[0],
			NULL, NULL, & status, & errno);
  if (pex_return != NULL)
    {
      perror (pex_return);
      _exit (127);
    }
  exit (status);
}

/* Final emulation specific call.  */

static void
gld${EMULATION_NAME}_finish (void)
{
  if (is_spu_target ())
    {
      if (params.local_store_lo < params.local_store_hi)
        {
	  asection *s;

	  s = spu_elf_check_vma (&link_info);
	  if (s != NULL && !params.auto_overlay)
	    einfo ("%X%P: %A exceeds local store range\n", s);
	}
      else if (params.auto_overlay)
	einfo ("%P: --auto-overlay ignored with zero local store range\n");
    }

  finish_default ();
}

static char *
gld${EMULATION_NAME}_choose_target (int argc, char *argv[])
{
  my_argc = argc;
  my_argv = argv;
  return ldemul_default_target (argc, argv);
}

EOF

if grep -q 'ld_elf.*ppc.*_emulation' ldemul-list.h; then
  fragment <<EOF
#include <errno.h>
#include "filenames.h"
#include "libiberty.h"

static const char *
base_name (const char *path)
{
  const char *file = strrchr (path, '/');
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
  {
    char *bslash = strrchr (path, '\\\\');

    if (file == NULL || (bslash != NULL && bslash > file))
      file = bslash;
    if (file == NULL
	&& path[0] != '\0'
	&& path[1] == ':')
      file = path + 1;
  }
#endif
  if (file == NULL)
    file = path;
  else
    ++file;
  return file;
}

/* This function is called when building a ppc32 or ppc64 executable
   to handle embedded spu images.  */
extern bfd_boolean embedded_spu_file (lang_input_statement_type *, const char *);

bfd_boolean
embedded_spu_file (lang_input_statement_type *entry, const char *flags)
{
  const char *cmd[6];
  const char *pex_return;
  const char *sym;
  char *handle, *p;
  char *oname;
  int fd;
  int status;
  union lang_statement_union **old_stat_tail;
  union lang_statement_union **old_file_tail;
  union lang_statement_union *new_ent;
  lang_input_statement_type *search;

  if (entry->the_bfd->format != bfd_object
      || strcmp (entry->the_bfd->xvec->name, "elf32-spu") != 0
      || (entry->the_bfd->tdata.elf_obj_data->elf_header->e_type != ET_EXEC
	  && entry->the_bfd->tdata.elf_obj_data->elf_header->e_type != ET_DYN))
    return FALSE;

  /* Use the filename as the symbol marking the program handle struct.  */
  sym = base_name (entry->the_bfd->filename);

  handle = xstrdup (sym);
  for (p = handle; *p; ++p)
    if (!(ISALNUM (*p) || *p == '$' || *p == '.'))
      *p = '_';

  fd = new_tmp_file (&oname);
  if (fd == -1)
    return FALSE;
  close (fd);

  for (search = (lang_input_statement_type *) input_file_chain.head;
       search != NULL;
       search = (lang_input_statement_type *) search->next_real_file)
    if (search->filename != NULL)
      {
	const char *infile = base_name (search->filename);

	if (strncmp (infile, "crtbegin", 8) == 0)
	  {
	    if (infile[8] == 'S')
	      flags = concat (flags, " -fPIC", (const char *) NULL);
	    else if (infile[8] == 'T')
	      flags = concat (flags, " -fpie", (const char *) NULL);
	    break;
	  }
      }

  cmd[0] = EMBEDSPU;
  cmd[1] = flags;
  cmd[2] = handle;
  cmd[3] = entry->the_bfd->filename;
  cmd[4] = oname;
  cmd[5] = NULL;
  if (verbose)
    {
      info_msg (_("running: %s \"%s\" \"%s\" \"%s\" \"%s\"\n"),
		cmd[0], cmd[1], cmd[2], cmd[3], cmd[4]);
      fflush (stdout);
    }

  pex_return = pex_one (PEX_SEARCH | PEX_LAST, cmd[0], (char *const *) cmd,
			cmd[0], NULL, NULL, &status, &errno);
  if (NULL != pex_return) {
      if (strcmp ("embedspu", EMBEDSPU) != 0)
	{
	  cmd[0] = "embedspu";
	  pex_return = pex_one (PEX_SEARCH | PEX_LAST, cmd[0], (char *const *) cmd,
				cmd[0], NULL, NULL, &status, &errno);
	}
      if (NULL != pex_return) {
	perror (pex_return);
	_exit (127);
      }
  }
  if (status)
    return FALSE;


  old_stat_tail = stat_ptr->tail;
  old_file_tail = input_file_chain.tail;
  if (lang_add_input_file (oname, lang_input_file_is_file_enum, NULL) == NULL)
    return FALSE;

  /* lang_add_input_file puts the new list entry at the end of the statement
     and input file lists.  Move it to just after the current entry.  */
  new_ent = *old_stat_tail;
  *old_stat_tail = NULL;
  stat_ptr->tail = old_stat_tail;
  *old_file_tail = NULL;
  input_file_chain.tail = old_file_tail;
  new_ent->header.next = entry->header.next;
  entry->header.next = new_ent;
  new_ent->input_statement.next_real_file = entry->next_real_file;
  entry->next_real_file = new_ent;

  /* Ensure bfd sections are excluded from the output.  */
  bfd_section_list_clear (entry->the_bfd);
  entry->flags.loaded = TRUE;
  return TRUE;
}

EOF
fi

# Define some shell vars to insert bits of code into the standard elf
# parse_args and list_options functions.
#
PARSE_AND_LIST_PROLOGUE='
#define OPTION_SPU_PLUGIN		301
#define OPTION_SPU_NO_OVERLAYS		(OPTION_SPU_PLUGIN + 1)
#define OPTION_SPU_COMPACT_STUBS	(OPTION_SPU_NO_OVERLAYS + 1)
#define OPTION_SPU_STUB_SYMS		(OPTION_SPU_COMPACT_STUBS + 1)
#define OPTION_SPU_NON_OVERLAY_STUBS	(OPTION_SPU_STUB_SYMS + 1)
#define OPTION_SPU_LOCAL_STORE		(OPTION_SPU_NON_OVERLAY_STUBS + 1)
#define OPTION_SPU_STACK_ANALYSIS	(OPTION_SPU_LOCAL_STORE + 1)
#define OPTION_SPU_STACK_SYMS		(OPTION_SPU_STACK_ANALYSIS + 1)
#define OPTION_SPU_AUTO_OVERLAY		(OPTION_SPU_STACK_SYMS + 1)
#define OPTION_SPU_AUTO_RELINK		(OPTION_SPU_AUTO_OVERLAY + 1)
#define OPTION_SPU_OVERLAY_RODATA	(OPTION_SPU_AUTO_RELINK + 1)
#define OPTION_SPU_SOFT_ICACHE		(OPTION_SPU_OVERLAY_RODATA + 1)
#define OPTION_SPU_LINE_SIZE		(OPTION_SPU_SOFT_ICACHE + 1)
#define OPTION_SPU_NUM_LINES		(OPTION_SPU_LINE_SIZE + 1)
#define OPTION_SPU_LRLIVE		(OPTION_SPU_NUM_LINES + 1)
#define OPTION_SPU_NON_IA_TEXT		(OPTION_SPU_LRLIVE + 1)
#define OPTION_SPU_FIXED_SPACE		(OPTION_SPU_NON_IA_TEXT + 1)
#define OPTION_SPU_RESERVED_SPACE	(OPTION_SPU_FIXED_SPACE + 1)
#define OPTION_SPU_EXTRA_STACK		(OPTION_SPU_RESERVED_SPACE + 1)
#define OPTION_SPU_NO_AUTO_OVERLAY	(OPTION_SPU_EXTRA_STACK + 1)
#define OPTION_SPU_EMIT_FIXUPS		(OPTION_SPU_NO_AUTO_OVERLAY + 1)
'

PARSE_AND_LIST_LONGOPTS='
  { "plugin", no_argument, NULL, OPTION_SPU_PLUGIN },
  { "soft-icache", no_argument, NULL, OPTION_SPU_SOFT_ICACHE },
  { "lrlive-analysis", no_argument, NULL, OPTION_SPU_LRLIVE },
  { "num-lines", required_argument, NULL, OPTION_SPU_NUM_LINES },
  { "line-size", required_argument, NULL, OPTION_SPU_LINE_SIZE },
  { "non-ia-text", no_argument, NULL, OPTION_SPU_NON_IA_TEXT },
  { "no-overlays", no_argument, NULL, OPTION_SPU_NO_OVERLAYS },
  { "compact-stubs", no_argument, NULL, OPTION_SPU_COMPACT_STUBS },
  { "emit-stub-syms", no_argument, NULL, OPTION_SPU_STUB_SYMS },
  { "extra-overlay-stubs", no_argument, NULL, OPTION_SPU_NON_OVERLAY_STUBS },
  { "local-store", required_argument, NULL, OPTION_SPU_LOCAL_STORE },
  { "stack-analysis", no_argument, NULL, OPTION_SPU_STACK_ANALYSIS },
  { "emit-stack-syms", no_argument, NULL, OPTION_SPU_STACK_SYMS },
  { "auto-overlay", optional_argument, NULL, OPTION_SPU_AUTO_OVERLAY },
  { "auto-relink", no_argument, NULL, OPTION_SPU_AUTO_RELINK },
  { "overlay-rodata", no_argument, NULL, OPTION_SPU_OVERLAY_RODATA },
  { "num-regions", required_argument, NULL, OPTION_SPU_NUM_LINES },
  { "region-size", required_argument, NULL, OPTION_SPU_LINE_SIZE },
  { "fixed-space", required_argument, NULL, OPTION_SPU_FIXED_SPACE },
  { "reserved-space", required_argument, NULL, OPTION_SPU_RESERVED_SPACE },
  { "extra-stack-space", required_argument, NULL, OPTION_SPU_EXTRA_STACK },
  { "no-auto-overlay", optional_argument, NULL, OPTION_SPU_NO_AUTO_OVERLAY },
  { "emit-fixups", optional_argument, NULL, OPTION_SPU_EMIT_FIXUPS },
'

PARSE_AND_LIST_OPTIONS='
  fprintf (file, _("\
  --plugin                    Make SPU plugin.\n\
  --no-overlays               No overlay handling.\n\
  --compact-stubs             Use smaller and possibly slower call stubs.\n\
  --emit-stub-syms            Add symbols on overlay call stubs.\n\
  --extra-overlay-stubs       Add stubs on all calls out of overlay regions.\n\
  --local-store=lo:hi         Valid address range.\n\
  --stack-analysis            Estimate maximum stack requirement.\n\
  --emit-stack-syms           Add sym giving stack needed for each func.\n\
  --auto-overlay [=filename]  Create an overlay script in filename if\n\
                              executable does not fit in local store.\n\
  --auto-relink               Rerun linker using auto-overlay script.\n\
  --overlay-rodata            Place read-only data with associated function\n\
                              code in overlays.\n\
  --num-regions               Number of overlay buffers (default 1).\n\
  --region-size               Size of overlay buffers (default 0, auto).\n\
  --fixed-space=bytes         Local store for non-overlay code and data.\n\
  --reserved-space=bytes      Local store for stack and heap.  If not specified\n\
                              ld will estimate stack size and assume no heap.\n\
  --extra-stack-space=bytes   Space for negative sp access (default 2000) if\n\
                              --reserved-space not given.\n\
  --soft-icache               Generate software icache overlays.\n\
  --num-lines                 Number of soft-icache lines (default 32).\n\
  --line-size                 Size of soft-icache lines (default 1k).\n\
  --non-ia-text               Allow non-icache code in icache lines.\n\
  --lrlive-analysis           Scan function prologue for lr liveness.\n"
		   ));
'

PARSE_AND_LIST_ARGS_CASES='
    case OPTION_SPU_PLUGIN:
      spu_elf_plugin (1);
      break;

    case OPTION_SPU_NO_OVERLAYS:
      no_overlays = 1;
      break;

    case OPTION_SPU_COMPACT_STUBS:
      params.compact_stub = 1;
      break;

    case OPTION_SPU_STUB_SYMS:
      params.emit_stub_syms = 1;
      break;

    case OPTION_SPU_NON_OVERLAY_STUBS:
      params.non_overlay_stubs = 1;
      break;

    case OPTION_SPU_LOCAL_STORE:
      {
	char *end;
	params.local_store_lo = strtoul (optarg, &end, 0);
	if (*end == '\'':'\'')
	  {
	    params.local_store_hi = strtoul (end + 1, &end, 0);
	    if (*end == 0)
	      break;
	  }
	einfo (_("%P%F: invalid --local-store address range `%s'\''\n"), optarg);
      }
      break;

    case OPTION_SPU_STACK_ANALYSIS:
      params.stack_analysis = 1;
      break;

    case OPTION_SPU_STACK_SYMS:
      params.emit_stack_syms = 1;
      break;

    case OPTION_SPU_AUTO_OVERLAY:
      params.auto_overlay |= 1;
      if (optarg != NULL)
	{
	  auto_overlay_file = optarg;
	  break;
	}
      /* Fall thru */

    case OPTION_SPU_AUTO_RELINK:
      params.auto_overlay |= 2;
      break;

    case OPTION_SPU_OVERLAY_RODATA:
      params.auto_overlay |= 4;
      break;

    case OPTION_SPU_SOFT_ICACHE:
      params.ovly_flavour = ovly_soft_icache;
      /* Software i-cache stubs are always "compact".  */
      params.compact_stub = 1;
      if (!num_lines_set)
	params.num_lines = 32;
      else if ((params.num_lines & -params.num_lines) != params.num_lines)
	einfo (_("%P%F: invalid --num-lines/--num-regions `%u'\''\n"),
	       params.num_lines);
      if (!line_size_set)
	params.line_size = 1024;
      else if ((params.line_size & -params.line_size) != params.line_size)
	einfo (_("%P%F: invalid --line-size/--region-size `%u'\''\n"),
	       params.line_size);
      break;

    case OPTION_SPU_LRLIVE:
      params.lrlive_analysis = 1;
      break;

    case OPTION_SPU_NON_IA_TEXT:
      params.non_ia_text = 1;
      break;

    case OPTION_SPU_NUM_LINES:
      {
	char *end;
	params.num_lines = strtoul (optarg, &end, 0);
	num_lines_set = 1;
	if (*end == 0
	    && (params.ovly_flavour != ovly_soft_icache
		|| (params.num_lines & -params.num_lines) == params.num_lines))
	  break;
	einfo (_("%P%F: invalid --num-lines/--num-regions `%s'\''\n"), optarg);
      }
      break;

    case OPTION_SPU_LINE_SIZE:
      {
	char *end;
	params.line_size = strtoul (optarg, &end, 0);
	line_size_set = 1;
	if (*end == 0
	    && (params.ovly_flavour != ovly_soft_icache
		|| (params.line_size & -params.line_size) == params.line_size))
	  break;
	einfo (_("%P%F: invalid --line-size/--region-size `%s'\''\n"), optarg);
      }
      break;

    case OPTION_SPU_FIXED_SPACE:
      {
	char *end;
	params.auto_overlay_fixed = strtoul (optarg, &end, 0);
	if (*end != 0)
	  einfo (_("%P%F: invalid --fixed-space value `%s'\''\n"), optarg);
      }
      break;

    case OPTION_SPU_RESERVED_SPACE:
      {
	char *end;
	params.auto_overlay_reserved = strtoul (optarg, &end, 0);
	if (*end != 0)
	  einfo (_("%P%F: invalid --reserved-space value `%s'\''\n"), optarg);
      }
      break;

    case OPTION_SPU_EXTRA_STACK:
      {
	char *end;
	params.extra_stack_space = strtol (optarg, &end, 0);
	if (*end != 0)
	  einfo (_("%P%F: invalid --extra-stack-space value `%s'\''\n"), optarg);
      }
      break;

    case OPTION_SPU_NO_AUTO_OVERLAY:
      params.auto_overlay = 0;
      if (optarg != NULL)
	{
	  struct tflist *tf;
	  size_t len;

	  if (tmp_file_list == NULL)
	    atexit (clean_tmp);

	  len = strlen (optarg) + 1;
	  tf = xmalloc (sizeof (*tf) - sizeof (tf->name) + len);
	  memcpy (tf->name, optarg, len);
	  tf->next = tmp_file_list;
	  tmp_file_list = tf;
	  break;
	}
      break;

    case OPTION_SPU_EMIT_FIXUPS:
      params.emit_fixups = 1;
      break;
'

LDEMUL_AFTER_OPEN=spu_after_open
LDEMUL_BEFORE_ALLOCATION=spu_before_allocation
LDEMUL_FINISH=gld${EMULATION_NAME}_finish
LDEMUL_CHOOSE_TARGET=gld${EMULATION_NAME}_choose_target
@


1.48
log
@	bfd/
	* elflink.c (bfd_elf_record_link_assignment): Remove --defsym
	symbols special case.

	ld/
	* ldexp.h (etree_union): Add defsym member to the assign member
	structure.
	(exp_assign): Add hidden argument to prototype.
	* ldexp.c (exp_fold_tree_1): Use the defsym member to handle
	--defsym symbols.
	(exp_assop): Add defsym argument, initialize the defsym member
	of the assign structure.
	(exp_assign): Handle hidden symbols.
	(exp_defsym): Update to use the defsym argument to exp_assop.
	(exp_provide): Update to handle the defsym argument to exp_assop.
	* ldlex.l (HIDDEN): New token.
	* ldgram.y (HIDDEN): Likewise.
	(assignment, section): Update calls to exp_assign.
	* ldctor.c (ldctor_build_sets): Likewise.
	* mri.c (mri_format): Likewise.
	* ldlang.c (lang_insert_orphan, lang_leave_overlay): Likewise.
	(open_input_bfds): Remove --defsym symbols special case.
	* emultempl/beos.em (gld_${EMULATION_NAME}_set_symbols): Update
	call to exp_assign.
	* emultempl/pe.em (gld_${EMULATION_NAME}_set_symbols): Likewise.
	* emultempl/pep.em (gld_${EMULATION_NAME}_set_symbols): Likewise.
	* emultempl/spuelf.em (spu_place_special_section): Likewise.
	* emultempl/xtensaelf.em (ld_xtensa_insert_page_offsets):
	Likewise.
	* ld.texinfo (Assigning Values to Symbols): Add HIDDEN.
	(HIDDEN): New subsection.
@
text
@d46 1
a46 1
static unsigned int no_overlays = 0;  
d554 1
a554 1
      if (NULL != pex_return) {      
@


1.47
log
@	PR ld/14357
	* ldmain.c (trace_file_tries): Rename to 'verbose'.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldmain.h: Likewise.
	* lexsup.c: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultemp/spuelf.em: Likewise.
	* pe-dll.c (pe_dll_generate_implib): Only print creation message
	in verbose mode.
@
text
@d168 1
a168 1
	  lang_add_assignment (exp_assign (".", e_size));
@


1.47.2.1
log
@bfd/
2012-08-09  Maciej W. Rozycki  <macro@@codesourcery.com>

	* elfxx-mips.c (LA25_LUI_MICROMIPS_1, LA25_LUI_MICROMIPS_2):
	Remove macros, folding them into...
	(LA25_LUI_MICROMIPS): ... this new macro.
	(LA25_J_MICROMIPS_1, LA25_J_MICROMIPS_2): Likewise into...
	(LA25_J_MICROMIPS): ... this new macro.
	(LA25_ADDIU_MICROMIPS_1, LA25_ADDIU_MICROMIPS_2): Likewise
	into...
	(LA25_ADDIU_MICROMIPS): ... this new macro.
	(bfd_put_micromips_32, bfd_get_micromips_32): New functions.
	(mips_elf_create_la25_stub): Use them.
	(check_br32_dslot, check_br32, check_relocated_bzc): Likewise.
	(_bfd_mips_elf_relax_section): Likewise.

gas/
	* config/tc-mips.c (NO_ISA_COP, COP_INSN): Remove macros.
	(is_opcode_valid): Remove coprocessor instruction exclusions.
	Replace OPCODE_IS_MEMBER with opcode_is_member.
	(is_opcode_valid_16): Replace OPCODE_IS_MEMBER with
	opcode_is_member.
	(macro): Remove coprocessor instruction exclusions.

gas/
	* gas/mips/mips.exp: Set has_newabi for all Linux targets.
	* gas/mips/cfi-n64-1.d: Adjust for targets that do not infer the
	ISA from the ABI.
	* gas/mips/elf-rel-got-n32.d: Likewise.
	* gas/mips/elf-rel-got-n64.d: Likewise.
	* gas/mips/elf-rel-xgot-n32.d: Likewise.
	* gas/mips/elf-rel-xgot-n64.d: Likewise.
	* gas/mips/elf-rel18.d: Likewise.
	* gas/mips/elf-rel28-n32.d: Likewise.
	* gas/mips/elf-rel28-n64.d: Likewise.
	* gas/mips/jal-newabi.d: Likewise.
	* gas/mips/ldstla-n64-shared.d: Likewise.
	* gas/mips/ldstla-n64-sym32.d: Likewise.
	* gas/mips/ldstla-n64.d: Likewise.
	* gas/mips/macro-warn-1-n32.d: Likewise.
	* gas/mips/macro-warn-2-n32.d: Likewise.
	* gas/mips/n32-consec.d: Likewise.

include/
2012-08-13  Richard Sandiford  <rdsandiford@@googlemail.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips.h (mips_opcode): Add the exclusions field.
	(OPCODE_IS_MEMBER): Remove macro.
	(cpu_is_member): New inline function.
	(opcode_is_member): Likewise.

ld/
	* emulparams/elf32bmip.sh: Make _gp hidden.
	* emulparams/elf32bmipn32-defs.sh: Likewise.
	* emulparams/elf32mipswindiss.sh: Likewise.
	* scripttempl/mips.sc: Likewise.

ld/
2012-08-28  Maciej W. Rozycki  <macro@@codesourcery.com>

	* ld-elf/export-class.sd: New test.
	* ld-elf/export-class.vd: New test.
	* ld-elf/export-class-def.s: New test source.
	* ld-elf/export-class-dep.s: New test source.
	* ld-elf/export-class-lib.s: New test source.
	* ld-elf/export-class-ref.s: New test source.
	* ld-elf/export-class-lib.ver: New test version script.
	* ld-elf/export-class.exp: New test script.
	* ld-arm/arm-export-class.rd: New test.
	* ld-arm/arm-export-class.xd: New test.
	* ld-arm/export-class.exp: New test script.
	* ld-i386/i386-export-class.rd: New test.
	* ld-i386/i386-export-class.xd: New test.
	* ld-i386/export-class.exp: New test script.
	* ld-mips-elf/mips-32-export-class.rd: New test.
	* ld-mips-elf/mips-32-export-class.xd: New test.
	* ld-mips-elf/mips-64-export-class.rd: New test.
	* ld-mips-elf/mips-64-export-class.xd: New test.
	* ld-mips-elf/export-class.exp: New test script.
	* ld-powerpc/powerpc-32-export-class.rd: New test.
	* ld-powerpc/powerpc-32-export-class.xd: New test.
	* ld-powerpc/powerpc-64-export-class.rd: New test.
	* ld-powerpc/powerpc-64-export-class.xd: New test.
	* ld-powerpc/export-class.exp: New test script.
	* ld-x86-64/x86-64-64-export-class.rd: New test.
	* ld-x86-64/x86-64-x32-export-class.rd: New test.
	* ld-x86-64/export-class.exp: New test script.

opcodes/
2012-08-14  Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips-dis.c (print_insn_args): Add GET_OP and GET_OP_S local
	macros, use local variables for info struct member accesses,
	update the type of the variable used to hold the instruction
	word.
	(print_insn_mips, print_mips16_insn_arg): Likewise.
	(print_insn_mips16): Add GET_OP and GET_OP_S local macros, use
	local variables for info struct member accesses.
	(print_insn_micromips): Add GET_OP_S local macro.
	(_print_insn_mips): Update the type of the variable used to hold
	the instruction word.
@
text
@d168 1
a168 1
	  lang_add_assignment (exp_assign (".", e_size, FALSE));
@


1.46
log
@
Add support for PowerPC VLE.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	* NEWS:  Mention PowerPC VLE port.

2012-05-14  James Lemke <jwlemke@@codesourcery.com>
	    Catherine Moore  <clm@@codesourcery.com>

	bfd/
	* bfd.c (bfd_lookup_section_flags): Add section parm.
	* ecoff.c (bfd_debug_section): Remove flag_info initializer.
	* elf-bfd.h (bfd_elf_section_data): Move in section_flag_info.
	(bfd_elf_lookup_section_flags): Add section parm.
	* elf32-ppc.c (is_ppc_vle): New function.
	(ppc_elf_modify_segment_map): New function.
	(elf_backend_modify_segment_map): Define.
	(has_vle_insns): New define.
	* elf32-ppc.h (ppc_elf_modify_segment_map): Declare.
	* elflink.c (bfd_elf_lookup_section_flags): Add return value & parm.
	Move in logic to omit / include a section.
	* libbfd-in.h (bfd_link_info): Add section parm.
	(bfd_generic_lookup_section_flags): Likewise.
	* reloc.c (bfd_generic_lookup_section_flags): Likewise.
	* section.c (bfd_section): Move out section_flag_info.
	(BFD_FAKE_SECTION): Remove flag_info initializer.
	* targets.c (_bfd_lookup_section_flags): Add section parm.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	bfd/
	* archures.c (bfd_mach_ppc_vle): New.
	* bfd-in2.h: Regenerated.
	* cpu-powerpc.c (bfd_powerpc_archs): New entry for vle.
	* elf32-ppc.c (split16_format_type): New enumeration.
	(ppc_elf_vle_split16): New function.
	(HOWTO): Add entries for R_PPC_VLE relocations.
	(ppc_elf_reloc_type_lookup): Handle PPC_VLE relocations.
	(ppc_elf_section_flags): New function.
	(ppc_elf_lookup_section_flags): New function.
	(ppc_elf_section_processing): New function.
	(ppc_elf_check_relocs): Handle PPC_VLE relocations.
	(ppc_elf_relocation_section): Likewise.
	(elf_backend_lookup_section_flags_hook): Define.
	(elf_backend_section_flags): Define.
	(elf_backend_section_processing): Define.
	* elf32-ppc.h (ppc_elf_section_processing): Declare.
	* libbfd.h: Regenerated.
	* reloc.c (BFD_RELOC_PPC_VLE_REL8, BFD_RELOC_PPC_VLE_REL15,
	BFD_RELOC_PPC_VLE_REL24, BFD_RELOC_PPC_VLE_LO16A,
	BFD_RELOC_PPC_VLE_LO16D, BFD_RELOC_PPC_VLE_HI16A,
	BFD_RELOC_PPC_VLE_HI16D, BFD_RELOC_PPC_VLE_HA16A,
	BFD_RELOC_PPC_VLE_HA16D, BFD_RELOC_PPC_VLE_SDA21,
	BFD_RELOC_PPC_VLE_SDA21_LO, BFD_RELOC_PPC_VLE_SDAREL_LO16A,
	BFD_RELOC_PPC_VLE_SDAREL_LO16D, BFD_RELOC_PPC_VLE_SDAREL_HI16A,
	BFD_RELOC_PPC_VLE_SDAREL_HI16D, BFD_RELOC_PPC_VLE_SDAREL_HA16A,
	BFD_RELOC_PPC_VLE_SDAREL_HA16D): New bfd relocations.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	gas/
	* config/tc-ppc.c (insn_validate): New func of existing code to call..
	(ppc_setup_opcodes): ..from 2 places here.
	Revise for second (VLE) opcode table.
	Add #ifdef'd code to print opcode tables.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	gas/
	* config/tc-ppc.c (ppc_setup_opcodes): Allow out-of-order
	for the VLE conditional branches.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>

	gas/
	* config/tc-ppc.c (PPC_VLE_SPLIT16A): New macro.
	(PPC_VLE_SPLIT16D): New macro.
	(PPC_VLE_LO16A): New macro.
	(PPC_VLE_LO16D): New macro.
	(PPC_VLE_HI16A): New macro.
	(PPC_VLE_HI16D): New macro.
	(PPC_VLE_HA16A): New macro.
	(PPC_VLE_HA16D): New macro.
	(PPC_APUINFO_VLE): New definition.
	(md_chars_to_number): New function.
	(md_parse_option): Check for combinations of little
	endian and -mvle.
	(md_show_usage): Document -mvle.
	(ppc_arch): Recognize VLE.
	(ppc_mach): Recognize bfd_mach_ppc_vle.
	(ppc_setup_opcodes): Print the opcode table if
	* config/tc-ppc.h (ppc_frag_check): Declare.
	* doc/c-ppc.texi: Document -mvle.
	* NEWS:  Mention PowerPC VLE port.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	gas/
	* config/tc-ppc.h (ppc_dw2_line_min_insn_length): Declare.
	(DWARF2_LINE_MIN_INSN_LENGTH): Redefine.
	* config/tc-ppc.c (ppc_dw2_line_min_insn_length): New.
	* dwarf2dbg.c (scale_addr_delta): Handle values of 1
	for DWARF2_LINE_MIN_INSN_LENGTH.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>

	gas/testsuite/
	* gas/ppc/ppc.exp: Run new tests.
	* gas/ppc/vle-reloc.d: New test.
	* gas/ppc/vle-reloc.s: New test.
	* gas/ppc/vle-simple-1.d: New test.
	* gas/ppc/vle-simple-1.s: New test.
	* gas/ppc/vle-simple-2.d: New test.
	* gas/ppc/vle-simple-2.s: New test.
	* gas/ppc/vle-simple-3.d: New test.
	* gas/ppc/vle-simple-3.s: New test.
	* gas/ppc/vle-simple-4.d: New test.
	* gas/ppc/vle-simple-4.s: New test.
	* gas/ppc/vle-simple-5.d: New test.
	* gas/ppc/vle-simple-5.s: New test.
	* gas/ppc/vle-simple-6.d: New test.
	* gas/ppc/vle-simple-6.s: New test.
	* gas/ppc/vle.d: New test.
	* gas/ppc/vle.s: New test.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>
	include/elf/
	* ppc.h (SEC_PPC_VLE): Remove.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
	    James Lemke  <jwlemke@@codesourcery.com>

	include/elf/
	* ppc.h (R_PPC_VLE_REL8): New reloction.
	(R_PPC_VLE_REL15): Likewise.
	(R_PPC_VLE_REL24): Likewise.
	(R_PPC_VLE_LO16A): Likewise.
	(R_PPC_VLE_LO16D): Likewise.
	(R_PPC_VLE_HI16A): Likewise.
	(R_PPC_VLE_HI16D): Likewise.
	(R_PPC_VLE_HA16A): Likewise.
	(R_PPC_VLE_HA16D): Likewise.
	(R_PPC_VLE_SDA21): Likewise.
	(R_PPC_VLE_SDA21_LO): Likewise.
	(R_PPC_VLE_SDAREL_LO16A): Likewise.
	(R_PPC_VLE_SDAREL_LO16D): Likewise.
	(R_PPC_VLE_SDAREL_HI16A): Likewise.
	(R_PPC_VLE_SDAREL_HI16D): Likewise.
	(R_PPC_VLE_SDAREL_HA16A): Likewise.
	(R_PPC_VLE_SDAREL_HA16D): Likewise.
	(SEC_PPC_VLE): Remove.
	(PF_PPC_VLE): New program header flag.
	(SHF_PPC_VLE): New section header flag.
	(vle_opcodes, vle_num_opcodes): New.
	(VLE_OP): New macro.
	(VLE_OP_TO_SEG): New macro.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>

	include/opcode/
	* ppc.h (PPC_OPCODE_VLE): New definition.
	(PPC_OP_SA): New macro.
	(PPC_OP_SE_VLE): New macro.
	(PPC_OP): Use a variable shift amount.
	(powerpc_operand): Update comments.
	(PPC_OPSHIFT_INV): New macro.
	(PPC_OPERAND_CR): Replace with...
	(PPC_OPERAND_CR_BIT): ...this and
	(PPC_OPERAND_CR_REG): ...this.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	ld/
	* ldlang.c (walk_wild_consider_section): Don't copy section_flag_list.
	Pass it to callback.
	(walk_wild_section_general): Pass section_flag_list to callback.
	(lang_add_section): Add sflag_list parm.
	Move out logic to keep / omit a section & call bfd_lookup_section_flags.
	(output_section_callback_fast): Add sflag_list parm.
	Add new parm to lang_add_section calls.
	(output_section_callback): Likewise.
	(check_section_callback): Add sflag_list parm.
	(lang_place_orphans): Add new parm to lang_add_section calls.
	(gc_section_callback): Add sflag_list parm.
	(find_relro_section_callback): Likewise.
	* ldlang.h (callback_t): Add flag_info parm.
	(lang_add_section): Add sflag_list parm.
	* emultempl/armelf.em (elf32_arm_add_stub_section):
	Add lang_add_section parm.
	* emultempl/beos.em (gld*_place_orphan): Likewise.
	* emultempl/elf32.em (gld*_place_orphan): Likewise.
	* emultempl/hppaelf.em (hppaelf_add_stub_section): Likewise.
	* emultempl/m68hc1xelf.em (m68hc11elf_add_stub_section): Likewise.
	* emultempl/mipself.em (mips_add_stub_section): Likewise.
	* emultempl/mmo.em (mmo_place_orphan): Likewise.
	* emultempl/pe.em (gld_*_place_orphan): Likewise.
	* emultempl/pep.em (gld_*_place_orphan): Likewise.
	* emultempl/ppc64elf.em (ppc_add_stub_section): Likewise.
	* emultempl/spuelf.em (spu_place_special_section): Likewise.
	* emultempl/vms.em (vms_place_orphan): Likewise.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	ld/testsuite/
	* ld-powerpc/powerpc.exp: Create ppceabitests.
	* ld-powerpc/vle-multiseg.s: New.
	* ld-powerpc/vle-multiseg-1.d: New.
	* ld-powerpc/vle-multiseg-1.ld: New.
	* ld-powerpc/vle-multiseg-2.d: New.
	* ld-powerpc/vle-multiseg-2.ld: New.
	* ld-powerpc/vle-multiseg-3.d: New.
	* ld-powerpc/vle-multiseg-3.ld: New.
	* ld-powerpc/vle-multiseg-4.d: New.
	* ld-powerpc/vle-multiseg-4.ld: New.
	* ld-powerpc/vle-multiseg-5.d: New.
	* ld-powerpc/vle-multiseg-5.ld: New.
	* ld-powerpc/vle-multiseg-6.d: New.
	* ld-powerpc/vle-multiseg-6.ld: New.
	* ld-powerpc/vle-multiseg-6a.s: New.
	* ld-powerpc/vle-multiseg-6b.s: New.
	* ld-powerpc/vle-multiseg-6c.s: New.
	* ld-powerpc/vle-multiseg-6d.s: New.
	* ld-powerpc/powerpc.exp: Run new tests.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	ld/
	* NEWS:  Mention PowerPC VLE port.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	ld/testsuite/
	* ld-powerpc/apuinfo.rd: Update for VLE.
	* ld-powerpc/vle-reloc-1.d: New.
	* ld-powerpc/vle-reloc-1.s: New.
	* ld-powerpc/vle-reloc-2.d: New.
	* ld-powerpc/vle-reloc-2.s: New.
	* ld-powerpc/vle-reloc-3.d: New.
	* ld-powerpc/vle-reloc-3.s: New.
	* ld-powerpc/vle-reloc-def-1.s: New.
	* ld-powerpc/vle-reloc-def-2.s: New.
	* ld-powerpc/vle-reloc-def-3.s: New.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	opcodes/
	* ppc-dis.c (get_powerpc_dialect): Use is_ppc_vle.
	(PPC_OPCD_SEGS, VLE_OPCD_SEGS): New defines.
	(vle_opcd_indices): New array.
	(lookup_vle): New function.
	(disassemble_init_powerpc): Revise for second (VLE) opcode table.
	(print_insn_powerpc): Likewise.
	* ppc-opc.c: Likewise.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>
	    Nathan Froyd <froydnj@@codesourcery.com>

	opcodes/
	* ppc-opc.c (insert_arx, extract_arx): New functions.
	(insert_ary, extract_ary): New functions.
	(insert_li20, extract_li20): New functions.
	(insert_rx, extract_rx): New functions.
	(insert_ry, extract_ry): New functions.
	(insert_sci8, extract_sci8): New functions.
	(insert_sci8n, extract_sci8n): New functions.
	(insert_sd4h, extract_sd4h): New functions.
	(insert_sd4w, extract_sd4w): New functions.
	(insert_vlesi, extract_vlesi): New functions.
	(insert_vlensi, extract_vlensi): New functions.
	(insert_vleui, extract_vleui): New functions.
	(insert_vleil, extract_vleil): New functions.
 	(BI_MASK, BB_MASK, BT): Use PPC_OPERAND_CR_BIT.
 	(BI16, BI32, BO32, B8): New.
	(B15, B24, CRD32, CRS): New.
 	(CRD, OBF, BFA, CR, CRFS): Use PPC_OPERAND_CR_REG.
	(DB, IMM20, RD, Rx, ARX, RY, RZ): New.
	(ARY, SCLSCI8, SCLSCI8N, SE_SD, SE_SDH): New.
	(SH6_MASK): Use PPC_OPSHIFT_INV.
	(SI8, UI5, OIMM5, UI7, BO16): New.
	(VLESIMM, VLENSIMM, VLEUIMM, VLEUIMML): New.
	(XT6, XA6, XB6, XB6S, XC6): Use PPC_OPSHIFT_INV.
	(ALLOW8_SPRG): New.
	(insert_sprg, extract_sprg): Check ALLOW8_SPRG.
	(OPVUP, OPVUP_MASK OPVUP): New
	(BD8, BD8_MASK, BD8IO, BD8IO_MASK): New.
	(EBD8IO, EBD8IO1_MASK, EBD8IO2_MASK, EBD8IO3_MASK): New.
	(BD15, BD15_MASK, EBD15, EBD15_MASK, EBD15BI, EBD15BI_MASK): New.
	(BD24,BD24_MASK, C_LK, C_LK_MASK, C, C_MASK): New.
 	(IA16, IA16_MASK, I16A, I16A_MASK, I16L, I16L_MASK): New.
	(IM7, IM7_MASK, LI20, LI20_MASK, SCI8, SCI8_MASK): New.
	(SCI8BF, SCI8BF_MASK, SD4, SD4_MASK): New.
	(SE_IM5, SE_IM5_MASK): New.
	(SE_R, SE_R_MASK, SE_RR, SE_RR_MASK): New.
	(EX, EX_MASK, BO16F, BO16T, BO32F, BO32T): New.
	(BO32DNZ, BO32DZ): New.
	(NO371, PPCSPE, PPCISEL, PPCEFS, MULHW): Include PPC_OPCODE_VLE.
	(PPCVLE): New.
	(powerpc_opcodes): Add new VLE instructions.  Update existing
	instruction to include PPCVLE if supported.
	* ppc-dis.c (ppc_opts): Add vle entry.
	(get_powerpc_dialect): New function.
	(powerpc_init_dialect): VLE support.
	(print_insn_big_powerpc): Call get_powerpc_dialect.
	(print_insn_little_powerpc): Likewise.
	(operand_value_powerpc): Handle negative shift counts.
	(print_insn_powerpc): Handle 2-byte instruction lengths.
@
text
@d538 1
a538 1
  if (trace_file_tries)
@


1.45
log
@	* ldlang.h (struct lang_input_statement_flags): New, extract from..
	(lang_input_statement_type): ..here.  New field "flags".
	(input_flags): Declare.
	(missing_file): Delete.
	* ldmain.h (whole_archive): Delete.
	(add_DT_NEEDED_for_regular, add_DT_NEEDED_for_dynamic): Delete.
	* ld.h (ld_config_type <dynamic_link>): Delete.
	* ldmain.c (whole_archive): Delete.
	(add_DT_NEEDED_for_regular, add_DT_NEEDED_for_dynamic): Delete.
	* ldlang.c (missing_file, ldlang_sysrooted_script): Delete.
	(input_flags): New variable.  Replace all uses of config.dynamic_link,
	missing_file, ldlang_sysrooted_script, whole_archive,
	add_DT_NEEDED_for_regular and add_DT_NEEDED_for_dynamic with fields
	from here.
	* ldfile.c: Likewise.
	* ldgram.y: Likewise.
	* ldmain.c: Likewise.
	* ldwrite.c: Likewise.
	* lexsup.c: Likewise.
	* plugin.c: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vms.em: Likewise.
	* ldlang.c (new_afile): Use memset to init zero fields.
	(load_symbols): Simplify save and restore of flags around command
	file processing.
	* ldfile.c (is_sysrooted_pathname): Tidy.
@
text
@d154 1
a154 1
      lang_add_section (&add, s, os);
d171 1
a171 1
      lang_add_section (&os->children, s, os);
@


1.44
log
@	* emultempl/spuelf.em (spu_elf_relink): Use pex_one in place
	of execvp.
@
text
@d2 1
a2 1
#   Copyright 2006, 2007, 2008, 2009, 2010, 2011
d582 1
a582 1
  entry->loaded = TRUE;
@


1.43
log
@	PR ld/12356
	* ldexp.h (exp_assop): Delete.
	(exp_assign, exp_defsym): Declare.
	* ldexp.c (exp_assop): Make static, handle all assignment variations.
	(exp_assign, exp_defsym): New functions.
	(exp_provide): Use exp_assop.
	* ldgram.y (defsym_expr): Use exp_defsym.
	* ldctor.c, * ldgram.y, * ldlang.c, * mri.c, * emultempl/beos.em,
	* emultempl/pe.em, * emultempl/pep.em, * emultempl/spuelf.em,
	* emultempl/xtensaelf.em: Update exp_assop -> exp_assign.
@
text
@d387 2
d392 2
d404 10
a413 3
  execvp (argv[0], (char *const *) argv);
  perror (argv[0]);
  _exit (127);
@


1.42
log
@ld/
2010-11-05 Pierre Muller <muller@@ics.u-strasbg.fr>

	* emultempl/spuelf.em (new_tmp_file): Fix wrong first parameter.
@
text
@d2 2
a3 1
#   Copyright 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d168 1
a168 1
	  lang_add_assignment (exp_assop ('=', ".", e_size));
@


1.41
log
@	PR 10474
	* ldemul.c (after_allocation_default): Run lang_relax_sections.
	* ldlang.h (lang_relax_sections): Declare.
	* ldlang.c (relax_sections): Delete.
	(lang_relax_sections): New function.
	(lang_process): Don't relax directly from here.
	* emultempl/alphaelf.em (alpha_finish): Call finish_default.
	* emultempl/armelf.em (arm_elf_after_allocation): Delete.  Move body..
	(gld${EMULATION_NAME}_finish): ..to here.  Move existing code..
	(gld${EMULATION_NAME}_after_allocation): ..to here.  New function.
	(LDEMUL_AFTER_ALLOCATION): Update.
	* emultempl/avrelf.em (avr_elf_finish, LDEMUL_FINISH): Delete.
	(avr_elf_after_allocation): New function.
	(LDEMUL_AFTER_ALLOCATION): Define.
	* emultempl/elf-generic.em (gld${EMULATION_NAME}_map_segments): Call
	lang_relax_sections.
	* emultempl/elf32.em (gld${EMULATION_NAME}_finish): Delete.  Move..
	(gld${EMULATION_NAME}_after_allocation): ..code to here.  New function.
	(LDEMUL_AFTER_ALLOCATION, LDEMUL_FINISH): Update.
	* emultempl/genelf.em (gld${EMULATION_NAME}_finish): Delete.  Move..
	(gld${EMULATION_NAME}_after_allocation): ..code to here.  New function.
	(LDEMUL_FINISH): Delete.
	(LDEMUL_AFTER_ALLOCATION): Define.
	* emultempl/hppaelf.em (gld${EMULATION_NAME}_finish): Delete.  Move..
	(gld${EMULATION_NAME}_after_allocation): ..to here.  New function.
	(LDEMUL_FINISH): Delete.
	(LDEMUL_AFTER_ALLOCATION): Define.
	* emultempl/m68hc1xelf.em (m68hc11elf_finish): Delete.  Move..
	(m68hc11elf_after_allocation): ..to here.  New function.
	(LDEMUL_FINISH): Delete.
	(LDEMUL_AFTER_ALLOCATION): Define.
	* emultempl/m68kelf.em (m68k_elf_after_allocation): Call
	gld${EMULATION_NAME}_after_allocation.
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): Call
	gld${EMULATION_NAME}_after_allocation.
	* emultempl/mmo.em (mmo_finish): Delete.  Move body..
	(gld${EMULATION_NAME}_after_allocation): ..to here.  New function.
	(LDEMUL_FINISH): Define.
	* emultempl/ppc64elf.em (ppc_layout_sections_again): Set elf_gp.
	(gld${EMULATION_NAME}_finish): Move code sizing sections..
	(gld${EMULATION_NAME}_after_allocation): ..to here.
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_after_allocation):
	Call gld${EMULATION_NAME}_after_allocation.
	* emultempl/spuelf.em (gld${EMULATION_NAME}_finish): Delete
	bfd_elf_discard_info and map_segments call.
@
text
@d358 1
a358 1
  fd = open (fname, O_RDWR | O_CREAT | O_EXCL, 0600);
@


1.41.4.1
log
@Backport

	ld/
	2010-11-05? Pierre Muller? <muller@@ics.u-strasbg.fr>

	* emultempl/spuelf.em (new_tmp_file): Fix wrong first parameter.
@
text
@d358 1
a358 1
  fd = open (*fname, O_RDWR | O_CREAT | O_EXCL, 0600);
@


1.41.4.2
log
@backport from mainline
@
text
@d2 1
a2 2
#   Copyright 2006, 2007, 2008, 2009, 2010, 2011
#   Free Software Foundation, Inc.
d167 1
a167 1
	  lang_add_assignment (exp_assign (".", e_size));
@


1.40
log
@bfd/
	* elf32-spu.h (spu_elf_params): Add member emit_fixups.
	(spu_elf_size_sections): Declare prototype.
	* elf32-spu.c (spu_link_hash_table): Add member sfixup.
	(FIXUP_RECORD_SIZE, FIXUP_GET, FIXUP_PUT): New macros.
	(spu_elf_emit_fixup): New function.
	(spu_elf_relocate_section): Emit fixup for each SPU_ADDR32.
	(spu_elf_size_sections): New function.
ld/
	* emulparams/elf32_spu.sh (OTHER_READONLY_SECTIONS): Add .fixup
	section and __fixup_start symbol.
	* emultempl/spuelf.em (params): Initialize emit_fixups member.
	(spu_before_allocation): Call spu_elf_size_sections.
	(OPTION_SPU_EMIT_FIXUPS): Define.
	(PARSE_AND_LIST_LONGOPTS): Add --emit-fixups.
	(PARSE_AND_LIST_ARGS_CASES): Handle --emit-fixups.
	* ld.texinfo (--emit-fixups): Document.
ld/testsuite/
	* ld-spu/fixup.d: New.
	* ld-spu/fixup.s: New.
@
text
@a408 6
  int need_laying_out;

  need_laying_out = bfd_elf_discard_info (link_info.output_bfd, &link_info);

  gld${EMULATION_NAME}_map_segments (need_laying_out);

@


1.39
log
@bfd/
	* elf32-spu.c (build_stub): Always build "compact" sofware
	i-cache stubs.

ld/
	* emultempl/spuelf.em (PARSE_AND_LIST_ARGS_CASES): Always use
	compact stubs with software i-cache.

ld/testsuite/
	* ld-spu/icache1.d: Update for compact stubs.
@
text
@d40 1
a40 1
  0, ovly_normal, 0, 0, 0, 0, 0, 0, 0,
d319 4
d607 1
d633 1
d821 4
@


1.38
log
@bfd/
	* elf32-spu.c (spu_elf_size_stubs): Split out section placement to..
	(spu_elf_place_overlay_data): ..here.  New function.
	* elf32-spu.h (spu_elf_place_overlay_data): Declare.
ld/
	* emultempl/spuelf.em (spu_before_allocation): Call
	spu_elf_place_overlay_data.
ld/testsuite/
	* ld-spu/icache1.d: Update for changed overlay manager placement.
	* ld-spu/ovl.d: Likewise.
	* ld-spu/ovl2.d: Likewise.
@
text
@d722 2
@


1.37
log
@	* emultempl/spuelf.em (embedded_spu_file): Use pex_one in place
	of fork/execvp.
@
text
@d311 2
@


1.36
log
@bfd/
	* elf32-spu.c (spu_elf_find_overlays): Separate error return from
	"no overlays" return.  If there are overlays, create overlay
	manager entry symbols here, so that..
	(spu_elf_build_stubs): ..we don't need to set them up here.
	Simplify entry symbol tests.
	* elf32-spu.h (spu_elf_find_overlays): Update prototype.
ld/
	* emultempl/spuelf.em (spu_before_allocation): Report errors from
	spu_elf_find_overlays.
@
text
@d438 1
d440 1
a440 2
#include <fcntl.h>
#include <sys/wait.h>
d473 1
a477 1
  pid_t pid;
a519 2
  /* Use fork() and exec() rather than system() so that we don't
     need to worry about quoting args.  */
d533 3
a535 6
  pid = fork ();
  if (pid == -1)
    return FALSE;
  if (pid == 0)
    {
      execvp (cmd[0], (char *const *) cmd);
d539 2
a540 1
	  execvp (cmd[0], (char *const *) cmd);
d542 6
a547 11
      perror (cmd[0]);
      _exit (127);
    }
#ifdef HAVE_WAITPID
#define WAITFOR(PID, STAT) waitpid (PID, STAT, 0)
#else
#define WAITFOR(PID, STAT) wait (STAT)
#endif
  if (WAITFOR (pid, &status) != pid
      || !WIFEXITED (status)
      || WEXITSTATUS (status) != 0)
d549 1
a549 1
#undef WAITFOR
@


1.35
log
@bfd/
	* elf32-spu.h (struct spu_elf_params): ovly_flavour now only 1 bit.
	Add compact_stub.
	(emum _ovly_flavour): Delete ovly_compact, ovly_none.
	* elf32-spu.c (struct spu_link_hash_table): Replace ovly_load and
	ovly_return fields with ovly_entry[2].  Adjust all users.
	(spu_elf_find_overlays): Set ovly_entry[1] from __icache_call_handler
	when soft-icache.
	(spu_elf_build_stubs): Likewise.
	(ovl_stub_size): Change arg to spu_elf_params pointer.  Adjust for
	ovly_flavour changes.  Update all callers.
	(ovl_stub_size_log2): New function.
	(build_stub): Handle compact icache stubs.  Use different manager
	entry point for stubs in non-icache area.
	(spu_elf_size_stubs): Don't allocate space for indirect branch
	descriptors.
	(spu_elf_build_stubs): And don't built them.
ld/
	* emultempl/spu_icache.S: Add new entry to dummy handler.
	* emultempl/spu_icache.o_c: Regenerate.
	* emultempl/spuelf.em (params): Init new field.
	(no_overlays): New static var.
	(spu_before_allocation): Use it.
	(OPTION_SPU_COMPACT_STUBS): Define.
	(PARSE_AND_LIST_LONGOPTS, PARSE_AND_LIST_OPTIONS): Add compact-stubs.
	(PARSE_AND_LIST_ARGS_CASES): Handle compact-stubs.  Adjust no-overlays
	handling.
ld/testsuite/
	* ld-spu/icache1.d: Update for fixed set_id, new manager entry, and
	reduced data.
@
text
@d269 2
d278 4
a281 1
      if (spu_elf_find_overlays (&link_info))
a282 1
	  int ret;
@


1.34
log
@	* ldlang.c (push_stat_ptr, pop_stat_ptr): New functions.
	(stat_save, stat_save_ptr): New variables.
	(lang_insert_orphan): Use push_stat_ptr and pop_stat_ptr.
	(load_symbols): Likewise.  Delete dead "bad_load" code.
	(open_input_bfds): Warn on script containing output sections.
	(lang_enter_output_section_statement): Use push_stat_ptr.
	(lang_enter_group): Likewise.
	(lang_leave_output_section_statement): Use pop_stat_ptr.
	(lang_leave_group): Likewise.
	* ldlang.h (push_stat_ptr, pop_stat_ptr): Declare.
	* ldctor.c (ldctor_build_sets): Use push_stat_ptr and pop_stat_ptr.
	* emultempl/beos.em (gld_${EMULATION_NAME}_set_symbols): Likewise.
	* emultempl/pe.em (gld_${EMULATION_NAME}_set_symbols): Likewise.
	* emultempl/pep.em (gld_${EMULATION_NAME}_set_symbols): Likewise.
	* emultempl/spuelf.em (spu_place_special_section): Likewise.
	* emultempl/xtensaelf.em (ld_xtensa_insert_page_offsets): Likewise.
@
text
@d40 1
a40 1
  0, ovly_normal, 0, 0, 0, 0, 0, 0,
d44 2
a45 1
  
d267 1
a267 1
      && params.ovly_flavour != ovly_none)
d588 2
a589 1
#define OPTION_SPU_STUB_SYMS		(OPTION_SPU_NO_OVERLAYS + 1)
d616 1
d637 1
d669 5
a673 1
      params.ovly_flavour = ovly_none;
@


1.33
log
@	* emultempl/spuelf.em (spu_after_open): Don't combine .text.ia.*
	during relocatable link.
@
text
@a162 1
	  lang_statement_list_type *save = stat_ptr;
d164 1
a164 1
	  stat_ptr = &os->children;
d167 1
a167 1
	  stat_ptr = save;
d560 1
a560 1
  /* lang_add_input_file put the new list entry at the end of the statement
@


1.32
log
@bfd/
	* elf32-spu.h (struct spu_elf_params): Add non_ia_text.
	* elf32-spu.c (mark_overlay_section): Only include .text.ia.*
	sections in soft-icache lines unless non_ia_text.  Don't add
	rodata if doing so would exceed line size.
ld/
	* emultempl/spuelf.em (params): Init new field.
	(OPTION_SPU_NON_IA_TEXT): Define.
	(PARSE_AND_LIST_LONGOPTS, PARSE_AND_LIST_OPTIONS): Add --non-ia-text.
	(PARSE_AND_LIST_ARGS_CASES): Handle OPTION_SPU_NON_IA_TEXT.
@
text
@d109 3
@


1.31
log
@bfd/
	* elf32-spu.c (struct spu_link_hash_table): Add init, line_size_log2,
	num_lines_log2.
	(struct got_entry): Add br_addr.
	(struct call_info): Add priority.
	(struct function_info): Add lr_store and sp_adjust.
	(spu_elf_setup): Init line_size_log2 and num_lines_log2.
	(spu_elf_find_overlays): For soft-icache, mark any section within cache
	area as an overlay, and check that no other overlays exist.  Look up
	icache overlay manager entry sym.
	(BRA_STUBS, BRA, BRASL): Define.
	(enum _stub_type): Replace ovl_stub with call_ovl_stub and br*_ovl_stub.
	(needs_ovl_stub): Adjust for soft-icache.  Return priority encoded
	in branch insn.
	(count_stub, build_stub): Support soft-icache.
	(build_spuear_stubs, process_stubs): Adjust build_stub call.
	(spu_elf_size_stubs): Size soft-icache stubs.
	(overlay_index): New function.
	(spu_elf_build_stubs): Make static.  Support soft-icache.
	(spu_elf_check_vma): Don't turn off auto_overlay if soft-icache.
	(find_function_stack_adjust): Save lr store and stack adjust insn
	offsets.
	(maybe_insert_function): Adjust find_function_stack_adjust call.
	(mark_functions_via_relocs): Retrieve priority.
	(remove_cycles): Only warn about pruned arcs when stack_analysis.
	(sort_calls): Sort by priority first.
	(mark_overlay_section): Ignore .ovl.init.
	(sum_stack): Only print when stack_analysis.
	(print_one_overlay_section): New function, extracted from..
	(spu_elf_auto_overlay): ..here.  Support soft-icache overlays.
	(spu_elf_stack_analysis): Only print when htab->stack_analysis.
	(spu_elf_final_link): Call spu_elf_stack_analysis for lrlive
	analysis.  Call spu_elf_build_stubs.
	(spu_elf_relocate_section): For soft-icache encode overlay index
	into addresses.
	(spu_elf_output_symbol_hook): Support soft-icache.
	(spu_elf_modify_program_headers: Likewise.
	* elf32-spu.h (struct spu_elf_params): Add lrlive_analysis.  Rename
	num_regions to num_lines.  Add line_size and max_branch.
	(enum _ovly_flavour): Add ovly_soft_icache.
	(spu_elf_build_stubs): Delete.
gas/
	* config/tc-spu.c (md_pseudo_table): Add "brinfo".
	(brinfo): New var.
	(md_assemble): Poke brinfo into branch instructions.
	(spu_brinfo): New function.
	(md_apply_fix): Don't assume insn fields start off at zero, mask
	them to remove possible brinfo.
ld/
	* emultempl/spuelf.em (params): Init new fields.
	(num_lines_set, line_size_set, icache_mgr, icache_mgr_stream): New vars.
	(spu_place_special_section): Adjust placement for soft-icache.  Pad
	soft-icache section to a fixed size.  Clear addr_tree.
	(spu_elf_load_ovl_mgr): Support soft-icache.  Map overlay manager
	sections a little more intelligently.
	(gld${EMULATION_NAME}_finish): Don't call spu_elf_build_stubs.
	(OPTION_SPU_NUM_LINES): Rename from OPTION_SPU_NUM_REGIONS.
	(OPTION_SPU_SOFT_ICACHE, OPTION_SPU_LINE_SIZE): Define.
	(OPTION_SPU_LRLIVE): Define.
	(PARSE_AND_LIST_LONGOPTS): Add new soft-icache options.
	(PARSE_AND_LIST_OPTIONS): Likewise.
	(PARSE_AND_LIST_ARGS_CASES): Handle them.
	* emultempl/spu_icache.S: Dummy file.
	* emultempl/spu_icache.o_c: Regenerate.
	* Makefile.am (eelf32_spu.c): Depend on spu_icache.o_c.
	(spu_icache.o_c): Add rule to build.
	(CLEANFILES): Zap temp files.
	(EXTRA_DIST): Add spu_icache.o_c.
	* Makefile.in: Regenerate.
ld/testsuite/
	* ld-spu/ovl.d: Allow for absolute branches in stubs.
	* ld-spu/ovl2.d: Likewise.
@
text
@d40 1
a40 1
  0, ovly_normal, 0, 0, 0, 0, 0,
d597 2
a598 1
#define OPTION_SPU_FIXED_SPACE		(OPTION_SPU_LRLIVE + 1)
d610 1
d652 1
d731 4
@


1.30
log
@bfd/
	* elf32-spu.h (struct spu_elf_params): Add num_regions.
	* elf32-spu.c (spu_elf_auto_overlay): Handle multiple overlay regions.
ld/
	* emultempl/spuelf.em (params): Init new field.
	(OPTION_SPU_NUM_REGIONS): Define.
	(PARSE_AND_LIST_LONGOPTS, PARSE_AND_LIST_OPTIONS): Add --num-regions.
	(PARSE_AND_LIST_ARGS_CASES): Handle --num-regions.
@
text
@d2 1
a2 1
#   Copyright 2006, 2007, 2008 Free Software Foundation, Inc.
d40 1
a40 1
  0, ovly_normal, 0, 0, 0, 0,
d42 1
a42 1
  1, 0, 0, 2000
d45 2
d57 14
a70 1
  echo >&2 "You must build gas/as-new with --target=spu to build spu_ovl.o"
d82 5
d119 2
a120 1
   If O is not NULL, add section S at the beginning of output section O.
d139 6
a144 2
    gld${EMULATION_NAME}_place_orphan (s, output_name, 0);
  else if (o != NULL && os->children.head != NULL)
d154 15
a168 1
    lang_add_section (&os->children, s, os);
d179 2
d183 7
d191 1
a191 1
			    "__ovly_load", FALSE, FALSE, FALSE);
d200 1
a200 1
  else if (ovl_mgr_stream.start == ovl_mgr_stream.end)
d210 1
a210 1
      if (!spu_elf_open_builtin_lib (&ovl_is->the_bfd, &ovl_mgr_stream))
d219 4
a222 1
	  /* Map overlay manager sections to output sections.  */
d227 24
a250 2
		total += in->size;
		spu_place_special_section (in, NULL, ".text");
a413 3

      if (!spu_elf_build_stubs (&link_info))
	einfo ("%F%P: can not build overlay stubs: %E\n");
d593 5
a597 2
#define OPTION_SPU_NUM_REGIONS		(OPTION_SPU_OVERLAY_RODATA + 1)
#define OPTION_SPU_FIXED_SPACE		(OPTION_SPU_NUM_REGIONS + 1)
d605 4
d618 2
a619 1
  { "num-regions", required_argument, NULL, OPTION_SPU_NUM_REGIONS },
d641 1
d646 5
a650 1
                              --reserved-space not given.\n"
d710 32
a741 1
    case OPTION_SPU_NUM_REGIONS:
d744 5
a748 2
	params.num_regions = strtoul (optarg, &end, 0);
	if (*end == 0)
d750 1
a750 1
	einfo (_("%P%F: invalid --num-regions `%s'\''\n"), optarg);
@


1.29
log
@bfd/
	* elf32-spu.g (struct spu_elf_params, enum _ovly_flavour): New.
	(spu_elf_setup): Declare.
	(spu_elf_create_sections, spu_elf_size_stubs): Update prototype.
	(spu_elf_build_stubs, spu_elf_check_vma): Likewise.
	* elf32-spu.c (struct spu_link_hash_table): Add "params". Remove
	various other fields now in "params".  Adjust code throughout.
	(struct call_info, struct function_info): Move earlier in file.
	(struct spu_elf_stack_info): Likewise.
	(spu_elf_setup): New function.
	(spu_elf_create_sections): Remove args other than "info".
	(spu_elf_size_stubs, spu_elf_build_stubs, spu_elf_check_vma): Likewise.
	(maybe_needs_stubs): Remove "output_bfd" arg.  Adjust all calls.
	(interesting_section): Similarly with "obfd" arg.
	(needs_ovl_stub): Adjust output_section test.
	(allocate_spuear_stubs): Likewise.
	(OVL_STUB_SIZE): Don't define.
	(ovl_stub_size): New function, use in place of OVL_STUB_SIZE.
	(build_stub): Test params->ovly_flavour rather than OVL_STUB_SIZE.
	(spu_elf_auto_overlay): Remove args other than "info".  Make use
	of size returned from spu_elf_load_ovl_mgr.
	(spu_elf_stack_analysis): Remove args other than "info".
	(spu_elf_relocate_section): Tidy setting of "ea".
ld/
	* emultempl/spuelf.em (params): New var, used instead of various others.
	Adjust use throughout file.
	(spu_after_open): Call spu_elf_setup.
	(spu_place_special_section): Tidy.
	(spu_elf_load_ovl_mgr): Return total size of sections loaded.  Move
	code setting overlay section alignment to..
	(spu_before_allocation): ..here.
@
text
@d42 1
a42 1
  0, 0, 2000
d523 2
a524 1
#define OPTION_SPU_FIXED_SPACE		(OPTION_SPU_OVERLAY_RODATA + 1)
d541 1
d562 1
d627 10
@


1.28
log
@	* ldemul.c (ldemul_place_orphan): Add "constraint" param.
	* ldemul.h (ldemul_place_orphan): Update prototype.
	(struct ld_emulation_xfer_struct <place_orphan>): Likewise add param.
	* ldlang.c (unique_section_p): Make static.
	(lang_output_section_statement_lookup): Optimise creation of SPECIAL
	sections.
	(lang_insert_orphan): Add "constraint" param.  Pass to
	lang_enter_output_section_statement.
	(init_os): Don't use an existing bfd section for SPECIAL sections.
	(lang_place_orphans): Don't rename unique output sections, instead
	mark their output section statements SPECIAL.
	* ldlang.h (lang_insert_orphan): Update prototype.
	(unique_section_p): Delete.
	* emultempl/beos.em (place_orphan): Add "constraint" param.
	* emultempl/elf32.em (place_orphan): Likewise.  Don't match existing
	output sections if set.
	* emultempl/pe.em (place_orphan): Likewise.
	* emultempl/pep.em (place_orphan): Likewise.
	* emultempl/mmo.em (mmo_place_orphan): Update.
	* emultempl/spuelf.em (spu_place_special_section): Update.
@
text
@d29 16
a44 21
/* Non-zero if no overlay processing should be done.  */
static int no_overlays = 0;

/* Non-zero if we want stubs on all calls out of overlay regions.  */
static int non_overlay_stubs = 0;

/* Whether to emit symbols for stubs.  */
static int emit_stub_syms = 0;

/* Non-zero to perform stack space analysis.  */
static int stack_analysis = 0;

/* Whether to emit symbols with stack requirements for each function.  */
static int emit_stack_syms = 0;

/* Range of valid addresses for loadable sections.  */
static bfd_vma local_store_lo = 0;
static bfd_vma local_store_hi = 0x3ffff;

/* Control --auto-overlay feature.  */
static int auto_overlay = 0;
a45 3
static unsigned int auto_overlay_fixed = 0;
static unsigned int auto_overlay_reserved = 0;
static int extra_stack_space = 2000;
d81 13
a93 6
  if (is_spu_target ()
      && !link_info.relocatable
      && link_info.input_bfds != NULL
      && !spu_elf_create_sections (&link_info,
				   stack_analysis, emit_stack_syms))
    einfo ("%X%P: can not create note section: %E\n");
d114 3
a116 1
  os = lang_output_section_find (o != NULL ? o->name : output_name);
d134 1
a134 1
/* Load built-in overlay manager, and tweak overlay section alignment.  */
d136 1
a136 1
static void
a138 1
  lang_output_section_statement_type *os;
d140 1
d175 4
a178 1
	      spu_place_special_section (in, NULL, ".text");
d181 1
a181 15

  /* Ensure alignment of overlay sections is sufficient.  */
  for (os = &lang_output_section_statement.head->output_section_statement;
       os != NULL;
       os = os->next)
    if (os->bfd_section != NULL
	&& spu_elf_section_data (os->bfd_section) != NULL
	&& spu_elf_section_data (os->bfd_section)->u.o.ovl_index != 0)
      {
	if (os->bfd_section->alignment_power < 4)
	  os->bfd_section->alignment_power = 4;

	/* Also ensure size rounds up.  */
	os->block_value = 16;
      }
d191 1
a191 1
      && !no_overlays)
d203 1
d205 1
a205 1
	  if (auto_overlay != 0)
d208 1
a208 1
	      auto_overlay = 0;
d211 16
a226 3
	  ret = spu_elf_size_stubs (&link_info,
				    spu_place_special_section,
				    non_overlay_stubs);
d331 1
a331 1
      if (local_store_lo < local_store_hi)
d335 2
a336 8
	  s = spu_elf_check_vma (&link_info, auto_overlay,
				 local_store_lo, local_store_hi,
				 auto_overlay_fixed, auto_overlay_reserved,
				 extra_stack_space,
				 spu_elf_load_ovl_mgr,
				 spu_elf_open_overlay_script,
				 spu_elf_relink);
	  if (s != NULL && !auto_overlay)
d339 1
a339 1
      else if (auto_overlay)
d342 1
a342 2
      if (!spu_elf_build_stubs (&link_info,
				emit_stub_syms || link_info.emitrelocations))
d574 1
a574 1
      no_overlays = 1;
d578 1
a578 1
      emit_stub_syms = 1;
d582 1
a582 1
      non_overlay_stubs = 1;
d588 1
a588 1
	local_store_lo = strtoul (optarg, &end, 0);
d591 1
a591 1
	    local_store_hi = strtoul (end + 1, &end, 0);
d600 1
a600 1
      stack_analysis = 1;
d604 1
a604 1
      emit_stack_syms = 1;
d608 1
a608 1
      auto_overlay |= 1;
d617 1
a617 1
      auto_overlay |= 2;
d621 1
a621 1
      auto_overlay |= 4;
d627 1
a627 1
	auto_overlay_fixed = strtoul (optarg, &end, 0);
d636 1
a636 1
	auto_overlay_reserved = strtoul (optarg, &end, 0);
d645 1
a645 1
	extra_stack_space = strtol (optarg, &end, 0);
d652 1
a652 1
      auto_overlay = 0;
@


1.27
log
@bfd/
	* elf.c (bfd_elf_set_group_contents): Assign sh_info for ld -r when
	the signature symbol is global.
	* elflink.c (elf_link_input_bfd): Ensure group signature symbol
	is output when ld -r.  Set group sh_info when local.
	* linker.c (default_indirect_link_order): Handle group sections
	specially.
ld/
	* ldemul.c (ldemul_place_orphan): Add "name" param.
	* ldemul.h (ldemul_place_orphan): Update prototype.
	(struct ld_emulation_xfer_struct <place_orphan>): Likewise.
	* ldlang.c (lang_place_orphans): Generate unique section names here..
	* emultempl/elf32.em (place_orphan): ..rather than here.  Don't
	directly use an existing output section statement that has no
	bfd section.
	* emultempl/pe.em (place_orphan): Likewise.
	* emultempl/pep.em (place_orphan): Likewise.
	* emultempl/beos.em (place_orphan): Adjust.
	* emultempl/spuelf.em (spu_place_special_section): Adjust
	place_orphan call.
	* emultempl/genelf.em (gld${EMULATION_NAME}_after_open): New function.
	(LDEMUL_AFTER_OPEN): Define.
@
text
@d117 1
a117 1
    gld${EMULATION_NAME}_place_orphan (s, output_name);
@


1.26
log
@	Include the spu_ovl ASCII form in the repository files.
	* emultempl/spuelf.em: No longer use `bin2c', use now `spu_ovl.o_c'.
	* Makefile.am (eelf32_spu.c): Depend now on `spu_ovl.o_c'.
	($(srcdir)/emultempl/spu_ovl.o_c): New target.
	($(srcdir)/emultempl/spu_ovl.o): Rename to...
	(spu_ovl.o): ...this one.
	* Makefile.in: Regenerate.
	* emultempl/spu_ovl.o_c: New file.
	* emultempl/spu_ovl.o: File removed.
@
text
@d117 1
a117 6
    {
      const char *save = s->name;
      s->name = output_name;
      gld${EMULATION_NAME}_place_orphan (s);
      s->name = save;
    }
@


1.26.2.1
log
@backport 2008-10-03  Alan Modra  <amodra@@bigpond.net.au>
@
text
@d117 6
a122 1
    gld${EMULATION_NAME}_place_orphan (s, output_name);
@


1.26.2.2
log
@backport 2008-10-04  Alan Modra  <amodra@@bigpond.net.au>
@
text
@d117 1
a117 1
    gld${EMULATION_NAME}_place_orphan (s, output_name, 0);
@


1.25
log
@	* emultempl/spuelf.em: Abort on the missing required `spu_ovl.o'.
@
text
@d60 1
a60 1
if ! ../binutils/bin2c < ${srcdir}/emultempl/spu_ovl.o >> e${EMULATION_NAME}.c
d62 1
a62 1
  echo >&2 "Missing ${srcdir}/emultempl/spu_ovl.o"
@


1.24
log
@	* emultempl/spuelf.em (gld${EMULATION_NAME}_finish): Make "can not
	build overlay stubs" a fatal error.
@
text
@d60 6
a65 1
../binutils/bin2c < ${srcdir}/emultempl/spu_ovl.o >> e${EMULATION_NAME}.c
@


1.23
log
@bfd/
	* elf32-spu.c (struct spu_link_hash_table): Add extra_stack_space.
	(spu_elf_check_vma): Add extra_stack_space param, copy to htab.
	(spu_elf_auto_overlay): Use it.
	(RECURSE_UNMARK): Define as 0.
	(unmark_overlay_section): Heed RECURSE_UNMARK.
	* elf32-spu.h (spu_elf_check_vma): Update prototype.
ld/
	* emultempl/spuelf.em (extra_stack_space): New variable.
	(gld${EMULATION_NAME}_finish): Pass it to spu_elf_check_vma.
	(PARSE_AND_LIST_LONGOPTS, PARSE_AND_LIST_OPTIONS,
	PARSE_AND_LIST_ARGS_CASES): Handle --extra-stack-space.
	* emultempl/spu_ovl.S: Mask interrupts during dma and update of
	overlay manager structures.
	* emultempl/spu_ovl.o: Regenerate.
@
text
@d346 1
a346 1
	einfo ("%X%P: can not build overlay stubs: %E\n");
@


1.22
log
@	* NEWS: Mention archive:path patterns.
	* ld.texinfo: Likewise.
	* ldlang.c: Formatting throughout.
	(archive_path): Only assume "[A-Za-z]:" is a dos drive.
	(input_statement_is_archive_path): New function, extracted from..
	(walk_wild): ..here.
	(walk_wild_consider_section): Match archive:path here too.
	(init_map_userdata, sort_def_symbol): Convert to ISO C.
	* ldmain.c (main): Set link_info.path_separator.
	* emultempl/spuelf.em (choose_target): Don't set it here.
@
text
@d53 1
d334 1
d528 2
a529 1
#define OPTION_SPU_NO_AUTO_OVERLAY	(OPTION_SPU_RESERVED_SPACE + 1)
d545 1
d564 4
a567 1
  --reserved-space=bytes      Local store for stack and heap.\n"
d645 9
@


1.21
log
@include/
	* bfdlink.h (struct bfd_link_info): Add "path_separator".
bfd/
	* elf32-spu.c (spu_elf_auto_overlay): Relax requirement that
	file names be unique.  Specify archive:path in overlay script.
ld/
	* ldlang.c (name_match): New function.
	(unique_section_p, walk_wild_consider_section): Use it here.
	(walk_wild_section_general): And here.
	(archive_path): New function.
	(walk_wild): Match archive:path filespecs.
	(open_input_bfds): Don't load archive:path files.
	* emultempl/spuelf.em (choose_target): Set path_separator.
	* emulparams/elf32_spu.sh: Add ._ea.* sections to ._ea output.
@
text
@a352 1
  link_info.path_separator = ':';
@


1.20
log
@	* emultempl/spuelf.em (spu_elf_relink): Correct --no-auto-overlay arg.
@
text
@d353 1
@


1.19
log
@bfd/
	* elf32-spu.c: Include libiberty.h.
	(struct spu_link_hash_table): Add local_stire, overlay_fixed, reserved,
	non_ovly_stub, spu_elf_load_ovl_mgr, spu_elf_open_overlay_script,
	spu_elf_relink, auto_overlay fields.
	(AUTO_OVERLAY, AUTO_RELINK, OVERLAY_RODATA): Define.
	(needs_ovl_stub): Flip test so that call to non-function warning
	is emitted during relocate_section rather than earlier.
	(spu_elf_check_vma): Stash --auto-overlay parameters, and clear
	auto_overlay if no section exceeds local store.
	(struct call_info): Add count, max_depth, is_pasted fields.
	(struct function_info): Add rodata, last_caller, call_count,
	depth, new visit flags.
	(insert_callee): Increment call count.
	(copy_callee): New function.
	(mark_functions_via_relocs): Investigate all reloc types to count
	possible function pointer stubs for --auto-overlay.  Track
	last_caller and increment function call_count.
	(pasted_function): Insert a "call" into call info for pasted section.
	(remove_cycles): Track max depth of calls.  Don't emit call graph
	pruning warning for --auto-overlay.
	(build_call_tree): Don't transfer_calls for --auto-overlay.
	Adjust remove_cycles call.
	(sort_calls, sort_lib, sort_bfds): New functions.
	(struct _mos_param, struct _uos_param, struct _cl_param): New.
	(mark_overlay_section, unmark_overlay_section): New functions.
	(collect_lib_sectios, auto_ovl_lib_functions): New functions.
	(collect_overlays, find_pasted_call): New functions.
	(sum_stack): Deal with is_pasted "calls".  Exit before printing
	when --auto-overlay.
	(spu_elf_auto_overlay): New function.
	(spu_elf_final_link): Call spu_elf_auto_overlay.
	* elf32-spu.h (spu_elf_check_vma): Update prototype.
ld/
	* emultempl/spuelf.em (auto_overlay, auto_overlay_file,
	auto_overlay_fixed, auto_overlay_reserved, my_argc, my_argv): New vars.
	(spu_before_allocation): Warn on --auto-overlay and existing overlays.
	(struct tflist, clean_tmp): Move.
	(new_tmp_file): New function, extracted from..
	(embedded_spu_file): ..here.
	(spu_elf_open_overlay_script, spu_elf_relink): New function.
	(gld${EMULATION_NAME}_finish): Pass a bunch of --auto-overlay params.
	Warn on --auto-overlay and zero local store.
	(gld${EMULATION_NAME}_choose_target): New function to stash argv.
	(OPTION_SPU_AUTO_OVERLAY, OPTION_SPU_AUTO_RELINK,
	OPTION_SPU_OVERLAY_RODATA, OPTION_SPU_FIXED_SPACE,
	OPTION_SPU_RESERVED_SPACE, OPTION_SPU_NO_AUTO_OVERLAY): Define.
	(PARSE_AND_LIST_LONGOPTS): Add entries for new options.
	(PARSE_AND_LIST_OPTIONS): Likewise.
	(PARSE_AND_LIST_ARGS_CASES): Likewise.
	(LDEMUL_CHOOSE_TARGET): Define.
@
text
@d298 1
a298 1
  char **argv = xmalloc ((my_argc + 5) * sizeof (*argv));
d303 2
a304 1
    argv[my_argc++] = auto_overlay_file;
@


1.18
log
@bfd/
	* elf32-spu.c (spu_elf_create_sections): Remove output_bfd parameter.
	(spu_elf_find_overlays, spu_elf_size_stubs): Likewise
	(process_stubs, discover_functions, build_call_tree): Likewise.
	(spu_elf_stack_analysis): Likewise.
	(spu_elf_check_vma): Likewise.  Move.
	(struct call_info): Make "is_tail" a bitfield.
	(insert_callee): Clear fun->start and set fun->is_func if we find
	a non-tail call.
	* elf32-spu.h (spu_elf_create_sections): Update prototype.
	(spu_elf_find_overlays, spu_elf_size_stubs, spu_elf_check_vma): Ditto.
ld/
	* emultempl/spuelf.em: Update calls to elf32-spu.c funcs.
@
text
@d48 8
d213 6
d235 77
d329 7
a335 2
	  s = spu_elf_check_vma (&link_info, local_store_lo, local_store_hi);
	  if (s != NULL)
d338 2
d349 8
a364 13
struct tflist {
  struct tflist *next;
  char name[9];
};

static struct tflist *tmp_file_list;

static void clean_tmp (void)
{
  for (; tmp_file_list != NULL; tmp_file_list = tmp_file_list->next)
    unlink (tmp_file_list->name);
}

a397 1
  struct tflist *tf;
d421 1
a421 16
  if (tmp_file_list == NULL)
    atexit (clean_tmp);
  tf = xmalloc (sizeof (*tf));
  tf->next = tmp_file_list;
  tmp_file_list = tf;
  oname = tf->name;
  memcpy (tf->name, "ldXXXXXX", sizeof (tf->name));

#ifdef HAVE_MKSTEMP
  fd = mkstemp (oname);
#else
  oname = mktemp (oname);
  if (oname == NULL)
    return FALSE;
  fd = open (oname, O_RDWR | O_CREAT | O_EXCL, 0600);
#endif
d520 6
d536 6
d552 8
a559 1
  --emit-stack-syms           Add sym giving stack needed for each func.\n"
d601 54
d660 1
@


1.17
log
@	* emultempl/spuelf.em (gld${EMULATION_NAME}_finish): Protect
	spu_elf_build_stubs with is_spu_target.
@
text
@d78 1
a78 1
      && !spu_elf_create_sections (link_info.output_bfd, &link_info,
d201 1
a201 1
      if (spu_elf_find_overlays (link_info.output_bfd, &link_info))
d205 1
a205 1
	  ret = spu_elf_size_stubs (link_info.output_bfd, &link_info,
d238 1
a238 2
	  s = spu_elf_check_vma (link_info.output_bfd,
				 local_store_lo, local_store_hi);
@


1.16
log
@include/
	* bfdlink.h (struct bfd_link_hash_table): Delete creator field.
	(struct bfd_link_info): Add output_bfd.
bfd/
	* elflink.c: Replace all accesses to hash->creator field with
	output_bfd->xvec.
	* cofflink.c: Likewise.
	* coff-h8300.c: Likewise.
	* ecoff.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfxx-mips.c: Likewise.
	* i386linux.c: Likewise.
	* m68klinux.c: Likewise.
	* sparclinux.c: Likewise.
	* sunos.c: Likewise.
	* xcofflink.c: Likewise.
	* linker.c: Likewise.
	(_bfd_link_hash_table_init): Don't store creator.
ld/
	* ldmain.h (output_bfd): Delete.
	* ldmain.c (output_bfd): Delete.
	Replace all occurrences of output_bfd with link_info.output_bfd.
	* ldcref.c: Likewise.
	* ldctor.c: Likewise.
	* ldemul.c: Likewise.
	* ldexp.c: Likewise.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldmisc.c: Likewise.
	* ldwrite.c: Likewise.
	* pe-dll.c: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/alphaelf.em: Likewise.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/elf-generic.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/irix.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/mmix-elfnmmo.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/sh64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
	* emultempl/z80.em: Likewise.
	* ldlang.c (open_output): Don't return output, instead write
	link_info_output_bfd directly.
	* emultempl/alphaelf.em: Replace occurrences of link_info.hash->creator
	with link_info.output_bfd->xvec.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
@
text
@d232 1
a232 1
  if (is_spu_target () && local_store_lo < local_store_hi)
d234 9
a242 1
      asection *s;
d244 3
a246 4
      s = spu_elf_check_vma (link_info.output_bfd,
			     local_store_lo, local_store_hi);
      if (s != NULL)
	einfo ("%X%P: %A exceeds local store range\n", s);
a248 4
  if (!spu_elf_build_stubs (&link_info,
			    emit_stub_syms || link_info.emitrelocations))
    einfo ("%X%P: can not build overlay stubs: %E\n");

@


1.15
log
@	* ldlang.c (new_afile): Don't pass unadorned NULL to concat.
	* ldfile.c (ldfile_add_library_path): Likewise.
	* emultempl/elf32.em (check_ld_elf_hints, check_ld_so_conf): Likewise.
	* emultempl/lnk960.em (lnk960_before_parse): Likewise.
	* emultempl/spuelf.em (embedded_spu_file): Likewise.
@
text
@d67 1
a67 1
  return link_info.hash->creator == &bfd_elf32_spu_vec;
d78 1
a78 1
      && !spu_elf_create_sections (output_bfd, &link_info,
d201 1
a201 1
      if (spu_elf_find_overlays (output_bfd, &link_info))
d205 1
a205 1
	  ret = spu_elf_size_stubs (output_bfd, &link_info,
d228 1
a228 1
  need_laying_out = bfd_elf_discard_info (output_bfd, &link_info);
d236 2
a237 1
      s = spu_elf_check_vma (output_bfd, local_store_lo, local_store_hi);
@


1.14
log
@	Rewrite SPU overlay handling code.  Put overlay calls stubs in the
	overlays where possible.  Use a faster call stub, or optionally at
	compile time, a more compact stub.  Double size of _ovly_buf_table
	so that low bit of _ovly_table.buf can be used as a "present" bit.
	Reserve an extra _ovly_table entry for index zero.
@
text
@d2 1
a2 1
#   Copyright 2006, 2007 Free Software Foundation, Inc.
d356 1
a356 1
	      flags = concat (flags, " -fPIC", NULL);
d358 1
a358 1
	      flags = concat (flags, " -fpie", NULL);
@


1.13
log
@	* emultempl/alphaelf.em: Format option help.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ia64elf.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/ticoff.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
@
text
@a60 2
static asection *toe = NULL;

d85 2
a86 1
/* Add section S at the end of output section OUTPUT_NAME.
d97 1
a97 1
spu_place_special_section (asection *s, const char *output_name)
d101 1
a101 1
  os = lang_output_section_find (output_name);
d109 9
d165 1
a165 1
	      spu_place_special_section (in, ".text");
d175 1
a175 1
	&& spu_elf_section_data (os->bfd_section)->ovl_index != 0)
d203 1
a203 1
	  asection *stub, *ovtab;
d205 4
a208 2
	  if (!spu_elf_size_stubs (output_bfd, &link_info, non_overlay_stubs,
				   stack_analysis, &stub, &ovtab, &toe))
d210 2
a211 9

	  if (stub != NULL)
	    {
	      spu_place_special_section (stub, ".text");
	      spu_place_special_section (ovtab, ".data");
	      spu_place_special_section (toe, ".toe");

	      spu_elf_load_ovl_mgr ();
	    }
d241 2
a242 4
  if (toe != NULL
      && !spu_elf_build_stubs (&link_info,
			       emit_stub_syms || link_info.emitrelocations,
			       toe))
@


1.12
log
@2007-07-19  Roland McGrath  <roland@@redhat.com>

	* genscripts.sh (source_em, fragment): New sh functions.
	Truncate e${EMULATION_NAME}.c file before .em script fills it.
	Use source_em in place of . for the .em script.
	* emultempl/generic.em: Use fragment and source_em functions.
	* emultempl/aix.em: Likewise.
	* emultempl/alphaelf.em: Likewise.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/cr16elf.em: Likewise.
	* emultempl/crxelf.em: Likewise.
	* emultempl/elf-generic.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/genelf.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/gld960c.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ia64elf.em: Likewise.
	* emultempl/irix.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/m68kcoff.em: Likewise.
	* emultempl/m68kelf.em: Likewise.
	* emultempl/mipsecoff.em: Likewise.
	* emultempl/mipself.em: Likewise.
	* emultempl/mmix-elfnmmo.em: Likewise.
	* emultempl/mmixelf.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/needrelax.em: Likewise.
	* emultempl/netbsd.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/sh64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/ticoff.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
	* emultempl/z80.em: Likewise.
@
text
@d453 7
a459 7
  --plugin              Make SPU plugin.\n\
  --no-overlays         No overlay handling.\n\
  --emit-stub-syms      Add symbols on overlay call stubs.\n\
  --extra-overlay-stubs Add stubs on all calls out of overlay regions.\n\
  --local-store=lo:hi   Valid address range.\n\
  --stack-analysis      Estimate maximum stack requirement.\n\
  --emit-stack-syms     Add __stack_func giving stack needed for each func.\n"
@


1.11
log
@	* emultempl/spuelf.em (embedded_spu_file): Test for NULL path
	before calling base_name, not after.
@
text
@d25 1
a25 1
cat >>e${EMULATION_NAME}.c <<EOF
d53 1
a53 1
cat >>e${EMULATION_NAME}.c <<EOF
d250 1
a250 1
  cat >>e${EMULATION_NAME}.c <<EOF
@


1.10
log
@Update sources to GPLv3
@
text
@d348 3
a350 2
    {
      const char *infile = base_name (search->filename);
d352 9
a360 10
      if (infile != NULL
	  && strncmp (infile, "crtbegin", 8) == 0)
	{
	  if (infile[8] == 'S')
	    flags = concat (flags, " -fPIC", NULL);
	  else if (infile[8] == 'T')
	    flags = concat (flags, " -fpie", NULL);
	  break;
	}
    }
@


1.9
log
@	* emultempl/spuelf.em (base_name): Correct backslash quoting.
@
text
@d4 1
a4 1
# This file is part of GLD, the Gnu Linker.
d8 1
a8 1
# the Free Software Foundation; either version 2 of the License, or
d16 4
a19 3
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
@


1.8
log
@	* Makefile.am: Add eelf32_spu.o rule.
	* Makefile.in: Regenerate.
	* emultempl/spuelf.em: Revert last change.  Instead use EMBEDSPU
	defined in Makefile for embedspu name.
@
text
@d273 1
a273 1
    char *bslash = strrchr (path, '\\');
@


1.7
log
@	* emultempl/spuelf.em (embedded_spu_file): Deduce embedspu program
	name prefix from that of ld.
@
text
@a308 2
  const char *prefix;
  size_t prefix_len;
d363 1
a363 17
  prefix = base_name (program_name);
  prefix_len = strlen (prefix);
  if (prefix_len > 2
      && (prefix[prefix_len - 2] == 'l'
	  || prefix[prefix_len - 2] == 'L')
      && (prefix[prefix_len - 1] == 'd'
	  || prefix[prefix_len - 1] == 'D'))
    {
      cmd[0] = xmalloc (prefix_len + 7);
      memcpy (cmd[0], prefix, prefix_len - 2);
      memcpy (cmd[0] + prefix_len - 2, "embedspu", 9);
    }
  else
    {
      prefix_len = 0;
      cmd[0] = "embedspu";
    }
d382 1
a382 1
      if (prefix_len != 0)
@


1.6
log
@binutils/
	* embedspu.sh: Emit SPU ELF image to .data.rel.ro.speelf if
	pic or pie and image needs relocs.
ld/
	* emultempl/spuelf.em (base_name): New function, split out from..
	(embedded_spu_file) ..here.  Pass -fPIC or -fpie to embedspu
	invocation if we deduce a shared lib or position independent
	executable build by looking at ctrbegin* linker input files.
@
text
@d309 2
d365 17
a381 1
  cmd[0] = "embedspu";
d400 5
@


1.5
log
@bfd/
	* elf32-spu.c (struct spu_link_hash_table): Add stack_analysis
	and emit_stack_syms bitfields.
	(get_sym_h): Read all symbols if stack analysis will be done.
	(spu_elf_create_sections): Add stack_analysis and emit_stack_syms
	params, and stash in hash table.
	(is_hint): Split off from..
	(is_branch): ..here.  Adjust callers.
	(spu_elf_size_stubs): Add stack_analysis param.  Arrange to read
	and keep all syms.
	(write_one_stub): Fix mem leak.
	(find_function_stack_adjust): New function.
	(sort_syms_syms, sort_syms_psecs): New vars.
	(sort_syms): New function.
	(struct call_info, struct function_info): New.
	(struct spu_elf_stack_info): New.
	(alloc_stack_info, maybe_insert_function, func_name): New functions.
	(is_nop, insns_at_end, check_function_ranges): Likewise.
	(find_function, insert_callee, mark_functions_via_relocs): Likewise.
	(pasted_function, interesting_section, discover_functions): Likewise.
	(mark_non_root, call_graph_traverse, build_call_tree): Likewise.
	(sum_stack, spu_elf_stack_analysis, spu_elf_final_link): Likewise.
	(bfd_elf32_bfd_final_link): Define.
	* elf32-spu.h (struct _spu_elf_section_data): Add stack_info field.
	(spu_elf_create_sections, spu_elf_size_stubs): Update prototypes.
include/
	* bfdlink.h (struct bfd_link_info): Add "info" and "minfo".
ld/
	* ldmain.c (link_callbacks): Init info and minfo fields.
	* ldmisc.c (minfo): Do nothing if no map file.
	* emultempl/spuelf.em (stack_analysis, emit_stack_syms): New vars.
	(spu_after_open): Adjust spu_elf_create_sections call.
	(spu_before_allocation): Likewise for spu_elf_size_stubs.
	(OPTION_SPU_STACK_ANALYSIS, OPTION_SPU_STACK_SYMS): Define.
	(PARSE_AND_LIST_LONGOPTS): Add new entries.
	(PARSE_AND_LIST_OPTIONS, PARSE_AND_LIST_ARGS_CASES): Likewise.
	* gen-doc.texi: Add @@set for SPU and other missing targets.
	* ld.texinfo: Update man page selection to match gen-doc.texi.
	Document SPU features.
@
text
@d267 23
d308 1
d317 1
a317 17
  sym = strrchr (entry->the_bfd->filename, '/');
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
  {
    char *bslash = strrchr (entry->the_bfd->filename, '\\');

    if (sym == NULL || (bslash != NULL && bslash > sym))
      sym = bslash;
    if (sym == NULL
	&& entry->the_bfd->filename[0] != '\0'
	&& entry->the_bfd->filename[1] == ':')
      sym = entry->the_bfd->filename + 1;
  }
#endif
  if (sym == NULL)
    sym = entry->the_bfd->filename;
  else
    ++sym;
d344 17
@


1.4
log
@	* Makefile.am: Add dependency on ldemul-list.h for powerpc and
	spu target emul files.
	* configure.in: Check for mkstemp and waitpid.
	* Makefile.in: Regenerate.
	* configure: Regenerate.
	* config.in: Regenerate.
	* ldlang.c (input_file_chain): Make global.
	(lang_add_input_file): Don't set lang_has_input_file here.
	* ldlang.h (input_file_chain): Declare.
	* emultempl/ppc32elf.em (ppc_recognized_file): New function.
	(LDEMUL_RECOGNIZED_FILE): Define.
	* emultempl/ppc64elf.em (ppc64_recognized_file): New function.
	(LDEMUL_RECOGNIZED_FILE): Define.
	* emultempl/spuelf.em (struct tflist): New.
	(tmp_file_list): New var.
@
text
@d37 6
d79 2
a80 1
      && !spu_elf_create_sections (output_bfd, &link_info))
d197 1
a197 1
				   &stub, &ovtab, &toe))
d406 2
d416 2
d426 3
a428 1
  --local-store=lo:hi   Valid address range.\n"
d462 8
@


1.3
log
@	* Makefile.am (ALL_EMUL_EXTRA_OFILES): Remove spu_inc.o.
	(eelf32_spu.c): Adjust dependencies.
	* Makefile.in: Regenerate.
	* emultempl/spuelf.em (ovl_mgr): New array.  Insert spu_ovl.o
	code using bin2c.
	(_binary_spu_ovl_o_start, _binary_spu_ovl_o_end): Delete.
	(ovl_mgr_stream): Update.
	* emultempl/spu_inc.s: Delete.
	* emultempl/spu_none.s: Delete.
@
text
@d241 149
@


1.2
log
@	* emultempl/spuelf.em (_binary_builtin_ovl_mgr_start): Rename
	to _binary_spu_ovl_o_start.
	(_binary_builtin_ovl_mgr_end): Rename to _binary_spu_ovl_o_end.
	(spu_elf_load_ovl_mgr): Fatal error on missing overlay manager.
	* emultempl/spu_inc.s: Rename symbols.
	* emultempl/spu_none.s: New file.
	* emultempl/spu_ovl.S: Update copyright.
	* Makefile.am (spu_inc.o): Try building with ld -r first, then
	gas incbin, then build without overlay manager.
	* Makefile.in: Regenerate.
@
text
@d2 1
a2 1
#   Copyright 2006 Free Software Foundation, Inc.
d41 7
a47 2
extern void *_binary_spu_ovl_o_start;
extern void *_binary_spu_ovl_o_end;
d50 2
a51 2
  &_binary_spu_ovl_o_start,
  &_binary_spu_ovl_o_end
@


1.1
log
@New Cell SPU port.
@
text
@d41 2
a42 2
extern void *_binary_builtin_ovl_mgr_start;
extern void *_binary_builtin_ovl_mgr_end;
d45 2
a46 2
  &_binary_builtin_ovl_mgr_start,
  &_binary_builtin_ovl_mgr_end
d121 2
@

