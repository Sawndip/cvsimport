head	1.30;
access;
symbols
	binutils-2_24-branch:1.30.0.2
	binutils-2_24-branchpoint:1.30
	binutils-2_21_1:1.27.2.1
	binutils-2_23_2:1.29.6.1
	binutils-2_23_1:1.29.6.1
	binutils-2_23:1.29.6.1
	binutils-2_23-branch:1.29.0.6
	binutils-2_23-branchpoint:1.29
	binutils-2_22_branch:1.29.0.4
	binutils-2_22:1.29
	binutils-2_22-branch:1.29.0.2
	binutils-2_22-branchpoint:1.29
	binutils-2_21:1.27
	binutils-2_21-branch:1.27.0.2
	binutils-2_21-branchpoint:1.27
	binutils-2_20_1:1.23
	binutils-2_20:1.23
	binutils-arc-20081103-branch:1.22.0.6
	binutils-arc-20081103-branchpoint:1.22
	binutils-2_20-branch:1.23.0.4
	binutils-2_20-branchpoint:1.23
	dje-cgen-play1-branch:1.23.0.2
	dje-cgen-play1-branchpoint:1.23
	arc-20081103-branch:1.22.0.4
	arc-20081103-branchpoint:1.22
	binutils-2_19_1:1.22
	binutils-2_19:1.22
	binutils-2_19-branch:1.22.0.2
	binutils-2_19-branchpoint:1.22
	binutils-2_18:1.20
	binutils-2_18-branch:1.20.0.2
	binutils-2_18-branchpoint:1.20
	binutils-csl-coldfire-4_1-32:1.11.2.1
	binutils-csl-sourcerygxx-4_1-32:1.11.2.1
	binutils-csl-innovasic-fido-3_4_4-33:1.11.2.1
	binutils-csl-sourcerygxx-3_4_4-32:1.8
	binutils-csl-coldfire-4_1-30:1.11.2.1
	binutils-csl-sourcerygxx-4_1-30:1.11.2.1
	binutils-csl-coldfire-4_1-28:1.11.2.1
	binutils-csl-sourcerygxx-4_1-29:1.11.2.1
	binutils-csl-sourcerygxx-4_1-28:1.11.2.1
	binutils-csl-arm-2006q3-27:1.11.2.1
	binutils-csl-sourcerygxx-4_1-27:1.11.2.1
	binutils-csl-arm-2006q3-26:1.11.2.1
	binutils-csl-sourcerygxx-4_1-26:1.11.2.1
	binutils-csl-sourcerygxx-4_1-25:1.11.2.1
	binutils-csl-sourcerygxx-4_1-24:1.11.2.1
	binutils-csl-sourcerygxx-4_1-23:1.11.2.1
	binutils-csl-sourcerygxx-4_1-21:1.11.2.1
	binutils-csl-arm-2006q3-21:1.11.2.1
	binutils-csl-sourcerygxx-4_1-22:1.11.2.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.11.2.1
	binutils-csl-sourcerygxx-4_1-20:1.11.2.1
	binutils-csl-arm-2006q3-19:1.11.2.1
	binutils-csl-sourcerygxx-4_1-19:1.11.2.1
	binutils-csl-sourcerygxx-4_1-18:1.11.2.1
	binutils-csl-renesas-4_1-9:1.11.2.1
	binutils-csl-sourcerygxx-3_4_4-25:1.8
	binutils-csl-renesas-4_1-8:1.11
	binutils-csl-renesas-4_1-7:1.11
	binutils-csl-renesas-4_1-6:1.11
	binutils-csl-sourcerygxx-4_1-17:1.11
	binutils-csl-sourcerygxx-4_1-14:1.11
	binutils-csl-sourcerygxx-4_1-15:1.11
	binutils-csl-sourcerygxx-4_1-13:1.11
	binutils-2_17:1.12
	binutils-csl-sourcerygxx-4_1-12:1.11
	binutils-csl-sourcerygxx-3_4_4-21:1.11
	binutils-csl-wrs-linux-3_4_4-24:1.8
	binutils-csl-wrs-linux-3_4_4-23:1.8
	binutils-csl-sourcerygxx-4_1-9:1.11
	binutils-csl-sourcerygxx-4_1-8:1.11
	binutils-csl-sourcerygxx-4_1-7:1.11
	binutils-csl-arm-2006q1-6:1.11
	binutils-csl-sourcerygxx-4_1-6:1.11
	binutils-csl-wrs-linux-3_4_4-22:1.8
	binutils-csl-coldfire-4_1-11:1.11
	binutils-csl-sourcerygxx-3_4_4-19:1.11
	binutils-csl-coldfire-4_1-10:1.11
	binutils-csl-sourcerygxx-4_1-5:1.11
	binutils-csl-sourcerygxx-4_1-4:1.11
	binutils-csl-wrs-linux-3_4_4-21:1.8
	binutils-csl-morpho-4_1-4:1.11
	binutils-csl-sourcerygxx-3_4_4-17:1.11
	binutils-csl-wrs-linux-3_4_4-20:1.8
	binutils-2_17-branch:1.12.0.2
	binutils-2_17-branchpoint:1.12
	binutils-csl-2_17-branch:1.11.0.2
	binutils-csl-2_17-branchpoint:1.11
	binutils-csl-gxxpro-3_4-branch:1.8.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.8
	binutils-2_16_1:1.8
	binutils-csl-arm-2005q1b:1.8
	binutils-2_16:1.8
	binutils-csl-arm-2005q1a:1.8
	binutils-csl-arm-2005q1-branch:1.8.0.4
	binutils-csl-arm-2005q1-branchpoint:1.8
	binutils-2_16-branch:1.8.0.2
	binutils-2_16-branchpoint:1.8
	csl-arm-2004-q3d:1.6
	csl-arm-2004-q3:1.4
	binutils-2_15:1.3
	binutils-2_15-branchpoint:1.3
	csl-arm-2004-q1a:1.3
	csl-arm-2004-q1:1.3
	binutils-2_15-branch:1.3.0.6
	cagney_bfdfile-20040213-branch:1.3.0.4
	cagney_bfdfile-20040213-branchpoint:1.3
	cagney_bigcore-20040122-branch:1.3.0.2
	cagney_bigcore-20040122-branchpoint:1.3
	csl-arm-2003-q4:1.3
	binutils-2_14:1.1
	binutils-2_14-branch:1.1.0.2
	binutils-2_14-branchpoint:1.1
	binutils_latest_snapshot:1.30;
locks; strict;
comment	@# @;


1.30
date	2012.08.06.22.27.52;	author macro;	state Exp;
branches;
next	1.29;

1.29
date	2011.01.14.12.37.17;	author amodra;	state Exp;
branches
	1.29.6.1;
next	1.28;

1.28
date	2011.01.13.13.06.22;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2010.10.04.14.13.10;	author bernds;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2010.09.10.01.23.12;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2010.06.27.04.07.54;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2009.11.26.13.45.25;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2009.02.16.07.25.52;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2008.02.15.03.35.53;	author amodra;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2007.08.17.13.50.48;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2007.07.19.19.56.10;	author roland;	state Exp;
branches;
next	1.19;

1.19
date	2007.07.06.14.09.42;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2007.06.11.16.53.08;	author bwilson;	state Exp;
branches;
next	1.17;

1.17
date	2006.11.27.20.14.53;	author bwilson;	state Exp;
branches;
next	1.16;

1.16
date	2006.10.12.21.56.19;	author bwilson;	state Exp;
branches;
next	1.15;

1.15
date	2006.09.16.18.12.16;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2006.07.26.00.10.26;	author bwilson;	state Exp;
branches;
next	1.13;

1.13
date	2006.07.25.00.20.09;	author bwilson;	state Exp;
branches;
next	1.12;

1.12
date	2006.04.14.21.31.16;	author bwilson;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.27.22.56.02;	author bwilson;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2005.11.17.00.10.05;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2005.05.12.07.32.04;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.03.11.52.04;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2005.01.21.04.15.59;	author bje;	state Exp;
branches;
next	1.6;

1.6
date	2004.10.12.18.33.16;	author bwilson;	state Exp;
branches;
next	1.5;

1.5
date	2004.10.08.00.22.13;	author bwilson;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.24.04.46.28;	author amodra;	state Exp;
branches;
next	1.3;

1.3
date	2003.06.27.00.38.25;	author amodra;	state Exp;
branches;
next	1.2;

1.2
date	2003.06.25.06.40.27;	author amodra;	state Exp;
branches;
next	1.1;

1.1
date	2003.04.01.15.50.31;	author nickc;	state Exp;
branches;
next	;

1.29.6.1
date	2012.09.04.14.38.00;	author gingold;	state Exp;
branches;
next	;

1.27.2.1
date	2011.02.01.12.25.47;	author amodra;	state Exp;
branches;
next	;

1.22.2.1
date	2009.03.02.13.56.19;	author amodra;	state Exp;
branches;
next	;

1.11.2.1
date	2006.08.22.15.08.43;	author jsm28;	state Exp;
branches;
next	;


desc
@@


1.30
log
@	bfd/
	* elflink.c (bfd_elf_record_link_assignment): Remove --defsym
	symbols special case.

	ld/
	* ldexp.h (etree_union): Add defsym member to the assign member
	structure.
	(exp_assign): Add hidden argument to prototype.
	* ldexp.c (exp_fold_tree_1): Use the defsym member to handle
	--defsym symbols.
	(exp_assop): Add defsym argument, initialize the defsym member
	of the assign structure.
	(exp_assign): Handle hidden symbols.
	(exp_defsym): Update to use the defsym argument to exp_assop.
	(exp_provide): Update to handle the defsym argument to exp_assop.
	* ldlex.l (HIDDEN): New token.
	* ldgram.y (HIDDEN): Likewise.
	(assignment, section): Update calls to exp_assign.
	* ldctor.c (ldctor_build_sets): Likewise.
	* mri.c (mri_format): Likewise.
	* ldlang.c (lang_insert_orphan, lang_leave_overlay): Likewise.
	(open_input_bfds): Remove --defsym symbols special case.
	* emultempl/beos.em (gld_${EMULATION_NAME}_set_symbols): Update
	call to exp_assign.
	* emultempl/pe.em (gld_${EMULATION_NAME}_set_symbols): Likewise.
	* emultempl/pep.em (gld_${EMULATION_NAME}_set_symbols): Likewise.
	* emultempl/spuelf.em (spu_place_special_section): Likewise.
	* emultempl/xtensaelf.em (ld_xtensa_insert_page_offsets):
	Likewise.
	* ld.texinfo (Assigning Values to Symbols): Add HIDDEN.
	(HIDDEN): New subsection.
@
text
@# This shell script emits a C file. -*- C -*-
#   Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
#   Free Software Foundation, Inc.
#
# This file is part of the GNU Binutils.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
# MA 02110-1301, USA.
#

# This file is sourced from elf32.em, and defines extra xtensa-elf
# specific routines.
#
fragment <<EOF

#include <xtensa-config.h>
#include "../bfd/elf-bfd.h"
#include "../bfd/libbfd.h"
#include "elf/xtensa.h"
#include "bfd.h"

/* Provide default values for new configuration settings.  */
#ifndef XSHAL_ABI
#define XSHAL_ABI 0
#endif

static void xtensa_wild_group_interleave (lang_statement_union_type *);
static void xtensa_colocate_output_literals (lang_statement_union_type *);
static void xtensa_strip_inconsistent_linkonce_sections
  (lang_statement_list_type *);


/* This number is irrelevant until we turn on use_literal_pages */
static bfd_vma xtensa_page_power = 12; /* 4K pages.  */

/* To force a page break between literals and text, change
   xtensa_use_literal_pages to "TRUE".  */
static bfd_boolean xtensa_use_literal_pages = FALSE;

#define EXTRA_VALIDATION 0


static char *
elf_xtensa_choose_target (int argc ATTRIBUTE_UNUSED,
			  char **argv ATTRIBUTE_UNUSED)
{
  if (XCHAL_HAVE_BE)
    return "${BIG_OUTPUT_FORMAT}";
  else
    return "${LITTLE_OUTPUT_FORMAT}";
}


static void
elf_xtensa_before_parse (void)
{
  /* Just call the default hook.... Tensilica's version of this function
     does some other work that isn't relevant here.  */
  gld${EMULATION_NAME}_before_parse ();
}


static void
remove_section (bfd *abfd, asection *os)
{
  asection **spp;
  for (spp = &abfd->sections; *spp; spp = &(*spp)->next)
    if (*spp == os)
      {
	*spp = os->next;
	os->owner->section_count--;
	break;
      }
}


static bfd_boolean
replace_insn_sec_with_prop_sec (bfd *abfd,
				const char *insn_sec_name,
				const char *prop_sec_name,
				char **error_message)
{
  asection *insn_sec;
  asection *prop_sec;
  bfd_byte *prop_contents = NULL;
  bfd_byte *insn_contents = NULL;
  unsigned entry_count;
  unsigned entry;
  Elf_Internal_Shdr *rel_hdr;
  Elf_Internal_Rela *internal_relocs = NULL;
  unsigned reloc_count;

  *error_message = "";
  insn_sec = bfd_get_section_by_name (abfd, insn_sec_name);
  if (insn_sec == NULL)
    return TRUE;
  entry_count = insn_sec->size / 8;

  prop_sec = bfd_get_section_by_name (abfd, prop_sec_name);
  if (prop_sec != NULL && insn_sec != NULL)
    {
      *error_message = _("file already has property tables");
      return FALSE;
    }

  if (insn_sec->size != 0)
    {
      insn_contents = (bfd_byte *) bfd_malloc (insn_sec->size);
      if (insn_contents == NULL)
	{
	  *error_message = _("out of memory");
	  goto cleanup;
	}
      if (! bfd_get_section_contents (abfd, insn_sec, insn_contents,
				      (file_ptr) 0, insn_sec->size))
	{
	  *error_message = _("failed to read section contents");
	  goto cleanup;
	}
    }

  /* Create a property table section for it.  */
  prop_sec_name = strdup (prop_sec_name);
  prop_sec = bfd_make_section_with_flags
    (abfd, prop_sec_name, bfd_get_section_flags (abfd, insn_sec));
  if (prop_sec == NULL
      || ! bfd_set_section_alignment (abfd, prop_sec, 2))
    {
      *error_message = _("could not create new section");
      goto cleanup;
    }

  prop_sec->size = entry_count * 12;
  prop_contents = (bfd_byte *) bfd_zalloc (abfd, prop_sec->size);
  elf_section_data (prop_sec)->this_hdr.contents = prop_contents;

  /* The entry size and size must be set to allow the linker to compute
     the number of relocations since it does not use reloc_count.  */
  rel_hdr = _bfd_elf_single_rel_hdr (prop_sec);
  rel_hdr->sh_entsize = sizeof (Elf32_External_Rela);
  rel_hdr->sh_size = _bfd_elf_single_rel_hdr (insn_sec)->sh_size;

  if (prop_contents == NULL && prop_sec->size != 0)
    {
      *error_message = _("could not allocate section contents");
      goto cleanup;
    }

  /* Read the relocations.  */
  reloc_count = insn_sec->reloc_count;
  if (reloc_count != 0)
    {
      /* If there is already an internal_reloc, then save it so that the
	 read_relocs function freshly allocates a copy.  */
      Elf_Internal_Rela *saved_relocs = elf_section_data (insn_sec)->relocs;

      elf_section_data (insn_sec)->relocs = NULL;
      internal_relocs =
	_bfd_elf_link_read_relocs (abfd, insn_sec, NULL, NULL, FALSE);
      elf_section_data (insn_sec)->relocs = saved_relocs;

      if (internal_relocs == NULL)
	{
	  *error_message = _("out of memory");
	  goto cleanup;
	}
    }

  /* Create a relocation section for the property section.  */
  if (internal_relocs != NULL)
    {
      elf_section_data (prop_sec)->relocs = internal_relocs;
      prop_sec->reloc_count = reloc_count;
    }

  /* Now copy each insn table entry to the prop table entry with
     appropriate flags.  */
  for (entry = 0; entry < entry_count; ++entry)
    {
      unsigned value;
      unsigned flags = (XTENSA_PROP_INSN | XTENSA_PROP_NO_TRANSFORM
			| XTENSA_PROP_INSN_NO_REORDER);
      value = bfd_get_32 (abfd, insn_contents + entry * 8 + 0);
      bfd_put_32 (abfd, value, prop_contents + entry * 12 + 0);
      value = bfd_get_32 (abfd, insn_contents + entry * 8 + 4);
      bfd_put_32 (abfd, value, prop_contents + entry * 12 + 4);
      bfd_put_32 (abfd, flags, prop_contents + entry * 12 + 8);
    }

  /* Now copy all of the relocations.  Change offsets for the
     instruction table section to offsets in the property table
     section.  */
  if (internal_relocs)
    {
      unsigned i;

      for (i = 0; i < reloc_count; i++)
	{
	  Elf_Internal_Rela *rela;
	  unsigned r_offset;

	  rela = &internal_relocs[i];

	  /* If this relocation is to the .xt.insn section,
	     change the section number and the offset.  */
	  r_offset = rela->r_offset;
	  r_offset += 4 * (r_offset / 8);
	  rela->r_offset = r_offset;
	}
    }

  remove_section (abfd, insn_sec);

  if (insn_contents)
    free (insn_contents);

  return TRUE;

 cleanup:
  if (prop_sec && prop_sec->owner)
    remove_section (abfd, prop_sec);
  if (insn_contents)
    free (insn_contents);
  if (internal_relocs)
    free (internal_relocs);

  return FALSE;
}


#define PROP_SEC_BASE_NAME ".xt.prop"
#define INSN_SEC_BASE_NAME ".xt.insn"
#define LINKONCE_SEC_OLD_TEXT_BASE_NAME ".gnu.linkonce.x."


static void
replace_instruction_table_sections (bfd *abfd, asection *sec)
{
  char *message = "";
  const char *insn_sec_name = NULL;
  char *prop_sec_name = NULL;
  char *owned_prop_sec_name = NULL;
  const char *sec_name;

  sec_name = bfd_get_section_name (abfd, sec);
  if (strcmp (sec_name, INSN_SEC_BASE_NAME) == 0)
    {
      insn_sec_name = INSN_SEC_BASE_NAME;
      prop_sec_name = PROP_SEC_BASE_NAME;
    }
  else if (CONST_STRNEQ (sec_name, LINKONCE_SEC_OLD_TEXT_BASE_NAME))
    {
      insn_sec_name = sec_name;
      owned_prop_sec_name = (char *) xmalloc (strlen (sec_name) + 20);
      prop_sec_name = owned_prop_sec_name;
      strcpy (prop_sec_name, ".gnu.linkonce.prop.t.");
      strcat (prop_sec_name,
	      sec_name + strlen (LINKONCE_SEC_OLD_TEXT_BASE_NAME));
    }
  if (insn_sec_name != NULL)
    {
      if (! replace_insn_sec_with_prop_sec (abfd, insn_sec_name, prop_sec_name,
					    &message))
	{
	  einfo (_("%P: warning: failed to convert %s table in %B (%s); subsequent disassembly may be incomplete\n"),
		 insn_sec_name, abfd, message);
	}
    }
  if (owned_prop_sec_name)
    free (owned_prop_sec_name);
}


/* This is called after all input sections have been opened to convert
   instruction tables (.xt.insn, gnu.linkonce.x.*) tables into property
   tables (.xt.prop) before any section placement.  */

static void
elf_xtensa_after_open (void)
{
  /* First call the ELF version.  */
  gld${EMULATION_NAME}_after_open ();

  /* Now search the input files looking for instruction table sections.  */
  LANG_FOR_EACH_INPUT_STATEMENT (f)
    {
      asection *sec = f->the_bfd->sections;
      asection *next_sec;

      /* Do not use bfd_map_over_sections here since we are removing
	 sections as we iterate.  */
      while (sec != NULL)
	{
	  next_sec = sec->next;
	  replace_instruction_table_sections (f->the_bfd, sec);
	  sec = next_sec;
	}
    }
}


static bfd_boolean
xt_config_info_unpack_and_check (char *data,
				 bfd_boolean *pmismatch,
				 char **pmsg)
{
  char *d, *key;
  unsigned num;

  *pmismatch = FALSE;

  d = data;
  while (*d)
    {
      key = d;
      d = strchr (d, '=');
      if (! d)
	goto error;

      /* Overwrite the equal sign.  */
      *d++ = 0;

      /* Check if this is a quoted string or a number.  */
      if (*d == '"')
	{
	  /* No string values are currently checked by LD;
	     just skip over the quotes.  */
	  d++;
	  d = strchr (d, '"');
	  if (! d)
	    goto error;
	  /* Overwrite the trailing quote.  */
	  *d++ = 0;
	}
      else
	{
	  if (*d == 0)
	    goto error;
	  num = strtoul (d, &d, 0);

	  if (! strcmp (key, "ABI"))
	    {
	      if (num != XSHAL_ABI)
		{
		  *pmismatch = TRUE;
		  *pmsg = "ABI does not match";
		}
	    }
	  else if (! strcmp (key, "USE_ABSOLUTE_LITERALS"))
	    {
	      if (num != XSHAL_USE_ABSOLUTE_LITERALS)
		{
		  *pmismatch = TRUE;
		  *pmsg = "incompatible use of the Extended L32R option";
		}
	    }
	}

      if (*d++ != '\n')
	goto error;
    }

  return TRUE;

 error:
  return FALSE;
}


#define XTINFO_NAME "Xtensa_Info"
#define XTINFO_NAMESZ 12
#define XTINFO_TYPE 1

static void
check_xtensa_info (bfd *abfd, asection *info_sec)
{
  char *data, *errmsg = "";
  bfd_boolean mismatch;

  data = xmalloc (info_sec->size);
  if (! bfd_get_section_contents (abfd, info_sec, data, 0, info_sec->size))
    einfo (_("%F%P:%B: cannot read contents of section %A\n"), abfd, info_sec);

  if (info_sec->size > 24
      && info_sec->size >= 24 + bfd_get_32 (abfd, data + 4)
      && bfd_get_32 (abfd, data + 0) == XTINFO_NAMESZ
      && bfd_get_32 (abfd, data + 8) == XTINFO_TYPE
      && strcmp (data + 12, XTINFO_NAME) == 0
      && xt_config_info_unpack_and_check (data + 12 + XTINFO_NAMESZ,
					  &mismatch, &errmsg))
    {
      if (mismatch)
	einfo (_("%P:%B: warning: incompatible Xtensa configuration (%s)\n"),
	       abfd, errmsg);
    }
  else
    einfo (_("%P:%B: warning: cannot parse .xtensa.info section\n"), abfd);

  free (data);
}


/* This is called after the sections have been attached to output
   sections, but before any sizes or addresses have been set.  */

static void
elf_xtensa_before_allocation (void)
{
  asection *info_sec, *first_info_sec;
  bfd *first_bfd;
  bfd_boolean is_big_endian = XCHAL_HAVE_BE;

  /* Check that the output endianness matches the Xtensa
     configuration.  The BFD library always includes both big and
     little endian target vectors for Xtensa, but it only supports the
     detailed instruction encode/decode operations (such as are
     required to process relocations) for the selected Xtensa
     configuration.  */

  if (is_big_endian
      && link_info.output_bfd->xvec->byteorder == BFD_ENDIAN_LITTLE)
    {
      einfo (_("%F%P: little endian output does not match "
	       "Xtensa configuration\n"));
    }
  if (!is_big_endian
      && link_info.output_bfd->xvec->byteorder == BFD_ENDIAN_BIG)
    {
      einfo (_("%F%P: big endian output does not match "
	       "Xtensa configuration\n"));
    }

  /* Keep track of the first input .xtensa.info section, and as a fallback,
     the first input bfd where a .xtensa.info section could be created.
     After the input .xtensa.info has been checked, the contents of the
     first one will be replaced with the output .xtensa.info table.  */
  first_info_sec = 0;
  first_bfd = 0;

  LANG_FOR_EACH_INPUT_STATEMENT (f)
    {
      /* Check that the endianness for each input file matches the output.
	 The merge_private_bfd_data hook has already reported any mismatches
	 as errors, but those errors are not fatal.  At this point, we
	 cannot go any further if there are any mismatches.  */
      if ((is_big_endian && f->the_bfd->xvec->byteorder == BFD_ENDIAN_LITTLE)
	  || (!is_big_endian && f->the_bfd->xvec->byteorder == BFD_ENDIAN_BIG))
	einfo (_("%F%P: cross-endian linking for %B not supported\n"),
	       f->the_bfd);

      if (! first_bfd)
	first_bfd = f->the_bfd;

      info_sec = bfd_get_section_by_name (f->the_bfd, ".xtensa.info");
      if (! info_sec)
	continue;

      if (! first_info_sec)
	first_info_sec = info_sec;

      /* Unpack the .xtensa.info section and check it against the current
	 Xtensa configuration.  */
      check_xtensa_info (f->the_bfd, info_sec);

      /* Do not include this copy of .xtensa.info in the output.  */
      info_sec->size = 0;
      info_sec->flags |= SEC_EXCLUDE;
    }

  /* Reuse the first .xtensa.info input section to hold the output
     .xtensa.info; or, if none were found, create a new section in the
     first input bfd (assuming there is one).  */
  info_sec = first_info_sec;
  if (! info_sec && first_bfd)
    {
      info_sec = bfd_make_section_with_flags (first_bfd, ".xtensa.info",
					      SEC_HAS_CONTENTS | SEC_READONLY);
      if (! info_sec)
	einfo (_("%F%P: failed to create .xtensa.info section\n"));
    }
  if (info_sec)
    {
      int xtensa_info_size;
      char *data;

      info_sec->flags &= ~SEC_EXCLUDE;
      info_sec->flags |= SEC_IN_MEMORY;

      data = xmalloc (100);
      sprintf (data, "USE_ABSOLUTE_LITERALS=%d\nABI=%d\n",
	       XSHAL_USE_ABSOLUTE_LITERALS, XSHAL_ABI);
      xtensa_info_size = strlen (data) + 1;

      /* Add enough null terminators to pad to a word boundary.  */
      do
	data[xtensa_info_size++] = 0;
      while ((xtensa_info_size & 3) != 0);

      info_sec->size = 12 + XTINFO_NAMESZ + xtensa_info_size;
      info_sec->contents = xmalloc (info_sec->size);
      bfd_put_32 (info_sec->owner, XTINFO_NAMESZ, info_sec->contents + 0);
      bfd_put_32 (info_sec->owner, xtensa_info_size, info_sec->contents + 4);
      bfd_put_32 (info_sec->owner, XTINFO_TYPE, info_sec->contents + 8);
      memcpy (info_sec->contents + 12, XTINFO_NAME, XTINFO_NAMESZ);
      memcpy (info_sec->contents + 12 + XTINFO_NAMESZ, data, xtensa_info_size);
      free (data);
    }

  /* Enable relaxation by default if the "--no-relax" option was not
     specified.  This is done here instead of in the before_parse hook
     because there is a check in main() to prohibit use of --relax and
     -r together and that combination should be allowed for Xtensa.  */
  if (RELAXATION_DISABLED_BY_DEFAULT)
    ENABLE_RELAXATION;

  xtensa_strip_inconsistent_linkonce_sections (stat_ptr);

  gld${EMULATION_NAME}_before_allocation ();

  xtensa_wild_group_interleave (stat_ptr->head);

  if (RELAXATION_ENABLED)
    xtensa_colocate_output_literals (stat_ptr->head);

  /* TBD: We need to force the page alignments to here and only do
     them as needed for the entire output section.  Finally, if this
     is a relocatable link then we need to add alignment notes so
     that the literals can be separated later.  */
}


typedef struct wildcard_list section_name_list;

typedef struct reloc_deps_e_t reloc_deps_e;
typedef struct reloc_deps_section_t reloc_deps_section;
typedef struct reloc_deps_graph_t reloc_deps_graph;


struct reloc_deps_e_t
{
  asection *src; /* Contains l32rs.  */
  asection *tgt; /* Contains literals.  */
  reloc_deps_e *next;
};

/* Place these in the userdata field.  */
struct reloc_deps_section_t
{
  reloc_deps_e *preds;
  reloc_deps_e *succs;
  bfd_boolean is_only_literal;
};


struct reloc_deps_graph_t
{
  size_t count;
  size_t size;
  asection **sections;
};

static void xtensa_layout_wild
  (const reloc_deps_graph *, lang_wild_statement_type *);

typedef void (*deps_callback_t) (asection *, /* src_sec */
				 bfd_vma,    /* src_offset */
				 asection *, /* target_sec */
				 bfd_vma,    /* target_offset */
				 void *);    /* closure */

extern bfd_boolean xtensa_callback_required_dependence
  (bfd *, asection *, struct bfd_link_info *, deps_callback_t, void *);
static void xtensa_ldlang_clear_addresses (lang_statement_union_type *);
static bfd_boolean ld_local_file_relocations_fit
  (lang_statement_union_type *, const reloc_deps_graph *);
static bfd_vma ld_assign_relative_paged_dot
  (bfd_vma, lang_statement_union_type *, const reloc_deps_graph *,
   bfd_boolean);
static bfd_vma ld_xtensa_insert_page_offsets
  (bfd_vma, lang_statement_union_type *, reloc_deps_graph *, bfd_boolean);
#if EXTRA_VALIDATION
static size_t ld_count_children (lang_statement_union_type *);
#endif

extern lang_statement_list_type constructor_list;

static reloc_deps_section *
xtensa_get_section_deps (const reloc_deps_graph *deps ATTRIBUTE_UNUSED,
			 asection *sec)
{
  /* We have a separate function for this so that
     we could in the future keep a completely independent
     structure that maps a section to its dependence edges.
     For now, we place these in the sec->userdata field.  */
  reloc_deps_section *sec_deps = sec->userdata;
  return sec_deps;
}

static void
xtensa_set_section_deps (const reloc_deps_graph *deps ATTRIBUTE_UNUSED,
			 asection *sec,
			 reloc_deps_section *deps_section)
{
  sec->userdata = deps_section;
}


/* This is used to keep a list of all of the sections participating in
   the graph so we can clean them up quickly.  */

static void
xtensa_append_section_deps (reloc_deps_graph *deps, asection *sec)
{
  if (deps->size <= deps->count)
    {
      asection **new_sections;
      size_t i;
      size_t new_size;

      new_size = deps->size * 2;
      if (new_size == 0)
	new_size = 20;

      new_sections = xmalloc (sizeof (asection *) * new_size);
      memset (new_sections, 0, sizeof (asection *) * new_size);
      for (i = 0; i < deps->count; i++)
	{
	  new_sections[i] = deps->sections[i];
	}
      if (deps->sections != NULL)
	free (deps->sections);
      deps->sections = new_sections;
      deps->size = new_size;
    }
  deps->sections[deps->count] = sec;
  deps->count++;
}


static void
free_reloc_deps_graph (reloc_deps_graph *deps)
{
  size_t i;
  for (i = 0; i < deps->count; i++)
    {
      asection *sec = deps->sections[i];
      reloc_deps_section *sec_deps;
      sec_deps = xtensa_get_section_deps (deps, sec);
      if (sec_deps)
	{
	  reloc_deps_e *next;
	  while (sec_deps->succs != NULL)
	    {
	      next = sec_deps->succs->next;
	      free (sec_deps->succs);
	      sec_deps->succs = next;
	    }

	  while (sec_deps->preds != NULL)
	    {
	      next = sec_deps->preds->next;
	      free (sec_deps->preds);
	      sec_deps->preds = next;
	    }
	  free (sec_deps);
	}
      xtensa_set_section_deps (deps, sec, NULL);
    }
  if (deps->sections)
    free (deps->sections);

  free (deps);
}


static bfd_boolean
section_is_source (const reloc_deps_graph *deps ATTRIBUTE_UNUSED,
		   lang_statement_union_type *s)
{
  asection *sec;
  const reloc_deps_section *sec_deps;

  if (s->header.type != lang_input_section_enum)
    return FALSE;
  sec = s->input_section.section;

  sec_deps = xtensa_get_section_deps (deps, sec);
  return sec_deps && sec_deps->succs != NULL;
}


static bfd_boolean
section_is_target (const reloc_deps_graph *deps ATTRIBUTE_UNUSED,
		   lang_statement_union_type *s)
{
  asection *sec;
  const reloc_deps_section *sec_deps;

  if (s->header.type != lang_input_section_enum)
    return FALSE;
  sec = s->input_section.section;

  sec_deps = xtensa_get_section_deps (deps, sec);
  return sec_deps && sec_deps->preds != NULL;
}


static bfd_boolean
section_is_source_or_target (const reloc_deps_graph *deps ATTRIBUTE_UNUSED,
			     lang_statement_union_type *s)
{
  return (section_is_source (deps, s)
	  || section_is_target (deps, s));
}


typedef struct xtensa_ld_iter_stack_t xtensa_ld_iter_stack;
typedef struct xtensa_ld_iter_t xtensa_ld_iter;

struct xtensa_ld_iter_t
{
  lang_statement_union_type *parent;	/* Parent of the list.  */
  lang_statement_list_type *l;		/* List that holds it.  */
  lang_statement_union_type **loc;	/* Place in the list.  */
};

struct xtensa_ld_iter_stack_t
{
  xtensa_ld_iter iterloc;		/* List that hold it.  */

  xtensa_ld_iter_stack *next;		/* Next in the stack.  */
  xtensa_ld_iter_stack *prev;		/* Back pointer for stack.  */
};


static void
ld_xtensa_move_section_after (xtensa_ld_iter *to, xtensa_ld_iter *current)
{
  lang_statement_union_type *to_next;
  lang_statement_union_type *current_next;
  lang_statement_union_type **e;

#if EXTRA_VALIDATION
  size_t old_to_count, new_to_count;
  size_t old_current_count, new_current_count;
#endif

  if (to == current)
    return;

#if EXTRA_VALIDATION
  old_to_count = ld_count_children (to->parent);
  old_current_count = ld_count_children (current->parent);
#endif

  to_next = *(to->loc);
  current_next = (*current->loc)->header.next;

  *(to->loc) = *(current->loc);

  *(current->loc) = current_next;
  (*(to->loc))->header.next = to_next;

  /* reset "to" list tail */
  for (e = &to->l->head; *e != NULL; e = &(*e)->header.next)
    ;
  to->l->tail = e;

  /* reset "current" list tail */
  for (e = &current->l->head; *e != NULL; e = &(*e)->header.next)
    ;
  current->l->tail = e;

#if EXTRA_VALIDATION
  new_to_count = ld_count_children (to->parent);
  new_current_count = ld_count_children (current->parent);

  ASSERT ((old_to_count + old_current_count)
	  == (new_to_count + new_current_count));
#endif
}


/* Can only be called with lang_statements that have lists.  Returns
   FALSE if the list is empty.  */

static bfd_boolean
iter_stack_empty (xtensa_ld_iter_stack **stack_p)
{
  return *stack_p == NULL;
}


static bfd_boolean
iter_stack_push (xtensa_ld_iter_stack **stack_p,
		 lang_statement_union_type *parent)
{
  xtensa_ld_iter_stack *stack;
  lang_statement_list_type *l = NULL;

  switch (parent->header.type)
    {
    case lang_output_section_statement_enum:
      l = &parent->output_section_statement.children;
      break;
    case lang_wild_statement_enum:
      l = &parent->wild_statement.children;
      break;
    case lang_group_statement_enum:
      l = &parent->group_statement.children;
      break;
    default:
      ASSERT (0);
      return FALSE;
    }

  /* Empty. do not push.  */
  if (l->tail == &l->head)
    return FALSE;

  stack = xmalloc (sizeof (xtensa_ld_iter_stack));
  memset (stack, 0, sizeof (xtensa_ld_iter_stack));
  stack->iterloc.parent = parent;
  stack->iterloc.l = l;
  stack->iterloc.loc = &l->head;

  stack->next = *stack_p;
  stack->prev = NULL;
  if (*stack_p != NULL)
    (*stack_p)->prev = stack;
  *stack_p = stack;
  return TRUE;
}


static void
iter_stack_pop (xtensa_ld_iter_stack **stack_p)
{
  xtensa_ld_iter_stack *stack;

  stack = *stack_p;

  if (stack == NULL)
    {
      ASSERT (stack != NULL);
      return;
    }

  if (stack->next != NULL)
    stack->next->prev = NULL;

  *stack_p = stack->next;
  free (stack);
}


/* This MUST be called if, during iteration, the user changes the
   underlying structure.  It will check for a NULL current and advance
   accordingly.  */

static void
iter_stack_update (xtensa_ld_iter_stack **stack_p)
{
  if (!iter_stack_empty (stack_p)
      && (*(*stack_p)->iterloc.loc) == NULL)
    {
      iter_stack_pop (stack_p);

      while (!iter_stack_empty (stack_p)
	     && ((*(*stack_p)->iterloc.loc)->header.next == NULL))
	{
	  iter_stack_pop (stack_p);
	}
      if (!iter_stack_empty (stack_p))
	(*stack_p)->iterloc.loc = &(*(*stack_p)->iterloc.loc)->header.next;
    }
}


static void
iter_stack_next (xtensa_ld_iter_stack **stack_p)
{
  xtensa_ld_iter_stack *stack;
  lang_statement_union_type *current;
  stack = *stack_p;

  current = *stack->iterloc.loc;
  /* If we are on the first element.  */
  if (current != NULL)
    {
      switch (current->header.type)
	{
	case lang_output_section_statement_enum:
	case lang_wild_statement_enum:
	case lang_group_statement_enum:
	  /* If the list if not empty, we are done.  */
	  if (iter_stack_push (stack_p, *stack->iterloc.loc))
	    return;
	  /* Otherwise increment the pointer as normal.  */
	  break;
	default:
	  break;
	}
    }

  while (!iter_stack_empty (stack_p)
	 && ((*(*stack_p)->iterloc.loc)->header.next == NULL))
    {
      iter_stack_pop (stack_p);
    }
  if (!iter_stack_empty (stack_p))
    (*stack_p)->iterloc.loc = &(*(*stack_p)->iterloc.loc)->header.next;
}


static lang_statement_union_type *
iter_stack_current (xtensa_ld_iter_stack **stack_p)
{
  return *((*stack_p)->iterloc.loc);
}


/* The iter stack is a preorder.  */

static void
iter_stack_create (xtensa_ld_iter_stack **stack_p,
		   lang_statement_union_type *parent)
{
  iter_stack_push (stack_p, parent);
}


static void
iter_stack_copy_current (xtensa_ld_iter_stack **stack_p, xtensa_ld_iter *front)
{
  *front = (*stack_p)->iterloc;
}


static void
xtensa_colocate_literals (reloc_deps_graph *deps,
			  lang_statement_union_type *statement)
{
  /* Keep a stack of pointers to control iteration through the contours.  */
  xtensa_ld_iter_stack *stack = NULL;
  xtensa_ld_iter_stack **stack_p = &stack;

  xtensa_ld_iter front;  /* Location where new insertion should occur.  */
  xtensa_ld_iter *front_p = NULL;

  xtensa_ld_iter current; /* Location we are checking.  */
  xtensa_ld_iter *current_p = NULL;
  bfd_boolean in_literals = FALSE;

  if (deps->count == 0)
    return;

  iter_stack_create (stack_p, statement);

  while (!iter_stack_empty (stack_p))
    {
      bfd_boolean skip_increment = FALSE;
      lang_statement_union_type *l = iter_stack_current (stack_p);

      switch (l->header.type)
	{
	case lang_assignment_statement_enum:
	  /* Any assignment statement should block reordering across it.  */
	  front_p = NULL;
	  in_literals = FALSE;
	  break;

	case lang_input_section_enum:
	  if (front_p == NULL)
	    {
	      in_literals = (section_is_target (deps, l)
			     && !section_is_source (deps, l));
	      if (in_literals)
		{
		  front_p = &front;
		  iter_stack_copy_current (stack_p, front_p);
		}
	    }
	  else
	    {
	      bfd_boolean is_target;
	      current_p = &current;
	      iter_stack_copy_current (stack_p, current_p);
	      is_target = (section_is_target (deps, l)
			   && !section_is_source (deps, l));

	      if (in_literals)
		{
		  iter_stack_copy_current (stack_p, front_p);
		  if (!is_target)
		    in_literals = FALSE;
		}
	      else
		{
		  if (is_target)
		    {
		      /* Try to insert in place.  */
		      ld_xtensa_move_section_after (front_p, current_p);
		      ld_assign_relative_paged_dot (0x100000,
						    statement,
						    deps,
						    xtensa_use_literal_pages);

		      /* We use this code because it's already written.  */
		      if (!ld_local_file_relocations_fit (statement, deps))
			{
			  /* Move it back.  */
			  ld_xtensa_move_section_after (current_p, front_p);
			  /* Reset the literal placement.  */
			  iter_stack_copy_current (stack_p, front_p);
			}
		      else
			{
			  /* Move front pointer up by one.  */
			  front_p->loc = &(*front_p->loc)->header.next;

			  /* Do not increment the current pointer.  */
			  skip_increment = TRUE;
			}
		    }
		}
	    }
	  break;
	default:
	  break;
	}

      if (!skip_increment)
	iter_stack_next (stack_p);
      else
	/* Be careful to update the stack_p if it now is a null.  */
	iter_stack_update (stack_p);
    }

  lang_for_each_statement_worker (xtensa_ldlang_clear_addresses, statement);
}


static void
xtensa_move_dependencies_to_front (reloc_deps_graph *deps,
				   lang_wild_statement_type *w)
{
  /* Keep a front pointer and a current pointer.  */
  lang_statement_union_type **front;
  lang_statement_union_type **current;

  /* Walk to the end of the targets.  */
  for (front = &w->children.head;
       (*front != NULL) && section_is_source_or_target (deps, *front);
       front = &(*front)->header.next)
    ;

  if (*front == NULL)
    return;

  current = &(*front)->header.next;
  while (*current != NULL)
    {
      if (section_is_source_or_target (deps, *current))
	{
	  /* Insert in place.  */
	  xtensa_ld_iter front_iter;
	  xtensa_ld_iter current_iter;

	  front_iter.parent = (lang_statement_union_type *) w;
	  front_iter.l = &w->children;
	  front_iter.loc = front;

	  current_iter.parent = (lang_statement_union_type *) w;
	  current_iter.l = &w->children;
	  current_iter.loc = current;

	  ld_xtensa_move_section_after (&front_iter, &current_iter);
	  front = &(*front)->header.next;
	}
      else
	{
	  current = &(*current)->header.next;
	}
    }
}


static bfd_boolean
deps_has_sec_edge (const reloc_deps_graph *deps, asection *src, asection *tgt)
{
  const reloc_deps_section *sec_deps;
  const reloc_deps_e *sec_deps_e;

  sec_deps = xtensa_get_section_deps (deps, src);
  if (sec_deps == NULL)
    return FALSE;

  for (sec_deps_e = sec_deps->succs;
       sec_deps_e != NULL;
       sec_deps_e = sec_deps_e->next)
    {
      ASSERT (sec_deps_e->src == src);
      if (sec_deps_e->tgt == tgt)
	return TRUE;
    }
  return FALSE;
}


static bfd_boolean
deps_has_edge (const reloc_deps_graph *deps,
	       lang_statement_union_type *src,
	       lang_statement_union_type *tgt)
{
  if (!section_is_source (deps, src))
    return FALSE;
  if (!section_is_target (deps, tgt))
    return FALSE;

  if (src->header.type != lang_input_section_enum)
    return FALSE;
  if (tgt->header.type != lang_input_section_enum)
    return FALSE;

  return deps_has_sec_edge (deps, src->input_section.section,
			    tgt->input_section.section);
}


static void
add_deps_edge (reloc_deps_graph *deps, asection *src_sec, asection *tgt_sec)
{
  reloc_deps_section *src_sec_deps;
  reloc_deps_section *tgt_sec_deps;

  reloc_deps_e *src_edge;
  reloc_deps_e *tgt_edge;

  if (deps_has_sec_edge (deps, src_sec, tgt_sec))
    return;

  src_sec_deps = xtensa_get_section_deps (deps, src_sec);
  if (src_sec_deps == NULL)
    {
      /* Add a section.  */
      src_sec_deps = xmalloc (sizeof (reloc_deps_section));
      memset (src_sec_deps, 0, sizeof (reloc_deps_section));
      src_sec_deps->is_only_literal = 0;
      src_sec_deps->preds = NULL;
      src_sec_deps->succs = NULL;
      xtensa_set_section_deps (deps, src_sec, src_sec_deps);
      xtensa_append_section_deps (deps, src_sec);
    }

  tgt_sec_deps = xtensa_get_section_deps (deps, tgt_sec);
  if (tgt_sec_deps == NULL)
    {
      /* Add a section.  */
      tgt_sec_deps = xmalloc (sizeof (reloc_deps_section));
      memset (tgt_sec_deps, 0, sizeof (reloc_deps_section));
      tgt_sec_deps->is_only_literal = 0;
      tgt_sec_deps->preds = NULL;
      tgt_sec_deps->succs = NULL;
      xtensa_set_section_deps (deps, tgt_sec, tgt_sec_deps);
      xtensa_append_section_deps (deps, tgt_sec);
    }

  /* Add the edges.  */
  src_edge = xmalloc (sizeof (reloc_deps_e));
  memset (src_edge, 0, sizeof (reloc_deps_e));
  src_edge->src = src_sec;
  src_edge->tgt = tgt_sec;
  src_edge->next = src_sec_deps->succs;
  src_sec_deps->succs = src_edge;

  tgt_edge = xmalloc (sizeof (reloc_deps_e));
  memset (tgt_edge, 0, sizeof (reloc_deps_e));
  tgt_edge->src = src_sec;
  tgt_edge->tgt = tgt_sec;
  tgt_edge->next = tgt_sec_deps->preds;
  tgt_sec_deps->preds = tgt_edge;
}


static void
build_deps_graph_callback (asection *src_sec,
			   bfd_vma src_offset ATTRIBUTE_UNUSED,
			   asection *target_sec,
			   bfd_vma target_offset ATTRIBUTE_UNUSED,
			   void *closure)
{
  reloc_deps_graph *deps = closure;

  /* If the target is defined.  */
  if (target_sec != NULL)
    add_deps_edge (deps, src_sec, target_sec);
}


static reloc_deps_graph *
ld_build_required_section_dependence (lang_statement_union_type *s)
{
  reloc_deps_graph *deps;
  xtensa_ld_iter_stack *stack = NULL;

  deps = xmalloc (sizeof (reloc_deps_graph));
  deps->sections = NULL;
  deps->count = 0;
  deps->size = 0;

  for (iter_stack_create (&stack, s);
       !iter_stack_empty (&stack);
       iter_stack_next (&stack))
    {
      lang_statement_union_type *l = iter_stack_current (&stack);

      if (l->header.type == lang_input_section_enum)
	{
	  lang_input_section_type *input;
	  input = &l->input_section;
	  xtensa_callback_required_dependence (input->section->owner,
					       input->section,
					       &link_info,
					       /* Use the same closure.  */
					       build_deps_graph_callback,
					       deps);
	}
    }
  return deps;
}


#if EXTRA_VALIDATION
static size_t
ld_count_children (lang_statement_union_type *s)
{
  size_t count = 0;
  xtensa_ld_iter_stack *stack = NULL;
  for (iter_stack_create (&stack, s);
       !iter_stack_empty (&stack);
       iter_stack_next (&stack))
    {
      lang_statement_union_type *l = iter_stack_current (&stack);
      ASSERT (l != NULL);
      count++;
    }
  return count;
}
#endif /* EXTRA_VALIDATION */


/* Check if a particular section is included in the link.  This will only
   be true for one instance of a particular linkonce section.  */

static bfd_boolean input_section_found = FALSE;
static asection *input_section_target = NULL;

static void
input_section_linked_worker (lang_statement_union_type *statement)
{
  if ((statement->header.type == lang_input_section_enum
       && (statement->input_section.section == input_section_target)))
    input_section_found = TRUE;
}

static bfd_boolean
input_section_linked (asection *sec)
{
  input_section_found = FALSE;
  input_section_target = sec;
  lang_for_each_statement_worker (input_section_linked_worker, stat_ptr->head);
  return input_section_found;
}


/* Strip out any linkonce property tables or XCC exception tables where the
   associated linkonce text is from a different object file.  Normally,
   a matching set of linkonce sections is taken from the same object file,
   but sometimes the files are compiled differently so that some of the
   linkonce sections are not present in all files.  Stripping the
   inconsistent sections like this is not completely robust -- a much
   better solution is to use comdat groups.  */

static int linkonce_len = sizeof (".gnu.linkonce.") - 1;

static bfd_boolean
is_inconsistent_linkonce_section (asection *sec)
{
  bfd *abfd = sec->owner;
  const char *sec_name = bfd_get_section_name (abfd, sec);
  const char *name;

  if ((bfd_get_section_flags (abfd, sec) & SEC_LINK_ONCE) == 0
      || strncmp (sec_name, ".gnu.linkonce.", linkonce_len) != 0)
    return FALSE;

  /* Check if this is an Xtensa property section or an exception table
     for Tensilica's XCC compiler.  */
  name = sec_name + linkonce_len;
  if (CONST_STRNEQ (name, "prop."))
    name = strchr (name + 5, '.') + 1;
  else if (name[1] == '.'
	   && (name[0] == 'p' || name[0] == 'e' || name[0] == 'h'))
    name += 2;
  else
    name = 0;

  if (name)
    {
      char *dep_sec_name = xmalloc (strlen (sec_name) + 1);
      asection *dep_sec;

      /* Get the associated linkonce text section and check if it is
	 included in the link.  If not, this section is inconsistent
	 and should be stripped.  */
      strcpy (dep_sec_name, ".gnu.linkonce.t.");
      strcat (dep_sec_name, name);
      dep_sec = bfd_get_section_by_name (abfd, dep_sec_name);
      if (dep_sec == NULL || ! input_section_linked (dep_sec))
	{
	  free (dep_sec_name);
	  return TRUE;
	}
      free (dep_sec_name);
    }

  return FALSE;
}


static void
xtensa_strip_inconsistent_linkonce_sections (lang_statement_list_type *slist)
{
  lang_statement_union_type **s_p = &slist->head;
  while (*s_p)
    {
      lang_statement_union_type *s = *s_p;
      lang_statement_union_type *s_next = (*s_p)->header.next;

      switch (s->header.type)
	{
	case lang_input_section_enum:
	  if (is_inconsistent_linkonce_section (s->input_section.section))
	    {
	      s->input_section.section->output_section = bfd_abs_section_ptr;
	      *s_p = s_next;
	      continue;
	    }
	  break;

	case lang_constructors_statement_enum:
	  xtensa_strip_inconsistent_linkonce_sections (&constructor_list);
	  break;

	case lang_output_section_statement_enum:
	  if (s->output_section_statement.children.head)
	    xtensa_strip_inconsistent_linkonce_sections
	      (&s->output_section_statement.children);
	  break;

	case lang_wild_statement_enum:
	  xtensa_strip_inconsistent_linkonce_sections
	    (&s->wild_statement.children);
	  break;

	case lang_group_statement_enum:
	  xtensa_strip_inconsistent_linkonce_sections
	    (&s->group_statement.children);
	  break;

	case lang_data_statement_enum:
	case lang_reloc_statement_enum:
	case lang_object_symbols_statement_enum:
	case lang_output_statement_enum:
	case lang_target_statement_enum:
	case lang_input_statement_enum:
	case lang_assignment_statement_enum:
	case lang_padding_statement_enum:
	case lang_address_statement_enum:
	case lang_fill_statement_enum:
	  break;

	default:
	  FAIL ();
	  break;
	}

      s_p = &(*s_p)->header.next;
    }

  /* Reset the tail of the list, in case the last entry was removed.  */
  if (s_p != slist->tail)
    slist->tail = s_p;
}


static void
xtensa_wild_group_interleave_callback (lang_statement_union_type *statement)
{
  lang_wild_statement_type *w;
  reloc_deps_graph *deps;
  if (statement->header.type == lang_wild_statement_enum)
    {
#if EXTRA_VALIDATION
      size_t old_child_count;
      size_t new_child_count;
#endif
      bfd_boolean no_reorder;

      w = &statement->wild_statement;

      no_reorder = FALSE;

      /* If it has 0 or 1 section bound, then do not reorder.  */
      if (w->children.head == NULL
	  || (w->children.head->header.type == lang_input_section_enum
	      && w->children.head->header.next == NULL))
	no_reorder = TRUE;

      if (w->filenames_sorted)
	no_reorder = TRUE;

      /* Check for sorting in a section list wildcard spec as well.  */
      if (!no_reorder)
	{
	  struct wildcard_list *l;
	  for (l = w->section_list; l != NULL; l = l->next)
	    {
	      if (l->spec.sorted == TRUE)
		{
		  no_reorder = TRUE;
		  break;
		}
	    }
	}

      /* Special case until the NOREORDER linker directive is supported:
	 *(.init) output sections and *(.fini) specs may NOT be reordered.  */

      /* Check for sorting in a section list wildcard spec as well.  */
      if (!no_reorder)
	{
	  struct wildcard_list *l;
	  for (l = w->section_list; l != NULL; l = l->next)
	    {
	      if (l->spec.name
		  && ((strcmp (".init", l->spec.name) == 0)
		      || (strcmp (".fini", l->spec.name) == 0)))
		{
		  no_reorder = TRUE;
		  break;
		}
	    }
	}

#if EXTRA_VALIDATION
      old_child_count = ld_count_children (statement);
#endif

      /* It is now officially a target.  Build the graph of source
	 section -> target section (kept as a list of edges).  */
      deps = ld_build_required_section_dependence (statement);

      /* If this wildcard does not reorder....  */
      if (!no_reorder && deps->count != 0)
	{
	  /* First check for reverse dependences.  Fix if possible.  */
	  xtensa_layout_wild (deps, w);

	  xtensa_move_dependencies_to_front (deps, w);
#if EXTRA_VALIDATION
	  new_child_count = ld_count_children (statement);
	  ASSERT (new_child_count == old_child_count);
#endif

	  xtensa_colocate_literals (deps, statement);

#if EXTRA_VALIDATION
	  new_child_count = ld_count_children (statement);
	  ASSERT (new_child_count == old_child_count);
#endif
	}

      /* Clean up.  */
      free_reloc_deps_graph (deps);
    }
}


static void
xtensa_wild_group_interleave (lang_statement_union_type *s)
{
  lang_for_each_statement_worker (xtensa_wild_group_interleave_callback, s);
}


static void
xtensa_layout_wild (const reloc_deps_graph *deps, lang_wild_statement_type *w)
{
  /* If it does not fit initially, we need to do this step.  Move all
     of the wild literal sections to a new list, then move each of
     them back in just before the first section they depend on.  */
  lang_statement_union_type **s_p;
#if EXTRA_VALIDATION
  size_t old_count, new_count;
  size_t ct1, ct2;
#endif

  lang_wild_statement_type literal_wild;
  literal_wild.header.next = NULL;
  literal_wild.header.type = lang_wild_statement_enum;
  literal_wild.filename = NULL;
  literal_wild.filenames_sorted = FALSE;
  literal_wild.section_list = NULL;
  literal_wild.keep_sections = FALSE;
  literal_wild.children.head = NULL;
  literal_wild.children.tail = &literal_wild.children.head;

#if EXTRA_VALIDATION
  old_count = ld_count_children ((lang_statement_union_type*) w);
#endif

  s_p = &w->children.head;
  while (*s_p != NULL)
    {
      lang_statement_union_type *l = *s_p;
      if (l->header.type == lang_input_section_enum)
	{
	  if (section_is_target (deps, l)
	      && ! section_is_source (deps, l))
	    {
	      /* Detach.  */
	      *s_p = l->header.next;
	      if (*s_p == NULL)
		w->children.tail = s_p;
	      l->header.next = NULL;

	      /* Append.  */
	      *literal_wild.children.tail = l;
	      literal_wild.children.tail = &l->header.next;
	      continue;
	    }
	}
      s_p = &(*s_p)->header.next;
    }

#if EXTRA_VALIDATION
  ct1 = ld_count_children ((lang_statement_union_type*) w);
  ct2 = ld_count_children ((lang_statement_union_type*) &literal_wild);

  ASSERT (old_count == (ct1 + ct2));
#endif

  /* Now place them back in front of their dependent sections.  */

  while (literal_wild.children.head != NULL)
    {
      lang_statement_union_type *lit = literal_wild.children.head;
      bfd_boolean placed = FALSE;

#if EXTRA_VALIDATION
      ASSERT (ct2 > 0);
      ct2--;
#endif

      /* Detach.  */
      literal_wild.children.head = lit->header.next;
      if (literal_wild.children.head == NULL)
	literal_wild.children.tail = &literal_wild.children.head;
      lit->header.next = NULL;

      /* Find a spot to place it.  */
      for (s_p = &w->children.head; *s_p != NULL; s_p = &(*s_p)->header.next)
	{
	  lang_statement_union_type *src = *s_p;
	  if (deps_has_edge (deps, src, lit))
	    {
	      /* Place it here.  */
	      lit->header.next = *s_p;
	      *s_p = lit;
	      placed = TRUE;
	      break;
	    }
	}

      if (!placed)
	{
	  /* Put it at the end.  */
	  *w->children.tail = lit;
	  w->children.tail = &lit->header.next;
	}
    }

#if EXTRA_VALIDATION
  new_count = ld_count_children ((lang_statement_union_type*) w);
  ASSERT (new_count == old_count);
#endif
}


static void
xtensa_colocate_output_literals_callback (lang_statement_union_type *statement)
{
  reloc_deps_graph *deps;
  if (statement->header.type == lang_output_section_statement_enum)
    {
      /* Now, we walk over the contours of the output section statement.

	 First we build the literal section dependences as before.

	 At the first uniquely_literal section, we mark it as a good
	 spot to place other literals.  Continue walking (and counting
	 sizes) until we find the next literal section.  If this
	 section can be moved to the first one, then we move it.  If
	 we every find a modification of ".", start over.  If we find
	 a labeling of the current location, start over.  Finally, at
	 the end, if we require page alignment, add page alignments.  */

#if EXTRA_VALIDATION
      size_t old_child_count;
      size_t new_child_count;
#endif
      bfd_boolean no_reorder = FALSE;

#if EXTRA_VALIDATION
      old_child_count = ld_count_children (statement);
#endif

      /* It is now officially a target.  Build the graph of source
	 section -> target section (kept as a list of edges).  */

      deps = ld_build_required_section_dependence (statement);

      /* If this wildcard does not reorder....  */
      if (!no_reorder)
	{
	  /* First check for reverse dependences.  Fix if possible.  */
	  xtensa_colocate_literals (deps, statement);

#if EXTRA_VALIDATION
	  new_child_count = ld_count_children (statement);
	  ASSERT (new_child_count == old_child_count);
#endif
	}

      /* Insert align/offset assignment statement.  */
      if (xtensa_use_literal_pages)
	{
	  ld_xtensa_insert_page_offsets (0, statement, deps,
					 xtensa_use_literal_pages);
	  lang_for_each_statement_worker (xtensa_ldlang_clear_addresses,
					  statement);
	}

      /* Clean up.  */
      free_reloc_deps_graph (deps);
    }
}


static void
xtensa_colocate_output_literals (lang_statement_union_type *s)
{
  lang_for_each_statement_worker (xtensa_colocate_output_literals_callback, s);
}


static void
xtensa_ldlang_clear_addresses (lang_statement_union_type *statement)
{
  switch (statement->header.type)
    {
    case lang_input_section_enum:
      {
	asection *bfd_section = statement->input_section.section;
	bfd_section->output_offset = 0;
      }
      break;
    default:
      break;
    }
}


static bfd_vma
ld_assign_relative_paged_dot (bfd_vma dot,
			      lang_statement_union_type *s,
			      const reloc_deps_graph *deps ATTRIBUTE_UNUSED,
			      bfd_boolean lit_align)
{
  /* Walk through all of the input statements in this wild statement
     assign dot to all of them.  */

  xtensa_ld_iter_stack *stack = NULL;
  xtensa_ld_iter_stack **stack_p = &stack;

  bfd_boolean first_section = FALSE;
  bfd_boolean in_literals = FALSE;

  for (iter_stack_create (stack_p, s);
       !iter_stack_empty (stack_p);
       iter_stack_next (stack_p))
    {
      lang_statement_union_type *l = iter_stack_current (stack_p);

      switch (l->header.type)
	{
	case lang_input_section_enum:
	  {
	    asection *section = l->input_section.section;
	    size_t align_pow = section->alignment_power;
	    bfd_boolean do_xtensa_alignment = FALSE;

	    if (lit_align)
	      {
		bfd_boolean sec_is_target = section_is_target (deps, l);
		bfd_boolean sec_is_source = section_is_source (deps, l);

		if (section->size != 0
		    && (first_section
			|| (in_literals && !sec_is_target)
			|| (!in_literals && sec_is_target)))
		  {
		    do_xtensa_alignment = TRUE;
		  }
		first_section = FALSE;
		if (section->size != 0)
		  in_literals = (sec_is_target && !sec_is_source);
	      }

	    if (do_xtensa_alignment && xtensa_page_power != 0)
	      dot += (1 << xtensa_page_power);

	    dot = align_power (dot, align_pow);
	    section->output_offset = dot;
	    dot += section->size;
	  }
	  break;
	case lang_fill_statement_enum:
	  dot += l->fill_statement.size;
	  break;
	case lang_padding_statement_enum:
	  dot += l->padding_statement.size;
	  break;
	default:
	  break;
	}
    }
  return dot;
}


static bfd_boolean
ld_local_file_relocations_fit (lang_statement_union_type *statement,
			       const reloc_deps_graph *deps ATTRIBUTE_UNUSED)
{
  /* Walk over all of the dependencies that we identified and make
     sure that IF the source and target are here (addr != 0):
     1) target addr < source addr
     2) (roundup(source + source_size, 4) - rounddown(target, 4))
        < (256K - (1 << bad align))
     Need a worst-case proof....  */

  xtensa_ld_iter_stack *stack = NULL;
  xtensa_ld_iter_stack **stack_p = &stack;
  size_t max_align_power = 0;
  size_t align_penalty = 256;
  reloc_deps_e *e;
  size_t i;

  /* Find the worst-case alignment requirement for this set of statements.  */
  for (iter_stack_create (stack_p, statement);
       !iter_stack_empty (stack_p);
       iter_stack_next (stack_p))
    {
      lang_statement_union_type *l = iter_stack_current (stack_p);
      if (l->header.type == lang_input_section_enum)
	{
	  lang_input_section_type *input = &l->input_section;
	  asection *section = input->section;
	  if (section->alignment_power > max_align_power)
	    max_align_power = section->alignment_power;
	}
    }

  /* Now check that everything fits.  */
  for (i = 0; i < deps->count; i++)
    {
      asection *sec = deps->sections[i];
      const reloc_deps_section *deps_section =
	xtensa_get_section_deps (deps, sec);
      if (deps_section)
	{
	  /* We choose to walk through the successors.  */
	  for (e = deps_section->succs; e != NULL; e = e->next)
	    {
	      if (e->src != e->tgt
		  && e->src->output_section == e->tgt->output_section
		  && e->src->output_offset != 0
		  && e->tgt->output_offset != 0)
		{
		  bfd_vma l32r_addr =
		    align_power (e->src->output_offset + e->src->size, 2);
		  bfd_vma target_addr = e->tgt->output_offset & ~3;
		  if (l32r_addr < target_addr)
		    {
		      fflush (stdout);
		      fprintf (stderr, "Warning: "
			       "l32r target section before l32r\n");
		      fflush (stderr);
		      return FALSE;
		    }

		  if (l32r_addr - target_addr > 256 * 1024 - align_penalty)
		    return FALSE;
		}
	    }
	}
    }

  return TRUE;
}


static bfd_vma
ld_xtensa_insert_page_offsets (bfd_vma dot,
			       lang_statement_union_type *s,
			       reloc_deps_graph *deps,
			       bfd_boolean lit_align)
{
  xtensa_ld_iter_stack *stack = NULL;
  xtensa_ld_iter_stack **stack_p = &stack;

  bfd_boolean first_section = FALSE;
  bfd_boolean in_literals = FALSE;

  if (!lit_align)
    return FALSE;

  for (iter_stack_create (stack_p, s);
       !iter_stack_empty (stack_p);
       iter_stack_next (stack_p))
    {
      lang_statement_union_type *l = iter_stack_current (stack_p);

      switch (l->header.type)
	{
	case lang_input_section_enum:
	  {
	    asection *section = l->input_section.section;
	    bfd_boolean do_xtensa_alignment = FALSE;

	    if (lit_align)
	      {
		if (section->size != 0
		    && (first_section
			|| (in_literals && !section_is_target (deps, l))
			|| (!in_literals && section_is_target (deps, l))))
		  {
		    do_xtensa_alignment = TRUE;
		  }
		first_section = FALSE;
		if (section->size != 0)
		  {
		    in_literals = (section_is_target (deps, l)
				   && !section_is_source (deps, l));
		  }
	      }

	    if (do_xtensa_alignment && xtensa_page_power != 0)
	      {
		/* Create an expression that increments the current address,
		   i.e., "dot", by (1 << xtensa_align_power).  */
		etree_type *name_op = exp_nameop (NAME, ".");
		etree_type *addend_op = exp_intop (1 << xtensa_page_power);
		etree_type *add_op = exp_binop ('+', name_op, addend_op);
		etree_type *assign_op = exp_assign (".", add_op, FALSE);

		lang_assignment_statement_type *assign_stmt;
		lang_statement_union_type *assign_union;
		lang_statement_list_type tmplist;

		/* There is hidden state in "lang_add_assignment".  It
		   appends the new assignment statement to the stat_ptr
		   list.  Thus, we swap it before and after the call.  */

		lang_list_init (&tmplist);
		push_stat_ptr (&tmplist);
		/* Warning: side effect; statement appended to stat_ptr.  */
		assign_stmt = lang_add_assignment (assign_op);
		assign_union = (lang_statement_union_type *) assign_stmt;
		pop_stat_ptr ();

		assign_union->header.next = l;
		*(*stack_p)->iterloc.loc = assign_union;
		iter_stack_next (stack_p);
	      }
	  }
	  break;
	default:
	  break;
	}
    }
  return dot;
}

EOF

# Define some shell vars to insert bits of code into the standard ELF
# parse_args and list_options functions.
#
PARSE_AND_LIST_PROLOGUE='
#define OPTION_OPT_SIZEOPT              (300)
#define OPTION_LITERAL_MOVEMENT		(OPTION_OPT_SIZEOPT + 1)
#define OPTION_NO_LITERAL_MOVEMENT	(OPTION_LITERAL_MOVEMENT + 1)
extern int elf32xtensa_size_opt;
extern int elf32xtensa_no_literal_movement;
'

PARSE_AND_LIST_LONGOPTS='
  { "size-opt", no_argument, NULL, OPTION_OPT_SIZEOPT},
  { "literal-movement", no_argument, NULL, OPTION_LITERAL_MOVEMENT},
  { "no-literal-movement", no_argument, NULL, OPTION_NO_LITERAL_MOVEMENT},
'

PARSE_AND_LIST_OPTIONS='
  fprintf (file, _("\
  --size-opt                  When relaxing longcalls, prefer size\n\
                                optimization over branch target alignment\n"));
'

PARSE_AND_LIST_ARGS_CASES='
    case OPTION_OPT_SIZEOPT:
      elf32xtensa_size_opt = 1;
      break;
    case OPTION_LITERAL_MOVEMENT:
      elf32xtensa_no_literal_movement = 0;
      break;
    case OPTION_NO_LITERAL_MOVEMENT:
      elf32xtensa_no_literal_movement = 1;
      break;
'

# Replace some of the standard ELF functions with our own versions.
#
LDEMUL_BEFORE_PARSE=elf_xtensa_before_parse
LDEMUL_AFTER_OPEN=elf_xtensa_after_open
LDEMUL_CHOOSE_TARGET=elf_xtensa_choose_target
LDEMUL_BEFORE_ALLOCATION=elf_xtensa_before_allocation
@


1.29
log
@	* ldmain.c (main): Flush stdout before and stderr after printing
	message.
	* ldmisc.c (einfo): Similarly.
	* plugin.c (message): Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
	* emulparams/elf32mcore.sh: Use einfo rather than printf.
	* emultempl/beos.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
@
text
@d1890 1
a1890 1
		etree_type *assign_op = exp_assign (".", add_op);
@


1.29.6.1
log
@bfd/
2012-08-09  Maciej W. Rozycki  <macro@@codesourcery.com>

	* elfxx-mips.c (LA25_LUI_MICROMIPS_1, LA25_LUI_MICROMIPS_2):
	Remove macros, folding them into...
	(LA25_LUI_MICROMIPS): ... this new macro.
	(LA25_J_MICROMIPS_1, LA25_J_MICROMIPS_2): Likewise into...
	(LA25_J_MICROMIPS): ... this new macro.
	(LA25_ADDIU_MICROMIPS_1, LA25_ADDIU_MICROMIPS_2): Likewise
	into...
	(LA25_ADDIU_MICROMIPS): ... this new macro.
	(bfd_put_micromips_32, bfd_get_micromips_32): New functions.
	(mips_elf_create_la25_stub): Use them.
	(check_br32_dslot, check_br32, check_relocated_bzc): Likewise.
	(_bfd_mips_elf_relax_section): Likewise.

gas/
	* config/tc-mips.c (NO_ISA_COP, COP_INSN): Remove macros.
	(is_opcode_valid): Remove coprocessor instruction exclusions.
	Replace OPCODE_IS_MEMBER with opcode_is_member.
	(is_opcode_valid_16): Replace OPCODE_IS_MEMBER with
	opcode_is_member.
	(macro): Remove coprocessor instruction exclusions.

gas/
	* gas/mips/mips.exp: Set has_newabi for all Linux targets.
	* gas/mips/cfi-n64-1.d: Adjust for targets that do not infer the
	ISA from the ABI.
	* gas/mips/elf-rel-got-n32.d: Likewise.
	* gas/mips/elf-rel-got-n64.d: Likewise.
	* gas/mips/elf-rel-xgot-n32.d: Likewise.
	* gas/mips/elf-rel-xgot-n64.d: Likewise.
	* gas/mips/elf-rel18.d: Likewise.
	* gas/mips/elf-rel28-n32.d: Likewise.
	* gas/mips/elf-rel28-n64.d: Likewise.
	* gas/mips/jal-newabi.d: Likewise.
	* gas/mips/ldstla-n64-shared.d: Likewise.
	* gas/mips/ldstla-n64-sym32.d: Likewise.
	* gas/mips/ldstla-n64.d: Likewise.
	* gas/mips/macro-warn-1-n32.d: Likewise.
	* gas/mips/macro-warn-2-n32.d: Likewise.
	* gas/mips/n32-consec.d: Likewise.

include/
2012-08-13  Richard Sandiford  <rdsandiford@@googlemail.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips.h (mips_opcode): Add the exclusions field.
	(OPCODE_IS_MEMBER): Remove macro.
	(cpu_is_member): New inline function.
	(opcode_is_member): Likewise.

ld/
	* emulparams/elf32bmip.sh: Make _gp hidden.
	* emulparams/elf32bmipn32-defs.sh: Likewise.
	* emulparams/elf32mipswindiss.sh: Likewise.
	* scripttempl/mips.sc: Likewise.

ld/
2012-08-28  Maciej W. Rozycki  <macro@@codesourcery.com>

	* ld-elf/export-class.sd: New test.
	* ld-elf/export-class.vd: New test.
	* ld-elf/export-class-def.s: New test source.
	* ld-elf/export-class-dep.s: New test source.
	* ld-elf/export-class-lib.s: New test source.
	* ld-elf/export-class-ref.s: New test source.
	* ld-elf/export-class-lib.ver: New test version script.
	* ld-elf/export-class.exp: New test script.
	* ld-arm/arm-export-class.rd: New test.
	* ld-arm/arm-export-class.xd: New test.
	* ld-arm/export-class.exp: New test script.
	* ld-i386/i386-export-class.rd: New test.
	* ld-i386/i386-export-class.xd: New test.
	* ld-i386/export-class.exp: New test script.
	* ld-mips-elf/mips-32-export-class.rd: New test.
	* ld-mips-elf/mips-32-export-class.xd: New test.
	* ld-mips-elf/mips-64-export-class.rd: New test.
	* ld-mips-elf/mips-64-export-class.xd: New test.
	* ld-mips-elf/export-class.exp: New test script.
	* ld-powerpc/powerpc-32-export-class.rd: New test.
	* ld-powerpc/powerpc-32-export-class.xd: New test.
	* ld-powerpc/powerpc-64-export-class.rd: New test.
	* ld-powerpc/powerpc-64-export-class.xd: New test.
	* ld-powerpc/export-class.exp: New test script.
	* ld-x86-64/x86-64-64-export-class.rd: New test.
	* ld-x86-64/x86-64-x32-export-class.rd: New test.
	* ld-x86-64/export-class.exp: New test script.

opcodes/
2012-08-14  Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips-dis.c (print_insn_args): Add GET_OP and GET_OP_S local
	macros, use local variables for info struct member accesses,
	update the type of the variable used to hold the instruction
	word.
	(print_insn_mips, print_mips16_insn_arg): Likewise.
	(print_insn_mips16): Add GET_OP and GET_OP_S local macros, use
	local variables for info struct member accesses.
	(print_insn_micromips): Add GET_OP_S local macro.
	(_print_insn_mips): Update the type of the variable used to hold
	the instruction word.
@
text
@d1890 1
a1890 1
		etree_type *assign_op = exp_assign (".", add_op, FALSE);
@


1.28
log
@	PR ld/12356
	* ldexp.h (exp_assop): Delete.
	(exp_assign, exp_defsym): Declare.
	* ldexp.c (exp_assop): Make static, handle all assignment variations.
	(exp_assign, exp_defsym): New functions.
	(exp_provide): Use exp_assop.
	* ldgram.y (defsym_expr): Use exp_defsym.
	* ldctor.c, * ldgram.y, * ldlang.c, * mri.c, * emultempl/beos.em,
	* emultempl/pe.em, * emultempl/pep.em, * emultempl/spuelf.em,
	* emultempl/xtensaelf.em: Update exp_assop -> exp_assign.
@
text
@d1820 1
d1823 1
@


1.27
log
@bfd/
	* elf-bfd.h (struct bfd_elf_section_reloc_data): New structure.
	(struct bfd_elf_section_data): New members REL and RELA; delete
	members REL_HDR, REL_HDR2, REL_COUNT, REL_COUNT2, REL_IDX,
	REL_IDX2, REL_HASHES.
	(_bfd_elf_init_reloc_shdr): Adjust declaration.
	(_bfd_elf_single_rel_hdr): Declare.
	(RELOC_AGAINST_DISCARDED_SECTION): Use it.
	* elf.c (bfd_section_from_shdr): Adjusted to match changes in
	data structures.
	(_bfd_elf_init_reloc_shdr): New arg RELDATA.  Remove arg REL_HDR.
	All callers changed.  Allocate memory for the Elf_Internal_Shdr
	structure.
	(_bfd_elf_single_rel_hdr): New function.
	(struct fake_section_arg): New structure.
	(elf_fake_section): Expect to see a pointer to it in the third
	argument.  If doing a relocatable link, allocate both REL and RELA
	sections as needed.
	(assign_section_numbers): Adjusted to match changes in
	data structures.
	(_bfd_elf_compute_section_file_positions): Call elf_fake_sections
	with a struct fake_section_args argument.
	* elfcode.h (elf_write_relocs): Adjusted to match changes in
	data structures.
	(elf_slurp_reloc_table): Likewise.
	* elflink.c (_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Remove arg REL_HDR, replace with
	RELDATA.  Remove argument O.  All callers changed.  Remove code to
	discover the right rel_hdr and count.
	(_bfd_elf_link_output_relocs): Adjusted to match changes in
	data structures.
	(elf_link_adjust_relocs): Remove args REL_HDR, COUNT and REL_HASH;
	replace with RELDATA.  All callers changed.
	(elf_link_input_bfd): Correctly generate rel_hash data when both
	REL and RELA sections are present.
	(elf_reloc_link_order): Adjusted to match changes in
	data structures.
	(bfd_elf_final_link): Simplify code to count relocs.  Free the
	hashes array for both REL and RELA.
	(get_dynamic_reloc_section_name): Use _bfd_elf_single_reloc_hdr
	* elf32-m32r.c (m32r_elf_fake_sections, elf_backend_fake_sections):
	Delete.
	* elf32-tic6x.c (elf32_tic6x_fake_sections, elf_backend_fake_sections):
	Delete.
	(elf32_tic6x_rel_relocation_p): Adjusted to match changes in
	data structures.
 	* elf32-microblaze.c (microblaze_elf_check_relocs): Use
	_bfd_elf_single_rel_hdr.
	* elf32-ppc.c (ppc_elf_relax_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (get_reloc_section): Likewise.
	* elf64-mips.c (mips_elf64_slurp_reloc_table): Adjusted to match
	changes in data structures.
	(mips_elf64_write_relocs): Use _bfd_elf_single_rel_hdr.
	* elf64-ppc.c (ppc64_elf_edit_opd): Likewise.
	(ppc64_elf_edit_toc): Likewise.
	(get_relocs): Adjusted to match changes in data structures.
	Allocate an Elf_Internal_Shdr structure if necessary.
	(ppc64_elf_finish_dynamic_sections): Use _bfd_elf_single_rel_hdr.
	* elf64-sparc.c (elf64_sparc_slurp_reloc_table): Adjusted to match
	changes in data structures.
	* elfxx-ia64.c (get_reloc_section): Use _bfd_elf_single_rel_hdr.
	* elfxx-mips.c (MIPS_RELOC_RELA_P): Remove macro.
	(mips_elf_rel_relocation_p): Adjusted to match changes in data
	structures.
	(_bfd_mips_elf_relocate_section): Use mips_elf_rel_relocation_p rather
	than MIPS_RELOC_RELOCA_P.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Use
	_bfd_elf_single_rel_hdr.
	(_bfd_sparc_elf_relocate_section): Likewise.

ld/
	* emultempl/xtensaelf.em (replace_insn_sec_with_prop_sec): Use
	_bfd_elf_single_rel_hdr.
@
text
@d2 1
a2 1
#   Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d1888 1
a1888 1
		etree_type *assign_op = exp_assop ('=', ".", add_op);
@


1.27.2.1
log
@backport from mainline
@
text
@d2 1
a2 1
#   Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
a1819 1
		      fflush (stdout);
a1821 1
		      fflush (stderr);
d1888 1
a1888 1
		etree_type *assign_op = exp_assign (".", add_op);
@


1.26
log
@	PR ld/11931
	* ldlang.h (lang_for_each_statement_worker): Declare.
	* ldlang.c (lang_for_each_statement_worker): Make global.  Don't
	recurse into children of output_section_statement with constraint
	set to -1.
	(print_assignment): Handle NULL output_section->bfd_section.
	(lang_size_sections_1): Ignore output section statement address
	when constraint is -1.
	* emultempl/xtensaelf.em (lang_for_each_statement_worker): Delete.
@
text
@d101 1
d151 3
a153 4
  elf_section_data (prop_sec)->rel_hdr.sh_entsize =
    sizeof (Elf32_External_Rela);
  elf_section_data (prop_sec)->rel_hdr.sh_size =
    elf_section_data (insn_sec)->rel_hdr.sh_size;
@


1.25
log
@fix set but unused variable warnings
@
text
@a598 53
/*  Begin verbatim code from ldlang.c:
    the following are copied from ldlang.c because they are defined
    there statically.  */

static void
lang_for_each_statement_worker (void (*func) (lang_statement_union_type *),
				lang_statement_union_type *s)
{
  for (; s != (lang_statement_union_type *) NULL; s = s->header.next)
    {
      func (s);

      switch (s->header.type)
	{
	case lang_constructors_statement_enum:
	  lang_for_each_statement_worker (func, constructor_list.head);
	  break;
	case lang_output_section_statement_enum:
	  lang_for_each_statement_worker
	    (func,
	     s->output_section_statement.children.head);
	  break;
	case lang_wild_statement_enum:
	  lang_for_each_statement_worker
	    (func,
	     s->wild_statement.children.head);
	  break;
	case lang_group_statement_enum:
	  lang_for_each_statement_worker (func,
					  s->group_statement.children.head);
	  break;
	case lang_data_statement_enum:
	case lang_reloc_statement_enum:
	case lang_object_symbols_statement_enum:
	case lang_output_statement_enum:
	case lang_target_statement_enum:
	case lang_input_section_enum:
	case lang_input_statement_enum:
	case lang_assignment_statement_enum:
	case lang_padding_statement_enum:
	case lang_address_statement_enum:
	case lang_fill_statement_enum:
	  break;
	default:
	  FAIL ();
	  break;
	}
    }
}

/* End of verbatim code from ldlang.c.  */


@


1.24
log
@        PR ld/10956
        * ld.h (struct args_type): Rename 'relax' field to
        'disable_target_specific_optimizations' and turn it into a
        tri-state variable.
        (RELAXATION_DISABLED_BY_DEFAULT): New macro.
        (RELAXATION_DISABLED_BY_USER): New macro.
        (RELAXATION_ENABLED): New macro.
        (DISABLE_RELAXATION): New macro.
        (ENABLE_RELAXATION): New macro.
        * lexsup (enum option_values): Add OPTION_NO_RELAX.
        (struct ld_options): Add --no-relax.
        (parse_args): Handle OPTION_NO_RELAX.  Use DISABLE_RELAXATION and
        ENABLE_RELAXATION macros.
        * ldlang.c (lang_relax_sections): Use RELAXATION_ENABLED macro.
        (lang_process): Likewise.
        * ldmain.c (main): Initialise
        disable_target_specific_optimizations field.
        (multiple_definition): Use RELAXATION_ENABLED macro.
        * ld.texinfo: Document new command line option.
        * emultempl/alphaelf.em: Remove --no-relax option.
        (before_allocation): Test RELAXATION_DISABLED_BY_USER macro.
        Use ENABLE_RELAXATION macro.
        * emultempl/avrelf.em: (after_allocation): Test RELAXATION_ENABLED
        macro.
        * emultempl/cr16elf.em: Remove --no-relax option.
        (before_allocation): Test RELAXATION_DISABLED_BY_USER macro.
        Use ENABLE_RELAXATION macro.
        * emultempl/crxelf.em: Remove --no-relax option.
        (before_allocation): Test RELAXATION_DISABLED_BY_USER macro.
        Use ENABLE_RELAXATION macro.
        * emultempl/mmix-elfnmmo.em: (before_allocation): Use
        ENABLE_RELAXATION macro.
        * emultempl/needrelax.em: (before_allocation): Use
        ENABLE_RELAXATION macro.
        * emultempl/ppc32elf.em: (before_allocation): Test
        RELAXATION_DISABLED_BY_DEFAULT macro. Use
        ENABLE_RELAXATION macro.
        * emultempl/sh64elf.em: (before_allocation): Test
        RELAXATION_ENABLED macro. Use DISABLE_RELAXATION macro.
        * emultempl/xtensaelf.em: Remove --no-relax option.
        (before_allocation): Test RELAXATION_ENABLED macro.
        Use ENABLE_RELAXATION macro.
@
text
@d2 1
a2 1
#   Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009
a100 1
  Elf_Internal_Shdr *symtab_hdr;
a207 1
      symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
a1669 1
  lang_output_section_statement_type *os;
a1690 2
      os = &statement->output_section_statement;

@


1.23
log
@	* ldlang.c (push_stat_ptr, pop_stat_ptr): New functions.
	(stat_save, stat_save_ptr): New variables.
	(lang_insert_orphan): Use push_stat_ptr and pop_stat_ptr.
	(load_symbols): Likewise.  Delete dead "bad_load" code.
	(open_input_bfds): Warn on script containing output sections.
	(lang_enter_output_section_statement): Use push_stat_ptr.
	(lang_enter_group): Likewise.
	(lang_leave_output_section_statement): Use pop_stat_ptr.
	(lang_leave_group): Likewise.
	* ldlang.h (push_stat_ptr, pop_stat_ptr): Declare.
	* ldctor.c (ldctor_build_sets): Use push_stat_ptr and pop_stat_ptr.
	* emultempl/beos.em (gld_${EMULATION_NAME}_set_symbols): Likewise.
	* emultempl/pe.em (gld_${EMULATION_NAME}_set_symbols): Likewise.
	* emultempl/pep.em (gld_${EMULATION_NAME}_set_symbols): Likewise.
	* emultempl/spuelf.em (spu_place_special_section): Likewise.
	* emultempl/xtensaelf.em (ld_xtensa_insert_page_offsets): Likewise.
@
text
@a44 3
/* Flag for the emulation-specific "--no-relax" option.  */
static bfd_boolean disable_relaxation = FALSE;

d527 2
a528 3

  if (!disable_relaxation)
    command_line.relax = TRUE;
d535 2
a536 1
  if (command_line.relax)
d1983 1
a1983 2
#define OPTION_NO_RELAX			(OPTION_OPT_SIZEOPT + 1)
#define OPTION_LITERAL_MOVEMENT		(OPTION_NO_RELAX + 1)
a1990 1
  { "no-relax", no_argument, NULL, OPTION_NO_RELAX},
a1998 2
  fprintf (file, _("\
  --no-relax                  Do not relax branches or coalesce literals\n"));
a2004 3
    case OPTION_NO_RELAX:
      disable_relaxation = TRUE;
      break;
@


1.22
log
@include/
	* bfdlink.h (struct bfd_link_hash_table): Delete creator field.
	(struct bfd_link_info): Add output_bfd.
bfd/
	* elflink.c: Replace all accesses to hash->creator field with
	output_bfd->xvec.
	* cofflink.c: Likewise.
	* coff-h8300.c: Likewise.
	* ecoff.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfxx-mips.c: Likewise.
	* i386linux.c: Likewise.
	* m68klinux.c: Likewise.
	* sparclinux.c: Likewise.
	* sunos.c: Likewise.
	* xcofflink.c: Likewise.
	* linker.c: Likewise.
	(_bfd_link_hash_table_init): Don't store creator.
ld/
	* ldmain.h (output_bfd): Delete.
	* ldmain.c (output_bfd): Delete.
	Replace all occurrences of output_bfd with link_info.output_bfd.
	* ldcref.c: Likewise.
	* ldctor.c: Likewise.
	* ldemul.c: Likewise.
	* ldexp.c: Likewise.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldmisc.c: Likewise.
	* ldwrite.c: Likewise.
	* pe-dll.c: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/alphaelf.em: Likewise.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/elf-generic.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/irix.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/mmix-elfnmmo.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/sh64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
	* emultempl/z80.em: Likewise.
	* ldlang.c (open_output): Don't return output, instead write
	link_info_output_bfd directly.
	* emultempl/alphaelf.em: Replace occurrences of link_info.hash->creator
	with link_info.output_bfd->xvec.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
@
text
@d2 1
a2 1
#   Copyright 2003, 2004, 2005, 2006, 2007, 2008
a1953 1
		lang_statement_list_type *old_stat_ptr = stat_ptr;
d1959 2
a1960 4
		tmplist.head = NULL;
		tmplist.tail = &tmplist.head;

		stat_ptr = &tmplist;
d1964 1
a1964 1
		stat_ptr = old_stat_ptr;
@


1.22.2.1
log
@backport 2009-02-16  Alan Modra  <amodra@@bigpond.net.au>
@
text
@d2 1
a2 1
#   Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009
d1954 1
d1960 4
a1963 2
		lang_list_init (&tmplist);
		push_stat_ptr (&tmplist);
d1967 1
a1967 1
		pop_stat_ptr ();
@


1.21
log
@	* emultempl/alphaelf.em: Format option help.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ia64elf.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/ticoff.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
@
text
@d2 1
a2 1
#   Copyright 2003, 2004, 2005, 2006, 2007
d437 2
a438 1
  if (is_big_endian && output_bfd->xvec->byteorder == BFD_ENDIAN_LITTLE)
d443 2
a444 1
  if (!is_big_endian && output_bfd->xvec->byteorder == BFD_ENDIAN_BIG)
@


1.20
log
@2007-07-19  Roland McGrath  <roland@@redhat.com>

	* genscripts.sh (source_em, fragment): New sh functions.
	Truncate e${EMULATION_NAME}.c file before .em script fills it.
	Use source_em in place of . for the .em script.
	* emultempl/generic.em: Use fragment and source_em functions.
	* emultempl/aix.em: Likewise.
	* emultempl/alphaelf.em: Likewise.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/cr16elf.em: Likewise.
	* emultempl/crxelf.em: Likewise.
	* emultempl/elf-generic.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/genelf.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/gld960c.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ia64elf.em: Likewise.
	* emultempl/irix.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/m68kcoff.em: Likewise.
	* emultempl/m68kelf.em: Likewise.
	* emultempl/mipsecoff.em: Likewise.
	* emultempl/mipself.em: Likewise.
	* emultempl/mmix-elfnmmo.em: Likewise.
	* emultempl/mmixelf.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/needrelax.em: Likewise.
	* emultempl/netbsd.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/sh64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/ticoff.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
	* emultempl/z80.em: Likewise.
@
text
@d2002 5
a2006 2
  fprintf (file, _("  --size-opt\t\tWhen relaxing longcalls, prefer size optimization\n\t\t\t  over branch target alignment\n"));
  fprintf (file, _("  --no-relax\t\tDo not relax branches or coalesce literals\n"));
@


1.19
log
@Update sources to GPLv3
@
text
@d26 1
a26 1
cat >>e${EMULATION_NAME}.c <<EOF
d107 1
a107 1
 
d120 1
a120 1
  
d147 1
a147 1
  
d156 1
a156 1
  elf_section_data (prop_sec)->rel_hdr.sh_size = 
d172 1
a172 1
      
d174 1
a174 1
      internal_relocs = 
d177 1
a177 1
      
d191 1
a191 1
  
d221 1
a221 1
	  /* If this relocation is to the .xt.insn section, 
d230 1
a230 1
  
d233 1
a233 1
  
d261 1
a261 1
    
d300 1
a300 1
  
a2026 1

@


1.18
log
@bfd/
        * elf32-xtensa.c (extend_ebb_bounds_forward): Use renamed
        XTENSA_PROP_NO_TRANSFORM flag instead of XTENSA_PROP_INSN_NO_TRANSFORM.
        (extend_ebb_bounds_backward, compute_text_actions): Likewise.
        (compute_ebb_proposed_actions, coalesce_shared_literal): Likewise.
        (xtensa_get_property_predef_flags): Likewise.
        (compute_removed_literals): Pass new arguments to is_removable_literal.
        (is_removable_literal): Add sec, prop_table and ptblsize arguments.
        Do not remove literal if the NO_TRANSFORM property flag is set.
gas/
        * config/tc-xtensa.c (XTENSA_PROP_INSN_NO_TRANSFORM): Renamed to...
        (XTENSA_PROP_NO_TRANSFORM): ...this.
        (frag_flags_struct): Move is_no_transform out of the insn sub-struct.
        (xtensa_mark_frags_for_org): New.
        (xtensa_handle_align): Set RELAX_ORG frag subtype for rs_org.
        (xtensa_post_relax_hook): Call xtensa_mark_frags_for_org.
        (get_frag_property_flags): Adjust reference to is_no_transform flag.
        (xtensa_frag_flags_combinable): Likewise.
        (frag_flags_to_number): Likewise.  Use XTENSA_PROP_NO_TRANSFORM.
        * config/tc-xtensa.h (xtensa_relax_statesE): Add RELAX_ORG.
include/elf/
        * xtensa.h (XTENSA_PROP_INSN_NO_TRANSFORM): Renamed to...
        (XTENSA_PROP_NO_TRANSFORM): ...this.
ld/
        * emultempl/xtensaelf.em (replace_insn_sec_with_prop_sec): Use renamed
        XTENSA_PROP_NO_TRANSFORM flag instead of XTENSA_PROP_INSN_NO_TRANSFORM.
@
text
@d2 1
a2 1
#   Copyright 2003, 2004, 2005, 2006
d5 1
a5 1
# This file is part of GLD, the Gnu Linker.
d9 1
a9 1
# the Free Software Foundation; either version 2 of the License, or
d19 2
a20 2
# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, 
# MA 02110-1301 USA.
@


1.17
log
@bfd/
	* elf32-xtensa.c (elf_xtensa_special_sections): Add .xtensa.info.
gas/
	* config/tc-xtensa.c (XSHAL_ABI): Add default definition.
	(directive_state): Disable scheduling by default.
	(xtensa_add_config_info): New.
	(xtensa_end): Call xtensa_add_config_info.
gas/testsuite/
	* gas/elf/section2.e-xtensa: New file.
	* gas/elf/elf.exp: Use it.
include/
	* xtensa-config.h (XSHAL_ABI): New.
	(XTHAL_ABI_WINDOWED, XTHAL_ABI_CALL0): New.
ld/
	* emultempl/xtensaelf.em (XSHAL_ABI): Add default definition.
	(replace_insn_sec_with_prop_sec): Use bfd_make_section_with_flags.
	Delete redundant code to set sections flags and alignment.
	(xt_config_info_unpack_and_check, check_xtensa_info): New.
	(elf_xtensa_after_open): Iterate over input statements instead of
	link_info.input_bfds.
	(elf_xtensa_before_allocation): Likewise.  Call check_xtensa_info for
	each input, and write a new .xtensa.info section in the output.
@
text
@d197 1
a197 1
      unsigned flags = (XTENSA_PROP_INSN | XTENSA_PROP_INSN_NO_TRANSFORM
@


1.16
log
@bfd/
	* elf32-xtensa.c (elf_xtensa_action_discarded): New.
	(elf_backend_action_discarded): Define.
ld/
	* emultempl/xtensaelf.em (is_inconsistent_linkonce_section): Check
	for linkonce XCC exception tables (".e" and ".h").
@
text
@d19 2
a20 1
# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
d34 5
d137 1
a137 1
  /* Create a Property table section and relocation section for it.  */
d139 2
a140 1
  prop_sec = bfd_make_section (abfd, prop_sec_name);
a141 2
      || ! bfd_set_section_flags (abfd, prop_sec, 
				  bfd_get_section_flags (abfd, insn_sec))
a147 7
  if (! bfd_set_section_flags (abfd, prop_sec, 
			       bfd_get_section_flags (abfd, insn_sec))
      || ! bfd_set_section_alignment (abfd, prop_sec, 2))
    {
      *error_message = _("could not set new section properties");
      goto cleanup;
    }
a297 2
  bfd *abfd;

d302 1
a302 3
  for (abfd = link_info.input_bfds;
       abfd != NULL;
       abfd = abfd->link_next)
d304 1
a304 1
      asection *sec = abfd->sections;
d312 1
a312 1
	  replace_instruction_table_sections (abfd, sec);
d319 101
d426 2
a427 1
  bfd *in_bfd;
d448 74
a521 12
  /* Check that the endianness for each input file matches the output.
     The merge_private_bfd_data hook has already reported any mismatches
     as errors, but those errors are not fatal.  At this point, we
     cannot go any further if there are any mismatches.  */

  for (in_bfd = link_info.input_bfds;
       in_bfd != NULL;
       in_bfd = in_bfd->link_next)
    {
      if ((is_big_endian && in_bfd->xvec->byteorder == BFD_ENDIAN_LITTLE)
	  || (!is_big_endian && in_bfd->xvec->byteorder == BFD_ENDIAN_BIG))
	einfo (_("%F%P: cross-endian linking not supported\n"));
@


1.15
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d1187 1
a1187 1
/* Strip out any linkonce literal sections or property tables where the
d1202 1
a1202 1
  const char *name = 0;
d1208 10
a1217 5
  /* Check if this is an Xtensa property section.  */
  if (CONST_STRNEQ (sec_name + linkonce_len, "p."))
    name = sec_name + linkonce_len + 2;
  else if (CONST_STRNEQ (sec_name + linkonce_len, "prop."))
    name = strchr (sec_name + linkonce_len + 5, '.') + 1;
@


1.14
log
@	* emultempl/xtensaelf.em (xtensa_strip_inconsistent_linkonce_sections):
	Set discarded section's output_section to bfd_abs_section_ptr.
@
text
@d270 1
a270 2
  else if (strncmp (sec_name, LINKONCE_SEC_OLD_TEXT_BASE_NAME,
		    strlen (LINKONCE_SEC_OLD_TEXT_BASE_NAME)) == 0)
d1209 1
a1209 1
  if (strncmp (sec_name + linkonce_len, "p.", 2) == 0)
d1211 1
a1211 1
  else if (strncmp (sec_name + linkonce_len, "prop.", 5) == 0)
@


1.13
log
@	* emultempl/xtensaelf.em (is_inconsistent_linkonce_section): Add space
	in dep_sec_name for null terminator.  Make sure dep_sec_name has a
	".t" linkonce tag.
@
text
@d1252 1
@


1.12
log
@	* emultempl/xtensaelf.em (elf_xtensa_before_allocation): Call new
	function to strip inconsistent linkonce sections.
	(input_section_linked_worker, input_section_linked): New.
	(is_inconsistent_linkonce_section): New.
	(xtensa_strip_inconsistent_linkonce_sections): New.
@
text
@d1203 1
a1203 1
  char *prop_tag = 0;
d1211 1
a1211 1
    prop_tag = "p.";
d1213 3
a1215 2
    prop_tag = "prop.";
  if (prop_tag)
d1217 1
a1217 2
      int tag_len = strlen (prop_tag);
      char *dep_sec_name = xmalloc (strlen (sec_name));
d1223 2
a1224 2
      strcpy (dep_sec_name, ".gnu.linkonce.");
      strcat (dep_sec_name, sec_name + linkonce_len + tag_len);
@


1.11
log
@	* emultempl/xtensaelf.em (elf_xtensa_place_orphan): Delete.
	(LDEMUL_PLACE_ORPHAN): Delete.
@
text
@d2 1
a2 1
#   Copyright 2003, 2004, 2005
d35 2
d375 2
d1164 139
@


1.11.2.1
log
@Merge changes between binutils-csl-2_17-branchpoint and
binutils-2_17, except for the addition of generated files to CVS.
@
text
@d2 1
a2 1
#   Copyright 2003, 2004, 2005, 2006
a34 2
static void xtensa_strip_inconsistent_linkonce_sections
  (lang_statement_list_type *);
a372 2
  xtensa_strip_inconsistent_linkonce_sections (stat_ptr);

a1159 139
/* Check if a particular section is included in the link.  This will only
   be true for one instance of a particular linkonce section.  */

static bfd_boolean input_section_found = FALSE;
static asection *input_section_target = NULL;

static void
input_section_linked_worker (lang_statement_union_type *statement)
{
  if ((statement->header.type == lang_input_section_enum
       && (statement->input_section.section == input_section_target)))
    input_section_found = TRUE;
}

static bfd_boolean
input_section_linked (asection *sec)
{
  input_section_found = FALSE;
  input_section_target = sec;
  lang_for_each_statement_worker (input_section_linked_worker, stat_ptr->head);
  return input_section_found;
}


/* Strip out any linkonce literal sections or property tables where the
   associated linkonce text is from a different object file.  Normally,
   a matching set of linkonce sections is taken from the same object file,
   but sometimes the files are compiled differently so that some of the
   linkonce sections are not present in all files.  Stripping the
   inconsistent sections like this is not completely robust -- a much
   better solution is to use comdat groups.  */

static int linkonce_len = sizeof (".gnu.linkonce.") - 1;

static bfd_boolean
is_inconsistent_linkonce_section (asection *sec)
{
  bfd *abfd = sec->owner;
  const char *sec_name = bfd_get_section_name (abfd, sec);
  char *prop_tag = 0;

  if ((bfd_get_section_flags (abfd, sec) & SEC_LINK_ONCE) == 0
      || strncmp (sec_name, ".gnu.linkonce.", linkonce_len) != 0)
    return FALSE;

  /* Check if this is an Xtensa property section.  */
  if (strncmp (sec_name + linkonce_len, "p.", 2) == 0)
    prop_tag = "p.";
  else if (strncmp (sec_name + linkonce_len, "prop.", 5) == 0)
    prop_tag = "prop.";
  if (prop_tag)
    {
      int tag_len = strlen (prop_tag);
      char *dep_sec_name = xmalloc (strlen (sec_name));
      asection *dep_sec;

      /* Get the associated linkonce text section and check if it is
	 included in the link.  If not, this section is inconsistent
	 and should be stripped.  */
      strcpy (dep_sec_name, ".gnu.linkonce.");
      strcat (dep_sec_name, sec_name + linkonce_len + tag_len);
      dep_sec = bfd_get_section_by_name (abfd, dep_sec_name);
      if (dep_sec == NULL || ! input_section_linked (dep_sec))
	{
	  free (dep_sec_name);
	  return TRUE;
	}
      free (dep_sec_name);
    }

  return FALSE;
}


static void
xtensa_strip_inconsistent_linkonce_sections (lang_statement_list_type *slist)
{
  lang_statement_union_type **s_p = &slist->head;
  while (*s_p)
    {
      lang_statement_union_type *s = *s_p;
      lang_statement_union_type *s_next = (*s_p)->header.next;

      switch (s->header.type)
	{
	case lang_input_section_enum:
	  if (is_inconsistent_linkonce_section (s->input_section.section))
	    {
	      *s_p = s_next;
	      continue;
	    }
	  break;

	case lang_constructors_statement_enum:
	  xtensa_strip_inconsistent_linkonce_sections (&constructor_list);
	  break;

	case lang_output_section_statement_enum:
	  if (s->output_section_statement.children.head)
	    xtensa_strip_inconsistent_linkonce_sections
	      (&s->output_section_statement.children);
	  break;

	case lang_wild_statement_enum:
	  xtensa_strip_inconsistent_linkonce_sections
	    (&s->wild_statement.children);
	  break;

	case lang_group_statement_enum:
	  xtensa_strip_inconsistent_linkonce_sections
	    (&s->group_statement.children);
	  break;

	case lang_data_statement_enum:
	case lang_reloc_statement_enum:
	case lang_object_symbols_statement_enum:
	case lang_output_statement_enum:
	case lang_target_statement_enum:
	case lang_input_statement_enum:
	case lang_assignment_statement_enum:
	case lang_padding_statement_enum:
	case lang_address_statement_enum:
	case lang_fill_statement_enum:
	  break;

	default:
	  FAIL ();
	  break;
	}

      s_p = &(*s_p)->header.next;
    }

  /* Reset the tail of the list, in case the last entry was removed.  */
  if (s_p != slist->tail)
    slist->tail = s_p;
}


@


1.10
log
@	* ldlang.h (lang_input_section_type): Remove "ifile" field.
	(lang_insert_orphan, lang_add_section): Update prototypes.
	* ldlang.c (lang_insert_orphan): Remove "file" param.
	(lang_add_section): Likewise.  Update all callers.
	(wild_sort): Get an input section's bfd via "section->owner".
	(size_input_section): Access just_syms_flag via bfd usrdata.
	(lang_place_orphans): Update ldemul_place_orphan call.
	* ldemul.h (ldemul_place_orphan): Remove input_statement param.
	(struct ld_emulation_xfer_struct <place_orphan>): Likewise.
	* ldemul.c (ldemul_place_orphan): Likewise.
	* ldwrite.c (build_link_order): Access just_syms_flag via bfd usrdata.
	* emultempl/armelf.em (arm_elf_set_bfd_for_interworking): Likewise.
	* emultempl/beos.em (sort_by_file_name): Access bfd by section->owner.
	(sort_sections): Likewise.
	(place_orphan): Remove "file" param.  Adjust lang_add_section call.
	* emultempl/elf32.em (place_orphan): Remove "file" param.  Adjust
	lang_add_section and lang_insert_orphan calls.
	* emultempl/hppaelf.em (hppaelf_add_stub_section): Adjust
	lang_add_section call.
	(build_section_lists): Access just_syms_flag via bfd usrdata.
	* emultempl/m68hc1xelf.em (m68hc11elf_add_stub_section): Adjust
	lang_add_section call.
	* emultempl/mmo.em (mmo_place_orphan): Remove "file" param.  Adjust
	lang_add_section and lang_insert_orphan calls.
	* emultempl/pe.em (place_orphan): Likewise.  Access bfd via section
	owner.
	* emultempl/ppc64elf.em (ppc_add_stub_section): Adjust
	lang_add_section call.
	(build_toc_list): Access just_syms_flag via bfd usrdata.
	(build_section_lists): Likewise.
	* emultempl/xtensaelf.em (elf_xtensa_place_orphan): Remove "file"
	param.  Adjust place_orphan call.
	(ld_build_required_section_dependence): Access bfd via section owner.
@
text
@a60 11
static bfd_boolean
elf_xtensa_place_orphan (asection *s)
{
  /* Early exit for relocatable links.  */
  if (link_info.relocatable)
    return FALSE;

  return gld${EMULATION_NAME}_place_orphan (s);
}


a1719 1
LDEMUL_PLACE_ORPHAN=elf_xtensa_place_orphan
@


1.9
log
@Update FSF addresses
@
text
@d62 1
a62 1
elf_xtensa_place_orphan (lang_input_statement_type *file, asection *s)
d68 1
a68 1
  return gld${EMULATION_NAME}_place_orphan (file, s);
d1140 1
a1140 1
	  xtensa_callback_required_dependence (input->ifile->the_bfd,
@


1.8
log
@update copyright dates
@
text
@d19 1
a19 1
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
@


1.7
log
@	* ldlang.c (lang_reasonable_defaults): Remove.
	(lang_process): Don't call lang_reasonable_defaults.

	* ldexp.c (exp_assop): Remove #if 0'd code.
	(exp_print_tree): Likewise.
	* ldlang.c (lang_memory_region_lookup): Likewise.
	(open_output): Likewise.
	(lang_do_assignments_1): Likewise.
	(lang_place_orphans): Likewise.
	(lang_enter_output_section_statement): Likewise.
	(lang_reasonable_defaults): Likewise.
	* ldlang.h (struct lang_input_statement_struct): Likewise.
	* mri.c (mri_draw_tree): Likewise.
	(mri_load): Likewise.
	* pe-dll.c (generate_reloc): Likewise.
	(make_import_fixup_entry): Likewise.
	(pe_as16): Likewise.
	* emultempl/beos.em (set_pe_subsystem): Likewise.
	* emultempl/hppaelf.em (hppaelf_after_parse): Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/xtensaelf.em (xtensa_colocate_literals): Likewise.
@
text
@d2 1
a2 1
#   Copyright 2003, 2004
@


1.6
log
@bfd ChangeLog

	* elf32-xtensa.c: Use ISO C90 formatting.

gas ChangeLog

	* config/tc-xtensa.c: Use ISO C90 formatting.
	* config/tc-xtensa.h: Likewise.
	* config/xtensa-istack.h: Likewise.
	* config/xtensa-relax.c: Likewise.
	* config/xtensa-relax.h: Likewise.

ld ChangeLog

	* emultempl/xtensaelf.em: Use ISO C90 formatting.

opcodes ChangeLog

	* xtensa-dis.c: Use ISO C90 formatting.
@
text
@a875 10
#if 0
  ld_assign_relative_paged_dot (0x100000, statement, deps,
				xtensa_use_literal_pages);

  if (!ld_local_file_relocations_fit (statement, deps))
    fprintf (stderr, "initial relocation placement does not fit\n");

  lang_for_each_statement_worker (xtensa_ldlang_clear_addresses, statement);
#endif

@


1.5
log
@bfd ChangeLog

	* elf32-xtensa.c (elf32xtensa_size_opt): New global variable.
	(xtensa_default_isa): Global variable moved here from xtensa-isa.c.
	(elf32xtensa_no_literal_movement): New global variable.
	(elf_howto_table): Add entries for new relocations.
	(elf_xtensa_reloc_type_lookup): Handle new relocations.
	(property_table_compare): When addresses are equal, compare sizes and
	various property flags.
	(property_table_matches): New.
	(xtensa_read_table_entries): Extend to read new property tables.  Add
	output_addr parameter to indicate that output addresses should be used.
	Use bfd_get_section_limit.
	(elf_xtensa_find_property_entry): New.
	(elf_xtensa_in_literal_pool): Use elf_xtensa_find_property_entry.
	(elf_xtensa_check_relocs): Handle new relocations.
	(elf_xtensa_do_reloc): Use bfd_get_section_limit.  Handle new
	relocations.  Use new xtensa-isa.h functions.
	(build_encoding_error_message): Remove encode_result parameter.  Add
	new target_address parameter used to detect alignment errors.
	(elf_xtensa_relocate_section): Use bfd_get_section_limit.  Clean up
	error handling.  Use new is_operand_relocation function.
	(elf_xtensa_combine_prop_entries, elf_xtensa_merge_private_bfd_data):
	Use underbar macro for error messages.  Formatting.
	(get_const16_opcode): New.
	(get_l32r_opcode): Add a separate flag for initialization.
	(get_relocation_opnd): Operand number is no longer explicit in the
	relocation.  Change to decode the opcode and analyze its operands.
	(get_relocation_slot): New.
	(get_relocation_opcode): Add bfd parameter.  Use bfd_get_section_limit.
	Use new xtensa-isa.h functions to handle multislot instructions.
	(is_l32r_relocation): Add bfd parameter.  Use is_operand_relocation.
	(get_asm_simplify_size, is_alt_relocation, is_operand_relocation,
	insn_decode_len, insn_decode_opcode, check_branch_target_aligned,
	check_loop_aligned, check_branch_target_aligned_address, narrowable,
	widenable, narrow_instruction, widen_instruction, op_single_fmt_table,
	get_single_format, init_op_single_format_table): New.
	(elf_xtensa_do_asm_simplify): Add error_message parameter and use it
	instead of calling _bfd_error_handler.  Use new xtensa-isa.h functions.
	(contract_asm_expansion): Add error_message parameter and pass it to
	elf_xtensa_do_asm_simplify.  Replace use of R_XTENSA_OP0 relocation
	with R_XTENSA_SLOT0_OP.
	(get_expanded_call_opcode): Extend to handle either L32R or CONST16
	instructions.  Use new xtensa-isa.h functions.
	(r_reloc struct): Add new virtual_offset field.
	(r_reloc_init): Add contents and content_length parameters.  Set
	virtual_offset field to zero.  Add contents to target_offset field for
	partial_inplace relocations.
	(r_reloc_is_defined): Check for null.
	(print_r_reloc): New debug function.
	(source_reloc struct): Replace xtensa_operand field with pair of the
	opcode and the operand position.  Add is_abs_literal field.
	(init_source_reloc): Specify operand by opcode/position pair.  Set
	is_abs_literal field.
	(source_reloc_compare): When target_offsets are equal, compare other
	fields to make sorting predictable.
	(literal_value struct): Add is_abs_literal field.
	(value_map_hash_table struct): Add has_last_loc and last_loc fields.
	(init_literal_value): New.
	(is_same_value): Replace with ...
	(literal_value_equal): ... this function.  Add comparisons of
	virtual_offset and is_abs_literal fields.
	(value_map_hash_table_init): Use bfd_zmalloc.  Check for allocation
	failure.  Initialize has_last_loc field.
	(value_map_hash_table_delete): New.
	(hash_literal_value): Rename to ...
	(literal_value_hash): ... this.  Include is_abs_literal flag and
	virtual_offset field in the hash value.
	(get_cached_value): Rename to ...
	(value_map_get_cached_value): ... this.  Update calls to
	literal_value_hash and literal_value_equal.
	(add_value_map): Check for allocation failure.  Update calls to
	value_map_get_cached_value and literal_value_hash.
	(text_action, text_action_list, text_action_t): New types.
	(find_fill_action, compute_removed_action_diff, adjust_fill_action,
	text_action_add, text_action_add_literal, offset_with_removed_text,
	offset_with_removed_text_before_fill, find_insn_action,
	print_action_list, print_removed_literals): New.
	(offset_with_removed_literals): Delete.
	(xtensa_relax_info struct): Add is_relaxable_asm_section, action_list,
	fix_array, fix_array_count, allocated_relocs, relocs_count, and
	allocated_relocs_count fields.
	(init_xtensa_relax_info): Initialize new fields.
	(reloc_bfd_fix struct): Add new translated field.
	(reloc_bfd_fix_init): Add translated parameter and use it to set the
	translated field.
	(fix_compare, cache_fix_array): New.
	(get_bfd_fix): Remove fix_list parameter and get all relax_info for the
	section via get_xtensa_relax_info.  Use cache_fix_array to set up
	sorted fix_array and use bsearch instead of linear search.
	(section_cache_t): New struct.
	(init_section_cache, section_cache_section, clear_section_cache): New.
	(ebb_t, ebb_target_enum, proposed_action, ebb_constraint): New types.
	(init_ebb_constraint, free_ebb_constraint, init_ebb, extend_ebb_bounds,
	extend_ebb_bounds_forward, extend_ebb_bounds_backward,
	insn_block_decodable_len, ebb_propose_action, ebb_add_proposed_action):
	New.
	(retrieve_contents): Use bfd_get_section_limit.
	(elf_xtensa_relax_section): Add relocations_analyzed flag.  Update call
	to compute_removed_literals.  Free value_map_hash_table when no longer
	needed.
	(analyze_relocations): Check is_relaxable_asm_section flag.  Call
	compute_text_actions for all sections.
	(find_relaxable_sections): Mark sections as relaxable if they contain
	ASM_EXPAND relocations that can be optimized.  Adjust r_reloc_init
	call.  Increment relax_info src_count field only for appropriate
	relocation types.  Remove is_literal_section check.
	(collect_source_relocs): Use bfd_get_section_limit.  Adjust calls to
	r_reloc_init and find_associated_l32r_irel.  Check
	is_relaxable_asm_section flag.  Handle L32R instructions with absolute
	literals.  Pass is_abs_literal flag to init_source_reloc.
	(is_resolvable_asm_expansion): Use bfd_get_section_limit.  Check for
	CONST16 instructions.  Adjust calls to r_reloc_init and
	pcrel_reloc_fits.  Handle weak symbols conservatively.
	(find_associated_l32r_irel): Add bfd parameter and pass it to
	is_l32r_relocation.
	(compute_text_actions, compute_ebb_proposed_actions,
	compute_ebb_actions, check_section_ebb_pcrels_fit,
	check_section_ebb_reduces, text_action_add_proposed,
	compute_fill_extra_space): New.
	(remove_literals): Replace with ...
	(compute_removed_literals): ... this function.  Call
	init_section_cache.  Use bfd_get_section_limit.  Sort internal_relocs.
	Call xtensa_read_table_entries to get the property table.  Skip
	relocations other than R_XTENSA_32 and R_XTENSA_PLT.  Use new
	is_removable_literal, remove_dead_literal, and
	identify_literal_placement functions.
	(get_irel_at_offset): Rewrite to use bsearch on sorted relocations
	instead of linear search.
	(is_removable_literal, remove_dead_literal,
	identify_literal_placement): New.
	(relocations_reach): Update check for literal not referenced by any
	PC-relative relocations.  Adjust call to pcrel_reloc_fits.
	(coalesce_shared_literal, move_shared_literal): New.
	(relax_section): Use bfd_get_section_limit.  Call
	translate_section_fixes.  Update calls to r_reloc_init and
	offset_with_removed_text.  Check new is_relaxable_asm_section flag.
	Add call to pin_internal_relocs.  Add special handling for
	R_XTENSA_ASM_SIMPLIFY and R_XTENSA_DIFF* relocs.  Use virtual_offset
	info to calculate new addend_displacement variable.  Replace code for
	deleting literals with more general code to perform the actions
	determined by the action_list for the section.
	(translate_section_fixes, translate_reloc_bfd_fix): New.
	(translate_reloc): Check new is_relaxable_asm_section flag.  Call
	find_removed_literal only if is_operand_relocation.  Update call to
	offset_with_removed_text.  Use new target_offset and removed_bytes
	variables.
	(move_literal): New.
	(relax_property_section):  Use bfd_get_section_limit.  Set new
	is_full_prop_section flag and handle new property tables.  Update calls
	to r_reloc_init and offset_with_removed_text.  Check
	is_relaxable_asm_section flag.  Handle expansion of zero-sized
	unreachable entries, with use of offset_with_removed_text_before_fill.
	For relocatable links, combine entries only for literal tables.
	(relax_section_symbols): Check is_relaxable_asm_section flag.  Update
	calls to offset_with_removed_text.  Translate st_size field for
	function symbols.
	(do_fix_for_relocatable_link): Change to return bfd_boolean to indicate
	failure.  Add contents parameter.  Update call to get_bfd_fix.  Update
	call to r_reloc_init.  Call _bfd_error_handler and return FALSE for
	R_XTENSA_ASM_EXPAND relocs.
	(do_fix_for_final_link): Add input_bfd and contents parameters.  Update
	call to get_bfd_fix.  Include offset from contents for partial_inplace
	relocations.
	(is_reloc_sym_weak): New.
	(pcrel_reloc_fits): Use new xtensa-isa.h functions.
	(prop_sec_len): New.
	(xtensa_is_property_section): Handle new property sections.
	(is_literal_section): Delete.
	(internal_reloc_compare): When r_offset matches, compare r_info and
	r_addend to make sorting predictable.
	(internal_reloc_matches): New.
	(xtensa_get_property_section_name): Handle new property sections.
	(xtensa_get_property_predef_flags): New.
	(xtensa_callback_required_dependence): Use bfd_get_section_limit.
	Update calls to xtensa_isa_init, is_l32r_relocation, and r_reloc_init.
	* xtensa-isa.c (xtensa_default_isa): Moved to elf32-xtensa.c.
	(xtisa_errno, xtisa_error_msg): New variables.
	(xtensa_isa_errno, xtensa_isa_error_msg): New.
	(xtensa_insnbuf_alloc): Add error handling.
	(xtensa_insnbuf_to_chars): Add num_chars parameter.  Update to
	use xtensa_format_decode.  Add error handling.
	(xtensa_insnbuf_from_chars): Add num_chars parameter.  Decode the
	instruction length to find the number of bytes to copy.
	(xtensa_isa_init): Add error handling.  Replace calls to
	xtensa_load_isa and xtensa_extend_isa with code to initialize lookup
	tables in the xtensa_modules structure.
	(xtensa_check_isa_config, xtensa_add_isa, xtensa_load_isa,
	xtensa_extend_isa): Delete.
	(xtensa_isa_free): Change to only free lookup tables.
	(opname_lookup_compare): Replace with ...
	(xtensa_isa_name_compare): ... this function.  Use strcasecmp.
	(xtensa_insn_maxlength): Rename to ...
	(xtensa_isa_maxlength): ... this.
	(xtensa_insn_length): Delete.
	(xtensa_insn_length_from_first_byte): Replace with ...
	(xtensa_isa_length_from_chars): ... this function.
	(xtensa_num_opcodes): Rename to ...
	(xtensa_isa_num_opcodes): ... this.
	(xtensa_isa_num_pipe_stages, xtensa_isa_num_formats,
	xtensa_isa_num_regfiles, xtensa_isa_num_stages,
	xtensa_isa_num_sysregs, xtensa_isa_num_interfaces,
	xtensa_isa_num_funcUnits, xtensa_format_name, xtensa_format_lookup,
	xtensa_format_decode, xtensa_format_encode, xtensa_format_length,
	xtensa_format_num_slots, xtensa_format_slot_nop_opcode,
	xtensa_format_get_slot, xtensa_format_set_slot): New functions.
	(xtensa_opcode_lookup): Add error handling.
	(xtensa_decode_insn): Replace with ...
	(xtensa_opcode_decode): ... this function, with new format and
	slot parameters.  Add error handling.
	(xtensa_encode_insn): Replace with ...
	(xtensa_opcode_encode): ... this function, which does the encoding via
	one of the entries in the "encode_fns" array.  Add error handling.
	(xtensa_opcode_name): Add error handling.
	(xtensa_opcode_is_branch, xtensa_opcode_is_jump, xtensa_opcode_is_loop,
	xtensa_opcode_is_call): New.
	(xtensa_num_operands): Replace with ...
	(xtensa_opcode_num_operands): ... this function.  Add error handling.
	(xtensa_opcode_num_stateOperands,
	xtensa_opcode_num_interfaceOperands, xtensa_opcode_num_funcUnit_uses,
	xtensa_opcode_funcUnit_use, xtensa_operand_name,
	xtensa_operand_is_visible): New.
	(xtensa_get_operand, xtensa_operand_kind): Delete.
	(xtensa_operand_inout): Add error handling and special-case for
	"sout" operands.
	(xtensa_operand_get_field, xtensa_operand_set_field): Rewritten to
	operate on one slot of an instruction.  Added error handling.
	(xtensa_operand_encode): Handle default operands with no encoding
	functions.  Check for success by comparing against decoded value.
	Add error handling.
	(xtensa_operand_decode): Handle default operands.  Return decoded value
	through argument pointer.  Add error handling.
	(xtensa_operand_is_register, xtensa_operand_regfile,
	xtensa_operand_num_regs, xtensa_operand_is_known_reg): New.
	(xtensa_operand_isPCRelative): Rename to ...
	(xtensa_operand_is_PCrelative): ... this.  Add error handling.
	(xtensa_operand_do_reloc, xtensa_operand_undo_reloc): Return value
	through argument pointer.  Add error handling.
	(xtensa_stateOperand_state, xtensa_stateOperand_inout,
	xtensa_interfaceOperand_interface, xtensa_regfile_lookup,
	xtensa_regfile_lookup_shortname, xtensa_regfile_name,
	xtensa_regfile_shortname, xtensa_regfile_view_parent,
	xtensa_regfile_num_bits, xtensa_regfile_num_entries,
	xtensa_state_lookup, xtensa_state_name, xtensa_state_num_bits,
	xtensa_state_is_exported, xtensa_sysreg_lookup,
	xtensa_sysreg_lookup_name, xtensa_sysreg_name, xtensa_sysreg_number,
	xtensa_sysreg_is_user, xtensa_interface_lookup, xtensa_interface_name,
	xtensa_interface_num_bits, xtensa_interface_inout,
	xtensa_interface_has_side_effect, xtensa_funcUnit_lookup,
	xtensa_funcUnit_name, xtensa_funcUnit_num_copies): New.
	* xtensa-modules.c: Rewrite to use new data structures.
	* reloc.c (BFD_RELOC_XTENSA_DIFF8, BFD_RELOC_XTENSA_DIFF16,
	BFD_RELOC_XTENSA_DIFF32, BFD_RELOC_XTENSA_SLOT0_OP,
	BFD_RELOC_XTENSA_SLOT1_OP, BFD_RELOC_XTENSA_SLOT2_OP,
	BFD_RELOC_XTENSA_SLOT3_OP, BFD_RELOC_XTENSA_SLOT4_OP,
	BFD_RELOC_XTENSA_SLOT5_OP, BFD_RELOC_XTENSA_SLOT6_OP,
	BFD_RELOC_XTENSA_SLOT7_OP, BFD_RELOC_XTENSA_SLOT8_OP,
	BFD_RELOC_XTENSA_SLOT9_OP, BFD_RELOC_XTENSA_SLOT10_OP,
	BFD_RELOC_XTENSA_SLOT11_OP, BFD_RELOC_XTENSA_SLOT12_OP,
	BFD_RELOC_XTENSA_SLOT13_OP, BFD_RELOC_XTENSA_SLOT14_OP,
	BFD_RELOC_XTENSA_SLOT0_ALT, BFD_RELOC_XTENSA_SLOT1_ALT,
	BFD_RELOC_XTENSA_SLOT2_ALT, BFD_RELOC_XTENSA_SLOT3_ALT,
	BFD_RELOC_XTENSA_SLOT4_ALT, BFD_RELOC_XTENSA_SLOT5_ALT,
	BFD_RELOC_XTENSA_SLOT6_ALT, BFD_RELOC_XTENSA_SLOT7_ALT,
	BFD_RELOC_XTENSA_SLOT8_ALT, BFD_RELOC_XTENSA_SLOT9_ALT,
	BFD_RELOC_XTENSA_SLOT10_ALT, BFD_RELOC_XTENSA_SLOT11_ALT,
	BFD_RELOC_XTENSA_SLOT12_ALT, BFD_RELOC_XTENSA_SLOT13_ALT,
	BFD_RELOC_XTENSA_SLOT14_ALT): Add new relocations.
	* Makefile.am (xtensa-isa.lo, xtensa-modules.lo): Update dependencies.
	* Makefile.in: Regenerate.
	* bfd-in2.h: Likewise.
	* libbfd.h: Likewise.

gas ChangeLog

	* config/tc-xtensa.c (absolute_literals_supported): New global flag.
	(UNREACHABLE_MAX_WIDTH): Define.
	(XTENSA_FETCH_WIDTH): Delete.
	(cur_vinsn, xtensa_fetch_width, xt_saved_debug_type, past_xtensa_end,
	prefer_const16, prefer_l32r): New global variables.
	(LIT4_SECTION_NAME): Define.
	(lit4_state struct): Add lit4_seg_name and lit4_seg fields.
	(XTENSA_PROP_*, GET_XTENSA_PROP_*, SET_XTENSA_PROP_*): Define.
	(frag_flags struct): New.
	(xtensa_block_info struct): Move from tc-xtensa.h.  Add flags field.
	(subseg_map struct): Add cur_total_freq and cur_target_freq fields.
	(bitfield, bit_is_set, set_bit, clear_bit): Define.
	(MAX_FORMATS): Define.
	(op_placement_info struct, op_placement_table): New.
	(O_pltrel, O_hi16, O_lo16): Define.
	(directiveE enum): Rename directive_generics to directive_transform.
	Delete directive_relax.  Add directive_schedule,
	directive_absolute_literals, and directive_last_directive.
	(directive_info): Rename "generics" to "transform".  Delete "relax".
	Add "schedule" and "absolute-literals".
	(directive_state): Adjust entries to match changes in directive_info.
	(xtensa_relax_statesE, RELAX_IMMED_MAXSTEPS): Move to tc-xtensa.h.
	(xtensa_const16_opcode, xtensa_movi_opcode, xtensa_movi_n_opcode,
	xtensa_l32r_opcode, xtensa_nop_opcode, xtensa_rsr_lcount_opcode): New.
	(xtensa_j_opcode, xtensa_rsr_opcode): Delete.
	(align_only_targets, software_a0_b_retw_interlock,
	software_avoid_b_j_loop_end, maybe_has_b_j_loop_end,
	software_avoid_short_loop, software_avoid_close_loop_end,
	software_avoid_all_short_loops, specific_opcode): Delete.
	(warn_unaligned_branch_targets): New.
	(workaround_a0_b_retw, workaround_b_j_loop_end, workaround_short_loop,
	workaround_close_loop_end, workaround_all_short_loops): Default FALSE.
	(option_[no_]link_relax, option_[no_]transform,
	option_[no_]absolute_literals, option_warn_unaligned_targets,
	option_prefer_l32r, option_prefer_const16, option_target_hardware):
	New enum values.
	(option_[no_]align_only_targets, option_literal_section_name,
	option_text_section_name, option_data_section_name,
	option_bss_section_name, option_eb, option_el): Delete.
	(md_longopts): Add entries for: [no-]transform, [no-]absolute-literals,
	warn-unaligned-targets, prefer-l32r, prefer-const16, [no-]link-relax,
	and target-hardware.  Delete entries for [no-]target-align-only,
	literal-section-name, text-section-name, data-section-name, and
	bss-section-name.
	(md_parse_option): Handle new options and remove old ones.  Accept but
	ignore [no-]density options.  Warn for [no-]generics and [no-]relax
	and treat them as [no-]transform.
	(md_show_usage): Add new options and remove old ones.
	(xtensa_setup_hw_workarounds): New.
	(md_pseudo_table): Change "word" entry to use xtensa_elf_cons.  Add
	"long", "short", "loc" and "frequency" entries.
	(use_generics): Rename to ...
	(use_transform): ... this function.  Add past_xtensa_end check.
	(use_longcalls): Add past_xtensa_end check.
	(code_density_available, can_relax): Delete.
	(do_align_targets): New.
	(get_directive): Accept dashes in directive names.  Warn about
	[no-]generics and [no-]relax directives and treat them as
	[no-]transform.
	(xtensa_begin_directive): Call md_flush_pending_output only for some
	directives.  Check for directives inside instruction bundles.  Warn
	about deprecated ".begin literal" usage.  Warn and ignore [no-]density
	directives.  Handle new directives.  Check generating_literals flag
	for literal_prefix.
	(xtensa_end_directive): Check for directives inside instruction
	bundles.  Warn and ignore [no-]density directives.  Handle new
	directives.  Call xtensa_set_frag_assembly_state.
	(xtensa_loc_directive_seen, xtensa_dwarf2_directive_loc,
	xtensa_dwarf2_emit_insn): New.
	(xtensa_literal_position): Call md_flush_pending_output.  Do not check
	use_literal_section flag.
	(xtensa_literal_pseudo): Call md_flush_pending_output.  Handle absolute
	literals.  Use xtensa_elf_cons to parse the expression.
	(xtensa_literal_prefix): Do not check use_literal_section.  Support
	".lit4" sections for absolute literals.  Change prefix convention to
	replace ".text" (or ".t" in a linkonce section).  No need to call
	subseg_set.
	(xtensa_frequency_pseudo, xtensa_elf_cons, xtensa_elf_suffix): New.
	(expression_end): Handle closing braces and colons.
	(PLT_SUFFIX, plt_suffix): Delete.
	(expression_maybe_register): Use new xtensa-isa.h functions.  Use
	xtensa_elf_suffix instead of checking for plt suffix, and handle O_lo16
	and O_hi16 expressions as well.
	(tokenize_arguments): Handle closing braces and colons.
	(parse_arguments): Use new xtensa-isa.h functions.  Handle "invisible"
	operands and paired register syntax.
	(get_invisible_operands): New.
	(xg_translate_sysreg_op): Handle new Xtensa LX RSR/WSR/XSR syntax.  Use
	new xtensa-isa.h functions.
	(xtensa_translate_old_userreg_ops, xtensa_translate_zero_immed): New.
	(xg_translate_idioms): Check if inside bundle.  Use use_transform.
	Handle new Xtensa LX RSR/WSR/XSR syntax.  Remove code to widen density
	instructions.  Use xtensa_translate_zero_immed.
	(operand_is_immed, operand_is_pcrel_label): Delete.
	(get_relaxable_immed): Use new xtensa-isa.h functions.
	(get_opcode_from_buf): Add slot parameter.  Use new xtensa-isa.h
	functions.
	(xtensa_print_insn_table, print_vliw_insn): New.
	(is_direct_call_opcode): Use new xtensa-isa.h functions.
	(is_call_opcode, is_loop_opcode, is_conditional_branch_opcode,
	is_branch_or_jump_opcode): Delete.
	(is_movi_opcode, decode_reloc, encode_reloc, encode_alt_reloc): New.
	(opnum_to_reloc, reloc_to_opnum): Delete.
	(xtensa_insnbuf_set_operand, xtensa_insnbuf_get_operand): Use new
	xtensa-isa.h functions.  Operate on one slot of an instruction.
	(xtensa_insnbuf_set_immediate_field, is_negatable_branch,
	xg_get_insn_size): Delete.
	(xg_get_build_instr_size): Use xg_get_single_size.
	(xg_is_narrow_insn, xg_is_single_relaxable_insn): Update calls to
	xg_build_widen_table.  Use xg_get_single_size.
	(xg_get_max_narrow_insn_size): Delete.
	(xg_get_max_insn_widen_size, xg_get_max_insn_widen_literal_size,
	xg_is_relaxable_insn): Update calls to xg_build_widen_table.  Use
	xg_get_single_size.
	(xg_build_to_insn): Record the loc field.  Handle OP_OPERAND_HI16U and
	OP_OPERAND_LOW16U.  Check xg_valid_literal_expression.
	(xg_expand_to_stack, xg_expand_narrow): Update calls to
	xg_build_widen_table.  Use xg_get_single_size.
	(xg_immeds_fit): Use new xtensa-isa.h functions.  Update call to
	xg_check_operand.
	(xg_symbolic_immeds_fit): Likewise.  Also handle O_lo16 and O_hi16, and
	treat weak symbols conservatively.
	(xg_check_operand): Use new xtensa-isa.h functions.
	(is_dnrange): Delete.
	(xg_assembly_relax): Inline previous calls to tinsn_copy.
	(xg_finish_frag): Specify separate relax states for the frag and slot0.
	(is_branch_jmp_to_next, xg_add_branch_and_loop_targets): Use new
	xtensa-isa.h functions.
	(xg_instruction_matches_option_term, xg_instruction_matches_or_options,
	xg_instruction_matches_options): New.
	(xg_instruction_matches_rule): Handle O_register expressions.  Call
	xg_instruction_matches_options.
	(transition_rule_cmp): New.
	(xg_instruction_match): Update call to xg_build_simplify_table.
	(xg_build_token_insn): Record loc fields.
	(xg_simplify_insn): Check is_specific_opcode field and
	density_supported flag.
	(xg_expand_assembly_insn): Skip checking code_density_available.  Use
	new xtensa-isa.h functions.  Call use_transform instead of can_relax.
	(xg_assemble_literal): Add error handling for O_big.  Call
	record_alignment.  Handle O_pltrel.
	(xg_valid_literal_expression): New.
	(xg_assemble_literal_space): Add slot parameter.  Remove call to
	set_expr_symbol_offset.  Add call to record_alignment.  Update call to
	xg_finish_frag.
	(xg_emit_insn): Delete.
	(xg_emit_insn_to_buf): Add format parameter.  Update calls to
	xg_add_opcode_fix and xtensa_insnbuf_to_chars.
	(xg_add_opcode_fix): Change opcode parameter to tinsn and add format
	and slot parameters.  Handle new "alternate" relocations for absolute
	literals and CONST16 instructions.  Check for bad uses of O_lo16 and
	O_hi16.  Use new xtensa-isa.h functions.
	(xg_assemble_tokens): Delete.
	(is_register_writer): Use new xtensa-isa.h functions.
	(is_bad_loopend_opcode): Check for xtensa_rsr_lcount_opcode instead of
	old-style RSR from LCOUNT.
	(next_frag_opcode): Delete.
	(next_frag_opcode_is_loop, next_frag_format_size, frag_format_size,
	update_next_frag_state): New.
	(update_next_frag_nop_state): Delete.
	(next_frag_pre_opcode_bytes): Use next_frag_opcode_is_loop.
	(xtensa_mark_literal_pool_location): Check use_literal_section flag and
	the state of the absolute-literals directive.  Add calls to
	record_alignment and xtensa_set_frag_assembly_state.  Call
	xtensa_switch_to_non_abs_literal_fragment instead of
	xtensa_switch_to_literal_fragment.
	(build_nop): New.
	(assemble_nop): Use build_nop.  Update call to xtensa_insnbuf_to_chars.
	(get_expanded_loop_offset): Change check for undefined opcode to an
	assertion.
	(xtensa_set_frag_assembly_state, relaxable_section,
	xtensa_find_unmarked_state_frags, xtensa_find_unaligned_branch_targets,
	xtensa_find_unaligned_loops, xg_apply_tentative_value): New.
	(md_begin): Update call to xtensa_isa_init.  Initialize linkrelax to 1.
	Set lit4_seg_name.  Call xg_init_vinsn.  Initialize new global opcodes.
	Call init_op_placement_info_table and xtensa_set_frag_assembly_state.
	(xtensa_init_fix_data): New.
	(xtensa_frob_label): Reset label symbol to the current frag.  Check
	do_align_targets and generating_literals flag.  Propagate frequency
	info to new alignment frag.  Call xtensa_set_frag_assembly_state.
	(xtensa_unrecognized_line): New.
	(xtensa_flush_pending_output): Check if inside a bundle.  Add a call
	to xtensa_set_frag_assembly_state.
	(error_reset_cur_vinsn): New.
	(md_assemble): Remove check for literal frag.  Remove call to
	istack_init.  Call use_transform instead of use_generics.  Parse
	explicit instruction format specifiers.  Move code for
	a0_b_retw_interlock workaround to xg_assemble_vliw_tokens.  Call
	error_reset_cur_vinsn on errors.  Add call to get_invisible_operands.
	Add dwarf2_where call.  Remote automatic alignment for ENTRY
	instructions.  Move call to xtensa_clear_insn_labels to the end.
	Rearrange to handle bundles.
	(xtensa_cons_fix_new): Delete.
	(xtensa_handle_align): New.
	(xtensa_frag_init): Call xtensa_set_frag_assembly_state.  Remove
	assignment to is_no_density field.
	(md_pcrel_from): Use new xtensa-isa.h functions.  Use decode_reloc
	instead of reloc_to_opnum.  Handle "alternate" relocations.
	(xtensa_force_relocation, xtensa_check_inside_bundle,
	xtensa_elf_section_change_hook): New.
	(xtensa_symbol_new_hook): Delete.
	(xtensa_fix_adjustable): Check for difference of symbols with an
	offset.  Check for external and weak symbols.
	(md_apply_fix3): Remove cases for XTENSA_OP{0,1,2} relocs.
	(md_estimate_size_before_relax): Return expansion for the first slot.
	(tc_gen_reloc): Handle difference of symbols by producing
	XTENSA_DIFF{8,16,32} relocs and by writing the value of the difference
	into the output.  Handle new XTENSA_SLOT*_OP relocs by storing the
	tentative values into the output when linkrelax is set.
	(XTENSA_PROP_SEC_NAME): Define.
	(xtensa_post_relax_hook): Call xtensa_find_unmarked_state_frags.
	Create literal tables only if using literal sections.  Create new
	property tables instead of old instruction tables.  Check for unaligned
	branch targets and loops.
	(finish_vinsn, find_vinsn_conflicts, check_t1_t2_reads_and_writes,
	new_resource_table, clear_resource_table, resize_resource_table,
	resources_available, reserve_resources, release_resources,
	opcode_funcUnit_use_unit, opcode_funcUnit_use_stage,
	resources_conflict, xg_find_narrowest_format, relaxation_requirements,
	bundle_single_op, emit_single_op, xg_assemble_vliw_tokens): New.
	(xtensa_end): Call xtensa_flush_pending_output.  Set past_xtensa_end
	flag.  Update checks for workaround options.  Call
	xtensa_mark_narrow_branches and xtensa_mark_zcl_first_insns.
	(xtensa_cleanup_align_frags): Add special case for branch targets.
	Check for and mark unreachable frags.
	(xtensa_fix_target_frags): Remove use of align_only_targets flag.
	Use RELAX_LOOP_END_BYTES in special case for negatable branch at the
	end of a zero-overhead loop body.
	(frag_can_negate_branch): Handle instructions with multiple slots.
	Use new xtensa-isa.h functions
	(xtensa_mark_narrow_branches, is_narrow_branch_guaranteed_in_range,
	xtensa_mark_zcl_first_insns): New.
	(xtensa_fix_a0_b_retw_frags, xtensa_fix_b_j_loop_end_frags): Error if
	transformations are disabled.
	(next_instrs_are_b_retw): Use new xtensa-isa.h functions.  Handle
	multislot instructions.
	(xtensa_fix_close_loop_end_frags, xtensa_fix_short_loop_frags):
	Likewise.  Also error if transformations are disabled.
	(unrelaxed_frag_max_size): New.
	(unrelaxed_frag_min_insn_count, unrelax_frag_has_b_j): Use new
	xtensa-isa.h functions.
	(xtensa_sanity_check, is_empty_loop, is_local_forward_loop): Use
	xtensa_opcode_is_loop instead of is_loop_opcode.
	(get_text_align_power): Replace as_fatal with assertion.
	(get_text_align_fill_size): Iterate instead of using modulus when
	use_nops is false.
	(get_noop_aligned_address): Assert that this is for a machine-dependent
	RELAX_ALIGN_NEXT_OPCODE frag.  Use next_frag_opcode_is_loop,
	xg_get_single_size, and frag_format_size.
	(get_widen_aligned_address): Rename to ...
	(get_aligned_diff): ... this function.  Add max_diff parameter.
	Remove handling of rs_align/rs_align_code frags.  Use
	next_frag_format_size, get_text_align_power, get_text_align_fill_size,
	next_frag_opcode_is_loop, and xg_get_single_size.  Compute max_diff
	and pass it back to caller.
	(xtensa_relax_frag): Use relax_frag_loop_align.  Add code for new
	RELAX_SLOTS, RELAX_MAYBE_UNREACHABLE, RELAX_MAYBE_DESIRE_ALIGN,
	RELAX_FILL_NOP, and RELAX_UNREACHABLE frag types.  Check relax_seen.
	(relax_frag_text_align): Rename to ...
	(relax_frag_loop_align): ... this function.  Assume loops can only be
	in the first slot of an instruction.
	(relax_frag_add_nop): Use assemble_nop instead of constructing an OR
	instruction.  Remove call to frag_wane.
	(relax_frag_narrow): Rename to ...
	(relax_frag_for_align): ... this function.  Extend to handle
	RELAX_FILL_NOP and RELAX_UNREACHABLE, as well as RELAX_SLOTS with
	RELAX_NARROW for the first slot.
	(find_address_of_next_align_frag, bytes_to_stretch): New.
	(future_alignment_required): Use find_address_of_next_align_frag and
	bytes_to_stretch.  Look ahead to subsequent frags to make smarter
	alignment decisions.
	(relax_frag_immed): Add format, slot, and estimate_only parameters.
	Check if transformations are enabled for b_j_loop_end workaround.
	Use new xtensa-isa.h functions and handle multislot instructions.
	Update call to xg_assembly_relax.
	(md_convert_frag): Handle new RELAX_SLOTS, RELAX_UNREACHABLE,
	RELAX_MAYBE_UNREACHABLE, RELAX_MAYBE_DESIRE_ALIGN, and RELAX_FILL_NOP
	frag types.
	(convert_frag_narrow): Add segP, format and slot parameters.  Call
	convert_frag_immed for branch instructions.  Adjust calls to
	tinsn_from_chars, tinsn_immed_from_frag, and xg_emit_insn_to_buf.  Use
	xg_get_single_size and xg_get_single_format.
	(convert_frag_fill_nop): New.
	(convert_frag_immed): Add format and slot parameters.  Handle multislot
	instructions and use new xtensa-isa.h functions.  Update calls to
	tinsn_immed_from_frag and xg_assembly_relax.  Check if transformations
	enabled for b_j_loop_end workaround.  Use build_nop instead of
	assemble_nop.  Check is_specific_opcode flag.  Check for unreachable
	frags.  Use xg_get_single_size.  Handle O_pltrel.
	(fix_new_exp_in_seg): Remove check for old plt flag.
	(convert_frag_immed_finish_loop): Update calls to tinsn_from_chars and
	xtensa_insnbuf_to_chars.  Call tinsn_immed_from_frag.  Change check
	for loop opcode to an assertion.  Mark all frags up to the end of the
	loop as not transformable.
	(get_last_insn_flags, set_last_insn_flags): Use get_subseg_info.
	(get_subseg_info): New.
	(xtensa_move_literals): Call xtensa_set_frag_assembly_state.  Add null
	check for dest_seg.
	(xtensa_switch_to_literal_fragment): Rewrite to handle absolute
	literals and use xtensa_switch_to_non_abs_literal_fragment otherwise.
	(xtensa_switch_to_non_abs_literal_fragment): New.
	(cache_literal_section): Add is_code parameter and pass it through to
	retrieve_literal_seg.
	(retrieve_literal_seg): Add is_code parameter and use it to set the
	flags on the literal section.  Handle case where head parameter is 0.
	(get_frag_is_no_transform, set_frag_is_specific_opcode,
	set_frag_is_no_transform): New.
	(xtensa_create_property_segments): Add end_property_function parameter
	and pass it through to add_xt_block_frags.  Call bfd_get_section_flags
	and skip SEC_DEBUGGING and !SEC_ALLOC sections.
	(xtensa_create_xproperty_segments, section_has_xproperty): New.
	(add_xt_block_frags): Add end_property_function parameter and call it
	if it is non-zero.  Call xtensa_frag_flags_init.
	(xtensa_frag_flags_is_empty, xtensa_frag_flags_init,
	get_frag_property_flags, frag_flags_to_number,
	xtensa_frag_flags_combinable, xt_block_aligned_size,
	xtensa_xt_block_combine, add_xt_prop_frags,
	init_op_placement_info_table, opcode_fits_format_slot,
	xg_get_single_size, xg_get_single_format): New.
	(istack_push): Inline call to tinsn_copy.
	(tinsn_copy): Delete.
	(tinsn_has_invalid_symbolic_operands): Handle O_hi16 and O_lo16 and
	CONST16 opcodes.  Handle O_big, O_illegal, and O_absent.
	(tinsn_has_complex_operands): Handle O_hi16 and O_lo16.
	(tinsn_to_insnbuf): Use xg_get_single_format and new xtensa-isa.h
	functions.  Handle invisible operands.
	(tinsn_to_slotbuf): New.
	(tinsn_check_arguments): Use new xtensa-isa.h functions.
	(tinsn_from_chars): Add slot parameter.  Rewrite using xg_init_vinsn,
	vinsn_from_chars, and xg_free_vinsn.
	(tinsn_from_insnbuf): New.
	(tinsn_immed_from_frag): Add slot parameter and handle multislot
	instructions.  Handle symbol differences.
	(get_num_stack_text_bytes): Use xg_get_single_size.
	(xg_init_vinsn, xg_clear_vinsn, vinsn_has_specific_opcodes,
	xg_free_vinsn, vinsn_to_insnbuf, vinsn_from_chars, expr_is_register,
	get_expr_register, set_expr_symbol_offset_diff): New.
	* config/tc-xtensa.h (MAX_SLOTS): Define.
	(xtensa_relax_statesE): Move from tc-xtensa.c. Add
	RELAX_CHECK_ALIGN_NEXT_OPCODE, RELAX_MAYBE_DESIRE_ALIGN, RELAX_SLOTS,
	RELAX_FILL_NOP, RELAX_UNREACHABLE, RELAX_MAYBE_UNREACHABLE, and
	RELAX_NONE types.
	(RELAX_IMMED_MAXSTEPS): Move from tc-xtensa.c.
	(xtensa_frag_type struct): Add is_assembly_state_set,
	use_absolute_literals, relax_seen, is_unreachable, is_specific_opcode,
	is_align, is_text_align, alignment, and is_first_loop_insn fields.
	Replace is_generics and is_relax fields by is_no_transform field.
	Delete is_text and is_longcalls fields.  Change text_expansion and
	literal_expansion to arrays of MAX_SLOTS entries.  Add arrays of
	per-slot information: literal_frags, slot_subtypes, slot_symbols,
	slot_sub_symbols, and slot_offsets.  Add fr_prev field.
	(xtensa_fix_data struct): New.
	(xtensa_symfield_type struct): Delete plt field.
	(xtensa_block_info struct): Move definition to tc-xtensa.h.  Add
	forward declaration here.
	(xt_section_type enum): Delete xt_insn_sec.  Add xt_prop_sec.
	(XTENSA_SECTION_RENAME): Undefine.
	(TC_FIX_TYPE, TC_INIT_FIX_DATA, TC_FORCE_RELOCATION, NO_PSEUDO_DOT,
	tc_unrecognized_line, md_do_align, md_elf_section_change_hook,
	HANDLE_ALIGN, TC_LINKRELAX_FIXUP, SUB_SEGMENT_ALIGN): Define.
	(TC_CONS_FIX_NEW, tc_symbol_new_hook): Delete.
	(unit_num_copies_func, opcode_num_units_func,
	opcode_funcUnit_use_unit_func, opcode_funcUnit_use_stage_func): New.
	(resource_table struct): New.
	* config/xtensa-istack.h (MAX_INSN_ARGS): Increase from 6 to 10.
	(TInsn struct): Add keep_wide, loc, fixup, record_fix, subtype,
	literal_space, symbol, sub_symbol, offset, and literal_frag fields.
	(tinsn_copy): Delete prototype.
	(vliw_insn struct): New.
	* config/xtensa-relax.c (insn_pattern_struct): Add options field.
	(widen_spec_list): Add option conditions for density and boolean
	instructions.  Add expansions using CONST16 and conditions for using
	CONST16 vs. L32R.  Use new Xtensa LX RSR/WSR syntax.  Add entries for
	predicted branches.
	(simplify_spec_list): Add option conditions for density instructions.
	Add entry for NOP instruction.
	(append_transition): Add cmp function pointer parameter and use it to
	insert the new entry in order.
	(operand_function_LOW16U, operand_function_HI16U): New.
	(xg_has_userdef_op_fn, xg_apply_userdef_op_fn): Handle
	OP_OPERAND_LOW16U and OP_OPERAND_HI16U.
	(enter_opname, split_string): Use xstrdup instead of strdup.
	(init_insn_pattern): Initialize new options field.
	(clear_req_or_option_list, clear_req_option_list,
	clone_req_or_option_list, clone_req_option_list, parse_option_cond):
	New.
	(parse_insn_pattern): Parse option conditions.
	(transition_applies): New.
	(build_transition): Use new xtensa-isa.h functions.  Fix incorrectly
	swapped last arguments in calls to append_constant_value_condition.
	Call clone_req_option_list.  Add warning about invalid opcode.
	Handle LOW16U and HI16U function names.
	(build_transition_table): Add cmp parameter and use it in calls to
	append_transition.  Use new xtensa-isa.h functions.  Check
	transition_applies before adding entries.
	(xg_build_widen_table, xg_build_simplify_table): Add cmp parameter and
	pass it through to build_transition_table.
	* config/xtensa-relax.h (ReqOrOptionList, ReqOrOption, ReqOptionList,
	ReqOption, transition_cmp_fn): New types.
	(OpType enum): Add OP_OPERAND_LOW16U and OP_OPERAND_HI16U.
	(transition_rule struct): Add options field.
	* doc/as.texinfo (Overview): Update Xtensa options.
	* doc/c-xtensa.texi (Xtensa Options): Delete --[no-]density,
	--[no-]relax, and --[no-]generics options.  Update descriptions of
	--text-section-literals and --[no-]longcalls.  Add
	--[no-]absolute-literals and --[no-]transform.
	(Xtensa Syntax): Add description of syntax for FLIX instructions.
	Remove use of "generic" and "specific" terminology for opcodes.
	(Xtensa Registers): Generalize the syntax description to include
	user-defined register files.
	(Xtensa Automatic Alignment): Update.
	(Xtensa Branch Relaxation): Mention limitation of unconditional jumps.
	(Xtensa Call Relaxation): Linker can now remove most of the overhead.
	(Xtensa Directives): Remove confusing rules about precedence.
	(Density Directive, Relax Directive): Delete.
	(Schedule Directive): New.
	(Generics Directive): Rename to ...
	(Transform Directive): ... this node.
	(Literal Directive): Update for absolute literals.  Missing
	literal_position directive is now an error.
	(Literal Position Directive): Update for absolute literals.
	(Freeregs Directive): Delete.
	(Absolute Literals Directive): New.
	(Frame Directive): Minor editing.
	* Makefile.am (DEPTC_xtensa_elf, DEPOBJ_xtensa_elf, DEP_xtensa_elf):
	Update dependencies.
	* Makefile.in: Regenerate.

gas/testsuite ChangeLog

	* gas/xtensa/all.exp: Adjust expected error message for j_too_far.
	Change entry_align test to expect an error.
	* gas/xtensa/entry_misalign2.s: Use no-transform instead of
	no-generics directives.

include ChangeLog

	* xtensa-config.h (XSHAL_USE_ABSOLUTE_LITERALS,
	XCHAL_HAVE_PREDICTED_BRANCHES, XCHAL_INST_FETCH_WIDTH): New.
	(XCHAL_EXTRA_SA_SIZE, XCHAL_EXTRA_SA_ALIGN): Delete.
	* xtensa-isa-internal.h (ISA_INTERFACE_VERSION): Delete.
	(config_sturct struct): Delete.
	(XTENSA_OPERAND_IS_REGISTER, XTENSA_OPERAND_IS_PCRELATIVE,
	XTENSA_OPERAND_IS_INVISIBLE, XTENSA_OPERAND_IS_UNKNOWN,
	XTENSA_OPCODE_IS_BRANCH, XTENSA_OPCODE_IS_JUMP,
	XTENSA_OPCODE_IS_LOOP, XTENSA_OPCODE_IS_CALL,
	XTENSA_STATE_IS_EXPORTED, XTENSA_INTERFACE_HAS_SIDE_EFFECT): Define.
	(xtensa_format_encode_fn, xtensa_get_slot_fn, xtensa_set_slot_fn): New.
	(xtensa_insn_decode_fn): Rename to ...
	(xtensa_opcode_decode_fn): ... this.
	(xtensa_immed_decode_fn, xtensa_immed_encode_fn, xtensa_do_reloc_fn,
	xtensa_undo_reloc_fn): Update.
	(xtensa_encoding_template_fn): Delete.
	(xtensa_opcode_encode_fn, xtensa_format_decode_fn,
	xtensa_length_decode_fn): New.
	(xtensa_format_internal, xtensa_slot_internal): New types.
	(xtensa_operand_internal): Delete operand_kind, inout, isPCRelative,
	get_field, and set_field fields.  Add name, field_id, regfile,
	num_regs, and flags fields.
	(xtensa_arg_internal): New type.
	(xtensa_iclass_internal): Change operands field to array of
	xtensa_arg_internal.  Add num_stateOperands, stateOperands,
	num_interfaceOperands, and interfaceOperands fields.
	(xtensa_opcode_internal): Delete length, template, and iclass fields.
	Add iclass_id, flags, encode_fns, num_funcUnit_uses, and funcUnit_uses.
	(opname_lookup_entry): Delete.
	(xtensa_regfile_internal, xtensa_interface_internal,
	xtensa_funcUnit_internal, xtensa_state_internal,
	xtensa_sysreg_internal, xtensa_lookup_entry): New.
	(xtensa_isa_internal): Replace opcode_table field with opcodes field.
	Change type of opname_lookup_table.  Delete num_modules,
	module_opcode_base, module_decode_fn, config, and has_density fields.
	Add num_formats, formats, format_decode_fn, length_decode_fn,
	num_slots, slots, num_fields, num_operands, operands, num_iclasses,
	iclasses, num_regfiles, regfiles, num_states, states,
	state_lookup_table, num_sysregs, sysregs, sysreg_lookup_table,
	max_sysreg_num, sysreg_table, num_interfaces, interfaces,
	interface_lookup_table, num_funcUnits, funcUnits and
	funcUnit_lookup_table fields.
	(xtensa_isa_module, xtensa_isa_modules): Delete.
	(xtensa_isa_name_compare): New prototype.
	(xtisa_errno, xtisa_error_msg): New.
	* xtensa-isa.h (XTENSA_ISA_VERSION): Define.
	(xtensa_isa): Change type.
	(xtensa_operand): Delete.
	(xtensa_format, xtensa_regfile, xtensa_state, xtensa_sysreg,
	xtensa_interface, xtensa_funcUnit, xtensa_isa_status,
	xtensa_funcUnit_use): New types.
	(libisa_module_specifier): Delete.
	(xtensa_isa_errno, xtensa_isa_error_msg): New prototypes.
	(xtensa_insnbuf_free, xtensa_insnbuf_to_chars,
	xtensa_insnbuf_from_chars): Update prototypes.
	(xtensa_load_isa, xtensa_extend_isa, xtensa_default_isa,
	xtensa_insn_maxlength, xtensa_num_opcodes, xtensa_decode_insn,
	xtensa_encode_insn, xtensa_insn_length,
	xtensa_insn_length_from_first_byte, xtensa_num_operands,
	xtensa_operand_kind, xtensa_encode_result,
	xtensa_operand_isPCRelative): Delete.
	(xtensa_isa_init, xtensa_operand_inout, xtensa_operand_get_field,
	xtensa_operand_set_field, xtensa_operand_encode,
	xtensa_operand_decode, xtensa_operand_do_reloc,
	xtensa_operand_undo_reloc): Update prototypes.
	(xtensa_isa_maxlength, xtensa_isa_length_from_chars,
	xtensa_isa_num_pipe_stages, xtensa_isa_num_formats,
	xtensa_isa_num_opcodes, xtensa_isa_num_regfiles, xtensa_isa_num_states,
	xtensa_isa_num_sysregs, xtensa_isa_num_interfaces,
	xtensa_isa_num_funcUnits, xtensa_format_name, xtensa_format_lookup,
	xtensa_format_decode, xtensa_format_encode, xtensa_format_length,
	xtensa_format_num_slots, xtensa_format_slot_nop_opcode,
	xtensa_format_get_slot, xtensa_format_set_slot, xtensa_opcode_decode,
	xtensa_opcode_encode, xtensa_opcode_is_branch, xtensa_opcode_is_jump,
	xtensa_opcode_is_loop, xtensa_opcode_is_call,
	xtensa_opcode_num_operands, xtensa_opcode_num_stateOperands,
	xtensa_opcode_num_interfaceOperands, xtensa_opcode_num_funcUnit_uses,
	xtensa_opcode_funcUnit_use, xtensa_operand_name,
	xtensa_operand_is_visible, xtensa_operand_is_register,
	xtensa_operand_regfile, xtensa_operand_num_regs,
	xtensa_operand_is_known_reg, xtensa_operand_is_PCrelative,
	xtensa_stateOperand_state, xtensa_stateOperand_inout,
	xtensa_interfaceOperand_interface, xtensa_regfile_lookup,
	xtensa_regfile_lookup_shortname, xtensa_regfile_name,
	xtensa_regfile_shortname, xtensa_regfile_view_parent,
	xtensa_regfile_num_bits, xtensa_regfile_num_entries,
	xtensa_state_lookup, xtensa_state_name, xtensa_state_num_bits,
	xtensa_state_is_exported, xtensa_sysreg_lookup,
	xtensa_sysreg_lookup_name, xtensa_sysreg_name, xtensa_sysreg_number,
	xtensa_sysreg_is_user, xtensa_interface_lookup, xtensa_interface_name,
	xtensa_interface_num_bits, xtensa_interface_inout,
	xtensa_interface_has_side_effect, xtensa_funcUnit_lookup,
	xtensa_funcUnit_name, xtensa_funcUnit_num_copies): New prototypes.
	* elf/xtensa.h (R_XTENSA_DIFF8, R_XTENSA_DIFF16, R_XTENSA_DIFF32,
	R_XTENSA_SLOT*_OP, R_XTENSA_SLOT*_ALT): New relocations.
	(XTENSA_PROP_SEC_NAME): Define.
	(property_table_entry): Add flags field.
	(XTENSA_PROP_*, GET_XTENSA_PROP_*, SET_XTENSA_PROP_*): Define.

ld ChangeLog

	* ld.texinfo (Xtensa): Describe new linker relaxation to optimize
	assembler-generated longcall sequences.  Describe new --size-opt
	option.
	* emulparams/elf32xtensa.sh (OTHER_SECTIONS): Add .xt.prop section.
	* emultempl/xtensaelf.em (remove_section,
	replace_insn_sec_with_prop_sec, replace_instruction_table_sections,
	elf_xtensa_after_open): New.
	(OPTION_OPT_SIZEOPT, OPTION_LITERAL_MOVEMENT,
	OPTION_NO_LITERAL_MOVEMENT): Define.
	(elf32xtensa_size_opt, elf32xtensa_no_literal_movement): New globals.
	(PARSE_AND_LIST_LONGOPTS): Add size-opt and [no-]literal-movement.
	(PARSE_AND_LIST_OPTIONS): Add --size-opt.
	(PARSE_AND_LIST_ARGS_CASES): Handle OPTION_OPT_SIZEOPT,
	OPTION_LITERAL_MOVEMENT, and OPTION_NO_LITERAL_MOVEMENT.
	(LDEMUL_AFTER_OPEN): Set to elf_xtensa_after_open.
	* scripttempl/elfxtensa.sc: Update with changes from elf.sc.
	* Makefile.am (eelf32xtensa.c): Update dependencies.
	* Makefile.in: Regenerate.

ld/testsuite ChangeLog

	* ld-xtensa/lcall1.s: Use .literal directive.
	* ld-xtensa/lcall2.s: Align function entry.
	* ld-xtensa/coalesce2.s: Likewise.

opcodes ChangeLog

	* xtensa-dis.c (state_names): Delete.
	(fetch_data): Use xtensa_isa_maxlength.
	(print_xtensa_operand): Replace operand parameter with opcode/operand
	pair.  Remove print_sr_name parameter.  Use new xtensa-isa.h functions.
	(print_insn_xtensa): Use new xtensa-isa.h functions.  Handle multislot
	instruction bundles.  Use xmalloc instead of malloc.
@
text
@a34 4
static void remove_section (bfd *, asection *);
static bfd_boolean replace_insn_sec_with_prop_sec (bfd *, const char *,
						   const char *, char **);
static void replace_instruction_table_sections (bfd *, asection *);
d81 2
a82 4
void
remove_section (abfd, os)
     bfd *abfd;
     asection *os;
d95 5
a99 7
bfd_boolean
replace_insn_sec_with_prop_sec (abfd, insn_sec_name, prop_sec_name,
				error_message)
     bfd *abfd;
     const char *insn_sec_name;
     const char *prop_sec_name;
     char **error_message;
d264 2
a265 4
void
replace_instruction_table_sections (abfd, sec)
     bfd *abfd;
     asection *sec;
d438 1
a438 2
static void xtensa_ldlang_clear_addresses
  (lang_statement_union_type *);
d447 1
a447 2
static size_t ld_count_children
  (lang_statement_union_type *);
d625 1
d852 1
a852 2
iter_stack_copy_current (xtensa_ld_iter_stack **stack_p,
			 xtensa_ld_iter *front)
d1018 1
a1018 3
deps_has_sec_edge (const reloc_deps_graph *deps,
		   asection *src,
		   asection *tgt)
d1060 1
a1060 3
add_deps_edge (reloc_deps_graph *deps,
	       asection *src_sec,
	       asection *tgt_sec)
d1282 1
a1282 2
xtensa_layout_wild (const reloc_deps_graph *deps,
		    lang_wild_statement_type *w)
@


1.4
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d28 4
d35 4
d48 1
a48 1
   xtensa_use_literal_pages to "true".  */
d85 260
d714 1
a714 1
   false if the list is empty.  */
d1714 1
a1714 1
# Define some shell vars to insert bits of code into the standard elf
d1718 6
a1723 1
#define OPTION_NO_RELAX			301
d1727 1
d1729 2
d1734 1
d1739 3
d1745 6
d1756 1
@


1.3
log
@	* emultempl/aix.em: Convert to C90, remove unnecessary prototypes
	and casts.  Replace PTR with void *.  Formatting.
	* emultempl/alphaelf.em: Likewise
	* emultempl/armcoff.em: Likewise
	* emultempl/armelf.em: Likewise
	* emultempl/armelf_oabi.em: Likewise
	* emultempl/beos.em: Likewise
	* emultempl/elf32.em: Likewise
	* emultempl/generic.em: Likewise
	* emultempl/gld960.em: Likewise
	* emultempl/gld960c.em: Likewise
	* emultempl/hppaelf.em: Likewise
	* emultempl/linux.em: Likewise
	* emultempl/lnk960.em: Likewise
	* emultempl/m68hc1xelf.em: Likewise
	* emultempl/m68kcoff.em: Likewise
	* emultempl/m68kelf.em: Likewise
	* emultempl/mipsecoff.em: Likewise
	* emultempl/mipself.em: Likewise
	* emultempl/mmix-elfnmmo.em: Likewise
	* emultempl/mmixelf.em: Likewise
	* emultempl/mmo.em: Likewise
	* emultempl/needrelax.em: Likewise
	* emultempl/netbsd.em: Likewise
	* emultempl/pe.em: Likewise
	* emultempl/sh64elf.em: Likewise
	* emultempl/sunos.em: Likewise
	* emultempl/ticoff.em: Likewise
	* emultempl/vanilla.em: Likewise
	* emultempl/xtensaelf.em: Likewise
	* Makefile.am: Correct dependencies.
	* Makefile.in: Regenerate.
@
text
@d2 1
a2 1
#   Copyright 2003
d1255 1
a1255 1
		if (section->_raw_size != 0
d1263 1
a1263 1
		if (section->_raw_size != 0)
d1272 1
a1272 1
	    dot += section->_raw_size;
d1339 1
a1339 1
		    align_power (e->src->output_offset + e->src->_raw_size, 2);
d1389 1
a1389 1
		if (section->_raw_size != 0
d1397 1
a1397 1
		if (section->_raw_size != 0)
@


1.2
log
@Correct spelling of "relocatable".
@
text
@d29 2
a30 16
static char *elf_xtensa_choose_target
  PARAMS ((int, char **));
static bfd_boolean elf_xtensa_place_orphan
  PARAMS ((lang_input_statement_type *, asection *));
static void elf_xtensa_before_parse
  PARAMS ((void));
static void elf_xtensa_before_allocation
  PARAMS ((void));
static void xtensa_wild_group_interleave
  PARAMS ((lang_statement_union_type *));
static void xtensa_wild_group_interleave_callback
  PARAMS ((lang_statement_union_type *));
static void xtensa_colocate_output_literals
  PARAMS ((lang_statement_union_type *));
static void xtensa_colocate_output_literals_callback
  PARAMS ((lang_statement_union_type *));
d47 2
a48 3
elf_xtensa_choose_target (argc, argv)
     int argc ATTRIBUTE_UNUSED;
     char **argv ATTRIBUTE_UNUSED;
d58 1
a58 3
elf_xtensa_place_orphan (file, s)
     lang_input_statement_type *file;
     asection *s;
d69 1
a69 1
elf_xtensa_before_parse ()
d80 2
a81 2
void
elf_xtensa_before_allocation ()
d129 1
a129 1
  if (command_line.relax) 
d170 1
a170 1
  PARAMS ((const reloc_deps_graph *, lang_wild_statement_type *));
d172 5
a176 6
typedef void (*deps_callback_t)
  PARAMS ((asection *, /* src_sec */
	   bfd_vma,    /* src_offset */
	   asection *, /* target_sec */
	   bfd_vma,    /* target_offset */
	   PTR));      /* closure */
a177 2
static void build_deps_graph_callback
  PARAMS ((asection *, bfd_vma, asection *, bfd_vma, PTR));
d179 1
a179 2
  PARAMS ((bfd *, asection *, struct bfd_link_info *,
	   deps_callback_t, PTR));
d181 1
a181 1
  PARAMS ((lang_statement_union_type *));
d183 1
a183 1
  PARAMS ((lang_statement_union_type *, const reloc_deps_graph *));
d185 2
a186 2
  PARAMS ((bfd_vma, lang_statement_union_type *,
	   const reloc_deps_graph *, bfd_boolean)); 
d188 1
a188 22
  PARAMS ((bfd_vma, lang_statement_union_type *, reloc_deps_graph *,
	   bfd_boolean));
static void lang_for_each_statement_worker
  PARAMS ((void (*) (lang_statement_union_type *),
	   lang_statement_union_type *));
static void xtensa_move_dependencies_to_front
  PARAMS ((reloc_deps_graph *, lang_wild_statement_type *));
static reloc_deps_graph *ld_build_required_section_dependence
  PARAMS ((lang_statement_union_type *));
static bfd_boolean section_is_source
  PARAMS ((const reloc_deps_graph *, lang_statement_union_type *));
static bfd_boolean section_is_target
  PARAMS ((const reloc_deps_graph *, lang_statement_union_type *));
static bfd_boolean section_is_source_or_target
  PARAMS ((const reloc_deps_graph *, lang_statement_union_type *));
static bfd_boolean deps_has_sec_edge
  PARAMS ((const reloc_deps_graph *, asection *, asection *));
static bfd_boolean deps_has_edge
  PARAMS ((const reloc_deps_graph *, lang_statement_union_type *,
	   lang_statement_union_type *));
static void add_deps_edge
  PARAMS ((reloc_deps_graph *, asection *, asection *));
d191 1
a191 1
  PARAMS ((lang_statement_union_type *));
a192 10
static void free_reloc_deps_graph
  PARAMS ((reloc_deps_graph *));
static void xtensa_colocate_literals
  PARAMS ((reloc_deps_graph *, lang_statement_union_type *));
static reloc_deps_section *xtensa_get_section_deps
  PARAMS ((const reloc_deps_graph *, asection *));
static void xtensa_set_section_deps
  PARAMS ((const reloc_deps_graph *, asection *, reloc_deps_section *));
static void xtensa_append_section_deps
  PARAMS ((reloc_deps_graph *, asection *));
d201 2
a202 3
lang_for_each_statement_worker (func, s)
     void (*func) PARAMS ((lang_statement_union_type *));
     lang_statement_union_type *s;
d209 34
a242 34
        {
        case lang_constructors_statement_enum:
          lang_for_each_statement_worker (func, constructor_list.head);
          break;
        case lang_output_section_statement_enum:
          lang_for_each_statement_worker
            (func,
             s->output_section_statement.children.head);
          break;
        case lang_wild_statement_enum:
          lang_for_each_statement_worker
            (func,
             s->wild_statement.children.head);
          break;
        case lang_group_statement_enum:
          lang_for_each_statement_worker (func,
                                          s->group_statement.children.head);
          break;
        case lang_data_statement_enum:
        case lang_reloc_statement_enum:
        case lang_object_symbols_statement_enum:
        case lang_output_statement_enum:
        case lang_target_statement_enum:
        case lang_input_section_enum:
        case lang_input_statement_enum:
        case lang_assignment_statement_enum:
        case lang_padding_statement_enum:
        case lang_address_statement_enum:
        case lang_fill_statement_enum:
          break;
        default:
          FAIL ();
          break;
        }
d249 3
a251 4
reloc_deps_section *
xtensa_get_section_deps (deps, sec)
     const reloc_deps_graph *deps ATTRIBUTE_UNUSED;
     asection *sec;
d257 1
a257 1
  reloc_deps_section *sec_deps = (reloc_deps_section *) sec->userdata;
d261 4
a264 5
void
xtensa_set_section_deps (deps, sec, deps_section)
     const reloc_deps_graph *deps ATTRIBUTE_UNUSED;
     asection *sec;
     reloc_deps_section *deps_section;
d266 1
a266 1
  sec->userdata = (void *) deps_section;
d273 2
a274 4
static void 
xtensa_append_section_deps (deps, sec)
     reloc_deps_graph *deps;
     asection *sec;
d281 1
a281 1
      
d285 4
a288 4
      
      new_sections = (asection**) xmalloc (sizeof (asection*) * new_size);
      memset (new_sections, 0, sizeof (asection*) * new_size);
      for (i = 0; i < deps->count; i++) 
d302 2
a303 3
static void 
free_reloc_deps_graph (deps)
     reloc_deps_graph *deps;
d311 1
a311 1
      if (sec_deps) 
d320 1
a320 1
	  
d338 3
a340 4
bfd_boolean
section_is_source (deps, s)
     const reloc_deps_graph *deps ATTRIBUTE_UNUSED;
     lang_statement_union_type *s;
d350 1
a350 1
  return (sec_deps && sec_deps->succs != NULL);
d354 3
a356 4
bfd_boolean
section_is_target (deps, s)
     const reloc_deps_graph *deps ATTRIBUTE_UNUSED;
     lang_statement_union_type *s;
d366 1
a366 1
  return (sec_deps && sec_deps->preds != NULL);
d369 3
a371 4
bfd_boolean
section_is_source_or_target (deps, s)
     const reloc_deps_graph *deps ATTRIBUTE_UNUSED;
     lang_statement_union_type *s;
d391 1
a391 1
  
a395 2
static void ld_xtensa_move_section_after
  PARAMS ((xtensa_ld_iter *, xtensa_ld_iter *));
d397 2
a398 5

void 
ld_xtensa_move_section_after (to, current)
     xtensa_ld_iter *to;
     xtensa_ld_iter *current;
d411 1
a411 1
  
d419 1
a419 1
  
d421 1
a421 1
  
d439 1
a439 1
  ASSERT ((old_to_count + old_current_count) 
d448 2
a449 21
static bfd_boolean iter_stack_empty
  PARAMS ((xtensa_ld_iter_stack **));
static bfd_boolean iter_stack_push
  PARAMS ((xtensa_ld_iter_stack **, lang_statement_union_type *));
static void iter_stack_pop
  PARAMS ((xtensa_ld_iter_stack **));
static void iter_stack_update
  PARAMS ((xtensa_ld_iter_stack **));
static void iter_stack_next
  PARAMS ((xtensa_ld_iter_stack **));
static lang_statement_union_type *iter_stack_current
  PARAMS ((xtensa_ld_iter_stack **));
static void iter_stack_create
  PARAMS ((xtensa_ld_iter_stack **, lang_statement_union_type *));
static void iter_stack_copy_current
  PARAMS ((xtensa_ld_iter_stack **, xtensa_ld_iter *));


static bfd_boolean 
iter_stack_empty (stack_p)
     xtensa_ld_iter_stack **stack_p;
d451 1
a451 1
  return (*stack_p == NULL);
d456 2
a457 3
iter_stack_push (stack_p, parent)
     xtensa_ld_iter_stack **stack_p;
     lang_statement_union_type *parent;
d462 1
a462 1
  switch (parent->header.type) 
d479 1
a479 1
  if (l->tail == &l->head) 
d482 1
a482 1
  stack = (xtensa_ld_iter_stack *) xmalloc (sizeof (xtensa_ld_iter_stack));
d490 1
a490 1
  if (*stack_p != NULL) 
d497 2
a498 3
static void 
iter_stack_pop (stack_p)
     xtensa_ld_iter_stack **stack_p;
d504 1
a504 1
  if (stack == NULL) 
d510 1
a510 1
  if (stack->next != NULL) 
d523 1
a523 2
iter_stack_update (stack_p)
     xtensa_ld_iter_stack **stack_p;
d526 1
a526 1
      && (*(*stack_p)->iterloc.loc) == NULL) 
d541 2
a542 3
static void 
iter_stack_next (stack_p)
     xtensa_ld_iter_stack **stack_p;
d550 1
a550 1
  if (current != NULL) 
d552 1
a552 1
      switch (current->header.type) 
d578 1
a578 2
iter_stack_current (stack_p)
     xtensa_ld_iter_stack **stack_p;
d586 3
a588 4
static void 
iter_stack_create (stack_p, parent)
     xtensa_ld_iter_stack **stack_p;
     lang_statement_union_type *parent;
d594 3
a596 4
static void 
iter_stack_copy_current (stack_p, front)
     xtensa_ld_iter_stack **stack_p;
     xtensa_ld_iter *front;
d602 3
a604 4
void
xtensa_colocate_literals (deps, statement)
     reloc_deps_graph *deps;
     lang_statement_union_type *statement;
d629 1
a629 1
					     
d632 1
a632 1
  while (!iter_stack_empty (stack_p)) 
d636 2
a637 2
    
      switch (l->header.type) 
d650 1
a650 1
	      if (in_literals) 
d655 1
a655 1
	    } 
d672 1
a672 1
		  if (is_target) 
d676 1
a676 1
		      ld_assign_relative_paged_dot (0x100000, 
d680 1
a680 1
	  
d689 1
a689 1
		      else 
d711 1
a711 1
  
d716 3
a718 4
void
xtensa_move_dependencies_to_front (deps, w)
     reloc_deps_graph *deps;
     lang_wild_statement_type *w;
d734 1
a734 1
  while (*current != NULL) 
d762 3
a764 4
deps_has_sec_edge (deps, src, tgt)
     const reloc_deps_graph *deps;
     asection *src;
     asection *tgt;
d772 1
a772 1
  
d774 1
a774 1
       sec_deps_e != NULL; 
d778 1
a778 1
      if (sec_deps_e->tgt == tgt) 
d786 3
a788 4
deps_has_edge (deps, src, tgt)
     const reloc_deps_graph *deps;
     lang_statement_union_type *src;
     lang_statement_union_type *tgt;
d799 1
a799 1
  
d806 3
a808 4
add_deps_edge (deps, src_sec, tgt_sec)
     reloc_deps_graph *deps;
     asection *src_sec;
     asection *tgt_sec;
d818 1
a818 1
  
d823 1
a823 2
      src_sec_deps = (reloc_deps_section *)
	xmalloc (sizeof (reloc_deps_section));
d836 1
a836 2
      tgt_sec_deps = (reloc_deps_section *)
	xmalloc (sizeof (reloc_deps_section));
d846 1
a846 1
  src_edge = (reloc_deps_e *) xmalloc (sizeof (reloc_deps_e));
d853 1
a853 1
  tgt_edge = (reloc_deps_e *) xmalloc (sizeof (reloc_deps_e));
d862 6
a867 8
void 
build_deps_graph_callback (src_sec, src_offset, 
			  target_sec, target_offset, closure)
     asection *src_sec;
     bfd_vma src_offset ATTRIBUTE_UNUSED;
     asection *target_sec;
     bfd_vma target_offset ATTRIBUTE_UNUSED;
     PTR closure;
d869 1
a869 2
  reloc_deps_graph *deps;
  deps = (reloc_deps_graph*) closure;
d877 2
a878 3
reloc_deps_graph *
ld_build_required_section_dependence (s)
     lang_statement_union_type *s;
d883 1
a883 1
  deps = (reloc_deps_graph*) xmalloc (sizeof (reloc_deps_graph));
d887 1
a887 1
  
d890 1
a890 1
       iter_stack_next (&stack)) 
d903 1
a903 1
					       (PTR) deps);
d911 2
a912 3
size_t
ld_count_children (s)
     lang_statement_union_type *s;
d918 1
a918 1
       iter_stack_next (&stack)) 
d929 2
a930 3
void
xtensa_wild_group_interleave_callback (statement)
     lang_statement_union_type * statement;
d967 1
a967 1
	}	  
d970 1
a970 1
         *(.init) output sections and *(.fini) specs may NOT be reordered.  */
d973 1
a973 1
      if (!no_reorder) 
d993 1
a993 1
         section -> target section (kept as a list of edges).  */
d1022 2
a1023 3
void 
xtensa_wild_group_interleave (s)
     lang_statement_union_type *s; 
d1029 3
a1031 4
void 
xtensa_layout_wild (deps, w)
     const reloc_deps_graph *deps;
     lang_wild_statement_type *w;
d1041 1
a1041 1
  
d1063 1
a1063 1
	      && ! section_is_source (deps, l)) 
d1075 1
a1075 1
	    } 
d1083 1
a1083 1
  
d1086 1
a1086 1
  
d1101 1
a1101 1
      if (literal_wild.children.head == NULL) 
d1106 1
a1106 1
      for (s_p = &w->children.head; *s_p != NULL; s_p = &(*s_p)->header.next) 
d1118 1
a1118 1
      
d1134 2
a1135 3
void
xtensa_colocate_output_literals_callback (statement)
     lang_statement_union_type * statement;
d1166 1
a1166 1
         section -> target section (kept as a list of edges).  */
d1185 1
a1185 1
	  ld_xtensa_insert_page_offsets ((bfd_vma) 0, statement, deps,
d1197 2
a1198 3
void 
xtensa_colocate_output_literals (s)
     lang_statement_union_type *s; 
d1204 2
a1205 3
void
xtensa_ldlang_clear_addresses (statement)
     lang_statement_union_type * statement;
d1209 1
a1209 1
    case lang_input_section_enum: 
d1221 5
a1225 6
bfd_vma
ld_assign_relative_paged_dot (dot, s, deps, lit_align)
     bfd_vma dot;
     lang_statement_union_type *s;
     const reloc_deps_graph *deps ATTRIBUTE_UNUSED;
     bfd_boolean lit_align;
d1229 1
a1229 1
  
d1238 1
a1238 1
       iter_stack_next (stack_p)) 
d1241 2
a1242 2
    
      switch (l->header.type) 
d1249 1
a1249 1
	
d1263 1
a1263 1
		if (section->_raw_size != 0) 
d1289 3
a1291 4
bfd_boolean
ld_local_file_relocations_fit (statement, deps)
     lang_statement_union_type *statement;
     const reloc_deps_graph *deps ATTRIBUTE_UNUSED;
d1296 1
a1296 1
     2) (roundup(source + source_size, 4) - rounddown(target, 4)) 
d1299 1
a1299 1
  
d1310 1
a1310 1
       iter_stack_next (stack_p)) 
d1313 1
a1313 1
      if (l->header.type == lang_input_section_enum) 
d1326 1
a1326 1
      const reloc_deps_section *deps_section = 
d1333 1
a1333 1
	      if ((e->src != e->tgt)
d1338 1
a1338 1
		  bfd_vma l32r_addr = 
d1340 1
a1340 1
		  bfd_vma target_addr = e->tgt->output_offset & (~3);
d1348 1
a1348 1
		  if ((l32r_addr - target_addr) > (256*1024 - align_penalty)) 
d1359 5
a1363 6
bfd_vma
ld_xtensa_insert_page_offsets (dot, s, deps, lit_align)
     bfd_vma dot;
     lang_statement_union_type *s;
     reloc_deps_graph *deps;
     bfd_boolean lit_align;
d1370 1
a1370 1
  
d1376 1
a1376 1
       iter_stack_next (stack_p)) 
d1380 2
a1381 2
      switch (l->header.type) 
        {
d1386 1
a1386 1
        
d1397 1
a1397 1
		if (section->_raw_size != 0) 
d1417 1
a1417 1
		  
d1434 6
a1439 6
              }
          }
          break;
        default:
          break;
        }
@


1.1
log
@Add Xtensa port
@
text
@d78 1
a78 1
  if (link_info.relocateable)
d151 1
a151 1
     is a relocateable link then we need to add alignment notes so
@

