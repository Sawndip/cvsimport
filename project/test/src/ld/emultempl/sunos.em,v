head	1.35;
access;
symbols
	binutils-2_24-branch:1.35.0.2
	binutils-2_24-branchpoint:1.35
	binutils-2_21_1:1.31.10.1
	binutils-2_23_2:1.34
	binutils-2_23_1:1.34
	binutils-2_23:1.34
	binutils-2_23-branch:1.34.0.2
	binutils-2_23-branchpoint:1.34
	binutils-2_22_branch:1.33.0.4
	binutils-2_22:1.33
	binutils-2_22-branch:1.33.0.2
	binutils-2_22-branchpoint:1.33
	binutils-2_21:1.31
	binutils-2_21-branch:1.31.0.10
	binutils-2_21-branchpoint:1.31
	binutils-2_20_1:1.31
	binutils-2_20:1.31
	binutils-arc-20081103-branch:1.31.0.8
	binutils-arc-20081103-branchpoint:1.31
	binutils-2_20-branch:1.31.0.6
	binutils-2_20-branchpoint:1.31
	dje-cgen-play1-branch:1.31.0.4
	dje-cgen-play1-branchpoint:1.31
	arc-20081103-branch:1.31.0.2
	arc-20081103-branchpoint:1.31
	binutils-2_19_1:1.30.2.1
	binutils-2_19:1.30.2.1
	binutils-2_19-branch:1.30.0.2
	binutils-2_19-branchpoint:1.30
	binutils-2_18:1.29
	binutils-2_18-branch:1.29.0.2
	binutils-2_18-branchpoint:1.29
	binutils-csl-coldfire-4_1-32:1.25
	binutils-csl-sourcerygxx-4_1-32:1.25
	binutils-csl-innovasic-fido-3_4_4-33:1.25
	binutils-csl-sourcerygxx-3_4_4-32:1.20
	binutils-csl-coldfire-4_1-30:1.25
	binutils-csl-sourcerygxx-4_1-30:1.25
	binutils-csl-coldfire-4_1-28:1.25
	binutils-csl-sourcerygxx-4_1-29:1.25
	binutils-csl-sourcerygxx-4_1-28:1.25
	binutils-csl-arm-2006q3-27:1.25
	binutils-csl-sourcerygxx-4_1-27:1.25
	binutils-csl-arm-2006q3-26:1.25
	binutils-csl-sourcerygxx-4_1-26:1.25
	binutils-csl-sourcerygxx-4_1-25:1.25
	binutils-csl-sourcerygxx-4_1-24:1.25
	binutils-csl-sourcerygxx-4_1-23:1.25
	binutils-csl-sourcerygxx-4_1-21:1.25
	binutils-csl-arm-2006q3-21:1.25
	binutils-csl-sourcerygxx-4_1-22:1.25
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.25
	binutils-csl-sourcerygxx-4_1-20:1.25
	binutils-csl-arm-2006q3-19:1.25
	binutils-csl-sourcerygxx-4_1-19:1.25
	binutils-csl-sourcerygxx-4_1-18:1.25
	binutils-csl-renesas-4_1-9:1.25
	binutils-csl-sourcerygxx-3_4_4-25:1.20
	binutils-csl-renesas-4_1-8:1.25
	binutils-csl-renesas-4_1-7:1.25
	binutils-csl-renesas-4_1-6:1.25
	binutils-csl-sourcerygxx-4_1-17:1.25
	binutils-csl-sourcerygxx-4_1-14:1.25
	binutils-csl-sourcerygxx-4_1-15:1.25
	binutils-csl-sourcerygxx-4_1-13:1.25
	binutils-2_17:1.25
	binutils-csl-sourcerygxx-4_1-12:1.25
	binutils-csl-sourcerygxx-3_4_4-21:1.25
	binutils-csl-wrs-linux-3_4_4-24:1.20
	binutils-csl-wrs-linux-3_4_4-23:1.20
	binutils-csl-sourcerygxx-4_1-9:1.25
	binutils-csl-sourcerygxx-4_1-8:1.25
	binutils-csl-sourcerygxx-4_1-7:1.25
	binutils-csl-arm-2006q1-6:1.25
	binutils-csl-sourcerygxx-4_1-6:1.25
	binutils-csl-wrs-linux-3_4_4-22:1.20
	binutils-csl-coldfire-4_1-11:1.25
	binutils-csl-sourcerygxx-3_4_4-19:1.25
	binutils-csl-coldfire-4_1-10:1.25
	binutils-csl-sourcerygxx-4_1-5:1.25
	binutils-csl-sourcerygxx-4_1-4:1.25
	binutils-csl-wrs-linux-3_4_4-21:1.20
	binutils-csl-morpho-4_1-4:1.25
	binutils-csl-sourcerygxx-3_4_4-17:1.25
	binutils-csl-wrs-linux-3_4_4-20:1.20
	binutils-2_17-branch:1.25.0.4
	binutils-2_17-branchpoint:1.25
	binutils-csl-2_17-branch:1.25.0.2
	binutils-csl-2_17-branchpoint:1.25
	binutils-csl-gxxpro-3_4-branch:1.20.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.20
	binutils-2_16_1:1.20
	binutils-csl-arm-2005q1b:1.20
	binutils-2_16:1.20
	binutils-csl-arm-2005q1a:1.20
	binutils-csl-arm-2005q1-branch:1.20.0.4
	binutils-csl-arm-2005q1-branchpoint:1.20
	binutils-2_16-branch:1.20.0.2
	binutils-2_16-branchpoint:1.20
	csl-arm-2004-q3d:1.18
	csl-arm-2004-q3:1.18
	binutils-2_15:1.16
	binutils-2_15-branchpoint:1.16
	csl-arm-2004-q1a:1.16
	csl-arm-2004-q1:1.16
	binutils-2_15-branch:1.16.0.6
	cagney_bfdfile-20040213-branch:1.16.0.4
	cagney_bfdfile-20040213-branchpoint:1.16
	cagney_bigcore-20040122-branch:1.16.0.2
	cagney_bigcore-20040122-branchpoint:1.16
	csl-arm-2003-q4:1.15
	binutils-2_14:1.12
	binutils-2_14-branch:1.12.0.2
	binutils-2_14-branchpoint:1.12
	binutils-2_13_2_1:1.10
	binutils-2_13_2:1.10
	binutils-2_13_1:1.10
	binutils-2_13:1.10
	binutils-2_13-branchpoint:1.10
	binutils-2_13-branch:1.10.0.2
	binutils-2_12_1:1.9
	binutils-2_12:1.9
	binutils-2_12-branch:1.9.0.2
	binutils-2_12-branchpoint:1.9
	cygnus_cvs_20020108_pre:1.9
	binutils-2_11_2:1.6.2.1
	binutils-2_11_1:1.6.2.1
	binutils-2_11:1.6
	x86_64versiong3:1.6
	binutils-2_11-branch:1.6.0.2
	binutils-2_10_1:1.5
	binutils-2_10:1.5
	binutils-2_10-branch:1.5.0.2
	binutils-2_10-branchpoint:1.5
	binutils_latest_snapshot:1.35
	repo-unification-2000-02-06:1.4
	binu_ss_19990721:1.2
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@# @;


1.35
date	2013.04.04.14.38.47;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2012.03.05.22.43.40;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2010.12.20.13.00.14;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2010.12.06.00.07.06;	author hjl;	state Exp;
branches;
next	1.31;

1.31
date	2008.09.08.16.07.46;	author hjl;	state Exp;
branches
	1.31.10.1;
next	1.30;

1.30
date	2008.02.15.03.35.53;	author amodra;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2007.07.19.19.56.10;	author roland;	state Exp;
branches;
next	1.28;

1.28
date	2007.07.06.14.09.42;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	2007.04.26.14.46.59;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2006.09.16.18.12.16;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2005.08.04.06.22.13;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2005.08.04.01.19.10;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2005.07.15.12.19.14;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2005.05.12.07.32.04;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2005.05.04.11.00.28;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2005.03.03.11.52.04;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2005.02.23.12.30.48;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2004.09.17.07.14.33;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2004.06.24.04.46.28;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2004.01.03.11.09.07;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2003.12.02.23.00.00;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.27.00.38.25;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.25.06.40.27;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.28.01.32.31;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2002.11.30.08.39.46;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.22.09.02.05;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.19.05.33.35;	author hjl;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.25.05.39.22;	author hjl;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.13.06.14.27;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.11.03.42.41;	author amodra;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.02.29.05.53.53;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.22.23.22.18;	author amodra;	state Exp;
branches;
next	1.3;

1.3
date	99.08.06.22.46.03;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.06.20.14.12.08;	author rth;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.29.07;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.31.10.1
date	2011.02.01.12.25.47;	author amodra;	state Exp;
branches;
next	;

1.30.2.1
date	2008.09.09.00.10.16;	author amodra;	state Exp;
branches;
next	;

1.6.2.1
date	2001.06.07.03.17.16;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.07;	author rth;	state Exp;
branches;
next	;


desc
@@


1.35
log
@	* ldlang.c (load_symbols): Report "error adding symbols" on
	bfd_link_add_symbols failure.
	* emultempl/elf32.em (gld${EMULATION_NAME}_try_needed): Likewise.
	* emultempl/sunos.em (gld${EMULATION_NAME}_after_open): Likewise.
	(gld${EMULATION_NAME}_try_needed): Likewise.
@
text
@# This shell script emits a C file. -*- C -*-
# It does some substitutions.
if [ -z "$MACHINE" ]; then
  OUTPUT_ARCH=${ARCH}
else
  OUTPUT_ARCH=${ARCH}:${MACHINE}
fi
fragment <<EOF
/* This file is is generated by a shell script.  DO NOT EDIT! */

/* SunOS emulation code for ${EMULATION_NAME}
   Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002, 2003, 2004, 2005, 2006, 2007, 2008, 2012
   Free Software Foundation, Inc.
   Written by Steve Chamberlain <sac@@cygnus.com>
   SunOS shared library support by Ian Lance Taylor <ian@@cygnus.com>

   This file is part of the GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#define TARGET_IS_${EMULATION_NAME}

#include "sysdep.h"
#include "bfd.h"
#include "bfdlink.h"
#include "libiberty.h"
#include "safe-ctype.h"

#include "ld.h"
#include "ldmain.h"
#include "ldmisc.h"
#include "ldexp.h"
#include "ldlang.h"
#include "ldfile.h"
#include "ldemul.h"

#ifdef HAVE_DIRENT_H
# include <dirent.h>
#else
# define dirent direct
# ifdef HAVE_SYS_NDIR_H
#  include <sys/ndir.h>
# endif
# ifdef HAVE_SYS_DIR_H
#  include <sys/dir.h>
# endif
# ifdef HAVE_NDIR_H
#  include <ndir.h>
# endif
#endif

static void gld${EMULATION_NAME}_find_so
  (lang_input_statement_type *);
static char *gld${EMULATION_NAME}_search_dir
  (const char *, const char *, bfd_boolean *);
static void gld${EMULATION_NAME}_check_needed
  (lang_input_statement_type *);
static bfd_boolean gld${EMULATION_NAME}_search_needed
  (const char *, const char *);
static bfd_boolean gld${EMULATION_NAME}_try_needed
  (const char *, const char *);
static void gld${EMULATION_NAME}_find_assignment
  (lang_statement_union_type *);
static void gld${EMULATION_NAME}_find_exp_assignment
  (etree_type *);
static void gld${EMULATION_NAME}_count_need
  (lang_input_statement_type *);
static void gld${EMULATION_NAME}_set_need
  (lang_input_statement_type *);

static void
gld${EMULATION_NAME}_before_parse (void)
{
  ldfile_set_output_arch ("${OUTPUT_ARCH}", bfd_arch_`echo ${ARCH} | sed -e 's/:.*//'`);
  input_flags.dynamic = TRUE;
  config.has_shared = TRUE;
}

/* This is called after the command line arguments have been parsed,
   but before the linker script has been read.  If this is a native
   linker, we add the directories in LD_LIBRARY_PATH to the search
   list.  */

static void
gld${EMULATION_NAME}_set_symbols (void)
{
EOF
if [ "x${host}" = "x${target}" ] ; then
  case " ${EMULATION_LIBPATH} " in
  *" ${EMULATION_NAME} "*)
fragment <<EOF
  const char *env;

  env = (const char *) getenv ("LD_LIBRARY_PATH");
  if (env != NULL)
    {
      char *l;

      l = xstrdup (env);
      while (1)
	{
	  char *c;

	  c = strchr (l, ':');
	  if (c != NULL)
	    *c++ = '\0';
	  if (*l != '\0')
	    ldfile_add_library_path (l, FALSE);
	  if (c == NULL)
	    break;
	  l = c;
	}
    }
EOF
  ;;
  esac
fi
fragment <<EOF
}

/* Despite the name, we use this routine to search for dynamic
   libraries.  On SunOS this requires a directory search.  We need to
   find the .so file with the highest version number.  The user may
   restrict the major version by saying, e.g., -lc.1.  Also, if we
   find a .so file, we need to look for a the same file after
   replacing .so with .sa; if it exists, it will be an archive which
   provide some initializations for data symbols, and we need to
   search it after including the .so file.  */

static void
gld${EMULATION_NAME}_create_output_section_statements (void)
{
  lang_for_each_input_file (gld${EMULATION_NAME}_find_so);
}

/* Search the directory for a .so file for each library search.  */

static void
gld${EMULATION_NAME}_find_so (lang_input_statement_type *inp)
{
  search_dirs_type *search;
  char *found = NULL;
  char *alc;
  struct stat st;

  if (! inp->flags.search_dirs
      || ! inp->flags.maybe_archive
      || ! inp->flags.dynamic)
    return;

  ASSERT (CONST_STRNEQ (inp->local_sym_name, "-l"));

  for (search = search_head; search != NULL; search = search->next)
    {
      bfd_boolean found_static;

      found = gld${EMULATION_NAME}_search_dir (search->name, inp->filename,
					       &found_static);
      if (found != NULL || found_static)
	break;
    }

  if (found == NULL)
    {
      /* We did not find a matching .so file.  This isn't an error,
	 since there might still be a matching .a file, which will be
	 found by the usual search.  */
      return;
    }

  /* Replace the filename with the one we have found.  */
  alc = (char *) xmalloc (strlen (search->name) + strlen (found) + 2);
  sprintf (alc, "%s/%s", search->name, found);
  inp->filename = alc;

  /* Turn off the search_dirs_flag to prevent ldfile_open_file from
     searching for this file again.  */
  inp->flags.search_dirs = FALSE;

  free (found);

  /* Now look for the same file name, but with .sa instead of .so.  If
     found, add it to the list of input files.  */
  alc = (char *) xmalloc (strlen (inp->filename) + 1);
  strcpy (alc, inp->filename);
  strstr (alc + strlen (search->name), ".so")[2] = 'a';
  if (stat (alc, &st) != 0)
    free (alc);
  else
    {
      lang_input_statement_type *sa;

      /* Add the .sa file to the statement list just before the .so
	 file.  This is really a hack.  */
      sa = ((lang_input_statement_type *)
	    xmalloc (sizeof (lang_input_statement_type)));
      *sa = *inp;

      inp->filename = alc;
      inp->local_sym_name = alc;

      inp->header.next = (lang_statement_union_type *) sa;
      inp->next_real_file = (lang_statement_union_type *) sa;
    }
}

/* Search a directory for a .so file.  */

static char *
gld${EMULATION_NAME}_search_dir
  (const char *dirname, const char *filename, bfd_boolean *found_static)
{
  int force_maj, force_min;
  const char *dot;
  unsigned int len;
  char *alc;
  char *found;
  int max_maj, max_min;
  DIR *dir;
  struct dirent *entry;
  unsigned int dirnamelen;
  char *full_path;
  int statval;
  struct stat st;

  *found_static = FALSE;

  force_maj = -1;
  force_min = -1;
  dot = strchr (filename, '.');
  if (dot == NULL)
    {
      len = strlen (filename);
      alc = NULL;
    }
  else
    {
      force_maj = atoi (dot + 1);

      len = dot - filename;
      alc = (char *) xmalloc (len + 1);
      strncpy (alc, filename, len);
      alc[len] = '\0';
      filename = alc;

      dot = strchr (dot + 1, '.');
      if (dot != NULL)
	force_min = atoi (dot + 1);
    }

  found = NULL;
  max_maj = max_min = 0;

  dir = opendir (dirname);
  if (dir == NULL)
    return NULL;
  dirnamelen = strlen (dirname);

  while ((entry = readdir (dir)) != NULL)
    {
      const char *s;
      int found_maj, found_min;

      if (! CONST_STRNEQ (entry->d_name, "lib")
	  || strncmp (entry->d_name + 3, filename, len) != 0)
	continue;

      if (dot == NULL
	  && strcmp (entry->d_name + 3 + len, ".a") == 0)
	{
	  *found_static = TRUE;
	  continue;
	}

      /* We accept libfoo.so without a version number, even though the
	 native linker does not.  This is more convenient for packages
	 which just generate .so files for shared libraries, as on ELF
	 systems.  */
      if (! CONST_STRNEQ (entry->d_name + 3 + len, ".so"))
	continue;
      if (entry->d_name[6 + len] == '\0')
	;
      else if (entry->d_name[6 + len] == '.'
	       && ISDIGIT (entry->d_name[7 + len]))
	;
      else
	continue;

      for (s = entry->d_name + 6 + len; *s != '\0'; s++)
	if (*s != '.' && ! ISDIGIT (*s))
	  break;
      if (*s != '\0')
	continue;

      /* We've found a .so file.  Work out the major and minor
	 version numbers.  */
      found_maj = 0;
      found_min = 0;
      sscanf (entry->d_name + 3 + len, ".so.%d.%d",
	      &found_maj, &found_min);

      if ((force_maj != -1 && force_maj != found_maj)
	  || (force_min != -1 && force_min != found_min))
	continue;

      /* Make sure the file really exists (ignore broken symlinks).  */
      full_path = xmalloc (dirnamelen + 1 + strlen (entry->d_name) + 1);
      sprintf (full_path, "%s/%s", dirname, entry->d_name);
      statval = stat (full_path, &st);
      free (full_path);
      if (statval != 0)
	continue;

      /* We've found a match for the name we are searching for.  See
	 if this is the version we should use.  If the major and minor
	 versions match, we use the last entry in alphabetical order;
	 I don't know if this is how SunOS distinguishes libc.so.1.8
	 from libc.so.1.8.1, but it ought to suffice.  */
      if (found == NULL
	  || (found_maj > max_maj)
	  || (found_maj == max_maj
	      && (found_min > max_min
		  || (found_min == max_min
		      && strcmp (entry->d_name, found) > 0))))
	{
	  if (found != NULL)
	    free (found);
	  found = (char *) xmalloc (strlen (entry->d_name) + 1);
	  strcpy (found, entry->d_name);
	  max_maj = found_maj;
	  max_min = found_min;
	}
    }

  closedir (dir);

  if (alc != NULL)
    free (alc);

  return found;
}

/* These variables are required to pass information back and forth
   between after_open and check_needed.  */

static struct bfd_link_needed_list *global_needed;
static bfd_boolean global_found;

/* This is called after all the input files have been opened.  */

static void
gld${EMULATION_NAME}_after_open (void)
{
  struct bfd_link_needed_list *needed, *l;

  after_open_default ();

  /* We only need to worry about this when doing a final link.  */
  if (link_info.relocatable || link_info.shared)
    return;

  /* Get the list of files which appear in ld_need entries in dynamic
     objects included in the link.  For each such file, we want to
     track down the corresponding library, and include the symbol
     table in the link.  This is what the runtime dynamic linker will
     do.  Tracking the files down here permits one dynamic object to
     include another without requiring special action by the person
     doing the link.  Note that the needed list can actually grow
     while we are stepping through this loop.  */
  needed = bfd_sunos_get_needed_list (link_info.output_bfd, &link_info);
  for (l = needed; l != NULL; l = l->next)
    {
      struct bfd_link_needed_list *ll;
      const char *lname;
      search_dirs_type *search;

      lname = l->name;

      /* If we've already seen this file, skip it.  */
      for (ll = needed; ll != l; ll = ll->next)
	if (strcmp (ll->name, lname) == 0)
	  break;
      if (ll != l)
	continue;

      /* See if this file was included in the link explicitly.  */
      global_needed = l;
      global_found = FALSE;
      lang_for_each_input_file (gld${EMULATION_NAME}_check_needed);
      if (global_found)
	continue;

      if (! CONST_STRNEQ (lname, "-l"))
	{
	  bfd *abfd;

	  abfd = bfd_openr (lname, bfd_get_target (link_info.output_bfd));
	  if (abfd != NULL)
	    {
	      if (! bfd_check_format (abfd, bfd_object))
		{
		  (void) bfd_close (abfd);
		  abfd = NULL;
		}
	    }
	  if (abfd != NULL)
	    {
	      if ((bfd_get_file_flags (abfd) & DYNAMIC) == 0)
		{
		  (void) bfd_close (abfd);
		  abfd = NULL;
		}
	    }
	  if (abfd != NULL)
	    {
	      /* We've found the needed dynamic object.  */
	      if (! bfd_link_add_symbols (abfd, &link_info))
		einfo ("%F%B: error adding symbols: %E\n", abfd);
	    }
	  else
	    {
	      einfo ("%P: warning: %s, needed by %B, not found\n",
		     lname, l->by);
	    }

	  continue;
	}

      lname += 2;

      /* We want to search for the file in the same way that the
	 dynamic linker will search.  That means that we want to use
	 rpath_link, rpath or -L, then the environment variable
	 LD_LIBRARY_PATH (native only), then (if rpath was used) the
	 linker script LIB_SEARCH_DIRS.  */
      if (gld${EMULATION_NAME}_search_needed (command_line.rpath_link,
					      lname))
	continue;
      if (command_line.rpath != NULL)
	{
	  if (gld${EMULATION_NAME}_search_needed (command_line.rpath, lname))
	    continue;
	}
      else
	{
	  for (search = search_head; search != NULL; search = search->next)
	    if (gld${EMULATION_NAME}_try_needed (search->name, lname))
	      break;
	  if (search != NULL)
	    continue;
	}
EOF
if [ "x${host}" = "x${target}" ] ; then
  case " ${EMULATION_LIBPATH} " in
  *" ${EMULATION_NAME} "*)
fragment <<EOF
      {
	const char *lib_path;

	lib_path = (const char *) getenv ("LD_LIBRARY_PATH");
	if (gld${EMULATION_NAME}_search_needed (lib_path, lname))
	  continue;
      }
EOF
  ;;
  esac
fi
fragment <<EOF
      if (command_line.rpath != NULL)
	{
	  for (search = search_head; search != NULL; search = search->next)
	    {
	      if (search->cmdline)
		continue;
	      if (gld${EMULATION_NAME}_try_needed (search->name, lname))
		break;
	    }
	  if (search != NULL)
	    continue;
	}

      einfo ("%P: warning: %s, needed by %B, not found\n",
	     l->name, l->by);
    }
}

/* Search for a needed file in a path.  */

static bfd_boolean
gld${EMULATION_NAME}_search_needed (const char *path, const char *name)
{
  const char *s;

  if (path == NULL || *path == '\0')
    return FALSE;
  while (1)
    {
      const char *dir;
      char *dircopy;

      s = strchr (path, ':');
      if (s == NULL)
	{
	  dircopy = NULL;
	  dir = path;
	}
      else
	{
	  dircopy = (char *) xmalloc (s - path + 1);
	  memcpy (dircopy, path, s - path);
	  dircopy[s - path] = '\0';
	  dir = dircopy;
	}

      if (gld${EMULATION_NAME}_try_needed (dir, name))
	return TRUE;

      if (dircopy != NULL)
	free (dircopy);

      if (s == NULL)
	break;
      path = s + 1;
    }

  return FALSE;
}

/* This function is called for each possible directory for a needed
   dynamic object.  */

static bfd_boolean
gld${EMULATION_NAME}_try_needed (const char *dir, const char *name)
{
  char *file;
  char *alc;
  bfd_boolean ignore;
  bfd *abfd;

  file = gld${EMULATION_NAME}_search_dir (dir, name, &ignore);
  if (file == NULL)
    return FALSE;

  alc = (char *) xmalloc (strlen (dir) + strlen (file) + 2);
  sprintf (alc, "%s/%s", dir, file);
  free (file);
  abfd = bfd_openr (alc, bfd_get_target (link_info.output_bfd));
  if (abfd == NULL)
    return FALSE;
  if (! bfd_check_format (abfd, bfd_object))
    {
      (void) bfd_close (abfd);
      return FALSE;
    }
  if ((bfd_get_file_flags (abfd) & DYNAMIC) == 0)
    {
      (void) bfd_close (abfd);
      return FALSE;
    }

  /* We've found the needed dynamic object.  */

  /* Add this file into the symbol table.  */
  if (! bfd_link_add_symbols (abfd, &link_info))
    einfo ("%F%B: error adding symbols: %E\n", abfd);

  return TRUE;
}

/* See if we have already included a needed object in the link.  This
   does not have to be precise, as it does no harm to include a
   dynamic object more than once.  */

static void
gld${EMULATION_NAME}_check_needed (lang_input_statement_type *s)
{
  if (s->filename == NULL)
    return;
  if (! CONST_STRNEQ (global_needed->name, "-l"))
    {
      if (strcmp (s->filename, global_needed->name) == 0)
	global_found = TRUE;
    }
  else
    {
      const char *sname, *lname;
      const char *sdot, *ldot;
      int lmaj, lmin, smaj, smin;

      lname = global_needed->name + 2;

      sname = strrchr (s->filename, '/');
      if (sname == NULL)
	sname = s->filename;
      else
	++sname;

      if (! CONST_STRNEQ (sname, "lib"))
	return;
      sname += 3;

      ldot = strchr (lname, '.');
      if (ldot == NULL)
	ldot = lname + strlen (lname);

      sdot = strstr (sname, ".so.");
      if (sdot == NULL)
	return;

      if (sdot - sname != ldot - lname
	  || strncmp (lname, sname, sdot - sname) != 0)
	return;

      lmaj = lmin = -1;
      sscanf (ldot, ".%d.%d", &lmaj, &lmin);
      smaj = smin = -1;
      sscanf (sdot, ".so.%d.%d", &smaj, &smin);
      if ((smaj != lmaj && smaj != -1 && lmaj != -1)
	  || (smin != lmin && smin != -1 && lmin != -1))
	return;

      global_found = TRUE;
    }
}

/* We need to use static variables to pass information around the call
   to lang_for_each_statement.  Ick.  */

static const char *find_assign;
static bfd_boolean found_assign;

/* We need to use static variables to pass information around the call
   to lang_for_each_input_file.  Ick.  */

static bfd_size_type need_size;
static bfd_size_type need_entries;
static bfd_byte *need_contents;
static bfd_byte *need_pinfo;
static bfd_byte *need_pnames;

/* The size of one entry in the .need section, not including the file
   name.  */

#define NEED_ENTRY_SIZE (16)

/* This is called after the sections have been attached to output
   sections, but before any sizes or addresses have been set.  */

static void
gld${EMULATION_NAME}_before_allocation (void)
{
  struct bfd_link_hash_entry *hdyn = NULL;
  asection *sneed;
  asection *srules;
  asection *sdyn;

  /* The SunOS native linker creates a shared library whenever there
     are any undefined symbols in a link, unless -e is used.  This is
     pretty weird, but we are compatible.  */
  if (! link_info.shared && ! link_info.relocatable && ! entry_from_cmdline)
    {
      struct bfd_link_hash_entry *h;

      for (h = link_info.hash->undefs; h != NULL; h = h->u.undef.next)
	{
	  if (h->type == bfd_link_hash_undefined
	      && h->u.undef.abfd != NULL
	      && (h->u.undef.abfd->flags & DYNAMIC) == 0
	      && strcmp (h->root.string, "__DYNAMIC") != 0
	      && strcmp (h->root.string, "__GLOBAL_OFFSET_TABLE_") != 0)
	    {
	      find_assign = h->root.string;
	      found_assign = FALSE;
	      lang_for_each_statement (gld${EMULATION_NAME}_find_assignment);
	      if (! found_assign)
		{
		  link_info.shared = TRUE;
		  break;
		}
	    }
	}
    }

  if (link_info.shared)
    {
      lang_output_section_statement_type *os;

      /* Set the .text section to start at 0x20, not 0x2020.  FIXME:
	 This is too magical.  */
      os = lang_output_section_statement_lookup (".text", 0, TRUE);
      if (os->addr_tree == NULL)
	os->addr_tree = exp_intop (0x20);
    }

  /* We need to create a __DYNAMIC symbol.  We don't do this in the
     linker script because we want to set the value to the start of
     the dynamic section if there is one, or to zero if there isn't
     one.  We need to create the symbol before calling
     size_dynamic_sections, although we can't set the value until
     afterward.  */
  if (! link_info.relocatable)
    {
      hdyn = bfd_link_hash_lookup (link_info.hash, "__DYNAMIC", TRUE, FALSE,
				   FALSE);
      if (hdyn == NULL)
	einfo ("%P%F: bfd_link_hash_lookup: %E\n");
      if (! bfd_sunos_record_link_assignment (link_info.output_bfd, &link_info,
					      "__DYNAMIC"))
	einfo ("%P%F: failed to record assignment to __DYNAMIC: %E\n");
    }

  /* If we are going to make any variable assignments, we need to let
     the backend linker know about them in case the variables are
     referred to by dynamic objects.  */
  lang_for_each_statement (gld${EMULATION_NAME}_find_assignment);

  /* Let the backend linker work out the sizes of any sections
     required by dynamic linking.  */
  if (! bfd_sunos_size_dynamic_sections (link_info.output_bfd, &link_info,
					 &sdyn, &sneed, &srules))
    einfo ("%P%F: failed to set dynamic section sizes: %E\n");

  if (sneed != NULL)
    {
      /* Set up the .need section.  See the description of the ld_need
	 field in include/aout/sun4.h.  */

      need_entries = 0;
      need_size = 0;

      lang_for_each_input_file (gld${EMULATION_NAME}_count_need);

      /* We should only have a .need section if we have at least one
	 dynamic object.  */
      ASSERT (need_entries != 0);

      sneed->size = need_size;
      sneed->contents = (bfd_byte *) xmalloc (need_size);

      need_contents = sneed->contents;
      need_pinfo = sneed->contents;
      need_pnames = sneed->contents + need_entries * 16;

      lang_for_each_input_file (gld${EMULATION_NAME}_set_need);

      ASSERT ((bfd_size_type) (need_pnames - sneed->contents) == need_size);
    }

  if (srules != NULL)
    {
      /* Set up the .rules section.  This is just a PATH like string
	 of the -L arguments given on the command line.  We permit the
	 user to specify the directories using the -rpath command line
	 option.  */
      if (command_line.rpath)
	{
	  srules->size = strlen (command_line.rpath);
	  srules->contents = (bfd_byte *) command_line.rpath;
	}
      else
	{
	  unsigned int size;
	  search_dirs_type *search;

	  size = 0;
	  for (search = search_head; search != NULL; search = search->next)
	    if (search->cmdline)
	      size += strlen (search->name) + 1;
	  srules->size = size;
	  if (size > 0)
	    {
	      char *p;

	      srules->contents = (bfd_byte *) xmalloc (size);
	      p = (char *) srules->contents;
	      *p = '\0';
	      for (search = search_head; search != NULL; search = search->next)
		{
		  if (search->cmdline)
		    {
		      if (p != (char *) srules->contents)
			*p++ = ':';
		      strcpy (p, search->name);
		      p += strlen (p);
		    }
		}
	    }
	}
    }

  /* We must assign a value to __DYNAMIC.  It should be zero if we are
     not doing a dynamic link, or the start of the .dynamic section if
     we are doing one.  */
  if (! link_info.relocatable)
    {
      hdyn->type = bfd_link_hash_defined;
      hdyn->u.def.value = 0;
      if (sdyn != NULL)
	hdyn->u.def.section = sdyn;
      else
	hdyn->u.def.section = bfd_abs_section_ptr;
    }

  before_allocation_default ();
}

/* This is called by the before_allocation routine via
   lang_for_each_statement.  It does one of two things: if the
   variable find_assign is set, it sets found_assign if it finds an
   assignment to that variable; otherwise it tells the backend linker
   about all assignment statements, in case they are assignments to
   symbols which are referred to by dynamic objects.  */

static void
gld${EMULATION_NAME}_find_assignment (lang_statement_union_type *s)
{
  if (s->header.type == lang_assignment_statement_enum
      && (find_assign == NULL || ! found_assign))
    gld${EMULATION_NAME}_find_exp_assignment (s->assignment_statement.exp);
}

/* Look through an expression for an assignment statement.  */

static void
gld${EMULATION_NAME}_find_exp_assignment (etree_type *exp)
{
  switch (exp->type.node_class)
    {
    case etree_assign:
      if (find_assign != NULL)
	{
	  if (strcmp (find_assign, exp->assign.dst) == 0)
	    found_assign = TRUE;
	  return;
	}

      if (strcmp (exp->assign.dst, ".") != 0)
	{
	  if (! bfd_sunos_record_link_assignment (link_info.output_bfd,
						  &link_info,
						  exp->assign.dst))
	    einfo ("%P%F: failed to record assignment to %s: %E\n",
		   exp->assign.dst);
	}
      gld${EMULATION_NAME}_find_exp_assignment (exp->assign.src);
      break;

    case etree_binary:
      gld${EMULATION_NAME}_find_exp_assignment (exp->binary.lhs);
      gld${EMULATION_NAME}_find_exp_assignment (exp->binary.rhs);
      break;

    case etree_trinary:
      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.cond);
      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.lhs);
      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.rhs);
      break;

    case etree_unary:
      gld${EMULATION_NAME}_find_exp_assignment (exp->unary.child);
      break;

    default:
      break;
    }
}

/* Work out the size of the .need section, and the number of entries.
   The backend will set the ld_need field of the dynamic linking
   information to point to the .need section.  See include/aout/sun4.h
   for more information.  */

static void
gld${EMULATION_NAME}_count_need (lang_input_statement_type *inp)
{
  if (inp->the_bfd != NULL
      && (inp->the_bfd->flags & DYNAMIC) != 0)
    {
      ++need_entries;
      need_size += NEED_ENTRY_SIZE;
      if (! inp->flags.maybe_archive)
	need_size += strlen (inp->filename) + 1;
      else
	{
	  ASSERT (inp->local_sym_name[0] == '-'
		  && inp->local_sym_name[1] == 'l');
	  need_size += strlen (inp->local_sym_name + 2) + 1;
	}
    }
}

/* Fill in the contents of the .need section.  */

static void
gld${EMULATION_NAME}_set_need (lang_input_statement_type *inp)
{
  if (inp->the_bfd != NULL
      && (inp->the_bfd->flags & DYNAMIC) != 0)
    {
      bfd_size_type c;

      /* To really fill in the .need section contents, we need to know
	 the final file position of the section, but we don't.
	 Instead, we use offsets, and rely on the BFD backend to
	 finish the section up correctly.  FIXME: Talk about lack of
	 referential locality.  */
      bfd_put_32 (link_info.output_bfd, need_pnames - need_contents,
		  need_pinfo);
      if (! inp->flags.maybe_archive)
	{
	  bfd_put_32 (link_info.output_bfd, (bfd_vma) 0, need_pinfo + 4);
	  bfd_put_16 (link_info.output_bfd, (bfd_vma) 0, need_pinfo + 8);
	  bfd_put_16 (link_info.output_bfd, (bfd_vma) 0, need_pinfo + 10);
	  strcpy ((char *) need_pnames, inp->filename);
	}
      else
	{
	  char *verstr;
	  int maj, min;

	  bfd_put_32 (link_info.output_bfd, (bfd_vma) 0x80000000,
		      need_pinfo + 4);
	  maj = 0;
	  min = 0;
	  verstr = strstr (inp->filename, ".so.");
	  if (verstr != NULL)
	    sscanf (verstr, ".so.%d.%d", &maj, &min);
	  bfd_put_16 (link_info.output_bfd, (bfd_vma) maj, need_pinfo + 8);
	  bfd_put_16 (link_info.output_bfd, (bfd_vma) min, need_pinfo + 10);
	  strcpy ((char *) need_pnames, inp->local_sym_name + 2);
	}

      c = (need_pinfo - need_contents) / NEED_ENTRY_SIZE;
      if (c + 1 >= need_entries)
	bfd_put_32 (link_info.output_bfd, (bfd_vma) 0, need_pinfo + 12);
      else
	bfd_put_32 (link_info.output_bfd, (bfd_vma) (c + 1) * NEED_ENTRY_SIZE,
		    need_pinfo + 12);

      need_pinfo += NEED_ENTRY_SIZE;
      need_pnames += strlen ((char *) need_pnames) + 1;
    }
}

static char *
gld${EMULATION_NAME}_get_script (int *isfile)
EOF

if test -n "$COMPILE_IN"
then
# Scripts compiled in.

# sed commands to quote an ld script as a C string.
sc="-f stringify.sed"

fragment <<EOF
{
  *isfile = 0;

  if (link_info.relocatable && config.build_constructors)
    return
EOF
sed $sc ldscripts/${EMULATION_NAME}.xu                     >> e${EMULATION_NAME}.c
echo '  ; else if (link_info.relocatable) return'         >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xr                     >> e${EMULATION_NAME}.c
echo '  ; else if (!config.text_read_only) return'         >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xbn                    >> e${EMULATION_NAME}.c
echo '  ; else if (!config.magic_demand_paged) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xn                     >> e${EMULATION_NAME}.c
echo '  ; else return'                                     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.x                      >> e${EMULATION_NAME}.c
echo '; }'                                                 >> e${EMULATION_NAME}.c

else
# Scripts read from the filesystem.

fragment <<EOF
{
  *isfile = 1;

  if (link_info.relocatable && config.build_constructors)
    return "ldscripts/${EMULATION_NAME}.xu";
  else if (link_info.relocatable)
    return "ldscripts/${EMULATION_NAME}.xr";
  else if (!config.text_read_only)
    return "ldscripts/${EMULATION_NAME}.xbn";
  else if (!config.magic_demand_paged)
    return "ldscripts/${EMULATION_NAME}.xn";
  else
    return "ldscripts/${EMULATION_NAME}.x";
}
EOF

fi

fragment <<EOF

struct ld_emulation_xfer_struct ld_${EMULATION_NAME}_emulation =
{
  gld${EMULATION_NAME}_before_parse,
  syslib_default,
  hll_default,
  after_parse_default,
  gld${EMULATION_NAME}_after_open,
  after_allocation_default,
  set_output_arch_default,
  ldemul_default_target,
  gld${EMULATION_NAME}_before_allocation,
  gld${EMULATION_NAME}_get_script,
  "${EMULATION_NAME}",
  "${OUTPUT_FORMAT}",
  finish_default,
  gld${EMULATION_NAME}_create_output_section_statements,
  NULL,	/* open dynamic archive */
  NULL,	/* place orphan */
  gld${EMULATION_NAME}_set_symbols,
  NULL,	/* parse args */
  NULL,	/* add_options */
  NULL,	/* handle_option */
  NULL,	/* unrecognized file */
  NULL,	/* list options */
  NULL,	/* recognized file */
  NULL,	/* find_potential_libraries */
  NULL	/* new_vers_pattern */
};
EOF
@


1.34
log
@	* ldlang.h (struct lang_input_statement_flags): New, extract from..
	(lang_input_statement_type): ..here.  New field "flags".
	(input_flags): Declare.
	(missing_file): Delete.
	* ldmain.h (whole_archive): Delete.
	(add_DT_NEEDED_for_regular, add_DT_NEEDED_for_dynamic): Delete.
	* ld.h (ld_config_type <dynamic_link>): Delete.
	* ldmain.c (whole_archive): Delete.
	(add_DT_NEEDED_for_regular, add_DT_NEEDED_for_dynamic): Delete.
	* ldlang.c (missing_file, ldlang_sysrooted_script): Delete.
	(input_flags): New variable.  Replace all uses of config.dynamic_link,
	missing_file, ldlang_sysrooted_script, whole_archive,
	add_DT_NEEDED_for_regular and add_DT_NEEDED_for_dynamic with fields
	from here.
	* ldfile.c: Likewise.
	* ldgram.y: Likewise.
	* ldmain.c: Likewise.
	* ldwrite.c: Likewise.
	* lexsup.c: Likewise.
	* plugin.c: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vms.em: Likewise.
	* ldlang.c (new_afile): Use memset to init zero fields.
	(load_symbols): Simplify save and restore of flags around command
	file processing.
	* ldfile.c (is_sysrooted_pathname): Tidy.
@
text
@d432 1
a432 1
		einfo ("%F%B: could not read symbols: %E\n", abfd);
d579 1
a579 1
    einfo ("%F%B: could not read symbols: %E\n", abfd);
@


1.33
log
@	* ld.texinfo (Expression Section): Describe treatment of numbers
	and absolute symbols.
	* ldemul.c (after_open_default): Look up __ld_compatibility.
	* ldexp.c (fold_name): Convert absolute symbols to numbers when
	inside output section definitions, or when __ld_compatibility >= 221.
	(exp_fold_tree_1): Convert numbers to absolute when not in output
	section definition and __ld_compatibility < 221.  Don't always
	convert values outside an output section definition to absolute.
	* ldexp.h (uses_defined): Comment.
	* ldlang.c (ld_compatibility): New variable.
	* ldlang.h (ld_compatibility): Declare.
	* emultempl/aix.em, * emultempl/armcoff.em, * emultempl/beos.em,
	* emultempl/elf32.em, * emultempl/genelf.em, * emultempl/lnk960.em,
	* emultempl/m68kcoff.em, * emultempl/mmo.em, * emultempl/pe.em,
	* emultempl/pep.em, * emultempl/sunos.em, * emultempl/z80.em: Call
	after_open_default from after_open function.
@
text
@d13 2
a14 1
   2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
d89 1
a89 1
  config.dynamic_link = TRUE;
d160 3
a162 3
  if (! inp->search_dirs_flag
      || ! inp->maybe_archive
      || ! inp->dynamic)
d192 1
a192 1
  inp->search_dirs_flag = FALSE;
d895 1
a895 1
      if (! inp->maybe_archive)
d923 1
a923 1
      if (! inp->maybe_archive)
@


1.32
log
@Replace is_archive with maybe_archive.

2010-12-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldfile.c (ldfile_open_file_search): Check maybe_archive instead
	of is_archive.
	* emultempl/aix.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vms.em: Likewise.

	* ldlang.c (new_afile): Set maybe_archive instead of is_archive..

	* ldlang.h (lang_input_statement_struct): Replace is_archive
	with maybe_archive.
@
text
@d369 2
@


1.31
log
@2008-09-08  H.J. Lu  <hongjiu.lu@@intel.com>

	2008-09-07  Alan Modra  <amodra@@bigpond.net.au>

	* emultempl/beos.em (gld${EMULATION_NAME}_place_orphan): Updated.
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): Likewise.
@
text
@d160 1
a160 1
      || ! inp->is_archive
d892 1
a892 1
      if (! inp->is_archive)
d920 1
a920 1
      if (! inp->is_archive)
@


1.31.10.1
log
@backport from mainline
@
text
@d160 1
a160 1
      || ! inp->maybe_archive
a368 2
  after_open_default ();

d892 1
a892 1
      if (! inp->maybe_archive)
d920 1
a920 1
      if (! inp->maybe_archive)
@


1.30
log
@include/
	* bfdlink.h (struct bfd_link_hash_table): Delete creator field.
	(struct bfd_link_info): Add output_bfd.
bfd/
	* elflink.c: Replace all accesses to hash->creator field with
	output_bfd->xvec.
	* cofflink.c: Likewise.
	* coff-h8300.c: Likewise.
	* ecoff.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfxx-mips.c: Likewise.
	* i386linux.c: Likewise.
	* m68klinux.c: Likewise.
	* sparclinux.c: Likewise.
	* sunos.c: Likewise.
	* xcofflink.c: Likewise.
	* linker.c: Likewise.
	(_bfd_link_hash_table_init): Don't store creator.
ld/
	* ldmain.h (output_bfd): Delete.
	* ldmain.c (output_bfd): Delete.
	Replace all occurrences of output_bfd with link_info.output_bfd.
	* ldcref.c: Likewise.
	* ldctor.c: Likewise.
	* ldemul.c: Likewise.
	* ldexp.c: Likewise.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldmisc.c: Likewise.
	* ldwrite.c: Likewise.
	* pe-dll.c: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/alphaelf.em: Likewise.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/elf-generic.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/irix.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/mmix-elfnmmo.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/sh64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
	* emultempl/z80.em: Likewise.
	* ldlang.c (open_output): Don't return output, instead write
	link_info_output_bfd directly.
	* emultempl/alphaelf.em: Replace occurrences of link_info.hash->creator
	with link_info.output_bfd->xvec.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
@
text
@d701 1
a701 1
      os = lang_output_section_statement_lookup (".text");
@


1.30.2.1
log
@	* emultempl/beos.em (gld${EMULATION_NAME}_place_orphan): Updated.
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): Ditto.
@
text
@d701 1
a701 1
      os = lang_output_section_statement_lookup (".text", 0, TRUE);
@


1.29
log
@2007-07-19  Roland McGrath  <roland@@redhat.com>

	* genscripts.sh (source_em, fragment): New sh functions.
	Truncate e${EMULATION_NAME}.c file before .em script fills it.
	Use source_em in place of . for the .em script.
	* emultempl/generic.em: Use fragment and source_em functions.
	* emultempl/aix.em: Likewise.
	* emultempl/alphaelf.em: Likewise.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/cr16elf.em: Likewise.
	* emultempl/crxelf.em: Likewise.
	* emultempl/elf-generic.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/genelf.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/gld960c.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ia64elf.em: Likewise.
	* emultempl/irix.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/m68kcoff.em: Likewise.
	* emultempl/m68kelf.em: Likewise.
	* emultempl/mipsecoff.em: Likewise.
	* emultempl/mipself.em: Likewise.
	* emultempl/mmix-elfnmmo.em: Likewise.
	* emultempl/mmixelf.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/needrelax.em: Likewise.
	* emultempl/netbsd.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/sh64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/ticoff.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
	* emultempl/z80.em: Likewise.
@
text
@d13 1
a13 1
   2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
d381 1
a381 1
  needed = bfd_sunos_get_needed_list (output_bfd, &link_info);
d408 1
a408 1
	  abfd = bfd_openr (lname, bfd_get_target (output_bfd));
d558 1
a558 1
  abfd = bfd_openr (alc, bfd_get_target (output_bfd));
d718 1
a718 1
      if (! bfd_sunos_record_link_assignment (output_bfd, &link_info,
d730 2
a731 2
  if (! bfd_sunos_size_dynamic_sections (output_bfd, &link_info, &sdyn,
					 &sneed, &srules))
d850 2
a851 1
	  if (! bfd_sunos_record_link_assignment (output_bfd, &link_info,
d918 2
a919 1
      bfd_put_32 (output_bfd, need_pnames - need_contents, need_pinfo);
d922 3
a924 3
	  bfd_put_32 (output_bfd, (bfd_vma) 0, need_pinfo + 4);
	  bfd_put_16 (output_bfd, (bfd_vma) 0, need_pinfo + 8);
	  bfd_put_16 (output_bfd, (bfd_vma) 0, need_pinfo + 10);
d932 2
a933 1
	  bfd_put_32 (output_bfd, (bfd_vma) 0x80000000, need_pinfo + 4);
d939 2
a940 2
	  bfd_put_16 (output_bfd, (bfd_vma) maj, need_pinfo + 8);
	  bfd_put_16 (output_bfd, (bfd_vma) min, need_pinfo + 10);
d946 1
a946 1
	bfd_put_32 (output_bfd, (bfd_vma) 0, need_pinfo + 12);
d948 1
a948 1
	bfd_put_32 (output_bfd, (bfd_vma) (c + 1) * NEED_ENTRY_SIZE,
@


1.28
log
@Update sources to GPLv3
@
text
@d8 1
a8 1
cat >e${EMULATION_NAME}.c <<EOF
d104 1
a104 1
cat >>e${EMULATION_NAME}.c <<EOF
d131 1
a131 1
cat >>e${EMULATION_NAME}.c <<EOF
d467 1
a467 1
cat >>e${EMULATION_NAME}.c <<EOF
d479 1
a479 1
cat >>e${EMULATION_NAME}.c <<EOF
d964 1
a964 1
cat >>e${EMULATION_NAME}.c <<EOF
d985 1
a985 1
cat >>e${EMULATION_NAME}.c <<EOF
d1004 1
a1004 1
cat >>e${EMULATION_NAME}.c <<EOF
@


1.27
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d17 1
a17 1
This file is part of GLD, the Gnu Linker.
d19 14
a32 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.26
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d13 1
a13 1
   2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
d35 1
a36 1
#include "sysdep.h"
@


1.25
log
@bfd/
	* elf32-ppc.c (struct elf_linker_section): Replace sym_val field
	with sym.
	(ppc_elf_relocate_section): Adjust for above.
	(create_sdata_sym): New function.
	(ppc_elf_create_linker_section): Call it.
	(ppc_elf_check_relocs): Correct has_sda_refs and non_got_refs.
	Create sdata syms for all SDA relocs.
	(ppc_elf_adjust_dynamic_symbol): Don't special case _SDA_BASE_
	and _SDA2_BASE_.
	(ppc_elf_set_sdata_syms): Delete.
	* elflink.c (bfd_elf_size_dynamic_sections): Don't create DT_INIT
	and DT_FINI tags unless associated section has input.
	(bfd_elf_set_symbol, _bfd_elf_provide_symbol): Delete.
	(_bfd_elf_provide_section_bound_symbols): Delete.
	* bfd-in.h (_bfd_elf_provide_symbol): Delete.
	(_bfd_elf_provide_section_bound_symbols): Delete.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c (ldemul_do_assignments, do_assignments_default): Delete.
	* ldemul.h (ldemul_do_assignments, do_assignments_default): Delete.
	(struct ld_emulation_xfer_struct): Remove do_assignments field.
	* ldlang.c (lang_do_assignments): Don't call ldemul_do_assignments.
	* emulparams/elf32ppc.sh (SDATA_START_SYMBOLS): New.
	(SDATA2_START_SYMBOLS, SBSS_START_SYMBOLS, SBSS_END_SYMBOLS): New.
	* emultempl/aix.em (ld_*_emulation): Delete do_assignments init.
	* emultempl/armcoff.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/generic.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/gld960c.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68kcoff.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/ticoff.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/elf32.em: Likewise.
	(gld*_provide_bound_symbols): Delete.
	(gld*_provide_init_fini_syms): Delete.
	(gld*_before_allocation): Don't call ldemul_do_assignments.
	* emultempl/ppc32elf.em (ppc_do_assignments): Delete.
	(LDEMUL_DO_ASSIGNMENTS): Delete.
	* scripttempl/elf.sc: Provide init/fini syms.  Add SBSS_START_SYMBOLS,
	SBSS_END_SYMBOLS, SDATA2_START_SYMBOLS.
@
text
@d13 1
a13 1
   2002, 2003, 2004, 2005 Free Software Foundation, Inc.
d163 1
a163 1
  ASSERT (strncmp (inp->local_sym_name, "-l", 2) == 0);
d276 1
a276 1
      if (strncmp (entry->d_name, "lib", 3) != 0
d291 1
a291 1
      if (strncmp (entry->d_name + 3 + len, ".so", 3) != 0)
d403 1
a403 1
      if (strncmp (lname, "-l", 2) != 0)
d589 1
a589 1
  if (strncmp (global_needed->name, "-l", 2) != 0)
d608 1
a608 1
      if (strncmp (sname, "lib", 3) != 0)
@


1.24
log
@bfd/
	* elflink.c (fix_syms, _bfd_elf_fix_excluded_sec_syms): Move to..
	* linker.c (fix_syms, _bfd_fix_excluded_sec_syms): ..here.
	* bfd-in.h (_bfd_fix_excluded_sec_syms): Rename.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c (ldemul_finish): Call ld_emulation->finish unconditionally.
	(finish_default): New function.
	* ldemul.h (finish_default): Declare.
	* emultempl/aix.em (gld*_before_allocation): Call
	before_allocation_default rather than strip_excluded_output_sections.
	(ld_*_emulation): Init finish field to finish_default.
	* emultempl/armcoff.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/generic.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/gld960c.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68kcoff.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/ticoff.em: Likewise.
	* emultempl/vanilla.em: Likewise.
@
text
@a1015 1
  do_assignments_default,
@


1.23
log
@	* ldemul.c (ldemul_do_assignments): New function.
	(do_assignments_default): New function.
	* ldemul.h (ldemul_do_assignments): Declare.
	(do_assignments_default): Declare.
	(struct ld_emulation_xfer_struct): Add do_assignments.
	* ldlang.c (lang_do_assignments) Call ldemul_do_assignments.
	* emultempl/aix.em (ld_*_emulation): Init do_assignments field.
	* emultempl/armcoff.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/generic.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/gld960c.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68kcoff.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/ticoff.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/elf32.em: Likewise, to call gld*_provide_init_fini_syms.
	(gld*_find_exp_assignment): Adjust bfd_elf_record_link_assignment call.
@
text
@d812 1
d814 1
a814 2
      strip_excluded_output_sections ();
    }
d1020 1
a1020 1
  NULL,	/* finish */
@


1.22
log
@Update FSF addresses
@
text
@d1016 1
@


1.21
log
@bfd/
	* section.c (struct bfd_section): Replace link_order_head and
	link_order_tail with map_head and map_tail union.
	(STD_SECTION): Update.
	(_bfd_strip_section_from_output): Delete.
	* aoutx.h: Update throughout for above changes.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* linker.c: Likewise.
	* merge.c: Likewise.
	* pdp11.c: Likewise.
	* xcofflink.c: Likewise.
	* elflink.c (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Split
	out from bfd_elf_size_dynamic_sections.
	* bfd-in.h (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Declare.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c: Include bfdlink.h.
	(ldemul_before_allocation): Assume before_allocation is non-zero.
	(before_allocation_default): Call strip_excluded_output_sections.
	* ldlang.c (stripped_excluded_sections): New variable.
	(lang_add_section): Build input section list for each output
	section, attached via map_head and map_tail pointers.
	(strip_excluded_output_sections): Make global.  Traverse the
	input section lists to find which output sections can go.  Clear
	link_order pointers and set stripped_excluded_sections.
	(lang_process): Call strip_excluded_output_sections.
	* ldlang.h (strip_excluded_output_sections): Declare.
	* ldwrite.c: Update throuhout for link_order_head -> map_head change.
	* emultempl/aix.em (before_allocation): Call
	strip_excluded_output_sections.
	* emultempl/armcoff.em (before_allocation): Likewise.
	* emultempl/beos.em (before_allocation): Likewise.
	* emultempl/linux.em (before_allocation): Likewise.
	* emultempl/pe.em (before_allocation): Likewise.
	* emultempl/sunos.em (before_allocation): Likewise.
	* emultempl/elf32.em (before_allocation): Likewise.  Call
	bfd_elf_size_dynsym_hash_dynstr too.
	* emultempl/lnk960.em (lnk960_before_allocation): Delete.
	(ld_lnk960): Use before_allocation_default.
@
text
@d31 1
a31 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.20
log
@update copyright dates
@
text
@d812 2
@


1.19
log
@	* pe-dll.c: Warning fixes.
	* emultempl/sunos.em: Likewise.
@
text
@d12 2
a13 2
   Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2002,
   2003, 2004, 2005 Free Software Foundation, Inc.
@


1.18
log
@include/
	* bfdlink.h (struct bfd_link_hash_entry): Move und_next into elements
	of union.
bfd/
	* ecoff.c: Update u.undef.next refs.
	* elf64-ppc.c: Likewise.
	* elflink.c: Likewise.
	* linker.c: Likewise.
	* xcofflink.c: Likewise.
ld/
	* ldexp.c (fold_name): Update u.undef.next refs.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.

bfd/
	* elf-bfd.h (struct elf_link_hash_entry): Rearrange.  Add FIXME to
	dynamic_def.  Combine weakdef and elf_hash_value.  Move vtable
	fields to indirect struct.
	* elf-m10300.c: Update u.weakdef refs.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elflink.c: Likewise.  Also u.elf_hash_value.
	(elf_gc_propagate_vtable_entries_used): Update for h->vtable
	indirection.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(bfd_elf_gc_record_vtinherit): Alloc vtable.
	(bfd_elf_gc_record_vtentry): Likewise.
	* elf.c (_bfd_elf_link_hash_newfunc): Use memset.
@
text
@d13 1
a13 1
   2003, 2004 Free Software Foundation, Inc.
d920 1
a920 1
	  strcpy (need_pnames, inp->filename);
d935 1
a935 1
	  strcpy (need_pnames, inp->local_sym_name + 2);
d946 1
a946 1
      need_pnames += strlen (need_pnames) + 1;
@


1.17
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d674 1
a674 1
      for (h = link_info.hash->undefs; h != NULL; h = h->und_next)
@


1.16
log
@	* ldfile.c (ldfile_set_output_arch): Add defarch param.
	* ldfile.h (ldfile_set_output_arch): Ditto.
	* emultempl/aix.em (gld${EMULATION_NAME}_before_parse): Use
	ldfile_set_output_arch.
	* emultempl/beos.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/elf32.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/linux.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/mipsecoff.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/pe.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* ldgram.y: Adjust ldfile_set_output_arch call.
	* emultempl/armcoff.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/armelf.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/armelf_oabi.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/generic.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/gld960c.em (gld960_set_output_arch): Ditto.
	* emultempl/m68kcoff.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/ticoff.em (gld${EMULATION_NAME}_before_parse): Ditto.
@
text
@d747 1
a747 1
      sneed->_raw_size = need_size;
d767 1
a767 1
	  srules->_raw_size = strlen (command_line.rpath);
d779 1
a779 1
	  srules->_raw_size = size;
@


1.15
log
@Rename bfd_link_hash_entry field "next" -> "und_next".
@
text
@d12 2
a13 2
   Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2002, 2003
   Free Software Foundation, Inc.
d86 1
a86 9
  const bfd_arch_info_type *arch = bfd_scan_arch ("${OUTPUT_ARCH}");
  if (arch)
    {
      ldfile_output_architecture = arch->arch;
      ldfile_output_machine = arch->mach;
      ldfile_output_machine_name = arch->printable_name;
    }
  else
    ldfile_output_architecture = bfd_arch_${ARCH};
@


1.14
log
@	* emultempl/aix.em: Convert to C90, remove unnecessary prototypes
	and casts.  Replace PTR with void *.  Formatting.
	* emultempl/alphaelf.em: Likewise
	* emultempl/armcoff.em: Likewise
	* emultempl/armelf.em: Likewise
	* emultempl/armelf_oabi.em: Likewise
	* emultempl/beos.em: Likewise
	* emultempl/elf32.em: Likewise
	* emultempl/generic.em: Likewise
	* emultempl/gld960.em: Likewise
	* emultempl/gld960c.em: Likewise
	* emultempl/hppaelf.em: Likewise
	* emultempl/linux.em: Likewise
	* emultempl/lnk960.em: Likewise
	* emultempl/m68hc1xelf.em: Likewise
	* emultempl/m68kcoff.em: Likewise
	* emultempl/m68kelf.em: Likewise
	* emultempl/mipsecoff.em: Likewise
	* emultempl/mipself.em: Likewise
	* emultempl/mmix-elfnmmo.em: Likewise
	* emultempl/mmixelf.em: Likewise
	* emultempl/mmo.em: Likewise
	* emultempl/needrelax.em: Likewise
	* emultempl/netbsd.em: Likewise
	* emultempl/pe.em: Likewise
	* emultempl/sh64elf.em: Likewise
	* emultempl/sunos.em: Likewise
	* emultempl/ticoff.em: Likewise
	* emultempl/vanilla.em: Likewise
	* emultempl/xtensaelf.em: Likewise
	* Makefile.am: Correct dependencies.
	* Makefile.in: Regenerate.
@
text
@d682 1
a682 1
      for (h = link_info.hash->undefs; h != NULL; h = h->next)
@


1.13
log
@Correct spelling of "relocatable".
@
text
@a63 4
static void gld${EMULATION_NAME}_before_parse PARAMS ((void));
static void gld${EMULATION_NAME}_set_symbols PARAMS ((void));
static void gld${EMULATION_NAME}_create_output_section_statements
  PARAMS ((void));
d65 1
a65 1
  PARAMS ((lang_input_statement_type *));
d67 1
a67 2
  PARAMS ((const char *, const char *, bfd_boolean *));
static void gld${EMULATION_NAME}_after_open PARAMS ((void));
d69 1
a69 1
  PARAMS ((lang_input_statement_type *));
d71 1
a71 1
  PARAMS ((const char *, const char *));
d73 1
a73 2
  PARAMS ((const char *, const char *));
static void gld${EMULATION_NAME}_before_allocation PARAMS ((void));
d75 3
a77 2
  PARAMS ((lang_statement_union_type *));
static void gld${EMULATION_NAME}_find_exp_assignment PARAMS ((etree_type *));
d79 1
a79 1
  PARAMS ((lang_input_statement_type *));
d81 1
a81 2
  PARAMS ((lang_input_statement_type *));
static char *gld${EMULATION_NAME}_get_script PARAMS ((int *isfile));
d84 1
a84 1
gld${EMULATION_NAME}_before_parse()
d105 1
a105 1
gld${EMULATION_NAME}_set_symbols ()
d151 1
a151 1
gld${EMULATION_NAME}_create_output_section_statements ()
d159 1
a159 2
gld${EMULATION_NAME}_find_so (inp)
     lang_input_statement_type *inp;
d230 2
a231 4
gld${EMULATION_NAME}_search_dir (dirname, filename, found_static)
     const char *dirname;
     const char *filename;
     bfd_boolean *found_static;
d296 3
a298 3
         native linker does not.  This is more convenient for packages
         which just generate .so files for shared libraries, as on ELF
         systems.  */
d372 1
a372 1
gld${EMULATION_NAME}_after_open ()
d508 1
a508 3
gld${EMULATION_NAME}_search_needed (path, name)
     const char *path;
     const char *name;
d551 1
a551 3
gld${EMULATION_NAME}_try_needed (dir, name)
     const char *dir;
     const char *name;
d593 1
a593 2
gld${EMULATION_NAME}_check_needed (s)
     lang_input_statement_type *s;
d668 1
a668 1
gld${EMULATION_NAME}_before_allocation ()
d707 1
a707 1
         This is too magical.  */
d831 1
a831 2
gld${EMULATION_NAME}_find_assignment (s)
     lang_statement_union_type *s;
d841 1
a841 2
gld${EMULATION_NAME}_find_exp_assignment (exp)
     etree_type *exp;
d889 1
a889 2
gld${EMULATION_NAME}_count_need (inp)
     lang_input_statement_type *inp;
d910 1
a910 2
gld${EMULATION_NAME}_set_need (inp)
     lang_input_statement_type *inp;
d959 1
a959 2
gld${EMULATION_NAME}_get_script(isfile)
     int *isfile;
@


1.12
log
@	* ldemul.c (ldemul_add_options, ldemul_handle_option): New functions.
	(ldemul_parse_args): Return bfd_boolean.  Formatting.
	* ldemul.h (ldemul_add_options, ldemul_handle_option): Declare.
	(ldemul_parse_args): Adjust.
	(struct ld_emulation_xfer_struct): Add add_options and handle_option.
	Return bfd_boolean from parse_args.
	* lexsup.c (parse_args): Malloc shortopts, longopts and
	really_longopts.  Call ldemul_add_options and ldemul_handle_option.
	* emultempl/aix.em (gld${EMULATION_NAME}_add_options): Split out from
	gld${EMULATION_NAME}_parse_args.
	(gld${EMULATION_NAME}_handle_option): Likewise.
	(ld_${EMULATION_NAME}_emulation): Adjust initializer.
	* emultempl/armcoff.em: As for aix.em, but remove parse_args.
	* emultempl/beos.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/ticoff.em: Likewise.
	* emultempl/elf32.em: Likewise.  Don't duplicate long options either.
	(gld${EMULATION_NAME}_add_sysroot): Prototype.
	* emultempl/armelf.em (PARSE_AND_LIST_LONGOPTS): Don't duplicate
	options.
	* emultempl/hppaelf.em (PARSE_AND_LIST_LONGOPTS): Likewise.
	* emultempl/ppc32elf.em (PARSE_AND_LIST_LONGOPTS): Likewise.
	* emultempl/ppc64elf.em (PARSE_AND_LIST_LONGOPTS): Likewise.
	* emultempl/armelf_oabi.em (ld_${EMULATION_NAME}_emulation): Adjust
	initializer.
	* emultempl/generic.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/gld960c.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68kcoff.em: Likewise.
	* emultempl/mipsecoff.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/netbsd.em (gldnetbsd_before_parse): Prototype.
@
text
@d386 1
a386 1
  if (link_info.relocateable || link_info.shared)
d692 1
a692 1
  if (! link_info.shared && ! link_info.relocateable && ! entry_from_cmdline)
d733 1
a733 1
  if (! link_info.relocateable)
d826 1
a826 1
  if (! link_info.relocateable)
d992 1
a992 1
  if (link_info.relocateable && config.build_constructors)
d996 1
a996 1
echo '  ; else if (link_info.relocateable) return'         >> e${EMULATION_NAME}.c
d1013 1
a1013 1
  if (link_info.relocateable && config.build_constructors)
d1015 1
a1015 1
  else if (link_info.relocateable)
@


1.11
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d12 1
a12 1
   Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2002
d1050 2
@


1.10
log
@	* ldemul.c (ldemul_new_vers_pattern): New function.
	* ldemul.h (ldemul_new_vers_pattern): Declare.
	(struct ld_emulation_xfer_struct): Add new_vers_pattern.
	* ldlang.c (lang_new_vers_pattern): Call ldemul_new_vers_pattern.
	* emultempl/ppc64elf.em (dotsyms): New static var.
	(gld${EMULATION_NAME}_new_vers_pattern): New function.
	(LDEMUL_NEW_VERS_PATTERN): Define.
	(PARSE_AND_LIST_PROLOGUE): Add OPTION_DOTSYMS, OPTION_NO_DOTSYMS.
	(PARSE_AND_LIST_LONGOPTS): Likewise.
	(PARSE_AND_LIST_ARGS_CASES): Handle them.
	* emultempl/aix.em (ld_${EMULATION_NAME}_emulation): Update
	initialiser.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf_oabi.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/generic.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/gld960c.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68kcoff.em: Likewise.
	* emultempl/mipsecoff.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/ticoff.em: Likewise.
	* emultempl/vanilla.em: Likewise.
@
text
@d3 1
a3 1
if [ -z "$MACHINE" ]; then 
d12 1
a12 1
   Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
d71 1
a71 1
  PARAMS ((const char *, const char *, boolean *));
d75 1
a75 1
static boolean gld${EMULATION_NAME}_search_needed
d77 1
a77 1
static boolean gld${EMULATION_NAME}_try_needed
d101 2
a102 2
  config.dynamic_link = true;
  config.has_shared = true;
d134 1
a134 1
	    ldfile_add_library_path (l, false);
d182 1
a182 1
      boolean found_static;
d205 1
a205 1
  inp->search_dirs_flag = false;
d240 1
a240 1
     boolean *found_static;
d255 1
a255 1
  *found_static = false;
d287 1
a287 1
  
d300 1
a300 1
	  *found_static = true;
d376 1
a376 1
static boolean global_found;
d415 1
a415 1
      global_found = false;
d516 1
a516 1
static boolean
d524 1
a524 1
    return false;
d545 1
a545 1
	return true;
d555 1
a555 1
  return false;	  
d561 1
a561 1
static boolean
d568 1
a568 1
  boolean ignore;
d573 1
a573 1
    return false;
d580 1
a580 1
    return false;
d584 1
a584 1
      return false;
d589 1
a589 1
      return false;
d598 1
a598 1
  return true;
d614 1
a614 1
	global_found = true;
d654 1
a654 1
      global_found = true;
d662 1
a662 1
static boolean found_assign;
d695 1
a695 1
      
d705 1
a705 1
	      found_assign = false;
d709 1
a709 1
		  link_info.shared = true;
d735 2
a736 2
      hdyn = bfd_link_hash_lookup (link_info.hash, "__DYNAMIC", true, false,
				   false);
d865 1
a865 1
	    found_assign = true;
d989 1
a989 1
{			     
d992 1
a992 1
  if (link_info.relocateable == true && config.build_constructors == true)
d996 1
a996 1
echo '  ; else if (link_info.relocateable == true) return' >> e${EMULATION_NAME}.c
d1010 1
a1010 1
{			     
d1013 1
a1013 1
  if (link_info.relocateable == true && config.build_constructors == true)
d1015 1
a1015 1
  else if (link_info.relocateable == true)
d1030 1
a1030 1
struct ld_emulation_xfer_struct ld_${EMULATION_NAME}_emulation = 
@


1.9
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d1053 2
a1054 1
  NULL 	/* find_potential_libraries */
@


1.8
log
@2001-05-24  H.J. Lu  <hjl@@gnu.org>

	* emultempl/aix.em (OUTPUT_ARCH): Defined.
	(gld${EMULATION_NAME}_before_parse): Initialize
	ldfile_output_architecture, ldfile_output_machine and
	ldfile_output_machine_name from ${OUTPUT_ARCH} if possible.
	* emultempl/beos.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/mipsecoff.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.
@
text
@a34 2
#include <ctype.h>

d39 1
d313 1
a313 1
	       && isdigit ((unsigned char) entry->d_name[7 + len]))
d319 1
a319 1
	if (*s != '.' && ! isdigit ((unsigned char) *s))
@


1.7
log
@Fixtypos in ChangeLogs, fix copyright dates in files
@
text
@d3 5
d93 9
a101 1
  ldfile_output_architecture = bfd_arch_${ARCH};
@


1.6
log
@Remove some forward declarations in ldemul.h and ldfile.h, and
re-arrange header include order.
Fix shadowing warnings in ldlang.h
Fix compile errors in mpw-elfmips.c
@
text
@d7 1
a7 1
   Copyright (C) 1991, 93, 94, 95, 96, 97, 98, 99, 2000
@


1.6.2.1
log
@Update copyright notices.
@
text
@d7 1
a7 1
   Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
@


1.5
log
@GCC warning fix: Add missing NULL initialiser for find_potential_libraries.
@
text
@d7 1
a7 1
   Copyright (C) 1991, 93, 94, 95, 96, 97, 98, 1999
a38 2
#include "ldemul.h"
#include "ldfile.h"
d42 2
@


1.4
log
@To satisfy latest CVS gcc:
	* emultempl/*.em (ld_emulation_xfer_struct): Add missing NULL
	initialisers, and comments.
	* testsuite/ld-srec/sr3.cc (__rethrow): New.
@
text
@d1040 2
a1041 1
  NULL 	/* recognized file */
@


1.3
log
@	* emultempl/ostring.sed: Rename from stringify.sed.
	* emultempl/astring.sed: New file.
	* Makefile.am (stringify.sed): New target.
	(GEN_DEPENDS): Change $(srcdir)/emultempl/stringify.sed to
	stringify.sed.
	* configure.in: Define and substitute STRINGIFY.
	* emultempl/*.em: Use stringify.sed from build directory rather
	than source directory.
	* emultempl/elf32.em: Use stringify.sed rather than inline sed
	script.
	* emultempl/gld960.em, emultempl/gld960c.em: Likewise.
	* emultempl/hppaelf.em, emultempl/linux.em: Likewise.
	* emultempl/lnk960.em, emultempl/sunos.em: Likewise.
	* configure, Makefile.in: Rebuild.
@
text
@d1032 1
a1032 1
  NULL, /* finish */
d1034 7
a1040 3
  NULL, /* open_dynamic_library */
  NULL, /* place_orphan */
  gld${EMULATION_NAME}_set_symbols
@


1.2
log
@        * emultempl/armelf.em: Watch EMULATION_LIBPATH instead of
        DEFAULT_EMULATION.
        * emultempl/elf32.em: Likewise.
        * emultempl/sunos.em: Likewise.
@
text
@d974 1
a974 5
sc='s/["\\]/\\&/g
s/$/\\n\\/
1s/^/"/
$s/$/n"/
'
d981 1
a981 10
    return `sed "$sc" ldscripts/${EMULATION_NAME}.xu`;
  else if (link_info.relocateable == true)
    return `sed "$sc" ldscripts/${EMULATION_NAME}.xr`;
  else if (!config.text_read_only)
    return `sed "$sc" ldscripts/${EMULATION_NAME}.xbn`;
  else if (!config.magic_demand_paged)
    return `sed "$sc" ldscripts/${EMULATION_NAME}.xn`;
  else
    return `sed "$sc" ldscripts/${EMULATION_NAME}.x`;
}
d983 10
@


1.1
log
@Initial revision
@
text
@d103 2
a104 1
  if [ "x${DEFAULT_EMULATION}" = "x${EMULATION_NAME}" ] ; then
d129 2
a130 1
  fi
d469 2
a470 1
  if [ "x${DEFAULT_EMULATION}" = "x${EMULATION_NAME}" ] ; then
d480 2
a481 1
  fi
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

