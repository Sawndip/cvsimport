head	1.62;
access;
symbols
	binutils-2_24-branch:1.61.0.2
	binutils-2_24-branchpoint:1.61
	binutils-2_21_1:1.55.2.2
	binutils-2_23_2:1.60
	binutils-2_23_1:1.60
	binutils-2_23:1.60
	binutils-2_23-branch:1.60.0.2
	binutils-2_23-branchpoint:1.60
	binutils-2_22_branch:1.58.0.4
	binutils-2_22:1.58
	binutils-2_22-branch:1.58.0.2
	binutils-2_22-branchpoint:1.58
	binutils-2_21:1.55
	binutils-2_21-branch:1.55.0.2
	binutils-2_21-branchpoint:1.55
	binutils-2_20_1:1.53
	binutils-2_20:1.53
	binutils-arc-20081103-branch:1.47.0.6
	binutils-arc-20081103-branchpoint:1.47
	binutils-2_20-branch:1.53.0.2
	binutils-2_20-branchpoint:1.53
	dje-cgen-play1-branch:1.52.0.2
	dje-cgen-play1-branchpoint:1.52
	arc-20081103-branch:1.47.0.4
	arc-20081103-branchpoint:1.47
	binutils-2_19_1:1.47
	binutils-2_19:1.47
	binutils-2_19-branch:1.47.0.2
	binutils-2_19-branchpoint:1.47
	binutils-2_18:1.46
	binutils-2_18-branch:1.46.0.2
	binutils-2_18-branchpoint:1.46
	binutils-csl-coldfire-4_1-32:1.41
	binutils-csl-sourcerygxx-4_1-32:1.41
	binutils-csl-innovasic-fido-3_4_4-33:1.41
	binutils-csl-sourcerygxx-3_4_4-32:1.36
	binutils-csl-coldfire-4_1-30:1.41
	binutils-csl-sourcerygxx-4_1-30:1.41
	binutils-csl-coldfire-4_1-28:1.41
	binutils-csl-sourcerygxx-4_1-29:1.41
	binutils-csl-sourcerygxx-4_1-28:1.41
	binutils-csl-arm-2006q3-27:1.41
	binutils-csl-sourcerygxx-4_1-27:1.41
	binutils-csl-arm-2006q3-26:1.41
	binutils-csl-sourcerygxx-4_1-26:1.41
	binutils-csl-sourcerygxx-4_1-25:1.41
	binutils-csl-sourcerygxx-4_1-24:1.41
	binutils-csl-sourcerygxx-4_1-23:1.41
	binutils-csl-sourcerygxx-4_1-21:1.41
	binutils-csl-arm-2006q3-21:1.41
	binutils-csl-sourcerygxx-4_1-22:1.41
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.41
	binutils-csl-sourcerygxx-4_1-20:1.41
	binutils-csl-arm-2006q3-19:1.41
	binutils-csl-sourcerygxx-4_1-19:1.41
	binutils-csl-sourcerygxx-4_1-18:1.41
	binutils-csl-renesas-4_1-9:1.41
	binutils-csl-sourcerygxx-3_4_4-25:1.36
	binutils-csl-renesas-4_1-8:1.41
	binutils-csl-renesas-4_1-7:1.41
	binutils-csl-renesas-4_1-6:1.41
	binutils-csl-sourcerygxx-4_1-17:1.41
	binutils-csl-sourcerygxx-4_1-14:1.41
	binutils-csl-sourcerygxx-4_1-15:1.41
	binutils-csl-sourcerygxx-4_1-13:1.41
	binutils-2_17:1.41
	binutils-csl-sourcerygxx-4_1-12:1.41
	binutils-csl-sourcerygxx-3_4_4-21:1.41
	binutils-csl-wrs-linux-3_4_4-24:1.36
	binutils-csl-wrs-linux-3_4_4-23:1.36
	binutils-csl-sourcerygxx-4_1-9:1.41
	binutils-csl-sourcerygxx-4_1-8:1.41
	binutils-csl-sourcerygxx-4_1-7:1.41
	binutils-csl-arm-2006q1-6:1.41
	binutils-csl-sourcerygxx-4_1-6:1.41
	binutils-csl-wrs-linux-3_4_4-22:1.36
	binutils-csl-coldfire-4_1-11:1.41
	binutils-csl-sourcerygxx-3_4_4-19:1.41
	binutils-csl-coldfire-4_1-10:1.41
	binutils-csl-sourcerygxx-4_1-5:1.41
	binutils-csl-sourcerygxx-4_1-4:1.41
	binutils-csl-wrs-linux-3_4_4-21:1.36
	binutils-csl-morpho-4_1-4:1.41
	binutils-csl-sourcerygxx-3_4_4-17:1.41
	binutils-csl-wrs-linux-3_4_4-20:1.36
	binutils-2_17-branch:1.41.0.4
	binutils-2_17-branchpoint:1.41
	binutils-csl-2_17-branch:1.41.0.2
	binutils-csl-2_17-branchpoint:1.41
	binutils-csl-gxxpro-3_4-branch:1.36.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.36
	binutils-2_16_1:1.36
	binutils-csl-arm-2005q1b:1.36
	binutils-2_16:1.36
	binutils-csl-arm-2005q1a:1.36
	binutils-csl-arm-2005q1-branch:1.36.0.4
	binutils-csl-arm-2005q1-branchpoint:1.36
	binutils-2_16-branch:1.36.0.2
	binutils-2_16-branchpoint:1.36
	csl-arm-2004-q3d:1.35
	csl-arm-2004-q3:1.34
	binutils-2_15:1.34
	binutils-2_15-branchpoint:1.34
	csl-arm-2004-q1a:1.34
	csl-arm-2004-q1:1.34
	binutils-2_15-branch:1.34.0.6
	cagney_bfdfile-20040213-branch:1.34.0.4
	cagney_bfdfile-20040213-branchpoint:1.34
	cagney_bigcore-20040122-branch:1.34.0.2
	cagney_bigcore-20040122-branchpoint:1.34
	csl-arm-2003-q4:1.33
	binutils-2_14:1.31
	binutils-2_14-branch:1.31.0.2
	binutils-2_14-branchpoint:1.31
	binutils-2_13_2_1:1.26.2.2
	binutils-2_13_2:1.26.2.2
	binutils-2_13_1:1.26.2.2
	binutils-2_13:1.26
	binutils-2_13-branchpoint:1.26
	binutils-2_13-branch:1.26.0.2
	binutils-2_12_1:1.18
	binutils-2_12:1.18
	binutils-2_12-branch:1.18.0.2
	binutils-2_12-branchpoint:1.18
	cygnus_cvs_20020108_pre:1.18
	binutils-2_11_2:1.4.2.2
	binutils-2_11_1:1.4.2.2
	binutils-2_11:1.4
	x86_64versiong3:1.4
	binutils-2_11-branch:1.4.0.2
	binutils-2_10_1:1.3
	binutils-2_10:1.3
	binutils-2_10-branch:1.3.0.2
	binutils-2_10-branchpoint:1.3
	binutils_latest_snapshot:1.62
	repo-unification-2000-02-06:1.2
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@# @;


1.62
date	2013.10.14.09.15.09;	author nickc;	state Exp;
branches;
next	1.61;

1.61
date	2013.01.10.20.08.03;	author hjl;	state Exp;
branches;
next	1.60;

1.60
date	2012.03.05.22.43.40;	author amodra;	state Exp;
branches;
next	1.59;

1.59
date	2011.11.02.16.28.31;	author gingold;	state Exp;
branches;
next	1.58;

1.58
date	2011.04.20.13.43.24;	author gingold;	state Exp;
branches;
next	1.57;

1.57
date	2010.12.20.13.00.14;	author amodra;	state Exp;
branches;
next	1.56;

1.56
date	2010.12.06.00.07.06;	author hjl;	state Exp;
branches;
next	1.55;

1.55
date	2010.10.28.06.45.33;	author amodra;	state Exp;
branches
	1.55.2.1;
next	1.54;

1.54
date	2010.06.27.04.07.54;	author amodra;	state Exp;
branches;
next	1.53;

1.53
date	2009.09.02.07.25.35;	author amodra;	state Exp;
branches;
next	1.52;

1.52
date	2009.04.01.19.53.52;	author rsandifo;	state Exp;
branches;
next	1.51;

1.51
date	2009.03.14.09.35.45;	author rsandifo;	state Exp;
branches;
next	1.50;

1.50
date	2009.03.14.09.17.32;	author rsandifo;	state Exp;
branches;
next	1.49;

1.49
date	2009.03.14.09.15.12;	author rsandifo;	state Exp;
branches;
next	1.48;

1.48
date	2009.03.14.09.14.29;	author rsandifo;	state Exp;
branches;
next	1.47;

1.47
date	2008.02.15.03.35.53;	author amodra;	state Exp;
branches;
next	1.46;

1.46
date	2007.07.19.19.56.10;	author roland;	state Exp;
branches;
next	1.45;

1.45
date	2007.07.06.14.09.42;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	2007.04.26.14.46.59;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2007.03.07.07.52.09;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	2006.09.16.18.12.16;	author nickc;	state Exp;
branches;
next	1.41;

1.41
date	2005.08.04.06.22.13;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2005.08.04.01.19.09;	author amodra;	state Exp;
branches;
next	1.39;

1.39
date	2005.07.15.12.19.14;	author amodra;	state Exp;
branches;
next	1.38;

1.38
date	2005.05.12.07.32.03;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	2005.05.04.11.00.27;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2005.03.03.11.52.03;	author amodra;	state Exp;
branches;
next	1.35;

1.35
date	2004.10.27.15.53.21;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	2004.01.03.11.09.07;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.27.00.38.25;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2003.06.25.06.40.26;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2003.02.28.01.32.30;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2002.11.30.08.39.46;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2002.10.30.03.57.39;	author drow;	state Exp;
branches;
next	1.28;

1.28
date	2002.08.28.01.55.46;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2002.08.06.11.40.30;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2002.07.01.08.07.31;	author amodra;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	2002.05.22.09.04.47;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2002.05.18.16.56.27;	author trix;	state Exp;
branches;
next	1.23;

1.23
date	2002.05.10.21.20.16;	author trix;	state Exp;
branches;
next	1.22;

1.22
date	2002.05.01.02.52.17;	author trix;	state Exp;
branches;
next	1.21;

1.21
date	2002.04.30.23.29.21;	author trix;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.18.12.46.27;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.19.05.01.40;	author trix;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.22.17.18.34;	author trix;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.05.13.34.46;	author trix;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.03.23.15.27;	author trix;	state Exp;
branches;
next	1.15;

1.15
date	2001.09.19.05.33.35;	author hjl;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.06.15.20.01;	author trix;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.03.06.43.36;	author aj;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.18.15.42.26;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.04.04.14.10;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.08.01.58.20;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.25.21.19.46;	author hjl;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.25.05.39.22;	author hjl;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.24.20.59.22;	author trix;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.02.18.14.31;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.13.06.14.27;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.11.03.42.41;	author amodra;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2000.02.29.05.53.53;	author amodra;	state Exp;
branches;
next	1.2;

1.2
date	99.08.06.22.46.03;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.29.07;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.55.2.1
date	2011.02.01.12.25.47;	author amodra;	state Exp;
branches;
next	1.55.2.2;

1.55.2.2
date	2011.04.20.13.48.32;	author gingold;	state Exp;
branches;
next	;

1.26.2.1
date	2002.09.23.22.15.59;	author drow;	state Exp;
branches;
next	1.26.2.2;

1.26.2.2
date	2002.10.30.03.54.52;	author drow;	state Exp;
branches;
next	;

1.4.2.1
date	2001.06.07.03.17.16;	author amodra;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2001.06.08.02.01.12;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.07;	author rth;	state Exp;
branches;
next	;


desc
@@


1.62
log
@	* gen-aout.c (main): Fix formatting.  Close file.

	* emultempl/aix.em (_read_file): Close file at end of function.

	* gas/all/itbl-test.c (main): Close fas.

	* read.c (add_include_dir): Use xrealloc.
	* config/tc-score.c (do_macro_bcmp): Initialise inst_main.
	* config/tc-tic6x.c (tic6x_parse_operand): Initialise second_reg.

	* readelf.c (decode_arm_unwind): Initialise addr structure.
	(process_symbol_table): Free lengths.
	* srcconv.c (wr_sc): Free info.

	* chew.c (perform): Free next.
@
text
@# This shell script emits a C file. -*- C -*-
# It does some substitutions.
if [ -z "$MACHINE" ]; then
  OUTPUT_ARCH=${ARCH}
else
  OUTPUT_ARCH=${ARCH}:${MACHINE}
fi
fragment <<EOF
/* This file is is generated by a shell script.  DO NOT EDIT! */

/* AIX emulation code for ${EMULATION_NAME}
   Copyright 1991-2013 Free Software Foundation, Inc.
   Written by Steve Chamberlain <sac@@cygnus.com>
   AIX support by Ian Lance Taylor <ian@@cygnus.com>
   AIX 64 bit support by Tom Rix <trix@@redhat.com>

   This file is part of the GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#define TARGET_IS_${EMULATION_NAME}

#include "sysdep.h"
#include "bfd.h"
#include "libiberty.h"
#include "safe-ctype.h"
#include "getopt.h"
#include "obstack.h"
#include "bfdlink.h"

#include "ld.h"
#include "ldmain.h"
#include "ldmisc.h"
#include "ldexp.h"
#include "ldlang.h"
#include "ldfile.h"
#include "ldemul.h"
#include "ldctor.h"
#include <ldgram.h>

#include "coff/internal.h"
#include "coff/xcoff.h"
#include "libcoff.h"
#include "libxcoff.h"

static void gld${EMULATION_NAME}_read_file (const char *, bfd_boolean);
static void gld${EMULATION_NAME}_free (void *);
static void gld${EMULATION_NAME}_find_relocs (lang_statement_union_type *);
static void gld${EMULATION_NAME}_find_exp_assignment (etree_type *);


/* The file alignment required for each section.  */
static unsigned long file_align;

/* The maximum size the stack is permitted to grow.  This is stored in
   the a.out header.  */
static unsigned long maxstack;

/* The maximum data size.  This is stored in the a.out header.  */
static unsigned long maxdata;

/* Whether to perform garbage collection.  */
static int gc = 1;

/* The module type to use.  */
static unsigned short modtype = ('1' << 8) | 'L';

/* Whether the .text section must be read-only (i.e., no relocs
   permitted).  */
static int textro;

/* A mask of XCOFF_EXPALL and XCOFF_EXPFULL flags, as set by their
   associated -b and -bno options.  */
static unsigned int auto_export_flags;

/* A mask of auto_export_flags bits that were explicitly set on the
   command line.  */
static unsigned int explicit_auto_export_flags;

/* Whether to implement Unix like linker semantics.  */
static int unix_ld;

/* Structure used to hold import file list.  */

struct filelist
{
  struct filelist *next;
  const char *name;
};

/* List of import files.  */
static struct filelist *import_files;

/* List of export symbols read from the export files.  */

struct export_symbol_list
{
  struct export_symbol_list *next;
  const char *name;
};

static struct export_symbol_list *export_symbols;

/* Maintains the 32 or 64 bit mode state of import file */
static unsigned int symbol_mode = 0x04;

/* Which symbol modes are valid */
static unsigned int symbol_mode_mask = 0x0d;

/* Whether this is a 64 bit link */
static int is_64bit = 0;

/* Which syscalls from import file are valid */
static unsigned int syscall_mask = 0x77;

/* fake file for -binitfini support */
static lang_input_statement_type *initfini_file;

/* Whether to do run time linking
   -brtl enables, -bnortl and -bnortllib disable. */
static int rtld;

/* Explicit command line library path, -blibpath */
static char *command_line_blibpath = NULL;

/* This routine is called before anything else is done.  */

static void
gld${EMULATION_NAME}_before_parse (void)
{
  ldfile_set_output_arch ("${OUTPUT_ARCH}", bfd_arch_`echo ${ARCH} | sed -e 's/:.*//'`);

  input_flags.dynamic = TRUE;
  config.has_shared = TRUE;

  /* The link_info.[init|fini]_functions are initialized in ld/lexsup.c.
     Override them here so we can use the link_info.init_function as a
     state flag that lets the backend know that -binitfini has been done.  */

  link_info.init_function = NULL;
  link_info.fini_function = NULL;
}

/* Handle AIX specific options.  */

enum
  {
    OPTION_IGNORE = 300,
    OPTION_AUTOIMP,
    OPTION_ERNOTOK,
    OPTION_EROK,
    OPTION_EXPALL,
    OPTION_EXPFULL,
    OPTION_EXPORT,
    OPTION_IMPORT,
    OPTION_INITFINI,
    OPTION_LOADMAP,
    OPTION_MAXDATA,
    OPTION_MAXSTACK,
    OPTION_MODTYPE,
    OPTION_NOAUTOIMP,
    OPTION_NOEXPALL,
    OPTION_NOEXPFULL,
    OPTION_NOSTRCMPCT,
    OPTION_PD,
    OPTION_PT,
    OPTION_STRCMPCT,
    OPTION_UNIX,
    OPTION_32,
    OPTION_64,
    OPTION_LIBPATH,
    OPTION_NOLIBPATH,
  };

static void
gld${EMULATION_NAME}_add_options
  (int ns, char **shortopts, int nl, struct option **longopts,
   int nrl ATTRIBUTE_UNUSED, struct option **really_longopts ATTRIBUTE_UNUSED)
{
  static const char xtra_short[] = "D:H:KT:z";
  static const struct option xtra_long[] = {
  /* -binitfini has special handling in the linker backend.  The native linker
     uses the arguemnts to generate a table of init and fini functions for
     the executable.  The important use for this option is to support aix 4.2+
     c++ constructors and destructors.  This is tied into gcc via collect2.c.

     The function table is accessed by the runtime linker/loader by checking if
     the first symbol in the loader symbol table is __rtinit.  The gnu linker
     generates this symbol and makes it the first loader symbol.  */

    {"basis", no_argument, NULL, OPTION_IGNORE},
    {"bautoimp", no_argument, NULL, OPTION_AUTOIMP},
    {"bcomprld", no_argument, NULL, OPTION_IGNORE},
    {"bcrld", no_argument, NULL, OPTION_IGNORE},
    {"bcror31", no_argument, NULL, OPTION_IGNORE},
    {"bD", required_argument, NULL, OPTION_MAXDATA},
    {"bE", required_argument, NULL, OPTION_EXPORT},
    {"bernotok", no_argument, NULL, OPTION_ERNOTOK},
    {"berok", no_argument, NULL, OPTION_EROK},
    {"berrmsg", no_argument, NULL, OPTION_IGNORE},
    {"bexpall", no_argument, NULL, OPTION_EXPALL},
    {"bexpfull", no_argument, NULL, OPTION_EXPFULL},
    {"bexport", required_argument, NULL, OPTION_EXPORT},
    {"bbigtoc", no_argument, NULL, OPTION_IGNORE},
    {"bf", no_argument, NULL, OPTION_ERNOTOK},
    {"bgc", no_argument, &gc, 1},
    {"bh", required_argument, NULL, OPTION_IGNORE},
    {"bhalt", required_argument, NULL, OPTION_IGNORE},
    {"bI", required_argument, NULL, OPTION_IMPORT},
    {"bimport", required_argument, NULL, OPTION_IMPORT},
    {"binitfini", required_argument, NULL, OPTION_INITFINI},
    {"bl", required_argument, NULL, OPTION_LOADMAP},
    {"bloadmap", required_argument, NULL, OPTION_LOADMAP},
    {"bmaxdata", required_argument, NULL, OPTION_MAXDATA},
    {"bmaxstack", required_argument, NULL, OPTION_MAXSTACK},
    {"bM", required_argument, NULL, OPTION_MODTYPE},
    {"bmodtype", required_argument, NULL, OPTION_MODTYPE},
    {"bnoautoimp", no_argument, NULL, OPTION_NOAUTOIMP},
    {"bnoexpall", no_argument, NULL, OPTION_NOEXPALL},
    {"bnoexpfull", no_argument, NULL, OPTION_NOEXPFULL},
    {"bnodelcsect", no_argument, NULL, OPTION_IGNORE},
    {"bnoentry", no_argument, NULL, OPTION_IGNORE},
    {"bnogc", no_argument, &gc, 0},
    {"bnso", no_argument, NULL, OPTION_NOAUTOIMP},
    {"bnostrcmpct", no_argument, NULL, OPTION_NOSTRCMPCT},
    {"bnotextro", no_argument, &textro, 0},
    {"bnro", no_argument, &textro, 0},
    {"bpD", required_argument, NULL, OPTION_PD},
    {"bpT", required_argument, NULL, OPTION_PT},
    {"bro", no_argument, &textro, 1},
    {"brtl", no_argument, &rtld, 1},
    {"bnortl", no_argument, &rtld, 0},
    {"bnortllib", no_argument, &rtld, 0},
    {"bS", required_argument, NULL, OPTION_MAXSTACK},
    {"bso", no_argument, NULL, OPTION_AUTOIMP},
    {"bstrcmpct", no_argument, NULL, OPTION_STRCMPCT},
    {"btextro", no_argument, &textro, 1},
    {"b32", no_argument, NULL, OPTION_32},
    {"b64", no_argument, NULL, OPTION_64},
    {"static", no_argument, NULL, OPTION_NOAUTOIMP},
    {"unix", no_argument, NULL, OPTION_UNIX},
    {"blibpath", required_argument, NULL, OPTION_LIBPATH},
    {"bnolibpath", required_argument, NULL, OPTION_NOLIBPATH},
    {NULL, no_argument, NULL, 0}
  };

  /* Options supported by the AIX linker which we do not support:
     -S, -v, -Z, -bbindcmds, -bbinder, -bbindopts, -bcalls, -bcaps,
     -bcror15, -bdebugopt, -bdbg, -bdelcsect, -bex?, -bfilelist, -bfl,
     -bgcbypass, -bglink, -binsert, -bi, -bloadmap, -bl, -bmap, -bnl,
     -bnobind, -bnocomprld, -bnocrld, -bnoerrmsg, -bnoglink,
     -bnoloadmap, -bnl, -bnoobjreorder, -bnoquiet, -bnoreorder,
     -bnotypchk, -bnox, -bquiet, -bR, -brename, -breorder, -btypchk,
     -bx, -bX, -bxref.  */

  *shortopts = (char *) xrealloc (*shortopts, ns + sizeof (xtra_short));
  memcpy (*shortopts + ns, &xtra_short, sizeof (xtra_short));
  *longopts = xrealloc (*longopts,
			nl * sizeof (struct option) + sizeof (xtra_long));
  memcpy (*longopts + nl, &xtra_long, sizeof (xtra_long));
}

static bfd_boolean
gld${EMULATION_NAME}_parse_args (int argc, char **argv)
{
  int indx;

  /* If the current option starts with -b, change the first : to an =.
     The AIX linker uses : to separate the option from the argument;
     changing it to = lets us treat it as a getopt option.  */
  indx = optind;
  if (indx == 0)
    indx = 1;

  if (indx < argc && CONST_STRNEQ (argv[indx], "-b"))
    {
      char *s;

      for (s = argv[indx]; *s != '\0'; s++)
	{
	  if (*s == ':')
	    {
	      *s = '=';
	      break;
	    }
	}
    }
  return FALSE;
}

/* Helper for option '-f', which specify a list of input files.
   Contrary to the native linker, we don't support shell patterns
   (simply because glob isn't always available).  */

static void
read_file_list (const char *filename)
{
  FILE *f;
  /* An upper bound on the number of characters in the file.  */
  long pos;
  /* File in memory.  */
  char *buffer;
  size_t len;
  char *b;
  char *e;

  f = fopen (filename, FOPEN_RT);
  if (f == NULL)
    {
      einfo ("%F%P: cannot open %s\n", filename);
      return;
    }
  if (fseek (f, 0L, SEEK_END) == -1)
    goto error;
  pos = ftell (f);
  if (pos == -1)
    goto error;
  if (fseek (f, 0L, SEEK_SET) == -1)
    goto error;

  buffer = (char *) xmalloc (pos + 1);
  len = fread (buffer, sizeof (char), pos, f);
  if (len != (size_t) pos && ferror (f))
    goto error;
  /* Add a NUL terminator.  */
  buffer[len] = '\0';
  fclose (f);

  /* Parse files.  */
  b = buffer;
  while (1)
    {
      /* Skip empty lines.  */
      while (*b == '\n' || *b == '\r')
        b++;

      /* Stop if end of buffer.  */
      if (b == buffer + len)
        break;

      /* Eat any byte until end of line.  */
      for (e = b; *e != '\0'; e++)
        if (*e == '\n' || *e == '\r')
          break;

      /* Replace end of line by nul.  */
      if (*e != '\0')
        *e++ = '\0';

      if (b != e)
        lang_add_input_file (b, lang_input_file_is_search_file_enum, NULL);
      b = e;
    }
  return;

 error:
  einfo ("%F%P: cannot read %s\n", optarg);
  fclose (f);
}

static bfd_boolean
gld${EMULATION_NAME}_handle_option (int optc)
{
  bfd_signed_vma val;
  const char *end;

  switch (optc)
    {
    default:
      return FALSE;

    case 0:
      /* Long option which just sets a flag.  */
      break;

    case 'f':
      /* This overrides --auxiliary.  This option specifies a file containing
         a list of input files.  */
      read_file_list (optarg);
      break;

    case 'D':
      val = bfd_scan_vma (optarg, &end, 0);
      if (*end != '\0')
	einfo ("%P: warning: ignoring invalid -D number %s\n", optarg);
      else if (val != -1)
	lang_section_start (".data", exp_intop (val), NULL);
      break;

    case 'H':
      val = bfd_scan_vma (optarg, &end, 0);
      if (*end != '\0' || (val & (val - 1)) != 0)
	einfo ("%P: warning: ignoring invalid -H number %s\n", optarg);
      else
	file_align = val;
      break;

    case 'K':
    case 'z':
      /* FIXME: This should use the page size for the target system.  */
      file_align = 4096;
      break;

    case 'T':
      /* On AIX this is the same as GNU ld -Ttext.  When we see -T
	 number, we assume the AIX option is intended.  Otherwise, we
	 assume the usual GNU ld -T option is intended.  We can't just
	 ignore the AIX option, because gcc passes it to the linker.  */
      val = bfd_scan_vma (optarg, &end, 0);
      if (*end != '\0')
	return FALSE;
      lang_section_start (".text", exp_intop (val), NULL);
      break;

    case OPTION_IGNORE:
      break;

    case OPTION_INITFINI:
      {
	/*
	 * The aix linker init fini has the format :
	 *
	 * -binitfini:[ Initial][:Termination][:Priority]
	 *
	 * it allows the Termination and Priority to be optional.
	 *
	 * Since we support only one init/fini pair, we ignore the Priority.
	 *
	 * Define the special symbol __rtinit.
	 *
	 * strtok does not correctly handle the case of -binitfini::fini: so
	 * do it by hand
	 */
	char *t, *i, *f;

	i = t = optarg;
	while (*t && ':' != *t)
	  t++;
	if (*t)
	  *t++ = 0;

	if (0 != strlen (i))
	  link_info.init_function = i;

	f = t;
	while (*t && ':' != *t)
	  t++;
	*t = 0;

	if (0 != strlen (f))
	  link_info.fini_function = f;
      }
      break;

    case OPTION_AUTOIMP:
      link_info.static_link = FALSE;
      break;

    case OPTION_ERNOTOK:
      link_info.unresolved_syms_in_objects = RM_GENERATE_ERROR;
      link_info.unresolved_syms_in_shared_libs = RM_GENERATE_ERROR;
      break;

    case OPTION_EROK:
      link_info.unresolved_syms_in_objects = RM_IGNORE;
      link_info.unresolved_syms_in_shared_libs = RM_IGNORE;
      break;

    case OPTION_EXPALL:
      auto_export_flags |= XCOFF_EXPALL;
      explicit_auto_export_flags |= XCOFF_EXPALL;
      break;

    case OPTION_EXPFULL:
      auto_export_flags |= XCOFF_EXPFULL;
      explicit_auto_export_flags |= XCOFF_EXPFULL;
      break;

    case OPTION_EXPORT:
      gld${EMULATION_NAME}_read_file (optarg, FALSE);
      break;

    case OPTION_IMPORT:
      {
	struct filelist *n;
	struct filelist **flpp;

	n = (struct filelist *) xmalloc (sizeof (struct filelist));
	n->next = NULL;
	n->name = optarg;
	flpp = &import_files;
	while (*flpp != NULL)
	  flpp = &(*flpp)->next;
	*flpp = n;
      }
      break;

    case OPTION_LOADMAP:
      config.map_filename = optarg;
      break;

    case OPTION_MAXDATA:
      val = bfd_scan_vma (optarg, &end, 0);
      if (*end != '\0')
	einfo ("%P: warning: ignoring invalid -bmaxdata number %s\n", optarg);
      else
	maxdata = val;
      break;

    case OPTION_MAXSTACK:
      val = bfd_scan_vma (optarg, &end, 0);
      if (*end != '\0')
	einfo ("%P: warning: ignoring invalid -bmaxstack number %s\n",
	       optarg);
      else
	maxstack = val;
      break;

    case OPTION_MODTYPE:
      if (*optarg == 'S')
	{
	  link_info.shared = TRUE;
	  ++optarg;
	}
      if (*optarg == '\0' || optarg[1] == '\0')
	einfo ("%P: warning: ignoring invalid module type %s\n", optarg);
      else
	modtype = (*optarg << 8) | optarg[1];
      break;

    case OPTION_NOAUTOIMP:
      link_info.static_link = TRUE;
      break;

    case OPTION_NOEXPALL:
      auto_export_flags &= ~XCOFF_EXPALL;
      explicit_auto_export_flags |= XCOFF_EXPALL;
      break;

    case OPTION_NOEXPFULL:
      auto_export_flags &= ~XCOFF_EXPFULL;
      explicit_auto_export_flags |= XCOFF_EXPFULL;
      break;

    case OPTION_NOSTRCMPCT:
      link_info.traditional_format = TRUE;
      break;

    case OPTION_PD:
      /* This sets the page that the .data section is supposed to
	 start on.  The offset within the page should still be the
	 offset within the file, so we need to build an appropriate
	 expression.  */
      val = bfd_scan_vma (optarg, &end, 0);
      if (*end != '\0')
	einfo ("%P: warning: ignoring invalid -pD number %s\n", optarg);
      else
	{
	  etree_type *t;

	  t = exp_binop ('+',
			 exp_intop (val),
			 exp_binop ('&',
				    exp_nameop (NAME, "."),
				    exp_intop (0xfff)));
	  t = exp_binop ('&',
			 exp_binop ('+', t, exp_intop (31)),
			 exp_intop (~(bfd_vma) 31));
	  lang_section_start (".data", t, NULL);
	}
      break;

    case OPTION_PT:
      /* This set the page that the .text section is supposed to start
	 on.  The offset within the page should still be the offset
	 within the file.  */
      val = bfd_scan_vma (optarg, &end, 0);
      if (*end != '\0')
	einfo ("%P: warning: ignoring invalid -pT number %s\n", optarg);
      else
	{
	  etree_type *t;

	  t = exp_binop ('+',
			 exp_intop (val),
			 exp_nameop (SIZEOF_HEADERS, NULL));
	  t = exp_binop ('&',
			 exp_binop ('+', t, exp_intop (31)),
			 exp_intop (~(bfd_vma) 31));
	  lang_section_start (".text", t, NULL);
	}
      break;

    case OPTION_STRCMPCT:
      link_info.traditional_format = FALSE;
      break;

    case OPTION_UNIX:
      unix_ld = TRUE;
      break;

    case OPTION_32:
      is_64bit = 0;
      syscall_mask = 0x77;
      symbol_mode_mask = 0x0d;
      break;

    case OPTION_64:
      is_64bit = 1;
      syscall_mask = 0xcc;
      symbol_mode_mask = 0x0e;
      break;

    case OPTION_LIBPATH:
      command_line_blibpath = optarg;
      break;

    case OPTION_NOLIBPATH:
      command_line_blibpath = NULL;
      break;

    }

  return TRUE;
}

/* This is called when an input file can not be recognized as a BFD
   object or an archive.  If the file starts with #!, we must treat it
   as an import file.  This is for AIX compatibility.  */

static bfd_boolean
gld${EMULATION_NAME}_unrecognized_file (lang_input_statement_type *entry)
{
  FILE *e;
  bfd_boolean ret;

  e = fopen (entry->filename, FOPEN_RT);
  if (e == NULL)
    return FALSE;

  ret = FALSE;

  if (getc (e) == '#' && getc (e) == '!')
    {
      struct filelist *n;
      struct filelist **flpp;

      n = (struct filelist *) xmalloc (sizeof (struct filelist));
      n->next = NULL;
      n->name = entry->filename;
      flpp = &import_files;
      while (*flpp != NULL)
	flpp = &(*flpp)->next;
      *flpp = n;

      ret = TRUE;
      entry->flags.loaded = TRUE;
    }

  fclose (e);

  return ret;
}

/* This is called after the input files have been opened.  */

static void
gld${EMULATION_NAME}_after_open (void)
{
  bfd_boolean r;
  struct set_info *p;

  after_open_default ();

  /* Call ldctor_build_sets, after pretending that this is a
     relocatable link.  We do this because AIX requires relocation
     entries for all references to symbols, even in a final
     executable.  Of course, we only want to do this if we are
     producing an XCOFF output file.  */
  r = link_info.relocatable;
  if (strstr (bfd_get_target (link_info.output_bfd), "xcoff") != NULL)
    link_info.relocatable = TRUE;
  ldctor_build_sets ();
  link_info.relocatable = r;

  /* For each set, record the size, so that the XCOFF backend can
     output the correct csect length.  */
  for (p = sets; p != (struct set_info *) NULL; p = p->next)
    {
      bfd_size_type size;

      /* If the symbol is defined, we may have been invoked from
	 collect, and the sets may already have been built, so we do
	 not do anything.  */
      if (p->h->type == bfd_link_hash_defined
	  || p->h->type == bfd_link_hash_defweak)
	continue;

      if (p->reloc != BFD_RELOC_CTOR)
	{
	  /* Handle this if we need to.  */
	  abort ();
	}

      size = (p->count + 2) * 4;
      if (!bfd_xcoff_link_record_set (link_info.output_bfd, &link_info,
				      p->h, size))
	einfo ("%F%P: bfd_xcoff_link_record_set failed: %E\n");
    }
}

/* This is called after the sections have been attached to output
   sections, but before any sizes or addresses have been set.  */

static void
gld${EMULATION_NAME}_before_allocation (void)
{
  struct filelist *fl;
  struct export_symbol_list *el;
  char *libpath;
  asection *special_sections[XCOFF_NUMBER_OF_SPECIAL_SECTIONS];
  static const char *const must_keep_sections[] = {
    ".text",
    ".data",
    ".bss"
  };
  unsigned int i, flags;

  /* Handle the import and export files, if any.  */
  for (fl = import_files; fl != NULL; fl = fl->next)
    gld${EMULATION_NAME}_read_file (fl->name, TRUE);
  for (el = export_symbols; el != NULL; el = el->next)
    {
      struct bfd_link_hash_entry *h;

      h = bfd_link_hash_lookup (link_info.hash, el->name, FALSE, FALSE, FALSE);
      if (h == NULL)
	einfo ("%P%F: bfd_link_hash_lookup of export symbol failed: %E\n");
      if (!bfd_xcoff_export_symbol (link_info.output_bfd, &link_info, h))
	einfo ("%P%F: bfd_xcoff_export_symbol failed: %E\n");
    }

  /* Track down all relocations called for by the linker script (these
     are typically constructor/destructor entries created by
     CONSTRUCTORS) and let the backend know it will need to create
     .loader relocs for them.  */
  lang_for_each_statement (gld${EMULATION_NAME}_find_relocs);

  /* Precedence of LIBPATH
     -blibpath:	 native support always first
     -rpath:	 gnu extension
     -L		 build from command line -L's */
  if (command_line_blibpath != NULL)
    libpath = command_line_blibpath;
  else if (command_line.rpath != NULL)
    libpath = command_line.rpath;
  else if (search_head == NULL)
    libpath = (char *) "";
  else
    {
      size_t len;
      search_dirs_type *search;

      /* PR ld/4023: Strip sysroot prefix from any paths
	 being inserted into the output binary's DT_RPATH.  */
      if (ld_sysroot != NULL
	  && * ld_sysroot != 0)
	{
	  const char * name = search_head->name;
	  size_t ld_sysroot_len = strlen (ld_sysroot);

	  if (strncmp (name, ld_sysroot, ld_sysroot_len) == 0)
	    name += ld_sysroot_len;

	  len = strlen (name);
	  libpath = xmalloc (len + 1);
	  strcpy (libpath, name);

	  for (search = search_head->next; search != NULL; search = search->next)
	    {
	      size_t nlen;

	      name = search->name;
	      if (strncmp (name, ld_sysroot, ld_sysroot_len) == 0)
		name += ld_sysroot_len;

	      nlen = strlen (name);
	      libpath = xrealloc (libpath, len + nlen + 2);
	      libpath[len] = ':';
	      strcpy (libpath + len + 1, name);
	      len += nlen + 1;
	    }
	}
      else
	{
	  len = strlen (search_head->name);
	  libpath = xmalloc (len + 1);
	  strcpy (libpath, search_head->name);

	  for (search = search_head->next; search != NULL; search = search->next)
	    {
	      size_t nlen;

	      nlen = strlen (search->name);
	      libpath = xrealloc (libpath, len + nlen + 2);
	      libpath[len] = ':';
	      strcpy (libpath + len + 1, search->name);
	      len += nlen + 1;
	    }
	}
    }

  /* Default to -bexpfull for SVR4-like semantics.  */
  flags = (unix_ld ? XCOFF_EXPFULL : 0);
  flags &= ~explicit_auto_export_flags;
  flags |= auto_export_flags;

  /* Let the XCOFF backend set up the .loader section.  */
  if (!bfd_xcoff_size_dynamic_sections
      (link_info.output_bfd, &link_info, libpath, entry_symbol.name, file_align,
       maxstack, maxdata, gc && !unix_ld ? TRUE : FALSE,
       modtype, textro ? TRUE : FALSE, flags, special_sections,
       rtld ? TRUE : FALSE))
    einfo ("%P%F: failed to set dynamic section sizes: %E\n");

  /* Look through the special sections, and put them in the right
     place in the link ordering.  This is especially magic.  */
  for (i = 0; i < XCOFF_NUMBER_OF_SPECIAL_SECTIONS; i++)
    {
      asection *sec;
      lang_output_section_statement_type *os;
      lang_statement_union_type **pls;
      lang_input_section_type *is;
      const char *oname;
      bfd_boolean start;

      sec = special_sections[i];
      if (sec == NULL)
	continue;

      /* Remove this section from the list of the output section.
	 This assumes we know what the script looks like.  */
      is = NULL;
      os = lang_output_section_find (sec->output_section->name);
      if (os == NULL)
	einfo ("%P%F: can't find output section %s\n",
	       sec->output_section->name);

      for (pls = &os->children.head; *pls != NULL; pls = &(*pls)->header.next)
	{
	  if ((*pls)->header.type == lang_input_section_enum
	      && (*pls)->input_section.section == sec)
	    {
	      is = (lang_input_section_type *) * pls;
	      *pls = (*pls)->header.next;
	      break;
	    }

	  if ((*pls)->header.type == lang_wild_statement_enum)
	    {
	      lang_statement_union_type **pwls;

	      for (pwls = &(*pls)->wild_statement.children.head;
		   *pwls != NULL; pwls = &(*pwls)->header.next)
		{

		  if ((*pwls)->header.type == lang_input_section_enum
		      && (*pwls)->input_section.section == sec)
		    {
		      is = (lang_input_section_type *) * pwls;
		      *pwls = (*pwls)->header.next;
		      break;
		    }
		}

	      if (is != NULL)
		break;
	    }
	}

      if (is == NULL)
	{
	  einfo ("%P%F: can't find %s in output section\n",
		 bfd_get_section_name (sec->owner, sec));
	}

      /* Now figure out where the section should go.  */
      switch (i)
	{

	default:		/* to avoid warnings */
	case XCOFF_SPECIAL_SECTION_TEXT:
	  /* _text */
	  oname = ".text";
	  start = TRUE;
	  break;

	case XCOFF_SPECIAL_SECTION_ETEXT:
	  /* _etext */
	  oname = ".text";
	  start = FALSE;
	  break;

	case XCOFF_SPECIAL_SECTION_DATA:
	  /* _data */
	  oname = ".data";
	  start = TRUE;
	  break;

	case XCOFF_SPECIAL_SECTION_EDATA:
	  /* _edata */
	  oname = ".data";
	  start = FALSE;
	  break;

	case XCOFF_SPECIAL_SECTION_END:
	case XCOFF_SPECIAL_SECTION_END2:
	  /* _end and end */
	  oname = ".bss";
	  start = FALSE;
	  break;
	}

      os = lang_output_section_find (oname);

      if (start)
	{
	  is->header.next = os->children.head;
	  os->children.head = (lang_statement_union_type *) is;
	}
      else
	{
	  is->header.next = NULL;
	  lang_statement_append (&os->children,
				 (lang_statement_union_type *) is,
				 &is->header.next);
	}
    }

  /* Executables and shared objects must always have .text, .data
     and .bss output sections, so that the header can refer to them.
     The kernel refuses to load objects that have missing sections.  */
  if (!link_info.relocatable)
    for (i = 0; i < ARRAY_SIZE (must_keep_sections); i++)
      {
	asection *sec;

	sec = bfd_get_section_by_name (link_info.output_bfd,
				       must_keep_sections[i]);
	if (sec == NULL)
	  einfo ("%P: can't find required output section %s\n", must_keep_sections[i]);
	else
	  sec->flags |= SEC_KEEP;
      }

  before_allocation_default ();
}

static char *
gld${EMULATION_NAME}_choose_target (int argc, char **argv)
{
  int i, j, jmax;
  static char *from_outside;
  static char *from_inside;
  static char *argv_to_target[][2] = {
    {NULL,   "${OUTPUT_FORMAT}"},
    {"-b32", "${OUTPUT_FORMAT_32BIT}"},
    {"-b64", "${OUTPUT_FORMAT_64BIT}"},
  };

  jmax = 3;

  from_outside = getenv (TARGET_ENVIRON);
  if (from_outside != (char *) NULL)
    return from_outside;

  /* Set to default. */
  from_inside = argv_to_target[0][1];
  for (i = 1; i < argc; i++)
    {
      for (j = 1; j < jmax; j++)
	{
	  if (0 == strcmp (argv[i], argv_to_target[j][0]))
	    from_inside = argv_to_target[j][1];
	}
    }

  return from_inside;
}

/* Returns
   1 : state changed
   0 : no change */
static int
change_symbol_mode (char *input)
{
  char *symbol_mode_string[] = {
    "# 32",			/* 0x01 */
    "# 64",			/* 0x02 */
    "# no32",			/* 0x04 */
    "# no64",			/* 0x08 */
    NULL,
  };

  unsigned int bit;
  char *string;

  for (bit = 0;; bit++)
    {
      string = symbol_mode_string[bit];
      if (string == NULL)
	return 0;

      if (0 == strcmp (input, string))
	{
	  symbol_mode = (1 << bit);
	  return 1;
	}
    }
  /* should not be here */
  return 0;
}

/* Returns
   1 : yes
   0 : ignore
   -1 : error, try something else */
static int
is_syscall (char *input, unsigned int *flag)
{
  unsigned int bit;
  char *string;

  struct sc {
    char *syscall_string;
    unsigned int flag;
  } s [] = {
    { "svc"	    /* 0x01 */, XCOFF_SYSCALL32 },
    { "svc32"	    /* 0x02 */, XCOFF_SYSCALL32 },
    { "svc3264"     /* 0x04 */, XCOFF_SYSCALL32 | XCOFF_SYSCALL64 },
    { "svc64"	    /* 0x08 */, XCOFF_SYSCALL64 },
    { "syscall"     /* 0x10 */, XCOFF_SYSCALL32 },
    { "syscall32"   /* 0x20 */, XCOFF_SYSCALL32 },
    { "syscall3264" /* 0x40 */, XCOFF_SYSCALL32 | XCOFF_SYSCALL64 },
    { "syscall64"   /* 0x80 */, XCOFF_SYSCALL64 },
    { NULL, 0 },
  };

  *flag = 0;

  for (bit = 0;; bit++)
    {
      string = s[bit].syscall_string;
      if (string == NULL)
	return -1;

      if (0 == strcmp (input, string))
	{
	  if (1 << bit & syscall_mask)
	    {
	      *flag = s[bit].flag;
	      return 1;
	    }
	  else
	    {
	      return 0;
	    }
	}
    }
  /* should not be here */
  return -1;
}

/* Read an import or export file.  For an import file, this is called
   by the before_allocation emulation routine.  For an export file,
   this is called by the handle_option emulation routine.  */

static void
gld${EMULATION_NAME}_read_file (const char *filename, bfd_boolean import)
{
  struct obstack *o;
  FILE *f;
  int lineno;
  int c;
  bfd_boolean keep;
  const char *imppath;
  const char *impfile;
  const char *impmember;

  o = (struct obstack *) xmalloc (sizeof (struct obstack));
  obstack_specify_allocation (o, 0, 0, xmalloc, gld${EMULATION_NAME}_free);

  f = fopen (filename, FOPEN_RT);
  if (f == NULL)
    {
      bfd_set_error (bfd_error_system_call);
      einfo ("%F%s: %E\n", filename);
      return;
    }

  keep = FALSE;

  imppath = NULL;
  impfile = NULL;
  impmember = NULL;

  lineno = 0;

  /* Default to 32 and 64 bit mode
     symbols at top of /lib/syscalls.exp do not have a mode modifier and they
     are not repeated, assume 64 bit routines also want to use them.
     See the routine change_symbol_mode for more information.  */

  symbol_mode = 0x04;

  while ((c = getc (f)) != EOF)
    {
      char *s;
      char *symname;
      unsigned int syscall_flag = 0;
      bfd_vma address;
      struct bfd_link_hash_entry *h;

      if (c != '\n')
	{
	  obstack_1grow (o, c);
	  continue;
	}

      obstack_1grow (o, '\0');
      ++lineno;

      s = (char *) obstack_base (o);
      while (ISSPACE (*s))
	++s;
      if (*s == '\0'
	  || *s == '*'
	  || change_symbol_mode (s)
	  || (*s == '#' && s[1] == ' ')
	  || (!import && *s == '#' && s[1] == '!'))
	{
	  obstack_free (o, obstack_base (o));
	  continue;
	}

      if (*s == '#' && s[1] == '!')
	{
	  s += 2;
	  while (ISSPACE (*s))
	    ++s;
	  if (*s == '\0')
	    {
	      imppath = NULL;
	      impfile = NULL;
	      impmember = NULL;
	      obstack_free (o, obstack_base (o));
	    }
	  else if (*s == '(')
	    einfo ("%F%s%d: #! ([member]) is not supported in import files\n",
		   filename, lineno);
	  else
	    {
	      char cs;
	      char *start;

	      (void) obstack_finish (o);
	      keep = TRUE;
	      start = s;
	      while (!ISSPACE (*s) && *s != '(' && *s != '\0')
		++s;
	      cs = *s;
	      *s = '\0';
	      if (!bfd_xcoff_split_import_path (link_info.output_bfd,
						start, &imppath, &impfile))
		einfo ("%F%P: Could not parse import path: %E\n");
	      while (ISSPACE (cs))
		{
		  ++s;
		  cs = *s;
		}
	      if (cs != '(')
		{
		  impmember = "";
		  if (cs != '\0')
		    einfo ("%s:%d: warning: syntax error in import file\n",
			   filename, lineno);
		}
	      else
		{
		  ++s;
		  impmember = s;
		  while (*s != ')' && *s != '\0')
		    ++s;
		  if (*s == ')')
		    *s = '\0';
		  else
		    einfo ("%s:%d: warning: syntax error in import file\n",
			   filename, lineno);
		}
	    }

	  continue;
	}

      if (symbol_mode & symbol_mode_mask)
	{
	  /* This is a symbol to be imported or exported.  */
	  symname = s;
	  syscall_flag = 0;
	  address = (bfd_vma) -1;

	  while (!ISSPACE (*s) && *s != '\0')
	    ++s;
	  if (*s != '\0')
	    {
	      char *se;

	      *s++ = '\0';

	      while (ISSPACE (*s))
		++s;

	      se = s;
	      while (!ISSPACE (*se) && *se != '\0')
		++se;
	      if (*se != '\0')
		{
		  *se++ = '\0';
		  while (ISSPACE (*se))
		    ++se;
		  if (*se != '\0')
		    einfo ("%s%d: warning: syntax error in import/export file\n",
			   filename, lineno);
		}

	      if (s != se)
		{
		  int status;
		  const char *end;

		  status = is_syscall (s, &syscall_flag);

		  if (0 > status)
		    {
		      /* not a system call, check for address */
		      address = bfd_scan_vma (s, &end, 0);
		      if (*end != '\0')
			{
			  einfo ("%s:%d: warning: syntax error in import/export file\n",
				 filename, lineno);

			}
		    }
		}
	    }

	  if (!import)
	    {
	      struct export_symbol_list *n;

	      ldlang_add_undef (symname, TRUE);
	      n = ((struct export_symbol_list *)
		   xmalloc (sizeof (struct export_symbol_list)));
	      n->next = export_symbols;
	      n->name = xstrdup (symname);
	      export_symbols = n;
	    }
	  else
	    {
	      h = bfd_link_hash_lookup (link_info.hash, symname, FALSE, FALSE,
					TRUE);
	      if (h == NULL || h->type == bfd_link_hash_new)
		{
		  /* We can just ignore attempts to import an unreferenced
		     symbol.  */
		}
	      else
		{
		  if (!bfd_xcoff_import_symbol (link_info.output_bfd,
						&link_info, h,
						address, imppath, impfile,
						impmember, syscall_flag))
		    einfo ("%X%s:%d: failed to import symbol %s: %E\n",
			   filename, lineno, symname);
		}
	    }
	}
      obstack_free (o, obstack_base (o));
    }

  if (obstack_object_size (o) > 0)
    {
      einfo ("%s:%d: warning: ignoring unterminated last line\n",
	     filename, lineno);
      obstack_free (o, obstack_base (o));
    }

  if (!keep)
    {
      obstack_free (o, NULL);
      free (o);
    }

  fclose (f);
}

/* This routine saves us from worrying about declaring free.  */

static void
gld${EMULATION_NAME}_free (void *p)
{
  free (p);
}

/* This is called by the before_allocation routine via
   lang_for_each_statement.  It looks for relocations and assignments
   to symbols.  */

static void
gld${EMULATION_NAME}_find_relocs (lang_statement_union_type *s)
{
  if (s->header.type == lang_reloc_statement_enum)
    {
      lang_reloc_statement_type *rs;

      rs = &s->reloc_statement;
      if (rs->name == NULL)
	einfo ("%F%P: only relocations against symbols are permitted\n");
      if (!bfd_xcoff_link_count_reloc (link_info.output_bfd, &link_info,
				       rs->name))
	einfo ("%F%P: bfd_xcoff_link_count_reloc failed: %E\n");
    }

  if (s->header.type == lang_assignment_statement_enum)
    gld${EMULATION_NAME}_find_exp_assignment (s->assignment_statement.exp);
}

/* Look through an expression for an assignment statement.  */

static void
gld${EMULATION_NAME}_find_exp_assignment (etree_type *exp)
{
  struct bfd_link_hash_entry *h;

  switch (exp->type.node_class)
    {
    case etree_provide:
      h = bfd_link_hash_lookup (link_info.hash, exp->assign.dst,
				FALSE, FALSE, FALSE);
      if (h == NULL)
	break;
      /* Fall through.  */
    case etree_assign:
      if (strcmp (exp->assign.dst, ".") != 0)
	{
	  if (!bfd_xcoff_record_link_assignment (link_info.output_bfd,
						 &link_info,
						 exp->assign.dst))
	    einfo ("%P%F: failed to record assignment to %s: %E\n",
		   exp->assign.dst);
	}
      gld${EMULATION_NAME}_find_exp_assignment (exp->assign.src);
      break;

    case etree_binary:
      gld${EMULATION_NAME}_find_exp_assignment (exp->binary.lhs);
      gld${EMULATION_NAME}_find_exp_assignment (exp->binary.rhs);
      break;

    case etree_trinary:
      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.cond);
      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.lhs);
      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.rhs);
      break;

    case etree_unary:
      gld${EMULATION_NAME}_find_exp_assignment (exp->unary.child);
      break;

    default:
      break;
    }
}

static char *
gld${EMULATION_NAME}_get_script (int *isfile)
EOF

if test -n "$COMPILE_IN"
then
# Scripts compiled in.

# sed commands to quote an ld script as a C string.
sc="-f ${srcdir}/emultempl/ostring.sed"

fragment <<EOF
{
  *isfile = 0;

  if (link_info.relocatable && config.build_constructors)
    return
EOF
sed $sc ldscripts/${EMULATION_NAME}.xu		       >> e${EMULATION_NAME}.c
echo '  ; else if (link_info.relocatable) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xr		       >> e${EMULATION_NAME}.c
echo '  ; else if (!config.text_read_only) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xbn		       >> e${EMULATION_NAME}.c
echo '  ; else if (!config.magic_demand_paged) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xn		       >> e${EMULATION_NAME}.c
echo '  ; else return'				       >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.x		       >> e${EMULATION_NAME}.c
echo '; }'					       >> e${EMULATION_NAME}.c

else
# Scripts read from the filesystem.

fragment <<EOF
{
  *isfile = 1;

  if (link_info.relocatable && config.build_constructors)
    return "ldscripts/${EMULATION_NAME}.xu";
  else if (link_info.relocatable)
    return "ldscripts/${EMULATION_NAME}.xr";
  else if (!config.text_read_only)
    return "ldscripts/${EMULATION_NAME}.xbn";
  else if (!config.magic_demand_paged)
    return "ldscripts/${EMULATION_NAME}.xn";
  else
    return "ldscripts/${EMULATION_NAME}.x";
}
EOF

fi

fragment <<EOF

static void
gld${EMULATION_NAME}_create_output_section_statements (void)
{
  /* __rtinit */
  if ((bfd_get_flavour (link_info.output_bfd) == bfd_target_xcoff_flavour)
      && (link_info.init_function != NULL
	  || link_info.fini_function != NULL
	  || rtld))
    {
      initfini_file = lang_add_input_file ("initfini",
					   lang_input_file_is_file_enum,
					   NULL);

      initfini_file->the_bfd = bfd_create ("initfini", link_info.output_bfd);
      if (initfini_file->the_bfd == NULL
	  || ! bfd_set_arch_mach (initfini_file->the_bfd,
				  bfd_get_arch (link_info.output_bfd),
				  bfd_get_mach (link_info.output_bfd)))
	{
	  einfo ("%X%P: can not create BFD %E\n");
	  return;
	}

      /* Call backend to fill in the rest */
      if (! bfd_xcoff_link_generate_rtinit (initfini_file->the_bfd,
					    link_info.init_function,
					    link_info.fini_function,
					    rtld))
	{
	  einfo ("%X%P: can not create BFD %E\n");
	  return;
	}

      /* __rtld defined in /lib/librtl.a */
      if (rtld)
	lang_add_input_file ("rtl", lang_input_file_is_l_enum, NULL);
    }
}

static void
gld${EMULATION_NAME}_set_output_arch (void)
{
  bfd_set_arch_mach (link_info.output_bfd,
		     bfd_xcoff_architecture (link_info.output_bfd),
		     bfd_xcoff_machine (link_info.output_bfd));

  ldfile_output_architecture = bfd_get_arch (link_info.output_bfd);
  ldfile_output_machine = bfd_get_mach (link_info.output_bfd);
  ldfile_output_machine_name = bfd_printable_name (link_info.output_bfd);
}

static bfd_boolean
gld${EMULATION_NAME}_open_dynamic_archive (const char *arch,
					   search_dirs_type *search,
					   lang_input_statement_type *entry)
{
  char *path;

  if (!entry->flags.maybe_archive)
    return FALSE;

  path = concat (search->name, "/lib", entry->filename, arch, ".a", NULL);
  if (!ldfile_try_open_bfd (path, entry))
    {
      free (path);
      return FALSE;
    }
  /* Don't include the searched directory in the import path.  */
  bfd_xcoff_set_archive_import_path (&link_info, entry->the_bfd,
				     path + strlen (search->name) + 1);
  entry->filename = path;
  return TRUE;
}

struct ld_emulation_xfer_struct ld_${EMULATION_NAME}_emulation = {
  gld${EMULATION_NAME}_before_parse,
  syslib_default,
  hll_default,
  after_parse_default,
  gld${EMULATION_NAME}_after_open,
  after_allocation_default,
  gld${EMULATION_NAME}_set_output_arch,
  gld${EMULATION_NAME}_choose_target,
  gld${EMULATION_NAME}_before_allocation,
  gld${EMULATION_NAME}_get_script,
  "${EMULATION_NAME}",
  "${OUTPUT_FORMAT}",
  finish_default,
  gld${EMULATION_NAME}_create_output_section_statements,
  gld${EMULATION_NAME}_open_dynamic_archive,
  0,				/* place_orphan */
  0,				/* set_symbols */
  gld${EMULATION_NAME}_parse_args,
  gld${EMULATION_NAME}_add_options,
  gld${EMULATION_NAME}_handle_option,
  gld${EMULATION_NAME}_unrecognized_file,
  NULL,				/* list_options */
  NULL,				/* recognized_file */
  NULL,				/* find potential_libraries */
  NULL				/* new_vers_pattern */
};
EOF
@


1.61
log
@Remove trailing white spaces in ld

	* deffilep.y: Remove trailing white spaces.
	* elf-hints-local.h: Likewise.
	* ldexp.c: Likewise.
	* ldlang.h: Likewise.
	* ldmisc.c: Likewise.
	* ldwrite.c: Likewise.
	* pe-dll.c: Likewise.
	* emulparams/criself.sh: Likewise.
	* emulparams/crislinux.sh: Likewise.
	* emulparams/elf32_tic6x_le.sh: Likewise.
	* emulparams/elf32bmipn32-defs.sh: Likewise.
	* emulparams/elf32mb_linux.sh: Likewise.
	* emulparams/elf32mep.sh: Likewise.
	* emulparams/elf32microblaze.sh: Likewise.
	* emulparams/elf32ppc.sh: Likewise.
	* emulparams/elf64_s390.sh: Likewise.
	* emulparams/elf64alpha.sh: Likewise.
	* emulparams/elf_s390.sh: Likewise.
	* emulparams/elf_x86_64.sh: Likewise.
	* emulparams/tic80coff.sh: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/cr16elf.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/tic6xdsbt.em: Likewise.
@
text
@d12 1
a12 3
   Copyright 1991, 1993, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2012
   Free Software Foundation, Inc.
d1111 1
d1316 2
@


1.60
log
@	* ldlang.h (struct lang_input_statement_flags): New, extract from..
	(lang_input_statement_type): ..here.  New field "flags".
	(input_flags): Declare.
	(missing_file): Delete.
	* ldmain.h (whole_archive): Delete.
	(add_DT_NEEDED_for_regular, add_DT_NEEDED_for_dynamic): Delete.
	* ld.h (ld_config_type <dynamic_link>): Delete.
	* ldmain.c (whole_archive): Delete.
	(add_DT_NEEDED_for_regular, add_DT_NEEDED_for_dynamic): Delete.
	* ldlang.c (missing_file, ldlang_sysrooted_script): Delete.
	(input_flags): New variable.  Replace all uses of config.dynamic_link,
	missing_file, ldlang_sysrooted_script, whole_archive,
	add_DT_NEEDED_for_regular and add_DT_NEEDED_for_dynamic with fields
	from here.
	* ldfile.c: Likewise.
	* ldgram.y: Likewise.
	* ldmain.c: Likewise.
	* ldwrite.c: Likewise.
	* lexsup.c: Likewise.
	* plugin.c: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vms.em: Likewise.
	* ldlang.c (new_afile): Use memset to init zero fields.
	(load_symbols): Simplify save and restore of flags around command
	file processing.
	* ldfile.c (is_sysrooted_pathname): Tidy.
@
text
@d364 1
a364 1
      
@


1.59
log
@2011-11-02  Tristan Gingold  <gingold@@adacore.com>

	* emultempl/aix.em (read_file_list): New function.
	(_handle_option): Handle '-f'.
	* NEWS: Mention this feature.
@
text
@d13 1
a13 1
   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d148 1
a148 1
  config.dynamic_link = TRUE;
d672 1
a672 1
      entry->loaded = TRUE;
d1508 1
a1508 1
  if (!entry->maybe_archive)
@


1.58
log
@2011-04-20  Tristan Gingold  <gingold@@adacore.com>

        * emultempl/aix.em (_add_options): Ignore -bbigtoc switch.
@
text
@d262 1
a262 1
  /* Options supported by the AIX linker which we do not support: -f,
d306 70
d391 6
@


1.57
log
@	* ld.texinfo (Expression Section): Describe treatment of numbers
	and absolute symbols.
	* ldemul.c (after_open_default): Look up __ld_compatibility.
	* ldexp.c (fold_name): Convert absolute symbols to numbers when
	inside output section definitions, or when __ld_compatibility >= 221.
	(exp_fold_tree_1): Convert numbers to absolute when not in output
	section definition and __ld_compatibility < 221.  Don't always
	convert values outside an output section definition to absolute.
	* ldexp.h (uses_defined): Comment.
	* ldlang.c (ld_compatibility): New variable.
	* ldlang.h (ld_compatibility): Declare.
	* emultempl/aix.em, * emultempl/armcoff.em, * emultempl/beos.em,
	* emultempl/elf32.em, * emultempl/genelf.em, * emultempl/lnk960.em,
	* emultempl/m68kcoff.em, * emultempl/mmo.em, * emultempl/pe.em,
	* emultempl/pep.em, * emultempl/sunos.em, * emultempl/z80.em: Call
	after_open_default from after_open function.
@
text
@d219 1
@


1.56
log
@Replace is_archive with maybe_archive.

2010-12-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldfile.c (ldfile_open_file_search): Check maybe_archive instead
	of is_archive.
	* emultempl/aix.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vms.em: Likewise.

	* ldlang.c (new_afile): Set maybe_archive instead of is_archive..

	* ldlang.h (lang_input_statement_struct): Replace is_archive
	with maybe_archive.
@
text
@d611 2
@


1.55
log
@	* ldlang.h (ldlang_add_undef): Add cmdline param.
	* ldlang.c (undef_from_cmdline): New var.
	(ldlang_add_undef): Add cmdline param.  Set undef_from_cmdline.
	(lang_end): Really require -e or -u from command line on
	relocatable --gc-sections.
	* ldemul.c (after_parse_default): Adjust ldlang_add_undef call.
	* ldgram.y (extern_name_list_body): Likewise.
	* lexsup.c (parse_args): Likewise.
	* emultempl/aix.em (gld${EMULATION_NAME}_read_file): Likewise.
@
text
@d1429 1
a1429 1
  if (!entry->is_archive)
@


1.55.2.1
log
@backport from mainline
@
text
@a610 2
  after_open_default ();

d1429 1
a1429 1
  if (!entry->maybe_archive)
@


1.55.2.2
log
@backport of:
Modified files:
	ld             : ChangeLog
	ld/emultempl   : aix.em

Log message:
	2011-04-20  Tristan Gingold  <gingold@@adacore.com>

	* emultempl/aix.em (_add_options): Ignore -bbigtoc switch.
@
text
@a218 1
    {"bbigtoc", no_argument, NULL, OPTION_IGNORE},
@


1.54
log
@fix set but unused variable warnings
@
text
@d1196 1
a1196 1
	      ldlang_add_undef (symname);
@


1.53
log
@update copyright dates
@
text
@d13 1
a13 1
   2003, 2004, 2005, 2006, 2007, 2008, 2009
a1426 1
  const char *filename;
a1431 1
  filename = entry->filename;
@


1.52
log
@bfd/
	* bfd-in.h (bfd_xcoff_split_import_path): Declare.
	(bfd_xcoff_set_archive_import_path): Likewise.
	* bfd-in2.h: Regenerate.
	* xcofflink.c: Include libiberty.h.
	(xcoff_archive_info): New structure.
	(xcoff_archive_info_hash): New function.
	(xcoff_archive_info_eq): Likewise.
	(xcoff_get_archive_info): Likewise.
	(_bfd_xcoff_bfd_link_hash_table_create): Initialize archive_info.
	(bfd_xcoff_split_import_path): New function.
	(bfd_xcoff_set_archive_import_path): Likewise.
	(xcoff_set_import_path): Move earlier in file.
	(xcoff_link_add_dynamic_symbols): Set the import path of a non-archive
	object to the the directory part of the bfd's filename.  Get the
	import path and filename of an archive object from the archive's
	xcoff_tdata, initializing it if necessary.  Update use of
	import_file_id.
	(bfd_link_input_bfd): Update use of import_file_id.
	(xcoff_write_global_symbol): Likewise.

ld/
	* emultempl/aix.em (gld${EMULATION_NAME}_open_dynamic_archive): New
	function.
	(ld_${EMULATION_NAME}_emulation): Use it.
@
text
@d13 1
a13 1
   2003, 2004, 2005, 2006, 2007, 2008
@


1.51
log
@include/coff/
	* xcoff.h (XCOFF_EXPALL, XCOFF_EXPFULL): New flags.
	(xcoff_loader_info): Add auto_export_flags.

bfd/
	* bfd-in.h (bfd_xcoff_size_dynamic_sections): Replace the
	bfd_boolean export_defineds parameter with an unsigned int
	auto_export_flags parameter.
	* bfd-in2.h: Regenerate.
	* xcofflink.c (xcoff_archive_contains_shared_object_p): New function,
	split out from xcoff_build_ldsyms.
	(xcoff_covered_by_expall_p): New function.
	(xcoff_auto_export_p): New function, split out from xcoff_build_ldsyms
	but with extra code to handle -bexpfull and -bexpall.
	(xcoff_mark_auto_exports): New function.
	(xcoff_build_ldsyms): Use xcoff_auto_export_p to decide whether
	a function should be automatically exported.
	(bfd_xcoff_size_dynamic_sections): Replace the export_defineds
	parameter with an auto_export_flags parameter.  Update ldinfo
	accordingly.  Use xcoff_mark_auto_exports to mark all automatically-
	exported symbols.

ld/
	* emultempl/aix.em (auto_export_flags): New variable.
	(explicit_auto_export_flags): Likewise.
	(OPTION_EXPALL, OPTION_EXPFULL): New enum values.
	(OPTION_NOEXPALL, OPTION_NOEXPFULL): Likewise.
	(gld${EMULATION_NAME}_add_options): Add -bexpall, -bexpfull,
	-bnoexpall and -bnoexpfull.
	(gld${EMULATION_NAME}_handle_option): Handle them.
	(gld${EMULATION_NAME}_before_allocation): Update the call to
	bfd_size_dynamic_sections.

ld/testsuite/
	* ld-powerpc/aix-export-1-all.dd, ld-powerpc/aix-export-1-full.dd,
	ld-powerpc/aix-export-1a.s, ld-powerpc/aix-export-1b.s: New tests.
	* ld-powerpc/aix52.exp: Run them.
@
text
@d1099 1
a1099 1
	      char *file;
d1103 1
a1103 2
	      imppath = s;
	      file = NULL;
d1105 1
a1105 17
		{
		  if (*s == '/')
		    file = s + 1;
		  ++s;
		}
	      if (file != NULL)
		{
		  file[-1] = '\0';
		  impfile = file;
		  if (imppath == file - 1)
		    imppath = "/";
		}
	      else
		{
		  impfile = imppath;
		  imppath = "";
		}
d1108 3
d1422 25
d1462 1
a1462 1
  0,				/* open_dynamic_archive */
@


1.50
log
@include/coff/
	* xcoff.h (XCOFF_CALLED, XCOFF_IMPORT): Update comments.
	(XCOFF_WAS_UNDEFINED): New flag.
	(xcoff_link_hash_table): Add an "rtld" field.

bfd/
	* coff-rs6000.c (xcoff_ppc_relocate_section): Report relocations
	against undefined symbols if the symbol's XCOFF_WAS_UNDEFINED
	flag is set.  Assert that all undefined symbols are either
	imported or defined by a dynamic object.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* xcofflink.c (xcoff_link_add_symbols): Extend function-symbol
	handling to all relocations.  Only set XCOFF_CALLED for function
	symbols.
	(xcoff_find_function): New function, split out from...
	(bfd_xcoff_export_symbol) ...here.
	(xcoff_set_import_path): New function, split out from...
	(bfd_xcoff_import_symbol): ...here.  Remove assertion for old
	meaning of XCOFF_CALLED.
	(xcoff_mark_symbol): If we mark an undefined and unimported
	symbol, find some way of defining it.  If the symbol is a function
	descriptor, fill in its definition automatically.  If the symbol
	is a function, mark its descriptor and allocate room for global
	linkage code.  Otherwise mark the symbol as implicitly imported.
	Move the code for creating function descriptors from...
	(xcoff_build_ldsyms): ...here.  Use XCOFF_WAS_UNDEFINED to
	check for symbols that were implicitly defined.
	(xcoff_mark): Don't count any dynamic relocations against
	function symbols.
	(bfd_xcoff_size_dynamic_sections): Save the rtld parameter
	in the xcoff link info.
	(xcoff_link_input_bfd): Remove handling of undefined and
	unexported symbols.

ld/
	* emultempl/aix.em (gld${EMULATION_NAME}_handle_option): Make
	-berok and -bernotok control link_info.unresolved_syms_in_objects
	and link_info.unresolved_syms_in_shared_libs instead of
	force_make_executable.

ld/testsuite/
	* ld-powerpc/aix-glink-1.ex, ld-powerpc/aix-glink-1.s,
	ld-powerpc/aix-glink-1-32.dd, ld-powerpc/aix-glink-1-64.dd,
	ld-powerpc/aix-glink-1-32.d, ld-powerpc/aix-glink-1-64.d: New tests.
	* ld-powerpc/aix52.exp: Run them.
@
text
@d87 8
d167 2
d177 2
d216 2
d233 2
d407 10
d473 10
d663 1
a663 1
  unsigned int i;
d749 5
d758 1
a758 1
       modtype,	textro ? TRUE : FALSE, unix_ld, special_sections,
@


1.49
log
@ld/
	* emultempl/aix.em (gld${EMULATION_NAME}_before_parse): Set
	config.dynamic_link to TRUE.
@
text
@d382 2
a383 1
      force_make_executable = FALSE;
d387 2
a388 1
      force_make_executable = TRUE;
@


1.48
log
@ld/
	* emultempl/aix.em (gld${EMULATION_NAME}_before_allocation): Mark
	.text, .data and .bss output sections as SEC_KEEP.

ld/testsuite/
	* ld-powerpc/aix-core-sec-1.s, ld-powerpc/aix-core-sec-1.ex,
	ld-powerpc/aix-core-sec-1.hd, ld-powerpc/aix-core-sec-2.s,
	ld-powerpc/aix-core-sec-2.ex, ld-powerpc/aix-core-sec-2.hd,
	ld-powerpc/aix-core-sec-3.s, ld-powerpc/aix-core-sec-3.ex,
	ld-powerpc/aix-core-sec-3.hd: New tests.
	* ld-powerpc/aix52.exp: New harness.
@
text
@d140 1
@


1.47
log
@include/
	* bfdlink.h (struct bfd_link_hash_table): Delete creator field.
	(struct bfd_link_info): Add output_bfd.
bfd/
	* elflink.c: Replace all accesses to hash->creator field with
	output_bfd->xvec.
	* cofflink.c: Likewise.
	* coff-h8300.c: Likewise.
	* ecoff.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfxx-mips.c: Likewise.
	* i386linux.c: Likewise.
	* m68klinux.c: Likewise.
	* sparclinux.c: Likewise.
	* sunos.c: Likewise.
	* xcofflink.c: Likewise.
	* linker.c: Likewise.
	(_bfd_link_hash_table_init): Don't store creator.
ld/
	* ldmain.h (output_bfd): Delete.
	* ldmain.c (output_bfd): Delete.
	Replace all occurrences of output_bfd with link_info.output_bfd.
	* ldcref.c: Likewise.
	* ldctor.c: Likewise.
	* ldemul.c: Likewise.
	* ldexp.c: Likewise.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldmisc.c: Likewise.
	* ldwrite.c: Likewise.
	* pe-dll.c: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/alphaelf.em: Likewise.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/elf-generic.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/irix.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/mmix-elfnmmo.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/sh64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
	* emultempl/z80.em: Likewise.
	* ldlang.c (open_output): Don't return output, instead write
	link_info_output_bfd directly.
	* emultempl/alphaelf.em: Replace occurrences of link_info.hash->creator
	with link_info.output_bfd->xvec.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
@
text
@d619 6
a624 1
  int i;
d832 16
@


1.46
log
@2007-07-19  Roland McGrath  <roland@@redhat.com>

	* genscripts.sh (source_em, fragment): New sh functions.
	Truncate e${EMULATION_NAME}.c file before .em script fills it.
	Use source_em in place of . for the .em script.
	* emultempl/generic.em: Use fragment and source_em functions.
	* emultempl/aix.em: Likewise.
	* emultempl/alphaelf.em: Likewise.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/cr16elf.em: Likewise.
	* emultempl/crxelf.em: Likewise.
	* emultempl/elf-generic.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/genelf.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/gld960c.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ia64elf.em: Likewise.
	* emultempl/irix.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/m68kcoff.em: Likewise.
	* emultempl/m68kelf.em: Likewise.
	* emultempl/mipsecoff.em: Likewise.
	* emultempl/mipself.em: Likewise.
	* emultempl/mmix-elfnmmo.em: Likewise.
	* emultempl/mmixelf.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/needrelax.em: Likewise.
	* emultempl/netbsd.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/sh64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/ticoff.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
	* emultempl/z80.em: Likewise.
@
text
@d13 1
a13 1
   2003, 2004, 2005, 2006, 2007
d578 1
a578 1
  if (strstr (bfd_get_target (output_bfd), "xcoff") != NULL)
d603 2
a604 1
      if (!bfd_xcoff_link_record_set (output_bfd, &link_info, p->h, size))
d631 1
a631 1
      if (!bfd_xcoff_export_symbol (output_bfd, &link_info, h))
d707 1
a707 1
      (output_bfd, &link_info, libpath,	entry_symbol.name, file_align,
d1163 2
a1164 1
		  if (!bfd_xcoff_import_symbol (output_bfd, &link_info, h,
d1211 2
a1212 1
      if (!bfd_xcoff_link_count_reloc (output_bfd, &link_info, rs->name))
d1238 2
a1239 1
	  if (!bfd_xcoff_record_link_assignment (output_bfd, &link_info,
d1324 1
a1324 1
  if ((bfd_get_flavour (output_bfd) == bfd_target_xcoff_flavour)
d1333 1
a1333 1
      initfini_file->the_bfd = bfd_create ("initfini", output_bfd);
d1336 2
a1337 2
				  bfd_get_arch (output_bfd),
				  bfd_get_mach (output_bfd)))
d1362 7
a1368 7
  bfd_set_arch_mach (output_bfd,
		     bfd_xcoff_architecture (output_bfd),
		     bfd_xcoff_machine (output_bfd));

  ldfile_output_architecture = bfd_get_arch (output_bfd);
  ldfile_output_machine = bfd_get_mach (output_bfd);
  ldfile_output_machine_name = bfd_printable_name (output_bfd);
@


1.45
log
@Update sources to GPLv3
@
text
@d8 1
a8 1
cat >e${EMULATION_NAME}.c <<EOF
d1274 1
a1274 1
cat >>e${EMULATION_NAME}.c <<EOF
d1295 1
a1295 1
cat >>e${EMULATION_NAME}.c <<EOF
d1314 1
a1314 1
cat >>e${EMULATION_NAME}.c <<EOF
@


1.44
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d19 1
a19 1
This file is part of GLD, the Gnu Linker.
d21 14
a34 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.43
log
@PR ld/4023
* emultempl/aix.em (..._before_allocation): Strip sysroot prefix
  from any paths being inserted into the output binary's DT_RPATH.
@
text
@d13 1
a13 1
   2003, 2004, 2005, 2006
d37 1
a38 1
#include "sysdep.h"
@


1.42
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d654 46
a699 12
      len = strlen (search_head->name);
      libpath = xmalloc (len + 1);
      strcpy (libpath, search_head->name);
      for (search = search_head->next; search != NULL; search = search->next)
	{
	  size_t nlen;

	  nlen = strlen (search->name);
	  libpath = xrealloc (libpath, len + nlen + 2);
	  libpath[len] = ':';
	  strcpy (libpath + len + 1, search->name);
	  len += nlen + 1;
@


1.41
log
@bfd/
	* elf32-ppc.c (struct elf_linker_section): Replace sym_val field
	with sym.
	(ppc_elf_relocate_section): Adjust for above.
	(create_sdata_sym): New function.
	(ppc_elf_create_linker_section): Call it.
	(ppc_elf_check_relocs): Correct has_sda_refs and non_got_refs.
	Create sdata syms for all SDA relocs.
	(ppc_elf_adjust_dynamic_symbol): Don't special case _SDA_BASE_
	and _SDA2_BASE_.
	(ppc_elf_set_sdata_syms): Delete.
	* elflink.c (bfd_elf_size_dynamic_sections): Don't create DT_INIT
	and DT_FINI tags unless associated section has input.
	(bfd_elf_set_symbol, _bfd_elf_provide_symbol): Delete.
	(_bfd_elf_provide_section_bound_symbols): Delete.
	* bfd-in.h (_bfd_elf_provide_symbol): Delete.
	(_bfd_elf_provide_section_bound_symbols): Delete.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c (ldemul_do_assignments, do_assignments_default): Delete.
	* ldemul.h (ldemul_do_assignments, do_assignments_default): Delete.
	(struct ld_emulation_xfer_struct): Remove do_assignments field.
	* ldlang.c (lang_do_assignments): Don't call ldemul_do_assignments.
	* emulparams/elf32ppc.sh (SDATA_START_SYMBOLS): New.
	(SDATA2_START_SYMBOLS, SBSS_START_SYMBOLS, SBSS_END_SYMBOLS): New.
	* emultempl/aix.em (ld_*_emulation): Delete do_assignments init.
	* emultempl/armcoff.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/generic.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/gld960c.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68kcoff.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/ticoff.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/elf32.em: Likewise.
	(gld*_provide_bound_symbols): Delete.
	(gld*_provide_init_fini_syms): Delete.
	(gld*_before_allocation): Don't call ldemul_do_assignments.
	* emultempl/ppc32elf.em (ppc_do_assignments): Delete.
	(LDEMUL_DO_ASSIGNMENTS): Delete.
	* scripttempl/elf.sc: Provide init/fini syms.  Add SBSS_START_SYMBOLS,
	SBSS_END_SYMBOLS, SDATA2_START_SYMBOLS.
@
text
@d13 1
a13 1
   2003, 2004, 2005
d271 1
a271 1
  if (indx < argc && strncmp (argv[indx], "-b", 2) == 0)
@


1.40
log
@bfd/
	* elflink.c (fix_syms, _bfd_elf_fix_excluded_sec_syms): Move to..
	* linker.c (fix_syms, _bfd_fix_excluded_sec_syms): ..here.
	* bfd-in.h (_bfd_fix_excluded_sec_syms): Rename.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c (ldemul_finish): Call ld_emulation->finish unconditionally.
	(finish_default): New function.
	* ldemul.h (finish_default): Declare.
	* emultempl/aix.em (gld*_before_allocation): Call
	before_allocation_default rather than strip_excluded_output_sections.
	(ld_*_emulation): Init finish field to finish_default.
	* emultempl/armcoff.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/generic.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/gld960c.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68kcoff.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/ticoff.em: Likewise.
	* emultempl/vanilla.em: Likewise.
@
text
@a1341 1
  do_assignments_default,
@


1.39
log
@	* ldemul.c (ldemul_do_assignments): New function.
	(do_assignments_default): New function.
	* ldemul.h (ldemul_do_assignments): Declare.
	(do_assignments_default): Declare.
	(struct ld_emulation_xfer_struct): Add do_assignments.
	* ldlang.c (lang_do_assignments) Call ldemul_do_assignments.
	* emultempl/aix.em (ld_*_emulation): Init do_assignments field.
	* emultempl/armcoff.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/generic.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/gld960c.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68kcoff.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/ticoff.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/elf32.em: Likewise, to call gld*_provide_init_fini_syms.
	(gld*_find_exp_assignment): Adjust bfd_elf_record_link_assignment call.
@
text
@d791 1
a791 2
  if (!link_info.relocatable)
    strip_excluded_output_sections ();
d1346 1
a1346 1
  0,				/* finish */
@


1.38
log
@Update FSF addresses
@
text
@d1343 1
@


1.37
log
@bfd/
	* section.c (struct bfd_section): Replace link_order_head and
	link_order_tail with map_head and map_tail union.
	(STD_SECTION): Update.
	(_bfd_strip_section_from_output): Delete.
	* aoutx.h: Update throughout for above changes.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* linker.c: Likewise.
	* merge.c: Likewise.
	* pdp11.c: Likewise.
	* xcofflink.c: Likewise.
	* elflink.c (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Split
	out from bfd_elf_size_dynamic_sections.
	* bfd-in.h (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Declare.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c: Include bfdlink.h.
	(ldemul_before_allocation): Assume before_allocation is non-zero.
	(before_allocation_default): Call strip_excluded_output_sections.
	* ldlang.c (stripped_excluded_sections): New variable.
	(lang_add_section): Build input section list for each output
	section, attached via map_head and map_tail pointers.
	(strip_excluded_output_sections): Make global.  Traverse the
	input section lists to find which output sections can go.  Clear
	link_order pointers and set stripped_excluded_sections.
	(lang_process): Call strip_excluded_output_sections.
	* ldlang.h (strip_excluded_output_sections): Declare.
	* ldwrite.c: Update throuhout for link_order_head -> map_head change.
	* emultempl/aix.em (before_allocation): Call
	strip_excluded_output_sections.
	* emultempl/armcoff.em (before_allocation): Likewise.
	* emultempl/beos.em (before_allocation): Likewise.
	* emultempl/linux.em (before_allocation): Likewise.
	* emultempl/pe.em (before_allocation): Likewise.
	* emultempl/sunos.em (before_allocation): Likewise.
	* emultempl/elf32.em (before_allocation): Likewise.  Call
	bfd_elf_size_dynsym_hash_dynstr too.
	* emultempl/lnk960.em (lnk960_before_allocation): Delete.
	(ld_lnk960): Use before_allocation_default.
@
text
@d33 1
a33 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.36
log
@update copyright dates
@
text
@d13 1
a13 1
   2003, 2004
d790 3
@


1.35
log
@emultempl/alphaelf.em (alpha_after_parse): Add extra, NULL, parameter to
  invocation of lang_section_start.
emultempl/aix.em (_handle_option): Likewise.

Makefile.am (eelf64alpha.c, eelf64alpha_fbsd.c,	eelf64alpha_nbsd.c): Add
  dependency upon emultempl/alphaelf.em.
Makefile.in: Regenerate.
@
text
@d12 2
a13 1
   Copyright 1991, 1993, 1995, 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2004
@


1.34
log
@	* ldfile.c (ldfile_set_output_arch): Add defarch param.
	* ldfile.h (ldfile_set_output_arch): Ditto.
	* emultempl/aix.em (gld${EMULATION_NAME}_before_parse): Use
	ldfile_set_output_arch.
	* emultempl/beos.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/elf32.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/linux.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/mipsecoff.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/pe.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* ldgram.y: Adjust ldfile_set_output_arch call.
	* emultempl/armcoff.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/armelf.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/armelf_oabi.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/generic.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/gld960c.em (gld960_set_output_arch): Ditto.
	* emultempl/m68kcoff.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/ticoff.em (gld${EMULATION_NAME}_before_parse): Ditto.
@
text
@d306 1
a306 1
	lang_section_start (".data", exp_intop (val));
d331 1
a331 1
      lang_section_start (".text", exp_intop (val));
d466 1
a466 1
	  lang_section_start (".data", t);
d487 1
a487 1
	  lang_section_start (".text", t);
@


1.33
log
@	* emultempl/aix.em: Convert to C90, remove unnecessary prototypes
	and casts.  Replace PTR with void *.  Formatting.
	* emultempl/alphaelf.em: Likewise
	* emultempl/armcoff.em: Likewise
	* emultempl/armelf.em: Likewise
	* emultempl/armelf_oabi.em: Likewise
	* emultempl/beos.em: Likewise
	* emultempl/elf32.em: Likewise
	* emultempl/generic.em: Likewise
	* emultempl/gld960.em: Likewise
	* emultempl/gld960c.em: Likewise
	* emultempl/hppaelf.em: Likewise
	* emultempl/linux.em: Likewise
	* emultempl/lnk960.em: Likewise
	* emultempl/m68hc1xelf.em: Likewise
	* emultempl/m68kcoff.em: Likewise
	* emultempl/m68kelf.em: Likewise
	* emultempl/mipsecoff.em: Likewise
	* emultempl/mipself.em: Likewise
	* emultempl/mmix-elfnmmo.em: Likewise
	* emultempl/mmixelf.em: Likewise
	* emultempl/mmo.em: Likewise
	* emultempl/needrelax.em: Likewise
	* emultempl/netbsd.em: Likewise
	* emultempl/pe.em: Likewise
	* emultempl/sh64elf.em: Likewise
	* emultempl/sunos.em: Likewise
	* emultempl/ticoff.em: Likewise
	* emultempl/vanilla.em: Likewise
	* emultempl/xtensaelf.em: Likewise
	* Makefile.am: Correct dependencies.
	* Makefile.in: Regenerate.
@
text
@d12 1
a12 1
   Copyright 1991, 1993, 1995, 1996, 1997, 1998, 2000, 2001, 2002, 2003
d136 1
a136 9
  const bfd_arch_info_type *arch = bfd_scan_arch ("${OUTPUT_ARCH}");
  if (arch)
    {
      ldfile_output_architecture = arch->arch;
      ldfile_output_machine = arch->mach;
      ldfile_output_machine_name = arch->printable_name;
    }
  else
    ldfile_output_architecture = bfd_arch_`echo ${ARCH} | sed -e 's/:.*//'`;
@


1.32
log
@Correct spelling of "relocatable".
@
text
@d59 5
a63 34
static void gld${EMULATION_NAME}_before_parse
  PARAMS ((void));
static bfd_boolean gld${EMULATION_NAME}_parse_args
  PARAMS ((int, char **));
static void gld${EMULATION_NAME}_add_options
  PARAMS ((int, char **, int, struct option **, int, struct option **));
static bfd_boolean gld${EMULATION_NAME}_handle_option
  PARAMS ((int));
static void gld${EMULATION_NAME}_after_open
  PARAMS ((void));
static char *gld${EMULATION_NAME}_choose_target
  PARAMS ((int, char **));
static void gld${EMULATION_NAME}_before_allocation
  PARAMS ((void));
static void gld${EMULATION_NAME}_read_file
  PARAMS ((const char *, bfd_boolean));
static void gld${EMULATION_NAME}_free
  PARAMS ((PTR));
static void gld${EMULATION_NAME}_find_relocs
  PARAMS ((lang_statement_union_type *));
static void gld${EMULATION_NAME}_find_exp_assignment
  PARAMS ((etree_type *));
static char *gld${EMULATION_NAME}_get_script
  PARAMS ((int *isfile));
static bfd_boolean gld${EMULATION_NAME}_unrecognized_file
  PARAMS ((lang_input_statement_type *));
static void gld${EMULATION_NAME}_create_output_section_statements
  PARAMS ((void));
static void gld${EMULATION_NAME}_set_output_arch
  PARAMS ((void));
static int is_syscall
  PARAMS ((char *, unsigned int *));
static int change_symbol_mode
  PARAMS ((char *));
d134 1
a134 1
gld${EMULATION_NAME}_before_parse ()
d184 3
a186 7
gld${EMULATION_NAME}_add_options (ns, shortopts, nl, longopts, nrl, really_longopts)
     int ns;
     char **shortopts;
     int nl;
     struct option **longopts;
     int nrl ATTRIBUTE_UNUSED;
     struct option **really_longopts ATTRIBUTE_UNUSED;
d261 2
a262 2
  *longopts = (struct option *)
    xrealloc (*longopts, nl * sizeof (struct option) + sizeof (xtra_long));
d267 1
a267 3
gld${EMULATION_NAME}_parse_args (argc, argv)
     int argc;
     char **argv;
d295 1
a295 2
gld${EMULATION_NAME}_handle_option (optc)
     int optc;
d537 1
a537 2
gld${EMULATION_NAME}_unrecognized_file (entry)
     lang_input_statement_type *entry;
d573 1
a573 1
gld${EMULATION_NAME}_after_open ()
d618 1
a618 1
gld${EMULATION_NAME}_before_allocation ()
d800 1
a800 3
gld${EMULATION_NAME}_choose_target (argc, argv)
     int argc;
     char **argv;
d835 1
a835 2
change_symbol_mode (input)
     char *input;
d869 1
a869 3
is_syscall (input, flag)
     char *input;
     unsigned int *flag;
d919 1
a919 3
gld${EMULATION_NAME}_read_file (filename, import)
     const char *filename;
     bfd_boolean import;
d1160 1
a1160 2
gld${EMULATION_NAME}_free (p)
     PTR p;
d1170 1
a1170 2
gld${EMULATION_NAME}_find_relocs (s)
     lang_statement_union_type *s;
d1190 1
a1190 2
gld${EMULATION_NAME}_find_exp_assignment (exp)
     etree_type *exp;
d1234 1
a1234 2
gld${EMULATION_NAME}_get_script (isfile)
     int *isfile;
d1287 1
a1287 1
gld${EMULATION_NAME}_create_output_section_statements ()
d1326 1
a1326 1
gld${EMULATION_NAME}_set_output_arch ()
@


1.31
log
@	* ldemul.c (ldemul_add_options, ldemul_handle_option): New functions.
	(ldemul_parse_args): Return bfd_boolean.  Formatting.
	* ldemul.h (ldemul_add_options, ldemul_handle_option): Declare.
	(ldemul_parse_args): Adjust.
	(struct ld_emulation_xfer_struct): Add add_options and handle_option.
	Return bfd_boolean from parse_args.
	* lexsup.c (parse_args): Malloc shortopts, longopts and
	really_longopts.  Call ldemul_add_options and ldemul_handle_option.
	* emultempl/aix.em (gld${EMULATION_NAME}_add_options): Split out from
	gld${EMULATION_NAME}_parse_args.
	(gld${EMULATION_NAME}_handle_option): Likewise.
	(ld_${EMULATION_NAME}_emulation): Adjust initializer.
	* emultempl/armcoff.em: As for aix.em, but remove parse_args.
	* emultempl/beos.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/ticoff.em: Likewise.
	* emultempl/elf32.em: Likewise.  Don't duplicate long options either.
	(gld${EMULATION_NAME}_add_sysroot): Prototype.
	* emultempl/armelf.em (PARSE_AND_LIST_LONGOPTS): Don't duplicate
	options.
	* emultempl/hppaelf.em (PARSE_AND_LIST_LONGOPTS): Likewise.
	* emultempl/ppc32elf.em (PARSE_AND_LIST_LONGOPTS): Likewise.
	* emultempl/ppc64elf.em (PARSE_AND_LIST_LONGOPTS): Likewise.
	* emultempl/armelf_oabi.em (ld_${EMULATION_NAME}_emulation): Adjust
	initializer.
	* emultempl/generic.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/gld960c.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68kcoff.em: Likewise.
	* emultempl/mipsecoff.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/netbsd.em (gldnetbsd_before_parse): Prototype.
@
text
@d616 1
a616 1
     relocateable link.  We do this because AIX requires relocation
d620 1
a620 1
  r = link_info.relocateable;
d622 1
a622 1
    link_info.relocateable = TRUE;
d624 1
a624 1
  link_info.relocateable = r;
d1296 1
a1296 1
  if (link_info.relocateable && config.build_constructors)
d1300 1
a1300 1
echo '  ; else if (link_info.relocateable) return'     >> e${EMULATION_NAME}.c
d1317 1
a1317 1
  if (link_info.relocateable && config.build_constructors)
d1319 1
a1319 1
  else if (link_info.relocateable)
@


1.30
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d12 1
a12 1
   Copyright 1991, 1993, 1995, 1996, 1997, 1998, 2000, 2001, 2002
d61 1
a61 1
static int gld${EMULATION_NAME}_parse_args
d63 4
d187 1
a187 14
static int
gld${EMULATION_NAME}_parse_args (argc, argv)
     int argc;
     char **argv;
{
  int prevoptind = optind;
  int prevopterr = opterr;
  int indx;
  int longind;
  int optc;
  bfd_signed_vma val;
  const char *end;

  enum
d212 11
a231 1
  static const struct option longopts[] = {
d292 14
d326 2
d329 6
a334 7

  /* We add s and u so to the short options list so that -s and -u on
     the command line do not match -static and -unix.  */

  opterr = 0;
  optc = getopt_long_only (argc, argv, "-D:H:KT:zsu", longopts, &longind);
  opterr = prevopterr;
a337 2
    case 's':
    case 'u':
d339 1
a339 2
      optind = prevoptind;
      return 0;
d374 1
a374 4
	{
	  optind = prevoptind;
	  return 0;
	}
d565 1
a565 1
  return 1;
d958 1
a958 1
   this is called by the parse_args emulation routine.  */
d1404 2
@


1.29
log
@	* emultempl/aix.em: Use include <> for generated headers.
	* emultempl/beos.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/pe.em: Likewise.
	* ldctor.c: Likewise.
	* ldexp.c: Likewise.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldlex.c: Likewise.
	* ldlex.l: Likewise.
	* ldmain.c: Likewise.
	* ldmisc.c: Likewise.
	* ldwrite.c: Likewise.
	* lexsup.c: Likewise.
	* mri.c: Likewise.
	* pe-dll.c: Likewise.
@
text
@d59 14
a72 7
static void gld${EMULATION_NAME}_before_parse PARAMS ((void));
static int gld${EMULATION_NAME}_parse_args PARAMS ((int, char **));
static void gld${EMULATION_NAME}_after_open PARAMS ((void));
static char *gld${EMULATION_NAME}_choose_target PARAMS ((int, char **));
static void gld${EMULATION_NAME}_before_allocation PARAMS ((void));
static void gld${EMULATION_NAME}_read_file PARAMS ((const char *, boolean));
static void gld${EMULATION_NAME}_free PARAMS ((PTR));
d74 6
a79 4
PARAMS ((lang_statement_union_type *));
static void gld${EMULATION_NAME}_find_exp_assignment PARAMS ((etree_type *));
static char *gld${EMULATION_NAME}_get_script PARAMS ((int *isfile));
static boolean gld${EMULATION_NAME}_unrecognized_file
d83 6
a88 4
static void gld${EMULATION_NAME}_set_output_arch PARAMS ((void));

static int is_syscall PARAMS ((char *, unsigned int *));
static int change_symbol_mode PARAMS ((char *));
d171 1
a171 1
  config.has_shared = true;
d409 1
a409 1
      link_info.static_link = false;
d413 1
a413 1
      force_make_executable = false;
d417 1
a417 1
      force_make_executable = true;
d421 1
a421 1
      gld${EMULATION_NAME}_read_file (optarg, false);
d463 1
a463 1
	  link_info.shared = true;
d473 1
a473 1
      link_info.static_link = true;
d477 1
a477 1
      link_info.traditional_format = true;
d526 1
a526 1
      link_info.traditional_format = false;
d530 1
a530 1
      unix_ld = true;
d562 1
a562 1
static boolean
d567 1
a567 1
  boolean ret;
d571 1
a571 1
    return false;
d573 1
a573 1
  ret = false;
d588 2
a589 2
      ret = true;
      entry->loaded = true;
d602 1
a602 1
  boolean r;
d612 1
a612 1
    link_info.relocateable = true;
d655 1
a655 1
    gld${EMULATION_NAME}_read_file (fl->name, true);
d660 1
a660 1
      h = bfd_link_hash_lookup (link_info.hash, el->name, false, false, false);
d706 3
a708 3
       maxstack, maxdata, gc && !unix_ld ? true : false,
       modtype,	textro ? true : false, unix_ld, special_sections,
       rtld ? true : false))
d720 1
a720 1
      boolean start;
d780 1
a780 1
	  start = true;
d786 1
a786 1
	  start = false;
d792 1
a792 1
	  start = true;
d798 1
a798 1
	  start = false;
d805 1
a805 1
	  start = false;
d953 1
a953 1
     boolean import;
d959 1
a959 1
  boolean keep;
d974 1
a974 1
  keep = false;
d1040 1
a1040 1
	      keep = true;
d1157 2
a1158 2
	      h = bfd_link_hash_lookup (link_info.hash, symname, false, false,
					true);
d1235 1
a1235 1
				false, false, false);
d1286 1
a1286 1
  if (link_info.relocateable == true && config.build_constructors == true)
d1289 10
a1298 10
sed $sc ldscripts/${EMULATION_NAME}.xu			   >> e${EMULATION_NAME}.c
echo '  ; else if (link_info.relocateable == true) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xr			   >> e${EMULATION_NAME}.c
echo '  ; else if (!config.text_read_only) return'	   >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xbn			   >> e${EMULATION_NAME}.c
echo '  ; else if (!config.magic_demand_paged) return'	   >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xn			   >> e${EMULATION_NAME}.c
echo '  ; else return'					   >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.x			   >> e${EMULATION_NAME}.c
echo '; }'						   >> e${EMULATION_NAME}.c
d1307 1
a1307 1
  if (link_info.relocateable == true && config.build_constructors == true)
d1309 1
a1309 1
  else if (link_info.relocateable == true)
d1331 1
a1331 1
	  || rtld == true))
d1348 4
a1351 4
      if (false == bfd_xcoff_link_generate_rtinit (initfini_file->the_bfd,
						   link_info.init_function,
						   link_info.fini_function,
						   rtld))
d1358 1
a1358 1
      if (true == rtld)
@


1.28
log
@	* emultempl/aix.em (gld${EMULATION_NAME}_parse_args): Replace strtoll,
	strtoul and strtoull with bfd_scan_vma.
	(gld${EMULATION_NAME}_read_file): Likewise.
@
text
@d52 1
a52 1
#include "ldgram.h"
@


1.27
log
@	* emultempl/aix.em (gld*_before_parse): Set default arch.  Reverts
	2002-05-10 change.
@
text
@d183 1
a183 1
  char *end;
d322 1
a322 1
      val = strtoll (optarg, &end, 0);
d330 1
a330 1
      val = strtoul (optarg, &end, 0);
d348 1
a348 1
      val = strtoull (optarg, &end, 0);
d433 1
a433 1
      val = strtoull (optarg, &end, 0);
d441 1
a441 1
      val = strtoull (optarg, &end, 0);
d474 1
a474 1
      val = strtoull (optarg, &end, 0);
d497 1
a497 1
      val = strtoull (optarg, &end, 0);
d1115 1
a1115 1
		  char *end;
d1122 1
a1122 1
		      address = strtoul (s, &end, 0);
@


1.26
log
@	* ldlang.h (entry_sym): Make it a struct bfd_sym_chain.
	* ldlang.c (entry_sym): Likewise.
	(ldlang_undef_chain_list_type): Likewise.
	(lang_finish): Adjust references to entry_symbol.
	(lang_add_entry): Likewise.
	(lang_gc_sections): Use link_info.gc_sym_list.
	(lang_process): Set link_info.gc_sym_list.
	* ldlex.l: Include bfdlink.h.
	* ldmain.c (main): Init link_info.gc_sym_list.
	* emultempl/aix.em: Adjust references to entry_symbol.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/ppc64elf.em (ppc_after_open): New function.
	(LDEMUL_AFTER_OPEN): Define.
	* emulparams/elf64ppc.sh: KEEP .opd sections.
@
text
@d66 1
a66 1
static void gld${EMULATION_NAME}_find_relocs 
d72 1
a72 1
static void gld${EMULATION_NAME}_create_output_section_statements 
d138 1
a138 1
/* Whether to do run time linking 
d150 9
d164 1
a164 1
     state flag that lets the backend know that -binitfini has been done.  */ 
d185 1
a185 1
  enum 
d214 1
a214 1
     
d345 3
a347 3
         number, we assume the AIX option is intended.  Otherwise, we
         assume the usual GNU ld -T option is intended.  We can't just
         ignore the AIX option, because gcc passes it to the linker.  */
d396 1
a396 1
      
d443 1
a443 1
	einfo ("%P: warning: ignoring invalid -bmaxstack number %s\n", 
d471 3
a473 3
         start on.  The offset within the page should still be the
         offset within the file, so we need to build an appropriate
         expression.  */
d495 2
a496 2
         on.  The offset within the page should still be the offset
         within the file.  */
d612 2
a613 2
         collect, and the sets may already have been built, so we do
         not do anything.  */
d663 3
a665 3
     -blibpath:  native support always first
     -rpath:     gnu extension
     -L          build from command line -L's */
d693 1
a693 1
  if (!bfd_xcoff_size_dynamic_sections 
d696 1
a696 1
       modtype,	textro ? true : false, unix_ld, special_sections, 
d716 1
a716 1
         This assumes we know what the script looks like.  */
d719 1
a719 1
      if (os == NULL) 
d725 1
a725 1
	  if ((*pls)->header.type == lang_input_section_enum 
d741 1
a741 1
		  if ((*pwls)->header.type == lang_input_section_enum 
d823 1
a823 1
  static char *argv_to_target[][2] = { 
d839 1
a839 1
      for (j = 1; j < jmax; j++) 
d849 1
a849 1
/* Returns 
d852 1
a852 1
static int 
d883 1
a883 1
/* Returns 
d887 1
a887 1
static int 
d894 1
a894 1
  
d912 1
a912 1
  for (bit = 0;; bit++) 
d915 1
a915 1
      if (string == NULL) 
d918 1
a918 1
      if (0 == strcmp (input, string)) 
d920 1
a920 1
	  if (1 << bit & syscall_mask) 
d924 2
a925 2
	    } 
	  else 
d1118 2
a1119 2
	      
		  if (0 > status) 
d1127 1
a1127 1
			  
d1278 1
a1278 1
sed $sc ldscripts/${EMULATION_NAME}.xu                     >> e${EMULATION_NAME}.c
d1280 8
a1287 8
sed $sc ldscripts/${EMULATION_NAME}.xr                     >> e${EMULATION_NAME}.c
echo '  ; else if (!config.text_read_only) return'         >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xbn                    >> e${EMULATION_NAME}.c
echo '  ; else if (!config.magic_demand_paged) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xn                     >> e${EMULATION_NAME}.c
echo '  ; else return'                                     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.x                      >> e${EMULATION_NAME}.c
echo '; }'                                                 >> e${EMULATION_NAME}.c
d1313 1
a1313 1
static void 
d1317 2
a1318 2
  if ((bfd_get_flavour (output_bfd) == bfd_target_xcoff_flavour) 
      && (link_info.init_function != NULL  
d1325 1
a1325 1
      
d1335 1
a1335 1
      
d1337 2
a1338 2
      if (false == bfd_xcoff_link_generate_rtinit (initfini_file->the_bfd, 
						   link_info.init_function, 
d1347 1
a1347 1
      if (true == rtld) 
@


1.26.2.1
log
@2002-09-23  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2002-09-22  Mark Elbrecht  <snowball3@@softhome.net>
	* scripttempl/i386go32.sc: Handle bss unique sections.

	2002-09-11  Nick Clifton  <nickc@@redhat.com>
	* po/tr.po: Updated Turkish translation.

	2002-08-28  Alan Modra  <amodra@@bigpond.net.au>
	* emultempl/aix.em (gld${EMULATION_NAME}_parse_args): Replace strtoll,
	strtoul and strtoull with bfd_scan_vma.
	(gld${EMULATION_NAME}_read_file): Likewise.

	2002-08-07  Nick Clifton  <nickc@@redhat.com>
	* emultempl/armelf.em (arm_elf_before_allocation): Only search
	for an interworking bfd if there are input bfds.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* emultempl/aix.em (gld*_before_parse): Set default arch.  Reverts
	2002-05-10 change.

	2002-08-06  H.J. Lu <hjl@@gnu.org>
	* ld.texinfo: Document --no-undefined-version.

	* ldlang.c (lang_new_vers_pattern): Set the `symver' and
	`script.' fields to 0.

	* ldmain.c (main): Initialize the allow_undefined_version to
	true.

	* lexsup.c (OPTION_NO_UNDEFINED_VERSION): New.
	(ld_options): Add --no-undefined-version.
	(parse_args): Support OPTION_NO_UNDEFINED_VERSION.

	2002-07-04  Bruno Haible  <bruno@@clisp.org>
	* emulparams/elf_i386_fbsd.sh: Set OUTPUT_FORMAT to
	elf32-i386-freebsd.
	* emulparams/elf64alpha_fbsd.sh: Set OUTPUT_FORMAT to
	elf64-alpha-freebsd.
@
text
@d66 1
a66 1
static void gld${EMULATION_NAME}_find_relocs
d72 1
a72 1
static void gld${EMULATION_NAME}_create_output_section_statements
d138 1
a138 1
/* Whether to do run time linking
a149 9
  const bfd_arch_info_type *arch = bfd_scan_arch ("${OUTPUT_ARCH}");
  if (arch)
    {
      ldfile_output_architecture = arch->arch;
      ldfile_output_machine = arch->mach;
      ldfile_output_machine_name = arch->printable_name;
    }
  else
    ldfile_output_architecture = bfd_arch_`echo ${ARCH} | sed -e 's/:.*//'`;
d155 1
a155 1
     state flag that lets the backend know that -binitfini has been done.  */
d174 1
a174 1
  const char *end;
d176 1
a176 1
  enum
d205 1
a205 1

d313 1
a313 1
      val = bfd_scan_vma (optarg, &end, 0);
d321 1
a321 1
      val = bfd_scan_vma (optarg, &end, 0);
d336 4
a339 4
	 number, we assume the AIX option is intended.  Otherwise, we
	 assume the usual GNU ld -T option is intended.  We can't just
	 ignore the AIX option, because gcc passes it to the linker.  */
      val = bfd_scan_vma (optarg, &end, 0);
d387 1
a387 1

d424 1
a424 1
      val = bfd_scan_vma (optarg, &end, 0);
d432 1
a432 1
      val = bfd_scan_vma (optarg, &end, 0);
d434 1
a434 1
	einfo ("%P: warning: ignoring invalid -bmaxstack number %s\n",
d462 4
a465 4
	 start on.  The offset within the page should still be the
	 offset within the file, so we need to build an appropriate
	 expression.  */
      val = bfd_scan_vma (optarg, &end, 0);
d486 3
a488 3
	 on.  The offset within the page should still be the offset
	 within the file.  */
      val = bfd_scan_vma (optarg, &end, 0);
d603 2
a604 2
	 collect, and the sets may already have been built, so we do
	 not do anything.  */
d654 3
a656 3
     -blibpath:	 native support always first
     -rpath:	 gnu extension
     -L		 build from command line -L's */
d684 1
a684 1
  if (!bfd_xcoff_size_dynamic_sections
d687 1
a687 1
       modtype,	textro ? true : false, unix_ld, special_sections,
d707 1
a707 1
	 This assumes we know what the script looks like.  */
d710 1
a710 1
      if (os == NULL)
d716 1
a716 1
	  if ((*pls)->header.type == lang_input_section_enum
d732 1
a732 1
		  if ((*pwls)->header.type == lang_input_section_enum
d814 1
a814 1
  static char *argv_to_target[][2] = {
d830 1
a830 1
      for (j = 1; j < jmax; j++)
d840 1
a840 1
/* Returns
d843 1
a843 1
static int
d874 1
a874 1
/* Returns
d878 1
a878 1
static int
d885 1
a885 1

d903 1
a903 1
  for (bit = 0;; bit++)
d906 1
a906 1
      if (string == NULL)
d909 1
a909 1
      if (0 == strcmp (input, string))
d911 1
a911 1
	  if (1 << bit & syscall_mask)
d915 2
a916 2
	    }
	  else
d1106 1
a1106 1
		  const char *end;
d1109 2
a1110 2

		  if (0 > status)
d1113 1
a1113 1
		      address = bfd_scan_vma (s, &end, 0);
d1118 1
a1118 1

d1269 1
a1269 1
sed $sc ldscripts/${EMULATION_NAME}.xu			   >> e${EMULATION_NAME}.c
d1271 8
a1278 8
sed $sc ldscripts/${EMULATION_NAME}.xr			   >> e${EMULATION_NAME}.c
echo '  ; else if (!config.text_read_only) return'	   >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xbn			   >> e${EMULATION_NAME}.c
echo '  ; else if (!config.magic_demand_paged) return'	   >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xn			   >> e${EMULATION_NAME}.c
echo '  ; else return'					   >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.x			   >> e${EMULATION_NAME}.c
echo '; }'						   >> e${EMULATION_NAME}.c
d1304 1
a1304 1
static void
d1308 2
a1309 2
  if ((bfd_get_flavour (output_bfd) == bfd_target_xcoff_flavour)
      && (link_info.init_function != NULL
d1316 1
a1316 1

d1326 1
a1326 1

d1328 2
a1329 2
      if (false == bfd_xcoff_link_generate_rtinit (initfini_file->the_bfd,
						   link_info.init_function,
d1338 1
a1338 1
      if (true == rtld)
@


1.26.2.2
log
@        * emultempl/aix.em: Use include <> for generated headers.
        * emultempl/beos.em: Likewise.
        * emultempl/elf32.em: Likewise.
        * emultempl/pe.em: Likewise.
        * ldctor.c: Likewise.
        * ldexp.c: Likewise.
        * ldfile.c: Likewise.
        * ldlang.c: Likewise.
        * ldlex.c: Likewise.
        * ldlex.l: Likewise.
        * ldmain.c: Likewise.
        * ldmisc.c: Likewise.
        * ldwrite.c: Likewise.
        * lexsup.c: Likewise.
        * mri.c: Likewise.
        * pe-dll.c: Likewise.
@
text
@d52 1
a52 1
#include <ldgram.h>
@


1.25
log
@	* ldemul.c (ldemul_new_vers_pattern): New function.
	* ldemul.h (ldemul_new_vers_pattern): Declare.
	(struct ld_emulation_xfer_struct): Add new_vers_pattern.
	* ldlang.c (lang_new_vers_pattern): Call ldemul_new_vers_pattern.
	* emultempl/ppc64elf.em (dotsyms): New static var.
	(gld${EMULATION_NAME}_new_vers_pattern): New function.
	(LDEMUL_NEW_VERS_PATTERN): Define.
	(PARSE_AND_LIST_PROLOGUE): Add OPTION_DOTSYMS, OPTION_NO_DOTSYMS.
	(PARSE_AND_LIST_LONGOPTS): Likewise.
	(PARSE_AND_LIST_ARGS_CASES): Handle them.
	* emultempl/aix.em (ld_${EMULATION_NAME}_emulation): Update
	initialiser.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf_oabi.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/generic.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/gld960c.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68kcoff.em: Likewise.
	* emultempl/mipsecoff.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/ticoff.em: Likewise.
	* emultempl/vanilla.em: Likewise.
@
text
@d12 1
a12 1
   Copyright 1991, 1993, 1995, 1996, 1997, 1998, 2000, 2001
d685 1
a685 1
      (output_bfd, &link_info, libpath,	entry_symbol, file_align,
@


1.24
log
@Add -bnortl and -bnortllib support for AIX.
@
text
@d1378 1
@


1.23
log
@XCOFF64 fixes. For setting arch/mach and for R_BR relocations.
@
text
@d138 2
a139 1
/* Whether to do run time linking */
d247 2
@


1.22
log
@Formatting fix.
@
text
@d56 2
d62 1
a62 1
static char *choose_target PARAMS ((int, char **));
d73 3
a75 1
  PARAMS((void));
d139 1
a139 1
static boolean rtld;
d149 1
a149 11
#ifndef TARGET_			/* I.e., if not generic.  */
  const bfd_arch_info_type *arch = bfd_scan_arch ("${OUTPUT_ARCH}");
  if (arch)
    {
      ldfile_output_architecture = arch->arch;
      ldfile_output_machine = arch->mach;
      ldfile_output_machine_name = arch->printable_name;
    }
  else
    ldfile_output_architecture = bfd_arch_${ARCH};
#endif /* not TARGET_ */
d684 2
a685 1
       modtype,	textro ? true : false, unix_ld, special_sections, rtld))
d804 1
a804 1
choose_target (argc, argv)
d1302 1
a1302 1
gld${EMULATION_NAME}_create_output_section_statements()
d1340 12
d1359 2
a1360 2
  set_output_arch_default,
  choose_target,
@


1.21
log
@Add support for AIX -blibpath and -bnolibpath.
@
text
@d529 1
a529 1
      command_line_blibpath=optarg;
d533 1
a533 1
      command_line_blibpath=NULL;
@


1.20
log
@Add AIX 64 shared library support and emulation layer for binutils
@
text
@d137 3
d202 2
d260 2
d528 8
d656 7
a662 4
  /* We need to build LIBPATH from the -L arguments.  If any -rpath
     arguments were used, though, we use -rpath instead, as a GNU
     extension.  */
  if (command_line.rpath != NULL)
@


1.19
log
@Add support for -brtl, run time linking, to AIX ld.
@
text
@d800 2
a801 2
    {"-b32", "aixcoff-rs6000"},
    {"-b64", "aixcoff64-rs6000"},
@


1.18
log
@-binitfini emulation, put __rtinit symbol generation into linker.
@
text
@d133 4
a136 1
 
a160 1

d246 1
d669 4
a672 7
  if (!bfd_xcoff_size_dynamic_sections (output_bfd, &link_info, libpath,
					entry_symbol, file_align,
					maxstack, maxdata,
					gc && !unix_ld ? true : false,
					modtype,
					textro ? true : false,
					unix_ld, special_sections))
d946 5
a950 6
  /*
   * default to 32 and 64 bit mode
   * symbols at top of /lib/syscalls.exp do not have a mode modifier and they
   * are not repeated, assume 64 bit routines also want to use them.
   * See the routine change_symbol_mode for more information.
   */
d1293 3
a1295 1
      && (link_info.init_function != NULL  || link_info.fini_function != NULL))
a1296 1
      
d1314 2
a1315 1
						   link_info.fini_function))
d1320 4
@


1.17
log
@Formatting and misc cleanup for AIX.
@
text
@d70 2
d131 3
d152 4
a155 5
  /*
   * The link_info.[init|fini]_functions are initialized in ld/lexsup.c.
   * Override them here so we can use the link_info.init_function as a
   * state flag that lets the backend know that -binitfini has been done.
   */
d199 8
a206 45
  /*
    binitfini has special handling in the linker backend.  The native linker
    uses the arguemnts to generate a table of init and fini functions for
    the executable.  The important use for this option is to support aix 4.2+
    c++ constructors and destructors.  This is tied into gcc via collect2.c.
    The function table is accessed by the runtime linker/loader by checking if
    the first symbol in the loader symbol table is "__rtinit".  The native
    linker generates this table and the loader symbol.  The gnu linker looks
    for the symbol "__rtinit" and makes it the first loader symbol.  It is the
    responsiblity of the user to define the __rtinit symbol.  The format for
    __rtinit is given by the aix system file /usr/include/rtinit.h.  You can
    look at collect2.c to see an example of how this is done for 32 and 64 bit.
    Below is an exmaple of a 32 bit assembly file that defines __rtinit.

    .file   "my_rtinit.s"

    .csect .data[RW],3
    .globl __rtinit
    .extern init_function
    .extern fini_function

    __rtinit:
            .long 0
            .long f1i - __rtinit
            .long f1f - __rtinit
            .long f2i - f1i
            .align 3
    f1i:    .long init_function
            .long s1i - __rtinit
            .long 0
    f2i:    .long 0
            .long 0
            .long 0
    f1f:    .long fini_function
            .long s1f - __rtinit
            .long 0
    f2f:    .long 0
            .long 0
            .long 0
            .align 3
    s1i:    .string "init_function"
            .align 3
    s1f:    .string "fini_function"

   */
d1289 33
d1336 1
a1336 1
  0,				/* create_output_section_statements */
@


1.16
log
@Pass argc and argv to ldemul_choose_target.
Support -b64 in AIX
@
text
@d60 1
a60 1
static char * choose_target PARAMS ((int, char **));
d64 2
a65 2
static void gld${EMULATION_NAME}_find_relocs
  PARAMS ((lang_statement_union_type *));
d70 2
d172 2
a173 1
  enum {
d302 1
a302 3
    {
      indx = 1;
    }
d348 1
a348 2
      if (*end != '\0'
	  || (val & (val - 1)) != 0)
d402 1
a402 3
	  {
	    link_info.init_function = i;
	  }
d410 1
a410 3
	  {
	    link_info.fini_function = f;
	  }
d412 2
a413 2
    break;

d460 2
a461 1
	einfo ("%P: warning: ignoring invalid -bmaxstack number %s\n", optarg);
d505 1
a505 1
			 exp_intop (~ (bfd_vma) 31));
d526 1
a526 1
			 exp_intop (~ (bfd_vma) 31));
d621 2
a622 2
	 collect, and the sets may already have been built, so we do
	 not do anything.  */
d634 1
a634 1
      if (! bfd_xcoff_link_record_set (output_bfd, &link_info, p->h, size))
d661 1
a661 1
      if (! bfd_xcoff_export_symbol (output_bfd, &link_info, h))
d699 7
a705 8
  if (! bfd_xcoff_size_dynamic_sections (output_bfd, &link_info, libpath,
					 entry_symbol, file_align,
					 maxstack, maxdata,
					 gc && ! unix_ld ? true : false,
					 modtype,
					 textro ? true : false,
					 unix_ld,
					 special_sections))
d724 1
a724 1
	 This assumes we know what the script looks like.  */
d727 1
a727 1
      if (os == NULL) {
a729 1
      }
d733 2
a734 3

	  if ((*pls)->header.type == lang_input_section_enum &&
	      (*pls)->input_section.section == sec)
d736 1
a736 1
	      is = (lang_input_section_type *) *pls;
d746 1
a746 2
		   *pwls != NULL;
		   pwls = &(*pwls)->header.next)
d749 2
a750 2
		  if ((*pwls)->header.type == lang_input_section_enum &&
		      (*pwls)->input_section.section == sec)
d752 1
a752 2

		      is = (lang_input_section_type *) *pwls;
d773 1
a773 1
	default: /* to avoid warnings */
d831 5
a835 6
  static char *argv_to_target[][2] = 
    { 
      NULL,   "aixcoff-rs6000",
      "-b32", "aixcoff-rs6000",
      "-b64", "aixcoff64-rs6000",
    };
d840 1
a840 1
  if (from_outside != (char *)NULL)
d853 1
a853 1
  
d857 6
a862 2

static int change_symbol_mode (char *input)
a863 5
  /*
   * 1 : state changed
   * 0 : no change
   */

d865 4
a868 4
    "# 32",   /* 0x01 */
    "# 64",   /* 0x02 */
    "# no32", /* 0x04 */
    "# no64", /* 0x08 */
d871 1
d875 1
a875 1
  for (bit = 0; ; bit++)
d878 1
a878 1
      if (NULL == string)
d891 8
a898 1
static int is_syscall(char *input, unsigned int *flag)
a899 5
  /*
   * 1 : yes
   * 0 : ignore
   * -1 : error, try something else
   */
d920 5
a924 6
  for (bit = 0; ;bit++) {
    
    string = s[bit].syscall_string;
    if (NULL == string) {
      return -1;
    }
d926 12
a937 7
    if (0 == strcmp(input, string)) {
      if (1 << bit & syscall_mask) {
	*flag = s[bit].flag;
	return 1;
      } else {
	return 0;
      }
a938 1
  }
d1011 1
a1011 1
	  || (! import && *s == '#' && s[1] == '!'))
d1041 1
a1041 2
	      while (! ISSPACE (*s)
		     && *s != '(' && *s != '\0')
d1097 1
a1097 1
	  while (! ISSPACE (*s) && *s != '\0')
d1109 1
a1109 1
	      while (! ISSPACE (*se) && *se != '\0')
d1126 1
a1126 1
		  status = is_syscall(s, &syscall_flag);
d1128 11
a1138 13
		  if (0 > status) {
		    /* not a system call, check for address */
		    address = strtoul (s, &end, 0);

		    /* not a system call, check for address */
		    address = strtoul (s, &end, 0);
		    if (*end != '\0')
		      {
			einfo ("%s:%d: warning: syntax error in import/export file\n",
			       filename, lineno);
			
		      }
		  }
d1142 1
a1142 1
	  if (! import)
d1164 3
a1166 3
		  if (! bfd_xcoff_import_symbol (output_bfd, &link_info, h,
						 address, imppath, impfile,
						 impmember, syscall_flag))
d1182 1
a1182 1
  if (! keep)
d1213 1
a1213 1
      if (! bfd_xcoff_link_count_reloc (output_bfd, &link_info, rs->name))
d1240 2
a1241 2
	  if (! bfd_xcoff_record_link_assignment (output_bfd, &link_info,
						  exp->assign.dst))
d1322 1
a1322 2
struct ld_emulation_xfer_struct ld_${EMULATION_NAME}_emulation =
{
d1335 5
a1339 5
  0,	/* finish */
  0,	/* create_output_section_statements */
  0,	/* open_dynamic_archive */
  0,	/* place_orphan */
  0,	/* set_symbols */
d1342 3
a1344 3
  NULL, /* list_options */
  NULL, /* recognized_file */
  NULL, /* find potential_libraries */
@


1.15
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d60 1
d118 9
d187 3
a189 1
    OPTION_UNIX
a192 5
    b64 is an empty option.  The native linker uses -b64 for xcoff64 support
    Our linker uses -m aixppc64 for xcoff64 support. The choice for the
    correct emulation is done in collect2.c via the environmental varible
    LDEMULATION.

d278 2
a279 1
    {"b64", no_argument, NULL, 0},
d541 13
d831 36
d935 1
a935 1
      if (1 << bit & ${SYSCALL_MASK}) {
d1095 1
a1095 1
      if (symbol_mode & ${SYMBOL_MODE_MASK})
d1338 1
a1338 1
  ldemul_default_target,
@


1.14
log
@Fix import symbols for AIX.
@
text
@d39 1
a43 2
#include <ctype.h>

d952 1
a952 1
      while (isspace ((unsigned char) *s))
d967 1
a967 1
	  while (isspace ((unsigned char) *s))
d988 2
a989 1
	      while (! isspace ((unsigned char) *s) && *s != '(' && *s != '\0')
d1009 1
a1009 1
	      while (isspace ((unsigned char) cs))
d1045 1
a1045 1
	  while (! isspace ((unsigned char) *s) && *s != '\0')
d1053 1
a1053 1
	      while (isspace ((unsigned char) *s))
d1057 1
a1057 1
	      while (! isspace ((unsigned char) *se) && *se != '\0')
d1062 1
a1062 1
		  while (isspace ((unsigned char) *se))
@


1.13
log
@	* emultempl/aix.em: Add missing prototype.
	* emultempl/lnk960.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf_oabi.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/gld960c.em: Likewise.
	* emultempl/gld960.em: Likewise.

	* emulparams/elf64alpha.sh (PARSE_AND_LIST_PROLOGUE): Add parameter
	for prototype declaration.
@
text
@a110 1
  boolean syscall;
d644 1
a644 1
      if (! bfd_xcoff_export_symbol (output_bfd, &link_info, h, el->syscall))
d844 1
a844 2

static int is_syscall (char *input)
d853 14
a866 11

  char *syscall_string[] = {
    "svc",	     /* 0x01 */
    "svc32",	     /* 0x02 */
    "svc3264",	     /* 0x04 */
    "svc64",	     /* 0x08 */
    "syscall",	     /* 0x10 */
    "syscall32",     /* 0x20 */
    "syscall3264",   /* 0x40 */
    "syscall64",     /* 0x80 */
    NULL
d869 1
a869 2
  for (bit = 0; ;bit++)
    {
d871 6
a876 5
      string = syscall_string[bit];
      if (NULL == string)
	{
	  return -1;
	}
d878 7
a884 11
      if (0 == strcmp (input, string))
	{
	  if (1 << bit & ${SYSCALL_MASK})
	    {
	      return 1;
	    }
	  else
	    {
	      return 0;
	    }
	}
d886 1
a890 1

d939 1
a939 1
      boolean syscall;
d1042 1
a1042 1
	  syscall = false;
d1074 15
a1088 23
		  status = is_syscall (s);

		  switch (status)
		    {
		    case 1:
		      /* this is a system call */
		      syscall = true;
		      break;

		    case 0:
		      /* ignore this system call */
		      break;

		    default:
		      /* not a system call, check for address */
		      address = strtoul (s, &end, 0);
		      if (*end != '\0')
			{
			  einfo ("%s:%d: warning: syntax error in import/export file\n",
				 filename, lineno);

			}
		    }
a1100 1
	      n->syscall = syscall;
d1116 1
a1116 1
						 impmember))
@


1.12
log
@	* emultempl/aix.em: Formatting fixes.
@
text
@d68 2
@


1.11
log
@	* emultempl/aix.em: ldexp.h,ldlang.h,ldfile.h,ldemul.h go in this
	order.
@
text
@d120 1
a120 1
gld${EMULATION_NAME}_before_parse()
d139 1
a139 1
   */ 
d162 15
a176 15
    OPTION_AUTOIMP, 
    OPTION_ERNOTOK, 
    OPTION_EROK, 
    OPTION_EXPORT, 
    OPTION_IMPORT, 
    OPTION_INITFINI, 
    OPTION_LOADMAP, 
    OPTION_MAXDATA, 
    OPTION_MAXSTACK, 
    OPTION_MODTYPE, 
    OPTION_NOAUTOIMP, 
    OPTION_NOSTRCMPCT, 
    OPTION_PD, 
    OPTION_PT, 
    OPTION_STRCMPCT, 
d182 1
a182 1
    Our linker uses -m aixppc64 for xcoff64 support. The choice for the 
d185 1
a185 1
	
d190 38
a227 38
	The function table is accessed by the runtime linker/loader by checking if
	the first symbol in the loader symbol table is "__rtinit".  The native
	linker generates this table and the loader symbol.  The gnu linker looks
	for the symbol "__rtinit" and makes it the first loader symbol.  It is the
	responsiblity of the user to define the __rtinit symbol.  The format for
	__rtinit is given by the aix system file /usr/include/rtinit.h.  You can
	look at collect2.c to see an example of how this is done for 32 and 64 bit.
	Below is an exmaple of a 32 bit assembly file that defines __rtinit.

	.file	"my_rtinit.s"
	
	.csect .data[RW],3
	.globl __rtinit
	.extern init_function
	.extern fini_function
	
	__rtinit:
	        .long 0
	        .long f1i - __rtinit
	        .long f1f - __rtinit
	        .long f2i - f1i
	        .align 3
	f1i:	.long init_function
	        .long s1i - __rtinit
	        .long 0
	f2i:	.long 0
	        .long 0
	        .long 0
	f1f:	.long fini_function
	        .long s1f - __rtinit
	        .long 0
	f2f:	.long 0
	        .long 0
	        .long 0
	        .align 3
	s1i:	.string "init_function"
	        .align 3
	s1f:	.string "fini_function"
d290 17
a306 12
  if (indx == 0) {
    indx = 1;
  }

  if (indx < argc && strncmp (argv[indx], "-b", 2) == 0) {
    char *s;
    
    for (s = argv[indx]; *s != '\0'; s++) {
      if (*s == ':') {
	*s = '=';
	break;
      }
a307 1
  }
d369 23
a391 20
    case OPTION_INITFINI: {
      /* 
       * The aix linker init fini has the format :
       *
       * -binitfini:[ Initial][:Termination][:Priority]
       *
       * it allows the Termination and Priority to be optional.
       *
       * Since we support only one init/fini pair, we ignore the Priority.
       * 
       * Define the special symbol __rtinit.
       *
       * strtok does not correctly handle the case of -binitfini::fini: so
       * do it by hand
       */
      char *t, *i, *f;

      i = t = optarg;
      while (*t && ':' != *t) t++;
      if (*t) *t++ = 0;
d393 4
a396 3
      if (0 != strlen(i)) {
	link_info.init_function = i;
      }
d398 4
a401 3
      f = t;
      while (*t && ':' != *t) t++;
      *t = 0;
d403 4
a406 2
      if (0 != strlen(f)) {
	link_info.fini_function = f;
a407 1
    }
d448 1
a448 2
	einfo ("%P: warning: ignoring invalid -bmaxdata number %s\n",
	       optarg);
d456 1
a456 2
	einfo ("%P: warning: ignoring invalid -bmaxstack number %s\n",
	       optarg);
d636 10
a645 9
  for (el = export_symbols; el != NULL; el = el->next) {
    struct bfd_link_hash_entry *h;
    
    h = bfd_link_hash_lookup (link_info.hash, el->name, false, false, false);
    if (h == NULL)
      einfo ("%P%F: bfd_link_hash_lookup of export symbol failed: %E\n");
    if (! bfd_xcoff_export_symbol (output_bfd, &link_info, h, el->syscall))
      einfo ("%P%F: bfd_xcoff_export_symbol failed: %E\n");
  }
d693 8
a700 20
  for (i = 0; i < XCOFF_NUMBER_OF_SPECIAL_SECTIONS; i++) {
    asection *sec;
    lang_output_section_statement_type *os;
    lang_statement_union_type **pls;
    lang_input_section_type *is;
    const char *oname;
    boolean start;

    sec = special_sections[i];
    if (sec == NULL)
      continue;

    /* Remove this section from the list of the output section.
       This assumes we know what the script looks like.  */
    is = NULL;
    os = lang_output_section_find (sec->output_section->name);
    if (os == NULL) {
      einfo ("%P%F: can't find output section %s\n",
	     sec->output_section->name);
    }
d702 3
a704 1
    for (pls = &os->children.head; *pls != NULL; pls = &(*pls)->next) {
d706 7
a712 5
      if ((*pls)->header.type == lang_input_section_enum && 
	  (*pls)->input_section.section == sec)	{
	is = (lang_input_section_type *) *pls;
	*pls = (*pls)->next;
	break;
a713 7
	
      if ((*pls)->header.type == lang_wild_statement_enum) {
	lang_statement_union_type **pwls;
	
	for (pwls = &(*pls)->wild_statement.children.head;
	     *pwls != NULL;
	     pwls = &(*pwls)->next) {
d715 2
a716 2
	  if ((*pwls)->header.type == lang_input_section_enum && 
	      (*pwls)->input_section.section == sec) {
d718 5
a722 2
	      is = (lang_input_section_type *) *pwls;
	      *pwls = (*pwls)->next;
d724 30
a753 1
	  }
d755 28
a782 2
	
	if (is != NULL)
a783 2
      }
    }	
d785 7
a791 40
    if (is == NULL) {
      einfo ("%P%F: can't find %s in output section\n",
	     bfd_get_section_name (sec->owner, sec));
    }
     
    /* Now figure out where the section should go.  */
    switch (i) {

    default: /* to avoid warnings */
    case XCOFF_SPECIAL_SECTION_TEXT:
      /* _text */
      oname = ".text";
      start = true;
      break;
    
    case XCOFF_SPECIAL_SECTION_ETEXT:
      /* _etext */
      oname = ".text";
      start = false;
      break;

    case XCOFF_SPECIAL_SECTION_DATA:
      /* _data */
      oname = ".data";
      start = true;
      break;
    
    case XCOFF_SPECIAL_SECTION_EDATA:
      /* _edata */
      oname = ".data";
      start = false;
      break;

    case XCOFF_SPECIAL_SECTION_END:
    case XCOFF_SPECIAL_SECTION_END2:
      /* _end and end */
      oname = ".bss";
      start = false;
      break;
    }
d793 1
a793 1
    os = lang_output_section_find (oname);
d795 12
a806 8
    if (start) {
      is->header.next = os->children.head;
      os->children.head = (lang_statement_union_type *) is;
    } else {
      is->header.next = NULL;
      lang_statement_append (&os->children,
			     (lang_statement_union_type *) is,
			     &is->header.next);
a807 1
  }
d810 1
a810 1
static int change_symbol_mode (char *input) 
d827 11
a837 8
  for (bit = 0; ; bit++) {
    string = symbol_mode_string[bit];
    if (NULL == string)
      return 0;
    
    if (0 == strcmp(input, string)) {
      symbol_mode = (1 << bit);
      return 1;
a838 1
  }
d844 1
a844 1
static int is_syscall(char *input)
d853 1
a853 1
  
d866 8
a873 6
  for (bit = 0; ;bit++) {
    
    string = syscall_string[bit];
    if (NULL == string) {
      return -1;
    }
d875 11
a885 6
    if (0 == strcmp(input, string)) {
      if (1 << bit & ${SYSCALL_MASK}) {
	return 1;
      } else {
	return 0;
      }
a886 1
  }
d928 1
a928 1
  /* 
d956 5
a960 5
      if (*s == '\0'  || 
	  *s == '*' ||
	  change_symbol_mode (s) ||
	  (*s == '#' && s[1] == ' ') ||
	  (! import && *s == '#' && s[1] == '!'))
d1039 35
a1073 1
      if (symbol_mode & ${SYMBOL_MODE_MASK}) { 
d1075 23
a1097 51
	/* This is a symbol to be imported or exported.  */
	symname = s;
	syscall = false;
	address = (bfd_vma) -1;

	while (! isspace ((unsigned char) *s) && *s != '\0')
	  ++s;
	if (*s != '\0')
	  {
	    char *se;
	    
	    *s++ = '\0';

	    while (isspace ((unsigned char) *s))
	      ++s;

	    se = s;
	    while (! isspace ((unsigned char) *se) && *se != '\0')
	      ++se;
	    if (*se != '\0')
	      {
		*se++ = '\0';
		while (isspace ((unsigned char) *se))
		  ++se;
		if (*se != '\0')
		  einfo ("%s%d: warning: syntax error in import/export file\n",
			 filename, lineno);
	      }

	    if (s != se) {
	      int status;
	      char *end;
			  
	      status = is_syscall(s);
			  
	      switch (status) {
	      case 1:
		/* this is a system call */
		syscall = true;
		break;
					  
	      case 0:
		/* ignore this system call */
		break;
					  
	      default:
		/* not a system call, check for address */
		address = strtoul (s, &end, 0);
		if (*end != '\0') {
		  einfo ("%s:%d: warning: syntax error in import/export file\n", filename, lineno);
			 
a1098 1
	      }
a1099 1
	  }
d1101 3
a1103 3
	if (! import)
	  {
	    struct export_symbol_list *n;
d1105 27
a1131 27
	    ldlang_add_undef (symname);
	    n = ((struct export_symbol_list *)
		 xmalloc (sizeof (struct export_symbol_list)));
	    n->next = export_symbols;
	    n->name = xstrdup (symname);
	    n->syscall = syscall;
	    export_symbols = n;
	  }
	else
	  {
	    h = bfd_link_hash_lookup (link_info.hash, symname, false, false,
				      true);
	    if (h == NULL || h->type == bfd_link_hash_new)
	      {
		/* We can just ignore attempts to import an unreferenced
		   symbol.  */
	      }
	    else
	      {
		if (! bfd_xcoff_import_symbol (output_bfd, &link_info, h,
					       address, imppath, impfile,
					       impmember))
		  einfo ("%X%s:%d: failed to import symbol %s: %E\n",
			 filename, lineno, symname);
	      }
	  }
      }
d1134 1
a1134 1
  
d1137 4
a1140 4
	  einfo ("%s:%d: warning: ignoring unterminated last line\n",
		 filename, lineno);
	  obstack_free (o, obstack_base (o));
	}
d1142 4
a1145 5
      if (! keep)
	{
	  obstack_free (o, NULL);
	  free (o);
	}
d1147 1
d1229 1
a1229 1
gld${EMULATION_NAME}_get_script(isfile)
d1241 1
a1241 1
{			     
d1262 1
a1262 1
{			     
d1282 1
a1282 1
struct ld_emulation_xfer_struct ld_${EMULATION_NAME}_emulation = 
@


1.10
log
@	* ldlang.c (record_bfd_errors): Remove.

	* emultempl/aix.em: Fix copyright dates.
@
text
@a46 2
#include "ldemul.h"
#include "ldfile.h"
d50 2
@


1.9
log
@2001-05-25  H.J. Lu  <hjl@@gnu.org>

	* emulparams/aixrs6.sh: Add SYSCALL_MASK and SYMBOL_MODE_MASK
	like emulparams/aixppc.sh.

	* emultempl/aix.em (sc): Use ${srcdir}/emultempl/ostring.sed
	instead of ${srcdir}/emultempl/stringify.sed.
@
text
@d12 2
a13 1
   Copyright (C) 1991, 93, 95, 96, 97, 1998 Free Software Foundation, Inc.
@


1.8
log
@2001-05-24  H.J. Lu  <hjl@@gnu.org>

	* emultempl/aix.em (OUTPUT_ARCH): Defined.
	(gld${EMULATION_NAME}_before_parse): Initialize
	ldfile_output_architecture, ldfile_output_machine and
	ldfile_output_machine_name from ${OUTPUT_ARCH} if possible.
	* emultempl/beos.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/mipsecoff.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.
@
text
@d1205 1
a1205 1
sc="-f ${srcdir}/emultempl/stringify.sed"
@


1.7
log
@Support for xcoff64
@
text
@d3 5
d122 9
a130 1
  ldfile_output_architecture = bfd_arch_${ARCH};
@


1.6
log
@Add gas and ld support for openrisc
@
text
@d7 1
a7 2
   Copyright 1991, 1993, 1995, 1996, 1997, 1998, 2000
   Free Software Foundation, Inc.
d10 1
d41 2
a45 2
#include "ldfile.h"
#include "ldemul.h"
d49 3
d108 3
d120 9
d143 1
a143 1
  long val;
d146 19
a164 16
#define OPTION_IGNORE (300)
#define OPTION_AUTOIMP (OPTION_IGNORE + 1)
#define OPTION_ERNOTOK (OPTION_AUTOIMP + 1)
#define OPTION_EROK (OPTION_ERNOTOK + 1)
#define OPTION_EXPORT (OPTION_EROK + 1)
#define OPTION_IMPORT (OPTION_EXPORT + 1)
#define OPTION_LOADMAP (OPTION_IMPORT + 1)
#define OPTION_MAXDATA (OPTION_LOADMAP + 1)
#define OPTION_MAXSTACK (OPTION_MAXDATA + 1)
#define OPTION_MODTYPE (OPTION_MAXSTACK + 1)
#define OPTION_NOAUTOIMP (OPTION_MODTYPE + 1)
#define OPTION_NOSTRCMPCT (OPTION_NOAUTOIMP + 1)
#define OPTION_PD (OPTION_NOSTRCMPCT + 1)
#define OPTION_PT (OPTION_PD + 1)
#define OPTION_STRCMPCT (OPTION_PT + 1)
#define OPTION_UNIX (OPTION_STRCMPCT + 1)
d166 52
a217 1
  static struct option longopts[] = {
d235 1
d257 1
d276 1
a276 1
  if (indx == 0)
d278 1
a278 3
  if (indx < argc && strncmp (argv[indx], "-b", 2) == 0)
    {
      char *s;
d280 8
a287 8
      for (s = argv[indx]; *s != '\0'; s++)
	{
	  if (*s == ':')
	    {
	      *s = '=';
	      break;
	    }
	}
d289 2
d312 1
a312 1
      val = strtol (optarg, &end, 0);
d339 1
a339 1
      val = strtoul (optarg, &end, 0);
d351 35
d422 1
a422 1
      val = strtoul (optarg, &end, 0);
d431 1
a431 1
      val = strtoul (optarg, &end, 0);
d464 1
a464 1
      val = strtoul (optarg, &end, 0);
d487 1
a487 1
      val = strtoul (optarg, &end, 0);
d608 1
a608 1
  asection *special_sections[6];
d614 9
a622 10
  for (el = export_symbols; el != NULL; el = el->next)
    {
      struct bfd_link_hash_entry *h;

      h = bfd_link_hash_lookup (link_info.hash, el->name, false, false, false);
      if (h == NULL)
	einfo ("%P%F: bfd_link_hash_lookup of export symbol failed: %E\n");
      if (! bfd_xcoff_export_symbol (output_bfd, &link_info, h, el->syscall))
	einfo ("%P%F: bfd_xcoff_export_symbol failed: %E\n");
    }
d670 36
a705 8
  for (i = 0; i < 6; i++)
    {
      asection *sec;
      lang_output_section_statement_type *os;
      lang_statement_union_type **pls;
      lang_input_section_type *is;
      const char *oname;
      boolean start;
d707 2
a708 3
      sec = special_sections[i];
      if (sec == NULL)
	continue;
d710 2
a711 14
      /* Remove this section from the list of the output section.
         This assumes we know what the script looks like.  */
      is = NULL;
      os = lang_output_section_find (sec->output_section->name);
      if (os == NULL)
	einfo ("%P%F: can't find output section %s\n",
	       sec->output_section->name);
      for (pls = &os->children.head; *pls != NULL; pls = &(*pls)->next)
	{
	  if ((*pls)->header.type == lang_input_section_enum
	      && (*pls)->input_section.section == sec)
	    {
	      is = (lang_input_section_type *) *pls;
	      *pls = (*pls)->next;
d713 79
a791 4
	    }
	  if ((*pls)->header.type == lang_wild_statement_enum)
	    {
	      lang_statement_union_type **pwls;
d793 13
a805 16
	      for (pwls = &(*pls)->wild_statement.children.head;
		   *pwls != NULL;
		   pwls = &(*pwls)->next)
		{
		  if ((*pwls)->header.type == lang_input_section_enum
		      && (*pwls)->input_section.section == sec)
		    {
		      is = (lang_input_section_type *) *pwls;
		      *pwls = (*pwls)->next;
		      break;
		    }
		}
	      if (is != NULL)
		break;
	    }
	}	
a806 3
      if (is == NULL)
	einfo ("%P%F: can't find %s in output section\n",
	       bfd_get_section_name (sec->owner, sec));
d808 21
a828 31
      /* Now figure out where the section should go.  */
      switch (i)
	{
	default: /* to avoid warnings */
	case 0:
	  /* _text */
	  oname = ".text";
	  start = true;
	  break;
	case 1:
	  /* _etext */
	  oname = ".text";
	  start = false;
	  break;
	case 2:
	  /* _data */
	  oname = ".data";
	  start = true;
	  break;
	case 3:
	  /* _edata */
	  oname = ".data";
	  start = false;
	  break;
	case 4:
	case 5:
	  /* _end and end */
	  oname = ".bss";
	  start = false;
	  break;
	}
d830 6
a835 1
      os = lang_output_section_find (oname);
d837 6
a842 12
      if (start)
	{
	  is->header.next = os->children.head;
	  os->children.head = (lang_statement_union_type *) is;
	}
      else
	{
	  is->header.next = NULL;
	  lang_statement_append (&os->children,
				 (lang_statement_union_type *) is,
				 &is->header.next);
	}
d844 3
d849 1
d885 9
d914 5
a918 4
      if (*s == '\0'
	  || *s == '*'
	  || (*s == '#' && s[1] == ' ')
	  || (! import && *s == '#' && s[1] == '!'))
d997 1
a997 4
      /* This is a symbol to be imported or exported.  */
      symname = s;
      syscall = false;
      address = (bfd_vma) -1;
d999 28
a1026 23
      while (! isspace ((unsigned char) *s) && *s != '\0')
	++s;
      if (*s != '\0')
	{
	  char *se;

	  *s++ = '\0';

	  while (isspace ((unsigned char) *s))
	    ++s;

	  se = s;
	  while (! isspace ((unsigned char) *se) && *se != '\0')
	    ++se;
	  if (*se != '\0')
	    {
	      *se++ = '\0';
	      while (isspace ((unsigned char) *se))
		++se;
	      if (*se != '\0')
		einfo ("%s%d: warning: syntax error in import/export file\n",
		       filename, lineno);
	    }
d1028 2
a1029 9
	  if (s == se)
	    {
	      /* There was no address after all.  */
	    }
	  else if (strcasecmp (s, "svc") == 0
		   || strcasecmp (s, "syscall") == 0)
	    syscall = true;
	  else
	    {
d1031 21
a1051 5

	      address = strtoul (s, &end, 0);
	      if (*end != '\0')
		einfo ("%s:%d: warning: syntax error in import/export file\n",
		       filename, lineno);
d1053 1
a1053 32
	}

      if (! import)
	{
	  struct export_symbol_list *n;

	  ldlang_add_undef (symname);
	  n = ((struct export_symbol_list *)
	       xmalloc (sizeof (struct export_symbol_list)));
	  n->next = export_symbols;
	  n->name = xstrdup (symname);
	  n->syscall = syscall;
	  export_symbols = n;
	}
      else
	{
	  h = bfd_link_hash_lookup (link_info.hash, symname, false, false,
				    true);
	  if (h == NULL || h->type == bfd_link_hash_new)
	    {
	      /* We can just ignore attempts to import an unreferenced
		 symbol.  */
	    }
	  else
	    {
	      if (! bfd_xcoff_import_symbol (output_bfd, &link_info, h,
					     address, imppath, impfile,
					     impmember))
		einfo ("%X%s:%d: failed to import symbol %s: %E\n",
		       filename, lineno, symname);
	    }
	}
d1055 31
d1088 1
a1088 1

d1091 4
a1094 4
      einfo ("%s:%d: warning: ignoring unterminated last line\n",
	     filename, lineno);
      obstack_free (o, obstack_base (o));
    }
d1096 5
a1100 4
  if (! keep)
    {
      obstack_free (o, NULL);
      free (o);
a1101 1
}
d1192 1
a1192 1
sc="-f stringify.sed"
d1257 3
a1259 1
  NULL 	/* find_potential_libraries */
@


1.5
log
@Fixtypos in ChangeLogs, fix copyright dates in files
@
text
@d860 1
a860 1
	  n->name = buystring (symname);
@


1.4
log
@Remove some forward declarations in ldemul.h and ldfile.h, and
re-arrange header include order.
Fix shadowing warnings in ldlang.h
Fix compile errors in mpw-elfmips.c
@
text
@d7 1
a7 1
   Copyright (C) 1991, 93, 95, 96, 97, 98, 99, 2000
@


1.4.2.1
log
@Update copyright notices.
@
text
@d7 1
a7 1
   Copyright 1991, 1993, 1995, 1996, 1997, 1998, 2000, 2001
@


1.4.2.2
log
@	* ldlang.c (record_bfd_errors): Remove.

	Merge from mainline.
	2001-05-31  H.J. Lu  <hjl@@gnu.org>
	* ldlang.c (open_input_bfds): Don't change the bfd error
	handler whilst loading symbols.

	2001-05-02  Nick Clifton  <nickc@@redhat.com>
	* emultempl/aix.em: Replace buystring with xstrdup.
	* emultempl/beos.em: Replace buystring with xstrdup.
@
text
@d860 1
a860 1
	  n->name = xstrdup (symname);
@


1.3
log
@GCC warning fix: Add missing NULL initialiser for find_potential_libraries.
@
text
@d7 2
a8 1
   Copyright (C) 1991, 93, 95, 96, 97, 98, 1999 Free Software Foundation, Inc.
a40 2
#include "ldemul.h"
#include "ldfile.h"
d44 2
@


1.2
log
@	* emultempl/ostring.sed: Rename from stringify.sed.
	* emultempl/astring.sed: New file.
	* Makefile.am (stringify.sed): New target.
	(GEN_DEPENDS): Change $(srcdir)/emultempl/stringify.sed to
	stringify.sed.
	* configure.in: Define and substitute STRINGIFY.
	* emultempl/*.em: Use stringify.sed from build directory rather
	than source directory.
	* emultempl/elf32.em: Use stringify.sed rather than inline sed
	script.
	* emultempl/gld960.em, emultempl/gld960c.em: Likewise.
	* emultempl/hppaelf.em, emultempl/linux.em: Likewise.
	* emultempl/lnk960.em, emultempl/sunos.em: Likewise.
	* configure, Makefile.in: Rebuild.
@
text
@d1052 2
a1053 1
  gld${EMULATION_NAME}_unrecognized_file
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
   Copyright (C) 1991, 93, 95, 96, 97, 1998 Free Software Foundation, Inc.
d988 1
a988 1
sc="-f ${srcdir}/emultempl/stringify.sed"
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

