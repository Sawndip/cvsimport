head	1.18;
access;
symbols
	binutils-2_24-branch:1.18.0.10
	binutils-2_24-branchpoint:1.18
	binutils-2_21_1:1.18
	binutils-2_23_2:1.18
	binutils-2_23_1:1.18
	binutils-2_23:1.18
	binutils-2_23-branch:1.18.0.8
	binutils-2_23-branchpoint:1.18
	binutils-2_22_branch:1.18.0.6
	binutils-2_22:1.18
	binutils-2_22-branch:1.18.0.4
	binutils-2_22-branchpoint:1.18
	binutils-2_21:1.18
	binutils-2_21-branch:1.18.0.2
	binutils-2_21-branchpoint:1.18
	binutils-2_20_1:1.16
	binutils-2_20:1.16
	binutils-arc-20081103-branch:1.14.0.8
	binutils-arc-20081103-branchpoint:1.14
	binutils-2_20-branch:1.16.0.2
	binutils-2_20-branchpoint:1.16
	dje-cgen-play1-branch:1.14.0.6
	dje-cgen-play1-branchpoint:1.14
	arc-20081103-branch:1.14.0.4
	arc-20081103-branchpoint:1.14
	binutils-2_19_1:1.14
	binutils-2_19:1.14
	binutils-2_19-branch:1.14.0.2
	binutils-2_19-branchpoint:1.14
	binutils-2_18:1.12
	binutils-2_18-branch:1.12.0.2
	binutils-2_18-branchpoint:1.12
	binutils-csl-coldfire-4_1-32:1.10
	binutils-csl-sourcerygxx-4_1-32:1.10
	binutils-csl-innovasic-fido-3_4_4-33:1.10
	binutils-csl-sourcerygxx-3_4_4-32:1.8
	binutils-csl-coldfire-4_1-30:1.10
	binutils-csl-sourcerygxx-4_1-30:1.10
	binutils-csl-coldfire-4_1-28:1.10
	binutils-csl-sourcerygxx-4_1-29:1.10
	binutils-csl-sourcerygxx-4_1-28:1.10
	binutils-csl-arm-2006q3-27:1.10
	binutils-csl-sourcerygxx-4_1-27:1.10
	binutils-csl-arm-2006q3-26:1.10
	binutils-csl-sourcerygxx-4_1-26:1.10
	binutils-csl-sourcerygxx-4_1-25:1.10
	binutils-csl-sourcerygxx-4_1-24:1.10
	binutils-csl-sourcerygxx-4_1-23:1.10
	binutils-csl-sourcerygxx-4_1-21:1.10
	binutils-csl-arm-2006q3-21:1.10
	binutils-csl-sourcerygxx-4_1-22:1.10
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.10
	binutils-csl-sourcerygxx-4_1-20:1.10
	binutils-csl-arm-2006q3-19:1.10
	binutils-csl-sourcerygxx-4_1-19:1.10
	binutils-csl-sourcerygxx-4_1-18:1.10
	binutils-csl-renesas-4_1-9:1.10
	binutils-csl-sourcerygxx-3_4_4-25:1.8
	binutils-csl-renesas-4_1-8:1.10
	binutils-csl-renesas-4_1-7:1.10
	binutils-csl-renesas-4_1-6:1.10
	binutils-csl-sourcerygxx-4_1-17:1.10
	binutils-csl-sourcerygxx-4_1-14:1.10
	binutils-csl-sourcerygxx-4_1-15:1.10
	binutils-csl-sourcerygxx-4_1-13:1.10
	binutils-2_17:1.10
	binutils-csl-sourcerygxx-4_1-12:1.10
	binutils-csl-sourcerygxx-3_4_4-21:1.10
	binutils-csl-wrs-linux-3_4_4-24:1.8
	binutils-csl-wrs-linux-3_4_4-23:1.8
	binutils-csl-sourcerygxx-4_1-9:1.10
	binutils-csl-sourcerygxx-4_1-8:1.10
	binutils-csl-sourcerygxx-4_1-7:1.10
	binutils-csl-arm-2006q1-6:1.10
	binutils-csl-sourcerygxx-4_1-6:1.10
	binutils-csl-wrs-linux-3_4_4-22:1.8
	binutils-csl-coldfire-4_1-11:1.10
	binutils-csl-sourcerygxx-3_4_4-19:1.10
	binutils-csl-coldfire-4_1-10:1.10
	binutils-csl-sourcerygxx-4_1-5:1.10
	binutils-csl-sourcerygxx-4_1-4:1.10
	binutils-csl-wrs-linux-3_4_4-21:1.8
	binutils-csl-morpho-4_1-4:1.10
	binutils-csl-sourcerygxx-3_4_4-17:1.10
	binutils-csl-wrs-linux-3_4_4-20:1.8
	binutils-2_17-branch:1.10.0.4
	binutils-2_17-branchpoint:1.10
	binutils-csl-2_17-branch:1.10.0.2
	binutils-csl-2_17-branchpoint:1.10
	binutils-csl-gxxpro-3_4-branch:1.8.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.8
	binutils-2_16_1:1.8
	binutils-csl-arm-2005q1b:1.8
	binutils-2_16:1.8
	binutils-csl-arm-2005q1a:1.8
	binutils-csl-arm-2005q1-branch:1.8.0.4
	binutils-csl-arm-2005q1-branchpoint:1.8
	binutils-2_16-branch:1.8.0.2
	binutils-2_16-branchpoint:1.8
	csl-arm-2004-q3d:1.8
	csl-arm-2004-q3:1.8
	binutils-2_15:1.6.6.1
	binutils-2_15-branchpoint:1.6
	csl-arm-2004-q1a:1.7
	csl-arm-2004-q1:1.7
	binutils-2_15-branch:1.6.0.6
	cagney_bfdfile-20040213-branch:1.6.0.4
	cagney_bfdfile-20040213-branchpoint:1.6
	cagney_bigcore-20040122-branch:1.6.0.2
	cagney_bigcore-20040122-branchpoint:1.6
	csl-arm-2003-q4:1.6
	binutils-2_14:1.3
	binutils-2_14-branch:1.3.0.2
	binutils-2_14-branchpoint:1.3
	binutils-2_13_2_1:1.1
	binutils-2_13_2:1.1
	binutils-2_13_1:1.1
	binutils-2_13:1.1
	binutils-2_13-branchpoint:1.1
	binutils-2_13-branch:1.1.0.4
	binutils-2_12_1:1.1
	binutils-2_12:1.1
	binutils-2_12-branch:1.1.0.2
	binutils-2_12-branchpoint:1.1
	binutils_latest_snapshot:1.18;
locks; strict;
comment	@# @;


1.18
date	2010.03.18.13.15.46;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2009.11.26.13.45.25;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2009.09.02.07.25.35;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2009.08.10.07.50.56;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2008.07.07.00.46.51;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2008.02.15.03.35.53;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2007.07.19.19.56.10;	author roland;	state Exp;
branches;
next	1.11;

1.11
date	2007.07.06.14.09.42;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2005.08.17.05.13.13;	author kkojima;	state Exp;
branches;
next	1.9;

1.9
date	2005.05.12.07.32.04;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2004.06.24.04.46.28;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2004.03.27.10.58.35;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2003.07.08.18.05.34;	author amylaar;	state Exp;
branches
	1.6.6.1;
next	1.5;

1.5
date	2003.06.27.00.38.25;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.25.06.40.27;	author amodra;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.23.11.51.35;	author amodra;	state Exp;
branches;
next	1.2;

1.2
date	2002.11.30.08.39.46;	author amodra;	state Exp;
branches;
next	1.1;

1.1
date	2002.02.08.06.39.00;	author aoliva;	state Exp;
branches;
next	;

1.6.6.1
date	2004.04.08.12.41.54;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.18
log
@        PR ld/11384
        * emultempl/sh64elf.em: Add missing EOF.
@
text
@# This shell script emits a C file. -*- C -*-
#   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009
#   Free Software Foundation, Inc.
#
# This file is part of the GNU Binutils.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
# MA 02110-1301, USA.
#

# This file is sourced from elf32.em, and defines extra sh64
# specific routines.
#

LDEMUL_AFTER_ALLOCATION=sh64_elf_${EMULATION_NAME}_after_allocation
LDEMUL_BEFORE_ALLOCATION=sh64_elf_${EMULATION_NAME}_before_allocation

fragment <<EOF

#include "libiberty.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "elf/sh.h"
#include "elf32-sh64.h"

/* Check if we need a .cranges section and create it if it's not in any
   input file.  It might seem better to always create it and if unneeded,
   discard it, but I don't find a simple way to discard it totally from
   the output.

   Putting it here instead of as a elf_backend_always_size_sections hook
   in elf32-sh64.c, means that we have access to linker command line
   options here, and we can access input sections in the order in which
   they will be linked.  */

static void
sh64_elf_${EMULATION_NAME}_before_allocation (void)
{
  asection *cranges;
  asection *osec;

  /* Call main function; we're just extending it.  */
  gld${EMULATION_NAME}_before_allocation ();

  cranges = bfd_get_section_by_name (link_info.output_bfd,
				     SH64_CRANGES_SECTION_NAME);

  if (cranges != NULL)
    {
      if (RELAXATION_ENABLED)
	{
	  /* FIXME: Look through incoming sections with .cranges
	     descriptors, build up some kind of descriptors that the
	     relaxing function will pick up and adjust, or perhaps make it
	     find and adjust an associated .cranges descriptor.  We could
	     also look through incoming relocs and kill the ones marking
	     relaxation areas, but that wouldn't be TRT.  */
	  einfo
	    (_("%P: Sorry, turning off relaxing: .cranges section in input.\n"));
	  einfo (_(" A .cranges section is present in:\n"));

	  {
	    LANG_FOR_EACH_INPUT_STATEMENT (f)
	      {
		asection *input_cranges
		  = bfd_get_section_by_name (f->the_bfd,
					     SH64_CRANGES_SECTION_NAME);
		if (input_cranges != NULL)
		  einfo (" %I\n", f);
	      }
	  }

	  DISABLE_RELAXATION;
	}

      /* We wouldn't need to do anything when there's already a .cranges
	 section (and have a return here), except that we need to set the
	 section flags right for output sections that *don't* need a
	 .cranges section.  */
    }

  if (RELAXATION_ENABLED)
    {
      LANG_FOR_EACH_INPUT_STATEMENT (f)
	{
	  if (bfd_get_flavour (f->the_bfd) == bfd_target_elf_flavour)
	    {
	      asection *isec;

	      for (isec = f->the_bfd->sections;
		   isec != NULL;
		   isec = isec->next)
		{
		  if (elf_section_data (isec)->this_hdr.sh_flags
		      & (SHF_SH5_ISA32 | SHF_SH5_ISA32_MIXED))
		    {
		      einfo (_("%P: Sorry, turning off relaxing: SHmedia sections present.\n"));
		      einfo ("  %I\n", f);
		      DISABLE_RELAXATION;
		      goto done_scanning_shmedia_sections;
		    }
		}
	    }
	}
    }
 done_scanning_shmedia_sections:

  /* For each non-empty input section in each output section, check if it
     has the same SH64-specific flags.  If some input section differs, we
     need a .cranges section.  */
  for (osec = link_info.output_bfd->sections;
       osec != NULL;
       osec = osec->next)
    {
      struct sh64_section_data *sh64_sec_data;
      bfd_vma oflags_isa = 0;
      bfd_vma iflags_isa = 0;

      if (bfd_get_flavour (link_info.output_bfd) != bfd_target_elf_flavour)
	einfo (_("%FError: non-ELF output formats are not supported by this target's linker.\n"));

      sh64_sec_data = sh64_elf_section_data (osec)->sh64_info;

      /* Omit excluded or garbage-collected sections.  */
      if (bfd_get_section_flags (link_info.output_bfd, osec) & SEC_EXCLUDE)
	continue;

      /* Make sure we have the target section data initialized.  */
      if (sh64_sec_data == NULL)
	{
	  sh64_sec_data = xcalloc (1, sizeof (struct sh64_section_data));
	  sh64_elf_section_data (osec)->sh64_info = sh64_sec_data;
	}

      /* First find an input section so we have flags to compare with; the
	 flags in the output section are not valid.  */
      {
	LANG_FOR_EACH_INPUT_STATEMENT (f)
	  {
	    asection *isec;

	    for (isec = f->the_bfd->sections;
		 isec != NULL;
		 isec = isec->next)
	      {
		if (isec->output_section == osec
		    && isec->size != 0
		    && (bfd_get_section_flags (isec->owner, isec)
			& SEC_EXCLUDE) == 0)
		  {
		    oflags_isa
		      = (elf_section_data (isec)->this_hdr.sh_flags
			 & (SHF_SH5_ISA32 | SHF_SH5_ISA32_MIXED));
		    goto break_1;
		  }
	      }
	  }
      }

    break_1:

      /* Check that all input sections have the same contents-type flags
         as the first input section.  */
      {
	LANG_FOR_EACH_INPUT_STATEMENT (f)
	  {
	    asection *isec;

	    for (isec = f->the_bfd->sections;
		 isec != NULL;
		 isec = isec->next)
	      {
		if (isec->output_section == osec
		    && isec->size != 0
		    && (bfd_get_section_flags (isec->owner, isec)
			& SEC_EXCLUDE) == 0)
		  {
		    iflags_isa
		      = (elf_section_data (isec)->this_hdr.sh_flags
			 & (SHF_SH5_ISA32 | SHF_SH5_ISA32_MIXED));

		    /* If flags don't agree, we need a .cranges section.
		       Create it here if it did not exist through input
		       sections.  */
		    if (iflags_isa != oflags_isa)
		      {
			if (cranges == NULL)
			  {
			    /* This section will be *appended* to
			       sections, so the outer iteration will reach
			       it in due time and set
			       sh64_elf_section_data; no need to set it
			       specifically here.  */
			    cranges
			      = bfd_make_section_with_flags (link_info.output_bfd,
							     SH64_CRANGES_SECTION_NAME,
							     SEC_LINKER_CREATED
							     | SEC_KEEP
							     | SEC_HAS_CONTENTS
							     | SEC_DEBUGGING);
			    if (cranges == NULL)
			      einfo
				(_("%P%E%F: Can't make .cranges section\n"));
			  }

			/* We don't need to look at more input sections,
			   and we know this section will have mixed
			   contents.  */
			goto break_2;
		      }
		  }
	      }
	  }
      }

      /* If we got here, then all input sections in this output section
	 have the same contents flag.  Put that where we expect to see
	 contents flags.  We don't need to do this for sections that will
	 need additional, linker-generated .cranges entries.  */
      sh64_sec_data->contents_flags = iflags_isa;

    break_2:
      ;
    }
}

/* Size up and extend the .cranges section, merging generated entries.  */

static void
sh64_elf_${EMULATION_NAME}_after_allocation (void)
{
  bfd_vma new_cranges = 0;
  bfd_vma cranges_growth = 0;
  asection *osec;
  bfd_byte *crangesp;
  asection *cranges;

  gld${EMULATION_NAME}_after_allocation ();

  cranges = bfd_get_section_by_name (link_info.output_bfd,
				     SH64_CRANGES_SECTION_NAME);

  /* If there is no .cranges section, it is because it was seen earlier on
     that none was needed.  Otherwise it must have been created then, or
     be present in input.  */
  if (cranges == NULL)
    return;

  /* First, we set the ISA flags for each output section according to the
     first non-discarded section.  For each input section in osec, we
     check if it has the same flags.  If it does not, we set flags to mark
     a mixed section (and exit the loop early).  */
  for (osec = link_info.output_bfd->sections;
       osec != NULL;
       osec = osec->next)
    {
      bfd_vma oflags_isa = 0;
      bfd_boolean need_check_cranges = FALSE;

      /* Omit excluded or garbage-collected sections.  */
      if (bfd_get_section_flags (link_info.output_bfd, osec) & SEC_EXCLUDE)
	continue;

      /* First find an input section so we have flags to compare with; the
	 flags in the output section are not valid.  */
      {
	LANG_FOR_EACH_INPUT_STATEMENT (f)
	  {
	    asection *isec;

	    for (isec = f->the_bfd->sections;
		 isec != NULL;
		 isec = isec->next)
	      {
		if (isec->output_section == osec
		    && isec->size != 0
		    && (bfd_get_section_flags (isec->owner, isec)
			& SEC_EXCLUDE) == 0)
		  {
		    oflags_isa
		      = (elf_section_data (isec)->this_hdr.sh_flags
			 & (SHF_SH5_ISA32 | SHF_SH5_ISA32_MIXED));
		    goto break_1;
		  }
	      }
	  }
      }

    break_1:

      /* Check that all input sections have the same contents-type flags
         as the first input section.  */
      {
	LANG_FOR_EACH_INPUT_STATEMENT (f)
	  {
	    asection *isec;

	    for (isec = f->the_bfd->sections;
		 isec != NULL;
		 isec = isec->next)
	      {
		if (isec->output_section == osec
		    && isec->size != 0
		    && (bfd_get_section_flags (isec->owner, isec)
			& SEC_EXCLUDE) == 0)
		  {
		    bfd_vma iflags_isa
		      = (elf_section_data (isec)->this_hdr.sh_flags
			 & (SHF_SH5_ISA32 | SHF_SH5_ISA32_MIXED));

		    /* If flags don't agree, set the target-specific data
		       of the section to mark that this section needs to
		       be have .cranges section entries added.  Don't
		       bother setting ELF section flags in output section;
		       they will be cleared later and will have to be
		       re-initialized before the linked file is written.  */
		    if (iflags_isa != oflags_isa)
		      {
			oflags_isa = SHF_SH5_ISA32_MIXED;

			BFD_ASSERT (sh64_elf_section_data (osec)->sh64_info);

			sh64_elf_section_data (osec)->sh64_info->contents_flags
			  = SHF_SH5_ISA32_MIXED;
			need_check_cranges = TRUE;
			goto break_2;
		      }
		  }
	      }
	  }
      }

    break_2:

      /* If there were no new ranges for this output section, we don't
	 need to iterate over the input sections to check how many are
	 needed.  */
      if (! need_check_cranges)
	continue;

      /* If we found a section with differing contents type, we need more
	 ranges to mark the sections that are not mixed (and already have
	 .cranges descriptors).  Calculate the maximum number of new
	 entries here.  We may merge some of them, so that number is not
	 final; it can shrink.  */
      {
	LANG_FOR_EACH_INPUT_STATEMENT (f)
	  {
	    asection *isec;

	    for (isec = f->the_bfd->sections;
		 isec != NULL;
		 isec = isec->next)
	      {
		if (isec->output_section == osec
		    && isec->size != 0
		    && (bfd_get_section_flags (isec->owner, isec)
			& SEC_EXCLUDE) == 0
		    && ((elf_section_data (isec)->this_hdr.sh_flags
			 & (SHF_SH5_ISA32 | SHF_SH5_ISA32_MIXED))
			!= SHF_SH5_ISA32_MIXED))
		  new_cranges++;
	      }
	  }
      }
    }

  if (cranges->contents != NULL)
    free (cranges->contents);

  BFD_ASSERT (sh64_elf_section_data (cranges)->sh64_info != NULL);

  /* Make sure we have .cranges in memory even if there were only
     assembler-generated .cranges.  */
  cranges_growth = new_cranges * SH64_CRANGE_SIZE;
  cranges->contents = xcalloc (cranges->size + cranges_growth, 1);
  bfd_set_section_flags (cranges->owner, cranges,
			 bfd_get_section_flags (cranges->owner, cranges)
			 | SEC_IN_MEMORY);

  /* If we don't need to grow the .cranges section beyond what was in the
     input sections, we have nothing more to do here.  We then only got
     here because there was a .cranges section coming from input.  Zero
     out the number of generated .cranges.  */
  if (new_cranges == 0)
    {
      sh64_elf_section_data (cranges)->sh64_info->cranges_growth = 0;
      return;
    }

  crangesp = cranges->contents + cranges->size;

  /* Now pass over the sections again, and make reloc orders for the new
     .cranges entries.  Constants are set as we go.  */
  for (osec = link_info.output_bfd->sections;
       osec != NULL;
       osec = osec->next)
    {
      struct bfd_link_order *cr_addr_order = NULL;
      enum sh64_elf_cr_type last_cr_type = CRT_NONE;
      bfd_vma last_cr_size = 0;
      bfd_vma continuation_vma = 0;

      /* Omit excluded or garbage-collected sections, and output sections
	 which were not marked as needing further processing.  */
      if ((bfd_get_section_flags (link_info.output_bfd, osec) & SEC_EXCLUDE) != 0
	  || (sh64_elf_section_data (osec)->sh64_info->contents_flags
	      != SHF_SH5_ISA32_MIXED))
	continue;

      {
	LANG_FOR_EACH_INPUT_STATEMENT (f)
	  {
	    asection *isec;

	    for (isec = f->the_bfd->sections;
		 isec != NULL;
		 isec = isec->next)
	      {
		/* Allow only sections that have (at least initially) a
		   non-zero size, and are not excluded, and are not marked
		   as containing mixed data, thus already having .cranges
		   entries.  */
		if (isec->output_section == osec
		    && isec->size != 0
		    && (bfd_get_section_flags (isec->owner, isec)
			& SEC_EXCLUDE) == 0
		    && ((elf_section_data (isec)->this_hdr.sh_flags
			 & (SHF_SH5_ISA32 | SHF_SH5_ISA32_MIXED))
			!= SHF_SH5_ISA32_MIXED))
		  {
		    enum sh64_elf_cr_type cr_type;
		    bfd_vma cr_size;
		    bfd_vma isa_flags
		      = (elf_section_data (isec)->this_hdr.sh_flags
			 & (SHF_SH5_ISA32 | SHF_SH5_ISA32_MIXED));

		    if (isa_flags == SHF_SH5_ISA32)
		      cr_type = CRT_SH5_ISA32;
		    else if ((bfd_get_section_flags (isec->owner, isec)
			      & SEC_CODE) == 0)
		      cr_type = CRT_DATA;
		    else
		      cr_type = CRT_SH5_ISA16;

		    cr_size = isec->size;

		    /* Sections can be empty, like .text in a file that
		       only contains other sections.  Ranges shouldn't be
		       emitted for them.  This can presumably happen after
		       relaxing and is not be caught at the "raw size"
		       test above.  */
		    if (cr_size == 0)
		      continue;

		    /* See if this is a continuation of the previous range
		       for the same output section.  If so, just change
		       the size of the last range and continue.  */
		    if (cr_type == last_cr_type
			&& (continuation_vma
			    == osec->vma + isec->output_offset))
		      {
			last_cr_size += cr_size;
			bfd_put_32 (link_info.output_bfd, last_cr_size,
				    crangesp - SH64_CRANGE_SIZE
				    + SH64_CRANGE_CR_SIZE_OFFSET);

			continuation_vma += cr_size;
			continue;
		      }

		    /* If we emit relocatable contents, we need a
		       relocation for the start address.  */
		    if (link_info.relocatable || link_info.emitrelocations)
		      {
			/* FIXME: We could perhaps use lang_add_reloc and
			   friends here, but I'm not really sure that
			   would leave us free to do some optimizations
			   later.  */
			cr_addr_order
			  = bfd_new_link_order (link_info.output_bfd, cranges);

			if (cr_addr_order == NULL)
			  {
			    einfo (_("%P%F: bfd_new_link_order failed\n"));
			    return;
			  }

			cr_addr_order->type = bfd_section_reloc_link_order;
			cr_addr_order->offset
			  = (cranges->output_offset
			     + crangesp + SH64_CRANGE_CR_ADDR_OFFSET
			     - cranges->contents);
			cr_addr_order->size = 4;
			cr_addr_order->u.reloc.p
			  = xmalloc (sizeof (struct bfd_link_order_reloc));

			cr_addr_order->u.reloc.p->reloc = BFD_RELOC_32;
			cr_addr_order->u.reloc.p->u.section = osec;

			/* Since SH, unlike normal RELA-targets, uses a
			   "partial inplace" REL-like relocation for this,
			   we put the addend in the contents and specify 0
			   for the reloc.  */
			bfd_put_32 (link_info.output_bfd, isec->output_offset,
				    crangesp + SH64_CRANGE_CR_ADDR_OFFSET);
			cr_addr_order->u.reloc.p->addend = 0;
		      }
		    else
		      bfd_put_32 (link_info.output_bfd,
				  osec->vma + isec->output_offset,
				  crangesp + SH64_CRANGE_CR_ADDR_OFFSET);

		    /* If we could make a reloc for cr_size we would do
		       it, but we would have to have a symbol for the size
		       of the _input_ section and there's no way to
		       generate that.  */
		    bfd_put_32 (link_info.output_bfd, cr_size,
				crangesp + SH64_CRANGE_CR_SIZE_OFFSET);

		    bfd_put_16 (link_info.output_bfd, cr_type,
				crangesp + SH64_CRANGE_CR_TYPE_OFFSET);

		    last_cr_type = cr_type;
		    last_cr_size = cr_size;
		    continuation_vma
		      = osec->vma + isec->output_offset + cr_size;
		    crangesp += SH64_CRANGE_SIZE;
		  }
	      }
	  }
      }
    }

  /* The .cranges section will have this size, no larger or smaller.
     Since relocs (if relocatable linking) will be emitted into the
     "extended" size, we must set the raw size to the total.  We have to
     keep track of the number of new .cranges entries.

     Sorting before writing is done by sh64_elf_final_write_processing.  */

  sh64_elf_section_data (cranges)->sh64_info->cranges_growth
    = crangesp - cranges->contents - cranges->size;
  cranges->size = crangesp - cranges->contents;
  cranges->rawsize = cranges->size;
}
EOF


@


1.17
log
@        PR ld/10956
        * ld.h (struct args_type): Rename 'relax' field to
        'disable_target_specific_optimizations' and turn it into a
        tri-state variable.
        (RELAXATION_DISABLED_BY_DEFAULT): New macro.
        (RELAXATION_DISABLED_BY_USER): New macro.
        (RELAXATION_ENABLED): New macro.
        (DISABLE_RELAXATION): New macro.
        (ENABLE_RELAXATION): New macro.
        * lexsup (enum option_values): Add OPTION_NO_RELAX.
        (struct ld_options): Add --no-relax.
        (parse_args): Handle OPTION_NO_RELAX.  Use DISABLE_RELAXATION and
        ENABLE_RELAXATION macros.
        * ldlang.c (lang_relax_sections): Use RELAXATION_ENABLED macro.
        (lang_process): Likewise.
        * ldmain.c (main): Initialise
        disable_target_specific_optimizations field.
        (multiple_definition): Use RELAXATION_ENABLED macro.
        * ld.texinfo: Document new command line option.
        * emultempl/alphaelf.em: Remove --no-relax option.
        (before_allocation): Test RELAXATION_DISABLED_BY_USER macro.
        Use ENABLE_RELAXATION macro.
        * emultempl/avrelf.em: (after_allocation): Test RELAXATION_ENABLED
        macro.
        * emultempl/cr16elf.em: Remove --no-relax option.
        (before_allocation): Test RELAXATION_DISABLED_BY_USER macro.
        Use ENABLE_RELAXATION macro.
        * emultempl/crxelf.em: Remove --no-relax option.
        (before_allocation): Test RELAXATION_DISABLED_BY_USER macro.
        Use ENABLE_RELAXATION macro.
        * emultempl/mmix-elfnmmo.em: (before_allocation): Use
        ENABLE_RELAXATION macro.
        * emultempl/needrelax.em: (before_allocation): Use
        ENABLE_RELAXATION macro.
        * emultempl/ppc32elf.em: (before_allocation): Test
        RELAXATION_DISABLED_BY_DEFAULT macro. Use
        ENABLE_RELAXATION macro.
        * emultempl/sh64elf.em: (before_allocation): Test
        RELAXATION_ENABLED macro. Use DISABLE_RELAXATION macro.
        * emultempl/xtensaelf.em: Remove --no-relax option.
        (before_allocation): Test RELAXATION_ENABLED macro.
        Use ENABLE_RELAXATION macro.
@
text
@d559 3
@


1.16
log
@update copyright dates
@
text
@d62 1
a62 1
      if (command_line.relax)
d85 1
a85 1
	  command_line.relax = FALSE;
d94 1
a94 1
  if (command_line.relax)
d101 1
d111 1
a111 1
		      command_line.relax = FALSE;
@


1.15
log
@	PR 10474
	* ldemul.c (after_allocation_default): Run lang_relax_sections.
	* ldlang.h (lang_relax_sections): Declare.
	* ldlang.c (relax_sections): Delete.
	(lang_relax_sections): New function.
	(lang_process): Don't relax directly from here.
	* emultempl/alphaelf.em (alpha_finish): Call finish_default.
	* emultempl/armelf.em (arm_elf_after_allocation): Delete.  Move body..
	(gld${EMULATION_NAME}_finish): ..to here.  Move existing code..
	(gld${EMULATION_NAME}_after_allocation): ..to here.  New function.
	(LDEMUL_AFTER_ALLOCATION): Update.
	* emultempl/avrelf.em (avr_elf_finish, LDEMUL_FINISH): Delete.
	(avr_elf_after_allocation): New function.
	(LDEMUL_AFTER_ALLOCATION): Define.
	* emultempl/elf-generic.em (gld${EMULATION_NAME}_map_segments): Call
	lang_relax_sections.
	* emultempl/elf32.em (gld${EMULATION_NAME}_finish): Delete.  Move..
	(gld${EMULATION_NAME}_after_allocation): ..code to here.  New function.
	(LDEMUL_AFTER_ALLOCATION, LDEMUL_FINISH): Update.
	* emultempl/genelf.em (gld${EMULATION_NAME}_finish): Delete.  Move..
	(gld${EMULATION_NAME}_after_allocation): ..code to here.  New function.
	(LDEMUL_FINISH): Delete.
	(LDEMUL_AFTER_ALLOCATION): Define.
	* emultempl/hppaelf.em (gld${EMULATION_NAME}_finish): Delete.  Move..
	(gld${EMULATION_NAME}_after_allocation): ..to here.  New function.
	(LDEMUL_FINISH): Delete.
	(LDEMUL_AFTER_ALLOCATION): Define.
	* emultempl/m68hc1xelf.em (m68hc11elf_finish): Delete.  Move..
	(m68hc11elf_after_allocation): ..to here.  New function.
	(LDEMUL_FINISH): Delete.
	(LDEMUL_AFTER_ALLOCATION): Define.
	* emultempl/m68kelf.em (m68k_elf_after_allocation): Call
	gld${EMULATION_NAME}_after_allocation.
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): Call
	gld${EMULATION_NAME}_after_allocation.
	* emultempl/mmo.em (mmo_finish): Delete.  Move body..
	(gld${EMULATION_NAME}_after_allocation): ..to here.  New function.
	(LDEMUL_FINISH): Define.
	* emultempl/ppc64elf.em (ppc_layout_sections_again): Set elf_gp.
	(gld${EMULATION_NAME}_finish): Move code sizing sections..
	(gld${EMULATION_NAME}_after_allocation): ..to here.
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_after_allocation):
	Call gld${EMULATION_NAME}_after_allocation.
	* emultempl/spuelf.em (gld${EMULATION_NAME}_finish): Delete
	bfd_elf_discard_info and map_segments call.
@
text
@d2 1
a2 1
#   Copyright 2000, 2001, 2002, 2003, 2004, 2007, 2008
@


1.14
log
@	* emultempl/armelf.em (elf32_arm_add_stub_section): Use
	bfd_make_section_with_flags.
	* emultempl/avrelf.em (avr_elf_create_output_section_statements):
	Likewise.
	* emultempl/hppaelf.em (hppaelf_add_stub_section): Likewise.
	* emultempl/m68hc1xelf.em (m68hc11elf_add_stub_section): Likewise.
	* emultempl/m68kcoff.em (gld${EMULATION_NAME}_after_open): Likewise.
	* emultempl/m68kelf.em (m68k_elf_after_open): Likewise.
	* emultempl/ppc64elf.em (ppc_add_stub_section): Likewise.
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation):
	Likewise.
@
text
@d247 1
d249 1
a249 2
  asection *cranges = bfd_get_section_by_name (link_info.output_bfd,
					       SH64_CRANGES_SECTION_NAME);
d251 2
a252 2
  /* If this ever starts doing something, we will pick it up.  */
  after_allocation_default ();
a378 5
  /* ldemul_after_allocation may be called twice.  First directly from
     lang_process, and the second time when lang_process calls ldemul_finish,
     which calls gld${EMULATION_NAME}_finish, e.g. gldshelf32_finish, which
     is defined in emultempl/elf32.em and calls ldemul_after_allocation,
     if bfd_elf_discard_info returned true.  */
@


1.13
log
@include/
	* bfdlink.h (struct bfd_link_hash_table): Delete creator field.
	(struct bfd_link_info): Add output_bfd.
bfd/
	* elflink.c: Replace all accesses to hash->creator field with
	output_bfd->xvec.
	* cofflink.c: Likewise.
	* coff-h8300.c: Likewise.
	* ecoff.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfxx-mips.c: Likewise.
	* i386linux.c: Likewise.
	* m68klinux.c: Likewise.
	* sparclinux.c: Likewise.
	* sunos.c: Likewise.
	* xcofflink.c: Likewise.
	* linker.c: Likewise.
	(_bfd_link_hash_table_init): Don't store creator.
ld/
	* ldmain.h (output_bfd): Delete.
	* ldmain.c (output_bfd): Delete.
	Replace all occurrences of output_bfd with link_info.output_bfd.
	* ldcref.c: Likewise.
	* ldctor.c: Likewise.
	* ldemul.c: Likewise.
	* ldexp.c: Likewise.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldmisc.c: Likewise.
	* ldwrite.c: Likewise.
	* pe-dll.c: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/alphaelf.em: Likewise.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/elf-generic.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/irix.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/mmix-elfnmmo.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/sh64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
	* emultempl/z80.em: Likewise.
	* ldlang.c (open_output): Don't return output, instead write
	link_info_output_bfd directly.
	* emultempl/alphaelf.em: Replace occurrences of link_info.hash->creator
	with link_info.output_bfd->xvec.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
@
text
@d206 7
a212 9
			      = bfd_make_section (link_info.output_bfd,
						  SH64_CRANGES_SECTION_NAME);
			    if (cranges == NULL
				|| !bfd_set_section_flags (link_info.output_bfd,
							   cranges,
							   SEC_LINKER_CREATED
							   | SEC_KEEP
							   | SEC_HAS_CONTENTS
							   | SEC_DEBUGGING))
@


1.12
log
@2007-07-19  Roland McGrath  <roland@@redhat.com>

	* genscripts.sh (source_em, fragment): New sh functions.
	Truncate e${EMULATION_NAME}.c file before .em script fills it.
	Use source_em in place of . for the .em script.
	* emultempl/generic.em: Use fragment and source_em functions.
	* emultempl/aix.em: Likewise.
	* emultempl/alphaelf.em: Likewise.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/cr16elf.em: Likewise.
	* emultempl/crxelf.em: Likewise.
	* emultempl/elf-generic.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/genelf.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/gld960c.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ia64elf.em: Likewise.
	* emultempl/irix.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/m68kcoff.em: Likewise.
	* emultempl/m68kelf.em: Likewise.
	* emultempl/mipsecoff.em: Likewise.
	* emultempl/mipself.em: Likewise.
	* emultempl/mmix-elfnmmo.em: Likewise.
	* emultempl/mmixelf.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/needrelax.em: Likewise.
	* emultempl/netbsd.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/sh64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/ticoff.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
	* emultempl/z80.em: Likewise.
@
text
@d2 2
a3 1
#   Copyright 2000, 2001, 2002, 2003, 2004, 2007 Free Software Foundation, Inc.
d57 2
a58 1
  cranges = bfd_get_section_by_name (output_bfd, SH64_CRANGES_SECTION_NAME);
d122 1
a122 1
  for (osec = output_bfd->sections;
d130 1
a130 1
      if (bfd_get_flavour (output_bfd) != bfd_target_elf_flavour)
d136 1
a136 1
      if (bfd_get_section_flags (output_bfd, osec) & SEC_EXCLUDE)
d206 1
a206 1
			      = bfd_make_section (output_bfd,
d209 1
a209 1
				|| !bfd_set_section_flags (output_bfd,
d250 2
a251 2
  asection *cranges
    = bfd_get_section_by_name (output_bfd, SH64_CRANGES_SECTION_NAME);
d266 1
a266 1
  for (osec = output_bfd->sections;
d274 1
a274 1
      if (bfd_get_section_flags (output_bfd, osec) & SEC_EXCLUDE)
d413 1
a413 1
  for (osec = output_bfd->sections;
d424 1
a424 1
      if ((bfd_get_section_flags (output_bfd, osec) & SEC_EXCLUDE) != 0
d482 1
a482 1
			bfd_put_32 (output_bfd, last_cr_size,
d499 1
a499 1
			  = bfd_new_link_order (output_bfd, cranges);
d523 1
a523 1
			bfd_put_32 (output_bfd, isec->output_offset,
d528 1
a528 1
		      bfd_put_32 (output_bfd,
d536 1
a536 1
		    bfd_put_32 (output_bfd, cr_size,
d539 1
a539 1
		    bfd_put_16 (output_bfd, cr_type,
@


1.11
log
@Update sources to GPLv3
@
text
@d29 1
a29 1
cat >>e${EMULATION_NAME}.c <<EOF
@


1.10
log
@	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_after_allocation):
	Don't increment rel_count of .cranges here.  Set rawsize of .cranges.
@
text
@d2 1
a2 1
#   Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d4 1
a4 1
# This file is part of GLD, the Gnu Linker.
d8 1
a8 1
# the Free Software Foundation; either version 2 of the License, or
d18 2
a19 1
# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
@


1.9
log
@Update FSF addresses
@
text
@a522 7

			/* We must update the number of relocations here,
			   since the elf linker does not take link orders
			   into account when setting header sizes.  The
			   actual relocation orders are however executed
			   correctly.  */
			elf_section_data(cranges)->rel_count++;
d560 1
@


1.8
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d18 1
a18 1
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
@


1.7
log
@	* emultempl/elf32.em: Update new bfd_elf_discard_info name.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/sh64elf.em: Likewise.
@
text
@d2 1
a2 1
#   Copyright 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d155 1
a155 1
		    && isec->_raw_size != 0
d182 1
a182 1
		    && isec->_raw_size != 0
d286 1
a286 1
		    && isec->_raw_size != 0
d313 1
a313 1
		    && isec->_raw_size != 0
d366 1
a366 1
		    && isec->_raw_size != 0
d391 1
a391 1
  cranges->contents = xcalloc (cranges->_raw_size + cranges_growth, 1);
d406 1
a406 1
  crangesp = cranges->contents + cranges->_raw_size;
d440 1
a440 1
		    && isec->_raw_size != 0
d461 1
a461 3
		    cr_size
		      = (isec->_cooked_size
			 ? isec->_cooked_size : isec->_raw_size);
a563 1
  cranges->_cooked_size = crangesp - cranges->contents;
d565 2
a566 2
    = cranges->_cooked_size - cranges->_raw_size;
  cranges->_raw_size = cranges->_cooked_size;
@


1.6
log
@	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_after_allocation):
	Allow second call from ldemul_finish.
@
text
@d382 1
a382 1
     if bfd_elf${ELFSIZE}_discard_info returned true.  */
@


1.6.6.1
log
@Merge from mainline
@
text
@d382 1
a382 1
     if bfd_elf_discard_info returned true.  */
@


1.5
log
@	* emultempl/aix.em: Convert to C90, remove unnecessary prototypes
	and casts.  Replace PTR with void *.  Formatting.
	* emultempl/alphaelf.em: Likewise
	* emultempl/armcoff.em: Likewise
	* emultempl/armelf.em: Likewise
	* emultempl/armelf_oabi.em: Likewise
	* emultempl/beos.em: Likewise
	* emultempl/elf32.em: Likewise
	* emultempl/generic.em: Likewise
	* emultempl/gld960.em: Likewise
	* emultempl/gld960c.em: Likewise
	* emultempl/hppaelf.em: Likewise
	* emultempl/linux.em: Likewise
	* emultempl/lnk960.em: Likewise
	* emultempl/m68hc1xelf.em: Likewise
	* emultempl/m68kcoff.em: Likewise
	* emultempl/m68kelf.em: Likewise
	* emultempl/mipsecoff.em: Likewise
	* emultempl/mipself.em: Likewise
	* emultempl/mmix-elfnmmo.em: Likewise
	* emultempl/mmixelf.em: Likewise
	* emultempl/mmo.em: Likewise
	* emultempl/needrelax.em: Likewise
	* emultempl/netbsd.em: Likewise
	* emultempl/pe.em: Likewise
	* emultempl/sh64elf.em: Likewise
	* emultempl/sunos.em: Likewise
	* emultempl/ticoff.em: Likewise
	* emultempl/vanilla.em: Likewise
	* emultempl/xtensaelf.em: Likewise
	* Makefile.am: Correct dependencies.
	* Makefile.in: Regenerate.
@
text
@d378 8
a385 1
  BFD_ASSERT (cranges->contents == NULL);
@


1.4
log
@Correct spelling of "relocatable".
@
text
@a35 3
static void sh64_elf_${EMULATION_NAME}_before_allocation PARAMS ((void));
static void sh64_elf_${EMULATION_NAME}_after_allocation PARAMS ((void));

d47 1
a47 1
sh64_elf_${EMULATION_NAME}_before_allocation ()
d240 1
a240 1
sh64_elf_${EMULATION_NAME}_after_allocation ()
d384 1
a384 2
  cranges->contents
    = (bfd_byte *) xcalloc (cranges->_raw_size + cranges_growth, 1);
d506 1
a506 2
			  = ((struct bfd_link_order_reloc *)
			     xmalloc (sizeof (struct bfd_link_order_reloc)));
d538 1
a538 1
		    bfd_put_16 (output_bfd, (bfd_vma) cr_type,
@


1.3
log
@include/elf/ChangeLog
	* sh.h: Split out various bits to bfd/elf32-sh64.h.

include/opcode/ChangeLog
	* m68hc11.h (cpu6812s): Define.

bfd/ChangeLog
	* elf-bfd.h (struct bfd_elf_section_data): Remove tdata.  Change
	dynindx to an int.  Rearrange for better packing.
	* elf.c (_bfd_elf_new_section_hook): Don't alloc if already done.
	* elf32-mips.c (bfd_elf32_new_section_hook): Define.
	* elf32-sh64.h: New.  Split out from include/elf/sh.h.
	(struct _sh64_elf_section_data): New struct.
	(sh64_elf_section_data): Don't dereference sh64_info (was tdata).
	* elf32-sh64-com.c: Include elf32-sh64.h.
	* elf32-sh64.c: Likewise.
	(sh64_elf_new_section_hook): New function.
	(bfd_elf32_new_section_hook): Define.
	(sh64_elf_fake_sections): Adjust for sh64_elf_section_data change.
	(sh64_bfd_elf_copy_private_section_data): Likewise.
	(sh64_elf_final_write_processing): Likewise.
	* elf32-sparc.c (struct elf32_sparc_section_data): New.
	(elf32_sparc_new_section_hook): New function.
	(SET_SEC_DO_RELAX, SEC_DO_RELAX): Delete.
	(sec_do_relax): Define.
	(elf32_sparc_relax_section): Adjust to use sec_do_relax.
	(elf32_sparc_relocate_section): Likewise.
	* elf64-mips.c (bfd_elf64_new_section_hook): Define.
	* elf64-mmix.c (struct _mmix_elf_section_data): New.
	(mmix_elf_section_data): Define.  Use throughout file.
	(mmix_elf_new_section_hook): New function.
	(bfd_elf64_new_section_hook): Define.
	* elf64-ppc.c (struct _ppc64_elf_section_data): New.
	(ppc64_elf_section_data): Define.  Use throughout.
	(ppc64_elf_new_section_hook): New function.
	(bfd_elf64_new_section_hook): Define.
	* elf64-sparc.c (struct sparc64_elf_section_data): New.
	(sparc64_elf_new_section_hook): New function.
	(SET_SEC_DO_RELAX, SEC_DO_RELAX): Delete.
	(sec_do_relax): Define.
	(sparc64_elf_relax_section): Adjust to use sec_do_relax.
	(sparc64_elf_relocate_section): Likewise.
	(bfd_elf64_new_section_hook): Define.
	* elfn32-mips.c (bfd_elf32_new_section_hook): Define.
	* elfxx-mips.c (struct _mips_elf_section_data): New.
	(mips_elf_section_data): Define.  Use throughout.
	(_bfd_mips_elf_new_section_hook): New function.
	(mips_elf_create_got_section): Don't alloc used_by_bfd.
	* elfxx-mips.h (_bfd_mips_elf_new_section_hook): Declare.
	* elfxx-target.h (bfd_elfNN_new_section_hook): Add #ifndef.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

opcodes/ChangeLog
	* sh64-dis.c: Include elf32-sh64.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

gas/ChangeLog
	* config/tc-sh64.c (shmedia_frob_section_type): Adjust for changed
	sh64_elf_section_data.
	* config/tc-sh64.h: Include elf32-sh64.h.
	* config/tc-m68hc11.c: Don't include stdio.h.
	(md_show_usage): Fix missing continuation.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

ld/ChangeLog
	* emultempl/sh64elf.em: Include elf32-sh64.h.
	(sh64_elf_${EMULATION_NAME}_before_allocation): Adjust for changed
	sh64_elf_section_data.
	(sh64_elf_${EMULATION_NAME}_after_allocation): Likewise.
@
text
@d486 1
a486 1
		    /* If we emit relocateable contents, we need a
d488 1
a488 1
		    if (link_info.relocateable || link_info.emitrelocations)
d558 1
a558 1
     Since relocs (if relocateable linking) will be emitted into the
@


1.2
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2 1
a2 1
#   Copyright 2000, 2001, 2002 Free Software Foundation, Inc.
d34 1
d133 1
a133 1
      sh64_sec_data = sh64_elf_section_data (osec);
d143 1
a143 1
	  sh64_elf_section_data (osec) = sh64_sec_data;
d334 1
a334 1
			BFD_ASSERT (sh64_elf_section_data (osec) != NULL);
d336 1
a336 1
			sh64_elf_section_data (osec)->contents_flags
d382 1
a382 1
  BFD_ASSERT (sh64_elf_section_data (cranges) != NULL);
d399 1
a399 1
      sh64_elf_section_data (cranges)->cranges_growth = 0;
d419 1
a419 1
	  || (sh64_elf_section_data (osec)->contents_flags
d565 1
a565 1
  sh64_elf_section_data (cranges)->cranges_growth
@


1.1
log
@Contribute sh64-elf.
2002-01-24  Alexandre Oliva  <aoliva@@redhat.com>
* emulparams/shelf32.sh (STACK_ADDR): Define as formerly defined
in OTHER_RELOCATABLE_SECTIONS.
2002-01-18  Alexandre Oliva  <aoliva@@redhat.com>
* emulparams/shelf32.sh (STACK_ADDR): Define.
(OTHER_RELOCATABLE_SECTIONS): Renamed to...
(OTHER_SECTIONS): this.	 Removed stack settings.
* emulparams/shelf64.sh (OTHER_RELOCATABLE_SECTIONS): Do not set.
(OTHER_SECTIONS): Reset after sourcing shelf32.sh.
2001-03-12  DJ Delorie	<dj@@redhat.com>
* emultempl/sh64elf.em (sh64_elf_$_before_allocation): Disable
relaxing if any shmedia or mixed sections are found.
2001-03-07  DJ Delorie	<dj@@redhat.com>
* emultempl/sh64elf.em (sh64_elf_before_allocation): Pass f to
einfo.	Gracefully decline to output to non-elf formats.
2001-03-06  Hans-Peter Nilsson	<hpn@@redhat.com>
* emulparams/shelf64.sh (OTHER_RELOCATING_SECTIONS) <.stack>:
Default to _end aligned to next multiple of 0x40000, plus 0x40000.
* emulparams/shelf32.sh: Ditto.
2001-01-14  Hans-Peter Nilsson	<hpn@@cygnus.com>
* emulparams/shelf32.sh (OTHER_RELOCATING_SECTIONS): Tweak
comment.
2001-01-10  Ben Elliston  <bje@@redhat.com>
* emulparams/shelf32.sh (OTHER_RELOCATING_SECTIONS): Avoid
non-portable shell constructs. From Hans-Peter Nilsson.
2001-01-09  Hans-Peter Nilsson	<hpn@@cygnus.com>
* emulparams/shelf64.sh (EXTRA_EM_FILE): Define empty.
* Makefile.am (eshelf64.c, eshlelf64.c, eshlelf32.c): Adjust
dependencies to the shell script include chain.
* Makefile.in: Regenerate.
2001-01-06  Hans-Peter Nilsson	<hpn@@cygnus.com>
* emultempl/sh64elf.em: Update and tweak comments.
(sh64_elf_${EMULATION_NAME}_after_allocation): Always allocate and
make a .cranges section SEC_IN_MEMORY.
2000-12-30  Hans-Peter Nilsson	<hpn@@cygnus.com>
* emultempl/sh64elf.em
(sh64_elf_${EMULATION_NAME}_before_allocation): Don't stop when
.cranges section found to be necessary; continue and set stored
section contents flags for sections with non-mixed contents.
Use a struct sh64_section_data container and sh64_elf_section_data
to store contents-type flags.
Remove unused update of "isec".
(sh64_elf_${EMULATION_NAME}_after_allocation): Only process
sections marked SHF_SH5_ISA32_MIXED.  Use sh64_elf_section_data to
access contents-type flags.  Assert that the associated container
is initialized.	 Use that container, not elf_gp_size, to hold size
of linker-generated cranges contents.
2000-12-18  Hans-Peter Nilsson	<hpn@@cygnus.com>
* emultempl/sh64elf.em
(sh64_elf_${EMULATION_NAME}_before_allocation): Exit early if
there's already a .cranges section.  When section flag difference
is found, don't NULL-check cranges a second time.  Tweak comments.
(sh64_elf_${EMULATION_NAME}_after_allocation): Use size after
merging, not max size, as size of ld-generated .cranges contents.
Don't set ELF section flags in output section.	When checking for
needed .cranges descriptors, don't use a variable; compare
incoming ELF section flags directly to SHF_SH5_ISA32_MIXED.  Tweak
comments.
2000-12-18  Hans-Peter Nilsson	<hpn@@cygnus.com>
* emultempl/sh64elf.em: New file.
* Makefile.am (eshelf32.c, eshlelf32.c): Adjust dependencies.
* Makefile.in: Regenerate.
* emulparams/shelf32.sh (OUTPUT_FORMAT): Only set if not set.
(OTHER_RELOCATING_SECTIONS): Ditto.
(EXTRA_EM_FILE): New, set to sh64elf if not set.
* emulparams/shlelf32.sh: Stub out all settings except
OUTPUT_FORMAT.	Source shelf32.sh.
* emulparams/shelf64.sh: Similar, but also keep ELF_SIZE and
OTHER_RELOCATING_SECTIONS.
(OTHER_RELOCATING_SECTIONS): Remove .cranges.
* emulparams/shlelf64.sh: Stub out all settings except
OUTPUT_FORMAT.	Source shelf64.sh.
2000-12-15  Hans-Peter Nilsson	<hpn@@cygnus.com>
* emulparams/shelf64.sh (OTHER_RELOCATING_SECTIONS): Include
.cranges section.
(DATA_START_SYMBOLS): Define, provide ___data.
(OTHER_READONLY_SYMBOLS): Define, provide ___rodata and align to 8
for consecutive .data section.
(OTHER_GOT_SECTIONS): Define, align to 8 for consecutive .bss
section after .data section.
* emulparams/shlelf64.sh: Ditto.
* emulparams/shelf32.sh: Ditto.
(ALIGNMENT): Define to 8.
* emulparams/shelf32.sh: Ditto.
2000-12-12  Hans-Peter Nilsson	<hpn@@cygnus.com>
* configure.tgt (sh64-*-elf*): Assign targ_extra_libpath to get
built-in linker scripts.
2000-11-30  Hans-Peter Nilsson	<hpn@@cygnus.com>
* emulparams/shlelf64.sh: New.
* emulparams/shelf64.sh: New.
* configure.tgt (sh64-*-elf*): Add shelf64 and shlelf64 to
targ_extra_emuls.
* Makefile.am: Add support for shlelf64 and shelf64.
* Makefile.in: Regenerate.
2000-11-29  Hans-Peter Nilsson	<hpn@@cygnus.com>
* configure.tgt (sh64-*-elf*): Add shelf as default.
Add shlelf to targ_extra_emuls.
2000-11-24  Hans-Peter Nilsson	<hpn@@cygnus.com>
* emulparams/shelf32.sh: New file.
* emulparams/shlelf32.sh: New file.
* Makefile.am: Add support for shlelf32 and shelf32.
* configure.tgt: Map sh64-*-elf* to shlelf32 and shelf32.
* Makefile.in: Regenerate.
@
text
@d2 1
a2 1
#   Copyright (C) 2000, 2001 Free Software Foundation, Inc.
d84 1
a84 1
	  command_line.relax = false;
d109 1
a109 1
		      command_line.relax = false;
d208 1
a208 1
				|| (bfd_set_section_flags (output_bfd,
d213 1
a213 2
							   | SEC_DEBUGGING)
				    == false))
d270 1
a270 1
      boolean need_check_cranges = false;
d337 1
a337 1
			need_check_cranges = true;
@

