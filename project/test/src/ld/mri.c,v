head	1.27;
access;
symbols
	binutils-2_24-branch:1.27.0.2
	binutils-2_24-branchpoint:1.27
	binutils-2_21_1:1.23.2.1
	binutils-2_23_2:1.25.6.1
	binutils-2_23_1:1.25.6.1
	binutils-2_23:1.25.6.1
	binutils-2_23-branch:1.25.0.6
	binutils-2_23-branchpoint:1.25
	binutils-2_22_branch:1.25.0.4
	binutils-2_22:1.25
	binutils-2_22-branch:1.25.0.2
	binutils-2_22-branchpoint:1.25
	binutils-2_21:1.23
	binutils-2_21-branch:1.23.0.2
	binutils-2_21-branchpoint:1.23
	binutils-2_20_1:1.22.10.1
	binutils-2_20:1.22.10.1
	binutils-arc-20081103-branch:1.22.0.12
	binutils-arc-20081103-branchpoint:1.22
	binutils-2_20-branch:1.22.0.10
	binutils-2_20-branchpoint:1.22
	dje-cgen-play1-branch:1.22.0.8
	dje-cgen-play1-branchpoint:1.22
	arc-20081103-branch:1.22.0.6
	arc-20081103-branchpoint:1.22
	binutils-2_19_1:1.22
	binutils-2_19:1.22
	binutils-2_19-branch:1.22.0.4
	binutils-2_19-branchpoint:1.22
	binutils-2_18:1.22
	binutils-2_18-branch:1.22.0.2
	binutils-2_18-branchpoint:1.22
	binutils-csl-coldfire-4_1-32:1.20
	binutils-csl-sourcerygxx-4_1-32:1.20
	binutils-csl-innovasic-fido-3_4_4-33:1.20
	binutils-csl-sourcerygxx-3_4_4-32:1.18
	binutils-csl-coldfire-4_1-30:1.20
	binutils-csl-sourcerygxx-4_1-30:1.20
	binutils-csl-coldfire-4_1-28:1.20
	binutils-csl-sourcerygxx-4_1-29:1.20
	binutils-csl-sourcerygxx-4_1-28:1.20
	binutils-csl-arm-2006q3-27:1.20
	binutils-csl-sourcerygxx-4_1-27:1.20
	binutils-csl-arm-2006q3-26:1.20
	binutils-csl-sourcerygxx-4_1-26:1.20
	binutils-csl-sourcerygxx-4_1-25:1.20
	binutils-csl-sourcerygxx-4_1-24:1.20
	binutils-csl-sourcerygxx-4_1-23:1.20
	binutils-csl-sourcerygxx-4_1-21:1.20
	binutils-csl-arm-2006q3-21:1.20
	binutils-csl-sourcerygxx-4_1-22:1.20
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.20
	binutils-csl-sourcerygxx-4_1-20:1.20
	binutils-csl-arm-2006q3-19:1.20
	binutils-csl-sourcerygxx-4_1-19:1.20
	binutils-csl-sourcerygxx-4_1-18:1.20
	binutils-csl-renesas-4_1-9:1.20
	binutils-csl-sourcerygxx-3_4_4-25:1.18
	binutils-csl-renesas-4_1-8:1.20
	binutils-csl-renesas-4_1-7:1.20
	binutils-csl-renesas-4_1-6:1.20
	binutils-csl-sourcerygxx-4_1-17:1.20
	binutils-csl-sourcerygxx-4_1-14:1.20
	binutils-csl-sourcerygxx-4_1-15:1.20
	binutils-csl-sourcerygxx-4_1-13:1.20
	binutils-2_17:1.20
	binutils-csl-sourcerygxx-4_1-12:1.20
	binutils-csl-sourcerygxx-3_4_4-21:1.20
	binutils-csl-wrs-linux-3_4_4-24:1.18
	binutils-csl-wrs-linux-3_4_4-23:1.18
	binutils-csl-sourcerygxx-4_1-9:1.20
	binutils-csl-sourcerygxx-4_1-8:1.20
	binutils-csl-sourcerygxx-4_1-7:1.20
	binutils-csl-arm-2006q1-6:1.20
	binutils-csl-sourcerygxx-4_1-6:1.20
	binutils-csl-wrs-linux-3_4_4-22:1.18
	binutils-csl-coldfire-4_1-11:1.20
	binutils-csl-sourcerygxx-3_4_4-19:1.20
	binutils-csl-coldfire-4_1-10:1.20
	binutils-csl-sourcerygxx-4_1-5:1.20
	binutils-csl-sourcerygxx-4_1-4:1.20
	binutils-csl-wrs-linux-3_4_4-21:1.18
	binutils-csl-morpho-4_1-4:1.20
	binutils-csl-sourcerygxx-3_4_4-17:1.20
	binutils-csl-wrs-linux-3_4_4-20:1.18
	binutils-2_17-branch:1.20.0.4
	binutils-2_17-branchpoint:1.20
	binutils-csl-2_17-branch:1.20.0.2
	binutils-csl-2_17-branchpoint:1.20
	binutils-csl-gxxpro-3_4-branch:1.18.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.18
	binutils-2_16_1:1.18
	binutils-csl-arm-2005q1b:1.18
	binutils-2_16:1.18
	binutils-csl-arm-2005q1a:1.18
	binutils-csl-arm-2005q1-branch:1.18.0.4
	binutils-csl-arm-2005q1-branchpoint:1.18
	binutils-2_16-branch:1.18.0.2
	binutils-2_16-branchpoint:1.18
	csl-arm-2004-q3d:1.16
	csl-arm-2004-q3:1.15
	binutils-2_15:1.14
	binutils-2_15-branchpoint:1.14
	csl-arm-2004-q1a:1.14
	csl-arm-2004-q1:1.14
	binutils-2_15-branch:1.14.0.6
	cagney_bfdfile-20040213-branch:1.14.0.4
	cagney_bfdfile-20040213-branchpoint:1.14
	cagney_bigcore-20040122-branch:1.14.0.2
	cagney_bigcore-20040122-branchpoint:1.14
	csl-arm-2003-q4:1.13
	binutils-2_14:1.12
	binutils-2_14-branch:1.12.0.2
	binutils-2_14-branchpoint:1.12
	binutils-2_13_2_1:1.9.2.1
	binutils-2_13_2:1.9.2.1
	binutils-2_13_1:1.9.2.1
	binutils-2_13:1.9
	binutils-2_13-branchpoint:1.9
	binutils-2_13-branch:1.9.0.2
	binutils-2_12_1:1.7
	binutils-2_12:1.7
	binutils-2_12-branch:1.7.0.2
	binutils-2_12-branchpoint:1.7
	cygnus_cvs_20020108_pre:1.7
	binutils-2_11_2:1.5.2.1
	binutils-2_11_1:1.5.2.1
	binutils-2_11:1.5
	x86_64versiong3:1.5
	binutils-2_11-branch:1.5.0.2
	binutils-2_10_1:1.2
	binutils-2_10:1.2
	binutils-2_10-branch:1.2.0.2
	binutils-2_10-branchpoint:1.2
	binutils_latest_snapshot:1.27
	repo-unification-2000-02-06:1.1.1.1
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2013.07.19.10.39.51;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	2012.08.06.22.27.52;	author macro;	state Exp;
branches;
next	1.25;

1.25
date	2011.07.11.15.03.09;	author clm;	state Exp;
branches
	1.25.6.1;
next	1.24;

1.24
date	2011.01.13.13.06.22;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2009.09.11.15.27.35;	author nickc;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2007.07.06.14.09.41;	author nickc;	state Exp;
branches
	1.22.10.1;
next	1.21;

1.21
date	2007.04.26.14.46.59;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2005.05.12.07.32.03;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2005.04.28.23.54.33;	author bje;	state Exp;
branches;
next	1.18;

1.18
date	2005.03.03.11.52.01;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2005.01.21.04.15.59;	author bje;	state Exp;
branches;
next	1.16;

1.16
date	2004.10.04.16.45.51;	author hjl;	state Exp;
branches;
next	1.15;

1.15
date	2004.05.19.14.01.14;	author jakub;	state Exp;
branches;
next	1.14;

1.14
date	2004.01.03.12.39.07;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.28.05.28.54;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2003.01.02.03.53.53;	author kazu;	state Exp;
branches;
next	1.11;

1.11
date	2002.11.30.08.39.45;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2002.10.30.03.57.38;	author drow;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.08.07.39.45;	author amodra;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2002.05.27.08.22.07;	author rsandifo;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.03.01.11.21;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.13.06.14.27;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2000.10.11.00.16.07;	author kazu;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2000.09.29.13.21.41;	author kazu;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.10.19.53.58;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.16.18.53.32;	author twall;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.29.07;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.25.6.1
date	2012.09.04.14.38.00;	author gingold;	state Exp;
branches;
next	;

1.23.2.1
date	2011.02.01.12.25.46;	author amodra;	state Exp;
branches;
next	;

1.22.10.1
date	2009.09.11.15.28.44;	author nickc;	state Exp;
branches;
next	;

1.9.2.1
date	2002.10.30.03.54.52;	author drow;	state Exp;
branches;
next	;

1.5.2.1
date	2001.06.07.03.17.14;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.07;	author rth;	state Exp;
branches;
next	;


desc
@@


1.27
log
@	* ldgram.y: Add ALIGN_WITH_INPUT output section attribute.
	* ldlang.c: Likewise.
	* ldlang.h: Likewise.
	* ldlex.l: Likewise.
	* mri.c: Likewise.
	* ld.texinfo: Document new feature.
	* NEWS: Mention new feature.

	* ld-scripts/script.exp: Run align with input test.
	* ld-scripts/align-with-input.t: New file.
	* ld-scripts/rgn-at8.d: Likewise.
	* ld-scripts/rgn-at8.t: Likewise.
@
text
@/* mri.c -- handle MRI style linker scripts
   Copyright 1991, 1992, 1993, 1994, 1996, 1997, 1998, 1999, 2000, 2001,
   2002, 2003, 2004, 2005, 2007, 2011 Free Software Foundation, Inc.
   Contributed by Steve Chamberlain <sac@@cygnus.com>.

   This file is part of the GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */


/* This bit does the tree decoration when MRI style link scripts
   are parsed.  */

#include "sysdep.h"
#include "bfd.h"
#include "ld.h"
#include "ldexp.h"
#include "ldlang.h"
#include "ldmisc.h"
#include "mri.h"
#include <ldgram.h>
#include "libiberty.h"

struct section_name_struct {
  struct section_name_struct *next;
  const char *name;
  const char *alias;
  etree_type *vma;
  etree_type *align;
  etree_type *subalign;
  int ok_to_load;
};

static unsigned int symbol_truncate = 10000;
static struct section_name_struct *order;
static struct section_name_struct *only_load;
static struct section_name_struct *address;
static struct section_name_struct *alias;

static struct section_name_struct *alignment;
static struct section_name_struct *subalignment;

static struct section_name_struct **
lookup (const char *name, struct section_name_struct **list)
{
  struct section_name_struct **ptr = list;

  while (*ptr)
    {
      if (strcmp (name, (*ptr)->name) == 0)
	/* If this is a match, delete it, we only keep the last instance
	   of any name.  */
	*ptr = (*ptr)->next;
      else
	ptr = &((*ptr)->next);
    }

  *ptr = (struct section_name_struct *)
      xmalloc (sizeof (struct section_name_struct));
  return ptr;
}

static void
mri_add_to_list (struct section_name_struct **list,
		 const char *name,
		 etree_type *vma,
		 const char *zalias,
		 etree_type *align,
		 etree_type *subalign)
{
  struct section_name_struct **ptr = lookup (name, list);

  (*ptr)->name = name;
  (*ptr)->vma = vma;
  (*ptr)->next = NULL;
  (*ptr)->ok_to_load = 0;
  (*ptr)->alias = zalias;
  (*ptr)->align = align;
  (*ptr)->subalign = subalign;
}

void
mri_output_section (const char *name, etree_type *vma)
{
  mri_add_to_list (&address, name, vma, 0, 0, 0);
}

/* If any ABSOLUTE <name> are in the script, only load those files
   marked thus.  */

void
mri_only_load (const char *name)
{
  mri_add_to_list (&only_load, name, 0, 0, 0, 0);
}

void
mri_base (etree_type *exp)
{
  base = exp;
}

static int done_tree = 0;

void
mri_draw_tree (void)
{
  if (done_tree)
    return;

  /* Now build the statements for the ldlang machine.  */

  /* Attach the addresses of any which have addresses,
     and add the ones not mentioned.  */
  if (address != NULL)
    {
      struct section_name_struct *alist;
      struct section_name_struct *olist;

      if (order == NULL)
	order = address;

      for (alist = address;
	   alist != NULL;
	   alist = alist->next)
	{
	  int done = 0;

	  for (olist = order; done == 0 && olist != NULL; olist = olist->next)
	    {
	      if (strcmp (alist->name, olist->name) == 0)
		{
		  olist->vma = alist->vma;
		  done = 1;
		}
	    }

	  if (!done)
	    {
	      /* Add this onto end of order list.  */
	      mri_add_to_list (&order, alist->name, alist->vma, 0, 0, 0);
	    }
	}
    }

  /* If we're only supposed to load a subset of them in, then prune
     the list.  */
  if (only_load != NULL)
    {
      struct section_name_struct *ptr1;
      struct section_name_struct *ptr2;

      if (order == NULL)
	order = only_load;

      /* See if this name is in the list, if it is then we can load it.  */
      for (ptr1 = only_load; ptr1; ptr1 = ptr1->next)
	for (ptr2 = order; ptr2; ptr2 = ptr2->next)
	  if (strcmp (ptr2->name, ptr1->name) == 0)
	    ptr2->ok_to_load = 1;
    }
  else
    {
      /* No only load list, so everything is ok to load.  */
      struct section_name_struct *ptr;

      for (ptr = order; ptr; ptr = ptr->next)
	ptr->ok_to_load = 1;
    }

  /* Create the order of sections to load.  */
  if (order != NULL)
    {
      /* Been told to output the sections in a certain order.  */
      struct section_name_struct *p = order;

      while (p)
	{
	  struct section_name_struct *aptr;
	  etree_type *align = 0;
	  etree_type *subalign = 0;
	  struct wildcard_list *tmp;

	  /* See if an alignment has been specified.  */
	  for (aptr = alignment; aptr; aptr = aptr->next)
	    if (strcmp (aptr->name, p->name) == 0)
	      align = aptr->align;

	  for (aptr = subalignment; aptr; aptr = aptr->next)
	    if (strcmp (aptr->name, p->name) == 0)
	      subalign = aptr->subalign;

	  if (base == 0)
	    base = p->vma ? p->vma : exp_nameop (NAME, ".");

	  lang_enter_output_section_statement (p->name, base,
					       p->ok_to_load ? normal_section : noload_section,
					       align, subalign, NULL, 0, 0);
	  base = 0;
	  tmp = (struct wildcard_list *) xmalloc (sizeof *tmp);
	  tmp->next = NULL;
	  tmp->spec.name = p->name;
	  tmp->spec.exclude_name_list = NULL;
	  tmp->spec.sorted = none;
	  tmp->spec.section_flag_list = NULL;
	  lang_add_wild (NULL, tmp, FALSE);

	  /* If there is an alias for this section, add it too.  */
	  for (aptr = alias; aptr; aptr = aptr->next)
	    if (strcmp (aptr->alias, p->name) == 0)
	      {
		tmp = (struct wildcard_list *) xmalloc (sizeof *tmp);
		tmp->next = NULL;
		tmp->spec.name = aptr->name;
		tmp->spec.exclude_name_list = NULL;
		tmp->spec.sorted = none;
		tmp->spec.section_flag_list = NULL;
		lang_add_wild (NULL, tmp, FALSE);
	      }

	  lang_leave_output_section_statement (0, "*default*", NULL, NULL);

	  p = p->next;
	}
    }

  done_tree = 1;
}

void
mri_load (const char *name)
{
  base = 0;
  lang_add_input_file (name, lang_input_file_is_file_enum, NULL);
}

void
mri_order (const char *name)
{
  mri_add_to_list (&order, name, 0, 0, 0, 0);
}

void
mri_alias (const char *want, const char *is, int isn)
{
  if (!is)
    {
      char buf[20];

      /* Some sections are digits.  */
      sprintf (buf, "%d", isn);

      is = xstrdup (buf);

      if (is == NULL)
	abort ();
    }

  mri_add_to_list (&alias, is, 0, want, 0, 0);
}

void
mri_name (const char *name)
{
  lang_add_output (name, 1);
}

void
mri_format (const char *name)
{
  if (strcmp (name, "S") == 0)
    lang_add_output_format ("srec", NULL, NULL, 1);

  else if (strcmp (name, "IEEE") == 0)
    lang_add_output_format ("ieee", NULL, NULL, 1);

  else if (strcmp (name, "COFF") == 0)
    lang_add_output_format ("coff-m68k", NULL, NULL, 1);

  else
    einfo (_("%P%F: unknown format type %s\n"), name);
}

void
mri_public (const char *name, etree_type *exp)
{
  lang_add_assignment (exp_assign (name, exp, FALSE));
}

void
mri_align (const char *name, etree_type *exp)
{
  mri_add_to_list (&alignment, name, 0, 0, exp, 0);
}

void
mri_alignmod (const char *name, etree_type *exp)
{
  mri_add_to_list (&subalignment, name, 0, 0, 0, exp);
}

void
mri_truncate (unsigned int exp)
{
  symbol_truncate = exp;
}
@


1.26
log
@	bfd/
	* elflink.c (bfd_elf_record_link_assignment): Remove --defsym
	symbols special case.

	ld/
	* ldexp.h (etree_union): Add defsym member to the assign member
	structure.
	(exp_assign): Add hidden argument to prototype.
	* ldexp.c (exp_fold_tree_1): Use the defsym member to handle
	--defsym symbols.
	(exp_assop): Add defsym argument, initialize the defsym member
	of the assign structure.
	(exp_assign): Handle hidden symbols.
	(exp_defsym): Update to use the defsym argument to exp_assop.
	(exp_provide): Update to handle the defsym argument to exp_assop.
	* ldlex.l (HIDDEN): New token.
	* ldgram.y (HIDDEN): Likewise.
	(assignment, section): Update calls to exp_assign.
	* ldctor.c (ldctor_build_sets): Likewise.
	* mri.c (mri_format): Likewise.
	* ldlang.c (lang_insert_orphan, lang_leave_overlay): Likewise.
	(open_input_bfds): Remove --defsym symbols special case.
	* emultempl/beos.em (gld_${EMULATION_NAME}_set_symbols): Update
	call to exp_assign.
	* emultempl/pe.em (gld_${EMULATION_NAME}_set_symbols): Likewise.
	* emultempl/pep.em (gld_${EMULATION_NAME}_set_symbols): Likewise.
	* emultempl/spuelf.em (spu_place_special_section): Likewise.
	* emultempl/xtensaelf.em (ld_xtensa_insert_page_offsets):
	Likewise.
	* ld.texinfo (Assigning Values to Symbols): Add HIDDEN.
	(HIDDEN): New subsection.
@
text
@d211 1
a211 1
					       align, subalign, NULL, 0);
@


1.25
log
@include/ChangeLog
2011-07-11  Catherine Moore  <clm@@codesourcery.com>

	* bfdlink.h (flag_type): New enumeration.
	(flag_info_list): New structure.
	(flag_info): New structure.

bfd/ChangeLog
2011-07-11  Catherine Moore  <clm@@codesourcery.com>

	* aout-adobe.c (aout_32_bfd_lookup_section_flags): New definition.
	* aout-target.h (MY_bfd_lookup_section_flags): New definition.
	* aout-tic30.c (MY_bfd_lookup_section_flags): New definition.
        * bfd-in2.h: Regenerated.
	* bfd.c (bfd_lookup_section_flags): New definition.
	* binary.c (binary_bfd_lookup_section_flags): New definition.
	* bout.c (b_out_bfd_lookup_section_flags): New definition.
	* coff-alpha.c (_bfd_ecoff_bfd_lookup_section_flags): New definition.
	* coff-mips.c (_bfd_ecoff_bfd_lookup_section_flags): New definition.
	* coff-rs6000.c (rs6000coff_vec): Include
	bfd_generic_lookup_section_flags.
	(pmac_xcoff_vec): Likewise.
	* coffcode.h (coff_bfd_lookup_section_flags): New definition.
	* coff64-rs6000.c (rs6000coff64_vec): Include
	bfd_generic_lookup_section_flags.
	(aix5coff64_vec): Likewise.
	* ecoff.c (bfd_debug_section): Initialize flag_info field.
	* elf-bfd.h (elf_backend_lookup_section_flags_hook): Declare.
	(bfd_elf_lookup_section_flags): Declare.
	* elflink.c (bfd_elf_lookup_section_flags): New function.
	* elfxx-target.h (bfd_elfNN_bfd_lookup_section_flags): Define.
	(elf_backend_lookup_section_flags_hook): Define.
	(elf_backend_data): Add elf_backend_lookup_section_flags_hook.
	* i386msdos.c (msdos_bfd_lookup_section_flags): New define.
	* i386os9k.c (os9k_bfd_lookup_section_flags): New define.
	* ieee.c (ieee_bfd_lookup_section_flags): New define.
	* ihex.c (ihex_bfd_lookup_section_flags): New define.
	* libbfd-in.h (_bfd_nolink_bfd_lookup_section_flags): Declare.
	(bfd_generic_lookup_section_flags): Declare.
	* libbfd.h: Regenerated.
	* mach-o-target.c (bfd_mach_o_bfd_lookup_section_flags): New.
	* mmo.c (mmo_bfd_lookup_section_flags): New definition.
	* nlm-target.h (nlm_bfd_lookup_section_flags): New definition.
	* oasys.c (oasys_bfd_lookup_section_flags): New definition.
	* pef.c (bfd_pef_bfd_lookup_section_flags): New definition.
	* plugin.c (bfd_plugin_bfd_lookup_section_flags): New definition.
	* ppcboot.c (ppcboot_bfd_lookup_section_flags): New definition.
	* reloc.c (bfd_generic_lookup_section_flags): New function.
	* som.c (som_bfd_lookup_section_flags): New definition.
	* srec.c (srec_bfd_lookup_section_flags): New definition.
	* targets.c (flag_info): Declare.
	(NAME##_bfd_lookup_section_flags): Add to LINK jump table.
	(_bfd_lookup_section_flags): New.
	* tekhex.c (tekhex_bfd_lookup_section_flags): New definition.
	* versados.c (versados_bfd_lookup_section_flags): New definition.
	* vms-alpha.c (alpha_vms_bfd_lookup_section_flag): New definition.
	* xsym.c (bfd_sym_bfd_lookup_section_flags): New definition.

ld/ChangeLog
2011-07-11  Catherine Moore  <clm@@codesourcery.com>

	* ld.h (section_flag_list): Add field to struct wildcard_spec.
	* ld.texinfo (INPUT_SECTION_FLAGS): Document.
	* ldgram.y (flag_info_list, flag_info): Add to union.
	(INPUT_SECTION_FLAGS): New token.
	(wildcard_spec): Initialize section_flag_list to NULL for
	each alternative.
	(sect_flag_list, sect_flags): New rules.
	(input_section_spec_no_keep): Add alternatives to recognize
	sect_flags.
	* ldlang.c (walk_wild_consider_section): Initialize
	section_flag_info field of the section struct.
	(lang_add_section): Check input section flags.
	(lang_add_wild): Initialize section_flag_list field of
	the statement struct.
	* ldlang.h (lang_input_statement_struct): Add section_flag_list field.
	(lang_wild_statement_struct): Likewise.
	* ldlex.l (INPUT_SECTION_FLAGS): New token.
	* mri.c (mri_draw_tree): Initialize section_flag_list to NULL.
	* NEWS: Announce INPUT_SECTION_FLAGS enhancement.

ld/testsuite/ChangeLog
2011-07-11 Catherine Moore  <clm@@cm00re.com>

	* ld-scripts/section-flags-1.s: New.
	* ld-scripts/section-flags-1.t: New.
	* ld-scripts/section-flags-2.s: New.
	* ld-scripts/section-flags-2.t: New.
	* ld-scripts/section-flags.exp: New.
@
text
@d300 1
a300 1
  lang_add_assignment (exp_assign (name, exp));
@


1.25.6.1
log
@bfd/
2012-08-09  Maciej W. Rozycki  <macro@@codesourcery.com>

	* elfxx-mips.c (LA25_LUI_MICROMIPS_1, LA25_LUI_MICROMIPS_2):
	Remove macros, folding them into...
	(LA25_LUI_MICROMIPS): ... this new macro.
	(LA25_J_MICROMIPS_1, LA25_J_MICROMIPS_2): Likewise into...
	(LA25_J_MICROMIPS): ... this new macro.
	(LA25_ADDIU_MICROMIPS_1, LA25_ADDIU_MICROMIPS_2): Likewise
	into...
	(LA25_ADDIU_MICROMIPS): ... this new macro.
	(bfd_put_micromips_32, bfd_get_micromips_32): New functions.
	(mips_elf_create_la25_stub): Use them.
	(check_br32_dslot, check_br32, check_relocated_bzc): Likewise.
	(_bfd_mips_elf_relax_section): Likewise.

gas/
	* config/tc-mips.c (NO_ISA_COP, COP_INSN): Remove macros.
	(is_opcode_valid): Remove coprocessor instruction exclusions.
	Replace OPCODE_IS_MEMBER with opcode_is_member.
	(is_opcode_valid_16): Replace OPCODE_IS_MEMBER with
	opcode_is_member.
	(macro): Remove coprocessor instruction exclusions.

gas/
	* gas/mips/mips.exp: Set has_newabi for all Linux targets.
	* gas/mips/cfi-n64-1.d: Adjust for targets that do not infer the
	ISA from the ABI.
	* gas/mips/elf-rel-got-n32.d: Likewise.
	* gas/mips/elf-rel-got-n64.d: Likewise.
	* gas/mips/elf-rel-xgot-n32.d: Likewise.
	* gas/mips/elf-rel-xgot-n64.d: Likewise.
	* gas/mips/elf-rel18.d: Likewise.
	* gas/mips/elf-rel28-n32.d: Likewise.
	* gas/mips/elf-rel28-n64.d: Likewise.
	* gas/mips/jal-newabi.d: Likewise.
	* gas/mips/ldstla-n64-shared.d: Likewise.
	* gas/mips/ldstla-n64-sym32.d: Likewise.
	* gas/mips/ldstla-n64.d: Likewise.
	* gas/mips/macro-warn-1-n32.d: Likewise.
	* gas/mips/macro-warn-2-n32.d: Likewise.
	* gas/mips/n32-consec.d: Likewise.

include/
2012-08-13  Richard Sandiford  <rdsandiford@@googlemail.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips.h (mips_opcode): Add the exclusions field.
	(OPCODE_IS_MEMBER): Remove macro.
	(cpu_is_member): New inline function.
	(opcode_is_member): Likewise.

ld/
	* emulparams/elf32bmip.sh: Make _gp hidden.
	* emulparams/elf32bmipn32-defs.sh: Likewise.
	* emulparams/elf32mipswindiss.sh: Likewise.
	* scripttempl/mips.sc: Likewise.

ld/
2012-08-28  Maciej W. Rozycki  <macro@@codesourcery.com>

	* ld-elf/export-class.sd: New test.
	* ld-elf/export-class.vd: New test.
	* ld-elf/export-class-def.s: New test source.
	* ld-elf/export-class-dep.s: New test source.
	* ld-elf/export-class-lib.s: New test source.
	* ld-elf/export-class-ref.s: New test source.
	* ld-elf/export-class-lib.ver: New test version script.
	* ld-elf/export-class.exp: New test script.
	* ld-arm/arm-export-class.rd: New test.
	* ld-arm/arm-export-class.xd: New test.
	* ld-arm/export-class.exp: New test script.
	* ld-i386/i386-export-class.rd: New test.
	* ld-i386/i386-export-class.xd: New test.
	* ld-i386/export-class.exp: New test script.
	* ld-mips-elf/mips-32-export-class.rd: New test.
	* ld-mips-elf/mips-32-export-class.xd: New test.
	* ld-mips-elf/mips-64-export-class.rd: New test.
	* ld-mips-elf/mips-64-export-class.xd: New test.
	* ld-mips-elf/export-class.exp: New test script.
	* ld-powerpc/powerpc-32-export-class.rd: New test.
	* ld-powerpc/powerpc-32-export-class.xd: New test.
	* ld-powerpc/powerpc-64-export-class.rd: New test.
	* ld-powerpc/powerpc-64-export-class.xd: New test.
	* ld-powerpc/export-class.exp: New test script.
	* ld-x86-64/x86-64-64-export-class.rd: New test.
	* ld-x86-64/x86-64-x32-export-class.rd: New test.
	* ld-x86-64/export-class.exp: New test script.

opcodes/
2012-08-14  Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips-dis.c (print_insn_args): Add GET_OP and GET_OP_S local
	macros, use local variables for info struct member accesses,
	update the type of the variable used to hold the instruction
	word.
	(print_insn_mips, print_mips16_insn_arg): Likewise.
	(print_insn_mips16): Add GET_OP and GET_OP_S local macros, use
	local variables for info struct member accesses.
	(print_insn_micromips): Add GET_OP_S local macro.
	(_print_insn_mips): Update the type of the variable used to hold
	the instruction word.
@
text
@d300 1
a300 1
  lang_add_assignment (exp_assign (name, exp, FALSE));
@


1.24
log
@	PR ld/12356
	* ldexp.h (exp_assop): Delete.
	(exp_assign, exp_defsym): Declare.
	* ldexp.c (exp_assop): Make static, handle all assignment variations.
	(exp_assign, exp_defsym): New functions.
	(exp_provide): Use exp_assop.
	* ldgram.y (defsym_expr): Use exp_defsym.
	* ldctor.c, * ldgram.y, * ldlang.c, * mri.c, * emultempl/beos.em,
	* emultempl/pe.em, * emultempl/pep.em, * emultempl/spuelf.em,
	* emultempl/xtensaelf.em: Update exp_assop -> exp_assign.
@
text
@d218 1
d230 1
@


1.23
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        * as.c (main): Call dwarf2_init.
        * config/obj-elf.c (struct group_list): New field.
        (build_group_lists): Use hash lookup.
        (free_section_idx): New function.
        (elf_frob_file): Adjust.
        * dwarf2dbg.c (all_segs_hash, last_seg_ptr): New variables.
        (get_line_subseg): Adjust.
        (dwarf2_init): New function.
        * dwarf2dbg.h (dwarf2_init): New declaration.
@
text
@d3 1
a3 1
   2002, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.
d298 1
a298 1
  lang_add_assignment (exp_assop ('=', name, exp));
@


1.23.2.1
log
@backport from mainline
@
text
@d3 1
a3 1
   2002, 2003, 2004, 2005, 2007, 2011 Free Software Foundation, Inc.
d298 1
a298 1
  lang_add_assignment (exp_assign (name, exp));
@


1.22
log
@Update sources to GPLv3
@
text
@d71 2
a72 1
  *ptr = xmalloc (sizeof (struct section_name_struct));
d210 1
a210 1
					       p->ok_to_load ? 0 : noload_section,
d213 1
a213 1
	  tmp = xmalloc (sizeof *tmp);
d224 1
a224 1
		tmp = xmalloc (sizeof *tmp);
@


1.22.10.1
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.
@
text
@d71 1
a71 2
  *ptr = (struct section_name_struct *)
      xmalloc (sizeof (struct section_name_struct));
d209 1
a209 1
					       p->ok_to_load ? normal_section : noload_section,
d212 1
a212 1
	  tmp = (struct wildcard_list *) xmalloc (sizeof *tmp);
d223 1
a223 1
		tmp = (struct wildcard_list *) xmalloc (sizeof *tmp);
@


1.21
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d4 1
d6 1
a6 1
This file is part of GLD, the Gnu Linker.
d8 4
a11 14
GLD is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GLD is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GLD; see the file COPYING.  If not, write to the Free
Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
02110-1301, USA.
d13 4
a16 2
   This bit does the tree decoration when MRI style link scripts
   are parsed.
d18 8
a25 1
   Contributed by Steve Chamberlain <sac@@cygnus.com>.  */
@


1.20
log
@Update FSF addresses
@
text
@d3 1
a3 1
   2002, 2003, 2004, 2005 Free Software Foundation, Inc.
d27 1
a28 1
#include "sysdep.h"
@


1.19
log
@	* ldgram.y (lang_memory_region_type): Make static.
	(ldgram_want_filename): Likewise.
	* ldemul.c (ld_emulation): Make static.
	* ldfile.h (ldfile_find_command_file): Remove extern.
	* ldfile.c (ldfile_find_command_file): Make static.
	* ldlang.h (unique_section_list): Remove extern declaration.
	* ldlang.c (unique_section_list): Make static.
	* mri.h (symbol_truncate): Remove extern declaration.
	* mri.c (symbol_truncate): Make static.
	(order, only_load, address, alias): Likewise.
	(alignment, subalignment): Likewise.
@
text
@d19 2
a20 2
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.
@


1.18
log
@update copyright dates
@
text
@d47 5
a51 5
unsigned int symbol_truncate = 10000;
struct section_name_struct *order;
struct section_name_struct *only_load;
struct section_name_struct *address;
struct section_name_struct *alias;
d53 2
a54 2
struct section_name_struct *alignment;
struct section_name_struct *subalignment;
@


1.17
log
@	* ldlang.c (lang_reasonable_defaults): Remove.
	(lang_process): Don't call lang_reasonable_defaults.

	* ldexp.c (exp_assop): Remove #if 0'd code.
	(exp_print_tree): Likewise.
	* ldlang.c (lang_memory_region_lookup): Likewise.
	(open_output): Likewise.
	(lang_do_assignments_1): Likewise.
	(lang_place_orphans): Likewise.
	(lang_enter_output_section_statement): Likewise.
	(lang_reasonable_defaults): Likewise.
	* ldlang.h (struct lang_input_statement_struct): Likewise.
	* mri.c (mri_draw_tree): Likewise.
	(mri_load): Likewise.
	* pe-dll.c (generate_reloc): Likewise.
	(make_import_fixup_entry): Likewise.
	(pe_as16): Likewise.
	* emultempl/beos.em (set_pe_subsystem): Likewise.
	* emultempl/hppaelf.em (hppaelf_after_parse): Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/xtensaelf.em (xtensa_colocate_literals): Likewise.
@
text
@d2 2
a3 2
   Copyright 1991, 1992, 1993, 1994, 1996, 1997, 1998, 1999, 2000, 2002,
   2003, 2004 Free Software Foundation, Inc.
@


1.16
log
@ld/

2004-10-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* NEWS: Mention SORT_BY_NAME, SORT_BY_ALIGNMENT and
	--sort-section name|alignment.

	* ld.texinfo: Document SORT_BY_NAME, SORT_BY_ALIGNMENT and
	--sort-section name|alignment.

	* ld.h (sort_type): New enum.
	(wildcard_spec): Change the type of `sorted' to sort_type.

	* ldgram.y (SORT): Removed.
	(SORT_BY_NAME): Added.
	(SORT_BY_ALIGNMENT): Added.
	(wildcard_spec): Updated `sorted'. Handle SORT_BY_NAME and
	SORT_BY_ALIGNMENT.
	(input_section_spec_no_keep): Updated `sorted'.
	(statement): Replace SORT with SORT_BY_NAME.

	* ldlang.c (compare_section): New function to compare 2
	sections with different sorting schemes.
	(wild_sort): Updated. Use compare_section.
	(update_wild_statements): New function.
	(lang_process): Call update_wild_statements before
	map_input_to_output_sections.

	* ldlex.l (SORT_BY_NAME): New.
	(SORT_BY_ALIGNMENT): New.
	(SORT): Return SORT_BY_NAME.

	* ldmain.c (sort_section): New. Defined.
	(main): Initialize it to none.

	* lexsup.c (option_values): Add OPTION_SORT_SECTION.
	(ld_options): Add an entry for OPTION_SORT_SECTION.
	(parse_args): Handle OPTION_SORT_SECTION.

	* mri.c (mri_draw_tree): Updated `sorted'.

ld/testsuite/

2004-10-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-scripts/sort.exp: New file for section sorting tests.
	* ld-scripts/sort_b_a.d: Likewise
	* ld-scripts/sort_b_a.s: Likewise
	* ld-scripts/sort_b_a.t: Likewise
	* ld-scripts/sort_b_a_a-1.d: Likewise
	* ld-scripts/sort_b_a_a-2.d: Likewise
	* ld-scripts/sort_b_a_a-3.d: Likewise
	* ld-scripts/sort_b_a_a.t: Likewise
	* ld-scripts/sort_b_a_n-1.d: Likewise
	* ld-scripts/sort_b_a_n-2.d: Likewise
	* ld-scripts/sort_b_a_n-3.d: Likewise
	* ld-scripts/sort_b_a_n.t: Likewise
	* ld-scripts/sort_b_n.d: Likewise
	* ld-scripts/sort_b_n.s: Likewise
	* ld-scripts/sort_b_n.t: Likewise
	* ld-scripts/sort_b_n_a-1.d: Likewise
	* ld-scripts/sort_b_n_a-2.d: Likewise
	* ld-scripts/sort_b_n_a-3.d: Likewise
	* ld-scripts/sort_b_n_a.t: Likewise
	* ld-scripts/sort_b_n_n-1.d: Likewise
	* ld-scripts/sort_b_n_n-2.d: Likewise
	* ld-scripts/sort_b_n_n-3.d: Likewise
	* ld-scripts/sort_b_n_n.t: Likewise
	* ld-scripts/sort_n_a-a.s: Likewise
	* ld-scripts/sort_n_a-b.s: Likewise
	* ld-scripts/sort_no-1.d: Likewise
	* ld-scripts/sort_no-2.d: Likewise
	* ld-scripts/sort_no.t: Likewise
@
text
@a122 13
#if 0   /* We don't bother with memory regions.  */
  /* Create the regions.  */
  {
    lang_memory_region_type *r;

    r = lang_memory_region_lookup("long");
    r->current = r->origin = exp_get_vma (base, (bfd_vma)0, "origin",
					  lang_first_phase_enum);
    r->length = (bfd_size_type) exp_get_vma (0, ~(bfd_vma) 0, "length",
					     lang_first_phase_enum);
  }
#endif

a244 3
#if 0
  lang_leave_output_section_statement (0, "*default*");
#endif
@


1.15
log
@	* ldgram.y (sect_constraint): New.
	(ONLY_IF_RO, ONLY_IF_RW): New tokens.
	(section): Add sect_constraint.  Pass additional argument
	to lang_enter_output_section_statement.
	* mri.c (mri_draw_tree): Pass additional argument to
	lang_enter_output_section_statement.
	* emultempl/pe.em (place_orphan): Likewise.
	(output_prev_sec_find): Disregard output section statements with
	constraint == -1.
	* emultempl/mmo.em (output_prev_sec_find): Likewise.
	(mmo_place_orphan): Pass additional argument to
	lang_enter_output_section_statement.
	* emultempl/elf32.em (output_prev_sec_find): Disregard output section
	statements with constraint == -1.
	(place_orphan): Pass additional argument to
	lang_enter_output_section_statement.
	* ldlang.c (lang_enter_overlay_section): Likewise.
	(lang_output_section_find_1): New.
	(lang_output_section_find): Use it.
	(lang_output_section_statement_lookup_1): New.
	(lang_output_section_statement_lookup): Use it.
	(check_section_callback, check_input_sections): New.
	(map_input_to_output_sections): Check if all input sections
	are readonly if ONLY_IF_RO or ONLY_IF_RW was seen.
	(strip_excluded_output_sections): Disregard output section statements
	with constraint == -1.
	(lang_record_phdrs): Likewise.
	(lang_enter_output_section_statement): Add constraint argument.
	Use lang_output_section_statement_lookup_1.
	* ldlang.h (lang_output_section_statement_type): Add constraint
	and all_input_readonly fields.
	(lang_enter_output_section_statement): Adjust prototype.
	* ldlex.l (ONLY_IF_RO, ONLY_IF_RW): New tokens.
	* scripttempl/elf.sc (.eh_frame, .gcc_except_table): Move into text
	segment if all input sections are readonly.
@
text
@d229 1
a229 1
	  tmp->spec.sorted = FALSE;
d240 1
a240 1
		tmp->spec.sorted = FALSE;
@


1.14
log
@	* ldexp.c (align_n): Make static.
	* ldexp.h (align_n): Delete declaration.
	* ldlang.h (lang_enter_output_section_statement): Remove
	block_value param.
	* ldlang.c (lang_enter_output_section_statement): Likewise.
	(TO_ADDR, TO_SIZE): Define.
	(opb): New var.
	(init_opb): New function.
	(print_input_section): Call init_opb and use TO_ADDR.
	(print_data_statement, print_reloc_statement): Likewise.
	(print_padding_statement): Likewise.
	(size_input_section): Use TO_SIZE and TO_ADDR, and global opb.
	(lang_check_section_addresses): Likewise.
	(lang_size_sections_1): Likewise.
	(lang_do_assignments_1): Likewise.
	(lang_set_startof): Likewise.
	(lang_one_common): Likewise.  Combine power_of_two and opb alignment.
	(lang_process): Call init_opb.
	(lang_abs_symbol_at_end_of): Use TO_ADDR and global opb.
	(lang_enter_overlay_section): Adjust
	lang_enter_output_section_statement call.
	* ldgram.y: Likewise.
	* mri.c (mri_draw_tree): Likewise.
	* emultempl/elf32.em (gld${EMULATION_NAME}_place_orphan): Likewise.
	* emultempl/mmo.em (mmo_place_orphan): Likewise.
	* emultempl/pe.em (gld${EMULATION_NAME}_place_orphan): Likewise.
@
text
@d223 1
a223 1
					       align, subalign, NULL);
@


1.13
log
@Convert to C90
@
text
@d2 2
a3 2
   Copyright 1991, 1992, 1993, 1994, 1996, 1997, 1998, 1999, 2000, 2002, 2003
   Free Software Foundation, Inc.
d223 1
a223 1
					       1, align, subalign, NULL);
@


1.12
log
@	* ldfile.c: Fix comment typos.
	* ldlang.c: Likewise.
	* mri.c: Likewise.
	* pe-dll.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 1991, 1992, 1993, 1994, 1996, 1997, 1998, 1999, 2000, 2002
a55 7
static struct section_name_struct **lookup
  PARAMS ((const char *name, struct section_name_struct **list));
static void mri_add_to_list PARAMS ((struct section_name_struct **list,
				     const char *name, etree_type *vma,
				     const char *zalias, etree_type *align,
				     etree_type *subalign));

d57 1
a57 3
lookup (name, list)
     const char *name;
     struct section_name_struct **list;
d71 1
a71 1
  *ptr = (struct section_name_struct *) xmalloc (sizeof (struct section_name_struct));
d76 6
a81 7
mri_add_to_list (list, name, vma, zalias, align, subalign)
     struct section_name_struct **list;
     const char *name;
     etree_type *vma;
     const char *zalias;
     etree_type *align;
     etree_type *subalign;
d87 1
a87 1
  (*ptr)->next = (struct section_name_struct *) NULL;
d95 1
a95 3
mri_output_section (name, vma)
     const char *name;
     etree_type *vma;
d104 1
a104 2
mri_only_load (name)
     const char *name;
d110 1
a110 2
mri_base (exp)
     etree_type *exp;
d118 1
a118 1
mri_draw_tree ()
d131 2
a132 2
    r->length = (bfd_size_type) exp_get_vma (0, (bfd_vma) ~((bfd_size_type)0),
					     "length", lang_first_phase_enum);
d140 1
a140 1
  if (address != (struct section_name_struct *) NULL)
d145 1
a145 1
      if (order == (struct section_name_struct *) NULL)
d149 1
a149 1
	   alist != (struct section_name_struct *) NULL;
d154 1
a154 3
	  for (olist = order;
	       done == 0 && olist != (struct section_name_struct *) NULL;
	       olist = olist->next)
d173 1
a173 1
  if (only_load != (struct section_name_struct *) NULL)
d178 1
a178 1
      if (order == (struct section_name_struct *) NULL)
d197 1
a197 1
  if (order != (struct section_name_struct *) NULL)
d223 1
a223 2
					       1, align, subalign,
					       (etree_type *) NULL);
d225 1
a225 1
	  tmp = (struct wildcard_list *) xmalloc (sizeof *tmp);
d236 1
a236 1
		tmp = (struct wildcard_list *) xmalloc (sizeof *tmp);
d244 1
a244 3
	  lang_leave_output_section_statement
	    (0, "*default*", (struct lang_output_section_phdr_list *) NULL,
	     NULL);
d254 1
a254 2
mri_load (name)
     const char *name;
d257 1
a257 2
  lang_add_input_file (name,
		       lang_input_file_is_file_enum, (char *) NULL);
d264 1
a264 2
mri_order (name)
     const char *name;
d270 1
a270 4
mri_alias (want, is, isn)
     const char *want;
     const char *is;
     int isn;
d289 1
a289 2
mri_name (name)
     const char *name;
d295 1
a295 2
mri_format (name)
     const char *name;
d298 1
a298 1
    lang_add_output_format ("srec", (char *) NULL, (char *) NULL, 1);
d301 1
a301 1
    lang_add_output_format ("ieee", (char *) NULL, (char *) NULL, 1);
d304 1
a304 1
    lang_add_output_format ("coff-m68k", (char *) NULL, (char *) NULL, 1);
d311 1
a311 3
mri_public (name, exp)
     const char *name;
     etree_type *exp;
d317 1
a317 3
mri_align (name, exp)
     const char *name;
     etree_type *exp;
d323 1
a323 3
mri_alignmod (name, exp)
     const char *name;
     etree_type *exp;
d329 1
a329 2
mri_truncate (exp)
     unsigned int exp;
@


1.11
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d152 1
a152 1
  /* Attatch the addresses of any which have addresses,
@


1.10
log
@	* emultempl/aix.em: Use include <> for generated headers.
	* emultempl/beos.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/pe.em: Likewise.
	* ldctor.c: Likewise.
	* ldexp.c: Likewise.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldlex.c: Likewise.
	* ldlex.l: Likewise.
	* ldmain.c: Likewise.
	* ldmisc.c: Likewise.
	* ldwrite.c: Likewise.
	* lexsup.c: Likewise.
	* mri.c: Likewise.
	* pe-dll.c: Likewise.
@
text
@d246 2
a247 2
	  tmp->spec.sorted = false;
	  lang_add_wild (NULL, tmp, false);
d257 2
a258 2
		tmp->spec.sorted = false;
		lang_add_wild (NULL, tmp, false);
@


1.9
log
@	* ldexp.c: Replace CONST with const.
	* ldfile.c: Likewise.
	* ldfile.h: Likewise.
	* ldlex.l: Likewise.
	* mri.c: Likewise.
	* pe-dll.h: Likewise.
@
text
@d34 1
a34 1
#include "ldgram.h"
@


1.9.2.1
log
@        * emultempl/aix.em: Use include <> for generated headers.
        * emultempl/beos.em: Likewise.
        * emultempl/elf32.em: Likewise.
        * emultempl/pe.em: Likewise.
        * ldctor.c: Likewise.
        * ldexp.c: Likewise.
        * ldfile.c: Likewise.
        * ldlang.c: Likewise.
        * ldlex.c: Likewise.
        * ldlex.l: Likewise.
        * ldmain.c: Likewise.
        * ldmisc.c: Likewise.
        * ldwrite.c: Likewise.
        * lexsup.c: Likewise.
        * mri.c: Likewise.
        * pe-dll.c: Likewise.
@
text
@d34 1
a34 1
#include <ldgram.h>
@


1.8
log
@	* ldlang.c (lang_size_sections_1): Move check for conflicting load
	addresses and regions from here...
	(lang_get_regions): ...to this new function.
	(lang_leave_output_section_statement): Use lang_get_regions.
	(lang_leave_overlay): Likewise.
	* mri.c (mri_draw_tree): Pass null as last argument to
	lang_leave_output_section_statement.
	* emultempl/elf32.em (gld*_place_orphan): Likewise.
	* emultempl/mmo.em (mmo_place_orphan): Likewise.
	* emultempl/pe.em (gld*_place_orphan): Likewise.
@
text
@d2 1
a2 1
   Copyright 1991, 1992, 1993, 1994, 1996, 1997, 1998, 1999, 2000
d39 2
a40 2
  CONST char *name;
  CONST char *alias;
d65 1
a65 1
     CONST char *name;
d87 1
a87 1
     CONST char *name;
d89 1
a89 1
     CONST char *zalias;
d106 1
a106 1
     CONST char *name;
d117 1
a117 1
     CONST char *name;
d274 1
a274 1
     CONST char *name;
d286 1
a286 1
     CONST char *name;
d293 2
a294 2
     CONST char *want;
     CONST char *is;
d315 1
a315 1
     CONST char *name;
d322 1
a322 1
     CONST char *name;
d339 1
a339 1
     CONST char *name;
d347 1
a347 1
     CONST char *name;
d355 1
a355 1
     CONST char *name;
@


1.7
log
@	* ld.texinfo (Input Section Basics): Clarify ordering of output
	sections.
	* ldlang.c (callback_t): Add wildcard_list param.
	(walk_wild_section): Remove "section" param.  Rewrite for
	lang_wild_statement_type change.  Remove unique_section_p test.
	(walk_wild_file): Remove "section" param.
	(walk_wild): Remove "section" and "file" params.
	(lang_gc_wild): Likewise.
	(wild): Likewise.  Modify for lang_wild_statement_type change.
	(wild_sort): Likewise.  Add "sec" param.
	(gc_section_callback): Likewise.
	(output_section_callback): Likewise.  Do unique_section_p test.
	(map_input_to_output_sections): Modify call to wild.
	(lang_gc_sections_1): Likewise.
	(print_wild_statement): Modify for lang_wild_statement_type
	change.
	(lang_add_wild): Replace filename, filenames_sorted param with
	filespec.  Replace section_name, sections_sorted,
	exclude_filename_list with section_list.
	* ldlang.h (lang_add_wild): Here too.
	(lang_wild_statement_type): Replace section_name, sections_sorted,
	and exclude_filename_list with section_list.
	* ldgram.y (current_file): Delete.
	(%union): Add wildcard_list.
	(file_NAME_list): Set type to wildcard_list.  Build a linked list
	rather than calling lang_add_wild for each entry.
	(input_section_spec_no_keep): Call lang_add_wild here instead.
	* ld.h (struct wildcard_list): Declare.
	* mri.c (mri_draw_tree): Modify to suit new lang_add_wild.
@
text
@d263 1
a263 1
	     "*default*");
@


1.6
log
@Fixtypos in ChangeLogs, fix copyright dates in files
@
text
@d223 1
d242 6
a247 1
	  lang_add_wild (p->name, false, (char *) NULL, false, false, NULL);
d252 8
a259 1
	      lang_add_wild (aptr->name, false, (char *) NULL, false, false, NULL);
@


1.5
log
@2000-10-10  Kazu Hirata  <kazu@@hxi.com>

	* deffile.h: Fix formatting.
	* lexsup.c: Likewise.
	* mri.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 1991, 92, 93, 94, 95, 96, 1997, 1998, 2000
@


1.5.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1991, 1992, 1993, 1994, 1996, 1997, 1998, 1999, 2000
@


1.4
log
@2000-09-29  Kazu Hirata  <kazu@@hxi.com>

	* deffile.h: Fix formatting.
	* ld.h: Likewise.
	* ldctor.h: Likewise.
	* ldemul.h: Likewise.
	* ldexp.h: Likewise.
	* ldfile.h: Likewise.
	* ldlang.h: Likewise.
	* lexsup.c: Likewise.
	* mri.c: Likewise.
	* pe-dll.c: Likewise.
@
text
@d37 1
a37 2
struct section_name_struct
{
d93 1
a93 1
  struct section_name_struct **ptr = lookup (name,list);
d109 1
a109 1
  mri_add_to_list (& address, name, vma, 0,0,0);
d119 1
a119 1
  mri_add_to_list (&only_load, name, 0, 0,0,0);
d154 1
a154 1
  if (address != (struct section_name_struct *)NULL)
d159 1
a159 1
      if (order == (struct section_name_struct *)NULL)
d163 1
a163 1
	   alist != (struct section_name_struct*)NULL;
d169 1
a169 2
	       done == 0 &&
		 olist != (struct section_name_struct *)NULL;
d182 1
a182 1
	      mri_add_to_list (& order, alist->name, alist->vma, 0,0,0);
d189 1
a189 1
  if (only_load != (struct section_name_struct *)NULL)
d194 1
a194 1
      if (order == (struct section_name_struct*)NULL)
d208 1
a208 1
      for (ptr = order; ptr; ptr=ptr->next)
d210 1
a210 1
  }
d213 1
a213 1
  if (order != (struct section_name_struct *)NULL)
d225 1
a225 1
	  for (aptr = alignment; aptr; aptr= aptr->next)
d227 1
a227 1
	      align =  aptr->align;
d229 1
a229 1
	  for (aptr = subalignment; aptr; aptr= aptr->next)
d231 1
a231 1
	      subalign =  aptr->subalign;
d234 1
a234 1
	    base = p->vma ? p->vma :exp_nameop (NAME, ".");
d241 1
a241 1
	  lang_add_wild (p->name, false, (char *)NULL, false, false, NULL);
d246 1
a246 1
	      lang_add_wild (aptr->name, false, (char *)NULL, false, false, NULL);
d265 1
a265 1
		       lang_input_file_is_file_enum, (char *)NULL);
d267 1
a267 1
  lang_leave_output_section_statement (0,"*default*");
d275 1
a275 1
  mri_add_to_list (& order, name, 0, 0,0,0);
d297 1
a297 1
  mri_add_to_list (& alias, is, 0, want,0,0);
d337 1
a337 1
  mri_add_to_list (& alignment, name, 0, 0, exp, 0);
d345 1
a345 1
  mri_add_to_list (& subalignment, name, 0, 0, 0, exp);
@


1.3
log
@Fix formatting
@
text
@d28 1
a28 1
#include "sysdep.h" 
d70 2
a71 2
  
  while (*ptr) 
d95 1
a95 1
  
d142 1
a142 1
    
d150 1
a150 1
  
d159 1
a159 1
      
d165 1
a165 1
	   alist = alist->next) 
d168 1
a168 1
	  
d172 1
a172 1
	       olist = olist->next) 
d174 1
a174 1
	      if (strcmp (alist->name, olist->name) == 0) 
d180 1
a180 1
	  
d191 1
a191 1
  if (only_load != (struct section_name_struct *)NULL) 
d195 1
a195 1
      
d198 1
a198 1
    
d200 2
a201 2
      for (ptr1 = only_load; ptr1; ptr1 = ptr1->next) 
	for (ptr2 = order; ptr2; ptr2 = ptr2->next) 
d205 1
a205 1
  else 
d209 1
a209 1
      
d215 1
a215 1
  if (order != (struct section_name_struct *)NULL) 
d219 2
a220 2
      
      while (p) 
d225 1
a225 1
	  
d244 1
a244 1
	  
d251 1
a251 1
	    (0, "*default*", (struct lang_output_section_phdr_list *) NULL, 
d268 1
a268 1
#if 0  
d280 1
a280 1
void 
d289 1
a289 1
      
d292 1
a292 1
      
d294 1
a294 1
      
d298 1
a298 1
  
d302 1
a302 1
void 
d315 1
a315 1
  
d318 1
a318 1
  
d321 1
a321 1
  
d334 1
a334 1
void 
d342 1
a342 1
void 
d350 1
a350 1
void 
a355 1

@


1.2
log
@Add LMA memory region functionality.
@
text
@d2 2
a3 1
   Copyright (C) 1991, 92, 93, 94, 95, 96, 1997, 1998 Free Software Foundation, Inc.
d20 1
a20 1
02111-1307, USA.  */
d22 2
d25 1
a25 7
/* This bit does the tree decoration when MRI style link scripts are parsed */

/*
  contributed by Steve Chamberlain
  		 sac@@cygnus.com

*/
d37 2
a38 1
struct section_name_struct {
d46 1
a46 1
} ;
a68 1

d70 1
d72 7
a78 5
  {
    if (strcmp(name, (*ptr)->name) == 0) {
      /* If this is a match, delete it, we only keep the last instance
	 of any name */
      *ptr = (*ptr)->next;
a79 4
    else {
      ptr = &((*ptr)->next);
    }
  }
d81 1
a81 1
  *ptr = (struct section_name_struct *)xmalloc(sizeof(struct section_name_struct));
d94 2
a95 1
  struct section_name_struct **ptr = lookup(name,list);
d98 1
a98 1
  (*ptr)->next = (struct section_name_struct *)NULL;
a104 1

d110 1
a110 1
  mri_add_to_list(&address, name, vma, 0,0,0);
d113 2
a114 2
/* if any ABSOLUTE <name> are in the script, only load those files
marked thus */
d120 1
a120 1
  mri_add_to_list(&only_load, name, 0, 0,0,0);
a122 1

d135 2
a136 1
  if (done_tree) return;
d138 11
a148 11
  /* We don't bother with memory regions.  */
#if 0
  /* Create the regions */
 {
   lang_memory_region_type *r;
   r = lang_memory_region_lookup("long");
   r->current = r->origin = exp_get_vma(base, (bfd_vma)0, "origin",
					lang_first_phase_enum);
   r->length = (bfd_size_type) exp_get_vma(0, (bfd_vma) ~((bfd_size_type)0),
					   "length", lang_first_phase_enum);
 }
d151 1
a151 11
  /* Now build the statements for the ldlang machine */


  /* Attatch the addresses of any which have addresses, and add the
     ones not mentioned */
  if (address != (struct section_name_struct *)NULL) {
    struct section_name_struct *alist;
    struct section_name_struct *olist;
    if (order == (struct section_name_struct *)NULL) {
      order = address;
    }
d153 3
a155 3
    for (alist = address;
	 alist != (struct section_name_struct*)NULL;
	 alist = alist->next) 
d157 9
a165 7
      int done = 0;
      for (olist = order;
	   done == 0 &&
	   olist != (struct section_name_struct *)NULL;
	   olist = olist->next) 
      {
	if (strcmp(alist->name, olist->name) == 0) 
d167 19
a185 2
	  olist->vma = alist->vma;
	  done = 1;
a186 6
      }
      if (!done) {
	/* add this onto end of order list */
	mri_add_to_list(&order, alist->name, alist->vma, 0,0,0);
      }

a188 2
  }

a190 1

d192 6
a197 5
  {
    struct section_name_struct *ptr1;
    struct section_name_struct *ptr2;
    if (order == (struct section_name_struct*)NULL)
     order = only_load;
d199 5
a203 10
    /* See if this name is in the list, if it is then we can load it
     */
    for (ptr1 = only_load; ptr1; ptr1 = ptr1->next) 
    {
      for (ptr2= order; ptr2; ptr2=ptr2->next) 
      {
	if (strcmp(ptr2->name, ptr1->name)==0) {
	  ptr2->ok_to_load = 1;
	}
      }
a204 1
  }
d206 6
a211 6
  {
    /* No only load list, so everything is ok to load */
    struct section_name_struct *ptr;
    for (ptr = order; ptr; ptr=ptr->next) {
      ptr->ok_to_load = 1;
    }
d214 1
a214 3


  /* Create the order of sections to load */
a215 4
  {
    /* Been told to output the sections in a certain order */
    struct section_name_struct *p = order;
    while (p) 
d217 36
a252 11
      struct section_name_struct *aptr;
      etree_type *align = 0;
      etree_type *subalign = 0;
      /* See if an alignment has been specified */

      for (aptr = alignment; aptr; aptr= aptr->next)
      {
	if (strcmp(aptr->name, p->name)==0) {
	  align =  aptr->align;
	}
      }
d254 1
a254 4
      for (aptr = subalignment; aptr; aptr= aptr->next)
      {
	if (strcmp(aptr->name, p->name)==0) {
	  subalign =  aptr->subalign;
a255 24
      }

      if (base == 0) {
	base = p->vma ? p->vma :exp_nameop(NAME, ".");
      }
      lang_enter_output_section_statement (p->name, base,
					   p->ok_to_load ? 0 : noload_section,
					   1, align, subalign,
					   (etree_type *) NULL);
      base = 0;
      lang_add_wild (p->name, false, (char *)NULL, false, false, NULL);
      /* If there is an alias for this section, add it too */
      for (aptr = alias; aptr; aptr = aptr->next) {

	if (strcmp(aptr->alias, p->name)== 0) {
	  lang_add_wild (aptr->name, false, (char *)NULL, false, false, NULL);
	}
      }

      lang_leave_output_section_statement
	(0, "*default*", (struct lang_output_section_phdr_list *) NULL, 
         "*default*");

      p = p->next;
a256 2
  }

d259 1
a260 1
}
d266 5
a270 3
  lang_add_input_file(name,
		      lang_input_file_is_file_enum, (char *)NULL);
  /*  lang_leave_output_section_statement(0,"*default*");*/
a272 1

d277 1
a277 1
  mri_add_to_list(&order, name, 0, 0,0,0);
d286 14
a299 10
  if (!is) {
    /* Some sections are digits - */
    char buf[20];
    sprintf(buf, "%d", isn);
    is = xstrdup (buf);
    if (is == NULL)
      abort ();
  }
  mri_add_to_list(&alias, is, 0, want,0,0);

a301 1

d306 1
a306 2
  lang_add_output(name, 1);

a308 1

d313 11
a323 15
  if (strcmp(name, "S") == 0)
  {
    lang_add_output_format("srec", (char *) NULL, (char *) NULL, 1);
  }
  else if (strcmp(name, "IEEE") == 0)
  {
    lang_add_output_format("ieee", (char *) NULL, (char *) NULL, 1);
  }
  else if (strcmp(name, "COFF") == 0)
  {
    lang_add_output_format("coff-m68k", (char *) NULL, (char *) NULL, 1);
  }
  else {
    einfo(_("%P%F: unknown format type %s\n"), name);
  }
a325 1

d331 1
a331 1
  lang_add_assignment(exp_assop('=', name, exp));
d339 1
a339 1
  mri_add_to_list(&alignment, name,0,0,exp,0);
d347 1
a347 1
  mri_add_to_list(&subalignment, name,0,0,0,exp);
a349 1

d356 1
@


1.1
log
@Initial revision
@
text
@d269 2
a270 1
	(0, "*default*", (struct lang_output_section_phdr_list *) NULL);
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

