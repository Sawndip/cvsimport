head	1.147;
access;
symbols
	binutils-2_24-branch:1.147.0.2
	binutils-2_24-branchpoint:1.147
	binutils-2_21_1:1.133.2.1
	binutils-2_23_2:1.145
	binutils-2_23_1:1.145
	binutils-2_23:1.145
	binutils-2_23-branch:1.145.0.2
	binutils-2_23-branchpoint:1.145
	binutils-2_22_branch:1.138.2.1.0.2
	binutils-2_22:1.138.2.1
	binutils-2_22-branch:1.138.0.2
	binutils-2_22-branchpoint:1.138
	binutils-2_21:1.133
	binutils-2_21-branch:1.133.0.2
	binutils-2_21-branchpoint:1.133
	binutils-2_20_1:1.120.4.1
	binutils-2_20:1.120
	binutils-arc-20081103-branch:1.109.0.4
	binutils-arc-20081103-branchpoint:1.109
	binutils-2_20-branch:1.120.0.4
	binutils-2_20-branchpoint:1.120
	dje-cgen-play1-branch:1.120.0.2
	dje-cgen-play1-branchpoint:1.120
	arc-20081103-branch:1.109.0.2
	arc-20081103-branchpoint:1.109
	binutils-2_19_1:1.108.2.1
	binutils-2_19:1.108
	binutils-2_19-branch:1.108.0.2
	binutils-2_19-branchpoint:1.108
	binutils-2_18:1.100
	binutils-2_18-branch:1.100.0.2
	binutils-2_18-branchpoint:1.100
	binutils-csl-coldfire-4_1-32:1.83
	binutils-csl-sourcerygxx-4_1-32:1.83
	binutils-csl-innovasic-fido-3_4_4-33:1.83
	binutils-csl-sourcerygxx-3_4_4-32:1.77
	binutils-csl-coldfire-4_1-30:1.83
	binutils-csl-sourcerygxx-4_1-30:1.83
	binutils-csl-coldfire-4_1-28:1.83
	binutils-csl-sourcerygxx-4_1-29:1.83
	binutils-csl-sourcerygxx-4_1-28:1.83
	binutils-csl-arm-2006q3-27:1.83
	binutils-csl-sourcerygxx-4_1-27:1.83
	binutils-csl-arm-2006q3-26:1.83
	binutils-csl-sourcerygxx-4_1-26:1.83
	binutils-csl-sourcerygxx-4_1-25:1.83
	binutils-csl-sourcerygxx-4_1-24:1.83
	binutils-csl-sourcerygxx-4_1-23:1.83
	binutils-csl-sourcerygxx-4_1-21:1.83
	binutils-csl-arm-2006q3-21:1.83
	binutils-csl-sourcerygxx-4_1-22:1.83
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.83
	binutils-csl-sourcerygxx-4_1-20:1.83
	binutils-csl-arm-2006q3-19:1.83
	binutils-csl-sourcerygxx-4_1-19:1.83
	binutils-csl-sourcerygxx-4_1-18:1.83
	binutils-csl-renesas-4_1-9:1.83
	binutils-csl-sourcerygxx-3_4_4-25:1.77
	binutils-csl-renesas-4_1-8:1.83
	binutils-csl-renesas-4_1-7:1.83
	binutils-csl-renesas-4_1-6:1.83
	binutils-csl-sourcerygxx-4_1-17:1.83
	binutils-csl-sourcerygxx-4_1-14:1.83
	binutils-csl-sourcerygxx-4_1-15:1.83
	binutils-csl-sourcerygxx-4_1-13:1.83
	binutils-2_17:1.83
	binutils-csl-sourcerygxx-4_1-12:1.83
	binutils-csl-sourcerygxx-3_4_4-21:1.83
	binutils-csl-wrs-linux-3_4_4-24:1.77
	binutils-csl-wrs-linux-3_4_4-23:1.77
	binutils-csl-sourcerygxx-4_1-9:1.83
	binutils-csl-sourcerygxx-4_1-8:1.83
	binutils-csl-sourcerygxx-4_1-7:1.83
	binutils-csl-arm-2006q1-6:1.83
	binutils-csl-sourcerygxx-4_1-6:1.83
	binutils-csl-wrs-linux-3_4_4-22:1.77
	binutils-csl-coldfire-4_1-11:1.83
	binutils-csl-sourcerygxx-3_4_4-19:1.83
	binutils-csl-coldfire-4_1-10:1.83
	binutils-csl-sourcerygxx-4_1-5:1.83
	binutils-csl-sourcerygxx-4_1-4:1.83
	binutils-csl-wrs-linux-3_4_4-21:1.77
	binutils-csl-morpho-4_1-4:1.83
	binutils-csl-sourcerygxx-3_4_4-17:1.83
	binutils-csl-wrs-linux-3_4_4-20:1.77
	binutils-2_17-branch:1.83.0.4
	binutils-2_17-branchpoint:1.83
	binutils-csl-2_17-branch:1.83.0.2
	binutils-csl-2_17-branchpoint:1.83
	binutils-csl-gxxpro-3_4-branch:1.77.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.77
	binutils-2_16_1:1.77
	binutils-csl-arm-2005q1b:1.77
	binutils-2_16:1.77
	binutils-csl-arm-2005q1a:1.77
	binutils-csl-arm-2005q1-branch:1.77.0.4
	binutils-csl-arm-2005q1-branchpoint:1.77
	binutils-2_16-branch:1.77.0.2
	binutils-2_16-branchpoint:1.77
	csl-arm-2004-q3d:1.74
	csl-arm-2004-q3:1.73
	binutils-2_15:1.66.6.2
	binutils-2_15-branchpoint:1.66
	csl-arm-2004-q1a:1.69
	csl-arm-2004-q1:1.68
	binutils-2_15-branch:1.66.0.6
	cagney_bfdfile-20040213-branch:1.66.0.4
	cagney_bfdfile-20040213-branchpoint:1.66
	cagney_bigcore-20040122-branch:1.66.0.2
	cagney_bigcore-20040122-branchpoint:1.66
	csl-arm-2003-q4:1.65
	binutils-2_14:1.56
	binutils-2_14-branch:1.56.0.2
	binutils-2_14-branchpoint:1.56
	binutils-2_13_2_1:1.41.2.3
	binutils-2_13_2:1.41.2.3
	binutils-2_13_1:1.41.2.3
	binutils-2_13:1.41
	binutils-2_13-branchpoint:1.41
	binutils-2_13-branch:1.41.0.2
	binutils-2_12_1:1.37
	binutils-2_12:1.37
	binutils-2_12-branch:1.37.0.2
	binutils-2_12-branchpoint:1.37
	cygnus_cvs_20020108_pre:1.37
	binutils-2_11_2:1.22.2.1
	binutils-2_11_1:1.22.2.1
	binutils-2_11:1.22
	x86_64versiong3:1.22
	binutils-2_11-branch:1.22.0.2
	binutils-2_10_1:1.10
	binutils-2_10:1.10
	binutils-2_10-branch:1.10.0.2
	binutils-2_10-branchpoint:1.10
	binutils_latest_snapshot:1.147
	repo-unification-2000-02-06:1.8
	binu_ss_19990721:1.2
	binu_ss_19990602:1.2
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.147
date	2013.03.21.14.05.29;	author ktietz;	state Exp;
branches;
next	1.146;

1.146
date	2013.01.10.20.08.02;	author hjl;	state Exp;
branches;
next	1.145;

1.145
date	2012.07.13.13.20.26;	author nickc;	state Exp;
branches;
next	1.144;

1.144
date	2012.05.07.10.52.00;	author gingold;	state Exp;
branches;
next	1.143;

1.143
date	2012.05.05.03.05.32;	author amodra;	state Exp;
branches;
next	1.142;

1.142
date	2012.03.14.19.00.03;	author ktietz;	state Exp;
branches;
next	1.141;

1.141
date	2012.02.19.21.18.08;	author ktietz;	state Exp;
branches;
next	1.140;

1.140
date	2012.02.11.19.25.12;	author nickc;	state Exp;
branches;
next	1.139;

1.139
date	2011.10.13.02.34.35;	author davek;	state Exp;
branches;
next	1.138;

1.138
date	2011.09.16.01.15.19;	author hjl;	state Exp;
branches
	1.138.2.1;
next	1.137;

1.137
date	2011.05.03.14.56.14;	author amodra;	state Exp;
branches;
next	1.136;

1.136
date	2011.04.13.12.53.36;	author ktietz;	state Exp;
branches;
next	1.135;

1.135
date	2011.02.28.18.34.52;	author ktietz;	state Exp;
branches;
next	1.134;

1.134
date	2011.02.15.16.15.55;	author ktietz;	state Exp;
branches;
next	1.133;

1.133
date	2010.06.27.04.07.54;	author amodra;	state Exp;
branches
	1.133.2.1;
next	1.132;

1.132
date	2010.06.09.18.17.10;	author davek;	state Exp;
branches;
next	1.131;

1.131
date	2010.05.15.19.50.44;	author ktietz;	state Exp;
branches;
next	1.130;

1.130
date	2010.05.15.14.20.06;	author davek;	state Exp;
branches;
next	1.129;

1.129
date	2010.04.28.15.24.22;	author ktietz;	state Exp;
branches;
next	1.128;

1.128
date	2010.04.05.09.04.08;	author ktietz;	state Exp;
branches;
next	1.127;

1.127
date	2010.03.18.10.51.31;	author nickc;	state Exp;
branches;
next	1.126;

1.126
date	2009.12.17.19.51.35;	author davek;	state Exp;
branches;
next	1.125;

1.125
date	2009.12.11.13.42.14;	author nickc;	state Exp;
branches;
next	1.124;

1.124
date	2009.11.27.09.00.36;	author gingold;	state Exp;
branches;
next	1.123;

1.123
date	2009.11.15.07.52.42;	author ktietz;	state Exp;
branches;
next	1.122;

1.122
date	2009.10.23.11.40.17;	author ktietz;	state Exp;
branches;
next	1.121;

1.121
date	2009.10.16.15.15.38;	author nickc;	state Exp;
branches;
next	1.120;

1.120
date	2009.05.19.16.08.07;	author davek;	state Exp;
branches
	1.120.4.1;
next	1.119;

1.119
date	2009.05.17.05.10.20;	author davek;	state Exp;
branches;
next	1.118;

1.118
date	2009.05.04.12.09.30;	author davek;	state Exp;
branches;
next	1.117;

1.117
date	2009.02.18.18.23.07;	author davek;	state Exp;
branches;
next	1.116;

1.116
date	2009.01.26.10.29.11;	author ktietz;	state Exp;
branches;
next	1.115;

1.115
date	2009.01.08.13.28.48;	author ktietz;	state Exp;
branches;
next	1.114;

1.114
date	2009.01.03.18.04.16;	author davek;	state Exp;
branches;
next	1.113;

1.113
date	2009.01.03.17.43.45;	author davek;	state Exp;
branches;
next	1.112;

1.112
date	2008.12.03.14.51.00;	author nickc;	state Exp;
branches;
next	1.111;

1.111
date	2008.12.02.09.33.12;	author ktietz;	state Exp;
branches;
next	1.110;

1.110
date	2008.11.14.15.13.05;	author ktietz;	state Exp;
branches;
next	1.109;

1.109
date	2008.09.29.14.01.50;	author ktietz;	state Exp;
branches;
next	1.108;

1.108
date	2008.08.17.03.12.50;	author amodra;	state Exp;
branches
	1.108.2.1;
next	1.107;

1.107
date	2008.07.31.07.27.52;	author dannysmith;	state Exp;
branches;
next	1.106;

1.106
date	2008.07.09.03.18.15;	author dannysmith;	state Exp;
branches;
next	1.105;

1.105
date	2008.05.27.08.34.26;	author ktietz;	state Exp;
branches;
next	1.104;

1.104
date	2008.05.09.11.56.31;	author ktietz;	state Exp;
branches;
next	1.103;

1.103
date	2008.04.03.14.44.55;	author ktietz;	state Exp;
branches;
next	1.102;

1.102
date	2008.02.15.03.35.53;	author amodra;	state Exp;
branches;
next	1.101;

1.101
date	2007.10.25.21.01.55;	author palves;	state Exp;
branches;
next	1.100;

1.100
date	2007.08.06.14.32.08;	author nickc;	state Exp;
branches;
next	1.99;

1.99
date	2007.07.06.14.09.41;	author nickc;	state Exp;
branches;
next	1.98;

1.98
date	2007.06.27.11.54.10;	author amodra;	state Exp;
branches;
next	1.97;

1.97
date	2007.04.26.14.46.59;	author amodra;	state Exp;
branches;
next	1.96;

1.96
date	2007.03.16.15.13.21;	author nickc;	state Exp;
branches;
next	1.95;

1.95
date	2007.01.19.15.40.54;	author nickc;	state Exp;
branches;
next	1.94;

1.94
date	2007.01.02.07.43.13;	author amodra;	state Exp;
branches;
next	1.93;

1.93
date	2006.12.18.22.38.53;	author cgf;	state Exp;
branches;
next	1.92;

1.92
date	2006.11.01.00.48.25;	author cgf;	state Exp;
branches;
next	1.91;

1.91
date	2006.10.29.17.14.37;	author cgf;	state Exp;
branches;
next	1.90;

1.90
date	2006.10.03.10.06.26;	author nickc;	state Exp;
branches;
next	1.89;

1.89
date	2006.09.20.11.35.09;	author nickc;	state Exp;
branches;
next	1.88;

1.88
date	2006.09.16.18.12.16;	author nickc;	state Exp;
branches;
next	1.87;

1.87
date	2006.08.21.08.12.46;	author nickc;	state Exp;
branches;
next	1.86;

1.86
date	2006.08.17.17.02.13;	author cgf;	state Exp;
branches;
next	1.85;

1.85
date	2006.06.23.11.20.15;	author nickc;	state Exp;
branches;
next	1.84;

1.84
date	2006.05.11.08.48.58;	author nickc;	state Exp;
branches;
next	1.83;

1.83
date	2006.01.31.22.08.14;	author dannysmith;	state Exp;
branches;
next	1.82;

1.82
date	2006.01.27.17.18.13;	author nickc;	state Exp;
branches;
next	1.81;

1.81
date	2005.12.08.11.38.25;	author amodra;	state Exp;
branches;
next	1.80;

1.80
date	2005.08.10.16.46.30;	author nickc;	state Exp;
branches;
next	1.79;

1.79
date	2005.06.09.02.05.46;	author amodra;	state Exp;
branches;
next	1.78;

1.78
date	2005.05.12.07.32.03;	author nickc;	state Exp;
branches;
next	1.77;

1.77
date	2005.03.02.09.03.58;	author jbeulich;	state Exp;
branches;
next	1.76;

1.76
date	2005.02.23.12.30.48;	author amodra;	state Exp;
branches;
next	1.75;

1.75
date	2005.01.21.04.15.59;	author bje;	state Exp;
branches;
next	1.74;

1.74
date	2004.10.24.01.00.12;	author dannysmith;	state Exp;
branches;
next	1.73;

1.73
date	2004.09.30.17.19.19;	author nickc;	state Exp;
branches;
next	1.72;

1.72
date	2004.07.13.08.55.53;	author nickc;	state Exp;
branches;
next	1.71;

1.71
date	2004.06.24.04.46.27;	author amodra;	state Exp;
branches;
next	1.70;

1.70
date	2004.06.15.01.13.20;	author amodra;	state Exp;
branches;
next	1.69;

1.69
date	2004.04.29.13.05.49;	author amodra;	state Exp;
branches;
next	1.68;

1.68
date	2004.03.08.11.33.59;	author nickc;	state Exp;
branches;
next	1.67;

1.67
date	2004.02.25.21.00.32;	author dannysmith;	state Exp;
branches;
next	1.66;

1.66
date	2004.01.20.21.08.16;	author dannysmith;	state Exp;
branches
	1.66.6.1;
next	1.65;

1.65
date	2003.12.05.11.30.18;	author nickc;	state Exp;
branches;
next	1.64;

1.64
date	2003.10.31.05.32.44;	author cagney;	state Exp;
branches;
next	1.63;

1.63
date	2003.10.20.14.38.42;	author cagney;	state Exp;
branches;
next	1.62;

1.62
date	2003.10.14.06.26.31;	author dannysmith;	state Exp;
branches;
next	1.61;

1.61
date	2003.10.02.11.18.13;	author nickc;	state Exp;
branches;
next	1.60;

1.60
date	2003.07.17.15.47.49;	author nickc;	state Exp;
branches;
next	1.59;

1.59
date	2003.06.28.05.28.54;	author amodra;	state Exp;
branches;
next	1.58;

1.58
date	2003.06.17.12.05.33;	author nickc;	state Exp;
branches;
next	1.57;

1.57
date	2003.06.02.08.43.37;	author nickc;	state Exp;
branches;
next	1.56;

1.56
date	2003.04.02.17.39.24;	author nickc;	state Exp;
branches;
next	1.55;

1.55
date	2003.02.21.10.51.24;	author nickc;	state Exp;
branches;
next	1.54;

1.54
date	2003.01.28.11.39.43;	author nickc;	state Exp;
branches;
next	1.53;

1.53
date	2003.01.05.03.04.10;	author cgf;	state Exp;
branches;
next	1.52;

1.52
date	2003.01.02.10.26.41;	author nickc;	state Exp;
branches;
next	1.51;

1.51
date	2003.01.02.03.53.53;	author kazu;	state Exp;
branches;
next	1.50;

1.50
date	2002.12.16.18.02.14;	author nickc;	state Exp;
branches;
next	1.49;

1.49
date	2002.11.30.08.39.45;	author amodra;	state Exp;
branches;
next	1.48;

1.48
date	2002.11.14.18.03.16;	author nickc;	state Exp;
branches;
next	1.47;

1.47
date	2002.11.11.21.16.28;	author cgf;	state Exp;
branches;
next	1.46;

1.46
date	2002.11.11.17.42.36;	author cgf;	state Exp;
branches;
next	1.45;

1.45
date	2002.11.06.19.36.20;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	2002.10.30.03.57.38;	author drow;	state Exp;
branches;
next	1.43;

1.43
date	2002.10.11.08.59.24;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2002.10.07.16.36.11;	author nickc;	state Exp;
branches;
next	1.41;

1.41
date	2002.05.25.20.39.25;	author kazu;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2002.05.22.18.03.07;	author cgf;	state Exp;
branches;
next	1.39;

1.39
date	2002.05.03.13.48.55;	author kazu;	state Exp;
branches;
next	1.38;

1.38
date	2002.02.15.02.11.05;	author amodra;	state Exp;
branches;
next	1.37;

1.37
date	2001.10.19.14.25.51;	author dj;	state Exp;
branches;
next	1.36;

1.36
date	2001.10.19.00.00.55;	author dj;	state Exp;
branches;
next	1.35;

1.35
date	2001.10.11.17.16.58;	author dj;	state Exp;
branches;
next	1.34;

1.34
date	2001.09.24.21.16.47;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	2001.09.24.21.13.48;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2001.09.24.18.21.24;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	2001.09.24.15.03.01;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	2001.09.19.05.33.33;	author hjl;	state Exp;
branches;
next	1.29;

1.29
date	2001.09.18.10.10.20;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2001.09.14.14.19.05;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	2001.09.12.15.58.10;	author cwilson;	state Exp;
branches;
next	1.26;

1.26
date	2001.08.21.11.42.57;	author aj;	state Exp;
branches;
next	1.25;

1.25
date	2001.08.20.00.22.40;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2001.08.02.23.12.02;	author cwilson;	state Exp;
branches;
next	1.23;

1.23
date	2001.03.13.06.14.27;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2000.10.10.03.28.01;	author dj;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2000.10.09.15.46.45;	author kazu;	state Exp;
branches;
next	1.20;

1.20
date	2000.10.09.07.01.29;	author kazu;	state Exp;
branches;
next	1.19;

1.19
date	2000.10.09.01.37.11;	author kazu;	state Exp;
branches;
next	1.18;

1.18
date	2000.10.03.22.07.17;	author dj;	state Exp;
branches;
next	1.17;

1.17
date	2000.10.02.14.39.46;	author dj;	state Exp;
branches;
next	1.16;

1.16
date	2000.09.29.13.21.41;	author kazu;	state Exp;
branches;
next	1.15;

1.15
date	2000.09.28.20.53.39;	author dj;	state Exp;
branches;
next	1.14;

1.14
date	2000.07.19.00.04.04;	author dj;	state Exp;
branches;
next	1.13;

1.13
date	2000.07.17.18.40.47;	author dj;	state Exp;
branches;
next	1.12;

1.12
date	2000.07.13.00.51.40;	author dj;	state Exp;
branches;
next	1.11;

1.11
date	2000.07.11.03.42.41;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2000.03.01.20.54.37;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2000.02.24.17.53.11;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2000.01.04.23.44.03;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2000.01.04.23.33.29;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.04.23.30.51;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	99.09.29.00.31.40;	author dj;	state Exp;
branches;
next	1.4;

1.4
date	99.09.28.20.22.55;	author dj;	state Exp;
branches;
next	1.3;

1.3
date	99.09.12.15.27.47;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.05.11.21.06.48;	author dj;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.29.07;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.138.2.1
date	2011.10.13.02.35.07;	author davek;	state Exp;
branches;
next	;

1.133.2.1
date	2011.05.03.15.16.40;	author amodra;	state Exp;
branches;
next	;

1.120.4.1
date	2009.12.17.21.46.44;	author davek;	state Exp;
branches;
next	;

1.108.2.1
date	2009.01.08.14.39.45;	author davek;	state Exp;
branches;
next	;

1.66.6.1
date	2004.04.09.18.28.15;	author drow;	state Exp;
branches;
next	1.66.6.2;

1.66.6.2
date	2004.04.29.13.18.48;	author amodra;	state Exp;
branches;
next	;

1.41.2.1
date	2002.10.11.09.01.44;	author amodra;	state Exp;
branches;
next	1.41.2.2;

1.41.2.2
date	2002.10.28.18.45.52;	author drow;	state Exp;
branches;
next	1.41.2.3;

1.41.2.3
date	2002.10.30.03.54.52;	author drow;	state Exp;
branches;
next	;

1.22.2.1
date	2001.06.07.03.17.14;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.07;	author rth;	state Exp;
branches;
next	;


desc
@@


1.147
log
@	* pe-dll.c (process_def_file_and_drectve): Don't handle VC
	generated C++-symbols as stdcall/fastcall.
@
text
@/* Routines to help build PEI-format DLLs (Win32 etc)
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
   2008, 2009, 2010, 2011, 2012 Free Software Foundation, Inc.
   Written by DJ Delorie <dj@@cygnus.com>

   This file is part of the GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "bfdlink.h"
#include "libiberty.h"
#include "filenames.h"
#include "safe-ctype.h"

#include <time.h>

#include "ld.h"
#include "ldexp.h"
#include "ldlang.h"
#include "ldwrite.h"
#include "ldmisc.h"
#include <ldgram.h>
#include "ldmain.h"
#include "ldfile.h"
#include "ldemul.h"
#include "coff/internal.h"
#include "../bfd/libcoff.h"
#include "deffile.h"

#ifdef pe_use_x86_64

#define PE_IDATA4_SIZE	8
#define PE_IDATA5_SIZE	8
#include "pep-dll.h"
#undef  AOUTSZ
#define AOUTSZ		PEPAOUTSZ
#define PEAOUTHDR	PEPAOUTHDR

#else

#include "pe-dll.h"

#endif

#ifndef PE_IDATA4_SIZE
#define PE_IDATA4_SIZE	4
#endif

#ifndef PE_IDATA5_SIZE
#define PE_IDATA5_SIZE	4
#endif

/*  This file turns a regular Windows PE image into a DLL.  Because of
    the complexity of this operation, it has been broken down into a
    number of separate modules which are all called by the main function
    at the end of this file.  This function is not re-entrant and is
    normally only called once, so static variables are used to reduce
    the number of parameters and return values required.

    See also: ld/emultempl/pe.em and ld/emultempl/pep.em.  */

/*  Auto-import feature by Paul Sokolovsky

    Quick facts:

    1. With this feature on, DLL clients can import variables from DLL
    without any concern from their side (for example, without any source
    code modifications).

    2. This is done completely in bounds of the PE specification (to be fair,
    there's a place where it pokes nose out of, but in practice it works).
    So, resulting module can be used with any other PE compiler/linker.

    3. Auto-import is fully compatible with standard import method and they
    can be mixed together.

    4. Overheads: space: 8 bytes per imported symbol, plus 20 for each
    reference to it; load time: negligible; virtual/physical memory: should be
    less than effect of DLL relocation, and I sincerely hope it doesn't affect
    DLL sharability (too much).

    Idea

    The obvious and only way to get rid of dllimport insanity is to make client
    access variable directly in the DLL, bypassing extra dereference. I.e.,
    whenever client contains something like

    mov dll_var,%eax,

    address of dll_var in the command should be relocated to point into loaded
    DLL. The aim is to make OS loader do so, and than make ld help with that.
    Import section of PE made following way: there's a vector of structures
    each describing imports from particular DLL. Each such structure points
    to two other parallel vectors: one holding imported names, and one which
    will hold address of corresponding imported name. So, the solution is
    de-vectorize these structures, making import locations be sparse and
    pointing directly into code. Before continuing, it is worth a note that,
    while authors strives to make PE act ELF-like, there're some other people
    make ELF act PE-like: elfvector, ;-) .

    Implementation

    For each reference of data symbol to be imported from DLL (to set of which
    belong symbols with name <sym>, if __imp_<sym> is found in implib), the
    import fixup entry is generated. That entry is of type
    IMAGE_IMPORT_DESCRIPTOR and stored in .idata$2 subsection. Each
    fixup entry contains pointer to symbol's address within .text section
    (marked with __fuN_<sym> symbol, where N is integer), pointer to DLL name
    (so, DLL name is referenced by multiple entries), and pointer to symbol
    name thunk. Symbol name thunk is singleton vector (__nm_th_<symbol>)
    pointing to IMAGE_IMPORT_BY_NAME structure (__nm_<symbol>) directly
    containing imported name. Here comes that "on the edge" problem mentioned
    above: PE specification rambles that name vector (OriginalFirstThunk)
    should run in parallel with addresses vector (FirstThunk), i.e. that they
    should have same number of elements and terminated with zero. We violate
    this, since FirstThunk points directly into machine code. But in practice,
    OS loader implemented the sane way: it goes thru OriginalFirstThunk and
    puts addresses to FirstThunk, not something else. It once again should be
    noted that dll and symbol name structures are reused across fixup entries
    and should be there anyway to support standard import stuff, so sustained
    overhead is 20 bytes per reference. Other question is whether having several
    IMAGE_IMPORT_DESCRIPTORS for the same DLL is possible. Answer is yes, it is
    done even by native compiler/linker (libth32's functions are in fact reside
    in windows9x kernel32.dll, so if you use it, you have two
    IMAGE_IMPORT_DESCRIPTORS for kernel32.dll). Yet other question is whether
    referencing the same PE structures several times is valid. The answer is why
    not, prohibiting that (detecting violation) would require more work on
    behalf of loader than not doing it.

    See also: ld/emultempl/pe.em and ld/emultempl/pep.em.  */

static void add_bfd_to_link (bfd *, const char *, struct bfd_link_info *);

/* For emultempl/pe.em.  */

def_file * pe_def_file = 0;
int pe_dll_export_everything = 0;
int pe_dll_exclude_all_symbols = 0;
int pe_dll_do_default_excludes = 1;
int pe_dll_kill_ats = 0;
int pe_dll_stdcall_aliases = 0;
int pe_dll_warn_dup_exports = 0;
int pe_dll_compat_implib = 0;
int pe_dll_extra_pe_debug = 0;
int pe_use_nul_prefixed_import_tables = 0;
int pe_use_coff_long_section_names = -1;
int pe_leading_underscore = -1;

/* Static variables and types.  */

static bfd_vma image_base;
static bfd *filler_bfd;
static struct bfd_section *edata_s, *reloc_s;
static unsigned char *edata_d, *reloc_d;
static size_t edata_sz, reloc_sz;
static int runtime_pseudo_relocs_created = 0;
static int runtime_pseudp_reloc_v2_init = 0;

typedef struct
{
  const char *name;
  int len;
}
autofilter_entry_type;

typedef struct
{
  const char *target_name;
  const char *object_target;
  unsigned int imagebase_reloc;
  int pe_arch;
  int bfd_arch;
  bfd_boolean underscored;
  const autofilter_entry_type* autofilter_symbollist;
}
pe_details_type;

static const autofilter_entry_type autofilter_symbollist_generic[] =
{
  { STRING_COMMA_LEN ("_NULL_IMPORT_DESCRIPTOR") },
  /* Entry point symbols.  */
  { STRING_COMMA_LEN ("DllMain") },
  { STRING_COMMA_LEN ("DllMainCRTStartup") },
  { STRING_COMMA_LEN ("_DllMainCRTStartup") },
  /* Runtime pseudo-reloc.  */
  { STRING_COMMA_LEN ("_pei386_runtime_relocator") },
  { STRING_COMMA_LEN ("do_pseudo_reloc") },
  { NULL, 0 }
};

static const autofilter_entry_type autofilter_symbollist_i386[] =
{
  { STRING_COMMA_LEN ("_NULL_IMPORT_DESCRIPTOR") },
  /* Entry point symbols, and entry hooks.  */
  { STRING_COMMA_LEN ("cygwin_crt0") },
#ifdef pe_use_x86_64
  { STRING_COMMA_LEN ("DllMain") },
  { STRING_COMMA_LEN ("DllEntryPoint") },
  { STRING_COMMA_LEN ("DllMainCRTStartup") },
  { STRING_COMMA_LEN ("_cygwin_dll_entry") },
  { STRING_COMMA_LEN ("_cygwin_crt0_common") },
  { STRING_COMMA_LEN ("_cygwin_noncygwin_dll_entry") },
#else
  { STRING_COMMA_LEN ("DllMain@@12") },
  { STRING_COMMA_LEN ("DllEntryPoint@@0") },
  { STRING_COMMA_LEN ("DllMainCRTStartup@@12") },
  { STRING_COMMA_LEN ("_cygwin_dll_entry@@12") },
  { STRING_COMMA_LEN ("_cygwin_crt0_common@@8") },
  { STRING_COMMA_LEN ("_cygwin_noncygwin_dll_entry@@12") },
  { STRING_COMMA_LEN ("cygwin_attach_dll") },
#endif
  { STRING_COMMA_LEN ("cygwin_premain0") },
  { STRING_COMMA_LEN ("cygwin_premain1") },
  { STRING_COMMA_LEN ("cygwin_premain2") },
  { STRING_COMMA_LEN ("cygwin_premain3") },
  /* Runtime pseudo-reloc.  */
  { STRING_COMMA_LEN ("_pei386_runtime_relocator") },
  { STRING_COMMA_LEN ("do_pseudo_reloc") },
  /* Global vars that should not be exported.  */
  { STRING_COMMA_LEN ("impure_ptr") },
  { STRING_COMMA_LEN ("_impure_ptr") },
  { STRING_COMMA_LEN ("_fmode") },
  { STRING_COMMA_LEN ("environ") },
  { NULL, 0 }
};

#define PE_ARCH_i386	 1
#define PE_ARCH_sh	 2
#define PE_ARCH_mips	 3
#define PE_ARCH_arm	 4
#define PE_ARCH_arm_epoc 5
#define PE_ARCH_arm_wince 6

/* Don't make it constant as underscore mode gets possibly overriden
   by target or -(no-)leading-underscore option.  */
static pe_details_type pe_detail_list[] =
{
  {
#ifdef pe_use_x86_64
    "pei-x86-64",
    "pe-x86-64",
    3 /* R_IMAGEBASE */,
#else
    "pei-i386",
    "pe-i386",
    7 /* R_IMAGEBASE */,
#endif
    PE_ARCH_i386,
    bfd_arch_i386,
#ifdef pe_use_x86_64
    FALSE,
#else
    TRUE,
#endif
    autofilter_symbollist_i386
  },
  {
    "pei-shl",
    "pe-shl",
    16 /* R_SH_IMAGEBASE */,
    PE_ARCH_sh,
    bfd_arch_sh,
    TRUE,
    autofilter_symbollist_generic
  },
  {
    "pei-mips",
    "pe-mips",
    34 /* MIPS_R_RVA */,
    PE_ARCH_mips,
    bfd_arch_mips,
    FALSE,
    autofilter_symbollist_generic
  },
  {
    "pei-arm-little",
    "pe-arm-little",
    11 /* ARM_RVA32 */,
    PE_ARCH_arm,
    bfd_arch_arm,
    TRUE,
    autofilter_symbollist_generic
  },
  {
    "epoc-pei-arm-little",
    "epoc-pe-arm-little",
    11 /* ARM_RVA32 */,
    PE_ARCH_arm_epoc,
    bfd_arch_arm,
    FALSE,
    autofilter_symbollist_generic
  },
  {
    "pei-arm-wince-little",
    "pe-arm-wince-little",
    2,  /* ARM_RVA32 on Windows CE, see bfd/coff-arm.c.  */
    PE_ARCH_arm_wince,
    bfd_arch_arm,
    FALSE,
    autofilter_symbollist_generic
  },
  { NULL, NULL, 0, 0, 0, FALSE, NULL }
};

static const pe_details_type *pe_details;

/* Do not specify library suffix explicitly, to allow for dllized versions.  */
static const autofilter_entry_type autofilter_liblist[] =
{
  { STRING_COMMA_LEN ("libcegcc") },
  { STRING_COMMA_LEN ("libcygwin") },
  { STRING_COMMA_LEN ("libgcc") },
  { STRING_COMMA_LEN ("libgcc_s") },
  { STRING_COMMA_LEN ("libstdc++") },
  { STRING_COMMA_LEN ("libmingw32") },
  { STRING_COMMA_LEN ("libmingwex") },
  { STRING_COMMA_LEN ("libg2c") },
  { STRING_COMMA_LEN ("libsupc++") },
  { STRING_COMMA_LEN ("libobjc") },
  { STRING_COMMA_LEN ("libgcj") },
  { NULL, 0 }
};

/* Regardless of the suffix issue mentioned above, we must ensure that
  we do not falsely match on a leading substring, such as when libtool
  builds libstdc++ as a DLL using libsupc++convenience.a as an intermediate.
  This routine ensures that the leading part of the name matches and that
  it is followed by only an optional version suffix and a file extension,
  returning zero if so or -1 if not.  */
static int libnamencmp (const char *libname, const autofilter_entry_type *afptr)
{
  if (filename_ncmp (libname, afptr->name, afptr->len))
    return -1;

  libname += afptr->len;

  /* Be liberal in interpreting what counts as a version suffix; we
    accept anything that has a dash to separate it from the name and
    begins with a digit.  */
  if (libname[0] == '-')
    {
      if (!ISDIGIT (*++libname))
	return -1;
      /* Ensure the filename has an extension.  */
      while (*++libname != '.')
	if (!*libname)
	  return -1;
    }
  else if (libname[0] != '.')
    return -1;

  return 0;
}

static const autofilter_entry_type autofilter_objlist[] =
{
  { STRING_COMMA_LEN ("crt0.o") },
  { STRING_COMMA_LEN ("crt1.o") },
  { STRING_COMMA_LEN ("crt2.o") },
  { STRING_COMMA_LEN ("dllcrt1.o") },
  { STRING_COMMA_LEN ("dllcrt2.o") },
  { STRING_COMMA_LEN ("gcrt0.o") },
  { STRING_COMMA_LEN ("gcrt1.o") },
  { STRING_COMMA_LEN ("gcrt2.o") },
  { STRING_COMMA_LEN ("crtbegin.o") },
  { STRING_COMMA_LEN ("crtend.o") },
  { NULL, 0 }
};

static const autofilter_entry_type autofilter_symbolprefixlist[] =
{
  /* _imp_ is treated specially, as it is always underscored.  */
  /* { STRING_COMMA_LEN ("_imp_") },  */
  /* Don't export some c++ symbols.  */
  { STRING_COMMA_LEN ("__rtti_") },
  { STRING_COMMA_LEN ("__builtin_") },
  /* Don't re-export auto-imported symbols.  */
  { STRING_COMMA_LEN ("__nm_") },
  /* Don't export symbols specifying internal DLL layout.  */
  { STRING_COMMA_LEN ("_head_") },
  { STRING_COMMA_LEN ("_IMPORT_DESCRIPTOR_") },
  /* Don't export section labels or artificial symbols
  (eg ".weak.foo".  */
  { STRING_COMMA_LEN (".") },
  { NULL, 0 }
};

static const autofilter_entry_type autofilter_symbolsuffixlist[] =
{
  { STRING_COMMA_LEN ("_iname") },
  { STRING_COMMA_LEN ("_NULL_THUNK_DATA") },
  { NULL, 0 }
};

#define U(str) (pe_details->underscored ? "_" str : str)

void
pe_dll_id_target (const char *target)
{
  int i;

  for (i = 0; pe_detail_list[i].target_name; i++)
    if (strcmp (pe_detail_list[i].target_name, target) == 0
	|| strcmp (pe_detail_list[i].object_target, target) == 0)
      {
	int u = pe_leading_underscore; /* Underscoring mode. -1 for use default.  */
	if (u == -1)
	  bfd_get_target_info (target, NULL, NULL, &u, NULL);
	if (u == -1)
	  abort ();
	pe_detail_list[i].underscored = (u != 0 ? TRUE : FALSE);
	pe_details = pe_detail_list + i;
	pe_leading_underscore = (u != 0 ? 1 : 0);
	return;
      }
  einfo (_("%XUnsupported PEI architecture: %s\n"), target);
  exit (1);
}

/* Helper functions for qsort.  Relocs must be sorted so that we can write
   them out by pages.  */

typedef struct
  {
    bfd_vma vma;
    char type;
    short extra;
  }
reloc_data_type;

static int
reloc_sort (const void *va, const void *vb)
{
  bfd_vma a = ((const reloc_data_type *) va)->vma;
  bfd_vma b = ((const reloc_data_type *) vb)->vma;

  return (a > b) ? 1 : ((a < b) ? -1 : 0);
}

static int
pe_export_sort (const void *va, const void *vb)
{
  const def_file_export *a = va;
  const def_file_export *b = vb;
  char *an = a->name;
  char *bn = b->name;
  if (a->its_name)
    an = a->its_name;
  if (b->its_name)
    bn = b->its_name;

  return strcmp (an, bn);
}

/* Read and process the .DEF file.  */

/* These correspond to the entries in pe_def_file->exports[].  I use
   exported_symbol_sections[i] to tag whether or not the symbol was
   defined, since we can't export symbols we don't have.  */

static bfd_vma *exported_symbol_offsets;
static struct bfd_section **exported_symbol_sections;
static int export_table_size;
static int count_exported;
static int count_exported_byname;
static int count_with_ordinals;
static const char *dll_name;
static int min_ordinal, max_ordinal;
static int *exported_symbols;

typedef struct exclude_list_struct
  {
    char *string;
    struct exclude_list_struct *next;
    exclude_type type;
  }
exclude_list_struct;

static struct exclude_list_struct *excludes = 0;

void
pe_dll_add_excludes (const char *new_excludes, const exclude_type type)
{
  char *local_copy;
  char *exclude_string;

  local_copy = xstrdup (new_excludes);

  exclude_string = strtok (local_copy, ",:");
  for (; exclude_string; exclude_string = strtok (NULL, ",:"))
    {
      struct exclude_list_struct *new_exclude;

      new_exclude = xmalloc (sizeof (struct exclude_list_struct));
      new_exclude->string = xmalloc (strlen (exclude_string) + 1);
      strcpy (new_exclude->string, exclude_string);
      new_exclude->type = type;
      new_exclude->next = excludes;
      excludes = new_exclude;
    }

  free (local_copy);
}

static bfd_boolean
is_import (const char* n)
{
  return (CONST_STRNEQ (n, "__imp_"));
}

/* abfd is a bfd containing n (or NULL)
   It can be used for contextual checks.  */

static int
auto_export (bfd *abfd, def_file *d, const char *n)
{
  def_file_export key;
  struct exclude_list_struct *ex;
  const autofilter_entry_type *afptr;
  const char * libname = NULL;

  if (abfd && abfd->my_archive)
    libname = lbasename (abfd->my_archive->filename);

  key.name = key.its_name = (char *) n;

  /* Return false if n is in the d->exports table.  */
  if (bsearch (&key, d->exports, d->num_exports,
               sizeof (pe_def_file->exports[0]), pe_export_sort))
    return 0;

  if (pe_dll_do_default_excludes)
    {
      const char * p;
      int    len;

      if (pe_dll_extra_pe_debug)
	printf ("considering exporting: %s, abfd=%p, abfd->my_arc=%p\n",
		n, abfd, abfd->my_archive);

      /* First of all, make context checks:
	 Don't export anything from standard libs.  */
      if (libname)
	{
	  afptr = autofilter_liblist;

	  while (afptr->name)
	    {
	      if (libnamencmp (libname, afptr) == 0 )
		return 0;
	      afptr++;
	    }
	}

      /* Next, exclude symbols from certain startup objects.  */

      if (abfd && (p = lbasename (abfd->filename)))
	{
	  afptr = autofilter_objlist;
	  while (afptr->name)
	    {
	      if (strcmp (p, afptr->name) == 0)
		return 0;
	      afptr++;
	    }
	}

      /* Don't try to blindly exclude all symbols
	 that begin with '__'; this was tried and
	 it is too restrictive.  Instead we have
	 a target specific list to use:  */
      afptr = pe_details->autofilter_symbollist;

      while (afptr->name)
	{
	  if (strcmp (n, afptr->name) == 0)
	    return 0;

	  afptr++;
	}

      /* Next, exclude symbols starting with ...  */
      afptr = autofilter_symbolprefixlist;
      while (afptr->name)
	{
	  if (strncmp (n, afptr->name, afptr->len) == 0)
	    return 0;

	  afptr++;
	}

      /* Finally, exclude symbols ending with ...  */
      len = strlen (n);
      afptr = autofilter_symbolsuffixlist;
      while (afptr->name)
	{
	  if ((len >= afptr->len)
	      /* Add 1 to insure match with trailing '\0'.  */
	      && strncmp (n + len - afptr->len, afptr->name,
			  afptr->len + 1) == 0)
	    return 0;

	  afptr++;
	}
    }

  for (ex = excludes; ex; ex = ex->next)
    {
      if (ex->type == EXCLUDELIBS)
	{
	  if (libname
	      && ((filename_cmp (libname, ex->string) == 0)
		   || (strcasecmp ("ALL", ex->string) == 0)))
	    return 0;
	}
      else if (ex->type == EXCLUDEFORIMPLIB)
	{
	  if (filename_cmp (abfd->filename, ex->string) == 0)
	    return 0;
	}
      else if (strcmp (n, ex->string) == 0)
	return 0;
    }

  return 1;
}

static void
process_def_file_and_drectve (bfd *abfd ATTRIBUTE_UNUSED, struct bfd_link_info *info)
{
  int i, j;
  struct bfd_link_hash_entry *blhe;
  bfd *b;
  struct bfd_section *s;
  def_file_export *e = 0;
  bfd_boolean resort_needed;

  if (!pe_def_file)
    pe_def_file = def_file_empty ();

  /* First, run around to all the objects looking for the .drectve
     sections, and push those into the def file too.  */
  for (b = info->input_bfds; b; b = b->link_next)
    {
      s = bfd_get_section_by_name (b, ".drectve");
      if (s)
	{
	  long size = s->size;
	  char *buf = xmalloc (size);

	  bfd_get_section_contents (b, s, buf, 0, size);
	  def_file_add_directive (pe_def_file, buf, size);
	  free (buf);
	}
    }

  /* Process aligned common symbol information from the
     .drectve sections now; common symbol allocation is
     done before final link, so it will be too late to
     process them in process_embedded_commands() called
     from _bfd_coff_link_input_bfd().  */
  if (pe_def_file->aligncomms)
    {
      def_file_aligncomm *ac = pe_def_file->aligncomms;
      while (ac)
	{
	  struct coff_link_hash_entry *sym_hash;
	  sym_hash = coff_link_hash_lookup (coff_hash_table (info),
		ac->symbol_name, FALSE, FALSE, FALSE);
	  if (sym_hash && sym_hash->root.type == bfd_link_hash_common
	    && sym_hash->root.u.c.p->alignment_power < (unsigned) ac->alignment)
	    {
	      sym_hash->root.u.c.p->alignment_power = (unsigned) ac->alignment;
	    }
	  ac = ac->next;
	}
    }

  /* If we are building an executable and there is nothing
     to export, we do not build an export table at all.  */
  if (info->executable && pe_def_file->num_exports == 0
      && (!pe_dll_export_everything || pe_dll_exclude_all_symbols))
    return;

  /* Now, maybe export everything else the default way.  */
  if ((pe_dll_export_everything || pe_def_file->num_exports == 0)
      && !pe_dll_exclude_all_symbols)
    {
      for (b = info->input_bfds; b; b = b->link_next)
	{
	  asymbol **symbols;
	  int nsyms;

	  if (!bfd_generic_link_read_symbols (b))
	    {
	      einfo (_("%B%F: could not read symbols: %E\n"), b);
	      return;
	    }

	  symbols = bfd_get_outsymbols (b);
	  nsyms = bfd_get_symcount (b);

	  for (j = 0; j < nsyms; j++)
	    {
	      /* We should export symbols which are either global or not
		 anything at all.  (.bss data is the latter)
		 We should not export undefined symbols.  */
	      bfd_boolean would_export
		= (symbols[j]->section != bfd_und_section_ptr
		   && ((symbols[j]->flags & BSF_GLOBAL)
		       || (symbols[j]->flags == 0)));
	      if (link_info.version_info && would_export)
		  would_export
		    = !bfd_hide_sym_by_version (link_info.version_info,
						symbols[j]->name);
	      if (would_export)
		{
		  const char *sn = symbols[j]->name;

		  /* We should not re-export imported stuff.  */
		  {
		    char *name;
		    if (is_import (sn))
			  continue;

		    name = xmalloc (strlen ("__imp_") + strlen (sn) + 1);
		    sprintf (name, "%s%s", "__imp_", sn);

		    blhe = bfd_link_hash_lookup (info->hash, name,
						 FALSE, FALSE, FALSE);
		    free (name);

		    if (blhe && blhe->type == bfd_link_hash_defined)
		      continue;
		  }

		  if (pe_details->underscored && *sn == '_')
		    sn++;

		  if (auto_export (b, pe_def_file, sn))
		    {
		      int is_dup = 0;
		      def_file_export *p;

		      p = def_file_add_export (pe_def_file, sn, 0, -1,
					       NULL, &is_dup);
		      /* Fill data flag properly, from dlltool.c.  */
		      if (!is_dup)
		        p->flag_data = !(symbols[j]->flags & BSF_FUNCTION);
		    }
		}
	    }
	}
    }

#undef NE
#define NE pe_def_file->num_exports

  /* Don't create an empty export table.  */
  if (NE == 0)
    return;

  resort_needed = FALSE;

  /* Canonicalize the export list.  */
  if (pe_dll_kill_ats)
    {
      for (i = 0; i < NE; i++)
	{
	  /* Check for fastcall/stdcall-decoration, but ignore
	     C++ mangled names.  */
	  if (pe_def_file->exports[i].name[0] != '?'
	      && strchr (pe_def_file->exports[i].name, '@@'))
	    {
	      /* This will preserve internal_name, which may have been
		 pointing to the same memory as name, or might not
		 have.  */
	      int lead_at = (*pe_def_file->exports[i].name == '@@');
	      char *tmp = xstrdup (pe_def_file->exports[i].name + lead_at);
	      char *tmp_at = strrchr (tmp, '@@');

	      if (tmp_at)
	        *tmp_at = 0;
	      else
	        einfo (_("%XCannot export %s: invalid export name\n"),
		       pe_def_file->exports[i].name);
	      pe_def_file->exports[i].name = tmp;
              resort_needed = TRUE;
	    }
	}
    }

  /* Re-sort the exports table as we have possibly changed the order
     by removing leading @@.  */
  if (resort_needed)
    qsort (pe_def_file->exports, NE, sizeof (pe_def_file->exports[0]),
           pe_export_sort);

  if (pe_dll_stdcall_aliases)
    {
      for (i = 0; i < NE; i++)
	{
	  if (is_import (pe_def_file->exports[i].name))
	    continue;

	  if (strchr (pe_def_file->exports[i].name, '@@'))
	    {
	      int is_dup = 1;
	      int lead_at = (*pe_def_file->exports[i].name == '@@');
	      char *tmp = xstrdup (pe_def_file->exports[i].name + lead_at);

	      *(strchr (tmp, '@@')) = 0;
	      if (auto_export (NULL, pe_def_file, tmp))
		def_file_add_export (pe_def_file, tmp,
				     pe_def_file->exports[i].internal_name,
				     -1, NULL, &is_dup);
	      if (is_dup)
	        free (tmp);
	    }
	}
    }

  /* Convenience, but watch out for it changing.  */
  e = pe_def_file->exports;

  for (i = 0, j = 0; i < NE; i++)
    {
      if (i > 0 && strcmp (e[i].name, e[i - 1].name) == 0)
	{
	  /* This is a duplicate.  */
	  if (e[j - 1].ordinal != -1
	      && e[i].ordinal != -1
	      && e[j - 1].ordinal != e[i].ordinal)
	    {
	      if (pe_dll_warn_dup_exports)
		/* xgettext:c-format */
		einfo (_("%XError, duplicate EXPORT with ordinals: %s (%d vs %d)\n"),
		       e[j - 1].name, e[j - 1].ordinal, e[i].ordinal);
	    }
	  else
	    {
	      if (pe_dll_warn_dup_exports)
		/* xgettext:c-format */
		einfo (_("Warning, duplicate EXPORT: %s\n"),
		       e[j - 1].name);
	    }

	  if (e[i].ordinal != -1)
	    e[j - 1].ordinal = e[i].ordinal;
	  e[j - 1].flag_private |= e[i].flag_private;
	  e[j - 1].flag_constant |= e[i].flag_constant;
	  e[j - 1].flag_noname |= e[i].flag_noname;
	  e[j - 1].flag_data |= e[i].flag_data;
	  if (e[i].name)
	    free (e[i].name);
	  if (e[i].internal_name)
	    free (e[i].internal_name);
	  if (e[i].its_name)
	    free (e[i].its_name);
	}
      else
	{
	  if (i != j)
	    e[j] = e[i];
	  j++;
	}
    }
  pe_def_file->num_exports = j;	/* == NE */

  exported_symbol_offsets = xmalloc (NE * sizeof (bfd_vma));
  exported_symbol_sections = xmalloc (NE * sizeof (struct bfd_section *));

  memset (exported_symbol_sections, 0, NE * sizeof (struct bfd_section *));
  max_ordinal = 0;
  min_ordinal = 65536;
  count_exported = 0;
  count_exported_byname = 0;
  count_with_ordinals = 0;

  for (i = 0; i < NE; i++)
    {
      char *name;
      name = xmalloc (strlen (pe_def_file->exports[i].internal_name) + 2);
      if (pe_details->underscored
 	  && (*pe_def_file->exports[i].internal_name != '@@'))
	{
	  *name = '_';
	  strcpy (name + 1, pe_def_file->exports[i].internal_name);
	}
      else
	strcpy (name, pe_def_file->exports[i].internal_name);

      blhe = bfd_link_hash_lookup (info->hash,
				   name,
				   FALSE, FALSE, TRUE);

      if (blhe
	  && (blhe->type == bfd_link_hash_defined
	      || (blhe->type == bfd_link_hash_common)))
	{
	  count_exported++;
	  if (!pe_def_file->exports[i].flag_noname)
	    count_exported_byname++;

	  /* Only fill in the sections. The actual offsets are computed
	     in fill_exported_offsets() after common symbols are laid
	     out.  */
	  if (blhe->type == bfd_link_hash_defined)
	    exported_symbol_sections[i] = blhe->u.def.section;
	  else
	    exported_symbol_sections[i] = blhe->u.c.p->section;

	  if (pe_def_file->exports[i].ordinal != -1)
	    {
	      if (max_ordinal < pe_def_file->exports[i].ordinal)
		max_ordinal = pe_def_file->exports[i].ordinal;
	      if (min_ordinal > pe_def_file->exports[i].ordinal)
		min_ordinal = pe_def_file->exports[i].ordinal;
	      count_with_ordinals++;
	    }
	}
      /* Check for forward exports.  These are indicated in DEF files by an
         export directive of the form NAME1 = MODULE-NAME.EXTERNAL-NAME
	 but we must take care not to be fooled when the user wants to export
	 a symbol that actually really has a dot in it, so we only check
	 for them here, after real defined symbols have already been matched.  */
      else if (strchr (pe_def_file->exports[i].internal_name, '.'))
	{
	  count_exported++;
	  if (!pe_def_file->exports[i].flag_noname)
	    count_exported_byname++;

	  pe_def_file->exports[i].flag_forward = 1;

	  if (pe_def_file->exports[i].ordinal != -1)
	    {
	      if (max_ordinal < pe_def_file->exports[i].ordinal)
		max_ordinal = pe_def_file->exports[i].ordinal;
	      if (min_ordinal > pe_def_file->exports[i].ordinal)
		min_ordinal = pe_def_file->exports[i].ordinal;
	      count_with_ordinals++;
	    }
	}
      else if (blhe && blhe->type == bfd_link_hash_undefined)
	{
	  /* xgettext:c-format */
	  einfo (_("%XCannot export %s: symbol not defined\n"),
		 pe_def_file->exports[i].internal_name);
	}
      else if (blhe)
	{
	  /* xgettext:c-format */
	  einfo (_("%XCannot export %s: symbol wrong type (%d vs %d)\n"),
		 pe_def_file->exports[i].internal_name,
		 blhe->type, bfd_link_hash_defined);
	}
      else
	{
	  /* xgettext:c-format */
	  einfo (_("%XCannot export %s: symbol not found\n"),
		 pe_def_file->exports[i].internal_name);
	}
      free (name);
    }
}

/* Build the bfd that will contain .edata and .reloc sections.  */

static void
build_filler_bfd (int include_edata)
{
  lang_input_statement_type *filler_file;
  filler_file = lang_add_input_file ("dll stuff",
				     lang_input_file_is_fake_enum,
				     NULL);
  filler_file->the_bfd = filler_bfd = bfd_create ("dll stuff",
						  link_info.output_bfd);
  if (filler_bfd == NULL
      || !bfd_set_arch_mach (filler_bfd,
			     bfd_get_arch (link_info.output_bfd),
			     bfd_get_mach (link_info.output_bfd)))
    {
      einfo ("%X%P: can not create BFD: %E\n");
      return;
    }

  if (include_edata)
    {
      edata_s = bfd_make_section_old_way (filler_bfd, ".edata");
      if (edata_s == NULL
	  || !bfd_set_section_flags (filler_bfd, edata_s,
				     (SEC_HAS_CONTENTS
				      | SEC_ALLOC
				      | SEC_LOAD
				      | SEC_KEEP
				      | SEC_IN_MEMORY)))
	{
	  einfo ("%X%P: can not create .edata section: %E\n");
	  return;
	}
      bfd_set_section_size (filler_bfd, edata_s, edata_sz);
    }

  reloc_s = bfd_make_section_old_way (filler_bfd, ".reloc");
  if (reloc_s == NULL
      || !bfd_set_section_flags (filler_bfd, reloc_s,
				 (SEC_HAS_CONTENTS
				  | SEC_ALLOC
				  | SEC_LOAD
				  | SEC_KEEP
				  | SEC_IN_MEMORY)))
    {
      einfo ("%X%P: can not create .reloc section: %E\n");
      return;
    }

  bfd_set_section_size (filler_bfd, reloc_s, 0);

  ldlang_add_file (filler_file);
}

/* Gather all the exported symbols and build the .edata section.  */

static void
generate_edata (bfd *abfd, struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  int i, next_ordinal;
  int name_table_size = 0;
  const char *dlnp;

  /* First, we need to know how many exported symbols there are,
     and what the range of ordinals is.  */
  if (pe_def_file->name)
    dll_name = pe_def_file->name;
  else
    {
      dll_name = abfd->filename;

      for (dlnp = dll_name; *dlnp; dlnp++)
	if (*dlnp == '\\' || *dlnp == '/' || *dlnp == ':')
	  dll_name = dlnp + 1;
    }

  if (count_with_ordinals && max_ordinal > count_exported)
    {
      if (min_ordinal > max_ordinal - count_exported + 1)
	min_ordinal = max_ordinal - count_exported + 1;
    }
  else
    {
      min_ordinal = 1;
      max_ordinal = count_exported;
    }

  export_table_size = max_ordinal - min_ordinal + 1;
  exported_symbols = xmalloc (export_table_size * sizeof (int));
  for (i = 0; i < export_table_size; i++)
    exported_symbols[i] = -1;

  /* Now we need to assign ordinals to those that don't have them.  */
  for (i = 0; i < NE; i++)
    {
      if (exported_symbol_sections[i] ||
          pe_def_file->exports[i].flag_forward)
	{
	  if (pe_def_file->exports[i].ordinal != -1)
	    {
	      int ei = pe_def_file->exports[i].ordinal - min_ordinal;
	      int pi = exported_symbols[ei];

	      if (pi != -1)
		{
		  /* xgettext:c-format */
		  einfo (_("%XError, ordinal used twice: %d (%s vs %s)\n"),
			 pe_def_file->exports[i].ordinal,
			 pe_def_file->exports[i].name,
			 pe_def_file->exports[pi].name);
		}
	      exported_symbols[ei] = i;
	    }
	  if (pe_def_file->exports[i].its_name)
	    name_table_size += strlen (pe_def_file->exports[i].its_name) + 1;
	  else
	    name_table_size += strlen (pe_def_file->exports[i].name) + 1;
	}

      /* Reserve space for the forward name. */
      if (pe_def_file->exports[i].flag_forward)
	{
	  name_table_size += strlen (pe_def_file->exports[i].internal_name) + 1;
	}
    }

  next_ordinal = min_ordinal;
  for (i = 0; i < NE; i++)
    if ((exported_symbol_sections[i] ||
         pe_def_file->exports[i].flag_forward) &&
        pe_def_file->exports[i].ordinal == -1)
      {
	while (exported_symbols[next_ordinal - min_ordinal] != -1)
	  next_ordinal++;

	exported_symbols[next_ordinal - min_ordinal] = i;
	pe_def_file->exports[i].ordinal = next_ordinal;
      }

  /* OK, now we can allocate some memory.  */
  edata_sz = (40				/* directory */
	      + 4 * export_table_size		/* addresses */
	      + 4 * count_exported_byname	/* name ptrs */
	      + 2 * count_exported_byname	/* ordinals */
	      + name_table_size + strlen (dll_name) + 1);
}

/* Fill the exported symbol offsets. The preliminary work has already
   been done in process_def_file_and_drectve().  */

static void
fill_exported_offsets (bfd *abfd ATTRIBUTE_UNUSED, struct bfd_link_info *info)
{
  int i;
  struct bfd_link_hash_entry *blhe;

  for (i = 0; i < pe_def_file->num_exports; i++)
    {
      char *name;

      name = xmalloc (strlen (pe_def_file->exports[i].internal_name) + 2);
      if (pe_details->underscored
 	  && *pe_def_file->exports[i].internal_name != '@@')
	{
	  *name = '_';
	  strcpy (name + 1, pe_def_file->exports[i].internal_name);
	}
      else
	strcpy (name, pe_def_file->exports[i].internal_name);

      blhe = bfd_link_hash_lookup (info->hash,
				   name,
				   FALSE, FALSE, TRUE);

      if (blhe && blhe->type == bfd_link_hash_defined)
	exported_symbol_offsets[i] = blhe->u.def.value;

      free (name);
    }
}

static void
fill_edata (bfd *abfd, struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  int s, hint;
  unsigned char *edirectory;
  unsigned char *eaddresses;
  unsigned char *enameptrs;
  unsigned char *eordinals;
  char *enamestr;
  time_t now;

  time (&now);

  edata_d = xmalloc (edata_sz);

  /* Note use of array pointer math here.  */
  edirectory = edata_d;
  eaddresses = edirectory + 40;
  enameptrs = eaddresses + 4 * export_table_size;
  eordinals = enameptrs + 4 * count_exported_byname;
  enamestr = (char *) eordinals + 2 * count_exported_byname;

#define ERVA(ptr) (((unsigned char *)(ptr) - edata_d) \
		   + edata_s->output_section->vma - image_base)

  memset (edata_d, 0, edata_sz);
  bfd_put_32 (abfd, now, edata_d + 4);
  if (pe_def_file->version_major != -1)
    {
      bfd_put_16 (abfd, pe_def_file->version_major, edata_d + 8);
      bfd_put_16 (abfd, pe_def_file->version_minor, edata_d + 10);
    }

  bfd_put_32 (abfd, ERVA (enamestr), edata_d + 12);
  strcpy (enamestr, dll_name);
  enamestr += strlen (enamestr) + 1;
  bfd_put_32 (abfd, min_ordinal, edata_d + 16);
  bfd_put_32 (abfd, export_table_size, edata_d + 20);
  bfd_put_32 (abfd, count_exported_byname, edata_d + 24);
  bfd_put_32 (abfd, ERVA (eaddresses), edata_d + 28);
  bfd_put_32 (abfd, ERVA (enameptrs), edata_d + 32);
  bfd_put_32 (abfd, ERVA (eordinals), edata_d + 36);

  fill_exported_offsets (abfd, info);

  /* Ok, now for the filling in part.
     Scan alphabetically - ie the ordering in the exports[] table,
     rather than by ordinal - the ordering in the exported_symbol[]
     table.  See dlltool.c and:
        http://sources.redhat.com/ml/binutils/2003-04/msg00379.html
     for more information.  */
  hint = 0;
  for (s = 0; s < NE; s++)
    {
      struct bfd_section *ssec = exported_symbol_sections[s];
      if (pe_def_file->exports[s].ordinal != -1 &&
          (pe_def_file->exports[s].flag_forward || ssec != NULL))
	{
	  int ord = pe_def_file->exports[s].ordinal;

	  if (pe_def_file->exports[s].flag_forward)
	    {
	      bfd_put_32 (abfd, ERVA (enamestr),
		          eaddresses + 4 * (ord - min_ordinal));

	      strcpy (enamestr, pe_def_file->exports[s].internal_name);
	      enamestr += strlen (pe_def_file->exports[s].internal_name) + 1;
	    }
	  else
	    {
	      bfd_vma srva = (exported_symbol_offsets[s]
				    + ssec->output_section->vma
				    + ssec->output_offset);

	      bfd_put_32 (abfd, srva - image_base,
		          eaddresses + 4 * (ord - min_ordinal));
	    }

	  if (!pe_def_file->exports[s].flag_noname)
	    {
	      char *ename = pe_def_file->exports[s].name;
	      if (pe_def_file->exports[s].its_name)
		ename = pe_def_file->exports[s].its_name;

	      bfd_put_32 (abfd, ERVA (enamestr), enameptrs);
	      enameptrs += 4;
	      strcpy (enamestr, ename);
	      enamestr += strlen (enamestr) + 1;
	      bfd_put_16 (abfd, ord - min_ordinal, eordinals);
	      eordinals += 2;
	      pe_def_file->exports[s].hint = hint++;
	    }
	}
    }
}


static struct bfd_section *current_sec;

void
pe_walk_relocs_of_symbol (struct bfd_link_info *info,
			  const char *name,
			  int (*cb) (arelent *, asection *))
{
  bfd *b;
  asection *s;

  for (b = info->input_bfds; b; b = b->link_next)
    {
      asymbol **symbols;

      if (!bfd_generic_link_read_symbols (b))
	{
	  einfo (_("%B%F: could not read symbols: %E\n"), b);
	  return;
	}

      symbols = bfd_get_outsymbols (b);

      for (s = b->sections; s; s = s->next)
	{
	  arelent **relocs;
	  int relsize, nrelocs, i;
	  int flags = bfd_get_section_flags (b, s);

	  /* Skip discarded linkonce sections.  */
	  if (flags & SEC_LINK_ONCE
	      && s->output_section == bfd_abs_section_ptr)
	    continue;

	  current_sec = s;

	  relsize = bfd_get_reloc_upper_bound (b, s);
	  relocs = xmalloc (relsize);
	  nrelocs = bfd_canonicalize_reloc (b, s, relocs, symbols);

	  for (i = 0; i < nrelocs; i++)
	    {
	      struct bfd_symbol *sym = *relocs[i]->sym_ptr_ptr;

	      if (!strcmp (name, sym->name))
		cb (relocs[i], s);
	    }

	  free (relocs);

	  /* Warning: the allocated symbols are remembered in BFD and reused
	     later, so don't free them! */
	  /* free (symbols); */
	}
    }
}

/* Gather all the relocations and build the .reloc section.  */

static void
generate_reloc (bfd *abfd, struct bfd_link_info *info)
{

  /* For .reloc stuff.  */
  reloc_data_type *reloc_data;
  int total_relocs = 0;
  int i;
  bfd_vma sec_page = (bfd_vma) -1;
  bfd_vma page_ptr, page_count;
  int bi;
  bfd *b;
  struct bfd_section *s;

  total_relocs = 0;
  for (b = info->input_bfds; b; b = b->link_next)
    for (s = b->sections; s; s = s->next)
      total_relocs += s->reloc_count;

  reloc_data = xmalloc (total_relocs * sizeof (reloc_data_type));

  total_relocs = 0;
  bi = 0;
  for (bi = 0, b = info->input_bfds; b; bi++, b = b->link_next)
    {
      arelent **relocs;
      int relsize, nrelocs;

      for (s = b->sections; s; s = s->next)
	{
	  bfd_vma sec_vma = s->output_section->vma + s->output_offset;
	  asymbol **symbols;

	  /* If it's not loaded, we don't need to relocate it this way.  */
	  if (!(s->output_section->flags & SEC_LOAD))
	    continue;

	  /* I don't know why there would be a reloc for these, but I've
	     seen it happen - DJ  */
	  if (s->output_section == bfd_abs_section_ptr)
	    continue;

	  if (s->output_section->vma == 0)
	    {
	      /* Huh?  Shouldn't happen, but punt if it does.  */
	      einfo ("DJ: zero vma section reloc detected: `%s' #%d f=%d\n",
		     s->output_section->name, s->output_section->index,
		     s->output_section->flags);
	      continue;
	    }

	  if (!bfd_generic_link_read_symbols (b))
	    {
	      einfo (_("%B%F: could not read symbols: %E\n"), b);
	      return;
	    }

	  symbols = bfd_get_outsymbols (b);
	  relsize = bfd_get_reloc_upper_bound (b, s);
	  relocs = xmalloc (relsize);
	  nrelocs = bfd_canonicalize_reloc (b, s, relocs, symbols);

	  for (i = 0; i < nrelocs; i++)
	    {
	      if (pe_dll_extra_pe_debug)
		{
		  struct bfd_symbol *sym = *relocs[i]->sym_ptr_ptr;
		  printf ("rel: %s\n", sym->name);
		}
	      if (!relocs[i]->howto->pc_relative
		  && relocs[i]->howto->type != pe_details->imagebase_reloc)
		{
		  struct bfd_symbol *sym = *relocs[i]->sym_ptr_ptr;

		  /* Don't create relocs for undefined weak symbols.  */
		  if (sym->flags == BSF_WEAK)
		    {
		      struct bfd_link_hash_entry *blhe
			= bfd_wrapped_link_hash_lookup (abfd, info, sym->name,
						FALSE, FALSE, FALSE);
		      if (blhe && blhe->type == bfd_link_hash_undefweak)
			{
			  /* Check aux sym and see if it is defined or not. */
			  struct coff_link_hash_entry *h, *h2;
			  h = (struct coff_link_hash_entry *)blhe;
			  if (h->symbol_class != C_NT_WEAK || h->numaux != 1)
			    continue;
			  h2 = h->auxbfd->tdata.coff_obj_data->sym_hashes
						[h->aux->x_sym.x_tagndx.l];
			  /* We don't want a base reloc if the aux sym is not
			     found, undefined, or if it is the constant ABS
			     zero default value.  (We broaden that slightly by
			     not testing the value, just the section; there's
			     no reason we'd want a reference to any absolute
			     address to get relocated during rebasing).  */
			  if (!h2 || h2->root.type == bfd_link_hash_undefined
				|| h2->root.u.def.section == bfd_abs_section_ptr)
			    continue;
			}
		      else if (!blhe || blhe->type != bfd_link_hash_defined)
			continue;
		    }
		  /* Nor for Dwarf FDE references to discarded sections.  */
		  else if (bfd_is_abs_section (sym->section->output_section))
		    {
		      /* We only ignore relocs from .eh_frame sections, as
			 they are discarded by the final link rather than
			 resolved against the kept section.  */
		      if (!strcmp (s->name, ".eh_frame"))
			continue;
		    }

		  reloc_data[total_relocs].vma = sec_vma + relocs[i]->address;

#define BITS_AND_SHIFT(bits, shift) (bits * 1000 | shift)

		  switch BITS_AND_SHIFT (relocs[i]->howto->bitsize,
					 relocs[i]->howto->rightshift)
		    {
#ifdef pe_use_x86_64
		    case BITS_AND_SHIFT (64, 0):
		      reloc_data[total_relocs].type = 10;
		      total_relocs++;
		      break;
#endif
		    case BITS_AND_SHIFT (32, 0):
		      reloc_data[total_relocs].type = 3;
		      total_relocs++;
		      break;
		    case BITS_AND_SHIFT (16, 0):
		      reloc_data[total_relocs].type = 2;
		      total_relocs++;
		      break;
		    case BITS_AND_SHIFT (16, 16):
		      reloc_data[total_relocs].type = 4;
		      /* FIXME: we can't know the symbol's right value
			 yet, but we probably can safely assume that
			 CE will relocate us in 64k blocks, so leaving
			 it zero is safe.  */
		      reloc_data[total_relocs].extra = 0;
		      total_relocs++;
		      break;
		    case BITS_AND_SHIFT (26, 2):
		      reloc_data[total_relocs].type = 5;
		      total_relocs++;
		      break;
		    case BITS_AND_SHIFT (24, 2):
		      /* FIXME: 0 is ARM_26D, it is defined in bfd/coff-arm.c
			 Those ARM_xxx definitions should go in proper
			 header someday.  */
		      if (relocs[i]->howto->type == 0
			  /* Older GNU linkers used 5 instead of 0 for this reloc.  */
			  || relocs[i]->howto->type == 5)
			/* This is an ARM_26D reloc, which is an ARM_26 reloc
			   that has already been fully processed during a
			   previous link stage, so ignore it here.  */
			break;
		      /* Fall through.  */
		    default:
		      /* xgettext:c-format */
		      einfo (_("%XError: %d-bit reloc in dll\n"),
			     relocs[i]->howto->bitsize);
		      break;
		    }
		}
	    }
	  free (relocs);
	  /* Warning: the allocated symbols are remembered in BFD and
	     reused later, so don't free them!  */
	}
    }

  /* At this point, we have total_relocs relocation addresses in
     reloc_addresses, which are all suitable for the .reloc section.
     We must now create the new sections.  */
  qsort (reloc_data, total_relocs, sizeof (*reloc_data), reloc_sort);

  for (i = 0; i < total_relocs; i++)
    {
      bfd_vma this_page = (reloc_data[i].vma >> 12);

      if (this_page != sec_page)
	{
	  reloc_sz = (reloc_sz + 3) & ~3;	/* 4-byte align.  */
	  reloc_sz += 8;
	  sec_page = this_page;
	}

      reloc_sz += 2;

      if (reloc_data[i].type == 4)
	reloc_sz += 2;
    }

  reloc_sz = (reloc_sz + 3) & ~3;	/* 4-byte align.  */
  reloc_d = xmalloc (reloc_sz);
  sec_page = (bfd_vma) -1;
  reloc_sz = 0;
  page_ptr = (bfd_vma) -1;
  page_count = 0;

  for (i = 0; i < total_relocs; i++)
    {
      bfd_vma rva = reloc_data[i].vma - image_base;
      bfd_vma this_page = (rva & ~0xfff);

      if (this_page != sec_page)
	{
	  while (reloc_sz & 3)
	    reloc_d[reloc_sz++] = 0;

	  if (page_ptr != (bfd_vma) -1)
	    bfd_put_32 (abfd, reloc_sz - page_ptr, reloc_d + page_ptr + 4);

	  bfd_put_32 (abfd, this_page, reloc_d + reloc_sz);
	  page_ptr = reloc_sz;
	  reloc_sz += 8;
	  sec_page = this_page;
	  page_count = 0;
	}

      bfd_put_16 (abfd, (rva & 0xfff) + (reloc_data[i].type << 12),
		  reloc_d + reloc_sz);
      reloc_sz += 2;

      if (reloc_data[i].type == 4)
	{
	  bfd_put_16 (abfd, reloc_data[i].extra, reloc_d + reloc_sz);
	  reloc_sz += 2;
	}

      page_count++;
    }

  while (reloc_sz & 3)
    reloc_d[reloc_sz++] = 0;

  if (page_ptr != (bfd_vma) -1)
    bfd_put_32 (abfd, reloc_sz - page_ptr, reloc_d + page_ptr + 4);

  while (reloc_sz < reloc_s->size)
    reloc_d[reloc_sz++] = 0;
}

/* Given the exiting def_file structure, print out a .DEF file that
   corresponds to it.  */

static void
quoteput (char *s, FILE *f, int needs_quotes)
{
  char *cp;

  for (cp = s; *cp; cp++)
    if (*cp == '\''
	|| *cp == '"'
	|| *cp == '\\'
	|| ISSPACE (*cp)
	|| *cp == ','
	|| *cp == ';')
      needs_quotes = 1;

  if (needs_quotes)
    {
      putc ('"', f);

      while (*s)
	{
	  if (*s == '"' || *s == '\\')
	    putc ('\\', f);

	  putc (*s, f);
	  s++;
	}

      putc ('"', f);
    }
  else
    fputs (s, f);
}

void
pe_dll_generate_def_file (const char *pe_out_def_filename)
{
  int i;
  FILE *out = fopen (pe_out_def_filename, "w");

  if (out == NULL)
    /* xgettext:c-format */
    einfo (_("%s: Can't open output def file %s\n"),
	   program_name, pe_out_def_filename);

  if (pe_def_file)
    {
      if (pe_def_file->name)
	{
	  if (pe_def_file->is_dll)
	    fprintf (out, "LIBRARY ");
	  else
	    fprintf (out, "NAME ");

	  quoteput (pe_def_file->name, out, 1);

	  if (pe_data (link_info.output_bfd)->pe_opthdr.ImageBase)
	    {
	      fprintf (out, " BASE=0x");
	      fprintf_vma (out, ((bfd_vma) pe_data (link_info.output_bfd)->pe_opthdr.ImageBase));
	    }
	  fprintf (out, "\n");
	}

      if (pe_def_file->description)
	{
	  fprintf (out, "DESCRIPTION ");
	  quoteput (pe_def_file->description, out, 1);
	  fprintf (out, "\n");
	}

      if (pe_def_file->version_minor != -1)
	fprintf (out, "VERSION %d.%d\n", pe_def_file->version_major,
		 pe_def_file->version_minor);
      else if (pe_def_file->version_major != -1)
	fprintf (out, "VERSION %d\n", pe_def_file->version_major);

      if (pe_def_file->stack_reserve != -1 || pe_def_file->heap_reserve != -1)
	fprintf (out, "\n");

      if (pe_def_file->stack_commit != -1)
	fprintf (out, "STACKSIZE 0x%x,0x%x\n",
		 pe_def_file->stack_reserve, pe_def_file->stack_commit);
      else if (pe_def_file->stack_reserve != -1)
	fprintf (out, "STACKSIZE 0x%x\n", pe_def_file->stack_reserve);

      if (pe_def_file->heap_commit != -1)
	fprintf (out, "HEAPSIZE 0x%x,0x%x\n",
		 pe_def_file->heap_reserve, pe_def_file->heap_commit);
      else if (pe_def_file->heap_reserve != -1)
	fprintf (out, "HEAPSIZE 0x%x\n", pe_def_file->heap_reserve);

      if (pe_def_file->num_section_defs > 0)
	{
	  fprintf (out, "\nSECTIONS\n\n");

	  for (i = 0; i < pe_def_file->num_section_defs; i++)
	    {
	      fprintf (out, "    ");
	      quoteput (pe_def_file->section_defs[i].name, out, 0);

	      if (pe_def_file->section_defs[i].class)
		{
		  fprintf (out, " CLASS ");
		  quoteput (pe_def_file->section_defs[i].class, out, 0);
		}

	      if (pe_def_file->section_defs[i].flag_read)
		fprintf (out, " READ");

	      if (pe_def_file->section_defs[i].flag_write)
		fprintf (out, " WRITE");

	      if (pe_def_file->section_defs[i].flag_execute)
		fprintf (out, " EXECUTE");

	      if (pe_def_file->section_defs[i].flag_shared)
		fprintf (out, " SHARED");

	      fprintf (out, "\n");
	    }
	}

      if (pe_def_file->num_exports > 0)
	{
	  fprintf (out, "EXPORTS\n");

	  for (i = 0; i < pe_def_file->num_exports; i++)
	    {
	      def_file_export *e = pe_def_file->exports + i;
	      fprintf (out, "    ");
	      quoteput (e->name, out, 0);

	      if (e->internal_name && strcmp (e->internal_name, e->name))
		{
		  fprintf (out, " = ");
		  quoteput (e->internal_name, out, 0);
		}

	      if (e->ordinal != -1)
		fprintf (out, " @@%d", e->ordinal);

	      if (e->flag_private)
		fprintf (out, " PRIVATE");

	      if (e->flag_constant)
		fprintf (out, " CONSTANT");

	      if (e->flag_noname)
		fprintf (out, " NONAME");

	      if (e->flag_data)
		fprintf (out, " DATA");

	      fprintf (out, "\n");
	    }
	}

      if (pe_def_file->num_imports > 0)
	{
	  fprintf (out, "\nIMPORTS\n\n");

	  for (i = 0; i < pe_def_file->num_imports; i++)
	    {
	      def_file_import *im = pe_def_file->imports + i;
	      fprintf (out, "    ");

	      if (im->internal_name
		  && (!im->name || strcmp (im->internal_name, im->name)))
		{
		  quoteput (im->internal_name, out, 0);
		  fprintf (out, " = ");
		}

	      quoteput (im->module->name, out, 0);
	      fprintf (out, ".");

	      if (im->name)
		quoteput (im->name, out, 0);
	      else
		fprintf (out, "%d", im->ordinal);

	      if (im->its_name)
		{
		  fprintf (out, " == ");
		  quoteput (im->its_name, out, 0);
		}

	      fprintf (out, "\n");
	    }
	}
    }
  else
    fprintf (out, _("; no contents available\n"));

  if (fclose (out) == EOF)
    /* xgettext:c-format */
    einfo (_("%P: Error closing file `%s'\n"), pe_out_def_filename);
}

/* Generate the import library.  */

static asymbol **symtab;
static int symptr;
static int tmp_seq;
static int tmp_seq2;
static const char *dll_filename;
static char *dll_symname;

#define UNDSEC bfd_und_section_ptr

static asection *
quick_section (bfd *abfd, const char *name, int flags, int align)
{
  asection *sec;
  asymbol *sym;

  sec = bfd_make_section_old_way (abfd, name);
  bfd_set_section_flags (abfd, sec, flags | SEC_ALLOC | SEC_LOAD | SEC_KEEP);
  bfd_set_section_alignment (abfd, sec, align);
  /* Remember to undo this before trying to link internally!  */
  sec->output_section = sec;

  sym = bfd_make_empty_symbol (abfd);
  symtab[symptr++] = sym;
  sym->name = sec->name;
  sym->section = sec;
  sym->flags = BSF_LOCAL;
  sym->value = 0;

  return sec;
}

static void
quick_symbol (bfd *abfd,
	      const char *n1,
	      const char *n2,
	      const char *n3,
	      asection *sec,
	      int flags,
	      int addr)
{
  asymbol *sym;
  char *name = xmalloc (strlen (n1) + strlen (n2) + strlen (n3) + 1);

  strcpy (name, n1);
  strcat (name, n2);
  strcat (name, n3);
  sym = bfd_make_empty_symbol (abfd);
  sym->name = name;
  sym->section = sec;
  sym->flags = flags;
  sym->value = addr;
  symtab[symptr++] = sym;
}

static arelent *reltab = 0;
static int relcount = 0, relsize = 0;

static void
quick_reloc (bfd *abfd, bfd_size_type address, int which_howto, int symidx)
{
  if (relcount >= relsize - 1)
    {
      relsize += 10;
      if (reltab)
	reltab = xrealloc (reltab, relsize * sizeof (arelent));
      else
	reltab = xmalloc (relsize * sizeof (arelent));
    }
  reltab[relcount].address = address;
  reltab[relcount].addend = 0;
  reltab[relcount].howto = bfd_reloc_type_lookup (abfd, which_howto);
  reltab[relcount].sym_ptr_ptr = symtab + symidx;
  relcount++;
}

static void
save_relocs (asection *sec)
{
  int i;

  sec->relocation = reltab;
  sec->reloc_count = relcount;
  sec->orelocation = xmalloc ((relcount + 1) * sizeof (arelent *));
  for (i = 0; i < relcount; i++)
    sec->orelocation[i] = sec->relocation + i;
  sec->orelocation[relcount] = 0;
  sec->flags |= SEC_RELOC;
  reltab = 0;
  relcount = relsize = 0;
}

/*	.section	.idata$2
 	.global		__head_my_dll
   __head_my_dll:
 	.rva		hname
 	.long		0
 	.long		0
 	.rva		__my_dll_iname
 	.rva		fthunk

 	.section	.idata$5
 	.long		0
   fthunk:

 	.section	.idata$4
 	.long		0
   hname:                              */

static bfd *
make_head (bfd *parent)
{
  asection *id2, *id5, *id4;
  unsigned char *d2, *d5, *d4;
  char *oname;
  bfd *abfd;

  oname = xmalloc (20);
  sprintf (oname, "d%06d.o", tmp_seq);
  tmp_seq++;

  abfd = bfd_create (oname, parent);
  bfd_find_target (pe_details->object_target, abfd);
  bfd_make_writable (abfd);

  bfd_set_format (abfd, bfd_object);
  bfd_set_arch_mach (abfd, pe_details->bfd_arch, 0);

  symptr = 0;
  symtab = xmalloc (6 * sizeof (asymbol *));
  id2 = quick_section (abfd, ".idata$2", SEC_HAS_CONTENTS, 2);
  id5 = quick_section (abfd, ".idata$5", SEC_HAS_CONTENTS, 2);
  id4 = quick_section (abfd, ".idata$4", SEC_HAS_CONTENTS, 2);
  quick_symbol (abfd, U ("_head_"), dll_symname, "", id2, BSF_GLOBAL, 0);
  quick_symbol (abfd, U (""), dll_symname, "_iname", UNDSEC, BSF_GLOBAL, 0);

  /* OK, pay attention here.  I got confused myself looking back at
     it.  We create a four-byte section to mark the beginning of the
     list, and we include an offset of 4 in the section, so that the
     pointer to the list points to the *end* of this section, which is
     the start of the list of sections from other objects.  */

  bfd_set_section_size (abfd, id2, 20);
  d2 = xmalloc (20);
  id2->contents = d2;
  memset (d2, 0, 20);
  if (pe_use_nul_prefixed_import_tables)
    d2[0] = d2[16] = PE_IDATA5_SIZE; /* Reloc addend.  */
  quick_reloc (abfd,  0, BFD_RELOC_RVA, 2);
  quick_reloc (abfd, 12, BFD_RELOC_RVA, 4);
  quick_reloc (abfd, 16, BFD_RELOC_RVA, 1);
  save_relocs (id2);

  if (pe_use_nul_prefixed_import_tables)
    bfd_set_section_size (abfd, id5, PE_IDATA5_SIZE);
  else
    bfd_set_section_size (abfd, id5, 0);
  d5 = xmalloc (PE_IDATA5_SIZE);
  id5->contents = d5;
  memset (d5, 0, PE_IDATA5_SIZE);
  if (pe_use_nul_prefixed_import_tables)
    bfd_set_section_size (abfd, id4, PE_IDATA4_SIZE);
  else
    bfd_set_section_size (abfd, id4, 0);
  d4 = xmalloc (PE_IDATA4_SIZE);
  id4->contents = d4;
  memset (d4, 0, PE_IDATA4_SIZE);

  bfd_set_symtab (abfd, symtab, symptr);

  bfd_set_section_contents (abfd, id2, d2, 0, 20);
  if (pe_use_nul_prefixed_import_tables)
    {
      bfd_set_section_contents (abfd, id5, d5, 0, PE_IDATA5_SIZE);
      bfd_set_section_contents (abfd, id4, d4, 0, PE_IDATA4_SIZE);
    }
  else
    {
      bfd_set_section_contents (abfd, id5, d5, 0, 0);
      bfd_set_section_contents (abfd, id4, d4, 0, 0);
    }

  bfd_make_readable (abfd);
  return abfd;
}

/*	.section	.idata$4
 	.long		0
	[.long		0] for PE+
 	.section	.idata$5
 	.long		0
	[.long		0] for PE+
 	.section	idata$7
 	.global		__my_dll_iname
  __my_dll_iname:
 	.asciz		"my.dll"       */

static bfd *
make_tail (bfd *parent)
{
  asection *id4, *id5, *id7;
  unsigned char *d4, *d5, *d7;
  int len;
  char *oname;
  bfd *abfd;

  oname = xmalloc (20);
  sprintf (oname, "d%06d.o", tmp_seq);
  tmp_seq++;

  abfd = bfd_create (oname, parent);
  bfd_find_target (pe_details->object_target, abfd);
  bfd_make_writable (abfd);

  bfd_set_format (abfd, bfd_object);
  bfd_set_arch_mach (abfd, pe_details->bfd_arch, 0);

  symptr = 0;
  symtab = xmalloc (5 * sizeof (asymbol *));
  id4 = quick_section (abfd, ".idata$4", SEC_HAS_CONTENTS, 2);
  id5 = quick_section (abfd, ".idata$5", SEC_HAS_CONTENTS, 2);
  id7 = quick_section (abfd, ".idata$7", SEC_HAS_CONTENTS, 2);
  quick_symbol (abfd, U (""), dll_symname, "_iname", id7, BSF_GLOBAL, 0);

  bfd_set_section_size (abfd, id4, PE_IDATA4_SIZE);
  d4 = xmalloc (PE_IDATA4_SIZE);
  id4->contents = d4;
  memset (d4, 0, PE_IDATA4_SIZE);

  bfd_set_section_size (abfd, id5, PE_IDATA5_SIZE);
  d5 = xmalloc (PE_IDATA5_SIZE);
  id5->contents = d5;
  memset (d5, 0, PE_IDATA5_SIZE);

  len = strlen (dll_filename) + 1;
  if (len & 1)
    len++;
  bfd_set_section_size (abfd, id7, len);
  d7 = xmalloc (len);
  id7->contents = d7;
  strcpy ((char *) d7, dll_filename);
  /* If len was odd, the above
     strcpy leaves behind an undefined byte. That is harmless,
     but we set it to 0 just so the binary dumps are pretty.  */
  d7[len - 1] = 0;

  bfd_set_symtab (abfd, symtab, symptr);

  bfd_set_section_contents (abfd, id4, d4, 0, PE_IDATA4_SIZE);
  bfd_set_section_contents (abfd, id5, d5, 0, PE_IDATA5_SIZE);
  bfd_set_section_contents (abfd, id7, d7, 0, len);

  bfd_make_readable (abfd);
  return abfd;
}

/*	.text
 	.global		_function
 	.global		___imp_function
 	.global		__imp__function
  _function:
 	jmp		*__imp__function:

 	.section	idata$7
 	.long		__head_my_dll

 	.section	.idata$5
  ___imp_function:
  __imp__function:
  iat?
  	.section	.idata$4
  iat?
 	.section	.idata$6
  ID<ordinal>:
 	.short		<hint>
 	.asciz		"function" xlate? (add underscore, kill at)  */

static const unsigned char jmp_ix86_bytes[] =
{
  0xff, 0x25, 0x00, 0x00, 0x00, 0x00, 0x90, 0x90
};

/* _function:
 	mov.l	ip+8,r0
 	mov.l	@@r0,r0
 	jmp	@@r0
 	nop
 	.dw	__imp_function   */

static const unsigned char jmp_sh_bytes[] =
{
  0x01, 0xd0, 0x02, 0x60, 0x2b, 0x40, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00
};

/* _function:
 	lui	$t0,<high:__imp_function>
 	lw	$t0,<low:__imp_function>
 	jr	$t0
 	nop                              */

static const unsigned char jmp_mips_bytes[] =
{
  0x00, 0x00, 0x08, 0x3c,  0x00, 0x00, 0x08, 0x8d,
  0x08, 0x00, 0x00, 0x01,  0x00, 0x00, 0x00, 0x00
};

static const unsigned char jmp_arm_bytes[] =
{
  0x00, 0xc0, 0x9f, 0xe5,	/* ldr  ip, [pc] */
  0x00, 0xf0, 0x9c, 0xe5,	/* ldr  pc, [ip] */
  0,    0,    0,    0
};


static bfd *
make_one (def_file_export *exp, bfd *parent, bfd_boolean include_jmp_stub)
{
  asection *tx, *id7, *id5, *id4, *id6;
  unsigned char *td = NULL, *d7, *d5, *d4, *d6 = NULL;
  int len;
  char *oname;
  bfd *abfd;
  const unsigned char *jmp_bytes = NULL;
  int jmp_byte_count = 0;

  /* Include the jump stub section only if it is needed. A jump
     stub is needed if the symbol being imported <sym> is a function
     symbol and there is at least one undefined reference to that
     symbol. In other words, if all the import references to <sym> are
     explicitly through _declspec(dllimport) then the jump stub is not
     needed.  */
  if (include_jmp_stub)
    {
      switch (pe_details->pe_arch)
	{
	case PE_ARCH_i386:
	  jmp_bytes = jmp_ix86_bytes;
	  jmp_byte_count = sizeof (jmp_ix86_bytes);
	  break;
	case PE_ARCH_sh:
	  jmp_bytes = jmp_sh_bytes;
	  jmp_byte_count = sizeof (jmp_sh_bytes);
	  break;
	case PE_ARCH_mips:
	  jmp_bytes = jmp_mips_bytes;
	  jmp_byte_count = sizeof (jmp_mips_bytes);
	  break;
	case PE_ARCH_arm:
	case PE_ARCH_arm_epoc:
	case PE_ARCH_arm_wince:
	  jmp_bytes = jmp_arm_bytes;
	  jmp_byte_count = sizeof (jmp_arm_bytes);
	  break;
	default:
	  abort ();
	}
    }

  oname = xmalloc (20);
  sprintf (oname, "d%06d.o", tmp_seq);
  tmp_seq++;

  abfd = bfd_create (oname, parent);
  bfd_find_target (pe_details->object_target, abfd);
  bfd_make_writable (abfd);

  bfd_set_format (abfd, bfd_object);
  bfd_set_arch_mach (abfd, pe_details->bfd_arch, 0);

  symptr = 0;
  symtab = xmalloc (12 * sizeof (asymbol *));

  tx  = quick_section (abfd, ".text", SEC_CODE | SEC_HAS_CONTENTS | SEC_READONLY, 2);
  id7 = quick_section (abfd, ".idata$7", SEC_HAS_CONTENTS, 2);
  id5 = quick_section (abfd, ".idata$5", SEC_HAS_CONTENTS, 2);
  id4 = quick_section (abfd, ".idata$4", SEC_HAS_CONTENTS, 2);
  id6 = quick_section (abfd, ".idata$6", SEC_HAS_CONTENTS, 2);

  if  (*exp->internal_name == '@@')
    {
      quick_symbol (abfd, U ("_head_"), dll_symname, "", UNDSEC,
		    BSF_GLOBAL, 0);
      if (include_jmp_stub)
	quick_symbol (abfd, "", exp->internal_name, "", tx, BSF_GLOBAL, 0);
      quick_symbol (abfd, "__imp_", exp->internal_name, "", id5,
		    BSF_GLOBAL, 0);
      /* Fastcall applies only to functions,
	 so no need for auto-import symbol.  */
    }
  else
    {
      quick_symbol (abfd, U ("_head_"), dll_symname, "", UNDSEC,
		    BSF_GLOBAL, 0);
      if (include_jmp_stub)
	quick_symbol (abfd, U (""), exp->internal_name, "", tx,
		      BSF_GLOBAL, 0);
      quick_symbol (abfd, "__imp_", U (""), exp->internal_name, id5,
		    BSF_GLOBAL, 0);
      /* Symbol to reference ord/name of imported
	 data symbol, used to implement auto-import.  */
      if (exp->flag_data)
	quick_symbol (abfd, "__nm_", U (""), exp->internal_name, id6,
		      BSF_GLOBAL,0);
    }
  if (pe_dll_compat_implib)
    quick_symbol (abfd, "___imp_", exp->internal_name, "", id5,
		  BSF_GLOBAL, 0);

  if (include_jmp_stub)
    {
      bfd_set_section_size (abfd, tx, jmp_byte_count);
      td = xmalloc (jmp_byte_count);
      tx->contents = td;
      memcpy (td, jmp_bytes, jmp_byte_count);

      switch (pe_details->pe_arch)
	{
	case PE_ARCH_i386:
#ifdef pe_use_x86_64
	  quick_reloc (abfd, 2, BFD_RELOC_32_PCREL, 2);
#else
	  /* Mark this object as SAFESEH compatible.  */
	  quick_symbol (abfd, "", "@@feat.00", "", bfd_abs_section_ptr,
			BSF_LOCAL, 1);
          quick_reloc (abfd, 2, BFD_RELOC_32, 2);
#endif
	  break;
	case PE_ARCH_sh:
	  quick_reloc (abfd, 8, BFD_RELOC_32, 2);
	  break;
	case PE_ARCH_mips:
	  quick_reloc (abfd, 0, BFD_RELOC_HI16_S, 2);
	  quick_reloc (abfd, 0, BFD_RELOC_LO16, 0); /* MIPS_R_PAIR */
	  quick_reloc (abfd, 4, BFD_RELOC_LO16, 2);
	  break;
	case PE_ARCH_arm:
 	case PE_ARCH_arm_epoc:
 	case PE_ARCH_arm_wince:
	  quick_reloc (abfd, 8, BFD_RELOC_32, 2);
	  break;
	default:
	  abort ();
	}
      save_relocs (tx);
    }
  else
    bfd_set_section_size (abfd, tx, 0);

  bfd_set_section_size (abfd, id7, 4);
  d7 = xmalloc (4);
  id7->contents = d7;
  memset (d7, 0, 4);
  quick_reloc (abfd, 0, BFD_RELOC_RVA, 5);
  save_relocs (id7);

  bfd_set_section_size (abfd, id5, PE_IDATA5_SIZE);
  d5 = xmalloc (PE_IDATA5_SIZE);
  id5->contents = d5;
  memset (d5, 0, PE_IDATA5_SIZE);

  if (exp->flag_noname)
    {
      d5[0] = exp->ordinal;
      d5[1] = exp->ordinal >> 8;
      d5[PE_IDATA5_SIZE - 1] = 0x80;
    }
  else
    {
      quick_reloc (abfd, 0, BFD_RELOC_RVA, 4);
      save_relocs (id5);
    }

  bfd_set_section_size (abfd, id4, PE_IDATA4_SIZE);
  d4 = xmalloc (PE_IDATA4_SIZE);
  id4->contents = d4;
  memset (d4, 0, PE_IDATA4_SIZE);

  if (exp->flag_noname)
    {
      d4[0] = exp->ordinal;
      d4[1] = exp->ordinal >> 8;
      d4[PE_IDATA4_SIZE - 1] = 0x80;
    }
  else
    {
      quick_reloc (abfd, 0, BFD_RELOC_RVA, 4);
      save_relocs (id4);
    }

  if (exp->flag_noname)
    {
      len = 0;
      bfd_set_section_size (abfd, id6, 0);
    }
  else
    {
      /* { short, asciz }  */
      if (exp->its_name)
	len = 2 + strlen (exp->its_name) + 1;
      else
	len = 2 + strlen (exp->name) + 1;
      if (len & 1)
	len++;
      bfd_set_section_size (abfd, id6, len);
      d6 = xmalloc (len);
      id6->contents = d6;
      memset (d6, 0, len);
      d6[0] = exp->hint & 0xff;
      d6[1] = exp->hint >> 8;
      if (exp->its_name)
	strcpy ((char*) d6 + 2, exp->its_name);
      else
	strcpy ((char *) d6 + 2, exp->name);
    }

  bfd_set_symtab (abfd, symtab, symptr);

  if (include_jmp_stub)
    bfd_set_section_contents (abfd, tx, td, 0, jmp_byte_count);
  bfd_set_section_contents (abfd, id7, d7, 0, 4);
  bfd_set_section_contents (abfd, id5, d5, 0, PE_IDATA5_SIZE);
  bfd_set_section_contents (abfd, id4, d4, 0, PE_IDATA4_SIZE);
  if (!exp->flag_noname)
    bfd_set_section_contents (abfd, id6, d6, 0, len);

  bfd_make_readable (abfd);
  return abfd;
}

static bfd *
make_singleton_name_imp (const char *import, bfd *parent)
{
  /* Name thunks go to idata$4.  */
  asection *id5;
  unsigned char *d5;
  char *oname;
  bfd *abfd;

  oname = xmalloc (20);
  sprintf (oname, "nmimp%06d.o", tmp_seq2);
  tmp_seq2++;

  abfd = bfd_create (oname, parent);
  bfd_find_target (pe_details->object_target, abfd);
  bfd_make_writable (abfd);

  bfd_set_format (abfd, bfd_object);
  bfd_set_arch_mach (abfd, pe_details->bfd_arch, 0);

  symptr = 0;
  symtab = xmalloc (3 * sizeof (asymbol *));
  id5 = quick_section (abfd, ".idata$5", SEC_HAS_CONTENTS, 2);
  quick_symbol (abfd, "__imp_", import, "", id5, BSF_GLOBAL, 0);

  /* We need space for the real thunk and for the null terminator.  */
  bfd_set_section_size (abfd, id5, PE_IDATA5_SIZE * 2);
  d5 = xmalloc (PE_IDATA5_SIZE * 2);
  id5->contents = d5;
  memset (d5, 0, PE_IDATA5_SIZE * 2);
  quick_reloc (abfd, 0, BFD_RELOC_RVA, 2);
  save_relocs (id5);

  bfd_set_symtab (abfd, symtab, symptr);

  bfd_set_section_contents (abfd, id5, d5, 0, PE_IDATA4_SIZE * 2);

  bfd_make_readable (abfd);
  return abfd;
}

static bfd *
make_singleton_name_thunk (const char *import, bfd *parent)
{
  /* Name thunks go to idata$4.  */
  asection *id4;
  unsigned char *d4;
  char *oname;
  bfd *abfd;

  oname = xmalloc (20);
  sprintf (oname, "nmth%06d.o", tmp_seq);
  tmp_seq++;

  abfd = bfd_create (oname, parent);
  bfd_find_target (pe_details->object_target, abfd);
  bfd_make_writable (abfd);

  bfd_set_format (abfd, bfd_object);
  bfd_set_arch_mach (abfd, pe_details->bfd_arch, 0);

  symptr = 0;
  symtab = xmalloc (3 * sizeof (asymbol *));
  id4 = quick_section (abfd, ".idata$4", SEC_HAS_CONTENTS, 2);
  quick_symbol (abfd, "__nm_thnk_", import, "", id4, BSF_GLOBAL, 0);
  quick_symbol (abfd, "__nm_", import, "", UNDSEC, BSF_GLOBAL, 0);

  /* We need space for the real thunk and for the null terminator.  */
  bfd_set_section_size (abfd, id4, PE_IDATA4_SIZE * 2);
  d4 = xmalloc (PE_IDATA4_SIZE * 2);
  id4->contents = d4;
  memset (d4, 0, PE_IDATA4_SIZE * 2);
  quick_reloc (abfd, 0, BFD_RELOC_RVA, 2);
  save_relocs (id4);

  bfd_set_symtab (abfd, symtab, symptr);

  bfd_set_section_contents (abfd, id4, d4, 0, PE_IDATA4_SIZE * 2);

  bfd_make_readable (abfd);
  return abfd;
}

static char *
make_import_fixup_mark (arelent *rel)
{
  /* We convert reloc to symbol, for later reference.  */
  static int counter;
  static char *fixup_name = NULL;
  static size_t buffer_len = 0;

  struct bfd_symbol *sym = *rel->sym_ptr_ptr;

  bfd *abfd = bfd_asymbol_bfd (sym);
  struct bfd_link_hash_entry *bh;

  if (!fixup_name)
    {
      fixup_name = xmalloc (384);
      buffer_len = 384;
    }

  if (strlen (sym->name) + 25 > buffer_len)
  /* Assume 25 chars for "__fu" + counter + "_".  If counter is
     bigger than 20 digits long, we've got worse problems than
     overflowing this buffer...  */
    {
      free (fixup_name);
      /* New buffer size is length of symbol, plus 25, but
	 then rounded up to the nearest multiple of 128.  */
      buffer_len = ((strlen (sym->name) + 25) + 127) & ~127;
      fixup_name = xmalloc (buffer_len);
    }

  sprintf (fixup_name, "__fu%d_%s", counter++, sym->name);

  bh = NULL;
  bfd_coff_link_add_one_symbol (&link_info, abfd, fixup_name, BSF_GLOBAL,
				current_sec, /* sym->section, */
				rel->address, NULL, TRUE, FALSE, &bh);

  return fixup_name;
}

/*	.section	.idata$2
  	.rva		__nm_thnk_SYM (singleton thunk with name of func)
 	.long		0
 	.long		0
 	.rva		__my_dll_iname (name of dll)
 	.rva		__fuNN_SYM (pointer to reference (address) in text)  */

static bfd *
make_import_fixup_entry (const char *name,
			 const char *fixup_name,
			 const char *symname,
			 bfd *parent)
{
  asection *id2;
  unsigned char *d2;
  char *oname;
  bfd *abfd;

  oname = xmalloc (20);
  sprintf (oname, "fu%06d.o", tmp_seq);
  tmp_seq++;

  abfd = bfd_create (oname, parent);
  bfd_find_target (pe_details->object_target, abfd);
  bfd_make_writable (abfd);

  bfd_set_format (abfd, bfd_object);
  bfd_set_arch_mach (abfd, pe_details->bfd_arch, 0);

  symptr = 0;
  symtab = xmalloc (6 * sizeof (asymbol *));
  id2 = quick_section (abfd, ".idata$2", SEC_HAS_CONTENTS, 2);

  quick_symbol (abfd, "__nm_thnk_", name, "", UNDSEC, BSF_GLOBAL, 0);
  quick_symbol (abfd, U (""), symname, "_iname", UNDSEC, BSF_GLOBAL, 0);
  /* For relocator v2 we have to use the .idata$5 element and not
     fixup_name.  */
  if (link_info.pei386_runtime_pseudo_reloc == 2)
    quick_symbol (abfd, "__imp_", name, "", UNDSEC, BSF_GLOBAL, 0);
  else
    quick_symbol (abfd, "", fixup_name, "", UNDSEC, BSF_GLOBAL, 0);

  bfd_set_section_size (abfd, id2, 20);
  d2 = xmalloc (20);
  id2->contents = d2;
  memset (d2, 0, 20);

  quick_reloc (abfd, 0, BFD_RELOC_RVA, 1);
  quick_reloc (abfd, 12, BFD_RELOC_RVA, 2);
  quick_reloc (abfd, 16, BFD_RELOC_RVA, 3);
  save_relocs (id2);

  bfd_set_symtab (abfd, symtab, symptr);

  bfd_set_section_contents (abfd, id2, d2, 0, 20);

  bfd_make_readable (abfd);
  return abfd;
}

/*	.section	.rdata_runtime_pseudo_reloc
 	.long		addend
 	.rva		__fuNN_SYM (pointer to reference (address) in text)  */

static bfd *
make_runtime_pseudo_reloc (const char *name ATTRIBUTE_UNUSED,
			   const char *fixup_name,
			   bfd_vma addend ATTRIBUTE_UNUSED,
			   bfd_vma bitsize,
			   bfd *parent)
{
  asection *rt_rel;
  unsigned char *rt_rel_d;
  char *oname;
  bfd *abfd;
  oname = xmalloc (20);
  sprintf (oname, "rtr%06d.o", tmp_seq);
  tmp_seq++;

  abfd = bfd_create (oname, parent);
  bfd_find_target (pe_details->object_target, abfd);
  bfd_make_writable (abfd);

  bfd_set_format (abfd, bfd_object);
  bfd_set_arch_mach (abfd, pe_details->bfd_arch, 0);

  symptr = 0;
  if (link_info.pei386_runtime_pseudo_reloc == 2)
    {
      symtab = xmalloc ((runtime_pseudp_reloc_v2_init ? 3 : 6) * sizeof (asymbol *));
    }
  else
    {
      symtab = xmalloc (2 * sizeof (asymbol *));
    }
  rt_rel = quick_section (abfd, ".rdata_runtime_pseudo_reloc",
			  SEC_HAS_CONTENTS, 2);

  quick_symbol (abfd, "", fixup_name, "", UNDSEC, BSF_GLOBAL, 0);

  if (link_info.pei386_runtime_pseudo_reloc == 2)
    {
	  size_t size = 12;
	  if (! runtime_pseudp_reloc_v2_init)
	    {
		  size += 12;
		  runtime_pseudp_reloc_v2_init = 1;
	    }
      quick_symbol (abfd, "__imp_", name, "", UNDSEC, BSF_GLOBAL, 0);

      bfd_set_section_size (abfd, rt_rel, size);
      rt_rel_d = xmalloc (size);
      rt_rel->contents = rt_rel_d;
      memset (rt_rel_d, 0, size);
	  quick_reloc (abfd, size - 8, BFD_RELOC_RVA, 1);
	  quick_reloc (abfd, size - 12, BFD_RELOC_RVA, 2);
	  bfd_put_32 (abfd, bitsize, rt_rel_d + (size - 4));
	  if (size != 12)
	    bfd_put_32 (abfd, 1, rt_rel_d + 8);
      save_relocs (rt_rel);

      bfd_set_symtab (abfd, symtab, symptr);

      bfd_set_section_contents (abfd, rt_rel, rt_rel_d, 0, size);
   }
  else
   {
      bfd_set_section_size (abfd, rt_rel, 8);
      rt_rel_d = xmalloc (8);
      rt_rel->contents = rt_rel_d;
      memset (rt_rel_d, 0, 8);

      bfd_put_32 (abfd, addend, rt_rel_d);
      quick_reloc (abfd, 4, BFD_RELOC_RVA, 1);

      save_relocs (rt_rel);

      bfd_set_symtab (abfd, symtab, symptr);

      bfd_set_section_contents (abfd, rt_rel, rt_rel_d, 0, 8);
   }
  bfd_make_readable (abfd);
  return abfd;
}

/*	.section	.rdata
 	.rva		__pei386_runtime_relocator  */

static bfd *
pe_create_runtime_relocator_reference (bfd *parent)
{
  asection *extern_rt_rel;
  unsigned char *extern_rt_rel_d;
  char *oname;
  bfd *abfd;

  oname = xmalloc (20);
  sprintf (oname, "ertr%06d.o", tmp_seq);
  tmp_seq++;

  abfd = bfd_create (oname, parent);
  bfd_find_target (pe_details->object_target, abfd);
  bfd_make_writable (abfd);

  bfd_set_format (abfd, bfd_object);
  bfd_set_arch_mach (abfd, pe_details->bfd_arch, 0);

  symptr = 0;
  symtab = xmalloc (2 * sizeof (asymbol *));
  extern_rt_rel = quick_section (abfd, ".rdata", SEC_HAS_CONTENTS, 2);

  quick_symbol (abfd, "", U ("_pei386_runtime_relocator"), "", UNDSEC,
		BSF_NO_FLAGS, 0);

  bfd_set_section_size (abfd, extern_rt_rel, PE_IDATA5_SIZE);
  extern_rt_rel_d = xmalloc (PE_IDATA5_SIZE);
  extern_rt_rel->contents = extern_rt_rel_d;

  quick_reloc (abfd, 0, BFD_RELOC_RVA, 1);
  save_relocs (extern_rt_rel);

  bfd_set_symtab (abfd, symtab, symptr);

  bfd_set_section_contents (abfd, extern_rt_rel, extern_rt_rel_d, 0, PE_IDATA5_SIZE);

  bfd_make_readable (abfd);
  return abfd;
}

void
pe_create_import_fixup (arelent *rel, asection *s, bfd_vma addend)
{
  char buf[300];
  struct bfd_symbol *sym = *rel->sym_ptr_ptr;
  struct bfd_link_hash_entry *name_thunk_sym;
  struct bfd_link_hash_entry *name_imp_sym;
  const char *name = sym->name;
  char *fixup_name = make_import_fixup_mark (rel);
  bfd *b;
  int need_import_table = 1;

  sprintf (buf, "__imp_%s", name);
  name_imp_sym = bfd_link_hash_lookup (link_info.hash, buf, 0, 0, 1);

  sprintf (buf, "__nm_thnk_%s", name);

  name_thunk_sym = bfd_link_hash_lookup (link_info.hash, buf, 0, 0, 1);

  /* For version 2 pseudo relocation we don't need to add an import
     if the import symbol is already present.  */
  if (link_info.pei386_runtime_pseudo_reloc == 2
      && name_imp_sym
      && name_imp_sym->type == bfd_link_hash_defined)
    need_import_table = 0;

  if (need_import_table == 1
      && (!name_thunk_sym || name_thunk_sym->type != bfd_link_hash_defined))
    {
      b = make_singleton_name_thunk (name, link_info.output_bfd);
      add_bfd_to_link (b, b->filename, &link_info);

      /* If we ever use autoimport, we have to cast text section writable.
         But not for version 2.  */
      if (link_info.pei386_runtime_pseudo_reloc != 2)
        {
          config.text_read_only = FALSE;
          link_info.output_bfd->flags &= ~WP_TEXT;
        }
      if (link_info.pei386_runtime_pseudo_reloc == 2)
        {
	  b = make_singleton_name_imp (name, link_info.output_bfd);
          add_bfd_to_link (b, b->filename, &link_info);
	}
    }

  if ((addend == 0 || link_info.pei386_runtime_pseudo_reloc)
      && need_import_table == 1)
    {
      extern char * pe_data_import_dll;
      char * symname = pe_data_import_dll ? pe_data_import_dll : "unknown";

      b = make_import_fixup_entry (name, fixup_name, symname,
				   link_info.output_bfd);
      add_bfd_to_link (b, b->filename, &link_info);
    }

    if ((link_info.pei386_runtime_pseudo_reloc != 0 && addend != 0)
        || link_info.pei386_runtime_pseudo_reloc == 2)
      {
	if (pe_dll_extra_pe_debug)
	  printf ("creating runtime pseudo-reloc entry for %s (addend=%d)\n",
	          fixup_name, (int) addend);

	b = make_runtime_pseudo_reloc (name, fixup_name, addend, rel->howto->bitsize,
				       link_info.output_bfd);
	add_bfd_to_link (b, b->filename, &link_info);

	if (runtime_pseudo_relocs_created == 0)
	  {
	    b = pe_create_runtime_relocator_reference (link_info.output_bfd);
	    add_bfd_to_link (b, b->filename, &link_info);
	  }
	runtime_pseudo_relocs_created++;
      }
    else if (addend != 0)
      {
	einfo (_("%C: variable '%T' can't be auto-imported. Please read the documentation for ld's --enable-auto-import for details.\n"),
	       s->owner, s, rel->address, sym->name);
	einfo ("%X");
      }
}


void
pe_dll_generate_implib (def_file *def, const char *impfilename, struct bfd_link_info *info)
{
  int i;
  bfd *ar_head;
  bfd *ar_tail;
  bfd *outarch;
  bfd *ibfd;
  bfd *head = 0;

  dll_filename = (def->name) ? def->name : dll_name;
  dll_symname = xstrdup (dll_filename);
  for (i = 0; dll_symname[i]; i++)
    if (!ISALNUM (dll_symname[i]))
      dll_symname[i] = '_';

  unlink_if_ordinary (impfilename);

  outarch = bfd_openw (impfilename, 0);

  if (!outarch)
    {
      /* xgettext:c-format */
      einfo (_("%XCan't open .lib file: %s\n"), impfilename);
      return;
    }

  if (verbose)
    /* xgettext:c-format */
    info_msg (_("Creating library file: %s\n"), impfilename);

  bfd_set_format (outarch, bfd_archive);
  outarch->has_armap = 1;

  /* Work out a reasonable size of things to put onto one line.  */
  ar_head = make_head (outarch);

  /* Iterate the input BFDs, looking for exclude-modules-for-implib.  */
  for (ibfd = info->input_bfds; ibfd; ibfd = ibfd->link_next)
    {
      /* Iterate the exclude list.  */
      struct exclude_list_struct *ex;
      char found;
      for (ex = excludes, found = 0; ex && !found; ex = ex->next)
	{
	  if (ex->type != EXCLUDEFORIMPLIB)
	    continue;
	  found = (filename_cmp (ex->string, ibfd->filename) == 0);
	}
      /* If it matched, we must open a fresh BFD for it (the original
        input BFD is still needed for the DLL's final link) and add
	it into the archive member chain.  */
      if (found)
	{
	  bfd *newbfd = bfd_openr (ibfd->my_archive
		? ibfd->my_archive->filename : ibfd->filename, NULL);
	  if (!newbfd)
	    {
	      einfo (_("%Xbfd_openr %s: %E\n"), ibfd->filename);
	      return;
	    }
	  if (ibfd->my_archive)
	    {
	      /* Must now iterate through archive until we find the
		required member.  A minor shame that we'll open the
		archive once per member that we require from it, and
		leak those archive bfds rather than reuse them.  */
	      bfd *arbfd = newbfd;
	      if (!bfd_check_format_matches (arbfd, bfd_archive, NULL))
		{
		  einfo (_("%X%s(%s): can't find member in non-archive file"),
		    ibfd->my_archive->filename, ibfd->filename);
		  return;
		}
	      newbfd = NULL;
	      while ((newbfd = bfd_openr_next_archived_file (arbfd, newbfd)) != 0)
		{
		  if (filename_cmp (newbfd->filename, ibfd->filename) == 0)
		    break;
		}
	      if (!newbfd)
		{
		  einfo (_("%X%s(%s): can't find member in archive"),
		    ibfd->my_archive->filename, ibfd->filename);
		  return;
		}
	    }
	  newbfd->archive_next = head;
	  head = newbfd;
	}
    }

  for (i = 0; i < def->num_exports; i++)
    {
      /* The import library doesn't know about the internal name.  */
      char *internal = def->exports[i].internal_name;
      bfd *n;

      /* Don't add PRIVATE entries to import lib.  */
      if (pe_def_file->exports[i].flag_private)
	continue;
      def->exports[i].internal_name = def->exports[i].name;
      n = make_one (def->exports + i, outarch,
		    ! (def->exports + i)->flag_data);
      n->archive_next = head;
      head = n;
      def->exports[i].internal_name = internal;
    }

  ar_tail = make_tail (outarch);

  if (ar_head == NULL || ar_tail == NULL)
    return;

  /* Now stick them all into the archive.  */
  ar_head->archive_next = head;
  ar_tail->archive_next = ar_head;
  head = ar_tail;

  if (! bfd_set_archive_head (outarch, head))
    einfo ("%Xbfd_set_archive_head: %E\n");

  if (! bfd_close (outarch))
    einfo ("%Xbfd_close %s: %E\n", impfilename);

  while (head != NULL)
    {
      bfd *n = head->archive_next;
      bfd_close (head);
      head = n;
    }
}

static int undef_count = 0;

struct key_value
{
  char *key;
  const char *oname;
};

static struct key_value *udef_table;

static int undef_sort_cmp (const void *l1, const void *r1)
{
  const struct key_value *l = l1;
  const struct key_value *r = r1;

  return strcmp (l->key, r->key);
}

static struct bfd_link_hash_entry *
pe_find_cdecl_alias_match (struct bfd_link_info *linfo, char *name)
{
  struct bfd_link_hash_entry *h = NULL;
  struct key_value *kv;
  struct key_value key;
  char *at, *lname = (char *) alloca (strlen (name) + 3);

  strcpy (lname, name);

  at = strchr (lname + (lname[0] == '@@'), '@@');
  if (at)
    at[1] = 0;

  key.key = lname;
  kv = bsearch (&key, udef_table, undef_count, sizeof (struct key_value),
		undef_sort_cmp);

  if (kv)
    {
      h = bfd_link_hash_lookup (linfo->hash, kv->oname, FALSE, FALSE, FALSE);
      if (h->type == bfd_link_hash_undefined)
        return h;
    }
  if (lname[0] == '?')
    return NULL;
  if (at || lname[0] == '@@')
    {
      if (lname[0] == '@@')
        {
	  if (pe_details->underscored)
	    lname[0] = '_';
	  else
	    strcpy (lname, lname + 1);
	  key.key = lname;
	  kv = bsearch (&key, udef_table, undef_count,
			sizeof (struct key_value), undef_sort_cmp);
	  if (kv)
	    {
	      h = bfd_link_hash_lookup (linfo->hash, kv->oname, FALSE, FALSE, FALSE);
	      if (h->type == bfd_link_hash_undefined)
		return h;
	    }
	}
      if (at)
        *strchr (lname, '@@') = 0;
      key.key = lname;
      kv = bsearch (&key, udef_table, undef_count,
		    sizeof (struct key_value), undef_sort_cmp);
      if (kv)
	{
	  h = bfd_link_hash_lookup (linfo->hash, kv->oname, FALSE, FALSE, FALSE);
	  if (h->type == bfd_link_hash_undefined)
	    return h;
	}
      return NULL;
    }

  strcat (lname, "@@");
  key.key = lname;
  kv = bsearch (&key, udef_table, undef_count,
		sizeof (struct key_value), undef_sort_cmp);

  if (kv)
    {
      h = bfd_link_hash_lookup (linfo->hash, kv->oname, FALSE, FALSE, FALSE);
      if (h->type == bfd_link_hash_undefined)
	return h;
    }

  if (lname[0] == '_' && pe_details->underscored)
    lname[0] = '@@';
  else
    {
      memmove (lname + 1, lname, strlen (lname) + 1);
      lname[0] = '@@';
    }
  key.key = lname;

  kv = bsearch (&key, udef_table, undef_count,
		sizeof (struct key_value), undef_sort_cmp);

  if (kv)
    {
      h = bfd_link_hash_lookup (linfo->hash, kv->oname, FALSE, FALSE, FALSE);
      if (h->type == bfd_link_hash_undefined)
        return h;
    }

  return NULL;
}

static bfd_boolean
pe_undef_count (struct bfd_link_hash_entry *h ATTRIBUTE_UNUSED,
                void *inf ATTRIBUTE_UNUSED)
{
  if (h->type == bfd_link_hash_undefined)
    undef_count++;
  return TRUE;
}

static bfd_boolean
pe_undef_fill (struct bfd_link_hash_entry *h, void *inf ATTRIBUTE_UNUSED)
{
  if (h->type == bfd_link_hash_undefined)
    {
      char *at;

      udef_table[undef_count].key = xstrdup (h->root.string);
      at = strchr (udef_table[undef_count].key
		   + (udef_table[undef_count].key[0] == '@@'), '@@');
      if (at)
        at[1] = 0;
      udef_table[undef_count].oname = h->root.string;
      undef_count++;
    }
  return TRUE;
}

static void
pe_create_undef_table (void)
{
  undef_count = 0;

  /* count undefined symbols */

  bfd_link_hash_traverse (link_info.hash, pe_undef_count, "");

  /* create and fill the corresponding table */
  udef_table = xmalloc (undef_count * sizeof (struct key_value));

  undef_count = 0;
  bfd_link_hash_traverse (link_info.hash, pe_undef_fill, "");

  /* sort items */
  qsort (udef_table, undef_count, sizeof (struct key_value), undef_sort_cmp);
}

static void
add_bfd_to_link (bfd *abfd, const char *name, struct bfd_link_info *linfo)
{
  lang_input_statement_type *fake_file;

  fake_file = lang_add_input_file (name,
				   lang_input_file_is_fake_enum,
				   NULL);
  fake_file->the_bfd = abfd;
  ldlang_add_file (fake_file);

  if (!bfd_link_add_symbols (abfd, linfo))
    einfo ("%Xaddsym %s: %E\n", name);
}

void
pe_process_import_defs (bfd *output_bfd, struct bfd_link_info *linfo)
{
  int i, j;
  def_file_module *module;
  def_file_import *imp;

  pe_dll_id_target (bfd_get_target (output_bfd));

  if (!pe_def_file)
    return;

  imp = pe_def_file->imports;

  pe_create_undef_table ();

  for (module = pe_def_file->modules; module; module = module->next)
    {
      int do_this_dll = 0;

      for (i = 0; i < pe_def_file->num_imports && imp[i].module != module; i++)
	;
      if (i >= pe_def_file->num_imports)
        continue;

      dll_filename = module->name;
      dll_symname = xstrdup (module->name);
      for (j = 0; dll_symname[j]; j++)
	if (!ISALNUM (dll_symname[j]))
	  dll_symname[j] = '_';

      for (; i < pe_def_file->num_imports && imp[i].module == module; i++)
	{
	  def_file_export exp;
	  struct bfd_link_hash_entry *blhe;
	  int lead_at = (*imp[i].internal_name == '@@');
	  /* See if we need this import.  */
	  size_t len = strlen (imp[i].internal_name);
	  char *name = xmalloc (len + 2 + 6);
	  bfd_boolean include_jmp_stub = FALSE;
	  bfd_boolean is_cdecl = FALSE;
	  bfd_boolean is_undef = FALSE;

	  if (!lead_at && strchr (imp[i].internal_name, '@@') == NULL)
	      is_cdecl = TRUE;

	  if (lead_at)
	    sprintf (name, "%s", imp[i].internal_name);
	  else
	    sprintf (name, "%s%s",U (""), imp[i].internal_name);

	  blhe = bfd_link_hash_lookup (linfo->hash, name,
				       FALSE, FALSE, FALSE);

	  /* Include the jump stub for <sym> only if the <sym>
	     is undefined.  */
	  if (!blhe || (blhe && blhe->type != bfd_link_hash_undefined))
	    {
	      if (lead_at)
		sprintf (name, "%s%s", "__imp_", imp[i].internal_name);
	      else
		sprintf (name, "%s%s%s", "__imp_", U (""),
			 imp[i].internal_name);

	      blhe = bfd_link_hash_lookup (linfo->hash, name,
					   FALSE, FALSE, FALSE);
	      if (blhe)
	        is_undef = (blhe->type == bfd_link_hash_undefined);
	    }
	  else
	    {
	      include_jmp_stub = TRUE;
	      is_undef = (blhe->type == bfd_link_hash_undefined);
	    }

	  if (is_cdecl && (!blhe || (blhe && blhe->type != bfd_link_hash_undefined)))
	    {
	      sprintf (name, "%s%s",U (""), imp[i].internal_name);
	      blhe = pe_find_cdecl_alias_match (linfo, name);
	      include_jmp_stub = TRUE;
	      if (blhe)
	        is_undef = (blhe->type == bfd_link_hash_undefined);
	    }

	  free (name);

	  if (is_undef)
	    {
	      bfd *one;
	      /* We do.  */
	      if (!do_this_dll)
		{
		  bfd *ar_head = make_head (output_bfd);
		  add_bfd_to_link (ar_head, ar_head->filename, linfo);
		  do_this_dll = 1;
		}
	      exp.internal_name = imp[i].internal_name;
	      exp.name = imp[i].name;
	      exp.its_name = imp[i].its_name;
	      exp.ordinal = imp[i].ordinal;
	      exp.hint = exp.ordinal >= 0 ? exp.ordinal : 0;
	      exp.flag_private = 0;
	      exp.flag_constant = 0;
	      exp.flag_data = imp[i].data;
	      exp.flag_noname = exp.name ? 0 : 1;
	      one = make_one (&exp, output_bfd, (! exp.flag_data) && include_jmp_stub);
	      add_bfd_to_link (one, one->filename, linfo);
	    }
	}
      if (do_this_dll)
	{
	  bfd *ar_tail = make_tail (output_bfd);
	  add_bfd_to_link (ar_tail, ar_tail->filename, linfo);
	}

      free (dll_symname);
    }

  while (undef_count)
    {
      --undef_count;
      free (udef_table[undef_count].key);
    }
  free (udef_table);
}

/* We were handed a *.DLL file.  Parse it and turn it into a set of
   IMPORTS directives in the def file.  Return TRUE if the file was
   handled, FALSE if not.  */

static unsigned int
pe_get16 (bfd *abfd, int where)
{
  unsigned char b[2];

  bfd_seek (abfd, (file_ptr) where, SEEK_SET);
  bfd_bread (b, (bfd_size_type) 2, abfd);
  return b[0] + (b[1] << 8);
}

static unsigned int
pe_get32 (bfd *abfd, int where)
{
  unsigned char b[4];

  bfd_seek (abfd, (file_ptr) where, SEEK_SET);
  bfd_bread (b, (bfd_size_type) 4, abfd);
  return b[0] + (b[1] << 8) + (b[2] << 16) + (b[3] << 24);
}

static unsigned int
pe_as32 (void *ptr)
{
  unsigned char *b = ptr;

  return b[0] + (b[1] << 8) + (b[2] << 16) + (b[3] << 24);
}

bfd_boolean
pe_implied_import_dll (const char *filename)
{
  bfd *dll;
  bfd_vma pe_header_offset, opthdr_ofs, num_entries, i;
  bfd_vma export_rva, export_size, nsections, secptr, expptr;
  bfd_vma exp_funcbase;
  unsigned char *expdata;
  char *erva;
  bfd_vma name_rvas, nexp;
  const char *dllname;
  /* Initialization with start > end guarantees that is_data
     will not be set by mistake, and avoids compiler warning.  */
  bfd_vma data_start = 1;
  bfd_vma data_end = 0;
  bfd_vma rdata_start = 1;
  bfd_vma rdata_end = 0;
  bfd_vma bss_start = 1;
  bfd_vma bss_end = 0;

  /* No, I can't use bfd here.  kernel32.dll puts its export table in
     the middle of the .rdata section.  */
  dll = bfd_openr (filename, pe_details->target_name);
  if (!dll)
    {
      einfo ("%Xopen %s: %E\n", filename);
      return FALSE;
    }

  /* PEI dlls seem to be bfd_objects.  */
  if (!bfd_check_format (dll, bfd_object))
    {
      einfo ("%X%s: this doesn't appear to be a DLL\n", filename);
      return FALSE;
    }

  /* Get pe_header, optional header and numbers of directory entries.  */
  pe_header_offset = pe_get32 (dll, 0x3c);
  opthdr_ofs = pe_header_offset + 4 + 20;
#ifdef pe_use_x86_64
  num_entries = pe_get32 (dll, opthdr_ofs + 92 + 4 * 4); /*  & NumberOfRvaAndSizes.  */
#else
  num_entries = pe_get32 (dll, opthdr_ofs + 92);
#endif

  /* No import or export directory entry.  */
  if (num_entries < 1)
    return FALSE;

#ifdef pe_use_x86_64
  export_rva  = pe_get32 (dll, opthdr_ofs + 96 + 4 * 4);
  export_size = pe_get32 (dll, opthdr_ofs + 100 + 4 * 4);
#else
  export_rva = pe_get32 (dll, opthdr_ofs + 96);
  export_size = pe_get32 (dll, opthdr_ofs + 100);
#endif

  /* No export table - nothing to export.  */
  if (export_size == 0)
    return FALSE;

  nsections = pe_get16 (dll, pe_header_offset + 4 + 2);
  secptr = (pe_header_offset + 4 + 20 +
	    pe_get16 (dll, pe_header_offset + 4 + 16));
  expptr = 0;

  /* Get the rva and size of the export section.  */
  for (i = 0; i < nsections; i++)
    {
      char sname[8];
      bfd_vma secptr1 = secptr + 40 * i;
      bfd_vma vaddr = pe_get32 (dll, secptr1 + 12);
      bfd_vma vsize = pe_get32 (dll, secptr1 + 16);
      bfd_vma fptr = pe_get32 (dll, secptr1 + 20);

      bfd_seek (dll, (file_ptr) secptr1, SEEK_SET);
      bfd_bread (sname, (bfd_size_type) 8, dll);

      if (vaddr <= export_rva && vaddr + vsize > export_rva)
	{
	  expptr = fptr + (export_rva - vaddr);
	  if (export_rva + export_size > vaddr + vsize)
	    export_size = vsize - (export_rva - vaddr);
	  break;
	}
    }

  /* Scan sections and store the base and size of the
     data and bss segments in data/base_start/end.  */
  for (i = 0; i < nsections; i++)
    {
      bfd_vma secptr1 = secptr + 40 * i;
      bfd_vma vsize = pe_get32 (dll, secptr1 + 8);
      bfd_vma vaddr = pe_get32 (dll, secptr1 + 12);
      bfd_vma flags = pe_get32 (dll, secptr1 + 36);
      char sec_name[9];

      sec_name[8] = '\0';
      bfd_seek (dll, (file_ptr) secptr1 + 0, SEEK_SET);
      bfd_bread (sec_name, (bfd_size_type) 8, dll);

      if (strcmp(sec_name,".data") == 0)
	{
	  data_start = vaddr;
	  data_end = vaddr + vsize;

	  if (pe_dll_extra_pe_debug)
	    printf ("%s %s: 0x%08lx-0x%08lx (0x%08lx)\n",
		    __FUNCTION__, sec_name, (unsigned long) vaddr,
		    (unsigned long) (vaddr + vsize), (unsigned long) flags);
	}
      else if (strcmp(sec_name,".rdata") == 0)
	{
	  rdata_start = vaddr;
	  rdata_end = vaddr + vsize;

	  if (pe_dll_extra_pe_debug)
	    printf ("%s %s: 0x%08lx-0x%08lx (0x%08lx)\n",
		    __FUNCTION__, sec_name, (unsigned long) vaddr,
		    (unsigned long) (vaddr + vsize), (unsigned long) flags);
	}
      else if (strcmp (sec_name,".bss") == 0)
	{
	  bss_start = vaddr;
	  bss_end = vaddr + vsize;

	  if (pe_dll_extra_pe_debug)
	    printf ("%s %s: 0x%08lx-0x%08lx (0x%08lx)\n",
		    __FUNCTION__, sec_name, (unsigned long) vaddr,
		    (unsigned long) (vaddr + vsize), (unsigned long) flags);
	}
    }

  expdata = xmalloc (export_size);
  bfd_seek (dll, (file_ptr) expptr, SEEK_SET);
  bfd_bread (expdata, (bfd_size_type) export_size, dll);
  erva = (char *) expdata - export_rva;

  if (pe_def_file == 0)
    pe_def_file = def_file_empty ();

  nexp = pe_as32 (expdata + 24);
  name_rvas = pe_as32 (expdata + 32);
  exp_funcbase = pe_as32 (expdata + 28);

  /* Use internal dll name instead of filename
     to enable symbolic dll linking.  */
  dllname = erva + pe_as32 (expdata + 12);

  /* Check to see if the dll has already been added to
     the definition list and if so return without error.
     This avoids multiple symbol definitions.  */
  if (def_get_module (pe_def_file, dllname))
    {
      if (pe_dll_extra_pe_debug)
	printf ("%s is already loaded\n", dllname);
      return TRUE;
    }

  /* Iterate through the list of symbols.  */
  for (i = 0; i < nexp; i++)
    {
      /* Pointer to the names vector.  */
      bfd_vma name_rva = pe_as32 (erva + name_rvas + i * 4);
      def_file_import *imp;
      /* Pointer to the function address vector.  */
      bfd_vma func_rva = pe_as32 (erva + exp_funcbase + i * 4);
      int is_data = 0;

      /* Skip unwanted symbols, which are
	 exported in buggy auto-import releases.  */
      if (! CONST_STRNEQ (erva + name_rva, "__nm_"))
 	{
	  int is_dup = 0;
 	  /* is_data is true if the address is in the data, rdata or bss
	     segment.  */
 	  is_data =
	    (func_rva >= data_start && func_rva < data_end)
	    || (func_rva >= rdata_start && func_rva < rdata_end)
	    || (func_rva >= bss_start && func_rva < bss_end);

	  imp = def_file_add_import (pe_def_file, erva + name_rva,
				     dllname, i, NULL, NULL, &is_dup);
 	  /* Mark symbol type.  */
 	  if (!is_dup)
 	    imp->data = is_data;

 	  if (pe_dll_extra_pe_debug)
	    printf ("%s dll-name: %s sym: %s addr: 0x%lx %s\n",
		    __FUNCTION__, dllname, erva + name_rva,
		    (unsigned long) func_rva, is_data ? "(data)" : "");
 	}
    }

  return TRUE;
}

void
pe_output_file_set_long_section_names (bfd *abfd)
{
  if (pe_use_coff_long_section_names < 0)
    return;
  if (!bfd_coff_set_long_section_names (abfd, pe_use_coff_long_section_names))
    einfo (_("%XError: can't use long section names on this arch\n"));
}

/* These are the main functions, called from the emulation.  The first
   is called after the bfds are read, so we can guess at how much space
   we need.  The second is called after everything is placed, so we
   can put the right values in place.  */

void
pe_dll_build_sections (bfd *abfd, struct bfd_link_info *info)
{
  pe_dll_id_target (bfd_get_target (abfd));
  pe_output_file_set_long_section_names (abfd);
  process_def_file_and_drectve (abfd, info);

  if (pe_def_file->num_exports == 0 && !info->shared)
    return;

  generate_edata (abfd, info);
  build_filler_bfd (1);
  pe_output_file_set_long_section_names (filler_bfd);
}

void
pe_exe_build_sections (bfd *abfd, struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  pe_dll_id_target (bfd_get_target (abfd));
  pe_output_file_set_long_section_names (abfd);
  build_filler_bfd (0);
  pe_output_file_set_long_section_names (filler_bfd);
}

void
pe_dll_fill_sections (bfd *abfd, struct bfd_link_info *info)
{
  pe_dll_id_target (bfd_get_target (abfd));
  pe_output_file_set_long_section_names (abfd);
  image_base = pe_data (abfd)->pe_opthdr.ImageBase;

  generate_reloc (abfd, info);
  if (reloc_sz > 0)
    {
      bfd_set_section_size (filler_bfd, reloc_s, reloc_sz);

      /* Resize the sections.  */
      lang_reset_memory_regions ();
      lang_size_sections (NULL, TRUE);

      /* Redo special stuff.  */
      ldemul_after_allocation ();

      /* Do the assignments again.  */
      lang_do_assignments (lang_final_phase_enum);
    }

  fill_edata (abfd, info);

  if (info->shared && !info->pie)
    pe_data (abfd)->dll = 1;

  edata_s->contents = edata_d;
  reloc_s->contents = reloc_d;
}

void
pe_exe_fill_sections (bfd *abfd, struct bfd_link_info *info)
{
  pe_dll_id_target (bfd_get_target (abfd));
  pe_output_file_set_long_section_names (abfd);
  image_base = pe_data (abfd)->pe_opthdr.ImageBase;

  generate_reloc (abfd, info);
  if (reloc_sz > 0)
    {
      bfd_set_section_size (filler_bfd, reloc_s, reloc_sz);

      /* Resize the sections.  */
      lang_reset_memory_regions ();
      lang_size_sections (NULL, TRUE);

      /* Redo special stuff.  */
      ldemul_after_allocation ();

      /* Do the assignments again.  */
      lang_do_assignments (lang_final_phase_enum);
    }
  reloc_s->contents = reloc_d;
}

bfd_boolean
pe_bfd_is_dll (bfd *abfd)
{
  return (bfd_get_format (abfd) == bfd_object
          && obj_pe (abfd)
          && pe_data (abfd)->dll);
}
@


1.146
log
@Remove trailing white spaces in ld

	* deffilep.y: Remove trailing white spaces.
	* elf-hints-local.h: Likewise.
	* ldexp.c: Likewise.
	* ldlang.h: Likewise.
	* ldmisc.c: Likewise.
	* ldwrite.c: Likewise.
	* pe-dll.c: Likewise.
	* emulparams/criself.sh: Likewise.
	* emulparams/crislinux.sh: Likewise.
	* emulparams/elf32_tic6x_le.sh: Likewise.
	* emulparams/elf32bmipn32-defs.sh: Likewise.
	* emulparams/elf32mb_linux.sh: Likewise.
	* emulparams/elf32mep.sh: Likewise.
	* emulparams/elf32microblaze.sh: Likewise.
	* emulparams/elf32ppc.sh: Likewise.
	* emulparams/elf64_s390.sh: Likewise.
	* emulparams/elf64alpha.sh: Likewise.
	* emulparams/elf_s390.sh: Likewise.
	* emulparams/elf_x86_64.sh: Likewise.
	* emulparams/tic80coff.sh: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/cr16elf.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/tic6xdsbt.em: Likewise.
@
text
@d785 4
a788 1
	  if (strchr (pe_def_file->exports[i].name, '@@'))
d795 1
a795 1
	      char *tmp_at = strchr (tmp, '@@');
@


1.145
log
@	PR ld/14357
	* ldmain.c (trace_file_tries): Rename to 'verbose'.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldmain.h: Likewise.
	* lexsup.c: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultemp/spuelf.em: Likewise.
	* pe-dll.c (pe_dll_generate_implib): Only print creation message
	in verbose mode.
@
text
@d2847 1
a2847 1
  
d2928 1
a2928 1
  
@


1.144
log
@2012-05-07  Tristan Gingold  <gingold@@adacore.com>

	* pe-dll.c (udef_table): Make it static.
@
text
@d2716 3
a2718 2
  /* xgettext:c-format */
  info_msg (_("Creating library file: %s\n"), impfilename);
@


1.143
log
@Replace all uses of bfd_abs_section, bfd_com_section, bfd_und_section
and bfd_ind_section with their _ptr variants, or use corresponding
bfd_is_* macros.
@
text
@d2829 1
a2829 1
struct key_value *udef_table;
@


1.142
log
@2012-03-14  Kai Tietz  <ktietz@@redhat.com>
	    Pascal Obry  <pascal@@obry.net>

	* pe-dll.c (found_sym): New static variable.
	(undef_count): Likewise.
	(key_value): New structure.
	(undef_sort_cmp): Compare routine for qsort/bsearch.
	(pe_find_cdecl_alias_match): Add new argument.
	(pe_undef_alias_cdecl_match): Removed.
	(pe_undef_count): New helper routine.
	(pe_create_undef_table): Likewise.
	(pe_process_import_defs): Use pe_create_undef_table and
	new pe_undef_alias_cdecl_match function.
@
text
@d723 4
a726 3
	      bfd_boolean would_export = symbols[j]->section != &bfd_und_section
		      && ((symbols[j]->flags & BSF_GLOBAL)
			  || (symbols[j]->flags == 0));
d1355 1
a1355 1
	  if (s->output_section == &bfd_abs_section)
d1412 1
a1412 1
				|| h2->root.u.def.section == &bfd_abs_section)
d1771 1
a1771 1
#define UNDSEC (asection *) &bfd_und_section
@


1.141
log
@        * deffilep.y (cmp_import_elem): Sort first by module name.
        * pe-dll.c (process_def_file_and_drectve): Free strings
        from removed export-element.
        (add_bfd_to_link): Optimize loop on import-elements and lower
        allocated memory.
        (pe_implied_import_dll): Pass NULL instead of 0 for pointer
        argument.
@
text
@d2820 118
a2937 1
static struct bfd_link_hash_entry *found_sym;
d2940 1
a2940 1
pe_undef_alias_cdecl_match (struct bfd_link_hash_entry *h, void *inf)
d2942 1
a2942 11
  int sl;
  char *string = inf;
  const char *hs = h->root.string;

  sl = strlen (string);
  if (h->type == bfd_link_hash_undefined
      && ((*hs == '@@' && (!pe_details->underscored || *string == '_')
	   && strncmp (hs + 1, string + (pe_details->underscored != 0),
		       sl - (pe_details->underscored != 0)) == 0)
	  || strncmp (hs, string, sl) == 0)
      && h->root.string[sl] == '@@')
d2944 9
a2952 2
      found_sym = h;
      return FALSE;
d2957 2
a2958 2
static struct bfd_link_hash_entry *
pe_find_cdecl_alias_match (char *name)
d2960 14
a2973 4
  found_sym = 0;
  bfd_link_hash_traverse (link_info.hash, pe_undef_alias_cdecl_match,
			  (char *) name);
  return found_sym;
d3005 2
d3032 2
d3057 2
d3061 4
a3064 1
	    include_jmp_stub = TRUE;
d3066 1
a3066 1
	  if (is_cdecl && !blhe)
d3069 1
a3069 1
	      blhe = pe_find_cdecl_alias_match (name);
d3071 2
d3077 1
a3077 1
	  if (blhe && blhe->type == bfd_link_hash_undefined)
d3108 7
@


1.140
log
@	* pe-dll.c (auto_export): Use bsearch to speed up scan of exports
	table.
	(process_def_file_and_drectve): Maintain sorting of exports table
	after stripping leading @@ signs.
@
text
@a836 10
  exported_symbol_offsets = xmalloc (NE * sizeof (bfd_vma));
  exported_symbol_sections = xmalloc (NE * sizeof (struct bfd_section *));

  memset (exported_symbol_sections, 0, NE * sizeof (struct bfd_section *));
  max_ordinal = 0;
  min_ordinal = 65536;
  count_exported = 0;
  count_exported_byname = 0;
  count_with_ordinals = 0;

d865 6
d881 10
d2870 1
d2872 1
d2879 2
d2883 6
a2888 1
      int i, do_this_dll;
d2892 24
a2915 3
      for (i = 0; dll_symname[i]; i++)
	if (!ISALNUM (dll_symname[i]))
	  dll_symname[i] = '_';
d2917 15
a2931 1
      do_this_dll = 0;
d2933 4
a2936 39
      for (i = 0; i < pe_def_file->num_imports; i++)
	if (pe_def_file->imports[i].module == module)
	  {
	    def_file_export exp;
	    struct bfd_link_hash_entry *blhe;
	    int lead_at = (*pe_def_file->imports[i].internal_name == '@@');
	    /* See if we need this import.  */
	    size_t len = strlen (pe_def_file->imports[i].internal_name);
	    char *name = xmalloc (len + 2 + 6);
	    bfd_boolean include_jmp_stub = FALSE;
	    bfd_boolean is_cdecl = FALSE;
	    if (!lead_at && strchr (pe_def_file->imports[i].internal_name, '@@') == NULL)
	        is_cdecl = TRUE;

 	    if (lead_at)
	      sprintf (name, "%s",
		       pe_def_file->imports[i].internal_name);
	    else
	      sprintf (name, "%s%s",U (""),
		       pe_def_file->imports[i].internal_name);

	    blhe = bfd_link_hash_lookup (linfo->hash, name,
					 FALSE, FALSE, FALSE);

	    /* Include the jump stub for <sym> only if the <sym>
	       is undefined.  */
	    if (!blhe || (blhe && blhe->type != bfd_link_hash_undefined))
	      {
		if (lead_at)
		  sprintf (name, "%s%s", "__imp_",
			   pe_def_file->imports[i].internal_name);
		else
		  sprintf (name, "%s%s%s", "__imp_", U (""),
			   pe_def_file->imports[i].internal_name);

		blhe = bfd_link_hash_lookup (linfo->hash, name,
					     FALSE, FALSE, FALSE);
	      }
	    else
d2938 1
d2940 25
a2964 33
	    if (is_cdecl && !blhe)
	      {
		sprintf (name, "%s%s",U (""),
		         pe_def_file->imports[i].internal_name);
		blhe = pe_find_cdecl_alias_match (name);
		include_jmp_stub = TRUE;
	      }

	    free (name);

	    if (blhe && blhe->type == bfd_link_hash_undefined)
	      {
		bfd *one;
		/* We do.  */
		if (!do_this_dll)
		  {
		    bfd *ar_head = make_head (output_bfd);
		    add_bfd_to_link (ar_head, ar_head->filename, linfo);
		    do_this_dll = 1;
		  }
		exp.internal_name = pe_def_file->imports[i].internal_name;
		exp.name = pe_def_file->imports[i].name;
		exp.its_name = pe_def_file->imports[i].its_name;
		exp.ordinal = pe_def_file->imports[i].ordinal;
		exp.hint = exp.ordinal >= 0 ? exp.ordinal : 0;
		exp.flag_private = 0;
		exp.flag_constant = 0;
		exp.flag_data = pe_def_file->imports[i].data;
		exp.flag_noname = exp.name ? 0 : 1;
		one = make_one (&exp, output_bfd, (! exp.flag_data) && include_jmp_stub);
		add_bfd_to_link (one, one->filename, linfo);
	      }
	  }
d3189 1
a3189 1
				     dllname, i, 0, NULL, &is_dup);
@


1.139
log
@	* pe-dll.c (generate_reloc): Don't emit a base reloc for an
	underlying BFD reloc that will be discarded in eh_frame data.
@
text
@d3 1
a3 1
   2008, 2009, 2010, 2011 Free Software Foundation, Inc.
d532 1
a532 1
  int i;
d535 2
a536 1
  const char * libname = 0;
d540 6
a545 3
  for (i = 0; i < d->num_exports; i++)
    if (strcmp (d->exports[i].name, n) == 0)
      return 0;
d651 1
d758 1
d777 2
d799 1
d804 6
a846 2
  qsort (pe_def_file->exports, NE, sizeof (pe_def_file->exports[0]),
	 pe_export_sort);
@


1.138
log
@Check if a symbol is hidden by linker script.

bfd/

2011-09-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12975
	* bfd-in.h (bfd_elf_size_dynamic_sections): Remove pointer
	to struct bfd_elf_version_tree.

	* elflink.c (elf_info_failed): Remove verdefs.
	(_bfd_elf_export_symbol): Updated.
	_bfd_elf_link_assign_sym_version): Likewise.
	(bfd_elf_size_dynamic_sections): Remove pointer to struct
	bfd_elf_version_tree.  Updated.
	(bfd_elf_gc_mark_dynamic_ref_symbol): Check if a symbol is hidden
	by linker script.

	* linker.c (bfd_hide_sym_by_version): New.

	* bfd-in2.h: Regenerated.

include/

2011-09-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12975
	* bfdlink.h (bfd_link_info): Add version_info.

ld/

2011-09-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12975
	* ldlang.c (lang_elf_version_info): Removed.
	(lang_register_vers_node): Replace lang_elf_version_info with
	link_info.version_info.
	(lang_add_vers_depend): Likewise.
	* pe-dll.c (process_def_file_and_drectve): Likewise.
	* emultempl/solaris2.em (elf_solaris2_before_allocation): Likewise.

	* ldlang.h (lang_elf_version_info): Removed.

	* plugin.c  (is_visible_from_outside): Check if symbol is hidden
	by version script.

	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation):
	Remove lang_elf_version_info.

ld/testsuite/

2011-09-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12975
	* ld-elf/pr12975.d: New.
	* ld-elf/pr12975.s: Likewise.
	* ld-elf/pr12975.t: Likewise.
@
text
@d1398 9
@


1.138.2.1
log
@	* pe-dll.c (generate_reloc): Don't emit a base reloc for an
	underlying BFD reloc that will be discarded in eh_frame data.
@
text
@a1397 9
		  /* Nor for Dwarf FDE references to discarded sections.  */
		  else if (bfd_is_abs_section (sym->section->output_section))
		    {
		      /* We only ignore relocs from .eh_frame sections, as
			 they are discarded by the final link rather than
			 resolved against the kept section.  */
		      if (!strcmp (s->name, ".eh_frame"))
			continue;
		    }
@


1.137
log
@	PR ld/12726
	* ldexp.h (lang_phase_type): Add lang_assigning_phase_enum.
	* ldexp.c (exp_fold_tree_1): Correct assign to dot comment.  Don't
	assign to dot when lang_assigning_phase_enum.
	* ldlang.h (lang_do_assignments): Update prototype.
	* ldlang.c (lang_do_assignments): Add phase parameter.  Update all
	callers.
	* pe-dll.c (pe_dll_fill_sections, pe_exe_fill_sections): Update
	lang_do_assignments calls.
@
text
@d721 4
a724 7
	      if (lang_elf_version_info && would_export)
		{
		  bfd_boolean hide = 0;
		  (void) bfd_find_version_for_sym (lang_elf_version_info,
				symbols[j]->name, &hide);
		  would_export = !hide;
		}
@


1.136
log
@2011-04-13  Kai Tietz  <ktietz@@redhat.com>

	PR binutils/12658
	* deffile.h (def_file_add_export): Add is_dup argument.
	(def_file_add_import): Likewise.
	* deffilep.y (are_names_equal): New helper.
	(cmp_export_elem): New helper.
	(find_export_in_list): Add search routine for exports.
	(def_file_add_export): Check for duplicates.
	(cmp_import_elem): New helper.
	(find_import_in_list): Add search routine for imports.
	(def_file_add_import): Check for duplicates.
	(def_exports): Handle duplicates.
	(def_imports): Likewise.
	* pe-dll.c (process_def_file_and_drectve): Likewise.
	(pe_implied_import_dll): Likewise.
@
text
@d3 1
a3 1
   2008, 2009, 2010 Free Software Foundation, Inc.
d3235 1
a3235 1
      lang_do_assignments ();
d3267 1
a3267 1
      lang_do_assignments ();
@


1.135
log
@2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* emultempl/beos.em (sort_by_file_name): Use filename_(n)cmp.
	* emultempl/elf32.em (gld${EMULATION_NAME}_vercheck):
	Likewise.
	(gld${EMULATION_NAME}_stat_needed): Likewise.
	(gld${EMULATION_NAME}_check_needed): Likewise.
	* emultempl/pe.em (gld_${EMULATION_NAME}_after_open): Likewise.
	(gld_${EMULATION_NAME}_unrecognized_file): Likewise.
	* emultempl/pep.em (gld_${EMULATION_NAME}_after_open): Likewise.
	(gld_${EMULATION_NAME}_unrecognized_file): Likewise.
	* ldfile.c (ldfile_open_file): Likewise.
	* ldlang.c (wild_sort): Likewise.
	(lookup_name): Likewise.
	(check_excluded_libs): Likewise.
	* ldmisc.c (vfinfo): Likewise.
	* pe-dll.c (libnamencmp): Likewise.
	(auto_export): Likewise.
	(pe_dll_generate_implib): Likewise.
	* testplug.c (onclaim_file): Likewise.
@
text
@d754 1
d756 2
a757 1
		      p=def_file_add_export (pe_def_file, sn, 0, -1, NULL);
d759 2
a760 1
		      p->flag_data = !(symbols[j]->flags & BSF_FUNCTION);
d807 1
d815 3
a817 3
				     -1, NULL);
	      else
		free (tmp);
d3153 1
d3162 1
a3162 1
				     dllname, i, 0, NULL);
d3164 2
a3165 1
 	  imp->data = is_data;
@


1.134
log
@2011-02-15  Kai Tietz  <kai.tietz@@onevision.com>

        * pe-dll.c (process_def_file_and_drectve): Don't strip
        leading underscore from symbol by calling bfd_find_version_for_sym.
@
text
@d27 1
d347 1
a347 1
  if (strncmp (libname, afptr->name, afptr->len))
d623 1
a623 1
	      && ((strcmp (libname, ex->string) == 0)
d629 1
a629 1
	  if (strcmp (abfd->filename, ex->string) == 0)
d2705 1
a2705 1
	  found = (strcmp (ex->string, ibfd->filename) == 0);
d2735 1
a2735 1
		  if (strcmp (newbfd->filename, ibfd->filename) == 0)
@


1.133
log
@fix set but unused variable warnings
@
text
@a722 1
		  char ofs = pe_details->underscored && symbols[j]->name[0] == '_';
d724 1
a724 1
				symbols[j]->name + ofs, &hide);
@


1.133.2.1
log
@	PR ld/12726
	* ldexp.h (lang_phase_type): Add lang_assigning_phase_enum.
	* ldexp.c (exp_fold_tree_1): Correct assign to dot comment.  Don't
	assign to dot when lang_assigning_phase_enum.
	* ldlang.h (lang_do_assignments): Update prototype.
	* ldlang.c (lang_do_assignments): Add phase parameter.  Update all
	callers.
	* pe-dll.c (pe_dll_fill_sections, pe_exe_fill_sections): Update
	lang_do_assignments calls.
@
text
@d3 1
a3 1
   2008, 2009, 2010, 2011 Free Software Foundation, Inc.
d3229 1
a3229 1
      lang_do_assignments (lang_final_phase_enum);
d3261 1
a3261 1
      lang_do_assignments (lang_final_phase_enum);
@


1.132
log
@	PR ld/11603
	* pe-dll.c (process_def_file_and_drectve): Reorder check for
	forwarded export name after check for ordinary export.
@
text
@d1157 1
a1157 1
  eaddresses = edata_d + 40;
a1249 1
      int nsyms;
a1257 1
      nsyms = bfd_get_symcount (b);
a1326 1
	  int nsyms;
a1352 1
	  nsyms = bfd_get_symcount (b);
a1366 1
		  bfd_vma sym_vma;
a1397 5
		  sym_vma = (relocs[i]->addend
			     + sym->value
			     + sym->section->vma
			     + sym->section->output_offset
			     + sym->section->output_section->vma);
d2985 1
a2985 1
  bfd_vma name_rvas, ordinals, nexp, ordbase;
a3118 2
  ordinals = pe_as32 (expdata + 36);
  ordbase = pe_as32 (expdata + 16);
@


1.131
log
@2010-05-15  Kai Tietz  <kai.tietz@@onevision.com>

	* emultempl/pe.em (is_underscoring): New helper function.
	(gld_${EMULATION_NAME}_before_parse): Replace code
	for pe(p)_leading_underscore detection by is_underscoring.
	(U): Likewise.
	(GET_INIT_SYMBOL_NAME): Likewise.
	(U_SIZE): Likewise.
	(set_pe_name):
	(set_entry_point):
	(gld_${EMULATION_NAME}_set_symbols):
	* emultempl/pep.em: Likewise.
	* pe-dll.c (pe_detail_list): Set default
	underscoring for x64 target.
	(pe_dll_id_target): Add initialization of
	pe(p)_leading_underscore.
@
text
@a873 22

      /* Check for forward exports */
      if (strchr (pe_def_file->exports[i].internal_name, '.'))
	{
	  count_exported++;
	  if (!pe_def_file->exports[i].flag_noname)
	    count_exported_byname++;

	  pe_def_file->exports[i].flag_forward = 1;

	  if (pe_def_file->exports[i].ordinal != -1)
	    {
	      if (max_ordinal < pe_def_file->exports[i].ordinal)
		max_ordinal = pe_def_file->exports[i].ordinal;
	      if (min_ordinal > pe_def_file->exports[i].ordinal)
		min_ordinal = pe_def_file->exports[i].ordinal;
	      count_with_ordinals++;
	    }

	  continue;
	}

d913 22
@


1.130
log
@	* pe-dll.c: Removed trailing whitespaces.
@
text
@d264 3
d268 1
d423 3
a425 2
	if (u != -1)
	  pe_detail_list[i].underscored = (u != 0 ? TRUE : FALSE);
d427 1
@


1.129
log
@2010-04-27  Kai Tietz  <kai.tietz@@onevision.com>

        * pe-dll.c (_nm_-symbols): Use always underscored variant
        for symbols.
        (__imp_-symbols): Likewise.
        (___imp_-symbols): Likewise.
        * NEWS: Mention ABI change for x64 PE-COFF.

PS: Sorry, missed this part of approved patch.
@
text
@d188 1
a188 1
  const autofilter_entry_type* autofilter_symbollist; 
d225 1
a225 1
#endif  
d576 1
a576 1
      afptr = pe_details->autofilter_symbollist; 
d1368 1
a1368 1
		  /* Don't create relocs for undefined weak symbols.  */ 
d2425 1
a2425 1
  /* For relocator v2 we have to use the .idata$5 element and not 
@


1.128
log
@2010-04-05  Kai Tietz  <kai.tietz@@onevision.com>

	* emultempl/pep.em (U): Macro modified.
	(U_SIZE): New helper macro.
	(GET_INIT_SYMBOL_NAME): Likewise.
	(enum options): Add OPTION_NO_LEADING_UNDERSCORE
	and OPTION_LEADING_UNDERSCORE enumerator-values.
	(gld${EMULATION_NAME}_add_options): Add --(no-)leading-underscore
	option.
	(definfo): Add new member is_c_symbol.
	(D): Add to macro underscore mode parameter.
	(init): Add definition for is_c_symbol.
	(gld_${EMULATION_NAME}_list_options): Display new options.
	(set_pep_name): Adjust underscoring dependent fixed
	symbol handling.
	(gld_${EMULATION_NAME}_set_symbols): Likewise.
	(saw_option): Likewise.
	(gld_${EMULATION_NAME}_unrecognized_file): Likewise.
	(set_entry_point): Initial initial_symbol_char dependent to
	target's default and new option flag pep_leading_underscore.
	* emultempl/pe.em (U): Macro modified.
	(U_SIZE): New helper macro.
	(GET_INIT_SYMBOL_NAME): Likewise.
	(OPTION_LEADING_UNDERSCORE): Add new option define.
	(OPTION_NO_LEADING_UNDERSCORE): Likewise.
	(gld${EMULATION_NAME}_add_options): Add --(no-)leading-underscore
	option.
	(definfo): Add new member is_c_symbol.
	(D): Add to macro underscore mode parameter.
	(init): Add definition for is_c_symbol.
	(gld_${EMULATION_NAME}_list_options): Display new options.
	(set_pep_name): Adjust underscoring dependent fixed
	symbol handling.
	(gld_${EMULATION_NAME}_set_symbols): Likewise.
	(saw_option): Likewise.
	(gld_${EMULATION_NAME}_unrecognized_file): Likewise.
	(set_entry_point): Initial initial_symbol_char dependent to
	target's default and new option flag pep_leading_underscore.
	* pe-dll.c (pe_leading_underscore): New flag variable.
	(pe_detail_list): Remove const to allow modify of
	member underscore.
	(pe_dll_id_target): Initialize pe_details' underscore variable
	dependent to target's default and flag pe_leading_underscore.
	* pe-dll.h (pe_leading_underscore): Add extern declaration of
	option flag.
	* pep-dll.c (pe_leading_underscore): Add alias define for
	pep_leading_underscore.
	* pep-dll.h (pep_leading_underscore) Add extern declaration of
	option flag.
	* ld.texinfo: Add documentation for --(no-)leading-underscore
	option.
@
text
@d388 1
a388 1
  { STRING_COMMA_LEN ("_nm_") },
d2138 1
a2138 1
	quick_symbol (abfd, U ("_nm_"), U (""), exp->internal_name, id6,
d2142 1
a2142 1
    quick_symbol (abfd, U ("__imp_"), exp->internal_name, "", id5,
d2289 1
a2289 1
  quick_symbol (abfd, U ("_imp_"), import, "", id5, BSF_GLOBAL, 0);
d2330 2
a2331 2
  quick_symbol (abfd, U ("_nm_thnk_"), import, "", id4, BSF_GLOBAL, 0);
  quick_symbol (abfd, U ("_nm_"), import, "", UNDSEC, BSF_GLOBAL, 0);
d2423 1
a2423 1
  quick_symbol (abfd, U ("_nm_thnk_"), name, "", UNDSEC, BSF_GLOBAL, 0);
d2428 1
a2428 1
    quick_symbol (abfd, U ("_imp_"), name, "", UNDSEC, BSF_GLOBAL, 0);
d2498 1
a2498 1
      quick_symbol (abfd, U ("_imp_"), name, "", UNDSEC, BSF_GLOBAL, 0);
d2591 1
a2591 1
  sprintf (buf, U ("_imp_%s"), name);
d2594 1
a2594 1
  sprintf (buf, U ("_nm_thnk_%s"), name);
d2806 3
a2808 2
      && ((*hs == '@@' && *string == '_'
	   && strncmp (hs + 1, string + 1, sl - 1) == 0)
d3153 1
a3153 1
      if (! CONST_STRNEQ (erva + name_rva, "_nm_"))
@


1.127
log
@        * pe-dll.c (make_one): Make text section readonly.
        (make_one): Add *ABS* symbol @@feat.00 with value 1 to tag
        the jump stub on X86 as /SAFESEH compatible for
        native toolchains.
@
text
@d161 1
d248 3
a250 1
static const pe_details_type pe_detail_list[] =
d416 5
@


1.126
log
@	* pe-dll.c (generate_reloc): Take account of wrapper options when
	testing if a weak symbol is defined or not, and when it is not,
	consider whether the default value requires a base reloc anyway.
@
text
@d3 1
a3 1
   2008, 2009 Free Software Foundation, Inc.
d2099 3
a2101 2
  symtab = xmalloc (11 * sizeof (asymbol *));
  tx  = quick_section (abfd, ".text",    SEC_CODE|SEC_HAS_CONTENTS, 2);
d2150 3
@


1.125
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d1364 1
a1364 1
			= bfd_link_hash_lookup (info->hash, sym->name,
d1366 21
a1386 2
		      if (!blhe || blhe->type != bfd_link_hash_defined)
			continue;		      
@


1.124
log
@2009-11-27  Tristan Gingold  <gingold@@adacore.com>

	* pe-dll.c (pe_implied_import_dll): Return early if there is no
	export entries.
@
text
@d1309 1
a1309 1
      int relsize, nrelocs, i;
d2369 1
a2369 1
			 const char *dll_symname,
d2393 1
a2393 1
  quick_symbol (abfd, U (""), dll_symname, "_iname", UNDSEC, BSF_GLOBAL, 0);
d2577 1
a2577 1
      bfd *b = make_singleton_name_thunk (name, link_info.output_bfd);
d2598 1
a2598 1
      char * dll_symname = pe_data_import_dll ? pe_data_import_dll : "unknown";
d2600 1
a2600 1
      b = make_import_fixup_entry (name, fixup_name, dll_symname,
d2796 1
a2796 1
add_bfd_to_link (bfd *abfd, const char *name, struct bfd_link_info *link_info)
d2806 1
a2806 1
  if (!bfd_link_add_symbols (abfd, link_info))
d2811 1
a2811 1
pe_process_import_defs (bfd *output_bfd, struct bfd_link_info *link_info)
d2853 1
a2853 1
	    blhe = bfd_link_hash_lookup (link_info->hash, name,
d2867 1
a2867 1
		blhe = bfd_link_hash_lookup (link_info->hash, name,
d2890 1
a2890 1
		    add_bfd_to_link (ar_head, ar_head->filename, link_info);
d2903 1
a2903 1
		add_bfd_to_link (one, one->filename, link_info);
d2909 1
a2909 1
	  add_bfd_to_link (ar_tail, ar_tail->filename, link_info);
d2958 1
a2958 1
  const char *dll_name;
d3097 1
a3097 1
  dll_name = erva + pe_as32 (expdata + 12);
d3102 1
a3102 1
  if (def_get_module (pe_def_file, dll_name))
d3105 1
a3105 1
	printf ("%s is already loaded\n", dll_name);
d3131 1
a3131 1
				     dll_name, i, 0, NULL);
d3137 1
a3137 1
		    __FUNCTION__, dll_name, erva + name_rva,
@


1.123
log
@2009-11-15  Kai Tietz  <kai.tietz@@onevision.com>

	* pe-dll.c (pe_undef_alias_cdecl_match): New function.
	(pe_find_cdecl_alias_match): New function.
	(pe_process_import_defs): Add matching for import symbols
	declared as cdecl for fastcall/stdcall.
	* emultempl/pe.em (pe_undef_cdecl_match): Treat fastcall
	symbols, too.
	(pe_fixup_stdcalls): Likewise.
	(gld_XXX_after_open): Redo scanning for imported
	fastcall/stdcall symbols as cdecl one.
	* emultempl/pep.em (pep_undef_cdecl_match): Treat fastcall
	symbols, too.
	(pep_fixup_stdcalls): Likewise.
	(gld_XXX_after_open): Redo scanning for imported
	fastcall/stdcall symbols as cdecl one.

2009-11-15  Kai Tietz  <kai.tietz@@onevision.com>

	* ld-pe/direct2_client.c: New file.
	* ld-pe/direct2_dll.c: Likewise.
	* ld-pe/direct2_dll.def: Likewise.
	* ld-pe/pe-run2.exp: Likewise.
@
text
@d2984 1
a2984 1
  /* Get pe_header, optional header and numbers of export entries.  */
d2993 2
a2994 1
  if (num_entries < 1) /* No exports.  */
d3005 4
@


1.122
log
@2009-10-23  Kai Tietz  <kai.tietz@@onevision.com>

	* deffile.h (def_file_export): New member its_name.
	(def_file_import): Likewise.
	(def_file_add_export): Add argument its_name.
	(def_file_add_import): Likewise.
	* deffilep.y (def_exports): Add argument its_name.
	(def_import): Likewise.
	(EQUAL): Add new token for '=='.
	(opt_equalequal_name): New rule.
	(expline): Add rule opt_equalequal_name.
	(impline): Likewise.
	(def_file_free): Free for exports and imports
	the optional member its_name.
	(def_lex): Add scan of '==' as EQUAL.
	* pe-dll.c (pe_export_sort): Sort for its_name too.
	(process_def_file_and_drectve): Adjust calls to
	def_file_add_export.
	(generate_edata): Take its_name in account.
	(make_one): Likewise.
	(pe_process_import_defs): Likewise.
	(pe_dll_generate_def_file): Add print of new '==' option.
	* ld.texinfo: Extend documentation about .def file syntax.
	* NEWS: Mention new feature.
@
text
@d2764 31
d2842 3
d2873 8
@


1.121
log
@        * emultempl/pe.em (OPTION_EXCLUDE_ALL_SYMBOLS): New macro.
        (gld${EMULATION_NAME}_add_options): Add new --exclude-all-symbols option
        to exclude all symbols from automatic export.
        (gld_${EMULATION_NAME}_list_options): Describe it.
        (gld${EMULATION_NAME}_handle_option): Handle it.
        * emultempl/pep.em: Likewise to all the above.
        * pe-dll.c (pe_dll_exclude_all_symbols): New variable.
        (process_def_file_and_drectve): Use it.
        * pe-dll.h (pe_dll_exclude_all_symbols): Declare.
        * pep-dll.c (pep_dll_exclude_all_symbols): Define pep_ alias.
        * pep-dll.h (pe_dll_exclude_all_symbols): Declare.
        * NEWS: Mention the new feature.
        * ld.texinfo: Document the new command line switch.
@
text
@d445 6
d452 1
a452 1
  return strcmp (a->name, b->name);
d741 1
a741 1
		      p=def_file_add_export (pe_def_file, sn, 0, -1);
d797 1
a797 1
				     -1);
d1058 4
a1061 1
	  name_table_size += strlen (pe_def_file->exports[i].name) + 1;
d1207 2
d1691 6
d2203 4
a2206 1
      len = 2 + strlen (exp->name) + 1;
d2215 4
a2218 1
      strcpy ((char *) d6 + 2, exp->name);
d2853 1
d3084 1
a3084 1
				     dll_name, i, 0);
@


1.120
log
@==> bfd/ChangeLog <==
2009-05-19  Dave Korn  <dave.korn.cygwin@@gmail.com>

	* cofflink.c (process_embedded_commands):  Ignore "-aligncomm".

==> gas/ChangeLog <==
2009-05-19  Dave Korn  <dave.korn.cygwin@@gmail.com>

	* NEWS:  Mention new feature.
	* config/obj-coff.c (obj_coff_common_parse):  New function.
	(obj_coff_comm):  Likewise.
	(coff_pseudo_table):  Override default ".comm" definition on PE.
	* doc/as.texinfo:  Document new feature.

==> gas/testsuite/ChangeLog <==
2009-05-19  Dave Korn  <dave.korn.cygwin@@gmail.com>

	* gas/pe/:  New directory for PE format-specific tests.
	* gas/pe/aligncomm-a.d:  New test pattern file.
	* gas/pe/aligncomm-a.s:  New test source file.
	* gas/pe/aligncomm-b.d:  New test pattern file.
	* gas/pe/aligncomm-b.s:  New test source file.
	* gas/pe/aligncomm-c.d:  New test pattern file.
	* gas/pe/aligncomm-c.s:  New test source file.
	* gas/pe/aligncomm-d.d:  New test pattern file.
	* gas/pe/aligncomm-d.s:  New test source file.
	* gas/pe/pe.exp:  New test control script.
	* lib/gas-defs.exp (is_pecoff_format):  New function.

==> ld/ChangeLog <==
2009-05-19  Dave Korn  <dave.korn.cygwin@@gmail.com>

	* NEWS:  Mention new feature.
	* deffile.h (def_file_aligncomm):  Add new struct definition.
	(def_file):  Add new def_file_aligncomm member.
	* deffilep.y (%token):  Add new ALIGNCOMM token.
	(command):  Add production rule for ALIGNCOMM.
	(def_file_free):  Free any chained def_file_aligncomm structs.
	(diropts[]):  Add entry for '-aligncomm' .drectve command.
	(def_aligncomm):  New grammar function.
	* ld.texinfo:  Document new feature.
	* pe-dll.c (process_def_file):  Rename from this ...
	(process_def_file_and_drectve):  ... to this, updating all callers,
	and process any aligncomms chained to the def file after scanning
	all .drectve sections.
	(generate_edata):  Updated to match.
	(pe_dll_build_sections):  Likewise.

==> ld/testsuite/ChangeLog <==
2009-05-19  Dave Korn  <dave.korn.cygwin@@gmail.com>

	* ld-pe/aligncomm-1.c:  New test source file.
	* ld-pe/aligncomm-2.c:  Likewise.
	* ld-pe/aligncomm-3.c:  Likewise.
	* ld-pe/aligncomm-4.c:  Likewise.
	* ld-pe/aligncomm.d:  New test pattern file.

	* ld-pe/direct.exp:  Deleted, and content moved into ...
	* ld-pe/pe-run.exp:  ... New common file for all PE run tests.

	* ld-pe/vers-script.exp:  Deleted, and content merged into ...
	* ld-pe/pe-compile.exp:  ... New common file for PE tests needing
	a compiler, adding aligned common tests.

	* ld-pe/pe.exp:  Update header comment.
@
text
@d152 1
d668 4
a671 4
  /* If we are not building a DLL, when there are no exports
     we do not build an export table at all.  */
  if (!pe_dll_export_everything && pe_def_file->num_exports == 0
      && info->executable)
d675 2
a676 1
  if (pe_dll_export_everything || pe_def_file->num_exports == 0)
@


1.120.4.1
log
@	* pe-dll.c (generate_reloc): Take account of wrapper options when
	testing if a weak symbol is defined or not, and when it is not,
	consider whether the default value requires a base reloc anyway.
@
text
@d1351 1
a1351 1
			= bfd_wrapped_link_hash_lookup (abfd, info, sym->name,
d1353 2
a1354 21
		      if (blhe && blhe->type == bfd_link_hash_undefweak)
			{
			  /* Check aux sym and see if it is defined or not. */
			  struct coff_link_hash_entry *h, *h2;
			  h = (struct coff_link_hash_entry *)blhe;
			  if (h->symbol_class != C_NT_WEAK || h->numaux != 1)
			    continue;
			  h2 = h->auxbfd->tdata.coff_obj_data->sym_hashes
						[h->aux->x_sym.x_tagndx.l];
			  /* We don't want a base reloc if the aux sym is not
			     found, undefined, or if it is the constant ABS
			     zero default value.  (We broaden that slightly by
			     not testing the value, just the section; there's
			     no reason we'd want a reference to any absolute
			     address to get relocated during rebasing).  */
			  if (!h2 || h2->root.type == bfd_link_hash_undefined
				|| h2->root.u.def.section == &bfd_abs_section)
			    continue;
			}
		      else if (!blhe || blhe->type != bfd_link_hash_defined)
			continue;
@


1.119
log
@Committed on behalf of

  2008-08-07  Aaron W. LaFramboise  <aaron98wiridge9@@aaronwl.com>

ld/ChangeLog:

	* pe-dll.c (process_def_file): Do not create empty export table.

ld/testsuite/ChangeLog:

	* ld-pe/exports.d: New file.
	* ld-pe/exports.s: New file.
	* ld-pe/pe.exp: New test for empty export table.
@
text
@d618 1
a618 1
process_def_file (bfd *abfd ATTRIBUTE_UNUSED, struct bfd_link_info *info)
d645 22
d1082 1
a1082 1
   been done in process_def_file().  */
d3091 1
a3091 1
  process_def_file (abfd, info);
@


1.118
log
@bfd/ChangeLog

	* elflink.c (find_version_for_sym):  Remove from here, ...
	* linker.c (bfd_find_version_for_sym):  ... rename, replace
	here, make public and update all callers.
	* bfd-in2.h:  Regenerate.

ld/ChangeLog

	* NEWS:  Mention new feature.
	* ld.texinfo (--version-script):  Document extent of PE support.
	(WIN32):  Mention --version-script.  Extend auto-export description.
	* pe-dll.c (process_def_file):  Use version script info to filter
	symbols from auto-export.
	* testsuite/ld-pe/vers-script-1.d:  New file.
	* testsuite/ld-pe/vers-script-2.d:  New file.
	* testsuite/ld-pe/vers-script-3.d:  New file.
	* testsuite/ld-pe/vers-script-4.d:  New file.
	* testsuite/ld-pe/vers-script-1.ver:  New file.
	* testsuite/ld-pe/vers-script-2.ver:  New file.
	* testsuite/ld-pe/vers-script-3.ver:  New file.
	* testsuite/ld-pe/vers-script-4.ver:  New file.
	* testsuite/ld-pe/vers-script-dll.c:  New file.
	* testsuite/ld-pe/vers-script.exp:  New test script.
@
text
@d723 4
@


1.117
log
@bfd/ChangeLog

	* coff-alpha.c (alpha_ecoff_backend_data):  Initialise fields which
	control long section name handling with ECOFF_NO_LONG_SECTION_NAMES.
	* coff-mips.c (mips_ecoff_backend_data):  Likewise.
	* coff-rs6000.c (bfd_xcoff_backend_data):  Initialise fields which
	control long section name handling with XCOFF_NO_LONG_SECTION_NAMES.
	(bfd_pmac_xcoff_backend_data):  Likewise.
	* coff64-rs6000.c (bfd_xcoff_backend_data):  Likewise.
	(bfd_xcoff_aix5_backend_data):  Likewise.
	(xcoff64_write_object_contents):  Delete unused long_section_names
	local variable.
	* coff-sh.c (bfd_coff_small_swap_table):  Initialise long section
	name members using COFF_DEFAULT_LONG_SECTION_NAMES and make entire
	struct non-const.
	* coffcode.h (documentation):  Update to describe long section names.
	(COFFLONGSECTIONCATHELPER):  New helper macro.
	(BLANKOR1TOODD):  Likewise.
	(COFF_ENABLE_LONG_SECTION_NAMES):  Likewise.
	(COFF_LONG_SECTION_NAMES_SETTER):  Likewise.
	(COFF_DEFAULT_LONG_SECTION_NAMES):  Likewise.
	(bfd_coff_set_long_section_names_allowed):  New function.
	(bfd_coff_set_long_section_names_disallowed):  Likewise.
	(struct bfd_coff_backend_data):  Add new backend hook function
	pointer _bfd_coff_set_long_section_names.
	(bfd_coff_set_long_section_names):  New backend hook.
	(coff_write_object_contents):  Only generate long section names if
	bfd_coff_long_section_names() indicates they are currently enabled.
	(bfd_coff_std_swap_table):  Make non-const, and initialise long
	section name fields using COFF_DEFAULT_LONG_SECTION_NAMES.
	(ticoff0_swap_table):  Likewise to both.
	(ticoff1_swap_table):  Again, likewise to both.
	* coffgen.c (make_a_section_from_file):  Allow long section names
	as inputs even if not currently allowed for outputs.
	* ecoff.c (_bfd_ecoff_no_long_sections):  New function.
	* efi-app-ia32.c (COFF_LONG_SECTION_NAMES):  Define to 0, not blank.
	* efi-app-ia64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-app-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-bsdrv-ia32.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-bsdrv-ia64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-bsdrv-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-rtdrv-ia32.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-rtdrv-ia64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-rtdrv-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-arm.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-i386.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-mcore.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-mips.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-ppc.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-sh.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* libcoff-in.h:  Update copyright year to cause updated copyright
	year in generated libcoff.h, and fix typo.
	* libcoff.h:  Regenerated.
	* libecoff.h (ECOFF_NO_LONG_SECTION_NAMES):  New macro.
	(_bfd_ecoff_no_long_sections):  Add prototype.
	* libxcoff.h (XCOFF_NO_LONG_SECTION_NAMES):  New macro.
	* pe-mips.c (COFF_LONG_SECTION_NAMES):  Define empty if not already
	defined by an including .c file.
	* ticoff.h (ticoff0_swap_table):  Make non-const, and initialise
	long section name fields using COFF_DEFAULT_LONG_SECTION_NAMES.
	(ticoff1_swap_table):  Likewise to both.

ld/ChangeLog

	* ld.texinfo:  Update to mention long section name options.
	* NEWS:  Mention new behaviour and command-line options.
	* pe-dll.c (pe_use_coff_long_section_names):  New global variable.
	(pe_output_file_set_long_section_names):  New function.
	(pe_dll_build_sections):  Call it on output BFDs.
	(pe_exe_build_sections):  Likewise.
	(pe_dll_fill_sections):  Likewise.
	(pe_exe_fill_sections):  Likewise.
	* pe-dll.h (pe_use_coff_long_section_names):  Declare extern.
	(pe_output_file_set_long_section_names):  Add prototype.
	* pep-dll.c (pe_use_coff_long_section_names):  Define pep_ alias.
	(pe_output_file_set_long_section_names):  Likewise.
	* pep-dll.h (pep_use_coff_long_section_names):  Declare extern.
	(pep_output_file_set_long_section_names):  Add prototype.
	* pe.em (OPTION_ENABLE_LONG_SECTION_NAMES):  New getopt value macro.
	(OPTION_DISABLE_LONG_SECTION_NAMES):  Likewise.
	(gld${EMULATION_NAME}_add_options):  Add new options to xtra_long[].
	(gld_${EMULATION_NAME}_list_options):  Describe them.
	(gld${EMULATION_NAME}_handle_option):  Set or clear global
	pe_use_coff_long_section_names flag when options recognised.
	(gld_${EMULATION_NAME}_after_open):  En/disable long section names
	for main output bfd by calling pe_output_file_set_long_section_names.
	* pep.em (enum options):  Extend enum with new getopt option values.
	(gld${EMULATION_NAME}_add_options):  Add new options to xtra_long[].
	(gld_${EMULATION_NAME}_list_options):  Describe them.
	(gld${EMULATION_NAME}_handle_option):  Set or clear global
	pe_use_coff_long_section_names flag when options recognised.
	(gld_${EMULATION_NAME}_after_open):  En/disable long section names
	for main output bfd by calling pep_output_file_set_long_section_names.

ld/testsuite/ChangeLog

	* ld-pe/longsecn-1.d:  New test file.
	* ld-pe/longsecn-2.d:  Likewise.
	* ld-pe/longsecn-3.d:  Likewise.
	* ld-pe/longsecn-4.d:  Likewise.
	* ld-pe/longsecn-5.d:  Likewise.
	* ld-pe/longsecn.d:  Likewise.
	* ld-pe/longsecn.exp:  New test control script.
	* ld-pe/longsecn.s:  New test source file.
@
text
@d673 12
a684 3
	      if (symbols[j]->section != &bfd_und_section
		  && ((symbols[j]->flags & BSF_GLOBAL)
		      || (symbols[j]->flags == 0)))
@


1.116
log
@2009-01-26  Kai Tietz  <kai.tietz@@onevision.com>

        * pe-dll.c (tmp_seq2): New static variable.
        (make_singleton_name_imp): New.
        (make_import_fixup_entry): Use for v2 the _imp_<name> symbol and
        avoid duplicate import table generation for same symbol.
        (pe_create_runtime_relocator_reference): Make reference for
        64-bit 8 bytes.
@
text
@d3 1
a3 1
   2008 Free Software Foundation, Inc.
d159 1
d3037 9
d3055 1
d3063 1
d3070 1
d3072 1
d3079 1
d3111 1
@


1.115
log
@2009-01-08  Kai Tietz  <kai.tietz@@onevision.com>

	* pe.em (OPTION_USE_NUL_PREFIXED_IMPORT_TABLES): New.
	(gld..._add_options): Add new option
	--use-nul-prefixed-import-tables.
	(gld..._handle_option): Likewise.
	* pep.em: Same as for pe.em.
	* ld.texinfo: Add new option documentation for
	--use-nul-prefixed-import-tables.
	* pe-dll.c (pe_use_nul_prefixed_import_tables): New.
	(make_head): Make prefix leading zero prefix element for
	idata$4 and idata$5 dependent to new flag.
	(make_import_fixup_entry): Remove idata4/5 prefix.
	* pe-dll.h (pe_use_nul_prefixed_import_tables): New.
	* pep-dll.c (pe_use_nul_prefixed_import_tables): New.
	* pep-dll.h (pep_use_nul_prefixed_import_tables): New.
	* NEWS: Add new option.
@
text
@d1659 1
d2175 41
d2333 6
a2338 1
  quick_symbol (abfd, "", fixup_name, "", UNDSEC, BSF_GLOBAL, 0);
d2472 2
a2473 2
  bfd_set_section_size (abfd, extern_rt_rel, 4);
  extern_rt_rel_d = xmalloc (4);
d2481 1
a2481 1
  bfd_set_section_contents (abfd, extern_rt_rel, extern_rt_rel_d, 0, 4);
d2493 1
d2497 4
d2506 9
a2514 1
  if (!name_thunk_sym || name_thunk_sym->type != bfd_link_hash_defined)
d2519 12
a2530 3
      /* If we ever use autoimport, we have to cast text section writable.  */
      config.text_read_only = FALSE;
      link_info.output_bfd->flags &= ~WP_TEXT;   
d2533 2
a2534 1
  if (addend == 0 || link_info.pei386_runtime_pseudo_reloc)
d2600 1
a2600 1
 
d2624 1
a2624 1
	  bfd *newbfd = bfd_openr (ibfd->my_archive 
d2640 1
a2640 1
		  einfo (_("%X%s(%s): can't find member in non-archive file"), 
d2652 1
a2652 1
		  einfo (_("%X%s(%s): can't find member in archive"), 
d2668 1
a2668 1
      /* Don't add PRIVATE entries to import lib.  */ 	
d2766 1
a2766 1
		  sprintf (name, "%s%s", "__imp_", 
d2899 1
a2899 1
  
@


1.114
log
@	* NEWS:  Mention new feature --exclude-modules-for-implib.
	* ld.texinfo:  Document new --exclude-modules-for-implib option.
	* pe-dll.c (exclude_list_struct):  Change type member from int to
	new enumeration exclude_type.
	(pe_dll_add_excludes):  Accept exclude_type instead of int param.
	(auto_export):  Replace magic constants by exclude_type values and
	handle new choice EXCLUDEFORIMPLIB.
	(pe_dll_generate_implib):  Accept a pointer to the link_info and
	iterate all input BFDs looking for EXCLUDEFORIMPLIB modules; re-open
	fresh BFDs for any found and link into import lib archive chain.
	* pe-dll.h (exclude_type):  Add new enumerated type to replace magic
	constants previously used for exclude_list_struct type member.
	(pe_dll_add_excludes, pe_dll_generate_implib):  Update prototypes.
	* pep-dll.h (exclude_type, pe_dll_add_excludes,
	pe_dll_generate_implib):  Likewise to all the above.
	* emultempl/pe.em (OPTION_EXCLUDE_MODULES_FOR_IMPLIB):  Define new
	getopts long option code for new --exclude-modules-for-implib option.
	(gld${EMULATION_NAME}_add_options):  Add new entry to xtra_long[].
	(gld_${EMULATION_NAME}_list_options):  List usage for it.
	(gld${EMULATION_NAME}_handle_option):  Use exclude_type enumerated
	values when calling pe_dll_add_excludes, and handle EXCLUDEFORIMPLIB.
	(gld_${EMULATION_NAME}_finish):  Pass pointer to link_info when
	calling pe_dll_generate_implib.
	* emultempl/pep.em (options):  Define new enumerated value for getopts
	long option code for new --exclude-modules-for-implib option.
	(gld${EMULATION_NAME}_add_options, gld_${EMULATION_NAME}_list_options,
	gld${EMULATION_NAME}_handle_option, gld_${EMULATION_NAME}_finish):
	Again, likewise to all the above.
@
text
@d158 1
d1800 2
a1801 1
  d2[0] = d2[16] = PE_IDATA5_SIZE; /* Reloc addend.  */
d1807 4
a1810 1
  bfd_set_section_size (abfd, id5, PE_IDATA5_SIZE);
d1814 4
a1817 2

  bfd_set_section_size (abfd, id4, PE_IDATA4_SIZE);
d1825 10
a1834 2
  bfd_set_section_contents (abfd, id5, d5, 0, PE_IDATA5_SIZE);
  bfd_set_section_contents (abfd, id4, d4, 0, PE_IDATA4_SIZE);
a2296 1
  d2[0] = d2[16] = PE_IDATA5_SIZE; /* Reloc addend.  */
@


1.113
log
@2009-01-03  Dave Korn  <dave.korn.cygwin@@gmail.com>

	* pe-dll.c (autofilter_liblist):  Add entry for shared libgcc.
	(libnamencmp):  New function.
	(auto_export):  Use it in place of strncmp when filtering libraries.

Also rolled over ChangeLog to ChangeLog-2008
@
text
@d466 1
a466 1
    int type;
d473 1
a473 1
pe_dll_add_excludes (const char *new_excludes, const int type)
d596 1
a596 1
      if (ex->type == 1) /* exclude-libs */
d603 5
d2488 1
a2488 1
pe_dll_generate_implib (def_file *def, const char *impfilename)
d2494 1
d2523 55
@


1.112
log
@include/elf/
            * common.h (STT_IFUNC): Define.
elfcpp/
            * elfcpp.h (enum STT): Add STT_IFUNC.
bfd/
            * syms.c (struct bfd_symbol): Add new flag BSF_INDIRECT_FUNCTION.
            Remove redundant flag BFD_FORT_COMM_DEFAULT_VALUE.  Renumber flags
            to remove gaps.
            (bfd_print_symbol_vandf): Return 'i' for BSF_INDIRECT_FUNCTION.
            (bfd_decode_symclass): Likewise.
            * elf.c (swap_out_syms): Translate BSF_INDIRECT_FUNCTION into
            STT_IFUNC.
            (elf_find_function): Treat STT_IFUNC in the same way as STT_FUNC.
            (_bfd_elf_is_function_type): Likewise.
            * elf32-arm.c (arm_elf_find_function): Likewise.
            (elf32_arm_adjust_dynamic_symbol): Likewise.
            (elf32_arm_swap_symbol_in): Likewise.
            (elf32_arm_additional_program_headers): Likewise.
            * elf32-i386.c (is_indirect_symbol): New function.
            (elf_i386_check_relocs): Also generate dynamic relocs for
            relocations against STT_IFUNC symbols.
            (allocate_dynrelocs): Likewise.
            (elf_i386_relocate_section): Likewise.
            * elf64-x86-64.c (is_indirect_symbol): New function.
            (elf64_x86_64_check_relocs): Also generate dynamic relocs for
            relocations against STT_IFUNC symbols.
            (allocate_dynrelocs): Likewise.
            (elf64_x86_64_relocate_section): Likewise.
            * elfcode.h (elf_slurp_symbol_table): Translate STT_IFUNC into
            BSF_INDIRECT_FUNCTION.
            * elflink.c (_bfd_elf_adjust_dynamic_reloc_section): Add support
            for STT_IFUNC symbols.
            (get_ifunc_reloc_section_name): New function.
            (_bfd_elf_make_ifunc_reloc_section): New function.
            * elf-bfd.h (struct bfd_elf_section_data): Add indirect_relocs field.
            * bfd-in2.h: Regenerate.
gas/
            * config/obj-elf.c (obj_elf_type): Add support for STT_IFUNC type.
            * doc/as.texinfo: Document new feature.
            * NEWS: Mention new feature.
gas/testsuite/
            * gas/elf/type.s: Add test of STT_IFUNC symbol type.
            * gas/elf/type.e: Update expected disassembly.
            * gas/elf/elf.exp: Update grep of symbol types.
ld/
            * NEWS: Mention new feature.
            * pe-dll.c (process_def_file): Replace use of redundant
            BFD_FORT_COMM_DEFAULT_VALUE with 0.
            * scripttempl/elf.sc: Add .rel.ifunc.dyn and .rela.ifunc.dyn
            sections.
ld/testsuite/
            * ld-mips-elf/reloc-1-n32.d: Updated expected output for reloc
            descriptions.
            * ld-mips-elf/reloc-1-n64.d: Likewise.
            * ld-i386/ifunc.d: New test.
            * ld-i386/ifunc.s: Source file for the new test.
            * ld-i386/i386.exp: Run the new test.
@
text
@d317 1
d328 31
d536 1
a536 1
	      if (strncmp (libname, afptr->name, afptr->len) == 0 )
@


1.111
log
@2008-12-02  Kai Tietz  <kai.tietz@@onevision.com>

        * pe-dll.c (make_runtime_pseudo_reloc): Make symtab big enough to
        hold relocations.
@
text
@d636 1
a636 1
		      || (symbols[j]->flags == BFD_FORT_COMM_DEFAULT_VALUE)))
@


1.110
log
@2008-11-14  Kai Tietz  <kai.tietz@@onevision.com>

	* emultempl/pep.em (..._before_parse): initialize
	pei386_runtime_pseudo_reloc by version 2.
	(OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC_V1): New option.
	(OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC_V2): New option.
	(make_import_fixup): Use relocation size to read addend.
	* emultempl/pe.em (..._before_parse): initialize
	pei386_runtime_pseudo_reloc by version 1.
	(OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC_V1): New option.
	(OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC_V2): New option.
	* pe-dll.c (pe-dll.h): Remove useless include.
	(make_runtime_pseudo_reloc): Change addend to use bfd_vma.
	Handle the two variants of pseudo-relocation.
	(pe_create_import_fixup): Change addend to type bfd_vma.
	Modify for the two pseudo_relocation variants.
	(runtime_pseudp_reloc_v2_init): New static variable.
	* pe-dll.h (pe_create_import_fixup): Change addend argument type
	to bfd_vma.
	* pep-dll.h (pep_create_import_fixup): Likewise.
	* NEWS: Add comment.
@
text
@d2287 8
a2294 1
  symtab = xmalloc (2 * sizeof (asymbol *));
@


1.109
log
@2008-09-26  Kai Tietz  <kai.tietz@@onevision.com>

	* pe-dll.c (make_import_fixup_entry): Make sure reloc is addend.
@
text
@a42 1
#include "pe-dll.h"
d167 1
d2267 2
a2268 1
			   int addend,
a2274 1

d2293 22
a2314 5
  bfd_set_section_size (abfd, rt_rel, 8);
  rt_rel_d = xmalloc (8);
  rt_rel->contents = rt_rel_d;
  memset (rt_rel_d, 0, 8);
  bfd_put_32 (abfd, addend, rt_rel_d);
d2316 8
a2323 2
  quick_reloc (abfd, 4, BFD_RELOC_RVA, 1);
  save_relocs (rt_rel);
d2325 4
a2328 1
  bfd_set_symtab (abfd, symtab, symptr);
d2330 1
a2330 1
  bfd_set_section_contents (abfd, rt_rel, rt_rel_d, 0, 8);
d2332 2
d2383 1
a2383 1
pe_create_import_fixup (arelent *rel, asection *s, int addend)
d2416 10
a2425 10
  if (addend != 0)
    {
      if (link_info.pei386_runtime_pseudo_reloc)
	{
	  if (pe_dll_extra_pe_debug)
	    printf ("creating runtime pseudo-reloc entry for %s (addend=%d)\n",
		   fixup_name, addend);
	  b = make_runtime_pseudo_reloc (name, fixup_name, addend,
					 link_info.output_bfd);
	  add_bfd_to_link (b, b->filename, &link_info);
d2427 13
a2439 14
	  if (runtime_pseudo_relocs_created == 0)
	    {
	      b = pe_create_runtime_relocator_reference (link_info.output_bfd);
	      add_bfd_to_link (b, b->filename, &link_info);
	    }
	  runtime_pseudo_relocs_created++;
	}
      else
	{
	  einfo (_("%C: variable '%T' can't be auto-imported. Please read the documentation for ld's --enable-auto-import for details.\n"),
		 s->owner, s, rel->address, sym->name);
	  einfo ("%X");
	}
    }
@


1.108
log
@bfd/
	* bfd.c (struct _bfd): Correct outsymbols comment.
	* bfd-in2.h: Regenerate.
	* linker.c (bfd_generic_link_read_symbols): Renamed from..
	(generic_link_read_symbols): ..this, and made global.

include/
	* bfdlink.h (bfd_generic_link_read_symbols): Declare.
ld/
	PR 6478
	* ldcref.c (check_local_sym_xref): Use bfd_generic_link_read_symbols.
	Don't free symbol pointer array.
	(check_refs): Likewise.
	* ldmain.c (warning_callback): Likewise.
	* ldmisc.c (vfinfo): Likewise.
	* pe-dll.c (process_def_file): Likewise.
	(pe_walk_relocs_of_symbol, generate_reloc): Likewise.
	* emultempl/pe.em (pe_find_data_imports): Likewise.
	(gld_${EMULATION_NAME}_after_open): Likewise.
	* emultempl/pep.em (pep_find_data_imports): Likewise.
	(gld_${EMULATION_NAME}_after_open): Likewise.
	* ldlang.h (lang_input_statement_type): Delete asymbols, symbol_count,
	passive_position, closed.
	* ldlang.c (new_afile): Don't set asymbols and symbol_count.
	* ldmain.c (add_archive_element): xcalloc lang_input_statement_type.
@
text
@d2245 1
@


1.108.2.1
log
@2009-01-08  Dave Korn  <dave.korn.cygwin@@gmail.com>

Backport bugfix from HEAD:

  2009-01-03  Dave Korn  <dave.korn.cygwin@@gmail.com>

	* pe-dll.c (autofilter_liblist):  Add entry for shared libgcc.
	(libnamencmp):  New function.
	(auto_export):  Use it in place of strncmp when filtering libraries.

Also rolled over ChangeLog.
@
text
@d3 1
a3 1
   2008, 2009 Free Software Foundation, Inc.
a316 1
  { STRING_COMMA_LEN ("libgcc_s") },
a326 31
/* Regardless of the suffix issue mentioned above, we must ensure that
  we do not falsely match on a leading substring, such as when libtool
  builds libstdc++ as a DLL using libsupc++convenience.a as an intermediate.
  This routine ensures that the leading part of the name matches and that
  it is followed by only an optional version suffix and a file extension,
  returning zero if so or -1 if not.  */
static int libnamencmp (const char *libname, const autofilter_entry_type *afptr)
{
  if (strncmp (libname, afptr->name, afptr->len))
    return -1;

  libname += afptr->len;

  /* Be liberal in interpreting what counts as a version suffix; we
    accept anything that has a dash to separate it from the name and
    begins with a digit.  */
  if (libname[0] == '-')
    {
      if (!ISDIGIT (*++libname))
	return -1;
      /* Ensure the filename has an extension.  */
      while (*++libname != '.')
	if (!*libname)
	  return -1;
    }
  else if (libname[0] != '.')
    return -1;

  return 0;
}

d504 1
a504 1
	      if (libnamencmp (libname, afptr) == 0 )
@


1.107
log
@2008-07-31  Takashi Ono  <t_ono@@hkfreak.net>

	* pe-dll.c (generate_relocs): Don't generate relocs for
	undefined weak symbols.
@
text
@d618 1
a618 1
	  int nsyms, symsize;
d620 8
a627 3
	  symsize = bfd_get_symtab_upper_bound (b);
	  symbols = xmalloc (symsize);
	  nsyms = bfd_canonicalize_symtab (b, symbols);
d1149 1
a1149 1
      int nsyms, symsize;
d1151 8
a1158 3
      symsize = bfd_get_symtab_upper_bound (b);
      symbols = xmalloc (symsize);
      nsyms   = bfd_canonicalize_symtab (b, symbols);
d1228 1
a1228 1
	  int nsyms, symsize;
d1248 5
a1252 3
	  symsize = bfd_get_symtab_upper_bound (b);
	  symbols = xmalloc (symsize);
	  nsyms = bfd_canonicalize_symtab (b, symbols);
d1254 2
@


1.106
log
@           *pe-dll.c (autofilter_symbolprefixlist): Excude all symbols
           starting with ".".
           Exclude "_IMPORT_DESCRIPTOR_".
           (autofilter_symbolsuffixlist): Exclude "_NULL_THUNK_DATA".
           (autofilter_symbollist_generic): Don't check for ".text".
           Exclude "_NULL_IMPORT_DESCRIPTOR".
           (autofilter_symbollist_i386): Likewise.
@
text
@d1259 10
@


1.105
log
@2008-05-27  Kai Tietz  <kai.tietz@@onevision.com>

        * pe-dll.c (fill_edata): Make sure we calculate vma's in
        type bfd_vma.
        (generate_reloc): Likewise.
        (pe_implied_import_dll): Likewise.
@
text
@d190 1
a190 1
  { STRING_COMMA_LEN (".text") },
d203 1
a203 1
  { STRING_COMMA_LEN (".text") },
d353 4
d363 1
@


1.104
log
@2008-05-09  Kai Tietz  <kai.tietz@@onevision.com>

	ld/PR6502
	* emultempl/pep.em (compute_dll_image_base): Use bfd_vma instead of long
	and change return type to bfd_vma.
	(definfo): Change type of address from long to bfd_vma.
	(set_pep_value): Replace strtoul to strtoull.
	(gld_${EMULATION_NAME}_set_symbols): use bfd_vma instead of long..
	* pe-dll.c (pe_dll_generate_def_file): Use fprintf_vma to print ImageBase.
	(quick_reloc): Change argument address from int to bfd_size_type.
@
text
@d1101 1
a1101 1
	      unsigned long srva = (exported_symbol_offsets[s]
d1189 2
a1190 2
  unsigned long sec_page = (unsigned long) -1;
  unsigned long page_ptr, page_count;
d1211 1
a1211 1
	  unsigned long sec_vma = s->output_section->vma + s->output_offset;
d1326 1
a1326 1
      unsigned long this_page = (reloc_data[i].vma >> 12);
d1343 1
a1343 1
  sec_page = (unsigned long) -1;
d1345 1
a1345 1
  page_ptr = (unsigned long) -1;
d1350 2
a1351 2
      unsigned long rva = reloc_data[i].vma - image_base;
      unsigned long this_page = (rva & ~0xfff);
d1358 1
a1358 1
	  if (page_ptr != (unsigned long) -1)
d1384 1
a1384 1
  if (page_ptr != (unsigned long) -1)
d2607 3
a2609 3
  unsigned long pe_header_offset, opthdr_ofs, num_entries, i;
  unsigned long export_rva, export_size, nsections, secptr, expptr;
  unsigned long exp_funcbase;
d2612 1
a2612 1
  unsigned long name_rvas, ordinals, nexp, ordbase;
d2616 6
a2621 6
  unsigned long data_start = 1;
  unsigned long data_end = 0;
  unsigned long rdata_start = 1;
  unsigned long rdata_end = 0;
  unsigned long bss_start = 1;
  unsigned long bss_end = 0;
d2668 4
a2671 4
      unsigned long secptr1 = secptr + 40 * i;
      unsigned long vaddr = pe_get32 (dll, secptr1 + 12);
      unsigned long vsize = pe_get32 (dll, secptr1 + 16);
      unsigned long fptr = pe_get32 (dll, secptr1 + 20);
d2689 4
a2692 4
      unsigned long secptr1 = secptr + 40 * i;
      unsigned long vsize = pe_get32 (dll, secptr1 + 8);
      unsigned long vaddr = pe_get32 (dll, secptr1 + 12);
      unsigned long flags = pe_get32 (dll, secptr1 + 36);
d2706 2
a2707 1
		    __FUNCTION__, sec_name, vaddr, vaddr + vsize, flags);
d2716 2
a2717 1
		    __FUNCTION__, sec_name, vaddr, vaddr + vsize, flags);
d2726 2
a2727 1
		    __FUNCTION__, sec_name, vaddr, vaddr + vsize, flags);
d2763 1
a2763 1
      unsigned long name_rva = pe_as32 (erva + name_rvas + i * 4);
d2766 1
a2766 1
      unsigned long func_rva = pe_as32 (erva + exp_funcbase + i * 4);
d2788 1
a2788 1
		    func_rva, is_data ? "(data)" : "");
@


1.103
log
@Kai Tietz  <kai.tietz@@onevision.com>

	PR ld/6026
	* pe-dll.c (make_head): Fix iat and thunk addend offset.
@
text
@d1450 4
a1453 3
	    fprintf (out, " BASE=0x%lx",
		     (unsigned long)
		     pe_data (link_info.output_bfd)->pe_opthdr.ImageBase);
d1646 1
a1646 1
quick_reloc (bfd *abfd, int address, int which_howto, int symidx)
@


1.102
log
@include/
	* bfdlink.h (struct bfd_link_hash_table): Delete creator field.
	(struct bfd_link_info): Add output_bfd.
bfd/
	* elflink.c: Replace all accesses to hash->creator field with
	output_bfd->xvec.
	* cofflink.c: Likewise.
	* coff-h8300.c: Likewise.
	* ecoff.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfxx-mips.c: Likewise.
	* i386linux.c: Likewise.
	* m68klinux.c: Likewise.
	* sparclinux.c: Likewise.
	* sunos.c: Likewise.
	* xcofflink.c: Likewise.
	* linker.c: Likewise.
	(_bfd_link_hash_table_init): Don't store creator.
ld/
	* ldmain.h (output_bfd): Delete.
	* ldmain.c (output_bfd): Delete.
	Replace all occurrences of output_bfd with link_info.output_bfd.
	* ldcref.c: Likewise.
	* ldctor.c: Likewise.
	* ldemul.c: Likewise.
	* ldexp.c: Likewise.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldmisc.c: Likewise.
	* ldwrite.c: Likewise.
	* pe-dll.c: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/alphaelf.em: Likewise.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/elf-generic.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/irix.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/mmix-elfnmmo.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/sh64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
	* emultempl/z80.em: Likewise.
	* ldlang.c (open_output): Don't return output, instead write
	link_info_output_bfd directly.
	* emultempl/alphaelf.em: Replace occurrences of link_info.hash->creator
	with link_info.output_bfd->xvec.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
@
text
@d1732 1
a1732 1
  d2[0] = d2[16] = 4; /* Reloc addend.  */
@


1.101
log
@	bfd/
	* bfd-in.h (STRING_COMMA_LEN): Don't handle NULL STR case.
	* bfd-in2.h: Regenerate.

	ld/
	* pe-dll.c (autofilter_symbollist_generic)
	(autofilter_symbollist_i386, autofilter_liblist)
	(autofilter_objlist, autofilter_symbolprefixlist)
	(autofilter_symbolsuffixlist): Don't use STRING_COMMA_LEN with
	NULL.
@
text
@d2 2
a3 2
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
   Free Software Foundation, Inc.
d861 2
a862 1
  filler_file->the_bfd = filler_bfd = bfd_create ("dll stuff", output_bfd);
d865 2
a866 2
			     bfd_get_arch (output_bfd),
			     bfd_get_mach (output_bfd)))
d1449 1
a1449 1
	  if (pe_data (output_bfd)->pe_opthdr.ImageBase)
d1451 2
a1452 1
		     (unsigned long) pe_data (output_bfd)->pe_opthdr.ImageBase);
d2339 1
a2339 1
      bfd *b = make_singleton_name_thunk (name, output_bfd);
d2344 1
a2344 1
      output_bfd->flags &= ~WP_TEXT;   
d2352 2
a2353 1
      b = make_import_fixup_entry (name, fixup_name, dll_symname, output_bfd);
d2364 2
a2365 1
	  b = make_runtime_pseudo_reloc (name, fixup_name, addend, output_bfd);
d2370 1
a2370 1
	      b = pe_create_runtime_relocator_reference (output_bfd);
@


1.100
log
@* emultempl/pep.em: (pep_enable_stdcall_fixup): Set to value 1.
  (gld_xxx_recognized_file): Use pep_bfd_is_dll for detection of shared objects.
* pe-dll.c: (autofilter_symbollist_i386): Define set for amd64 mingw target.
@
text
@d198 1
a198 1
  { STRING_COMMA_LEN (NULL) }
d234 1
a234 1
  { STRING_COMMA_LEN (NULL) }
d324 1
a324 1
  { STRING_COMMA_LEN (NULL) }
d339 1
a339 1
  { STRING_COMMA_LEN (NULL) }
d353 1
a353 1
  { STRING_COMMA_LEN (NULL) }
d359 1
a359 1
  { STRING_COMMA_LEN (NULL) }
@


1.99
log
@Update sources to GPLv3
@
text
@d206 8
d221 1
@


1.98
log
@bfd/
	* bfd.c (struct bfd): Rename "next" to "archive_next".
	* archive.c: Rename uses throughout file.
	* archive64.c: Likewise.
	* coff-rs6000.c: Likewise.
	* ecoff.c: Likewise.
	* som.c: Likewise.
	* bfd-in2.h: Regenerate.
binutils/
	* ar.c: Rename uses of bfd.next to bfd.archive_next throughout.
	* arsup.c: Likewise.
	* binemul.c: Likewise.
	* objcopy.c: Likewise.
	* dlltool.c: Likewise.
ld/
	* pe-dll.c: Rename uses of bfd.next to bfd.archive_next throughout.
@
text
@d6 1
a6 1
   This file is part of GLD, the Gnu Linker.
d8 1
a8 1
   GLD is free software; you can redistribute it and/or modify
d10 2
a11 2
   the Free Software Foundation; either version 2, or (at your option)
   any later version.
d13 1
a13 1
   GLD is distributed in the hope that it will be useful,
d19 3
a21 3
   along with GLD; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */
@


1.97
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d2419 1
a2419 1
      n->next = head;
d2430 2
a2431 2
  ar_head->next = head;
  ar_tail->next = ar_head;
d2442 1
a2442 1
      bfd *n = head->next;
@


1.96
log
@Use pc-relative relocation instead of an absolute relocation for x86_64-pc-mingw32 target.
@
text
@d23 1
a24 1
#include "sysdep.h"
@


1.95
log
@* pe-dll.c: (make_one) Conditionally include jump stubs.
* emultempl/pe.em (gld_${EMULATION_NAME}_after_open): Identify
  redundant jump stubs from import libraries and exclude them from link.
@
text
@d1978 5
a1982 1
	  quick_reloc (abfd, 2, BFD_RELOC_32, 2);
@


1.94
log
@	* pe-dll.c: Include pe-dll.h.
	* pep-dll.c (pe_bfd_is_dll): Define.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
d1876 1
a1876 1
make_one (def_file_export *exp, bfd *parent)
d1886 7
a1892 1
  switch (pe_details->pe_arch)
d1894 23
a1916 20
    case PE_ARCH_i386:
      jmp_bytes = jmp_ix86_bytes;
      jmp_byte_count = sizeof (jmp_ix86_bytes);
      break;
    case PE_ARCH_sh:
      jmp_bytes = jmp_sh_bytes;
      jmp_byte_count = sizeof (jmp_sh_bytes);
      break;
    case PE_ARCH_mips:
      jmp_bytes = jmp_mips_bytes;
      jmp_byte_count = sizeof (jmp_mips_bytes);
      break;
    case PE_ARCH_arm:
    case PE_ARCH_arm_epoc:
    case PE_ARCH_arm_wince:
      jmp_bytes = jmp_arm_bytes;
      jmp_byte_count = sizeof (jmp_arm_bytes);
      break;
    default:
      abort ();
d1942 1
a1942 1
      if (! exp->flag_data)
d1953 1
a1953 1
      if (! exp->flag_data)
d1968 1
a1968 1
  if (! exp->flag_data)
d1998 2
d2064 2
a2065 1
  bfd_set_section_contents (abfd, tx, td, 0, jmp_byte_count);
d2413 2
a2414 1
      n = make_one (def->exports + i, outarch);
d2490 1
d2502 2
d2516 3
d2539 1
a2539 1
		one = make_one (&exp, output_bfd);
@


1.93
log
@* pe-dll.c (pe_bfd_is_dll): New function.
* pe-dll.h (pe_bfd_is_dll): Declare.
* emultempl/pe.em (gld_${EMULATION_NAME}_recognized_file): Recognize dlls using
pe_bfd_is_dll instead of using the filename extension.
@
text
@d43 1
@


1.92
log
@* pe-dll.c (autofilter_entry_type): Change name to const.
(pe_details_type) : Change target_name, object_target and autofilter_symbollist
to const.
(autofilter_symbollist_generic): Change to const.
(autofilter_symbollist_i386, pe_detail_list, pe_details, autofilter_liblist,
autofilter_objlist autofilter_symbolprefixlist, autofilter_symbolsuffixlist):
Likewise.
(is_import): Fix indentation.
(auto_export): Change afptr to const.  Move name declaration to beginning of
scope.
(make_tail): Clear undefined byte.
(jmp_ix86_bytes, jmp_sh_bytes, jmp_mips_bytes, jmp_arm_bytes): Change to const.
(make_one): Change jmp_bytes to const.  Make idata$6 member size arithmetic
explicit and add comment.
@
text
@d2833 8
@


1.91
log
@* pe-dll.c (make_singleton_name_thunk): Re-add the NULL terminator.
@
text
@d170 1
a170 1
  char *name;
d177 2
a178 2
  char *target_name;
  char *object_target;
d183 1
a183 1
  autofilter_entry_type* autofilter_symbollist; 
d187 1
a187 1
static autofilter_entry_type autofilter_symbollist_generic[] =
d200 1
a200 1
static autofilter_entry_type autofilter_symbollist_i386[] =
d234 1
a234 1
static pe_details_type pe_detail_list[] =
d299 1
a299 1
static pe_details_type *pe_details;
d302 1
a302 1
static autofilter_entry_type autofilter_liblist[] =
d317 1
a317 1
static autofilter_entry_type autofilter_objlist[] =
d332 1
a332 1
static autofilter_entry_type autofilter_symbolprefixlist[] =
d346 1
a346 1
static autofilter_entry_type autofilter_symbolsuffixlist[] =
d452 1
a452 1
	return (CONST_STRNEQ (n, "__imp_"));
d463 1
a463 1
  autofilter_entry_type *afptr;
d622 1
d626 1
a626 1
		    char *name = xmalloc (strlen ("__imp_") + strlen (sn) + 1);
d1801 4
d1837 1
a1837 1
static unsigned char jmp_ix86_bytes[] =
d1849 1
a1849 1
static unsigned char jmp_sh_bytes[] =
d1860 1
a1860 1
static unsigned char jmp_mips_bytes[] =
d1866 1
a1866 1
static unsigned char jmp_arm_bytes[] =
d1882 1
a1882 1
  unsigned char *jmp_bytes = NULL;
d2037 2
a2038 1
      len = strlen (exp->name) + 3;
@


1.90
log
@* pe-dll.c : Fix typo.
  (autofilter_symbolprefixlist) : Remove __imp_.
  (is_import) : New.
  (auto-export) : Remove  re-import check. Moved to callers.
  (process_def_file) : Check is symbol is an import. Always underscore __imp_.
  Only skip underscore on underscored targets.
  (make_one) : Always underscore __imp_.
  (pe_create_runtime_relocator_reference) : Only underscore _pei386_runtime_relocator on underscored targets.
  (pe_process_import_defs) : Always underscore __imp_.
* pe.em (U) : New macro.
  (set_pe_subsystem) : Remove underscore from _WinMainCRTStartup on wince subsystem case.
  (pe_find_data_imports) : Use U on "_head_".
  (gld_${EMULATION_NAME}_unrecognized_file) : Use U.
@
text
@d2083 3
a2085 2
  bfd_set_section_size (abfd, id4, PE_IDATA4_SIZE);
  d4 = xmalloc (PE_IDATA4_SIZE);
d2087 1
a2087 1
  memset (d4, 0, PE_IDATA4_SIZE);
d2093 1
a2093 1
  bfd_set_section_contents (abfd, id4, d4, 0, PE_IDATA4_SIZE);
@


1.89
log
@Add x86_64-mingw64 target
@
text
@d126 1
a126 1
    containing imported name. Here comes that "om the edge" problem mentioned
d334 3
a336 2
  { STRING_COMMA_LEN ("__imp_") },
  /* Do __imp_ explicitly to save time.  */
d338 1
a340 1
  { STRING_COMMA_LEN ("__builtin_") },
d449 5
a467 4
  /* We should not re-export imported stuff.  */
  if (CONST_STRNEQ (n, "_imp_"))
    return 0;

d622 5
a626 2
		    char *name = xmalloc (strlen (sn) + 2 + 6);
		    sprintf (name, "%s%s", U("_imp_"), sn);
d636 1
a636 1
		  if (*sn == '_')
d682 3
d1929 1
a1929 1
      quick_symbol (abfd, U ("_imp_"), exp->internal_name, "", id5,
d1941 1
a1941 1
      quick_symbol (abfd, U ("_imp__"), exp->internal_name, "", id5,
d1946 1
a1946 1
	quick_symbol (abfd, U("_nm__"), exp->internal_name, "", id6,
d2270 1
a2270 1
  quick_symbol (abfd, "", "__pei386_runtime_relocator", "", UNDSEC,
d2471 1
a2471 1
	      sprintf (name, "%s%s", "",
d2483 1
a2483 1
		  sprintf (name, "%s%s", U ("_imp_"),
d2486 1
a2486 1
		  sprintf (name, "%s%s", U ("_imp__"),
@


1.88
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d43 12
d57 10
d74 1
a74 1
    See also: ld/emultempl/pe.em.  */
d144 1
a144 1
    See also: ld/emultempl/pe.em.  */
d237 5
d245 1
d511 1
d1246 6
d1717 2
a1718 2
  bfd_set_section_size (abfd, id5, 4);
  d5 = xmalloc (4);
d1720 1
a1720 1
  memset (d5, 0, 4);
d1722 2
a1723 2
  bfd_set_section_size (abfd, id4, 4);
  d4 = xmalloc (4);
d1725 1
a1725 1
  memset (d4, 0, 4);
d1730 2
a1731 2
  bfd_set_section_contents (abfd, id5, d5, 0, 4);
  bfd_set_section_contents (abfd, id4, d4, 0, 4);
d1739 1
d1742 1
d1775 2
a1776 2
  bfd_set_section_size (abfd, id4, 4);
  d4 = xmalloc (4);
d1778 1
a1778 1
  memset (d4, 0, 4);
d1780 2
a1781 2
  bfd_set_section_size (abfd, id5, 4);
  d5 = xmalloc (4);
d1783 1
a1783 1
  memset (d5, 0, 4);
d1795 2
a1796 2
  bfd_set_section_contents (abfd, id4, d4, 0, 4);
  bfd_set_section_contents (abfd, id5, d5, 0, 4);
d1983 2
a1984 2
  bfd_set_section_size (abfd, id5, 4);
  d5 = xmalloc (4);
d1986 1
a1986 1
  memset (d5, 0, 4);
d1992 1
a1992 1
      d5[3] = 0x80;
d2000 2
a2001 2
  bfd_set_section_size (abfd, id4, 4);
  d4 = xmalloc (4);
d2003 1
a2003 1
  memset (d4, 0, 4);
d2009 1
a2009 1
      d4[3] = 0x80;
d2040 2
a2041 2
  bfd_set_section_contents (abfd, id5, d5, 0, 4);
  bfd_set_section_contents (abfd, id4, d4, 0, 4);
d2075 2
a2076 2
  bfd_set_section_size (abfd, id4, 8);
  d4 = xmalloc (4);
d2078 1
a2078 1
  memset (d4, 0, 8);
d2084 1
a2084 1
  bfd_set_section_contents (abfd, id4, d4, 0, 8);
a2127 9
  if (0)
    {
      struct coff_link_hash_entry *myh;

      myh = (struct coff_link_hash_entry *) bh;
      printf ("type:%d\n", myh->type);
      printf ("%s\n", myh->root.u.def.section->name);
    }

d2589 3
d2593 1
d2598 4
d2604 2
@


1.87
log
@bfd
* Makefile.am: Add rules to build pe-arm-wince.lo and pei-arm-wince.lo objects.
* Makefile.in: Regenerate.
* pe-arm-wince.c: New file.
* pei-arm-wince.c: New file.
* pei-arm.c: Remove ARM_WINCE block.
* pe-arm.c: Remove ARM_WINCE block. Rename
bfd_arm_pe_allocate_interworking_sections,
bfd_arm_pe_get_bfd_for_interworking, and
bfd_arm_pe_process_before_allocation to
bfd_armpe_allocate_interworking_sections,
bfd_armpe_get_bfd_for_interworking, and
bfd_armpe_process_before_allocation. Move them before including bfd.h.
* bfd.c: ARM wince bfd format names were renamed. Adjust.
* coff-arm.c [ARM_WINCE]: Adjust so Windows CE doesn't end up with unexpected/conflicting relocs.
* targets.c: The arm-wince-pe target got its own new vector.  Adjust.
* config.bfd: Likewise.
* configure.in: Likewise.
* configure: Regenerate.

binutils
* configure.in: Split arm-pe and arm-wince-pe. Build dlltool with -DDLLTOOL_ARM_WINCE for Windows CE case.
* configure: Regenerate.
* dlltool.c: Add support for arm-wince.

gas
* Makefile.am (TARG_ENV_HFILES): Add te-wince-pe.h.
* Makefile.in: Regenerate.
* config/tc-arm.h [TARGET_FORMAT]: ARM wince bfd names were  renamed. Adjust.

ld
* Makefile.am: Split arm-wince into its own emulation.
* Makefile.in: Regenerate.
* configure.tgt: Set targ_emul to arm_wince_pe for ARM Windows CE targets.
* pe-dll.c : Define PE_ARCH_arm_wince.
  (pe_detail_list): Add PE_ARCH_arm_wince case.
  (make_one): Handle PE_ARCH_arm_epoc and PE_ARCH_arm_wince cases.
* emulparams/arm_wince_pe.sh: New file.
* emultempl/pe.em: Handle new TARGET_IS_arm_wince_pe define.
  Remap bfd_arm_allocate_interworking_sections, bfd_arm_get_bfd_for_interworking and
  bfd_arm_process_before_allocation for arm-pe and arm-wince-pe targets too.
  (gld_${EMULATION_NAME}_recognized_file): Handle arm-wince and arm-epoc bfd format names.
@
text
@d167 1
a167 1
  { ".text", 5 },
d169 3
a171 3
  { "DllMain", 7 },
  { "DllMainCRTStartup", 17 },
  { "_DllMainCRTStartup", 18 },
d173 3
a175 3
  { "_pei386_runtime_relocator", 25 },
  { "do_pseudo_reloc", 15 },
  { NULL, 0 }
d180 1
a180 1
  { ".text", 5 },
d182 12
a193 12
  { "cygwin_crt0", 11 },
  { "DllMain@@12", 10 },
  { "DllEntryPoint@@0", 15 },
  { "DllMainCRTStartup@@12", 20 },
  { "_cygwin_dll_entry@@12", 20 },
  { "_cygwin_crt0_common@@8", 21 },
  { "_cygwin_noncygwin_dll_entry@@12", 30 },
  { "cygwin_attach_dll", 17 },
  { "cygwin_premain0", 15 },
  { "cygwin_premain1", 15 },
  { "cygwin_premain2", 15 },
  { "cygwin_premain3", 15 },
d195 2
a196 2
  { "_pei386_runtime_relocator", 25 },
  { "do_pseudo_reloc", 15 },
d198 5
a202 5
  { "impure_ptr", 10 },
  { "_impure_ptr", 11 },
  { "_fmode", 6 },
  { "environ", 7 },
  { NULL, 0 }
d276 11
a286 11
  { "libcegcc", 8 },
  { "libcygwin", 9 },
  { "libgcc", 6 },
  { "libstdc++", 9 },
  { "libmingw32", 10 },
  { "libmingwex", 10 },
  { "libg2c", 6 },
  { "libsupc++", 9 },
  { "libobjc", 7 },
  { "libgcj", 6 },
  { NULL, 0 }
d291 11
a301 11
  { "crt0.o", 6 },
  { "crt1.o", 6 },
  { "crt2.o", 6 },
  { "dllcrt1.o", 9 },
  { "dllcrt2.o", 9 },
  { "gcrt0.o", 7 },
  { "gcrt1.o", 7 },
  { "gcrt2.o", 7 },
  { "crtbegin.o", 10 },
  { "crtend.o", 8 },
  { NULL, 0 }
d306 1
a306 1
  { "__imp_", 6 },
d308 1
a308 1
  { "__rtti_", 7 },
d310 2
a311 2
  { "_nm_", 4 },
  { "__builtin_", 10 },
d313 2
a314 2
  { "_head_", 6 },
  { NULL, 0 }
d319 2
a320 2
  { "_iname", 6 },
  { NULL, 0 }
d435 1
a435 1
  if (strncmp (n, "_imp_", 5) == 0)
d2677 1
a2677 1
      if (strncmp (erva + name_rva, "_nm_", 4) != 0)
@


1.86
log
@* pe-dll.c (autofilter_symbolprefixlist): Remove .idata$.
(generate_reloc): Revert to skipping sections without a SEC_LOAD flag, and to
not skipping .idata* sections.
@
text
@d210 1
d259 9
d1850 2
d1929 2
@


1.85
log
@* pe-dll.c (pe_details_type): Add new pointer for symbols list autofilter.
  (autofilter_symbollist): Split into autofilter_symbollist_generic and
    autofilter_symbollist_i386.
  (pe_detail_list): Add autofilter_symbollist_i386 to i386 case and
    autofilter_symbollist_generic for all the others.
  (autofilter_symbolprefixlist): Moved _fmode, _impure_ptr, cygwin_attach_dll,
    cygwin_premain0, cygwin_premain1, cygwin_premain2, cygwin_premain3,
    environ, into autofilter_symbollist_i386.
  (auto_export): Get autofilter_symbollist from pe_details.
@
text
@a298 1
  { ".idata$", 7 },
a1156 1
#if 0	  /* Some toolchains can generate .data sections without a SEC_LOAD flag but with relocs.  */
a1158 4
#endif
	  /* Huh ?  */
	  if (strncmp (bfd_get_section_name (abfd, s), ".idata",6) == 0)
	    continue;
@


1.84
log
@Apply fixes to allow arm WinCE toolchain to produce working executables.
@
text
@d147 16
a162 8
  {
    char *target_name;
    char *object_target;
    unsigned int imagebase_reloc;
    int pe_arch;
    int bfd_arch;
    int underscored;
  }
d165 39
a203 6
typedef struct
  {
    char *name;
    int len;
  }
autofilter_entry_type;
d205 4
a208 4
#define PE_ARCH_i386	1
#define PE_ARCH_sh	2
#define PE_ARCH_mips	3
#define PE_ARCH_arm	4
d219 2
a220 1
    1
d228 2
a229 1
    1
d237 2
a238 1
    0
d246 2
a247 1
    1
d255 2
a256 1
    0
d258 1
a258 1
  { NULL, NULL, 0, 0, 0, 0 }
a262 19
static autofilter_entry_type autofilter_symbollist[] =
{
  { "DllMain", 7 },
  { "DllMainCRTStartup", 17 },
  { "_DllMainCRTStartup", 18 },
  { "DllMain@@12", 10 },
  { "DllEntryPoint@@0", 15 },
  { "DllMainCRTStartup@@12", 20 },
  { "_cygwin_dll_entry@@12", 20 },
  { "_cygwin_crt0_common@@8", 21 },
  { "_cygwin_noncygwin_dll_entry@@12", 30 },
  { "impure_ptr", 10 },
  { "_pei386_runtime_relocator", 25 },
  { "do_pseudo_reloc", 15 },
  { "cygwin_crt0", 11 },
  { ".text", 5 },
  { NULL, 0 }
};

a304 8
  { "_fmode", 6 },
  { "_impure_ptr", 11 },
  { "cygwin_attach_dll", 17 },
  { "cygwin_premain0", 15 },
  { "cygwin_premain1", 15 },
  { "cygwin_premain2", 15 },
  { "cygwin_premain3", 15 },
  { "environ", 7 },
d471 3
a473 4
	 it is too restrictive.  */

      /* Then, exclude specific symbols.  */
      afptr = autofilter_symbollist;
@


1.83
log
@2006-01-31  Filip Navara  <navaraf@@reactos.com>

	* deffile.h (struct def_file_export): Add field flag_forward.
	* pe-dll.c (process_def_file): Check for forward exports.
	(generate_edata): Generate forward export symbols.
	(fill_edata): Emit them.

	* pe-dll.c (process_def_file): Don't crash on malformed
	fastcall symbol names in .def file.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
d98 1
a98 1
    IMAGE_IMPORT_DESCRIPTOR and stored in .idata$3 subsection. Each
d219 3
d232 1
d239 1
d269 1
a269 1
  /*  { "__imp_", 6 }, */
d272 1
d1140 1
d1143 4
d1794 8
d1827 4
d1904 3
d2077 1
a2077 1
/*	.section	.idata$3
d2090 2
a2091 2
  asection *id3;
  unsigned char *d3;
d2108 1
a2108 1
  id3 = quick_section (abfd, ".idata$3", SEC_HAS_CONTENTS, 2);
d2114 4
a2117 4
  bfd_set_section_size (abfd, id3, 20);
  d3 = xmalloc (20);
  id3->contents = d3;
  memset (d3, 0, 20);
d2122 1
a2122 1
  save_relocs (id3);
d2126 1
a2126 1
  bfd_set_section_contents (abfd, id3, d3, 0, 20);
@


1.82
log
@* pe-dll.c (pe_dll_generate_implib): Issue "Creating library file:" as
informational message, not a warning.
@
text
@d599 1
d601 5
a605 1
	      *(strchr (tmp, '@@')) = 0;
d688 21
d866 2
a867 1
      if (exported_symbol_sections[i])
d886 6
d896 10
a905 9
    if (exported_symbol_sections[i])
      if (pe_def_file->exports[i].ordinal == -1)
	{
	  while (exported_symbols[next_ordinal - min_ordinal] != -1)
	    next_ordinal++;

	  exported_symbols[next_ordinal - min_ordinal] = i;
	  pe_def_file->exports[i].ordinal = next_ordinal;
	}
d1004 2
a1005 1
      if (ssec && pe_def_file->exports[s].ordinal != -1)
a1006 3
	  unsigned long srva = (exported_symbol_offsets[s]
				+ ssec->output_section->vma
				+ ssec->output_offset);
d1009 17
a1025 2
	  bfd_put_32 (abfd, srva - image_base,
		      eaddresses + 4 * (ord - min_ordinal));
@


1.81
log
@	* pe-dll.c (build_filler_bfd): Conform error message to standard.
	(pe_dll_generate_implib): Use %E in error message.
	(add_bfd_to_link): Likewise.
	(pe_implied_import_dll): Likewise.
@
text
@d2240 2
a2241 2
  einfo (_("Creating library file: %s\n"), impfilename);

@


1.80
log
@pe-dll.c (pe_exe_fill_sections): Call lang_reset_memory_regions before
lang_size_sections.
@
text
@d760 1
a760 1
      einfo ("%X%P: can not create BFD %E\n");
d2275 1
a2275 1
    einfo ("%Xbfd_set_archive_head: %s\n", bfd_errmsg (bfd_get_error ()));
d2278 1
a2278 1
    einfo ("%Xbfd_close %s: %s\n", impfilename, bfd_errmsg (bfd_get_error ()));
d2300 1
a2300 1
    einfo ("%Xaddsym %s: %s\n", name, bfd_errmsg (bfd_get_error ()));
d2448 1
a2448 1
      einfo ("%Xopen %s: %s\n", filename, bfd_errmsg (bfd_get_error ()));
@


1.79
log
@	* ld.h (lang_phase_type): Move to..
	* ldexp.h: ..here.  Add lang_mark_phase_enum.
	(node_type): Remove etree_undef and etree_unspec.
	(exp_data_seg): Delete.
	(struct ldexp_control, expld): New.
	(invalid, exp_mark_used_section): Delete.
	(exp_fold_tree, exp_get_vma, exp_get_value_int, exp_get_fill,
	exp_get_abs_int): Update prototypes.
	* ldexp.c (assigning_to_dot): Delete.
	(expld): Define.
	(make_abs): Operate directly on expld.result.  Update all callers.
	(new_abs): Likewise.  Return void.
	(new_rel_from_abs): Rename from new_rel_from_section.
	(new_rel, new_rel_from_abs): Operate on expld.result and return void.
	Update all callers.
	(fold_unary): Operate on expld.result and return void.  Remove
	"current_section", "allocation_done", "dot", "dotp" and "mark_used"
	params.  Update all callers.
	(fold_binary, fold_trinary, fold_name, exp_fold_tree_1): Likewise.
	(fold_unary <ALIGN_K>): Ensure alignment is absolute.
	(fold_unary <ABSOLUTE>): Use make_abs.
	(fold_unary <DATA_SEGMENT_END>): Evaluate mark_phase as for
	allocating_phase.
	(fold_binary <DATA_SEGMENT_ALIGN, DATA_SEGMENT_RELRO_END, >): Ditto.
	(fold_binary <'%','/'>): Don't error if marking.
	(fold_name <SIZEOF_HEADERS>): Don't call bfd_sizeof_headers when
	marking.
	(fold_name <NAME>): Remove FIXME; -R is handled correctly.  Don't
	error when marking.
	(fold_name <ADDR, LOADADDR, SIZEOF>): Don't set SEC_KEEP.
	(exp_fold_tree_1): Don't error when marking.
	(exp_fold_tree_1 <etree_rel>): Evaluate in all phases except first.
	(exp_fold_tree_1 <etree_assign to dot>): Don't check for NULL
	current section, instead check for NULL dotp.
	(exp_fold_tree_1 <etree_provide>): Don't evaluate the assignment
	source unless the symbol is referenced and undefined.
	(exp_fold_tree): Remove "allocation_done" and "dot" params.  Save
	params to expld.
	(exp_fold_tree_no_dot): Remove "current_section", "allocation_done
	and "mark_used" params.  Save params to expld.  Update all callers.
	(exp_assop): Do without temp var.
	(exp_print_tree <etree_undef>): Delete code.
	(exp_get_vma): Remove "allocation_done" param.  Correct error return.
	(exp_get_fill, exp_get_abs_int): Likewise.
	(exp_get_value_int): Remove "allocation_done" param.
	(exp_mark_used_section): Delete.
	* ldgram.y (fill_exp): Update exp_get_fill call.
	(origin_spec, length_spec): Update exp_get_vma call.
	* ldlang.c (lang_init): Don't bother clearing lang_statement_iteration.
	(lang_mark_used_section_1, lang_mark_used_section): Delete.
	(strip_excluded_output_sections): Call one_lang_size_sections_pass in
	marking mode.  Merge old lang_mark_used_section code.  Correct handling
	of output sections with excluded input sections and data statements.
	Don't drop non-zero sized sections.  Don't zap os->bfd_section.
	Do set SEC_EXCLUDE when appropriate.
	(print_output_section_statement): Update for changed ldexp.c
	interface.
	(print_assignment, lang_size_sections_1): Likewise.
	(lang_do_assignments_1, lang_enter_output_section_statement): Likewise.
	(lang_new_phdr, lang_record_phdrs): Likewise.
	(lang_size_sections): Likewise.
	(insert_pad): Use following statement if it is a pad, rather than
	creating a new one.
	(lang_size_sections_1 <lang_output_section_statement_enum>): Do
	process ignored output section to set vma and lma, but don't
	update dot for these sections.  Don't error if marking.
	(lang_size_sections_1 <lang_assignment_statement_enum>): Don't
	update dot for ignored sections.
	(lang_size_sections_1 <lang_data_statement_enum>): Don't mark absolute
	section with SEC_ALLOC.
	(one_lang_size_sections_pass): New function.
	(lang_size_sections): Remove first five params.  Set expld.phase on
	entry and exit.   Use one_lang_size_sections_pass.
	(lang_do_assignments): Remove all params.  Update all callers.
	(lang_reset_memory_regions): Clear os->processed for all output
	section statements.
	* ldlang.h (lang_do_assignments): Update prototype.
	(lang_size_sections): Likewise.
	(one_lang_size_sections_pass): Declare.
	* pe-dll.c (pe_dll_fill_sections, pe_exe_fill_sections): Update
	lang_size_sections and lang_do_assignments calls.
	* emultempl/elf32.em (layout_sections_again): Likewise.
	* emultempl/ppc64elf.em (ppc_before_allocation): Use
	one_lang_size_sections_pass.
@
text
@d2639 1
d2670 1
@


1.78
log
@Update FSF addresses
@
text
@d2639 1
a2639 2
      lang_size_sections (stat_ptr->head, abs_output_section,
			  &stat_ptr->head, 0, 0, NULL, TRUE);
d2645 1
a2645 1
      lang_do_assignments (stat_ptr->head, abs_output_section, NULL, 0);
d2669 1
a2669 2
      lang_size_sections (stat_ptr->head, abs_output_section,
			  &stat_ptr->head, 0, 0, NULL, TRUE);
d2675 1
a2675 1
      lang_do_assignments (stat_ptr->head, abs_output_section, NULL, 0);
@


1.77
log
@bfd/
2005-03-02  Jan Beulich  <jbeulich@@novell.com>

	* Makefile.am: Add dependency of cache.o on libiberty.h.
	* cache.c: Include libiberty.h.
	(bfd_open_file): Use unlink_if_ordinary instead of unlink.

binutils/
2005-03-02  Jan Beulich  <jbeulich@@novell.com>

	* ar.c (remove_output): Use unlink_if_ordinary instead of unlink.
	* objcopy.c (copy_file): Likewise.
	(strip_main): Likewise.

gas/
2005-03-02  Jan Beulich  <jbeulich@@novell.com>

	* as.c (main): Use unlink_if_ordinary instead of unlink.
	* messages.c (as_fatal): Likewise.

ld/
2005-03-02  Jan Beulich  <jbeulich@@novell.com>

	* ldmain.c (remove_output): Use unlink_if_ordinary instead of unlink.
	* pe-dll.c (pe_dll_generate_implib): Likewise.
@
text
@d20 2
a21 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.76
log
@	* pe-dll.c: Warning fixes.
	* emultempl/sunos.em: Likewise.
@
text
@d2228 1
a2228 1
  unlink (impfilename);
@


1.75
log
@	* ldlang.c (lang_reasonable_defaults): Remove.
	(lang_process): Don't call lang_reasonable_defaults.

	* ldexp.c (exp_assop): Remove #if 0'd code.
	(exp_print_tree): Likewise.
	* ldlang.c (lang_memory_region_lookup): Likewise.
	(open_output): Likewise.
	(lang_do_assignments_1): Likewise.
	(lang_place_orphans): Likewise.
	(lang_enter_output_section_statement): Likewise.
	(lang_reasonable_defaults): Likewise.
	* ldlang.h (struct lang_input_statement_struct): Likewise.
	* mri.c (mri_draw_tree): Likewise.
	(mri_load): Likewise.
	* pe-dll.c (generate_reloc): Likewise.
	(make_import_fixup_entry): Likewise.
	(pe_as16): Likewise.
	* emultempl/beos.em (set_pe_subsystem): Likewise.
	* emultempl/hppaelf.em (hppaelf_after_parse): Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/xtensaelf.em (xtensa_colocate_literals): Likewise.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004
d923 1
a923 1
  unsigned char *enamestr;
d935 1
a935 1
  enamestr = eordinals + 2 * count_exported_byname;
d1674 1
a1674 1
  strcpy (d7, dll_filename);
d1897 1
a1897 1
      strcpy (d6 + 2, exp->name);
d2430 2
a2431 1
  unsigned char *expdata, *erva;
d2541 1
a2541 1
  erva = expdata - export_rva;
d2554 1
a2554 1
  dll_name = pe_as32 (expdata + 12) + erva;
@


1.74
log
@	* pe-dll.c (process_def_file): Don't export all symbols by default if
	building a position-independent executable.
@
text
@a1180 3
#if 0
	  free (symbol);
#endif
a2036 3
#if 0
  quick_symbol (abfd, U ("_head_"), dll_symname, "", id2, BSF_GLOBAL, 0);
#endif
a2414 12
#if 0 /* This is not currently used.  */

static unsigned int
pe_as16 (void *ptr)
{
  unsigned char *b = ptr;

  return b[0] + (b[1] << 8);
}

#endif

@


1.73
log
@emultempl/pe.em (gld_${EMULATION_NAME}_set_symbols): Generate correct base
  address for position independant executables.
pe-dll.c (pe_dll_fill_sections): Don't mark position independant executables
  as DLLs.
@
text
@d530 1
a530 1
      && !info->shared)
@


1.72
log
@* pe-dll.c (auto_export):  Filter on just the import prefix, "_imp_", not
"_imp__".
@
text
@d2668 1
a2668 1
  if (info->shared)
@


1.71
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d401 1
a401 1
  if (strncmp (n, "_imp__", 6) == 0)
@


1.70
log
@	* ldwrite.c (build_link_order): Use bfd_get_section_size
	instead of bfd_get_section_size_before_reloc or _raw_size.
	* pe-dll.c (process_def_file): Likewise.
@
text
@d518 1
a518 1
	  int size = bfd_get_section_size (s);
d1255 1
a1255 1
  while (reloc_sz < reloc_s->_raw_size)
@


1.69
log
@	* pe-dll.c: Revert changes accidentally committed 2004-03-08.
	(fill_edata): Correct pointer arithmetic.
@
text
@d518 1
a518 1
	  int size = bfd_get_section_size_before_reloc (s);
@


1.68
log
@Honour PRIVATE keyword
@
text
@a28 1
#include <stdint.h>
d920 3
a922 3
  uint32_t *eaddresses;
  uint32_t *enameptrs;
  unsigned short *eordinals;
d932 4
a935 4
  eaddresses = (uint32_t *) (edata_d + 40);
  enameptrs = eaddresses + export_table_size;
  eordinals = (unsigned short *) (enameptrs + count_exported_byname);
  enamestr = (char *) (eordinals + count_exported_byname);
d978 1
a978 1
		      (void *) (eaddresses + ord - min_ordinal));
d984 2
a985 2
	      bfd_put_32 (abfd, ERVA (enamestr), (void *) enameptrs);
	      enameptrs++;
d988 2
a989 2
	      bfd_put_16 (abfd, ord - min_ordinal, (void *) eordinals);
	      eordinals++;
@


1.67
log
@	* pe-dll.c (fill_edata): Check that exported_symbol_sections is
	not NULL.
@
text
@d29 1
d921 2
a922 2
  unsigned long *eaddresses;
  unsigned long *enameptrs;
d933 1
a933 1
  eaddresses = (unsigned long *) (edata_d + 40);
d2261 3
@


1.66
log
@	* pe-dll.c (pe_create_import_fixup): Clear WP_TEXT flag.
	* ld.texinfo (--omagic): Note that writable text section
	does not conform to published PE-COFF specs.
	(--enable-auto-import): Likewise.
@
text
@d969 2
a970 1
      if (pe_def_file->exports[s].ordinal != -1)
a971 1
	  struct bfd_section *ssec = exported_symbol_sections[s];
@


1.66.6.1
log
@Merge to 2.15 branch.
@
text
@a28 1
#include <stdint.h>
d920 2
a921 2
  uint32_t *eaddresses;
  uint32_t *enameptrs;
d932 1
a932 1
  eaddresses = (uint32_t *) (edata_d + 40);
d969 1
a969 2
      struct bfd_section *ssec = exported_symbol_sections[s];
      if (ssec && pe_def_file->exports[s].ordinal != -1)
d971 1
a2259 3
      /* Don't add PRIVATE entries to import lib.  */ 	
      if (pe_def_file->exports[i].flag_private)
	continue;
@


1.66.6.2
log
@	* pe-dll.c: Revert changes accidentally committed 2004-03-08.
	(fill_edata): Correct pointer arithmetic.
@
text
@d29 1
d921 3
a923 3
  unsigned char *eaddresses;
  unsigned char *enameptrs;
  unsigned char *eordinals;
d933 4
a936 4
  eaddresses = edata_d + 40;
  enameptrs = eaddresses + 4 * export_table_size;
  eordinals = enameptrs + 4 * count_exported_byname;
  enamestr = eordinals + 2 * count_exported_byname;
d979 1
a979 1
		      eaddresses + 4 * (ord - min_ordinal));
d985 2
a986 2
	      bfd_put_32 (abfd, ERVA (enamestr), enameptrs);
	      enameptrs += 4;
d989 2
a990 2
	      bfd_put_16 (abfd, ord - min_ordinal, eordinals);
	      eordinals += 2;
@


1.65
log
@Fixes for use of ARM_26D reloc in arm-wince toolchain.
@
text
@d2 2
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d2180 1
@


1.64
log
@Index: sim/frv/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* traps.c: Replace "struct symbol_cache_entry" with "struct
	bfd_symbol".

Index: sim/d10v/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* simops.c: Replace "struct symbol_cache_entry" with "struct
	bfd_symbol".

Index: sim/common/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* sim-trace.c, sim-base.h: Replace "struct symbol_cache_entry"
	with "struct bfd_symbol".

Index: ld/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* emultempl/pe.em, pe-dll.c: Replace "struct symbol_cache_entry"
	with "struct bfd_symbol".

Index: bfd/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* syms.c: Replace "struct symbol_cache_entry" with "struct
	bfd_symbol".
	* vms.h, targets.c, section.c, reloc.c, peicode.h: Ditto.
	* mipsbsd.c, elf.c, linker.c, elf-bfd.h, ecoff.c: Ditto.
	* cpu-z8k.c, cpu-ns32k.c, cpu-h8500.c, bfd.c, bfd-in.h: Ditto.
	* bfd-in2.h: Re-generate.
@
text
@d1158 6
a1163 1
		      if (relocs[i]->howto->type == 5)
@


1.63
log
@2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* targets.c: Replace "struct sec" with "struct bfd_section"
	* syms.c, sparclynx.c, section.c, opncls.c: Ditto.
	* libcoff-in.h, libbfd-in.h, elfxx-target.h: Ditto.
	* elf.c, coffgen.c, bfd.c, bfd-in.h, aoutf1.h: Ditto.
	* aout-tic30.c, aout-target.h:
	* bfd-in2.h, libcoff.h, libbfd.h: Regenerate.

Index: binutils/ChangeLog
2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* coffgrok.h (coff_section): Replace 'struct sec" with "struct
	bfd_section".

Index: gdb/ChangeLog
2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* symtab.c: Replace "struct sec" with "struct bfd_section".
	* objfiles.c, linespec.c, blockframe.c, block.c: Ditto.

Index: ld/ChangeLog
2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* pe-dll.c: Replace "struct sec" with "struct bfd_section".

Index: sim/common/ChangeLog
2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* sim-base.h: Replace "struct sec" with "struct bfd_section".
@
text
@d1034 1
a1034 1
	      struct symbol_cache_entry *sym = *relocs[i]->sym_ptr_ptr;
d1115 1
a1115 1
		  struct symbol_cache_entry *sym = *relocs[i]->sym_ptr_ptr;
d1122 1
a1122 1
		  struct symbol_cache_entry *sym = *relocs[i]->sym_ptr_ptr;
d1959 1
a1959 1
  struct symbol_cache_entry *sym = *rel->sym_ptr_ptr;
d2157 1
a2157 1
  struct symbol_cache_entry *sym = *rel->sym_ptr_ptr;
@


1.62
log
@	* pe-dll.c (pe_implied_import_dll): Also scan .rdata sections
	to identify data symbols.
@
text
@d140 1
a140 1
static struct sec *edata_s, *reloc_s;
d342 1
a342 1
static struct sec **exported_symbol_sections;
d504 1
a504 1
  struct sec *s;
d629 1
a629 1
  exported_symbol_sections = xmalloc (NE * sizeof (struct sec *));
d631 1
a631 1
  memset (exported_symbol_sections, 0, NE * sizeof (struct sec *));
d970 1
a970 1
	  struct sec *ssec = exported_symbol_sections[s];
d996 1
a996 1
static struct sec *current_sec;
d1063 1
a1063 1
  struct sec *s;
@


1.61
log
@ Correct sym def order & pick right sym for .idata$7 reloc.
@
text
@d2444 5
a2448 3
  unsigned long data_end   = 0;
  unsigned long bss_start  = 1;
  unsigned long bss_end    = 0;
d2525 9
d2587 2
a2588 1
 	  /* is_data is true if the address is in the data or bss segment.  */
d2591 1
@


1.60
log
@Add libcygwin to the lib autofiler list
@
text
@d1783 2
a1786 2
      quick_symbol (abfd, U ("_head_"), dll_symname, "", UNDSEC,
		    BSF_GLOBAL, 0);
d1794 2
a1798 2
      quick_symbol (abfd, U ("_head_"), dll_symname, "", UNDSEC,
		    BSF_GLOBAL, 0);
d1841 1
a1841 1
  quick_reloc (abfd, 0, BFD_RELOC_RVA, 6);
@


1.59
log
@Convert to C90
@
text
@d234 1
@


1.58
log
@Catch and ignore an ARM_26D reloc.
@
text
@d123 1
a123 2
static void
add_bfd_to_link PARAMS ((bfd *, const char *, struct bfd_link_info *));
a288 30
static int reloc_sort PARAMS ((const void *, const void *));
static int pe_export_sort PARAMS ((const void *, const void *));
static int auto_export PARAMS ((bfd *, def_file *, const char *));
static void process_def_file PARAMS ((bfd *, struct bfd_link_info *));
static void build_filler_bfd PARAMS ((int));
static void generate_edata PARAMS ((bfd *, struct bfd_link_info *));
static void fill_exported_offsets PARAMS ((bfd *, struct bfd_link_info *));
static void fill_edata PARAMS ((bfd *, struct bfd_link_info *));
static void generate_reloc PARAMS ((bfd *, struct bfd_link_info *));
static void quoteput PARAMS ((char *, FILE *, int));
static asection *quick_section PARAMS ((bfd *, const char *, int, int));
static void quick_symbol
  PARAMS ((bfd *, const char *, const char *, const char *,
	   asection *, int, int));
static void quick_reloc PARAMS ((bfd *, int, int, int));
static bfd *make_head PARAMS ((bfd *));
static bfd *make_tail PARAMS ((bfd *));
static bfd *make_one PARAMS ((def_file_export *, bfd *));
static bfd *make_singleton_name_thunk PARAMS ((const char *, bfd *));
static char *make_import_fixup_mark PARAMS ((arelent *));
static bfd *make_import_fixup_entry
  PARAMS ((const char *, const char *, const char *, bfd *));
static bfd *make_runtime_pseudo_reloc
  PARAMS ((const char *, const char *, int, bfd *));
static bfd *pe_create_runtime_relocator_reference
  PARAMS ((bfd *));
static unsigned int pe_get16 PARAMS ((bfd *, int));
static unsigned int pe_get32 PARAMS ((bfd *, int));
static unsigned int pe_as32 PARAMS ((void *));

d290 1
a290 2
pe_dll_id_target (target)
     const char *target;
d317 1
a317 2
reloc_sort (va, vb)
     const void *va, *vb;
d319 2
a320 2
  bfd_vma a = ((reloc_data_type *) va)->vma;
  bfd_vma b = ((reloc_data_type *) vb)->vma;
d326 1
a326 2
pe_export_sort (va, vb)
     const void *va, *vb;
d328 2
a329 2
  def_file_export *a = (def_file_export *) va;
  def_file_export *b = (def_file_export *) vb;
d361 1
a361 3
pe_dll_add_excludes (new_excludes, type)
     const char *new_excludes;
     const int type;
d373 2
a374 3
      new_exclude = ((struct exclude_list_struct *)
		     xmalloc (sizeof (struct exclude_list_struct)));
      new_exclude->string = (char *) xmalloc (strlen (exclude_string) + 1);
d389 1
a389 4
auto_export (abfd, d, n)
     bfd *abfd;
     def_file *d;
     const char *n;
d416 1
a416 1
         Don't export anything from standard libs.  */
d498 1
a498 3
process_def_file (abfd, info)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
d528 1
a528 1
      && !(info->shared))
d540 1
a540 1
	  symbols = (asymbol **) xmalloc (symsize);
d546 2
a547 2
	         anything at all.  (.bss data is the latter)
	         We should not export undefined symbols.  */
d556 1
a556 1
		    char *name = (char *) xmalloc (strlen (sn) + 2 + 6);
d593 3
a595 3
	         pointing to the same memory as name, or might not
	         have.  */
	      int lead_at = (*pe_def_file->exports[i].name =='@@');
d610 1
a610 1
	      int lead_at = (*pe_def_file->exports[i].name == '@@' ) ;
d627 2
a628 2
  exported_symbol_offsets = (bfd_vma *) xmalloc (NE * sizeof (bfd_vma));
  exported_symbol_sections = (struct sec **) xmalloc (NE * sizeof (struct sec *));
d637 2
a638 1
  qsort (pe_def_file->exports, NE, sizeof (pe_def_file->exports[0]), pe_export_sort);
d679 1
a679 1
      char *name = (char *) xmalloc (strlen (pe_def_file->exports[i].internal_name) + 2);
d681 1
d746 1
a746 2
build_filler_bfd (include_edata)
     int include_edata;
d800 1
a800 3
generate_edata (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
d831 1
a831 1
  exported_symbols = (int *) xmalloc (export_table_size * sizeof (int));
d883 1
a883 3
fill_exported_offsets (abfd, info)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
d890 1
a890 1
      char *name = (char *) xmalloc (strlen (pe_def_file->exports[i].internal_name) + 2);
d892 1
d894 1
a894 1
 	  && (*pe_def_file->exports[i].internal_name != '@@'))
d906 1
a906 1
      if (blhe && (blhe->type == bfd_link_hash_defined))
d914 1
a914 3
fill_edata (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
d926 1
a926 1
  edata_d = (unsigned char *) xmalloc (edata_sz);
d935 2
a936 1
#define ERVA(ptr) (((unsigned char *)(ptr) - edata_d) + edata_s->output_section->vma - image_base)
d963 1
a963 1
     for more information.  */  
d998 3
a1000 4
pe_walk_relocs_of_symbol (info, name, cb)
     struct bfd_link_info *info;
     const char *name;
     int (*cb) (arelent *, asection *);
d1011 1
a1011 1
      symbols = (asymbol **) xmalloc (symsize);
d1028 1
a1028 1
	  relocs = (arelent **) xmalloc ((size_t) relsize);
d1051 1
a1051 3
generate_reloc (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d1058 1
a1058 1
  unsigned long sec_page = (unsigned long) (-1);
d1069 1
a1069 2
  reloc_data =
    (reloc_data_type *) xmalloc (total_relocs * sizeof (reloc_data_type));
d1103 1
a1103 1
	  symbols = (asymbol **) xmalloc (symsize);
d1107 1
a1107 1
	  relocs = (arelent **) xmalloc ((size_t) relsize);
d1203 2
a1204 2
  reloc_d = (unsigned char *) xmalloc (reloc_sz);
  sec_page = (unsigned long) (-1);
d1206 1
a1206 1
  page_ptr = (unsigned long) (-1);
d1219 1
a1219 1
	  if (page_ptr != (unsigned long) (-1))
d1245 1
a1245 1
  if (page_ptr != (unsigned long) (-1))
d1256 1
a1256 4
quoteput (s, f, needs_quotes)
     char *s;
     FILE *f;
     int needs_quotes;
d1289 1
a1289 2
pe_dll_generate_def_file (pe_out_def_filename)
     const char *pe_out_def_filename;
d1457 1
a1457 5
quick_section (abfd, name, flags, align)
     bfd *abfd;
     const char *name;
     int flags;
     int align;
d1479 7
a1485 8
quick_symbol (abfd, n1, n2, n3, sec, flags, addr)
     bfd *abfd;
     const char *n1;
     const char *n2;
     const char *n3;
     asection *sec;
     int flags;
     int addr;
d1488 1
a1488 1
  char *name = (char *) xmalloc (strlen (n1) + strlen (n2) + strlen (n3) + 1);
d1505 1
a1505 5
quick_reloc (abfd, address, which_howto, symidx)
     bfd *abfd;
     int address;
     int which_howto;
     int symidx;
d1507 1
a1507 1
  if (relcount >= (relsize - 1))
d1511 1
a1511 1
	reltab = (arelent *) xrealloc (reltab, relsize * sizeof (arelent));
d1513 1
a1513 1
	reltab = (arelent *) xmalloc (relsize * sizeof (arelent));
d1529 1
a1529 1
  sec->orelocation = (arelent **) xmalloc ((relcount + 1) * sizeof (arelent *));
d1556 1
a1556 2
make_head (parent)
     bfd *parent;
d1563 1
a1563 1
  oname = (char *) xmalloc (20);
d1575 1
a1575 1
  symtab = (asymbol **) xmalloc (6 * sizeof (asymbol *));
d1589 1
a1589 1
  d2 = (unsigned char *) xmalloc (20);
d1599 1
a1599 1
  d5 = (unsigned char *) xmalloc (4);
d1604 1
a1604 1
  d4 = (unsigned char *) xmalloc (4);
d1628 1
a1628 2
make_tail (parent)
     bfd *parent;
d1636 1
a1636 1
  oname = (char *) xmalloc (20);
d1648 1
a1648 1
  symtab = (asymbol **) xmalloc (5 * sizeof (asymbol *));
d1655 1
a1655 1
  d4 = (unsigned char *) xmalloc (4);
d1660 1
a1660 1
  d5 = (unsigned char *) xmalloc (4);
d1668 1
a1668 1
  d7 = (unsigned char *) xmalloc (len);
d1733 1
a1733 3
make_one (exp, parent)
     def_file_export *exp;
     bfd *parent;
d1761 1
a1761 1
  oname = (char *) xmalloc (20);
d1773 1
a1773 1
  symtab = (asymbol **) xmalloc (11 * sizeof (asymbol *));
d1784 4
a1787 2
      quick_symbol (abfd, U ("_head_"), dll_symname, "", UNDSEC, BSF_GLOBAL, 0);
      quick_symbol (abfd, U ("_imp_"), exp->internal_name, "", id5, BSF_GLOBAL, 0);
d1794 6
a1799 3
        quick_symbol (abfd, U (""), exp->internal_name, "", tx, BSF_GLOBAL, 0);
      quick_symbol (abfd, U ("_head_"), dll_symname, "", UNDSEC, BSF_GLOBAL, 0);
      quick_symbol (abfd, U ("_imp__"), exp->internal_name, "", id5, BSF_GLOBAL, 0);
d1801 1
a1801 1
         data symbol, used to implement auto-import.  */
d1803 2
a1804 1
        quick_symbol (abfd, U("_nm__"), exp->internal_name, "", id6, BSF_GLOBAL,0);
d1807 2
a1808 2
    quick_symbol (abfd, U ("__imp_"), exp->internal_name, "",
		  id5, BSF_GLOBAL, 0);
d1813 1
a1813 1
      td = (unsigned char *) xmalloc (jmp_byte_count);
d1837 1
a1837 1
  d7 = (unsigned char *) xmalloc (4);
d1844 1
a1844 1
  d5 = (unsigned char *) xmalloc (4);
d1861 1
a1861 1
  d4 = (unsigned char *) xmalloc (4);
d1888 1
a1888 1
      d6 = (unsigned char *) xmalloc (len);
d1910 1
a1910 3
make_singleton_name_thunk (import, parent)
     const char *import;
     bfd *parent;
d1918 1
a1918 1
  oname = (char *) xmalloc (20);
d1930 1
a1930 1
  symtab = (asymbol **) xmalloc (3 * sizeof (asymbol *));
d1936 1
a1936 1
  d4 = (unsigned char *) xmalloc (4);
d1951 1
a1951 2
make_import_fixup_mark (rel)
     arelent *rel;
d1965 1
a1965 1
      fixup_name = (char *) xmalloc (384);
d1978 1
a1978 1
      fixup_name = (char *) xmalloc (buffer_len);
d2008 4
a2011 5
make_import_fixup_entry (name, fixup_name, dll_symname, parent)
     const char *name;
     const char *fixup_name;
     const char *dll_symname;
     bfd *parent;
d2018 1
a2018 1
  oname = (char *) xmalloc (20);
d2030 1
a2030 1
  symtab = (asymbol **) xmalloc (6 * sizeof (asymbol *));
d2041 1
a2041 1
  d3 = (unsigned char *) xmalloc (20);
d2063 4
a2066 5
make_runtime_pseudo_reloc (name, fixup_name, addend, parent)
     const char *name ATTRIBUTE_UNUSED;
     const char *fixup_name;
     int addend;
     bfd *parent;
d2073 1
a2073 1
  oname = (char *) xmalloc (20);
d2085 3
a2087 2
  symtab = (asymbol **) xmalloc (2 * sizeof (asymbol *));
  rt_rel = quick_section (abfd, ".rdata_runtime_pseudo_reloc", SEC_HAS_CONTENTS, 2);
d2092 1
a2092 1
  rt_rel_d = (unsigned char *) xmalloc (8);
d2112 1
a2112 2
pe_create_runtime_relocator_reference (parent)
     bfd *parent;
d2119 1
a2119 1
  oname = (char *) xmalloc (20);
d2131 1
a2131 1
  symtab = (asymbol **) xmalloc (2 * sizeof (asymbol *));
d2134 2
a2135 1
  quick_symbol (abfd, "", "__pei386_runtime_relocator", "", UNDSEC, BSF_NO_FLAGS, 0);
d2138 1
a2138 1
  extern_rt_rel_d = (unsigned char *) xmalloc (4);
d2153 1
a2153 4
pe_create_import_fixup (rel, s, addend)
     arelent *rel;
     asection *s;
     int addend;
d2212 1
a2212 3
pe_dll_generate_implib (def, impfilename)
     def_file *def;
     const char *impfilename;
d2284 1
a2284 4
add_bfd_to_link (abfd, name, link_info)
     bfd *abfd;
     const char *name;
     struct bfd_link_info *link_info;
d2299 1
a2299 3
pe_process_import_defs (output_bfd, link_info)
     bfd *output_bfd;
     struct bfd_link_info *link_info;
d2327 2
a2328 1
	    char *name = (char *) xmalloc (strlen (pe_def_file->imports[i].internal_name) + 2 + 6);
d2331 2
a2332 1
              sprintf (name, "%s%s", "", pe_def_file->imports[i].internal_name);
d2334 2
a2335 1
	      sprintf (name, "%s%s",U (""), pe_def_file->imports[i].internal_name);
d2391 1
a2391 3
pe_get16 (abfd, where)
     bfd *abfd;
     int where;
d2401 1
a2401 3
pe_get32 (abfd, where)
     bfd *abfd;
     int where;
d2413 1
a2413 2
pe_as16 (ptr)
     void *ptr;
d2423 1
a2423 2
pe_as32 (ptr)
     void *ptr;
d2431 1
a2431 2
pe_implied_import_dll (filename)
     const char *filename;
d2478 1
a2478 1
  /* Get the rva and size of the export section.  */ 
d2500 1
a2500 1
     data and bss segments in data/base_start/end.  */ 
d2521 1
a2521 1
        }
d2533 1
a2533 1
  expdata = (unsigned char *) xmalloc (export_size);
d2567 1
a2567 1
      /* Pointer to the function address vector.  */ 
d2584 1
a2584 1
 
d2601 1
a2601 3
pe_dll_build_sections (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d2606 1
a2606 1
  if (pe_def_file->num_exports == 0 && !(info->shared))
d2614 1
a2614 3
pe_exe_build_sections (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
d2621 1
a2621 3
pe_dll_fill_sections (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d2633 1
a2633 1
			  &stat_ptr->head, 0, (bfd_vma) 0, NULL, TRUE);
d2639 1
a2639 3
      lang_do_assignments (stat_ptr->head,
			   abs_output_section,
			   (fill_type *) 0, (bfd_vma) 0);
d2652 1
a2652 3
pe_exe_fill_sections (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d2664 1
a2664 1
			  &stat_ptr->head, 0, (bfd_vma) 0, NULL, TRUE);
d2670 1
a2670 3
      lang_do_assignments (stat_ptr->head,
			   abs_output_section,
			   (fill_type *) 0, (bfd_vma) 0);
@


1.57
log
@Scan table pe_dll->exports, which is sorted alphabetically, instead of
exported_symbols, which is sorted by ordinal.
@
text
@d1205 7
@


1.56
log
@pe-dll.c (pe_detail_list): arm-pe targets use underscores.
(process_def_file): Don't create an export section if there are no exports and
  we're building an exe.
(pe_dll_build_sections): Ditto
(pe_dll_fill_sections): Conditionalize setting abfd->dll true on info->shared

emultempl/pe.em (gld_${EMULATION_NAME}_after_open): If i386pe or armpe, call
  pe_dll_build_section() for both exe's and dll's, not just dll's.  Don't call
  pe_dll_build_section() if link_info.relocateable.
(gld_${EMULATION_NAME}_finish): For all targets except shpe and mipspe, call
  pe_dll_fill_sections() for both exe's and dll's, not just dll's.  Don't call
  pe_dll_fill_sections() if link_info.relocateable.
@
text
@d962 1
a962 1
  int i, hint;
d1003 6
a1008 1
  /* Ok, now for the filling in part.  */
d1010 1
a1010 1
  for (i = 0; i < export_table_size; i++)
d1012 1
a1012 3
      int s = exported_symbols[i];

      if (s != -1)
d1026 1
@


1.55
log
@Disable region size checking whilst relaxing sections.
@
text
@d202 1
a202 1
    0
d567 6
d2675 3
d2719 2
a2720 1
  pe_data (abfd)->dll = 1;
@


1.54
log
@Add code to prevent importing a dll multiple times.
@
text
@d2697 1
a2697 1
			  &stat_ptr->head, 0, (bfd_vma) 0, NULL);
d2731 1
a2731 1
			  &stat_ptr->head, 0, (bfd_vma) 0, NULL);
@


1.53
log
@* ld/pe-dll.c (autofilter_symbollist): Add cygwin_crt0.
@
text
@d2021 2
a2022 2
      /* New buffer size is length of symbol, plus 25, but then
	 rounded up to the nearest multiple of 128.  */
d2156 1
a2156 1
 	.rva		__pei386_runtime_relocator */
d2611 10
@


1.52
log
@Add do_pseudo_reloc and _pei386_runtime_relocator to the exclude list.
@
text
@d228 1
@


1.51
log
@	* ldfile.c: Fix comment typos.
	* ldlang.c: Likewise.
	* mri.c: Likewise.
	* pe-dll.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d226 2
@


1.50
log
@Add support to skip import libraries for performance reasons and instead
use the direct auto-import of dll's
@
text
@d62 1
a62 1
    there's a place where it pokes nose out of, but in practise it works).
d77 1
a77 1
    whenever client contains someting like
d85 1
a85 1
    to two other parellel vectors: one holding imported names, and one which
d107 1
a107 1
    this, since FirstThunk points directly into machine code. But in practise,
d118 1
a118 1
    not, prohibitting that (detecting violation) would require more work on
d2630 1
a2630 1
 	  /* Mark symbole type.  */
@


1.49
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2421 1
a2421 1
		exp.flag_data = 0;
d2494 1
d2498 6
d2521 1
a2521 5
  dll_name = filename;
  for (i = 0; filename[i]; i++)
    if (filename[i] == '/' || filename[i] == '\\' || filename[i] == ':')
      dll_name = filename + i + 1;

d2536 1
d2557 34
d2603 1
d2605 5
d2612 1
d2615 23
a2637 3

      imp = def_file_add_import (pe_def_file, erva + name_rva, dll_name,
				 i, 0);
@


1.48
log
@Add --enable-auto-import extension.
@
text
@d593 1
a593 1
						 false, false, false);
d724 1
a724 1
				   false, false, true);
d939 1
a939 1
				   false, false, true);
d1825 1
a1825 1
 
d2029 1
a2029 1
				rel->address, NULL, true, false, &bh);
d2219 1
a2219 1
      config.text_read_only = false;
d2247 1
a2247 1
	} 
d2379 1
a2379 1
	    int lead_at = (*pe_def_file->imports[i].internal_name == '@@');  
d2389 1
a2389 1
					 false, false, false);
d2401 1
a2401 1
					     false, false, false);
d2438 2
a2439 2
   IMPORTS directives in the def file.  Return true if the file was
   handled, false if not.  */
d2487 1
a2487 1
boolean
d2504 1
a2504 1
      return false;
d2511 1
a2511 1
      return false;
d2524 1
a2524 1
    return false;
d2575 1
a2575 1
  return true;
@


1.47
log
@* pe-dll.c (autofilter_liblist): add libmingwex and libgcj to the list of
restricted auto-export libs.
@
text
@d144 1
d309 4
d2102 94
d2197 1
a2197 1
pe_create_import_fixup (rel)
d2199 2
d2207 1
d2222 18
a2239 3
  {
    extern char * pe_data_import_dll;
    char * dll_symname = pe_data_import_dll ? pe_data_import_dll : "unknown";
d2241 14
a2254 4
    bfd *b = make_import_fixup_entry (name, fixup_name, dll_symname,
				      output_bfd);
    add_bfd_to_link (b, b->filename, &link_info);
  }
@


1.46
log
@* pe-dll.c (autofilter_liblist): Generalize library names to catch more
creative library naming instances like, e.g., libstdc++-2.a.
@
text
@d234 1
d238 1
@


1.45
log
@Adds support for fastcall symbols as used on Microsoft Windows platforms
(i386)
@
text
@d231 6
a236 6
  { "libgcc.", 7 },
  { "libstdc++.", 10 },
  { "libmingw32.", 11 },
  { "libg2c.", 7 },
  { "libsupc++.", 10 },
  { "libobjc.", 8 },
@


1.44
log
@	* emultempl/aix.em: Use include <> for generated headers.
	* emultempl/beos.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/pe.em: Likewise.
	* ldctor.c: Likewise.
	* ldexp.c: Likewise.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldlex.c: Likewise.
	* ldlex.l: Likewise.
	* ldmain.c: Likewise.
	* ldmisc.c: Likewise.
	* ldwrite.c: Likewise.
	* lexsup.c: Likewise.
	* mri.c: Likewise.
	* pe-dll.c: Likewise.
@
text
@d621 2
a622 1
	      char *tmp = xstrdup (pe_def_file->exports[i].name);
d636 2
a637 1
	      char *tmp = xstrdup (pe_def_file->exports[i].name);
d706 2
a707 1
      if (pe_details->underscored)
d921 2
a922 1
      if (pe_details->underscored)
d1818 21
a1838 9
  if (! exp->flag_data)
    quick_symbol (abfd, U (""), exp->internal_name, "", tx, BSF_GLOBAL, 0);
  quick_symbol (abfd, U ("_head_"), dll_symname, "", UNDSEC, BSF_GLOBAL, 0);
  quick_symbol (abfd, U ("_imp__"), exp->internal_name, "", id5, BSF_GLOBAL, 0);
  /* Symbol to reference ord/name of imported
     data symbol, used to implement auto-import.  */
  if (exp->flag_data)
    quick_symbol (abfd, U("_nm__"), exp->internal_name, "", id6,
		  BSF_GLOBAL,0);
d2250 1
a2250 1

d2253 6
a2258 1
	    sprintf (name, "%s%s", U (""), pe_def_file->imports[i].internal_name);
d2261 1
d2264 7
a2270 2
		sprintf (name, "%s%s", U ("_imp__"),
			 pe_def_file->imports[i].internal_name);
d2275 1
@


1.43
log
@	* pe-dll.c (make_import_fixup_mark): Avoid type-punned pointer.
@
text
@d35 1
a35 1
#include "ldgram.h"
@


1.42
log
@Don't re-export auto-import symbols.
@
text
@d1981 1
a1981 1
  struct coff_link_hash_entry *myh = NULL;
d2003 1
d2006 10
a2015 2
				rel->address, NULL, true, false,
				(struct bfd_link_hash_entry **) &myh);
a2016 4
#if 0
  printf ("type:%d\n", myh->type);
  printf ("%s\n", myh->root.u.def.section->name);
#endif
@


1.41
log
@	* ldemul.c: Fix formatting.
	* ldfile.c: Likewise.
	* pe-dll.c: Likewise.
	* pe-dll.h: Likewise.
@
text
@d260 2
d1819 4
a1822 2
     symbol, used to implement auto-import.  */
  quick_symbol (abfd, U("_nm__"), exp->internal_name, "", id6, BSF_GLOBAL, 0);
@


1.41.2.1
log
@	* pe-dll.c (make_import_fixup_mark): Avoid type-punned pointer.
@
text
@d1977 1
a1977 1
  struct bfd_link_hash_entry *bh;
a1998 1
  bh = NULL;
d2001 2
a2002 10
				rel->address, NULL, true, false, &bh);

  if (0)
    {
      struct coff_link_hash_entry *myh;

      myh = (struct coff_link_hash_entry *) bh;
      printf ("type:%d\n", myh->type);
      printf ("%s\n", myh->root.u.def.section->name);
    }
d2004 4
@


1.41.2.2
log
@Merge from mainline.
@
text
@a259 2
  /* Don't re-export auto-imported symbols.  */
  { "_nm_", 4 },
d1817 2
a1818 4
     data symbol, used to implement auto-import.  */
  if (exp->flag_data)
    quick_symbol (abfd, U("_nm__"), exp->internal_name, "", id6,
		  BSF_GLOBAL,0);
@


1.41.2.3
log
@        * emultempl/aix.em: Use include <> for generated headers.
        * emultempl/beos.em: Likewise.
        * emultempl/elf32.em: Likewise.
        * emultempl/pe.em: Likewise.
        * ldctor.c: Likewise.
        * ldexp.c: Likewise.
        * ldfile.c: Likewise.
        * ldlang.c: Likewise.
        * ldlex.c: Likewise.
        * ldlex.l: Likewise.
        * ldmain.c: Likewise.
        * ldmisc.c: Likewise.
        * ldwrite.c: Likewise.
        * lexsup.c: Likewise.
        * mri.c: Likewise.
        * pe-dll.c: Likewise.
@
text
@d35 1
a35 1
#include <ldgram.h>
@


1.40
log
@* pe-dll.c (autofilter_liblist): Add more system libs excluded by default.
(autofilter_objlist): Add crtbegin.o, crtend.o.
* emultempl/pe.em (OPTION_EXCLUDE_LIBS): Add new define.
(longopts): Add new option --exclude-libs.
(gld_${EMULATION_NAME}_list_options): Give quick help about it.
(gld_${EMULATION_NAME}_parse_args): Use it.
* pe-dll.h (pe_dll_add_excludes): Add second param to prototype.
* pe-dll.c (exclude_list_struct): Add field type to distinguish symbols from
whole archives.
(pe_dll_add_excludes): Set excludes->type.
(auto_export): Add new variable libname and set to archive basename if abfd.
Use it when filtering default and user-specified libarary excludes.  Let string
"ALL" mean all libs when filtering user-specified libs.
* ld.texinfo: Document --exclude-libs.
@
text
@d236 1
a236 1
  { "libobjc.", 8 }, 
d376 1
a376 1
    int type;	
d385 1
a385 1
     const int type;	
d445 1
a445 1
      if (libname)	
d519 1
a519 1
        return 0;	      		
@


1.39
log
@	* ld.h: Fix formatting.
	* ldexp.c: Likewise.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldmain.c: Likewise.
	* lexsup.c: Likewise.
	* pe-dll.c: Likewise.
@
text
@d234 3
d250 2
d376 1
d383 1
a383 1
pe_dll_add_excludes (new_excludes)
d385 1
d401 1
d409 1
d422 3
d444 2
a445 2
         Don't export anything from libgcc.  */
      if (abfd && abfd->my_archive)
d451 1
a451 1
	      if (strstr (abfd->my_archive->filename, afptr->name))
d510 11
a520 2
    if (strcmp (n, ex->string) == 0)
      return 0;
@


1.38
log
@	Support arbitrary length fill patterns.
	* ldexp.h (etree_value_type): Add "str" field.
	(union etree_union): Add "str" to "value" struct.
	(exp_bigintop): Declare.
	(exp_get_fill): Declare.
	* ldexp.c: Include "safe-ctype.h".
	(exp_intop): Set value.str to NULL.
	(exp_bigintop): New function.
	(new_rel): Pass in "str", and set new.str from it.
	(new_rel_from_section): Set new.str to NULL.
	(fold_name): Adjust calls to new_rel.
	(exp_fold_tree): Likewise.
	(exp_get_fill): New function.
	* ldgram.y (struct big_int bigint, fill_type *fill): New.
	(INT): Returns a "bigint".  Adjust all code handling INTs.
	(fill_opt): Returns a "fill".
	(fill_exp): Split out of fill_opt, use for FILL.
	* ldlang.h (struct _fill_type): New.
	(fill_type): Move typedef to ldexp.h.
	(lang_output_section_statement_type): "fill" is now a pointer.
	(lang_fill_statement_type): Likewise.
	(lang_padding_statement_type): Likewise.
	(lang_add_fill): Now takes a "fill_type *" param.
	(lang_leave_output_section_statement): Likewise.
	(lang_do_assignments): Likewise.
	(lang_size_sections): Likewise.
	(lang_leave_overlay_section): Likewise.
	(lang_leave_overlay): Likewise.
	* ldlang.c: Include ldgram.h after ldexp.h.
	(lang_output_section_statement_lookup): Adjust for fill_type change.
	(print_fill_statement): Likewise.
	(print_padding_statement): Likewise.
	(insert_pad): Now takes a "fill_type *" arg.
	(size_input_section): Likewise.
	(lang_size_sections_1): Likewise.
	(lang_size_sections): Likewise.
	(lang_do_assignments): Likewise.
	(lang_add_fill): Likewise.
	(lang_leave_output_section_statement): Likewise.
	(lang_leave_overlay_section): Likewise.
	(lang_leave_overlay): Likewise.
	Adjust all callers of the above function.
	* ldlex.l: Include ldgram.h after ldexp.h.  Allow hex numbers
	starting with "0X" as well as "0x".  Return bigint.str for hex
	numbers starting with "0x" or "0X", zero bigint.str otherwise.
	Always use base 16 for numbers starting with "$".
	* ldmain.c: Include ldgram.h after ldexp.h.
	* ldwrite.c (build_link_order): Use bfd_data_link_order in place
	of bfd_fill_link_order.
	* pe-dll.c: Adjust lang_do_assignments calls.
	* emultempl/elf32.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/beos.em: Include ldgram.h after ldexp.h, adjust
	lang_add_assignment call.
	* emultempl/pe.em: Likewise.
@
text
@d50 1
a50 1
    
d246 1
a246 1
  { "gcrt2.o", 7 },  
d320 1
a320 1
/* Helper functions for qsort.  Relocs must be sorted so that we can write 
d449 2
a450 2
          afptr = autofilter_objlist;
          while (afptr->name)
d452 2
a453 2
	      if ( strcmp (p, afptr->name) == 0 )
	        return 0;
d469 1
a469 1
	  afptr ++;
d479 1
a479 1
	  afptr ++;
d487 1
a487 1
	  if ((len >= afptr->len) && 
d489 2
a490 2
	      strncmp (n + len - afptr->len, afptr->name, 
		       afptr->len + 1) == 0)
d493 1
a493 1
	  afptr ++;
d563 1
a563 1
						  false, false, false);
d566 1
a566 1
		    if (blhe && blhe->type == bfd_link_hash_defined) 
d866 1
a866 1
	    next_ordinal ++;
d1115 1
a1115 1
		{              
d1117 1
a1117 1
		  printf("rel: %s\n",sym->name);
d1196 1
a1196 1
  
d1554 1
a1554 1
 
d1558 1
a1558 1
 
d1698 1
a1698 1
 
d1701 1
a1701 1
 
d1952 1
a1952 1
  
d1954 1
a1954 1
  
d1965 1
a1965 1
  /* Assume 25 chars for "__fu" + counter + "_".  If counter is 
d1975 1
a1975 1
  
d1978 1
a1978 1
  bfd_coff_link_add_one_symbol (&link_info, abfd, fixup_name, BSF_GLOBAL, 
d1984 2
a1985 2
    printf ("type:%d\n", myh->type);
    printf ("%s\n", myh->root.u.def.section->name);
d1998 1
a1998 1
make_import_fixup_entry (name, fixup_name, dll_symname,parent)
d2024 2
a2025 2
#if 0  
  quick_symbol (abfd, U ("_head_"), dll_symname, "", id2, BSF_GLOBAL, 0); 
@


1.37
log
@* pe-dll.c (autofilter_objectlist): Add gcrt0.o.
(auto-export): Fix indentation.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d2440 1
a2440 1
			   (fill_type) 0, (bfd_vma) 0);
d2474 1
a2474 1
			   (fill_type) 0, (bfd_vma) 0);
@


1.36
log
@* pe-dll.c (autofilter_objectlist):  Add startup objects
for profiling.
(auto-export): Constify char * p.
Extract file basename and use strcmp rather than ststr
for object lookup.
@
text
@d244 1
d447 1
a447 1
      if (abfd && (p = lbasename (abfd->filename)) )
d450 2
a451 2
      while (afptr->name)
	{
d453 2
a454 2
	    return 0;
	  afptr ++;
@


1.35
log
@* pe-dll.c (autofilter_entry_type autofilter_liblist: Add
startup files for mingw32 dlls to list.
@
text
@d244 2
d423 1
a423 1
      char * p;
a444 1
      afptr = autofilter_objlist;
d446 3
d451 1
a451 3
	  if (abfd && 
	      (p = strstr (abfd->filename, afptr->name)) &&
	      (*(p + afptr->len - 1) == 0))
a452 1

d454 1
@


1.34
log
@Fix thinko
@
text
@d242 2
@


1.33
log
@Remove spurious prototype.
@
text
@d2069 1
a2069 1
    char * dll_symname = pe_data_import_dll ? "unknown" : pe_data_import_dll;
@


1.32
log
@oops - omitted from previous delta
@
text
@a125 4
/* Defined in emultempl/pe.em.  */
extern char *
pe_get_data_import_dll_name PARAMS ((void));

@


1.31
log
@Define and use pe_get_data_import_dll_name().
@
text
@d2072 4
a2075 2
    bfd *b = make_import_fixup_entry (name, fixup_name,
				      pe_get_data_import_dll_name (),
@


1.30
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d126 4
d2072 2
a2073 3
    extern char * pe_data_import_dll;  /* Defined in emultempl/pe.em.  */
    
    bfd *b = make_import_fixup_entry (name, fixup_name, pe_data_import_dll,
@


1.29
log
@	* deffilep.y (def_stash_module): Constify "name" param.

	* pe-dll.c: Replace CONST with const throughout.
	(quick_symbol): Constify "n1", "n2", "n3" params.
	(make_singleton_name_thunk): Constify "import" param.  Make
	"buffer_len" a size_t.
	(make_import_fixup_entry): Constify "name", "fixup_name",
	"dll_symname" params.
	(pe_get16): Cast args of bfd_seek.  Replace bfd_read with bfd_bread.
	(pe_get32): Likewise.
	(pe_implied_import_dll): Likewise.

	* emultempl/beos.em (sort_by_file_name): Constify "ra", "rb".
	(sort_by_section_name): Likewise.

	* emultempl/pe.em: Move defines for arm_epoc_pe before bfd.h included.
	(make_import_fixup): Cast printf arg, rel->address to long rather
	than int.
	(gld_${EMULATION_NAME}_after_open): Don't compare NULL against int.
@
text
@d26 1
a28 1
#include <ctype.h>
d1257 1
a1257 1
	|| isspace ((unsigned char) *cp)
d2091 1
a2091 1
    if (!isalnum ((unsigned char) dll_symname[i]))
d2188 1
a2188 1
	if (!isalnum (dll_symname[i]))
@


1.28
log
@Fix memory leak
@
text
@d284 2
a285 1
  PARAMS ((bfd *, char *, char *, char *, asection *, int, int));
d290 1
a290 1
static bfd *make_singleton_name_thunk PARAMS ((char *, bfd *));
d292 2
a293 1
static bfd *make_import_fixup_entry PARAMS ((char *, char *, char *, bfd *));
d993 1
a993 1
     CONST char *name;
d1479 3
a1481 3
     char *n1;
     char *n2;
     char *n3;
d1898 1
a1898 1
     char *import;
d1946 1
a1946 1
  static unsigned int buffer_len = 0;
d1994 3
a1996 3
     char *name;
     char *fixup_name;
     char *dll_symname;
d2051 1
a2051 1
  CONST char *name = sym->name;
d2154 1
a2154 1
     CONST char *name;
d2255 2
a2256 2
  bfd_seek (abfd, where, SEEK_SET);
  bfd_read (b, 1, 2, abfd);
d2267 2
a2268 2
  bfd_seek (abfd, where, SEEK_SET);
  bfd_read (b, 1, 4, abfd);
d2348 2
a2349 2
      bfd_seek (dll, secptr1, SEEK_SET);
      bfd_read (sname, 1, 8, dll);
d2361 2
a2362 2
  bfd_seek (dll, expptr, SEEK_SET);
  bfd_read (expdata, 1, export_size, dll);
@


1.27
log
@2001-09-12  Paul Sokolovsky  <Paul.Sokolovsky@@technologist.com>
        * emultempl/pe.em(make_import_fixup): change signature to
        take asection as well as arelec; we need this for proper
        error reporting.  Only call pe_create_import_fixup() if
        there is no attempt to add a constant addend to the reloc;
        otherwise, report error condition.
        * pe-dll.c(pe_walk_relocs_of_symbol): change signature,
        since final argument is a pointer to make_import_fixup().
        Change call to cb() to match make_import_fixup() signature.
        (make_import_fixup_mark): make buffer_len unsigned.
        * pe-dll.h: change signature of pe_walk_relocs_of_symbol.
2001-09-12  Charles Wilson  <cwilson@@ece.gatech.edu>
        * ld.texinfo: add verbose documentation for auto-import
        direct-addressing workaround, to compliment the terse
        error message.
@
text
@d44 76
a119 1
/************************************************************************
d121 1
a121 85
 This file turns a regular Windows PE image into a DLL.  Because of
 the complexity of this operation, it has been broken down into a
 number of separate modules which are all called by the main function
 at the end of this file.  This function is not re-entrant and is
 normally only called once, so static variables are used to reduce
 the number of parameters and return values required.

 See also: ld/emultempl/pe.em

 ************************************************************************/

/************************************************************************

 Auto-import feature by Paul Sokolovsky

 Quick facts:

 1. With this feature on, DLL clients can import variables from DLL
 without any concern from their side (for example, without any source
 code modifications).

 2. This is done completely in bounds of the PE specification (to be fair,
 there's a place where it pokes nose out of, but in practise it works).
 So, resulting module can be used with any other PE compiler/linker.

 3. Auto-import is fully compatible with standard import method and they
 can be mixed together.

 4. Overheads: space: 8 bytes per imported symbol, plus 20 for each
 reference to it; load time: negligible; virtual/physical memory: should be
 less than effect of DLL relocation, and I sincerely hope it doesn't affect
 DLL sharability (too much).

 Idea

 The obvious and only way to get rid of dllimport insanity is to make client
 access variable directly in the DLL, bypassing extra dereference. I.e.,
 whenever client contains someting like

 mov dll_var,%eax,

 address of dll_var in the command should be relocated to point into loaded
 DLL. The aim is to make OS loader do so, and than make ld help with that.
 Import section of PE made following way: there's a vector of structures
 each describing imports from particular DLL. Each such structure points
 to two other parellel vectors: one holding imported names, and one which
 will hold address of corresponding imported name. So, the solution is
 de-vectorize these structures, making import locations be sparse and
 pointing directly into code. Before continuing, it is worth a note that,
 while authors strives to make PE act ELF-like, there're some other people
 make ELF act PE-like: elfvector, ;-) .

 Implementation

 For each reference of data symbol to be imported from DLL (to set of which
 belong symbols with name <sym>, if __imp_<sym> is found in implib), the
 import fixup entry is generated. That entry is of type
 IMAGE_IMPORT_DESCRIPTOR and stored in .idata$3 subsection. Each
 fixup entry contains pointer to symbol's address within .text section
 (marked with __fuN_<sym> symbol, where N is integer), pointer to DLL name
 (so, DLL name is referenced by multiple entries), and pointer to symbol
 name thunk. Symbol name thunk is singleton vector (__nm_th_<symbol>)
 pointing to IMAGE_IMPORT_BY_NAME structure (__nm_<symbol>) directly
 containing imported name. Here comes that "om the edge" problem mentioned
 above: PE specification rambles that name vector (OriginalFirstThunk)
 should run in parallel with addresses vector (FirstThunk), i.e. that they
 should have same number of elements and terminated with zero. We violate
 this, since FirstThunk points directly into machine code. But in practise,
 OS loader implemented the sane way: it goes thru OriginalFirstThunk and
 puts addresses to FirstThunk, not something else. It once again should be
 noted that dll and symbol name structures are reused across fixup entries
 and should be there anyway to support standard import stuff, so sustained
 overhead is 20 bytes per reference. Other question is whether having several
 IMAGE_IMPORT_DESCRIPTORS for the same DLL is possible. Answer is yes, it is
 done even by native compiler/linker (libth32's functions are in fact reside
 in windows9x kernel32.dll, so if you use it, you have two
 IMAGE_IMPORT_DESCRIPTORS for kernel32.dll). Yet other question is whether
 referencing the same PE structures several times is valid. The answer is why
 not, prohibitting that (detecting violation) would require more work on
 behalf of loader than not doing it.


 See also: ld/emultempl/pe.em

 ************************************************************************/
d124 1
a124 2
add_bfd_to_link (bfd *abfd, CONST char *name, 
                 struct bfd_link_info *link_info);
d126 1
a126 1
/* for emultempl/pe.em */
d128 1
a128 1
def_file *pe_def_file = 0;
d137 1
a137 5
/************************************************************************

 static variables and types

 ************************************************************************/
a139 1

d145 10
a154 8
typedef struct {
  char *target_name;
  char *object_target;
  unsigned int imagebase_reloc;
  int pe_arch;
  int bfd_arch;
  int underscored;
} pe_details_type;
d156 6
a161 4
typedef struct {
  char *name;
  int len;
} autofilter_entry_type;
d167 1
d169 2
a170 1
static pe_details_type pe_detail_list[] = {
d203 8
d216 2
a217 1
static autofilter_entry_type autofilter_symbollist[] = {
d227 4
a230 2
/* Do not specify library suffix explicitly, to allow for dllized versions */
static autofilter_entry_type autofilter_liblist[] = {
d236 3
a238 1
static autofilter_entry_type autofilter_objlist[] = {
d244 5
a248 3
static autofilter_entry_type autofilter_symbolprefixlist[] = {
/*  { "__imp_", 6 }, */
/* Do __imp_ explicitly to save time */
d251 2
a252 1
  { "_head_", 6 }, /* don't export symbols specifying internal DLL layout */
d263 3
a265 1
static autofilter_entry_type autofilter_symbolsuffixlist[] = {
d301 1
d313 2
a314 1
/************************************************************************
d316 7
a322 10
 Helper functions for qsort.  Relocs must be sorted so that we can write
 them out by pages.

 ************************************************************************/

typedef struct {
  bfd_vma vma;
  char type;
  short extra;
} reloc_data_type;
d330 1
d340 1
d344 1
a344 5
/************************************************************************

 Read and process the .DEF file

 ************************************************************************/
a351 1

d360 6
a365 4
typedef struct exclude_list_struct {
  char *string;
  struct exclude_list_struct *next;
} exclude_list_struct;
d394 3
a396 4
/*
   abfd is a bfd containing n (or NULL)
   It can be used for contextual checks.
*/
d407 1
a407 1
  /* we should not re-export imported stuff */
d414 1
d417 3
d421 2
a422 4
	{
	  printf ("considering exporting: %s, abfd=%p, abfd->my_arc=%p\n",
		  n, abfd, abfd->my_archive);
	}
d425 1
a425 1
         Don't export anything from libgcc */
d429 1
d438 12
a449 13
      /* Next, exclude symbols from certain startup objects */
      {
	char *p;
	afptr = autofilter_objlist;
	while (afptr->name)
	  {
	    if (abfd && 
	        (p = strstr (abfd->filename, afptr->name)) &&
	        (*(p + afptr->len - 1) == 0))
	      return 0;
	    afptr++;
	  }
      }
d453 1
a453 1
	 it is too restrictive */
d455 1
a455 1
      /* Then, exclude specific symbols */
d461 2
a462 1
	  afptr++;
d465 1
a465 1
      /* Next, exclude symbols starting with ... */
d471 2
a472 1
	  afptr++;
d475 13
a487 14
      /* Finally, exclude symbols ending with ... */
      {
	int len = strlen(n);
	afptr = autofilter_symbolsuffixlist;
	while (afptr->name)
	  {
	    if ((len >= afptr->len) && 
		/* add 1 to insure match with trailing '\0' */
		strncmp (n + len - afptr->len, afptr->name, 
			 afptr->len + 1) == 0)
	      return 0;
	    afptr++;
	  }
      }
d489 1
d493 1
a512 1

d520 1
a527 1

d543 1
a543 2
	         We should not export undefined symbols
	      */
d550 1
a550 1
		  /* we should not re-export imported stuff */
d554 1
d565 1
d570 1
a570 1
		      /* Fill data flag properly, from dlltool.c */
a581 1

d592 1
d606 1
d653 1
d673 1
d734 1
a734 5
/************************************************************************

 Build the bfd that will contain .edata and .reloc sections

 ************************************************************************/
d783 1
d789 1
a789 5
/************************************************************************

 Gather all the exported symbols and build the .edata section

 ************************************************************************/
a801 1

d803 1
a803 3
    {
      dll_name = pe_def_file->name;
    }
d807 1
d809 2
a810 4
	{
	  if (*dlnp == '\\' || *dlnp == '/' || *dlnp == ':')
	    dll_name = dlnp + 1;
	}
d823 1
a824 1

d838 1
d859 2
a860 1
	    next_ordinal++;
d866 2
a867 3

  edata_sz = (40		/* directory */
	      + 4 * export_table_size	/* addresses */
d887 1
d901 2
a902 3
	{
	  exported_symbol_offsets[i] = blhe->u.def.value;
	}
d940 1
d958 1
d969 1
d999 6
a1004 2
      arelent **relocs;
      int relsize, nrelocs, i;
d1008 2
a1009 2
	  asymbol **symbols;
	  int nsyms, symsize;
d1012 1
a1012 1
	  /* Skip discarded linkonce sections */
a1018 4
	  symsize = bfd_get_symtab_upper_bound (b);
	  symbols = (asymbol **) xmalloc (symsize);
	  nsyms = bfd_canonicalize_symtab (b, symbols);

d1026 3
a1028 1
	      if (!strcmp(name,sym->name)) cb(relocs[i], s);
d1030 1
d1032 1
d1040 1
a1040 5
/************************************************************************

 Gather all the relocations and build the .reloc section

 ************************************************************************/
d1117 1
a1170 1

d1179 1
a1179 1
	  reloc_sz = (reloc_sz + 3) & ~3;	/* 4-byte align */
d1189 2
a1190 2
  reloc_sz = (reloc_sz + 3) & ~3;	/* 4-byte align */

a1191 1

d1196 1
d1201 1
d1206 1
d1209 1
d1216 1
d1220 1
d1226 1
d1229 1
d1232 1
d1235 1
d1240 2
a1241 6
/************************************************************************

 Given the exiting def_file structure, print out a .DEF file that
 corresponds to it.

 ************************************************************************/
d1250 1
d1259 1
d1263 1
d1268 1
d1272 1
d1285 1
d1287 3
a1289 5
    {
      /* xgettext:c-format */
      einfo (_("%s: Can't open output def file %s\n"),
	     program_name, pe_out_def_filename);
    }
d1299 1
d1301 1
d1329 1
d1339 1
d1344 1
d1350 1
d1353 1
d1356 1
d1359 1
d1362 1
d1370 1
d1376 1
d1382 1
d1385 1
d1388 1
d1391 1
d1394 1
d1405 1
d1410 1
d1417 1
d1420 1
d1425 1
d1434 2
a1435 4
    {
      /* xgettext:c-format */
      einfo (_("%P: Error closing file `%s'\n"), pe_out_def_filename);
    }
d1438 1
a1438 5
/************************************************************************

 Generate the import library

 ************************************************************************/
d1486 1
d1527 1
d1539 16
a1554 18
/*
 *	.section	.idata$2
 *	.global		__head_my_dll
 * __head_my_dll:
 *	.rva		hname
 *	.long		0
 *	.long		0
 *	.rva		__my_dll_iname
 *	.rva		fthunk
 *
 *	.section	.idata$5
 *	.long		0
 * fthunk:
 *
 *	.section	.idata$4
 *	.long		0
 * hname:
 */
d1594 1
a1594 1
  d2[0] = d2[16] = 4; /* reloc addend */
d1620 8
a1627 10
/*
 *	.section	.idata$4
 *	.long		0
 *	.section	.idata$5
 *	.long		0
 *	.section	idata$7
 *	.global		__my_dll_iname
 *__my_dll_iname:
 *	.asciz		"my.dll"
 */
d1685 20
a1704 22
/*
 *	.text
 *	.global		_function
 *	.global		___imp_function
 *	.global		__imp__function
 *_function:
 *	jmp		*__imp__function:
 *
 *	.section	idata$7
 *	.long		__head_my_dll
 *
 *	.section	.idata$5
 *___imp_function:
 *__imp__function:
 *iat?
 *	.section	.idata$4
 *iat?
 *	.section	.idata$6
 *ID<ordinal>:
 *	.short		<hint>
 *	.asciz		"function" xlate? (add underscore, kill at)
 */
d1706 2
a1707 1
static unsigned char jmp_ix86_bytes[] = {
d1711 6
a1716 8
/*
 *_function:
 *	mov.l	ip+8,r0
 *	mov.l	@@r0,r0
 *	jmp	@@r0
 *	nop
 *	.dw	__imp_function
 */
d1718 2
a1719 1
static unsigned char jmp_sh_bytes[] = {
d1723 5
a1727 7
/*
 *_function:
 *	lui	$t0,<high:__imp_function>
 *	lw	$t0,<low:__imp_function>
 *	jr	$t0
 *	nop
 */
d1729 2
a1730 1
static unsigned char jmp_mips_bytes[] = {
d1762 2
d1788 2
a1789 2
  /* symbol to reference ord/name of imported symbol, used to implement
     auto-import */
d1796 24
a1819 21
  {
    bfd_set_section_size (abfd, tx, jmp_byte_count);
    td = (unsigned char *) xmalloc (jmp_byte_count);
    tx->contents = td;
    memcpy (td, jmp_bytes, jmp_byte_count);
    switch (pe_details->pe_arch)
      {
      case PE_ARCH_i386:
        quick_reloc (abfd, 2, BFD_RELOC_32, 2);
        break;
      case PE_ARCH_sh:
        quick_reloc (abfd, 8, BFD_RELOC_32, 2);
        break;
      case PE_ARCH_mips:
        quick_reloc (abfd, 0, BFD_RELOC_HI16_S, 2);
        quick_reloc (abfd, 0, BFD_RELOC_LO16, 0); /* MIPS_R_PAIR */
        quick_reloc (abfd, 4, BFD_RELOC_LO16, 2);
        break;
      }
    save_relocs (tx);
  }
d1832 1
d1849 1
d1899 1
a1899 2
  /* name thunks go to idata$4 */

d1941 1
a1941 1
  /* we convert reloc to symbol, for later reference */
d1958 1
a1958 1
  /* assume 25 chars for "__fu" + counter + "_".  If counter is 
d1960 1
a1960 1
     overflowing this buffer... */
d1963 2
a1964 2
      /* new buffer size is length of symbol, plus 25, but then
	 rounded up to the nearest multiple of 128 */
d1976 4
a1979 4
/*
  printf("type:%d\n",myh->type);
  printf("%s\n",myh->root.u.def.section->name);
*/
d1983 6
a1988 10

/*
 *	.section	.idata$3
 *	.rva		__nm_thnk_SYM (singleton thunk with name of func)
 *	.long		0
 *	.long		0
 *	.rva		__my_dll_iname (name of dll)
 *	.rva		__fuNN_SYM (pointer to reference (address) in text)
 *
 */
d2016 4
a2019 3
/*  
  quick_symbol (abfd, U("_head_"), dll_symname, "", id2, BSF_GLOBAL, 0); 
*/
d2061 1
a2061 1
      /* If we ever use autoimport, we have to cast text section writable */
d2066 2
a2067 1
    extern char *pe_data_import_dll;
a2109 1

d2117 1
a2130 1

d2156 1
d2162 1
d2173 1
d2242 3
a2244 7
/************************************************************************

 We were handed a *.DLL file.  Parse it and turn it into a set of
 IMPORTS directives in the def file.  Return true if the file was
 handled, false if not.

 ************************************************************************/
d2252 1
d2264 1
d2277 1
d2288 1
a2304 1

d2311 1
d2327 2
a2328 1
  if (num_entries < 1) /* no exports */
d2330 1
d2337 1
d2345 1
d2348 1
d2370 1
d2375 1
d2383 4
a2386 8
/************************************************************************

 These are the main functions, called from the emulation.  The first
 is called after the bfds are read, so we can guess at how much space
 we need.  The second is called after everything is placed, so we
 can put the right values in place.

 ************************************************************************/
@


1.26
log
@	* deffilep.y: Add missing prototypes.
	* pe-dll.c: Likewise.
@
text
@d985 1
a985 1
     int (*cb) (arelent *);
d988 1
a988 1
  struct sec *s;
d1006 1
a1006 1
	  current_sec=s;
d1019 1
a1019 1
	      if (!strcmp(name,sym->name)) cb(relocs[i]);
d1911 1
a1911 1
  static int buffer_len = 0;
@


1.25
log
@	* pe-dll.c (pe_dll_fill_sections): Correct type of "relax" param
	passed to lang_size_sections.
	(pe_exe_fill_sections): Likewise.
	* emultempl/pe.em (output_prev_sec_find): Copied from elf32.em.
	(gld_${EMULATION_NAME}_place_orphan): Merge from elf32.em.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000 Free Software Foundation, Inc.
d262 24
@


1.24
log
@2001-08-02  Charles Wilson  <cwilson@@ece.gatech.edu>
        * ldmain.c (main): initialize link_info.pei386_auto_import
        * pe-dll.c: new tables for auto-export filtering
        (auto_export): change API, pass abfd for contextual filtering.
        Loop thru tables of excluded symbols instead of comparing
        "by hand".
2001-08-02  Paul Sokolovsky  <paul.sokolovsky@@technologist.com>
        * pe-dll.c: new variable pe_dll_enable_extra_debug. New
        static variable current_sec (static struct sec *). Add
        forward declaration for add_bfd_to_link.
        (process_def_file): Don't export undefined symbols. Do not
        export symbols starting with  "_imp__".  Call auto_export()
        with new API.
        (pe_walk_relocs_of_symbol): New function.
        (generate_reloc): add optional extra debugging
        (pe_dll_generate_def_file): eliminate extraneous initial blank
        line in output
        (make_one): enlarge symtab to make room for __nm__ symbols
        (DATA auto-import support).
        (make_singleton_name_thunk): New function.
        (make_import_fixup_mark): New function.
        (make_import_fixup_entry): New function.
        (pe_create_import_fixup): New function.
        (add_bfd_to_link): Specify that 'name' argument is a CONST
        char *.
        * pe-dll.h: declare new variable pe_dll_extra_pe_debug;
        declare new functions pe_walk_relocs_of_symbol and
        pe_create_import_fixup.
        * emultempl/pe.em: add new options --enable-auto-import,
        --disable-auto-import, and --enable-extra-pe-debug.
        (make_import_fixup): New function.
        (pe_find_data_imports): New function.
        (pr_sym): New function.
        (gld_${EMULATION_NAME}_after_open): Add optional extra pe
        debugging. Call pe_find_data_imports.  Mark .idata as DATA, not
        CODE.
2001-08-02  Charles Wilson  <cwilson@@ece.gatech.edu>
        * ld.texinfo: add additional documentation for
        --export-all-symbols.  Document --out-implib,
        --enable-auto-image-base, --disable-auto-image-base,
        --dll-search-prefix, --enable-auto-import, and
        --disable-auto-import.
        * ldint.texinfo: Add detailed documentation on auto-import
        implementation.
@
text
@d2364 1
a2364 1
			  &stat_ptr->head, 0, (bfd_vma) 0, false);
d2398 1
a2398 1
			  &stat_ptr->head, 0, (bfd_vma) 0, false);
@


1.23
log
@Fixtypos in ChangeLogs, fix copyright dates in files
@
text
@d57 79
d145 1
d169 5
d217 44
d363 4
d368 2
a369 1
auto_export (d, n)
d375 6
d386 69
a454 6
      if (strcmp (n, "DllMain@@12") == 0)
	return 0;
      if (strcmp (n, "DllEntryPoint@@0") == 0)
	return 0;
      if (strcmp (n, "impure_ptr") == 0)
	return 0;
d508 6
a513 3
	         anything at all.  (.bss data is the latter)  */
	      if ((symbols[j]->flags & BSF_GLOBAL)
		  || (symbols[j]->flags == BSF_NO_FLAGS))
d516 13
d531 7
a537 7
		  if (auto_export (pe_def_file, sn))
                    {
                      def_file_export *p;
                      p=def_file_add_export (pe_def_file, sn, 0, -1);
                      /* Fill data flag properly, from dlltool.c */
                      p->flag_data = !(symbols[j]->flags & BSF_FUNCTION);
                    }
d572 1
a572 1
	      if (auto_export (pe_def_file, tmp))
d574 2
a575 1
				     pe_def_file->exports[i].internal_name, -1);
d954 51
d1032 2
a1033 1
  reloc_data = (reloc_data_type *) xmalloc (total_relocs * sizeof (reloc_data_type));
d1076 5
d1319 1
a1319 1
	  fprintf (out, "\nEXPORTS\n\n");
d1725 1
a1725 1
  symtab = (asymbol **) xmalloc (10 * sizeof (asymbol *));
d1735 3
d1836 184
d2098 1
a2098 1
     char *name;
@


1.22
log
@* pe-dll.c (make_one): Do not generate code thunk for DATA
exports.
(process_def_file): deduce DATA flag for auto-export sumbols.
@
text
@d2 1
a2 1
   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.
@


1.22.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000 Free Software Foundation, Inc.
@


1.21
log
@2000-10-09  Kazu Hirata  <kazu@@hxi.com>

	* pe-dll.c: Revert some formatting fixes.
@
text
@d313 6
a318 1
		    def_file_add_export (pe_def_file, sn, 0, -1);
d1413 1
a1413 1
  unsigned char *td, *d7, *d5, *d4, *d6 = NULL;
d1462 22
a1483 19
  bfd_set_section_size (abfd, tx, jmp_byte_count);
  td = (unsigned char *) xmalloc (jmp_byte_count);
  tx->contents = td;
  memcpy (td, jmp_bytes, jmp_byte_count);
  switch (pe_details->pe_arch)
    {
    case PE_ARCH_i386:
      quick_reloc (abfd, 2, BFD_RELOC_32, 2);
      break;
    case PE_ARCH_sh:
      quick_reloc (abfd, 8, BFD_RELOC_32, 2);
      break;
    case PE_ARCH_mips:
      quick_reloc (abfd, 0, BFD_RELOC_HI16_S, 2);
      quick_reloc (abfd, 0, BFD_RELOC_LO16, 0); /* MIPS_R_PAIR */
      quick_reloc (abfd, 4, BFD_RELOC_LO16, 2);
      break;
    }
  save_relocs (tx);
@


1.20
log
@2000-10-09  Kazu Hirata  <kazu@@hxi.com>

	* pe-dll.c: Fix formatting.
@
text
@d87 1
a87 2
}
pe_details_type;
d161 1
a161 2
}
reloc_data_type;
d205 1
a205 2
}
exclude_list_struct;
d848 3
@


1.19
log
@2000-10-08  Kazu Hirata  <kazu@@hxi.com>

	* pe-dll.c: Fix formatting.
@
text
@d87 2
a88 1
} pe_details_type;
d162 2
a163 1
} reloc_data_type;
d204 4
a207 5
typedef struct exclude_list_struct
  {
    char *string;
    struct exclude_list_struct *next;
  }
d209 1
d277 1
a277 1
     sections, and push those into the def file too */
d292 1
a292 1
  /* Now, maybe export everything else the default way */
d308 1
a308 1
	         anything at all (.bss data is the latter)  */
d325 1
a325 1
  /* Canonicalize the export list */
d333 3
a335 2
	      /* This will preserve internal_name, which may have been pointing
	         to the same memory as name, or might not have */
d360 2
a361 1
  e = pe_def_file->exports; /* convenience, but watch out for it changing */
d580 1
a580 1
  /* Now we need to assign ordinals to those that don't have them */
d614 1
a614 1
  /* OK, now we can allocate some memory */
d674 1
a674 1
  /* Note use of array pointer math here */
d702 1
a702 1
  /* Ok, now for the filling in part */
d744 1
a744 1
  /* for .reloc stuff */
d774 1
a774 1
	  /* if it's not loaded, we don't need to relocate it this way */
d779 1
a779 1
	     seen it happen - DJ */
d785 1
a785 1
	      /* Huh?  Shouldn't happen, but punt if it does */
d829 4
a832 3
		      /* FIXME: we can't know the symbol's right value yet,
			 but we probably can safely assume that CE will relocate
			 us in 64k blocks, so leaving it zero is safe.  */
d849 2
a850 3
	  /* Warning: the allocated symbols are remembered in BFD and reused
	     later, so don't free them! */
	  /* free (symbols); */
d1121 1
a1121 5
  bfd_set_section_flags (abfd, sec, flags
				  | SEC_ALLOC
				  | SEC_LOAD
				  | SEC_KEEP
			 );
d1123 1
a1123 1
  /* remember to undo this before trying to link internally! */
d1588 1
a1588 1
      /* The import library doesn't know about the internal name */
d1603 1
a1603 1
  /* Now stick them all into the archive */
d1668 1
a1668 1
	    /* see if we need this import */
d1684 1
a1684 1
		/* we do */
d1783 1
a1783 1
  /* PEI dlls seem to be bfd_objects */
@


1.18
log
@* pe-dll.c (fill_edata): initialize entire block
(make_one): fill in correct section.
@
text
@d139 1
a139 1
  for (i=0; pe_detail_list[i].target_name; i++)
d143 1
a143 1
	pe_details = pe_detail_list+i;
d269 1
a269 1
  def_file_export *e=0;
d305 2
a306 2
              /* We should export symbols which are either global or not
                 anything at all (.bss data is the latter)  */
d308 1
a308 1
                  || (symbols[j]->flags == BSF_NO_FLAGS))
d423 1
a423 1
          && (blhe->type == bfd_link_hash_defined
d433 1
a433 1
          if (blhe->type == bfd_link_hash_defined)
d648 1
a648 1
        }
d896 1
a896 1
      bfd_put_16 (abfd, (rva & 0xfff) + (reloc_data[i].type<<12),
d924 1
a924 1
     FILE * f;
d1107 1
a1107 1
quick_section(abfd, name, flags, align)
d1169 1
a1169 1
  if (relcount >= (relsize-1))
d1190 2
a1191 2
  sec->orelocation = (arelent **) xmalloc ((relcount+1) * sizeof (arelent *));
  for (i=0; i<relcount; i++)
d1243 2
a1244 2
  quick_symbol (abfd, U("_head_"), dll_symname, "", id2, BSF_GLOBAL, 0);
  quick_symbol (abfd, U(""), dll_symname, "_iname", UNDSEC, BSF_GLOBAL, 0);
d1319 1
a1319 1
  quick_symbol (abfd, U(""), dll_symname, "_iname", id7, BSF_GLOBAL, 0);
d1331 1
a1331 1
  len = strlen (dll_filename)+1;
d1333 1
a1333 1
    len ++;
d1450 3
a1452 3
    quick_symbol (abfd, U(""), exp->internal_name, "", tx, BSF_GLOBAL, 0);
  quick_symbol (abfd, U("_head_"), dll_symname, "", UNDSEC, BSF_GLOBAL, 0);
  quick_symbol (abfd, U("_imp__"), exp->internal_name, "", id5, BSF_GLOBAL, 0);
d1454 2
a1455 2
    quick_symbol (abfd, U("__imp_"), exp->internal_name, "",
                  id5, BSF_GLOBAL, 0);
d1532 1
a1532 1
      strcpy (d6+2, exp->name);
d1561 1
a1561 1
  for (i=0; dll_symname[i]; i++)
d1586 1
a1586 1
  for (i = 0; i<def->num_exports; i++)
d1592 1
a1592 1
      n = make_one (def->exports+i, outarch);
d1645 1
a1645 1
  pe_dll_id_target(bfd_get_target (output_bfd));
d1656 1
a1656 1
      for (i=0; dll_symname[i]; i++)
d1662 1
a1662 1
      for (i=0; i<pe_def_file->num_imports; i++)
d1670 1
a1670 1
	    sprintf (name, "%s%s", U(""), pe_def_file->imports[i].internal_name);
d1675 1
a1675 1
		sprintf (name, "%s%s", U("_imp__"),
d1729 1
a1729 1
  return b[0] + (b[1]<<8);
d1740 1
a1740 1
  return b[0] + (b[1]<<8) + (b[2]<<16) + (b[3]<<24);
d1750 1
a1750 1
  return b[0] + (b[1]<<8);
d1760 1
a1760 1
  return b[0] + (b[1]<<8) + (b[2]<<16) + (b[3]<<24);
d1791 1
a1791 1
  for (i=0; filename[i]; i++)
d1806 1
a1806 1
  for (i=0; i<nsections; i++)
d1813 3
a1815 3
      bfd_seek(dll, secptr1, SEEK_SET);
      bfd_read(sname, 1, 8, dll);
      if (vaddr <= export_rva && vaddr+vsize > export_rva)
d1830 1
a1830 1
    pe_def_file = def_file_empty();
d1832 5
a1836 5
  nexp = pe_as32 (expdata+24);
  name_rvas = pe_as32 (expdata+32);
  ordinals = pe_as32 (expdata+36);
  ordbase = pe_as32 (expdata+16);
  for (i=0; i<nexp; i++)
d1838 1
a1838 1
      unsigned long name_rva = pe_as32 (erva+name_rvas+i*4);
d1840 1
a1840 1
      imp = def_file_add_import (pe_def_file, erva+name_rva, dll_name,
@


1.17
log
@* emultempl/pe.em (gld_*_after_open): detect case where there two
import libraries for same dll; rename one to ensure proper link
order.

* pe-dll.c (process_def_file): compare ordinals to -1, not 0; fix
typo
(generate_edata): fix typo
@
text
@d679 1
a679 1
  memset (edata_d, 0, 40);
d1506 3
a1508 3
      d5[0] = exp->ordinal;
      d5[1] = exp->ordinal >> 8;
      d5[3] = 0x80;
@


1.16
log
@2000-09-29  Kazu Hirata  <kazu@@hxi.com>

	* deffile.h: Fix formatting.
	* ld.h: Likewise.
	* ldctor.h: Likewise.
	* ldemul.h: Likewise.
	* ldexp.h: Likewise.
	* ldfile.h: Likewise.
	* ldlang.h: Likewise.
	* lexsup.c: Likewise.
	* mri.c: Likewise.
	* pe-dll.c: Likewise.
@
text
@d381 1
a381 1
		einfo (_("%XError, duplicate EXPORT with oridinals: %s (%d vs %d)\n"),
d391 1
a391 1
	  if (e[i].ordinal)
d588 1
a588 1
		  einfo (_("%XError, oridinal used twice: %d (%s vs %s)\n"),
@


1.15
log
@* pe-dll.c (process_def_file): Uninitialized data wasn't
exported with --export-all-symbols switch.

* pe-dll.c (fill_edata): rearrange the data so that ordinals and
noname work properly.
@
text
@d189 1
a189 1
   defined, since we can't export symbols we don't have. */
d437 1
a437 1
	  
d544 1
a544 1
     and what the range of ordinals is. */
d629 1
a629 1
  
d809 1
a809 1
		  
d811 1
a811 1
				    
d852 1
a852 1
     We must now create the new sections. */
d859 1
a859 1
      
d866 1
a866 1
      
d868 1
a868 1
      
d1250 1
a1250 1
     the start of the list of sections from other objects. */
d1277 1
a1277 1
  
d1454 1
a1454 1
    quick_symbol (abfd, U("__imp_"), exp->internal_name, "", 
d1578 1
a1578 1
  
d1582 1
a1582 1
  /* Work out a reasonable size of things to put onto one line. */
d1611 1
a1611 1
  
d1775 1
a1775 1
     the middle of the .rdata section. */
@


1.14
log
@* pe-dll.c (pe_dll_id_target): check object target name also
@
text
@d305 4
a308 1
	      if (symbols[j]->flags & BSF_GLOBAL)
d709 1
d711 2
a712 1
	  bfd_put_32 (abfd, srva - image_base, (void *) (eaddresses + i));
d717 1
d720 2
a721 2
	      bfd_put_16 (abfd, i, (void *) eordinals);
	      enameptrs++;
a723 1
	  eordinals++;
@


1.13
log
@* pe-dll.c (process_def_file): auto-export data items also
(pe_process_import_defs): also see if _imp_ form needed
@
text
@d140 2
a141 1
    if (strcmp (pe_detail_list[i].target_name, target) == 0)
@


1.12
log
@* pe-dll.c (make_one): fix a typo in the __imp_ name decoration
for dll import libraries
@
text
@d304 1
a304 2
	      if ((symbols[j]->flags & (BSF_FUNCTION | BSF_GLOBAL))
		  == (BSF_FUNCTION | BSF_GLOBAL))
d1663 1
a1663 1
	    char *name = (char *) xmalloc (strlen (pe_def_file->imports[i].internal_name) + 2);
d1667 7
@


1.11
log
@Remove some forward declarations in ldemul.h and ldfile.h, and
re-arrange header include order.
Fix shadowing warnings in ldlang.h
Fix compile errors in mpw-elfmips.c
@
text
@d1447 1
a1447 1
  quick_symbol (abfd, U("__imp_"), exp->internal_name, "", id5, BSF_GLOBAL, 0);
@


1.10
log
@Fix building with --enable-targets=all.
@
text
@d37 1
@


1.9
log
@Add support for WinCE based toolchains.
@
text
@d620 1
a620 1
     bfd *abfd;
d623 1
a623 1
  int i, j;
d625 1
a625 4
  bfd *b;
  struct sec *s;
  def_file_export *e=0;

d1402 1
a1402 1
  unsigned char *td, *d7, *d5, *d4, *d6;
d1406 2
a1407 2
  unsigned char *jmp_bytes;
  int jmp_byte_count;
@


1.8
log
@Applied Mumit Kha's patch to tweak dll production code.
@
text
@d89 3
d102 24
d433 1
a433 1

d806 5
a810 2
		  switch (relocs[i]->howto->bitsize*1000
			  + relocs[i]->howto->rightshift)
d812 1
a812 1
		    case 32000:
d816 16
d856 1
d863 1
d865 3
d1373 25
d1418 8
d1462 8
@


1.7
log
@Added year 2000 copyright notice
@
text
@d63 2
d343 1
a343 1
	  /* This is a duplicate */
d348 4
a351 3
	      /* xgettext:c-format */
	      einfo (_("%XError, duplicate EXPORT with oridinals: %s (%d vs %d)\n"),
		     e[j - 1].name, e[j - 1].ordinal, e[i].ordinal);
d355 4
a358 3
	      /* xgettext:c-format */
	      einfo (_("Warning, duplicate EXPORT: %s\n"),
		     e[j - 1].name);
d1366 3
a1368 1
  quick_symbol (abfd, U("_imp__"), exp->internal_name, "", id5, BSF_GLOBAL, 0);
@


1.6
log
@Apply patch from Mumit Khan to fix bugs generating dll names.
@
text
@d2 1
a2 1
   Copyright (C) 1998, 1999 Free Software Foundation, Inc.
@


1.5
log
@* pe-dll.c (process_def_file): Move the offset lookup from here to
(fill_exported_offsets): here. New static function.
(fill_edata): Use.
@
text
@d1458 1
a1458 8
  dll_filename = def->name;
  if (dll_filename == 0)
    {
      dll_filename = dll_name;
      for (i=0; impfilename[i]; i++)
	if (impfilename[i] == '/' || impfilename[i] == '\\')
	  dll_filename = impfilename+1;
    }
@


1.4
log
@* deffilep.y (tokens): Add upper and lower case versions of DATA,
CONSTANT, NONAME and PRIVATE tokens.
(command): Use DATAU.
(expline): Allow for drectve syntax as well.
(exp_opt_list): Likewise.
(exp_opt): Likewise.
* pe-dll.c (make_one): Only generate the idata entries for data
symbols.
@
text
@d387 3
a389 1
      if (blhe && (blhe->type == bfd_link_hash_defined))
d394 9
a402 2
	  exported_symbol_offsets[i] = blhe->u.def.value;
	  exported_symbol_sections[i] = blhe->u.def.section;
d584 37
d663 2
@


1.3
log
@	* pe-dll.h: New file.
	* pe-dll.c: Include "pe-dll.h".  Mark unused arguments as needed
	to avoid warnings.
	(edata_sz, reloc_sz): Change from int to size_t.
	(pe_details_type): Change type of imagebase_reloc from int to
	unsigned int.
	(pe_detail_list): Fully initialize last entry.
	(pe_dll_id_target): Change parameter to const.
	(pe_dll_generate_def_file): Likewise.
	(pe_dll_generate_implib): Likewise.
	(pe_implied_import_dll): Likewise.  Change dll_name to const.
	* emultempl/pe.em: Include "pe-dll.h".  Remove declarations now in
	pe-dll.h.
	(init): Fully initialize __dll__ entry.
	(gld_${EMULATION_NAME}_after_open): Remove unused variables
	sequence, elt, and i.
	* deffile.h: Add preprocessor guard.
	* deffilep.y (def_debug): Remove.
	* Makefile.am: Rebuild dependencies.
	(HFILES): Add pe-dll.h.
@
text
@d1310 2
a1311 1
  quick_symbol (abfd, U(""), exp->internal_name, "", tx, BSF_GLOBAL, 0);
@


1.2
log
@1999-05-10  DJ Delorie  <dj@@cygnus.com>
	* scripttempl/pe.sc: Specify the output arch, which Ian says is
	the Right Thing to do.
	* emultempl/pe.em: various changes to parameterize the
	target-specific information.
	(gld_i386pe_after_open): Detect and fix MS import libraries
	by renaming the member objects (which are all named the same).
	* pe-dll.c: various changes to parameterize the target-specific
	information.
	(generate_reloc): support relocs more generically to allow for
	expansion.
	(pe_exe_build_sections): new; used to add .relocs to .exes
	(pe_exe_fill_sections): ditto
@
text
@d41 1
d75 1
a75 1
static int edata_sz, reloc_sz;
d80 1
a80 1
  int imagebase_reloc;
d97 1
a97 1
  { 0 }
d106 1
a106 1
     char *target;
d231 1
a231 1
     bfd *abfd;
d493 1
a493 1
     struct bfd_link_info *info;
d578 1
a578 1
     struct bfd_link_info *info;
d848 1
a848 1
     char *pe_out_def_filename;
d1401 1
a1401 1
     char *impfilename;
d1615 1
a1615 1
     char *filename;
d1622 1
a1622 1
  char *dll_name;
d1721 1
a1721 1
     struct bfd_link_info *info;
@


1.1
log
@Initial revision
@
text
@d76 42
d125 6
d135 3
a137 3
  bfd_vma a = *(bfd_vma *) va;
  bfd_vma b = *(bfd_vma *) vb;
  return (a > b) - (a < b);
d374 7
a380 2
      *name = '_';
      strcpy (name + 1, pe_def_file->exports[i].internal_name);
d432 2
a433 1
build_filler_bfd ()
d449 1
a449 8
  edata_s = bfd_make_section_old_way (filler_bfd, ".edata");
  if (edata_s == NULL
      || !bfd_set_section_flags (filler_bfd, edata_s,
				 (SEC_HAS_CONTENTS
				  | SEC_ALLOC
				  | SEC_LOAD
				  | SEC_KEEP
				  | SEC_IN_MEMORY)))
d451 13
a463 2
      einfo ("%X%P: can not create .edata section: %E\n");
      return;
a464 1
  bfd_set_section_size (filler_bfd, edata_s, edata_sz);
d658 1
a658 1
  bfd_vma *reloc_addresses;
d672 1
a672 1
  reloc_addresses = (bfd_vma *) xmalloc (total_relocs * sizeof (bfd_vma));
d716 1
a716 1
		  && relocs[i]->howto->type != R_IMAGEBASE)
d718 10
a727 1
		  switch (relocs[i]->howto->bitsize)
d729 3
a731 2
		    case 32:
		      reloc_addresses[total_relocs++] = sec_vma + relocs[i]->address;
d752 1
a752 1
  qsort (reloc_addresses, total_relocs, sizeof (bfd_vma), reloc_sort);
d756 1
a756 1
      unsigned long this_page = (reloc_addresses[i] >> 12);
d775 1
a775 1
      unsigned long rva = reloc_addresses[i] - image_base;
d789 2
a790 1
      bfd_put_16 (abfd, (rva & 0xfff) + 0x3000, reloc_d + reloc_sz);
d792 5
d1125 1
a1125 1
  bfd_find_target ("pe-i386", abfd);
d1129 1
a1129 1
  bfd_set_arch_mach (abfd, bfd_arch_i386, 0);
d1136 8
a1143 2
  quick_symbol (abfd, "__head_", dll_symname, "", id2, BSF_GLOBAL, 0);
  quick_symbol (abfd, "_", dll_symname, "_iname", UNDSEC, BSF_GLOBAL, 0);
d1201 1
a1201 1
  bfd_find_target ("pe-i386", abfd);
d1205 1
a1205 1
  bfd_set_arch_mach (abfd, bfd_arch_i386, 0);
d1212 1
a1212 1
  quick_symbol (abfd, "_", dll_symname, "_iname", id7, BSF_GLOBAL, 0);
d1280 10
d1296 1
a1296 1
  bfd_find_target ("pe-i386", abfd);
d1300 1
a1300 1
  bfd_set_arch_mach (abfd, bfd_arch_i386, 0);
d1309 4
a1312 4
  quick_symbol (abfd, "_", exp->internal_name, "", tx, BSF_GLOBAL, 0);
  quick_symbol (abfd, "__head_", dll_symname, "", UNDSEC, BSF_GLOBAL, 0);
  quick_symbol (abfd, "___imp_", exp->internal_name, "", id5, BSF_GLOBAL, 0);
  quick_symbol (abfd, "__imp__", exp->internal_name, "", id5, BSF_GLOBAL, 0);
d1314 2
a1315 2
  bfd_set_section_size (abfd, tx, 8);
  td = (unsigned char *) xmalloc (8);
d1317 7
a1323 2
  memcpy (td, jmp_ix86_bytes, 8);
  quick_reloc (abfd, 2, BFD_RELOC_32, 2);
d1386 1
a1386 1
  bfd_set_section_contents (abfd, tx, td, 0, 4);
a1440 4
  ar_tail = make_tail (outarch);

  if (ar_head == NULL || ar_tail == NULL)
    return;
d1454 5
d1501 1
d1526 1
a1526 1
	    sprintf (name, "_%s", pe_def_file->imports[i].internal_name);
d1626 1
a1626 1
  dll = bfd_openr (filename, "pei-i386");
d1710 1
d1714 10
a1723 1
  build_filler_bfd ();
d1731 1
d1757 28
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

