head	1.22;
access;
symbols
	msnyder-fork-checkpoint-branch:1.16.0.2
	msnyder-fork-checkpoint-branchpoint:1.16
	msnyder-tracepoint-checkpoint-branch:1.13.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.13
	jimb-rda-nptl-branch:1.9.0.2
	jimb-rda-nptl-branchpoint:1.9;
locks; strict;
comment	@ * @;


1.22
date	2012.06.14.20.21.57;	author kevinb;	state Exp;
branches;
next	1.21;

1.21
date	2011.11.30.23.14.30;	author kevinb;	state Exp;
branches;
next	1.20;

1.20
date	2009.12.01.00.27.09;	author kevinb;	state Exp;
branches;
next	1.19;

1.19
date	2005.12.07.17.51.48;	author kevinb;	state Exp;
branches;
next	1.18;

1.18
date	2005.12.02.20.52.04;	author kevinb;	state Exp;
branches;
next	1.17;

1.17
date	2005.12.02.00.49.14;	author kevinb;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.08.21.58.36;	author kevinb;	state Exp;
branches;
next	1.15;

1.15
date	2005.11.04.21.16.29;	author kevinb;	state Exp;
branches;
next	1.14;

1.14
date	2005.06.30.03.24.18;	author jimb;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.10.23.50.47;	author jimb;	state Exp;
branches;
next	1.12;

1.12
date	2005.02.08.18.29.04;	author kevinb;	state Exp;
branches;
next	1.11;

1.11
date	2005.02.08.16.05.31;	author kevinb;	state Exp;
branches;
next	1.10;

1.10
date	2004.11.18.21.40.02;	author kevinb;	state Exp;
branches;
next	1.9;

1.9
date	2004.10.20.19.28.02;	author jimb;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2004.10.20.19.22.47;	author jimb;	state Exp;
branches;
next	1.7;

1.7
date	2004.10.19.22.54.23;	author jimb;	state Exp;
branches;
next	1.6;

1.6
date	2004.10.19.21.20.08;	author jimb;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.22.19.29.41;	author jimb;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.22.19.00.31;	author jimb;	state Exp;
branches;
next	1.3;

1.3
date	2004.04.20.20.33.36;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2003.02.07.23.03.09;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	2002.08.28.01.22.28;	author kevinb;	state Exp;
branches;
next	;

1.9.2.1
date	2004.10.26.23.04.44;	author jimb;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2004.10.29.23.49.55;	author jimb;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2004.11.01.04.23.02;	author jimb;	state Exp;
branches;
next	1.9.2.4;

1.9.2.4
date	2004.11.01.04.37.09;	author jimb;	state Exp;
branches;
next	1.9.2.5;

1.9.2.5
date	2004.11.01.04.39.21;	author jimb;	state Exp;
branches;
next	1.9.2.6;

1.9.2.6
date	2004.11.01.21.55.37;	author jimb;	state Exp;
branches;
next	1.9.2.7;

1.9.2.7
date	2004.11.23.06.02.19;	author jimb;	state Exp;
branches;
next	1.9.2.8;

1.9.2.8
date	2004.11.29.19.36.22;	author jimb;	state Exp;
branches;
next	1.9.2.9;

1.9.2.9
date	2004.12.03.00.02.44;	author jimb;	state Exp;
branches;
next	1.9.2.10;

1.9.2.10
date	2004.12.03.00.03.28;	author jimb;	state Exp;
branches;
next	1.9.2.11;

1.9.2.11
date	2004.12.03.00.04.45;	author jimb;	state Exp;
branches;
next	1.9.2.12;

1.9.2.12
date	2004.12.03.00.05.56;	author jimb;	state Exp;
branches;
next	1.9.2.13;

1.9.2.13
date	2004.12.03.00.07.10;	author jimb;	state Exp;
branches;
next	1.9.2.14;

1.9.2.14
date	2004.12.03.21.36.40;	author jimb;	state Exp;
branches;
next	1.9.2.15;

1.9.2.15
date	2004.12.03.23.35.45;	author jimb;	state Exp;
branches;
next	1.9.2.16;

1.9.2.16
date	2005.03.11.00.01.05;	author jimb;	state Exp;
branches;
next	1.9.2.17;

1.9.2.17
date	2005.06.28.00.59.55;	author jimb;	state Exp;
branches;
next	;


desc
@@


1.22
log
@	* lwp-pool.c (struct lwp): Add new field `disabled'.
	(empty_lwp_slot): New static global.
	(hash_empty_slot, resize_hash, lwp_pool_stop_all)
	(lwp_pool_continue_all, clear_all_do_step_flags)
	(hash_find): Rename to hash_find_1.  Add parameter `create_p'.
	Initialize `disabled' field.
	(hash_find, hash_find_no_create, lwp_pool_disable_lwp)
	(lwp_pool_enable_lwp): New functions.
	(hash_delete): Revise method used for deleting a slot from
	the hash table.
	(lwp_pool_continue_all): Don't continue disabled LWPs.
	(lwp_pool_continue_lwp): Print a warning instead of an error, and
	then only when LWP Pool diagnostics are enabled when attempting
	to continue a LWP with the state of
	lwp_state_stopped_stop_pending_interesting.
	* lwp-pool.h (lwp_pool_disable_lwp, lwp_pool_enable_lwp): Declare.
	* thread-db.c (find_new_threads_callback): Adjust thread
	deletion / reuse message.
	(update_thread_list): Disable continuation of zombie threads.
	(thread_db_break_program): Enable diagnostic message for "monitor
	thread-db-noisy".  Use kill_lwp() instead of kill().
	(thread_db_check_child_state): Don't stop on signals from zombie
	threads.
@
text
@/* thread-db.c

   Copyright 2001, 2002 Red Hat, Inc.

   This file is part of RDA, the Red Hat Debug Agent (and library).

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.
   
   Alternative licenses for RDA may be arranged by contacting Red Hat,
   Inc.  */

#include "config.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dlfcn.h>
#include <thread_db.h>
#include <signal.h>
#include <errno.h>
#include <sys/wait.h>
#include <assert.h>

#include "gdbserv.h"
#include "gdbserv-target.h"
#include "gdbserv-utils.h"
#include "server.h"
#include "arch.h"
#include "gdb_proc_service.h"
#include "gdbserv-thread-db.h"
#include "lwp-ctrl.h"
#include "lwp-pool.h"
#include "diagnostics.h"

/* Make lots of noise (debugging output). */
int thread_db_noisy = 0;

#define ALWAYS_UPDATE_THREAD_LIST 0
#define TID_MAY_BE_REUSED 1

/*
 * A tiny local symbol table.
 *
 * This is used by ps_pglobal_lookup, and is really just a 
 * local cache of symbols whose values we have obtained from gdb.
 *
 * Since the cache is expected to be small, and infrequently used,
 * there is no effort to sort or hash it.  Symbols may be added 
 * in an "undefined" state, and then defined later.
 */

/* The "defined_p" field may have one of the following three values. */
enum symbol_cache_defined { UNDEFINED, REQUESTED, DEFINED };

struct symbol_cache {
  char *name;
  paddr_t value;
  enum symbol_cache_defined  defined_p;
  struct symbol_cache *next;
} *symbol_list;

/* Function: add_symbol_to_list
   Add a symbol to the symbol cache.  First checks to see if 
   an entry is already in there, and re-uses it if so.  This way
   the cache may be used for symbols awaiting lookup as well as
   for those that have already been defined by the debugger. */

static void
add_symbol_to_list (const char *name, paddr_t value, int defined_p)
{
  struct symbol_cache *tmp;

  for (tmp = symbol_list; tmp; tmp = tmp->next)
    {
      if (strcmp (name, tmp->name) == 0)
	{
	  /* Symbol is already in cache -- set its value and definedness. */
	  tmp->value = value;
	  if (defined_p == DEFINED)
	    tmp->defined_p = defined_p;
	  return;
	}
    }

  /* Symbol is not in cache -- add it. */
  tmp = malloc (sizeof (struct symbol_cache));

  tmp->value = value;
  tmp->defined_p = defined_p;
  tmp->name = malloc (strlen (name) + 1);
  strcpy (tmp->name, name);
  /* LIFO */
  tmp->next = symbol_list;
  symbol_list = tmp;
}

/* Function: free_symbol_list
   Empty the symbol cache. */

static void
free_symbol_list (void)
{
  struct symbol_cache *tmp;

  for (tmp = symbol_list; tmp; tmp = symbol_list)
    {
      symbol_list = tmp->next;
      free (tmp->name);
      free (tmp);
    }
}

/* Function: sync_symbol_list
   Return all "requested" symbols to the "undefined" state
   (so they can be "requested" again).  Called when a new
   source of symbols becomes available (eg. a new shared object). */

static void
sync_symbol_list (void)
{
  struct symbol_cache *tmp;

  for (tmp = symbol_list; tmp; tmp = tmp->next)
    if (tmp->defined_p == REQUESTED)
      tmp->defined_p = UNDEFINED;
}

/* Function: lookup_cached_symbol
   If symbol is defined and cached, return its value in VALUE.
   Return:  0 if not found, 1 if found.  */

static int 
lookup_cached_symbol (char *name, paddr_t *value)
{
  struct symbol_cache *tmp;

  for (tmp = symbol_list; tmp; tmp = tmp->next)
    if (strcmp (name, tmp->name) == 0 && tmp->defined_p == DEFINED)
      {
	*value = tmp->value;	/* known and defined */
	return 1;
      }

  return 0;	/* not found */
}

/* Function: next_undefined_symbol
   Find a symbol in the cache that needs lookup by GDB.
   On returning a symbol, mark it REQUESTED, so that it won't
   be requested again until a new source of symbols opens up
   (eg. a new shared object). */

static char *
next_undefined_symbol (void)
{
  struct symbol_cache *tmp;
  /* Make a pass thru the list, and return the first symbol that
     hasn't been either requested or defined. */
  for (tmp = symbol_list; tmp; tmp = tmp->next)
    if (tmp->defined_p == UNDEFINED)
      {
	tmp->defined_p = REQUESTED;
	return tmp->name;
      }
  return NULL;
}

/*
 * A tiny local thread list.
 *
 * This local list of threads is used for gdbserv operations that
 * require a struct gdbserv_thread.  Its first use will be to 
 * implement "info threads" for gdb.
 */


/* Define the struct gdbserv_thread object. */

struct gdbserv_thread {

  /* A note about thread states (TI.ti_state):

     When a thread calls pthread_exit, it first runs all its
     cancellation cleanup functions (see pthread_cleanup_push), and
     then calls destructors for its thread-specific data (see
     pthread_key_create).  If the thread is not detached, it then
     makes the pointer passed to pthread_exit available for thread(s)
     calling pthread_join.  Then, the thread terminates.

     If a thread's start function, passed to pthread_create, returns,
     then an implementation may assume that the cleanups have run
     already (the POSIX threads interface requires user code to ensure
     that this is the case).  So it just runs the destructors, and
     terminates.

     In glibc 2.3.3's NPTL, if a thread calls pthread_exit,
     libthread_db says its state is TD_THR_ZOMBIE while it runs its
     cleanups and destructors.  However, if a thread simply returns
     from its start function, then libthread_db says it's
     TD_THR_ACTIVE while it runs its destructors.  Other versions of
     libthread_db seem to do inconsistent things like that as well.

     A note about LWP id's (TI.ti_lid):

     After a thread has exited, the libthread_db's for LinuxThreads
     and NPTL report its ti_lid as being equal to the pid of the main
     thread.  To be precise, it reports the LWP id's as being equal to
     ps_getpid (PROCHANDLE), where PROCHANDLE is the 'struct
     ps_prochandle' passed to td_ta_new when we created the thread
     agent in the first place.

     The idea here seems to be, "There are no kernel-level resources
     devoted to the thread any more that a debugger could talk to, so
     let's hand the debugger whatever info we used to create the
     thread agent in the first place, so it can at least talk to what
     remains of the process."  This is a nice thought, but since the
     thread_db interface doesn't give us any way to stop threads or
     wait for them, the debugger needs to break through the
     abstraction and operate on LWP's directly to do those things.
     libthread_db's attempt to be helpful, together with the
     sloppiness in the ti_state handling, makes figuring whether there
     even *is* an LWP to operate on pretty difficult.

     If we attach to a process using some pid P, whose corresponding
     thread happens to have called pthread_exit, then there's no way
     for us to distinguish threads whose lwp is reported as P because
     they're dead from the thread whose lwp is reported as P because
     it actually is: they're all zombies.  */
  td_thrinfo_t ti;

  struct gdbserv_thread *next;

} *thread_list;

/* Function: add_thread_to_list 
   Add a thread (provided by libthread_db) to the local list. */

static struct gdbserv_thread *
add_thread_to_list (td_thrinfo_t *ti)
{
  struct gdbserv_thread *new = malloc (sizeof (struct gdbserv_thread));

  /* First cut -- add to start of list. */
  memset (new, 0, sizeof (*new));
  memcpy (&new->ti, ti, sizeof (td_thrinfo_t));
  new->next = thread_list;
  thread_list = new;
  return new;
}

static struct gdbserv_thread *
first_thread_in_list (void)
{
  return thread_list;
}

static struct gdbserv_thread *
next_thread_in_list (struct gdbserv_thread *thread)
{
  if (thread == NULL)
    return thread_list;
  else
    return thread->next;
}

static void
delete_thread_from_list (struct gdbserv_thread *thread)
{
  struct gdbserv_thread *tmp;

  for (tmp = thread_list; tmp; tmp = tmp->next)
    {
      if (tmp->next == thread)
	{
	  tmp->next = tmp->next->next;		/* unlink */
	  free (thread);			/* discard */
	  return;				/* finished */
	}
    }
  /* Special case -- delete first element of list. */
  if (thread == thread_list)
    {
      thread_list = thread->next;		/* unlink */
      free (thread);				/* discard */
      return;					/* finished */
    }
  /* If we reach this point, the thread wasn't in the list. */
}

static void
free_thread_list (void)
{
  struct gdbserv_thread *tmp;

  for (tmp = thread_list; tmp; tmp = thread_list)
    {
      thread_list = tmp->next;
      free (tmp);
    }
}

static struct gdbserv_thread *
thread_list_lookup_by_tid (thread_t tid)
{
  struct gdbserv_thread *tmp;

  for (tmp = thread_list; tmp; tmp = tmp->next)
    if (tmp->ti.ti_tid == tid)
      break;

  return tmp;
}

/* A copy of the next lower layer's target vector, before we modify it. */
static struct gdbserv_target parentvec;

/* A pointer to the current target vector. */
static struct gdbserv_target *currentvec;

/* 
 * proc_service callback functions, called by thread_db.
 */

void
ps_plog (const char *fmt, ...)
{
  fprintf (stderr, "<ps_plog: %s>\n", fmt);
  return;
}

/* Look up a symbol in GDB's global symbol table.
   Return the symbol's address.
   FIXME: it would be more correct to look up the symbol in the context 
   of the LD_OBJECT_NAME provided.  However we're probably fairly safe 
   as long as there aren't name conflicts with other libraries.  */

ps_err_e
ps_pglobal_lookup (gdb_ps_prochandle_t ph,
		   const char *ld_object_name,	/* the library name */
		   const char *ld_symbol_name,	/* the symbol name */
		   paddr_t    *ld_symbol_addr)	/* return the symbol addr */
{
  paddr_t value;

  if (lookup_cached_symbol ((char *) ld_symbol_name, &value) == 0)
    {
      /* Symbol not in cache -- ask GDB to look it up. 
	 Add the symbol to the cache as undefined. */
      add_symbol_to_list ((char *) ld_symbol_name, 0, UNDEFINED);
      return PS_NOSYM;
    }
  else
    {
      /* Symbol is in the cache and defined -- return its value. */
      *ld_symbol_addr = value;
      return PS_OK;
    }
}


/* Connection to the libthread_db library.  */
static struct ps_prochandle  proc_handle;
static td_thragent_t *thread_agent = NULL;

/* Pointers to the libthread_db functions.  */
static td_err_e (*td_init_p) (void);

static td_err_e (*td_ta_new_p)           (struct ps_prochandle *ps, 
					  td_thragent_t **ta);
static td_err_e (*td_ta_delete_p)        (td_thragent_t *ta);
static td_err_e (*td_ta_map_id2thr_p)    (const td_thragent_t *ta, 
					  thread_t pt, 
					  td_thrhandle_t *__th);
static td_err_e (*td_ta_map_lwp2thr_p)   (const td_thragent_t *ta, 
					  lwpid_t lwpid, 
					  td_thrhandle_t *th);
static td_err_e (*td_ta_thr_iter_p)      (const td_thragent_t *ta, 
					  td_thr_iter_f *callback, 
					  void *cbdata, 
					  td_thr_state_e state, 
					  int ti_pri, 
					  sigset_t *ti_sigmask, 
					  unsigned int ti_user_flags);
static td_err_e (*td_ta_event_addr_p)    (const td_thragent_t *ta, 
					  td_event_e event, 
					  td_notify_t *ptr);
static td_err_e (*td_ta_set_event_p)     (const td_thragent_t *ta, 
					  td_thr_events_t *event);
static td_err_e (*td_ta_event_getmsg_p)  (const td_thragent_t *ta, 
					  td_event_msg_t *msg);
static td_err_e (*td_thr_validate_p)     (const td_thrhandle_t *th);
static td_err_e (*td_thr_get_info_p)     (const td_thrhandle_t *th, 
					  td_thrinfo_t *infop);
static td_err_e (*td_thr_getfpregs_p)    (const td_thrhandle_t *th, 
					  FPREGSET_T *regset);
static td_err_e (*td_thr_getgregs_p)     (const td_thrhandle_t *th, 
					  GREGSET_T gregs);
static td_err_e (*td_thr_setfpregs_p)    (const td_thrhandle_t *th, 
					  const FPREGSET_T *fpregs);
static td_err_e (*td_thr_setgregs_p)     (const td_thrhandle_t *th, 
					  GREGSET_T gregs);
static td_err_e (*td_thr_getxregsize_p)  (const td_thrhandle_t *th,
                                          int *sizep);
static td_err_e (*td_thr_getxregs_p)     (const td_thrhandle_t *th, 
					  void *xregs);
static td_err_e (*td_thr_setxregs_p)     (const td_thrhandle_t *th, 
					  void *xregs);
static td_err_e (*td_thr_event_enable_p) (const td_thrhandle_t *th, 
					  int event);
static const char **(*td_symbol_list_p)  (void);
static td_err_e (*td_thr_tls_get_addr_p) (const td_thrhandle_t *th,
                                          void *map_address,
					  size_t offset, void **address);


/* Function: thread_db_state_str
   Convert a thread_db state code to a string.
   If state code is unknown, return an <unknown> message. */

static char *
thread_db_state_str (td_thr_state_e statecode)
{
  static char buf[64];

  switch (statecode) {
  case TD_THR_ANY_STATE:	return "<any state>";
  case TD_THR_UNKNOWN:		return "<officially unknown>";
  case TD_THR_STOPPED:		return "<stopped>";
  case TD_THR_RUN:		return "<running>";
  case TD_THR_ACTIVE:		return "<active>";
  case TD_THR_ZOMBIE:		return "<zombie>";
  case TD_THR_SLEEP:		return "<sleep>";
  case TD_THR_STOPPED_ASLEEP:	return "<stopped asleep>";
  default:
    sprintf (buf, "<unknown state code %d>", statecode);
    return buf;
  }
}

static char *
thread_db_type_str (td_thr_type_e type)
{
  switch (type) {
  case TD_THR_USER:		return "<user>";
  case TD_THR_SYSTEM:		return "<system>";
  default:                      return "<unknown>";
  }
}

/* Function: thread_db_err_string
   Convert a thread_db error code to a string.
   If errcode is unknown, then return an <unknown> message. */

static char *
thread_db_err_str (td_err_e errcode)
{
  static char buf[64];

  switch (errcode) {
  case TD_OK:		return "generic 'call succeeded'";
  case TD_ERR:		return "generic error";
  case TD_NOTHR:	return "no thread to satisfy query";
  case TD_NOSV:		return "no sync handle to satisfy query";
  case TD_NOLWP:	return "no lwp to satisfy query";
  case TD_BADPH:	return "invalid process handle";
  case TD_BADTH:	return "invalid thread handle";
  case TD_BADSH:	return "invalid synchronization handle";
  case TD_BADTA:	return "invalid thread agent";
  case TD_BADKEY:	return "invalid key";
  case TD_NOMSG:	return "no event message for getmsg";
  case TD_NOFPREGS:	return "FPU register set not available";
  case TD_NOLIBTHREAD:	return "application not linked with libthread";
  case TD_NOEVENT:	return "requested event is not supported";
  case TD_NOCAPAB:	return "capability not available";
  case TD_DBERR:	return "debugger service failed";
  case TD_NOAPLIC:	return "operation not applicable to";
  case TD_NOTSD:	return "no thread-specific data for this thread";
  case TD_MALLOC:	return "malloc failed";
  case TD_PARTIALREG:	return "only part of register set was written/read";
  case TD_NOXREGS:	return "X register set not available for this thread";
  default:
    sprintf (buf, "unknown thread_db error '%d'", errcode);
    return buf;
  }
}


/* Return a string naming the event type EVENT.  */
static const char *
thread_db_event_str (td_event_e event)
{
  switch (event) {
  case TD_READY:		return "TD_READY";
  case TD_SLEEP:		return "TD_SLEEP";
  case TD_SWITCHTO:		return "TD_SWITCHTO";
  case TD_SWITCHFROM:		return "TD_SWITCHFROM";
  case TD_LOCK_TRY:		return "TD_LOCK_TRY";
  case TD_CATCHSIG:		return "TD_CATCHSIG";
  case TD_IDLE:			return "TD_IDLE";
  case TD_CREATE:		return "TD_CREATE";
  case TD_DEATH:		return "TD_DEATH";
  case TD_PREEMPT:		return "TD_PREEMPT";
  case TD_PRI_INHERIT:		return "TD_PRI_INHERIT";
  case TD_REAP:			return "TD_REAP";
  case TD_CONCURRENCY:		return "TD_CONCURRENCY";
  case TD_TIMEOUT:		return "TD_TIMEOUT";
  default:                      return "<unknown>";
  }
}

/* Return a pointer to a statically allocated string describing
   THREAD.  For debugging.  The resulting string has the form
   "(TID STATE LID PTR)", where:
   - TID is the thread ID, which you'll see in the user program and
     in the remote protocol,
   - STATE is the state of the thread, which can be important in 
     deciding how to interpret LID,
   - LID is the PID of the underlying LWP, and
   - PTR is the address of the 'struct thread' in RDA, so you can
     actually mess with it further if you want.  */
static const char *
thread_debug_name (struct gdbserv_thread *thread)
{
  if (thread)
    {
      static char buf[100];
      sprintf (buf, "(0x%lx %s %d %p)",
	       (unsigned long) thread->ti.ti_tid,
	       thread_db_state_str (thread->ti.ti_state),
	       thread->ti.ti_lid,
	       thread);
      return buf;
    }
  else
    return "(null thread)";
}

/* flag which indicates if the map_id2thr cache is valid.  See below.  */
static int thread_db_map_id2thr_cache_valid;

/* Function: thread_db_map_id2thr
   Calling td_ta_map_id2thr() is expensive.  This function invokes
   td_ta_map_id2thr() and caches the value for future reference.  The
   cache may be invalidated by calling thread_db_invalidate_cache().
   Returns: TD_OK on success, an appropriate error code otherwise.  */

static td_err_e
thread_db_map_id2thr (const td_thragent_t *ta, thread_t pt,
                      td_thrhandle_t *th)
{
  static td_thrhandle_t cached_handle;
  static thread_t input_pt;

  if (pt == input_pt && thread_db_map_id2thr_cache_valid)
    {
      *th = cached_handle;
      return TD_OK;
    }
  else
    {
      td_err_e status;

      status = td_ta_map_id2thr_p (ta, pt, th);
      if (status == TD_OK)
	{
	  thread_db_map_id2thr_cache_valid = 1;
	  input_pt = pt;
	  cached_handle = *th;
	}
      else
	thread_db_map_id2thr_cache_valid = 0;
      return status;
    }
}

/* Invalidate the map_id2thr cache.  */
static void
thread_db_invalidate_map_id2thr_cache (void)
{
  thread_db_map_id2thr_cache_valid = 0;
}

static struct gdbserv_thread *
thread_list_lookup_by_lid (lwpid_t pid)
{
  struct gdbserv_thread *t;
  struct gdbserv_thread *second_choice = NULL;

  /* Ideally, we'd be using td_ta_map_lwp2thr here.  */

  for (t = thread_list; t; t = t->next)
    if (t->ti.ti_lid == pid)
      {
	/* libthread_db reports the ti_lid of a deceased thread as
	   being equal to ps_getpid (&proc_handle).  So be a bit
	   skeptical of those.  */
	if (pid == proc_handle.pid
	    && (t->ti.ti_state == TD_THR_ZOMBIE
		|| t->ti.ti_state == TD_THR_UNKNOWN))
	  second_choice = t;
	else return t;
      }

  return second_choice;
}

/* The regset cache object.  This object keeps track of the most
   recently fetched or set gregset (of a particular type) and whether
   or not it needs to still needs to be synchronized with the target.  */
struct regset_cache
{
  /* Are the cache contents valid?  */
  int valid;

  /* Does cache need to be flushed?  */
  int needs_flush;

  /* Handle corresponding to cached regset.  */
  td_thrhandle_t handle;

  /* Size of memory area used to hold regset.  */
  int regset_size;

  /* Memory area used to hold regset.  */
  void *regset_buffer;

  /* Functions used to get/set regset.  */
  td_err_e (*getregset) (const td_thrhandle_t *th, void *regset);
  td_err_e (*setregset) (const td_thrhandle_t *th, const void *regset);
};

/* Declare fpregset and gregset cache objects.  */
static struct regset_cache fpregset_cache;
static struct regset_cache gregset_cache;

/* Wrappers for td_thr_getfpregs_p, td_thr_setfpregs_p, td_thr_getgregs_p,
   and td_thr_setgregs_p.  These simply allow us to pass a void * for the
   regset parameter.  */

static td_err_e
td_thr_getfpregs_wrapper (const td_thrhandle_t *th, void *fpregs)
{
  return td_thr_getfpregs_p (th, fpregs);
}

static td_err_e td_thr_getgregs_wrapper (const td_thrhandle_t *th, void *gregs)
{
  return td_thr_getgregs_p (th, gregs);
}

static td_err_e td_thr_setfpregs_wrapper (const td_thrhandle_t *th,
                                          const void *fpregs)
{
  return td_thr_setfpregs_p (th, fpregs);
}

static td_err_e td_thr_setgregs_wrapper (const td_thrhandle_t *th,
                                         const void *gregs)
{
  void * gregs_nonconst = (void *) gregs;

  return td_thr_setgregs_p (th, gregs_nonconst);
}

/* Initialize a regset cache object.  */
static void
initialize_regset_cache (struct regset_cache *regset_cache,
                         const int regset_size,
			 void * const regset_buffer,
			 td_err_e (* const getregset) (const td_thrhandle_t *th,
			                               void *regset),
                         td_err_e (* const setregset) (const td_thrhandle_t *th,
			                               const void *regset))
{
  regset_cache->valid = 0;
  regset_cache->needs_flush = 0;
  regset_cache->regset_size = regset_size;
  regset_cache->regset_buffer = regset_buffer;
  regset_cache->getregset = getregset;
  regset_cache->setregset = setregset;
}

/* Initialize the fpregset and gregset cache objects.  Space for
   the regset buffer is statically allocated to avoid calls to malloc().  */
static void
initialize_regset_caches (void)
{
  static FPREGSET_T fpregset;
  static GREGSET_T gregset;

  initialize_regset_cache (&fpregset_cache, sizeof fpregset, &fpregset,
                           td_thr_getfpregs_wrapper, td_thr_setfpregs_wrapper);
  initialize_regset_cache (&gregset_cache, sizeof gregset, gregset,
                           td_thr_getgregs_wrapper, td_thr_setgregs_wrapper);
}

/* Synchronize a cached regset with the target.  */
static td_err_e
thread_db_flush_regset_cache (struct regset_cache *regset_cache)
{
  td_err_e status = TD_OK;
  if (regset_cache->valid && regset_cache->needs_flush)
    {
      status = regset_cache->setregset (&regset_cache->handle,
					regset_cache->regset_buffer);
      if (status != TD_OK)
	regset_cache->valid = 0;
      regset_cache->needs_flush = 0;
    }
  return status;
}

/* Synchronize the gregset and fpregset caches with the target.  */
static td_err_e
thread_db_flush_regset_caches (void)
{
  td_err_e status;
  td_err_e ret_status = TD_OK;

  status = thread_db_flush_regset_cache (&fpregset_cache);
  if (status != TD_OK)
    ret_status = status;

  status = thread_db_flush_regset_cache (&gregset_cache);
  if (status != TD_OK)
    ret_status = status;

  return status;
}

/* Fetch a regset, using a previously cached copy if possible.  */
static td_err_e
thread_db_get_regset (struct regset_cache *regset_cache,
                     const td_thrhandle_t *th,
		     void *regset)
{
  if (regset_cache->valid
      && memcmp (&regset_cache->handle, th, sizeof *th) == 0)
    {
      /* Cache is valid and handles match.  Copy the cached regset.  */
      memcpy (regset, regset_cache->regset_buffer, regset_cache->regset_size);
      return TD_OK;
    }
  else
    {
      td_err_e status;

      /* Handles don't match.  Write out old cache contents before
         fetching contents w/ new handle if necessary.  */
      if (regset_cache->valid && regset_cache->needs_flush)
	{
	  status = regset_cache->setregset (&regset_cache->handle,
					    regset_cache->regset_buffer);
	  if (status != TD_OK)
	    {
	      regset_cache->needs_flush = 0;
	      regset_cache->valid = 0;
	      return status;
	    }
	}
      

      /* Fetch the regset.  */
      status = regset_cache->getregset (th, regset);
      if (status == TD_OK)
        {
	  /* Preserve it in the cache.  */
	  regset_cache->needs_flush = 0;
	  regset_cache->valid = 1;
	  memcpy (&regset_cache->handle, th, sizeof (*th));
	  memcpy (regset_cache->regset_buffer, regset,
	          regset_cache->regset_size);
	}
      else
	regset_cache->valid = 0;
      return status;
    }
}

/* Set a regset deferring synchronization with the target until
   later.  */
static td_err_e
thread_db_set_regset (struct regset_cache *regset_cache,
                     const td_thrhandle_t *th,
		     const void *regset)
{
  td_err_e ret_status = TD_OK;

  if (regset_cache->valid && regset_cache->needs_flush
      && memcmp (&regset_cache->handle, th, sizeof *th) != 0)
    {
      /* Cached regset needs to be flushed because handles don't
         match.  */
      ret_status = thread_db_flush_regset_cache (regset_cache);
    }

  memcpy (&regset_cache->handle, th, sizeof *th);
  memcpy (regset_cache->regset_buffer, regset, regset_cache->regset_size);
  regset_cache->valid = 1;
  regset_cache->needs_flush = 1;

  return ret_status;
}

/* Mark a regset cache as invalid.  */
static void
thread_db_invalidate_regset_cache (struct regset_cache *regset_cache)
{
  regset_cache->valid = 0;
}

/* Mark the gregset and fpregset caches as invalid.  */
static void
thread_db_invalidate_regset_caches (void)
{
  thread_db_invalidate_regset_cache (&fpregset_cache);
  thread_db_invalidate_regset_cache (&gregset_cache);
}

/* Invalidate all caches.  */
static void
thread_db_invalidate_caches (void)
{
  thread_db_invalidate_regset_caches ();
  thread_db_invalidate_map_id2thr_cache ();
}

/* Fetch the floating point registers via the fpregset cache.  */
static td_err_e
thread_db_getfpregs (const td_thrhandle_t *th, FPREGSET_T *fpregset)
{
  return thread_db_get_regset (&fpregset_cache, th, fpregset);
}

/* Set the floating point registers via the fpregset cache.  */
static td_err_e
thread_db_setfpregs (const td_thrhandle_t *th, const FPREGSET_T *fpregset)
{
  return thread_db_set_regset (&fpregset_cache, th, fpregset);
}

/* Fetch the general purpose registers via the gregset cache.  */
static td_err_e
thread_db_getgregs (const td_thrhandle_t *th, GREGSET_T gregset)
{
  return thread_db_get_regset (&gregset_cache, th, gregset);
}

/* Set the general purpose registers via the gregset cache.  */
static td_err_e
thread_db_setgregs (const td_thrhandle_t *th, const GREGSET_T gregset)
{
  return thread_db_set_regset (&gregset_cache, th, gregset);
}


/* Function: get_target_int_by_name
   Read the value of a target integer, given its name and size.
   Returns -1 for failure, zero for success. */

static int
get_target_int_by_name (char *name, void *value, int size)
{
  paddr_t addr;

  if (ps_pglobal_lookup (&proc_handle, NULL, name, &addr) == PS_OK)
    {
      if (ps_pdread (&proc_handle, addr,
		     (gdb_ps_read_buf_t) value,
		     (gdb_ps_size_t) size) == PS_OK)
	return 0;
    }
  return -1;		/* fail */
}

/* Function: set_target_int_by_name
   Read the value of a target integer, given its name and size.
   Returns -1 for failure, zero for success. */

static int
set_target_int_by_name (char *name, void *value, int size)
{
  paddr_t addr;

  if (ps_pglobal_lookup (&proc_handle, NULL, name, &addr) == PS_OK)
    {
      if (ps_pdwrite (&proc_handle, addr,
		      (gdb_ps_write_buf_t) value,
		      (gdb_ps_size_t) size) == PS_OK)
	return 0;
    }
  return -1;		/* fail */
}

/* Function: get_thread_signals

   Obtain the values of the "cancel", "restart" and "debug" signals
   used by LinuxThreads, and store them in a set of global variables
   for use by check_child_state and friends.

   Return 0 for success: we obtained the signal numbers and enabled
   debugging in the thread library.  Return -1 for failure.

   Recent versions of NPTL don't define these symbols at all; you must
   use the libthread_db event functions instead (td_ta_event_addr,
   ...) to find out about thread creation, thread exits, and so on.

   Older versions of LinuxThreads provide both interfaces.  To avoid
   changing RDA's behavior on any system it supports, we use the older
   signal-based interface if present, and use the event-based
   interface as a fall-back.  */

static int cancel_signal;
static int restart_signal;
static int debug_signal;
static int got_thread_signals;

static int
get_thread_signals (void)
{
  int cancel, restart, debug;

  /* If we've already gotten the thread signals, that's great.  */
  if (got_thread_signals)
    return 0;

  if (get_target_int_by_name ("__pthread_sig_cancel", 
			      &cancel, sizeof (cancel)) == -1
      || get_target_int_by_name ("__pthread_sig_restart",
				 &restart, sizeof (restart)) == -1
      || get_target_int_by_name ("__pthread_sig_debug", 
				 &debug, sizeof (debug)) == -1)
    return -1;

  restart_signal = restart;
  cancel_signal  = cancel;
  debug_signal   = debug;

  got_thread_signals = 1;

  {
    static int debug_flag = 1;
    set_target_int_by_name ("__pthread_threads_debug", 
			    &debug_flag, sizeof (debug_flag));
  }

  return 0;
}


/* Return true if PROCESS stopped for a libpthread-related signal that
   should not be reported to GDB.  */
static int
ignore_thread_signal (struct child_process *process)
{
  if (process->stop_status == 'T')
    /* Child stopped with a signal.  
       See if it was one of our special signals. */
    return (process->stop_signal == cancel_signal  ||	/* ignore */
	    process->stop_signal == restart_signal ||	/* ignore */
	    process->stop_signal == debug_signal   ||	/* ignore */
	    process->stop_signal == SIGCHLD);		/* ignore */

  return 0;
}


/* NPTL and later versions of LinuxThreads support a set of "event"
   functions for notifying the debugger of interesting events that
   have taken place in the thread library, like thread creation and
   thread death.

   There are three steps to using this interface:

   - First, the debugger asks libthread_db how a given event will be
     reported; libthread_db fills in a 'td_notify_t' structure whose
     'type' says how.  The debuggee may call functions on which the
     debugger can set breakpoints (type == NOTIFY_BPT), hit breakpoint
     instructions hard-coded into the program (type == NOTIFY_AUTOBPT),
     or perform system calls to indicate that an event has occurred
     (type == NOTIFY_SYSCALL).

   - Second, the debugger tells libthread_db which events it's
     interested in.  It can ask to be notified when a given event
     occurs in any thread, or when a given event occurs in a given
     thread.

   - Finally, the debugger watches for the given event to occur.

   We make a few simplifications here:

   - NPTL and LinuxThreads only actually use one kind of event
     notification: calling a function on which the debugger can set a
     breakpoint (NOTIFY_BPT).  So although, strictly speaking, the
     thread library could notify us in other ways, we only support
     NOTIFY_BPT.

   - NPTL and LinuxThreads only support a few kinds of events:
     TD_CREATE (a new thread has been created), TD_DEATH (a thread has
     exited), and TD_REAP (not sure).  We are only interested in
     TD_CREATE and TD_DEATH.  */

/* Ideally, these would be members of some structure somewhere, and
   not global variables, but that's how this file is written.  */

/* True if we're using libthread_db events.  */
int using_thread_db_events;

/* How we are notified of thread creation and death.  */
static td_notify_t create_notification, death_notification;

/* Breakpoints set at the addresses indicated by create_notification
   and death_notification.  These are raw arch breakpoints, so we have
   to delete them to step over them; the objects here will generally
   get regenerated every time we receive an event.  */
static struct arch_bp *create_event_breakpoint;
static struct arch_bp *death_event_breakpoint;
  

/* Set NOTIFICATION to the notification method for EVENT, and check
   that it uses NOTIFY_BPT notification.  Return -1 for failure, zero
   for success.  */
static int
get_event_notification (td_event_e event, td_notify_t *notification)
{
  td_err_e ret = td_ta_event_addr_p (thread_agent, event, notification);
  if (ret != TD_OK)
    {
      if (thread_db_noisy)
	fprintf (stderr, "td_ta_event_addr (%s) -> %s\n",
		 thread_db_event_str (event),
		 thread_db_err_str (ret));
      return -1;
    }

  if (notification->type != NOTIFY_BPT)
    {
      if (thread_db_noisy)
	fprintf (stderr, "notification for %s is not NOTIFY_BPT\n",
		 thread_db_event_str (event));
      return -1;
    }

  return 0;
}


/* Insert a breakpoint in SERV at the address given by NOTIFICATION.
   Return NULL for failure, or the breakpoint for success.  */
static struct arch_bp *
set_event_breakpoint (struct gdbserv *serv, td_notify_t *notification)
{
  struct child_process *process = gdbserv_target_data (serv);
  struct gdbserv_reg addr;

  /* Use the widest type for the conversion, just in case.  */
  gdbserv_ulonglong_to_reg (serv, (paddr_t) notification->u.bptaddr,
			    &addr);
  
  return process->arch->set_bp (process->breakpoint_table, &addr);
}


/* Insert breakpoints at all functions needed for communication with
   the underlying thread library.  Return 0 for success, -1 for
   failure.  */
static int
insert_thread_db_event_breakpoints (struct gdbserv *serv)
{
  struct child_process *process = gdbserv_target_data (serv);

  create_event_breakpoint = set_event_breakpoint (serv, &create_notification);
  death_event_breakpoint  = set_event_breakpoint (serv, &death_notification);

  if (! create_event_breakpoint || ! death_event_breakpoint)
    {
      if (create_event_breakpoint)
	process->arch->delete_bp (create_event_breakpoint);
      if (death_event_breakpoint)
	process->arch->delete_bp (death_event_breakpoint);
      create_event_breakpoint = death_event_breakpoint = 0;
      return -1;
    }

  return 0;
}


/* Remove breakpoints from all libthread_db event notification
   addresses.  Return 0 for success, -1 for failure.  */
static int
delete_thread_db_event_breakpoints (struct gdbserv *serv)
{
  struct child_process *process = gdbserv_target_data (serv);
  int create_ret, death_ret;

  create_ret = process->arch->delete_bp (create_event_breakpoint);
  death_ret = process->arch->delete_bp (death_event_breakpoint);

  create_event_breakpoint = death_event_breakpoint = 0;

  if (create_ret == 0 && death_ret == 0)
    return 0;
  else
    return -1;
}


/* If we don't have event set manipulation macros, then we can't use
   the event interface.  */
#if defined (td_event_emptyset)

/* Tell the program being debugged by SERV to notify us of thread
   creation and death.  Return -1 for failure, zero for success.  */
static int
request_thread_db_events (struct gdbserv *serv)
{
  struct child_process *process = gdbserv_target_data (serv);

  /* If we don't have the libthread_db functions we need, then we
     can't use the event interface.  */
  if (! td_ta_event_addr_p
      || ! td_ta_event_getmsg_p
      || ! td_thr_event_enable_p
      || ! td_ta_set_event_p)
    return -1;

  /* If we don't have an architecture object, then we don't know how
     to insert breakpoints, even if our thread library supports the
     event interface.  */
  if (! process->arch
      || ! process->breakpoint_table)
    return -1;

  /* Get the notification addresses for TD_CREATE and TD_DEATH,
     and ensure that they use NOTIFY_BPT notification.  */
  if (get_event_notification (TD_CREATE, &create_notification) == -1
      || get_event_notification (TD_DEATH,  &death_notification) == -1)
    return -1;

  insert_thread_db_event_breakpoints (serv);

  /* Tell the thread library to send us those events.  */
  {
    td_thr_events_t events;
    td_err_e err;

    /* The td_event_ thingies are all documented to be macros.  So we
       don't need to access them via pointers.  */
    td_event_emptyset (&events);
    td_event_addset (&events, TD_CREATE);
    td_event_addset (&events, TD_DEATH);
    err = td_ta_set_event_p (thread_agent, &events);
    if (err != TD_OK)
      fprintf (stderr, "couldn't set global event mask: %s",
	       thread_db_err_str (err));
  }

  using_thread_db_events = 1;
  return 0;
}

#else /* ! defined (td_event_emptyset) */

/* td_event_emptyset is not defined, so we can't use the event
   interface.  */
static int
request_thread_db_events (struct gdbserv *serv)
{
  return -1;
}

#endif /* ! defined (td_event_emptyset) */


/* Return non-zero if BREAKPOINT is a libthread_db event breakpoint,
   zero otherwise.  */
static int
hit_thread_db_event_breakpoint (struct gdbserv *serv,
				struct gdbserv_thread *thread)
{
  struct child_process *process = gdbserv_target_data (serv);

  return (process->arch->bp_hit_p (thread, create_event_breakpoint)
	  || process->arch->bp_hit_p (thread, death_event_breakpoint));
}


/* Call dlsym() to find the address of a symbol.  If symbol lookup fails,
   print the reason to stderr.  */

static void *
lookup_sym (void *dlhandle, char *symbol)
{
  void *addr;

  addr = dlsym (dlhandle, symbol);

  if (addr == NULL)
    fprintf (stderr, "Symbol lookup of %s failed: %s\n",
	     symbol, dlerror ());

  return addr;
}

/* Function: thread_db_dlopen
   Attach to the libthread_db library.  
   This function does all the dynamic library stuff (dlopen, dlsym).
   Return: -1 for failure, zero for success.  */

static int
thread_db_dlopen (void)
{
  void *dlhandle;

#ifndef LIBTHREAD_DB_SO
#define LIBTHREAD_DB_SO "libthread_db.so.1"
#endif

  if ((dlhandle = dlopen (LIBTHREAD_DB_SO, RTLD_NOW)) == NULL)
    {
      fprintf (stderr, "Unable to open %s: %s\n",
               LIBTHREAD_DB_SO, dlerror ());
      return -1;		/* fail */
    }

  /* Initialize pointers to the dynamic library functions we will use.
   */

  if ((td_init_p = lookup_sym (dlhandle, "td_init")) == NULL)
    return -1;		/* fail */

  if ((td_ta_new_p = lookup_sym (dlhandle, "td_ta_new")) == NULL)
    return -1;		/* fail */

  if ((td_ta_delete_p = lookup_sym (dlhandle, "td_ta_delete")) == NULL)
    return -1;		/* fail */

  if ((td_ta_map_id2thr_p = lookup_sym (dlhandle, "td_ta_map_id2thr")) == NULL)
    return -1;		/* fail */

  if ((td_ta_map_lwp2thr_p = lookup_sym (dlhandle, "td_ta_map_lwp2thr")) == NULL)
    return -1;		/* fail */

  if ((td_ta_thr_iter_p = lookup_sym (dlhandle, "td_ta_thr_iter")) == NULL)
    return -1;		/* fail */

  if ((td_thr_validate_p = lookup_sym (dlhandle, "td_thr_validate")) == NULL)
    return -1;		/* fail */

  if ((td_thr_get_info_p = lookup_sym (dlhandle, "td_thr_get_info")) == NULL)
    return -1;		/* fail */

  if ((td_thr_getfpregs_p = lookup_sym (dlhandle, "td_thr_getfpregs")) == NULL)
    return -1;		/* fail */

  if ((td_thr_getgregs_p = lookup_sym (dlhandle, "td_thr_getgregs")) == NULL)
    return -1;		/* fail */

  if ((td_thr_setfpregs_p = lookup_sym (dlhandle, "td_thr_setfpregs")) == NULL)
    return -1;		/* fail */

  if ((td_thr_setgregs_p = lookup_sym (dlhandle, "td_thr_setgregs")) == NULL)
    return -1;		/* fail */

  /* These are not essential.  */
  td_ta_event_addr_p    = dlsym (dlhandle, "td_ta_event_addr");
  td_ta_set_event_p     = dlsym (dlhandle, "td_ta_set_event");
  td_ta_event_getmsg_p  = dlsym (dlhandle, "td_ta_event_getmsg");
  td_thr_event_enable_p = dlsym (dlhandle, "td_thr_event_enable");
  td_thr_getxregsize_p  = dlsym (dlhandle, "td_thr_getxregsize");
  td_thr_getxregs_p     = dlsym (dlhandle, "td_thr_getxregs");
  td_thr_setxregs_p     = dlsym (dlhandle, "td_thr_setxregs");
  td_symbol_list_p      = dlsym (dlhandle, "td_symbol_list");
  td_thr_tls_get_addr_p = dlsym (dlhandle, "td_thr_tls_get_addr");

  return 0;		/* success */
}

/* Function: thread_db_open
   Open a channel to the child's thread library.
   Returns: 0 for success, -1 for failure
   FIXME: closure.
   FIXME: where should we be called from?  We will not succeed
   until the thread shlib is loaded.  The call from attach will not
   succeed even if the target is statically linked, 'cause there's 
   no symbol lookup handshake on attach.  Therefore I can't handle
   a statically linked threaded process.  */

static int
thread_db_open (struct gdbserv *serv, int pid)
{ /* FIXME: once we have the serv, we can derive the pid. 
     No, not true -- not when we're called from attach. 
     But then, there isn't much use in the call from attach unles
     I make GDB respond to symbol callbacks from there somehow. */
  td_err_e ret;

  /* If we already have a thread agent, we're all set.  */
  if (thread_agent)
    return 0;

  /* Have the proc service handle point back to our serv object and
     the target's overall pid. */
  proc_handle.pid = pid;
  proc_handle.serv = serv;
      
  ret = td_ta_new_p (&proc_handle, &thread_agent);
  if (ret != TD_OK)
    {
      if (thread_db_noisy)
	fprintf (stderr, "< -- failed, thread_agent = %p>\n", thread_agent);
      
      return -1;		/* failure */
    }

  if (thread_db_noisy)
    fprintf (stderr, "< -- succeeded, thread_agent = %p>\n", thread_agent);

  /* All LinuxThreads versions support the signal-based debugging
     interface.  Newer versions of LinuxThreads also provide the
     event-based debugging interface.  NPTL has only ever supported
     the event-based debugging interface.  Prefer the signal-based
     interface to the event-based interface, to leave behavior on
     older systems unchanged.  */
  if (get_thread_signals () == 0)
    {
      if (thread_db_noisy)
        fprintf (stderr,
                 "(using thread signals cancel=%d, restart=%d, debug=%d)\n",
                 cancel_signal, restart_signal, debug_signal);
      return 0;
    }

  if (request_thread_db_events (serv) == 0)
    {
      if (thread_db_noisy)
        fprintf (stderr, "(using thread_db events)\n");
      return 0;
    }

  return -1;
}


/* Function: thread_db_detach
   FIXME: gdbserv kills the inferior and exits when gdb detaches.
   This is the best place I have from which to shut down the 
   thread_db interface, but it's not really where this should
   be done. */

static void
thread_db_detach (struct gdbserv *serv, struct gdbserv_target *target)
{
  struct child_process *process = gdbserv_target_data (serv);

  /* FIXME: this isn't really enough, and detach isn't really the
     right place for this anyway.  Do this in exit_program. */
  td_ta_delete_p (thread_agent);
  thread_agent = NULL;
  currentvec = NULL;

  if (process->debug_informational)
    fprintf (stderr, "<thread_db_detach>\n");
  if (parentvec.detach)
    parentvec.detach (serv, target);
}

static void
attach_thread (struct gdbserv *serv, struct gdbserv_thread *thread)
{
  if (thread->ti.ti_lid != 0)
    {
      /* We attach to all threads with a plausible LWP PID, including
	 TD_THR_ZOMBIE threads.  libthread_db sometimes reports
	 threads still executing cleanups or thread-specific data
	 destructors as zombies, so it may be important to attach to
	 them.

	 libthread_db never reports an invalid LWP PID in ti.ti_lid,
	 even when the LWP has exited --- in that case, it returns
	 ps_getpid (&proc_handle).  The LWP pool code tolerates
	 multiple requests to attach to the same PID.  */
      int status = lwp_pool_attach (serv, thread->ti.ti_lid);

      /* If we're using signals to communicate with the thread
	 library, send the newly attached thread the restart
	 signal.  It will remain stopped, but it will receive the
	 signal as soon as we continue it.  */
      if (got_thread_signals)
	{
	  if (status == 1)
	    kill_lwp (thread->ti.ti_lid, restart_signal);
	}
    }
}

/* Function: find_new_threads_callback
   Enter threads into a local thread database. */

static int
find_new_threads_callback (const td_thrhandle_t *thandle, void *data)
{
  struct gdbserv_thread *thread;
  struct gdbserv *serv = data;
  td_thrinfo_t ti;
  td_err_e     ret;

  if ((ret = td_thr_get_info_p (thandle, &ti)) != TD_OK)
    {
      fprintf (stderr, "<find_new_threads_callback: get_info failed! %s>\n", 
	       thread_db_err_str (ret));
      return -1;
    }

  /* Enter the thread into a local list
     (unless it is TD_THR_UNKNOWN, which means its defunct). */
  if ((thread = thread_list_lookup_by_tid (ti.ti_tid)) == NULL
#if TID_MAY_BE_REUSED
      || thread->ti.ti_lid != ti.ti_lid
#endif
      )
    {
      if (ti.ti_state != TD_THR_UNKNOWN)
	{
	  if (thread)
	    {
	      /* Thread is being reused.  What has happened here is that
	         one thread has died and another was created using the
		 same thread identifier.  */
	      if (thread_db_noisy)
		fprintf (stderr, "(thread deletion / reuse: %s; state: %d new lwp: %d)\n", thread_debug_name (thread), thread->ti.ti_state, ti.ti_lid);
	      thread->ti = ti;
	    }
	  else
	    thread = add_thread_to_list (&ti);

	  if (thread_db_noisy)
	    fprintf (stderr, "(new thread %s)\n", thread_debug_name (thread));

	  attach_thread (serv, thread);

	  if (using_thread_db_events)
	    {
	      /* Enable event reporting in this thread.  */
	      if (td_thr_event_enable_p (thandle, 1) != TD_OK)
		fprintf (stderr, "couldn't enable event reporting "
			 "in thread %d\n",
			 ti.ti_lid);
	    }
	}
    }
  else
    {
      /* Already in list -- cache new thread info */
      memcpy (&thread->ti, &ti, sizeof (ti));
    }

  return 0;
}

/* Function: update_thread_list

   First run td_ta_thr_iter to find all threads.
   Then walk the list and validate that each thread is still running.
   If not, prune it from the list. */

static void
update_thread_list (struct child_process *process)
{
  struct gdbserv_thread *thread, *next;
  struct gdbserv *serv = process->serv;
  td_thrhandle_t handle;

  if (thread_db_noisy)
    fprintf (stderr, "thread-db.c: update_thread_list\n");

  /* First make sure all libthread threads are in the list. */
  td_ta_thr_iter_p (thread_agent, find_new_threads_callback, 
		    serv, 
		    TD_THR_ANY_STATE, 
		    TD_THR_LOWEST_PRIORITY,
		    TD_SIGNO_MASK,
		    TD_THR_ANY_USER_FLAGS);

  /* Next, remove any defunct threads from the list. */
  for (thread = first_thread_in_list ();
       thread;
       thread = next)
    {
      /* Thread may be deleted, so find its successor first! */
      next = next_thread_in_list (thread);

      /* Now ask if thread is still valid, and if not, delete it. */
      if (thread_db_map_id2thr (thread_agent, 
			        thread->ti.ti_tid, 
			        &handle) != TD_OK
          || td_thr_validate_p (&handle) != TD_OK)
	{
	  if (thread->ti.ti_state == TD_THR_UNKNOWN)
	    {
	      /* Thread is no longer "valid".
	         By the time this happens, it's too late for us to 
	         detach from it.  Just delete it from the list.  */

	      if (thread == process->focus_thread)
		process->focus_thread = NULL;
	      
	      delete_thread_from_list (thread);
	    }
	}
    }

  /* Disable zombie threads.  */
  for (thread = first_thread_in_list ();
       thread;
       thread = next_thread_in_list (thread))
    {
      /* Don't allow zombie threads to continue.  */
      if (thread->ti.ti_state == TD_THR_ZOMBIE)
	lwp_pool_disable_lwp (thread->ti.ti_lid);
    }
}

/* Function: thread_db_thread_next
   Exported to gdbserv to implement "info threads" request from GDB. */

static struct gdbserv_thread *
thread_db_thread_next (struct gdbserv *serv, struct gdbserv_thread *thread)
{
  if (thread == NULL)
    {
      /* First request -- build up thread list using td_ta_thr_iter. */
      /* NOTE: this should be unnecessary, once we begin to keep the
	 list up to date all the time. */
      struct child_process *process = gdbserv_target_data (serv);
      update_thread_list (process);
    }
  return next_thread_in_list (thread);
}


/* Function: thread_db_get_gen
   Handle 'q' requests:
     qSymbol and qGetTLSAddr
*/

static void
thread_db_get_gen (struct gdbserv *serv)
{
  struct child_process *process = gdbserv_target_data (serv);
  char tempname[1024], *symbol_query;
  unsigned long tempval;
  int len;

  if (gdbserv_input_string_match (serv, "Symbol:") >= 0)
    {
      /* Message: qSymbol:<optional value>:<optional name hexified>
	 Reply:   OK
	 Reply:   qSymbol:<name hexified>

	 This message from GDB has three possible forms:

	 1) "qSymbol::" (no value, no name).
	 This means the start of a symbol query session.
	 GDB is offering to serve up symbols.
	 The target should reply with the FIRST symbol whose value 
	 it wants (or "OK" if it doesn't want any).

	 2) "qSymbol:<value>:<name hexified>
	 This means "here is the value of the symbol you requested".
	 The target should reply with the NEXT symbol whose value
	 it wants (or "OK" if it doesn't want any more).

	 3) "qSymbol::<name hexified>" (no value)
	 This means "I have no value for the symbol you requested".
	 The target should reply with the NEXT symbol whose value
	 it wants (or "OK" if it doesn't want any more).
      */
	 
      if (gdbserv_input_string_match (serv, ":") >= 0)
	{
	  /* So far we've matched "qSymbol::".  We're looking at either 
	     form #1 ("qSymbol::", open a symbol lookup session), or
	     form #3 ("qSymbol::<name>", a reply that "this symbol is
	     not defined".  */

	  len = gdbserv_input_bytes (serv, tempname, sizeof (tempname));

	  if (len == 0)
	    {
	      /* Form #1, open a new symbol lookup session.
		 Prepare to request the first symbol in the list. */
	      sync_symbol_list ();
	    }
	  else
	    {
	      /* Form #3, this symbol not currently defined.  Nothing
		 to do, since we marked it REQUESTED when we sent it,
		 and lookup_cached_symbol treats REQUESTED like
		 UNDEFINED. */
	    }
	}
      else if (gdbserv_input_hex_ulong (serv, &tempval) >= 0 &&
	       gdbserv_input_string_match (serv, ":") >= 0 &&
	       (len = gdbserv_input_bytes (serv, tempname, sizeof (tempname))) 
	       > 0)
	{
	  /* Message contains a symbol and a value (form #2). */

	  tempname[len] = '\0';
	  add_symbol_to_list (tempname, (paddr_t) tempval, DEFINED);
	  if (thread_agent != NULL)
	    {
	      /* We now have a new symbol in the cache, which was
		 requested by the last td_ta_new call.  Delete the
		 current (not-completely-valid) thread agent, so that
		 a new one will have to be opened.  */
	      td_ta_delete_p (thread_agent);
	      thread_agent = NULL;
	    }
	}

      /* If we have no more symbols to look up, try opening a thread
	 agent.  It's possible that opening an agent could succeed
	 before we have finished looking up all the symbols, but since
	 we always loop until all the symbols we know about have been
	 requested anyway, it's unnecessary.

	 This ensures that ps_pglobal_lookup will always succeed in
	 the case where we can obtain the full list of symbol names
	 before opening the agent; this may be a little more robust
	 than assuming it will handle all errors gracefully.
	 
	 Otherwise, if ps_pglobal_lookup fails, it will at least add
	 the missing symbol's name to the list, and we'll request
	 their values the next time around.  */
      symbol_query = next_undefined_symbol ();
      if (! symbol_query)
	{
	  thread_db_open (serv, process->pid);
	  symbol_query = next_undefined_symbol ();
	}

      /* Now the reply depends on whether there is another 
	 symbol in need of lookup.  */
      if (! symbol_query)
	{
	  gdbserv_output_string (serv, "OK");
	}
      else
	{
	  gdbserv_output_string (serv, "qSymbol:");
	  gdbserv_output_bytes (serv, symbol_query, strlen (symbol_query));
	}
    }
  else if (gdbserv_input_string_match (serv, "GetTLSAddr:") >= 0)
    {
      /* Message qGetTLSAddr:thread-id,offset,link-map-addr */
      unsigned long thread_id, offset, link_map_addr;

      if (thread_agent == NULL
          || td_thr_tls_get_addr_p == 0)
	{
	  /* Not supported by thread library.  */
	  gdbserv_output_string (serv, "E01");
	}
      else if (gdbserv_input_hex_ulong (serv, &thread_id) >= 0
          && gdbserv_input_string_match (serv, ",") >= 0
	  && gdbserv_input_hex_ulong (serv, &offset) >= 0
	  && gdbserv_input_string_match (serv, ",") >= 0
	  && gdbserv_input_hex_ulong (serv, &link_map_addr) >= 0)
	{
	  td_err_e ret;
	  td_thrhandle_t thread_handle;
	  ret = thread_db_map_id2thr (thread_agent, 
				      (thread_t) thread_id,
				      &thread_handle);

	  if (ret == TD_OK)
	    {
	      void *addr;

	      ret = td_thr_tls_get_addr_p (&thread_handle,
				           (void *) link_map_addr, 
				           (size_t) offset,
				           &addr);
	      if (ret == TD_OK)
	        {
		  struct gdbserv_reg addr_as_reg;

		  gdbserv_ulonglong_to_reg (serv,
		                            (unsigned long long)
		                              (unsigned long) addr,
		                            &addr_as_reg);
		  gdbserv_output_reg_beb (serv, &addr_as_reg, 0);
		}
	      else
		{
		  /* Can't find TLS address.  */
		  gdbserv_output_string (serv, "E04");
		}
	    }
	  else
	    {
	      /* Unable to find thread.  */
	      gdbserv_output_string (serv, "E03");
	    }
	}
      else
	{
	  /* Malformed qGetTLSAddr packet.  */
	  gdbserv_output_string (serv, "E02");
	}
    }
  else if (parentvec.process_get_gen)
    parentvec.process_get_gen (serv);
}

/* Function: thread_db_set_gen
   Handle 'Q' requests:
*/

static void
thread_db_set_gen (struct gdbserv *serv)
{
    if (parentvec.process_set_gen)
      parentvec.process_set_gen (serv);
}

static void
thread_db_thread_id (struct gdbserv *serv, 
		     struct gdbserv_thread *thread,
		     struct gdbserv_reg *id)
{
  gdbserv_ulonglong_to_reg (serv, 
			    (unsigned long long) thread->ti.ti_tid, 
			    id);
}

static int
thread_db_thread_lookup_by_id (struct gdbserv *serv,
			       const struct gdbserv_reg *thread_id,
			       struct gdbserv_thread **thread)
{
  unsigned long id;

  gdbserv_reg_to_ulong (serv, thread_id, &id);
  if (id == 0)			/* any thread */
    {
      *thread = next_thread_in_list (NULL);	/* FIXME curthread? */
      return 0;
    }
  else
    {
      *thread = thread_list_lookup_by_tid ((thread_t) id);
      if (*thread == NULL)	/* bad thread id */
	{
	  *thread = next_thread_in_list (NULL);	/* FIXME curthread? */
	  return -1;
	}
      else
	{
	  return 1;		/* success */
	}
    }
}

static char *
thread_db_thread_info (struct gdbserv *serv, struct gdbserv_thread *thread)
{
  char *info = malloc (128);

  /* When a thread's LWP has exited, NPTL reports its ti_lid as
     being equal to that of the main process.  Which is a little
     confusing.  So print the pid in a helpfully detailed way.  */
  sprintf (info, "Type %s State %s LWP %d%s",
	   thread_db_type_str (thread->ti.ti_type),
	   thread_db_state_str (thread->ti.ti_state),
	   thread->ti.ti_lid,
	   (thread->ti.ti_lid == proc_handle.pid ? " (main)" : ""));

  return info;
}


/* If we are using the libthread_db event interface, and PROCESS is
   stopped at an event breakpoint, handle the event.

   If we've taken care of PROCESS's situation and it needs no further
   attention, return non-zero.  If PROCESS still needs attention (say,
   because we're not using the event interface, or PROCESS didn't in
   fact hit an event breakpoint, or it did but had new interesting
   things happen when we tried to single-step it), return zero.  */
static int
handle_thread_db_event (struct child_process *process)
{
  struct gdbserv *serv = process->serv;
  struct gdbserv_thread *thread = process->event_thread;
  lwpid_t lwp;
  union wait w;
  int do_update = 0;

  /* We need to be actually using the event interface.  */
  if (! using_thread_db_events)
    return 0;

  /* We need a thread to work on.  */
  if (! thread)
    return 0;

  /* It needs to be stopped at an event breakpoint.  */
  if (! (process->stop_status == 'T'
	 && process->stop_signal == SIGTRAP
	 && hit_thread_db_event_breakpoint (serv, thread)))
    return 0;

  lwp = thread->ti.ti_lid;

  /* Consume events from the queue.  */
  for (;;)
    {
      td_event_msg_t msg;
      td_err_e status = td_ta_event_getmsg_p (thread_agent, &msg);

      if (status == TD_NOMSG)
	break;

      if (status != TD_OK)
	{
	  fprintf (stderr, "error getting thread messages: %s\n",
		   thread_db_err_str (status));
	  break;
	}

      if (msg.event == TD_CREATE || msg.event == TD_DEATH)
	do_update = 1;
    }

  if (do_update)
    {
#if !ALWAYS_UPDATE_THREAD_LIST
      /* Update the thread list.  */
      update_thread_list (process);
#endif
    }

  /* Disable the event breakpoints while we step the thread across them.  */
  delete_thread_db_event_breakpoints (serv);

  /* Back up the thread, if needed.  */
  decr_pc_after_break (serv, lwp);

  /* Single-step the thread across the breakpoint.  */
  lwp_pool_singlestep_lwp (serv, lwp, 0);

  /* Get a new status for that thread.  */
  if (thread_db_noisy)
    fprintf (stderr, "(waiting after event bp step %s)\n",
	     thread_debug_name (thread));
  if (lwp_pool_waitpid (serv, lwp, (int *) &w, 0) < 0)
    {
      fprintf (stderr, "error waiting for thread %d after "
	       "stepping over event breakpoint:\n%s",
	       lwp, strerror (errno));
      /* We don't have any new status to report...  */
      return 1;
    }
  /* Give underlying target a chance to look at the wait status.  This
     is necessary for software singlestep to work correctly.  */
  handle_waitstatus (process, w);

  /* Re-insert the event breakpoints.  */
  insert_thread_db_event_breakpoints (serv);

  /* If the wait status is a SIGTRAP signal, then that means the
     single-step proceeded normally.  Otherwise, it's a new event we
     should deal with.  */
  if (WIFSTOPPED (w) && WSTOPSIG (w) == SIGTRAP)
    return 1;
  else
    {
      handle_waitstatus (process, w);
      return 0;
    }
}


/* Function: continue_thread
   Send continue to a struct gdbserv_thread. */

static void
continue_thread (struct gdbserv *serv, struct gdbserv_thread *thread,
                 int signal)
{
  thread_db_flush_regset_caches();

  if (thread->ti.ti_lid != 0)
    lwp_pool_continue_lwp (serv, thread->ti.ti_lid, signal);

  thread_db_invalidate_caches ();
}

/* Function: continue_program
   Make sure every thread is running, starting with the event thread. */

static void
thread_db_continue_program (struct gdbserv *serv)
{
  struct child_process *process = gdbserv_target_data (serv);

  /* Synchronize the regset caches.  */
  thread_db_flush_regset_caches();

  /* First resume the event thread. */
  if (process->event_thread)
      continue_thread (serv, process->event_thread, process->signal_to_send);
  else
    lwp_pool_continue_lwp (serv, process->pid, process->signal_to_send);

  process->stop_signal = process->stop_status = 
    process->signal_to_send = 0;

  /* Then resume everyone else. */
  lwp_pool_continue_all (serv);
  process->running = 1;
  thread_db_invalidate_caches ();

  process->focus_thread = NULL;
}

/* Function: singlestep_thread
   Send SINGLESTEP to a struct gdbserv_thread. */

static void
singlestep_thread (struct gdbserv *serv,
                   struct gdbserv_thread *thread,
                   int signal)
{
  lwp_pool_singlestep_lwp (serv, thread->ti.ti_lid, signal);
}

/* Function: singlestep_program
   Make sure every thread is runnable, while the event thread gets to 
   do a singlestep. */

static void
thread_db_singlestep_program (struct gdbserv *serv)
{
  struct child_process *process = gdbserv_target_data (serv);

  /* Synchronize the regset caches.  */
  thread_db_flush_regset_caches();

  /* First singlestep the event thread. */
  if (process->event_thread)
    {
      if (thread_db_noisy)
	fprintf (stderr, "thread_db_singlestep_program: Single stepping event thread %d starting from %#lx\n",
	         process->event_thread->ti.ti_lid,
		 debug_get_pc (serv, process->event_thread->ti.ti_lid));
      singlestep_thread (serv, process->event_thread, process->signal_to_send);
    }
  else
    {
      if (thread_db_noisy)
	fprintf (stderr, "thread_db_singlestep_program: Single stepping %d starting from %#lx\n",
	         process->pid,
		 debug_get_pc (serv, process->pid));
      lwp_pool_singlestep_lwp (serv, process->pid, process->signal_to_send);
    }

  process->stop_status = process->stop_signal =
    process->signal_to_send = 0;

  /* Then resume everyone else. */
  lwp_pool_continue_all (serv);
  process->running = 1;
  thread_db_invalidate_caches ();

  process->focus_thread = NULL;
}

/* Function: thread_db_continue_thread
   Let a single thread continue, while everyone else waits. */

static void
thread_db_continue_thread (struct gdbserv *serv,
			   struct gdbserv_thread *thread,
			   const struct gdbserv_reg *signum)
{
  struct child_process *process = gdbserv_target_data (serv);
  unsigned long sig;

  /* Synchronize the regset caches.  */
  thread_db_flush_regset_caches();

  /* Handle the signal value. */
  if (parentvec.process_signal && signum)
    {
      gdbserv_reg_to_ulong (serv, signum, &sig);
      parentvec.process_signal (serv, (int) sig);
    }

  /* A null thread argument is to be taken as a continue for all. */
  if (thread == NULL)
    thread_db_continue_program (serv);
  else
    {
      process->pid = thread->ti.ti_lid;		/* thread to be continued */
      continue_thread (serv, thread, process->signal_to_send);
      process->stop_status = process->stop_signal =
	process->signal_to_send = 0;
      process->running = 1;
    }
  thread_db_invalidate_caches ();

  /* If we continued a particular thread, then collect wait statuses
     for that thread only.  Otherwise, look for events from
     everyone.  */
  process->focus_thread = thread;
}

/* Function: singlestep_thread
   Let a single thread step, while everyone else waits. */

static void
thread_db_singlestep_thread (struct gdbserv *serv,
			     struct gdbserv_thread *thread,
			     const struct gdbserv_reg *signum)
{
  struct child_process *process = gdbserv_target_data (serv);
  unsigned long sig;

  /* Synchronize the regset caches.  */
  thread_db_flush_regset_caches();

  /* Handle the signal value. */
  if (parentvec.process_signal && signum)
    {
      gdbserv_reg_to_ulong (serv, signum, &sig);
      parentvec.process_signal (serv, (int) sig);
    }

  /* A null thread argument is to be taken as a singlestep for all. */
  if (thread == NULL)
    thread_db_singlestep_program (serv);
  else
    {
      singlestep_thread (serv, thread, process->signal_to_send);
      process->stop_status = process->stop_signal =
	process->signal_to_send = 0;
      process->running = 1;
    }
  thread_db_invalidate_caches ();

  /* If we stepped a particular thread, then collect wait statuses for
     that thread only.  Otherwise, look for events from everyone.  */
  process->focus_thread = thread;
}

/* Function: exit_program
   Called by main loop when child exits. */

static void
thread_db_exit_program (struct gdbserv *serv)
{
  /* FIXME: stop and kill all threads. */

  /* Shut down the thread_db library interface. */
  td_ta_delete_p (thread_agent);
  thread_agent = NULL;
  currentvec = NULL;
  /* Discard all cached symbol lookups. */
  free_symbol_list ();
  /* Discard all cached threads. */
  free_thread_list ();
  /* Call underlying exit_program method. */
  parentvec.exit_program (serv);
}

static void
thread_db_break_program (struct gdbserv *serv)
{
  struct child_process *process = gdbserv_target_data (serv);

  /* We always send the signal to the main thread.  It's not correct
     to use process->pid; that's whatever thread last reported a
     status, and it may well have been exiting.
     
     We send either SIGSTOP or SIGINT depending upon user preference -
     a GDB monitor command may be used to change the signal used.  SIGINT
     has the advantage of allowing the user to continue in the usual
     manner via GDB's continue command.  SIGSTOP may be preferred in some
     settings because it cannot be blocked or ignored.  When SIGSTOP is
     used, it is slightly more difficult to continue without sending
     another SISSTOP.  */

  if (process->interrupt_with_SIGSTOP)
    {
      if (process->debug_backend || thread_db_noisy)
	fprintf (stderr, " -- send SIGSTOP to child %d\n", proc_handle.pid);

      /* Tell the GDB user that SIGSTOP has been sent to the inferior.  */
      print_sigstop_message (serv);

      kill_lwp (proc_handle.pid, SIGSTOP);
    }
  else
    {
      if (process->debug_backend || thread_db_noisy)
	fprintf (stderr, " -- send SIGINT to child %d\n", proc_handle.pid);

      /* Tell the GDB user that SIGINT has been sent to the inferior.  */
      print_sigint_message (serv);

      kill_lwp (proc_handle.pid, SIGINT);
    }
}

/* Function: check_child_state

   This function checks for signal events in the running child processes.
   It does not block if there is no event in any child, but if there is
   an event, it selectively calls other functions that will, if appropriate,
   make sure that all the other children are stopped as well. 

   This is a polling (non-blocking) function, and may be called when 
   the child is already stopped. */

static int
thread_db_check_child_state (struct child_process *process)
{
  struct gdbserv *serv = process->serv;
  int eventpid;
  union wait w;

  /* The "process" is likely to be the parent thread.
     We will have to manage a list of threads/pids. */

  /* Since this is a polling call, and threads don't all stop at once, 
     it is possible for a subsequent call to intercept a new wait event
     before we've resumed from the previous wait event.  Prevent this
     with a resume flag. */

  if (process->running)
    {
      eventpid = -1;

      /* If we only stepped or continued a single thread, check for
	 status results only from that thread, even though there may
	 be others collected from before.  */
      if (process->focus_thread)
	eventpid = lwp_pool_waitpid (serv, process->focus_thread->ti.ti_lid,
				     (int *) &w, WNOHANG);
      else
	eventpid = lwp_pool_waitpid (serv, -1, (int *) &w, WNOHANG);

      if (eventpid > 0)	/* found an event */
	{
	  /* Allow underlying target to use the event process by default,
	     since it is stopped and the others are still running. */
	  process->pid = eventpid;

	  handle_waitstatus (process, w);

	  /* Look for thread exit. 
	     This has to be done now -- if the eventpid has exited, I can't
	     run update_thread_list because there is no stopped process 
	     thru which I can read memory.  I could find another one to 
	     stop, but it's not really worth it. */
	  if (process->stop_status == 'W')
	    {
	      if (eventpid == proc_handle.pid)
		return 1;	/* Main thread exited! */
	      else
		return 0;	/* Just a thread exit, don't tell GDB. */
	    }

	  /* Stop all the threads we know about.  */
	  lwp_pool_stop_all (serv);

	  if (thread_db_noisy)
	    fprintf (stderr,
		     "\n<check_child_state: %d got '%c' - %d at 0x%08lx>\n", 
		     process->pid,
		     process->stop_status,
		     process->stop_signal,
		     (unsigned long) debug_get_pc (process->serv, process->pid));

#if !ALWAYS_UPDATE_THREAD_LIST
	  /* The thread_db event model requires that `event_thread' (see
	     below) gets set correctly, but this won't happen unless there's
	     a thread list to search.  So, if the thread_list is empty and
	     we're using the thread_db event model, we need to update the
	     thread list.  */
	  if (thread_list == NULL && using_thread_db_events)
#endif
	    {
	      /* Update the thread list, and attach to (and thereby stop)
		 any new threads we find.  */
	      update_thread_list (process);
	    }

	  process->event_thread = thread_list_lookup_by_lid (process->pid);

	  /* For now, call get_thread_signals from here (FIXME:) */
	  get_thread_signals ();

	  /* If we're using the thread_db event interface, and this is
	     a thread_db event, then just handle it silently and
	     continue.  */
	  if (handle_thread_db_event (process))
	    {
	      currentvec->continue_program (serv);
	      return 0;
	    }

	  /* If we're using the signal-based interface, and someone
	     got a thread-related signal, then deal with that.  */
	  if (got_thread_signals && ignore_thread_signal (process))
	    {
	      /* Ignore this signal, restart the child. */
	      if (thread_db_noisy)
		fprintf (stderr, 
			 "<check_child_state: ignoring signal %d for %d>\n",
			 process->stop_signal, process->pid);
	      if (process->stop_signal == debug_signal)
		{
		  /* The debug signal arrives under two circumstances:
		     1) The main thread raises it once, upon the first call
		     to pthread_create.  This lets us detect the manager
		     thread.  The main thread MUST be given the restart
		     signal when this occurs. 
		     2) The manager thread raises it each time a new
		     child thread is created.  The child thread will be
		     in sigsuspend, and MUST be sent the restart signal.
		     However, the manager thread, which raised the debug
		     signal, does not need to be restarted.  

		     Sending the restart signal to the newly attached
		     child thread (which is not the event thread) is
		     handled in continue_all_threads.  */

		  if (process->pid == proc_handle.pid)  /* main thread */
		    process->stop_signal = restart_signal;
		  else				/* not main thread */
		    process->stop_signal = 0;

#if !ALWAYS_UPDATE_THREAD_LIST
		  /* Update the thread list.  */
		  update_thread_list (process);
#endif

		}

	      /* Continue the program.  */
	      process->signal_to_send = process->stop_signal;
	      currentvec->continue_program (serv);
	      return 0;
	    }

	  /* Continue on if the thread in question is now a zombie.  */
	  if (process->event_thread
              && process->event_thread->ti.ti_state == TD_THR_ZOMBIE)
	    {
	      if (thread_db_noisy)
		fprintf (stderr,
			 "\n<check_child_state: Ignoring %d - it's a zombie.>\n", 
			 process->pid);
	      /* Updating the thread list will disable this zombie, plus any others.  */
	      update_thread_list (process);
	      /* Continue the main thread; not the zombie.  */
	      process->event_thread = NULL;
	      process->pid = proc_handle.pid;
	      /* No signal.  */
	      process->signal_to_send = 0;
	      /* Continue.  */
	      currentvec->continue_program (serv);
	      return 0;
	    }

	  process->running = 0;

	  /* Pass this event back to GDB. */
	  if (process->debug_backend)
	    fprintf (stderr, "wait returned '%c' (%d) for %d.\n", 
		     process->stop_status, process->stop_signal, process->pid);
	  return 1;
	}
    }

  /* NOTE: this function is called in a polling loop, so it
     probably (?) should not block.  Return when there's no event. */
  return 0;
}

/* Function: fromtarget_thread_break
   Called from the main loop when one of the child processes stops.
   Notifies the RDA library and lets it know which thread took the event. */

static void
thread_db_fromtarget_thread_break (struct child_process *process)
{
  int gdb_signal = parentvec.compute_signal (process->serv,
					     process->stop_signal);

  gdbserv_fromtarget_thread_break (process->serv, 
				   process->event_thread,
				   gdb_signal);
}

/* Function: get_thread_reg
   Get a register value for a specific thread. */

static int
thread_db_get_thread_reg (struct gdbserv *serv, 
			  struct gdbserv_thread *thread, 
			  int regnum, 
			  struct gdbserv_reg *reg)
{
  struct child_process *process = gdbserv_target_data (serv);
  td_thrhandle_t thread_handle;
  FPREGSET_T fpregset;
  GREGSET_T gregset;
  td_err_e ret;

  /* Initialize reg to 0 in the event that we return early due to a
     register being unsupported.  */
  gdbserv_ulonglong_to_reg (serv, 0LL, reg);

  if (thread == NULL)
    thread = process->event_thread;	/* Default to the event thread. */

  if (thread_agent == NULL || 		/* Thread layer not alive yet? */
      thread       == NULL)		/* No thread specified? */
    {
      /* Fall back on parentvec non-threaded method. */
      if (parentvec.get_reg)
	return parentvec.get_reg (serv, regnum, reg);
      else
	return -1;	/* give up. */
    }

  /* Thread_db active, thread_agent valid.
     The request goes to the thread_db library. 
     From there it will be dispatched to ps_lgetregs,
     and from there it will be kicked back to the parent. */

  if (thread->ti.ti_state == TD_THR_ZOMBIE ||
      thread->ti.ti_state == TD_THR_UNKNOWN)
    {
      /* This thread is dead!  Can't get its registers. */
      return -1;
    }

  ret = thread_db_map_id2thr (thread_agent, 
			      thread->ti.ti_tid,
			      &thread_handle);
  if (ret == TD_NOTHR)
    {
      /* Thread has exited, no registers. */
      return -1;
    }
  else if (ret != TD_OK)
    {
      fprintf (stderr, "<<< ERROR get_thread_reg map_id2thr %lu >>>\n",
	       (unsigned long) thread->ti.ti_tid);
      return -1;	/* fail */
    }

  if (is_fp_reg (regnum))
    {
      if (thread_db_getfpregs (&thread_handle, &fpregset) != TD_OK)
	{
	  /* Failure to get the fpregs isn't necessarily an error.
	     Assume that the target just doesn't support fpregs. */
	  return 0;
	}
      /* Now extract the register from the fpregset. */
      if (reg_from_fpregset (serv, reg, regnum, &fpregset) < 0)
	{
	  fprintf (stderr, "<<< ERROR reg_from_fpregset %lu %d>>>\n",
		   (unsigned long) thread->ti.ti_tid, regnum);
	  return -1;
	}
    }
  else if (td_thr_getxregsize_p != NULL
           && td_thr_getxregs_p != NULL
	   && is_extended_reg (regnum))
    {
      int xregsize;
      void *xregset;

      if (td_thr_getxregsize_p (&thread_handle, &xregsize) != TD_OK)
	{
	  /* Failure to get the size of the extended regs isn't
	     necessarily an error.  Assume that the target just
	     doesn't support them.  */
	  return 0;
	}

      if (xregsize <= 0)
	{
	  /* Another form of not being supported...  */
	  return 0;
	}

      /* Allocate space for the extended registers.  */
      xregset = alloca (xregsize);
      
      /* Fetch the extended registers.  */
      if (td_thr_getxregs_p (&thread_handle, xregset) != TD_OK)
	{
	  /* Failure to get the extended regs isn't necessarily an error.
	     Assume that the target just doesn't support them.  */
	  return 0;
	}

      /* Now extract the register from the extended regset.  */
      if (reg_from_xregset (serv, reg, regnum, xregset) < 0)
	{
	  fprintf (stderr, "<<< ERROR reg_from_xregset %lu %d>>>\n",
		   (unsigned long) thread->ti.ti_tid, regnum);
	  return -1;
	}
    }
  else if (is_gp_reg (regnum)) /* GP reg */
    {
      if (thread_db_getgregs (&thread_handle, gregset) != TD_OK)
	{
	  fprintf (stderr,
		   "<<< ERROR get_thread_reg td_thr_getgregs %lu >>>\n",
		   (unsigned long) thread->ti.ti_tid);
	  return -1;	/* fail */
	}
      /* Now extract the requested register from the gregset. */
      if (reg_from_gregset (serv, reg, regnum, gregset) < 0)
	{
	  fprintf (stderr, "<<< ERROR reg_from_gregset %lu %d>>>\n", 
		   (unsigned long) thread->ti.ti_tid, regnum);
	  return -1;	/* fail */
	}
    }
  else
    {
      /* Register not supported by this target.  This shouldn't be
         construed as an error though.  */
      return 0;
    }

  return 0;		/* success */
}

/* Function: set_thread_reg
   Set a register value for a specific thread. */

static int
thread_db_set_thread_reg (struct gdbserv *serv, 
			  struct gdbserv_thread *thread, 
			  int regnum, 
			  const struct gdbserv_reg *reg)
{
  struct child_process *process = gdbserv_target_data (serv);
  td_thrhandle_t thread_handle;
  FPREGSET_T fpregset;
  GREGSET_T gregset;
  td_err_e ret;

  if (thread == NULL)
    thread = process->event_thread;	/* Default to the event thread. */

  if (thread_agent == NULL || 		/* Thread layer not alive yet? */
      thread       == NULL)		/* No thread specified? */
    {
      /* Fall back on parentvec non-threaded method. */
      if (parentvec.set_reg)
	return parentvec.set_reg (serv, regnum, (struct gdbserv_reg *) reg);
      else
	return -1;	/* give up. */
    }

  /* Thread_db active, thread_agent valid.
     The request goes to the thread_db library. 
     From there it will be dispatched to ps_lsetregs,
     and from there it will be kicked back to the parent. */

  if (thread->ti.ti_state == TD_THR_ZOMBIE ||
      thread->ti.ti_state == TD_THR_UNKNOWN)
    {
      /* This thread is dead!  Can't get its registers. */
      return -1;
    }

  ret = thread_db_map_id2thr (thread_agent, 
			      thread->ti.ti_tid,
			      &thread_handle);
  if (ret == TD_NOTHR)
    {
      /* Thread has exited, no registers. */
      return -1;
    }
  else if (ret != TD_OK)
    {
      fprintf (stderr, "<<< ERROR set_thread_reg map_id2thr %lu >>>\n",
	       (unsigned long) thread->ti.ti_tid);
      return -1;	/* fail */
    }

  if (is_fp_reg (regnum))
    {
      /* Get the current fpregset.  */
      if (thread_db_getfpregs (&thread_handle, &fpregset) != TD_OK)
	{
	  /* Failing to get the fpregs is not necessarily an error.
	     Assume it simply means that this target doesn't support
	     fpregs. */
	  return 0;
	}
      /* Now write the new reg value into the fpregset. */
      if (reg_to_fpregset (serv, reg, regnum, &fpregset) < 0)
	{
	  fprintf (stderr, "<<< ERROR reg_to_fpregset %lu %d >>>\n",
		   (unsigned long) thread->ti.ti_tid, regnum);
	  return -1;	/* fail */
	}
      /* Now write the fpregset back to the child. */
      if (thread_db_setfpregs (&thread_handle, &fpregset) != TD_OK)
	{
	  fprintf (stderr,
		   "<<< ERROR set_thread_reg td_thr_setfpregs %lu>>>\n",
		   (unsigned long) thread->ti.ti_tid);
	  return -1;	/* fail */
	}
    }
  else if (td_thr_getxregsize_p != NULL
           && td_thr_getxregs_p != NULL
           && td_thr_setxregs_p != NULL
	   && is_extended_reg (regnum))
    {
      int xregsize;
      void *xregset;

      if (td_thr_getxregsize_p (&thread_handle, &xregsize) != TD_OK)
	{
	  /* Failure to get the size of the extended regs isn't
	     necessarily an error.  Assume that the target just
	     doesn't support them.  */
	  return 0;
	}

      if (xregsize <= 0)
	{
	  /* Another form of not being supported...  */
	  return 0;
	}

      /* Allocate space for the extended registers.  */
      xregset = alloca (xregsize);

      /* Fetch the extended registers.  */
      if (td_thr_getxregs_p (&thread_handle, xregset) != TD_OK)
	{
	  /* Failure to get the extended regs isn't necessarily an error.
	     Assume that the target just doesn't support them.  */
	  return 0;
	}
      /* Now write the new reg value into the extended regset. */
      if (reg_to_xregset (serv, reg, regnum, xregset) < 0)
	{
	  fprintf (stderr, "<<< ERROR reg_to_xregset %lu %d >>>\n", 
		   (unsigned long) thread->ti.ti_tid, regnum);
	  return -1;	/* fail */
	}
      /* Now write the extended regset back to the child. */
      if (td_thr_setxregs_p (&thread_handle, gregset) != TD_OK)
	{
	  fprintf (stderr,
		   "<<< ERROR set_thread_reg td_thr_setxregs %lu >>>\n",
		   (unsigned long) thread->ti.ti_tid);
	  return -1;	/* fail */
	}
    }
  else if (is_gp_reg (regnum))
    {
      /* First get the current gregset.  */
      if (thread_db_getgregs (&thread_handle, gregset) != TD_OK)
	{
	  fprintf (stderr,
		   "<<< ERROR set_thread_reg td_thr_getgregs %lu >>>\n",
		   (unsigned long) thread->ti.ti_tid);
	  return -1;	/* fail */
	}
      /* Now write the new reg value into the gregset. */
      if (reg_to_gregset (serv, reg, regnum, gregset) < 0)
	{
	  fprintf (stderr, "<<< ERROR reg_to_gregset %lu %d >>>\n", 
		   (unsigned long) thread->ti.ti_tid, regnum);
	  return -1;	/* fail */
	}
      /* Now write the gregset back to the child. */
      if (thread_db_setgregs (&thread_handle, gregset) != TD_OK)
	{
	  fprintf (stderr,
		   "<<< ERROR set_thread_reg td_thr_setgregs %lu >>>\n",
		   (unsigned long) thread->ti.ti_tid);
	  return -1;	/* fail */
	}
    }

  return 0;	/* success */
}

/* Function: thread_db_attach
   gdbserv target function called upon attaching to gdb. 
   Return -1 for failure, zero for success. 
   Note that this has nothing to do with attaching to a running process
   (which in fact we don't even know how to do), or a running thread. */

int
thread_db_attach (struct gdbserv *serv, struct gdbserv_target *target)
{
  td_err_e ret;
  struct child_process *process = target->data;
  extern struct server_vector gdbserver;

  if ((thread_db_dlopen ()) < 0)
    return -1;			/* fail */

  /* Save a copy of the existing target vector before we modify it. */
  memcpy (&parentvec, target, sizeof (parentvec));
  /* Save a pointer to the actual target vector. */
  currentvec = target;

  /* Initialize the library.  */
  if ((ret = td_init_p ()) != TD_OK)
    {
      fprintf (stderr, 
	       "Cannot initialize libthread_db: %s", thread_db_err_str (ret));
      currentvec = NULL;
      return -1;		/* fail */
    }

  /* Initialize threadish target methods. */
  target->thread_info         = thread_db_thread_info;
  target->thread_next         = thread_db_thread_next;
  target->thread_id           = thread_db_thread_id;
  target->thread_lookup_by_id = thread_db_thread_lookup_by_id;
  target->process_set_gen     = thread_db_set_gen;
  target->process_get_gen     = thread_db_get_gen;
  target->detach              = thread_db_detach;

  /* Take over selected target methods. */
  target->exit_program        = thread_db_exit_program;
  target->continue_program    = thread_db_continue_program;
  target->singlestep_program  = thread_db_singlestep_program;

  target->continue_thread     = thread_db_continue_thread;
  target->singlestep_thread   = thread_db_singlestep_thread;

  target->break_program       = thread_db_break_program;

  /* Take over get_reg / set_reg methods with threaded versions. */
  if (target->next_gg_reg != NULL &&
      target->reg_format  != NULL &&
      target->output_reg  != NULL &&
      target->input_reg   != NULL)
    {
      target->get_thread_reg      = thread_db_get_thread_reg;
      target->set_thread_reg      = thread_db_set_thread_reg;
    }
  else
    fprintf (stderr, "< ERROR attach: GDB will not read thread regs. >>>\n");

  /* Preload the symbol list with the names of the symbols whose names
     we use ourselves.  

     This might be a kludge, but it's not a gratuitous kludge.  On
     older LinuxThreads libraries, RDA must manage LinuxThreads
     signals.  Since libthread_db provides no abstraction for managing
     them, RDA must look up the addresses of the signal variables and
     read their values itself.  However, libthread_db may never look
     those symbols up itself, and they may not appear in the list
     provided by td_symbol_list_p.  (In fact, in glibc-2.2.93, they
     don't.)

     So RDA may as well preload them into the symbol list; otherwise,
     get_thread_signals will fail even though the symbols are defined,
     because the names will only get added to symbol_list as we
     attempt to look them up; each remote protocol symbol lookup dance
     will resolve exactly one new symbol, allowing get_thread_signal
     to get as far as requesting the next one and failing.

     As it turns out, this is actually necessary, not just efficient,
     because failures from get_thread_signal cause RDA to try the
     libthread_db event-based interface; we may end up using that even
     when the signal-based interface is actually available.  And we'd
     rather use the signal-based interface when we can, to avoid
     changing the behavior of RDA on older systems.  */
  add_symbol_to_list ("__pthread_sig_restart",   0, UNDEFINED);
  add_symbol_to_list ("__pthread_sig_cancel",    0, UNDEFINED);
  add_symbol_to_list ("__pthread_sig_debug",     0, UNDEFINED);
  add_symbol_to_list ("__pthread_threads_debug", 0, UNDEFINED);

  if (td_symbol_list_p)
    {
      /* Take all the symbol names libthread_db might try to look up
	 and place them in our cached symbol list, to be looked up
	 when invited by GDB.  */
      const char **symbol_list = td_symbol_list_p ();
      int i;

      for (i = 0; symbol_list[i]; i++)
	add_symbol_to_list (symbol_list[i], 0, UNDEFINED);
    }

  /* Attempt to open the thread_db interface.  This attempt will 
     most likely fail (unles the child is statically linked). */
  thread_db_open (serv, process->pid);	/* Don't test return value */

  /* Take over the "wait" vector. FIXME global object */
  gdbserver.check_child_state = thread_db_check_child_state;
  /* Take over the "fromtarget_break" vector. FIXME global object */
  gdbserver.fromtarget_break = thread_db_fromtarget_thread_break;
  /* FIXME what about terminate and exit? */

  /* Record the initial thread's pid in the LWP pool.  */
  lwp_pool_new_stopped (process->pid);

  /* Initially, there is no focus thread.  */
  process->focus_thread = NULL;

  /* Set up the regset caches.  */
  initialize_regset_caches ();
  return 0;		/* success */
}
@


1.21
log
@	* thread-db.c (TID_MAY_BE_REUSED): Define.
	(find_new_threads_callback): Detect thread id reuse.
@
text
@d1444 1
a1444 1
		fprintf (stderr, "(thread deletion / reuse: %s)\n", thread_debug_name (thread));
d1525 10
d2113 1
a2113 1
      if (process->debug_backend)
d2119 1
a2119 1
      kill (proc_handle.pid, SIGSTOP);
d2123 1
a2123 1
      if (process->debug_backend)
d2129 1
a2129 1
      kill (proc_handle.pid, SIGINT);
d2275 20
@


1.20
log
@	* diagnostics.h, diagnostics.c (print_sigint_message): New function.
	* linux-target.c (linux_process_rcmd): Add monitor commands
	"interrupt-with-SIGSTOP and interrupt-with-SIGINT".
	* server.h (struct child_process): Add new field
	interrupt_with_SIGSTOP.
	* thread-db.c (thread_db_break_program): Interrupt using either
	SIGSTOP or SIGINT depending upon user's preference.
@
text
@d52 1
d1430 5
a1434 1
  if ((thread = thread_list_lookup_by_tid (ti.ti_tid)) == NULL)
d1438 11
a1448 1
	  thread = add_thread_to_list (&ti);
@


1.19
log
@	* Makefile.am (EXTRA_rda_SOURCES): Add diagnostics.c.
	* configure.in (TARGET_MODULES): Add diagnostics.o.
	* Makefile.in, configure: Regenerate.
	* diagnostics.c: New file.
	* diagnostics.h (output_O_packet, print_sigstop_message): New
	functions.
	* ptrace-target.c (diagnostics.h): Include.
	(ptrace_break_program): Call print_sigstop_message().
	* thread_db.c (thread_db_break_program): Likewise.
@
text
@d2077 16
d2094 6
a2099 6
     We send SIGSTOP, rather than some other signal such as SIGINT,
     because SIGSTOP cannot be blocked or ignored.  On Linux, using
     a signal that can be blocked means that the process never gets
     interrupted, since it's the kernel which does the blocking.  */
  if (process->debug_backend)
    fprintf (stderr, " -- send SIGSTOP to child %d\n", proc_handle.pid);
d2101 2
a2102 2
  /* Tell the GDB user that SIGSTOP has been sent to the inferior.  */
  print_sigstop_message (serv);
d2104 2
a2105 1
  kill (proc_handle.pid, SIGSTOP);
@


1.18
log
@	* ptrace-target.c (ptrace_break_program): Use SIGSTOP instead of
	SIGINT to interrupt inferior process.
	* thread-db.c (thread_db_break_program): Likewise.
@
text
@d2084 4
@


1.17
log
@	* thread-db.c (handle_thread_db_event): Allow underlying target a
	chance to look at the wait status too.
	(thread_db_check_child_state): Ensure that there's a thread list
	to work with when using the thread_db event model.
@
text
@d2076 6
a2081 1
     status, and it may well have been exiting.  */
d2083 2
a2084 2
    fprintf (stderr, " -- send SIGINT to child %d\n", proc_handle.pid);
  kill (proc_handle.pid, SIGINT);
@


1.16
log
@Add diagnostic messages.
@
text
@d1856 3
d2152 7
a2158 4
#if ALWAYS_UPDATE_THREAD_LIST
	  /* Update the thread list, and attach to (and thereby stop)
             any new threads we find.  */
	  update_thread_list (process);
d2160 5
@


1.15
log
@	* thread-db.c (ALWAYS_UPDATE_THREAD_LIST): Define to be 0.
	(handle_thread_db_event): Update thread list upon receipt of
	TD_CREATE or TD_DEATH events.
	(thread_db_check_child_state): Potentially disable, depending upon
	value of ALWAYS_UPDATE_THREAD_LIST, the thread list update.
	(thread_db_check_child_state): Update thread list for signal based
	event model too.
@
text
@d46 1
a49 1
int proc_service_noisy = 0;
d1381 1
a1381 1
attach_thread (struct gdbserv_thread *thread)
d1395 1
a1395 1
      int status = lwp_pool_attach (thread->ti.ti_lid);
d1416 1
d1438 1
a1438 1
	  attach_thread (thread);
d1469 1
d1472 3
d1477 1
a1477 1
		    (void *) 0, 
d1848 1
a1848 1
  if (lwp_pool_waitpid (lwp, (int *) &w, 0) < 0)
d1877 2
a1878 1
continue_thread (struct gdbserv_thread *thread, int signal)
d1883 1
a1883 1
    lwp_pool_continue_lwp (thread->ti.ti_lid, signal);
d1901 1
a1901 1
      continue_thread (process->event_thread, process->signal_to_send);
d1903 1
a1903 1
    lwp_pool_continue_lwp (process->pid, process->signal_to_send);
d1909 1
a1909 1
  lwp_pool_continue_all ();
d1941 7
a1947 1
    singlestep_thread (serv, process->event_thread, process->signal_to_send);
d1949 7
a1955 1
    lwp_pool_singlestep_lwp (serv, process->pid, process->signal_to_send);
d1961 1
a1961 1
  lwp_pool_continue_all ();
d1995 1
a1995 1
      continue_thread (thread, process->signal_to_send);
d2112 1
a2112 1
	eventpid = lwp_pool_waitpid (process->focus_thread->ti.ti_lid,
d2115 1
a2115 1
	eventpid = lwp_pool_waitpid (-1, (int *) &w, WNOHANG);
d2139 1
a2139 1
	  lwp_pool_stop_all ();
d2206 2
d2218 1
a2218 1
		     process->stop_status, process->stop_signal, eventpid);
@


1.14
log
@Add support for the Linux NPTL (New POSIX Thread Library) thread
implementation.
* arch.h, lwp-pool.c, lwp-pool.h, stock-breakpoints.c:
* stock-breakpoints.h: New files.
* gdbserv-thread-db.h (continue_lwp, singlestep_lwp, attach_lwp)
(stop_lwp): Move these ...
* lwp-ctrl.h: ... to here (new file).
* server.h (struct child_process): Include a pointer to the
architecture object, a breakpoint table, and a pointer to the
"focus thread".
* linux-target.c: Create architecture objects for the i386 and
FRV, and describe breakpoints for those architectures.
#include "arch.h".
[STOCK_BREAKPOINTS]: #include "stock-breakpoints.h".
(allocate_empty_arch): New function.
[X86_LINUX_TARGET] (stock_table_to_x86, x86_table_to_stock)
(stock_bp_to_x86, x86_bp_to_stock, x86_make_bp_table, x86_set_bp)
(x86_delete_bp, x86_bp_hit_p, x86_make_arch): New functions.
(MAKE_ARCH): #define to call x86_make_arch.
[X86_LINUX_TARGET] (stock_table_to_frv, frv_table_to_stock)
(stock_bp_to_frv, frv_bp_to_stock, frv_make_bp_table, frv_set_bp)
(frv_delete_bp, frv_bp_hit_p, frv_make_arch): New functions.
(MAKE_ARCH): #define to call frv_make_arch.
(linux_attach): If MAKE_ARCH is #defined, create an architecture
object for this process.  And if we have an architecture object,
make a breakpoint table.
* thread-db.c: #include <assert.h>, "arch.h", "lwp-ctrl.h", and
"lwp-pool.h".
(struct gdbserv_thread): Remove state-tracking flags 'attached',
'stopped', 'waited', and 'stepping'; all that state is handled
inside lwp-pool.c now.
(add_thread_to_list): Zero the entire newly allocated thread
structure.
(thread_list_lookup_by_lid): Prefer threads whose ti_lid values
are different from that of the main process.
(thread_db_state_str, thread_db_type_str): Don't include
formatting spaces here.
(thread_db_event_str): New function.
(thread_debug_name): New function.
(get_thread_signals): Return a value indicating success or failure.
(ignore_thread_signal): New function.
(using_thread_db_events, create_notification, death_notification)
(get_event_notification, set_event_breakpoint)
(insert_thread_db_event_breakpoints)
(delete_thread_db_event_breakpoints, request_thread_db_events)
(hit_thread_db_event_breakpoint, handle_thread_db_event): New
variables and functions, for using libthread_db's event interface.
(thread_db_open): Gather error-handling code next to the operation
that might fail.  Decide here whether to use the signal-based
debugging interface, or the event-based debugging interface.
(stop_thread, stop_all_threads, struct event_list, pending_events)
(pending_events_listsize, pending_events_top, add_pending_event)
(select_pending_event, send_pending_signals, wait_all_threads):
Deleted; we now use lwp-pool.c for all this.
(attach_thread, continue_thread, continue_all_threads)
(singlestep_thread, thread_db_singlestep_program)
(thread_db_continue_thread, thread_db_singlestep_thread): Use the
lwp-pool.c functions, instead of calling the lwp manipulation
functions directly and managing state here.  Keep track of the
focus thread.
(find_new_threads_callback): Always call attach_thread.  If we're
using libthread_db events, enable event reporting for the new
thread.
(update_thread_list): Take the current child process as an
argument; if the current focus thread disappears, clear the
process's focus_thread pointer.
(thread_db_thread_next): Pass the current child process to
update_thread_list.
(thread_db_thread_info): Reformat thread descriptions.  Mark
threads whose pid is equal to the process ID.
(thread_db_check_child_state): Use the lwp-pool functions, instead
of calling waitpid and the old stop-all-threads functions.  If we
have a focus thread, only check for a status on that thread.
Check for libthread_db events.  Use ignore_thread_signal, instead
of writing it out.
(thread_db_break_program): New function.
(thread_db_attach): Register it as the target's 'break_program'
method.  Always preload the symbol list with the names we'll need
for the signal-based interface, even if we have td_symbol_list.
Use lwp_pool_new_stopped to register the initial thread.  Clear
the focus thread.
* ptrace-target.c: #define _GNU_SOURCE and #include <sys/types.h>
and <linux/unistd.h>, to get declarations for the functions we
need.
#include "lwp-ctrl.h".
(continue_lwp, singlestep_lwp, attach_lwp): Remove
unnecessary 'extern' keywords.  Move pre-function comments to
lwp-ctrl.h.  Take an ordinary 'pid_t', not an 'lwpid_t', since
we're calling ptrace / tkill, and that's what they expect; rename
arguments accordingly.  Preserve value of errno across calls to
fprintf when reporting errors.
(kill_lwp): All the above, and use tkill system call if available.
* configure.in: Whenever we include thread-db.o in TARGET_MODULES,
also include lwp-pool.o.
On i386 and FRV Linux, use the stock-breakpoints module.
* config.in: Add template for STOCK_BREAKPOINTS.
* Makefile.am (EXTRA_rda_SOURCES): Include stock-breakpoints.c.
* Makefile.in, aclocal.m4, configure: Regenerated.
@
text
@d51 2
d1784 1
d1818 3
a1820 2
      /* The only messages we're concerned with are TD_CREATE and
	 TD_DEATH.
d1822 6
a1827 4
	 Every time thread_db_check_child_state gets a wait status
	 from waitpid, we call update_thread_list, so our list is
	 always up to date; we don't actually need to do anything with
	 these messages for our own sake.  */
d2131 1
d2135 1
d2181 6
@


1.13
log
@Compile with no warnings.
* Makefile.am (AM_CFLAGS): Compile with -Wall.
* Makefile.in: Regenerated.
* gdbserv-thread-db.h (stop_lwp, handle_waitstatus, ps_pdread,
ps_pdwrite): Add declarations for these functions to
gdbserv-thread-db.h.
* linux-target.c: #include <string.h>, <sys/types.h>, and
<sys/wait.h> to get declarations for system functions used in this
file.
(linux_get_reg): When register REGNO doesn't exist, provide zeros
for its value; don't use an uninitialized pointer.
(linux_set_reg): Delete unused variables.
(decr_pc_after_break): Fix printf format directive to match
arguments.
* ptrace-target.c (ptrace_read_user, ptrace_check_child_state,
ptrace_attach): Delete unused variables.
(ptrace_singlestep_program, ptrace_continue_program): Fix printf
format directive to match arguments.
* server.c (invalid_speed): Same.
(main): Initialize infd, outfd, and speed.
(tty_raw): Use proper name for speed_t "zero baud" value.
* thread-db.c: #include <string.h> and "gdbserv-utils.h", to get
declarations for functions used in this file.
(thread_db_open, wait_all_threads)
(thread_db_check_child_state, thread_db_get_thread_reg)
(thread_db_set_thread_reg): Fix printf format directive to match
arguments.
(continue_thread, thread_db_get_thread_reg, continue_all_threads,
thread_db_attach): Delete unused variables.
@
text
@d35 1
d38 1
a39 1
#include "gdbserv-target.h"
d41 1
d44 2
d186 1
d190 49
d240 1
a240 4
  int attached : 1;
  int stopped : 1;
  int waited : 1;
  int stepping : 1;
d242 1
d254 1
a323 12
static struct gdbserv_thread *
thread_list_lookup_by_lid (lwpid_t pid)
{
  struct gdbserv_thread *tmp;

  for (tmp = thread_list; tmp; tmp = tmp->next)
    if (tmp->ti.ti_lid == pid)
      break;

  return tmp;
}

d440 3
a442 3
  case TD_THR_ACTIVE:		return "<active> ";
  case TD_THR_ZOMBIE:		return "<zombie> ";
  case TD_THR_SLEEP:		return "<sleep>  ";
d454 1
a454 1
  case TD_THR_USER:		return "<user>  ";
d497 51
d593 24
d866 333
d1292 1
a1292 1
   Returns: -1 for success, 0 for failure
d1308 11
a1318 1
  if (thread_agent == NULL)
d1320 2
a1321 2
      proc_handle.pid = pid;
      proc_handle.serv = serv;
d1323 26
a1348 10
      ret = td_ta_new_p (&proc_handle, &thread_agent);
      if (ret == TD_OK)
	{
	  return -1;	/* success */
	}
      else if (thread_db_noisy)
	{
	  fprintf (stderr, "< -- failed, thread_agent = %p>\n", thread_agent);
	}
      return 0;		/* failure */
d1350 2
a1351 1
  return -1;		/* success */
d1354 1
d1381 1
a1381 2
  if (thread->ti.ti_lid   != 0 &&
      thread->ti.ti_state != TD_THR_ZOMBIE)	/* Don't attach a zombie. */
d1383 21
a1403 4
      if (attach_lwp (thread->ti.ti_lid) == 0)
	thread->attached = 1;
      else
	thread->attached = 0;
d1431 7
a1437 3
	  /* Now make sure we've attached to it.  
	     Skip the main pid (already attached). */
	  if (thread->ti.ti_lid != proc_handle.pid)
d1439 5
a1443 1
	      attach_thread (thread);
d1463 1
a1463 1
update_thread_list (void)
d1495 3
d1516 2
a1517 1
      update_thread_list ();
d1754 4
a1757 2
  sprintf (info, "PID %d Type %s State %s",
	   thread->ti.ti_lid, 
d1759 4
a1762 1
	   thread_db_state_str (thread->ti.ti_state));
a1765 18
/* Function: get_target_int_by_name
   Read the value of a target integer, given its name and size.
   Returns -1 for failure, zero for success. */

static int
get_target_int_by_name (char *name, void *value, int size)
{
  paddr_t addr;

  if (ps_pglobal_lookup (&proc_handle, NULL, name, &addr) == PS_OK)
    {
      if (ps_pdread (&proc_handle, addr,
		     (gdb_ps_read_buf_t) value,
		     (gdb_ps_size_t) size) == PS_OK)
	return 0;
    }
  return -1;		/* fail */
}
d1767 2
a1768 3
/* Function: set_target_int_by_name
   Read the value of a target integer, given its name and size.
   Returns -1 for failure, zero for success. */
d1770 5
d1776 1
a1776 1
set_target_int_by_name (char *name, void *value, int size)
d1778 4
a1781 1
  paddr_t addr;
d1783 15
a1797 15
  if (ps_pglobal_lookup (&proc_handle, NULL, name, &addr) == PS_OK)
    {
      if (ps_pdwrite (&proc_handle, addr,
		      (gdb_ps_write_buf_t) value,
		      (gdb_ps_size_t) size) == PS_OK)
	return 0;
    }
  return -1;		/* fail */
}

/* Function: get_thread_signals

   Obtain the values of the "cancel", "restart" and "debug" signals
   used by LinuxThreads, and store them in a set of global variables
   for use by check_child_state and friends.
d1799 2
a1800 20
   Recent versions of NPTL don't define these symbols at all; you must
   use the libthread_db event functions instead (td_ta_event_addr,
   ...) to find out about thread creation, thread exits, and so on.

   Older versions of LinuxThreads provide both interfaces.  To avoid
   changing RDA's behavior on any system it supports, we use the older
   signal-based interface if present, and use the event-based
   interface as a fall-back.  */

static int cancel_signal;
static int restart_signal;
static int debug_signal;
static int got_thread_signals;

static void
get_thread_signals (void)
{
  int cancel, restart, debug, debug_flag;

  if (!got_thread_signals)
d1802 2
a1803 17
      if (get_target_int_by_name ("__pthread_sig_cancel", 
				  &cancel, sizeof (cancel)) == 0 &&
	  get_target_int_by_name ("__pthread_sig_restart",
				  &restart, sizeof (restart)) == 0 &&
	  get_target_int_by_name ("__pthread_sig_debug", 
				  &debug, sizeof (debug)) == 0)
	{
	  restart_signal = restart;
	  cancel_signal  = cancel;
	  debug_signal   = debug;
	  got_thread_signals = 1;
	}
      debug_flag = 1;
      set_target_int_by_name ("__pthread_threads_debug", 
			      &debug_flag, sizeof (debug_flag));
    }
}
d1805 2
a1806 2
/* Function: stop_thread 
   Use SIGSTOP to force a thread to stop. */
d1808 1
a1808 38
static void
stop_thread (struct gdbserv_thread *thread)
{
  if (thread->ti.ti_lid != 0)
    {
      if (stop_lwp (thread->ti.ti_lid) == 0)
	thread->stopped = 1;
      else
	thread->stopped = 0;
    }
}

/* Function: stop_all_threads
   Use SIGSTOP to make sure all child threads are stopped.
   Do not send SIGSTOP to the event thread, or to any 
   new threads that have just been attached. */

static void
stop_all_threads (struct child_process *process)
{
  struct gdbserv_thread *thread;

  for (thread = first_thread_in_list ();
       thread;
       thread = next_thread_in_list (thread))
    {
      if (thread->ti.ti_lid == process->pid)
	{
	  /* HACK mark him signalled. */
	  thread->stopped = 1;
	  continue;	/* This thread is already stopped. */
	}
      /* All threads must be stopped, unles
	 a) they have only just been attached, or 
	 b) they're already stopped. */
      if (!thread->attached && !thread->stopped &&
	  thread->ti.ti_state != TD_THR_ZOMBIE &&
	  thread->ti.ti_state != TD_THR_UNKNOWN)
d1810 3
a1812 1
	  stop_thread (thread);
a1813 2
    }
}
d1815 2
a1816 7
/* A list of signals that have been prematurely sucked out of the threads.
   Because of the complexities of linux threads, we must send SIGSTOP to
   every thread, and then call waitpid on the thread to retrieve the 
   SIGSTOP event.  Sometimes another signal is pending on the thread,
   and we get that one by mistake.  Throw all such signals into this
   list, and send them back to their respective threads once we're
   finished calling waitpid. */
d1818 4
a1821 29
static struct event_list {
  struct gdbserv_thread *thread;
  union wait waited;
  int selected;
} *pending_events;
static int pending_events_listsize;
static int pending_events_top;

/* Function: add_pending_event
   Helper function for wait_all_threads.

   When we call waitpid for each thread (trying to consume the SIGSTOP
   events that we sent from stop_all_threads), we sometimes inadvertantly
   get other events that we didn't send.  We pend these to a list, and 
   then resend them to the child threads after our own SIGSTOP events
   have been consumed.  

   This list will be used to choose which of the possible events 
   will be returned to the debugger by check_child_status. */

static void
add_pending_event (struct gdbserv_thread *thread, union wait waited)
{
  if (pending_events_top >= pending_events_listsize)
    {
      pending_events_listsize += 64;
      pending_events = 
	realloc (pending_events, 
		 pending_events_listsize * sizeof (*pending_events));
a1822 19
  pending_events [pending_events_top].thread = thread;
  pending_events [pending_events_top].waited = waited;
  pending_events [pending_events_top].selected = 0;
  pending_events_top ++;
}

/* Function: select_pending_event
   Helper function for wait_all_threads.

   Having collected a list of events from various threads, 
   choose one "favored event" to be returned to the debugger. */


static void
select_pending_event (struct child_process *process)
{
  int i = 0;
  int num_wifstopped_events = 0;
  int random_key;
d1824 2
a1825 1
  /* Select the event that will be returned to the debugger. */
d1827 2
a1828 4
  /* Selection criterion #0:
     If there are no events, don't do anything!  (paranoia) */
  if (pending_events_top == 0)
    return;
d1830 2
a1831 8
  /* Selection criterion #1: 
     If the thread pointer is null, then the thread library is
     not in play yet, so this is the only thread and the only event. */
  if (pending_events[0].thread == NULL)
    {
      i = 0;
      goto selected;
    }
d1833 1
a1833 55
  /* Selection criterion #2:
     Exit and terminate events take priority. */
  for (i = 0; i < pending_events_top; i++)
    if (WIFEXITED (pending_events[i].waited) ||
	WIFSIGNALED (pending_events[i].waited))
      {
	goto selected;
      }

  /* Selection criterion #3: 
     Give priority to a stepping SIGTRAP. */
  for (i = 0; i < pending_events_top; i++)
    if (pending_events[i].thread->stepping &&
	WIFSTOPPED (pending_events[i].waited) &&
	WSTOPSIG (pending_events[i].waited) == SIGTRAP)
      {
	/* We don't actually know whether this sigtrap was the result
	   of a singlestep, or of executing a trap instruction.  But
	   GDB has a better chance of figuring it out than we do. */
	goto selected;
      }

  /* Selection criterion #4:
     Count the WIFSTOPPED events and choose one at random. */
  for (i = 0; i < pending_events_top; i++)
    if (WIFSTOPPED (pending_events[i].waited))
      num_wifstopped_events ++;

  random_key = (int) 
    ((num_wifstopped_events * (double) rand ()) / (RAND_MAX + 1.0));

  for (i = pending_events_top - 1; i >= 0; i--)
    if (WIFSTOPPED (pending_events[i].waited))
      {
	if (random_key == --num_wifstopped_events)
	  {
	    goto selected;
	  }
	else if (WSTOPSIG (pending_events[i].waited) == SIGINT)
	  {
	    goto selected;	/* Give preference to SIGINT. */
	  }
      }

  /* Selection criterion #4 (should never get here):
     If all else fails, take the first event in the list. */
  i = 0;

 selected:	/* Got our favored event. */
  pending_events[i].selected = 1;
  process->event_thread = pending_events[i].thread;
  if (pending_events[i].thread)
    process->pid = pending_events[i].thread->ti.ti_lid;

  handle_waitstatus (process, pending_events[i].waited);
d1835 20
a1854 28
    fprintf (stderr, "<select_pending_event: pid %d '%c' %d>\n",
	    process->pid, process->stop_status, process->stop_signal);
  return;
}

/* Function: send_pending_signals
   Helper function for wait_all_threads.

   When we call waitpid for each thread (trying to consume the SIGSTOP
   events that we sent from stop_all_threads), we sometimes inadvertantly
   get other events that we didn't send.  We pend these to a list, and 
   then resend them to the child threads after our own SIGSTOP events
   have been consumed. 

   Some events in the list require special treatment:
    * One event is "selected" to be returned to the debugger. 
      Skip that one.
    * Trap events may represent breakpoints.  We can't just resend
      the signal.  Instead we must arrange for the breakpoint to be
      hit again when the thread resumes.  */

static void
send_pending_signals (struct child_process *process)
{
  int i;
  int signum;

  for (i = 0; i < pending_events_top; i++)
d1856 2
a1857 21
      if (WIFSTOPPED (pending_events[i].waited) &&
	  ! pending_events[i].selected)
	{
	  signum = WSTOPSIG (pending_events[i].waited);
	  if (signum == SIGTRAP &&
	      pending_events[i].thread->stepping == 0)
	    {
	      /* Breakpoint.  Push it back.  */
	      if (thread_db_noisy)
		fprintf (stderr, "<send_pending_events: pushing back SIGTRAP for %d>\n",
			pending_events[i].thread->ti.ti_lid);
	      decr_pc_after_break (process->serv,
	                           pending_events[i].thread->ti.ti_lid);
	    }
	  else /* FIXME we're letting SIGINT go thru as normal */
	    {
	      /* Put the signal back into the child's queue. */
	      kill (pending_events[i].thread->ti.ti_lid, 
		    WSTOPSIG (pending_events[i].waited));
	    }
	}
a1858 1
  pending_events_top = 0;
a1860 98
/* Function: wait_all_threads
   Use waitpid to close the loop on all threads that have been
   attached or SIGSTOP'd.  Skip the eventpid -- it's already been waited. 

   Special considerations:
     The debug signal does not go into the event queue, 
     does not get forwarded to the thread etc. */

static void
wait_all_threads (struct child_process *process)
{
  struct gdbserv_thread *thread;
  union  wait w;
  int    ret, stopsig;

  for (thread = first_thread_in_list ();
       thread;
       thread = next_thread_in_list (thread))
    {
      /* Special handling for the thread that has already been waited. */
      if (thread->ti.ti_lid == process->pid)
	{
	  /* HACK mark him waited. */
	  thread->waited = 1;
	  continue;
	}

      while ((thread->stopped || thread->attached) &&
	     !thread->waited)
	{
	  errno = 0;
	  ret = waitpid (thread->ti.ti_lid, (int *) &w, 
			 thread->ti.ti_lid == proc_handle.pid ? 0 : __WCLONE);
	  if (ret == -1)
	    {
	      if (errno == ECHILD)
		fprintf (stderr, "<wait_all_threads: %d has disappeared>\n", 
			thread->ti.ti_lid);
	      else
		fprintf (stderr, "<wait_all_threads: waitpid %d failed, '%s'>\n", 
			thread->ti.ti_lid, strerror (errno));
	      break;
	    }
	  if (WIFEXITED (w))
	    {
	      add_pending_event (thread, w);
	      fprintf (stderr, "<wait_all_threads: %d has exited>\n", 
		      thread->ti.ti_lid);
	      break;
	    }
	  if (WIFSIGNALED (w))
	    {
	      add_pending_event (thread, w);
	      fprintf (stderr, "<wait_all_threads: %d died with signal %d>\n", 
		      thread->ti.ti_lid, WTERMSIG (w));
	      break;
	    }
	  stopsig = WSTOPSIG (w);
	  switch (stopsig) {
	  case SIGSTOP:
	    /* This is the one we're looking for.
	       Mark the thread as 'waited' and move on to the next thread. */
#if 0 /* too noisy! */
	    if (thread_db_noisy)
	      fprintf (stderr, "<waitpid (%d, SIGSTOP)>\n", thread->ti.ti_lid);
#endif
	    thread->waited = 1;
	    break;
	  default:
	    if (stopsig == debug_signal)
	      {
		/* This signal does not need to be forwarded. */
		if (thread_db_noisy)
		  fprintf (stderr, "<wait_all_threads: ignoring SIGDEBUG (%d) for %d>\n",
			  debug_signal,
			  thread->ti.ti_lid);
	      }
	    else
	      {
		if (thread_db_noisy)
		  fprintf (stderr, "<wait_all_threads: stash sig %d for %d at 0x%08lx>\n",
			   stopsig, thread->ti.ti_lid,
			  (unsigned long) debug_get_pc (process->serv,
			                                thread->ti.ti_lid));
		add_pending_event (thread, w);
	      }
	  }

	  if (!thread->waited)	/* Signal was something other than STOP. */
	    {
	      /* Continue the thread so it can stop on the next signal. */
	      continue_lwp (thread->ti.ti_lid, 0);
	    }
	}
    }
  select_pending_event (process);
  send_pending_signals (process);
}
a1869 2
  /* Continue thread only if (a) it was just attached, or 
     (b) we stopped it and waited for it. */
d1871 2
a1872 5
    if (thread->attached || (thread->stopped && thread->waited))
      {
	continue_lwp (thread->ti.ti_lid, signal);
	thread->stopped = thread->attached = thread->waited = 0;
      }
a1875 21
/* Function: continue_all_threads 
   Send continue to all stopped or attached threads
   except the event thread (which will be continued separately). */

static void
continue_all_threads (struct gdbserv *serv)
{
  struct gdbserv_thread *thread;

  for (thread = first_thread_in_list ();
       thread;
       thread = next_thread_in_list (thread))
    {
      /* Send any newly attached thread the restart signal. */
      if (thread->attached)
	continue_thread (thread, restart_signal);
      else
	continue_thread (thread, 0);
    }
}

d1889 1
a1889 1
    continue_thread (process->event_thread, process->signal_to_send);
d1891 1
a1891 1
    continue_lwp (process->pid, process->signal_to_send);
d1897 1
a1897 1
  continue_all_threads (serv);
d1900 2
d1912 1
a1912 3
  singlestep_lwp (serv, thread->ti.ti_lid, signal);
  thread->stopped = thread->attached = thread->waited = 0;
  thread->stepping = 1;
d1931 1
a1931 1
    singlestep_lwp (serv, process->pid, process->signal_to_send);
d1937 1
a1937 1
  continue_all_threads (serv);		/* All but the event thread. */
d1940 2
d1977 5
d2016 4
d2042 13
d2082 10
a2091 6
      eventpid = waitpid (-1, (int *) &w, WNOHANG);
      /* If no event on main thread, check clone threads. 
         It doesn't matter what event we find first, since we now have
         a fair algorithm for choosing which event to handle next. */
      if (eventpid <= 0)
	eventpid = waitpid (-1, (int *) &w, WNOHANG | __WCLONE);
d2114 3
a2116 4
	  /* FIXME: this debugging output will be removed soon, but 
	     putting it here before the update_thread_list etc. is
	     bad from the point of view of synchronization. */
	  handle_waitstatus (process, w);
d2119 9
a2127 3
		     "<check_child_state: %d got '%c' - %d at 0x%08lx>\n", 
		     process->pid, process->stop_status, process->stop_signal,
		     debug_get_pc (process->serv, process->pid));
d2129 1
a2129 2
	  /* Update the thread list. */
	  update_thread_list ();
d2134 4
a2137 10
	  /* Put this child's event into the pending list. */
	  add_pending_event (thread_list_lookup_by_lid ((lwpid_t) eventpid), 
			     w);

	  stop_all_threads (process);
	  wait_all_threads (process);
	  /* Note: if more than one thread has an event ready to be
	     handled, wait_all_threads will have chosen one at random. */

	  if (got_thread_signals && process->stop_status == 'T')
d2139 3
a2141 2
	      /* Child stopped with a signal.  
		 See if it was one of our special signals. */
d2143 3
a2145 37
	      if (process->stop_signal == cancel_signal  ||	/* ignore */
		  process->stop_signal == restart_signal ||	/* ignore */
		  process->stop_signal == debug_signal   ||	/* ignore */
		  process->stop_signal == SIGCHLD)		/* ignore */
		{
		  /* Ignore this signal, restart the child. */
		  if (thread_db_noisy)
		    fprintf (stderr, "<check_child_state: ignoring signal %d for %d>\n",
			     process->stop_signal, process->pid);
		  if (process->stop_signal == debug_signal)
		    {
		      /* The debug signal arrives under two circumstances:
			 1) The main thread raises it once, upon the first call
			 to pthread_create.  This lets us detect the manager
			 thread.  The main thread MUST be given the restart
			 signal when this occurs. 
		         2) The manager thread raises it each time a new
			 child thread is created.  The child thread will be
			 in sigsuspend, and MUST be sent the restart signal.
			 However, the manager thread, which raised the debug
			 signal, does not need to be restarted.  

		         Sending the restart signal to the newly attached
		         child thread (which is not the event thread) is
		         handled in continue_all_threads.  */

		      if (process->pid == proc_handle.pid)  /* main thread */
			process->stop_signal = restart_signal;
		      else				/* not main thread */
			process->stop_signal = 0;
		    }
		  process->signal_to_send = process->stop_signal;
		  currentvec->continue_program (serv);
		  return 0;
		}
	    }
	  if (process->stop_status == 'W')
d2147 6
a2152 3
	      if (process->pid == proc_handle.pid)
		return 1;	/* Main thread exited! */
	      else
d2154 19
a2172 2
		  currentvec->continue_program (serv);
		  return 0;	/* Just a thread exit, don't tell GDB. */
d2174 3
a2180 4
	  /* This is the place to cancel its 'stepping' flag. */
	  if (process && process->event_thread)
	    process->event_thread->stepping = 0;

d2557 2
d2571 30
a2611 11
  else
    {
      /* KLUDGE: Insert some magic symbols into the cached symbol list,
	 to be looked up later.  This is badly wrong -- we should be 
	 obtaining these values thru the thread_db interface.  Their names
	 should not be hard-coded here <sob>. */
      add_symbol_to_list ("__pthread_sig_restart",   0, UNDEFINED);
      add_symbol_to_list ("__pthread_sig_cancel",    0, UNDEFINED);
      add_symbol_to_list ("__pthread_sig_debug",     0, UNDEFINED);
      add_symbol_to_list ("__pthread_threads_debug", 0, UNDEFINED);
    }
d2623 6
@


1.12
log
@	* td_thr_tls_get_addr_p): New static global.
	(thread_db_dlopen): Initialize ``td_thr_tls_get_addr_p''.
	(thread_db_get_gen): Add support for qGetTLSAddr packet.
@
text
@d29 1
d37 1
d871 1
a871 2
	  fprintf (stderr, "< -- failed, thread_agent = 0x%08x>\n", 
		   (long) thread_agent);
d1650 1
a1650 1
		  fprintf (stderr, "<wait_all_threads: stash sig %d for %d at 0x%08x>\n",
a1694 1
  struct child_process *process = gdbserv_target_data (serv);
a1695 1
  int signal;
d1924 2
a1925 1
	    fprintf (stderr, "<check_child_state: %d got '%c' - %d at 0x%08x>\n", 
d1927 1
a1927 1
		     (unsigned long) debug_get_pc (process->serv, process->pid));
a2040 1
  td_thrinfo_t   ti;
d2084 2
a2085 2
      fprintf (stderr, "<<< ERROR get_thread_reg map_id2thr %d >>>\n",
	       thread->ti.ti_tid);
d2100 2
a2101 2
	  fprintf (stderr, "<<< ERROR reg_from_fpregset %d %d>>>\n",
		   thread->ti.ti_tid, regnum);
d2140 2
a2141 2
	  fprintf (stderr, "<<< ERROR reg_from_xregset %d %d>>>\n",
		   thread->ti.ti_tid, regnum);
d2149 3
a2151 2
	  fprintf (stderr, "<<< ERROR get_thread_reg td_thr_getgregs %d >>>\n",
		   thread->ti.ti_tid);
d2157 2
a2158 2
	  fprintf (stderr, "<<< ERROR reg_from_gregset %d %d>>>\n", 
		   thread->ti.ti_tid, regnum);
d2222 2
a2223 2
      fprintf (stderr, "<<< ERROR set_thread_reg map_id2thr %d >>>\n",
	       thread->ti.ti_tid);
d2240 2
a2241 2
	  fprintf (stderr, "<<< ERROR reg_to_fpregset %d %d >>>\n",
		   thread->ti.ti_tid, regnum);
d2247 3
a2249 2
	  fprintf (stderr, "<<< ERROR set_thread_reg td_thr_setfpregs %d>>>\n",
		   thread->ti.ti_tid);
d2288 2
a2289 2
	  fprintf (stderr, "<<< ERROR reg_to_xregset %d %d >>>\n", 
		   thread->ti.ti_tid, regnum);
d2295 3
a2297 2
	  fprintf (stderr, "<<< ERROR set_thread_reg td_thr_setxregs %d >>>\n",
		   thread->ti.ti_tid);
d2306 3
a2308 2
	  fprintf (stderr, "<<< ERROR set_thread_reg td_thr_getgregs %d >>>\n",
		   thread->ti.ti_tid);
d2314 2
a2315 2
	  fprintf (stderr, "<<< ERROR reg_to_gregset %d %d >>>\n", 
		   thread->ti.ti_tid, regnum);
d2321 3
a2323 2
	  fprintf (stderr, "<<< ERROR set_thread_reg td_thr_setgregs %d >>>\n",
		   thread->ti.ti_tid);
a2342 1
  paddr_t dummy;
@


1.11
log
@	* thread-db.c (thread_db_get_thread_reg): Don't allow a successful
	return without first initializing ``reg''.
	(thread_db_set_thread_reg): Remove code intended to for
	thread_db_get_thread_reg().
@
text
@d378 3
d834 1
d1019 1
a1019 1
     qSymbol
d1131 59
@


1.10
log
@	* thread-db.c (thread_db_set_thread_reg): Don't allow a successful
	return without first initializing ``reg''.
@
text
@d1983 4
a2123 4
  /* Initialize reg to 0 in the event that we return early due to a
     register being unsupported.  */
  gdbserv_ulonglong_to_reg (serv, 0LL, reg);

@


1.9
log
@Use the libthread_db 'td_symbol_list' function to look up all the
symbols libthread_db will need when invited to by GDB.
* thread-db.c (add_symbol_to_list): Make 'name' argument const.
(td_symbol_list_p): New libthread_db function pointer.
(thread_db_dlopen): Initialize it.
(thread_db_attach): Use td_symbol_list to pre-load our symbol
cache with the names of all the symbols libthread_db will ever
request.
@
text
@d2120 4
@


1.9.2.1
log
@Add an architecture object to the Unix server.
* arch.h: New header file.
* server.h (struct arch): New forward struct declaration.
(struct child_process): Add an 'arch' member to the process.
* thread-db.c: #include arch.h.
* linux-target.c: #include arch.h.
(allocate_empty_arch): New function.
(x86_make_arch): New function.
(MAKE_ARCH): New #definition.
(linux_attach): Initialize process's architecture.

Provide arch-independent framework for breakpoints.
* server.h (struct arch_bp_table): New forward struct declaration.
(struct child_process): New member: 'breakpoint_table'.
* linux-target.c (linux_attach): Initialize process's breakpoint
table, if the architecture defines a breakpoint table constructor.
* arch.h (struct arch): Add fields pointing to breakpoint functions.

Provide a module implementing breakpoints for architectures that
support a simple software breakpoint model ("patch these bytes
into the instruction stream").
* stock-breakpoints.h, stock-breakpoints.c: New files.
* linux-target.c: If STOCK_BREAKPOINTS is #defined, then #include
"stock-breakpoints.h".
* Makefile.am (EXTRA_rda_SOURCES): Add stock-breakpoints.c.
* Makefile.in: Updated.

Define x86 breakpoint functions using the stock-breakpoints.c
model.
* configure.in: When configuring for an x86 target, include
stock-breakpoints.o in the mix, and #define STOCK_BREAKPOINTS.
* configure: Regenerated.
* config.in (STOCK_BREAKPOINTS): Provide #definition template.
* linux-target.c (stock_table_to_x86, x86_table_to_stock,
stock_bp_to_x86, x86_bp_to_stock, x86_make_bp_table, x86_set_bp,
x86_delete_bp, x86_bp_hit_p): New functions.
(x86_make_arch): Register the latter four as our breakpoint
methods.

Use the libthread_db event interface to communicate with the
thread library, if the old signal-based interface is not
supported.
* thread-db.c: #include <assert.h>.
(thread_db_event_str): New function.
(get_target_int_by_name, set_target_int_by_name, get_thread_signals)
(cancel_signal, restart_signal, debug_signal): Move these to just
before thread_db_dlopen; get_thread_signals is a subroutine of that.
(using_thread_db_events, create_notification, death_notification,
create_event_breakpoint, death_event_breakpoint): New global vars.
(get_event_notification, set_event_breakpoint)
(insert_thread_db_event_breakpoints)
(delete_thread_db_event_breakpoints, request_thread_db_events)
(hit_thread_db_event_breakpoint): New functions.
(thread_db_open): Call get_thread_signals, and if that fails, call
request_thread_db_events.
(struct event_list): Add 'thread_db_event' member.
(add_pending_event): Initialize it.
(delete_pending_event, handle_thread_db_events): New functions.
(find_new_threads_callback): If we're using the event interface,
enable event reporting on each new thread we find.
(select_pending_event): Return a value to indicate whether we
selected any event at all.
(continue_all_threads): Send a restart signal only if we're using
the signal-based interface.
(thread_db_check_child_state): If we're using the libthread_db
event interface to communicate with the inferior thread library,
check for those events here.  If select_pending_event says it
didn't find anything interesting, that means we consumed all the
reportable events; continue the program silently.
* ptrace-target.c: #include <sys/types.h> and <linux/unistd.h>.
(tkill): Generate code for this syscall.
(stop_lwp): Use tkill instead of kill.

* thread-db.c (thread_db_check_child_state): Call stop_all_threads
before calling update_thread_list, so RDA will have to compete for
CPU with fewer running threads.

* thread-db.c (wait_all_threads): Move calls to
select_pending_event and send_pending_signals from here...
(thread_db_check_child_state): To here.

* thread-db.c (ignore_thread_signal): New function.
(thread_db_check_child_state): Call it, instead of writing it out.

* thread-db.c (thread_db_open): Return 0 on success, -1 on
failure, like most of the other int-valued functions in this file,
and like most system calls.

* thread-db.c (struct gdbserv_thread): Doc fixes.

* thread-db.c: #include "gdbserv-utils.h", to get prototypes for
the 'struct gdbserv_reg' manipulation functions.

* thread-db.c (thread_db_noisy): Initialize to 1.

* thread-db.c (thread_debug_name): New function.
(find_new_threads_callback): If noisy, report new threads.
(stop_thread): If noisy, report stopping threads.
(select_pending_event): If noisy, report what we selected.
(wait_all_threads): If noisy, report before each thread we wait
for.

* thread-db.c (stop_all_threads): Doc fixes.

* aclocal.m4: Regenerated.
@
text
@a33 1
#include <assert.h>
a36 1
#include "gdbserv-utils.h"
a37 1
#include "arch.h"
d42 1
a42 1
int thread_db_noisy = 1;
a183 3

  /* True if we have attached to this thread, but haven't yet
     continued or single-stepped it.  */
a184 4

  /* True if we have sent this thread a SIGSTOP (because some other
     thread has had something interesting happen, and we want the
     whole program to stop), but not yet continued or single-stepped it.  */
a185 3

  /* True if we have called waitpid, and consumed any extraneous wait
     statuses created by attaching, stopping, etc.  */
a186 4

  /* True if we last single-stepped this thread, instead of continuing
     it.  When choosing one event out of many to report to GDB, we
     give stepped events higher priority than some others.  */
a280 15
/* Return a pointer to a statically allocated string describing
   THREAD.  For debugging.  */
static const char *
thread_debug_name (struct gdbserv_thread *thread)
{
  if (thread)
    {
      static char buf[50];
      sprintf (buf, "(%p %d)", thread, thread->ti.ti_lid);
      return buf;
    }
  else
    return "(null thread)";
}

a450 25

/* Return a string naming the event type EVENT.  */
static const char *
thread_db_event_str (td_event_e event)
{
  switch (event) {
  case TD_READY:		return "TD_READY";
  case TD_SLEEP:		return "TD_SLEEP";
  case TD_SWITCHTO:		return "TD_SWITCHTO";
  case TD_SWITCHFROM:		return "TD_SWITCHFROM";
  case TD_LOCK_TRY:		return "TD_LOCK_TRY";
  case TD_CATCHSIG:		return "TD_CATCHSIG";
  case TD_IDLE:			return "TD_IDLE";
  case TD_CREATE:		return "TD_CREATE";
  case TD_DEATH:		return "TD_DEATH";
  case TD_PREEMPT:		return "TD_PREEMPT";
  case TD_PRI_INHERIT:		return "TD_PRI_INHERIT";
  case TD_REAP:			return "TD_REAP";
  case TD_CONCURRENCY:		return "TD_CONCURRENCY";
  case TD_TIMEOUT:		return "TD_TIMEOUT";
  default:                      return "<unknown>";
  }
}


a744 333

/* Function: get_target_int_by_name
   Read the value of a target integer, given its name and size.
   Returns -1 for failure, zero for success. */

static int
get_target_int_by_name (char *name, void *value, int size)
{
  paddr_t addr;

  if (ps_pglobal_lookup (&proc_handle, NULL, name, &addr) == PS_OK)
    {
      if (ps_pdread (&proc_handle, addr,
		     (gdb_ps_read_buf_t) value,
		     (gdb_ps_size_t) size) == PS_OK)
	return 0;
    }
  return -1;		/* fail */
}

/* Function: set_target_int_by_name
   Read the value of a target integer, given its name and size.
   Returns -1 for failure, zero for success. */

static int
set_target_int_by_name (char *name, void *value, int size)
{
  paddr_t addr;

  if (ps_pglobal_lookup (&proc_handle, NULL, name, &addr) == PS_OK)
    {
      if (ps_pdwrite (&proc_handle, addr,
		      (gdb_ps_write_buf_t) value,
		      (gdb_ps_size_t) size) == PS_OK)
	return 0;
    }
  return -1;		/* fail */
}

/* Function: get_thread_signals

   Obtain the values of the "cancel", "restart" and "debug" signals
   used by LinuxThreads, and store them in a set of global variables
   for use by check_child_state and friends.

   Return 0 for success: we obtained the signal numbers and enabled
   debugging in the thread library.  Return -1 for failure.

   Recent versions of NPTL don't define these symbols at all; you must
   use the libthread_db event functions instead (td_ta_event_addr,
   ...) to find out about thread creation, thread exits, and so on.

   Older versions of LinuxThreads provide both interfaces.  To avoid
   changing RDA's behavior on any system it supports, we use the older
   signal-based interface if present, and use the event-based
   interface as a fall-back.  */

static int cancel_signal;
static int restart_signal;
static int debug_signal;
static int got_thread_signals;

static int
get_thread_signals (void)
{
  int cancel, restart, debug;

  /* If we've already gotten the thread signals, that's great.  */
  if (got_thread_signals)
    return 0;

  if (get_target_int_by_name ("__pthread_sig_cancel", 
			      &cancel, sizeof (cancel)) == -1
      || get_target_int_by_name ("__pthread_sig_restart",
				 &restart, sizeof (restart)) == -1
      || get_target_int_by_name ("__pthread_sig_debug", 
				 &debug, sizeof (debug)) == -1)
    return -1;

  restart_signal = restart;
  cancel_signal  = cancel;
  debug_signal   = debug;

  got_thread_signals = 1;

  {
    static int debug_flag = 1;
    set_target_int_by_name ("__pthread_threads_debug", 
			    &debug_flag, sizeof (debug_flag));
  }

  return 0;
}


/* Return true if PROCESS stopped for a libpthread-related signal that
   should not be reported to GDB.  */
static int
ignore_thread_signal (struct child_process *process)
{
  if (process->stop_status == 'T')
    /* Child stopped with a signal.  
       See if it was one of our special signals. */
    return (process->stop_signal == cancel_signal  ||	/* ignore */
	    process->stop_signal == restart_signal ||	/* ignore */
	    process->stop_signal == debug_signal   ||	/* ignore */
	    process->stop_signal == SIGCHLD);		/* ignore */

  return 0;
}


/* NPTL and later versions of LinuxThreads support a set of "event"
   functions for notifying the debugger of interesting events that
   have taken place in the thread library, like thread creation and
   thread death.

   There are three steps to using this interface:

   - First, the debugger asks libthread_db how a given event will be
     reported; libthread_db fills in a 'td_notify_t' structure whose
     'type' says how.  The debuggee may call functions on which the
     debugger can set breakpoints (type == NOTIFY_BPT), hit breakpoint
     instructions hard-coded into the program (type == NOTIFY_AUTOBPT),
     or perform system calls to indicate that an event has occurred
     (type == NOTIFY_SYSCALL).

   - Second, the debugger tells libthread_db which events it's
     interested in.  It can ask to be notified when a given event
     occurs in any thread, or when a given event occurs in a given
     thread.

   - Finally, the debugger watches for the given event to occur.

   We make a few simplifications here:

   - NPTL and LinuxThreads only actually use one kind of event
     notification: calling a function on which the debugger can set a
     breakpoint (NOTIFY_BPT).  So although, strictly speaking, the
     thread library could notify us in other ways, we only support
     NOTIFY_BPT.

   - NPTL and LinuxThreads only support a few kinds of events:
     TD_CREATE (a new thread has been created), TD_DEATH (a thread has
     exited), and TD_REAP (not sure).  We are only interested in
     TD_CREATE and TD_DEATH.  */

/* Ideally, these would be members of some structure somewhere, and
   not global variables, but that's how this file is written.  */

/* True if we're using libthread_db events.  */
int using_thread_db_events;

/* How we are notified of thread creation and death.  */
static td_notify_t create_notification, death_notification;

/* Breakpoints set at the addresses indicated by create_notification
   and death_notification.  These are raw arch breakpoints, so we have
   to delete them to step over them; the objects here will generally
   get regenerated every time we receive an event.  */
static struct arch_bp *create_event_breakpoint;
static struct arch_bp *death_event_breakpoint;
  

/* Set NOTIFICATION to the notification method for EVENT, and check
   that it uses NOTIFY_BPT notification.  Return -1 for failure, zero
   for success.  */
static int
get_event_notification (td_event_e event, td_notify_t *notification)
{
  td_err_e ret = td_ta_event_addr_p (thread_agent, event, notification);
  if (ret != TD_OK)
    {
      if (thread_db_noisy)
	fprintf (stderr, "td_ta_event_addr (%s) -> %s\n",
		 thread_db_event_str (event),
		 thread_db_err_str (ret));
      return -1;
    }

  if (notification->type != NOTIFY_BPT)
    {
      if (thread_db_noisy)
	fprintf (stderr, "notification for %s is not NOTIFY_BPT\n",
		 thread_db_event_str (event));
      return -1;
    }

  return 0;
}


/* Insert a breakpoint in SERV at the address given by NOTIFICATION.
   Return NULL for failure, or the breakpoint for success.  */
static struct arch_bp *
set_event_breakpoint (struct gdbserv *serv, td_notify_t *notification)
{
  struct child_process *process = gdbserv_target_data (serv);
  struct gdbserv_reg addr;

  /* Use the widest type for the conversion, just in case.  */
  gdbserv_ulonglong_to_reg (serv, (paddr_t) notification->u.bptaddr,
			    &addr);
  
  return process->arch->set_bp (process->breakpoint_table, &addr);
}


/* Insert breakpoints at all functions needed for communication with
   the underlying thread library.  Return 0 for success, -1 for
   failure.  */
static int
insert_thread_db_event_breakpoints (struct gdbserv *serv)
{
  struct child_process *process = gdbserv_target_data (serv);

  create_event_breakpoint = set_event_breakpoint (serv, &create_notification);
  death_event_breakpoint  = set_event_breakpoint (serv, &death_notification);

  if (! create_event_breakpoint || ! death_event_breakpoint)
    {
      if (create_event_breakpoint)
	process->arch->delete_bp (create_event_breakpoint);
      if (death_event_breakpoint)
	process->arch->delete_bp (death_event_breakpoint);
      create_event_breakpoint = death_event_breakpoint = 0;
      return -1;
    }

  return 0;
}


/* Remove breakpoints from all libthread_db event notification
   addresses.  Return 0 for success, -1 for failure.  */
static int
delete_thread_db_event_breakpoints (struct gdbserv *serv)
{
  struct child_process *process = gdbserv_target_data (serv);
  int create_ret, death_ret;

  create_ret = process->arch->delete_bp (create_event_breakpoint);
  death_ret = process->arch->delete_bp (death_event_breakpoint);

  create_event_breakpoint = death_event_breakpoint = 0;

  if (create_ret == 0 && death_ret == 0)
    return 0;
  else
    return -1;
}


/* If we don't have event set manipulation macros, then we can't use
   the event interface.  */
#if defined (td_event_emptyset)

/* Tell the program being debugged by SERV to notify us of thread
   creation and death.  Return -1 for failure, zero for success.  */
static int
request_thread_db_events (struct gdbserv *serv)
{
  struct child_process *process = gdbserv_target_data (serv);

  /* If we don't have the libthread_db functions we need, then we
     can't use the event interface.  */
  if (! td_ta_event_addr_p
      || ! td_ta_event_getmsg_p
      || ! td_thr_event_enable_p
      || ! td_ta_set_event_p)
    return -1;

  /* If we don't have an architecture object, then we don't know how
     to insert breakpoints, even if our thread library supports the
     event interface.  */
  if (! process->arch
      || ! process->breakpoint_table)
    return -1;

  /* Get the notification addresses for TD_CREATE and TD_DEATH,
     and ensure that they use NOTIFY_BPT notification.  */
  if (get_event_notification (TD_CREATE, &create_notification) == -1
      || get_event_notification (TD_DEATH,  &death_notification) == -1)
    return -1;

  insert_thread_db_event_breakpoints (serv);

  /* Tell the thread library to send us those events.  */
  {
    td_thr_events_t events;
    td_err_e err;

    /* The td_event_ thingies are all documented to be macros.  So we
       don't need to access them via pointers.  */
    td_event_emptyset (&events);
    td_event_addset (&events, TD_CREATE);
    td_event_addset (&events, TD_DEATH);
    err = td_ta_set_event_p (thread_agent, &events);
    if (err != TD_OK)
      fprintf (stderr, "couldn't set global event mask: %s",
	       thread_db_err_str (err));
  }

  using_thread_db_events = 1;
  return 0;
}

#else /* ! defined (td_event_emptyset) */

/* td_event_emptyset is not defined, so we can't use the event
   interface.  */
static int
request_thread_db_events (struct gdbserv *serv)
{
  return -1;
}

#endif /* ! defined (td_event_emptyset) */


/* Return non-zero if BREAKPOINT is a libthread_db event breakpoint,
   zero otherwise.  */
static int
hit_thread_db_event_breakpoint (struct gdbserv *serv,
				struct gdbserv_thread *thread)
{
  struct child_process *process = gdbserv_target_data (serv);

  return (process->arch->bp_hit_p (thread, create_event_breakpoint)
	  || process->arch->bp_hit_p (thread, death_event_breakpoint));
}


d837 1
a837 1
   Returns: 0 for success, -1 for failure
d853 1
a853 11
  /* If we already have a thread agent, we're all set.  */
  if (thread_agent)
    return 0;

  /* Have the proc service handle point back to our serv object and
     the target's overall pid. */
  proc_handle.pid = pid;
  proc_handle.serv = serv;
      
  ret = td_ta_new_p (&proc_handle, &thread_agent);
  if (ret != TD_OK)
d855 2
a856 3
      if (thread_db_noisy)
	fprintf (stderr, "< -- failed, thread_agent = 0x%08x>\n", 
		 (long) thread_agent);
d858 11
a868 1
      return -1;		/* failure */
d870 1
a870 14

  /* All LinuxThreads versions support the signal-based debugging
     interface.  Newer versions of LinuxThreads also provide the
     event-based debugging interface.  NPTL has only ever supported
     the event-based debugging interface.  Prefer the signal-based
     interface to the event-based interface, to leave behavior on
     older systems unchanged.  */
  if (get_thread_signals () == 0)
    return 0;

  if (request_thread_db_events (serv) == -1)
    return 0;

  return -1;
a872 1

a932 4

	  if (thread_db_noisy)
	    fprintf (stderr, "(new thread %s)\n", thread_debug_name (thread));

a938 9

	  if (using_thread_db_events)
	    {
	      /* Enable event reporting in this thread.  */
	      if (td_thr_event_enable_p (thandle, 1) != TD_OK)
		fprintf (stderr, "couldn't enable event reporting "
			 "in thread %d\n",
			 ti.ti_lid);
	    }
d1192 83
a1282 2
      if (thread_db_noisy)
	fprintf (stderr, "(stop thread %s)\n", thread_debug_name (thread));
d1306 1
a1306 7
	  /* HACK: mark him stopped.
	     It would make more sense to do this in
	     thread_db_check_child_state, where we received his
	     waitstatus and thus know he's stopped.  But that code is
	     also used when we don't have a thread list yet, so the
	     'struct gdbserv_thread' whose 'stopped' flag we want to
	     set may not exist.  */
d1310 1
a1310 1
      /* All threads must be stopped, unless
d1316 3
a1318 1
	stop_thread (thread);
a1333 1
  int thread_db_event;
a1362 1
  pending_events [pending_events_top].thread_db_event = 0;
a1365 26

/* Delete the I'th pending event.  This will reorder events at indices
   I and higher, but not events whose indices are less than I.

   This function runs in constant time, so you can iterate through the
   whole pending event pool by deleting events as you process them.
   But the nice thing about this function is that you can also handle
   only selected events, and leave others for later.  */
static void
delete_pending_event (int i)
{
  /* You shouldn't ask to delete an event that's not actually in the
     list.  */
  assert (i <= i && i < pending_events_top);

  /* Copy the last element down into this element's position, unless
     this is the last element itself.  */
  if (i < pending_events_top - 1)
    pending_events[i] = pending_events[pending_events_top - 1];

  /* Now the deleted space is at the end of the array.  So just
     decrement the top pointer, and we're done.  */
  pending_events_top--;
}


d1367 1
a1367 1
   Helper function for thread_db_check_child_state.
d1370 1
a1370 1
   choose one "favored event" to be returned to the debugger.
a1371 2
   Return non-zero if we selected an event, or zero if we couldn't
   find anything interesting to report.  */
d1373 1
a1373 2

static int
d1385 1
a1385 5
    {
      if (thread_db_noisy)
	fprintf (stderr, "(selected nothing)\n");
      return 0;
    }
a1444 5

  if (thread_db_noisy)
    fprintf (stderr, "(selected %s)\n",
	     thread_debug_name (pending_events[i].thread));

d1454 1
a1454 1
  return 1;
d1458 1
a1458 1
   Helper function for thread_db_check_child_state.
a1536 3
	  if (thread_db_noisy)
	    fprintf (stderr, "(waiting for %s)\n",
		     thread_debug_name (thread));
d1543 1
a1543 1
			 thread->ti.ti_lid);
d1546 1
a1546 1
			 thread->ti.ti_lid, strerror (errno));
d1553 1
a1553 1
		       thread->ti.ti_lid);
d1560 1
a1560 1
		       thread->ti.ti_lid, WTERMSIG (w));
d1572 1
a1572 1
	      thread->waited = 1;
d1580 2
a1581 2
			   debug_signal,
			   thread->ti.ti_lid);
d1588 2
a1589 2
			   (unsigned long) debug_get_pc (process->serv,
							 thread->ti.ti_lid));
d1601 2
a1604 116

/* Scan the list for threads that have stopped at libthread_db event
   breakpoints, process the events they're reporting, and step the
   threads past the breakpoints, updating the pending_events
   table.

   This function assumes that all threads have been stopped.  */
static void
handle_thread_db_events (struct child_process *process)
{
  struct gdbserv *serv = process->serv;
  int i;
  int any_events;

  /* Are there any threads at all stopped at libthread_db event
     breakpoints?  */
  any_events = 0;
  for (i = 0; i < pending_events_top; i++)
    {
      struct event_list *e = &pending_events[i];
      if (e->thread
	  && WIFSTOPPED (e->waited)
	  && WSTOPSIG (e->waited) == SIGTRAP
	  && hit_thread_db_event_breakpoint (serv, e->thread))
	{
	  any_events = 1;
	  e->thread_db_event = 1;
	}
    }

  if (! any_events)
    return;

  /* Consume events.  */
  for (;;)
    {
      td_event_msg_t msg;
      td_err_e status = td_ta_event_getmsg_p (thread_agent, &msg);

      if (status == TD_NOMSG)
	break;

      if (status != TD_OK)
	{
	  fprintf (stderr, "error getting thread messages: %s\n",
		   thread_db_err_str (status));
	  break;
	}

      /* The only messages we're concerned with are TD_CREATE and
	 TD_DEATH.  But since we call update_thread_list every time
	 thread_db_check_child_state gets a wait status from waitpid,
	 our list is always up to date, so we don't actually need to
	 do anything with these messages.

	 (Ignore the question, for now, of how RDA loses when threads
	 spawn off new threads after we've updated our list, but
	 before we've managed to send each of the threads on our list
	 a SIGSTOP.)  */
    }

  /* Disable the event breakpoints while we step the threads across
     them.  */
  delete_thread_db_event_breakpoints (serv);

  for (i = 0; i < pending_events_top;)
    {
      struct event_list *e = &pending_events[i];
      if (e->thread_db_event)
	{
	  struct gdbserv_thread *thread = e->thread;
	  lwpid_t lwp = thread->ti.ti_lid;
	  union wait w;

	  /* Delete this pending event.  If appropriate, we'll add a
	     new pending event below, but if stepping across the event
	     breakpoint is successful, then this pending event, at
	     least, has been addressed.  */
	  delete_pending_event (i);

	  /* Back up the thread, if needed.  */
	  decr_pc_after_break (serv, lwp);

	  /* Single-step the thread across the breakpoint.  */
	  singlestep_lwp (serv, lwp, 0);

	  /* Get a new status for that thread.  */
	  if (thread_db_noisy)
	    fprintf (stderr, "(waiting after event bp step %s)\n",
		     thread_debug_name (thread));
	  if (waitpid (lwp, (int *) &w, lwp == proc_handle.pid ? 0 : __WCLONE)
	      < 0)
	    fprintf (stderr, "error waiting for thread %d after "
		     "stepping over event breakpoint:\n%s",
		     lwp, strerror (errno));
	  else
	    {
	      /* If the result is a SIGTRAP signal, then that means
		 the single-step proceeded normally.  Otherwise, it's
		 a new pending event.  */
	      if (WIFSTOPPED (w)
		  && WSTOPSIG (w) == SIGTRAP)
		;
	      else
		add_pending_event (thread, w);
	    }
	}
      else
	i++;
    }

  /* Re-insert the event breakpoints.  */
  insert_thread_db_event_breakpoints (serv);
}


d1639 2
a1640 3
      /* If we're using signals to communicate with the thread
	 library, send any newly attached thread the restart signal. */
      if (got_thread_signals && thread->attached)
a1837 2
	  int selected_anything;

d1862 1
a1862 1
	    fprintf (stderr, "\n<check_child_state: %d got '%c' - %d at 0x%08x>\n", 
a1864 4
	  /* It shouldn't hurt to call this twice.  But if there are a
	     lot of other threads running, it can take a *long* time
	     for the thread list update to complete.  */
	  stop_all_threads (process);
a1877 14
	  if (using_thread_db_events)
	    handle_thread_db_events (process);
	  selected_anything = select_pending_event (process);
	  send_pending_signals (process);

	  /* If there weren't any pending events to report, then
	     continue the program, and let the main loop know that
	     nothing interesting happened.  */
	  if (! selected_anything)
	    {
	      currentvec->continue_program (serv);
	      return 0;
	    }

d1881 1
a1881 1
	  if (got_thread_signals && ignore_thread_signal (process))
d1883 7
a1889 5
	      /* Ignore this signal, restart the child. */
	      if (thread_db_noisy)
		fprintf (stderr, "<check_child_state: ignoring signal %d for %d>\n",
			 process->stop_signal, process->pid);
	      if (process->stop_signal == debug_signal)
d1891 29
a1919 19
		  /* The debug signal arrives under two circumstances:
		     1) The main thread raises it once, upon the first call
		     to pthread_create.  This lets us detect the manager
		     thread.  The main thread MUST be given the restart
		     signal when this occurs. 
		     2) The manager thread raises it each time a new
		     child thread is created.  The child thread will be
		     in sigsuspend, and MUST be sent the restart signal.
		     However, the manager thread, which raised the debug
		     signal, does not need to be restarted.  

		     Sending the restart signal to the newly attached
		     child thread (which is not the event thread) is
		     handled in continue_all_threads.  */

		  if (process->pid == proc_handle.pid)  /* main thread */
		    process->stop_signal = restart_signal;
		  else				/* not main thread */
		    process->stop_signal = 0;
a1920 3
	      process->signal_to_send = process->stop_signal;
	      currentvec->continue_program (serv);
	      return 0;
a1921 1

@


1.9.2.2
log
@* linux-target.c (linux_set_reg): Delete unused variables.
* ptrace-target.c (ptrace_read_user, ptrace_check_child_state):
Same.
* thread-db.c (continue_all_threads, thread_db_attach): Same.
@
text
@d2129 1
d2131 1
d2783 1
@


1.9.2.3
log
@* linux-target.c (decr_pc_after_break): Fix printf format
directive to match arguments.
* ptrace-target.c (ptrace_singlestep_program): Same.
(ptrace_continue_program): Same.
* server.c (invalid_speed): Same.
* thread-db.c (thread_db_open, wait_all_threads)
(thread_db_check_child_state, thread_db_get_thread_reg)
(thread_db_set_thread_reg): Same.
@
text
@d1256 2
a1257 1
	fprintf (stderr, "< -- failed, thread_agent = %p>\n", thread_agent);
d1970 1
a1970 1
		  fprintf (stderr, "<wait_all_threads: stash sig %d for %d at 0x%08lx>\n",
d2361 1
a2361 2
	    fprintf (stderr,
		     "\n<check_child_state: %d got '%c' - %d at 0x%08lx>\n", 
d2527 2
a2528 2
      fprintf (stderr, "<<< ERROR get_thread_reg map_id2thr %lu >>>\n",
	       (unsigned long) thread->ti.ti_tid);
d2543 2
a2544 2
	  fprintf (stderr, "<<< ERROR reg_from_fpregset %lu %d>>>\n",
		   (unsigned long) thread->ti.ti_tid, regnum);
d2583 2
a2584 2
	  fprintf (stderr, "<<< ERROR reg_from_xregset %lu %d>>>\n",
		   (unsigned long) thread->ti.ti_tid, regnum);
d2592 2
a2593 3
	  fprintf (stderr,
		   "<<< ERROR get_thread_reg td_thr_getgregs %lu >>>\n",
		   (unsigned long) thread->ti.ti_tid);
d2599 2
a2600 2
	  fprintf (stderr, "<<< ERROR reg_from_gregset %lu %d>>>\n", 
		   (unsigned long) thread->ti.ti_tid, regnum);
d2664 2
a2665 2
      fprintf (stderr, "<<< ERROR set_thread_reg map_id2thr %lu >>>\n",
	       (unsigned long) thread->ti.ti_tid);
d2682 2
a2683 2
	  fprintf (stderr, "<<< ERROR reg_to_fpregset %lu %d >>>\n",
		   (unsigned long) thread->ti.ti_tid, regnum);
d2689 2
a2690 3
	  fprintf (stderr,
		   "<<< ERROR set_thread_reg td_thr_setfpregs %lu>>>\n",
		   (unsigned long) thread->ti.ti_tid);
d2729 2
a2730 2
	  fprintf (stderr, "<<< ERROR reg_to_xregset %lu %d >>>\n", 
		   (unsigned long) thread->ti.ti_tid, regnum);
d2736 2
a2737 3
	  fprintf (stderr,
		   "<<< ERROR set_thread_reg td_thr_setxregs %lu >>>\n",
		   (unsigned long) thread->ti.ti_tid);
d2746 2
a2747 3
	  fprintf (stderr,
		   "<<< ERROR set_thread_reg td_thr_getgregs %lu >>>\n",
		   (unsigned long) thread->ti.ti_tid);
d2753 2
a2754 2
	  fprintf (stderr, "<<< ERROR reg_to_gregset %lu %d >>>\n", 
		   (unsigned long) thread->ti.ti_tid, regnum);
d2760 2
a2761 3
	  fprintf (stderr,
		   "<<< ERROR set_thread_reg td_thr_setgregs %lu >>>\n",
		   (unsigned long) thread->ti.ti_tid);
@


1.9.2.4
log
@* stock-breakpoints.c: #include all headers necessary to get
prototypes for functions used in this file.
* thread-db.c: Same.
@
text
@a28 1
#include <string.h>
@


1.9.2.5
log
@* stock-breakpoints.c: #include all headers necessary to get
prototypes for functions used in this file.
* thread-db.c: Same.
@
text
@d2488 1
@


1.9.2.6
log
@* thread-db.c (delete_pending_event): Fix bounds-check assertion.
@
text
@d1722 1
a1722 1
  assert (0 <= i && i < pending_events_top);
@


1.9.2.7
log
@Separate management of kernel-level LWPs from that of libpthread /
libthread_db-level threads.
* lwp-pool.c, lwp-pool.h: New files.
* thread-db.c: #include "lwp-ctrl.h" and "lwp-pool.h".
(struct gdbserv_thread): Delete members 'attached', 'stopped',
'waited', and 'stepping'.  This structure is now just a
'td_thrinfo_t' and a list link.  Describe some quirks in the
meanings of certain 'ti' fields.
(thread_list_lookup_by_lid): Move later in file, so we can use
information directly from our proc handle.  Be skeptical of ZOMBIE
or UNKNOWN threads whose LWP ID is equal to the PID in the proc
handle.
(thread_debug_name): Move later in file, so we can use
thread_db_state_str.
(attach_thread): Use lwp pool functions to attach.  Attach to
zombies.  When using signal-based communication, send the thread
the restart signal immediately.
(find_new_threads_callback): Go ahead and attach to all threads.
The LWP pool functions tolerate attaching to a given LWP more than
once.
(update_thread_list): Take the process as an argument.  If the
focus thread has disappeared, set process->focus_thread to NULL.
(thread_db_thread_next): Pass the process to update_thread_list.
(stop_thread, stop_all_threads, add_pending_event,
delete_pending_event, select_pending_event, send_pending_signals,
wait_all_threads, continue_all_threads): Deleted.
(handle_thread_db_event): Renamed from handle_thread_db_events.
Take the process structure as an argument, and check only for a
thread-db event notification from process->event_thread.  Use LWP
pool functions.
(continue_thread, singlestep_thread): Use LWP pool functions.
(thread_db_continue_program, thread_db_singlestep_program,
thread_db_continue_thread, thread_db_singlestep_thread): Use LWP
pool functions, and update process->focus_thread appropriately.
(thread_db_check_child_state): Use the LWP pool functions.  Rather
than stopping all LWP's, choosing the most interesting events, and
then arranging to re-create all the other wait statuses we got,
just pick the first event we get from lwp_pool_waitpid (either on
the focus thread, if there is one, or on any thread) and report
that.  Use the new handle_thread_db_event function.
(struct event_list, pending_events, pending_events_listsize,
pending_events_top): Deleted; replaced by LWP pool code.
(thread_db_attach): Tell the LWP pool about the PID we're
attaching to.  Clear the focus thread.
* server.h (struct process): New member: 'focus_thread'.
* gdbserv-thread-db.h (continue_lwp, singlestep_lwp, attach_lwp,
stop_lwp): Move declarations from here...
* lwp-ctrl.h: ... to here.  New file.
(kill_lwp): Renamed from stop_lwp; allow caller to specify any
signal.
* ptrace-target.c: #include "lwp-ctrl.h".
(continue_lwp, singlestep_lwp, attach_lwp, stop_lwp): Move
function comments to lwp-ctrl.h, and expand.
* configure.in: Whenever we select 'thread-db.o', select
'lwp-pool.o' as well.
* configure: Regenerated.

* thread-db.c (thread_db_check_child_state): Remove extraneous
call to handle_waitstatus.  Remove extra check for exited main
thread.

* thread-db.c (thread_db_thread_info): List the type and state
before the PID, and mention whether the LWP's PID is equal to that
of the main thread, since ZOMBIE and UNKNOWN threads whose LWP's
PID is equal are probably actually exited threads.

* thread-db.c (add_thread_to_list): Zero out entire structure.

* thread-db.c (thread_db_state_str, thread_db_type_str): Remove
spaces from names; we don't always want them, and the caller can
use printf formatting directives to arrange things as they please.

* ptrace-target.c (continue_lwp, singlestep_lwp, attach_lwp,
stop_lwp): Change arguments from 'lwpid_t' to 'pid_t'.  lwpid_t is
strictly a thread-db type; these are functions that use system
calls, which all expect pid_t.  Rename arguments from 'lwpid' to
'pid'.

* ptrace-target.c: #define _GNU_SOURCE to get declaration for
strsignal.
(kill_lwp): Enhance error reporting.
@
text
@a43 2
#include "lwp-ctrl.h"
#include "lwp-pool.h"
a186 49

  /* A note about thread states (TI.ti_state):

     When a thread calls pthread_exit, it first runs all its
     cancellation cleanup functions (see pthread_cleanup_push), and
     then calls destructors for its thread-specific data (see
     pthread_key_create).  If the thread is not detached, it then
     makes the pointer passed to pthread_exit available for thread(s)
     calling pthread_join.  Then, the thread terminates.

     If a thread's start function, passed to pthread_create, returns,
     then an implementation may assume that the cleanups have run
     already (the POSIX threads interface requires user code to ensure
     that this is the case).  So it just runs the destructors, and
     terminates.

     In glibc 2.3.3's NPTL, if a thread calls pthread_exit,
     libthread_db says its state is TD_THR_ZOMBIE while it runs its
     cleanups and destructors.  However, if a thread simply returns
     from its start function, then libthread_db says it's
     TD_THR_ACTIVE while it runs its destructors.  Other versions of
     libthread_db seem to do inconsistent things like that as well.

     A note about LWP id's (TI.ti_lid):

     After a thread has exited, the libthread_db's for LinuxThreads
     and NPTL report its ti_lid as being equal to the pid of the main
     thread.  To be precise, it reports the LWP id's as being equal to
     ps_getpid (PROCHANDLE), where PROCHANDLE is the 'struct
     ps_prochandle' passed to td_ta_new when we created the thread
     agent in the first place.

     The idea here seems to be, "There are no kernel-level resources
     devoted to the thread any more that a debugger could talk to, so
     let's hand the debugger whatever info we used to create the
     thread agent in the first place, so it can at least talk to what
     remains of the process."  This is a nice thought, but since the
     thread_db interface doesn't give us any way to stop threads or
     wait for them, the debugger needs to break through the
     abstraction and operate on LWP's directly to do those things.
     libthread_db's attempt to be helpful, together with the
     sloppiness in the ti_state handling, makes figuring whether there
     even *is* an LWP to operate on pretty difficult.

     If we attach to a process using some pid P, whose corresponding
     thread happens to have called pthread_exit, then there's no way
     for us to distinguish threads whose lwp is reported as P because
     they're dead from the thread whose lwp is reported as P because
     it actually is: they're all zombies.  */
d189 17
a217 1
  memset (new, 0, sizeof (*new));
d287 27
d427 3
a429 3
  case TD_THR_ACTIVE:		return "<active>";
  case TD_THR_ZOMBIE:		return "<zombie>";
  case TD_THR_SLEEP:		return "<sleep>";
d441 1
a441 1
  case TD_THR_USER:		return "<user>";
a507 26
/* Return a pointer to a statically allocated string describing
   THREAD.  For debugging.  The resulting string has the form
   "(TID STATE LID PTR)", where:
   - TID is the thread ID, which you'll see in the user program and
     in the remote protocol,
   - STATE is the state of the thread, which can be important in 
     deciding how to interpret LID,
   - LID is the PID of the underlying LWP, and
   - PTR is the address of the 'struct thread' in RDA, so you can
     actually mess with it further if you want.  */
static const char *
thread_debug_name (struct gdbserv_thread *thread)
{
  if (thread)
    {
      static char buf[100];
      sprintf (buf, "(0x%lx %s %d %p)",
	       (unsigned long) thread->ti.ti_tid,
	       thread_db_state_str (thread->ti.ti_state),
	       thread->ti.ti_lid,
	       thread);
      return buf;
    }
  else
    return "(null thread)";
}
a553 24
static struct gdbserv_thread *
thread_list_lookup_by_lid (lwpid_t pid)
{
  struct gdbserv_thread *t;
  struct gdbserv_thread *second_choice = NULL;

  /* Ideally, we'd be using td_ta_map_lwp2thr here.  */

  for (t = thread_list; t; t = t->next)
    if (t->ti.ti_lid == pid)
      {
	/* libthread_db reports the ti_lid of a deceased thread as
	   being equal to ps_getpid (&proc_handle).  So be a bit
	   skeptical of those.  */
	if (pid == proc_handle.pid
	    && (t->ti.ti_state == TD_THR_ZOMBIE
		|| t->ti.ti_state == TD_THR_UNKNOWN))
	  second_choice = t;
	else return t;
      }

  return second_choice;
}

d1304 2
a1305 1
  if (thread->ti.ti_lid != 0)
d1307 4
a1310 21
      /* We attach to all threads with a plausible LWP PID, including
	 TD_THR_ZOMBIE threads.  libthread_db sometimes reports
	 threads still executing cleanups or thread-specific data
	 destructors as zombies, so it may be important to attach to
	 them.

	 libthread_db never reports an invalid LWP PID in ti.ti_lid,
	 even when the LWP has exited --- in that case, it returns
	 ps_getpid (&proc_handle).  The LWP pool code tolerates
	 multiple requests to attach to the same PID.  */
      int status = lwp_pool_attach (thread->ti.ti_lid);

      /* If we're using signals to communicate with the thread
	 library, send the newly attached thread the restart
	 signal.  It will remain stopped, but it will receive the
	 signal as soon as we continue it.  */
      if (got_thread_signals)
	{
	  if (status == 1)
	    kill_lwp (thread->ti.ti_lid, restart_signal);
	}
d1342 6
a1347 1
	  attach_thread (thread);
d1375 1
a1375 1
update_thread_list (struct child_process *process)
a1406 3

	      if (thread == process->focus_thread)
		process->focus_thread = NULL;
d1425 1
a1425 2
      struct child_process *process = gdbserv_target_data (serv);
      update_thread_list (process);
d1603 2
a1604 4
  /* When a thread's LWP has exited, NPTL reports its ti_lid as
     being equal to that of the main process.  Which is a little
     confusing.  So print the pid in a helpfully detailed way.  */
  sprintf (info, "Type %s State %s PID %d%s",
d1606 117
a1722 3
	   thread_db_state_str (thread->ti.ti_state),
	   thread->ti.ti_lid,
	   (thread->ti.ti_lid == proc_handle.pid ? " (main)" : ""));
d1724 8
a1731 1
  return info;
d1735 9
a1743 2
/* If we are using the libthread_db event interface, and PROCESS is
   stopped at an event breakpoint, handle the event.
a1744 5
   If we've taken care of PROCESS's situation and it needs no further
   attention, return non-zero.  If PROCESS still needs attention (say,
   because we're not using the event interface, or PROCESS didn't in
   fact hit an event breakpoint, or it did but had new interesting
   things happen when we tried to single-step it), return zero.  */
d1746 151
a1896 1
handle_thread_db_event (struct child_process *process)
d1898 89
a1986 4
  struct gdbserv *serv = process->serv;
  struct gdbserv_thread *thread = process->event_thread;
  lwpid_t lwp;
  union wait w;
d1988 4
a1991 3
  /* We need to be actually using the event interface.  */
  if (! using_thread_db_events)
    return 0;
d1993 7
a1999 3
  /* We need a thread to work on.  */
  if (! thread)
    return 0;
d2001 15
a2015 5
  /* It needs to be stopped at an event breakpoint.  */
  if (! (process->stop_status == 'T'
	 && process->stop_signal == SIGTRAP
	 && hit_thread_db_event_breakpoint (serv, thread)))
    return 0;
d2017 2
a2018 1
  lwp = thread->ti.ti_lid;
d2020 1
a2020 1
  /* Consume events from the queue.  */
d2037 4
a2040 10
	 TD_DEATH.

	 Every time thread_db_check_child_state gets a wait status
	 from waitpid, we call update_thread_list, so our list is
	 always up to date; we don't actually need to do anything with
	 these messages for our own sake.

	 However, the LWP pool module needs to be told when threads
	 are about to exit, since NPTL gives no kernel-level
	 indication of this.  Threads just disappear.
d2044 3
a2046 2
	 before we've managed to send each of the LWP's a
	 SIGSTOP.)  */
d2048 8
a2055 1
      if (msg.event == TD_DEATH)
d2057 3
a2059 10
	  td_thrinfo_t ti;
	  
	  status = td_thr_get_info_p (msg.th_p, &ti);
	  if (status != TD_OK)
	    {
	      fprintf (stderr, 
		       "error getting thread info on dying thread: %s\n",
		       thread_db_err_str (status));
	      break;
	    }
d2061 5
a2065 5
	  /* Tell the LWP pool code that this thread's death has been
	     foretold.  */
	  lwp_pool_thread_db_death_event ((pid_t) ti.ti_lid);
	}
    }
d2067 2
a2068 2
  /* Disable the event breakpoints while we step the thread across them.  */
  delete_thread_db_event_breakpoints (serv);
d2070 2
a2071 2
  /* Back up the thread, if needed.  */
  decr_pc_after_break (serv, lwp);
d2073 23
a2095 14
  /* Single-step the thread across the breakpoint.  */
  lwp_pool_singlestep_lwp (serv, lwp, 0);

  /* Get a new status for that thread.  */
  if (thread_db_noisy)
    fprintf (stderr, "(waiting after event bp step %s)\n",
	     thread_debug_name (thread));
  if (lwp_pool_waitpid (lwp, (int *) &w, 0) < 0)
    {
      fprintf (stderr, "error waiting for thread %d after "
	       "stepping over event breakpoint:\n%s",
	       lwp, strerror (errno));
      /* We don't have any new status to report...  */
      return 1;
a2097 3
  /* Tell the LWP pool that this thread has notified RDA of an event.  */
  lwp_pool_thread_db_death_notified (lwp);

a2099 11

  /* If the wait status is a SIGTRAP signal, then that means the
     single-step proceeded normally.  Otherwise, it's a new event we
     should deal with.  */
  if (WIFSTOPPED (w) && WSTOPSIG (w) == SIGTRAP)
    return 1;
  else
    {
      handle_waitstatus (process, w);
      return 0;
    }
d2111 2
d2114 16
a2129 1
    lwp_pool_continue_lwp (thread->ti.ti_lid, signal);
d2131 11
a2141 1
  thread_db_invalidate_caches ();
d2157 1
a2157 1
      continue_thread (process->event_thread, process->signal_to_send);
d2159 1
a2159 1
    lwp_pool_continue_lwp (process->pid, process->signal_to_send);
d2165 1
a2165 1
  lwp_pool_continue_all ();
a2167 2

  process->focus_thread = NULL;
d2178 3
a2180 1
  lwp_pool_singlestep_lwp (serv, thread->ti.ti_lid, signal);
d2199 1
a2199 1
    lwp_pool_singlestep_lwp (serv, process->pid, process->signal_to_send);
d2205 1
a2205 1
  lwp_pool_continue_all ();
a2207 2

  process->focus_thread = NULL;
a2242 5

  /* If we continued a particular thread, then collect wait statuses
     for that thread only.  Otherwise, look for events from
     everyone.  */
  process->focus_thread = thread;
a2276 4

  /* If we stepped a particular thread, then collect wait statuses for
     that thread only.  Otherwise, look for events from everyone.  */
  process->focus_thread = thread;
d2326 6
a2331 10
      eventpid = -1;

      /* If we only stepped or continued a single thread, check for
	 status results only from that thread, even though there may
	 be others collected from before.  */
      if (process->focus_thread)
	eventpid = lwp_pool_waitpid (process->focus_thread->ti.ti_lid,
				     (int *) &w, WNOHANG);
      else
	eventpid = lwp_pool_waitpid (-1, (int *) &w, WNOHANG);
d2335 2
d2356 4
a2359 6
	  /* It doesn't hurt to call this twice.  But if there are a
	     lot of other threads running, then RDA is competing with
	     them for time slices and it can take a long time for the
	     thread list update to complete.  */
	  lwp_pool_stop_all ();

d2363 1
a2363 3
		     process->pid,
		     process->stop_status,
		     process->stop_signal,
d2365 4
d2371 1
a2371 3
	  update_thread_list (process);

	  process->event_thread = thread_list_lookup_by_lid (process->pid);
d2376 3
a2378 2
	  /* Stop any new threads we've recognized.  */
	  lwp_pool_stop_all ();
d2380 11
a2390 4
	  /* If we're using the thread_db event interface, and this is
	     a thread_db event, then just handle it silently and
	     continue.  */
	  if (handle_thread_db_event (process))
d2396 3
a2398 2
	  /* If we're using the signal-based interface, and someone
	     got a thread-related signal, then deal with that.  */
d2403 1
a2403 2
		fprintf (stderr, 
			 "<check_child_state: ignoring signal %d for %d>\n",
d2432 11
d2445 4
a2865 6
  /* Record the initial thread's pid in the LWP pool.  */
  lwp_pool_new_stopped (process->pid);

  /* Initially, there is no focus thread.  */
  process->focus_thread = NULL;

@


1.9.2.8
log
@Move libthread_db event-based thread death logic from lwp-pool.c
to thread-db.c, so the former can stay innocent of libthread_db's
details, and limit itself to kernel behavior.
* lwp-pool.h (lwp_pool_continue_and_drop): New declaration.
(lwp_pool_thread_db_death_event,
lwp_pool_thread_db_death_notified): Declarations deleted.
* lwp-pool.c (enum death_state): Move to thread-db.c.
(struct lwp): Delete 'death_state' member.
(hash_find): Don't initialize it.
(interesting_queue): Don't provide an initializer for it.
(check_stop_pending): Don't abort if wait_and_handle didn't put
the thread in a stopped state; that could be caused by kernel
behavior (say, threads exiting silently), not necessarily a logic
flaw in lwp-pool.c.
(death_state_str, debug_report_death_state_change): Move to
thread-db.c.
(lwp_pool_thread_db_death_event,
lwp_pool_thread_db_death_notified): Move to thread-db.c, and
rename (see below).
(check_for_exiting_nptl_lwp): Delete.
(lwp_pool_continue_all, lwp_pool_continue_lwp): Don't call
check_for_exiting_nptl_lwp.
(lwp_pool_continue_and_drop_lwp): New function.
* thread-db.c (enum death_state): Moved here from lwp-pool.c.
(struct gdbserv_thread): New member death_state.
(add_thread_to_list): Initialize it.
(death_state_str, debug_report_death_state_change): Moved here
from lwp-pool.c.
(death_state_got_event, death_state_notified): Renamed from
lwp_pool_thread_db_death_event and lwp_pool_thread_db_death_notified,
and changed to update the death state of a 'struct gdbserv_thread'
instead of a 'struct lwp'.
(handle_thread_db_event): Call death_state_got_event instead of
lwp_pool_thread_db_death_event, and death_state_notified instead
of lwp_pool_thread_db_death_notified.
(continue_thread): If the thread's death state indicates that it's
going to disappear without further ado when continued, continue it
with lwp_pool_continue_and_drop_lwp, not lwp_pool_continue_lwp.
@
text
@a185 52

/* Under NPTL, LWP's simply disappear, without becoming a zombie or
   producing any wait status.  At the kernel level, we have no way of
   knowing that the LWP's PID is now free and may be reused ---
   perhaps by an entirely different program!  So we need to use the
   death events from libthread_db to help us make the right calls to
   lwp_pool_continue_and_drop_lwp to keep our LWP table clean.

   There are two steps to delivering a TD_DEATH event:

   - first, the thread sends enqueues the event.

   - then, the thread takes some pre-negotiated action (hitting a
     breakpoint; making a system call) to notify libthread_db's client
     that there are events queued it should attend to.

   What's tricky here is that the queueing of the event and the
   notification are not synchronized.  Several threads could queue
   events, and then perform their notification actions simultaneously.
   So RDA could easily find TD_DEATH events for several threads in the
   queue when the first of those threads performs its notification.
   We need to continue to manage the remaining threads whose death is
   foretold (are there any named Santiago?) until they have each
   completed their notifications.

   And since RDA consumes all the events each time a notification is
   received, we should be prepared to receive notifications even when
   the queue is empty as well.

   'enum death_state' helps us keep track of the state of a given
   thread, so we can call lwp_pool_continue_and_drop_lwp on a thread
   when its death has been foretold, and it has completed its
   notification.  */


/* The thread_db death state.  */
enum death_state {

  /* We've received no indication that this thread will exit.  */
  death_state_alive,

  /* We've received a TD_DEATH event for this thread, but it hasn't
     completed its event notification yet.  */
  death_state_event_received,

  /* We've received a TD_DEATH event for this thread, and it has
     completed its event notification; we will continue it next using
     lwp_pool_continue_and_drop_lwp.  */
  death_state_drop_when_continued
};


a239 3
  /* The death state for this thread.  */
  enum death_state death_state;

a240 1

a253 1
  new->death_state = death_state_alive;
a1688 77
static const char *
death_state_str (enum death_state d)
{
  switch (d)
    {
    case death_state_alive: return "alive";
    case death_state_event_received: return "event_received";
    case death_state_drop_when_continued: return "drop_when_continued";
    default:
      {
	static char buf[100];
	sprintf (buf, "%d (unrecognized death_state)", d);
	return buf;
      }
    }
}


static void
debug_report_death_state_change (struct gdbserv_thread *thread,
				 enum death_state old,
				 enum death_state new)
{
  if (thread_db_noisy && old != new)
    fprintf (stderr,
	     "%19s -- %s -> %s\n",
	     death_state_str (old),
	     thread_debug_name (thread),
	     death_state_str (new));
}


/* Record the fact that a TD_DEATH event was received for TID.  */
static void
death_state_got_event (thread_t tid)
{
  struct gdbserv_thread *thread = thread_list_lookup_by_tid (tid);
  enum death_state old_state;

  if (thread_db_noisy)
    fprintf (stderr, "death_state_got_event (0x%x)\n", (unsigned int) tid);

  if (! thread)
    fprintf (stderr, "ERROR: death event for unknown thread 0x%x\n",
	     (unsigned int) tid);

  old_state = thread->death_state;

  if (thread->death_state == death_state_alive)
    thread->death_state = death_state_event_received;

  debug_report_death_state_change (thread, old_state, thread->death_state);
}


/* Record the fact that THREAD has completed an event notification.
   Call this for every thread that does an event notification, even
   if there were no messages actually received, or if none of them
   were TD_DEATH messages, or if none applied to the notifying thread.
   The description of 'enum death_state' explains why.  */
static void
death_state_notified (struct gdbserv_thread *thread)
{
  enum death_state old_state;

  if (thread_db_noisy)
    fprintf (stderr, "death_state_notified (%p)\n", thread);

  old_state = thread->death_state;

  if (thread->death_state == death_state_event_received)
    thread->death_state = death_state_drop_when_continued;

  debug_report_death_state_change (thread, old_state, thread->death_state);
}


d1767 3
a1769 2
	  /* Note that this thread's death has been foretold.  */
	  death_state_got_event (ti.ti_tid);
d1795 3
a1800 3
  /* Note that this thread has performed an event notification.  */
  death_state_notified (thread);

d1823 1
a1823 9
    {
      /* If this thread is now going to exit silently, just continue
	 it now and let it die.  */
      if (thread->death_state == death_state_drop_when_continued
	  && signal == 0)
	lwp_pool_continue_and_drop_lwp (thread->ti.ti_lid, 0);
      else
	lwp_pool_continue_lwp (thread->ti.ti_lid, signal);
    }
@


1.9.2.9
log
@* thread-db.c (thread_db_break_program): New function.
(thread_db_attach): Register it as the 'break_program' method.
@
text
@a2134 13
static void
thread_db_break_program (struct gdbserv *serv)
{
  struct child_process *process = gdbserv_target_data (serv);

  /* We always send the signal to the main thread.  It's not correct
     to use process->pid; that's whatever thread last reported a
     status, and it may well have been exiting.  */
  if (process->debug_backend)
    fprintf (stderr, " -- send SIGINT to child %d\n", proc_handle.pid);
  kill (proc_handle.pid, SIGINT);
}

a2637 2
  target->break_program       = thread_db_break_program;

@


1.9.2.10
log
@* thread-db.c (thread_db_attach): Always preload the symbol list
with the names of the symbols RDA uses itself.
@
text
@a2664 30
  /* Preload the symbol list with the names of the symbols whose names
     we use ourselves.  

     This might be a kludge, but it's not a gratuitous kludge.  On
     older LinuxThreads libraries, RDA must manage LinuxThreads
     signals.  Since libthread_db provides no abstraction for managing
     them, RDA must look up the addresses of the signal variables and
     read their values itself.  However, libthread_db may never look
     those symbols up itself, and they may not appear in the list
     provided by td_symbol_list_p.  (In fact, in glibc-2.2.93, they
     don't.)

     So RDA may as well preload them into the symbol list; otherwise,
     get_thread_signals will fail even though the symbols are defined,
     because the names will only get added to symbol_list as we
     attempt to look them up; each remote protocol symbol lookup dance
     will resolve exactly one new symbol, allowing get_thread_signal
     to get as far as requesting the next one and failing.

     As it turns out, this is actually necessary, not just efficient,
     because failures from get_thread_signal cause RDA to try the
     libthread_db event-based interface; we may end up using that even
     when the signal-based interface is actually available.  And we'd
     rather use the signal-based interface when we can, to avoid
     changing the behavior of RDA on older systems.  */
  add_symbol_to_list ("__pthread_sig_restart",   0, UNDEFINED);
  add_symbol_to_list ("__pthread_sig_cancel",    0, UNDEFINED);
  add_symbol_to_list ("__pthread_sig_debug",     0, UNDEFINED);
  add_symbol_to_list ("__pthread_threads_debug", 0, UNDEFINED);

d2676 11
@


1.9.2.11
log
@* thread-db.c (thread_db_check_child_state): No need to call
lwp_pool_stop_all twice; update_thread_list stops any new threads.
@
text
@d2207 4
a2210 1
	  /* Stop all the threads we know about.  */
d2221 1
a2221 2
	  /* Update the thread list, and attach to (and thereby stop)
             any new threads we find.  */
d2229 3
@


1.9.2.12
log
@* thread-db.c (thread_db_thread_info): Produce output that more
closely resembles GDB's native thread output, to mollify the GDB
test suite.
@
text
@d1736 1
a1736 1
  sprintf (info, "Type %s State %s LWP %d%s",
@


1.9.2.13
log
@* thread-db.c (thread_db_open): Produce debugging output.
@
text
@a1376 3
  if (thread_db_noisy)
    fprintf (stderr, "< -- succeeded, thread_agent = %p>\n", thread_agent);

d1384 1
a1384 7
    {
      if (thread_db_noisy)
        fprintf (stderr,
                 "(using thread signals cancel=%d, restart=%d, debug=%d)\n",
                 cancel_signal, restart_signal, debug_signal);
      return 0;
    }
d1386 2
a1387 6
  if (request_thread_db_events (serv) == 0)
    {
      if (thread_db_noisy)
        fprintf (stderr, "(using thread_db events)\n");
      return 0;
    }
@


1.9.2.14
log
@Remove code to handle threads exiting without generating a wait
status; that was a kernel bug, not an intended feature, and
there's no easy way to support both.
* lwp-pool.c (lwp_pool_continue_and_drop): Delete function.
* lwp-pool.h (lwp_pool_continue_and_drop): Delete declaration.
* thread-db.c (enum death_state): Delete type.
(struct gdbserv_thread): Remove 'death_state' member.
(add_thread_to_list): Don't initialize it.
(death_state_str, debug_report_death_state_change,
death_state_got_event, death_state_notified): Delete functions.
(handle_thread_db_event): Don't handle death events specially, and
don't handle the notifying thread specially.
(continue_thread): Don't treat threads whose death has been
foretold and who have completed their notification specially.
@
text
@d187 51
d292 3
d310 1
d1759 77
d1890 27
a1916 1
	 these messages for our own sake.  */
d1944 3
d1969 9
a1977 1
    lwp_pool_continue_lwp (thread->ti.ti_lid, signal);
@


1.9.2.15
log
@Disable debugging messages by default.
* lwp-pool.c (debug_lwp_pool): Initialize to zero.
* thread-db.c (thread_db_noisy): Same.
@
text
@d48 1
a48 1
int thread_db_noisy = 0;
@


1.9.2.16
log
@Merge changes from trunk, to make progressive branch-vs.-trunk
diffs easier to generate.

2005-02-08  Kevin Buettner  <kevinb@@redhat.com

* td_thr_tls_get_addr_p): New static global.
(thread_db_dlopen): Initialize ``td_thr_tls_get_addr_p''.
(thread_db_get_gen): Add support for qGetTLSAddr packet.

2004-12-13  Kevin Buettner  <kevinb@@redhat.com>

* thread-db.c (thread_db_get_thread_reg): Don't allow a successful
return without first initializing ``reg''.
(thread_db_set_thread_reg): Remove code intended to for
thread_db_get_thread_reg().

2004-11-18  Kevin Buettner  <kevinb@@redhat.com>

* thread-db.c (thread_db_set_thread_reg): Don't allow a successful
return without first initializing ``reg''.
@
text
@a420 3
static td_err_e (*td_thr_tls_get_addr_p) (const td_thrhandle_t *th,
                                          void *map_address,
					  size_t offset, void **address);
a1281 1
  td_thr_tls_get_addr_p = dlsym (dlhandle, "td_thr_tls_get_addr");
d1521 1
a1521 1
     qSymbol and qGetTLSAddr
a1632 59
  else if (gdbserv_input_string_match (serv, "GetTLSAddr:") >= 0)
    {
      /* Message qGetTLSAddr:thread-id,offset,link-map-addr */
      unsigned long thread_id, offset, link_map_addr;

      if (thread_agent == NULL
          || td_thr_tls_get_addr_p == 0)
	{
	  /* Not supported by thread library.  */
	  gdbserv_output_string (serv, "E01");
	}
      else if (gdbserv_input_hex_ulong (serv, &thread_id) >= 0
          && gdbserv_input_string_match (serv, ",") >= 0
	  && gdbserv_input_hex_ulong (serv, &offset) >= 0
	  && gdbserv_input_string_match (serv, ",") >= 0
	  && gdbserv_input_hex_ulong (serv, &link_map_addr) >= 0)
	{
	  td_err_e ret;
	  td_thrhandle_t thread_handle;
	  ret = thread_db_map_id2thr (thread_agent, 
				      (thread_t) thread_id,
				      &thread_handle);

	  if (ret == TD_OK)
	    {
	      void *addr;

	      ret = td_thr_tls_get_addr_p (&thread_handle,
				           (void *) link_map_addr, 
				           (size_t) offset,
				           &addr);
	      if (ret == TD_OK)
	        {
		  struct gdbserv_reg addr_as_reg;

		  gdbserv_ulonglong_to_reg (serv,
		                            (unsigned long long)
		                              (unsigned long) addr,
		                            &addr_as_reg);
		  gdbserv_output_reg_beb (serv, &addr_as_reg, 0);
		}
	      else
		{
		  /* Can't find TLS address.  */
		  gdbserv_output_string (serv, "E04");
		}
	    }
	  else
	    {
	      /* Unable to find thread.  */
	      gdbserv_output_string (serv, "E03");
	    }
	}
      else
	{
	  /* Malformed qGetTLSAddr packet.  */
	  gdbserv_output_string (serv, "E02");
	}
    }
a2298 4
  /* Initialize reg to 0 in the event that we return early due to a
     register being unsupported.  */
  gdbserv_ulonglong_to_reg (serv, 0LL, reg);

@


1.9.2.17
log
@Correct merge of Kevin's patch from the trunk.
@
text
@a2223 4
  /* Initialize reg to 0 in the event that we return early due to a
     register being unsupported.  */
  gdbserv_ulonglong_to_reg (serv, 0LL, reg);

d2362 4
@


1.8
log
@* thread-db.c (thread_db_get_gen): There's no reason to try to
open a thread agent until we've at least requested values for all
the symbols we know about.
@
text
@d73 1
a73 1
add_symbol_to_list (char *name, paddr_t value, int defined_p)
d377 2
d830 1
d2320 22
a2341 8
  /* KLUDGE: Insert some magic symbols into the cached symbol list,
     to be looked up later.  This is badly wrong -- we should be 
     obtaining these values thru the thread_db interface.  Their names
     should not be hard-coded here <sob>. */
  add_symbol_to_list ("__pthread_sig_restart",   0, UNDEFINED);
  add_symbol_to_list ("__pthread_sig_cancel",    0, UNDEFINED);
  add_symbol_to_list ("__pthread_sig_debug",     0, UNDEFINED);
  add_symbol_to_list ("__pthread_threads_debug", 0, UNDEFINED);
@


1.7
log
@	* thread-db.c (get_thread_signals): Doc fix.
@
text
@d1091 21
d1114 1
a1114 2
      thread_db_open (serv, process->pid);
      if ((symbol_query = next_undefined_symbol ()) == NULL)
@


1.6
log
@	* thread-db.c (enum symbol_cache_defined): Move this definition
	above that of (struct symbol_cache), and give it a name.
	(struct symbol_cache): Use that enum as the type of 'defined_p', so
	the debugger will print symbol cache entries more helpfully.
@
text
@d1208 13
a1220 3
   Obtain the values of the "cancel", "restart" and "debug" signals 
   used by linux threads, and store them in a set of global variables
   for use by check_child_state and friends. */
@


1.5
log
@	* thread-db.c (thread_db_open, thread_db_get_gen): Doc fixes.
@
text
@d56 3
d62 1
a62 1
  int  defined_p;
a65 3
/* The "defined_p" field may have one of the following three values. */
enum { UNDEFINED, REQUESTED, DEFINED };

@


1.4
log
@	* thread-db.c (thread_db_detach, thread_db_set_gen,
	thread_db_thread_id): Make these functions static.
@
text
@d834 1
a834 1
   Returns: -1 for failure, 0 for success
d1052 1
a1052 1
	     form #2 ("qSymbol::<name>", a reply that "this symbol is
d1065 4
a1068 2
	      /* Form #2, this symbol not currently defined.
		 Nothing to do, since we already have it marked undefined. */
d1076 1
a1076 1
	  /* Message contains a symbol and a value (form #3). */
@


1.3
log
@	* thread-db.c (lookup_sym): New function.
	(thread_db_open): Print diagnostic message for failed dlopen()
	call.  Call lookup_sym() which will print diagnostic for failed
	dlsym() call.
@
text
@d876 1
a876 1
void
d1110 1
a1110 1
void
d1117 1
a1117 1
void
@


1.2
log
@Fix mips single step code for mips64 n32 and n64 targets.  Adjust register
information.
@
text
@d743 17
d775 5
a779 1
    return -1;		/* fail */
d784 1
a784 1
  if ((td_init_p = dlsym (dlhandle, "td_init")) == NULL)
d787 1
a787 1
  if ((td_ta_new_p = dlsym (dlhandle, "td_ta_new")) == NULL)
d790 1
a790 1
  if ((td_ta_delete_p = dlsym (dlhandle, "td_ta_delete")) == NULL)
d793 1
a793 1
  if ((td_ta_map_id2thr_p = dlsym (dlhandle, "td_ta_map_id2thr")) == NULL)
d796 1
a796 1
  if ((td_ta_map_lwp2thr_p = dlsym (dlhandle, "td_ta_map_lwp2thr")) == NULL)
d799 1
a799 1
  if ((td_ta_thr_iter_p = dlsym (dlhandle, "td_ta_thr_iter")) == NULL)
d802 1
a802 1
  if ((td_thr_validate_p = dlsym (dlhandle, "td_thr_validate")) == NULL)
d805 1
a805 1
  if ((td_thr_get_info_p = dlsym (dlhandle, "td_thr_get_info")) == NULL)
d808 1
a808 1
  if ((td_thr_getfpregs_p = dlsym (dlhandle, "td_thr_getfpregs")) == NULL)
d811 1
a811 1
  if ((td_thr_getgregs_p = dlsym (dlhandle, "td_thr_getgregs")) == NULL)
d814 1
a814 1
  if ((td_thr_setfpregs_p = dlsym (dlhandle, "td_thr_setfpregs")) == NULL)
d817 1
a817 1
  if ((td_thr_setgregs_p = dlsym (dlhandle, "td_thr_setgregs")) == NULL)
@


1.1
log
@Added files comprising RDA.
@
text
@d1523 2
a1524 1
		  fprintf (stderr, "<wait_all_threads: ignoring SIGDEBUG for %d>\n",
d1621 3
a1623 1
singlestep_thread (struct gdbserv_thread *thread, int signal)
d1625 1
a1625 1
  singlestep_lwp (thread->ti.ti_lid, signal);
d1644 1
a1644 1
    singlestep_thread (process->event_thread, process->signal_to_send);
d1646 1
a1646 1
    singlestep_lwp (process->pid, process->signal_to_send);
d1718 1
a1718 1
      singlestep_thread (thread, process->signal_to_send);
@

