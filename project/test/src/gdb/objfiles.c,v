head	1.171;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.157
	gdb_7_6-2013-04-26-release:1.157
	gdb_7_6-branch:1.157.0.2
	gdb_7_6-2013-03-12-branchpoint:1.157
	gdb_7_5_1-2012-11-29-release:1.140
	gdb_7_5-2012-08-17-release:1.140
	gdb_7_5-branch:1.140.0.2
	gdb_7_5-2012-07-18-branchpoint:1.140
	gdb_7_4_1-2012-04-26-release:1.133.2.1
	gdb_7_4-2012-01-24-release:1.133.2.1
	gdb_7_4-branch:1.133.0.2
	gdb_7_4-2011-12-13-branchpoint:1.133
	gdb_7_3_1-2011-09-04-release:1.127.2.1
	gdb_7_3-2011-07-26-release:1.127.2.1
	gdb_7_3-branch:1.127.0.2
	gdb_7_3-2011-04-01-branchpoint:1.127
	gdb_7_2-2010-09-02-release:1.116
	gdb_7_2-branch:1.116.0.2
	gdb_7_2-2010-07-07-branchpoint:1.116
	gdb_7_1-2010-03-18-release:1.111
	gdb_7_1-branch:1.111.0.2
	gdb_7_1-2010-02-18-branchpoint:1.111
	gdb_7_0_1-2009-12-22-release:1.96.2.2
	gdb_7_0-2009-10-06-release:1.96.2.1
	gdb_7_0-branch:1.96.0.2
	gdb_7_0-2009-09-16-branchpoint:1.96
	arc-sim-20090309:1.70
	msnyder-checkpoint-072509-branch:1.87.0.2
	msnyder-checkpoint-072509-branchpoint:1.87
	arc-insight_6_8-branch:1.70.0.6
	arc-insight_6_8-branchpoint:1.70
	insight_6_8-branch:1.70.0.4
	insight_6_8-branchpoint:1.70
	reverse-20081226-branch:1.79.0.6
	reverse-20081226-branchpoint:1.79
	multiprocess-20081120-branch:1.79.0.4
	multiprocess-20081120-branchpoint:1.79
	reverse-20080930-branch:1.79.0.2
	reverse-20080930-branchpoint:1.79
	reverse-20080717-branch:1.75.0.4
	reverse-20080717-branchpoint:1.75
	msnyder-reverse-20080609-branch:1.75.0.2
	msnyder-reverse-20080609-branchpoint:1.75
	drow-reverse-20070409-branch:1.66.0.2
	drow-reverse-20070409-branchpoint:1.66
	gdb_6_8-2008-03-27-release:1.70
	gdb_6_8-branch:1.70.0.2
	gdb_6_8-2008-02-26-branchpoint:1.70
	gdb_6_7_1-2007-10-29-release:1.68
	gdb_6_7-2007-10-10-release:1.68
	gdb_6_7-branch:1.68.0.2
	gdb_6_7-2007-09-07-branchpoint:1.68
	insight_6_6-20070208-release:1.65
	gdb_6_6-2006-12-18-release:1.65
	gdb_6_6-branch:1.65.0.2
	gdb_6_6-2006-11-15-branchpoint:1.65
	insight_6_5-20061003-release:1.64
	gdb-csl-symbian-6_4_50_20060226-12:1.64.8.2
	gdb-csl-sourcerygxx-3_4_4-25:1.61
	nickrob-async-20060828-mergepoint:1.65
	gdb-csl-symbian-6_4_50_20060226-11:1.64.8.2
	gdb-csl-sourcerygxx-4_1-17:1.64
	gdb-csl-20060226-branch-local-2:1.64
	gdb-csl-sourcerygxx-4_1-14:1.64
	gdb-csl-sourcerygxx-4_1-13:1.64
	gdb-csl-sourcerygxx-4_1-12:1.64
	gdb-csl-sourcerygxx-3_4_4-21:1.64
	gdb_6_5-20060621-release:1.64
	gdb-csl-sourcerygxx-4_1-9:1.64
	gdb-csl-sourcerygxx-4_1-8:1.64
	gdb-csl-sourcerygxx-4_1-7:1.64
	gdb-csl-arm-2006q1-6:1.64
	gdb-csl-sourcerygxx-4_1-6:1.64
	gdb-csl-symbian-6_4_50_20060226-10:1.64.8.1
	gdb-csl-symbian-6_4_50_20060226-9:1.64
	gdb-csl-symbian-6_4_50_20060226-8:1.64
	gdb-csl-coldfire-4_1-11:1.64
	gdb-csl-sourcerygxx-3_4_4-19:1.64
	gdb-csl-coldfire-4_1-10:1.64
	gdb_6_5-branch:1.64.0.16
	gdb_6_5-2006-05-14-branchpoint:1.64
	gdb-csl-sourcerygxx-4_1-5:1.64
	nickrob-async-20060513-branch:1.64.0.14
	nickrob-async-20060513-branchpoint:1.64
	gdb-csl-sourcerygxx-4_1-4:1.64
	msnyder-reverse-20060502-branch:1.64.0.12
	msnyder-reverse-20060502-branchpoint:1.64
	gdb-csl-morpho-4_1-4:1.64
	gdb-csl-sourcerygxx-3_4_4-17:1.64
	readline_5_1-import-branch:1.64.0.10
	readline_5_1-import-branchpoint:1.64
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.64
	gdb-csl-symbian-20060226-branch:1.64.0.8
	gdb-csl-symbian-20060226-branchpoint:1.64
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.64
	msnyder-reverse-20060331-branch:1.64.0.6
	msnyder-reverse-20060331-branchpoint:1.64
	gdb-csl-available-20060303-branch:1.64.0.4
	gdb-csl-available-20060303-branchpoint:1.64
	gdb-csl-20060226-branch:1.64.0.2
	gdb-csl-20060226-branchpoint:1.64
	gdb_6_4-20051202-release:1.61
	msnyder-fork-checkpoint-branch:1.61.0.12
	msnyder-fork-checkpoint-branchpoint:1.61
	gdb-csl-gxxpro-6_3-branch:1.61.0.10
	gdb-csl-gxxpro-6_3-branchpoint:1.61
	gdb_6_4-branch:1.61.0.8
	gdb_6_4-2005-11-01-branchpoint:1.61
	gdb-csl-arm-20051020-branch:1.61.0.6
	gdb-csl-arm-20051020-branchpoint:1.61
	msnyder-tracepoint-checkpoint-branch:1.61.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.61
	gdb-csl-arm-20050325-2005-q1b:1.61
	gdb-csl-arm-20050325-2005-q1a:1.61
	csl-arm-20050325-branch:1.61.0.2
	csl-arm-20050325-branchpoint:1.61
	gdb-post-i18n-errorwarning-20050211:1.60
	gdb-pre-i18n-errorwarning-20050211:1.59
	gdb_6_3-20041109-release:1.56
	gdb_6_3-branch:1.56.0.2
	gdb_6_3-20041019-branchpoint:1.56
	drow_intercu-merge-20040921:1.55
	drow_intercu-merge-20040915:1.55
	jimb-gdb_6_2-e500-branch:1.53.0.6
	jimb-gdb_6_2-e500-branchpoint:1.53
	gdb_6_2-20040730-release:1.53
	gdb_6_2-branch:1.53.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.53
	gdb_6_1_1-20040616-release:1.51
	gdb_6_1-2004-04-05-release:1.51
	drow_intercu-merge-20040402:1.51
	drow_intercu-merge-20040327:1.51
	ezannoni_pie-20040323-branch:1.51.0.8
	ezannoni_pie-20040323-branchpoint:1.51
	cagney_tramp-20040321-mergepoint:1.51
	cagney_tramp-20040309-branch:1.51.0.6
	cagney_tramp-20040309-branchpoint:1.51
	gdb_6_1-branch:1.51.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.51
	drow_intercu-20040221-branch:1.51.0.2
	drow_intercu-20040221-branchpoint:1.51
	cagney_bfdfile-20040213-branch:1.48.0.2
	cagney_bfdfile-20040213-branchpoint:1.48
	drow-cplus-merge-20040208:1.47
	carlton_dictionary-20040126-merge:1.44
	cagney_bigcore-20040122-branch:1.44.0.2
	cagney_bigcore-20040122-branchpoint:1.44
	drow-cplus-merge-20040113:1.43
	drow-cplus-merge-20031224:1.43
	drow-cplus-merge-20031220:1.43
	carlton_dictionary-20031215-merge:1.43
	drow-cplus-merge-20031214:1.43
	carlton-dictionary-20031111-merge:1.41
	gdb_6_0-2003-10-04-release:1.33.4.1
	kettenis_sparc-20030918-branch:1.37.0.4
	kettenis_sparc-20030918-branchpoint:1.37
	carlton_dictionary-20030917-merge:1.37
	ezannoni_pie-20030916-branchpoint:1.37
	ezannoni_pie-20030916-branch:1.37.0.2
	cagney_x86i386-20030821-branch:1.33.0.6
	cagney_x86i386-20030821-branchpoint:1.33
	carlton_dictionary-20030805-merge:1.33
	carlton_dictionary-20030627-merge:1.33
	gdb_6_0-branch:1.33.0.4
	gdb_6_0-2003-06-23-branchpoint:1.33
	jimb-ppc64-linux-20030613-branch:1.33.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.33
	cagney_convert-20030606-branch:1.31.0.6
	cagney_convert-20030606-branchpoint:1.31
	cagney_writestrings-20030508-branch:1.30.0.4
	cagney_writestrings-20030508-branchpoint:1.30
	jimb-ppc64-linux-20030528-branch:1.31.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.31
	carlton_dictionary-20030523-merge:1.31
	cagney_fileio-20030521-branch:1.31.0.2
	cagney_fileio-20030521-branchpoint:1.31
	kettenis_i386newframe-20030517-mergepoint:1.31
	jimb-ppc64-linux-20030509-branch:1.30.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.30
	kettenis_i386newframe-20030504-mergepoint:1.30
	carlton_dictionary-20030430-merge:1.29
	kettenis_i386newframe-20030419-branch:1.29.0.16
	kettenis_i386newframe-20030419-branchpoint:1.29
	carlton_dictionary-20030416-merge:1.29
	cagney_frameaddr-20030409-mergepoint:1.29
	kettenis_i386newframe-20030406-branch:1.29.0.14
	kettenis_i386newframe-20030406-branchpoint:1.29
	cagney_frameaddr-20030403-branchpoint:1.29
	cagney_frameaddr-20030403-branch:1.29.0.12
	cagney_framebase-20030330-mergepoint:1.29
	cagney_framebase-20030326-branch:1.29.0.10
	cagney_framebase-20030326-branchpoint:1.29
	cagney_lazyid-20030317-branch:1.29.0.8
	cagney_lazyid-20030317-branchpoint:1.29
	kettenis-i386newframe-20030316-mergepoint:1.29
	offbyone-20030313-branch:1.29.0.6
	offbyone-20030313-branchpoint:1.29
	kettenis-i386newframe-20030308-branch:1.29.0.4
	kettenis-i386newframe-20030308-branchpoint:1.29
	carlton_dictionary-20030305-merge:1.29
	cagney_offbyone-20030303-branch:1.29.0.2
	cagney_offbyone-20030303-branchpoint:1.29
	carlton_dictionary-20030207-merge:1.27
	interps-20030203-mergepoint:1.25
	interps-20030202-branch:1.24.0.2
	interps-20030202-branchpoint:1.24
	cagney-unwind-20030108-branch:1.22.0.14
	cagney-unwind-20030108-branchpoint:1.22
	carlton_dictionary-20021223-merge:1.22
	gdb_5_3-2002-12-12-release:1.22
	jimb-separate-debug-021125-branch:1.22.0.12
	carlton_dictionary-20021115-merge:1.22
	kseitz_interps-20021105-merge:1.22
	kseitz_interps-20021103-merge:1.22
	drow-cplus-merge-20021020:1.22
	drow-cplus-merge-20021025:1.22
	carlton_dictionary-20021025-merge:1.22
	carlton_dictionary-20021011-merge:1.22
	drow-cplus-branch:1.22.0.10
	drow-cplus-branchpoint:1.22
	kseitz_interps-20020930-merge:1.22
	carlton_dictionary-20020927-merge:1.22
	carlton_dictionary-branch:1.22.0.8
	carlton_dictionary-20020920-branchpoint:1.22
	gdb_5_3-branch:1.22.0.6
	gdb_5_3-2002-09-04-branchpoint:1.22
	kseitz_interps-20020829-merge:1.22
	cagney_sysregs-20020825-branch:1.22.0.4
	cagney_sysregs-20020825-branchpoint:1.22
	readline_4_3-import-branch:1.22.0.2
	readline_4_3-import-branchpoint:1.22
	gdb_5_2_1-2002-07-23-release:1.19
	kseitz_interps-20020528-branch:1.20.0.4
	kseitz_interps-20020528-branchpoint:1.20
	cagney_regbuf-20020515-branch:1.20.0.2
	cagney_regbuf-20020515-branchpoint:1.20
	jimb-macro-020506-branch:1.19.0.4
	jimb-macro-020506-branchpoint:1.19
	gdb_5_2-2002-04-29-release:1.19
	gdb_5_2-branch:1.19.0.2
	gdb_5_2-2002-03-03-branchpoint:1.19
	gdb_5_1_1-2002-01-24-release:1.16
	gdb_5_1_0_1-2002-01-03-release:1.16
	cygnus_cvs_20020108_pre:1.19
	gdb_5_1_0_1-2002-01-03-branchpoint:1.16
	gdb_5_1_0_1-2002-01-03-branch:1.16.0.8
	gdb_5_1-2001-11-21-release:1.16
	gdb_s390-2001-09-26-branch:1.16.0.6
	gdb_s390-2001-09-26-branchpoint:1.16
	gdb_5_1-2001-07-29-branch:1.16.0.4
	gdb_5_1-2001-07-29-branchpoint:1.16
	dberlin-typesystem-branch:1.16.0.2
	dberlin-typesystem-branchpoint:1.16
	gdb-post-ptid_t-2001-05-03:1.15
	gdb-pre-ptid_t-2001-05-03:1.15
	insight-precleanup-2001-01-01:1.12
	gdb-post-protoization-2000-07-29:1.7
	gdb-pre-protoization-2000-07-29:1.6
	gdb-premipsmulti-2000-06-06-branch:1.6.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.6
	gdb-post-params-removal-2000-06-04:1.6
	gdb-pre-params-removal-2000-06-04:1.6
	gdb-post-params-removal-2000-05-28:1.6
	gdb-pre-params-removal-2000-05-28:1.5
	gdb_5_0-2000-05-19-release:1.3
	gdb_4_18_2-2000-05-18-release:1.3
	gdb_4_95_1-2000-05-11-snapshot:1.3
	gdb_4_95_0-2000-04-27-snapshot:1.3
	gdb_5_0-2000-04-10-branch:1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.3
	repo-unification-2000-02-06:1.1.1.9
	insight-2000-02-04:1.1.1.9
	gdb-2000-02-04:1.1.1.9
	gdb-2000-02-02:1.1.1.9
	gdb-2000-02-01:1.1.1.9
	gdb-2000-01-31:1.1.1.9
	gdb-2000-01-26:1.1.1.9
	gdb-2000-01-24:1.1.1.9
	gdb-2000-01-17:1.1.1.9
	gdb-2000-01-10:1.1.1.9
	gdb-2000-01-05:1.1.1.9
	gdb-1999-12-21:1.1.1.9
	gdb-1999-12-13:1.1.1.9
	gdb-1999-12-07:1.1.1.9
	gdb-1999-12-06:1.1.1.9
	gdb-1999-11-16:1.1.1.8
	gdb-1999-11-08:1.1.1.8
	gdb-1999-11-01:1.1.1.8
	gdb-1999-10-25:1.1.1.8
	gdb-1999-10-18:1.1.1.8
	gdb-1999-10-11:1.1.1.8
	gdb-1999-10-04:1.1.1.7
	gdb-1999-09-28:1.1.1.7
	gdb-1999-09-21:1.1.1.7
	gdb-1999-09-13:1.1.1.6
	gdb-1999-09-08:1.1.1.6
	gdb-1999-08-30:1.1.1.5
	gdb-1999-08-23:1.1.1.5
	gdb-1999-08-16:1.1.1.5
	gdb-1999-08-09:1.1.1.4
	gdb-1999-08-02:1.1.1.3
	gdb-1999-07-26:1.1.1.3
	gdb-1999-07-19:1.1.1.3
	gdb-1999-07-12:1.1.1.3
	gdb-post-reformat-19990707:1.1.1.3
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.3
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.171
date	2013.10.09.13.22.36;	author jkratoch;	state Exp;
branches;
next	1.170;

1.170
date	2013.10.07.19.40.38;	author tromey;	state Exp;
branches;
next	1.169;

1.169
date	2013.10.07.19.31.13;	author tromey;	state Exp;
branches;
next	1.168;

1.168
date	2013.09.26.01.08.35;	author devans;	state Exp;
branches;
next	1.167;

1.167
date	2013.09.25.00.15.30;	author devans;	state Exp;
branches;
next	1.166;

1.166
date	2013.09.24.14.00.06;	author jkratoch;	state Exp;
branches;
next	1.165;

1.165
date	2013.09.24.13.57.37;	author jkratoch;	state Exp;
branches;
next	1.164;

1.164
date	2013.09.24.13.51.55;	author jkratoch;	state Exp;
branches;
next	1.163;

1.163
date	2013.08.20.15.04.51;	author tromey;	state Exp;
branches;
next	1.162;

1.162
date	2013.06.24.22.18.31;	author macro;	state Exp;
branches;
next	1.161;

1.161
date	2013.06.04.12.53.34;	author gary;	state Exp;
branches;
next	1.160;

1.160
date	2013.05.06.19.15.17;	author devans;	state Exp;
branches;
next	1.159;

1.159
date	2013.05.04.06.19.31;	author devans;	state Exp;
branches;
next	1.158;

1.158
date	2013.04.08.20.04.42;	author tromey;	state Exp;
branches;
next	1.157;

1.157
date	2013.03.11.08.51.58;	author mmetzger;	state Exp;
branches;
next	1.156;

1.156
date	2013.02.03.15.57.07;	author jkratoch;	state Exp;
branches;
next	1.155;

1.155
date	2013.02.01.19.39.03;	author jkratoch;	state Exp;
branches;
next	1.154;

1.154
date	2013.01.31.18.37.37;	author aristovski;	state Exp;
branches;
next	1.153;

1.153
date	2013.01.02.18.52.07;	author tromey;	state Exp;
branches;
next	1.152;

1.152
date	2013.01.01.06.32.47;	author brobecke;	state Exp;
branches;
next	1.151;

1.151
date	2012.12.18.06.19.54;	author brobecke;	state Exp;
branches;
next	1.150;

1.150
date	2012.12.15.13.11.18;	author brobecke;	state Exp;
branches;
next	1.149;

1.149
date	2012.11.27.08.11.59;	author qiyao;	state Exp;
branches;
next	1.148;

1.148
date	2012.11.20.06.47.25;	author qiyao;	state Exp;
branches;
next	1.147;

1.147
date	2012.08.22.16.44.45;	author tromey;	state Exp;
branches;
next	1.146;

1.146
date	2012.08.22.16.12.50;	author tromey;	state Exp;
branches;
next	1.145;

1.145
date	2012.08.22.16.01.07;	author tromey;	state Exp;
branches;
next	1.144;

1.144
date	2012.08.22.15.31.12;	author tromey;	state Exp;
branches;
next	1.143;

1.143
date	2012.08.22.15.17.21;	author tromey;	state Exp;
branches;
next	1.142;

1.142
date	2012.07.23.14.58.44;	author tromey;	state Exp;
branches;
next	1.141;

1.141
date	2012.07.18.19.33.34;	author tromey;	state Exp;
branches;
next	1.140;

1.140
date	2012.06.05.13.50.50;	author brobecke;	state Exp;
branches;
next	1.139;

1.139
date	2012.05.10.19.50.08;	author tromey;	state Exp;
branches;
next	1.138;

1.138
date	2012.04.27.20.47.55;	author sergiodj;	state Exp;
branches;
next	1.137;

1.137
date	2012.02.21.06.55.36;	author devans;	state Exp;
branches;
next	1.136;

1.136
date	2012.01.04.08.17.08;	author brobecke;	state Exp;
branches;
next	1.135;

1.135
date	2011.12.21.21.51.56;	author tromey;	state Exp;
branches;
next	1.134;

1.134
date	2011.12.21.07.11.52;	author brobecke;	state Exp;
branches;
next	1.133;

1.133
date	2011.12.08.18.08.12;	author tromey;	state Exp;
branches
	1.133.2.1;
next	1.132;

1.132
date	2011.06.14.16.49.41;	author tromey;	state Exp;
branches;
next	1.131;

1.131
date	2011.04.25.19.38.15;	author jkratoch;	state Exp;
branches;
next	1.130;

1.130
date	2011.04.06.00.08.12;	author jkratoch;	state Exp;
branches;
next	1.129;

1.129
date	2011.04.04.15.19.58;	author tromey;	state Exp;
branches;
next	1.128;

1.128
date	2011.04.04.14.37.16;	author tromey;	state Exp;
branches;
next	1.127;

1.127
date	2011.03.07.16.17.29;	author tromey;	state Exp;
branches
	1.127.2.1;
next	1.126;

1.126
date	2011.01.10.20.38.49;	author msnyder;	state Exp;
branches;
next	1.125;

1.125
date	2011.01.05.22.22.49;	author msnyder;	state Exp;
branches;
next	1.124;

1.124
date	2011.01.01.15.33.12;	author brobecke;	state Exp;
branches;
next	1.123;

1.123
date	2010.10.17.17.45.16;	author jkratoch;	state Exp;
branches;
next	1.122;

1.122
date	2010.09.22.20.00.53;	author jkratoch;	state Exp;
branches;
next	1.121;

1.121
date	2010.08.31.20.10.42;	author swagiaal;	state Exp;
branches;
next	1.120;

1.120
date	2010.08.31.17.26.08;	author swagiaal;	state Exp;
branches;
next	1.119;

1.119
date	2010.08.18.19.13.33;	author devans;	state Exp;
branches;
next	1.118;

1.118
date	2010.08.09.19.42.48;	author swagiaal;	state Exp;
branches;
next	1.117;

1.117
date	2010.07.28.16.23.58;	author tromey;	state Exp;
branches;
next	1.116;

1.116
date	2010.05.16.00.46.46;	author msnyder;	state Exp;
branches;
next	1.115;

1.115
date	2010.05.06.22.50.09;	author msnyder;	state Exp;
branches;
next	1.114;

1.114
date	2010.04.27.20.07.01;	author jkratoch;	state Exp;
branches;
next	1.113;

1.113
date	2010.04.14.17.26.11;	author palves;	state Exp;
branches;
next	1.112;

1.112
date	2010.03.10.18.20.06;	author tromey;	state Exp;
branches;
next	1.111;

1.111
date	2010.02.17.22.25.05;	author tromey;	state Exp;
branches;
next	1.110;

1.110
date	2010.02.09.10.59.50;	author gingold;	state Exp;
branches;
next	1.109;

1.109
date	2010.01.11.18.15.05;	author jkratoch;	state Exp;
branches;
next	1.108;

1.108
date	2010.01.09.09.10.59;	author jkratoch;	state Exp;
branches;
next	1.107;

1.107
date	2010.01.06.10.11.04;	author gingold;	state Exp;
branches;
next	1.106;

1.106
date	2010.01.01.07.31.38;	author brobecke;	state Exp;
branches;
next	1.105;

1.105
date	2009.11.11.04.59.47;	author jkratoch;	state Exp;
branches;
next	1.104;

1.104
date	2009.11.05.22.26.10;	author tromey;	state Exp;
branches;
next	1.103;

1.103
date	2009.11.02.14.50.27;	author jkratoch;	state Exp;
branches;
next	1.102;

1.102
date	2009.10.23.14.36.30;	author ppluzhnikov;	state Exp;
branches;
next	1.101;

1.101
date	2009.10.23.13.22.46;	author gingold;	state Exp;
branches;
next	1.100;

1.100
date	2009.10.22.20.20.27;	author ppluzhnikov;	state Exp;
branches;
next	1.99;

1.99
date	2009.10.19.09.51.41;	author palves;	state Exp;
branches;
next	1.98;

1.98
date	2009.10.13.07.56.29;	author gingold;	state Exp;
branches;
next	1.97;

1.97
date	2009.09.18.17.33.51;	author jkratoch;	state Exp;
branches;
next	1.96;

1.96
date	2009.09.14.17.12.07;	author ppluzhnikov;	state Exp;
branches
	1.96.2.1;
next	1.95;

1.95
date	2009.09.11.18.51.31;	author devans;	state Exp;
branches;
next	1.94;

1.94
date	2009.08.27.21.56.38;	author devans;	state Exp;
branches;
next	1.93;

1.93
date	2009.08.21.17.57.17;	author ppluzhnikov;	state Exp;
branches;
next	1.92;

1.92
date	2009.08.17.11.16.13;	author palves;	state Exp;
branches;
next	1.91;

1.91
date	2009.08.10.22.09.22;	author jkratoch;	state Exp;
branches;
next	1.90;

1.90
date	2009.08.10.20.14.14;	author ppluzhnikov;	state Exp;
branches;
next	1.89;

1.89
date	2009.08.04.18.46.05;	author ppluzhnikov;	state Exp;
branches;
next	1.88;

1.88
date	2009.07.28.16.39.06;	author drow;	state Exp;
branches;
next	1.87;

1.87
date	2009.07.22.19.21.31;	author ppluzhnikov;	state Exp;
branches;
next	1.86;

1.86
date	2009.07.21.20.54.30;	author ppluzhnikov;	state Exp;
branches;
next	1.85;

1.85
date	2009.07.14.14.55.06;	author uweigand;	state Exp;
branches;
next	1.84;

1.84
date	2009.06.23.16.28.45;	author ppluzhnikov;	state Exp;
branches;
next	1.83;

1.83
date	2009.05.14.23.33.08;	author ppluzhnikov;	state Exp;
branches;
next	1.82;

1.82
date	2009.03.11.20.26.02;	author drow;	state Exp;
branches;
next	1.81;

1.81
date	2009.01.15.16.35.22;	author uweigand;	state Exp;
branches;
next	1.80;

1.80
date	2009.01.03.05.57.52;	author brobecke;	state Exp;
branches;
next	1.79;

1.79
date	2008.09.05.11.37.17;	author uweigand;	state Exp;
branches
	1.79.4.1;
next	1.78;

1.78
date	2008.08.20.11.21.44;	author palves;	state Exp;
branches;
next	1.77;

1.77
date	2008.08.18.19.44.49;	author tromey;	state Exp;
branches;
next	1.76;

1.76
date	2008.07.30.21.53.07;	author shebs;	state Exp;
branches;
next	1.75;

1.75
date	2008.05.22.16.58.02;	author uweigand;	state Exp;
branches;
next	1.74;

1.74
date	2008.05.03.18.04.02;	author drow;	state Exp;
branches;
next	1.73;

1.73
date	2008.05.02.20.38.16;	author drow;	state Exp;
branches;
next	1.72;

1.72
date	2008.05.02.20.35.39;	author drow;	state Exp;
branches;
next	1.71;

1.71
date	2008.03.26.14.53.28;	author uweigand;	state Exp;
branches;
next	1.70;

1.70
date	2008.01.01.22.53.12;	author drow;	state Exp;
branches;
next	1.69;

1.69
date	2007.12.04.23.43.57;	author jimb;	state Exp;
branches;
next	1.68;

1.68
date	2007.08.23.18.08.36;	author brobecke;	state Exp;
branches;
next	1.67;

1.67
date	2007.06.05.22.46.30;	author uweigand;	state Exp;
branches;
next	1.66;

1.66
date	2007.01.09.17.58.55;	author drow;	state Exp;
branches;
next	1.65;

1.65
date	2006.08.08.17.39.10;	author drow;	state Exp;
branches;
next	1.64;

1.64
date	2006.02.01.23.14.10;	author drow;	state Exp;
branches
	1.64.8.1
	1.64.14.1;
next	1.63;

1.63
date	2006.01.06.16.23.35;	author fnf;	state Exp;
branches;
next	1.62;

1.62
date	2005.12.17.22.34.01;	author eliz;	state Exp;
branches;
next	1.61;

1.61
date	2005.02.11.18.13.51;	author cagney;	state Exp;
branches;
next	1.60;

1.60
date	2005.02.11.04.06.00;	author cagney;	state Exp;
branches;
next	1.59;

1.59
date	2004.10.31.17.48.17;	author cagney;	state Exp;
branches;
next	1.58;

1.58
date	2004.10.31.03.42.52;	author cagney;	state Exp;
branches;
next	1.57;

1.57
date	2004.10.31.02.59.21;	author cagney;	state Exp;
branches;
next	1.56;

1.56
date	2004.09.30.19.57.54;	author kettenis;	state Exp;
branches;
next	1.55;

1.55
date	2004.09.02.03.05.46;	author cagney;	state Exp;
branches;
next	1.54;

1.54
date	2004.08.10.21.52.04;	author cagney;	state Exp;
branches;
next	1.53;

1.53
date	2004.06.24.20.42.42;	author cagney;	state Exp;
branches;
next	1.52;

1.52
date	2004.05.07.14.29.34;	author cagney;	state Exp;
branches;
next	1.51;

1.51
date	2004.02.17.19.37.37;	author ezannoni;	state Exp;
branches
	1.51.2.1
	1.51.8.1;
next	1.50;

1.50
date	2004.02.16.21.14.24;	author drow;	state Exp;
branches;
next	1.49;

1.49
date	2004.02.14.15.46.33;	author ezannoni;	state Exp;
branches;
next	1.48;

1.48
date	2004.02.09.23.50.55;	author ezannoni;	state Exp;
branches;
next	1.47;

1.47
date	2004.02.07.23.13.47;	author ezannoni;	state Exp;
branches;
next	1.46;

1.46
date	2004.02.07.18.29.54;	author ezannoni;	state Exp;
branches;
next	1.45;

1.45
date	2004.02.07.16.57.55;	author ezannoni;	state Exp;
branches;
next	1.44;

1.44
date	2004.01.19.19.56.01;	author cagney;	state Exp;
branches;
next	1.43;

1.43
date	2003.11.23.20.41.17;	author cagney;	state Exp;
branches;
next	1.42;

1.42
date	2003.11.11.20.04.52;	author chastain;	state Exp;
branches;
next	1.41;

1.41
date	2003.11.08.00.13.02;	author cagney;	state Exp;
branches;
next	1.40;

1.40
date	2003.11.06.02.52.27;	author cagney;	state Exp;
branches;
next	1.39;

1.39
date	2003.10.29.18.29.07;	author kettenis;	state Exp;
branches;
next	1.38;

1.38
date	2003.10.20.14.38.42;	author cagney;	state Exp;
branches;
next	1.37;

1.37
date	2003.09.14.16.32.13;	author cagney;	state Exp;
branches;
next	1.36;

1.36
date	2003.09.12.18.40.18;	author cagney;	state Exp;
branches;
next	1.35;

1.35
date	2003.09.11.19.49.18;	author carlton;	state Exp;
branches;
next	1.34;

1.34
date	2003.08.21.22.35.33;	author kettenis;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.11.23.29.47;	author carlton;	state Exp;
branches
	1.33.4.1;
next	1.32;

1.32
date	2003.06.06.23.32.59;	author mmitchel;	state Exp;
branches;
next	1.31;

1.31
date	2003.05.14.17.43.18;	author ezannoni;	state Exp;
branches;
next	1.30;

1.30
date	2003.05.02.17.00.57;	author carlton;	state Exp;
branches;
next	1.29;

1.29
date	2003.02.25.21.36.18;	author carlton;	state Exp;
branches
	1.29.16.1;
next	1.28;

1.28
date	2003.02.20.00.01.06;	author carlton;	state Exp;
branches;
next	1.27;

1.27
date	2003.02.04.21.55.26;	author carlton;	state Exp;
branches;
next	1.26;

1.26
date	2003.02.04.18.07.01;	author drow;	state Exp;
branches;
next	1.25;

1.25
date	2003.02.03.20.39.41;	author jimb;	state Exp;
branches;
next	1.24;

1.24
date	2003.01.23.23.03.31;	author jimb;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2003.01.18.15.55.52;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2002.07.29.22.55.26;	author cagney;	state Exp;
branches
	1.22.6.1
	1.22.8.1
	1.22.10.1
	1.22.12.1;
next	1.21;

1.21
date	2002.07.12.15.23.10;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.15.21.19.18;	author jimb;	state Exp;
branches
	1.20.4.1;
next	1.19;

1.19
date	2001.12.06.20.59.11;	author cagney;	state Exp;
branches
	1.19.4.1;
next	1.18;

1.18
date	2001.12.02.22.38.23;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2001.10.12.23.51.28;	author drow;	state Exp;
branches;
next	1.16;

1.16
date	2001.07.05.21.32.39;	author cagney;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2001.03.06.08.21.11;	author kevinb;	state Exp;
branches;
next	1.14;

1.14
date	2001.02.08.06.03.53;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.19.08.01.46;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2000.12.15.01.01.48;	author kevinb;	state Exp;
branches;
next	1.11;

1.11
date	2000.11.03.19.00.06;	author schauer;	state Exp;
branches;
next	1.10;

1.10
date	2000.09.13.01.47.16;	author kevinb;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.07.15.02.48;	author ezannoni;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.04.23.13.49;	author kevinb;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.30.01.48.26;	author kevinb;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.28.01.12.28;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.22.09.02.23;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.04.16.52.33;	author ezannoni;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.15.16.55.07;	author jimb;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.29.12.58.51;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.133.2.1
date	2012.01.06.04.43.21;	author brobecke;	state Exp;
branches;
next	;

1.127.2.1
date	2011.04.25.21.25.18;	author jkratoch;	state Exp;
branches;
next	;

1.96.2.1
date	2009.09.18.17.39.36;	author jkratoch;	state Exp;
branches;
next	1.96.2.2;

1.96.2.2
date	2009.10.22.20.31.36;	author ppluzhnikov;	state Exp;
branches;
next	;

1.79.4.1
date	2008.11.21.02.31.57;	author shebs;	state Exp;
branches;
next	;

1.64.8.1
date	2006.06.01.20.03.30;	author drow;	state Exp;
branches;
next	1.64.8.2;

1.64.8.2
date	2006.08.17.14.45.29;	author drow;	state Exp;
branches;
next	;

1.64.14.1
date	2006.08.28.07.48.48;	author nickrob;	state Exp;
branches;
next	;

1.51.2.1
date	2004.09.16.17.01.16;	author drow;	state Exp;
branches;
next	;

1.51.8.1
date	2004.03.24.04.10.01;	author ezannoni;	state Exp;
branches;
next	;

1.33.4.1
date	2003.09.14.18.26.46;	author drow;	state Exp;
branches;
next	1.33.4.2;

1.33.4.2
date	2003.10.29.18.40.39;	author kettenis;	state Exp;
branches;
next	;

1.29.16.1
date	2003.05.04.11.37.45;	author kettenis;	state Exp;
branches;
next	1.29.16.2;

1.29.16.2
date	2003.05.18.09.44.18;	author kettenis;	state Exp;
branches;
next	;

1.24.2.1
date	2003.02.03.22.00.55;	author cagney;	state Exp;
branches;
next	;

1.22.6.1
date	2003.02.04.21.59.00;	author carlton;	state Exp;
branches;
next	;

1.22.8.1
date	2002.09.24.00.04.50;	author carlton;	state Exp;
branches;
next	1.22.8.2;

1.22.8.2
date	2002.10.18.23.42.58;	author carlton;	state Exp;
branches;
next	1.22.8.3;

1.22.8.3
date	2003.01.11.01.11.02;	author carlton;	state Exp;
branches;
next	1.22.8.4;

1.22.8.4
date	2003.01.28.00.33.12;	author carlton;	state Exp;
branches;
next	1.22.8.5;

1.22.8.5
date	2003.02.01.01.17.22;	author carlton;	state Exp;
branches;
next	1.22.8.6;

1.22.8.6
date	2003.02.07.19.17.51;	author carlton;	state Exp;
branches;
next	1.22.8.7;

1.22.8.7
date	2003.03.06.00.56.31;	author carlton;	state Exp;
branches;
next	1.22.8.8;

1.22.8.8
date	2003.05.01.00.46.51;	author carlton;	state Exp;
branches;
next	1.22.8.9;

1.22.8.9
date	2003.05.23.18.40.43;	author carlton;	state Exp;
branches;
next	1.22.8.10;

1.22.8.10
date	2003.06.27.21.50.07;	author carlton;	state Exp;
branches;
next	1.22.8.11;

1.22.8.11
date	2003.06.27.22.47.33;	author carlton;	state Exp;
branches;
next	1.22.8.12;

1.22.8.12
date	2003.09.17.21.28.26;	author carlton;	state Exp;
branches;
next	1.22.8.13;

1.22.8.13
date	2003.11.11.23.50.51;	author carlton;	state Exp;
branches;
next	1.22.8.14;

1.22.8.14
date	2003.12.16.00.00.44;	author carlton;	state Exp;
branches;
next	1.22.8.15;

1.22.8.15
date	2004.01.26.19.11.29;	author carlton;	state Exp;
branches;
next	;

1.22.10.1
date	2003.12.14.20.27.22;	author drow;	state Exp;
branches;
next	1.22.10.2;

1.22.10.2
date	2004.02.09.19.43.45;	author drow;	state Exp;
branches;
next	;

1.22.12.1
date	2002.11.26.04.50.34;	author jimb;	state Exp;
branches;
next	1.22.12.2;

1.22.12.2
date	2002.12.17.04.18.13;	author jimb;	state Exp;
branches;
next	;

1.20.4.1
date	2002.07.22.21.47.00;	author kseitz;	state Exp;
branches;
next	1.20.4.2;

1.20.4.2
date	2002.08.09.18.34.26;	author kseitz;	state Exp;
branches;
next	;

1.19.4.1
date	2002.05.09.18.35.54;	author jimb;	state Exp;
branches;
next	;

1.16.2.1
date	2001.07.06.19.17.02;	author dberlin;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.24.53;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.07.20.08.28;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.08.09.21.33.44;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.08.16.19.53.26;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.09.08.23.59.23;	author shebs;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.09.22.03.24.49;	author jsm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	99.10.12.04.37.23;	author jsm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	99.12.07.03.56.03;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.171
log
@New flag OBJF_NOT_FILENAME

gdb/
2013-10-09  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	New flag OBJF_NOT_FILENAME.
	* auto-load.c (auto_load_objfile_script): Check also OBJF_NOT_FILENAME.
	* jit.c (jit_object_close_impl): Use OBJF_NOT_FILENAME for
	allocate_objfile.
	(jit_bfd_try_read_symtab): Use OBJF_NOT_FILENAME for
	symbol_file_add_from_bfd.
	* jv-lang.c (get_dynamics_objfile): Use OBJF_NOT_FILENAME for
	allocate_objfile.
	* objfiles.c (allocate_objfile): Assert OBJF_NOT_FILENAME if NAME is
	NULL.
	* objfiles.h (OBJF_NOT_FILENAME): New.
@
text
@/* GDB routines for manipulating objfiles.

   Copyright (C) 1992-2013 Free Software Foundation, Inc.

   Contributed by Cygnus Support, using pieces from other GDB modules.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* This file contains support routines for creating, manipulating, and
   destroying objfile structures.  */

#include "defs.h"
#include "bfd.h"		/* Binary File Description */
#include "symtab.h"
#include "symfile.h"
#include "objfiles.h"
#include "gdb-stabs.h"
#include "target.h"
#include "bcache.h"
#include "expression.h"
#include "parser-defs.h"

#include "gdb_assert.h"
#include <sys/types.h>
#include "gdb_stat.h"
#include <fcntl.h>
#include "gdb_obstack.h"
#include "gdb_string.h"
#include "hashtab.h"

#include "breakpoint.h"
#include "block.h"
#include "dictionary.h"
#include "source.h"
#include "addrmap.h"
#include "arch-utils.h"
#include "exec.h"
#include "observer.h"
#include "complaints.h"
#include "psymtab.h"
#include "solist.h"
#include "gdb_bfd.h"
#include "btrace.h"

/* Keep a registry of per-objfile data-pointers required by other GDB
   modules.  */

DEFINE_REGISTRY (objfile, REGISTRY_ACCESS_FIELD)

/* Externally visible variables that are owned by this module.
   See declarations in objfile.h for more info.  */

struct objfile_pspace_info
{
  struct obj_section **sections;
  int num_sections;

  /* Nonzero if object files have been added since the section map
     was last updated.  */
  int new_objfiles_available;

  /* Nonzero if the section map MUST be updated before use.  */
  int section_map_dirty;

  /* Nonzero if section map updates should be inhibited if possible.  */
  int inhibit_updates;
};

/* Per-program-space data key.  */
static const struct program_space_data *objfiles_pspace_data;

static void
objfiles_pspace_data_cleanup (struct program_space *pspace, void *arg)
{
  struct objfile_pspace_info *info;

  info = program_space_data (pspace, objfiles_pspace_data);
  if (info != NULL)
    {
      xfree (info->sections);
      xfree (info);
    }
}

/* Get the current svr4 data.  If none is found yet, add it now.  This
   function always returns a valid object.  */

static struct objfile_pspace_info *
get_objfile_pspace_data (struct program_space *pspace)
{
  struct objfile_pspace_info *info;

  info = program_space_data (pspace, objfiles_pspace_data);
  if (info == NULL)
    {
      info = XZALLOC (struct objfile_pspace_info);
      set_program_space_data (pspace, objfiles_pspace_data, info);
    }

  return info;
}



/* Per-BFD data key.  */

static const struct bfd_data *objfiles_bfd_data;

/* Create the per-BFD storage object for OBJFILE.  If ABFD is not
   NULL, and it already has a per-BFD storage object, use that.
   Otherwise, allocate a new per-BFD storage object.  If ABFD is not
   NULL, the object is allocated on the BFD; otherwise it is allocated
   on OBJFILE's obstack.  Note that it is not safe to call this
   multiple times for a given OBJFILE -- it can only be called when
   allocating or re-initializing OBJFILE.  */

static struct objfile_per_bfd_storage *
get_objfile_bfd_data (struct objfile *objfile, struct bfd *abfd)
{
  struct objfile_per_bfd_storage *storage = NULL;

  if (abfd != NULL)
    storage = bfd_data (abfd, objfiles_bfd_data);

  if (storage == NULL)
    {
      /* If the object requires gdb to do relocations, we simply fall
	 back to not sharing data across users.  These cases are rare
	 enough that this seems reasonable.  */
      if (abfd != NULL && !gdb_bfd_requires_relocations (abfd))
	{
	  storage = bfd_zalloc (abfd, sizeof (struct objfile_per_bfd_storage));
	  set_bfd_data (abfd, objfiles_bfd_data, storage);
	}
      else
	storage = OBSTACK_ZALLOC (&objfile->objfile_obstack,
				  struct objfile_per_bfd_storage);

      /* Look up the gdbarch associated with the BFD.  */
      if (abfd != NULL)
	storage->gdbarch = gdbarch_from_bfd (abfd);

      obstack_init (&storage->storage_obstack);
      storage->filename_cache = bcache_xmalloc (NULL, NULL);
      storage->macro_cache = bcache_xmalloc (NULL, NULL);
    }

  return storage;
}

/* Free STORAGE.  */

static void
free_objfile_per_bfd_storage (struct objfile_per_bfd_storage *storage)
{
  bcache_xfree (storage->filename_cache);
  bcache_xfree (storage->macro_cache);
  if (storage->demangled_names_hash)
    htab_delete (storage->demangled_names_hash);
  obstack_free (&storage->storage_obstack, 0);
}

/* A wrapper for free_objfile_per_bfd_storage that can be passed as a
   cleanup function to the BFD registry.  */

static void
objfile_bfd_data_free (struct bfd *unused, void *d)
{
  free_objfile_per_bfd_storage (d);
}

/* See objfiles.h.  */

void
set_objfile_per_bfd (struct objfile *objfile)
{
  objfile->per_bfd = get_objfile_bfd_data (objfile, objfile->obfd);
}



/* Called via bfd_map_over_sections to build up the section table that
   the objfile references.  The objfile contains pointers to the start
   of the table (objfile->sections) and to the first location after
   the end of the table (objfile->sections_end).  */

static void
add_to_objfile_sections_full (struct bfd *abfd, struct bfd_section *asect,
			      struct objfile *objfile, int force)
{
  struct obj_section *section;

  if (!force)
    {
      flagword aflag;

      aflag = bfd_get_section_flags (abfd, asect);
      if (!(aflag & SEC_ALLOC))
	return;
    }

  section = &objfile->sections[gdb_bfd_section_index (abfd, asect)];
  section->objfile = objfile;
  section->the_bfd_section = asect;
  section->ovly_mapped = 0;
}

static void
add_to_objfile_sections (struct bfd *abfd, struct bfd_section *asect,
			 void *objfilep)
{
  add_to_objfile_sections_full (abfd, asect, objfilep, 0);
}

/* Builds a section table for OBJFILE.

   Note that the OFFSET and OVLY_MAPPED in each table entry are
   initialized to zero.  */

void
build_objfile_section_table (struct objfile *objfile)
{
  int count = gdb_bfd_count_sections (objfile->obfd);

  objfile->sections = OBSTACK_CALLOC (&objfile->objfile_obstack,
				      count,
				      struct obj_section);
  objfile->sections_end = (objfile->sections + count);
  bfd_map_over_sections (objfile->obfd,
			 add_to_objfile_sections, (void *) objfile);

  /* See gdb_bfd_section_index.  */
  add_to_objfile_sections_full (objfile->obfd, bfd_com_section_ptr, objfile, 1);
  add_to_objfile_sections_full (objfile->obfd, bfd_und_section_ptr, objfile, 1);
  add_to_objfile_sections_full (objfile->obfd, bfd_abs_section_ptr, objfile, 1);
  add_to_objfile_sections_full (objfile->obfd, bfd_ind_section_ptr, objfile, 1);
}

/* Given a pointer to an initialized bfd (ABFD) and some flag bits
   allocate a new objfile struct, fill it in as best we can, link it
   into the list of all known objfiles, and return a pointer to the
   new objfile struct.

   NAME should contain original non-canonicalized filename or other
   identifier as entered by user.  If there is no better source use
   bfd_get_filename (ABFD).  NAME may be NULL only if ABFD is NULL.
   NAME content is copied into returned objfile.

   The FLAGS word contains various bits (OBJF_*) that can be taken as
   requests for specific operations.  Other bits like OBJF_SHARED are
   simply copied through to the new objfile flags member.  */

/* NOTE: carlton/2003-02-04: This function is called with args NULL, 0
   by jv-lang.c, to create an artificial objfile used to hold
   information about dynamically-loaded Java classes.  Unfortunately,
   that branch of this function doesn't get tested very frequently, so
   it's prone to breakage.  (E.g. at one time the name was set to NULL
   in that situation, which broke a loop over all names in the dynamic
   library loader.)  If you change this function, please try to leave
   things in a consistent state even if abfd is NULL.  */

struct objfile *
allocate_objfile (bfd *abfd, const char *name, int flags)
{
  struct objfile *objfile;

  objfile = (struct objfile *) xzalloc (sizeof (struct objfile));
  objfile->psymbol_cache = psymbol_bcache_init ();
  /* We could use obstack_specify_allocation here instead, but
     gdb_obstack.h specifies the alloc/dealloc functions.  */
  obstack_init (&objfile->objfile_obstack);
  terminate_minimal_symbol_table (objfile);

  objfile_alloc_data (objfile);

  if (name == NULL)
    {
      gdb_assert (abfd == NULL);
      gdb_assert ((flags & OBJF_NOT_FILENAME) != 0);
      name = "<<anonymous objfile>>";
    }
  objfile->original_name = obstack_copy0 (&objfile->objfile_obstack, name,
					  strlen (name));

  /* Update the per-objfile information that comes from the bfd, ensuring
     that any data that is reference is saved in the per-objfile data
     region.  */

  objfile->obfd = abfd;
  gdb_bfd_ref (abfd);
  if (abfd != NULL)
    {
      objfile->mtime = bfd_get_mtime (abfd);

      /* Build section table.  */
      build_objfile_section_table (objfile);
    }

  objfile->per_bfd = get_objfile_bfd_data (objfile, abfd);
  objfile->pspace = current_program_space;

  /* Initialize the section indexes for this objfile, so that we can
     later detect if they are used w/o being properly assigned to.  */

  objfile->sect_index_text = -1;
  objfile->sect_index_data = -1;
  objfile->sect_index_bss = -1;
  objfile->sect_index_rodata = -1;

  /* Add this file onto the tail of the linked list of other such files.  */

  objfile->next = NULL;
  if (object_files == NULL)
    object_files = objfile;
  else
    {
      struct objfile *last_one;

      for (last_one = object_files;
	   last_one->next;
	   last_one = last_one->next);
      last_one->next = objfile;
    }

  /* Save passed in flag bits.  */
  objfile->flags |= flags;

  /* Rebuild section map next time we need it.  */
  get_objfile_pspace_data (objfile->pspace)->new_objfiles_available = 1;

  return objfile;
}

/* Retrieve the gdbarch associated with OBJFILE.  */
struct gdbarch *
get_objfile_arch (struct objfile *objfile)
{
  return objfile->per_bfd->gdbarch;
}

/* If there is a valid and known entry point, function fills *ENTRY_P with it
   and returns non-zero; otherwise it returns zero.  */

int
entry_point_address_query (CORE_ADDR *entry_p)
{
  if (symfile_objfile == NULL || !symfile_objfile->ei.entry_point_p)
    return 0;

  *entry_p = symfile_objfile->ei.entry_point;

  return 1;
}

/* Get current entry point address.  Call error if it is not known.  */

CORE_ADDR
entry_point_address (void)
{
  CORE_ADDR retval;

  if (!entry_point_address_query (&retval))
    error (_("Entry point address is not known."));

  return retval;
}

/* Iterator on PARENT and every separate debug objfile of PARENT.
   The usage pattern is:
     for (objfile = parent;
          objfile;
          objfile = objfile_separate_debug_iterate (parent, objfile))
       ...
*/

struct objfile *
objfile_separate_debug_iterate (const struct objfile *parent,
                                const struct objfile *objfile)
{
  struct objfile *res;

  /* If any, return the first child.  */
  res = objfile->separate_debug_objfile;
  if (res)
    return res;

  /* Common case where there is no separate debug objfile.  */
  if (objfile == parent)
    return NULL;

  /* Return the brother if any.  Note that we don't iterate on brothers of
     the parents.  */
  res = objfile->separate_debug_objfile_link;
  if (res)
    return res;

  for (res = objfile->separate_debug_objfile_backlink;
       res != parent;
       res = res->separate_debug_objfile_backlink)
    {
      gdb_assert (res != NULL);
      if (res->separate_debug_objfile_link)
        return res->separate_debug_objfile_link;
    }
  return NULL;
}

/* Put one object file before a specified on in the global list.
   This can be used to make sure an object file is destroyed before
   another when using ALL_OBJFILES_SAFE to free all objfiles.  */
void
put_objfile_before (struct objfile *objfile, struct objfile *before_this)
{
  struct objfile **objp;

  unlink_objfile (objfile);
  
  for (objp = &object_files; *objp != NULL; objp = &((*objp)->next))
    {
      if (*objp == before_this)
	{
	  objfile->next = *objp;
	  *objp = objfile;
	  return;
	}
    }
  
  internal_error (__FILE__, __LINE__,
		  _("put_objfile_before: before objfile not in list"));
}

/* Put OBJFILE at the front of the list.  */

void
objfile_to_front (struct objfile *objfile)
{
  struct objfile **objp;
  for (objp = &object_files; *objp != NULL; objp = &((*objp)->next))
    {
      if (*objp == objfile)
	{
	  /* Unhook it from where it is.  */
	  *objp = objfile->next;
	  /* Put it in the front.  */
	  objfile->next = object_files;
	  object_files = objfile;
	  break;
	}
    }
}

/* Unlink OBJFILE from the list of known objfiles, if it is found in the
   list.

   It is not a bug, or error, to call this function if OBJFILE is not known
   to be in the current list.  This is done in the case of mapped objfiles,
   for example, just to ensure that the mapped objfile doesn't appear twice
   in the list.  Since the list is threaded, linking in a mapped objfile
   twice would create a circular list.

   If OBJFILE turns out to be in the list, we zap it's NEXT pointer after
   unlinking it, just to ensure that we have completely severed any linkages
   between the OBJFILE and the list.  */

void
unlink_objfile (struct objfile *objfile)
{
  struct objfile **objpp;

  for (objpp = &object_files; *objpp != NULL; objpp = &((*objpp)->next))
    {
      if (*objpp == objfile)
	{
	  *objpp = (*objpp)->next;
	  objfile->next = NULL;
	  return;
	}
    }

  internal_error (__FILE__, __LINE__,
		  _("unlink_objfile: objfile already unlinked"));
}

/* Add OBJFILE as a separate debug objfile of PARENT.  */

void
add_separate_debug_objfile (struct objfile *objfile, struct objfile *parent)
{
  gdb_assert (objfile && parent);

  /* Must not be already in a list.  */
  gdb_assert (objfile->separate_debug_objfile_backlink == NULL);
  gdb_assert (objfile->separate_debug_objfile_link == NULL);
  gdb_assert (objfile->separate_debug_objfile == NULL);
  gdb_assert (parent->separate_debug_objfile_backlink == NULL);
  gdb_assert (parent->separate_debug_objfile_link == NULL);

  objfile->separate_debug_objfile_backlink = parent;
  objfile->separate_debug_objfile_link = parent->separate_debug_objfile;
  parent->separate_debug_objfile = objfile;

  /* Put the separate debug object before the normal one, this is so that
     usage of the ALL_OBJFILES_SAFE macro will stay safe.  */
  put_objfile_before (objfile, parent);
}

/* Free all separate debug objfile of OBJFILE, but don't free OBJFILE
   itself.  */

void
free_objfile_separate_debug (struct objfile *objfile)
{
  struct objfile *child;

  for (child = objfile->separate_debug_objfile; child;)
    {
      struct objfile *next_child = child->separate_debug_objfile_link;
      free_objfile (child);
      child = next_child;
    }
}

/* Destroy an objfile and all the symtabs and psymtabs under it.  Note
   that as much as possible is allocated on the objfile_obstack 
   so that the memory can be efficiently freed.

   Things which we do NOT free because they are not in malloc'd memory
   or not in memory specific to the objfile include:

   objfile -> sf

   FIXME:  If the objfile is using reusable symbol information (via mmalloc),
   then we need to take into account the fact that more than one process
   may be using the symbol information at the same time (when mmalloc is
   extended to support cooperative locking).  When more than one process
   is using the mapped symbol info, we need to be more careful about when
   we free objects in the reusable area.  */

void
free_objfile (struct objfile *objfile)
{
  /* Free all separate debug objfiles.  */
  free_objfile_separate_debug (objfile);

  if (objfile->separate_debug_objfile_backlink)
    {
      /* We freed the separate debug file, make sure the base objfile
	 doesn't reference it.  */
      struct objfile *child;

      child = objfile->separate_debug_objfile_backlink->separate_debug_objfile;

      if (child == objfile)
        {
          /* OBJFILE is the first child.  */
          objfile->separate_debug_objfile_backlink->separate_debug_objfile =
            objfile->separate_debug_objfile_link;
        }
      else
        {
          /* Find OBJFILE in the list.  */
          while (1)
            {
              if (child->separate_debug_objfile_link == objfile)
                {
                  child->separate_debug_objfile_link =
                    objfile->separate_debug_objfile_link;
                  break;
                }
              child = child->separate_debug_objfile_link;
              gdb_assert (child);
            }
        }
    }
  
  /* Remove any references to this objfile in the global value
     lists.  */
  preserve_values (objfile);

  /* It still may reference data modules have associated with the objfile and
     the symbol file data.  */
  forget_cached_source_info_for_objfile (objfile);

  breakpoint_free_objfile (objfile);
  btrace_free_objfile (objfile);

  /* First do any symbol file specific actions required when we are
     finished with a particular symbol file.  Note that if the objfile
     is using reusable symbol information (via mmalloc) then each of
     these routines is responsible for doing the correct thing, either
     freeing things which are valid only during this particular gdb
     execution, or leaving them to be reused during the next one.  */

  if (objfile->sf != NULL)
    {
      (*objfile->sf->sym_finish) (objfile);
    }

  /* Discard any data modules have associated with the objfile.  The function
     still may reference objfile->obfd.  */
  objfile_free_data (objfile);

  if (objfile->obfd)
    gdb_bfd_unref (objfile->obfd);
  else
    free_objfile_per_bfd_storage (objfile->per_bfd);

  /* Remove it from the chain of all objfiles.  */

  unlink_objfile (objfile);

  if (objfile == symfile_objfile)
    symfile_objfile = NULL;

  /* Before the symbol table code was redone to make it easier to
     selectively load and remove information particular to a specific
     linkage unit, gdb used to do these things whenever the monolithic
     symbol table was blown away.  How much still needs to be done
     is unknown, but we play it safe for now and keep each action until
     it is shown to be no longer needed.  */

  /* Not all our callers call clear_symtab_users (objfile_purge_solibs,
     for example), so we need to call this here.  */
  clear_pc_function_cache ();

  /* Clear globals which might have pointed into a removed objfile.
     FIXME: It's not clear which of these are supposed to persist
     between expressions and which ought to be reset each time.  */
  expression_context_block = NULL;
  innermost_block = NULL;

  /* Check to see if the current_source_symtab belongs to this objfile,
     and if so, call clear_current_source_symtab_and_line.  */

  {
    struct symtab_and_line cursal = get_current_source_symtab_and_line ();

    if (cursal.symtab && cursal.symtab->objfile == objfile)
      clear_current_source_symtab_and_line ();
  }

  if (objfile->global_psymbols.list)
    xfree (objfile->global_psymbols.list);
  if (objfile->static_psymbols.list)
    xfree (objfile->static_psymbols.list);
  /* Free the obstacks for non-reusable objfiles.  */
  psymbol_bcache_free (objfile->psymbol_cache);
  obstack_free (&objfile->objfile_obstack, 0);

  /* Rebuild section map next time we need it.  */
  get_objfile_pspace_data (objfile->pspace)->section_map_dirty = 1;

  /* The last thing we do is free the objfile struct itself.  */
  xfree (objfile);
}

static void
do_free_objfile_cleanup (void *obj)
{
  free_objfile (obj);
}

struct cleanup *
make_cleanup_free_objfile (struct objfile *obj)
{
  return make_cleanup (do_free_objfile_cleanup, obj);
}

/* Free all the object files at once and clean up their users.  */

void
free_all_objfiles (void)
{
  struct objfile *objfile, *temp;
  struct so_list *so;

  /* Any objfile referencewould become stale.  */
  for (so = master_so_list (); so; so = so->next)
    gdb_assert (so->objfile == NULL);

  ALL_OBJFILES_SAFE (objfile, temp)
  {
    free_objfile (objfile);
  }
  clear_symtab_users (0);
}

/* A helper function for objfile_relocate1 that relocates a single
   symbol.  */

static void
relocate_one_symbol (struct symbol *sym, struct objfile *objfile,
		     struct section_offsets *delta)
{
  fixup_symbol_section (sym, objfile);

  /* The RS6000 code from which this was taken skipped
     any symbols in STRUCT_DOMAIN or UNDEF_DOMAIN.
     But I'm leaving out that test, on the theory that
     they can't possibly pass the tests below.  */
  if ((SYMBOL_CLASS (sym) == LOC_LABEL
       || SYMBOL_CLASS (sym) == LOC_STATIC)
      && SYMBOL_SECTION (sym) >= 0)
    {
      SYMBOL_VALUE_ADDRESS (sym) += ANOFFSET (delta, SYMBOL_SECTION (sym));
    }
}

/* Relocate OBJFILE to NEW_OFFSETS.  There should be OBJFILE->NUM_SECTIONS
   entries in new_offsets.  SEPARATE_DEBUG_OBJFILE is not touched here.
   Return non-zero iff any change happened.  */

static int
objfile_relocate1 (struct objfile *objfile, 
		   const struct section_offsets *new_offsets)
{
  struct obj_section *s;
  struct section_offsets *delta =
    ((struct section_offsets *) 
     alloca (SIZEOF_N_SECTION_OFFSETS (objfile->num_sections)));

  int i;
  int something_changed = 0;

  for (i = 0; i < objfile->num_sections; ++i)
    {
      delta->offsets[i] =
	ANOFFSET (new_offsets, i) - ANOFFSET (objfile->section_offsets, i);
      if (ANOFFSET (delta, i) != 0)
	something_changed = 1;
    }
  if (!something_changed)
    return 0;

  /* OK, get all the symtabs.  */
  {
    struct symtab *s;

    ALL_OBJFILE_SYMTABS (objfile, s)
    {
      struct linetable *l;
      struct blockvector *bv;
      int i;

      /* First the line table.  */
      l = LINETABLE (s);
      if (l)
	{
	  for (i = 0; i < l->nitems; ++i)
	    l->item[i].pc += ANOFFSET (delta, s->block_line_section);
	}

      /* Don't relocate a shared blockvector more than once.  */
      if (!s->primary)
	continue;

      bv = BLOCKVECTOR (s);
      if (BLOCKVECTOR_MAP (bv))
	addrmap_relocate (BLOCKVECTOR_MAP (bv),
			  ANOFFSET (delta, s->block_line_section));

      for (i = 0; i < BLOCKVECTOR_NBLOCKS (bv); ++i)
	{
	  struct block *b;
	  struct symbol *sym;
	  struct dict_iterator iter;

	  b = BLOCKVECTOR_BLOCK (bv, i);
	  BLOCK_START (b) += ANOFFSET (delta, s->block_line_section);
	  BLOCK_END (b) += ANOFFSET (delta, s->block_line_section);

	  /* We only want to iterate over the local symbols, not any
	     symbols in included symtabs.  */
	  ALL_DICT_SYMBOLS (BLOCK_DICT (b), iter, sym)
	    {
	      relocate_one_symbol (sym, objfile, delta);
	    }
	}
    }
  }

  /* Relocate isolated symbols.  */
  {
    struct symbol *iter;

    for (iter = objfile->template_symbols; iter; iter = iter->hash_next)
      relocate_one_symbol (iter, objfile, delta);
  }

  if (objfile->psymtabs_addrmap)
    addrmap_relocate (objfile->psymtabs_addrmap,
		      ANOFFSET (delta, SECT_OFF_TEXT (objfile)));

  if (objfile->sf)
    objfile->sf->qf->relocate (objfile, new_offsets, delta);

  {
    struct minimal_symbol *msym;

    ALL_OBJFILE_MSYMBOLS (objfile, msym)
      if (SYMBOL_SECTION (msym) >= 0)
      SYMBOL_VALUE_ADDRESS (msym) += ANOFFSET (delta, SYMBOL_SECTION (msym));
  }
  /* Relocating different sections by different amounts may cause the symbols
     to be out of order.  */
  msymbols_sort (objfile);

  if (objfile->ei.entry_point_p)
    {
      /* Relocate ei.entry_point with its section offset, use SECT_OFF_TEXT
	 only as a fallback.  */
      struct obj_section *s;
      s = find_pc_section (objfile->ei.entry_point);
      if (s)
	{
	  int idx = gdb_bfd_section_index (objfile->obfd, s->the_bfd_section);

	  objfile->ei.entry_point += ANOFFSET (delta, idx);
	}
      else
        objfile->ei.entry_point += ANOFFSET (delta, SECT_OFF_TEXT (objfile));
    }

  {
    int i;

    for (i = 0; i < objfile->num_sections; ++i)
      (objfile->section_offsets)->offsets[i] = ANOFFSET (new_offsets, i);
  }

  /* Rebuild section map next time we need it.  */
  get_objfile_pspace_data (objfile->pspace)->section_map_dirty = 1;

  /* Update the table in exec_ops, used to read memory.  */
  ALL_OBJFILE_OSECTIONS (objfile, s)
    {
      int idx = s - objfile->sections;

      exec_set_section_address (bfd_get_filename (objfile->obfd), idx,
				obj_section_addr (s));
    }

  /* Relocating probes.  */
  if (objfile->sf && objfile->sf->sym_probe_fns)
    objfile->sf->sym_probe_fns->sym_relocate_probe (objfile,
						    new_offsets, delta);

  /* Data changed.  */
  return 1;
}

/* Relocate OBJFILE to NEW_OFFSETS.  There should be OBJFILE->NUM_SECTIONS
   entries in new_offsets.  Process also OBJFILE's SEPARATE_DEBUG_OBJFILEs.

   The number and ordering of sections does differ between the two objfiles.
   Only their names match.  Also the file offsets will differ (objfile being
   possibly prelinked but separate_debug_objfile is probably not prelinked) but
   the in-memory absolute address as specified by NEW_OFFSETS must match both
   files.  */

void
objfile_relocate (struct objfile *objfile,
		  const struct section_offsets *new_offsets)
{
  struct objfile *debug_objfile;
  int changed = 0;

  changed |= objfile_relocate1 (objfile, new_offsets);

  for (debug_objfile = objfile->separate_debug_objfile;
       debug_objfile;
       debug_objfile = objfile_separate_debug_iterate (objfile, debug_objfile))
    {
      struct section_addr_info *objfile_addrs;
      struct section_offsets *new_debug_offsets;
      struct cleanup *my_cleanups;

      objfile_addrs = build_section_addr_info_from_objfile (objfile);
      my_cleanups = make_cleanup (xfree, objfile_addrs);

      /* Here OBJFILE_ADDRS contain the correct absolute addresses, the
	 relative ones must be already created according to debug_objfile.  */

      addr_info_make_relative (objfile_addrs, debug_objfile->obfd);

      gdb_assert (debug_objfile->num_sections
		  == gdb_bfd_count_sections (debug_objfile->obfd));
      new_debug_offsets = 
	xmalloc (SIZEOF_N_SECTION_OFFSETS (debug_objfile->num_sections));
      make_cleanup (xfree, new_debug_offsets);
      relative_addr_info_to_section_offsets (new_debug_offsets,
					     debug_objfile->num_sections,
					     objfile_addrs);

      changed |= objfile_relocate1 (debug_objfile, new_debug_offsets);

      do_cleanups (my_cleanups);
    }

  /* Relocate breakpoints as necessary, after things are relocated.  */
  if (changed)
    breakpoint_re_set ();
}

/* Rebase (add to the offsets) OBJFILE by SLIDE.  SEPARATE_DEBUG_OBJFILE is
   not touched here.
   Return non-zero iff any change happened.  */

static int
objfile_rebase1 (struct objfile *objfile, CORE_ADDR slide)
{
  struct section_offsets *new_offsets =
    ((struct section_offsets *)
     alloca (SIZEOF_N_SECTION_OFFSETS (objfile->num_sections)));
  int i;

  for (i = 0; i < objfile->num_sections; ++i)
    new_offsets->offsets[i] = slide;

  return objfile_relocate1 (objfile, new_offsets);
}

/* Rebase (add to the offsets) OBJFILE by SLIDE.  Process also OBJFILE's
   SEPARATE_DEBUG_OBJFILEs.  */

void
objfile_rebase (struct objfile *objfile, CORE_ADDR slide)
{
  struct objfile *debug_objfile;
  int changed = 0;

  changed |= objfile_rebase1 (objfile, slide);

  for (debug_objfile = objfile->separate_debug_objfile;
       debug_objfile;
       debug_objfile = objfile_separate_debug_iterate (objfile, debug_objfile))
    changed |= objfile_rebase1 (debug_objfile, slide);

  /* Relocate breakpoints as necessary, after things are relocated.  */
  if (changed)
    breakpoint_re_set ();
}

/* Return non-zero if OBJFILE has partial symbols.  */

int
objfile_has_partial_symbols (struct objfile *objfile)
{
  if (!objfile->sf)
    return 0;

  /* If we have not read psymbols, but we have a function capable of reading
     them, then that is an indication that they are in fact available.  Without
     this function the symbols may have been already read in but they also may
     not be present in this objfile.  */
  if ((objfile->flags & OBJF_PSYMTABS_READ) == 0
      && objfile->sf->sym_read_psymbols != NULL)
    return 1;

  return objfile->sf->qf->has_symbols (objfile);
}

/* Return non-zero if OBJFILE has full symbols.  */

int
objfile_has_full_symbols (struct objfile *objfile)
{
  return objfile->symtabs != NULL;
}

/* Return non-zero if OBJFILE has full or partial symbols, either directly
   or through a separate debug file.  */

int
objfile_has_symbols (struct objfile *objfile)
{
  struct objfile *o;

  for (o = objfile; o; o = objfile_separate_debug_iterate (objfile, o))
    if (objfile_has_partial_symbols (o) || objfile_has_full_symbols (o))
      return 1;
  return 0;
}


/* Many places in gdb want to test just to see if we have any partial
   symbols available.  This function returns zero if none are currently
   available, nonzero otherwise.  */

int
have_partial_symbols (void)
{
  struct objfile *ofp;

  ALL_OBJFILES (ofp)
  {
    if (objfile_has_partial_symbols (ofp))
      return 1;
  }
  return 0;
}

/* Many places in gdb want to test just to see if we have any full
   symbols available.  This function returns zero if none are currently
   available, nonzero otherwise.  */

int
have_full_symbols (void)
{
  struct objfile *ofp;

  ALL_OBJFILES (ofp)
  {
    if (objfile_has_full_symbols (ofp))
      return 1;
  }
  return 0;
}


/* This operations deletes all objfile entries that represent solibs that
   weren't explicitly loaded by the user, via e.g., the add-symbol-file
   command.  */

void
objfile_purge_solibs (void)
{
  struct objfile *objf;
  struct objfile *temp;

  ALL_OBJFILES_SAFE (objf, temp)
  {
    /* We assume that the solib package has been purged already, or will
       be soon.  */

    if (!(objf->flags & OBJF_USERLOADED) && (objf->flags & OBJF_SHARED))
      free_objfile (objf);
  }
}


/* Many places in gdb want to test just to see if we have any minimal
   symbols available.  This function returns zero if none are currently
   available, nonzero otherwise.  */

int
have_minimal_symbols (void)
{
  struct objfile *ofp;

  ALL_OBJFILES (ofp)
  {
    if (ofp->minimal_symbol_count > 0)
      {
	return 1;
      }
  }
  return 0;
}

/* Qsort comparison function.  */

static int
qsort_cmp (const void *a, const void *b)
{
  const struct obj_section *sect1 = *(const struct obj_section **) a;
  const struct obj_section *sect2 = *(const struct obj_section **) b;
  const CORE_ADDR sect1_addr = obj_section_addr (sect1);
  const CORE_ADDR sect2_addr = obj_section_addr (sect2);

  if (sect1_addr < sect2_addr)
    return -1;
  else if (sect1_addr > sect2_addr)
    return 1;
  else
    {
      /* Sections are at the same address.  This could happen if
	 A) we have an objfile and a separate debuginfo.
	 B) we are confused, and have added sections without proper relocation,
	 or something like that.  */

      const struct objfile *const objfile1 = sect1->objfile;
      const struct objfile *const objfile2 = sect2->objfile;

      if (objfile1->separate_debug_objfile == objfile2
	  || objfile2->separate_debug_objfile == objfile1)
	{
	  /* Case A.  The ordering doesn't matter: separate debuginfo files
	     will be filtered out later.  */

	  return 0;
	}

      /* Case B.  Maintain stable sort order, so bugs in GDB are easier to
	 triage.  This section could be slow (since we iterate over all
	 objfiles in each call to qsort_cmp), but this shouldn't happen
	 very often (GDB is already in a confused state; one hopes this
	 doesn't happen at all).  If you discover that significant time is
	 spent in the loops below, do 'set complaints 100' and examine the
	 resulting complaints.  */

      if (objfile1 == objfile2)
	{
	  /* Both sections came from the same objfile.  We are really confused.
	     Sort on sequence order of sections within the objfile.  */

	  const struct obj_section *osect;

	  ALL_OBJFILE_OSECTIONS (objfile1, osect)
	    if (osect == sect1)
	      return -1;
	    else if (osect == sect2)
	      return 1;

	  /* We should have found one of the sections before getting here.  */
	  gdb_assert_not_reached ("section not found");
	}
      else
	{
	  /* Sort on sequence number of the objfile in the chain.  */

	  const struct objfile *objfile;

	  ALL_OBJFILES (objfile)
	    if (objfile == objfile1)
	      return -1;
	    else if (objfile == objfile2)
	      return 1;

	  /* We should have found one of the objfiles before getting here.  */
	  gdb_assert_not_reached ("objfile not found");
	}
    }

  /* Unreachable.  */
  gdb_assert_not_reached ("unexpected code path");
  return 0;
}

/* Select "better" obj_section to keep.  We prefer the one that came from
   the real object, rather than the one from separate debuginfo.
   Most of the time the two sections are exactly identical, but with
   prelinking the .rel.dyn section in the real object may have different
   size.  */

static struct obj_section *
preferred_obj_section (struct obj_section *a, struct obj_section *b)
{
  gdb_assert (obj_section_addr (a) == obj_section_addr (b));
  gdb_assert ((a->objfile->separate_debug_objfile == b->objfile)
	      || (b->objfile->separate_debug_objfile == a->objfile));
  gdb_assert ((a->objfile->separate_debug_objfile_backlink == b->objfile)
	      || (b->objfile->separate_debug_objfile_backlink == a->objfile));

  if (a->objfile->separate_debug_objfile != NULL)
    return a;
  return b;
}

/* Return 1 if SECTION should be inserted into the section map.
   We want to insert only non-overlay and non-TLS section.  */

static int
insert_section_p (const struct bfd *abfd,
		  const struct bfd_section *section)
{
  const bfd_vma lma = bfd_section_lma (abfd, section);

  if (overlay_debugging && lma != 0 && lma != bfd_section_vma (abfd, section)
      && (bfd_get_file_flags (abfd) & BFD_IN_MEMORY) == 0)
    /* This is an overlay section.  IN_MEMORY check is needed to avoid
       discarding sections from the "system supplied DSO" (aka vdso)
       on some Linux systems (e.g. Fedora 11).  */
    return 0;
  if ((bfd_get_section_flags (abfd, section) & SEC_THREAD_LOCAL) != 0)
    /* This is a TLS section.  */
    return 0;

  return 1;
}

/* Filter out overlapping sections where one section came from the real
   objfile, and the other from a separate debuginfo file.
   Return the size of table after redundant sections have been eliminated.  */

static int
filter_debuginfo_sections (struct obj_section **map, int map_size)
{
  int i, j;

  for (i = 0, j = 0; i < map_size - 1; i++)
    {
      struct obj_section *const sect1 = map[i];
      struct obj_section *const sect2 = map[i + 1];
      const struct objfile *const objfile1 = sect1->objfile;
      const struct objfile *const objfile2 = sect2->objfile;
      const CORE_ADDR sect1_addr = obj_section_addr (sect1);
      const CORE_ADDR sect2_addr = obj_section_addr (sect2);

      if (sect1_addr == sect2_addr
	  && (objfile1->separate_debug_objfile == objfile2
	      || objfile2->separate_debug_objfile == objfile1))
	{
	  map[j++] = preferred_obj_section (sect1, sect2);
	  ++i;
	}
      else
	map[j++] = sect1;
    }

  if (i < map_size)
    {
      gdb_assert (i == map_size - 1);
      map[j++] = map[i];
    }

  /* The map should not have shrunk to less than half the original size.  */
  gdb_assert (map_size / 2 <= j);

  return j;
}

/* Filter out overlapping sections, issuing a warning if any are found.
   Overlapping sections could really be overlay sections which we didn't
   classify as such in insert_section_p, or we could be dealing with a
   corrupt binary.  */

static int
filter_overlapping_sections (struct obj_section **map, int map_size)
{
  int i, j;

  for (i = 0, j = 0; i < map_size - 1; )
    {
      int k;

      map[j++] = map[i];
      for (k = i + 1; k < map_size; k++)
	{
	  struct obj_section *const sect1 = map[i];
	  struct obj_section *const sect2 = map[k];
	  const CORE_ADDR sect1_addr = obj_section_addr (sect1);
	  const CORE_ADDR sect2_addr = obj_section_addr (sect2);
	  const CORE_ADDR sect1_endaddr = obj_section_endaddr (sect1);

	  gdb_assert (sect1_addr <= sect2_addr);

	  if (sect1_endaddr <= sect2_addr)
	    break;
	  else
	    {
	      /* We have an overlap.  Report it.  */

	      struct objfile *const objf1 = sect1->objfile;
	      struct objfile *const objf2 = sect2->objfile;

	      const struct bfd_section *const bfds1 = sect1->the_bfd_section;
	      const struct bfd_section *const bfds2 = sect2->the_bfd_section;

	      const CORE_ADDR sect2_endaddr = obj_section_endaddr (sect2);

	      struct gdbarch *const gdbarch = get_objfile_arch (objf1);

	      complaint (&symfile_complaints,
			 _("unexpected overlap between:\n"
			   " (A) section `%s' from `%s' [%s, %s)\n"
			   " (B) section `%s' from `%s' [%s, %s).\n"
			   "Will ignore section B"),
			 bfd_section_name (abfd1, bfds1), objfile_name (objf1),
			 paddress (gdbarch, sect1_addr),
			 paddress (gdbarch, sect1_endaddr),
			 bfd_section_name (abfd2, bfds2), objfile_name (objf2),
			 paddress (gdbarch, sect2_addr),
			 paddress (gdbarch, sect2_endaddr));
	    }
	}
      i = k;
    }

  if (i < map_size)
    {
      gdb_assert (i == map_size - 1);
      map[j++] = map[i];
    }

  return j;
}


/* Update PMAP, PMAP_SIZE with sections from all objfiles, excluding any
   TLS, overlay and overlapping sections.  */

static void
update_section_map (struct program_space *pspace,
		    struct obj_section ***pmap, int *pmap_size)
{
  struct objfile_pspace_info *pspace_info;
  int alloc_size, map_size, i;
  struct obj_section *s, **map;
  struct objfile *objfile;

  pspace_info = get_objfile_pspace_data (pspace);
  gdb_assert (pspace_info->section_map_dirty != 0
	      || pspace_info->new_objfiles_available != 0);

  map = *pmap;
  xfree (map);

  alloc_size = 0;
  ALL_PSPACE_OBJFILES (pspace, objfile)
    ALL_OBJFILE_OSECTIONS (objfile, s)
      if (insert_section_p (objfile->obfd, s->the_bfd_section))
	alloc_size += 1;

  /* This happens on detach/attach (e.g. in gdb.base/attach.exp).  */
  if (alloc_size == 0)
    {
      *pmap = NULL;
      *pmap_size = 0;
      return;
    }

  map = xmalloc (alloc_size * sizeof (*map));

  i = 0;
  ALL_PSPACE_OBJFILES (pspace, objfile)
    ALL_OBJFILE_OSECTIONS (objfile, s)
      if (insert_section_p (objfile->obfd, s->the_bfd_section))
	map[i++] = s;

  qsort (map, alloc_size, sizeof (*map), qsort_cmp);
  map_size = filter_debuginfo_sections(map, alloc_size);
  map_size = filter_overlapping_sections(map, map_size);

  if (map_size < alloc_size)
    /* Some sections were eliminated.  Trim excess space.  */
    map = xrealloc (map, map_size * sizeof (*map));
  else
    gdb_assert (alloc_size == map_size);

  *pmap = map;
  *pmap_size = map_size;
}

/* Bsearch comparison function.  */

static int
bsearch_cmp (const void *key, const void *elt)
{
  const CORE_ADDR pc = *(CORE_ADDR *) key;
  const struct obj_section *section = *(const struct obj_section **) elt;

  if (pc < obj_section_addr (section))
    return -1;
  if (pc < obj_section_endaddr (section))
    return 0;
  return 1;
}

/* Returns a section whose range includes PC or NULL if none found.   */

struct obj_section *
find_pc_section (CORE_ADDR pc)
{
  struct objfile_pspace_info *pspace_info;
  struct obj_section *s, **sp;

  /* Check for mapped overlay section first.  */
  s = find_pc_mapped_section (pc);
  if (s)
    return s;

  pspace_info = get_objfile_pspace_data (current_program_space);
  if (pspace_info->section_map_dirty
      || (pspace_info->new_objfiles_available
	  && !pspace_info->inhibit_updates))
    {
      update_section_map (current_program_space,
			  &pspace_info->sections,
			  &pspace_info->num_sections);

      /* Don't need updates to section map until objfiles are added,
         removed or relocated.  */
      pspace_info->new_objfiles_available = 0;
      pspace_info->section_map_dirty = 0;
    }

  /* The C standard (ISO/IEC 9899:TC2) requires the BASE argument to
     bsearch be non-NULL.  */
  if (pspace_info->sections == NULL)
    {
      gdb_assert (pspace_info->num_sections == 0);
      return NULL;
    }

  sp = (struct obj_section **) bsearch (&pc,
					pspace_info->sections,
					pspace_info->num_sections,
					sizeof (*pspace_info->sections),
					bsearch_cmp);
  if (sp != NULL)
    return *sp;
  return NULL;
}


/* Return non-zero if PC is in a section called NAME.  */

int
pc_in_section (CORE_ADDR pc, char *name)
{
  struct obj_section *s;
  int retval = 0;

  s = find_pc_section (pc);

  retval = (s != NULL
	    && s->the_bfd_section->name != NULL
	    && strcmp (s->the_bfd_section->name, name) == 0);
  return (retval);
}


/* Set section_map_dirty so section map will be rebuilt next time it
   is used.  Called by reread_symbols.  */

void
objfiles_changed (void)
{
  /* Rebuild section map next time we need it.  */
  get_objfile_pspace_data (current_program_space)->section_map_dirty = 1;
}

/* See comments in objfiles.h.  */

void
inhibit_section_map_updates (struct program_space *pspace)
{
  get_objfile_pspace_data (pspace)->inhibit_updates = 1;
}

/* See comments in objfiles.h.  */

void
resume_section_map_updates (struct program_space *pspace)
{
  get_objfile_pspace_data (pspace)->inhibit_updates = 0;
}

/* See comments in objfiles.h.  */

void
resume_section_map_updates_cleanup (void *arg)
{
  resume_section_map_updates (arg);
}

/* The default implementation for the "iterate_over_objfiles_in_search_order"
   gdbarch method.  It is equivalent to use the ALL_OBJFILES macro,
   searching the objfiles in the order they are stored internally,
   ignoring CURRENT_OBJFILE.

   On most platorms, it should be close enough to doing the best
   we can without some knowledge specific to the architecture.  */

void
default_iterate_over_objfiles_in_search_order
  (struct gdbarch *gdbarch,
   iterate_over_objfiles_in_search_order_cb_ftype *cb,
   void *cb_data, struct objfile *current_objfile)
{
  int stop = 0;
  struct objfile *objfile;

  ALL_OBJFILES (objfile)
    {
       stop = cb (objfile, cb_data);
       if (stop)
	 return;
    }
}

/* Return canonical name for OBJFILE.  */

const char *
objfile_name (const struct objfile *objfile)
{
  if (objfile->obfd != NULL)
    return bfd_get_filename (objfile->obfd);

  return objfile->original_name;
}

/* Provide a prototype to silence -Wmissing-prototypes.  */
extern initialize_file_ftype _initialize_objfiles;

void
_initialize_objfiles (void)
{
  objfiles_pspace_data
    = register_program_space_data_with_cleanup (NULL,
						objfiles_pspace_data_cleanup);

  objfiles_bfd_data = register_bfd_data_with_cleanup (NULL,
						      objfile_bfd_data_free);
}
@


1.170
log
@move the demangled_names_hash into the per-BFD

This moves the demangled_names_hash from the objfile into the per-BFD
object.  This is part of the objfile splitting project.

The demangled names hash is independent of the program space.  And, it
is needed by the symbol tables.  Both of these things indicate that it
must be pushed into the per-BFD object, which this patch does.

Built and regtested on x86-64 Fedora 18.

	* objfiles.c (free_objfile_per_bfd_storage): Delete the
	demangled_names_hash.
	(free_objfile): Don't delete the demangled_names_hash.
	* objfiles.h (struct objfile_per_bfd_storage)
	<demangled_names_hash>: New field.
	(struct objfile) <demangled_names_hash>: Move to
	objfile_per_bfd_storage.
	* symfile.c (reread_symbols): Don't delete the
	demangled_names_hash.
	* symtab.c (create_demangled_names_hash): Update.
	(symbol_set_names): Update.
@
text
@d292 1
@


1.169
log
@don't share per-BFD data if relocations are needed

Right now we always share per-BFD data across objfiles, if there is a
BFD.  This works fine.  However, we're going to start sharing more
data, and sometimes this data will come directly from sections of the
BFD.  If such a section has SEC_RELOC set, then the data coming from
that section will not be truly sharable -- the section will be
program-space-dependent, and re-read by gdb for each objfile.

This patch disallows per-BFD sharing in this case.  This is a bit
"heavy" in that we could in theory examine each bit of shared data for
suitability.  However, that is more complicated, and SEC_RELOC is rare
enough that I think we needn't bother.

Note that the "no sharing" case is equivalent to "gdb works as it
historically did".  That is, the sharing is a new(-ish) optimization.

Built and regtested on x86-64 Fedora 18.

	* gdb_bfd.c (struct gdb_bfd_data) <relocation_computed,
	needs_relocations>: New fields.
	(gdb_bfd_requires_relocations): New function.
	* gdb_bfd.h (gdb_bfd_requires_relocations): Declare.
	* objfiles.c (get_objfile_bfd_data): Disallow sharing if
	the BFD needs relocations applied.
@
text
@d171 2
a659 2
  if (objfile->demangled_names_hash)
    htab_delete (objfile->demangled_names_hash);
@


1.168
log
@	* objfiles.c (allocate_objfile): Move comment to better place.
@
text
@d140 4
a143 1
      if (abfd != NULL)
a146 3

	  /* Look up the gdbarch associated with the BFD.  */
	  storage->gdbarch = gdbarch_from_bfd (abfd);
d152 4
@


1.167
log
@	* objfiles.c (free_objfile): Move comment.
@
text
@a282 4
  /* Update the per-objfile information that comes from the bfd, ensuring
     that any data that is reference is saved in the per-objfile data
     region.  */

d291 4
@


1.166
log
@Keep objfile original filename

gdb/
2013-09-24  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	Pass down original filename for objfile.
	* coffread.c (coff_symfile_read): Update symbol_file_add_separate call.
	* elfread.c (elf_symfile_read): Likewise.
	* jit.c (jit_object_close_impl): Update allocate_objfile call, no
	longer set ORIGINAL_NAME.
	(jit_bfd_try_read_symtab): Update symbol_file_add_from_bfd call.
	* jv-lang.c (get_dynamics_objfile): Update allocate_objfile call.
	* machoread.c (macho_add_oso_symfile): Add parameter name.  Update
	symbol_file_add_from_bfd call.
	(macho_symfile_read_all_oso): Update two macho_add_oso_symfile calls.
	(macho_check_dsym): Add parameter filenamep.  Change function comment.
	Set *filenamep.
	(macho_symfile_read): New variable dsym_filename.  Update
	macho_check_dsym call.  Use it for symbol_file_add_separate.
	* objfiles.c (allocate_objfile): Add parameter name.  New comment for
	it.  Use it for objfile->original_name.
	(objfile_name): Return OBFD's filename, if available.
	* objfiles.h (allocate_objfile): Add new parameter name.
	* solib.c (solib_read_symbols): Update symbol_file_add_from_bfd call.
	* symfile-mem.c (symbol_file_add_from_memory): Update
	symbol_file_add_from_bfd call.
	* symfile.c (read_symbols): Update symbol_file_add_separate call, new
	comment for it.
	(symbol_file_add_with_addrs): New parameter name, add function comment
	for it.  Remove variable name.  Update allocate_objfile call.
	(symbol_file_add_separate): New parameter name, add function comment
	for it.  Update symbol_file_add_with_addrs call.
	(symbol_file_add_from_bfd): New parameter name.  Update
	symbol_file_add_with_addrs call.
	(symbol_file_add): Update symbol_file_add_from_bfd call.
	(reread_symbols): New variable original_name.  Save
	objfile->original_name by it.
	* symfile.h (symbol_file_add_from_bfd, symbol_file_add_separate): Add
	second parameter.
@
text
@a647 2
  /* The last thing we do is free the objfile struct itself.  */

d661 1
@


1.165
log
@Code cleanup: Add objfile_name accessor

gdb/
2013-09-24  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	Code cleanup: Add objfile_name accessor function.
	* ada-lang.c (is_known_support_routine): Use objfile_name.
	* auto-load.c (source_gdb_script_for_objfile)
	(auto_load_objfile_script): Likewise.
	* coffread.c (coff_symtab_read, read_one_sym): Likewise.
	* dbxread.c (dbx_symfile_read): Likewise.
	* dwarf2-frame.c (dwarf2_build_frame_info): Likewise.
	* dwarf2loc.c (locexpr_describe_location_piece): Likewise.
	* dwarf2read.c (dwarf2_get_dwz_file, dwarf2_read_index)
	(dw2_symtab_iter_next, dw2_expand_symtabs_matching)
	(lookup_dwp_signatured_type, lookup_dwo_unit)
	(dwarf2_build_psymtabs_hard, scan_partial_symbols, process_queue)
	(fixup_go_packaging, process_imported_unit_die, dwarf2_physname)
	(read_import_statement, create_dwo_cu, open_and_init_dwp_file)
	(lookup_dwo_cutu, read_call_site_scope, dwarf2_ranges_read)
	(dwarf2_record_block_ranges, read_common_block, read_typedef)
	(read_subrange_type, load_partial_dies, read_partial_die)
	(read_addr_index_1, read_str_index, dwarf_decode_lines_1)
	(die_containing_type, build_error_marker_type, lookup_die_type)
	(follow_die_ref_or_sig, follow_die_ref, dwarf2_fetch_die_loc_sect_off)
	(dwarf2_fetch_constant_bytes, follow_die_sig, get_signatured_type)
	(get_DW_AT_signature_type, write_psymtabs_to_index)
	(save_gdb_index_command): Likewise.
	* elfread.c (find_separate_debug_file_by_buildid, elf_symfile_read):
	Likewise.
	* expprint.c (dump_subexp_body_standard): Likewise.
	* gdbtypes.c (type_name_no_tag_or_error): Likewise.
	* jit.c (jit_object_close_impl): Use the objfile field name renamed to
	original_name.
	* linux-thread-db.c (try_thread_db_load_from_pdir_1): New variable
	obj_name, use objfile_name for it, use the variable.
	(try_thread_db_load_from_pdir, has_libpthread, thread_db_new_objfile):
	Use objfile_name.
	* machoread.c (macho_symtab_read, macho_check_dsym)
	(macho_symfile_relocate): Likewise.
	* maint.c (maintenance_translate_address): Likewise.
	* minidebug.c (find_separate_debug_file_in_section): Likewise.
	* minsyms.c (install_minimal_symbols): Likewise.
	* objfiles.c (allocate_objfile): Use the objfile field name renamed to
	original_name.
	(filter_overlapping_sections): Use objfile_name.
	(objfile_name): New function.
	* objfiles.h (struct objfile): Rename field name to original_name.
	(objfile_name): New prototype.
	* printcmd.c (sym_info, address_info): Use objfile_name.
	* probe.c (parse_probes, collect_probes, compare_probes)
	(info_probes_for_ops): Likewise.
	* progspace.c (clone_program_space): Likewise.
	* psymtab.c (require_partial_symbols, dump_psymtab, allocate_psymtab)
	(maintenance_info_psymtabs): Likewise.
	* python/py-auto-load.c (gdbpy_load_auto_script_for_objfile)
	(source_section_scripts): Likewise.
	* python/py-objfile.c (objfpy_get_filename): Likewise.
	* python/py-progspace.c (pspy_get_filename): Likewise.
	* solib-aix.c (solib_aix_get_toc_value): Likewise.
	* solib-som.c (match_main, som_solib_section_offsets): Likewise.
	* solib.c (solib_read_symbols): Likewise.
	* stabsread.c (scan_file_globals): Likewise.
	* stap-probe.c (handle_stap_probe): Likewise.
	* symfile.c (symbol_file_clear, separate_debug_file_exists)
	(find_separate_debug_file_by_debuglink): Likewise.
	(reread_symbols): Likewise.  Use the objfile field name renamed to
	original_name.
	(allocate_symtab): Use objfile_name.
	* symmisc.c (print_symbol_bcache_statistics, print_objfile_statistics)
	(dump_objfile, dump_msymbols, dump_symtab_1)
	(maintenance_print_msymbols, maintenance_print_objfiles)
	(maintenance_info_symtabs, maintenance_check_symtabs): Likewise.
	* target.c (target_translate_tls_address, target_info): Likewise.
	* xcoffread.c (xcoff_initial_scan): Make variable name const.  Use
	objfile_name.
@
text
@d251 5
d270 1
a270 1
allocate_objfile (bfd *abfd, int flags)
d287 8
a298 1
      objfile->original_name = bfd_get_filename (abfd);
a303 4
  else
    {
      objfile->original_name = "<<anonymous objfile>>";
    }
d1497 3
@


1.164
log
@Remove solib-sunos.c

gdb/
2013-09-24  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	Remove solib-sunos.c.
	* Makefile.in (ALLDEPFILES): Remove solib-sunos.c.
	* config/m68k/obsd.mh (NATDEPFILES): Remove solib-sunos.o.
	* objfiles.c (rt_common_objfile): Remove.
	(free_objfile): Remove rt_common_objfile comparison.
	* objfiles.h (rt_common_objfile): Remove.
	* solib-sunos.c: Remove.
	* symfile.c (reread_symbols): Remove solib-sunos.c comment.
@
text
@d286 1
a286 1
      objfile->name = bfd_get_filename (abfd);
d294 1
a294 1
      objfile->name = "<<anonymous objfile>>";
d1270 1
a1270 1
			 bfd_section_name (abfd1, bfds1), objf1->name,
d1273 1
a1273 1
			 bfd_section_name (abfd2, bfds2), objf2->name,
d1484 8
@


1.163
log
@move gdbarch object from objfile to per-BFD

This moves the "gdbarch" field from the objfile into the BFD.

This field's value is derived from the BFD and is immutable over the
lifetime of the BFD.  This makes it a reasonable candidate for pushing
into the per-BFD object.

This is part of the long-term objfile splitting project.  In the long
run I think this patch will make it simpler to moves types from the
objfile to the per-BFD object; but the patch makes sense as a minor
cleanup by itself.

Built and regtested on x86-64 Fedora 18.

	* cp-namespace.c (cp_lookup_symbol_imports_or_template): Use
	get_objfile_arch.
	* elfread.c (elf_rel_plt_read, elf_gnu_ifunc_record_cache)
	(elf_gnu_ifunc_resolve_by_got): Use get_objfile_arch.
	* jit.c (jit_object_close_impl): Update.
	* jv-lang.c (get_dynamics_objfile): Update.
	* linespec.c (add_minsym): Use get_dynamics_objfile.
	* objfiles.c (get_objfile_bfd_data): Initialize 'gdbarch' field.
	(allocate_objfile): Don't initialize 'gdbarch' field.
	(get_objfile_arch): Update.
	* objfiles.h (struct objfile_per_bfd_storage) <gdbarch>: New field,
	moved from...
	(struct objfile) <gdbarch>: ... here.  Remove.
	* stap-probe.c (stap_can_evaluate_probe_arguments): Use
	get_objfile_arch.
	* symfile.c (init_entry_point_info): Use get_objfile_arch.
@
text
@a65 2
struct objfile *rt_common_objfile;	/* For runtime common symbols */

a612 3
  if (objfile == rt_common_objfile)
    rt_common_objfile = NULL;

@


1.162
log
@	* objfiles.h (pc_in_section): New prototype.
	(in_plt_section): Remove name argument, replace prototype with
	static inline function.
	* mips-tdep.h: Include "objfiles.h".
	(in_mips_stubs_section): New function.
	* hppa-tdep.h (gdbarch_tdep): Remove name argument of
	in_solib_call_trampoline member.
	(hppa_in_solib_call_trampoline): Remove name argument.
	* objfiles.c (pc_in_section): New function.
	(in_plt_section): Remove function.
	* mips-linux-tdep.c: Include "objfiles.h".
	(mips_linux_in_dynsym_stub): Call in_mips_stubs_section.  Remove
	name argument.  Return 1 rather than the low 16-bit halfword of
	any instruction examined.
	(mips_linux_in_dynsym_resolve_code): Update
	mips_linux_in_dynsym_stub call accordingly.
	* mips-tdep.c (mips_stub_frame_sniffer): Use in_mips_stubs_section
	rather than an equivalent hand-coded sequence.
	* hppa-hpux-tdep.c (in_opd_section): Remove function.
	(hppa32_hpux_in_solib_call_trampoline): Remove name argument.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.
	(hppa64_hpux_find_global_pointer): Use pc_in_section rather than
	in_opd_section.
	* hppa-tdep.c (hppa_stub_unwind_sniffer): Remove name argument
	on call to tdep->in_solib_call_trampoline.
	(hppa_in_solib_call_trampoline): Remove name argument, update
	according to in_plt_section change.
	(hppa_skip_trampoline_code): Update according to in_plt_section
	change.
	* aarch64-tdep.c (aarch64_stub_unwind_sniffer): Likewise.
	* arm-symbian-tdep.c (arm_symbian_skip_trampoline_code):
	Likewise.
	* arm-tdep.c (arm_stub_unwind_sniffer): Likewise.
	* hppa-linux-tdep.c (hppa_linux_find_global_pointer): Likewise.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Likewise.
	* nios2-tdep.c (nios2_stub_frame_sniffer): Likewise.
	* nto-tdep.c (nto_relocate_section_addresses): Likewise.
	* s390-tdep.c (s390_stub_frame_sniffer): Likewise.
	* sh-tdep.c (sh_stub_unwind_sniffer): Likewise.
	* solib-dsbt.c (dsbt_in_dynsym_resolve_code): Likewise.
	* solib-frv.c (frv_in_dynsym_resolve_code): Likewise.
	* solib-svr4.c (svr4_in_dynsym_resolve_code): Likewise.
	* solib-target.c (solib_target_in_dynsym_resolve_code): Likewise.
	* sparc-tdep.c (sparc_analyze_prologue): Likewise.
	* tic6x-tdep.c (tic6x_stub_unwind_sniffer): Likewise.
@
text
@d146 3
a287 3
      /* Look up the gdbarch associated with the BFD.  */
      objfile->gdbarch = gdbarch_from_bfd (abfd);

d338 1
a338 1
  return objfile->gdbarch;
@


1.161
log
@2013-06-04  Gary Benson  <gbenson@@redhat.com>

	* objfiles.h (inhibit_section_map_updates): New function
	declaration.
	(resume_section_map_updates): Likewise.
	(resume_section_map_updates_cleanup): Likewise.
	* objfiles.c (objfile_pspace_info): Removed field
	"objfiles_changed_p".  New fields "new_objfiles_available",
	"section_map_dirty" and "inhibit_updates".
	(allocate_objfile): Set new_objfiles_available.
	(free_objfile): Set section_map_dirty.
	(objfile_relocate1): Likewise.
	(in_plt_section): Likewise.
	(find_pc_section): Update the conditions under which the
	section map will be updated.
	(inhibit_section_map_updates): New function.
	(resume_section_map_updates): Likewise.
	(resume_section_map_updates_cleanup): Likewise.
@
text
@d1413 1
a1413 3
/* In SVR4, we recognize a trampoline by it's section name. 
   That is, if the pc is in a section named ".plt" then we are in
   a trampoline.  */
d1416 1
a1416 1
in_plt_section (CORE_ADDR pc, char *name)
d1425 1
a1425 1
	    && strcmp (s->the_bfd_section->name, ".plt") == 0);
@


1.160
log
@	* dbxread.c (process_one_symbol): Constify section_offsets parameter.
	* stabsread.h (process_one_symbol): Update declaration.
	* dwarf2read.c (dw2_relocate): Constify new_offsets, delta parameters.
	* elfread.c (elf_symfile_relocate_probe): Ditto.
	* psymtab.c (relocate_psymtabs): Ditto.
	* objfiles.c (objfile_relocate1): Constify new_offsets parameter.
	(objfile_relocate): Ditto.
	* objfiles.h (objfile_relocate): Update declaration.
	* symfile.c (relative_addr_info_to_section_offsets): Constify
	addrs parameter.
	(default_symfile_offsets): Ditto.
	(syms_from_objfile_1): Constify offsets parameter.
	(syms_from_objfile): Ditto.
	(symbol_file_add_with_addrs_or_offsets): Ditto.
	(symfile_map_offsets_to_segments): Constify data parameter.
	* symfile.h (struct quick_symbol_functions): Constify new_offsets,
	delta parameters of member relocate.
	(struct sym_probe_fns): Constify new_offsets,
	delta parameters of member sym_relocate_probe.
	(struct sym_fns): Constify section_addr_info parameter of member
	sym_offsets.
	(relative_addr_info_to_section_offsets): Update declaration.
	(default_symfile_offsets): Ditto.
	(syms_from_objfile): Ditto.
	(symfile_map_offsets_to_segments): Ditto.
@
text
@a69 1
  int objfiles_changed_p;
d72 10
d329 1
a329 1
  get_objfile_pspace_data (objfile->pspace)->objfiles_changed_p = 1;
d658 1
a658 1
  get_objfile_pspace_data (objfile->pspace)->objfiles_changed_p = 1;
d838 1
a838 1
  get_objfile_pspace_data (objfile->pspace)->objfiles_changed_p = 1;
d1303 1
d1308 3
a1310 1
  gdb_assert (get_objfile_pspace_data (pspace)->objfiles_changed_p != 0);
d1380 3
a1382 1
  if (pspace_info->objfiles_changed_p != 0)
d1390 2
a1391 1
      pspace_info->objfiles_changed_p = 0;
d1432 1
a1432 1
/* Set objfiles_changed_p so section map will be rebuilt next time it
d1439 25
a1463 1
  get_objfile_pspace_data (current_program_space)->objfiles_changed_p = 1;
@


1.159
log
@	* objfiles.c (objfile_relocate): Use gdb_bfd_count_sections instead
	of bfd_count_sections.
	* solib-target.c (solib_target_relocate_section_addresses): Ditto.
	* symfile.c (default_symfile_offsets): Ditto.
	(syms_from_objfile_1): Ditto.  Make dummy addrs list an array of
	one entry, not bfd_count_sections entries.
@
text
@d712 1
a712 1
		   struct section_offsets *new_offsets)
d859 2
a860 1
objfile_relocate (struct objfile *objfile, struct section_offsets *new_offsets)
@


1.158
log
@	* coffread.c (cs_to_section): Use gdb_bfd_section_index.
	* elfread.c (record_minimal_symbol, elf_symtab_read): Use
	gdb_bfd_section_index.
	* gdb_bfd.c (gdb_bfd_section_index, gdb_bfd_count_sections):
	New functions.
	* gdb_bfd.h (gdb_bfd_section_index, gdb_bfd_count_sections):
	Declare.
	* machoread.c (macho_symtab_add_minsym, macho_symfile_offsets):
	Update.
	* objfiles.c (add_to_objfile_sections_full): New function.
	(add_to_objfile_sections): Use it.
	(build_section_table): Rewrite.
	(objfile_relocate1): Use gdb_bfd_section_index.  Update.
	* objfiles.h (obj_section_offset): Use gdb_bfd_section_index.
	(struct objfile) <sections>: Update comment.
	(ALL_OBJFILE_OSECTIONS): Skip sections where the_bfd_section
	is NULL.
	(ALL_OBJSECTIONS): Use it.
	* solib-dsbt.c (dsbt_relocate_main_executable): Update.
	* solib-frv.c (frv_relocate_main_executable): Update.
	* solib-target.c (solib_target_relocate_section_addresses):
	Use gdb_bfd_section_index.
	* symfile.c (build_section_addr_info_from_section_table):
	Use gdb_bfd_section_index.
	(build_section_addr_info_from_bfd, place_section): Likewise.
	* symtab.c (fixup_section): Update.
	* xcoffread.c (find_targ_sec): Use gdb_bfd_section_index.
@
text
@d883 1
a883 1
		  == bfd_count_sections (debug_objfile->obfd));
@


1.157
log
@Add a target for branch trace recording.

The target implements the new record sub-commands
"record instruction-history" and
"record function-call-history".

The target does not support reverse execution or navigation in the
recorded execution log.

gdb/
	* Makefile.in (SFILES): Add record-btrace.c
	(COMMON_OBS): Add record-btrace.o
	* record-btrace.c: New.
	* objfiles.c: Include btrace.h.
	(free_objfile): call btrace_free_objfile.
@
text
@d185 21
d209 1
a209 17
  struct objfile *objfile = (struct objfile *) objfilep;
  struct obj_section section;
  flagword aflag;

  aflag = bfd_get_section_flags (abfd, asect);
  if (!(aflag & SEC_ALLOC))
    return;
  if (bfd_section_size (abfd, asect) == 0)
    return;

  section.objfile = objfile;
  section.the_bfd_section = asect;
  section.ovly_mapped = 0;
  obstack_grow (&objfile->objfile_obstack,
		(char *) &section, sizeof (section));
  objfile->sections_end
    = (struct obj_section *) (((size_t) objfile->sections_end) + 1);
d214 2
a215 11
   Note that while we are building the table, which goes into the
   objfile obstack, we hijack the sections_end pointer to instead hold
   a count of the number of sections.  When bfd_map_over_sections
   returns, this count is used to compute the pointer to the end of
   the sections table, which then overwrites the count.

   Also note that the OFFSET and OVLY_MAPPED in each table entry
   are initialized to zero.

   Also note that if anything else writes to the objfile obstack while
   we are building the table, we're pretty much hosed.  */
d220 6
a225 1
  objfile->sections_end = 0;
d228 6
a233 2
  objfile->sections = obstack_finish (&objfile->objfile_obstack);
  objfile->sections_end = objfile->sections + (size_t) objfile->sections_end;
d812 5
a816 1
        objfile->ei.entry_point += ANOFFSET (delta, s->the_bfd_section->index);
d834 1
a834 1
      int idx = s->the_bfd_section->index;
@


1.156
log
@gdb/
	Code cleanup.
	* breakpoint.c (print_breakpoint_location): Replace bp_location field
	source_file references by symtab field references.  Remove variables
	sal and fullname.
	(momentary_breakpoint_from_master, add_location_to_breakpoint):
	(clear_command, say_where): Replace bp_location field source_file
	references by symtab field references.
	(bp_location_dtor): Remove the source_file reference.
	(update_static_tracepoint): Replace bp_location field source_file
	references by symtab field references.
	(breakpoint_free_objfile): New function.
	* breakpoint.h (struct bp_location): Extend the comment for line_number.
	Replace the field source_file by field symtab, extend its comment.
	(breakpoint_free_objfile): New declaration.
	* objfiles.c (free_objfile): Call breakpoint_free_objfile.
	* tui/tui-winsource.c (tui_update_breakpoint_info): Replace bp_location
	field source_file references by symtab field references.
@
text
@d56 1
d571 1
@


1.155
log
@gdb/
	* elfread.c (elf_symfile_read): Limit separate debug info additions to
	files with no separate debug info.
	* objfiles.c (add_separate_debug_objfile): Add gdb_assert calls.
	* symfile.c (read_symbols): Call find_separate_debug_file_in_section
	only for files with no separate debug info.

gdb/testsuite/
	* gdb.base/gnu-debugdata.exp): Create ${binfile}.debug,
	${binfile}.mini_debuginfo-debuglink, add -k to xz, use now
	${binfile}.mini_debuginfo-debuglink and
	${binfile}.mini_debuginfo-debuglink.xz.
@
text
@d569 2
@


1.154
log
@2013-01-31  Aleksandar Ristovski  <aristovski@@qnx.com>

	* charset.c (intermediate_encoding): Remove unused i.
	* completer.c (signal_completer): Remove unused i.
	* continuations.c (discard_my_continuations_1): Remove unused
	continuation_ptr.
	* corelow.c (core_close): Remove unuseD name.
	(get_core_siginfo): Remove unused pid.
	* cp-namespace.c (cp_lookup_symbol_imports_or_template): Remove unused
	i, cps.
	* dwarf2loc.c (dwarf2_compile_expr_to_ax): Remove unused base_offset.
	(loclist_describe_location): Remove unused first.
	* event-top.c (command_line_handler): Remove unused got_eof.
	* exec.c (exec_close_1): Remove unused need_symtab_cleanup.
	(resize_section_table): Remove unused old_value.
	* gdb_bfd.c (gdb_bfd_map_section): Remove unused header.
	* gnu-v3-abi.c (compute_vtable_size): Remove unused addr.
	* i386-tdep.c (i386_process_record): Remove unused rex.
	* infcmd.c (get_return_value): Remove unused uiout.
	* jv-lang.c (type_from_class): Remove unused is_array.
	* jv-valprint.c (java_val_print): Remove unused i.
	* linux-nat.c (linux_nat_stop_lwp): Remove unused ptid.
	* linux-thread-db.c (thread_db_find_new_threads_2): Remove unuseD pid.
	* m2-typeprint.c (m2_print_type): Remove unused code.
	* macroexp.c (get_character_constant): Remove unused body_start.
	(macro_stringify): Remove unused result.
	* objc-lang.c (find_methods): Remove unused gdbarch.
	* objfiles.c (filter_overlapping_sections): Remove unused abfd1, abfd2.
	* regcache.c (regcache_cooked_read): Remove unused gdbarch.
	* stack.c (print_frame_args): Remove unused summary.
	* thread.c (thread_apply_command): Remove unused p.
	* valarith.c (value_x_unop): Remove unused mangle_ptr.
	* valops.c (search_struct_method): Remove unused skip.
	* valprint.c (generic_val_print): Remove unused byte_order.
	* varobj.c (varobj_update): Remove unused changed.
	* cli/cli-cmds.c (complete_command): Remove unused next_item.
	(alias_command): Remove unused c.
	* mi/mi-cmd-catch.c (mi_catch_load_unload): Remove unused c.
	* mi/mi-main.c (mi_cmd_data_write_register_values): Remove unused
	format.
	(mi_cmd_data_write_memory): Remove unused word_format.
	(mi_cmd_data_write_memory_bytes): Remove unused r.
	* python/py-gdb-readline.c (gdbpy_readline_wrapper): Remove unused
	p_start, p_end.
	* python/python.c (_initialize_python): Remove unused cmd_name, cmd.
	* tui/tui-disasm.c (tui_set_disassem_content): Remove unused
	line_width.

Reference: http://sourceware.org/ml/gdb-patches/2013-01/msg00766.html
@
text
@d479 3
@


1.153
log
@	* symfile.h (struct ecoff_debug_hack): Remove.
	* objfiles.c: Don't include mdebugread.h.
@
text
@a1236 3
	      const struct bfd *const abfd1 = objf1->obfd;
	      const struct bfd *const abfd2 = objf2->obfd;

@


1.152
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@a32 1
#include "mdebugread.h"
@


1.151
log
@solib-darwin.c: handle PIE when attaching processes.

gdb/ChangeLog:

        * solib-darwin.c (darwin_current_sos): Fix indentation.
        (darwin_read_exec_load_addr): New function.
        (darwin_solib_create_inferior_hook): Rebase executable.
        * objfiles.c (objfile_rebase1, objfile_rebase): New functions.
        * objfiles.h (objfile_rebase1, objfile_rebase): Add prototypes.
@
text
@d3 1
a3 1
   Copyright (C) 1992-2004, 2007-2012 Free Software Foundation, Inc.
@


1.150
log
@Move init_entry_point_info to symfile.c and make it static.

gdb/ChangeLog:

        * objfiles.c (init_entry_point_info): Move function from here...
        * symfile.c (init_entry_point_info): ... to there.  Make static.
        * objfiles.h (objfiles.h): Delete declaration.
@
text
@d885 39
@


1.149
log
@gdb/
2012-11-27  Daniel Jacobowitz  <dan@@codesourcery.com>
	    Kazu Hirata  <kazu@@codesourcery.com>
	    Yao Qi  <yao@@codesourcery.com>

	* objfiles.c (init_entry_point_info): Call
	gdbarch_convert_from_func_ptr_addr and
	gdbarch_addr_bits_remove here ...
	(entry_point_address_query): ... instead of here.
	* solib-svr4.c (exec_entry_point): Call
	gdbarch_addr_bits_remove.
	* symfile.c (generic_load): Call gdbarch_addr_bits_remove on
	the entry address.
@
text
@a326 48
/* Initialize entry point information for this objfile.  */

void
init_entry_point_info (struct objfile *objfile)
{
  /* Save startup file's range of PC addresses to help blockframe.c
     decide where the bottom of the stack is.  */

  if (bfd_get_file_flags (objfile->obfd) & EXEC_P)
    {
      /* Executable file -- record its entry point so we'll recognize
         the startup file because it contains the entry point.  */
      objfile->ei.entry_point = bfd_get_start_address (objfile->obfd);
      objfile->ei.entry_point_p = 1;
    }
  else if (bfd_get_file_flags (objfile->obfd) & DYNAMIC
	   && bfd_get_start_address (objfile->obfd) != 0)
    {
      /* Some shared libraries may have entry points set and be
	 runnable.  There's no clear way to indicate this, so just check
	 for values other than zero.  */
      objfile->ei.entry_point = bfd_get_start_address (objfile->obfd);
      objfile->ei.entry_point_p = 1;
    }
  else
    {
      /* Examination of non-executable.o files.  Short-circuit this stuff.  */
      objfile->ei.entry_point_p = 0;
    }

  if (objfile->ei.entry_point_p)
    {
      CORE_ADDR entry_point =  objfile->ei.entry_point;

      /* Make certain that the address points at real code, and not a
	 function descriptor.  */
      entry_point
	= gdbarch_convert_from_func_ptr_addr (objfile->gdbarch,
					      entry_point,
					      &current_target);

      /* Remove any ISA markers, so that this matches entries in the
	 symbol table.  */
      objfile->ei.entry_point
	= gdbarch_addr_bits_remove (objfile->gdbarch, entry_point);
    }
}

@


1.148
log
@gdb/
2012-11-20  Yao Qi  <yao@@codesourcery.com>

	* objfiles.c (init_entry_point_info): Remove trailing spaces.
@
text
@d356 17
a380 3
  struct gdbarch *gdbarch;
  CORE_ADDR entry_point;

d384 1
a384 12
  gdbarch = get_objfile_arch (symfile_objfile);

  entry_point = symfile_objfile->ei.entry_point;

  /* Make certain that the address points at real code, and not a
     function descriptor.  */
  entry_point = gdbarch_convert_from_func_ptr_addr (gdbarch, entry_point,
						    &current_target);

  /* Remove any ISA markers, so that this matches entries in the
     symbol table.  */
  entry_point = gdbarch_addr_bits_remove (gdbarch, entry_point);
a385 1
  *entry_p = entry_point;
@


1.147
log
@	* jit.c (jit_object_close_impl): Don't malloc the objfile
	name.
	* objfiles.c (allocate_objfile): Don't malloc the objfile
	name.
	(free_objfile): Don't free the objfile name.
	* objfiles.h (struct objfile) <name>: Update comment.
	* symfile.c (reread_symbols): Fix reference counting.  Don't
	malloc objfile name.
@
text
@d348 1
a348 1
      objfile->ei.entry_point = bfd_get_start_address (objfile->obfd);    
@


1.146
log
@	* dwarf2read.c (macro_start_file): Update.
	* objfiles.c (get_objfile_bfd_data): Initialize macro_cache.
	(free_objfile_per_bfd_storage): Destroy macro_cache.
	(allocate_objfile, free_objfile): Update.
	* objfiles.h (struct objfile_per_bfd_storage) <macro_cache>:
	New field.
	(struct objfile) <macro_cache>: Remove.
	* symfile.c (reread_symbols): Update.
	* symmisc.c (print_symbol_bcache_statistics): Update.
	(print_objfile_statistics): Update.
@
text
@d274 1
a274 1
      objfile->name = xstrdup (bfd_get_filename (abfd));
d282 1
a282 1
      objfile->name = xstrdup ("<<anonymous objfile>>");
a672 1
  xfree (objfile->name);
@


1.145
log
@	* elfread.c (elf_symtab_read): Update.
	* objfiles.c (objfiles_bfd_data): New global.
	(get_objfile_bfd_data, free_objfile_per_bfd_storage)
	(objfile_bfd_data_free, set_objfile_per_bfd): New functions.
	(allocate_objfile, free_objfile): Update.
	(_initialize_objfiles): Initialize objfiles_bfd_data.
	* objfiles.h (struct objfile_per_bfd_storage): New.
	(struct objfile) <per_bfd>: New field.
	<filename_cache>: Remove.
	(set_objfile_per_bfd): Declare.
	* symfile.c (reread_symbols): Update.  Call
	set_objfile_per_bfd.
	(allocate_symtab): Update.
	* symmisc.c (print_symbol_bcache_statistics): Update.
	(print_objfile_statistics): Print the size of the BFD obstack.
gdb/testsuite
	* gdb.base/maint.exp: Update.
@
text
@d144 1
d156 1
a255 1
  objfile->macro_cache = bcache_xmalloc (NULL, NULL);
a679 1
  bcache_xfree (objfile->macro_cache);
@


1.144
log
@	* registry.h (struct registry_fields): New.
	(REGISTRY_FIELDS): Redefine.
	(REGISTRY_ACCESS_FIELD): New macro.
	(DEFINE_REGISTRY): Add ACCESS argument.  Update defined
	functions.
@
text
@d109 68
a254 1
  objfile->filename_cache = bcache_xmalloc (NULL, NULL);
d284 1
d628 4
a631 1
  gdb_bfd_unref (objfile->obfd);
a679 1
  bcache_xfree (objfile->filename_cache);
d1456 3
@


1.143
log
@	* auto-load.c (_initialize_auto_load): Update.
	* solib-svr4.c (_initialize_svr4_solib): Update
	* solib-dsbt.c (_initialize_dsbt_solib): Update.
	* solib-darwin.c (_initialize_darwin_solib): Update.
	* registry.h: New file.
	* python/py-progspace.c (gdbpy_initialize_pspace): Update.
	* python/py-inferior.c (gdbpy_initialize_inferior): Update.
	* progspace.h: Include registry.h.  Use DECLARE_REGISTRY.
	(register_program_space_data_with_cleanup)
	(register_program_space_data, program_space_alloc_data)
	(clear_program_space_data, set_program_space_data)
	(program_space_data): Don't declare.
	* progspace.c: Use DEFINE_REGISTRY.
	(struct program_space_data, struct
	program_space_data_registration, struct
	program_space_data_registry, program_space_data_registry)
	(register_program_space_data_with_cleanup)
	(register_program_space_data, program_space_alloc_data)
	(program_space_free_data, clear_program_space_data)
	(set_program_space_data, program_space_data): Remove.
	* objfiles.h: Include registry.h.  Use DECLARE_REGISTRY.
	(struct objfile) <data, num_data>: Replace with REGISTRY_FIELDS.
	(register_objfile_data_with_cleanup, register_objfile_data)
	(clear_objfile_data, set_objfile_data, objfile_data): Don't
	declare.
	* objfiles.c: Use DEFINE_REGISTRY.
	(struct objfile_data, struct objfile_data_registration, struct
	objfile_data_registry, objfile_data_registry)
	(register_objfile_data_with_cleanup, register_objfile_data)
	(objfile_alloc_data, objfile_free_data, clear_objfile_data)
	(set_objfile_data, objfile_data): Remove.
	(_initialize_objfiles): Update.
	* jit.c (_initialize_jit): Update.
	* inflow.c (_initialize_inflow): Update.
	* inferior.h: Include registry.h.  Use DECLARE_REGISTRY.
	(struct inferior) <data, num_data>: Replace with REGISTRY_FIELDS.
	(register_inferior_data_with_cleanup, register_inferior_data)
	(clear_inferior_data, set_inferior_data, inferior_data): Don't
	declare.
	* inferior.c: Use DEFINE_REGISTRY.
	(struct inferior_data, struct inferior_data_registration, struct
	inferior_data_registry, inferior_data_registry)
	(register_inferior_data_with_cleanup, register_inferior_data)
	(inferior_alloc_data, inferior_free_data  clear_inferior_data)
	(set_inferior_data, inferior_data): Remove.
	* auxv.c (_initialize_auxv): Update.
	* ada-lang.c (_initialize_ada_language): Update.
	* breakpoint.c (_initialize_breakpoint): Update.
	* i386-nat.c (i386_use_watchpoints): Update.
@
text
@d61 1
a61 1
DEFINE_REGISTRY (objfile)
@


1.142
log
@	* coffread.c (coff_symfile_read): Make a cleanup for 'debugfile'
	and 'abfd'.
	* elfread.c (elf_symfile_read): Make a cleanup for 'debugfile'
	and 'abfd'.
	* jit.c (jit_bfd_try_read_symtab): Make a cleanup for 'nbfd'.
	* machoread.c (macho_add_oso_symfile): Make a cleanup for
	'abfd'.
	(macho_symfile_read): Make a cleanup for 'dsym_bfd'.
	* objfiles.c (allocate_objfile): Acquire a new reference.
	* rs6000-nat.c (add_vmap): Don't acquire a BFD reference.
	* solib.c (solib_read_symbols): Don't acquire a BFD reference.
	* spu-linux-nat.c (spu_symbol_file_add_from_memory): Make
	a cleanup for 'nbfd'.
	* symfile-mem.c (symbol_file_add_from_memory): Make a cleanup
	for 'nbfd'.
	* symfile.c (symbol_file_add_with_addrs_or_offsets): Don't
	make a cleanup for 'abfd'.
	(symbol_file_add): Make a BFD cleanup.
@
text
@d58 2
a59 1
/* Prototypes for local functions */
d61 1
a61 2
static void objfile_alloc_data (struct objfile *objfile);
static void objfile_free_data (struct objfile *objfile);
a1341 109
/* Keep a registry of per-objfile data-pointers required by other GDB
   modules.  */

struct objfile_data
{
  unsigned index;
  void (*save) (struct objfile *, void *);
  void (*free) (struct objfile *, void *);
};

struct objfile_data_registration
{
  struct objfile_data *data;
  struct objfile_data_registration *next;
};
  
struct objfile_data_registry
{
  struct objfile_data_registration *registrations;
  unsigned num_registrations;
};

static struct objfile_data_registry objfile_data_registry = { NULL, 0 };

const struct objfile_data *
register_objfile_data_with_cleanup (void (*save) (struct objfile *, void *),
				    void (*free) (struct objfile *, void *))
{
  struct objfile_data_registration **curr;

  /* Append new registration.  */
  for (curr = &objfile_data_registry.registrations;
       *curr != NULL; curr = &(*curr)->next);

  *curr = XMALLOC (struct objfile_data_registration);
  (*curr)->next = NULL;
  (*curr)->data = XMALLOC (struct objfile_data);
  (*curr)->data->index = objfile_data_registry.num_registrations++;
  (*curr)->data->save = save;
  (*curr)->data->free = free;

  return (*curr)->data;
}

const struct objfile_data *
register_objfile_data (void)
{
  return register_objfile_data_with_cleanup (NULL, NULL);
}

static void
objfile_alloc_data (struct objfile *objfile)
{
  gdb_assert (objfile->data == NULL);
  objfile->num_data = objfile_data_registry.num_registrations;
  objfile->data = XCALLOC (objfile->num_data, void *);
}

static void
objfile_free_data (struct objfile *objfile)
{
  gdb_assert (objfile->data != NULL);
  clear_objfile_data (objfile);
  xfree (objfile->data);
  objfile->data = NULL;
}

void
clear_objfile_data (struct objfile *objfile)
{
  struct objfile_data_registration *registration;
  int i;

  gdb_assert (objfile->data != NULL);

  /* Process all the save handlers.  */

  for (registration = objfile_data_registry.registrations, i = 0;
       i < objfile->num_data;
       registration = registration->next, i++)
    if (objfile->data[i] != NULL && registration->data->save != NULL)
      registration->data->save (objfile, objfile->data[i]);

  /* Now process all the free handlers.  */

  for (registration = objfile_data_registry.registrations, i = 0;
       i < objfile->num_data;
       registration = registration->next, i++)
    if (objfile->data[i] != NULL && registration->data->free != NULL)
      registration->data->free (objfile, objfile->data[i]);

  memset (objfile->data, 0, objfile->num_data * sizeof (void *));
}

void
set_objfile_data (struct objfile *objfile, const struct objfile_data *data,
		  void *value)
{
  gdb_assert (data->index < objfile->num_data);
  objfile->data[data->index] = value;
}

void *
objfile_data (struct objfile *objfile, const struct objfile_data *data)
{
  gdb_assert (data->index < objfile->num_data);
  return objfile->data[data->index];
}

d1384 2
a1385 1
    = register_program_space_data_with_cleanup (objfiles_pspace_data_cleanup);
@


1.141
log
@	* dwarf2read.c (try_open_dwo_file): Use gdb_bfd_ref and
	gdb_bfd_unref.
	(free_dwo_file): Use gdb_bfd_unref.
	* cli/cli-dump.c: Include gdb_bfd.h.
	(bfd_openw_with_cleanup): Use gdb_bfd_ref.
	(bfd_openr_with_cleanup): Likewise.
	* windows-nat.c (windows_make_so): Use gdb_bfd_ref,
	gdb_bfd_unref.
	* utils.c: Include gdb_bfd.h.
	(do_bfd_close_cleanup): Use gdb_bfd_unref.
	* symfile.c: Include gdb_bfd.h.
	(separate_debug_file_exists): Use gdb_bfd_unref.
	(bfd_open_maybe_remote): Use gdb_bfd_ref.
	(symfile_bfd_open): Use gdb_bfd_ref, gdb_bfd_unref.
	(generic_load): Use gdb_bfd_ref.
	(reread_symbols): Use gdb_bfd_unref.
	* symfile-mem.c: Include gdb_bfd.h.
	(symbol_file_add_from_memory): Use make_cleanup_bfd_close.
	* spu-linux-nat.c (spu_bfd_open): Use gdb_bfd_ref, gdb_bfd_unref.
	* solib.c: Include gdb_bfd.h.
	(solib_bfd_fopen): Use gdb_bfd_ref.
	(solib_bfd_open): Use gdb_bfd_unref.
	(free_so_symbols): Use gdb_bfd_unref.
	(reload_shared_libraries_1): Use gdb_bfd_unref.
	* solib-spu.c: Include gdb_bfd.h.
	(spu_bfd_fopen): Use gdb_bfd_ref, gdb_bfd_unref.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Use gdb_bfd_ref,
	gdb_bfd_unref.
	* solib-frv.c: Include gdb_bfd.h.
	(enable_break2): Use gdb_bfd_unref.
	* solib-dsbt.c: Include gdb_bfd.h.
	(enable_break2): Use gdb_bfd_unref.
	* solib-darwin.c: Include gdb_bfd.h.
	(darwin_solib_get_all_image_info_addr_at_init): Use gdb_bfd_ref,
	gdb_bfd_unref.
	(darwin_bfd_open): Use gdb_bfd_unref.
	* rs6000-nat.c (add_vmap): Use gdb_bfd_ref, gdb_bfd_unref.
	* remote-mips.c: Include gdb_bfd.h.
	(mips_load_srec): Use gdb_bfd_ref.
	(pmon_load_fast): Use gdb_bfd_ref.
	* remote-m32r-sdi.c: Include gdb_bfd.h.
	(m32r_load): Use gdb_bfd_ref.
	* record.c: Include gdb_bfd.h.
	(record_save_cleanups): Use gdb_bfd_unref.
	(cmd_record_save): Use gdb_bfd_unref.
	* procfs.c (insert_dbx_link_bpt_in_file): Use gdb_bfd_ref,
	gdb_bfd_unref.
	* objfiles.h (gdb_bfd_close_or_warn): Remove.
	(gdb_bfd_ref, gdb_bfd_unref): Move to gdb_bfd.h.
	* objfiles.c: Include gdb_bfd.h.
	(free_objfile): Use gdb_bfd_unref.
	(gdb_bfd_close_or_warn, gdb_bfd_ref, gdb_bfd_unref): Move to
	gdb_bfd.c.
	* machoread.c (macho_add_oso_symfile): Use gdb_bfd_unref.
	(macho_symfile_read_all_oso): Use gdb_bfd_ref, gdb_bfd_unref.
	(macho_check_dsym): Likewise.
	* m32r-rom.c: Include gdb_bfd.h.
	(m32r_load): Use gdb_bfd_ref.
	(m32r_upload_command): Use gdb_bfd_ref.
	* jit.c: Include gdb_bfd.h.
	(jit_bfd_try_read_symtab): Use gdb_bfd_ref, gdb_bfd_unref.
	* gdb_bfd.h: New file.
	* gdb_bfd.c: New file.
	* gcore.c: Include gdb_bfd.h.
	(create_gcore_bfd): Use gdb_bfd_ref.
	(do_bfd_delete_cleanup): Use gdb_bfd_unref.
	(gcore_command): Use gdb_bfd_unref.
	* exec.c: Include gdb_bfd.h.
	(exec_close): Use gdb_bfd_unref.
	(exec_close_1): Use gdb_bfd_unref.
	(exec_file_attach): Use gdb_bfd_ref.
	* elfread.c: Include gdb_bfd.h.
	(build_id_verify): Use gdb_bfd_unref.
	* dsrec.c: Include gdb_bfd.h.
	(load_srec): Use gdb_bfd_ref.
	* corelow.c: Include gdb_bfd.h.
	(core_close): Use gdb_bfd_unref.
	(core_open): Use gdb_bfd_ref.
	* bfd-target.c: Include gdb_bfd.h.
	(target_bfd_xclose): Use gdb_bfd_unref.
	(target_bfd_reopen): Use gdb_bfd_ref.
	* Makefile.in (SFILES): Add gdb_bfd.c.
	(HFILES_NO_SRCDIR): Add gdb_bfd.h.
	(COMMON_OBS): Add gdb_bfd.o.
@
text
@d197 1
a197 1
     region.  Note that we steal a reference to ABFD.  */
d200 1
@


1.140
log
@New "iterate_over_objfiles_in_search_order" gdbarch method.

This patch introduces the "iterate_over_objfiles_in_search_order"
gdbarch method, as well as its default implementation, and converts
the areas where it will matter to using this gdbarch method.

The default method implementation is the only one installed, and
the changes should have no functional impact in terms of behavior.
This only paves the way for the architectures that will need their
own version.

gdb/ChangeLog:

        * gdbarch.sh: Add generation of
        "iterate_over_objfiles_in_search_order_cb_ftype" typedef in
        gdbarch.h.  Add include of "objfiles.h" in gdbarch.c.
        (iterate_over_objfiles_in_search_order): New gdbarch method.
        * gdbarch.h, gdbarch.c: Regenerate.
        * objfiles.h (default_iterate_over_objfiles_in_search_order):
        Add declaration.
        * objfiles.c (default_iterate_over_objfiles_in_search_order):
        New function.
        * symtab.c (lookup_symbol_aux_objfile): New function, extracted
        out of lookup_symbol_aux_symtabs.
        (lookup_symbol_aux_symtabs): Replace extracted-out code by
        call to lookup_symbol_aux_objfile.
        (struct global_sym_lookup_data): New type.
        (lookup_symbol_global_iterator_cb): New function.
        (lookup_symbol_global): Search for symbol using
        gdbarch_iterate_over_objfiles_in_search_order and
        lookup_symbol_global_iterator_cb.
        * findvar.c (struct minsym_lookup_data): New type.
        (minsym_lookup_iterator_cb): New function.
        (default_read_var_value) [case LOC_UNRESOLVED]: Resolve the
        symbol's address via gdbarch_iterate_over_objfiles_in_search_order
        and minsym_lookup_iterator_cb.
@
text
@d56 1
d197 1
a197 1
     region.  */
d199 1
a199 1
  objfile->obfd = gdb_bfd_ref (abfd);
a1459 69
/* Close ABFD, and warn if that fails.  */

int
gdb_bfd_close_or_warn (struct bfd *abfd)
{
  int ret;
  char *name = bfd_get_filename (abfd);

  ret = bfd_close (abfd);

  if (!ret)
    warning (_("cannot close \"%s\": %s"),
	     name, bfd_errmsg (bfd_get_error ()));

  return ret;
}

/* Add reference to ABFD.  Returns ABFD.  */
struct bfd *
gdb_bfd_ref (struct bfd *abfd)
{
  int *p_refcount;

  if (abfd == NULL)
    return NULL;

  p_refcount = bfd_usrdata (abfd);

  if (p_refcount != NULL)
    {
      *p_refcount += 1;
      return abfd;
    }

  p_refcount = xmalloc (sizeof (*p_refcount));
  *p_refcount = 1;
  bfd_usrdata (abfd) = p_refcount;

  return abfd;
}

/* Unreference and possibly close ABFD.  */
void
gdb_bfd_unref (struct bfd *abfd)
{
  int *p_refcount;
  char *name;

  if (abfd == NULL)
    return;

  p_refcount = bfd_usrdata (abfd);

  /* Valid range for p_refcount: a pointer to int counter, which has a
     value of 1 (single owner) or 2 (shared).  */
  gdb_assert (*p_refcount == 1 || *p_refcount == 2);

  *p_refcount -= 1;
  if (*p_refcount > 0)
    return;

  xfree (p_refcount);
  bfd_usrdata (abfd) = NULL;  /* Paranoia.  */

  name = bfd_get_filename (abfd);
  gdb_bfd_close_or_warn (abfd);
  xfree (name);
}

@


1.139
log
@	* tracepoint.c (scope_info): Update.
	* symtab.c (lookup_block_symbol, iterate_over_symbols)
	(find_pc_sect_symtab, search_symbols)
	(default_make_symbol_completion_list_break_on)
	(make_file_symbol_completion_list): Update.
	* symmisc.c (dump_symtab_1): Update.
	* stack.c (print_frame_args, iterate_over_block_locals)
	(print_frame_labels, iterate_over_block_arg_vars): Update.
	* python/py-block.c (block_object) <dict>: Remove.
	<block>: New field.
	<iter>: Change type.
	(blpy_iter): Update.
	(blpy_block_syms_iternext): Update.
	* psymtab.c (map_block): Use block iterators.
	* objfiles.c (objfile_relocate1): Use ALL_DICT_SYMBOLS.
	* mi/mi-cmd-stack.c (list_args_or_locals): Update.
	* mdebugread.c (parse_symbol, mylookup_symbol): Update.
	* infrun.c (check_exception_resume): Update.
	* cp-support.c (make_symbol_overload_list_block): Update.
	* coffread.c (patch_opaque_types): Update.
	* buildsym.c (finish_block, end_symtab): Use ALL_DICT_SYMBOLS.
	* block.h (struct block_iterator): New.
	(block_iterator_first, block_iterator_next, block_iter_name_first)
	(block_iter_name_next, block_iter_match_first)
	(block_iter_match_next): Declare.
	(ALL_BLOCK_SYMBOLS): Redefine.
	* block.c (block_iterator_first, block_iterator_next)
	(block_iter_name_first, block_iter_name_next)
	(block_iter_match_first, block_iter_match_next): New functions.
	* ada-lang.c (ada_add_block_symbols)
	(ada_make_symbol_completion_list): Use block iterator.
@
text
@d1528 25
@


1.138
log
@2012-04-27  Sergio Durigan Junior  <sergiodj@@redhat.com>
	    Tom Tromey  <tromey@@redhat.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* Makefile.in (SFILES): Add `probe' and `stap-probe'.
	(COMMON_OBS): Likewise.
	(HFILES_NO_SRCDIR): Add `probe'.
	* NEWS: Mention support for static and SystemTap probes.
	* amd64-tdep.c (amd64_init_abi): Initializing proper fields used by
	SystemTap probes' arguments parser.
	* arm-linux-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(arm_stap_is_single_operand): New function.
	(arm_stap_parse_special_token): Likewise.
	(arm_linux_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* ax-gdb.c (require_rvalue): Removing static declaration.
	(gen_expr): Likewise.
	* ax-gdb.h (gen_expr): Declaring function.
	(require_rvalue): Likewise.
	* breakpoint.c: Include `gdb_regex.h' and `probe.h'.
	(bkpt_probe_breakpoint_ops): New variable.
	(momentary_breakpoint_from_master): Set the `probe' value.
	(add_location_to_breakpoint): Likewise.
	(break_command_1): Using proper breakpoint_ops according to the
	argument passed by the user in the command line.
	(bkpt_probe_insert_location): New function.
	(bkpt_probe_remove_location): Likewise.
	(bkpt_probe_create_sals_from_address): Likewise.
	(bkpt_probe_decode_linespec): Likewise.
	(tracepoint_probe_create_sals_from_address): Likewise.
	(tracepoint_probe_decode_linespec): Likewise.
	(tracepoint_probe_breakpoint_ops): New variable.
	(trace_command): Using proper breakpoint_ops according to the
	argument passed by the user in the command line.
	(initialize_breakpoint_ops): Initializing breakpoint_ops for
	static probes on breakpoints and tracepoints.
	* breakpoint.h (struct bp_location) <probe>: New field.
	* cli-utils.c (skip_spaces_const): New function.
	(extract_arg): Likewise.
	* cli-utils.h (skip_spaces_const): Likewise.
	(extract_arg): Likewise.
	* coffread.c (coff_sym_fns): Add `sym_probe_fns' value.
	* configure.ac: Append `stap-probe.o' to be generated when ELF
	support is present.
	* configure: Regenerate.
	* dbxread.c (aout_sym_fns): Add `sym_probe_fns' value.
	* elfread.c: Include `probe.h' and `arch-utils.h'.
	(probe_key): New variable.
	(elf_get_probes): New function.
	(elf_get_probe_argument_count): Likewise.
	(elf_evaluate_probe_argument): Likewise.
	(elf_compile_to_ax): Likewise.
	(elf_symfile_relocate_probe): Likewise.
	(stap_probe_key_free): Likewise.
	(elf_probe_fns): New variable.
	(elf_sym_fns): Add `sym_probe_fns' value.
	(elf_sym_fns_lazy_psyms): Likewise.
	(elf_sym_fns_gdb_index): Likewise.
	(_initialize_elfread): Initialize objfile cache for static
	probes.
	* gdb_vecs.h (struct probe): New forward declaration.
	(probe_p): New VEC declaration.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* gdbarch.sh (stap_integer_prefix): New variable.
	(stap_integer_suffix): Likewise.
	(stap_register_prefix): Likewise.
	(stap_register_suffix): Likewise.
	(stap_register_indirection_prefix): Likewise.
	(stap_register_indirection_suffix): Likewise.
	(stap_gdb_register_prefix): Likewise.
	(stap_gdb_register_suffix): Likewise.
	(stap_is_single_operand): New function.
	(stap_parse_special_token): Likewise.
	(struct stap_parse_info): Forward declaration.
	* i386-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(i386_stap_is_single_operand): New function.
	(i386_stap_parse_special_token): Likewise.
	(i386_elf_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* i386-tdep.h (i386_stap_is_single_operand): New function.
	(i386_stap_parse_special_token): Likewise.
	* machoread.c (macho_sym_fns): Add `sym_probe_fns' value.
	* mipsread.c (ecoff_sym_fns): Likewise.
	* objfiles.c (objfile_relocate1): Support relocation for static
	probes.
	* parse.c (prefixify_expression): Remove static declaration.
	(initialize_expout): Likewise.
	(reallocate_expout): Likewise.
	* parser-defs.h (initialize_expout): Declare function.
	(reallocate_expout): Likewise.
	(prefixify_expression): Likewise.
	* ppc-linux-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(ppc_stap_is_single_operand): New function.
	(ppc_stap_parse_special_token): Likewise.
	(ppc_linux_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* probe.c: New file, for generic statically defined probe support.
	* probe.h: Likewise.
	* s390-tdep.c: Including headers needed to perform the parsing of
	SystemTap probes' arguments.
	(s390_stap_is_single_operand): New function.
	(s390_gdbarch_init): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* somread.c (som_sym_fns): Add `sym_probe_fns' value.
	* stap-probe.c: New file, for SystemTap probe support.
	* stap-probe.h: Likewise.
	* symfile.h: Include `gdb_vecs.h'.
	(struct sym_probe_fns): New struct.
	(struct sym_fns) <sym_probe_fns>: New field.
	* symtab.c (init_sal): Initialize `probe' field.
	* symtab.h (struct probe): Forward declaration.
	(struct symtab_and_line) <probe>: New field.
	* tracepoint.c (start_tracing): Adjust semaphore on breakpoints
	locations.
	(stop_tracing): Likewise.
	* xcoffread.c (xcoff_sym_fns): Add `sym_probe_fns' value.
@
text
@d733 3
a735 1
	  ALL_BLOCK_SYMBOLS (b, iter, sym)
@


1.137
log
@	* objfiles.c (add_to_objfile_sections): Remove outdated comments.
	Rename objfile_p_char parameter to objfilep.
	(build_objfile_section_table): Result is now void.  All callers
	updated.
	* objfiles.h (struct objfile): Tweak comments, whitespace.
	(build_objfile_section_table): Update.
@
text
@d798 5
@


1.136
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@a107 7
/* Records whether any objfiles appeared or disappeared since we last updated
   address to obj section map.  */

/* Locate all mappable sections of a BFD file.
   objfile_p_char is a char * to get it through
   bfd_map_over_sections; we cast it back to its proper type.  */

d115 1
a115 1
			 void *objfile_p_char)
d117 1
a117 1
  struct objfile *objfile = (struct objfile *) objfile_p_char;
a121 1

d124 2
a126 2
  if (0 == bfd_section_size (abfd, asect))
    return;
a136 2
   Returns 0 if OK, 1 on error (in which case bfd_error contains the
   error).
d139 1
a139 1
   psymbol obstack, we hijack the sections_end pointer to instead hold
d147 1
a147 1
   Also note that if anything else writes to the psymbol obstack while
d150 1
a150 1
int
a157 1
  return (0);
d208 1
a208 6

      if (build_objfile_section_table (objfile))
	{
	  error (_("Can't find the file sections in `%s': %s"),
		 objfile->name, bfd_errmsg (bfd_get_error ()));
	}
@


1.135
log
@	* symtab.h: Include minsyms.h.
	(prim_record_minimal_symbol, prim_record_minimal_symbol_full)
	(prim_record_minimal_symbol_and_info, msymbol_hash_iw)
	(msymbol_hash, SYMBOL_HASH_NEXT, msymbol_objfile)
	(lookup_minimal_symbol, lookup_minimal_symbol_text)
	(lookup_minimal_symbol_solib_trampoline)
	(lookup_minimal_symbol_by_pc_name, lookup_minimal_symbol_by_pc)
	(iterate_over_minimal_symbols, lookup_minimal_symbol_and_objfile)
	(lookup_minimal_symbol_by_pc_section)
	(lookup_solib_trampoline_symbol_by_pc)
	(init_minimal_symbol_collection)
	(make_cleanup_discard_minimal_symbols, install_minimal_symbols)
	(msymbols_sort): Move to minsyms.h.
	* objfiles.c (terminate_minimal_symbol_table): Move to minsyms.c.
	* minsyms.c (terminate_minimal_symbol_table): Move from
	objfiles.c.
	* minsyms.h: New file.
@
text
@d3 1
a3 3
   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002, 2003, 2004, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.134
log
@missing check against overlay_debugging in objfiles.c

This fixes a problem where the debugger is trying to locate a minimal
symbol from its address, when the symbol is inside a section whose
VMA is different from its LMA.

We have a program that was built on ppc-elf using a linker script
such that data sections are placed in ROM, and then loaded onto RAM
at execution.  So their VMA addresses are indeed different from
their LMA address.

Unfortunately, there is one place where GDB gets slightly confused
into thinking that these data sections are overlayed, while it's
not the case here.  This show up when trying to print the list of
Ada tasks, where GDB is unable to determine their names, and thus
prints a generic `Ravenscar task' instead:

    (gdb) info tasks
       ID       TID P-ID Pri State                  Name
        1     1d580      127 Delay Sleep            Ravenscar task
        2     183f8      127 Delay Sleep            Ravenscar task
    *   3     13268      127 Runnable               Ravenscar task

We expected:

    (gdb) info tasks
       ID       TID P-ID Pri State                  Name
        1     1d580      127 Delay Sleep            environment_task
        2     183f8      127 Delay Sleep            raven2
    *   3     13268      127 Runnable               raven1

The name of the task is determined by looking up the symbol table
using the task ID, which is the address where the symbol is defined.
So, ada-tasks calls...

    msym = lookup_minimal_symbol_by_pc (task_id);

... which in turn first tries to determine the section associated
to this address (find_pc_section), which itself uses a map of sections
to find it. The map itself is recomputed every time objfiles are
loaded/changed by `update_section_map'. And `update_section_map'
relies on `insert_section_p' to determine whether the section should
be inserted in the map or not.

This is where things get interesting for us, because `insert_section_p'
simply rejects overlay sections:

  if (lma != 0 && lma != bfd_section_vma (abfd, section)
      && (bfd_get_file_flags (abfd) & BFD_IN_MEMORY) == 0)
    /* This is an overlay section.  IN_MEMORY check is needed to avoid
       discarding sections from the "system supplied DSO" (aka vdso)
       on some Linux systems (e.g. Fedora 11).  */
    return 0;

However, it shouldn't reject our section in this case, since overlay
debugging is off.  The fix is to add a check that overlay debugging
is active before rejecting the section.  This is similar to what is
done in `section_is_overlay' (which takes obj_section objects), for
instance.

gdb/Changelog:

        * objfiles.c (insert_section_p): Do not detect overlay sections
        if overlay debugging is off.
@
text
@a346 23
/* Create the terminating entry of OBJFILE's minimal symbol table.
   If OBJFILE->msymbols is zero, allocate a single entry from
   OBJFILE->objfile_obstack; otherwise, just initialize
   OBJFILE->msymbols[OBJFILE->minimal_symbol_count].  */
void
terminate_minimal_symbol_table (struct objfile *objfile)
{
  if (! objfile->msymbols)
    objfile->msymbols = ((struct minimal_symbol *)
                         obstack_alloc (&objfile->objfile_obstack,
                                        sizeof (objfile->msymbols[0])));

  {
    struct minimal_symbol *m
      = &objfile->msymbols[objfile->minimal_symbol_count];

    memset (m, 0, sizeof (*m));
    /* Don't rely on these enumeration values being 0's.  */
    MSYMBOL_TYPE (m) = mst_unknown;
    SYMBOL_SET_LANGUAGE (m, language_unknown);
  }
}

@


1.133
log
@	* objfiles.h (struct objfile): Remove obsolete comment.
	* objfiles.c (build_objfile_section_table): Remove obsolete
	comment.
@
text
@d1120 1
a1120 1
  if (lma != 0 && lma != bfd_section_vma (abfd, section)
@


1.133.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 3
a5 1
   Copyright (C) 1992-2004, 2007-2012 Free Software Foundation, Inc.
@


1.132
log
@	* symtab.h (current_objfile): Don't declare.
	* objfiles.h (current_objfile): Don't declare.
	* objfiles.c (current_objfile): Remove.
	* mdebugread.c (current_objfile): New file-scope global.
	* dbxread.c (current_objfile): New file-scope global.
	* coffread.c (current_objfile): New file-scope global.
@
text
@a164 6
  /* objfile->sections can be already set when reading a mapped symbol
     file.  I believe that we do need to rebuild the section table in
     this case (we rebuild other things derived from the bfd), but we
     can't free the old one (it's in the objfile_obstack).  So we just
     waste some memory.  */

@


1.131
log
@gdb/
	* elfread.c (elf_symfile_read): Protect dwarf2_initialize_objfile by
	!objfile_has_partial_symbols.  New comment.
	* objfiles.c (objfile_has_partial_symbols): Call HAS_SYMBOLS if
	SYM_READ_PSYMBOLS is not present. Extend the comment.
	* symfile.h (struct sym_fns): Extend the sym_read_psymbols comment.

gdb/testsuite/
	* gdb.base/gdbindex-stabs-dwarf.c: New file.
	* gdb.base/gdbindex-stabs.c: New file.
	* gdb.base/gdbindex-stabs.exp: New file.
@
text
@a66 1
struct objfile *current_objfile;	/* For symbol file being read in */
@


1.130
log
@gdb/
	Fix crash regression on systems featuring .gdb_index.
	* objfiles.c (free_objfile): Move the
	forget_cached_source_info_for_objfile call earlier.  Comment it.
	Extend the comment for objfile_free_data.
@
text
@d909 9
a917 5
  /* If we have not read psymbols, but we have a function capable of
     reading them, then that is an indication that they are in fact
     available.  */
  if ((objfile->flags & OBJF_PSYMTABS_READ) == 0)
    return objfile->sf->sym_read_psymbols != NULL;
@


1.129
log
@	* symtab.h (free_symtab): Remove.
	(forget_cached_source_info_for_objfile): Declare.
	* symmisc.c (free_symtab): Remove.
	* source.c (forget_cached_source_info_for_objfile): New function.
	(forget_cached_source_info): Use it.
	* objfiles.c (free_objfile): Simplify check before calling
	clear_current_source_symtab_and_line.  Call
	forget_cached_source_info_for_objfile.
@
text
@d586 4
d602 2
a603 1
  /* Discard any data modules have associated with the objfile.  */
a644 2
  forget_cached_source_info_for_objfile (objfile);

@


1.128
log
@gdb
	* symfile.c (reread_symbols): Update.
	* objfiles.h (struct objfile) <cp_namespace_symtab>: Remove
	field.
	* objfiles.c (allocate_objfile): Update.
	* cp-support.h (cp_check_possible_namespace_symbols): Don't
	declare.
	* cp-namespace.c (lookup_symbol_file): Don't call
	lookup_possible_namespace_symbol.
	(initialize_namespace_symtab, get_possible_namespace_block)
	(free_namespace_block, cp_check_possible_namespace_symbols)
	(check_possible_namespace_symbols_loop)
	(check_one_possible_namespace_symbol)
	(lookup_possible_namespace_symbol): Remove.
	(maintenance_cplus_namespace): Replace with notice.
	(_initialize_cp_namespace): Deprecate `maint cplus namespace'.
gdb/testsuite
	* gdb.cp/maint.exp (test_help): Update.
	(test_namespace): Likewise.
@
text
@a634 1
    struct symtab *s;
d636 2
a637 5
    ALL_OBJFILE_SYMTABS (objfile, s)
      {
	if (s == cursal.symtab)
	  clear_current_source_symtab_and_line ();
      }
d640 2
@


1.127
log
@	* xcoffread.c (xcoff_sym_fns): Update.
	* symfile.h (struct sym_fns) <sym_read_psymbols>: New field.
	(enum symfile_add_flags) <SYMFILE_NO_READ>: New constant.
	* symfile.c (syms_from_objfile): Handle SYMFILE_NO_READ.
	(symbol_file_add_with_addrs_or_offsets): Likewise.
	(reread_symbols): Handle OBJF_PSYMTABS_READ.
	* somread.c (som_sym_fns): Update.
	* psymtab.h (require_partial_symbols): Declare.
	* psymtab.c (require_partial_symbols): New function.
	(ALL_OBJFILE_PSYMTABS_REQUIRED): New macro.
	(ALL_OBJFILE_PSYMTABS): Undef.
	(ALL_PSYMTABS): Move from psympriv.h.
	(lookup_partial_symtab, find_pc_sect_psymtab)
	(lookup_symbol_aux_psymtabs, relocate_psymtabs)
	(find_last_source_symtab_from_partial)
	(forget_cached_source_info_partial)
	(print_psymtab_stats_for_objfile, read_symtabs_for_function)
	(expand_partial_symbol_tables, read_psymtabs_with_filename)
	(map_symbol_names_psymtab, map_symbol_filenames_psymtab)
	(find_symbol_file_from_partial, map_matching_symbols_psymtab)
	(expand_symtabs_matching_via_partial, maintenance_info_psymtabs):
	Use ALL_OBJFILE_PSYMTABS_REQUIRED.
	* psympriv.h (ALL_PSYMTABS): Move to psymtab.c.
	* objfiles.h (OBJF_PSYMTABS_READ): New macro.
	* objfiles.c (objfile_has_partial_symbols): Handle lazily-read
	psymtabs.
	* mipsread.c (ecoff_sym_fns): Update.
	* machoread.c (macho_sym_fns): Update.
	* elfread.c (elf_symfile_read): Set up for lazy psymtab reading.
	(read_psyms): New function.
	(elf_sym_fns, elf_sym_fns_gdb_index): Update.
	(elf_sym_fns_lazy_psyms): New global.
	* dwarf2read.c (dwarf2_initialize_objfile): Don't call
	dwarf2_build_psymtabs.
	* dbxread.c (aout_sym_fns): Update.
	* coffread.c (coff_sym_fns): Update.
@
text
@a249 4
  /* We don't yet have a C++-specific namespace symtab.  */

  objfile->cp_namespace_symtab = NULL;

@


1.127.2.1
log
@gdb/
	* elfread.c (elf_symfile_read): Protect dwarf2_initialize_objfile by
	!objfile_has_partial_symbols.  New comment.
	* objfiles.c (objfile_has_partial_symbols): Call HAS_SYMBOLS if
	SYM_READ_PSYMBOLS is not present. Extend the comment.
	* symfile.h (struct sym_fns): Extend the sym_read_psymbols comment.

gdb/testsuite/
	* gdb.base/gdbindex-stabs-dwarf.c: New file.
	* gdb.base/gdbindex-stabs.c: New file.
	* gdb.base/gdbindex-stabs.exp: New file.
@
text
@d912 5
a916 9

  /* If we have not read psymbols, but we have a function capable of reading
     them, then that is an indication that they are in fact available.  Without
     this function the symbols may have been already read in but they also may
     not be present in this objfile.  */
  if ((objfile->flags & OBJF_PSYMTABS_READ) == 0
      && objfile->sf->sym_read_psymbols != NULL)
    return 1;

@


1.126
log
@2011-01-10  Michael Snyder  <msnyder@@vmware.com>

	* nto-procfs.c: Comment cleanup, mostly periods and spaces.
	* nto-tdep.c: Ditto.
	* nto-tdep.h: Ditto.
	* objc-exp.y: Ditto.
	* objc-lang.c: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* observer.c: Ditto.
	* opencl-lang.c: Ditto.
	* osabi.c: Ditto.
	* parse.c: Ditto.
	* parser-defs.h: Ditto.
	* p-exp.y: Ditto.
	* p-lang.c: Ditto.
	* posix-hdep.c: Ditto.
	* ppcbug-rom.c: Ditto.
	* ppc-linux-nat.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* ppc-linux-tdep.h: Ditto.
	* ppcnbsd-tdep.c: Ditto.
	* ppcobsd-tdep.c: Ditto.
	* ppcobsd-tdep.h: Ditto.
	* ppc-sysv-tdep.c: Ditto.
	* ppc-tdep.h: Ditto.
	* printcmd.c: Ditto.
	* proc-abi.c: Ditto.
	* proc-flags.c: Ditto.
	* procfs.c: Ditto.
	* proc-utils.h: Ditto.
	* progspace.h: Ditto.
	* prologue-value.c: Ditto.
	* prologue-value.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* ravenscar-sparc-thread.c: Ditto.
	* ravenscar-thread.c: Ditto.
	* ravenscar-thread.h: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote.c: Ditto.
	* remote-fileio.c: Ditto.
	* remote-fileio.h: Ditto.
	* remote.h: Ditto.
	* remote-m32r-sdi.c: Ditto.
	* remote-mips.c: Ditto.
	* remote-sim.c: Ditto.
	* rs6000-aix-tdep.c: Ditto.
	* rs6000-nat.c: Ditto.
	* rs6000-tdep.c: Ditto.
@
text
@d910 8
a917 1
  return objfile->sf ? objfile->sf->qf->has_symbols (objfile) : 0;
@


1.125
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d25 1
a25 1
   destroying objfile structures. */
d65 1
a65 1
   See declarations in objfile.h for more info. */
d114 1
a114 1
/* Locate all mappable sections of a BFD file. 
d121 1
a121 1
   the end of the table (objfile->sections_end). */
d161 1
a161 1
   we are building the table, we're pretty much hosed. */
d187 1
a187 1
   simply copied through to the new objfile flags member. */
d216 1
a216 1
     region. */
d243 1
a243 1
     later detect if they are used w/o being properly assigned to. */
d254 1
a254 1
  /* Add this file onto the tail of the linked list of other such files. */
d269 1
a269 1
  /* Save passed in flag bits. */
d285 1
a285 1
/* Initialize entry point information for this objfile. */
d423 1
a423 1
   another when using ALL_OBJFILES_SAFE to free all objfiles. */
d476 1
a476 1
   between the OBJFILE and the list. */
d513 1
a513 1
     usage of the ALL_OBJFILES_SAFE macro will stay safe. */
d547 1
a547 1
   we free objects in the reusable area. */
d595 1
a595 1
     execution, or leaving them to be reused during the next one. */
d607 1
a607 1
  /* Remove it from the chain of all objfiles. */
d622 1
a622 1
     it is shown to be no longer needed. */
d635 1
a635 1
     and if so, call clear_current_source_symtab_and_line. */
d648 1
a648 1
  /* The last thing we do is free the objfile struct itself. */
d655 1
a655 1
  /* Free the obstacks for non-reusable objfiles */
d900 1
a900 1
  /* Relocate breakpoints as necessary, after things are relocated. */
d938 1
a938 1
   available, nonzero otherwise. */
d955 1
a955 1
   available, nonzero otherwise. */
d973 2
a974 2
   command.
 */
d984 2
a985 2
       be soon.
     */
d994 1
a994 1
   available, nonzero otherwise. */
d1030 1
a1030 1
	 or something like that. */
d1295 1
a1295 1
/* Bsearch comparison function. */
@


1.124
log
@run copyright.sh for 2011.
@
text
@d141 2
a142 1
  obstack_grow (&objfile->objfile_obstack, (char *) &section, sizeof (section));
@


1.123
log
@gdb/
	* infrun.c (follow_exec): Replace symbol_file_add_main by
	symbol_file_add with SYMFILE_DEFER_BP_RESET, set_initial_language and
	breakpoint_re_set.
	* m32r-rom.c (m32r_load, m32r_upload_command): Use parameter 0 for
	clear_symtab_users.
	* objfiles.c (free_all_objfiles): Likewise.
	* remote-m32r-sdi.c (m32r_load): Likewise.
	* solib-som.c (som_solib_create_inferior_hook): Likewise.
	* symfile.c (new_symfile_objfile): New comment for add_flags.  Call
	clear_symtab_users with ADD_FLAGS.
	(reread_symbols): Use parameter 0 for clear_symtab_users.
	(clear_symtab_users): New parameter add_flags.  Do not call
	breakpoint_re_set if SYMFILE_DEFER_BP_RESET.
	(clear_symtab_users_cleanup): Use parameter 0 for clear_symtab_users.
	* symtab.h (clear_symtab_users): New parameter add_flags.

gdb/testsuite/
	* gdb.base/pie-execl.exp: New file.
	* gdb.base/pie-execl.c: New file.
@
text
@d4 2
a5 1
   2002, 2003, 2004, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.122
log
@gdb/
	Code cleanup.
	* objfiles.c (allocate_objfile) <objfile->name != NULL>: Remove.
	(free_objfile) <objfile->name != NULL>: Remove the conditional around
	xfree.
	* objfiles.h (struct objfile) <name>: New comment it is never NULL.
	* python/py-auto-load.c (auto_load_new_objfile) <!objfile->name>:
	Remove.
	* python/py-objfile.c (objfpy_get_filename) <obj->objfile->name>
	Remove the conditional.
	* python/py-progspace.c (pspy_get_filename) <objfile->name>: Likewise.
@
text
@d695 1
a695 1
  clear_symtab_users ();
@


1.121
log
@Create and use a specialized bcache type for psymbols

2010-08-31  Sami Wagiaalla  <swagiaal@@redhat.com>

	* symfile.c (reread_symbols): Use psymbol_bcache_free, and
	psymbol_bcache_init.
	* psymtab.h (psymbol_bcache_init): New function prototype.
	(psymbol_bcache_free): New function prototype.
	(psymbol_bcache_get_bcache): New function prototype.
	* psymtab.c (psymbol_bcache_init): New function.
	(psymbol_bcache_free): New function.
	(psymbol_bcache_full): New function.
	(psymbol_bcache_get_bcache): New function.
	(add_psymbol_to_bcache): use psymbol_bcache_full.
	* objfiles.h (psymbol_cache): Change type of psymbol_cache to
	psymbol_bcache.
	* symmisc.c (print_symbol_bcache_statistics): Updated.
	(print_objfile_statistics): Updated.
	* objfiles.c (allocate_objfile): Use psymbol_bcache_init to initialize
	psymbol_cache.
	(free_objfile): Use psymbol_bcache_free.
@
text
@a216 4
  if (objfile->name != NULL)
    {
      xfree (objfile->name);
    }
d648 1
a648 4
  if (objfile->name != NULL)
    {
      xfree (objfile->name);
    }
@


1.120
log
@Enable custom bcache hash function.

2010-08-25  Sami Wagiaalla  <swagiaal@@redhat.com>

	* psymtab.c (add_psymbol_to_bcache): Remove 'static' from
	'static partial_symbol psymbol'.
	(psymbol_hash): New function.
	(psymbol_compare): New function.
	* bcache.c (hash_continue): New.
	(hash): Use hash_continue.
	* bcache.c: Add hash_function and compare_function
	pointers to bcache struct.
	(bcache_full): Use bcache->hash_function, and
	bcache->compare_function.
	(bcache_compare): New function.
	(bcache_xmalloc): Take hash_function and
	compare_function arguments and initialize the
	bcach's pointers.
	Updated comment.
	* objfiles.c (allocate_objfile): Updated.
	* symfile.c (reread_symbols): Updated.
	* python/py-type.c (typy_richcompare): Updated.
@
text
@d202 1
a202 1
  objfile->psymbol_cache = bcache_xmalloc (psymbol_hash, psymbol_compare);
d661 1
a661 1
  bcache_xfree (objfile->psymbol_cache);
@


1.119
log
@	* gdb_assert.h (gdb_assert_not_reached): New macro.
	(gdb_assert_fail): Fix typo in comment.
	* avr-tdep.c (avr_return_value): Use gdb_assert_not_reached instead of
	gdb_assert (0).
	* darwin-nat.c (darwin_check_new_threads): Ditto.
	* dwarf2read.c (dwarf2_get_section_info): Ditto.
	(munmap_section_buffer): Ditto.
	* m32c-tdep.c (make_types): Ditto.
	(m32c_decode_srcdest4, m32c_decode_sd23, m32c_frame_base): Ditto.
	* macroexp.c (get_character_constant): Ditto.
	(get_string_literal): Ditto.
	* mep-tdep.c (mep_pseudo_cr_size): Ditto.
	(mep_pseudo_cr_index, mep_register_type): Ditto.
	(mep_pseudo_register_read, mep_pseudo_register_write): Ditto.
	(mep_get_insn, mep_analyze_prologue): Ditto.
	* objfiles.c (qsort_cmp): Ditto.
	* prologue-value.c (pv_is_identical): Ditto.
	* record.c (record_get_loc): Ditto.
	* value.c (value_static_field): Ditto.
	* xtensa-tdep.c (call0_track_op): Ditto.
@
text
@d202 3
a204 3
  objfile->psymbol_cache = bcache_xmalloc ();
  objfile->macro_cache = bcache_xmalloc ();
  objfile->filename_cache = bcache_xmalloc ();
@


1.118
log
@create and use symbol_set_language.

2010-08-09  Sami Wagiaalla  <swagiaal@@redhat.com>

	* symtab.h: Renamed SYMBOL_INIT_LANGUAGE_SPECIFIC to
	SYMBOL_SET_LANGUAGE.
	(symbol_init_language_specific): Renamed to symbol_set_language.
	* symtab.c (symbol_init_language_specific): Removed redundant check
	for language_cplus.
	Renamed to symbol_set_language.
	* stabsread.c (define_symbol): Updated.
	(read_enum_type): Updated
	* psymtab.c (add_psymbol_to_bcache): Updated.
	* minsyms.c (install_minimal_symbols): Updated.
	* coffread.c (process_coff_symbol): SYMBOL_SET_LANGUAGE instead of
	SYMBOL_LANGUAGE to set the language.
	* minsyms.c (prim_record_minimal_symbol_full): Ditto.
	* mdebugread.c (new_symbol): Ditto.
	* cp-namespace.c (check_one_possible_namespace_symbol): Ditto.
	* dwarf2read.c (new_symbol_full): Ditto.
	* jv-lang.c (add_class_symbol): Ditto.
@
text
@d1071 1
a1071 1
	  gdb_assert (0);
d1086 1
a1086 1
	  gdb_assert (0);
d1091 1
a1091 1
  gdb_assert (0);
@


1.117
log
@gdb
	PR c++/9946:
	* symfile.c (reread_symbols): Clear template_symbols.
	* symtab.h (struct symbol) <is_cplus_template_function>: New
	field.
	(SYMBOL_IS_CPLUS_TEMPLATE_FUNCTION): New macro.
	(struct template_symbol): New.
	* symtab.c (lookup_symbol_aux_local): Use
	cp_lookup_symbol_imports_or_template.
	* objfiles.h (struct objfile) <template_symbols>: New field.
	* objfiles.c (relocate_one_symbol): New function.
	(objfile_relocate1): Use it.  Relocate isolated symbols.
	* gdbtypes.h (struct cplus_struct_type) <n_template_arguments,
	template_arguments>: New fields.
	(TYPE_N_TEMPLATE_ARGUMENTS): New macro.
	(TYPE_TEMPLATE_ARGUMENTS): Likewise.
	(TYPE_TEMPLATE_ARGUMENT): Likewise.
	(lookup_typename): Update.
	* gdbtypes.c (lookup_typename): Constify "block" argument.
	* dwarf2read.c: Include vec.h.
	(symbolp): New typedef.
	(read_func_scope): Read template arguments.  Allocate a
	template_symbol when needed.
	(read_structure_type): Read template arguments.
	(new_symbol_full): New function, from new_symbol.  Handle
	DW_TAG_template_type_param and DW_TAG_template_value_param.
	(new_symbol): Rewrite as wrapper.
	* cp-support.h (cp_lookup_symbol_imports_or_template): Declare.
	* cp-namespace.c: Include language.h.
	(search_symbol_list): New function.
	(cp_lookup_symbol_imports_or_template): Likewise.
gdb/testsuite
	PR c++/9946:
	* gdb.cp/temargs.exp: New file.
	* gdb.cp/temargs.cc: New file.
@
text
@d379 1
a379 1
    SYMBOL_INIT_LANGUAGE_SPECIFIC (m, language_unknown);
@


1.116
log
@2010-05-15  Michael Snyder  <msnyder@@vmware.com>

	* objc-lang.c: White space.
	* objfiles.c: White space.
	* observer.c: White space.
	* osabi.c: White space.
	* osdata.c: White space.
@
text
@d705 21
d791 1
a791 13
	      fixup_symbol_section (sym, objfile);

	      /* The RS6000 code from which this was taken skipped
	         any symbols in STRUCT_DOMAIN or UNDEF_DOMAIN.
	         But I'm leaving out that test, on the theory that
	         they can't possibly pass the tests below.  */
	      if ((SYMBOL_CLASS (sym) == LOC_LABEL
		   || SYMBOL_CLASS (sym) == LOC_STATIC)
		  && SYMBOL_SECTION (sym) >= 0)
		{
		  SYMBOL_VALUE_ADDRESS (sym) +=
		    ANOFFSET (delta, SYMBOL_SECTION (sym));
		}
d797 8
@


1.115
log
@2010-05-06  Michael Snyder  <msnyder@@vmware.com>

	* objfiles.c (objfile_relocate): Delete unused variable.
	* maint.c (_initialize_maint_cmds): Delete unused variable.
	* demangle.c (_initialize_demangler): Delete unused variable.
	* corefile.c (reopen_exec_file): Delete unused variable.
	* dwarf2expr.c (dwarf2_read_address): Delete unused variable.
	* dwarf2-frame.c (decode_frame_entry): Delete unused variable.
@
text
@d710 2
a711 1
objfile_relocate1 (struct objfile *objfile, struct section_offsets *new_offsets)
d718 12
a729 13
  {
    int i;
    int something_changed = 0;
    for (i = 0; i < objfile->num_sections; ++i)
      {
	delta->offsets[i] =
	  ANOFFSET (new_offsets, i) - ANOFFSET (objfile->section_offsets, i);
	if (ANOFFSET (delta, i) != 0)
	  something_changed = 1;
      }
    if (!something_changed)
      return 0;
  }
d797 1
d820 1
d1014 8
a1021 57
   {
     /* Sections are at the same address.  This could happen if
	A) we have an objfile and a separate debuginfo.
	B) we are confused, and have added sections without proper relocation,
	or something like that. */

     const struct objfile *const objfile1 = sect1->objfile;
     const struct objfile *const objfile2 = sect2->objfile;

     if (objfile1->separate_debug_objfile == objfile2
	 || objfile2->separate_debug_objfile == objfile1)
       {
	 /* Case A.  The ordering doesn't matter: separate debuginfo files
	    will be filtered out later.  */

	 return 0;
       }

     /* Case B.  Maintain stable sort order, so bugs in GDB are easier to
	triage.  This section could be slow (since we iterate over all
	objfiles in each call to qsort_cmp), but this shouldn't happen
	very often (GDB is already in a confused state; one hopes this
	doesn't happen at all).  If you discover that significant time is
	spent in the loops below, do 'set complaints 100' and examine the
	resulting complaints.  */

     if (objfile1 == objfile2)
       {
	 /* Both sections came from the same objfile.  We are really confused.
	    Sort on sequence order of sections within the objfile.  */

	 const struct obj_section *osect;

	 ALL_OBJFILE_OSECTIONS (objfile1, osect)
	   if (osect == sect1)
	     return -1;
	   else if (osect == sect2)
	     return 1;

	 /* We should have found one of the sections before getting here.  */
	 gdb_assert (0);
       }
     else
       {
	 /* Sort on sequence number of the objfile in the chain.  */

	 const struct objfile *objfile;

	 ALL_OBJFILES (objfile)
	   if (objfile == objfile1)
	     return -1;
	   else if (objfile == objfile2)
	     return 1;

	 /* We should have found one of the objfiles before getting here.  */
	 gdb_assert (0);
       }
d1023 49
a1071 1
   }
@


1.114
log
@gdb/
	* objfiles.c: Include solist.h.
	(free_all_objfiles): New variable so.  Check stale solist objfiles.
	* symfile.c (symbol_file_clear): Swap the order of free_all_objfiles
	and no_shared_libraries.
@
text
@a861 1
      int new_debug_num_sections;
d874 2
a875 2
      new_debug_offsets = xmalloc (SIZEOF_N_SECTION_OFFSETS
						 (debug_objfile->num_sections));
@


1.113
log
@	* objfiles.h (gdb_bfd_close_or_warn): Declare.
	* objfiles.c (gdb_bfd_close_or_warn): New.
	* corelow.c: Include objfiles.h
	(core_close): Use gdb_bfd_close_or_warn.
	* elfread.c (build_id_verify): Ditto.
	* exec.c (exec_close, exec_close_1): Ditto.
@
text
@d56 1
d692 5
@


1.112
log
@gdb
	* xcoffread.c: Include psymtab.h.
	(xcoff_sym_fns): Update.
	* symtab.h (struct partial_symbol): Remove.
	(PSYMBOL_DOMAIN, PSYMBOL_CLASS): Remove.
	(struct partial_symtab): Remove.
	(PSYMTAB_TO_SYMTAB): Remove.
	(lookup_partial_symbol, lookup_partial_symtab, find_pc_psymtab)
	(find_pc_sect_psymtab): Remove.
	(find_pc_sect_symtab_via_partial): Declare.
	(find_pc_psymtab, find_pc_sect_psymbol, psymtab_to_symtab)
	(find_main_psymtab): Remove.
	(find_main_filename): Declare.
	(fixup_psymbol_section): Remove.
	(fixup_section): Declare.
	* symtab.c: Include psymtab.h.
	(lookup_symtab): Use lookup_symtab method.
	(lookup_partial_symtab): Remove.
	(find_pc_sect_psymtab_closer): Remove.
	(find_pc_sect_psymtab): Remove.
	(find_pc_sect_symtab_via_partial): New function.
	(find_pc_psymtab, find_pc_sect_psymbol, find_pc_psymbol): Remove.
	(fixup_section): No longer static.
	(fixup_psymbol_section): Remove.
	(lookup_symbol_aux): Use lookup_symbol_aux_quick.
	(lookup_global_symbol_from_objfile): Likewise.
	(lookup_symbol_aux_psymtabs): Remove.
	(lookup_symbol_aux_quick): New function.
	(lookup_symbol_global): Use lookup_symbol_aux_quick.
	(lookup_partial_symbol): Remove.
	(basic_lookup_transparent_type_quick): New function.
	(basic_lookup_transparent_type): Use it.
	(find_main_psymtab): Remove.
	(find_main_filename): New function.
	(find_pc_sect_symtab): Use find_pc_sect_symtab method.
	(find_line_symtab): Use expand_symtabs_with_filename method.
	(output_partial_symbol_filename): New function.
	(sources_info): Use map_partial_symbol_filenames.
	(struct search_symbols_data): New type.
	(search_symbols_file_matches): New function.
	(search_symbols_name_matches): Likewise.
	(search_symbols): Use expand_symtabs_matching method.
	(struct add_name_data): Rename from add_macro_name_data.
	(add_macro_name): Update.
	(add_partial_symbol_name): New function.
	(default_make_symbol_completion_list): Use
	map_partial_symbol_names.
	(struct add_partial_symbol_name): New type.
	(maybe_add_partial_symtab_filename): New function.
	(make_source_files_completion_list): Use
	map_partial_symbol_filenames.
	(expand_line_sal): Use expand_symtabs_with_filename method.
	* symmisc.c: Include psymtab.h.
	(print_objfile_statistics): Use print_stats method.
	(dump_objfile): Use dump method.
	(dump_psymtab, maintenance_print_psymbols)
	(maintenance_info_psymtabs, maintenance_check_symtabs)
	(extend_psymbol_list): Remove.
	* symfile.h (struct quick_symbol_functions): New struct.
	(struct sym_fns) <qf>: New field.
	(sort_pst_symbols): Remove.
	(increment_reading_symtab): Declare.
	* symfile.c: Include psymtab.h.
	(compare_psymbols, sort_pst_symbols): Remove.
	(psymtab_to_symtab): Remove.
	(increment_reading_symtab): New function.
	(symbol_file_add_with_addrs_or_offsets): Use expand_all_symtabs
	method.
	(set_initial_language): Use find_main_filename.
	(allocate_psymtab, discard_psymtab, cashier_psymtab): Remove.
	(free_named_symtabs): Remove unused code.
	(start_psymtab_common, add_psymbol_to_bcache)
	(append_psymbol_to_list, add_psymbol_to_list, init_psymbol_list):
	Remove.
	* stack.c: Include psymtab.h, symfile.h.
	(backtrace_command_1): Use find_pc_sect_symtab_via_partial.
	* source.h (psymtab_to_fullname): Don't declare.
	* source.c: Include psymtab.h.
	(select_source_symtab): Use find_last_source_symtab method.
	(forget_cached_source_info): Use forget_cached_source_info
	method.
	(find_and_open_source): No longer static.
	(psymtab_to_fullname): Remove.
	* somread.c: Include psymtab.h.
	(som_sym_fns): Update.
	* psympriv.h: New file.
	* psymtab.h: New file.
	* psymtab.c: New file.
	* objfiles.h: (ALL_OBJFILE_PSYMTABS): Remove.
	(ALL_PSYMTABS, ALL_PSPACE_PSYMTABS): Likewise.
	* objfiles.c: Include psymtab.h.
	(objfile_relocate1): Use relocate method.
	(objfile_has_partial_symbols): Use has_symbols method.
	* mipsread.c: Include psymtab.h.
	(ecoff_sym_fns): Update.
	* mi/mi-cmd-file.c: Include psymtab.h.
	(print_partial_file_name): New function.
	(mi_cmd_file_list_exec_source_files): Use
	map_partial_symbol_filenames.
	* mdebugread.c: Include psympriv.h.
	* machoread.c: Include psympriv.h.
	(macho_sym_fns): Update.
	* m2-exp.y (yylex): Use lookup_symtab.
	* elfread.c: Include psympriv.h.
	(elf_sym_fns): Update.
	* dwarf2read.c: Include psympriv.h.
	* dbxread.c: Include psympriv.h.
	(aout_sym_fns): Update.
	* cp-support.c: Include psymtab.h.
	(read_in_psymtabs): Remove.
	(make_symbol_overload_list_qualified): Use
	expand_symtabs_for_function method.
	* coffread.c: Include psympriv.h.
	(coff_sym_fns): Update.
	* blockframe.c: Include psymtab.h.
	(find_pc_partial_function): Use find_pc_sect_symtab method.
	* ada-lang.h (ada_update_initial_language): Update.
	* ada-lang.c: Include psymtab.h.
	(ada_update_initial_language): Remove 'main_pst' argument.
	(ada_lookup_partial_symbol): Remove.
	(struct ada_psym_data): New type.
	(ada_add_psyms): New function.
	(ada_add_non_local_symbols): Use map_ada_symtabs method.
	(struct add_partial_datum): New type.
	(ada_add_partial_symbol_completions): New function.
	(ada_make_symbol_completion_list): Use map_partial_symbol_names.
	(ada_exception_support_info_sniffer): Update.
	* Makefile.in (SFILES): Add psymtab.c.
	(COMMON_OBS): Add psymtab.o.
	(HFILES_NO_SRCDIR): Add psymtab.h, psympriv.h.
gdb/doc
	* gdbint.texinfo (Symbol Handling): Update.
@
text
@d1474 17
d1539 1
a1539 3
  if (!bfd_close (abfd))
    warning (_("cannot close \"%s\": %s"),
	     name, bfd_errmsg (bfd_get_error ()));
@


1.111
log
@gdb
	* objfiles.c (gdb_bfd_ref): Handle abfd==NULL.
gdb/testsuite
	* gdb.java/jprint.java (jprint.props): New field.
	* gdb.java/jprint.exp (set_lang_java): Add regression test.
@
text
@d55 1
d786 2
a787 32
  {
    struct partial_symtab *p;

    ALL_OBJFILE_PSYMTABS (objfile, p)
    {
      p->textlow += ANOFFSET (delta, SECT_OFF_TEXT (objfile));
      p->texthigh += ANOFFSET (delta, SECT_OFF_TEXT (objfile));
    }
  }

  {
    struct partial_symbol **psym;

    for (psym = objfile->global_psymbols.list;
	 psym < objfile->global_psymbols.next;
	 psym++)
      {
	fixup_psymbol_section (*psym, objfile);
	if (SYMBOL_SECTION (*psym) >= 0)
	  SYMBOL_VALUE_ADDRESS (*psym) += ANOFFSET (delta,
						    SYMBOL_SECTION (*psym));
      }
    for (psym = objfile->static_psymbols.list;
	 psym < objfile->static_psymbols.next;
	 psym++)
      {
	fixup_psymbol_section (*psym, objfile);
	if (SYMBOL_SECTION (*psym) >= 0)
	  SYMBOL_VALUE_ADDRESS (*psym) += ANOFFSET (delta,
						    SYMBOL_SECTION (*psym));
      }
  }
d891 1
a891 1
  return objfile->psymtabs != NULL;
@


1.110
log
@2010-02-08  Tristan Gingold  <gingold@@adacore.com>

	* objfiles.c (objfile_separate_debug_iterate): Do not iterate on
	brothers of the parent.
@
text
@d1507 6
a1512 1
  int *p_refcount = bfd_usrdata (abfd);
@


1.109
log
@gdb/
	* objfiles.c (objfile_relocate1): Change the return type to int.
	Describe the new return value.  Return non-zero if data changed.
	(objfile_relocate): New variable changed.  Set it.  Call
	breakpoint_re_set depending on CHANGED.
@
text
@d395 1
d400 6
a409 4
  /* Common case where there is no separate debug objfile.  */
  if (objfile == parent)
    return NULL;

@


1.108
log
@gdb/
	Fix displacement of separate debug info files.
	* objfiles.c (objfile_relocate): Rename to ...
	(objfile_relocate1): ... here and make it static.  Extend the comment.
	(objfile_relocate): New function.
	* solib-spu.c (spu_relocate_main_executable): Explicitly check if
	SYMFILE_OBJFILE is NULL.  Remove variables objfile and old_chain.
	Remove following of SEPARATE_DEBUG_OBJFILE.  new_offsets is now
	allocated using alloca.
	* symfile.c (copy_section_addr_info): Remove.
	(build_section_addr_info_from_objfile): Make it global.  New variables
	addr_bit and mask, use them.
	* symfile.h (build_section_addr_info_from_objfile): New prototype.
	(copy_section_addr_info): Remove.
@
text
@d696 2
a697 1
   entries in new_offsets.  SEPARATE_DEBUG_OBJFILE is not touched here.  */
d699 1
a699 1
static void
d718 1
a718 1
      return;
d854 3
d872 1
d874 1
a874 1
  objfile_relocate1 (objfile, new_offsets);
d902 1
a902 1
      objfile_relocate1 (debug_objfile, new_debug_offsets);
d908 2
a909 1
  breakpoint_re_set ();
@


1.107
log
@2010-01-06  Tristan Gingold  <gingold@@adacore.com>

	* symtab.c (lookup_global_symbol_from_objfile): Rename objfile
	parameter to main_objfile.  Iterate on all separate debug objfiles.
	* symfile.h (symbol_file_add_separate)
	(find_separate_debug_file_by_debuglink): Remove parameter names.
	* symfile.c (symbol_file_add_separate): Use add_separate_objfile.
	(reread_symbols): Use free_objfile_separate_debug.
	* objfiles.h (struct objfile): Add separate_debug_objfile_link.
	Adjust comment.
	(objfile_separate_debug_iterate, add_separate_debug_objfile)
	(free_objfile_separate_debug): New prototypes.
	* objfiles.c (objfile_separate_debug_iterate): New function.
	(add_separate_debug_objfile, free_objfile_separate_debug): New
	functions.
	(free_objfile): Use free_objfile_separate_debug.  Adjust for
	multiple separate debug objfile.
	(objfile_has_symbols): Adjust comment.  Iterate on all separate
	debug objfiles.
	* minsyms.c (lookup_minimal_symbol): Adjust for multiple separate
	debug objfile.
	(lookup_minimal_symbol_text): Ditto.
	(lookup_minimal_symbol_by_pc_name): Ditto.
	(lookup_minimal_symbol_solib_trampoline): Ditto.
	(lookup_minimal_symbol_by_pc_section_1): Iterate on all separate
	debug objfiles.
@
text
@d696 4
a699 3
   entries in new_offsets.  */
void
objfile_relocate (struct objfile *objfile, struct section_offsets *new_offsets)
d853 48
@


1.106
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d381 36
d494 35
d549 3
a551 5
  if (objfile->separate_debug_objfile)
    {
      free_objfile (objfile->separate_debug_objfile);
    }
  
d556 25
a580 1
      objfile->separate_debug_objfile_backlink->separate_debug_objfile = NULL;
d874 1
a874 1
   or throught its separate debug file.  */
d879 1
a879 13
  struct objfile *separate_objfile;

  if (objfile_has_partial_symbols (objfile)
      || objfile_has_full_symbols (objfile))
    return 1;

  separate_objfile = objfile->separate_debug_objfile;
  if (separate_objfile == NULL)
    return 0;

  if (objfile_has_partial_symbols (separate_objfile)
      || objfile_has_full_symbols (separate_objfile))
    return 1;
d881 3
@


1.105
log
@gdb/
	* objfiles.c (objfile_relocate): Update also the field psymtabs_addrmap.

gdb/testsuite/
	* gdb.dwarf2/dw2-ranges.exp: Call runto_main.
@
text
@d4 1
a4 1
   2002, 2003, 2004, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.104
log
@	* symmisc.c (print_symbol_bcache_statistics): Print filename cache
	statistics.
	(print_objfile_statistics): Likewise.
	* symfile.c (reread_symbols): Initialize filename_cache.
	(allocate_symtab): Cache the file name.
	(allocate_psymtab): Likewise.
	* solib-sunos.c (allocate_rt_common_objfile): Initialize
	filename_cache.
	* objfiles.h (struct objfile) <filename_cache>: New field.
	* objfiles.c (allocate_objfile): Initialize filename_cache.
	(free_objfile): Free filename_cache.
@
text
@d683 4
@


1.103
log
@gdb/
	Remove INVALID_ENTRY_POINT.
	* frame.c (inside_entry_func): New variable entry_point.  Return 0 if
	the entry point is not known.
	* solib-irix.c (enable_break): Likewise.
	* objfiles.c (init_entry_point_info): Stop using INVALID_ENTRY_POINT.
	Initialize EI.ENTRY_POINT_P.
	(entry_point_address): Rename to ...
	(entry_point_address_query): ... a new function.  Use EI.ENTRY_POINT_P.
	(entry_point_address): New function.
	(objfile_relocate): Use EI.ENTRY_POINT_P.
	* objfiles.h (struct entry_info): Simplify entry_point comment.  New
	field entry_point_p.
	(INVALID_ENTRY_POINT): Remove.
	(entry_point_address_query): New prototype.
	* solib-frv.c (enable_break): Check for NULL SYMFILE_OBJFILE and its
	EI.ENTRY_POINT_P.  Return 0 if ".interp" is not found.
@
text
@d202 1
d565 1
@


1.102
log
@2009-10-23  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* objfiles.c (allocate_objfile): Use xzalloc.
@
text
@d297 1
d301 7
a307 4
    /* Some shared libraries may have entry points set and be
       runnable.  There's no clear way to indicate this, so just check
       for values other than zero.  */
    objfile->ei.entry_point = bfd_get_start_address (objfile->obfd);    
d311 1
a311 1
      objfile->ei.entry_point = INVALID_ENTRY_POINT;
d315 2
a316 1
/* Get current entry point address.  */
d318 2
a319 2
CORE_ADDR
entry_point_address (void)
d324 1
a324 1
  if (symfile_objfile == NULL)
d340 15
a354 1
  return entry_point;
d724 1
a724 1
  if (objfile->ei.entry_point != ~(CORE_ADDR) 0)
@


1.101
log
@2009-10-23  Tristan Gingold  <gingold@@adacore.com>

	* objfiles.c (allocate_objfile): Remove useless test.  Move
	declaration of last_one to the block that uses it.
@
text
@d199 1
a199 2
  objfile = (struct objfile *) xmalloc (sizeof (struct objfile));
  memset (objfile, 0, sizeof (struct objfile));
@


1.100
log
@2009-10-22  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	PR gdb/10819
	* dwarf2-frame.c (find_cie): Don't call bsearch on empty cie_table.
	* objfiles.c (find_pc_section): Likewise.
	(update_section_map): Don't allocate empty table.
@
text
@d197 1
a197 2
  struct objfile *objfile = NULL;
  struct objfile *last_one = NULL;
d199 8
a206 15
  /* If we don't support mapped symbol files, didn't ask for the file to be
     mapped, or failed to open the mapped file for some reason, then revert
     back to an unmapped objfile. */

  if (objfile == NULL)
    {
      objfile = (struct objfile *) xmalloc (sizeof (struct objfile));
      memset (objfile, 0, sizeof (struct objfile));
      objfile->psymbol_cache = bcache_xmalloc ();
      objfile->macro_cache = bcache_xmalloc ();
      /* We could use obstack_specify_allocation here instead, but
	 gdb_obstack.h specifies the alloc/dealloc functions.  */
      obstack_init (&objfile->objfile_obstack);
      terminate_minimal_symbol_table (objfile);
    }
d261 2
@


1.99
log
@2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	Add base multi-executable/process support to GDB.

	gdb/
	* Makefile.in (SFILES): Add progspace.c.
	(COMMON_OBS): Add progspace.o.
	* progspace.h: New.
	* progspace.c: New.

	* breakpoint.h (struct bp_target_info) <placed_address_space>: New
	field.
	(struct bp_location) <pspace>: New field.
	(struct breakpoint) <pspace>: New field.
	(bpstat_stop_status, breakpoint_here_p)
	(moribund_breakpoint_here_p, breakpoint_inserted_here_p)
	(regular_breakpoint_inserted_here_p)
	(software_breakpoint_inserted_here_p, breakpoint_thread_match)
	(set_default_breakpoint): Adjust prototypes.
	(remove_breakpoints_pid, breakpoint_program_space_exit): Declare.
	(insert_single_step_breakpoint, deprecated_insert_raw_breakpoint):
	Adjust prototypes.
	* breakpoint.c (executing_startup): Delete.
	(default_breakpoint_sspace): New.
	(breakpoint_restore_shadows): Skip if the address space doesn't
	match.
	(update_watchpoint): Record the frame's program space in the
	breakpoint location.
	(insert_bp_location): Record the address space in target_info.
	Adjust to pass the symbol space to solib_name_from_address.
	(breakpoint_program_space_exit): New.
	(insert_breakpoint_locations): Switch the symbol space and thread
	when inserting breakpoints.  Don't insert breakpoints in a vfork
	parent waiting for vfork done if we're not attached to the vfork
	child.
	(remove_breakpoints_pid): New.
	(reattach_breakpoints): Switch to a thread of PID.  Ignore
	breakpoints of other symbol spaces.
	(create_internal_breakpoint): Store the symbol space in the sal.
	(create_longjmp_master_breakpoint): Iterate over all symbol
	spaces.
	(update_breakpoints_after_exec): Ignore breakpoints for other
	symbol spaces.
	(remove_breakpoint): Rename to ...
	(remove_breakpoint_1): ... this.  Pass the breakpoints symbol
	space to solib_name_from_address.
	(remove_breakpoint): New.
	(mark_breakpoints_out): Ignore breakpoints from other symbol
	spaces.
	(breakpoint_init_inferior): Ditto.
	(breakpoint_here_p): Add an address space argument and adjust to
	use breakpoint_address_match.
	(moribund_breakpoint_here_p): Ditto.
	(regular_breakpoint_inserted_here_p): Ditto.
	(breakpoint_inserted_here_p): Ditto.
	(software_breakpoint_inserted_here_p): Ditto.
	(breakpoint_thread_match): Ditto.
	(bpstat_check_location): Ditto.
	(bpstat_stop_status): Ditto.
	(print_breakpoint_location): If there's a location to print,
	switch the current symbol space.
	(print_one_breakpoint_location): Add `allflag' argument.
	(print_one_breakpoint): Ditto.	Adjust.
	(do_captured_breakpoint_query): Adjust.
	(breakpoint_1): Adjust.
	(breakpoint_has_pc): Also match the symbol space.
	(describe_other_breakpoints): Add a symbol space argument and
	adjust.
	(set_default_breakpoint): Add a symbol space argument.	Set
	default_breakpoint_sspace.
	(breakpoint_address_match): New.
	(check_duplicates_for): Add an address space argument, and adjust.
	(set_raw_breakpoint): Record the symbol space in the location and
	in the breakpoint.
	(set_longjmp_breakpoint): Skip longjmp master breakpoints from
	other symbol spaces.
	(remove_thread_event_breakpoints, remove_solib_event_breakpoints)
	(disable_breakpoints_in_shlibs): Skip breakpoints from other
	symbol spaces.
	(disable_breakpoints_in_unloaded_shlib): Match symbol spaces.
	(create_catchpoint): Set the symbol space in the sal.
	(disable_breakpoints_before_startup): Skip breakpoints from other
	symbol spaces.	Set executing_startup in the current symbol space.
	(enable_breakpoints_after_startup): Clear executing_startup in the
	current symbol space.  Skip breakpoints from other symbol spaces.
	(clone_momentary_breakpoint): Also copy the symbol space.
	(add_location_to_breakpoint): Set the location's symbol space.
	(bp_loc_is_permanent): Switch thread and symbol space.
	(create_breakpoint): Adjust.
	(expand_line_sal_maybe): Expand comment to mention symbol spaces.
	Switch thread and symbol space when reading memory.
	(parse_breakpoint_sals): Set the symbol space in the sal.
	(break_command_really): Ditto.
	(skip_prologue_sal): Switch and space.
	(resolve_sal_pc): Ditto.
	(watch_command_1): Record the symbol space in the sal.
	(create_ada_exception_breakpoint): Adjust.
	(clear_command): Adjust.  Match symbol spaces.
	(update_global_location_list): Use breakpoint_address_match.
	(breakpoint_re_set_one): Switch thread and space.
	(breakpoint_re_set): Save symbol space.
	(breakpoint_re_set_thread): Also reset the symbol space.
	(deprecated_insert_raw_breakpoint): Add an address space argument.
	Adjust.
	(insert_single_step_breakpoint): Ditto.
	(single_step_breakpoint_inserted_here_p): Ditto.
	(clear_syscall_counts): New.
	(_initialize_breakpoint): Install it as inferior_exit observer.

	* exec.h: Include "progspace.h".
	(exec_bfd, exec_bfd_mtime): New defines.
	(exec_close): Declare.
	* exec.c: Include "gdbthread.h" and "progspace.h".
	(exec_bfd, exec_bfd_mtime, current_target_sections_1): Delete.
	(using_exec_ops): New.
	(exec_close_1): Rename to exec_close, and make public.
	(exec_close): Rename to exec_close_1, and adjust all callers.  Add
	description.  Remove target sections and close executables from
	all program spaces.
	(exec_file_attach): Add comment.
	(add_target_sections): Check on `using_exec_ops' to check if the
	target should be pushed.
	(remove_target_sections): Only unpush the target if there are no
	more target sections in any symbol space.
	* gdbcore.h: Include "exec.h".
	(exec_bfd, exec_bfd_mtime): Remove declarations.

	* frame.h (get_frame_program_space, get_frame_address_space)
	(frame_unwind_program_space): Declare.
	* frame.c (struct frame_info) <pspace, aspace>: New fields.
	(create_sentinel_frame): Add program space argument.  Set the
	pspace and aspace fields of the frame object.
	(get_current_frame, create_new_frame): Adjust.
	(get_frame_program_space): New.
	(frame_unwind_program_space): New.
	(get_frame_address_space): New.
	* stack.c (print_frame_info): Adjust.
	(print_frame): Use the frame's program space.

	* gdbthread.h (any_live_thread_of_process): Declare.
	* thread.c (any_live_thread_of_process): New.
	(switch_to_thread): Switch the program space as well.
	(restore_selected_frame): Don't warn if trying to restore frame
	level 0.

	* inferior.h: Include "progspace.h".
	(detach_fork): Declare.
	(struct inferior) <removable, aspace, pspace>
	<vfork_parent, vfork_child, pending_detach>
	<waiting_for_vfork_done>: New fields.
	<terminal_info>: Remove field.
	<data, num_data>: New fields.
	(register_inferior_data, register_inferior_data_with_cleanup)
	(clear_inferior_data, set_inferior_data, inferior_data): Declare.
	(exit_inferior, exit_inferior_silent, exit_inferior_num_silent)
	(inferior_appeared): Declare.
	(find_inferior_pid): Typo.
	(find_inferior_id, find_inferior_for_program_space): Declare.
	(set_current_inferior, save_current_inferior, prune_inferiors)
	(number_of_inferiors): Declare.
	(inferior_list): Declare.
	* inferior.c: Include "gdbcore.h" and "symfile.h".
	(inferior_list): Make public.
	(delete_inferior_1): Always delete thread silently.
	(find_inferior_id): Make public.
	(current_inferior_): New.
	(current_inferior): Use it.
	(set_current_inferior): New.
	(restore_inferior): New.
	(save_current_inferior): New.
	(free_inferior): Free the per-inferior data.
	(add_inferior_silent): Allocate per-inferior data.
	Call inferior_appeared.
	(delete_threads_of_inferior): New.
	(delete_inferior_1): Adjust interface to take an inferior pointer.
	(delete_inferior): Adjust.
	(delete_inferior_silent): Adjust.
	(exit_inferior_1): New.
	(exit_inferior): New.
	(exit_inferior_silent): New.
	(exit_inferior_num_silent): New.
	(detach_inferior): Adjust.
	(inferior_appeared): New.
	(discard_all_inferiors): Adjust.
	(find_inferior_id): Make public.  Assert pid is not zero.
	(find_inferior_for_program_space): New.
	(have_inferiors): Check if we have any inferior with pid not zero.
	(have_live_inferiors): Go over all pushed targets looking for
	process_stratum.
	(prune_inferiors): New.
	(number_of_inferiors): New.
	(print_inferior): Add executable column.  Print vfork parent/child
	relationships.
	(inferior_command): Adjust to cope with not running inferiors.
	(remove_inferior_command): New.
	(add_inferior_command): New.
	(clone_inferior_command): New.
	(struct inferior_data): New.
	(struct inferior_data_registration): New.
	(struct inferior_data_registry): New.
	(inferior_data_registry): New.
	(register_inferior_data_with_cleanup): New.
	(register_inferior_data): New.
	(inferior_alloc_data): New.
	(inferior_free_data): New.
	(clear_inferior_data): New.
	(set_inferior_data): New.
	(inferior_data): New.
	(initialize_inferiors): New.
	(_initialize_inferiors): Register "add-inferior",
	"remove-inferior" and "clone-inferior" commands.

	* objfiles.h: Include "progspace.h".
	(struct objfile) <pspace>: New field.
	(symfile_objfile, object_files): Don't declare.
	(ALL_PSPACE_OBJFILES): New.
	(ALL_PSPACE_OBJFILES_SAFE): New.
	(ALL_OBJFILES, ALL_OBJFILES_SAFE): Adjust.
	(ALL_PSPACE_SYMTABS): New.
	(ALL_PRIMARY_SYMTABS): Adjust.
	(ALL_PSPACE_PRIMARY_SYMTABS): New.
	(ALL_PSYMTABS): Adjust.
	(ALL_PSPACE_PSYMTABS): New.
	* objfiles.c (object_files, symfile_objfile): Delete.
	(struct objfile_sspace_info): New.
	(objfiles_pspace_data): New.
	(objfiles_pspace_data_cleanup): New.
	(get_objfile_pspace_data): New.
	(objfiles_changed_p): Delete.
	(allocate_objfile): Set the objfile's program space.  Adjust to
	reference objfiles_changed_p in pspace data.
	(free_objfile): Adjust to reference objfiles_changed_p in pspace
	data.
	(objfile_relocate): Ditto.
	(update_section_map): Add pspace argument.  Adjust to iterate over
	objfiles in the passed in pspace.
	(find_pc_section): Delete sections and num_sections statics.
	Adjust to refer to program space's objfiles_changed_p.	Adjust to
	refer to sections and num_sections store in the objfile's pspace
	data.
	(objfiles_changed): Adjust to reference objfiles_changed_p in
	pspace data.
	(_initialize_objfiles): New.
	* linespec.c (decode_all_digits, decode_dollar): Set the sal's
	program space.
	* source.c (current_source_pspace): New.
	(get_current_source_symtab_and_line): Set the sal's program space.
	(set_current_source_symtab_and_line): Set current_source_pspace.
	(select_source_symtab): Ditto.	Use ALL_OBJFILES.
	(forget_cached_source_info): Iterate over all program spaces.
	* symfile.c (clear_symtab_users): Adjust.
	* symmisc.c (print_symbol_bcache_statistics): Iterate over all
	program spaces.
	(print_objfile_statistics): Ditto.
	(maintenance_print_msymbols): Ditto.
	(maintenance_print_objfiles): Ditto.
	(maintenance_info_symtabs): Ditto.
	(maintenance_info_psymtabs): Ditto.
	* symtab.h (SYMTAB_PSPACE): New.
	(struct symtab_and_line) <pspace>: New field.
	* symtab.c (init_sal): Clear the sal's program space.
	(find_pc_sect_symtab): Set the sal's program space.  Switch thread
	and space.
	(append_expanded_sal): Add program space argument.  Iterate over
	all program spaces.
	(expand_line_sal): Iterate over all program spaces.  Switch
	program space.

	* target.h (enum target_waitkind) <TARGET_WAITKIND_VFORK_DONE>: New.
	(struct target_ops) <to_thread_address_space>: New field.
	(target_thread_address_space): Define.
	* target.c (target_detach): Only remove breakpoints from the
	inferior we're detaching.
	(target_thread_address_space): New.

	* defs.h (initialize_progspace): Declare.
	* top.c (gdb_init): Call it.

	* solist.h (struct so_list) <sspace>: New field.
	* solib.h (struct program_space): Forward declare.
	(solib_name_from_address): Adjust prototype.
	* solib.c (so_list_head): Replace with a macro referencing the
	program space.
	(update_solib_list): Set the so's program space.
	(solib_name_from_address): Add a program space argument and adjust.

	* solib-svr4.c (struct svr4_info) <pid>: Delete field.
	<interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low>
	<interp_plt_sect_high>: New fields.
	(svr4_info_p, svr4_info): Delete.
	(solib_svr4_sspace_data): New.
	(get_svr4_info): Rewrite.
	(svr4_sspace_data_cleanup): New.
	(open_symbol_file_object): Adjust.
	(svr4_default_sos): Adjust.
	(svr4_fetch_objfile_link_map): Adjust.
	(interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low)
	(interp_plt_sect_high): Delete.
	(svr4_in_dynsym_resolve_code): Adjust.
	(enable_break): Adjust.
	(svr4_clear_solib): Revert bit that removed the svr4_info here,
	and reinstate clearing debug_base, debug_loader_offset_p,
	debug_loader_offset and debug_loader_name.
	(_initialize_svr4_solib): Register solib_svr4_pspace_data.  Don't
	install an inferior_exit observer anymore.

	* printcmd.c (struct display) <pspace>: New field.
	(display_command): Set the display's sspace.
	(do_one_display): Match the display's sspace.
	(display_uses_solib_p): Ditto.

	* linux-fork.c (detach_fork): Moved to infrun.c.
	(_initialize_linux_fork): Moved "detach-on-fork" command to
	infrun.c.
	* infrun.c (detach_fork): Moved from linux-fork.c.
	(proceed_after_vfork_done): New.
	(handle_vfork_child_exec_or_exit): New.
	(follow_exec_mode_replace, follow_exec_mode_keep)
	(follow_exec_mode_names, follow_exec_mode_string)
	(show_follow_exec_mode_string): New.
	(follow_exec): New.  Reinstate the mark_breakpoints_out call.
	Remove shared libraries before attaching new executable.  If user
	wants to keep the inferior, keep it.
	(displaced_step_fixup): Adjust to pass an address space to the
	breakpoints module.
	(resume): Ditto.
	(clear_proceed_status): In all-stop mode, always clear the proceed
	status of all threads.
	(prepare_to_proceed): Adjust to pass an address space to the
	breakpoints module.
	(proceed): Ditto.
	(adjust_pc_after_break): Ditto.
	(handle_inferior_event): When handling a process exit, switch the
	program space to the inferior's that had exited.  Call
	handle_vfork_child_exec_or_exit.  Adjust to pass an address space
	to the breakpoints module.  In non-stop mode, when following a
	fork and detach-fork is off, also resume the other branch.  Handle
	TARGET_WAITKIND_VFORK_DONE.  Set the program space in sals.
	(normal_stop): Prune inferiors.
	(_initialize_infrun): Install the new "follow-exec-mode" command.
	"detach-on-fork" moved here.

	* regcache.h (get_regcache_aspace): Declare.
	* regcache.c (struct regcache) <aspace>: New field.
	(regcache_xmalloc): Clear the aspace.
	(get_regcache_aspace): New.
	(regcache_cpy): Copy the aspace field.
	(regcache_cpy_no_passthrough): Ditto.
	(get_thread_regcache): Fetch the thread's address space from the
	target, and store it in the regcache.

	* infcall.c (call_function_by_hand): Set the sal's pspace.

	* arch-utils.c (default_has_shared_address_space): New.
	* arch-utils.h (default_has_shared_address_space): Declare.

	* gdbarch.sh (has_shared_address_space): New.
	* gdbarch.h, gdbarch.c: Regenerate.

	* linux-tdep.c: Include auxv.h, target.h, elf/common.h.
	(linux_has_shared_address_space): New.
	(_initialize_linux_tdep): Declare.

	* arm-tdep.c (arm_software_single_step): Pass the frame's address
	space to insert_single_step_breakpoint.
	* arm-linux-tdep.c (arm_linux_software_single_step): Pass the
	frame's pspace to breakpoint functions.
	* cris-tdep.c (crisv32_single_step_through_delay): Ditto.
	(cris_software_single_step): Ditto.
	* mips-tdep.c (deal_with_atomic_sequence): Add frame argument.
	Pass the frame's pspace to breakpoint functions.
	(mips_software_single_step): Adjust.
	(mips_single_step_through_delay): Adjust.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Adjust.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Adjust.
	* solib-irix.c (enable_break): Adjust to pass the current frame's
	address space to breakpoint functions.
	* sparc-tdep.c (sparc_software_single_step): Ditto.
	* spu-tdep.c (spu_software_single_step): Ditto.
	* alpha-tdep.c (alpha_software_single_step): Ditto.
	* record.c (record_wait): Adjust to pass an address space to the
	breakpoints module.

	* fork-child.c (fork_inferior): Set the new inferior's program and
	address spaces.
	* inf-ptrace.c (inf_ptrace_follow_fork): Copy the parent's program
	and address spaces.
	(inf_ptrace_attach): Set the inferior's program and address spaces.
	* linux-nat.c: Include "solib.h".
	(linux_child_follow_fork): Manage parent and child's program and
	address spaces.	 Clone the parent's program space if necessary.
	Don't wait for the vfork to be done here.  Refuse to resume if
	following the vfork parent while leaving the child stopped.
	(resume_callback): Don't resume a vfork parent.
	(linux_nat_resume): Also check for pending events in the
	lp->waitstatus field.
	(linux_handle_extended_wait): Report TARGET_WAITKIND_VFORK_DONE
	events to the core.
	(stop_wait_callback): Don't wait for SIGSTOP on vfork parents.
	(cancel_breakpoint): Adjust.
	* linux-thread-db.c (thread_db_wait): Don't remove thread event
	breakpoints here.
	(thread_db_mourn_inferior): Don't mark breakpoints out here.
	Remove thread event breakpoints after mourning.
	* corelow.c: Include progspace.h.
	(core_open): Set the inferior's program and address spaces.
	* remote.c (remote_add_inferior): Set the new inferior's program
	and address spaces.
	(remote_start_remote): Update address spaces.
	(extended_remote_create_inferior_1): Don't init the thread list if
	we already debugging other inferiors.
	* darwin-nat.c (darwin_attach): Set the new inferior's program and
	address spaces.
	* gnu-nat.c (gnu_attach): Ditto.
	* go32-nat.c (go32_create_inferior): Ditto.
	* inf-ttrace.c (inf_ttrace_follow_fork, inf_ttrace_attach): Ditto.
	* monitor.c (monitor_open): Ditto.
	* nto-procfs.c (procfs_attach, procfs_create_inferior): Ditto.
	* procfs.c (do_attach): Ditto.
	* windows-nat.c (do_initial_windows_stuff): Ditto.

	* inflow.c (inferior_process_group)
	(terminal_init_inferior_with_pgrp, terminal_inferior,
	(terminal_ours_1, inflow_inferior_exit, copy_terminal_info)
	(child_terminal_info, new_tty_postfork, set_sigint_trap): Adjust
	to use per-inferior data instead of inferior->terminal_info.
	(inflow_inferior_data): New.
	(inflow_new_inferior): Delete.
	(inflow_inferior_data_cleanup): New.
	(get_inflow_inferior_data): New.

	* mi/mi-interp.c (mi_new_inferior): Rename to...
	(mi_inferior_appeared): ... this.
	(mi_interpreter_init): Adjust.

	* tui/tui-disasm.c: Include "progspace.h".
	(tui_set_disassem_content): Pass an address space to
	breakpoint_here_p.

	* NEWS: Mention multi-program debugging support.  Mention new
	commands "add-inferior", "clone-inferior", "remove-inferior",
	"maint info program-spaces", and new option "set
	follow-exec-mode".

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* observer.texi (new_inferior): Rename to...
	(inferior_appeared): ... this.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/testsuite/
	* gdb.base/foll-vfork.exp: Adjust to spell out "follow-fork".
	* gdb.base/foll-exec.exp: Adjust to expect a process id before
	"Executing new program".
	* gdb.base/foll-fork.exp: Adjust to spell out "follow-fork".
	* gdb.base/multi-forks.exp: Ditto.  Adjust to the inferior being
	left listed after having been killed.
	* gdb.base/attach.exp: Adjust to spell out "symbol-file".
	* gdb.base/maint.exp: Adjust test.

	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* gdb.multi/Makefile.in: New.
	* gdb.multi/base.exp: New.
	* gdb.multi/goodbye.c: New.
	* gdb.multi/hangout.c: New.
	* gdb.multi/hello.c: New.
	* gdb.multi/bkpt-multi-exec.c: New.
	* gdb.multi/bkpt-multi-exec.exp: New.
	* gdb.multi/crashme.c: New.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Inferiors): Rename node to ...
	(Inferiors and Programs): ... this.  Mention running multiple
	programs in the same debug session.
	<info inferiors>: Mention the new 'Executable' column if "info
	inferiors".  Update examples.  Document the "add-inferior",
	"clone-inferior", "remove-inferior" and "maint info
	program-spaces" commands.
	(Process): Rename node to...
	(Forks): ... this.  Document "set|show follow-exec-mode".
@
text
@d1116 8
d1186 8
@


1.98
log
@2009-10-12  Tristan Gingold  <gingold@@adacore.com>

	* objfiles.c (objfile_has_symbols): New function.
	* objfiles.h (objfile_has_symbols): Add prototype.
	* symfile.c (symbol_file_add_with_addrs_or_offsets): Call
	objfile_has_symbols.
	(reread_symbols): Ditto.
@
text
@a63 1
struct objfile *object_files;	/* Linked list of all objfiles */
a64 1
struct objfile *symfile_objfile;	/* Main symbol table loaded from */
d67 41
a110 2
static int objfiles_changed_p;

d248 2
d278 2
a279 1
  objfiles_changed_p = 1;  /* Rebuild section map next time we need it.  */
d281 1
a281 1
  return (objfile);
d555 4
a559 2
  objfile = NULL;
  objfiles_changed_p = 1;  /* Rebuild section map next time we need it.  */
d731 1
a731 1
  objfiles_changed_p = 1;
d1098 2
a1099 1
update_section_map (struct obj_section ***pmap, int *pmap_size)
d1105 1
a1105 1
  gdb_assert (objfiles_changed_p != 0);
d1111 4
a1114 3
  ALL_OBJSECTIONS (objfile, s)
    if (insert_section_p (objfile->obfd, s->the_bfd_section))
      alloc_size += 1;
d1119 4
a1122 3
  ALL_OBJSECTIONS (objfile, s)
    if (insert_section_p (objfile->obfd, s->the_bfd_section))
      map[i++] = s;
d1158 1
a1158 3
  static struct obj_section **sections;
  static int num_sections;

d1166 2
a1167 1
  if (objfiles_changed_p != 0)
d1169 14
a1182 9
      update_section_map (&sections, &num_sections);

      /* Don't need updates to section map until objfiles are added
         or removed.  */
      objfiles_changed_p = 0;
    }

  sp = (struct obj_section **) bsearch (&pc, sections, num_sections,
					sizeof (*sections), bsearch_cmp);
d1323 2
a1324 1
  objfiles_changed_p = 1;  /* Rebuild section map next time we need it.  */
d1375 10
@


1.97
log
@gdb/
	* objfiles.c (free_objfile): Clear SYMFILE_OBJFILE if it is OBJFILE.
	* rs6000-nat.c (vmap_ldinfo): Only assertion check SYMFILE_OBJFILE now.
	* symfile.c (syms_from_objfile, symbol_file_clear): Likewise.
@
text
@d720 24
@


1.96
log
@2009-09-14  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* objfiles.c (qsort_cmp): Remove asserts.
	(insert_section_p, filter_debuginfo_sections): New function.
	(filter_overlapping_sections): Likewise.
	(update_section_map): Adjust.
@
text
@d462 2
a463 2
  /* If we are going to free the runtime common objfile, mark it
     as unallocated.  */
@


1.96.2.1
log
@gdb/
	* objfiles.c (free_objfile): Clear SYMFILE_OBJFILE if it is OBJFILE.
	* rs6000-nat.c (vmap_ldinfo): Only assertion check SYMFILE_OBJFILE now.
	* symfile.c (syms_from_objfile, symbol_file_clear): Likewise.
@
text
@d462 2
a463 2
  if (objfile == symfile_objfile)
    symfile_objfile = NULL;
@


1.96.2.2
log
@2009-10-22  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	PR gdb/10819
	* dwarf2-frame.c (find_cie): Don't call bsearch on empty cie_table.
	* objfiles.c (find_pc_section): Likewise.
	(update_section_map): Don't allocate empty table.
@
text
@a1047 8
  /* This happens on detach/attach (e.g. in gdb.base/attach.exp).  */
  if (alloc_size == 0)
    {
      *pmap = NULL;
      *pmap_size = 0;
      return;
    }

a1107 8
  /* The C standard (ISO/IEC 9899:TC2) requires the BASE argument to
     bsearch be non-NULL.  */
  if (sections == NULL)
    {
      gdb_assert (num_sections == 0);
      return NULL;
    }

@


1.95
log
@	* objfiles.c (struct objfile_data): Delete member cleanup and replace
	with save, free.
	(register_objfile_data_with_cleanup): Delete arg cleanup and replace
	with save, free.  All callers updated.
	(clear_objfile_data): Replace cleanup loop with separate save and
	free loops.
	* objfiles.h (register_objfile_data_with_cleanup): Update.
	* arm-tdep.c (arm_objfile_data_free): Renamed from
	arm_objfile_data_cleanup, all callers updated.
	* dwarf2read.c (dwarf2_per_objfile_free): Renamed from
	dwarf2_per_objfile_cleanup, all callers updated.
	* python/py-objfile.c (py_free_objfile): Renamed from clean_up_objfile,
	all callers updated.
	* python/py-type.c (save_objfile_types): Renamed from
	clean_up_objfile_types, all callers updated.
@
text
@d54 1
d806 1
a806 4
    {
      gdb_assert (obj_section_endaddr (sect1) <= sect2_addr);
      return -1;
    }
d808 61
a868 4
    {
      gdb_assert (sect1_addr >= obj_section_endaddr (sect2));
      return 1;
    }
d870 2
d895 135
a1029 1
/* Update PMAP, PMAP_SIZE with non-TLS sections from all objfiles.  */
d1034 1
a1034 1
  int map_size, i, j;
d1043 1
a1043 5
#define insert_p(objf, sec) \
  ((bfd_get_section_flags ((objf)->obfd, (sec)->the_bfd_section) \
    & SEC_THREAD_LOCAL) == 0)

  map_size = 0;
d1045 2
a1046 2
    if (insert_p (objfile, s))
      map_size += 1;
d1048 1
a1048 1
  map = xmalloc (map_size * sizeof (*map));
d1052 1
a1052 1
    if (insert_p (objfile, s))
d1055 7
a1061 31
#undef insert_p

  qsort (map, map_size, sizeof (*map), qsort_cmp);

  /* With separate debuginfo files, we may have up to two (almost)
     identical copies of some obj_sections in the map.
     Filter out duplicates.  */
  for (i = 0, j = 0; i < map_size; ++i)
    {
      struct obj_section *sect1 = map[i];
      struct obj_section *sect2 = (i + 1 < map_size) ? map[i + 1] : NULL;

      if (sect2 == NULL
	  || obj_section_addr (sect1) != obj_section_addr (sect2))
	map[j++] = sect1;
      else
	{
	  map[j++] = preferred_obj_section (sect1, sect2);
	  ++i;
	}
    }

  if (j < map_size)
    {
      /* Some duplicates were eliminated.
	 The new size shouldn't be less than half of the original. */
      gdb_assert (map_size / 2 <= j);
      map_size = j;

      map = xrealloc (map, map_size * sizeof (*map));  /* Trim excess space.  */
    }
d1063 1
a1063 1
    gdb_assert (j == map_size);
@


1.94
log
@	* NEWS: Add note on "info sharedlibrary".
	Remove note on "set print symbol-loading".
	* main.c (captured_main): Pass !batch for from_tty when calling
	symbol_file_add_main.
	* objfiles.h (objfile_has_partial_symbols): Declare.
	(objfile_has_full_symbols): Declare.
	* objfiles.c (objfile_has_partial_symbols): New function.
	(have_partial_symbols): Use it.
	(objfile_has_full_symbols): New function.
	(have_full_symbols): Use it.
	* solib.c: Include interps.h.
	(solib_read_symbols): Back out patch of 2008-07-10.
	Add test for info_verbose for symbol loading messages for
	consistency with symfile.c.
	(info_sharedlibrary_command): Handle optional parameter of regex of
	libraries to list.  Inform user of libraries without debugging info.
	Rewrite to use ui_out routines to format output.
	* symfile.c (print_symbol_loading): Delete.
	(symbol_file_add_with_addrs_or_offsets): Back out patch of 2008-07-10.
	Print "no debugging symbols found" only if from_tty || info_verbose;
	and only check file being loaded, not all files.
	(reread_symbols): Test file being loaded for whether it has symbols,
	not all files.
	(__initialize_symfile): Delete `set print symbol-loading'.
	* symfile.h (print_symbol_loading): Delete.

	* doc/gdb.texinfo (Symbols): Delete `set print symbol-loading'.
	(Files): Add note on new optional regex arg to `info sharedlibrary'.
@
text
@d978 2
a979 1
  void (*cleanup) (struct objfile *, void *);
d997 2
a998 1
register_objfile_data_with_cleanup (void (*cleanup) (struct objfile *, void *))
d1010 2
a1011 1
  (*curr)->data->cleanup = cleanup;
d1019 1
a1019 1
  return register_objfile_data_with_cleanup (NULL);
d1047 10
d1060 2
a1061 2
    if (objfile->data[i] != NULL && registration->data->cleanup)
      registration->data->cleanup (objfile, objfile->data[i]);
@


1.93
log
@2009-08-21  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* objfiles.h (gdb_bfd_ref): New prototype.
	* objfiles.c (gdb_bfd_ref): New function.
	(allocate_objfile): Call it.
	(gdb_bfd_unref): Adjust assertion.
	* solib.c (solib_map_sections): Add reference.
	(symbol_add_stub): Don't add reference here.
	* symfile.c (reread_symbols): Add reference.
@
text
@d703 16
d730 2
a731 4
    if (ofp->psymtabs != NULL)
      {
	return 1;
      }
d747 2
a748 4
    if (ofp->symtabs != NULL)
      {
	return 1;
      }
@


1.92
log
@2009-08-17  Pedro Alves  <pedro@@codesourcery.com>>

	* objfiles.c (objfile_relocate): Relocate the entry point before
	relocating the section offsets.  Flush the section map before
	resetting breakpoints.
@
text
@d184 1
a184 1
  objfile->obfd = abfd;
d1065 20
a1084 1
/* Unreference and possibly close abfd.  */
d1096 7
a1102 3
  /* Valid range for p_refcount: NULL (single owner), or a pointer
     to int counter, which has a value of 1 (single owner) or 2 (shared).  */
  gdb_assert (p_refcount == NULL || *p_refcount == 1 || *p_refcount == 2);
a1103 6
  if (p_refcount != NULL)
    {
      *p_refcount -= 1;
      if (*p_refcount > 0)
	return;
    }
@


1.91
log
@gdb/
	* objfiles.c (gdb_bfd_unref): Use the bfd_usrdata accessor.
	* solib.c (symbol_add_stub): Likewise.
	* symfile.c (symfile_bfd_open): Assert BFD_USRDATA is NULL.
@
text
@a668 6
  {
    int i;
    for (i = 0; i < objfile->num_sections; ++i)
      (objfile->section_offsets)->offsets[i] = ANOFFSET (new_offsets, i);
  }

d681 9
a700 1
  objfiles_changed_p = 1;  /* Rebuild section map next time we need it.  */
@


1.90
log
@2009-08-10  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* objfiles.c (qsort_cmp): Remove assert.
	(preferred_obj_section): New function.
	(update_section_map): Filter duplicates.
@
text
@d1073 1
a1073 1
  p_refcount = abfd->usrdata;
d1086 1
a1086 1
  abfd->usrdata = NULL;  /* Paranoia.  */
@


1.89
log
@2009-08-04  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* objfiles.h (OBJF_KEEPBFD): Delete.
	(gdb_bfd_unref): New prototype.
	* objfiles.c (gdb_bfd_unref): New function.
	(free_objfile): Call gdb_bfd_unref.
	* solib.c (free_so): Likewise.
	(symbol_add_stub): Set refcount.
@
text
@a799 2
  /* This can happen for separate debug-info files.  */
  gdb_assert (obj_section_endaddr (sect1) == obj_section_endaddr (sect2));
d804 20
d829 1
a829 1
  int map_size, idx;
d849 1
a849 1
  idx = 0;
d852 1
a852 1
      map[idx++] = s;
d858 30
@


1.88
log
@	* arch-utils.c (displaced_step_at_entry_point): Do not call
	gdbarch_convert_from_func_ptr_addr.
	* cris-tdep.c: Remove outdated comment.
	* infcall.c (call_function_by_hand): Do not call
	gdbarch_convert_from_func_ptr_addr after entry_point_address.
	* objfiles.c (entry_point_address): Call both
	gdbarch_convert_from_func_ptr_addr and
	gdbarch_addr_bits_remove.
@
text
@d455 1
a455 10
  /* We always close the bfd, unless the OBJF_KEEPBFD flag is set.  */

  if (objfile->obfd != NULL && !(objfile->flags & OBJF_KEEPBFD))
    {
      char *name = bfd_get_filename (objfile->obfd);
      if (!bfd_close (objfile->obfd))
	warning (_("cannot close \"%s\": %s"),
		 name, bfd_errmsg (bfd_get_error ()));
      xfree (name);
    }
d1014 32
@


1.87
log
@2009-07-22  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* objfiles.h (objfiles_changed): New prototype.
	* objfiles.c (objfiles_updated_p): Rename to objfiles_changed_p.
	(allocate_objfile, free_objfile): Must rebuild section map.
	(objfile_relocate): Likewise.
	(update_section_map, find_pc_section): Adjust.
	(set_objfiles_updated_on_exe_change): Remove.
	(set_objfiles_updated_on_solib_activity): Remove.
	(_initialize_objfiles): Remove.
	(objfiles_changed): New function.
	* symfile.c (reread_symbols): Call objfiles_changed.
@
text
@d282 20
a301 1
  return symfile_objfile ? symfile_objfile->ei.entry_point : 0;
@


1.86
log
@2009-07-21  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* objfiles.c (objfiles_updated_p): New variable.
	(qsort_cmp, bsearch_cmp, update_section_map): New function.
	(find_pc_section): Use bsearch.
	(set_objfiles_updated_on_exe_change): New function.
	(set_objfiles_updated_on_solib_activity): New function.
	(_initialize_objfiles): New function.
@
text
@d71 1
a71 1
static int objfiles_updated_p;
d238 2
d506 1
d688 1
d805 1
a805 1
  gdb_assert (objfiles_updated_p != 0);
d864 1
a864 1
  if (objfiles_updated_p != 0)
d870 1
a870 1
      objfiles_updated_p = 0;
d996 2
a997 17
/* Set objfiles_updated_p so section map will be rebuilt next time it
   is used.  Called by executable_changed observer.  */

static void
set_objfiles_updated_on_exe_change (void)
{
  objfiles_updated_p = 1;  /* Rebuild section map next time we need it.  */
}

/* Set objfiles_updated_p so section map will be rebuilt next time it
   is used.  Called by solib_loaded/unloaded observer.  */

static void
set_objfiles_updated_on_solib_activity (struct so_list *so_list)
{
  objfiles_updated_p = 1;  /* Rebuild section map next time we need it.  */
}
d1000 1
a1000 1
_initialize_objfiles (void)
d1002 1
a1002 3
  observer_attach_executable_changed (set_objfiles_updated_on_exe_change);
  observer_attach_solib_loaded (set_objfiles_updated_on_solib_activity);
  observer_attach_solib_unloaded (set_objfiles_updated_on_solib_activity);
@


1.85
log
@	* objfiles.c (objfile_relocate): Do not relocate the same
	BLOCKVECTOR_MAP address map multiple times.
@
text
@d53 1
d68 5
d766 79
d850 4
a853 2
  struct obj_section *s;
  struct objfile *objfile;
d860 8
a867 3
  ALL_OBJSECTIONS (objfile, s)
    if (obj_section_addr (s) <= pc && pc < obj_section_endaddr (s))
      return s;
d869 4
d991 26
@


1.84
log
@2009-06-23  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	Revert 2009-05-14 breakpoint commit (no longer needed).
	* breakpoint.h (breakpoint_re_set_objfile): Remove
	* breakpoint.c (breakpoint_re_set_objfile): Likewise
	(create_overlay_event_breakpoint): Remove objfile parameter,
	iterate over all objfiles.
	* objfiles.c (objfile_relocate): Update.
	* symfile.c (new_symfile_objfile): Likewise.
@
text
@d573 4
a585 3
          if (BLOCKVECTOR_MAP (bv))
            addrmap_relocate (BLOCKVECTOR_MAP (bv),
                              ANOFFSET (delta, s->block_line_section));
@


1.83
log
@2009-05-14  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* breakpoint.h: Add breakpoint_re_set_objfile prototype.
	* breakpoint.c (create_overlay_event_breakpoint): Renamed
	from create_overlay_event_breakpoint_1, old
	create_overlay_event_breakpoint deleted.
	(breakpoint_re_set_objfile): Don't rescan all objfiles
	unnecessarily.
	(breakpoint_re_set): New function.
	* symfile.c (new_symfile_objfile): Call breakpoint_re_set_objfile
	instead of breakpoint_re_set.
	* objfiles.c (objfile_relocate): Likewise.
@
text
@d677 1
a677 1
  breakpoint_re_set_objfile (objfile);
@


1.82
log
@	* breakpoint.c (bpstat_check_breakpoint_conditions): Use
	value_mark and value_free_to_mark.
	* objfiles.c (free_objfile): Call objfile_free_data before
	freeing the BFD.
@
text
@d677 1
a677 1
  breakpoint_re_set ();
@


1.81
log
@	* solist.h (struct target_so_ops): New member bfd_open.
	(solib_find): Add prototype.
	(solib_bfd_fopen): Add prototype.
	* solib.c (solib_find, solib_bfd_fopen): New functions, extracted
	from solib_bfd_open.
	(solib_bfd_open): Use ops->bfd_open override if present.  Call
	solib_find and solib_bfd_open otherwise.

	* objfiles.h (OBJF_KEEPBFD): New define.
	* objfiles.c (free_objfile): Do not close BFD if OBJF_KEEPBFD
	objfile flag is set.
	* solib.c (symbol_add_stub): Do not allocate second BFD for
	shared library; use OBJF_KEEPBFD flag on solib objfile.
@
text
@d425 3
a481 1
  objfile_free_data (objfile);
@


1.80
log
@        Updated copyright notices for most files.
@
text
@d425 1
a425 1
  /* We always close the bfd. */
d427 1
a427 1
  if (objfile->obfd != NULL)
@


1.79
log
@	* breakpoint.h (struct bp_location): Change type of section
	member to "struct obj_section *".
	* tracepoint.h (struct tracepoint): Likewise.
	* symtab.h (struct general_symbol_info): Replace bfd_section
	member with obj_section.
	(struct symtab_and_line): Change type of section member to
	"struct obj_section *".
	(SYMBOL_BFD_SECTION): Remove macro, replace by ...
	(SYMBOL_OBJ_SECTION): ... this.

	* minsym.c (prim_record_minimal_symbol_and_info): Record symbol
	section as obj_section instead of bfd_section.

	* ada-lang.c (ada_decode_symbol): Use gsymbol->obj_section
	directly instead of looking of obj_section from bfd_section.

	* objfiles.h (find_pc_sect_section): Remove.
	* objfiles.c (find_pc_sect_section): Remove.
	(find_pc_section): Inline find_pc_sect_section code.

	* symfile.h (find_pc_overlay): Return struct obj_section *.
	(find_pc_mapped_section): Likewise.
	(section_is_overlay, section_is_mapped): Change type of section
	argument to struct obj_section *.
	(pc_in_mapped_range, pc_in_unmapped_range): Likewise.
	(overlay_mapped_address, overlay_unmapped_address): Likewise.
	(symbol_overlayed_address): Likewise.
	* symtab.h (symbol_overlayed_address): Likewise.
	* symfile.c (overlay_is_mapped): Remove.
	(section_is_mapped): Inline overlay_is_mapped code.  Update.
	(overlay_invalidate_all): Update.
	(section_is_overlay): Change section argument to type
	"struct obj_section *".  Use bfd_ methods.
	(pc_in_unmapped_range): Likewise.  Handle relocated sections.
	(pc_in_mapped_range): Likewise.  Handle relocated sections.
	(sections_overlap): Likewise.
	(overlay_unmapped_address): Likewise.
	(overlay_mapped_address): Likewise.
	(symbol_overlayed_address): Likewise.
	(find_pc_overlay): Return struct obj_section *.
	(find_pc_mapped_section): Likewise.
	(list_overlays_command): Update.
	(map_overlay_command, unmap_overlay_command): Update.
	(simple_overlay_update): Update.

	* block.h (blockvector_for_pc_sect): Change section argument
	to type "struct obj_section *".
	(block_for_pc_sect): Likewise.
	* block.c (blockvector_for_pc_sect): Change section argument
	to type "struct obj_section *".
	(block_for_pc_sect): Likewise.
	* symtab.h (find_pc_sect_function, find_pc_sect_psymtab,
	find_pc_sect_symtab, find_pc_sect_psymbol, find_pc_sect_line,
	lookup_minimal_symbol_by_pc_section, find_function_start_pc): Likewise.
	(matching_bfd_sections): Rename to ...
	(matching_obj_sections): ... this.  Update argument types.
	* blockframe.c (find_pc_sect_function): Likewise.
	* breakpoint.c (describe_other_breakpoints): Likewise.
	(breakpoint_has_pc, check_duplicates_for): Likewise.
	* minsyms.c (lookup_minimal_symbol_by_pc_section_1): Likewise.
	(lookup_minimal_symbol_by_pc_section): Likewise.
	* symtab.c (find_pc_sect_psymtab_closer): Likewise.
	(find_pc_sect_psymtab, find_pc_sect_psymbol, find_pc_sect_symtab,
	find_pc_sect_line, find_function_start_pc): Likewise.
	(matching_bfd_sections): Rename to ...
	(matching_obj_sections): ... this.  Update argument types.

	* blockframe.c (find_pc_partial_function): Update to section
	type changes.  No longer call find_pc_sect_section.
	(cache_pc_function_section): Change to type "struct obj_section *".
	* breakpoint.c (resolve_sal_pc): Update to section type changes.
	* exec.c (xfer_memory): Likewise.
	* findvar.c (read_var_value): Likewise.
	* infcmd.c (jump_command): Likewise.
	* linespec.c (minsym_found): Likewise.
	* maint.c (maintenance_translate_address): Likewise.
	* minsyms.c (lookup_minimal_symbol_by_pc_section_1): Likewise.
	(lookup_solib_trampoline_symbol_by_pc): Likewise.
	* parse.c (write_exp_msymbol): Likewise.
	* printcmd.c (build_address_symbolic): Likewise.
	(address_info, sym_info): Likewise.
	* symmisc.c (dump_msymbols, print_symbol): Likewise.
	* symtab.c (fixup_section): Likewise.
	(fixup_symbol_section, fixup_psymbol_section): Likewise.
	(find_pc_line, find_function_start_sal): Likewise.
	* target.c (memory_xfer_partial): Likewise.
	* hppa-hpux-tdep.c (hppa64_hpux_in_solib_call_trampoline): Likewise.
	* spu-tdep.c (spu_overlay_update): Likewise.
@
text
@d4 1
a4 1
   2002, 2003, 2004, 2007, 2008 Free Software Foundation, Inc.
@


1.79.4.1
log
@2008-11-20  Stan Shebs  <stan@@codesourcery.com>

	Multi-process (primarily multi-exec) support.

	2008-10-14  Stan Shebs  <stan@@codesourcery.com>

	* blockframe.c (get_frame_block): Get inferior from frame.
	* block.c (block_for_pc_inf): New function.
	* block.h (block_for_pc_inf): Declare.
	* symfile.c (find_pc_inf_sect): New function.
	* symfile.h (find_pc_inf_sect): Declare.
	* symtab.c (find_pc_inf_line): New function.
	* symtab.h (find_pc_inf_line): Declare.
	* frame.c (struct frame_info) New field inferior.
	(fprint_frame_id): Display inferior.
	(get_frame_id): Set inferior_num from inferior.
	(frame_id_eq): Compare inferiors.
	(create_sentinel_frame): Set inferior.
	(create_new_frame): Copy inferior from sentinel.
	(get_prev_frame_raw): Copy inferior from next frame.
	(find_frame_sal): Use find_pc_inf_line.
	(get_frame_inferior): New function.
	* frame.h (struct frame_id): New field inferior_num.

	* breakpoint.c (expand_sals_by_inferiors): Copy section from input
	sal to expanded sals.
	* symtab.c (expand_line_sal): Ditto.

	2008-10-10  Stan Shebs  <stan@@codesourcery.com>

	* remote.c (discard_pending_stop_replies): Initialize prev.
	* infrun.c (infrun_thread_stop_requested): Ditto.

	2008-10-08  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (struct inferior): Rename environ field to inf_environ.
	* inferior.c (print_inferior): Ditto.

	2008-10-01  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (detach_fork): Declare here...
	* linux-fork.h (detach_fork): ...instead of here.
	* linux-fork.c (detach_fork): Move to...
	* infrun.c (detach_fork): ...here.
	* remote.c (detach_fork): Remove decl.

	2008-09-30  Stan Shebs  <stan@@codesourcery.com>

	* linespec.c (decode_line_1): Better default for one-exec case.
	* remote (remote_start_remote): Use the exec in the one-exec case.

	2008-09-29  Stan Shebs  <stan@@codesourcery.com>

	* infcmd.c (attach_command): If only one exec, assume it is the
	attached inferior's exec.
	(attach_command_post_wait): Set inferior's exec from
	the one that was found.
	* inf-ptrace.c (inf_ptrace_attach): Only report exec file if
	if there is just one present.
	(inf_ptrace_detach): Use inferior to get correct exec name.

	2008-09-29  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (print_inferior): Use exec short names, and drop
	unused address space display.

	2008-09-26  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (should_be_inserted): Test for no inferior.
	(clone_breakpoint_location): New function, broken out from...
	(update_breakpoint_inferiors): ...here, also tweak conditions
	for adding a location.
	(insert_breakpoint_location): Don't count non-running inferiors.
	(remove_breakpoint): Set tmp_inf.
	(print_one_breakpoint_location): Add allflag arg, use to always
	show inf.
	(print_one_breakpoint): Add allflag arg.
	(do_captured_breakpoint_query): Fix caller.
	(breakpoint_1): Ditto.
	* exec.c (create_exec): Save full pathname as exec name.
	(find_exec_by_name): Use find_exec_by_substr.
	* fork-child.c (fork_inferior): Warn if exec not found for new
	inferior.

	2008-09-25  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (should_be_inserted): Don't insert in inferiors
	that are not running.
	(update_breakpoint_inferiors): New function.
	(insert_breakpoints): Call it.
	(insert_breakpoint_locations): Don't insert in inferiors that are
	not running.
	(set_raw_breakpoint_without_location): Set trigger set from
	current itset here...
	(set_raw_breakpoint): Instead of here. Also add default fillins
	for the location's inferior.
	(add_location_to_breakpoint): Similarly.
	(expand_sals_by_inferiors): New function.
	(breakpoint_re_set_one): Call it.
	(resolve_sal_pc): Don't set sal inferior.
	* breakpoint.h (struct breakpoint): Remove exec field, never used.
	* inferior.h (inferior_list): Declare.
	* inferior.c (inferior_list): Make public.
	(add_inferior_to_itset): Auto-add inferiors after exec's inferior.
	(first_inferior_in_set): Check for zero-length vector.
	* exec.c (xfer_memory): Use tmp_inf as inferior if set.
	* infcmd.c (focus_command): Improve user feedback.
	* linespec.c (build_canonical_line_spec): Record exec name as part
	of canonical spec.
	(symbol_found): Canonicalize specs more.
	(decode_indirect): Revert rewrite from 2008-09-14.
	(decode_sharp): Use find_exec_by_substr, better error messages.
	* minsyms.c (lookup_minimal_symbol_in_exec): New function.
	(lookup_minimal_symbol_in_exec_1): New function, body of
	lookup_minimal_symbol.
	* symtab.h (lookup_minimal_symbol_in_exec): Declare.
	* symtab.c (find_function_start_sal): Set inferior to use.
	(append_expanded_sal): Return pointer to the new sal.
	* remote.c (remote_xfer_memory): Better parms to ptid_build, remove
	debug print.
	(remote_xfer_partial): Ditto.

	2008-09-22  Pedro Alves  <pedro@@codesourcery.com>

	* inferior.c (itset_member): Fix typo.

	2008-09-22  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (current_inf): Remove declaration.
	(tmp_inf): Declare.
	* inferior.c (current_inf): Remove.
	(tmp_inf): New global, hack to bypass passing inferior throughout
	target stack.
	(print_inferior): Don't report current_inf.
	(add_inferior_command): Don't use current_inf.
	(name_inferior_command): Use first inferior of current_itset.
	(update_itset): Handle NULL case.
	(add_inferior_itset): Recursively add all inferiors derived from
	an exec if the exec's own inferior is present.
	(first_inferior_in_set): New function.
	(free_inferior): Comment out until references cleared reliably.
	* infcmd.c (focus_command): Don't set current_inf.
	(get_inferior_args): Use first_inferior_in_set instead of
	current_inf.
	(set_inferior_args): Ditto.
	(set_inferior_args_vector): Ditto.
	(notice_args_set): Ditto.
	* breakpoint.c (insert_breakpoint_locations): Remove insertion test
	using current_inf, set tmp_inf.
	(reattach_breakpoints): Set tmp_inf.
	(bpstat_check_breakpoint_conditions): Test trigger set here...
	(bpstat_stop_status): ... instead of here.
	(bpstat_check_trigger_set): Add special case for exec's own
	inferior.
	(print_one_breakpoint_location): Also test for multiple inferiors
	before displaying location's inferior, flag trigger set with "i/t"
	instead of "focus".
	(check_duplicates): Pass location's inferior to...
	(check_duplicates_for): Add inferior arg and use.
	(set_raw_breakpoint): Override sal inferior with one from the
	trigger set.
	(add_location_to_breakpoint): Ditto.
	* remote.c (remote_xfer_memory): Switch inferiors if tmp_inf is
	set to something different from inferior_ptid.
	(remote_xfer_partial): Ditto.
	* top.c (execute_command): Always update the current itset.

	2008-09-19  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (set_inferior_exec): New function.
	(set_inferior_exec_command): New command.
	* inferior.h: Declare set_inferior_exec.
	* fork-child.c (fork_inferior): Set the inferior's exec.
	* remote.c (extended_remote_create_inferior_1): Ditto.
	gdb/doc/
	* gdb.texinfo (Debugging Multiple Programs): Describe set-exec.

	2008-09-18  Stan Shebs  <stan@@codesourcery.com>

	* target.c (target_resize_to_sections): Adjust execs' section
	tables too.

	2008-09-17  Stan Shebs  <stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Invoking GDB): Describe multiple program args.
	(File Options): Describe multi-program effects.
	(Multiple Programs): New section, multi-program debugging.
	(Forks): Rename section from "Processes".
	(Specify Location): Describe the #-syntax.
	(Variables): Describe the #-syntax.
	(Files): Describe add-file and add-exec-file.
	(Maintenance Commands): Describe maint print execs.

	2008-09-15  Stan Shebs  <stan@@codesourcery.com>

	* exec.c (addr_space_info_command): Don't try to display host address.

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* c-exp.y: (yylex): Accept '#' in identifiers.
	* linespec.c (decode_sharp): New function.
	(decode_line_1): Use it for #-syntax.
	(decode_indirect): Rewrite to accept exec arg and iterate over
	inferiors.
	(struct d_i_data): New struct for inferior iteration.
	(decode_indirect_callback): New function.
	(decode_variable): Pass in exec, use in symbol lookup.

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.h (struct bp_location): Add inferior field instead
	of address space field.
	* breakpoint.c (insert_breakpoint_locations): Only insert in
	appropriate inferior.
	(bpstat_check_trigger_set): New function.
	(bpstat_stop_status): Call it, check location's inferior also.
	(print_one_breakpoint_location): Report location's inferior.
	(set_raw_breakpoint): Set location inferior, clear an experiment.
	(add_location_to_breakpoint): Ditto.
	(expand_line_sal_maybe): Check for non-NULL original function.
	(resolve_sal_pc): Set sal inferior.
	(clear_command): Be careful to not clear anything twice.
	* symtab.h: Update declarations of symbol lookups.
	(struct symtab_and_line): Change address space to inferior field.
	* symtab.c (init_sal): Clear inferior field.
	(append_expanded_sal): Set inferior.
	(lookup_symbol_in_language_1): New function.
	(lookup_symbol_in_language): Call it.
	(lookup_symbol_in_exec_in_language): New function.
	(lookup_symbol): Detect #-syntax and find exec to use.
	(lookup_symbol_aux): Add exec argument and use it.
	(lookup_symbol_aux_symtabs): Ditto.
	(lookup_symbol_aux_psymtabs): Ditto.
	(basic_lookup_symbol_nonlocal): Ditto.
	(lookup_symbol_static): Ditto.
	(lookup_symbol_global): Ditto.
	* ada-lang.c (cp_lookup_symbol_nonlocal): Ditto.
	* cp-support.h (cp_lookup_symbol_nonlocal): Ditto.
	* cp-namespace.c (cp_lookup_symbol_nonlocal): Ditto.
	* language.h (struct language_defn): Ditto.
	* scm-valprint.c (scm_inferior_print): Add exec arg to
	lookup_symbol_global.
	* source.c (select_source_symtab): Use current_exec.
	* addrspace.h (struct addr_space): New field num.
	* exec.h (struct exec): New fields sections and sections_end.
	* exec.c (exec_file_attach_1): Set them from exec_ops, set
	inferior's address space name from exec.
	(find_exec_by_substr): New function.
	(build_section_table): Don't free old table.
	(print_section_info): Use exec's section table.
	(next_address_space_num): New global, numbering for address spaces.
	(new_address_space): Use it.
	(addr_space_info_command): Display it.
	* infcmd.c (set_current_exec): Set exec_ops section table.
	* inferior.h (update_itset): Declare.
	* inferior.c (add_inferior_silent): Set address space.
	(print_inferior): Display it.
	(number_of_inferiors): New function.
	(itset_member): New function.

	2008-09-04  Stan Shebs  <stan@@codesourcery.com>

	* corefile.c (close_exec_file): Remove #if 0 block.
	(validate_files): Use first_exec instead of exec_bfd.
	(get_exec_file): Ditto.
	* corelow.c (core_open): Ditto.
	* utils.c (string_to_core_addr): Ditto.
	* arch-utils.c (gdbarch_update_p): Ditto.
	* linux-thread-db.c (enable_thread_event): Ditto.
	(thread_db_get_thread_local_address ): Ditto.
	* exec.c (find_exec_by_name): Test short name also.
	(file_command): Set current exec.

	2008-09-03  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (add_threads_to_itset): Default to including all
	of an inferior's threads.

	2008-08-31  Stan Shebs  <stan@@codesourcery.com>

	Parsing for i/t sets.
	* inferior.h (struct itset_entry): New struct.
	(struct itset): Make thread lists be per-inferior, add parse state
	variables.
	* inferior.c: (add_inferior_command): Add error checking and
	confirmation.
	(remove_inferior_command): Update for itset restructuring.
	(new_itset): Don't pass in dynamic-ness, call parse_itset_spec.
	(update_itset): Similarly.
	(parse_itset_spec): New, parsing of itset spec.
	(parse_itset_list, parse_itset_range, etc): New.
	(make_itset_from_spec): Rewrite.
	(dump_itset): Rewrite to reflect itset structure.
	* infcmd.c (focus_command): Similarly.

	2008-08-25  Stan Shebs  <stan@@codesourcery.com>

	First part of multiprocess support.
	* Makefile.in (COMMON_OBS): Add inferior.o.
	* addrspace.h: New file.
	* breakpoints.h (struct bp_location): Add address space field.
	(struct breakpoint): Add trigger set and exec fields.
	* breakpoints.c (print_one_breakpoint_location): Display trigger
	set.
	(set_raw_breakpoint): Set trigger set from current itset.
	* corefile.c (reopen_exec_file): Rewrite for multiple execs.
	(get_exec_file): Add case for current_exec.
	* corelow.c (is_core_file): New function.
	(core_files_info): Pass additional arg to print_section_info.
	* exec.h (struct exec): New struct.
	* exec.c (execs): New global.
	(exec_bfd_mtime): Remove.
	(last_exec_created, current_exec, first_exec): New globals.
	(exec_close): Clear all exec objects.
	(exec_file_clear): Tweak user message.
	(exec_file_add): New function.
	(exec_file_attach_1): New function, body of exec_file_attach,
	plus new code to handle multiple execs.
	(exec_file_attach): Call it.
	(exec_file_update): New function.
	(create_exec, find_exec_by_name, number_of_execs): New functions.
	(exec_file_command): Rephrase query, set current exec.
	(add_exec_file_command): New command.
	(add_file_command): New command.
	(print_section_info): Add exec argument.
	(exec_files_info): Rewrite for multiple execs.
	(maintenance_print_execs): New function.
	(new_address_space): New function.
	(addr_space_info_command): New command.
	* gdbcore.h (exec_bfd_mtime): Remove decl.
	(exec_file_add): Declare.
	* infcmd.c: Include exec.h.
	(current_itset): New global.
	(set_current_exec): New function.
	(focus_command): New command.
	(get_inferior_args): Maybe get from the current inferior.
	(set_inferior_args): Also set in current inferior.
	(set_inferior_args_vector): Similarly.
	(notice_args_set): Similarly.
	(attach_command): Rephrase query.
	* inferior.h (struct inferior): New struct.
	(struct itset): New struct.
	* inferior.c: New file, management of multiple inferiors.
	* main.c (captured_main): Rewrite to allow multiple executables,
	pids, and corefiles on the command line.
	* maint.c (maintenance_info_sections): Rewrite for multiple execs.
	* objfiles.h (struct objfile): New field for exec.
	(ALL_OBJFILES_FOR_EXEC, ALL_PRIMARY_SYMTABS_FOR_EXEC,
	ALL_PSYMTABS_FOR_EXEC): New macros.
	* objfiles.c (allocate_objfile): Clear exec field.
	* solib.c (clear_solib): Use first_exec instead of exec_bfd.
	* source.c (select_source_symtab): Use ALL_OBJFILES_FOR_EXEC.
	(find_source_lines): Use mtime from exec.
	* symfile.c (syms_from_objfile): Don't clear objfile if multiple
	execs.
	(new_symfile_objfile): Get objfile's exec from last_exec_created.
	(symbol_file_clear): Rephrase messages.
	(reread_symbols): Update objfile's exec if necessary.
	* symmisc.c (dump_objfile): Dump objfile's exec also.
	(maintenance_print_objfiles): Report symfile_objfile.
	* symtab.h (struct symtab_and_line): Add address space field.
	* symtab.c (find_pc_sect_psymtab): Look for a plausible exec, and
	then use it.
	(lookup_symbol_aux_symtabs): Use current exec.
	(lookup_symbol_aux_symtabs): Ditto.
	(basic_lookup_transparent_type): Ditto.
	(find_pc_sect_symtab): Ditto.
	* target.h (print_section_info): Add arg to decl.
	* tui/tui-win.c: Rename "focus" command to "ffocus".

gdb/testsuite:

2008-11-20  Stan Shebs  <stan@@codesourcery.com>

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* gdb.gdb/selftest.exp: Update to reflect current sources.
	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* configure.ac (AC_OUTPUT): Add gdb.multi/Makefile.
	* configure: Regenerate.

	* gdb.multi/Makefile.in: New.
	* gdb.multi/hello.c, hangout.c, goodbye.c: New source files.
	* gdb.multi/base.exp: New file, basic multiprocess tests.

	2008-08-25  Stan Shebs  <stan@@codesourcery.com>

	* config/monitor.exp: Match on rephrased message.
	* gdb.base/attach.exp: Ditto.
	* gdb.base/default.exp: Ditto.
	* lib/gdb.exp: Ditto.
@
text
@a203 2
  objfile->exec = NULL;

@


1.78
log
@	* objfiles.h (struct obj_section): Remove addr and endaddr fields.
	(obj_section_offset, obj_section_addr, obj_section_endaddr): New
	macros.
	* objfiles.c (add_to_objfile_sections): Don't set addr, endaddr
	and offset.  Use size_t instead of unsigned long.
	(build_objfile_section_table): Use size_t instead of unsigned
	long.
	(objfile_relocate): Don't relocate s->addr and s->endaddr, they're
	gone.
	(find_pc_sect_section): Use obj_section_addr and
	obj_section_endaddr.
	* symfile.c (symfile.c): Remove code that maps sections
	offsets in "addr" to the object's sections.
	* blockframe.c (find_pc_partial_function): Use obj_section_endaddr.
	* gcore.c (gcore_create_callback): Use obj_section_addr and
	obj_section_endaddr.
	* maint.c (print_objfile_section_info): Likewise.
	* printcmd.c (sym_info): Use obj_section_addr and
	obj_section_endaddr.
	* symtab.c (fixup_section): Likewise.
@
text
@d757 1
a757 5
/* Returns a section whose range includes PC and SECTION, or NULL if
   none found.  Note the distinction between the return type, struct
   obj_section (which is defined in gdb), and the input type "struct
   bfd_section" (which is a bfd-defined data type).  The obj_section
   contains a pointer to the "struct bfd_section".  */
d760 1
a760 1
find_pc_sect_section (CORE_ADDR pc, struct bfd_section *section)
d765 5
d771 2
a772 6
    if ((section == 0 || section == s->the_bfd_section)
	&& obj_section_addr (s) <= pc && pc < obj_section_endaddr (s))
      return (s);

  return (NULL);
}
d774 1
a774 7
/* Returns a section whose range includes PC or NULL if none found. 
   Backward compatibility, no section.  */

struct obj_section *
find_pc_section (CORE_ADDR pc)
{
  return find_pc_sect_section (pc, find_pc_mapped_section (pc));
@


1.77
log
@	* symfile.c (reread_symbols): Update.
	* solib-sunos.c (allocate_rt_common_objfile): Update.
	* objfiles.c (allocate_objfile): Update.
	* objfiles.h (struct objfile) <md, mmfd, deprecated_obj_private>:
	Remove.
@
text
@a90 1
  section.offset = 0;
a93 2
  section.addr = bfd_section_vma (abfd, asect);
  section.endaddr = section.addr + bfd_section_size (abfd, asect);
d95 2
a96 1
  objfile->sections_end = (struct obj_section *) (((unsigned long) objfile->sections_end) + 1);
d125 4
a128 4
  bfd_map_over_sections (objfile->obfd, add_to_objfile_sections, (char *) objfile);
  objfile->sections = (struct obj_section *)
    obstack_finish (&objfile->objfile_obstack);
  objfile->sections_end = objfile->sections + (unsigned long) objfile->sections_end;
a664 15
  {
    struct obj_section *s;
    bfd *abfd;

    abfd = objfile->obfd;

    ALL_OBJFILE_OSECTIONS (objfile, s)
      {
      	int idx = s->the_bfd_section->index;
	
	s->addr += ANOFFSET (delta, idx);
	s->endaddr += ANOFFSET (delta, idx);
      }
  }

d671 1
a671 1
				s->addr);
d770 2
a771 2
    if ((section == 0 || section == s->the_bfd_section) &&
	s->addr <= pc && pc < s->endaddr)
@


1.76
log
@	* objfiles.c (TARGET_KEEP_SECTION): Remove.
	(add_to_objfile_sections): Remove use.
@
text
@a165 1
      objfile->md = NULL;
@


1.75
log
@	* symtab.h (enum address_class): Remove LOC_INDIRECT and
	LOC_HP_THREAD_LOCAL_STATIC.

	* findvar.c (symbol_read_needs_frame, read_var_value): Do not
	handle LOC_INDIRECT or LOC_HP_THREAD_LOCAL_STATIC.
	(read_var_value): Likewise.
	* buildsym.c (finish_block): Likewise.
	* objfiles.c (objfile_relocate): Likewise.
	* printcmd.c (address_info): Likewise.
	* symmisc.c (print_symbol, print_partial_symbols): Likewise.
	* tracepoint.c (scope_info): Likewise.
@
text
@a70 4
#ifndef TARGET_KEEP_SECTION
#define TARGET_KEEP_SECTION(ASECT)	0
#endif

d86 1
a86 1
  if (!(aflag & SEC_ALLOC) && !(TARGET_KEEP_SECTION (asect)))
@


1.74
log
@	* Makefile.in (objfiles.o): Update.
	* exec.c (exec_set_section_address): Support p->addr != 0.
	* objfiles.c (objfile_relocate): Update exec_ops section
	addresses.
	* symfile.c (place_section): Move exec_set_section_address call...
	(default_symfile_offsets): ...to here.
@
text
@d600 1
a600 2
		   || SYMBOL_CLASS (sym) == LOC_STATIC
		   || SYMBOL_CLASS (sym) == LOC_INDIRECT)
@


1.73
log
@	* Makefile.in (arm-tdep.o): Update.
	* arm-tdep.c (arm_objfile_data_key, struct arm_mapping_symbol)
	(struct arm_per_objfile, arm_compare_mapping_symbols): New.
	(arm_pc_is_thumb): Use mapping symbols.
	(arm_objfile_data_cleanup, arm_record_special_symbol): New.
	(arm_gdbarch_init): Call set_gdbarch_record_special_symbol.
	(_initialize_arm_tdep): Initialize arm_objfile_data_key.
	* elfread.c (elf_symtab_read): Use gdbarch_record_special_symbol.
	* gdbarch.sh: Add record_special_symbol.
	* gdbarch.c, gdbarch.h: Regenerated.
	* objfiles.c (struct objfile_data): Add cleanup member.
	(register_objfile_data_with_cleanup): New function, from
	register_objfile_data.
	(register_objfile_data): Use it.
	(objfile_free_data): Call clear_objfile_data.
	(clear_objfile_data): Call cleanup functions.
	* objfiles.h (register_objfile_data_with_cleanup): Declare.
@
text
@d52 1
d536 1
d688 9
@


1.72
log
@	* objfiles.c (init_entry_point_info): Handle shared libraries.
@
text
@d824 1
d842 1
a842 1
register_objfile_data (void)
d854 1
d859 6
d877 1
d885 3
d889 7
@


1.71
log
@	* objfiles.h (struct objfile): New GDBARCH member.
	(get_objfile_arch): Add prototype.
	* objfiles.c: Include "arch-utils.h".
	(allocate_objfile): Look up gdbarch associated with bfd.
	(get_objfile_arch): New function.
	* Makefile (objfiles.o): Update dependencies.

	* dwarf2-frame.c (decode_frame_entry_1): Replace current_gdbarch
	by objfile arch.
	* dwarf2loc.c (dwarf_expr_read_reg): Replace current_gdbarch
	by frame arch.
	(locexpr_describe_location): Replace current_gdbarch by
	objfile arch.
	* dwarf2read.c (die_type): Replace current_gdbarch by objfile arch.
	(dwarf2_add_field): Likewise.
	(read_tag_pointer_type): Likewise.
	(read_base_type): Likewise.
	(new_symbol): Likewise.

	* coffread.c (decode_type): Add OBJFILE argument.  Update callers.
	(decode_base_type, decode_function_type): Likewise.
	(coff_read_struct_type, coff_read_enum_type): Likewise.
	(coff_symtab_read): Replace current_gdbarch by objfile arch.
	(decode_base_type): Likewise.
	(coff_read_enum_type): Likewise.
	(coff_read_struct_type): Replace current_objfile by OBJFILE argument.
	(coff_read_enum_type): Likewise.

	* dbxread.c (read_dbx_symtab): Replace current_gdbarch by objfile arch.
	(end_psymtab): Likewise.
	(process_one_symbol): Likewise.

	* mdebugread.c (parse_symbol): Replace current_gdbarch by objfile arch.
	(parse_procedure): Likewise.
	(parse_partial_symbols): Likewise.

	* somread.c (som_symtab_read): Replace current_gdbarch by objfile arch.

	* stabsread.c (define_symbol): Replace current_gdbarch by objfile arch.
	Replace static pcc_promotion_type and pcc_unsigned_promotion_type by
	built-in types.
	(read_range_type): Replace current_gdbarch by objfile arch.  Replace
	static range_index_type by built-in type.
	(read_one_struct_field): Replace current_gdbarch by objfile arch.
	(read_enum_type): Likewise.

	* xcoffread.c (read_xcoff_symtab): Replace current_gdbarch by
	objfile arch.
@
text
@d262 6
@


1.70
log
@	Updated copyright notices for most files.
@
text
@d51 1
d191 3
d241 7
@


1.69
log
@Support lexical blocks and function bodies that occupy
non-contiguous address ranges.
* addrmap.c, addrmap.h: New files.
* block.h (struct addrmap): New forward declaration.
(struct blockvector): New member, 'map'.
(BLOCKVECTOR_MAP): New accessor macro.
* block.c: #include "addrmap.h"
(blockvector_for_pc_sect): If the blockvector we've found has
an address map, use it instead of searching the blocks.
* buildsym.c: #include "addrmap.h"
(pending_addrmap_obstack, pending_addrmap_interesting): New static
variables.
(really_free_pendings): If we have a pending addrmap, free it too.
(record_block_range): New function.
(make_blockvector): If we have an interesting pending addrmap,
record it in the new blockvector.
(start_symtab, buildsym_init): Assert that there is no pending
addrmap now; we should have cleaned up any addrmaps we'd built
previously.
(end_symtab): If there is a pending addrmap left over that didn't
get included in the blockvector, free it.
* buildsym.h (struct addrmap): New forward declaration.
(record_block_range): New prototype.
* objfiles.c: #include "addrmap.h".
(objfile_relocate): Relocate the blockvector's address map, if
present.
* dwarf2read.c (dwarf2_record_block_ranges): New function.
(read_func_scope, read_lexical_block_scope): Call it.
* Makefile.in (SFILES): Add addrmap.c.
(addrmap_h): New header dependency variable.
(COMMON_OBS): Add addrmap.o.
(addrmap.o): New rule.l
(block.o, objfiles.o, buildsym.o): Depend on $(addrmap_h).

* block.c (blockvector_for_pc, blockvector_for_pc_sect): Return a
pointer to the block, not its index in the blockvector.
(block_for_pc_sect): Use the returned block, instead of looking it
up ourselves.
* block.h (blockvector_for_pc, blockvector_for_pc_sect): Update
declarations.
* breakpoint.c (resolve_sal_pc): Use returned block, instead of
looking it up ourselves.
* stack.c (print_frame_label_vars): Disable function, which
depends on the block's index.

* buildsym.c (finish_block): Return the block we've built.
* buildsym.h (finish_block): Update prototype.

* defs.h (CORE_ADDR_MAX): New constant.
@
text
@d4 1
a4 1
   2002, 2003, 2004, 2007 Free Software Foundation, Inc.
@


1.68
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d50 1
d568 3
@


1.67
log
@	* objfiles.h (ImportEntry, ExportEntry): Remove types.
	(struct objfile): Remove import_list, import_list_size,
	export_list, export_list_size members.
	(is_in_import_list): Remove prototype.
	* objfiles.c (is_in_import_list): Remove.
	* somread.c (init_import_symbols, init_export_symbols): Remove.
	(som_symfile_read): Do not call init_import_symbols.  Do not
	set objfile->export_list and objfile->export_list_size.
@
text
@d12 1
a12 1
   the Free Software Foundation; either version 2 of the License, or
d21 1
a21 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.66
log
@Copyright updates for 2007.
@
text
@a796 17

/* Return nonzero if NAME is in the import list of OBJFILE.  Else
   return zero.  */

int
is_in_import_list (char *name, struct objfile *objfile)
{
  int i;

  if (!objfile || !name || !*name)
    return 0;

  for (i = 0; i < objfile->import_list_size; i++)
    if (objfile->import_list[i] && DEPRECATED_STREQ (name, objfile->import_list[i]))
      return 1;
  return 0;
}
@


1.65
log
@	* Makefile.in (objfiles.o, symfile.o): Update.
	* objfiles.c: Include "expression.h" and "parser-defs.h".
	(free_objfile): Clear global blocks.
	* symfile.c: Include "parser-defs.h".
	(clear_symtab_users): Clear global blocks.
@
text
@d3 2
a4 2
   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001, 2002, 2003, 2004 Free Software Foundation, Inc.
@


1.64
log
@gdb/
	* Makefile.in (gdbtypes_h, gdbtypes.o, utils.o): Update.
	* defs.h (hashtab_obstack_allocate, dummy_obstack_deallocate): Add
	prototypes.
	* dwarf2read.c (read_subroutine_type): Use TYPE_ZALLOC.
	(hashtab_obstack_allocate, dummy_obstack_deallocate): Moved to...
	* utils.c (hashtab_obstack_allocate, dummy_obstack_deallocate):
	...here.
	* gdbtypes.c: Include "hashtab.h".
	(build_gdbtypes): Remove extra prototype.
	(struct type_pair, type_pair_hash, type_pair_eq)
	(create_copied_types_hash, copy_type_recursive): New.
	* gdbtypes.h: Include "hashtab.h".
	(TYPE_ZALLOC): New.
	(create_copied_types_hash, copy_type_recursive): New prototypes.
	* objfiles.c (free_objfile): Call preserve_values.
	* symfile.c (reread_symbols): Likewise.
	(clear_symtab_users): Remove calls to clear_value_history and
	clear_internalvars.
	* value.c (clear_value_history, clear_internalvars): Removed.
	(preserve_one_value, preserve_values): New functions.
	* value.h (clear_value_history, clear_internalvars): Removed.
	(preserve_values): New prototype.

	* tracepoint.c (_initialize_tracepoint): Do not initialize convenience
	variables here.
gdb/doc/
	* gdb.texinfo (Files): Remove obsolete bits from the description
	of "symbol-file".
@
text
@d37 3
d447 6
@


1.64.14.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@a36 3
#include "expression.h"
#include "parser-defs.h"

a443 6
  /* Clear globals which might have pointed into a removed objfile.
     FIXME: It's not clear which of these are supposed to persist
     between expressions and which ought to be reset each time.  */
  expression_context_block = NULL;
  innermost_block = NULL;

@


1.64.8.1
log
@	* gdb/exec.c (exec_set_section_address): Always update the
	section's address.
	* gdb/objfiles.c (objfile_relocate): Also relocate the
	target sections table.
	* gdb/Makefile.in (objfiles.o): Update.

	* gdb/remote.c (remote_xfer_partial): Fail if the target is not
	running.
@
text
@a29 1
#include "exec.h"
a654 5

	/* FIXME: The exec file uses a completely different table from
	   any objfile, unfortunately.  A nice improvement would
	   be to unify those.  */
	exec_set_section_address (bfd_get_filename (abfd), idx, s->addr);
@


1.64.8.2
log
@	* objfiles.c (init_entry_point_info): Handle shared objects
	with entry points.
@
text
@a249 6
  else if (bfd_get_file_flags (objfile->obfd) & DYNAMIC
	   && bfd_get_start_address (objfile->obfd) != 0)
    /* Some shared libraries may have entry points set and be
       runnable.  There's no clear way to indicate this, so just check
       for values other than zero.  */
    objfile->ei.entry_point = bfd_get_start_address (objfile->obfd);    
@


1.63
log
@Reviewed and approved by Jim Blandy

	2006-01-06  Fred Fish  <fnf@@specifix.com>
	* objfiles.c (source.h): Include.
	(free_objfile): Update comment about clear_symtab_users().
	(free_objfile): Check all symtabs of objfile being freed and if
	one of them is the current source symtab, call
 	clear_current_source_symtab_and_line().
@
text
@d396 4
@


1.62
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d48 1
d436 2
a437 2
  /* I *think* all our callers call clear_symtab_users.  If so, no need
     to call this here.  */
d440 14
@


1.61
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d3 1
a3 1
   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
d22 2
a23 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.60
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d308 1
a308 1
		  "put_objfile_before: before objfile not in list");
d360 1
a360 1
		  "unlink_objfile: objfile already unlinked");
@


1.59
log
@2004-10-31  Andrew Cagney  <cagney@@gnu.org>

	* mdebugread.h (ecoff_relocate_efi): Delete declaration.
	* mdebugread.c (ecoff_relocate_efi): Delete function.
	* objfiles.c (objfile_relocate): Delete #ifdef
	MDEBUG_EFI_SYMBOL_NAME code.
@
text
@d194 1
a194 1
	  error ("Can't find the file sections in `%s': %s",
d413 1
a413 1
	warning ("cannot close \"%s\": %s",
@


1.58
log
@2004-10-30  Andrew Cagney  <cagney@@gnu.org>

	* objfiles.c: Include "mdebugread.h".
	* mdebugread.c: Include "mdebugread.h".
	(ecoff_relocate_cfi): Delete.
	* config/alpha/tm-alpha.h (ecoff_relcate_cfi): Delete.
	* config/mips/tm-mips.h (ecoff_relcate_cfi): Delete.
	* mdebugread.h (ecoff_relocate_efi): New file.
	* Makefile.in: Update dependencies.
@
text
@a557 10
#ifdef MDEBUG_EFI_SYMBOL_NAME
	      /* Relocate Extra Function Info for ecoff.  */

	      else if (SYMBOL_CLASS (sym) == LOC_CONST
		       && SYMBOL_DOMAIN (sym) == LABEL_DOMAIN
		       && strcmp (DEPRECATED_SYMBOL_NAME (sym),
				  MDEBUG_EFI_SYMBOL_NAME) == 0)
		ecoff_relocate_efi (sym, ANOFFSET (delta,
						   s->block_line_section));
#endif
@


1.57
log
@2004-10-30  Andrew Cagney  <cagney@@gnu.org>

	* config/alpha/tm-alpha.h (MDEBUG_EFI_SYMBOL_NAME): Rename
	MIPS_EFI_SYMBOL_NAME.
	(mips_extra_func_info_t, mips_extra_func_info): Delete.
	(struct mdebug_extra_func_info): Replace struct
	alpha_extra_func_info and alpha_extra_func_info_t.
	* config/mips/tm-mips.h (MDEBUG_EFI_SYMBOL_NAME): Rename
	MIPS_EFI_SYMBOL_NAME.
	(struct mdebug_extra_func_info): Replace struct
	alpha_extra_func_info and alpha_extra_func_info_t.
	* objfiles.c, mips-tdep.c, mips-mdebug-tdep.c: Update.
	* mdebugread.c, alpha-mdebug-tdep.c:
@
text
@d36 1
a36 1

@


1.56
log
@* defs.h (msavestring, mstrsave): Remove prototypes.
* utils.c (msavestring, mstrsave): Remove functions.
* objfiles.c (allocate_objfile): Use xstrdup instead of mstrsave.
* solib-sunos.c (allocate_rt_common_objfile): Use xstrdup instead
of mstrsave.
* source.c (find_and_open_source): Use xstrdup instead of
mstrsave.
@
text
@d558 1
a558 1
#ifdef MIPS_EFI_SYMBOL_NAME
d563 2
a564 1
		       && strcmp (DEPRECATED_SYMBOL_NAME (sym), MIPS_EFI_SYMBOL_NAME) == 0)
@


1.55
log
@2004-09-01  Andrew Cagney  <cagney@@gnu.org>

	* objfiles.h (struct entry_info): Delete fields main_func_lowpc
	and main_func_highpc.
	(INVALID_ENTRY_LOWPC, INVALID_ENTRY_HIGHPC): Delete macros.
	* objfiles.c (init_entry_point_info, objfile_relocate): Update
	* nlmread.c (nlm_symfile_read): Update.
@
text
@d187 1
a187 1
      objfile->name = mstrsave (objfile->md, bfd_get_filename (abfd));
d200 1
a200 1
      objfile->name = mstrsave (objfile->md, "<<anonymous objfile>>");
@


1.54
log
@2004-08-10  Andrew Cagney  <cagney@@gnu.org>

	* defs.h (xmfree): Delete.
	* utils.c (xmfree): Delete function.
	(xfree): Inline calls to xmfree and mfree.
	* symmisc.c (free_symtab_block, free_symtab): Use xfree.
	* symfile.c (reread_symbols, init_psymbol_list): Ditto.
	* source.c (forget_cached_source_info, find_and_open_source): Ditto.
	* somread.c (som_symfile_finish): Ditto.
	* objfiles.c (allocate_objfile, free_objfile):
	* nlmread.c (nlm_symfile_finish): Ditto.
	* hpread.c (hpread_symfile_finish): Ditto.
	* elfread.c (free_elfinfo, elf_symfile_finish): Ditto.
	* dbxread.c (dbx_symfile_finish, free_bincl_list): Ditto.
	* coffread.c (coff_symfile_finish): Ditto.
@
text
@a252 2
  objfile->ei.main_func_lowpc = INVALID_ENTRY_LOWPC;
  objfile->ei.main_func_highpc = INVALID_ENTRY_HIGHPC;
a647 6
  if (objfile->ei.main_func_lowpc != INVALID_ENTRY_LOWPC)
    {
      objfile->ei.main_func_lowpc += ANOFFSET (delta, SECT_OFF_TEXT (objfile));
      objfile->ei.main_func_highpc += ANOFFSET (delta, SECT_OFF_TEXT (objfile));
    }

@


1.53
log
@2004-06-24  Andrew Cagney  <cagney@@gnu.org>

	* objfiles.h (struct entry_info): Delete entry_func_lowpc and
	entry_func_highpc fields.
	* objfiles.c (init_entry_point_info): Do not clear
	entry_func_lowpc and entry_func_highpc.
	(objfile_relocate): Do not relocate entry_func_lowpc and
	entry_func_highpc.
	* dwarfread.c (read_func_scope): Do not set entry_func_lowpc and
	entry_func_highpc.
	* dwarf2read.c (read_func_scope): Do not set entry_func_lowpc and
	entry_func_highpc.
	* blockframe.c (legacy_frame_chain_valid): Replace tests against
	entry_func_lowpc and entry_func_highpc with call to
	inside_entry_func.
@
text
@d183 1
a183 1
      xmfree (objfile->md, objfile->name);
d446 1
a446 1
      xmfree (objfile->md, objfile->name);
d449 1
a449 1
    xmfree (objfile->md, objfile->global_psymbols.list);
d451 1
a451 1
    xmfree (objfile->md, objfile->static_psymbols.list);
d458 1
a458 1
  xmfree (objfile->md, objfile);
@


1.52
log
@2004-05-07  Andrew Cagney  <cagney@@redhat.com>

	* objfiles.h (struct entry_info): Delete unused fields
	deprecated_entry_file_lowpc and deprecated_entry_file_highpc.
	* objfiles.c (init_entry_point_info, objfile_relocate): Update.
	* mipsread.c (mipscoff_symfile_read): Update.
	* mdebugread.c (parse_partial_symbols): Update.
	* dwarfread.c (read_file_scope): Update.
	* dwarf2read.c (read_file_scope): Update.
	* dbxread.c (read_dbx_symtab, read_dbx_symtab): Update.
	* coffread.c (complete_symtab): Update.
@
text
@a252 2
  objfile->ei.entry_func_lowpc = INVALID_ENTRY_LOWPC;
  objfile->ei.entry_func_highpc = INVALID_ENTRY_HIGHPC;
a649 6
  if (objfile->ei.entry_func_lowpc != INVALID_ENTRY_LOWPC)
    {
      objfile->ei.entry_func_lowpc += ANOFFSET (delta, SECT_OFF_TEXT (objfile));
      objfile->ei.entry_func_highpc += ANOFFSET (delta, SECT_OFF_TEXT (objfile));
    }

@


1.51
log
@2004-02-17  Elena Zannoni  <ezannoni@@redhat.com>

	* objfiles.c (terminate_minimal_symbol_table): Add back
	initialization of MSYMBOL_TYPE.
@
text
@a252 2
  objfile->ei.deprecated_entry_file_lowpc = INVALID_ENTRY_LOWPC;
  objfile->ei.deprecated_entry_file_highpc = INVALID_ENTRY_HIGHPC;
a655 6
    }

  if (objfile->ei.deprecated_entry_file_lowpc != INVALID_ENTRY_LOWPC)
    {
      objfile->ei.deprecated_entry_file_lowpc += ANOFFSET (delta, SECT_OFF_TEXT (objfile));
      objfile->ei.deprecated_entry_file_highpc += ANOFFSET (delta, SECT_OFF_TEXT (objfile));
@


1.51.2.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d183 1
a183 1
      xfree (objfile->name);
d253 6
d450 1
a450 1
      xfree (objfile->name);
d453 1
a453 1
    xfree (objfile->global_psymbols.list);
d455 1
a455 1
    xfree (objfile->static_psymbols.list);
d462 1
a462 1
  xfree (objfile);
d654 18
@


1.51.8.1
log
@2004-03-23  Elena Zannoni  <ezannoni@@redhat.com>

       * solib-svr4.c (svr4_solib_create_inferior_hook): Disable
       breakpoints at startup.
       (elf_locate_base): Find out where the entry point for the program
       is, using the auxv vector, if possible. Compute the address of
       .dynamic using it.
       (svr4_current_sos): Don't ignore the first entry if we have PIE,
       it's our main program. Delete code that was skipping over the
       solib entry for main executable.
       * solist.h (struct so_list): Add fields main and main_relocated.
        (add_to_target_sections): Export.
       * solib.c (symbol_add_stub): Handle main executable in shared
       library list. Ignore it if it has been relocated already. Add it
       as the main symbol file, otherwise.
       * infrun.c (handle_inferior_event): Re-enable startup breakpoints.

       * solib-svr4.c (elf_locate_base, first_link_map_member)
       svr4_current_sos, enable_break): Add debugging output.
       * solist.h (debug_solib): Export.
       * solib.c (debug_solib): New variable to enable debugging output.
       (symbol_add_stub, update_solib_list, update_solib_list)
       (add_to_target_sections): Add debugging output.
       (_initialize_solib): Add new comand to enable printing of
       debugging output.
       (add_to_target_sections): New function. Factored out from
       update_solib_list.
       (update_solib_list): Call add_to_target_sections.

       * varobj.h (varobj_refresh): New prototype.
       * varobj.c (varobj_refresh): New function.
       * symfile.c (reread_symbols): Make sure that we recompute the
       entry point for the program.
       (symbol_file_clear): Clear the solibs as well, if we change symbol
       files.
       (clear_symtab_users): Refresh the varobjs that depend on the symtabs
       we are clearing.
       * objfiles.c (entry_point_address): Rewrite, to fetch entry point
       from auxv vector, if possible.
       Add include of elf/common.h.
       * breakpoint.h (enum bptype): Add bp type bp_startup_disabled.
       (re_enable_breakpoints_at_startup)
       (disable_breakpoints_at_startup): Add prototypes
       * breakpoint.c (re_enable_breakpoints_at_startup)
       (disable_breakpoints_at_startup): New functions.
       (describe_other_breakpoints, delete_breakpoint)
       (breakpoint_re_set_one): Handle new bp type.
       * auxv.h (target_auxv_parse, target_auxv_search): Update.
       * auxv.c (target_auxv_parse, target_auxv_search)
       (fprint_target_auxv): Use ULONGEST instead of CORE_ADDR for
       variable. Change variable name to at_type.
@
text
@a48 2
#include "elf/common.h"

d266 1
a266 13
  int ret;
  CORE_ADDR entry_addr;

  /* Find the address of the entry point of the program from the
     auxv vector.  */
  ret = target_auxv_search (&current_target, AT_ENTRY, &entry_addr);
  if (ret == 1)
     return entry_addr;                                                                              
  /*if (ret == 0 || ret == -1)*/
  else
    {
      return symfile_objfile ? symfile_objfile->ei.entry_point : 0;
    }
@


1.50
log
@	* objfiles.c (terminate_minimal_symbol_table): Remove unnecessary
	initializations.
@
text
@d286 2
@


1.49
log
@2004-02-14  Elena Zannoni  <ezannoni@@redhat.com>

	* symfile.c (init_entry_point_info, entry_point_address): Move
	from here...
	* objfiles.c (init_entry_point_info, entry_point_address):..to
	here.
	* symfile.h (init_entry_point_info, entry_point_address): Remove
	prototypes.
	* objfiles.h (init_entry_point_info, entry_point_address):Add
	prototypes.
	* cris-tdep.c: Remove include of symfile.h. Add include of
	objfiles.h.
	* infcall.c: Ditto.
	* mcore-tdep.c: Ditto.
	* mn10300-tdep.c: Ditto.
	* sh64-tdep.c: Ditto.
 	* v850-tdep.c: Ditto.
	* arm-tdep.c: Remove include of symfile.h.
	* blockframe.c: Ditto.
	* coffread.c: Ditto.
	* dbxread.c: Ditto.
	* dwarf2read.c: Ditto.
	* dwarfread.c: Ditto.
	* frv-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* mdebugread.c: Ditto.
	* mipsread.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* s390-tdep.c: Ditto.
	* sh-tdep.c: Ditto.
	* xstormy16-tdep.c: Ditto.
	* gdbarch.sh: Remove include of symfile.h.
	* gdbarch.c: Regenerate.
	* solib-irix.c (enable_break): Use entry_point_address().
	Add comment about include file.
	* xcoffread.c: Add comment about include file.
	* Makefile.in (arm-tdep.o, blockframe.o, coffread.o, cris-tdep.o)
	(dbxread.o, dwarf2read.o, dwarfread.o, frv-tdep.o, gdbarch.o)
	(ia64-tdep.o, infcall.o, mcore-tdep.o, mdebugread.o, mipsread.o)
	(mn10300-tdep.o, rs6000-nat.o, s390-tdep.o, sh64-tdep.o)
	(sh-tdep.o, v850-tdep.o, xstormy16-tdep.o): Update dependencies.
@
text
@a285 5
    DEPRECATED_SYMBOL_NAME (m) = NULL;
    SYMBOL_VALUE_ADDRESS (m) = 0;
    MSYMBOL_INFO (m) = NULL;
    MSYMBOL_SIZE (m) = 0;
    MSYMBOL_TYPE (m) = mst_unknown;
@


1.48
log
@2004-02-09  Elena Zannoni  <ezannoni@@redhat.com>

	* bcache.c (bcache_xmalloc): Use obstack_init instead of
	obstack_specify_allocation.
	* objfiles.c (allocate_objfile): Ditto.
	* solib-sunos.c (solib_add_common_symbols)
	(allocate_rt_common_objfile): Ditto.
	* symfile.c (reread_symbols): Ditto.
	* gdb_obstack.h: Add comment.
@
text
@d234 34
@


1.47
log
@2004-02-07  Elena Zannoni  <ezannoni@@redhat.com>

	* buildsym.c (free_pending_blocks, finish_block)
	(record_pending_block, make_blockvector, end_symtab): Replace
	symbol_obstack with objfile_obstack.
	* coffread.c (process_coff_symbol, coff_read_struct_type)
	(coff_read_enum_type): Ditto.
	* cp-namespace.c (initialize_namespace_symtab)
	(check_one_possible_namespace_symbol): Ditto.
	* dwarf2read.c (new_symbol, dwarf2_const_value, macro_start_file)
	(dwarf2_symbol_mark_computed): Ditto.
	* dwarfread.c (enum_type, new_symbol, synthesize_typedef): Ditto.
	* elfread.c (elf_symtab_read): Ditto.
	* hpread.c (hpread_symfile_init, hpread_symfile_init)
	(hpread_read_enum_type, hpread_read_function_type)
	(hpread_read_doc_function_type, hpread_process_one_debug_symbol):
	Ditto.
	* jv-lang.c (get_java_class_symtab, add_class_symbol)
	(java_link_class_type): Ditto.
	* mdebugread.c (parse_symbol, psymtab_to_symtab_1, new_symtab)
	(new_symbol): Ditto.
	* minsyms.c (install_minimal_symbols): Ditto.
	* objfiles.c (allocate_objfile): Remove init of symbol_obstack.
	(terminate_minimal_symbol_table): Replace symbol_obstack with
	objfile_obstack.
	(free_objfile): Remove freeing of symbol_obstack.
	* objfiles.h: Remove symbol_obstack field.
	* pa64solib.c (add_to_solist): Replace symbol_obstack with
	objfile_obstack.
	* solib-sunos.c (allocate_rt_common_objfile): Remove init of
	symbol_obstack.
	(solib_add_common_symbols): Replace symbol_obstack with
	objfile_obstack.
	* somsolib.c (som_solib_add): Ditto.
	* stabsread.c (patch_block_stabs, define_symbol, read_enum_type)
	(common_block_start, common_block_end): Ditto.
	* symfile.c (reread_symbols): Remove freeing and init of
	symbol_obstack.
	(allocate_symtab): Rename symbol_obstack to objfile_obstack.
	* symfile.h: Update comment.
	* symmisc.c (print_objfile_statistics): Remove symbol_obstack
	stats printing.
	* symtab.c (symbol_set_names): Replace symbol_obstack with
	objfile_obstack.
	* symtab.h (struct general_symbol_info, struct minimal_symbol):
	Update comments.
	* xcoffread.c (read_xcoff_symtab, SYMBOL_DUP, SYMNAME_ALLOC)
	(init_stringtab, xcoff_initial_scan): Replace symbol_obstack with
	objfile_obstack.
@
text
@d168 3
a170 2
      obstack_specify_allocation (&objfile->objfile_obstack, 0, 0, xmalloc,
				  xfree);
@


1.46
log
@2004-02-07  Elena Zannoni  <ezannoni@@redhat.com>

	* dbxread.c (dbx_symfile_init, start_psymtab, end_psymtab,
	coffstab_build_psymtabs, elfstab_build_psymtabs)
	(stabsect_build_psymtabs): Replace psymbol_obstack with
	objfile_obstack.
	* dwarf2-frame.c (decode_frame_entry_1): Ditto.
	* dwarf2read.c (dwarf2_build_psymtabs_hard, dwarf2_read_section):
	Ditto.
	* dwarfread.c (scan_compilation_units): Ditto.
	* elfread.c (elfstab_offset_sections): Ditto.
	* hppa-tdep.c (read_unwind_info): Ditto.
	* hpread.c (hpread_build_psymtabs, hpread_start_psymtab)
	(hpread_end_psymtab): Ditto.
	* mdebugread.c (mdebug_build_psymtabs, add_pending)
	(parse_partial_symbols, new_psymtab, elfmdebug_build_psymtabs):
	Ditto.
	* mips-tdep.c (non_heuristic_proc_desc): Ditto.
	* objfiles.c (add_to_objfile_sections)
	(build_objfile_section_table): Ditto.
	(allocate_objfile): Remove init of psymbol_obstack.
	(free_objfile): Remove freeing of psymbol_obstack.
	* objfiles.h (struct objfile): Remove field
	psymbol_obstack. Update comments.
	* pa64solib.c (pa64_solib_add_solib_objfile): Replace
	psymbol_obstack with objfile_obstack.
	* solib-sunos.c (allocate_rt_common_objfile): Remove init of
        psymbol_obstack.
	* somread.c (som_symfile_offsets, init_import_symbols)
	(init_export_symbols): Replace psymbol_obstack with
	objfile_obstack.
	* somsolib.c (som_solib_add_solib_objfile): Ditto.
	* symfile.c (default_symfile_offsets, syms_from_objfile)
	(reread_symbols): Remove freeing and init of psymbol_obstack.
	(cashier_psymtab): Update comment.
	* symmisc.c (print_objfile_statistics): Don't report stats for
	psymbol obstack.
	* symtab.h (struct general_symbol_info, struct partial_symtab):
	Update comments.
	* xcoffread.c (xcoff_start_psymtab, xcoff_end_psymtab, swap_sym)
	(xcoff_symfile_offsets): Replace psymbol_obstack with
	objfile_obstack.
@
text
@a169 3
      obstack_specify_allocation (&objfile->symbol_obstack, 0, 0, xmalloc,
				  xfree);

d236 1
a236 1
   OBJFILE->symbol_obstack; otherwise, just initialize
d243 1
a243 1
                         obstack_alloc (&objfile->symbol_obstack,
d339 2
a340 2
   that as much as possible is allocated on the symbol_obstack and
   objfile_obstack, so that the memory can be efficiently freed.
a429 2
  obstack_free (&objfile->symbol_obstack, 0);

@


1.45
log
@2004-02-07  Elena Zannoni  <ezannoni@@redhat.com>

        * objfiles.h (struct objfile): Add objfile_obstack field.
        Remove type_obstack field.

        * dwarf2read.c (dwarf2_add_field,dwarf2_add_member_fn,
        read_structure_scope read_enumeration, new_symbol): Replace
        type_obstack with objfile_obstack.
        * dwarfread.c (struct_type, enum_type): Ditto.
        * gdbtypes.c (alloc_type, alloc_type_instance, init_type)
        (lookup_fundamental_type): Ditto.
        * gdbtypes.h (TYPE_ALLOC): Ditto.
        * hpread.c (hpread_read_enum_type, hpread_read_function_type)
        (hpread_read_doc_function_type, hpread_read_struct_type)
        (fix_static_member_physnames, hpread_read_array_type)
        (hpread_read_subrange_type, hpread_type_lookup): Ditto.
        * jv-lang.c (java_lookup_class, type_from_class, type_from_class)
        (java_link_class_type): Ditto.
        * mdebugread.c (parse_type): Ditto.
        * objfiles.c (allocate_objfile, free_objfile): Ditto.
        * solib-sunos.c (solib_add_common_symbols): Ditto.
        * stabsread.c (define_symbol, read_type, read_member_functions,
        read_cpp_abbrev, read_one_struct_field): Ditto.
        * symfile.c (reread_symbols): Ditto.
        * symmisc.c (print_objfile_statistics): Ditto.
@
text
@d96 1
a96 1
  obstack_grow (&objfile->psymbol_obstack, (char *) &section, sizeof (section));
d122 1
a122 1
     can't free the old one (it's in the psymbol_obstack).  So we just
d128 1
a128 1
    obstack_finish (&objfile->psymbol_obstack);
d168 1
a168 1
      obstack_specify_allocation (&objfile->psymbol_obstack, 0, 0, xmalloc,
a171 2
      obstack_specify_allocation (&objfile->objfile_obstack, 0, 0, xmalloc,
				  xfree);
d343 1
a343 1
   psymbol_obstack, so that the memory can be efficiently freed.
d432 1
a432 1
  obstack_free (&objfile->psymbol_obstack, 0);
d434 1
a434 1
  obstack_free (&objfile->objfile_obstack, 0);
@


1.44
log
@2004-01-19  Andrew Cagney  <cagney@@redhat.com>

	* top.h (mapped_symbol_files): Delete declaration.
	* main.c (captured_main): Delete option "m" and "mapped".
	* objfiles.c (mapped_symbol_files): Delete variable.
	* symfile.c (symbol_file_command): Delete mmap code.
	(symbol_file_add_with_addrs_or_offsets): Ditto.
	(add_symbol_file_command, reread_separate_symbols): Ditto.
	* objfiles.h (OBJF_MAPPED): Delete.
	* objfiles.c (allocate_objfile) [USE_MMALLOC]: Delete.
	(free_objfile) [USE_MMALLOC]: Ditto.
	(open_existing_mapped_file): Delete function.
	(open_mapped_file): Delete function.
	(map_to_file): Delete function.
@
text
@d4 1
a4 1
   2001, 2002, 2003 Free Software Foundation, Inc.
d172 1
a172 1
      obstack_specify_allocation (&objfile->type_obstack, 0, 0, xmalloc,
d436 1
a436 1
  obstack_free (&objfile->type_obstack, 0);
@


1.43
log
@2003-11-23  Andrew Cagney  <cagney@@redhat.com>

	* symfile.c (symbol_file_command): Replace STREQ with strcmp.
	* defs.h (DEPRECATED_STREQN): Rename STREQN.
	(DEPRECATED_STREQ): Rename STREQ.
	* ada-exp.y, ada-lang.c, ada-lex.l, coffread.c: Update.
	* config/mips/tm-irix5.h, config/mips/tm-irix6.h: Update.
	* config/mips/tm-mipsv4.h, config/sparc/tm-sun4sol2.h: Update.
	* dbxread.c, dwarf2read.c, dwarfread.c, environ.c: Update.
	* eval.c, exec.c, f-lang.c, hppa-tdep.c, hpread.c: Update.
	* jv-exp.y, language.c, m2-exp.y, mcore-rom.c: Update.
	* mdebugread.c, mipsread.c, objc-exp.y, objfiles.c: Update.
	* p-exp.y, p-typeprint.c, p-valprint.c, rs6000-nat.c: Update.
	* source.c, sparc-tdep.c, stack.c, target.c: Update.
@
text
@a50 12
#if defined(USE_MMALLOC) && defined(HAVE_MMAP)

#include "mmalloc.h"

static int open_existing_mapped_file (char *, long, int);

static int open_mapped_file (char *filename, long mtime, int flags);

static void *map_to_file (int);

#endif /* defined(USE_MMALLOC) && defined(HAVE_MMAP) */

a61 2
int mapped_symbol_files;	/* Try to use mapped symbol files */

d139 2
a140 4
   requests for specific operations, like trying to open a mapped
   version of the objfile (OBJF_MAPPED).  Other bits like
   OBJF_SHARED are simply copied through to the new objfile flags
   member. */
a156 113
  if (mapped_symbol_files)
    flags |= OBJF_MAPPED;

#if defined(USE_MMALLOC) && defined(HAVE_MMAP)
  if (abfd != NULL)
    {

      /* If we can support mapped symbol files, try to open/reopen the
         mapped file that corresponds to the file from which we wish to
         read symbols.  If the objfile is to be mapped, we must malloc
         the structure itself using the mmap version, and arrange that
         all memory allocation for the objfile uses the mmap routines.
         If we are reusing an existing mapped file, from which we get
         our objfile pointer, we have to make sure that we update the
         pointers to the alloc/free functions in the obstack, in case
         these functions have moved within the current gdb.  */

      int fd;

      fd = open_mapped_file (bfd_get_filename (abfd), bfd_get_mtime (abfd),
			     flags);
      if (fd >= 0)
	{
	  void *md;

	  if ((md = map_to_file (fd)) == NULL)
	    {
	      close (fd);
	    }
	  else if ((objfile = (struct objfile *) mmalloc_getkey (md, 0)) != NULL)
	    {
	      /* Update memory corruption handler function addresses. */
	      init_malloc (md);
	      objfile->md = md;
	      objfile->mmfd = fd;
	      /* Update pointers to functions to *our* copies */
	      if (objfile->demangled_names_hash)
		htab_set_functions_ex
		  (objfile->demangled_names_hash, htab_hash_string,
		   (int (*) (const void *, const void *)) streq, NULL,
		   objfile->md, xmcalloc, xmfree);
	      obstack_chunkfun (&objfile->psymbol_cache.cache, xmmalloc);
	      obstack_freefun (&objfile->psymbol_cache.cache, xmfree);
	      obstack_chunkfun (&objfile->macro_cache.cache, xmmalloc);
	      obstack_freefun (&objfile->macro_cache.cache, xmfree);
	      obstack_chunkfun (&objfile->psymbol_obstack, xmmalloc);
	      obstack_freefun (&objfile->psymbol_obstack, xmfree);
	      obstack_chunkfun (&objfile->symbol_obstack, xmmalloc);
	      obstack_freefun (&objfile->symbol_obstack, xmfree);
	      obstack_chunkfun (&objfile->type_obstack, xmmalloc);
	      obstack_freefun (&objfile->type_obstack, xmfree);
	      /* If already in objfile list, unlink it. */
	      unlink_objfile (objfile);
	      /* Forget things specific to a particular gdb, may have changed. */
	      objfile->sf = NULL;
	    }
	  else
	    {

	      /* Set up to detect internal memory corruption.  MUST be
	         done before the first malloc.  See comments in
	         init_malloc() and mmcheck().  */

	      init_malloc (md);

	      objfile = (struct objfile *)
		xmmalloc (md, sizeof (struct objfile));
	      memset (objfile, 0, sizeof (struct objfile));
	      objfile->md = md;
	      objfile->mmfd = fd;
	      objfile->flags |= OBJF_MAPPED;
	      mmalloc_setkey (objfile->md, 0, objfile);
	      obstack_specify_allocation_with_arg (&objfile->psymbol_cache.cache,
						   0, 0, xmmalloc, xmfree,
						   objfile->md);
	      obstack_specify_allocation_with_arg (&objfile->macro_cache.cache,
						   0, 0, xmmalloc, xmfree,
						   objfile->md);
	      obstack_specify_allocation_with_arg (&objfile->psymbol_obstack,
						   0, 0, xmmalloc, xmfree,
						   objfile->md);
	      obstack_specify_allocation_with_arg (&objfile->symbol_obstack,
						   0, 0, xmmalloc, xmfree,
						   objfile->md);
	      obstack_specify_allocation_with_arg (&objfile->type_obstack,
						   0, 0, xmmalloc, xmfree,
						   objfile->md);
	    }
	}

      if ((flags & OBJF_MAPPED) && (objfile == NULL))
	{
	  warning ("symbol table for '%s' will not be mapped",
		   bfd_get_filename (abfd));
	  flags &= ~OBJF_MAPPED;
	}
    }
#else /* !defined(USE_MMALLOC) || !defined(HAVE_MMAP) */

  if (flags & OBJF_MAPPED)
    {
      warning ("mapped symbol tables are not supported on this machine; missing or broken mmap().");

      /* Turn off the global flag so we don't try to do mapped symbol tables
         any more, which shuts up gdb unless the user specifically gives the
         "mapped" keyword again. */

      mapped_symbol_files = 0;
      flags &= ~OBJF_MAPPED;
    }

#endif /* defined(USE_MMALLOC) && defined(HAVE_MMAP) */

a173 1
      flags &= ~OBJF_MAPPED;
d418 1
a418 4
  /* The last thing we do is free the objfile struct itself for the
     non-reusable case, or detach from the mapped file for the
     reusable case.  Note that the mmalloc_detach or the xmfree() is
     the last thing we can do with this objfile. */
d420 2
a421 3
#if defined(USE_MMALLOC) && defined(HAVE_MMAP)

  if (objfile->flags & OBJF_MAPPED)
d423 1
a423 36
      /* Remember the fd so we can close it.  We can't close it before
         doing the detach, and after the detach the objfile is gone. */
      int mmfd;

      mmfd = objfile->mmfd;
      mmalloc_detach (objfile->md);
      objfile = NULL;
      close (mmfd);
    }

#endif /* defined(USE_MMALLOC) && defined(HAVE_MMAP) */

  /* If we still have an objfile, then either we don't support reusable
     objfiles or this one was not reusable.  So free it normally. */

  if (objfile != NULL)
    {
      objfile_free_data (objfile);
      if (objfile->name != NULL)
	{
	  xmfree (objfile->md, objfile->name);
	}
      if (objfile->global_psymbols.list)
	xmfree (objfile->md, objfile->global_psymbols.list);
      if (objfile->static_psymbols.list)
	xmfree (objfile->md, objfile->static_psymbols.list);
      /* Free the obstacks for non-reusable objfiles */
      bcache_xfree (objfile->psymbol_cache);
      bcache_xfree (objfile->macro_cache);
      if (objfile->demangled_names_hash)
	htab_delete (objfile->demangled_names_hash);
      obstack_free (&objfile->psymbol_obstack, 0);
      obstack_free (&objfile->symbol_obstack, 0);
      obstack_free (&objfile->type_obstack, 0);
      xmfree (objfile->md, objfile);
      objfile = NULL;
d425 14
a728 162

#if defined(USE_MMALLOC) && defined(HAVE_MMAP)

/* Given the name of a mapped symbol file in SYMSFILENAME, and the timestamp
   of the corresponding symbol file in MTIME, try to open an existing file
   with the name SYMSFILENAME and verify it is more recent than the base
   file by checking it's timestamp against MTIME.

   If SYMSFILENAME does not exist (or can't be stat'd), simply returns -1.

   If SYMSFILENAME does exist, but is out of date, we check to see if the
   user has specified creation of a mapped file.  If so, we don't issue
   any warning message because we will be creating a new mapped file anyway,
   overwriting the old one.  If not, then we issue a warning message so that
   the user will know why we aren't using this existing mapped symbol file.
   In either case, we return -1.

   If SYMSFILENAME does exist and is not out of date, but can't be opened for
   some reason, then prints an appropriate system error message and returns -1.

   Otherwise, returns the open file descriptor.  */

static int
open_existing_mapped_file (char *symsfilename, long mtime, int flags)
{
  int fd = -1;
  struct stat sbuf;

  if (stat (symsfilename, &sbuf) == 0)
    {
      if (sbuf.st_mtime < mtime)
	{
	  if (!(flags & OBJF_MAPPED))
	    {
	      warning ("mapped symbol file `%s' is out of date, ignored it",
		       symsfilename);
	    }
	}
      else if ((fd = open (symsfilename, O_RDWR)) < 0)
	{
	  if (error_pre_print)
	    {
	      printf_unfiltered (error_pre_print);
	    }
	  print_sys_errmsg (symsfilename, errno);
	}
    }
  return (fd);
}

/* Look for a mapped symbol file that corresponds to FILENAME and is more
   recent than MTIME.  If MAPPED is nonzero, the user has asked that gdb
   use a mapped symbol file for this file, so create a new one if one does
   not currently exist.

   If found, then return an open file descriptor for the file, otherwise
   return -1.

   This routine is responsible for implementing the policy that generates
   the name of the mapped symbol file from the name of a file containing
   symbols that gdb would like to read.  Currently this policy is to append
   ".syms" to the name of the file.

   This routine is also responsible for implementing the policy that
   determines where the mapped symbol file is found (the search path).
   This policy is that when reading an existing mapped file, a file of
   the correct name in the current directory takes precedence over a
   file of the correct name in the same directory as the symbol file.
   When creating a new mapped file, it is always created in the current
   directory.  This helps to minimize the chances of a user unknowingly
   creating big mapped files in places like /bin and /usr/local/bin, and
   allows a local copy to override a manually installed global copy (in
   /bin for example).  */

static int
open_mapped_file (char *filename, long mtime, int flags)
{
  int fd;
  char *symsfilename;

  /* First try to open an existing file in the current directory, and
     then try the directory where the symbol file is located. */

  symsfilename = concat ("./", lbasename (filename), ".syms", (char *) NULL);
  if ((fd = open_existing_mapped_file (symsfilename, mtime, flags)) < 0)
    {
      xfree (symsfilename);
      symsfilename = concat (filename, ".syms", (char *) NULL);
      fd = open_existing_mapped_file (symsfilename, mtime, flags);
    }

  /* If we don't have an open file by now, then either the file does not
     already exist, or the base file has changed since it was created.  In
     either case, if the user has specified use of a mapped file, then
     create a new mapped file, truncating any existing one.  If we can't
     create one, print a system error message saying why we can't.

     By default the file is rw for everyone, with the user's umask taking
     care of turning off the permissions the user wants off. */

  if ((fd < 0) && (flags & OBJF_MAPPED))
    {
      xfree (symsfilename);
      symsfilename = concat ("./", lbasename (filename), ".syms",
			     (char *) NULL);
      if ((fd = open (symsfilename, O_RDWR | O_CREAT | O_TRUNC, 0666)) < 0)
	{
	  if (error_pre_print)
	    {
	      printf_unfiltered (error_pre_print);
	    }
	  print_sys_errmsg (symsfilename, errno);
	}
    }

  xfree (symsfilename);
  return (fd);
}

static void *
map_to_file (int fd)
{
  void *md;
  CORE_ADDR mapto;

  md = mmalloc_attach (fd, 0);
  if (md != NULL)
    {
      mapto = (CORE_ADDR) mmalloc_getkey (md, 1);
      md = mmalloc_detach (md);
      if (md != NULL)
	{
	  /* FIXME: should figure out why detach failed */
	  md = NULL;
	}
      else if (mapto != (CORE_ADDR) NULL)
	{
	  /* This mapping file needs to be remapped at "mapto" */
	  md = mmalloc_attach (fd, mapto);
	}
      else
	{
	  /* This is a freshly created mapping file. */
	  mapto = (CORE_ADDR) mmalloc_findbase (20 * 1024 * 1024);
	  if (mapto != 0)
	    {
	      /* To avoid reusing the freshly created mapping file, at the 
	         address selected by mmap, we must truncate it before trying
	         to do an attach at the address we want. */
	      ftruncate (fd, 0);
	      md = mmalloc_attach (fd, mapto);
	      if (md != NULL)
		{
		  mmalloc_setkey (md, 1, mapto);
		}
	    }
	}
    }
  return (md);
}

#endif /* defined(USE_MMALLOC) && defined(HAVE_MMAP) */
@


1.42
log
@2003-11-07  Michael Chastain  <mec@@shout.net>

	* symtab.h (struct minimal_symbol): Add size.
	* dbxread.c: Use it.
	* elfread.c: (record_minimal_symbol_and_info): Do not use info.
	Rename to record_minimal_symbol.
	(elf_symtab_read): Set MSYMBOL_SIZE explicitly.
	* minsyms.c (prim_record_minimal_symbol_and_info): Initialize MSYMBOL_SIZE.
	(install_minimal_symbols): Ditto.
	* objfiles.c (terminate_minimal_symbol_table): Ditto.
	* arm-tdep.c: Delete unused MSYMBOL_SIZE.
	* m68hc11-tdep.c: Ditto.
	* mips-tdep.c: Ditto.
	* sh64-tdep.c: Ditto.
@
text
@d1107 1
a1107 1
    if (objfile->import_list[i] && STREQ (name, objfile->import_list[i]))
@


1.41
log
@2003-11-07  Andrew Cagney  <cagney@@redhat.com>

	* top.c (print_gdb_version): Replace STREQ with strcmp.
	* valops.c (value_struct_elt_for_reference): Ditto.
	(value_struct_elt_for_reference): Ditto.
	* symtab.c (gdb_mangle_name): Ditto.
	(find_line_symtab): Ditto.
	* symmisc.c (maintenance_print_symbols): Ditto.
	* symfile.c (symbol_file_command): Ditto.
	* stabsread.c (define_symbol, read_type): Ditto.
	(cleanup_undefined_types, scan_file_globals): Ditto.
	* solib.c (solib_map_sections): Ditto.
	* solib-svr4.c (bfd_lookup_symbol): Ditto.
	* rs6000-tdep.c (skip_prologue): Ditto.
	* p-valprint.c (pascal_value_print): Ditto.
	(pascal_object_is_vtbl_ptr_type): Ditto.
	* objfiles.c (in_plt_section): Ditto.
	* minsyms.c (lookup_minimal_symbol): Ditto.
	(compact_minimal_symbols): Ditto.
	(find_solib_trampoline_target): Ditto.
	* mdebugread.c (parse_type): Ditto.
	* language.c (set_language_command): Ditto.
	(set_type_command, set_range_command): Ditto.
	* f-lang.c (add_common_block): Ditto.
	(add_common_block): Ditto.
	(find_first_common_named): Ditto.
	(patch_all_commons_by_name): Ditto.
	* elfread.c (elf_locate_sections): Ditto.
	(elf_locate_sections): Ditto.
	(elfstab_offset_sections): Ditto.
	* dwarf2read.c (dwarf2_locate_sections): Ditto.
	* dbxread.c (add_old_header_file): Ditto.
	(find_corresponding_bincl_psymtab): Ditto.
	(read_dbx_symtab, process_one_symbol): Ditto.
	* coffread.c (patch_opaque_types): Ditto.
	* cli/cli-decode.c (delete_cmd): Ditto.
	* cli/cli-cmds.c (pwd_command, list_command): Ditto.
	* c-typeprint.c (c_type_print_base): Ditto.
	* breakpoint.c (bpstat_stop_status): Ditto.
	(clear_command, breakpoint_re_set_one): Ditto.
@
text
@d389 1
@


1.40
log
@2003-11-05  Andrew Cagney  <cagney@@redhat.com>

	* xcoffread.c (find_linenos): Replace "sec_ptr" and "bfd" with
	"struct bfd_section" and "struct bfd".
	* target.h (struct section_table): Ditto.
	* rs6000-nat.c (xcoff_relocate_core): Ditto.
	* solib-svr4.c (elf_locate_base): Ditto.
	* pa64solib.c (dld_cache_t): Ditto.
	* objfiles.h (struct obj_section): Ditto.
	* objfiles.c (add_to_objfile_sections): Ditto.
	* exec.c (bfdsec_to_vmap): Ditto.
	(add_to_section_table): Ditto.
	(build_section_table): Ditto.
	* corelow.c (get_core_register_section): Ditto.
	* coffread.c (find_linenos): Ditto.
	* elfread.c (elf_interpreter): Delete #if0'd function.

	* mips-tdep.c (mips_dump_tdep): Delete code prinint VX_NUM_REGS.
	* config/sparc/tm-vxsparc.h (VX_NUM_REGS): Delete macro.
	* config/mips/tm-vxmips.h (VX_NUM_REGS): Delete macro.
	* config/m68k/tm-vx68.h (VX_NUM_REGS): Delete macro.

	* arch-utils.h (generic_cannot_extract_struct_value_address):
	Delete declaration.
	* wince.c (_initialize_wince): Fix multi-line string.
	* ia64-tdep.c (floatformat_valid): Convert to ISO C.
@
text
@d1090 1
a1090 1
	    && STREQ (s->the_bfd_section->name, ".plt"));
@


1.39
log
@* objfiles.h (clear_objfile_data): New prototype.
* objfiles.c (clear_objfile_data): New function.
* symfile.c (reread_symbols): Clear per-objfile data.
@
text
@a62 2
static void add_to_objfile_sections (bfd *, sec_ptr, void *);

d90 2
a91 1
add_to_objfile_sections (bfd *abfd, sec_ptr asect, void *objfile_p_char)
@


1.38
log
@2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* targets.c: Replace "struct sec" with "struct bfd_section"
	* syms.c, sparclynx.c, section.c, opncls.c: Ditto.
	* libcoff-in.h, libbfd-in.h, elfxx-target.h: Ditto.
	* elf.c, coffgen.c, bfd.c, bfd-in.h, aoutf1.h: Ditto.
	* aout-tic30.c, aout-target.h:
	* bfd-in2.h, libcoff.h, libbfd.h: Regenerate.

Index: binutils/ChangeLog
2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* coffgrok.h (coff_section): Replace 'struct sec" with "struct
	bfd_section".

Index: gdb/ChangeLog
2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* symtab.c: Replace "struct sec" with "struct bfd_section".
	* objfiles.c, linespec.c, blockframe.c, block.c: Ditto.

Index: ld/ChangeLog
2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* pe-dll.c: Replace "struct sec" with "struct bfd_section".

Index: sim/common/ChangeLog
2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* sim-base.h: Replace "struct sec" with "struct bfd_section".
@
text
@d1169 7
@


1.37
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@d1047 5
a1051 5
/* Returns a section whose range includes PC and SECTION, 
   or NULL if none found.  Note the distinction between the return type, 
   struct obj_section (which is defined in gdb), and the input type
   struct sec (which is a bfd-defined data type).  The obj_section
   contains a pointer to the bfd struct sec section.  */
d1054 1
a1054 1
find_pc_sect_section (CORE_ADDR pc, struct sec *section)
@


1.36
log
@2003-09-12  Andrew Cagney  <cagney@@redhat.com>

	* objfiles.h (struct entry_info): Deprecate "entry_file_lowpc" and
	"entry_file_highpc".  Update comments.
	* defs.h (deprecated_inside_entry_file): Rename
	"inside_entry_file".
	* blockframe.c (deprecated_inside_entry_file): Rename
	"inside_entry_file".
	* frame.c (get_prev_frame): Update.  Use if 0 instead of #if 0.
	* vax-tdep.c (vax_frame_chain): Update.
	* sh64-tdep.c (sh64_frame_chain): Update.
	* sh-tdep.c (sh_frame_chain): Update.
	* rs6000-tdep.c (rs6000_frame_chain): Update.
	* ns32k-tdep.c (ns32k_frame_chain): Update.
	* mips-tdep.c (mips_frame_chain): Update.
	* m68hc11-tdep.c (m68hc11_frame_this_id): Update.
	* m32r-tdep.c (m32r_frame_this_id): Update.
	* i386-interix-tdep.c (i386_interix_frame_chain_valid): Update.
	* frv-tdep.c (frv_frame_this_id): Update.
	* d10v-tdep.c (d10v_frame_this_id): Update.
	* cris-tdep.c (cris_frame_chain): Update.
	* blockframe.c (legacy_frame_chain_valid): Update.
	* avr-tdep.c (avr_frame_this_id): Update.
	* arm-tdep.c (arm_prologue_this_id): Update.
	* alpha-tdep.c (alpha_heuristic_frame_this_id): Update.
	* objfiles.c (objfile_relocate): Update.
	* mipsread.c (mipscoff_symfile_read): Update.
	(mipscoff_symfile_read): Update.
	* mdebugread.c (parse_partial_symbols): Update.
	* dwarfread.c (read_file_scope): Update.
	* dwarf2read.c (read_file_scope): Update.
	* dbxread.c (read_dbx_symtab): Update.
	(read_dbx_symtab): Update.
	* coffread.c (complete_symtab): Update.
@
text
@d1101 1
a1101 1
  register int i;
@


1.35
log
@2003-09-11  David Carlton  <carlton@@kealia.com>

	* gdbtypes.h: Add TYPE_CODE_NAMESPACE.
	* gdbtypes.c (init_type): Handle TYPE_CODE_NAMESPACE.
	(recursive_dump_type): Ditto.
	* printcmd.c (print_formatted): Ditto.
	* typeprint.c (print_type_scalar): Ditto.
	* c-typeprint.c (c_type_print_varspec_prefix): Ditto.
	(c_type_print_varspec_suffix, c_type_print_base): Ditto.
	* cp-support.h: Declare cp_check_possible_namespace_symbols,
	maint_cplus_cmd_list.
	* cp-support.c: Make maint_cplus_cmd_list extern.
	* cp-namespace.c: Include objfiles.h, gdbtypes.h, dictionary.h,
	command.h.
	(lookup_symbol_file): Look in possible namespace blocks when
	appropriate.
	(initialize_namespace_symtab): New.
	(get_possible_namespace_block, free_namespace_block)
	(check_possible_namespace_symbols)
	(check_possible_namespace_symbols_loop)
	(check_one_possible_namespace_symbol)
	(lookup_possible_namespace_symbol, maintenance_cplus_namespace)
	(_initialize_cp_namespace): Ditto.
	* block.h: Declare allocate_block.
	* block.c (allocate_block): New.
	* jv-lang.c (get_java_class_symtab): Allocate blocks via
	allocate_block.
	* symfile.h: Update declaration of add_psymbol_to_list.
	* symfile.c (add_psymbol_to_list): Return the partial symbol in
	question.
	* dwarf2read.c (dwarf2_build_psymtabs_hard): Add argument to
	scan_partial_symbols_call.
	(scan_partial_symbols): Add NAMESPACE argument; update calls to
	helper functions.
	(add_partial_symbol): If necessary, scan mangled names for names
	of namespaces.
	(add_partial_namespace): Add NAMESPACE argument; generate partial
	symbols associated  to namespaces.
	(add_partial_enumeration): Add NAMESPACE argument.
	(new_symbol): Allow namespace syms.
	(read_namespace): Generate namespace syms.
	* objfiles.h: Add opaque declaration of struct symtab.
	(struct objfile): Add cp_namespace_symtab member.
	* objfiles.c (allocate_objfile): Set
	objfile->cp_namespace_symtab.
	* Makefile.in (cp-namespace.o): Depend on objfiles_h, gdbtypes_h,
	dictionary_h, command_h.

2003-09-11  David Carlton  <carlton@@kealia.com>

	* gdb.c++/namespace.exp: Add tests for namespace types.
	* gdb.c++/maint.exp (test_help): Test 'help maint cp namespace'.
	(test_namespace): New.
@
text
@d790 1
a790 1
  if (objfile->ei.entry_file_lowpc != INVALID_ENTRY_LOWPC)
d792 2
a793 2
      objfile->ei.entry_file_lowpc += ANOFFSET (delta, SECT_OFF_TEXT (objfile));
      objfile->ei.entry_file_highpc += ANOFFSET (delta, SECT_OFF_TEXT (objfile));
@


1.34
log
@* objfiles.h (struct objfile): Add memebers `data' and `num_data'.
(register_objfile_data, set_objfile_data, objfile_data): New
prototypes.
* objfiles.c (objfile_alloc_data, objfile_free_data): New
prototypes.
(allocate_objfile): Call objfile_alloc_data.
(free_objfile): Call objfile_free_data.
(struct objfile_data): New.
(struct objfile_data_registration): New.
(struct objfile_data_registry): New.
(objfile_data_registry): New variable.
(register_objfile_data): New function.
(objfile_alloc_data, objfile_free_data): New functions.
(set_objfile_data, objfile_data): New functions.
* dwarf2-frame.c (dwarf2_frame_data): New variable.
(dwarf2_frame_find_fde, add_fde): Use new per-objfile data mechanism.
(_initialize_dwarf2_frame): New function and prototype.
@
text
@d341 8
a348 4
    objfile->sect_index_text = -1;
    objfile->sect_index_data = -1;
    objfile->sect_index_bss = -1;
    objfile->sect_index_rodata = -1;
@


1.33
log
@2003-06-11  David Carlton  <carlton@@bactrian.org>

	* dictionary.h: New.
	* dictionary.c: New.
	* block.h: Add opaque declaration for struct dictionary.
	(struct block): Add 'dict' member; delete 'hashtable', 'nsyms',
	'sym' members.
	(BLOCK_DICT): New macro.
	Delete macros BLOCK_HASHTABLE, BLOCK_NSYMS, BLOCK_SYM,
	BLOCK_BUCKETS, BLOCK_BUCKET, BLOCK_HASHTABLE_SIZE,
	BLOCK_SHOULD_SORT.
	(ALL_BLOCK_SYMBOLS): Update definition.
	* Makefile.in (SFILES): Add dictionary.c.
	(dictionary_h): New.
	(COMMON_OBS): Add dictionary.o.
	(dictionary.o): New.
	(ada-lang.o): Depend on dictionary_h.
	(buildsym.o, coffread.o, jv-lang.o, mdebugread.o, objfiles.o)
	(stack.o, symmisc.o, symtab.o, tracepoint.o, valops.o)
	(mi-cmd-stack.o): Ditto.
	(gdbtk-cmds.o): Update dependencies.
	(gdbtk-stack.o): Ditto.
	* ada-lang.c: Include dictionary.h.
	(symtab_for_sym): Update uses of ALL_BLOCK_SYMBOLS.
	(fill_in_ada_prototype, debug_print_block): Ditto.
	(ada_add_block_symbols): Update uses of ALL_BLOCK_SYMBOLS; replace
	explicit iteration by use of ALL_BLOCK_SYMBOLS.  Delete variable
	'is_sorted'.
	* mdebugread.c: Include dictionary.h.
	(struct parse_stack): Delete 'maxsyms' member.
	(parse_symbol): Update calls to new_block.  Delete calls to
	shrink_block.  Use dictionary methods.
	(psymtab_to_symtab_1): Delete calls to sort_symtab_syms.
	Update calls to new_symtab.  Don't maintain maxsyms data.
	(mylookup_symbol): Update use of ALL_BLOCK_SYMBOLS.
	(add_symbol): Just call dict_add_symbol.
	(new_symtab): Delete 'maxsyms' argument.
	(new_symtab): Update calls to new_block.
	(new_block): Delete 'maxsyms' argument; add 'function' argument.
	(shrink_block): Delete function.
	(fixup_sigtramp): Update call to new_block.  Add symbol via
	dict_add_symbol.
	* jv-lang.c: Include dictionary.h.
	(get_java_class_symtab): Set the BLOCK_DICT of the blocks
	appropriately.  Set class_symtab->free_func.  Make sure the
	blockvector is big enough to hold two blocks.
	(add_class_symtab_symbol): Use dictionary methods.
	(free_class_block): New function.
	(type_from_class): Replace explicit iteration by
	ALL_BLOCK_SYMBOLS.
	* symtab.h (struct symtab): Replace 'free_ptr' method by
	'free_func'.
	* dwarf2read.c (psymtab_to_symtab_1): Delete call to
	sort_symtab_syms.
	* dwarfread.c (psymtab_to_symtab_1): Delete call to
	sort_symtab_syms.
	* coffread.c (coff_symfile_read): Delete call to sort_symtab_syms.
	Include dictionary.h.
	(patch_opaque_types): Update use of ALL_BLOCK_SYMBOLS.
	* dbxread.c (dbx_psymtab_to_symtab_1): Delete call to
	sort_symtab_syms.
	* objfiles.c: Include dictionary.h.
	(objfile_relocate): Update use of ALL_BLOCK_SYMBOLS.
	* buildsym.c: Include dictionary.h.
	(finish_block): Use dictionary methods.
	(end_symtab): Set free_func to NULL, not free_ptr.
	* tracepoint.c: Include dictionary.h.
	(add_local_symbols): Update use of ALL_BLOCK_SYMBOLS.
	(scope_info): Ditto.
	* stack.c: Include dictionary.h.
	(print_block_frame_locals): Update use of ALL_BLOCK_SYMBOLS.
	(print_block_frame_labels, print_frame_arg_vars)
	(print_frame_args): Ditto.
	* symmisc.c (free_symtab_block): Use dictionary methods.
	(dump_symtab): Ditto.
	(free_symtab): Replace use of 'free_ptr' by 'free_func'.
	Include	dictionary.h.
	* symfile.h: Delete declarations of sort_block_syms,
	sort_symtab_syms.
	* symfile.c (sort_block_syms): Delete.
	(sort_symtab_syms): Delete.
	* symtab.c: Include dictionary.h.
	(lookup_block_symbol): Use dictionary iterators.
	(find_pc_sect_symtab): Update use of ALL_BLOCK_SYMBOLS.
	(search_symbols, make_symbol_completion_list): Ditto.
	(make_symbol_overload_list): Ditto.
	* valops.c (value_of_local): Use dict_empty.
	Include dictionary.h.

2003-06-11  David Carlton  <carlton@@bactrian.org>

	* generic/gdbtk-stack.c: Include dictionary.h.
	(gdb_block_vars): Update use of ALL_BLOCK_SYMBOLS.
	(gdb_get_blocks, gdb_get_vars_command): Ditto.
	* generic/gdbtk-cmds.c: Include dictionary.h.
	(gdb_listfuncs): Update use of ALL_BLOCK_SYMBOLS.

2003-06-11  David Carlton  <carlton@@bactrian.org>

	* mi-cmd-stack.c: Include dictionary.h.
	(list_args_or_locals): Update use of ALL_BLOCK_SYMBOLS.
@
text
@d37 1
d65 3
d309 2
d570 1
d1107 32
d1140 38
@


1.33.4.1
log
@	Merge from mainline:
	2003-07-13  Mark Kettenis  <kettenis@@gnu.org>

	* objfiles.h (struct objfile): Add memebers `data' and `num_data'.
	(register_objfile_data, set_objfile_data, objfile_data): New
	prototypes.
	* objfiles.c (objfile_alloc_data, objfile_free_data): New
	prototypes.
	(allocate_objfile): Call objfile_alloc_data.
	(free_objfile): Call objfile_free_data.
	(struct objfile_data): New.
	(struct objfile_data_registration): New.
	(struct objfile_data_registry): New.
	(objfile_data_registry): New variable.
	(register_objfile_data): New function.
	(objfile_alloc_data, objfile_free_data): New functions.
	(set_objfile_data, objfile_data): New functions.
	* dwarf2-frame.c (dwarf2_frame_data): New variable.
	(dwarf2_frame_find_fde, add_fde): Use new per-objfile data mechanism.
	(_initialize_dwarf2_frame): New function and prototype.
@
text
@a36 1
#include "gdb_assert.h"
a63 3
static void objfile_alloc_data (struct objfile *objfile);
static void objfile_free_data (struct objfile *objfile);

a304 2
  objfile_alloc_data (objfile);

a563 1
      objfile_free_data (objfile);
a1099 32


/* Keep a registry of per-objfile data-pointers required by other GDB
   modules.  */

struct objfile_data
{
  unsigned index;
};

struct objfile_data_registration
{
  struct objfile_data *data;
  struct objfile_data_registration *next;
};
  
struct objfile_data_registry
{
  struct objfile_data_registration *registrations;
  unsigned num_registrations;
};

static struct objfile_data_registry objfile_data_registry = { NULL, 0 };

const struct objfile_data *
register_objfile_data (void)
{
  struct objfile_data_registration **curr;

  /* Append new registration.  */
  for (curr = &objfile_data_registry.registrations;
       *curr != NULL; curr = &(*curr)->next);
a1100 38
  *curr = XMALLOC (struct objfile_data_registration);
  (*curr)->next = NULL;
  (*curr)->data = XMALLOC (struct objfile_data);
  (*curr)->data->index = objfile_data_registry.num_registrations++;

  return (*curr)->data;
}

static void
objfile_alloc_data (struct objfile *objfile)
{
  gdb_assert (objfile->data == NULL);
  objfile->num_data = objfile_data_registry.num_registrations;
  objfile->data = XCALLOC (objfile->num_data, void *);
}

static void
objfile_free_data (struct objfile *objfile)
{
  gdb_assert (objfile->data != NULL);
  xfree (objfile->data);
  objfile->data = NULL;
}

void
set_objfile_data (struct objfile *objfile, const struct objfile_data *data,
		  void *value)
{
  gdb_assert (data->index < objfile->num_data);
  objfile->data[data->index] = value;
}

void *
objfile_data (struct objfile *objfile, const struct objfile_data *data)
{
  gdb_assert (data->index < objfile->num_data);
  return objfile->data[data->index];
}
@


1.33.4.2
log
@Merged from mainline:

2003-10-29  Mark Kettenis  <kettenis@@gnu.org>

* objfiles.h (clear_objfile_data): New prototype.
* objfiles.c (clear_objfile_data): New function.
* symfile.c (reread_symbols): Clear per-objfile data.
@
text
@a1164 7
clear_objfile_data (struct objfile *objfile)
{
  gdb_assert (objfile->data != NULL);
  memset (objfile->data, 0, objfile->num_data * sizeof (void *));
}

void
@


1.32
log
@	* elfread.c (elf_symtab_read): Avoid use of SECT_OFF_MAX.
	(elfstab_offset_sections): Likewise.
	* gdb-stabs.h (stab_section_info): Likewise.
	* i386-interix-tdep.c (pei_adjust_objfile_offsets): Likewise.
	* objfiles.c (objfile_relocate): Likewise.
	* pa64solib.c (pa64_solib_add_solib_objfile): Likewise.
	* remote.c (get_offsets): Likewise.
	(remote_cisco_objfile_relocate): Likewise.
	* somread.c (som_symfile_offsets): Likewise.
	* symfile.c (alloc_section_addr_info): New function.
	(build_section_addr_info_from_section_tab): Use it.
	(free_section_addr_info): Adjust.
	(default_symfile_offsets): Avoid use of SECT_OFF_MAX.
	(syms_from_objfile): Allocate local_addr dynamically.
	(symbol_file_add_with_addrs_or_offsets): Allocate orig_addrs
	dynamically.
	(add_symbol_file_command): Allocate sect_opts dynamically.
	(reread_symbols): Avoid use of SECT_OFF_MAX.
	* symfile.h (section_addr_info): Do not use MAX_SECTIONS.
	(alloc_section_addr_info): Declare it.
	* symtab.h (SIZEOF_SECTION_OFFSETS): Remove.
	* win32-nat.c (solib_symbols_add): Allocate section_addrs
	dynamically.
	* xcoffread.c (xcoff_symfile_offsets): Avoid use of SECT_OFF_MAX.
@
text
@d46 1
d661 1
a661 1
	  int j;
d667 1
a667 1
	  ALL_BLOCK_SYMBOLS (b, j, sym)
@


1.31
log
@2003-05-14  Elena Zannoni  <ezannoni@@redhat.com>

	* symtab.h (enum domain_enum): Rename from namespace_enum.
	(UNDEF_DOMAIN, VAR_DOMAIN, STRUCT_DOMAIN, LABEL_DOMAIN,
	VARIABLES_DOMAIN, FUNCTIONS_DOMAIN, TYPES_DOMAIN, METHODS_DOMAIN):
	Rename from UNDEF_NAMESPACE, VAR_NAMESPACE, STRUCT_NAMESPACE,
	LABEL_NAMESPACE, VARIABLES_NAMESPACE, FUNCTIONS_NAMESPACE,
	TYPES_NAMESPACE, METHODS_NAMESPACE.
	(SYMBOL_NAMESPACE): Rename to SYMBOL_DOMAIN.
	(struct symbol, struct partial_symbol): Rename field
	'namespace_enum namespace' to 'domain_enum domain'.
	(PSYMBOL_NAMESPACE): Rename to PSYMBOL_DOMAIN.
	Delete old define kludge for namespace.

	* ada-exp.y, ada-lang.c, ada-lang.h, alpha-tdep.c, arm-tdep.c,
	blockframe.c, c-exp.y, c-valprint.c, coffread.c, dbxread.c,
	dwarf2read.c, dwarfread.c, f-exp.y, gdbtypes.c, gdbtypes.h,
	gnu-v3-abi.c, hppa-tdep.c, hpread.c, jv-exp.y, jv-lang.c,
	language.c, linespec.c, m2-exp.y, m3-nat.c, mdebugread.c,
	mips-tdep.c, nlmread.c, objc-exp.y, objc-lang.c, objfiles.c,
	p-exp.y, p-valprint.c, parse.c, printcmd.c, scm-lang.c, source.c,
	stabsread.c, stack.c, symfile.c, symfile.h, symmisc.c, symtab.c,
	valops.c, values.c, xcoffread.c, xstormy16-tdep.c: Replace all
	occurrences of the above.

2003-05-12  Elena Zannoni  <ezannoni@@redhat.com>

	* mi-mi-cmd-stack.c (list_args_or_locals): Rename VAR_NAMESPACE to
	VAR_DOMAIN.
@
text
@d616 2
a617 1
    (struct section_offsets *) alloca (SIZEOF_SECTION_OFFSETS);
@


1.30
log
@2003-05-02  David Carlton  <carlton@@bactrian.org>

	* objfiles.c (allocate_objfile): For anonymous objfiles, allocate
	the name with mstrsave.
@
text
@d670 1
a670 1
	         any symbols in STRUCT_NAMESPACE or UNDEF_NAMESPACE.
d685 1
a685 1
		       && SYMBOL_NAMESPACE (sym) == LABEL_NAMESPACE
@


1.29
log
@2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_NATURAL_NAME): New macro.
	(SYMBOL_LINKAGE_NAME): Ditto.
	(SYMBOL_PRINT_NAME): Use SYMBOL_NATURAL_NAME and
	SYMBOL_LINKAGE_NAME.
	(struct general_symbol_info): Expand comment.
	(DEPRECATED_SYMBOL_NAME): Rename from SYMBOL_NAME.
	(SYMBOL_MATCHES_NAME): Use DEPRECATED_SYMBOL_NAME.
	(SYMBOL_MATCHES_REGEXP): Ditto.
	* symtab.c (symbol_natural_name): New function.
	* objfiles.h: Replace all uses of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* xcoffread.c, valops.c, typeprint.c, tracepoint.c: Ditto.
	* symtab.c, symmisc.c, symfile.c, stack.c, stabsread.c: Ditto.
	* somsolib.c, sol-thread.c, rs6000-tdep.c, p-valprint.c: Ditto.
	* printcmd.c, objfiles.c, objc-lang.c, mipsread.c: Ditto.
	* minsyms.c, mdebugread.c, linespec.c, jv-lang.c: Ditto.
	* i386-tdep.c, i386-linux-tdep.c, hpread.c, hppa-tdep.c: Ditto.
	* gnu-v2-abi.c, f-valprint.c, findvar.c, expprint.c: Ditto.
	* dwarfread.c, dwarf2read.c, dbxread.c, c-valprint.c: Ditto.
	* cp-valprint.c, coffread.c, buildsym.c, breakpoint.c: Ditto.
	* blockframe.c, ax-gdb.c, arm-linux-tdep.c, ada-lang.c: Ditto.
	* ada-exp.y: Ditto.
	* ada-exp.y: Update copyright.
	* sol-thread.c, mipsread.c, jv-lang.c, f-valprint.c: Ditto.
	* cp-valprint.c: Ditto.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* generic/gdbtk.h: Replace all instances of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Ditto.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Update copyright.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: Replace all instances of SYMBOL_NAME with
	DEPRECATED_SYMBOL_NAME.  Update copyright.
@
text
@d328 1
a328 1
      objfile->name = "<<anonymous objfile>>";
@


1.29.16.1
log
@Merge from mainline.
@
text
@d328 1
a328 1
      objfile->name = mstrsave (objfile->md, "<<anonymous objfile>>");
@


1.29.16.2
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d670 1
a670 1
	         any symbols in STRUCT_DOMAIN or UNDEF_DOMAIN.
d685 1
a685 1
		       && SYMBOL_DOMAIN (sym) == LABEL_DOMAIN
@


1.28
log
@2003-02-19  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (SFILES): Add block.c.
	(block_h): New.
	(COMMON_OBS): Add block.o.
	(block.o): New.
	(x86-64-tdep.o): Add $(block_h).
	(values.o, valops.o, tracepoint.o, symtab.o, symmisc.o, symfile.o)
	(stack.o, printcmd.o, p-exp.tab.o, parse.o, objfiles.o)
	(objc-exp.tab.o, objc-lang.o, nlmread.o, mips-tdep.o, mdebugread.o)
	(m2-exp.tab.o, linespec.o, jv-lang.o, jv-exp.tab.o, infcmd.o)
	(f-valprint.o, findvar.o, f-exp.tab.o, expprint.o, coffread.o)
	(c-exp.tab.o, buildsym.o, breakpoint.o, blockframe.o, ax-gdb.o)
	(alpha-tdep.o, ada-lang.o, ada-exp.tab.o, mi-cmd-stack.o): Ditto.
	* value.h: Add opaque declaration for struct block.
	* parser-defs.h, objc-lang.h, buildsym.h, breakpoint.h: Ditto.
	* ada-lang.h: Ditto.
	* x86-64-tdep.c: #include "block.h"
	* values.c, valops.c, tracepoint.c, symtab.c, symmisc.c: Ditto.
	* symfile.c, stack.c, printcmd.c, p-exp.y, parse.c: Ditto.
	* objfiles.c, objc-exp.y, objc-lang.c, nlmread.c: Ditto.
	* mips-tdep.c, mdebugread.c, m2-exp.y, linespec.c: Ditto.
	* jv-lang.c, jv-exp.y, infcmd.c, f-valprint.c: Ditto.
	* findvar.c, f-exp.y, expprint.c, coffread.c, c-exp.y: Ditto.
	* buildsym.c, breakpoint.c, blockframe.c, ax-gdb.c: Ditto.
	* alpha-tdep.c, ada-lang.c, ada-exp.y: Ditto.
	* blockframe.c (blockvector_for_pc_sect): Move to "block.c".
	(blockvector_for_pc, block_for_pc_sect, block_for_pc): Ditto.
	* symtab.c (block_function): Ditto.
	(contained_in): Ditto.
	* frame.h: Move block_for_pc and block_for_pc_sect declarations to
	block.h.  Add opaque declaration for struct block.
	* symtab.h: Move block_function and contained_in declarations to
	block.h.  Add opaque declarations for struct block, struct
	blockvector.
	(struct block): Move to block.h.
	(struct blockvector): Ditto.
	(BLOCK_START, BLOCK_END, BLOCK_FUNCTION, BLOCK_SUPERBLOCK)
	(BLOCK_GCC_COMPILED, BLOCK_HASHTABLE, BLOCK_NSYMS, BLOCK_SYM)
	(BLOCK_BUCKETS, BLOCK_BUCKET, BLOCK_HASHTABLE_SIZE)
	(ALL_BLOCK_SYMBOLS, BLOCK_SHOULD_SORT, BLOCKVECTOR_NBLOCKS)
	(BLOCKVECTOR_BLOCK, GLOBAL_BLOCK, STATIC_BLOCK, FIRST_LOCAL_BLOCK):
	Ditto.
	* block.c: New file.
	* block.h: New file.

2003-02-19  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: #include "block.h"
@
text
@d376 1
a376 1
    SYMBOL_NAME (m) = NULL;
d686 1
a686 1
		       && strcmp (SYMBOL_NAME (sym), MIPS_EFI_SYMBOL_NAME) == 0)
@


1.27
log
@2003-02-04  David Carlton  <carlton@@math.stanford.edu>

	* objfiles.c (allocate_objfile): Always set name.  Add comment at
	start of function.
	* jv-lang.c (get_dynamics_objfile): Add comment.
@
text
@d45 1
@


1.26
log
@	* defs.h (streq): Add prototype.
	* utils.c (streq): New function.

	* dwarf2read.c (new_symbol): Use SYMBOL_SET_NAMES instead of
	SYMBOL_NAME and SYMBOL_INIT_DEMANGLED_NAME.
	* mdebugread.c (new_symbol): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* coffread.c (process_coff_symbol): Likewise.
	* dwarfread.c (new_symbol): Likewise.

	* minsyms.c (prim_record_minimal_symbol_and_info): Use
	SYMBOL_SET_NAMES instead of setting SYMBOL_NAME.  Set the language
	here.
	(install_minimal_symbols): Don't set SYMBOL_LANGUAGE or call
	SYMBOL_INIT_DEMANGLED_NAME.
	* objfiles.c: Include "hashtab.h".
	(allocate_objfile): Call htab_set_functions_ex for the
	demangled_names_hash.
	(free_objfile): Call htab_delete for the demangled_names_hash.
	* objfiles.h (struct htab): Add declaration.
	(struct objfile): Add demangled_names_hash.
	* symfile.c: Include "hashtab.h".
	(reread_symbols): Call htab_delete for the demangled_names_hash.
	(add_psymbol_to_list): Use SYMBOL_SET_NAMES instead of putting
	SYMBOL_NAME in the bcache.
	* symtab.c: Include "hashtab.h".  Update comments.
	(create_demangled_names_hash, symbol_set_names): New functions.
	(symbol_find_demangled_name): New function, broken out from
	symbol_init_demangled_names.
	(symbol_init_demangled_names): Use it.
	* symtab.h (SYMBOL_INIT_DEMANGLED_NAME): Add missing parentheses.
	(SYMBOL_SET_NAMES): New macro.
	(symbol_set_names): Add prototype.
@
text
@d153 9
d324 4
@


1.25
log
@Use a single, consistent representation for an empty minimal
symbol table in an objfile.
* objfiles.c (terminate_minimal_symbol_table): New function.
(allocate_objfile): Call it.
* objfiles.h (terminate_minimal_symbol_table): New declaration.
(ALL_MSYMBOLS): No need to test whether (objfile)->msymbols is
non-NULL.
* minsyms.c (lookup_minimal_symbol_by_pc_section): To see whether
objfile has minimal symbols, compare minimal_symbol_count to zero,
instead of comparing msymbols with NULL.
* objfiles.c (have_minimal_symbols): Same.
* solib-sunos.c (solib_add_common_symbols): Call
terminate_minimal_symbol_table.
* symfile.c (reread_symbols): Same.
@
text
@d4 1
a4 1
   2001, 2002 Free Software Foundation, Inc.
d42 1
d195 5
d560 2
@


1.24
log
@gdb/ChangeLog:
2003-01-23  Alexander Larsson <alexl@@redhat.com>
	    Jim Blandy  <jimb@@redhat.com>

	Add support for executables whose debug info has been separated
	out into a separate file, leaving only a link behind.
	* objfiles.h (struct objfile): New fields: separate_debug_objfile
	and separate_debug_objfile_backlink.
	(put_objfile_before): New declaration.
	* symfile.c: #include "filenames.h".
	(symbol_file_add_with_addrs_or_offsets): If this objfile has its
	debug info in a separate file, read that, too. Save the addrs
	argument, so we can use it again to read the separated debug info;
	syms_from_objfile modifies the table we pass it.
	(reread_symbols): After re-reading an objfile, call
	reread_separate_symbols to refresh its separate debug info
	objfile, if it has one.
	(reread_separate_symbols, find_separate_debug_file,
	get_debug_link_info, separate_debug_file_exists): New functions.
	(debug_file_directory): New global var.
	(_initialize_symfile): Initialize debug_file_directory, and
	provide the new `set debug-file-directory' command to let the user
	change it.
	* objfiles.c (free_objfile): If this objfile has its debug info in
	a separate objfile, free that one too.  If this is itself a
	separate debug info objfile, clear our parent's backlink.
	(put_objfile_before): New function.
	* utils.c (gnu_debuglink_crc32): New function.
	* defs.h (gnu_debuglink_crc32): New declaration.
	* Makefile.in (symfile.o): Note dependency on "filenames.h".
	* configure.in: Handle --with-separate-debug-dir config option.
	* acinclude.m4 (AC_DEFINE_DIR): New macro.
	* acconfig.h (DEBUGDIR): New macro.
	* configure, aclocal.m4, config.in: Regenerated.

gdb/doc/ChangeLog:
2003-01-23  Jim Blandy  <jimb@@redhat.com>

	* gdb.texinfo (Separate Debug Files): New section.
@
text
@d284 2
d338 27
d842 1
a842 1
    if (ofp->msymbols != NULL)
@


1.24.2.1
log
@Merge with interps-20030203-mergepoint.
@
text
@a283 2

      terminate_minimal_symbol_table (objfile);
a335 27

/* Create the terminating entry of OBJFILE's minimal symbol table.
   If OBJFILE->msymbols is zero, allocate a single entry from
   OBJFILE->symbol_obstack; otherwise, just initialize
   OBJFILE->msymbols[OBJFILE->minimal_symbol_count].  */
void
terminate_minimal_symbol_table (struct objfile *objfile)
{
  if (! objfile->msymbols)
    objfile->msymbols = ((struct minimal_symbol *)
                         obstack_alloc (&objfile->symbol_obstack,
                                        sizeof (objfile->msymbols[0])));

  {
    struct minimal_symbol *m
      = &objfile->msymbols[objfile->minimal_symbol_count];

    memset (m, 0, sizeof (*m));
    SYMBOL_NAME (m) = NULL;
    SYMBOL_VALUE_ADDRESS (m) = 0;
    MSYMBOL_INFO (m) = NULL;
    MSYMBOL_TYPE (m) = mst_unknown;
    SYMBOL_INIT_LANGUAGE_SPECIFIC (m, language_unknown);
  }
}


d813 1
a813 1
    if (ofp->minimal_symbol_count > 0)
@


1.23
log
@2003-01-18  Andrew Cagney  <ac131313@@redhat.com>

	* ada-valprint.c: Eliminate PTR.
	* breakpoint.c, corelow.c, cris-tdep.c, dbxread.c: Ditto.
	* defs.h, dve3900-rom.c, dwarf2read.c, dwarfread.c: Ditto.
	* exec.c, hppa-tdep.c, hpread.c, infcmd.c, mdebugread.c: Ditto.
	* objfiles.c, objfiles.h, ocd.c, remote-es.c: Ditto.
	* remote-mips.c, remote-sds.c, remote-vx.c: Ditto.
	* solib-svr4.c, solib.c, stack.c, symfile.c, symfile.h: Ditto.
	* symmisc.c, v850ice.c, xcoffread.c, cli/cli-script.c: Ditto.
@
text
@d336 24
d432 12
@


1.22
log
@2002-07-29  Andrew Cagney  <ac131313@@redhat.com>

* gdb_obstack.h: New file.
* symtab.h: Include "gdb_obstack.h" instead of "obstack.h".
(obstack_chunk_alloc, obstack_chunk_free): Delete macros.
* objfiles.h: Include "gdb_obstack.h".
* Makefile.in (gdb_obstack_h): Define.
(symtab_h): Add $(gdb_obstack_h).
(objfiles_h): Add $(gdb_obstack_h).

* objfiles.c: Include "gdb_obstack.h" instead of "obstack.h".
* macrotab.c, cp-valprint.c, dbxread.c: Ditto.
* ch-typeprint.c, ch-valprint.c, dstread.c: Ditto.
* macroexp.c, p-typeprint.c, stabsread.c: Ditto.
* symtab.c, f-typeprint.c, mdebugread.c: Ditto.
* p-valprint.c, symmisc.c, typeprint.c: Ditto.
* symfile.c, coffread.c, c-typeprint.c: Ditto.
* buildsym.c, bcache.c, ada-typeprint.c: Ditto.

* Makefile.in (bcache.o): Update dependencies.
(buildsym.o, c-typeprint.o, ch-typeprint.o): Ditto.
(ch-valprint.o, coffread.o, cp-valprint.o): Ditto.
(dbxread.o, dstread.o, f-typeprint.o): Ditto.
(objfiles.o, p-typeprint.o, p-valprint.o): Ditto.
(stabsread.o, symfile.o, symmisc.o): Ditto.
(symtab.o, typeprint.o, macroexp.o): Ditto.
(macrotab.o, mdebugread.o): Ditto.
(f_lang_h, coff_sym_h, coff_symconst_h): Define.
(coff_ecoff_h, aout_aout64_h): Define.
(aout_stabs_gnu_h, libaout_h): Define.
@
text
@d55 1
a55 1
static PTR map_to_file (int);
d59 1
a59 1
static void add_to_objfile_sections (bfd *, sec_ptr, PTR);
d85 1
a85 1
add_to_objfile_sections (bfd *abfd, sec_ptr asect, PTR objfile_p_char)
d181 1
a181 1
	  PTR md;
d903 1
a903 1
static PTR
d906 1
a906 1
  PTR md;
d909 1
a909 1
  md = mmalloc_attach (fd, (PTR) 0);
d922 1
a922 1
	  md = mmalloc_attach (fd, (PTR) mapto);
d934 1
a934 1
	      md = mmalloc_attach (fd, (PTR) mapto);
d937 1
a937 1
		  mmalloc_setkey (md, 1, (PTR) mapto);
@


1.22.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d4 1
a4 1
   2001, 2002, 2003 Free Software Foundation, Inc.
a36 1
#include "gdb_assert.h"
a41 1
#include "hashtab.h"
a43 2
#include "block.h"
#include "dictionary.h"
d55 1
a55 1
static void *map_to_file (int);
d59 1
a59 2
static void objfile_alloc_data (struct objfile *objfile);
static void objfile_free_data (struct objfile *objfile);
d85 1
a85 2
add_to_objfile_sections (struct bfd *abfd, struct bfd_section *asect,
			 void *objfile_p_char)
a151 9
/* NOTE: carlton/2003-02-04: This function is called with args NULL, 0
   by jv-lang.c, to create an artificial objfile used to hold
   information about dynamically-loaded Java classes.  Unfortunately,
   that branch of this function doesn't get tested very frequently, so
   it's prone to breakage.  (E.g. at one time the name was set to NULL
   in that situation, which broke a loop over all names in the dynamic
   library loader.)  If you change this function, please try to leave
   things in a consistent state even if abfd is NULL.  */

d181 1
a181 1
	  void *md;
a193 5
	      if (objfile->demangled_names_hash)
		htab_set_functions_ex
		  (objfile->demangled_names_hash, htab_hash_string,
		   (int (*) (const void *, const void *)) streq, NULL,
		   objfile->md, xmcalloc, xmfree);
a283 2

      terminate_minimal_symbol_table (objfile);
a285 2
  objfile_alloc_data (objfile);

a307 4
  else
    {
      objfile->name = mstrsave (objfile->md, "<<anonymous objfile>>");
    }
d312 4
a315 8
  objfile->sect_index_text = -1;
  objfile->sect_index_data = -1;
  objfile->sect_index_bss = -1;
  objfile->sect_index_rodata = -1;

  /* We don't yet have a C++-specific namespace symtab.  */

  objfile->cp_namespace_symtab = NULL;
a335 52

/* Create the terminating entry of OBJFILE's minimal symbol table.
   If OBJFILE->msymbols is zero, allocate a single entry from
   OBJFILE->symbol_obstack; otherwise, just initialize
   OBJFILE->msymbols[OBJFILE->minimal_symbol_count].  */
void
terminate_minimal_symbol_table (struct objfile *objfile)
{
  if (! objfile->msymbols)
    objfile->msymbols = ((struct minimal_symbol *)
                         obstack_alloc (&objfile->symbol_obstack,
                                        sizeof (objfile->msymbols[0])));

  {
    struct minimal_symbol *m
      = &objfile->msymbols[objfile->minimal_symbol_count];

    memset (m, 0, sizeof (*m));
    DEPRECATED_SYMBOL_NAME (m) = NULL;
    SYMBOL_VALUE_ADDRESS (m) = 0;
    MSYMBOL_INFO (m) = NULL;
    MSYMBOL_SIZE (m) = 0;
    MSYMBOL_TYPE (m) = mst_unknown;
    SYMBOL_INIT_LANGUAGE_SPECIFIC (m, language_unknown);
  }
}


/* Put one object file before a specified on in the global list.
   This can be used to make sure an object file is destroyed before
   another when using ALL_OBJFILES_SAFE to free all objfiles. */
void
put_objfile_before (struct objfile *objfile, struct objfile *before_this)
{
  struct objfile **objp;

  unlink_objfile (objfile);
  
  for (objp = &object_files; *objp != NULL; objp = &((*objp)->next))
    {
      if (*objp == before_this)
	{
	  objfile->next = *objp;
	  *objp = objfile;
	  return;
	}
    }
  
  internal_error (__FILE__, __LINE__,
		  "put_objfile_before: before objfile not in list");
}

a407 12
  if (objfile->separate_debug_objfile)
    {
      free_objfile (objfile->separate_debug_objfile);
    }
  
  if (objfile->separate_debug_objfile_backlink)
    {
      /* We freed the separate debug file, make sure the base objfile
	 doesn't reference it.  */
      objfile->separate_debug_objfile_backlink->separate_debug_objfile = NULL;
    }
  
a477 1
      objfile_free_data (objfile);
a488 2
      if (objfile->demangled_names_hash)
	htab_delete (objfile->demangled_names_hash);
d529 1
a529 2
    ((struct section_offsets *) 
     alloca (SIZEOF_N_SECTION_OFFSETS (objfile->num_sections)));
d572 1
a572 1
	  struct dict_iterator iter;
d578 1
a578 1
	  ALL_BLOCK_SYMBOLS (b, iter, sym)
d583 1
a583 1
	         any symbols in STRUCT_DOMAIN or UNDEF_DOMAIN.
d598 2
a599 2
		       && SYMBOL_DOMAIN (sym) == LABEL_DOMAIN
		       && strcmp (DEPRECATED_SYMBOL_NAME (sym), MIPS_EFI_SYMBOL_NAME) == 0)
d690 1
a690 1
  if (objfile->ei.deprecated_entry_file_lowpc != INVALID_ENTRY_LOWPC)
d692 2
a693 2
      objfile->ei.deprecated_entry_file_lowpc += ANOFFSET (delta, SECT_OFF_TEXT (objfile));
      objfile->ei.deprecated_entry_file_highpc += ANOFFSET (delta, SECT_OFF_TEXT (objfile));
d777 1
a777 1
    if (ofp->minimal_symbol_count > 0)
d903 1
a903 1
static void *
d906 1
a906 1
  void *md;
d909 1
a909 1
  md = mmalloc_attach (fd, 0);
d922 1
a922 1
	  md = mmalloc_attach (fd, mapto);
d934 1
a934 1
	      md = mmalloc_attach (fd, mapto);
d937 1
a937 1
		  mmalloc_setkey (md, 1, mapto);
d947 5
a951 5
/* Returns a section whose range includes PC and SECTION, or NULL if
   none found.  Note the distinction between the return type, struct
   obj_section (which is defined in gdb), and the input type "struct
   bfd_section" (which is a bfd-defined data type).  The obj_section
   contains a pointer to the "struct bfd_section".  */
d954 1
a954 1
find_pc_sect_section (CORE_ADDR pc, struct bfd_section *section)
d991 1
a991 1
	    && strcmp (s->the_bfd_section->name, ".plt") == 0);
d1001 1
a1001 1
  int i;
d1007 1
a1007 1
    if (objfile->import_list[i] && DEPRECATED_STREQ (name, objfile->import_list[i]))
a1010 48


/* Keep a registry of per-objfile data-pointers required by other GDB
   modules.  */

struct objfile_data
{
  unsigned index;
};

struct objfile_data_registration
{
  struct objfile_data *data;
  struct objfile_data_registration *next;
};
  
struct objfile_data_registry
{
  struct objfile_data_registration *registrations;
  unsigned num_registrations;
};

static struct objfile_data_registry objfile_data_registry = { NULL, 0 };

const struct objfile_data *
register_objfile_data (void)
{
  struct objfile_data_registration **curr;

  /* Append new registration.  */
  for (curr = &objfile_data_registry.registrations;
       *curr != NULL; curr = &(*curr)->next);

  *curr = XMALLOC (struct objfile_data_registration);
  (*curr)->next = NULL;
  (*curr)->data = XMALLOC (struct objfile_data);
  (*curr)->data->index = objfile_data_registry.num_registrations++;

  return (*curr)->data;
}

static void
objfile_alloc_data (struct objfile *objfile)
{
  gdb_assert (objfile->data == NULL);
  objfile->num_data = objfile_data_registry.num_registrations;
  objfile->data = XCALLOC (objfile->num_data, void *);
}
a1011 29
static void
objfile_free_data (struct objfile *objfile)
{
  gdb_assert (objfile->data != NULL);
  xfree (objfile->data);
  objfile->data = NULL;
}

void
clear_objfile_data (struct objfile *objfile)
{
  gdb_assert (objfile->data != NULL);
  memset (objfile->data, 0, objfile->num_data * sizeof (void *));
}

void
set_objfile_data (struct objfile *objfile, const struct objfile_data *data,
		  void *value)
{
  gdb_assert (data->index < objfile->num_data);
  objfile->data[data->index] = value;
}

void *
objfile_data (struct objfile *objfile, const struct objfile_data *data)
{
  gdb_assert (data->index < objfile->num_data);
  return objfile->data[data->index];
}
@


1.22.10.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d4 1
a4 1
   2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d51 12
d74 2
d110 1
a110 1
  obstack_grow (&objfile->objfile_obstack, (char *) &section, sizeof (section));
d136 1
a136 1
     can't free the old one (it's in the objfile_obstack).  So we just
d142 1
a142 1
    obstack_finish (&objfile->objfile_obstack);
d153 4
a156 2
   requests for specific operations.  Other bits like OBJF_SHARED are
   simply copied through to the new objfile flags member. */
d173 113
d297 3
a299 1
      obstack_specify_allocation (&objfile->objfile_obstack, 0, 0, xmalloc,
d301 4
d371 1
a371 1
   OBJFILE->objfile_obstack; otherwise, just initialize
d378 1
a378 1
                         obstack_alloc (&objfile->objfile_obstack,
d474 2
a475 2
   that as much as possible is allocated on the objfile_obstack 
   so that the memory can be efficiently freed.
d548 18
a565 1
  /* The last thing we do is free the objfile struct itself. */
d567 6
a572 2
  objfile_free_data (objfile);
  if (objfile->name != NULL)
d574 19
a592 1
      xmfree (objfile->md, objfile->name);
a593 12
  if (objfile->global_psymbols.list)
    xmfree (objfile->md, objfile->global_psymbols.list);
  if (objfile->static_psymbols.list)
    xmfree (objfile->md, objfile->static_psymbols.list);
  /* Free the obstacks for non-reusable objfiles */
  bcache_xfree (objfile->psymbol_cache);
  bcache_xfree (objfile->macro_cache);
  if (objfile->demangled_names_hash)
    htab_delete (objfile->demangled_names_hash);
  obstack_free (&objfile->objfile_obstack, 0);
  xmfree (objfile->md, objfile);
  objfile = NULL;
d884 162
@


1.22.6.1
log
@2003-02-04  David Carlton  <carlton@@math.stanford.edu>

	* objfiles.c (allocate_objfile): Always set name.  Add comment at
	start of function.
	* jv-lang.c (get_dynamics_objfile): Add comment.
@
text
@a151 9
/* NOTE: carlton/2003-02-04: This function is called with args NULL, 0
   by jv-lang.c, to create an artificial objfile used to hold
   information about dynamically-loaded Java classes.  Unfortunately,
   that branch of this function doesn't get tested very frequently, so
   it's prone to breakage.  (E.g. at one time the name was set to NULL
   in that situation, which broke a loop over all names in the dynamic
   library loader.)  If you change this function, please try to leave
   things in a consistent state even if abfd is NULL.  */

a306 4
    }
  else
    {
      objfile->name = "<<anonymous objfile>>";
@


1.22.12.1
log
@Add support for executables whose debug info has been separated
out into a separate file, leaving only a link behind.
* objfiles.h (struct objfile): New fields: separate_debug_objfile
and separate_debug_objfile_backlink.
(put_objfile_before): New declaration.
* symfile.c (symbol_file_add_with_addrs_or_offsets): If this
objfile has its debug info in a separate file, read that,
too. Save the addrs argument, so we can use it again to read the
separated debug info; syms_from_objfile modifies the table we pass
it.
(reread_symbols): After re-reading an objfile, call
reread_separate_symbols to refresh its separate debug info
objfile, if it has one.
(reread_separate_symbols, find_separate_debug_file,
get_debug_link_info, separate_debug_file_exists): New functions.
(debug_file_directory): New global var.
(_initialize_symfile): Initialize debug_file_directory, and
provide the new `set debug-file-directory' command to let the user
change it.
* objfiles.c (free_objfile): If this objfile has its debug info in
a separate objfile, free that one too.  If this is itself a
separate debug info objfile, clear our parent's backlink.
(put_objfile_before): New function.
* utils.c (calc_crc32): New function.
* defs.h (calc_crc32): New declaration.
* configure.in: Handle --with-separate-debug-dir config option.
* acinclude.m4 (AC_DEFINE_DIR): New macro.
* acconfig.h (DEBUGDIR): New macro.
* configure, aclocal.m4, config.in: Regenerated.
@
text
@a335 24
/* Put one object file before a specified on in the global list.
   This can be used to make sure an object file is destroyed before
   another when using ALL_OBJFILES_SAFE to free all objfiles. */
void
put_objfile_before (struct objfile *objfile, struct objfile *before_this)
{
  struct objfile **objp;

  unlink_objfile (objfile);
  
  for (objp = &object_files; *objp != NULL; objp = &((*objp)->next))
    {
      if (*objp == before_this)
	{
	  objfile->next = *objp;
	  *objp = objfile;
	  return;
	}
    }
  
  internal_error (__FILE__, __LINE__,
		  "put_objfile_before: before objfile not in list");
}

a407 12
  if (objfile->separate_debug_objfile)
    {
      free_objfile (objfile->separate_debug_objfile);
    }
  
  if (objfile->separate_debug_objfile_backlink)
    {
      /* We freed the separate debug file, make sure the base objfile
	 doesn't reference it.  */
      objfile->separate_debug_objfile_backlink->separate_debug_objfile = NULL;
    }
  
@


1.22.12.2
log
@Back initial version of Alex Larsson's change off the branch, so we
can revise it.
@
text
@d336 24
d432 12
@


1.22.8.1
log
@2002-09-23  David Carlton  <carlton@@math.stanford.edu>

	* dictionary.c (struct dict_vtbl): 'add_symbol' field.
	(add_symbol_generic): New function.
	(free_obstack): New function.
	(dict_create_hashed): New function.
	(lookup_hashed): New function.
	(iterator_first_hashed): New function.
	(iterator_hashed_advance): New function.
	(iterator_next_hashed): New function.
	* dictionary.h: A few more declarations.
	* mdebugread.c (parse_symbol): Use dict_iterator when finding
	parameters.
	* Makefile.in (valops.o): Depend on dictionary_h.
	* valops.c (value_of_this): Check empty block via dict_empty.
	#include "dictionary.h"
	* symfile.c (free_named_symtabs): Check empty block via dict_empty.
	* dictionary.h: Declare dict_empty.
	* symmisc.c (dump_symtab): Don't print out number of
	symbols/buckets.
	* printcmd.c (print_frame_args): Delete assertion that block isn't
	a hashtable.
	* symmisc.c (free_symtab_block): Update to use dictionary
	methods.
	* symtab.h (struct symtab): Comment on free_contents.
	* jv-lang.c (get_java_class_symtab): Set class_symtab->free_code.
	* mdebugread.c (add_symbol): Delete 'nsyms' variable.
	(fixup_sigtramp): Add symbol via dict_add_symbol_block.
	* Makefile.in (mi-cmd-stack.o): Depend on dictionary_h.
	* ada-lang.c (symtab_for_sym): Update uses of ALL_BLOCK_SYMBOLS.
	(ada_add_block_symbols): Ditto.
	(debug_print_block): Ditto.
	(fill_in_ada_prototype): Ditto.
	* breakpoint.c (get_catch_sals): Ditto.
	* coffread.c (patch_opaque_types): Ditto.
	* tracepoint.c (add_local_symbols): Ditto.
	(scope_info): Ditto.
	* symtab.c (find_pc_sect_symtab): Ditto.
	(search_symbols): Ditto.
	(make_symbol_completion_list): Ditto.
	(find_addr_symbol): Ditto.
	(make_file_symbol_completion_list): Ditto.
	(make_symbol_overload_list): Ditto.
	* symmisc.c (dump_symtab): Ditto.
	* stack.c (print_block_frame_locals): Ditto.
	(print_block_frame_labels): Ditto.
	(print_frame_arg_vars): Ditto.
	* printcmd.c (print_frame_args): Ditto.
	* objfiles.c (objfile_relocate): Ditto.
	* mdebugread.c (mylookup_symbol): Ditto.
	* Makefile.in (ada-lang.o): Depend on dictionary_h.
	* Makefile.in (tracepoint.o): Ditto.
	* Makefile.in (symmisc.o): Ditto.
	* Makefile.in (stack.o): Ditto.
	* Makefile.in (printcmd.o): Ditto.
	* Makefile.in (objfiles.o): Ditto.
	* Makefile.in (coffread.o): Ditto.
	* Makefile.in (breakpoint.o): Ditto.
	* ada-lang.c: #include "dictionary.h"
	* tracepoint.c: Ditto.
	* symmisc.c: Ditto.
	* stack.c: Ditto.
	* printcmd.c: Ditto.
	* objfiles.c: Ditto.
	* coffread.c: Ditto.
	* breakpoint.c: Ditto.
	* symtab.h: Comment out ALL_BLOCK_SYMBOLS.  (Moved to
	dictionary.h.)
	* dictionary.c: Dict_iterator accessor macros.
	(struct dict_vtbl): Add iterator_first, iterator_next.
	(dict_iterator_first): New function.
	(dict_iterator_next): New function.
	(iterator_first_block): New function.
	(iterator_next_block): New function.
	(iterator_block_hashed_advance): New function.
	* dictionary.h: Add dict_iterator stuff.
	* Makefile.in (symtab.o): Depend on dictionary_h.
	* symtab.c: #include "dictionary.h"
	* dictionary.c: Move down #include "dictionary.h", for now...
	(free_block): Rename from dict_free_block.
	(struct dict_vtbl): Add LOOKUP member.
	(dict_lookup): New function.
	(lookup_block): New function.
	* dictionary.h: Declare dict_lookup.
	* symtab.c (lookup_block_symbol): Use dict_lookup.

2002-09-23  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c (list_args_or_locals): Update use of
	ALL_BLOCK_SYMBOLS.
	#include "dictionary.h"
@
text
@a43 1
#include "dictionary.h"
d572 1
a572 1
	  struct dict_iterator iter;
d578 1
a578 1
	  ALL_BLOCK_SYMBOLS (b, iter, sym)
@


1.22.8.2
log
@2002-10-18  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (block_h): New variable.
	Updated dependencies to reflect it.
	* parse.c (parse_exp_1): Use BLOCK_START.
	#include "block.h"
	* p-exp.tab.c: Regenerated.
	* m2-exp.tab.c: Ditto.
	* jv-exp.tab.c: Ditto.
	* f-exp.tab.c: Ditto.
	* c-exp.tab.c: Ditto.
	* ada-exp.tab.c: Ditto.
	* ada-lang.c: #include "block.h"
	* p-exp.y: Ditto.
	* objc-exp.y: Ditto.
	* m2-exp.y: Ditto.
	* jv-exp.y: Ditto.
	* f-exp.y: Ditto.
	* c-exp.y: Ditto.
	* ada-exp.y: Ditto.
	* values.c: Ditto.
	* valops.c: Ditto.
	* tracepoint.c: Ditto.
	* symtab.c: Ditto.
	* symmisc.c: Ditto.
	* symfile.c: Ditto.
	* stack.c: Ditto.
	* printcmd.c: Ditto.
	* objfiles.c: Ditto.
	* objc-lang.c: Ditto.
	* nlmread.c: Ditto.
	* mips-tdep.c: Ditto.
	* mdebugread.c: Ditto.
	* linespec.c: Ditto.
	* jv-lang.c: Ditto.
	* infcmd.c: Ditto.
	* f-valprint.c: Ditto.
	* findvar.c: Ditto.
	* expprint.c: Ditto.
	* coffread.c: Ditto.
	* buildsym.c: Ditto.
	* breakpoint.c: Ditto.
	* blockframe.c: Ditto.
	* ax-gdb.c: Ditto.
	* alpha-tdep.c: Ditto.
	* block.h: New file.
	* symtab.h: Moved struct block, struct blockvector, and related
	macros and function declarations to block.h.
	* dwarf2read.c (process_die): Set processing_has_namespace_info if
	we run into DW_TAG_namespace, DW_TAG_imported_declaration, or
	DW_TAG_imported_module.
	New variable current_namespace.
	(psymtab_to_symtab_1): Set current_namespace to "".
	(dwarf2_name): New function.
	(dwarf2_add_member_fn): Get name via dwarf2_name.
	(read_typedef): Ditto.
	(read_file_scope): Ditto.
	(dwarf2_add_field): Ditto.
	(read_structure_scope): Ditto.
	(read_enumeration): Ditto.
	(dwarf2_extension): New function.
	(read_namespace): Set current_namespace correctly; also, if we're
	entering an anonymous namespace, add an appropriate using
	directive.
	* buildsym.c (start_symtab): Reset processing_has_namespace_info
	to 0.
	(add_symbol_to_list): Only scan for anonymous namespaces if
	!processing_has_namespace_info.
	* buildsym.h: Add new flag processing_has_namespace_info.

2002-10-18  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: #include "block.h"
@
text
@a30 1
#include "block.h"
@


1.22.8.3
log
@2003-01-10  David Carlton  <carlton@@math.stanford.edu>

	* objfiles.c (allocate_objfile): Always set name.
	* dwarf2read.c (scan_partial_symbols): Don't call
	add_partial_structure on unions.
	(add_partial_structure): Look for enclosing namespace names.
	(read_structure_scope): Look enclosing namespace/class names.
	(new_symbol): For C++ structures, always grab the name from the
	type's name.

2003-01-10  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/templates.exp (do_tests): Update some of the regexps to
	be a bit more generous.
@
text
@a309 4
  else
    {
      objfile->name = "<<anonymous objfile>>";
    }
@


1.22.8.4
log
@2003-01-27  David Carlton  <carlton@@math.stanford.edu>

	* objfiles.h: Add comments about objfile->msymbols being NULL.
	* objfiles.c (objfile_relocate): Enclose ALL_OBJFILE_MSYMBOLS in
	guard.
	* i386-linux-tdep.c (find_minsym_and_objfile): Call ALL_MSYMBOLS
	instead of ALL_OBJFILES and ALL_OBJFILE_MSYMBOLS.
	* arm-linux-tdep.c (find_minsym_and_objfile): Ditto.
@
text
@d647 6
a652 9
  if (objfile->msymbols != NULL)
    {
      struct minimal_symbol *msym;
      ALL_OBJFILE_MSYMBOLS (objfile, msym)
	if (SYMBOL_SECTION (msym) >= 0)
	  SYMBOL_VALUE_ADDRESS (msym)
	    += ANOFFSET (delta, SYMBOL_SECTION (msym));
    }

@


1.22.8.5
log
@2003-01-31  David Carlton  <carlton@@math.stanford.edu>

	From Jim Blandy  <jimb@@redhat.com>:

	Use a single, consistent representation for an empty minimal
	symbol table in an objfile.
	* objfiles.c (terminate_minimal_symbol_table): New function.
	(allocate_objfile): Call it.
	* objfiles.h (terminate_minimal_symbol_table): New declaration.
	(ALL_MSYMBOLS): No need to test whether (objfile)->msymbols is
	non-NULL.
	* minsyms.c (lookup_minimal_symbol_by_pc_section): To see whether
	objfile has minimal symbols, compare minimal_symbol_count to zero,
	instead of comparing msymbols with NULL.
	* objfiles.c (have_minimal_symbols): Same.
	* solib-sunos.c (solib_add_common_symbols): Call
	terminate_minimal_symbol_table.
	* symfile.c (reread_symbols): Same.

	* objfiles.h: Revert patch from 2003-01-27, to be replaced by
	similar patch from Jim Blandy.
	* objfiles.c (objfile_relocate): Ditto.
	* i386-linux-tdep.c (find_minsym_and_objfile): Ditto.
	* arm-linux-tdep.c (find_minsym_and_objfile): Ditto.
	* gdbtypes.h: Delete INTEGER_COERCION_BADNESS,
	FLOAT_COERCION_BADNESS.
	* gdbtypes.c (rank_one_type): Replace all uses of
	INTEGER_COERCION_BADNESS by INTEGER_CONVERSION_BADNESS.
	* valops.c (find_overload_match): Call cp_func_name.
	* cp-support.h: Declare cp_func_name.
	* cp-support.c (cp_func_name): New function.

2003-01-30  David Carlton  <carlton@@math.stanford.edu>

	* valops.c (find_overload_match): Move code into
	find_oload_champ_namespace.
	(find_oload_champ_namespace): New function, which immediately gets
	eviscerated and turned into a call to
	find_oload_champ_namespace_loop.
	(find_oload_champ_namespace_loop): New function.
	* symtab.c (make_symbol_overload_list): Move entire body into
	make_symbol_overload_list_qualified.
	(make_symbol_overload_list_qualified): New.
	(read_in_psymtabs): New.
	(make_symbol_overload_list_qualified): Rewrite.
	(make_symbol_overload_list_using): New.
	(lookup_symbol_namespace): Use alloca, not xmalloc.
	(make_symbol_overload_list): Put some memory management stuff back
	in.
@
text
@a285 2

      terminate_minimal_symbol_table (objfile);
a341 25
/* Create the terminating entry of OBJFILE's minimal symbol table.
   If OBJFILE->msymbols is zero, allocate a single entry from
   OBJFILE->symbol_obstack; otherwise, just initialize
   OBJFILE->msymbols[OBJFILE->minimal_symbol_count].  */
void
terminate_minimal_symbol_table (struct objfile *objfile)
{
  if (! objfile->msymbols)
    objfile->msymbols = ((struct minimal_symbol *)
                         obstack_alloc (&objfile->symbol_obstack,
                                        sizeof (objfile->msymbols[0])));

  {
    struct minimal_symbol *m
      = &objfile->msymbols[objfile->minimal_symbol_count];

    memset (m, 0, sizeof (*m));
    SYMBOL_NAME (m) = NULL;
    SYMBOL_VALUE_ADDRESS (m) = 0;
    MSYMBOL_INFO (m) = NULL;
    MSYMBOL_TYPE (m) = mst_unknown;
    SYMBOL_INIT_LANGUAGE_SPECIFIC (m, language_unknown);
  }
}

d647 9
a655 6
  {
    struct minimal_symbol *msym;
    ALL_OBJFILE_MSYMBOLS (objfile, msym)
      if (SYMBOL_SECTION (msym) >= 0)
      SYMBOL_VALUE_ADDRESS (msym) += ANOFFSET (delta, SYMBOL_SECTION (msym));
  }
d786 1
a786 1
    if (ofp->minimal_symbol_count > 0)
@


1.22.8.6
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d4 1
a4 1
   2001, 2002, 2003 Free Software Foundation, Inc.
a42 1
#include "hashtab.h"
d57 1
a57 1
static void *map_to_file (int);
d61 1
a61 1
static void add_to_objfile_sections (bfd *, sec_ptr, void *);
d87 1
a87 1
add_to_objfile_sections (bfd *abfd, sec_ptr asect, void *objfile_p_char)
a153 9
/* NOTE: carlton/2003-02-04: This function is called with args NULL, 0
   by jv-lang.c, to create an artificial objfile used to hold
   information about dynamically-loaded Java classes.  Unfortunately,
   that branch of this function doesn't get tested very frequently, so
   it's prone to breakage.  (E.g. at one time the name was set to NULL
   in that situation, which broke a loop over all names in the dynamic
   library loader.)  If you change this function, please try to leave
   things in a consistent state even if abfd is NULL.  */

d183 1
a183 1
	  void *md;
a195 5
	      if (objfile->demangled_names_hash)
		htab_set_functions_ex
		  (objfile->demangled_names_hash, htab_hash_string,
		   (int (*) (const void *, const void *)) streq, NULL,
		   objfile->md, xmcalloc, xmfree);
a343 1

a368 25

/* Put one object file before a specified on in the global list.
   This can be used to make sure an object file is destroyed before
   another when using ALL_OBJFILES_SAFE to free all objfiles. */
void
put_objfile_before (struct objfile *objfile, struct objfile *before_this)
{
  struct objfile **objp;

  unlink_objfile (objfile);
  
  for (objp = &object_files; *objp != NULL; objp = &((*objp)->next))
    {
      if (*objp == before_this)
	{
	  objfile->next = *objp;
	  *objp = objfile;
	  return;
	}
    }
  
  internal_error (__FILE__, __LINE__,
		  "put_objfile_before: before objfile not in list");
}

a440 12
  if (objfile->separate_debug_objfile)
    {
      free_objfile (objfile->separate_debug_objfile);
    }
  
  if (objfile->separate_debug_objfile_backlink)
    {
      /* We freed the separate debug file, make sure the base objfile
	 doesn't reference it.  */
      objfile->separate_debug_objfile_backlink->separate_debug_objfile = NULL;
    }
  
a521 2
      if (objfile->demangled_names_hash)
	htab_delete (objfile->demangled_names_hash);
d936 1
a936 1
static void *
d939 1
a939 1
  void *md;
d942 1
a942 1
  md = mmalloc_attach (fd, 0);
d955 1
a955 1
	  md = mmalloc_attach (fd, mapto);
d967 1
a967 1
	      md = mmalloc_attach (fd, mapto);
d970 1
a970 1
		  mmalloc_setkey (md, 1, mapto);
@


1.22.8.7
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d31 1
a45 1
#include "block.h"
d377 1
a377 1
    DEPRECATED_SYMBOL_NAME (m) = NULL;
d687 1
a687 1
		       && strcmp (DEPRECATED_SYMBOL_NAME (sym), MIPS_EFI_SYMBOL_NAME) == 0)
@


1.22.8.8
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@d329 1
a329 1
      objfile->name = mstrsave (objfile->md, "<<anonymous objfile>>");
@


1.22.8.9
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d671 1
a671 1
	         any symbols in STRUCT_DOMAIN or UNDEF_DOMAIN.
d686 1
a686 1
		       && SYMBOL_DOMAIN (sym) == LABEL_DOMAIN
@


1.22.8.10
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d617 1
a617 2
    ((struct section_offsets *) 
     alloca (SIZEOF_N_SECTION_OFFSETS (objfile->num_sections)));
@


1.22.8.11
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* dwarf2read.c (add_partial_symbol): Add 'objfile' argument to
	call to cp_check_possible_namespace_symbols.
	(add_partial_namespace): Add partial symbol instead of calling
	cp_check_namespace_symbol.
	(read_namespace): Add symbol associated to namespace.
	(new_symbol): Handle DW_TAG_namespace.
	* cp-support.h: Delete declaration of cp_check_namespace_symbol;
	add 'objfile' argument to declaration of
	cp_check_possible_namespace_symbols.
	* cp-namespace.c: Delete variables namespace_block,
	possible_namespace_block, namespace_objfile.
	Delete functions get_namespace_block, get_namespace_objfile,
	cp_check_namespace_symbol, check_namespace_symbol_block,
	lookup_namespace_symbol.
	(lookup_symbol_file): Delete call to lookup_namespace_symbol;
	tweak call to lookup_possible_namespace_symbol.
	(initialize_namespace_symtab): Rename from
	initialize_namespace_blocks; add 'objfile' argument, don't do
	anything special with global block.
	(get_possible_namespace_block): Add 'objfile' argument.
	(check_possible_namespace_symbols_loop)
	(cp_check_possible_namespace_symbols): Ditto.
	(free_namespace_block): Rename from free_namespace_blocks; don't
	do anything special with global block.
	(check_one_possible_namespace_symbol): Add 'objfile' argument, and
	inline call to check_namespace_symbol_block.
	(lookup_possible_namespace_symbol): Add 'symtab' argument, loop
	over all objfiles.
	(maintenance_cplus_namespace): Only have possible symbols; add
	loop over objfiles.
	(_initialize_cp_namespace): Tweak doc string.
	* objfiles.h: Add opaque declaration of struct symtab.
	(struct objfile): Add cp_namespace_symtab member.
	* objfiles.c (allocate_objfile): Set
	objfile->cp_namespace_symtab.

2003-06-27  David Carlton  <carlton@@kealia.com>

	* carlton_runtest (FASTTESTS): Add gdb.c++/pr-1210.exp.
	* gdb.c++/namespace.exp: Delete test for maint cp namespace.
	* gdb.c++/maint.exp (test_help): Tweak output for 'help maint cp
	namespace'.
	(test_namespace): Tweak comment.
@
text
@d335 4
a338 8
  objfile->sect_index_text = -1;
  objfile->sect_index_data = -1;
  objfile->sect_index_bss = -1;
  objfile->sect_index_rodata = -1;

  /* We don't yet have a C++-specific namespace symtab.  */

  objfile->cp_namespace_symtab = NULL;
@


1.22.8.12
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@a36 1
#include "gdb_assert.h"
a63 3
static void objfile_alloc_data (struct objfile *objfile);
static void objfile_free_data (struct objfile *objfile);

a304 2
  objfile_alloc_data (objfile);

a567 1
      objfile_free_data (objfile);
d783 1
a783 1
  if (objfile->ei.deprecated_entry_file_lowpc != INVALID_ENTRY_LOWPC)
d785 2
a786 2
      objfile->ei.deprecated_entry_file_lowpc += ANOFFSET (delta, SECT_OFF_TEXT (objfile));
      objfile->ei.deprecated_entry_file_highpc += ANOFFSET (delta, SECT_OFF_TEXT (objfile));
d1094 1
a1094 1
  int i;
a1103 32


/* Keep a registry of per-objfile data-pointers required by other GDB
   modules.  */

struct objfile_data
{
  unsigned index;
};

struct objfile_data_registration
{
  struct objfile_data *data;
  struct objfile_data_registration *next;
};
  
struct objfile_data_registry
{
  struct objfile_data_registration *registrations;
  unsigned num_registrations;
};

static struct objfile_data_registry objfile_data_registry = { NULL, 0 };

const struct objfile_data *
register_objfile_data (void)
{
  struct objfile_data_registration **curr;

  /* Append new registration.  */
  for (curr = &objfile_data_registry.registrations;
       *curr != NULL; curr = &(*curr)->next);
a1104 38
  *curr = XMALLOC (struct objfile_data_registration);
  (*curr)->next = NULL;
  (*curr)->data = XMALLOC (struct objfile_data);
  (*curr)->data->index = objfile_data_registry.num_registrations++;

  return (*curr)->data;
}

static void
objfile_alloc_data (struct objfile *objfile)
{
  gdb_assert (objfile->data == NULL);
  objfile->num_data = objfile_data_registry.num_registrations;
  objfile->data = XCALLOC (objfile->num_data, void *);
}

static void
objfile_free_data (struct objfile *objfile)
{
  gdb_assert (objfile->data != NULL);
  xfree (objfile->data);
  objfile->data = NULL;
}

void
set_objfile_data (struct objfile *objfile, const struct objfile_data *data,
		  void *value)
{
  gdb_assert (data->index < objfile->num_data);
  objfile->data[data->index] = value;
}

void *
objfile_data (struct objfile *objfile, const struct objfile_data *data)
{
  gdb_assert (data->index < objfile->num_data);
  return objfile->data[data->index];
}
@


1.22.8.13
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d63 2
d92 1
a92 2
add_to_objfile_sections (struct bfd *abfd, struct bfd_section *asect,
			 void *objfile_p_char)
d1047 5
a1051 5
/* Returns a section whose range includes PC and SECTION, or NULL if
   none found.  Note the distinction between the return type, struct
   obj_section (which is defined in gdb), and the input type "struct
   bfd_section" (which is a bfd-defined data type).  The obj_section
   contains a pointer to the "struct bfd_section".  */
d1054 1
a1054 1
find_pc_sect_section (CORE_ADDR pc, struct bfd_section *section)
d1091 1
a1091 1
	    && strcmp (s->the_bfd_section->name, ".plt") == 0);
a1165 7
}

void
clear_objfile_data (struct objfile *objfile)
{
  gdb_assert (objfile->data != NULL);
  memset (objfile->data, 0, objfile->num_data * sizeof (void *));
@


1.22.8.14
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@a388 1
    MSYMBOL_SIZE (m) = 0;
d1106 1
a1106 1
    if (objfile->import_list[i] && DEPRECATED_STREQ (name, objfile->import_list[i]))
@


1.22.8.15
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d51 12
d74 2
d153 4
a156 2
   requests for specific operations.  Other bits like OBJF_SHARED are
   simply copied through to the new objfile flags member. */
d173 113
d303 1
d548 23
a570 1
  /* The last thing we do is free the objfile struct itself. */
d572 1
a572 2
  objfile_free_data (objfile);
  if (objfile->name != NULL)
d574 19
a592 1
      xmfree (objfile->md, objfile->name);
a593 14
  if (objfile->global_psymbols.list)
    xmfree (objfile->md, objfile->global_psymbols.list);
  if (objfile->static_psymbols.list)
    xmfree (objfile->md, objfile->static_psymbols.list);
  /* Free the obstacks for non-reusable objfiles */
  bcache_xfree (objfile->psymbol_cache);
  bcache_xfree (objfile->macro_cache);
  if (objfile->demangled_names_hash)
    htab_delete (objfile->demangled_names_hash);
  obstack_free (&objfile->psymbol_obstack, 0);
  obstack_free (&objfile->symbol_obstack, 0);
  obstack_free (&objfile->type_obstack, 0);
  xmfree (objfile->md, objfile);
  objfile = NULL;
d884 162
@


1.21
log
@* bcache.h: Update copyright.
(struct bstring, struct bcache): Move definition to "bcache.c".
Replaced by opaque declaration.
(bcache_xfree): Replace free_bcache.
(bcache_xmalloc, bcache_memory_used): Declare.

* bcache.c: Update copyright.
(struct bstring, struct bcache): Moved to here from "bcache.h".
Update comments.
(bcache_xmalloc, bcache_memory_used): New functions.
(bcache_xfree): Replace function free_bcache.

* Makefile.in (objfiles.o): Add $(bcache_h).
(objfiles_h): Remove $(bcache_h).
(symfile.o): Add $(bcache_h).

* symmisc.c: Update copyright.
(print_symbol_bcache_statistics): Pass psymbol_cache by value.
(print_objfile_statistics): Use bcache_memory_used.

* symfile.c: Include "bcache.h".
(reread_symbols): Use bcache_xfree.
(reread_symbols): Use bcache_xmalloc and bcache_xfree.
(add_psymbol_to_list): Pass psymbol_cache by value.
(add_psymbol_with_dem_name_to_list): Ditto.

* objfiles.h: Update copyright.
(struct bcache): Declare opaque.  Do not include "bcache.h".
(struct objfile): Change psymbol_cache and macro_cache to ``struct
bcache'' pointers.
* dwarf2read.c (macro_start_file): Pass macro_cache by value.

* objfiles.c: Include "bcache.h".  Update copyright.
(allocate_objfile): Use bcache_xmalloc to create psymbol_cache and
macro_cache.
(free_objfile): Use bcache_xfree.
@
text
@d40 1
a40 1
#include "obstack.h"
@


1.20
log
@Add macro structures to GDB's symbol tables.  Nobody puts anything
in them yet.
* symtab.h (struct symtab): New member: `macro_table'.
* buildsym.h (pending_macros): New global variable.
* buildsym.c: #include "macrotab.h".
(buildsym_init): Initialize `pending_macros'.
(end_symtab): If we found macro information while reading a CU's
debugging info, do build a symtab structure for it.  Make the
symtab point to the macro information, and clear the
`pending_macros' pointer which held it while we were reading the
debug info.
(really_free_pendings): Free any pending macro table.
* objfiles.h (struct objfile): New member: `macro_cache'.
* objfiles.c (allocate_objfile): Set allocate and free functions
for the macro cache's objstack.
(free_objfile): Empty the macro cache's obstack.
* symfile.c (reread_symbols): Empty the macro cache's obstack, and
set new allocate and free functions for it.
* solib-sunos.c (allocate_rt_common_objfile): Set allocate and
free functions for the macro cache's objstack.  (Why is this
function building its own objfile?)
* symmisc.c (print_objfile_statistics): Print statistics on the
macro bcache.
* Makefile.in: Note that buildsym.o depends on macrotab.h.
@
text
@d2 4
a5 2
   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d35 1
d275 2
a276 4
      obstack_specify_allocation (&objfile->psymbol_cache.cache, 0, 0,
				  xmalloc, xfree);
      obstack_specify_allocation (&objfile->macro_cache.cache, 0, 0,
				  xmalloc, xfree);
d487 2
a488 2
      free_bcache (&objfile->psymbol_cache);
      free_bcache (&objfile->macro_cache);
@


1.20.4.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d2 2
a3 4

   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001, 2002 Free Software Foundation, Inc.

a32 1
#include "bcache.h"
d272 4
a275 2
      objfile->psymbol_cache = bcache_xmalloc ();
      objfile->macro_cache = bcache_xmalloc ();
d486 2
a487 2
      bcache_xfree (objfile->psymbol_cache);
      bcache_xfree (objfile->macro_cache);
@


1.20.4.2
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d40 1
a40 1
#include "gdb_obstack.h"
@


1.19
log
@Eliminate global #include of "mmalloc.h".
@
text
@d193 2
d225 3
d274 2
d487 1
@


1.19.4.1
log
@Add macro structures to GDB's symbol tables.  Nobody puts anything
in them yet.
* symtab.h (struct symtab): New member: `macro_table'.
* buildsym.h (pending_macros): New global variable.
* buildsym.c: #include "macrotab.h".
(buildsym_init): Initialize `pending_macros'.
(end_symtab): If we found macro information while reading a CU's
debugging info, do build a symtab structure for it.  Make the
symtab point to the macro information, and clear the
`pending_macros' pointer which held it while we were reading the
debug info.
(really_free_pendings): Free any pending macro table.
* objfiles.h (struct objfile): New member: `macro_cache'.
* objfiles.c (allocate_objfile): Set allocate and free functions
for the macro cache's objstack.
(free_objfile): Empty the macro cache's obstack.
* symfile.c (reread_symbols): Empty the macro cache's obstack, and
set new allocate and free functions for it.
* solib-sunos.c (allocate_rt_common_objfile): Set allocate and
free functions for the macro cache's objstack.  (Why is this
function building its own objfile?)
* symmisc.c (print_objfile_statistics): Print statistics on the
macro bcache.
* Makefile.in: Note that buildsym.o depends on macrotab.h.
@
text
@a192 2
	      obstack_chunkfun (&objfile->macro_cache.cache, xmmalloc);
	      obstack_freefun (&objfile->macro_cache.cache, xmfree);
a222 3
	      obstack_specify_allocation_with_arg (&objfile->macro_cache.cache,
						   0, 0, xmmalloc, xmfree,
						   objfile->md);
a268 2
      obstack_specify_allocation (&objfile->macro_cache.cache, 0, 0,
				  xmalloc, xfree);
a479 1
      free_bcache (&objfile->macro_cache);
@


1.18
log
@mfree() -> xmfree().
@
text
@d46 2
@


1.17
log
@2001-10-12  Daniel Jacobowitz  <drow@@mvista.com>

        * symtab.h (struct block): (ALL_BLOCK_SYMBOLS): New macro.

        * symtab.c (find_pc_sect_symtab): Use ALL_BLOCK_SYMBOLS.
        (make_symbol_completion_list): Likewise.
        (make_symbol_overload_list): Likewise.
        * buildsym.c (finish_block): Likewise.
        * breakpoint.c (get_catch_sals):  Likewise.
        * mdebugread.c (mylookup_symbol): Likewise.
        * objfiles.c (objfile_relocate): Likewise.
        * printcmd.c (print_frame_args): Likewise.
        * stack.c (print_block_frame_locals): Likewise.
        (print_block_frame_labels): Likewise.
        (print_frame_arg_vars): Likewise.
        * symmisc.c (dump_symtab): Likewise.
        * tracepoint.c (add_local_symbols): Likewise.
        (scope_info): Likewise.

2001-10-12  Daniel Jacobowitz  <drow@@mvista.com>

        * mi-cmd-stack.c (list_args_or_locals): Use ALL_BLOCK_SYMBOLS.

2001-10-12  Daniel Jacobowitz  <drow@@mvista.com>

        * generic/gdbtk-cmds.c (gdb_listfuncs): Use ALL_BLOCK_SYMBOLS.
        * generic/gdbtk-stack.c (gdb_block_vars): Likewise.
        (gdb_get_blocks): Likewise.
        (gdb_get_vars_command): Likewise.
5~
@
text
@d190 1
a190 1
	      obstack_freefun (&objfile->psymbol_cache.cache, mfree);
d192 1
a192 1
	      obstack_freefun (&objfile->psymbol_obstack, mfree);
d194 1
a194 1
	      obstack_freefun (&objfile->symbol_obstack, mfree);
d196 1
a196 1
	      obstack_freefun (&objfile->type_obstack, mfree);
d219 1
a219 1
						   0, 0, xmmalloc, mfree,
d222 1
a222 1
						   0, 0, xmmalloc, mfree,
d225 1
a225 1
						   0, 0, xmmalloc, mfree,
d228 1
a228 1
						   0, 0, xmmalloc, mfree,
d283 1
a283 1
      mfree (objfile->md, objfile->name);
d443 3
a445 3
     non-reusable case, or detach from the mapped file for the reusable
     case.  Note that the mmalloc_detach or the mfree is the last thing
     we can do with this objfile. */
d470 1
a470 1
	  mfree (objfile->md, objfile->name);
d473 1
a473 1
	mfree (objfile->md, objfile->global_psymbols.list);
d475 1
a475 1
	mfree (objfile->md, objfile->static_psymbols.list);
d481 1
a481 1
      mfree (objfile->md, objfile);
@


1.16
log
@s/basename/lbasename/
@
text
@d560 1
d567 1
a567 1
	  for (j = 0; j < BLOCK_NSYMS (b); ++j)
a568 2
	      struct symbol *sym = BLOCK_SYM (b, j);

@


1.16.2.1
log
@Typesystem work initial import.
Note that this currently isn't building, i'm in the middle of converting make_function_type/lookup_function_type
@
text
@d99 1
a99 1
  obstack_grow (&objfile->misc_obstack, (char *) &section, sizeof (section));
d124 3
a126 6
     this case (we rebuild other things derived from the bfd).
     DJB - 05-27-2001 
     It's in the misc_obstack now, feel free to do what you need to.
     All the stuff in objfile that was on the psymbol obstack, but didnt' belong, is in the misc obstack, which 
     I think is all the stuff you want to blow away anyway.
     */
d131 1
a131 1
    obstack_finish (&objfile->misc_obstack);
a190 2
	      obstack_chunkfun (&objfile->misc_obstack, xmmalloc);
	      obstack_freefun (&objfile->misc_obstack, mfree);
a220 3
	      obstack_specify_allocation_with_arg (&objfile->misc_obstack,
						   0, 0, xmmalloc, mfree,
						   objfile->md);
a266 2
      obstack_specify_allocation (&objfile->misc_obstack, 0, 0, xmalloc,
				  xfree);
a477 1
      obstack_free (&objfile->misc_obstack, 0);
@


1.15
log
@Update/correct copyright notices.
@
text
@d857 1
a857 1
  symsfilename = concat ("./", basename (filename), ".syms", (char *) NULL);
d877 1
a877 1
      symsfilename = concat ("./", basename (filename), ".syms",
@


1.14
log
@Add __FILE__ and __LINE__ parameter to internal_error() /
internal_verror().
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1994, 1995, 2001
@


1.13
log
@Replace STRCMP with strcmp()
@
text
@d2 2
a3 1
   Copyright 1992, 1993, 1994, 1995 Free Software Foundation, Inc.
d374 2
a375 1
  internal_error ("objfiles.c (unlink_objfile): objfile already unlinked");
@


1.12
log
@Replace free() with xfree().
@
text
@d587 1
a587 1
		   && STRCMP (SYMBOL_NAME (sym), MIPS_EFI_SYMBOL_NAME) == 0)
@


1.11
log
@	* objfiles.c (objfile_relocate):  Relocate ei.entry_point with
	its section offset, use SECT_OFF_TEXT only as a fallback.
@
text
@d265 1
a265 1
				  xmalloc, free);
d267 1
a267 1
				  free);
d269 1
a269 1
				  free);
d271 1
a271 1
				  free);
d416 1
a416 1
      free (name);
d858 1
a858 1
      free (symsfilename);
d874 1
a874 1
      free (symsfilename);
d887 1
a887 1
  free (symsfilename);
@


1.10
log
@In objfile_relocate(), don't assume that offsets associated with one
of SECT_OFF_TEXT, SECT_OFF_DATA, or SECT_OFF_BSS will be adequate for
relocating all of the sections in an objfile.
@
text
@d645 12
a670 3

  if (objfile->ei.entry_point != ~(CORE_ADDR) 0)
    objfile->ei.entry_point += ANOFFSET (delta, SECT_OFF_TEXT (objfile));
@


1.9
log
@2000-08-07  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* objfiles.h (SECT_OFF_BSS): Don't detect invalid sect_index_bss
 	here, let the users of the macro do it.
	* symtab.h (ANOFFSET): Detect here if the section index is not
 	initialized.
	* xcoffread.c (find_targ_sec): Don't treat .bss as special,
 	because some objfiles may not have that section at all.
	* coffread.c (cs_to_section): Ditto.
	* elfread.c (elf_symtab_read): Detect an uninitialized index
 	value.
	(elfstab_offset_sections): The macro ANOFFSET cannot be used as an
 	lvalue anymore.
	* remote.c (get_offsets, remote_cisco_objfile_relocate): Don't use
 	ANOFFSET as an lvalue.
	* objfiles.c (objfile_relocate, objfile_relocate): Don't use
 	ANOFFSET as an lvalue.
	* symfile.c (default_symfile_offsets): Don't use ANOFFSET as an
 	lvalue.
@
text
@d653 4
a656 19
	flagword flags;

	flags = bfd_get_section_flags (abfd, s->the_bfd_section);

	if (flags & SEC_CODE)
	  {
	    s->addr += ANOFFSET (delta, SECT_OFF_TEXT (objfile));
	    s->endaddr += ANOFFSET (delta, SECT_OFF_TEXT (objfile));
	  }
	else if (flags & (SEC_DATA | SEC_LOAD))
	  {
	    s->addr += ANOFFSET (delta, SECT_OFF_DATA (objfile));
	    s->endaddr += ANOFFSET (delta, SECT_OFF_DATA (objfile));
	  }
	else if (flags & SEC_ALLOC)
	  {
	    s->addr += ANOFFSET (delta, SECT_OFF_BSS (objfile));
	    s->endaddr += ANOFFSET (delta, SECT_OFF_BSS (objfile));
	  }
@


1.8
log
@Fixup SYMBOL_SECTION for objfiles_relocate().
@
text
@d523 1
a523 1
	ANOFFSET (delta, i) =
d642 1
a642 1
      ANOFFSET (objfile->section_offsets, i) = ANOFFSET (new_offsets, i);
@


1.7
log
@Protoization.
@
text
@d567 3
d612 6
a617 3
      if (SYMBOL_SECTION (*psym) >= 0)
	SYMBOL_VALUE_ADDRESS (*psym) += ANOFFSET (delta,
						  SYMBOL_SECTION (*psym));
d621 6
a626 3
      if (SYMBOL_SECTION (*psym) >= 0)
	SYMBOL_VALUE_ADDRESS (*psym) += ANOFFSET (delta,
						  SYMBOL_SECTION (*psym));
@


1.6
log
@PARAMS removal.
@
text
@d79 1
a79 4
add_to_objfile_sections (abfd, asect, objfile_p_char)
     bfd *abfd;
     sec_ptr asect;
     PTR objfile_p_char;
d119 1
a119 2
build_objfile_section_table (objfile)
     struct objfile *objfile;
d147 1
a147 3
allocate_objfile (abfd, flags)
     bfd *abfd;
     int flags;
d328 1
a328 2
objfile_to_front (objfile)
     struct objfile *objfile;
d359 1
a359 2
unlink_objfile (objfile)
     struct objfile *objfile;
d394 1
a394 2
free_objfile (objfile)
     struct objfile *objfile;
d499 1
a499 1
free_all_objfiles ()
d513 1
a513 3
objfile_relocate (objfile, new_offsets)
     struct objfile *objfile;
     struct section_offsets *new_offsets;
d696 1
a696 1
have_partial_symbols ()
d715 1
a715 1
have_full_symbols ()
d735 1
a735 1
objfile_purge_solibs ()
d756 1
a756 1
have_minimal_symbols ()
d792 1
a792 4
open_existing_mapped_file (symsfilename, mtime, flags)
     char *symsfilename;
     long mtime;
     int flags;
d844 1
a844 4
open_mapped_file (filename, mtime, flags)
     char *filename;
     long mtime;
     int flags;
d889 1
a889 2
map_to_file (fd)
     int fd;
d939 1
a939 3
find_pc_sect_section (pc, section)
     CORE_ADDR pc;
     struct sec *section;
d956 1
a956 2
find_pc_section (pc)
     CORE_ADDR pc;
d967 1
a967 3
in_plt_section (pc, name)
     CORE_ADDR pc;
     char *name;
d984 1
a984 3
is_in_import_list (name, objfile)
     char *name;
     struct objfile *objfile;
@


1.5
log
@Purge (almost) make_cleanup_func.
@
text
@d45 1
a45 2
static int
open_existing_mapped_file PARAMS ((char *, long, int));
d47 1
a47 2
static int
open_mapped_file PARAMS ((char *filename, long mtime, int flags));
d49 1
a49 2
static PTR
  map_to_file PARAMS ((int));
d53 1
a53 2
static void
add_to_objfile_sections PARAMS ((bfd *, sec_ptr, PTR));
@


1.4
log
@Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * objfiles.h (SECT_OFF_DATA, SECT_OFF_TEXT, SECT_OFF_BSS,
        SECT_OFF_RODATA): Define as functions of OBJFILE.  Add
        sect_index_text, sect_index_data, sect_index_rodata,
        sect_index_bss to objfile structure.
        * gdb-stabs.h (SECT_OFF_DATA, SECT_OFF_TEXT, SECT_OFF_BSS,
        SECT_OFF_RODATA): Remove.
        * objfiles.c (allocate_objfile): Initialize
        sect_index_{text,data,bss,rodata} to -1, for error detection.

        * symfile.c (default_symfile_offsets): Initialize
        sect_index_{text,data,bss,rodata} from bfd information.
        * xcoffread.c (xcoff_symfile_offsets): Ditto.
        * somread.c (som_symfile_offsets): Initialize
        sect_index_{text,data,bss,rodata}.

        * coffread.c, dbxread.c, elfread.c, hp-psymtab-read.c,
        hp-symtab-read.c, hpread.c, mdebugread.c, minsyms.c,
        mipsread.c, objfiles.c, os9kread.c, pa64solib.c, partial-stab.h,
        remote-os9k.c, remote-vx.c, remote.c, rs6000-nat.c, somsolib.c,
        stabsread.c, symfile.c, xcoffread.c:
        Update use of SECT_OFF_{TEXT,DATA,BSS,RODATA} to depend on the
        current objfile.

        * xcoffread.c: Add new field objfile to find_targ_sec_arg.
@
text
@d497 11
@


1.3
log
@Deal with the inferior unloading shared objects.
* solib.c (current_sos): New function, replacing find_solib.
(find_solib): Deleted.
(free_so): New function.
(clear_solib): Call free_so, instead of writing it out.
(solib_add): Rewritten: compare the inferior's current list of
shared objects with GDB's list, and do the required loads and
unloads.
(info_sharedlibrary_command, solib_address): Don't use find_solib
to walk the list of shared libraries: call solib_add, and then
walk the list at so_list_head normally.
* objfiles.c (free_objfile): Don't call CLEAR_SOLIB, and don't
detach the core target.  These tasks are taken care of elsewhere.
* target.c (remove_target_sections): New function.
* target.h (remove_target_sections): New declaration.

* solib.c (symbol_add_stub): Check whether we've already created
an objfile for this shared object first, before doing all that
work to compute section addresses, etc.

* objfiles.c (unlink_objfile): Report an internal error if objfile
doesn't occur in the object_files list.

* solib.c (special_symbol_handling): Delete argument; it's not
used.

* solib.c (SOLIB_EXTRACT_ADDRESS):  New macro to extract addresses
from solib structures. Use it throughout solib.c, get rid of all
CORE_ADDR casts.
(struct so_list):  Change type of lmaddr to CORE_ADDR.
(first_link_map_member):  Change return value type to CORE_ADDR,
update callers.
(solib_add_common_symbols):  Change parameter type to CORE_ADDR,
update callers.
(open_symbol_file_object, find_solib):  Change type of lm variable
to CORE_ADDR.
@
text
@d308 8
d602 2
a603 2
      p->textlow += ANOFFSET (delta, SECT_OFF_TEXT);
      p->texthigh += ANOFFSET (delta, SECT_OFF_TEXT);
d654 2
a655 2
	    s->addr += ANOFFSET (delta, SECT_OFF_TEXT);
	    s->endaddr += ANOFFSET (delta, SECT_OFF_TEXT);
d659 2
a660 2
	    s->addr += ANOFFSET (delta, SECT_OFF_DATA);
	    s->endaddr += ANOFFSET (delta, SECT_OFF_DATA);
d664 2
a665 2
	    s->addr += ANOFFSET (delta, SECT_OFF_BSS);
	    s->endaddr += ANOFFSET (delta, SECT_OFF_BSS);
d671 1
a671 1
    objfile->ei.entry_point += ANOFFSET (delta, SECT_OFF_TEXT);
d675 2
a676 2
      objfile->ei.entry_func_lowpc += ANOFFSET (delta, SECT_OFF_TEXT);
      objfile->ei.entry_func_highpc += ANOFFSET (delta, SECT_OFF_TEXT);
d681 2
a682 2
      objfile->ei.entry_file_lowpc += ANOFFSET (delta, SECT_OFF_TEXT);
      objfile->ei.entry_file_highpc += ANOFFSET (delta, SECT_OFF_TEXT);
d687 2
a688 2
      objfile->ei.main_func_lowpc += ANOFFSET (delta, SECT_OFF_TEXT);
      objfile->ei.main_func_highpc += ANOFFSET (delta, SECT_OFF_TEXT);
@


1.2
log
@From Peter Schauer - fix mmalloc bitrot.
@
text
@d373 1
a373 1
	  break;
d376 2
a440 11
#if defined (CLEAR_SOLIB)
  CLEAR_SOLIB ();
  /* CLEAR_SOLIB closes the bfd's for any shared libraries.  But
     the to_sections for a core file might refer to those bfd's.  So
     detach any core file.  */
  {
    struct target_ops *t = find_core_target ();
    if (t != NULL)
      (t->to_detach) (NULL, 0);
  }
#endif
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
This file is part of GDB.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d39 2
d49 1
a49 1
open_mapped_file PARAMS ((char *filename, long mtime, int mapped));
d52 1
a52 1
map_to_file PARAMS ((int));
d54 1
a54 1
#endif  /* defined(USE_MMALLOC) && defined(HAVE_MMAP) */
d62 1
a62 1
struct objfile *object_files;		/* Linked list of all objfiles */
d67 1
a67 1
int mapped_symbol_files;		/* Try to use mapped symbol files */
d77 5
d94 1
a94 1
  if (!(aflag & SEC_ALLOC) && !(TARGET_KEEP_SECTION(asect)))
d105 1
a105 1
  obstack_grow (&objfile->psymbol_obstack, (char *) &section, sizeof(section));
d111 13
a123 1
   error).  */
d136 1
a136 1
  bfd_map_over_sections (objfile->obfd, add_to_objfile_sections, (char *)objfile);
d140 1
a140 1
  return(0);
d143 10
a152 11
/* Given a pointer to an initialized bfd (ABFD) and a flag that indicates
   whether or not an objfile is to be mapped (MAPPED), allocate a new objfile
   struct, fill it in as best we can, link it into the list of all known
   objfiles, and return a pointer to the new objfile struct.

   USER_LOADED is simply recorded in the objfile.  This record offers a way for
   run_command to remove old objfile entries which are no longer valid (i.e.,
   are associated with an old inferior), but to preserve ones that the user
   explicitly loaded via the add-symbol-file command.

   IS_SOLIB is also simply recorded in the objfile. */
d155 1
a155 1
allocate_objfile (abfd, mapped, user_loaded, is_solib)
d157 1
a157 3
     int mapped;
     int  user_loaded;
     int  is_solib;
d162 2
a163 1
  mapped |= mapped_symbol_files;
d167 1
a167 1
  {
d169 17
a185 17
    /* If we can support mapped symbol files, try to open/reopen the
       mapped file that corresponds to the file from which we wish to
       read symbols.  If the objfile is to be mapped, we must malloc
       the structure itself using the mmap version, and arrange that
       all memory allocation for the objfile uses the mmap routines.
       If we are reusing an existing mapped file, from which we get
       our objfile pointer, we have to make sure that we update the
       pointers to the alloc/free functions in the obstack, in case
       these functions have moved within the current gdb.  */

    int fd;

    fd = open_mapped_file (bfd_get_filename (abfd), bfd_get_mtime (abfd),
			   mapped);
    if (fd >= 0)
      {
	PTR md;
d187 26
a212 26
	if ((md = map_to_file (fd)) == NULL)
	  {
	    close (fd);
	  }
	else if ((objfile = (struct objfile *) mmalloc_getkey (md, 0)) != NULL)
	  {
	    /* Update memory corruption handler function addresses. */
	    init_malloc (md);
	    objfile -> md = md;
	    objfile -> mmfd = fd;
	    /* Update pointers to functions to *our* copies */
	    obstack_chunkfun (&objfile -> psymbol_cache.cache, xmmalloc);
	    obstack_freefun (&objfile -> psymbol_cache.cache, mfree);
	    obstack_chunkfun (&objfile -> psymbol_obstack, xmmalloc);
	    obstack_freefun (&objfile -> psymbol_obstack, mfree);
	    obstack_chunkfun (&objfile -> symbol_obstack, xmmalloc);
	    obstack_freefun (&objfile -> symbol_obstack, mfree);
	    obstack_chunkfun (&objfile -> type_obstack, xmmalloc);
	    obstack_freefun (&objfile -> type_obstack, mfree);
	    /* If already in objfile list, unlink it. */
	    unlink_objfile (objfile);
	    /* Forget things specific to a particular gdb, may have changed. */
	    objfile -> sf = NULL;
	  }
	else
	  {
d214 27
a240 27
	    /* Set up to detect internal memory corruption.  MUST be
	       done before the first malloc.  See comments in
	       init_malloc() and mmcheck().  */

	    init_malloc (md);

	    objfile = (struct objfile *)
	      xmmalloc (md, sizeof (struct objfile));
	    memset (objfile, 0, sizeof (struct objfile));
	    objfile -> md = md;
	    objfile -> mmfd = fd;
	    objfile -> flags |= OBJF_MAPPED;
	    mmalloc_setkey (objfile -> md, 0, objfile);
	    obstack_specify_allocation_with_arg (&objfile -> psymbol_cache.cache,
						 0, 0, xmmalloc, mfree,
						 objfile -> md);
	    obstack_specify_allocation_with_arg (&objfile -> psymbol_obstack,
						 0, 0, xmmalloc, mfree,
						 objfile -> md);
	    obstack_specify_allocation_with_arg (&objfile -> symbol_obstack,
						 0, 0, xmmalloc, mfree,
						 objfile -> md);
	    obstack_specify_allocation_with_arg (&objfile -> type_obstack,
						 0, 0, xmmalloc, mfree,
						 objfile -> md);
	  }
      }
d242 8
a249 7
    if (mapped && (objfile == NULL))
      {
	warning ("symbol table for '%s' will not be mapped",
		 bfd_get_filename (abfd));
      }
  }
#else	/* !defined(USE_MMALLOC) || !defined(HAVE_MMAP) */
d251 1
a251 1
  if (mapped)
d256 2
a257 2
	 any more, which shuts up gdb unless the user specifically gives the
	 "mapped" keyword again. */
d260 1
d263 1
a263 1
#endif	/* defined(USE_MMALLOC) && defined(HAVE_MMAP) */
d273 2
a274 2
      objfile -> md = NULL;
      obstack_specify_allocation (&objfile -> psymbol_cache.cache, 0, 0,
d276 1
a276 1
      obstack_specify_allocation (&objfile -> psymbol_obstack, 0, 0, xmalloc,
d278 1
a278 1
      obstack_specify_allocation (&objfile -> symbol_obstack, 0, 0, xmalloc,
d280 1
a280 1
      obstack_specify_allocation (&objfile -> type_obstack, 0, 0, xmalloc,
d282 1
d289 2
a290 2
  objfile -> obfd = abfd;
  if (objfile -> name != NULL)
d292 1
a292 1
      mfree (objfile -> md, objfile -> name);
d296 2
a297 2
      objfile -> name = mstrsave (objfile -> md, bfd_get_filename (abfd));
      objfile -> mtime = bfd_get_mtime (abfd);
d303 2
a304 2
	  error ("Can't find the file sections in `%s': %s", 
		 objfile -> name, bfd_errmsg (bfd_get_error ()));
d310 1
a310 1
  objfile -> next = NULL;
d316 3
a318 3
	   last_one -> next;
	   last_one = last_one -> next);
      last_one -> next = objfile;
d321 2
a322 7
  /* Record whether this objfile was created because the user explicitly
     caused it (e.g., used the add-symbol-file command).
     */
  objfile -> user_loaded = user_loaded;

  /* Record whether this objfile definitely represents a solib. */
  objfile -> is_solib = is_solib;
d365 1
a365 1
  struct objfile** objpp;
d367 1
a367 1
  for (objpp = &object_files; *objpp != NULL; objpp = &((*objpp) -> next))
d369 1
a369 1
      if (*objpp == objfile) 
d371 2
a372 2
	  *objpp = (*objpp) -> next;
	  objfile -> next = NULL;
d386 1
a386 1
   	objfile -> sf
d406 1
a406 1
  if (objfile -> sf != NULL)
d408 1
a408 1
      (*objfile -> sf -> sym_finish) (objfile);
d413 1
a413 1
  if (objfile -> obfd != NULL)
d416 1
a416 1
      if (!bfd_close (objfile -> obfd))
d438 1
a438 1
     
d461 1
a461 1
  if (objfile -> flags & OBJF_MAPPED)
d464 1
a464 1
	 doing the detach, and after the detach the objfile is gone. */
d467 2
a468 2
      mmfd = objfile -> mmfd;
      mmalloc_detach (objfile -> md);
d473 1
a473 1
#endif	/* defined(USE_MMALLOC) && defined(HAVE_MMAP) */
d480 1
a480 1
      if (objfile -> name != NULL)
d482 1
a482 1
	  mfree (objfile -> md, objfile -> name);
d489 5
a493 5
      obstack_free (&objfile -> psymbol_cache.cache, 0);
      obstack_free (&objfile -> psymbol_obstack, 0);
      obstack_free (&objfile -> symbol_obstack, 0);
      obstack_free (&objfile -> type_obstack, 0);
      mfree (objfile -> md, objfile);
d507 3
a509 3
    {
      free_objfile (objfile);
    }
d520 2
a521 3
  struct section_offsets *delta = (struct section_offsets *) 
    alloca (sizeof (struct section_offsets)
	    + objfile->num_sections * sizeof (delta->offsets));
d542 22
a563 12
      {
	struct linetable *l;
	struct blockvector *bv;
	int i;
	
	/* First the line table.  */
	l = LINETABLE (s);
	if (l)
	  {
	    for (i = 0; i < l->nitems; ++i)
	      l->item[i].pc += ANOFFSET (delta, s->block_line_section);
	  }
d565 3
a567 3
	/* Don't relocate a shared blockvector more than once.  */
	if (!s->primary)
	  continue;
d569 15
a583 25
	bv = BLOCKVECTOR (s);
	for (i = 0; i < BLOCKVECTOR_NBLOCKS (bv); ++i)
	  {
	    struct block *b;
	    int j;
	    
	    b = BLOCKVECTOR_BLOCK (bv, i);
	    BLOCK_START (b) += ANOFFSET (delta, s->block_line_section);
	    BLOCK_END (b)   += ANOFFSET (delta, s->block_line_section);

	    for (j = 0; j < BLOCK_NSYMS (b); ++j)
	      {
		struct symbol *sym = BLOCK_SYM (b, j);
		/* The RS6000 code from which this was taken skipped
		   any symbols in STRUCT_NAMESPACE or UNDEF_NAMESPACE.
		   But I'm leaving out that test, on the theory that
		   they can't possibly pass the tests below.  */
		if ((SYMBOL_CLASS (sym) == LOC_LABEL
		     || SYMBOL_CLASS (sym) == LOC_STATIC 
                     || SYMBOL_CLASS (sym) == LOC_INDIRECT)
		    && SYMBOL_SECTION (sym) >= 0)
		  {
		    SYMBOL_VALUE_ADDRESS (sym) += 
		      ANOFFSET (delta, SYMBOL_SECTION (sym));
		  }
d585 1
a585 1
		/* Relocate Extra Function Info for ecoff.  */
d587 4
a590 5
		else
		  if (SYMBOL_CLASS (sym) == LOC_CONST
		      && SYMBOL_NAMESPACE (sym) == LABEL_NAMESPACE
		      && STRCMP (SYMBOL_NAME (sym), MIPS_EFI_SYMBOL_NAME) == 0)
		ecoff_relocate_efi (sym, ANOFFSET (delta, 
d593 3
a595 3
	      }
	  }
      }
d602 4
a605 4
      {
	p->textlow += ANOFFSET (delta, SECT_OFF_TEXT);
	p->texthigh += ANOFFSET (delta, SECT_OFF_TEXT);
      }
d615 1
a615 1
	SYMBOL_VALUE_ADDRESS (*psym) += ANOFFSET (delta, 
d621 1
a621 1
	SYMBOL_VALUE_ADDRESS (*psym) += ANOFFSET (delta, 
d629 1
a629 1
	SYMBOL_VALUE_ADDRESS (msym) += ANOFFSET (delta, SYMBOL_SECTION (msym));
d647 1
a647 2
    for (s = objfile->sections;
	 s < objfile->sections_end; ++s)
d655 1
a655 1
	    s->addr    += ANOFFSET (delta, SECT_OFF_TEXT);
d660 1
a660 1
	    s->addr    += ANOFFSET (delta, SECT_OFF_DATA);
d665 1
a665 1
	    s->addr    += ANOFFSET (delta, SECT_OFF_BSS);
d671 1
a671 1
  if (objfile->ei.entry_point != ~(CORE_ADDR)0)
d676 1
a676 1
      objfile->ei.entry_func_lowpc  += ANOFFSET (delta, SECT_OFF_TEXT);
d682 1
a682 1
      objfile->ei.entry_file_lowpc  += ANOFFSET (delta, SECT_OFF_TEXT);
d688 1
a688 1
      objfile->ei.main_func_lowpc  += ANOFFSET (delta, SECT_OFF_TEXT);
d706 6
a711 6
    {
      if (ofp -> psymtabs != NULL)
	{
	  return 1;
	}
    }
d725 6
a730 6
    {
      if (ofp -> symtabs != NULL)
	{
	  return 1;
	}
    }
d738 1
a738 1
   */
d742 2
a743 2
  struct objfile *  objf;
  struct objfile *  temp;
d749 2
a750 2
       */
    if (! objf->user_loaded && objf->is_solib)
d766 6
a771 6
    {
      if (ofp -> msymbols != NULL)
	{
	  return 1;
	}
    }
d797 1
a797 1
open_existing_mapped_file (symsfilename, mtime, mapped)
d800 1
a800 1
     int mapped;
d809 1
a809 1
	  if (!mapped)
d852 1
a852 1
open_mapped_file (filename, mtime, mapped)
d855 1
a855 1
     int mapped;
d864 1
a864 1
  if ((fd = open_existing_mapped_file (symsfilename, mtime, mapped)) < 0)
d868 1
a868 1
      fd = open_existing_mapped_file (symsfilename, mtime, mapped);
d880 1
a880 1
  if ((fd < 0) && mapped)
d928 2
a929 2
		 address selected by mmap, we must truncate it before trying
		 to do an attach at the address we want. */
d942 1
a942 1
#endif	/* defined(USE_MMALLOC) && defined(HAVE_MMAP) */
a956 11
  
  ALL_OBJFILES (objfile)
    for (s = objfile->sections; s < objfile->sections_end; ++s)
#if defined(HPUXHPPA)
      if ((section == 0 || section == s->the_bfd_section) && 
	  s->addr <= pc && pc <= s->endaddr)
#else
      if ((section == 0 || section == s->the_bfd_section) && 
	  s->addr <= pc && pc < s->endaddr)
#endif
	return(s);
d958 6
a963 1
  return(NULL);
d970 1
a970 1
find_pc_section(pc)
d975 1
a975 1
  
d982 1
a982 1
in_plt_section(pc, name)
d988 3
a990 3
  
  s = find_pc_section(pc);
  
d994 20
a1013 1
  return(retval);
d1015 1
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@a37 2
#include "breakpoint.h"

@


1.1.1.3
log
@import gdb-1999-07-07 post reformat
@
text
@d5 1
a5 1
   This file is part of GDB.
d7 13
a19 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d51 1
a51 1
  map_to_file PARAMS ((int));
d53 1
a53 1
#endif /* defined(USE_MMALLOC) && defined(HAVE_MMAP) */
d61 1
a61 1
struct objfile *object_files;	/* Linked list of all objfiles */
d66 1
a66 1
int mapped_symbol_files;	/* Try to use mapped symbol files */
d88 1
a88 1
  if (!(aflag & SEC_ALLOC) && !(TARGET_KEEP_SECTION (asect)))
d99 1
a99 1
  obstack_grow (&objfile->psymbol_obstack, (char *) &section, sizeof (section));
d118 1
a118 1
  bfd_map_over_sections (objfile->obfd, add_to_objfile_sections, (char *) objfile);
d122 1
a122 1
  return (0);
d141 2
a142 2
     int user_loaded;
     int is_solib;
d151 1
a151 1
    {
d153 17
a169 17
      /* If we can support mapped symbol files, try to open/reopen the
         mapped file that corresponds to the file from which we wish to
         read symbols.  If the objfile is to be mapped, we must malloc
         the structure itself using the mmap version, and arrange that
         all memory allocation for the objfile uses the mmap routines.
         If we are reusing an existing mapped file, from which we get
         our objfile pointer, we have to make sure that we update the
         pointers to the alloc/free functions in the obstack, in case
         these functions have moved within the current gdb.  */

      int fd;

      fd = open_mapped_file (bfd_get_filename (abfd), bfd_get_mtime (abfd),
			     mapped);
      if (fd >= 0)
	{
	  PTR md;
d171 26
a196 26
	  if ((md = map_to_file (fd)) == NULL)
	    {
	      close (fd);
	    }
	  else if ((objfile = (struct objfile *) mmalloc_getkey (md, 0)) != NULL)
	    {
	      /* Update memory corruption handler function addresses. */
	      init_malloc (md);
	      objfile->md = md;
	      objfile->mmfd = fd;
	      /* Update pointers to functions to *our* copies */
	      obstack_chunkfun (&objfile->psymbol_cache.cache, xmmalloc);
	      obstack_freefun (&objfile->psymbol_cache.cache, mfree);
	      obstack_chunkfun (&objfile->psymbol_obstack, xmmalloc);
	      obstack_freefun (&objfile->psymbol_obstack, mfree);
	      obstack_chunkfun (&objfile->symbol_obstack, xmmalloc);
	      obstack_freefun (&objfile->symbol_obstack, mfree);
	      obstack_chunkfun (&objfile->type_obstack, xmmalloc);
	      obstack_freefun (&objfile->type_obstack, mfree);
	      /* If already in objfile list, unlink it. */
	      unlink_objfile (objfile);
	      /* Forget things specific to a particular gdb, may have changed. */
	      objfile->sf = NULL;
	    }
	  else
	    {
d198 27
a224 27
	      /* Set up to detect internal memory corruption.  MUST be
	         done before the first malloc.  See comments in
	         init_malloc() and mmcheck().  */

	      init_malloc (md);

	      objfile = (struct objfile *)
		xmmalloc (md, sizeof (struct objfile));
	      memset (objfile, 0, sizeof (struct objfile));
	      objfile->md = md;
	      objfile->mmfd = fd;
	      objfile->flags |= OBJF_MAPPED;
	      mmalloc_setkey (objfile->md, 0, objfile);
	      obstack_specify_allocation_with_arg (&objfile->psymbol_cache.cache,
						   0, 0, xmmalloc, mfree,
						   objfile->md);
	      obstack_specify_allocation_with_arg (&objfile->psymbol_obstack,
						   0, 0, xmmalloc, mfree,
						   objfile->md);
	      obstack_specify_allocation_with_arg (&objfile->symbol_obstack,
						   0, 0, xmmalloc, mfree,
						   objfile->md);
	      obstack_specify_allocation_with_arg (&objfile->type_obstack,
						   0, 0, xmmalloc, mfree,
						   objfile->md);
	    }
	}
d226 7
a232 7
      if (mapped && (objfile == NULL))
	{
	  warning ("symbol table for '%s' will not be mapped",
		   bfd_get_filename (abfd));
	}
    }
#else /* !defined(USE_MMALLOC) || !defined(HAVE_MMAP) */
d239 2
a240 2
         any more, which shuts up gdb unless the user specifically gives the
         "mapped" keyword again. */
d245 1
a245 1
#endif /* defined(USE_MMALLOC) && defined(HAVE_MMAP) */
d255 2
a256 2
      objfile->md = NULL;
      obstack_specify_allocation (&objfile->psymbol_cache.cache, 0, 0,
d258 1
a258 1
      obstack_specify_allocation (&objfile->psymbol_obstack, 0, 0, xmalloc,
d260 1
a260 1
      obstack_specify_allocation (&objfile->symbol_obstack, 0, 0, xmalloc,
d262 1
a262 1
      obstack_specify_allocation (&objfile->type_obstack, 0, 0, xmalloc,
d270 2
a271 2
  objfile->obfd = abfd;
  if (objfile->name != NULL)
d273 1
a273 1
      mfree (objfile->md, objfile->name);
d277 2
a278 2
      objfile->name = mstrsave (objfile->md, bfd_get_filename (abfd));
      objfile->mtime = bfd_get_mtime (abfd);
d284 2
a285 2
	  error ("Can't find the file sections in `%s': %s",
		 objfile->name, bfd_errmsg (bfd_get_error ()));
d291 1
a291 1
  objfile->next = NULL;
d297 3
a299 3
	   last_one->next;
	   last_one = last_one->next);
      last_one->next = objfile;
d304 2
a305 2
   */
  objfile->user_loaded = user_loaded;
d308 1
a308 1
  objfile->is_solib = is_solib;
d351 1
a351 1
  struct objfile **objpp;
d353 1
a353 1
  for (objpp = &object_files; *objpp != NULL; objpp = &((*objpp)->next))
d355 1
a355 1
      if (*objpp == objfile)
d357 2
a358 2
	  *objpp = (*objpp)->next;
	  objfile->next = NULL;
d372 1
a372 1
   objfile -> sf
d392 1
a392 1
  if (objfile->sf != NULL)
d394 1
a394 1
      (*objfile->sf->sym_finish) (objfile);
d399 1
a399 1
  if (objfile->obfd != NULL)
d402 1
a402 1
      if (!bfd_close (objfile->obfd))
d424 1
a424 1

d447 1
a447 1
  if (objfile->flags & OBJF_MAPPED)
d450 1
a450 1
         doing the detach, and after the detach the objfile is gone. */
d453 2
a454 2
      mmfd = objfile->mmfd;
      mmalloc_detach (objfile->md);
d459 1
a459 1
#endif /* defined(USE_MMALLOC) && defined(HAVE_MMAP) */
d466 1
a466 1
      if (objfile->name != NULL)
d468 1
a468 1
	  mfree (objfile->md, objfile->name);
d475 5
a479 5
      obstack_free (&objfile->psymbol_cache.cache, 0);
      obstack_free (&objfile->psymbol_obstack, 0);
      obstack_free (&objfile->symbol_obstack, 0);
      obstack_free (&objfile->type_obstack, 0);
      mfree (objfile->md, objfile);
d493 3
a495 3
  {
    free_objfile (objfile);
  }
d506 3
a508 3
  struct section_offsets *delta = (struct section_offsets *)
  alloca (sizeof (struct section_offsets)
	  + objfile->num_sections * sizeof (delta->offsets));
d529 12
a540 12
    {
      struct linetable *l;
      struct blockvector *bv;
      int i;

      /* First the line table.  */
      l = LINETABLE (s);
      if (l)
	{
	  for (i = 0; i < l->nitems; ++i)
	    l->item[i].pc += ANOFFSET (delta, s->block_line_section);
	}
d542 3
a544 3
      /* Don't relocate a shared blockvector more than once.  */
      if (!s->primary)
	continue;
d546 25
a570 25
      bv = BLOCKVECTOR (s);
      for (i = 0; i < BLOCKVECTOR_NBLOCKS (bv); ++i)
	{
	  struct block *b;
	  int j;

	  b = BLOCKVECTOR_BLOCK (bv, i);
	  BLOCK_START (b) += ANOFFSET (delta, s->block_line_section);
	  BLOCK_END (b) += ANOFFSET (delta, s->block_line_section);

	  for (j = 0; j < BLOCK_NSYMS (b); ++j)
	    {
	      struct symbol *sym = BLOCK_SYM (b, j);
	      /* The RS6000 code from which this was taken skipped
	         any symbols in STRUCT_NAMESPACE or UNDEF_NAMESPACE.
	         But I'm leaving out that test, on the theory that
	         they can't possibly pass the tests below.  */
	      if ((SYMBOL_CLASS (sym) == LOC_LABEL
		   || SYMBOL_CLASS (sym) == LOC_STATIC
		   || SYMBOL_CLASS (sym) == LOC_INDIRECT)
		  && SYMBOL_SECTION (sym) >= 0)
		{
		  SYMBOL_VALUE_ADDRESS (sym) +=
		    ANOFFSET (delta, SYMBOL_SECTION (sym));
		}
d572 1
a572 1
	      /* Relocate Extra Function Info for ecoff.  */
d574 5
a578 4
	      else if (SYMBOL_CLASS (sym) == LOC_CONST
		       && SYMBOL_NAMESPACE (sym) == LABEL_NAMESPACE
		   && STRCMP (SYMBOL_NAME (sym), MIPS_EFI_SYMBOL_NAME) == 0)
		ecoff_relocate_efi (sym, ANOFFSET (delta,
d581 3
a583 3
	    }
	}
    }
d590 4
a593 4
    {
      p->textlow += ANOFFSET (delta, SECT_OFF_TEXT);
      p->texthigh += ANOFFSET (delta, SECT_OFF_TEXT);
    }
d603 1
a603 1
	SYMBOL_VALUE_ADDRESS (*psym) += ANOFFSET (delta,
d609 1
a609 1
	SYMBOL_VALUE_ADDRESS (*psym) += ANOFFSET (delta,
d617 1
a617 1
      SYMBOL_VALUE_ADDRESS (msym) += ANOFFSET (delta, SYMBOL_SECTION (msym));
d644 1
a644 1
	    s->addr += ANOFFSET (delta, SECT_OFF_TEXT);
d649 1
a649 1
	    s->addr += ANOFFSET (delta, SECT_OFF_DATA);
d654 1
a654 1
	    s->addr += ANOFFSET (delta, SECT_OFF_BSS);
d660 1
a660 1
  if (objfile->ei.entry_point != ~(CORE_ADDR) 0)
d665 1
a665 1
      objfile->ei.entry_func_lowpc += ANOFFSET (delta, SECT_OFF_TEXT);
d671 1
a671 1
      objfile->ei.entry_file_lowpc += ANOFFSET (delta, SECT_OFF_TEXT);
d677 1
a677 1
      objfile->ei.main_func_lowpc += ANOFFSET (delta, SECT_OFF_TEXT);
d695 6
a700 6
  {
    if (ofp->psymtabs != NULL)
      {
	return 1;
      }
  }
d714 6
a719 6
  {
    if (ofp->symtabs != NULL)
      {
	return 1;
      }
  }
d727 1
a727 1
 */
d731 2
a732 2
  struct objfile *objf;
  struct objfile *temp;
d738 2
a739 2
     */
    if (!objf->user_loaded && objf->is_solib)
d755 6
a760 6
  {
    if (ofp->msymbols != NULL)
      {
	return 1;
      }
  }
d917 2
a918 2
	         address selected by mmap, we must truncate it before trying
	         to do an attach at the address we want. */
d931 1
a931 1
#endif /* defined(USE_MMALLOC) && defined(HAVE_MMAP) */
d946 1
a946 1

d950 2
a951 2
    if ((section == 0 || section == s->the_bfd_section) &&
	s->addr <= pc && pc <= s->endaddr)
d953 2
a954 2
    if ((section == 0 || section == s->the_bfd_section) &&
	s->addr <= pc && pc < s->endaddr)
d956 1
a956 1
      return (s);
d958 1
a958 1
  return (NULL);
d965 1
a965 1
find_pc_section (pc)
d970 1
a970 1

d977 1
a977 1
in_plt_section (pc, name)
d983 3
a985 3

  s = find_pc_section (pc);

d989 1
a989 1
  return (retval);
@


1.1.1.4
log
@import gdb-1999-08-09 snapshot
@
text
@a76 5
/* Called via bfd_map_over_sections to build up the section table that
   the objfile references.  The objfile contains pointers to the start
   of the table (objfile->sections) and to the first location after
   the end of the table (objfile->sections_end). */

d106 1
a106 13
   error).

   Note that while we are building the table, which goes into the
   psymbol obstack, we hijack the sections_end pointer to instead hold
   a count of the number of sections.  When bfd_map_over_sections
   returns, this count is used to compute the pointer to the end of
   the sections table, which then overwrites the count.

   Also note that the OFFSET and OVLY_MAPPED in each table entry
   are initialized to zero.

   Also note that if anything else writes to the psymbol obstack while
   we are building the table, we're pretty much hosed. */
d635 2
a636 1
    ALL_OBJFILE_OSECTIONS (objfile, s)
d947 2
a948 1
  ALL_OBJSECTIONS (objfile, s)
@


1.1.1.5
log
@import gdb-1999-08-16 snapshot
@
text
@a1005 20

/* Return nonzero if NAME is in the import list of OBJFILE.  Else
   return zero.  */

int
is_in_import_list (name, objfile)
     char *name;
     struct objfile *objfile;
{
  register int i;

  if (!objfile || !name || !*name)
    return 0;

  for (i = 0; i < objfile->import_list_size; i++)
    if (objfile->import_list[i] && STREQ (name, objfile->import_list[i]))
      return 1;
  return 0;
}

@


1.1.1.6
log
@import gdb-1999-09-08 snapshot
@
text
@d524 3
a526 2
  struct section_offsets *delta =
    (struct section_offsets *) alloca (SIZEOF_SECTION_OFFSETS);
@


1.1.1.7
log
@import gdb-1999-09-21
@
text
@d963 4
d969 1
@


1.1.1.8
log
@import gdb-1999-10-11 snapshot
@
text
@d49 1
a49 1
open_mapped_file PARAMS ((char *filename, long mtime, int flags));
d143 11
a153 10
/* Given a pointer to an initialized bfd (ABFD) and some flag bits
   allocate a new objfile struct, fill it in as best we can, link it
   into the list of all known objfiles, and return a pointer to the
   new objfile struct.

   The FLAGS word contains various bits (OBJF_*) that can be taken as
   requests for specific operations, like trying to open a mapped
   version of the objfile (OBJF_MAPPED).  Other bits like
   OBJF_SHARED are simply copied through to the new objfile flags
   member. */
d156 1
a156 1
allocate_objfile (abfd, flags)
d158 3
a160 1
     int flags;
d165 1
a165 2
  if (mapped_symbol_files)
    flags |= OBJF_MAPPED;
d184 1
a184 1
			     flags);
d244 1
a244 1
      if ((flags & OBJF_MAPPED) && (objfile == NULL))
a247 1
	  flags &= ~OBJF_MAPPED;
d252 1
a252 1
  if (flags & OBJF_MAPPED)
a260 1
      flags &= ~OBJF_MAPPED;
a281 1
      flags &= ~OBJF_MAPPED;
d320 7
a326 2
  /* Save passed in flag bits. */
  objfile->flags |= flags;
d754 1
a754 1
    if (!(objf->flags & OBJF_USERLOADED) && (objf->flags & OBJF_SHARED))
d801 1
a801 1
open_existing_mapped_file (symsfilename, mtime, flags)
d804 1
a804 1
     int flags;
d813 1
a813 1
	  if (!(flags & OBJF_MAPPED))
d856 1
a856 1
open_mapped_file (filename, mtime, flags)
d859 1
a859 1
     int flags;
d868 1
a868 1
  if ((fd = open_existing_mapped_file (symsfilename, mtime, flags)) < 0)
@


1.1.1.9
log
@import gdb-1999-12-06 snapshot
@
text
@d489 1
a489 1
      free_bcache (&objfile->psymbol_cache);
@


