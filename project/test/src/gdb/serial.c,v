head	1.56;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.54
	gdb_7_6-2013-04-26-release:1.54
	gdb_7_6-branch:1.54.0.2
	gdb_7_6-2013-03-12-branchpoint:1.54
	gdb_7_5_1-2012-11-29-release:1.50
	gdb_7_5-2012-08-17-release:1.50
	gdb_7_5-branch:1.50.0.2
	gdb_7_5-2012-07-18-branchpoint:1.50
	gdb_7_4_1-2012-04-26-release:1.44.4.1
	gdb_7_4-2012-01-24-release:1.44.4.1
	gdb_7_4-branch:1.44.0.4
	gdb_7_4-2011-12-13-branchpoint:1.44
	gdb_7_3_1-2011-09-04-release:1.44
	gdb_7_3-2011-07-26-release:1.44
	gdb_7_3-branch:1.44.0.2
	gdb_7_3-2011-04-01-branchpoint:1.44
	gdb_7_2-2010-09-02-release:1.38
	gdb_7_2-branch:1.38.0.2
	gdb_7_2-2010-07-07-branchpoint:1.38
	gdb_7_1-2010-03-18-release:1.35
	gdb_7_1-branch:1.35.0.2
	gdb_7_1-2010-02-18-branchpoint:1.35
	gdb_7_0_1-2009-12-22-release:1.34
	gdb_7_0-2009-10-06-release:1.34
	gdb_7_0-branch:1.34.0.4
	gdb_7_0-2009-09-16-branchpoint:1.34
	arc-sim-20090309:1.33
	msnyder-checkpoint-072509-branch:1.34.0.2
	msnyder-checkpoint-072509-branchpoint:1.34
	arc-insight_6_8-branch:1.33.0.16
	arc-insight_6_8-branchpoint:1.33
	insight_6_8-branch:1.33.0.14
	insight_6_8-branchpoint:1.33
	reverse-20081226-branch:1.33.0.12
	reverse-20081226-branchpoint:1.33
	multiprocess-20081120-branch:1.33.0.10
	multiprocess-20081120-branchpoint:1.33
	reverse-20080930-branch:1.33.0.8
	reverse-20080930-branchpoint:1.33
	reverse-20080717-branch:1.33.0.6
	reverse-20080717-branchpoint:1.33
	msnyder-reverse-20080609-branch:1.33.0.4
	msnyder-reverse-20080609-branchpoint:1.33
	drow-reverse-20070409-branch:1.29.0.2
	drow-reverse-20070409-branchpoint:1.29
	gdb_6_8-2008-03-27-release:1.33
	gdb_6_8-branch:1.33.0.2
	gdb_6_8-2008-02-26-branchpoint:1.33
	gdb_6_7_1-2007-10-29-release:1.31
	gdb_6_7-2007-10-10-release:1.31
	gdb_6_7-branch:1.31.0.2
	gdb_6_7-2007-09-07-branchpoint:1.31
	insight_6_6-20070208-release:1.27
	gdb_6_6-2006-12-18-release:1.27
	gdb_6_6-branch:1.27.0.2
	gdb_6_6-2006-11-15-branchpoint:1.27
	insight_6_5-20061003-release:1.26
	gdb-csl-symbian-6_4_50_20060226-12:1.24
	gdb-csl-sourcerygxx-3_4_4-25:1.22
	nickrob-async-20060828-mergepoint:1.26
	gdb-csl-symbian-6_4_50_20060226-11:1.24
	gdb-csl-sourcerygxx-4_1-17:1.24
	gdb-csl-20060226-branch-local-2:1.24
	gdb-csl-sourcerygxx-4_1-14:1.24
	gdb-csl-sourcerygxx-4_1-13:1.24
	gdb-csl-sourcerygxx-4_1-12:1.24
	gdb-csl-sourcerygxx-3_4_4-21:1.24
	gdb_6_5-20060621-release:1.26
	gdb-csl-sourcerygxx-4_1-9:1.24
	gdb-csl-sourcerygxx-4_1-8:1.24
	gdb-csl-sourcerygxx-4_1-7:1.24
	gdb-csl-arm-2006q1-6:1.24
	gdb-csl-sourcerygxx-4_1-6:1.24
	gdb-csl-symbian-6_4_50_20060226-10:1.24
	gdb-csl-symbian-6_4_50_20060226-9:1.24
	gdb-csl-symbian-6_4_50_20060226-8:1.24
	gdb-csl-coldfire-4_1-11:1.24
	gdb-csl-sourcerygxx-3_4_4-19:1.24
	gdb-csl-coldfire-4_1-10:1.24
	gdb_6_5-branch:1.26.0.6
	gdb_6_5-2006-05-14-branchpoint:1.26
	gdb-csl-sourcerygxx-4_1-5:1.24
	nickrob-async-20060513-branch:1.26.0.4
	nickrob-async-20060513-branchpoint:1.26
	gdb-csl-sourcerygxx-4_1-4:1.24
	msnyder-reverse-20060502-branch:1.26.0.2
	msnyder-reverse-20060502-branchpoint:1.26
	gdb-csl-morpho-4_1-4:1.24
	gdb-csl-sourcerygxx-3_4_4-17:1.24
	readline_5_1-import-branch:1.25.0.2
	readline_5_1-import-branchpoint:1.25
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.24
	gdb-csl-symbian-20060226-branch:1.24.0.8
	gdb-csl-symbian-20060226-branchpoint:1.24
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.24
	msnyder-reverse-20060331-branch:1.24.0.6
	msnyder-reverse-20060331-branchpoint:1.24
	gdb-csl-available-20060303-branch:1.24.0.4
	gdb-csl-available-20060303-branchpoint:1.24
	gdb-csl-20060226-branch:1.24.0.2
	gdb-csl-20060226-branchpoint:1.24
	gdb_6_4-20051202-release:1.22
	msnyder-fork-checkpoint-branch:1.22.0.12
	msnyder-fork-checkpoint-branchpoint:1.22
	gdb-csl-gxxpro-6_3-branch:1.22.0.10
	gdb-csl-gxxpro-6_3-branchpoint:1.22
	gdb_6_4-branch:1.22.0.8
	gdb_6_4-2005-11-01-branchpoint:1.22
	gdb-csl-arm-20051020-branch:1.22.0.6
	gdb-csl-arm-20051020-branchpoint:1.22
	msnyder-tracepoint-checkpoint-branch:1.22.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.22
	gdb-csl-arm-20050325-2005-q1b:1.22
	gdb-csl-arm-20050325-2005-q1a:1.22
	csl-arm-20050325-branch:1.22.0.2
	csl-arm-20050325-branchpoint:1.22
	gdb-post-i18n-errorwarning-20050211:1.17
	gdb-pre-i18n-errorwarning-20050211:1.17
	gdb_6_3-20041109-release:1.17
	gdb_6_3-branch:1.17.0.2
	gdb_6_3-20041019-branchpoint:1.17
	drow_intercu-merge-20040921:1.17
	drow_intercu-merge-20040915:1.17
	jimb-gdb_6_2-e500-branch:1.16.0.6
	jimb-gdb_6_2-e500-branchpoint:1.16
	gdb_6_2-20040730-release:1.16
	gdb_6_2-branch:1.16.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.16
	gdb_6_1_1-20040616-release:1.15
	gdb_6_1-2004-04-05-release:1.15
	drow_intercu-merge-20040402:1.15
	drow_intercu-merge-20040327:1.15
	ezannoni_pie-20040323-branch:1.15.0.68
	ezannoni_pie-20040323-branchpoint:1.15
	cagney_tramp-20040321-mergepoint:1.15
	cagney_tramp-20040309-branch:1.15.0.66
	cagney_tramp-20040309-branchpoint:1.15
	gdb_6_1-branch:1.15.0.64
	gdb_6_1-2004-03-01-gmt-branchpoint:1.15
	drow_intercu-20040221-branch:1.15.0.62
	drow_intercu-20040221-branchpoint:1.15
	cagney_bfdfile-20040213-branch:1.15.0.60
	cagney_bfdfile-20040213-branchpoint:1.15
	drow-cplus-merge-20040208:1.15
	carlton_dictionary-20040126-merge:1.15
	cagney_bigcore-20040122-branch:1.15.0.58
	cagney_bigcore-20040122-branchpoint:1.15
	drow-cplus-merge-20040113:1.15
	drow-cplus-merge-20031224:1.15
	drow-cplus-merge-20031220:1.15
	carlton_dictionary-20031215-merge:1.15
	drow-cplus-merge-20031214:1.15
	carlton-dictionary-20031111-merge:1.15
	gdb_6_0-2003-10-04-release:1.15
	kettenis_sparc-20030918-branch:1.15.0.56
	kettenis_sparc-20030918-branchpoint:1.15
	carlton_dictionary-20030917-merge:1.15
	ezannoni_pie-20030916-branchpoint:1.15
	ezannoni_pie-20030916-branch:1.15.0.54
	cagney_x86i386-20030821-branch:1.15.0.52
	cagney_x86i386-20030821-branchpoint:1.15
	carlton_dictionary-20030805-merge:1.15
	carlton_dictionary-20030627-merge:1.15
	gdb_6_0-branch:1.15.0.50
	gdb_6_0-2003-06-23-branchpoint:1.15
	jimb-ppc64-linux-20030613-branch:1.15.0.48
	jimb-ppc64-linux-20030613-branchpoint:1.15
	cagney_convert-20030606-branch:1.15.0.46
	cagney_convert-20030606-branchpoint:1.15
	cagney_writestrings-20030508-branch:1.15.0.44
	cagney_writestrings-20030508-branchpoint:1.15
	jimb-ppc64-linux-20030528-branch:1.15.0.42
	jimb-ppc64-linux-20030528-branchpoint:1.15
	carlton_dictionary-20030523-merge:1.15
	cagney_fileio-20030521-branch:1.15.0.40
	cagney_fileio-20030521-branchpoint:1.15
	kettenis_i386newframe-20030517-mergepoint:1.15
	jimb-ppc64-linux-20030509-branch:1.15.0.38
	jimb-ppc64-linux-20030509-branchpoint:1.15
	kettenis_i386newframe-20030504-mergepoint:1.15
	carlton_dictionary-20030430-merge:1.15
	kettenis_i386newframe-20030419-branch:1.15.0.36
	kettenis_i386newframe-20030419-branchpoint:1.15
	carlton_dictionary-20030416-merge:1.15
	cagney_frameaddr-20030409-mergepoint:1.15
	kettenis_i386newframe-20030406-branch:1.15.0.34
	kettenis_i386newframe-20030406-branchpoint:1.15
	cagney_frameaddr-20030403-branchpoint:1.15
	cagney_frameaddr-20030403-branch:1.15.0.32
	cagney_framebase-20030330-mergepoint:1.15
	cagney_framebase-20030326-branch:1.15.0.30
	cagney_framebase-20030326-branchpoint:1.15
	cagney_lazyid-20030317-branch:1.15.0.28
	cagney_lazyid-20030317-branchpoint:1.15
	kettenis-i386newframe-20030316-mergepoint:1.15
	offbyone-20030313-branch:1.15.0.26
	offbyone-20030313-branchpoint:1.15
	kettenis-i386newframe-20030308-branch:1.15.0.24
	kettenis-i386newframe-20030308-branchpoint:1.15
	carlton_dictionary-20030305-merge:1.15
	cagney_offbyone-20030303-branch:1.15.0.22
	cagney_offbyone-20030303-branchpoint:1.15
	carlton_dictionary-20030207-merge:1.15
	interps-20030203-mergepoint:1.15
	interps-20030202-branch:1.15.0.20
	interps-20030202-branchpoint:1.15
	cagney-unwind-20030108-branch:1.15.0.18
	cagney-unwind-20030108-branchpoint:1.15
	carlton_dictionary-20021223-merge:1.15
	gdb_5_3-2002-12-12-release:1.15
	carlton_dictionary-20021115-merge:1.15
	kseitz_interps-20021105-merge:1.15
	kseitz_interps-20021103-merge:1.15
	drow-cplus-merge-20021020:1.15
	drow-cplus-merge-20021025:1.15
	carlton_dictionary-20021025-merge:1.15
	carlton_dictionary-20021011-merge:1.15
	drow-cplus-branch:1.15.0.16
	drow-cplus-branchpoint:1.15
	kseitz_interps-20020930-merge:1.15
	carlton_dictionary-20020927-merge:1.15
	carlton_dictionary-branch:1.15.0.14
	carlton_dictionary-20020920-branchpoint:1.15
	gdb_5_3-branch:1.15.0.12
	gdb_5_3-2002-09-04-branchpoint:1.15
	kseitz_interps-20020829-merge:1.15
	cagney_sysregs-20020825-branch:1.15.0.10
	cagney_sysregs-20020825-branchpoint:1.15
	readline_4_3-import-branch:1.15.0.8
	readline_4_3-import-branchpoint:1.15
	gdb_5_2_1-2002-07-23-release:1.14
	kseitz_interps-20020528-branch:1.15.0.6
	kseitz_interps-20020528-branchpoint:1.15
	cagney_regbuf-20020515-branch:1.15.0.4
	cagney_regbuf-20020515-branchpoint:1.15
	jimb-macro-020506-branch:1.15.0.2
	jimb-macro-020506-branchpoint:1.15
	gdb_5_2-2002-04-29-release:1.14
	gdb_5_2-branch:1.14.0.2
	gdb_5_2-2002-03-03-branchpoint:1.14
	gdb_5_1_1-2002-01-24-release:1.12
	gdb_5_1_0_1-2002-01-03-release:1.12
	cygnus_cvs_20020108_pre:1.13
	gdb_5_1_0_1-2002-01-03-branchpoint:1.12
	gdb_5_1_0_1-2002-01-03-branch:1.12.0.6
	gdb_5_1-2001-11-21-release:1.12
	gdb_s390-2001-09-26-branch:1.12.0.4
	gdb_s390-2001-09-26-branchpoint:1.12
	gdb_5_1-2001-07-29-branch:1.12.0.2
	gdb_5_1-2001-07-29-branchpoint:1.12
	dberlin-typesystem-branch:1.9.0.2
	dberlin-typesystem-branchpoint:1.9
	gdb-post-ptid_t-2001-05-03:1.9
	gdb-pre-ptid_t-2001-05-03:1.9
	insight-precleanup-2001-01-01:1.6
	gdb-post-protoization-2000-07-29:1.4
	gdb-pre-protoization-2000-07-29:1.4
	gdb-premipsmulti-2000-06-06-branch:1.3.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb-post-params-removal-2000-06-04:1.3
	gdb-pre-params-removal-2000-06-04:1.3
	gdb-post-params-removal-2000-05-28:1.3
	gdb-pre-params-removal-2000-05-28:1.3
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.10
	insight-2000-02-04:1.1.1.10
	gdb-2000-02-04:1.1.1.10
	gdb-2000-02-02:1.1.1.10
	gdb-2000-02-01:1.1.1.10
	gdb-2000-01-31:1.1.1.9
	gdb-2000-01-26:1.1.1.9
	gdb-2000-01-24:1.1.1.9
	gdb-2000-01-17:1.1.1.9
	gdb-2000-01-10:1.1.1.9
	gdb-2000-01-05:1.1.1.9
	gdb-1999-12-21:1.1.1.9
	gdb-1999-12-13:1.1.1.9
	gdb-1999-12-07:1.1.1.9
	gdb-1999-12-06:1.1.1.9
	gdb-1999-11-16:1.1.1.9
	gdb-1999-11-08:1.1.1.9
	gdb-1999-11-01:1.1.1.8
	gdb-1999-10-25:1.1.1.8
	gdb-1999-10-18:1.1.1.8
	gdb-1999-10-11:1.1.1.8
	gdb-1999-10-04:1.1.1.7
	gdb-1999-09-28:1.1.1.6
	gdb-1999-09-21:1.1.1.6
	gdb-1999-09-13:1.1.1.5
	gdb-1999-09-08:1.1.1.5
	gdb-1999-08-30:1.1.1.5
	gdb-1999-08-23:1.1.1.5
	gdb-1999-08-16:1.1.1.5
	gdb-1999-08-09:1.1.1.5
	gdb-1999-08-02:1.1.1.4
	gdb-1999-07-26:1.1.1.4
	gdb-1999-07-19:1.1.1.4
	gdb-1999-07-12:1.1.1.4
	gdb-post-reformat-19990707:1.1.1.3
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.3
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.56
date	2013.10.10.05.50.19;	author brobecke;	state Exp;
branches;
next	1.55;

1.55
date	2013.04.19.15.26.17;	author palves;	state Exp;
branches;
next	1.54;

1.54
date	2013.03.07.21.57.30;	author kseitz;	state Exp;
branches;
next	1.53;

1.53
date	2013.01.01.06.32.50;	author brobecke;	state Exp;
branches;
next	1.52;

1.52
date	2012.12.20.15.30.25;	author tromey;	state Exp;
branches;
next	1.51;

1.51
date	2012.08.02.09.36.39;	author qiyao;	state Exp;
branches;
next	1.50;

1.50
date	2012.06.13.11.06.52;	author palves;	state Exp;
branches;
next	1.49;

1.49
date	2012.06.11.20.36.53;	author palves;	state Exp;
branches;
next	1.48;

1.48
date	2012.06.11.20.33.56;	author palves;	state Exp;
branches;
next	1.47;

1.47
date	2012.06.11.20.32.29;	author palves;	state Exp;
branches;
next	1.46;

1.46
date	2012.01.28.18.08.20;	author jkratoch;	state Exp;
branches;
next	1.45;

1.45
date	2012.01.04.08.17.10;	author brobecke;	state Exp;
branches;
next	1.44;

1.44
date	2011.03.04.19.23.42;	author uweigand;	state Exp;
branches
	1.44.4.1;
next	1.43;

1.43
date	2011.02.27.16.25.37;	author msnyder;	state Exp;
branches;
next	1.42;

1.42
date	2011.01.11.21.53.23;	author msnyder;	state Exp;
branches;
next	1.41;

1.41
date	2011.01.05.22.22.50;	author msnyder;	state Exp;
branches;
next	1.40;

1.40
date	2011.01.01.15.33.14;	author brobecke;	state Exp;
branches;
next	1.39;

1.39
date	2010.08.20.18.49.20;	author palves;	state Exp;
branches;
next	1.38;

1.38
date	2010.05.16.23.49.58;	author msnyder;	state Exp;
branches;
next	1.37;

1.37
date	2010.05.07.00.47.35;	author msnyder;	state Exp;
branches;
next	1.36;

1.36
date	2010.04.26.21.45.50;	author devans;	state Exp;
branches;
next	1.35;

1.35
date	2010.01.01.07.31.41;	author brobecke;	state Exp;
branches;
next	1.34;

1.34
date	2009.01.03.05.57.53;	author brobecke;	state Exp;
branches;
next	1.33;

1.33
date	2008.02.23.20.04.20;	author vprus;	state Exp;
branches;
next	1.32;

1.32
date	2008.01.01.22.53.12;	author drow;	state Exp;
branches;
next	1.31;

1.31
date	2007.08.23.18.08.37;	author brobecke;	state Exp;
branches;
next	1.30;

1.30
date	2007.08.08.22.12.35;	author jkratoch;	state Exp;
branches;
next	1.29;

1.29
date	2007.04.08.15.20.07;	author vprus;	state Exp;
branches;
next	1.28;

1.28
date	2007.01.09.17.58.58;	author drow;	state Exp;
branches;
next	1.27;

1.27
date	2006.11.04.08.37.24;	author vprus;	state Exp;
branches;
next	1.26;

1.26
date	2006.04.24.21.00.13;	author drow;	state Exp;
branches;
next	1.25;

1.25
date	2006.04.11.20.33.12;	author jimb;	state Exp;
branches;
next	1.24;

1.24
date	2006.02.10.22.01.43;	author drow;	state Exp;
branches;
next	1.23;

1.23
date	2005.12.17.22.34.02;	author eliz;	state Exp;
branches;
next	1.22;

1.22
date	2005.02.21.04.31.58;	author cagney;	state Exp;
branches;
next	1.21;

1.21
date	2005.02.18.18.58.56;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2005.02.17.17.11.03;	author cagney;	state Exp;
branches;
next	1.19;

1.19
date	2005.02.15.15.49.19;	author cagney;	state Exp;
branches;
next	1.18;

1.18
date	2005.02.11.18.13.52;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2004.07.26.14.53.04;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2004.06.29.14.57.39;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.19.02.51.07;	author cagney;	state Exp;
branches
	1.15.44.1
	1.15.62.1;
next	1.14;

1.14
date	2002.02.24.03.59.50;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.26.23.27.39;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2001.07.15.20.34.14;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.11.17.52.32;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.09.14.38.49;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.06.08.21.16;	author kevinb;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.08.06.03.53;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.31.01.24.01;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.15.12.04.03;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.15.01.01.49;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.08.00.52.56;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.16.03.03.13;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.28.02.25.14;	author dberlin;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.04;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.44.4.1
date	2012.01.06.04.43.29;	author brobecke;	state Exp;
branches;
next	;

1.15.44.1
date	2003.06.03.20.54.39;	author cagney;	state Exp;
branches;
next	;

1.15.62.1
date	2004.09.16.17.01.19;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.04;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.05.25.18.03.16;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.07.20.09.51;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.07.12.11.06.56;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.08.09.21.33.53;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.09.22.03.25.00;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.10.05.23.08.47;	author jsm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	99.10.12.04.37.24;	author jsm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	99.11.09.01.23.07;	author jsm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2000.02.02.00.21.10;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.56
log
@Rename "set/show remotebaud" command into "set/show serial baud"

This patch renames the "set/show remotebaud" commands into
"set/show serial baud", and moves its implementation into serial.c.
It also moves the "baud_rate" global from top.c to serial.c, where
the new code is being added (the alternative was to add an include
of target.h).

And to facilitate the transition to the new setting name, this
patch also preserves the old commands, and marks them as deprecated
to alert the users of the change.

gdb/ChangeLog:

        * cli/cli-cmds.c (show_baud_rate): Moved to serial.c as
        serial_baud_show_cmd.
        (_initialize_cli_cmds): Delete the code creating the
        "set/show remotebaud" commands.
        * serial.c (baud_rate): Move here from top.c.
        (serial_baud_show_cmd): Move here from cli/cli-cmds.c.
        (_initialize_serial): Create "set/show serial baud" commands.
        Add "set/show remotebaud" command aliases.
        * top.c (baud_rate): Moved to serial.c.
        * NEWS: Document the new "set/show serial baud" commands,
        replacing "set/show remotebaud".

gdb/doc/ChangeLog:

        * gdb.texinfo: Replace "set remotebaud" and "show remotebaud"
        by "set serial baud" and "show serial baud" (resp) throughout.
@
text
@/* Generic serial interface routines

   Copyright (C) 1992-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include <ctype.h>
#include "serial.h"
#include "gdb_string.h"
#include "gdbcmd.h"
#include "cli/cli-utils.h"

extern void _initialize_serial (void);

/* Is serial being debugged?  */

static unsigned int global_serial_debug_p;

/* Linked list of serial I/O handlers.  */

static struct serial_ops *serial_ops_list = NULL;

/* Pointer to list of scb's.  */

static struct serial *scb_base;

/* Non-NULL gives filename which contains a recording of the remote session,
   suitable for playback by gdbserver.  */

static char *serial_logfile = NULL;
static struct ui_file *serial_logfp = NULL;

static struct serial_ops *serial_interface_lookup (const char *);
static void serial_logchar (struct ui_file *stream,
			    int ch_type, int ch, int timeout);
static const char logbase_hex[] = "hex";
static const char logbase_octal[] = "octal";
static const char logbase_ascii[] = "ascii";
static const char *const logbase_enums[] =
{logbase_hex, logbase_octal, logbase_ascii, NULL};
static const char *serial_logbase = logbase_ascii;


static int serial_current_type = 0;

/* Log char CH of type CHTYPE, with TIMEOUT.  */

/* Define bogus char to represent a BREAK.  Should be careful to choose a value
   that can't be confused with a normal char, or an error code.  */
#define SERIAL_BREAK 1235

static void
serial_logchar (struct ui_file *stream, int ch_type, int ch, int timeout)
{
  if (ch_type != serial_current_type)
    {
      fprintf_unfiltered (stream, "\n%c ", ch_type);
      serial_current_type = ch_type;
    }

  if (serial_logbase != logbase_ascii)
    fputc_unfiltered (' ', stream);

  switch (ch)
    {
    case SERIAL_TIMEOUT:
      fprintf_unfiltered (stream, "<Timeout: %d seconds>", timeout);
      return;
    case SERIAL_ERROR:
      fprintf_unfiltered (stream, "<Error: %s>", safe_strerror (errno));
      return;
    case SERIAL_EOF:
      fputs_unfiltered ("<Eof>", stream);
      return;
    case SERIAL_BREAK:
      fputs_unfiltered ("<Break>", stream);
      return;
    default:
      if (serial_logbase == logbase_hex)
	fprintf_unfiltered (stream, "%02x", ch & 0xff);
      else if (serial_logbase == logbase_octal)
	fprintf_unfiltered (stream, "%03o", ch & 0xff);
      else
	switch (ch)
	  {
	  case '\\':
	    fputs_unfiltered ("\\\\", stream);
	    break;
	  case '\b':
	    fputs_unfiltered ("\\b", stream);
	    break;
	  case '\f':
	    fputs_unfiltered ("\\f", stream);
	    break;
	  case '\n':
	    fputs_unfiltered ("\\n", stream);
	    break;
	  case '\r':
	    fputs_unfiltered ("\\r", stream);
	    break;
	  case '\t':
	    fputs_unfiltered ("\\t", stream);
	    break;
	  case '\v':
	    fputs_unfiltered ("\\v", stream);
	    break;
	  default:
	    fprintf_unfiltered (stream,
				isprint (ch) ? "%c" : "\\x%02x", ch & 0xFF);
	    break;
	  }
    }
}

void
serial_log_command (const char *cmd)
{
  if (!serial_logfp)
    return;

  serial_current_type = 'c';

  fputs_unfiltered ("\nc ", serial_logfp);
  fputs_unfiltered (cmd, serial_logfp);

  /* Make sure that the log file is as up-to-date as possible,
     in case we are getting ready to dump core or something.  */
  gdb_flush (serial_logfp);
}


static struct serial_ops *
serial_interface_lookup (const char *name)
{
  struct serial_ops *ops;

  for (ops = serial_ops_list; ops; ops = ops->next)
    if (strcmp (name, ops->name) == 0)
      return ops;

  return NULL;
}

void
serial_add_interface (struct serial_ops *optable)
{
  optable->next = serial_ops_list;
  serial_ops_list = optable;
}

/* Return the open serial device for FD, if found, or NULL if FD is
   not already opened.  */

struct serial *
serial_for_fd (int fd)
{
  struct serial *scb;

  for (scb = scb_base; scb; scb = scb->next)
    if (scb->fd == fd)
      return scb;

  return NULL;
}

/* Open up a device or a network socket, depending upon the syntax of NAME.  */

struct serial *
serial_open (const char *name)
{
  struct serial *scb;
  struct serial_ops *ops;
  const char *open_name = name;

  if (strcmp (name, "pc") == 0)
    ops = serial_interface_lookup ("pc");
  else if (strncmp (name, "lpt", 3) == 0)
    ops = serial_interface_lookup ("parallel");
  else if (strncmp (name, "|", 1) == 0)
    {
      ops = serial_interface_lookup ("pipe");
      /* Discard ``|'' and any space before the command itself.  */
      ++open_name;
      open_name = skip_spaces_const (open_name);
    }
  /* Check for a colon, suggesting an IP address/port pair.
     Do this *after* checking for all the interesting prefixes.  We
     don't want to constrain the syntax of what can follow them.  */
  else if (strchr (name, ':'))
    ops = serial_interface_lookup ("tcp");
  else
    ops = serial_interface_lookup ("hardwire");

  if (!ops)
    return NULL;

  scb = XMALLOC (struct serial);

  scb->ops = ops;

  scb->bufcnt = 0;
  scb->bufp = scb->buf;
  scb->error_fd = -1;
  scb->refcnt = 1;

  /* `...->open (...)' would get expanded by the open(2) syscall macro.  */
  if ((*scb->ops->open) (scb, open_name))
    {
      xfree (scb);
      return NULL;
    }

  scb->name = xstrdup (name);
  scb->next = scb_base;
  scb->debug_p = 0;
  scb->async_state = 0;
  scb->async_handler = NULL;
  scb->async_context = NULL;
  scb_base = scb;

  if (serial_logfile != NULL)
    {
      serial_logfp = gdb_fopen (serial_logfile, "w");
      if (serial_logfp == NULL)
	perror_with_name (serial_logfile);
    }

  return scb;
}

/* Open a new serial stream using a file handle, using serial
   interface ops OPS.  */

static struct serial *
serial_fdopen_ops (const int fd, struct serial_ops *ops)
{
  struct serial *scb;

  if (!ops)
    {
      ops = serial_interface_lookup ("terminal");
      if (!ops)
 	ops = serial_interface_lookup ("hardwire");
    }

  if (!ops)
    return NULL;

  scb = XCALLOC (1, struct serial);

  scb->ops = ops;

  scb->bufcnt = 0;
  scb->bufp = scb->buf;
  scb->error_fd = -1;
  scb->refcnt = 1;

  scb->name = NULL;
  scb->next = scb_base;
  scb->debug_p = 0;
  scb->async_state = 0;
  scb->async_handler = NULL;
  scb->async_context = NULL;
  scb_base = scb;

  if ((ops->fdopen) != NULL)
    (*ops->fdopen) (scb, fd);
  else
    scb->fd = fd;

  return scb;
}

struct serial *
serial_fdopen (const int fd)
{
  return serial_fdopen_ops (fd, NULL);
}

static void
do_serial_close (struct serial *scb, int really_close)
{
  struct serial *tmp_scb;

  if (serial_logfp)
    {
      fputs_unfiltered ("\nEnd of log\n", serial_logfp);
      serial_current_type = 0;

      /* XXX - What if serial_logfp == gdb_stdout or gdb_stderr?  */
      ui_file_delete (serial_logfp);
      serial_logfp = NULL;
    }

  /* ensure that the FD has been taken out of async mode.  */
  if (scb->async_handler != NULL)
    serial_async (scb, NULL, NULL);

  if (really_close)
    scb->ops->close (scb);

  if (scb->name)
    xfree (scb->name);

  /* For serial_is_open.  */
  scb->bufp = NULL;

  if (scb_base == scb)
    scb_base = scb_base->next;
  else
    for (tmp_scb = scb_base; tmp_scb; tmp_scb = tmp_scb->next)
      {
	if (tmp_scb->next != scb)
	  continue;

	tmp_scb->next = tmp_scb->next->next;
	break;
      }

  serial_unref (scb);
}

void
serial_close (struct serial *scb)
{
  do_serial_close (scb, 1);
}

void
serial_un_fdopen (struct serial *scb)
{
  do_serial_close (scb, 0);
}

int
serial_is_open (struct serial *scb)
{
  return scb->bufp != NULL;
}

void
serial_ref (struct serial *scb)
{
  scb->refcnt++;
}

void
serial_unref (struct serial *scb)
{
  --scb->refcnt;
  if (scb->refcnt == 0)
    xfree (scb);
}

int
serial_readchar (struct serial *scb, int timeout)
{
  int ch;

  /* FIXME: cagney/1999-10-11: Don't enable this check until the ASYNC
     code is finished.  */
  if (0 && serial_is_async_p (scb) && timeout < 0)
    internal_error (__FILE__, __LINE__,
		    _("serial_readchar: blocking read in async mode"));

  ch = scb->ops->readchar (scb, timeout);
  if (serial_logfp != NULL)
    {
      serial_logchar (serial_logfp, 'r', ch, timeout);

      /* Make sure that the log file is as up-to-date as possible,
         in case we are getting ready to dump core or something.  */
      gdb_flush (serial_logfp);
    }
  if (serial_debug_p (scb))
    {
      fprintf_unfiltered (gdb_stdlog, "[");
      serial_logchar (gdb_stdlog, 'r', ch, timeout);
      fprintf_unfiltered (gdb_stdlog, "]");
      gdb_flush (gdb_stdlog);
    }

  return (ch);
}

int
serial_write (struct serial *scb, const void *buf, size_t count)
{
  if (serial_logfp != NULL)
    {
      const char *str = buf;
      size_t c;

      for (c = 0; c < count; c++)
	serial_logchar (serial_logfp, 'w', str[c] & 0xff, 0);

      /* Make sure that the log file is as up-to-date as possible,
         in case we are getting ready to dump core or something.  */
      gdb_flush (serial_logfp);
    }
  if (serial_debug_p (scb))
    {
      const char *str = buf;
      size_t c;

      for (c = 0; c < count; c++)
	{
	  fprintf_unfiltered (gdb_stdlog, "[");
	  serial_logchar (gdb_stdlog, 'w', str[count] & 0xff, 0);
	  fprintf_unfiltered (gdb_stdlog, "]");
	}
      gdb_flush (gdb_stdlog);
    }

  return (scb->ops->write (scb, buf, count));
}

void
serial_printf (struct serial *desc, const char *format,...)
{
  va_list args;
  char *buf;
  va_start (args, format);

  buf = xstrvprintf (format, args);
  serial_write (desc, buf, strlen (buf));

  xfree (buf);
  va_end (args);
}

int
serial_drain_output (struct serial *scb)
{
  return scb->ops->drain_output (scb);
}

int
serial_flush_output (struct serial *scb)
{
  return scb->ops->flush_output (scb);
}

int
serial_flush_input (struct serial *scb)
{
  return scb->ops->flush_input (scb);
}

int
serial_send_break (struct serial *scb)
{
  if (serial_logfp != NULL)
    serial_logchar (serial_logfp, 'w', SERIAL_BREAK, 0);

  return (scb->ops->send_break (scb));
}

void
serial_raw (struct serial *scb)
{
  scb->ops->go_raw (scb);
}

serial_ttystate
serial_get_tty_state (struct serial *scb)
{
  return scb->ops->get_tty_state (scb);
}

serial_ttystate
serial_copy_tty_state (struct serial *scb, serial_ttystate ttystate)
{
  return scb->ops->copy_tty_state (scb, ttystate);
}

int
serial_set_tty_state (struct serial *scb, serial_ttystate ttystate)
{
  return scb->ops->set_tty_state (scb, ttystate);
}

void
serial_print_tty_state (struct serial *scb,
			serial_ttystate ttystate,
			struct ui_file *stream)
{
  scb->ops->print_tty_state (scb, ttystate, stream);
}

int
serial_noflush_set_tty_state (struct serial *scb,
			      serial_ttystate new_ttystate,
			      serial_ttystate old_ttystate)
{
  return scb->ops->noflush_set_tty_state (scb, new_ttystate, old_ttystate);
}

int
serial_setbaudrate (struct serial *scb, int rate)
{
  return scb->ops->setbaudrate (scb, rate);
}

int
serial_setstopbits (struct serial *scb, int num)
{
  return scb->ops->setstopbits (scb, num);
}

int
serial_can_async_p (struct serial *scb)
{
  return (scb->ops->async != NULL);
}

int
serial_is_async_p (struct serial *scb)
{
  return (scb->ops->async != NULL) && (scb->async_handler != NULL);
}

void
serial_async (struct serial *scb,
	      serial_event_ftype *handler,
	      void *context)
{
  int changed = ((scb->async_handler == NULL) != (handler == NULL));

  scb->async_handler = handler;
  scb->async_context = context;
  /* Only change mode if there is a need.  */
  if (changed)
    scb->ops->async (scb, handler != NULL);
}

void
serial_debug (struct serial *scb, int debug_p)
{
  scb->debug_p = debug_p;
}

int
serial_debug_p (struct serial *scb)
{
  return scb->debug_p || global_serial_debug_p;
}

#ifdef USE_WIN32API
void
serial_wait_handle (struct serial *scb, HANDLE *read, HANDLE *except)
{
  if (scb->ops->wait_handle)
    scb->ops->wait_handle (scb, read, except);
  else
    {
      *read = (HANDLE) _get_osfhandle (scb->fd);
      *except = NULL;
    }
}

void
serial_done_wait_handle (struct serial *scb)
{
  if (scb->ops->done_wait_handle)
    scb->ops->done_wait_handle (scb);
}
#endif

int
serial_pipe (struct serial *scbs[2])
{
  struct serial_ops *ops;
  int fildes[2];

  ops = serial_interface_lookup ("pipe");
  if (!ops)
    {
      errno = ENOSYS;
      return -1;
    }

  if (gdb_pipe (fildes) == -1)
    return -1;

  scbs[0] = serial_fdopen_ops (fildes[0], ops);
  scbs[1] = serial_fdopen_ops (fildes[1], ops);
  return 0;
}

/* Serial set/show framework.  */

static struct cmd_list_element *serial_set_cmdlist;
static struct cmd_list_element *serial_show_cmdlist;

static void
serial_set_cmd (char *args, int from_tty)
{
  printf_unfiltered ("\"set serial\" must be followed "
		     "by the name of a command.\n");
  help_list (serial_set_cmdlist, "set serial ", -1, gdb_stdout);
}

static void
serial_show_cmd (char *args, int from_tty)
{
  cmd_show_list (serial_show_cmdlist, from_tty, "");
}

/* Baud rate specified for talking to serial target systems.  Default
   is left as -1, so targets can choose their own defaults.  */
/* FIXME: This means that "show serial baud" and gr_files_info can
   print -1 or (unsigned int)-1.  This is a Bad User Interface.  */

int baud_rate = -1;

static void
serial_baud_show_cmd (struct ui_file *file, int from_tty,
		      struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("Baud rate for remote serial I/O is %s.\n"),
		    value);
}

void
_initialize_serial (void)
{
#if 0
  add_com ("connect", class_obscure, connect_command, _("\
Connect the terminal directly up to the command monitor.\n\
Use <CR>~. or <CR>~^D to break out."));
#endif /* 0 */

  add_prefix_cmd ("serial", class_maintenance, serial_set_cmd, _("\
Set default serial/parallel port configuration."),
		  &serial_set_cmdlist, "set serial ",
		  0/*allow-unknown*/,
		  &setlist);

  add_prefix_cmd ("serial", class_maintenance, serial_show_cmd, _("\
Show default serial/parallel port configuration."),
		  &serial_show_cmdlist, "show serial ",
		  0/*allow-unknown*/,
		  &showlist);

  /* If target is open when baud changes, it doesn't take effect until
     the next open (I think, not sure).  */
  add_setshow_zinteger_cmd ("baud", no_class, &baud_rate, _("\
Set baud rate for remote serial I/O."), _("\
Show baud rate for remote serial I/O."), _("\
This value is used to set the speed of the serial port when debugging\n\
using remote targets."),
			    NULL,
			    serial_baud_show_cmd,
			    &serial_set_cmdlist, &serial_show_cmdlist);

  /* The commands "set/show serial baud" used to have a different name.
     Add aliases to those names to facilitate the transition, and mark
     them as deprecated, in order to make users aware of the fact that
     the command names have been changed.  */
    {
      const char *cmd_name;
      struct cmd_list_element *cmd;

      /* FIXME: There is a limitation in the deprecation mechanism,
	 and the warning ends up not being displayed for prefixed
	 aliases.  So use a real command instead of an alias.  */
      add_setshow_zinteger_cmd ("remotebaud", class_alias, &baud_rate, _("\
Set baud rate for remote serial I/O."), _("\
Show baud rate for remote serial I/O."), _("\
This value is used to set the speed of the serial port when debugging\n\
using remote targets."),
				NULL,
				serial_baud_show_cmd,
				&setlist, &showlist);
      cmd_name = "remotebaud";
      cmd = lookup_cmd (&cmd_name, setlist, "", -1, 1);
      deprecate_cmd (cmd, "set serial baud");
      cmd_name
	= "remotebaud"; /* needed because lookup_cmd updates the pointer */
      cmd = lookup_cmd (&cmd_name, showlist, "", -1, 1);
      deprecate_cmd (cmd, "show serial baud");
    }

  add_setshow_filename_cmd ("remotelogfile", no_class, &serial_logfile, _("\
Set filename for remote session recording."), _("\
Show filename for remote session recording."), _("\
This file is used to record the remote session for future playback\n\
by gdbserver."),
			    NULL,
			    NULL, /* FIXME: i18n: */
			    &setlist, &showlist);

  add_setshow_enum_cmd ("remotelogbase", no_class, logbase_enums,
			&serial_logbase, _("\
Set numerical base for remote session logging"), _("\
Show numerical base for remote session logging"), NULL,
			NULL,
			NULL, /* FIXME: i18n: */
			&setlist, &showlist);

  add_setshow_zuinteger_cmd ("serial", class_maintenance,
			     &global_serial_debug_p, _("\
Set serial debugging."), _("\
Show serial debugging."), _("\
When non-zero, serial port debugging is enabled."),
			     NULL,
			     NULL, /* FIXME: i18n: */
			     &setdebuglist, &showdebuglist);
}
@


1.55
log
@serial_write: change prototype to take a void-pointer buffer.

While remote.c works with "char *" buffers most of the time, other
remote targets have binary-ish-er protocols, and choose to use
"unsigned char" throughout, like e.g., remote-mips.c or
remote-m32r-sdi.c.  That results in -Wpointer-sign warnings in those
targets, unless we add casts in calls to serial_write.  Since
serial_write is only concerned about sending raw host bytes out, and
serial_ops->write_prim already works with "void *"/"size_t", a similar
interface to the "write" or "send" system calls, I find it natural to
change serial_write's prototype accordingly, avoiding the need for
casts.

Tested on x86_64 Fedora 17, and also by building x86_64-mingw32
and DJGPP/go32 -hosted gdbs.

gdb/
2013-04-19  Pedro Alves  <palves@@redhat.com>

	* ser-base.c (ser_base_write): Change prototype -- take 'void *'
	buffer and size_t size.  Adjust.
	* ser-base.h (ser_base_write): Adjust.
	* ser-go32.c (cnts): Change type to size_t.
	(dos_write): Change prototype -- take 'void *'
	buffer and size_t size.  Adjust.
	(dos_info): Print elements of 'cnts' as unsigned long.
	* serial.c (serial_write): Likewise.
	* serial.h (serial_write): Adjust.
	(struct serial_ops) <write>: Change prototype -- take 'void *'
	buffer and size_t size.  Adjust.
@
text
@d624 14
d660 39
@


1.54
log
@	* breakpoint.c (catch_syscall_split_args): Use skip_spaces.
	(trace_pass_command): Likewise.
	* cli/cli-cmds.c: Include cli/cli-utils.h.
	(source_command): Use skip-spaces.
	(disassemble_command): Likewise.
	* findcmd.c: Include cli/cli-utils.h.
	(parse_find_args): Use skip_spaces.
	* go32-nat.c: Include cli/cli-utils.h.
	(go32_sldt): Use skip_spaces.
	(go32_sgdt): Likewise.
	(go32_sidt): Likewise.
	(go32_pde): Likewise.
	(go32_pte): Likewise.
	(go32_pte_for_address): Likewise.
	* infcmd.c: Include cli/cli-utils.h.
	(registers_info): Use skip_spaces.
	* linux-tdep.c (read_mapping): Use skip_spaces_const.
	(linux_info_proc): Likewise.
	* linux-thread-db.c: Include cli/cli-utils.h.
	(info_auto_load_libthread_db): Use skip_spaces_const.
	* m32r-rom.c: Include cli/cli-utils.h.
	(m32r_upload_command): Use skip_spaces.
	* maint.c: Include cli/cli-utils.h.
	(maintenance_translate_address): Use skip_spaces.
	* mi/mi-parse.c: Include cli/cli-utils.h.
	(mi_parse_argv): Use skip_spaces.
	(mi_parse): Likewise.
	* minsyms.c: Include cli/cli-utils.h.
	(msymbol_hash_iw): Use skip_spaces_const.
	* objc-lang.c: Include cli/cli-utils.h.
	(parse_selector): Use skip_spaces.
	(parse_method): Likewise.
	* python/python.c: Include cli/cli-utils.h.
	(python_interactive_command)[HAVE_PYTHON]: Use skip_spaces.
	(python_command)[HAVE_PYTHON]: Likewise.
	(python_interactive_command)[!HAVE_PYTHON]: Likewise.
	* remote-m32r-sdi.c: Include cli/cli-utils.h.
	(m32r_load): Use skip_spaces.
	* serial.c: Include cli/cli-utils.h.
	(serial_open): Use skip_spaces_const.
	* stack.c: Include cli/cli-utils.h.
	(parse_frame_specification_1): Use skip_spaces_const.
	* symfile.c: Include cli/cli-utils.h.
	(set_ext_lang_command): Use skip_spaces.
	* symtab.c: Include cli/cli-utils.h.
	(rbreak_command): Use skip_spaces.
	* thread.c (thread_name_command): Use skip_spaces.
	* tracepoint.c (validate_actionline): Use skip_spaces.
	(encode_actions_1): Likewise.
	(trace_find_range_command): Likewise.
	(trace_find_outside_command): Likewise.
	(trace_dump_actions): Likewise.
@
text
@d401 1
a401 1
serial_write (struct serial *scb, const char *str, int len)
d405 2
a406 1
      int count;
d408 2
a409 2
      for (count = 0; count < len; count++)
	serial_logchar (serial_logfp, 'w', str[count] & 0xff, 0);
d417 2
a418 1
      int count;
d420 1
a420 1
      for (count = 0; count < len; count++)
d429 1
a429 1
  return (scb->ops->write (scb, str, len));
@


1.53
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d25 1
d198 1
a198 2
      while (isspace (*open_name))
	++open_name;
@


1.52
log
@	* serial.c (deprecated_serial_fd): Remove.
	* serial.h (deprecated_serial_fd): Remove.
@
text
@d3 1
a3 1
   Copyright (C) 1992-2002, 2004-2012 Free Software Foundation, Inc.
@


1.51
log
@gdb/
	* dwarf2loc.c (entry_values_debug): Add 'unsigned'.
	(_initialize_dwarf2loc): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* dwarf2loc.h: Update the declaration of 'entry_values_debug'.
	* dwarf2read.c (dwarf2_die_debug): Add 'unsigned'.
	(_initialize_dwarf2_read): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* darwin-nat.c (dwarwin_debug_flag): Add 'unsigned'.
	(_initialize_darwin_inferior): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* frame.c (frame_debug): Add 'unsigned'.
	(_intialize_frame): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* frame.h: Update the declaration of 'frame_debug'.
	* gdbtypes.c (overload_debug): Add 'unsigned'.
	(_initialize_gdbtypes): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* inferior.h: Update declaration of 'debug_infrun'.
	* infrun.c (debug_infrun): Add 'unsigned'.
	(_initialize_infrun): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* jit.c (jit_debug): Add 'unsigned'.
	(_initialize_jit): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* linux-nat.c (debug_linux_nat): Add 'unsigned'.
	(_initialize_linux_nat): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* linux-thread-db.c (libthread_db_debug): Add 'unsigned'.
	(_initialize_thread_db): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* machoread.c (mach_o_debug_level): Add 'unsigned'.
	(_initialize_machoread): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* mi/mi-cmd-var.c: Update the declaration of 'varobjdebug'.
	* microblaze-tdep.c (microblaze_debug_flag): Add 'unsigned'.
	(_initialize_microblaze_tdep): Call add_setshow_zuinteger_cmd
	intead of add_setshow_zinteger_cmd.
	* mips-tdep.c (mips_debug): Add 'unsigned'.
	(_initialize_mips_tdep): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* monitor.c (monitor_debug): Add 'unsigned'.
	(_initialize_remote_monitors): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* observer.c (observer_debug): Add 'unsigned'.
	(_initialize_observer): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* parse.c (expressiondebug): Add 'unsigned'.
	(_initialize_parse): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* record.c (record_debug): Add 'unsigned'.
	(_initialize_record): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* record.h: Update the declaration of 'record_debug'.
	* stap-probe.c (stap_expression_debug): Add 'unsigned'.
	(_initialize_stap_probe): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* serial.c (global_serial_debug_p): Add 'unsigned'.
	(_initialize_serial): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* solib-dsbt.c (solib_dsbt_debug): Add 'unsigned'.
	(_initialize_dsbt_solib): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* solib-frv.c (solib_frv_debug): Add 'unsigned'.
	(_initialize_frv_solib): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* target.c (targetdebug): Add 'unsigned'.
	(initialize_targets): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* valops.c (overload_debug): Add 'unsigned'.
	* varobj.c (varobjdebug): Add 'unsigned'.
	(_initialize_varobj): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* xtensa-tdep.c (xtensa_debug_level): Add 'unsigned'.
	(_initialize_xtensa_tdep): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.

	* arch-utils.h: Remove the declaration of 'gdbarch_debug'.
	* gdbarch.sh (gdbarch_debug): Add 'unsigned'.
	(extern void _initialize_gdbarch): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* gdbarch.c, gdbarch.h: Re-generated.
@
text
@a548 13
int
deprecated_serial_fd (struct serial *scb)
{
  /* FIXME: should this output a warning that deprecated code is being
     called?  */
  if (scb->fd < 0)
    {
      internal_error (__FILE__, __LINE__,
		      _("serial: FD not valid"));
    }
  return scb->fd; /* sigh */
}

@


1.50
log
@2012-06-13  Pedro Alves  <palves@@redhat.com>

	Partial revert of previous change.

	* serial.c (scb_base): New global.
	(serial_for_fd): New.
	(serial_open, serial_fdopen_ops): Link new serial in open serials
	chain.
	(do_serial_close): Unlink serial from the open serials chain.
@
text
@d30 1
a30 1
static int global_serial_debug_p;
d674 2
a675 2
  add_setshow_zinteger_cmd ("serial", class_maintenance,
			    &global_serial_debug_p, _("\
d679 3
a681 3
			    NULL,
			    NULL, /* FIXME: i18n: */
			    &setdebuglist, &showdebuglist);
@


1.49
log
@2012-06-11  Pedro Alves  <palves@@redhat.com>

	* ser-base.c (run_async_handler_and_reschedule): New.
	(fd_event, push_event): Use it.
	* serial.c (serial_open, serial_fdopen_ops): Set the initial
	reference count to 1.
	(do_serial_close): Set the bufp field to NULL.  Use serial_unref
	instead of xfree.
	(serial_is_open, serial_ref, serial_unref): New.
	* serial.h (serial_open): Adjust comment.
	(serial_is_open): Declare.
	(serial_close): Adjust comment.
	(serial_ref, serial_unref) Declare.
	(struct serial): New field 'refcnt'.
@
text
@d36 4
d164 15
d228 1
d233 1
d273 1
d278 1
d322 12
@


1.48
log
@2012-06-11  Pedro Alves  <palves@@redhat.com>

	Remove #if 0'd "connect" command, and unnecessary associated
	refcounting and serial reuse bits.

	* serial.h (struct serial): Remove fields 'next' and 'refcnt'.
	* serial.c (last_serial_opened): Delete.
	(scb_base): Delete.
	(serial_open): Adjust.
	(serial_for_fd): Delete.
	(serial_fdopen_ops, do_serial_close): Adjust.
	(serial_fdopen_ops): Adjust.
@
text
@d199 1
d249 1
d296 4
a299 1
  xfree (scb);
d315 20
@


1.47
log
@2012-06-11  Pedro Alves  <palves@@redhat.com>

	* serial.c (do_serial_close): Remove early return when SCB is
	null.
@
text
@a35 8
/* This is the last serial stream opened.  Used by connect command.  */

static struct serial *last_serial_opened = NULL;

/* Pointer to list of scb's.  */

static struct serial *scb_base;

a168 7
  for (scb = scb_base; scb; scb = scb->next)
    if (scb->name && strcmp (scb->name, name) == 0)
      {
	scb->refcnt++;
	return scb;
      }

a207 2
  scb->next = scb_base;
  scb->refcnt = 1;
a211 3
  scb_base = scb;

  last_serial_opened = scb;
a222 15
/* Return the open serial device for FD, if found, or NULL if FD
   is not already opened.  */

struct serial *
serial_for_fd (int fd)
{
  struct serial *scb;

  for (scb = scb_base; scb; scb = scb->next)
    if (scb->fd == fd)
      return scb;

  return NULL;
}

a230 7
  scb = serial_for_fd (fd);
  if (scb)
    {
      scb->refcnt++;
      return scb;
    }

a249 2
  scb->next = scb_base;
  scb->refcnt = 1;
a253 1
  scb_base = scb;
a259 2
  last_serial_opened = scb;

a273 2
  last_serial_opened = NULL;

a283 4
  scb->refcnt--;
  if (scb->refcnt > 0)
    return;

a293 12
  if (scb_base == scb)
    scb_base = scb_base->next;
  else
    for (tmp_scb = scb_base; tmp_scb; tmp_scb = tmp_scb->next)
      {
	if (tmp_scb->next != scb)
	  continue;

	tmp_scb->next = tmp_scb->next->next;
	break;
      }

a555 123
#if 0
/* The connect command is #if 0 because I hadn't thought of an elegant
   way to wait for I/O on two `struct serial *'s simultaneously.  Two
   solutions came to mind:

   1) Fork, and have have one fork handle the to user direction,
   and have the other hand the to target direction.  This
   obviously won't cut it for MSDOS.

   2) Use something like select.  This assumes that stdin and
   the target side can both be waited on via the same
   mechanism.  This may not be true for DOS, if GDB is
   talking to the target via a TCP socket.
   -grossman, 8 Jun 93 */

/* Connect the user directly to the remote system.  This command acts just like
   the 'cu' or 'tip' command.  Use <CR>~. or <CR>~^D to break out.  */

static struct serial *tty_desc;	/* Controlling terminal */

static void
cleanup_tty (serial_ttystate ttystate)
{
  printf_unfiltered ("\r\n[Exiting connect mode]\r\n");
  serial_set_tty_state (tty_desc, ttystate);
  xfree (ttystate);
  serial_close (tty_desc);
}

static void
connect_command (char *args, int fromtty)
{
  int c;
  char cur_esc = 0;
  serial_ttystate ttystate;
  struct serial *port_desc;		/* TTY port */

  dont_repeat ();

  if (args)
    fprintf_unfiltered (gdb_stderr,
			"This command takes no args.  "
			"They have been ignored.\n");

  printf_unfiltered ("[Entering connect mode.  Use ~. or ~^D to escape]\n");

  tty_desc = serial_fdopen (0);
  port_desc = last_serial_opened;

  ttystate = serial_get_tty_state (tty_desc);

  serial_raw (tty_desc);
  serial_raw (port_desc);

  make_cleanup (cleanup_tty, ttystate);

  while (1)
    {
      int mask;

      mask = serial_wait_2 (tty_desc, port_desc, -1);

      if (mask & 2)
	{			/* tty input */
	  char cx;

	  while (1)
	    {
	      c = serial_readchar (tty_desc, 0);

	      if (c == SERIAL_TIMEOUT)
		break;

	      if (c < 0)
		perror_with_name (_("connect"));

	      cx = c;
	      serial_write (port_desc, &cx, 1);

	      switch (cur_esc)
		{
		case 0:
		  if (c == '\r')
		    cur_esc = c;
		  break;
		case '\r':
		  if (c == '~')
		    cur_esc = c;
		  else
		    cur_esc = 0;
		  break;
		case '~':
		  if (c == '.' || c == '\004')
		    return;
		  else
		    cur_esc = 0;
		}
	    }
	}

      if (mask & 1)
	{			/* Port input */
	  char cx;

	  while (1)
	    {
	      c = serial_readchar (port_desc, 0);

	      if (c == SERIAL_TIMEOUT)
		break;

	      if (c < 0)
		perror_with_name (_("connect"));

	      cx = c;

	      serial_write (tty_desc, &cx, 1);
	    }
	}
    }
}
#endif /* 0 */

@


1.46
log
@gdb/
	Code cleanup: Make 1440 bytes of data segment read-only.
	* arch-utils.c (endian_enum): Make it const char *const [].
	* arm-tdep.c (fp_model_strings, arm_abi_strings, arm_mode_strings):
	Likewise.
	* breakpoint.c (always_inserted_enums): Likewise.
	* cli/cli-cmds.c (script_ext_enums): Likewise.
	* cli/cli-decode.c (add_setshow_enum_cmd, complete_on_enum): Make the
	enumlist parameter const char *const *.
	* cli/cli-decode.h (struct cmd_list_element): Make the enums field
	const char *const *.
	* command.h (complete_on_enum, add_setshow_enum_cmd): Make the enumlist
	parameter const char *const *.
	* cris-tdep.c (cris_modes): Make it const char *const [].
	* filesystem.c (target_file_system_kinds): Likewise.
	* i386-tdep.c (valid_flavors, valid_conventions): Likewise.
	* infrun.c (follow_fork_mode_kind_names, follow_exec_mode_names)
	(can_use_displaced_stepping_enum, scheduler_enums)
	(exec_direction_names): Likewise.
	* language.c (_initialize_language): Make the type_or_range_names and
	case_sensitive_names variables const char *const [].
	* mips-tdep.c (mips_abi_strings): Make it const char *const [].
	* python/python.c (python_excp_enums): Likewise.
	* remote.c (interrupt_sequence_modes): Likewise.
	* rs6000-tdep.c (powerpc_vector_strings): Likewise.
	* serial.c (logbase_enums): Likewise.
	* sh-tdep.c (sh_cc_enum): Likewise.
	* stack.c (print_frame_arguments_choices, print_entry_values_choices):
	Likewise.
	* symtab.c (multiple_symbols_modes): Likewise.
	* tui/tui-win.c (tui_border_kind_enums, tui_border_mode_enums):
	Likewise.
	* utils.c (internal_problem_modes): Likewise.
@
text
@a332 6
/* This is bogus.  It's not our fault if you pass us a bad scb...!  Rob, you
   should fix your code instead.  */

  if (!scb)
    return;

@


1.45
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d56 1
a56 1
static const char *logbase_enums[] =
@


1.44
log
@	* inflow.c (terminal_init_inferior_with_pgrp): Copy ttystate.
	(terminal_save_ours): Remove misleading comment.
	(inflow_inferior_data_cleanup): Free ttystate.
	(inflow_inferior_exit): Likewise.
	(copy_terminal_info): Copy ttystate.

	* serial.c (serial_copy_tty_state): New function.
	* serial.h (serial_copy_tty_state): Add prototype.
	(struct serial_ops): Add copy_tty_state callback.
	* ser-base.c (ser_base_copy_tty_state): New function.
	* ser-base.h (ser_base_copy_tty_state): Add prototype.
	* ser-go32.c (dos_copy_tty_state): New function.
	(dos_ops): Install copy_tty_state callback.
	* ser-mingw.c (_initialize_ser_windows): Likewise.
	* ser-pipe.c (_initialize_ser_pipe): Likewise.
	* ser-unix.c (hardwire_copy_tty_state): New function.
	(_initialize_ser_hardwire): Install it.
@
text
@d3 1
a3 3
   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.44.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 3
a5 1
   Copyright (C) 1992-2002, 2004-2012 Free Software Foundation, Inc.
@


1.43
log
@2011-02-27  Michael Snyder  <msnyder@@vmware.com>

	* darwin-nat-info.c: Fix comment typo.
	* dwarf2expr.h: Ditto.
	* fbsd-nat.c: Ditto.
	* fbsd-nat.h: Ditto.
	* frame-unwind.h: Ditto.
	* frame.h: Ditto.
	* hppa-hpux-tdep.c: Ditto.
	* i386-linux-nat.c: Ditto.
	* linux-nat.c: Ditto.
	* nbsd-nat.c: Ditto.
	* nbsd-nat.h: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* serial.c: Ditto.
	* ui-file.h: Ditto.
	* tui/tui-winsource.c: Ditto.
@
text
@d496 6
@


1.42
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* s390-tdep.c: Comment cleanup, mostly periods and spaces.
	* score-tdep.c: Ditto.
	* score-tdep.h: Ditto.
	* ser-base.c: Ditto.
	* ser-go32.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* ser-mingw.c: Ditto.
	* ser-pipe.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* sh64-tdep.c: Ditto.
	* shnbsd-nat.c: Ditto.
	* sh-tdep.c: Ditto.
	* sh-tdep.h: Ditto.
	* solib.c: Ditto.
	* solib-darwin.c: Ditto.
	* solib-frv.c: Ditto.
	* solib.h: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-spu.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solist.h: Ditto.
	* sol-thread.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* source.h: Ditto.
	* sparc64-linux-tdep.c: Ditto.
	* sparc64-tdep.c: Ditto.
	* sparc-linux-nat.c: Ditto.
	* sparc-linux-tdep.c: Ditto.
	* sparc-sol2-nat.c: Ditto.
	* sparc-sol2-tdep.c: Ditto.
	* sparc-tdep.c: Ditto.
	* sparc-tdep.h: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.h: Ditto.
	* stack.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target.c: Ditto.
	* target-descriptions.c: Ditto.
	* target-descriptions.h: Ditto.
	* target.h: Ditto.
	* target-memory.c: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* trad-frame.h: Ditto.
	* typeprint.c: Ditto.
@
text
@d217 1
a217 1
  /* `...->open (...)' would get expanded by an the open(2) syscall macro.  */
@


1.41
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d30 1
a30 1
/* Is serial being debugged? */
d34 1
a34 1
/* Linked list of serial I/O handlers */
d38 1
a38 1
/* This is the last serial stream opened.  Used by connect command. */
d42 1
a42 1
/* Pointer to list of scb's. */
d47 1
a47 1
   suitable for playback by gdbserver. */
d65 1
a65 1
/* Log char CH of type CHTYPE, with TIMEOUT */
d146 1
a146 1
     in case we are getting ready to dump core or something. */
d170 1
a170 1
/* Open up a device or a network socket, depending upon the syntax of NAME. */
d330 1
a330 1
      /* XXX - What if serial_logfp == gdb_stdout or gdb_stderr? */
d345 1
a345 1
  /* ensure that the FD has been taken out of async mode */
d388 1
a388 1
     code is finished. */
d399 1
a399 1
         in case we are getting ready to dump core or something. */
d424 1
a424 1
         in case we are getting ready to dump core or something. */
d560 1
a560 1
     called? */
@


1.40
log
@run copyright.sh for 2011.
@
text
@d53 2
a54 1
static void serial_logchar (struct ui_file *stream, int ch_type, int ch, int timeout);
d127 2
a128 1
	    fprintf_unfiltered (stream, isprint (ch) ? "%c" : "\\x%02x", ch & 0xFF);
d663 3
a665 1
    fprintf_unfiltered (gdb_stderr, "This command takes no args.  They have been ignored.\n");
d754 2
a755 1
  printf_unfiltered ("\"set serial\" must be followed by the name of a command.\n");
@


1.39
log
@	* serial.h (gdb_pipe, serial_pipe): Declare.
	* serial.c (serial_interface_lookup): Take a const char pointer.
	(serial_fdopen): Rename to ...
	(serial_fdopen_ops): ... this.  Add an OPS parameter and use it.
	Call the OPS' fdopen function if there is one.
	(serial_fdopen): Rewrite as wrapper to serial_fdopen_ops.
	(serial_pipe): New.
	(struct serial_ops) <fdopen>: New field.

	* ser-mingw.c (free_pipe_state):
	(free_pipe_state): Close output on non-pex pipes.
	(pipe_windows_fdopen): New.
	(gdb_pipe): New.
	(_initialize_ser_windows): Register pipe_windows_fdopen.
	* ser-go32.c (gdb_pipe): New.
	* ser-pipe.c (pipe_close): Close file descriptor even if there's
	no state pointer.
	(pipe_ops): Delete.
	(gdb_pipe): New.
@
text
@d4 1
a4 1
   2002, 2004, 2005, 2006, 2007, 2008, 2009, 2010
@


1.38
log
@2010-05-16  Michael Snyder  <msnyder@@vmware.com>

	* scm-exp.c: White space.
	* scm-lang.c: White space.
	* scm-valprint.c: White space.
	* sentinel-frame.c: White space.
	* ser-base.c: White space.
	* ser-go32.c: White space.
	* serial.c: White space.
	* ser-mingw.c: White space.
	* ser-pipe.c: White space.
	* ser-tcp.c: White space.
	* ser-unix.c: White space.
	* solib.c: White space.
	* solib-darwin.c: White space.
	* solib-frv.c: White space.
	* solib-irix.c: White space.
	* solib-osf.c: White space.
	* solib-pa64.c: White space.
	* solib-som.c: White space.
	* solib-spu.c: White space.
	* solib-svr4.c: White space.
	* solib-target.c: White space.
	* source.c: White space.
	* stabsread.c: White space.
	* stack.c: White space.
	* std-regs.c: White space.
	* symfile.c: White space.
	* symmisc.c: White space.
	* symtab.c: White space.
@
text
@d52 1
a52 1
static struct serial_ops *serial_interface_lookup (char *);
d150 1
a150 1
serial_interface_lookup (char *name)
d258 5
a262 2
struct serial *
serial_fdopen (const int fd)
a264 1
  struct serial_ops *ops;
d266 6
a271 6
  for (scb = scb_base; scb; scb = scb->next)
    if (scb->fd == fd)
      {
	scb->refcnt++;
	return scb;
      }
a272 1
  ops = serial_interface_lookup ("terminal");
d274 5
a278 1
    ops = serial_interface_lookup ("hardwire");
d289 1
a289 2

  scb->fd = fd;
d300 5
d310 6
d600 21
@


1.37
log
@2010-05-06  Michael Snyder  <msnyder@@vmware.com>

	* serial.c (serial_for_fd): Delete unused variable.
	* mdebugread.c (psymtab_to_symtab_1): Delete unused variable.
	* top.c (execute_command): Delete unused variable.
	(init_main): Delete unused variable.
	* utils.c (do_fclose_cleanup): Delete unused variable.
	(do_all_inferior_continuations): Delete unused variable.
	(initialize_utils): Delete unused variable.
	(internal_problem_mode): Delete unused global.
	* frame.c (get_prev_frame): Delete unused global.
	(get_frame_locals_address): Delete unused global.
	(get_frame_args_address): Delete unused global.
@
text
@d531 1
@


1.36
log
@	* serial.c (serial_write): Handle serial_debug_p akin to serial_read.
@
text
@a249 1
  struct serial_ops *ops;
@


1.35
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d411 12
@


1.34
log
@        Updated copyright notices for most files.
@
text
@d4 2
a5 1
   2002, 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.33
log
@	Unbreak 'target async'.
        * serial.c (serial_async): Set the
        handler function before enabling async
        mode.
@
text
@d4 1
a4 1
   2002, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.32
log
@	Updated copyright notices for most files.
@
text
@d518 1
a518 4
  /* Only change mode if there is a need. */
  if ((scb->async_handler == NULL)
      != (handler == NULL))
    scb->ops->async (scb, handler != NULL);
d521 3
@


1.31
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d4 1
a4 1
   2002, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
@


1.30
log
@2007-08-08  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* serial.c (serial_open): Fix the OPEN parameter macro expansion.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.29
log
@        Pass stderr of program run with "target remote |"
        via gdb_stderr.
        * serial.c (serial_open): Set error_fd to -1.
        * serial.h (struct serial): New field error_fd.
        (struct serial_opts): New field avail.
        * ser-pipe.c (pipe_open): Create another pair
        of sockets.  Pass stderr to gdb.
        * ser-mingw.c (pipe_windows_open): Pass
        PEX_STDERR_TO_PIPE to pex_run.  Initialize
        sd->error_fd.
        (pipe_avail): New.
        (_initialize_ser_windows): Hook pipe_avail.
        * ser-base.c (generic_readchar): Check if there's
        anything in stderr channel and route that to gdb_stderr.
@
text
@d216 2
a217 1
  if (scb->ops->open (scb, open_name))
@


1.28
log
@Copyright updates for 2007.
@
text
@d214 1
@


1.27
log
@2006-11-04  Vladimir Prus  <vladimir@@codesourcery.com>

       * serial.c (serial_open): Strip leading spaces from program
       name when opening pipe.
@
text
@d3 2
a4 2
   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001, 2002, 2004, 2005, 2006 Free Software Foundation, Inc.
@


1.26
log
@	* ser-mingw.c: Include <conio.h>.
	(struct ser_console_state, struct net_windows_state): Add exit_select,
	have_stopped, thread.
	(pipe_select_thread, console_select_thread)
	(net_windows_select_thread): Don't create a local state copy or
	close stop_select.  Exit on exit_select instead of stop_select.  Set
	have_stopped.
	(console_select_thread): Don't report control keypresses as pending
	input.
	(pipe_select_thread): Allow stop_select to interrupt sleeping.
	(set_console_wait_handle): Create exit_select and have_stopped.
	Save the thread handle.  Check _kbhit before starting a thread.
	(ser_console_done_wait_handle): New.
	(ser_console_close): Close new handles.  Wait for the thread to
	exit.
	(new_windows_select_thread): Assert that an event occurred.
	(net_windows_wait_handle): Check for pending input before starting
	a thread.
	(net_windows_done_wait_handle): New.
	(net_windows_open): Create exit_select and have_stopped.
	Save the thread handle.
	(net_windows_close): Close new handles.  Wait for the thread to
	exit.
	(_intiialize_ser_windows): Register done_wait_handle methods.

	* serial.c [USE_WIN32API] (serial_done_wait_handle): New.
	* serial.h [USE_WIN32API] (struct serial_ops): Add done_wait_handle.
	[USE_WIN32API] (serial_done_wait_handle): New prototype.
	* mingw-hdep.c (gdb_select): Use serial_done_wait_handle.
@
text
@d192 4
a195 1
      open_name = name + 1; /* discard ``|'' */
@


1.25
log
@src/gdb/ChangeLog:
2006-04-11  Jim Blandy  <jimb@@codesourcery.com>

	* serial.c (serial_open): Check for special cases at the front of
	the "device" name before scanning for the ':' that would indicate
	an IP-based connection.
@
text
@d560 7
@


1.24
log
@	* NEWS: Mention native Windows support.
	* Makefile.in (gdb_select_h, ser_tcp_h): New.
	(ALLDEPFILES): Add ser-mingw.c.
	(event-loop.o, inflow.o, mingw-hdep.o, posix-hdep.o, ser-base.o)
	(ser-tcp.o, ser-unix.o): Update.
	(ser-mingw.o): New rule.
	* configure: Regenerated.
	* configure.ac: Add ser-mingw.o for mingw32.
	* ser-mingw.c: New file.
	* event-loop.c: Include "gdb_select.h".
	(gdb_select): Remove, moved to mingw-hdep.c and posix-hdep.c.
	* ser-base.c: Include "gdb_select.h".
	(ser_base_wait_for): Use gdb_select.
	* serial.c (serial_for_fd): New function.
	(serial_fdopen): Try "terminal" before "hardwire".  Initialize
	the allocated struct serial.
	(serial_wait_handle): New function.
	* serial.h (serial_for_fd, serial_wait_handle): New prototypes.
	(struct serial_ops) [USE_WIN32API]: Add wait_handle.
	* gdb_select.h: New file.
	* ser-tcp.c: Include "ser-tcp.h".  Remove unused "ser-unix.h" include.
	(net_close, net_read_prim, net_write_prim): Make global.
	(net_open): Likewise.  Pass an exception set to select.  Whitespace fix.
	Document why we can not use gdb_select.
	(_initialize_ser_tcp) [USE_WIN32API]: Do not register TCP support here.
	* ser-tcp.h: New file.
	* inflow.c (gdb_has_a_terminal): Don't initialize stdin_serial here.
	(handle_sigio): Use gdb_select.
	(initialize_stdin_serial): New function.
	* terminal.h (initialize_stdin_serial): New prototype.
	* top.c (gdb_init): Call initialize_stdin_serial.
	* mingw-hdep.c (gdb_select): New function, moved from gdb_select in
	event-loop.c.  Add exception condition support.  Use serial_for_fd
	and serial_wait_handle.  Fix timeout handling.
	* posix-hdep.c: Include "gdb_select.h".
	(gdb_select): New function.
	* remote-st.c (connect_command): Use gdb_select.
	* ser-unix.c: Include "gdb_select.h".
	(hardwire_send_break, wait_for): Use gdb_select.
@
text
@a186 2
  else if (strchr (name, ':'))
    ops = serial_interface_lookup ("tcp");
d194 5
@


1.23
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d4 1
a4 1
   2001, 2002 Free Software Foundation, Inc.
d236 16
d265 3
a267 1
  ops = serial_interface_lookup ("hardwire");
d272 1
a272 1
  scb = XMALLOC (struct serial);
d545 13
@


1.22
log
@2005-02-20  Andrew Cagney  <cagney@@gnu.org>

	Use add_setshow_enum_cmd through out.
	* arch-utils.c, charset.c, demangle.c, i386-tdep.c: Update.
	* infrun.c, mips-tdep.c, osabi.c, serial.c, tui/tui-win.c: Update.
@
text
@d3 1
a3 1
   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.21
log
@2005-02-18  Andrew Cagney  <cagney@@gnu.org>

	Use add_setshow_zinteger_cmd through out.  Re-sync gdbarch.sh
	and gdbarch.c.
	* breakpoint.c, frame.c, gdb-events.sh, gdbarch.sh: Update.
	* gdbtypes.c, infrun.c, linux-nat.c, maint.c, monitor.c: Update.
	* pa64solib.c, parse.c, remote-mips.c, ser-go32.c: Update.
	* serial.c, solib-frv.c, somsolib.c, target.c, top.c: Update.
	* varobj.c, cli/cli-cmds.c: Update.
	* gdbarch.c, gdb-events.c: Regenerate.
@
text
@d698 7
a704 6
  deprecated_add_show_from_set
    (add_set_enum_cmd ("remotelogbase", no_class,
		       logbase_enums, &serial_logbase,
		       "Set numerical base for remote session logging",
		       &setlist),
     &showlist);
@


1.20
log
@2005-02-17  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_filename_cmd): Set the completer
	to filename_completer.
	* solib.c (_initialize_solib, reload_shared_libraries): Use
	add_setshow_filename_cmd.
	* serial.c (_initialize_serial): Ditto.
	* remote-utils.c (_initialize_sr_support): Ditto.
@
text
@d705 8
a712 8
  deprecated_add_show_from_set
    (add_set_cmd ("serial",
		  class_maintenance,
		  var_zinteger,
		  (char *)&global_serial_debug_p,
		  "Set serial debugging.\n\
When non-zero, serial port debugging is enabled.", &setdebuglist),
     &showdebuglist);
@


1.19
log
@2005-02-15  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_com, add_info and add_prefix_cmd.
	* breakpoint.c, cp-support.c, dcache.c, dwarf2read.c: Update.
	* exec.c, f-valprint.c, frame.c, gcore.c, gnu-nat.c: Update.
	* go32-nat.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* kod.c, language.c, linux-nat.c, m32r-rom.c, macrocmd.c: Update.
	* maint.c, memattr.c, mips-tdep.c, nto-procfs.c, objc-lang.c: Update.
	* ocd.c, pa64solib.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote-e7000.c, remote-m32r-sdi.c, remote-mips.c: Update.
	* remote-sds.c, remote-sim.c, remote-st.c, remote-utils.c: Update.
	* remote.c, rs6000-tdep.c, ser-go32.c, serial.c: Update.
	* sh-tdep.c, solib.c, somsolib.c, source.c, stack.c: Update.
	* symfile.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, typeprint.c, utils.c, valprint.c: Update.
	* win32-nat.c, xcoffsolib.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-layout.c, tui/tui-regs.c: Update.
	* tui/tui-stack.c, tui/tui-win.c: Update.
@
text
@d689 3
a691 4
  deprecated_add_show_from_set
    (add_set_cmd ("remotelogfile", no_class,
		  var_filename, (char *) &serial_logfile,
		  "Set filename for remote session recording.\n\
d693 4
a696 3
by gdbserver.",
		  &setlist),
     &showlist);
@


1.18
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d672 3
a674 3
  add_com ("connect", class_obscure, connect_command,
	   "Connect the terminal directly up to the command monitor.\n\
Use <CR>~. or <CR>~^D to break out.");
d677 2
a678 2
  add_prefix_cmd ("serial", class_maintenance, serial_set_cmd, "\
Set default serial/parallel port configuration.",
d683 2
a684 2
  add_prefix_cmd ("serial", class_maintenance, serial_show_cmd, "\
Show default serial/parallel port configuration.",
@


1.17
log
@2004-07-26  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (deprecated_add_show_from_set): Deprecate.
	* xcoffsolib.c (_initialize_xcoffsolib): Update.
	* wince.c (_initialize_wince): Update.
	* win32-nat.c (_initialize_win32_nat): Update.
	* varobj.c (_initialize_varobj): Update.
	* valops.c (_initialize_valops): Update.
	* utils.c (initialize_utils, initialize_utils): Update.
	* tui/tui-win.c (_initialize_tui_win): Update.
	* top.c (init_main): Update.
	* symfile.c (_initialize_symfile): Update.
	* source.c (_initialize_source): Update.
	* somsolib.c (_initialize_som_solib): Update.
	* solib.c (_initialize_solib): Update.
	* solib-frv.c (_initialize_frv_solib): Update.
	* serial.c (_initialize_serial): Update.
	* ser-go32.c (_initialize_ser_dos, _initialize_ser_dos): Update.
	* remote.c (_initialize_remote, _initialize_remote): Update.
	* remote-vx.c (_initialize_vx): Update.
	* remote-utils.c (_initialize_sr_support): Update.
	* remote-sds.c (_initialize_remote_sds): Update.
	* remote-mips.c (_initialize_remote_mips): Update.
	* remote-e7000.c (_initialize_remote_e7000): Update.
	* proc-api.c (_initialize_proc_api): Update.
	* printcmd.c: Update.
	* parse.c (_initialize_parse): Update.
	* pa64solib.c (_initialize_pa64_solib): Update.
	* p-valprint.c (_initialize_pascal_valprint): Update.
	* monitor.c (_initialize_remote_monitors): Update.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* mcore-tdep.c (_initialize_mcore_tdep): Update.
	* maint.c (_initialize_maint_cmds): Update.
	* lin-lwp.c (_initialize_lin_lwp): Update.
	* language.c (_initialize_language): Update.
	* kod.c (_initialize_kod): Update.
	* infrun.c (set_schedlock_func, _initialize_infrun): Update.
	* i386-tdep.c (_initialize_i386_tdep): Update.
	* gdbtypes.c (build_gdbtypes, _initialize_gdbtypes): Update.
	* gdbarch.sh: Update.
	* gdbarch.c: Re-generate.
	* gdb-events.sh: Update.
	* gdb-events.c: Re-generate.
	* frame.c (_initialize_frame): Update.
	* exec.c: Update.
	* demangle.c (_initialize_demangler): Update.
	* dcache.c (_initialize_dcache): Update.
	* cris-tdep.c (_initialize_cris_tdep, cris_version_update): Update.
	* cp-valprint.c (_initialize_cp_valprint): Update.
	* corefile.c (_initialize_core): Update.
	* command.h: Update.
	* cli/cli-decode.h: Update.
	* cli/cli-cmds.c (init_cli_cmds): Update.
	* charset.c (_initialize_charset): Update.
	* breakpoint.c (_initialize_breakpoint): Update.
	* arm-tdep.c (_initialize_arm_tdep_initialize_arm_tdep): Update.
	* alpha-tdep.c (_initialize_alpha_tdep): Update.
	* aix-thread.c (_initialize_aix_thread): Update.
@
text
@d350 1
a350 1
		    "serial_readchar: blocking read in async mode");
d510 1
a510 1
		      "serial: FD not valid");
d600 1
a600 1
		perror_with_name ("connect");
d638 1
a638 1
		perror_with_name ("connect");
@


1.16
log
@2004-06-28  Andrew Cagney  <cagney@@gnu.org>

	* defs.h (xstrvprintf): Declare.
	* utils.c (xstrvprintf): New function.
	(internal_vproblem, xstrprintf, xasprintf)
	(vfprintf_maybe_filtered, vfprintf_unfiltered): Use xstrvprintf.
	* serial.c (serial_printf): Ditto.
	* complaints.c (vcomplaint): Ditto.
@
text
@d689 1
a689 1
  add_show_from_set
d698 1
a698 1
  add_show_from_set
d705 6
a710 5
  add_show_from_set (add_set_cmd ("serial",
				  class_maintenance,
				  var_zinteger,
				  (char *)&global_serial_debug_p,
				  "Set serial debugging.\n\
d712 1
a712 1
		     &showdebuglist);
@


1.15
log
@* defs.h (XMALLOC): Define.
* gdb-events.sh (XMALLOC): Delete macro.
* gdb-events.c, gdb-events.h: Regenerate.
* gdbarch.sh (XMALLOC): Delete macro.
* gdbarch.c: Regenerate.
* serial.c (XMALLOC): Delete macro.
* ui-file.c (XMALLOC): Ditto.
* ser-unix.h (XMALLOC): Ditto.
* sh-tdep.c (XMALLOC): Ditto.
* ui-out.c (XMALLOC): Ditto.
* utils.c (XMALLOC): Ditto.
* i386-tdep.c (XMALLOC): Ditto.
* gdb-events.c (XMALLOC): Ditto.
* d10v-tdep.c (XMALLOC): Ditto.
* cli-out.c (XMALLOC): Ditto.

* cli-out.c, d10v-tdep.c, gdb-events.c: Update copyright.
* gdb-events.sh, i386-tdep.c, ser-unix.h, serial.c: Ditto.
* ui-file.c, ui-out.c: Ditto.
@
text
@d397 1
a397 1
  xvasprintf (&buf, format, args);
@


1.15.62.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d397 1
a397 1
  buf = xstrvprintf (format, args);
d689 1
a689 1
  deprecated_add_show_from_set
d698 1
a698 1
  deprecated_add_show_from_set
d705 5
a709 6
  deprecated_add_show_from_set
    (add_set_cmd ("serial",
		  class_maintenance,
		  var_zinteger,
		  (char *)&global_serial_debug_p,
		  "Set serial debugging.\n\
d711 1
a711 1
     &showdebuglist);
@


1.15.44.1
log
@Snap const char * mess.
@
text
@d655 1
a655 1
serial_set_cmd (const char *args, int from_tty)
d662 1
a662 1
serial_show_cmd (const char *args, int from_tty)
@


1.14
log
@* ocd.c (ocd_open): Do not try to open the "ocd" device.
* serial.c (serial_open): Delete check for "ocd".
Fix PR gdb/349.
@
text
@d3 2
a4 2
   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
a60 3

#undef XMALLOC
#define XMALLOC(TYPE) ((TYPE*) xmalloc (sizeof (TYPE)))
@


1.13
log
@Add framework for ``set/show serial ...''.
@
text
@d188 1
a188 3
  if (strcmp (name, "ocd") == 0)
    ops = serial_interface_lookup ("ocd");
  else if (strcmp (name, "pc") == 0)
@


1.12
log
@* serial.h (SERIAL_ASYNC): Delete.
(DEPRECATED_SERIAL_FD): Delete.
(SERIAL_DEBUG): Delete.
(SERIAL_DEBUG_P): Delete.
(SERIAL_DRAIN_OUTPUT): Delete.
(SERIAL_FLUSH_OUTPUT): Delete.
(SERIAL_FLUSH_INPUT): Delete.
(SERIAL_SEND_BREAK): Delete.
(SERIAL_RAW): Delete.
(SERIAL_GET_TTY_STATE): Delete.
(SERIAL_SET_TTY_STATE): Delete.
(SERIAL_PRINT_TTY_STATE): Delete.
(SERIAL_NOFLUSH_SET_TTY_STATE): Delete.
(SERIAL_SETBAUDRATE): Delete.
(SERIAL_SETSTOPBITS): Delete.
(SERIAL_CAN_ASYNC_P): Delete.
(SERIAL_IS_ASYNC_P): Delete.
(SERIAL_UN_FDOPEN): Delete.
(SERIAL_READCHAR): Delete.
(SERIAL_CLOSE): Delete.
(SERIAL_FDOPEN): Delete.
(SERIAL_OPEN): Delete.
@
text
@d654 19
d681 12
@


1.11
log
@s/typedef serial_t/struct serial */
@
text
@d353 1
a353 1
  if (0 && SERIAL_IS_ASYNC_P (scb) && timeout < 0)
d366 1
a366 1
  if (SERIAL_DEBUG_P (scb))
d403 1
a403 1
  SERIAL_WRITE (desc, buf, strlen (buf));
d557 1
a557 1
  SERIAL_SET_TTY_STATE (tty_desc, ttystate);
d559 1
a559 1
  SERIAL_CLOSE (tty_desc);
d577 1
a577 1
  tty_desc = SERIAL_FDOPEN (0);
d580 1
a580 1
  ttystate = SERIAL_GET_TTY_STATE (tty_desc);
d582 2
a583 2
  SERIAL_RAW (tty_desc);
  SERIAL_RAW (port_desc);
d591 1
a591 1
      mask = SERIAL_WAIT_2 (tty_desc, port_desc, -1);
d599 1
a599 1
	      c = SERIAL_READCHAR (tty_desc, 0);
d608 1
a608 1
	      SERIAL_WRITE (port_desc, &cx, 1);
d637 1
a637 1
	      c = SERIAL_READCHAR (port_desc, 0);
d647 1
a647 1
	      SERIAL_WRITE (tty_desc, &cx, 1);
@


1.10
log
@s/struct _serial_t/struct serial/
@
text
@d41 1
a41 1
static serial_t last_serial_opened = NULL;
d45 1
a45 1
static serial_t scb_base;
a65 1

d174 1
a174 1
serial_t
d177 1
a177 1
  serial_t scb;
d241 1
a241 1
serial_t
d244 1
a244 1
  serial_t scb;
d283 1
a283 1
do_serial_close (serial_t scb, int really_close)
d285 1
a285 1
  serial_t tmp_scb;
d335 1
a335 1
serial_close (serial_t scb)
d341 1
a341 1
serial_un_fdopen (serial_t scb)
d347 1
a347 1
serial_readchar (serial_t scb, int timeout)
d378 1
a378 1
serial_write (serial_t scb, const char *str, int len)
d396 1
a396 1
serial_printf (serial_t desc, const char *format,...)
d410 1
a410 1
serial_drain_output (serial_t scb)
d416 1
a416 1
serial_flush_output (serial_t scb)
d422 1
a422 1
serial_flush_input (serial_t scb)
d428 1
a428 1
serial_send_break (serial_t scb)
d437 1
a437 1
serial_raw (serial_t scb)
d443 1
a443 1
serial_get_tty_state (serial_t scb)
d449 1
a449 1
serial_set_tty_state (serial_t scb, serial_ttystate ttystate)
d455 1
a455 1
serial_print_tty_state (serial_t scb,
d463 1
a463 1
serial_noflush_set_tty_state (serial_t scb,
d471 1
a471 1
serial_setbaudrate (serial_t scb, int rate)
d477 1
a477 1
serial_setstopbits (serial_t scb, int num)
d483 1
a483 1
serial_can_async_p (serial_t scb)
d489 1
a489 1
serial_is_async_p (serial_t scb)
d495 1
a495 1
serial_async (serial_t scb,
d508 1
a508 1
deprecated_serial_fd (serial_t scb)
d521 1
a521 1
serial_debug (serial_t scb, int debug_p)
d527 1
a527 1
serial_debug_p (serial_t scb)
d534 3
a536 4
/*
   The connect command is #if 0 because I hadn't thought of an elegant
   way to wait for I/O on two serial_t's simultaneously.  Two solutions
   came to mind:
d546 1
a546 2
   -grossman, 8 Jun 93
 */
d551 1
a551 1
static serial_t tty_desc;	/* Controlling terminal */
d568 1
a568 1
  serial_t port_desc;		/* TTY port */
@


1.9
log
@Update/correct copyright notices.
@
text
@d61 3
d208 1
a208 1
  scb = (serial_t) xmalloc (sizeof (struct _serial_t));
d260 1
a260 1
  scb = (serial_t) xmalloc (sizeof (struct _serial_t));
@


1.8
log
@Add __FILE__ and __LINE__ parameter to internal_error() /
internal_verror().
@
text
@d3 2
a4 2
   Copyright 1992, 1993, 1996, 1997, 1999, 2000, 2001 Free Software
   Foundation, Inc.
@


1.7
log
@Replace strsave() with xstrdup().
@
text
@d352 2
a353 1
    internal_error ("serial_readchar: blocking read in async mode");
d512 2
a513 1
      internal_error ("serial: FD not valid");
@


1.6
log
@vasprintf() -> xvasprintf()
@
text
@d2 3
a4 1
   Copyright 1992, 1993, 1996, 1997, 1999, 2000 Free Software Foundation, Inc.
d218 1
a218 1
  scb->name = strsave (name);
@


1.5
log
@Replace free() with xfree().
@
text
@d397 1
a397 1
  vasprintf (&buf, format, args);
@


1.4
log
@Change signature of function add_set_enum_cmd() so that it uses
constant character pointers.  Update everything.
As a consequence fix infrun's follow-fork plugging a small memory leak.
@
text
@d212 1
a212 1
      free (scb);
d313 1
a313 1
    free (scb->name);
d327 1
a327 1
  free (scb);
d400 1
a400 1
  free (buf);
d554 1
a554 1
  free (ttystate);
@


1.3
log
@Fix signature of add_set_enum_cmd.  Change VAR parameter to char**.
Cleanup signature of add_set_cmd.  Change VAR parameter to void*.
@
text
@d53 4
a56 4
static char logbase_hex[] = "hex";
static char logbase_octal[] = "octal";
static char logbase_ascii[] = "ascii";
static char *logbase_enums[] =
d58 1
a58 1
static char *serial_logbase = logbase_ascii;
@


1.2
log
@The set debug changes
@
text
@d670 1
a670 1
		       logbase_enums, (char *) &serial_logbase,
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1996, 1997 Free Software Foundation, Inc.
d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d27 6
d49 1
a49 1
static GDB_FILE *serial_logfp = NULL;
d51 2
a52 2
static struct serial_ops *serial_interface_lookup PARAMS ((char *));
static void serial_logchar PARAMS ((int, int, int));
d56 2
a57 1
static char *logbase_enums[] = {logbase_hex, logbase_octal, logbase_ascii, NULL};
d59 2
a61 1

d71 1
a71 4
serial_logchar (ch_type, ch, timeout)
     int ch_type;
     int ch;
     int timeout;
d75 1
a75 1
      fprintf_unfiltered (serial_logfp, "\n%c ", ch_type);
d80 1
a80 1
    fputc_unfiltered (' ', serial_logfp);
d85 1
a85 1
      fprintf_unfiltered (serial_logfp, "<Timeout: %d seconds>", timeout);
d88 1
a88 1
      fprintf_unfiltered (serial_logfp, "<Error: %s>", safe_strerror (errno));
d91 1
a91 1
      fputs_unfiltered ("<Eof>", serial_logfp);
d94 1
a94 1
      fputs_unfiltered ("<Break>", serial_logfp);
d98 1
a98 1
	fprintf_unfiltered (serial_logfp, "%02x", ch & 0xff);
d100 1
a100 1
	fprintf_unfiltered (serial_logfp, "%03o", ch & 0xff);
d104 24
a127 8
	  case '\\':	fputs_unfiltered ("\\\\", serial_logfp); break;	
	  case '\b':	fputs_unfiltered ("\\b", serial_logfp); break;	
	  case '\f':	fputs_unfiltered ("\\f", serial_logfp); break;	
	  case '\n':	fputs_unfiltered ("\\n", serial_logfp); break;	
	  case '\r':	fputs_unfiltered ("\\r", serial_logfp); break;	
	  case '\t':	fputs_unfiltered ("\\t", serial_logfp); break;	
	  case '\v':	fputs_unfiltered ("\\v", serial_logfp); break;	
	  default:	fprintf_unfiltered (serial_logfp, isprint (ch) ? "%c" : "\\x%02x", ch & 0xFF); break;
d133 1
a133 2
serial_log_command (cmd)
     const char *cmd;
d148 1
a148 51
int
serial_write (scb, str, len)
     serial_t scb;
     const char *str;
     int len;
{
  if (serial_logfp != NULL)
    {
      int count;

      for (count = 0; count < len; count++)
	serial_logchar ('w', str[count] & 0xff, 0);

      /* Make sure that the log file is as up-to-date as possible,
	 in case we are getting ready to dump core or something. */
      gdb_flush (serial_logfp);
    }

  return (scb -> ops -> write (scb, str, len));
}

int
serial_readchar (scb, timeout)
     serial_t scb;
     int timeout;
{
  int ch;

  ch = scb -> ops -> readchar (scb, timeout);
  if (serial_logfp != NULL)
    {
      serial_logchar ('r', ch, timeout);

      /* Make sure that the log file is as up-to-date as possible,
	 in case we are getting ready to dump core or something. */
      gdb_flush (serial_logfp);
    }

  return (ch);
}

int
serial_send_break (scb)
     serial_t scb;
{
  if (serial_logfp != NULL)
    serial_logchar ('w', SERIAL_BREAK, 0);

  return (scb -> ops -> send_break (scb));
}

d150 1
a150 2
serial_interface_lookup (name)
     char *name;
d162 1
a162 2
serial_add_interface(optable)
     struct serial_ops *optable;
d171 1
a171 2
serial_open (name)
     const char *name;
d175 1
d192 5
d203 1
a203 1
  scb = (serial_t)xmalloc (sizeof (struct _serial_t));
d210 1
a210 1
  if (scb->ops->open(scb, name))
d219 4
d238 1
a238 2
serial_fdopen (fd)
     const int fd;
d255 1
a255 1
  scb = (serial_t)xmalloc (sizeof (struct _serial_t));
d267 4
d278 2
a279 4
void
serial_close (scb, really_close)
     serial_t scb;
     int really_close;
d291 1
a291 1
      gdb_fclose (&serial_logfp); 
d305 4
d327 102
a428 1
  free(scb);
d431 96
d529 14
a542 14
The connect command is #if 0 because I hadn't thought of an elegant
way to wait for I/O on two serial_t's simultaneously.  Two solutions
came to mind:

	1) Fork, and have have one fork handle the to user direction,
	   and have the other hand the to target direction.  This
	   obviously won't cut it for MSDOS.

	2) Use something like select.  This assumes that stdin and
	   the target side can both be waited on via the same
	   mechanism.  This may not be true for DOS, if GDB is
	   talking to the target via a TCP socket.
-grossman, 8 Jun 93
*/
d547 1
a547 1
static serial_t tty_desc;		/* Controlling terminal */
d550 1
a550 2
cleanup_tty(ttystate)
     serial_ttystate ttystate;
d559 1
a559 3
connect_command (args, fromtty)
     char	*args;
     int	fromtty;
d566 1
a566 1
  dont_repeat();
d569 3
a571 3
    fprintf_unfiltered(gdb_stderr, "This command takes no args.  They have been ignored.\n");
	
  printf_unfiltered("[Entering connect mode.  Use ~. or ~^D to escape]\n");
d595 1
a595 1
	      c = SERIAL_READCHAR(tty_desc, 0);
d598 1
a598 1
		  break;
d601 1
a601 1
		perror_with_name("connect");
d604 1
a604 1
	      SERIAL_WRITE(port_desc, &cx, 1);
d633 1
a633 1
	      c = SERIAL_READCHAR(port_desc, 0);
d636 1
a636 1
		  break;
d639 1
a639 1
		perror_with_name("connect");
d643 1
a643 1
	      SERIAL_WRITE(tty_desc, &cx, 1);
a649 1
/* VARARGS */
d651 1
a651 29
#ifdef ANSI_PROTOTYPES
serial_printf (serial_t desc, const char *format, ...)
#else
serial_printf (va_alist)
     va_dcl
#endif
{
  va_list args;
  char *buf;
#ifdef ANSI_PROTOTYPES
  va_start (args, format);
#else
  serial_t desc;
  char *format;

  va_start (args);
  desc = va_arg (args, serial_t);
  format = va_arg (args, char *);
#endif

  vasprintf (&buf, format, args);
  SERIAL_WRITE (desc, buf, strlen (buf));

  free (buf);
  va_end (args);
}

void
_initialize_serial ()
d659 1
a659 1
  add_show_from_set 
d664 1
a664 1
by gdbserver.", 
d668 1
a668 1
  add_show_from_set 
d674 8
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-05-25 snapshot
@
text
@a25 2
extern void _initialize_serial PARAMS ((void));

@


1.1.1.3
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d51 1
a51 2
static char *logbase_enums[] =
{logbase_hex, logbase_octal, logbase_ascii, NULL};
d53 1
a54 1

d100 8
a107 24
	  case '\\':
	    fputs_unfiltered ("\\\\", serial_logfp);
	    break;
	  case '\b':
	    fputs_unfiltered ("\\b", serial_logfp);
	    break;
	  case '\f':
	    fputs_unfiltered ("\\f", serial_logfp);
	    break;
	  case '\n':
	    fputs_unfiltered ("\\n", serial_logfp);
	    break;
	  case '\r':
	    fputs_unfiltered ("\\r", serial_logfp);
	    break;
	  case '\t':
	    fputs_unfiltered ("\\t", serial_logfp);
	    break;
	  case '\v':
	    fputs_unfiltered ("\\v", serial_logfp);
	    break;
	  default:
	    fprintf_unfiltered (serial_logfp, isprint (ch) ? "%c" : "\\x%02x", ch & 0xFF);
	    break;
d143 1
a143 1
         in case we are getting ready to dump core or something. */
d147 1
a147 1
  return (scb->ops->write (scb, str, len));
d157 1
a157 1
  ch = scb->ops->readchar (scb, timeout);
d163 1
a163 1
         in case we are getting ready to dump core or something. */
d177 1
a177 1
  return (scb->ops->send_break (scb));
d194 1
a194 1
serial_add_interface (optable)
d231 1
a231 1
  scb = (serial_t) xmalloc (sizeof (struct _serial_t));
d238 1
a238 1
  if (scb->ops->open (scb, name))
d280 1
a280 1
  scb = (serial_t) xmalloc (sizeof (struct _serial_t));
d314 1
a314 1
      gdb_fclose (&serial_logfp);
d346 1
a346 1
  free (scb);
d351 14
a364 14
   The connect command is #if 0 because I hadn't thought of an elegant
   way to wait for I/O on two serial_t's simultaneously.  Two solutions
   came to mind:

   1) Fork, and have have one fork handle the to user direction,
   and have the other hand the to target direction.  This
   obviously won't cut it for MSDOS.

   2) Use something like select.  This assumes that stdin and
   the target side can both be waited on via the same
   mechanism.  This may not be true for DOS, if GDB is
   talking to the target via a TCP socket.
   -grossman, 8 Jun 93
 */
d369 1
a369 1
static serial_t tty_desc;	/* Controlling terminal */
d372 1
a372 1
cleanup_tty (ttystate)
d383 2
a384 2
     char *args;
     int fromtty;
d391 1
a391 1
  dont_repeat ();
d394 3
a396 3
    fprintf_unfiltered (gdb_stderr, "This command takes no args.  They have been ignored.\n");

  printf_unfiltered ("[Entering connect mode.  Use ~. or ~^D to escape]\n");
d420 1
a420 1
	      c = SERIAL_READCHAR (tty_desc, 0);
d423 1
a423 1
		break;
d426 1
a426 1
		perror_with_name ("connect");
d429 1
a429 1
	      SERIAL_WRITE (port_desc, &cx, 1);
d458 1
a458 1
	      c = SERIAL_READCHAR (port_desc, 0);
d461 1
a461 1
		break;
d464 1
a464 1
		perror_with_name ("connect");
d468 1
a468 1
	      SERIAL_WRITE (tty_desc, &cx, 1);
d478 1
a478 1
serial_printf (serial_t desc, const char *format,...)
d513 1
a513 1
  add_show_from_set
d518 1
a518 1
by gdbserver.",
d522 1
a522 1
  add_show_from_set
@


1.1.1.4
log
@import gdb-1999-07-12 snapshot
@
text
@a242 2
  else if (strncmp (name, "|", 1) == 0)
    ops = serial_interface_lookup ("pipe");
@


1.1.1.5
log
@import gdb-1999-08-09 snapshot
@
text
@d495 1
d497 1
d499 4
d506 1
d508 8
@


1.1.1.6
log
@import gdb-1999-09-21
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1996, 1997, 1999 Free Software Foundation, Inc.
d27 1
a27 1
extern void _initialize_serial (void);
d47 2
a48 2
static struct serial_ops *serial_interface_lookup (char *);
static void serial_logchar (int, int, int);
a56 1

d66 4
a69 1
serial_logchar (int ch_type, int ch, int timeout)
d131 2
a132 1
serial_log_command (const char *cmd)
d147 51
a197 1

d199 2
a200 1
serial_interface_lookup (char *name)
d212 2
a213 1
serial_add_interface (struct serial_ops *optable)
d222 2
a223 1
serial_open (const char *name)
a226 1
  const char *open_name = name;
d244 1
a244 4
    {
      ops = serial_interface_lookup ("pipe");
      open_name = name + 1; /* discard ``|'' */
    }
d258 1
a258 1
  if (scb->ops->open (scb, open_name))
a266 2
  scb->async_handler = NULL;
  scb->async_context = NULL;
d282 2
a283 1
serial_fdopen (const int fd)
a311 2
  scb->async_handler = NULL;
  scb->async_context = NULL;
d319 4
a322 2
static void
do_serial_close (serial_t scb, int really_close)
a347 4
  /* ensure that the FD has been taken out of async mode */
  if (scb->async_handler != NULL)
    serial_async (scb, NULL, NULL);

a368 172
void
serial_close (serial_t scb)
{
  do_serial_close (scb, 1);
}

void
serial_un_fdopen (serial_t scb)
{
  do_serial_close (scb, 0);
}

int
serial_readchar (serial_t scb, int timeout)
{
  int ch;

  ch = scb->ops->readchar (scb, timeout);
  if (serial_logfp != NULL)
    {
      serial_logchar ('r', ch, timeout);

      /* Make sure that the log file is as up-to-date as possible,
         in case we are getting ready to dump core or something. */
      gdb_flush (serial_logfp);
    }

  return (ch);
}

int
serial_write (serial_t scb, const char *str, int len)
{
  if (serial_logfp != NULL)
    {
      int count;

      for (count = 0; count < len; count++)
	serial_logchar ('w', str[count] & 0xff, 0);

      /* Make sure that the log file is as up-to-date as possible,
         in case we are getting ready to dump core or something. */
      gdb_flush (serial_logfp);
    }

  return (scb->ops->write (scb, str, len));
}

void
serial_printf (serial_t desc, const char *format,...)
{
  va_list args;
  char *buf;
  va_start (args, format);

  vasprintf (&buf, format, args);
  SERIAL_WRITE (desc, buf, strlen (buf));

  free (buf);
  va_end (args);
}

int
serial_drain_output (serial_t scb)
{
  return scb->ops->drain_output (scb);
}

int
serial_flush_output (serial_t scb)
{
  return scb->ops->flush_output (scb);
}

int
serial_flush_input (serial_t scb)
{
  return scb->ops->flush_input (scb);
}

int
serial_send_break (serial_t scb)
{
  if (serial_logfp != NULL)
    serial_logchar ('w', SERIAL_BREAK, 0);

  return (scb->ops->send_break (scb));
}

void
serial_raw (serial_t scb)
{
  scb->ops->go_raw (scb);
}

serial_ttystate
serial_get_tty_state (serial_t scb)
{
  return scb->ops->get_tty_state (scb);
}

int
serial_set_tty_state (serial_t scb, serial_ttystate ttystate)
{
  return scb->ops->set_tty_state (scb, ttystate);
}

void
serial_print_tty_state (serial_t scb,
			serial_ttystate ttystate,
			struct gdb_file *stream)
{
  scb->ops->print_tty_state (scb, ttystate, stream);
}

int
serial_noflush_set_tty_state (serial_t scb,
			      serial_ttystate new_ttystate,
			      serial_ttystate old_ttystate)
{
  return scb->ops->noflush_set_tty_state (scb, new_ttystate, old_ttystate);
}

int
serial_setbaudrate (serial_t scb, int rate)
{
  return scb->ops->setbaudrate (scb, rate);
}

int
serial_setstopbits (serial_t scb, int num)
{
  return scb->ops->setstopbits (scb, num);
}

int
serial_can_async_p (serial_t scb)
{
  return (scb->ops->async != NULL);
}

int
serial_is_async_p (serial_t scb)
{
  return (scb->ops->async != NULL) && (scb->async_handler != NULL);
}

void
serial_async (serial_t scb,
	      serial_event_ftype *handler,
	      void *context)
{
  /* Only change mode if there is a need. */
  if ((scb->async_handler == NULL)
      != (handler == NULL))
    scb->ops->async (scb, handler != NULL);
  scb->async_handler = handler;
  scb->async_context = context;
}

int
deprecated_serial_fd (serial_t scb)
{
  /* FIXME: should this output a warning that deprecated code is being
     called? */
  if (scb->fd < 0)
    {
      internal_error ("serial: FD not valid");
    }
  return scb->fd; /* sigh */
}

d392 2
a393 1
cleanup_tty (serial_ttystate ttystate)
d402 3
a404 1
connect_command (char *args, int fromtty)
d496 15
a510 1
_initialize_serial (void)
@


1.1.1.7
log
@import gdb-1999-10-04 snapshot
@
text
@a28 4
/* Is serial being debugged? */

static int global_serial_debug_p;

d48 1
a48 1
static void serial_logchar (struct gdb_file *stream, int ch_type, int ch, int timeout);
d67 1
a67 1
serial_logchar (struct gdb_file *stream, int ch_type, int ch, int timeout)
d71 1
a71 1
      fprintf_unfiltered (stream, "\n%c ", ch_type);
d76 1
a76 1
    fputc_unfiltered (' ', stream);
d81 1
a81 1
      fprintf_unfiltered (stream, "<Timeout: %d seconds>", timeout);
d84 1
a84 1
      fprintf_unfiltered (stream, "<Error: %s>", safe_strerror (errno));
d87 1
a87 1
      fputs_unfiltered ("<Eof>", stream);
d90 1
a90 1
      fputs_unfiltered ("<Break>", stream);
d94 1
a94 1
	fprintf_unfiltered (stream, "%02x", ch & 0xff);
d96 1
a96 1
	fprintf_unfiltered (stream, "%03o", ch & 0xff);
d101 1
a101 1
	    fputs_unfiltered ("\\\\", stream);
d104 1
a104 1
	    fputs_unfiltered ("\\b", stream);
d107 1
a107 1
	    fputs_unfiltered ("\\f", stream);
d110 1
a110 1
	    fputs_unfiltered ("\\n", stream);
d113 1
a113 1
	    fputs_unfiltered ("\\r", stream);
d116 1
a116 1
	    fputs_unfiltered ("\\t", stream);
d119 1
a119 1
	    fputs_unfiltered ("\\v", stream);
d122 1
a122 1
	    fprintf_unfiltered (stream, isprint (ch) ? "%c" : "\\x%02x", ch & 0xFF);
a214 2
  scb->debug_p = 0;
  scb->async_state = 0;
a260 2
  scb->debug_p = 0;
  scb->async_state = 0;
d342 1
a342 1
      serial_logchar (serial_logfp, 'r', ch, timeout);
a347 7
  if (SERIAL_DEBUG_P (scb))
    {
      fprintf_unfiltered (gdb_stdlog, "[");
      serial_logchar (gdb_stdlog, 'r', ch, timeout);
      fprintf_unfiltered (gdb_stdlog, "]");
      gdb_flush (gdb_stdlog);
    }
d360 1
a360 1
	serial_logchar (serial_logfp, 'w', str[count] & 0xff, 0);
d406 1
a406 1
    serial_logchar (serial_logfp, 'w', SERIAL_BREAK, 0);
a493 13
void
serial_debug (serial_t scb, int debug_p)
{
  scb->debug_p = debug_p;
}

int
serial_debug_p (serial_t scb)
{
  return scb->debug_p || global_serial_debug_p;
}


a640 8

  add_show_from_set (add_set_cmd ("serialdebug",
				  class_maintenance,
				  var_zinteger,
				  (char *)&global_serial_debug_p,
				  "Set serial debugging.\n\
When non-zero, serial port debugging is enabled.", &setlist),
		     &showlist);
@


1.1.1.8
log
@import gdb-1999-10-11 snapshot
@
text
@a346 5
  /* FIXME: cagney/1999-10-11: Don't enable this check until the ASYNC
     code is finished. */
  if (0 && SERIAL_IS_ASYNC_P (scb) && timeout < 0)
    internal_error ("serial_readchar: blocking read in async mode");

@


1.1.1.9
log
@import gdb-1999-11-08 snapshot
@
text
@d291 1
a291 1
      gdb_file_delete (serial_logfp);
@


1.1.1.10
log
@import gdb-2000-02-01 snapshot
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1996, 1997, 1999, 2000 Free Software Foundation, Inc.
d49 1
a49 1
static struct ui_file *serial_logfp = NULL;
d52 1
a52 1
static void serial_logchar (struct ui_file *stream, int ch_type, int ch, int timeout);
d71 1
a71 1
serial_logchar (struct ui_file *stream, int ch_type, int ch, int timeout)
d291 1
a291 1
      ui_file_delete (serial_logfp);
d452 1
a452 1
			struct ui_file *stream)
@


