head	1.74;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.73
	gdb_7_6-2013-04-26-release:1.73
	gdb_7_6-branch:1.73.0.2
	gdb_7_6-2013-03-12-branchpoint:1.73
	gdb_7_5_1-2012-11-29-release:1.72
	gdb_7_5-2012-08-17-release:1.72
	gdb_7_5-branch:1.72.0.2
	gdb_7_5-2012-07-18-branchpoint:1.72
	gdb_7_4_1-2012-04-26-release:1.67.4.2
	gdb_7_4-2012-01-24-release:1.67.4.2
	gdb_7_4-branch:1.67.0.4
	gdb_7_4-2011-12-13-branchpoint:1.67
	gdb_7_3_1-2011-09-04-release:1.67
	gdb_7_3-2011-07-26-release:1.67
	gdb_7_3-branch:1.67.0.2
	gdb_7_3-2011-04-01-branchpoint:1.67
	gdb_7_2-2010-09-02-release:1.63
	gdb_7_2-branch:1.63.0.4
	gdb_7_2-2010-07-07-branchpoint:1.63
	gdb_7_1-2010-03-18-release:1.63
	gdb_7_1-branch:1.63.0.2
	gdb_7_1-2010-02-18-branchpoint:1.63
	gdb_7_0_1-2009-12-22-release:1.62
	gdb_7_0-2009-10-06-release:1.62
	gdb_7_0-branch:1.62.0.4
	gdb_7_0-2009-09-16-branchpoint:1.62
	arc-sim-20090309:1.54
	msnyder-checkpoint-072509-branch:1.62.0.2
	msnyder-checkpoint-072509-branchpoint:1.62
	arc-insight_6_8-branch:1.54.0.6
	arc-insight_6_8-branchpoint:1.54
	insight_6_8-branch:1.54.0.4
	insight_6_8-branchpoint:1.54
	reverse-20081226-branch:1.57.0.6
	reverse-20081226-branchpoint:1.57
	multiprocess-20081120-branch:1.57.0.4
	multiprocess-20081120-branchpoint:1.57
	reverse-20080930-branch:1.57.0.2
	reverse-20080930-branchpoint:1.57
	reverse-20080717-branch:1.56.0.2
	reverse-20080717-branchpoint:1.56
	msnyder-reverse-20080609-branch:1.55.0.2
	msnyder-reverse-20080609-branchpoint:1.55
	drow-reverse-20070409-branch:1.43.0.2
	drow-reverse-20070409-branchpoint:1.43
	gdb_6_8-2008-03-27-release:1.54
	gdb_6_8-branch:1.54.0.2
	gdb_6_8-2008-02-26-branchpoint:1.54
	gdb_6_7_1-2007-10-29-release:1.48
	gdb_6_7-2007-10-10-release:1.48
	gdb_6_7-branch:1.48.0.2
	gdb_6_7-2007-09-07-branchpoint:1.48
	insight_6_6-20070208-release:1.41
	gdb_6_6-2006-12-18-release:1.41
	gdb_6_6-branch:1.41.0.10
	gdb_6_6-2006-11-15-branchpoint:1.41
	insight_6_5-20061003-release:1.41
	gdb-csl-symbian-6_4_50_20060226-12:1.40.8.1
	gdb-csl-sourcerygxx-3_4_4-25:1.39
	nickrob-async-20060828-mergepoint:1.41
	gdb-csl-symbian-6_4_50_20060226-11:1.40.8.1
	gdb-csl-sourcerygxx-4_1-17:1.40
	gdb-csl-20060226-branch-local-2:1.40
	gdb-csl-sourcerygxx-4_1-14:1.40
	gdb-csl-sourcerygxx-4_1-13:1.40
	gdb-csl-sourcerygxx-4_1-12:1.40
	gdb-csl-sourcerygxx-3_4_4-21:1.40
	gdb_6_5-20060621-release:1.41
	gdb-csl-sourcerygxx-4_1-9:1.40
	gdb-csl-sourcerygxx-4_1-8:1.40
	gdb-csl-sourcerygxx-4_1-7:1.40
	gdb-csl-arm-2006q1-6:1.40
	gdb-csl-sourcerygxx-4_1-6:1.40
	gdb-csl-symbian-6_4_50_20060226-10:1.40.8.1
	gdb-csl-symbian-6_4_50_20060226-9:1.40.8.1
	gdb-csl-symbian-6_4_50_20060226-8:1.40.8.1
	gdb-csl-coldfire-4_1-11:1.40
	gdb-csl-sourcerygxx-3_4_4-19:1.40
	gdb-csl-coldfire-4_1-10:1.40
	gdb_6_5-branch:1.41.0.8
	gdb_6_5-2006-05-14-branchpoint:1.41
	gdb-csl-sourcerygxx-4_1-5:1.40
	nickrob-async-20060513-branch:1.41.0.6
	nickrob-async-20060513-branchpoint:1.41
	gdb-csl-sourcerygxx-4_1-4:1.40
	msnyder-reverse-20060502-branch:1.41.0.4
	msnyder-reverse-20060502-branchpoint:1.41
	gdb-csl-morpho-4_1-4:1.40
	gdb-csl-sourcerygxx-3_4_4-17:1.40
	readline_5_1-import-branch:1.41.0.2
	readline_5_1-import-branchpoint:1.41
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.40
	gdb-csl-symbian-20060226-branch:1.40.0.8
	gdb-csl-symbian-20060226-branchpoint:1.40
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.40
	msnyder-reverse-20060331-branch:1.40.0.6
	msnyder-reverse-20060331-branchpoint:1.40
	gdb-csl-available-20060303-branch:1.40.0.4
	gdb-csl-available-20060303-branchpoint:1.40
	gdb-csl-20060226-branch:1.40.0.2
	gdb-csl-20060226-branchpoint:1.40
	gdb_6_4-20051202-release:1.38
	msnyder-fork-checkpoint-branch:1.39.0.4
	msnyder-fork-checkpoint-branchpoint:1.39
	gdb-csl-gxxpro-6_3-branch:1.39.0.2
	gdb-csl-gxxpro-6_3-branchpoint:1.39
	gdb_6_4-branch:1.38.0.6
	gdb_6_4-2005-11-01-branchpoint:1.38
	gdb-csl-arm-20051020-branch:1.38.0.4
	gdb-csl-arm-20051020-branchpoint:1.38
	msnyder-tracepoint-checkpoint-branch:1.38.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.38
	gdb-csl-arm-20050325-2005-q1b:1.37
	gdb-csl-arm-20050325-2005-q1a:1.37
	csl-arm-20050325-branch:1.37.0.2
	csl-arm-20050325-branchpoint:1.37
	gdb-post-i18n-errorwarning-20050211:1.37
	gdb-pre-i18n-errorwarning-20050211:1.37
	gdb_6_3-20041109-release:1.33.2.2
	gdb_6_3-branch:1.33.0.2
	gdb_6_3-20041019-branchpoint:1.33
	drow_intercu-merge-20040921:1.30
	drow_intercu-merge-20040915:1.30
	jimb-gdb_6_2-e500-branch:1.28.0.6
	jimb-gdb_6_2-e500-branchpoint:1.28
	gdb_6_2-20040730-release:1.28
	gdb_6_2-branch:1.28.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.28
	gdb_6_1_1-20040616-release:1.25
	gdb_6_1-2004-04-05-release:1.25
	drow_intercu-merge-20040402:1.25
	drow_intercu-merge-20040327:1.25
	ezannoni_pie-20040323-branch:1.25.0.8
	ezannoni_pie-20040323-branchpoint:1.25
	cagney_tramp-20040321-mergepoint:1.25
	cagney_tramp-20040309-branch:1.25.0.6
	cagney_tramp-20040309-branchpoint:1.25
	gdb_6_1-branch:1.25.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.25
	drow_intercu-20040221-branch:1.25.0.2
	drow_intercu-20040221-branchpoint:1.25
	cagney_bfdfile-20040213-branch:1.24.0.2
	cagney_bfdfile-20040213-branchpoint:1.24
	drow-cplus-merge-20040208:1.23
	carlton_dictionary-20040126-merge:1.22
	cagney_bigcore-20040122-branch:1.22.0.2
	cagney_bigcore-20040122-branchpoint:1.22
	drow-cplus-merge-20040113:1.20
	drow-cplus-merge-20031224:1.20
	drow-cplus-merge-20031220:1.20
	carlton_dictionary-20031215-merge:1.20
	drow-cplus-merge-20031214:1.20
	carlton-dictionary-20031111-merge:1.20
	gdb_6_0-2003-10-04-release:1.14.30.1
	kettenis_sparc-20030918-branch:1.18.0.4
	kettenis_sparc-20030918-branchpoint:1.18
	carlton_dictionary-20030917-merge:1.18
	ezannoni_pie-20030916-branchpoint:1.18
	ezannoni_pie-20030916-branch:1.18.0.2
	cagney_x86i386-20030821-branch:1.17.0.2
	cagney_x86i386-20030821-branchpoint:1.17
	carlton_dictionary-20030805-merge:1.17
	carlton_dictionary-20030627-merge:1.14
	gdb_6_0-branch:1.14.0.30
	gdb_6_0-2003-06-23-branchpoint:1.14
	jimb-ppc64-linux-20030613-branch:1.14.0.28
	jimb-ppc64-linux-20030613-branchpoint:1.14
	cagney_convert-20030606-branch:1.14.0.26
	cagney_convert-20030606-branchpoint:1.14
	cagney_writestrings-20030508-branch:1.14.0.24
	cagney_writestrings-20030508-branchpoint:1.14
	jimb-ppc64-linux-20030528-branch:1.14.0.22
	jimb-ppc64-linux-20030528-branchpoint:1.14
	carlton_dictionary-20030523-merge:1.14
	cagney_fileio-20030521-branch:1.14.0.20
	cagney_fileio-20030521-branchpoint:1.14
	kettenis_i386newframe-20030517-mergepoint:1.14
	jimb-ppc64-linux-20030509-branch:1.14.0.18
	jimb-ppc64-linux-20030509-branchpoint:1.14
	kettenis_i386newframe-20030504-mergepoint:1.14
	carlton_dictionary-20030430-merge:1.14
	kettenis_i386newframe-20030419-branch:1.14.0.16
	kettenis_i386newframe-20030419-branchpoint:1.14
	carlton_dictionary-20030416-merge:1.14
	cagney_frameaddr-20030409-mergepoint:1.14
	kettenis_i386newframe-20030406-branch:1.14.0.14
	kettenis_i386newframe-20030406-branchpoint:1.14
	cagney_frameaddr-20030403-branchpoint:1.14
	cagney_frameaddr-20030403-branch:1.14.0.12
	cagney_framebase-20030330-mergepoint:1.14
	cagney_framebase-20030326-branch:1.14.0.10
	cagney_framebase-20030326-branchpoint:1.14
	cagney_lazyid-20030317-branch:1.14.0.8
	cagney_lazyid-20030317-branchpoint:1.14
	kettenis-i386newframe-20030316-mergepoint:1.14
	offbyone-20030313-branch:1.14.0.6
	offbyone-20030313-branchpoint:1.14
	kettenis-i386newframe-20030308-branch:1.14.0.4
	kettenis-i386newframe-20030308-branchpoint:1.14
	carlton_dictionary-20030305-merge:1.14
	cagney_offbyone-20030303-branch:1.14.0.2
	cagney_offbyone-20030303-branchpoint:1.14
	carlton_dictionary-20030207-merge:1.14
	interps-20030203-mergepoint:1.13
	interps-20030202-branch:1.13.0.2
	interps-20030202-branchpoint:1.13
	cagney-unwind-20030108-branch:1.12.0.2
	cagney-unwind-20030108-branchpoint:1.12
	carlton_dictionary-20021223-merge:1.11
	gdb_5_3-2002-12-12-release:1.8
	carlton_dictionary-20021115-merge:1.9
	kseitz_interps-20021105-merge:1.9
	kseitz_interps-20021103-merge:1.9
	drow-cplus-merge-20021020:1.9
	drow-cplus-merge-20021025:1.9
	carlton_dictionary-20021025-merge:1.9
	carlton_dictionary-20021011-merge:1.9
	drow-cplus-branch:1.9.0.4
	drow-cplus-branchpoint:1.9
	kseitz_interps-20020930-merge:1.9
	carlton_dictionary-20020927-merge:1.9
	carlton_dictionary-branch:1.9.0.2
	carlton_dictionary-20020920-branchpoint:1.9
	gdb_5_3-branch:1.8.0.6
	gdb_5_3-2002-09-04-branchpoint:1.8
	kseitz_interps-20020829-merge:1.8
	cagney_sysregs-20020825-branch:1.8.0.4
	cagney_sysregs-20020825-branchpoint:1.8
	readline_4_3-import-branch:1.8.0.2
	readline_4_3-import-branchpoint:1.8
	gdb_5_2_1-2002-07-23-release:1.7
	kseitz_interps-20020528-branch:1.7.0.8
	kseitz_interps-20020528-branchpoint:1.7
	cagney_regbuf-20020515-branch:1.7.0.6
	cagney_regbuf-20020515-branchpoint:1.7
	jimb-macro-020506-branch:1.7.0.4
	jimb-macro-020506-branchpoint:1.7
	gdb_5_2-2002-04-29-release:1.7
	gdb_5_2-branch:1.7.0.2
	gdb_5_2-2002-03-03-branchpoint:1.7
	gdb_5_1_1-2002-01-24-release:1.6
	gdb_5_1_0_1-2002-01-03-release:1.6
	cygnus_cvs_20020108_pre:1.7
	gdb_5_1_0_1-2002-01-03-branchpoint:1.6
	gdb_5_1_0_1-2002-01-03-branch:1.6.0.6
	gdb_5_1-2001-11-21-release:1.6
	gdb_s390-2001-09-26-branch:1.6.0.4
	gdb_s390-2001-09-26-branchpoint:1.6
	gdb_5_1-2001-07-29-branch:1.6.0.2
	gdb_5_1-2001-07-29-branchpoint:1.6
	dberlin-typesystem-branch:1.5.0.2
	dberlin-typesystem-branchpoint:1.5
	gdb-post-ptid_t-2001-05-03:1.5
	gdb-pre-ptid_t-2001-05-03:1.5
	insight-precleanup-2001-01-01:1.2
	gdb-post-protoization-2000-07-29:1.2
	gdb-pre-protoization-2000-07-29:1.1.1.5
	gdb-premipsmulti-2000-06-06-branch:1.1.1.5.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.5
	gdb-post-params-removal-2000-06-04:1.1.1.5
	gdb-pre-params-removal-2000-06-04:1.1.1.5
	gdb-post-params-removal-2000-05-28:1.1.1.5
	gdb-pre-params-removal-2000-05-28:1.1.1.5
	gdb_5_0-2000-05-19-release:1.1.1.5
	gdb_4_18_2-2000-05-18-release:1.1.1.5
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.5
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.5
	gdb_5_0-2000-04-10-branch:1.1.1.5.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.5
	repo-unification-2000-02-06:1.1.1.5
	insight-2000-02-04:1.1.1.5
	gdb-2000-02-04:1.1.1.5
	gdb-2000-02-02:1.1.1.5
	gdb-2000-02-01:1.1.1.5
	gdb-2000-01-31:1.1.1.5
	gdb-2000-01-26:1.1.1.5
	gdb-2000-01-24:1.1.1.5
	gdb-2000-01-17:1.1.1.5
	gdb-2000-01-10:1.1.1.5
	gdb-2000-01-05:1.1.1.5
	gdb-1999-12-21:1.1.1.5
	gdb-1999-12-13:1.1.1.5
	gdb-1999-12-07:1.1.1.5
	gdb-1999-12-06:1.1.1.5
	gdb-1999-11-16:1.1.1.5
	gdb-1999-11-08:1.1.1.5
	gdb-1999-11-01:1.1.1.5
	gdb-1999-10-25:1.1.1.5
	gdb-1999-10-18:1.1.1.5
	gdb-1999-10-11:1.1.1.5
	gdb-1999-10-04:1.1.1.5
	gdb-1999-09-28:1.1.1.5
	gdb-1999-09-21:1.1.1.5
	gdb-1999-09-13:1.1.1.5
	gdb-1999-09-08:1.1.1.4
	gdb-1999-08-30:1.1.1.3
	gdb-1999-08-23:1.1.1.3
	gdb-1999-08-16:1.1.1.3
	gdb-1999-08-09:1.1.1.3
	gdb-1999-08-02:1.1.1.3
	gdb-1999-07-26:1.1.1.3
	gdb-1999-07-19:1.1.1.3
	gdb-1999-07-12:1.1.1.3
	gdb-post-reformat-19990707:1.1.1.3
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.3
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.74
date	2013.04.29.10.08.46;	author brobecke;	state Exp;
branches;
next	1.73;

1.73
date	2013.01.01.06.32.46;	author brobecke;	state Exp;
branches;
next	1.72;

1.72
date	2012.05.18.21.02.49;	author sergiodj;	state Exp;
branches;
next	1.71;

1.71
date	2012.05.16.14.35.06;	author macro;	state Exp;
branches;
next	1.70;

1.70
date	2012.03.15.18.33.45;	author brobecke;	state Exp;
branches;
next	1.69;

1.69
date	2012.01.04.08.17.05;	author brobecke;	state Exp;
branches;
next	1.68;

1.68
date	2011.12.14.14.55.27;	author palves;	state Exp;
branches;
next	1.67;

1.67
date	2011.03.18.18.52.31;	author palves;	state Exp;
branches
	1.67.4.1;
next	1.66;

1.66
date	2011.01.31.20.21.02;	author msnyder;	state Exp;
branches;
next	1.65;

1.65
date	2011.01.09.03.20.33;	author msnyder;	state Exp;
branches;
next	1.64;

1.64
date	2011.01.01.15.33.10;	author brobecke;	state Exp;
branches;
next	1.63;

1.63
date	2010.01.01.07.31.37;	author brobecke;	state Exp;
branches;
next	1.62;

1.62
date	2009.07.02.17.25.55;	author uweigand;	state Exp;
branches;
next	1.61;

1.61
date	2009.07.02.12.46.19;	author uweigand;	state Exp;
branches;
next	1.60;

1.60
date	2009.05.28.00.53.51;	author tromey;	state Exp;
branches;
next	1.59;

1.59
date	2009.02.22.01.02.17;	author palves;	state Exp;
branches;
next	1.58;

1.58
date	2009.01.03.05.57.52;	author brobecke;	state Exp;
branches;
next	1.57;

1.57
date	2008.09.11.14.23.15;	author uweigand;	state Exp;
branches;
next	1.56;

1.56
date	2008.06.28.17.29.02;	author uweigand;	state Exp;
branches;
next	1.55;

1.55
date	2008.04.22.11.03.42;	author corinna;	state Exp;
branches;
next	1.54;

1.54
date	2008.02.20.14.31.40;	author deuling;	state Exp;
branches;
next	1.53;

1.53
date	2008.01.11.13.20.01;	author deuling;	state Exp;
branches;
next	1.52;

1.52
date	2008.01.01.22.53.11;	author drow;	state Exp;
branches;
next	1.51;

1.51
date	2007.11.07.06.33.00;	author deuling;	state Exp;
branches;
next	1.50;

1.50
date	2007.11.02.14.27.14;	author uweigand;	state Exp;
branches;
next	1.49;

1.49
date	2007.10.16.06.39.30;	author kevinb;	state Exp;
branches;
next	1.48;

1.48
date	2007.08.23.18.08.35;	author brobecke;	state Exp;
branches;
next	1.47;

1.47
date	2007.06.15.22.44.55;	author uweigand;	state Exp;
branches;
next	1.46;

1.46
date	2007.05.31.20.57.41;	author uweigand;	state Exp;
branches;
next	1.45;

1.45
date	2007.05.31.17.32.21;	author uweigand;	state Exp;
branches;
next	1.44;

1.44
date	2007.05.11.19.57.17;	author uweigand;	state Exp;
branches;
next	1.43;

1.43
date	2007.02.27.20.17.19;	author drow;	state Exp;
branches;
next	1.42;

1.42
date	2007.01.09.17.58.52;	author drow;	state Exp;
branches;
next	1.41;

1.41
date	2006.04.18.19.20.06;	author drow;	state Exp;
branches;
next	1.40;

1.40
date	2005.12.17.22.34.01;	author eliz;	state Exp;
branches
	1.40.8.1;
next	1.39;

1.39
date	2005.11.08.05.54.22;	author ksakamot;	state Exp;
branches;
next	1.38;

1.38
date	2005.05.01.19.58.54;	author cagney;	state Exp;
branches;
next	1.37;

1.37
date	2005.02.07.00.09.54;	author cagney;	state Exp;
branches;
next	1.36;

1.36
date	2004.11.13.02.15.32;	author cagney;	state Exp;
branches;
next	1.35;

1.35
date	2004.11.04.02.15.20;	author ksakamot;	state Exp;
branches;
next	1.34;

1.34
date	2004.11.04.00.40.39;	author ksakamot;	state Exp;
branches;
next	1.33;

1.33
date	2004.10.07.01.21.53;	author ksakamot;	state Exp;
branches
	1.33.2.1;
next	1.32;

1.32
date	2004.10.05.04.07.10;	author ksakamot;	state Exp;
branches;
next	1.31;

1.31
date	2004.10.01.07.29.34;	author ksakamot;	state Exp;
branches;
next	1.30;

1.30
date	2004.08.02.19.44.40;	author cagney;	state Exp;
branches;
next	1.29;

1.29
date	2004.07.31.21.53.17;	author cagney;	state Exp;
branches;
next	1.28;

1.28
date	2004.06.20.17.18.05;	author cagney;	state Exp;
branches;
next	1.27;

1.27
date	2004.06.07.02.02.50;	author tausq;	state Exp;
branches;
next	1.26;

1.26
date	2004.04.22.17.02.31;	author cagney;	state Exp;
branches;
next	1.25;

1.25
date	2004.02.16.21.49.22;	author cagney;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2004.02.11.15.40.27;	author cagney;	state Exp;
branches;
next	1.23;

1.23
date	2004.01.26.20.52.11;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2004.01.17.15.34.12;	author cagney;	state Exp;
branches;
next	1.21;

1.21
date	2004.01.13.21.38.46;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2003.10.31.23.47.17;	author cagney;	state Exp;
branches;
next	1.19;

1.19
date	2003.10.08.02.41.49;	author ksakamot;	state Exp;
branches;
next	1.18;

1.18
date	2003.09.12.18.40.17;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2003.08.01.21.14.33;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2003.07.27.15.38.16;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2003.07.21.18.56.05;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.04.23.26.43;	author cagney;	state Exp;
branches
	1.14.30.1;
next	1.13;

1.13
date	2003.01.14.00.49.04;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2003.01.06.21.50.25;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2002.12.11.02.26.36;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2002.12.01.19.07.15;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.17.20.42.01;	author cagney;	state Exp;
branches
	1.9.2.1
	1.9.4.1;
next	1.8;

1.8
date	2002.07.29.16.34.06;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.05.23.44.43;	author ezannoni;	state Exp;
branches
	1.7.8.1;
next	1.6;

1.6
date	2001.07.15.20.10.02;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.06.08.21.09;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.01.22.10.04;	author msnyder;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.30.01.48.26;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.67.4.1
date	2011.12.14.14.56.23;	author palves;	state Exp;
branches;
next	1.67.4.2;

1.67.4.2
date	2012.01.06.04.43.19;	author brobecke;	state Exp;
branches;
next	;

1.40.8.1
date	2006.04.11.21.58.23;	author drow;	state Exp;
branches;
next	;

1.33.2.1
date	2004.11.04.00.48.01;	author ksakamot;	state Exp;
branches;
next	1.33.2.2;

1.33.2.2
date	2004.11.04.02.18.49;	author ksakamot;	state Exp;
branches;
next	;

1.25.2.1
date	2004.09.16.17.01.12;	author drow;	state Exp;
branches;
next	;

1.14.30.1
date	2003.08.01.21.56.58;	author cagney;	state Exp;
branches;
next	;

1.9.2.1
date	2002.12.23.19.38.33;	author carlton;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2003.02.07.19.17.50;	author carlton;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2003.08.05.17.13.10;	author carlton;	state Exp;
branches;
next	1.9.2.4;

1.9.2.4
date	2003.09.17.21.28.25;	author carlton;	state Exp;
branches;
next	1.9.2.5;

1.9.2.5
date	2003.11.11.23.50.48;	author carlton;	state Exp;
branches;
next	1.9.2.6;

1.9.2.6
date	2004.01.26.19.11.27;	author carlton;	state Exp;
branches;
next	;

1.9.4.1
date	2003.12.14.20.27.20;	author drow;	state Exp;
branches;
next	1.9.4.2;

1.9.4.2
date	2004.02.09.19.43.43;	author drow;	state Exp;
branches;
next	;

1.7.8.1
date	2002.08.09.18.34.25;	author kseitz;	state Exp;
branches;
next	1.7.8.2;

1.7.8.2
date	2002.10.01.00.46.10;	author kseitz;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.24.42;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.07.20.07.47;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.09.08.23.59.19;	author shebs;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.09.13.21.37.32;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.74
log
@Use gdbarch_pc_regnum instead of gdbarch_write_pc.

gdb/ChangeLog:

	* m32r-tdep.c (m32r_write_pc): Delete.
	(m32r_gdbarch_init): Remove call to set_gdbarch_write_pc.
	Add call to set_gdbarch_pc_regnum.
@
text
@/* Target-dependent code for Renesas M32R, for GDB.

   Copyright (C) 1996-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "frame.h"
#include "frame-unwind.h"
#include "frame-base.h"
#include "symtab.h"
#include "gdbtypes.h"
#include "gdbcmd.h"
#include "gdbcore.h"
#include "gdb_string.h"
#include "value.h"
#include "inferior.h"
#include "symfile.h"
#include "objfiles.h"
#include "osabi.h"
#include "language.h"
#include "arch-utils.h"
#include "regcache.h"
#include "trad-frame.h"
#include "dis-asm.h"

#include "gdb_assert.h"

#include "m32r-tdep.h"

/* Local functions */

extern void _initialize_m32r_tdep (void);

static CORE_ADDR
m32r_frame_align (struct gdbarch *gdbarch, CORE_ADDR sp)
{
  /* Align to the size of an instruction (so that they can safely be
     pushed onto the stack.  */
  return sp & ~3;
}


/* Breakpoints
 
   The little endian mode of M32R is unique.  In most of architectures,
   two 16-bit instructions, A and B, are placed as the following:
  
   Big endian:
   A0 A1 B0 B1
  
   Little endian:
   A1 A0 B1 B0
  
   In M32R, they are placed like this:
  
   Big endian:
   A0 A1 B0 B1
  
   Little endian:
   B1 B0 A1 A0
  
   This is because M32R always fetches instructions in 32-bit.
  
   The following functions take care of this behavior.  */

static int
m32r_memory_insert_breakpoint (struct gdbarch *gdbarch,
			       struct bp_target_info *bp_tgt)
{
  CORE_ADDR addr = bp_tgt->placed_address;
  int val;
  gdb_byte buf[4];
  gdb_byte contents_cache[4];
  gdb_byte bp_entry[] = { 0x10, 0xf1 };	/* dpt */

  /* Save the memory contents.  */
  val = target_read_memory (addr & 0xfffffffc, contents_cache, 4);
  if (val != 0)
    return val;			/* return error */

  memcpy (bp_tgt->shadow_contents, contents_cache, 4);
  bp_tgt->placed_size = bp_tgt->shadow_len = 4;

  /* Determine appropriate breakpoint contents and size for this address.  */
  if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
    {
      if ((addr & 3) == 0)
	{
	  buf[0] = bp_entry[0];
	  buf[1] = bp_entry[1];
	  buf[2] = contents_cache[2] & 0x7f;
	  buf[3] = contents_cache[3];
	}
      else
	{
	  buf[0] = contents_cache[0];
	  buf[1] = contents_cache[1];
	  buf[2] = bp_entry[0];
	  buf[3] = bp_entry[1];
	}
    }
  else				/* little-endian */
    {
      if ((addr & 3) == 0)
	{
	  buf[0] = contents_cache[0];
	  buf[1] = contents_cache[1] & 0x7f;
	  buf[2] = bp_entry[1];
	  buf[3] = bp_entry[0];
	}
      else
	{
	  buf[0] = bp_entry[1];
	  buf[1] = bp_entry[0];
	  buf[2] = contents_cache[2];
	  buf[3] = contents_cache[3];
	}
    }

  /* Write the breakpoint.  */
  val = target_write_memory (addr & 0xfffffffc, buf, 4);
  return val;
}

static int
m32r_memory_remove_breakpoint (struct gdbarch *gdbarch,
			       struct bp_target_info *bp_tgt)
{
  CORE_ADDR addr = bp_tgt->placed_address;
  int val;
  gdb_byte buf[4];
  gdb_byte *contents_cache = bp_tgt->shadow_contents;

  buf[0] = contents_cache[0];
  buf[1] = contents_cache[1];
  buf[2] = contents_cache[2];
  buf[3] = contents_cache[3];

  /* Remove parallel bit.  */
  if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
    {
      if ((buf[0] & 0x80) == 0 && (buf[2] & 0x80) != 0)
	buf[2] &= 0x7f;
    }
  else				/* little-endian */
    {
      if ((buf[3] & 0x80) == 0 && (buf[1] & 0x80) != 0)
	buf[1] &= 0x7f;
    }

  /* Write contents.  */
  val = target_write_raw_memory (addr & 0xfffffffc, buf, 4);
  return val;
}

static const gdb_byte *
m32r_breakpoint_from_pc (struct gdbarch *gdbarch,
			 CORE_ADDR *pcptr, int *lenptr)
{
  static gdb_byte be_bp_entry[] = {
    0x10, 0xf1, 0x70, 0x00
  };	/* dpt -> nop */
  static gdb_byte le_bp_entry[] = {
    0x00, 0x70, 0xf1, 0x10
  };	/* dpt -> nop */
  gdb_byte *bp;

  /* Determine appropriate breakpoint.  */
  if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
    {
      if ((*pcptr & 3) == 0)
	{
	  bp = be_bp_entry;
	  *lenptr = 4;
	}
      else
	{
	  bp = be_bp_entry;
	  *lenptr = 2;
	}
    }
  else
    {
      if ((*pcptr & 3) == 0)
	{
	  bp = le_bp_entry;
	  *lenptr = 4;
	}
      else
	{
	  bp = le_bp_entry + 2;
	  *lenptr = 2;
	}
    }

  return bp;
}


char *m32r_register_names[] = {
  "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
  "r8", "r9", "r10", "r11", "r12", "fp", "lr", "sp",
  "psw", "cbr", "spi", "spu", "bpc", "pc", "accl", "acch",
  "evb"
};

static const char *
m32r_register_name (struct gdbarch *gdbarch, int reg_nr)
{
  if (reg_nr < 0)
    return NULL;
  if (reg_nr >= M32R_NUM_REGS)
    return NULL;
  return m32r_register_names[reg_nr];
}


/* Return the GDB type object for the "standard" data type
   of data in register N.  */

static struct type *
m32r_register_type (struct gdbarch *gdbarch, int reg_nr)
{
  if (reg_nr == M32R_PC_REGNUM)
    return builtin_type (gdbarch)->builtin_func_ptr;
  else if (reg_nr == M32R_SP_REGNUM || reg_nr == M32R_FP_REGNUM)
    return builtin_type (gdbarch)->builtin_data_ptr;
  else
    return builtin_type (gdbarch)->builtin_int32;
}


/* Write into appropriate registers a function return value
   of type TYPE, given in virtual format.

   Things always get returned in RET1_REGNUM, RET2_REGNUM.  */

static void
m32r_store_return_value (struct type *type, struct regcache *regcache,
			 const void *valbuf)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  CORE_ADDR regval;
  int len = TYPE_LENGTH (type);

  regval = extract_unsigned_integer (valbuf, len > 4 ? 4 : len, byte_order);
  regcache_cooked_write_unsigned (regcache, RET1_REGNUM, regval);

  if (len > 4)
    {
      regval = extract_unsigned_integer ((gdb_byte *) valbuf + 4,
					 len - 4, byte_order);
      regcache_cooked_write_unsigned (regcache, RET1_REGNUM + 1, regval);
    }
}

/* This is required by skip_prologue.  The results of decoding a prologue
   should be cached because this thrashing is getting nuts.  */

static int
decode_prologue (struct gdbarch *gdbarch,
		 CORE_ADDR start_pc, CORE_ADDR scan_limit,
		 CORE_ADDR *pl_endptr, unsigned long *framelength)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  unsigned long framesize;
  int insn;
  int op1;
  CORE_ADDR after_prologue = 0;
  CORE_ADDR after_push = 0;
  CORE_ADDR after_stack_adjust = 0;
  CORE_ADDR current_pc;
  LONGEST return_value;

  framesize = 0;
  after_prologue = 0;

  for (current_pc = start_pc; current_pc < scan_limit; current_pc += 2)
    {
      /* Check if current pc's location is readable.  */
      if (!safe_read_memory_integer (current_pc, 2, byte_order, &return_value))
	return -1;

      insn = read_memory_unsigned_integer (current_pc, 2, byte_order);

      if (insn == 0x0000)
	break;

      /* If this is a 32 bit instruction, we dont want to examine its
         immediate data as though it were an instruction.  */
      if (current_pc & 0x02)
	{
	  /* Decode this instruction further.  */
	  insn &= 0x7fff;
	}
      else
	{
	  if (insn & 0x8000)
	    {
	      if (current_pc == scan_limit)
		scan_limit += 2;	/* extend the search */

	      current_pc += 2;	/* skip the immediate data */

	      /* Check if current pc's location is readable.  */
	      if (!safe_read_memory_integer (current_pc, 2, byte_order,
					     &return_value))
		return -1;

	      if (insn == 0x8faf)	/* add3 sp, sp, xxxx */
		/* add 16 bit sign-extended offset */
		{
		  framesize +=
		    -((short) read_memory_unsigned_integer (current_pc,
							    2, byte_order));
		}
	      else
		{
		  if (((insn >> 8) == 0xe4) /* ld24 r4, xxxxxx; sub sp, r4 */
		      && safe_read_memory_integer (current_pc + 2,
						   2, byte_order,
						   &return_value)
		      && read_memory_unsigned_integer (current_pc + 2,
						       2, byte_order)
			 == 0x0f24)
		    {
		      /* Subtract 24 bit sign-extended negative-offset.  */
		      insn = read_memory_unsigned_integer (current_pc - 2,
							   4, byte_order);
		      if (insn & 0x00800000)	/* sign extend */
			insn |= 0xff000000;	/* negative */
		      else
			insn &= 0x00ffffff;	/* positive */
		      framesize += insn;
		    }
		}
	      after_push = current_pc + 2;
	      continue;
	    }
	}
      op1 = insn & 0xf000;	/* Isolate just the first nibble.  */

      if ((insn & 0xf0ff) == 0x207f)
	{			/* st reg, @@-sp */
	  int regno;
	  framesize += 4;
	  regno = ((insn >> 8) & 0xf);
	  after_prologue = 0;
	  continue;
	}
      if ((insn >> 8) == 0x4f)	/* addi sp, xx */
	/* Add 8 bit sign-extended offset.  */
	{
	  int stack_adjust = (signed char) (insn & 0xff);

	  /* there are probably two of these stack adjustments:
	     1) A negative one in the prologue, and
	     2) A positive one in the epilogue.
	     We are only interested in the first one.  */

	  if (stack_adjust < 0)
	    {
	      framesize -= stack_adjust;
	      after_prologue = 0;
	      /* A frameless function may have no "mv fp, sp".
	         In that case, this is the end of the prologue.  */
	      after_stack_adjust = current_pc + 2;
	    }
	  continue;
	}
      if (insn == 0x1d8f)
	{			/* mv fp, sp */
	  after_prologue = current_pc + 2;
	  break;		/* end of stack adjustments */
	}

      /* Nop looks like a branch, continue explicitly.  */
      if (insn == 0x7000)
	{
	  after_prologue = current_pc + 2;
	  continue;		/* nop occurs between pushes.  */
	}
      /* End of prolog if any of these are trap instructions.  */
      if ((insn & 0xfff0) == 0x10f0)
	{
	  after_prologue = current_pc;
	  break;
	}
      /* End of prolog if any of these are branch instructions.  */
      if ((op1 == 0x7000) || (op1 == 0xb000) || (op1 == 0xf000))
	{
	  after_prologue = current_pc;
	  continue;
	}
      /* Some of the branch instructions are mixed with other types.  */
      if (op1 == 0x1000)
	{
	  int subop = insn & 0x0ff0;
	  if ((subop == 0x0ec0) || (subop == 0x0fc0))
	    {
	      after_prologue = current_pc;
	      continue;		/* jmp , jl */
	    }
	}
    }

  if (framelength)
    *framelength = framesize;

  if (current_pc >= scan_limit)
    {
      if (pl_endptr)
	{
	  if (after_stack_adjust != 0)
	    /* We did not find a "mv fp,sp", but we DID find
	       a stack_adjust.  Is it safe to use that as the
	       end of the prologue?  I just don't know.  */
	    {
	      *pl_endptr = after_stack_adjust;
	    }
	  else if (after_push != 0)
	    /* We did not find a "mv fp,sp", but we DID find
	       a push.  Is it safe to use that as the
	       end of the prologue?  I just don't know.  */
	    {
	      *pl_endptr = after_push;
	    }
	  else
	    /* We reached the end of the loop without finding the end
	       of the prologue.  No way to win -- we should report
	       failure.  The way we do that is to return the original
	       start_pc.  GDB will set a breakpoint at the start of
	       the function (etc.)  */
	    *pl_endptr = start_pc;
	}
      return 0;
    }

  if (after_prologue == 0)
    after_prologue = current_pc;

  if (pl_endptr)
    *pl_endptr = after_prologue;

  return 0;
}				/*  decode_prologue */

/* Function: skip_prologue
   Find end of function prologue.  */

#define DEFAULT_SEARCH_LIMIT 128

static CORE_ADDR
m32r_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  CORE_ADDR func_addr, func_end;
  struct symtab_and_line sal;
  LONGEST return_value;

  /* See what the symbol table says.  */

  if (find_pc_partial_function (pc, NULL, &func_addr, &func_end))
    {
      sal = find_pc_line (func_addr, 0);

      if (sal.line != 0 && sal.end <= func_end)
	{
	  func_end = sal.end;
	}
      else
	/* Either there's no line info, or the line after the prologue is after
	   the end of the function.  In this case, there probably isn't a
	   prologue.  */
	{
	  func_end = min (func_end, func_addr + DEFAULT_SEARCH_LIMIT);
	}
    }
  else
    func_end = pc + DEFAULT_SEARCH_LIMIT;

  /* If pc's location is not readable, just quit.  */
  if (!safe_read_memory_integer (pc, 4, byte_order, &return_value))
    return pc;

  /* Find the end of prologue.  */
  if (decode_prologue (gdbarch, pc, func_end, &sal.end, NULL) < 0)
    return pc;

  return sal.end;
}

struct m32r_unwind_cache
{
  /* The previous frame's inner most stack address.  Used as this
     frame ID's stack_addr.  */
  CORE_ADDR prev_sp;
  /* The frame's base, optionally used by the high-level debug info.  */
  CORE_ADDR base;
  int size;
  /* How far the SP and r13 (FP) have been offset from the start of
     the stack frame (as defined by the previous frame's stack
     pointer).  */
  LONGEST sp_offset;
  LONGEST r13_offset;
  int uses_frame;
  /* Table indicating the location of each and every register.  */
  struct trad_frame_saved_reg *saved_regs;
};

/* Put here the code to store, into fi->saved_regs, the addresses of
   the saved registers of frame described by FRAME_INFO.  This
   includes special registers such as pc and fp saved in special ways
   in the stack frame.  sp is even more special: the address we return
   for it IS the sp for the next frame.  */

static struct m32r_unwind_cache *
m32r_frame_unwind_cache (struct frame_info *this_frame,
			 void **this_prologue_cache)
{
  CORE_ADDR pc, scan_limit;
  ULONGEST prev_sp;
  ULONGEST this_base;
  unsigned long op;
  int i;
  struct m32r_unwind_cache *info;


  if ((*this_prologue_cache))
    return (*this_prologue_cache);

  info = FRAME_OBSTACK_ZALLOC (struct m32r_unwind_cache);
  (*this_prologue_cache) = info;
  info->saved_regs = trad_frame_alloc_saved_regs (this_frame);

  info->size = 0;
  info->sp_offset = 0;
  info->uses_frame = 0;

  scan_limit = get_frame_pc (this_frame);
  for (pc = get_frame_func (this_frame);
       pc > 0 && pc < scan_limit; pc += 2)
    {
      if ((pc & 2) == 0)
	{
	  op = get_frame_memory_unsigned (this_frame, pc, 4);
	  if ((op & 0x80000000) == 0x80000000)
	    {
	      /* 32-bit instruction */
	      if ((op & 0xffff0000) == 0x8faf0000)
		{
		  /* add3 sp,sp,xxxx */
		  short n = op & 0xffff;
		  info->sp_offset += n;
		}
	      else if (((op >> 8) == 0xe4)
		       && get_frame_memory_unsigned (this_frame, pc + 2,
						     2) == 0x0f24)
		{
		  /* ld24 r4, xxxxxx; sub sp, r4 */
		  unsigned long n = op & 0xffffff;
		  info->sp_offset += n;
		  pc += 2;	/* skip sub instruction */
		}

	      if (pc == scan_limit)
		scan_limit += 2;	/* extend the search */
	      pc += 2;		/* skip the immediate data */
	      continue;
	    }
	}

      /* 16-bit instructions */
      op = get_frame_memory_unsigned (this_frame, pc, 2) & 0x7fff;
      if ((op & 0xf0ff) == 0x207f)
	{
	  /* st rn, @@-sp */
	  int regno = ((op >> 8) & 0xf);
	  info->sp_offset -= 4;
	  info->saved_regs[regno].addr = info->sp_offset;
	}
      else if ((op & 0xff00) == 0x4f00)
	{
	  /* addi sp, xx */
	  int n = (signed char) (op & 0xff);
	  info->sp_offset += n;
	}
      else if (op == 0x1d8f)
	{
	  /* mv fp, sp */
	  info->uses_frame = 1;
	  info->r13_offset = info->sp_offset;
	  break;		/* end of stack adjustments */
	}
      else if ((op & 0xfff0) == 0x10f0)
	{
	  /* End of prologue if this is a trap instruction.  */
	  break;		/* End of stack adjustments.  */
	}
    }

  info->size = -info->sp_offset;

  /* Compute the previous frame's stack pointer (which is also the
     frame's ID's stack address), and this frame's base pointer.  */
  if (info->uses_frame)
    {
      /* The SP was moved to the FP.  This indicates that a new frame
         was created.  Get THIS frame's FP value by unwinding it from
         the next frame.  */
      this_base = get_frame_register_unsigned (this_frame, M32R_FP_REGNUM);
      /* The FP points at the last saved register.  Adjust the FP back
         to before the first saved register giving the SP.  */
      prev_sp = this_base + info->size;
    }
  else
    {
      /* Assume that the FP is this frame's SP but with that pushed
         stack space added back.  */
      this_base = get_frame_register_unsigned (this_frame, M32R_SP_REGNUM);
      prev_sp = this_base + info->size;
    }

  /* Convert that SP/BASE into real addresses.  */
  info->prev_sp = prev_sp;
  info->base = this_base;

  /* Adjust all the saved registers so that they contain addresses and
     not offsets.  */
  for (i = 0; i < gdbarch_num_regs (get_frame_arch (this_frame)) - 1; i++)
    if (trad_frame_addr_p (info->saved_regs, i))
      info->saved_regs[i].addr = (info->prev_sp + info->saved_regs[i].addr);

  /* The call instruction moves the caller's PC in the callee's LR.
     Since this is an unwind, do the reverse.  Copy the location of LR
     into PC (the address / regnum) so that a request for PC will be
     converted into a request for the LR.  */
  info->saved_regs[M32R_PC_REGNUM] = info->saved_regs[LR_REGNUM];

  /* The previous frame's SP needed to be computed.  Save the computed
     value.  */
  trad_frame_set_value (info->saved_regs, M32R_SP_REGNUM, prev_sp);

  return info;
}

static CORE_ADDR
m32r_read_pc (struct regcache *regcache)
{
  ULONGEST pc;
  regcache_cooked_read_unsigned (regcache, M32R_PC_REGNUM, &pc);
  return pc;
}

static CORE_ADDR
m32r_unwind_sp (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  return frame_unwind_register_unsigned (next_frame, M32R_SP_REGNUM);
}


static CORE_ADDR
m32r_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
		      struct regcache *regcache, CORE_ADDR bp_addr, int nargs,
		      struct value **args, CORE_ADDR sp, int struct_return,
		      CORE_ADDR struct_addr)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  int stack_offset, stack_alloc;
  int argreg = ARG1_REGNUM;
  int argnum;
  struct type *type;
  enum type_code typecode;
  CORE_ADDR regval;
  gdb_byte *val;
  gdb_byte valbuf[MAX_REGISTER_SIZE];
  int len;

  /* First force sp to a 4-byte alignment.  */
  sp = sp & ~3;

  /* Set the return address.  For the m32r, the return breakpoint is
     always at BP_ADDR.  */
  regcache_cooked_write_unsigned (regcache, LR_REGNUM, bp_addr);

  /* If STRUCT_RETURN is true, then the struct return address (in
     STRUCT_ADDR) will consume the first argument-passing register.
     Both adjust the register count and store that value.  */
  if (struct_return)
    {
      regcache_cooked_write_unsigned (regcache, argreg, struct_addr);
      argreg++;
    }

  /* Now make sure there's space on the stack.  */
  for (argnum = 0, stack_alloc = 0; argnum < nargs; argnum++)
    stack_alloc += ((TYPE_LENGTH (value_type (args[argnum])) + 3) & ~3);
  sp -= stack_alloc;		/* Make room on stack for args.  */

  for (argnum = 0, stack_offset = 0; argnum < nargs; argnum++)
    {
      type = value_type (args[argnum]);
      typecode = TYPE_CODE (type);
      len = TYPE_LENGTH (type);

      memset (valbuf, 0, sizeof (valbuf));

      /* Passes structures that do not fit in 2 registers by reference.  */
      if (len > 8
	  && (typecode == TYPE_CODE_STRUCT || typecode == TYPE_CODE_UNION))
	{
	  store_unsigned_integer (valbuf, 4, byte_order,
				  value_address (args[argnum]));
	  typecode = TYPE_CODE_PTR;
	  len = 4;
	  val = valbuf;
	}
      else if (len < 4)
	{
	  /* Value gets right-justified in the register or stack word.  */
	  memcpy (valbuf + (register_size (gdbarch, argreg) - len),
		  (gdb_byte *) value_contents (args[argnum]), len);
	  val = valbuf;
	}
      else
	val = (gdb_byte *) value_contents (args[argnum]);

      while (len > 0)
	{
	  if (argreg > ARGN_REGNUM)
	    {
	      /* Must go on the stack.  */
	      write_memory (sp + stack_offset, val, 4);
	      stack_offset += 4;
	    }
	  else if (argreg <= ARGN_REGNUM)
	    {
	      /* There's room in a register.  */
	      regval =
		extract_unsigned_integer (val,
					  register_size (gdbarch, argreg),
					  byte_order);
	      regcache_cooked_write_unsigned (regcache, argreg++, regval);
	    }

	  /* Store the value 4 bytes at a time.  This means that things
	     larger than 4 bytes may go partly in registers and partly
	     on the stack.  */
	  len -= register_size (gdbarch, argreg);
	  val += register_size (gdbarch, argreg);
	}
    }

  /* Finally, update the SP register.  */
  regcache_cooked_write_unsigned (regcache, M32R_SP_REGNUM, sp);

  return sp;
}


/* Given a return value in `regbuf' with a type `valtype', 
   extract and copy its value into `valbuf'.  */

static void
m32r_extract_return_value (struct type *type, struct regcache *regcache,
			   void *dst)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  bfd_byte *valbuf = dst;
  int len = TYPE_LENGTH (type);
  ULONGEST tmp;

  /* By using store_unsigned_integer we avoid having to do
     anything special for small big-endian values.  */
  regcache_cooked_read_unsigned (regcache, RET1_REGNUM, &tmp);
  store_unsigned_integer (valbuf, (len > 4 ? len - 4 : len), byte_order, tmp);

  /* Ignore return values more than 8 bytes in size because the m32r
     returns anything more than 8 bytes in the stack.  */
  if (len > 4)
    {
      regcache_cooked_read_unsigned (regcache, RET1_REGNUM + 1, &tmp);
      store_unsigned_integer (valbuf + len - 4, 4, byte_order, tmp);
    }
}

static enum return_value_convention
m32r_return_value (struct gdbarch *gdbarch, struct value *function,
		   struct type *valtype, struct regcache *regcache,
		   gdb_byte *readbuf, const gdb_byte *writebuf)
{
  if (TYPE_LENGTH (valtype) > 8)
    return RETURN_VALUE_STRUCT_CONVENTION;
  else
    {
      if (readbuf != NULL)
	m32r_extract_return_value (valtype, regcache, readbuf);
      if (writebuf != NULL)
	m32r_store_return_value (valtype, regcache, writebuf);
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
}



static CORE_ADDR
m32r_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  return frame_unwind_register_unsigned (next_frame, M32R_PC_REGNUM);
}

/* Given a GDB frame, determine the address of the calling function's
   frame.  This will be used to create a new GDB frame struct.  */

static void
m32r_frame_this_id (struct frame_info *this_frame,
		    void **this_prologue_cache, struct frame_id *this_id)
{
  struct m32r_unwind_cache *info
    = m32r_frame_unwind_cache (this_frame, this_prologue_cache);
  CORE_ADDR base;
  CORE_ADDR func;
  struct minimal_symbol *msym_stack;
  struct frame_id id;

  /* The FUNC is easy.  */
  func = get_frame_func (this_frame);

  /* Check if the stack is empty.  */
  msym_stack = lookup_minimal_symbol ("_stack", NULL, NULL);
  if (msym_stack && info->base == SYMBOL_VALUE_ADDRESS (msym_stack))
    return;

  /* Hopefully the prologue analysis either correctly determined the
     frame's base (which is the SP from the previous frame), or set
     that base to "NULL".  */
  base = info->prev_sp;
  if (base == 0)
    return;

  id = frame_id_build (base, func);
  (*this_id) = id;
}

static struct value *
m32r_frame_prev_register (struct frame_info *this_frame,
			  void **this_prologue_cache, int regnum)
{
  struct m32r_unwind_cache *info
    = m32r_frame_unwind_cache (this_frame, this_prologue_cache);
  return trad_frame_get_prev_register (this_frame, info->saved_regs, regnum);
}

static const struct frame_unwind m32r_frame_unwind = {
  NORMAL_FRAME,
  default_frame_unwind_stop_reason,
  m32r_frame_this_id,
  m32r_frame_prev_register,
  NULL,
  default_frame_sniffer
};

static CORE_ADDR
m32r_frame_base_address (struct frame_info *this_frame, void **this_cache)
{
  struct m32r_unwind_cache *info
    = m32r_frame_unwind_cache (this_frame, this_cache);
  return info->base;
}

static const struct frame_base m32r_frame_base = {
  &m32r_frame_unwind,
  m32r_frame_base_address,
  m32r_frame_base_address,
  m32r_frame_base_address
};

/* Assuming THIS_FRAME is a dummy, return the frame ID of that dummy
   frame.  The frame ID's base needs to match the TOS value saved by
   save_dummy_frame_tos(), and the PC match the dummy frame's breakpoint.  */

static struct frame_id
m32r_dummy_id (struct gdbarch *gdbarch, struct frame_info *this_frame)
{
  CORE_ADDR sp = get_frame_register_unsigned (this_frame, M32R_SP_REGNUM);
  return frame_id_build (sp, get_frame_pc (this_frame));
}


static gdbarch_init_ftype m32r_gdbarch_init;

static struct gdbarch *
m32r_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
{
  struct gdbarch *gdbarch;
  struct gdbarch_tdep *tdep;

  /* If there is already a candidate, use it.  */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;

  /* Allocate space for the new architecture.  */
  tdep = XMALLOC (struct gdbarch_tdep);
  gdbarch = gdbarch_alloc (&info, tdep);

  set_gdbarch_read_pc (gdbarch, m32r_read_pc);
  set_gdbarch_unwind_sp (gdbarch, m32r_unwind_sp);

  set_gdbarch_num_regs (gdbarch, M32R_NUM_REGS);
  set_gdbarch_pc_regnum (gdbarch, M32R_PC_REGNUM);
  set_gdbarch_sp_regnum (gdbarch, M32R_SP_REGNUM);
  set_gdbarch_register_name (gdbarch, m32r_register_name);
  set_gdbarch_register_type (gdbarch, m32r_register_type);

  set_gdbarch_push_dummy_call (gdbarch, m32r_push_dummy_call);
  set_gdbarch_return_value (gdbarch, m32r_return_value);

  set_gdbarch_skip_prologue (gdbarch, m32r_skip_prologue);
  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);
  set_gdbarch_breakpoint_from_pc (gdbarch, m32r_breakpoint_from_pc);
  set_gdbarch_memory_insert_breakpoint (gdbarch,
					m32r_memory_insert_breakpoint);
  set_gdbarch_memory_remove_breakpoint (gdbarch,
					m32r_memory_remove_breakpoint);

  set_gdbarch_frame_align (gdbarch, m32r_frame_align);

  frame_base_set_default (gdbarch, &m32r_frame_base);

  /* Methods for saving / extracting a dummy frame's ID.  The ID's
     stack address must match the SP value returned by
     PUSH_DUMMY_CALL, and saved by generic_save_dummy_frame_tos.  */
  set_gdbarch_dummy_id (gdbarch, m32r_dummy_id);

  /* Return the unwound PC value.  */
  set_gdbarch_unwind_pc (gdbarch, m32r_unwind_pc);

  set_gdbarch_print_insn (gdbarch, print_insn_m32r);

  /* Hook in ABI-specific overrides, if they have been registered.  */
  gdbarch_init_osabi (info, gdbarch);

  /* Hook in the default unwinders.  */
  frame_unwind_append_unwinder (gdbarch, &m32r_frame_unwind);

  /* Support simple overlay manager.  */
  set_gdbarch_overlay_update (gdbarch, simple_overlay_update);

  return gdbarch;
}

void
_initialize_m32r_tdep (void)
{
  register_gdbarch_init (bfd_arch_m32r, m32r_gdbarch_init);
}
@


1.73
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@a669 6
static void
m32r_write_pc (struct regcache *regcache, CORE_ADDR val)
{
  regcache_cooked_write_unsigned (regcache, M32R_PC_REGNUM, val);
}

a923 1
  set_gdbarch_write_pc (gdbarch, m32r_write_pc);
d927 1
@


1.72
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@d3 1
a3 2
   Copyright (C) 1996, 1998-2005, 2007-2012 Free Software Foundation,
   Inc.
@


1.71
log
@	gdb/
	* breakpoint.h (bp_location): Add related_address member.
	* inferior.h (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* value.h (using_struct_return): Likewise.
	* gdbarch.sh (return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* breakpoint.c (set_breakpoint_location_function): Initialize
	related_address for bp_gnu_ifunc_resolver breakpoints.
	* elfread.c (elf_gnu_ifunc_resolver_return_stop): Pass the
	requested function's address to gdbarch_return_value.
	* eval.c (evaluate_subexp_standard): Pass the requested
	function's address to using_struct_return.
	* infcall.c (call_function_by_hand): Pass the requested
	function's address to using_struct_return and
	gdbarch_return_value.
	* infcmd.c (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	(print_return_value): Update accordingly.
	(finish_command_continuation): Likewise.
	* stack.c (return_command): Pass the requested function's
	address to using_struct_return and gdbarch_return_value.
	* value.c (using_struct_return): Take a pointer to struct value
	instead of struct type for the function requested.  Pass the
	requested function's address to gdbarch_return_value.
	* python/py-finishbreakpoint.c (finish_breakpoint_object):
	New function_value member, replacing function_type.
	(bpfinishpy_dealloc): Update accordingly.
	(bpfinishpy_pre_stop_hook): Likewise.
	(bpfinishpy_init): Likewise.  Record the requested function's
	address.
	* mips-tdep.c (mips_fval_reg): New enum.
	(mips_o32_push_dummy_call): For MIPS16 FP doubles do not swap
	words put in GP registers.
	(mips_o64_push_dummy_call): Update a comment.
	(mips_o32_return_value): Take a pointer to struct value instead
	of struct type for the function requested and use it to check if
	using the MIPS16 calling convention.  Return the designated
	general purpose registers for floating-point values returned in
	MIPS16 mode.
	(mips_o64_return_value): Likewise.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Update prototype.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* alpha-tdep.c (alpha_return_value): Take a pointer to struct
	value instead of struct type for the function requested.
	* amd64-tdep.c (amd64_return_value): Likewise.
	* amd64-windows-tdep.c (amd64_windows_return_value): Likewise.
	* arm-tdep.c (arm_return_value): Likewise.
	* avr-tdep.c (avr_return_value): Likewise.
	* bfin-tdep.c (bfin_return_value): Likewise.
	* cris-tdep.c (cris_return_value): Likewise.
	* frv-tdep.c (frv_return_value): Likewise.
	* h8300-tdep.c (h8300_return_value): Likewise.
	(h8300h_return_value): Likewise.
	* hppa-tdep.c (hppa32_return_value): Likewise.
	(hppa64_return_value): Likewise.
	* i386-tdep.c (i386_return_value): Likewise.
	* ia64-tdep.c (ia64_return_value): Likewise.
	* iq2000-tdep.c (iq2000_return_value): Likewise.
	* lm32-tdep.c (lm32_return_value): Likewise.
	* m32c-tdep.c (m32c_return_value): Likewise.
	* m32r-tdep.c (m32r_return_value): Likewise.
	* m68hc11-tdep.c (m68hc11_return_value): Likewise.
	* m68k-tdep.c (m68k_return_value): Likewise.
	(m68k_svr4_return_value): Likewise.
	* m88k-tdep.c (m88k_return_value): Likewise.
	* mep-tdep.c (mep_return_value): Likewise.
	* microblaze-tdep.c (microblaze_return_value): Likewise.
	* mn10300-tdep.c (mn10300_return_value): Likewise.
	* moxie-tdep.c (moxie_return_value): Likewise.
	* mt-tdep.c (mt_return_value): Likewise.
	* ppc-linux-tdep.c (ppc_linux_return_value): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Likewise.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Likewise.
	* rl78-tdep.c (rl78_return_value): Likewise.
	* rs6000-aix-tdep.c (rs6000_return_value): Likewise.
	* rx-tdep.c (rx_return_value): Likewise.
	* s390-tdep.c (s390_return_value): Likewise.
	* score-tdep.c (score_return_value): Likewise.
	* sh-tdep.c (sh_return_value_nofpu): Likewise.
	(sh_return_value_fpu): Likewise.
	* sh64-tdep.c (sh64_return_value): Likewise.
	* sparc-tdep.c (sparc32_return_value): Likewise.
	* sparc64-tdep.c (sparc64_return_value): Likewise.
	* spu-tdep.c (spu_return_value): Likewise.
	* tic6x-tdep.c (tic6x_return_value): Likewise.
	* v850-tdep.c (v850_return_value): Likewise.
	* vax-tdep.c (vax_return_value): Likewise.
	* xstormy16-tdep.c (xstormy16_return_value): Likewise.
	* xtensa-tdep.c (xtensa_return_value): Likewise.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.

	gdb/testsuite/
	* gdb.base/return-nodebug.exp: Also test float and double types.
@
text
@d540 1
a540 1
  unsigned long op, op2;
a699 1
  int odd_sized_struct;
@


1.70
log
@Problem after hitting breakpoint on Windows (with GDBserver)

When debugging on Windows with GDBserver, the debugger starts
failing after hitting a breakpoint.  For instance:

    (gdb) b foo
    Breakpoint 1 at 0x40177e: file foo.adb, line 5.
    (gdb) cont
    Continuing.

    Breakpoint 1, foo () at foo.adb:5
    5          Put_Line ("Hello World.");  -- STOP
    (gdb) n

    Program received signal SIGSEGV, Segmentation fault.
    0x00401782 in foo () at foo.adb:5
    5          Put_Line ("Hello World.");  -- STOP

There are two issues:

  1. While trying to re-insert a breakpoint that is still inserted
     in memory, insert_bp_location wipes out the breakpoint location's
     shadow_contents.  As a consequence, we cannot restore the proper
     instruction when removing the breakpoint anymore.  That's why
     the inferior's behavior changes when trying to resume after
     the breakpoint was hit.

  2. mem-break.c:default_memory_insert_breakpoint passes a breakpoint
     location's shadow_contents as the buffer for a memory read.
     This reveals a limitation of the various memory-read target
     functions.  This patch documents this limitation and adjust
     the two calls that seem to hit that limitation.

gdb/ChangeLog:

        * breakpoint.c (breakpoint_xfer_memory): Add assertion.
        Update function description.
        (insert_bp_location): Do not wipe bl->target_info out.
        * mem-break.c: #include "gdb_string.h".
        (default_memory_insert_breakpoint): Do not call target_read_memory
        with a pointer to the breakpoint's shadow_contents buffer.  Use
        a local buffer instead.
        * m32r-tdep.c (m32r_memory_insert_breakpoint): Ditto.
@
text
@d812 1
a812 1
m32r_return_value (struct gdbarch *gdbarch, struct type *func_type,
@


1.69
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d88 1
a88 1
  gdb_byte *contents_cache = bp_tgt->shadow_contents;
d96 1
@


1.68
log
@2011-12-14  Pedro Alves  <pedro@@codesourcery.com>

	* ia64-tdep.c (ia64_memory_remove_breakpoint): Use
	target_write_raw_memory.
	* m32r-tdep.c (m32r_memory_remove_breakpoint): Use
	target_write_raw_memory.
	* microblaze-linux-tdep.c
	(microblaze_linux_memory_remove_breakpoint): Use
	target_write_raw_memory.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Use
	target_write_raw_memory.
@
text
@d3 2
a4 2
   Copyright (C) 1996, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007,
   2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.67
log
@	gdb/
	* frame.c (frame_unwind_register): Throw an error if unwinding the
	register failed.
	* get_prev_frame_1 (get_prev_frame_1): Ask the unwinder if there's
	an unwind stop reason.
	(frame_stop_reason_string): Handle UNWIND_UNAVAILABLE.
	* frame.h (enum unwind_stop_reason) <UNWIND_OUTERMOST,
	UNWIND_UNAVAILABLE>: New.
	* inline-frame.c (inline_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* frame-unwind.c: Include "exceptions.h".
	(frame_unwind_find_by_frame): Swallow NOT_AVAILABLE_ERROR errors.
	(default_frame_unwind_stop_reason): New.
	* frame-unwind.h (frame_unwind_stop_reason_ftype): New typedef.
	(default_frame_unwind_stop_reason): Declare.
	(struct frame_unwind) <stop_reason>: New function pointer.

	* dummy-frame.c: Install default_frame_unwind_stop_reason.
	* dwarf2-frame.c: Include exceptions.h.
	(struct dwarf2_frame_cache) <unavailable_retaddr>: New field.
	(dwarf2_frame_cache): Swallow NOT_AVAILABLE_ERROR errors when
	computing the CFA.  If such an error was thrown, set
	unavailable_retaddr.
	(dwarf2_frame_unwind_stop_reason): New.
	(dwarf2_frame_this_id): Don't build a frame id if the CFA was
	unavailable.
	(dwarf2_frame_unwind): Install dwarf2_frame_unwind_stop_reason.
	(dwarf2_signal_frame_unwind): Ditto.

	* amd64-tdep.c: Include "exceptions.h".
	(struct amd64_frame_cache): New field "base_p".
	(amd64_init_frame_cache): Clear it.
	(amd64_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(amd64_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(amd64_frame_unwind_stop_reason): New.
	(amd64_frame_this_id): Don't build a frame id if the frame base
	was unavailable.
	(amd64_frame_unwind): Install amd64_frame_unwind_stop_reason.
	(amd64_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_sigtramp_frame_unwind_stop_reason): New.
	(amd64_sigtramp_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_sigtramp_frame_unwind): Install
	amd64_sigtramp_frame_unwind_stop_reason.
	(amd64_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_epilogue_frame_unwind_stop_reason): New.
	(amd64_epilogue_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_epilogue_frame_unwind): Install
	amd64_epilogue_frame_unwind_stop_reason.
	* i386-tdep.c: Include "exceptions.h".
	(struct i386_frame_cache): New field "base_p".
	(i386_init_frame_cache): Clear it.
	(i386_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(i386_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(i386_frame_unwind_stop_reason): New.
	(i386_frame_this_id): Don't build a frame id if the frame base was
	unavailable.
	(i386_frame_prev_register): Handle unavailable SP.
	(i386_frame_unwind): Install i386_frame_unwind_stop_reason.
	(i386_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_epilogue_frame_unwind_stop_reason): New.
	(i386_epilogue_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_epilogue_frame_unwind): Install
	i386_epilogue_frame_unwind_stop_reason.
	(i386_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_sigtramp_frame_unwind_stop_reason): New.
	(i386_sigtramp_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_sigtramp_frame_unwind): Install
	i386_sigtramp_frame_unwind_stop_reason.
	* sentinel-frame.c (sentinel_frame_prev_register): Use the value
	type's size, not the register's.
	(sentinel_frame_unwind): Install default_frame_unwind_stop_reason.

	* alpha-mdebug-tdep.c (alpha_mdebug_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* alpha-tdep.c (alpha_sigtramp_frame_unwind)
	(alpha_heuristic_frame_unwind): Ditto.
	* amd64obsd-tdep.c (amd64obsd_trapframe_unwind): Ditto.
	* arm-tdep.c (arm_prologue_unwind, arm_stub_unwind): Ditto.
	* avr-tdep.c (avr_frame_unwind): Ditto.
	* cris-tdep.c (cris_sigtramp_frame_unwind, cris_frame_unwind):
	Ditto.
	* frv-linux-tdep.c (frv_linux_sigtramp_frame_unwind): Ditto.
	* frv-tdep.c (frv_frame_unwind): Ditto.
	* h8300-tdep.c (h8300_frame_unwind): Ditto.
	* hppa-hpux-tdep.c (hppa_hpux_sigtramp_frame_unwind): Ditto.
	* hppa-linux-tdep.c (hppa_linux_sigtramp_frame_unwind): Ditto.
	* hppa-tdep.c (hppa_frame_unwind, hppa_fallback_frame_unwind)
	(hppa_stub_frame_unwind): Ditto.
	* i386obsd-tdep.c (i386obsd_trapframe_unwind): Ditto.
	* ia64-tdep.c (ia64_frame_unwind, ia64_sigtramp_frame_unwind)
	(ia64_libunwind_frame_unwind)
	(ia64_libunwind_sigtramp_frame_unwind): Ditto.
	* iq2000-tdep.c (iq2000_frame_unwind): Ditto.
	* lm32-tdep.c (lm32_frame_unwind): Ditto.
	* m32c-tdep.c (m32c_unwind): Ditto.
	* m32r-linux-tdep.c (m32r_linux_sigtramp_frame_unwind): Ditto.
	* m32r-tdep.c (m32r_frame_unwind): Ditto.
	* m68hc11-tdep.c (m68hc11_frame_unwind): Ditto.
	* m68k-tdep.c (m68k_frame_unwind): Ditto.
	* m68klinux-tdep.c (m68k_linux_sigtramp_frame_unwind): Ditto.
	* m88k-tdep.c (m88k_frame_unwind): Ditto.
	* mep-tdep.c (mep_frame_unwind): Ditto.
	* microblaze-tdep.c (microblaze_frame_unwind): Ditto.
	* mips-tdep.c (mips_insn16_frame_unwind, mips_insn32_frame_unwind)
	(mips_stub_frame_unwind): Ditto.
	* mn10300-tdep.c (mn10300_frame_unwind): Ditto.
	* moxie-tdep.c (moxie_frame_unwind): Ditto.
	* mt-tdep.c (mt_frame_unwind): Ditto.
	* ppc-linux-tdep.c (ppu2spu_unwind): Ditto.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_unwind): Ditto.
	* rs6000-tdep.c (rs6000_frame_unwind): Ditto.
	* s390-tdep.c (s390_frame_unwind, s390_stub_frame_unwind)
	(s390_sigtramp_frame_unwind): Ditto.
	* score-tdep.c (score_prologue_unwind): Ditto.
	* sh-tdep.c (sh_frame_unwind): Ditto.
	* sh64-tdep.c (sh64_frame_unwind): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_sigtramp_frame_unwind): Ditto.
	* sparc-tdep.c (sparc32_frame_unwind): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_sigtramp_frame_unwind): Ditto.
	* sparc64-tdep.c (sparc64_frame_unwind): Ditto.
	* sparc64fbsd-tdep.c (sparc64fbsd_sigtramp_frame_unwind): Ditto.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_frame_unwind): Ditto.
	* sparc64obsd-tdep.c (sparc64obsd_frame_unwind)
	(sparc64obsd_trapframe_unwind): Ditto.
	* sparcnbsd-tdep.c (sparc32nbsd_sigcontext_frame_unwind): Ditto.
	* sparcobsd-tdep.c (sparc32obsd_sigtramp_frame_unwind): Ditto.
	* spu-tdep.c (spu_frame_unwind, spu2ppu_unwind): Ditto.
	* v850-tdep.c (v850_frame_unwind): Ditto.
	* vax-tdep.c (vax_frame_unwind): Ditto.
	* vaxobsd-tdep.c (vaxobsd_sigtramp_frame_unwind): Ditto.
	* xstormy16-tdep.c (frame_unwind xstormy16_frame_unwind): Ditto.
	* xtensa-tdep.c (xtensa_unwind): Ditto.
@
text
@d166 1
a166 1
  val = target_write_memory (addr & 0xfffffffc, buf, 4);
@


1.67.4.1
log
@2011-12-14  Pedro Alves  <pedro@@codesourcery.com>

	* ia64-tdep.c (ia64_memory_remove_breakpoint): Use
	target_write_raw_memory.
	* m32r-tdep.c (m32r_memory_remove_breakpoint): Use
	target_write_raw_memory.
	* microblaze-linux-tdep.c
	(microblaze_linux_memory_remove_breakpoint): Use
	target_write_raw_memory.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Use
	target_write_raw_memory.
@
text
@d166 1
a166 1
  val = target_write_raw_memory (addr & 0xfffffffc, buf, 4);
@


1.67.4.2
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 2
   Copyright (C) 1996, 1998-2005, 2007-2012 Free Software Foundation,
   Inc.
@


1.66
log
@2011-01-31  Michael Snyder  <msnyder@@vmware.com>

	* m32r-tdep.c (m32r_gdbarch_init): Replace accidentally deleted
	line.
@
text
@d879 1
@


1.65
log
@2011-01-08  Michael Snyder  <msnyder@@vmware.com>

	* m2-exp.y: Comment cleanup, mostly periods and spaces.
	* m2-lang.c: Ditto.
	* m2-typeprint.c: Ditto.
	* m2-valprint.c: Ditto.
	* m32c-tdep.c: Ditto.
	* m32r-linux-nat.c: Ditto.
	* m32r-rom.c: Ditto.
	* m32r-tdep.c: Ditto.
	* m32r-tdep.h: Ditto.
	* m68hc11-tdep.c: Ditto.
	* m58klinux-nat.c: Ditto.
	* m68k-tdep.c: Ditto.
	* m88k-tdep.c: Ditto.
	* m88k-tdep.h: Ditto.
	* machoread.c: Ditto.
	* macrocmd.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* mdebugread.h: Ditto.
	* memattr.c: Ditto.
	* memattr.h: Ditto.
	* memory-map.h: Ditto.
	* mep-tdep.c: Ditto.
	* microblaze-rom.c: Ditto.
	* microblaze-tdep.c: Ditto.
	* minsyms.c: Ditto.
	* mips-irix-tdep.c: Ditto.
	* mips-linux-nat.c: Ditto.
	* mips-linux-tdep.c: Ditto.
	* mips-linux-tdep.h: Ditto.
	* mipsnbsd-nat.c: Ditto.
	* mipsnbsd-tdep.c: Ditto.
	* mipsread.c: Ditto.
	* mips-tdep.c: Ditto.
	* mips-tdep.h: Ditto.
	* mn10300-linux-tdep.c: Ditto.
	* mn10300-tdep.c: Ditto.
	* mn10300-tdep.h: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* moxie-tdep.c: Ditto.
	* moxie-tdep.h: Ditto.
	* mt-tdep.c: Ditto.
@
text
@d933 1
a933 1

@


1.64
log
@run copyright.sh for 2011.
@
text
@d60 1
a60 1
   The little endian mode of M32R is unique. In most of architectures,
d79 1
a79 1
   The following functions take care of this behavior. */
d171 2
a172 1
m32r_breakpoint_from_pc (struct gdbarch *gdbarch, CORE_ADDR *pcptr, int *lenptr)
d174 6
a179 2
  static gdb_byte be_bp_entry[] = { 0x10, 0xf1, 0x70, 0x00 };	/* dpt -> nop */
  static gdb_byte le_bp_entry[] = { 0x00, 0x70, 0xf1, 0x10 };	/* dpt -> nop */
d248 1
a248 1
   of type TYPE, given in virtual format.  
d250 1
a250 1
   Things always get returned in RET1_REGNUM, RET2_REGNUM. */
d272 1
a272 1
/* This is required by skip_prologue. The results of decoding a prologue
d295 1
a295 1
      /* Check if current pc's location is readable. */
d305 1
a305 1
         immediate data as though it were an instruction */
d308 1
a308 1
	  /* decode this instruction further */
d320 1
a320 1
	      /* Check if current pc's location is readable. */
d334 1
a334 1
		  if (((insn >> 8) == 0xe4)	/* ld24 r4, xxxxxx; sub sp, r4 */
a340 1
		    /* subtract 24 bit sign-extended negative-offset */
d342 1
d356 1
a356 1
      op1 = insn & 0xf000;	/* isolate just the first nibble */
d367 1
a367 1
	/* add 8 bit sign-extended offset */
d392 1
a392 1
      /* Nop looks like a branch, continue explicitly */
d396 1
a396 1
	  continue;		/* nop occurs between pushes */
d398 1
a398 1
      /* End of prolog if any of these are trap instructions */
d404 1
a404 1
      /* End of prolog if any of these are branch instructions */
d410 1
a410 1
      /* Some of the branch instructions are mixed with other types */
d432 1
a432 1
	       end of the prologue?  I just don't know. */
d439 1
a439 1
	       end of the prologue?  I just don't know. */
d445 4
a448 3
	       of the prologue.  No way to win -- we should report failure.  
	       The way we do that is to return the original start_pc.
	       GDB will set a breakpoint at the start of the function (etc.) */
d464 1
a464 1
   Find end of function prologue */
d476 1
a476 1
  /* See what the symbol table says */
d497 1
a497 1
  /* If pc's location is not readable, just quit. */
d530 1
a530 1
   for it IS the sp for the next frame. */
d612 2
a613 2
	  /* end of prologue if this is a trap instruction */
	  break;		/* end of stack adjustments */
d701 1
a701 1
  /* first force sp to a 4-byte alignment */
d717 1
a717 1
  /* Now make sure there's space on the stack */
d720 1
a720 1
  sp -= stack_alloc;		/* make room on stack for args */
d742 1
a742 1
	  /* value gets right-justified in the register or stack word */
d754 1
a754 1
	      /* must go on the stack */
d760 1
a760 1
	      /* there's room in a register */
d802 1
a802 1
     returns anything more than 8 bytes in the stack. */
d933 1
a933 1
  set_gdbarch_num_regs (gdbarch, M32R_NUM_REGS);
@


1.63
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d4 1
a4 1
   2008, 2009, 2010 Free Software Foundation, Inc.
@


1.62
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d4 1
a4 1
   2008, 2009 Free Software Foundation, Inc.
@


1.61
log
@	* gdbtypes.h (builtin_type_int0, builtin_type_int8, builtin_type_uint8,
	builtin_type_int16, builtin_type_uint16, builtin_type_int32,
	builtin_type_uint32, builtin_type_int64, builtin_type_uint64,
	builtin_type_int128, builtin_type_uint128): Remove.
	(struct builtin_type): New members builtin_int0, builtin_int8,
	builtin_uint8, builtin_int16, builtin_uint16, builtin_int32,
	builtin_uint32, builtin_int64, builtin_uint64, builtin_int128,
	and builtin_uint128.
	* gdbtypes.c (builtin_type_int0, builtin_type_int8, builtin_type_uint8,
	builtin_type_int16, builtin_type_uint16, builtin_type_int32,
	builtin_type_uint32, builtin_type_int64, builtin_type_uint64,
	builtin_type_int128, builtin_type_uint128): Remove.
	(_initialize_gdbtypes): Do not initialize them.
	(gdbtypes_post_init): Initialize fixed-size integer types.

	* dwarf2expr.c (unsigned_address_type, signed_address_type): Add
	GDBARCH argument.  Return platform-specific type.
	(dwarf2_read_address, execute_stack_op): Update calls.

	* target-descriptions.c (tdesc_gdb_type): Use platform-specific types
	instead of global builtin_int_... variables.
	* mi/mi-main.c (mi_cmd_data_read_memory): Likewise.
	* printcmd.c (do_examine): Likewise.
	* jv-exp.y (parse_number): Likewise.

	* alpha-tdep.c (alpha_register_type, alpha_push_dummy_call,
	alpha_store_return_value): Likewise.
	* amd64-linux-tdep.c (amd64_linux_register_type): Likewise.
	* amd64-tdep.c (amd64_register_type): Likewise.
	* arm-tdep.c (arm_register_type): Likewise.
	* avr-tdep.c (avr_register_type): Likewise.
	* cris-tdep.c (cris_register_type, crisv32_register_type): Likewise.
	* frv-tdep.c (frv_register_type): Likewise.
	* h8300-tdep.c h8300_register_type): Likewise.
	* hppa-tdep.c (hppa64_push_dummy_call, hppa32_register_type,
	hppa64_register_type): Likewise.
	* i386-tdep.c (i386_mmx_type, i386_sse_type): Likewise.
	* iq2000-tdep.c (iq2000_register_type): Likewise.
	* lm32-tdep.c (lm32_register_type, lm32_push_dummy_call): Likewise.
	* m32r-tdep.c (m32r_register_type): Likewise.
	* m68hc11-tdep.c (m68hc11_register_type, m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m88k-tdep.c (m88k_register_type, m88k_store_arguments): Likewise.
	* mep-tdep.c (mep_register_type): Likewise.
	* mips-tdep.c (mips_register_type, mips_pseudo_register_type,
	mips_print_fp_register): Likewise.
	* moxie-tdep.c (moxie_register_type): Likewise.
	* mt-tdep.c (mt_copro_register_type, mt_register_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64,
	rs6000_builtin_type_vec128): Likewise.
	* score-tdep.c (score_register_type): Likewise.
	* sparc-tdep.c (sparc32_register_type, sparc32_store_arguments):
	Likewise.
	* sparc64-tdep.c (sparc64_register_type, sparc64_store_arguments):
	Likewise.
	* spu-tdep.c (spu_builtin_type_vec128, spu_register_type): Likewise.
	* v850-tdep.c (v850_register_type): Likewise.
	* xstormy16-tdep.c (xstormy16_register_type): Likewise.
	* xtensa-tdep.c (xtensa_register_type): Likewise.

	* mt-tdep.c (struct gdbarch_tdep): New data structure.
	(mt_gdbarch_init): Alloc TDEP structures.
	(mt_register_type): Cache coprocessor type in TDEP instead of
	static global variable.

	* xtensa-tdep.h (struct gdbarch_tdep): Add type_entries member.
	* xtensa-tdep.c (type_entries): Remove.
	(xtensa_register_type): Cache fixed-size types in TDEP instead
	of in global variable.
@
text
@d251 2
d256 1
a256 1
  regval = extract_unsigned_integer (valbuf, len > 4 ? 4 : len);
d261 2
a262 1
      regval = extract_unsigned_integer ((gdb_byte *) valbuf + 4, len - 4);
d271 2
a272 1
decode_prologue (CORE_ADDR start_pc, CORE_ADDR scan_limit,
d275 1
d291 1
a291 1
      if (!safe_read_memory_integer (current_pc, 2, &return_value))
d294 1
a294 1
      insn = read_memory_unsigned_integer (current_pc, 2);
d316 2
a317 1
	      if (!safe_read_memory_integer (current_pc, 2, &return_value))
d324 2
a325 1
		    -((short) read_memory_unsigned_integer (current_pc, 2));
d330 2
a331 1
		      && safe_read_memory_integer (current_pc + 2, 2,
d334 2
a335 1
						       2) == 0x0f24)
d338 2
a339 1
		      insn = read_memory_unsigned_integer (current_pc - 2, 4);
d465 1
d492 1
a492 1
  if (!safe_read_memory_integer (pc, 4, &return_value))
d496 1
a496 1
  if (decode_prologue (pc, func_end, &sal.end, NULL) < 0)
d683 1
d728 2
a729 1
	  store_unsigned_integer (valbuf, 4, value_address (args[argnum]));
d757 2
a758 1
					  register_size (gdbarch, argreg));
d784 2
d793 1
a793 1
  store_unsigned_integer (valbuf, (len > 4 ? len - 4 : len), tmp);
d800 1
a800 1
      store_unsigned_integer (valbuf + len - 4, 4, tmp);
@


1.60
log
@2009-05-27  Tom Tromey  <tromey@@redhat.com>
	    Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* mi/mi-main.c (mi_cmd_data_evaluate_expression): Use
	value_address.
	* cli/cli-dump.c (dump_value_to_file): Use value_address.
	* valprint.c (common_val_print): Likewise.
	* v850-tdep.c (v850_push_dummy_call): Use value_address.
	* tracepoint.c (encode_actions): Use value_address.
	* printcmd.c (print_formatted): Use value_address.
	(x_command): Likewise.
	* p-valprint.c (pascal_object_print_static_field): Use
	value_address.
	* mn10300-tdep.c (mn10300_push_dummy_call): Use value_address.
	* mips-tdep.c (mips_eabi_push_dummy_call): Use value_address.
	* m32r-tdep.c (m32r_push_dummy_call): Use value_address.
	* jv-valprint.c (java_value_print): Use value_address.
	* infcall.c (find_function_addr): Use value_address.
	* gnu-v3-abi.c (gnuv3_rtti_type): Use value_address.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Use value_address.
	* frv-tdep.c (frv_push_dummy_call): Use value_address.
	* frame.c (frame_register_unwind): Use value_address.
	(frame_unwind_register_value): Likewise.
	* darwin-nat-info.c (info_mach_region_command): Use
	value_address.
	* cp-valprint.c (cp_print_static_field): Use value_address.
	* c-valprint.c (c_value_print): Use value_address.
	* breakpoint.c (update_watchpoint): Use value_address.
	(can_use_hardware_watchpoint): Likewise.
	* ada-valprint.c (ada_val_print_1): Use value_address.
	(ada_value_print): Likewise.
	* ada-tasks.c (read_fat_string_value): Use value_address.
	* jv-lang.c (java_link_class_type): Use set_value_address.
	(java_link_class_type): Likewise.
	(get_java_utf8_name): Use value_address.
	(type_from_class): Likewise.
	(java_link_class_type): Likewise.
	* findvar.c (value_of_register): Use set_value_address.
	(read_var_value): Likewise.
	(read_var_value): Likewise.
	* eval.c (evaluate_subexp_standard): Use set_value_address.
	(evaluate_subexp_standard): Use value_address.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Use set_value_address.
	* ada-lang.c (coerce_unspec_val_to_type): Use set_value_address.
	(ada_value_primitive_packed_val): Likewise.
	(ensure_lval): Likewise.
	(thin_data_pntr): Use value_address.
	(desc_bounds): Likewise.
	(ada_value_primitive_packed_val): Likewise.
	(value_assign_to_component): Likewise.
	(ensure_lval): Likewise.
	(make_array_descriptor): Likewise.
	(ada_to_fixed_value): Likewise.
	(unwrap_value): Likewise.
	* value.c (deprecated_value_address_hack): Remove.
	(value_address): New function.
	(value_raw_address): Likewise.
	(set_value_address): Likewise.
	(value_fn_field): Use set_value_address.
	(value_from_contents_and_address): Likewise.
	(value_fn_field): Likewise.
	(allocate_value_lazy): Don't use VALUE_ADDRESS.
	(value_as_address): Use value_address.
	(value_static_field): Likewise.
	* valops.c (search_struct_field): Use set_value_address.
	(value_at): Likewise.
	(value_at_lazy): Likewise.
	(value_repeat): Likewise.
	(value_cast_structs): Use value_address.
	(value_cast): Likewise.
	(value_fetch_lazy): Likewise.
	(value_assign): Likewise.
	(value_repeat): Likewise.
	(address_of_variable): Likewise.
	(value_coerce_array): Likewise.
	(value_coerce_function): Likewise.
	(value_addr): Likewise.
	(search_struct_field): Likewise.
	(search_struct_method): Likewise.
	(find_method_list): Likewise.
	(value_struct_elt_for_reference): Likewise.
	(value_full_object): Likewise.
	* jv-valprint.c (java_value_print): Use set_value_address.
	* value.h (deprecated_value_address_hack): Remove.
	(VALUE_ADDRESS): Remove.
	(value_address): Declare.
	(value_raw_address): Declare.
	(set_value_address): Declare.
@
text
@d238 1
a238 1
    return builtin_type_int32;
@


1.59
log
@	Silence a few -Wmissing-prototypes warnings.

	PR build/9877:
        * alpha-linux-tdep.c (alpha_linux_regset_from_core_section): Make
	it static.
        * alpha-osf1-tdep.c (_initialize_alpha_osf1_tdep): Declare.
        * amd64fbsd-tdep.c (amd64fbsd_init_abi): Make it static.
        * amd64nbsd-tdep.c (_initialize_amd64nbsd_ndep): Rename to ...
	(_initialize_amd64nbsd_tdep): ... this.
	* arm-linux-tdep.c (arm_linux_software_single_step): Make it static.
	(_initialize_arm_linux_tdep): Declare.
	* armbsd-tdep.c (armbsd_fpreg_offset): Make it static.
	* armnbsd-tdep.c (_initialize_arm_netbsd_tdep): Declare.
	* armobsd-tdep.c (_initialize_armobsd_tdep): Declare.
	* avr-tdep.c (avr_return_value): Make it static.
	(avr_frame_unwind_cache): Ditto.
	* bsd-uthread.c (bsd_uthread_inferior_created): Ditto.
	(bsd_uthread_solib_loaded): Ditto.
	(bsd_uthread_solib_unloaded): Ditto.
	(bsd_uthread_target): Ditto.
	(_initialize_bsd_uthread): Declare.
	* cris-tdep.c (crisv32_single_step_through_delay): Make it static.
	(cris_frame_unwind_cache): Ditto.
	* frv-tdep.c (frv_return_value): Ditto.
	* h8300-tdep.c (h8300_use_struct_convention): Ditto.
	(h8300h_use_struct_convention): Ditto.
	* hppa-tdep.c (hppa_sign_extend, hppa_low_hppa_sign_extend):
	Ditto.
	* hppa-tdep.h (hppa_low_sign_extend, hppa_sign_extend): Delete
	declarations.
	* hppabsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_find_global_pointer): Make it static.
	* hppabsd-tdep.h: New.
	* hppanbsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_init_abi): Remove declaration.
	(_initialize_hppabsd_tdep): Remove declaration.
	(_initialize_hppanbsd_tdep): Declare.
	* hppaobsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_init_abi): Delete declaration.
	(hppaobsd_init_abi): Make it static.
	* i386-nto-tdep.c (_initialize_i386nto_tdep): Declare.
	* i386nbsd-tdep.c (_initialize_i386nbsd_tdep): Declare.
	* ia64-linux-tdep.c (_initialize_ia64_linux_tdep): Declare.
	* ia64-tdep.c (ia64_register_reggroup_p): Make it static.
	* iq2000-tdep.c (_initialize_iq2000_tdep): Declare.
	* m32c-tdep.c (m32c_register_reggroup_p): Make it static.
	(m32c_analyze_prologue, m32c_virtual_frame_pointer): Ditto.
	(_initialize_m32c_tdep): Declare.
	* m32r-rom.c (_initialize_m32r_rom): Declare.
	* m32r-tdep.c (m32r_skip_prologue): Make it static.
	(m32r_return_value): Ditto.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache): Make it static.
	(m68hc11_return_value): Ditto.
	* m68klinux-tdep.c (_initialize_m68k_linux_tdep): Declare.
	* m88k-tdep.c (m88k_frame_cache): Make it static.
	* mep-tdep.c (mep_gdb_print_insn): Ditto.
	(mep_return_value): Ditto.
	(_initialize_mep_tdep): Declare.
	* mips-irix-tdep.c (_initialize_mips_irix_tdep): Declare.
	* mips-linux-tdep.c (supply_64bit_reg): Make it static.
	(mips_linux_syscall_next_pc): Ditto.
	(_initialize_mips_linux_tdep): Declare.
	* mips-tdep.c (mips_single_step_through_delay): Make it static.
	* mipsnbsd-tdep.c (_initialize_mipsnbsd_tdep): Declare.
	* mn10300-linux-tdep.c (_initialize_mn10300_linux_tdep): Declare.
	* mn10300-tdep.c (_initialize_mn10300_tdep): Declare.
	* mt-tdep.c (_initialize_mt_tdep): Declare.
	* nbsd-tdep.c: Include nbsd-tdep.h.
	* nto-tdep.c (find_load_phdr): Make it static.
	(_initialize_nto_tdep): Declare.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Make it
	static.
	(_initialize_ppc_linux_tdep): Declare.
	* remote-m32r-sdi.c (m32r_can_use_hw_watchpoint)
	(m32r_insert_watchpoint, m32r_remove_watchpoint)
	(m32r_stopped_data_address, m32r_stopped_by_watchpoint): Make
	static.
	* rs6000-aix-tdep.c (_initialize_rs6000_aix_tdep): Declare.
	* rs6000-nat.c: Include xcoffread.h.
	(find_toc_address): Don't extern declare get_toc_offset.  Adjust
	to call xcoff_get_to_offset.
	* rs6000-tdep.c (ppc_vsx_support_p, ppc_displaced_step_fixup)
	(rs6000_skip_main_prologue, rs6000_in_solib_return_trampoline)
	(rs6000_skip_trampoline_code): Make static.
	* s390-tdep.c (s390_regset_from_core_section): Ditto.
	* sh-tdep.c (sh_register_reggroup_p): Ditto.
	* shnbsd-tdep.c (shnbsd_regset_from_core_section): Ditto.
	(_initialize_shnbsd_tdep): Declare.
	* solib-frv.c (displacement_from_map): Make static.
	(_initialize_frv_solib): Declare.
	* solib-irix.c (fetch_lm_info): Make static.
	(_initialize_irix_solib): Declare.
	* solib-som.c: Include solib-som.h.
	(som_solib_select): Line break.
	* sparc-tdep.c (sparc_regset_from_core_section): Make static.
	* sparcnbsd-tdep.c (_initialize_sparnbsd_tdep): Rename to ...
	(_initialize_sparcnbsd_tdep): ... this.
	* spu-tdep.c (spu_software_single_step): Make it static.
	(_initialize_spu_tdep): Declare.
	* vax-tdep.c (vax_frame_cache): Make it static.
	* xcoffread.c: Include xcoffread.h.
	(get_toc_offset): Rename to ...
	(xcoff_get_toc_offset): ... this.
	(_initialize_xcoffread): Declare.
	* xcoffread.h: New.
	* xtensa-linux-tdep.c (_initialize_xtensa_linux_tdep): Declare.
	* xtensa-tdep.c (xtensa_skip_prologue, xtensa_derive_tdep): Make
	static.
	(_initialize_xtensa_tdep): Declare.
@
text
@d716 1
a716 1
	  store_unsigned_integer (valbuf, 4, VALUE_ADDRESS (args[argnum]));
@


1.58
log
@        Updated copyright notices for most files.
@
text
@d452 1
a452 1
CORE_ADDR
d788 1
a788 1
enum return_value_convention
@


1.57
log
@	* alpha-tdep.c (alpha_register_type): Use builtin_type (gdbarch)
	instead of builtin_type_ macros.
	* amd64-tdep.c (amd64_register_type): Likewise.
	(amd64_get_longjmp_target): Likewise.
	* arm-tdep.c (arm_register_type): Likewise.
	* avr-tdep.c (avr_register_type): Likewise.
	* cris-tdep.c (cris_register_type, crisv32_register_type): Likewise.
	* frv-tdep.c (frv_register_type): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* hppa-tdep.c (hppa32_convert_from_func_ptr_addr,
	hppa_skip_trampoline_code): Likewise.
	* i386-tdep.c (i386_register_type): Likewise.
	(i386_unwind_pc, i386_sse_type): Likewise.
	* ia64-tdep.c (ia64_register_type): Likewise.
	* m32r-tdep.c (m32r_register_type): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m88k-tdep.c (m88k_register_type): Likewise.
	* mep-tdep.c (mep_register_type): Likewise.
	* mips-tdep.c (mips_pseudo_register_type): Likewise.
	* mn10300-tdep.c (mn10300_register_type): Likewise.
	* mt-tdep.c (mt_copro_register_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64): Likewise.
	(rs6000_convert_register_p, rs6000_register_to_value,
	rs6000_value_to_register): Likewise.
	* s390-tdep.c (s390_register_type): Likewise.
	* sh64-tdep.c (sh64_register_type): Likewise.
	(sh64_build_float_register_type, sh64_do_fp_register): Likewise.
	* sh-tdep.c (sh_sh2a_register_type, sh_sh3e_register_type,
	sh_sh4_build_float_register_type, sh_sh4_register_type,
	sh_default_register_type): Likewise.
	* sparc64-tdep.c (sparc64_register_type): Likewise.
	* sparc-tdep.c (sparc32_register_type): Likewise.
	* spu-tdep.c (spu_builtin_type_vec128, spu_register_type): Likewise.
	* v850-tdep.c (v850_register_type): Likewise.
	* vax-tdep.c (vax_register_type): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_unwind_pc,
	xtensa_push_dummy_call): Likewise.

	* std-regs.c (value_of_builtin_frame_fp_reg,
	value_of_builtin_frame_pc_reg): Likewise.
	* target-descriptions.c (tdesc_register_type): Likewise.
@
text
@d4 1
a4 1
   2008 Free Software Foundation, Inc.
@


1.56
log
@	* alphafbsd-tdep.c: Update for unwinder changes.
	* alpha-linux-tdep.c: Likewise.
	* alphanbsd-tdep.c: Likewise.
	* alphaobsd-tdep.c: Likewise.
	* avr-tdep.c: Likewise.
	* cris-tdep.c: Likewise.
	* frv-linux-tdep.c: Likewise.
	* frv-tdep.c: Likewise.
	* h8300-tdep.c: Likewise.
	* hppa-linux-tdep.c: Likewise.
	* iq2000-tdep.c: Likewise.
	* m32c-tdep.c: Likewise.
	* m32r-linux-tdep.c: Likewise.
	* m32r-tdep.c: Likewise.
	* m68hc11-tdep.c: Likewise.
	* mep-tdep.c: Likewise.
	* mn10300-tdep.c: Likewise.
	* mt-tdep.c: Likewise.
	* score-tdep.c: Likewise.
	* sh64-tdep.c: Likewise.
	* sh-tdep.c: Likewise.
	* sparc64fbsd-tdep.c: Likewise.
	* sparc64nbsd-tdep.c: Likewise.
	* sparc64obsd-tdep.c: Likewise.
	* v850-tdep.c: Likewise.
	* vaxobsd-tdep.c: Likewise.
	* vax-tdep.c: Likewise.
	* xstormy16-tdep.c: Likewise.
@
text
@d234 1
a234 1
    return builtin_type_void_func_ptr;
d236 1
a236 1
    return builtin_type_void_data_ptr;
@


1.55
log
@doc/ChangeLog:
--------------

	* gdb.texinfo (Set SH Calling convention): New @@item.
	(Show SH Calling convention): Ditto.

ChangeLog:
----------

	* NEWS: Add information on calling convention and new SH CLI options.

	* sh-tdep.c (sh_cc_gcc): New static string.
	(sh_cc_renesas): Ditto.
	(sh_cc_enum): New static string array.
	(sh_active_calling_convention): New static string pointer denoting
	active user chosen ABI.
	(sh_is_renesas_calling_convention): New function to return function
	specific ABI, or user choice if necessary.
	(sh_use_struct_convention): Rename first argument and turn around its
	meaning.  Check for renesas ABI and return accordingly.
	(sh_use_struct_convention_nofpu): New function.
	(sh_next_flt_argreg): Get function type as third parameter.  Check
	for renesas ABI and choose floating registers accordingly.
	(sh_push_dummy_call_fpu): Check for ABI and choose argument slot and
	struct return slot accordingly.
	(sh_push_dummy_call_nofpu): Ditto.
	(sh_return_value_nofpu): Call sh_use_struct_convention_nofpu from here.
	Evaluate ABI and give to sh_use_struct_convention_nofpu.
	(sh_return_value_fpu):  Evaluate ABI and give to
	sh_use_struct_convention.
	(show_sh_command): New function.
	(set_sh_command): Ditto.
	(_initialize_sh_tdep): Initialize `set/show sh calling-convention
	CLI command.

	* gdbarch.sh (return_value): Add func_type argument.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Ditto.
	* eval.c (evaluate_subexp_standard): Rename local variable value_type to
	val_type so as not to collide with value_type function.  Call
	using_struct_return with additional function type argument.
	* infcall.c (call_function_by_hand): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* infcmd.c (print_return_value): Take addition func_type argument.
	Call gdbarch_return_value with additional function type argument.
	(finish_command_continuation): Call print_return_value with additional
	function type argument.
	(finish_command): Ditto.
	* sparc-tdep.c (sparc32_push_dummy_code): Call using_struct_return with
	additional function type argument.
	* stack.c (return_command): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* value.c (using_struct_return): Take additional function type argument.
	* value.h (using_struct_return): Accommodate declaration.
	* alpha-tdep.c (alpha_return_value): Add func_type argument.
	* amd64-tdep.c (amd64_return_value): Ditto.
	* arm-tdep.c (arm_return_value): Ditto.
	* avr-tdep.c (avr_return_value): Ditto.
	* cris-tdep.c (cris_return_value): Ditto.
	* frv-tdep.c (frv_return_value): Ditto.
	* h8300-tdep.c (h8300_return_value): Ditto.
	(h8300h_return_value): Ditto.
	* hppa-tdep.c (hppa32_return_value): Ditto.
	(hppa64_return_value): Ditto.
	* i386-tdep.c (i386_return_value): Ditto.
	* ia64-tdep.c (ia64_return_value): Ditto.
	* iq2000-tdep.c (iq2000_return_value): Ditto.
	* m32c-tdep.c (m32c_return_value): Ditto.
	* m32r-tdep.c (m32r_return_value): Ditto.
	* m68hc11-tdep.c (m68hc11_return_value): Ditto.
	* m68k-tdep.c (m68k_return_value): Ditto.
	(m68k_svr4_return_value): Ditto.
	* m88k-tdep.c  (m88k_return_value): Ditto.
	* mep-tdep.c (mep_return_value): Ditto.
	* mips-tdep.c (mips_eabi_return_value): Ditto.
	(mips_n32n64_return_value): Ditto.
	(mips_o32_return_value): Ditto.
	(mips_o64_return_value): Ditto.
	* mn10300-tdep.c (mn10300_return_value): Ditto.
	* mt-tdep.c (mt_return_value): Ditto.
	* ppc-linux-tdep.c (ppc_linux_return_value): Ditto.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Ditto.
	* rs6000-tdep.c (rs6000_return_value): Ditto.
	* s390-tdep.c (s390_return_value): Ditto.
	* score-tdep.c (score_return_value): Ditto.
	* sh-tdep.c (sh_return_value_nofpu): Ditto.
	(sh_return_value_fpu): Ditto.
	* sh64-tdep.c (sh64_return_value): Ditto.
	* sparc-tdep.c (sparc32_return_value): Ditto.
	* sparc64-tdep.c (sparc64_return_value): Ditto.
	* spu-tdep.c (spu_return_value): Ditto.
	* v850-tdep.c (v850_return_value): Ditto.
	* vax-tdep.c (vax_return_value): Ditto.
	* xstormy16-tdep.c (xstormy16_return_value): Ditto.
	* xtensa-tdep.c (xtensa_return_value): Ditto.

	* gdbtypes.h (struct type): Add calling_convention member.
	* dwarf2read.c (read_subroutine_type): Add calling convention read
	from DW_AT_calling_convention attribute to function type.
@
text
@d516 1
a516 1
m32r_frame_unwind_cache (struct frame_info *next_frame,
d532 1
a532 1
  info->saved_regs = trad_frame_alloc_saved_regs (next_frame);
d538 2
a539 2
  scan_limit = frame_pc_unwind (next_frame);
  for (pc = frame_func_unwind (next_frame, NORMAL_FRAME);
d544 1
a544 1
	  op = get_frame_memory_unsigned (next_frame, pc, 4);
d555 1
a555 1
		       && get_frame_memory_unsigned (next_frame, pc + 2,
d572 1
a572 1
      op = get_frame_memory_unsigned (next_frame, pc, 2) & 0x7fff;
d609 1
a609 1
      this_base = frame_unwind_register_unsigned (next_frame, M32R_FP_REGNUM);
d618 1
a618 1
      this_base = frame_unwind_register_unsigned (next_frame, M32R_SP_REGNUM);
d628 1
a628 1
  for (i = 0; i < gdbarch_num_regs (get_frame_arch (next_frame)) - 1; i++)
d817 1
a817 1
m32r_frame_this_id (struct frame_info *next_frame,
d821 1
a821 1
    = m32r_frame_unwind_cache (next_frame, this_prologue_cache);
d828 1
a828 1
  func = frame_func_unwind (next_frame, NORMAL_FRAME);
d846 3
a848 6
static void
m32r_frame_prev_register (struct frame_info *next_frame,
			  void **this_prologue_cache,
			  int regnum, int *optimizedp,
			  enum lval_type *lvalp, CORE_ADDR *addrp,
			  int *realnump, gdb_byte *bufferp)
d851 2
a852 3
    = m32r_frame_unwind_cache (next_frame, this_prologue_cache);
  trad_frame_get_prev_register (next_frame, info->saved_regs, regnum,
				optimizedp, lvalp, addrp, realnump, bufferp);
d858 3
a860 1
  m32r_frame_prev_register
a862 6
static const struct frame_unwind *
m32r_frame_sniffer (struct frame_info *next_frame)
{
  return &m32r_frame_unwind;
}

d864 1
a864 1
m32r_frame_base_address (struct frame_info *next_frame, void **this_cache)
d867 1
a867 1
    = m32r_frame_unwind_cache (next_frame, this_cache);
d878 3
a880 4
/* Assuming NEXT_FRAME->prev is a dummy, return the frame ID of that
   dummy frame.  The frame ID's base needs to match the TOS value
   saved by save_dummy_frame_tos(), and the PC match the dummy frame's
   breakpoint.  */
d883 1
a883 1
m32r_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
d885 2
a886 2
  return frame_id_build (m32r_unwind_sp (gdbarch, next_frame),
			 frame_pc_unwind (next_frame));
d934 1
a934 1
  set_gdbarch_unwind_dummy_id (gdbarch, m32r_unwind_dummy_id);
d945 1
a945 1
  frame_unwind_append_sniffer (gdbarch, m32r_frame_sniffer);
@


1.54
log
@
	* gdbarch.sh (memory_insert_breakpoint, memory_remove_breakpoint): Add
	gdbarch as parameter.

	* gdbarch.{c,h}: Regenerate.

	* ppc-tdep.h (ppc_linux_memory_remove_breakpoint): Add gdbarch as
	parameter.
	* mem-break.c (default_memory_insert_breakpoint)
	(default_memory_remove_breakpoint): Likewise.
	* target.h (default_memory_remove_breakpoint)
	(default_memory_insert_breakpoint): Likewise.

	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Add gdbarch as
	parameter. Replace current_gdbarch by gdbarch.
	* m32r-tdep.c (m32r_memory_insert_breakpoint)
	(m32r_memory_remove_breakpoint): Likewise.
@
text
@d789 3
a791 3
m32r_return_value (struct gdbarch *gdbarch, struct type *valtype,
		   struct regcache *regcache, gdb_byte *readbuf,
		   const gdb_byte *writebuf)
@


1.53
log
@
	* gdbarch.sh (skip_prologue): Add gdbarch
	as parameter.
	* gdbarch.{c,h}: Regenerate.

	* alpha-tdep.c (alpha_skip_prologue): Add gdbarch as parameter.
	* amd64-tdep.c (amd64_skip_prologue): Likewise.
	* avr-tdep.c (avr_skip_prologue): Likewise.
	* cris-tdep.c (cris_skip_prologue): Likewise.
	* frv-tdep.c (frv_skip_prologue): Likewise.
	* h8300-tdep.c (h8300_skip_prologue): Likewise.
	* hppa-tdep.c (hppa_skip_prologue): Likewise.
	* i386-tdep.c (i386_skip_prologue): Likewise.
	* ia64-tdep.c (ia64_skip_prologue): Likewise.
	* iq2000-tdep.c (iq2000_skip_prologue): Likewise.
	* m32r-tdep.c (m32r_skip_prologue): Likewise.
	* m68hc11-tdep.c (m68hc11_skip_prologue): Likewise.
	* m68k-tdep.c (m68k_skip_prologue): Likewise.
	* m88k-tdep.c (m88k_skip_prologue): Likewise.
	* mep-tdep.c (mep_skip_prologue): Likewise.
	* mips-tdep.c (mips_skip_prologue): Likewise.
	* mn10300-tdep.c (mn10300_skip_prologue): Likewise.
	* mt-tdep.c (mt_skip_prologue): Likewise.
	* rs6000-tdep.c (rs6000_skip_prologue): Likewise.
	* score-tdep.c (score_skip_prologue): Likewise.
	* sh64-tdep.c (sh64_skip_prologue): Likewise.
	* sh-tdep.c (sh_skip_prologue): Likewise.
	* sparc64-tdep.c (sparc64_skip_prologue): Likewise.
	* sparc-tdep.c (sparc32_skip_prologue): Likewise.
	* spu-tdep.c (spu_skip_prologue): Likewise.
	* v850-tdep.c (v850_skip_prologue): Likewise.
	* vax-tdep.c (vax_skip_prologue): Likewise.
	* xstormy16-tdep.c (xstormy16_skip_prologue): Likewise.
	* xtensa-tdep.c (xtensa_skip_prologue): Likewise.

	* arm-tdep.c (arm_skip_prologue): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch.
	* m32c-tdep.c (m32c_skip_prologue): Likewise.
	* s390-tdep.c (s390_skip_prologue): Likewise.
@
text
@d82 2
a83 1
m32r_memory_insert_breakpoint (struct bp_target_info *bp_tgt)
d99 1
a99 1
  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
d140 2
a141 1
m32r_memory_remove_breakpoint (struct bp_target_info *bp_tgt)
d154 1
a154 1
  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
@


1.52
log
@	Updated copyright notices for most files.
@
text
@d451 1
a451 1
m32r_skip_prologue (CORE_ADDR pc)
@


1.51
log
@*** empty log message ***
@
text
@d3 2
a4 2
   Copyright (C) 1996, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007
   Free Software Foundation, Inc.
@


1.50
log
@2007-11-02  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (register_name): Add gdbarch parameter.
	* gdbarch.{c,h}: Regenerate.

	* target-descriptions.c (tdesc_register_name): Add gdbarch parameter.
	(tdesc_register_name): Replace current_gdbarch by gdbarch.
	* target-descriptions.h (tdesc_register_name): Add gdbarch parameter.

	* xstormy16-tdep.c (xstormy16_register_name): Add gdbarch parameter.
	* vax-tdep.c (vax_register_name): Add gdbarch parameter.
	* spu-tdep.c (spu_register_name): Add gdbarch parameter.
	* s390-tdep.c (s390_register_name): Add gdbarch parameter.
	* mt-tdep.c (mt_register_name): Add gdbarch parameter.
	(mt_registers_info): Replace current_gdbarch by gdbarch.
	(mt_register_reggroup_p): Add gdbarch to mt_register_name call.
	* mips-tdep.c (mips_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(mips_register_name): Add gdbarch to tdesc_register_name call.
	* mep-tdep.c (mep_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(mep_register_reggroup_p): Add gdbarch to mep_register_name call.
	* m32c-tdep.c (m32c_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	* m88k-tdep.c (m88k_register_name): Add gdbarch parameter.
	* m68k-tdep.c (m68k_register_name): Add gdbarch parameter.
	* m32r-tdep.c (m32r_register_name): Add gdbarch parameter.
	(m32r_frame_unwind_cache): Use get_frame_arch to get at the current
	architecture by frame_info.
	* iq2000-tdep.c (iq2000_register_name): Add gdbarch parameter.
	* ia64-tdep.c (ia64_register_name): Add gdbarch parameter.
	* hppa-tdep.c (hppa32_register_name, hppa64_register_name): Add gdbarch
	parameter.
	* h8300-tdep.c (h8300_register_name, h8300s_register_name)
	(h8300sx_register_name): Add gdbarch parameter.
	* cris-tdep.c (cris_register_name, crisv32_register_name): Add
	gdbarch parameter. Replace current_gdbarch by gdbarch.
	(cris_gdbarch_init): Replace current_gdbarch by gdbarch (comment).
	* avr-tdep.c (avr_register_name): Add gdbarch parameter.
	* arm-tdep.c (arm_register_name): Add gdbarch paramete
	* amd64-tdep.c (amd64_register_name): Add gdbarch parameter. Update
	caller.
	* amd64-tdep.h (amd64_register_name): Add gdbarch parameter.
	* amd64-linux-tdep.c (amd64_linux_register_name): Add gdbarch parameter.
	* alpha-tdep.c (alpha_register_name): Add gdbarch parameter.
	(alpha_cannot_fetch_register, alpha_cannot_store_register): Update call
	of alpha_register_name.
	* frv-tdep.c (frv_register_name): Add gdbarch parameter.
	* i386-tdep.c (i386_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(i386_register_type): Replace ?current_gdbarch by gdbarch.
	* i386-tdep.h (i386_register_name): Add gdbarch parameter.
	* i386-linux-tdep.c (i386_linux_register_name): Add gdbarch parameter.

	* m68hc11-tdep.c (m68hc11_register_name): Add gdbarch parameter.
	(m68hc11_register_reggroup_p): Add gdbarch to call of
	m68hc11_register_name.
	* mn10300-tdep.c (mn10300_generic_register_name, am33_register_name)
	(am33_2_register_name): Add gdbarch parameter.
	(mn10300_frame_unwind_cache): Use get_frame_arch to get at the current
	architecture by frame_info.
	(mn10300_dump_tdep): Replace current_gdbarch by gdbarch.
	* rs6000-tdep.c (rs6000_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	* score-tdep.c (score_register_name): Add gdbarch parameter.
	(score_return_value, score_push_dummy_call): Replace current_gdbarch
	by gdbarch.
	* sh64-tdep.c (sh64_register_name): Add gdbarch parameter.
	(sh64_compact_reg_base_num, sh64_register_convert_to_virtual)
	(sh64_register_convert_to_raw, sh64_fv_reg_base_num)
	(sh64_dr_reg_base_num, sh64_fpp_reg_base_num): Add gdbarch parameter
	and update caller. Replace current_gdbarch by gdbarch.
	(sh64_extract_return_value, sh64_store_return_value): Use
	get_regcache_arch to get at the current architecture by regcache.
	* sh-tdep.c (sh_sh_register_name, sh_sh3_register_name)
	(sh_sh3e_register_name, sh_sh2e_register_name, sh_sh2a_register_name)
	(sh_sh2a_nofpu_register_name, sh_sh_dsp_register_name)
	(sh_sh3_dsp_register_name, sh_sh4_register_name)
	(sh_sh4_nofpu_register_name, sh_sh4al_dsp_register_name): Add gdbarch
	parameter.
	(fv_reg_base_num, dr_reg_base_num, sh_justify_value_in_reg)
	(sh_next_flt_argreg): Add gdbarch parameter and update caller. Replace
	current_gdbarch by gdbarch.
	(sh_extract_return_value_fpu, sh_store_return_value_fpu): Use
	get_regcache_arch to get at the current architecture by regcache.
	* sparc-tdep.c (sparc32_register_name): Add gdbarch parameter.
	* sparc64-tdep.c (sparc64_register_name): Add gdbarch parameter.
	* v850-tdep.c (v850_register_name, v850e_register_name): Add gdbarch
	parameter.
	(v850_unwind_sp, v850_unwind_pc): Replace current_gdbarch by gdbarch.
	* xtensa-tdep.c (xtensa_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(xtensa_pseudo_register_read, xtensa_pseudo_register_write)
	(xtensa_frame_prev_register): Add gdbarch parameter to
	xtensa_register_name call.
@
text
@d169 1
a169 1
m32r_breakpoint_from_pc (CORE_ADDR *pcptr, int *lenptr)
d176 1
a176 1
  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
@


1.49
log
@	* m32r-tdep.c (decode_prologue): Sign extend offset for
	"addi sp, xx" case.
	(m32r_frame_unwind_cache): Likewise.
@
text
@d215 1
a215 1
m32r_register_name (int reg_nr)
d626 1
a626 1
  for (i = 0; i < gdbarch_num_regs (current_gdbarch) - 1; i++)
@


1.48
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d352 1
a352 1
	  int stack_adjust = (gdb_byte) (insn & 0xff);
d581 1
a581 1
	  int n = (gdb_byte) (op & 0xff);
@


1.47
log
@	* gdbarch.sh (read_pc): Add REGCACHE argument.  Remove PTID argument.
	(write_pc): Likewise.  Remove default implementation, add predicate.
	* gdbarch.c, gdbarch.h: Regenerate.
	* regcache.c (read_pc_pid): Use current regcache instead of calling
	read_register_pid.
	(write_pc_pid): Check gdbarch_write_pc predicate, implement default
	case inline.
	(generic_target_write_pc): Remove.
	* inferior.h (generic_target_write_pc): Remove.
	* frv-tdep.c (frv_gdbarch_init): Do not install it.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Likewise.
	* rs6000-tdep.c (rs6000_gdbarch_init): Likewise.
	* sh64-tdep.c (sh64_gdbarch_init): Likewise.
	* sh-tdep.c (sh_gdbarch_init): Likewise.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Likewise.

	* avr-tdep.c (avr_read_pc): Add REGCACHE argument.  Remove PTID
	argument.  Use REGCACHE instead of calling read_register_pid.
	* hppa-hpux-tdep.c (hppa_hpux_read_pc): Likewise.
	* hppa-tdep.c (hppa_read_pc): Likewise.
	* hppa-tdep.h (hppa_read_pc): Likewise.
	* ia64-tdep.c (ia64_read_pc): Likewise.
	* m32r-tdep.c (m32r_read_pc): Likewise.
	* mep-tdep.c (mep_read_pc): Likewise.
	* mn10300-tdep.c (mn10300_read_pc): Likewise.
	* spu-tdep.c (spu_read_pc): Likewise.

	* arm-tdep.c (arm_write_pc): Add REGCACHE argument.  Remove PTID
	argument.  Use REGCACHE instead of calling write_register_pid.
	* avr-tdep.c (avr_write_pc): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_write_pc): Likewise.
	* hppa-tdep.c (hppa_write_pc): Likewise.
	* hppa-tdep.h (hppa_write_pc): Likewise.
	* i386-linux-tdep.c (i386_linux_write_pc): Likewise.
	* amd64-linux-tdep.c (amd64_linux_write_pc): Likewise.
	* ia64-linux-tdep.c (ia64_linux_write_pc): Likewise.
	* ia64-tdep.c (ia64_write_pc): Likewise.
	* ia64-tdep.h (ia64_write_pc): Likewise.
	* m32r-tdep.c (m32r_write_pc): Likewise.
	* m88k-tdep.c (m88k_write_pc): Likewise.
	* mep-tdep.c (mep_write_pc): Likewise.
	* mips-tdep.c (mips_write_pc): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.
	* mn10300-tdep.c (mn10300_write_pc): Likewise.
	* sparc-tdep.c (sparc_write_pc): Likewise.
	* spu-tdep.c (spu_write_pc): Likewise.

	* mips-tdep.c (read_signed_register): Remove.
	(read_signed_register_pid): Likewise.
	(mips_read_pc): Add REGCACHE argument.  Remove PTID argument.
	Use REGCACHE instead of calling read_signed_register_pid.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.46
log
@2007-05-31  Markus Deuling  <deuling@@de.ibm.com>

	* xtensa-tdep.c (XTENSA_IS_ENTRY, extract_call_winsize)
	(xtensa_register_write_masked, xtensa_register_read_masked)
	(xtensa_extract_return_value, xtensa_store_return_value
	(xtensa_push_dummy_call, xtensa_breakpoint_from_pc): Replace
	TARGET_BYTE_ORDER by gdbarch_byte_order.
	* sh-tdep.c (sh_breakpoint_from_pc, gdb_print_insn_sh)
	(sh_justify_value_in_reg, sh_next_flt_argreg, sh_push_dummy_call_fpu)
	(sh_extract_return_value_fpu, sh_store_return_value_fpu): Likewise.
	* sh64-tdep.c (sh64_breakpoint_from_pc, gdb_print_insn_sh64)
	(sh64_push_dummy_call, sh64_extract_return_value)
	(sh64_store_return_value, sh64_register_convert_to_virtual)
	(sh64_register_convert_to_raw, sh64_pseudo_register_read)
	(sh64_pseudo_register_write, sh64_do_fp_register)
	(sh64_frame_prev_register): Likewise.
	* score-tdep.c (score_print_insn, score_breakpoint_from_pc)
	(score_return_value, score_push_dummy_call, score_fetch_inst): Likewise.
	* rs6000-tdep.c (rs6000_breakpoint_from_pc, rs6000_push_dummy_call)
	(e500_move_ev_register,gdb_print_insn_powerpc): Likewise.
	* remote-m32r-sdi.c (m32r_resume, m32r_wait): Likewise.
	* ppc-linux-nat.c (store_register): Likewise.
	* nto-tdep.c (nto_find_and_open_solib)
	(nto_init_solib_absolute_prefix): Likewise.
	* mips-tdep.c (mips_pseudo_register_read, mips_pseudo_register_write)
	(mips_convert_register_p, mips_eabi_push_dummy_call)
	(mips_n32n64_push_dummy_call, mips_n32n64_return_value)
	(mips_o32_push_dummy_call, mips_o32_return_value)
	(mips_o64_push_dummy_call, mips_o64_return_value, mips_o64_return_value)
	(mips_read_fp_register_single, mips_read_fp_register_double)
	(mips_print_register, print_gp_register_row, gdb_print_insn_mips)
	(mips_breakpoint_from_pc): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_sigtramp_offset): Likewise.
	* mips-linux-tdep.c (mips64_supply_fpregset, mips64_fill_fpregset)
	(mips_linux_o32_sigframe_init): Likewise.
	* m32r-tdep.c (m32r_memory_insert_breakpoint)
	(m32r_memory_remove_breakpoint, m32r_breakpoint_from_pc): Likewise.
	* libunwind-frame.c (libunwind_frame_cache, libunwind_frame_sniffer)
	(libunwind_sigtramp_frame_sniffer, libunwind_get_reg_special): Likewise.
	* iq2000-tdep.c (iq2000_breakpoint_from_pc): Likewise.
	* coffread.c (process_coff_symbol): Likewise.
	* arm-tdep.c (convert_from_extended, convert_to_extended)
	(gdb_print_insn_arm): Likewise.
@
text
@d646 1
a646 1
m32r_read_pc (ptid_t ptid)
a647 1
  ptid_t save_ptid;
d649 1
a649 5

  save_ptid = inferior_ptid;
  inferior_ptid = ptid;
  regcache_cooked_read_unsigned (current_regcache, M32R_PC_REGNUM, &pc);
  inferior_ptid = save_ptid;
d654 1
a654 1
m32r_write_pc (CORE_ADDR val, ptid_t ptid)
d656 1
a656 6
  ptid_t save_ptid;

  save_ptid = inferior_ptid;
  inferior_ptid = ptid;
  write_register (M32R_PC_REGNUM, val);
  inferior_ptid = save_ptid;
@


1.45
log
@2007-05-31  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (NUM_REGS): Replace by gdbarch_num_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_registers)
	(inf_ptrace_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* i386-linux-nat.c (supply_gregset, fill_gregset)
	(i386_linux_fetch_inferior_registers)
	(i386_linux_store_inferior_registers): Likewise.
	* remote.c (init_remote_state,packet_reg_from_regnum)
	(packet_reg_from_pnum,process_g_packet,remote_fetch_registers)
	(remote_prepare_to_store,store_registers_using_G)
	(remote_store_registers,remote_arch_state): Likewise.
	* tracepoint.c (encode_actions): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* tui/tui-regs.c (tui_show_register_group)
	(tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* xtensa-tdep.c (xtensa_register_name,xtensa_register_type)
	(xtensa_reg_to_regnum,xtensa_pseudo_register_read)
	(xtensa_pseudo_register_write,xtensa_register_reggroup_p): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers)
	(do_win32_store_inferior_registers,fetch_elf_core_registers
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target-descriptions.c (tdesc_use_registers): Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_do_pseudo_register,sh64_print_register)
	(sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* rs6000-nat.c (fetch_register,store_register): Likewise.
	* remote-sim.c (one2one_register_sim_regno,gdbsim_fetch_register)
	(gdbsim_fetch_register,gdbsim_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers,mips_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers)
	(m32r_store_registers): Likewise.
	* reggroups.c (default_register_reggroup_p): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save)
	(regcache_restore,regcache_dump): Likewise.
	* monitor.c (monitor_fetch_registers,monitor_store_registers): Likewise.
	* mips-tdep.c (mips_xfer_register,mips_register_name)
	(mips_register_reggroup_p,mips_pseudo_register_read)
	(mips_pseudo_register_write,mips_convert_register_p,mips_register_type)
	(mips_unwind_pc,mips_unwind_sp,mips_unwind_dummy_id,set_reg_offset)
	(mips16_scan_prologue,mips_insn16_frame_cache,reset_saved_regs)
	(mips32_scan_prologue,mips_insn32_frame_cache,read_next_frame_reg)
	(mips_n32n64_return_value,mips_o32_return_value,mips_o64_return_value)
	(print_gp_register_row,mips_print_registers_info)
	(mips_stab_reg_to_regnum,mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_register_sim_regno): Likewise.
	* mips-linux-tdep.c (mips_linux_o32_sigframe_init)
	(mips_linux_n32n64_sigframe_init): Likewise.
	* mips-linux-nat.c (mips_linux_register_addr)
	(mips64_linux_register_addr): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* mips64obsd-tdep.c (mips64obsd_sigframe_init): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache(: Likewise.
	* m32r-tdep.c (m32r_frame_unwind_cache): Likewise.
	* ia64-linux-nat.c (ia64_register_addr,ia64_cannot_fetch_register)
	(ia64_cannot_store_register,ia64_linux_fetch_registers)
	(ia64_linux_store_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Likewise.
	* h8300-tdep.c (E_PSEUDO_CCR_REGNUM,E_PSEUDO_EXR_REGNUM)
	(h8300_init_frame_cache,h8300_frame_cache,h8300_frame_prev_register)
	(h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache)
	(dwarf2_frame_state_alloc_regs): Likewise.
	* cris-tdep.c (cris_register_size,cris_cannot_fetch_register)
	(cris_cannot_store_register,crisv32_cannot_fetch_register)
	(crisv32_cannot_store_register,cris_register_name): Likewise.
	* avr-tdep.c (avr_frame_unwind_cache): Likewise.
	* arch-utils.c (legacy_register_sim_regno)
	(legacy_virtual_frame_pointer): Likewise.
	* arm-tdep.c (arm_make_prologue_cache,arm_register_sim_regno):Likewise.
	* arm-tdep.h: Likewise (comment).
	* frv-tdep.c (frv_register_sim_regno): Likewise.
	* m68klinux-nat.c (old_fetch_inferior_registers)
	(old_store_inferior_registers): Likewise.
	* m32c-tdep.c (m32c_virtual_frame_pointer): Likewise.
	* irix5-nat.c (fetch_core_registers): Likewise.
	* hppa-tdep.c (hppa_frame_cache): Likewise.
	* hppa-linux-nat.c (hppa_linux_register_addr)
	(hppa_linux_fetch_inferior_registers)
	(hppa_linux_store_inferior_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_inferior_registers)
	(hppa_hpux_store_inferior_registers): Likewise.
	* amd64-nat.c (amd64_native_gregset_reg_offset)
	(amd64_supply_native_gregset,amd64_collect_native_gregset): Likewise.
	* dbug-rom.c (dbug_regname): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache)
	(HARD_PAGE_REGNUM (comment)): Likewise.
	* gdbarch.sh (NUM_PSEUDO_REGS): Replace by gdbarch_num_pseudo_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
	* tui/tui-regs.c (tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_print_register,sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save
	(regcache_restore,regcache_dump): Likewise.
	* mips-tdep.c (print_gp_register_row,mips_print_registers_info)
	(mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_stab_reg_to_regnum): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache): Likewise.
	* frame.h (SIZEOF_FRAME_SAVED_REGS): Likewise.
	* xtensa-tdep.c (xtensa_register_type,xtensa_reg_to_regnum)
	(xtensa_pseudo_register_read,xtensa_pseudo_register_write): Likewise.
	* parse.c: Remove comment.
	* gdbarch.c, gdbarch.h: Regenerate
@
text
@d100 1
a100 1
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
d154 1
a154 1
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
d178 1
a178 1
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
@


1.44
log
@	* gdbarch.sh (overlay_update): New gdbarch function.
	(struct obj_section): Add forward declaration.
	* gdbarch.c, gdbarch.h: Regenerate.

	* symfile.c (simple_overlay_update): Make global.
	(target_overlay_update): Remove variable.
	(overlay_is_mapped): Call gdbarch_overlay_update instead of
	target_overlay_update.
	(overlay_load_command): Likewise.
	* symfile.h (struct obj_section): Add forward declaration.
	(simple_overlay_update): Add prototype.

	* m32r-tdep.c (m32r_gdbarch_init): Install simple_overlay_update.
@
text
@d628 1
a628 1
  for (i = 0; i < NUM_REGS - 1; i++)
@


1.43
log
@	* dwarf2-frame.c (dwarf2_frame_cache, dwarf2_frame_this_id)
	(dwarf2_frame_sniffer): Update.
	(dwarf2_signal_frame_this_id): New function.
	(dwarf2_signal_frame_unwind): Use it.
	(dwarf2_frame_base_sniffer): Use frame_unwind_address_in_block.
	* frame.c (frame_func_unwind): Add this_type argument.
	(get_frame_func): Update.
	(frame_unwind_address_in_block): Add this_type argument and check it.
	Fix a typo.
	(get_frame_address_in_block): Update.
	* frame.h (enum frame_type): Move higher in the file.
	(frame_unwind_address_in_block, frame_func_unwind): Add enum frame_type
	argument.

	* alpha-mdebug-tdep.c, alpha-tdep.c, amd64-tdep.c, amd64obsd-tdep.c,
	arm-tdep.c, avr-tdep.c, cris-tdep.c, frv-tdep.c, h8300-tdep.c,
	hppa-tdep.c, i386-tdep.c, i386obsd-tdep.c, ia64-tdep.c,
	libunwind-frame.c, m32c-tdep.c, m32r-linux-tdep.c, m32r-tdep.c,
	m68hc11-tdep.c, m68k-tdep.c, m88k-tdep.c, mips-mdebug-tdep.c,
	mips-tdep.c, mn10300-tdep.c, mt-tdep.c, rs6000-tdep.c, s390-tdep.c,
	score-tdep.c, sh-tdep.c, sh64-tdep.c, sparc-tdep.c,
	sparc64obsd-tdep.c, spu-tdep.c, v850-tdep.c, vax-tdep.c,
	xstormy16-tdep.c, xtensa-tdep.c: Update calls to
	frame_func_unwind and frame_unwind_address_in_block to specify
	the frame type.  Use frame_unwind_address_in_block instead of
	frame_pc_unwind in sniffers.

	* gdb.arch/i386-signal.c, gdb.arch/i386-signal.exp: New files.
@
text
@d966 3
@


1.42
log
@Copyright updates for 2007.
@
text
@d539 1
a539 1
  for (pc = frame_func_unwind (next_frame);
d838 1
a838 1
  func = frame_func_unwind (next_frame);
@


1.41
log
@gdb/
	* breakpoint.c (deprecated_read_memory_nobpt): Update to use
	shadow_len.
	(insert_bp_location, reattach_breakpoints, remove_breakpoint)
	(delete_breakpoint): Update calls to changed methods.
	(deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint)
	(single_step_breakpoints, insert_single_step_breakpoint)
	(remove_single_step_breakpoints): New.
	* breakpoint.h (struct bp_target_info): New.
	(struct bp_location): Replace shadow_contents with
	target_info and overlay_target_info.
	(deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint)
	(insert_single_step_breakpoint, remove_single_step_breakpoints): New
	prototypes.
	* gdbarch.sh: Forward declare struct bp_target_info in gdbarch.h.
	(memory_insert_breakpoint, memory_remove_breakpoint): Update second
	argument.
	* mem-break.c (default_memory_insert_breakpoint): Update.  Set
	placed_address, placed_size, and shadow_len.
	(default_memory_remove_breakpoint): Update.  Don't use
	BREAKPOINT_FROM_PC.
	(memory_insert_breakpoint, memory_remove_breakpoint): Update.
	* target.c (update_current_target): Update prototypes for changed
	functions.
	(debug_to_insert_breakpoint, debug_to_remove_breakpoint)
	(debug_to_insert_hw_breakpoint, debug_to_remove_hw_breakpoint):
	Update.
	* target.h: Forward declare struct bp_target_info.
	(struct target_ops): Use a bp_target_info argument for
	to_insert_breakpoint, to_remove_breakpoint,
	to_insert_hw_breakpoint, and to_remove_hw_breakpoint.
	(target_insert_breakpoint, target_remove_breakpoint)
	(target_insert_hw_breakpoint, target_remove_hw_breakpoint)
	(memory_insert_breakpoint, memory_remove_breakpoint)
	(default_memory_insert_breakpoint, default_memory_remove_breakpoint):
	Update.
	* config/i386/nm-i386.h: Forward declare struct bp_target_info.
	(i386_insert_hw_breakpoint, i386_remove_hw_breakpoint): Update.
	(target_insert_hw_breakpoint, target_remove_hw_breakpoint): Likewise.

	* gdbarch.c, gdbarch.h: Regenerated.

	* alpha-tdep.c (alpha_software_single_step): Use
	insert_single_step_breakpoint and remove_single_step_breakpoints.
	Remove unused statics.
	* arm-tdep.c (arm_software_single_step): Likewise.  Add a note.
	* cris-tdep.c (cris_software_single_step): Likewise.
	* mips-tdep.c (mips_software_single_step): Likewise.
	* rs6000-tdep.c (rs6000_software_single_step): Likewise.
	* sparc-tdep.c (sparc_software_single_step): Likewise.
	* wince.c (struct thread_info_struct): Remove step_prev.
	(undoSStep): Use remove_single_step_breakpoints.
	(wince_software_single_step): Use insert_single_step_breakpoint.

	* corelow.c (ignore): Remove unneeded prototype.  Update arguments.
	* exec.c (ignore): Likewise.
	* sol-thread.c (ignore): Likewise.

	* procfs.c (dbx_link_shadow_contents): Delete.
	(dbx_link_bpt): New.
	(procfs_mourn_inferior): Remove it if necessary.
	(remove_dbx_link_breakpoint): Use it.
	(insert_dbx_link_bpt_in_file): Set it.
	(procfs_init_inferior): Don't update dbx_link_bpt_addr.
	* rs6000-nat.c (exec_one_dummy_insn): Use
	deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint.
	* solib-irix.c (shadow_contents, breakpoint_addr): Delete.
	(base_breakpoint): New.
	(disable_break): Use it.
	(enable_break): Set it.

	* i386-nat.c (i386_insert_hw_breakpoint, i386_remove_hw_breakpoint):
	Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint)
	(ia64_memory_remove_breakpoint): Likewise.
	* m32r-tdep.c (m32r_memory_insert_breakpoint)
	(m32r_memory_remove_breakpoint): Likewise.
	* monitor.c (monitor_insert_breakpoint, monitor_remove_breakpoint):
	Likewise.  Remove unnecessary prototypes.  Use placed_address
	and placed_size.  Removed useless read from memory.
	* nto-procfs.c (procfs_insert_breakpoint)
	(procfs_remove_breakpoint, procfs_insert_hw_breakpoint)
	(procfs_remove_hw_breakpoint): Update.
	* ocd.c (ocd_insert_breakpoint, ocd_remove_breakpoint): Likewise.
	* ocd.h (ocd_insert_breakpoint, ocd_remove_breakpoint): Likewise.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Likewise.
	* ppc-tdep.h (ppc_linux_memory_remove_breakpoint): Likewise.
	* remote-e7000.c (e7000_insert_breakpoint)
	(e7000_remove_breakpoint): Likewise.
	* remote-m32r-sdi.c (m32r_insert_breakpoint)
	(m32r_remove_breakpoint): Likewise.
	* remote-mips.c (mips_insert_breakpoint)
	(mips_remove_breakpoint): Likewise.
	* remote-rdp.c (remote_rdp_insert_breakpoint)
	(remote_rdp_remove_breakpoint): Likewise.
	(rdp_step): Use deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint.
	* remote-sds.c (sds_insert_breakpoint, sds_remove_breakpoint):
	Update.
	* remote-sim.c (gdbsim_insert_breakpoint, gdbsim_remove_breakpoint):
	Delete.
	(init_gdbsim_ops): Use memory_insert_breakpoint and
	memory_remove_breakpoint.
	* remote-st.c (st2000_insert_breakpoint)
	(st2000_remove_breakpoint): Update.  Remove unused
	BREAKPOINT_FROM_PC.
	* remote.c (remote_insert_breakpoint, remote_remove_breakpoint):
	Update.  Use placed_address and placed_size.
	(remote_insert_hw_breakpoint, remote_remove_hw_breakpoint): Likewise.
gdb/doc/
	* gdbint.texinfo (x86 Watchpoints, Target Conditionals): Update insert
	and remove breakpoint prototypes.
	(Watchpoints): Move description of target_insert_hw_breakpoint and
	target_remove_hw_breakpoint ...
	(Breakpoints): ... to here.  Document target_insert_breakpoint and
	target_remove_breakpoint.
@
text
@d3 2
a4 2
   Copyright (C) 1996, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005 Free
   Software Foundation, Inc.
@


1.40
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d84 1
a84 1
m32r_memory_insert_breakpoint (CORE_ADDR addr, bfd_byte *contents_cache)
d86 1
d89 1
d97 2
d141 1
a141 1
m32r_memory_remove_breakpoint (CORE_ADDR addr, bfd_byte *contents_cache)
d143 1
d146 1
@


1.40.8.1
log
@Merge to branch:
  http://sourceware.org/ml/gdb-patches/2006-04/msg00139.html
@
text
@d84 1
a84 1
m32r_memory_insert_breakpoint (CORE_ADDR addr, struct bp_location *bpt)
a87 1
  gdb_byte *contents_cache = bpt->shadow_contents;
d137 1
a137 1
m32r_memory_remove_breakpoint (CORE_ADDR addr, struct bp_location *bpt)
a140 1
  gdb_byte *contents_cache = bpt->shadow_contents;
@


1.39
log
@2005-11-08  Kei Sakamoto  <sakamoto.kei@@renesas.com>

	* m32r-linux-tdep.c (linux_sigtramp_code): Use 'gdb_byte' instead
	of 'unsigned char'.
	(m32r_linux_sigtramp_start): Likewise.
	(linux_rt_sigtramp_code): Likewise.
	(m32r_linux_rt_sigtramp_start): Likewise.
	(m32r_linux_sigtramp_frame_prev_register): Use 'gdb_byte *' instead
	of 'void *'.
	* m32r-tdep.c (m32r_memory_insert_breakpoint): Use 'gdb_byte'
	instead of 'char'.
	(m32r_memory_remove_breakpoint): Likewise.
	(m32r_breakpoint_from_pc): Likewise.
	(m32r_store_return_value): Likewise.
	(decode_prologue): Likewise.
	(m32r_push_dummy_call): Likewise.
	(m32r_return_value): Use 'gdb_byte *' instead of 'void *'.
	* remote-m32r-sdi.c (m32r_xfer_memory): Use 'gdb_byte' instead of
	'char'.
@
text
@d3 1
a3 1
   Copyright 1996, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005 Free
d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.38
log
@2005-05-01  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (deprecated_extract_return_value)
	(breakpoint_from_pc, deprecated_store_return_value)
	(memory_insert_breakpoint, memory_remove_breakpoint): Change type
	of buffer to a bfd_byte pointer.
	* gdbarch.h, gdbarch.c: Re-generate.
	* mem-break.c (memory_insert_breakpoint)
	(memory_remove_breakpoint, default_memory_insert_breakpoint)
	(default_memory_remove_breakpoint): Update.
	* target.h (memory_insert_breakpoint)
	(memory_remove_breakpoint, default_memory_insert_breakpoint)
	(default_memory_remove_breakpoint): Update declarations.
	(struct target_ops): Update to_insert_breakpoint and
	to_remove_breakpoint.
	* target.c (debug_to_remove_breakpoint)
	(debug_to_insert_breakpoint): Update.
	* remote-m32r-sdi.c (m32r_remove_breakpoint)
	(m32r_insert_breakpoint): Update.
	* m32r-tdep.c (m32r_memory_insert_breakpoint)
	(m32r_memory_remove_breakpoint): Update.
	* remote-e7000.c (e7000_insert_breakpoint)
	(e7000_remove_breakpoint): Update.
	* remote-rdi.c (arm_rdi_insert_breakpoint)
	(arm_rdi_remove_breakpoint): Update.
	* remote-sim.c (gdbsim_insert_breakpoint)
	(gdbsim_remove_breakpoint): Update.
	* exec.c (ignore): Update.
	* rs6000-tdep.c (rs6000_extract_return_value): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint)
	(ia64_memory_remove_breakpoint): Update.
	* remote-rdp.c (remote_rdp_insert_breakpoint)
	(remote_rdp_remove_breakpoint): Update.
@
text
@d87 2
a88 2
  char buf[4];
  char bp_entry[] = { 0x10, 0xf1 };	/* dpt */
d140 1
a140 1
  char buf[4];
d164 1
a164 1
static const unsigned char *
d167 3
a169 3
  static char be_bp_entry[] = { 0x10, 0xf1, 0x70, 0x00 };	/* dpt -> nop */
  static char le_bp_entry[] = { 0x00, 0x70, 0xf1, 0x10 };	/* dpt -> nop */
  unsigned char *bp;
d253 1
a253 1
      regval = extract_unsigned_integer ((char *) valbuf + 4, len - 4);
d348 1
a348 1
	  int stack_adjust = (char) (insn & 0xff);
d577 1
a577 1
	  int n = (char) (op & 0xff);
d682 2
a683 2
  char *val;
  char valbuf[MAX_REGISTER_SIZE];
d729 1
a729 1
		  (char *) value_contents (args[argnum]), len);
d733 1
a733 1
	val = (char *) value_contents (args[argnum]);
d794 2
a795 2
		   struct regcache *regcache, void *readbuf,
		   const void *writebuf)
d855 1
a855 1
			  int *realnump, void *bufferp)
@


1.37
log
@2005-02-06  Andrew Cagney  <cagney@@gnu.org>

	* value.c (value_contents, value_contents_writeable): New
	functions.
	* value.h (VALUE_CONTENTS): Delete macro.
	(value_contents, value_contents_writeable): Declare.
	* xstormy16-tdep.c, value.c, valops.c, valarith.c: Update.
	* stack.c, sparc-tdep.c, sparc64-tdep.c, sh-tdep.c: Update.
	* sh64-tdep.c, scm-valprint.c, scm-exp.c, s390-tdep.c: Update.
	* rs6000-tdep.c, p-valprint.c, printcmd.c: Update.
	* ppc-sysv-tdep.c, mips-tdep.c, mi/mi-main.c: Update.
	* m88k-tdep.c, m68hc11-tdep.c, m32r-tdep.c: Update.
	* jv-valprint.c, ia64-tdep.c, hppa-tdep.c: Update.
	* hpacc-abi.c, f-valprint.c, frv-tdep.c, eval.c: Update.
	* c-valprint.c, cris-tdep.c, cp-valprint.c: Update.
	* cli/cli-dump.c, breakpoint.c, avr-tdep.c, arm-tdep.c: Update.
	* arm-linux-tdep.c, amd64-tdep.c, alpha-tdep.c: Update.
	* ada-valprint.c, ada-lang.c: Update.
@
text
@d84 1
a84 1
m32r_memory_insert_breakpoint (CORE_ADDR addr, char *contents_cache)
d137 1
a137 1
m32r_memory_remove_breakpoint (CORE_ADDR addr, char *contents_cache)
@


1.36
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	* sparc-tdep.c: Replace VALUE_TYPE with value_type.
	* v850-tdep.c, sparc64-tdep.c, sh-tdep.c: Ditto.
	* sh64-tdep.c, s390-tdep.c, mcore-tdep.c: Ditto.
	* h8300-tdep.c, arm-linux-tdep.c, amd64-tdep.c: Ditto.
	* hppa-tdep.c, mips-tdep.c, m88k-tdep.c: Ditto.
	* m68hc11-tdep.c, m32r-tdep.c, ia64-tdep.c: Ditto.
	* frv-tdep.c, cris-tdep.c, avr-tdep.c, alpha-tdep.c: Ditto.
@
text
@d3 2
a4 2
   Copyright 1996, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
   Foundation, Inc.
d729 1
a729 1
		  (char *) VALUE_CONTENTS (args[argnum]), len);
d733 1
a733 1
	val = (char *) VALUE_CONTENTS (args[argnum]);
@


1.35
log
@2004-11-04  Kei Sakamoto  <sakamoto.kei@@denesas.com>
	* Makefile.in (m32r-tdep.o): Update dependencies.
	* m32r-tdep.c (m32r_gdbarch_init): Call gdbarch_init_osabi for
	ABI-specific overrides.
@
text
@d705 1
a705 1
    stack_alloc += ((TYPE_LENGTH (VALUE_TYPE (args[argnum])) + 3) & ~3);
d710 1
a710 1
      type = VALUE_TYPE (args[argnum]);
@


1.34
log
@2004-11-04  Kei Sakamoto  <sakamoto.kei@@denesas.com>
        * m32r-tdep.c (m32r_memory_insert_breakpoint): Remove
        unnecessary parallel execution bit.
        (m32r_memory_remove_breakpoint): Ditto.
        (m32r_breakpoint_from_pc): Update.
@
text
@d36 1
a941 1
  frame_unwind_append_sniffer (gdbarch, m32r_frame_sniffer);
d954 6
@


1.33
log
@2004-10-07  Kei Sakamoto  <sakamoto.kei@@renesas.com>

        * m32r-tdep.c (decode_prologue): Support functions written
        in assembler language. Recognize trap instructions as the
        end of prologue.
        (m32r_frame_unwind_cache): Ditto.
        (m32r_skip_prologue): Extend search limit. Quit analyzing
        prologue if pc's location is not readable.
@
text
@d59 22
a80 5
/* BREAKPOINT */
#define M32R_BE_BREAKPOINT32 {0x10, 0xf1, 0x70, 0x00}
#define M32R_LE_BREAKPOINT32 {0xf1, 0x10, 0x00, 0x70}
#define M32R_BE_BREAKPOINT16 {0x10, 0xf1}
#define M32R_LE_BREAKPOINT16 {0xf1, 0x10}
d86 2
a87 4
  unsigned char *bp;
  int bplen;

  bplen = (addr & 3) ? 2 : 4;
d90 1
a90 1
  val = target_read_memory (addr, contents_cache, bplen);
d97 1
a97 2
      if (((addr & 3) == 0)
	  && ((contents_cache[0] & 0x80) || (contents_cache[2] & 0x80)))
d99 4
a102 3
	  static unsigned char insn[] = M32R_BE_BREAKPOINT32;
	  bp = insn;
	  bplen = sizeof (insn);
d106 4
a109 3
	  static unsigned char insn[] = M32R_BE_BREAKPOINT16;
	  bp = insn;
	  bplen = sizeof (insn);
d112 8
a119 8
  else
    {				/* little-endian */
      if (((addr & 3) == 0)
	  && ((contents_cache[1] & 0x80) || (contents_cache[3] & 0x80)))
	{
	  static unsigned char insn[] = M32R_LE_BREAKPOINT32;
	  bp = insn;
	  bplen = sizeof (insn);
d123 4
a126 3
	  static unsigned char insn[] = M32R_LE_BREAKPOINT16;
	  bp = insn;
	  bplen = sizeof (insn);
d131 1
a131 1
  val = target_write_memory (addr, (char *) bp, bplen);
d139 1
a139 1
  int bplen;
d141 6
a146 1
  /* Determine appropriate breakpoint contents and size for this address.  */
d149 2
a150 11
      if (((addr & 3) == 0)
	  && ((contents_cache[0] & 0x80) || (contents_cache[2] & 0x80)))
	{
	  static unsigned char insn[] = M32R_BE_BREAKPOINT32;
	  bplen = sizeof (insn);
	}
      else
	{
	  static unsigned char insn[] = M32R_BE_BREAKPOINT16;
	  bplen = sizeof (insn);
	}
d152 1
a152 1
  else
d154 2
a155 12
      /* little-endian */
      if (((addr & 3) == 0)
	  && ((contents_cache[1] & 0x80) || (contents_cache[3] & 0x80)))
	{
	  static unsigned char insn[] = M32R_BE_BREAKPOINT32;
	  bplen = sizeof (insn);
	}
      else
	{
	  static unsigned char insn[] = M32R_BE_BREAKPOINT16;
	  bplen = sizeof (insn);
	}
d159 1
a159 1
  val = target_write_memory (addr, contents_cache, bplen);
d166 2
d175 2
a176 3
	  static unsigned char insn[] = M32R_BE_BREAKPOINT32;
	  bp = insn;
	  *lenptr = sizeof (insn);
d180 2
a181 3
	  static unsigned char insn[] = M32R_BE_BREAKPOINT16;
	  bp = insn;
	  *lenptr = sizeof (insn);
d188 2
a189 3
	  static unsigned char insn[] = M32R_LE_BREAKPOINT32;
	  bp = insn;
	  *lenptr = sizeof (insn);
d193 2
a194 3
	  static unsigned char insn[] = M32R_LE_BREAKPOINT16;
	  bp = insn;
	  *lenptr = sizeof (insn);
@


1.33.2.1
log
@2004-11-04  Kei Sakamoto  <sakamoto.kei@@denesas.com>
        * m32r-tdep.c (m32r_memory_insert_breakpoint): Remove
        unnecessary parallel execution bit.
        (m32r_memory_remove_breakpoint): Ditto.
        (m32r_breakpoint_from_pc): Update.
@
text
@d59 5
a63 22
/* Breakpoints
 
   The little endian mode of M32R is unique. In most of architectures,
   two 16-bit instructions, A and B, are placed as the following:
  
   Big endian:
   A0 A1 B0 B1
  
   Little endian:
   A1 A0 B1 B0
  
   In M32R, they are placed like this:
  
   Big endian:
   A0 A1 B0 B1
  
   Little endian:
   B1 B0 A1 A0
  
   This is because M32R always fetches instructions in 32-bit.
  
   The following functions take care of this behavior. */
d69 4
a72 2
  char buf[4];
  char bp_entry[] = { 0x10, 0xf1 };	/* dpt */
d75 1
a75 1
  val = target_read_memory (addr & 0xfffffffc, contents_cache, 4);
d82 2
a83 1
      if ((addr & 3) == 0)
d85 3
a87 4
	  buf[0] = bp_entry[0];
	  buf[1] = bp_entry[1];
	  buf[2] = contents_cache[2] & 0x7f;
	  buf[3] = contents_cache[3];
d91 3
a93 4
	  buf[0] = contents_cache[0];
	  buf[1] = contents_cache[1];
	  buf[2] = bp_entry[0];
	  buf[3] = bp_entry[1];
d96 8
a103 8
  else				/* little-endian */
    {
      if ((addr & 3) == 0)
	{
	  buf[0] = contents_cache[0];
	  buf[1] = contents_cache[1] & 0x7f;
	  buf[2] = bp_entry[1];
	  buf[3] = bp_entry[0];
d107 3
a109 4
	  buf[0] = bp_entry[1];
	  buf[1] = bp_entry[0];
	  buf[2] = contents_cache[2];
	  buf[3] = contents_cache[3];
d114 1
a114 1
  val = target_write_memory (addr & 0xfffffffc, buf, 4);
d122 1
a122 1
  char buf[4];
d124 1
a124 6
  buf[0] = contents_cache[0];
  buf[1] = contents_cache[1];
  buf[2] = contents_cache[2];
  buf[3] = contents_cache[3];

  /* Remove parallel bit.  */
d127 11
a137 2
      if ((buf[0] & 0x80) == 0 && (buf[2] & 0x80) != 0)
	buf[2] &= 0x7f;
d139 1
a139 1
  else				/* little-endian */
d141 12
a152 2
      if ((buf[3] & 0x80) == 0 && (buf[1] & 0x80) != 0)
	buf[1] &= 0x7f;
d156 1
a156 1
  val = target_write_memory (addr & 0xfffffffc, buf, 4);
a162 2
  static char be_bp_entry[] = { 0x10, 0xf1, 0x70, 0x00 };	/* dpt -> nop */
  static char le_bp_entry[] = { 0x00, 0x70, 0xf1, 0x10 };	/* dpt -> nop */
d170 3
a172 2
	  bp = be_bp_entry;
	  *lenptr = 4;
d176 3
a178 2
	  bp = be_bp_entry;
	  *lenptr = 2;
d185 3
a187 2
	  bp = le_bp_entry;
	  *lenptr = 4;
d191 3
a193 2
	  bp = le_bp_entry + 2;
	  *lenptr = 2;
@


1.33.2.2
log
@2004-11-04  Kei Sakamoto  <sakamoto.kei@@denesas.com>

	* Makefile.in (m32r-tdep.o): Update dependencies.
	* m32r-tdep.c (m32r_gdbarch_init): Call gdbarch_init_osabi for
	ABI-specific overrides.
@
text
@a35 1
#include "osabi.h"
d941 1
a953 6
  /* Hook in ABI-specific overrides, if they have been registered.  */
  gdbarch_init_osabi (info, gdbarch);

  /* Hook in the default unwinders.  */
  frame_unwind_append_sniffer (gdbarch, m32r_frame_sniffer);

@


1.32
log
@2004-10-05  Kei Sakamoto  <sakamoto.kei@@renesas.com>

	* m32r-tdep.c (m32r_use_struct_convention): Delete function.
	(m32r_extract_struct_value_address): Delete function.
	(m32r_return_value): New function.
	(m32r_gdbarch_init): Instead of store_return_value,
	extract_return_value, deprecated_extract_struct_value_address
	and deprecated_use_struct_convention, set return_value.
@
text
@d3 1
a3 1
   Copyright 1996, 1998, 1999, 2000, 2001, 2002, 2003 Free Software
d259 1
a259 1
static void
d261 1
a261 1
		 CORE_ADDR *pl_endptr)
a265 1
  int maybe_one_more = 0;
d267 1
d270 1
d277 4
d283 3
a289 12
	  /* Clear the parallel execution bit from 16 bit instruction */
	  if (maybe_one_more)
	    {
	      /* The last instruction was a branch, usually terminates
	         the series, but if this is a parallel instruction,
	         it may be a stack framing instruction */
	      if (!(insn & 0x8000))
		{
		  /* nope, we are really done */
		  break;
		}
	    }
a294 2
	  if (maybe_one_more)
	    break;		/* This isnt the one more */
d299 1
d301 5
d315 2
d329 1
a329 1
	      after_prologue = current_pc;
d368 1
d375 6
a384 1
	  maybe_one_more = 1;
a393 1
	      maybe_one_more = 1;
d399 3
d413 7
d427 1
a427 1
      return;
d429 1
d435 2
d442 1
a442 1
#define DEFAULT_SEARCH_LIMIT 44
d449 1
d471 9
a479 1
  decode_prologue (pc, func_end, &sal.end);
a482 1

d511 1
a511 1
  CORE_ADDR pc;
d514 1
a514 1
  unsigned long op;
d518 1
d528 1
d530 1
a530 1
  info->uses_frame = 0;
d532 1
a532 1
       pc > 0 && pc < frame_pc_unwind (next_frame); pc += 2)
d546 2
a547 2
	      else if (((op >> 8) == 0xe4)	/* ld24 r4, xxxxxx; sub sp, r4 */
		       && get_frame_memory_unsigned (next_frame, pc + 4,
d550 1
d553 1
a553 1
		  pc += 2;
a554 2
	      else
		break;
d556 3
a558 1
	      pc += 2;
d583 6
a589 5
      else if (op == 0x7000)
	/* nop */
	continue;
      else
	break;
@


1.31
log
@2004-09-30    Kei Sakamoto  <sakamoto.kei@@renesas.com>

        Add m32r-linux support.
        * configure.tgt: Add m32r*-*-linux*.
        * Makefile.in (ALLDEPFILES): Add m32r-tdep.c, m32r-linux-nat.c
        and m32r-linux-tdep.c.
        (m32r-linux-nat.o, m32r-linux-tdep.o): New dependencies.
        * m32r-tdep.c: Move some definitions to m32r-tdep.h.
        * config/djgpp/fnchange.lst: Add m32r-linux-nat.c and
        m32r-linux-tdep.c.
        * m32r-tdep.h, m32r-linux-nat.c, m32r-linux-tdep.c,
        config/m32r/linux.mh, config/m32r/linux.mt,
        config/m32r/nm-linux.h: New files.
@
text
@a57 13
/* Should we use DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS instead of
   EXTRACT_RETURN_VALUE?  GCC_P is true if compiled with gcc and TYPE
   is the type (which is known to be struct, union or array).

   The m32r returns anything less than 8 bytes in size in
   registers. */

static int
m32r_use_struct_convention (int gcc_p, struct type *type)
{
  return (TYPE_LENGTH (type) > 8);
}

a255 13
/* Extract from an array REGBUF containing the (raw) register state
   the address in which a function should return its structure value,
   as a CORE_ADDR (or an expression that can be used as one).  */

static CORE_ADDR
m32r_extract_struct_value_address (struct regcache *regcache)
{
  ULONGEST addr;
  regcache_cooked_read_unsigned (regcache, ARG1_REGNUM, &addr);
  return addr;
}


d758 18
a894 1
  set_gdbarch_extract_return_value (gdbarch, m32r_extract_return_value);
d896 1
a896 5
  set_gdbarch_store_return_value (gdbarch, m32r_store_return_value);
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch,
						       m32r_extract_struct_value_address);
  set_gdbarch_deprecated_use_struct_convention (gdbarch,
						m32r_use_struct_convention);
@


1.30
log
@2004-08-02  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (deprecated_frameless_function_invocation): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arm-tdep.c 	(arm_frameless_function_invocation): Delete.
	(arm_gdbarch_init) Do not set frameless function invocation.
	* frame.h (legacy_frameless_look_for_prologue): Delete declaration.
	* blockframe.c (legacy_frameless_look_for_prologue): Delete function.
	* frv-tdep.c (frv_frameless_function_invocation): Delete.
	(frv_gdbarch_init): Do not set frameless function invocation.
	* sh64-tdep.c (sh64_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* m32r-tdep.c (m32r_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
@
text
@d44 1
a44 21
struct gdbarch_tdep
{
  /* gdbarch target dependent data here. Currently unused for M32R. */
};

/* m32r register names. */

enum
{
  R0_REGNUM = 0,
  R3_REGNUM = 3,
  M32R_FP_REGNUM = 13,
  LR_REGNUM = 14,
  M32R_SP_REGNUM = 15,
  PSW_REGNUM = 16,
  M32R_PC_REGNUM = 21,
  /* m32r calling convention. */
  ARG1_REGNUM = R0_REGNUM,
  ARGN_REGNUM = R3_REGNUM,
  RET1_REGNUM = R0_REGNUM,
};
a220 6
static int
m32r_num_regs (void)
{
  return (sizeof (m32r_register_names) / sizeof (m32r_register_names[0]));
}

d226 1
a226 1
  if (reg_nr >= m32r_num_regs ())
d898 1
a898 1
  set_gdbarch_num_regs (gdbarch, m32r_num_regs ());
d906 4
a909 2
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, m32r_extract_struct_value_address);
  set_gdbarch_deprecated_use_struct_convention (gdbarch, m32r_use_struct_convention);
@


1.29
log
@2004-07-31  Andrew Cagney  <cagney@@gnu.org>

	* trad-frame.c (trad_frame_get_prev_register): Rename
	trad_frame_get_prev_register.
	* vax-tdep.c (vax_frame_prev_register): Update.
	* trad-frame.h: Update.
	* trad-frame.c (trad_frame_get_register): Update.
	* sparcobsd-tdep.c (sparc32obsd_frame_prev_register): Update.
	* sparcnbsd-tdep.c (sparc32nbsd_sigcontext_frame_prev_register):
	Update.
	* sparc64obsd-tdep.c (sparc64obsd_frame_prev_register): Update.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_frame_prev_register):
	Update.
	* sparc64fbsd-tdep.c (sparc64fbsd_sigtramp_frame_prev_register):
	Update.
	* sparc64-sol2-tdep.c (sparc64_sol2_sigtramp_frame_prev_register):
	Update.
	* sparc-sol2-tdep.c (sparc32_sol2_sigtramp_frame_prev_register):
	Update.
	* sparc-linux-tdep.c (sparc32_linux_sigtramp_frame_prev_register):
	Update.
	* s390-tdep.c (s390_frame_prev_register)
	(s390_stub_frame_prev_register)
	(s390_sigtramp_frame_prev_register): Update.
	* rs6000-tdep.c (rs6000_frame_prev_register): Update.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_prev_register): Update.
	* mips-tdep.c (mips_mdebug_frame_prev_register): Update.
	* m88k-tdep.c (m88k_frame_prev_register)
	* m68hc11-tdep.c (m68hc11_frame_prev_register)
	* m32r-tdep.c (m32r_frame_prev_register): Update.
	* hppa-tdep.c (hppa_frame_prev_register_helper)
	* frv-tdep.c (frv_frame_prev_register): Update.
	* d10v-tdep.c (d10v_frame_prev_register): Update.
	* cris-tdep.c (cris_frame_prev_register): Update.
	* avr-tdep.c (avr_frame_prev_register): Update.
	* arm-tdep.c (arm_prologue_prev_register)
	(arm_sigtramp_prev_register): Update.
@
text
@a942 2
  set_gdbarch_deprecated_frameless_function_invocation (gdbarch, legacy_frameless_look_for_prologue);

@


1.28
log
@2004-06-20  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (DEPRECATED_USE_STRUCT_CONVENTION): Deprecated.
	* gdbarch.h, gdbarch.c: Re-generate.
	* values.c (using_struct_return): Update call.
	* mcore-tdep.c: Update comment.
	* infcall.c (call_function_by_hand): Update comment.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* arch-utils.h (always_use_struct_convention): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

Index: doc/ChangeLog
2004-06-20  Andrew Cagney  <cagney@@gnu.org>

	* gdbint.texinfo (Target Architecture Definition): Deprecate
	USE_STRUCT_CONVENTION.
@
text
@d859 2
a860 2
  trad_frame_prev_register (next_frame, info->saved_regs, regnum,
			    optimizedp, lvalp, addrp, realnump, bufferp);
@


1.27
log
@2004-06-06  Randolph Chung  <tausq@@debian.org>

	* gdbarch.sh (PUSH_DUMMY_CALL): Change CORE_ADDR func_addr argument
	to struct value *function.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Likewise.
	* infcall.c (call_function_by_hand): Pass entire function value
	to push_dummy_call.

	* Makefile.in (alpha-tdep.o, frv-tdep.o, ia64-tdep.o, mips-tdep.o)
	(ppc-sysv-tdep.o, rs6000-tdep.o): Update dependencies.
	* alpha-tdep.c (alpha_push_dummy_call): Update call signature.
	* amd64-tdep.c (amd64_push_dummy_call): Likewise.
	* arm-tdep.c (arm_push_dummy_call): Likewise.
	* avr-tdep.c (avr_push_dummy_call): Likewise.
	* cris-tdep.c (cris_push_dummy_call): Likewise.
	* d10v-tdep.c (d10v_push_dummy_call): Likewise.
	* frv-tdep.c (frv_push_dummy_call): Likewise.
	* h8300-tdep.c (h8300_push_dummy_call): Likewise.
	* hppa-tdep.c (hppa32_push_dummy_call)
	(hppa64_push_dummy_call): Likewise.
	* i386-tdep.c (i386_push_dummy_call): Likewise.
	* ia64-tdep.c (ia64_push_dummy_call): Likewise.
	* m32r-tdep.c (m32r_push_dummy_call): Likewise.
	* m68hc11-tdep.c (m68hc11_push_dummy_call): Likewise.
	* m68k-tdep.c (m68k_push_dummy_call): Likewise.
	* m88k-tdep.c (m88k_push_dummy_call): Likewise.
	* mips-tdep.c (mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call)
	(mips_o32_push_dummy_call, mips_o64_push_dummy_call): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppc-tdep.h (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.
	* s390-tdep.c (s390_push_dummy_call): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu)
	(sh_push_dummy_call_nofpu): Likewise.
	* sparc-tdep.c (sparc32_push_dummy_call): Likewise.
	* sparc64-tdep.c (sparc64_push_dummy_call): Likewise.
	* vax-tdep.c (vax_push_dummy_call): Likewise.
@
text
@d933 1
a933 1
  set_gdbarch_use_struct_convention (gdbarch, m32r_use_struct_convention);
@


1.26
log
@2004-04-22  Andrew Cagney  <cagney@@redhat.com>

	* arm-tdep.c (arm_prologue_this_id): Delete redundant cycle test.
	* m68hc11-tdep.c (m68hc11_frame_this_id): Ditto.
	* m32r-tdep.c (m32r_frame_this_id): Ditto.
	* frv-tdep.c (frv_frame_this_id): Ditto.
	* avr-tdep.c (avr_frame_this_id): Ditto.
@
text
@d689 1
a689 1
m32r_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
@


1.25
log
@2004-02-09  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAMELESS_FUNCTION_INVOCATION): Predicate
	and function replacing FRAMELESS_FUNCTION_INVOCATION.
	* blockframe.c (legacy_frameless_look_for_prologue): Rename
	frameless_look_for_prologue.
	* frame.h (legacy_frameless_look_for_prologue): Rename
	frameless_look_for_prologue.
	* gdbarch.h, gdbarch.c: Re-generate.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	(delta68_frame_args_address): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	(frv_frameless_function_invocation): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	(cris_frameless_function_invocation): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* stack.c (frame_info): Update, call predicate.
	* rs6000-tdep.c (rs6000_frame_chain): Update, call predicate..
	* frame.c (legacy_get_prev_frame): Update, call predicate..
	* arch-utils.c (generic_frameless_function_invocation_not): Delete.
	* arch-utils.h (generic_frameless_function_invocation_not): Delete.
	* alpha-tdep.c (alpha_gdbarch_init): Do not set frameless function
	invocation.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
@
text
@a846 10

  /* Check that we're not going round in circles with the same frame
     ID (but avoid applying the test to sentinel frames which do go
     round in circles).  Can't use frame_id_eq() as that doesn't yet
     compare the frame's PC value.  */
  if (frame_relative_level (next_frame) >= 0
      && get_frame_type (next_frame) != DUMMY_FRAME
      && frame_id_eq (get_frame_id (next_frame), id))
    return;

@


1.25.2.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d689 1
a689 1
m32r_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
d847 10
d869 2
a870 2
  trad_frame_get_prev_register (next_frame, info->saved_regs, regnum,
				optimizedp, lvalp, addrp, realnump, bufferp);
d943 1
a943 1
  set_gdbarch_deprecated_use_struct_convention (gdbarch, m32r_use_struct_convention);
d953 2
@


1.24
log
@2004-02-11  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FRAME_ARGS_SKIP): Default to 0.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
@
text
@d953 1
a953 2
  set_gdbarch_frameless_function_invocation (gdbarch,
					     frameless_look_for_prologue);
@


1.23
log
@2004-01-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (EXTRACT_STRUCT_VALUE_ADDRESS): Deprecate.  Add
	comments mentioning extract_returned_value_address.
	* infcmd.c (print_return_value): Update.  Add comments on
	extract_returned_value_address.
	* stack.c (return_command): Add comments on
	extract_returned_value_address.
	* values.c: Update comment.
	* m32r-tdep.c: Update comment.
	* sparc-tdep.c: Update comment.
	* ia64-tdep.c (ia64_use_struct_convention): Update comment.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* m68klinux-tdep.c (m68k_linux_init_abi): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

Index: doc/ChangeLog
2004-01-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	EXTRACT_STRUCT_VALUE_ADDRESS to
	DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS.
@
text
@a952 1
  set_gdbarch_frame_args_skip (gdbarch, 0);
@


1.22
log
@2004-01-17  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DECR_PC_AFTER_BREAK): Make zero the default.
	* gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	DECR_PC_AFTER_BREAK to zero.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc32_gdbarch_init): Ditto.
	* sh64-tdep.c (sh64_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* m32r-tdep.c (m32r_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-interix-tdep.c (i386_interix_init_abi): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* i386-nto-tdep.c (i386nto_init_abi): Add comment.
@
text
@d78 3
a80 3
/* Should we use EXTRACT_STRUCT_VALUE_ADDRESS instead of
   EXTRACT_RETURN_VALUE?  GCC_P is true if compiled with gcc
   and TYPE is the type (which is known to be struct, union or array).
d942 1
a942 2
  set_gdbarch_extract_struct_value_address (gdbarch,
					    m32r_extract_struct_value_address);
@


1.21
log
@2004-01-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FUNCTION_START_OFFSET): Make zero the default.
	* gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	FUNCTION_START_OFFSET.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc32_gdbarch_init): Ditto.
	* sh64-tdep.c (sh64_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* m32r-tdep.c (m32r_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
@
text
@a947 1
  set_gdbarch_decr_pc_after_break (gdbarch, 0);
@


1.20
log
@2003-10-31  Andrew Cagney  <cagney@@redhat.com>

	* avr-tdep.c (avr_frame_this_id): Do not call
	deprecated_inside_entry_file.
	* m68hc11-tdep.c (m68hc11_frame_this_id): Ditto.
	* m32r-tdep.c (m32r_frame_this_id): Ditto.
	* d10v-tdep.c (d10v_frame_this_id): Ditto.
	* arm-tdep.c (arm_prologue_this_id): Ditto.
	* alpha-tdep.c (alpha_heuristic_frame_this_id): Ditto.
@
text
@a948 1
  set_gdbarch_function_start_offset (gdbarch, 0);
@


1.19
log
@2003-10-08  Kei Sakamoto  <sakamoto.kei@@renesas.com>

	* m32r-tdep.c : Include "dis-asm.h".
	* Makefile.in (m32r-tdep.o): Update dependencies.
@
text
@a833 5
  /* This is meant to halt the backtrace at "_start".  Make sure we
     don't halt it at a generic dummy frame. */
  if (deprecated_inside_entry_file (func))
    return;

@


1.18
log
@2003-09-12  Andrew Cagney  <cagney@@redhat.com>

	* objfiles.h (struct entry_info): Deprecate "entry_file_lowpc" and
	"entry_file_highpc".  Update comments.
	* defs.h (deprecated_inside_entry_file): Rename
	"inside_entry_file".
	* blockframe.c (deprecated_inside_entry_file): Rename
	"inside_entry_file".
	* frame.c (get_prev_frame): Update.  Use if 0 instead of #if 0.
	* vax-tdep.c (vax_frame_chain): Update.
	* sh64-tdep.c (sh64_frame_chain): Update.
	* sh-tdep.c (sh_frame_chain): Update.
	* rs6000-tdep.c (rs6000_frame_chain): Update.
	* ns32k-tdep.c (ns32k_frame_chain): Update.
	* mips-tdep.c (mips_frame_chain): Update.
	* m68hc11-tdep.c (m68hc11_frame_this_id): Update.
	* m32r-tdep.c (m32r_frame_this_id): Update.
	* i386-interix-tdep.c (i386_interix_frame_chain_valid): Update.
	* frv-tdep.c (frv_frame_this_id): Update.
	* d10v-tdep.c (d10v_frame_this_id): Update.
	* cris-tdep.c (cris_frame_chain): Update.
	* blockframe.c (legacy_frame_chain_valid): Update.
	* avr-tdep.c (avr_frame_this_id): Update.
	* arm-tdep.c (arm_prologue_this_id): Update.
	* alpha-tdep.c (alpha_heuristic_frame_this_id): Update.
	* objfiles.c (objfile_relocate): Update.
	* mipsread.c (mipscoff_symfile_read): Update.
	(mipscoff_symfile_read): Update.
	* mdebugread.c (parse_partial_symbols): Update.
	* dwarfread.c (read_file_scope): Update.
	* dwarf2read.c (read_file_scope): Update.
	* dbxread.c (read_dbx_symtab): Update.
	(read_dbx_symtab): Update.
	* coffread.c (complete_symtab): Update.
@
text
@d40 1
@


1.17
log
@2003-08-01  Andrew Cagney  <cagney@@redhat.com>

	* NEWS: Mention that m32r is multi-arch.
	From 2003-07-28 Kei Sakamoto <sakamoto.kei@@renesas.com>:
	* configure.tgt: Recognize m32r-*-*.
	* config/m32r/tm-m32r.h: Delete file.
	* config/m32r/m32r.mt: New file.
	* m32r-rom.c (m32r_upload_command): Use hostent only when
        gethostname succeeds, in order to avoid a compilation
        warning.
	* m32r-tdep.c (m32r_store_return_value): Add a cast to remove a
	compiler warning.
@
text
@d835 1
a835 1
  if (inside_entry_file (func))
@


1.16
log
@2003-07-27  Andrew Cagney  <cagney@@redhat.com>

	Patch from 2003-07-22 Kei Sakamoto <sakamoto.kei@@renesas.com>:
	* m32r-tdep.c (m32r_memory_insert_breakpoint): Fix code style -
	operator at start and not end of line.
	(decode_prologue): Ditto.
	(m32r_frame_unwind_cache, m32r_unwind_sp, m32r_unwind_pc): Use
	frame_unwind_register_unsigned instead of
	frame_unwind_unsigned_register.
	(m32r_read_pc): Use regcache_cooked_read_unsigned instead of
	read_register.
	(m32r_push_dummy_call): Use register_size instead of
	REGISTER_RAW_SIZE.
	(m32r_frame_sniffer): Replace m32r_frame_p.
	(m32r_gdbarch_init): Call frame_unwind_append_sniffer.
	* m32r-rom.c (report_transfer_performance): Delete extern
	declaration.
	(m32r_load, m32r_upload_command): Use print_transfer_performance
	instead of report_transfer_performance.
	(_initialize_m32r_rom): Use add_setshow_cmd instead of add_set_cmd
	/ add_show_from_set.
@
text
@d289 1
a289 1
      regval = extract_unsigned_integer (valbuf + 4, len - 4);
@


1.15
log
@2003-07-21  Andrew Cagney  <cagney@@redhat.com>

	From 2003-07-04 Kei Sakamoto <sakamoto.kei@@renesas.com>:
	* m32r-tdep.c, m32r-stub.c, m32r-tdep.c: Rewrite.
@
text
@d114 2
a115 2
      if (((addr & 3) == 0) &&
	  ((contents_cache[0] & 0x80) || (contents_cache[2] & 0x80)))
d130 2
a131 2
      if (((addr & 3) == 0) &&
	  ((contents_cache[1] & 0x80) || (contents_cache[3] & 0x80)))
d159 2
a160 2
      if (((addr & 3) == 0) &&
	  ((contents_cache[0] & 0x80) || (contents_cache[2] & 0x80)))
d174 2
a175 2
      if (((addr & 3) == 0) &&
	  ((contents_cache[1] & 0x80) || (contents_cache[3] & 0x80)))
d365 3
a367 3
		  if (((insn >> 8) == 0xe4) &&	/* ld24 r4, xxxxxx; sub sp, r4 */
		      read_memory_unsigned_integer (current_pc + 2,
						    2) == 0x0f24)
d567 3
a569 3
	      else if (((op >> 8) == 0xe4) &&	/* ld24 r4, xxxxxx; sub sp, r4 */
		       get_frame_memory_unsigned (next_frame, pc + 4,
						  2) == 0x0f24)
d620 1
a620 1
      frame_unwind_unsigned_register (next_frame, M32R_FP_REGNUM, &this_base);
d629 1
a629 1
      frame_unwind_unsigned_register (next_frame, M32R_SP_REGNUM, &this_base);
d660 1
a660 1
  CORE_ADDR pc;
d664 1
a664 1
  pc = (int) read_register (M32R_PC_REGNUM);
d683 1
a683 3
  ULONGEST sp;
  frame_unwind_unsigned_register (next_frame, M32R_SP_REGNUM, &sp);
  return sp;
d745 1
a745 1
	  memcpy (valbuf + (REGISTER_RAW_SIZE (argreg) - len),
d764 2
a765 1
		extract_unsigned_integer (val, REGISTER_RAW_SIZE (argreg));
d772 2
a773 2
	  len -= REGISTER_RAW_SIZE (argreg);
	  val += REGISTER_RAW_SIZE (argreg);
d813 1
a813 3
  ULONGEST pc;
  frame_unwind_unsigned_register (next_frame, M32R_PC_REGNUM, &pc);
  return pc;
d884 1
a884 1
m32r_frame_p (CORE_ADDR pc)
d966 1
a966 1
  frame_unwind_append_predicate (gdbarch, m32r_frame_p);
@


1.14
log
@2003-02-04  Andrew Cagney  <ac131313@@redhat.com>

	* NEWS: Note that the m32r-*-elf* is obsolete.
	* monitor.c (monitor_expect): Obsolete reference to m32r.
	* configure.tgt: Mark m32r-*-elf* as obsolete.
	* MAINTAINERS: Mark m32k as obsolete.
	* m32r-rom.c: Obsolete file.
	* config/m32r/m32r.mt: Obsolete file.
	* config/m32r/tm-m32r.h: Obsolete file.
	* m32r-stub.c: Obsolete file.
	* m32r-tdep.c: Obsolete file.
@
text
@d1 989
a989 708
// OBSOLETE /* Target-dependent code for the Mitsubishi m32r for GDB, the GNU debugger.
// OBSOLETE 
// OBSOLETE    Copyright 1996, 1998, 1999, 2000, 2001, 2003 Free Software
// OBSOLETE    Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "frame.h"
// OBSOLETE #include "inferior.h"
// OBSOLETE #include "target.h"
// OBSOLETE #include "value.h"
// OBSOLETE #include "bfd.h"
// OBSOLETE #include "gdb_string.h"
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include "symfile.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE 
// OBSOLETE /* Function: m32r_use_struct_convention
// OBSOLETE    Return nonzero if call_function should allocate stack space for a
// OBSOLETE    struct return? */
// OBSOLETE int
// OBSOLETE m32r_use_struct_convention (int gcc_p, struct type *type)
// OBSOLETE {
// OBSOLETE   return (TYPE_LENGTH (type) > 8);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: frame_find_saved_regs
// OBSOLETE    Return the frame_saved_regs structure for the frame.
// OBSOLETE    Doesn't really work for dummy frames, but it does pass back
// OBSOLETE    an empty frame_saved_regs, so I guess that's better than total failure */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE m32r_frame_find_saved_regs (struct frame_info *fi,
// OBSOLETE 			    struct frame_saved_regs *regaddr)
// OBSOLETE {
// OBSOLETE   memcpy (regaddr, &fi->fsr, sizeof (struct frame_saved_regs));
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Turn this on if you want to see just how much instruction decoding
// OBSOLETE    if being done, its quite a lot
// OBSOLETE  */
// OBSOLETE #if 0
// OBSOLETE static void
// OBSOLETE dump_insn (char *commnt, CORE_ADDR pc, int insn)
// OBSOLETE {
// OBSOLETE   printf_filtered ("  %s %08x %08x ",
// OBSOLETE 		   commnt, (unsigned int) pc, (unsigned int) insn);
// OBSOLETE   TARGET_PRINT_INSN (pc, &tm_print_insn_info);
// OBSOLETE   printf_filtered ("\n");
// OBSOLETE }
// OBSOLETE #define insn_debug(args) { printf_filtered args; }
// OBSOLETE #else
// OBSOLETE #define dump_insn(a,b,c) {}
// OBSOLETE #define insn_debug(args) {}
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE #define DEFAULT_SEARCH_LIMIT 44
// OBSOLETE 
// OBSOLETE /* Function: scan_prologue
// OBSOLETE    This function decodes the target function prologue to determine
// OBSOLETE    1) the size of the stack frame, and 2) which registers are saved on it.
// OBSOLETE    It saves the offsets of saved regs in the frame_saved_regs argument,
// OBSOLETE    and returns the frame size.  */
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE    The sequence it currently generates is:
// OBSOLETE 
// OBSOLETE    if (varargs function) { ddi sp,#n }
// OBSOLETE    push registers
// OBSOLETE    if (additional stack <= 256) {       addi sp,#-stack }
// OBSOLETE    else if (additional stack < 65k) { add3 sp,sp,#-stack
// OBSOLETE 
// OBSOLETE    } else if (additional stack) {
// OBSOLETE    seth sp,#(stack & 0xffff0000)
// OBSOLETE    or3 sp,sp,#(stack & 0x0000ffff)
// OBSOLETE    sub sp,r4
// OBSOLETE    }
// OBSOLETE    if (frame pointer) {
// OBSOLETE    mv sp,fp
// OBSOLETE    }
// OBSOLETE 
// OBSOLETE    These instructions are scheduled like everything else, so you should stop at
// OBSOLETE    the first branch instruction.
// OBSOLETE 
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE /* This is required by skip prologue and by m32r_init_extra_frame_info. 
// OBSOLETE    The results of decoding a prologue should be cached because this
// OBSOLETE    thrashing is getting nuts.
// OBSOLETE    I am thinking of making a container class with two indexes, name and
// OBSOLETE    address. It may be better to extend the symbol table.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE decode_prologue (CORE_ADDR start_pc, CORE_ADDR scan_limit, CORE_ADDR *pl_endptr,	/* var parameter */
// OBSOLETE 		 unsigned long *framelength, struct frame_info *fi,
// OBSOLETE 		 struct frame_saved_regs *fsr)
// OBSOLETE {
// OBSOLETE   unsigned long framesize;
// OBSOLETE   int insn;
// OBSOLETE   int op1;
// OBSOLETE   int maybe_one_more = 0;
// OBSOLETE   CORE_ADDR after_prologue = 0;
// OBSOLETE   CORE_ADDR after_stack_adjust = 0;
// OBSOLETE   CORE_ADDR current_pc;
// OBSOLETE 
// OBSOLETE 
// OBSOLETE   framesize = 0;
// OBSOLETE   after_prologue = 0;
// OBSOLETE   insn_debug (("rd prolog l(%d)\n", scan_limit - current_pc));
// OBSOLETE 
// OBSOLETE   for (current_pc = start_pc; current_pc < scan_limit; current_pc += 2)
// OBSOLETE     {
// OBSOLETE 
// OBSOLETE       insn = read_memory_unsigned_integer (current_pc, 2);
// OBSOLETE       dump_insn ("insn-1", current_pc, insn);	/* MTZ */
// OBSOLETE 
// OBSOLETE       /* If this is a 32 bit instruction, we dont want to examine its
// OBSOLETE          immediate data as though it were an instruction */
// OBSOLETE       if (current_pc & 0x02)
// OBSOLETE 	{			/* Clear the parallel execution bit from 16 bit instruction */
// OBSOLETE 	  if (maybe_one_more)
// OBSOLETE 	    {			/* The last instruction was a branch, usually terminates
// OBSOLETE 				   the series, but if this is a parallel instruction,
// OBSOLETE 				   it may be a stack framing instruction */
// OBSOLETE 	      if (!(insn & 0x8000))
// OBSOLETE 		{
// OBSOLETE 		  insn_debug (("Really done"));
// OBSOLETE 		  break;	/* nope, we are really done */
// OBSOLETE 		}
// OBSOLETE 	    }
// OBSOLETE 	  insn &= 0x7fff;	/* decode this instruction further */
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  if (maybe_one_more)
// OBSOLETE 	    break;		/* This isnt the one more */
// OBSOLETE 	  if (insn & 0x8000)
// OBSOLETE 	    {
// OBSOLETE 	      insn_debug (("32 bit insn\n"));
// OBSOLETE 	      if (current_pc == scan_limit)
// OBSOLETE 		scan_limit += 2;	/* extend the search */
// OBSOLETE 	      current_pc += 2;	/* skip the immediate data */
// OBSOLETE 	      if (insn == 0x8faf)	/* add3 sp, sp, xxxx */
// OBSOLETE 		/* add 16 bit sign-extended offset */
// OBSOLETE 		{
// OBSOLETE 		  insn_debug (("stack increment\n"));
// OBSOLETE 		  framesize += -((short) read_memory_unsigned_integer (current_pc, 2));
// OBSOLETE 		}
// OBSOLETE 	      else
// OBSOLETE 		{
// OBSOLETE 		  if (((insn >> 8) == 0xe4) &&	/* ld24 r4, xxxxxx; sub sp, r4 */
// OBSOLETE 		  read_memory_unsigned_integer (current_pc + 2, 2) == 0x0f24)
// OBSOLETE 		    {		/* subtract 24 bit sign-extended negative-offset */
// OBSOLETE 		      dump_insn ("insn-2", current_pc + 2, insn);
// OBSOLETE 		      insn = read_memory_unsigned_integer (current_pc - 2, 4);
// OBSOLETE 		      dump_insn ("insn-3(l4)", current_pc - 2, insn);
// OBSOLETE 		      if (insn & 0x00800000)	/* sign extend */
// OBSOLETE 			insn |= 0xff000000;	/* negative */
// OBSOLETE 		      else
// OBSOLETE 			insn &= 0x00ffffff;	/* positive */
// OBSOLETE 		      framesize += insn;
// OBSOLETE 		    }
// OBSOLETE 		}
// OBSOLETE 	      after_prologue = current_pc;
// OBSOLETE 	      continue;
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       op1 = insn & 0xf000;	/* isolate just the first nibble */
// OBSOLETE 
// OBSOLETE       if ((insn & 0xf0ff) == 0x207f)
// OBSOLETE 	{			/* st reg, @@-sp */
// OBSOLETE 	  int regno;
// OBSOLETE 	  insn_debug (("push\n"));
// OBSOLETE #if 0				/* No, PUSH FP is not an indication that we will use a frame pointer. */
// OBSOLETE 	  if (((insn & 0xffff) == 0x2d7f) && fi)
// OBSOLETE 	    fi->using_frame_pointer = 1;
// OBSOLETE #endif
// OBSOLETE 	  framesize += 4;
// OBSOLETE #if 0
// OBSOLETE /* Why should we increase the scan limit, just because we did a push? 
// OBSOLETE    And if there is a reason, surely we would only want to do it if we
// OBSOLETE    had already reached the scan limit... */
// OBSOLETE 	  if (current_pc == scan_limit)
// OBSOLETE 	    scan_limit += 2;
// OBSOLETE #endif
// OBSOLETE 	  regno = ((insn >> 8) & 0xf);
// OBSOLETE 	  if (fsr)		/* save_regs offset */
// OBSOLETE 	    fsr->regs[regno] = framesize;
// OBSOLETE 	  after_prologue = 0;
// OBSOLETE 	  continue;
// OBSOLETE 	}
// OBSOLETE       if ((insn >> 8) == 0x4f)	/* addi sp, xx */
// OBSOLETE 	/* add 8 bit sign-extended offset */
// OBSOLETE 	{
// OBSOLETE 	  int stack_adjust = (char) (insn & 0xff);
// OBSOLETE 
// OBSOLETE 	  /* there are probably two of these stack adjustments:
// OBSOLETE 	     1) A negative one in the prologue, and
// OBSOLETE 	     2) A positive one in the epilogue.
// OBSOLETE 	     We are only interested in the first one.  */
// OBSOLETE 
// OBSOLETE 	  if (stack_adjust < 0)
// OBSOLETE 	    {
// OBSOLETE 	      framesize -= stack_adjust;
// OBSOLETE 	      after_prologue = 0;
// OBSOLETE 	      /* A frameless function may have no "mv fp, sp".
// OBSOLETE 	         In that case, this is the end of the prologue.  */
// OBSOLETE 	      after_stack_adjust = current_pc + 2;
// OBSOLETE 	    }
// OBSOLETE 	  continue;
// OBSOLETE 	}
// OBSOLETE       if (insn == 0x1d8f)
// OBSOLETE 	{			/* mv fp, sp */
// OBSOLETE 	  if (fi)
// OBSOLETE 	    fi->using_frame_pointer = 1;	/* fp is now valid */
// OBSOLETE 	  insn_debug (("done fp found\n"));
// OBSOLETE 	  after_prologue = current_pc + 2;
// OBSOLETE 	  break;		/* end of stack adjustments */
// OBSOLETE 	}
// OBSOLETE       if (insn == 0x7000)	/* Nop looks like a branch, continue explicitly */
// OBSOLETE 	{
// OBSOLETE 	  insn_debug (("nop\n"));
// OBSOLETE 	  after_prologue = current_pc + 2;
// OBSOLETE 	  continue;		/* nop occurs between pushes */
// OBSOLETE 	}
// OBSOLETE       /* End of prolog if any of these are branch instructions */
// OBSOLETE       if ((op1 == 0x7000)
// OBSOLETE 	  || (op1 == 0xb000)
// OBSOLETE 	  || (op1 == 0xf000))
// OBSOLETE 	{
// OBSOLETE 	  after_prologue = current_pc;
// OBSOLETE 	  insn_debug (("Done: branch\n"));
// OBSOLETE 	  maybe_one_more = 1;
// OBSOLETE 	  continue;
// OBSOLETE 	}
// OBSOLETE       /* Some of the branch instructions are mixed with other types */
// OBSOLETE       if (op1 == 0x1000)
// OBSOLETE 	{
// OBSOLETE 	  int subop = insn & 0x0ff0;
// OBSOLETE 	  if ((subop == 0x0ec0) || (subop == 0x0fc0))
// OBSOLETE 	    {
// OBSOLETE 	      insn_debug (("done: jmp\n"));
// OBSOLETE 	      after_prologue = current_pc;
// OBSOLETE 	      maybe_one_more = 1;
// OBSOLETE 	      continue;		/* jmp , jl */
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (current_pc >= scan_limit)
// OBSOLETE     {
// OBSOLETE       if (pl_endptr)
// OBSOLETE 	{
// OBSOLETE #if 1
// OBSOLETE 	  if (after_stack_adjust != 0)
// OBSOLETE 	    /* We did not find a "mv fp,sp", but we DID find
// OBSOLETE 	       a stack_adjust.  Is it safe to use that as the
// OBSOLETE 	       end of the prologue?  I just don't know. */
// OBSOLETE 	    {
// OBSOLETE 	      *pl_endptr = after_stack_adjust;
// OBSOLETE 	      if (framelength)
// OBSOLETE 		*framelength = framesize;
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE #endif
// OBSOLETE 	    /* We reached the end of the loop without finding the end
// OBSOLETE 	       of the prologue.  No way to win -- we should report failure.  
// OBSOLETE 	       The way we do that is to return the original start_pc.
// OBSOLETE 	       GDB will set a breakpoint at the start of the function (etc.) */
// OBSOLETE 	    *pl_endptr = start_pc;
// OBSOLETE 	}
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE   if (after_prologue == 0)
// OBSOLETE     after_prologue = current_pc;
// OBSOLETE 
// OBSOLETE   insn_debug ((" framesize %d, firstline %08x\n", framesize, after_prologue));
// OBSOLETE   if (framelength)
// OBSOLETE     *framelength = framesize;
// OBSOLETE   if (pl_endptr)
// OBSOLETE     *pl_endptr = after_prologue;
// OBSOLETE }				/*  decode_prologue */
// OBSOLETE 
// OBSOLETE /* Function: skip_prologue
// OBSOLETE    Find end of function prologue */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE m32r_skip_prologue (CORE_ADDR pc)
// OBSOLETE {
// OBSOLETE   CORE_ADDR func_addr, func_end;
// OBSOLETE   struct symtab_and_line sal;
// OBSOLETE 
// OBSOLETE   /* See what the symbol table says */
// OBSOLETE 
// OBSOLETE   if (find_pc_partial_function (pc, NULL, &func_addr, &func_end))
// OBSOLETE     {
// OBSOLETE       sal = find_pc_line (func_addr, 0);
// OBSOLETE 
// OBSOLETE       if (sal.line != 0 && sal.end <= func_end)
// OBSOLETE 	{
// OBSOLETE 
// OBSOLETE 	  insn_debug (("BP after prologue %08x\n", sal.end));
// OBSOLETE 	  func_end = sal.end;
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	/* Either there's no line info, or the line after the prologue is after
// OBSOLETE 	   the end of the function.  In this case, there probably isn't a
// OBSOLETE 	   prologue.  */
// OBSOLETE 	{
// OBSOLETE 	  insn_debug (("No line info, line(%x) sal_end(%x) funcend(%x)\n",
// OBSOLETE 		       sal.line, sal.end, func_end));
// OBSOLETE 	  func_end = min (func_end, func_addr + DEFAULT_SEARCH_LIMIT);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     func_end = pc + DEFAULT_SEARCH_LIMIT;
// OBSOLETE   decode_prologue (pc, func_end, &sal.end, 0, 0, 0);
// OBSOLETE   return sal.end;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static unsigned long
// OBSOLETE m32r_scan_prologue (struct frame_info *fi, struct frame_saved_regs *fsr)
// OBSOLETE {
// OBSOLETE   struct symtab_and_line sal;
// OBSOLETE   CORE_ADDR prologue_start, prologue_end, current_pc;
// OBSOLETE   unsigned long framesize = 0;
// OBSOLETE 
// OBSOLETE   /* this code essentially duplicates skip_prologue, 
// OBSOLETE      but we need the start address below.  */
// OBSOLETE 
// OBSOLETE   if (find_pc_partial_function (fi->pc, NULL, &prologue_start, &prologue_end))
// OBSOLETE     {
// OBSOLETE       sal = find_pc_line (prologue_start, 0);
// OBSOLETE 
// OBSOLETE       if (sal.line == 0)	/* no line info, use current PC */
// OBSOLETE 	if (prologue_start == entry_point_address ())
// OBSOLETE 	  return 0;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       prologue_start = fi->pc;
// OBSOLETE       prologue_end = prologue_start + 48;	/* We're in the boondocks: 
// OBSOLETE 						   allow for 16 pushes, an add, 
// OBSOLETE 						   and "mv fp,sp" */
// OBSOLETE     }
// OBSOLETE #if 0
// OBSOLETE   prologue_end = min (prologue_end, fi->pc);
// OBSOLETE #endif
// OBSOLETE   insn_debug (("fipc(%08x) start(%08x) end(%08x)\n",
// OBSOLETE 	       fi->pc, prologue_start, prologue_end));
// OBSOLETE   prologue_end = min (prologue_end, prologue_start + DEFAULT_SEARCH_LIMIT);
// OBSOLETE   decode_prologue (prologue_start, prologue_end, &prologue_end, &framesize,
// OBSOLETE 		   fi, fsr);
// OBSOLETE   return framesize;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: init_extra_frame_info
// OBSOLETE    This function actually figures out the frame address for a given pc and
// OBSOLETE    sp.  This is tricky on the m32r because we sometimes don't use an explicit
// OBSOLETE    frame pointer, and the previous stack pointer isn't necessarily recorded
// OBSOLETE    on the stack.  The only reliable way to get this info is to
// OBSOLETE    examine the prologue.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE m32r_init_extra_frame_info (struct frame_info *fi)
// OBSOLETE {
// OBSOLETE   int reg;
// OBSOLETE 
// OBSOLETE   if (fi->next)
// OBSOLETE     fi->pc = FRAME_SAVED_PC (fi->next);
// OBSOLETE 
// OBSOLETE   memset (fi->fsr.regs, '\000', sizeof fi->fsr.regs);
// OBSOLETE 
// OBSOLETE   if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
// OBSOLETE     {
// OBSOLETE       /* We need to setup fi->frame here because run_stack_dummy gets it wrong
// OBSOLETE          by assuming it's always FP.  */
// OBSOLETE       fi->frame = deprecated_read_register_dummy (fi->pc, fi->frame,
// OBSOLETE 						  SP_REGNUM);
// OBSOLETE       fi->framesize = 0;
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       fi->using_frame_pointer = 0;
// OBSOLETE       fi->framesize = m32r_scan_prologue (fi, &fi->fsr);
// OBSOLETE 
// OBSOLETE       if (!fi->next)
// OBSOLETE 	if (fi->using_frame_pointer)
// OBSOLETE 	  {
// OBSOLETE 	    fi->frame = read_register (FP_REGNUM);
// OBSOLETE 	  }
// OBSOLETE 	else
// OBSOLETE 	  fi->frame = read_register (SP_REGNUM);
// OBSOLETE       else
// OBSOLETE 	/* fi->next means this is not the innermost frame */ if (fi->using_frame_pointer)
// OBSOLETE 	/* we have an FP */
// OBSOLETE 	if (fi->next->fsr.regs[FP_REGNUM] != 0)		/* caller saved our FP */
// OBSOLETE 	  fi->frame = read_memory_integer (fi->next->fsr.regs[FP_REGNUM], 4);
// OBSOLETE       for (reg = 0; reg < NUM_REGS; reg++)
// OBSOLETE 	if (fi->fsr.regs[reg] != 0)
// OBSOLETE 	  fi->fsr.regs[reg] = fi->frame + fi->framesize - fi->fsr.regs[reg];
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: m32r_virtual_frame_pointer
// OBSOLETE    Return the register that the function uses for a frame pointer, 
// OBSOLETE    plus any necessary offset to be applied to the register before
// OBSOLETE    any frame pointer offsets.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE m32r_virtual_frame_pointer (CORE_ADDR pc, long *reg, long *offset)
// OBSOLETE {
// OBSOLETE   struct frame_info *fi = deprecated_frame_xmalloc ();
// OBSOLETE   struct cleanup *old_chain = make_cleanup (xfree, fi);
// OBSOLETE 
// OBSOLETE   /* Set up a dummy frame_info. */
// OBSOLETE   fi->next = NULL;
// OBSOLETE   fi->prev = NULL;
// OBSOLETE   fi->frame = 0;
// OBSOLETE   fi->pc = pc;
// OBSOLETE 
// OBSOLETE   /* Analyze the prolog and fill in the extra info.  */
// OBSOLETE   m32r_init_extra_frame_info (fi);
// OBSOLETE 
// OBSOLETE   /* Results will tell us which type of frame it uses.  */
// OBSOLETE   if (fi->using_frame_pointer)
// OBSOLETE     {
// OBSOLETE       *reg = FP_REGNUM;
// OBSOLETE       *offset = 0;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       *reg = SP_REGNUM;
// OBSOLETE       *offset = 0;
// OBSOLETE     }
// OBSOLETE   do_cleanups (old_chain);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: find_callers_reg
// OBSOLETE    Find REGNUM on the stack.  Otherwise, it's in an active register.  One thing
// OBSOLETE    we might want to do here is to check REGNUM against the clobber mask, and
// OBSOLETE    somehow flag it as invalid if it isn't saved on the stack somewhere.  This
// OBSOLETE    would provide a graceful failure mode when trying to get the value of
// OBSOLETE    caller-saves registers for an inner frame.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE m32r_find_callers_reg (struct frame_info *fi, int regnum)
// OBSOLETE {
// OBSOLETE   for (; fi; fi = fi->next)
// OBSOLETE     if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
// OBSOLETE       return deprecated_read_register_dummy (fi->pc, fi->frame, regnum);
// OBSOLETE     else if (fi->fsr.regs[regnum] != 0)
// OBSOLETE       return read_memory_integer (fi->fsr.regs[regnum],
// OBSOLETE 				  REGISTER_RAW_SIZE (regnum));
// OBSOLETE   return read_register (regnum);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: frame_chain Given a GDB frame, determine the address of
// OBSOLETE    the calling function's frame.  This will be used to create a new
// OBSOLETE    GDB frame struct, and then INIT_EXTRA_FRAME_INFO and
// OBSOLETE    DEPRECATED_INIT_FRAME_PC will be called for the new frame.  For
// OBSOLETE    m32r, we save the frame size when we initialize the frame_info.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE m32r_frame_chain (struct frame_info *fi)
// OBSOLETE {
// OBSOLETE   CORE_ADDR fn_start, callers_pc, fp;
// OBSOLETE 
// OBSOLETE   /* is this a dummy frame? */
// OBSOLETE   if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
// OBSOLETE     return fi->frame;		/* dummy frame same as caller's frame */
// OBSOLETE 
// OBSOLETE   /* is caller-of-this a dummy frame? */
// OBSOLETE   callers_pc = FRAME_SAVED_PC (fi);	/* find out who called us: */
// OBSOLETE   fp = m32r_find_callers_reg (fi, FP_REGNUM);
// OBSOLETE   if (DEPRECATED_PC_IN_CALL_DUMMY (callers_pc, fp, fp))
// OBSOLETE     return fp;			/* dummy frame's frame may bear no relation to ours */
// OBSOLETE 
// OBSOLETE   if (find_pc_partial_function (fi->pc, 0, &fn_start, 0))
// OBSOLETE     if (fn_start == entry_point_address ())
// OBSOLETE       return 0;			/* in _start fn, don't chain further */
// OBSOLETE   if (fi->framesize == 0)
// OBSOLETE     {
// OBSOLETE       printf_filtered ("cannot determine frame size @@ %s , pc(%s)\n",
// OBSOLETE 		       paddr (fi->frame),
// OBSOLETE 		       paddr (fi->pc));
// OBSOLETE       return 0;
// OBSOLETE     }
// OBSOLETE   insn_debug (("m32rx frame %08x\n", fi->frame + fi->framesize));
// OBSOLETE   return fi->frame + fi->framesize;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: push_return_address (pc)
// OBSOLETE    Set up the return address for the inferior function call.
// OBSOLETE    Necessary for targets that don't actually execute a JSR/BSR instruction 
// OBSOLETE    (ie. when using an empty CALL_DUMMY) */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE m32r_push_return_address (CORE_ADDR pc, CORE_ADDR sp)
// OBSOLETE {
// OBSOLETE   write_register (RP_REGNUM, CALL_DUMMY_ADDRESS ());
// OBSOLETE   return sp;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* Function: pop_frame
// OBSOLETE    Discard from the stack the innermost frame,
// OBSOLETE    restoring all saved registers.  */
// OBSOLETE 
// OBSOLETE struct frame_info *
// OBSOLETE m32r_pop_frame (struct frame_info *frame)
// OBSOLETE {
// OBSOLETE   int regnum;
// OBSOLETE 
// OBSOLETE   if (DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
// OBSOLETE     generic_pop_dummy_frame ();
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       for (regnum = 0; regnum < NUM_REGS; regnum++)
// OBSOLETE 	if (frame->fsr.regs[regnum] != 0)
// OBSOLETE 	  write_register (regnum,
// OBSOLETE 			  read_memory_integer (frame->fsr.regs[regnum], 4));
// OBSOLETE 
// OBSOLETE       write_register (PC_REGNUM, FRAME_SAVED_PC (frame));
// OBSOLETE       write_register (SP_REGNUM, read_register (FP_REGNUM));
// OBSOLETE       if (read_register (PSW_REGNUM) & 0x80)
// OBSOLETE 	write_register (SPU_REGNUM, read_register (SP_REGNUM));
// OBSOLETE       else
// OBSOLETE 	write_register (SPI_REGNUM, read_register (SP_REGNUM));
// OBSOLETE     }
// OBSOLETE   flush_cached_frames ();
// OBSOLETE   return NULL;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: frame_saved_pc
// OBSOLETE    Find the caller of this frame.  We do this by seeing if RP_REGNUM is saved
// OBSOLETE    in the stack anywhere, otherwise we get it from the registers. */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE m32r_frame_saved_pc (struct frame_info *fi)
// OBSOLETE {
// OBSOLETE   if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
// OBSOLETE     return deprecated_read_register_dummy (fi->pc, fi->frame, PC_REGNUM);
// OBSOLETE   else
// OBSOLETE     return m32r_find_callers_reg (fi, RP_REGNUM);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: push_arguments
// OBSOLETE    Setup the function arguments for calling a function in the inferior.
// OBSOLETE 
// OBSOLETE    On the Mitsubishi M32R architecture, there are four registers (R0 to R3)
// OBSOLETE    which are dedicated for passing function arguments.  Up to the first 
// OBSOLETE    four arguments (depending on size) may go into these registers.
// OBSOLETE    The rest go on the stack.
// OBSOLETE 
// OBSOLETE    Arguments that are smaller than 4 bytes will still take up a whole
// OBSOLETE    register or a whole 32-bit word on the stack, and will be
// OBSOLETE    right-justified in the register or the stack word.  This includes
// OBSOLETE    chars, shorts, and small aggregate types.
// OBSOLETE 
// OBSOLETE    Arguments of 8 bytes size are split between two registers, if 
// OBSOLETE    available.  If only one register is available, the argument will 
// OBSOLETE    be split between the register and the stack.  Otherwise it is
// OBSOLETE    passed entirely on the stack.  Aggregate types with sizes between
// OBSOLETE    4 and 8 bytes are passed entirely on the stack, and are left-justified
// OBSOLETE    within the double-word (as opposed to aggregates smaller than 4 bytes
// OBSOLETE    which are right-justified).
// OBSOLETE 
// OBSOLETE    Aggregates of greater than 8 bytes are first copied onto the stack, 
// OBSOLETE    and then a pointer to the copy is passed in the place of the normal
// OBSOLETE    argument (either in a register if available, or on the stack).
// OBSOLETE 
// OBSOLETE    Functions that must return an aggregate type can return it in the 
// OBSOLETE    normal return value registers (R0 and R1) if its size is 8 bytes or
// OBSOLETE    less.  For larger return values, the caller must allocate space for 
// OBSOLETE    the callee to copy the return value to.  A pointer to this space is
// OBSOLETE    passed as an implicit first argument, always in R0. */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE m32r_push_arguments (int nargs, struct value **args, CORE_ADDR sp,
// OBSOLETE 		     unsigned char struct_return, CORE_ADDR struct_addr)
// OBSOLETE {
// OBSOLETE   int stack_offset, stack_alloc;
// OBSOLETE   int argreg;
// OBSOLETE   int argnum;
// OBSOLETE   struct type *type;
// OBSOLETE   CORE_ADDR regval;
// OBSOLETE   char *val;
// OBSOLETE   char valbuf[4];
// OBSOLETE   int len;
// OBSOLETE   int odd_sized_struct;
// OBSOLETE 
// OBSOLETE   /* first force sp to a 4-byte alignment */
// OBSOLETE   sp = sp & ~3;
// OBSOLETE 
// OBSOLETE   argreg = ARG0_REGNUM;
// OBSOLETE   /* The "struct return pointer" pseudo-argument goes in R0 */
// OBSOLETE   if (struct_return)
// OBSOLETE     write_register (argreg++, struct_addr);
// OBSOLETE 
// OBSOLETE   /* Now make sure there's space on the stack */
// OBSOLETE   for (argnum = 0, stack_alloc = 0;
// OBSOLETE        argnum < nargs; argnum++)
// OBSOLETE     stack_alloc += ((TYPE_LENGTH (VALUE_TYPE (args[argnum])) + 3) & ~3);
// OBSOLETE   sp -= stack_alloc;		/* make room on stack for args */
// OBSOLETE 
// OBSOLETE 
// OBSOLETE   /* Now load as many as possible of the first arguments into
// OBSOLETE      registers, and push the rest onto the stack.  There are 16 bytes
// OBSOLETE      in four registers available.  Loop thru args from first to last.  */
// OBSOLETE 
// OBSOLETE   argreg = ARG0_REGNUM;
// OBSOLETE   for (argnum = 0, stack_offset = 0; argnum < nargs; argnum++)
// OBSOLETE     {
// OBSOLETE       type = VALUE_TYPE (args[argnum]);
// OBSOLETE       len = TYPE_LENGTH (type);
// OBSOLETE       memset (valbuf, 0, sizeof (valbuf));
// OBSOLETE       if (len < 4)
// OBSOLETE 	{			/* value gets right-justified in the register or stack word */
// OBSOLETE 	  memcpy (valbuf + (4 - len),
// OBSOLETE 		  (char *) VALUE_CONTENTS (args[argnum]), len);
// OBSOLETE 	  val = valbuf;
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	val = (char *) VALUE_CONTENTS (args[argnum]);
// OBSOLETE 
// OBSOLETE       if (len > 4 && (len & 3) != 0)
// OBSOLETE 	odd_sized_struct = 1;	/* such structs go entirely on stack */
// OBSOLETE       else
// OBSOLETE 	odd_sized_struct = 0;
// OBSOLETE       while (len > 0)
// OBSOLETE 	{
// OBSOLETE 	  if (argreg > ARGLAST_REGNUM || odd_sized_struct)
// OBSOLETE 	    {			/* must go on the stack */
// OBSOLETE 	      write_memory (sp + stack_offset, val, 4);
// OBSOLETE 	      stack_offset += 4;
// OBSOLETE 	    }
// OBSOLETE 	  /* NOTE WELL!!!!!  This is not an "else if" clause!!!
// OBSOLETE 	     That's because some *&^%$ things get passed on the stack
// OBSOLETE 	     AND in the registers!   */
// OBSOLETE 	  if (argreg <= ARGLAST_REGNUM)
// OBSOLETE 	    {			/* there's room in a register */
// OBSOLETE 	      regval = extract_address (val, REGISTER_RAW_SIZE (argreg));
// OBSOLETE 	      write_register (argreg++, regval);
// OBSOLETE 	    }
// OBSOLETE 	  /* Store the value 4 bytes at a time.  This means that things
// OBSOLETE 	     larger than 4 bytes may go partly in registers and partly
// OBSOLETE 	     on the stack.  */
// OBSOLETE 	  len -= REGISTER_RAW_SIZE (argreg);
// OBSOLETE 	  val += REGISTER_RAW_SIZE (argreg);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   return sp;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: fix_call_dummy 
// OBSOLETE    If there is real CALL_DUMMY code (eg. on the stack), this function
// OBSOLETE    has the responsability to insert the address of the actual code that
// OBSOLETE    is the target of the target function call.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE m32r_fix_call_dummy (char *dummy, CORE_ADDR pc, CORE_ADDR fun, int nargs,
// OBSOLETE 		     struct value **args, struct type *type, int gcc_p)
// OBSOLETE {
// OBSOLETE   /* ld24 r8, <(imm24) fun> */
// OBSOLETE   *(unsigned long *) (dummy) = (fun & 0x00ffffff) | 0xe8000000;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* Function: m32r_write_sp
// OBSOLETE    Because SP is really a read-only register that mirrors either SPU or SPI,
// OBSOLETE    we must actually write one of those two as well, depending on PSW. */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE m32r_write_sp (CORE_ADDR val)
// OBSOLETE {
// OBSOLETE   unsigned long psw = read_register (PSW_REGNUM);
// OBSOLETE 
// OBSOLETE   if (psw & 0x80)		/* stack mode: user or interrupt */
// OBSOLETE     write_register (SPU_REGNUM, val);
// OBSOLETE   else
// OBSOLETE     write_register (SPI_REGNUM, val);
// OBSOLETE   write_register (SP_REGNUM, val);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_m32r_tdep (void)
// OBSOLETE {
// OBSOLETE   tm_print_insn = print_insn_m32r;
// OBSOLETE }
@


1.14.30.1
log
@2003-08-01  Andrew Cagney  <cagney@@redhat.com>

	Import mainline multi-arch changes from Kei Sakamoto.
	* gdb/NEWS: Mention that m32r is multi-arch.
	* configure.tgt: Recognize m32r-*-*.
	* config/m32r/m32r.mt: New file.
	* m32r-rom.c, m32r-stub.c, m32r-tdep.c: Import
@
text
@d1 708
a708 986
/* Target-dependent code for Renesas M32R, for GDB.

   Copyright 1996, 1998, 1999, 2000, 2001, 2002, 2003 Free Software
   Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "frame.h"
#include "frame-unwind.h"
#include "frame-base.h"
#include "symtab.h"
#include "gdbtypes.h"
#include "gdbcmd.h"
#include "gdbcore.h"
#include "gdb_string.h"
#include "value.h"
#include "inferior.h"
#include "symfile.h"
#include "objfiles.h"
#include "language.h"
#include "arch-utils.h"
#include "regcache.h"
#include "trad-frame.h"

#include "gdb_assert.h"

struct gdbarch_tdep
{
  /* gdbarch target dependent data here. Currently unused for M32R. */
};

/* m32r register names. */

enum
{
  R0_REGNUM = 0,
  R3_REGNUM = 3,
  M32R_FP_REGNUM = 13,
  LR_REGNUM = 14,
  M32R_SP_REGNUM = 15,
  PSW_REGNUM = 16,
  M32R_PC_REGNUM = 21,
  /* m32r calling convention. */
  ARG1_REGNUM = R0_REGNUM,
  ARGN_REGNUM = R3_REGNUM,
  RET1_REGNUM = R0_REGNUM,
};

/* Local functions */

extern void _initialize_m32r_tdep (void);

static CORE_ADDR
m32r_frame_align (struct gdbarch *gdbarch, CORE_ADDR sp)
{
  /* Align to the size of an instruction (so that they can safely be
     pushed onto the stack.  */
  return sp & ~3;
}

/* Should we use EXTRACT_STRUCT_VALUE_ADDRESS instead of
   EXTRACT_RETURN_VALUE?  GCC_P is true if compiled with gcc
   and TYPE is the type (which is known to be struct, union or array).

   The m32r returns anything less than 8 bytes in size in
   registers. */

static int
m32r_use_struct_convention (int gcc_p, struct type *type)
{
  return (TYPE_LENGTH (type) > 8);
}


/* BREAKPOINT */
#define M32R_BE_BREAKPOINT32 {0x10, 0xf1, 0x70, 0x00}
#define M32R_LE_BREAKPOINT32 {0xf1, 0x10, 0x00, 0x70}
#define M32R_BE_BREAKPOINT16 {0x10, 0xf1}
#define M32R_LE_BREAKPOINT16 {0xf1, 0x10}

static int
m32r_memory_insert_breakpoint (CORE_ADDR addr, char *contents_cache)
{
  int val;
  unsigned char *bp;
  int bplen;

  bplen = (addr & 3) ? 2 : 4;

  /* Save the memory contents.  */
  val = target_read_memory (addr, contents_cache, bplen);
  if (val != 0)
    return val;			/* return error */

  /* Determine appropriate breakpoint contents and size for this address.  */
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
    {
      if (((addr & 3) == 0)
	  && ((contents_cache[0] & 0x80) || (contents_cache[2] & 0x80)))
	{
	  static unsigned char insn[] = M32R_BE_BREAKPOINT32;
	  bp = insn;
	  bplen = sizeof (insn);
	}
      else
	{
	  static unsigned char insn[] = M32R_BE_BREAKPOINT16;
	  bp = insn;
	  bplen = sizeof (insn);
	}
    }
  else
    {				/* little-endian */
      if (((addr & 3) == 0)
	  && ((contents_cache[1] & 0x80) || (contents_cache[3] & 0x80)))
	{
	  static unsigned char insn[] = M32R_LE_BREAKPOINT32;
	  bp = insn;
	  bplen = sizeof (insn);
	}
      else
	{
	  static unsigned char insn[] = M32R_LE_BREAKPOINT16;
	  bp = insn;
	  bplen = sizeof (insn);
	}
    }

  /* Write the breakpoint.  */
  val = target_write_memory (addr, (char *) bp, bplen);
  return val;
}

static int
m32r_memory_remove_breakpoint (CORE_ADDR addr, char *contents_cache)
{
  int val;
  int bplen;

  /* Determine appropriate breakpoint contents and size for this address.  */
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
    {
      if (((addr & 3) == 0)
	  && ((contents_cache[0] & 0x80) || (contents_cache[2] & 0x80)))
	{
	  static unsigned char insn[] = M32R_BE_BREAKPOINT32;
	  bplen = sizeof (insn);
	}
      else
	{
	  static unsigned char insn[] = M32R_BE_BREAKPOINT16;
	  bplen = sizeof (insn);
	}
    }
  else
    {
      /* little-endian */
      if (((addr & 3) == 0)
	  && ((contents_cache[1] & 0x80) || (contents_cache[3] & 0x80)))
	{
	  static unsigned char insn[] = M32R_BE_BREAKPOINT32;
	  bplen = sizeof (insn);
	}
      else
	{
	  static unsigned char insn[] = M32R_BE_BREAKPOINT16;
	  bplen = sizeof (insn);
	}
    }

  /* Write contents.  */
  val = target_write_memory (addr, contents_cache, bplen);
  return val;
}

static const unsigned char *
m32r_breakpoint_from_pc (CORE_ADDR *pcptr, int *lenptr)
{
  unsigned char *bp;

  /* Determine appropriate breakpoint.  */
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
    {
      if ((*pcptr & 3) == 0)
	{
	  static unsigned char insn[] = M32R_BE_BREAKPOINT32;
	  bp = insn;
	  *lenptr = sizeof (insn);
	}
      else
	{
	  static unsigned char insn[] = M32R_BE_BREAKPOINT16;
	  bp = insn;
	  *lenptr = sizeof (insn);
	}
    }
  else
    {
      if ((*pcptr & 3) == 0)
	{
	  static unsigned char insn[] = M32R_LE_BREAKPOINT32;
	  bp = insn;
	  *lenptr = sizeof (insn);
	}
      else
	{
	  static unsigned char insn[] = M32R_LE_BREAKPOINT16;
	  bp = insn;
	  *lenptr = sizeof (insn);
	}
    }

  return bp;
}


char *m32r_register_names[] = {
  "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
  "r8", "r9", "r10", "r11", "r12", "fp", "lr", "sp",
  "psw", "cbr", "spi", "spu", "bpc", "pc", "accl", "acch",
  "evb"
};

static int
m32r_num_regs (void)
{
  return (sizeof (m32r_register_names) / sizeof (m32r_register_names[0]));
}

static const char *
m32r_register_name (int reg_nr)
{
  if (reg_nr < 0)
    return NULL;
  if (reg_nr >= m32r_num_regs ())
    return NULL;
  return m32r_register_names[reg_nr];
}


/* Return the GDB type object for the "standard" data type
   of data in register N.  */

static struct type *
m32r_register_type (struct gdbarch *gdbarch, int reg_nr)
{
  if (reg_nr == M32R_PC_REGNUM)
    return builtin_type_void_func_ptr;
  else if (reg_nr == M32R_SP_REGNUM || reg_nr == M32R_FP_REGNUM)
    return builtin_type_void_data_ptr;
  else
    return builtin_type_int32;
}


/* Write into appropriate registers a function return value
   of type TYPE, given in virtual format.  

   Things always get returned in RET1_REGNUM, RET2_REGNUM. */

static void
m32r_store_return_value (struct type *type, struct regcache *regcache,
			 const void *valbuf)
{
  CORE_ADDR regval;
  int len = TYPE_LENGTH (type);

  regval = extract_unsigned_integer (valbuf, len > 4 ? 4 : len);
  regcache_cooked_write_unsigned (regcache, RET1_REGNUM, regval);

  if (len > 4)
    {
      regval = extract_unsigned_integer ((char *) valbuf + 4, len - 4);
      regcache_cooked_write_unsigned (regcache, RET1_REGNUM + 1, regval);
    }
}

/* Extract from an array REGBUF containing the (raw) register state
   the address in which a function should return its structure value,
   as a CORE_ADDR (or an expression that can be used as one).  */

static CORE_ADDR
m32r_extract_struct_value_address (struct regcache *regcache)
{
  ULONGEST addr;
  regcache_cooked_read_unsigned (regcache, ARG1_REGNUM, &addr);
  return addr;
}


/* This is required by skip_prologue. The results of decoding a prologue
   should be cached because this thrashing is getting nuts.  */

static void
decode_prologue (CORE_ADDR start_pc, CORE_ADDR scan_limit,
		 CORE_ADDR *pl_endptr)
{
  unsigned long framesize;
  int insn;
  int op1;
  int maybe_one_more = 0;
  CORE_ADDR after_prologue = 0;
  CORE_ADDR after_stack_adjust = 0;
  CORE_ADDR current_pc;

  framesize = 0;
  after_prologue = 0;

  for (current_pc = start_pc; current_pc < scan_limit; current_pc += 2)
    {
      insn = read_memory_unsigned_integer (current_pc, 2);

      /* If this is a 32 bit instruction, we dont want to examine its
         immediate data as though it were an instruction */
      if (current_pc & 0x02)
	{
	  /* Clear the parallel execution bit from 16 bit instruction */
	  if (maybe_one_more)
	    {
	      /* The last instruction was a branch, usually terminates
	         the series, but if this is a parallel instruction,
	         it may be a stack framing instruction */
	      if (!(insn & 0x8000))
		{
		  /* nope, we are really done */
		  break;
		}
	    }
	  /* decode this instruction further */
	  insn &= 0x7fff;
	}
      else
	{
	  if (maybe_one_more)
	    break;		/* This isnt the one more */
	  if (insn & 0x8000)
	    {
	      if (current_pc == scan_limit)
		scan_limit += 2;	/* extend the search */
	      current_pc += 2;	/* skip the immediate data */
	      if (insn == 0x8faf)	/* add3 sp, sp, xxxx */
		/* add 16 bit sign-extended offset */
		{
		  framesize +=
		    -((short) read_memory_unsigned_integer (current_pc, 2));
		}
	      else
		{
		  if (((insn >> 8) == 0xe4)	/* ld24 r4, xxxxxx; sub sp, r4 */
		      && read_memory_unsigned_integer (current_pc + 2,
						       2) == 0x0f24)
		    /* subtract 24 bit sign-extended negative-offset */
		    {
		      insn = read_memory_unsigned_integer (current_pc - 2, 4);
		      if (insn & 0x00800000)	/* sign extend */
			insn |= 0xff000000;	/* negative */
		      else
			insn &= 0x00ffffff;	/* positive */
		      framesize += insn;
		    }
		}
	      after_prologue = current_pc;
	      continue;
	    }
	}
      op1 = insn & 0xf000;	/* isolate just the first nibble */

      if ((insn & 0xf0ff) == 0x207f)
	{			/* st reg, @@-sp */
	  int regno;
	  framesize += 4;
	  regno = ((insn >> 8) & 0xf);
	  after_prologue = 0;
	  continue;
	}
      if ((insn >> 8) == 0x4f)	/* addi sp, xx */
	/* add 8 bit sign-extended offset */
	{
	  int stack_adjust = (char) (insn & 0xff);

	  /* there are probably two of these stack adjustments:
	     1) A negative one in the prologue, and
	     2) A positive one in the epilogue.
	     We are only interested in the first one.  */

	  if (stack_adjust < 0)
	    {
	      framesize -= stack_adjust;
	      after_prologue = 0;
	      /* A frameless function may have no "mv fp, sp".
	         In that case, this is the end of the prologue.  */
	      after_stack_adjust = current_pc + 2;
	    }
	  continue;
	}
      if (insn == 0x1d8f)
	{			/* mv fp, sp */
	  after_prologue = current_pc + 2;
	  break;		/* end of stack adjustments */
	}
      /* Nop looks like a branch, continue explicitly */
      if (insn == 0x7000)
	{
	  after_prologue = current_pc + 2;
	  continue;		/* nop occurs between pushes */
	}
      /* End of prolog if any of these are branch instructions */
      if ((op1 == 0x7000) || (op1 == 0xb000) || (op1 == 0xf000))
	{
	  after_prologue = current_pc;
	  maybe_one_more = 1;
	  continue;
	}
      /* Some of the branch instructions are mixed with other types */
      if (op1 == 0x1000)
	{
	  int subop = insn & 0x0ff0;
	  if ((subop == 0x0ec0) || (subop == 0x0fc0))
	    {
	      after_prologue = current_pc;
	      maybe_one_more = 1;
	      continue;		/* jmp , jl */
	    }
	}
    }

  if (current_pc >= scan_limit)
    {
      if (pl_endptr)
	{
	  if (after_stack_adjust != 0)
	    /* We did not find a "mv fp,sp", but we DID find
	       a stack_adjust.  Is it safe to use that as the
	       end of the prologue?  I just don't know. */
	    {
	      *pl_endptr = after_stack_adjust;
	    }
	  else
	    /* We reached the end of the loop without finding the end
	       of the prologue.  No way to win -- we should report failure.  
	       The way we do that is to return the original start_pc.
	       GDB will set a breakpoint at the start of the function (etc.) */
	    *pl_endptr = start_pc;
	}
      return;
    }
  if (after_prologue == 0)
    after_prologue = current_pc;

  if (pl_endptr)
    *pl_endptr = after_prologue;
}				/*  decode_prologue */

/* Function: skip_prologue
   Find end of function prologue */

#define DEFAULT_SEARCH_LIMIT 44

CORE_ADDR
m32r_skip_prologue (CORE_ADDR pc)
{
  CORE_ADDR func_addr, func_end;
  struct symtab_and_line sal;

  /* See what the symbol table says */

  if (find_pc_partial_function (pc, NULL, &func_addr, &func_end))
    {
      sal = find_pc_line (func_addr, 0);

      if (sal.line != 0 && sal.end <= func_end)
	{
	  func_end = sal.end;
	}
      else
	/* Either there's no line info, or the line after the prologue is after
	   the end of the function.  In this case, there probably isn't a
	   prologue.  */
	{
	  func_end = min (func_end, func_addr + DEFAULT_SEARCH_LIMIT);
	}
    }
  else
    func_end = pc + DEFAULT_SEARCH_LIMIT;
  decode_prologue (pc, func_end, &sal.end);
  return sal.end;
}


struct m32r_unwind_cache
{
  /* The previous frame's inner most stack address.  Used as this
     frame ID's stack_addr.  */
  CORE_ADDR prev_sp;
  /* The frame's base, optionally used by the high-level debug info.  */
  CORE_ADDR base;
  int size;
  /* How far the SP and r13 (FP) have been offset from the start of
     the stack frame (as defined by the previous frame's stack
     pointer).  */
  LONGEST sp_offset;
  LONGEST r13_offset;
  int uses_frame;
  /* Table indicating the location of each and every register.  */
  struct trad_frame_saved_reg *saved_regs;
};

/* Put here the code to store, into fi->saved_regs, the addresses of
   the saved registers of frame described by FRAME_INFO.  This
   includes special registers such as pc and fp saved in special ways
   in the stack frame.  sp is even more special: the address we return
   for it IS the sp for the next frame. */

static struct m32r_unwind_cache *
m32r_frame_unwind_cache (struct frame_info *next_frame,
			 void **this_prologue_cache)
{
  CORE_ADDR pc;
  ULONGEST prev_sp;
  ULONGEST this_base;
  unsigned long op;
  int i;
  struct m32r_unwind_cache *info;

  if ((*this_prologue_cache))
    return (*this_prologue_cache);

  info = FRAME_OBSTACK_ZALLOC (struct m32r_unwind_cache);
  (*this_prologue_cache) = info;
  info->saved_regs = trad_frame_alloc_saved_regs (next_frame);

  info->size = 0;
  info->sp_offset = 0;

  info->uses_frame = 0;
  for (pc = frame_func_unwind (next_frame);
       pc > 0 && pc < frame_pc_unwind (next_frame); pc += 2)
    {
      if ((pc & 2) == 0)
	{
	  op = get_frame_memory_unsigned (next_frame, pc, 4);
	  if ((op & 0x80000000) == 0x80000000)
	    {
	      /* 32-bit instruction */
	      if ((op & 0xffff0000) == 0x8faf0000)
		{
		  /* add3 sp,sp,xxxx */
		  short n = op & 0xffff;
		  info->sp_offset += n;
		}
	      else if (((op >> 8) == 0xe4)	/* ld24 r4, xxxxxx; sub sp, r4 */
		       && get_frame_memory_unsigned (next_frame, pc + 4,
						     2) == 0x0f24)
		{
		  unsigned long n = op & 0xffffff;
		  info->sp_offset += n;
		  pc += 2;
		}
	      else
		break;

	      pc += 2;
	      continue;
	    }
	}

      /* 16-bit instructions */
      op = get_frame_memory_unsigned (next_frame, pc, 2) & 0x7fff;
      if ((op & 0xf0ff) == 0x207f)
	{
	  /* st rn, @@-sp */
	  int regno = ((op >> 8) & 0xf);
	  info->sp_offset -= 4;
	  info->saved_regs[regno].addr = info->sp_offset;
	}
      else if ((op & 0xff00) == 0x4f00)
	{
	  /* addi sp, xx */
	  int n = (char) (op & 0xff);
	  info->sp_offset += n;
	}
      else if (op == 0x1d8f)
	{
	  /* mv fp, sp */
	  info->uses_frame = 1;
	  info->r13_offset = info->sp_offset;
	}
      else if (op == 0x7000)
	/* nop */
	continue;
      else
	break;
    }

  info->size = -info->sp_offset;

  /* Compute the previous frame's stack pointer (which is also the
     frame's ID's stack address), and this frame's base pointer.  */
  if (info->uses_frame)
    {
      /* The SP was moved to the FP.  This indicates that a new frame
         was created.  Get THIS frame's FP value by unwinding it from
         the next frame.  */
      this_base = frame_unwind_register_unsigned (next_frame, M32R_FP_REGNUM);
      /* The FP points at the last saved register.  Adjust the FP back
         to before the first saved register giving the SP.  */
      prev_sp = this_base + info->size;
    }
  else
    {
      /* Assume that the FP is this frame's SP but with that pushed
         stack space added back.  */
      this_base = frame_unwind_register_unsigned (next_frame, M32R_SP_REGNUM);
      prev_sp = this_base + info->size;
    }

  /* Convert that SP/BASE into real addresses.  */
  info->prev_sp = prev_sp;
  info->base = this_base;

  /* Adjust all the saved registers so that they contain addresses and
     not offsets.  */
  for (i = 0; i < NUM_REGS - 1; i++)
    if (trad_frame_addr_p (info->saved_regs, i))
      info->saved_regs[i].addr = (info->prev_sp + info->saved_regs[i].addr);

  /* The call instruction moves the caller's PC in the callee's LR.
     Since this is an unwind, do the reverse.  Copy the location of LR
     into PC (the address / regnum) so that a request for PC will be
     converted into a request for the LR.  */
  info->saved_regs[M32R_PC_REGNUM] = info->saved_regs[LR_REGNUM];

  /* The previous frame's SP needed to be computed.  Save the computed
     value.  */
  trad_frame_set_value (info->saved_regs, M32R_SP_REGNUM, prev_sp);

  return info;
}

static CORE_ADDR
m32r_read_pc (ptid_t ptid)
{
  ptid_t save_ptid;
  ULONGEST pc;

  save_ptid = inferior_ptid;
  inferior_ptid = ptid;
  regcache_cooked_read_unsigned (current_regcache, M32R_PC_REGNUM, &pc);
  inferior_ptid = save_ptid;
  return pc;
}

static void
m32r_write_pc (CORE_ADDR val, ptid_t ptid)
{
  ptid_t save_ptid;

  save_ptid = inferior_ptid;
  inferior_ptid = ptid;
  write_register (M32R_PC_REGNUM, val);
  inferior_ptid = save_ptid;
}

static CORE_ADDR
m32r_unwind_sp (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  return frame_unwind_register_unsigned (next_frame, M32R_SP_REGNUM);
}


static CORE_ADDR
m32r_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
		      struct regcache *regcache, CORE_ADDR bp_addr, int nargs,
		      struct value **args, CORE_ADDR sp, int struct_return,
		      CORE_ADDR struct_addr)
{
  int stack_offset, stack_alloc;
  int argreg = ARG1_REGNUM;
  int argnum;
  struct type *type;
  enum type_code typecode;
  CORE_ADDR regval;
  char *val;
  char valbuf[MAX_REGISTER_SIZE];
  int len;
  int odd_sized_struct;

  /* first force sp to a 4-byte alignment */
  sp = sp & ~3;

  /* Set the return address.  For the m32r, the return breakpoint is
     always at BP_ADDR.  */
  regcache_cooked_write_unsigned (regcache, LR_REGNUM, bp_addr);

  /* If STRUCT_RETURN is true, then the struct return address (in
     STRUCT_ADDR) will consume the first argument-passing register.
     Both adjust the register count and store that value.  */
  if (struct_return)
    {
      regcache_cooked_write_unsigned (regcache, argreg, struct_addr);
      argreg++;
    }

  /* Now make sure there's space on the stack */
  for (argnum = 0, stack_alloc = 0; argnum < nargs; argnum++)
    stack_alloc += ((TYPE_LENGTH (VALUE_TYPE (args[argnum])) + 3) & ~3);
  sp -= stack_alloc;		/* make room on stack for args */

  for (argnum = 0, stack_offset = 0; argnum < nargs; argnum++)
    {
      type = VALUE_TYPE (args[argnum]);
      typecode = TYPE_CODE (type);
      len = TYPE_LENGTH (type);

      memset (valbuf, 0, sizeof (valbuf));

      /* Passes structures that do not fit in 2 registers by reference.  */
      if (len > 8
	  && (typecode == TYPE_CODE_STRUCT || typecode == TYPE_CODE_UNION))
	{
	  store_unsigned_integer (valbuf, 4, VALUE_ADDRESS (args[argnum]));
	  typecode = TYPE_CODE_PTR;
	  len = 4;
	  val = valbuf;
	}
      else if (len < 4)
	{
	  /* value gets right-justified in the register or stack word */
	  memcpy (valbuf + (register_size (gdbarch, argreg) - len),
		  (char *) VALUE_CONTENTS (args[argnum]), len);
	  val = valbuf;
	}
      else
	val = (char *) VALUE_CONTENTS (args[argnum]);

      while (len > 0)
	{
	  if (argreg > ARGN_REGNUM)
	    {
	      /* must go on the stack */
	      write_memory (sp + stack_offset, val, 4);
	      stack_offset += 4;
	    }
	  else if (argreg <= ARGN_REGNUM)
	    {
	      /* there's room in a register */
	      regval =
		extract_unsigned_integer (val,
					  register_size (gdbarch, argreg));
	      regcache_cooked_write_unsigned (regcache, argreg++, regval);
	    }

	  /* Store the value 4 bytes at a time.  This means that things
	     larger than 4 bytes may go partly in registers and partly
	     on the stack.  */
	  len -= register_size (gdbarch, argreg);
	  val += register_size (gdbarch, argreg);
	}
    }

  /* Finally, update the SP register.  */
  regcache_cooked_write_unsigned (regcache, M32R_SP_REGNUM, sp);

  return sp;
}


/* Given a return value in `regbuf' with a type `valtype', 
   extract and copy its value into `valbuf'.  */

static void
m32r_extract_return_value (struct type *type, struct regcache *regcache,
			   void *dst)
{
  bfd_byte *valbuf = dst;
  int len = TYPE_LENGTH (type);
  ULONGEST tmp;

  /* By using store_unsigned_integer we avoid having to do
     anything special for small big-endian values.  */
  regcache_cooked_read_unsigned (regcache, RET1_REGNUM, &tmp);
  store_unsigned_integer (valbuf, (len > 4 ? len - 4 : len), tmp);

  /* Ignore return values more than 8 bytes in size because the m32r
     returns anything more than 8 bytes in the stack. */
  if (len > 4)
    {
      regcache_cooked_read_unsigned (regcache, RET1_REGNUM + 1, &tmp);
      store_unsigned_integer (valbuf + len - 4, 4, tmp);
    }
}


static CORE_ADDR
m32r_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  return frame_unwind_register_unsigned (next_frame, M32R_PC_REGNUM);
}

/* Given a GDB frame, determine the address of the calling function's
   frame.  This will be used to create a new GDB frame struct.  */

static void
m32r_frame_this_id (struct frame_info *next_frame,
		    void **this_prologue_cache, struct frame_id *this_id)
{
  struct m32r_unwind_cache *info
    = m32r_frame_unwind_cache (next_frame, this_prologue_cache);
  CORE_ADDR base;
  CORE_ADDR func;
  struct minimal_symbol *msym_stack;
  struct frame_id id;

  /* The FUNC is easy.  */
  func = frame_func_unwind (next_frame);

  /* This is meant to halt the backtrace at "_start".  Make sure we
     don't halt it at a generic dummy frame. */
  if (inside_entry_file (func))
    return;

  /* Check if the stack is empty.  */
  msym_stack = lookup_minimal_symbol ("_stack", NULL, NULL);
  if (msym_stack && info->base == SYMBOL_VALUE_ADDRESS (msym_stack))
    return;

  /* Hopefully the prologue analysis either correctly determined the
     frame's base (which is the SP from the previous frame), or set
     that base to "NULL".  */
  base = info->prev_sp;
  if (base == 0)
    return;

  id = frame_id_build (base, func);

  /* Check that we're not going round in circles with the same frame
     ID (but avoid applying the test to sentinel frames which do go
     round in circles).  Can't use frame_id_eq() as that doesn't yet
     compare the frame's PC value.  */
  if (frame_relative_level (next_frame) >= 0
      && get_frame_type (next_frame) != DUMMY_FRAME
      && frame_id_eq (get_frame_id (next_frame), id))
    return;

  (*this_id) = id;
}

static void
m32r_frame_prev_register (struct frame_info *next_frame,
			  void **this_prologue_cache,
			  int regnum, int *optimizedp,
			  enum lval_type *lvalp, CORE_ADDR *addrp,
			  int *realnump, void *bufferp)
{
  struct m32r_unwind_cache *info
    = m32r_frame_unwind_cache (next_frame, this_prologue_cache);
  trad_frame_prev_register (next_frame, info->saved_regs, regnum,
			    optimizedp, lvalp, addrp, realnump, bufferp);
}

static const struct frame_unwind m32r_frame_unwind = {
  NORMAL_FRAME,
  m32r_frame_this_id,
  m32r_frame_prev_register
};

static const struct frame_unwind *
m32r_frame_sniffer (struct frame_info *next_frame)
{
  return &m32r_frame_unwind;
}

static CORE_ADDR
m32r_frame_base_address (struct frame_info *next_frame, void **this_cache)
{
  struct m32r_unwind_cache *info
    = m32r_frame_unwind_cache (next_frame, this_cache);
  return info->base;
}

static const struct frame_base m32r_frame_base = {
  &m32r_frame_unwind,
  m32r_frame_base_address,
  m32r_frame_base_address,
  m32r_frame_base_address
};

/* Assuming NEXT_FRAME->prev is a dummy, return the frame ID of that
   dummy frame.  The frame ID's base needs to match the TOS value
   saved by save_dummy_frame_tos(), and the PC match the dummy frame's
   breakpoint.  */

static struct frame_id
m32r_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  return frame_id_build (m32r_unwind_sp (gdbarch, next_frame),
			 frame_pc_unwind (next_frame));
}


static gdbarch_init_ftype m32r_gdbarch_init;

static struct gdbarch *
m32r_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
{
  struct gdbarch *gdbarch;
  struct gdbarch_tdep *tdep;

  /* If there is already a candidate, use it.  */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;

  /* Allocate space for the new architecture.  */
  tdep = XMALLOC (struct gdbarch_tdep);
  gdbarch = gdbarch_alloc (&info, tdep);

  set_gdbarch_read_pc (gdbarch, m32r_read_pc);
  set_gdbarch_write_pc (gdbarch, m32r_write_pc);
  set_gdbarch_unwind_sp (gdbarch, m32r_unwind_sp);

  set_gdbarch_num_regs (gdbarch, m32r_num_regs ());
  set_gdbarch_sp_regnum (gdbarch, M32R_SP_REGNUM);
  set_gdbarch_register_name (gdbarch, m32r_register_name);
  set_gdbarch_register_type (gdbarch, m32r_register_type);

  set_gdbarch_extract_return_value (gdbarch, m32r_extract_return_value);
  set_gdbarch_push_dummy_call (gdbarch, m32r_push_dummy_call);
  set_gdbarch_store_return_value (gdbarch, m32r_store_return_value);
  set_gdbarch_extract_struct_value_address (gdbarch,
					    m32r_extract_struct_value_address);
  set_gdbarch_use_struct_convention (gdbarch, m32r_use_struct_convention);

  set_gdbarch_skip_prologue (gdbarch, m32r_skip_prologue);
  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);
  set_gdbarch_decr_pc_after_break (gdbarch, 0);
  set_gdbarch_function_start_offset (gdbarch, 0);
  set_gdbarch_breakpoint_from_pc (gdbarch, m32r_breakpoint_from_pc);
  set_gdbarch_memory_insert_breakpoint (gdbarch,
					m32r_memory_insert_breakpoint);
  set_gdbarch_memory_remove_breakpoint (gdbarch,
					m32r_memory_remove_breakpoint);

  set_gdbarch_frame_args_skip (gdbarch, 0);
  set_gdbarch_frameless_function_invocation (gdbarch,
					     frameless_look_for_prologue);

  set_gdbarch_frame_align (gdbarch, m32r_frame_align);

  frame_unwind_append_sniffer (gdbarch, m32r_frame_sniffer);
  frame_base_set_default (gdbarch, &m32r_frame_base);

  /* Methods for saving / extracting a dummy frame's ID.  The ID's
     stack address must match the SP value returned by
     PUSH_DUMMY_CALL, and saved by generic_save_dummy_frame_tos.  */
  set_gdbarch_unwind_dummy_id (gdbarch, m32r_unwind_dummy_id);

  /* Return the unwound PC value.  */
  set_gdbarch_unwind_pc (gdbarch, m32r_unwind_pc);

  set_gdbarch_print_insn (gdbarch, print_insn_m32r);

  return gdbarch;
}

void
_initialize_m32r_tdep (void)
{
  register_gdbarch_init (bfd_arch_m32r, m32r_gdbarch_init);
}
@


1.13
log
@2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* ax-gdb.c, c-valprint.c, charset.c, corefile.c: Update copyright.
	* demangle.c, disasm.c, dwarf2cfi.c, dwarfread.c: Update copyright.
	* elfread.c, eval.c, expprint.c, expression.h: Update copyright.
	* f-typeprint.c, findvar.c, gcore.c, gdb_mbuild.sh: Update copyright.
	* gdbtypes.h, gnu-v2-abi.c, inferior.h, inftarg.c: Update copyright.
	* language.c, language.h, m32r-tdep.c: Update copyright.
	* mn10200-tdep.c, scm-lang.c, scm-lang.h: Update copyright.
	* somsolib.c, somsolib.h, symfile.c, symtab.h: Update copyright.
	* thread-db.c, typeprint.c, utils.c, valarith.c: Update copyright.
	* values.c, win32-nat.c, x86-64-linux-nat.c: Update copyright.
	* x86-64-linux-tdep.c, z8k-tdep.c: Update copyright.
	* cli/cli-decode.h, config/h8500/tm-h8500.h: Update copyright.

Index: mi/ChangeLog
2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* mi-cmd-env.c: Update copyright.
@
text
@d1 708
a708 708
/* Target-dependent code for the Mitsubishi m32r for GDB, the GNU debugger.

   Copyright 1996, 1998, 1999, 2000, 2001, 2003 Free Software
   Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "frame.h"
#include "inferior.h"
#include "target.h"
#include "value.h"
#include "bfd.h"
#include "gdb_string.h"
#include "gdbcore.h"
#include "symfile.h"
#include "regcache.h"

/* Function: m32r_use_struct_convention
   Return nonzero if call_function should allocate stack space for a
   struct return? */
int
m32r_use_struct_convention (int gcc_p, struct type *type)
{
  return (TYPE_LENGTH (type) > 8);
}

/* Function: frame_find_saved_regs
   Return the frame_saved_regs structure for the frame.
   Doesn't really work for dummy frames, but it does pass back
   an empty frame_saved_regs, so I guess that's better than total failure */

void
m32r_frame_find_saved_regs (struct frame_info *fi,
			    struct frame_saved_regs *regaddr)
{
  memcpy (regaddr, &fi->fsr, sizeof (struct frame_saved_regs));
}

/* Turn this on if you want to see just how much instruction decoding
   if being done, its quite a lot
 */
#if 0
static void
dump_insn (char *commnt, CORE_ADDR pc, int insn)
{
  printf_filtered ("  %s %08x %08x ",
		   commnt, (unsigned int) pc, (unsigned int) insn);
  TARGET_PRINT_INSN (pc, &tm_print_insn_info);
  printf_filtered ("\n");
}
#define insn_debug(args) { printf_filtered args; }
#else
#define dump_insn(a,b,c) {}
#define insn_debug(args) {}
#endif

#define DEFAULT_SEARCH_LIMIT 44

/* Function: scan_prologue
   This function decodes the target function prologue to determine
   1) the size of the stack frame, and 2) which registers are saved on it.
   It saves the offsets of saved regs in the frame_saved_regs argument,
   and returns the frame size.  */

/*
   The sequence it currently generates is:

   if (varargs function) { ddi sp,#n }
   push registers
   if (additional stack <= 256) {       addi sp,#-stack }
   else if (additional stack < 65k) { add3 sp,sp,#-stack

   } else if (additional stack) {
   seth sp,#(stack & 0xffff0000)
   or3 sp,sp,#(stack & 0x0000ffff)
   sub sp,r4
   }
   if (frame pointer) {
   mv sp,fp
   }

   These instructions are scheduled like everything else, so you should stop at
   the first branch instruction.

 */

/* This is required by skip prologue and by m32r_init_extra_frame_info. 
   The results of decoding a prologue should be cached because this
   thrashing is getting nuts.
   I am thinking of making a container class with two indexes, name and
   address. It may be better to extend the symbol table.
 */

static void
decode_prologue (CORE_ADDR start_pc, CORE_ADDR scan_limit, CORE_ADDR *pl_endptr,	/* var parameter */
		 unsigned long *framelength, struct frame_info *fi,
		 struct frame_saved_regs *fsr)
{
  unsigned long framesize;
  int insn;
  int op1;
  int maybe_one_more = 0;
  CORE_ADDR after_prologue = 0;
  CORE_ADDR after_stack_adjust = 0;
  CORE_ADDR current_pc;


  framesize = 0;
  after_prologue = 0;
  insn_debug (("rd prolog l(%d)\n", scan_limit - current_pc));

  for (current_pc = start_pc; current_pc < scan_limit; current_pc += 2)
    {

      insn = read_memory_unsigned_integer (current_pc, 2);
      dump_insn ("insn-1", current_pc, insn);	/* MTZ */

      /* If this is a 32 bit instruction, we dont want to examine its
         immediate data as though it were an instruction */
      if (current_pc & 0x02)
	{			/* Clear the parallel execution bit from 16 bit instruction */
	  if (maybe_one_more)
	    {			/* The last instruction was a branch, usually terminates
				   the series, but if this is a parallel instruction,
				   it may be a stack framing instruction */
	      if (!(insn & 0x8000))
		{
		  insn_debug (("Really done"));
		  break;	/* nope, we are really done */
		}
	    }
	  insn &= 0x7fff;	/* decode this instruction further */
	}
      else
	{
	  if (maybe_one_more)
	    break;		/* This isnt the one more */
	  if (insn & 0x8000)
	    {
	      insn_debug (("32 bit insn\n"));
	      if (current_pc == scan_limit)
		scan_limit += 2;	/* extend the search */
	      current_pc += 2;	/* skip the immediate data */
	      if (insn == 0x8faf)	/* add3 sp, sp, xxxx */
		/* add 16 bit sign-extended offset */
		{
		  insn_debug (("stack increment\n"));
		  framesize += -((short) read_memory_unsigned_integer (current_pc, 2));
		}
	      else
		{
		  if (((insn >> 8) == 0xe4) &&	/* ld24 r4, xxxxxx; sub sp, r4 */
		  read_memory_unsigned_integer (current_pc + 2, 2) == 0x0f24)
		    {		/* subtract 24 bit sign-extended negative-offset */
		      dump_insn ("insn-2", current_pc + 2, insn);
		      insn = read_memory_unsigned_integer (current_pc - 2, 4);
		      dump_insn ("insn-3(l4)", current_pc - 2, insn);
		      if (insn & 0x00800000)	/* sign extend */
			insn |= 0xff000000;	/* negative */
		      else
			insn &= 0x00ffffff;	/* positive */
		      framesize += insn;
		    }
		}
	      after_prologue = current_pc;
	      continue;
	    }
	}
      op1 = insn & 0xf000;	/* isolate just the first nibble */

      if ((insn & 0xf0ff) == 0x207f)
	{			/* st reg, @@-sp */
	  int regno;
	  insn_debug (("push\n"));
#if 0				/* No, PUSH FP is not an indication that we will use a frame pointer. */
	  if (((insn & 0xffff) == 0x2d7f) && fi)
	    fi->using_frame_pointer = 1;
#endif
	  framesize += 4;
#if 0
/* Why should we increase the scan limit, just because we did a push? 
   And if there is a reason, surely we would only want to do it if we
   had already reached the scan limit... */
	  if (current_pc == scan_limit)
	    scan_limit += 2;
#endif
	  regno = ((insn >> 8) & 0xf);
	  if (fsr)		/* save_regs offset */
	    fsr->regs[regno] = framesize;
	  after_prologue = 0;
	  continue;
	}
      if ((insn >> 8) == 0x4f)	/* addi sp, xx */
	/* add 8 bit sign-extended offset */
	{
	  int stack_adjust = (char) (insn & 0xff);

	  /* there are probably two of these stack adjustments:
	     1) A negative one in the prologue, and
	     2) A positive one in the epilogue.
	     We are only interested in the first one.  */

	  if (stack_adjust < 0)
	    {
	      framesize -= stack_adjust;
	      after_prologue = 0;
	      /* A frameless function may have no "mv fp, sp".
	         In that case, this is the end of the prologue.  */
	      after_stack_adjust = current_pc + 2;
	    }
	  continue;
	}
      if (insn == 0x1d8f)
	{			/* mv fp, sp */
	  if (fi)
	    fi->using_frame_pointer = 1;	/* fp is now valid */
	  insn_debug (("done fp found\n"));
	  after_prologue = current_pc + 2;
	  break;		/* end of stack adjustments */
	}
      if (insn == 0x7000)	/* Nop looks like a branch, continue explicitly */
	{
	  insn_debug (("nop\n"));
	  after_prologue = current_pc + 2;
	  continue;		/* nop occurs between pushes */
	}
      /* End of prolog if any of these are branch instructions */
      if ((op1 == 0x7000)
	  || (op1 == 0xb000)
	  || (op1 == 0xf000))
	{
	  after_prologue = current_pc;
	  insn_debug (("Done: branch\n"));
	  maybe_one_more = 1;
	  continue;
	}
      /* Some of the branch instructions are mixed with other types */
      if (op1 == 0x1000)
	{
	  int subop = insn & 0x0ff0;
	  if ((subop == 0x0ec0) || (subop == 0x0fc0))
	    {
	      insn_debug (("done: jmp\n"));
	      after_prologue = current_pc;
	      maybe_one_more = 1;
	      continue;		/* jmp , jl */
	    }
	}
    }

  if (current_pc >= scan_limit)
    {
      if (pl_endptr)
	{
#if 1
	  if (after_stack_adjust != 0)
	    /* We did not find a "mv fp,sp", but we DID find
	       a stack_adjust.  Is it safe to use that as the
	       end of the prologue?  I just don't know. */
	    {
	      *pl_endptr = after_stack_adjust;
	      if (framelength)
		*framelength = framesize;
	    }
	  else
#endif
	    /* We reached the end of the loop without finding the end
	       of the prologue.  No way to win -- we should report failure.  
	       The way we do that is to return the original start_pc.
	       GDB will set a breakpoint at the start of the function (etc.) */
	    *pl_endptr = start_pc;
	}
      return;
    }
  if (after_prologue == 0)
    after_prologue = current_pc;

  insn_debug ((" framesize %d, firstline %08x\n", framesize, after_prologue));
  if (framelength)
    *framelength = framesize;
  if (pl_endptr)
    *pl_endptr = after_prologue;
}				/*  decode_prologue */

/* Function: skip_prologue
   Find end of function prologue */

CORE_ADDR
m32r_skip_prologue (CORE_ADDR pc)
{
  CORE_ADDR func_addr, func_end;
  struct symtab_and_line sal;

  /* See what the symbol table says */

  if (find_pc_partial_function (pc, NULL, &func_addr, &func_end))
    {
      sal = find_pc_line (func_addr, 0);

      if (sal.line != 0 && sal.end <= func_end)
	{

	  insn_debug (("BP after prologue %08x\n", sal.end));
	  func_end = sal.end;
	}
      else
	/* Either there's no line info, or the line after the prologue is after
	   the end of the function.  In this case, there probably isn't a
	   prologue.  */
	{
	  insn_debug (("No line info, line(%x) sal_end(%x) funcend(%x)\n",
		       sal.line, sal.end, func_end));
	  func_end = min (func_end, func_addr + DEFAULT_SEARCH_LIMIT);
	}
    }
  else
    func_end = pc + DEFAULT_SEARCH_LIMIT;
  decode_prologue (pc, func_end, &sal.end, 0, 0, 0);
  return sal.end;
}

static unsigned long
m32r_scan_prologue (struct frame_info *fi, struct frame_saved_regs *fsr)
{
  struct symtab_and_line sal;
  CORE_ADDR prologue_start, prologue_end, current_pc;
  unsigned long framesize = 0;

  /* this code essentially duplicates skip_prologue, 
     but we need the start address below.  */

  if (find_pc_partial_function (fi->pc, NULL, &prologue_start, &prologue_end))
    {
      sal = find_pc_line (prologue_start, 0);

      if (sal.line == 0)	/* no line info, use current PC */
	if (prologue_start == entry_point_address ())
	  return 0;
    }
  else
    {
      prologue_start = fi->pc;
      prologue_end = prologue_start + 48;	/* We're in the boondocks: 
						   allow for 16 pushes, an add, 
						   and "mv fp,sp" */
    }
#if 0
  prologue_end = min (prologue_end, fi->pc);
#endif
  insn_debug (("fipc(%08x) start(%08x) end(%08x)\n",
	       fi->pc, prologue_start, prologue_end));
  prologue_end = min (prologue_end, prologue_start + DEFAULT_SEARCH_LIMIT);
  decode_prologue (prologue_start, prologue_end, &prologue_end, &framesize,
		   fi, fsr);
  return framesize;
}

/* Function: init_extra_frame_info
   This function actually figures out the frame address for a given pc and
   sp.  This is tricky on the m32r because we sometimes don't use an explicit
   frame pointer, and the previous stack pointer isn't necessarily recorded
   on the stack.  The only reliable way to get this info is to
   examine the prologue.  */

void
m32r_init_extra_frame_info (struct frame_info *fi)
{
  int reg;

  if (fi->next)
    fi->pc = FRAME_SAVED_PC (fi->next);

  memset (fi->fsr.regs, '\000', sizeof fi->fsr.regs);

  if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
    {
      /* We need to setup fi->frame here because run_stack_dummy gets it wrong
         by assuming it's always FP.  */
      fi->frame = deprecated_read_register_dummy (fi->pc, fi->frame,
						  SP_REGNUM);
      fi->framesize = 0;
      return;
    }
  else
    {
      fi->using_frame_pointer = 0;
      fi->framesize = m32r_scan_prologue (fi, &fi->fsr);

      if (!fi->next)
	if (fi->using_frame_pointer)
	  {
	    fi->frame = read_register (FP_REGNUM);
	  }
	else
	  fi->frame = read_register (SP_REGNUM);
      else
	/* fi->next means this is not the innermost frame */ if (fi->using_frame_pointer)
	/* we have an FP */
	if (fi->next->fsr.regs[FP_REGNUM] != 0)		/* caller saved our FP */
	  fi->frame = read_memory_integer (fi->next->fsr.regs[FP_REGNUM], 4);
      for (reg = 0; reg < NUM_REGS; reg++)
	if (fi->fsr.regs[reg] != 0)
	  fi->fsr.regs[reg] = fi->frame + fi->framesize - fi->fsr.regs[reg];
    }
}

/* Function: m32r_virtual_frame_pointer
   Return the register that the function uses for a frame pointer, 
   plus any necessary offset to be applied to the register before
   any frame pointer offsets.  */

void
m32r_virtual_frame_pointer (CORE_ADDR pc, long *reg, long *offset)
{
  struct frame_info *fi = deprecated_frame_xmalloc ();
  struct cleanup *old_chain = make_cleanup (xfree, fi);

  /* Set up a dummy frame_info. */
  fi->next = NULL;
  fi->prev = NULL;
  fi->frame = 0;
  fi->pc = pc;

  /* Analyze the prolog and fill in the extra info.  */
  m32r_init_extra_frame_info (fi);

  /* Results will tell us which type of frame it uses.  */
  if (fi->using_frame_pointer)
    {
      *reg = FP_REGNUM;
      *offset = 0;
    }
  else
    {
      *reg = SP_REGNUM;
      *offset = 0;
    }
  do_cleanups (old_chain);
}

/* Function: find_callers_reg
   Find REGNUM on the stack.  Otherwise, it's in an active register.  One thing
   we might want to do here is to check REGNUM against the clobber mask, and
   somehow flag it as invalid if it isn't saved on the stack somewhere.  This
   would provide a graceful failure mode when trying to get the value of
   caller-saves registers for an inner frame.  */

CORE_ADDR
m32r_find_callers_reg (struct frame_info *fi, int regnum)
{
  for (; fi; fi = fi->next)
    if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
      return deprecated_read_register_dummy (fi->pc, fi->frame, regnum);
    else if (fi->fsr.regs[regnum] != 0)
      return read_memory_integer (fi->fsr.regs[regnum],
				  REGISTER_RAW_SIZE (regnum));
  return read_register (regnum);
}

/* Function: frame_chain Given a GDB frame, determine the address of
   the calling function's frame.  This will be used to create a new
   GDB frame struct, and then INIT_EXTRA_FRAME_INFO and
   DEPRECATED_INIT_FRAME_PC will be called for the new frame.  For
   m32r, we save the frame size when we initialize the frame_info.  */

CORE_ADDR
m32r_frame_chain (struct frame_info *fi)
{
  CORE_ADDR fn_start, callers_pc, fp;

  /* is this a dummy frame? */
  if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
    return fi->frame;		/* dummy frame same as caller's frame */

  /* is caller-of-this a dummy frame? */
  callers_pc = FRAME_SAVED_PC (fi);	/* find out who called us: */
  fp = m32r_find_callers_reg (fi, FP_REGNUM);
  if (DEPRECATED_PC_IN_CALL_DUMMY (callers_pc, fp, fp))
    return fp;			/* dummy frame's frame may bear no relation to ours */

  if (find_pc_partial_function (fi->pc, 0, &fn_start, 0))
    if (fn_start == entry_point_address ())
      return 0;			/* in _start fn, don't chain further */
  if (fi->framesize == 0)
    {
      printf_filtered ("cannot determine frame size @@ %s , pc(%s)\n",
		       paddr (fi->frame),
		       paddr (fi->pc));
      return 0;
    }
  insn_debug (("m32rx frame %08x\n", fi->frame + fi->framesize));
  return fi->frame + fi->framesize;
}

/* Function: push_return_address (pc)
   Set up the return address for the inferior function call.
   Necessary for targets that don't actually execute a JSR/BSR instruction 
   (ie. when using an empty CALL_DUMMY) */

CORE_ADDR
m32r_push_return_address (CORE_ADDR pc, CORE_ADDR sp)
{
  write_register (RP_REGNUM, CALL_DUMMY_ADDRESS ());
  return sp;
}


/* Function: pop_frame
   Discard from the stack the innermost frame,
   restoring all saved registers.  */

struct frame_info *
m32r_pop_frame (struct frame_info *frame)
{
  int regnum;

  if (DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
    generic_pop_dummy_frame ();
  else
    {
      for (regnum = 0; regnum < NUM_REGS; regnum++)
	if (frame->fsr.regs[regnum] != 0)
	  write_register (regnum,
			  read_memory_integer (frame->fsr.regs[regnum], 4));

      write_register (PC_REGNUM, FRAME_SAVED_PC (frame));
      write_register (SP_REGNUM, read_register (FP_REGNUM));
      if (read_register (PSW_REGNUM) & 0x80)
	write_register (SPU_REGNUM, read_register (SP_REGNUM));
      else
	write_register (SPI_REGNUM, read_register (SP_REGNUM));
    }
  flush_cached_frames ();
  return NULL;
}

/* Function: frame_saved_pc
   Find the caller of this frame.  We do this by seeing if RP_REGNUM is saved
   in the stack anywhere, otherwise we get it from the registers. */

CORE_ADDR
m32r_frame_saved_pc (struct frame_info *fi)
{
  if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
    return deprecated_read_register_dummy (fi->pc, fi->frame, PC_REGNUM);
  else
    return m32r_find_callers_reg (fi, RP_REGNUM);
}

/* Function: push_arguments
   Setup the function arguments for calling a function in the inferior.

   On the Mitsubishi M32R architecture, there are four registers (R0 to R3)
   which are dedicated for passing function arguments.  Up to the first 
   four arguments (depending on size) may go into these registers.
   The rest go on the stack.

   Arguments that are smaller than 4 bytes will still take up a whole
   register or a whole 32-bit word on the stack, and will be
   right-justified in the register or the stack word.  This includes
   chars, shorts, and small aggregate types.

   Arguments of 8 bytes size are split between two registers, if 
   available.  If only one register is available, the argument will 
   be split between the register and the stack.  Otherwise it is
   passed entirely on the stack.  Aggregate types with sizes between
   4 and 8 bytes are passed entirely on the stack, and are left-justified
   within the double-word (as opposed to aggregates smaller than 4 bytes
   which are right-justified).

   Aggregates of greater than 8 bytes are first copied onto the stack, 
   and then a pointer to the copy is passed in the place of the normal
   argument (either in a register if available, or on the stack).

   Functions that must return an aggregate type can return it in the 
   normal return value registers (R0 and R1) if its size is 8 bytes or
   less.  For larger return values, the caller must allocate space for 
   the callee to copy the return value to.  A pointer to this space is
   passed as an implicit first argument, always in R0. */

CORE_ADDR
m32r_push_arguments (int nargs, struct value **args, CORE_ADDR sp,
		     unsigned char struct_return, CORE_ADDR struct_addr)
{
  int stack_offset, stack_alloc;
  int argreg;
  int argnum;
  struct type *type;
  CORE_ADDR regval;
  char *val;
  char valbuf[4];
  int len;
  int odd_sized_struct;

  /* first force sp to a 4-byte alignment */
  sp = sp & ~3;

  argreg = ARG0_REGNUM;
  /* The "struct return pointer" pseudo-argument goes in R0 */
  if (struct_return)
    write_register (argreg++, struct_addr);

  /* Now make sure there's space on the stack */
  for (argnum = 0, stack_alloc = 0;
       argnum < nargs; argnum++)
    stack_alloc += ((TYPE_LENGTH (VALUE_TYPE (args[argnum])) + 3) & ~3);
  sp -= stack_alloc;		/* make room on stack for args */


  /* Now load as many as possible of the first arguments into
     registers, and push the rest onto the stack.  There are 16 bytes
     in four registers available.  Loop thru args from first to last.  */

  argreg = ARG0_REGNUM;
  for (argnum = 0, stack_offset = 0; argnum < nargs; argnum++)
    {
      type = VALUE_TYPE (args[argnum]);
      len = TYPE_LENGTH (type);
      memset (valbuf, 0, sizeof (valbuf));
      if (len < 4)
	{			/* value gets right-justified in the register or stack word */
	  memcpy (valbuf + (4 - len),
		  (char *) VALUE_CONTENTS (args[argnum]), len);
	  val = valbuf;
	}
      else
	val = (char *) VALUE_CONTENTS (args[argnum]);

      if (len > 4 && (len & 3) != 0)
	odd_sized_struct = 1;	/* such structs go entirely on stack */
      else
	odd_sized_struct = 0;
      while (len > 0)
	{
	  if (argreg > ARGLAST_REGNUM || odd_sized_struct)
	    {			/* must go on the stack */
	      write_memory (sp + stack_offset, val, 4);
	      stack_offset += 4;
	    }
	  /* NOTE WELL!!!!!  This is not an "else if" clause!!!
	     That's because some *&^%$ things get passed on the stack
	     AND in the registers!   */
	  if (argreg <= ARGLAST_REGNUM)
	    {			/* there's room in a register */
	      regval = extract_address (val, REGISTER_RAW_SIZE (argreg));
	      write_register (argreg++, regval);
	    }
	  /* Store the value 4 bytes at a time.  This means that things
	     larger than 4 bytes may go partly in registers and partly
	     on the stack.  */
	  len -= REGISTER_RAW_SIZE (argreg);
	  val += REGISTER_RAW_SIZE (argreg);
	}
    }
  return sp;
}

/* Function: fix_call_dummy 
   If there is real CALL_DUMMY code (eg. on the stack), this function
   has the responsability to insert the address of the actual code that
   is the target of the target function call.  */

void
m32r_fix_call_dummy (char *dummy, CORE_ADDR pc, CORE_ADDR fun, int nargs,
		     struct value **args, struct type *type, int gcc_p)
{
  /* ld24 r8, <(imm24) fun> */
  *(unsigned long *) (dummy) = (fun & 0x00ffffff) | 0xe8000000;
}


/* Function: m32r_write_sp
   Because SP is really a read-only register that mirrors either SPU or SPI,
   we must actually write one of those two as well, depending on PSW. */

void
m32r_write_sp (CORE_ADDR val)
{
  unsigned long psw = read_register (PSW_REGNUM);

  if (psw & 0x80)		/* stack mode: user or interrupt */
    write_register (SPU_REGNUM, val);
  else
    write_register (SPI_REGNUM, val);
  write_register (SP_REGNUM, val);
}

void
_initialize_m32r_tdep (void)
{
  tm_print_insn = print_insn_m32r;
}
@


1.12
log
@2003-01-06  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (deprecated_frame_xmalloc_with_cleanup): Declare.
	* frame.c (deprecated_frame_xmalloc_with_cleanup): New function.
	* arm-tdep.c (arm_frame_chain): Allocate caller_fi using
	deprecated_frame_xmalloc_with_cleanup.
	* m32r-tdep.c (m32r_virtual_frame_pointer): Allocate `fi' using
	deprecated_frame_xmalloc.
	* mcore-tdep.c (analyze_dummy_frame): Ditto for dummy.
	* mn10200-tdep.c (mn10200_frame_chain): Ditto for dummy_frame.
@
text
@d2 3
a4 1
   Copyright 1996, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
@


1.11
log
@2002-12-10  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_INIT_FRAME_PC): Rename INIT_FRAME_PC.
	Change to a function with predicate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.c (get_prev_frame): Update.  Test
	DEPRECATED_INIT_FRAME_PC_P.
	* config/sparc/tm-sparc.h (DEPRECATED_INIT_FRAME_PC): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC): Update.
	* config/mn10200/tm-mn10200.h (DEPRECATED_INIT_FRAME_PC): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	* arm-tdep.c: Update comments.
	* h8300-tdep.c (h8300_gdbarch_init): Explicitly set init_frame_pc.
	* config/m32r/tm-m32r.h (DEPRECATED_INIT_FRAME_PC): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* config/z8k/tm-z8k.h (INIT_FRAME_PC_FIRST): Delete macro.
	(DEPRECATED_INIT_FRAME_PC): Rename INIT_FRAME_PC.
@
text
@d429 2
a430 1
  struct frame_info fi;
d433 4
a436 4
  fi.next = NULL;
  fi.prev = NULL;
  fi.frame = 0;
  fi.pc = pc;
d439 1
a439 2
  m32r_init_extra_frame_info (&fi);

d442 1
a442 1
  if (fi.using_frame_pointer)
d452 1
@


1.10
log
@2002-12-01  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (DEPRECATED_PC_IN_CALL_DUMMY): Rename
	PC_IN_CALL_DUMMY.  Change to predicate.  Always allow call.
	* gdbarch.h, gdbarch.c: Re-generate.
	* config/sparc/tm-sparc.h, config/sparc/tm-sp64.h: Update.
	* config/mn10200/tm-mn10200.h, config/h8500/tm-h8500.h: Update.
	* config/pa/tm-hppa.h, frame.h: Update.
	* x86-64-tdep.c, vax-tdep.c, sparc-tdep.c: Update.
	* s390-tdep.c, ns32k-tdep.c, mn10300-tdep.c: Update.
	* m68k-tdep.c, i386-tdep.c, frv-tdep.c: Update.
	* cris-tdep.c, alpha-tdep.c: Update.
	* frame.c (set_unwind_by_pc, create_new_frame): Use either
	DEPRECATED_PC_IN_CALL_DUMMY or pc_in_dummy_frame.
	(get_prev_frame): Ditto.

Index: doc/ChangeLog
2002-12-01  Andrew Cagney  <ac131313@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	PC_IN_CALL_DUMMY.
@
text
@d473 5
a477 5
/* Function: frame_chain
   Given a GDB frame, determine the address of the calling function's frame.
   This will be used to create a new GDB frame struct, and then
   INIT_EXTRA_FRAME_INFO and INIT_FRAME_PC will be called for the new frame.
   For m32r, we save the frame size when we initialize the frame_info.  */
@


1.9
log
@2002-09-17  Andrew Cagney  <cagney@@redhat.com>

	* h8300-tdep.c (h8300_frame_chain):
	(h8300_frame_saved_pc):

	* blockframe.c (deprecated_read_register_dummy): Rename
	generic_read_register_dummy.
	* frame.c (frame_unwind_signed_register): New function.
	(frame_unwind_unsigned_register): New function.
	* frame.h (frame_unwind_signed_register): Declare.
	(frame_unwind_unsigned_register): Declare.
	(deprecated_read_register_dummy): Rename
	generic_read_register_dummy.

	* xstormy16-tdep.c (xstormy16_frame_saved_pc): Update.
	* rs6000-tdep.c (rs6000_frame_saved_pc): Update.
	* s390-tdep.c (s390_frame_saved_pc_nofix): Update.
	(s390_frame_chain): Update.
	* v850-tdep.c (v850_find_callers_reg): Update.
	(v850_frame_saved_pc): Update.
	* m32r-tdep.c (m32r_init_extra_frame_info): Update.
	(m32r_find_callers_reg): Update.
	(m32r_frame_saved_pc): Update.
	* sh-tdep.c (sh_find_callers_reg): Update.
	(sh64_get_saved_pr): Update.
	(sh_init_extra_frame_info): Update.
	(sh_init_extra_frame_info): Update.
	(sh64_init_extra_frame_info): Update.
	(sh64_init_extra_frame_info): Update.
	* mcore-tdep.c (mcore_find_callers_reg): Update.
	(mcore_frame_saved_pc): Update.
	(mcore_init_extra_frame_info): Update.
	* i386-tdep.c (i386_frame_saved_pc): Update.
	* ia64-tdep.c (ia64_frame_saved_pc): Update.
	(ia64_init_extra_frame_info): Update.
	(ia64_init_extra_frame_info): Update.
	* d10v-tdep.c (d10v_frame_saved_pc): Update.
	* cris-tdep.c (cris_init_extra_frame_info): Update.
	* avr-tdep.c (avr_frame_chain): Update.
	(avr_init_extra_frame_info): Update.
	(avr_frame_saved_pc): Update.
	* arm-tdep.c (arm_find_callers_reg): Update.
	(arm_init_extra_frame_info): Update.
	(arm_frame_saved_pc): Update.
@
text
@d389 1
a389 1
  if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
d465 1
a465 1
    if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
d485 1
a485 1
  if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
d491 1
a491 1
  if (PC_IN_CALL_DUMMY (callers_pc, fp, fp))
d530 1
a530 1
  if (PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
d557 1
a557 1
  if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
@


1.9.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d1 2
a2 4
/* Target-dependent code for Renesas M32R, for GDB.

   Copyright 1996, 1998, 1999, 2000, 2001, 2002, 2003 Free Software
   Foundation, Inc.
d23 5
a27 5
#include "frame-unwind.h"
#include "frame-base.h"
#include "symtab.h"
#include "gdbtypes.h"
#include "gdbcmd.h"
a28 3
#include "gdb_string.h"
#include "value.h"
#include "inferior.h"
a29 3
#include "objfiles.h"
#include "language.h"
#include "arch-utils.h"
a30 4
#include "trad-frame.h"
#include "dis-asm.h"

#include "gdb_assert.h"
d32 4
a35 42
struct gdbarch_tdep
{
  /* gdbarch target dependent data here. Currently unused for M32R. */
};

/* m32r register names. */

enum
{
  R0_REGNUM = 0,
  R3_REGNUM = 3,
  M32R_FP_REGNUM = 13,
  LR_REGNUM = 14,
  M32R_SP_REGNUM = 15,
  PSW_REGNUM = 16,
  M32R_PC_REGNUM = 21,
  /* m32r calling convention. */
  ARG1_REGNUM = R0_REGNUM,
  ARGN_REGNUM = R3_REGNUM,
  RET1_REGNUM = R0_REGNUM,
};

/* Local functions */

extern void _initialize_m32r_tdep (void);

static CORE_ADDR
m32r_frame_align (struct gdbarch *gdbarch, CORE_ADDR sp)
{
  /* Align to the size of an instruction (so that they can safely be
     pushed onto the stack.  */
  return sp & ~3;
}

/* Should we use EXTRACT_STRUCT_VALUE_ADDRESS instead of
   EXTRACT_RETURN_VALUE?  GCC_P is true if compiled with gcc
   and TYPE is the type (which is known to be struct, union or array).

   The m32r returns anything less than 8 bytes in size in
   registers. */

static int
d41 4
d46 3
a48 61
/* BREAKPOINT */
#define M32R_BE_BREAKPOINT32 {0x10, 0xf1, 0x70, 0x00}
#define M32R_LE_BREAKPOINT32 {0xf1, 0x10, 0x00, 0x70}
#define M32R_BE_BREAKPOINT16 {0x10, 0xf1}
#define M32R_LE_BREAKPOINT16 {0xf1, 0x10}

static int
m32r_memory_insert_breakpoint (CORE_ADDR addr, char *contents_cache)
{
  int val;
  unsigned char *bp;
  int bplen;

  bplen = (addr & 3) ? 2 : 4;

  /* Save the memory contents.  */
  val = target_read_memory (addr, contents_cache, bplen);
  if (val != 0)
    return val;			/* return error */

  /* Determine appropriate breakpoint contents and size for this address.  */
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
    {
      if (((addr & 3) == 0)
	  && ((contents_cache[0] & 0x80) || (contents_cache[2] & 0x80)))
	{
	  static unsigned char insn[] = M32R_BE_BREAKPOINT32;
	  bp = insn;
	  bplen = sizeof (insn);
	}
      else
	{
	  static unsigned char insn[] = M32R_BE_BREAKPOINT16;
	  bp = insn;
	  bplen = sizeof (insn);
	}
    }
  else
    {				/* little-endian */
      if (((addr & 3) == 0)
	  && ((contents_cache[1] & 0x80) || (contents_cache[3] & 0x80)))
	{
	  static unsigned char insn[] = M32R_LE_BREAKPOINT32;
	  bp = insn;
	  bplen = sizeof (insn);
	}
      else
	{
	  static unsigned char insn[] = M32R_LE_BREAKPOINT16;
	  bp = insn;
	  bplen = sizeof (insn);
	}
    }

  /* Write the breakpoint.  */
  val = target_write_memory (addr, (char *) bp, bplen);
  return val;
}

static int
m32r_memory_remove_breakpoint (CORE_ADDR addr, char *contents_cache)
d50 1
a50 37
  int val;
  int bplen;

  /* Determine appropriate breakpoint contents and size for this address.  */
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
    {
      if (((addr & 3) == 0)
	  && ((contents_cache[0] & 0x80) || (contents_cache[2] & 0x80)))
	{
	  static unsigned char insn[] = M32R_BE_BREAKPOINT32;
	  bplen = sizeof (insn);
	}
      else
	{
	  static unsigned char insn[] = M32R_BE_BREAKPOINT16;
	  bplen = sizeof (insn);
	}
    }
  else
    {
      /* little-endian */
      if (((addr & 3) == 0)
	  && ((contents_cache[1] & 0x80) || (contents_cache[3] & 0x80)))
	{
	  static unsigned char insn[] = M32R_BE_BREAKPOINT32;
	  bplen = sizeof (insn);
	}
      else
	{
	  static unsigned char insn[] = M32R_BE_BREAKPOINT16;
	  bplen = sizeof (insn);
	}
    }

  /* Write contents.  */
  val = target_write_memory (addr, contents_cache, bplen);
  return val;
d53 4
a56 85
static const unsigned char *
m32r_breakpoint_from_pc (CORE_ADDR *pcptr, int *lenptr)
{
  unsigned char *bp;

  /* Determine appropriate breakpoint.  */
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
    {
      if ((*pcptr & 3) == 0)
	{
	  static unsigned char insn[] = M32R_BE_BREAKPOINT32;
	  bp = insn;
	  *lenptr = sizeof (insn);
	}
      else
	{
	  static unsigned char insn[] = M32R_BE_BREAKPOINT16;
	  bp = insn;
	  *lenptr = sizeof (insn);
	}
    }
  else
    {
      if ((*pcptr & 3) == 0)
	{
	  static unsigned char insn[] = M32R_LE_BREAKPOINT32;
	  bp = insn;
	  *lenptr = sizeof (insn);
	}
      else
	{
	  static unsigned char insn[] = M32R_LE_BREAKPOINT16;
	  bp = insn;
	  *lenptr = sizeof (insn);
	}
    }

  return bp;
}


char *m32r_register_names[] = {
  "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
  "r8", "r9", "r10", "r11", "r12", "fp", "lr", "sp",
  "psw", "cbr", "spi", "spu", "bpc", "pc", "accl", "acch",
  "evb"
};

static int
m32r_num_regs (void)
{
  return (sizeof (m32r_register_names) / sizeof (m32r_register_names[0]));
}

static const char *
m32r_register_name (int reg_nr)
{
  if (reg_nr < 0)
    return NULL;
  if (reg_nr >= m32r_num_regs ())
    return NULL;
  return m32r_register_names[reg_nr];
}


/* Return the GDB type object for the "standard" data type
   of data in register N.  */

static struct type *
m32r_register_type (struct gdbarch *gdbarch, int reg_nr)
{
  if (reg_nr == M32R_PC_REGNUM)
    return builtin_type_void_func_ptr;
  else if (reg_nr == M32R_SP_REGNUM || reg_nr == M32R_FP_REGNUM)
    return builtin_type_void_data_ptr;
  else
    return builtin_type_int32;
}


/* Write into appropriate registers a function return value
   of type TYPE, given in virtual format.  

   Things always get returned in RET1_REGNUM, RET2_REGNUM. */

d58 1
a58 2
m32r_store_return_value (struct type *type, struct regcache *regcache,
			 const void *valbuf)
d60 10
a69 2
  CORE_ADDR regval;
  int len = TYPE_LENGTH (type);
d71 1
a71 9
  regval = extract_unsigned_integer (valbuf, len > 4 ? 4 : len);
  regcache_cooked_write_unsigned (regcache, RET1_REGNUM, regval);

  if (len > 4)
    {
      regval = extract_unsigned_integer ((char *) valbuf + 4, len - 4);
      regcache_cooked_write_unsigned (regcache, RET1_REGNUM + 1, regval);
    }
}
d73 34
a106 15
/* Extract from an array REGBUF containing the (raw) register state
   the address in which a function should return its structure value,
   as a CORE_ADDR (or an expression that can be used as one).  */

static CORE_ADDR
m32r_extract_struct_value_address (struct regcache *regcache)
{
  ULONGEST addr;
  regcache_cooked_read_unsigned (regcache, ARG1_REGNUM, &addr);
  return addr;
}


/* This is required by skip_prologue. The results of decoding a prologue
   should be cached because this thrashing is getting nuts.  */
d109 3
a111 2
decode_prologue (CORE_ADDR start_pc, CORE_ADDR scan_limit,
		 CORE_ADDR *pl_endptr)
d121 1
d124 1
d128 1
d130 1
d135 1
a135 2
	{
	  /* Clear the parallel execution bit from 16 bit instruction */
d137 3
a139 4
	    {
	      /* The last instruction was a branch, usually terminates
	         the series, but if this is a parallel instruction,
	         it may be a stack framing instruction */
d142 2
a143 2
		  /* nope, we are really done */
		  break;
d146 1
a146 2
	  /* decode this instruction further */
	  insn &= 0x7fff;
d154 1
d161 2
a162 2
		  framesize +=
		    -((short) read_memory_unsigned_integer (current_pc, 2));
d166 4
a169 5
		  if (((insn >> 8) == 0xe4)	/* ld24 r4, xxxxxx; sub sp, r4 */
		      && read_memory_unsigned_integer (current_pc + 2,
						       2) == 0x0f24)
		    /* subtract 24 bit sign-extended negative-offset */
		    {
d171 1
d188 5
d194 7
d202 2
d229 3
d235 1
a235 2
      /* Nop looks like a branch, continue explicitly */
      if (insn == 0x7000)
d237 1
d242 3
a244 1
      if ((op1 == 0x7000) || (op1 == 0xb000) || (op1 == 0xf000))
d247 1
d257 1
d269 1
d276 2
d280 1
d292 3
a301 2
#define DEFAULT_SEARCH_LIMIT 44

d316 2
d325 2
d332 1
a332 1
  decode_prologue (pc, func_end, &sal.end);
d336 9
d346 35
a380 1
struct m32r_unwind_cache
d382 17
a398 46
  /* The previous frame's inner most stack address.  Used as this
     frame ID's stack_addr.  */
  CORE_ADDR prev_sp;
  /* The frame's base, optionally used by the high-level debug info.  */
  CORE_ADDR base;
  int size;
  /* How far the SP and r13 (FP) have been offset from the start of
     the stack frame (as defined by the previous frame's stack
     pointer).  */
  LONGEST sp_offset;
  LONGEST r13_offset;
  int uses_frame;
  /* Table indicating the location of each and every register.  */
  struct trad_frame_saved_reg *saved_regs;
};

/* Put here the code to store, into fi->saved_regs, the addresses of
   the saved registers of frame described by FRAME_INFO.  This
   includes special registers such as pc and fp saved in special ways
   in the stack frame.  sp is even more special: the address we return
   for it IS the sp for the next frame. */

static struct m32r_unwind_cache *
m32r_frame_unwind_cache (struct frame_info *next_frame,
			 void **this_prologue_cache)
{
  CORE_ADDR pc;
  ULONGEST prev_sp;
  ULONGEST this_base;
  unsigned long op;
  int i;
  struct m32r_unwind_cache *info;

  if ((*this_prologue_cache))
    return (*this_prologue_cache);

  info = FRAME_OBSTACK_ZALLOC (struct m32r_unwind_cache);
  (*this_prologue_cache) = info;
  info->saved_regs = trad_frame_alloc_saved_regs (next_frame);

  info->size = 0;
  info->sp_offset = 0;

  info->uses_frame = 0;
  for (pc = frame_func_unwind (next_frame);
       pc > 0 && pc < frame_pc_unwind (next_frame); pc += 2)
d400 2
a401 27
      if ((pc & 2) == 0)
	{
	  op = get_frame_memory_unsigned (next_frame, pc, 4);
	  if ((op & 0x80000000) == 0x80000000)
	    {
	      /* 32-bit instruction */
	      if ((op & 0xffff0000) == 0x8faf0000)
		{
		  /* add3 sp,sp,xxxx */
		  short n = op & 0xffff;
		  info->sp_offset += n;
		}
	      else if (((op >> 8) == 0xe4)	/* ld24 r4, xxxxxx; sub sp, r4 */
		       && get_frame_memory_unsigned (next_frame, pc + 4,
						     2) == 0x0f24)
		{
		  unsigned long n = op & 0xffffff;
		  info->sp_offset += n;
		  pc += 2;
		}
	      else
		break;

	      pc += 2;
	      continue;
	    }
	}
d403 7
a409 24
      /* 16-bit instructions */
      op = get_frame_memory_unsigned (next_frame, pc, 2) & 0x7fff;
      if ((op & 0xf0ff) == 0x207f)
	{
	  /* st rn, @@-sp */
	  int regno = ((op >> 8) & 0xf);
	  info->sp_offset -= 4;
	  info->saved_regs[regno].addr = info->sp_offset;
	}
      else if ((op & 0xff00) == 0x4f00)
	{
	  /* addi sp, xx */
	  int n = (char) (op & 0xff);
	  info->sp_offset += n;
	}
      else if (op == 0x1d8f)
	{
	  /* mv fp, sp */
	  info->uses_frame = 1;
	  info->r13_offset = info->sp_offset;
	}
      else if (op == 0x7000)
	/* nop */
	continue;
d411 7
a417 1
	break;
d419 20
a439 1
  info->size = -info->sp_offset;
d441 5
a445 11
  /* Compute the previous frame's stack pointer (which is also the
     frame's ID's stack address), and this frame's base pointer.  */
  if (info->uses_frame)
    {
      /* The SP was moved to the FP.  This indicates that a new frame
         was created.  Get THIS frame's FP value by unwinding it from
         the next frame.  */
      this_base = frame_unwind_register_unsigned (next_frame, M32R_FP_REGNUM);
      /* The FP points at the last saved register.  Adjust the FP back
         to before the first saved register giving the SP.  */
      prev_sp = this_base + info->size;
d449 69
a517 40
      /* Assume that the FP is this frame's SP but with that pushed
         stack space added back.  */
      this_base = frame_unwind_register_unsigned (next_frame, M32R_SP_REGNUM);
      prev_sp = this_base + info->size;
    }

  /* Convert that SP/BASE into real addresses.  */
  info->prev_sp = prev_sp;
  info->base = this_base;

  /* Adjust all the saved registers so that they contain addresses and
     not offsets.  */
  for (i = 0; i < NUM_REGS - 1; i++)
    if (trad_frame_addr_p (info->saved_regs, i))
      info->saved_regs[i].addr = (info->prev_sp + info->saved_regs[i].addr);

  /* The call instruction moves the caller's PC in the callee's LR.
     Since this is an unwind, do the reverse.  Copy the location of LR
     into PC (the address / regnum) so that a request for PC will be
     converted into a request for the LR.  */
  info->saved_regs[M32R_PC_REGNUM] = info->saved_regs[LR_REGNUM];

  /* The previous frame's SP needed to be computed.  Save the computed
     value.  */
  trad_frame_set_value (info->saved_regs, M32R_SP_REGNUM, prev_sp);

  return info;
}

static CORE_ADDR
m32r_read_pc (ptid_t ptid)
{
  ptid_t save_ptid;
  ULONGEST pc;

  save_ptid = inferior_ptid;
  inferior_ptid = ptid;
  regcache_cooked_read_unsigned (current_regcache, M32R_PC_REGNUM, &pc);
  inferior_ptid = save_ptid;
  return pc;
d520 7
a526 2
static void
m32r_write_pc (CORE_ADDR val, ptid_t ptid)
d528 1
a528 1
  ptid_t save_ptid;
d530 18
a547 4
  save_ptid = inferior_ptid;
  inferior_ptid = ptid;
  write_register (M32R_PC_REGNUM, val);
  inferior_ptid = save_ptid;
d550 6
a555 2
static CORE_ADDR
m32r_unwind_sp (struct gdbarch *gdbarch, struct frame_info *next_frame)
d557 4
a560 1
  return frame_unwind_register_unsigned (next_frame, M32R_SP_REGNUM);
d563 2
d566 31
a596 5
static CORE_ADDR
m32r_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
		      struct regcache *regcache, CORE_ADDR bp_addr, int nargs,
		      struct value **args, CORE_ADDR sp, int struct_return,
		      CORE_ADDR struct_addr)
d599 1
a599 1
  int argreg = ARG1_REGNUM;
a601 1
  enum type_code typecode;
d604 1
a604 1
  char valbuf[MAX_REGISTER_SIZE];
d611 2
a612 7
  /* Set the return address.  For the m32r, the return breakpoint is
     always at BP_ADDR.  */
  regcache_cooked_write_unsigned (regcache, LR_REGNUM, bp_addr);

  /* If STRUCT_RETURN is true, then the struct return address (in
     STRUCT_ADDR) will consume the first argument-passing register.
     Both adjust the register count and store that value.  */
d614 1
a614 4
    {
      regcache_cooked_write_unsigned (regcache, argreg, struct_addr);
      argreg++;
    }
d617 2
a618 1
  for (argnum = 0, stack_alloc = 0; argnum < nargs; argnum++)
d622 6
a630 1
      typecode = TYPE_CODE (type);
a631 1

d633 3
a635 14

      /* Passes structures that do not fit in 2 registers by reference.  */
      if (len > 8
	  && (typecode == TYPE_CODE_STRUCT || typecode == TYPE_CODE_UNION))
	{
	  store_unsigned_integer (valbuf, 4, VALUE_ADDRESS (args[argnum]));
	  typecode = TYPE_CODE_PTR;
	  len = 4;
	  val = valbuf;
	}
      else if (len < 4)
	{
	  /* value gets right-justified in the register or stack word */
	  memcpy (valbuf + (register_size (gdbarch, argreg) - len),
d642 4
d648 2
a649 3
	  if (argreg > ARGN_REGNUM)
	    {
	      /* must go on the stack */
d653 7
a659 7
	  else if (argreg <= ARGN_REGNUM)
	    {
	      /* there's room in a register */
	      regval =
		extract_unsigned_integer (val,
					  register_size (gdbarch, argreg));
	      regcache_cooked_write_unsigned (regcache, argreg++, regval);
a660 1

d664 2
a665 2
	  len -= register_size (gdbarch, argreg);
	  val += register_size (gdbarch, argreg);
a667 4

  /* Finally, update the SP register.  */
  regcache_cooked_write_unsigned (regcache, M32R_SP_REGNUM, sp);

d671 4
d676 3
a678 6
/* Given a return value in `regbuf' with a type `valtype', 
   extract and copy its value into `valbuf'.  */

static void
m32r_extract_return_value (struct type *type, struct regcache *regcache,
			   void *dst)
d680 2
a681 16
  bfd_byte *valbuf = dst;
  int len = TYPE_LENGTH (type);
  ULONGEST tmp;

  /* By using store_unsigned_integer we avoid having to do
     anything special for small big-endian values.  */
  regcache_cooked_read_unsigned (regcache, RET1_REGNUM, &tmp);
  store_unsigned_integer (valbuf, (len > 4 ? len - 4 : len), tmp);

  /* Ignore return values more than 8 bytes in size because the m32r
     returns anything more than 8 bytes in the stack. */
  if (len > 4)
    {
      regcache_cooked_read_unsigned (regcache, RET1_REGNUM + 1, &tmp);
      store_unsigned_integer (valbuf + len - 4, 4, tmp);
    }
d685 3
a687 5
static CORE_ADDR
m32r_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  return frame_unwind_register_unsigned (next_frame, M32R_PC_REGNUM);
}
d689 2
a690 6
/* Given a GDB frame, determine the address of the calling function's
   frame.  This will be used to create a new GDB frame struct.  */

static void
m32r_frame_this_id (struct frame_info *next_frame,
		    void **this_prologue_cache, struct frame_id *this_id)
d692 1
a692 32
  struct m32r_unwind_cache *info
    = m32r_frame_unwind_cache (next_frame, this_prologue_cache);
  CORE_ADDR base;
  CORE_ADDR func;
  struct minimal_symbol *msym_stack;
  struct frame_id id;

  /* The FUNC is easy.  */
  func = frame_func_unwind (next_frame);

  /* Check if the stack is empty.  */
  msym_stack = lookup_minimal_symbol ("_stack", NULL, NULL);
  if (msym_stack && info->base == SYMBOL_VALUE_ADDRESS (msym_stack))
    return;

  /* Hopefully the prologue analysis either correctly determined the
     frame's base (which is the SP from the previous frame), or set
     that base to "NULL".  */
  base = info->prev_sp;
  if (base == 0)
    return;

  id = frame_id_build (base, func);

  /* Check that we're not going round in circles with the same frame
     ID (but avoid applying the test to sentinel frames which do go
     round in circles).  Can't use frame_id_eq() as that doesn't yet
     compare the frame's PC value.  */
  if (frame_relative_level (next_frame) >= 0
      && get_frame_type (next_frame) != DUMMY_FRAME
      && frame_id_eq (get_frame_id (next_frame), id))
    return;
d694 5
a698 119
  (*this_id) = id;
}

static void
m32r_frame_prev_register (struct frame_info *next_frame,
			  void **this_prologue_cache,
			  int regnum, int *optimizedp,
			  enum lval_type *lvalp, CORE_ADDR *addrp,
			  int *realnump, void *bufferp)
{
  struct m32r_unwind_cache *info
    = m32r_frame_unwind_cache (next_frame, this_prologue_cache);
  trad_frame_prev_register (next_frame, info->saved_regs, regnum,
			    optimizedp, lvalp, addrp, realnump, bufferp);
}

static const struct frame_unwind m32r_frame_unwind = {
  NORMAL_FRAME,
  m32r_frame_this_id,
  m32r_frame_prev_register
};

static const struct frame_unwind *
m32r_frame_sniffer (struct frame_info *next_frame)
{
  return &m32r_frame_unwind;
}

static CORE_ADDR
m32r_frame_base_address (struct frame_info *next_frame, void **this_cache)
{
  struct m32r_unwind_cache *info
    = m32r_frame_unwind_cache (next_frame, this_cache);
  return info->base;
}

static const struct frame_base m32r_frame_base = {
  &m32r_frame_unwind,
  m32r_frame_base_address,
  m32r_frame_base_address,
  m32r_frame_base_address
};

/* Assuming NEXT_FRAME->prev is a dummy, return the frame ID of that
   dummy frame.  The frame ID's base needs to match the TOS value
   saved by save_dummy_frame_tos(), and the PC match the dummy frame's
   breakpoint.  */

static struct frame_id
m32r_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  return frame_id_build (m32r_unwind_sp (gdbarch, next_frame),
			 frame_pc_unwind (next_frame));
}


static gdbarch_init_ftype m32r_gdbarch_init;

static struct gdbarch *
m32r_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
{
  struct gdbarch *gdbarch;
  struct gdbarch_tdep *tdep;

  /* If there is already a candidate, use it.  */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;

  /* Allocate space for the new architecture.  */
  tdep = XMALLOC (struct gdbarch_tdep);
  gdbarch = gdbarch_alloc (&info, tdep);

  set_gdbarch_read_pc (gdbarch, m32r_read_pc);
  set_gdbarch_write_pc (gdbarch, m32r_write_pc);
  set_gdbarch_unwind_sp (gdbarch, m32r_unwind_sp);

  set_gdbarch_num_regs (gdbarch, m32r_num_regs ());
  set_gdbarch_sp_regnum (gdbarch, M32R_SP_REGNUM);
  set_gdbarch_register_name (gdbarch, m32r_register_name);
  set_gdbarch_register_type (gdbarch, m32r_register_type);

  set_gdbarch_extract_return_value (gdbarch, m32r_extract_return_value);
  set_gdbarch_push_dummy_call (gdbarch, m32r_push_dummy_call);
  set_gdbarch_store_return_value (gdbarch, m32r_store_return_value);
  set_gdbarch_extract_struct_value_address (gdbarch,
					    m32r_extract_struct_value_address);
  set_gdbarch_use_struct_convention (gdbarch, m32r_use_struct_convention);

  set_gdbarch_skip_prologue (gdbarch, m32r_skip_prologue);
  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);
  set_gdbarch_decr_pc_after_break (gdbarch, 0);
  set_gdbarch_function_start_offset (gdbarch, 0);
  set_gdbarch_breakpoint_from_pc (gdbarch, m32r_breakpoint_from_pc);
  set_gdbarch_memory_insert_breakpoint (gdbarch,
					m32r_memory_insert_breakpoint);
  set_gdbarch_memory_remove_breakpoint (gdbarch,
					m32r_memory_remove_breakpoint);

  set_gdbarch_frame_args_skip (gdbarch, 0);
  set_gdbarch_frameless_function_invocation (gdbarch,
					     frameless_look_for_prologue);

  set_gdbarch_frame_align (gdbarch, m32r_frame_align);

  frame_unwind_append_sniffer (gdbarch, m32r_frame_sniffer);
  frame_base_set_default (gdbarch, &m32r_frame_base);

  /* Methods for saving / extracting a dummy frame's ID.  The ID's
     stack address must match the SP value returned by
     PUSH_DUMMY_CALL, and saved by generic_save_dummy_frame_tos.  */
  set_gdbarch_unwind_dummy_id (gdbarch, m32r_unwind_dummy_id);

  /* Return the unwound PC value.  */
  set_gdbarch_unwind_pc (gdbarch, m32r_unwind_pc);

  set_gdbarch_print_insn (gdbarch, print_insn_m32r);

  return gdbarch;
d704 1
a704 1
  register_gdbarch_init (bfd_arch_m32r, m32r_gdbarch_init);
@


1.9.4.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d78 3
a80 3
/* Should we use DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS instead of
   EXTRACT_RETURN_VALUE?  GCC_P is true if compiled with gcc and TYPE
   is the type (which is known to be struct, union or array).
d942 2
a943 1
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, m32r_extract_struct_value_address);
d948 2
@


1.9.2.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d389 1
a389 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
d465 1
a465 1
    if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
d473 5
a477 5
/* Function: frame_chain Given a GDB frame, determine the address of
   the calling function's frame.  This will be used to create a new
   GDB frame struct, and then INIT_EXTRA_FRAME_INFO and
   DEPRECATED_INIT_FRAME_PC will be called for the new frame.  For
   m32r, we save the frame size when we initialize the frame_info.  */
d485 1
a485 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
d491 1
a491 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (callers_pc, fp, fp))
d530 1
a530 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
d557 1
a557 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
@


1.9.2.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d1 705
a705 708
// OBSOLETE /* Target-dependent code for the Mitsubishi m32r for GDB, the GNU debugger.
// OBSOLETE 
// OBSOLETE    Copyright 1996, 1998, 1999, 2000, 2001, 2003 Free Software
// OBSOLETE    Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "frame.h"
// OBSOLETE #include "inferior.h"
// OBSOLETE #include "target.h"
// OBSOLETE #include "value.h"
// OBSOLETE #include "bfd.h"
// OBSOLETE #include "gdb_string.h"
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include "symfile.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE 
// OBSOLETE /* Function: m32r_use_struct_convention
// OBSOLETE    Return nonzero if call_function should allocate stack space for a
// OBSOLETE    struct return? */
// OBSOLETE int
// OBSOLETE m32r_use_struct_convention (int gcc_p, struct type *type)
// OBSOLETE {
// OBSOLETE   return (TYPE_LENGTH (type) > 8);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: frame_find_saved_regs
// OBSOLETE    Return the frame_saved_regs structure for the frame.
// OBSOLETE    Doesn't really work for dummy frames, but it does pass back
// OBSOLETE    an empty frame_saved_regs, so I guess that's better than total failure */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE m32r_frame_find_saved_regs (struct frame_info *fi,
// OBSOLETE 			    struct frame_saved_regs *regaddr)
// OBSOLETE {
// OBSOLETE   memcpy (regaddr, &fi->fsr, sizeof (struct frame_saved_regs));
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Turn this on if you want to see just how much instruction decoding
// OBSOLETE    if being done, its quite a lot
// OBSOLETE  */
// OBSOLETE #if 0
// OBSOLETE static void
// OBSOLETE dump_insn (char *commnt, CORE_ADDR pc, int insn)
// OBSOLETE {
// OBSOLETE   printf_filtered ("  %s %08x %08x ",
// OBSOLETE 		   commnt, (unsigned int) pc, (unsigned int) insn);
// OBSOLETE   TARGET_PRINT_INSN (pc, &tm_print_insn_info);
// OBSOLETE   printf_filtered ("\n");
// OBSOLETE }
// OBSOLETE #define insn_debug(args) { printf_filtered args; }
// OBSOLETE #else
// OBSOLETE #define dump_insn(a,b,c) {}
// OBSOLETE #define insn_debug(args) {}
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE #define DEFAULT_SEARCH_LIMIT 44
// OBSOLETE 
// OBSOLETE /* Function: scan_prologue
// OBSOLETE    This function decodes the target function prologue to determine
// OBSOLETE    1) the size of the stack frame, and 2) which registers are saved on it.
// OBSOLETE    It saves the offsets of saved regs in the frame_saved_regs argument,
// OBSOLETE    and returns the frame size.  */
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE    The sequence it currently generates is:
// OBSOLETE 
// OBSOLETE    if (varargs function) { ddi sp,#n }
// OBSOLETE    push registers
// OBSOLETE    if (additional stack <= 256) {       addi sp,#-stack }
// OBSOLETE    else if (additional stack < 65k) { add3 sp,sp,#-stack
// OBSOLETE 
// OBSOLETE    } else if (additional stack) {
// OBSOLETE    seth sp,#(stack & 0xffff0000)
// OBSOLETE    or3 sp,sp,#(stack & 0x0000ffff)
// OBSOLETE    sub sp,r4
// OBSOLETE    }
// OBSOLETE    if (frame pointer) {
// OBSOLETE    mv sp,fp
// OBSOLETE    }
// OBSOLETE 
// OBSOLETE    These instructions are scheduled like everything else, so you should stop at
// OBSOLETE    the first branch instruction.
// OBSOLETE 
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE /* This is required by skip prologue and by m32r_init_extra_frame_info. 
// OBSOLETE    The results of decoding a prologue should be cached because this
// OBSOLETE    thrashing is getting nuts.
// OBSOLETE    I am thinking of making a container class with two indexes, name and
// OBSOLETE    address. It may be better to extend the symbol table.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE decode_prologue (CORE_ADDR start_pc, CORE_ADDR scan_limit, CORE_ADDR *pl_endptr,	/* var parameter */
// OBSOLETE 		 unsigned long *framelength, struct frame_info *fi,
// OBSOLETE 		 struct frame_saved_regs *fsr)
// OBSOLETE {
// OBSOLETE   unsigned long framesize;
// OBSOLETE   int insn;
// OBSOLETE   int op1;
// OBSOLETE   int maybe_one_more = 0;
// OBSOLETE   CORE_ADDR after_prologue = 0;
// OBSOLETE   CORE_ADDR after_stack_adjust = 0;
// OBSOLETE   CORE_ADDR current_pc;
// OBSOLETE 
// OBSOLETE 
// OBSOLETE   framesize = 0;
// OBSOLETE   after_prologue = 0;
// OBSOLETE   insn_debug (("rd prolog l(%d)\n", scan_limit - current_pc));
// OBSOLETE 
// OBSOLETE   for (current_pc = start_pc; current_pc < scan_limit; current_pc += 2)
// OBSOLETE     {
// OBSOLETE 
// OBSOLETE       insn = read_memory_unsigned_integer (current_pc, 2);
// OBSOLETE       dump_insn ("insn-1", current_pc, insn);	/* MTZ */
// OBSOLETE 
// OBSOLETE       /* If this is a 32 bit instruction, we dont want to examine its
// OBSOLETE          immediate data as though it were an instruction */
// OBSOLETE       if (current_pc & 0x02)
// OBSOLETE 	{			/* Clear the parallel execution bit from 16 bit instruction */
// OBSOLETE 	  if (maybe_one_more)
// OBSOLETE 	    {			/* The last instruction was a branch, usually terminates
// OBSOLETE 				   the series, but if this is a parallel instruction,
// OBSOLETE 				   it may be a stack framing instruction */
// OBSOLETE 	      if (!(insn & 0x8000))
// OBSOLETE 		{
// OBSOLETE 		  insn_debug (("Really done"));
// OBSOLETE 		  break;	/* nope, we are really done */
// OBSOLETE 		}
// OBSOLETE 	    }
// OBSOLETE 	  insn &= 0x7fff;	/* decode this instruction further */
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  if (maybe_one_more)
// OBSOLETE 	    break;		/* This isnt the one more */
// OBSOLETE 	  if (insn & 0x8000)
// OBSOLETE 	    {
// OBSOLETE 	      insn_debug (("32 bit insn\n"));
// OBSOLETE 	      if (current_pc == scan_limit)
// OBSOLETE 		scan_limit += 2;	/* extend the search */
// OBSOLETE 	      current_pc += 2;	/* skip the immediate data */
// OBSOLETE 	      if (insn == 0x8faf)	/* add3 sp, sp, xxxx */
// OBSOLETE 		/* add 16 bit sign-extended offset */
// OBSOLETE 		{
// OBSOLETE 		  insn_debug (("stack increment\n"));
// OBSOLETE 		  framesize += -((short) read_memory_unsigned_integer (current_pc, 2));
// OBSOLETE 		}
// OBSOLETE 	      else
// OBSOLETE 		{
// OBSOLETE 		  if (((insn >> 8) == 0xe4) &&	/* ld24 r4, xxxxxx; sub sp, r4 */
// OBSOLETE 		  read_memory_unsigned_integer (current_pc + 2, 2) == 0x0f24)
// OBSOLETE 		    {		/* subtract 24 bit sign-extended negative-offset */
// OBSOLETE 		      dump_insn ("insn-2", current_pc + 2, insn);
// OBSOLETE 		      insn = read_memory_unsigned_integer (current_pc - 2, 4);
// OBSOLETE 		      dump_insn ("insn-3(l4)", current_pc - 2, insn);
// OBSOLETE 		      if (insn & 0x00800000)	/* sign extend */
// OBSOLETE 			insn |= 0xff000000;	/* negative */
// OBSOLETE 		      else
// OBSOLETE 			insn &= 0x00ffffff;	/* positive */
// OBSOLETE 		      framesize += insn;
// OBSOLETE 		    }
// OBSOLETE 		}
// OBSOLETE 	      after_prologue = current_pc;
// OBSOLETE 	      continue;
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       op1 = insn & 0xf000;	/* isolate just the first nibble */
// OBSOLETE 
// OBSOLETE       if ((insn & 0xf0ff) == 0x207f)
// OBSOLETE 	{			/* st reg, @@-sp */
// OBSOLETE 	  int regno;
// OBSOLETE 	  insn_debug (("push\n"));
// OBSOLETE #if 0				/* No, PUSH FP is not an indication that we will use a frame pointer. */
// OBSOLETE 	  if (((insn & 0xffff) == 0x2d7f) && fi)
// OBSOLETE 	    fi->using_frame_pointer = 1;
// OBSOLETE #endif
// OBSOLETE 	  framesize += 4;
// OBSOLETE #if 0
// OBSOLETE /* Why should we increase the scan limit, just because we did a push? 
// OBSOLETE    And if there is a reason, surely we would only want to do it if we
// OBSOLETE    had already reached the scan limit... */
// OBSOLETE 	  if (current_pc == scan_limit)
// OBSOLETE 	    scan_limit += 2;
// OBSOLETE #endif
// OBSOLETE 	  regno = ((insn >> 8) & 0xf);
// OBSOLETE 	  if (fsr)		/* save_regs offset */
// OBSOLETE 	    fsr->regs[regno] = framesize;
// OBSOLETE 	  after_prologue = 0;
// OBSOLETE 	  continue;
// OBSOLETE 	}
// OBSOLETE       if ((insn >> 8) == 0x4f)	/* addi sp, xx */
// OBSOLETE 	/* add 8 bit sign-extended offset */
// OBSOLETE 	{
// OBSOLETE 	  int stack_adjust = (char) (insn & 0xff);
// OBSOLETE 
// OBSOLETE 	  /* there are probably two of these stack adjustments:
// OBSOLETE 	     1) A negative one in the prologue, and
// OBSOLETE 	     2) A positive one in the epilogue.
// OBSOLETE 	     We are only interested in the first one.  */
// OBSOLETE 
// OBSOLETE 	  if (stack_adjust < 0)
// OBSOLETE 	    {
// OBSOLETE 	      framesize -= stack_adjust;
// OBSOLETE 	      after_prologue = 0;
// OBSOLETE 	      /* A frameless function may have no "mv fp, sp".
// OBSOLETE 	         In that case, this is the end of the prologue.  */
// OBSOLETE 	      after_stack_adjust = current_pc + 2;
// OBSOLETE 	    }
// OBSOLETE 	  continue;
// OBSOLETE 	}
// OBSOLETE       if (insn == 0x1d8f)
// OBSOLETE 	{			/* mv fp, sp */
// OBSOLETE 	  if (fi)
// OBSOLETE 	    fi->using_frame_pointer = 1;	/* fp is now valid */
// OBSOLETE 	  insn_debug (("done fp found\n"));
// OBSOLETE 	  after_prologue = current_pc + 2;
// OBSOLETE 	  break;		/* end of stack adjustments */
// OBSOLETE 	}
// OBSOLETE       if (insn == 0x7000)	/* Nop looks like a branch, continue explicitly */
// OBSOLETE 	{
// OBSOLETE 	  insn_debug (("nop\n"));
// OBSOLETE 	  after_prologue = current_pc + 2;
// OBSOLETE 	  continue;		/* nop occurs between pushes */
// OBSOLETE 	}
// OBSOLETE       /* End of prolog if any of these are branch instructions */
// OBSOLETE       if ((op1 == 0x7000)
// OBSOLETE 	  || (op1 == 0xb000)
// OBSOLETE 	  || (op1 == 0xf000))
// OBSOLETE 	{
// OBSOLETE 	  after_prologue = current_pc;
// OBSOLETE 	  insn_debug (("Done: branch\n"));
// OBSOLETE 	  maybe_one_more = 1;
// OBSOLETE 	  continue;
// OBSOLETE 	}
// OBSOLETE       /* Some of the branch instructions are mixed with other types */
// OBSOLETE       if (op1 == 0x1000)
// OBSOLETE 	{
// OBSOLETE 	  int subop = insn & 0x0ff0;
// OBSOLETE 	  if ((subop == 0x0ec0) || (subop == 0x0fc0))
// OBSOLETE 	    {
// OBSOLETE 	      insn_debug (("done: jmp\n"));
// OBSOLETE 	      after_prologue = current_pc;
// OBSOLETE 	      maybe_one_more = 1;
// OBSOLETE 	      continue;		/* jmp , jl */
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (current_pc >= scan_limit)
// OBSOLETE     {
// OBSOLETE       if (pl_endptr)
// OBSOLETE 	{
// OBSOLETE #if 1
// OBSOLETE 	  if (after_stack_adjust != 0)
// OBSOLETE 	    /* We did not find a "mv fp,sp", but we DID find
// OBSOLETE 	       a stack_adjust.  Is it safe to use that as the
// OBSOLETE 	       end of the prologue?  I just don't know. */
// OBSOLETE 	    {
// OBSOLETE 	      *pl_endptr = after_stack_adjust;
// OBSOLETE 	      if (framelength)
// OBSOLETE 		*framelength = framesize;
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE #endif
// OBSOLETE 	    /* We reached the end of the loop without finding the end
// OBSOLETE 	       of the prologue.  No way to win -- we should report failure.  
// OBSOLETE 	       The way we do that is to return the original start_pc.
// OBSOLETE 	       GDB will set a breakpoint at the start of the function (etc.) */
// OBSOLETE 	    *pl_endptr = start_pc;
// OBSOLETE 	}
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE   if (after_prologue == 0)
// OBSOLETE     after_prologue = current_pc;
// OBSOLETE 
// OBSOLETE   insn_debug ((" framesize %d, firstline %08x\n", framesize, after_prologue));
// OBSOLETE   if (framelength)
// OBSOLETE     *framelength = framesize;
// OBSOLETE   if (pl_endptr)
// OBSOLETE     *pl_endptr = after_prologue;
// OBSOLETE }				/*  decode_prologue */
// OBSOLETE 
// OBSOLETE /* Function: skip_prologue
// OBSOLETE    Find end of function prologue */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE m32r_skip_prologue (CORE_ADDR pc)
// OBSOLETE {
// OBSOLETE   CORE_ADDR func_addr, func_end;
// OBSOLETE   struct symtab_and_line sal;
// OBSOLETE 
// OBSOLETE   /* See what the symbol table says */
// OBSOLETE 
// OBSOLETE   if (find_pc_partial_function (pc, NULL, &func_addr, &func_end))
// OBSOLETE     {
// OBSOLETE       sal = find_pc_line (func_addr, 0);
// OBSOLETE 
// OBSOLETE       if (sal.line != 0 && sal.end <= func_end)
// OBSOLETE 	{
// OBSOLETE 
// OBSOLETE 	  insn_debug (("BP after prologue %08x\n", sal.end));
// OBSOLETE 	  func_end = sal.end;
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	/* Either there's no line info, or the line after the prologue is after
// OBSOLETE 	   the end of the function.  In this case, there probably isn't a
// OBSOLETE 	   prologue.  */
// OBSOLETE 	{
// OBSOLETE 	  insn_debug (("No line info, line(%x) sal_end(%x) funcend(%x)\n",
// OBSOLETE 		       sal.line, sal.end, func_end));
// OBSOLETE 	  func_end = min (func_end, func_addr + DEFAULT_SEARCH_LIMIT);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     func_end = pc + DEFAULT_SEARCH_LIMIT;
// OBSOLETE   decode_prologue (pc, func_end, &sal.end, 0, 0, 0);
// OBSOLETE   return sal.end;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static unsigned long
// OBSOLETE m32r_scan_prologue (struct frame_info *fi, struct frame_saved_regs *fsr)
// OBSOLETE {
// OBSOLETE   struct symtab_and_line sal;
// OBSOLETE   CORE_ADDR prologue_start, prologue_end, current_pc;
// OBSOLETE   unsigned long framesize = 0;
// OBSOLETE 
// OBSOLETE   /* this code essentially duplicates skip_prologue, 
// OBSOLETE      but we need the start address below.  */
// OBSOLETE 
// OBSOLETE   if (find_pc_partial_function (fi->pc, NULL, &prologue_start, &prologue_end))
// OBSOLETE     {
// OBSOLETE       sal = find_pc_line (prologue_start, 0);
// OBSOLETE 
// OBSOLETE       if (sal.line == 0)	/* no line info, use current PC */
// OBSOLETE 	if (prologue_start == entry_point_address ())
// OBSOLETE 	  return 0;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       prologue_start = fi->pc;
// OBSOLETE       prologue_end = prologue_start + 48;	/* We're in the boondocks: 
// OBSOLETE 						   allow for 16 pushes, an add, 
// OBSOLETE 						   and "mv fp,sp" */
// OBSOLETE     }
// OBSOLETE #if 0
// OBSOLETE   prologue_end = min (prologue_end, fi->pc);
// OBSOLETE #endif
// OBSOLETE   insn_debug (("fipc(%08x) start(%08x) end(%08x)\n",
// OBSOLETE 	       fi->pc, prologue_start, prologue_end));
// OBSOLETE   prologue_end = min (prologue_end, prologue_start + DEFAULT_SEARCH_LIMIT);
// OBSOLETE   decode_prologue (prologue_start, prologue_end, &prologue_end, &framesize,
// OBSOLETE 		   fi, fsr);
// OBSOLETE   return framesize;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: init_extra_frame_info
// OBSOLETE    This function actually figures out the frame address for a given pc and
// OBSOLETE    sp.  This is tricky on the m32r because we sometimes don't use an explicit
// OBSOLETE    frame pointer, and the previous stack pointer isn't necessarily recorded
// OBSOLETE    on the stack.  The only reliable way to get this info is to
// OBSOLETE    examine the prologue.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE m32r_init_extra_frame_info (struct frame_info *fi)
// OBSOLETE {
// OBSOLETE   int reg;
// OBSOLETE 
// OBSOLETE   if (fi->next)
// OBSOLETE     fi->pc = FRAME_SAVED_PC (fi->next);
// OBSOLETE 
// OBSOLETE   memset (fi->fsr.regs, '\000', sizeof fi->fsr.regs);
// OBSOLETE 
// OBSOLETE   if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
// OBSOLETE     {
// OBSOLETE       /* We need to setup fi->frame here because run_stack_dummy gets it wrong
// OBSOLETE          by assuming it's always FP.  */
// OBSOLETE       fi->frame = deprecated_read_register_dummy (fi->pc, fi->frame,
// OBSOLETE 						  SP_REGNUM);
// OBSOLETE       fi->framesize = 0;
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       fi->using_frame_pointer = 0;
// OBSOLETE       fi->framesize = m32r_scan_prologue (fi, &fi->fsr);
// OBSOLETE 
// OBSOLETE       if (!fi->next)
// OBSOLETE 	if (fi->using_frame_pointer)
// OBSOLETE 	  {
// OBSOLETE 	    fi->frame = read_register (FP_REGNUM);
// OBSOLETE 	  }
// OBSOLETE 	else
// OBSOLETE 	  fi->frame = read_register (SP_REGNUM);
// OBSOLETE       else
// OBSOLETE 	/* fi->next means this is not the innermost frame */ if (fi->using_frame_pointer)
// OBSOLETE 	/* we have an FP */
// OBSOLETE 	if (fi->next->fsr.regs[FP_REGNUM] != 0)		/* caller saved our FP */
// OBSOLETE 	  fi->frame = read_memory_integer (fi->next->fsr.regs[FP_REGNUM], 4);
// OBSOLETE       for (reg = 0; reg < NUM_REGS; reg++)
// OBSOLETE 	if (fi->fsr.regs[reg] != 0)
// OBSOLETE 	  fi->fsr.regs[reg] = fi->frame + fi->framesize - fi->fsr.regs[reg];
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: m32r_virtual_frame_pointer
// OBSOLETE    Return the register that the function uses for a frame pointer, 
// OBSOLETE    plus any necessary offset to be applied to the register before
// OBSOLETE    any frame pointer offsets.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE m32r_virtual_frame_pointer (CORE_ADDR pc, long *reg, long *offset)
// OBSOLETE {
// OBSOLETE   struct frame_info *fi = deprecated_frame_xmalloc ();
// OBSOLETE   struct cleanup *old_chain = make_cleanup (xfree, fi);
// OBSOLETE 
// OBSOLETE   /* Set up a dummy frame_info. */
// OBSOLETE   fi->next = NULL;
// OBSOLETE   fi->prev = NULL;
// OBSOLETE   fi->frame = 0;
// OBSOLETE   fi->pc = pc;
// OBSOLETE 
// OBSOLETE   /* Analyze the prolog and fill in the extra info.  */
// OBSOLETE   m32r_init_extra_frame_info (fi);
// OBSOLETE 
// OBSOLETE   /* Results will tell us which type of frame it uses.  */
// OBSOLETE   if (fi->using_frame_pointer)
// OBSOLETE     {
// OBSOLETE       *reg = FP_REGNUM;
// OBSOLETE       *offset = 0;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       *reg = SP_REGNUM;
// OBSOLETE       *offset = 0;
// OBSOLETE     }
// OBSOLETE   do_cleanups (old_chain);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: find_callers_reg
// OBSOLETE    Find REGNUM on the stack.  Otherwise, it's in an active register.  One thing
// OBSOLETE    we might want to do here is to check REGNUM against the clobber mask, and
// OBSOLETE    somehow flag it as invalid if it isn't saved on the stack somewhere.  This
// OBSOLETE    would provide a graceful failure mode when trying to get the value of
// OBSOLETE    caller-saves registers for an inner frame.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE m32r_find_callers_reg (struct frame_info *fi, int regnum)
// OBSOLETE {
// OBSOLETE   for (; fi; fi = fi->next)
// OBSOLETE     if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
// OBSOLETE       return deprecated_read_register_dummy (fi->pc, fi->frame, regnum);
// OBSOLETE     else if (fi->fsr.regs[regnum] != 0)
// OBSOLETE       return read_memory_integer (fi->fsr.regs[regnum],
// OBSOLETE 				  REGISTER_RAW_SIZE (regnum));
// OBSOLETE   return read_register (regnum);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: frame_chain Given a GDB frame, determine the address of
// OBSOLETE    the calling function's frame.  This will be used to create a new
// OBSOLETE    GDB frame struct, and then INIT_EXTRA_FRAME_INFO and
// OBSOLETE    DEPRECATED_INIT_FRAME_PC will be called for the new frame.  For
// OBSOLETE    m32r, we save the frame size when we initialize the frame_info.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE m32r_frame_chain (struct frame_info *fi)
// OBSOLETE {
// OBSOLETE   CORE_ADDR fn_start, callers_pc, fp;
// OBSOLETE 
// OBSOLETE   /* is this a dummy frame? */
// OBSOLETE   if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
// OBSOLETE     return fi->frame;		/* dummy frame same as caller's frame */
// OBSOLETE 
// OBSOLETE   /* is caller-of-this a dummy frame? */
// OBSOLETE   callers_pc = FRAME_SAVED_PC (fi);	/* find out who called us: */
// OBSOLETE   fp = m32r_find_callers_reg (fi, FP_REGNUM);
// OBSOLETE   if (DEPRECATED_PC_IN_CALL_DUMMY (callers_pc, fp, fp))
// OBSOLETE     return fp;			/* dummy frame's frame may bear no relation to ours */
// OBSOLETE 
// OBSOLETE   if (find_pc_partial_function (fi->pc, 0, &fn_start, 0))
// OBSOLETE     if (fn_start == entry_point_address ())
// OBSOLETE       return 0;			/* in _start fn, don't chain further */
// OBSOLETE   if (fi->framesize == 0)
// OBSOLETE     {
// OBSOLETE       printf_filtered ("cannot determine frame size @@ %s , pc(%s)\n",
// OBSOLETE 		       paddr (fi->frame),
// OBSOLETE 		       paddr (fi->pc));
// OBSOLETE       return 0;
// OBSOLETE     }
// OBSOLETE   insn_debug (("m32rx frame %08x\n", fi->frame + fi->framesize));
// OBSOLETE   return fi->frame + fi->framesize;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: push_return_address (pc)
// OBSOLETE    Set up the return address for the inferior function call.
// OBSOLETE    Necessary for targets that don't actually execute a JSR/BSR instruction 
// OBSOLETE    (ie. when using an empty CALL_DUMMY) */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE m32r_push_return_address (CORE_ADDR pc, CORE_ADDR sp)
// OBSOLETE {
// OBSOLETE   write_register (RP_REGNUM, CALL_DUMMY_ADDRESS ());
// OBSOLETE   return sp;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* Function: pop_frame
// OBSOLETE    Discard from the stack the innermost frame,
// OBSOLETE    restoring all saved registers.  */
// OBSOLETE 
// OBSOLETE struct frame_info *
// OBSOLETE m32r_pop_frame (struct frame_info *frame)
// OBSOLETE {
// OBSOLETE   int regnum;
// OBSOLETE 
// OBSOLETE   if (DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
// OBSOLETE     generic_pop_dummy_frame ();
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       for (regnum = 0; regnum < NUM_REGS; regnum++)
// OBSOLETE 	if (frame->fsr.regs[regnum] != 0)
// OBSOLETE 	  write_register (regnum,
// OBSOLETE 			  read_memory_integer (frame->fsr.regs[regnum], 4));
// OBSOLETE 
// OBSOLETE       write_register (PC_REGNUM, FRAME_SAVED_PC (frame));
// OBSOLETE       write_register (SP_REGNUM, read_register (FP_REGNUM));
// OBSOLETE       if (read_register (PSW_REGNUM) & 0x80)
// OBSOLETE 	write_register (SPU_REGNUM, read_register (SP_REGNUM));
// OBSOLETE       else
// OBSOLETE 	write_register (SPI_REGNUM, read_register (SP_REGNUM));
// OBSOLETE     }
// OBSOLETE   flush_cached_frames ();
// OBSOLETE   return NULL;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: frame_saved_pc
// OBSOLETE    Find the caller of this frame.  We do this by seeing if RP_REGNUM is saved
// OBSOLETE    in the stack anywhere, otherwise we get it from the registers. */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE m32r_frame_saved_pc (struct frame_info *fi)
// OBSOLETE {
// OBSOLETE   if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
// OBSOLETE     return deprecated_read_register_dummy (fi->pc, fi->frame, PC_REGNUM);
// OBSOLETE   else
// OBSOLETE     return m32r_find_callers_reg (fi, RP_REGNUM);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: push_arguments
// OBSOLETE    Setup the function arguments for calling a function in the inferior.
// OBSOLETE 
// OBSOLETE    On the Mitsubishi M32R architecture, there are four registers (R0 to R3)
// OBSOLETE    which are dedicated for passing function arguments.  Up to the first 
// OBSOLETE    four arguments (depending on size) may go into these registers.
// OBSOLETE    The rest go on the stack.
// OBSOLETE 
// OBSOLETE    Arguments that are smaller than 4 bytes will still take up a whole
// OBSOLETE    register or a whole 32-bit word on the stack, and will be
// OBSOLETE    right-justified in the register or the stack word.  This includes
// OBSOLETE    chars, shorts, and small aggregate types.
// OBSOLETE 
// OBSOLETE    Arguments of 8 bytes size are split between two registers, if 
// OBSOLETE    available.  If only one register is available, the argument will 
// OBSOLETE    be split between the register and the stack.  Otherwise it is
// OBSOLETE    passed entirely on the stack.  Aggregate types with sizes between
// OBSOLETE    4 and 8 bytes are passed entirely on the stack, and are left-justified
// OBSOLETE    within the double-word (as opposed to aggregates smaller than 4 bytes
// OBSOLETE    which are right-justified).
// OBSOLETE 
// OBSOLETE    Aggregates of greater than 8 bytes are first copied onto the stack, 
// OBSOLETE    and then a pointer to the copy is passed in the place of the normal
// OBSOLETE    argument (either in a register if available, or on the stack).
// OBSOLETE 
// OBSOLETE    Functions that must return an aggregate type can return it in the 
// OBSOLETE    normal return value registers (R0 and R1) if its size is 8 bytes or
// OBSOLETE    less.  For larger return values, the caller must allocate space for 
// OBSOLETE    the callee to copy the return value to.  A pointer to this space is
// OBSOLETE    passed as an implicit first argument, always in R0. */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE m32r_push_arguments (int nargs, struct value **args, CORE_ADDR sp,
// OBSOLETE 		     unsigned char struct_return, CORE_ADDR struct_addr)
// OBSOLETE {
// OBSOLETE   int stack_offset, stack_alloc;
// OBSOLETE   int argreg;
// OBSOLETE   int argnum;
// OBSOLETE   struct type *type;
// OBSOLETE   CORE_ADDR regval;
// OBSOLETE   char *val;
// OBSOLETE   char valbuf[4];
// OBSOLETE   int len;
// OBSOLETE   int odd_sized_struct;
// OBSOLETE 
// OBSOLETE   /* first force sp to a 4-byte alignment */
// OBSOLETE   sp = sp & ~3;
// OBSOLETE 
// OBSOLETE   argreg = ARG0_REGNUM;
// OBSOLETE   /* The "struct return pointer" pseudo-argument goes in R0 */
// OBSOLETE   if (struct_return)
// OBSOLETE     write_register (argreg++, struct_addr);
// OBSOLETE 
// OBSOLETE   /* Now make sure there's space on the stack */
// OBSOLETE   for (argnum = 0, stack_alloc = 0;
// OBSOLETE        argnum < nargs; argnum++)
// OBSOLETE     stack_alloc += ((TYPE_LENGTH (VALUE_TYPE (args[argnum])) + 3) & ~3);
// OBSOLETE   sp -= stack_alloc;		/* make room on stack for args */
// OBSOLETE 
// OBSOLETE 
// OBSOLETE   /* Now load as many as possible of the first arguments into
// OBSOLETE      registers, and push the rest onto the stack.  There are 16 bytes
// OBSOLETE      in four registers available.  Loop thru args from first to last.  */
// OBSOLETE 
// OBSOLETE   argreg = ARG0_REGNUM;
// OBSOLETE   for (argnum = 0, stack_offset = 0; argnum < nargs; argnum++)
// OBSOLETE     {
// OBSOLETE       type = VALUE_TYPE (args[argnum]);
// OBSOLETE       len = TYPE_LENGTH (type);
// OBSOLETE       memset (valbuf, 0, sizeof (valbuf));
// OBSOLETE       if (len < 4)
// OBSOLETE 	{			/* value gets right-justified in the register or stack word */
// OBSOLETE 	  memcpy (valbuf + (4 - len),
// OBSOLETE 		  (char *) VALUE_CONTENTS (args[argnum]), len);
// OBSOLETE 	  val = valbuf;
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	val = (char *) VALUE_CONTENTS (args[argnum]);
// OBSOLETE 
// OBSOLETE       if (len > 4 && (len & 3) != 0)
// OBSOLETE 	odd_sized_struct = 1;	/* such structs go entirely on stack */
// OBSOLETE       else
// OBSOLETE 	odd_sized_struct = 0;
// OBSOLETE       while (len > 0)
// OBSOLETE 	{
// OBSOLETE 	  if (argreg > ARGLAST_REGNUM || odd_sized_struct)
// OBSOLETE 	    {			/* must go on the stack */
// OBSOLETE 	      write_memory (sp + stack_offset, val, 4);
// OBSOLETE 	      stack_offset += 4;
// OBSOLETE 	    }
// OBSOLETE 	  /* NOTE WELL!!!!!  This is not an "else if" clause!!!
// OBSOLETE 	     That's because some *&^%$ things get passed on the stack
// OBSOLETE 	     AND in the registers!   */
// OBSOLETE 	  if (argreg <= ARGLAST_REGNUM)
// OBSOLETE 	    {			/* there's room in a register */
// OBSOLETE 	      regval = extract_address (val, REGISTER_RAW_SIZE (argreg));
// OBSOLETE 	      write_register (argreg++, regval);
// OBSOLETE 	    }
// OBSOLETE 	  /* Store the value 4 bytes at a time.  This means that things
// OBSOLETE 	     larger than 4 bytes may go partly in registers and partly
// OBSOLETE 	     on the stack.  */
// OBSOLETE 	  len -= REGISTER_RAW_SIZE (argreg);
// OBSOLETE 	  val += REGISTER_RAW_SIZE (argreg);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   return sp;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: fix_call_dummy 
// OBSOLETE    If there is real CALL_DUMMY code (eg. on the stack), this function
// OBSOLETE    has the responsability to insert the address of the actual code that
// OBSOLETE    is the target of the target function call.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE m32r_fix_call_dummy (char *dummy, CORE_ADDR pc, CORE_ADDR fun, int nargs,
// OBSOLETE 		     struct value **args, struct type *type, int gcc_p)
// OBSOLETE {
// OBSOLETE   /* ld24 r8, <(imm24) fun> */
// OBSOLETE   *(unsigned long *) (dummy) = (fun & 0x00ffffff) | 0xe8000000;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* Function: m32r_write_sp
// OBSOLETE    Because SP is really a read-only register that mirrors either SPU or SPI,
// OBSOLETE    we must actually write one of those two as well, depending on PSW. */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE m32r_write_sp (CORE_ADDR val)
// OBSOLETE {
// OBSOLETE   unsigned long psw = read_register (PSW_REGNUM);
// OBSOLETE 
// OBSOLETE   if (psw & 0x80)		/* stack mode: user or interrupt */
// OBSOLETE     write_register (SPU_REGNUM, val);
// OBSOLETE   else
// OBSOLETE     write_register (SPI_REGNUM, val);
// OBSOLETE   write_register (SP_REGNUM, val);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_m32r_tdep (void)
// OBSOLETE {
// OBSOLETE   tm_print_insn = print_insn_m32r;
// OBSOLETE }
@


1.9.2.3
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d1 708
a708 986
/* Target-dependent code for Renesas M32R, for GDB.

   Copyright 1996, 1998, 1999, 2000, 2001, 2002, 2003 Free Software
   Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "frame.h"
#include "frame-unwind.h"
#include "frame-base.h"
#include "symtab.h"
#include "gdbtypes.h"
#include "gdbcmd.h"
#include "gdbcore.h"
#include "gdb_string.h"
#include "value.h"
#include "inferior.h"
#include "symfile.h"
#include "objfiles.h"
#include "language.h"
#include "arch-utils.h"
#include "regcache.h"
#include "trad-frame.h"

#include "gdb_assert.h"

struct gdbarch_tdep
{
  /* gdbarch target dependent data here. Currently unused for M32R. */
};

/* m32r register names. */

enum
{
  R0_REGNUM = 0,
  R3_REGNUM = 3,
  M32R_FP_REGNUM = 13,
  LR_REGNUM = 14,
  M32R_SP_REGNUM = 15,
  PSW_REGNUM = 16,
  M32R_PC_REGNUM = 21,
  /* m32r calling convention. */
  ARG1_REGNUM = R0_REGNUM,
  ARGN_REGNUM = R3_REGNUM,
  RET1_REGNUM = R0_REGNUM,
};

/* Local functions */

extern void _initialize_m32r_tdep (void);

static CORE_ADDR
m32r_frame_align (struct gdbarch *gdbarch, CORE_ADDR sp)
{
  /* Align to the size of an instruction (so that they can safely be
     pushed onto the stack.  */
  return sp & ~3;
}

/* Should we use EXTRACT_STRUCT_VALUE_ADDRESS instead of
   EXTRACT_RETURN_VALUE?  GCC_P is true if compiled with gcc
   and TYPE is the type (which is known to be struct, union or array).

   The m32r returns anything less than 8 bytes in size in
   registers. */

static int
m32r_use_struct_convention (int gcc_p, struct type *type)
{
  return (TYPE_LENGTH (type) > 8);
}


/* BREAKPOINT */
#define M32R_BE_BREAKPOINT32 {0x10, 0xf1, 0x70, 0x00}
#define M32R_LE_BREAKPOINT32 {0xf1, 0x10, 0x00, 0x70}
#define M32R_BE_BREAKPOINT16 {0x10, 0xf1}
#define M32R_LE_BREAKPOINT16 {0xf1, 0x10}

static int
m32r_memory_insert_breakpoint (CORE_ADDR addr, char *contents_cache)
{
  int val;
  unsigned char *bp;
  int bplen;

  bplen = (addr & 3) ? 2 : 4;

  /* Save the memory contents.  */
  val = target_read_memory (addr, contents_cache, bplen);
  if (val != 0)
    return val;			/* return error */

  /* Determine appropriate breakpoint contents and size for this address.  */
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
    {
      if (((addr & 3) == 0)
	  && ((contents_cache[0] & 0x80) || (contents_cache[2] & 0x80)))
	{
	  static unsigned char insn[] = M32R_BE_BREAKPOINT32;
	  bp = insn;
	  bplen = sizeof (insn);
	}
      else
	{
	  static unsigned char insn[] = M32R_BE_BREAKPOINT16;
	  bp = insn;
	  bplen = sizeof (insn);
	}
    }
  else
    {				/* little-endian */
      if (((addr & 3) == 0)
	  && ((contents_cache[1] & 0x80) || (contents_cache[3] & 0x80)))
	{
	  static unsigned char insn[] = M32R_LE_BREAKPOINT32;
	  bp = insn;
	  bplen = sizeof (insn);
	}
      else
	{
	  static unsigned char insn[] = M32R_LE_BREAKPOINT16;
	  bp = insn;
	  bplen = sizeof (insn);
	}
    }

  /* Write the breakpoint.  */
  val = target_write_memory (addr, (char *) bp, bplen);
  return val;
}

static int
m32r_memory_remove_breakpoint (CORE_ADDR addr, char *contents_cache)
{
  int val;
  int bplen;

  /* Determine appropriate breakpoint contents and size for this address.  */
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
    {
      if (((addr & 3) == 0)
	  && ((contents_cache[0] & 0x80) || (contents_cache[2] & 0x80)))
	{
	  static unsigned char insn[] = M32R_BE_BREAKPOINT32;
	  bplen = sizeof (insn);
	}
      else
	{
	  static unsigned char insn[] = M32R_BE_BREAKPOINT16;
	  bplen = sizeof (insn);
	}
    }
  else
    {
      /* little-endian */
      if (((addr & 3) == 0)
	  && ((contents_cache[1] & 0x80) || (contents_cache[3] & 0x80)))
	{
	  static unsigned char insn[] = M32R_BE_BREAKPOINT32;
	  bplen = sizeof (insn);
	}
      else
	{
	  static unsigned char insn[] = M32R_BE_BREAKPOINT16;
	  bplen = sizeof (insn);
	}
    }

  /* Write contents.  */
  val = target_write_memory (addr, contents_cache, bplen);
  return val;
}

static const unsigned char *
m32r_breakpoint_from_pc (CORE_ADDR *pcptr, int *lenptr)
{
  unsigned char *bp;

  /* Determine appropriate breakpoint.  */
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
    {
      if ((*pcptr & 3) == 0)
	{
	  static unsigned char insn[] = M32R_BE_BREAKPOINT32;
	  bp = insn;
	  *lenptr = sizeof (insn);
	}
      else
	{
	  static unsigned char insn[] = M32R_BE_BREAKPOINT16;
	  bp = insn;
	  *lenptr = sizeof (insn);
	}
    }
  else
    {
      if ((*pcptr & 3) == 0)
	{
	  static unsigned char insn[] = M32R_LE_BREAKPOINT32;
	  bp = insn;
	  *lenptr = sizeof (insn);
	}
      else
	{
	  static unsigned char insn[] = M32R_LE_BREAKPOINT16;
	  bp = insn;
	  *lenptr = sizeof (insn);
	}
    }

  return bp;
}


char *m32r_register_names[] = {
  "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
  "r8", "r9", "r10", "r11", "r12", "fp", "lr", "sp",
  "psw", "cbr", "spi", "spu", "bpc", "pc", "accl", "acch",
  "evb"
};

static int
m32r_num_regs (void)
{
  return (sizeof (m32r_register_names) / sizeof (m32r_register_names[0]));
}

static const char *
m32r_register_name (int reg_nr)
{
  if (reg_nr < 0)
    return NULL;
  if (reg_nr >= m32r_num_regs ())
    return NULL;
  return m32r_register_names[reg_nr];
}


/* Return the GDB type object for the "standard" data type
   of data in register N.  */

static struct type *
m32r_register_type (struct gdbarch *gdbarch, int reg_nr)
{
  if (reg_nr == M32R_PC_REGNUM)
    return builtin_type_void_func_ptr;
  else if (reg_nr == M32R_SP_REGNUM || reg_nr == M32R_FP_REGNUM)
    return builtin_type_void_data_ptr;
  else
    return builtin_type_int32;
}


/* Write into appropriate registers a function return value
   of type TYPE, given in virtual format.  

   Things always get returned in RET1_REGNUM, RET2_REGNUM. */

static void
m32r_store_return_value (struct type *type, struct regcache *regcache,
			 const void *valbuf)
{
  CORE_ADDR regval;
  int len = TYPE_LENGTH (type);

  regval = extract_unsigned_integer (valbuf, len > 4 ? 4 : len);
  regcache_cooked_write_unsigned (regcache, RET1_REGNUM, regval);

  if (len > 4)
    {
      regval = extract_unsigned_integer ((char *) valbuf + 4, len - 4);
      regcache_cooked_write_unsigned (regcache, RET1_REGNUM + 1, regval);
    }
}

/* Extract from an array REGBUF containing the (raw) register state
   the address in which a function should return its structure value,
   as a CORE_ADDR (or an expression that can be used as one).  */

static CORE_ADDR
m32r_extract_struct_value_address (struct regcache *regcache)
{
  ULONGEST addr;
  regcache_cooked_read_unsigned (regcache, ARG1_REGNUM, &addr);
  return addr;
}


/* This is required by skip_prologue. The results of decoding a prologue
   should be cached because this thrashing is getting nuts.  */

static void
decode_prologue (CORE_ADDR start_pc, CORE_ADDR scan_limit,
		 CORE_ADDR *pl_endptr)
{
  unsigned long framesize;
  int insn;
  int op1;
  int maybe_one_more = 0;
  CORE_ADDR after_prologue = 0;
  CORE_ADDR after_stack_adjust = 0;
  CORE_ADDR current_pc;

  framesize = 0;
  after_prologue = 0;

  for (current_pc = start_pc; current_pc < scan_limit; current_pc += 2)
    {
      insn = read_memory_unsigned_integer (current_pc, 2);

      /* If this is a 32 bit instruction, we dont want to examine its
         immediate data as though it were an instruction */
      if (current_pc & 0x02)
	{
	  /* Clear the parallel execution bit from 16 bit instruction */
	  if (maybe_one_more)
	    {
	      /* The last instruction was a branch, usually terminates
	         the series, but if this is a parallel instruction,
	         it may be a stack framing instruction */
	      if (!(insn & 0x8000))
		{
		  /* nope, we are really done */
		  break;
		}
	    }
	  /* decode this instruction further */
	  insn &= 0x7fff;
	}
      else
	{
	  if (maybe_one_more)
	    break;		/* This isnt the one more */
	  if (insn & 0x8000)
	    {
	      if (current_pc == scan_limit)
		scan_limit += 2;	/* extend the search */
	      current_pc += 2;	/* skip the immediate data */
	      if (insn == 0x8faf)	/* add3 sp, sp, xxxx */
		/* add 16 bit sign-extended offset */
		{
		  framesize +=
		    -((short) read_memory_unsigned_integer (current_pc, 2));
		}
	      else
		{
		  if (((insn >> 8) == 0xe4)	/* ld24 r4, xxxxxx; sub sp, r4 */
		      && read_memory_unsigned_integer (current_pc + 2,
						       2) == 0x0f24)
		    /* subtract 24 bit sign-extended negative-offset */
		    {
		      insn = read_memory_unsigned_integer (current_pc - 2, 4);
		      if (insn & 0x00800000)	/* sign extend */
			insn |= 0xff000000;	/* negative */
		      else
			insn &= 0x00ffffff;	/* positive */
		      framesize += insn;
		    }
		}
	      after_prologue = current_pc;
	      continue;
	    }
	}
      op1 = insn & 0xf000;	/* isolate just the first nibble */

      if ((insn & 0xf0ff) == 0x207f)
	{			/* st reg, @@-sp */
	  int regno;
	  framesize += 4;
	  regno = ((insn >> 8) & 0xf);
	  after_prologue = 0;
	  continue;
	}
      if ((insn >> 8) == 0x4f)	/* addi sp, xx */
	/* add 8 bit sign-extended offset */
	{
	  int stack_adjust = (char) (insn & 0xff);

	  /* there are probably two of these stack adjustments:
	     1) A negative one in the prologue, and
	     2) A positive one in the epilogue.
	     We are only interested in the first one.  */

	  if (stack_adjust < 0)
	    {
	      framesize -= stack_adjust;
	      after_prologue = 0;
	      /* A frameless function may have no "mv fp, sp".
	         In that case, this is the end of the prologue.  */
	      after_stack_adjust = current_pc + 2;
	    }
	  continue;
	}
      if (insn == 0x1d8f)
	{			/* mv fp, sp */
	  after_prologue = current_pc + 2;
	  break;		/* end of stack adjustments */
	}
      /* Nop looks like a branch, continue explicitly */
      if (insn == 0x7000)
	{
	  after_prologue = current_pc + 2;
	  continue;		/* nop occurs between pushes */
	}
      /* End of prolog if any of these are branch instructions */
      if ((op1 == 0x7000) || (op1 == 0xb000) || (op1 == 0xf000))
	{
	  after_prologue = current_pc;
	  maybe_one_more = 1;
	  continue;
	}
      /* Some of the branch instructions are mixed with other types */
      if (op1 == 0x1000)
	{
	  int subop = insn & 0x0ff0;
	  if ((subop == 0x0ec0) || (subop == 0x0fc0))
	    {
	      after_prologue = current_pc;
	      maybe_one_more = 1;
	      continue;		/* jmp , jl */
	    }
	}
    }

  if (current_pc >= scan_limit)
    {
      if (pl_endptr)
	{
	  if (after_stack_adjust != 0)
	    /* We did not find a "mv fp,sp", but we DID find
	       a stack_adjust.  Is it safe to use that as the
	       end of the prologue?  I just don't know. */
	    {
	      *pl_endptr = after_stack_adjust;
	    }
	  else
	    /* We reached the end of the loop without finding the end
	       of the prologue.  No way to win -- we should report failure.  
	       The way we do that is to return the original start_pc.
	       GDB will set a breakpoint at the start of the function (etc.) */
	    *pl_endptr = start_pc;
	}
      return;
    }
  if (after_prologue == 0)
    after_prologue = current_pc;

  if (pl_endptr)
    *pl_endptr = after_prologue;
}				/*  decode_prologue */

/* Function: skip_prologue
   Find end of function prologue */

#define DEFAULT_SEARCH_LIMIT 44

CORE_ADDR
m32r_skip_prologue (CORE_ADDR pc)
{
  CORE_ADDR func_addr, func_end;
  struct symtab_and_line sal;

  /* See what the symbol table says */

  if (find_pc_partial_function (pc, NULL, &func_addr, &func_end))
    {
      sal = find_pc_line (func_addr, 0);

      if (sal.line != 0 && sal.end <= func_end)
	{
	  func_end = sal.end;
	}
      else
	/* Either there's no line info, or the line after the prologue is after
	   the end of the function.  In this case, there probably isn't a
	   prologue.  */
	{
	  func_end = min (func_end, func_addr + DEFAULT_SEARCH_LIMIT);
	}
    }
  else
    func_end = pc + DEFAULT_SEARCH_LIMIT;
  decode_prologue (pc, func_end, &sal.end);
  return sal.end;
}


struct m32r_unwind_cache
{
  /* The previous frame's inner most stack address.  Used as this
     frame ID's stack_addr.  */
  CORE_ADDR prev_sp;
  /* The frame's base, optionally used by the high-level debug info.  */
  CORE_ADDR base;
  int size;
  /* How far the SP and r13 (FP) have been offset from the start of
     the stack frame (as defined by the previous frame's stack
     pointer).  */
  LONGEST sp_offset;
  LONGEST r13_offset;
  int uses_frame;
  /* Table indicating the location of each and every register.  */
  struct trad_frame_saved_reg *saved_regs;
};

/* Put here the code to store, into fi->saved_regs, the addresses of
   the saved registers of frame described by FRAME_INFO.  This
   includes special registers such as pc and fp saved in special ways
   in the stack frame.  sp is even more special: the address we return
   for it IS the sp for the next frame. */

static struct m32r_unwind_cache *
m32r_frame_unwind_cache (struct frame_info *next_frame,
			 void **this_prologue_cache)
{
  CORE_ADDR pc;
  ULONGEST prev_sp;
  ULONGEST this_base;
  unsigned long op;
  int i;
  struct m32r_unwind_cache *info;

  if ((*this_prologue_cache))
    return (*this_prologue_cache);

  info = FRAME_OBSTACK_ZALLOC (struct m32r_unwind_cache);
  (*this_prologue_cache) = info;
  info->saved_regs = trad_frame_alloc_saved_regs (next_frame);

  info->size = 0;
  info->sp_offset = 0;

  info->uses_frame = 0;
  for (pc = frame_func_unwind (next_frame);
       pc > 0 && pc < frame_pc_unwind (next_frame); pc += 2)
    {
      if ((pc & 2) == 0)
	{
	  op = get_frame_memory_unsigned (next_frame, pc, 4);
	  if ((op & 0x80000000) == 0x80000000)
	    {
	      /* 32-bit instruction */
	      if ((op & 0xffff0000) == 0x8faf0000)
		{
		  /* add3 sp,sp,xxxx */
		  short n = op & 0xffff;
		  info->sp_offset += n;
		}
	      else if (((op >> 8) == 0xe4)	/* ld24 r4, xxxxxx; sub sp, r4 */
		       && get_frame_memory_unsigned (next_frame, pc + 4,
						     2) == 0x0f24)
		{
		  unsigned long n = op & 0xffffff;
		  info->sp_offset += n;
		  pc += 2;
		}
	      else
		break;

	      pc += 2;
	      continue;
	    }
	}

      /* 16-bit instructions */
      op = get_frame_memory_unsigned (next_frame, pc, 2) & 0x7fff;
      if ((op & 0xf0ff) == 0x207f)
	{
	  /* st rn, @@-sp */
	  int regno = ((op >> 8) & 0xf);
	  info->sp_offset -= 4;
	  info->saved_regs[regno].addr = info->sp_offset;
	}
      else if ((op & 0xff00) == 0x4f00)
	{
	  /* addi sp, xx */
	  int n = (char) (op & 0xff);
	  info->sp_offset += n;
	}
      else if (op == 0x1d8f)
	{
	  /* mv fp, sp */
	  info->uses_frame = 1;
	  info->r13_offset = info->sp_offset;
	}
      else if (op == 0x7000)
	/* nop */
	continue;
      else
	break;
    }

  info->size = -info->sp_offset;

  /* Compute the previous frame's stack pointer (which is also the
     frame's ID's stack address), and this frame's base pointer.  */
  if (info->uses_frame)
    {
      /* The SP was moved to the FP.  This indicates that a new frame
         was created.  Get THIS frame's FP value by unwinding it from
         the next frame.  */
      this_base = frame_unwind_register_unsigned (next_frame, M32R_FP_REGNUM);
      /* The FP points at the last saved register.  Adjust the FP back
         to before the first saved register giving the SP.  */
      prev_sp = this_base + info->size;
    }
  else
    {
      /* Assume that the FP is this frame's SP but with that pushed
         stack space added back.  */
      this_base = frame_unwind_register_unsigned (next_frame, M32R_SP_REGNUM);
      prev_sp = this_base + info->size;
    }

  /* Convert that SP/BASE into real addresses.  */
  info->prev_sp = prev_sp;
  info->base = this_base;

  /* Adjust all the saved registers so that they contain addresses and
     not offsets.  */
  for (i = 0; i < NUM_REGS - 1; i++)
    if (trad_frame_addr_p (info->saved_regs, i))
      info->saved_regs[i].addr = (info->prev_sp + info->saved_regs[i].addr);

  /* The call instruction moves the caller's PC in the callee's LR.
     Since this is an unwind, do the reverse.  Copy the location of LR
     into PC (the address / regnum) so that a request for PC will be
     converted into a request for the LR.  */
  info->saved_regs[M32R_PC_REGNUM] = info->saved_regs[LR_REGNUM];

  /* The previous frame's SP needed to be computed.  Save the computed
     value.  */
  trad_frame_set_value (info->saved_regs, M32R_SP_REGNUM, prev_sp);

  return info;
}

static CORE_ADDR
m32r_read_pc (ptid_t ptid)
{
  ptid_t save_ptid;
  ULONGEST pc;

  save_ptid = inferior_ptid;
  inferior_ptid = ptid;
  regcache_cooked_read_unsigned (current_regcache, M32R_PC_REGNUM, &pc);
  inferior_ptid = save_ptid;
  return pc;
}

static void
m32r_write_pc (CORE_ADDR val, ptid_t ptid)
{
  ptid_t save_ptid;

  save_ptid = inferior_ptid;
  inferior_ptid = ptid;
  write_register (M32R_PC_REGNUM, val);
  inferior_ptid = save_ptid;
}

static CORE_ADDR
m32r_unwind_sp (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  return frame_unwind_register_unsigned (next_frame, M32R_SP_REGNUM);
}


static CORE_ADDR
m32r_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
		      struct regcache *regcache, CORE_ADDR bp_addr, int nargs,
		      struct value **args, CORE_ADDR sp, int struct_return,
		      CORE_ADDR struct_addr)
{
  int stack_offset, stack_alloc;
  int argreg = ARG1_REGNUM;
  int argnum;
  struct type *type;
  enum type_code typecode;
  CORE_ADDR regval;
  char *val;
  char valbuf[MAX_REGISTER_SIZE];
  int len;
  int odd_sized_struct;

  /* first force sp to a 4-byte alignment */
  sp = sp & ~3;

  /* Set the return address.  For the m32r, the return breakpoint is
     always at BP_ADDR.  */
  regcache_cooked_write_unsigned (regcache, LR_REGNUM, bp_addr);

  /* If STRUCT_RETURN is true, then the struct return address (in
     STRUCT_ADDR) will consume the first argument-passing register.
     Both adjust the register count and store that value.  */
  if (struct_return)
    {
      regcache_cooked_write_unsigned (regcache, argreg, struct_addr);
      argreg++;
    }

  /* Now make sure there's space on the stack */
  for (argnum = 0, stack_alloc = 0; argnum < nargs; argnum++)
    stack_alloc += ((TYPE_LENGTH (VALUE_TYPE (args[argnum])) + 3) & ~3);
  sp -= stack_alloc;		/* make room on stack for args */

  for (argnum = 0, stack_offset = 0; argnum < nargs; argnum++)
    {
      type = VALUE_TYPE (args[argnum]);
      typecode = TYPE_CODE (type);
      len = TYPE_LENGTH (type);

      memset (valbuf, 0, sizeof (valbuf));

      /* Passes structures that do not fit in 2 registers by reference.  */
      if (len > 8
	  && (typecode == TYPE_CODE_STRUCT || typecode == TYPE_CODE_UNION))
	{
	  store_unsigned_integer (valbuf, 4, VALUE_ADDRESS (args[argnum]));
	  typecode = TYPE_CODE_PTR;
	  len = 4;
	  val = valbuf;
	}
      else if (len < 4)
	{
	  /* value gets right-justified in the register or stack word */
	  memcpy (valbuf + (register_size (gdbarch, argreg) - len),
		  (char *) VALUE_CONTENTS (args[argnum]), len);
	  val = valbuf;
	}
      else
	val = (char *) VALUE_CONTENTS (args[argnum]);

      while (len > 0)
	{
	  if (argreg > ARGN_REGNUM)
	    {
	      /* must go on the stack */
	      write_memory (sp + stack_offset, val, 4);
	      stack_offset += 4;
	    }
	  else if (argreg <= ARGN_REGNUM)
	    {
	      /* there's room in a register */
	      regval =
		extract_unsigned_integer (val,
					  register_size (gdbarch, argreg));
	      regcache_cooked_write_unsigned (regcache, argreg++, regval);
	    }

	  /* Store the value 4 bytes at a time.  This means that things
	     larger than 4 bytes may go partly in registers and partly
	     on the stack.  */
	  len -= register_size (gdbarch, argreg);
	  val += register_size (gdbarch, argreg);
	}
    }

  /* Finally, update the SP register.  */
  regcache_cooked_write_unsigned (regcache, M32R_SP_REGNUM, sp);

  return sp;
}


/* Given a return value in `regbuf' with a type `valtype', 
   extract and copy its value into `valbuf'.  */

static void
m32r_extract_return_value (struct type *type, struct regcache *regcache,
			   void *dst)
{
  bfd_byte *valbuf = dst;
  int len = TYPE_LENGTH (type);
  ULONGEST tmp;

  /* By using store_unsigned_integer we avoid having to do
     anything special for small big-endian values.  */
  regcache_cooked_read_unsigned (regcache, RET1_REGNUM, &tmp);
  store_unsigned_integer (valbuf, (len > 4 ? len - 4 : len), tmp);

  /* Ignore return values more than 8 bytes in size because the m32r
     returns anything more than 8 bytes in the stack. */
  if (len > 4)
    {
      regcache_cooked_read_unsigned (regcache, RET1_REGNUM + 1, &tmp);
      store_unsigned_integer (valbuf + len - 4, 4, tmp);
    }
}


static CORE_ADDR
m32r_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  return frame_unwind_register_unsigned (next_frame, M32R_PC_REGNUM);
}

/* Given a GDB frame, determine the address of the calling function's
   frame.  This will be used to create a new GDB frame struct.  */

static void
m32r_frame_this_id (struct frame_info *next_frame,
		    void **this_prologue_cache, struct frame_id *this_id)
{
  struct m32r_unwind_cache *info
    = m32r_frame_unwind_cache (next_frame, this_prologue_cache);
  CORE_ADDR base;
  CORE_ADDR func;
  struct minimal_symbol *msym_stack;
  struct frame_id id;

  /* The FUNC is easy.  */
  func = frame_func_unwind (next_frame);

  /* This is meant to halt the backtrace at "_start".  Make sure we
     don't halt it at a generic dummy frame. */
  if (inside_entry_file (func))
    return;

  /* Check if the stack is empty.  */
  msym_stack = lookup_minimal_symbol ("_stack", NULL, NULL);
  if (msym_stack && info->base == SYMBOL_VALUE_ADDRESS (msym_stack))
    return;

  /* Hopefully the prologue analysis either correctly determined the
     frame's base (which is the SP from the previous frame), or set
     that base to "NULL".  */
  base = info->prev_sp;
  if (base == 0)
    return;

  id = frame_id_build (base, func);

  /* Check that we're not going round in circles with the same frame
     ID (but avoid applying the test to sentinel frames which do go
     round in circles).  Can't use frame_id_eq() as that doesn't yet
     compare the frame's PC value.  */
  if (frame_relative_level (next_frame) >= 0
      && get_frame_type (next_frame) != DUMMY_FRAME
      && frame_id_eq (get_frame_id (next_frame), id))
    return;

  (*this_id) = id;
}

static void
m32r_frame_prev_register (struct frame_info *next_frame,
			  void **this_prologue_cache,
			  int regnum, int *optimizedp,
			  enum lval_type *lvalp, CORE_ADDR *addrp,
			  int *realnump, void *bufferp)
{
  struct m32r_unwind_cache *info
    = m32r_frame_unwind_cache (next_frame, this_prologue_cache);
  trad_frame_prev_register (next_frame, info->saved_regs, regnum,
			    optimizedp, lvalp, addrp, realnump, bufferp);
}

static const struct frame_unwind m32r_frame_unwind = {
  NORMAL_FRAME,
  m32r_frame_this_id,
  m32r_frame_prev_register
};

static const struct frame_unwind *
m32r_frame_sniffer (struct frame_info *next_frame)
{
  return &m32r_frame_unwind;
}

static CORE_ADDR
m32r_frame_base_address (struct frame_info *next_frame, void **this_cache)
{
  struct m32r_unwind_cache *info
    = m32r_frame_unwind_cache (next_frame, this_cache);
  return info->base;
}

static const struct frame_base m32r_frame_base = {
  &m32r_frame_unwind,
  m32r_frame_base_address,
  m32r_frame_base_address,
  m32r_frame_base_address
};

/* Assuming NEXT_FRAME->prev is a dummy, return the frame ID of that
   dummy frame.  The frame ID's base needs to match the TOS value
   saved by save_dummy_frame_tos(), and the PC match the dummy frame's
   breakpoint.  */

static struct frame_id
m32r_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  return frame_id_build (m32r_unwind_sp (gdbarch, next_frame),
			 frame_pc_unwind (next_frame));
}


static gdbarch_init_ftype m32r_gdbarch_init;

static struct gdbarch *
m32r_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
{
  struct gdbarch *gdbarch;
  struct gdbarch_tdep *tdep;

  /* If there is already a candidate, use it.  */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;

  /* Allocate space for the new architecture.  */
  tdep = XMALLOC (struct gdbarch_tdep);
  gdbarch = gdbarch_alloc (&info, tdep);

  set_gdbarch_read_pc (gdbarch, m32r_read_pc);
  set_gdbarch_write_pc (gdbarch, m32r_write_pc);
  set_gdbarch_unwind_sp (gdbarch, m32r_unwind_sp);

  set_gdbarch_num_regs (gdbarch, m32r_num_regs ());
  set_gdbarch_sp_regnum (gdbarch, M32R_SP_REGNUM);
  set_gdbarch_register_name (gdbarch, m32r_register_name);
  set_gdbarch_register_type (gdbarch, m32r_register_type);

  set_gdbarch_extract_return_value (gdbarch, m32r_extract_return_value);
  set_gdbarch_push_dummy_call (gdbarch, m32r_push_dummy_call);
  set_gdbarch_store_return_value (gdbarch, m32r_store_return_value);
  set_gdbarch_extract_struct_value_address (gdbarch,
					    m32r_extract_struct_value_address);
  set_gdbarch_use_struct_convention (gdbarch, m32r_use_struct_convention);

  set_gdbarch_skip_prologue (gdbarch, m32r_skip_prologue);
  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);
  set_gdbarch_decr_pc_after_break (gdbarch, 0);
  set_gdbarch_function_start_offset (gdbarch, 0);
  set_gdbarch_breakpoint_from_pc (gdbarch, m32r_breakpoint_from_pc);
  set_gdbarch_memory_insert_breakpoint (gdbarch,
					m32r_memory_insert_breakpoint);
  set_gdbarch_memory_remove_breakpoint (gdbarch,
					m32r_memory_remove_breakpoint);

  set_gdbarch_frame_args_skip (gdbarch, 0);
  set_gdbarch_frameless_function_invocation (gdbarch,
					     frameless_look_for_prologue);

  set_gdbarch_frame_align (gdbarch, m32r_frame_align);

  frame_unwind_append_sniffer (gdbarch, m32r_frame_sniffer);
  frame_base_set_default (gdbarch, &m32r_frame_base);

  /* Methods for saving / extracting a dummy frame's ID.  The ID's
     stack address must match the SP value returned by
     PUSH_DUMMY_CALL, and saved by generic_save_dummy_frame_tos.  */
  set_gdbarch_unwind_dummy_id (gdbarch, m32r_unwind_dummy_id);

  /* Return the unwound PC value.  */
  set_gdbarch_unwind_pc (gdbarch, m32r_unwind_pc);

  set_gdbarch_print_insn (gdbarch, print_insn_m32r);

  return gdbarch;
}

void
_initialize_m32r_tdep (void)
{
  register_gdbarch_init (bfd_arch_m32r, m32r_gdbarch_init);
}
@


1.9.2.4
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d835 1
a835 1
  if (deprecated_inside_entry_file (func))
@


1.9.2.5
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@a39 1
#include "dis-asm.h"
d832 5
@


1.9.2.6
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d948 2
@


1.8
log
@2002-07-26  Andrew Cagney  <ac131313@@redhat.com>

* z8k-tdep.c: Do not include "obstack.h".
* h8300-tdep.c, h8500-tdep.c: Ditto.
* m68hc11-tdep.c, sh-tdep.c: Ditto.
* valprint.c, v850-tdep.c: Ditto.
* d10v-tdep.c, mn10300-tdep.c: Ditto.
* mn10200-tdep.c: Ditto.

* Makefile.in (z8k-tdep.o): Update dependencies.
(m68hc11-tdep.o, valprint.o): Ditto.
(v850-tdep.o, d10v-tdep.o): Ditto.
(mn10300-tdep.o, sparc-tdep.o): Ditto.
(sh-tdep.o, h8500-tdep.o, h8300-tdep.o): Ditto.
(m32r-tdep.o, mn10200-tdep.o): Specify dependencies.
(sh_opc_h, gdb_sim_sh_h): Define.
(elf_sh_h, elf_bfd_h): Define.
(opcode_m68hc11_h): Define.
(OPCODES_SRC, OPCODES_DIR): define.
(OPCODES): Use $(OPCODES_DIR).
(gdb_sim_d10v_h): Rename sim_d10v_h.
(gdb_sim_arm_h): Rename sim_arm_h.
@
text
@d393 2
a394 1
      fi->frame = generic_read_register_dummy (fi->pc, fi->frame, SP_REGNUM);
d466 1
a466 1
      return generic_read_register_dummy (fi->pc, fi->frame, regnum);
d558 1
a558 1
    return generic_read_register_dummy (fi->pc, fi->frame, PC_REGNUM);
@


1.7
log
@2001-09-05  Elena Zannoni  <ezannoni@@redhat.com>

        * gdbarch.sh: Move include of dis-asm.h so it is generated earlier
        in gdbarch.h.
        (TARGET_PRINT_INSN): Multiarch.
        * gdbarch.h: Regenerate.
        * gdbarch.c: Regenerate.

        * arch-utils.c (legacy_print_insn): New function.
        * arch-utils.h (legacy_print_insn): Export.

        * cris-tdep.c (cris_delayed_get_disassembler): Use
        TARGET_PRINT_INSN, instead of tm_print_insn.
        * d10v-tdep.c (print_insn): Ditto.
        * d30v-tdep.c (print_insn): Ditto.
        * m32r-tdep.c (dump_insn): Ditto.
        * v850-tdep.c (v850_scan_prologue): Ditto.
        * mcore-tdep.c (mcore_dump_insn): Ditto.
        * sh-tdep.c (sh_gdbarch_init): Set print_insn gdbarch field.
@
text
@a23 1
#include "obstack.h"
@


1.7.8.1
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d24 1
@


1.7.8.2
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d393 1
a393 2
      fi->frame = deprecated_read_register_dummy (fi->pc, fi->frame,
						  SP_REGNUM);
d465 1
a465 1
      return deprecated_read_register_dummy (fi->pc, fi->frame, regnum);
d557 1
a557 1
    return deprecated_read_register_dummy (fi->pc, fi->frame, PC_REGNUM);
@


1.6
log
@s/value_ptr/struct value */
@
text
@d63 1
a63 1
  (*tm_print_insn) (pc, &tm_print_insn_info);
@


1.5
log
@Update/correct copyright notices.
@
text
@d595 1
a595 1
m32r_push_arguments (int nargs, value_ptr *args, CORE_ADDR sp,
d678 1
a678 1
		     value_ptr *args, struct type *type, int gcc_p)
@


1.4
log
@2001-03-01  Michael Snyder  <msnyder@@mvstp600e.cygnus.com>

	* m32r-tdep.c: Fix cut and paste error in comment.
@
text
@d2 1
a2 1
   Copyright 1996, 2001 Free Software Foundation, Inc.
@


1.3
log
@Create new file regcache.h.  Update all uses.
@
text
@d421 1
a421 1
/* Function: mn10300_virtual_frame_pointer
@


1.2
log
@Protoization.
@
text
@d2 1
a2 1
   Copyright 1996, Free Software Foundation, Inc.
d31 1
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d36 1
a36 3
m32r_use_struct_convention (gcc_p, type)
     int gcc_p;
     struct type *type;
d46 3
a48 4
void 
m32r_frame_find_saved_regs (fi, regaddr)
     struct frame_info *fi;
     struct frame_saved_regs *regaddr;
d50 1
a50 1
  memcpy(regaddr, &fi->fsr, sizeof(struct frame_saved_regs));
d55 1
a55 1
   */
d57 2
a58 1
static void dump_insn(char * commnt,CORE_ADDR pc, int insn)
d60 4
a63 4
  printf_filtered("  %s %08x %08x ",
		  commnt,(unsigned int)pc,(unsigned int) insn);
  (*tm_print_insn)(pc,&tm_print_insn_info);
  printf_filtered("\n");
d71 1
a71 1
#define DEFAULT_SEARCH_LIMIT 44 
d80 20
a99 20
  The sequence it currently generates is:
  
	if (varargs function) { ddi sp,#n }
	push registers
	if (additional stack <= 256) {	addi sp,#-stack	}
	else if (additional stack < 65k) { add3 sp,sp,#-stack

	} else if (additional stack) {
	seth sp,#(stack & 0xffff0000)
	or3 sp,sp,#(stack & 0x0000ffff)
	sub sp,r4
	}
	if (frame pointer) {
		mv sp,fp
	}

These instructions are scheduled like everything else, so you should stop at
the first branch instruction.
 
*/
d106 1
a106 1
   */
d108 4
a111 9
static void decode_prologue (start_pc, scan_limit, 
			     pl_endptr, framelength, 
			     fi, fsr)
     CORE_ADDR start_pc;
     CORE_ADDR scan_limit;
     CORE_ADDR * pl_endptr;  /* var parameter */
     unsigned long * framelength;
     struct frame_info * fi;
     struct frame_saved_regs * fsr;
d124 1
a124 1
  insn_debug(("rd prolog l(%d)\n",scan_limit - current_pc));
d130 4
a133 4
      dump_insn("insn-1",current_pc,insn);    /* MTZ */
      
       /* If this is a 32 bit instruction, we dont want to examine its
	 immediate data as though it were an instruction */
d135 1
a135 1
	{ /* Clear the parallel execution bit from 16 bit instruction */
d137 7
a143 6
	    { /* The last instruction was a branch, usually terminates
		 the series, but if this is a parallel instruction,
		 it may be a stack framing instruction */
	      if (! (insn & 0x8000))
		{ insn_debug(("Really done"));
		  break; /* nope, we are really done */
d146 1
a146 1
	  insn &= 0x7fff;        /* decode this instruction further */
d150 2
a151 2
	  if (maybe_one_more) 
	    break; /* This isnt the one more */
d154 1
a154 1
	      insn_debug(("32 bit insn\n"));
d156 3
a158 3
		scan_limit += 2; /* extend the search */
	      current_pc += 2;   /* skip the immediate data */
	      if (insn == 0x8faf)			/* add3 sp, sp, xxxx */
d160 3
a162 2
		{ insn_debug(("stack increment\n"));
		framesize += -((short) read_memory_unsigned_integer (current_pc, 2));
d166 4
a169 4
		  if (((insn >> 8) == 0xe4) && /* ld24 r4, xxxxxx; sub sp, r4 */
		      read_memory_unsigned_integer (current_pc + 2, 2) == 0x0f24)
		    { /* subtract 24 bit sign-extended negative-offset */
		      dump_insn("insn-2",current_pc+2,insn);
d171 1
a171 1
		      dump_insn("insn-3(l4)",current_pc -2,insn);
d173 1
a173 1
			insn  |= 0xff000000;	/* negative */
d175 1
a175 1
			insn  &= 0x00ffffff;	/* positive */
d183 2
a184 2
      op1 = insn & 0xf000; /* isolate just the first nibble */
      
d186 1
a186 1
	{		/* st reg, @@-sp */
d188 3
a190 3
	  insn_debug(("push\n"));
#if 0	/* No, PUSH FP is not an indication that we will use a frame pointer. */
	  if (((insn & 0xffff) == 0x2d7f) && fi) 
d193 2
a194 2
	  framesize  += 4;
#if 0 
d202 1
a202 1
	  if (fsr)				/* save_regs offset */
d205 1
a205 1
	    continue;
d207 1
a207 1
      if ((insn >> 8) == 0x4f)  		/* addi sp, xx */
d222 1
a222 1
		 In that case, this is the end of the prologue.  */
d227 13
a239 11
      if (insn == 0x1d8f) {	/* mv fp, sp */
	if (fi) 
	  fi->using_frame_pointer = 1;	/* fp is now valid */
	insn_debug(("done fp found\n"));
	after_prologue = current_pc + 2;
	break;				/* end of stack adjustments */
      }
      if (insn ==  0x7000)  /* Nop looks like a branch, continue explicitly */
	{ insn_debug(("nop\n"));
	after_prologue = current_pc + 2;
	continue; /* nop occurs between pushes */
d243 2
a244 2
	  || ( op1 == 0xb000)
	  || (op1 == 0x7000))
d247 1
a247 1
	  insn_debug(("Done: branch\n"));
d253 2
a254 1
	{int subop = insn & 0x0ff0;
d256 2
a257 1
	    { insn_debug(("done: jmp\n"));
d260 1
a260 1
	      continue; /* jmp , jl */
d267 2
a268 1
      if (pl_endptr) 
d270 10
a279 10
	if (after_stack_adjust != 0)
	  /* We did not find a "mv fp,sp", but we DID find
	     a stack_adjust.  Is it safe to use that as the
	     end of the prologue?  I just don't know. */
	  {
	    *pl_endptr = after_stack_adjust;
	    if (framelength)
	      *framelength = framesize;
	  }
	else
d281 6
a286 7
      /* We reached the end of the loop without finding the end
	 of the prologue.  No way to win -- we should report failure.  
	 The way we do that is to return the original start_pc.
	 GDB will set a breakpoint at the start of the function (etc.) */

	*pl_endptr = start_pc;
	
d289 1
a289 1
  if (after_prologue == 0) 
d292 2
a293 2
  insn_debug((" framesize %d, firstline %08x\n",framesize,after_prologue));
  if (framelength) 
d295 1
a295 1
  if (pl_endptr) 
d297 1
a297 1
} /*  decode_prologue */
d303 1
a303 2
m32r_skip_prologue (pc)
     CORE_ADDR pc;
d316 2
a317 2
	  
	  insn_debug(("BP after prologue %08x\n",sal.end));
d325 3
a327 3
	  insn_debug(("No line info, line(%x) sal_end(%x) funcend(%x)\n",
		      sal.line,sal.end,func_end));
	  func_end = min(func_end,func_addr + DEFAULT_SEARCH_LIMIT);
d330 1
a330 1
  else 
d337 1
a337 3
m32r_scan_prologue (fi, fsr)
     struct frame_info *fi;
     struct frame_saved_regs *fsr;
d341 1
a341 1
  unsigned long framesize;
d350 1
a350 1
      if (sal.line == 0)		/* no line info, use current PC */
d357 3
a359 3
      prologue_end = prologue_start + 48; /* We're in the boondocks: 
					      allow for 16 pushes, an add, 
					      and "mv fp,sp" */
d364 5
a368 5
  insn_debug(("fipc(%08x) start(%08x) end(%08x)\n",
	      fi->pc,prologue_start,prologue_end));
  prologue_end = min(prologue_end, prologue_start + DEFAULT_SEARCH_LIMIT);
  decode_prologue (prologue_start,prologue_end,&prologue_end,&framesize,
		   fi,fsr);
d380 1
a380 2
m32r_init_extra_frame_info (fi)
     struct frame_info *fi;
d392 1
a392 1
	 by assuming it's always FP.  */
d397 1
a397 1
  else 
d409 5
a413 4
      else 	/* fi->next means this is not the innermost frame */
	if (fi->using_frame_pointer)		    /* we have an FP */
	  if (fi->next->fsr.regs[FP_REGNUM] != 0)   /* caller saved our FP */
	    fi->frame = read_memory_integer (fi->next->fsr.regs[FP_REGNUM], 4);
d426 1
a426 4
m32r_virtual_frame_pointer (pc, reg, offset)
     CORE_ADDR pc;
     long *reg;
     long *offset;
d443 1
a443 1
      *reg    = FP_REGNUM;
d448 1
a448 1
      *reg    = SP_REGNUM;
d461 1
a461 3
m32r_find_callers_reg (fi, regnum)
     struct frame_info *fi;
     int regnum;
d467 2
a468 2
      return read_memory_integer (fi->fsr.regs[regnum], 
				  REGISTER_RAW_SIZE(regnum));
d479 1
a479 2
m32r_frame_chain (fi)
     struct frame_info *fi;
d484 2
a485 2
  if (PC_IN_CALL_DUMMY(fi->pc, fi->frame, fi->frame))
    return fi->frame;	/* dummy frame same as caller's frame */
d488 1
a488 1
  callers_pc = FRAME_SAVED_PC(fi);  /* find out who called us: */
d490 2
a491 2
  if (PC_IN_CALL_DUMMY(callers_pc, fp, fp))	
    return fp;		/* dummy frame's frame may bear no relation to ours */
d495 1
a495 1
      return 0;		/* in _start fn, don't chain further */
d498 3
a500 3
      printf_filtered("cannot determine frame size @@ %08x , pc(%08x)\n",
		      (unsigned long) fi->frame,
		      (unsigned long) fi->pc );
d503 1
a503 1
  insn_debug(("m32rx frame %08x\n",fi->frame+fi->framesize));
d513 1
a513 3
m32r_push_return_address (pc, sp)
     CORE_ADDR pc;
     CORE_ADDR sp;
d525 1
a525 2
m32r_pop_frame (frame)
     struct frame_info *frame;
d535 1
a535 1
	  write_register (regnum, 
d554 1
a554 2
m32r_frame_saved_pc (fi)
     struct frame_info *fi;
d556 2
a557 2
  if (PC_IN_CALL_DUMMY(fi->pc, fi->frame, fi->frame))
    return generic_read_register_dummy(fi->pc, fi->frame, PC_REGNUM);
d574 1
a574 1
 
d594 2
a595 6
m32r_push_arguments (nargs, args, sp, struct_return, struct_addr)
     int nargs;
     value_ptr *args;
     CORE_ADDR sp;
     unsigned char struct_return;
     CORE_ADDR struct_addr;
d610 1
a610 1
  argreg = ARG0_REGNUM;  
d613 2
a614 2
      write_register (argreg++, struct_addr);
 
d618 4
a621 4
    stack_alloc += ((TYPE_LENGTH(VALUE_TYPE(args[argnum])) + 3) & ~3);
  sp -= stack_alloc;    /* make room on stack for args */
 
 
d625 1
a625 1
 
d630 2
a631 2
      len  = TYPE_LENGTH (type);
      memset(valbuf, 0, sizeof(valbuf));
d633 5
a637 5
        { /* value gets right-justified in the register or stack word */
          memcpy(valbuf + (4 - len),
                 (char *) VALUE_CONTENTS (args[argnum]), len);
          val = valbuf;
        }
d639 2
a640 2
        val = (char *) VALUE_CONTENTS (args[argnum]);
 
d642 1
a642 1
        odd_sized_struct = 1;           /* such structs go entirely on stack */
d644 1
a644 1
        odd_sized_struct = 0;
d646 20
a665 20
        {
          if (argreg > ARGLAST_REGNUM || odd_sized_struct)
            {				/* must go on the stack */
              write_memory (sp + stack_offset, val, 4);
              stack_offset += 4;
            }
          /* NOTE WELL!!!!!  This is not an "else if" clause!!!
             That's because some *&^%$ things get passed on the stack
             AND in the registers!   */
          if (argreg <= ARGLAST_REGNUM)
            {				/* there's room in a register */
              regval = extract_address (val, REGISTER_RAW_SIZE(argreg));
              write_register (argreg++, regval);
            }
          /* Store the value 4 bytes at a time.  This means that things
             larger than 4 bytes may go partly in registers and partly
             on the stack.  */
          len -= REGISTER_RAW_SIZE(argreg);
          val += REGISTER_RAW_SIZE(argreg);
        }
d676 2
a677 8
m32r_fix_call_dummy (dummy, pc, fun, nargs, args, type, gcc_p)
     char *dummy;
     CORE_ADDR pc;
     CORE_ADDR fun;
     int nargs;
     value_ptr *args;
     struct type *type;
     int gcc_p;
a682 16
/* Function: get_saved_register
   Just call the generic_get_saved_register function.  */

void
get_saved_register (raw_buffer, optimized, addrp, frame, regnum, lval)
     char *raw_buffer;
     int *optimized;
     CORE_ADDR *addrp;
     struct frame_info *frame;
     int regnum;
     enum lval_type *lval;
{
  generic_get_saved_register (raw_buffer, optimized, addrp, 
			      frame, regnum, lval);
}

d689 1
a689 2
m32r_write_sp (val)
     CORE_ADDR val;
d693 1
a693 1
  if (psw & 0x80)	/* stack mode: user or interrupt */
d701 1
a701 1
_initialize_m32r_tdep ()
a704 1

@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@a267 1
	{
d269 10
a278 10
	  if (after_stack_adjust != 0)
	    /* We did not find a "mv fp,sp", but we DID find
	       a stack_adjust.  Is it safe to use that as the
	       end of the prologue?  I just don't know. */
	    {
	      *pl_endptr = after_stack_adjust;
	      if (framelength)
		*framelength = framesize;
	    }
	  else
d280 7
a286 6
	    /* We reached the end of the loop without finding the end
	       of the prologue.  No way to win -- we should report failure.  
	       The way we do that is to return the original start_pc.
	       GDB will set a breakpoint at the start of the function (etc.) */
	    *pl_endptr = start_pc;
	}	
d704 16
@


1.1.1.3
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d47 1
a47 1
void
d52 1
a52 1
  memcpy (regaddr, &fi->fsr, sizeof (struct frame_saved_regs));
d57 1
a57 1
 */
d59 1
a59 2
static void
dump_insn (char *commnt, CORE_ADDR pc, int insn)
d61 4
a64 4
  printf_filtered ("  %s %08x %08x ",
		   commnt, (unsigned int) pc, (unsigned int) insn);
  (*tm_print_insn) (pc, &tm_print_insn_info);
  printf_filtered ("\n");
d72 1
a72 1
#define DEFAULT_SEARCH_LIMIT 44
d81 20
a100 20
   The sequence it currently generates is:

   if (varargs function) { ddi sp,#n }
   push registers
   if (additional stack <= 256) {       addi sp,#-stack }
   else if (additional stack < 65k) { add3 sp,sp,#-stack

   } else if (additional stack) {
   seth sp,#(stack & 0xffff0000)
   or3 sp,sp,#(stack & 0x0000ffff)
   sub sp,r4
   }
   if (frame pointer) {
   mv sp,fp
   }

   These instructions are scheduled like everything else, so you should stop at
   the first branch instruction.

 */
d107 1
a107 1
 */
d109 3
a111 4
static void
decode_prologue (start_pc, scan_limit,
		 pl_endptr, framelength,
		 fi, fsr)
d114 4
a117 4
     CORE_ADDR *pl_endptr;	/* var parameter */
     unsigned long *framelength;
     struct frame_info *fi;
     struct frame_saved_regs *fsr;
d130 1
a130 1
  insn_debug (("rd prolog l(%d)\n", scan_limit - current_pc));
d136 4
a139 4
      dump_insn ("insn-1", current_pc, insn);	/* MTZ */

      /* If this is a 32 bit instruction, we dont want to examine its
         immediate data as though it were an instruction */
d141 1
a141 1
	{			/* Clear the parallel execution bit from 16 bit instruction */
d143 6
a148 7
	    {			/* The last instruction was a branch, usually terminates
				   the series, but if this is a parallel instruction,
				   it may be a stack framing instruction */
	      if (!(insn & 0x8000))
		{
		  insn_debug (("Really done"));
		  break;	/* nope, we are really done */
d151 1
a151 1
	  insn &= 0x7fff;	/* decode this instruction further */
d155 2
a156 2
	  if (maybe_one_more)
	    break;		/* This isnt the one more */
d159 1
a159 1
	      insn_debug (("32 bit insn\n"));
d161 3
a163 3
		scan_limit += 2;	/* extend the search */
	      current_pc += 2;	/* skip the immediate data */
	      if (insn == 0x8faf)	/* add3 sp, sp, xxxx */
d165 2
a166 3
		{
		  insn_debug (("stack increment\n"));
		  framesize += -((short) read_memory_unsigned_integer (current_pc, 2));
d170 4
a173 4
		  if (((insn >> 8) == 0xe4) &&	/* ld24 r4, xxxxxx; sub sp, r4 */
		  read_memory_unsigned_integer (current_pc + 2, 2) == 0x0f24)
		    {		/* subtract 24 bit sign-extended negative-offset */
		      dump_insn ("insn-2", current_pc + 2, insn);
d175 1
a175 1
		      dump_insn ("insn-3(l4)", current_pc - 2, insn);
d177 1
a177 1
			insn |= 0xff000000;	/* negative */
d179 1
a179 1
			insn &= 0x00ffffff;	/* positive */
d187 2
a188 2
      op1 = insn & 0xf000;	/* isolate just the first nibble */

d190 1
a190 1
	{			/* st reg, @@-sp */
d192 3
a194 3
	  insn_debug (("push\n"));
#if 0				/* No, PUSH FP is not an indication that we will use a frame pointer. */
	  if (((insn & 0xffff) == 0x2d7f) && fi)
d197 2
a198 2
	  framesize += 4;
#if 0
d206 1
a206 1
	  if (fsr)		/* save_regs offset */
d209 1
a209 1
	  continue;
d211 1
a211 1
      if ((insn >> 8) == 0x4f)	/* addi sp, xx */
d226 1
a226 1
	         In that case, this is the end of the prologue.  */
d231 11
a241 13
      if (insn == 0x1d8f)
	{			/* mv fp, sp */
	  if (fi)
	    fi->using_frame_pointer = 1;	/* fp is now valid */
	  insn_debug (("done fp found\n"));
	  after_prologue = current_pc + 2;
	  break;		/* end of stack adjustments */
	}
      if (insn == 0x7000)	/* Nop looks like a branch, continue explicitly */
	{
	  insn_debug (("nop\n"));
	  after_prologue = current_pc + 2;
	  continue;		/* nop occurs between pushes */
d245 1
a245 1
	  || (op1 == 0xb000)
d249 1
a249 1
	  insn_debug (("Done: branch\n"));
d255 1
a255 2
	{
	  int subop = insn & 0x0ff0;
d257 1
a257 2
	    {
	      insn_debug (("done: jmp\n"));
d260 1
a260 1
	      continue;		/* jmp , jl */
d267 1
a267 1
      if (pl_endptr)
d286 1
a286 1
	}
d289 1
a289 1
  if (after_prologue == 0)
d292 2
a293 2
  insn_debug ((" framesize %d, firstline %08x\n", framesize, after_prologue));
  if (framelength)
d295 1
a295 1
  if (pl_endptr)
d297 1
a297 1
}				/*  decode_prologue */
d317 2
a318 2

	  insn_debug (("BP after prologue %08x\n", sal.end));
d326 3
a328 3
	  insn_debug (("No line info, line(%x) sal_end(%x) funcend(%x)\n",
		       sal.line, sal.end, func_end));
	  func_end = min (func_end, func_addr + DEFAULT_SEARCH_LIMIT);
d331 1
a331 1
  else
d353 1
a353 1
      if (sal.line == 0)	/* no line info, use current PC */
d360 3
a362 3
      prologue_end = prologue_start + 48;	/* We're in the boondocks: 
						   allow for 16 pushes, an add, 
						   and "mv fp,sp" */
d367 5
a371 5
  insn_debug (("fipc(%08x) start(%08x) end(%08x)\n",
	       fi->pc, prologue_start, prologue_end));
  prologue_end = min (prologue_end, prologue_start + DEFAULT_SEARCH_LIMIT);
  decode_prologue (prologue_start, prologue_end, &prologue_end, &framesize,
		   fi, fsr);
d396 1
a396 1
         by assuming it's always FP.  */
d401 1
a401 1
  else
d413 4
a416 5
      else
	/* fi->next means this is not the innermost frame */ if (fi->using_frame_pointer)
	/* we have an FP */
	if (fi->next->fsr.regs[FP_REGNUM] != 0)		/* caller saved our FP */
	  fi->frame = read_memory_integer (fi->next->fsr.regs[FP_REGNUM], 4);
d449 1
a449 1
      *reg = FP_REGNUM;
d454 1
a454 1
      *reg = SP_REGNUM;
d475 2
a476 2
      return read_memory_integer (fi->fsr.regs[regnum],
				  REGISTER_RAW_SIZE (regnum));
d493 2
a494 2
  if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
    return fi->frame;		/* dummy frame same as caller's frame */
d497 1
a497 1
  callers_pc = FRAME_SAVED_PC (fi);	/* find out who called us: */
d499 2
a500 2
  if (PC_IN_CALL_DUMMY (callers_pc, fp, fp))
    return fp;			/* dummy frame's frame may bear no relation to ours */
d504 1
a504 1
      return 0;			/* in _start fn, don't chain further */
d507 3
a509 3
      printf_filtered ("cannot determine frame size @@ %08x , pc(%08x)\n",
		       (unsigned long) fi->frame,
		       (unsigned long) fi->pc);
d512 1
a512 1
  insn_debug (("m32rx frame %08x\n", fi->frame + fi->framesize));
d547 1
a547 1
	  write_register (regnum,
d569 2
a570 2
  if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
    return generic_read_register_dummy (fi->pc, fi->frame, PC_REGNUM);
d587 1
a587 1

d627 1
a627 1
  argreg = ARG0_REGNUM;
d630 2
a631 2
    write_register (argreg++, struct_addr);

d635 4
a638 4
    stack_alloc += ((TYPE_LENGTH (VALUE_TYPE (args[argnum])) + 3) & ~3);
  sp -= stack_alloc;		/* make room on stack for args */


d642 1
a642 1

d647 2
a648 2
      len = TYPE_LENGTH (type);
      memset (valbuf, 0, sizeof (valbuf));
d650 5
a654 5
	{			/* value gets right-justified in the register or stack word */
	  memcpy (valbuf + (4 - len),
		  (char *) VALUE_CONTENTS (args[argnum]), len);
	  val = valbuf;
	}
d656 2
a657 2
	val = (char *) VALUE_CONTENTS (args[argnum]);

d659 1
a659 1
	odd_sized_struct = 1;	/* such structs go entirely on stack */
d661 1
a661 1
	odd_sized_struct = 0;
d663 20
a682 20
	{
	  if (argreg > ARGLAST_REGNUM || odd_sized_struct)
	    {			/* must go on the stack */
	      write_memory (sp + stack_offset, val, 4);
	      stack_offset += 4;
	    }
	  /* NOTE WELL!!!!!  This is not an "else if" clause!!!
	     That's because some *&^%$ things get passed on the stack
	     AND in the registers!   */
	  if (argreg <= ARGLAST_REGNUM)
	    {			/* there's room in a register */
	      regval = extract_address (val, REGISTER_RAW_SIZE (argreg));
	      write_register (argreg++, regval);
	    }
	  /* Store the value 4 bytes at a time.  This means that things
	     larger than 4 bytes may go partly in registers and partly
	     on the stack.  */
	  len -= REGISTER_RAW_SIZE (argreg);
	  val += REGISTER_RAW_SIZE (argreg);
	}
d717 1
a717 1
  if (psw & 0x80)		/* stack mode: user or interrupt */
d729 1
@


1.1.1.4
log
@import gdb-1999-09-08 snapshot
@
text
@d517 3
a519 3
      printf_filtered ("cannot determine frame size @@ %s , pc(%s)\n",
		       paddr (fi->frame),
		       paddr (fi->pc));
@


1.1.1.5
log
@import gdb-1999-09-13 snapshot
@
text
@d253 1
a253 1
	  || (op1 == 0xf000))
d353 1
a353 1
  unsigned long framesize = 0;
@


