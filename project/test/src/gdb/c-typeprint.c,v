head	1.92;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.91
	gdb_7_6-2013-04-26-release:1.91
	gdb_7_6-branch:1.91.0.2
	gdb_7_6-2013-03-12-branchpoint:1.91
	gdb_7_5_1-2012-11-29-release:1.74
	gdb_7_5-2012-08-17-release:1.74
	gdb_7_5-branch:1.74.0.2
	gdb_7_5-2012-07-18-branchpoint:1.74
	gdb_7_4_1-2012-04-26-release:1.71.2.1
	gdb_7_4-2012-01-24-release:1.71.2.1
	gdb_7_4-branch:1.71.0.2
	gdb_7_4-2011-12-13-branchpoint:1.71
	gdb_7_3_1-2011-09-04-release:1.70
	gdb_7_3-2011-07-26-release:1.70
	gdb_7_3-branch:1.70.0.2
	gdb_7_3-2011-04-01-branchpoint:1.70
	gdb_7_2-2010-09-02-release:1.60
	gdb_7_2-branch:1.60.0.2
	gdb_7_2-2010-07-07-branchpoint:1.60
	gdb_7_1-2010-03-18-release:1.52
	gdb_7_1-branch:1.52.0.2
	gdb_7_1-2010-02-18-branchpoint:1.52
	gdb_7_0_1-2009-12-22-release:1.47
	gdb_7_0-2009-10-06-release:1.47
	gdb_7_0-branch:1.47.0.4
	gdb_7_0-2009-09-16-branchpoint:1.47
	arc-sim-20090309:1.41
	msnyder-checkpoint-072509-branch:1.47.0.2
	msnyder-checkpoint-072509-branchpoint:1.47
	arc-insight_6_8-branch:1.41.0.6
	arc-insight_6_8-branchpoint:1.41
	insight_6_8-branch:1.41.0.4
	insight_6_8-branchpoint:1.41
	reverse-20081226-branch:1.45.0.4
	reverse-20081226-branchpoint:1.45
	multiprocess-20081120-branch:1.45.0.2
	multiprocess-20081120-branchpoint:1.45
	reverse-20080930-branch:1.43.0.2
	reverse-20080930-branchpoint:1.43
	reverse-20080717-branch:1.42.0.4
	reverse-20080717-branchpoint:1.42
	msnyder-reverse-20080609-branch:1.42.0.2
	msnyder-reverse-20080609-branchpoint:1.42
	drow-reverse-20070409-branch:1.36.0.2
	drow-reverse-20070409-branchpoint:1.36
	gdb_6_8-2008-03-27-release:1.41
	gdb_6_8-branch:1.41.0.2
	gdb_6_8-2008-02-26-branchpoint:1.41
	gdb_6_7_1-2007-10-29-release:1.38
	gdb_6_7-2007-10-10-release:1.38
	gdb_6_7-branch:1.38.0.2
	gdb_6_7-2007-09-07-branchpoint:1.38
	insight_6_6-20070208-release:1.33
	gdb_6_6-2006-12-18-release:1.33
	gdb_6_6-branch:1.33.0.18
	gdb_6_6-2006-11-15-branchpoint:1.33
	insight_6_5-20061003-release:1.33
	gdb-csl-symbian-6_4_50_20060226-12:1.33
	gdb-csl-sourcerygxx-3_4_4-25:1.32
	nickrob-async-20060828-mergepoint:1.33
	gdb-csl-symbian-6_4_50_20060226-11:1.33
	gdb-csl-sourcerygxx-4_1-17:1.33.2.1
	gdb-csl-20060226-branch-local-2:1.33.2.1
	gdb-csl-sourcerygxx-4_1-14:1.33.2.1
	gdb-csl-sourcerygxx-4_1-13:1.33.2.1
	gdb-csl-sourcerygxx-4_1-12:1.33.2.1
	gdb-csl-sourcerygxx-3_4_4-21:1.33.2.1
	gdb_6_5-20060621-release:1.33
	gdb-csl-sourcerygxx-4_1-9:1.33.2.1
	gdb-csl-sourcerygxx-4_1-8:1.33.2.1
	gdb-csl-sourcerygxx-4_1-7:1.33.2.1
	gdb-csl-arm-2006q1-6:1.33.2.1
	gdb-csl-sourcerygxx-4_1-6:1.33.2.1
	gdb-csl-symbian-6_4_50_20060226-10:1.33
	gdb-csl-symbian-6_4_50_20060226-9:1.33
	gdb-csl-symbian-6_4_50_20060226-8:1.33
	gdb-csl-coldfire-4_1-11:1.33.2.1
	gdb-csl-sourcerygxx-3_4_4-19:1.33.2.1
	gdb-csl-coldfire-4_1-10:1.33.2.1
	gdb_6_5-branch:1.33.0.16
	gdb_6_5-2006-05-14-branchpoint:1.33
	gdb-csl-sourcerygxx-4_1-5:1.33.2.1
	nickrob-async-20060513-branch:1.33.0.14
	nickrob-async-20060513-branchpoint:1.33
	gdb-csl-sourcerygxx-4_1-4:1.33.2.1
	msnyder-reverse-20060502-branch:1.33.0.12
	msnyder-reverse-20060502-branchpoint:1.33
	gdb-csl-morpho-4_1-4:1.33
	gdb-csl-sourcerygxx-3_4_4-17:1.33
	readline_5_1-import-branch:1.33.0.10
	readline_5_1-import-branchpoint:1.33
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.33
	gdb-csl-symbian-20060226-branch:1.33.0.8
	gdb-csl-symbian-20060226-branchpoint:1.33
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.33
	msnyder-reverse-20060331-branch:1.33.0.6
	msnyder-reverse-20060331-branchpoint:1.33
	gdb-csl-available-20060303-branch:1.33.0.4
	gdb-csl-available-20060303-branchpoint:1.33
	gdb-csl-20060226-branch:1.33.0.2
	gdb-csl-20060226-branchpoint:1.33
	gdb_6_4-20051202-release:1.32
	msnyder-fork-checkpoint-branch:1.32.0.12
	msnyder-fork-checkpoint-branchpoint:1.32
	gdb-csl-gxxpro-6_3-branch:1.32.0.10
	gdb-csl-gxxpro-6_3-branchpoint:1.32
	gdb_6_4-branch:1.32.0.8
	gdb_6_4-2005-11-01-branchpoint:1.32
	gdb-csl-arm-20051020-branch:1.32.0.6
	gdb-csl-arm-20051020-branchpoint:1.32
	msnyder-tracepoint-checkpoint-branch:1.32.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.32
	gdb-csl-arm-20050325-2005-q1b:1.32
	gdb-csl-arm-20050325-2005-q1a:1.32
	csl-arm-20050325-branch:1.32.0.2
	csl-arm-20050325-branchpoint:1.32
	gdb-post-i18n-errorwarning-20050211:1.32
	gdb-pre-i18n-errorwarning-20050211:1.32
	gdb_6_3-20041109-release:1.31
	gdb_6_3-branch:1.31.0.4
	gdb_6_3-20041019-branchpoint:1.31
	drow_intercu-merge-20040921:1.31
	drow_intercu-merge-20040915:1.31
	jimb-gdb_6_2-e500-branch:1.31.0.6
	jimb-gdb_6_2-e500-branchpoint:1.31
	gdb_6_2-20040730-release:1.31
	gdb_6_2-branch:1.31.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.31
	gdb_6_1_1-20040616-release:1.30
	gdb_6_1-2004-04-05-release:1.30
	drow_intercu-merge-20040402:1.30
	drow_intercu-merge-20040327:1.30
	ezannoni_pie-20040323-branch:1.30.0.12
	ezannoni_pie-20040323-branchpoint:1.30
	cagney_tramp-20040321-mergepoint:1.30
	cagney_tramp-20040309-branch:1.30.0.10
	cagney_tramp-20040309-branchpoint:1.30
	gdb_6_1-branch:1.30.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.30
	drow_intercu-20040221-branch:1.30.0.6
	drow_intercu-20040221-branchpoint:1.30
	cagney_bfdfile-20040213-branch:1.30.0.4
	cagney_bfdfile-20040213-branchpoint:1.30
	drow-cplus-merge-20040208:1.30
	carlton_dictionary-20040126-merge:1.30
	cagney_bigcore-20040122-branch:1.30.0.2
	cagney_bigcore-20040122-branchpoint:1.30
	drow-cplus-merge-20040113:1.30
	drow-cplus-merge-20031224:1.30
	drow-cplus-merge-20031220:1.30
	carlton_dictionary-20031215-merge:1.30
	drow-cplus-merge-20031214:1.30
	carlton-dictionary-20031111-merge:1.30
	gdb_6_0-2003-10-04-release:1.26
	kettenis_sparc-20030918-branch:1.28.0.4
	kettenis_sparc-20030918-branchpoint:1.28
	carlton_dictionary-20030917-merge:1.28
	ezannoni_pie-20030916-branchpoint:1.28
	ezannoni_pie-20030916-branch:1.28.0.2
	cagney_x86i386-20030821-branch:1.26.0.36
	cagney_x86i386-20030821-branchpoint:1.26
	carlton_dictionary-20030805-merge:1.26
	carlton_dictionary-20030627-merge:1.26
	gdb_6_0-branch:1.26.0.34
	gdb_6_0-2003-06-23-branchpoint:1.26
	jimb-ppc64-linux-20030613-branch:1.26.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.26
	cagney_convert-20030606-branch:1.26.0.30
	cagney_convert-20030606-branchpoint:1.26
	cagney_writestrings-20030508-branch:1.26.0.28
	cagney_writestrings-20030508-branchpoint:1.26
	jimb-ppc64-linux-20030528-branch:1.26.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.26
	carlton_dictionary-20030523-merge:1.26
	cagney_fileio-20030521-branch:1.26.0.24
	cagney_fileio-20030521-branchpoint:1.26
	kettenis_i386newframe-20030517-mergepoint:1.26
	jimb-ppc64-linux-20030509-branch:1.26.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.26
	kettenis_i386newframe-20030504-mergepoint:1.26
	carlton_dictionary-20030430-merge:1.26
	kettenis_i386newframe-20030419-branch:1.26.0.20
	kettenis_i386newframe-20030419-branchpoint:1.26
	carlton_dictionary-20030416-merge:1.26
	cagney_frameaddr-20030409-mergepoint:1.26
	kettenis_i386newframe-20030406-branch:1.26.0.18
	kettenis_i386newframe-20030406-branchpoint:1.26
	cagney_frameaddr-20030403-branchpoint:1.26
	cagney_frameaddr-20030403-branch:1.26.0.16
	cagney_framebase-20030330-mergepoint:1.26
	cagney_framebase-20030326-branch:1.26.0.14
	cagney_framebase-20030326-branchpoint:1.26
	cagney_lazyid-20030317-branch:1.26.0.12
	cagney_lazyid-20030317-branchpoint:1.26
	kettenis-i386newframe-20030316-mergepoint:1.26
	offbyone-20030313-branch:1.26.0.10
	offbyone-20030313-branchpoint:1.26
	kettenis-i386newframe-20030308-branch:1.26.0.8
	kettenis-i386newframe-20030308-branchpoint:1.26
	carlton_dictionary-20030305-merge:1.26
	cagney_offbyone-20030303-branch:1.26.0.6
	cagney_offbyone-20030303-branchpoint:1.26
	carlton_dictionary-20030207-merge:1.26
	interps-20030203-mergepoint:1.26
	interps-20030202-branch:1.26.0.4
	interps-20030202-branchpoint:1.26
	cagney-unwind-20030108-branch:1.26.0.2
	cagney-unwind-20030108-branchpoint:1.26
	carlton_dictionary-20021223-merge:1.24
	gdb_5_3-2002-12-12-release:1.22
	carlton_dictionary-20021115-merge:1.23
	kseitz_interps-20021105-merge:1.23
	kseitz_interps-20021103-merge:1.23
	drow-cplus-merge-20021020:1.23
	drow-cplus-merge-20021025:1.23
	carlton_dictionary-20021025-merge:1.23
	carlton_dictionary-20021011-merge:1.22
	drow-cplus-branch:1.22.0.10
	drow-cplus-branchpoint:1.22
	kseitz_interps-20020930-merge:1.22
	carlton_dictionary-20020927-merge:1.22
	carlton_dictionary-branch:1.22.0.8
	carlton_dictionary-20020920-branchpoint:1.22
	gdb_5_3-branch:1.22.0.6
	gdb_5_3-2002-09-04-branchpoint:1.22
	kseitz_interps-20020829-merge:1.22
	cagney_sysregs-20020825-branch:1.22.0.4
	cagney_sysregs-20020825-branchpoint:1.22
	readline_4_3-import-branch:1.22.0.2
	readline_4_3-import-branchpoint:1.22
	gdb_5_2_1-2002-07-23-release:1.18
	kseitz_interps-20020528-branch:1.20.0.4
	kseitz_interps-20020528-branchpoint:1.20
	cagney_regbuf-20020515-branch:1.20.0.2
	cagney_regbuf-20020515-branchpoint:1.20
	jimb-macro-020506-branch:1.18.0.4
	jimb-macro-020506-branchpoint:1.18
	gdb_5_2-2002-04-29-release:1.18
	gdb_5_2-branch:1.18.0.2
	gdb_5_2-2002-03-03-branchpoint:1.18
	gdb_5_1_1-2002-01-24-release:1.11
	gdb_5_1_0_1-2002-01-03-release:1.11
	cygnus_cvs_20020108_pre:1.13
	gdb_5_1_0_1-2002-01-03-branchpoint:1.11
	gdb_5_1_0_1-2002-01-03-branch:1.11.0.8
	gdb_5_1-2001-11-21-release:1.11
	gdb_s390-2001-09-26-branch:1.11.0.6
	gdb_s390-2001-09-26-branchpoint:1.11
	gdb_5_1-2001-07-29-branch:1.11.0.4
	gdb_5_1-2001-07-29-branchpoint:1.11
	dberlin-typesystem-branch:1.11.0.2
	dberlin-typesystem-branchpoint:1.11
	gdb-post-ptid_t-2001-05-03:1.11
	gdb-pre-ptid_t-2001-05-03:1.11
	jimb_gnu_v3_branchpoint:1.6
	jimb_gnu_v3_branch:1.6.0.2
	insight-precleanup-2001-01-01:1.4
	gdb-post-protoization-2000-07-29:1.2
	gdb-pre-protoization-2000-07-29:1.1.1.7
	gdb-premipsmulti-2000-06-06-branch:1.1.1.7.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.7
	gdb-post-params-removal-2000-06-04:1.1.1.7
	gdb-pre-params-removal-2000-06-04:1.1.1.7
	gdb-post-params-removal-2000-05-28:1.1.1.7
	gdb-pre-params-removal-2000-05-28:1.1.1.7
	gdb_5_0-2000-05-19-release:1.1.1.7
	gdb_4_18_2-2000-05-18-release:1.1.1.7
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.7
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.7
	gdb_5_0-2000-04-10-branch:1.1.1.7.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.7
	repo-unification-2000-02-06:1.1.1.7
	insight-2000-02-04:1.1.1.7
	gdb-2000-02-04:1.1.1.7
	gdb-2000-02-02:1.1.1.6
	gdb-2000-02-01:1.1.1.6
	gdb-2000-01-31:1.1.1.5
	gdb-2000-01-26:1.1.1.5
	gdb-2000-01-24:1.1.1.5
	gdb-2000-01-17:1.1.1.5
	gdb-2000-01-10:1.1.1.5
	gdb-2000-01-05:1.1.1.5
	gdb-1999-12-21:1.1.1.5
	gdb-1999-12-13:1.1.1.5
	gdb-1999-12-07:1.1.1.4
	gdb-1999-12-06:1.1.1.4
	gdb-1999-11-16:1.1.1.4
	gdb-1999-11-08:1.1.1.4
	gdb-1999-11-01:1.1.1.4
	gdb-1999-10-25:1.1.1.4
	gdb-1999-10-18:1.1.1.4
	gdb-1999-10-11:1.1.1.4
	gdb-1999-10-04:1.1.1.4
	gdb-1999-09-28:1.1.1.4
	gdb-1999-09-21:1.1.1.4
	gdb-1999-09-13:1.1.1.4
	gdb-1999-09-08:1.1.1.4
	gdb-1999-08-30:1.1.1.4
	gdb-1999-08-23:1.1.1.4
	gdb-1999-08-16:1.1.1.4
	gdb-1999-08-09:1.1.1.4
	gdb-1999-08-02:1.1.1.4
	gdb-1999-07-26:1.1.1.4
	gdb-1999-07-19:1.1.1.4
	gdb-1999-07-12:1.1.1.4
	gdb-post-reformat-19990707:1.1.1.4
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.4
	gdb-pre-reformat-19990707:1.1.1.3
	gdb-1999-07-07:1.1.1.3
	gdb-1999-07-05:1.1.1.3
	gdb-1999-06-28:1.1.1.3
	gdb-1999-06-21:1.1.1.3
	gdb-1999-06-14:1.1.1.3
	gdb-1999-06-07:1.1.1.3
	gdb-1999-06-01:1.1.1.3
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.3
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.92
date	2013.04.15.17.30.35;	author tromey;	state Exp;
branches;
next	1.91;

1.91
date	2013.01.31.18.46.11;	author aristovski;	state Exp;
branches;
next	1.90;

1.90
date	2013.01.14.20.59.26;	author tromey;	state Exp;
branches;
next	1.89;

1.89
date	2013.01.01.06.32.40;	author brobecke;	state Exp;
branches;
next	1.88;

1.88
date	2012.12.14.20.33.26;	author tromey;	state Exp;
branches;
next	1.87;

1.87
date	2012.11.21.18.07.17;	author tromey;	state Exp;
branches;
next	1.86;

1.86
date	2012.11.12.17.37.36;	author tromey;	state Exp;
branches;
next	1.85;

1.85
date	2012.11.12.17.26.19;	author tromey;	state Exp;
branches;
next	1.84;

1.84
date	2012.11.12.17.20.39;	author tromey;	state Exp;
branches;
next	1.83;

1.83
date	2012.11.12.17.14.54;	author tromey;	state Exp;
branches;
next	1.82;

1.82
date	2012.10.31.09.26.21;	author aburgess;	state Exp;
branches;
next	1.81;

1.81
date	2012.09.25.12.20.39;	author siddhesh;	state Exp;
branches;
next	1.80;

1.80
date	2012.09.21.17.37.47;	author tromey;	state Exp;
branches;
next	1.79;

1.79
date	2012.09.21.17.33.17;	author tromey;	state Exp;
branches;
next	1.78;

1.78
date	2012.09.14.21.23.45;	author aburgess;	state Exp;
branches;
next	1.77;

1.77
date	2012.09.11.09.03.07;	author aburgess;	state Exp;
branches;
next	1.76;

1.76
date	2012.08.19.19.37.50;	author kseitz;	state Exp;
branches;
next	1.75;

1.75
date	2012.08.16.07.36.19;	author qiyao;	state Exp;
branches;
next	1.74;

1.74
date	2012.04.18.06.46.46;	author jkratoch;	state Exp;
branches;
next	1.73;

1.73
date	2012.02.07.04.48.18;	author devans;	state Exp;
branches;
next	1.72;

1.72
date	2012.01.04.08.17.00;	author brobecke;	state Exp;
branches;
next	1.71;

1.71
date	2011.05.18.16.30.34;	author tromey;	state Exp;
branches
	1.71.2.1;
next	1.70;

1.70
date	2011.03.22.17.35.22;	author jkratoch;	state Exp;
branches;
next	1.69;

1.69
date	2011.02.13.09.15.53;	author jkratoch;	state Exp;
branches;
next	1.68;

1.68
date	2011.01.07.19.36.15;	author msnyder;	state Exp;
branches;
next	1.67;

1.67
date	2011.01.05.22.22.47;	author msnyder;	state Exp;
branches;
next	1.66;

1.66
date	2011.01.01.15.32.58;	author brobecke;	state Exp;
branches;
next	1.65;

1.65
date	2010.12.31.22.59.52;	author msnyder;	state Exp;
branches;
next	1.64;

1.64
date	2010.11.03.14.21.56;	author kwerner;	state Exp;
branches;
next	1.63;

1.63
date	2010.10.19.04.22.20;	author devans;	state Exp;
branches;
next	1.62;

1.62
date	2010.10.13.15.10.10;	author devans;	state Exp;
branches;
next	1.61;

1.61
date	2010.10.11.19.24.52;	author devans;	state Exp;
branches;
next	1.60;

1.60
date	2010.06.28.20.39.28;	author jkratoch;	state Exp;
branches;
next	1.59;

1.59
date	2010.06.25.07.32.25;	author muller;	state Exp;
branches;
next	1.58;

1.58
date	2010.06.21.18.01.50;	author tromey;	state Exp;
branches;
next	1.57;

1.57
date	2010.06.14.08.26.56;	author jkratoch;	state Exp;
branches;
next	1.56;

1.56
date	2010.05.13.23.53.32;	author msnyder;	state Exp;
branches;
next	1.55;

1.55
date	2010.03.31.00.48.29;	author kseitz;	state Exp;
branches;
next	1.54;

1.54
date	2010.03.09.18.09.07;	author kseitz;	state Exp;
branches;
next	1.53;

1.53
date	2010.02.19.22.22.48;	author tromey;	state Exp;
branches;
next	1.52;

1.52
date	2010.02.15.20.42.28;	author tromey;	state Exp;
branches;
next	1.51;

1.51
date	2010.02.02.16.47.13;	author tromey;	state Exp;
branches;
next	1.50;

1.50
date	2010.01.01.07.31.30;	author brobecke;	state Exp;
branches;
next	1.49;

1.49
date	2009.11.12.19.47.25;	author drow;	state Exp;
branches;
next	1.48;

1.48
date	2009.10.06.22.47.20;	author muller;	state Exp;
branches;
next	1.47;

1.47
date	2009.07.02.12.57.14;	author uweigand;	state Exp;
branches;
next	1.46;

1.46
date	2009.01.03.05.57.51;	author brobecke;	state Exp;
branches;
next	1.45;

1.45
date	2008.10.08.12.49.12;	author jkratoch;	state Exp;
branches;
next	1.44;

1.44
date	2008.10.02.22.06.07;	author jkratoch;	state Exp;
branches;
next	1.43;

1.43
date	2008.09.27.21.29.29;	author tromey;	state Exp;
branches;
next	1.42;

1.42
date	2008.05.03.22.20.13;	author drow;	state Exp;
branches;
next	1.41;

1.41
date	2008.01.01.22.53.09;	author drow;	state Exp;
branches;
next	1.40;

1.40
date	2007.11.02.19.35.18;	author uweigand;	state Exp;
branches;
next	1.39;

1.39
date	2007.10.25.17.57.34;	author bauermann;	state Exp;
branches;
next	1.38;

1.38
date	2007.08.23.18.08.26;	author brobecke;	state Exp;
branches;
next	1.37;

1.37
date	2007.06.05.22.47.50;	author uweigand;	state Exp;
branches;
next	1.36;

1.36
date	2007.01.09.17.58.50;	author drow;	state Exp;
branches;
next	1.35;

1.35
date	2007.01.03.19.01.25;	author drow;	state Exp;
branches;
next	1.34;

1.34
date	2007.01.03.18.05.43;	author drow;	state Exp;
branches;
next	1.33;

1.33
date	2005.12.17.22.33.59;	author eliz;	state Exp;
branches
	1.33.2.1;
next	1.32;

1.32
date	2005.01.29.17.53.25;	author ibr;	state Exp;
branches;
next	1.31;

1.31
date	2004.04.08.21.18.12;	author cagney;	state Exp;
branches;
next	1.30;

1.30
date	2003.11.08.00.13.02;	author cagney;	state Exp;
branches
	1.30.6.1;
next	1.29;

1.29
date	2003.11.06.22.54.01;	author cagney;	state Exp;
branches;
next	1.28;

1.28
date	2003.09.14.16.32.12;	author cagney;	state Exp;
branches;
next	1.27;

1.27
date	2003.09.11.19.49.17;	author carlton;	state Exp;
branches;
next	1.26;

1.26
date	2003.01.04.21.54.54;	author drow;	state Exp;
branches;
next	1.25;

1.25
date	2003.01.04.21.51.53;	author drow;	state Exp;
branches;
next	1.24;

1.24
date	2002.12.11.20.19.39;	author kevinb;	state Exp;
branches;
next	1.23;

1.23
date	2002.10.14.22.58.28;	author kevinb;	state Exp;
branches;
next	1.22;

1.22
date	2002.07.29.22.55.26;	author cagney;	state Exp;
branches
	1.22.8.1
	1.22.10.1;
next	1.21;

1.21
date	2002.06.14.14.34.25;	author drow;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.14.18.30.50;	author drow;	state Exp;
branches
	1.20.2.1
	1.20.4.1;
next	1.19;

1.19
date	2002.05.13.14.00.35;	author drow;	state Exp;
branches;
next	1.18;

1.18
date	2002.02.09.16.08.53;	author jimb;	state Exp;
branches;
next	1.17;

1.17
date	2002.01.20.19.42.04;	author drow;	state Exp;
branches;
next	1.16;

1.16
date	2002.01.20.19.20.15;	author drow;	state Exp;
branches;
next	1.15;

1.15
date	2002.01.16.02.43.38;	author drow;	state Exp;
branches;
next	1.14;

1.14
date	2002.01.10.00.06.02;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.12.02.11.51;	author fnf;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.15.01.55.59;	author msnyder;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.27.00.19.09;	author jimb;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2001.04.24.23.12.50;	author jimb;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.27.20.36.23;	author jtc;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.24.03.23.20;	author jimb;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.24.03.21.46;	author jimb;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.07.02.57.08;	author jtc;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.03.06.08.21.06;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.01.01.46;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.04.08.29.25;	author muller;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.30.01.48.24;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.33.58;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.71.2.1
date	2012.01.06.04.43.05;	author brobecke;	state Exp;
branches;
next	;

1.33.2.1
date	2006.05.03.16.30.56;	author pbrook;	state Exp;
branches;
next	;

1.30.6.1
date	2004.09.16.17.00.54;	author drow;	state Exp;
branches;
next	;

1.22.8.1
date	2002.10.25.23.49.52;	author carlton;	state Exp;
branches;
next	1.22.8.2;

1.22.8.2
date	2002.11.24.18.47.18;	author carlton;	state Exp;
branches;
next	1.22.8.3;

1.22.8.3
date	2002.11.28.00.53.22;	author carlton;	state Exp;
branches;
next	1.22.8.4;

1.22.8.4
date	2002.12.23.19.38.13;	author carlton;	state Exp;
branches;
next	1.22.8.5;

1.22.8.5
date	2003.02.07.19.17.45;	author carlton;	state Exp;
branches;
next	1.22.8.6;

1.22.8.6
date	2003.06.16.20.00.45;	author carlton;	state Exp;
branches;
next	1.22.8.7;

1.22.8.7
date	2003.09.17.21.28.07;	author carlton;	state Exp;
branches;
next	1.22.8.8;

1.22.8.8
date	2003.11.11.23.50.38;	author carlton;	state Exp;
branches;
next	;

1.22.10.1
date	2002.10.06.03.10.08;	author drow;	state Exp;
branches;
next	1.22.10.2;

1.22.10.2
date	2002.10.26.17.12.04;	author drow;	state Exp;
branches;
next	1.22.10.3;

1.22.10.3
date	2002.10.29.03.10.51;	author drow;	state Exp;
branches;
next	1.22.10.4;

1.22.10.4
date	2002.10.30.23.11.47;	author drow;	state Exp;
branches;
next	1.22.10.5;

1.22.10.5
date	2002.11.01.16.43.03;	author drow;	state Exp;
branches;
next	1.22.10.6;

1.22.10.6
date	2003.12.14.20.27.07;	author drow;	state Exp;
branches;
next	;

1.20.2.1
date	2002.06.15.16.42.51;	author cagney;	state Exp;
branches;
next	;

1.20.4.1
date	2002.06.20.01.32.14;	author kseitz;	state Exp;
branches;
next	1.20.4.2;

1.20.4.2
date	2002.08.09.18.34.23;	author kseitz;	state Exp;
branches;
next	1.20.4.3;

1.20.4.3
date	2002.11.04.00.17.29;	author ezannoni;	state Exp;
branches;
next	;

1.11.2.1
date	2001.07.06.19.16.57;	author dberlin;	state Exp;
branches;
next	;

1.6.2.1
date	2001.03.24.03.27.11;	author jimb;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.33.58;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.23.45;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.05.25.18.01.08;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.07.07.20.04.38;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.12.14.01.05.28;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.02.02.00.21.04;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2000.02.05.07.29.40;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.92
log
@	PR c++/11990:
	* c-lang.c (cplus_language_defn): Use gdb_demangle.
	* c-typeprint.c (c_type_print_base): Use gdb_demangle.
	* cp-support.c (mangled_name_to_comp): Use gdb_demangle.
	(gdb_demangle): New function.
	* cp-support.h (gdb_demangle): Declare.
	* dwarf2read.c (dwarf2_physname, fixup_partial_die)
	(dwarf2_name): Use gdb_demangle.
	* gdbtypes.c (check_stub_method): Use gdb_demangle.
	* gnu-v3-abi.c (gnuv3_rtti_type): Strip @@plt and version
	suffixes from name.
	(gnuv3_print_method_ptr): Use gdb_demangle.
	* jv-lang.c (java_demangle): Use gdb_demangle.
	* jv-typeprint.c (java_type_print_base): Use gdb_demangle.
	* language.c (unk_lang_demangle): Use gdb_demangle.
	* symtab.c (symbol_find_demangled_name)
	(demangle_for_lookup): Use gdb_demangle.
@
text
@/* Support for printing C and C++ types for GDB, the GNU debugger.
   Copyright (C) 1986-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "gdb_obstack.h"
#include "bfd.h"		/* Binary File Description.  */
#include "symtab.h"
#include "gdbtypes.h"
#include "expression.h"
#include "value.h"
#include "gdbcore.h"
#include "target.h"
#include "language.h"
#include "demangle.h"
#include "c-lang.h"
#include "typeprint.h"
#include "cp-abi.h"
#include "jv-lang.h"
#include "gdb_string.h"
#include <errno.h>
#include "cp-support.h"

static void c_type_print_varspec_prefix (struct type *,
					 struct ui_file *,
					 int, int, int,
					 const struct type_print_options *);

/* Print "const", "volatile", or address space modifiers.  */
static void c_type_print_modifier (struct type *,
				   struct ui_file *,
				   int, int);


/* A callback function for cp_canonicalize_string_full that uses
   find_typedef_in_hash.  */

static const char *
find_typedef_for_canonicalize (struct type *t, void *data)
{
  return find_typedef_in_hash (data, t);
}

/* Print NAME on STREAM.  If the 'raw' field of FLAGS is not set,
   canonicalize NAME using the local typedefs first.  */

static void
print_name_maybe_canonical (const char *name,
			    const struct type_print_options *flags,
			    struct ui_file *stream)
{
  char *s = NULL;

  if (!flags->raw)
    s = cp_canonicalize_string_full (name,
				     find_typedef_for_canonicalize,
				     (void *) flags);

  fputs_filtered (s ? s : name, stream);
  xfree (s);
}



/* LEVEL is the depth to indent lines by.  */

void
c_print_type (struct type *type,
	      const char *varstring,
	      struct ui_file *stream,
	      int show, int level,
	      const struct type_print_options *flags)
{
  enum type_code code;
  int demangled_args;
  int need_post_space;
  const char *local_name;

  if (show > 0)
    CHECK_TYPEDEF (type);

  local_name = find_typedef_in_hash (flags, type);
  if (local_name != NULL)
    {
      fputs_filtered (local_name, stream);
      if (varstring != NULL && *varstring != '\0')
	fputs_filtered (" ", stream);
    }
  else
    {
      c_type_print_base (type, stream, show, level, flags);
      code = TYPE_CODE (type);
      if ((varstring != NULL && *varstring != '\0')
	  /* Need a space if going to print stars or brackets;
	     but not if we will print just a type name.  */
	  || ((show > 0 || TYPE_NAME (type) == 0)
	      && (code == TYPE_CODE_PTR || code == TYPE_CODE_FUNC
		  || code == TYPE_CODE_METHOD
		  || (code == TYPE_CODE_ARRAY
		      && !TYPE_VECTOR (type))
		  || code == TYPE_CODE_MEMBERPTR
		  || code == TYPE_CODE_METHODPTR
		  || code == TYPE_CODE_REF)))
	fputs_filtered (" ", stream);
      need_post_space = (varstring != NULL && strcmp (varstring, "") != 0);
      c_type_print_varspec_prefix (type, stream, show, 0, need_post_space,
				   flags);
    }

  if (varstring != NULL)
    {
      fputs_filtered (varstring, stream);

      /* For demangled function names, we have the arglist as part of
         the name, so don't print an additional pair of ()'s.  */
      if (local_name == NULL)
	{
	  demangled_args = strchr (varstring, '(') != NULL;
	  c_type_print_varspec_suffix (type, stream, show,
				       0, demangled_args,
				       flags);
	}
    }
}

/* Print a typedef using C syntax.  TYPE is the underlying type.
   NEW_SYMBOL is the symbol naming the type.  STREAM is the stream on
   which to print.  */

void
c_print_typedef (struct type *type,
		 struct symbol *new_symbol,
		 struct ui_file *stream)
{
  CHECK_TYPEDEF (type);
  fprintf_filtered (stream, "typedef ");
  type_print (type, "", stream, 0);
  if (TYPE_NAME ((SYMBOL_TYPE (new_symbol))) == 0
      || strcmp (TYPE_NAME ((SYMBOL_TYPE (new_symbol))),
		 SYMBOL_LINKAGE_NAME (new_symbol)) != 0
      || TYPE_CODE (SYMBOL_TYPE (new_symbol)) == TYPE_CODE_TYPEDEF)
    fprintf_filtered (stream, " %s", SYMBOL_PRINT_NAME (new_symbol));
  fprintf_filtered (stream, ";\n");
}

/* If TYPE is a derived type, then print out derivation information.
   Print only the actual base classes of this type, not the base
   classes of the base classes.  I.e. for the derivation hierarchy:

   class A { int a; };
   class B : public A {int b; };
   class C : public B {int c; };

   Print the type of class C as:

   class C : public B {
   int c;
   }

   Not as the following (like gdb used to), which is not legal C++
   syntax for derived types and may be confused with the multiple
   inheritance form:

   class C : public B : public A {
   int c;
   }

   In general, gdb should try to print the types as closely as
   possible to the form that they appear in the source code.  */

static void
cp_type_print_derivation_info (struct ui_file *stream,
			       struct type *type,
			       const struct type_print_options *flags)
{
  const char *name;
  int i;

  for (i = 0; i < TYPE_N_BASECLASSES (type); i++)
    {
      wrap_here ("        ");
      fputs_filtered (i == 0 ? ": " : ", ", stream);
      fprintf_filtered (stream, "%s%s ",
			BASETYPE_VIA_PUBLIC (type, i)
			? "public" : (TYPE_FIELD_PROTECTED (type, i)
				      ? "protected" : "private"),
			BASETYPE_VIA_VIRTUAL (type, i) ? " virtual" : "");
      name = type_name_no_tag (TYPE_BASECLASS (type, i));
      if (name)
	print_name_maybe_canonical (name, flags, stream);
      else
	fprintf_filtered (stream, "(null)");
    }
  if (i > 0)
    {
      fputs_filtered (" ", stream);
    }
}

/* Print the C++ method arguments ARGS to the file STREAM.  */

static void
cp_type_print_method_args (struct type *mtype, const char *prefix,
			   const char *varstring, int staticp,
			   struct ui_file *stream,
			   const struct type_print_options *flags)
{
  struct field *args = TYPE_FIELDS (mtype);
  int nargs = TYPE_NFIELDS (mtype);
  int varargs = TYPE_VARARGS (mtype);
  int i;

  fprintf_symbol_filtered (stream, prefix,
			   language_cplus, DMGL_ANSI);
  fprintf_symbol_filtered (stream, varstring,
			   language_cplus, DMGL_ANSI);
  fputs_filtered ("(", stream);

  /* Skip the class variable.  */
  i = staticp ? 0 : 1;
  if (nargs > i)
    {
      while (i < nargs)
	{
	  c_print_type (args[i++].type, "", stream, 0, 0, flags);

	  if (i == nargs && varargs)
	    fprintf_filtered (stream, ", ...");
	  else if (i < nargs)
	    {
	      fprintf_filtered (stream, ", ");
	      wrap_here ("        ");
	    }
	}
    }
  else if (varargs)
    fprintf_filtered (stream, "...");
  else if (current_language->la_language == language_cplus)
    fprintf_filtered (stream, "void");

  fprintf_filtered (stream, ")");

  /* For non-static methods, read qualifiers from the type of
     THIS.  */
  if (!staticp)
    {
      struct type *domain;

      gdb_assert (nargs > 0);
      gdb_assert (TYPE_CODE (args[0].type) == TYPE_CODE_PTR);
      domain = TYPE_TARGET_TYPE (args[0].type);

      if (TYPE_CONST (domain))
	fprintf_filtered (stream, " const");

      if (TYPE_VOLATILE (domain))
	fprintf_filtered (stream, " volatile");

      if (TYPE_RESTRICT (domain))
	fprintf_filtered (stream, " restrict");
    }
}


/* Print any asterisks or open-parentheses needed before the
   variable name (to describe its type).

   On outermost call, pass 0 for PASSED_A_PTR.
   On outermost call, SHOW > 0 means should ignore
   any typename for TYPE and show its details.
   SHOW is always zero on recursive calls.
   
   NEED_POST_SPACE is non-zero when a space will be be needed
   between a trailing qualifier and a field, variable, or function
   name.  */

static void
c_type_print_varspec_prefix (struct type *type,
			     struct ui_file *stream,
			     int show, int passed_a_ptr,
			     int need_post_space,
			     const struct type_print_options *flags)
{
  const char *name;

  if (type == 0)
    return;

  if (TYPE_NAME (type) && show <= 0)
    return;

  QUIT;

  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_PTR:
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type),
				   stream, show, 1, 1, flags);
      fprintf_filtered (stream, "*");
      c_type_print_modifier (type, stream, 1, need_post_space);
      break;

    case TYPE_CODE_MEMBERPTR:
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type),
				   stream, show, 0, 0, flags);
      name = type_name_no_tag (TYPE_DOMAIN_TYPE (type));
      if (name)
	print_name_maybe_canonical (name, flags, stream);
      else
	c_type_print_base (TYPE_DOMAIN_TYPE (type),
			   stream, -1, passed_a_ptr, flags);
      fprintf_filtered (stream, "::*");
      break;

    case TYPE_CODE_METHODPTR:
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type),
				   stream, show, 0, 0, flags);
      fprintf_filtered (stream, "(");
      name = type_name_no_tag (TYPE_DOMAIN_TYPE (type));
      if (name)
	print_name_maybe_canonical (name, flags, stream);
      else
	c_type_print_base (TYPE_DOMAIN_TYPE (type),
			   stream, -1, passed_a_ptr, flags);
      fprintf_filtered (stream, "::*");
      break;

    case TYPE_CODE_REF:
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type),
				   stream, show, 1, 0, flags);
      fprintf_filtered (stream, "&");
      c_type_print_modifier (type, stream, 1, need_post_space);
      break;

    case TYPE_CODE_METHOD:
    case TYPE_CODE_FUNC:
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type),
				   stream, show, 0, 0, flags);
      if (passed_a_ptr)
	fprintf_filtered (stream, "(");
      break;

    case TYPE_CODE_ARRAY:
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type),
				   stream, show, 0, 0, flags);
      if (passed_a_ptr)
	fprintf_filtered (stream, "(");
      break;

    case TYPE_CODE_TYPEDEF:
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type),
				   stream, show, passed_a_ptr, 0, flags);
      break;

    case TYPE_CODE_UNDEF:
    case TYPE_CODE_STRUCT:
    case TYPE_CODE_UNION:
    case TYPE_CODE_ENUM:
    case TYPE_CODE_INT:
    case TYPE_CODE_FLT:
    case TYPE_CODE_VOID:
    case TYPE_CODE_ERROR:
    case TYPE_CODE_CHAR:
    case TYPE_CODE_BOOL:
    case TYPE_CODE_SET:
    case TYPE_CODE_RANGE:
    case TYPE_CODE_STRING:
    case TYPE_CODE_COMPLEX:
    case TYPE_CODE_NAMESPACE:
    case TYPE_CODE_DECFLOAT:
      /* These types need no prefix.  They are listed here so that
         gcc -Wall will reveal any types that haven't been handled.  */
      break;
    default:
      error (_("type not handled in c_type_print_varspec_prefix()"));
      break;
    }
}

/* Print out "const" and "volatile" attributes,
   and address space id if present.
   TYPE is a pointer to the type being printed out.
   STREAM is the output destination.
   NEED_PRE_SPACE = 1 indicates an initial white space is needed.
   NEED_POST_SPACE = 1 indicates a final white space is needed.  */

static void
c_type_print_modifier (struct type *type, struct ui_file *stream,
		       int need_pre_space, int need_post_space)
{
  int did_print_modifier = 0;
  const char *address_space_id;

  /* We don't print `const' qualifiers for references --- since all
     operators affect the thing referenced, not the reference itself,
     every reference is `const'.  */
  if (TYPE_CONST (type)
      && TYPE_CODE (type) != TYPE_CODE_REF)
    {
      if (need_pre_space)
	fprintf_filtered (stream, " ");
      fprintf_filtered (stream, "const");
      did_print_modifier = 1;
    }

  if (TYPE_VOLATILE (type))
    {
      if (did_print_modifier || need_pre_space)
	fprintf_filtered (stream, " ");
      fprintf_filtered (stream, "volatile");
      did_print_modifier = 1;
    }

  if (TYPE_RESTRICT (type))
    {
      if (did_print_modifier || need_pre_space)
	fprintf_filtered (stream, " ");
      fprintf_filtered (stream, "restrict");
      did_print_modifier = 1;
    }

  address_space_id = address_space_int_to_name (get_type_arch (type),
						TYPE_INSTANCE_FLAGS (type));
  if (address_space_id)
    {
      if (did_print_modifier || need_pre_space)
	fprintf_filtered (stream, " ");
      fprintf_filtered (stream, "@@%s", address_space_id);
      did_print_modifier = 1;
    }

  if (did_print_modifier && need_post_space)
    fprintf_filtered (stream, " ");
}


/* Print out the arguments of TYPE, which should have TYPE_CODE_METHOD
   or TYPE_CODE_FUNC, to STREAM.  Artificial arguments, such as "this"
   in non-static methods, are displayed if LINKAGE_NAME is zero.  If
   LINKAGE_NAME is non-zero and LANGUAGE is language_cplus the topmost
   parameter types get removed their possible const and volatile qualifiers to
   match demangled linkage name parameters part of such function type.
   LANGUAGE is the language in which TYPE was defined.  This is a necessary
   evil since this code is used by the C, C++, and Java backends.  */

void
c_type_print_args (struct type *type, struct ui_file *stream,
		   int linkage_name, enum language language,
		   const struct type_print_options *flags)
{
  int i;
  int printed_any = 0;

  fprintf_filtered (stream, "(");

  for (i = 0; i < TYPE_NFIELDS (type); i++)
    {
      struct type *param_type;

      if (TYPE_FIELD_ARTIFICIAL (type, i) && linkage_name)
	continue;

      if (printed_any)
	{
	  fprintf_filtered (stream, ", ");
	  wrap_here ("    ");
	}

      param_type = TYPE_FIELD_TYPE (type, i);

      if (language == language_cplus && linkage_name)
	{
	  /* C++ standard, 13.1 Overloadable declarations, point 3, item:
	     - Parameter declarations that differ only in the presence or
	       absence of const and/or volatile are equivalent.

	     And the const/volatile qualifiers are not present in the mangled
	     names as produced by GCC.  */

	  param_type = make_cv_type (0, 0, param_type, NULL);
	}

      if (language == language_java)
	java_print_type (param_type, "", stream, -1, 0, flags);
      else
	c_print_type (param_type, "", stream, -1, 0, flags);
      printed_any = 1;
    }

  if (printed_any && TYPE_VARARGS (type))
    {
      /* Print out a trailing ellipsis for varargs functions.  Ignore
	 TYPE_VARARGS if the function has no named arguments; that
	 represents unprototyped (K&R style) C functions.  */
      if (printed_any && TYPE_VARARGS (type))
	{
	  fprintf_filtered (stream, ", ");
	  wrap_here ("    ");
	  fprintf_filtered (stream, "...");
	}
    }
  else if (!printed_any
	   && ((TYPE_PROTOTYPED (type) && language != language_java)
	       || language == language_cplus))
    fprintf_filtered (stream, "void");

  fprintf_filtered (stream, ")");
}

/* Return true iff the j'th overloading of the i'th method of TYPE
   is a type conversion operator, like `operator int () { ... }'.
   When listing a class's methods, we don't print the return type of
   such operators.  */

static int
is_type_conversion_operator (struct type *type, int i, int j)
{
  /* I think the whole idea of recognizing type conversion operators
     by their name is pretty terrible.  But I don't think our present
     data structure gives us any other way to tell.  If you know of
     some other way, feel free to rewrite this function.  */
  const char *name = TYPE_FN_FIELDLIST_NAME (type, i);

  if (strncmp (name, "operator", 8) != 0)
    return 0;

  name += 8;
  if (! strchr (" \t\f\n\r", *name))
    return 0;

  while (strchr (" \t\f\n\r", *name))
    name++;

  if (!('a' <= *name && *name <= 'z')
      && !('A' <= *name && *name <= 'Z')
      && *name != '_')
    /* If this doesn't look like the start of an identifier, then it
       isn't a type conversion operator.  */
    return 0;
  else if (strncmp (name, "new", 3) == 0)
    name += 3;
  else if (strncmp (name, "delete", 6) == 0)
    name += 6;
  else
    /* If it doesn't look like new or delete, it's a type conversion
       operator.  */
    return 1;

  /* Is that really the end of the name?  */
  if (('a' <= *name && *name <= 'z')
      || ('A' <= *name && *name <= 'Z')
      || ('0' <= *name && *name <= '9')
      || *name == '_')
    /* No, so the identifier following "operator" must be a type name,
       and this is a type conversion operator.  */
    return 1;

  /* That was indeed the end of the name, so it was `operator new' or
     `operator delete', neither of which are type conversion
     operators.  */
  return 0;
}

/* Given a C++ qualified identifier QID, strip off the qualifiers,
   yielding the unqualified name.  The return value is a pointer into
   the original string.

   It's a pity we don't have this information in some more structured
   form.  Even the author of this function feels that writing little
   parsers like this everywhere is stupid.  */

static char *
remove_qualifiers (char *qid)
{
  int quoted = 0;	/* Zero if we're not in quotes;
			   '"' if we're in a double-quoted string;
			   '\'' if we're in a single-quoted string.  */
  int depth = 0;	/* Number of unclosed parens we've seen.  */
  char *parenstack = (char *) alloca (strlen (qid));
  char *scan;
  char *last = 0;	/* The character after the rightmost
			   `::' token we've seen so far.  */

  for (scan = qid; *scan; scan++)
    {
      if (quoted)
	{
	  if (*scan == quoted)
	    quoted = 0;
	  else if (*scan == '\\' && *(scan + 1))
	    scan++;
	}
      else if (scan[0] == ':' && scan[1] == ':')
	{
	  /* If we're inside parenthesis (i.e., an argument list) or
	     angle brackets (i.e., a list of template arguments), then
	     we don't record the position of this :: token, since it's
	     not relevant to the top-level structure we're trying to
	     operate on.  */
	  if (depth == 0)
	    {
	      last = scan + 2;
	      scan++;
	    }
	}
      else if (*scan == '"' || *scan == '\'')
	quoted = *scan;
      else if (*scan == '(')
	parenstack[depth++] = ')';
      else if (*scan == '[')
	parenstack[depth++] = ']';
      /* We're going to treat <> as a pair of matching characters,
	 since we're more likely to see those in template id's than
	 real less-than characters.  What a crock.  */
      else if (*scan == '<')
	parenstack[depth++] = '>';
      else if (*scan == ')' || *scan == ']' || *scan == '>')
	{
	  if (depth > 0 && parenstack[depth - 1] == *scan)
	    depth--;
	  else
	    {
	      /* We're going to do a little error recovery here.  If
		 we don't find a match for *scan on the paren stack,
		 but there is something lower on the stack that does
		 match, we pop the stack to that point.  */
	      int i;

	      for (i = depth - 1; i >= 0; i--)
		if (parenstack[i] == *scan)
		  {
		    depth = i;
		    break;
		  }
	    }
	}
    }

  if (last)
    return last;
  else
    /* We didn't find any :: tokens at the top level, so declare the
       whole thing an unqualified identifier.  */
    return qid;
}

/* Print any array sizes, function arguments or close parentheses
   needed after the variable name (to describe its type).
   Args work like c_type_print_varspec_prefix.  */

void
c_type_print_varspec_suffix (struct type *type,
			     struct ui_file *stream,
			     int show, int passed_a_ptr,
			     int demangled_args,
			     const struct type_print_options *flags)
{
  if (type == 0)
    return;

  if (TYPE_NAME (type) && show <= 0)
    return;

  QUIT;

  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_ARRAY:
      {
	LONGEST low_bound, high_bound;
	int is_vector = TYPE_VECTOR (type);

	if (passed_a_ptr)
	  fprintf_filtered (stream, ")");

	fprintf_filtered (stream, (is_vector ?
				   " __attribute__ ((vector_size(" : "["));
	if (get_array_bounds (type, &low_bound, &high_bound))
	  fprintf_filtered (stream, "%s", 
			    plongest (high_bound - low_bound + 1));
	fprintf_filtered (stream, (is_vector ? ")))" : "]"));

	c_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream,
				     show, 0, 0, flags);
      }
      break;

    case TYPE_CODE_MEMBERPTR:
      c_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream,
				   show, 0, 0, flags);
      break;

    case TYPE_CODE_METHODPTR:
      fprintf_filtered (stream, ")");
      c_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream,
				   show, 0, 0, flags);
      break;

    case TYPE_CODE_PTR:
    case TYPE_CODE_REF:
      c_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream,
				   show, 1, 0, flags);
      break;

    case TYPE_CODE_METHOD:
    case TYPE_CODE_FUNC:
      if (passed_a_ptr)
	fprintf_filtered (stream, ")");
      if (!demangled_args)
	c_type_print_args (type, stream, 0, current_language->la_language,
			   flags);
      c_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream,
				   show, passed_a_ptr, 0, flags);
      break;

    case TYPE_CODE_TYPEDEF:
      c_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream,
				   show, passed_a_ptr, 0, flags);
      break;

    case TYPE_CODE_UNDEF:
    case TYPE_CODE_STRUCT:
    case TYPE_CODE_UNION:
    case TYPE_CODE_ENUM:
    case TYPE_CODE_INT:
    case TYPE_CODE_FLT:
    case TYPE_CODE_VOID:
    case TYPE_CODE_ERROR:
    case TYPE_CODE_CHAR:
    case TYPE_CODE_BOOL:
    case TYPE_CODE_SET:
    case TYPE_CODE_RANGE:
    case TYPE_CODE_STRING:
    case TYPE_CODE_COMPLEX:
    case TYPE_CODE_NAMESPACE:
    case TYPE_CODE_DECFLOAT:
      /* These types do not need a suffix.  They are listed so that
         gcc -Wall will report types that may not have been
         considered.  */
      break;
    default:
      error (_("type not handled in c_type_print_varspec_suffix()"));
      break;
    }
}

/* A helper for c_type_print_base that displays template
   parameters and their bindings, if needed.

   TABLE is the local bindings table to use.  If NULL, no printing is
   done.  Note that, at this point, TABLE won't have any useful
   information in it -- but it is also used as a flag to
   print_name_maybe_canonical to activate searching the global typedef
   table.

   TYPE is the type whose template arguments are being displayed.

   STREAM is the stream on which to print.  */

static void
c_type_print_template_args (const struct type_print_options *flags,
			    struct type *type, struct ui_file *stream)
{
  int first = 1, i;

  if (flags->raw)
    return;

  for (i = 0; i < TYPE_N_TEMPLATE_ARGUMENTS (type); ++i)
    {
      struct symbol *sym = TYPE_TEMPLATE_ARGUMENT (type, i);

      if (SYMBOL_CLASS (sym) != LOC_TYPEDEF)
	continue;

      if (first)
	{
	  wrap_here ("    ");
	  fprintf_filtered (stream, _("[with %s = "),
			    SYMBOL_LINKAGE_NAME (sym));
	  first = 0;
	}
      else
	{
	  fputs_filtered (", ", stream);
	  wrap_here ("         ");
	  fprintf_filtered (stream, "%s = ", SYMBOL_LINKAGE_NAME (sym));
	}

      c_print_type (SYMBOL_TYPE (sym), "", stream, -1, 0, flags);
    }

  if (!first)
    fputs_filtered (_("] "), stream);
}

/* Print the name of the type (or the ultimate pointer target,
   function value or array element), or the description of a structure
   or union.

   SHOW positive means print details about the type (e.g. enum
   values), and print structure elements passing SHOW - 1 for show.

   SHOW negative means just print the type name or struct tag if there
   is one.  If there is no name, print something sensible but concise
   like "struct {...}".

   SHOW zero means just print the type name or struct tag if there is
   one.  If there is no name, print something sensible but not as
   concise like "struct {int x; int y;}".

   LEVEL is the number of spaces to indent by.
   We increase it for some recursive calls.  */

void
c_type_print_base (struct type *type, struct ui_file *stream,
		   int show, int level, const struct type_print_options *flags)
{
  int i;
  int len, real_len;
  enum
    {
      s_none, s_public, s_private, s_protected
    }
  section_type;
  int need_access_label = 0;
  int j, len2;

  QUIT;

  if (type == NULL)
    {
      fputs_filtered (_("<type unknown>"), stream);
      return;
    }

  /* When SHOW is zero or less, and there is a valid type name, then
     always just print the type name directly from the type.  */
  /* If we have "typedef struct foo {. . .} bar;" do we want to print
     it as "struct foo" or as "bar"?  Pick the latter, because C++
     folk tend to expect things like "class5 *foo" rather than "struct
     class5 *foo".  */

  if (show <= 0
      && TYPE_NAME (type) != NULL)
    {
      c_type_print_modifier (type, stream, 0, 1);
      print_name_maybe_canonical (TYPE_NAME (type), flags, stream);
      return;
    }

  CHECK_TYPEDEF (type);

  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_TYPEDEF:
      /* If we get here, the typedef doesn't have a name, and we
	 couldn't resolve TYPE_TARGET_TYPE.  Not much we can do.  */
      gdb_assert (TYPE_NAME (type) == NULL);
      gdb_assert (TYPE_TARGET_TYPE (type) == NULL);
      fprintf_filtered (stream, _("<unnamed typedef>"));
      break;

    case TYPE_CODE_ARRAY:
    case TYPE_CODE_PTR:
    case TYPE_CODE_MEMBERPTR:
    case TYPE_CODE_REF:
    case TYPE_CODE_FUNC:
    case TYPE_CODE_METHOD:
    case TYPE_CODE_METHODPTR:
      c_type_print_base (TYPE_TARGET_TYPE (type),
			 stream, show, level, flags);
      break;

    case TYPE_CODE_STRUCT:
    case TYPE_CODE_UNION:
      {
	struct type_print_options local_flags = *flags;
	struct type_print_options semi_local_flags = *flags;
	struct cleanup *local_cleanups = make_cleanup (null_cleanup, NULL);

	local_flags.local_typedefs = NULL;
	semi_local_flags.local_typedefs = NULL;

	if (!flags->raw)
	  {
	    if (flags->local_typedefs)
	      local_flags.local_typedefs
		= copy_typedef_hash (flags->local_typedefs);
	    else
	      local_flags.local_typedefs = create_typedef_hash ();

	    make_cleanup_free_typedef_hash (local_flags.local_typedefs);
	  }

	c_type_print_modifier (type, stream, 0, 1);
	if (TYPE_CODE (type) == TYPE_CODE_UNION)
	  fprintf_filtered (stream, "union ");
	else if (TYPE_DECLARED_CLASS (type))
	  fprintf_filtered (stream, "class ");
	else
	  fprintf_filtered (stream, "struct ");

	/* Print the tag if it exists.  The HP aCC compiler emits a
	   spurious "{unnamed struct}"/"{unnamed union}"/"{unnamed
	   enum}" tag for unnamed struct/union/enum's, which we don't
	   want to print.  */
	if (TYPE_TAG_NAME (type) != NULL
	    && strncmp (TYPE_TAG_NAME (type), "{unnamed", 8))
	  {
	    /* When printing the tag name, we are still effectively
	       printing in the outer context, hence the use of FLAGS
	       here.  */
	    print_name_maybe_canonical (TYPE_TAG_NAME (type), flags, stream);
	    if (show > 0)
	      fputs_filtered (" ", stream);
	  }

	if (show < 0)
	  {
	    /* If we just printed a tag name, no need to print anything
	       else.  */
	    if (TYPE_TAG_NAME (type) == NULL)
	      fprintf_filtered (stream, "{...}");
	  }
	else if (show > 0 || TYPE_TAG_NAME (type) == NULL)
	  {
	    struct type *basetype;
	    int vptr_fieldno;

	    c_type_print_template_args (&local_flags, type, stream);

	    /* Add in template parameters when printing derivation info.  */
	    add_template_parameters (local_flags.local_typedefs, type);
	    cp_type_print_derivation_info (stream, type, &local_flags);

	    /* This holds just the global typedefs and the template
	       parameters.  */
	    semi_local_flags.local_typedefs
	      = copy_typedef_hash (local_flags.local_typedefs);
	    if (semi_local_flags.local_typedefs)
	      make_cleanup_free_typedef_hash (semi_local_flags.local_typedefs);

	    /* Now add in the local typedefs.  */
	    recursively_update_typedef_hash (local_flags.local_typedefs, type);

	    fprintf_filtered (stream, "{\n");
	    if (TYPE_NFIELDS (type) == 0 && TYPE_NFN_FIELDS (type) == 0
		&& TYPE_TYPEDEF_FIELD_COUNT (type) == 0)
	      {
		if (TYPE_STUB (type))
		  fprintfi_filtered (level + 4, stream,
				     _("<incomplete type>\n"));
		else
		  fprintfi_filtered (level + 4, stream,
				     _("<no data fields>\n"));
	      }

	    /* Start off with no specific section type, so we can print
	       one for the first field we find, and use that section type
	       thereafter until we find another type.  */

	    section_type = s_none;

	    /* For a class, if all members are private, there's no need
	       for a "private:" label; similarly, for a struct or union
	       masquerading as a class, if all members are public, there's
	       no need for a "public:" label.  */

	    if (TYPE_DECLARED_CLASS (type))
	      {
		QUIT;
		len = TYPE_NFIELDS (type);
		for (i = TYPE_N_BASECLASSES (type); i < len; i++)
		  if (!TYPE_FIELD_PRIVATE (type, i))
		    {
		      need_access_label = 1;
		      break;
		    }
		QUIT;
		if (!need_access_label)
		  {
		    len2 = TYPE_NFN_FIELDS (type);
		    for (j = 0; j < len2; j++)
		      {
			len = TYPE_FN_FIELDLIST_LENGTH (type, j);
			for (i = 0; i < len; i++)
			  if (!TYPE_FN_FIELD_PRIVATE (TYPE_FN_FIELDLIST1 (type,
									  j), i))
			    {
			      need_access_label = 1;
			      break;
			    }
			if (need_access_label)
			  break;
		      }
		  }
	      }
	    else
	      {
		QUIT;
		len = TYPE_NFIELDS (type);
		for (i = TYPE_N_BASECLASSES (type); i < len; i++)
		  if (TYPE_FIELD_PRIVATE (type, i)
		      || TYPE_FIELD_PROTECTED (type, i))
		    {
		      need_access_label = 1;
		      break;
		    }
		QUIT;
		if (!need_access_label)
		  {
		    len2 = TYPE_NFN_FIELDS (type);
		    for (j = 0; j < len2; j++)
		      {
			QUIT;
			len = TYPE_FN_FIELDLIST_LENGTH (type, j);
			for (i = 0; i < len; i++)
			  if (TYPE_FN_FIELD_PROTECTED (TYPE_FN_FIELDLIST1 (type,
									   j), i)
			      || TYPE_FN_FIELD_PRIVATE (TYPE_FN_FIELDLIST1 (type,
									    j),
							i))
			    {
			      need_access_label = 1;
			      break;
			    }
			if (need_access_label)
			  break;
		      }
		  }
	      }

	    /* If there is a base class for this type,
	       do not print the field that it occupies.  */

	    len = TYPE_NFIELDS (type);
	    vptr_fieldno = get_vptr_fieldno (type, &basetype);
	    for (i = TYPE_N_BASECLASSES (type); i < len; i++)
	      {
		QUIT;

		/* If we have a virtual table pointer, omit it.  Even if
		   virtual table pointers are not specifically marked in
		   the debug info, they should be artificial.  */
		if ((i == vptr_fieldno && type == basetype)
		    || TYPE_FIELD_ARTIFICIAL (type, i))
		  continue;

		if (need_access_label)
		  {
		    if (TYPE_FIELD_PROTECTED (type, i))
		      {
			if (section_type != s_protected)
			  {
			    section_type = s_protected;
			    fprintfi_filtered (level + 2, stream,
					       "protected:\n");
			  }
		      }
		    else if (TYPE_FIELD_PRIVATE (type, i))
		      {
			if (section_type != s_private)
			  {
			    section_type = s_private;
			    fprintfi_filtered (level + 2, stream,
					       "private:\n");
			  }
		      }
		    else
		      {
			if (section_type != s_public)
			  {
			    section_type = s_public;
			    fprintfi_filtered (level + 2, stream,
					       "public:\n");
			  }
		      }
		  }

		print_spaces_filtered (level + 4, stream);
		if (field_is_static (&TYPE_FIELD (type, i)))
		  fprintf_filtered (stream, "static ");
		c_print_type (TYPE_FIELD_TYPE (type, i),
			      TYPE_FIELD_NAME (type, i),
			      stream, show - 1, level + 4,
			      &local_flags);
		if (!field_is_static (&TYPE_FIELD (type, i))
		    && TYPE_FIELD_PACKED (type, i))
		  {
		    /* It is a bitfield.  This code does not attempt
		       to look at the bitpos and reconstruct filler,
		       unnamed fields.  This would lead to misleading
		       results if the compiler does not put out fields
		       for such things (I don't know what it does).  */
		    fprintf_filtered (stream, " : %d",
				      TYPE_FIELD_BITSIZE (type, i));
		  }
		fprintf_filtered (stream, ";\n");
	      }

	  /* If there are both fields and methods, put a blank line
	     between them.  Make sure to count only method that we
	     will display; artificial methods will be hidden.  */
	  len = TYPE_NFN_FIELDS (type);
	  if (!flags->print_methods)
	    len = 0;
	  real_len = 0;
	  for (i = 0; i < len; i++)
	    {
	      struct fn_field *f = TYPE_FN_FIELDLIST1 (type, i);
	      int len2 = TYPE_FN_FIELDLIST_LENGTH (type, i);
	      int j;

	      for (j = 0; j < len2; j++)
		if (!TYPE_FN_FIELD_ARTIFICIAL (f, j))
		  real_len++;
	    }
	  if (real_len > 0 && section_type != s_none)
	    fprintf_filtered (stream, "\n");

	  /* C++: print out the methods.  */
	  for (i = 0; i < len; i++)
	    {
	      struct fn_field *f = TYPE_FN_FIELDLIST1 (type, i);
	      int j, len2 = TYPE_FN_FIELDLIST_LENGTH (type, i);
	      const char *method_name = TYPE_FN_FIELDLIST_NAME (type, i);
	      const char *name = type_name_no_tag (type);
	      int is_constructor = name && strcmp (method_name,
						   name) == 0;

	      for (j = 0; j < len2; j++)
		{
		  const char *mangled_name;
		  char *demangled_name;
		  struct cleanup *inner_cleanup;
		  const char *physname = TYPE_FN_FIELD_PHYSNAME (f, j);
		  int is_full_physname_constructor =
		    TYPE_FN_FIELD_CONSTRUCTOR (f, j)
		    || is_constructor_name (physname)
		    || is_destructor_name (physname)
		    || method_name[0] == '~';

		  /* Do not print out artificial methods.  */
		  if (TYPE_FN_FIELD_ARTIFICIAL (f, j))
		    continue;

		  inner_cleanup = make_cleanup (null_cleanup, NULL);

		  QUIT;
		  if (TYPE_FN_FIELD_PROTECTED (f, j))
		    {
		      if (section_type != s_protected)
			{
			  section_type = s_protected;
			  fprintfi_filtered (level + 2, stream,
					     "protected:\n");
			}
		    }
		  else if (TYPE_FN_FIELD_PRIVATE (f, j))
		    {
		      if (section_type != s_private)
			{
			  section_type = s_private;
			  fprintfi_filtered (level + 2, stream,
					     "private:\n");
			}
		    }
		  else
		    {
		      if (section_type != s_public)
			{
			  section_type = s_public;
			  fprintfi_filtered (level + 2, stream,
					     "public:\n");
			}
		    }

		  print_spaces_filtered (level + 4, stream);
		  if (TYPE_FN_FIELD_VIRTUAL_P (f, j))
		    fprintf_filtered (stream, "virtual ");
		  else if (TYPE_FN_FIELD_STATIC_P (f, j))
		    fprintf_filtered (stream, "static ");
		  if (TYPE_TARGET_TYPE (TYPE_FN_FIELD_TYPE (f, j)) == 0)
		    {
		      /* Keep GDB from crashing here.  */
		      fprintf_filtered (stream,
					_("<undefined type> %s;\n"),
					TYPE_FN_FIELD_PHYSNAME (f, j));
		      break;
		    }
		  else if (!is_constructor	/* Constructors don't
						   have declared
						   types.  */
			   && !is_full_physname_constructor  /* " " */
			   && !is_type_conversion_operator (type, i, j))
		    {
		      c_print_type (TYPE_TARGET_TYPE (TYPE_FN_FIELD_TYPE (f, j)),
				    "", stream, -1, 0,
				    &local_flags);
		      fputs_filtered (" ", stream);
		    }
		  if (TYPE_FN_FIELD_STUB (f, j))
		    {
		      char *tem;

		      /* Build something we can demangle.  */
		      tem = gdb_mangle_name (type, i, j);
		      make_cleanup (xfree, tem);
		      mangled_name = tem;
		    }
		  else
		    mangled_name = TYPE_FN_FIELD_PHYSNAME (f, j);

		  demangled_name =
		    gdb_demangle (mangled_name,
				  DMGL_ANSI | DMGL_PARAMS);
		  if (demangled_name == NULL)
		    {
		      /* In some cases (for instance with the HP
			 demangling), if a function has more than 10
			 arguments, the demangling will fail.
			 Let's try to reconstruct the function
			 signature from the symbol information.  */
		      if (!TYPE_FN_FIELD_STUB (f, j))
			{
			  int staticp = TYPE_FN_FIELD_STATIC_P (f, j);
			  struct type *mtype = TYPE_FN_FIELD_TYPE (f, j);

			  cp_type_print_method_args (mtype,
						     "",
						     method_name,
						     staticp,
						     stream, &local_flags);
			}
		      else
			fprintf_filtered (stream,
					  _("<badly mangled name '%s'>"),
					  mangled_name);
		    }
		  else
		    {
		      char *p;
		      char *demangled_no_class
			= remove_qualifiers (demangled_name);

		      /* Get rid of the `static' appended by the
			 demangler.  */
		      p = strstr (demangled_no_class, " static");
		      if (p != NULL)
			{
			  int length = p - demangled_no_class;
			  char *demangled_no_static;

			  demangled_no_static
			    = (char *) xmalloc (length + 1);
			  strncpy (demangled_no_static,
				   demangled_no_class, length);
			  *(demangled_no_static + length) = '\0';
			  fputs_filtered (demangled_no_static, stream);
			  xfree (demangled_no_static);
			}
		      else
			fputs_filtered (demangled_no_class, stream);
		      xfree (demangled_name);
		    }

		  do_cleanups (inner_cleanup);

		  fprintf_filtered (stream, ";\n");
		}
	    }

	  /* Print typedefs defined in this class.  */

	  if (TYPE_TYPEDEF_FIELD_COUNT (type) != 0 && flags->print_typedefs)
	    {
	      if (TYPE_NFIELDS (type) != 0 || TYPE_NFN_FIELDS (type) != 0)
		fprintf_filtered (stream, "\n");

		for (i = 0; i < TYPE_TYPEDEF_FIELD_COUNT (type); i++)
		  {
		    struct type *target = TYPE_TYPEDEF_FIELD_TYPE (type, i);

		    /* Dereference the typedef declaration itself.  */
		    gdb_assert (TYPE_CODE (target) == TYPE_CODE_TYPEDEF);
		    target = TYPE_TARGET_TYPE (target);

		    print_spaces_filtered (level + 4, stream);
		    fprintf_filtered (stream, "typedef ");

		    /* We want to print typedefs with substitutions
		       from the template parameters or globally-known
		       typedefs but not local typedefs.  */
		    c_print_type (target,
				  TYPE_TYPEDEF_FIELD_NAME (type, i),
				  stream, show - 1, level + 4,
				  &semi_local_flags);
		    fprintf_filtered (stream, ";\n");
		  }
	      }

	    fprintfi_filtered (level, stream, "}");
	  }

	do_cleanups (local_cleanups);
      }
      break;

    case TYPE_CODE_ENUM:
      c_type_print_modifier (type, stream, 0, 1);
      fprintf_filtered (stream, "enum ");
      /* Print the tag name if it exists.
         The aCC compiler emits a spurious 
         "{unnamed struct}"/"{unnamed union}"/"{unnamed enum}"
         tag for unnamed struct/union/enum's, which we don't
         want to print.  */
      if (TYPE_TAG_NAME (type) != NULL
	  && strncmp (TYPE_TAG_NAME (type), "{unnamed", 8))
	{
	  print_name_maybe_canonical (TYPE_TAG_NAME (type), flags, stream);
	  if (show > 0)
	    fputs_filtered (" ", stream);
	}

      wrap_here ("    ");
      if (show < 0)
	{
	  /* If we just printed a tag name, no need to print anything
	     else.  */
	  if (TYPE_TAG_NAME (type) == NULL)
	    fprintf_filtered (stream, "{...}");
	}
      else if (show > 0 || TYPE_TAG_NAME (type) == NULL)
	{
	  LONGEST lastval = 0;

	  fprintf_filtered (stream, "{");
	  len = TYPE_NFIELDS (type);
	  for (i = 0; i < len; i++)
	    {
	      QUIT;
	      if (i)
		fprintf_filtered (stream, ", ");
	      wrap_here ("    ");
	      fputs_filtered (TYPE_FIELD_NAME (type, i), stream);
	      if (lastval != TYPE_FIELD_ENUMVAL (type, i))
		{
		  fprintf_filtered (stream, " = %s",
				    plongest (TYPE_FIELD_ENUMVAL (type, i)));
		  lastval = TYPE_FIELD_ENUMVAL (type, i);
		}
	      lastval++;
	    }
	  fprintf_filtered (stream, "}");
	}
      break;

    case TYPE_CODE_VOID:
      fprintf_filtered (stream, "void");
      break;

    case TYPE_CODE_UNDEF:
      fprintf_filtered (stream, _("struct <unknown>"));
      break;

    case TYPE_CODE_ERROR:
      fprintf_filtered (stream, "%s", TYPE_ERROR_NAME (type));
      break;

    case TYPE_CODE_RANGE:
      /* This should not occur.  */
      fprintf_filtered (stream, _("<range type>"));
      break;

    case TYPE_CODE_NAMESPACE:
      fputs_filtered ("namespace ", stream);
      fputs_filtered (TYPE_TAG_NAME (type), stream);
      break;

    default:
      /* Handle types not explicitly handled by the other cases, such
         as fundamental types.  For these, just print whatever the
         type name is, as recorded in the type itself.  If there is no
         type name, then complain.  */
      if (TYPE_NAME (type) != NULL)
	{
	  c_type_print_modifier (type, stream, 0, 1);
	  print_name_maybe_canonical (TYPE_NAME (type), flags, stream);
	}
      else
	{
	  /* At least for dump_symtab, it is important that this not
	     be an error ().  */
	  fprintf_filtered (stream, _("<invalid type code %d>"),
			    TYPE_CODE (type));
	}
      break;
    }
}
@


1.91
log
@2013-01-31  Aleksandar Ristovski  <aristovski@@qnx.com>

	* c-exp.y (classify_inner_name): Remove unused type.
	* c-lang.c (c_printstr): Remove unused byte_order, i, things_printed,
	in_quotes, need_comma, wchar_buf, output, cleanup, iter, finished,
	need_escape.
	(c_get_string): Remove unused kind.
	* c-typeprint.c (c_type_print_args): Remove unused i, len, args, table2.

Reference: http://sourceware.org/ml/gdb-patches/2013-01/msg00759.html
@
text
@d1230 2
a1231 2
		    cplus_demangle (mangled_name,
				    DMGL_ANSI | DMGL_PARAMS);
@


1.90
log
@	PR symtab/14442:
	* c-typeprint.c (cp_type_print_method_args): Handle 'restrict'.
	(c_type_print_modifier): Likewise.
	* dwarf2read.c (read_tag_restrict_type): New function.
	(read_type_die_1): Handle DW_TAG_restrict_type.
	* gdbtypes.c (make_restrict_type): New function.
	(recursive_dump_type): Handle TYPE_RESTRICT.
	* gdbtypes.h (enum type_flag_values): Renumber.
	(enum type_instance_flag_value): Add
	TYPE_INSTANCE_FLAG_RESTRICT.
	(TYPE_RESTRICT): New macro.
	(make_restrict_type): Declare.
gdb/testsuite
	* gdb.dwarf2/dw2-restrict.S: New file.
	* gdb.dwarf2/dw2-restrict.c: New file.
	* gdb.dwarf2/dw2-restrict.exp: New file.
@
text
@d465 1
a465 2
  int i, len;
  struct field *args;
a468 2
  args = TYPE_FIELDS (type);
  len = TYPE_NFIELDS (type);
a1297 1
		    struct typedef_hash_table *table2;
@


1.89
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d272 3
d428 8
@


1.88
log
@	Partial fix for PR c++/14160:
	* c-typeprint.c (c_type_print_base): Use TYPE_FN_FIELD_CONSTRUCTOR.
	* dwarf2read.c (dwarf2_is_constructor): New function.
	(dwarf2_add_member_fn): Use it.
	* gnu-v3-abi.c (gnuv3_pass_by_reference): Use
	TYPE_FN_FIELD_CONSTRUCTOR.
	* jv-typeprint.c (java_type_print_base): Use
	TYPE_FN_FIELD_CONSTRUCTOR.
	* gdbtypes.h (struct fn_field) <is_constructor>: New field.
	<dummy>: Shrink.
	(TYPE_FN_FIELD_CONSTRUCTOR): New macro.
testsuite
	* gdb.cp/templates.exp (test_ptype_of_templates): Update kfails.
@
text
@d2 1
a2 2
   Copyright (C) 1986, 1988-1989, 1991-1996, 1998-2003, 2006-2012 Free
   Software Foundation, Inc.
@


1.87
log
@	* gdbtypes.h (struct cplus_struct_type) <localtype_ptr>: Remove
	field.
	(TYPE_LOCALTYPE_PTR, TYPE_LOCALTYPE_FILE, TYPE_LOCALTYPE_LINE):
	Remove.
	* c-typeprint.c (c_type_print_base): Update.
@
text
@d1146 2
a1147 1
		    is_constructor_name (physname) 
@


1.86
log
@	* c-typeprint.c (find_typedef_for_canonicalize,
	print_name_maybe_canonical): New functions.
	(c_print_type): Look up type name.
	(cp_type_print_derivation_info): Add flags argument.  Use
	print_name_maybe_canonical.
	(cp_type_print_method_args): Add wrapping.
	(c_type_print_varspec_prefix): Use print_name_maybe_canonical.
	(c_type_print_template_args): New function.
	(c_type_print_base): Change wrapping.  Use
	print_name_maybe_canonical.
	<TYPE_CODE_STRUCT>: Possibly create a typedef hash, and do
	type name lookups.
	* gdbtypes.c (types_equal): No longer static.
	* gdbtypes.h (types_equal): Declare.
	* typeprint.c (type_print_raw_options, default_ptype_flags):
	Update.
	(struct typedef_hash_table): New.
	(hash_typedef_field, eq_typedef_field,
	recursively_update_typedef_hash, add_template_parameters,
	create_typedef_hash, free_typedef_hash, do_free_typedef_hash,
	make_cleanup_free_typedef_hash, copy_typedef_hash_element,
	copy_typedef_hash, find_typedef_in_hash): New functions.
	* typeprint.h (struct type_print_options) <local_typedefs>:
	New field.
	(recursively_update_typedef_hash, add_template_parameters,
	create_typedef_hash, free_typedef_hash,
	make_cleanup_free_typedef_hash, copy_typedef_hash,
	find_typedef_in_hash): Declare.
testsuite
	* gdb.base/call-sc.exp: Use "ptype/r".
	* gdb.base/volatile.exp: Don't expect "int".
	* gdb.cp/ptype-flags.cc: New file.
	* gdb.cp/ptype-flags.exp: New file.
	* gdb.cp/templates.exp: Use ptype/r.
	(test_ptype_of_templates, test_template_typedef): Likewise.
	* lib/cp-support.exp (cp_test_ptype_class): Add in_ptype_arg
	argument.  Handle template names and template parameters.
	* gdb.mi/mi-var-cmd.exp: Accept "long".
	* gdb.mi/mi-var-child.exp: Accept "long".
	* gdb.mi/mi-var-display.exp: Accept "long".
	* gdb.mi/mi2-var-child.exp: Accept "long".
@
text
@a1310 6

	    if (TYPE_LOCALTYPE_PTR (type) && show >= 0)
	      fprintfi_filtered (level,
				 stream, _(" (Local at %s:%d)\n"),
				 TYPE_LOCALTYPE_FILE (type),
				 TYPE_LOCALTYPE_LINE (type));
@


1.85
log
@	* NEWS: Update.
	* c-typeprint.c (c_type_print_base): Handle print_method and
	print_typedefs flags.
	* gdbcmd.h (setprinttypelist, showprinttypelist): Declare.
	* python/py-type.c (typy_str): Use LA_PRINT_TYPE and raw
	options.
	* typeprint.c (type_print_raw_options, default_ptype_flags):
	Update for new field.s
	(whatis_exp): Parse flags.  Use LA_PRINT_TYPE.
	(setprinttypelist, showprinttypelist, print_methods,
	print_typedefs): New globals.
	(set_print_type, show_print_type, set_print_type_methods,
	show_print_type_methods, set_print_type_typedefs,
	show_print_type_typedefs): New functions.
	(_initialize_typeprint): Update documentation.  Add "print
	type methods" and "print type typedefs" parameters.
	* typeprint.h (struct type_print_options) <print_methods,
	print_typedefs>: New fields.
doc
	* gdb.texinfo (Symbols): Document "set print type methods",
	"set print type typedefs", and flags to ptype and whatis.
@
text
@d37 1
d49 31
d92 1
d97 27
a123 17
  c_type_print_base (type, stream, show, level, flags);
  code = TYPE_CODE (type);
  if ((varstring != NULL && *varstring != '\0')
  /* Need a space if going to print stars or brackets;
     but not if we will print just a type name.  */
      || ((show > 0 || TYPE_NAME (type) == 0)
	  && (code == TYPE_CODE_PTR || code == TYPE_CODE_FUNC
	      || code == TYPE_CODE_METHOD
	      || (code == TYPE_CODE_ARRAY
		  && !TYPE_VECTOR (type))
	      || code == TYPE_CODE_MEMBERPTR
	      || code == TYPE_CODE_METHODPTR
	      || code == TYPE_CODE_REF)))
    fputs_filtered (" ", stream);
  need_post_space = (varstring != NULL && strcmp (varstring, "") != 0);
  c_type_print_varspec_prefix (type, stream, show, 0, need_post_space,
			       flags);
d131 7
a137 4

      demangled_args = strchr (varstring, '(') != NULL;
      c_type_print_varspec_suffix (type, stream, show,
				   0, demangled_args, flags);
d188 2
a189 1
			       struct type *type)
d196 1
d204 4
a207 1
      fprintf_filtered (stream, "%s", name ? name : "(null)");
d245 4
a248 1
	    fprintf_filtered (stream, ", ");
d320 1
a320 1
	fputs_filtered (name, stream);
d333 1
a333 1
	fputs_filtered (name, stream);
d754 50
a837 1
  wrap_here ("    ");
d855 1
a855 1
      fputs_filtered (TYPE_NAME (type), stream);
d884 105
a988 63
      c_type_print_modifier (type, stream, 0, 1);
      if (TYPE_CODE (type) == TYPE_CODE_UNION)
	fprintf_filtered (stream, "union ");
      else if (TYPE_DECLARED_CLASS (type))
	fprintf_filtered (stream, "class ");
      else
	fprintf_filtered (stream, "struct ");

      /* Print the tag if it exists.  The HP aCC compiler emits a
         spurious "{unnamed struct}"/"{unnamed union}"/"{unnamed
         enum}" tag for unnamed struct/union/enum's, which we don't
         want to print.  */
      if (TYPE_TAG_NAME (type) != NULL
	  && strncmp (TYPE_TAG_NAME (type), "{unnamed", 8))
	{
	  fputs_filtered (TYPE_TAG_NAME (type), stream);
	  if (show > 0)
	    fputs_filtered (" ", stream);
	}
      wrap_here ("    ");
      if (show < 0)
	{
	  /* If we just printed a tag name, no need to print anything
	     else.  */
	  if (TYPE_TAG_NAME (type) == NULL)
	    fprintf_filtered (stream, "{...}");
	}
      else if (show > 0 || TYPE_TAG_NAME (type) == NULL)
	{
	  struct type *basetype;
	  int vptr_fieldno;

	  cp_type_print_derivation_info (stream, type);

	  fprintf_filtered (stream, "{\n");
	  if (TYPE_NFIELDS (type) == 0 && TYPE_NFN_FIELDS (type) == 0
	      && TYPE_TYPEDEF_FIELD_COUNT (type) == 0)
	    {
	      if (TYPE_STUB (type))
		fprintfi_filtered (level + 4, stream,
				   _("<incomplete type>\n"));
	      else
		fprintfi_filtered (level + 4, stream,
				   _("<no data fields>\n"));
	    }

	  /* Start off with no specific section type, so we can print
	     one for the first field we find, and use that section type
	     thereafter until we find another type.  */

	  section_type = s_none;

	  /* For a class, if all members are private, there's no need
	     for a "private:" label; similarly, for a struct or union
	     masquerading as a class, if all members are public, there's
	     no need for a "public:" label.  */

	  if (TYPE_DECLARED_CLASS (type))
	    {
	      QUIT;
	      len = TYPE_NFIELDS (type);
	      for (i = TYPE_N_BASECLASSES (type); i < len; i++)
		if (!TYPE_FIELD_PRIVATE (type, i))
d990 14
a1003 2
		    need_access_label = 1;
		    break;
d1005 8
a1012 5
	      QUIT;
	      if (!need_access_label)
		{
		  len2 = TYPE_NFN_FIELDS (type);
		  for (j = 0; j < len2; j++)
d1014 2
a1015 10
		      len = TYPE_FN_FIELDLIST_LENGTH (type, j);
		      for (i = 0; i < len; i++)
			if (!TYPE_FN_FIELD_PRIVATE (TYPE_FN_FIELDLIST1 (type,
									j), i))
			  {
			    need_access_label = 1;
			    break;
			  }
		      if (need_access_label)
			break;
d1017 2
a1018 9
		}
	    }
	  else
	    {
	      QUIT;
	      len = TYPE_NFIELDS (type);
	      for (i = TYPE_N_BASECLASSES (type); i < len; i++)
		if (TYPE_FIELD_PRIVATE (type, i)
		    || TYPE_FIELD_PROTECTED (type, i))
d1020 18
a1037 2
		    need_access_label = 1;
		    break;
d1039 1
a1039 23
	      QUIT;
	      if (!need_access_label)
		{
		  len2 = TYPE_NFN_FIELDS (type);
		  for (j = 0; j < len2; j++)
		    {
		      QUIT;
		      len = TYPE_FN_FIELDLIST_LENGTH (type, j);
		      for (i = 0; i < len; i++)
			if (TYPE_FN_FIELD_PROTECTED (TYPE_FN_FIELDLIST1 (type,
									 j), i)
			    || TYPE_FN_FIELD_PRIVATE (TYPE_FN_FIELDLIST1 (type,
									  j),
						      i))
			  {
			    need_access_label = 1;
			    break;
			  }
		      if (need_access_label)
			break;
		    }
		}
	    }
d1041 2
a1042 2
	  /* If there is a base class for this type,
	     do not print the field that it occupies.  */
d1044 12
a1055 5
	  len = TYPE_NFIELDS (type);
	  vptr_fieldno = get_vptr_fieldno (type, &basetype);
	  for (i = TYPE_N_BASECLASSES (type); i < len; i++)
	    {
	      QUIT;
d1057 30
a1086 6
	      /* If we have a virtual table pointer, omit it.  Even if
		 virtual table pointers are not specifically marked in
		 the debug info, they should be artificial.  */
	      if ((i == vptr_fieldno && type == basetype)
		  || TYPE_FIELD_ARTIFICIAL (type, i))
		continue;
d1088 20
a1107 50
	      if (need_access_label)
		{
		  if (TYPE_FIELD_PROTECTED (type, i))
		    {
		      if (section_type != s_protected)
			{
			  section_type = s_protected;
			  fprintfi_filtered (level + 2, stream,
					     "protected:\n");
			}
		    }
		  else if (TYPE_FIELD_PRIVATE (type, i))
		    {
		      if (section_type != s_private)
			{
			  section_type = s_private;
			  fprintfi_filtered (level + 2, stream,
					     "private:\n");
			}
		    }
		  else
		    {
		      if (section_type != s_public)
			{
			  section_type = s_public;
			  fprintfi_filtered (level + 2, stream,
					     "public:\n");
			}
		    }
		}

	      print_spaces_filtered (level + 4, stream);
	      if (field_is_static (&TYPE_FIELD (type, i)))
		fprintf_filtered (stream, "static ");
	      c_print_type (TYPE_FIELD_TYPE (type, i),
			    TYPE_FIELD_NAME (type, i),
			    stream, show - 1, level + 4, flags);
	      if (!field_is_static (&TYPE_FIELD (type, i))
		  && TYPE_FIELD_PACKED (type, i))
		{
		  /* It is a bitfield.  This code does not attempt
		     to look at the bitpos and reconstruct filler,
		     unnamed fields.  This would lead to misleading
		     results if the compiler does not put out fields
		     for such things (I don't know what it does).  */
		  fprintf_filtered (stream, " : %d",
				    TYPE_FIELD_BITSIZE (type, i));
		}
	      fprintf_filtered (stream, ";\n");
	    }
d1205 2
a1206 1
				    "", stream, -1, 0, flags);
d1227 4
a1230 4
		         demangling), if a function has more than 10
		         arguments, the demangling will fail.
		         Let's try to reconstruct the function
		         signature from the symbol information.  */
d1240 1
a1240 1
						     stream, flags);
d1287 4
a1290 3
	      for (i = 0; i < TYPE_TYPEDEF_FIELD_COUNT (type); i++)
		{
		  struct type *target = TYPE_TYPEDEF_FIELD_TYPE (type, i);
d1292 17
a1308 3
		  /* Dereference the typedef declaration itself.  */
		  gdb_assert (TYPE_CODE (target) == TYPE_CODE_TYPEDEF);
		  target = TYPE_TARGET_TYPE (target);
d1310 1
a1310 7
		  print_spaces_filtered (level + 4, stream);
		  fprintf_filtered (stream, "typedef ");
		  c_print_type (target, TYPE_TYPEDEF_FIELD_NAME (type, i),
				stream, show - 1, level + 4, flags);
		  fprintf_filtered (stream, ";\n");
		}
	    }
d1312 6
a1317 1
	  fprintfi_filtered (level, stream, "}");
d1319 2
a1320 6
	  if (TYPE_LOCALTYPE_PTR (type) && show >= 0)
	    fprintfi_filtered (level,
			       stream, _(" (Local at %s:%d)\n"),
			       TYPE_LOCALTYPE_FILE (type),
			       TYPE_LOCALTYPE_LINE (type));
	}
d1334 1
a1334 1
	  fputs_filtered (TYPE_TAG_NAME (type), stream);
d1402 1
a1402 1
	  fputs_filtered (TYPE_NAME (type), stream);
@


1.84
log
@	* c-typeprint.c (cp_type_print_method_args): Add flags
	argument.  Call c_print_type, not type_print.
	(c_type_print_base): Call c_print_type, not type_print.
	Update.
@
text
@d973 2
d1141 1
a1141 1
	  if (TYPE_TYPEDEF_FIELD_COUNT (type) != 0)
@


1.83
log
@	* ada-lang.c (user_select_syms, ada_print_subexp): Pass flags
	to type-printing functions.
	* ada-lang.h (ada_print_type): Add argument.
	* ada-typeprint.c (print_array_type, print_variant_clauses,
	print_variant_part, print_selected_record_field_types,
	print_record_field_types, print_unchecked_union_type,
	print_func_type, ada_print_type): Add flags argument.
	(ada_print_typedef): Update.
	* c-exp.y (OPERATOR conversion_type_id): Update.
	* c-lang.h (c_print_type, c_type_print_base): Update.
	* c-typeprint.c (c_print_type, c_type_print_varspec_prefix,
	c_type_print_modifier, c_type_print_args,
	c_type_print_varspec_suffix, c_type_print_base): Add flags
	argument.
	* cp-valprint.c (cp_print_class_member): Update.
	* dwarf2read.c (dwarf2_compute_name): Update.
	* f-lang.h (f_print_type): Add argument.
	* f-typeprint.c (f_print_type): Add flags argument.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update.
	* go-lang.h (go_print_type): Add argument.
	* go-typeprint.c (go_print_type): Add flags argument.
	* jv-lang.h (java_print_type): Add argument.
	* jv-typeprint.c (java_type_print_base, java_print_type): Add
	flags argument.
	* language.c (unk_lang_print_type): Add flags argument.
	* language.h (struct language_defn) <la_print_type>: Add flags
	argument.
	(LA_PRINT_TYPE): Likewise.
	* m2-lang.h (m2_print_type): Add argument.
	* m2-typeprint.c (m2_print_type, m2_range, m2_typedef,
	m2_array, m2_pointer, m2_ref, m2_procedure, m2_long_set,
	m2_unbounded_array, m2_record_fields): Add flags argument.
	* p-lang.h (pascal_print_type, pascal_type_print_base,
	pascal_type_print_varspec_prefix): Add argument.
	* p-typeprint.c (pascal_print_type,
	pascal_type_print_varspec_prefix, pascal_print_func_args,
	pascal_type_print_varspec_suffix, pascal_type_print_base): Add
	flags argument.
	* symmisc.c (print_symbol): Update.
	* typeprint.c (type_print_raw_options, default_ptype_flags):
	New globals.
	(type_print): Update.
	* typeprint.h (struct type_print_options): New.
	(type_print_raw_options): Declare.
	(c_type_print_varspec_suffix, c_type_print_args): Add argument.
@
text
@d169 2
a170 1
			   struct ui_file *stream)
d189 1
a189 1
	  type_print (args[i++].type, "", stream, 0);
d1062 2
a1063 2
		      type_print (TYPE_TARGET_TYPE (TYPE_FN_FIELD_TYPE (f, j)),
				  "", stream, -1);
d1097 1
a1097 1
						     stream);
@


1.82
log
@http://sourceware.org/ml/gdb-patches/2012-10/msg00525.html

gdb/ChangeLog

        PR cli/14772
        * c-typeprint.c (c_print_type): Don't print a space for vector
        types, this is handled within the suffix.
        (c_type_print_varspec_suffix): Add a space to vector suffix

gdb/testsuite/ChangeLog

        PR cli/14772
        * gdb.base/gnu_vector.c (union_with_vector_1)
        (struct_with_vector_1): Add new struct and union for testing
        ptype.
        * gdb.base/gnu_vector.exp: Add testing of ptype on vectors, and
        structs / unions containing vectors.
@
text
@d40 2
a41 1
					 int, int, int);
d54 2
a55 1
	      int show, int level)
d64 1
a64 1
  c_type_print_base (type, stream, show, level);
d79 2
a80 1
  c_type_print_varspec_prefix (type, stream, show, 0, need_post_space);
d91 1
a91 1
				   0, demangled_args);
d238 2
a239 1
			     int need_post_space)
d255 1
a255 1
				   stream, show, 1, 1);
d262 1
a262 1
				   stream, show, 0, 0);
d268 1
a268 1
			   stream, -1, passed_a_ptr);
d274 1
a274 1
				   stream, show, 0, 0);
d281 1
a281 1
			   stream, -1, passed_a_ptr);
d287 1
a287 1
				   stream, show, 1, 0);
d295 1
a295 1
				   stream, show, 0, 0);
d302 1
a302 1
				   stream, show, 0, 0);
d309 1
a309 1
				   stream, show, passed_a_ptr, 0);
d397 2
a398 1
		   int linkage_name, enum language language)
d436 1
a436 1
	java_print_type (param_type, "", stream, -1, 0);
d438 1
a438 1
	c_print_type (param_type, "", stream, -1, 0);
d607 2
a608 1
			     int demangled_args)
d636 1
a636 1
				     show, 0, 0);
d642 1
a642 1
				   show, 0, 0);
d648 1
a648 1
				   show, 0, 0);
d654 1
a654 1
				   show, 1, 0);
d662 2
a663 1
	c_type_print_args (type, stream, 0, current_language->la_language);
d665 1
a665 1
				   show, passed_a_ptr, 0);
d670 1
a670 1
				   show, passed_a_ptr, 0);
d719 1
a719 1
		   int show, int level)
d775 1
a775 1
			 stream, show, level);
d953 1
a953 1
			    stream, show - 1, level + 4);
d1154 1
a1154 1
				stream, show - 1, level + 4);
@


1.81
log
@gdb/ChangeLog:

	* c-typeprint.c (c_type_print_varspec_suffix): Remove cast and
	use plongest to print the array size.

testsuite/ChangeLog:

	* gdb.base/longest-types.c: New test case.
	* gdb.base/longest-types.exp: New test case.
@
text
@d70 2
a71 1
	      || code == TYPE_CODE_ARRAY
d623 1
a623 1
				   "__attribute__ ((vector_size(" : "["));
@


1.80
log
@	* c-typeprint.c (c_type_print_base) <TYPE_CODE_STRUCT,
	TYPE_CODE_UNION>: Unify, removing a goto.
@
text
@d624 2
a625 2
	  fprintf_filtered (stream, "%d", 
			    (int) (high_bound - low_bound + 1));
@


1.79
log
@	* c-typeprint.c (cp_type_print_derivation_info): Fix comment.
@
text
@d771 1
d773 3
a775 1
      if (TYPE_DECLARED_CLASS (type))
a778 7
      goto struct_union;

    case TYPE_CODE_UNION:
      c_type_print_modifier (type, stream, 0, 1);
      fprintf_filtered (stream, "union ");

    struct_union:
@


1.78
log
@http://sourceware.org/ml/gdb-patches/2012-09/msg00015.html

gdb/ChangeLog

        * c-typeprint.c (c_type_print_varspec_suffix): Display the size of
        vector variables using vector_size syntax rather than array
        syntax.

gdb/testsuite/ChangeLog

        * gdb.xml/tdesc-regs.exp: Update expected output for new
        vector_size syntax of vector types.
@
text
@d134 1
a134 6
   possible to the form that they appear in the source code.

   Note that in case of protected derivation gcc will not say
   'protected' but 'private'.  The HP's aCC compiler emits specific
   information for derivation via protected inheritance, so gdb can
   print it out */
@


1.77
log
@http://sourceware.org/ml/gdb-patches/2012-09/msg00013.html

gdb/ChangeLog:
        * c-typeprint.c (c_type_print_varspec_prefix): Pass through the
        passed_a_ptr flag when displaying typedef types.


gdb/testsuite/ChangeLog:
        * gdb.base/ptype.exp: Test ptype on a pointer to a typedef.
@
text
@d621 1
d626 2
a627 1
	fprintf_filtered (stream, "[");
d631 1
a631 1
	fprintf_filtered (stream, "]");
@


1.76
log
@	PR c++/14365
	* c-typeprint.c (c_type_print_varspec_prefix): Pass
	-1 for SHOW to c_type_print_base for METHODPTR and MEMBERPTR.

	* gdb.dwarf2/dw2-anon-mptr.exp: New file.
	* gdb.dwarf2/dw2-anon-mptr.S: New file.
@
text
@d309 1
a309 1
				   stream, show, 0, 0);
@


1.75
log
@gdb/
	* gdbtypes.h (enum type_code): Define TYPE_CODE_BITSTRING -1.
	* arm-tdep.c (arm_type_align): Remove code handling TYPE_CODE_BITSTRING.
	* c-typeprint.c (c_type_print_varspec_prefix): Likewise.
	(c_type_print_varspec_suffix): Likewise.
	* eval.c (evaluate_subexp_standard): Likewise.
	* f-typeprint.c (f_type_print_varspec_prefix): Likewise.
	(f_type_print_varspec_suffix): Likewise.
	* gdbtypes.c (is_scalar_type): Likewise.
	(recursive_dump_type): Likewise.
	* infcall.c (value_arg_coerce): Likewise.
	* m2-valprint.c (m2_val_print): Likewise.
	* p-typeprint.c (pascal_type_print_varspec_prefix): Likewise.
	(pascal_type_print_varspec_suffix): Likewise.
	(pascal_type_print_base): Likewise.
	* p-valprint.c (pascal_val_print): Likewise.
	(pascal_val_print): Likewise.
	* valops.c (value_slice): Likewise.
	* valprint.c (scalar_type_p): Likewise.
	* valarith.c (value_bitstring_subscript): Remove.
	(value_concat): Remove code handling TYPE_CODE_BITSTRING.
	Remove comment on TYPE_CODE_BITSTRING.

	* stabsread.c (read_type): Don't set TYPE_CODE (type) to
	TYPE_CODE_BITSTRING.

	* python/py-type.c (pyty_codes): Move ENTRY (TYPE_CODE_BITSTRING) to
	slot 0.

gdb/doc:
	* gdb.texinfo (Types In Python): Mention gdb.TYPE_CODE_BITSTRING
	is deprecated.
@
text
@d268 1
a268 1
			   stream, 0, passed_a_ptr);
d281 1
a281 1
			   stream, 0, passed_a_ptr);
@


1.74
log
@gdb/
	PR symtab/7259:
	* ada-exp.y (convert_char_literal): Use TYPE_FIELD_ENUMVAL.
	* ada-lang.c (ada_discrete_type_high_bound)
	(ada_discrete_type_low_bound): Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	(ada_identical_enum_types_p): Use TYPE_FIELD_ENUMVAL.
	(pos_atr, value_val_atr): Use TYPE_FIELD_ENUMVAL for TYPE_CODE_ENUM.
	* ada-typeprint.c (print_enum_type): Change variable lastval to LONGEST.
	Use TYPE_FIELD_ENUMVAL.
	* ada-valprint.c (print_optional_low_bound, ada_print_scalar)
	(ada_val_print_1): Use TYPE_FIELD_ENUMVAL for TYPE_CODE_ENUM.
	* c-typeprint.c (c_type_print_base): Move variable lastval to inner
	block, change it to LONGEST.  Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	* coffread.c (coff_read_enum_type): Use SET_FIELD_ENUMVAL.
	* dwarf2read.c (process_enumeration_scope): Likewise.
	* gdb-gdb.py (TypeFlagsPrinter): Use field.enumval instead of
	field.bitpos.
	(class StructMainTypePrettyPrinter): Support also
	FIELD_LOC_KIND_ENUMVAL.
	* gdbtypes.c (get_discrete_bounds): Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	(recursive_dump_type): Use TYPE_FIELD_ENUMVAL for TYPE_CODE_ENUM.
	(copy_type_recursive): Support also FIELD_LOC_KIND_ENUMVAL.
	* gdbtypes.h (enum field_loc_kind): New FIELD_LOC_KIND_ENUMVAL.
	(struct main_type.flds_bnds.fields.loc): Adjust bitpos comment.  New
	field enumval.
	(struct main_type.flds_bnds.bields): Adjust loc_kind and bitsize to
	accommodate enumval.
	(struct call_site): Adjust loc_kind to accommodate enumval.
	(FIELD_ENUMVAL, FIELD_ENUMVAL_LVAL, SET_FIELD_ENUMVAL)
	(TYPE_FIELD_ENUMVAL): New macros.
	* m2-typeprint.c (m2_enum): Use TYPE_FIELD_ENUMVAL.
	* mdebugread.c (parse_symbol): Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	* p-typeprint.c (pascal_type_print_base): Likewise.
	* python/lib/gdb/printing.py (class FlagEnumerationPrinter): Use
	enumval.
	* python/lib/gdb/types.py (make_enum_dict): Likewise.
	* python/py-type.c (convert_field): New variable addrstring.  Use
	TYPE_FIELD_ENUMVAL for TYPE_CODE_ENUM.
	(check_types_equal): Support also FIELD_LOC_KIND_ENUMVAL.
	* stabsread.c (read_enum_type): Use SET_FIELD_ENUMVAL.
	* typepint.c (print_type_scalar): Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	* valprint.c (generic_val_print): Likewise.

gdb/testsuite/
	PR symtab/7259:
	* gdb.base/enumval.c: New test case.
	* gdb.base/enumval.exp: New test case.
	* gdb.python/py-type.exp (test_enums): Use field.enumval instead of
	field.bitpos.
@
text
@a324 1
    case TYPE_CODE_BITSTRING:
a680 1
    case TYPE_CODE_BITSTRING:
@


1.73
log
@	* gdbtypes.h (struct main_type): Change type of name,tag_name,
	and fields.name members from char * to const char *.  All uses updated.
	(struct cplus_struct_type): Change type of fn_fieldlists.name member
	from char * to const char *.  All uses updated.
	(type_name_no_tag): Update.
	(lookup_unsigned_typename, lookup_signed_typename): Update.
	* gdbtypes.c (type_name_no_tag): Change result type
	from char * to const char *.  All callers updated.
	(lookup_unsigned_typename, lookup_signed_typename): Change type of
	name parameter from char * to const char *.
	* symtab.h (struct cplus_specific): Change type of demangled_name
	member from char * to const char *.  All uses updated.
	(struct general_symbol_info): Change type of name and
	mangled_lang.demangled_name members from char * to const char *.
	All uses updated.
	(symbol_get_demangled_name, symbol_natural_name): Update.
	(symbol_demangled_name, symbol_search_name): Update.
	* symtab.c (symbol_get_demangled_name): Change result type
	from char * to const char *.  All callers updated.
	(symbol_natural_name, symbol_demangled_name): Ditto.
	(symbol_search_name): Ditto.
	(completion_list_add_name): Change type of symname,sym_text,
	text,word parameters from char * to const char *.
	(completion_list_objc_symbol): Change type of sym_text,
	text,word parameters from char * to const char *.
	* ada-lang.c (find_struct_field): Change type of name parameter
	from char * to const char *.
	(encoded_ordered_before): Similarly for N0,N1 parameters.
	(old_renaming_is_invisible): Similarly for function_name parameter.
	(ada_type_name): Change result type from char * to const char *.
	All callers updated.
	* ada-lang.h (ada_type_name): Update.
	* buildsym.c (hashname): Change type of name parameter
	from char * to const char *.
	* buildsym.h (hashname): Update.
	* dbxread.c (end_psymtab): Change type of include_list parameter
	from char ** to const char **.
	* dwarf2read.c (determine_prefix): Change result type
	from char * to const char *.  All callers updated.
	* f-lang.c (find_common_for_function): Change type of name, funcname
	parameters from char * to const char *.
	* f-lang.c (find_common_for_function): Update.
	* f-valprint.c (list_all_visible_commons): Change type of funcname
	parameters from char * to const char *.
	* gdbarch.sh (static_transform_name): Change type of name parameter
	and result from char * to const char *.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* i386-sol2-tdep.c (i386_sol2_static_transform_name): Change type
	of name parameter from char * to const char *.
	* jv-lang.c (java_primitive_type_from_name): Ditto.
	(java_demangled_signature_length): Similarly for signature parameter.
	(java_demangled_signature_copy): Ditto.
	(java_demangle_type_signature): Ditto.
	* jv-lang.h (java_primitive_type_from_name): Update.
	(java_demangle_type_signature): Update.
	* objc-lang.c (specialcmp): Change type of a,b parameters
	from char * to const char *.
	* p-lang.c (is_pascal_string_type): Change type of arrayname parameter
	from char * to const char *.  All callers updated.
	* p-lang.h (is_pascal_string_type): Update.
	* solib-frv.c (find_canonical_descriptor_in_load_object): Change type
	of name parameter from char * to const char *.
	* sparc-sol2-tdep.c (sparc_sol2_static_transform_name): Ditto.
	* utils.c (fprintf_symbol_filtered): Ditto.
	* defs.h (fprintf_symbol_filtered): Update.
	* sparc-tdep.h (sparc_sol2_static_transform_name): Update.
	* stabsread.h (end_psymtab): Update.
	* stack.c (find_frame_funname): Change type of funname parameter
	from char ** to const char **.
	* stack.h (find_frame_funname): Update.
	* typeprint.c (type_print): Change type of varstring parameter
	from char * to const char *.
	* value.h (type_print): Update.
	* xcoffread.c (xcoff_start_psymtab): Change type of filename parameter
	from char * to const char *.  All callers updated.
	(xcoff_end_psymtab): Change type of include_list parameter
	from char ** to const char **.  All callers updated.
	(swap_sym): Similarly for name parameter.  All callers updated.
	* coffread.c (patch_type): Add (char*) cast to xfree parameter.
	Use xstrdup.
	(process_coff_symbol): Use xstrdup.
	* stabsread.c (stabs_method_name_from_physname): Renamed from
	update_method_name_from_physname.  Change result type from void
	to char *.  All callers updated.
	(read_member_functions): In has_destructor case, store name in objfile
	obstack instead of malloc space.  In !has_stub case, fix mem leak.
@
text
@a719 1
  int lastval;
d1196 2
a1199 1
	  lastval = 0;
d1207 1
a1207 1
	      if (lastval != TYPE_FIELD_BITPOS (type, i))
d1209 3
a1211 3
		  fprintf_filtered (stream, " = %d", 
				    TYPE_FIELD_BITPOS (type, i));
		  lastval = TYPE_FIELD_BITPOS (type, i);
@


1.72
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d145 1
a145 1
  char *name;
d168 2
a169 2
cp_type_print_method_args (struct type *mtype, char *prefix,
			   char *varstring, int staticp,
d241 1
a241 1
  char *name;
d474 1
a474 1
  char *name = TYPE_FN_FIELDLIST_NAME (type, i);
d993 2
a994 2
	      char *method_name = TYPE_FN_FIELDLIST_NAME (type, i);
	      char *name = type_name_no_tag (type);
@


1.71
log
@	* value.c (value_fn_field): Constify.
	* symtab.c (gdb_mangle_name): Constify.
	* stabsread.c (update_method_name_from_physname): Make 'physname'
	argument const.
	* p-typeprint.c (pascal_type_print_method_args): Make arguments
	const.  Use explicit fputc_filtered loop.
	(pascal_type_print_base): Constify.
	* p-lang.h (pascal_type_print_method_args): Update.
	* linespec.c (add_matching_methods): Constify.
	(add_constructors): Likewise.
	* jv-typeprint.c (java_type_print_base): Constify.
	* gdbtypes.h (struct cplus_struct_type)
	<fn_fieldlist.fn_field.physname>: Now const.
	* dwarf2read.c (compute_delayed_physnames): Constify.
	(dwarf2_add_member_fn): Likewise.
	* c-typeprint.c (c_type_print_base): Constify.  Use cleanups.
@
text
@d2 2
a3 3
   Copyright (C) 1986, 1988, 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1998,
   1999, 2000, 2001, 2002, 2003, 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.71.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 3
a4 2
   Copyright (C) 1986, 1988-1989, 1991-1996, 1998-2003, 2006-2012 Free
   Software Foundation, Inc.
@


1.70
log
@gdb/
	Code cleanup.
	* c-typeprint.c (c_type_print_args): Change parameter show_artificial
	to linkage_name.  Invert its value.  Update the function comment.
	(c_type_print_varspec_suffix): Invert it at the caller.
	* dwarf2read.c (dwarf2_compute_name): Invert it at the caller.
@
text
@a721 3
  char *mangled_name;
  char *demangled_name;
  char *demangled_no_static;
d1001 4
a1004 1
		  char *physname = TYPE_FN_FIELD_PHYSNAME (f, j);
d1014 2
d1069 8
a1076 2
		    /* Build something we can demangle.  */
		    mangled_name = gdb_mangle_name (type, i, j);
d1118 1
d1133 1
a1133 2
		  if (TYPE_FN_FIELD_STUB (f, j))
		    xfree (mangled_name);
@


1.69
log
@gdb/
	Fix const/volatile qualifiers of C++ types, PR c++/12328.
	* c-typeprint.c (c_type_print_args): Update the function comment.  New
	variable param_type, initialize it.  Remove const/volatile qualifiers
	for language_cplus and !show_artificial.  Use param_type.

gdb/testsuite/
	Fix const/volatile qualifiers of C++ types, PR c++/12328.
	* gdb.cp/overload-const.exp: New file.
	* gdb.cp/overload-const.cc: New file.
@
text
@d390 6
a395 7
   in non-static methods, are displayed if SHOW_ARTIFICIAL is
   non-zero.  If SHOW_ARTIFICIAL is zero and LANGUAGE is language_cplus
   the topmost parameter types get removed their possible const and volatile
   qualifiers to match demangled linkage name parameters part of such function
   type.  LANGUAGE is the language in which TYPE was defined.  This is
   a necessary evil since this code is used by the C, C++, and Java backends.
   */
d399 1
a399 1
		   int show_artificial, enum language language)
d413 1
a413 1
      if (TYPE_FIELD_ARTIFICIAL (type, i) && !show_artificial)
d424 1
a424 1
      if (language == language_cplus && !show_artificial)
d660 1
a660 2
	c_type_print_args (type, stream, 1,
			   current_language->la_language);
@


1.68
log
@2011-01-07  Michael Snyder  <msnyder@@vmware.com>

	* ada-lang.c: Comment cleanup, mostly periods and spaces.
	* ada-lang.h: Ditto.
	* ada-tasks.c: Ditto.
	* ada-valprint.c: Ditto.
	* aix-threads.c: Ditto.
	* alpha-linux-nat.c: Ditto.
	* alpha-linux-tdep.c: Ditto.
	* alpha-mdebug-tdep.c: Ditto.
	* alpha-nat.c: Ditto.
	* alpha-osf1-tdep.c: Ditto.
	* alpha-tdep.c: Ditto.
	* alphabsd-nat.c: Ditto.
	* alphabsd-tdep.c: Ditto.
	* amd64-darwin-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* amd64-sol2-tdep.c: Ditto.
	* amd64-tdep.c: Ditto.
	* amd64-fbsd-tdep.c: Ditto.
	* amd64-nbsd-tdep.c: Ditto.
	* amd64-obsd-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* arm-tdep.c: Ditto.
	* arm-tdep.h: Ditto.
	* armnbsd-nat.c: Ditto.
	* avr-tdep.c: Ditto.
	* bfin-tdep.c: Ditto.
	* bsd-kvm.c: Ditto.
	* c-typeprintc: Ditto.
	* c-valprint.c: Ditto.
	* coff-pe-read.h: Ditto.
	* coffreead.c: Ditto.
	* cris-tdep.c: Ditto.
	* d-lang.c: Ditto.
	* darwin-nat-info.c: Ditto.
	* darwin-nat.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* dcache.c: Ditto.
	* dcache.h: Ditto.
	* dec-thread.c: Ditto.
	* defs.h: Ditto.
	* demangle.c: Ditto.
	* dicos-tdep.c: Ditto.
	* dictionary.c: Ditto.
	* dictionary.h: Ditto.
	* dink32-rom.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dsrec.c: Ditto.
	* dummy-frame.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* environ.c: Ditto.
	* eval.c: Ditto.
	* event-top.h: Ditto.
	* exceptions.c: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-exp.y: Ditto.
	* f-lang.c: Ditto.
	* f-lang.h: Ditto.
	* f-typeprint.c: Ditto.
	* f-valprint.c: Ditto.
	* fbsd-nat.c: Ditto.
	* findvar.c: Ditto.
	* fork-child.c: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* frv-linux-tdep.c: Ditto.
	* frv-tdep.c: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_string.h: Ditto.
	* gdb_thread_db.h: Ditto.
	* gdb_wait.h: Ditto.
	* gdbarch.sh: Ditto.
	* gdbcore.h: Ditto.
	* gdbthread.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* gnu-nat.c: Ditto.
	* gnu-nat.h: Ditto.
	* gnu-v2-abi.c: Ditto.
	* gnu-v3-abi.c: Ditto.
	* go32-nat.c: Ditto.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
@
text
@d391 6
a396 3
   non-zero.  LANGUAGE is the language in which TYPE was defined.
   This is a necessary evil since this code is used by the C, C++, and
   Java backends.  */
d412 2
d423 14
d438 1
a438 2
	java_print_type (TYPE_FIELD_TYPE (type, i),
			 "", stream, -1, 0);
d440 1
a440 2
	c_print_type (TYPE_FIELD_TYPE (type, i),
		      "", stream, -1, 0);
@


1.67
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d84 1
a84 1
         the name, so don't print an additional pair of ()'s */
d512 1
a512 1
  int quoted = 0;	/* zero if we're not in quotes;
d515 1
a515 1
  int depth = 0;	/* number of unclosed parens we've seen */
d977 1
a977 1
	  /* C++: print out the methods */
d1210 1
a1210 1
      /* This should not occur */
@


1.66
log
@run copyright.sh for 2011.
@
text
@d846 2
a847 1
			if (!TYPE_FN_FIELD_PRIVATE (TYPE_FN_FIELDLIST1 (type, j), i))
d877 5
a881 2
			if (TYPE_FN_FIELD_PRIVATE (TYPE_FN_FIELDLIST1 (type, j), i)
			    || TYPE_FN_FIELD_PROTECTED (TYPE_FN_FIELDLIST1 (type, j), i))
@


1.65
log
@2010-12-31  Michael Snyder  <msnyder@@vmware.com>

	* charset.c: Comment cleanup and long line wrapping.
	* charset.h: Ditto.
	* c-lang.c: Ditto.
	* c-lang.h: Ditto.
	* coff-pe-read.c: Ditto.
	* coff-pe-read.h: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* complaints.c: Ditto.
	* complaints.h: Ditto.
	* completer.c: Ditto.
	* completer.h: Ditto.
	* corefile.c: Ditto.
	* corelow.c: Ditto.
	* core-regset.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-abi.h: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* cp-support.h: Ditto.
	* cp-valprint.c: Ditto.
	* cp-typeprint.c: Ditto.
	* c-valprint.c: Ditto.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003, 2006, 2007, 2008, 2009, 2010
@


1.64
log
@gdb:
	* dwarf2read.c (read_array_type): Read the DW_AT_byte_size from the
	DIE and set the length of the type.
	* gdbtypes.h (get_array_bounds): Move here from valprint.h.
	* gdbtypes.c (get_array_bounds): Move here from valprint.c and
	return 0 if the corresponding bounds of the type are undefined.
	* valprint.h (get_array_bounds): Move declaration to gdbtypes.h.
	* valprint.c (get_array_bounds): Move implementation to gdbtypes.c.
	(val_print_array_elements): Use get_array_bounds to compute the number
	of array elements instead of dividing the length of the array by the
	length of the element types.
	* valarith.c (vector_binop): Likewise.
	* valops.c (value_cast): Likewise.
	* c-valprint.c (c_val_print): Likewise.
	* c-typeprint.c (c_type_print_varspec_suffix): Likewise.

gdb/testsuite:
	* gdb.base/gnu_vector.exp: Adjust expect messages.
@
text
@d23 1
a23 1
#include "bfd.h"		/* Binary File Description */
d39 7
a45 5
static void c_type_print_varspec_prefix (struct type *, struct ui_file *, int,
				         int, int);

/* Print "const", "volatile", or address space modifiers. */
static void c_type_print_modifier (struct type *, struct ui_file *,
d51 3
a53 1
c_print_type (struct type *type, const char *varstring, struct ui_file *stream,
d83 2
a84 2
      /* For demangled function names, we have the arglist as part of the name,
         so don't print an additional pair of ()'s */
d87 2
a88 1
      c_type_print_varspec_suffix (type, stream, show, 0, demangled_args);
d97 2
a98 1
c_print_typedef (struct type *type, struct symbol *new_symbol,
d113 2
a114 2
   Print only the actual base classes of this type, not the base classes
   of the base classes.  I.E.  for the derivation hierarchy:
d126 3
a128 2
   Not as the following (like gdb used to), which is not legal C++ syntax for
   derived types and may be confused with the multiple inheritance form:
d134 7
a140 5
   In general, gdb should try to print the types as closely as possible to
   the form that they appear in the source code. 
   Note that in case of protected derivation gcc will not say 'protected' 
   but 'private'. The HP's aCC compiler emits specific information for 
   derivation via protected inheritance, so gdb can print it out */
d143 2
a144 1
cp_type_print_derivation_info (struct ui_file *stream, struct type *type)
d153 3
a155 2
			BASETYPE_VIA_PUBLIC (type, i) ? "public"
	       : (TYPE_FIELD_PROTECTED (type, i) ? "protected" : "private"),
d169 3
a171 2
cp_type_print_method_args (struct type *mtype, char *prefix, char *varstring,
			   int staticp, struct ui_file *stream)
d178 4
a181 2
  fprintf_symbol_filtered (stream, prefix, language_cplus, DMGL_ANSI);
  fprintf_symbol_filtered (stream, varstring, language_cplus, DMGL_ANSI);
d237 4
a240 2
c_type_print_varspec_prefix (struct type *type, struct ui_file *stream,
			     int show, int passed_a_ptr, int need_post_space)
d255 2
a256 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, show, 1, 1);
d262 2
a263 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, show, 0, 0);
d268 2
a269 1
	c_type_print_base (TYPE_DOMAIN_TYPE (type), stream, 0, passed_a_ptr);
d274 2
a275 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, show, 0, 0);
d281 2
a282 1
	c_type_print_base (TYPE_DOMAIN_TYPE (type), stream, 0, passed_a_ptr);
d287 2
a288 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, show, 1, 0);
d295 2
a296 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, show, 0, 0);
d302 2
a303 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, show, 0, 0);
d309 2
a310 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, show, 0, 0);
d391 3
a393 3
   non-zero. LANGUAGE is the language in which TYPE was defined.  This is
   a necessary evil since this code is used by the C, C++, and Java
   backends. */
d419 2
a420 1
	java_print_type (TYPE_FIELD_TYPE (type, i), "", stream, -1, 0);
d422 2
a423 1
	c_print_type (TYPE_FIELD_TYPE (type, i), "", stream, -1, 0);
d496 2
a497 1
     `operator delete', neither of which are type conversion operators.  */
d512 4
a515 4
  int quoted = 0;		/* zero if we're not in quotes;
				   '"' if we're in a double-quoted string;
				   '\'' if we're in a single-quoted string.  */
  int depth = 0;		/* number of unclosed parens we've seen */
d518 2
a519 2
  char *last = 0;		/* The character after the rightmost
				   `::' token we've seen so far.  */
d535 2
a536 2
	     not relevant to the top-level structure we're trying
	     to operate on.  */
d560 4
a563 4
	      /* We're going to do a little error recovery here.  If we
		 don't find a match for *scan on the paren stack, but
		 there is something lower on the stack that does match, we
		 pop the stack to that point.  */
d589 4
a592 2
c_type_print_varspec_suffix (struct type *type, struct ui_file *stream,
			     int show, int passed_a_ptr, int demangled_args)
d613 2
a614 1
	  fprintf_filtered (stream, "%d", (int) (high_bound - low_bound + 1));
d617 2
a618 2
	c_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream, show,
				     0, 0);
d623 2
a624 2
      c_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream, show,
				   0, 0);
d629 2
a630 2
      c_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream, show,
				   0, 0);
d635 2
a636 2
      c_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream, show,
				   1, 0);
d644 4
a647 3
	c_type_print_args (type, stream, 1, current_language->la_language);
      c_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream, show,
				   passed_a_ptr, 0);
d651 2
a652 2
      c_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream, show,
				   passed_a_ptr, 0);
d673 2
a674 1
         gcc -Wall will report types that may not have been considered.  */
d683 2
a684 2
   function value or array element), or the description of a
   structure or union.
d686 10
a695 8
   SHOW positive means print details about the type (e.g. enum values),
   and print structure elements passing SHOW - 1 for show.
   SHOW negative means just print the type name or struct tag if there is one.
   If there is no name, print something sensible but concise like
   "struct {...}".
   SHOW zero means just print the type name or struct tag if there is one.
   If there is no name, print something sensible but not as concise like
   "struct {int x; int y;}".
d701 2
a702 2
c_type_print_base (struct type *type, struct ui_file *stream, int show,
		   int level)
d727 6
a732 5
  /* When SHOW is zero or less, and there is a valid type name, then always
     just print the type name directly from the type.  */
  /* If we have "typedef struct foo {. . .} bar;" do we want to print it
     as "struct foo" or as "bar"?  Pick the latter, because C++ folk tend
     to expect things like "class5 *foo" rather than "struct class5 *foo".  */
d747 2
a748 2
      /* If we get here, the typedef doesn't have a name, and we couldn't
	 resolve TYPE_TARGET_TYPE.  Not much we can do.  */
d761 2
a762 1
      c_type_print_base (TYPE_TARGET_TYPE (type), stream, show, level);
d779 4
a782 6
      /* Print the tag if it exists. 
       * The HP aCC compiler emits
       * a spurious "{unnamed struct}"/"{unnamed union}"/"{unnamed enum}"
       * tag  for unnamed struct/union/enum's, which we don't
       * want to print.
       */
d793 2
a794 1
	  /* If we just printed a tag name, no need to print anything else.  */
d810 2
a811 1
		fprintfi_filtered (level + 4, stream, _("<incomplete type>\n"));
d813 2
a814 1
		fprintfi_filtered (level + 4, stream, _("<no data fields>\n"));
d819 1
a819 1
	     thereafter until we find another type. */
d826 1
a826 1
	     no need for a "public:" label. */
d861 2
a862 1
		if (TYPE_FIELD_PRIVATE (type, i) || TYPE_FIELD_PROTECTED (type, i))
d920 2
a921 1
			  fprintfi_filtered (level + 2, stream, "private:\n");
d929 2
a930 1
			  fprintfi_filtered (level + 2, stream, "public:\n");
d956 2
a957 2
	      between them.  Make sure to count only method that we will
	      display; artificial methods will be hidden.  */
d980 2
a981 1
	      int is_constructor = name && strcmp (method_name, name) == 0;
d1010 2
a1011 1
			  fprintfi_filtered (level + 2, stream, "private:\n");
d1019 2
a1020 1
			  fprintfi_filtered (level + 2, stream, "public:\n");
d1032 2
a1033 1
		      fprintf_filtered (stream, _("<undefined type> %s;\n"),
d1037 4
a1040 2
		  else if (!is_constructor	/* constructors don't have declared types */
			   && !is_full_physname_constructor	/*    " "  */
d1058 5
a1062 5
		      /* in some cases (for instance with the HP demangling),
		         if a function has more than 10 arguments, 
		         the demangling will fail.
		         Let's try to reconstruct the function signature from 
		         the symbol information */
d1075 2
a1076 1
			fprintf_filtered (stream, _("<badly mangled name '%s'>"),
d1085 2
a1086 1
		      /* get rid of the `static' appended by the demangler */
d1092 4
a1095 2
			  demangled_no_static = (char *) xmalloc (length + 1);
			  strncpy (demangled_no_static, demangled_no_class, length);
d1138 2
a1139 1
	    fprintfi_filtered (level, stream, _(" (Local at %s:%d)\n"),
d1152 1
a1152 1
         want to print. */
d1164 2
a1165 1
	  /* If we just printed a tag name, no need to print anything else.  */
d1183 2
a1184 1
		  fprintf_filtered (stream, " = %d", TYPE_FIELD_BITPOS (type, i));
d1216 4
a1219 4
      /* Handle types not explicitly handled by the other cases,
         such as fundamental types.  For these, just print whatever
         the type name is, as recorded in the type itself.  If there
         is no type name, then complain. */
d1227 2
a1228 2
	  /* At least for dump_symtab, it is important that this not be
	     an error ().  */
@


1.63
log
@	* c-typeprint.c (c_type_print_base, case TYPE_CODE_TYPEDEF): Verify
	assumptions of when this case happens.  Print "<unnamed typedef>".
@
text
@d575 2
a576 2
      if (passed_a_ptr)
	fprintf_filtered (stream, ")");
d578 2
a579 7
      fprintf_filtered (stream, "[");
      if (TYPE_LENGTH (TYPE_TARGET_TYPE (type)) > 0
	&& !TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED (type))
	fprintf_filtered (stream, "%d",
			  (TYPE_LENGTH (type)
			   / TYPE_LENGTH (TYPE_TARGET_TYPE (type))));
      fprintf_filtered (stream, "]");
d581 8
a588 2
      c_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream, show,
				   0, 0);
@


1.62
log
@	* c-typeprint.c: Whitespace cleanup.
	(cp_type_print_method_args): Remove unnecessary forward decl.
	(cp_type_print_derivation_info): Ditto.
	(c_type_print_varspec_prefix): Mark as static at definition.
	(c_type_print_modifier): Fix arg descriptions.
@
text
@d710 7
@


1.61
log
@	* c-typeprint.c (c_type_print_modifier): Add note that this prints
	the address space id too.
@
text
@a35 1

a38 6
static void cp_type_print_method_args (struct type *mtype, char *prefix,
				       char *varstring, int staticp,
				       struct ui_file *stream);

static void cp_type_print_derivation_info (struct ui_file *, struct type *);

a45 3



d222 1
a222 1
void
d318 2
a319 1
   NEED_SPACE = 1 indicates an initial white space is needed */
a419 1

d424 1
a472 1

d480 1
a555 1

@


1.60
log
@gdb/
	* c-typeprint.c (c_type_print_base): For no fields check include also
	TYPE_TYPEDEF_FIELD_COUNT.  Print new typedefs section.
	* dwarf2read.c (struct typedef_field_list)
	(struct field_info) <typedef_field_list, typedef_field_list_count>: New.
	(dwarf2_add_typedef): New.
	(read_structure_type): Call dwarf2_add_typedef for DW_TAG_typedef.
	Copy also FI.TYPEDEF_FIELD_LIST.
	* gdbtypes.h (struct typedef_field)
	(struct cplus_struct_type) <typedef_field, typedef_field_count>
	(TYPE_TYPEDEF_FIELD_ARRAY, TYPE_TYPEDEF_FIELD, TYPE_TYPEDEF_FIELD_NAME)
	(TYPE_TYPEDEF_FIELD_TYPE, TYPE_TYPEDEF_FIELD_COUNT): New.

gdb/testsuite/
	* gdb.cp/namespace.exp (ptype OtherFileClass typedefs)
	(ptype ::C::OtherFileClass typedefs): New.
	* gdb.cp/namespace1.cc (C::OtherFileClass::cOtherFileClassType2)
	(C::OtherFileClass::cOtherFileClassVar2): New.
	(C::OtherFileClass::cOtherFileClassVar_use): Use also
	cOtherFileClassVar2.
	(C::cOtherFileType2, C::cOtherFileVar2): New.
	(C::cOtherFileVar_use): use also cOtherFileVar2.
	* gdb.cp/userdef.exp (ptype &*c): Permit arbitrary trailing text.
@
text
@d324 2
a325 1
/* Print out "const" and "volatile" attributes.
@


1.59
log
@	* c-typeprint.c (c_print_typedef): Append new type name for typedefs.
@
text
@d771 2
a772 1
	  if ((TYPE_NFIELDS (type) == 0) && (TYPE_NFN_FIELDS (type) == 0))
d1062 23
@


1.58
log
@	* p-valprint.c (pascal_val_print): Use TYPE_ERROR_NAME.
	* p-typeprint.c (pascal_type_print_base): Use TYPE_ERROR_NAME.
	* m2-valprint.c (m2_val_print): Use TYPE_ERROR_NAME.
	* gdbtypes.h (TYPE_ERROR_NAME): New macro.
	* f-valprint.c (f_val_print): Use TYPE_ERROR_NAME.
	* f-typeprint.c (f_type_print_base): Use TYPE_ERROR_NAME.
	* dwarf2read.c (tag_type_to_type): Create a new error type on
	failure.
	* c-valprint.c (c_val_print): Use TYPE_ERROR_NAME.
	* c-typeprint.c (c_type_print_base): Use TYPE_ERROR_NAME.
@
text
@d110 2
a111 1
		 SYMBOL_LINKAGE_NAME (new_symbol)) != 0)
@


1.57
log
@gdb/
	* ada-lang.h (ada_print_type): Make varstring const.
	* ada-typeprint.c (print_func_type): Make name const.
	(ada_print_type): Make varstring const.
	* c-lang.h (c_print_type): Make varstring const.
	* c-typeprint.c (c_print_type): Likewise.
	* f-lang.h (f_print_type): Likewise.
	* f-typeprint.c (f_print_type): Likewise.
	* jv-lang.h (java_print_type): Likewise.
	* jv-typeprint.c (java_print_type): Likewise.
	* language.c (unk_lang_print_type): Likewise.
	* language.h (struct language_defn) <la_print_type>: Likewise.
	* m2-lang.h (m2_print_type): Likewise.
	* m2-typeprint.c (m2_print_type): Likewise.
	* p-lang.h (pascal_print_type): Likewise.
	* p-typeprint.c (pascal_print_type): Likewise.
@
text
@d1124 1
a1124 1
      fprintf_filtered (stream, _("<unknown type>"));
@


1.56
log
@2010-05-13  Michael Snyder  <msnyder@@vmware.com>

	* charset.c: White space.
	* c-lang.c: White space.
	* cli-out.c: White space.
	* coffread.c: White space.
	* complaints.c: White space.
	* completer.c: White space.
	* corefile.c: White space.
	* corelow.c: White space.
	* cp-abi.c: White space.
	* cp-namespace.c: White space.
	* cp-support.c: White space.
	* cp-valprint.c: White space.
	* c-typeprint.c: White space.
	* c-valprint.c: White space.
@
text
@d59 1
a59 1
c_print_type (struct type *type, char *varstring, struct ui_file *stream,
@


1.55
log
@  * c-typeprint.c (c_type_print_args): Don't print "void"
  for java, regardless of whether it is TYPE_PROTOTYPED.
  Use the passed-in language instead of current_language.
  (c_type_print_varspec_suffix): Use current_language instead
  of assuming language_c.
  * jv-typeprint.c (java_type_print_base): (bz 9320) Strip off
  any return type specifier from the physname.
@
text
@d236 1
d923 1
d939 1
d944 3
a946 3
		   is_constructor_name (physname) 
		   || is_destructor_name (physname)
		   || method_name[0] == '~';
d1019 1
d1041 1
@


1.54
log
@dwarf2_physname patchset:

	Based on work from Daniel Jacobowitz  <dan@@codesourcery.com>
	* c-typeprint.c (cp_type_print_method_args): For non-static methods,
	print out const or volatile qualifiers, too.
	(c_type_print_args): Add parameters show_artificial and language.
	Skip artificial parameters when requested.
	Use the appropriate language printer.
	(c_type_print_varspec): Tell c_type_print_args to skip artificial
	parameters and pass language_c.
	* dwarf2read.c (die_list): New file global.
	(struct partial_die_info): Update comments for name field.
	(pdi_needs_namespace): Renamed to ...
	(die_needs_namespace): ... this. Rewrite.
	(dwarf2_linkage_name): Remove.
	(add_partial_symbol): Do not predicate the call to
	partial_die_full_name based on pdi_needs_namespace.
	Remove call to cp_check_possible_namespace_symbols and associated
	outdated comments.
	(guess_structure_name): Do not inspect child subprogram DIEs.
	(dwarf2_fullname): Update comments.
	Use die_needs_namespace to assist in computing the name.
	(read_func_scope): Use dwarf2_name to get the DIE's name.
	Use dwarf2_physname to get the "linkage name" of the DIE.
	(dwarf2_add_member_field): Use dwarf2_physname instead of
	dwarf2_linkage_name.
	(read_structure_type): For structs and classes, set TYPE_NAME, too.
	(determine_class): Remove.
	(read_partial_die): Ignore DW_AT_MIPS_linkage_name for all languages
	except Ada.
	(new_symbol): Unconditionally call dwarf2_name.
	Compute the "linkage name" using dwarf2_physname.
	Use dwarf2_name instead of dwarf2_full_name for enumerator DIEs.
	When determining to scan for anonymous C++ namespaces, ignore
	the linkage name.
	(dwarf2_physname): New function.
	(dwarf2_full_name): Move content to new function and call
	that.
	(dwarf2_compute_name): "New" function.
	(_initialize_dwarf2_read): Initialize die_list.
	* gnu-v3-eabi.c (gnu_v3_find_method_in): Remove unused variable
	physname.
	(gnu_v3_print_method_ptr): Use the physname for virtual methods
	without a demangled name.
	Print out type information for non-virtual methods.
        * linespec.c (decode_line_1): Force ANY string using "::" (or
	"." for java) to use decode_compound, and clean up any stray quoting.
        If we found a file symtab, re-evaluate whether the remainder is_quoted.
        (decode_compound): Stop consuming at an open parenthesis.
        Keep template parameters.
        Keep any overload information.
        Keep keywords like "const".
        Remove paren_pointer.
        Move is_quoted check from set_flags to here.
        Remove #if 0 code from 2000. Ten years is long enough.
        (find_method): Before comparing symbol names, canonicalize the string
        from the user.
        If a specific overload is requested, find it. Otherwise throw an error.
	(find_method_overload_end): New function.
	(set_flags): Remove.
        (decode_compound): Assume that parentheses are matched.
        It's a lot easier.
	* symtab.c (symbol_find_demangled_name): Add DMGL_VERBOSE flag
	to cplus_demangle.
	* linespec.c (decode_line_1): Keep important keywords like
	"const" and "volatile".
	* symtab.h (SYMBOL_CPLUS_DEMANGLED_NAME): Remove.
	* typeprint.h (c_type_print_args): Add declaration.
	* ui-file.c (do_ui_file_obsavestring): New function.
	(ui_file_obsavestring): New function.
	* ui-file.h (ui_file_obsavestring): Add declaration.
	* valops.c (find_overload_match): Resolve the object to
	a non-pointer type.
	If the object is a data member, search the object for the member
	and return with staticp set.
	Use SYMBOL_NATURAL_NAME instead of SYMBOL_CPLUS_DEMANGLED_NAME.
	Do not attempt to extract a function name from non-function types.
	If the extracted function name and the original name are the same,
	we don't have a C++ method.

	From Jan Kratochvil  <jan.kratochvil@@redhat.com>:
    	* dwarf2read.c (new_symbol <DW_TAG_enumerator>): Call dwarf2_full_name.

	* ada-lang.c (ada_lookup_symbol): Remove linkage_name parameters
	and arguments from symbol lookups.
	* ax-gdb.c (gen_expr): Likewise.
	* cp-namespace.c (cp_lookup_symbol_nonlocal, lookup_namespace_scope,
	cp_lookup_symbol_namespace, lookup_symbol_file, lookup_nested_type,
	lookup_possible_namespace_symbol): Likewise.
	* cp-support.c (read_in_psymtabs): Likewise.
	* cp-support.h (cp_lookup_symbol_nonlocal): Likewise.
	* language.h (la_lookup_symbol_nonlocal): Likewise.
	* scm-valprint.c (scm_inferior_print): Likewise.
	* solib-darwin.c (darwin_relocate_section_addresses): Likewise.
	* solib-svr.c (elf_lookup_lib): Likewise.
	* solib.c (show_auto_solib_add): Likewise.
	* solist.h (lookup_lib_global, solib_global_lookup): Likewise.
	* symmisc.c (maintenance_check_symtabs): Likewise.
	* symtab.c (lookup_symbol_in_language, lookup_symbol_aux,
	lookup_symbol_aux_local, lookup_symbol_aux_block,
	lookup_symbol_from_objfile, lookup_symbol_aux_symtabs,
	lookup_symbol_aux_psymtabs,basic_lookup_symbol_nonlocal,
	lookup_symbol_static, lookup_symbol_global, symbol_matches_domain,
	basic_lookup_transparent_type, find_main_psymtab,
	lookup_block_symbol): Likewise.
	* symtab.h (basic_lookp_symbol_nonlocal, lookup_symbol_static,
	lookup_symbol_global, lookup_symbol_aux_block,
	lookup_symbol_partial_symbol, lookup_block_symbol,
	lookup_global_symbol, value_maybe_namespace_elt): Likewise.
@
text
@d419 2
a420 2
      && (TYPE_PROTOTYPED (type)
	  || current_language->la_language == language_cplus))
d619 1
a619 1
	c_type_print_args (type, stream, 1, language_c);
@


1.53
log
@	* p-typeprint.c (pascal_type_print_varspec_prefix): Update.
	* m2-typeprint.c (m2_print_type): Update.
	* gdbtypes.c (recursive_dump_type): Update.
	(copy_type_recursive): Update.
	* c-typeprint.c (c_type_print_varspec_prefix): Update.
	(c_type_print_base): Update.
	* gdbtypes.h (TYPE_CODE_TEMPLATE, TYPE_CODE_TEMPLATE_ARG):
	Remove.
	(struct cplus_struct_type) <ntemplate_args>: Remove.
	<struct template_arg>: Remove.
	<is_dynamic>: Move earlier.
	(TYPE_TEMPLATE_ARGS): Remove.
	(TYPE_NTEMPLATE_ARGS): Remove.
	(TYPE_TEMPLATE_ARG): Remove.
@
text
@d35 1
a43 2
static void c_type_print_args (struct type *, struct ui_file *);

d199 17
d371 4
a374 1
   in non-static methods, are displayed.  */
d376 3
a378 2
static void
c_type_print_args (struct type *type, struct ui_file *stream)
d390 3
d399 4
a402 1
      c_print_type (TYPE_FIELD_TYPE (type, i), "", stream, -1, 0);
d619 1
a619 1
	c_type_print_args (type, stream);
@


1.52
log
@	* c-typeprint.c (c_type_print_base): Reverse order of test.
@
text
@a294 1
    case TYPE_CODE_TEMPLATE:
a617 1
    case TYPE_CODE_TEMPLATE:
a1100 19
    case TYPE_CODE_TEMPLATE:
      /* Called on "ptype t" where "t" is a template.
         Prints the template header (with args), e.g.:
         template <class T1, class T2> class "
         and then merges with the struct/union/class code to
         print the rest of the definition. */
      c_type_print_modifier (type, stream, 0, 1);
      fprintf_filtered (stream, "template <");
      for (i = 0; i < TYPE_NTEMPLATE_ARGS (type); i++)
	{
	  struct template_arg templ_arg;
	  templ_arg = TYPE_TEMPLATE_ARG (type, i);
	  fprintf_filtered (stream, "class %s", templ_arg.name);
	  if (i < TYPE_NTEMPLATE_ARGS (type) - 1)
	    fprintf_filtered (stream, ", ");
	}
      fprintf_filtered (stream, "> class ");
      goto struct_union;

@


1.51
log
@gdb
	* m2-typeprint.c (m2_record_fields): Don't use
	TYPE_DECLARED_TYPE.
	* gdbtypes.h (TYPE_DECLARED_CLASS): New macro.
	(struct main_type) <flag_declared_class>: New field.
	(struct cplus_struct_type) <declared_type>: Remove.
	<ntemplate_args>: Move earlier.
	(DECLARED_TYPE_CLASS, DECLARED_TYPE_UNION, DECLARED_TYPE_STRUCT)
	(DECLARED_TYPE_TEMPLATE): Remove.
	(TYPE_DECLARED_TYPE): Remove.
	* gdbtypes.c (lookup_union): Don't use TYPE_DECLARED_TYPE.
	* dwarf2read.c (read_structure_type): Set TYPE_DECLARED_CLASS.
	* c-typeprint.c (c_type_print_base): Use TYPE_DECLARED_CLASS, not
	TYPE_DECLARED_TYPE.
gdb/testsuite
	* gdb.dwarf2/member-ptr-forwardref.exp: Update expected result for
	type-printing change.
@
text
@d835 1
a835 1
	      if ((type == basetype && i == vptr_fieldno)
@


1.50
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d705 2
a706 24
      /* Note TYPE_CODE_STRUCT and TYPE_CODE_CLASS have the same value,
       * so we use another means for distinguishing them.
       */
      if (HAVE_CPLUS_STRUCT (type))
	{
	  switch (TYPE_DECLARED_TYPE (type))
	    {
	    case DECLARED_TYPE_CLASS:
	      fprintf_filtered (stream, "class ");
	      break;
	    case DECLARED_TYPE_UNION:
	      fprintf_filtered (stream, "union ");
	      break;
	    case DECLARED_TYPE_STRUCT:
	      fprintf_filtered (stream, "struct ");
	      break;
	    default:
	      /* If there is a CPLUS_STRUCT, assume class if not
	       * otherwise specified in the declared_type field.
	       */
	      fprintf_filtered (stream, "class ");
	      break;
	    }			/* switch */
	}
d708 1
a708 4
	{
	  /* If not CPLUS_STRUCT, then assume it's a C struct */
	  fprintf_filtered (stream, "struct ");
	}
d764 1
a764 2
	  if ((TYPE_DECLARED_TYPE (type) == DECLARED_TYPE_CLASS)
	      || (TYPE_DECLARED_TYPE (type) == DECLARED_TYPE_TEMPLATE))
d792 1
a792 2
	  else if ((TYPE_DECLARED_TYPE (type) == DECLARED_TYPE_STRUCT)
		   || (TYPE_DECLARED_TYPE (type) == DECLARED_TYPE_UNION))
d839 1
a839 4
	      /* If this is a C++ class we can print the various C++ section
	         labels. */

	      if (HAVE_CPLUS_STRUCT (type) && need_access_label)
@


1.49
log
@2009-11-12  Daniel Jacobowitz  <dan@@codesourcery.com>
	    Paul Brook  <paul@@codesourcery.com>

	* c-typeprint.c (c_type_print_base): Skip artificial fields.
	Use get_vptr_fieldno to skip the vtable pointer.
	* dwarf2read.c (dwarf2_add_field): Set FIELD_ARTIFICIAL on artificial
	fields.
	(dwarf2_add_member_fn): Complain about virtual member functions
	without DW_AT_vtable_elem_location and force TYPE_CPLUS_DYNAMIC.
	* gdbtypes.c (get_vptr_fieldno): Update comment.
	* gdbtypes.h (struct cplus_struct_type): Add is_dynamic.
	(TYPE_CPLUS_DYNAMIC): New macro.
	* gnu-v3-abi.c (gnuv3_dynamic_class): New.
	(gnuv3_get_vtable): Rewrite to use gnuv3_dynamic_class.  Move higher.
	(gnuv3_rtti_type, gnuv3_get_virtual_fn, gnuv3_baseclass_offset): Use
	gnuv3_get_vtable.
	* varobj.c (cplus_class_num_children, cplus_describe_child): Skip
	artificial fields.  Use get_vptr_fieldno to skip the vtable pointer.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003, 2006, 2007, 2008, 2009
@


1.48
log
@	ARI fix: OP eol rule.
	* blockframe.c (find_pc_partial_function): Avoid operator at end of
	line.
	* buildsym.c (find_symbol_in_list): Idem.
	(start_subfile, patch_subfile_names): Idem.
	* c-exp.y (variable, yylex): Idem.
	* c-typeprint.c (c_print_type, c_type_print_base): Idem.
	* c-valprint.c (c_val_print): Idem.
	* coffread.c (patch_opaque_types, process_coff_symbol): Idem.
	* corelow.c (core_open): Idem.
	* cris-tdep.c (move_reg_to_mem_movem_op): Idem.
	* cli/cli-decode.c (help_cmd_list, find_command_name_length): Idem.
@
text
@d764 3
d854 1
d858 6
a863 3
	      /* Don't print out virtual function table.  */
	      if (strncmp (TYPE_FIELD_NAME (type, i), "_vptr", 5) == 0
		  && is_cplus_marker ((TYPE_FIELD_NAME (type, i))[5]))
@


1.47
log
@	* gdbtypes.c (make_pointer_type, make_reference_type,
	smash_to_memberptr_type, lookup_array_range_type, check_stub_method):
	Use type architecture instead of current_gdbarch.

	* gdbtypes.h (address_space_name_to_int, address_space_int_to_name):
	Add GDBARCH paramter.
	* gdbtypes.c (address_space_name_to_int, address_space_int_to_name):
	Add GDBARCH parameter.   Use it instead of current_gdbarch.
	* c-typeprint.c (c_type_print_modifier): Update call.
	* parse.c (push_type_address_space): Likewise.

	* findvar.c (extract_typed_address, store_typed_address): Use type
	architecture instead of current_gdbarch.

	* value.c (value_as_address, unpack_field_as_long): Use type architecture
	instead of current_gdbarch.

	* doublest.c (floatformat_from_length): Add GDBARCH argument.  Use it
	instead of current_gdbarch.
	(floatformat_from_type): Pass type architecture.

	* infcall.c (find_function_addr): Use type architecture instead
	of current_gdbarch.

	* valarith.c (value_bitstring_subscript, value_x_binop, value_neg,
	value_bit_index): Use type architecture instead of current_gdbarch.
	* valops.c (value_cast, value_slice): Likewise.

	* value.h (modify_field): Add TYPE argument.
	* value.c (modify_field): Add TYPE argument.  Use type architecture
	instead of current_gdbarch.
	(set_internalvar_component): Likewise.
	* eval.c (evaluate_struct_tuple): Update call.
	* valops.c (value_assign): Likewise.
	* ada-lang.c (modify_general_field): Likewise.  Add TYPE argument.
	(make_array_descriptor): Update calls.
	(move_bits): Add BITS_BIG_ENDIAN_P argument.  Use it instead of
	current_gdbarch.
	(ada_value_assign, value_assign_to_component): Update calls.
	(decode_packed_array, ada_value_primitive_packed_val, ada_value_assign,
	value_assign_to_component): Use type arch instead of current_gdbarch.

	* printcmd.c (float_type_from_length): Remove GDBARCH argument,
	use type architecture instead.
	(print_scalar_formatted, printf_command): Update calls.  Use type
	architecture instead of current_gdbarch.
	* valprint.c (val_print_type_code_int): Use type architecture
	instead of current_gdbarch.
	* varobj.c (value_get_print_value): Likewise.
	* python/python-prettyprint.c (print_string_repr): Add GDBARCH
	argument.  Use it instead of current_gdbarch.
	(apply_val_pretty_printer): Update call.

	* ada-valprint.c (ada_val_print_1): Use type architecture instead
	of current_gdbarch.
	* c-valprint.c (print_function_pointer_address): Add GDBARCH argument.
	Use it instead of current_gdbarch.
	(c_val_print): Update calls passing type architecture.
	* f-valprint.c (f_val_print): Use type architecture instead of
	current_gdbarch.
	* jv-valprint (java_value_print): Likewise.
	* m2-valprint.c (print_function_pointer_address): Add GDBARCH argument.
	Use it instead of current_gdbarch.
	(print_unpacked_pointer): Update calls passing type architecture.
	* scm-valprint.c (scm_scmval_print): Use type architecture instead of
	current_gdbarch.

	* gnu-v3-abi.c (get_class_arch): Remove.
	(gnuv3_rtti_type): Use get_type_arch instead of get_class_arch.  Remove
	special-case check for Java classes.
	(gnuv3_virtual_fn_field, gnuv3_baseclass_offset, gnuv3_print_method_ptr,
	gnuv3_method_ptr_size, gnuv3_make_method_ptr, gnuv3_method_ptr_to_value):
	Use get_type_arch instead of get_class_arch.
@
text
@a72 1
      ||
d75 7
a81 8
      ((show > 0 || TYPE_NAME (type) == 0)
       &&
       (code == TYPE_CODE_PTR || code == TYPE_CODE_FUNC
	|| code == TYPE_CODE_METHOD
	|| code == TYPE_CODE_ARRAY
	|| code == TYPE_CODE_MEMBERPTR
	|| code == TYPE_CODE_METHODPTR
	|| code == TYPE_CODE_REF)))
d748 2
a749 2
      if (TYPE_TAG_NAME (type) != NULL &&
	  strncmp (TYPE_TAG_NAME (type), "{unnamed", 8))
d786 2
a787 2
	  if ((TYPE_DECLARED_TYPE (type) == DECLARED_TYPE_CLASS) ||
	      (TYPE_DECLARED_TYPE (type) == DECLARED_TYPE_TEMPLATE))
d815 2
a816 2
	  else if ((TYPE_DECLARED_TYPE (type) == DECLARED_TYPE_STRUCT) ||
		   (TYPE_DECLARED_TYPE (type) == DECLARED_TYPE_UNION))
d835 2
a836 2
			if (TYPE_FN_FIELD_PRIVATE (TYPE_FN_FIELDLIST1 (type, j), i) ||
			    TYPE_FN_FIELD_PROTECTED (TYPE_FN_FIELDLIST1 (type, j), i))
d987 3
a989 3
		  else if (!is_constructor &&	/* constructors don't have declared types */
			   !is_full_physname_constructor &&	/*    " "  */
			   !is_type_conversion_operator (type, i, j))
d1071 2
a1072 2
      if (TYPE_TAG_NAME (type) != NULL &&
	  strncmp (TYPE_TAG_NAME (type), "{unnamed", 8))
@


1.46
log
@        Updated copyright notices for most files.
@
text
@d341 2
a342 1
  address_space_id = address_space_int_to_name (TYPE_INSTANCE_FLAGS (type));
@


1.45
log
@	Convert static_kind into loc_kind enum.
	* gdbtypes.h (enum field_loc_kind): New.
	(union field_location): New field dwarf_block.
	(struct field): Rename static_kind as loc_kind.
	(FIELD_STATIC_KIND): Rename to ...
	(FIELD_LOC_KIND): ... here.
	(TYPE_FIELD_STATIC_KIND): Rename to ...
	(TYPE_FIELD_LOC_KIND): ... here and use there now new FIELD_LOC_KIND.
	(TYPE_FIELD_STATIC_HAS_ADDR): Remove.
	(TYPE_FIELD_STATIC): Remove.
	(TYPE_FIELD_BITPOS): Reformat.
	(SET_FIELD_BITPOS): New.
	(FIELD_PHYSADDR): Rename to ...
	(FIELD_STATIC_PHYSADDR): ... here.
	(TYPE_FIELD_STATIC_PHYSADDR): Follow the FIELD_PHYSADDR rename.
	(SET_FIELD_PHYSADDR): Use new FIELD_LOC_KIND.
	(FIELD_PHYSNAME): Rename to ...
	(FIELD_STATIC_PHYSNAME): ... here.
	(TYPE_FIELD_STATIC_PHYSNAME): Follow the FIELD_PHYSNAME rename.
	(SET_FIELD_PHYSNAME): Use new FIELD_LOC_KIND.
	(FIELD_DWARF_BLOCK, TYPE_FIELD_DWARF_BLOCK, SET_FIELD_DWARF_BLOCK): New.
	(field_is_static): New declaration.
	* gdbtypes.c (field_is_static): New function.
	(copy_type_recursive): Update throughout.
	* amd64-tdep.c, c-typeprint.c, coffread.c, cp-valprint.c, dwarf2read.c,
	eval.c, jv-typeprint.c, jv-valprint.c, mdebugread.c, p-typeprint.c,
	p-valprint.c, valops.c, value.c, varobj.c: Update throughout.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003, 2006, 2007, 2008
@


1.44
log
@gdb/
	Replace TYPE_ARRAY_{UPPER,LOWER}_BOUND_TYPE by a bit if {un,}defined.
	* c-typeprint.c (c_type_print_varspec_suffix), m2-typeprint.c
	(m2_array), p-typeprint.c (pascal_type_print_varspec_prefix),
	valops.c (value_cast), varobj.c (c_number_of_children): Replace
	TYPE_ARRAY_UPPER_BOUND_TYPE compared to BOUND_CANNOT_BE_DETERMINED by
	TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED.
	* parse.c (follow_types): Use TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED.
	* f-valprint.c (f77_get_dynamic_upperbound): Replace with ...
	(f77_get_upperbound): ... this function handling now only
	TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED.
	(f77_get_dynamic_lowerbound): Replace with ...
	(f77_get_lowerbound): ... this function handling now only
	TYPE_ARRAY_LOWER_BOUND_IS_UNDEFINED.
	(f77_get_dynamic_length_of_aggregate, f77_create_arrayprint_offset_tbl):
	Update their callers.
	* eval.c (evaluate_subexp_standard): Update their callers.
	* f-lang.h (f77_get_dynamic_upperbound, f77_get_upperbound)
	(f77_get_dynamic_lowerbound, f77_get_lowerbound): Update their
	prototypes.
	(BOUND_FETCH_OK, BOUND_FETCH_ERROR): Remove.
	* f-typeprint.c (f_type_print_varspec_suffix, f_type_print_base): Remove
	the lower_bound_was_default variable.  Update the
	f77_get_dynamic_upperbound, f77_get_upperbound and
	TYPE_ARRAY_UPPER_BOUND_TYPE calls.
	* gdbtypes.c (print_bound_type): Remove the function.
	(recursive_dump_type): Remove its calls printing UPPER_BOUND_TYPE and
	LOWER_BOUND_TYPE.
	* gdbtypes.h (enum array_bound_type): Remove.
	(struct main_type): Remove the fields upper_bound_type and
	lower_bound_type.  Comment the new overload of the field artificial.
	(TYPE_ARRAY_UPPER_BOUND_TYPE): Replace by ...
	(TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED): ... this macro.
	(TYPE_ARRAY_LOWER_BOUND_TYPE): Replace by ...
	(TYPE_ARRAY_LOWER_BOUND_IS_UNDEFINED): ... this macro.

gdb/testsuite/
	* gdb.base/maint.exp (maint print type): Remove printing
	UPPER_BOUND_TYPE and LOWER_BOUND_TYPE.
@
text
@d893 2
a894 4
	      if (TYPE_FIELD_STATIC (type, i))
		{
		  fprintf_filtered (stream, "static ");
		}
d898 1
a898 1
	      if (!TYPE_FIELD_STATIC (type, i)
@


1.43
log
@gdb
	* scm-lang.c (scm_language_defn): Update.
	* p-typeprint.c (pascal_print_typedef): New function.
	* p-lang.h: (pascal_print_typedef): Declare.
	* p-lang.c (pascal_language_defn): Update.
	* objc-lang.c (objc_language_defn): Update.
	* m2-typeprint.c (m2_print_typedef): New function.
	* m2-lang.h (m2_print_typedef): Declare.
	* m2-lang.c (m2_language_defn): Update.
	* language.h (_LANG_c, _LANG_m2, _LANG_fortran, _LANG_pascal):
	Remove.
	(struct language_defn) <la_print_typedef>: New field.
	(default_print_typedef): Declare.
	(LA_PRINT_TYPEDEF): New define.
	* language.c (unknown_language_defn): Update.
	(auto_language_defn): Update.
	(local_language_defn): Update.
	* jv-lang.c (java_language_defn): Update.
	* f-lang.c (f_language_defn): Update.
	* c-typeprint.c (c_print_typedef): New function.
	* c-lang.h (c_print_typedef): Declare.
	* c-lang.c (c_language_defn): Update.
	(cplus_language_defn): Update.
	(asm_language_defn): Update.
	(minimal_language_defn): Update.
	* ada-lang.c (ada_language_defn): Update.
	* typeprint.c (default_print_typedef): New function.
gdb/doc
	* gdbint.texinfo (Language Support): Remove text about omitting
	support for a language.
@
text
@d563 1
a563 1
	&& TYPE_ARRAY_UPPER_BOUND_TYPE (type) != BOUND_CANNOT_BE_DETERMINED)
@


1.42
log
@	* alpha-tdep.h (ALPHA_REGISTER_BYTES): Delete.
	* arm-tdep.h (STATUS_REGISTER_SIZE): Delete.
	* breakpoint.c (args_for_catchpoint_enable, current_exception_event):
	Delete.
	* c-typeprint.c (c_type_print_base): Delete handling of template
	instantiations.
	* cp-support.h (METHOD_PTR_IS_VIRTUAL, METHOD_PTR_FROM_VOFFSET)
	(METHOD_PTR_TO_VOFFSET): Delete.
	* defs.h (QUIT_FIXME): Delete.
	* f-lang.h (DEFAULT_DOTMAIN_NAME_IN_MF77, DEFAULT_MAIN_NAME_IN_MF77)
	(DEFAULT_DOTMAIN_NAME_IN_XLF_BUGGY, DEFAULT_DOTMAIN_NAME_IN_XLF): Delete.
	* gdbtypes.h (struct cplus_struct_type): Delete is_inlined,
	ninstantiations, and instantiations.
	(TYPE_INSTANTIATIONS, TYPE_NINSTANTIATIONS, TYPE_INSTANTIATION)
	(TYPE_FN_FIELD_INLINED): Delete.
	* srec.h (SREC_BINARY): Delete.
	* symtab.c (symbol_init_demangled_name): Delete.
	* symtab.h (SYMBOL_INIT_DEMANGLED_NAME, symbol_init_demangled_name)
	(SYMBOL_OBJFILE, struct exception_event_record, CURRENT_EXCEPTION_KIND)
	(CURRENT_EXCEPTION_CATCH_SAL, CURRENT_EXCEPTION_CATCH_LINE)
	(CURRENT_EXCEPTION_CATCH_FILE, CURRENT_EXCEPTION_CATCH_PC)
	(CURRENT_EXCEPTION_THROW_SAL, CURRENT_EXCEPTION_THROW_LINE)
	(CURRENT_EXCEPTION_THROW_FILE, CURRENT_EXCEPTION_THROW_PC): Delete.
	* target.h (enum thread_control_capabilities): Delete tc_switch.
	(target_can_switch_threads): Delete.
@
text
@d100 18
@


1.41
log
@	Updated copyright notices for most files.
@
text
@a1045 2
      if (TYPE_CODE (type) == TYPE_CODE_TEMPLATE)
	goto go_back;
a1127 2
      /* Yuck, factor this out to a subroutine so we can call
         it and return to the point marked with the "goback:" label... - RT */
a1128 13
    go_back:
      if (TYPE_NINSTANTIATIONS (type) > 0)
	{
	  fprintf_filtered (stream, _("\ntemplate instantiations:\n"));
	  for (i = 0; i < TYPE_NINSTANTIATIONS (type); i++)
	    {
	      fprintf_filtered (stream, "  ");
	      c_type_print_base (TYPE_INSTANTIATION (type, i), stream, 0, level);
	      if (i < TYPE_NINSTANTIATIONS (type) - 1)
		fprintf_filtered (stream, "\n");
	    }
	}
      break;
@


1.40
log
@	* gdbtypes.h (struct cplus_struct_type): Remove runtime_ptr member.
	(TYPE_RUNTIME_PTR, TYPE_VTABLE, TYPE_HAS_VTABLE,
	TYPE_PRIMARY_BASE, TYPE_VIRTUAL_BASE_LIST): Remove macros.
	(HP_ACC_VFUNC_START, HP_ACC_VBASE_START, HP_ACC_TYPEINFO_OFFSET,
	HP_ACC_TOP_OFFSET_OFFSET): Likewise.
	(has_vtable, primary_base_class, virtual_base_list_length,
	virtual_base_list_length_skip_primaries, virtual_base_index,
	virtual_base_index_skip_primaries, class_index_in_primary_list,
	count_virtual_fns): Remove prototypes.
	* gdbtypes.c (has_vtable, primary_base_class, current_vbase_list,
	virtual_base_list_aux, virtual_base_list, virtual_base_list_length,
	virtual_base_list_length_skip_primaries, virtual_base_index,
	virtual_base_index_skip_primaries, class_index_in_primary_list,
	count_virtual_fns): Remove.

	* cp-valprint.c (cp_print_hpacc_virtual_table_entries): Remove.
	(hpacc_vtbl_ptr_name, hpacc_vtbl_ptr_type_name): Remove.
	(cp_print_value_fields): Remove support for HP aCC vtables.
	(cp_print_value): Likewise.
	* c-typeprint.c (c_type_print_base): Likewise.

	* value.h (find_rt_vbase_offset): Remove prototype.
	* valops.c (find_rt_vbase_offset): Remove.
	(search_struct_method): Remove support for HP aCC vtables.
	(find_method_list): Likewise.
@
text
@d3 2
a4 1
   1999, 2000, 2001, 2002, 2003, 2006, 2007 Free Software Foundation, Inc.
@


1.39
log
@2007-10-25  Wu Zhou  <woodzltc@@cn.ibm.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	* c-lang.c (c_create_fundamental_type): Create fundamental
	types for DFP.
	* c-typeprint.c (c_type_print_varspec_prefix): Add
	TYPE_CODE_DECFLOAT to no prefix needed case.
	(c_type_print_varspec_suffix): Add TYPE_CODE_DECFLOAT to no
	suffix needed case.
	* c-valprint.c (c_val_print): Call print_decimal_floating to
	print DFP values.
	* dwarf2read.c (read_base_type): Read DW_ATE_decimal_float
	attribute code and return TYPE_CODE_DECFLOAT.
	(dwarf_base_type): Set dwarf2_fundamental_type for DFP values.
	* gdbtypes.c (gdbtypes_post_init): Initialize builtin_decfloat,
	builtin_decdouble and builtin_declong.
	* gdbtypes.h (enum type_code): Add TYPE_CODE_DECFLOAT as a
	type code for DFP.
	(FT_DECFLOAT, FT_DBL_PREC_DECFLOAT, FT_EXT_PREC_DECFLOAT): New
	types, for decimal floating point.
	(FT_NUM_MEMBERS):  Increment, new types added.
	(struct builtin_type): Add builtin_decfloat, builtin_decdouble
	and builtin_declong.
	* valprint.c (print_decimal_floating): New function to print DFP
	values.
	* value.h (print_decimal_floating): Prototype.
@
text
@a836 5
	      /* HP ANSI C++ case */
	      if (TYPE_HAS_VTABLE (type)
		  && (strncmp (TYPE_FIELD_NAME (type, i), "__vfp", 5) == 0))
		continue;
	      /* Other compilers */
@


1.38
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d280 1
d603 1
@


1.37
log
@	* hppa-hpux-tdep.c (args_for_find_stub, HP_ACC_EH_notify_hook,
	HP_ACC_EH_set_hook_value, HP_ACC_EH_notify_callback, HP_ACC_EH_break,
	HP_ACC_EH_catch_throw, HP_ACC_EH_catch_catch, __eh_notification,
	hp_cxx_exception_support, hp_cxx_exception_support_initialized,
	eh_notify_hook_addr, eh_notify_callback_addr, eh_break_addr,
	eh_catch_throw_addr, break_callback_sal, setup_d_pid_in_inferior,
	find_stub_with_shl_get, cover_find_stub_with_shl_get,
	initialize_hp_cxx_exception_support, child_enable_exception_callback,
	current_ex_event, child_get_current_exception_event): Remove.
	(hppa_hpux_inferior_created): Remove.
	(hppa_hpux_init_abi): Do not install hppa_hpux_inferior_created.

	* breakpoint.h (deprecated_exception_catchpoints_are_fragile): Remove.
	(deprecated_exception_support_initialized): Remove.
	* breakpoint.c (deprecated_exception_catchpoints_are_fragile): Remove.
	(deprecated_exception_support_initialized): Remove.
	(breakpoint_init_inferior): Remove handling of non-zero
	deprecated_exception_catchpoints_are_fragile.

	* symtab.h (deprecated_hp_som_som_object_present): Remove.
	* symtab.c (deprecated_hp_som_som_object_present): Remove.
	* c-typeprint.c (c_type_print_base): Remove handling of non-zero
	deprecated_hp_som_som_object_present.
	* eval.c (evaluate_subexp_standard): Likewise.
	* valops.c (value_cast): Likewise.

	* parse.c (parse_nested_classes_for_hpacc, coloncolon): Remove.
	* parser-defs.h (parse_nested_classes_for_hpacc): Remove.
	* c-exp.y (yylex): Do not call parse_nested_classes_for_hpacc.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
d18 1
a18 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.36
log
@Copyright updates for 2007.
@
text
@a1055 13
      /* HP C supports sized enums */
      if (deprecated_hp_som_som_object_present)
	switch (TYPE_LENGTH (type))
	  {
	  case 1:
	    fputs_filtered ("char ", stream);
	    break;
	  case 2:
	    fputs_filtered ("short ", stream);
	    break;
	  default:
	    break;
	  }
@


1.35
log
@	Warning fixes.
	* ada-lang.c (find_struct_field): Initialize *byte_offset_p.
	* breakpoint.c (do_enable_breakpoint): Ignore both mem_cnt and i.
	* c-typeprint.c (c_type_print_varspec_suffix): Don't test length
	greater than or equal to zero.
	* m2-typeprint.c (m2_array): Likewise.
	* p-typeprint.c (pascal_type_print_varspec_prefix): Likewise.
	* gdbtypes.c (copy_type_recursive): Correct == typo.
	* i386-tdep.c (i386_skip_prologue): Remove stray semicolon.
	* linux-nat.c (linux_nat_info_proc_cmd): Don't compare a pointer
	greater than zero.
	* macroscope.c (sal_macro_scope): Don't name a local variable "main".
	(default_macro_scope): Remove unused variable.
	* prologue-value.h (pv_area_find_reg): Don't name an argument
	"register".
	* remote-fileio.c (remote_fio_func_map): Add missing braces.
	* remote.c (sigint_remote_twice_token, sigint_remote_token): Change
	type.
	(cleanup_sigint_signal_handler): Remove casts.
	* valprint.c (val_print): Use a volatile local for the modified
	argument.
	* varobj.c (languages): Remove extra array dimension.
	(varobj_create): Correct access to languages array.
	* mi/mi-cmd-break.c (mi_cmd_break_insert, mi_cmd_break_watch): Add
	missing braces.
	* mi/mi-cmd-disas.c (mi_cmd_disassemble): Likewise.
	* mi/mi-cmd-env.c (mi_cmd_env_path, mi_cmd_env_dir): Likewise.
	* mi/mi-getopt.c (mi_valid_noargs): Likewise.
	* mi/mi-main.c (mi_cmd_data_read_memory): Likewise.
	(mi_cmd_data_write_memory): Likewise.
	* signals/signals.c (target_signal_to_string): Cast to int before
	comparing.
	* tui/tui-layout.c (init_and_make_win): Take and return a void *.
	Update all callers.
@
text
@d3 1
a3 2
   1999, 2000, 2001, 2002, 2003, 2006
   Free Software Foundation, Inc.
@


1.34
log
@	* NEWS: Mention pointer to member improvements.
	* Makefile.in (gnu-v3-abi.o): Delete special rule.
	(eval.o, gnu-v3-abi.o, ia64-tdep.o): Update.
	* ada-valprint.c (ada_print_scalar): Update for new type codes.
	* c-typeprint.c (c_print_type): Update for new type codes.
	(c_type_print_varspec_prefix, c_type_print_varspec_suffix)
	(c_type_print_base): Likewise.
	(c_type_print_args): Rewrite.
	* c-valprint.c (c_val_print): Update for new type codes.  Remove
	support for references to members.  Treat methods like functions.
	* cp-abi.c (cplus_print_method_ptr, cplus_method_ptr_size)
	(cplus_make_method_ptr, cplus_method_ptr_to_value): New.
	* cp-abi.h (cplus_print_method_ptr, cplus_method_ptr_size)
	(cplus_make_method_ptr, cplus_method_ptr_to_value): New prototypes.
	(struct cp_abi_ops): Add corresponding members.
	* cp-valprint.c (cp_print_class_method): Delete.
	(cp_find_class_member): New function.
	(cp_print_class_member): Use it.  Simplify support for bogus
	member pointers.
	* dwarf2read.c (quirk_gcc_member_function_pointer): Use
	lookup_methodptr_type.
	(read_tag_ptr_to_member_type): Likewise, and lookup_memberptr_type.
	* eval.c (evaluate_subexp_standard): Implement EVAL_SKIP for
	OP_SCOPE.  Update call to value_aggregate_elt.  Rewrite member
	pointer support.
	(evaluate_subexp_for_address): Handle OP_SCOPE explicitly.  Handle
	references returned by user defined operators.
	* f-typeprint.c (f_print_type, f_type_print_varspec_prefix)
	(f_type_print_varspec_suffix): Remove support for member pointers.
	* gdbtypes.c (lookup_memberptr_type): Renamed from lookup_member_type
	and adjusted.
	(smash_to_memberptr_type): Likewise, from smash_to_member_type.
	(lookup_methodptr_type): New.
	(rank_one_type): Adjust for TYPE_CODE_MEMBERPTR.
	(recursive_dump_type): Update for new types.
	* gdbtypes.h (enum type_code): Replace TYPE_CODE_MEMBER with
	TYPE_CODE_MEMBERPTR and TYPE_CODE_METHODPTR.
	(lookup_memberptr_type, lookup_methodptr_type)
	(smash_to_memberptr_type): New prototypes.
	(smash_to_method_type): Formatting fix.
	(lookup_member_type, smash_to_member_type): Delete prototypes.
	* gnu-v3-abi.c (gnuv3_get_vtable, gnuv3_get_virtual_fn): New.
	Do not rely on debug information for the vptr or the method's
	enclosing type.  Handle function descriptors for IA64.
	(gnuv3_virtual_fn_field): Rewrite using the new functions.
	(gnuv3_find_method_in, gnuv3_print_method_ptr)
	(gnuv3_method_ptr_size, gnuv3_make_method_ptr)
	(gnuv3_method_ptr_to_value): New.
	(init_gnuv3_ops): Set new members of gnu_v3_abi_ops.
	* hpread.c (hpread_type_lookup): Update for new types.
	* infcall.c (value_arg_coerce): Likewise.
	* m2-typeprint.c (m2_print_type): Remove explicit support
	for member pointers.
	* m2-valprint.c (m2_val_print): Likewise.
	* p-typeprint.c (pascal_type_print_varspec_prefix)
	(pascal_type_print_varspec_suffix, pascal_type_print_base): Likewise.
	* p-valprint.c (pascal_val_print): Likewise.
	(pascal_object_print_class_method, pascal_object_print_class_member):
	Delete.
	* p-lang.h (pascal_object_print_class_method)
	(pascal_object_print_class_member): Delete prototypes.
	* stabsread.c (read_type): Update for new types.
	* typeprint.c (print_type_scalar): Likewise.
	* valops.c (value_struct_elt_for_reference, value_namespace_elt)
	(value_maybe_namespace_elt, value_aggregate_elt): Add want_address
	argument.  Construct a pointer to member if the address of a
	function or data member is requested.
	(value_cast_pointers): Don't modify the input value.
	(value_cast): Adjust pointer to member handling for new types.
	Allow null pointer to member constants.  Don't modify the input
	value.
	(value_ind): Remove pointer to member check.  Handle function
	descriptors for function pointers.
	(value_struct_elt, value_find_oload_method_list, check_field):
	Remove pointer to member checks.
	* value.c (unpack_long): Allow pointers to data members.
	(value_from_longest): Allow member pointers.
	* value.h (value_aggregate_elt): Add want_address.
	* varobj.c (c_variable_editable): Remove check for members.
	* gdbarch.sh: Add vtable_function_descriptors and vbit_in_delta.
	* ia64-tdep.c (ia64_convert_from_func_ptr_addr): Handle descriptors
	in virtual tables.
	(ia64_gdbarch_init): Call set_gdbarch_vtable_function_descriptors.
	* c-lang.h (cp_print_class_method): Delete prototype.
	* arm-tdep.c (arm_gdbarch_init): Call set_gdbarch_vbit_in_delta.
	* mips-tdep.c (mips_gdbarch_init): Likewise.
	* gdbarch.c, gdbarch.h: Regenerated.

	* gdb.cp/classes.exp (test_pointers_to_class_members): Update expected
	output.  Test the types of members and member pointers.
	* gdb.cp/inherit.exp (test_print_mi_member_types): Remove KFAILs for
	gdb/2092.
	* gdb.cp/member-ptr.exp: Search for a comment instead of a
	statement.  Enable for GCC.  Update expected output for some tests
	and add new tests.  Remove obsolete GCC KFAILs.  Allow GCC's class
	layout.
	* gdb.cp/member-ptr.cc (Padding, Padding::vspacer, Base, Base::get_x)
	(Base::vget_base, Left, Left::vget, Right, Right::vget, Diamond)
	(Diamond::vget_base): New.
	(main): Add new tests.
	* gdb.cp/printmethod.exp: Update expected output for member functions.
	* gdb.cp/virtfunc.exp (test_virtual_calls): Add a KFAIL for
	print pEe->D::vg().
@
text
@d545 1
a545 1
      if (TYPE_LENGTH (type) >= 0 && TYPE_LENGTH (TYPE_TARGET_TYPE (type)) > 0
@


1.33
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003
d83 2
a84 1
	|| code == TYPE_CODE_MEMBER
d222 1
a222 3
    case TYPE_CODE_MEMBER:
      if (passed_a_ptr)
	fprintf_filtered (stream, "(");
a223 1
      fprintf_filtered (stream, " ");
d229 1
a229 1
      fprintf_filtered (stream, "::");
d232 1
a232 3
    case TYPE_CODE_METHOD:
      if (passed_a_ptr)
	fprintf_filtered (stream, "(");
d234 7
a240 6
      if (passed_a_ptr)
	{
	  fprintf_filtered (stream, " ");
	  c_type_print_base (TYPE_DOMAIN_TYPE (type), stream, 0, passed_a_ptr);
	  fprintf_filtered (stream, "::");
	}
d249 1
d338 3
a340 1

d345 1
a345 1
  int i;
d347 1
d351 3
a353 1
  if (args != NULL)
d355 5
a359 1
      int i;
d361 3
a363 2
      /* FIXME drow/2002-05-31: Always skips the first argument,
	 should we be checking for static members?  */
d365 6
a370 1
      for (i = 1; i < TYPE_NFIELDS (type); i++)
d372 3
a374 6
	  c_print_type (args[i].type, "", stream, -1, 0);
	  if (i != TYPE_NFIELDS (type))
	    {
	      fprintf_filtered (stream, ",");
	      wrap_here ("    ");
	    }
a375 9
      if (TYPE_VARARGS (type))
	fprintf_filtered (stream, "...");
      else if (i == 1
	       && (current_language->la_language == language_cplus))
	fprintf_filtered (stream, "void");
    }
  else if (current_language->la_language == language_cplus)
    {
      fprintf_filtered (stream, "void");
d377 4
d556 1
a556 3
    case TYPE_CODE_MEMBER:
      if (passed_a_ptr)
	fprintf_filtered (stream, ")");
d561 2
a562 3
    case TYPE_CODE_METHOD:
      if (passed_a_ptr)
	fprintf_filtered (stream, ")");
a564 4
      if (passed_a_ptr)
	{
	  c_type_print_args (type, stream);
	}
d573 1
d578 1
a578 21
	{
	  int i, len = TYPE_NFIELDS (type);
	  fprintf_filtered (stream, "(");
	  if (len == 0
              && (TYPE_PROTOTYPED (type)
                  || current_language->la_language == language_cplus))
	    {
	      fprintf_filtered (stream, "void");
	    }
	  else
	    for (i = 0; i < len; i++)
	      {
		if (i > 0)
		  {
		    fputs_filtered (", ", stream);
		    wrap_here ("    ");
		  }
		c_print_type (TYPE_FIELD_TYPE (type, i), "", stream, -1, 0);
	      }
	  fprintf_filtered (stream, ")");
	}
d678 1
a678 1
    case TYPE_CODE_MEMBER:
d682 1
@


1.33.2.1
log
@2006-05-03  Paul Brook  <paul@@codesourcery.com>
	Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdb/c-valprint.c: Handle class member typedefs.

	* gdb/symtab.c (skip_prologue_using_sal): Treat two consecutive lines
	at the same address as a prolouge marker.
	* gdb/arm-tdep.c (arm_skip_prologue): Use skip_prologue_using_sal.

	* gdb/dwarf2expr.c (execute_stack_op): Check for bogus DW_OP_reg.

	* gdb/dwarf2read.c (read_structure_type): Use tag name for C++/Java
	classes.

	* Makefile.in (eval.o): Update dependencies.
	* eval.c: Include "ui-out.h" and "exceptions.h".
	(evaluate_subexp_standard): Use TRY_CATCH around value_of_variable.
	Use value_zero if an error occurs when avoiding side effects.
	* varobj.c (varobj_create): Call release_value after evaluate_type.
	(c_value_of_root): Initialize new_val.  Don't release_value a NULL
	value.

	* gdb/c-typeprint.c (cp_type_print_method_args): Don't print type
	details.

	* gdb/dwarf2read.c (dwarf2_debug_line_missing_file_complaint): New
	function.
	(dwarf_decode_lines): Check for line info without a file.
@
text
@d171 1
a171 1
	  type_print (args[i++].type, "", stream, -1);
@


1.32
log
@2005-01-29  Baurzhan Ismagulov  <ibr@@radix50.net>

	* ax-gdb.c, ax-general.c, bcache.c, bfd-target.c, bsd-kvm.c,
	* buildsym.c, c-lang.c, c-typeprint.c, c-valprint.c, charset.c,
	* coff-pe-read.c, coffread.c, complaints.c, copying.c: I18n markup.
@
text
@d2 1
a2 1
   Copyright 1986, 1988, 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1998,
d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.31
log
@2004-04-08  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.h (deprecated_exception_catchpoints_are_fragile)
	(deprecated_exception_support_initialized): Declare.
	* hppa-hpux-tdep.c (initialize_hp_cxx_exception_support)
	(initialize_hp_cxx_exception_support)
	(child_enable_exception_callback): Update.
	* breakpoint.c (deprecated_exception_catchpoints_are_fragile)
	(deprecated_exception_support_initialized): Rename
	deprecated_exception_catchpoints_are_fragile and
	deprecated_exception_support_initialized.
	(breakpoint_init_inferior, breakpoint_init_inferior): Update.

	* symtab.c (deprecated_hp_som_som_object_present): Rename
	hp_som_som_object_present.
	* symtab.h (deprecated_hp_som_som_object_present): Declare.
	* symfile.c (hp_som_som_object_present, RESET_HP_UX_GLOBALS):
	Update.  Delete extern declaration.
	* valops.c (hp_som_som_object_present): Ditto.
	* parse.c (deprecated_hp_som_som_object_present)
	(parse_nested_classes_for_hpacc): Ditto.
	* hpread.c (hp_som_som_object_present, hpread_expand_symtab): Ditto.
	* hppa-hpux-tdep.c (hp_som_som_object_present)
	(initialize_hp_cxx_exception_support): Ditto.
	* eval.c (hp_som_som_object_present, evaluate_subexp_standard): Ditto.
	* cp-valprint.c (hp_som_som_object_present)
	(cp_print_class_method): Ditto.
	* c-typeprint.c (hp_som_som_object_present):
	(c_type_print_base): Ditto.
	* c-exp.y (hp_som_som_object_present): Ditto.
@
text
@d289 1
a289 1
      error ("type not handled in c_type_print_varspec_prefix()");
d630 1
a630 1
      error ("type not handled in c_type_print_varspec_suffix()");
d674 1
a674 1
      fputs_filtered ("<type unknown>", stream);
d773 1
a773 1
		fprintfi_filtered (level + 4, stream, "<incomplete type>\n");
d775 1
a775 1
		fprintfi_filtered (level + 4, stream, "<no data fields>\n");
d993 1
a993 1
		      fprintf_filtered (stream, "<undefined type> %s;\n",
d1032 1
a1032 1
			fprintf_filtered (stream, "<badly mangled name '%s'>",
d1067 1
a1067 1
	    fprintfi_filtered (level, stream, " (Local at %s:%d)\n",
d1139 1
a1139 1
      fprintf_filtered (stream, "struct <unknown>");
d1143 1
a1143 1
      fprintf_filtered (stream, "<unknown type>");
d1148 1
a1148 1
      fprintf_filtered (stream, "<range type>");
d1174 1
a1174 1
	  fprintf_filtered (stream, "\ntemplate instantiations:\n");
d1204 1
a1204 1
	  fprintf_filtered (stream, "<invalid type code %d>",
@


1.30
log
@2003-11-07  Andrew Cagney  <cagney@@redhat.com>

	* top.c (print_gdb_version): Replace STREQ with strcmp.
	* valops.c (value_struct_elt_for_reference): Ditto.
	(value_struct_elt_for_reference): Ditto.
	* symtab.c (gdb_mangle_name): Ditto.
	(find_line_symtab): Ditto.
	* symmisc.c (maintenance_print_symbols): Ditto.
	* symfile.c (symbol_file_command): Ditto.
	* stabsread.c (define_symbol, read_type): Ditto.
	(cleanup_undefined_types, scan_file_globals): Ditto.
	* solib.c (solib_map_sections): Ditto.
	* solib-svr4.c (bfd_lookup_symbol): Ditto.
	* rs6000-tdep.c (skip_prologue): Ditto.
	* p-valprint.c (pascal_value_print): Ditto.
	(pascal_object_is_vtbl_ptr_type): Ditto.
	* objfiles.c (in_plt_section): Ditto.
	* minsyms.c (lookup_minimal_symbol): Ditto.
	(compact_minimal_symbols): Ditto.
	(find_solib_trampoline_target): Ditto.
	* mdebugread.c (parse_type): Ditto.
	* language.c (set_language_command): Ditto.
	(set_type_command, set_range_command): Ditto.
	* f-lang.c (add_common_block): Ditto.
	(add_common_block): Ditto.
	(find_first_common_named): Ditto.
	(patch_all_commons_by_name): Ditto.
	* elfread.c (elf_locate_sections): Ditto.
	(elf_locate_sections): Ditto.
	(elfstab_offset_sections): Ditto.
	* dwarf2read.c (dwarf2_locate_sections): Ditto.
	* dbxread.c (add_old_header_file): Ditto.
	(find_corresponding_bincl_psymtab): Ditto.
	(read_dbx_symtab, process_one_symbol): Ditto.
	* coffread.c (patch_opaque_types): Ditto.
	* cli/cli-decode.c (delete_cmd): Ditto.
	* cli/cli-cmds.c (pwd_command, list_command): Ditto.
	* c-typeprint.c (c_type_print_base): Ditto.
	* breakpoint.c (bpstat_stop_status): Ditto.
	(clear_command, breakpoint_re_set_one): Ditto.
@
text
@a40 3
/* Flag indicating target was compiled by HP compiler */
extern int hp_som_som_object_present;

d1078 1
a1078 1
      if (hp_som_som_object_present)
@


1.30.6.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d41 3
d1081 1
a1081 1
      if (deprecated_hp_som_som_object_present)
@


1.29
log
@2003-11-06  Andrew Cagney  <cagney@@redhat.com>

	* valops.c (destructor_name_p): Replace STREQN with strncmp.
	* top.c (command_line_input): Ditto.
	* objc-exp.y (yylex): Ditto.
	* minsyms.c (prim_record_minimal_symbol_and_info): Ditto.
	* jv-exp.y (yylex): Ditto.
	* f-exp.y (yylex): Ditto.
	* event-top.c (command_line_handler): Ditto.
	* environ.c (get_in_environ): Ditto.
	(set_in_environ): Ditto.
	* dwarfread.c (handle_producer): Ditto.
	* dbxread.c (process_one_symbol): Ditto.
	* c-typeprint.c (c_type_print_base): Ditto.
	* c-exp.y (yylex): Ditto.

2003-11-06  Andrew Cagney  <cagney@@redhat.com>

	* mi-cmd-var.c (mi_cmd_var_set_format): Replace STREQN with
	strncmp.
@
text
@d948 1
a948 1
	      int is_constructor = name && STREQ (method_name, name);
@


1.28
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@d862 2
a863 1
	      if (TYPE_HAS_VTABLE (type) && (STREQN (TYPE_FIELD_NAME (type, i), "__vfp", 5)))
d866 1
a866 1
	      if (STREQN (TYPE_FIELD_NAME (type, i), "_vptr", 5)
@


1.27
log
@2003-09-11  David Carlton  <carlton@@kealia.com>

	* gdbtypes.h: Add TYPE_CODE_NAMESPACE.
	* gdbtypes.c (init_type): Handle TYPE_CODE_NAMESPACE.
	(recursive_dump_type): Ditto.
	* printcmd.c (print_formatted): Ditto.
	* typeprint.c (print_type_scalar): Ditto.
	* c-typeprint.c (c_type_print_varspec_prefix): Ditto.
	(c_type_print_varspec_suffix, c_type_print_base): Ditto.
	* cp-support.h: Declare cp_check_possible_namespace_symbols,
	maint_cplus_cmd_list.
	* cp-support.c: Make maint_cplus_cmd_list extern.
	* cp-namespace.c: Include objfiles.h, gdbtypes.h, dictionary.h,
	command.h.
	(lookup_symbol_file): Look in possible namespace blocks when
	appropriate.
	(initialize_namespace_symtab): New.
	(get_possible_namespace_block, free_namespace_block)
	(check_possible_namespace_symbols)
	(check_possible_namespace_symbols_loop)
	(check_one_possible_namespace_symbol)
	(lookup_possible_namespace_symbol, maintenance_cplus_namespace)
	(_initialize_cp_namespace): Ditto.
	* block.h: Declare allocate_block.
	* block.c (allocate_block): New.
	* jv-lang.c (get_java_class_symtab): Allocate blocks via
	allocate_block.
	* symfile.h: Update declaration of add_psymbol_to_list.
	* symfile.c (add_psymbol_to_list): Return the partial symbol in
	question.
	* dwarf2read.c (dwarf2_build_psymtabs_hard): Add argument to
	scan_partial_symbols_call.
	(scan_partial_symbols): Add NAMESPACE argument; update calls to
	helper functions.
	(add_partial_symbol): If necessary, scan mangled names for names
	of namespaces.
	(add_partial_namespace): Add NAMESPACE argument; generate partial
	symbols associated  to namespaces.
	(add_partial_enumeration): Add NAMESPACE argument.
	(new_symbol): Allow namespace syms.
	(read_namespace): Generate namespace syms.
	* objfiles.h: Add opaque declaration of struct symtab.
	(struct objfile): Add cp_namespace_symtab member.
	* objfiles.c (allocate_objfile): Set
	objfile->cp_namespace_symtab.
	* Makefile.in (cp-namespace.o): Depend on objfiles_h, gdbtypes_h,
	dictionary_h, command_h.

2003-09-11  David Carlton  <carlton@@kealia.com>

	* gdb.c++/namespace.exp: Add tests for namespace types.
	* gdb.c++/maint.exp (test_help): Test 'help maint cp namespace'.
	(test_namespace): New.
@
text
@d68 1
a68 1
  register enum type_code code;
@


1.26
log
@Update copyright date with last commit.
@
text
@d287 1
d628 1
d1185 5
@


1.25
log
@	Suggested by Stewart Brown <sb24@@avaya.com>:
	* c-typeprint.c (c_type_print_varspec_prefix): Pass value of show
	in recursive calls.  Handle TYPE_CODE_TYPEDEF.
	(c_type_print_varspec_suffix): Likewise.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002
@


1.24
log
@	* gdbarch.sh (ADDRESS_CLASS_TYPE_FLAGS_TO_NAME)
	(ADDRESS_CLASS_NAME_TO_TYPE_FLAGS): Use ``const char *'' instead of
	``char *'' for return and parameter types.
	* gdbarch.h, gdbarch.c: Regenerate.
	* gdbtypes.h, gdbtypes.c (address_space_int_to_name): Change
	return type from ``char *'' to ``const char *''.
	* c-typeprint.c (c_type_print_modifier): Make ``address_space_id''
	const.
@
text
@d219 1
a219 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 1, 1);
d227 1
a227 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 0, 0);
d240 1
a240 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 0, 0);
d250 1
a250 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 1, 0);
d256 1
a256 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 0, 0);
d262 1
a262 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 0, 0);
d267 4
a285 1
    case TYPE_CODE_TYPEDEF:
d549 2
a550 1
      c_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream, 0, 0, 0);
d556 2
a557 1
      c_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream, 0, 0, 0);
d563 2
a564 1
      c_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream, 0, 0, 0);
d573 2
a574 1
      c_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream, 0, 1, 0);
d602 6
a607 1
      c_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream, 0,
a625 1
    case TYPE_CODE_TYPEDEF:
@


1.23
log
@	* c-lang.h (c_type_print_varspec_prefix): Delete.
	* c-typeprint.c (c_type_print_varspec_prefix): Make static.  Add
	``need_post_space'' parameter.  Adjust all callers.
@
text
@d303 1
a303 1
  char *address_space_id;
@


1.22
log
@2002-07-29  Andrew Cagney  <ac131313@@redhat.com>

* gdb_obstack.h: New file.
* symtab.h: Include "gdb_obstack.h" instead of "obstack.h".
(obstack_chunk_alloc, obstack_chunk_free): Delete macros.
* objfiles.h: Include "gdb_obstack.h".
* Makefile.in (gdb_obstack_h): Define.
(symtab_h): Add $(gdb_obstack_h).
(objfiles_h): Add $(gdb_obstack_h).

* objfiles.c: Include "gdb_obstack.h" instead of "obstack.h".
* macrotab.c, cp-valprint.c, dbxread.c: Ditto.
* ch-typeprint.c, ch-valprint.c, dstread.c: Ditto.
* macroexp.c, p-typeprint.c, stabsread.c: Ditto.
* symtab.c, f-typeprint.c, mdebugread.c: Ditto.
* p-valprint.c, symmisc.c, typeprint.c: Ditto.
* symfile.c, coffread.c, c-typeprint.c: Ditto.
* buildsym.c, bcache.c, ada-typeprint.c: Ditto.

* Makefile.in (bcache.o): Update dependencies.
(buildsym.o, c-typeprint.o, ch-typeprint.o): Ditto.
(ch-valprint.o, coffread.o, cp-valprint.o): Ditto.
(dbxread.o, dstread.o, f-typeprint.o): Ditto.
(objfiles.o, p-typeprint.o, p-valprint.o): Ditto.
(stabsread.o, symfile.o, symmisc.o): Ditto.
(symtab.o, typeprint.o, macroexp.o): Ditto.
(macrotab.o, mdebugread.o): Ditto.
(f_lang_h, coff_sym_h, coff_symconst_h): Define.
(coff_ecoff_h, aout_aout64_h): Define.
(aout_stabs_gnu_h, libaout_h): Define.
@
text
@d52 2
a53 2
void c_type_print_varspec_prefix (struct type *, struct ui_file *, int,
				  int);
d70 1
d89 2
a90 1
  c_type_print_varspec_prefix (type, stream, show, 0);
d197 5
a201 1
   SHOW is always zero on recursive calls.  */
d205 1
a205 1
			     int show, int passed_a_ptr)
d219 1
a219 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 1);
d221 1
a221 1
      c_type_print_modifier (type, stream, 1, 0);
d227 1
a227 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 0);
d240 1
a240 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 0);
d250 1
a250 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 1);
d252 1
a252 1
      c_type_print_modifier (type, stream, 1, 0);
d256 1
a256 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 0);
d262 1
a262 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 0);
@


1.22.8.1
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@d52 2
a53 2
static void c_type_print_varspec_prefix (struct type *, struct ui_file *, int,
				         int, int);
a69 1
  int need_post_space;
d88 1
a88 2
  need_post_space = (varstring != NULL && strcmp (varstring, "") != 0);
  c_type_print_varspec_prefix (type, stream, show, 0, need_post_space);
d195 1
a195 5
   SHOW is always zero on recursive calls.
   
   NEED_POST_SPACE is non-zero when a space will be be needed
   between a trailing qualifier and a field, variable, or function
   name.  */
d199 1
a199 1
			     int show, int passed_a_ptr, int need_post_space)
d213 1
a213 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 1, 1);
d215 1
a215 1
      c_type_print_modifier (type, stream, 1, need_post_space);
d221 1
a221 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 0, 0);
d234 1
a234 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 0, 0);
d244 1
a244 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 1, 0);
d246 1
a246 1
      c_type_print_modifier (type, stream, 1, need_post_space);
d250 1
a250 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 0, 0);
d256 1
a256 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 0, 0);
@


1.22.8.2
log
@2002-11-24  David Carlton  <carlton@@bactrian.org>

	* Makefile.in (c-typeprint.o): Depend on gdb_assert_h.
	* c-typeprint.c: #include "gdb_assert.h"
	* gdbtypes.c (recursive_dump_type): Handle TYPE_CODE_NAMESPACE.
	* c-typeprint.c (c_type_print_varspec_prefix): Ditto.
	(c_type_print_varspec_suffix): Ditto.
	(c_type_print_base): Ditto.
	* typeprint.c (print_type_scalar): Ditto.
	* printcmd.c (print_formatted): Ditto.
	* language.c (structured_type): Ditto.
	* cp-support.c (cp_check_namespace_symbol): Allocate type via
	init_type.
	* gdbtypes.c (init_type): Handle TYPE_CODE_NAMESPACE.
	* valops.c (value_namespace_elt): Handle sym == NULL.

2002-11-24  David Carlton  <carlton@@bactrian.org>

	* gdb.c++/namespace.exp: Eliminate some of the single quotes, and
	duplicate some of the single quote tests without the quotes.
	Change "print E::ce" test.
	Add some ptype <namespace> tests.
	* carlton_runnamespace: Use different files for compiler with and
	without debug info.
@
text
@a39 1
#include "gdb_assert.h"
a283 1
    case TYPE_CODE_NAMESPACE:
a615 1
    case TYPE_CODE_NAMESPACE:
a1171 6
      break;

    case TYPE_CODE_NAMESPACE:
      gdb_assert (TYPE_NAME (type) != NULL);
      fputs_filtered ("namespace ", stream);
      fputs_filtered (TYPE_NAME (type), stream);
@


1.22.8.3
log
@2002-11-27  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (add_partial_enumeration): New function.
	(scan_partial_symbols): Call add_partial_enumeration.
	(locate_pdi_sibling): New function.
	(scan_partial_symbols): Call locate_pdi_sibling.  Get rid of
	nesting_level.
	(pdi_needs_namespace): New function.
	(add_partial_symbol): Add 'namespace' arg; calculate full name
	when appropriate.
	(scan_partial_symbols): Update calls to add_partial_symbol.
	(add_partial_enumeration): Ditto.
	(read_enumeration): Add processing_current_prefix to name when
	appropriate.
	(new_symbol): Set names of enumerators and typedefs appropriately
	if processing_has_namespace_info.
	* symtab.c (lookup_symbol_namespace): Rename 'namespace' argument
	to 'namespace_name'.
	* symtab.h: Ditto.
	* symtab.c (lookup_symbol_namespace): Delete FIXME comments; add a
	new one.
	(lookup_symbol_aux_file): New function.
	(lookup_symbol_aux): Delete FIXME comment.
	(lookup_symbol_aux): Don't search static block explicitly; delete
	FIXME comments.
	* valops.c (value_namespace_elt): Update call to
	lookup_symbol_namespace.
	* symtab.h: Update declaration for lookup_symbol_namespace.
	* symtab.c (lookup_symbol_namespace): Delete 'using' argument and
	add 'block' argument; get using directives via iterators.
	(lookup_symbol_aux_using_loop): Delete 'using' argument and add
	'block' argument.
	(lookup_symbol_aux_using): Don't calculate using directives.
	* block.c (block_using_iterator_first): New function.
	(block_using_iterator_next): Ditto.
	* block.h: Add comment.
	(struct block_using_iterator): New struct.
	Declare block_using_iterator_first, block_using_iterator_next.

2002-11-26  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (read_structure_scope): Set type name and
	processing_current_prefix appropriately.
	(new_symbol): Make sure that, in symbols associated to class
	types, the name includes appropriate namespaces.
	* buildsym.h: Rename processing_current_namespace to
	processing_current_prefix.
	* buildsym.c (finish_block): Ditto.
	* dwarf2read.c (psymtab_to_symtab_1): Ditto.
	(read_namespace): Ditto.  Also rename previous_namespace to
	previous_prefix.

	Now come a thousand and one const correctness fixes:
	* p-typeprint.c (pascal_print_type): Const.
	(pascal_type_print_method_args): Const.
	* p-lang.h: Const.
	* m2-typeprint.c (m2_print_type): Const.
	* valops.c (hand_function_call): Const.
	* jv-lang.c (java_primitive_type_from_name): Const.
	* jv-lang.h: Const.
	* jv-typeprint.c (java_print_type): Const.
	* language.c: (unk_lang_print_type): Const.
	* stack.c (frame_info): Const.
	* linespec.c (find_methods): Const.
	(find_method_name): Const
	* f-lang.h: Const.
	* f-typeprint.c (f_print_type): Const.
	* c-typeprint.c (c_print_type): Const.
	* c-lang.h: Const.
	* gdbtypes.h: Const.
	* gdbtypes.c (lookup_primitive_typename): Const.
	* stack.c (print_frame): Const.
	(func_command): Delete pointless cast.
	* linespec.c (find_method_name): Const.
	* language.h: Const.
	* symfile.c (compare_psymbols): Const.
	* symtab.c (completion_list_add_name): Const.
	* breakpoint.c (break_at_finish_at_depth_command_1): Remove
	useless cast.
	(break_at_finish_command_1): Ditto.
	* typeprint.c (type_print): Const.
	* symtab.h: Const.
	* symtab.c (gdb_mangle_name): Const.
	(symbol_init_demangled_name): Const.
	(symbol_demangled_name): Const.
	* defs.h: Const.
	* printcmd.c (build_address_symbolic): Const.
	* valops.c (search_struct_method): Const.
	* cp-valprint.c (cp_is_vtbl_ptr_type): Const.
	(cp_print_value): Const.
	(cp_print_class_member): Const.
	* c-typeprint.c (cp_type_print_derivation_info): Const.
	(c_type_print_varspec_prefix): Const.
	(c_type_print_base): Const.
	* p-valprint.c (pascal_object_is_vtbl_ptr_type): Const.
	(pascal_object_print_value): Const.
	(pascal_object_print_class_member): Const.
	* p-typeprint.c (pascal_type_print_derivation_info): Const.
	(pascal_type_print_varspec_prefix): Const.
	(pascal_type_print_base): Const.
	* jv-typeprint.c (java_type_print_base): Const.
	* jv-lang.h (java_demangle_type_signature): Const.
	* jv-lang.c (java_demangle_type_signature): Const.
	(java_demangled_signature_length): Const.
	(java_demangled_signature_copy): Const.
	* jv-typeprint.c (java_type_print_derivation_info): Const.
	* jv-valprint.c (java_value_print): Const.
	(java_print_value_fields): Const.
	* jv-lang.c (is_object_type): Const.
	(evaluate_subexp_java): Const.
	* stabsread.c (read_cpp_abbrev): Const.
	(complain_about_struct_wipeout): Const.
	(cleanup_undefined_types): Const.
	* gdbtypes.h: Const.
	* gdbtypes.c (add_name): Second arg const.
	(lookup_typename): Const.
	(lookup_unsigned_typename): Const.
	(lookup_signed_typename): Const.
	* linespec.c (find_methods): const char *class_name.
	* symtab.c (gdb_mangle_name): const char *newname.
	* valops.c (destructor_name_p): const char *dname.
	(search_struct_field): First arg const.
	* gdbtypes.c (check_typedef): const char *name (multiple places).
	(cfront_mangle_name): const char *newname.
	* gdbtypes.c (add_mangled_type): const char *tname.
	* valops.c (find_overload_match): const char *obj_type_name.
	* utils.c (gdb_print_host_address): Make first arg const.
	* defs.h: Declare first arg of gdb_print_host_address to be
	const.
	* valarith.c (find_size_for_pointer_math): const char *name.

2002-11-27  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/m-data.cc (main): Add marker comment.
	* gdb.c++/m-data.exp: Use marker comment instead of line numbers.
	* gdb.c++/m-data.cc: Delete superfluous namespace.
	* gdb.c++/m-static.cc: Ditto.
	* gdb.c++/m-static1.cc: Ditto.
	* carlton_runtest: Compare based on gdb.sum, not based on output.
	* carlton_runnamespace: Ditto.

2002-11-26  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Put tests for CClass.
	* gdb.c++/namespace.cc (C): Add CClass.
@
text
@d66 1
a66 1
c_print_type (struct type *type, const char *varstring, struct ui_file *stream,
d135 1
a135 1
  const char *name;
d208 1
a208 1
  const char *name;
d936 1
a936 1
	      const char *name = type_name_no_tag (type);
@


1.22.8.4
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d305 1
a305 1
  const char *address_space_id;
@


1.22.8.5
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003
d220 1
a220 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, show, 1, 1);
d228 1
a228 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, show, 0, 0);
d241 1
a241 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, show, 0, 0);
d251 1
a251 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, show, 1, 0);
d257 1
a257 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, show, 0, 0);
d263 1
a263 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, show, 0, 0);
a267 4
    case TYPE_CODE_TYPEDEF:
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, show, 0, 0);
      break;

d283 1
d548 1
a548 2
      c_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream, show,
				   0, 0);
d554 1
a554 2
      c_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream, show,
				   0, 0);
d560 1
a560 2
      c_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream, show,
				   0, 0);
d569 1
a569 2
      c_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream, show,
				   1, 0);
d597 1
a597 6
      c_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream, show,
				   passed_a_ptr, 0);
      break;

    case TYPE_CODE_TYPEDEF:
      c_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream, show,
d616 1
@


1.22.8.6
log
@2003-06-16  David Carlton  <carlton@@kealia.com>

	* symfile.h: Change formatting.
	* block.c (allocate_block): Rephrase comment.
	* block.h (BLOCK_GCC_COMPILED): Move definition.
	* cp-namespace.c: Include command.h instead of gdbcmd.h.  Update
	comments, reorder functions.
	(lookup_symbol_file): Set symtab when looking for namespace
	symbols.  Update call to lookup_possible_namespace_symbol.
	(initialize_namespace_blocks): Change comment.
	(get_namespace_objfile): Change objfile name.
	(cp_check_namespace_symbol): Extract body into
	check_namespace_symbol_block.
	(check_namespace_symbol_block): New.
	(lookup_namespace_symbol): Make static, rename from
	cp_lookup_symbol.
	(check_possible_namespace_symbols_loop): Update comment.
	(check_one_possible_namespace_symbol): Call
	check_namespace_symbol_block.
	(lookup_possible_namespace_symbol): Make static; rename from
	cp_lookup_possible_namespace_symbol.
	* cp-support.h: Update declarations.
	* Makefile.in (c-typeprint.o): Don't depend on gdb_assert_h.
	(cp-namespace.o): Depend on command_h, not gdbcmd_h.
	* c-typeprint.c: Don't include gdb_assert.h.
	(c_type_print_base): Delete assertion.  Use TYPE_TAG_NAME.
	* dwarf2read.c: Delete double include of cp-support.h.
	(add_partial_symbol): Look at psym for static variables.
	(add_partial_namespace): Update call to
	cp_check_namespace_symbol.
	(locate_pdi_sibling): Update comment.

2003-06-16  David Carlton  <carlton@@kealia.com>

	* gdb.c++/namespace.exp: Add 'maint cp namespace' test.
	* gdb.c++/maint.exp (test_namespace): Change comment.
@
text
@d40 1
d1189 1
d1191 1
a1191 1
      fputs_filtered (TYPE_TAG_NAME (type), stream);
@


1.22.8.7
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d68 1
a68 1
  enum type_code code;
@


1.22.8.8
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d862 1
a862 2
	      if (TYPE_HAS_VTABLE (type)
		  && (strncmp (TYPE_FIELD_NAME (type, i), "__vfp", 5) == 0))
d865 1
a865 1
	      if (strncmp (TYPE_FIELD_NAME (type, i), "_vptr", 5) == 0
d947 1
a947 1
	      int is_constructor = name && strcmp (method_name, name) == 0;
@


1.22.10.1
log
@	* c-typeprint.c (cp_type_print_method_args): Don't recursively
	expand classes in the arguments to methods.
	(c_type_print_base): Use the name of the method to figure out
	if it is a constructor or destructor.  Use the type information
	to print out the method signature, instead of using the demangled
	name.
@
text
@d172 1
a172 2
	  /* Don't recursively expand classes in method arguments.  */
	  type_print (args[i++].type, "", stream, -1);
d926 1
a926 1
	      char *method_name;
d928 1
a928 6
	      int is_constructor, is_destructor;

	      check_stub_method_group (type, i);
	      method_name = TYPE_FN_FIELDLIST_NAME (type, i);
	      is_constructor = name && STREQ (method_name, name);
	      is_destructor = method_name[0] == '~';
d931 6
a972 1

d980 3
a982 2
		  else if (!is_constructor && !is_destructor
			   && !is_type_conversion_operator (type, i, j))
a983 3
		      /* Print the return type for methods other than
			 constructors, destructors, and cast
			 operators.  */
d988 54
a1042 5
		  cp_type_print_method_args (TYPE_FN_FIELD_TYPE (f, j),
					     "",
					     method_name,
					     TYPE_FN_FIELD_STATIC_P (f, j),
					     stream);
@


1.22.10.2
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@d52 2
a53 2
static void c_type_print_varspec_prefix (struct type *, struct ui_file *, int,
				         int, int);
a69 1
  int need_post_space;
d88 1
a88 2
  need_post_space = (varstring != NULL && strcmp (varstring, "") != 0);
  c_type_print_varspec_prefix (type, stream, show, 0, need_post_space);
d196 1
a196 5
   SHOW is always zero on recursive calls.
   
   NEED_POST_SPACE is non-zero when a space will be be needed
   between a trailing qualifier and a field, variable, or function
   name.  */
d200 1
a200 1
			     int show, int passed_a_ptr, int need_post_space)
d214 1
a214 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 1, 1);
d216 1
a216 1
      c_type_print_modifier (type, stream, 1, need_post_space);
d222 1
a222 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 0, 0);
d235 1
a235 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 0, 0);
d245 1
a245 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 1, 0);
d247 1
a247 1
      c_type_print_modifier (type, stream, 1, need_post_space);
d251 1
a251 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 0, 0);
d257 1
a257 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 0, 0);
@


1.22.10.3
log
@	* c-typeprint.c (c_type_print_base): Print method qualifiers.
@
text
@a1002 20

		  /* If the method is const or volatile, this will show up as
		     a qualifier on the first argument.  Handle a missing or
		     corrupt THIS pointer gracefully, since we shouldn't crash
		     on corrupt debug information (if we're going to complain
		     about this it should be in the debug readers, not this
		     late).  */
		  if (!TYPE_FN_FIELD_STATIC_P (f, j)
		      && TYPE_NFIELDS (TYPE_FN_FIELD_TYPE (f, j)) > 0)
		    {
		      struct type *method_type, *this_ptr_type, *this_type;
		      method_type = TYPE_FN_FIELD_TYPE (f, j);
		      this_ptr_type = TYPE_FIELDS (method_type)[0].type;
		      if (TYPE_CODE (this_ptr_type) == TYPE_CODE_PTR)
			{
			  this_type = TYPE_TARGET_TYPE (this_ptr_type);
			  c_type_print_modifier (this_type, stream, 1, 0);
			}
		    }

@


1.22.10.4
log
@        * c-typeprint.c (c_type_print_modifier_before): New function.
        (c_type_print_modifier_after): New function.
        (c_type_print_base): Call c_type_print_modifier_before and
        c_type_print_modifier_after.
@
text
@a338 6
static void
c_type_print_modifier_before (struct type *type, struct ui_file *stream)
{
  if (current_language->la_language != language_cplus)
    c_type_print_modifier (type, stream, 0, 1);
}
d340 1
a340 6
static void
c_type_print_modifier_after (struct type *type, struct ui_file *stream)
{
  if (current_language->la_language == language_cplus)
    c_type_print_modifier (type, stream, 1, 0);
}
d678 1
a678 1
      c_type_print_modifier_before (type, stream);
a679 1
      c_type_print_modifier_after (type, stream);
d698 1
a698 1
      c_type_print_modifier_before (type, stream);
d731 1
a731 1
      c_type_print_modifier_before (type, stream);
a754 1
	  c_type_print_modifier_after (type, stream);
a1028 2
	  c_type_print_modifier_after (type, stream);

d1039 1
a1039 1
      c_type_print_modifier_before (type, stream);
d1120 1
a1120 1
      c_type_print_modifier_before (type, stream);
d1155 1
a1155 1
	  c_type_print_modifier_before (type, stream);
a1156 1
	  c_type_print_modifier_after (type, stream);
@


1.22.10.5
log
@	* c-typeprint.c (c_type_print_args): Remove.
	(cp_type_print_method_args): Remove unused PREFIX argument.
	Simplify logic.  Skip FIELD_ARTIFICIAL arguments.
	(c_type_print_varspec_suffix): Call cp_type_print_method_args.
	(c_type_print_base): Handle template classes when looking for
	constructor field names.  Update call to cp_type_print_method_args.
@
text
@d44 1
a44 1
static void cp_type_print_method_args (struct type *mtype,
d48 2
d156 1
a156 1
cp_type_print_method_args (struct type *mtype, char *varstring,
d162 1
a162 1
  int i, printed_arg;
d164 1
d168 1
a168 1
  /* Always skip the class variable.  */
d170 1
a170 2
  printed_arg = 0;
  while (i < nargs)
d172 1
a172 2
      /* Don't print artificial arguments.  */
      if (FIELD_ARTIFICIAL (args[i]))
d174 7
a180 2
	  i++;
	  continue;
a181 7

      /* Don't recursively expand classes in method arguments.  */
      type_print (args[i++].type, "", stream, -1);
      printed_arg = 1;

      if (i < nargs || varargs)
	fprintf_filtered (stream, ", ");
d183 1
a183 2

  if (varargs)
d185 1
a185 2
  else if (printed_arg == 0
	   && current_language->la_language == language_cplus)
d353 39
d572 3
a574 1
	cp_type_print_method_args (type, "", 0, stream);
d948 1
a948 1
	      int is_constructor, is_destructor, name_len;
a950 1

d952 1
a952 4
	      name_len = strlen (method_name);
	      is_constructor = name
		&& !strncmp (method_name, name, name_len)
		&& (name[name_len] == 0 || name[name_len] == '<');
a953 1

d1012 1
@


1.22.10.6
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003
d66 1
a66 1
  enum type_code code;
d223 1
a223 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, show, 1, 1);
d231 1
a231 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, show, 0, 0);
d244 1
a244 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, show, 0, 0);
d254 1
a254 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, show, 1, 0);
d260 1
a260 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, show, 0, 0);
d266 1
a266 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, show, 0, 0);
a270 4
    case TYPE_CODE_TYPEDEF:
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, show, 0, 0);
      break;

d286 1
a287 1
    case TYPE_CODE_NAMESPACE:
d307 1
a307 1
  const char *address_space_id;
d522 1
a522 2
      c_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream, show,
				   0, 0);
d528 1
a528 2
      c_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream, show,
				   0, 0);
d534 1
a534 2
      c_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream, show,
				   0, 0);
d541 1
a541 2
      c_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream, show,
				   1, 0);
d569 1
a569 6
      c_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream, show,
				   passed_a_ptr, 0);
      break;

    case TYPE_CODE_TYPEDEF:
      c_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream, show,
d588 1
a589 1
    case TYPE_CODE_NAMESPACE:
d825 1
a825 2
	      if (TYPE_HAS_VTABLE (type)
		  && (strncmp (TYPE_FIELD_NAME (type, i), "__vfp", 5) == 0))
d828 1
a828 1
	      if (strncmp (TYPE_FIELD_NAME (type, i), "_vptr", 5) == 0
a1126 5
      break;

    case TYPE_CODE_NAMESPACE:
      fputs_filtered ("namespace ", stream);
      fputs_filtered (TYPE_TAG_NAME (type), stream);
@


1.21
log
@2002-06-14  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbtypes.h (TYPE_FLAG_VARARGS): Update comment.
        (struct main_type): Remove arg_types member.  Update comments for
        struct field.
        (TYPE_ARG_TYPES): Remove.
        (TYPE_FN_FIELD_ARGS): Update.
        (smash_to_method_type): Update prototype.

        * c-typeprint.c (cp_type_print_method_args): Take method type
        instead of argument list.  Use new argument layout.  Simplify.
        (c_type_print_args): Use new argument layout.  Simplify.
        (c_type_print_base): Update call to cp_type_print_method_args.
        * dwarf2read.c (dwarf2_add_member_fn): Remove unneeded type
        argument; use die->type instead.  Update call to
        smash_to_method_type.
        (read_structure_scope): Update call to dwarf2_add_member_fn.
        * gdbtypes.c (allocate_stub_method): Update comment.
        (smash_to_method_type): Take new NARGS and VARARGS arguments.
        Use new argument layout.
        (check_stub_method): Use new argument layout.  Don't count
        void as an argument.
        (print_arg_types): Update comments.  Use new argument layout.
        (recursive_dump_type): Don't print arg_types member.
        * hpread.c (hpread_read_struct_type): Use new argument layout.
        (fixup_class_method_type): Likewise.
        (hpread_type_lookup): Likewise.
        * stabsread.c (read_type): Update calls to read_args and
        smash_to_method_type.
        (read_args): Use new argument layout.  Simplify.
        * valops.c (typecmp): Use new argument layout.  Update parameters
        and comments.  Simplify.
        (hand_function_call): Use new argument layout.
        (search_struct_method): Update call to typecmp.
        (find_overload_match): Use new argument layout.
@
text
@d24 1
a24 1
#include "obstack.h"
@


1.20
log
@2002-05-14  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbtypes.h: Update accessor macros to use TYPE_MAIN_TYPE.
        (TYPE_CONST, TYPE_VOLATILE, TYPE_CODE_SPACE, TYPE_DATA_SPACE): Use
        TYPE_INSTANCE_FLAGS.
        (struct main_type): New.
        (struct type): Move most members to struct main_type.  Change
        cv_type and as_type to new type_chain member.  Add instance_flags.
        (TYPE_MAIN_TYPE, TYPE_CHAIN, TYPE_INSTANCE_FLAGS): New macros.
        (TYPE_CV_TYPE, TYPE_AS_TYPE): Remove.
        (finish_cv_type): Remove prototype.
        * gdbtypes.c (alloc_type): Update comment.  Allocate TYPE_MAIN_TYPE.
        Set TYPE_CHAIN.
        (alloc_type_instance): New function.
        (smash_type): New function.
        (make_pointer_type, make_reference_type, make_function_type)
        (smash_to_member_type, smash_to_method_type): Call smash_type.
        (make_qualified_type): New function.
        (make_type_with_address_space): Call make_qualified_type.
        (make_cv_type): Likewise.
        (finish_cv_type): Remove unnecessary function.
        (replace_type): Update comment.  Copy TYPE_MAIN_TYPE.
        (recursive_dump_type): Dump TYPE_CHAIN and TYPE_INSTANCE_FLAGS;
        remove TYPE_CV_TYPE and TYPE_AS_TYPE.
        * c-typeprint.c (c_type_print_modifier): Use TYPE_INSTANCE_FLAGS.
        * dwarf2read.c (read_structure_scope): Don't call finish_cv_type.
        * hpread.c (hpread_read_struct_type): Likewise.
        * stabsread.c (read_struct_type): Likewise.

2002-05-14  Daniel Jacobowitz  <drow@@mvista.com>

        * gdb.base/maint.exp (maint print type): Update for new type
        structure.
@
text
@d44 1
a44 1
static void cp_type_print_method_args (struct type ** args, char *prefix,
d150 1
d154 1
a154 1
cp_type_print_method_args (struct type **args, char *prefix, char *varstring,
d157 3
d165 4
a168 1
  if (args && args[!staticp] && TYPE_CODE (args[!staticp]) != TYPE_CODE_VOID)
d170 1
a170 2
      i = !staticp;		/* skip the class variable */
      while (1)
d172 6
a177 12
	  type_print (args[i++], "", stream, 0);
	  if (!args[i])
	    {
	      fprintf_filtered (stream, " ...");
	      break;
	    }
	  else if (TYPE_CODE (args[i]) != TYPE_CODE_VOID)
	    {
	      fprintf_filtered (stream, ", ");
	    }
	  else
	    break;
d180 2
d183 1
a183 3
    {
      fprintf_filtered (stream, "void");
    }
d339 1
a339 1
  struct type **args;
d342 1
a342 1
  args = TYPE_ARG_TYPES (type);
d345 6
a350 10
      if (args[1] == NULL)
	{
	  fprintf_filtered (stream, "...");
	}
      else if ((TYPE_CODE (args[1]) == TYPE_CODE_VOID) &&
	       (current_language->la_language == language_cplus))
	{
	  fprintf_filtered (stream, "void");
	}
      else
d352 2
a353 3
	  for (i = 1;
	       args[i] != NULL && TYPE_CODE (args[i]) != TYPE_CODE_VOID;
	       i++)
d355 2
a356 10
	      c_print_type (args[i], "", stream, -1, 0);
	      if (args[i + 1] == NULL)
		{
		  fprintf_filtered (stream, "...");
		}
	      else if (TYPE_CODE (args[i + 1]) != TYPE_CODE_VOID)
		{
		  fprintf_filtered (stream, ",");
		  wrap_here ("    ");
		}
d359 5
d1005 9
a1013 4
			cp_type_print_method_args (TYPE_FN_FIELD_ARGS (f, j), "",
						   method_name,
					      TYPE_FN_FIELD_STATIC_P (f, j),
						   stream);
@


1.20.4.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d44 1
a44 1
static void cp_type_print_method_args (struct type *mtype, char *prefix,
a149 1

d153 1
a153 1
cp_type_print_method_args (struct type *mtype, char *prefix, char *varstring,
a155 3
  struct field *args = TYPE_FIELDS (mtype);
  int nargs = TYPE_NFIELDS (mtype);
  int varargs = TYPE_VARARGS (mtype);
d161 1
a161 4

  /* Skip the class variable.  */
  i = staticp ? 0 : 1;
  if (nargs > i)
d163 2
a164 1
      while (i < nargs)
d166 12
a177 6
	  type_print (args[i++].type, "", stream, 0);

	  if (i == nargs && varargs)
	    fprintf_filtered (stream, ", ...");
	  else if (i < nargs)
	    fprintf_filtered (stream, ", ");
a179 2
  else if (varargs)
    fprintf_filtered (stream, "...");
d181 3
a183 1
    fprintf_filtered (stream, "void");
d339 1
a339 1
  struct field *args;
d342 1
a342 1
  args = TYPE_FIELDS (type);
d345 10
a354 6
      int i;

      /* FIXME drow/2002-05-31: Always skips the first argument,
	 should we be checking for static members?  */

      for (i = 1; i < TYPE_NFIELDS (type); i++)
d356 3
a358 2
	  c_print_type (args[i].type, "", stream, -1, 0);
	  if (i != TYPE_NFIELDS (type))
d360 10
a369 2
	      fprintf_filtered (stream, ",");
	      wrap_here ("    ");
a371 5
      if (TYPE_VARARGS (type))
	fprintf_filtered (stream, "...");
      else if (i == 1
	       && (current_language->la_language == language_cplus))
	fprintf_filtered (stream, "void");
d1013 4
a1016 9
			{
			  int staticp = TYPE_FN_FIELD_STATIC_P (f, j);
			  struct type *mtype = TYPE_FN_FIELD_TYPE (f, j);
			  cp_type_print_method_args (mtype,
						     "",
						     method_name,
						     staticp,
						     stream);
			}
@


1.20.4.2
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d24 1
a24 1
#include "gdb_obstack.h"
@


1.20.4.3
log
@merge from mainline
@
text
@d52 2
a53 2
static void c_type_print_varspec_prefix (struct type *, struct ui_file *, int,
				         int, int);
a69 1
  int need_post_space;
d88 1
a88 2
  need_post_space = (varstring != NULL && strcmp (varstring, "") != 0);
  c_type_print_varspec_prefix (type, stream, show, 0, need_post_space);
d195 1
a195 5
   SHOW is always zero on recursive calls.
   
   NEED_POST_SPACE is non-zero when a space will be be needed
   between a trailing qualifier and a field, variable, or function
   name.  */
d199 1
a199 1
			     int show, int passed_a_ptr, int need_post_space)
d213 1
a213 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 1, 1);
d215 1
a215 1
      c_type_print_modifier (type, stream, 1, need_post_space);
d221 1
a221 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 0, 0);
d234 1
a234 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 0, 0);
d244 1
a244 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 1, 0);
d246 1
a246 1
      c_type_print_modifier (type, stream, 1, need_post_space);
d250 1
a250 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 0, 0);
d256 1
a256 1
      c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 0, 0);
@


1.20.2.1
log
@merge from trunk
@
text
@d44 1
a44 1
static void cp_type_print_method_args (struct type *mtype, char *prefix,
a149 1

d153 1
a153 1
cp_type_print_method_args (struct type *mtype, char *prefix, char *varstring,
a155 3
  struct field *args = TYPE_FIELDS (mtype);
  int nargs = TYPE_NFIELDS (mtype);
  int varargs = TYPE_VARARGS (mtype);
d161 1
a161 4

  /* Skip the class variable.  */
  i = staticp ? 0 : 1;
  if (nargs > i)
d163 2
a164 1
      while (i < nargs)
d166 12
a177 6
	  type_print (args[i++].type, "", stream, 0);

	  if (i == nargs && varargs)
	    fprintf_filtered (stream, ", ...");
	  else if (i < nargs)
	    fprintf_filtered (stream, ", ");
a179 2
  else if (varargs)
    fprintf_filtered (stream, "...");
d181 3
a183 1
    fprintf_filtered (stream, "void");
d339 1
a339 1
  struct field *args;
d342 1
a342 1
  args = TYPE_FIELDS (type);
d345 10
a354 6
      int i;

      /* FIXME drow/2002-05-31: Always skips the first argument,
	 should we be checking for static members?  */

      for (i = 1; i < TYPE_NFIELDS (type); i++)
d356 3
a358 2
	  c_print_type (args[i].type, "", stream, -1, 0);
	  if (i != TYPE_NFIELDS (type))
d360 10
a369 2
	      fprintf_filtered (stream, ",");
	      wrap_here ("    ");
a371 5
      if (TYPE_VARARGS (type))
	fprintf_filtered (stream, "...");
      else if (i == 1
	       && (current_language->la_language == language_cplus))
	fprintf_filtered (stream, "void");
d1013 4
a1016 9
			{
			  int staticp = TYPE_FN_FIELD_STATIC_P (f, j);
			  struct type *mtype = TYPE_FN_FIELD_TYPE (f, j);
			  cp_type_print_method_args (mtype,
						     "",
						     method_name,
						     staticp,
						     stream);
			}
@


1.19
log
@2002-05-13  Daniel Jacobowitz  <drow@@mvista.com>

        * ax-gdb.c (gen_sign_extend, gen_fetch, gen_usual_unary)
        (gen_cast, gen_scale, gen_add, gen_sub, gen_binop, gen_deref)
        (gen_address_of, gen_struct_ref, gen_repeat): Use type
        access macros.
        * c-typeprint.c (cp_type_print_method_args): Likewise.
        (c_type_print_args): Likewise.
        * d10v-tdep.c (d10v_push_arguments): Likewise.
        (d10v_extract_return_value): Likewise.
        * expprint.c (print_subexp): Likewise.
        * gdbtypes.c (lookup_primitive_typename): Likewise.
        (lookup_template_type, add_mangled_type, print_arg_types): Likewise.
        * gdbtypes.h (TYPE_UNSIGNED, TYPE_NOSIGN, TYPE_STUB)
        (TYPE_TARGET_STUB, TYPE_STATIC, TYPE_CONST, TYPE_VOLATILE)
        (TYPE_PROTOTYPED, TYPE_INCOMPLETE, TYPE_CODE_SPACE, TYPE_VARARGS)
        (TYPE_VECTOR): Likewise.
        * hpread.c (hpread_read_struct_type)
        (fix_static_member_physnames, fixup_class_method_type)
        (hpread_type_lookup): Likewise.
        * mdebugread.c (parse_symbol, parse_type): Likewise.
        * p-lang.c (is_pascal_string_type): Likewise.
        * valops.c (hand_function_call): Likewise.
        * x86-64-tdep.c (classify_argument): Likewise.

        * hpread.c (hpread_read_function_type)
        (hpread_read_doc_function_type): Call replace_type.
        * dstread.c (create_new_type): Delete.
        (decode_dst_structure, process_dst_function): Call alloc_type.
        Use type access macros.
@
text
@d319 1
a319 1
  address_space_id = address_space_int_to_name (TYPE_FLAGS (type));
@


1.18
log
@* c-typeprint.c (c_type_print_varspec_suffix): If a function type
is prototyped and has no arguments, print its argument list as
`(void)'.
@
text
@d161 1
a161 1
  if (args && args[!staticp] && args[!staticp]->code != TYPE_CODE_VOID)
d172 1
a172 1
	  else if (args[i]->code != TYPE_CODE_VOID)
d349 1
a349 1
      else if ((args[1]->code == TYPE_CODE_VOID) &&
d357 1
a357 1
	       args[i] != NULL && args[i]->code != TYPE_CODE_VOID;
d365 1
a365 1
	      else if (args[i + 1]->code != TYPE_CODE_VOID)
@


1.17
log
@2002-01-20  Daniel Jacobowitz  <drow@@mvista.com>

	* buildsym.c: Update copyright years.
	* c-typeprint.c: Likewise.
	* dwarf2read.c: Likewise.
	* f-typeprint.c: Likewise.
	* gdbtypes.c: Likewise.
	* gdbtypes.h: Likewise.
	* hp-symtab-read.c: Likewise.
	* hpread.c: Likewise.
	* mdebugread.c: Likewise.
	* p-typeprint.c: Likewise.
@
text
@d579 3
a581 1
	  if ((len == 0) && (current_language->la_language == language_cplus))
@


1.16
log
@2002-01-20  Daniel Jacobowitz  <drow@@mvista.com>

	* gdbtypes.h (struct cplus_struct_type): Add is_artificial to
	member function fields.  Add accessor macro
	TYPE_FN_FIELD_ARTIFICIAL.
	* dwarf2read.c (dwarf2_add_member_fn): Check for artificial methods.
	* c-typeprint.c (c_type_print_base): Skip artificial member
	functions.
@
text
@d3 1
a3 1
   1999, 2000
@


1.15
log
@        * c-typeprint.c (is_type_conversion_operator): Add additional
        check for non-conversion operators.
@
text
@d645 3
a647 3
  register int i;
  register int len;
  register int lastval;
d910 3
a912 1
	  /* If there are both fields and methods, put a space between. */
d914 11
a924 1
	  if (len && section_type != s_none)
d943 3
@


1.14
log
@        * c-typeprint.c (is_type_conversion_operator): Fix thinko.
@
text
@d405 7
a411 1
  if (strncmp (name, "new", 3) == 0)
@


1.13
log
@Approved by Jim Blandy:

	2001-12-11  Fred Fish  <fnf@@redhat.com>
	* c-typeprint.c (c_type_print_base): Use type flags access macros
	to test bits.
	* ch-typeprint.c (chill_type_print_base): Ditto.
	* ch-valprint.c (chill_val_print): Ditto.
	* d10v-tdep.c (d10v_pointer_to_address): Ditto.
	* dwarf2read.c (dwarf2_add_member_fn): Ditto.
	* dwarfread.c (read_structure_scope): Ditto.
	* gdbtypes.c (create_range_type): Dittol
	(create_set_type): Ditto.
	(check_typedef): Ditto.
	* jv-typeprint.c (java_type_print_base): Ditto.
	* p-typeprint.c (pascal_type_print_base): Ditto
	* p-valprint.c (pascal_val_print): Ditto.
	* stabsread.c (read_cfront_member_functions): Ditto.
	(read_member_functions): Ditto.
	(cleanup_undefined_types): Ditto.
	* valprint.c (val_print): Ditto.
	* valops.c (hand_function_call): Remove is_prototyped
	variable and just use type flag test macro directly.
@
text
@d410 3
a412 1
    return 0;
@


1.12
log
@2001-11-14  Michael Snyder  <msnyder@@redhat.com>
	Add address space identifiers to expression language for types.
	* c-exp.y (space_identifier, cv_with_space_id,
	const_or_volatile_or_space_identifier_noopt,
	const_or_volatile_or_space_identifier): New terminals.
	(ptype): Accept const_or_volatile_or_space_identifier.
	(typebase): Accept const_or_volatile_or_space_identifier.
	* c-typeprint.c (c_type_print_cv_qualifier): Rename to
	c_type_print_modifier.  Handle address space modified types.
	* gdbtypes.h (TYPE_FLAG_CODE_SPACE, TYPE_FLAG_DATA_SPACE):
	New type flags.
	(struct type): Add new field as_type for addr-space qualified types.
	(TYPE_AS_TYPE): New macro, retrieves the chain of types that are
	identical to this one except for address-space qualification.
	* gdbtypes.c (alloc_type): Initialize new field 'as_type'.
	(address_space_name_to_int): New function.
	(address_space_int_to_name): New function.
	(make_type_with_address_space): New function.
	(make_cv_type): Handle as_type field of new struct type object.
	* parse.c (check_type_stack_depth): New function.
	(push_type_address_space): New function.
	(follow_types): Handle types with address-space qualifier.
	* parser-defs.h (enum type_pieces): Add enum tp_space_identifier.
@
text
@d754 1
a754 1
	      if (TYPE_FLAGS (type) & TYPE_FLAG_STUB)
@


1.11
log
@(Changes from Daniel Berlin, with revisions by Jim Blandy.)

Abstract out operations specific to particular C++ ABI's, and
invoke them through a function table.  This removes the C++ ABI
dependencies scattered throughout the code, and allows us to
cleanly add support for new C++ ABI's.
* cp-abi.h, cp-abi.h, gnu-v2-abi.c, hpacc-abi.c: New files.
* c-typeprint.c, c-valprint.c, dbxread.c, eval.c, gdbtypes.c,
jv-typeprint.c, linespec.c, symtab.c, typeprint.c, valops.c:
#include "cp-abi.h".  These files all use functions now declared
there.
* symtab.h (OPNAME_PREFIX_P, VTBL_PREFIX_P, DESTRUCTOR_PREFIX_P):
Deleted.  These services are now provided by functions declared in
cp-abi.h.
* value.h (value_rtti_type, value_virtual_fn_field): Same.
* values.c (value_virtual_fn_field): Same, for this definition.
* valops.c (value_rtti_type): Same.
* c-typeprint.c (c_type_print_base): Use the functions from
"cp-abi.h", instead of the old macros, or hard-coded ABI-specific
tests.
* dbxread.c (record_minimal_symbol): Same.
* gdbtypes.c (get_destructor_fn_field, virtual_base_index,
virtual_base_index_skip_primaries): Same.
* jv-typeprint.c (java_type_print_base): Same.
* linespec.c (find_methods, decode_line_1): Same.
* symtab.c (gdb_mangle_name): Same.
* Makefile.in (SFILES): Add the new .c files mentioned above.
(cp_abi_h): New variable.
(COMMON_OBS): Add gnu-v2-abi.o, hpacc-abi.o, and cp-abi.o.
(cp-abi.o, gnu-v2-abi.o, hpacc-abi.o): New targets.
(c-typeprint.o, c-valprint.o, dbxread.o, eval.o, gdbtypes.o,
jv-typeprint.o, symtab.o, linespec.o, typeprint.o, valops.o): Add
dependency on $(cp_abi_h).
@
text
@d55 3
a57 2
static void c_type_print_cv_qualifier (struct type *, struct ui_file *,
				       int, int);
d215 1
a215 1
      c_type_print_cv_qualifier (type, stream, 1, 0);
d246 1
a246 1
      c_type_print_cv_qualifier (type, stream, 1, 0);
d293 2
a294 2
c_type_print_cv_qualifier (struct type *type, struct ui_file *stream,
			   int need_pre_space, int need_post_space)
d296 2
a297 1
  int flag = 0;
d308 1
a308 1
      flag = 1;
d313 1
a313 1
      if (flag || need_pre_space)
d316 1
a316 1
      flag = 1;
d319 10
a328 1
  if (flag && need_post_space)
d669 1
a669 1
      c_type_print_cv_qualifier (type, stream, 0, 1);
d689 1
a689 1
      c_type_print_cv_qualifier (type, stream, 0, 1);
d722 1
a722 1
      c_type_print_cv_qualifier (type, stream, 0, 1);
d1037 1
a1037 1
      c_type_print_cv_qualifier (type, stream, 0, 1);
d1118 1
a1118 1
      c_type_print_cv_qualifier (type, stream, 0, 1);
d1153 1
a1153 1
	  c_type_print_cv_qualifier (type, stream, 0, 1);
@


1.11.2.1
log
@Typesystem work initial import.
Note that this currently isn't building, i'm in the middle of converting make_function_type/lookup_function_type
@
text
@d131 1
a131 1
  const char *name;
d160 1
a160 1
  if (args && args[!staticp] && TYPE_CODE(args[!staticp]) != TYPE_CODE_VOID)
d171 1
a171 1
	  else if (TYPE_CODE(args[i]) != TYPE_CODE_VOID)
d200 1
a200 1
  const char *name;
d212 1
a212 1
      c_type_print_varspec_prefix (POINTER_TARGET_TYPE (type), stream, 0, 1);
d243 1
a243 1
      c_type_print_varspec_prefix (POINTER_TARGET_TYPE (type), stream, 0, 1);
d249 1
a249 1
      c_type_print_varspec_prefix (FUNCTION_RETURN_VALUE (type), stream, 0, 0);
d255 1
a255 1
      c_type_print_varspec_prefix (ARRAY_ELEMENT_TYPE (type), stream, 0, 0);
d338 1
a338 1
      else if ((TYPE_CODE(args[1]) == TYPE_CODE_VOID) &&
d346 1
a346 1
	       args[i] != NULL && TYPE_CODE(args[i]) != TYPE_CODE_VOID;
d354 1
a354 1
	      else if (TYPE_CODE(args[i + 1]) != TYPE_CODE_VOID)
d522 2
a523 1
      if (TYPE_LENGTH (type) >= 0 && TYPE_LENGTH (ARRAY_ELEMENT_TYPE (type)) > 0)
d526 1
a526 1
			   / TYPE_LENGTH (ARRAY_ELEMENT_TYPE (type))));
a548 2
      c_type_print_varspec_suffix (POINTER_TARGET_TYPE (type), stream, 0, 1, 0);
      break;
d550 1
a550 1
      c_type_print_varspec_suffix (POINTER_TARGET_TYPE (type), stream, 0, 1, 0);
d558 1
a558 1
	  int i, len = FUNCTION_NUM_ARGUMENTS (type);
d572 1
a572 1
		c_print_type (FUNCTION_ARGUMENT_TYPE (type, i), "", stream, -1, 0);
d576 1
a576 1
      c_type_print_varspec_suffix (FUNCTION_RETURN_VALUE (type), stream, 0,
d667 2
d670 1
a671 5
      c_type_print_base (POINTER_TARGET_TYPE (type), stream, show, level);
      break;
    case TYPE_CODE_ARRAY:
      c_type_print_base (ARRAY_ELEMENT_TYPE (type), stream, show, level);
      break;
a672 4
      c_type_print_base (FUNCTION_RETURN_VALUE (type), stream, show, level);
      break;
    case TYPE_CODE_TYPEDEF:
    case TYPE_CODE_MEMBER:
d686 1
a686 1
	    case DT_class:
d689 1
a689 1
	    case DT_union:
d692 1
a692 1
	    case DT_struct:
d760 2
a761 2
	  if ((TYPE_DECLARED_TYPE (type) == DT_class) ||
	      (TYPE_DECLARED_TYPE (type) == DT_template))
d789 2
a790 2
	  else if ((TYPE_DECLARED_TYPE (type) == DT_struct) ||
		   (TYPE_DECLARED_TYPE (type) == DT_union))
d902 1
a902 1
	      const char *name = type_name_no_tag (type);
d1064 1
a1064 1
	  len = ENUM_NUM_VALUES (type);
d1072 2
a1073 2
	      fputs_filtered (ENUM_VALUE_NAME (type, i), stream);
	      if (lastval != ENUM_VALUE_VALUE (type, i))
d1075 2
a1076 2
		  fprintf_filtered (stream, " = %d", ENUM_VALUE_VALUE (type, i));
		  lastval = ENUM_VALUE_VALUE (type, i);
@


1.10
log
@* c-typeprint.c (c_type_print_cv_qualifier): Don't print `const'
qualifier on C++ references; all references are innately const.
@
text
@d36 1
d908 4
a911 5
		  ((physname[0] == '_' && physname[1] == '_'
		    && strchr ("0123456789Qt", physname[2]))
		   || STREQN (physname, "__ct__", 6)
		   || DESTRUCTOR_PREFIX_P (physname)
		   || STREQN (physname, "__dt__", 6));
@


1.9
log
@* arch-utils.c (#include "gdbthread.h"): Removed.
(#include "symfile.h"): Removed.
(XMALLOC): Removed unused macro.
* breakpoint.c (tbreak_command): Removed local declaration.
(awatch_command, do_enable_breakpoint, set_breakpoint_count):
Remove duplicate declarations.
(bpstat_should_step, bpstat_have_active_hw_watchpoints)
(remove_solib_event_breakpoints): Fix indentation botch.
* c-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* ch-exp.c (ch_terminal_match_float_literal, parse_expr)
(parse_primval, parse_untyped_expr, parse_opt_untyped_expr):
Removed duplicate declarations.
* ch-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* corefile.c (#include "frame.h"): Removed
(#include "symfile.h"): Removed.
(#include "language.h"): Removed.
* dbxread.c (#include "command.h"): Removed.
* environ.c (#include "gdbcore.h"): Removed.
* event-loop.c (#include "top.h"): Removed.
* f-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
(#include "language.h"): Removed.
(#include "typeprint.h"): Removed.
(#include "frame.h"): Removed.
* gdbtypes.h (print_type_scalar): Removed declaration.
* infcmd.c (#include "completer.h"): Removed.
* language.c (#include "frame.h"): Removed.
* m2-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
(#include "language.h"): Removed.
* m2-valprint.c (#include "valprint.h"): Removed.
* p-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* p-valprint.c (#include "typeprint.h"): Removed.
* parse.c (#include "linespec.h"): Removed.
* regcache.c (#include "frame.h"): Removed.
* remote.c (#include "frame.h"): Removed.
(getpkt_sane): Make static.
* source.c (#include "completer.h"): Removed.
* stack.c (#include "symfile.h"): Removed.
(#include "objfiles.h"): Removed.
* symfile.c (#include "completer.h"): Removed.
* tracepoint.c (#include "completer.h"): Removed.
* values.c (#include "frame.h"): Removed.
* varobj.c (#include "valprint.h"): Removed.
* wrapper.c (#include "frame.h"): Removed.

* memattr.c (create_mem_region): Removed unused variable.
* remote-nrom.c: Removed spurious semicolon after init_nrom_ops.
-------------------------------------------------------------------
@
text
@d296 5
a300 1
  if (TYPE_CONST (type))
@


1.8
log
@Revert previous change, committed to trunk accidentally.
@
text
@a31 2
#include "command.h"
#include "gdbcmd.h"
@


1.7
log
@A single-file branch to help me keep things straight while adapting
GDB to the GNU V3 C++ ABI.

* c-typeprint.c: Commit Dan Berlin's changes.
@
text
@a37 1
#include "cp-abi.h"
d905 5
a909 4
		   is_constructor_name (physname) 
		   || is_destructor_name (physname)
		   || method_name[0] == '~';

@


1.6
log
@2001-03-06  J.T. Conklin  <jtc@@redback.com>

        * symtab.h (decode_line_1): Removed declaration.

        * symfile.c (#include <assert.h>): Removed.

        * arch-utils.c (#include <ctype.h>): Removed.
        * c-typeprint.c: Likewise.
        * dbxread.c: Likewise.
        * gdbtypes.c: Likewise.
        * target.c: Likewise.
        * os9kread.c: Likewise.

        * c-valprint.c (#include "demangle.h"): Removed.
        * ch-typeprint.c: Likewise.
        * eval.c: Likewise.
        * f-typeprint.c: Likewise.
        * f-valprint.c: Likewise.
        * m2-typeprint.c: Likewise.
        * typeprint.c: Likewise.
        * p-typeprint.c: Likewise.
        * valarith.c: Likewise.
        * valprint.c: Likewise.

        * m2-typeprint.c (#include "gdb_string.h"): Removed.
        * nlmread.c: Likewise.

        * mdebugread.c (#include "gdb-stabs.h"): Removed.
        * minsyms.c: Likewise.
        * mipsread.c: Likewise.
        * nlmread.c: Likewise.

        * m2-typeprint.c (#include "obstack.h"): Removed.
        * m2-valprint.c: Likewise.

        * event-loop.c (#include <setjmp.h>): Removed.
@
text
@d38 1
d906 4
a909 5
		  ((physname[0] == '_' && physname[1] == '_'
		    && strchr ("0123456789Qt", physname[2]))
		   || STREQN (physname, "__ct__", 6)
		   || DESTRUCTOR_PREFIX_P (physname)
		   || STREQN (physname, "__dt__", 6));
@


1.6.2.1
log
@A single-file branch to help me keep things straight while adapting
GDB to the GNU V3 C++ ABI.

* c-typeprint.c: Commit Dan Berlin's changes.
@
text
@a37 1
#include "cp-abi.h"
d905 5
a909 4
		   is_constructor_name (physname) 
		   || is_destructor_name (physname)
		   || method_name[0] == '~';

@


1.5
log
@Update/correct copyright notices.
@
text
@a40 1
#include <ctype.h>
@


1.4
log
@Replace free() with xfree().
@
text
@d2 2
a3 1
   Copyright 1986, 1988, 1989, 1991, 1993-1996, 1998-2000
@


1.3
log
@
2000-09-04 Pierre Muller <muller@@ics.u-strasbg.fr>
	* c-typeprint.c (c_typedef_print): remove (replaced by typedef_print in
	typeprint.c).
	* typeprint.c (typedef_print): new function. (old c_typedef_print
	function with pascal language support added).
	* value.h (c_printdef_print): removed.
	(typedef_print): declare.
	* symtab.c (print_symbol_info): call to c_typedef_print replaced by
	call to typedef_print.
@
text
@d998 1
a998 1
			  free (demangled_no_static);
d1002 1
a1002 1
		      free (demangled_name);
d1006 1
a1006 1
		    free (mangled_name);
@


1.2
log
@Protoization.
@
text
@a60 48
/* Print a description of a type in the format of a 
   typedef for the current language.
   NEW is the new name for a type TYPE. */

void
c_typedef_print (struct type *type, struct symbol *new, struct ui_file *stream)
{
  CHECK_TYPEDEF (type);
  switch (current_language->la_language)
    {
#ifdef _LANG_c
    case language_c:
    case language_cplus:
      fprintf_filtered (stream, "typedef ");
      type_print (type, "", stream, 0);
      if (TYPE_NAME ((SYMBOL_TYPE (new))) == 0
	  || !STREQ (TYPE_NAME ((SYMBOL_TYPE (new))), SYMBOL_NAME (new)))
	fprintf_filtered (stream, " %s", SYMBOL_SOURCE_NAME (new));
      break;
#endif
#ifdef _LANG_m2
    case language_m2:
      fprintf_filtered (stream, "TYPE ");
      if (!TYPE_NAME (SYMBOL_TYPE (new)) ||
	  !STREQ (TYPE_NAME (SYMBOL_TYPE (new)), SYMBOL_NAME (new)))
	fprintf_filtered (stream, "%s = ", SYMBOL_SOURCE_NAME (new));
      else
	fprintf_filtered (stream, "<builtin> = ");
      type_print (type, "", stream, 0);
      break;
#endif
#ifdef _LANG_chill
    case language_chill:
      fprintf_filtered (stream, "SYNMODE ");
      if (!TYPE_NAME (SYMBOL_TYPE (new)) ||
	  !STREQ (TYPE_NAME (SYMBOL_TYPE (new)), SYMBOL_NAME (new)))
	fprintf_filtered (stream, "%s = ", SYMBOL_SOURCE_NAME (new));
      else
	fprintf_filtered (stream, "<builtin> = ");
      type_print (type, "", stream, 0);
      break;
#endif
    default:
      error ("Language not supported.");
    }
  fprintf_filtered (stream, ";\n");
}

@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1986, 1988, 1989, 1991, 1993, 1994, 1995, 1996, 1998, 1999
d5 1
a5 1
This file is part of GDB.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d45 5
a49 2
static void
c_type_print_args PARAMS ((struct type *, GDB_FILE *));
d51 1
a51 2
static void
cp_type_print_derivation_info PARAMS ((GDB_FILE *, struct type *));
d53 2
a54 2
void
c_type_print_varspec_prefix PARAMS ((struct type *, GDB_FILE *, int, int));
d56 3
a58 2
static void
c_type_print_cv_qualifier PARAMS ((struct type *, GDB_FILE *, int, int));
a60 1

d66 1
a66 4
c_typedef_print (type, new, stream)
   struct type *type;
   struct symbol *new;
   GDB_FILE *stream;
d69 2
a70 2
   switch (current_language->la_language)
   {
d72 7
a78 7
   case language_c:
   case language_cplus:
      fprintf_filtered(stream, "typedef ");
      type_print(type,"",stream,0);
      if(TYPE_NAME ((SYMBOL_TYPE (new))) == 0
	 || !STREQ (TYPE_NAME ((SYMBOL_TYPE (new))), SYMBOL_NAME (new)))
	fprintf_filtered(stream,  " %s", SYMBOL_SOURCE_NAME(new));
d82 5
a86 5
   case language_m2:
      fprintf_filtered(stream, "TYPE ");
      if(!TYPE_NAME(SYMBOL_TYPE(new)) ||
	 !STREQ (TYPE_NAME(SYMBOL_TYPE(new)), SYMBOL_NAME(new)))
	fprintf_filtered(stream, "%s = ", SYMBOL_SOURCE_NAME(new));
d88 2
a89 2
	 fprintf_filtered(stream, "<builtin> = ");
      type_print(type,"",stream,0);
d93 5
a97 5
   case language_chill:
      fprintf_filtered(stream, "SYNMODE ");
      if(!TYPE_NAME(SYMBOL_TYPE(new)) ||
	 !STREQ (TYPE_NAME(SYMBOL_TYPE(new)), SYMBOL_NAME(new)))
	fprintf_filtered(stream, "%s = ", SYMBOL_SOURCE_NAME(new));
d99 2
a100 2
	 fprintf_filtered(stream, "<builtin> = ");
      type_print(type,"",stream,0);
d103 4
a106 4
   default:
      error("Language not supported.");
   }
   fprintf_filtered(stream, ";\n");
d113 2
a114 6
c_print_type (type, varstring, stream, show, level)
     struct type *type;
     char *varstring;
     GDB_FILE *stream;
     int show;
     int level;
d126 2
a127 2
      /* Need a space if going to print stars or brackets;
	 but not if we will print just a type name.  */
d143 1
a143 1
	 so don't print an additional pair of ()'s */
d145 1
a145 1
      demangled_args = strchr(varstring, '(') != NULL;
d149 1
a149 1
  
d154 3
a156 3
	class A { int a; };
	class B : public A {int b; };
	class C : public B {int c; };
d160 3
a162 3
   	class C : public B {
		int c;
	}
d167 3
a169 3
	class C : public B : public A {
		int c;
	}
d178 1
a178 3
cp_type_print_derivation_info (stream, type)
     GDB_FILE *stream;
     struct type *type;
d187 3
a189 3
			BASETYPE_VIA_PUBLIC (type, i) ? "public" 
			: (TYPE_FIELD_PROTECTED (type, i) ? "protected" : "private"),
			BASETYPE_VIA_VIRTUAL(type, i) ? " virtual" : "");
d199 4
a202 8
 
void
cp_type_print_method_args (args, prefix, varstring, staticp, stream)
     struct type **args;
     char *prefix;
     char *varstring;
     int staticp;
     GDB_FILE *stream;
d205 1
a205 1
 
d211 1
a211 1
      i = !staticp;             /* skip the class variable */
d213 14
a226 13
        {
          type_print (args[i++], "", stream, 0);
          if (!args[i])
            {
              fprintf_filtered (stream, " ...");
              break;
            }
          else if (args[i]->code != TYPE_CODE_VOID)
            {
              fprintf_filtered (stream, ", ");
            }
          else break;
        }
d232 1
a232 1
 
d246 2
a247 5
c_type_print_varspec_prefix (type, stream, show, passed_a_ptr)
     struct type *type;
     GDB_FILE *stream;
     int show;
     int passed_a_ptr;
d275 1
a275 1
        c_type_print_base (TYPE_DOMAIN_TYPE (type), stream, 0, passed_a_ptr);
d325 1
d327 4
a330 1
	 gcc -Wall will reveal any types that haven't been handled.  */
d341 2
a342 5
c_type_print_cv_qualifier (type, stream, need_pre_space, need_post_space)
  struct type *type;
  GDB_FILE *stream;
  int need_pre_space;
  int need_post_space;
d345 1
a345 1
  
d349 1
a349 1
        fprintf_filtered (stream, " ");
d353 1
a353 1
  
d357 1
a357 1
        fprintf_filtered (stream, " ");
d370 1
a370 3
c_type_print_args (type, stream)
     struct type *type;
     GDB_FILE *stream;
d384 4
a387 4
               (current_language->la_language == language_cplus))
        {
          fprintf_filtered (stream, "void");
        }
d395 1
a395 1
	      if (args[i+1] == NULL)
d399 1
a399 1
	      else if (args[i+1]->code != TYPE_CODE_VOID)
d411 1
a411 1
  
d415 129
d549 2
a550 6
c_type_print_varspec_suffix (type, stream, show, passed_a_ptr, demangled_args)
     struct type *type;
     GDB_FILE *stream;
     int show;
     int passed_a_ptr;
     int demangled_args;
d565 1
a565 1
      
d568 1
a568 1
	  && TYPE_ARRAY_UPPER_BOUND_TYPE(type) != BOUND_CANNOT_BE_DETERMINED)
d573 1
a573 1
      
d602 2
a603 1
	{ int i, len = TYPE_NFIELDS (type);
d605 14
a618 14
          if ((len == 0) && (current_language->la_language == language_cplus))
            {
              fprintf_filtered (stream, "void");
            }
          else
            for (i = 0; i < len; i++)
              {
                if (i > 0)
                  {
                    fputs_filtered (", ", stream);
                    wrap_here ("    ");
                  }
                c_print_type (TYPE_FIELD_TYPE (type, i), "", stream, -1, 0);
              }
d641 1
d643 4
a646 1
	 gcc -Wall will report types that may not have been considered.  */
d668 2
a669 5
c_type_print_base (type, stream, show, level)
     struct type *type;
     GDB_FILE *stream;
     int show;
     int level;
d677 5
a681 1
  enum {s_none, s_public, s_private, s_protected} section_type;
d709 1
a709 1
	  
d727 26
a752 22
      if (HAVE_CPLUS_STRUCT (type)) {
        switch (TYPE_DECLARED_TYPE(type)) {
          case DECLARED_TYPE_CLASS:
	    fprintf_filtered (stream, "class ");
            break;
          case DECLARED_TYPE_UNION:
            fprintf_filtered (stream, "union ");
            break;
          case DECLARED_TYPE_STRUCT:
            fprintf_filtered (stream, "struct ");
            break;
          default:
            /* If there is a CPLUS_STRUCT, assume class if not
             * otherwise specified in the declared_type field.
             */
	    fprintf_filtered (stream, "class ");
            break;
        } /* switch */
      } else {
        /* If not CPLUS_STRUCT, then assume it's a C struct */ 
        fprintf_filtered (stream, "struct ");
      }
d768 1
a768 1
          strncmp(TYPE_TAG_NAME(type), "{unnamed", 8))
d784 1
a784 1
	  
d800 65
a864 65
          /* For a class, if all members are private, there's no need
             for a "private:" label; similarly, for a struct or union
             masquerading as a class, if all members are public, there's
             no need for a "public:" label. */ 

          if ((TYPE_DECLARED_TYPE (type) == DECLARED_TYPE_CLASS) ||
               (TYPE_DECLARED_TYPE (type) == DECLARED_TYPE_TEMPLATE))
            {
              QUIT;
              len = TYPE_NFIELDS (type);
              for (i = TYPE_N_BASECLASSES (type); i < len; i++)
                if (!TYPE_FIELD_PRIVATE (type, i))
                  {
                    need_access_label = 1;
                    break;
                  }
              QUIT;
              if (!need_access_label)
                {
                  len2 = TYPE_NFN_FIELDS (type);
                  for (j = 0; j < len2; j++)
                    {
                      len = TYPE_FN_FIELDLIST_LENGTH (type, j);
                      for (i = 0; i < len; i++)
                        if (!TYPE_FN_FIELD_PRIVATE (TYPE_FN_FIELDLIST1 (type, j), i))
                          {
                            need_access_label = 1;
                            break;
                          }
                      if (need_access_label)
                        break;
                    }
                }
            }
          else if ((TYPE_DECLARED_TYPE (type) == DECLARED_TYPE_STRUCT) ||
                   (TYPE_DECLARED_TYPE (type) == DECLARED_TYPE_UNION))
            {
              QUIT;
              len = TYPE_NFIELDS (type);
              for (i = TYPE_N_BASECLASSES (type); i < len; i++)
                if (TYPE_FIELD_PRIVATE (type, i) || TYPE_FIELD_PROTECTED (type, i))
                  {
                    need_access_label = 1;
                    break;
                  }
              QUIT;
              if (!need_access_label)
                {
                  len2 = TYPE_NFN_FIELDS (type);
                  for (j = 0; j < len2; j++)
                    {
                      QUIT;
                      len = TYPE_FN_FIELDLIST_LENGTH (type, j);
                      for (i = 0; i < len; i++)
                        if (TYPE_FN_FIELD_PRIVATE (TYPE_FN_FIELDLIST1 (type, j), i) ||
                            TYPE_FN_FIELD_PROTECTED (TYPE_FN_FIELDLIST1 (type, j), i))
                          {
                            need_access_label = 1;
                            break;
                          }
                      if (need_access_label)
                        break;
                    }
                }
            }
d874 4
a877 5
              /* HP ANSI C++ case */
              if (TYPE_HAS_VTABLE(type) && (STREQN (TYPE_FIELD_NAME (type, i), "__vfp", 5)))
                 continue;
              /* Other compilers */
              /* pai:: FIXME : check for has_vtable < 0 */
d883 1
a883 1
		 labels. */
d939 1
a939 1
	     fprintf_filtered (stream, "\n");
d948 1
a948 1
	      int is_constructor = name && STREQ(method_name, name);
d952 6
a957 6
		  int is_full_physname_constructor = 
		    ((physname[0] == '_' && physname[1] == '_'
		      && strchr ("0123456789Qt", physname[2]))
		     || STREQN (physname, "__ct__", 6)
		     || DESTRUCTOR_PREFIX_P (physname)
		     || STREQN (physname, "__dt__", 6));
d995 1
a995 1
			       TYPE_FN_FIELD_PHYSNAME (f, j));
d998 3
a1000 4
		  else if (!is_constructor &&                  /* constructors don't have declared types */
                           !is_full_physname_constructor &&    /*    " "  */ 
                           !strstr (method_name, "operator ")) /* Not a type conversion operator */
                                                               /* (note space -- other operators don't have it) */ 
d1018 4
a1021 4
			 if a function has more than 10 arguments, 
			 the demangling will fail.
			 Let's try to reconstruct the function signature from 
			 the symbol information	*/
d1025 1
a1025 1
						   TYPE_FN_FIELD_STATIC_P (f, j),
d1034 4
a1037 9
		      char *demangled_no_class = demangled_name;
		      
		      while (p = strchr (demangled_no_class, ':'))
			{
			  demangled_no_class = p;
			  if (*++demangled_no_class == ':')
			    ++demangled_no_class;
			}
		      /* get rid of the static word appended by the demangler */
d1044 1
a1044 1
                          *(demangled_no_static + length) = '\0';
d1060 1
a1060 4
      if (TYPE_LOCALTYPE_PTR (type) && show >= 0)
        fprintfi_filtered (level, stream, " (Local at %s:%d)\n",
                           TYPE_LOCALTYPE_FILE (type),
                           TYPE_LOCALTYPE_LINE (type));
d1062 4
a1065 1
	  fprintfi_filtered (level, stream, "}");
d1067 2
a1068 2
      if (TYPE_CODE(type) == TYPE_CODE_TEMPLATE)
        goto go_back;
d1075 12
a1086 12
        switch (TYPE_LENGTH (type))
          {
            case 1:
              fputs_filtered ("char ", stream);
              break;
            case 2:
              fputs_filtered ("short ", stream);
              break;
            default:
              break;
          }
       fprintf_filtered (stream, "enum ");
d1093 1
a1093 1
          strncmp(TYPE_TAG_NAME(type), "{unnamed", 8))
d1115 2
a1116 1
	      if (i) fprintf_filtered (stream, ", ");
d1150 1
a1150 1
           template <class T1, class T2> class "
d1155 8
a1162 7
      for (i = 0; i < TYPE_NTEMPLATE_ARGS(type); i++) {
        struct template_arg templ_arg;
        templ_arg = TYPE_TEMPLATE_ARG(type, i);
        fprintf_filtered (stream, "class %s", templ_arg.name);
        if (i < TYPE_NTEMPLATE_ARGS(type)-1)
          fprintf_filtered (stream, ", ");
      }
d1166 13
a1178 10
      goto struct_union; 
go_back:
      if (TYPE_NINSTANTIATIONS(type) > 0) {
        fprintf_filtered (stream, "\ntemplate instantiations:\n");
        for (i = 0; i < TYPE_NINSTANTIATIONS(type); i++) {
          fprintf_filtered(stream, "  ");
          c_type_print_base (TYPE_INSTANTIATION(type, i), stream, 0, level);
          if (i < TYPE_NINSTANTIATIONS(type)-1) fprintf_filtered(stream, "\n");
        }
      }
d1180 1
a1180 1
       
d1183 3
a1185 3
	 such as fundamental types.  For these, just print whatever
	 the type name is, as recorded in the type itself.  If there
	 is no type name, then complain. */
d1188 1
a1188 1
          c_type_print_cv_qualifier (type, stream, 0, 1);
a1200 9









@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d916 1
a916 1
		      while ((p = strchr (demangled_no_class, ':')))
@


1.1.1.3
log
@import gdb-1999-05-25 snapshot
@
text
@a43 2
static void cp_type_print_method_args PARAMS ((struct type **args, char *prefix, char *varstring, int staticp, GDB_FILE *stream));

d206 1
a206 1
static void
@


1.1.1.4
log
@import gdb-1999-07-07 post reformat
@
text
@d5 1
a5 1
   This file is part of GDB.
d7 13
a19 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d44 1
a44 1
static void cp_type_print_method_args PARAMS ((struct type ** args, char *prefix, char *varstring, int staticp, GDB_FILE * stream));
a56 1

d59 1
d66 3
a68 3
     struct type *type;
     struct symbol *new;
     GDB_FILE *stream;
d71 2
a72 2
  switch (current_language->la_language)
    {
d74 7
a80 7
    case language_c:
    case language_cplus:
      fprintf_filtered (stream, "typedef ");
      type_print (type, "", stream, 0);
      if (TYPE_NAME ((SYMBOL_TYPE (new))) == 0
	  || !STREQ (TYPE_NAME ((SYMBOL_TYPE (new))), SYMBOL_NAME (new)))
	fprintf_filtered (stream, " %s", SYMBOL_SOURCE_NAME (new));
d84 5
a88 5
    case language_m2:
      fprintf_filtered (stream, "TYPE ");
      if (!TYPE_NAME (SYMBOL_TYPE (new)) ||
	  !STREQ (TYPE_NAME (SYMBOL_TYPE (new)), SYMBOL_NAME (new)))
	fprintf_filtered (stream, "%s = ", SYMBOL_SOURCE_NAME (new));
d90 2
a91 2
	fprintf_filtered (stream, "<builtin> = ");
      type_print (type, "", stream, 0);
d95 5
a99 5
    case language_chill:
      fprintf_filtered (stream, "SYNMODE ");
      if (!TYPE_NAME (SYMBOL_TYPE (new)) ||
	  !STREQ (TYPE_NAME (SYMBOL_TYPE (new)), SYMBOL_NAME (new)))
	fprintf_filtered (stream, "%s = ", SYMBOL_SOURCE_NAME (new));
d101 2
a102 2
	fprintf_filtered (stream, "<builtin> = ");
      type_print (type, "", stream, 0);
d105 4
a108 4
    default:
      error ("Language not supported.");
    }
  fprintf_filtered (stream, ";\n");
d132 2
a133 2
  /* Need a space if going to print stars or brackets;
     but not if we will print just a type name.  */
d149 1
a149 1
         so don't print an additional pair of ()'s */
d151 1
a151 1
      demangled_args = strchr (varstring, '(') != NULL;
d155 1
a155 1

d160 3
a162 3
   class A { int a; };
   class B : public A {int b; };
   class C : public B {int c; };
d166 3
a168 3
   class C : public B {
   int c;
   }
d173 3
a175 3
   class C : public B : public A {
   int c;
   }
d195 3
a197 3
			BASETYPE_VIA_PUBLIC (type, i) ? "public"
	       : (TYPE_FIELD_PROTECTED (type, i) ? "protected" : "private"),
			BASETYPE_VIA_VIRTUAL (type, i) ? " virtual" : "");
d207 1
a207 1

d217 1
a217 1

d223 1
a223 1
      i = !staticp;		/* skip the class variable */
d225 13
a237 14
	{
	  type_print (args[i++], "", stream, 0);
	  if (!args[i])
	    {
	      fprintf_filtered (stream, " ...");
	      break;
	    }
	  else if (args[i]->code != TYPE_CODE_VOID)
	    {
	      fprintf_filtered (stream, ", ");
	    }
	  else
	    break;
	}
d243 1
a243 1

d289 1
a289 1
	c_type_print_base (TYPE_DOMAIN_TYPE (type), stream, 0, passed_a_ptr);
d340 1
a340 1
         gcc -Wall will reveal any types that haven't been handled.  */
d352 4
a355 4
     struct type *type;
     GDB_FILE *stream;
     int need_pre_space;
     int need_post_space;
d358 1
a358 1

d362 1
a362 1
	fprintf_filtered (stream, " ");
d366 1
a366 1

d370 1
a370 1
	fprintf_filtered (stream, " ");
d399 4
a402 4
	       (current_language->la_language == language_cplus))
	{
	  fprintf_filtered (stream, "void");
	}
d410 1
a410 1
	      if (args[i + 1] == NULL)
d414 1
a414 1
	      else if (args[i + 1]->code != TYPE_CODE_VOID)
d426 1
a426 1

d455 1
a455 1

d458 1
a458 1
	&& TYPE_ARRAY_UPPER_BOUND_TYPE (type) != BOUND_CANNOT_BE_DETERMINED)
d463 1
a463 1

d492 1
a492 2
	{
	  int i, len = TYPE_NFIELDS (type);
d494 14
a507 14
	  if ((len == 0) && (current_language->la_language == language_cplus))
	    {
	      fprintf_filtered (stream, "void");
	    }
	  else
	    for (i = 0; i < len; i++)
	      {
		if (i > 0)
		  {
		    fputs_filtered (", ", stream);
		    wrap_here ("    ");
		  }
		c_print_type (TYPE_FIELD_TYPE (type, i), "", stream, -1, 0);
	      }
d531 1
a531 1
         gcc -Wall will report types that may not have been considered.  */
d565 1
a565 5
  enum
    {
      s_none, s_public, s_private, s_protected
    }
  section_type;
d593 1
a593 1

d611 22
a632 26
      if (HAVE_CPLUS_STRUCT (type))
	{
	  switch (TYPE_DECLARED_TYPE (type))
	    {
	    case DECLARED_TYPE_CLASS:
	      fprintf_filtered (stream, "class ");
	      break;
	    case DECLARED_TYPE_UNION:
	      fprintf_filtered (stream, "union ");
	      break;
	    case DECLARED_TYPE_STRUCT:
	      fprintf_filtered (stream, "struct ");
	      break;
	    default:
	      /* If there is a CPLUS_STRUCT, assume class if not
	       * otherwise specified in the declared_type field.
	       */
	      fprintf_filtered (stream, "class ");
	      break;
	    }			/* switch */
	}
      else
	{
	  /* If not CPLUS_STRUCT, then assume it's a C struct */
	  fprintf_filtered (stream, "struct ");
	}
d648 1
a648 1
	  strncmp (TYPE_TAG_NAME (type), "{unnamed", 8))
d664 1
a664 1

d680 65
a744 65
	  /* For a class, if all members are private, there's no need
	     for a "private:" label; similarly, for a struct or union
	     masquerading as a class, if all members are public, there's
	     no need for a "public:" label. */

	  if ((TYPE_DECLARED_TYPE (type) == DECLARED_TYPE_CLASS) ||
	      (TYPE_DECLARED_TYPE (type) == DECLARED_TYPE_TEMPLATE))
	    {
	      QUIT;
	      len = TYPE_NFIELDS (type);
	      for (i = TYPE_N_BASECLASSES (type); i < len; i++)
		if (!TYPE_FIELD_PRIVATE (type, i))
		  {
		    need_access_label = 1;
		    break;
		  }
	      QUIT;
	      if (!need_access_label)
		{
		  len2 = TYPE_NFN_FIELDS (type);
		  for (j = 0; j < len2; j++)
		    {
		      len = TYPE_FN_FIELDLIST_LENGTH (type, j);
		      for (i = 0; i < len; i++)
			if (!TYPE_FN_FIELD_PRIVATE (TYPE_FN_FIELDLIST1 (type, j), i))
			  {
			    need_access_label = 1;
			    break;
			  }
		      if (need_access_label)
			break;
		    }
		}
	    }
	  else if ((TYPE_DECLARED_TYPE (type) == DECLARED_TYPE_STRUCT) ||
		   (TYPE_DECLARED_TYPE (type) == DECLARED_TYPE_UNION))
	    {
	      QUIT;
	      len = TYPE_NFIELDS (type);
	      for (i = TYPE_N_BASECLASSES (type); i < len; i++)
		if (TYPE_FIELD_PRIVATE (type, i) || TYPE_FIELD_PROTECTED (type, i))
		  {
		    need_access_label = 1;
		    break;
		  }
	      QUIT;
	      if (!need_access_label)
		{
		  len2 = TYPE_NFN_FIELDS (type);
		  for (j = 0; j < len2; j++)
		    {
		      QUIT;
		      len = TYPE_FN_FIELDLIST_LENGTH (type, j);
		      for (i = 0; i < len; i++)
			if (TYPE_FN_FIELD_PRIVATE (TYPE_FN_FIELDLIST1 (type, j), i) ||
			    TYPE_FN_FIELD_PROTECTED (TYPE_FN_FIELDLIST1 (type, j), i))
			  {
			    need_access_label = 1;
			    break;
			  }
		      if (need_access_label)
			break;
		    }
		}
	    }
d754 5
a758 5
	      /* HP ANSI C++ case */
	      if (TYPE_HAS_VTABLE (type) && (STREQN (TYPE_FIELD_NAME (type, i), "__vfp", 5)))
		continue;
	      /* Other compilers */
	      /* pai:: FIXME : check for has_vtable < 0 */
d764 1
a764 1
	         labels. */
d820 1
a820 1
	    fprintf_filtered (stream, "\n");
d829 1
a829 1
	      int is_constructor = name && STREQ (method_name, name);
d833 6
a838 6
		  int is_full_physname_constructor =
		  ((physname[0] == '_' && physname[1] == '_'
		    && strchr ("0123456789Qt", physname[2]))
		   || STREQN (physname, "__ct__", 6)
		   || DESTRUCTOR_PREFIX_P (physname)
		   || STREQN (physname, "__dt__", 6));
d876 1
a876 1
					TYPE_FN_FIELD_PHYSNAME (f, j));
d879 4
a882 4
		  else if (!is_constructor &&	/* constructors don't have declared types */
			   !is_full_physname_constructor &&	/*    " "  */
			   !strstr (method_name, "operator "))	/* Not a type conversion operator */
		    /* (note space -- other operators don't have it) */
d900 4
a903 4
		         if a function has more than 10 arguments, 
		         the demangling will fail.
		         Let's try to reconstruct the function signature from 
		         the symbol information */
d907 1
a907 1
					      TYPE_FN_FIELD_STATIC_P (f, j),
d917 1
a917 1

d931 1
a931 1
			  *(demangled_no_static + length) = '\0';
d947 4
a950 4
	  if (TYPE_LOCALTYPE_PTR (type) && show >= 0)
	    fprintfi_filtered (level, stream, " (Local at %s:%d)\n",
			       TYPE_LOCALTYPE_FILE (type),
			       TYPE_LOCALTYPE_LINE (type));
d954 2
a955 2
      if (TYPE_CODE (type) == TYPE_CODE_TEMPLATE)
	goto go_back;
d962 12
a973 12
	switch (TYPE_LENGTH (type))
	  {
	  case 1:
	    fputs_filtered ("char ", stream);
	    break;
	  case 2:
	    fputs_filtered ("short ", stream);
	    break;
	  default:
	    break;
	  }
      fprintf_filtered (stream, "enum ");
d980 1
a980 1
	  strncmp (TYPE_TAG_NAME (type), "{unnamed", 8))
d1002 1
a1002 2
	      if (i)
		fprintf_filtered (stream, ", ");
d1036 1
a1036 1
         template <class T1, class T2> class "
d1041 7
a1047 8
      for (i = 0; i < TYPE_NTEMPLATE_ARGS (type); i++)
	{
	  struct template_arg templ_arg;
	  templ_arg = TYPE_TEMPLATE_ARG (type, i);
	  fprintf_filtered (stream, "class %s", templ_arg.name);
	  if (i < TYPE_NTEMPLATE_ARGS (type) - 1)
	    fprintf_filtered (stream, ", ");
	}
d1051 10
a1060 13
      goto struct_union;
    go_back:
      if (TYPE_NINSTANTIATIONS (type) > 0)
	{
	  fprintf_filtered (stream, "\ntemplate instantiations:\n");
	  for (i = 0; i < TYPE_NINSTANTIATIONS (type); i++)
	    {
	      fprintf_filtered (stream, "  ");
	      c_type_print_base (TYPE_INSTANTIATION (type, i), stream, 0, level);
	      if (i < TYPE_NINSTANTIATIONS (type) - 1)
		fprintf_filtered (stream, "\n");
	    }
	}
d1062 1
a1062 1

d1065 3
a1067 3
         such as fundamental types.  For these, just print whatever
         the type name is, as recorded in the type itself.  If there
         is no type name, then complain. */
d1070 1
a1070 1
	  c_type_print_cv_qualifier (type, stream, 0, 1);
d1083 9
@


1.1.1.5
log
@import gdb-1999-12-13 snapshot
@
text
@a340 1
    case TYPE_CODE_TEMPLATE:
a343 3
    default:
      error ("type not handled in c_type_print_varspec_prefix()");
      break;
a532 1
    case TYPE_CODE_TEMPLATE:
a535 3
    default:
      error ("type not handled in c_type_print_varspec_suffix()");
      break;
d769 1
d927 1
a927 1
		      char *demangled_no_class = strrchr (demangled_name, ':');
d929 5
a933 5
                      if (demangled_no_class == NULL)
                        demangled_no_class = demangled_name;
                      else
                        {
                          ++demangled_no_class; /* skip over last ':' */
a957 2
	  fprintfi_filtered (level, stream, "}");

d962 2
@


1.1.1.6
log
@import gdb-2000-02-01 snapshot
@
text
@d2 1
a2 1
   Copyright 1986, 1988, 1989, 1991, 1993-1996, 1998-2000
d45 1
a45 3
static void cp_type_print_method_args (struct type ** args, char *prefix,
				       char *varstring, int staticp,
				       struct ui_file *stream);
d47 2
a48 1
static void c_type_print_args (struct type *, struct ui_file *);
d50 2
a51 1
static void cp_type_print_derivation_info (struct ui_file *, struct type *);
d53 2
a54 2
void c_type_print_varspec_prefix (struct type *, struct ui_file *, int,
				  int);
d56 2
a57 2
static void c_type_print_cv_qualifier (struct type *, struct ui_file *,
				       int, int);
d69 1
a69 1
     struct ui_file *stream;
d119 1
a119 1
     struct ui_file *stream;
d186 1
a186 1
     struct ui_file *stream;
d215 1
a215 1
     struct ui_file *stream;
d261 1
a261 1
     struct ui_file *stream;
d359 1
a359 1
     struct ui_file *stream;
d391 1
a391 1
     struct ui_file *stream;
d443 1
a443 1
     struct ui_file *stream;
d566 1
a566 1
     struct ui_file *stream;
@


1.1.1.7
log
@import gdb-2000-02-04 snapshot
@
text
@a435 129

/* Return true iff the j'th overloading of the i'th method of TYPE
   is a type conversion operator, like `operator int () { ... }'.
   When listing a class's methods, we don't print the return type of
   such operators.  */
static int
is_type_conversion_operator (struct type *type, int i, int j)
{
  /* I think the whole idea of recognizing type conversion operators
     by their name is pretty terrible.  But I don't think our present
     data structure gives us any other way to tell.  If you know of
     some other way, feel free to rewrite this function.  */
  char *name = TYPE_FN_FIELDLIST_NAME (type, i);

  if (strncmp (name, "operator", 8) != 0)
    return 0;

  name += 8;
  if (! strchr (" \t\f\n\r", *name))
    return 0;

  while (strchr (" \t\f\n\r", *name))
    name++;

  if (strncmp (name, "new", 3) == 0)
    name += 3;
  else if (strncmp (name, "delete", 6) == 0)
    name += 6;
  else
    return 0;

  /* Is that really the end of the name?  */
  if (('a' <= *name && *name <= 'z')
      || ('A' <= *name && *name <= 'Z')
      || ('0' <= *name && *name <= '9')
      || *name == '_')
    /* No, so the identifier following "operator" must be a type name,
       and this is a type conversion operator.  */
    return 1;

  /* That was indeed the end of the name, so it was `operator new' or
     `operator delete', neither of which are type conversion operators.  */
  return 0;
}


/* Given a C++ qualified identifier QID, strip off the qualifiers,
   yielding the unqualified name.  The return value is a pointer into
   the original string.

   It's a pity we don't have this information in some more structured
   form.  Even the author of this function feels that writing little
   parsers like this everywhere is stupid.  */
static char *
remove_qualifiers (char *qid)
{
  int quoted = 0;		/* zero if we're not in quotes;
				   '"' if we're in a double-quoted string;
				   '\'' if we're in a single-quoted string.  */
  int depth = 0;		/* number of unclosed parens we've seen */
  char *parenstack = (char *) alloca (strlen (qid));
  char *scan;
  char *last = 0;		/* The character after the rightmost
				   `::' token we've seen so far.  */

  for (scan = qid; *scan; scan++)
    {
      if (quoted)
	{
	  if (*scan == quoted)
	    quoted = 0;
	  else if (*scan == '\\' && *(scan + 1))
	    scan++;
	}
      else if (scan[0] == ':' && scan[1] == ':')
	{
	  /* If we're inside parenthesis (i.e., an argument list) or
	     angle brackets (i.e., a list of template arguments), then
	     we don't record the position of this :: token, since it's
	     not relevant to the top-level structure we're trying
	     to operate on.  */
	  if (depth == 0)
	    {
	      last = scan + 2;
	      scan++;
	    }
	}
      else if (*scan == '"' || *scan == '\'')
	quoted = *scan;
      else if (*scan == '(')
	parenstack[depth++] = ')';
      else if (*scan == '[')
	parenstack[depth++] = ']';
      /* We're going to treat <> as a pair of matching characters,
	 since we're more likely to see those in template id's than
	 real less-than characters.  What a crock.  */
      else if (*scan == '<')
	parenstack[depth++] = '>';
      else if (*scan == ')' || *scan == ']' || *scan == '>')
	{
	  if (depth > 0 && parenstack[depth - 1] == *scan)
	    depth--;
	  else
	    {
	      /* We're going to do a little error recovery here.  If we
		 don't find a match for *scan on the paren stack, but
		 there is something lower on the stack that does match, we
		 pop the stack to that point.  */
	      int i;

	      for (i = depth - 1; i >= 0; i--)
		if (parenstack[i] == *scan)
		  {
		    depth = i;
		    break;
		  }
	    }
	}
    }

  if (last)
    return last;
  else
    /* We didn't find any :: tokens at the top level, so declare the
       whole thing an unqualified identifier.  */
    return qid;
}


d899 2
a900 1
			   !is_type_conversion_operator (type, i, j))
d934 1
a934 2
		      char *demangled_no_class
			= remove_qualifiers (demangled_name);
d936 7
a942 1
		      /* get rid of the `static' appended by the demangler */
@


