head	1.97;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.96
	gdb_7_6-2013-04-26-release:1.96
	gdb_7_6-branch:1.96.0.2
	gdb_7_6-2013-03-12-branchpoint:1.96
	gdb_7_5_1-2012-11-29-release:1.91
	gdb_7_5-2012-08-17-release:1.91
	gdb_7_5-branch:1.91.0.2
	gdb_7_5-2012-07-18-branchpoint:1.91
	gdb_7_4_1-2012-04-26-release:1.84.2.1
	gdb_7_4-2012-01-24-release:1.84.2.1
	gdb_7_4-branch:1.84.0.2
	gdb_7_4-2011-12-13-branchpoint:1.84
	gdb_7_3_1-2011-09-04-release:1.81
	gdb_7_3-2011-07-26-release:1.81
	gdb_7_3-branch:1.81.0.2
	gdb_7_3-2011-04-01-branchpoint:1.81
	gdb_7_2-2010-09-02-release:1.66
	gdb_7_2-branch:1.66.0.2
	gdb_7_2-2010-07-07-branchpoint:1.66
	gdb_7_1-2010-03-18-release:1.61
	gdb_7_1-branch:1.61.0.2
	gdb_7_1-2010-02-18-branchpoint:1.61
	gdb_7_0_1-2009-12-22-release:1.54
	gdb_7_0-2009-10-06-release:1.54
	gdb_7_0-branch:1.54.0.4
	gdb_7_0-2009-09-16-branchpoint:1.54
	arc-sim-20090309:1.35
	msnyder-checkpoint-072509-branch:1.54.0.2
	msnyder-checkpoint-072509-branchpoint:1.54
	arc-insight_6_8-branch:1.35.0.6
	arc-insight_6_8-branchpoint:1.35
	insight_6_8-branch:1.35.0.4
	insight_6_8-branchpoint:1.35
	reverse-20081226-branch:1.44.0.4
	reverse-20081226-branchpoint:1.44
	multiprocess-20081120-branch:1.44.0.2
	multiprocess-20081120-branchpoint:1.44
	reverse-20080930-branch:1.43.0.2
	reverse-20080930-branchpoint:1.43
	reverse-20080717-branch:1.37.0.4
	reverse-20080717-branchpoint:1.37
	msnyder-reverse-20080609-branch:1.37.0.2
	msnyder-reverse-20080609-branchpoint:1.37
	drow-reverse-20070409-branch:1.30.0.2
	drow-reverse-20070409-branchpoint:1.30
	gdb_6_8-2008-03-27-release:1.35
	gdb_6_8-branch:1.35.0.2
	gdb_6_8-2008-02-26-branchpoint:1.35
	gdb_6_7_1-2007-10-29-release:1.31
	gdb_6_7-2007-10-10-release:1.31
	gdb_6_7-branch:1.31.0.2
	gdb_6_7-2007-09-07-branchpoint:1.31
	insight_6_6-20070208-release:1.28
	gdb_6_6-2006-12-18-release:1.28
	gdb_6_6-branch:1.28.0.18
	gdb_6_6-2006-11-15-branchpoint:1.28
	insight_6_5-20061003-release:1.28
	gdb-csl-symbian-6_4_50_20060226-12:1.28
	gdb-csl-sourcerygxx-3_4_4-25:1.25
	nickrob-async-20060828-mergepoint:1.28
	gdb-csl-symbian-6_4_50_20060226-11:1.28
	gdb-csl-sourcerygxx-4_1-17:1.28
	gdb-csl-20060226-branch-local-2:1.28
	gdb-csl-sourcerygxx-4_1-14:1.28
	gdb-csl-sourcerygxx-4_1-13:1.28
	gdb-csl-sourcerygxx-4_1-12:1.28
	gdb-csl-sourcerygxx-3_4_4-21:1.28
	gdb_6_5-20060621-release:1.28
	gdb-csl-sourcerygxx-4_1-9:1.28
	gdb-csl-sourcerygxx-4_1-8:1.28
	gdb-csl-sourcerygxx-4_1-7:1.28
	gdb-csl-arm-2006q1-6:1.28
	gdb-csl-sourcerygxx-4_1-6:1.28
	gdb-csl-symbian-6_4_50_20060226-10:1.28
	gdb-csl-symbian-6_4_50_20060226-9:1.28
	gdb-csl-symbian-6_4_50_20060226-8:1.28
	gdb-csl-coldfire-4_1-11:1.28
	gdb-csl-sourcerygxx-3_4_4-19:1.28
	gdb-csl-coldfire-4_1-10:1.28
	gdb_6_5-branch:1.28.0.16
	gdb_6_5-2006-05-14-branchpoint:1.28
	gdb-csl-sourcerygxx-4_1-5:1.28
	nickrob-async-20060513-branch:1.28.0.14
	nickrob-async-20060513-branchpoint:1.28
	gdb-csl-sourcerygxx-4_1-4:1.28
	msnyder-reverse-20060502-branch:1.28.0.12
	msnyder-reverse-20060502-branchpoint:1.28
	gdb-csl-morpho-4_1-4:1.28
	gdb-csl-sourcerygxx-3_4_4-17:1.28
	readline_5_1-import-branch:1.28.0.10
	readline_5_1-import-branchpoint:1.28
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.28
	gdb-csl-symbian-20060226-branch:1.28.0.8
	gdb-csl-symbian-20060226-branchpoint:1.28
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.28
	msnyder-reverse-20060331-branch:1.28.0.6
	msnyder-reverse-20060331-branchpoint:1.28
	gdb-csl-available-20060303-branch:1.28.0.4
	gdb-csl-available-20060303-branchpoint:1.28
	gdb-csl-20060226-branch:1.28.0.2
	gdb-csl-20060226-branchpoint:1.28
	gdb_6_4-20051202-release:1.25
	msnyder-fork-checkpoint-branch:1.25.0.8
	msnyder-fork-checkpoint-branchpoint:1.25
	gdb-csl-gxxpro-6_3-branch:1.25.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.25
	gdb_6_4-branch:1.25.0.4
	gdb_6_4-2005-11-01-branchpoint:1.25
	gdb-csl-arm-20051020-branch:1.25.0.2
	gdb-csl-arm-20051020-branchpoint:1.25
	msnyder-tracepoint-checkpoint-branch:1.23.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.23
	gdb-csl-arm-20050325-2005-q1b:1.22
	gdb-csl-arm-20050325-2005-q1a:1.22
	csl-arm-20050325-branch:1.22.0.2
	csl-arm-20050325-branchpoint:1.22
	gdb-post-i18n-errorwarning-20050211:1.21
	gdb-pre-i18n-errorwarning-20050211:1.21
	gdb_6_3-20041109-release:1.14
	gdb_6_3-branch:1.14.0.2
	gdb_6_3-20041019-branchpoint:1.14
	drow_intercu-merge-20040921:1.13
	drow_intercu-merge-20040915:1.13
	jimb-gdb_6_2-e500-branch:1.13.0.6
	jimb-gdb_6_2-e500-branchpoint:1.13
	gdb_6_2-20040730-release:1.13
	gdb_6_2-branch:1.13.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.13
	gdb_6_1_1-20040616-release:1.9
	gdb_6_1-2004-04-05-release:1.9
	drow_intercu-merge-20040402:1.9
	drow_intercu-merge-20040327:1.9
	ezannoni_pie-20040323-branch:1.9.0.26
	ezannoni_pie-20040323-branchpoint:1.9
	cagney_tramp-20040321-mergepoint:1.9
	cagney_tramp-20040309-branch:1.9.0.24
	cagney_tramp-20040309-branchpoint:1.9
	gdb_6_1-branch:1.9.0.22
	gdb_6_1-2004-03-01-gmt-branchpoint:1.9
	drow_intercu-20040221-branch:1.9.0.20
	drow_intercu-20040221-branchpoint:1.9
	cagney_bfdfile-20040213-branch:1.9.0.18
	cagney_bfdfile-20040213-branchpoint:1.9
	drow-cplus-merge-20040208:1.9
	carlton_dictionary-20040126-merge:1.9
	cagney_bigcore-20040122-branch:1.9.0.16
	cagney_bigcore-20040122-branchpoint:1.9
	drow-cplus-merge-20040113:1.9
	drow-cplus-merge-20031224:1.9
	drow-cplus-merge-20031220:1.9
	carlton_dictionary-20031215-merge:1.9
	drow-cplus-merge-20031214:1.9
	carlton-dictionary-20031111-merge:1.9
	gdb_6_0-2003-10-04-release:1.9
	kettenis_sparc-20030918-branch:1.9.0.14
	kettenis_sparc-20030918-branchpoint:1.9
	carlton_dictionary-20030917-merge:1.9
	ezannoni_pie-20030916-branchpoint:1.9
	ezannoni_pie-20030916-branch:1.9.0.12
	cagney_x86i386-20030821-branch:1.9.0.10
	cagney_x86i386-20030821-branchpoint:1.9
	carlton_dictionary-20030805-merge:1.9
	carlton_dictionary-20030627-merge:1.9
	gdb_6_0-branch:1.9.0.8
	gdb_6_0-2003-06-23-branchpoint:1.9
	jimb-ppc64-linux-20030613-branch:1.9.0.6
	jimb-ppc64-linux-20030613-branchpoint:1.9
	cagney_convert-20030606-branch:1.9.0.4
	cagney_convert-20030606-branchpoint:1.9
	cagney_writestrings-20030508-branch:1.7.0.4
	cagney_writestrings-20030508-branchpoint:1.7
	jimb-ppc64-linux-20030528-branch:1.9.0.2
	jimb-ppc64-linux-20030528-branchpoint:1.9
	carlton_dictionary-20030523-merge:1.8
	cagney_fileio-20030521-branch:1.8.0.2
	cagney_fileio-20030521-branchpoint:1.8
	kettenis_i386newframe-20030517-mergepoint:1.8
	jimb-ppc64-linux-20030509-branch:1.7.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.7
	kettenis_i386newframe-20030504-mergepoint:1.7
	carlton_dictionary-20030430-merge:1.7
	kettenis_i386newframe-20030419-branch:1.6.0.18
	kettenis_i386newframe-20030419-branchpoint:1.6
	carlton_dictionary-20030416-merge:1.6
	cagney_frameaddr-20030409-mergepoint:1.6
	kettenis_i386newframe-20030406-branch:1.6.0.16
	kettenis_i386newframe-20030406-branchpoint:1.6
	cagney_frameaddr-20030403-branchpoint:1.6
	cagney_frameaddr-20030403-branch:1.6.0.14
	cagney_framebase-20030330-mergepoint:1.6
	cagney_framebase-20030326-branch:1.6.0.12
	cagney_framebase-20030326-branchpoint:1.6
	cagney_lazyid-20030317-branch:1.6.0.10
	cagney_lazyid-20030317-branchpoint:1.6
	kettenis-i386newframe-20030316-mergepoint:1.6
	offbyone-20030313-branch:1.6.0.8
	offbyone-20030313-branchpoint:1.6
	kettenis-i386newframe-20030308-branch:1.6.0.6
	kettenis-i386newframe-20030308-branchpoint:1.6
	carlton_dictionary-20030305-merge:1.6
	cagney_offbyone-20030303-branch:1.6.0.4
	cagney_offbyone-20030303-branchpoint:1.6
	carlton_dictionary-20030207-merge:1.6
	interps-20030203-mergepoint:1.6
	interps-20030202-branch:1.6.0.2
	interps-20030202-branchpoint:1.6
	cagney-unwind-20030108-branch:1.5.0.6
	cagney-unwind-20030108-branchpoint:1.5
	carlton_dictionary-20021223-merge:1.5
	gdb_5_3-2002-12-12-release:1.4.6.1
	carlton_dictionary-20021115-merge:1.5
	kseitz_interps-20021105-merge:1.5
	kseitz_interps-20021103-merge:1.5
	drow-cplus-merge-20021020:1.5
	drow-cplus-merge-20021025:1.5
	carlton_dictionary-20021025-merge:1.5
	carlton_dictionary-20021011-merge:1.5
	drow-cplus-branch:1.5.0.4
	drow-cplus-branchpoint:1.5
	kseitz_interps-20020930-merge:1.5
	carlton_dictionary-20020927-merge:1.5
	carlton_dictionary-branch:1.5.0.2
	carlton_dictionary-20020920-branchpoint:1.5
	gdb_5_3-branch:1.4.0.6
	gdb_5_3-2002-09-04-branchpoint:1.4
	kseitz_interps-20020829-merge:1.4
	cagney_sysregs-20020825-branch:1.4.0.4
	cagney_sysregs-20020825-branchpoint:1.4
	readline_4_3-import-branch:1.4.0.2
	readline_4_3-import-branchpoint:1.4
	kseitz_interps-20020528-branch:1.1.0.4
	cagney_regbuf-20020515-branch:1.1.0.2;
locks; strict;
comment	@ * @;


1.97
date	2013.07.09.16.57.08;	author devans;	state Exp;
branches;
next	1.96;

1.96
date	2013.02.01.20.08.45;	author aristovski;	state Exp;
branches;
next	1.95;

1.95
date	2013.01.07.16.40.36;	author tromey;	state Exp;
branches;
next	1.94;

1.94
date	2013.01.01.06.32.37;	author brobecke;	state Exp;
branches;
next	1.93;

1.93
date	2012.11.29.16.28.10;	author guitton;	state Exp;
branches;
next	1.92;

1.92
date	2012.09.25.12.48.52;	author siddhesh;	state Exp;
branches;
next	1.91;

1.91
date	2012.04.18.06.46.46;	author jkratoch;	state Exp;
branches;
next	1.90;

1.90
date	2012.03.29.18.50.21;	author brobecke;	state Exp;
branches;
next	1.89;

1.89
date	2012.03.01.19.27.18;	author tromey;	state Exp;
branches;
next	1.88;

1.88
date	2012.03.01.19.26.12;	author tromey;	state Exp;
branches;
next	1.87;

1.87
date	2012.03.01.19.22.22;	author tromey;	state Exp;
branches;
next	1.86;

1.86
date	2012.02.29.19.33.02;	author brobecke;	state Exp;
branches;
next	1.85;

1.85
date	2012.01.04.08.16.55;	author brobecke;	state Exp;
branches;
next	1.84;

1.84
date	2011.10.09.19.43.40;	author jkratoch;	state Exp;
branches
	1.84.2.1;
next	1.83;

1.83
date	2011.07.01.18.27.25;	author brobecke;	state Exp;
branches;
next	1.82;

1.82
date	2011.07.01.18.26.22;	author brobecke;	state Exp;
branches;
next	1.81;

1.81
date	2011.03.07.08.57.09;	author brobecke;	state Exp;
branches;
next	1.80;

1.80
date	2011.02.14.11.23.33;	author palves;	state Exp;
branches;
next	1.79;

1.79
date	2011.02.07.17.49.32;	author palves;	state Exp;
branches;
next	1.78;

1.78
date	2011.01.25.17.58.59;	author palves;	state Exp;
branches;
next	1.77;

1.77
date	2011.01.24.21.28.12;	author palves;	state Exp;
branches;
next	1.76;

1.76
date	2011.01.24.18.54.15;	author palves;	state Exp;
branches;
next	1.75;

1.75
date	2011.01.18.16.38.59;	author brobecke;	state Exp;
branches;
next	1.74;

1.74
date	2011.01.14.19.32.56;	author brobecke;	state Exp;
branches;
next	1.73;

1.73
date	2011.01.13.23.01.22;	author brobecke;	state Exp;
branches;
next	1.72;

1.72
date	2011.01.10.06.07.10;	author brobecke;	state Exp;
branches;
next	1.71;

1.71
date	2011.01.07.19.36.14;	author msnyder;	state Exp;
branches;
next	1.70;

1.70
date	2011.01.01.15.32.56;	author brobecke;	state Exp;
branches;
next	1.69;

1.69
date	2010.12.29.08.02.58;	author brobecke;	state Exp;
branches;
next	1.68;

1.68
date	2010.12.29.08.01.31;	author brobecke;	state Exp;
branches;
next	1.67;

1.67
date	2010.11.03.23.20.33;	author brobecke;	state Exp;
branches;
next	1.66;

1.66
date	2010.06.11.15.36.03;	author tromey;	state Exp;
branches
	1.66.2.1;
next	1.65;

1.65
date	2010.06.03.06.50.49;	author muller;	state Exp;
branches;
next	1.64;

1.64
date	2010.05.18.19.23.37;	author msnyder;	state Exp;
branches;
next	1.63;

1.63
date	2010.05.07.00.28.32;	author msnyder;	state Exp;
branches;
next	1.62;

1.62
date	2010.04.20.22.26.56;	author brobecke;	state Exp;
branches;
next	1.61;

1.61
date	2010.01.14.08.03.35;	author pmuldoon;	state Exp;
branches;
next	1.60;

1.60
date	2010.01.12.07.45.51;	author brobecke;	state Exp;
branches;
next	1.59;

1.59
date	2010.01.12.05.48.56;	author brobecke;	state Exp;
branches;
next	1.58;

1.58
date	2010.01.09.04.34.35;	author brobecke;	state Exp;
branches;
next	1.57;

1.57
date	2010.01.08.11.58.23;	author brobecke;	state Exp;
branches;
next	1.56;

1.56
date	2010.01.01.07.31.29;	author brobecke;	state Exp;
branches;
next	1.55;

1.55
date	2009.11.19.22.42.48;	author brobecke;	state Exp;
branches;
next	1.54;

1.54
date	2009.07.02.17.25.52;	author uweigand;	state Exp;
branches;
next	1.53;

1.53
date	2009.07.02.17.21.05;	author uweigand;	state Exp;
branches;
next	1.52;

1.52
date	2009.07.02.12.57.14;	author uweigand;	state Exp;
branches;
next	1.51;

1.51
date	2009.07.02.12.44.34;	author uweigand;	state Exp;
branches;
next	1.50;

1.50
date	2009.06.29.17.30.12;	author uweigand;	state Exp;
branches;
next	1.49;

1.49
date	2009.05.28.00.53.51;	author tromey;	state Exp;
branches;
next	1.48;

1.48
date	2009.05.18.13.51.52;	author uweigand;	state Exp;
branches;
next	1.47;

1.47
date	2009.03.20.23.04.29;	author tromey;	state Exp;
branches;
next	1.46;

1.46
date	2009.01.03.05.57.50;	author brobecke;	state Exp;
branches;
next	1.45;

1.45
date	2008.12.28.14.14.19;	author jkratoch;	state Exp;
branches;
next	1.44;

1.44
date	2008.10.28.17.19.56;	author tromey;	state Exp;
branches;
next	1.43;

1.43
date	2008.09.11.14.22.32;	author uweigand;	state Exp;
branches;
next	1.42;

1.42
date	2008.09.11.14.21.21;	author uweigand;	state Exp;
branches;
next	1.41;

1.41
date	2008.09.11.14.19.44;	author uweigand;	state Exp;
branches;
next	1.40;

1.40
date	2008.09.11.14.17.23;	author uweigand;	state Exp;
branches;
next	1.39;

1.39
date	2008.08.24.16.39.56;	author tromey;	state Exp;
branches;
next	1.38;

1.38
date	2008.08.19.10.10.39;	author hilfingr;	state Exp;
branches;
next	1.37;

1.37
date	2008.05.23.18.13.35;	author brobecke;	state Exp;
branches;
next	1.36;

1.36
date	2008.05.06.21.34.59;	author brobecke;	state Exp;
branches;
next	1.35;

1.35
date	2008.01.11.13.34.14;	author deuling;	state Exp;
branches;
next	1.34;

1.34
date	2008.01.03.12.30.38;	author brobecke;	state Exp;
branches;
next	1.33;

1.33
date	2008.01.01.22.53.09;	author drow;	state Exp;
branches;
next	1.32;

1.32
date	2008.01.01.11.39.07;	author brobecke;	state Exp;
branches;
next	1.31;

1.31
date	2007.08.23.18.08.25;	author brobecke;	state Exp;
branches;
next	1.30;

1.30
date	2007.01.09.17.58.49;	author drow;	state Exp;
branches;
next	1.29;

1.29
date	2007.01.03.18.05.43;	author drow;	state Exp;
branches;
next	1.28;

1.28
date	2006.01.18.21.24.19;	author kettenis;	state Exp;
branches;
next	1.27;

1.27
date	2006.01.02.09.39.21;	author hilfingr;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.17.22.33.59;	author eliz;	state Exp;
branches;
next	1.25;

1.25
date	2005.10.10.01.05.32;	author brobecke;	state Exp;
branches;
next	1.24;

1.24
date	2005.10.03.21.21.20;	author brobecke;	state Exp;
branches;
next	1.23;

1.23
date	2005.05.09.21.20.30;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2005.02.14.14.37.37;	author cagney;	state Exp;
branches;
next	1.21;

1.21
date	2005.02.07.00.09.52;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2005.01.29.01.59.30;	author cagney;	state Exp;
branches;
next	1.19;

1.19
date	2005.01.29.00.11.11;	author cagney;	state Exp;
branches;
next	1.18;

1.18
date	2005.01.28.19.19.10;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2005.01.12.18.31.30;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2005.01.05.15.43.41;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2004.11.12.21.45.05;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2004.10.08.09.40.12;	author hilfingr;	state Exp;
branches;
next	1.13;

1.13
date	2004.07.09.19.29.56;	author hilfingr;	state Exp;
branches;
next	1.12;

1.12
date	2004.07.01.10.30.57;	author hilfingr;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.01.10.11.11;	author hilfingr;	state Exp;
branches;
next	1.10;

1.10
date	2004.06.02.09.55.36;	author hilfingr;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.24.03.21.42;	author cagney;	state Exp;
branches
	1.9.20.1;
next	1.8;

1.8
date	2003.05.15.22.18.42;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.21.16.48.37;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2003.01.18.15.55.51;	author cagney;	state Exp;
branches
	1.6.18.1;
next	1.5;

1.5
date	2002.09.08.17.43.49;	author aidan;	state Exp;
branches
	1.5.2.1
	1.5.4.1;
next	1.4;

1.4
date	2002.08.18.18.07.33;	author aidan;	state Exp;
branches
	1.4.6.1;
next	1.3;

1.3
date	2002.08.11.18.14.57;	author aidan;	state Exp;
branches;
next	1.2;

1.2
date	2002.07.25.01.14.26;	author aidan;	state Exp;
branches;
next	1.1;

1.1
date	2002.06.04.15.28.49;	author aidan;	state Exp;
branches
	1.1.2.1
	1.1.4.1;
next	;

1.84.2.1
date	2012.01.06.04.43.03;	author brobecke;	state Exp;
branches;
next	;

1.66.2.1
date	2011.01.14.20.18.10;	author brobecke;	state Exp;
branches;
next	1.66.2.2;

1.66.2.2
date	2011.01.14.20.18.21;	author brobecke;	state Exp;
branches;
next	1.66.2.3;

1.66.2.3
date	2011.01.18.17.03.57;	author brobecke;	state Exp;
branches;
next	;

1.9.20.1
date	2004.09.16.17.00.52;	author drow;	state Exp;
branches;
next	;

1.6.18.1
date	2003.05.04.11.37.39;	author kettenis;	state Exp;
branches;
next	1.6.18.2;

1.6.18.2
date	2003.05.18.09.43.57;	author kettenis;	state Exp;
branches;
next	;

1.5.2.1
date	2003.02.07.19.17.43;	author carlton;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2003.05.01.00.46.45;	author carlton;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2003.05.23.18.40.34;	author carlton;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2003.06.27.21.49.44;	author carlton;	state Exp;
branches;
next	;

1.5.4.1
date	2003.12.14.20.27.04;	author drow;	state Exp;
branches;
next	;

1.4.6.1
date	2002.09.18.22.54.11;	author cagney;	state Exp;
branches;
next	;

1.1.2.1
date	2002.06.15.16.42.50;	author cagney;	state Exp;
branches;
next	;

1.1.4.1
date	2002.06.20.01.32.10;	author kseitz;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2002.08.09.18.34.23;	author kseitz;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2002.08.30.22.52.42;	author kseitz;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2002.10.01.00.46.02;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.97
log
@	* defs.h (enum val_prettyformat): Renamed from val_prettyprint.
	Enum values rename as well.  All uses updated.
	* valprint.h (value_print_options): Rename member pretty to
	pretty format.  Rename member prettyprint_arrays to
	prettyformat_arrays.  Rename member prettyprint_structs to
	prettyformat_structs.  All uses updated.
	(get_no_prettyformat_print_options): Renamed from
	get_raw_print_options.
	* valprint.c (get_no_prettyformat_print_options): Renamed from
	get_raw_print_options.  All callers updated.
	(show_prettyformat_structs): Renamed from show_prettyprint_structs.
	All callers updated.
	(show_prettyformat_arrays): Renamed from show_prettyprint_arrays.
	All callers updated.
	(_initialize_valprint): Improve help text for "set print pretty" and
	"set print arrays".

	testsuite/
	* gdb.base/default.exp: Update expected output of "show print array"
	and "show print pretty".
@
text
@/* Support for printing Ada values for GDB, the GNU debugger.

   Copyright (C) 1986-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include <ctype.h>
#include "gdb_string.h"
#include "symtab.h"
#include "gdbtypes.h"
#include "expression.h"
#include "value.h"
#include "demangle.h"
#include "valprint.h"
#include "language.h"
#include "annotate.h"
#include "ada-lang.h"
#include "c-lang.h"
#include "infcall.h"
#include "exceptions.h"
#include "objfiles.h"

static void print_record (struct type *, const gdb_byte *, int,
			  struct ui_file *,
			  int,
			  const struct value *,
			  const struct value_print_options *);

static int print_field_values (struct type *, const gdb_byte *,
			       int,
			       struct ui_file *, int,
			       const struct value *,
			       const struct value_print_options *,
			       int, struct type *, int);

static void adjust_type_signedness (struct type *);

static void ada_val_print_1 (struct type *, const gdb_byte *, int, CORE_ADDR,
			     struct ui_file *, int,
			     const struct value *,
			     const struct value_print_options *);


/* Make TYPE unsigned if its range of values includes no negatives.  */
static void
adjust_type_signedness (struct type *type)
{
  if (type != NULL && TYPE_CODE (type) == TYPE_CODE_RANGE
      && TYPE_LOW_BOUND (type) >= 0)
    TYPE_UNSIGNED (type) = 1;
}

/* Assuming TYPE is a simple array type, prints its lower bound on STREAM,
   if non-standard (i.e., other than 1 for numbers, other than lower bound
   of index type for enumerated type).  Returns 1 if something printed,
   otherwise 0.  */

static int
print_optional_low_bound (struct ui_file *stream, struct type *type,
			  const struct value_print_options *options)
{
  struct type *index_type;
  LONGEST low_bound;
  LONGEST high_bound;

  if (options->print_array_indexes)
    return 0;

  if (!get_array_bounds (type, &low_bound, &high_bound))
    return 0;

  /* If this is an empty array, then don't print the lower bound.
     That would be confusing, because we would print the lower bound,
     followed by... nothing!  */
  if (low_bound > high_bound)
    return 0;

  index_type = TYPE_INDEX_TYPE (type);

  if (TYPE_CODE (index_type) == TYPE_CODE_RANGE)
    {
      /* We need to know what the base type is, in order to do the
         appropriate check below.  Otherwise, if this is a subrange
         of an enumerated type, where the underlying value of the
         first element is typically 0, we might test the low bound
         against the wrong value.  */
      index_type = TYPE_TARGET_TYPE (index_type);
    }

  switch (TYPE_CODE (index_type))
    {
    case TYPE_CODE_BOOL:
      if (low_bound == 0)
	return 0;
      break;
    case TYPE_CODE_ENUM:
      if (low_bound == TYPE_FIELD_ENUMVAL (index_type, 0))
	return 0;
      break;
    case TYPE_CODE_UNDEF:
      index_type = NULL;
      /* FALL THROUGH */
    default:
      if (low_bound == 1)
	return 0;
      break;
    }

  ada_print_scalar (index_type, low_bound, stream);
  fprintf_filtered (stream, " => ");
  return 1;
}

/*  Version of val_print_array_elements for GNAT-style packed arrays.
    Prints elements of packed array of type TYPE at bit offset
    BITOFFSET from VALADDR on STREAM.  Formats according to OPTIONS and
    separates with commas.  RECURSE is the recursion (nesting) level.
    TYPE must have been decoded (as by ada_coerce_to_simple_array).  */

static void
val_print_packed_array_elements (struct type *type, const gdb_byte *valaddr,
				 int offset,
				 int bitoffset, struct ui_file *stream,
				 int recurse,
				 const struct value *val,
				 const struct value_print_options *options)
{
  unsigned int i;
  unsigned int things_printed = 0;
  unsigned len;
  struct type *elttype, *index_type;
  unsigned eltlen;
  unsigned long bitsize = TYPE_FIELD_BITSIZE (type, 0);
  struct value *mark = value_mark ();
  LONGEST low = 0;

  elttype = TYPE_TARGET_TYPE (type);
  eltlen = TYPE_LENGTH (check_typedef (elttype));
  index_type = TYPE_INDEX_TYPE (type);

  {
    LONGEST high;

    if (get_discrete_bounds (index_type, &low, &high) < 0)
      len = 1;
    else
      len = high - low + 1;
  }

  i = 0;
  annotate_array_section_begin (i, elttype);

  while (i < len && things_printed < options->print_max)
    {
      struct value *v0, *v1;
      int i0;

      if (i != 0)
	{
	  if (options->prettyformat_arrays)
	    {
	      fprintf_filtered (stream, ",\n");
	      print_spaces_filtered (2 + 2 * recurse, stream);
	    }
	  else
	    {
	      fprintf_filtered (stream, ", ");
	    }
	}
      wrap_here (n_spaces (2 + 2 * recurse));
      maybe_print_array_index (index_type, i + low, stream, options);

      i0 = i;
      v0 = ada_value_primitive_packed_val (NULL, valaddr + offset,
					   (i0 * bitsize) / HOST_CHAR_BIT,
					   (i0 * bitsize) % HOST_CHAR_BIT,
					   bitsize, elttype);
      while (1)
	{
	  i += 1;
	  if (i >= len)
	    break;
	  v1 = ada_value_primitive_packed_val (NULL, valaddr + offset,
					       (i * bitsize) / HOST_CHAR_BIT,
					       (i * bitsize) % HOST_CHAR_BIT,
					       bitsize, elttype);
	  if (!value_available_contents_eq (v0, value_embedded_offset (v0),
					    v1, value_embedded_offset (v1),
					    eltlen))
	    break;
	}

      if (i - i0 > options->repeat_count_threshold)
	{
	  struct value_print_options opts = *options;

	  opts.deref_ref = 0;
	  val_print (elttype, value_contents_for_printing (v0),
		     value_embedded_offset (v0), 0, stream,
		     recurse + 1, v0, &opts, current_language);
	  annotate_elt_rep (i - i0);
	  fprintf_filtered (stream, _(" <repeats %u times>"), i - i0);
	  annotate_elt_rep_end ();

	}
      else
	{
	  int j;
	  struct value_print_options opts = *options;

	  opts.deref_ref = 0;
	  for (j = i0; j < i; j += 1)
	    {
	      if (j > i0)
		{
		  if (options->prettyformat_arrays)
		    {
		      fprintf_filtered (stream, ",\n");
		      print_spaces_filtered (2 + 2 * recurse, stream);
		    }
		  else
		    {
		      fprintf_filtered (stream, ", ");
		    }
		  wrap_here (n_spaces (2 + 2 * recurse));
		  maybe_print_array_index (index_type, j + low,
					   stream, options);
		}
	      val_print (elttype, value_contents_for_printing (v0),
			 value_embedded_offset (v0), 0, stream,
			 recurse + 1, v0, &opts, current_language);
	      annotate_elt ();
	    }
	}
      things_printed += i - i0;
    }
  annotate_array_section_end ();
  if (i < len)
    {
      fprintf_filtered (stream, "...");
    }

  value_free_to_mark (mark);
}

static struct type *
printable_val_type (struct type *type, const gdb_byte *valaddr)
{
  return ada_to_fixed_type (ada_aligned_type (type), valaddr, 0, NULL, 1);
}

/* Print the character C on STREAM as part of the contents of a literal
   string whose delimiter is QUOTER.  TYPE_LEN is the length in bytes
   of the character.  */

void
ada_emit_char (int c, struct type *type, struct ui_file *stream,
	       int quoter, int type_len)
{
  /* If this character fits in the normal ASCII range, and is
     a printable character, then print the character as if it was
     an ASCII character, even if this is a wide character.
     The UCHAR_MAX check is necessary because the isascii function
     requires that its argument have a value of an unsigned char,
     or EOF (EOF is obviously not printable).  */
  if (c <= UCHAR_MAX && isascii (c) && isprint (c))
    {
      if (c == quoter && c == '"')
	fprintf_filtered (stream, "\"\"");
      else
	fprintf_filtered (stream, "%c", c);
    }
  else
    fprintf_filtered (stream, "[\"%0*x\"]", type_len * 2, c);
}

/* Character #I of STRING, given that TYPE_LEN is the size in bytes
   of a character.  */

static int
char_at (const gdb_byte *string, int i, int type_len,
	 enum bfd_endian byte_order)
{
  if (type_len == 1)
    return string[i];
  else
    return (int) extract_unsigned_integer (string + type_len * i,
                                           type_len, byte_order);
}

/* Wrapper around memcpy to make it legal argument to ui_file_put.  */
static void
ui_memcpy (void *dest, const char *buffer, long len)
{
  memcpy (dest, buffer, (size_t) len);
  ((char *) dest)[len] = '\0';
}

/* Print a floating-point value of type TYPE, pointed to in GDB by
   VALADDR, on STREAM.  Use Ada formatting conventions: there must be
   a decimal point, and at least one digit before and after the
   point.  We use GNAT format for NaNs and infinities.  */
static void
ada_print_floating (const gdb_byte *valaddr, struct type *type,
		    struct ui_file *stream)
{
  char buffer[64];
  char *s, *result;
  struct ui_file *tmp_stream = mem_fileopen ();
  struct cleanup *cleanups = make_cleanup_ui_file_delete (tmp_stream);

  print_floating (valaddr, type, tmp_stream);
  ui_file_put (tmp_stream, ui_memcpy, buffer);
  do_cleanups (cleanups);

  result = buffer;

  /* Modify for Ada rules.  */

  s = strstr (result, "inf");
  if (s == NULL)
    s = strstr (result, "Inf");
  if (s == NULL)
    s = strstr (result, "INF");
  if (s != NULL)
    strcpy (s, "Inf");

  if (s == NULL)
    {
      s = strstr (result, "nan");
      if (s == NULL)
	s = strstr (result, "NaN");
      if (s == NULL)
	s = strstr (result, "Nan");
      if (s != NULL)
	{
	  s[0] = s[2] = 'N';
	  if (result[0] == '-')
	    result += 1;
	}
    }

  if (s == NULL && strchr (result, '.') == NULL)
    {
      s = strchr (result, 'e');
      if (s == NULL)
	fprintf_filtered (stream, "%s.0", result);
      else
	fprintf_filtered (stream, "%.*s.0%s", (int) (s-result), result, s);
      return;
    }
  fprintf_filtered (stream, "%s", result);
}

void
ada_printchar (int c, struct type *type, struct ui_file *stream)
{
  fputs_filtered ("'", stream);
  ada_emit_char (c, type, stream, '\'', TYPE_LENGTH (type));
  fputs_filtered ("'", stream);
}

/* [From print_type_scalar in typeprint.c].   Print VAL on STREAM in a
   form appropriate for TYPE, if non-NULL.  If TYPE is NULL, print VAL
   like a default signed integer.  */

void
ada_print_scalar (struct type *type, LONGEST val, struct ui_file *stream)
{
  unsigned int i;
  unsigned len;

  if (!type)
    {
      print_longest (stream, 'd', 0, val);
      return;
    }

  type = ada_check_typedef (type);

  switch (TYPE_CODE (type))
    {

    case TYPE_CODE_ENUM:
      len = TYPE_NFIELDS (type);
      for (i = 0; i < len; i++)
	{
	  if (TYPE_FIELD_ENUMVAL (type, i) == val)
	    {
	      break;
	    }
	}
      if (i < len)
	{
	  fputs_filtered (ada_enum_name (TYPE_FIELD_NAME (type, i)), stream);
	}
      else
	{
	  print_longest (stream, 'd', 0, val);
	}
      break;

    case TYPE_CODE_INT:
      print_longest (stream, TYPE_UNSIGNED (type) ? 'u' : 'd', 0, val);
      break;

    case TYPE_CODE_CHAR:
      LA_PRINT_CHAR (val, type, stream);
      break;

    case TYPE_CODE_BOOL:
      fprintf_filtered (stream, val ? "true" : "false");
      break;

    case TYPE_CODE_RANGE:
      ada_print_scalar (TYPE_TARGET_TYPE (type), val, stream);
      return;

    case TYPE_CODE_UNDEF:
    case TYPE_CODE_PTR:
    case TYPE_CODE_ARRAY:
    case TYPE_CODE_STRUCT:
    case TYPE_CODE_UNION:
    case TYPE_CODE_FUNC:
    case TYPE_CODE_FLT:
    case TYPE_CODE_VOID:
    case TYPE_CODE_SET:
    case TYPE_CODE_STRING:
    case TYPE_CODE_ERROR:
    case TYPE_CODE_MEMBERPTR:
    case TYPE_CODE_METHODPTR:
    case TYPE_CODE_METHOD:
    case TYPE_CODE_REF:
      warning (_("internal error: unhandled type in ada_print_scalar"));
      break;

    default:
      error (_("Invalid type code in symbol table."));
    }
  gdb_flush (stream);
}

/* Print the character string STRING, printing at most LENGTH characters.
   Printing stops early if the number hits print_max; repeat counts
   are printed as appropriate.  Print ellipses at the end if we
   had to stop before printing LENGTH characters, or if FORCE_ELLIPSES.
   TYPE_LEN is the length (1 or 2) of the character type.  */

static void
printstr (struct ui_file *stream, struct type *elttype, const gdb_byte *string,
	  unsigned int length, int force_ellipses, int type_len,
	  const struct value_print_options *options)
{
  enum bfd_endian byte_order = gdbarch_byte_order (get_type_arch (elttype));
  unsigned int i;
  unsigned int things_printed = 0;
  int in_quotes = 0;
  int need_comma = 0;

  if (length == 0)
    {
      fputs_filtered ("\"\"", stream);
      return;
    }

  for (i = 0; i < length && things_printed < options->print_max; i += 1)
    {
      /* Position of the character we are examining
         to see whether it is repeated.  */
      unsigned int rep1;
      /* Number of repetitions we have detected so far.  */
      unsigned int reps;

      QUIT;

      if (need_comma)
	{
	  fputs_filtered (", ", stream);
	  need_comma = 0;
	}

      rep1 = i + 1;
      reps = 1;
      while (rep1 < length
	     && char_at (string, rep1, type_len, byte_order)
		== char_at (string, i, type_len, byte_order))
	{
	  rep1 += 1;
	  reps += 1;
	}

      if (reps > options->repeat_count_threshold)
	{
	  if (in_quotes)
	    {
	      fputs_filtered ("\", ", stream);
	      in_quotes = 0;
	    }
	  fputs_filtered ("'", stream);
	  ada_emit_char (char_at (string, i, type_len, byte_order),
			 elttype, stream, '\'', type_len);
	  fputs_filtered ("'", stream);
	  fprintf_filtered (stream, _(" <repeats %u times>"), reps);
	  i = rep1 - 1;
	  things_printed += options->repeat_count_threshold;
	  need_comma = 1;
	}
      else
	{
	  if (!in_quotes)
	    {
	      fputs_filtered ("\"", stream);
	      in_quotes = 1;
	    }
	  ada_emit_char (char_at (string, i, type_len, byte_order),
			 elttype, stream, '"', type_len);
	  things_printed += 1;
	}
    }

  /* Terminate the quotes if necessary.  */
  if (in_quotes)
    fputs_filtered ("\"", stream);

  if (force_ellipses || i < length)
    fputs_filtered ("...", stream);
}

void
ada_printstr (struct ui_file *stream, struct type *type,
	      const gdb_byte *string, unsigned int length,
	      const char *encoding, int force_ellipses,
	      const struct value_print_options *options)
{
  printstr (stream, type, string, length, force_ellipses, TYPE_LENGTH (type),
	    options);
}


/* See val_print for a description of the various parameters of this
   function; they are identical.  */

void
ada_val_print (struct type *type, const gdb_byte *valaddr,
	       int embedded_offset, CORE_ADDR address,
	       struct ui_file *stream, int recurse,
	       const struct value *val,
	       const struct value_print_options *options)
{
  volatile struct gdb_exception except;

  /* XXX: this catches QUIT/ctrl-c as well.  Isn't that busted?  */
  TRY_CATCH (except, RETURN_MASK_ALL)
    {
      ada_val_print_1 (type, valaddr, embedded_offset, address,
		       stream, recurse, val, options);
    }
}

/* Assuming TYPE is a simple array, print the value of this array located
   at VALADDR + OFFSET.  See ada_val_print for a description of the various
   parameters of this function; they are identical.  */

static void
ada_val_print_array (struct type *type, const gdb_byte *valaddr,
		     int offset, CORE_ADDR address,
		     struct ui_file *stream, int recurse,
		     const struct value *val,
		     const struct value_print_options *options)
{
  /* For an array of chars, print with string syntax.  */
  if (ada_is_string_type (type)
      && (options->format == 0 || options->format == 's'))
    {
      enum bfd_endian byte_order = gdbarch_byte_order (get_type_arch (type));
      struct type *elttype = TYPE_TARGET_TYPE (type);
      unsigned int eltlen;
      unsigned int len;

      /* We know that ELTTYPE cannot possibly be null, because we found
	 that TYPE is a string-like type.  Similarly, the size of ELTTYPE
	 should also be non-null, since it's a character-like type.  */
      gdb_assert (elttype != NULL);
      gdb_assert (TYPE_LENGTH (elttype) != 0);

      eltlen = TYPE_LENGTH (elttype);
      len = TYPE_LENGTH (type) / eltlen;

      if (options->prettyformat_arrays)
        print_spaces_filtered (2 + 2 * recurse, stream);

      /* If requested, look for the first null char and only print
         elements up to it.  */
      if (options->stop_print_at_null)
        {
          int temp_len;

          /* Look for a NULL char.  */
          for (temp_len = 0;
               (temp_len < len
                && temp_len < options->print_max
                && char_at (valaddr + offset,
			    temp_len, eltlen, byte_order) != 0);
               temp_len += 1);
          len = temp_len;
        }

      printstr (stream, elttype, valaddr + offset, len, 0, eltlen, options);
    }
  else
    {
      fprintf_filtered (stream, "(");
      print_optional_low_bound (stream, type, options);
      if (TYPE_FIELD_BITSIZE (type, 0) > 0)
        val_print_packed_array_elements (type, valaddr, offset,
					 0, stream, recurse, val, options);
      else
        val_print_array_elements (type, valaddr, offset, address,
				  stream, recurse, val, options, 0);
      fprintf_filtered (stream, ")");
    }
}

/* See the comment on ada_val_print.  This function differs in that it
   does not catch evaluation errors (leaving that to ada_val_print).  */

static void
ada_val_print_1 (struct type *type, const gdb_byte *valaddr,
		 int offset, CORE_ADDR address,
		 struct ui_file *stream, int recurse,
		 const struct value *original_value,
		 const struct value_print_options *options)
{
  int i;
  struct type *elttype;
  int offset_aligned;

  type = ada_check_typedef (type);

  if (ada_is_array_descriptor_type (type)
      || (ada_is_constrained_packed_array_type (type)
	  && TYPE_CODE (type) != TYPE_CODE_PTR))
    {
      struct value *mark = value_mark ();
      struct value *val;

      val = value_from_contents_and_address (type, valaddr + offset, address);
      /* If this is a reference, coerce it now.  This helps taking care
	 of the case where ADDRESS is meaningless because original_value
	 was not an lval.  */
      val = coerce_ref (val);
      if (TYPE_CODE (type) == TYPE_CODE_TYPEDEF)  /* array access type.  */
	val = ada_coerce_to_simple_array_ptr (val);
      else
	val = ada_coerce_to_simple_array (val);
      if (val == NULL)
	{
	  gdb_assert (TYPE_CODE (type) == TYPE_CODE_TYPEDEF);
	  fprintf_filtered (stream, "0x0");
	}
      else
	ada_val_print_1 (value_type (val),
			 value_contents_for_printing (val),
			 value_embedded_offset (val),
			 value_address (val), stream, recurse,
			 val, options);
      value_free_to_mark (mark);
      return;
    }

  offset_aligned = offset + ada_aligned_value_addr (type, valaddr) - valaddr;
  type = printable_val_type (type, valaddr + offset_aligned);

  switch (TYPE_CODE (type))
    {
    default:
      c_val_print (type, valaddr, offset, address, stream,
		   recurse, original_value, options);
      break;

    case TYPE_CODE_PTR:
      {
	c_val_print (type, valaddr, offset, address,
		     stream, recurse, original_value, options);

	if (ada_is_tag_type (type))
	  {
	    struct value *val =
	      value_from_contents_and_address (type,
					       valaddr + offset_aligned,
					       address + offset_aligned);
	    const char *name = ada_tag_name (val);

	    if (name != NULL) 
	      fprintf_filtered (stream, " (%s)", name);
	  }
	return;
      }

    case TYPE_CODE_INT:
    case TYPE_CODE_RANGE:
      if (ada_is_fixed_point_type (type))
	{
	  LONGEST v = unpack_long (type, valaddr + offset_aligned);

	  fprintf_filtered (stream, TYPE_LENGTH (type) < 4 ? "%.11g" : "%.17g",
			    (double) ada_fixed_to_float (type, v));
	  return;
	}
      else if (TYPE_CODE (type) == TYPE_CODE_RANGE)
	{
	  struct type *target_type = TYPE_TARGET_TYPE (type);

	  if (TYPE_LENGTH (type) != TYPE_LENGTH (target_type))
	    {
	      /* Obscure case of range type that has different length from
	         its base type.  Perform a conversion, or we will get a
	         nonsense value.  Actually, we could use the same
	         code regardless of lengths; I'm just avoiding a cast.  */
	      struct value *v1
		= value_from_contents_and_address (type, valaddr + offset, 0);
	      struct value *v = value_cast (target_type, v1);

	      ada_val_print_1 (target_type,
			       value_contents_for_printing (v),
			       value_embedded_offset (v), 0,
			       stream, recurse + 1, v, options);
	    }
	  else
	    ada_val_print_1 (TYPE_TARGET_TYPE (type),
			     valaddr, offset,
			     address, stream, recurse,
			     original_value, options);
	  return;
	}
      else
	{
	  int format = (options->format ? options->format
			: options->output_format);

	  if (format)
	    {
	      struct value_print_options opts = *options;

	      opts.format = format;
	      val_print_scalar_formatted (type, valaddr, offset_aligned,
					  original_value, &opts, 0, stream);
	    }
          else if (ada_is_system_address_type (type))
            {
              /* FIXME: We want to print System.Address variables using
                 the same format as for any access type.  But for some
                 reason GNAT encodes the System.Address type as an int,
                 so we have to work-around this deficiency by handling
                 System.Address values as a special case.  */

	      struct gdbarch *gdbarch = get_type_arch (type);
	      struct type *ptr_type = builtin_type (gdbarch)->builtin_data_ptr;
	      CORE_ADDR addr = extract_typed_address (valaddr + offset_aligned,
						      ptr_type);

              fprintf_filtered (stream, "(");
              type_print (type, "", stream, -1);
              fprintf_filtered (stream, ") ");
	      fputs_filtered (paddress (gdbarch, addr), stream);
            }
	  else
	    {
	      val_print_type_code_int (type, valaddr + offset_aligned, stream);
	      if (ada_is_character_type (type))
		{
		  LONGEST c;

		  fputs_filtered (" ", stream);
		  c = unpack_long (type, valaddr + offset_aligned);
		  ada_printchar (c, type, stream);
		}
	    }
	  return;
	}

    case TYPE_CODE_ENUM:
      {
	unsigned int len;
	LONGEST val;

	if (options->format)
	  {
	    val_print_scalar_formatted (type, valaddr, offset_aligned,
					original_value, options, 0, stream);
	    break;
	  }
	len = TYPE_NFIELDS (type);
	val = unpack_long (type, valaddr + offset_aligned);
	for (i = 0; i < len; i++)
	  {
	    QUIT;
	    if (val == TYPE_FIELD_ENUMVAL (type, i))
	      {
		break;
	      }
	  }
	if (i < len)
	  {
	    const char *name = ada_enum_name (TYPE_FIELD_NAME (type, i));

	    if (name[0] == '\'')
	      fprintf_filtered (stream, "%ld %s", (long) val, name);
	    else
	      fputs_filtered (name, stream);
	  }
	else
	  {
	    print_longest (stream, 'd', 0, val);
	  }
	break;
      }

    case TYPE_CODE_FLT:
      if (options->format)
	{
	  c_val_print (type, valaddr, offset, address, stream,
		       recurse, original_value, options);
	  return;
	}
      else
	ada_print_floating (valaddr + offset, type, stream);
      break;

    case TYPE_CODE_UNION:
    case TYPE_CODE_STRUCT:
      if (ada_is_bogus_array_descriptor (type))
	{
	  fprintf_filtered (stream, "(...?)");
	  return;
	}
      else
	{
	  print_record (type, valaddr, offset_aligned,
			stream, recurse, original_value, options);
	  return;
	}

    case TYPE_CODE_ARRAY:
      ada_val_print_array (type, valaddr, offset_aligned,
			   address, stream, recurse, original_value,
			   options);
      return;

    case TYPE_CODE_REF:
      /* For references, the debugger is expected to print the value as
         an address if DEREF_REF is null.  But printing an address in place
         of the object value would be confusing to an Ada programmer.
         So, for Ada values, we print the actual dereferenced value
         regardless.  */
      elttype = check_typedef (TYPE_TARGET_TYPE (type));
      
      if (TYPE_CODE (elttype) != TYPE_CODE_UNDEF)
        {
          CORE_ADDR deref_val_int;
	  struct value *deref_val;

	  deref_val = coerce_ref_if_computed (original_value);
	  if (deref_val)
	    {
	      if (ada_is_tagged_type (value_type (deref_val), 1))
		deref_val = ada_tag_value_at_base_address (deref_val);

	      common_val_print (deref_val, stream, recurse + 1, options,
				current_language);
	      break;
	    }

          deref_val_int = unpack_pointer (type, valaddr + offset_aligned);
          if (deref_val_int != 0)
            {
              deref_val =
                ada_value_ind (value_from_pointer
                               (lookup_pointer_type (elttype),
                                deref_val_int));

	      if (ada_is_tagged_type (value_type (deref_val), 1))
		deref_val = ada_tag_value_at_base_address (deref_val);

              val_print (value_type (deref_val),
                         value_contents_for_printing (deref_val),
                         value_embedded_offset (deref_val),
                         value_address (deref_val), stream, recurse + 1,
			 deref_val, options, current_language);
            }
          else
            fputs_filtered ("(null)", stream);
        }
      else
        fputs_filtered ("???", stream);

      break;
    }
  gdb_flush (stream);
}

static int
print_variant_part (struct type *type, int field_num,
		    const gdb_byte *valaddr, int offset,
		    struct ui_file *stream, int recurse,
		    const struct value *val,
		    const struct value_print_options *options,
		    int comma_needed,
		    struct type *outer_type, int outer_offset)
{
  struct type *var_type = TYPE_FIELD_TYPE (type, field_num);
  int which = ada_which_variant_applies (var_type, outer_type,
					 valaddr + outer_offset);

  if (which < 0)
    return 0;
  else
    return print_field_values
      (TYPE_FIELD_TYPE (var_type, which),
       valaddr,
       offset + TYPE_FIELD_BITPOS (type, field_num) / HOST_CHAR_BIT
       + TYPE_FIELD_BITPOS (var_type, which) / HOST_CHAR_BIT,
       stream, recurse, val, options,
       comma_needed, outer_type, outer_offset);
}

void
ada_value_print (struct value *val0, struct ui_file *stream,
		 const struct value_print_options *options)
{
  struct value *val = ada_to_fixed_value (val0);
  CORE_ADDR address = value_address (val);
  struct type *type = ada_check_typedef (value_type (val));
  struct value_print_options opts;

  /* If it is a pointer, indicate what it points to.  */
  if (TYPE_CODE (type) == TYPE_CODE_PTR)
    {
      /* Hack:  don't print (char *) for char strings.  Their
         type is indicated by the quoted string anyway.  */
      if (TYPE_LENGTH (TYPE_TARGET_TYPE (type)) != sizeof (char)
	  || TYPE_CODE (TYPE_TARGET_TYPE (type)) != TYPE_CODE_INT 
	  || TYPE_UNSIGNED (TYPE_TARGET_TYPE (type)))
	{
	  fprintf_filtered (stream, "(");
	  type_print (type, "", stream, -1);
	  fprintf_filtered (stream, ") ");
	}
    }
  else if (ada_is_array_descriptor_type (type))
    {
      /* We do not print the type description unless TYPE is an array
	 access type (this is encoded by the compiler as a typedef to
	 a fat pointer - hence the check against TYPE_CODE_TYPEDEF).  */
      if (TYPE_CODE (type) == TYPE_CODE_TYPEDEF)
        {
	  fprintf_filtered (stream, "(");
	  type_print (type, "", stream, -1);
	  fprintf_filtered (stream, ") ");
	}
    }
  else if (ada_is_bogus_array_descriptor (type))
    {
      fprintf_filtered (stream, "(");
      type_print (type, "", stream, -1);
      fprintf_filtered (stream, ") (...?)");
      return;
    }

  opts = *options;
  opts.deref_ref = 1;
  val_print (type, value_contents_for_printing (val),
	     value_embedded_offset (val), address,
	     stream, 0, val, &opts, current_language);
}

static void
print_record (struct type *type, const gdb_byte *valaddr,
	      int offset,
	      struct ui_file *stream, int recurse,
	      const struct value *val,
	      const struct value_print_options *options)
{
  type = ada_check_typedef (type);

  fprintf_filtered (stream, "(");

  if (print_field_values (type, valaddr, offset,
			  stream, recurse, val, options,
			  0, type, offset) != 0 && options->prettyformat)
    {
      fprintf_filtered (stream, "\n");
      print_spaces_filtered (2 * recurse, stream);
    }

  fprintf_filtered (stream, ")");
}

/* Print out fields of value at VALADDR + OFFSET having structure type TYPE.

   TYPE, VALADDR, OFFSET, STREAM, RECURSE, and OPTIONS have the same
   meanings as in ada_print_value and ada_val_print.

   OUTER_TYPE and OUTER_OFFSET give type and address of enclosing
   record (used to get discriminant values when printing variant
   parts).

   COMMA_NEEDED is 1 if fields have been printed at the current recursion
   level, so that a comma is needed before any field printed by this
   call.

   Returns 1 if COMMA_NEEDED or any fields were printed.  */

static int
print_field_values (struct type *type, const gdb_byte *valaddr,
		    int offset, struct ui_file *stream, int recurse,
		    const struct value *val,
		    const struct value_print_options *options,
		    int comma_needed,
		    struct type *outer_type, int outer_offset)
{
  int i, len;

  len = TYPE_NFIELDS (type);

  for (i = 0; i < len; i += 1)
    {
      if (ada_is_ignored_field (type, i))
	continue;

      if (ada_is_wrapper_field (type, i))
	{
	  comma_needed =
	    print_field_values (TYPE_FIELD_TYPE (type, i),
				valaddr,
				(offset
				 + TYPE_FIELD_BITPOS (type, i) / HOST_CHAR_BIT),
				stream, recurse, val, options,
				comma_needed, type, offset);
	  continue;
	}
      else if (ada_is_variant_part (type, i))
	{
	  comma_needed =
	    print_variant_part (type, i, valaddr,
				offset, stream, recurse, val,
				options, comma_needed,
				outer_type, outer_offset);
	  continue;
	}

      if (comma_needed)
	fprintf_filtered (stream, ", ");
      comma_needed = 1;

      if (options->prettyformat)
	{
	  fprintf_filtered (stream, "\n");
	  print_spaces_filtered (2 + 2 * recurse, stream);
	}
      else
	{
	  wrap_here (n_spaces (2 + 2 * recurse));
	}

      annotate_field_begin (TYPE_FIELD_TYPE (type, i));
      fprintf_filtered (stream, "%.*s",
			ada_name_prefix_len (TYPE_FIELD_NAME (type, i)),
			TYPE_FIELD_NAME (type, i));
      annotate_field_name_end ();
      fputs_filtered (" => ", stream);
      annotate_field_value ();

      if (TYPE_FIELD_PACKED (type, i))
	{
	  struct value *v;

	  /* Bitfields require special handling, especially due to byte
	     order problems.  */
	  if (HAVE_CPLUS_STRUCT (type) && TYPE_FIELD_IGNORE (type, i))
	    {
	      fputs_filtered (_("<optimized out or zero length>"), stream);
	    }
	  else
	    {
	      int bit_pos = TYPE_FIELD_BITPOS (type, i);
	      int bit_size = TYPE_FIELD_BITSIZE (type, i);
	      struct value_print_options opts;

	      adjust_type_signedness (TYPE_FIELD_TYPE (type, i));
	      v = ada_value_primitive_packed_val
		    (NULL, valaddr,
		     offset + bit_pos / HOST_CHAR_BIT,
		     bit_pos % HOST_CHAR_BIT,
		     bit_size, TYPE_FIELD_TYPE (type, i));
	      opts = *options;
	      opts.deref_ref = 0;
	      val_print (TYPE_FIELD_TYPE (type, i),
			 value_contents_for_printing (v),
			 value_embedded_offset (v), 0,
			 stream, recurse + 1, v,
			 &opts, current_language);
	    }
	}
      else
	{
	  struct value_print_options opts = *options;

	  opts.deref_ref = 0;
	  ada_val_print (TYPE_FIELD_TYPE (type, i),
			 valaddr,
			 (offset
			  + TYPE_FIELD_BITPOS (type, i) / HOST_CHAR_BIT),
			 0, stream, recurse + 1, val, &opts);
	}
      annotate_field_end ();
    }

  return comma_needed;
}
@


1.96
log
@2013-02-01  Aleksandar Ristovski  <aristovski@@qnx.com>

        * ada-valprint.c (ada_print_floating): Remove unused 'len'.

Reference: http://sourceware.org/ml/gdb-patches/2013-01/msg00732.html
@
text
@d174 1
a174 1
	  if (options->prettyprint_arrays)
d230 1
a230 1
		  if (options->prettyprint_arrays)
d603 1
a603 1
      if (options->prettyprint_arrays)
d1004 1
a1004 1
			  0, type, offset) != 0 && options->pretty)
d1070 1
a1070 1
      if (options->pretty)
@


1.95
log
@	PR cli/7719:
	* NEWS: Update.
	* ada-valprint.c (printstr, print_field_values): Remove
	"inspect_it" code.
	* cp-valprint.c (cp_print_value_fields): Remove "inspect_it"
	code.
	* jv-valprint.c (java_print_value_fields): Remove "inspect_it"
	code.
	* m2-lang.c (m2_printstr): Remove "inspect_it" code.
	* main.c (captured_main): Remove "epoch" argument.
	* objc-lang.c (objc_printstr): Remove "inspect_it" code.
	* p-lang.c (pascal_printstr): Remove "inspect_it" code.
	* p-valprint.c (pascal_object_print_value_fields): Remove
	"inspect_it" code.
	* printcmd.c (print_command_1): Remove 'inspect' argument.
	(print_command, call_command): Update.
	(inspect_command): Remove.
	(_initialize_printcmd): Make "inspect" an alias for "print".
	* top.c (epoch_interface): Remove.
	* top.h (epoch_interface): Remove.
	* valprint.c (user_print_options): Update.
	(print_converted_chars_to_obstack): Remove "inspect_it" code.
	* valprint.h (struct value_print_options) <inspect_it>: Remove
	field.
doc
	* gdb.texinfo (Mode Options): Don't mention -epoch.
	(Data, Emacs): Remove obsolete comments.
@
text
@a322 1
  int len;
a330 1
  len = strlen (result);
@


1.94
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d512 1
a512 4
	      if (options->inspect_it)
		fputs_filtered ("\\\", ", stream);
	      else
		fputs_filtered ("\", ", stream);
d528 1
a528 4
	      if (options->inspect_it)
		fputs_filtered ("\\\"", stream);
	      else
		fputs_filtered ("\"", stream);
d539 1
a539 6
    {
      if (options->inspect_it)
	fputs_filtered ("\\\"", stream);
      else
	fputs_filtered ("\"", stream);
    }
d1081 8
a1088 23
      if (options->inspect_it)
	{
	  if (TYPE_CODE (TYPE_FIELD_TYPE (type, i)) == TYPE_CODE_PTR)
	    fputs_filtered ("\"( ptr \"", stream);
	  else
	    fputs_filtered ("\"( nodef \"", stream);
	  fprintf_symbol_filtered (stream, TYPE_FIELD_NAME (type, i),
				   language_cplus, DMGL_NO_OPTS);
	  fputs_filtered ("\" \"", stream);
	  fprintf_symbol_filtered (stream, TYPE_FIELD_NAME (type, i),
				   language_cplus, DMGL_NO_OPTS);
	  fputs_filtered ("\") \"", stream);
	}
      else
	{
	  annotate_field_begin (TYPE_FIELD_TYPE (type, i));
	  fprintf_filtered (stream, "%.*s",
			    ada_name_prefix_len (TYPE_FIELD_NAME (type, i)),
			    TYPE_FIELD_NAME (type, i));
	  annotate_field_name_end ();
	  fputs_filtered (" => ", stream);
	  annotate_field_value ();
	}
@


1.93
log
@Full view of interface-wide types

For displaying the full view of a class-wide object, GDB relies on
the assumption that this view will have the same address as the
address of the object. In the case of simple inheritance, this
assumption is correct; the proper type is deduced by decoding
the tag of the object and converting the result to this full-view
type.

Consider for example an abstract class Shape, a child Circle
which implements an interface Drawable, and the corresponding
following objects:

   My_Circle   : Circle := ((1, 2), 3);
   My_Shape    : Shape'Class := Shape'Class (My_Circle);
   My_Drawable : Drawable'Class := Drawable'Class (My_Circle);

To display My_Shape, the debugger first extracts the tag (an internal
field, usually the first one of the record):

 (gdb) p my_shape'address
 $2 = (system.address) 0x8063e28
 (gdb) x/x my_shape'address
 0x8063e28 <classes__my_shape>: 0x08059ec4

Then the type specific data and the expanded name of the tag is read
from there:

 (gdb) p my_shape'tag
 $3 = (access ada.tags.dispatch_table) 0x8059ec4 (classes.circle)

To get the full view, the debugger converts to the corresponding type:

 (gdb) p {classes.circle}0x8063e28
 $4 = (center => (x => 1, y => 2), radius => 3)

Now, in the case of multiple inheritance, the assumption does not hold
anymore. The address that we have usually points to some
place lower. The offset to the original address is saved in the field
Offset_To_Top of the metadata that are above the tag, at address
obj'tag - 8. In the case of my_shape, this offset is 0:

 (gdb) x/x my_shape'tag - 8
 0x8059ebc <classes__circleT+12>:        0x00000000

...but in the case of an interface-wide object, it is not null:

 (gdb) x/x my_drawable'tag - 8
 0x8063b28 <classes__classes__circle_classes__drawable1T56s+12>: 0x00000004
 (gdb) p {classes.circle}(my_drawable'address - 4)
 $7 = (center => (x => 1, y => 2), radius => 3)

The following change handles this relocation in the most common cases.
Remaining cases that are still to be investigated are signaled by
comments.

gdb/ChangeLog:

	* ada-lang.h (ada_tag_value_at_base_address): New function
	declaration.
	* ada-lang.c (is_ada95_tag, ada_tag_value_at_base_address):
	New functions.
	(ada_to_fixed_type_1, ada_evaluate_subexp): Let ada_tag_base_address
	relocate the class-wide value if need be.
	(ada_value_struct_elt, ada_value_ind, ada_coerce_ref):
	Let ada_tag_value_at_base_address relocate the class-wide access/ref
	before dereferencing it.
	* ada-valprint.c (ada_val_print_1): Relocate to base address
	before displaying the content of an interface-wide ref.

gdb/testsuite/ChangeLog:

        * gdb.ada/ptype_tagged_param.exp: Adjust expected output in
        ptype test.
@
text
@d3 1
a3 2
   Copyright (C) 1986, 1988-1989, 1991-1994, 1997, 2001-2012 Free
   Software Foundation, Inc.
@


1.92
log
@	* ada-valprint.c (ada_val_print_1): Eliminate single-use
	variable LEN.
	* alpha-tdep.c (alpha_extract_return_value): Use TYPE_LENGTH
	directly.
	(alpha_store_return_value): Likewise.
	* amd64-tdep.c (amd64_classify_aggregate): Likewise.
	(amd64_push_arguments): Likewise.
	* ax-gdb.c (gen_trace_static_fields): Likewise.
	(gen_traced_pop): Likewise.
	* bfin-tdep.c (bfin_push_dummy_call): Likewise.
	* breakpoint.c (update_watchpoint): Likewise.
	* findcmd.c (parse_find_args): Use local variable for type
	instead of length.
	* findvar.c (default_read_var_value): Use TYPE_LENGTH directly.
	* h8300-tdep.c (h8300h_extract_return_value): Likewise.
	(h8300_store_return_value): Likewise.
	* i386-darwin-tdep.c (i386_darwin_push_dummy_call): Likewise.
	Use i386_darwin_arg_type_alignment directly.
	* infcall.c (call_function_by_hand): Use TYPE_LENGTH directly.
	* lm32-tdep.c (lm32_push_dummy_call): Likewise.
	* m68hc11-tdep.c (m68hc11_push_dummy_call): Likewise.
	(m68hc11_extract_return_value): Likewise.
	* mep-tdep.c (mep_push_dummy_call): Likewise.
	* printcmd.c (float_type_from_length): Likewise.
	* s390-tdep.c (s390_value_from_register): Likewise.
	* stack.c (read_frame_arg): Likewise.
	* tracepoint.c (encode_actions_1): Likewise.
	* valops.c (value_fetch_lazy): Use local variable for type
	instead of length.  Use TYPE_LENGTH directly.
	* value.c (value_contents_equal): Use TYPE_LENGTH directly.
@
text
@d894 3
d910 3
@


1.91
log
@gdb/
	PR symtab/7259:
	* ada-exp.y (convert_char_literal): Use TYPE_FIELD_ENUMVAL.
	* ada-lang.c (ada_discrete_type_high_bound)
	(ada_discrete_type_low_bound): Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	(ada_identical_enum_types_p): Use TYPE_FIELD_ENUMVAL.
	(pos_atr, value_val_atr): Use TYPE_FIELD_ENUMVAL for TYPE_CODE_ENUM.
	* ada-typeprint.c (print_enum_type): Change variable lastval to LONGEST.
	Use TYPE_FIELD_ENUMVAL.
	* ada-valprint.c (print_optional_low_bound, ada_print_scalar)
	(ada_val_print_1): Use TYPE_FIELD_ENUMVAL for TYPE_CODE_ENUM.
	* c-typeprint.c (c_type_print_base): Move variable lastval to inner
	block, change it to LONGEST.  Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	* coffread.c (coff_read_enum_type): Use SET_FIELD_ENUMVAL.
	* dwarf2read.c (process_enumeration_scope): Likewise.
	* gdb-gdb.py (TypeFlagsPrinter): Use field.enumval instead of
	field.bitpos.
	(class StructMainTypePrettyPrinter): Support also
	FIELD_LOC_KIND_ENUMVAL.
	* gdbtypes.c (get_discrete_bounds): Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	(recursive_dump_type): Use TYPE_FIELD_ENUMVAL for TYPE_CODE_ENUM.
	(copy_type_recursive): Support also FIELD_LOC_KIND_ENUMVAL.
	* gdbtypes.h (enum field_loc_kind): New FIELD_LOC_KIND_ENUMVAL.
	(struct main_type.flds_bnds.fields.loc): Adjust bitpos comment.  New
	field enumval.
	(struct main_type.flds_bnds.bields): Adjust loc_kind and bitsize to
	accommodate enumval.
	(struct call_site): Adjust loc_kind to accommodate enumval.
	(FIELD_ENUMVAL, FIELD_ENUMVAL_LVAL, SET_FIELD_ENUMVAL)
	(TYPE_FIELD_ENUMVAL): New macros.
	* m2-typeprint.c (m2_enum): Use TYPE_FIELD_ENUMVAL.
	* mdebugread.c (parse_symbol): Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	* p-typeprint.c (pascal_type_print_base): Likewise.
	* python/lib/gdb/printing.py (class FlagEnumerationPrinter): Use
	enumval.
	* python/lib/gdb/types.py (make_enum_dict): Likewise.
	* python/py-type.c (convert_field): New variable addrstring.  Use
	TYPE_FIELD_ENUMVAL for TYPE_CODE_ENUM.
	(check_types_equal): Support also FIELD_LOC_KIND_ENUMVAL.
	* stabsread.c (read_enum_type): Use SET_FIELD_ENUMVAL.
	* typepint.c (print_type_scalar): Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	* valprint.c (generic_val_print): Likewise.

gdb/testsuite/
	PR symtab/7259:
	* gdb.base/enumval.c: New test case.
	* gdb.base/enumval.exp: New test case.
	* gdb.python/py-type.exp (test_enums): Use field.enumval instead of
	field.bitpos.
@
text
@a732 1
	  int len = TYPE_LENGTH (type);
d734 1
a734 1
	  fprintf_filtered (stream, len < 4 ? "%.11g" : "%.17g",
@


1.90
log
@Fix -Wshadow error in ada-valprint.c

gdb/ChangeLog:

        * ada-valprint.c (ada_val_print_1): Move the code handling
        TYPE_CODE_ENUM inside its own lexical block.  Declare
        variables len and val there, instead of in the function's
        top level block.  Avoid declaring deref_val again in a way
        that shadows another variable of the same name declared
        in one of the up-level blocks.  Just re-use the up-level
        variable instead.
@
text
@d112 1
a112 1
      if (low_bound == TYPE_FIELD_BITPOS (index_type, 0))
d405 1
a405 1
	  if (TYPE_FIELD_BITPOS (type, i) == val)
d827 1
a827 1
	    if (val == TYPE_FIELD_BITPOS (type, i))
@


1.89
log
@	* valprint.h (struct generic_val_print_decorations): New.
	(generic_val_print): Declare.
	* valprint.c (generic_val_print): New function.
	* p-valprint.c (p_decorations): New global.
	(pascal_val_print) <TYPE_CODE_REF, TYPE_CODE_ENUM,
	TYPE_CODE_FLAGS, TYPE_CODE_FUNC, TYPE_CODE_RANGE, TYPE_CODE_INT,
	TYPE_CODE_FLT, TYPE_CODE_VOID, TYPE_CODE_ERROR, TYPE_CODE_UNDEF,
	TYPE_CODE_BOOL, TYPE_CODE_CHAR>: Call generic_val_print.
	* m2-valprint.c (m2_decorations): New global.
	(m2_val_print) <TYPE_CODE_REF, TYPE_CODE_ENUM, TYPE_CODE_FUNC,
	TYPE_CODE_BOOL, TYPE_CODE_RANGE, TYPE_CODE_INT, TYPE_CODE_CHAR,
	TYPE_CODE_FLT, TYPE_CODE_METHOD, TYPE_CODE_VOID, TYPE_CODE_UNDEF,
	TYPE_CODE_ERROR>: Call generic_val_print.
	* f-valprint.c (f_decorations): New global.
	(f_val_print): Use print_function_pointer_address.
	<TYPE_CODE_REF, TYPE_CODE_FUNC, TYPE_CODE_CHAR, TYPE_CODE_FLAGS,
	TYPE_CODE_FLT, TYPE_CODE_VOID, TYPE_CODE_ENUM, TYPE_CODE_RANGE,
	TYPE_CODE_BOOL, TYPE_CODE_COMPLEX, TYPE_CODE_UNDEF>: Call
	generic_val_print.
	* c-valprint.c (c_decorations): New global.
	(c_val_print) <TYPE_CODE_MEMBERPTR, TYPE_CODE_REF, TYPE_CODE_ENUM,
	TYPE_CODE_FLAGS, TYPE_CODE_FUNC, TYPE_CODE_METHOD, TYPE_CODE_BOOL,
	TYPE_CODE_RANGE, TYPE_CODE_CHAR, TYPE_CODE_FLT,
	TYPE_CODE_DECFLOAT, TYPE_CODE_VOID, TYPE_CODE_ERROR,
	TYPE_CODE_UNDEF, TYPE_CODE_COMPLEX>: Call generic_val_print.
	* ada-valprint.c (ada_val_print_1) <TYPE_CODE_FLAGS>: Remove
	case.
@
text
@a661 1
  unsigned int len;
a663 1
  LONGEST val;
d812 23
a834 19
      if (options->format)
	{
	  val_print_scalar_formatted (type, valaddr, offset_aligned,
				      original_value, options, 0, stream);
	  break;
	}
      len = TYPE_NFIELDS (type);
      val = unpack_long (type, valaddr + offset_aligned);
      for (i = 0; i < len; i++)
	{
	  QUIT;
	  if (val == TYPE_FIELD_BITPOS (type, i))
	    {
	      break;
	    }
	}
      if (i < len)
	{
	  const char *name = ada_enum_name (TYPE_FIELD_NAME (type, i));
d836 11
a846 10
	  if (name[0] == '\'')
	    fprintf_filtered (stream, "%ld %s", (long) val, name);
	  else
	    fputs_filtered (name, stream);
	}
      else
	{
	  print_longest (stream, 'd', 0, val);
	}
      break;
d903 1
a903 1
              struct value *deref_val =
@


1.88
log
@	* valprint.c (val_print): Update.
	* p-valprint (pascal_val_print): Return void.
	* p-lang.h (pascal_val_print): Return void.
	* m2-valprint.c (m2_val_print): Return void.
	* m2-lang.h (m2_val_print): Return void.
	* language.h (struct language_defn) <la_val_print>: Return void.
	* language.c (unk_lang_val_print): Return void.
	* jv-valprint.c (java_val_print): Return void.
	* jv-lang.h (java_val_print): Return void.
	* f-valprint.c (f_val_print): Return void.
	* f-lang.h (f_val_print): Return void.
	* d-valprint.c (d_val_print): Return void.
	(dynamic_array_type): Update.
	* d-lang.h (d_val_print): Return void.
	* c-valprint.c (c_val_print): Return void.
	* c-lang.h (c_val_print): Return void.
	* ada-valprint.c (ada_vada_val_print, ada_val_print_1): Return
	void.
	* ada-lang.h (ada_val_print): Return void.
@
text
@a844 8
    case TYPE_CODE_FLAGS:
      if (options->format)
	val_print_scalar_formatted (type, valaddr, offset_aligned,
				    original_value, options, 0, stream);
      else
	val_print_type_code_flags (type, valaddr + offset_aligned, stream);
      break;

@


1.87
log
@	* value.h (value_print): Return void.
	* valprint.c (value_print): Return void.
	* p-valprint.c (pascal_value_print): Return void.
	* p-lang.h (pascal_value_print): Return void.
	* language.h (struct language_defn) <la_value_print>: Return
	void.
	* language.c (unk_lang_value_print): Return void.
	* jv-valprint.c (java_value_print): Return void.
	* jv-lang.h (java_value_print): Return void.
	* f-valprint.c (c_value_print): Don't declare.
	Include c-lang.h.
	* c-valprint.c (c_value_print): Return void.
	* c-lang.h (c_value_print): Return void.
	* ada-valprint.c (ada_value_print): Return void.
	* ada-lang.h (ada_value_print): Return void.
@
text
@d53 4
a56 4
static int ada_val_print_1 (struct type *, const gdb_byte *, int, CORE_ADDR,
			    struct ui_file *, int,
			    const struct value *,
			    const struct value_print_options *);
d569 1
a569 2
   function; they are identical.  The semantics of the return value is
   also identical to val_print.  */
d571 1
a571 1
int
a578 1
  int result = 0;
d583 2
a584 2
      result = ada_val_print_1 (type, valaddr, embedded_offset, address,
				stream, recurse, val, options);
a585 5

  if (except.reason < 0)
    result = 0;

  return result;
d590 1
a590 2
   parameters of this function; they are identical.  The semantics
   of the return value is also identical to ada_val_print.  */
d592 1
a592 1
static int
a598 2
  int result = 0;

a636 1
      result = len;
a649 2

  return result;
d655 1
a655 1
static int
a673 1
      int retn;
a689 1
	  retn = 0;
d692 5
a696 5
	retn = ada_val_print_1 (value_type (val),
				value_contents_for_printing (val),
				value_embedded_offset (val),
				value_address (val), stream, recurse,
				val, options);
d698 1
a698 1
      return retn;
d707 3
a709 2
      return c_val_print (type, valaddr, offset, address, stream,
			  recurse, original_value, options);
d713 2
a714 2
	int ret = c_val_print (type, valaddr, offset, address,
			       stream, recurse, original_value, options);
d726 2
a727 3
	    return 0;
	}
	return ret;
d739 1
a739 1
	  return 0;
d755 4
a758 4
	      return ada_val_print_1 (target_type,
				      value_contents_for_printing (v),
				      value_embedded_offset (v), 0,
 				      stream, recurse + 1, v, options);
d761 5
a765 4
	    return ada_val_print_1 (TYPE_TARGET_TYPE (type),
				    valaddr, offset,
				    address, stream, recurse,
				    original_value, options);
d810 1
a810 1
	  return 0;
d855 5
a859 2
	return c_val_print (type, valaddr, offset, address, stream,
			    recurse, original_value, options);
d869 1
a869 1
	  return 0;
d875 1
a875 1
	  return 0;
d879 4
a882 3
      return ada_val_print_array (type, valaddr, offset_aligned,
				  address, stream, recurse, original_value,
				  options);
a927 1
  return 0;
@


1.86
log
@[Ada] Handle reference to array descriptors

This patch is to help handle aliased array variables, such as:

   type Bounded is array (Integer range <>) of Integer;
   function New_Bounded (Low, High : Integer) return Bounded;
   BT : aliased Bounded := New_Bounded (Low => 1, High => 3);

In that case, the compiler describes variable "BT" as a reference
to a thin pointer, and GDB is unable to print its value:

    (gdb) p bt
    $1 =

The problems starts when ada_value_print deconstructs the struct
value into contents and address in order to call val_print. It
turns out in this case that "bt" is not an lval. In the debug
information, this variable's location is described as:

        .uleb128 0xd    # (DIE (0xe0) DW_TAG_variable)
        .ascii "bt\0"   # DW_AT_name
        [...]
        .byte   0x6     # DW_AT_location
        .byte   0x91    # DW_OP_fbreg
        .sleb128 -56
        .byte   0x6     # DW_OP_deref
        .byte   0x23    # DW_OP_plus_uconst
        .uleb128 0x8
        .byte   0x9f    # DW_OP_stack_value

So, when ada_value_print passes the bt's (value) address, it passes
in effect a meaningless address. The problem continues shortly after
when ada_val_print_1 re-creates the value from the contents and address.
The value has become an lval_memory, with a null address.

As a result, we trigger a memory error later on, while trying to
read the array bounds in order to transform our value into a simple
array.

To avoid the problem entirely, the fix is to coerce references before
transforming array descriptors into simple arrays.

gdb/ChangeLog:

        * ada-valprint.c (ada_val_print_1): If our value is a reference
        to an array descriptor, dereference it before converting it
        to a simple array.

gdb/testsuite/ChangeLog:

        * gdb.ada/aliased_array: New testcase.
@
text
@d966 1
a966 1
int
d1006 1
a1006 1
      return 0;
d1011 3
a1013 3
  return (val_print (type, value_contents_for_printing (val),
		     value_embedded_offset (val), address,
		     stream, 0, val, &opts, current_language));
@


1.85
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d692 4
@


1.84
log
@gdb/
	Display @@entry parameter values even for references.
	* ada-valprint.c (ada_val_print_1) <TYPE_CODE_REF>: Try also
	coerce_ref_if_computed.
	* c-valprint.c (c_val_print) <TYPE_CODE_REF>: Likewise.
	* dwarf2expr.c (dwarf_block_to_dwarf_reg_deref): New function.
	(execute_stack_op) <DW_OP_GNU_entry_value>: Add -1 deref_size to the
	existing push_dwarf_reg_entry_value call.  Add new detection calling
	dwarf_block_to_dwarf_reg_deref.  Update the error message.
	(ctx_no_push_dwarf_reg_entry_value): New parameter deref_size.
	* dwarf2expr.h
	(struct dwarf_expr_context_funcs) <push_dwarf_reg_entry_value>: Add new
	parameter deref_size, describe it in the comment.
	(ctx_no_push_dwarf_reg_entry_value): Add new parameter deref_size.
	(dwarf_block_to_dwarf_reg_deref): New declaration.
	* dwarf2loc.c (dwarf_entry_parameter_to_value): Add new parameter
	deref_size, describe it in the function comment.  New variables
	data_src and size, fetch the alternative block accoring to DEREF_SIZE.
	(dwarf_expr_push_dwarf_reg_entry_value): Add new parameter deref_size,
	describe it in the function comment.  Fetch the alternative block
	accoring to DEREF_SIZE.
	(entry_data_value_coerce_ref, entry_data_value_copy_closure)
	(entry_data_value_free_closure, entry_data_value_funcs): New.
	(value_of_dwarf_reg_entry): New variables checked_type, target_type,
	outer_val, target_val, val and addr.  Try to fetch and create also
	referenced value content.
	(pieced_value_funcs): NULL value for coerce_ref.
	(needs_dwarf_reg_entry_value): Add new parameter deref_size.
	* f-valprint.c (f_val_print) <TYPE_CODE_REF>: Try also
	coerce_ref_if_computed.
	* opencl-lang.c (opencl_value_funcs): NULL value for coerce_ref.
	* p-valprint.c (pascal_val_print) <TYPE_CODE_REF>: Likewise.
	* stack.c (read_frame_arg): Compare also dereferenced values.
	* value.c (value_computed_funcs): Make the parameter v const, use
	value_lval_const for it.
	(value_lval_const, coerce_ref_if_computed): New function.
	(coerce_ref): New variable retval.  Call also coerce_ref_if_computed.
	* value.h (struct lval_funcs): New field coerce_ref.
	(value_computed_funcs): Make the parameter v const.
	(value_lval_const, coerce_ref_if_computed): New declarations.

gdb/testsuite/
	Display @@entry parameter values even for references.
	* gdb.arch/amd64-entry-value.cc (reference, datap, datap_input): New
	functions.
	(main): New variables regvar, nodatavarp, stackvar1, stackvar2.  Call
	reference and datap_input.
	* gdb.arch/amd64-entry-value.exp (reference, breakhere_reference): New
	breakpoints.
	(continue to breakpoint: entry_reference: reference)
	(entry_reference: bt at entry)
	(continue to breakpoint: entry_reference: breakhere_reference)
	(entry_reference: bt, entry_reference: ptype regparam)
	(entry_reference: p regparam, entry_reference: ptype regparam@@entry)
	(entry_reference: p regparam@@entry, entry_reference: p &regparam@@entry)
	(entry_reference: p regcopy, entry_reference: p nodataparam)
	(entry_reference: p nodataparam@@entry): New tests.
@
text
@d3 2
a4 3
   Copyright (C) 1986, 1988, 1989, 1991, 1992, 1993, 1994, 1997, 2001, 2002,
   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.84.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 3
a5 2
   Copyright (C) 1986, 1988-1989, 1991-1994, 1997, 2001-2012 Free
   Software Foundation, Inc.
@


1.83
log
@Fix printing address of packed array

When trying to print the address of a non-packed array, GDB
correctly prints the type name and address:

    (gdb) print &var
    $2 = (access pa.var) 0xbffff1d8

However, it is behaving differently when dealing with a packed
array:

    (gdb) p &var
    (access array (4 .. 8) of boolean <packed: 1-bit elements>) (4 =>
    false, false, false, true, false)

The type description isn't all that bad, but GDB shouldn't be
printing the array value!

This patch fixes the `print` and `ptype` command on packed and
non-packed array.  It also fixes a gdb.ada test to match with
the new ouput.

gdb/ChangeLog (Jean-Charles Delay):

        * ada-typeprint.c (ada_print_type): Fix both PAD type and
        pointer to constrained packed array type output.
        * ada-valprint.c (ada_val_print_1): Fix pointer to constrained
        packed array output.

gdb/testsuite/ChangeLog (Jean-Charles Delay):

        * gdb.ada/packed_array.exp: Fix expected outout.
@
text
@d901 2
a902 2
          CORE_ADDR deref_val_int
	    = unpack_pointer (type, valaddr + offset_aligned);
d904 9
@


1.82
log
@missing type description for typedef to pointer value

If we evaluate an expression that results in a value that is a typedef
to pointer, then the debugger fails to print the type description
before printing the actual value:

    (gdb) print e.plan(1)
    $1 = 0x0

The expected output is:

    (gdb) print e.plan(1)
    $1 = (access integer) 0x0

gdb/ChangeLog:

        * ada-valprint.c (ada_value_print): Handle typedefs.

gdb/testsuite/ChangeLog:

        * gdb.ada/ptr_typedef: New testcase.
@
text
@d685 2
a686 1
      || ada_is_constrained_packed_array_type (type))
@


1.81
log
@simplify ada-valprint.c:ada_val_print_array

Two things:
  - Move the declaration of a couple of variables inside the block
    where they are actually used;
  - Remove some code that checks against NULL/zero, because the
    condition should always be false. Add some gdb_asserts to
    make sure we never fail those assumptions.

gdb/ChangeLog:

        * ada-valprint.c (ada_val_print_array): Move the declaration of
        "byte_order" and "elttype" inside the block where these variables
        are actually used.  Remove some special handling for the case
        where "elttype" and "eltlen" are null.  Replace by a comment
        and a couple of assertion checks.
@
text
@d959 1
a959 1
  struct type *type = value_type (val);
@


1.80
log
@	gdb/
	* value.h (value_available_contents_eq): Declare.
	* value.c (find_first_range_overlap): New function.
	(value_available_contents_eq): New function.
	* valprint.c (val_print_array_elements): Use
	value_available_contents_eq.
	* ada-valprint.c (val_print_packed_array_elements): Use
	value_available_contents_eq.
	* jv-valprint.c (java_value_print): Use
	value_available_contents_eq.
@
text
@a607 2
  enum bfd_endian byte_order = gdbarch_byte_order (get_type_arch (type));
  struct type *elttype = TYPE_TARGET_TYPE (type);
d614 2
d619 8
a626 8
      if (elttype == NULL)
        eltlen = 0;
      else
        eltlen = TYPE_LENGTH (elttype);
      if (eltlen == 0)
        len = 0;
      else
        len = TYPE_LENGTH (type) / eltlen;
@


1.79
log
@	* valprint.c (val_print): Extend comment.
	* ada-valprint.c (ada_valprint): Rewrite comment deferring
	interface explanation to val_print.
	(ada_val_print_array): Adjust comment to current interface.
	(print_field_values): Adjust comment to current interface.
	* c-valprint.c (c_val_print): Rewrite comment deferring interface
	explanation to val_print.
	* f-valprint.c (f_val_print): Ditto.
	* jv-valprint.c (java_val_print): Ditto.
	* m2-valprint.c (m2_val_print): Ditto.
	* p-valprint.c (pascal_val_print): Ditto.
@
text
@d203 3
a205 1
	  if (memcmp (value_contents (v0), value_contents (v1), eltlen) != 0)
@


1.78
log
@	* printcmd.c (print_formatted): Use val_print_scalar_formatted
	instead of print_scalar_formatted.
	(print_scalar_formatted): Don't handle 's' format strings here,
	and add an assertion that we never see such format here.
	* valprint.h (val_print_scalar_formatted): Declare.
	* valprint.c (val_print_scalar_formatted): New.
	* c-valprint.c (c_val_print): Use val_print_scalar_formatted
	instead of print_scalar_formatted.
	* jv-valprint.c (java_val_print): Ditto.
	* p-valprint.c (pascal_val_print): Ditto.
	* ada-valprint.c (ada_val_print_1): Ditto.
	* f-valprint.c (f_val_print): Ditto.
	* infcmd.c (registers_info): Ditto.
	* m2-valprint.c (m2_val_print): Ditto.
@
text
@d567 3
a569 9
/* Print data of type TYPE located at VALADDR (within GDB), which came from
   the inferior at address ADDRESS, onto stdio stream STREAM according to
   OPTIONS.  The data at VALADDR is in target byte order.

   If the data is printed as a string, returns the number of string characters
   printed.

   RECURSE indicates the amount of indentation to supply before
   continuation lines; this amount is roughly twice the value of RECURSE.  */
d595 1
a595 1
   at VALADDR.  See ada_val_print for a description of the various
d1023 1
a1023 1
/* Print out fields of value at VALADDR having structure type TYPE.
d1025 2
a1026 2
   TYPE, VALADDR, STREAM, RECURSE, and OPTIONS have the
   same meanings as in ada_print_value and ada_val_print.
d1028 3
a1030 2
   OUTER_TYPE and OUTER_VALADDR give type and address of enclosing record
   (used to get discriminant values when printing variant parts).
@


1.77
log
@	* ada-valprint.c (val_print_packed_array_elements): Pass the
	correct struct value to val_print.
	(ada_val_print_1): Ditto.
@
text
@d791 2
a792 2
	      print_scalar_formatted (valaddr + offset_aligned,
				      type, &opts, 0, stream);
d830 2
a831 2
	  print_scalar_formatted (valaddr + offset_aligned,
				  type, options, 0, stream);
d861 2
a862 2
	print_scalar_formatted (valaddr + offset_aligned,
				type, options, 0, stream);
@


1.76
log
@2011-01-24  Pedro Alves  <pedro@@codesourcery.com>

	Don't lose embedded_offset in printing routines throughout.

	gdb/
	* valprint.h (val_print_array_elements): Change prototype.
	* valprint.c (val_print_array_elements): Add `embedded_offset'
	parameter, and adjust to pass it down to val_print, while passing
	`valaddr' or `address' unmodified.  Take embedded_offset into
	account when checking repetitions.
	* c-valprint.c (c_val_print): Pass embedded_offset to
	val_print_array_elements instead of adjusting `valaddr' and
	`address'.
	* m2-valprint.c (m2_print_array_contents, m2_val_print): Pass
	embedded_offset to val_print_array_elements instead of adjusting
	`valaddr'.
	* p-lang.h (pascal_object_print_value_fields): Adjust prototype.
	* p-valprint.c (pascal_val_print): Pass embedded_offset to
	val_print_array_elements and pascal_object_print_value_fields
	instead of adjusting `valaddr'.
	(pascal_object_print_value_fields): Add `offset' parameter, and
	adjust to use it.
	(pascal_object_print_value): Add `offset' parameter, and adjust to
	use it.
	(pascal_object_print_static_field): Use
	value_contents_for_printing/value_embedded_offset, rather than
	value_contents.
	* ada-valprint.c (val_print_packed_array_elements): Add `offset'
	parameter, and adjust to use it.  Use
	value_contents_for_printing/value_embedded_offset, rather than
	value_contents.
	(ada_val_print): Rename `valaddr0' parameter to `valaddr'.
	(ada_val_print_array): Add `offset' parameter, and adjust to use
	it.
	(ada_val_print_1): Rename `valaddr0' parameter to `valaddr', and
	`embedded_offset' to `offset'.  Don't re-adjust `valaddr'.
	Instead work with offsets.  Use
	value_contents_for_printing/value_embedded_offset, rather than
	value_contents.  Change `defer_val_int' local type to CORE_ADDR,
	and use value_from_pointer to extract a target pointer, rather
	than value_from_longest.
	(print_variant_part): Add `offset' parameter.  Replace
	`outer_valaddr' parameter by a new `outer_offset' parameter.
	Don't re-adjust `valaddr'.  Instead pass down adjusted offsets.
	(ada_value_print): Use
	value_contents_for_printing/value_embedded_offset, rather than
	value_contents.
	(print_record): Add `offset' parameter, and adjust to pass it
	down.
	(print_field_values): Add `offset' parameter.  Replace
	`outer_valaddr' parameter by a new `outer_offset' parameter.
	Don't re-adjust `valaddr'.  Instead pass down adjusted offsets.
	Use value_contents_for_printing/value_embedded_offset, rather than
	value_contents.
	* d-valprint.c (dynamic_array_type): Use
	value_contents_for_printing/value_embedded_offset, rather than
	value_contents.
	* jv-valprint.c (java_print_value_fields): Add `offset' parameter.
	Don't re-adjust `valaddr'.  Instead pass down adjusted offsets.
	(java_print_value_fields): Take `offset' into account.  Don't
	re-adjust `valaddr'.  Instead pass down adjusted offsets.
	(java_val_print): Take `embedded_offset' into account.  Pass it to
	java_print_value_fields.
	* f-valprint.c (f77_print_array_1): Add `embedded_offset'
	parameter.  Don't re-adjust `valaddr' or `address'.  Instead pass
	down adjusted offsets.
	(f77_print_array): Add `embedded_offset' parameter.  Pass it down.
	(f_val_print): Take `embedded_offset' into account.

	gdb/testsuite/
	* gdb.base/printcmds.c (some_struct): New struct and instance.
	* gdb.base/printcmds.exp (test_print_repeats_embedded_array): New
	procedure.
	<global scope>: Call it.
@
text
@d214 1
a214 1
		     recurse + 1, val, &opts, current_language);
d245 1
a245 1
			 recurse + 1, val, &opts, current_language);
d711 1
a711 1
				NULL, options);
d773 1
a773 1
 				      stream, recurse + 1, NULL, options);
d918 1
a918 1
			 original_value, options, current_language);
@


1.75
log
@fix printing of Ada wide characters on ppc-aix

Same problem as before: We were downcasting the character value from
int to unsigned char, which caused an overflow.  The reason why we did
not see this problem before is probably related to the fact that
we're using stabs on AIX and thus characters types are defined as
a TYPE_CODE_INT (or TYPE_CODE_RANGE?).

gdb/ChangeLog:

        * ada-valprint.c (ada_print_scalar): Remove unsigned char downcast.
        (ada_val_print_1): Likewise.
@
text
@d39 2
a40 1
static void print_record (struct type *, const gdb_byte *, struct ui_file *,
d46 1
d50 1
a50 2
			       int, struct type *,
			       const gdb_byte *);
d138 1
d190 1
a190 1
      v0 = ada_value_primitive_packed_val (NULL, valaddr,
d199 1
a199 1
	  v1 = ada_value_primitive_packed_val (NULL, valaddr,
d212 2
a213 1
	  val_print (elttype, value_contents (v0), 0, 0, stream,
d243 2
a244 1
	      val_print (elttype, value_contents (v0), 0, 0, stream,
d578 1
a578 1
ada_val_print (struct type *type, const gdb_byte *valaddr0,
d587 1
d590 1
a590 1
      result = ada_val_print_1 (type, valaddr0, embedded_offset, address,
d607 2
a608 1
		     CORE_ADDR address, struct ui_file *stream, int recurse,
d645 2
a646 1
                && char_at (valaddr, temp_len, eltlen, byte_order) != 0);
d651 1
a651 1
      printstr (stream, elttype, valaddr, len, 0, eltlen, options);
d659 2
a660 2
        val_print_packed_array_elements (type, valaddr, 0, stream,
                                         recurse, val, options);
d662 2
a663 2
        val_print_array_elements (type, valaddr, address, stream,
                                  recurse, val, options, 0);
d674 2
a675 2
ada_val_print_1 (struct type *type, const gdb_byte *valaddr0,
		 int embedded_offset, CORE_ADDR address,
d684 1
a684 1
  const gdb_byte *valaddr = valaddr0 + embedded_offset;
d695 1
a695 1
      val = value_from_contents_and_address (type, valaddr, address);
d707 3
a709 1
	retn = ada_val_print_1 (value_type (val), value_contents (val), 0,
d716 2
a717 3
  valaddr = ada_aligned_value_addr (type, valaddr);
  embedded_offset -= valaddr - valaddr0 - embedded_offset;
  type = printable_val_type (type, valaddr);
d722 1
a722 1
      return c_val_print (type, valaddr0, embedded_offset, address, stream,
d727 1
a727 1
	int ret = c_val_print (type, valaddr0, embedded_offset, address, 
d732 4
a735 2
	    struct value *val = 
	      value_from_contents_and_address (type, valaddr, address);
d749 1
a749 1
	  LONGEST v = unpack_long (type, valaddr);
d766 8
a773 6
	      struct value *v = value_cast (target_type,
					    value_from_contents_and_address
					    (type, valaddr, 0));

	      return ada_val_print_1 (target_type, value_contents (v), 0, 0,
				      stream, recurse + 1, NULL, options);
d777 1
a777 1
				    valaddr0, embedded_offset,
d791 2
a792 1
	      print_scalar_formatted (valaddr, type, &opts, 0, stream);
d804 2
a805 1
	      CORE_ADDR addr = extract_typed_address (valaddr, ptr_type);
d814 1
a814 1
	      val_print_type_code_int (type, valaddr, stream);
d817 2
d820 2
a821 1
		  ada_printchar (unpack_long (type, valaddr), type, stream);
d830 2
a831 1
	  print_scalar_formatted (valaddr, type, options, 0, stream);
d835 1
a835 1
      val = unpack_long (type, valaddr);
d861 2
a862 1
	print_scalar_formatted (valaddr, type, options, 0, stream);
d864 1
a864 1
	val_print_type_code_flags (type, valaddr, stream);
d869 1
a869 1
	return c_val_print (type, valaddr0, embedded_offset, address, stream,
d872 1
a872 1
	ada_print_floating (valaddr0 + embedded_offset, type, stream);
d884 2
a885 2
	  print_record (type, valaddr, stream, recurse, original_value,
			options);
d890 3
a892 2
      return ada_val_print_array (type, valaddr, address, stream,
				  recurse, original_value, options);
d904 2
a905 1
          LONGEST deref_val_int = (LONGEST) unpack_pointer (type, valaddr);
d910 1
a910 1
                ada_value_ind (value_from_longest
d915 2
a916 1
                         value_contents (deref_val), 0,
d933 2
a934 1
print_variant_part (struct type *type, int field_num, const gdb_byte *valaddr,
d939 1
a939 1
		    struct type *outer_type, const gdb_byte *outer_valaddr)
d942 2
a943 1
  int which = ada_which_variant_applies (var_type, outer_type, outer_valaddr);
d950 2
a951 1
       valaddr + TYPE_FIELD_BITPOS (type, field_num) / HOST_CHAR_BIT
d954 1
a954 1
       comma_needed, outer_type, outer_valaddr);
d1002 2
a1003 1
  return (val_print (type, value_contents (val), 0, address,
d1009 1
d1018 3
a1020 2
  if (print_field_values (type, valaddr, stream, recurse, val, options,
			  0, type, valaddr) != 0 && options->pretty)
d1045 1
a1045 1
		    struct ui_file *stream, int recurse,
d1049 1
a1049 1
		    struct type *outer_type, const gdb_byte *outer_valaddr)
d1064 3
a1066 2
				valaddr
				+ TYPE_FIELD_BITPOS (type, i) / HOST_CHAR_BIT,
d1068 1
a1068 1
				comma_needed, type, valaddr);
d1075 3
a1077 2
				stream, recurse, val, options, comma_needed,
				outer_type, outer_valaddr);
d1135 5
a1139 5
	      v = ada_value_primitive_packed_val (NULL, valaddr,
						  bit_pos / HOST_CHAR_BIT,
						  bit_pos % HOST_CHAR_BIT,
						  bit_size,
						  TYPE_FIELD_TYPE (type, i));
d1142 3
a1144 1
	      val_print (TYPE_FIELD_TYPE (type, i), value_contents (v), 0, 0,
d1155 4
a1158 2
			 valaddr + TYPE_FIELD_BITPOS (type, i) / HOST_CHAR_BIT,
			 0, 0, stream, recurse + 1, val, &opts);
@


1.74
log
@Fix printing of Wide_Character & Wide_Wide_Character entities.

Wide_Characters and Wide_Wide_Characters are incorrectly printed.
Consider for instance:

    Medium : Wide_Character := Wide_Character'Val(16#dead#);

Trying to print the value of this variable yields:

    (gdb) p medium
    $1 = 57005 '["ad"]'

The integer value is correct (57005 = 0xdead), but the character
representation is not, it should be:

    $1 = 57005 '["dead"]'

Same for Wide_Wide_Characters.

There were two issues:
   (a) The first issue was in ada-valprint, where we were assuming
       that character types were 1 byte long;
   (b) The second problem was in c-valprint, where we were down-casting
       the integer value of the character to type `unsigned char',
       causing use to lose all but the lowest byte.

gdb/ChangeLog:

        * ada-valprint. (ada_printchar): Use the correct type length
        in call to ada_emit_char.
        * c-valprint.c (c_val_print): Remove cast in call to LA_PRINT_CHAR.
@
text
@d420 1
a420 1
      LA_PRINT_CHAR ((unsigned char) val, type, stream);
d804 1
a804 2
		  ada_printchar ((unsigned char) unpack_long (type, valaddr),
				 type, stream);
@


1.73
log
@[Ada] Fix printing of Wide_Wide_Strings

This fixes the printing of Wide_Wide_String objects.  For instance,
consider:

    My_WWS : Wide_Wide_String := " helo";

Before this patch is applied, GDB prints:

    (gdb) print my_wws
    $1 = " ["00"]h["00"]e"

gdb/ChangeLog:

        * ada-valprint.c (ada_emit_char): Remove strange code.
        Check that c is <= UCHAR_MAX before passing it to isascii.
        (char_at): Do not assume that TYPE_LEN is either 1 or 2.
@
text
@d371 1
a371 1
  ada_emit_char (c, type, stream, '\'', 1);
@


1.72
log
@minor comment reformatting (ada-valprint.c:printstr)

Just to make the length of each line a little more balanced.

gdb/ChangeLog:

        * ada-valprint.c (printstr): Minor comment reformatting.
@
text
@d264 1
a264 1
   (1 or 2) of the character.  */
d270 7
a276 6
  if (type_len != 2)
    type_len = 1;

  c &= (1 << (type_len * TARGET_CHAR_BIT)) - 1;

  if (isascii (c) && isprint (c))
d287 2
a288 2
/* Character #I of STRING, given that TYPE_LEN is the size in bytes (1
   or 2) of a character.  */
d297 2
a298 1
    return (int) extract_unsigned_integer (string + 2 * i, 2, byte_order);
@


1.71
log
@2011-01-07  Michael Snyder  <msnyder@@vmware.com>

	* ada-lang.c: Comment cleanup, mostly periods and spaces.
	* ada-lang.h: Ditto.
	* ada-tasks.c: Ditto.
	* ada-valprint.c: Ditto.
	* aix-threads.c: Ditto.
	* alpha-linux-nat.c: Ditto.
	* alpha-linux-tdep.c: Ditto.
	* alpha-mdebug-tdep.c: Ditto.
	* alpha-nat.c: Ditto.
	* alpha-osf1-tdep.c: Ditto.
	* alpha-tdep.c: Ditto.
	* alphabsd-nat.c: Ditto.
	* alphabsd-tdep.c: Ditto.
	* amd64-darwin-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* amd64-sol2-tdep.c: Ditto.
	* amd64-tdep.c: Ditto.
	* amd64-fbsd-tdep.c: Ditto.
	* amd64-nbsd-tdep.c: Ditto.
	* amd64-obsd-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* arm-tdep.c: Ditto.
	* arm-tdep.h: Ditto.
	* armnbsd-nat.c: Ditto.
	* avr-tdep.c: Ditto.
	* bfin-tdep.c: Ditto.
	* bsd-kvm.c: Ditto.
	* c-typeprintc: Ditto.
	* c-valprint.c: Ditto.
	* coff-pe-read.h: Ditto.
	* coffreead.c: Ditto.
	* cris-tdep.c: Ditto.
	* d-lang.c: Ditto.
	* darwin-nat-info.c: Ditto.
	* darwin-nat.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* dcache.c: Ditto.
	* dcache.h: Ditto.
	* dec-thread.c: Ditto.
	* defs.h: Ditto.
	* demangle.c: Ditto.
	* dicos-tdep.c: Ditto.
	* dictionary.c: Ditto.
	* dictionary.h: Ditto.
	* dink32-rom.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dsrec.c: Ditto.
	* dummy-frame.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* environ.c: Ditto.
	* eval.c: Ditto.
	* event-top.h: Ditto.
	* exceptions.c: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-exp.y: Ditto.
	* f-lang.c: Ditto.
	* f-lang.h: Ditto.
	* f-typeprint.c: Ditto.
	* f-valprint.c: Ditto.
	* fbsd-nat.c: Ditto.
	* findvar.c: Ditto.
	* fork-child.c: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* frv-linux-tdep.c: Ditto.
	* frv-tdep.c: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_string.h: Ditto.
	* gdb_thread_db.h: Ditto.
	* gdb_wait.h: Ditto.
	* gdbarch.sh: Ditto.
	* gdbcore.h: Ditto.
	* gdbthread.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* gnu-nat.c: Ditto.
	* gnu-nat.h: Ditto.
	* gnu-v2-abi.c: Ditto.
	* gnu-v3-abi.c: Ditto.
	* go32-nat.c: Ditto.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
@
text
@d456 2
a457 2
   had to stop before printing LENGTH characters, or if
   FORCE_ELLIPSES.   TYPE_LEN is the length (1 or 2) of the character type.  */
@


1.70
log
@run copyright.sh for 2011.
@
text
@d299 1
a299 1
/* Wrapper around memcpy to make it legal argument to ui_file_put */
d457 1
a457 2
   FORCE_ELLIPSES.   TYPE_LEN is the length (1 or 2) of the character type.
 */
d551 3
a553 2
ada_printstr (struct ui_file *stream, struct type *type, const gdb_byte *string,
	      unsigned int length, const char *encoding, int force_ellipses,
d764 2
a765 1
				    address, stream, recurse, original_value, options);
d913 2
a914 1
		    const struct value_print_options *options, int comma_needed,
@


1.69
log
@[Ada] print null array pointer as `0x0' rather than `(null)'

Trying to print a variable defined as an access to an unconstrained
array:

       type String_Access is access String;
       S1 : String_Access;

If that variable is null, then GDB prints its value in an odd way:

    (gdb) print S1
    $1 = (string_bug.string_access) (null)
                                    ^^^^^^

This patch changes the debugger behavior to print the pointer using
the same output we'd use for any null pointer:

    (gdb) print S1
    $1 = (string_bug.string_access) 0x0

It also adds an assert, helping us verify an assumption.

gdb/ChangeLog:

        * ada-valprint.c (ada_val_print_1): Print null array pointers as
        `0x0' rather than `(null)'.  Add assertion.

gdb/testsuite/ChangeLog:

        * gdb.ada/arrayptr/foo.adb: Add new local variable Null_String.
        * gdb.ada/arrayptr.exp: Add test printing that new variable.
@
text
@d4 1
a4 1
   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
@


1.68
log
@[Ada] do not print arrays as array pointers

This patch enhances the debugger to distinguish between fat pointers
that represent either: array types, or array access types.  In the latter
case, the object/type is encoded as a typedef type pointing to the fat
pointer.

The first part of the change is to adjust ada_check_typedef to avoid
stripping the typedef layer when it points to a fat pointer.  The rest
of the patch is adjustments required in various places to deal with
the fact that the type is uses might now be a typedef.

gdb/ChangeLog:

        * ada-lang.h (ada_coerce_to_simple_array): Add declaration.
        * ada-lang.c (ada_typedef_target_type): New function.
        (desc_base_type): Add handling of fat pointer typedefs.
        (ada_coerce_to_simple_array): Make non-static.
        (decode_packed_array_bitsize): Add handling of fat pointer typedefs.
        Add assertion.
        (ada_template_to_fixed_record_type_1, ada_to_fixed_type)
        (ada_check_typedef): Add handling of fat pointer typedefs.
        (ada_evaluate_subexp) [OP_FUNCALL]: Likewise.
        * ada-typeprint.c (ada_print_type): Add handling of fat pointer
        typedefs.
        * ada-valprint.c (ada_val_print_1): Convert fat pointers that are not
        array accesses to simple arrays rather than simple array pointers.
        (ada_value_print): In the case of array descriptors, do not print
        the value type description unless it is an array access.

gdb/testsuite/ChangeLog:

        * gdb.ada/lang_switch.exp: Correct expected parameter value.

gdb/doc/ChangeLog:

        * gdb.texinfo (Ada Glitches): Remove paragraph describing the
        occasional case where the debugger prints an array address
        instead of the array itself.
@
text
@d693 2
a694 1
	  fprintf_filtered (stream, "(null)");
@


1.67
log
@[Ada] move some variables to scope where they are used

I noticed that some variables are only used inside one side of
an if/else blob. So I moved these variables inside that block for
better clarity.

gdb/ChangeLog:

        * ada-valprint.c (ada_val_print_array): Move variables `eltlen'
        and `len' declaration and computation inside block where they
        are being used.
@
text
@d687 4
a690 1
      val = ada_coerce_to_simple_array_ptr (val);
d953 9
a961 3
      fprintf_filtered (stream, "(");
      type_print (type, "", stream, -1);
      fprintf_filtered (stream, ") ");
@


1.66
log
@gdb
	PR gdb/9977, PR exp/11636:
	* value.h (value_offset): Update.
	(struct lval_funcs) <check_validity>: New field.
	<copy_closure>: Make argument const.
	(value_computed_closure): Update.
	(value_contents_for_printing): Declare.
	(value_bits_valid): Likewise.
	(val_print): Likewise.
	(set_value_component_location): Update.
	(value_entirely_optimized_out): Declare.
	* value.c (value_offset): Argument now const.
	(require_not_optimized_out): New function.
	(value_contents_for_printing): New function.
	(value_contents_all): Call require_not_optimized_out.
	(value_contents): Likewise.
	(value_bits_valid): New function.
	(value_computed_closure): Argument now const.
	(set_value_component_location): Make 'whole' argument const.
	(value_entirely_optimized_out): New function.
	(value_bitsize): Argument now 'const'.
	(value_bitpos): Likewise.
	(value_type): Likewise.
	* valprint.h (val_print_array_elements): Update.
	* valprint.c (val_print): Add 'val' argument.  Use
	valprint_check_validity.
	(valprint_check_validity): New function.
	(value_check_printable): Use value_entirely_optimized_out.
	(common_val_print): Update.
	(value_print): Likewise.
	(val_print_array_elements): Add 'val' argument.
	* valops.c (value_fetch_lazy): Use value_contents_for_printing,
	value_bits_valid.  Reinit frame cache for lval_computed.
	* sh64-tdep.c (sh64_do_register): Update.
	* scm-valprint.c (scm_val_print): Add 'val' argument.
	* scm-lang.h (scm_val_print): Update.
	* python/python.h (apply_val_pretty_printer): Update.
	* python/py-prettyprint.c (apply_val_pretty_printer): Add 'val'
	argument.  Call set_value_component_location.
	* printcmd.c (print_scalar_formatted): Update.
	* p-valprint.c (pascal_val_print): Add 'val' argument.
	(pascal_object_print_value_fields): Likewise.
	(pascal_object_print_value): Likewise.
	(pascal_object_print_static_field): Update.
	* p-lang.h (pascal_val_print): Update.
	(pascal_object_print_value_fields): Update.
	* mt-tdep.c (mt_registers_info): Update.
	* mi/mi-main.c (get_register): Update.
	(mi_cmd_data_evaluate_expression): Use common_val_print.
	* m2-valprint.c (m2_print_array_contents): Add 'val' argument.
	(m2_print_unbounded_array): Likewise.
	(m2_val_print): Likewise.
	* m2-lang.h (m2_val_print): Update.
	* language.h (struct language_defn) <la_val_print>: Add 'val'
	argument.
	(LA_VAL_PRINT): Likewise.
	* language.c (unk_lang_val_print): Add 'val' argument.
	* jv-valprint.c (java_print_value_fields): Add 'val' argument.
	(java_val_print): Likewise.
	* jv-lang.h (java_val_print): Add 'val' argument.
	* infcmd.c (default_print_registers_info): Update.
	* f-valprint.c (f77_print_array_1): Add 'val' argument.
	(f77_print_array): Likewise.
	(f_val_print): Likewise.
	* f-lang.h (f_val_print): Add 'val' argument.
	* dwarf2loc.c (read_pieced_value): Use value_bitsize and
	value_bitpos.
	<DWARF_VALUE_OPTIMIZED_OUT>: Don't print warning.  Call
	set_value_optimized_out.
	(write_pieced_value): Use value_bitsize and value_bitpos.
	<default>: Don't exit loop.
	(check_pieced_value_validity): New function.
	(pieced_value_funcs): Reference check_pieced_value_validity,
	check_pieced_value_invalid.
	(copy_pieced_value_closure): Update.
	(check_pieced_value_bits): New function.
	(check_pieced_value_invalid): New function.
	* d-valprint.c (dynamic_array_type): Add 'val' argument.
	(d_val_print): Likewise.
	* d-lang.h (d_val_print): Update.
	* cp-valprint.c (cp_print_value_fields): Add 'val' argument.
	(cp_print_value_fields_rtti): Likewise.
	(cp_print_value): Likewise.
	(cp_print_static_field): Update.
	* c-valprint.c (c_val_print): Add 'val' argument.
	(c_value_print): Update.
	* c-lang.h (c_val_print): Update.
	(cp_print_value_fields): Likewise.
	(cp_print_value_fields_rtti): Likewise.
	* ada-valprint.c (struct ada_val_print_args): Remove.
	(val_print_packed_array_elements): Add 'val' argument.
	(ada_val_print): Likewise.  Rewrite.
	(ada_val_print_stub): Remove.
	(ada_val_print_array): Add 'val' argument.
	(ada_val_print_1): Likewise.
	(print_variant_part): Likewise.
	(ada_value_print): Update.
	(print_record): Add 'val' argument.
	(print_field_values): Likewise.
	* ada-lang.h (ada_val_print): Update.
gdb/testsuite
	PR gdb/9977, PR exp/11636::
	* gdb.dwarf2/pieces.exp (pieces_test_f3): Remove kfail.
	(pieces_test_f6): Update expected output.
@
text
@a605 2
  unsigned int eltlen;
  unsigned int len;
a607 9
  if (elttype == NULL)
    eltlen = 0;
  else
    eltlen = TYPE_LENGTH (elttype);
  if (eltlen == 0)
    len = 0;
  else
    len = TYPE_LENGTH (type) / eltlen;

d612 12
@


1.66.2.1
log
@[Ada] Fix printing of Wide_Wide_Strings

This fixes the printing of Wide_Wide_String objects.  For instance,
consider:

    My_WWS : Wide_Wide_String := " helo";

Before this patch is applied, GDB prints:

    (gdb) print my_wws
    $1 = " ["00"]h["00"]e"

gdb/ChangeLog:

        * ada-valprint.c (ada_emit_char): Remove strange code.
        Check that c is <= UCHAR_MAX before passing it to isascii.
        (char_at): Do not assume that TYPE_LEN is either 1 or 2.
@
text
@d264 1
a264 1
   of the character.  */
d270 6
a275 7
  /* If this character fits in the normal ASCII range, and is
     a printable character, then print the character as if it was
     an ASCII character, even if this is a wide character.
     The UCHAR_MAX check is necessary because the isascii function
     requires that its argument have a value of an unsigned char,
     or EOF (EOF is obviously not printable).  */
  if (c <= UCHAR_MAX && isascii (c) && isprint (c))
d286 2
a287 2
/* Character #I of STRING, given that TYPE_LEN is the size in bytes
   of a character.  */
d296 1
a296 2
    return (int) extract_unsigned_integer (string + type_len * i,
                                           type_len, byte_order);
@


1.66.2.2
log
@Fix printing of Wide_Character & Wide_Wide_Character entities.

Wide_Characters and Wide_Wide_Characters are incorrectly printed.
Consider for instance:

    Medium : Wide_Character := Wide_Character'Val(16#dead#);

Trying to print the value of this variable yields:

    (gdb) p medium
    $1 = 57005 '["ad"]'

The integer value is correct (57005 = 0xdead), but the character
representation is not, it should be:

    $1 = 57005 '["dead"]'

Same for Wide_Wide_Characters.

There were two issues:
   (a) The first issue was in ada-valprint, where we were assuming
       that character types were 1 byte long;
   (b) The second problem was in c-valprint, where we were down-casting
       the integer value of the character to type `unsigned char',
       causing use to lose all but the lowest byte.

gdb/ChangeLog:

        * ada-valprint. (ada_printchar): Use the correct type length
        in call to ada_emit_char.
        * c-valprint.c (c_val_print): Remove cast in call to LA_PRINT_CHAR.
@
text
@d371 1
a371 1
  ada_emit_char (c, type, stream, '\'', TYPE_LENGTH (type));
@


1.66.2.3
log
@fix printing of Ada wide characters on ppc-aix

Same problem as before: We were downcasting the character value from
int to unsigned char, which caused an overflow.  The reason why we did
not see this problem before is probably related to the fact that
we're using stabs on AIX and thus characters types are defined as
a TYPE_CODE_INT (or TYPE_CODE_RANGE?).

gdb/ChangeLog:

        * ada-valprint.c (ada_print_scalar): Remove unsigned char downcast.
        (ada_val_print_1): Likewise.
@
text
@d420 1
a420 1
      LA_PRINT_CHAR (val, type, stream);
d798 2
a799 1
		  ada_printchar (unpack_long (type, valaddr), type, stream);
@


1.65
log
@	* valprint.h (get_array_bounds): Change low and high parameter types
	to LONGEST *.
	* valprint.c (get_array_bounds): Use get_discrete_bounds call to
	compute bounds.
	(val_print_array_elements): Adapt to change above.
	* ada-valprint.c (print_optional_low_bound): Adapt to change above.
	* p-valprint.c (pascal_val_print): Likewise.
@
text
@a38 12
/* Encapsulates arguments to ada_val_print.  */
struct ada_val_print_args
{
  struct type *type;
  const gdb_byte *valaddr0;
  int embedded_offset;
  CORE_ADDR address;
  struct ui_file *stream;
  int recurse;
  const struct value_print_options *options;
};

d40 3
a42 1
			  int, const struct value_print_options *);
d46 1
a52 2
static int ada_val_print_stub (void *args0);

d55 1
d139 1
d211 1
a211 1
		     recurse + 1, &opts, current_language);
d241 1
a241 1
			 recurse + 1, &opts, current_language);
d575 1
d578 2
a579 8
  struct ada_val_print_args args;
  args.type = type;
  args.valaddr0 = valaddr0;
  args.embedded_offset = embedded_offset;
  args.address = address;
  args.stream = stream;
  args.recurse = recurse;
  args.options = options;
d581 5
a585 2
  return catch_errors (ada_val_print_stub, &args, NULL, RETURN_MASK_ALL);
}
d587 2
a588 6
/* Helper for ada_val_print; used as argument to catch_errors to
   unmarshal the arguments to ada_val_print_1, which does the work.  */
static int
ada_val_print_stub (void *args0)
{
  struct ada_val_print_args *argsp = (struct ada_val_print_args *) args0;
d590 1
a590 3
  return ada_val_print_1 (argsp->type, argsp->valaddr0,
			  argsp->embedded_offset, argsp->address,
			  argsp->stream, argsp->recurse, argsp->options);
d601 1
d650 1
a650 1
                                         recurse, options);
d653 1
a653 1
                                  recurse, options, 0);
d667 1
d694 2
a695 1
				value_address (val), stream, recurse, options);
d708 1
a708 1
			  recurse, options);
d713 1
a713 1
			       stream, recurse, options);
d754 1
a754 1
				      stream, recurse + 1, options);
d759 1
a759 1
				    address, stream, recurse, options);
d844 1
a844 1
			    recurse, options);
d858 2
a859 1
	  print_record (type, valaddr, stream, recurse, options);
d865 1
a865 1
				  recurse, options);
d889 1
a889 1
			 options, current_language);
d906 1
d920 1
a920 1
       stream, recurse, options,
d964 1
a964 1
		     stream, 0, &opts, current_language));
d970 1
d977 1
a977 1
  if (print_field_values (type, valaddr, stream, recurse, options,
d1004 1
d1024 1
a1024 1
				stream, recurse, options,
d1032 1
a1032 1
				stream, recurse, options, comma_needed,
d1099 2
a1100 1
			 stream, recurse + 1, &opts, current_language);
d1110 1
a1110 1
			 0, 0, stream, recurse + 1, &opts);
@


1.64
log
@2010-05-18  Michael Snyder  <msnyder@@vmware.com>

	* ada-lang.c: White space.
	* ada-typeprint.c: White space.
	* ada-valprint.c: White space.
	* addrmap.c: White space.
	* auxv.c: White space.
	* ax-gdb.c: White space.
@
text
@d88 2
a89 2
  long low_bound;
  long high_bound;
d134 1
a134 1
  ada_print_scalar (index_type, (LONGEST) low_bound, stream);
@


1.63
log
@2010-05-06  Michael Snyder  <msnyder@@vmware.com>

	* p-typeprint.c (pascal_type_print_base): Delete unused variable.
	(pascal_type_print_varspec_prefix): Delete unused variable.
	* f-typeprint.c (f_type_print_base): Delete unused variable.
	(f_type_print_varspec_suffix): Delete unused variable.
	* m2-typeprint.c (m2_print_type): Delete unused variable.
	(m2_long_set): Delete unused variable.
	* ada-valprint.c (ada_val_print_1): Delete unused variable.
	* d-valprint.c (dynamic_array_type): Delete unused variable.
	* f-valprint.c (f77_get_dynamic_length_of_aggregate):
	Delete unused variable.
	(f77_create_arrayprint_offset_tbl): Delete unused variable.
	* m2-valprint.c (m2_val_print): Delete unused variable.
@
text
@d166 1
d217 1
d230 1
d604 1
d699 1
d728 1
d734 1
d756 1
d766 1
d779 1
d783 1
d836 1
d891 1
d898 1
d1115 1
@


1.62
log
@Wrong value printed by info locals for dynamic object.

The problem is printing the wrong value for dynamic local variables
when using the "info locals" command. Consider the following code:

   procedure Print (I1 : Positive; I2 : Positive) is
      type My_String is array (I1 .. I2) of Character;
      I : My_String := (others => 'A');
      S : String (1 .. I2 + 3) := (others => ' ');
   begin
      S (I1 .. I2) := String (I); --  BREAK
      Put_Line (S);
   end Print;

After the debugger stopped at BREAK, we try printing all local variables.
Here is what we get:

        (gdb) info locals
        i = "["00"]["00"]"
        s = "["00"]["00"]["00"]["00"]["00"]["00"]["00"]["00"]"

Curiously, printing their value using the "print" command works:

        (gdb) print i
        $1 = "AA"
        (gdb) print s
        $2 = "        "

We traced the problem to trying to get the contents of a variable
(call to value_contents) before "fix'ing" it.  For those not familiar
with the Ada language support, "fixing" a value consists of swapping
the value's dynamic type with a static version that is appropriate
for our actual value.  As a result, the dynamic type was used to
determine the value size, which is zero, and thus the value contents
was empty.

gdb/ChangeLog:

        * valprint.c (common_val_print): Fix the value before extracting
        its contents.
        * ada-lang.c (ada_to_fixed_value): Make this function extern.
        * ada-lang.h (ada_to_fixed_value): New function declaration.
        * ada-valprint.c (ada_value_print): Use ada_to_fixed_value
        to avoid code duplication and fix a bug in the handling of
        fixed types contents.

gdb/testsuite/ChangeLog:

        * gdb.ada/dyn_loc: New testcase.
@
text
@a683 1
  unsigned int eltlen;
@


1.61
log
@2010-01-13  Phil Muldoon  <pmuldoon@@redhat.com>

	PR python/10705

	* python/python-internal.h: Add lazy_string_object_type
	definition.
	(create_lazy_string_object, gdbpy_initialize_lazy_string)
	(gdbpy_is_lazystring, gdbpy_extract_lazy_string): Define.
	* python/py-value.c (valpy_lazy_string): New function.
	(convert_value_from_python): Add lazy string conversion.
	* python/py-prettyprint.c (pretty_print_one_value): Check if
	return is also a lazy string.
	(print_string_repr): Add lazy string printing branch.
	(print_children): Likewise.
	* python/py-lazy-string.c: New file. Implement lazy strings.
	* python/python.c (_initialize_python): Call
	gdbpy_initialize_lazy_string.
	* varobj.c (value_get_print_value): Add lazy string printing
	branch.  Account for encoding.
	* c-lang.c (c_printstr): Account for new encoding argument.  If
	encoding is NULL, find encoding suited for type, otherwise use
	user encoding.
	* language.h (language_defn): Add encoding argument.
	(LA_PRINT_STRING): Likewise.
	* language.c (unk_lang_printstr): Update to reflect new encoding
	argument to language_defn.
	* ada-lang.h (ada_printstr): Likewise.
	* c-lang.h (c_printstr): Likewise.
	* p-lang.h (pascal_printstr);
	* f-lang.c (f_printstr): Likewise.
	* m2-lang.c (m2_printstr): Likewise.
	* objc-lang.c (objc_printstr): Likewise.
	* p-lang.c (pascal_printstr): Likewise.
	* scm-lang.c (scm_printstr): Likewise.
	* c-valprint.c (c_val_print): Update LA_PRINT_STRING call for
	encoding argument.
	* ada-valprint.c (ada_printstr): Likewise.
	* f-valprint.c (f_val_print): Likewise
	* m2-valprint.c (m2_val_print): Likewise.
	* p-valprint.c (pascal_val_print): Likewise.
	* expprint.c (print_subexp_standard): Likewise.
	* valprint.c (val_print_string): Likewise.
	* Makefile.in (SUBDIR_PYTHON_OBS): Add py-lazy-string.
	(SUBDIR_PYTHON_SRCS): Likewise.
	(py-lazy-string.o): New rule.

2010-01-13  Phil Muldoon  <pmuldoon@@redhat.com>

	* gdb.texinfo (Values From Inferior): Document lazy_string value
	method.
	(Python API): Add Lazy strings menu item.
	(Lazy Strings In Python): New node.

2010-01-13  Phil Muldoon  <pmuldoon@@redhat.com>

	* gdb.python/py-value.exp (test_lazy_strings): Add lazy string test.
	* gdb.python/py-prettyprint.py (pp_ls): New printer.
	* gdb.python/py-prettyprint.exp (run_lang_tests): Add lazy string
	test.
	* gdb.python/py-prettyprint.c: Define lazystring test structure.
	* gdb.python/py-mi.exp: Add lazy string test.
@
text
@d927 3
a929 6
  const gdb_byte *valaddr = value_contents (val0);
  CORE_ADDR address = value_address (val0);
  struct type *type =
    ada_to_fixed_type (value_type (val0), valaddr, address, NULL, 1);
  struct value *val =
    value_from_contents_and_address (type, valaddr, address);
@


1.60
log
@        * ada-valprint.c (ada_print_floating): Remove trailing space.
@
text
@d559 1
a559 1
	      unsigned int length, int force_ellipses,
@


1.59
log
@gdb/ChangeLog:

        Add support for DW_AT_GNAT_descriptive_type.
        * gdbtypes.h (enum type_specific_kind): New enum.
        (struct main_type) [type_specific_field]: New component.
        [type_specific]: Add new component "gnat_stuff".
        (struct gnat_aux_type): New type.
        (INIT_CPLUS_SPECIFIC): Also set TYPE_SPECIFIC_FIELD (type).
        (HAVE_CPLUS_STRUCT): Also check TYPE_SPECIFIC_FIELD (type).
        (gnat_aux_default, allocate_gnat_aux_type): Add declaration.
        (INIT_GNAT_SPECIFIC, ALLOCATE_GNAT_AUX_TYPE, HAVE_GNAT_AUX_INFO)
        (TYPE_SPECIFIC_FIELD): New macros.
        (TYPE_CPLUS_SPECIFIC): Return cplus_struct_default if the given
        type does not hold any cplus-specific data.
        (TYPE_RAW_CPLUS_SPECIFIC): New macro.
        (TYPE_GNAT_SPECIFIC, TYPE_DESCRIPTIVE_TYPE): New macros.
        (TYPE_IS_OPAQUE): Use HAVE_CPLUS_STRUCT to check if type has
        cplus-specific data.
        * gdbtypes.c (allocate_cplus_struct_type): Minor stylistic rewrite.
        Set new component TYPE_SPECIFIC_FIELD (type).
        (gnat_aux_default): New constant.
        (allocate_gnat_aux_type): New function.
        (init_type): Add initialization the type-specific stuff for
        TYPE_CODE_FLT and TYPE_CODE_FUNC types.
        (print_gnat_stuff): New function.
        (recursive_dump_type): Use HAVE_CPLUS_STRUCT to check for cplus-
        specific data.  Adjust code that prints the contents of the
        type-specific union using the TYPE_SPECIFIC_FIELD value.
        * dwarf2read.c (dwarf2_attach_fields_to_type): Do not allocate
        the type cplus stuff for Ada types.
        (dwarf2_add_member_fn, dwarf2_attach_fn_fields_to_type):
        Error out if these routines are called with an Ada type.
        (read_structure_type, read_array_type, read_subrange_type):
        Add call to set_descriptive_type.
        (set_die_type): Initialize the gnat-specific data if necessary.
        (need_gnat_info, die_descriptive_type, set_descriptive_type):
        New functions.
        * ada-lang.c (decode_constrained_packed_array_type): Use
        decode_constrained_packed_array_type instead of doing a standard
        lookup to locate a parallel type.
        (find_parallel_type_by_descriptive_type): New function.
        (ada_find_parallel_type_with_name): New function.
        (ada_find_parallel_type): Reimplement using
        ada_find_parallel_type_with_name.
        * ada-valprint.c (print_field_values): Use HAVE_CPLUS_STRUCT
        to check if type has a cplus stuff.
        * linespec.c (total_number_of_methods): Likewise.
        * mdebugread.c (new_type): Likewise.

gdb/testsuite/ChangeLog:

        * gdb.base/maint.exp: Adjust the expected output for the
        "maint print type" test. Use gdb_test_multiple instead of
        gdb_sent/gdb_expect.
@
text
@d335 1
a335 1
  
@


1.58
log
@        * ada-valprint.c, parse.c: Include defs.h before including ctype.h.
@
text
@d1080 1
a1080 2
	  if (TYPE_CPLUS_SPECIFIC (type) != NULL
	      && TYPE_FIELD_IGNORE (type, i))
@


1.57
log
@Get rid of support for VAX Floats.

        * ada-lang.h (ada_is_vax_floating_type, ada_vax_float_type_suffix)
        (ada_vax_float_print_function): Delete.
        * ada-lang.c (ada_is_vax_floating_type, ada_vax_float_type_suffix)
        (ada_vax_float_print_function): Delete.
        * ada-typeprint.c (print_vax_floating_point_type): Delete.
        (ada_print_type): Remove support for VAX floats.
        * ada-valprint.c (ada_val_print_1): Remove support for VAX floats.
@
text
@d22 1
a23 1
#include "defs.h"
@


1.56
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@a746 16
      else if (ada_is_vax_floating_type (type))
	{
	  struct value *val =
	    value_from_contents_and_address (type, valaddr, address);
	  struct value *func = ada_vax_float_print_function (type);
	  if (func != 0)
	    {
	      struct gdbarch *gdbarch = get_type_arch (type);
	      CORE_ADDR addr;
	      addr = value_as_address (call_function_by_hand (func, 1, &val));
	      val_print_string (builtin_type (gdbarch)->builtin_true_char,
				addr, -1, stream, options);
	      return 0;
	    }
	  /* No special printing function.  Do as best we can.  */
	}
@


1.55
log
@        * ada-lang.c (packed_array_type): Rename to...
        (constrained_packed_array_type): ...and update comment.
        (decode_packed_array, decode_constrained_packed_array): Ditto.
        (decode_packed_array_type, decode_constrained_packed_array_type):
        Ditto.
        (ada_is_constrained_packed_array_type): New function.
        (ada_is_unconstrained_packed_array_type): New function.
        (decode_packed_array_bitsize): New function, extracted from
        decode_packed_array_type.
        (ada_type_of_array): Add support for unconstrained packed arrays.
        (ada_coerce_to_simple_array_ptr, ada_coerce_to_simple_array)
        (ada_array_bound_from_type, ada_array_bound, ada_array_length)
        (ada_prefer_type, to_fixed_array_type, ada_evaluate_subexp): Resync.
        * ada-lang.h (ada_is_packed_array_type,
        ada_is_constrained_packed_array_type): Renaming.
        * ada-valprint.c (ada_val_print_1): Resync.
        * ada-typeprint.c (print_array_type, ada_print_type): Resync.
@
text
@d4 2
a5 1
   2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.54
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d689 2
a690 1
  if (ada_is_array_descriptor_type (type) || ada_is_packed_array_type (type))
@


1.53
log
@	* defs.h (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter.
	* utils.c (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter, use it instead of current_gdbarch.
	* ui-out.h (ui_out_field_core_addr): Add GDBARCH parameter.
	* ui-out.c (ui_out_field_core_addr): Add GDBARCH parameter,
	use it instead of current_gdbarch.

	Update calls to ui_out_field_core_addr to pass architecture:
	* ada-lang.c (print_one_exception): Update.
	* breakpoint.c (print_one_breakpoint_location,
	print_one_exception_catchpoint): Update.
	* disasm.c (dump_insns): Update.
	* darwin-nat-info.c (darwin_debug_regions_recurse): Update.
	* mi/mi-main.c (mi_cmd_data_read_memory): Update.
	* mi/mi-symbol-cmds.c: Include "objfiles.h".
	(mi_cmd_symbol_list_lines): Update.
	* stack.c (print_frame_info, print_frame): Update.

	Update callers of paddress to pass architecture:
	* ada-tasks.c (info_task): Update.
	* ada-valprint.c (ada_val_print_1): Update.
	* annotate.c (annotate_source, annotate_frame_begin): Update.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints,
	mention): Update.
	* cli/cli-cmds.c (edit_command, list_command, print_disassembly):
	Update.
	* corefile.c (memory_error): Update.
	* c-valprint.c (print_function_pointer_address, c_val_print): Update.
	* disasm.c (dis_asm_print_address): Update.
	* exec.c (print_section_info): Update.
	* f-valprint.c (f_val_print): Update.
	* infcmd.c: Include "arch-utils.h".
	(jump_command, program_info): Update.
	* linux-fork.c: Include "arch-utils.h".
	(info_forks_command): Update.
	* m2-valprint.c (print_function_pointer_address,
	print_unpacked_pointer, print_variable_at_address,
	m2_val_print): Update.
	* m32r-rom.c (m32r_load_section, m32r_load, m32r_upload_command):
	Update.
	* printcmd.c (print_address, print_address_demangle, address_info):
	Update.
	* p-valprint.c (pascal_val_print): Update.
	* source.c: Include "arch-utils.h".
	(line_info): Update.
	* stack.c (frame_info, print_block_frame_labels): Update.
	* symfile.c (add_symbol_file_command, list_overlays_command): Update.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1,
	print_symbol, print_partial_symbols, maintenance_info_psymtabs,
	maintenance_check_symtabs): Update.
	* symtab.c (find_pc_sect_symtab): Update.
	* target.c (deprecated_debug_xfer_memory): Update.
	* tracepoint.c (scope_info): Update.
	* tui/tui-stack.c (tui_make_status_line): Update.
	* valprint.c (val_print_string): Update.

	Update callers of paddr_nz to use paddress instead (keeping
	user-visible output identical):
	* alpha-tdep.c (alpha_heuristic_proc_start): Update.
	* amd64-tdep.c (fixup_riprel, amd64_displaced_step_copy_insn,
	amd64_displaced_step_fixup): Update.
	* arch-utils.c (simple_displaced_step_copy_insn): Update.
	* auxv.c (fprint_target_auxv): Update.
	* breakpoint.c (insert_single_step_breakpoint): Update.
	* buildsym.c (finish_block): Update.
	* cli/cli-dump.c (restore_section_callback): Update.
	* fbsd-nat.c (fbsd_find_memory_regions): Update.
	* frame.c (frame_unwind_register_value): Update.
	* gcore.c (gcore_create_callback): Update.
	* hppa-tdep.c (hppa_frame_cache, hppa_skip_trampoline_code): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_record_modrm,
	i386_record_lea_modrm_addr, i386_record_lea_modrm,
	i386_process_record): Update.
	* ia64-tdep.c (ia64_frame_this_id, ia64_sigtramp_frame_this_id,
	ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id,
	ia64_dummy_id, ia64_access_reg, ia64_access_rse_reg): Update.
	* infrun.c (displaced_step_prepare, displaced_step_fixup,
	handle_inferior_event, insert_step_resume_breakpoint_at_sal,
	insert_longjmp_resume_breakpoint): Update.
	* linux-nat.c (linux_nat_find_memory_regions): Update.
	* linux-record.c (record_linux_system_call): Update.
	* mips-tdep.c (heuristic_proc_start, mips_eabi_push_dummy_call,
	mips_n32n64_push_dummy_call, mips_o32_push_dummy_call,
	mips_o64_push_dummy_call): Update.
	* monitor.c (monitor_error, monitor_remove_breakpoint): Update.
	* record.c (record_arch_list_add_mem, record_wait,
	record_xfer_partial): Update.
	* remote-mips.c (mips_fetch_word, mips_check_lsi_error,
	mips_common_breakpoint): Update.
	* remote-sim.c (gdbsim_xfer_inferior_memory): Update.
	* rs6000-tdep.c (ppc_displaced_step_fixup): Update.
	* solib-som.c (som_current_sos): Update.
	* symfile.c (load_progress, generic_load): Update.
	* symfile-mem.c (add_vsyscall_page): Update.
	* valops.c (value_fetch_lazy): Update.
	* windows-tdep.c (windows_xfer_shared_library): Update.

	Update callers of paddr_nz to use paddress instead (changing
	user-visible output to make it more correct):
	* dwarf2loc.c (locexpr_describe_location): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint,
	ia64_memory_remove_breakpoint): Update.
	* jv-valprint.c (java_value_print): Update.
	* m32c-tdep.c (m32c_m16c_address_to_pointer): Update.
	* monitor.c (monitor_read_memory): Update.

	Update callers of paddr to use paddress instead (changing
	user-visible output to make it more correct):
	* arm-tdep.c (arm_push_dummy_call): Update.
	* breakpoint.c (insert_bp_location, create_thread_event_breakpoint,
	create_breakpoint): Update.
	* darwin-nat-info.c (darwin_debug_regions): Update.
	* dcache.c (dcache_info): Update.
	* dsrec.c (load_srec, make_srec): Update.
	* dwarf2-frame.c (dwarf2_restore_rule, execute_cfa_program,
	dwarf2_frame_cache): Update.
	* gcore.c (gcore_copy_callback): Update.
	* gnu-nat.c (gnu_xfer_memory): Update.
	* mips-linux-nat.c (mips_show_dr): Update.
	* monitor.c (monitor_write_memory, monitor_insert_breakpoint,
	monitor_remove_breakpoint): Update.
	* remote.c (compare_sections_command): Update.
	* remote-m32r-sdi.c (m32r_xfer_memory, m32r_insert_breakpoint,
	m32r_remove_breakpoint, m32r_insert_watchpoint,
	m32r_remove_watchpoint): Update.
	* sol-thread.c (info_cb): Update.
	* symfile.c (load_progress): Update.

	Update callers of paddress or paddr_nz to use hex_string instead
	(changes output of internal/error/debug messages only):
	* dwarf2read.c (dump_die_shallow): Update.
	* frame.c (fprint_field, fprint_frame, frame_pc_unwind,
	get_frame_func, create_new_frame): Update.
	* hppa-tdep.c (find_unwind_entry, unwind_command): Update.
	* ia64-tdep.c (get_kernel_table, ia64_find_proc_info_x,
	ia64_get_dyn_info_list): Update.
	* maint.c (maintenance_translate_address): Update.
	* mi/mi-cmd-var.c (mi_cmd_var_create): Update.
	* target.c (target_flash_erase): Update.

	Update callers of paddr/paddr_nz to use phex/phex_nz instead,
	using an appropriate address size.  Remove use of strlen_paddr.
	* exec.c (exec_files_info): Update.
	* i386-nat.c (i386_show_dr): Update.
	* remote.c (remote_flash_erase): Update.
	* m32r-rom.c (m32r_load_section): Update.
	* monitor.c (monitor_vsprintf, monitor_store_register): Update.
	* remote.c (remote_check_symbols, remote_search_memory): Update.
	* remote-mips.c (mips_request, mips_common_breakpoint): Update.
	* scm-valprint.c (scm_ipruk, scm_scmval_print): Update.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Update.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs,
	sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs,
	sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs,
	sh_dsp_show_regs): Update.
	* xcoffsolib.c (sharedlibrary_command): Update.


	* maint.c (maint_print_section_info): Add ADDR_SIZE parameter.
	Use hex_string_custom instead of paddr.
	(print_bfd_section_info): Pass address size.
	(print_objfile_section_info): Likewise.

	* annotate.h (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* annotate.c (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* source.c (identify_source_line): Update call to annotate_source.
	* stack.c (print_frame_info, print_frame): Update call to
	annotate_frame_begin.

	* breakpoint.c (describe_other_breakpoints): Add GDBARCH parameter.
	(create_breakpoint, create_ada_exception_breakpoint): Update call.

	* stack.c (print_block_frame_labels): Add GDBARCH parameter.
	(print_frame_label_vars): Update call.

	* symmisc.c (print_partial_symbols): Add GDBARCH parameter.
	(dump_psymtab): Update call to print_partial_symbols.
	(struct print_symbol_args): Add GDBARCH member.
	(dump_symtab_1): Set print_symbol_args architecture member.
	(print_symbol): Use it.

	* windows-tdep.h (windows_xfer_shared_library): Add GDBARCH
	parameter.
	* windows-tdep.c (windows_xfer_shared_library): Likewise.
	* i386-cygwin-tdep.c (struct cpms_data): Add GDBARCH member.
	(core_process_module_section): Pass architecture from cpms_data to
	windows_xfer_shared_library.
	(windows_core_xfer_shared_libraries): Initialize cmps_data
	architecture member.
	* windows-nat.c (windows_xfer_shared_libraries): Pass architecture
	to windows_xfer_shared_library.

	* defs.h (print_address): Add GDBARCH parameter.
	* printcmd.c (print_address): Add GDBARCH parameter.
	(print_scalar_formatted, do_examine): Update call.
	* findcmd.c (find_command): Update call.
	* tracepoint.c: Include "arch-utils.h".
	(trace_find_line_command): Update call.
	* tui/tui-disasm.c (tui_disassemble): Update call.

	* value.h (print_address_demangle): Add GDBARCH parameter.
	* printcmd.c (print_address_demangle): Add GDBARCH parameter.
	* c-valprint.c (print_function_pointer_address, c_val_print):
	Update call.
	* f-valprint.c (f_val_print): Update call.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update call.
	* jv-valprint.c (java_val_print): Update call.
	* m2-valprint.c (print_function_pointer_address, m2_val_print):
	Update call.
	* p-valprint.c (pascal_val_print): Update call.

	* disasm.c (gdb_disassemble_info): Install architecture into
	di.application_data field.

testsuite/ChangeLog:

	* gdb.threads/tls-shared.exp: Update to locexpr_describe_location
	change to prefix TLS offset in hex with 0x.

doc/ChangeLog:

	* gdbint.texinfo (Item Output Functions): Update signature
	for ui_out_field_core_addr.
@
text
@d295 2
a296 1
char_at (const gdb_byte *string, int i, int type_len)
d301 1
a301 1
    return (int) extract_unsigned_integer (string + 2 * i, 2);
d470 1
d501 2
a502 2
	     && char_at (string, rep1, type_len) == char_at (string, i,
							     type_len))
d519 2
a520 2
	  ada_emit_char (char_at (string, i, type_len), elttype, stream, '\'',
			 type_len);
d537 2
a538 2
	  ada_emit_char (char_at (string, i, type_len), elttype, stream, '"',
			 type_len);
d615 1
d647 1
a647 1
                && char_at (valaddr, temp_len, eltlen) != 0);
@


1.52
log
@	* gdbtypes.c (make_pointer_type, make_reference_type,
	smash_to_memberptr_type, lookup_array_range_type, check_stub_method):
	Use type architecture instead of current_gdbarch.

	* gdbtypes.h (address_space_name_to_int, address_space_int_to_name):
	Add GDBARCH paramter.
	* gdbtypes.c (address_space_name_to_int, address_space_int_to_name):
	Add GDBARCH parameter.   Use it instead of current_gdbarch.
	* c-typeprint.c (c_type_print_modifier): Update call.
	* parse.c (push_type_address_space): Likewise.

	* findvar.c (extract_typed_address, store_typed_address): Use type
	architecture instead of current_gdbarch.

	* value.c (value_as_address, unpack_field_as_long): Use type architecture
	instead of current_gdbarch.

	* doublest.c (floatformat_from_length): Add GDBARCH argument.  Use it
	instead of current_gdbarch.
	(floatformat_from_type): Pass type architecture.

	* infcall.c (find_function_addr): Use type architecture instead
	of current_gdbarch.

	* valarith.c (value_bitstring_subscript, value_x_binop, value_neg,
	value_bit_index): Use type architecture instead of current_gdbarch.
	* valops.c (value_cast, value_slice): Likewise.

	* value.h (modify_field): Add TYPE argument.
	* value.c (modify_field): Add TYPE argument.  Use type architecture
	instead of current_gdbarch.
	(set_internalvar_component): Likewise.
	* eval.c (evaluate_struct_tuple): Update call.
	* valops.c (value_assign): Likewise.
	* ada-lang.c (modify_general_field): Likewise.  Add TYPE argument.
	(make_array_descriptor): Update calls.
	(move_bits): Add BITS_BIG_ENDIAN_P argument.  Use it instead of
	current_gdbarch.
	(ada_value_assign, value_assign_to_component): Update calls.
	(decode_packed_array, ada_value_primitive_packed_val, ada_value_assign,
	value_assign_to_component): Use type arch instead of current_gdbarch.

	* printcmd.c (float_type_from_length): Remove GDBARCH argument,
	use type architecture instead.
	(print_scalar_formatted, printf_command): Update calls.  Use type
	architecture instead of current_gdbarch.
	* valprint.c (val_print_type_code_int): Use type architecture
	instead of current_gdbarch.
	* varobj.c (value_get_print_value): Likewise.
	* python/python-prettyprint.c (print_string_repr): Add GDBARCH
	argument.  Use it instead of current_gdbarch.
	(apply_val_pretty_printer): Update call.

	* ada-valprint.c (ada_val_print_1): Use type architecture instead
	of current_gdbarch.
	* c-valprint.c (print_function_pointer_address): Add GDBARCH argument.
	Use it instead of current_gdbarch.
	(c_val_print): Update calls passing type architecture.
	* f-valprint.c (f_val_print): Use type architecture instead of
	current_gdbarch.
	* jv-valprint (java_value_print): Likewise.
	* m2-valprint.c (print_function_pointer_address): Add GDBARCH argument.
	Use it instead of current_gdbarch.
	(print_unpacked_pointer): Update calls passing type architecture.
	* scm-valprint.c (scm_scmval_print): Use type architecture instead of
	current_gdbarch.

	* gnu-v3-abi.c (get_class_arch): Remove.
	(gnuv3_rtti_type): Use get_type_arch instead of get_class_arch.  Remove
	special-case check for Java classes.
	(gnuv3_virtual_fn_field, gnuv3_baseclass_offset, gnuv3_print_method_ptr,
	gnuv3_method_ptr_size, gnuv3_make_method_ptr, gnuv3_method_ptr_to_value):
	Use get_type_arch instead of get_class_arch.
@
text
@d798 1
d803 1
a803 3
	      fputs_filtered (paddress (extract_typed_address
					(valaddr, ptr_type)),
			      stream);
@


1.51
log
@	* gdbtypes.h (builtin_type_true_char): Remove.
	(builtin_type_true_unsigned_char): Likewise.
	(struct builtin_type): Add builtin_true_char and
	builtin_true_unsigned_char members.
	* gdbtypes.c (builtin_type_true_char): Remove.
	(builtin_type_true_unsigned_char): Likewise.
	(_initialize_gdbtypes): Do not initialize them.
	(gdbtypes_post_init): Initialize builtin_true_char and
	builtin_true_unsigned_char members of builtin_type.

	* printcmd.c (print_scalar_formatted): Use builtin_type
	members instead of builtin_type_true_char and
	builtin_type_true_unsigned_char.
	* ada-valprint.c (ada_val_print_1): Likewise.
@
text
@d749 1
a749 1
	      struct gdbarch *gdbarch = current_gdbarch;
d788 1
a788 2
          else if (ada_is_system_address_type (type)
		   && TYPE_OBJFILE (type) != NULL)
d794 1
a794 1
                 System.Address values as a special case.
d796 1
a796 5
		 We do this only for System.Address types defined in an
		 objfile.  For the built-in version of System.Address we
		 have installed the proper type to begin with.  */

	      struct gdbarch *gdbarch = get_objfile_arch (TYPE_OBJFILE (type));
@


1.50
log
@	* ada-valprint.c (ada_print_scalar): Accept NULL type argument
	to indicate scalar should be printed as default integer.
	(print_optional_low_bound): Pass NULL to ada_print_scalar to
	indicate default integer output.
	* ada-typeprint.c (print_range, print_range_bound): Likewise.
	(print_choices): Likewise.  Thus, accept NULL as val_type.
	* ada-lang.c (ada_variant_discrim_type): Return NULL when failed
	to look up controlling discriminant name.
@
text
@d749 1
d752 1
a752 1
	      val_print_string (builtin_type_true_char,
@


1.49
log
@2009-05-27  Tom Tromey  <tromey@@redhat.com>
	    Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* mi/mi-main.c (mi_cmd_data_evaluate_expression): Use
	value_address.
	* cli/cli-dump.c (dump_value_to_file): Use value_address.
	* valprint.c (common_val_print): Likewise.
	* v850-tdep.c (v850_push_dummy_call): Use value_address.
	* tracepoint.c (encode_actions): Use value_address.
	* printcmd.c (print_formatted): Use value_address.
	(x_command): Likewise.
	* p-valprint.c (pascal_object_print_static_field): Use
	value_address.
	* mn10300-tdep.c (mn10300_push_dummy_call): Use value_address.
	* mips-tdep.c (mips_eabi_push_dummy_call): Use value_address.
	* m32r-tdep.c (m32r_push_dummy_call): Use value_address.
	* jv-valprint.c (java_value_print): Use value_address.
	* infcall.c (find_function_addr): Use value_address.
	* gnu-v3-abi.c (gnuv3_rtti_type): Use value_address.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Use value_address.
	* frv-tdep.c (frv_push_dummy_call): Use value_address.
	* frame.c (frame_register_unwind): Use value_address.
	(frame_unwind_register_value): Likewise.
	* darwin-nat-info.c (info_mach_region_command): Use
	value_address.
	* cp-valprint.c (cp_print_static_field): Use value_address.
	* c-valprint.c (c_value_print): Use value_address.
	* breakpoint.c (update_watchpoint): Use value_address.
	(can_use_hardware_watchpoint): Likewise.
	* ada-valprint.c (ada_val_print_1): Use value_address.
	(ada_value_print): Likewise.
	* ada-tasks.c (read_fat_string_value): Use value_address.
	* jv-lang.c (java_link_class_type): Use set_value_address.
	(java_link_class_type): Likewise.
	(get_java_utf8_name): Use value_address.
	(type_from_class): Likewise.
	(java_link_class_type): Likewise.
	* findvar.c (value_of_register): Use set_value_address.
	(read_var_value): Likewise.
	(read_var_value): Likewise.
	* eval.c (evaluate_subexp_standard): Use set_value_address.
	(evaluate_subexp_standard): Use value_address.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Use set_value_address.
	* ada-lang.c (coerce_unspec_val_to_type): Use set_value_address.
	(ada_value_primitive_packed_val): Likewise.
	(ensure_lval): Likewise.
	(thin_data_pntr): Use value_address.
	(desc_bounds): Likewise.
	(ada_value_primitive_packed_val): Likewise.
	(value_assign_to_component): Likewise.
	(ensure_lval): Likewise.
	(make_array_descriptor): Likewise.
	(ada_to_fixed_value): Likewise.
	(unwrap_value): Likewise.
	* value.c (deprecated_value_address_hack): Remove.
	(value_address): New function.
	(value_raw_address): Likewise.
	(set_value_address): Likewise.
	(value_fn_field): Use set_value_address.
	(value_from_contents_and_address): Likewise.
	(value_fn_field): Likewise.
	(allocate_value_lazy): Don't use VALUE_ADDRESS.
	(value_as_address): Use value_address.
	(value_static_field): Likewise.
	* valops.c (search_struct_field): Use set_value_address.
	(value_at): Likewise.
	(value_at_lazy): Likewise.
	(value_repeat): Likewise.
	(value_cast_structs): Use value_address.
	(value_cast): Likewise.
	(value_fetch_lazy): Likewise.
	(value_assign): Likewise.
	(value_repeat): Likewise.
	(address_of_variable): Likewise.
	(value_coerce_array): Likewise.
	(value_coerce_function): Likewise.
	(value_addr): Likewise.
	(search_struct_field): Likewise.
	(search_struct_method): Likewise.
	(find_method_list): Likewise.
	(value_struct_elt_for_reference): Likewise.
	(value_full_object): Likewise.
	* jv-valprint.c (java_value_print): Use set_value_address.
	* value.h (deprecated_value_address_hack): Remove.
	(VALUE_ADDRESS): Remove.
	(value_address): Declare.
	(value_raw_address): Declare.
	(set_value_address): Declare.
@
text
@d125 1
a125 1
      index_type = builtin_type_int32;
d378 2
a379 1
   form appropriate for TYPE.  */
d387 6
@


1.48
log
@	* ada-valprint.c (ada_val_print_1): Use val_print_string to print
	result of ada_vax_float_print_function inferior call.
@
text
@d693 1
a693 1
				VALUE_ADDRESS (val), stream, recurse, options);
d897 1
a897 1
                         VALUE_ADDRESS (deref_val), stream, recurse + 1,
d937 1
a937 1
  CORE_ADDR address = VALUE_ADDRESS (val0) + value_offset (val0);
@


1.47
log
@gdb:
2009-03-19  Tom Tromey  <tromey@@redhat.com>
	    Julian Brown  <julian@@codesourcery.com>

	PR i18n/7220, PR i18n/7821, PR exp/8815, PR exp/9103,
	PR i18n/9401, PR exp/9613:
	* NEWS: Update
	* value.h (value_typed_string): Declare.
	(val_print_string): Update.
	* valprint.h (print_char_chars): Update.
	* valprint.c (print_char_chars): Add type argument.  Update.
	(val_print_string): Likewise.
	* valops.c (value_typed_string): New function.
	* utils.c (host_char_to_target): New function.
	(parse_escape): Use host_char_to_target, host_hex_value.  Update.
	Remove '^' case.
	(no_control_char_error): Remove.
	* typeprint.c (print_type_scalar): Update.
	* scm-valprint.c (scm_scmval_print): Update.
	* scm-lang.h (scm_printchar, scm_printstr): Update.
	* scm-lang.c (scm_printchar): Add type argument.
	(scm_printstr): Likewise.
	* printcmd.c (print_formatted): Update.
	(print_scalar_formatted): Update.
	(printf_command) <wide_string_arg, wide_char_arg>: New constants.
	Handle '%lc' and '%ls'.
	* parser-defs.h (struct typed_stoken): New type.
	(struct stoken_vector): Likewise.
	(write_exp_string_vector): Declare.
	* parse.c (write_exp_string_vector): New function.
	* p-valprint.c (pascal_val_print): Update.
	* p-lang.h (is_pascal_string_type, pascal_printchar,
	pascal_printstr): Update.
	* p-lang.c (is_pascal_string_type): Remove 'char_size' argument.
	Add 'char_type' argument.
	(pascal_emit_char): Add type argument.
	(pascal_printchar): Likewise.
	(pascal_printstr): Likewise.
	* objc-lang.c (objc_emit_char): Add type argument.
	(objc_printchar): Likewise.
	(objc_printstr): Likewise.
	* macroexp.c (get_character_constant): Handle unicode characters.
	Use c_parse_escape.
	(get_string_literal): Handle unicode strings.  Use
	c_parse_escape.
	* m2-valprint.c (print_unpacked_pointer): Update.
	(m2_print_array_contents): Update.
	(m2_val_print): Update.
	* m2-lang.c (m2_emit_char): Add type argument.
	(m2_printchar): Likewise.
	(m2_printstr): Likewise.
	* language.h (struct language_defn) <la_printchar>: Add type
	argument.
	<la_printstr, la_emitchar>: Likewise.
	(LA_PRINT_CHAR): Likewise.
	(LA_PRINT_STRING): Likewise.
	(LA_EMIT_CHAR): Likewise.
	* language.c (unk_lang_emit_char): Add type argument.
	(unk_lang_printchar): Likewise.
	(unk_lang_printstr): Likewise.
	* jv-valprint.c (java_val_print): Update.
	* jv-lang.c (java_emit_char): Add type argument.
	* f-valprint.c (f_val_print): Update.
	* f-lang.c (f_emit_char): Add type argument.
	(f_printchar): Likewise.
	(f_printstr): Likewise.
	* expprint.c (print_subexp_standard): Update.
	* charset.h (target_wide_charset): Declare.
	(c_target_char_has_backslash_escape, c_parse_backslash,
	host_char_print_literally, host_char_to_target,
	target_char_to_host, target_char_to_control_char): Remove.
	(enum transliterations): New type.
	(convert_between_encodings): Declare.
	(HOST_ESCAPE_CHAR): New define.
	(host_letter_to_control_character, host_hex_value): Declare.
	(enum wchar_iterate_result): New enum.
	(struct wchar_iterator): Declare.
	(make_wchar_iterator, make_cleanup_wchar_iterator, wchar_iterator,
	wchar_push_back): Declare.
	* charset-list.h: New file.
	* c-valprint.c (textual_name): New function.
	(textual_element_type): Handle wide character types.
	(c_val_print): Pass original type to textual_element_type.  Handle
	wide character types.
	(c_value_print): Use textual_element_type.  Pass original type of
	value to val_print.
	* c-lang.h (enum c_string_type): New type.
	(c_printchar, c_printstr): Update.
	* c-lang.c (classify_type): New function.
	(print_wchar): Likewise.
	(c_emit_char): Add type argument.  Handle wide characters.
	(c_printchar): Likewise.
	(c_printstr): Add type argument.  Handle wide and multibyte
	character sets.
	(convert_ucn): New function.
	(emit_numeric_character): Likewise.
	(convert_octal): Likewise.
	(convert_hex): Likewise.
	(ADVANCE): New macro.
	(convert_escape): New function.
	(parse_one_string): Likewise.
	(evaluate_subexp_c): Likewise.
	(exp_descriptor_c): New global.
	(c_language_defn): Use exp_descriptor_c.
	(cplus_language_defn): Likewise.
	(asm_language_defn): Likewise.
	(minimal_language_defn): Likewise.
	(charset_for_string_type): New function.
	* c-exp.y (%union): Add 'svec' and 'tsval'.
	(CHAR): New token.
	(exp): Add CHAR production.
	(string_exp): Rewrite.
	(exp) <string_exp>: Rewrite.
	(tempbuf): Now global.
	(tempbuf_init): New global.
	(parse_string_or_char): New function.
	(yylex) <tempbuf>: Now global.
	<tokptr, tempbufindex, tempbufsize, token_string, class_prefix>:
	Remove.
	Handle 'u', 'U', and 'L' prefixes.  Call parse_string_or_char.
	(c_parse_escape): New function.
	* auxv.c (fprint_target_auxv): Update.
	* ada-valprint.c (ada_emit_char): Add type argument.
	(ada_printchar): Likewise.
	(ada_print_scalar): Update.
	(printstr): Add type argument.  Update calls to ada_emit_char.
	(ada_printstr): Add type argument.
	(ada_val_print_array): Update.
	(ada_val_print_1): Likewise.
	* ada-lang.c (emit_char): Add type argument.
	* ada-lang.h (ada_emit_char, ada_printchar, ada_printstr): Add
	type arguments.
	* gdb_locale.h: Include langinfo.h.
	* charset.c (_initialize_charset): Set default host charset from
	the locale.  Don't register charsets.  Add target-wide-charset
	commands.  Call find_charset_names.
	(struct charset, struct translation): Remove.
	(GDB_DEFAULT_HOST_CHARSET): Remove.
	(GDB_DEFAULT_TARGET_WIDE_CHARSET): New define.
	(target_wide_charset_name): New global.
	(show_host_charset_name): Handle "auto".
	(show_target_wide_charset_name): New function.
	(host_charset_enum, target_charset_enum): Remove.
	(charset_enum): New global.
	(all_charsets, register_charset, lookup_charset, all_translations,
	register_translation, lookup_translation): Remove.
	(simple_charset, ascii_print_literally, ascii_to_control): Remove.
	(iso_8859_print_literally, iso_8859_to_control,
	iso_8859_family_charset): Remove.
	(ebcdic_print_literally, ebcdic_to_control,
	ebcdic_family_charset): Remove.
	(struct cached_iconv, check_iconv_cache, cached_iconv_convert,
	register_iconv_charsets): Remove.
	(target_wide_charset_be_name, target_wide_charset_le_name): New
	globals.
	(identity_either_char_to_other): Remove.
	(set_be_le_names, validate): New functions.
	(backslashable, backslashed, represented): Remove.
	(default_c_target_char_has_backslash_escape): Remove.
	(default_c_parse_backslash, iconv_convert): Remove.
	(ascii_to_iso_8859_1_table, ascii_to_ebcdic_us_table,
	ascii_to_ibm1047_table, iso_8859_1_to_ascii_table,
	iso_8859_1_to_ebcdic_us_table, iso_8859_1_to_ibm1047_table,
	ebcdic_us_to_ascii_table, ebcdic_us_to_iso_8859_1_table,
	ebcdic_us_to_ibm1047_table, ibm1047_to_ascii_table,
	ibm1047_to_iso_8859_1_table, ibm1047_to_ebcdic_us_table): Remove.
	(table_convert_char, table_translation, simple_table_translation):
	Remove.
	(current_host_charset, current_target_charset,
	c_target_char_has_backslash_escape_func,
	c_target_char_has_backslash_escape_baton): Remove.
	(c_parse_backslash_func, c_parse_backslash_baton): Remove.
	(host_char_to_target_func, host_char_to_target_baton): Remove.
	(target_char_to_host_func, target_char_to_host_baton): Remove.
	(cached_iconv_host_to_target, cached_iconv_target_to_host):
	Remove.
	(lookup_charset_or_error, check_valid_host_charset): Remove.
	(set_host_and_target_charsets): Remove.
	(set_host_charset, set_target_charset): Remove.
	(set_host_charset_sfunc, set_target_charset_sfunc): Rewrite.
	(set_target_wide_charset_sfunc): New function.
	(show_charset): Print target wide character set.
	(host_charset, target_charset): Rewrite.
	(target_wide_charset): New function.
	(c_target_char_has_backslash_escape): Remove.
	(c_parse_backslash): Remove.
	(host_letter_to_control_character): New function.
	(host_char_print_literally): Remove.
	(host_hex_value): New function.
	(target_char_to_control_char): Remove.
	(cleanup_iconv): New function.
	(convert_between_encodings): New function.
	(target_char_to_host): Remove.
	(struct wchar_iterator): Define.
	(make_wchar_iterator, make_cleanup_wchar_iterator, wchar_iterator,
	wchar_push_back): New functions.
	(do_cleanup_iterator): New function.
	(char_ptr): New typedef.
	(charsets): New global.
	(add_one, find_charset_names): New functions.
	(default_charset_names): New global.
	(auto_host_charset_name): Likewise.
	* aclocal.m4, config.in, configure: Rebuild.
	* configure.ac: Call AM_LANGINFO_CODESET.
	(GDB_DEFAULT_HOST_CHARSET): Default to UTF-8.
	(AM_ICONV): Invoke earlier.
	* acinclude.m4: Include codeset.m4.  Subst LIBICONV_INCLUDE and
	LIBICONV_LIBDIR.  Check for libiconv in build tree.
	* Makefile.in (LIBICONV_LIBDIR, LIBICONV_INCLUDE): New macros.
	(INTERNAL_CFLAGS_BASE): Add LIBICONV_INCLUDE.
	(INTERNAL_LDFLAGS): Add LIBICONV_LIBDIR.
	* gdb_obstack.h (obstack_grow_wstr): New define.
        * gdb_wchar.h: New file.
        * defs.h: Include it.
gdb/testsuite:
	* gdb.base/store.exp: Update for change to escape output.
	* gdb.base/callfuncs.exp (fetch_all_registers): Update for change
	to escape output.
	* gdb.base/pointers.exp: Update for change to escape output.
	* gdb.base/long_long.exp (gdb_test_long_long): Update for change
	to escape output.
	* gdb.base/constvars.exp (do_constvar_tests): Update for change to
	escape output.
	* gdb.base/call-rt-st.exp (print_struct_call): Update for change
	to escape output.
	* gdb.cp/ref-types.exp (gdb_start_again): Update for change to
	escape output.
	* gdb.base/setvar.exp: Update for change to escape output.
	* lib/gdb.exp (default_gdb_start): Set LC_CTYPE to C.
	* gdb.base/printcmds.exp (test_print_all_chars): Update for change
	to escape output.
	(test_print_string_constants): Likewise.
	* gdb.base/charset.exp (valid_host_charset): Check size of
	wchar_t.  Handle UCS-2 and UCS-4.  Add tests for wide and unicode
	cases.  Handle "auto"-related output.
	* gdb.base/charset.c (char16_t, char32_t): New typedefs.
	(uvar, Uvar): New globals.
gdb/doc:
	* gdb.texinfo (Character Sets): Remove obsolete text.  Document
	set target-wide-charset.
	(Requirements): Mention iconv.
@
text
@d742 4
a745 16
	      static struct type *parray_of_char = NULL;
	      struct value *printable_val;

	      if (parray_of_char == NULL)
		parray_of_char =
		  make_pointer_type
		  (create_array_type
		   (NULL, builtin_type_true_char,
		    create_range_type (NULL, builtin_type_int32, 0, 32)), NULL);

	      printable_val =
		value_ind (value_cast (parray_of_char,
				       call_function_by_hand (func, 1,
							      &val)));

	      fprintf_filtered (stream, "%s", value_contents (printable_val));
@


1.46
log
@        Updated copyright notices for most files.
@
text
@d272 2
a273 1
ada_emit_char (int c, struct ui_file *stream, int quoter, int type_len)
d370 1
a370 1
ada_printchar (int c, struct ui_file *stream)
d373 1
a373 1
  ada_emit_char (c, stream, '\'', 1);
d415 1
a415 1
      LA_PRINT_CHAR ((unsigned char) val, stream);
d458 1
a458 1
printstr (struct ui_file *stream, const gdb_byte *string,
d510 1
a510 1
	  ada_emit_char (char_at (string, i, type_len), stream, '\'',
d528 1
a528 1
	  ada_emit_char (char_at (string, i, type_len), stream, '"',
d548 2
a549 2
ada_printstr (struct ui_file *stream, const gdb_byte *string,
	      unsigned int length, int width, int force_ellipses,
d552 2
a553 1
  printstr (stream, string, length, force_ellipses, width, options);
d642 1
a642 1
      printstr (stream, valaddr, len, 0, eltlen, options);
d822 1
a822 1
				 stream);
@


1.45
log
@	Fix TYPE_HIGH_BOUND for TYPE_CODE_RANGE using arbitrary TYPE_NFIELDS in
	preparation for supporting DW_AT_byte_stride.
	* ada-lang.c (packed_array_type, ada_index_type): Use TYPE_INDEX_TYPE.
	(ada_array_bound_from_type): Move `index_type' declaration to the
	function start.  New variable `retval'.  Return the bounds for
	TYPE_CODE_RANGE using TYPE_LOW_BOUND and TYPE_HIGH_BOUND.  Abort on
	invalid index type codes.
	* ada-typeprint.c (print_range): Set `upper_bound' for TYPE_CODE_RANGE
	now using TYPE_HIGH_BOUND.
	* ada-valprint.c (val_print_packed_array_elements): Use `index_type'.
	* eval.c (evaluate_subexp_standard): Use TYPE_INDEX_TYPE.
	* gdbtypes.c (create_range_type): Use TYPE_LOW_BOUND, TYPE_HIGH_BOUND,
	refer to the number of fields only through TYPE_NFIELDS.
	(create_array_type): Use TYPE_INDEX_TYPE.
	(check_typedef): Use TYPE_INDEX_TYPE, TYPE_LOW_BOUND, TYPE_HIGH_BOUND.
	* gdbtypes.h (TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED)
	(TYPE_ARRAY_LOWER_BOUND_IS_UNDEFINED): Use TYPE_INDEX_TYPE.
	(TYPE_ARRAY_UPPER_BOUND_VALUE, TYPE_ARRAY_LOWER_BOUND_VALUE): Use
	TYPE_INDEX_TYPE, TYPE_LOW_BOUND, TYPE_HIGH_BOUND,
	* hppa-tdep.c (hppa_alignof <TYPE_CODE_ARRAY>): Use TYPE_INDEX_TYPE.
	* mdebugread.c (parse_type): Use TYPE_LOW_BOUND, TYPE_HIGH_BOUND,
	* valarith.c (value_bit_index): Use TYPE_INDEX_TYPE.
@
text
@d4 1
a4 1
   2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.44
log
@gdb
	* varobj.c (value_get_print_value): Include valprint.h.
	(value_get_print_value): Use get_formatted_print_options.
	* value.h (struct value_print_options): Declare.
	(value_print, val_print, common_val_print, val_print_string):
	Update.
	* value.c: Include valprint.h.
	(show_values): Use get_user_print_options.
	(show_convenience): Likewise.
	* valprint.h (prettyprint_arrays, prettyprint_structs): Don't
	declare.
	(struct value_print_options): New type.
	(vtblprint, unionprint, addressprint, objectprint, print_max,
	inspect_it, repeat_count_threshold, output_format,
	stop_print_at_null): Don't declare.
	(user_print_options, get_user_print_options,
	get_raw_print_options, get_formatted_print_options): Declare.
	(print_array_indexes_p): Don't declare.
	(maybe_print_array_index, val_print_array_elements): Update.
	* valprint.c (print_max): Remove.
	(user_print_options): New global.
	(get_user_print_options, get_raw_print_options,
	get_formatted_print_options): New functions.
	(print_array_indexes, repeat_count_threshold, stop_print_at_null,
	prettyprint_structs, prettyprint_arrays, unionprint,
	addressprint): Remove.
	(val_print): Remove format, deref_ref, pretty arguments; add
	options.  Update.
	(common_val_print): Likewise.
	(print_array_indexes_p): Remove.
	(maybe_print_array_index): Remove format, pretty arguments; add
	options.  Update.
	(val_print_array_elements): Remove format, deref_ref, pretty
	arguments; add options.  Update.
	(val_print_string): Add options argument.  Update.
	(_initialize_valprint): Use user_print_options.
	(output_format): Remove.
	(set_output_radix_1): Use user_print_options.
	* typeprint.c: Include valprint.h.
	(objectprint): Don't declare.
	(whatis_exp): Use get_user_print_options.
	* tui/tui-regs.c: Include valprint.h.
	(tui_register_format): Use get_formatted_print_options.
	* tracepoint.c: Include valprint.h.
	(addressprint): Don't declare.
	(trace_mention): Use get_user_print_options.
	(tracepoints_info): Likewise.
	* stack.c (print_frame_args): Use get_raw_print_options.
	(print_frame_info): Use get_user_print_options.
	(print_frame): Likewise.
	* sh64-tdep.c: Include valprint.h
	(sh64_do_register): Use get_formatted_print_options.
	* scm-valprint.c (scm_inferior_print): Remove format, deref_ref,
	pretty arguments; add options.
	(scm_scmlist_print): Likewise.  Update.
	(scm_scmval_print): Likewise.
	(scm_val_print): Likewise.
	(scm_value_print): Remove format, pretty arguments; add options.
	Update.
	* scm-lang.h (scm_value_print, scm_val_print, scm_scmval_print):
	Update.
	* scm-lang.c (scm_printstr): Add options argument.
	* python/python-value.c: Include valprint.h.
	(valpy_str): Use get_user_print_options.
	* printcmd.c: Include valprint.h.
	(addressprint): Don't declare.
	(inspect_it): Remove.
	(print_formatted): Remove format option; add options.  Update.
	(print_scalar_formatted): Likewise.
	(print_address_demangle): Use get_user_print_options.
	(do_examine): Use get_formatted_print_options.
	(print_command_1): Likewise.
	(output_command): Use get_formatted_print_options.
	(do_one_display): Likewise.
	(print_variable_value): Use get_user_print_options.
	* p-valprint.c (pascal_val_print): Remove format, deref_ref,
	pretty arguments; add options.  Update.
	(pascal_value_print): Remove format, pretty arguments; add
	options.  Update.
	(vtblprint, objectprint): Don't declare.
	(pascal_static_field_print): Remove.
	(pascal_object_print_value_fields): Remove format, pretty
	arguments; add options.  Update.
	(pascal_object_print_static_field): Likewise.
	(_initialize_pascal_valprint): Use user_print_options.  Update.
	* p-lang.h (pascal_val_print, pascal_value_print,
	pascal_printstr, pascal_object_print_value_fields): Update.
	(vtblprint, static_field_print): Don't declare.
	* p-lang.c (pascal_printstr): Add options argument.  Update.
	* objc-lang.c (objc_printstr): Add options argument.  Update.
	* mt-tdep.c: Include valprint.h.
	(mt_registers_info): Use get_raw_print_options.
	* mips-tdep.c: Include valprint.h.
	(mips_print_fp_register): Use get_formatted_print_options.
	(mips_print_register): Likewise.
	* mi/mi-main.c: Include valprint.h.
	(get_register): Use get_user_print_options.
	(mi_cmd_data_evaluate_expression): Likewise.
	(mi_cmd_data_read_memory): Use get_formatted_print_options.
	* mi/mi-cmd-stack.c: Include valprint.h.
	(list_args_or_locals): Use get_raw_print_options.
	* m2-valprint.c (print_function_pointer_address): Add addressprint
	argument.
	(m2_print_long_set): Remove format, pretty arguments.
	(m2_print_unbounded_array): Remove format, deref_ref, pretty
	arguments; add options.  Update.
	(print_unpacked_pointer): Remove format argument; add options.
	Now static.  Update.
	(print_variable_at_address): Remove format, deref_ref, pretty
	arguments; add options.  Update.
	(m2_print_array_contents): Likewise.
	(m2_val_print): Likewise.
	* m2-lang.h (m2_val_print): Update.
	* m2-lang.c (m2_printstr): Add options argument. Update.
	* language.h (struct value_print_options): Declare.
	(struct language_defn) <la_printstr>: Add options argument.
	<la_val_print>: Remove format, deref_ref, pretty argument; add
	options.
	<la_value_print>: Remove format, pretty arguments; add options.
	<la_print_array_index>: Likewise.
	(LA_VAL_PRINT, LA_VALUE_PRINT, LA_PRINT_STRING,
	LA_PRINT_ARRAY_INDEX): Update.
	(default_print_array_index): Update.
	* language.c (default_print_array_index): Remove format, pretty
	arguments; add options.  Update.
	(unk_lang_printstr): Add options argument.
	(unk_lang_val_print): Remove format, deref_ref, pretty arguments;
	add options.
	(unk_lang_value_print): Remove format, pretty arguments; add
	options.
	* jv-valprint.c (java_value_print): Remove format, pretty
	arguments; add options.  Update.
	(java_print_value_fields): Likewise.
	(java_val_print): Remove format, deref_ref, pretty arguments; add
	options.  Update.
	* jv-lang.h (java_val_print, java_value_print): Declare.
	* infcmd.c: Include valprint.h.
	(print_return_value): Use get_raw_print_options.
	(default_print_registers_info): Use get_user_print_options,
	get_formatted_print_options.
	(registers_info): Use get_formatted_print_options.
	* gdbtypes.h (struct value_print_options): Declare.
	(print_scalar_formatted): Update.
	* f-valprint.c (f77_print_array_1): Remove format, deref_ref,
	pretty arguments; add options.  Update.
	(f77_print_array): Likewise.
	(f_val_print): Likewise.
	* f-lang.h (f_val_print): Update.
	* f-lang.c (f_printstr): Add options argument.  Update.
	(c_value_print): Update declaration.
	* expprint.c: Include valprint.h.
	(print_subexp_standard): Use get_raw_print_options,
	get_user_print_options.
	* eval.c: Include valprint.h.
	(objectprint): Don't declare.
	(evaluate_subexp_standard): Use get_user_print_options.
	* cp-valprint.c (vtblprint, objectprint, static_field_print):
	Remove.
	(cp_print_value_fields): Remove format, pretty arguments; add
	options.  Update.
	(cp_print_value): Likewise.
	(cp_print_static_field): Likewise.
	(_initialize_cp_valprint): Use user_print_options.  Update.
	* c-valprint.c (print_function_pointer_address): Add addressprint
	argument.
	(c_val_print): Remove format, deref_ref, pretty arguments; add
	options.  Update.
	(c_value_print): Add options argument.  Update.
	* c-lang.h (c_val_print, c_value_print, c_printstr): Update.
	(vtblprint, static_field_print): Don't declare.
	(cp_print_value_fields): Update.
	* c-lang.c (c_printstr): Add options argument.  Update.
	* breakpoint.c: Include valprint.h.
	(addressprint): Don't declare.
	(watchpoint_value_print): Use get_user_print_options.
	(print_one_breakpoint_location): Likewise.
	(breakpoint_1, print_it_catch_fork, print_it_catch_vfork, mention,
	print_exception_catchpoint): Likewise.
	* auxv.c (fprint_target_auxv): Don't declare addressprint.  Use
	get_user_print_options.
	* ada-valprint.c (struct ada_val_print_args): Remove format,
	deref_ref, and pretty; add options.
	(print_optional_low_bound): Add options argument.
	(val_print_packed_array_elements): Remove format and pretty
	arguments; add options.  Update.
	(printstr): Add options argument.  Update.
	(ada_printstr): Likewise.
	(ada_val_print): Remove format, deref_ref, pretty arguments; add
	options argument.  Update.
	(ada_val_print_stub): Update.
	(ada_val_print_array): Remove format, deref_ref, pretty arguments;
	add options.  Update.
	(ada_val_print_1): Likewise.
	(print_variant_part): Likewise.
	(ada_value_print): Remove format, pretty arguments; add options.
	Update.
	(print_record): Likewise.
	(print_field_values): Likewise.
	* ada-lang.h (ada_val_print, ada_value_print, ada_printstr):
	Update.
	* ada-lang.c (ada_print_array_index): Add options argument; remove
	format and pretty arguments.
	(print_one_exception): Use get_user_print_options.
gdb/testsuite
	* gdb.base/exprs.exp (test_expr): Add enum formatting tests.
@
text
@d165 1
a165 1
    if (get_discrete_bounds (TYPE_FIELD_TYPE (type, 0), &low, &high) < 0)
@


1.43
log
@	* ada-lang.c (ada_coerce_to_simple_array_type): Use builtin_type_int32
	instead of builtin_type_int as default unspecified integral type.
	(ada_index_type, ada_array_bound_from_type, ada_variant_discrim_type,
	assign_component, to_fixed_range_type): Likewise.
	* ada-typeprint.c (print_range, print_range_bound,
	print_range_type_named): Likewise.
	* ada-valprint.c (print_optional_low_bound, ada_val_print_1): Likewise.
	* eval.c (evaluate_subexp_standard): Likewise.
	* gnu-v2-abi.c (gnuv2_virtual_fn_field): Likewise.
	* gnu-v3-abi.c (gnuv3_get_virtual_fn, gnuv3_baseclass_offset,
	build_gdb_vtable_type): Likewise.
	* jv-lang.c (java_array_type): Likewise.
	* m2-typeprint.c (m2_print_bounds, m2_is_long_set_of_type): Likewise.
	* m2-valprint.c (m2_print_long_set): Likewise.
	* parse.c (follow_types): Likewise.
	* p-typeprint.c (pascal_type_print_base): Likewise.
	* valops.c (value_one, value_array, value_string,
	value_bitstring): Likewise.
	* value.c (allocate_repeat_value, value_from_string): Likewise.
	* varobj.c (c_describe_child): Likewise.
	* mt-tdep.c (mt_register_type): Likewise.
	* sh-tdep.c (sh_sh4_build_float_register_type): Likewise.
	* sh64-tdep.c (sh64_build_float_register_type): Likewise.
@
text
@a45 2
  int format;
  int deref_ref;
d47 1
a47 1
  enum val_prettyprint pretty;
d51 1
a51 1
			  int, int, enum val_prettyprint);
d54 3
a56 2
			       struct ui_file *, int, int,
			       enum val_prettyprint, int, struct type *,
d64 2
a65 2
			    struct ui_file *, int, int, int,
			    enum val_prettyprint);
d83 2
a84 1
print_optional_low_bound (struct ui_file *stream, struct type *type)
d90 1
a90 1
  if (print_array_indexes_p ())
d140 1
a140 1
    BITOFFSET from VALADDR on STREAM.  Formats according to FORMAT and
d142 1
a142 2
    If PRETTY, uses "prettier" format.  TYPE must have been decoded (as
    by ada_coerce_to_simple_array).  */
d147 2
a148 2
				 int format, int recurse,
				 enum val_prettyprint pretty)
d174 1
a174 1
  while (i < len && things_printed < print_max)
d181 1
a181 1
	  if (prettyprint_arrays)
d192 1
a192 1
      maybe_print_array_index (index_type, i + low, stream, format, pretty);
d212 1
a212 1
      if (i - i0 > repeat_count_threshold)
d214 4
a217 2
	  val_print (elttype, value_contents (v0), 0, 0, stream, format,
		     0, recurse + 1, pretty, current_language);
d226 2
d232 1
a232 1
		  if (prettyprint_arrays)
d243 1
a243 1
					   stream, format, pretty);
d245 2
a246 2
	      val_print (elttype, value_contents (v0), 0, 0, stream, format,
			 0, recurse + 1, pretty, current_language);
d458 2
a459 1
	  unsigned int length, int force_ellipses, int type_len)
d472 1
a472 1
  for (i = 0; i < length && things_printed < print_max; i += 1)
d498 1
a498 1
      if (reps > repeat_count_threshold)
d502 1
a502 1
	      if (inspect_it)
d514 1
a514 1
	  things_printed += repeat_count_threshold;
d521 1
a521 1
	      if (inspect_it)
d536 1
a536 1
      if (inspect_it)
d548 2
a549 1
	      unsigned int length, int width, int force_ellipses)
d551 1
a551 1
  printstr (stream, string, length, force_ellipses, width);
d557 1
a557 2
   FORMAT (a letter as for the printf % codes or 0 for natural format).
   The data at VALADDR is in target byte order.
a561 3
   If DEREF_REF is nonzero, then dereference references, otherwise just print
   them like pointers.

d563 1
a563 6
   continuation lines; this amount is roughly twice the value of RECURSE.

   When PRETTY is non-zero, prints record fields on separate lines.
   (For some reason, the current version of gdb instead uses a global
   variable---prettyprint_arrays--- to causes a similar effect on
   arrays.)  */
d568 2
a569 2
	       struct ui_file *stream, int format, int deref_ref,
	       int recurse, enum val_prettyprint pretty)
a576 2
  args.format = format;
  args.deref_ref = deref_ref;
d578 1
a578 1
  args.pretty = pretty;
d591 1
a591 2
			  argsp->stream, argsp->format, argsp->deref_ref,
			  argsp->recurse, argsp->pretty);
d601 2
a602 2
		     CORE_ADDR address, struct ui_file *stream, int format,
		     int deref_ref, int recurse, enum val_prettyprint pretty)
d619 2
a620 1
  if (ada_is_string_type (type) && (format == 0 || format == 's'))
d622 1
a622 1
      if (prettyprint_arrays)
d627 1
a627 1
      if (stop_print_at_null)
d634 1
a634 1
                && temp_len < print_max
d640 1
a640 1
      printstr (stream, valaddr, len, 0, eltlen);
d646 1
a646 1
      print_optional_low_bound (stream, type);
d649 1
a649 1
                                         format, recurse, pretty);
d652 1
a652 2
                                  format, deref_ref, recurse,
                                  pretty, 0);
d665 2
a666 2
		 struct ui_file *stream, int format,
		 int deref_ref, int recurse, enum val_prettyprint pretty)
d691 1
a691 2
				VALUE_ADDRESS (val), stream, format,
				deref_ref, recurse, pretty);
d704 1
a704 1
			  format, deref_ref, recurse, pretty);
d709 1
a709 1
			       stream, format, deref_ref, recurse, pretty);
d773 1
a773 1
				      stream, format, 0, recurse + 1, pretty);
d778 1
a778 2
				    address, stream, format, deref_ref,
				    recurse, pretty);
d782 2
a783 1
	  format = format ? format : output_format;
d786 3
a788 1
	      print_scalar_formatted (valaddr, type, format, 0, stream);
d827 1
a827 1
      if (format)
d829 1
a829 1
	  print_scalar_formatted (valaddr, type, format, 0, stream);
d857 2
a858 2
      if (format)
	  print_scalar_formatted (valaddr, type, format, 0, stream);
d864 1
a864 1
      if (format)
d866 1
a866 1
			    format, deref_ref, recurse, pretty);
d880 1
a880 1
	  print_record (type, valaddr, stream, format, recurse, pretty);
d885 2
a886 2
      return ada_val_print_array (type, valaddr, address, stream, format,
                                  deref_ref, recurse, pretty);
d907 2
a908 2
                         VALUE_ADDRESS (deref_val), stream, format,
                         deref_ref, recurse + 1, pretty, current_language);
d924 2
a925 2
		    struct ui_file *stream, int format, int recurse,
		    enum val_prettyprint pretty, int comma_needed,
d938 1
a938 1
       stream, format, recurse, pretty,
d943 2
a944 2
ada_value_print (struct value *val0, struct ui_file *stream, int format,
		 enum val_prettyprint pretty)
d952 1
d982 2
d985 1
a985 1
		     stream, format, 1, 0, pretty, current_language));
d990 2
a991 2
	      struct ui_file *stream, int format, int recurse,
	      enum val_prettyprint pretty)
d997 2
a998 2
  if (print_field_values (type, valaddr, stream, format, recurse, pretty,
			  0, type, valaddr) != 0 && pretty)
d1009 1
a1009 1
   TYPE, VALADDR, STREAM, FORMAT, RECURSE, and PRETTY have the
d1023 3
a1025 2
		    struct ui_file *stream, int format, int recurse,
		    enum val_prettyprint pretty, int comma_needed,
d1043 1
a1043 1
				stream, format, recurse, pretty,
d1051 1
a1051 1
				stream, format, recurse, pretty, comma_needed,
d1060 1
a1060 1
      if (pretty)
d1069 1
a1069 1
      if (inspect_it)
d1108 1
d1116 2
d1119 1
a1119 2
			 stream, format, 0, recurse + 1, pretty,
			 current_language);
d1123 7
a1129 3
	ada_val_print (TYPE_FIELD_TYPE (type, i),
		       valaddr + TYPE_FIELD_BITPOS (type, i) / HOST_CHAR_BIT,
		       0, 0, stream, format, 0, recurse + 1, pretty);
@


1.42
log
@	* gdbtypes.h (struct builtin_type): Remove builtin_true_char
	and builtin_true_unsigned_char.
	(builtin_type_true_char): Remove macro, add extern declaration.
	(builtin_type_true_unsigned_char): Add extern declaration.
	* gdbtypes.c (builtin_type_true_char): New global variable.
	(builtin_type_true_unsigned_char): Likewise.
	(_initialize_gdbtypes): Initialize them.
	(gdbtypes_post_init): Do not initialize builtin_true_char
	and builtin_true_unsigned_char members of struct builtin_type.

	* printcmd.c (print_scalar_formatted): Do not use builtin_type;
	use builtin_type_true_unsigned_char instead.

	* ada-valprint.c (ada_val_print_1): Use builtin_type_true_char
	instead of builtin_type_char for internal string.
@
text
@d125 1
a125 1
      index_type = builtin_type_long;
d756 1
a756 1
		    create_range_type (NULL, builtin_type_int, 0, 32)), NULL);
@


1.41
log
@	* ada-valprint.c: Include "objfiles.h".
	(ada_val_print_1): Use the gdbarch associated with the objfile whether
	a System.Address type is defined to retrieve the proper pointer type
	to use to print it.
@
text
@d755 1
a755 1
		   (NULL, builtin_type_char,
@


1.40
log
@	* ada-valprint.c (ada_val_print_1): When implicitly dereferencing
	a reference type, pass the reference type directly to unpack_pointer.
	* c-valprint.c (c_val_print): Likewise.
	* f-valprint.c (f_val_print): Likewise.
	* m2-valprint.c (print_variable_at_address, m2_val_print): Likewise.
	* p-valprint.c (pascal_val_print): Likewise.
@
text
@d36 1
d796 2
a797 1
          else if (ada_is_system_address_type (type))
d803 9
a811 1
                 System.Address values as a special case.  */
d816 1
a816 1
					(valaddr, builtin_type_void_data_ptr)),
@


1.39
log
@gdb:
	* xml-tdesc.c (tdesc_end_union): Update.
	* stabsread.c (define_symbol): Update.
	(read_type): Update.
	(read_struct_type): Update.
	(read_enum_type): Update.
	* spu-tdep.c (spu_builtin_type_vec128): Update.
	* sh-tdep.c (sh_push_dummy_call_fpu): Update.
	(sh_push_dummy_call_nofpu): Update.
	* mdebugread.c (parse_symbol): Update.
	(parse_symbol): Update.
	(parse_symbol): Update.
	(upgrade_type): Update.
	* jv-lang.c (java_lookup_class): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address): Update.
	* i386-tdep.c (i386_mmx_type): Update.
	(i386_sse_type): Update.
	* gdbtypes.h (enum type_flag_value): New enum.
	(enum type_instance_flag_value): New enum.
	(TYPE_FLAG_UNSIGNED, TYPE_FLAG_NOSIGN, TYPE_FLAG_STUB,
	TYPE_FLAG_TARGET_STUB, TYPE_FLAG_STATIC, TYPE_FLAG_PROTOTYPED,
	TYPE_FLAG_INCOMPLETE, TYPE_FLAG_VARARGS, TYPE_FLAG_VECTOR,
	TYPE_FLAG_FIXED_INSTANCE, TYPE_FLAG_STUB_SUPPORTED,
	TYPE_FLAG_NOTTEXT): Now enum constants.
	(TYPE_FLAG_CONST, TYPE_FLAG_VOLATILE, TYPE_FLAG_CODE_SPACE,
	TYPE_FLAG_DATA_SPACE, TYPE_FLAG_ADDRESS_CLASS_1,
	TYPE_FLAG_ADDRESS_CLASS_2): Remove.
	(TYPE_INSTANCE_FLAG_CONST, TYPE_INSTANCE_FLAG_VOLATILE,
	TYPE_INSTANCE_FLAG_CODE_SPACE, TYPE_INSTANCE_FLAG_DATA_SPACE,
	TYPE_INSTANCE_FLAG_ADDRESS_CLASS_1,
	TYPE_INSTANCE_FLAG_ADDRESS_CLASS_2): New constants.
	(TYPE_UNSIGNED, TYPE_NOSIGN, TYPE_STUB, TYPE_TARGET_STUB,
	TYPE_STATIC, TYPE_PROTOTYPED, TYPE_INCOMPLETE, TYPE_VARARGS,
	TYPE_VECTOR, TYPE_FIXED_INSTANCE, TYPE_STUB_SUPPORTED,
	TYPE_NOTTEXT): Update.
	(TYPE_FLAG_ADDRESS_CLASS_ALL): Remove.
	(TYPE_INSTANCE_FLAG_ADDRESS_CLASS_ALL): New define.
	(TYPE_VOLATILE, TYPE_CODE_SPACE, TYPE_DATA_SPACE,
	TYPE_ADDRESS_CLASS_1, TYPE_ADDRESS_CLASS_2,
	TYPE_ADDRESS_CLASS_ALL): Update.
	(struct main_type) <flags>: Remove.
	<flag_unsigned, flag_nosign, flag_stub, flag_target_stub,
	flag_static, flag_prototyped, flag_incomplete, flag_varargs,
	flag_vector, flag_stub_supported, flag_nottext,
	flag_fixed_instance>: New fields.
	<nfields, vptr_fieldno>: Move earlier.
	(TYPE_FLAGS): Remove.
	* gdbtypes.c (make_pointer_type): Update.
	(address_space_name_to_int): Update.
	(address_space_int_to_name): Update.
	(make_type_with_address_space): Update.
	(make_cv_type): Update.
	(create_range_type): Update.
	(get_discrete_bounds): Update.
	(create_set_type): Update.
	(make_vector_type): Update.
	(smash_to_method_type): Update.
	(check_typedef): Update.
	(check_stub_method): Update.
	(init_type): Individually assign flag fields.
	(recursive_dump_type): Don't print entire TYPE_FLAGS field.  Do
	print TYPE_FIXED_INSTANCE, TYPE_STUB_SUPPORTED, and TYPE_NOTTEXT.
	(copy_type_recursive): Copy the entire main type.  Don't use
	TYPE_FLAGS.
	* features/rs6000/powerpc-altivec64l.c
	(initialize_tdesc_powerpc_altivec64l): Update.
	* features/rs6000/powerpc-altivec64.c
	(initialize_tdesc_powerpc_altivec64): Update.
	* features/rs6000/powerpc-altivec32l.c
	(initialize_tdesc_powerpc_altivec32l): Update.
	* features/rs6000/powerpc-altivec32.c
	(initialize_tdesc_powerpc_altivec32): Update.
	* features/rs6000/powerpc-7400.c (initialize_tdesc_powerpc_7400):
	Update.
	* features/arm-with-iwmmxt.c (initialize_tdesc_arm_with_iwmmxt):
	Update.
	* dwarf2read.c (read_structure_type): Update.
	(read_enumeration_type): Likewise.
	(process_enumeration_scope): Likewise.
	(read_tag_pointer_type): Likewise.
	(read_subroutine_type): Likewise.
	(read_subroutine_type): Likewise.
	(read_base_type): Likewise.
	* coffread.c (coff_read_enum_type): Update.
	* ada-valprint.c (adjust_type_signedness): Update.
	* ada-typeprint.c (print_record_field_types): Update.
	* ada-lang.c (packed_array_type): Update.
	(empty_record): Don't reset TYPE_FLAGS.
	(ada_template_to_fixed_record_type_1): Update.
	(ada_template_to_fixed_record_type_1): Likewise.
	(template_to_static_fixed_type): Likewise.
	(to_record_with_fixed_variant_part): Likewise.
	(to_fixed_record_type): Likewise.
	(to_fixed_array_type): Likewise.
	(to_static_fixed_type): Likewise.
gdb/testsuite:
	* gdb.base/maint.exp: Update "maint print type".
@
text
@d894 1
a894 3
          LONGEST deref_val_int = (LONGEST)
            unpack_pointer (lookup_pointer_type (builtin_type_void),
                            valaddr);
@


1.38
log
@* ada-lang.c (discrete_type_high_bound,discrete_type_low_bound): Change
API to return LONGEST values rather than struct values.
(ada_evaluate_subexp): Change to use new API of discrete_type_low_bound
and discrete_type_high_bound.
(to_fixed_range_type): Create a range type in cases where
argument is base type and its limits are representable as ints.
(ada_is_modular_type): Correct so that base type must be integral.
* ada-lex.l (TRUEKEYWORD,FALSEKEYWORD): Make 'true' and 'false'
keywords when they appear alone, since we are phasing out
direct representation of these identifiers in ebugging data.
* ada-exp.y: Define 'true' and 'false' as primaries.
(type_boolean): New function.
(type_int,type_long,type_long_long,type_floattype_double)
(type_long_double): Remove uses of current_gdbarch for consistency
with type_boolean.
(write_int): Change comment to indicate that it might write boolean
constant as well.
* ada-typeprint.c (ada_print_type): Print '(false, true)' for boolean
type, since will no longer be represented as enumerated type in
debugging data.
* ada-valprint.c (print_optional_low_bound): Handle boolean case
as well.
@
text
@d74 1
a74 1
    TYPE_FLAGS (type) |= TYPE_FLAG_UNSIGNED;
@


1.37
log
@        * valprint.h (get_array_bounds): Renames get_array_low_bound.
        * valprint.c (get_array_bounds): Renames get_array_low_bound.
        Return the proper bound value if the array index type is an
        enumerated type. Compute the high bound if requested.
        (val_print_array_elements): Handle the case when the array
        element has a null size.
        * ada-valprint.c (print_optional_low_bound): Add handling
        for empty arrays or arrays of zero-size elements.
        (ada_val_print_array): New function, extracted out from
        ada_val_print_1 case TYPE_CODE_ARRAY, and enhanced to
        handle empty arrays and arrays of zero-size elements.
        (ada_val_print_1)[case TYPE_CODE_ARRAY]: Replace extracted-out
        code by call to ada_val_print_array.
        (ada_value_print): Remove handling of null array.  The handling
        was incomplete and is now better handled by ada_val_print_array.
@
text
@d115 4
@


1.36
log
@        * valprint.c (val_print): Add new language parameter and use it
        instead of using the current_language. Update calls to val_print
        throughout.
        (common_val_print): Add new langauge parameter and pass it to
        val_print.
        * value.h (struct language_defn): Add opaque declaration.
        (val_print, common_val_print): Update declarations.
        * stack.c (print_frame_args): Update call to common_val_print
        using the appropriate language.
        * mi/mi-cmd-stack.c (list_args_or_locals): Likewise.
        * c-valprint, f-valprint.c, m2-valprint.c, mt-tdep.c, infcmd.c,
        mi/mi-main.c, jv-valprint.c, ada-valprint.c, varobj.c, p-valprint.c,
        scm-valprint.c, cp-valprint.c, sh64-tdep.c, printcmd.c:
        #include "language.h" if necessary.
        Update calls to val_print and common_val_print.
        * Makefile.in (mt-tdep.o, sh64-tdep.o, mi-cmds.o, mi-main.o):
        Update dependencies.
@
text
@d77 4
a80 4
/* Assuming TYPE is a simple, non-empty array type, prints its lower bound 
   on STREAM, if non-standard (i.e., other than 1 for numbers, other
   than lower bound of index type for enumerated type).  Returns 1 
   if something printed, otherwise 0.  */
d87 1
d92 7
a98 1
  if (!get_array_low_bound (type, &low_bound))
d596 65
d662 1
a662 1
 * does not catch evaluation errors (leaving that to ada_val_print).  */
d877 2
a878 51
      elttype = TYPE_TARGET_TYPE (type);
      if (elttype == NULL)
	eltlen = 0;
      else
	eltlen = TYPE_LENGTH (elttype);
      /* FIXME: This doesn't deal with non-empty arrays of
	 0-length items (not a typical case!) */
      if (eltlen == 0)
	len = 0;
      else
	len = TYPE_LENGTH (type) / eltlen;

	  /* For an array of chars, print with string syntax.  */
      if (ada_is_string_type (type) && (format == 0 || format == 's'))
	{
	  if (prettyprint_arrays)
	    {
	      print_spaces_filtered (2 + 2 * recurse, stream);
	    }
	  /* If requested, look for the first null char and only print
	     elements up to it.  */
	  if (stop_print_at_null)
	    {
	      int temp_len;

	      /* Look for a NULL char.  */
	      for (temp_len = 0;
		   temp_len < len && temp_len < print_max
		     && char_at (valaddr, temp_len, eltlen) != 0;
		   temp_len += 1);
	      len = temp_len;
	    }

	  printstr (stream, valaddr, len, 0, eltlen);
	}
      else
	{
	  len = 0;
	  fprintf_filtered (stream, "(");
	  print_optional_low_bound (stream, type);
	  if (TYPE_FIELD_BITSIZE (type, 0) > 0)
	    val_print_packed_array_elements (type, valaddr, 0, stream,
					     format, recurse, pretty);
	  else
	    val_print_array_elements (type, valaddr, address, stream,
				      format, deref_ref, recurse,
				      pretty, 0);
	  fprintf_filtered (stream, ")");
	}
      gdb_flush (stream);
      return len;
a974 16
  if (TYPE_CODE (type) == TYPE_CODE_ARRAY
      && TYPE_LENGTH (TYPE_TARGET_TYPE (type)) == 0
      && TYPE_CODE (TYPE_INDEX_TYPE (type)) == TYPE_CODE_RANGE)
    {
      /* This is an array of zero-length elements, that is an array
         of null records.  This array needs to be printed by hand,
         as the standard routine to print arrays relies on the size of
         the array elements to be nonzero.  This is because it computes
         the number of elements in the array by dividing the array size
         by the array element size.  */
      fprintf_filtered (stream, "(%d .. %d => ())",
                        TYPE_LOW_BOUND (TYPE_INDEX_TYPE (type)),
                        TYPE_HIGH_BOUND (TYPE_INDEX_TYPE (type)));
      return 0;
    }
  
@


1.35
log
@	* exec.c: #include "arch-utils.h"
	 (print_section_info): Use gdbarch_from_bfd to get at the
	current architecture. Replace current_gdbarch. Fix indention.
	Replace deprecated_print_address_numeric by paddress.
	* Makefile.in (exec.o) Add dependency to arch-utils.h.

	* valprint.c (val_print_string): Replace
	deprecated_print_address_numeric.
	* tracepoint.c (trace_mention, scope_info): Likewise.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1, print_symbol)
	(print_symbol, print_partial_symbols, maintenance_info_psymtabs)
	(maintenance_check_symtabs): Likewise.
	* symfile.c (list_overlays_command): Likewise.
	* stack.c (frame_info, print_block_frame_labels): Likewise.
	* printcmd.c (print_address, print_address_demangle)
	(address_info): Likewise.
	* corefile.c (memory_error): Likewise.
	* infcmd.c (jump_command): Likewise.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints)
	(mention, delete_breakpoint): Likewise.
	* c-valprint.c (print_function_pointer_address, c_val_print): Likewise.
	* dwarf2read.c (dump_die): Likewise.
	* ada-valprint.c (ada_val_print_1): Likewise.
	* f-valprint.c (f_val_print): Likewise.
	* linux-fork.c (info_forks_command): Likewise.
	* m32r-com.c (m32r_load_section, m32r_load)
	(m32r_upload_command): Likewise.

	* ui-out.c (ui_out_field_core_addr): Remove unnecessary comment.
@
text
@d204 1
a204 1
		     0, recurse + 1, pretty);
d231 1
a231 1
			 0, recurse + 1, pretty);
d879 1
a879 1
                         deref_ref, recurse + 1, pretty);
d969 1
a969 1
		     stream, format, 1, 0, pretty));
d1099 2
a1100 1
			 stream, format, 0, recurse + 1, pretty);
@


1.34
log
@        * ada-lang.c (ada_value_struct_elt, to_fixed_array_type)
        (to_fixed_array_type, ada_to_fixed_value_create, unwrap_value):
        Update calls to ada_to_fixed_type.
        (ada_template_to_fixed_record_type_1): Ditto, but without looking
        for the tag.
        (ada_to_fixed_type): Add check_tag parameter; do not look for
        tag if null.  When looking for a tag, use a fixed record type.
        * ada-lang.h (ada_to_fixed_type): Add check_tag parameter.
        * ada-valprint.c (printable_val_type, ada_value_print): Update
        calls to ada_to_fixed_type.
@
text
@d729 3
a731 3
              deprecated_print_address_numeric 
		(extract_typed_address (valaddr, builtin_type_void_data_ptr),
                 1, stream);
@


1.33
log
@	Updated copyright notices for most files.
@
text
@d249 1
a249 1
  return ada_to_fixed_type (ada_aligned_type (type), valaddr, 0, NULL);
d920 1
a920 1
    ada_to_fixed_type (value_type (val0), valaddr, address, NULL);
@


1.32
log
@        * ada-valprint.c (ada_val_print_1) [TYPE_CODE_REF]: Ignore deref_ref
        and always print the dereferenced value.
@
text
@d4 1
a4 1
   2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
@


1.31
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d858 5
d864 23
a886 25
      /* De-reference the reference */
      if (deref_ref)
	{
	  if (TYPE_CODE (elttype) != TYPE_CODE_UNDEF)
	    {
	      LONGEST deref_val_int = (LONGEST)
		unpack_pointer (lookup_pointer_type (builtin_type_void),
				valaddr);
	      if (deref_val_int != 0)
		{
		  struct value *deref_val =
		    ada_value_ind (value_from_longest
				   (lookup_pointer_type (elttype),
				    deref_val_int));
		  val_print (value_type (deref_val),
			     value_contents (deref_val), 0,
			     VALUE_ADDRESS (deref_val), stream, format,
			     deref_ref, recurse + 1, pretty);
		}
	      else
		fputs_filtered ("(null)", stream);
	    }
	  else
	    fputs_filtered ("???", stream);
	}
@


1.30
log
@Copyright updates for 2007.
@
text
@d6 1
a6 1
This file is part of GDB.
d8 12
a19 14
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301, USA.  */
@


1.29
log
@	* NEWS: Mention pointer to member improvements.
	* Makefile.in (gnu-v3-abi.o): Delete special rule.
	(eval.o, gnu-v3-abi.o, ia64-tdep.o): Update.
	* ada-valprint.c (ada_print_scalar): Update for new type codes.
	* c-typeprint.c (c_print_type): Update for new type codes.
	(c_type_print_varspec_prefix, c_type_print_varspec_suffix)
	(c_type_print_base): Likewise.
	(c_type_print_args): Rewrite.
	* c-valprint.c (c_val_print): Update for new type codes.  Remove
	support for references to members.  Treat methods like functions.
	* cp-abi.c (cplus_print_method_ptr, cplus_method_ptr_size)
	(cplus_make_method_ptr, cplus_method_ptr_to_value): New.
	* cp-abi.h (cplus_print_method_ptr, cplus_method_ptr_size)
	(cplus_make_method_ptr, cplus_method_ptr_to_value): New prototypes.
	(struct cp_abi_ops): Add corresponding members.
	* cp-valprint.c (cp_print_class_method): Delete.
	(cp_find_class_member): New function.
	(cp_print_class_member): Use it.  Simplify support for bogus
	member pointers.
	* dwarf2read.c (quirk_gcc_member_function_pointer): Use
	lookup_methodptr_type.
	(read_tag_ptr_to_member_type): Likewise, and lookup_memberptr_type.
	* eval.c (evaluate_subexp_standard): Implement EVAL_SKIP for
	OP_SCOPE.  Update call to value_aggregate_elt.  Rewrite member
	pointer support.
	(evaluate_subexp_for_address): Handle OP_SCOPE explicitly.  Handle
	references returned by user defined operators.
	* f-typeprint.c (f_print_type, f_type_print_varspec_prefix)
	(f_type_print_varspec_suffix): Remove support for member pointers.
	* gdbtypes.c (lookup_memberptr_type): Renamed from lookup_member_type
	and adjusted.
	(smash_to_memberptr_type): Likewise, from smash_to_member_type.
	(lookup_methodptr_type): New.
	(rank_one_type): Adjust for TYPE_CODE_MEMBERPTR.
	(recursive_dump_type): Update for new types.
	* gdbtypes.h (enum type_code): Replace TYPE_CODE_MEMBER with
	TYPE_CODE_MEMBERPTR and TYPE_CODE_METHODPTR.
	(lookup_memberptr_type, lookup_methodptr_type)
	(smash_to_memberptr_type): New prototypes.
	(smash_to_method_type): Formatting fix.
	(lookup_member_type, smash_to_member_type): Delete prototypes.
	* gnu-v3-abi.c (gnuv3_get_vtable, gnuv3_get_virtual_fn): New.
	Do not rely on debug information for the vptr or the method's
	enclosing type.  Handle function descriptors for IA64.
	(gnuv3_virtual_fn_field): Rewrite using the new functions.
	(gnuv3_find_method_in, gnuv3_print_method_ptr)
	(gnuv3_method_ptr_size, gnuv3_make_method_ptr)
	(gnuv3_method_ptr_to_value): New.
	(init_gnuv3_ops): Set new members of gnu_v3_abi_ops.
	* hpread.c (hpread_type_lookup): Update for new types.
	* infcall.c (value_arg_coerce): Likewise.
	* m2-typeprint.c (m2_print_type): Remove explicit support
	for member pointers.
	* m2-valprint.c (m2_val_print): Likewise.
	* p-typeprint.c (pascal_type_print_varspec_prefix)
	(pascal_type_print_varspec_suffix, pascal_type_print_base): Likewise.
	* p-valprint.c (pascal_val_print): Likewise.
	(pascal_object_print_class_method, pascal_object_print_class_member):
	Delete.
	* p-lang.h (pascal_object_print_class_method)
	(pascal_object_print_class_member): Delete prototypes.
	* stabsread.c (read_type): Update for new types.
	* typeprint.c (print_type_scalar): Likewise.
	* valops.c (value_struct_elt_for_reference, value_namespace_elt)
	(value_maybe_namespace_elt, value_aggregate_elt): Add want_address
	argument.  Construct a pointer to member if the address of a
	function or data member is requested.
	(value_cast_pointers): Don't modify the input value.
	(value_cast): Adjust pointer to member handling for new types.
	Allow null pointer to member constants.  Don't modify the input
	value.
	(value_ind): Remove pointer to member check.  Handle function
	descriptors for function pointers.
	(value_struct_elt, value_find_oload_method_list, check_field):
	Remove pointer to member checks.
	* value.c (unpack_long): Allow pointers to data members.
	(value_from_longest): Allow member pointers.
	* value.h (value_aggregate_elt): Add want_address.
	* varobj.c (c_variable_editable): Remove check for members.
	* gdbarch.sh: Add vtable_function_descriptors and vbit_in_delta.
	* ia64-tdep.c (ia64_convert_from_func_ptr_addr): Handle descriptors
	in virtual tables.
	(ia64_gdbarch_init): Call set_gdbarch_vtable_function_descriptors.
	* c-lang.h (cp_print_class_method): Delete prototype.
	* arm-tdep.c (arm_gdbarch_init): Call set_gdbarch_vbit_in_delta.
	* mips-tdep.c (mips_gdbarch_init): Likewise.
	* gdbarch.c, gdbarch.h: Regenerated.

	* gdb.cp/classes.exp (test_pointers_to_class_members): Update expected
	output.  Test the types of members and member pointers.
	* gdb.cp/inherit.exp (test_print_mi_member_types): Remove KFAILs for
	gdb/2092.
	* gdb.cp/member-ptr.exp: Search for a comment instead of a
	statement.  Enable for GCC.  Update expected output for some tests
	and add new tests.  Remove obsolete GCC KFAILs.  Allow GCC's class
	layout.
	* gdb.cp/member-ptr.cc (Padding, Padding::vspacer, Base, Base::get_x)
	(Base::vget_base, Left, Left::vget, Right, Right::vget, Diamond)
	(Diamond::vget_base): New.
	(main): Add new tests.
	* gdb.cp/printmethod.exp: Update expected output for member functions.
	* gdb.cp/virtfunc.exp (test_virtual_calls): Add a KFAIL for
	print pEe->D::vg().
@
text
@d3 2
a4 2
   Copyright (C) 1986, 1988, 1989, 1991, 1992, 1993, 1994, 1997, 2001,
   2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
@


1.28
log
@Based on a previous patch form Michal Ludvig:
* gdbtypes.c (append_flags_type_flag, init_flags_type): New
functions.
(is_integral_type, rank_one_type, recursive_dump_type): Add
support for TYPE_CODE_FLAGS.
* gdbtypes.h (enum type_code): Add TYPE_CODE_FLAGS.
(append_flags_type_field, init_flags_type): New prototypes.
* ada-valprint.c (ada_val_print_1): Add support for
TYPE_CODE_FLAGS.
* c-valprint.c (c_val_print): Likewise.
* f-valprint.c (f_val_print): Likewise.
* p-valprint.c (pascal_val_print): Likewise.
* valprint.c (val_print_type_code_flags): New function.
* valprint.h (val_print_type_code_flags): New prototype.
* value.c (unpack_long, value_from_longest): Add support for
TYPE_CODE_FLAGS.
@
text
@d423 2
a424 1
    case TYPE_CODE_MEMBER:
@


1.27
log
@	* ada-lang.c (process_raise_exception_name): Remove extraneous
        definition from unsubmitted code.
	(is_lower_alphanum): New function.
	(ada_decode):  Add support for decoding protected object subprograms
	and entries, and of entities declared inside protected object
	subprograms.
	Also add missing handling for__{DIGITS}+ suffixes.
	Allow '$<digits>' as valid overloading suffix.
	(is_name_suffix): Add handling for protected type entriy suffixes.
	Also add support for protected type subprogram suffixes, but keep
	it commented out for now, as there is an ambiguity between these
	entities and other internally generated entities.
	Allow '$<digits>' as valid overloading suffix.
	(is_valid_name_for_wild_match): New function.
	(wild_match): Add an exra level of verification of the entity name
	before declaring it a match for the given pattern.
	(ada_type_of_array, ada_evaluate_subexp): Use more proper
	longest_to_int rather than cast.
	(ada_evaluate_subexp): Use "invalid" rather than "illegal" in comment.
	(ada_coerce_to_simple_array): Call check_size to make sure
	that the object size is reasonable.
	(ada_value_primitive_packed_val):  Use correct location in target
	buffer for extracting packed record fields that are themselves records.
	(add_defn_to_vec): Do not try to replace a stub type by its full
	type. Avoids a potential infinite loop.
	(ada_lookup_symbol): Move return incorrectly placed return statement,
	causing a loop that should be scanning all object files to only
	scan the first one.
	(ada_tag_name_2): New function.
	(ada_tag_name_1): If no 'tsd' field found in the dispatching table,
	use alternative representation.
	(ada_find_renaming_symbol): Strip the function name suffix when
	computing the XR type name.
	(ada_to_fixed_type): Try determining the tag only if we have the
	object's address.
	(to_fixed_array_type): Add comments.
	(ada_check_typedef): Replace expression checking whether the given
	type is a stub or not by a "call" to TYPE_STUB. Clearer and more
	consistent.

	* ada-lang.h (ADA_KNOWN_AUXILIARY_FUNCTION_NAME_PATTERNS): Allow
	'$' in addition to '.' for runtime auxiliary function name suffixes.
	See changes to ada_decode above.
	(struct task_control_block): Add field called_task.  (This change is
	to keep synchronized with our local sources; it does not affect the
	public version yet.)

	* ada-typeprint.c (ada_print_type): Use int_string for printing
	modulus of modular type.
	(print_range): Trivial editorial comment fix.

	* ada-valprint.c (ada_emit_char): Use normal Ada syntax for
	double quote in string.
@
text
@d4 1
a4 1
   2002, 2003, 2004, 2005 Free Software Foundation, Inc.
d777 7
@


1.26
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d269 1
a269 1
	fprintf_filtered (stream, "[\"%c\"]", quoter);
@


1.25
log
@        * ada-valprint.c (print_optional_low_bound): Handle properly
        cases where the array index type is a TYPE_CODE_RANGE.
@
text
@d3 1
a3 1
   Copyright 1986, 1988, 1989, 1991, 1992, 1993, 1994, 1997, 2001,
d20 2
a21 1
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
@


1.24
log
@2005-10-03  Joel Brobecker  <brobecker@@adacore.com>

        * language.h (language_defn): New field la_print_array_index.
        (LA_PRINT_ARRAY_INDEX): New macro.
        (default_print_array_index): Add declaration.
        * language.c (default_print_array_index): new function.
        (unknown_language): Add value for new field.
        (auto_language): Likewise.
        (local_language): Likewise.
        * ada-lang.c (ada_print_array_index): New function.
        (ada_language_defn): Add value for new field.
        * c-lang.c (c_language_defn): Likewise.
        (cpluc_language_defn): Likewise.
        (asm_language_defn): Likewise.
        (minimal_language_defn): Likewise.
        * f-lang.c (f_language_defn): Likewise.
        * jv-lang.c (java_language_defn): Likewise.
        * m2-lang.c (m2_language_defn): Likewise.
        * objc-lang.c (objc_language_defn): Likewise.
        * p-lang.c (pascal_language_defn): Likewise.
        * scm-lang.c (scm_language_defn): Likewise.
        * valprint.h (print_array_indexes_p): Add declaration.
        (get_array_low_bound): Add declaration.
        (maybe_print_array_index): Add declaration.
        * valprint.c (print_array_indexes): New static variable.
        (show_print_array_indexes): New function.
        (print_array_indexes_p): New function.
        (get_array_low_bound): New function.
        (maybe_print_array_index): New function.
        (val_print_array_elements): Print the index of each element if
        requested by the user.
        (_initialize_valprint): Add new array-indexes "set/show print" command.
        * ada-valprint.c (print_optional_low_bound): Replace extracted code
        by call to ada_get_array_low_bound_and_type(). Stop printing the low
        bound if indexes will be printed for all elements of the array.
        (val_print_packed_array_elements): Print the index of each element
        of the array if necessary.
@
text
@d97 10
@


1.23
log
@2005-05-09  Andrew Cagney  <cagney@@gnu.org>

	Use gdb_byte in preference to bfd_byte.
	* gdbarch.sh: Update.
	* gdbarch.h, gdbarch.c: Re-generate.
	* ada-lang.c, ada-lang.h, ada-valprint.c, arch-utils.c: Update.
	* c-lang.c, c-lang.h, c-valprint.c, cp-valprint.c: Update.
	* f-lang.c, f-lang.h, f-valprint.c, gdbcore.h, jv-lang.h: Update.
	* jv-valprint.c, language.c, language.h, m2-lang.c: Update.
	* m2-lang.h, m2-valprint.c, objc-lang.c, p-lang.c: Update.
	* p-lang.h, p-valprint.c, regcache.c, scm-lang.c: Update.
	* scm-lang.h, scm-valprint.c, target.c, target.h: Update.
	* tramp-frame.c, valarith.c, valops.c, valprint.c: Update.
	* valprint.h, value.c, value.h: Update.
@
text
@d89 2
a90 2
  index_type = TYPE_INDEX_TYPE (type);
  low_bound = 0;
d92 1
a92 10
  if (index_type == NULL)
    return 0;
  if (TYPE_CODE (index_type) == TYPE_CODE_RANGE)
    {
      low_bound = TYPE_LOW_BOUND (index_type);
      if (low_bound > TYPE_HIGH_BOUND (index_type))
	return 0;
      index_type = TYPE_TARGET_TYPE (index_type);
    }
  else
d94 2
d133 1
a133 1
  struct type *elttype;
d137 1
d141 1
d144 1
a144 1
    LONGEST low, high;
d172 1
d218 2
@


1.22
log
@2005-02-14  Andrew Cagney  <cagney@@gnu.org>

	* utils.c (paddress): New function.
	* defs.h (paddress): Declare.
	* printcmd.c (deprecated_print_address_numeric): Rename
	print_address_numeric, call paddress.
	* valprint.c, ui-out.c, tui/tui-stack.c, tracepoint.c: Update.
	* symmisc.c, symfile.c stack.c, p-valprint.c, printcmd.c: Update.
	* maint.c, m32r-rom.c, infcmd.c, f-valprint.c, exec.c: Update.
	* dwarf2read.c, dve3900-rom.c, defs.h, c-valprint.c: Update.
	* corefile.c, cli/cli-cmds.c, breakpoint.c, annotate.c: Update.
	* ada-valprint.c: Update.
@
text
@d42 1
a42 1
  const bfd_byte *valaddr0;
d52 1
a52 1
static void print_record (struct type *, const bfd_byte *, struct ui_file *,
d55 1
a55 1
static int print_field_values (struct type *, const bfd_byte *,
d58 1
a58 1
			       const bfd_byte *);
d64 1
a64 1
static int ada_val_print_1 (struct type *, const bfd_byte *, int, CORE_ADDR,
d132 1
a132 1
val_print_packed_array_elements (struct type *type, const bfd_byte *valaddr,
d240 1
a240 1
printable_val_type (struct type *type, const bfd_byte *valaddr)
d272 1
a272 1
char_at (const bfd_byte *string, int i, int type_len)
d293 1
a293 1
ada_print_floating (const bfd_byte *valaddr, struct type *type,
d434 1
a434 1
printstr (struct ui_file *stream, const bfd_byte *string,
d523 1
a523 1
ada_printstr (struct ui_file *stream, const bfd_byte *string,
d550 1
a550 1
ada_val_print (struct type *type, const bfd_byte *valaddr0,
d585 1
a585 1
ada_val_print_1 (struct type *type, const bfd_byte *valaddr0,
d595 1
a595 1
  const bfd_byte *valaddr = valaddr0 + embedded_offset;
d876 1
a876 1
print_variant_part (struct type *type, int field_num, const bfd_byte *valaddr,
d879 1
a879 1
		    struct type *outer_type, const bfd_byte *outer_valaddr)
d899 1
a899 1
  const bfd_byte *valaddr = value_contents (val0);
d955 1
a955 1
print_record (struct type *type, const bfd_byte *valaddr,
d988 1
a988 1
print_field_values (struct type *type, const bfd_byte *valaddr,
d991 1
a991 1
		    struct type *outer_type, const bfd_byte *outer_valaddr)
@


1.21
log
@2005-02-06  Andrew Cagney  <cagney@@gnu.org>

	* value.c (value_contents, value_contents_writeable): New
	functions.
	* value.h (VALUE_CONTENTS): Delete macro.
	(value_contents, value_contents_writeable): Declare.
	* xstormy16-tdep.c, value.c, valops.c, valarith.c: Update.
	* stack.c, sparc-tdep.c, sparc64-tdep.c, sh-tdep.c: Update.
	* sh64-tdep.c, scm-valprint.c, scm-exp.c, s390-tdep.c: Update.
	* rs6000-tdep.c, p-valprint.c, printcmd.c: Update.
	* ppc-sysv-tdep.c, mips-tdep.c, mi/mi-main.c: Update.
	* m88k-tdep.c, m68hc11-tdep.c, m32r-tdep.c: Update.
	* jv-valprint.c, ia64-tdep.c, hppa-tdep.c: Update.
	* hpacc-abi.c, f-valprint.c, frv-tdep.c, eval.c: Update.
	* c-valprint.c, cris-tdep.c, cp-valprint.c: Update.
	* cli/cli-dump.c, breakpoint.c, avr-tdep.c, arm-tdep.c: Update.
	* arm-linux-tdep.c, amd64-tdep.c, alpha-tdep.c: Update.
	* ada-valprint.c, ada-lang.c: Update.
@
text
@d721 1
a721 1
              print_address_numeric 
@


1.20
log
@2005-01-28  Andrew Cagney  <cagney@@gnu.org>

	* language.h (struct language_defn): Make la_val_print's buffer
	parameter a const bfd_byte.
	* cp-valprint.c (cp_print_value_fields, cp_print_value): Update.
	* ada-lang.c (ada_aligned_value_addr)
	(ada_value_primitive_packed_val, ada_which_variant_applies): Update.
	* valprint.c (val_print_array_elements): Update.
	* valprint.h (val_print_array_elements): Update.
	* ada-lang.h (ada_val_print, ada_aligned_value_addr)
	(ada_value_primitive_packed_val, ada_which_variant_applies): Update.
	* ada-valprint.c (ada_val_print, struct ada_val_print_args)
	(ada_val_print_1, ada_print_floating, printable_val_type)
	(print_record, val_print_packed_array_elements)
	(print_field_values, print_variant_part): Update.
	* c-lang.h (c_val_print, cp_print_value_fields): Update.
	* c-valprint.c (c_val_print): Update.
	* f-lang.h (f_val_print): Update.
	* f-valprint.c (f_val_print, f77_print_array_1)
	(f77_print_array): Update.
	* jv-lang.h (java_val_print): Update.
	* jv-valprint.c (java_print_value_fields, java_val_print): Update.
	* language.c (unk_lang_val_print): Update.
	* m2-lang.h (m2_val_print): Update.
	* m2-valprint.c (m2_val_print): Update.
	* p-lang.h (pascal_val_print): Update.
	(pascal_object_print_value_fields): Update.
	* p-valprint.c (pascal_val_print)
	(pascal_object_print_value_fields, pascal_object_print_value)
	(pascal_object_print_value): Update.
	* scm-lang.h (scm_val_print): Update.
	* scm-valprint.c (scm_val_print): Update.
	* value.h (val_print): Update.
@
text
@d192 1
a192 1
	  if (memcmp (VALUE_CONTENTS (v0), VALUE_CONTENTS (v1), eltlen) != 0)
d198 1
a198 1
	  val_print (elttype, VALUE_CONTENTS (v0), 0, 0, stream, format,
d223 1
a223 1
	      val_print (elttype, VALUE_CONTENTS (v0), 0, 0, stream, format,
d612 1
a612 1
	retn = ada_val_print_1 (value_type (val), VALUE_CONTENTS (val), 0,
d678 1
a678 1
	      fprintf_filtered (stream, "%s", VALUE_CONTENTS (printable_val));
d695 1
a695 1
	      return ada_val_print_1 (target_type, VALUE_CONTENTS (v), 0, 0,
d859 1
a859 1
			     VALUE_CONTENTS (deref_val), 0,
d899 1
a899 1
  char *valaddr = VALUE_CONTENTS (val0);
d950 1
a950 1
  return (val_print (type, VALUE_CONTENTS (val), 0, address,
d1080 1
a1080 1
	      val_print (TYPE_FIELD_TYPE (type, i), VALUE_CONTENTS (v), 0, 0,
@


1.19
log
@2005-01-28  Andrew Cagney  <cagney@@gnu.org>

	* language.h (struct language_defn): Make la_printstr's buffer
	parameter a const bfd_byte.
	* p-lang.h (pascal_printstr): Update function to match.
	* ada-valprint.c (ada_printstr): Update function to match.
	* scm-lang.c (scm_printstr): Update function to match.
	* p-lang.c (pascal_printstr): Update function to match.
	* ada-lang.h (ada_printstr): Update function to match.
	* m2-lang.c (m2_printstr): Update function to match.
	* objc-lang.c (objc_printstr): Update function to match.
	* c-lang.h (c_printstr): Update function to match.
	* f-lang.c (f_printstr): Update function to match.
	* c-lang.c (c_printstr): Update function to match.
	* language.c (unk_lang_printstr): Update function to match.
@
text
@d42 1
a42 1
  char *valaddr0;
d52 2
a53 2
static void print_record (struct type *, char *, struct ui_file *, int,
			  int, enum val_prettyprint);
d55 1
a55 5
static int print_field_values (struct type *, char *, struct ui_file *,
			       int, int, enum val_prettyprint,
			       int, struct type *, char *);

static int print_variant_part (struct type *, int, char *,
d58 1
a58 5
			       char *);

static void val_print_packed_array_elements (struct type *, char *valaddr,
					     int, struct ui_file *, int, int,
					     enum val_prettyprint);
d64 1
a64 1
static int ada_val_print_1 (struct type *, char *, int, CORE_ADDR,
a66 1
static void ada_print_floating (char *, struct type *, struct ui_file *);
d132 1
a132 1
val_print_packed_array_elements (struct type *type, char *valaddr,
d240 1
a240 1
printable_val_type (struct type *type, char *valaddr)
d293 2
a294 1
ada_print_floating (char *valaddr, struct type *type, struct ui_file *stream)
d550 4
a553 3
ada_val_print (struct type *type, char *valaddr0, int embedded_offset,
	       CORE_ADDR address, struct ui_file *stream, int format,
	       int deref_ref, int recurse, enum val_prettyprint pretty)
d585 3
a587 2
ada_val_print_1 (struct type *type, char *valaddr0, int embedded_offset,
		 CORE_ADDR address, struct ui_file *stream, int format,
d595 1
a595 1
  char *valaddr = valaddr0 + embedded_offset;
d876 1
a876 1
print_variant_part (struct type *type, int field_num, char *valaddr,
d879 1
a879 1
		    struct type *outer_type, char *outer_valaddr)
d955 3
a957 2
print_record (struct type *type, char *valaddr, struct ui_file *stream,
	      int format, int recurse, enum val_prettyprint pretty)
d988 4
a991 4
print_field_values (struct type *type, char *valaddr, struct ui_file *stream,
		    int format, int recurse, enum val_prettyprint pretty,
		    int comma_needed, struct type *outer_type,
		    char *outer_valaddr)
@


1.18
log
@2005-01-28  Andrew Cagney  <cagney@@gnu.org>

	* ada-valprint.c (char_at, printstr): Make buffer a const bfd_byte.
@
text
@d531 2
a532 2
ada_printstr (struct ui_file *stream, char *string, unsigned int length,
	      int width, int force_ellipses)
@


1.17
log
@2005-01-12  Andrew Cagney  <cagney@@gnu.org>

	* exceptions.h (enum return_reason, RETURN_MASK)
	(RETURN_MASK_QUIT, RETURN_MASK_ERROR, RETURN_MASK_ALL)
	(return_mask, throw_exception, catch_exceptions_ftype)
	(catch_exceptions_with_msg, catch_errors_ftype, catch_errors)
	(catch_command_errors_ftype, catch_command_errors): Move to
	exceptions.h.
	* exceptions.c, exceptions.h: New files.
	* top.c: Do not include <setjmp.h>.
	(SIGJMP_BUF, SIGSETJMP, SIGLONGJMP, catch_return)
	(throw_exception, catcher, catch_exceptions)
	(catch_exceptions_with_msg, struct catch_errors_args)
	(do_catch_errors, catch_errors, struct captured_command_args)
	(do_captured_command, catch_command_errors): Move to exceptions.c.
	* wrapper.c, wince.c, win32-nat.c, utils.c: Include "exceptions.h".
	* tui/tui-interp.c, top.c, thread.c, symmisc.c: Ditto.
	* symfile-mem.c, stack.c, solib.c, rs6000-nat.c: Ditto.
	* remote-sds.c, remote-mips.c, remote-fileio.c: Ditto.
	* remote-e7000.c, objc-lang.c, ocd.c: Ditto.
	* remote.c, nto-procfs.c, monitor.c, mi/mi-main.c: Ditto.
	* main.c, m32r-rom.c, infrun.c, inf-loop.c: Ditto.
	* hppa-hpux-tdep.c, frame.c, event-top.c, event-loop.c: Ditto.
	* corelow.c, corefile.c, cli/cli-interp.c, breakpoint.c: Ditto.
	* ada-valprint.c, ada-lang.c: Ditto.
	* Makefile.in (HFILES_NO_SRCDIR, COMMON_OBS): Add exceptions.h and
	exceptions.o.  Update all dependencies.
@
text
@d2 1
d4 1
a4 2
   2002, 2003, 2004.
             Free Software Foundation, Inc.
d281 1
a281 1
char_at (char *string, int i, int type_len)
d442 2
a443 2
printstr (struct ui_file *stream, char *string, unsigned int length,
	  int force_ellipses, int type_len)
@


1.16
log
@2005-01-05  Baurjan Ismagulov  <ibr@@ata.cs.hun.edu.tr>

	Committed by Andrew Cagney.
	* ada-valprint.c, aix-thread.c, alpha-nat.c: I18n markup.
	* alphabsd-nat.c, alphanbsd-tdep.c, amd64-linux-nat.c: I18n markup.
	* amd64-tdep.c,	amd64bsd-nat.c, amd64fbsd-nat.c: I18n markup.
	* arch-utils.c, arm-linux-nat.c, arm-tdep.c: I18n markup.
	* armnbsd-nat.c, armnbsd-tdep.c, auxv.c, avr-tdep.c: I18n markup.
	* aix-thread.c (_initialize_aix_thread): Get rid of the
	deprecated_add_show_from_set call.
	* alpha-tdep.c (_initialize_alpha_tdep): Ditto.
	* arm-tdep.c (_initialize_arm_tdep): Ditto.
	* command.h (add_setshow_enum_cmd): Add arguments for returning
	new list elements.
	* cli/cli-decode.c (add_setshow_enum_cmd): Ditto.
	* mips-tdep.c (_initialize_mips_tdep): Modify calls to
	add_setshow_enum_cmd.
@
text
@d36 1
@


1.15
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	* value.h (VALUE_TYPE, VALUE_NEXT, VALUE_OFFSET, VALUE_BITSIZE)
	(VALUE_BITPOS): Delete.
	(value_type, value_offset, value_bitsize, value_bitpos): Declare.
	* value.c (value_type, value_offset, value_bitpos)
	(value_bitsize): New functions.  Update references.
	* arm-tdep.c, gnu-v3-abi.c, hpacc-abi.c, gnu-v2-abi.c: Update.
	* f-valprint.c, cp-valprint.c, c-valprint.c: Update.
	* ada-valprint.c, typeprint.c, scm-valprint.c, scm-exp.c: Update.
	* p-valprint.c, jv-valprint.c, jv-lang.c, varobj.c: Update.
	* objc-lang.c, ada-lang.c, std-regs.c, stack.c: Update.
	* infcall.c, linespec.c, printcmd.c, valarith.c: Update.
	* valops.c, eval.c, findvar.c, breakpoint.c: Update.
	* tracepoint.c, ax-gdb.c, mi/mi-main.c, cli/cli-dump.c:
	* rs6000-tdep.c, ppc-sysv-tdep.c: Update.
@
text
@d209 1
a209 1
	  fprintf_filtered (stream, " <repeats %u times>", i - i0);
d424 1
a424 1
      warning ("internal error: unhandled type in ada_print_scalar");
d428 1
a428 1
      error ("Invalid type code in symbol table.");
d495 1
a495 1
	  fprintf_filtered (stream, " <repeats %u times>", reps);
d1071 1
a1071 1
	      fputs_filtered ("<optimized out or zero length>", stream);
@


1.14
log
@* ada-typeprint.c (ada_print_type): Use int_string for printing
modulus of modular type.
* ada-lang.h (ada_modulus): Change return type to unsigned.
* ada-lang.c (ada_language_arch_info): Correct type of
string_char_type.
(ada_modulus): Return unsigned result.
(ada_lookup_symbol): Remove user disambiguation and modify comment
accordingly.

2004-10-08 Eric Botcazou  <ebotcazou@@act-europe.fr>

Committed by Paul Hilfinger.
* ada-lang.c (decode_packed_array): On big-endian targets,
left-justify the value if it comes with a modular type.

2004-10-08  Joel Brobecker  <brobecker@@gnat.com>

Committed by Paul Hilfinger.
* ada-lang.c (template_to_static_fixed_type): Fix a small typo.
(is_name_suffix): Add support for "___JM" suffixes.
(ada_check_typedef): Renames ada_completed_type.
Update all users of CHECK_TYPEDEF, check_typedef, and
ada_complete_type to call ada_check_typedef.
* ada-typeprint.c: Likewise.
* ada-valprint.c: Likewise.
@
text
@d617 1
a617 1
	retn = ada_val_print_1 (VALUE_TYPE (val), VALUE_CONTENTS (val), 0,
d863 1
a863 1
		  val_print (VALUE_TYPE (deref_val),
d905 1
a905 1
  CORE_ADDR address = VALUE_ADDRESS (val0) + VALUE_OFFSET (val0);
d907 1
a907 1
    ada_to_fixed_type (VALUE_TYPE (val0), valaddr, address, NULL);
@


1.13
log
@Remove ARI problems:

* ada-exp.y (write_var_from_sym): Reformat to put operator at
beginning of line.

* ada-lang.c (MAX_OF_SIZE): Rename max_of_size.
Add comment.
Add comment concerning MAX_OF_TYPE and MIN_OF_TYPE.
(MIN_OF_SIZE): Rename min_of_size.  Add comment.
(UMAX_OF_SIZE): Renmae umax_of_size.  Add comment.
(UMIN_OF_SIZE): Remove.
(max_of_type): New function to replace orphan macro in gdbtypes.h
(min_of_type): Ditto.
(discrete_type_high_bound): Use max_of_type.
(discrete_type_low_bound): Use min_of_type.
(possible_user_operator_p): Move operator to beginning of line.
(ada_is_variant_part): Ditto.
(ensure_lval): Rewrite to avoid deprecated operations.
(ada_finish_decode_line_1): Use gdbarch_convert_from_func_ptr_addr
rather than adding DEPRECATED_FUNCTION_START_OFFSET.
(ada_enum_name): Remove assignments in 'if' statements.
(build_ada_types): Add gdbarch parameter.
(_initialize_ada_language): Replace deprecated_register_gdbarch_swap
with gdbarch_data_register_post_init.
Use add_setshow_uinteger_cmd rather than add_set_cmd and
add_show_from_set.

* ada-valprint.c (inspect_it): Remove declaration.
(repeat_count_threshold): Remove declaration.
(ada_print_floating): Remove assignments in 'if' statements.
(print_str): Move operator to beginning of line.
@
text
@d370 1
a370 1
  CHECK_TYPEDEF (type);
d602 1
a602 1
  CHECK_TYPEDEF (type);
d963 1
a963 1
  CHECK_TYPEDEF (type);
@


1.12
log
@* ada-lang.c (decode_packed_array): Minor change to comment.
(ada_value_slice_ptr): New function.
(ada_value_slice): New function.
(ada_evaluate_subexp): Remove XVS-suffix code from subscripting
test.  Don't know why it is there.
Change slice code to use ada_value_slice_ptr and ada_value_slice, and
to avoid dereferencing huge arrays from which one is slicing.
(empty_array): Correct to return an array rather than
a subrange value.
* ada-valprint.c (print_optional_low_bound): Don't print lower bound
on empty arrays (let'em use 'FIRST instead).
@
text
@a50 3
extern int inspect_it;
extern unsigned int repeat_count_threshold;

d317 7
a323 3
  if ((s = strstr (result, "inf")) != NULL
      || (s = strstr (result, "Inf")) != NULL
      || (s = strstr (result, "INF")) != NULL)
d325 2
a326 3
  else if ((s = strstr (result, "nan")) != NULL
	   || (s = strstr (result, "NaN")) != NULL
	   || (s = strstr (result, "Nan")) != NULL)
d328 11
a338 3
      s[0] = s[2] = 'N';
      if (result[0] == '-')
	result += 1;
d340 2
a341 1
  else if (strchr (result, '.') == NULL)
d343 2
a344 1
      if ((s = strchr (result, 'e')) == NULL)
d473 3
a475 3
      while (rep1 < length &&
	     char_at (string, rep1, type_len) == char_at (string, i,
							  type_len))
@


1.11
log
@Address complaints from gdb_ari.sh:

* ada-exp.y: Include gdb_string.h rather than string.h.
(convert_char_literal): Reformat declaration.
* ada-lang.h: Include opaque struct declaration for struct frame_info.
* ada-lex.l: Change use of free to xfree (the macro would do so
anyway, but this is harmless).
Include gdb_string.h rather than string.h.
* ada-valprint.c (ada_val_print_stub): Change PTR => void*.

* ada-lang.c (parse): Remove K&Rism in parameter list.
(is_name_suffix): Correct Linux => GNU/Linux in comment.
@
text
@d89 4
a92 4
/* Assuming TYPE is a simple array type, prints its lower bound on STREAM,
   if non-standard (i.e., other than 1 for numbers, other than lower bound
   of index type for enumerated type).  Returns 1 if something printed,
   otherwise 0.  */
d108 2
@


1.10
log
@ada-exp.y: Synchronize with current ACT sources.
ada-lang.c: Ditto.
ada-lang.h: Ditto.
ada-lex.l: Ditto.
ada-tasks.c: Ditto.
ada-typeprint.c: Ditto.
ada-valprint.c: Ditto.
@
text
@d72 1
a72 1
static int ada_val_print_stub (PTR args0);
d566 1
a566 1
ada_val_print_stub (PTR args0)
@


1.9
log
@2003-05-23  Andrew Cagney  <cagney@@redhat.com>

	* p-valprint.c (pascal_val_print): Replace extract_address with
	the inline equivalent extract_unsigned_integer.
	* jv-valprint.c (java_value_print): Ditto.
	* ada-valprint.c (ada_val_print_1): Ditto.
	* ada-lang.h (EXTRACT_ADDRESS): Ditto.
@
text
@d1 3
a3 2
/* Support for printing Ada values for GDB, the GNU debugger.  
   Copyright 1986, 1988, 1989, 1991, 1992, 1993, 1994, 1997, 2001
d24 1
d37 1
a37 1
/* Encapsulates arguments to ada_val_print. */
d51 3
d72 1
a72 1
static int ada_val_print_stub (void *args0);
d77 1
d80 1
a80 1
/* Make TYPE unsigned if its range of values includes no negatives. */
d91 2
a92 2
   of index type for enumerated type). Returns 1 if something printed, 
   otherwise 0. */
d136 2
a137 2
    separates with commas. RECURSE is the recursion (nesting) level.
    If PRETTY, uses "prettier" format. TYPE must have been decoded (as
a150 5
  /* Position of the array element we are examining to see
     whether it is repeated.  */
  unsigned int rep1;
  /* Number of repetitions we have detected so far.  */
  unsigned int reps;
d256 1
a256 1
   (1 or 2) of the character. */
d278 1
a278 1
   or 2) of a character. */
d289 52
d350 1
a350 1
   form appropriate for TYPE. */
d519 1
a519 1
	      int force_ellipses, int width)
d527 1
a527 1
   FORMAT (a letter as for the printf % codes or 0 for natural format).  
d564 1
a564 1
   unmarshal the arguments to ada_val_print_1, which does the work. */
d566 1
a566 1
ada_val_print_stub (void * args0)
d576 1
a576 1
 * does not catch evaluation errors (leaving that to ada_val_print). */
a587 1
  CORE_ADDR addr;
d592 1
a592 1
  if (ada_is_array_descriptor (type) || ada_is_packed_array_type (type))
d622 16
d674 1
a674 1
	  /* No special printing function.  Do as best we can. */
d684 1
a684 1
	         code regardless of lengths; I'm just avoiding a cast. */
d704 14
d761 8
d783 11
a793 5
      if (TYPE_LENGTH (type) > 0 && TYPE_LENGTH (TYPE_TARGET_TYPE (type)) > 0)
	{
	  elttype = TYPE_TARGET_TYPE (type);
	  eltlen = TYPE_LENGTH (elttype);
	  len = TYPE_LENGTH (type) / eltlen;
d796 3
a798 1
	  if (ada_is_string_type (type) && (format == 0 || format == 's'))
d800 7
a806 9
	      if (prettyprint_arrays)
		{
		  print_spaces_filtered (2 + 2 * recurse, stream);
		}
	      /* If requested, look for the first null char and only print
	         elements up to it.  */
	      if (stop_print_at_null)
		{
		  int temp_len;
d808 7
a814 7
		  /* Look for a NULL char. */
		  for (temp_len = 0;
		       temp_len < len && temp_len < print_max
		       && char_at (valaddr, temp_len, eltlen) != 0;
		       temp_len += 1);
		  len = temp_len;
		}
d816 10
a825 2
	      printstr (stream, valaddr, len, 0, eltlen);
	    }
d827 4
a830 15
	    {
	      len = 0;
	      fprintf_filtered (stream, "(");
	      print_optional_low_bound (stream, type);
	      if (TYPE_FIELD_BITSIZE (type, 0) > 0)
		val_print_packed_array_elements (type, valaddr, 0, stream,
						 format, recurse, pretty);
	      else
		val_print_array_elements (type, valaddr, address, stream,
					  format, deref_ref, recurse,
					  pretty, 0);
	      fprintf_filtered (stream, ")");
	    }
	  gdb_flush (stream);
	  return len;
d832 2
a836 11
      if (addressprint)
	{
	  fprintf_filtered (stream, "@@");
	  /* Extract an address, assume that the address is unsigned.  */
	  print_address_numeric
	    (extract_unsigned_integer (valaddr,
				       TARGET_PTR_BIT / HOST_CHAR_BIT),
	     1, stream);
	  if (deref_ref)
	    fputs_filtered (": ", stream);
	}
d864 1
d899 2
a900 2
  /* If it is a pointer, indicate what it points to. */
  if (TYPE_CODE (type) == TYPE_CODE_PTR || TYPE_CODE (type) == TYPE_CODE_REF)
d902 5
a906 10
      /* Hack:  remove (char *) for char strings.  Their
         type is indicated by the quoted string anyway. */
      if (TYPE_CODE (type) == TYPE_CODE_PTR &&
	  TYPE_LENGTH (TYPE_TARGET_TYPE (type)) == sizeof (char) &&
	  TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_INT &&
	  !TYPE_UNSIGNED (TYPE_TARGET_TYPE (type)))
	{
	  /* Print nothing */
	}
      else
d913 1
a913 1
  else if (ada_is_array_descriptor (type))
d926 17
d966 1
a966 1
  
d968 1
a968 1
   same meanings as in ada_print_value and ada_val_print.   
d973 1
a973 1
   COMMA_NEEDED is 1 if fields have been printed at the current recursion 
d975 1
a975 1
   call. 
d977 1
a977 1
   Returns 1 if COMMA_NEEDED or any fields were printed. */
@


1.9.20.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d1 2
a2 3
/* Support for printing Ada values for GDB, the GNU debugger.
   Copyright 1986, 1988, 1989, 1991, 1992, 1993, 1994, 1997, 2001,
   2002, 2003, 2004.
a22 1
#include "gdb_string.h"
d35 1
a35 1
/* Encapsulates arguments to ada_val_print.  */
a71 1
static void ada_print_floating (char *, struct type *, struct ui_file *);
d74 1
a74 1
/* Make TYPE unsigned if its range of values includes no negatives.  */
d83 4
a86 4
/* Assuming TYPE is a simple, non-empty array type, prints its lower bound 
   on STREAM, if non-standard (i.e., other than 1 for numbers, other
   than lower bound of index type for enumerated type).  Returns 1 
   if something printed, otherwise 0.  */
a101 2
      if (low_bound > TYPE_HIGH_BOUND (index_type))
	return 0;
d130 2
a131 2
    separates with commas.  RECURSE is the recursion (nesting) level.
    If PRETTY, uses "prettier" format.  TYPE must have been decoded (as
d145 5
d255 1
a255 1
   (1 or 2) of the character.  */
d277 1
a277 1
   or 2) of a character.  */
a287 65
/* Wrapper around memcpy to make it legal argument to ui_file_put */
static void
ui_memcpy (void *dest, const char *buffer, long len)
{
  memcpy (dest, buffer, (size_t) len);
  ((char *) dest)[len] = '\0';
}

/* Print a floating-point value of type TYPE, pointed to in GDB by
   VALADDR, on STREAM.  Use Ada formatting conventions: there must be
   a decimal point, and at least one digit before and after the
   point.  We use GNAT format for NaNs and infinities.  */
static void
ada_print_floating (char *valaddr, struct type *type, struct ui_file *stream)
{
  char buffer[64];
  char *s, *result;
  int len;
  struct ui_file *tmp_stream = mem_fileopen ();
  struct cleanup *cleanups = make_cleanup_ui_file_delete (tmp_stream);

  print_floating (valaddr, type, tmp_stream);
  ui_file_put (tmp_stream, ui_memcpy, buffer);
  do_cleanups (cleanups);

  result = buffer;
  len = strlen (result);

  /* Modify for Ada rules.  */
  
  s = strstr (result, "inf");
  if (s == NULL)
    s = strstr (result, "Inf");
  if (s == NULL)
    s = strstr (result, "INF");
  if (s != NULL)
    strcpy (s, "Inf");

  if (s == NULL)
    {
      s = strstr (result, "nan");
      if (s == NULL)
	s = strstr (result, "NaN");
      if (s == NULL)
	s = strstr (result, "Nan");
      if (s != NULL)
	{
	  s[0] = s[2] = 'N';
	  if (result[0] == '-')
	    result += 1;
	}
    }

  if (s == NULL && strchr (result, '.') == NULL)
    {
      s = strchr (result, 'e');
      if (s == NULL)
	fprintf_filtered (stream, "%s.0", result);
      else
	fprintf_filtered (stream, "%.*s.0%s", (int) (s-result), result, s);
      return;
    }
  fprintf_filtered (stream, "%s", result);
}

d297 1
a297 1
   form appropriate for TYPE.  */
d408 3
a410 3
      while (rep1 < length
	     && char_at (string, rep1, type_len) == char_at (string, i,
							     type_len))
d466 1
a466 1
	      int width, int force_ellipses)
d474 1
a474 1
   FORMAT (a letter as for the printf % codes or 0 for natural format).
d511 1
a511 1
   unmarshal the arguments to ada_val_print_1, which does the work.  */
d513 1
a513 1
ada_val_print_stub (void *args0)
d523 1
a523 1
 * does not catch evaluation errors (leaving that to ada_val_print).  */
d535 1
d540 1
a540 1
  if (ada_is_array_descriptor_type (type) || ada_is_packed_array_type (type))
a569 16
    case TYPE_CODE_PTR:
      {
	int ret = c_val_print (type, valaddr0, embedded_offset, address, 
			       stream, format, deref_ref, recurse, pretty);
	if (ada_is_tag_type (type))
	  {
	    struct value *val = 
	      value_from_contents_and_address (type, valaddr, address);
	    const char *name = ada_tag_name (val);
	    if (name != NULL) 
	      fprintf_filtered (stream, " (%s)", name);
	    return 0;
	}
	return ret;
      }

d606 1
a606 1
	  /* No special printing function.  Do as best we can.  */
d616 1
a616 1
	         code regardless of lengths; I'm just avoiding a cast.  */
a635 14
          else if (ada_is_system_address_type (type))
            {
              /* FIXME: We want to print System.Address variables using
                 the same format as for any access type.  But for some
                 reason GNAT encodes the System.Address type as an int,
                 so we have to work-around this deficiency by handling
                 System.Address values as a special case.  */
              fprintf_filtered (stream, "(");
              type_print (type, "", stream, -1);
              fprintf_filtered (stream, ") ");
              print_address_numeric 
		(extract_typed_address (valaddr, builtin_type_void_data_ptr),
                 1, stream);
            }
a678 8
    case TYPE_CODE_FLT:
      if (format)
	return c_val_print (type, valaddr0, embedded_offset, address, stream,
			    format, deref_ref, recurse, pretty);
      else
	ada_print_floating (valaddr0 + embedded_offset, type, stream);
      break;

d693 5
a697 11
      elttype = TYPE_TARGET_TYPE (type);
      if (elttype == NULL)
	eltlen = 0;
      else
	eltlen = TYPE_LENGTH (elttype);
      /* FIXME: This doesn't deal with non-empty arrays of
	 0-length items (not a typical case!) */
      if (eltlen == 0)
	len = 0;
      else
	len = TYPE_LENGTH (type) / eltlen;
d700 1
a700 3
      if (ada_is_string_type (type) && (format == 0 || format == 's'))
	{
	  if (prettyprint_arrays)
d702 19
a720 1
	      print_spaces_filtered (2 + 2 * recurse, stream);
d722 1
a722 3
	  /* If requested, look for the first null char and only print
	     elements up to it.  */
	  if (stop_print_at_null)
d724 11
a734 8
	      int temp_len;

	      /* Look for a NULL char.  */
	      for (temp_len = 0;
		   temp_len < len && temp_len < print_max
		     && char_at (valaddr, temp_len, eltlen) != 0;
		   temp_len += 1);
	      len = temp_len;
d736 2
a737 2

	  printstr (stream, valaddr, len, 0, eltlen);
a738 16
      else
	{
	  len = 0;
	  fprintf_filtered (stream, "(");
	  print_optional_low_bound (stream, type);
	  if (TYPE_FIELD_BITSIZE (type, 0) > 0)
	    val_print_packed_array_elements (type, valaddr, 0, stream,
					     format, recurse, pretty);
	  else
	    val_print_array_elements (type, valaddr, address, stream,
				      format, deref_ref, recurse,
				      pretty, 0);
	  fprintf_filtered (stream, ")");
	}
      gdb_flush (stream);
      return len;
d742 11
a779 1
  gdb_flush (stream);
d814 2
a815 2
  /* If it is a pointer, indicate what it points to.  */
  if (TYPE_CODE (type) == TYPE_CODE_PTR)
d817 10
a826 5
      /* Hack:  don't print (char *) for char strings.  Their
         type is indicated by the quoted string anyway.  */
      if (TYPE_LENGTH (TYPE_TARGET_TYPE (type)) != sizeof (char)
	  || TYPE_CODE (TYPE_TARGET_TYPE (type)) != TYPE_CODE_INT 
	  || TYPE_UNSIGNED (TYPE_TARGET_TYPE (type)))
d833 1
a833 1
  else if (ada_is_array_descriptor_type (type))
a845 17

  if (TYPE_CODE (type) == TYPE_CODE_ARRAY
      && TYPE_LENGTH (TYPE_TARGET_TYPE (type)) == 0
      && TYPE_CODE (TYPE_INDEX_TYPE (type)) == TYPE_CODE_RANGE)
    {
      /* This is an array of zero-length elements, that is an array
         of null records.  This array needs to be printed by hand,
         as the standard routine to print arrays relies on the size of
         the array elements to be nonzero.  This is because it computes
         the number of elements in the array by dividing the array size
         by the array element size.  */
      fprintf_filtered (stream, "(%d .. %d => ())",
                        TYPE_LOW_BOUND (TYPE_INDEX_TYPE (type)),
                        TYPE_HIGH_BOUND (TYPE_INDEX_TYPE (type)));
      return 0;
    }
  
d869 1
a869 1

d871 1
a871 1
   same meanings as in ada_print_value and ada_val_print.
d876 1
a876 1
   COMMA_NEEDED is 1 if fields have been printed at the current recursion
d878 1
a878 1
   call.
d880 1
a880 1
   Returns 1 if COMMA_NEEDED or any fields were printed.  */
@


1.8
log
@2003-05-15  Andrew Cagney  <cagney@@redhat.com>

	* c-lang.c (c_printstr): Delete "extern inspect_it" declaration.
	* p-valprint.c (pascal_object_print_value_fields): Ditto.
	* p-lang.c (pascal_printstr): Ditto.
	* objc-lang.c (objc_printstr): Ditto.
	* m2-lang.c (m2_printstr): Ditto.
	* jv-valprint.c (java_print_value_fields): Ditto.
	* f-lang.c (f_printstr): Ditto.
	* cp-valprint.c (cp_print_value_fields): Ditto.  Include "valprint.h".
	* ada-valprint.c (inspect_it, repeat_count_threshold): Ditto, and
	for repeat_count_threshold.
	* Makefile.in (cp-valprint.o): Update dependencies.
@
text
@d745 1
d747 3
a749 2
	    (extract_address (valaddr,
			      TARGET_PTR_BIT / HOST_CHAR_BIT), 1, stream);
@


1.7
log
@2003-04-21  Andrew Cagney  <cagney@@redhat.com>

	* infcall.c: New file.
	* infcall.h: New file.
	* valarith.c: Include "infcall.h".
	* scm-lang.c, objc-lang.cm, hppa-tdep.c, gcore.c: Ditto.
	* eval.c, ada-valprint.c, ada-lang.c: Ditto.
	* Makefile.in (valarith.o, scm-lang.o): Update dependencies.
	(objc-lang.o, hppa-tdep.o, gcore.o): Update dependencies.
	(eval.o, ada-valprint.o, ada-lang.o): Update dependencies.
	(SFILES): Add "infcall.c"
	(COMMON_OBS): Add "infcall.o".
	(infcall.o): Specify dependencies.
	* value.h (call_function_by_hand): Delete declaration.
	* inferior.h (run_stack_dummy): Delete declaration.
	* infcmd.c (breakpoint_auto_delete_contents): Move to "infcall.c".
	(run_stack_dummy): Move to "infcall.c", merged into
	call_function_by_hand.
	* valops.c (call_function_by_hand): Moved to "infcall.c".
	(find_function_addr, value_arg_coerce): Ditto.
	(unwindonsignal_p, coerce_float_to_double): Ditto.
	(_initialize_valops): Move "set/show coerce-float-to-double", and
	"set/show unwindonsignal" commands to "infcall.c".
	* v850-tdep.c, target.h: Update comments.
	* sparc-tdep.c (sparc_fix_call_dummy): Update comments.
	* sh-tdep.c (sh_init_extra_frame_info): Update comments.
	(sh64_init_extra_frame_info): Update comments.
	* mn10300-tdep.c: Update comments.
	* mcore-tdep.c (mcore_init_extra_frame_info): Update comments.
	* config/sparc/tm-sparc.h: Update comments.
	* breakpoint.h: Update comments.
	* avr-tdep.c (avr_init_extra_frame_info): Update comments.
	* arm-tdep.c: Update comment.
@
text
@a48 3
extern int inspect_it;
extern unsigned int repeat_count_threshold;

@


1.6
log
@2003-01-18  Andrew Cagney  <ac131313@@redhat.com>

	* ada-valprint.c: Eliminate PTR.
	* breakpoint.c, corelow.c, cris-tdep.c, dbxread.c: Ditto.
	* defs.h, dve3900-rom.c, dwarf2read.c, dwarfread.c: Ditto.
	* exec.c, hppa-tdep.c, hpread.c, infcmd.c, mdebugread.c: Ditto.
	* objfiles.c, objfiles.h, ocd.c, remote-es.c: Ditto.
	* remote-mips.c, remote-sds.c, remote-vx.c: Ditto.
	* solib-svr4.c, solib.c, stack.c, symfile.c, symfile.h: Ditto.
	* symmisc.c, v850ice.c, xcoffread.c, cli/cli-script.c: Ditto.
@
text
@d33 1
@


1.6.18.1
log
@Merge from mainline.
@
text
@a32 1
#include "infcall.h"
@


1.6.18.2
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d49 3
@


1.5
log
@	* ada-lang.c (ada_array_bound, ada_type_match,
	_initialize_ada_language): Fix K&R definitions.
	* ada-tasks.c (get_current_task): Fix K&R definitions.
	* ada-valprint.c (adjust_type_signedness): Fix K&R definitions.
@
text
@d69 1
a69 1
static int ada_val_print_stub (PTR args0);
d515 1
a515 1
ada_val_print_stub (PTR args0)
@


1.5.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a32 1
#include "infcall.h"
d48 3
d69 1
a69 1
static int ada_val_print_stub (void *args0);
d515 1
a515 1
ada_val_print_stub (void * args0)
a746 1
	  /* Extract an address, assume that the address is unsigned.  */
d748 2
a749 3
	    (extract_unsigned_integer (valaddr,
				       TARGET_PTR_BIT / HOST_CHAR_BIT),
	     1, stream);
@


1.5.2.1
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d69 1
a69 1
static int ada_val_print_stub (void *args0);
d515 1
a515 1
ada_val_print_stub (void * args0)
@


1.5.2.2
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@a32 1
#include "infcall.h"
@


1.5.2.3
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d49 3
@


1.5.2.4
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@a744 1
	  /* Extract an address, assume that the address is unsigned.  */
d746 2
a747 3
	    (extract_unsigned_integer (valaddr,
				       TARGET_PTR_BIT / HOST_CHAR_BIT),
	     1, stream);
@


1.4
log
@        * ada-lang.c: run through gdb_indent.sh
        * ada-lang.h: run through gdb_indent.sh
        * ada-tasks.c: run through gdb_indent.sh
        * ada-typeprint.c: run through gdb_indent.sh
        * ada-valprint.c: run through gdb_indent.sh
@
text
@d78 1
a78 2
adjust_type_signedness (type)
     struct type *type;
@


1.4.6.1
log
@Import ada-lang.c, ada-tasks.c and ada-valprint.c from mainline.
@
text
@d78 2
a79 1
adjust_type_signedness (struct type *type)
@


1.3
log
@	* ada-lang.c (ada_lookup_partial_symbol)
	(to_fixed_variant_branch_type) (find_line_in_linetable): Fix
	prototype names so that grep ^func works properly.

	* ada-lang.c (ada_array_element_type)
	(ada_lookup_partial_symbol): Fix typos in parameter list.

	* ada-valprint.c (val_print_packed_array_elements) (ada_val_print_1):
	Fix prototype names so that grep ^func works properly.
@
text
@d35 4
a38 3
struct ada_val_print_args {
  struct type* type;
  char* valaddr0;
d51 1
a51 1
static void print_record (struct type*, char*, struct ui_file*, int,
d54 1
a54 1
static int print_field_values (struct type*, char*, struct ui_file*, 
d56 1
a56 1
			       int, struct type*, char*);
d58 4
a61 3
static int print_variant_part (struct type*, int, char*, 
			       struct ui_file*, int, int, enum val_prettyprint,
			       int, struct type*, char*);
d63 2
a64 2
static void val_print_packed_array_elements (struct type*, char *valaddr, int,
					     struct ui_file*, int, int, 
d67 1
a67 1
static void adjust_type_signedness (struct type*);
d71 3
a73 2
static int ada_val_print_1 (struct type*, char*, int, CORE_ADDR, struct ui_file*,
			    int, int, int, enum val_prettyprint);
d77 1
a77 1
static void 
d79 1
a79 1
     struct type* type;
d81 1
a81 1
  if (type != NULL && TYPE_CODE (type) == TYPE_CODE_RANGE 
d84 1
a84 1
}	
d91 1
a91 1
static int 
d102 1
a102 1
  if (TYPE_CODE (index_type) == TYPE_CODE_RANGE) 
d109 15
a123 14
      
  switch (TYPE_CODE (index_type)) {
  case TYPE_CODE_ENUM:
    if (low_bound == TYPE_FIELD_BITPOS (index_type, 0))
      return 0;
    break;
  case TYPE_CODE_UNDEF:
    index_type = builtin_type_long;
    /* FALL THROUGH */
  default:
    if (low_bound == 1)
      return 0;
    break;
  }
d135 1
a135 1
    by ada_coerce_to_simple_array).  */ 
d154 2
a155 2
  struct value* mark = value_mark ();
      
d190 1
a190 1
      v0 = ada_value_primitive_packed_val (NULL, valaddr, 
d199 1
a199 1
	  v1 = ada_value_primitive_packed_val (NULL, valaddr, 
d203 1
a203 2
	  if (memcmp (VALUE_CONTENTS (v0), VALUE_CONTENTS (v1), eltlen) 
	      != 0)
d221 1
a221 1
	      if (j > i0) 
d250 2
a251 2
static struct type*
printable_val_type (struct type* type, char* valaddr)
d276 1
a276 1
    fprintf_filtered (stream, "[\"%0*x\"]", type_len*2, c);
d283 1
a283 1
char_at (char* string, int i, int type_len)
d287 2
a288 2
  else 
    return (int) extract_unsigned_integer (string + 2*i, 2);
d396 1
a396 1
	 to see whether it is repeated.  */
d411 3
a413 2
      while (rep1 < length && 
	     char_at(string, rep1, type_len) == char_at (string, i, type_len))
d430 2
a431 1
	  ada_emit_char (char_at (string, i, type_len), stream, '\'', type_len);
d495 1
a495 1
ada_val_print (struct type* type, char* valaddr0, int embedded_offset,
d500 2
a501 1
  args.type = type; args.valaddr0 = valaddr0; 
d518 5
a522 5
  struct ada_val_print_args* argsp = (struct ada_val_print_args*) args0;
  return ada_val_print_1 (argsp->type, argsp->valaddr0, argsp->embedded_offset,
			  argsp->address, argsp->stream, argsp->format,
			  argsp->deref_ref, argsp->recurse,
			  argsp->pretty);
d529 1
a529 1
ada_val_print_1 (struct type* type, char* valaddr0, int embedded_offset,
d539 1
a539 1
  char* valaddr = valaddr0 + embedded_offset;
d546 2
a547 2
      struct value* mark = value_mark ();
      struct value* val;
d557 1
a557 1
				VALUE_ADDRESS (val), stream, format, 
d570 1
a570 1
      return c_val_print (type, valaddr0, embedded_offset, address, stream, 
d586 1
a586 1
	  struct value* val = 
d588 1
a588 1
	  struct value* func = ada_vax_float_print_function (type);
d591 2
a592 2
	      static struct type* parray_of_char = NULL;
	      struct value* printable_val;
d594 6
a599 7
	      if (parray_of_char == NULL) 
		parray_of_char = 
		  make_pointer_type 
		    (create_array_type 
		      (NULL, builtin_type_char,
		       create_range_type (NULL, builtin_type_int, 0, 32)),
		     NULL);
d601 1
a601 1
	      printable_val = 
d603 3
a605 2
				       call_function_by_hand (func, 1, &val)));
	      
d613 1
a613 1
	  struct type* target_type = TYPE_TARGET_TYPE (type);
d617 6
a622 6
		 its base type.  Perform a conversion, or we will get a
		 nonsense value.  Actually, we could use the same
		 code regardless of lengths; I'm just avoiding a cast. */
	      struct value* v = 
		value_cast (target_type, 
			    value_from_contents_and_address (type, valaddr, 0));
d627 1
a627 1
	    return ada_val_print_1 (TYPE_TARGET_TYPE (type), 
d629 1
a629 1
				    address,  stream, format, deref_ref, 
d632 1
a632 1
      else 
d670 2
a671 2
	  const char* name = ada_enum_name (TYPE_FIELD_NAME (type, i));
	  if (name[0] == '\'') 
d681 1
a681 1
      
d688 1
a688 1
	}			      
d691 1
a691 2
	  print_record (type, valaddr, stream, format,
			recurse, pretty);
d701 1
a701 1
	      
d703 1
a703 2
	  if (ada_is_string_type (type) 
	      && (format == 0 || format == 's'))
d710 1
a710 1
		 elements up to it.  */
d714 1
a714 1
		  
d722 1
a722 1
	      
d730 1
a730 1
	      if (TYPE_FIELD_BITSIZE (type, 0) > 0) 
d732 1
a732 2
						 format, recurse,
						 pretty);
d746 1
a746 1
        {
d753 1
a753 1
        }
d759 2
a760 2
	      LONGEST deref_val_int = (LONGEST) 
		unpack_pointer (lookup_pointer_type (builtin_type_void), 
d762 1
a762 1
	      if (deref_val_int != 0) 
d764 3
a766 3
		  struct value* deref_val =
		    ada_value_ind (value_from_longest 
				   (lookup_pointer_type (elttype), 
d791 1
a791 2
  int which = 
    ada_which_variant_applies (var_type, outer_type, outer_valaddr);
d796 1
a796 1
    return print_field_values 
d805 1
a805 1
ada_value_print (struct value* val0, struct ui_file *stream, int format,
d808 1
a808 1
  char* valaddr = VALUE_CONTENTS (val0);
d810 1
a810 1
  struct type* type = 
d812 2
a813 1
  struct value* val = value_from_contents_and_address (type, valaddr, address);
d816 1
a816 2
  if (TYPE_CODE (type) == TYPE_CODE_PTR ||
      TYPE_CODE (type) == TYPE_CODE_REF)
d819 1
a819 1
	 type is indicated by the quoted string anyway. */
d821 1
a821 1
	  TYPE_LENGTH (TYPE_TARGET_TYPE (type)) == sizeof(char) &&
d834 1
a834 1
  else if (ada_is_array_descriptor (type)) 
d847 1
a847 1
  return (val_print (type, VALUE_CONTENTS (val), 0, address, 
d850 1
a850 1
 
d860 1
a860 2
			  0, type, valaddr) != 0
      && pretty)
d896 1
a896 1
	  continue;
d900 1
a900 1
	  comma_needed = 
d902 1
a902 1
				valaddr 
d926 1
a926 1
      else 
d946 1
a946 1
	  fprintf_filtered (stream, "%.*s", 
d956 1
a956 1
	  struct value* v;
d969 1
a969 1
      
d974 1
a974 1
						  bit_size, 
d976 1
a976 1
	      val_print (TYPE_FIELD_TYPE(type, i), VALUE_CONTENTS (v), 0, 0,
d981 3
a983 3
	  ada_val_print (TYPE_FIELD_TYPE (type, i), 
		         valaddr + TYPE_FIELD_BITPOS (type, i) / HOST_CHAR_BIT,
		         0, 0, stream, format, 0, recurse + 1, pretty);
@


1.2
log
@        * ada-lang.c: Change k&r style function definitions to prototyped
        form.
        * ada-typeprint.c: Change k&r style function definitions to prototyped
        form.
        * ada-valprint.c: Change k&r style function definitions to prototyped
        form.
@
text
@d61 3
a63 4
static void
val_print_packed_array_elements (struct type*, char *valaddr, int,
				 struct ui_file*, int, int, 
				 enum val_prettyprint);
d69 2
a70 3
static int
ada_val_print_1 (struct type*, char*, int, CORE_ADDR, struct ui_file*,
		 int, int, int, enum val_prettyprint);
@


1.1
log
@Add base ada language files
@
text
@d91 1
a91 3
print_optional_low_bound (stream, type)
     struct ui_file *stream;
     struct type *type;
d136 4
a139 9
val_print_packed_array_elements (type, valaddr, bitoffset, stream, format, 
				 recurse, pretty)
     struct type *type;
     char *valaddr;
     int bitoffset;
     struct ui_file *stream;
     int format;
     int recurse;
     enum val_prettyprint pretty;
d250 1
a250 3
printable_val_type (type, valaddr)
     struct type* type;
     char* valaddr;
d260 1
a260 5
ada_emit_char (c, stream, quoter, type_len)
     int c;
     struct ui_file *stream;
     int quoter;
     int type_len;
d282 1
a282 4
char_at (string, i, type_len)
     char* string;
     int i;
     int type_len;
d291 1
a291 3
ada_printchar (c, stream)
     int c;
     struct ui_file *stream;
d302 1
a302 4
ada_print_scalar (type, val, stream)
     struct type *type;
     LONGEST val;
     struct ui_file *stream;
d378 2
a379 6
printstr (stream, string, length, force_ellipses, type_len)
     struct ui_file *stream;
     char *string;
     unsigned int length;
     int force_ellipses;
     int type_len;
d465 2
a466 6
ada_printstr (stream, string, length, force_ellipses, width)
     struct ui_file *stream;
     char *string;
     unsigned int length;
     int force_ellipses;
     int width;
d492 3
a494 11
ada_val_print (type, valaddr0, embedded_offset, address, stream,
	       format, deref_ref, recurse, pretty)
     struct type* type;
     char* valaddr0;
     int embedded_offset;
     CORE_ADDR address;
     struct ui_file *stream;
     int format;
     int deref_ref;
     int recurse;
     enum val_prettyprint pretty;
d525 3
a527 11
ada_val_print_1 (type, valaddr0, embedded_offset, address, stream,
		 format, deref_ref, recurse, pretty)
     struct type* type;
     char* valaddr0;
     int embedded_offset;
     CORE_ADDR address;
     struct ui_file *stream;
     int format;
     int deref_ref;
     int recurse;
     enum val_prettyprint pretty;
d784 4
a787 13
print_variant_part (type, field_num, valaddr, 
		    stream, format, recurse, pretty, comma_needed,
		    outer_type, outer_valaddr)
     struct type *type;
     int field_num;
     char *valaddr;
     struct ui_file *stream;
     int format;
     int recurse;
     enum val_prettyprint pretty;
     int comma_needed;
     struct type *outer_type;
     char *outer_valaddr;
d805 2
a806 5
ada_value_print (val0, stream, format, pretty)
     struct value* val0;
     struct ui_file *stream;
     int format;
     enum val_prettyprint pretty;
d852 2
a853 7
print_record (type, valaddr, stream, format, recurse, pretty)
     struct type *type;
     char *valaddr;
     struct ui_file *stream;
     int format;
     int recurse;
     enum val_prettyprint pretty;
d885 4
a888 11
print_field_values (type, valaddr, stream, format, recurse, pretty, 
		    comma_needed, outer_type, outer_valaddr)
     struct type *type;
     char *valaddr;
     struct ui_file *stream;
     int format;
     int recurse;
     enum val_prettyprint pretty;
     int comma_needed;
     struct type *outer_type;
     char *outer_valaddr;
@


1.1.4.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@@


1.1.4.2
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d91 3
a93 1
print_optional_low_bound (struct ui_file *stream, struct type *type)
d138 9
a146 4
val_print_packed_array_elements (struct type *type, char *valaddr,
				 int bitoffset, struct ui_file *stream,
				 int format, int recurse,
				 enum val_prettyprint pretty)
d257 3
a259 1
printable_val_type (struct type* type, char* valaddr)
d269 5
a273 1
ada_emit_char (int c, struct ui_file *stream, int quoter, int type_len)
d295 4
a298 1
char_at (char* string, int i, int type_len)
d307 3
a309 1
ada_printchar (int c, struct ui_file *stream)
d320 4
a323 1
ada_print_scalar (struct type *type, LONGEST val, struct ui_file *stream)
d399 6
a404 2
printstr (struct ui_file *stream, char *string, unsigned int length,
	  int force_ellipses, int type_len)
d490 6
a495 2
ada_printstr (struct ui_file *stream, char *string, unsigned int length,
	      int force_ellipses, int width)
d521 11
a531 3
ada_val_print (struct type* type, char* valaddr0, int embedded_offset,
	       CORE_ADDR address, struct ui_file *stream, int format,
	       int deref_ref, int recurse, enum val_prettyprint pretty)
d562 11
a572 3
ada_val_print_1 (struct type* type, char* valaddr0, int embedded_offset,
		 CORE_ADDR address, struct ui_file *stream, int format,
		 int deref_ref, int recurse, enum val_prettyprint pretty)
d829 13
a841 4
print_variant_part (struct type *type, int field_num, char *valaddr,
		    struct ui_file *stream, int format, int recurse,
		    enum val_prettyprint pretty, int comma_needed,
		    struct type *outer_type, char *outer_valaddr)
d859 5
a863 2
ada_value_print (struct value* val0, struct ui_file *stream, int format,
		 enum val_prettyprint pretty)
d909 7
a915 2
print_record (struct type *type, char *valaddr, struct ui_file *stream,
	      int format, int recurse, enum val_prettyprint pretty)
d947 11
a957 4
print_field_values (struct type *type, char *valaddr, struct ui_file *stream,
		    int format, int recurse, enum val_prettyprint pretty,
		    int comma_needed, struct type *outer_type,
		    char *outer_valaddr)
@


1.1.4.3
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d35 3
a37 4
struct ada_val_print_args
{
  struct type *type;
  char *valaddr0;
d50 1
a50 1
static void print_record (struct type *, char *, struct ui_file *, int,
d53 1
a53 1
static int print_field_values (struct type *, char *, struct ui_file *,
d55 5
a59 1
			       int, struct type *, char *);
d61 4
a64 8
static int print_variant_part (struct type *, int, char *,
			       struct ui_file *, int, int,
			       enum val_prettyprint, int, struct type *,
			       char *);

static void val_print_packed_array_elements (struct type *, char *valaddr,
					     int, struct ui_file *, int, int,
					     enum val_prettyprint);
d66 1
a66 1
static void adjust_type_signedness (struct type *);
d70 3
a72 3
static int ada_val_print_1 (struct type *, char *, int, CORE_ADDR,
			    struct ui_file *, int, int, int,
			    enum val_prettyprint);
d76 1
a76 1
static void
d78 1
a78 1
     struct type *type;
d80 1
a80 1
  if (type != NULL && TYPE_CODE (type) == TYPE_CODE_RANGE
d83 1
a83 1
}
d90 1
a90 1
static int
d101 1
a101 1
  if (TYPE_CODE (index_type) == TYPE_CODE_RANGE)
d108 14
a121 15

  switch (TYPE_CODE (index_type))
    {
    case TYPE_CODE_ENUM:
      if (low_bound == TYPE_FIELD_BITPOS (index_type, 0))
	return 0;
      break;
    case TYPE_CODE_UNDEF:
      index_type = builtin_type_long;
      /* FALL THROUGH */
    default:
      if (low_bound == 1)
	return 0;
      break;
    }
d133 1
a133 1
    by ada_coerce_to_simple_array).  */
d152 2
a153 2
  struct value *mark = value_mark ();

d188 1
a188 1
      v0 = ada_value_primitive_packed_val (NULL, valaddr,
d197 1
a197 1
	  v1 = ada_value_primitive_packed_val (NULL, valaddr,
d201 2
a202 1
	  if (memcmp (VALUE_CONTENTS (v0), VALUE_CONTENTS (v1), eltlen) != 0)
d220 1
a220 1
	      if (j > i0)
d249 2
a250 2
static struct type *
printable_val_type (struct type *type, char *valaddr)
d275 1
a275 1
    fprintf_filtered (stream, "[\"%0*x\"]", type_len * 2, c);
d282 1
a282 1
char_at (char *string, int i, int type_len)
d286 2
a287 2
  else
    return (int) extract_unsigned_integer (string + 2 * i, 2);
d395 1
a395 1
         to see whether it is repeated.  */
d410 2
a411 3
      while (rep1 < length &&
	     char_at (string, rep1, type_len) == char_at (string, i,
							  type_len))
d428 1
a428 2
	  ada_emit_char (char_at (string, i, type_len), stream, '\'',
			 type_len);
d492 1
a492 1
ada_val_print (struct type *type, char *valaddr0, int embedded_offset,
d497 1
a497 2
  args.type = type;
  args.valaddr0 = valaddr0;
d514 5
a518 5
  struct ada_val_print_args *argsp = (struct ada_val_print_args *) args0;
  return ada_val_print_1 (argsp->type, argsp->valaddr0,
			  argsp->embedded_offset, argsp->address,
			  argsp->stream, argsp->format, argsp->deref_ref,
			  argsp->recurse, argsp->pretty);
d525 1
a525 1
ada_val_print_1 (struct type *type, char *valaddr0, int embedded_offset,
d535 1
a535 1
  char *valaddr = valaddr0 + embedded_offset;
d542 2
a543 2
      struct value *mark = value_mark ();
      struct value *val;
d553 1
a553 1
				VALUE_ADDRESS (val), stream, format,
d566 1
a566 1
      return c_val_print (type, valaddr0, embedded_offset, address, stream,
d582 1
a582 1
	  struct value *val =
d584 1
a584 1
	  struct value *func = ada_vax_float_print_function (type);
d587 2
a588 2
	      static struct type *parray_of_char = NULL;
	      struct value *printable_val;
d590 7
a596 6
	      if (parray_of_char == NULL)
		parray_of_char =
		  make_pointer_type
		  (create_array_type
		   (NULL, builtin_type_char,
		    create_range_type (NULL, builtin_type_int, 0, 32)), NULL);
d598 1
a598 1
	      printable_val =
d600 2
a601 3
				       call_function_by_hand (func, 1,
							      &val)));

d609 1
a609 1
	  struct type *target_type = TYPE_TARGET_TYPE (type);
d613 6
a618 6
	         its base type.  Perform a conversion, or we will get a
	         nonsense value.  Actually, we could use the same
	         code regardless of lengths; I'm just avoiding a cast. */
	      struct value *v = value_cast (target_type,
					    value_from_contents_and_address
					    (type, valaddr, 0));
d623 1
a623 1
	    return ada_val_print_1 (TYPE_TARGET_TYPE (type),
d625 1
a625 1
				    address, stream, format, deref_ref,
d628 1
a628 1
      else
d666 2
a667 2
	  const char *name = ada_enum_name (TYPE_FIELD_NAME (type, i));
	  if (name[0] == '\'')
d677 1
a677 1

d684 1
a684 1
	}
d687 2
a688 1
	  print_record (type, valaddr, stream, format, recurse, pretty);
d698 1
a698 1

d700 2
a701 1
	  if (ada_is_string_type (type) && (format == 0 || format == 's'))
d708 1
a708 1
	         elements up to it.  */
d712 1
a712 1

d720 1
a720 1

d728 1
a728 1
	      if (TYPE_FIELD_BITSIZE (type, 0) > 0)
d730 2
a731 1
						 format, recurse, pretty);
d745 1
a745 1
	{
d752 1
a752 1
	}
d758 2
a759 2
	      LONGEST deref_val_int = (LONGEST)
		unpack_pointer (lookup_pointer_type (builtin_type_void),
d761 1
a761 1
	      if (deref_val_int != 0)
d763 3
a765 3
		  struct value *deref_val =
		    ada_value_ind (value_from_longest
				   (lookup_pointer_type (elttype),
d790 2
a791 1
  int which = ada_which_variant_applies (var_type, outer_type, outer_valaddr);
d796 1
a796 1
    return print_field_values
d805 1
a805 1
ada_value_print (struct value *val0, struct ui_file *stream, int format,
d808 1
a808 1
  char *valaddr = VALUE_CONTENTS (val0);
d810 1
a810 1
  struct type *type =
d812 1
a812 2
  struct value *val =
    value_from_contents_and_address (type, valaddr, address);
d815 2
a816 1
  if (TYPE_CODE (type) == TYPE_CODE_PTR || TYPE_CODE (type) == TYPE_CODE_REF)
d819 1
a819 1
         type is indicated by the quoted string anyway. */
d821 1
a821 1
	  TYPE_LENGTH (TYPE_TARGET_TYPE (type)) == sizeof (char) &&
d834 1
a834 1
  else if (ada_is_array_descriptor (type))
d847 1
a847 1
  return (val_print (type, VALUE_CONTENTS (val), 0, address,
d850 1
a850 1

d860 2
a861 1
			  0, type, valaddr) != 0 && pretty)
d897 1
a897 1
	continue;
d901 1
a901 1
	  comma_needed =
d903 1
a903 1
				valaddr
d927 1
a927 1
      else
d947 1
a947 1
	  fprintf_filtered (stream, "%.*s",
d957 1
a957 1
	  struct value *v;
d970 1
a970 1

d975 1
a975 1
						  bit_size,
d977 1
a977 1
	      val_print (TYPE_FIELD_TYPE (type, i), VALUE_CONTENTS (v), 0, 0,
d982 3
a984 3
	ada_val_print (TYPE_FIELD_TYPE (type, i),
		       valaddr + TYPE_FIELD_BITPOS (type, i) / HOST_CHAR_BIT,
		       0, 0, stream, format, 0, recurse + 1, pretty);
@


1.1.4.4
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d78 2
a79 1
adjust_type_signedness (struct type *type)
@


1.1.2.1
log
@merge from trunk
@
text
@@

