head	1.381;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.377.2.1
	gdb_7_6-2013-04-26-release:1.377.2.1
	gdb_7_6-branch:1.377.0.2
	gdb_7_6-2013-03-12-branchpoint:1.377
	gdb_7_5_1-2012-11-29-release:1.365
	gdb_7_5-2012-08-17-release:1.365
	gdb_7_5-branch:1.365.0.2
	gdb_7_5-2012-07-18-branchpoint:1.365
	gdb_7_4_1-2012-04-26-release:1.354.2.2
	gdb_7_4-2012-01-24-release:1.354.2.2
	gdb_7_4-branch:1.354.0.2
	gdb_7_4-2011-12-13-branchpoint:1.354
	gdb_7_3_1-2011-09-04-release:1.339.2.2
	gdb_7_3-2011-07-26-release:1.339.2.2
	gdb_7_3-branch:1.339.0.2
	gdb_7_3-2011-04-01-branchpoint:1.339
	gdb_7_2-2010-09-02-release:1.304.2.2
	gdb_7_2-branch:1.304.0.2
	gdb_7_2-2010-07-07-branchpoint:1.304
	gdb_7_1-2010-03-18-release:1.296.2.1
	gdb_7_1-branch:1.296.0.2
	gdb_7_1-2010-02-18-branchpoint:1.296
	gdb_7_0_1-2009-12-22-release:1.288.2.1
	gdb_7_0-2009-10-06-release:1.288
	gdb_7_0-branch:1.288.0.2
	gdb_7_0-2009-09-16-branchpoint:1.288
	arc-sim-20090309:1.257
	msnyder-checkpoint-072509-branch:1.282.0.2
	msnyder-checkpoint-072509-branchpoint:1.282
	arc-insight_6_8-branch:1.257.0.6
	arc-insight_6_8-branchpoint:1.257
	insight_6_8-branch:1.257.0.4
	insight_6_8-branchpoint:1.257
	reverse-20081226-branch:1.273.0.4
	reverse-20081226-branchpoint:1.273
	multiprocess-20081120-branch:1.273.0.2
	multiprocess-20081120-branchpoint:1.273
	reverse-20080930-branch:1.272.0.2
	reverse-20080930-branchpoint:1.272
	reverse-20080717-branch:1.266.0.4
	reverse-20080717-branchpoint:1.266
	msnyder-reverse-20080609-branch:1.266.0.2
	msnyder-reverse-20080609-branchpoint:1.266
	drow-reverse-20070409-branch:1.225.0.2
	drow-reverse-20070409-branchpoint:1.225
	gdb_6_8-2008-03-27-release:1.257
	gdb_6_8-branch:1.257.0.2
	gdb_6_8-2008-02-26-branchpoint:1.257
	gdb_6_7_1-2007-10-29-release:1.242
	gdb_6_7-2007-10-10-release:1.242
	gdb_6_7-branch:1.242.0.2
	gdb_6_7-2007-09-07-branchpoint:1.242
	insight_6_6-20070208-release:1.216
	gdb_6_6-2006-12-18-release:1.216
	gdb_6_6-branch:1.216.0.2
	gdb_6_6-2006-11-15-branchpoint:1.216
	insight_6_5-20061003-release:1.208
	gdb-csl-symbian-6_4_50_20060226-12:1.205.2.4.2.5
	gdb-csl-sourcerygxx-3_4_4-25:1.201
	nickrob-async-20060828-mergepoint:1.214
	gdb-csl-symbian-6_4_50_20060226-11:1.205.2.4.2.5
	gdb-csl-sourcerygxx-4_1-17:1.205.2.5
	gdb-csl-20060226-branch-local-2:1.205.2.5
	gdb-csl-sourcerygxx-4_1-14:1.205.2.5
	gdb-csl-sourcerygxx-4_1-13:1.205.2.5
	gdb-csl-sourcerygxx-4_1-12:1.205.2.5
	gdb-csl-sourcerygxx-3_4_4-21:1.205.2.5
	gdb_6_5-20060621-release:1.208
	gdb-csl-sourcerygxx-4_1-9:1.205.2.5
	gdb-csl-sourcerygxx-4_1-8:1.205.2.5
	gdb-csl-sourcerygxx-4_1-7:1.205.2.5
	gdb-csl-arm-2006q1-6:1.205.2.5
	gdb-csl-sourcerygxx-4_1-6:1.205.2.5
	gdb-csl-symbian-6_4_50_20060226-10:1.205.2.4.2.5
	gdb-csl-symbian-6_4_50_20060226-9:1.205.2.4.2.5
	gdb-csl-symbian-6_4_50_20060226-8:1.205.2.4.2.5
	gdb-csl-coldfire-4_1-11:1.205.2.5
	gdb-csl-sourcerygxx-3_4_4-19:1.205.2.5
	gdb-csl-coldfire-4_1-10:1.205.2.5
	gdb_6_5-branch:1.208.0.8
	gdb_6_5-2006-05-14-branchpoint:1.208
	gdb-csl-sourcerygxx-4_1-5:1.205.2.5
	nickrob-async-20060513-branch:1.208.0.6
	nickrob-async-20060513-branchpoint:1.208
	gdb-csl-sourcerygxx-4_1-4:1.205.2.5
	msnyder-reverse-20060502-branch:1.208.0.4
	msnyder-reverse-20060502-branchpoint:1.208
	gdb-csl-morpho-4_1-4:1.205.2.4
	gdb-csl-sourcerygxx-3_4_4-17:1.205.2.4
	readline_5_1-import-branch:1.208.0.2
	readline_5_1-import-branchpoint:1.208
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.205.2.4
	gdb-csl-symbian-20060226-branch:1.205.2.4.0.2
	gdb-csl-symbian-20060226-branchpoint:1.205.2.4
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.205.2.4
	msnyder-reverse-20060331-branch:1.206.0.2
	msnyder-reverse-20060331-branchpoint:1.206
	gdb-csl-available-20060303-branch:1.205.0.4
	gdb-csl-available-20060303-branchpoint:1.205
	gdb-csl-20060226-branch:1.205.0.2
	gdb-csl-20060226-branchpoint:1.205
	gdb_6_4-20051202-release:1.201
	msnyder-fork-checkpoint-branch:1.201.0.8
	msnyder-fork-checkpoint-branchpoint:1.201
	gdb-csl-gxxpro-6_3-branch:1.201.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.201
	gdb_6_4-branch:1.201.0.4
	gdb_6_4-2005-11-01-branchpoint:1.201
	gdb-csl-arm-20051020-branch:1.201.0.2
	gdb-csl-arm-20051020-branchpoint:1.201
	msnyder-tracepoint-checkpoint-branch:1.198.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.198
	gdb-csl-arm-20050325-2005-q1b:1.194.2.4
	gdb-csl-arm-20050325-2005-q1a:1.194.2.4
	csl-arm-20050325-branch:1.194.0.2
	csl-arm-20050325-branchpoint:1.194
	gdb-post-i18n-errorwarning-20050211:1.189
	gdb-pre-i18n-errorwarning-20050211:1.189
	gdb_6_3-20041109-release:1.183
	gdb_6_3-branch:1.183.0.2
	gdb_6_3-20041019-branchpoint:1.183
	drow_intercu-merge-20040921:1.183
	drow_intercu-merge-20040915:1.183
	jimb-gdb_6_2-e500-branch:1.177.0.6
	jimb-gdb_6_2-e500-branchpoint:1.177
	gdb_6_2-20040730-release:1.177
	gdb_6_2-branch:1.177.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.177
	gdb_6_1_1-20040616-release:1.164.4.4
	gdb_6_1-2004-04-05-release:1.164.4.4
	drow_intercu-merge-20040402:1.169
	drow_intercu-merge-20040327:1.169
	ezannoni_pie-20040323-branch:1.168.0.2
	ezannoni_pie-20040323-branchpoint:1.168
	cagney_tramp-20040321-mergepoint:1.167
	cagney_tramp-20040309-branch:1.167.0.2
	cagney_tramp-20040309-branchpoint:1.167
	gdb_6_1-branch:1.164.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.164
	drow_intercu-20040221-branch:1.164.0.2
	drow_intercu-20040221-branchpoint:1.164
	cagney_bfdfile-20040213-branch:1.161.0.2
	cagney_bfdfile-20040213-branchpoint:1.161
	drow-cplus-merge-20040208:1.159
	carlton_dictionary-20040126-merge:1.158
	cagney_bigcore-20040122-branch:1.158.0.2
	cagney_bigcore-20040122-branchpoint:1.158
	drow-cplus-merge-20040113:1.155
	drow-cplus-merge-20031224:1.155
	drow-cplus-merge-20031220:1.155
	carlton_dictionary-20031215-merge:1.155
	drow-cplus-merge-20031214:1.155
	carlton-dictionary-20031111-merge:1.154
	gdb_6_0-2003-10-04-release:1.143
	kettenis_sparc-20030918-branch:1.150.0.4
	kettenis_sparc-20030918-branchpoint:1.150
	carlton_dictionary-20030917-merge:1.150
	ezannoni_pie-20030916-branchpoint:1.150
	ezannoni_pie-20030916-branch:1.150.0.2
	cagney_x86i386-20030821-branch:1.143.0.6
	cagney_x86i386-20030821-branchpoint:1.143
	carlton_dictionary-20030805-merge:1.143
	carlton_dictionary-20030627-merge:1.143
	gdb_6_0-branch:1.143.0.4
	gdb_6_0-2003-06-23-branchpoint:1.143
	jimb-ppc64-linux-20030613-branch:1.143.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.143
	cagney_convert-20030606-branch:1.137.0.2
	cagney_convert-20030606-branchpoint:1.137
	cagney_writestrings-20030508-branch:1.132.0.4
	cagney_writestrings-20030508-branchpoint:1.132
	jimb-ppc64-linux-20030528-branch:1.135.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.135
	carlton_dictionary-20030523-merge:1.135
	cagney_fileio-20030521-branch:1.135.0.2
	cagney_fileio-20030521-branchpoint:1.135
	kettenis_i386newframe-20030517-mergepoint:1.135
	jimb-ppc64-linux-20030509-branch:1.132.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.132
	kettenis_i386newframe-20030504-mergepoint:1.131
	carlton_dictionary-20030430-merge:1.131
	kettenis_i386newframe-20030419-branch:1.129.0.2
	kettenis_i386newframe-20030419-branchpoint:1.129
	carlton_dictionary-20030416-merge:1.129
	cagney_frameaddr-20030409-mergepoint:1.128
	kettenis_i386newframe-20030406-branch:1.127.0.2
	kettenis_i386newframe-20030406-branchpoint:1.127
	cagney_frameaddr-20030403-branchpoint:1.125
	cagney_frameaddr-20030403-branch:1.125.0.2
	cagney_framebase-20030330-mergepoint:1.120
	cagney_framebase-20030326-branch:1.116.0.2
	cagney_framebase-20030326-branchpoint:1.116
	cagney_lazyid-20030317-branch:1.107.0.2
	cagney_lazyid-20030317-branchpoint:1.107
	kettenis-i386newframe-20030316-mergepoint:1.107
	offbyone-20030313-branch:1.106.0.2
	offbyone-20030313-branchpoint:1.106
	kettenis-i386newframe-20030308-branch:1.105.0.4
	kettenis-i386newframe-20030308-branchpoint:1.105
	carlton_dictionary-20030305-merge:1.105
	cagney_offbyone-20030303-branch:1.105.0.2
	cagney_offbyone-20030303-branchpoint:1.105
	carlton_dictionary-20030207-merge:1.98
	interps-20030203-mergepoint:1.98
	interps-20030202-branch:1.97.0.4
	interps-20030202-branchpoint:1.97
	cagney-unwind-20030108-branch:1.97.0.2
	cagney-unwind-20030108-branchpoint:1.97
	carlton_dictionary-20021223-merge:1.84
	gdb_5_3-2002-12-12-release:1.69
	carlton_dictionary-20021115-merge:1.75
	kseitz_interps-20021105-merge:1.74
	kseitz_interps-20021103-merge:1.74
	drow-cplus-merge-20021020:1.73
	drow-cplus-merge-20021025:1.73
	carlton_dictionary-20021025-merge:1.73
	carlton_dictionary-20021011-merge:1.73
	drow-cplus-branch:1.73.0.4
	drow-cplus-branchpoint:1.73
	kseitz_interps-20020930-merge:1.73
	carlton_dictionary-20020927-merge:1.73
	carlton_dictionary-branch:1.73.0.2
	carlton_dictionary-20020920-branchpoint:1.73
	gdb_5_3-branch:1.69.0.6
	gdb_5_3-2002-09-04-branchpoint:1.69
	kseitz_interps-20020829-merge:1.69
	cagney_sysregs-20020825-branch:1.69.0.4
	cagney_sysregs-20020825-branchpoint:1.69
	readline_4_3-import-branch:1.69.0.2
	readline_4_3-import-branchpoint:1.69
	gdb_5_2_1-2002-07-23-release:1.48
	kseitz_interps-20020528-branch:1.62.0.2
	kseitz_interps-20020528-branchpoint:1.62
	cagney_regbuf-20020515-branch:1.60.0.2
	cagney_regbuf-20020515-branchpoint:1.60
	jimb-macro-020506-branch:1.57.0.2
	jimb-macro-020506-branchpoint:1.57
	gdb_5_2-2002-04-29-release:1.48
	gdb_5_2-branch:1.48.0.2
	gdb_5_2-2002-03-03-branchpoint:1.48
	gdb_5_1_1-2002-01-24-release:1.13
	gdb_5_1_0_1-2002-01-03-release:1.13
	cygnus_cvs_20020108_pre:1.25
	gdb_5_1_0_1-2002-01-03-branchpoint:1.13
	gdb_5_1_0_1-2002-01-03-branch:1.13.0.6
	gdb_5_1-2001-11-21-release:1.13
	gdb_s390-2001-09-26-branch:1.13.0.4
	gdb_s390-2001-09-26-branchpoint:1.13
	gdb_5_1-2001-07-29-branch:1.13.0.2
	gdb_5_1-2001-07-29-branchpoint:1.13
	dberlin-typesystem-branch:1.12.0.2
	dberlin-typesystem-branchpoint:1.12
	gdb-post-ptid_t-2001-05-03:1.12
	gdb-pre-ptid_t-2001-05-03:1.12
	insight-precleanup-2001-01-01:1.9
	gdb-post-protoization-2000-07-29:1.7
	gdb-pre-protoization-2000-07-29:1.7
	gdb-premipsmulti-2000-06-06-branch:1.6.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.6
	gdb-post-params-removal-2000-06-04:1.6
	gdb-pre-params-removal-2000-06-04:1.6
	gdb-post-params-removal-2000-05-28:1.6
	gdb-pre-params-removal-2000-05-28:1.6
	gdb_5_0-2000-05-19-release:1.5
	gdb_4_18_2-2000-05-18-release:1.5
	gdb_4_95_1-2000-05-11-snapshot:1.5
	gdb_4_95_0-2000-04-27-snapshot:1.5
	gdb_5_0-2000-04-10-branch:1.5.0.2
	gdb_5_0-2000-04-10-branchpoint:1.5
	repo-unification-2000-02-06:1.1.1.13
	insight-2000-02-04:1.1.1.13
	gdb-2000-02-04:1.1.1.13
	gdb-2000-02-02:1.1.1.12
	gdb-2000-02-01:1.1.1.11
	gdb-2000-01-31:1.1.1.11
	gdb-2000-01-26:1.1.1.10
	gdb-2000-01-24:1.1.1.10
	gdb-2000-01-17:1.1.1.10
	gdb-2000-01-10:1.1.1.10
	gdb-2000-01-05:1.1.1.10
	gdb-1999-12-21:1.1.1.10
	gdb-1999-12-13:1.1.1.9
	gdb-1999-12-07:1.1.1.9
	gdb-1999-12-06:1.1.1.9
	gdb-1999-11-16:1.1.1.9
	gdb-1999-11-08:1.1.1.9
	gdb-1999-11-01:1.1.1.9
	gdb-1999-10-25:1.1.1.8
	gdb-1999-10-18:1.1.1.8
	gdb-1999-10-11:1.1.1.8
	gdb-1999-10-04:1.1.1.8
	gdb-1999-09-28:1.1.1.8
	gdb-1999-09-21:1.1.1.8
	gdb-1999-09-13:1.1.1.8
	gdb-1999-09-08:1.1.1.8
	gdb-1999-08-30:1.1.1.8
	gdb-1999-08-23:1.1.1.7
	gdb-1999-08-16:1.1.1.7
	gdb-1999-08-09:1.1.1.6
	gdb-1999-08-02:1.1.1.5
	gdb-1999-07-26:1.1.1.5
	gdb-1999-07-19:1.1.1.5
	gdb-1999-07-12:1.1.1.5
	gdb-post-reformat-19990707:1.1.1.5
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.5
	gdb-pre-reformat-19990707:1.1.1.4
	gdb-1999-07-07:1.1.1.4
	gdb-1999-07-05:1.1.1.4
	gdb-1999-06-28:1.1.1.4
	gdb-1999-06-21:1.1.1.3
	gdb-1999-06-14:1.1.1.3
	gdb-1999-06-07:1.1.1.3
	gdb-1999-06-01:1.1.1.3
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.3
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.381
date	2013.06.24.22.18.31;	author macro;	state Exp;
branches;
next	1.380;

1.380
date	2013.04.22.09.20.32;	author sergiodj;	state Exp;
branches;
next	1.379;

1.379
date	2013.04.19.15.09.45;	author palves;	state Exp;
branches;
next	1.378;

1.378
date	2013.04.08.19.59.08;	author tromey;	state Exp;
branches;
next	1.377;

1.377
date	2013.03.11.08.45.54;	author mmetzger;	state Exp;
branches
	1.377.2.1;
next	1.376;

1.376
date	2013.03.11.08.42.55;	author mmetzger;	state Exp;
branches;
next	1.375;

1.375
date	2013.03.01.15.38.23;	author palves;	state Exp;
branches;
next	1.374;

1.374
date	2013.01.01.06.32.38;	author brobecke;	state Exp;
branches;
next	1.373;

1.373
date	2012.11.21.00.29.54;	author qiyao;	state Exp;
branches;
next	1.372;

1.372
date	2012.11.20.22.51.04;	author muller;	state Exp;
branches;
next	1.371;

1.371
date	2012.11.14.03.49.12;	author qiyao;	state Exp;
branches;
next	1.370;

1.370
date	2012.11.09.19.57.57;	author tromey;	state Exp;
branches;
next	1.369;

1.369
date	2012.11.07.20.10.12;	author palves;	state Exp;
branches;
next	1.368;

1.368
date	2012.09.26.12.14.30;	author kvbhat;	state Exp;
branches;
next	1.367;

1.367
date	2012.08.22.19.47.56;	author jsm28;	state Exp;
branches;
next	1.366;

1.366
date	2012.08.16.07.36.17;	author qiyao;	state Exp;
branches;
next	1.365;

1.365
date	2012.06.25.12.32.45;	author mgretton;	state Exp;
branches;
next	1.364;

1.364
date	2012.05.18.21.02.47;	author sergiodj;	state Exp;
branches;
next	1.363;

1.363
date	2012.05.16.14.35.02;	author macro;	state Exp;
branches;
next	1.362;

1.362
date	2012.04.26.15.20.14;	author jlarmour;	state Exp;
branches;
next	1.361;

1.361
date	2012.04.20.23.39.57;	author jlarmour;	state Exp;
branches;
next	1.360;

1.360
date	2012.03.27.15.46.33;	author ozapawandeep;	state Exp;
branches;
next	1.359;

1.359
date	2012.03.15.18.53.42;	author jlarmour;	state Exp;
branches;
next	1.358;

1.358
date	2012.02.02.20.19.12;	author devans;	state Exp;
branches;
next	1.357;

1.357
date	2012.01.28.18.08.16;	author jkratoch;	state Exp;
branches;
next	1.356;

1.356
date	2012.01.04.08.16.56;	author brobecke;	state Exp;
branches;
next	1.355;

1.355
date	2011.12.21.21.13.15;	author uweigand;	state Exp;
branches;
next	1.354;

1.354
date	2011.12.07.20.53.08;	author uweigand;	state Exp;
branches
	1.354.2.1;
next	1.353;

1.353
date	2011.11.09.00.53.40;	author meadori;	state Exp;
branches;
next	1.352;

1.352
date	2011.10.13.08.16.49;	author qiyao;	state Exp;
branches;
next	1.351;

1.351
date	2011.10.11.07.31.29;	author qiyao;	state Exp;
branches;
next	1.350;

1.350
date	2011.09.18.14.34.54;	author qiyao;	state Exp;
branches;
next	1.349;

1.349
date	2011.09.18.14.18.07;	author qiyao;	state Exp;
branches;
next	1.348;

1.348
date	2011.09.17.14.37.59;	author qiyao;	state Exp;
branches;
next	1.347;

1.347
date	2011.06.30.18.48.19;	author tromey;	state Exp;
branches;
next	1.346;

1.346
date	2011.06.15.16.39.27;	author uweigand;	state Exp;
branches;
next	1.345;

1.345
date	2011.04.28.04.59.21;	author qiyao;	state Exp;
branches;
next	1.344;

1.344
date	2011.04.19.18.04.06;	author tromey;	state Exp;
branches;
next	1.343;

1.343
date	2011.04.07.04.18.02;	author qiyao;	state Exp;
branches;
next	1.342;

1.342
date	2011.04.07.03.42.51;	author qiyao;	state Exp;
branches;
next	1.341;

1.341
date	2011.04.01.19.38.15;	author uweigand;	state Exp;
branches;
next	1.340;

1.340
date	2011.04.01.11.57.02;	author uweigand;	state Exp;
branches;
next	1.339;

1.339
date	2011.03.25.21.05.23;	author uweigand;	state Exp;
branches
	1.339.2.1;
next	1.338;

1.338
date	2011.03.21.17.28.04;	author uweigand;	state Exp;
branches;
next	1.337;

1.337
date	2011.03.18.18.52.29;	author palves;	state Exp;
branches;
next	1.336;

1.336
date	2011.03.18.18.38.41;	author palves;	state Exp;
branches;
next	1.335;

1.335
date	2011.03.11.14.48.55;	author qiyao;	state Exp;
branches;
next	1.334;

1.334
date	2011.03.08.01.04.35;	author qiyao;	state Exp;
branches;
next	1.333;

1.333
date	2011.03.03.02.18.24;	author qiyao;	state Exp;
branches;
next	1.332;

1.332
date	2011.03.02.05.33.37;	author qiyao;	state Exp;
branches;
next	1.331;

1.331
date	2011.03.01.18.20.23;	author uweigand;	state Exp;
branches;
next	1.330;

1.330
date	2011.02.26.02.07.07;	author msnyder;	state Exp;
branches;
next	1.329;

1.329
date	2011.02.21.15.03.37;	author uweigand;	state Exp;
branches;
next	1.328;

1.328
date	2011.02.18.05.01.53;	author qiyao;	state Exp;
branches;
next	1.327;

1.327
date	2011.02.16.14.54.42;	author qiyao;	state Exp;
branches;
next	1.326;

1.326
date	2011.02.15.14.26.34;	author qiyao;	state Exp;
branches;
next	1.325;

1.325
date	2011.02.03.18.34.55;	author uweigand;	state Exp;
branches;
next	1.324;

1.324
date	2011.02.02.19.45.32;	author uweigand;	state Exp;
branches;
next	1.323;

1.323
date	2011.02.02.19.44.44;	author uweigand;	state Exp;
branches;
next	1.322;

1.322
date	2011.02.02.18.03.35;	author uweigand;	state Exp;
branches;
next	1.321;

1.321
date	2011.01.14.20.37.13;	author qiyao;	state Exp;
branches;
next	1.320;

1.320
date	2011.01.11.15.09.59;	author msnyder;	state Exp;
branches;
next	1.319;

1.319
date	2011.01.07.19.36.15;	author msnyder;	state Exp;
branches;
next	1.318;

1.318
date	2011.01.01.15.32.57;	author brobecke;	state Exp;
branches;
next	1.317;

1.317
date	2010.12.28.13.26.46;	author qiyao;	state Exp;
branches;
next	1.316;

1.316
date	2010.12.23.14.38.34;	author qiyao;	state Exp;
branches;
next	1.315;

1.315
date	2010.12.23.03.20.10;	author qiyao;	state Exp;
branches;
next	1.314;

1.314
date	2010.12.20.06.19.05;	author qiyao;	state Exp;
branches;
next	1.313;

1.313
date	2010.11.18.16.38.20;	author muller;	state Exp;
branches;
next	1.312;

1.312
date	2010.11.14.12.10.59;	author muller;	state Exp;
branches;
next	1.311;

1.311
date	2010.10.19.21.30.54;	author uweigand;	state Exp;
branches;
next	1.310;

1.310
date	2010.10.12.08.46.15;	author mgretton;	state Exp;
branches;
next	1.309;

1.309
date	2010.10.08.13.31.07;	author uweigand;	state Exp;
branches;
next	1.308;

1.308
date	2010.10.08.13.24.55;	author uweigand;	state Exp;
branches;
next	1.307;

1.307
date	2010.08.30.15.26.28;	author qiyao;	state Exp;
branches;
next	1.306;

1.306
date	2010.08.24.15.56.14;	author drow;	state Exp;
branches;
next	1.305;

1.305
date	2010.08.14.00.45.39;	author uweigand;	state Exp;
branches;
next	1.304;

1.304
date	2010.05.27.19.06.12;	author tromey;	state Exp;
branches
	1.304.2.1;
next	1.303;

1.303
date	2010.05.05.15.05.57;	author muller;	state Exp;
branches;
next	1.302;

1.302
date	2010.03.31.22.10.07;	author rearnsha;	state Exp;
branches;
next	1.301;

1.301
date	2010.03.24.20.23.13;	author drow;	state Exp;
branches;
next	1.300;

1.300
date	2010.03.04.19.00.19;	author devans;	state Exp;
branches;
next	1.299;

1.299
date	2010.03.04.16.39.57;	author devans;	state Exp;
branches;
next	1.298;

1.298
date	2010.03.04.13.42.12;	author drow;	state Exp;
branches;
next	1.297;

1.297
date	2010.02.26.20.46.00;	author drow;	state Exp;
branches;
next	1.296;

1.296
date	2010.02.01.16.16.26;	author drow;	state Exp;
branches
	1.296.2.1;
next	1.295;

1.295
date	2010.02.01.16.13.15;	author drow;	state Exp;
branches;
next	1.294;

1.294
date	2010.01.01.07.31.29;	author brobecke;	state Exp;
branches;
next	1.293;

1.293
date	2009.11.13.22.34.33;	author drow;	state Exp;
branches;
next	1.292;

1.292
date	2009.10.28.20.17.36;	author drow;	state Exp;
branches;
next	1.291;

1.291
date	2009.10.19.09.51.40;	author palves;	state Exp;
branches;
next	1.290;

1.290
date	2009.10.13.22.48.45;	author drow;	state Exp;
branches;
next	1.289;

1.289
date	2009.10.06.21.27.59;	author muller;	state Exp;
branches;
next	1.288;

1.288
date	2009.09.11.18.51.31;	author devans;	state Exp;
branches
	1.288.2.1;
next	1.287;

1.287
date	2009.09.03.18.52.02;	author brobecke;	state Exp;
branches;
next	1.286;

1.286
date	2009.08.14.00.32.31;	author palves;	state Exp;
branches;
next	1.285;

1.285
date	2009.07.30.23.05.04;	author jules;	state Exp;
branches;
next	1.284;

1.284
date	2009.07.28.18.26.49;	author drow;	state Exp;
branches;
next	1.283;

1.283
date	2009.07.28.17.30.52;	author drow;	state Exp;
branches;
next	1.282;

1.282
date	2009.07.02.17.25.52;	author uweigand;	state Exp;
branches;
next	1.281;

1.281
date	2009.07.02.17.21.05;	author uweigand;	state Exp;
branches;
next	1.280;

1.280
date	2009.07.02.17.12.24;	author uweigand;	state Exp;
branches;
next	1.279;

1.279
date	2009.07.02.12.55.30;	author uweigand;	state Exp;
branches;
next	1.278;

1.278
date	2009.07.02.12.48.53;	author uweigand;	state Exp;
branches;
next	1.277;

1.277
date	2009.07.02.12.46.18;	author uweigand;	state Exp;
branches;
next	1.276;

1.276
date	2009.06.17.18.43.24;	author uweigand;	state Exp;
branches;
next	1.275;

1.275
date	2009.06.17.18.39.13;	author uweigand;	state Exp;
branches;
next	1.274;

1.274
date	2009.01.03.05.57.50;	author brobecke;	state Exp;
branches;
next	1.273;

1.273
date	2008.10.01.16.41.27;	author tromey;	state Exp;
branches;
next	1.272;

1.272
date	2008.09.22.15.02.54;	author jlarmour;	state Exp;
branches;
next	1.271;

1.271
date	2008.09.11.14.23.15;	author uweigand;	state Exp;
branches;
next	1.270;

1.270
date	2008.09.05.11.42.31;	author uweigand;	state Exp;
branches;
next	1.269;

1.269
date	2008.08.26.17.21.29;	author uweigand;	state Exp;
branches;
next	1.268;

1.268
date	2008.08.21.13.19.18;	author palves;	state Exp;
branches;
next	1.267;

1.267
date	2008.08.11.19.00.25;	author shebs;	state Exp;
branches;
next	1.266;

1.266
date	2008.05.19.15.50.09;	author uweigand;	state Exp;
branches
	1.266.2.1
	1.266.4.1;
next	1.265;

1.265
date	2008.05.16.00.27.22;	author drow;	state Exp;
branches;
next	1.264;

1.264
date	2008.05.02.20.38.15;	author drow;	state Exp;
branches;
next	1.263;

1.263
date	2008.05.02.17.24.50;	author drow;	state Exp;
branches;
next	1.262;

1.262
date	2008.05.02.16.00.35;	author drow;	state Exp;
branches;
next	1.261;

1.261
date	2008.05.01.18.32.52;	author drow;	state Exp;
branches;
next	1.260;

1.260
date	2008.05.01.18.30.50;	author drow;	state Exp;
branches;
next	1.259;

1.259
date	2008.04.30.21.23.45;	author drow;	state Exp;
branches;
next	1.258;

1.258
date	2008.04.22.11.03.41;	author corinna;	state Exp;
branches;
next	1.257;

1.257
date	2008.02.20.14.34.42;	author deuling;	state Exp;
branches;
next	1.256;

1.256
date	2008.01.24.15.11.13;	author palves;	state Exp;
branches;
next	1.255;

1.255
date	2008.01.11.14.43.14;	author deuling;	state Exp;
branches;
next	1.254;

1.254
date	2008.01.11.13.19.59;	author deuling;	state Exp;
branches;
next	1.253;

1.253
date	2008.01.01.22.53.09;	author drow;	state Exp;
branches;
next	1.252;

1.252
date	2007.12.06.16.32.58;	author deuling;	state Exp;
branches;
next	1.251;

1.251
date	2007.11.19.05.06.24;	author deuling;	state Exp;
branches;
next	1.250;

1.250
date	2007.11.15.13.53.11;	author deuling;	state Exp;
branches;
next	1.249;

1.249
date	2007.11.07.06.32.59;	author deuling;	state Exp;
branches;
next	1.248;

1.248
date	2007.11.02.14.27.13;	author uweigand;	state Exp;
branches;
next	1.247;

1.247
date	2007.10.30.21.43.33;	author uweigand;	state Exp;
branches;
next	1.246;

1.246
date	2007.10.15.19.45.30;	author drow;	state Exp;
branches;
next	1.245;

1.245
date	2007.10.10.14.04.53;	author drow;	state Exp;
branches;
next	1.244;

1.244
date	2007.10.08.12.49.03;	author uweigand;	state Exp;
branches;
next	1.243;

1.243
date	2007.09.27.18.48.32;	author drow;	state Exp;
branches;
next	1.242;

1.242
date	2007.09.07.12.13.45;	author drow;	state Exp;
branches;
next	1.241;

1.241
date	2007.08.23.18.08.26;	author brobecke;	state Exp;
branches;
next	1.240;

1.240
date	2007.08.14.15.47.00;	author drow;	state Exp;
branches;
next	1.239;

1.239
date	2007.06.19.22.44.13;	author jsm28;	state Exp;
branches;
next	1.238;

1.238
date	2007.06.18.18.58.13;	author uweigand;	state Exp;
branches;
next	1.237;

1.237
date	2007.06.15.22.44.55;	author uweigand;	state Exp;
branches;
next	1.236;

1.236
date	2007.06.15.22.41.13;	author uweigand;	state Exp;
branches;
next	1.235;

1.235
date	2007.06.15.22.39.51;	author uweigand;	state Exp;
branches;
next	1.234;

1.234
date	2007.06.15.22.37.34;	author uweigand;	state Exp;
branches;
next	1.233;

1.233
date	2007.06.15.22.34.13;	author uweigand;	state Exp;
branches;
next	1.232;

1.232
date	2007.06.09.13.49.20;	author uweigand;	state Exp;
branches;
next	1.231;

1.231
date	2007.06.09.13.42.15;	author uweigand;	state Exp;
branches;
next	1.230;

1.230
date	2007.05.31.20.57.41;	author uweigand;	state Exp;
branches;
next	1.229;

1.229
date	2007.05.31.17.32.20;	author uweigand;	state Exp;
branches;
next	1.228;

1.228
date	2007.05.16.15.31.11;	author uweigand;	state Exp;
branches;
next	1.227;

1.227
date	2007.04.14.18.10.54;	author uweigand;	state Exp;
branches;
next	1.226;

1.226
date	2007.04.12.14.52.19;	author uweigand;	state Exp;
branches;
next	1.225;

1.225
date	2007.03.30.22.50.33;	author palves;	state Exp;
branches
	1.225.2.1;
next	1.224;

1.224
date	2007.02.27.20.17.18;	author drow;	state Exp;
branches;
next	1.223;

1.223
date	2007.02.26.19.18.52;	author drow;	state Exp;
branches;
next	1.222;

1.222
date	2007.02.08.21.00.29;	author drow;	state Exp;
branches;
next	1.221;

1.221
date	2007.01.29.17.31.05;	author drow;	state Exp;
branches;
next	1.220;

1.220
date	2007.01.25.20.17.26;	author pbrook;	state Exp;
branches;
next	1.219;

1.219
date	2007.01.09.17.58.49;	author drow;	state Exp;
branches;
next	1.218;

1.218
date	2007.01.03.18.05.43;	author drow;	state Exp;
branches;
next	1.217;

1.217
date	2006.11.22.18.51.58;	author drow;	state Exp;
branches;
next	1.216;

1.216
date	2006.11.12.11.06.31;	author bjh21;	state Exp;
branches;
next	1.215;

1.215
date	2006.11.02.21.32.22;	author drow;	state Exp;
branches;
next	1.214;

1.214
date	2006.08.01.18.27.51;	author kettenis;	state Exp;
branches;
next	1.213;

1.213
date	2006.07.31.17.33.30;	author fnf;	state Exp;
branches;
next	1.212;

1.212
date	2006.07.19.18.21.36;	author kettenis;	state Exp;
branches;
next	1.211;

1.211
date	2006.07.16.10.33.25;	author kettenis;	state Exp;
branches;
next	1.210;

1.210
date	2006.06.23.13.01.05;	author drow;	state Exp;
branches;
next	1.209;

1.209
date	2006.05.17.14.40.39;	author drow;	state Exp;
branches;
next	1.208;

1.208
date	2006.04.18.19.20.05;	author drow;	state Exp;
branches
	1.208.6.1;
next	1.207;

1.207
date	2006.03.30.16.48.47;	author drow;	state Exp;
branches;
next	1.206;

1.206
date	2006.03.08.14.22.47;	author pbrook;	state Exp;
branches;
next	1.205;

1.205
date	2006.02.15.17.36.11;	author pbrook;	state Exp;
branches
	1.205.2.1
	1.205.4.1;
next	1.204;

1.204
date	2006.01.15.14.51.28;	author kettenis;	state Exp;
branches;
next	1.203;

1.203
date	2005.12.22.17.06.25;	author drow;	state Exp;
branches;
next	1.202;

1.202
date	2005.12.17.22.33.59;	author eliz;	state Exp;
branches;
next	1.201;

1.201
date	2005.09.26.02.17.31;	author pbrook;	state Exp;
branches
	1.201.2.1;
next	1.200;

1.200
date	2005.06.12.12.57.21;	author kettenis;	state Exp;
branches;
next	1.199;

1.199
date	2005.06.12.12.15.31;	author kettenis;	state Exp;
branches;
next	1.198;

1.198
date	2005.05.22.20.11.12;	author kettenis;	state Exp;
branches;
next	1.197;

1.197
date	2005.04.14.18.40.25;	author drow;	state Exp;
branches;
next	1.196;

1.196
date	2005.03.29.16.56.40;	author drow;	state Exp;
branches;
next	1.195;

1.195
date	2005.03.25.21.28.05;	author drow;	state Exp;
branches;
next	1.194;

1.194
date	2005.03.03.15.14.09;	author drow;	state Exp;
branches
	1.194.2.1;
next	1.193;

1.193
date	2005.02.21.07.15.47;	author cagney;	state Exp;
branches;
next	1.192;

1.192
date	2005.02.17.13.49.48;	author cagney;	state Exp;
branches;
next	1.191;

1.191
date	2005.02.16.17.20.57;	author cagney;	state Exp;
branches;
next	1.190;

1.190
date	2005.02.14.16.18.38;	author cagney;	state Exp;
branches;
next	1.189;

1.189
date	2005.02.10.17.32.46;	author cagney;	state Exp;
branches;
next	1.188;

1.188
date	2005.02.09.23.14.58;	author cagney;	state Exp;
branches;
next	1.187;

1.187
date	2005.02.09.21.56.11;	author cagney;	state Exp;
branches;
next	1.186;

1.186
date	2005.02.07.00.09.53;	author cagney;	state Exp;
branches;
next	1.185;

1.185
date	2005.01.05.15.43.43;	author cagney;	state Exp;
branches;
next	1.184;

1.184
date	2004.11.12.21.45.05;	author cagney;	state Exp;
branches;
next	1.183;

1.183
date	2004.08.03.02.02.20;	author cagney;	state Exp;
branches;
next	1.182;

1.182
date	2004.08.02.19.44.39;	author cagney;	state Exp;
branches;
next	1.181;

1.181
date	2004.08.01.19.34.50;	author cagney;	state Exp;
branches;
next	1.180;

1.180
date	2004.07.31.21.53.16;	author cagney;	state Exp;
branches;
next	1.179;

1.179
date	2004.07.28.17.26.26;	author cagney;	state Exp;
branches;
next	1.178;

1.178
date	2004.07.26.14.52.59;	author cagney;	state Exp;
branches;
next	1.177;

1.177
date	2004.06.20.17.18.04;	author cagney;	state Exp;
branches;
next	1.176;

1.176
date	2004.06.18.21.36.15;	author cagney;	state Exp;
branches;
next	1.175;

1.175
date	2004.06.10.13.22.05;	author cagney;	state Exp;
branches;
next	1.174;

1.174
date	2004.06.07.02.02.45;	author tausq;	state Exp;
branches;
next	1.173;

1.173
date	2004.05.08.21.27.02;	author cagney;	state Exp;
branches;
next	1.172;

1.172
date	2004.05.08.20.16.33;	author cagney;	state Exp;
branches;
next	1.171;

1.171
date	2004.04.30.23.47.56;	author cagney;	state Exp;
branches;
next	1.170;

1.170
date	2004.04.22.17.02.31;	author cagney;	state Exp;
branches;
next	1.169;

1.169
date	2004.03.25.16.52.42;	author drow;	state Exp;
branches;
next	1.168;

1.168
date	2004.03.23.14.47.55;	author cagney;	state Exp;
branches;
next	1.167;

1.167
date	2004.03.09.17.08.25;	author drow;	state Exp;
branches;
next	1.166;

1.166
date	2004.03.09.15.44.26;	author drow;	state Exp;
branches;
next	1.165;

1.165
date	2004.03.07.20.03.12;	author drow;	state Exp;
branches;
next	1.164;

1.164
date	2004.02.16.21.49.21;	author cagney;	state Exp;
branches
	1.164.2.1
	1.164.4.1;
next	1.163;

1.163
date	2004.02.16.21.39.46;	author cagney;	state Exp;
branches;
next	1.162;

1.162
date	2004.02.14.15.46.32;	author ezannoni;	state Exp;
branches;
next	1.161;

1.161
date	2004.02.12.18.43.09;	author cagney;	state Exp;
branches;
next	1.160;

1.160
date	2004.02.11.15.40.27;	author cagney;	state Exp;
branches;
next	1.159;

1.159
date	2004.01.26.20.51.58;	author cagney;	state Exp;
branches;
next	1.158;

1.158
date	2004.01.17.21.58.54;	author drow;	state Exp;
branches;
next	1.157;

1.157
date	2004.01.17.15.34.11;	author cagney;	state Exp;
branches;
next	1.156;

1.156
date	2004.01.13.21.38.45;	author cagney;	state Exp;
branches;
next	1.155;

1.155
date	2003.11.11.20.04.52;	author chastain;	state Exp;
branches;
next	1.154;

1.154
date	2003.10.31.23.47.17;	author cagney;	state Exp;
branches;
next	1.153;

1.153
date	2003.10.02.20.28.28;	author cagney;	state Exp;
branches;
next	1.152;

1.152
date	2003.09.29.13.27.39;	author guitton;	state Exp;
branches;
next	1.151;

1.151
date	2003.09.25.14.21.00;	author guitton;	state Exp;
branches;
next	1.150;

1.150
date	2003.09.14.16.32.12;	author cagney;	state Exp;
branches;
next	1.149;

1.149
date	2003.09.12.18.40.16;	author cagney;	state Exp;
branches;
next	1.148;

1.148
date	2003.09.09.03.58.18;	author cagney;	state Exp;
branches;
next	1.147;

1.147
date	2003.09.03.20.46.02;	author drow;	state Exp;
branches;
next	1.146;

1.146
date	2003.09.03.20.45.03;	author drow;	state Exp;
branches;
next	1.145;

1.145
date	2003.09.03.20.44.26;	author drow;	state Exp;
branches;
next	1.144;

1.144
date	2003.08.24.11.47.17;	author cagney;	state Exp;
branches;
next	1.143;

1.143
date	2003.06.13.14.15.51;	author rearnsha;	state Exp;
branches;
next	1.142;

1.142
date	2003.06.13.14.13.13;	author rearnsha;	state Exp;
branches;
next	1.141;

1.141
date	2003.06.13.04.40.30;	author cagney;	state Exp;
branches;
next	1.140;

1.140
date	2003.06.11.13.16.26;	author cagney;	state Exp;
branches;
next	1.139;

1.139
date	2003.06.09.20.08.55;	author cagney;	state Exp;
branches;
next	1.138;

1.138
date	2003.06.09.17.35.56;	author cagney;	state Exp;
branches;
next	1.137;

1.137
date	2003.06.02.02.09.39;	author cagney;	state Exp;
branches;
next	1.136;

1.136
date	2003.05.31.14.20.30;	author cagney;	state Exp;
branches;
next	1.135;

1.135
date	2003.05.17.05.59.57;	author cagney;	state Exp;
branches;
next	1.134;

1.134
date	2003.05.14.17.43.16;	author ezannoni;	state Exp;
branches;
next	1.133;

1.133
date	2003.05.13.19.27.27;	author cagney;	state Exp;
branches;
next	1.132;

1.132
date	2003.05.05.17.56.54;	author cagney;	state Exp;
branches
	1.132.4.1;
next	1.131;

1.131
date	2003.04.29.01.49.46;	author cagney;	state Exp;
branches;
next	1.130;

1.130
date	2003.04.21.16.48.37;	author cagney;	state Exp;
branches;
next	1.129;

1.129
date	2003.04.11.18.15.38;	author cagney;	state Exp;
branches
	1.129.2.1;
next	1.128;

1.128
date	2003.04.06.19.08.17;	author cagney;	state Exp;
branches;
next	1.127;

1.127
date	2003.04.05.18.54.38;	author cagney;	state Exp;
branches;
next	1.126;

1.126
date	2003.04.04.12.37.13;	author rearnsha;	state Exp;
branches;
next	1.125;

1.125
date	2003.04.01.17.17.27;	author cagney;	state Exp;
branches
	1.125.2.1;
next	1.124;

1.124
date	2003.04.01.14.38.47;	author cagney;	state Exp;
branches;
next	1.123;

1.123
date	2003.03.31.23.52.37;	author cagney;	state Exp;
branches;
next	1.122;

1.122
date	2003.03.31.21.58.21;	author cagney;	state Exp;
branches;
next	1.121;

1.121
date	2003.03.31.19.01.18;	author cagney;	state Exp;
branches;
next	1.120;

1.120
date	2003.03.30.14.59.00;	author cagney;	state Exp;
branches;
next	1.119;

1.119
date	2003.03.30.14.32.08;	author cagney;	state Exp;
branches;
next	1.118;

1.118
date	2003.03.29.17.08.00;	author rearnsha;	state Exp;
branches;
next	1.117;

1.117
date	2003.03.26.22.39.52;	author cagney;	state Exp;
branches;
next	1.116;

1.116
date	2003.03.25.20.38.44;	author cagney;	state Exp;
branches
	1.116.2.1;
next	1.115;

1.115
date	2003.03.25.18.54.14;	author cagney;	state Exp;
branches;
next	1.114;

1.114
date	2003.03.25.15.35.39;	author rearnsha;	state Exp;
branches;
next	1.113;

1.113
date	2003.03.25.14.52.33;	author rearnsha;	state Exp;
branches;
next	1.112;

1.112
date	2003.03.24.03.54.47;	author cagney;	state Exp;
branches;
next	1.111;

1.111
date	2003.03.22.20.39.20;	author rearnsha;	state Exp;
branches;
next	1.110;

1.110
date	2003.03.22.18.01.38;	author rearnsha;	state Exp;
branches;
next	1.109;

1.109
date	2003.03.22.16.22.18;	author rearnsha;	state Exp;
branches;
next	1.108;

1.108
date	2003.03.22.14.31.30;	author rearnsha;	state Exp;
branches;
next	1.107;

1.107
date	2003.03.13.21.45.39;	author cagney;	state Exp;
branches;
next	1.106;

1.106
date	2003.03.12.16.50.43;	author cagney;	state Exp;
branches;
next	1.105;

1.105
date	2003.03.03.20.50.17;	author cagney;	state Exp;
branches
	1.105.4.1;
next	1.104;

1.104
date	2003.03.02.05.56.56;	author cagney;	state Exp;
branches;
next	1.103;

1.103
date	2003.03.02.04.02.22;	author cagney;	state Exp;
branches;
next	1.102;

1.102
date	2003.03.02.00.11.42;	author cagney;	state Exp;
branches;
next	1.101;

1.101
date	2003.02.27.23.17.52;	author cagney;	state Exp;
branches;
next	1.100;

1.100
date	2003.02.27.17.48.46;	author cagney;	state Exp;
branches;
next	1.99;

1.99
date	2003.02.21.17.17.31;	author carlton;	state Exp;
branches;
next	1.98;

1.98
date	2003.02.03.20.03.00;	author msnyder;	state Exp;
branches;
next	1.97;

1.97
date	2003.01.08.19.45.22;	author cagney;	state Exp;
branches
	1.97.4.1;
next	1.96;

1.96
date	2003.01.08.17.21.27;	author cagney;	state Exp;
branches;
next	1.95;

1.95
date	2003.01.08.15.56.36;	author cagney;	state Exp;
branches;
next	1.94;

1.94
date	2003.01.08.01.53.36;	author cagney;	state Exp;
branches;
next	1.93;

1.93
date	2003.01.07.16.22.29;	author cagney;	state Exp;
branches;
next	1.92;

1.92
date	2003.01.07.14.51.10;	author cagney;	state Exp;
branches;
next	1.91;

1.91
date	2003.01.06.21.50.25;	author cagney;	state Exp;
branches;
next	1.90;

1.90
date	2003.01.05.13.31.26;	author cagney;	state Exp;
branches;
next	1.89;

1.89
date	2003.01.05.01.39.54;	author drow;	state Exp;
branches;
next	1.88;

1.88
date	2003.01.04.23.38.44;	author drow;	state Exp;
branches;
next	1.87;

1.87
date	2003.01.04.22.37.46;	author drow;	state Exp;
branches;
next	1.86;

1.86
date	2003.01.03.23.53.47;	author cagney;	state Exp;
branches;
next	1.85;

1.85
date	2003.01.02.22.20.46;	author cagney;	state Exp;
branches;
next	1.84;

1.84
date	2002.12.21.19.58.07;	author kettenis;	state Exp;
branches;
next	1.83;

1.83
date	2002.12.14.10.42.05;	author rearnsha;	state Exp;
branches;
next	1.82;

1.82
date	2002.12.11.02.26.34;	author cagney;	state Exp;
branches;
next	1.81;

1.81
date	2002.12.01.19.07.14;	author cagney;	state Exp;
branches;
next	1.80;

1.80
date	2002.11.28.21.38.43;	author cagney;	state Exp;
branches;
next	1.79;

1.79
date	2002.11.28.18.15.57;	author cagney;	state Exp;
branches;
next	1.78;

1.78
date	2002.11.24.18.23.37;	author cagney;	state Exp;
branches;
next	1.77;

1.77
date	2002.11.23.17.17.29;	author cagney;	state Exp;
branches;
next	1.76;

1.76
date	2002.11.18.22.19.26;	author cagney;	state Exp;
branches;
next	1.75;

1.75
date	2002.11.14.00.25.02;	author cagney;	state Exp;
branches;
next	1.74;

1.74
date	2002.11.01.21.21.49;	author cagney;	state Exp;
branches;
next	1.73;

1.73
date	2002.09.17.20.42.00;	author cagney;	state Exp;
branches
	1.73.2.1
	1.73.4.1;
next	1.72;

1.72
date	2002.09.05.19.05.59;	author msnyder;	state Exp;
branches;
next	1.71;

1.71
date	2002.09.05.19.03.07;	author msnyder;	state Exp;
branches;
next	1.70;

1.70
date	2002.09.04.17.52.38;	author thorpej;	state Exp;
branches;
next	1.69;

1.69
date	2002.08.24.00.21.34;	author cagney;	state Exp;
branches;
next	1.68;

1.68
date	2002.08.15.23.41.20;	author cagney;	state Exp;
branches;
next	1.67;

1.67
date	2002.07.11.19.25.13;	author cagney;	state Exp;
branches;
next	1.66;

1.66
date	2002.06.14.22.55.40;	author cagney;	state Exp;
branches;
next	1.65;

1.65
date	2002.06.12.21.46.05;	author cagney;	state Exp;
branches;
next	1.64;

1.64
date	2002.06.12.21.19.41;	author cagney;	state Exp;
branches;
next	1.63;

1.63
date	2002.06.11.02.30.58;	author cagney;	state Exp;
branches;
next	1.62;

1.62
date	2002.05.21.15.36.02;	author thorpej;	state Exp;
branches
	1.62.2.1;
next	1.61;

1.61
date	2002.05.17.00.05.24;	author msnyder;	state Exp;
branches;
next	1.60;

1.60
date	2002.05.09.18.07.00;	author msnyder;	state Exp;
branches
	1.60.2.1;
next	1.59;

1.59
date	2002.05.08.01.35.51;	author cagney;	state Exp;
branches;
next	1.58;

1.58
date	2002.05.07.12.58.51;	author rearnsha;	state Exp;
branches;
next	1.57;

1.57
date	2002.05.01.00.57.51;	author msnyder;	state Exp;
branches;
next	1.56;

1.56
date	2002.05.01.00.30.02;	author msnyder;	state Exp;
branches;
next	1.55;

1.55
date	2002.04.24.21.22.06;	author msnyder;	state Exp;
branches;
next	1.54;

1.54
date	2002.04.24.18.25.45;	author cagney;	state Exp;
branches;
next	1.53;

1.53
date	2002.04.24.16.28.14;	author cagney;	state Exp;
branches;
next	1.52;

1.52
date	2002.04.23.18.10.06;	author msnyder;	state Exp;
branches;
next	1.51;

1.51
date	2002.04.22.23.22.04;	author msnyder;	state Exp;
branches;
next	1.50;

1.50
date	2002.04.21.19.58.35;	author cagney;	state Exp;
branches;
next	1.49;

1.49
date	2002.04.21.03.46.44;	author cagney;	state Exp;
branches;
next	1.48;

1.48
date	2002.02.19.19.20.31;	author rearnsha;	state Exp;
branches;
next	1.47;

1.47
date	2002.02.19.13.57.35;	author rearnsha;	state Exp;
branches;
next	1.46;

1.46
date	2002.02.18.16.42.53;	author rearnsha;	state Exp;
branches;
next	1.45;

1.45
date	2002.02.18.15.04.17;	author rearnsha;	state Exp;
branches;
next	1.44;

1.44
date	2002.02.18.13.35.29;	author rearnsha;	state Exp;
branches;
next	1.43;

1.43
date	2002.02.15.16.12.22;	author rearnsha;	state Exp;
branches;
next	1.42;

1.42
date	2002.02.15.13.35.25;	author rearnsha;	state Exp;
branches;
next	1.41;

1.41
date	2002.02.14.19.00.55;	author corinna;	state Exp;
branches;
next	1.40;

1.40
date	2002.02.13.16.32.33;	author rearnsha;	state Exp;
branches;
next	1.39;

1.39
date	2002.02.11.18.34.08;	author rearnsha;	state Exp;
branches;
next	1.38;

1.38
date	2002.02.11.12.42.03;	author rearnsha;	state Exp;
branches;
next	1.37;

1.37
date	2002.02.08.18.26.36;	author rearnsha;	state Exp;
branches;
next	1.36;

1.36
date	2002.02.06.15.21.16;	author rearnsha;	state Exp;
branches;
next	1.35;

1.35
date	2002.02.06.13.12.14;	author rearnsha;	state Exp;
branches;
next	1.34;

1.34
date	2002.02.06.13.00.44;	author rearnsha;	state Exp;
branches;
next	1.33;

1.33
date	2002.02.05.04.37.21;	author cagney;	state Exp;
branches;
next	1.32;

1.32
date	2002.02.04.11.55.35;	author rearnsha;	state Exp;
branches;
next	1.31;

1.31
date	2002.02.01.13.39.41;	author rearnsha;	state Exp;
branches;
next	1.30;

1.30
date	2002.01.30.16.35.51;	author rearnsha;	state Exp;
branches;
next	1.29;

1.29
date	2002.01.21.20.12.36;	author fnf;	state Exp;
branches;
next	1.28;

1.28
date	2002.01.21.17.36.08;	author rearnsha;	state Exp;
branches;
next	1.27;

1.27
date	2002.01.21.16.27.42;	author rearnsha;	state Exp;
branches;
next	1.26;

1.26
date	2002.01.09.18.07.48;	author rearnsha;	state Exp;
branches;
next	1.25;

1.25
date	2002.01.05.04.30.15;	author cagney;	state Exp;
branches;
next	1.24;

1.24
date	2001.12.20.21.56.56;	author kevinb;	state Exp;
branches;
next	1.23;

1.23
date	2001.12.20.21.40.22;	author kevinb;	state Exp;
branches;
next	1.22;

1.22
date	2001.12.19.23.54.26;	author ezannoni;	state Exp;
branches;
next	1.21;

1.21
date	2001.12.19.17.57.41;	author fnasser;	state Exp;
branches;
next	1.20;

1.20
date	2001.12.17.17.03.57;	author fnasser;	state Exp;
branches;
next	1.19;

1.19
date	2001.12.05.08.36.01;	author corinna;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.30.20.27.08;	author kevinb;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.14.08.18.32;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2001.10.21.17.19.36;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.21.04.31.32;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.01.18.39.22;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.15.20.10.02;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.06.08.21.05;	author kevinb;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2001.03.01.01.39.20;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.19.22.03.25;	author jlarmour;	state Exp;
branches;
next	1.9;

1.9
date	2000.09.06.23.39.15;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2000.09.06.00.39.11;	author kevinb;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.08.00.52.56;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.16.03.03.13;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.24.21.33.35;	author jlarmour;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.29.07.23.02;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.17.19.51.04;	author fnasser;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.16.20.17.50;	author fnasser;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.33.58;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.377.2.1
date	2013.04.25.12.22.25;	author sergiodj;	state Exp;
branches;
next	;

1.354.2.1
date	2011.12.21.21.16.12;	author uweigand;	state Exp;
branches;
next	1.354.2.2;

1.354.2.2
date	2012.01.06.04.43.04;	author brobecke;	state Exp;
branches;
next	;

1.339.2.1
date	2011.05.17.21.23.25;	author brobecke;	state Exp;
branches;
next	1.339.2.2;

1.339.2.2
date	2011.05.17.21.27.01;	author brobecke;	state Exp;
branches;
next	;

1.304.2.1
date	2010.08.14.00.46.43;	author uweigand;	state Exp;
branches;
next	1.304.2.2;

1.304.2.2
date	2010.08.30.15.33.03;	author qiyao;	state Exp;
branches;
next	;

1.296.2.1
date	2010.02.26.20.45.33;	author drow;	state Exp;
branches;
next	;

1.288.2.1
date	2009.11.16.09.13.09;	author ramana;	state Exp;
branches;
next	;

1.266.2.1
date	2008.06.10.18.06.04;	author msnyder;	state Exp;
branches;
next	;

1.266.4.1
date	2008.07.18.04.23.49;	author msnyder;	state Exp;
branches;
next	;

1.225.2.1
date	2008.06.10.00.13.14;	author msnyder;	state Exp;
branches;
next	;

1.208.6.1
date	2006.08.28.07.48.50;	author nickrob;	state Exp;
branches;
next	;

1.205.2.1
date	2006.03.08.14.23.31;	author pbrook;	state Exp;
branches;
next	1.205.2.2;

1.205.2.2
date	2006.03.20.22.45.13;	author mmitchel;	state Exp;
branches;
next	1.205.2.3;

1.205.2.3
date	2006.03.21.02.13.35;	author pbrook;	state Exp;
branches;
next	1.205.2.4;

1.205.2.4
date	2006.04.03.00.47.37;	author drow;	state Exp;
branches
	1.205.2.4.2.1;
next	1.205.2.5;

1.205.2.5
date	2006.05.03.16.30.55;	author pbrook;	state Exp;
branches;
next	;

1.205.2.4.2.1
date	2006.04.11.21.58.21;	author drow;	state Exp;
branches;
next	1.205.2.4.2.2;

1.205.2.4.2.2
date	2006.04.12.14.48.21;	author drow;	state Exp;
branches;
next	1.205.2.4.2.3;

1.205.2.4.2.3
date	2006.04.12.14.52.04;	author drow;	state Exp;
branches;
next	1.205.2.4.2.4;

1.205.2.4.2.4
date	2006.04.12.18.11.39;	author drow;	state Exp;
branches;
next	1.205.2.4.2.5;

1.205.2.4.2.5
date	2006.04.24.20.06.49;	author drow;	state Exp;
branches;
next	;

1.205.4.1
date	2006.03.03.20.46.35;	author drow;	state Exp;
branches;
next	1.205.4.2;

1.205.4.2
date	2006.03.23.16.52.21;	author drow;	state Exp;
branches;
next	1.205.4.3;

1.205.4.3
date	2006.03.23.21.49.57;	author drow;	state Exp;
branches;
next	1.205.4.4;

1.205.4.4
date	2006.03.27.19.11.10;	author drow;	state Exp;
branches;
next	1.205.4.5;

1.205.4.5
date	2006.04.02.02.35.32;	author drow;	state Exp;
branches;
next	;

1.201.2.1
date	2005.10.20.03.36.27;	author pbrook;	state Exp;
branches;
next	1.201.2.2;

1.201.2.2
date	2005.10.20.03.36.54;	author pbrook;	state Exp;
branches;
next	1.201.2.3;

1.201.2.3
date	2005.10.20.13.32.36;	author jules;	state Exp;
branches;
next	1.201.2.4;

1.201.2.4
date	2005.10.20.13.36.44;	author jules;	state Exp;
branches;
next	1.201.2.5;

1.201.2.5
date	2005.10.20.14.10.25;	author jules;	state Exp;
branches;
next	;

1.194.2.1
date	2005.03.25.21.09.23;	author drow;	state Exp;
branches;
next	1.194.2.2;

1.194.2.2
date	2005.03.25.21.28.50;	author drow;	state Exp;
branches;
next	1.194.2.3;

1.194.2.3
date	2005.03.25.22.02.37;	author drow;	state Exp;
branches;
next	1.194.2.4;

1.194.2.4
date	2005.03.29.02.52.04;	author pbrook;	state Exp;
branches;
next	;

1.164.2.1
date	2004.03.27.17.37.44;	author drow;	state Exp;
branches;
next	1.164.2.2;

1.164.2.2
date	2004.09.16.17.00.53;	author drow;	state Exp;
branches;
next	;

1.164.4.1
date	2004.03.09.15.46.06;	author drow;	state Exp;
branches;
next	1.164.4.2;

1.164.4.2
date	2004.03.09.15.46.44;	author drow;	state Exp;
branches;
next	1.164.4.3;

1.164.4.3
date	2004.03.09.17.10.19;	author drow;	state Exp;
branches;
next	1.164.4.4;

1.164.4.4
date	2004.03.25.17.03.59;	author drow;	state Exp;
branches;
next	;

1.132.4.1
date	2003.06.03.20.54.32;	author cagney;	state Exp;
branches;
next	;

1.129.2.1
date	2003.05.04.11.37.40;	author kettenis;	state Exp;
branches;
next	1.129.2.2;

1.129.2.2
date	2003.05.18.09.43.58;	author kettenis;	state Exp;
branches;
next	;

1.125.2.1
date	2003.04.10.21.33.47;	author cagney;	state Exp;
branches;
next	;

1.116.2.1
date	2003.03.30.16.35.19;	author cagney;	state Exp;
branches;
next	;

1.105.4.1
date	2003.03.16.14.01.47;	author kettenis;	state Exp;
branches;
next	;

1.97.4.1
date	2003.02.03.22.00.55;	author cagney;	state Exp;
branches;
next	;

1.73.2.1
date	2002.11.15.19.18.36;	author carlton;	state Exp;
branches;
next	1.73.2.2;

1.73.2.2
date	2002.12.23.19.38.12;	author carlton;	state Exp;
branches;
next	1.73.2.3;

1.73.2.3
date	2003.02.07.19.17.44;	author carlton;	state Exp;
branches;
next	1.73.2.4;

1.73.2.4
date	2003.02.22.01.33.13;	author carlton;	state Exp;
branches;
next	1.73.2.5;

1.73.2.5
date	2003.03.06.00.56.23;	author carlton;	state Exp;
branches;
next	1.73.2.6;

1.73.2.6
date	2003.04.16.19.56.50;	author carlton;	state Exp;
branches;
next	1.73.2.7;

1.73.2.7
date	2003.05.01.00.46.46;	author carlton;	state Exp;
branches;
next	1.73.2.8;

1.73.2.8
date	2003.05.23.18.40.34;	author carlton;	state Exp;
branches;
next	1.73.2.9;

1.73.2.9
date	2003.06.27.21.49.45;	author carlton;	state Exp;
branches;
next	1.73.2.10;

1.73.2.10
date	2003.09.17.21.28.06;	author carlton;	state Exp;
branches;
next	1.73.2.11;

1.73.2.11
date	2003.11.11.23.50.37;	author carlton;	state Exp;
branches;
next	1.73.2.12;

1.73.2.12
date	2003.12.16.00.00.12;	author carlton;	state Exp;
branches;
next	1.73.2.13;

1.73.2.13
date	2004.01.26.19.11.14;	author carlton;	state Exp;
branches;
next	;

1.73.4.1
date	2003.12.14.20.27.06;	author drow;	state Exp;
branches;
next	1.73.4.2;

1.73.4.2
date	2004.02.09.19.43.30;	author drow;	state Exp;
branches;
next	;

1.62.2.1
date	2002.06.20.01.32.12;	author kseitz;	state Exp;
branches;
next	1.62.2.2;

1.62.2.2
date	2002.07.22.21.46.55;	author kseitz;	state Exp;
branches;
next	1.62.2.3;

1.62.2.3
date	2002.08.30.22.52.42;	author kseitz;	state Exp;
branches;
next	1.62.2.4;

1.62.2.4
date	2002.10.01.00.46.02;	author kseitz;	state Exp;
branches;
next	1.62.2.5;

1.62.2.5
date	2002.11.04.00.17.29;	author ezannoni;	state Exp;
branches;
next	;

1.60.2.1
date	2002.06.15.16.42.50;	author cagney;	state Exp;
branches;
next	;

1.12.2.1
date	2001.07.06.19.16.56;	author dberlin;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.33.58;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.23.33;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.05.25.18.00.55;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.06.28.16.00.13;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.07.07.20.04.13;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.08.09.21.33.18;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.08.16.19.52.03;	author jsm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	99.08.31.01.04.26;	author jsm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	99.11.02.04.44.13;	author jsm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	99.12.22.21.45.03;	author jsm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2000.02.01.03.19.04;	author jsm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2000.02.03.04.14.27;	author jsm;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2000.02.05.07.29.40;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.381
log
@	* objfiles.h (pc_in_section): New prototype.
	(in_plt_section): Remove name argument, replace prototype with
	static inline function.
	* mips-tdep.h: Include "objfiles.h".
	(in_mips_stubs_section): New function.
	* hppa-tdep.h (gdbarch_tdep): Remove name argument of
	in_solib_call_trampoline member.
	(hppa_in_solib_call_trampoline): Remove name argument.
	* objfiles.c (pc_in_section): New function.
	(in_plt_section): Remove function.
	* mips-linux-tdep.c: Include "objfiles.h".
	(mips_linux_in_dynsym_stub): Call in_mips_stubs_section.  Remove
	name argument.  Return 1 rather than the low 16-bit halfword of
	any instruction examined.
	(mips_linux_in_dynsym_resolve_code): Update
	mips_linux_in_dynsym_stub call accordingly.
	* mips-tdep.c (mips_stub_frame_sniffer): Use in_mips_stubs_section
	rather than an equivalent hand-coded sequence.
	* hppa-hpux-tdep.c (in_opd_section): Remove function.
	(hppa32_hpux_in_solib_call_trampoline): Remove name argument.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.
	(hppa64_hpux_find_global_pointer): Use pc_in_section rather than
	in_opd_section.
	* hppa-tdep.c (hppa_stub_unwind_sniffer): Remove name argument
	on call to tdep->in_solib_call_trampoline.
	(hppa_in_solib_call_trampoline): Remove name argument, update
	according to in_plt_section change.
	(hppa_skip_trampoline_code): Update according to in_plt_section
	change.
	* aarch64-tdep.c (aarch64_stub_unwind_sniffer): Likewise.
	* arm-symbian-tdep.c (arm_symbian_skip_trampoline_code):
	Likewise.
	* arm-tdep.c (arm_stub_unwind_sniffer): Likewise.
	* hppa-linux-tdep.c (hppa_linux_find_global_pointer): Likewise.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Likewise.
	* nios2-tdep.c (nios2_stub_frame_sniffer): Likewise.
	* nto-tdep.c (nto_relocate_section_addresses): Likewise.
	* s390-tdep.c (s390_stub_frame_sniffer): Likewise.
	* sh-tdep.c (sh_stub_unwind_sniffer): Likewise.
	* solib-dsbt.c (dsbt_in_dynsym_resolve_code): Likewise.
	* solib-frv.c (frv_in_dynsym_resolve_code): Likewise.
	* solib-svr4.c (svr4_in_dynsym_resolve_code): Likewise.
	* solib-target.c (solib_target_in_dynsym_resolve_code): Likewise.
	* sparc-tdep.c (sparc_analyze_prologue): Likewise.
	* tic6x-tdep.c (tic6x_stub_unwind_sniffer): Likewise.
@
text
@/* Common target dependent code for GDB on ARM systems.

   Copyright (C) 1988-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"

#include <ctype.h>		/* XXX for isupper ().  */

#include "frame.h"
#include "inferior.h"
#include "gdbcmd.h"
#include "gdbcore.h"
#include "gdb_string.h"
#include "dis-asm.h"		/* For register styles.  */
#include "regcache.h"
#include "reggroups.h"
#include "doublest.h"
#include "value.h"
#include "arch-utils.h"
#include "osabi.h"
#include "frame-unwind.h"
#include "frame-base.h"
#include "trad-frame.h"
#include "objfiles.h"
#include "dwarf2-frame.h"
#include "gdbtypes.h"
#include "prologue-value.h"
#include "remote.h"
#include "target-descriptions.h"
#include "user-regs.h"
#include "observer.h"

#include "arm-tdep.h"
#include "gdb/sim-arm.h"

#include "elf-bfd.h"
#include "coff/internal.h"
#include "elf/arm.h"

#include "gdb_assert.h"
#include "vec.h"

#include "record.h"
#include "record-full.h"

#include "features/arm-with-m.c"
#include "features/arm-with-m-fpa-layout.c"
#include "features/arm-with-m-vfp-d16.c"
#include "features/arm-with-iwmmxt.c"
#include "features/arm-with-vfpv2.c"
#include "features/arm-with-vfpv3.c"
#include "features/arm-with-neon.c"

static int arm_debug;

/* Macros for setting and testing a bit in a minimal symbol that marks
   it as Thumb function.  The MSB of the minimal symbol's "info" field
   is used for this purpose.

   MSYMBOL_SET_SPECIAL	Actually sets the "special" bit.
   MSYMBOL_IS_SPECIAL   Tests the "special" bit in a minimal symbol.  */

#define MSYMBOL_SET_SPECIAL(msym)				\
	MSYMBOL_TARGET_FLAG_1 (msym) = 1

#define MSYMBOL_IS_SPECIAL(msym)				\
	MSYMBOL_TARGET_FLAG_1 (msym)

/* Per-objfile data used for mapping symbols.  */
static const struct objfile_data *arm_objfile_data_key;

struct arm_mapping_symbol
{
  bfd_vma value;
  char type;
};
typedef struct arm_mapping_symbol arm_mapping_symbol_s;
DEF_VEC_O(arm_mapping_symbol_s);

struct arm_per_objfile
{
  VEC(arm_mapping_symbol_s) **section_maps;
};

/* The list of available "set arm ..." and "show arm ..." commands.  */
static struct cmd_list_element *setarmcmdlist = NULL;
static struct cmd_list_element *showarmcmdlist = NULL;

/* The type of floating-point to use.  Keep this in sync with enum
   arm_float_model, and the help string in _initialize_arm_tdep.  */
static const char *const fp_model_strings[] =
{
  "auto",
  "softfpa",
  "fpa",
  "softvfp",
  "vfp",
  NULL
};

/* A variable that can be configured by the user.  */
static enum arm_float_model arm_fp_model = ARM_FLOAT_AUTO;
static const char *current_fp_model = "auto";

/* The ABI to use.  Keep this in sync with arm_abi_kind.  */
static const char *const arm_abi_strings[] =
{
  "auto",
  "APCS",
  "AAPCS",
  NULL
};

/* A variable that can be configured by the user.  */
static enum arm_abi_kind arm_abi_global = ARM_ABI_AUTO;
static const char *arm_abi_string = "auto";

/* The execution mode to assume.  */
static const char *const arm_mode_strings[] =
  {
    "auto",
    "arm",
    "thumb",
    NULL
  };

static const char *arm_fallback_mode_string = "auto";
static const char *arm_force_mode_string = "auto";

/* Internal override of the execution mode.  -1 means no override,
   0 means override to ARM mode, 1 means override to Thumb mode.
   The effect is the same as if arm_force_mode has been set by the
   user (except the internal override has precedence over a user's
   arm_force_mode override).  */
static int arm_override_mode = -1;

/* Number of different reg name sets (options).  */
static int num_disassembly_options;

/* The standard register names, and all the valid aliases for them.  Note
   that `fp', `sp' and `pc' are not added in this alias list, because they
   have been added as builtin user registers in
   std-regs.c:_initialize_frame_reg.  */
static const struct
{
  const char *name;
  int regnum;
} arm_register_aliases[] = {
  /* Basic register numbers.  */
  { "r0", 0 },
  { "r1", 1 },
  { "r2", 2 },
  { "r3", 3 },
  { "r4", 4 },
  { "r5", 5 },
  { "r6", 6 },
  { "r7", 7 },
  { "r8", 8 },
  { "r9", 9 },
  { "r10", 10 },
  { "r11", 11 },
  { "r12", 12 },
  { "r13", 13 },
  { "r14", 14 },
  { "r15", 15 },
  /* Synonyms (argument and variable registers).  */
  { "a1", 0 },
  { "a2", 1 },
  { "a3", 2 },
  { "a4", 3 },
  { "v1", 4 },
  { "v2", 5 },
  { "v3", 6 },
  { "v4", 7 },
  { "v5", 8 },
  { "v6", 9 },
  { "v7", 10 },
  { "v8", 11 },
  /* Other platform-specific names for r9.  */
  { "sb", 9 },
  { "tr", 9 },
  /* Special names.  */
  { "ip", 12 },
  { "lr", 14 },
  /* Names used by GCC (not listed in the ARM EABI).  */
  { "sl", 10 },
  /* A special name from the older ATPCS.  */
  { "wr", 7 },
};

static const char *const arm_register_names[] =
{"r0",  "r1",  "r2",  "r3",	/*  0  1  2  3 */
 "r4",  "r5",  "r6",  "r7",	/*  4  5  6  7 */
 "r8",  "r9",  "r10", "r11",	/*  8  9 10 11 */
 "r12", "sp",  "lr",  "pc",	/* 12 13 14 15 */
 "f0",  "f1",  "f2",  "f3",	/* 16 17 18 19 */
 "f4",  "f5",  "f6",  "f7",	/* 20 21 22 23 */
 "fps", "cpsr" };		/* 24 25       */

/* Valid register name styles.  */
static const char **valid_disassembly_styles;

/* Disassembly style to use. Default to "std" register names.  */
static const char *disassembly_style;

/* This is used to keep the bfd arch_info in sync with the disassembly
   style.  */
static void set_disassembly_style_sfunc(char *, int,
					 struct cmd_list_element *);
static void set_disassembly_style (void);

static void convert_from_extended (const struct floatformat *, const void *,
				   void *, int);
static void convert_to_extended (const struct floatformat *, void *,
				 const void *, int);

static enum register_status arm_neon_quad_read (struct gdbarch *gdbarch,
						struct regcache *regcache,
						int regnum, gdb_byte *buf);
static void arm_neon_quad_write (struct gdbarch *gdbarch,
				 struct regcache *regcache,
				 int regnum, const gdb_byte *buf);

static int thumb_insn_size (unsigned short inst1);

struct arm_prologue_cache
{
  /* The stack pointer at the time this frame was created; i.e. the
     caller's stack pointer when this function was called.  It is used
     to identify this frame.  */
  CORE_ADDR prev_sp;

  /* The frame base for this frame is just prev_sp - frame size.
     FRAMESIZE is the distance from the frame pointer to the
     initial stack pointer.  */

  int framesize;

  /* The register used to hold the frame pointer for this frame.  */
  int framereg;

  /* Saved register offsets.  */
  struct trad_frame_saved_reg *saved_regs;
};

static CORE_ADDR arm_analyze_prologue (struct gdbarch *gdbarch,
				       CORE_ADDR prologue_start,
				       CORE_ADDR prologue_end,
				       struct arm_prologue_cache *cache);

/* Architecture version for displaced stepping.  This effects the behaviour of
   certain instructions, and really should not be hard-wired.  */

#define DISPLACED_STEPPING_ARCH_VERSION		5

/* Addresses for calling Thumb functions have the bit 0 set.
   Here are some macros to test, set, or clear bit 0 of addresses.  */
#define IS_THUMB_ADDR(addr)	((addr) & 1)
#define MAKE_THUMB_ADDR(addr)	((addr) | 1)
#define UNMAKE_THUMB_ADDR(addr) ((addr) & ~1)

/* Set to true if the 32-bit mode is in use.  */

int arm_apcs_32 = 1;

/* Return the bit mask in ARM_PS_REGNUM that indicates Thumb mode.  */

int
arm_psr_thumb_bit (struct gdbarch *gdbarch)
{
  if (gdbarch_tdep (gdbarch)->is_m)
    return XPSR_T;
  else
    return CPSR_T;
}

/* Determine if FRAME is executing in Thumb mode.  */

int
arm_frame_is_thumb (struct frame_info *frame)
{
  CORE_ADDR cpsr;
  ULONGEST t_bit = arm_psr_thumb_bit (get_frame_arch (frame));

  /* Every ARM frame unwinder can unwind the T bit of the CPSR, either
     directly (from a signal frame or dummy frame) or by interpreting
     the saved LR (from a prologue or DWARF frame).  So consult it and
     trust the unwinders.  */
  cpsr = get_frame_register_unsigned (frame, ARM_PS_REGNUM);

  return (cpsr & t_bit) != 0;
}

/* Callback for VEC_lower_bound.  */

static inline int
arm_compare_mapping_symbols (const struct arm_mapping_symbol *lhs,
			     const struct arm_mapping_symbol *rhs)
{
  return lhs->value < rhs->value;
}

/* Search for the mapping symbol covering MEMADDR.  If one is found,
   return its type.  Otherwise, return 0.  If START is non-NULL,
   set *START to the location of the mapping symbol.  */

static char
arm_find_mapping_symbol (CORE_ADDR memaddr, CORE_ADDR *start)
{
  struct obj_section *sec;

  /* If there are mapping symbols, consult them.  */
  sec = find_pc_section (memaddr);
  if (sec != NULL)
    {
      struct arm_per_objfile *data;
      VEC(arm_mapping_symbol_s) *map;
      struct arm_mapping_symbol map_key = { memaddr - obj_section_addr (sec),
					    0 };
      unsigned int idx;

      data = objfile_data (sec->objfile, arm_objfile_data_key);
      if (data != NULL)
	{
	  map = data->section_maps[sec->the_bfd_section->index];
	  if (!VEC_empty (arm_mapping_symbol_s, map))
	    {
	      struct arm_mapping_symbol *map_sym;

	      idx = VEC_lower_bound (arm_mapping_symbol_s, map, &map_key,
				     arm_compare_mapping_symbols);

	      /* VEC_lower_bound finds the earliest ordered insertion
		 point.  If the following symbol starts at this exact
		 address, we use that; otherwise, the preceding
		 mapping symbol covers this address.  */
	      if (idx < VEC_length (arm_mapping_symbol_s, map))
		{
		  map_sym = VEC_index (arm_mapping_symbol_s, map, idx);
		  if (map_sym->value == map_key.value)
		    {
		      if (start)
			*start = map_sym->value + obj_section_addr (sec);
		      return map_sym->type;
		    }
		}

	      if (idx > 0)
		{
		  map_sym = VEC_index (arm_mapping_symbol_s, map, idx - 1);
		  if (start)
		    *start = map_sym->value + obj_section_addr (sec);
		  return map_sym->type;
		}
	    }
	}
    }

  return 0;
}

/* Determine if the program counter specified in MEMADDR is in a Thumb
   function.  This function should be called for addresses unrelated to
   any executing frame; otherwise, prefer arm_frame_is_thumb.  */

int
arm_pc_is_thumb (struct gdbarch *gdbarch, CORE_ADDR memaddr)
{
  struct bound_minimal_symbol sym;
  char type;
  struct displaced_step_closure* dsc
    = get_displaced_step_closure_by_addr(memaddr);

  /* If checking the mode of displaced instruction in copy area, the mode
     should be determined by instruction on the original address.  */
  if (dsc)
    {
      if (debug_displaced)
	fprintf_unfiltered (gdb_stdlog,
			    "displaced: check mode of %.8lx instead of %.8lx\n",
			    (unsigned long) dsc->insn_addr,
			    (unsigned long) memaddr);
      memaddr = dsc->insn_addr;
    }

  /* If bit 0 of the address is set, assume this is a Thumb address.  */
  if (IS_THUMB_ADDR (memaddr))
    return 1;

  /* Respect internal mode override if active.  */
  if (arm_override_mode != -1)
    return arm_override_mode;

  /* If the user wants to override the symbol table, let him.  */
  if (strcmp (arm_force_mode_string, "arm") == 0)
    return 0;
  if (strcmp (arm_force_mode_string, "thumb") == 0)
    return 1;

  /* ARM v6-M and v7-M are always in Thumb mode.  */
  if (gdbarch_tdep (gdbarch)->is_m)
    return 1;

  /* If there are mapping symbols, consult them.  */
  type = arm_find_mapping_symbol (memaddr, NULL);
  if (type)
    return type == 't';

  /* Thumb functions have a "special" bit set in minimal symbols.  */
  sym = lookup_minimal_symbol_by_pc (memaddr);
  if (sym.minsym)
    return (MSYMBOL_IS_SPECIAL (sym.minsym));

  /* If the user wants to override the fallback mode, let them.  */
  if (strcmp (arm_fallback_mode_string, "arm") == 0)
    return 0;
  if (strcmp (arm_fallback_mode_string, "thumb") == 0)
    return 1;

  /* If we couldn't find any symbol, but we're talking to a running
     target, then trust the current value of $cpsr.  This lets
     "display/i $pc" always show the correct mode (though if there is
     a symbol table we will not reach here, so it still may not be
     displayed in the mode it will be executed).  */
  if (target_has_registers)
    return arm_frame_is_thumb (get_current_frame ());

  /* Otherwise we're out of luck; we assume ARM.  */
  return 0;
}

/* Remove useless bits from addresses in a running program.  */
static CORE_ADDR
arm_addr_bits_remove (struct gdbarch *gdbarch, CORE_ADDR val)
{
  /* On M-profile devices, do not strip the low bit from EXC_RETURN
     (the magic exception return address).  */
  if (gdbarch_tdep (gdbarch)->is_m
      && (val & 0xfffffff0) == 0xfffffff0)
    return val;

  if (arm_apcs_32)
    return UNMAKE_THUMB_ADDR (val);
  else
    return (val & 0x03fffffc);
}

/* Return 1 if PC is the start of a compiler helper function which
   can be safely ignored during prologue skipping.  IS_THUMB is true
   if the function is known to be a Thumb function due to the way it
   is being called.  */
static int
skip_prologue_function (struct gdbarch *gdbarch, CORE_ADDR pc, int is_thumb)
{
  enum bfd_endian byte_order_for_code = gdbarch_byte_order_for_code (gdbarch);
  struct bound_minimal_symbol msym;

  msym = lookup_minimal_symbol_by_pc (pc);
  if (msym.minsym != NULL
      && SYMBOL_VALUE_ADDRESS (msym.minsym) == pc
      && SYMBOL_LINKAGE_NAME (msym.minsym) != NULL)
    {
      const char *name = SYMBOL_LINKAGE_NAME (msym.minsym);

      /* The GNU linker's Thumb call stub to foo is named
	 __foo_from_thumb.  */
      if (strstr (name, "_from_thumb") != NULL)
	name += 2;

      /* On soft-float targets, __truncdfsf2 is called to convert promoted
	 arguments to their argument types in non-prototyped
	 functions.  */
      if (strncmp (name, "__truncdfsf2", strlen ("__truncdfsf2")) == 0)
	return 1;
      if (strncmp (name, "__aeabi_d2f", strlen ("__aeabi_d2f")) == 0)
	return 1;

      /* Internal functions related to thread-local storage.  */
      if (strncmp (name, "__tls_get_addr", strlen ("__tls_get_addr")) == 0)
	return 1;
      if (strncmp (name, "__aeabi_read_tp", strlen ("__aeabi_read_tp")) == 0)
	return 1;
    }
  else
    {
      /* If we run against a stripped glibc, we may be unable to identify
	 special functions by name.  Check for one important case,
	 __aeabi_read_tp, by comparing the *code* against the default
	 implementation (this is hand-written ARM assembler in glibc).  */

      if (!is_thumb
	  && read_memory_unsigned_integer (pc, 4, byte_order_for_code)
	     == 0xe3e00a0f /* mov r0, #0xffff0fff */
	  && read_memory_unsigned_integer (pc + 4, 4, byte_order_for_code)
	     == 0xe240f01f) /* sub pc, r0, #31 */
	return 1;
    }

  return 0;
}

/* Support routines for instruction parsing.  */
#define submask(x) ((1L << ((x) + 1)) - 1)
#define bit(obj,st) (((obj) >> (st)) & 1)
#define bits(obj,st,fn) (((obj) >> (st)) & submask ((fn) - (st)))
#define sbits(obj,st,fn) \
  ((long) (bits(obj,st,fn) | ((long) bit(obj,fn) * ~ submask (fn - st))))
#define BranchDest(addr,instr) \
  ((CORE_ADDR) (((unsigned long) (addr)) + 8 + (sbits (instr, 0, 23) << 2)))

/* Extract the immediate from instruction movw/movt of encoding T.  INSN1 is
   the first 16-bit of instruction, and INSN2 is the second 16-bit of
   instruction.  */
#define EXTRACT_MOVW_MOVT_IMM_T(insn1, insn2) \
  ((bits ((insn1), 0, 3) << 12)               \
   | (bits ((insn1), 10, 10) << 11)           \
   | (bits ((insn2), 12, 14) << 8)            \
   | bits ((insn2), 0, 7))

/* Extract the immediate from instruction movw/movt of encoding A.  INSN is
   the 32-bit instruction.  */
#define EXTRACT_MOVW_MOVT_IMM_A(insn) \
  ((bits ((insn), 16, 19) << 12) \
   | bits ((insn), 0, 11))

/* Decode immediate value; implements ThumbExpandImmediate pseudo-op.  */

static unsigned int
thumb_expand_immediate (unsigned int imm)
{
  unsigned int count = imm >> 7;

  if (count < 8)
    switch (count / 2)
      {
      case 0:
	return imm & 0xff;
      case 1:
	return (imm & 0xff) | ((imm & 0xff) << 16);
      case 2:
	return ((imm & 0xff) << 8) | ((imm & 0xff) << 24);
      case 3:
	return (imm & 0xff) | ((imm & 0xff) << 8)
		| ((imm & 0xff) << 16) | ((imm & 0xff) << 24);
      }

  return (0x80 | (imm & 0x7f)) << (32 - count);
}

/* Return 1 if the 16-bit Thumb instruction INST might change
   control flow, 0 otherwise.  */

static int
thumb_instruction_changes_pc (unsigned short inst)
{
  if ((inst & 0xff00) == 0xbd00)	/* pop {rlist, pc} */
    return 1;

  if ((inst & 0xf000) == 0xd000)	/* conditional branch */
    return 1;

  if ((inst & 0xf800) == 0xe000)	/* unconditional branch */
    return 1;

  if ((inst & 0xff00) == 0x4700)	/* bx REG, blx REG */
    return 1;

  if ((inst & 0xff87) == 0x4687)	/* mov pc, REG */
    return 1;

  if ((inst & 0xf500) == 0xb100)	/* CBNZ or CBZ.  */
    return 1;

  return 0;
}

/* Return 1 if the 32-bit Thumb instruction in INST1 and INST2
   might change control flow, 0 otherwise.  */

static int
thumb2_instruction_changes_pc (unsigned short inst1, unsigned short inst2)
{
  if ((inst1 & 0xf800) == 0xf000 && (inst2 & 0x8000) == 0x8000)
    {
      /* Branches and miscellaneous control instructions.  */

      if ((inst2 & 0x1000) != 0 || (inst2 & 0xd001) == 0xc000)
	{
	  /* B, BL, BLX.  */
	  return 1;
	}
      else if (inst1 == 0xf3de && (inst2 & 0xff00) == 0x3f00)
	{
	  /* SUBS PC, LR, #imm8.  */
	  return 1;
	}
      else if ((inst2 & 0xd000) == 0x8000 && (inst1 & 0x0380) != 0x0380)
	{
	  /* Conditional branch.  */
	  return 1;
	}

      return 0;
    }

  if ((inst1 & 0xfe50) == 0xe810)
    {
      /* Load multiple or RFE.  */

      if (bit (inst1, 7) && !bit (inst1, 8))
	{
	  /* LDMIA or POP */
	  if (bit (inst2, 15))
	    return 1;
	}
      else if (!bit (inst1, 7) && bit (inst1, 8))
	{
	  /* LDMDB */
	  if (bit (inst2, 15))
	    return 1;
	}
      else if (bit (inst1, 7) && bit (inst1, 8))
	{
	  /* RFEIA */
	  return 1;
	}
      else if (!bit (inst1, 7) && !bit (inst1, 8))
	{
	  /* RFEDB */
	  return 1;
	}

      return 0;
    }

  if ((inst1 & 0xffef) == 0xea4f && (inst2 & 0xfff0) == 0x0f00)
    {
      /* MOV PC or MOVS PC.  */
      return 1;
    }

  if ((inst1 & 0xff70) == 0xf850 && (inst2 & 0xf000) == 0xf000)
    {
      /* LDR PC.  */
      if (bits (inst1, 0, 3) == 15)
	return 1;
      if (bit (inst1, 7))
	return 1;
      if (bit (inst2, 11))
	return 1;
      if ((inst2 & 0x0fc0) == 0x0000)
	return 1;	

      return 0;
    }

  if ((inst1 & 0xfff0) == 0xe8d0 && (inst2 & 0xfff0) == 0xf000)
    {
      /* TBB.  */
      return 1;
    }

  if ((inst1 & 0xfff0) == 0xe8d0 && (inst2 & 0xfff0) == 0xf010)
    {
      /* TBH.  */
      return 1;
    }

  return 0;
}

/* Analyze a Thumb prologue, looking for a recognizable stack frame
   and frame pointer.  Scan until we encounter a store that could
   clobber the stack frame unexpectedly, or an unknown instruction.
   Return the last address which is definitely safe to skip for an
   initial breakpoint.  */

static CORE_ADDR
thumb_analyze_prologue (struct gdbarch *gdbarch,
			CORE_ADDR start, CORE_ADDR limit,
			struct arm_prologue_cache *cache)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  enum bfd_endian byte_order_for_code = gdbarch_byte_order_for_code (gdbarch);
  int i;
  pv_t regs[16];
  struct pv_area *stack;
  struct cleanup *back_to;
  CORE_ADDR offset;
  CORE_ADDR unrecognized_pc = 0;

  for (i = 0; i < 16; i++)
    regs[i] = pv_register (i, 0);
  stack = make_pv_area (ARM_SP_REGNUM, gdbarch_addr_bit (gdbarch));
  back_to = make_cleanup_free_pv_area (stack);

  while (start < limit)
    {
      unsigned short insn;

      insn = read_memory_unsigned_integer (start, 2, byte_order_for_code);

      if ((insn & 0xfe00) == 0xb400)		/* push { rlist } */
	{
	  int regno;
	  int mask;

	  if (pv_area_store_would_trash (stack, regs[ARM_SP_REGNUM]))
	    break;

	  /* Bits 0-7 contain a mask for registers R0-R7.  Bit 8 says
	     whether to save LR (R14).  */
	  mask = (insn & 0xff) | ((insn & 0x100) << 6);

	  /* Calculate offsets of saved R0-R7 and LR.  */
	  for (regno = ARM_LR_REGNUM; regno >= 0; regno--)
	    if (mask & (1 << regno))
	      {
		regs[ARM_SP_REGNUM] = pv_add_constant (regs[ARM_SP_REGNUM],
						       -4);
		pv_area_store (stack, regs[ARM_SP_REGNUM], 4, regs[regno]);
	      }
	}
      else if ((insn & 0xff00) == 0xb000)	/* add sp, #simm  OR  
						   sub sp, #simm */
	{
	  offset = (insn & 0x7f) << 2;		/* get scaled offset */
	  if (insn & 0x80)			/* Check for SUB.  */
	    regs[ARM_SP_REGNUM] = pv_add_constant (regs[ARM_SP_REGNUM],
						   -offset);
	  else
	    regs[ARM_SP_REGNUM] = pv_add_constant (regs[ARM_SP_REGNUM],
						   offset);
	}
      else if ((insn & 0xf800) == 0xa800)	/* add Rd, sp, #imm */
	regs[bits (insn, 8, 10)] = pv_add_constant (regs[ARM_SP_REGNUM],
						    (insn & 0xff) << 2);
      else if ((insn & 0xfe00) == 0x1c00	/* add Rd, Rn, #imm */
	       && pv_is_register (regs[bits (insn, 3, 5)], ARM_SP_REGNUM))
	regs[bits (insn, 0, 2)] = pv_add_constant (regs[bits (insn, 3, 5)],
						   bits (insn, 6, 8));
      else if ((insn & 0xf800) == 0x3000	/* add Rd, #imm */
	       && pv_is_register (regs[bits (insn, 8, 10)], ARM_SP_REGNUM))
	regs[bits (insn, 8, 10)] = pv_add_constant (regs[bits (insn, 8, 10)],
						    bits (insn, 0, 7));
      else if ((insn & 0xfe00) == 0x1800	/* add Rd, Rn, Rm */
	       && pv_is_register (regs[bits (insn, 6, 8)], ARM_SP_REGNUM)
	       && pv_is_constant (regs[bits (insn, 3, 5)]))
	regs[bits (insn, 0, 2)] = pv_add (regs[bits (insn, 3, 5)],
					  regs[bits (insn, 6, 8)]);
      else if ((insn & 0xff00) == 0x4400	/* add Rd, Rm */
	       && pv_is_constant (regs[bits (insn, 3, 6)]))
	{
	  int rd = (bit (insn, 7) << 3) + bits (insn, 0, 2);
	  int rm = bits (insn, 3, 6);
	  regs[rd] = pv_add (regs[rd], regs[rm]);
	}
      else if ((insn & 0xff00) == 0x4600)	/* mov hi, lo or mov lo, hi */
	{
	  int dst_reg = (insn & 0x7) + ((insn & 0x80) >> 4);
	  int src_reg = (insn & 0x78) >> 3;
	  regs[dst_reg] = regs[src_reg];
	}
      else if ((insn & 0xf800) == 0x9000)	/* str rd, [sp, #off] */
	{
	  /* Handle stores to the stack.  Normally pushes are used,
	     but with GCC -mtpcs-frame, there may be other stores
	     in the prologue to create the frame.  */
	  int regno = (insn >> 8) & 0x7;
	  pv_t addr;

	  offset = (insn & 0xff) << 2;
	  addr = pv_add_constant (regs[ARM_SP_REGNUM], offset);

	  if (pv_area_store_would_trash (stack, addr))
	    break;

	  pv_area_store (stack, addr, 4, regs[regno]);
	}
      else if ((insn & 0xf800) == 0x6000)	/* str rd, [rn, #off] */
	{
	  int rd = bits (insn, 0, 2);
	  int rn = bits (insn, 3, 5);
	  pv_t addr;

	  offset = bits (insn, 6, 10) << 2;
	  addr = pv_add_constant (regs[rn], offset);

	  if (pv_area_store_would_trash (stack, addr))
	    break;

	  pv_area_store (stack, addr, 4, regs[rd]);
	}
      else if (((insn & 0xf800) == 0x7000	/* strb Rd, [Rn, #off] */
		|| (insn & 0xf800) == 0x8000)	/* strh Rd, [Rn, #off] */
	       && pv_is_register (regs[bits (insn, 3, 5)], ARM_SP_REGNUM))
	/* Ignore stores of argument registers to the stack.  */
	;
      else if ((insn & 0xf800) == 0xc800	/* ldmia Rn!, { registers } */
	       && pv_is_register (regs[bits (insn, 8, 10)], ARM_SP_REGNUM))
	/* Ignore block loads from the stack, potentially copying
	   parameters from memory.  */
	;
      else if ((insn & 0xf800) == 0x9800	/* ldr Rd, [Rn, #immed] */
	       || ((insn & 0xf800) == 0x6800	/* ldr Rd, [sp, #immed] */
		   && pv_is_register (regs[bits (insn, 3, 5)], ARM_SP_REGNUM)))
	/* Similarly ignore single loads from the stack.  */
	;
      else if ((insn & 0xffc0) == 0x0000	/* lsls Rd, Rm, #0 */
	       || (insn & 0xffc0) == 0x1c00)	/* add Rd, Rn, #0 */
	/* Skip register copies, i.e. saves to another register
	   instead of the stack.  */
	;
      else if ((insn & 0xf800) == 0x2000)	/* movs Rd, #imm */
	/* Recognize constant loads; even with small stacks these are necessary
	   on Thumb.  */
	regs[bits (insn, 8, 10)] = pv_constant (bits (insn, 0, 7));
      else if ((insn & 0xf800) == 0x4800)	/* ldr Rd, [pc, #imm] */
	{
	  /* Constant pool loads, for the same reason.  */
	  unsigned int constant;
	  CORE_ADDR loc;

	  loc = start + 4 + bits (insn, 0, 7) * 4;
	  constant = read_memory_unsigned_integer (loc, 4, byte_order);
	  regs[bits (insn, 8, 10)] = pv_constant (constant);
	}
      else if (thumb_insn_size (insn) == 4) /* 32-bit Thumb-2 instructions.  */
	{
	  unsigned short inst2;

	  inst2 = read_memory_unsigned_integer (start + 2, 2,
						byte_order_for_code);

	  if ((insn & 0xf800) == 0xf000 && (inst2 & 0xe800) == 0xe800)
	    {
	      /* BL, BLX.  Allow some special function calls when
		 skipping the prologue; GCC generates these before
		 storing arguments to the stack.  */
	      CORE_ADDR nextpc;
	      int j1, j2, imm1, imm2;

	      imm1 = sbits (insn, 0, 10);
	      imm2 = bits (inst2, 0, 10);
	      j1 = bit (inst2, 13);
	      j2 = bit (inst2, 11);

	      offset = ((imm1 << 12) + (imm2 << 1));
	      offset ^= ((!j2) << 22) | ((!j1) << 23);

	      nextpc = start + 4 + offset;
	      /* For BLX make sure to clear the low bits.  */
	      if (bit (inst2, 12) == 0)
		nextpc = nextpc & 0xfffffffc;

	      if (!skip_prologue_function (gdbarch, nextpc,
					   bit (inst2, 12) != 0))
		break;
	    }

	  else if ((insn & 0xffd0) == 0xe900    /* stmdb Rn{!},
						   { registers } */
		   && pv_is_register (regs[bits (insn, 0, 3)], ARM_SP_REGNUM))
	    {
	      pv_t addr = regs[bits (insn, 0, 3)];
	      int regno;

	      if (pv_area_store_would_trash (stack, addr))
		break;

	      /* Calculate offsets of saved registers.  */
	      for (regno = ARM_LR_REGNUM; regno >= 0; regno--)
		if (inst2 & (1 << regno))
		  {
		    addr = pv_add_constant (addr, -4);
		    pv_area_store (stack, addr, 4, regs[regno]);
		  }

	      if (insn & 0x0020)
		regs[bits (insn, 0, 3)] = addr;
	    }

	  else if ((insn & 0xff50) == 0xe940	/* strd Rt, Rt2,
						   [Rn, #+/-imm]{!} */
		   && pv_is_register (regs[bits (insn, 0, 3)], ARM_SP_REGNUM))
	    {
	      int regno1 = bits (inst2, 12, 15);
	      int regno2 = bits (inst2, 8, 11);
	      pv_t addr = regs[bits (insn, 0, 3)];

	      offset = inst2 & 0xff;
	      if (insn & 0x0080)
		addr = pv_add_constant (addr, offset);
	      else
		addr = pv_add_constant (addr, -offset);

	      if (pv_area_store_would_trash (stack, addr))
		break;

	      pv_area_store (stack, addr, 4, regs[regno1]);
	      pv_area_store (stack, pv_add_constant (addr, 4),
			     4, regs[regno2]);

	      if (insn & 0x0020)
		regs[bits (insn, 0, 3)] = addr;
	    }

	  else if ((insn & 0xfff0) == 0xf8c0	/* str Rt,[Rn,+/-#imm]{!} */
		   && (inst2 & 0x0c00) == 0x0c00
		   && pv_is_register (regs[bits (insn, 0, 3)], ARM_SP_REGNUM))
	    {
	      int regno = bits (inst2, 12, 15);
	      pv_t addr = regs[bits (insn, 0, 3)];

	      offset = inst2 & 0xff;
	      if (inst2 & 0x0200)
		addr = pv_add_constant (addr, offset);
	      else
		addr = pv_add_constant (addr, -offset);

	      if (pv_area_store_would_trash (stack, addr))
		break;

	      pv_area_store (stack, addr, 4, regs[regno]);

	      if (inst2 & 0x0100)
		regs[bits (insn, 0, 3)] = addr;
	    }

	  else if ((insn & 0xfff0) == 0xf8c0	/* str.w Rt,[Rn,#imm] */
		   && pv_is_register (regs[bits (insn, 0, 3)], ARM_SP_REGNUM))
	    {
	      int regno = bits (inst2, 12, 15);
	      pv_t addr;

	      offset = inst2 & 0xfff;
	      addr = pv_add_constant (regs[bits (insn, 0, 3)], offset);

	      if (pv_area_store_would_trash (stack, addr))
		break;

	      pv_area_store (stack, addr, 4, regs[regno]);
	    }

	  else if ((insn & 0xffd0) == 0xf880	/* str{bh}.w Rt,[Rn,#imm] */
		   && pv_is_register (regs[bits (insn, 0, 3)], ARM_SP_REGNUM))
	    /* Ignore stores of argument registers to the stack.  */
	    ;

	  else if ((insn & 0xffd0) == 0xf800	/* str{bh} Rt,[Rn,#+/-imm] */
		   && (inst2 & 0x0d00) == 0x0c00
		   && pv_is_register (regs[bits (insn, 0, 3)], ARM_SP_REGNUM))
	    /* Ignore stores of argument registers to the stack.  */
	    ;

	  else if ((insn & 0xffd0) == 0xe890	/* ldmia Rn[!],
						   { registers } */
		   && (inst2 & 0x8000) == 0x0000
		   && pv_is_register (regs[bits (insn, 0, 3)], ARM_SP_REGNUM))
	    /* Ignore block loads from the stack, potentially copying
	       parameters from memory.  */
	    ;

	  else if ((insn & 0xffb0) == 0xe950	/* ldrd Rt, Rt2,
						   [Rn, #+/-imm] */
		   && pv_is_register (regs[bits (insn, 0, 3)], ARM_SP_REGNUM))
	    /* Similarly ignore dual loads from the stack.  */
	    ;

	  else if ((insn & 0xfff0) == 0xf850	/* ldr Rt,[Rn,#+/-imm] */
		   && (inst2 & 0x0d00) == 0x0c00
		   && pv_is_register (regs[bits (insn, 0, 3)], ARM_SP_REGNUM))
	    /* Similarly ignore single loads from the stack.  */
	    ;

	  else if ((insn & 0xfff0) == 0xf8d0	/* ldr.w Rt,[Rn,#imm] */
		   && pv_is_register (regs[bits (insn, 0, 3)], ARM_SP_REGNUM))
	    /* Similarly ignore single loads from the stack.  */
	    ;

	  else if ((insn & 0xfbf0) == 0xf100	/* add.w Rd, Rn, #imm */
		   && (inst2 & 0x8000) == 0x0000)
	    {
	      unsigned int imm = ((bits (insn, 10, 10) << 11)
				  | (bits (inst2, 12, 14) << 8)
				  | bits (inst2, 0, 7));

	      regs[bits (inst2, 8, 11)]
		= pv_add_constant (regs[bits (insn, 0, 3)],
				   thumb_expand_immediate (imm));
	    }

	  else if ((insn & 0xfbf0) == 0xf200	/* addw Rd, Rn, #imm */
		   && (inst2 & 0x8000) == 0x0000)
	    {
	      unsigned int imm = ((bits (insn, 10, 10) << 11)
				  | (bits (inst2, 12, 14) << 8)
				  | bits (inst2, 0, 7));

	      regs[bits (inst2, 8, 11)]
		= pv_add_constant (regs[bits (insn, 0, 3)], imm);
	    }

	  else if ((insn & 0xfbf0) == 0xf1a0	/* sub.w Rd, Rn, #imm */
		   && (inst2 & 0x8000) == 0x0000)
	    {
	      unsigned int imm = ((bits (insn, 10, 10) << 11)
				  | (bits (inst2, 12, 14) << 8)
				  | bits (inst2, 0, 7));

	      regs[bits (inst2, 8, 11)]
		= pv_add_constant (regs[bits (insn, 0, 3)],
				   - (CORE_ADDR) thumb_expand_immediate (imm));
	    }

	  else if ((insn & 0xfbf0) == 0xf2a0	/* subw Rd, Rn, #imm */
		   && (inst2 & 0x8000) == 0x0000)
	    {
	      unsigned int imm = ((bits (insn, 10, 10) << 11)
				  | (bits (inst2, 12, 14) << 8)
				  | bits (inst2, 0, 7));

	      regs[bits (inst2, 8, 11)]
		= pv_add_constant (regs[bits (insn, 0, 3)], - (CORE_ADDR) imm);
	    }

	  else if ((insn & 0xfbff) == 0xf04f)	/* mov.w Rd, #const */
	    {
	      unsigned int imm = ((bits (insn, 10, 10) << 11)
				  | (bits (inst2, 12, 14) << 8)
				  | bits (inst2, 0, 7));

	      regs[bits (inst2, 8, 11)]
		= pv_constant (thumb_expand_immediate (imm));
	    }

	  else if ((insn & 0xfbf0) == 0xf240)	/* movw Rd, #const */
	    {
	      unsigned int imm
		= EXTRACT_MOVW_MOVT_IMM_T (insn, inst2);

	      regs[bits (inst2, 8, 11)] = pv_constant (imm);
	    }

	  else if (insn == 0xea5f		/* mov.w Rd,Rm */
		   && (inst2 & 0xf0f0) == 0)
	    {
	      int dst_reg = (inst2 & 0x0f00) >> 8;
	      int src_reg = inst2 & 0xf;
	      regs[dst_reg] = regs[src_reg];
	    }

	  else if ((insn & 0xff7f) == 0xf85f)	/* ldr.w Rt,<label> */
	    {
	      /* Constant pool loads.  */
	      unsigned int constant;
	      CORE_ADDR loc;

	      offset = bits (insn, 0, 11);
	      if (insn & 0x0080)
		loc = start + 4 + offset;
	      else
		loc = start + 4 - offset;

	      constant = read_memory_unsigned_integer (loc, 4, byte_order);
	      regs[bits (inst2, 12, 15)] = pv_constant (constant);
	    }

	  else if ((insn & 0xff7f) == 0xe95f)	/* ldrd Rt,Rt2,<label> */
	    {
	      /* Constant pool loads.  */
	      unsigned int constant;
	      CORE_ADDR loc;

	      offset = bits (insn, 0, 7) << 2;
	      if (insn & 0x0080)
		loc = start + 4 + offset;
	      else
		loc = start + 4 - offset;

	      constant = read_memory_unsigned_integer (loc, 4, byte_order);
	      regs[bits (inst2, 12, 15)] = pv_constant (constant);

	      constant = read_memory_unsigned_integer (loc + 4, 4, byte_order);
	      regs[bits (inst2, 8, 11)] = pv_constant (constant);
	    }

	  else if (thumb2_instruction_changes_pc (insn, inst2))
	    {
	      /* Don't scan past anything that might change control flow.  */
	      break;
	    }
	  else
	    {
	      /* The optimizer might shove anything into the prologue,
		 so we just skip what we don't recognize.  */
	      unrecognized_pc = start;
	    }

	  start += 2;
	}
      else if (thumb_instruction_changes_pc (insn))
	{
	  /* Don't scan past anything that might change control flow.  */
	  break;
	}
      else
	{
	  /* The optimizer might shove anything into the prologue,
	     so we just skip what we don't recognize.  */
	  unrecognized_pc = start;
	}

      start += 2;
    }

  if (arm_debug)
    fprintf_unfiltered (gdb_stdlog, "Prologue scan stopped at %s\n",
			paddress (gdbarch, start));

  if (unrecognized_pc == 0)
    unrecognized_pc = start;

  if (cache == NULL)
    {
      do_cleanups (back_to);
      return unrecognized_pc;
    }

  if (pv_is_register (regs[ARM_FP_REGNUM], ARM_SP_REGNUM))
    {
      /* Frame pointer is fp.  Frame size is constant.  */
      cache->framereg = ARM_FP_REGNUM;
      cache->framesize = -regs[ARM_FP_REGNUM].k;
    }
  else if (pv_is_register (regs[THUMB_FP_REGNUM], ARM_SP_REGNUM))
    {
      /* Frame pointer is r7.  Frame size is constant.  */
      cache->framereg = THUMB_FP_REGNUM;
      cache->framesize = -regs[THUMB_FP_REGNUM].k;
    }
  else
    {
      /* Try the stack pointer... this is a bit desperate.  */
      cache->framereg = ARM_SP_REGNUM;
      cache->framesize = -regs[ARM_SP_REGNUM].k;
    }

  for (i = 0; i < 16; i++)
    if (pv_area_find_reg (stack, gdbarch, i, &offset))
      cache->saved_regs[i].addr = offset;

  do_cleanups (back_to);
  return unrecognized_pc;
}


/* Try to analyze the instructions starting from PC, which load symbol
   __stack_chk_guard.  Return the address of instruction after loading this
   symbol, set the dest register number to *BASEREG, and set the size of
   instructions for loading symbol in OFFSET.  Return 0 if instructions are
   not recognized.  */

static CORE_ADDR
arm_analyze_load_stack_chk_guard(CORE_ADDR pc, struct gdbarch *gdbarch,
				 unsigned int *destreg, int *offset)
{
  enum bfd_endian byte_order_for_code = gdbarch_byte_order_for_code (gdbarch);
  int is_thumb = arm_pc_is_thumb (gdbarch, pc);
  unsigned int low, high, address;

  address = 0;
  if (is_thumb)
    {
      unsigned short insn1
	= read_memory_unsigned_integer (pc, 2, byte_order_for_code);

      if ((insn1 & 0xf800) == 0x4800) /* ldr Rd, #immed */
	{
	  *destreg = bits (insn1, 8, 10);
	  *offset = 2;
	  address = bits (insn1, 0, 7);
	}
      else if ((insn1 & 0xfbf0) == 0xf240) /* movw Rd, #const */
	{
	  unsigned short insn2
	    = read_memory_unsigned_integer (pc + 2, 2, byte_order_for_code);

	  low = EXTRACT_MOVW_MOVT_IMM_T (insn1, insn2);

	  insn1
	    = read_memory_unsigned_integer (pc + 4, 2, byte_order_for_code);
	  insn2
	    = read_memory_unsigned_integer (pc + 6, 2, byte_order_for_code);

	  /* movt Rd, #const */
	  if ((insn1 & 0xfbc0) == 0xf2c0)
	    {
	      high = EXTRACT_MOVW_MOVT_IMM_T (insn1, insn2);
	      *destreg = bits (insn2, 8, 11);
	      *offset = 8;
	      address = (high << 16 | low);
	    }
	}
    }
  else
    {
      unsigned int insn
	= read_memory_unsigned_integer (pc, 4, byte_order_for_code);

      if ((insn & 0x0e5f0000) == 0x041f0000) /* ldr Rd, #immed */
	{
	  address = bits (insn, 0, 11);
	  *destreg = bits (insn, 12, 15);
	  *offset = 4;
	}
      else if ((insn & 0x0ff00000) == 0x03000000) /* movw Rd, #const */
	{
	  low = EXTRACT_MOVW_MOVT_IMM_A (insn);

	  insn
	    = read_memory_unsigned_integer (pc + 4, 4, byte_order_for_code);

	  if ((insn & 0x0ff00000) == 0x03400000) /* movt Rd, #const */
	    {
	      high = EXTRACT_MOVW_MOVT_IMM_A (insn);
	      *destreg = bits (insn, 12, 15);
	      *offset = 8;
	      address = (high << 16 | low);
	    }
	}
    }

  return address;
}

/* Try to skip a sequence of instructions used for stack protector.  If PC
   points to the first instruction of this sequence, return the address of
   first instruction after this sequence, otherwise, return original PC.

   On arm, this sequence of instructions is composed of mainly three steps,
     Step 1: load symbol __stack_chk_guard,
     Step 2: load from address of __stack_chk_guard,
     Step 3: store it to somewhere else.

   Usually, instructions on step 2 and step 3 are the same on various ARM
   architectures.  On step 2, it is one instruction 'ldr Rx, [Rn, #0]', and
   on step 3, it is also one instruction 'str Rx, [r7, #immd]'.  However,
   instructions in step 1 vary from different ARM architectures.  On ARMv7,
   they are,

	movw	Rn, #:lower16:__stack_chk_guard
	movt	Rn, #:upper16:__stack_chk_guard

   On ARMv5t, it is,

	ldr	Rn, .Label
	....
	.Lable:
	.word	__stack_chk_guard

   Since ldr/str is a very popular instruction, we can't use them as
   'fingerprint' or 'signature' of stack protector sequence.  Here we choose
   sequence {movw/movt, ldr}/ldr/str plus symbol __stack_chk_guard, if not
   stripped, as the 'fingerprint' of a stack protector cdoe sequence.  */

static CORE_ADDR
arm_skip_stack_protector(CORE_ADDR pc, struct gdbarch *gdbarch)
{
  enum bfd_endian byte_order_for_code = gdbarch_byte_order_for_code (gdbarch);
  unsigned int basereg;
  struct bound_minimal_symbol stack_chk_guard;
  int offset;
  int is_thumb = arm_pc_is_thumb (gdbarch, pc);
  CORE_ADDR addr;

  /* Try to parse the instructions in Step 1.  */
  addr = arm_analyze_load_stack_chk_guard (pc, gdbarch,
					   &basereg, &offset);
  if (!addr)
    return pc;

  stack_chk_guard = lookup_minimal_symbol_by_pc (addr);
  /* If name of symbol doesn't start with '__stack_chk_guard', this
     instruction sequence is not for stack protector.  If symbol is
     removed, we conservatively think this sequence is for stack protector.  */
  if (stack_chk_guard.minsym
      && strncmp (SYMBOL_LINKAGE_NAME (stack_chk_guard.minsym),
		  "__stack_chk_guard",
		  strlen ("__stack_chk_guard")) != 0)
   return pc;

  if (is_thumb)
    {
      unsigned int destreg;
      unsigned short insn
	= read_memory_unsigned_integer (pc + offset, 2, byte_order_for_code);

      /* Step 2: ldr Rd, [Rn, #immed], encoding T1.  */
      if ((insn & 0xf800) != 0x6800)
	return pc;
      if (bits (insn, 3, 5) != basereg)
	return pc;
      destreg = bits (insn, 0, 2);

      insn = read_memory_unsigned_integer (pc + offset + 2, 2,
					   byte_order_for_code);
      /* Step 3: str Rd, [Rn, #immed], encoding T1.  */
      if ((insn & 0xf800) != 0x6000)
	return pc;
      if (destreg != bits (insn, 0, 2))
	return pc;
    }
  else
    {
      unsigned int destreg;
      unsigned int insn
	= read_memory_unsigned_integer (pc + offset, 4, byte_order_for_code);

      /* Step 2: ldr Rd, [Rn, #immed], encoding A1.  */
      if ((insn & 0x0e500000) != 0x04100000)
	return pc;
      if (bits (insn, 16, 19) != basereg)
	return pc;
      destreg = bits (insn, 12, 15);
      /* Step 3: str Rd, [Rn, #immed], encoding A1.  */
      insn = read_memory_unsigned_integer (pc + offset + 4,
					   4, byte_order_for_code);
      if ((insn & 0x0e500000) != 0x04000000)
	return pc;
      if (bits (insn, 12, 15) != destreg)
	return pc;
    }
  /* The size of total two instructions ldr/str is 4 on Thumb-2, while 8
     on arm.  */
  if (is_thumb)
    return pc + offset + 4;
  else
    return pc + offset + 8;
}

/* Advance the PC across any function entry prologue instructions to
   reach some "real" code.

   The APCS (ARM Procedure Call Standard) defines the following
   prologue:

   mov          ip, sp
   [stmfd       sp!, {a1,a2,a3,a4}]
   stmfd        sp!, {...,fp,ip,lr,pc}
   [stfe        f7, [sp, #-12]!]
   [stfe        f6, [sp, #-12]!]
   [stfe        f5, [sp, #-12]!]
   [stfe        f4, [sp, #-12]!]
   sub fp, ip, #nn @@@@ nn == 20 or 4 depending on second insn.  */

static CORE_ADDR
arm_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  enum bfd_endian byte_order_for_code = gdbarch_byte_order_for_code (gdbarch);
  unsigned long inst;
  CORE_ADDR skip_pc;
  CORE_ADDR func_addr, limit_pc;

  /* See if we can determine the end of the prologue via the symbol table.
     If so, then return either PC, or the PC after the prologue, whichever
     is greater.  */
  if (find_pc_partial_function (pc, NULL, &func_addr, NULL))
    {
      CORE_ADDR post_prologue_pc
	= skip_prologue_using_sal (gdbarch, func_addr);
      struct symtab *s = find_pc_symtab (func_addr);

      if (post_prologue_pc)
	post_prologue_pc
	  = arm_skip_stack_protector (post_prologue_pc, gdbarch);


      /* GCC always emits a line note before the prologue and another
	 one after, even if the two are at the same address or on the
	 same line.  Take advantage of this so that we do not need to
	 know every instruction that might appear in the prologue.  We
	 will have producer information for most binaries; if it is
	 missing (e.g. for -gstabs), assuming the GNU tools.  */
      if (post_prologue_pc
	  && (s == NULL
	      || s->producer == NULL
	      || strncmp (s->producer, "GNU ", sizeof ("GNU ") - 1) == 0 
	      || strncmp (s->producer, "clang ", sizeof ("clang ") - 1) == 0))
	return post_prologue_pc;

      if (post_prologue_pc != 0)
	{
	  CORE_ADDR analyzed_limit;

	  /* For non-GCC compilers, make sure the entire line is an
	     acceptable prologue; GDB will round this function's
	     return value up to the end of the following line so we
	     can not skip just part of a line (and we do not want to).

	     RealView does not treat the prologue specially, but does
	     associate prologue code with the opening brace; so this
	     lets us skip the first line if we think it is the opening
	     brace.  */
	  if (arm_pc_is_thumb (gdbarch, func_addr))
	    analyzed_limit = thumb_analyze_prologue (gdbarch, func_addr,
						     post_prologue_pc, NULL);
	  else
	    analyzed_limit = arm_analyze_prologue (gdbarch, func_addr,
						   post_prologue_pc, NULL);

	  if (analyzed_limit != post_prologue_pc)
	    return func_addr;

	  return post_prologue_pc;
	}
    }

  /* Can't determine prologue from the symbol table, need to examine
     instructions.  */

  /* Find an upper limit on the function prologue using the debug
     information.  If the debug information could not be used to provide
     that bound, then use an arbitrary large number as the upper bound.  */
  /* Like arm_scan_prologue, stop no later than pc + 64.  */
  limit_pc = skip_prologue_using_sal (gdbarch, pc);
  if (limit_pc == 0)
    limit_pc = pc + 64;          /* Magic.  */


  /* Check if this is Thumb code.  */
  if (arm_pc_is_thumb (gdbarch, pc))
    return thumb_analyze_prologue (gdbarch, pc, limit_pc, NULL);

  for (skip_pc = pc; skip_pc < limit_pc; skip_pc += 4)
    {
      inst = read_memory_unsigned_integer (skip_pc, 4, byte_order_for_code);

      /* "mov ip, sp" is no longer a required part of the prologue.  */
      if (inst == 0xe1a0c00d)			/* mov ip, sp */
	continue;

      if ((inst & 0xfffff000) == 0xe28dc000)    /* add ip, sp #n */
	continue;

      if ((inst & 0xfffff000) == 0xe24dc000)    /* sub ip, sp #n */
	continue;

      /* Some prologues begin with "str lr, [sp, #-4]!".  */
      if (inst == 0xe52de004)			/* str lr, [sp, #-4]! */
	continue;

      if ((inst & 0xfffffff0) == 0xe92d0000)	/* stmfd sp!,{a1,a2,a3,a4} */
	continue;

      if ((inst & 0xfffff800) == 0xe92dd800)	/* stmfd sp!,{fp,ip,lr,pc} */
	continue;

      /* Any insns after this point may float into the code, if it makes
	 for better instruction scheduling, so we skip them only if we
	 find them, but still consider the function to be frame-ful.  */

      /* We may have either one sfmfd instruction here, or several stfe
	 insns, depending on the version of floating point code we
	 support.  */
      if ((inst & 0xffbf0fff) == 0xec2d0200)	/* sfmfd fn, <cnt>, [sp]! */
	continue;

      if ((inst & 0xffff8fff) == 0xed6d0103)	/* stfe fn, [sp, #-12]! */
	continue;

      if ((inst & 0xfffff000) == 0xe24cb000)	/* sub fp, ip, #nn */
	continue;

      if ((inst & 0xfffff000) == 0xe24dd000)	/* sub sp, sp, #nn */
	continue;

      if ((inst & 0xffffc000) == 0xe54b0000	/* strb r(0123),[r11,#-nn] */
	  || (inst & 0xffffc0f0) == 0xe14b00b0	/* strh r(0123),[r11,#-nn] */
	  || (inst & 0xffffc000) == 0xe50b0000)	/* str  r(0123),[r11,#-nn] */
	continue;

      if ((inst & 0xffffc000) == 0xe5cd0000	/* strb r(0123),[sp,#nn] */
	  || (inst & 0xffffc0f0) == 0xe1cd00b0	/* strh r(0123),[sp,#nn] */
	  || (inst & 0xffffc000) == 0xe58d0000)	/* str  r(0123),[sp,#nn] */
	continue;

      /* Un-recognized instruction; stop scanning.  */
      break;
    }

  return skip_pc;		/* End of prologue.  */
}

/* *INDENT-OFF* */
/* Function: thumb_scan_prologue (helper function for arm_scan_prologue)
   This function decodes a Thumb function prologue to determine:
     1) the size of the stack frame
     2) which registers are saved on it
     3) the offsets of saved regs
     4) the offset from the stack pointer to the frame pointer

   A typical Thumb function prologue would create this stack frame
   (offsets relative to FP)
     old SP ->	24  stack parameters
		20  LR
		16  R7
     R7 ->       0  local variables (16 bytes)
     SP ->     -12  additional stack space (12 bytes)
   The frame size would thus be 36 bytes, and the frame offset would be
   12 bytes.  The frame register is R7.
   
   The comments for thumb_skip_prolog() describe the algorithm we use
   to detect the end of the prolog.  */
/* *INDENT-ON* */

static void
thumb_scan_prologue (struct gdbarch *gdbarch, CORE_ADDR prev_pc,
		     CORE_ADDR block_addr, struct arm_prologue_cache *cache)
{
  CORE_ADDR prologue_start;
  CORE_ADDR prologue_end;

  if (find_pc_partial_function (block_addr, NULL, &prologue_start,
				&prologue_end))
    {
      /* See comment in arm_scan_prologue for an explanation of
	 this heuristics.  */
      if (prologue_end > prologue_start + 64)
	{
	  prologue_end = prologue_start + 64;
	}
    }
  else
    /* We're in the boondocks: we have no idea where the start of the
       function is.  */
    return;

  prologue_end = min (prologue_end, prev_pc);

  thumb_analyze_prologue (gdbarch, prologue_start, prologue_end, cache);
}

/* Return 1 if THIS_INSTR might change control flow, 0 otherwise.  */

static int
arm_instruction_changes_pc (uint32_t this_instr)
{
  if (bits (this_instr, 28, 31) == INST_NV)
    /* Unconditional instructions.  */
    switch (bits (this_instr, 24, 27))
      {
      case 0xa:
      case 0xb:
	/* Branch with Link and change to Thumb.  */
	return 1;
      case 0xc:
      case 0xd:
      case 0xe:
	/* Coprocessor register transfer.  */
        if (bits (this_instr, 12, 15) == 15)
	  error (_("Invalid update to pc in instruction"));
	return 0;
      default:
	return 0;
      }
  else
    switch (bits (this_instr, 25, 27))
      {
      case 0x0:
	if (bits (this_instr, 23, 24) == 2 && bit (this_instr, 20) == 0)
	  {
	    /* Multiplies and extra load/stores.  */
	    if (bit (this_instr, 4) == 1 && bit (this_instr, 7) == 1)
	      /* Neither multiplies nor extension load/stores are allowed
		 to modify PC.  */
	      return 0;

	    /* Otherwise, miscellaneous instructions.  */

	    /* BX <reg>, BXJ <reg>, BLX <reg> */
	    if (bits (this_instr, 4, 27) == 0x12fff1
		|| bits (this_instr, 4, 27) == 0x12fff2
		|| bits (this_instr, 4, 27) == 0x12fff3)
	      return 1;

	    /* Other miscellaneous instructions are unpredictable if they
	       modify PC.  */
	    return 0;
	  }
	/* Data processing instruction.  Fall through.  */

      case 0x1:
	if (bits (this_instr, 12, 15) == 15)
	  return 1;
	else
	  return 0;

      case 0x2:
      case 0x3:
	/* Media instructions and architecturally undefined instructions.  */
	if (bits (this_instr, 25, 27) == 3 && bit (this_instr, 4) == 1)
	  return 0;

	/* Stores.  */
	if (bit (this_instr, 20) == 0)
	  return 0;

	/* Loads.  */
	if (bits (this_instr, 12, 15) == ARM_PC_REGNUM)
	  return 1;
	else
	  return 0;

      case 0x4:
	/* Load/store multiple.  */
	if (bit (this_instr, 20) == 1 && bit (this_instr, 15) == 1)
	  return 1;
	else
	  return 0;

      case 0x5:
	/* Branch and branch with link.  */
	return 1;

      case 0x6:
      case 0x7:
	/* Coprocessor transfers or SWIs can not affect PC.  */
	return 0;

      default:
	internal_error (__FILE__, __LINE__, _("bad value in switch"));
      }
}

/* Analyze an ARM mode prologue starting at PROLOGUE_START and
   continuing no further than PROLOGUE_END.  If CACHE is non-NULL,
   fill it in.  Return the first address not recognized as a prologue
   instruction.

   We recognize all the instructions typically found in ARM prologues,
   plus harmless instructions which can be skipped (either for analysis
   purposes, or a more restrictive set that can be skipped when finding
   the end of the prologue).  */

static CORE_ADDR
arm_analyze_prologue (struct gdbarch *gdbarch,
		      CORE_ADDR prologue_start, CORE_ADDR prologue_end,
		      struct arm_prologue_cache *cache)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  enum bfd_endian byte_order_for_code = gdbarch_byte_order_for_code (gdbarch);
  int regno;
  CORE_ADDR offset, current_pc;
  pv_t regs[ARM_FPS_REGNUM];
  struct pv_area *stack;
  struct cleanup *back_to;
  int framereg, framesize;
  CORE_ADDR unrecognized_pc = 0;

  /* Search the prologue looking for instructions that set up the
     frame pointer, adjust the stack pointer, and save registers.

     Be careful, however, and if it doesn't look like a prologue,
     don't try to scan it.  If, for instance, a frameless function
     begins with stmfd sp!, then we will tell ourselves there is
     a frame, which will confuse stack traceback, as well as "finish" 
     and other operations that rely on a knowledge of the stack
     traceback.  */

  for (regno = 0; regno < ARM_FPS_REGNUM; regno++)
    regs[regno] = pv_register (regno, 0);
  stack = make_pv_area (ARM_SP_REGNUM, gdbarch_addr_bit (gdbarch));
  back_to = make_cleanup_free_pv_area (stack);

  for (current_pc = prologue_start;
       current_pc < prologue_end;
       current_pc += 4)
    {
      unsigned int insn
	= read_memory_unsigned_integer (current_pc, 4, byte_order_for_code);

      if (insn == 0xe1a0c00d)		/* mov ip, sp */
	{
	  regs[ARM_IP_REGNUM] = regs[ARM_SP_REGNUM];
	  continue;
	}
      else if ((insn & 0xfff00000) == 0xe2800000	/* add Rd, Rn, #n */
	       && pv_is_register (regs[bits (insn, 16, 19)], ARM_SP_REGNUM))
	{
	  unsigned imm = insn & 0xff;                   /* immediate value */
	  unsigned rot = (insn & 0xf00) >> 7;           /* rotate amount */
	  int rd = bits (insn, 12, 15);
	  imm = (imm >> rot) | (imm << (32 - rot));
	  regs[rd] = pv_add_constant (regs[bits (insn, 16, 19)], imm);
	  continue;
	}
      else if ((insn & 0xfff00000) == 0xe2400000	/* sub Rd, Rn, #n */
	       && pv_is_register (regs[bits (insn, 16, 19)], ARM_SP_REGNUM))
	{
	  unsigned imm = insn & 0xff;                   /* immediate value */
	  unsigned rot = (insn & 0xf00) >> 7;           /* rotate amount */
	  int rd = bits (insn, 12, 15);
	  imm = (imm >> rot) | (imm << (32 - rot));
	  regs[rd] = pv_add_constant (regs[bits (insn, 16, 19)], -imm);
	  continue;
	}
      else if ((insn & 0xffff0fff) == 0xe52d0004)	/* str Rd,
							   [sp, #-4]! */
	{
	  if (pv_area_store_would_trash (stack, regs[ARM_SP_REGNUM]))
	    break;
	  regs[ARM_SP_REGNUM] = pv_add_constant (regs[ARM_SP_REGNUM], -4);
	  pv_area_store (stack, regs[ARM_SP_REGNUM], 4,
			 regs[bits (insn, 12, 15)]);
	  continue;
	}
      else if ((insn & 0xffff0000) == 0xe92d0000)
	/* stmfd sp!, {..., fp, ip, lr, pc}
	   or
	   stmfd sp!, {a1, a2, a3, a4}  */
	{
	  int mask = insn & 0xffff;

	  if (pv_area_store_would_trash (stack, regs[ARM_SP_REGNUM]))
	    break;

	  /* Calculate offsets of saved registers.  */
	  for (regno = ARM_PC_REGNUM; regno >= 0; regno--)
	    if (mask & (1 << regno))
	      {
		regs[ARM_SP_REGNUM]
		  = pv_add_constant (regs[ARM_SP_REGNUM], -4);
		pv_area_store (stack, regs[ARM_SP_REGNUM], 4, regs[regno]);
	      }
	}
      else if ((insn & 0xffff0000) == 0xe54b0000	/* strb rx,[r11,#-n] */
	       || (insn & 0xffff00f0) == 0xe14b00b0	/* strh rx,[r11,#-n] */
	       || (insn & 0xffffc000) == 0xe50b0000)	/* str  rx,[r11,#-n] */
	{
	  /* No need to add this to saved_regs -- it's just an arg reg.  */
	  continue;
	}
      else if ((insn & 0xffff0000) == 0xe5cd0000	/* strb rx,[sp,#n] */
	       || (insn & 0xffff00f0) == 0xe1cd00b0	/* strh rx,[sp,#n] */
	       || (insn & 0xffffc000) == 0xe58d0000)	/* str  rx,[sp,#n] */
	{
	  /* No need to add this to saved_regs -- it's just an arg reg.  */
	  continue;
	}
      else if ((insn & 0xfff00000) == 0xe8800000	/* stm Rn,
							   { registers } */
	       && pv_is_register (regs[bits (insn, 16, 19)], ARM_SP_REGNUM))
	{
	  /* No need to add this to saved_regs -- it's just arg regs.  */
	  continue;
	}
      else if ((insn & 0xfffff000) == 0xe24cb000)	/* sub fp, ip #n */
	{
	  unsigned imm = insn & 0xff;			/* immediate value */
	  unsigned rot = (insn & 0xf00) >> 7;		/* rotate amount */
	  imm = (imm >> rot) | (imm << (32 - rot));
	  regs[ARM_FP_REGNUM] = pv_add_constant (regs[ARM_IP_REGNUM], -imm);
	}
      else if ((insn & 0xfffff000) == 0xe24dd000)	/* sub sp, sp #n */
	{
	  unsigned imm = insn & 0xff;			/* immediate value */
	  unsigned rot = (insn & 0xf00) >> 7;		/* rotate amount */
	  imm = (imm >> rot) | (imm << (32 - rot));
	  regs[ARM_SP_REGNUM] = pv_add_constant (regs[ARM_SP_REGNUM], -imm);
	}
      else if ((insn & 0xffff7fff) == 0xed6d0103	/* stfe f?,
							   [sp, -#c]! */
	       && gdbarch_tdep (gdbarch)->have_fpa_registers)
	{
	  if (pv_area_store_would_trash (stack, regs[ARM_SP_REGNUM]))
	    break;

	  regs[ARM_SP_REGNUM] = pv_add_constant (regs[ARM_SP_REGNUM], -12);
	  regno = ARM_F0_REGNUM + ((insn >> 12) & 0x07);
	  pv_area_store (stack, regs[ARM_SP_REGNUM], 12, regs[regno]);
	}
      else if ((insn & 0xffbf0fff) == 0xec2d0200	/* sfmfd f0, 4,
							   [sp!] */
	       && gdbarch_tdep (gdbarch)->have_fpa_registers)
	{
	  int n_saved_fp_regs;
	  unsigned int fp_start_reg, fp_bound_reg;

	  if (pv_area_store_would_trash (stack, regs[ARM_SP_REGNUM]))
	    break;

	  if ((insn & 0x800) == 0x800)		/* N0 is set */
	    {
	      if ((insn & 0x40000) == 0x40000)	/* N1 is set */
		n_saved_fp_regs = 3;
	      else
		n_saved_fp_regs = 1;
	    }
	  else
	    {
	      if ((insn & 0x40000) == 0x40000)	/* N1 is set */
		n_saved_fp_regs = 2;
	      else
		n_saved_fp_regs = 4;
	    }

	  fp_start_reg = ARM_F0_REGNUM + ((insn >> 12) & 0x7);
	  fp_bound_reg = fp_start_reg + n_saved_fp_regs;
	  for (; fp_start_reg < fp_bound_reg; fp_start_reg++)
	    {
	      regs[ARM_SP_REGNUM] = pv_add_constant (regs[ARM_SP_REGNUM], -12);
	      pv_area_store (stack, regs[ARM_SP_REGNUM], 12,
			     regs[fp_start_reg++]);
	    }
	}
      else if ((insn & 0xff000000) == 0xeb000000 && cache == NULL) /* bl */
	{
	  /* Allow some special function calls when skipping the
	     prologue; GCC generates these before storing arguments to
	     the stack.  */
	  CORE_ADDR dest = BranchDest (current_pc, insn);

	  if (skip_prologue_function (gdbarch, dest, 0))
	    continue;
	  else
	    break;
	}
      else if ((insn & 0xf0000000) != 0xe0000000)
	break;			/* Condition not true, exit early.  */
      else if (arm_instruction_changes_pc (insn))
	/* Don't scan past anything that might change control flow.  */
	break;
      else if ((insn & 0xfe500000) == 0xe8100000	/* ldm */
	       && pv_is_register (regs[bits (insn, 16, 19)], ARM_SP_REGNUM))
	/* Ignore block loads from the stack, potentially copying
	   parameters from memory.  */
	continue;
      else if ((insn & 0xfc500000) == 0xe4100000
	       && pv_is_register (regs[bits (insn, 16, 19)], ARM_SP_REGNUM))
	/* Similarly ignore single loads from the stack.  */
	continue;
      else if ((insn & 0xffff0ff0) == 0xe1a00000)
	/* MOV Rd, Rm.  Skip register copies, i.e. saves to another
	   register instead of the stack.  */
	continue;
      else
	{
	  /* The optimizer might shove anything into the prologue,
	     so we just skip what we don't recognize.  */
	  unrecognized_pc = current_pc;
	  continue;
	}
    }

  if (unrecognized_pc == 0)
    unrecognized_pc = current_pc;

  /* The frame size is just the distance from the frame register
     to the original stack pointer.  */
  if (pv_is_register (regs[ARM_FP_REGNUM], ARM_SP_REGNUM))
    {
      /* Frame pointer is fp.  */
      framereg = ARM_FP_REGNUM;
      framesize = -regs[ARM_FP_REGNUM].k;
    }
  else
    {
      /* Try the stack pointer... this is a bit desperate.  */
      framereg = ARM_SP_REGNUM;
      framesize = -regs[ARM_SP_REGNUM].k;
    }

  if (cache)
    {
      cache->framereg = framereg;
      cache->framesize = framesize;

      for (regno = 0; regno < ARM_FPS_REGNUM; regno++)
	if (pv_area_find_reg (stack, gdbarch, regno, &offset))
	  cache->saved_regs[regno].addr = offset;
    }

  if (arm_debug)
    fprintf_unfiltered (gdb_stdlog, "Prologue scan stopped at %s\n",
			paddress (gdbarch, unrecognized_pc));

  do_cleanups (back_to);
  return unrecognized_pc;
}

static void
arm_scan_prologue (struct frame_info *this_frame,
		   struct arm_prologue_cache *cache)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  int regno;
  CORE_ADDR prologue_start, prologue_end, current_pc;
  CORE_ADDR prev_pc = get_frame_pc (this_frame);
  CORE_ADDR block_addr = get_frame_address_in_block (this_frame);
  pv_t regs[ARM_FPS_REGNUM];
  struct pv_area *stack;
  struct cleanup *back_to;
  CORE_ADDR offset;

  /* Assume there is no frame until proven otherwise.  */
  cache->framereg = ARM_SP_REGNUM;
  cache->framesize = 0;

  /* Check for Thumb prologue.  */
  if (arm_frame_is_thumb (this_frame))
    {
      thumb_scan_prologue (gdbarch, prev_pc, block_addr, cache);
      return;
    }

  /* Find the function prologue.  If we can't find the function in
     the symbol table, peek in the stack frame to find the PC.  */
  if (find_pc_partial_function (block_addr, NULL, &prologue_start,
				&prologue_end))
    {
      /* One way to find the end of the prologue (which works well
         for unoptimized code) is to do the following:

	    struct symtab_and_line sal = find_pc_line (prologue_start, 0);

	    if (sal.line == 0)
	      prologue_end = prev_pc;
	    else if (sal.end < prologue_end)
	      prologue_end = sal.end;

	 This mechanism is very accurate so long as the optimizer
	 doesn't move any instructions from the function body into the
	 prologue.  If this happens, sal.end will be the last
	 instruction in the first hunk of prologue code just before
	 the first instruction that the scheduler has moved from
	 the body to the prologue.

	 In order to make sure that we scan all of the prologue
	 instructions, we use a slightly less accurate mechanism which
	 may scan more than necessary.  To help compensate for this
	 lack of accuracy, the prologue scanning loop below contains
	 several clauses which'll cause the loop to terminate early if
	 an implausible prologue instruction is encountered.

	 The expression

	      prologue_start + 64

	 is a suitable endpoint since it accounts for the largest
	 possible prologue plus up to five instructions inserted by
	 the scheduler.  */

      if (prologue_end > prologue_start + 64)
	{
	  prologue_end = prologue_start + 64;	/* See above.  */
	}
    }
  else
    {
      /* We have no symbol information.  Our only option is to assume this
	 function has a standard stack frame and the normal frame register.
	 Then, we can find the value of our frame pointer on entrance to
	 the callee (or at the present moment if this is the innermost frame).
	 The value stored there should be the address of the stmfd + 8.  */
      CORE_ADDR frame_loc;
      LONGEST return_value;

      frame_loc = get_frame_register_unsigned (this_frame, ARM_FP_REGNUM);
      if (!safe_read_memory_integer (frame_loc, 4, byte_order, &return_value))
        return;
      else
        {
          prologue_start = gdbarch_addr_bits_remove
			     (gdbarch, return_value) - 8;
          prologue_end = prologue_start + 64;	/* See above.  */
        }
    }

  if (prev_pc < prologue_end)
    prologue_end = prev_pc;

  arm_analyze_prologue (gdbarch, prologue_start, prologue_end, cache);
}

static struct arm_prologue_cache *
arm_make_prologue_cache (struct frame_info *this_frame)
{
  int reg;
  struct arm_prologue_cache *cache;
  CORE_ADDR unwound_fp;

  cache = FRAME_OBSTACK_ZALLOC (struct arm_prologue_cache);
  cache->saved_regs = trad_frame_alloc_saved_regs (this_frame);

  arm_scan_prologue (this_frame, cache);

  unwound_fp = get_frame_register_unsigned (this_frame, cache->framereg);
  if (unwound_fp == 0)
    return cache;

  cache->prev_sp = unwound_fp + cache->framesize;

  /* Calculate actual addresses of saved registers using offsets
     determined by arm_scan_prologue.  */
  for (reg = 0; reg < gdbarch_num_regs (get_frame_arch (this_frame)); reg++)
    if (trad_frame_addr_p (cache->saved_regs, reg))
      cache->saved_regs[reg].addr += cache->prev_sp;

  return cache;
}

/* Our frame ID for a normal frame is the current function's starting PC
   and the caller's SP when we were called.  */

static void
arm_prologue_this_id (struct frame_info *this_frame,
		      void **this_cache,
		      struct frame_id *this_id)
{
  struct arm_prologue_cache *cache;
  struct frame_id id;
  CORE_ADDR pc, func;

  if (*this_cache == NULL)
    *this_cache = arm_make_prologue_cache (this_frame);
  cache = *this_cache;

  /* This is meant to halt the backtrace at "_start".  */
  pc = get_frame_pc (this_frame);
  if (pc <= gdbarch_tdep (get_frame_arch (this_frame))->lowest_pc)
    return;

  /* If we've hit a wall, stop.  */
  if (cache->prev_sp == 0)
    return;

  /* Use function start address as part of the frame ID.  If we cannot
     identify the start address (due to missing symbol information),
     fall back to just using the current PC.  */
  func = get_frame_func (this_frame);
  if (!func)
    func = pc;

  id = frame_id_build (cache->prev_sp, func);
  *this_id = id;
}

static struct value *
arm_prologue_prev_register (struct frame_info *this_frame,
			    void **this_cache,
			    int prev_regnum)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  struct arm_prologue_cache *cache;

  if (*this_cache == NULL)
    *this_cache = arm_make_prologue_cache (this_frame);
  cache = *this_cache;

  /* If we are asked to unwind the PC, then we need to return the LR
     instead.  The prologue may save PC, but it will point into this
     frame's prologue, not the next frame's resume location.  Also
     strip the saved T bit.  A valid LR may have the low bit set, but
     a valid PC never does.  */
  if (prev_regnum == ARM_PC_REGNUM)
    {
      CORE_ADDR lr;

      lr = frame_unwind_register_unsigned (this_frame, ARM_LR_REGNUM);
      return frame_unwind_got_constant (this_frame, prev_regnum,
					arm_addr_bits_remove (gdbarch, lr));
    }

  /* SP is generally not saved to the stack, but this frame is
     identified by the next frame's stack pointer at the time of the call.
     The value was already reconstructed into PREV_SP.  */
  if (prev_regnum == ARM_SP_REGNUM)
    return frame_unwind_got_constant (this_frame, prev_regnum, cache->prev_sp);

  /* The CPSR may have been changed by the call instruction and by the
     called function.  The only bit we can reconstruct is the T bit,
     by checking the low bit of LR as of the call.  This is a reliable
     indicator of Thumb-ness except for some ARM v4T pre-interworking
     Thumb code, which could get away with a clear low bit as long as
     the called function did not use bx.  Guess that all other
     bits are unchanged; the condition flags are presumably lost,
     but the processor status is likely valid.  */
  if (prev_regnum == ARM_PS_REGNUM)
    {
      CORE_ADDR lr, cpsr;
      ULONGEST t_bit = arm_psr_thumb_bit (gdbarch);

      cpsr = get_frame_register_unsigned (this_frame, prev_regnum);
      lr = frame_unwind_register_unsigned (this_frame, ARM_LR_REGNUM);
      if (IS_THUMB_ADDR (lr))
	cpsr |= t_bit;
      else
	cpsr &= ~t_bit;
      return frame_unwind_got_constant (this_frame, prev_regnum, cpsr);
    }

  return trad_frame_get_prev_register (this_frame, cache->saved_regs,
				       prev_regnum);
}

struct frame_unwind arm_prologue_unwind = {
  NORMAL_FRAME,
  default_frame_unwind_stop_reason,
  arm_prologue_this_id,
  arm_prologue_prev_register,
  NULL,
  default_frame_sniffer
};

/* Maintain a list of ARM exception table entries per objfile, similar to the
   list of mapping symbols.  We only cache entries for standard ARM-defined
   personality routines; the cache will contain only the frame unwinding
   instructions associated with the entry (not the descriptors).  */

static const struct objfile_data *arm_exidx_data_key;

struct arm_exidx_entry
{
  bfd_vma addr;
  gdb_byte *entry;
};
typedef struct arm_exidx_entry arm_exidx_entry_s;
DEF_VEC_O(arm_exidx_entry_s);

struct arm_exidx_data
{
  VEC(arm_exidx_entry_s) **section_maps;
};

static void
arm_exidx_data_free (struct objfile *objfile, void *arg)
{
  struct arm_exidx_data *data = arg;
  unsigned int i;

  for (i = 0; i < objfile->obfd->section_count; i++)
    VEC_free (arm_exidx_entry_s, data->section_maps[i]);
}

static inline int
arm_compare_exidx_entries (const struct arm_exidx_entry *lhs,
			   const struct arm_exidx_entry *rhs)
{
  return lhs->addr < rhs->addr;
}

static struct obj_section *
arm_obj_section_from_vma (struct objfile *objfile, bfd_vma vma)
{
  struct obj_section *osect;

  ALL_OBJFILE_OSECTIONS (objfile, osect)
    if (bfd_get_section_flags (objfile->obfd,
			       osect->the_bfd_section) & SEC_ALLOC)
      {
	bfd_vma start, size;
	start = bfd_get_section_vma (objfile->obfd, osect->the_bfd_section);
	size = bfd_get_section_size (osect->the_bfd_section);

	if (start <= vma && vma < start + size)
	  return osect;
      }

  return NULL;
}

/* Parse contents of exception table and exception index sections
   of OBJFILE, and fill in the exception table entry cache.

   For each entry that refers to a standard ARM-defined personality
   routine, extract the frame unwinding instructions (from either
   the index or the table section).  The unwinding instructions
   are normalized by:
    - extracting them from the rest of the table data
    - converting to host endianness
    - appending the implicit 0xb0 ("Finish") code

   The extracted and normalized instructions are stored for later
   retrieval by the arm_find_exidx_entry routine.  */
 
static void
arm_exidx_new_objfile (struct objfile *objfile)
{
  struct cleanup *cleanups;
  struct arm_exidx_data *data;
  asection *exidx, *extab;
  bfd_vma exidx_vma = 0, extab_vma = 0;
  bfd_size_type exidx_size = 0, extab_size = 0;
  gdb_byte *exidx_data = NULL, *extab_data = NULL;
  LONGEST i;

  /* If we've already touched this file, do nothing.  */
  if (!objfile || objfile_data (objfile, arm_exidx_data_key) != NULL)
    return;
  cleanups = make_cleanup (null_cleanup, NULL);

  /* Read contents of exception table and index.  */
  exidx = bfd_get_section_by_name (objfile->obfd, ".ARM.exidx");
  if (exidx)
    {
      exidx_vma = bfd_section_vma (objfile->obfd, exidx);
      exidx_size = bfd_get_section_size (exidx);
      exidx_data = xmalloc (exidx_size);
      make_cleanup (xfree, exidx_data);

      if (!bfd_get_section_contents (objfile->obfd, exidx,
				     exidx_data, 0, exidx_size))
	{
	  do_cleanups (cleanups);
	  return;
	}
    }

  extab = bfd_get_section_by_name (objfile->obfd, ".ARM.extab");
  if (extab)
    {
      extab_vma = bfd_section_vma (objfile->obfd, extab);
      extab_size = bfd_get_section_size (extab);
      extab_data = xmalloc (extab_size);
      make_cleanup (xfree, extab_data);

      if (!bfd_get_section_contents (objfile->obfd, extab,
				     extab_data, 0, extab_size))
	{
	  do_cleanups (cleanups);
	  return;
	}
    }

  /* Allocate exception table data structure.  */
  data = OBSTACK_ZALLOC (&objfile->objfile_obstack, struct arm_exidx_data);
  set_objfile_data (objfile, arm_exidx_data_key, data);
  data->section_maps = OBSTACK_CALLOC (&objfile->objfile_obstack,
				       objfile->obfd->section_count,
				       VEC(arm_exidx_entry_s) *);

  /* Fill in exception table.  */
  for (i = 0; i < exidx_size / 8; i++)
    {
      struct arm_exidx_entry new_exidx_entry;
      bfd_vma idx = bfd_h_get_32 (objfile->obfd, exidx_data + i * 8);
      bfd_vma val = bfd_h_get_32 (objfile->obfd, exidx_data + i * 8 + 4);
      bfd_vma addr = 0, word = 0;
      int n_bytes = 0, n_words = 0;
      struct obj_section *sec;
      gdb_byte *entry = NULL;

      /* Extract address of start of function.  */
      idx = ((idx & 0x7fffffff) ^ 0x40000000) - 0x40000000;
      idx += exidx_vma + i * 8;

      /* Find section containing function and compute section offset.  */
      sec = arm_obj_section_from_vma (objfile, idx);
      if (sec == NULL)
	continue;
      idx -= bfd_get_section_vma (objfile->obfd, sec->the_bfd_section);

      /* Determine address of exception table entry.  */
      if (val == 1)
	{
	  /* EXIDX_CANTUNWIND -- no exception table entry present.  */
	}
      else if ((val & 0xff000000) == 0x80000000)
	{
	  /* Exception table entry embedded in .ARM.exidx
	     -- must be short form.  */
	  word = val;
	  n_bytes = 3;
	}
      else if (!(val & 0x80000000))
	{
	  /* Exception table entry in .ARM.extab.  */
	  addr = ((val & 0x7fffffff) ^ 0x40000000) - 0x40000000;
	  addr += exidx_vma + i * 8 + 4;

	  if (addr >= extab_vma && addr + 4 <= extab_vma + extab_size)
	    {
	      word = bfd_h_get_32 (objfile->obfd,
				   extab_data + addr - extab_vma);
	      addr += 4;

	      if ((word & 0xff000000) == 0x80000000)
		{
		  /* Short form.  */
		  n_bytes = 3;
		}
	      else if ((word & 0xff000000) == 0x81000000
		       || (word & 0xff000000) == 0x82000000)
		{
		  /* Long form.  */
		  n_bytes = 2;
		  n_words = ((word >> 16) & 0xff);
		}
	      else if (!(word & 0x80000000))
		{
		  bfd_vma pers;
		  struct obj_section *pers_sec;
		  int gnu_personality = 0;

		  /* Custom personality routine.  */
		  pers = ((word & 0x7fffffff) ^ 0x40000000) - 0x40000000;
		  pers = UNMAKE_THUMB_ADDR (pers + addr - 4);

		  /* Check whether we've got one of the variants of the
		     GNU personality routines.  */
		  pers_sec = arm_obj_section_from_vma (objfile, pers);
		  if (pers_sec)
		    {
		      static const char *personality[] = 
			{
			  "__gcc_personality_v0",
			  "__gxx_personality_v0",
			  "__gcj_personality_v0",
			  "__gnu_objc_personality_v0",
			  NULL
			};

		      CORE_ADDR pc = pers + obj_section_offset (pers_sec);
		      int k;

		      for (k = 0; personality[k]; k++)
			if (lookup_minimal_symbol_by_pc_name
			      (pc, personality[k], objfile))
			  {
			    gnu_personality = 1;
			    break;
			  }
		    }

		  /* If so, the next word contains a word count in the high
		     byte, followed by the same unwind instructions as the
		     pre-defined forms.  */
		  if (gnu_personality
		      && addr + 4 <= extab_vma + extab_size)
		    {
		      word = bfd_h_get_32 (objfile->obfd,
					   extab_data + addr - extab_vma);
		      addr += 4;
		      n_bytes = 3;
		      n_words = ((word >> 24) & 0xff);
		    }
		}
	    }
	}

      /* Sanity check address.  */
      if (n_words)
	if (addr < extab_vma || addr + 4 * n_words > extab_vma + extab_size)
	  n_words = n_bytes = 0;

      /* The unwind instructions reside in WORD (only the N_BYTES least
	 significant bytes are valid), followed by N_WORDS words in the
	 extab section starting at ADDR.  */
      if (n_bytes || n_words)
	{
	  gdb_byte *p = entry = obstack_alloc (&objfile->objfile_obstack,
					       n_bytes + n_words * 4 + 1);

	  while (n_bytes--)
	    *p++ = (gdb_byte) ((word >> (8 * n_bytes)) & 0xff);

	  while (n_words--)
	    {
	      word = bfd_h_get_32 (objfile->obfd,
				   extab_data + addr - extab_vma);
	      addr += 4;

	      *p++ = (gdb_byte) ((word >> 24) & 0xff);
	      *p++ = (gdb_byte) ((word >> 16) & 0xff);
	      *p++ = (gdb_byte) ((word >> 8) & 0xff);
	      *p++ = (gdb_byte) (word & 0xff);
	    }

	  /* Implied "Finish" to terminate the list.  */
	  *p++ = 0xb0;
	}

      /* Push entry onto vector.  They are guaranteed to always
	 appear in order of increasing addresses.  */
      new_exidx_entry.addr = idx;
      new_exidx_entry.entry = entry;
      VEC_safe_push (arm_exidx_entry_s,
		     data->section_maps[sec->the_bfd_section->index],
		     &new_exidx_entry);
    }

  do_cleanups (cleanups);
}

/* Search for the exception table entry covering MEMADDR.  If one is found,
   return a pointer to its data.  Otherwise, return 0.  If START is non-NULL,
   set *START to the start of the region covered by this entry.  */

static gdb_byte *
arm_find_exidx_entry (CORE_ADDR memaddr, CORE_ADDR *start)
{
  struct obj_section *sec;

  sec = find_pc_section (memaddr);
  if (sec != NULL)
    {
      struct arm_exidx_data *data;
      VEC(arm_exidx_entry_s) *map;
      struct arm_exidx_entry map_key = { memaddr - obj_section_addr (sec), 0 };
      unsigned int idx;

      data = objfile_data (sec->objfile, arm_exidx_data_key);
      if (data != NULL)
	{
	  map = data->section_maps[sec->the_bfd_section->index];
	  if (!VEC_empty (arm_exidx_entry_s, map))
	    {
	      struct arm_exidx_entry *map_sym;

	      idx = VEC_lower_bound (arm_exidx_entry_s, map, &map_key,
				     arm_compare_exidx_entries);

	      /* VEC_lower_bound finds the earliest ordered insertion
		 point.  If the following symbol starts at this exact
		 address, we use that; otherwise, the preceding
		 exception table entry covers this address.  */
	      if (idx < VEC_length (arm_exidx_entry_s, map))
		{
		  map_sym = VEC_index (arm_exidx_entry_s, map, idx);
		  if (map_sym->addr == map_key.addr)
		    {
		      if (start)
			*start = map_sym->addr + obj_section_addr (sec);
		      return map_sym->entry;
		    }
		}

	      if (idx > 0)
		{
		  map_sym = VEC_index (arm_exidx_entry_s, map, idx - 1);
		  if (start)
		    *start = map_sym->addr + obj_section_addr (sec);
		  return map_sym->entry;
		}
	    }
	}
    }

  return NULL;
}

/* Given the current frame THIS_FRAME, and its associated frame unwinding
   instruction list from the ARM exception table entry ENTRY, allocate and
   return a prologue cache structure describing how to unwind this frame.

   Return NULL if the unwinding instruction list contains a "spare",
   "reserved" or "refuse to unwind" instruction as defined in section
   "9.3 Frame unwinding instructions" of the "Exception Handling ABI
   for the ARM Architecture" document.  */

static struct arm_prologue_cache *
arm_exidx_fill_cache (struct frame_info *this_frame, gdb_byte *entry)
{
  CORE_ADDR vsp = 0;
  int vsp_valid = 0;

  struct arm_prologue_cache *cache;
  cache = FRAME_OBSTACK_ZALLOC (struct arm_prologue_cache);
  cache->saved_regs = trad_frame_alloc_saved_regs (this_frame);

  for (;;)
    {
      gdb_byte insn;

      /* Whenever we reload SP, we actually have to retrieve its
	 actual value in the current frame.  */
      if (!vsp_valid)
	{
	  if (trad_frame_realreg_p (cache->saved_regs, ARM_SP_REGNUM))
	    {
	      int reg = cache->saved_regs[ARM_SP_REGNUM].realreg;
	      vsp = get_frame_register_unsigned (this_frame, reg);
	    }
	  else
	    {
	      CORE_ADDR addr = cache->saved_regs[ARM_SP_REGNUM].addr;
	      vsp = get_frame_memory_unsigned (this_frame, addr, 4);
	    }

	  vsp_valid = 1;
	}

      /* Decode next unwind instruction.  */
      insn = *entry++;

      if ((insn & 0xc0) == 0)
	{
	  int offset = insn & 0x3f;
	  vsp += (offset << 2) + 4;
	}
      else if ((insn & 0xc0) == 0x40)
	{
	  int offset = insn & 0x3f;
	  vsp -= (offset << 2) + 4;
	}
      else if ((insn & 0xf0) == 0x80)
	{
	  int mask = ((insn & 0xf) << 8) | *entry++;
	  int i;

	  /* The special case of an all-zero mask identifies
	     "Refuse to unwind".  We return NULL to fall back
	     to the prologue analyzer.  */
	  if (mask == 0)
	    return NULL;

	  /* Pop registers r4..r15 under mask.  */
	  for (i = 0; i < 12; i++)
	    if (mask & (1 << i))
	      {
	        cache->saved_regs[4 + i].addr = vsp;
		vsp += 4;
	      }

	  /* Special-case popping SP -- we need to reload vsp.  */
	  if (mask & (1 << (ARM_SP_REGNUM - 4)))
	    vsp_valid = 0;
	}
      else if ((insn & 0xf0) == 0x90)
	{
	  int reg = insn & 0xf;

	  /* Reserved cases.  */
	  if (reg == ARM_SP_REGNUM || reg == ARM_PC_REGNUM)
	    return NULL;

	  /* Set SP from another register and mark VSP for reload.  */
	  cache->saved_regs[ARM_SP_REGNUM] = cache->saved_regs[reg];
	  vsp_valid = 0;
	}
      else if ((insn & 0xf0) == 0xa0)
	{
	  int count = insn & 0x7;
	  int pop_lr = (insn & 0x8) != 0;
	  int i;

	  /* Pop r4..r[4+count].  */
	  for (i = 0; i <= count; i++)
	    {
	      cache->saved_regs[4 + i].addr = vsp;
	      vsp += 4;
	    }

	  /* If indicated by flag, pop LR as well.  */
	  if (pop_lr)
	    {
	      cache->saved_regs[ARM_LR_REGNUM].addr = vsp;
	      vsp += 4;
	    }
	}
      else if (insn == 0xb0)
	{
	  /* We could only have updated PC by popping into it; if so, it
	     will show up as address.  Otherwise, copy LR into PC.  */
	  if (!trad_frame_addr_p (cache->saved_regs, ARM_PC_REGNUM))
	    cache->saved_regs[ARM_PC_REGNUM]
	      = cache->saved_regs[ARM_LR_REGNUM];

	  /* We're done.  */
	  break;
	}
      else if (insn == 0xb1)
	{
	  int mask = *entry++;
	  int i;

	  /* All-zero mask and mask >= 16 is "spare".  */
	  if (mask == 0 || mask >= 16)
	    return NULL;

	  /* Pop r0..r3 under mask.  */
	  for (i = 0; i < 4; i++)
	    if (mask & (1 << i))
	      {
		cache->saved_regs[i].addr = vsp;
		vsp += 4;
	      }
	}
      else if (insn == 0xb2)
	{
	  ULONGEST offset = 0;
	  unsigned shift = 0;

	  do
	    {
	      offset |= (*entry & 0x7f) << shift;
	      shift += 7;
	    }
	  while (*entry++ & 0x80);

	  vsp += 0x204 + (offset << 2);
	}
      else if (insn == 0xb3)
	{
	  int start = *entry >> 4;
	  int count = (*entry++) & 0xf;
	  int i;

	  /* Only registers D0..D15 are valid here.  */
	  if (start + count >= 16)
	    return NULL;

	  /* Pop VFP double-precision registers D[start]..D[start+count].  */
	  for (i = 0; i <= count; i++)
	    {
	      cache->saved_regs[ARM_D0_REGNUM + start + i].addr = vsp;
	      vsp += 8;
	    }

	  /* Add an extra 4 bytes for FSTMFDX-style stack.  */
	  vsp += 4;
	}
      else if ((insn & 0xf8) == 0xb8)
	{
	  int count = insn & 0x7;
	  int i;

	  /* Pop VFP double-precision registers D[8]..D[8+count].  */
	  for (i = 0; i <= count; i++)
	    {
	      cache->saved_regs[ARM_D0_REGNUM + 8 + i].addr = vsp;
	      vsp += 8;
	    }

	  /* Add an extra 4 bytes for FSTMFDX-style stack.  */
	  vsp += 4;
	}
      else if (insn == 0xc6)
	{
	  int start = *entry >> 4;
	  int count = (*entry++) & 0xf;
	  int i;

	  /* Only registers WR0..WR15 are valid.  */
	  if (start + count >= 16)
	    return NULL;

	  /* Pop iwmmx registers WR[start]..WR[start+count].  */
	  for (i = 0; i <= count; i++)
	    {
	      cache->saved_regs[ARM_WR0_REGNUM + start + i].addr = vsp;
	      vsp += 8;
	    }
	}
      else if (insn == 0xc7)
	{
	  int mask = *entry++;
	  int i;

	  /* All-zero mask and mask >= 16 is "spare".  */
	  if (mask == 0 || mask >= 16)
	    return NULL;

	  /* Pop iwmmx general-purpose registers WCGR0..WCGR3 under mask.  */
	  for (i = 0; i < 4; i++)
	    if (mask & (1 << i))
	      {
		cache->saved_regs[ARM_WCGR0_REGNUM + i].addr = vsp;
		vsp += 4;
	      }
	}
      else if ((insn & 0xf8) == 0xc0)
	{
	  int count = insn & 0x7;
	  int i;

	  /* Pop iwmmx registers WR[10]..WR[10+count].  */
	  for (i = 0; i <= count; i++)
	    {
	      cache->saved_regs[ARM_WR0_REGNUM + 10 + i].addr = vsp;
	      vsp += 8;
	    }
	}
      else if (insn == 0xc8)
	{
	  int start = *entry >> 4;
	  int count = (*entry++) & 0xf;
	  int i;

	  /* Only registers D0..D31 are valid.  */
	  if (start + count >= 16)
	    return NULL;

	  /* Pop VFP double-precision registers
	     D[16+start]..D[16+start+count].  */
	  for (i = 0; i <= count; i++)
	    {
	      cache->saved_regs[ARM_D0_REGNUM + 16 + start + i].addr = vsp;
	      vsp += 8;
	    }
	}
      else if (insn == 0xc9)
	{
	  int start = *entry >> 4;
	  int count = (*entry++) & 0xf;
	  int i;

	  /* Pop VFP double-precision registers D[start]..D[start+count].  */
	  for (i = 0; i <= count; i++)
	    {
	      cache->saved_regs[ARM_D0_REGNUM + start + i].addr = vsp;
	      vsp += 8;
	    }
	}
      else if ((insn & 0xf8) == 0xd0)
	{
	  int count = insn & 0x7;
	  int i;

	  /* Pop VFP double-precision registers D[8]..D[8+count].  */
	  for (i = 0; i <= count; i++)
	    {
	      cache->saved_regs[ARM_D0_REGNUM + 8 + i].addr = vsp;
	      vsp += 8;
	    }
	}
      else
	{
	  /* Everything else is "spare".  */
	  return NULL;
	}
    }

  /* If we restore SP from a register, assume this was the frame register.
     Otherwise just fall back to SP as frame register.  */
  if (trad_frame_realreg_p (cache->saved_regs, ARM_SP_REGNUM))
    cache->framereg = cache->saved_regs[ARM_SP_REGNUM].realreg;
  else
    cache->framereg = ARM_SP_REGNUM;

  /* Determine offset to previous frame.  */
  cache->framesize
    = vsp - get_frame_register_unsigned (this_frame, cache->framereg);

  /* We already got the previous SP.  */
  cache->prev_sp = vsp;

  return cache;
}

/* Unwinding via ARM exception table entries.  Note that the sniffer
   already computes a filled-in prologue cache, which is then used
   with the same arm_prologue_this_id and arm_prologue_prev_register
   routines also used for prologue-parsing based unwinding.  */

static int
arm_exidx_unwind_sniffer (const struct frame_unwind *self,
			  struct frame_info *this_frame,
			  void **this_prologue_cache)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  enum bfd_endian byte_order_for_code = gdbarch_byte_order_for_code (gdbarch);
  CORE_ADDR addr_in_block, exidx_region, func_start;
  struct arm_prologue_cache *cache;
  gdb_byte *entry;

  /* See if we have an ARM exception table entry covering this address.  */
  addr_in_block = get_frame_address_in_block (this_frame);
  entry = arm_find_exidx_entry (addr_in_block, &exidx_region);
  if (!entry)
    return 0;

  /* The ARM exception table does not describe unwind information
     for arbitrary PC values, but is guaranteed to be correct only
     at call sites.  We have to decide here whether we want to use
     ARM exception table information for this frame, or fall back
     to using prologue parsing.  (Note that if we have DWARF CFI,
     this sniffer isn't even called -- CFI is always preferred.)

     Before we make this decision, however, we check whether we
     actually have *symbol* information for the current frame.
     If not, prologue parsing would not work anyway, so we might
     as well use the exception table and hope for the best.  */
  if (find_pc_partial_function (addr_in_block, NULL, &func_start, NULL))
    {
      int exc_valid = 0;

      /* If the next frame is "normal", we are at a call site in this
	 frame, so exception information is guaranteed to be valid.  */
      if (get_next_frame (this_frame)
	  && get_frame_type (get_next_frame (this_frame)) == NORMAL_FRAME)
	exc_valid = 1;

      /* We also assume exception information is valid if we're currently
	 blocked in a system call.  The system library is supposed to
	 ensure this, so that e.g. pthread cancellation works.  */
      if (arm_frame_is_thumb (this_frame))
	{
	  LONGEST insn;

	  if (safe_read_memory_integer (get_frame_pc (this_frame) - 2, 2,
					byte_order_for_code, &insn)
	      && (insn & 0xff00) == 0xdf00 /* svc */)
	    exc_valid = 1;
	}
      else
	{
	  LONGEST insn;

	  if (safe_read_memory_integer (get_frame_pc (this_frame) - 4, 4,
					byte_order_for_code, &insn)
	      && (insn & 0x0f000000) == 0x0f000000 /* svc */)
	    exc_valid = 1;
	}
	
      /* Bail out if we don't know that exception information is valid.  */
      if (!exc_valid)
	return 0;

     /* The ARM exception index does not mark the *end* of the region
	covered by the entry, and some functions will not have any entry.
	To correctly recognize the end of the covered region, the linker
	should have inserted dummy records with a CANTUNWIND marker.

	Unfortunately, current versions of GNU ld do not reliably do
	this, and thus we may have found an incorrect entry above.
	As a (temporary) sanity check, we only use the entry if it
	lies *within* the bounds of the function.  Note that this check
	might reject perfectly valid entries that just happen to cover
	multiple functions; therefore this check ought to be removed
	once the linker is fixed.  */
      if (func_start > exidx_region)
	return 0;
    }

  /* Decode the list of unwinding instructions into a prologue cache.
     Note that this may fail due to e.g. a "refuse to unwind" code.  */
  cache = arm_exidx_fill_cache (this_frame, entry);
  if (!cache)
    return 0;

  *this_prologue_cache = cache;
  return 1;
}

struct frame_unwind arm_exidx_unwind = {
  NORMAL_FRAME,
  default_frame_unwind_stop_reason,
  arm_prologue_this_id,
  arm_prologue_prev_register,
  NULL,
  arm_exidx_unwind_sniffer
};

static struct arm_prologue_cache *
arm_make_stub_cache (struct frame_info *this_frame)
{
  struct arm_prologue_cache *cache;

  cache = FRAME_OBSTACK_ZALLOC (struct arm_prologue_cache);
  cache->saved_regs = trad_frame_alloc_saved_regs (this_frame);

  cache->prev_sp = get_frame_register_unsigned (this_frame, ARM_SP_REGNUM);

  return cache;
}

/* Our frame ID for a stub frame is the current SP and LR.  */

static void
arm_stub_this_id (struct frame_info *this_frame,
		  void **this_cache,
		  struct frame_id *this_id)
{
  struct arm_prologue_cache *cache;

  if (*this_cache == NULL)
    *this_cache = arm_make_stub_cache (this_frame);
  cache = *this_cache;

  *this_id = frame_id_build (cache->prev_sp, get_frame_pc (this_frame));
}

static int
arm_stub_unwind_sniffer (const struct frame_unwind *self,
			 struct frame_info *this_frame,
			 void **this_prologue_cache)
{
  CORE_ADDR addr_in_block;
  gdb_byte dummy[4];

  addr_in_block = get_frame_address_in_block (this_frame);
  if (in_plt_section (addr_in_block)
      /* We also use the stub winder if the target memory is unreadable
	 to avoid having the prologue unwinder trying to read it.  */
      || target_read_memory (get_frame_pc (this_frame), dummy, 4) != 0)
    return 1;

  return 0;
}

struct frame_unwind arm_stub_unwind = {
  NORMAL_FRAME,
  default_frame_unwind_stop_reason,
  arm_stub_this_id,
  arm_prologue_prev_register,
  NULL,
  arm_stub_unwind_sniffer
};

/* Put here the code to store, into CACHE->saved_regs, the addresses
   of the saved registers of frame described by THIS_FRAME.  CACHE is
   returned.  */

static struct arm_prologue_cache *
arm_m_exception_cache (struct frame_info *this_frame)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  struct arm_prologue_cache *cache;
  CORE_ADDR unwound_sp;
  LONGEST xpsr;

  cache = FRAME_OBSTACK_ZALLOC (struct arm_prologue_cache);
  cache->saved_regs = trad_frame_alloc_saved_regs (this_frame);

  unwound_sp = get_frame_register_unsigned (this_frame,
					    ARM_SP_REGNUM);

  /* The hardware saves eight 32-bit words, comprising xPSR,
     ReturnAddress, LR (R14), R12, R3, R2, R1, R0.  See details in
     "B1.5.6 Exception entry behavior" in
     "ARMv7-M Architecture Reference Manual".  */
  cache->saved_regs[0].addr = unwound_sp;
  cache->saved_regs[1].addr = unwound_sp + 4;
  cache->saved_regs[2].addr = unwound_sp + 8;
  cache->saved_regs[3].addr = unwound_sp + 12;
  cache->saved_regs[12].addr = unwound_sp + 16;
  cache->saved_regs[14].addr = unwound_sp + 20;
  cache->saved_regs[15].addr = unwound_sp + 24;
  cache->saved_regs[ARM_PS_REGNUM].addr = unwound_sp + 28;

  /* If bit 9 of the saved xPSR is set, then there is a four-byte
     aligner between the top of the 32-byte stack frame and the
     previous context's stack pointer.  */
  cache->prev_sp = unwound_sp + 32;
  if (safe_read_memory_integer (unwound_sp + 28, 4, byte_order, &xpsr)
      && (xpsr & (1 << 9)) != 0)
    cache->prev_sp += 4;

  return cache;
}

/* Implementation of function hook 'this_id' in
   'struct frame_uwnind'.  */

static void
arm_m_exception_this_id (struct frame_info *this_frame,
			 void **this_cache,
			 struct frame_id *this_id)
{
  struct arm_prologue_cache *cache;

  if (*this_cache == NULL)
    *this_cache = arm_m_exception_cache (this_frame);
  cache = *this_cache;

  /* Our frame ID for a stub frame is the current SP and LR.  */
  *this_id = frame_id_build (cache->prev_sp,
			     get_frame_pc (this_frame));
}

/* Implementation of function hook 'prev_register' in
   'struct frame_uwnind'.  */

static struct value *
arm_m_exception_prev_register (struct frame_info *this_frame,
			       void **this_cache,
			       int prev_regnum)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  struct arm_prologue_cache *cache;

  if (*this_cache == NULL)
    *this_cache = arm_m_exception_cache (this_frame);
  cache = *this_cache;

  /* The value was already reconstructed into PREV_SP.  */
  if (prev_regnum == ARM_SP_REGNUM)
    return frame_unwind_got_constant (this_frame, prev_regnum,
				      cache->prev_sp);

  return trad_frame_get_prev_register (this_frame, cache->saved_regs,
				       prev_regnum);
}

/* Implementation of function hook 'sniffer' in
   'struct frame_uwnind'.  */

static int
arm_m_exception_unwind_sniffer (const struct frame_unwind *self,
				struct frame_info *this_frame,
				void **this_prologue_cache)
{
  CORE_ADDR this_pc = get_frame_pc (this_frame);

  /* No need to check is_m; this sniffer is only registered for
     M-profile architectures.  */

  /* Exception frames return to one of these magic PCs.  Other values
     are not defined as of v7-M.  See details in "B1.5.8 Exception
     return behavior" in "ARMv7-M Architecture Reference Manual".  */
  if (this_pc == 0xfffffff1 || this_pc == 0xfffffff9
      || this_pc == 0xfffffffd)
    return 1;

  return 0;
}

/* Frame unwinder for M-profile exceptions.  */

struct frame_unwind arm_m_exception_unwind =
{
  SIGTRAMP_FRAME,
  default_frame_unwind_stop_reason,
  arm_m_exception_this_id,
  arm_m_exception_prev_register,
  NULL,
  arm_m_exception_unwind_sniffer
};

static CORE_ADDR
arm_normal_frame_base (struct frame_info *this_frame, void **this_cache)
{
  struct arm_prologue_cache *cache;

  if (*this_cache == NULL)
    *this_cache = arm_make_prologue_cache (this_frame);
  cache = *this_cache;

  return cache->prev_sp - cache->framesize;
}

struct frame_base arm_normal_base = {
  &arm_prologue_unwind,
  arm_normal_frame_base,
  arm_normal_frame_base,
  arm_normal_frame_base
};

/* Assuming THIS_FRAME is a dummy, return the frame ID of that
   dummy frame.  The frame ID's base needs to match the TOS value
   saved by save_dummy_frame_tos() and returned from
   arm_push_dummy_call, and the PC needs to match the dummy frame's
   breakpoint.  */

static struct frame_id
arm_dummy_id (struct gdbarch *gdbarch, struct frame_info *this_frame)
{
  return frame_id_build (get_frame_register_unsigned (this_frame,
						      ARM_SP_REGNUM),
			 get_frame_pc (this_frame));
}

/* Given THIS_FRAME, find the previous frame's resume PC (which will
   be used to construct the previous frame's ID, after looking up the
   containing function).  */

static CORE_ADDR
arm_unwind_pc (struct gdbarch *gdbarch, struct frame_info *this_frame)
{
  CORE_ADDR pc;
  pc = frame_unwind_register_unsigned (this_frame, ARM_PC_REGNUM);
  return arm_addr_bits_remove (gdbarch, pc);
}

static CORE_ADDR
arm_unwind_sp (struct gdbarch *gdbarch, struct frame_info *this_frame)
{
  return frame_unwind_register_unsigned (this_frame, ARM_SP_REGNUM);
}

static struct value *
arm_dwarf2_prev_register (struct frame_info *this_frame, void **this_cache,
			  int regnum)
{
  struct gdbarch * gdbarch = get_frame_arch (this_frame);
  CORE_ADDR lr, cpsr;
  ULONGEST t_bit = arm_psr_thumb_bit (gdbarch);

  switch (regnum)
    {
    case ARM_PC_REGNUM:
      /* The PC is normally copied from the return column, which
	 describes saves of LR.  However, that version may have an
	 extra bit set to indicate Thumb state.  The bit is not
	 part of the PC.  */
      lr = frame_unwind_register_unsigned (this_frame, ARM_LR_REGNUM);
      return frame_unwind_got_constant (this_frame, regnum,
					arm_addr_bits_remove (gdbarch, lr));

    case ARM_PS_REGNUM:
      /* Reconstruct the T bit; see arm_prologue_prev_register for details.  */
      cpsr = get_frame_register_unsigned (this_frame, regnum);
      lr = frame_unwind_register_unsigned (this_frame, ARM_LR_REGNUM);
      if (IS_THUMB_ADDR (lr))
	cpsr |= t_bit;
      else
	cpsr &= ~t_bit;
      return frame_unwind_got_constant (this_frame, regnum, cpsr);

    default:
      internal_error (__FILE__, __LINE__,
		      _("Unexpected register %d"), regnum);
    }
}

static void
arm_dwarf2_frame_init_reg (struct gdbarch *gdbarch, int regnum,
			   struct dwarf2_frame_state_reg *reg,
			   struct frame_info *this_frame)
{
  switch (regnum)
    {
    case ARM_PC_REGNUM:
    case ARM_PS_REGNUM:
      reg->how = DWARF2_FRAME_REG_FN;
      reg->loc.fn = arm_dwarf2_prev_register;
      break;
    case ARM_SP_REGNUM:
      reg->how = DWARF2_FRAME_REG_CFA;
      break;
    }
}

/* Return true if we are in the function's epilogue, i.e. after the
   instruction that destroyed the function's stack frame.  */

static int
thumb_in_function_epilogue_p (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  enum bfd_endian byte_order_for_code = gdbarch_byte_order_for_code (gdbarch);
  unsigned int insn, insn2;
  int found_return = 0, found_stack_adjust = 0;
  CORE_ADDR func_start, func_end;
  CORE_ADDR scan_pc;
  gdb_byte buf[4];

  if (!find_pc_partial_function (pc, NULL, &func_start, &func_end))
    return 0;

  /* The epilogue is a sequence of instructions along the following lines:

    - add stack frame size to SP or FP
    - [if frame pointer used] restore SP from FP
    - restore registers from SP [may include PC]
    - a return-type instruction [if PC wasn't already restored]

    In a first pass, we scan forward from the current PC and verify the
    instructions we find as compatible with this sequence, ending in a
    return instruction.

    However, this is not sufficient to distinguish indirect function calls
    within a function from indirect tail calls in the epilogue in some cases.
    Therefore, if we didn't already find any SP-changing instruction during
    forward scan, we add a backward scanning heuristic to ensure we actually
    are in the epilogue.  */

  scan_pc = pc;
  while (scan_pc < func_end && !found_return)
    {
      if (target_read_memory (scan_pc, buf, 2))
	break;

      scan_pc += 2;
      insn = extract_unsigned_integer (buf, 2, byte_order_for_code);

      if ((insn & 0xff80) == 0x4700)  /* bx <Rm> */
	found_return = 1;
      else if (insn == 0x46f7)  /* mov pc, lr */
	found_return = 1;
      else if (insn == 0x46bd)  /* mov sp, r7 */
	found_stack_adjust = 1;
      else if ((insn & 0xff00) == 0xb000)  /* add sp, imm or sub sp, imm  */
	found_stack_adjust = 1;
      else if ((insn & 0xfe00) == 0xbc00)  /* pop <registers> */
	{
	  found_stack_adjust = 1;
	  if (insn & 0x0100)  /* <registers> include PC.  */
	    found_return = 1;
	}
      else if (thumb_insn_size (insn) == 4)  /* 32-bit Thumb-2 instruction */
	{
	  if (target_read_memory (scan_pc, buf, 2))
	    break;

	  scan_pc += 2;
	  insn2 = extract_unsigned_integer (buf, 2, byte_order_for_code);

	  if (insn == 0xe8bd)  /* ldm.w sp!, <registers> */
	    {
	      found_stack_adjust = 1;
	      if (insn2 & 0x8000)  /* <registers> include PC.  */
		found_return = 1;
	    }
	  else if (insn == 0xf85d  /* ldr.w <Rt>, [sp], #4 */
		   && (insn2 & 0x0fff) == 0x0b04)
	    {
	      found_stack_adjust = 1;
	      if ((insn2 & 0xf000) == 0xf000) /* <Rt> is PC.  */
		found_return = 1;
	    }
	  else if ((insn & 0xffbf) == 0xecbd  /* vldm sp!, <list> */
		   && (insn2 & 0x0e00) == 0x0a00)
	    found_stack_adjust = 1;
	  else
	    break;
	}
      else
	break;
    }

  if (!found_return)
    return 0;

  /* Since any instruction in the epilogue sequence, with the possible
     exception of return itself, updates the stack pointer, we need to
     scan backwards for at most one instruction.  Try either a 16-bit or
     a 32-bit instruction.  This is just a heuristic, so we do not worry
     too much about false positives.  */

  if (!found_stack_adjust)
    {
      if (pc - 4 < func_start)
	return 0;
      if (target_read_memory (pc - 4, buf, 4))
	return 0;

      insn = extract_unsigned_integer (buf, 2, byte_order_for_code);
      insn2 = extract_unsigned_integer (buf + 2, 2, byte_order_for_code);

      if (insn2 == 0x46bd)  /* mov sp, r7 */
	found_stack_adjust = 1;
      else if ((insn2 & 0xff00) == 0xb000)  /* add sp, imm or sub sp, imm  */
	found_stack_adjust = 1;
      else if ((insn2 & 0xff00) == 0xbc00)  /* pop <registers> without PC */
	found_stack_adjust = 1;
      else if (insn == 0xe8bd)  /* ldm.w sp!, <registers> */
	found_stack_adjust = 1;
      else if (insn == 0xf85d  /* ldr.w <Rt>, [sp], #4 */
	       && (insn2 & 0x0fff) == 0x0b04)
	found_stack_adjust = 1;
      else if ((insn & 0xffbf) == 0xecbd  /* vldm sp!, <list> */
	       && (insn2 & 0x0e00) == 0x0a00)
	found_stack_adjust = 1;
    }

  return found_stack_adjust;
}

/* Return true if we are in the function's epilogue, i.e. after the
   instruction that destroyed the function's stack frame.  */

static int
arm_in_function_epilogue_p (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  enum bfd_endian byte_order_for_code = gdbarch_byte_order_for_code (gdbarch);
  unsigned int insn;
  int found_return, found_stack_adjust;
  CORE_ADDR func_start, func_end;

  if (arm_pc_is_thumb (gdbarch, pc))
    return thumb_in_function_epilogue_p (gdbarch, pc);

  if (!find_pc_partial_function (pc, NULL, &func_start, &func_end))
    return 0;

  /* We are in the epilogue if the previous instruction was a stack
     adjustment and the next instruction is a possible return (bx, mov
     pc, or pop).  We could have to scan backwards to find the stack
     adjustment, or forwards to find the return, but this is a decent
     approximation.  First scan forwards.  */

  found_return = 0;
  insn = read_memory_unsigned_integer (pc, 4, byte_order_for_code);
  if (bits (insn, 28, 31) != INST_NV)
    {
      if ((insn & 0x0ffffff0) == 0x012fff10)
	/* BX.  */
	found_return = 1;
      else if ((insn & 0x0ffffff0) == 0x01a0f000)
	/* MOV PC.  */
	found_return = 1;
      else if ((insn & 0x0fff0000) == 0x08bd0000
	  && (insn & 0x0000c000) != 0)
	/* POP (LDMIA), including PC or LR.  */
	found_return = 1;
    }

  if (!found_return)
    return 0;

  /* Scan backwards.  This is just a heuristic, so do not worry about
     false positives from mode changes.  */

  if (pc < func_start + 4)
    return 0;

  found_stack_adjust = 0;
  insn = read_memory_unsigned_integer (pc - 4, 4, byte_order_for_code);
  if (bits (insn, 28, 31) != INST_NV)
    {
      if ((insn & 0x0df0f000) == 0x0080d000)
	/* ADD SP (register or immediate).  */
	found_stack_adjust = 1;
      else if ((insn & 0x0df0f000) == 0x0040d000)
	/* SUB SP (register or immediate).  */
	found_stack_adjust = 1;
      else if ((insn & 0x0ffffff0) == 0x01a0d000)
	/* MOV SP.  */
	found_stack_adjust = 1;
      else if ((insn & 0x0fff0000) == 0x08bd0000)
	/* POP (LDMIA).  */
	found_stack_adjust = 1;
      else if ((insn & 0x0fff0000) == 0x049d0000)
	/* POP of a single register.  */
	found_stack_adjust = 1;
    }

  if (found_stack_adjust)
    return 1;

  return 0;
}


/* When arguments must be pushed onto the stack, they go on in reverse
   order.  The code below implements a FILO (stack) to do this.  */

struct stack_item
{
  int len;
  struct stack_item *prev;
  void *data;
};

static struct stack_item *
push_stack_item (struct stack_item *prev, const void *contents, int len)
{
  struct stack_item *si;
  si = xmalloc (sizeof (struct stack_item));
  si->data = xmalloc (len);
  si->len = len;
  si->prev = prev;
  memcpy (si->data, contents, len);
  return si;
}

static struct stack_item *
pop_stack_item (struct stack_item *si)
{
  struct stack_item *dead = si;
  si = si->prev;
  xfree (dead->data);
  xfree (dead);
  return si;
}


/* Return the alignment (in bytes) of the given type.  */

static int
arm_type_align (struct type *t)
{
  int n;
  int align;
  int falign;

  t = check_typedef (t);
  switch (TYPE_CODE (t))
    {
    default:
      /* Should never happen.  */
      internal_error (__FILE__, __LINE__, _("unknown type alignment"));
      return 4;

    case TYPE_CODE_PTR:
    case TYPE_CODE_ENUM:
    case TYPE_CODE_INT:
    case TYPE_CODE_FLT:
    case TYPE_CODE_SET:
    case TYPE_CODE_RANGE:
    case TYPE_CODE_REF:
    case TYPE_CODE_CHAR:
    case TYPE_CODE_BOOL:
      return TYPE_LENGTH (t);

    case TYPE_CODE_ARRAY:
    case TYPE_CODE_COMPLEX:
      /* TODO: What about vector types?  */
      return arm_type_align (TYPE_TARGET_TYPE (t));

    case TYPE_CODE_STRUCT:
    case TYPE_CODE_UNION:
      align = 1;
      for (n = 0; n < TYPE_NFIELDS (t); n++)
	{
	  falign = arm_type_align (TYPE_FIELD_TYPE (t, n));
	  if (falign > align)
	    align = falign;
	}
      return align;
    }
}

/* Possible base types for a candidate for passing and returning in
   VFP registers.  */

enum arm_vfp_cprc_base_type
{
  VFP_CPRC_UNKNOWN,
  VFP_CPRC_SINGLE,
  VFP_CPRC_DOUBLE,
  VFP_CPRC_VEC64,
  VFP_CPRC_VEC128
};

/* The length of one element of base type B.  */

static unsigned
arm_vfp_cprc_unit_length (enum arm_vfp_cprc_base_type b)
{
  switch (b)
    {
    case VFP_CPRC_SINGLE:
      return 4;
    case VFP_CPRC_DOUBLE:
      return 8;
    case VFP_CPRC_VEC64:
      return 8;
    case VFP_CPRC_VEC128:
      return 16;
    default:
      internal_error (__FILE__, __LINE__, _("Invalid VFP CPRC type: %d."),
		      (int) b);
    }
}

/* The character ('s', 'd' or 'q') for the type of VFP register used
   for passing base type B.  */

static int
arm_vfp_cprc_reg_char (enum arm_vfp_cprc_base_type b)
{
  switch (b)
    {
    case VFP_CPRC_SINGLE:
      return 's';
    case VFP_CPRC_DOUBLE:
      return 'd';
    case VFP_CPRC_VEC64:
      return 'd';
    case VFP_CPRC_VEC128:
      return 'q';
    default:
      internal_error (__FILE__, __LINE__, _("Invalid VFP CPRC type: %d."),
		      (int) b);
    }
}

/* Determine whether T may be part of a candidate for passing and
   returning in VFP registers, ignoring the limit on the total number
   of components.  If *BASE_TYPE is VFP_CPRC_UNKNOWN, set it to the
   classification of the first valid component found; if it is not
   VFP_CPRC_UNKNOWN, all components must have the same classification
   as *BASE_TYPE.  If it is found that T contains a type not permitted
   for passing and returning in VFP registers, a type differently
   classified from *BASE_TYPE, or two types differently classified
   from each other, return -1, otherwise return the total number of
   base-type elements found (possibly 0 in an empty structure or
   array).  Vectors and complex types are not currently supported,
   matching the generic AAPCS support.  */

static int
arm_vfp_cprc_sub_candidate (struct type *t,
			    enum arm_vfp_cprc_base_type *base_type)
{
  t = check_typedef (t);
  switch (TYPE_CODE (t))
    {
    case TYPE_CODE_FLT:
      switch (TYPE_LENGTH (t))
	{
	case 4:
	  if (*base_type == VFP_CPRC_UNKNOWN)
	    *base_type = VFP_CPRC_SINGLE;
	  else if (*base_type != VFP_CPRC_SINGLE)
	    return -1;
	  return 1;

	case 8:
	  if (*base_type == VFP_CPRC_UNKNOWN)
	    *base_type = VFP_CPRC_DOUBLE;
	  else if (*base_type != VFP_CPRC_DOUBLE)
	    return -1;
	  return 1;

	default:
	  return -1;
	}
      break;

    case TYPE_CODE_ARRAY:
      {
	int count;
	unsigned unitlen;
	count = arm_vfp_cprc_sub_candidate (TYPE_TARGET_TYPE (t), base_type);
	if (count == -1)
	  return -1;
	if (TYPE_LENGTH (t) == 0)
	  {
	    gdb_assert (count == 0);
	    return 0;
	  }
	else if (count == 0)
	  return -1;
	unitlen = arm_vfp_cprc_unit_length (*base_type);
	gdb_assert ((TYPE_LENGTH (t) % unitlen) == 0);
	return TYPE_LENGTH (t) / unitlen;
      }
      break;

    case TYPE_CODE_STRUCT:
      {
	int count = 0;
	unsigned unitlen;
	int i;
	for (i = 0; i < TYPE_NFIELDS (t); i++)
	  {
	    int sub_count = arm_vfp_cprc_sub_candidate (TYPE_FIELD_TYPE (t, i),
							base_type);
	    if (sub_count == -1)
	      return -1;
	    count += sub_count;
	  }
	if (TYPE_LENGTH (t) == 0)
	  {
	    gdb_assert (count == 0);
	    return 0;
	  }
	else if (count == 0)
	  return -1;
	unitlen = arm_vfp_cprc_unit_length (*base_type);
	if (TYPE_LENGTH (t) != unitlen * count)
	  return -1;
	return count;
      }

    case TYPE_CODE_UNION:
      {
	int count = 0;
	unsigned unitlen;
	int i;
	for (i = 0; i < TYPE_NFIELDS (t); i++)
	  {
	    int sub_count = arm_vfp_cprc_sub_candidate (TYPE_FIELD_TYPE (t, i),
							base_type);
	    if (sub_count == -1)
	      return -1;
	    count = (count > sub_count ? count : sub_count);
	  }
	if (TYPE_LENGTH (t) == 0)
	  {
	    gdb_assert (count == 0);
	    return 0;
	  }
	else if (count == 0)
	  return -1;
	unitlen = arm_vfp_cprc_unit_length (*base_type);
	if (TYPE_LENGTH (t) != unitlen * count)
	  return -1;
	return count;
      }

    default:
      break;
    }

  return -1;
}

/* Determine whether T is a VFP co-processor register candidate (CPRC)
   if passed to or returned from a non-variadic function with the VFP
   ABI in effect.  Return 1 if it is, 0 otherwise.  If it is, set
   *BASE_TYPE to the base type for T and *COUNT to the number of
   elements of that base type before returning.  */

static int
arm_vfp_call_candidate (struct type *t, enum arm_vfp_cprc_base_type *base_type,
			int *count)
{
  enum arm_vfp_cprc_base_type b = VFP_CPRC_UNKNOWN;
  int c = arm_vfp_cprc_sub_candidate (t, &b);
  if (c <= 0 || c > 4)
    return 0;
  *base_type = b;
  *count = c;
  return 1;
}

/* Return 1 if the VFP ABI should be used for passing arguments to and
   returning values from a function of type FUNC_TYPE, 0
   otherwise.  */

static int
arm_vfp_abi_for_function (struct gdbarch *gdbarch, struct type *func_type)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  /* Variadic functions always use the base ABI.  Assume that functions
     without debug info are not variadic.  */
  if (func_type && TYPE_VARARGS (check_typedef (func_type)))
    return 0;
  /* The VFP ABI is only supported as a variant of AAPCS.  */
  if (tdep->arm_abi != ARM_ABI_AAPCS)
    return 0;
  return gdbarch_tdep (gdbarch)->fp_model == ARM_FLOAT_VFP;
}

/* We currently only support passing parameters in integer registers, which
   conforms with GCC's default model, and VFP argument passing following
   the VFP variant of AAPCS.  Several other variants exist and
   we should probably support some of them based on the selected ABI.  */

static CORE_ADDR
arm_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
		     struct regcache *regcache, CORE_ADDR bp_addr, int nargs,
		     struct value **args, CORE_ADDR sp, int struct_return,
		     CORE_ADDR struct_addr)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  int argnum;
  int argreg;
  int nstack;
  struct stack_item *si = NULL;
  int use_vfp_abi;
  struct type *ftype;
  unsigned vfp_regs_free = (1 << 16) - 1;

  /* Determine the type of this function and whether the VFP ABI
     applies.  */
  ftype = check_typedef (value_type (function));
  if (TYPE_CODE (ftype) == TYPE_CODE_PTR)
    ftype = check_typedef (TYPE_TARGET_TYPE (ftype));
  use_vfp_abi = arm_vfp_abi_for_function (gdbarch, ftype);

  /* Set the return address.  For the ARM, the return breakpoint is
     always at BP_ADDR.  */
  if (arm_pc_is_thumb (gdbarch, bp_addr))
    bp_addr |= 1;
  regcache_cooked_write_unsigned (regcache, ARM_LR_REGNUM, bp_addr);

  /* Walk through the list of args and determine how large a temporary
     stack is required.  Need to take care here as structs may be
     passed on the stack, and we have to push them.  */
  nstack = 0;

  argreg = ARM_A1_REGNUM;
  nstack = 0;

  /* The struct_return pointer occupies the first parameter
     passing register.  */
  if (struct_return)
    {
      if (arm_debug)
	fprintf_unfiltered (gdb_stdlog, "struct return in %s = %s\n",
			    gdbarch_register_name (gdbarch, argreg),
			    paddress (gdbarch, struct_addr));
      regcache_cooked_write_unsigned (regcache, argreg, struct_addr);
      argreg++;
    }

  for (argnum = 0; argnum < nargs; argnum++)
    {
      int len;
      struct type *arg_type;
      struct type *target_type;
      enum type_code typecode;
      const bfd_byte *val;
      int align;
      enum arm_vfp_cprc_base_type vfp_base_type;
      int vfp_base_count;
      int may_use_core_reg = 1;

      arg_type = check_typedef (value_type (args[argnum]));
      len = TYPE_LENGTH (arg_type);
      target_type = TYPE_TARGET_TYPE (arg_type);
      typecode = TYPE_CODE (arg_type);
      val = value_contents (args[argnum]);

      align = arm_type_align (arg_type);
      /* Round alignment up to a whole number of words.  */
      align = (align + INT_REGISTER_SIZE - 1) & ~(INT_REGISTER_SIZE - 1);
      /* Different ABIs have different maximum alignments.  */
      if (gdbarch_tdep (gdbarch)->arm_abi == ARM_ABI_APCS)
	{
	  /* The APCS ABI only requires word alignment.  */
	  align = INT_REGISTER_SIZE;
	}
      else
	{
	  /* The AAPCS requires at most doubleword alignment.  */
	  if (align > INT_REGISTER_SIZE * 2)
	    align = INT_REGISTER_SIZE * 2;
	}

      if (use_vfp_abi
	  && arm_vfp_call_candidate (arg_type, &vfp_base_type,
				     &vfp_base_count))
	{
	  int regno;
	  int unit_length;
	  int shift;
	  unsigned mask;

	  /* Because this is a CPRC it cannot go in a core register or
	     cause a core register to be skipped for alignment.
	     Either it goes in VFP registers and the rest of this loop
	     iteration is skipped for this argument, or it goes on the
	     stack (and the stack alignment code is correct for this
	     case).  */
	  may_use_core_reg = 0;

	  unit_length = arm_vfp_cprc_unit_length (vfp_base_type);
	  shift = unit_length / 4;
	  mask = (1 << (shift * vfp_base_count)) - 1;
	  for (regno = 0; regno < 16; regno += shift)
	    if (((vfp_regs_free >> regno) & mask) == mask)
	      break;

	  if (regno < 16)
	    {
	      int reg_char;
	      int reg_scaled;
	      int i;

	      vfp_regs_free &= ~(mask << regno);
	      reg_scaled = regno / shift;
	      reg_char = arm_vfp_cprc_reg_char (vfp_base_type);
	      for (i = 0; i < vfp_base_count; i++)
		{
		  char name_buf[4];
		  int regnum;
		  if (reg_char == 'q')
		    arm_neon_quad_write (gdbarch, regcache, reg_scaled + i,
					 val + i * unit_length);
		  else
		    {
		      xsnprintf (name_buf, sizeof (name_buf), "%c%d",
				 reg_char, reg_scaled + i);
		      regnum = user_reg_map_name_to_regnum (gdbarch, name_buf,
							    strlen (name_buf));
		      regcache_cooked_write (regcache, regnum,
					     val + i * unit_length);
		    }
		}
	      continue;
	    }
	  else
	    {
	      /* This CPRC could not go in VFP registers, so all VFP
		 registers are now marked as used.  */
	      vfp_regs_free = 0;
	    }
	}

      /* Push stack padding for dowubleword alignment.  */
      if (nstack & (align - 1))
	{
	  si = push_stack_item (si, val, INT_REGISTER_SIZE);
	  nstack += INT_REGISTER_SIZE;
	}
      
      /* Doubleword aligned quantities must go in even register pairs.  */
      if (may_use_core_reg
	  && argreg <= ARM_LAST_ARG_REGNUM
	  && align > INT_REGISTER_SIZE
	  && argreg & 1)
	argreg++;

      /* If the argument is a pointer to a function, and it is a
	 Thumb function, create a LOCAL copy of the value and set
	 the THUMB bit in it.  */
      if (TYPE_CODE_PTR == typecode
	  && target_type != NULL
	  && TYPE_CODE_FUNC == TYPE_CODE (check_typedef (target_type)))
	{
	  CORE_ADDR regval = extract_unsigned_integer (val, len, byte_order);
	  if (arm_pc_is_thumb (gdbarch, regval))
	    {
	      bfd_byte *copy = alloca (len);
	      store_unsigned_integer (copy, len, byte_order,
				      MAKE_THUMB_ADDR (regval));
	      val = copy;
	    }
	}

      /* Copy the argument to general registers or the stack in
	 register-sized pieces.  Large arguments are split between
	 registers and stack.  */
      while (len > 0)
	{
	  int partial_len = len < INT_REGISTER_SIZE ? len : INT_REGISTER_SIZE;

	  if (may_use_core_reg && argreg <= ARM_LAST_ARG_REGNUM)
	    {
	      /* The argument is being passed in a general purpose
		 register.  */
	      CORE_ADDR regval
		= extract_unsigned_integer (val, partial_len, byte_order);
	      if (byte_order == BFD_ENDIAN_BIG)
		regval <<= (INT_REGISTER_SIZE - partial_len) * 8;
	      if (arm_debug)
		fprintf_unfiltered (gdb_stdlog, "arg %d in %s = 0x%s\n",
				    argnum,
				    gdbarch_register_name
				      (gdbarch, argreg),
				    phex (regval, INT_REGISTER_SIZE));
	      regcache_cooked_write_unsigned (regcache, argreg, regval);
	      argreg++;
	    }
	  else
	    {
	      /* Push the arguments onto the stack.  */
	      if (arm_debug)
		fprintf_unfiltered (gdb_stdlog, "arg %d @@ sp + %d\n",
				    argnum, nstack);
	      si = push_stack_item (si, val, INT_REGISTER_SIZE);
	      nstack += INT_REGISTER_SIZE;
	    }
	      
	  len -= partial_len;
	  val += partial_len;
	}
    }
  /* If we have an odd number of words to push, then decrement the stack
     by one word now, so first stack argument will be dword aligned.  */
  if (nstack & 4)
    sp -= 4;

  while (si)
    {
      sp -= si->len;
      write_memory (sp, si->data, si->len);
      si = pop_stack_item (si);
    }

  /* Finally, update teh SP register.  */
  regcache_cooked_write_unsigned (regcache, ARM_SP_REGNUM, sp);

  return sp;
}


/* Always align the frame to an 8-byte boundary.  This is required on
   some platforms and harmless on the rest.  */

static CORE_ADDR
arm_frame_align (struct gdbarch *gdbarch, CORE_ADDR sp)
{
  /* Align the stack to eight bytes.  */
  return sp & ~ (CORE_ADDR) 7;
}

static void
print_fpu_flags (int flags)
{
  if (flags & (1 << 0))
    fputs ("IVO ", stdout);
  if (flags & (1 << 1))
    fputs ("DVZ ", stdout);
  if (flags & (1 << 2))
    fputs ("OFL ", stdout);
  if (flags & (1 << 3))
    fputs ("UFL ", stdout);
  if (flags & (1 << 4))
    fputs ("INX ", stdout);
  putchar ('\n');
}

/* Print interesting information about the floating point processor
   (if present) or emulator.  */
static void
arm_print_float_info (struct gdbarch *gdbarch, struct ui_file *file,
		      struct frame_info *frame, const char *args)
{
  unsigned long status = get_frame_register_unsigned (frame, ARM_FPS_REGNUM);
  int type;

  type = (status >> 24) & 127;
  if (status & (1 << 31))
    printf (_("Hardware FPU type %d\n"), type);
  else
    printf (_("Software FPU type %d\n"), type);
  /* i18n: [floating point unit] mask */
  fputs (_("mask: "), stdout);
  print_fpu_flags (status >> 16);
  /* i18n: [floating point unit] flags */
  fputs (_("flags: "), stdout);
  print_fpu_flags (status);
}

/* Construct the ARM extended floating point type.  */
static struct type *
arm_ext_type (struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (!tdep->arm_ext_type)
    tdep->arm_ext_type
      = arch_float_type (gdbarch, -1, "builtin_type_arm_ext",
			 floatformats_arm_ext);

  return tdep->arm_ext_type;
}

static struct type *
arm_neon_double_type (struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (tdep->neon_double_type == NULL)
    {
      struct type *t, *elem;

      t = arch_composite_type (gdbarch, "__gdb_builtin_type_neon_d",
			       TYPE_CODE_UNION);
      elem = builtin_type (gdbarch)->builtin_uint8;
      append_composite_type_field (t, "u8", init_vector_type (elem, 8));
      elem = builtin_type (gdbarch)->builtin_uint16;
      append_composite_type_field (t, "u16", init_vector_type (elem, 4));
      elem = builtin_type (gdbarch)->builtin_uint32;
      append_composite_type_field (t, "u32", init_vector_type (elem, 2));
      elem = builtin_type (gdbarch)->builtin_uint64;
      append_composite_type_field (t, "u64", elem);
      elem = builtin_type (gdbarch)->builtin_float;
      append_composite_type_field (t, "f32", init_vector_type (elem, 2));
      elem = builtin_type (gdbarch)->builtin_double;
      append_composite_type_field (t, "f64", elem);

      TYPE_VECTOR (t) = 1;
      TYPE_NAME (t) = "neon_d";
      tdep->neon_double_type = t;
    }

  return tdep->neon_double_type;
}

/* FIXME: The vector types are not correctly ordered on big-endian
   targets.  Just as s0 is the low bits of d0, d0[0] is also the low
   bits of d0 - regardless of what unit size is being held in d0.  So
   the offset of the first uint8 in d0 is 7, but the offset of the
   first float is 4.  This code works as-is for little-endian
   targets.  */

static struct type *
arm_neon_quad_type (struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (tdep->neon_quad_type == NULL)
    {
      struct type *t, *elem;

      t = arch_composite_type (gdbarch, "__gdb_builtin_type_neon_q",
			       TYPE_CODE_UNION);
      elem = builtin_type (gdbarch)->builtin_uint8;
      append_composite_type_field (t, "u8", init_vector_type (elem, 16));
      elem = builtin_type (gdbarch)->builtin_uint16;
      append_composite_type_field (t, "u16", init_vector_type (elem, 8));
      elem = builtin_type (gdbarch)->builtin_uint32;
      append_composite_type_field (t, "u32", init_vector_type (elem, 4));
      elem = builtin_type (gdbarch)->builtin_uint64;
      append_composite_type_field (t, "u64", init_vector_type (elem, 2));
      elem = builtin_type (gdbarch)->builtin_float;
      append_composite_type_field (t, "f32", init_vector_type (elem, 4));
      elem = builtin_type (gdbarch)->builtin_double;
      append_composite_type_field (t, "f64", init_vector_type (elem, 2));

      TYPE_VECTOR (t) = 1;
      TYPE_NAME (t) = "neon_q";
      tdep->neon_quad_type = t;
    }

  return tdep->neon_quad_type;
}

/* Return the GDB type object for the "standard" data type of data in
   register N.  */

static struct type *
arm_register_type (struct gdbarch *gdbarch, int regnum)
{
  int num_regs = gdbarch_num_regs (gdbarch);

  if (gdbarch_tdep (gdbarch)->have_vfp_pseudos
      && regnum >= num_regs && regnum < num_regs + 32)
    return builtin_type (gdbarch)->builtin_float;

  if (gdbarch_tdep (gdbarch)->have_neon_pseudos
      && regnum >= num_regs + 32 && regnum < num_regs + 32 + 16)
    return arm_neon_quad_type (gdbarch);

  /* If the target description has register information, we are only
     in this function so that we can override the types of
     double-precision registers for NEON.  */
  if (tdesc_has_registers (gdbarch_target_desc (gdbarch)))
    {
      struct type *t = tdesc_register_type (gdbarch, regnum);

      if (regnum >= ARM_D0_REGNUM && regnum < ARM_D0_REGNUM + 32
	  && TYPE_CODE (t) == TYPE_CODE_FLT
	  && gdbarch_tdep (gdbarch)->have_neon)
	return arm_neon_double_type (gdbarch);
      else
	return t;
    }

  if (regnum >= ARM_F0_REGNUM && regnum < ARM_F0_REGNUM + NUM_FREGS)
    {
      if (!gdbarch_tdep (gdbarch)->have_fpa_registers)
	return builtin_type (gdbarch)->builtin_void;

      return arm_ext_type (gdbarch);
    }
  else if (regnum == ARM_SP_REGNUM)
    return builtin_type (gdbarch)->builtin_data_ptr;
  else if (regnum == ARM_PC_REGNUM)
    return builtin_type (gdbarch)->builtin_func_ptr;
  else if (regnum >= ARRAY_SIZE (arm_register_names))
    /* These registers are only supported on targets which supply
       an XML description.  */
    return builtin_type (gdbarch)->builtin_int0;
  else
    return builtin_type (gdbarch)->builtin_uint32;
}

/* Map a DWARF register REGNUM onto the appropriate GDB register
   number.  */

static int
arm_dwarf_reg_to_regnum (struct gdbarch *gdbarch, int reg)
{
  /* Core integer regs.  */
  if (reg >= 0 && reg <= 15)
    return reg;

  /* Legacy FPA encoding.  These were once used in a way which
     overlapped with VFP register numbering, so their use is
     discouraged, but GDB doesn't support the ARM toolchain
     which used them for VFP.  */
  if (reg >= 16 && reg <= 23)
    return ARM_F0_REGNUM + reg - 16;

  /* New assignments for the FPA registers.  */
  if (reg >= 96 && reg <= 103)
    return ARM_F0_REGNUM + reg - 96;

  /* WMMX register assignments.  */
  if (reg >= 104 && reg <= 111)
    return ARM_WCGR0_REGNUM + reg - 104;

  if (reg >= 112 && reg <= 127)
    return ARM_WR0_REGNUM + reg - 112;

  if (reg >= 192 && reg <= 199)
    return ARM_WC0_REGNUM + reg - 192;

  /* VFP v2 registers.  A double precision value is actually
     in d1 rather than s2, but the ABI only defines numbering
     for the single precision registers.  This will "just work"
     in GDB for little endian targets (we'll read eight bytes,
     starting in s0 and then progressing to s1), but will be
     reversed on big endian targets with VFP.  This won't
     be a problem for the new Neon quad registers; you're supposed
     to use DW_OP_piece for those.  */
  if (reg >= 64 && reg <= 95)
    {
      char name_buf[4];

      xsnprintf (name_buf, sizeof (name_buf), "s%d", reg - 64);
      return user_reg_map_name_to_regnum (gdbarch, name_buf,
					  strlen (name_buf));
    }

  /* VFP v3 / Neon registers.  This range is also used for VFP v2
     registers, except that it now describes d0 instead of s0.  */
  if (reg >= 256 && reg <= 287)
    {
      char name_buf[4];

      xsnprintf (name_buf, sizeof (name_buf), "d%d", reg - 256);
      return user_reg_map_name_to_regnum (gdbarch, name_buf,
					  strlen (name_buf));
    }

  return -1;
}

/* Map GDB internal REGNUM onto the Arm simulator register numbers.  */
static int
arm_register_sim_regno (struct gdbarch *gdbarch, int regnum)
{
  int reg = regnum;
  gdb_assert (reg >= 0 && reg < gdbarch_num_regs (gdbarch));

  if (regnum >= ARM_WR0_REGNUM && regnum <= ARM_WR15_REGNUM)
    return regnum - ARM_WR0_REGNUM + SIM_ARM_IWMMXT_COP0R0_REGNUM;

  if (regnum >= ARM_WC0_REGNUM && regnum <= ARM_WC7_REGNUM)
    return regnum - ARM_WC0_REGNUM + SIM_ARM_IWMMXT_COP1R0_REGNUM;

  if (regnum >= ARM_WCGR0_REGNUM && regnum <= ARM_WCGR7_REGNUM)
    return regnum - ARM_WCGR0_REGNUM + SIM_ARM_IWMMXT_COP1R8_REGNUM;

  if (reg < NUM_GREGS)
    return SIM_ARM_R0_REGNUM + reg;
  reg -= NUM_GREGS;

  if (reg < NUM_FREGS)
    return SIM_ARM_FP0_REGNUM + reg;
  reg -= NUM_FREGS;

  if (reg < NUM_SREGS)
    return SIM_ARM_FPS_REGNUM + reg;
  reg -= NUM_SREGS;

  internal_error (__FILE__, __LINE__, _("Bad REGNUM %d"), regnum);
}

/* NOTE: cagney/2001-08-20: Both convert_from_extended() and
   convert_to_extended() use floatformat_arm_ext_littlebyte_bigword.
   It is thought that this is is the floating-point register format on
   little-endian systems.  */

static void
convert_from_extended (const struct floatformat *fmt, const void *ptr,
		       void *dbl, int endianess)
{
  DOUBLEST d;

  if (endianess == BFD_ENDIAN_BIG)
    floatformat_to_doublest (&floatformat_arm_ext_big, ptr, &d);
  else
    floatformat_to_doublest (&floatformat_arm_ext_littlebyte_bigword,
			     ptr, &d);
  floatformat_from_doublest (fmt, &d, dbl);
}

static void
convert_to_extended (const struct floatformat *fmt, void *dbl, const void *ptr,
		     int endianess)
{
  DOUBLEST d;

  floatformat_to_doublest (fmt, ptr, &d);
  if (endianess == BFD_ENDIAN_BIG)
    floatformat_from_doublest (&floatformat_arm_ext_big, &d, dbl);
  else
    floatformat_from_doublest (&floatformat_arm_ext_littlebyte_bigword,
			       &d, dbl);
}

static int
condition_true (unsigned long cond, unsigned long status_reg)
{
  if (cond == INST_AL || cond == INST_NV)
    return 1;

  switch (cond)
    {
    case INST_EQ:
      return ((status_reg & FLAG_Z) != 0);
    case INST_NE:
      return ((status_reg & FLAG_Z) == 0);
    case INST_CS:
      return ((status_reg & FLAG_C) != 0);
    case INST_CC:
      return ((status_reg & FLAG_C) == 0);
    case INST_MI:
      return ((status_reg & FLAG_N) != 0);
    case INST_PL:
      return ((status_reg & FLAG_N) == 0);
    case INST_VS:
      return ((status_reg & FLAG_V) != 0);
    case INST_VC:
      return ((status_reg & FLAG_V) == 0);
    case INST_HI:
      return ((status_reg & (FLAG_C | FLAG_Z)) == FLAG_C);
    case INST_LS:
      return ((status_reg & (FLAG_C | FLAG_Z)) != FLAG_C);
    case INST_GE:
      return (((status_reg & FLAG_N) == 0) == ((status_reg & FLAG_V) == 0));
    case INST_LT:
      return (((status_reg & FLAG_N) == 0) != ((status_reg & FLAG_V) == 0));
    case INST_GT:
      return (((status_reg & FLAG_Z) == 0)
	      && (((status_reg & FLAG_N) == 0)
		  == ((status_reg & FLAG_V) == 0)));
    case INST_LE:
      return (((status_reg & FLAG_Z) != 0)
	      || (((status_reg & FLAG_N) == 0)
		  != ((status_reg & FLAG_V) == 0)));
    }
  return 1;
}

static unsigned long
shifted_reg_val (struct frame_info *frame, unsigned long inst, int carry,
		 unsigned long pc_val, unsigned long status_reg)
{
  unsigned long res, shift;
  int rm = bits (inst, 0, 3);
  unsigned long shifttype = bits (inst, 5, 6);

  if (bit (inst, 4))
    {
      int rs = bits (inst, 8, 11);
      shift = (rs == 15 ? pc_val + 8
			: get_frame_register_unsigned (frame, rs)) & 0xFF;
    }
  else
    shift = bits (inst, 7, 11);

  res = (rm == ARM_PC_REGNUM
	 ? (pc_val + (bit (inst, 4) ? 12 : 8))
	 : get_frame_register_unsigned (frame, rm));

  switch (shifttype)
    {
    case 0:			/* LSL */
      res = shift >= 32 ? 0 : res << shift;
      break;

    case 1:			/* LSR */
      res = shift >= 32 ? 0 : res >> shift;
      break;

    case 2:			/* ASR */
      if (shift >= 32)
	shift = 31;
      res = ((res & 0x80000000L)
	     ? ~((~res) >> shift) : res >> shift);
      break;

    case 3:			/* ROR/RRX */
      shift &= 31;
      if (shift == 0)
	res = (res >> 1) | (carry ? 0x80000000L : 0);
      else
	res = (res >> shift) | (res << (32 - shift));
      break;
    }

  return res & 0xffffffff;
}

/* Return number of 1-bits in VAL.  */

static int
bitcount (unsigned long val)
{
  int nbits;
  for (nbits = 0; val != 0; nbits++)
    val &= val - 1;		/* Delete rightmost 1-bit in val.  */
  return nbits;
}

/* Return the size in bytes of the complete Thumb instruction whose
   first halfword is INST1.  */

static int
thumb_insn_size (unsigned short inst1)
{
  if ((inst1 & 0xe000) == 0xe000 && (inst1 & 0x1800) != 0)
    return 4;
  else
    return 2;
}

static int
thumb_advance_itstate (unsigned int itstate)
{
  /* Preserve IT[7:5], the first three bits of the condition.  Shift
     the upcoming condition flags left by one bit.  */
  itstate = (itstate & 0xe0) | ((itstate << 1) & 0x1f);

  /* If we have finished the IT block, clear the state.  */
  if ((itstate & 0x0f) == 0)
    itstate = 0;

  return itstate;
}

/* Find the next PC after the current instruction executes.  In some
   cases we can not statically determine the answer (see the IT state
   handling in this function); in that case, a breakpoint may be
   inserted in addition to the returned PC, which will be used to set
   another breakpoint by our caller.  */

static CORE_ADDR
thumb_get_next_pc_raw (struct frame_info *frame, CORE_ADDR pc)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  struct address_space *aspace = get_frame_address_space (frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  enum bfd_endian byte_order_for_code = gdbarch_byte_order_for_code (gdbarch);
  unsigned long pc_val = ((unsigned long) pc) + 4;	/* PC after prefetch */
  unsigned short inst1;
  CORE_ADDR nextpc = pc + 2;		/* Default is next instruction.  */
  unsigned long offset;
  ULONGEST status, itstate;

  nextpc = MAKE_THUMB_ADDR (nextpc);
  pc_val = MAKE_THUMB_ADDR (pc_val);

  inst1 = read_memory_unsigned_integer (pc, 2, byte_order_for_code);

  /* Thumb-2 conditional execution support.  There are eight bits in
     the CPSR which describe conditional execution state.  Once
     reconstructed (they're in a funny order), the low five bits
     describe the low bit of the condition for each instruction and
     how many instructions remain.  The high three bits describe the
     base condition.  One of the low four bits will be set if an IT
     block is active.  These bits read as zero on earlier
     processors.  */
  status = get_frame_register_unsigned (frame, ARM_PS_REGNUM);
  itstate = ((status >> 8) & 0xfc) | ((status >> 25) & 0x3);

  /* If-Then handling.  On GNU/Linux, where this routine is used, we
     use an undefined instruction as a breakpoint.  Unlike BKPT, IT
     can disable execution of the undefined instruction.  So we might
     miss the breakpoint if we set it on a skipped conditional
     instruction.  Because conditional instructions can change the
     flags, affecting the execution of further instructions, we may
     need to set two breakpoints.  */

  if (gdbarch_tdep (gdbarch)->thumb2_breakpoint != NULL)
    {
      if ((inst1 & 0xff00) == 0xbf00 && (inst1 & 0x000f) != 0)
	{
	  /* An IT instruction.  Because this instruction does not
	     modify the flags, we can accurately predict the next
	     executed instruction.  */
	  itstate = inst1 & 0x00ff;
	  pc += thumb_insn_size (inst1);

	  while (itstate != 0 && ! condition_true (itstate >> 4, status))
	    {
	      inst1 = read_memory_unsigned_integer (pc, 2,
						    byte_order_for_code);
	      pc += thumb_insn_size (inst1);
	      itstate = thumb_advance_itstate (itstate);
	    }

	  return MAKE_THUMB_ADDR (pc);
	}
      else if (itstate != 0)
	{
	  /* We are in a conditional block.  Check the condition.  */
	  if (! condition_true (itstate >> 4, status))
	    {
	      /* Advance to the next executed instruction.  */
	      pc += thumb_insn_size (inst1);
	      itstate = thumb_advance_itstate (itstate);

	      while (itstate != 0 && ! condition_true (itstate >> 4, status))
		{
		  inst1 = read_memory_unsigned_integer (pc, 2, 
							byte_order_for_code);
		  pc += thumb_insn_size (inst1);
		  itstate = thumb_advance_itstate (itstate);
		}

	      return MAKE_THUMB_ADDR (pc);
	    }
	  else if ((itstate & 0x0f) == 0x08)
	    {
	      /* This is the last instruction of the conditional
		 block, and it is executed.  We can handle it normally
		 because the following instruction is not conditional,
		 and we must handle it normally because it is
		 permitted to branch.  Fall through.  */
	    }
	  else
	    {
	      int cond_negated;

	      /* There are conditional instructions after this one.
		 If this instruction modifies the flags, then we can
		 not predict what the next executed instruction will
		 be.  Fortunately, this instruction is architecturally
		 forbidden to branch; we know it will fall through.
		 Start by skipping past it.  */
	      pc += thumb_insn_size (inst1);
	      itstate = thumb_advance_itstate (itstate);

	      /* Set a breakpoint on the following instruction.  */
	      gdb_assert ((itstate & 0x0f) != 0);
	      arm_insert_single_step_breakpoint (gdbarch, aspace,
						 MAKE_THUMB_ADDR (pc));
	      cond_negated = (itstate >> 4) & 1;

	      /* Skip all following instructions with the same
		 condition.  If there is a later instruction in the IT
		 block with the opposite condition, set the other
		 breakpoint there.  If not, then set a breakpoint on
		 the instruction after the IT block.  */
	      do
		{
		  inst1 = read_memory_unsigned_integer (pc, 2,
							byte_order_for_code);
		  pc += thumb_insn_size (inst1);
		  itstate = thumb_advance_itstate (itstate);
		}
	      while (itstate != 0 && ((itstate >> 4) & 1) == cond_negated);

	      return MAKE_THUMB_ADDR (pc);
	    }
	}
    }
  else if (itstate & 0x0f)
    {
      /* We are in a conditional block.  Check the condition.  */
      int cond = itstate >> 4;

      if (! condition_true (cond, status))
	/* Advance to the next instruction.  All the 32-bit
	   instructions share a common prefix.  */
	return MAKE_THUMB_ADDR (pc + thumb_insn_size (inst1));

      /* Otherwise, handle the instruction normally.  */
    }

  if ((inst1 & 0xff00) == 0xbd00)	/* pop {rlist, pc} */
    {
      CORE_ADDR sp;

      /* Fetch the saved PC from the stack.  It's stored above
         all of the other registers.  */
      offset = bitcount (bits (inst1, 0, 7)) * INT_REGISTER_SIZE;
      sp = get_frame_register_unsigned (frame, ARM_SP_REGNUM);
      nextpc = read_memory_unsigned_integer (sp + offset, 4, byte_order);
    }
  else if ((inst1 & 0xf000) == 0xd000)	/* conditional branch */
    {
      unsigned long cond = bits (inst1, 8, 11);
      if (cond == 0x0f)  /* 0x0f = SWI */
	{
	  struct gdbarch_tdep *tdep;
	  tdep = gdbarch_tdep (gdbarch);

	  if (tdep->syscall_next_pc != NULL)
	    nextpc = tdep->syscall_next_pc (frame);

	}
      else if (cond != 0x0f && condition_true (cond, status))
	nextpc = pc_val + (sbits (inst1, 0, 7) << 1);
    }
  else if ((inst1 & 0xf800) == 0xe000)	/* unconditional branch */
    {
      nextpc = pc_val + (sbits (inst1, 0, 10) << 1);
    }
  else if (thumb_insn_size (inst1) == 4) /* 32-bit instruction */
    {
      unsigned short inst2;
      inst2 = read_memory_unsigned_integer (pc + 2, 2, byte_order_for_code);

      /* Default to the next instruction.  */
      nextpc = pc + 4;
      nextpc = MAKE_THUMB_ADDR (nextpc);

      if ((inst1 & 0xf800) == 0xf000 && (inst2 & 0x8000) == 0x8000)
	{
	  /* Branches and miscellaneous control instructions.  */

	  if ((inst2 & 0x1000) != 0 || (inst2 & 0xd001) == 0xc000)
	    {
	      /* B, BL, BLX.  */
	      int j1, j2, imm1, imm2;

	      imm1 = sbits (inst1, 0, 10);
	      imm2 = bits (inst2, 0, 10);
	      j1 = bit (inst2, 13);
	      j2 = bit (inst2, 11);

	      offset = ((imm1 << 12) + (imm2 << 1));
	      offset ^= ((!j2) << 22) | ((!j1) << 23);

	      nextpc = pc_val + offset;
	      /* For BLX make sure to clear the low bits.  */
	      if (bit (inst2, 12) == 0)
		nextpc = nextpc & 0xfffffffc;
	    }
	  else if (inst1 == 0xf3de && (inst2 & 0xff00) == 0x3f00)
	    {
	      /* SUBS PC, LR, #imm8.  */
	      nextpc = get_frame_register_unsigned (frame, ARM_LR_REGNUM);
	      nextpc -= inst2 & 0x00ff;
	    }
	  else if ((inst2 & 0xd000) == 0x8000 && (inst1 & 0x0380) != 0x0380)
	    {
	      /* Conditional branch.  */
	      if (condition_true (bits (inst1, 6, 9), status))
		{
		  int sign, j1, j2, imm1, imm2;

		  sign = sbits (inst1, 10, 10);
		  imm1 = bits (inst1, 0, 5);
		  imm2 = bits (inst2, 0, 10);
		  j1 = bit (inst2, 13);
		  j2 = bit (inst2, 11);

		  offset = (sign << 20) + (j2 << 19) + (j1 << 18);
		  offset += (imm1 << 12) + (imm2 << 1);

		  nextpc = pc_val + offset;
		}
	    }
	}
      else if ((inst1 & 0xfe50) == 0xe810)
	{
	  /* Load multiple or RFE.  */
	  int rn, offset, load_pc = 1;

	  rn = bits (inst1, 0, 3);
	  if (bit (inst1, 7) && !bit (inst1, 8))
	    {
	      /* LDMIA or POP */
	      if (!bit (inst2, 15))
		load_pc = 0;
	      offset = bitcount (inst2) * 4 - 4;
	    }
	  else if (!bit (inst1, 7) && bit (inst1, 8))
	    {
	      /* LDMDB */
	      if (!bit (inst2, 15))
		load_pc = 0;
	      offset = -4;
	    }
	  else if (bit (inst1, 7) && bit (inst1, 8))
	    {
	      /* RFEIA */
	      offset = 0;
	    }
	  else if (!bit (inst1, 7) && !bit (inst1, 8))
	    {
	      /* RFEDB */
	      offset = -8;
	    }
	  else
	    load_pc = 0;

	  if (load_pc)
	    {
	      CORE_ADDR addr = get_frame_register_unsigned (frame, rn);
	      nextpc = get_frame_memory_unsigned (frame, addr + offset, 4);
	    }
	}
      else if ((inst1 & 0xffef) == 0xea4f && (inst2 & 0xfff0) == 0x0f00)
	{
	  /* MOV PC or MOVS PC.  */
	  nextpc = get_frame_register_unsigned (frame, bits (inst2, 0, 3));
	  nextpc = MAKE_THUMB_ADDR (nextpc);
	}
      else if ((inst1 & 0xff70) == 0xf850 && (inst2 & 0xf000) == 0xf000)
	{
	  /* LDR PC.  */
	  CORE_ADDR base;
	  int rn, load_pc = 1;

	  rn = bits (inst1, 0, 3);
	  base = get_frame_register_unsigned (frame, rn);
	  if (rn == ARM_PC_REGNUM)
	    {
	      base = (base + 4) & ~(CORE_ADDR) 0x3;
	      if (bit (inst1, 7))
		base += bits (inst2, 0, 11);
	      else
		base -= bits (inst2, 0, 11);
	    }
	  else if (bit (inst1, 7))
	    base += bits (inst2, 0, 11);
	  else if (bit (inst2, 11))
	    {
	      if (bit (inst2, 10))
		{
		  if (bit (inst2, 9))
		    base += bits (inst2, 0, 7);
		  else
		    base -= bits (inst2, 0, 7);
		}
	    }
	  else if ((inst2 & 0x0fc0) == 0x0000)
	    {
	      int shift = bits (inst2, 4, 5), rm = bits (inst2, 0, 3);
	      base += get_frame_register_unsigned (frame, rm) << shift;
	    }
	  else
	    /* Reserved.  */
	    load_pc = 0;

	  if (load_pc)
	    nextpc = get_frame_memory_unsigned (frame, base, 4);
	}
      else if ((inst1 & 0xfff0) == 0xe8d0 && (inst2 & 0xfff0) == 0xf000)
	{
	  /* TBB.  */
	  CORE_ADDR tbl_reg, table, offset, length;

	  tbl_reg = bits (inst1, 0, 3);
	  if (tbl_reg == 0x0f)
	    table = pc + 4;  /* Regcache copy of PC isn't right yet.  */
	  else
	    table = get_frame_register_unsigned (frame, tbl_reg);

	  offset = get_frame_register_unsigned (frame, bits (inst2, 0, 3));
	  length = 2 * get_frame_memory_unsigned (frame, table + offset, 1);
	  nextpc = pc_val + length;
	}
      else if ((inst1 & 0xfff0) == 0xe8d0 && (inst2 & 0xfff0) == 0xf010)
	{
	  /* TBH.  */
	  CORE_ADDR tbl_reg, table, offset, length;

	  tbl_reg = bits (inst1, 0, 3);
	  if (tbl_reg == 0x0f)
	    table = pc + 4;  /* Regcache copy of PC isn't right yet.  */
	  else
	    table = get_frame_register_unsigned (frame, tbl_reg);

	  offset = 2 * get_frame_register_unsigned (frame, bits (inst2, 0, 3));
	  length = 2 * get_frame_memory_unsigned (frame, table + offset, 2);
	  nextpc = pc_val + length;
	}
    }
  else if ((inst1 & 0xff00) == 0x4700)	/* bx REG, blx REG */
    {
      if (bits (inst1, 3, 6) == 0x0f)
	nextpc = UNMAKE_THUMB_ADDR (pc_val);
      else
	nextpc = get_frame_register_unsigned (frame, bits (inst1, 3, 6));
    }
  else if ((inst1 & 0xff87) == 0x4687)	/* mov pc, REG */
    {
      if (bits (inst1, 3, 6) == 0x0f)
	nextpc = pc_val;
      else
	nextpc = get_frame_register_unsigned (frame, bits (inst1, 3, 6));

      nextpc = MAKE_THUMB_ADDR (nextpc);
    }
  else if ((inst1 & 0xf500) == 0xb100)
    {
      /* CBNZ or CBZ.  */
      int imm = (bit (inst1, 9) << 6) + (bits (inst1, 3, 7) << 1);
      ULONGEST reg = get_frame_register_unsigned (frame, bits (inst1, 0, 2));

      if (bit (inst1, 11) && reg != 0)
	nextpc = pc_val + imm;
      else if (!bit (inst1, 11) && reg == 0)
	nextpc = pc_val + imm;
    }
  return nextpc;
}

/* Get the raw next address.  PC is the current program counter, in 
   FRAME, which is assumed to be executing in ARM mode.

   The value returned has the execution state of the next instruction 
   encoded in it.  Use IS_THUMB_ADDR () to see whether the instruction is
   in Thumb-State, and gdbarch_addr_bits_remove () to get the plain memory
   address.  */

static CORE_ADDR
arm_get_next_pc_raw (struct frame_info *frame, CORE_ADDR pc)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  enum bfd_endian byte_order_for_code = gdbarch_byte_order_for_code (gdbarch);
  unsigned long pc_val;
  unsigned long this_instr;
  unsigned long status;
  CORE_ADDR nextpc;

  pc_val = (unsigned long) pc;
  this_instr = read_memory_unsigned_integer (pc, 4, byte_order_for_code);

  status = get_frame_register_unsigned (frame, ARM_PS_REGNUM);
  nextpc = (CORE_ADDR) (pc_val + 4);	/* Default case */

  if (bits (this_instr, 28, 31) == INST_NV)
    switch (bits (this_instr, 24, 27))
      {
      case 0xa:
      case 0xb:
	{
	  /* Branch with Link and change to Thumb.  */
	  nextpc = BranchDest (pc, this_instr);
	  nextpc |= bit (this_instr, 24) << 1;
	  nextpc = MAKE_THUMB_ADDR (nextpc);
	  break;
	}
      case 0xc:
      case 0xd:
      case 0xe:
	/* Coprocessor register transfer.  */
        if (bits (this_instr, 12, 15) == 15)
	  error (_("Invalid update to pc in instruction"));
	break;
      }
  else if (condition_true (bits (this_instr, 28, 31), status))
    {
      switch (bits (this_instr, 24, 27))
	{
	case 0x0:
	case 0x1:			/* data processing */
	case 0x2:
	case 0x3:
	  {
	    unsigned long operand1, operand2, result = 0;
	    unsigned long rn;
	    int c;

	    if (bits (this_instr, 12, 15) != 15)
	      break;

	    if (bits (this_instr, 22, 25) == 0
		&& bits (this_instr, 4, 7) == 9)	/* multiply */
	      error (_("Invalid update to pc in instruction"));

	    /* BX <reg>, BLX <reg> */
	    if (bits (this_instr, 4, 27) == 0x12fff1
		|| bits (this_instr, 4, 27) == 0x12fff3)
	      {
		rn = bits (this_instr, 0, 3);
		nextpc = ((rn == ARM_PC_REGNUM)
			  ? (pc_val + 8)
			  : get_frame_register_unsigned (frame, rn));

		return nextpc;
	      }

	    /* Multiply into PC.  */
	    c = (status & FLAG_C) ? 1 : 0;
	    rn = bits (this_instr, 16, 19);
	    operand1 = ((rn == ARM_PC_REGNUM)
			? (pc_val + 8)
			: get_frame_register_unsigned (frame, rn));

	    if (bit (this_instr, 25))
	      {
		unsigned long immval = bits (this_instr, 0, 7);
		unsigned long rotate = 2 * bits (this_instr, 8, 11);
		operand2 = ((immval >> rotate) | (immval << (32 - rotate)))
		  & 0xffffffff;
	      }
	    else		/* operand 2 is a shifted register.  */
	      operand2 = shifted_reg_val (frame, this_instr, c,
					  pc_val, status);

	    switch (bits (this_instr, 21, 24))
	      {
	      case 0x0:	/*and */
		result = operand1 & operand2;
		break;

	      case 0x1:	/*eor */
		result = operand1 ^ operand2;
		break;

	      case 0x2:	/*sub */
		result = operand1 - operand2;
		break;

	      case 0x3:	/*rsb */
		result = operand2 - operand1;
		break;

	      case 0x4:	/*add */
		result = operand1 + operand2;
		break;

	      case 0x5:	/*adc */
		result = operand1 + operand2 + c;
		break;

	      case 0x6:	/*sbc */
		result = operand1 - operand2 + c;
		break;

	      case 0x7:	/*rsc */
		result = operand2 - operand1 + c;
		break;

	      case 0x8:
	      case 0x9:
	      case 0xa:
	      case 0xb:	/* tst, teq, cmp, cmn */
		result = (unsigned long) nextpc;
		break;

	      case 0xc:	/*orr */
		result = operand1 | operand2;
		break;

	      case 0xd:	/*mov */
		/* Always step into a function.  */
		result = operand2;
		break;

	      case 0xe:	/*bic */
		result = operand1 & ~operand2;
		break;

	      case 0xf:	/*mvn */
		result = ~operand2;
		break;
	      }

            /* In 26-bit APCS the bottom two bits of the result are 
	       ignored, and we always end up in ARM state.  */
	    if (!arm_apcs_32)
	      nextpc = arm_addr_bits_remove (gdbarch, result);
	    else
	      nextpc = result;

	    break;
	  }

	case 0x4:
	case 0x5:		/* data transfer */
	case 0x6:
	case 0x7:
	  if (bit (this_instr, 20))
	    {
	      /* load */
	      if (bits (this_instr, 12, 15) == 15)
		{
		  /* rd == pc */
		  unsigned long rn;
		  unsigned long base;

		  if (bit (this_instr, 22))
		    error (_("Invalid update to pc in instruction"));

		  /* byte write to PC */
		  rn = bits (this_instr, 16, 19);
		  base = ((rn == ARM_PC_REGNUM)
			  ? (pc_val + 8)
			  : get_frame_register_unsigned (frame, rn));

		  if (bit (this_instr, 24))
		    {
		      /* pre-indexed */
		      int c = (status & FLAG_C) ? 1 : 0;
		      unsigned long offset =
		      (bit (this_instr, 25)
		       ? shifted_reg_val (frame, this_instr, c, pc_val, status)
		       : bits (this_instr, 0, 11));

		      if (bit (this_instr, 23))
			base += offset;
		      else
			base -= offset;
		    }
		  nextpc =
		    (CORE_ADDR) read_memory_unsigned_integer ((CORE_ADDR) base,
							      4, byte_order);
		}
	    }
	  break;

	case 0x8:
	case 0x9:		/* block transfer */
	  if (bit (this_instr, 20))
	    {
	      /* LDM */
	      if (bit (this_instr, 15))
		{
		  /* loading pc */
		  int offset = 0;
		  unsigned long rn_val
		    = get_frame_register_unsigned (frame,
						   bits (this_instr, 16, 19));

		  if (bit (this_instr, 23))
		    {
		      /* up */
		      unsigned long reglist = bits (this_instr, 0, 14);
		      offset = bitcount (reglist) * 4;
		      if (bit (this_instr, 24))		/* pre */
			offset += 4;
		    }
		  else if (bit (this_instr, 24))
		    offset = -4;

		  nextpc =
		    (CORE_ADDR) read_memory_unsigned_integer ((CORE_ADDR)
							      (rn_val + offset),
							      4, byte_order);
		}
	    }
	  break;

	case 0xb:		/* branch & link */
	case 0xa:		/* branch */
	  {
	    nextpc = BranchDest (pc, this_instr);
	    break;
	  }

	case 0xc:
	case 0xd:
	case 0xe:		/* coproc ops */
	  break;
	case 0xf:		/* SWI */
	  {
	    struct gdbarch_tdep *tdep;
	    tdep = gdbarch_tdep (gdbarch);

	    if (tdep->syscall_next_pc != NULL)
	      nextpc = tdep->syscall_next_pc (frame);

	  }
	  break;

	default:
	  fprintf_filtered (gdb_stderr, _("Bad bit-field extraction\n"));
	  return (pc);
	}
    }

  return nextpc;
}

/* Determine next PC after current instruction executes.  Will call either
   arm_get_next_pc_raw or thumb_get_next_pc_raw.  Error out if infinite
   loop is detected.  */

CORE_ADDR
arm_get_next_pc (struct frame_info *frame, CORE_ADDR pc)
{
  CORE_ADDR nextpc;

  if (arm_frame_is_thumb (frame))
    {
      nextpc = thumb_get_next_pc_raw (frame, pc);
      if (nextpc == MAKE_THUMB_ADDR (pc))
	error (_("Infinite loop detected"));
    }
  else
    {
      nextpc = arm_get_next_pc_raw (frame, pc);
      if (nextpc == pc)
	error (_("Infinite loop detected"));
    }

  return nextpc;
}

/* Like insert_single_step_breakpoint, but make sure we use a breakpoint
   of the appropriate mode (as encoded in the PC value), even if this
   differs from what would be expected according to the symbol tables.  */

void
arm_insert_single_step_breakpoint (struct gdbarch *gdbarch,
				   struct address_space *aspace,
				   CORE_ADDR pc)
{
  struct cleanup *old_chain
    = make_cleanup_restore_integer (&arm_override_mode);

  arm_override_mode = IS_THUMB_ADDR (pc);
  pc = gdbarch_addr_bits_remove (gdbarch, pc);

  insert_single_step_breakpoint (gdbarch, aspace, pc);

  do_cleanups (old_chain);
}

/* Checks for an atomic sequence of instructions beginning with a LDREX{,B,H,D}
   instruction and ending with a STREX{,B,H,D} instruction.  If such a sequence
   is found, attempt to step through it.  A breakpoint is placed at the end of
   the sequence.  */

static int
thumb_deal_with_atomic_sequence_raw (struct frame_info *frame)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  struct address_space *aspace = get_frame_address_space (frame);
  enum bfd_endian byte_order_for_code = gdbarch_byte_order_for_code (gdbarch);
  CORE_ADDR pc = get_frame_pc (frame);
  CORE_ADDR breaks[2] = {-1, -1};
  CORE_ADDR loc = pc;
  unsigned short insn1, insn2;
  int insn_count;
  int index;
  int last_breakpoint = 0; /* Defaults to 0 (no breakpoints placed).  */
  const int atomic_sequence_length = 16; /* Instruction sequence length.  */
  ULONGEST status, itstate;

  /* We currently do not support atomic sequences within an IT block.  */
  status = get_frame_register_unsigned (frame, ARM_PS_REGNUM);
  itstate = ((status >> 8) & 0xfc) | ((status >> 25) & 0x3);
  if (itstate & 0x0f)
    return 0;

  /* Assume all atomic sequences start with a ldrex{,b,h,d} instruction.  */
  insn1 = read_memory_unsigned_integer (loc, 2, byte_order_for_code);
  loc += 2;
  if (thumb_insn_size (insn1) != 4)
    return 0;

  insn2 = read_memory_unsigned_integer (loc, 2, byte_order_for_code);
  loc += 2;
  if (!((insn1 & 0xfff0) == 0xe850
        || ((insn1 & 0xfff0) == 0xe8d0 && (insn2 & 0x00c0) == 0x0040)))
    return 0;

  /* Assume that no atomic sequence is longer than "atomic_sequence_length"
     instructions.  */
  for (insn_count = 0; insn_count < atomic_sequence_length; ++insn_count)
    {
      insn1 = read_memory_unsigned_integer (loc, 2, byte_order_for_code);
      loc += 2;

      if (thumb_insn_size (insn1) != 4)
	{
	  /* Assume that there is at most one conditional branch in the
	     atomic sequence.  If a conditional branch is found, put a
	     breakpoint in its destination address.  */
	  if ((insn1 & 0xf000) == 0xd000 && bits (insn1, 8, 11) != 0x0f)
	    {
	      if (last_breakpoint > 0)
		return 0; /* More than one conditional branch found,
			     fallback to the standard code.  */

	      breaks[1] = loc + 2 + (sbits (insn1, 0, 7) << 1);
	      last_breakpoint++;
	    }

	  /* We do not support atomic sequences that use any *other*
	     instructions but conditional branches to change the PC.
	     Fall back to standard code to avoid losing control of
	     execution.  */
	  else if (thumb_instruction_changes_pc (insn1))
	    return 0;
	}
      else
	{
	  insn2 = read_memory_unsigned_integer (loc, 2, byte_order_for_code);
	  loc += 2;

	  /* Assume that there is at most one conditional branch in the
	     atomic sequence.  If a conditional branch is found, put a
	     breakpoint in its destination address.  */
	  if ((insn1 & 0xf800) == 0xf000
	      && (insn2 & 0xd000) == 0x8000
	      && (insn1 & 0x0380) != 0x0380)
	    {
	      int sign, j1, j2, imm1, imm2;
	      unsigned int offset;

	      sign = sbits (insn1, 10, 10);
	      imm1 = bits (insn1, 0, 5);
	      imm2 = bits (insn2, 0, 10);
	      j1 = bit (insn2, 13);
	      j2 = bit (insn2, 11);

	      offset = (sign << 20) + (j2 << 19) + (j1 << 18);
	      offset += (imm1 << 12) + (imm2 << 1);

	      if (last_breakpoint > 0)
		return 0; /* More than one conditional branch found,
			     fallback to the standard code.  */

	      breaks[1] = loc + offset;
	      last_breakpoint++;
	    }

	  /* We do not support atomic sequences that use any *other*
	     instructions but conditional branches to change the PC.
	     Fall back to standard code to avoid losing control of
	     execution.  */
	  else if (thumb2_instruction_changes_pc (insn1, insn2))
	    return 0;

	  /* If we find a strex{,b,h,d}, we're done.  */
	  if ((insn1 & 0xfff0) == 0xe840
	      || ((insn1 & 0xfff0) == 0xe8c0 && (insn2 & 0x00c0) == 0x0040))
	    break;
	}
    }

  /* If we didn't find the strex{,b,h,d}, we cannot handle the sequence.  */
  if (insn_count == atomic_sequence_length)
    return 0;

  /* Insert a breakpoint right after the end of the atomic sequence.  */
  breaks[0] = loc;

  /* Check for duplicated breakpoints.  Check also for a breakpoint
     placed (branch instruction's destination) anywhere in sequence.  */
  if (last_breakpoint
      && (breaks[1] == breaks[0]
	  || (breaks[1] >= pc && breaks[1] < loc)))
    last_breakpoint = 0;

  /* Effectively inserts the breakpoints.  */
  for (index = 0; index <= last_breakpoint; index++)
    arm_insert_single_step_breakpoint (gdbarch, aspace,
				       MAKE_THUMB_ADDR (breaks[index]));

  return 1;
}

static int
arm_deal_with_atomic_sequence_raw (struct frame_info *frame)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  struct address_space *aspace = get_frame_address_space (frame);
  enum bfd_endian byte_order_for_code = gdbarch_byte_order_for_code (gdbarch);
  CORE_ADDR pc = get_frame_pc (frame);
  CORE_ADDR breaks[2] = {-1, -1};
  CORE_ADDR loc = pc;
  unsigned int insn;
  int insn_count;
  int index;
  int last_breakpoint = 0; /* Defaults to 0 (no breakpoints placed).  */
  const int atomic_sequence_length = 16; /* Instruction sequence length.  */

  /* Assume all atomic sequences start with a ldrex{,b,h,d} instruction.
     Note that we do not currently support conditionally executed atomic
     instructions.  */
  insn = read_memory_unsigned_integer (loc, 4, byte_order_for_code);
  loc += 4;
  if ((insn & 0xff9000f0) != 0xe1900090)
    return 0;

  /* Assume that no atomic sequence is longer than "atomic_sequence_length"
     instructions.  */
  for (insn_count = 0; insn_count < atomic_sequence_length; ++insn_count)
    {
      insn = read_memory_unsigned_integer (loc, 4, byte_order_for_code);
      loc += 4;

      /* Assume that there is at most one conditional branch in the atomic
         sequence.  If a conditional branch is found, put a breakpoint in
         its destination address.  */
      if (bits (insn, 24, 27) == 0xa)
	{
          if (last_breakpoint > 0)
            return 0; /* More than one conditional branch found, fallback
                         to the standard single-step code.  */

	  breaks[1] = BranchDest (loc - 4, insn);
	  last_breakpoint++;
        }

      /* We do not support atomic sequences that use any *other* instructions
         but conditional branches to change the PC.  Fall back to standard
	 code to avoid losing control of execution.  */
      else if (arm_instruction_changes_pc (insn))
	return 0;

      /* If we find a strex{,b,h,d}, we're done.  */
      if ((insn & 0xff9000f0) == 0xe1800090)
	break;
    }

  /* If we didn't find the strex{,b,h,d}, we cannot handle the sequence.  */
  if (insn_count == atomic_sequence_length)
    return 0;

  /* Insert a breakpoint right after the end of the atomic sequence.  */
  breaks[0] = loc;

  /* Check for duplicated breakpoints.  Check also for a breakpoint
     placed (branch instruction's destination) anywhere in sequence.  */
  if (last_breakpoint
      && (breaks[1] == breaks[0]
	  || (breaks[1] >= pc && breaks[1] < loc)))
    last_breakpoint = 0;

  /* Effectively inserts the breakpoints.  */
  for (index = 0; index <= last_breakpoint; index++)
    arm_insert_single_step_breakpoint (gdbarch, aspace, breaks[index]);

  return 1;
}

int
arm_deal_with_atomic_sequence (struct frame_info *frame)
{
  if (arm_frame_is_thumb (frame))
    return thumb_deal_with_atomic_sequence_raw (frame);
  else
    return arm_deal_with_atomic_sequence_raw (frame);
}

/* single_step() is called just before we want to resume the inferior,
   if we want to single-step it but there is no hardware or kernel
   single-step support.  We find the target of the coming instruction
   and breakpoint it.  */

int
arm_software_single_step (struct frame_info *frame)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  struct address_space *aspace = get_frame_address_space (frame);
  CORE_ADDR next_pc;

  if (arm_deal_with_atomic_sequence (frame))
    return 1;

  next_pc = arm_get_next_pc (frame, get_frame_pc (frame));
  arm_insert_single_step_breakpoint (gdbarch, aspace, next_pc);

  return 1;
}

/* Given BUF, which is OLD_LEN bytes ending at ENDADDR, expand
   the buffer to be NEW_LEN bytes ending at ENDADDR.  Return
   NULL if an error occurs.  BUF is freed.  */

static gdb_byte *
extend_buffer_earlier (gdb_byte *buf, CORE_ADDR endaddr,
		       int old_len, int new_len)
{
  gdb_byte *new_buf;
  int bytes_to_read = new_len - old_len;

  new_buf = xmalloc (new_len);
  memcpy (new_buf + bytes_to_read, buf, old_len);
  xfree (buf);
  if (target_read_memory (endaddr - new_len, new_buf, bytes_to_read) != 0)
    {
      xfree (new_buf);
      return NULL;
    }
  return new_buf;
}

/* An IT block is at most the 2-byte IT instruction followed by
   four 4-byte instructions.  The furthest back we must search to
   find an IT block that affects the current instruction is thus
   2 + 3 * 4 == 14 bytes.  */
#define MAX_IT_BLOCK_PREFIX 14

/* Use a quick scan if there are more than this many bytes of
   code.  */
#define IT_SCAN_THRESHOLD 32

/* Adjust a breakpoint's address to move breakpoints out of IT blocks.
   A breakpoint in an IT block may not be hit, depending on the
   condition flags.  */
static CORE_ADDR
arm_adjust_breakpoint_address (struct gdbarch *gdbarch, CORE_ADDR bpaddr)
{
  gdb_byte *buf;
  char map_type;
  CORE_ADDR boundary, func_start;
  int buf_len;
  enum bfd_endian order = gdbarch_byte_order_for_code (gdbarch);
  int i, any, last_it, last_it_count;

  /* If we are using BKPT breakpoints, none of this is necessary.  */
  if (gdbarch_tdep (gdbarch)->thumb2_breakpoint == NULL)
    return bpaddr;

  /* ARM mode does not have this problem.  */
  if (!arm_pc_is_thumb (gdbarch, bpaddr))
    return bpaddr;

  /* We are setting a breakpoint in Thumb code that could potentially
     contain an IT block.  The first step is to find how much Thumb
     code there is; we do not need to read outside of known Thumb
     sequences.  */
  map_type = arm_find_mapping_symbol (bpaddr, &boundary);
  if (map_type == 0)
    /* Thumb-2 code must have mapping symbols to have a chance.  */
    return bpaddr;

  bpaddr = gdbarch_addr_bits_remove (gdbarch, bpaddr);

  if (find_pc_partial_function (bpaddr, NULL, &func_start, NULL)
      && func_start > boundary)
    boundary = func_start;

  /* Search for a candidate IT instruction.  We have to do some fancy
     footwork to distinguish a real IT instruction from the second
     half of a 32-bit instruction, but there is no need for that if
     there's no candidate.  */
  buf_len = min (bpaddr - boundary, MAX_IT_BLOCK_PREFIX);
  if (buf_len == 0)
    /* No room for an IT instruction.  */
    return bpaddr;

  buf = xmalloc (buf_len);
  if (target_read_memory (bpaddr - buf_len, buf, buf_len) != 0)
    return bpaddr;
  any = 0;
  for (i = 0; i < buf_len; i += 2)
    {
      unsigned short inst1 = extract_unsigned_integer (&buf[i], 2, order);
      if ((inst1 & 0xff00) == 0xbf00 && (inst1 & 0x000f) != 0)
	{
	  any = 1;
	  break;
	}
    }
  if (any == 0)
    {
      xfree (buf);
      return bpaddr;
    }

  /* OK, the code bytes before this instruction contain at least one
     halfword which resembles an IT instruction.  We know that it's
     Thumb code, but there are still two possibilities.  Either the
     halfword really is an IT instruction, or it is the second half of
     a 32-bit Thumb instruction.  The only way we can tell is to
     scan forwards from a known instruction boundary.  */
  if (bpaddr - boundary > IT_SCAN_THRESHOLD)
    {
      int definite;

      /* There's a lot of code before this instruction.  Start with an
	 optimistic search; it's easy to recognize halfwords that can
	 not be the start of a 32-bit instruction, and use that to
	 lock on to the instruction boundaries.  */
      buf = extend_buffer_earlier (buf, bpaddr, buf_len, IT_SCAN_THRESHOLD);
      if (buf == NULL)
	return bpaddr;
      buf_len = IT_SCAN_THRESHOLD;

      definite = 0;
      for (i = 0; i < buf_len - sizeof (buf) && ! definite; i += 2)
	{
	  unsigned short inst1 = extract_unsigned_integer (&buf[i], 2, order);
	  if (thumb_insn_size (inst1) == 2)
	    {
	      definite = 1;
	      break;
	    }
	}

      /* At this point, if DEFINITE, BUF[I] is the first place we
	 are sure that we know the instruction boundaries, and it is far
	 enough from BPADDR that we could not miss an IT instruction
	 affecting BPADDR.  If ! DEFINITE, give up - start from a
	 known boundary.  */
      if (! definite)
	{
	  buf = extend_buffer_earlier (buf, bpaddr, buf_len,
				       bpaddr - boundary);
	  if (buf == NULL)
	    return bpaddr;
	  buf_len = bpaddr - boundary;
	  i = 0;
	}
    }
  else
    {
      buf = extend_buffer_earlier (buf, bpaddr, buf_len, bpaddr - boundary);
      if (buf == NULL)
	return bpaddr;
      buf_len = bpaddr - boundary;
      i = 0;
    }

  /* Scan forwards.  Find the last IT instruction before BPADDR.  */
  last_it = -1;
  last_it_count = 0;
  while (i < buf_len)
    {
      unsigned short inst1 = extract_unsigned_integer (&buf[i], 2, order);
      last_it_count--;
      if ((inst1 & 0xff00) == 0xbf00 && (inst1 & 0x000f) != 0)
	{
	  last_it = i;
	  if (inst1 & 0x0001)
	    last_it_count = 4;
	  else if (inst1 & 0x0002)
	    last_it_count = 3;
	  else if (inst1 & 0x0004)
	    last_it_count = 2;
	  else
	    last_it_count = 1;
	}
      i += thumb_insn_size (inst1);
    }

  xfree (buf);

  if (last_it == -1)
    /* There wasn't really an IT instruction after all.  */
    return bpaddr;

  if (last_it_count < 1)
    /* It was too far away.  */
    return bpaddr;

  /* This really is a trouble spot.  Move the breakpoint to the IT
     instruction.  */
  return bpaddr - buf_len + last_it;
}

/* ARM displaced stepping support.

   Generally ARM displaced stepping works as follows:

   1. When an instruction is to be single-stepped, it is first decoded by
      arm_process_displaced_insn (called from arm_displaced_step_copy_insn).
      Depending on the type of instruction, it is then copied to a scratch
      location, possibly in a modified form.  The copy_* set of functions
      performs such modification, as necessary.  A breakpoint is placed after
      the modified instruction in the scratch space to return control to GDB.
      Note in particular that instructions which modify the PC will no longer
      do so after modification.

   2. The instruction is single-stepped, by setting the PC to the scratch
      location address, and resuming.  Control returns to GDB when the
      breakpoint is hit.

   3. A cleanup function (cleanup_*) is called corresponding to the copy_*
      function used for the current instruction.  This function's job is to
      put the CPU/memory state back to what it would have been if the
      instruction had been executed unmodified in its original location.  */

/* NOP instruction (mov r0, r0).  */
#define ARM_NOP				0xe1a00000
#define THUMB_NOP 0x4600

/* Helper for register reads for displaced stepping.  In particular, this
   returns the PC as it would be seen by the instruction at its original
   location.  */

ULONGEST
displaced_read_reg (struct regcache *regs, struct displaced_step_closure *dsc,
		    int regno)
{
  ULONGEST ret;
  CORE_ADDR from = dsc->insn_addr;

  if (regno == ARM_PC_REGNUM)
    {
      /* Compute pipeline offset:
	 - When executing an ARM instruction, PC reads as the address of the
	 current instruction plus 8.
	 - When executing a Thumb instruction, PC reads as the address of the
	 current instruction plus 4.  */

      if (!dsc->is_thumb)
	from += 8;
      else
	from += 4;

      if (debug_displaced)
	fprintf_unfiltered (gdb_stdlog, "displaced: read pc value %.8lx\n",
			    (unsigned long) from);
      return (ULONGEST) from;
    }
  else
    {
      regcache_cooked_read_unsigned (regs, regno, &ret);
      if (debug_displaced)
	fprintf_unfiltered (gdb_stdlog, "displaced: read r%d value %.8lx\n",
			    regno, (unsigned long) ret);
      return ret;
    }
}

static int
displaced_in_arm_mode (struct regcache *regs)
{
  ULONGEST ps;
  ULONGEST t_bit = arm_psr_thumb_bit (get_regcache_arch (regs));

  regcache_cooked_read_unsigned (regs, ARM_PS_REGNUM, &ps);

  return (ps & t_bit) == 0;
}

/* Write to the PC as from a branch instruction.  */

static void
branch_write_pc (struct regcache *regs, struct displaced_step_closure *dsc,
		 ULONGEST val)
{
  if (!dsc->is_thumb)
    /* Note: If bits 0/1 are set, this branch would be unpredictable for
       architecture versions < 6.  */
    regcache_cooked_write_unsigned (regs, ARM_PC_REGNUM,
				    val & ~(ULONGEST) 0x3);
  else
    regcache_cooked_write_unsigned (regs, ARM_PC_REGNUM,
				    val & ~(ULONGEST) 0x1);
}

/* Write to the PC as from a branch-exchange instruction.  */

static void
bx_write_pc (struct regcache *regs, ULONGEST val)
{
  ULONGEST ps;
  ULONGEST t_bit = arm_psr_thumb_bit (get_regcache_arch (regs));

  regcache_cooked_read_unsigned (regs, ARM_PS_REGNUM, &ps);

  if ((val & 1) == 1)
    {
      regcache_cooked_write_unsigned (regs, ARM_PS_REGNUM, ps | t_bit);
      regcache_cooked_write_unsigned (regs, ARM_PC_REGNUM, val & 0xfffffffe);
    }
  else if ((val & 2) == 0)
    {
      regcache_cooked_write_unsigned (regs, ARM_PS_REGNUM, ps & ~t_bit);
      regcache_cooked_write_unsigned (regs, ARM_PC_REGNUM, val);
    }
  else
    {
      /* Unpredictable behaviour.  Try to do something sensible (switch to ARM
	  mode, align dest to 4 bytes).  */
      warning (_("Single-stepping BX to non-word-aligned ARM instruction."));
      regcache_cooked_write_unsigned (regs, ARM_PS_REGNUM, ps & ~t_bit);
      regcache_cooked_write_unsigned (regs, ARM_PC_REGNUM, val & 0xfffffffc);
    }
}

/* Write to the PC as if from a load instruction.  */

static void
load_write_pc (struct regcache *regs, struct displaced_step_closure *dsc,
	       ULONGEST val)
{
  if (DISPLACED_STEPPING_ARCH_VERSION >= 5)
    bx_write_pc (regs, val);
  else
    branch_write_pc (regs, dsc, val);
}

/* Write to the PC as if from an ALU instruction.  */

static void
alu_write_pc (struct regcache *regs, struct displaced_step_closure *dsc,
	      ULONGEST val)
{
  if (DISPLACED_STEPPING_ARCH_VERSION >= 7 && !dsc->is_thumb)
    bx_write_pc (regs, val);
  else
    branch_write_pc (regs, dsc, val);
}

/* Helper for writing to registers for displaced stepping.  Writing to the PC
   has a varying effects depending on the instruction which does the write:
   this is controlled by the WRITE_PC argument.  */

void
displaced_write_reg (struct regcache *regs, struct displaced_step_closure *dsc,
		     int regno, ULONGEST val, enum pc_write_style write_pc)
{
  if (regno == ARM_PC_REGNUM)
    {
      if (debug_displaced)
	fprintf_unfiltered (gdb_stdlog, "displaced: writing pc %.8lx\n",
			    (unsigned long) val);
      switch (write_pc)
	{
	case BRANCH_WRITE_PC:
	  branch_write_pc (regs, dsc, val);
	  break;

	case BX_WRITE_PC:
	  bx_write_pc (regs, val);
  	  break;

	case LOAD_WRITE_PC:
	  load_write_pc (regs, dsc, val);
  	  break;

	case ALU_WRITE_PC:
	  alu_write_pc (regs, dsc, val);
  	  break;

	case CANNOT_WRITE_PC:
	  warning (_("Instruction wrote to PC in an unexpected way when "
		     "single-stepping"));
	  break;

	default:
	  internal_error (__FILE__, __LINE__,
			  _("Invalid argument to displaced_write_reg"));
	}

      dsc->wrote_to_pc = 1;
    }
  else
    {
      if (debug_displaced)
	fprintf_unfiltered (gdb_stdlog, "displaced: writing r%d value %.8lx\n",
			    regno, (unsigned long) val);
      regcache_cooked_write_unsigned (regs, regno, val);
    }
}

/* This function is used to concisely determine if an instruction INSN
   references PC.  Register fields of interest in INSN should have the
   corresponding fields of BITMASK set to 0b1111.  The function
   returns return 1 if any of these fields in INSN reference the PC
   (also 0b1111, r15), else it returns 0.  */

static int
insn_references_pc (uint32_t insn, uint32_t bitmask)
{
  uint32_t lowbit = 1;

  while (bitmask != 0)
    {
      uint32_t mask;

      for (; lowbit && (bitmask & lowbit) == 0; lowbit <<= 1)
	;

      if (!lowbit)
	break;

      mask = lowbit * 0xf;

      if ((insn & mask) == mask)
	return 1;

      bitmask &= ~mask;
    }

  return 0;
}

/* The simplest copy function.  Many instructions have the same effect no
   matter what address they are executed at: in those cases, use this.  */

static int
arm_copy_unmodified (struct gdbarch *gdbarch, uint32_t insn,
		     const char *iname, struct displaced_step_closure *dsc)
{
  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: copying insn %.8lx, "
			"opcode/class '%s' unmodified\n", (unsigned long) insn,
			iname);

  dsc->modinsn[0] = insn;

  return 0;
}

static int
thumb_copy_unmodified_32bit (struct gdbarch *gdbarch, uint16_t insn1,
			     uint16_t insn2, const char *iname,
			     struct displaced_step_closure *dsc)
{
  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: copying insn %.4x %.4x, "
			"opcode/class '%s' unmodified\n", insn1, insn2,
			iname);

  dsc->modinsn[0] = insn1;
  dsc->modinsn[1] = insn2;
  dsc->numinsns = 2;

  return 0;
}

/* Copy 16-bit Thumb(Thumb and 16-bit Thumb-2) instruction without any
   modification.  */
static int
thumb_copy_unmodified_16bit (struct gdbarch *gdbarch, unsigned int insn,
			     const char *iname,
			     struct displaced_step_closure *dsc)
{
  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: copying insn %.4x, "
			"opcode/class '%s' unmodified\n", insn,
			iname);

  dsc->modinsn[0] = insn;

  return 0;
}

/* Preload instructions with immediate offset.  */

static void
cleanup_preload (struct gdbarch *gdbarch,
		 struct regcache *regs, struct displaced_step_closure *dsc)
{
  displaced_write_reg (regs, dsc, 0, dsc->tmp[0], CANNOT_WRITE_PC);
  if (!dsc->u.preload.immed)
    displaced_write_reg (regs, dsc, 1, dsc->tmp[1], CANNOT_WRITE_PC);
}

static void
install_preload (struct gdbarch *gdbarch, struct regcache *regs,
		 struct displaced_step_closure *dsc, unsigned int rn)
{
  ULONGEST rn_val;
  /* Preload instructions:

     {pli/pld} [rn, #+/-imm]
     ->
     {pli/pld} [r0, #+/-imm].  */

  dsc->tmp[0] = displaced_read_reg (regs, dsc, 0);
  rn_val = displaced_read_reg (regs, dsc, rn);
  displaced_write_reg (regs, dsc, 0, rn_val, CANNOT_WRITE_PC);
  dsc->u.preload.immed = 1;

  dsc->cleanup = &cleanup_preload;
}

static int
arm_copy_preload (struct gdbarch *gdbarch, uint32_t insn, struct regcache *regs,
		  struct displaced_step_closure *dsc)
{
  unsigned int rn = bits (insn, 16, 19);

  if (!insn_references_pc (insn, 0x000f0000ul))
    return arm_copy_unmodified (gdbarch, insn, "preload", dsc);

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: copying preload insn %.8lx\n",
			(unsigned long) insn);

  dsc->modinsn[0] = insn & 0xfff0ffff;

  install_preload (gdbarch, regs, dsc, rn);

  return 0;
}

static int
thumb2_copy_preload (struct gdbarch *gdbarch, uint16_t insn1, uint16_t insn2,
		     struct regcache *regs, struct displaced_step_closure *dsc)
{
  unsigned int rn = bits (insn1, 0, 3);
  unsigned int u_bit = bit (insn1, 7);
  int imm12 = bits (insn2, 0, 11);
  ULONGEST pc_val;

  if (rn != ARM_PC_REGNUM)
    return thumb_copy_unmodified_32bit (gdbarch, insn1, insn2, "preload", dsc);

  /* PC is only allowed to use in PLI (immediate,literal) Encoding T3, and
     PLD (literal) Encoding T1.  */
  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog,
			"displaced: copying pld/pli pc (0x%x) %c imm12 %.4x\n",
			(unsigned int) dsc->insn_addr, u_bit ? '+' : '-',
			imm12);

  if (!u_bit)
    imm12 = -1 * imm12;

  /* Rewrite instruction {pli/pld} PC imm12 into:
     Prepare: tmp[0] <- r0, tmp[1] <- r1, r0 <- pc, r1 <- imm12

     {pli/pld} [r0, r1]

     Cleanup: r0 <- tmp[0], r1 <- tmp[1].  */

  dsc->tmp[0] = displaced_read_reg (regs, dsc, 0);
  dsc->tmp[1] = displaced_read_reg (regs, dsc, 1);

  pc_val = displaced_read_reg (regs, dsc, ARM_PC_REGNUM);

  displaced_write_reg (regs, dsc, 0, pc_val, CANNOT_WRITE_PC);
  displaced_write_reg (regs, dsc, 1, imm12, CANNOT_WRITE_PC);
  dsc->u.preload.immed = 0;

  /* {pli/pld} [r0, r1] */
  dsc->modinsn[0] = insn1 & 0xfff0;
  dsc->modinsn[1] = 0xf001;
  dsc->numinsns = 2;

  dsc->cleanup = &cleanup_preload;
  return 0;
}

/* Preload instructions with register offset.  */

static void
install_preload_reg(struct gdbarch *gdbarch, struct regcache *regs,
		    struct displaced_step_closure *dsc, unsigned int rn,
		    unsigned int rm)
{
  ULONGEST rn_val, rm_val;

  /* Preload register-offset instructions:

     {pli/pld} [rn, rm {, shift}]
     ->
     {pli/pld} [r0, r1 {, shift}].  */

  dsc->tmp[0] = displaced_read_reg (regs, dsc, 0);
  dsc->tmp[1] = displaced_read_reg (regs, dsc, 1);
  rn_val = displaced_read_reg (regs, dsc, rn);
  rm_val = displaced_read_reg (regs, dsc, rm);
  displaced_write_reg (regs, dsc, 0, rn_val, CANNOT_WRITE_PC);
  displaced_write_reg (regs, dsc, 1, rm_val, CANNOT_WRITE_PC);
  dsc->u.preload.immed = 0;

  dsc->cleanup = &cleanup_preload;
}

static int
arm_copy_preload_reg (struct gdbarch *gdbarch, uint32_t insn,
		      struct regcache *regs,
		      struct displaced_step_closure *dsc)
{
  unsigned int rn = bits (insn, 16, 19);
  unsigned int rm = bits (insn, 0, 3);


  if (!insn_references_pc (insn, 0x000f000ful))
    return arm_copy_unmodified (gdbarch, insn, "preload reg", dsc);

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: copying preload insn %.8lx\n",
			(unsigned long) insn);

  dsc->modinsn[0] = (insn & 0xfff0fff0) | 0x1;

  install_preload_reg (gdbarch, regs, dsc, rn, rm);
  return 0;
}

/* Copy/cleanup coprocessor load and store instructions.  */

static void
cleanup_copro_load_store (struct gdbarch *gdbarch,
			  struct regcache *regs,
			  struct displaced_step_closure *dsc)
{
  ULONGEST rn_val = displaced_read_reg (regs, dsc, 0);

  displaced_write_reg (regs, dsc, 0, dsc->tmp[0], CANNOT_WRITE_PC);

  if (dsc->u.ldst.writeback)
    displaced_write_reg (regs, dsc, dsc->u.ldst.rn, rn_val, LOAD_WRITE_PC);
}

static void
install_copro_load_store (struct gdbarch *gdbarch, struct regcache *regs,
			  struct displaced_step_closure *dsc,
			  int writeback, unsigned int rn)
{
  ULONGEST rn_val;

  /* Coprocessor load/store instructions:

     {stc/stc2} [<Rn>, #+/-imm]  (and other immediate addressing modes)
     ->
     {stc/stc2} [r0, #+/-imm].

     ldc/ldc2 are handled identically.  */

  dsc->tmp[0] = displaced_read_reg (regs, dsc, 0);
  rn_val = displaced_read_reg (regs, dsc, rn);
  /* PC should be 4-byte aligned.  */
  rn_val = rn_val & 0xfffffffc;
  displaced_write_reg (regs, dsc, 0, rn_val, CANNOT_WRITE_PC);

  dsc->u.ldst.writeback = writeback;
  dsc->u.ldst.rn = rn;

  dsc->cleanup = &cleanup_copro_load_store;
}

static int
arm_copy_copro_load_store (struct gdbarch *gdbarch, uint32_t insn,
			   struct regcache *regs,
			   struct displaced_step_closure *dsc)
{
  unsigned int rn = bits (insn, 16, 19);

  if (!insn_references_pc (insn, 0x000f0000ul))
    return arm_copy_unmodified (gdbarch, insn, "copro load/store", dsc);

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: copying coprocessor "
			"load/store insn %.8lx\n", (unsigned long) insn);

  dsc->modinsn[0] = insn & 0xfff0ffff;

  install_copro_load_store (gdbarch, regs, dsc, bit (insn, 25), rn);

  return 0;
}

static int
thumb2_copy_copro_load_store (struct gdbarch *gdbarch, uint16_t insn1,
			      uint16_t insn2, struct regcache *regs,
			      struct displaced_step_closure *dsc)
{
  unsigned int rn = bits (insn1, 0, 3);

  if (rn != ARM_PC_REGNUM)
    return thumb_copy_unmodified_32bit (gdbarch, insn1, insn2,
					"copro load/store", dsc);

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: copying coprocessor "
			"load/store insn %.4x%.4x\n", insn1, insn2);

  dsc->modinsn[0] = insn1 & 0xfff0;
  dsc->modinsn[1] = insn2;
  dsc->numinsns = 2;

  /* This function is called for copying instruction LDC/LDC2/VLDR, which
     doesn't support writeback, so pass 0.  */
  install_copro_load_store (gdbarch, regs, dsc, 0, rn);

  return 0;
}

/* Clean up branch instructions (actually perform the branch, by setting
   PC).  */

static void
cleanup_branch (struct gdbarch *gdbarch, struct regcache *regs,
		struct displaced_step_closure *dsc)
{
  uint32_t status = displaced_read_reg (regs, dsc, ARM_PS_REGNUM);
  int branch_taken = condition_true (dsc->u.branch.cond, status);
  enum pc_write_style write_pc = dsc->u.branch.exchange
				 ? BX_WRITE_PC : BRANCH_WRITE_PC;

  if (!branch_taken)
    return;

  if (dsc->u.branch.link)
    {
      /* The value of LR should be the next insn of current one.  In order
       not to confuse logic hanlding later insn `bx lr', if current insn mode
       is Thumb, the bit 0 of LR value should be set to 1.  */
      ULONGEST next_insn_addr = dsc->insn_addr + dsc->insn_size;

      if (dsc->is_thumb)
	next_insn_addr |= 0x1;

      displaced_write_reg (regs, dsc, ARM_LR_REGNUM, next_insn_addr,
			   CANNOT_WRITE_PC);
    }

  displaced_write_reg (regs, dsc, ARM_PC_REGNUM, dsc->u.branch.dest, write_pc);
}

/* Copy B/BL/BLX instructions with immediate destinations.  */

static void
install_b_bl_blx (struct gdbarch *gdbarch, struct regcache *regs,
		  struct displaced_step_closure *dsc,
		  unsigned int cond, int exchange, int link, long offset)
{
  /* Implement "BL<cond> <label>" as:

     Preparation: cond <- instruction condition
     Insn: mov r0, r0  (nop)
     Cleanup: if (condition true) { r14 <- pc; pc <- label }.

     B<cond> similar, but don't set r14 in cleanup.  */

  dsc->u.branch.cond = cond;
  dsc->u.branch.link = link;
  dsc->u.branch.exchange = exchange;

  dsc->u.branch.dest = dsc->insn_addr;
  if (link && exchange)
    /* For BLX, offset is computed from the Align (PC, 4).  */
    dsc->u.branch.dest = dsc->u.branch.dest & 0xfffffffc;

  if (dsc->is_thumb)
    dsc->u.branch.dest += 4 + offset;
  else
    dsc->u.branch.dest += 8 + offset;

  dsc->cleanup = &cleanup_branch;
}
static int
arm_copy_b_bl_blx (struct gdbarch *gdbarch, uint32_t insn,
		   struct regcache *regs, struct displaced_step_closure *dsc)
{
  unsigned int cond = bits (insn, 28, 31);
  int exchange = (cond == 0xf);
  int link = exchange || bit (insn, 24);
  long offset;

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: copying %s immediate insn "
			"%.8lx\n", (exchange) ? "blx" : (link) ? "bl" : "b",
			(unsigned long) insn);
  if (exchange)
    /* For BLX, set bit 0 of the destination.  The cleanup_branch function will
       then arrange the switch into Thumb mode.  */
    offset = (bits (insn, 0, 23) << 2) | (bit (insn, 24) << 1) | 1;
  else
    offset = bits (insn, 0, 23) << 2;

  if (bit (offset, 25))
    offset = offset | ~0x3ffffff;

  dsc->modinsn[0] = ARM_NOP;

  install_b_bl_blx (gdbarch, regs, dsc, cond, exchange, link, offset);
  return 0;
}

static int
thumb2_copy_b_bl_blx (struct gdbarch *gdbarch, uint16_t insn1,
		      uint16_t insn2, struct regcache *regs,
		      struct displaced_step_closure *dsc)
{
  int link = bit (insn2, 14);
  int exchange = link && !bit (insn2, 12);
  int cond = INST_AL;
  long offset = 0;
  int j1 = bit (insn2, 13);
  int j2 = bit (insn2, 11);
  int s = sbits (insn1, 10, 10);
  int i1 = !(j1 ^ bit (insn1, 10));
  int i2 = !(j2 ^ bit (insn1, 10));

  if (!link && !exchange) /* B */
    {
      offset = (bits (insn2, 0, 10) << 1);
      if (bit (insn2, 12)) /* Encoding T4 */
	{
	  offset |= (bits (insn1, 0, 9) << 12)
	    | (i2 << 22)
	    | (i1 << 23)
	    | (s << 24);
	  cond = INST_AL;
	}
      else /* Encoding T3 */
	{
	  offset |= (bits (insn1, 0, 5) << 12)
	    | (j1 << 18)
	    | (j2 << 19)
	    | (s << 20);
	  cond = bits (insn1, 6, 9);
	}
    }
  else
    {
      offset = (bits (insn1, 0, 9) << 12);
      offset |= ((i2 << 22) | (i1 << 23) | (s << 24));
      offset |= exchange ?
	(bits (insn2, 1, 10) << 2) : (bits (insn2, 0, 10) << 1);
    }

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: copying %s insn "
			"%.4x %.4x with offset %.8lx\n",
			link ? (exchange) ? "blx" : "bl" : "b",
			insn1, insn2, offset);

  dsc->modinsn[0] = THUMB_NOP;

  install_b_bl_blx (gdbarch, regs, dsc, cond, exchange, link, offset);
  return 0;
}

/* Copy B Thumb instructions.  */
static int
thumb_copy_b (struct gdbarch *gdbarch, unsigned short insn,
	      struct displaced_step_closure *dsc)
{
  unsigned int cond = 0;
  int offset = 0;
  unsigned short bit_12_15 = bits (insn, 12, 15);
  CORE_ADDR from = dsc->insn_addr;

  if (bit_12_15 == 0xd)
    {
      /* offset = SignExtend (imm8:0, 32) */
      offset = sbits ((insn << 1), 0, 8);
      cond = bits (insn, 8, 11);
    }
  else if (bit_12_15 == 0xe) /* Encoding T2 */
    {
      offset = sbits ((insn << 1), 0, 11);
      cond = INST_AL;
    }

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog,
			"displaced: copying b immediate insn %.4x "
			"with offset %d\n", insn, offset);

  dsc->u.branch.cond = cond;
  dsc->u.branch.link = 0;
  dsc->u.branch.exchange = 0;
  dsc->u.branch.dest = from + 4 + offset;

  dsc->modinsn[0] = THUMB_NOP;

  dsc->cleanup = &cleanup_branch;

  return 0;
}

/* Copy BX/BLX with register-specified destinations.  */

static void
install_bx_blx_reg (struct gdbarch *gdbarch, struct regcache *regs,
		    struct displaced_step_closure *dsc, int link,
		    unsigned int cond, unsigned int rm)
{
  /* Implement {BX,BLX}<cond> <reg>" as:

     Preparation: cond <- instruction condition
     Insn: mov r0, r0 (nop)
     Cleanup: if (condition true) { r14 <- pc; pc <- dest; }.

     Don't set r14 in cleanup for BX.  */

  dsc->u.branch.dest = displaced_read_reg (regs, dsc, rm);

  dsc->u.branch.cond = cond;
  dsc->u.branch.link = link;

  dsc->u.branch.exchange = 1;

  dsc->cleanup = &cleanup_branch;
}

static int
arm_copy_bx_blx_reg (struct gdbarch *gdbarch, uint32_t insn,
		     struct regcache *regs, struct displaced_step_closure *dsc)
{
  unsigned int cond = bits (insn, 28, 31);
  /* BX:  x12xxx1x
     BLX: x12xxx3x.  */
  int link = bit (insn, 5);
  unsigned int rm = bits (insn, 0, 3);

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: copying insn %.8lx",
			(unsigned long) insn);

  dsc->modinsn[0] = ARM_NOP;

  install_bx_blx_reg (gdbarch, regs, dsc, link, cond, rm);
  return 0;
}

static int
thumb_copy_bx_blx_reg (struct gdbarch *gdbarch, uint16_t insn,
		       struct regcache *regs,
		       struct displaced_step_closure *dsc)
{
  int link = bit (insn, 7);
  unsigned int rm = bits (insn, 3, 6);

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: copying insn %.4x",
			(unsigned short) insn);

  dsc->modinsn[0] = THUMB_NOP;

  install_bx_blx_reg (gdbarch, regs, dsc, link, INST_AL, rm);

  return 0;
}


/* Copy/cleanup arithmetic/logic instruction with immediate RHS.  */

static void
cleanup_alu_imm (struct gdbarch *gdbarch,
		 struct regcache *regs, struct displaced_step_closure *dsc)
{
  ULONGEST rd_val = displaced_read_reg (regs, dsc, 0);
  displaced_write_reg (regs, dsc, 0, dsc->tmp[0], CANNOT_WRITE_PC);
  displaced_write_reg (regs, dsc, 1, dsc->tmp[1], CANNOT_WRITE_PC);
  displaced_write_reg (regs, dsc, dsc->rd, rd_val, ALU_WRITE_PC);
}

static int
arm_copy_alu_imm (struct gdbarch *gdbarch, uint32_t insn, struct regcache *regs,
		  struct displaced_step_closure *dsc)
{
  unsigned int rn = bits (insn, 16, 19);
  unsigned int rd = bits (insn, 12, 15);
  unsigned int op = bits (insn, 21, 24);
  int is_mov = (op == 0xd);
  ULONGEST rd_val, rn_val;

  if (!insn_references_pc (insn, 0x000ff000ul))
    return arm_copy_unmodified (gdbarch, insn, "ALU immediate", dsc);

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: copying immediate %s insn "
			"%.8lx\n", is_mov ? "move" : "ALU",
			(unsigned long) insn);

  /* Instruction is of form:

     <op><cond> rd, [rn,] #imm

     Rewrite as:

     Preparation: tmp1, tmp2 <- r0, r1;
		  r0, r1 <- rd, rn
     Insn: <op><cond> r0, r1, #imm
     Cleanup: rd <- r0; r0 <- tmp1; r1 <- tmp2
  */

  dsc->tmp[0] = displaced_read_reg (regs, dsc, 0);
  dsc->tmp[1] = displaced_read_reg (regs, dsc, 1);
  rn_val = displaced_read_reg (regs, dsc, rn);
  rd_val = displaced_read_reg (regs, dsc, rd);
  displaced_write_reg (regs, dsc, 0, rd_val, CANNOT_WRITE_PC);
  displaced_write_reg (regs, dsc, 1, rn_val, CANNOT_WRITE_PC);
  dsc->rd = rd;

  if (is_mov)
    dsc->modinsn[0] = insn & 0xfff00fff;
  else
    dsc->modinsn[0] = (insn & 0xfff00fff) | 0x10000;

  dsc->cleanup = &cleanup_alu_imm;

  return 0;
}

static int
thumb2_copy_alu_imm (struct gdbarch *gdbarch, uint16_t insn1,
		     uint16_t insn2, struct regcache *regs,
		     struct displaced_step_closure *dsc)
{
  unsigned int op = bits (insn1, 5, 8);
  unsigned int rn, rm, rd;
  ULONGEST rd_val, rn_val;

  rn = bits (insn1, 0, 3); /* Rn */
  rm = bits (insn2, 0, 3); /* Rm */
  rd = bits (insn2, 8, 11); /* Rd */

  /* This routine is only called for instruction MOV.  */
  gdb_assert (op == 0x2 && rn == 0xf);

  if (rm != ARM_PC_REGNUM && rd != ARM_PC_REGNUM)
    return thumb_copy_unmodified_32bit (gdbarch, insn1, insn2, "ALU imm", dsc);

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: copying reg %s insn %.4x%.4x\n",
			"ALU", insn1, insn2);

  /* Instruction is of form:

     <op><cond> rd, [rn,] #imm

     Rewrite as:

     Preparation: tmp1, tmp2 <- r0, r1;
		  r0, r1 <- rd, rn
     Insn: <op><cond> r0, r1, #imm
     Cleanup: rd <- r0; r0 <- tmp1; r1 <- tmp2
  */

  dsc->tmp[0] = displaced_read_reg (regs, dsc, 0);
  dsc->tmp[1] = displaced_read_reg (regs, dsc, 1);
  rn_val = displaced_read_reg (regs, dsc, rn);
  rd_val = displaced_read_reg (regs, dsc, rd);
  displaced_write_reg (regs, dsc, 0, rd_val, CANNOT_WRITE_PC);
  displaced_write_reg (regs, dsc, 1, rn_val, CANNOT_WRITE_PC);
  dsc->rd = rd;

  dsc->modinsn[0] = insn1;
  dsc->modinsn[1] = ((insn2 & 0xf0f0) | 0x1);
  dsc->numinsns = 2;

  dsc->cleanup = &cleanup_alu_imm;

  return 0;
}

/* Copy/cleanup arithmetic/logic insns with register RHS.  */

static void
cleanup_alu_reg (struct gdbarch *gdbarch,
		 struct regcache *regs, struct displaced_step_closure *dsc)
{
  ULONGEST rd_val;
  int i;

  rd_val = displaced_read_reg (regs, dsc, 0);

  for (i = 0; i < 3; i++)
    displaced_write_reg (regs, dsc, i, dsc->tmp[i], CANNOT_WRITE_PC);

  displaced_write_reg (regs, dsc, dsc->rd, rd_val, ALU_WRITE_PC);
}

static void
install_alu_reg (struct gdbarch *gdbarch, struct regcache *regs,
		 struct displaced_step_closure *dsc,
		 unsigned int rd, unsigned int rn, unsigned int rm)
{
  ULONGEST rd_val, rn_val, rm_val;

  /* Instruction is of form:

     <op><cond> rd, [rn,] rm [, <shift>]

     Rewrite as:

     Preparation: tmp1, tmp2, tmp3 <- r0, r1, r2;
		  r0, r1, r2 <- rd, rn, rm
     Insn: <op><cond> r0, r1, r2 [, <shift>]
     Cleanup: rd <- r0; r0, r1, r2 <- tmp1, tmp2, tmp3
  */

  dsc->tmp[0] = displaced_read_reg (regs, dsc, 0);
  dsc->tmp[1] = displaced_read_reg (regs, dsc, 1);
  dsc->tmp[2] = displaced_read_reg (regs, dsc, 2);
  rd_val = displaced_read_reg (regs, dsc, rd);
  rn_val = displaced_read_reg (regs, dsc, rn);
  rm_val = displaced_read_reg (regs, dsc, rm);
  displaced_write_reg (regs, dsc, 0, rd_val, CANNOT_WRITE_PC);
  displaced_write_reg (regs, dsc, 1, rn_val, CANNOT_WRITE_PC);
  displaced_write_reg (regs, dsc, 2, rm_val, CANNOT_WRITE_PC);
  dsc->rd = rd;

  dsc->cleanup = &cleanup_alu_reg;
}

static int
arm_copy_alu_reg (struct gdbarch *gdbarch, uint32_t insn, struct regcache *regs,
		  struct displaced_step_closure *dsc)
{
  unsigned int op = bits (insn, 21, 24);
  int is_mov = (op == 0xd);

  if (!insn_references_pc (insn, 0x000ff00ful))
    return arm_copy_unmodified (gdbarch, insn, "ALU reg", dsc);

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: copying reg %s insn %.8lx\n",
			is_mov ? "move" : "ALU", (unsigned long) insn);

  if (is_mov)
    dsc->modinsn[0] = (insn & 0xfff00ff0) | 0x2;
  else
    dsc->modinsn[0] = (insn & 0xfff00ff0) | 0x10002;

  install_alu_reg (gdbarch, regs, dsc, bits (insn, 12, 15), bits (insn, 16, 19),
		   bits (insn, 0, 3));
  return 0;
}

static int
thumb_copy_alu_reg (struct gdbarch *gdbarch, uint16_t insn,
		    struct regcache *regs,
		    struct displaced_step_closure *dsc)
{
  unsigned rn, rm, rd;

  rd = bits (insn, 3, 6);
  rn = (bit (insn, 7) << 3) | bits (insn, 0, 2);
  rm = 2;

  if (rd != ARM_PC_REGNUM && rn != ARM_PC_REGNUM)
    return thumb_copy_unmodified_16bit (gdbarch, insn, "ALU reg", dsc);

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: copying reg %s insn %.4x\n",
			"ALU", (unsigned short) insn);

  dsc->modinsn[0] = ((insn & 0xff00) | 0x08);

  install_alu_reg (gdbarch, regs, dsc, rd, rn, rm);

  return 0;
}

/* Cleanup/copy arithmetic/logic insns with shifted register RHS.  */

static void
cleanup_alu_shifted_reg (struct gdbarch *gdbarch,
			 struct regcache *regs,
			 struct displaced_step_closure *dsc)
{
  ULONGEST rd_val = displaced_read_reg (regs, dsc, 0);
  int i;

  for (i = 0; i < 4; i++)
    displaced_write_reg (regs, dsc, i, dsc->tmp[i], CANNOT_WRITE_PC);

  displaced_write_reg (regs, dsc, dsc->rd, rd_val, ALU_WRITE_PC);
}

static void
install_alu_shifted_reg (struct gdbarch *gdbarch, struct regcache *regs,
			 struct displaced_step_closure *dsc,
			 unsigned int rd, unsigned int rn, unsigned int rm,
			 unsigned rs)
{
  int i;
  ULONGEST rd_val, rn_val, rm_val, rs_val;

  /* Instruction is of form:

     <op><cond> rd, [rn,] rm, <shift> rs

     Rewrite as:

     Preparation: tmp1, tmp2, tmp3, tmp4 <- r0, r1, r2, r3
		  r0, r1, r2, r3 <- rd, rn, rm, rs
     Insn: <op><cond> r0, r1, r2, <shift> r3
     Cleanup: tmp5 <- r0
	      r0, r1, r2, r3 <- tmp1, tmp2, tmp3, tmp4
	      rd <- tmp5
  */

  for (i = 0; i < 4; i++)
    dsc->tmp[i] = displaced_read_reg (regs, dsc, i);

  rd_val = displaced_read_reg (regs, dsc, rd);
  rn_val = displaced_read_reg (regs, dsc, rn);
  rm_val = displaced_read_reg (regs, dsc, rm);
  rs_val = displaced_read_reg (regs, dsc, rs);
  displaced_write_reg (regs, dsc, 0, rd_val, CANNOT_WRITE_PC);
  displaced_write_reg (regs, dsc, 1, rn_val, CANNOT_WRITE_PC);
  displaced_write_reg (regs, dsc, 2, rm_val, CANNOT_WRITE_PC);
  displaced_write_reg (regs, dsc, 3, rs_val, CANNOT_WRITE_PC);
  dsc->rd = rd;
  dsc->cleanup = &cleanup_alu_shifted_reg;
}

static int
arm_copy_alu_shifted_reg (struct gdbarch *gdbarch, uint32_t insn,
			  struct regcache *regs,
			  struct displaced_step_closure *dsc)
{
  unsigned int op = bits (insn, 21, 24);
  int is_mov = (op == 0xd);
  unsigned int rd, rn, rm, rs;

  if (!insn_references_pc (insn, 0x000fff0ful))
    return arm_copy_unmodified (gdbarch, insn, "ALU shifted reg", dsc);

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: copying shifted reg %s insn "
			"%.8lx\n", is_mov ? "move" : "ALU",
			(unsigned long) insn);

  rn = bits (insn, 16, 19);
  rm = bits (insn, 0, 3);
  rs = bits (insn, 8, 11);
  rd = bits (insn, 12, 15);

  if (is_mov)
    dsc->modinsn[0] = (insn & 0xfff000f0) | 0x302;
  else
    dsc->modinsn[0] = (insn & 0xfff000f0) | 0x10302;

  install_alu_shifted_reg (gdbarch, regs, dsc, rd, rn, rm, rs);

  return 0;
}

/* Clean up load instructions.  */

static void
cleanup_load (struct gdbarch *gdbarch, struct regcache *regs,
	      struct displaced_step_closure *dsc)
{
  ULONGEST rt_val, rt_val2 = 0, rn_val;

  rt_val = displaced_read_reg (regs, dsc, 0);
  if (dsc->u.ldst.xfersize == 8)
    rt_val2 = displaced_read_reg (regs, dsc, 1);
  rn_val = displaced_read_reg (regs, dsc, 2);

  displaced_write_reg (regs, dsc, 0, dsc->tmp[0], CANNOT_WRITE_PC);
  if (dsc->u.ldst.xfersize > 4)
    displaced_write_reg (regs, dsc, 1, dsc->tmp[1], CANNOT_WRITE_PC);
  displaced_write_reg (regs, dsc, 2, dsc->tmp[2], CANNOT_WRITE_PC);
  if (!dsc->u.ldst.immed)
    displaced_write_reg (regs, dsc, 3, dsc->tmp[3], CANNOT_WRITE_PC);

  /* Handle register writeback.  */
  if (dsc->u.ldst.writeback)
    displaced_write_reg (regs, dsc, dsc->u.ldst.rn, rn_val, CANNOT_WRITE_PC);
  /* Put result in right place.  */
  displaced_write_reg (regs, dsc, dsc->rd, rt_val, LOAD_WRITE_PC);
  if (dsc->u.ldst.xfersize == 8)
    displaced_write_reg (regs, dsc, dsc->rd + 1, rt_val2, LOAD_WRITE_PC);
}

/* Clean up store instructions.  */

static void
cleanup_store (struct gdbarch *gdbarch, struct regcache *regs,
	       struct displaced_step_closure *dsc)
{
  ULONGEST rn_val = displaced_read_reg (regs, dsc, 2);

  displaced_write_reg (regs, dsc, 0, dsc->tmp[0], CANNOT_WRITE_PC);
  if (dsc->u.ldst.xfersize > 4)
    displaced_write_reg (regs, dsc, 1, dsc->tmp[1], CANNOT_WRITE_PC);
  displaced_write_reg (regs, dsc, 2, dsc->tmp[2], CANNOT_WRITE_PC);
  if (!dsc->u.ldst.immed)
    displaced_write_reg (regs, dsc, 3, dsc->tmp[3], CANNOT_WRITE_PC);
  if (!dsc->u.ldst.restore_r4)
    displaced_write_reg (regs, dsc, 4, dsc->tmp[4], CANNOT_WRITE_PC);

  /* Writeback.  */
  if (dsc->u.ldst.writeback)
    displaced_write_reg (regs, dsc, dsc->u.ldst.rn, rn_val, CANNOT_WRITE_PC);
}

/* Copy "extra" load/store instructions.  These are halfword/doubleword
   transfers, which have a different encoding to byte/word transfers.  */

static int
arm_copy_extra_ld_st (struct gdbarch *gdbarch, uint32_t insn, int unpriveleged,
		      struct regcache *regs, struct displaced_step_closure *dsc)
{
  unsigned int op1 = bits (insn, 20, 24);
  unsigned int op2 = bits (insn, 5, 6);
  unsigned int rt = bits (insn, 12, 15);
  unsigned int rn = bits (insn, 16, 19);
  unsigned int rm = bits (insn, 0, 3);
  char load[12]     = {0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1};
  char bytesize[12] = {2, 2, 2, 2, 8, 1, 8, 1, 8, 2, 8, 2};
  int immed = (op1 & 0x4) != 0;
  int opcode;
  ULONGEST rt_val, rt_val2 = 0, rn_val, rm_val = 0;

  if (!insn_references_pc (insn, 0x000ff00ful))
    return arm_copy_unmodified (gdbarch, insn, "extra load/store", dsc);

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: copying %sextra load/store "
			"insn %.8lx\n", unpriveleged ? "unpriveleged " : "",
			(unsigned long) insn);

  opcode = ((op2 << 2) | (op1 & 0x1) | ((op1 & 0x4) >> 1)) - 4;

  if (opcode < 0)
    internal_error (__FILE__, __LINE__,
		    _("copy_extra_ld_st: instruction decode error"));

  dsc->tmp[0] = displaced_read_reg (regs, dsc, 0);
  dsc->tmp[1] = displaced_read_reg (regs, dsc, 1);
  dsc->tmp[2] = displaced_read_reg (regs, dsc, 2);
  if (!immed)
    dsc->tmp[3] = displaced_read_reg (regs, dsc, 3);

  rt_val = displaced_read_reg (regs, dsc, rt);
  if (bytesize[opcode] == 8)
    rt_val2 = displaced_read_reg (regs, dsc, rt + 1);
  rn_val = displaced_read_reg (regs, dsc, rn);
  if (!immed)
    rm_val = displaced_read_reg (regs, dsc, rm);

  displaced_write_reg (regs, dsc, 0, rt_val, CANNOT_WRITE_PC);
  if (bytesize[opcode] == 8)
    displaced_write_reg (regs, dsc, 1, rt_val2, CANNOT_WRITE_PC);
  displaced_write_reg (regs, dsc, 2, rn_val, CANNOT_WRITE_PC);
  if (!immed)
    displaced_write_reg (regs, dsc, 3, rm_val, CANNOT_WRITE_PC);

  dsc->rd = rt;
  dsc->u.ldst.xfersize = bytesize[opcode];
  dsc->u.ldst.rn = rn;
  dsc->u.ldst.immed = immed;
  dsc->u.ldst.writeback = bit (insn, 24) == 0 || bit (insn, 21) != 0;
  dsc->u.ldst.restore_r4 = 0;

  if (immed)
    /* {ldr,str}<width><cond> rt, [rt2,] [rn, #imm]
	->
       {ldr,str}<width><cond> r0, [r1,] [r2, #imm].  */
    dsc->modinsn[0] = (insn & 0xfff00fff) | 0x20000;
  else
    /* {ldr,str}<width><cond> rt, [rt2,] [rn, +/-rm]
	->
       {ldr,str}<width><cond> r0, [r1,] [r2, +/-r3].  */
    dsc->modinsn[0] = (insn & 0xfff00ff0) | 0x20003;

  dsc->cleanup = load[opcode] ? &cleanup_load : &cleanup_store;

  return 0;
}

/* Copy byte/half word/word loads and stores.  */

static void
install_load_store (struct gdbarch *gdbarch, struct regcache *regs,
		    struct displaced_step_closure *dsc, int load,
		    int immed, int writeback, int size, int usermode,
		    int rt, int rm, int rn)
{
  ULONGEST rt_val, rn_val, rm_val = 0;

  dsc->tmp[0] = displaced_read_reg (regs, dsc, 0);
  dsc->tmp[2] = displaced_read_reg (regs, dsc, 2);
  if (!immed)
    dsc->tmp[3] = displaced_read_reg (regs, dsc, 3);
  if (!load)
    dsc->tmp[4] = displaced_read_reg (regs, dsc, 4);

  rt_val = displaced_read_reg (regs, dsc, rt);
  rn_val = displaced_read_reg (regs, dsc, rn);
  if (!immed)
    rm_val = displaced_read_reg (regs, dsc, rm);

  displaced_write_reg (regs, dsc, 0, rt_val, CANNOT_WRITE_PC);
  displaced_write_reg (regs, dsc, 2, rn_val, CANNOT_WRITE_PC);
  if (!immed)
    displaced_write_reg (regs, dsc, 3, rm_val, CANNOT_WRITE_PC);
  dsc->rd = rt;
  dsc->u.ldst.xfersize = size;
  dsc->u.ldst.rn = rn;
  dsc->u.ldst.immed = immed;
  dsc->u.ldst.writeback = writeback;

  /* To write PC we can do:

     Before this sequence of instructions:
     r0 is the PC value got from displaced_read_reg, so r0 = from + 8;
     r2 is the Rn value got from dispalced_read_reg.

     Insn1: push {pc} Write address of STR instruction + offset on stack
     Insn2: pop  {r4} Read it back from stack, r4 = addr(Insn1) + offset
     Insn3: sub r4, r4, pc   r4 = addr(Insn1) + offset - pc
                                = addr(Insn1) + offset - addr(Insn3) - 8
                                = offset - 16
     Insn4: add r4, r4, #8   r4 = offset - 8
     Insn5: add r0, r0, r4   r0 = from + 8 + offset - 8
                                = from + offset
     Insn6: str r0, [r2, #imm] (or str r0, [r2, r3])

     Otherwise we don't know what value to write for PC, since the offset is
     architecture-dependent (sometimes PC+8, sometimes PC+12).  More details
     of this can be found in Section "Saving from r15" in
     http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0204g/Cihbjifh.html */

  dsc->cleanup = load ? &cleanup_load : &cleanup_store;
}


static int
thumb2_copy_load_literal (struct gdbarch *gdbarch, uint16_t insn1,
			  uint16_t insn2, struct regcache *regs,
			  struct displaced_step_closure *dsc, int size)
{
  unsigned int u_bit = bit (insn1, 7);
  unsigned int rt = bits (insn2, 12, 15);
  int imm12 = bits (insn2, 0, 11);
  ULONGEST pc_val;

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog,
			"displaced: copying ldr pc (0x%x) R%d %c imm12 %.4x\n",
			(unsigned int) dsc->insn_addr, rt, u_bit ? '+' : '-',
			imm12);

  if (!u_bit)
    imm12 = -1 * imm12;

  /* Rewrite instruction LDR Rt imm12 into:

     Prepare: tmp[0] <- r0, tmp[1] <- r2, tmp[2] <- r3, r2 <- pc, r3 <- imm12

     LDR R0, R2, R3,

     Cleanup: rt <- r0, r0 <- tmp[0], r2 <- tmp[1], r3 <- tmp[2].  */


  dsc->tmp[0] = displaced_read_reg (regs, dsc, 0);
  dsc->tmp[2] = displaced_read_reg (regs, dsc, 2);
  dsc->tmp[3] = displaced_read_reg (regs, dsc, 3);

  pc_val = displaced_read_reg (regs, dsc, ARM_PC_REGNUM);

  pc_val = pc_val & 0xfffffffc;

  displaced_write_reg (regs, dsc, 2, pc_val, CANNOT_WRITE_PC);
  displaced_write_reg (regs, dsc, 3, imm12, CANNOT_WRITE_PC);

  dsc->rd = rt;

  dsc->u.ldst.xfersize = size;
  dsc->u.ldst.immed = 0;
  dsc->u.ldst.writeback = 0;
  dsc->u.ldst.restore_r4 = 0;

  /* LDR R0, R2, R3 */
  dsc->modinsn[0] = 0xf852;
  dsc->modinsn[1] = 0x3;
  dsc->numinsns = 2;

  dsc->cleanup = &cleanup_load;

  return 0;
}

static int
thumb2_copy_load_reg_imm (struct gdbarch *gdbarch, uint16_t insn1,
			  uint16_t insn2, struct regcache *regs,
			  struct displaced_step_closure *dsc,
			  int writeback, int immed)
{
  unsigned int rt = bits (insn2, 12, 15);
  unsigned int rn = bits (insn1, 0, 3);
  unsigned int rm = bits (insn2, 0, 3);  /* Only valid if !immed.  */
  /* In LDR (register), there is also a register Rm, which is not allowed to
     be PC, so we don't have to check it.  */

  if (rt != ARM_PC_REGNUM && rn != ARM_PC_REGNUM)
    return thumb_copy_unmodified_32bit (gdbarch, insn1, insn2, "load",
					dsc);

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog,
			"displaced: copying ldr r%d [r%d] insn %.4x%.4x\n",
			 rt, rn, insn1, insn2);

  install_load_store (gdbarch, regs, dsc, 1, immed, writeback, 4,
		      0, rt, rm, rn);

  dsc->u.ldst.restore_r4 = 0;

  if (immed)
    /* ldr[b]<cond> rt, [rn, #imm], etc.
       ->
       ldr[b]<cond> r0, [r2, #imm].  */
    {
      dsc->modinsn[0] = (insn1 & 0xfff0) | 0x2;
      dsc->modinsn[1] = insn2 & 0x0fff;
    }
  else
    /* ldr[b]<cond> rt, [rn, rm], etc.
       ->
       ldr[b]<cond> r0, [r2, r3].  */
    {
      dsc->modinsn[0] = (insn1 & 0xfff0) | 0x2;
      dsc->modinsn[1] = (insn2 & 0x0ff0) | 0x3;
    }

  dsc->numinsns = 2;

  return 0;
}


static int
arm_copy_ldr_str_ldrb_strb (struct gdbarch *gdbarch, uint32_t insn,
			    struct regcache *regs,
			    struct displaced_step_closure *dsc,
			    int load, int size, int usermode)
{
  int immed = !bit (insn, 25);
  int writeback = (bit (insn, 24) == 0 || bit (insn, 21) != 0);
  unsigned int rt = bits (insn, 12, 15);
  unsigned int rn = bits (insn, 16, 19);
  unsigned int rm = bits (insn, 0, 3);  /* Only valid if !immed.  */

  if (!insn_references_pc (insn, 0x000ff00ful))
    return arm_copy_unmodified (gdbarch, insn, "load/store", dsc);

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog,
			"displaced: copying %s%s r%d [r%d] insn %.8lx\n",
			load ? (size == 1 ? "ldrb" : "ldr")
			     : (size == 1 ? "strb" : "str"), usermode ? "t" : "",
			rt, rn,
			(unsigned long) insn);

  install_load_store (gdbarch, regs, dsc, load, immed, writeback, size,
		      usermode, rt, rm, rn);

  if (load || rt != ARM_PC_REGNUM)
    {
      dsc->u.ldst.restore_r4 = 0;

      if (immed)
	/* {ldr,str}[b]<cond> rt, [rn, #imm], etc.
	   ->
	   {ldr,str}[b]<cond> r0, [r2, #imm].  */
	dsc->modinsn[0] = (insn & 0xfff00fff) | 0x20000;
      else
	/* {ldr,str}[b]<cond> rt, [rn, rm], etc.
	   ->
	   {ldr,str}[b]<cond> r0, [r2, r3].  */
	dsc->modinsn[0] = (insn & 0xfff00ff0) | 0x20003;
    }
  else
    {
      /* We need to use r4 as scratch.  Make sure it's restored afterwards.  */
      dsc->u.ldst.restore_r4 = 1;
      dsc->modinsn[0] = 0xe92d8000;  /* push {pc} */
      dsc->modinsn[1] = 0xe8bd0010;  /* pop  {r4} */
      dsc->modinsn[2] = 0xe044400f;  /* sub r4, r4, pc.  */
      dsc->modinsn[3] = 0xe2844008;  /* add r4, r4, #8.  */
      dsc->modinsn[4] = 0xe0800004;  /* add r0, r0, r4.  */

      /* As above.  */
      if (immed)
	dsc->modinsn[5] = (insn & 0xfff00fff) | 0x20000;
      else
	dsc->modinsn[5] = (insn & 0xfff00ff0) | 0x20003;

      dsc->numinsns = 6;
    }

  dsc->cleanup = load ? &cleanup_load : &cleanup_store;

  return 0;
}

/* Cleanup LDM instructions with fully-populated register list.  This is an
   unfortunate corner case: it's impossible to implement correctly by modifying
   the instruction.  The issue is as follows: we have an instruction,

   ldm rN, {r0-r15}

   which we must rewrite to avoid loading PC.  A possible solution would be to
   do the load in two halves, something like (with suitable cleanup
   afterwards):

   mov r8, rN
   ldm[id][ab] r8!, {r0-r7}
   str r7, <temp>
   ldm[id][ab] r8, {r7-r14}
   <bkpt>

   but at present there's no suitable place for <temp>, since the scratch space
   is overwritten before the cleanup routine is called.  For now, we simply
   emulate the instruction.  */

static void
cleanup_block_load_all (struct gdbarch *gdbarch, struct regcache *regs,
			struct displaced_step_closure *dsc)
{
  int inc = dsc->u.block.increment;
  int bump_before = dsc->u.block.before ? (inc ? 4 : -4) : 0;
  int bump_after = dsc->u.block.before ? 0 : (inc ? 4 : -4);
  uint32_t regmask = dsc->u.block.regmask;
  int regno = inc ? 0 : 15;
  CORE_ADDR xfer_addr = dsc->u.block.xfer_addr;
  int exception_return = dsc->u.block.load && dsc->u.block.user
			 && (regmask & 0x8000) != 0;
  uint32_t status = displaced_read_reg (regs, dsc, ARM_PS_REGNUM);
  int do_transfer = condition_true (dsc->u.block.cond, status);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);

  if (!do_transfer)
    return;

  /* If the instruction is ldm rN, {...pc}^, I don't think there's anything
     sensible we can do here.  Complain loudly.  */
  if (exception_return)
    error (_("Cannot single-step exception return"));

  /* We don't handle any stores here for now.  */
  gdb_assert (dsc->u.block.load != 0);

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: emulating block transfer: "
			"%s %s %s\n", dsc->u.block.load ? "ldm" : "stm",
			dsc->u.block.increment ? "inc" : "dec",
			dsc->u.block.before ? "before" : "after");

  while (regmask)
    {
      uint32_t memword;

      if (inc)
	while (regno <= ARM_PC_REGNUM && (regmask & (1 << regno)) == 0)
	  regno++;
      else
	while (regno >= 0 && (regmask & (1 << regno)) == 0)
	  regno--;

      xfer_addr += bump_before;

      memword = read_memory_unsigned_integer (xfer_addr, 4, byte_order);
      displaced_write_reg (regs, dsc, regno, memword, LOAD_WRITE_PC);

      xfer_addr += bump_after;

      regmask &= ~(1 << regno);
    }

  if (dsc->u.block.writeback)
    displaced_write_reg (regs, dsc, dsc->u.block.rn, xfer_addr,
			 CANNOT_WRITE_PC);
}

/* Clean up an STM which included the PC in the register list.  */

static void
cleanup_block_store_pc (struct gdbarch *gdbarch, struct regcache *regs,
			struct displaced_step_closure *dsc)
{
  uint32_t status = displaced_read_reg (regs, dsc, ARM_PS_REGNUM);
  int store_executed = condition_true (dsc->u.block.cond, status);
  CORE_ADDR pc_stored_at, transferred_regs = bitcount (dsc->u.block.regmask);
  CORE_ADDR stm_insn_addr;
  uint32_t pc_val;
  long offset;
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);

  /* If condition code fails, there's nothing else to do.  */
  if (!store_executed)
    return;

  if (dsc->u.block.increment)
    {
      pc_stored_at = dsc->u.block.xfer_addr + 4 * transferred_regs;

      if (dsc->u.block.before)
	 pc_stored_at += 4;
    }
  else
    {
      pc_stored_at = dsc->u.block.xfer_addr;

      if (dsc->u.block.before)
	 pc_stored_at -= 4;
    }

  pc_val = read_memory_unsigned_integer (pc_stored_at, 4, byte_order);
  stm_insn_addr = dsc->scratch_base;
  offset = pc_val - stm_insn_addr;

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: detected PC offset %.8lx for "
			"STM instruction\n", offset);

  /* Rewrite the stored PC to the proper value for the non-displaced original
     instruction.  */
  write_memory_unsigned_integer (pc_stored_at, 4, byte_order,
				 dsc->insn_addr + offset);
}

/* Clean up an LDM which includes the PC in the register list.  We clumped all
   the registers in the transferred list into a contiguous range r0...rX (to
   avoid loading PC directly and losing control of the debugged program), so we
   must undo that here.  */

static void
cleanup_block_load_pc (struct gdbarch *gdbarch,
		       struct regcache *regs,
		       struct displaced_step_closure *dsc)
{
  uint32_t status = displaced_read_reg (regs, dsc, ARM_PS_REGNUM);
  int load_executed = condition_true (dsc->u.block.cond, status);
  unsigned int mask = dsc->u.block.regmask, write_reg = ARM_PC_REGNUM;
  unsigned int regs_loaded = bitcount (mask);
  unsigned int num_to_shuffle = regs_loaded, clobbered;

  /* The method employed here will fail if the register list is fully populated
     (we need to avoid loading PC directly).  */
  gdb_assert (num_to_shuffle < 16);

  if (!load_executed)
    return;

  clobbered = (1 << num_to_shuffle) - 1;

  while (num_to_shuffle > 0)
    {
      if ((mask & (1 << write_reg)) != 0)
	{
	  unsigned int read_reg = num_to_shuffle - 1;

	  if (read_reg != write_reg)
	    {
	      ULONGEST rval = displaced_read_reg (regs, dsc, read_reg);
	      displaced_write_reg (regs, dsc, write_reg, rval, LOAD_WRITE_PC);
	      if (debug_displaced)
		fprintf_unfiltered (gdb_stdlog, _("displaced: LDM: move "
				    "loaded register r%d to r%d\n"), read_reg,
				    write_reg);
	    }
	  else if (debug_displaced)
	    fprintf_unfiltered (gdb_stdlog, _("displaced: LDM: register "
				"r%d already in the right place\n"),
				write_reg);

	  clobbered &= ~(1 << write_reg);

	  num_to_shuffle--;
	}

      write_reg--;
    }

  /* Restore any registers we scribbled over.  */
  for (write_reg = 0; clobbered != 0; write_reg++)
    {
      if ((clobbered & (1 << write_reg)) != 0)
	{
	  displaced_write_reg (regs, dsc, write_reg, dsc->tmp[write_reg],
			       CANNOT_WRITE_PC);
	  if (debug_displaced)
	    fprintf_unfiltered (gdb_stdlog, _("displaced: LDM: restored "
				"clobbered register r%d\n"), write_reg);
	  clobbered &= ~(1 << write_reg);
	}
    }

  /* Perform register writeback manually.  */
  if (dsc->u.block.writeback)
    {
      ULONGEST new_rn_val = dsc->u.block.xfer_addr;

      if (dsc->u.block.increment)
	new_rn_val += regs_loaded * 4;
      else
	new_rn_val -= regs_loaded * 4;

      displaced_write_reg (regs, dsc, dsc->u.block.rn, new_rn_val,
			   CANNOT_WRITE_PC);
    }
}

/* Handle ldm/stm, apart from some tricky cases which are unlikely to occur
   in user-level code (in particular exception return, ldm rn, {...pc}^).  */

static int
arm_copy_block_xfer (struct gdbarch *gdbarch, uint32_t insn,
		     struct regcache *regs,
		     struct displaced_step_closure *dsc)
{
  int load = bit (insn, 20);
  int user = bit (insn, 22);
  int increment = bit (insn, 23);
  int before = bit (insn, 24);
  int writeback = bit (insn, 21);
  int rn = bits (insn, 16, 19);

  /* Block transfers which don't mention PC can be run directly
     out-of-line.  */
  if (rn != ARM_PC_REGNUM && (insn & 0x8000) == 0)
    return arm_copy_unmodified (gdbarch, insn, "ldm/stm", dsc);

  if (rn == ARM_PC_REGNUM)
    {
      warning (_("displaced: Unpredictable LDM or STM with "
		 "base register r15"));
      return arm_copy_unmodified (gdbarch, insn, "unpredictable ldm/stm", dsc);
    }

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: copying block transfer insn "
			"%.8lx\n", (unsigned long) insn);

  dsc->u.block.xfer_addr = displaced_read_reg (regs, dsc, rn);
  dsc->u.block.rn = rn;

  dsc->u.block.load = load;
  dsc->u.block.user = user;
  dsc->u.block.increment = increment;
  dsc->u.block.before = before;
  dsc->u.block.writeback = writeback;
  dsc->u.block.cond = bits (insn, 28, 31);

  dsc->u.block.regmask = insn & 0xffff;

  if (load)
    {
      if ((insn & 0xffff) == 0xffff)
	{
	  /* LDM with a fully-populated register list.  This case is
	     particularly tricky.  Implement for now by fully emulating the
	     instruction (which might not behave perfectly in all cases, but
	     these instructions should be rare enough for that not to matter
	     too much).  */
	  dsc->modinsn[0] = ARM_NOP;

	  dsc->cleanup = &cleanup_block_load_all;
	}
      else
	{
	  /* LDM of a list of registers which includes PC.  Implement by
	     rewriting the list of registers to be transferred into a
	     contiguous chunk r0...rX before doing the transfer, then shuffling
	     registers into the correct places in the cleanup routine.  */
	  unsigned int regmask = insn & 0xffff;
	  unsigned int num_in_list = bitcount (regmask), new_regmask, bit = 1;
	  unsigned int to = 0, from = 0, i, new_rn;

	  for (i = 0; i < num_in_list; i++)
	    dsc->tmp[i] = displaced_read_reg (regs, dsc, i);

	  /* Writeback makes things complicated.  We need to avoid clobbering
	     the base register with one of the registers in our modified
	     register list, but just using a different register can't work in
	     all cases, e.g.:

	       ldm r14!, {r0-r13,pc}

	     which would need to be rewritten as:

	       ldm rN!, {r0-r14}

	     but that can't work, because there's no free register for N.

	     Solve this by turning off the writeback bit, and emulating
	     writeback manually in the cleanup routine.  */

	  if (writeback)
	    insn &= ~(1 << 21);

	  new_regmask = (1 << num_in_list) - 1;

	  if (debug_displaced)
	    fprintf_unfiltered (gdb_stdlog, _("displaced: LDM r%d%s, "
				"{..., pc}: original reg list %.4x, modified "
				"list %.4x\n"), rn, writeback ? "!" : "",
				(int) insn & 0xffff, new_regmask);

	  dsc->modinsn[0] = (insn & ~0xffff) | (new_regmask & 0xffff);

	  dsc->cleanup = &cleanup_block_load_pc;
	}
    }
  else
    {
      /* STM of a list of registers which includes PC.  Run the instruction
	 as-is, but out of line: this will store the wrong value for the PC,
	 so we must manually fix up the memory in the cleanup routine.
	 Doing things this way has the advantage that we can auto-detect
	 the offset of the PC write (which is architecture-dependent) in
	 the cleanup routine.  */
      dsc->modinsn[0] = insn;

      dsc->cleanup = &cleanup_block_store_pc;
    }

  return 0;
}

static int
thumb2_copy_block_xfer (struct gdbarch *gdbarch, uint16_t insn1, uint16_t insn2,
			struct regcache *regs,
			struct displaced_step_closure *dsc)
{
  int rn = bits (insn1, 0, 3);
  int load = bit (insn1, 4);
  int writeback = bit (insn1, 5);

  /* Block transfers which don't mention PC can be run directly
     out-of-line.  */
  if (rn != ARM_PC_REGNUM && (insn2 & 0x8000) == 0)
    return thumb_copy_unmodified_32bit (gdbarch, insn1, insn2, "ldm/stm", dsc);

  if (rn == ARM_PC_REGNUM)
    {
      warning (_("displaced: Unpredictable LDM or STM with "
		 "base register r15"));
      return thumb_copy_unmodified_32bit (gdbarch, insn1, insn2,
					  "unpredictable ldm/stm", dsc);
    }

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: copying block transfer insn "
			"%.4x%.4x\n", insn1, insn2);

  /* Clear bit 13, since it should be always zero.  */
  dsc->u.block.regmask = (insn2 & 0xdfff);
  dsc->u.block.rn = rn;

  dsc->u.block.load = load;
  dsc->u.block.user = 0;
  dsc->u.block.increment = bit (insn1, 7);
  dsc->u.block.before = bit (insn1, 8);
  dsc->u.block.writeback = writeback;
  dsc->u.block.cond = INST_AL;
  dsc->u.block.xfer_addr = displaced_read_reg (regs, dsc, rn);

  if (load)
    {
      if (dsc->u.block.regmask == 0xffff)
	{
	  /* This branch is impossible to happen.  */
	  gdb_assert (0);
	}
      else
	{
	  unsigned int regmask = dsc->u.block.regmask;
	  unsigned int num_in_list = bitcount (regmask), new_regmask, bit = 1;
	  unsigned int to = 0, from = 0, i, new_rn;

	  for (i = 0; i < num_in_list; i++)
	    dsc->tmp[i] = displaced_read_reg (regs, dsc, i);

	  if (writeback)
	    insn1 &= ~(1 << 5);

	  new_regmask = (1 << num_in_list) - 1;

	  if (debug_displaced)
	    fprintf_unfiltered (gdb_stdlog, _("displaced: LDM r%d%s, "
				"{..., pc}: original reg list %.4x, modified "
				"list %.4x\n"), rn, writeback ? "!" : "",
				(int) dsc->u.block.regmask, new_regmask);

	  dsc->modinsn[0] = insn1;
	  dsc->modinsn[1] = (new_regmask & 0xffff);
	  dsc->numinsns = 2;

	  dsc->cleanup = &cleanup_block_load_pc;
	}
    }
  else
    {
      dsc->modinsn[0] = insn1;
      dsc->modinsn[1] = insn2;
      dsc->numinsns = 2;
      dsc->cleanup = &cleanup_block_store_pc;
    }
  return 0;
}

/* Cleanup/copy SVC (SWI) instructions.  These two functions are overridden
   for Linux, where some SVC instructions must be treated specially.  */

static void
cleanup_svc (struct gdbarch *gdbarch, struct regcache *regs,
	     struct displaced_step_closure *dsc)
{
  CORE_ADDR resume_addr = dsc->insn_addr + dsc->insn_size;

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: cleanup for svc, resume at "
			"%.8lx\n", (unsigned long) resume_addr);

  displaced_write_reg (regs, dsc, ARM_PC_REGNUM, resume_addr, BRANCH_WRITE_PC);
}


/* Common copy routine for svc instruciton.  */

static int
install_svc (struct gdbarch *gdbarch, struct regcache *regs,
	     struct displaced_step_closure *dsc)
{
  /* Preparation: none.
     Insn: unmodified svc.
     Cleanup: pc <- insn_addr + insn_size.  */

  /* Pretend we wrote to the PC, so cleanup doesn't set PC to the next
     instruction.  */
  dsc->wrote_to_pc = 1;

  /* Allow OS-specific code to override SVC handling.  */
  if (dsc->u.svc.copy_svc_os)
    return dsc->u.svc.copy_svc_os (gdbarch, regs, dsc);
  else
    {
      dsc->cleanup = &cleanup_svc;
      return 0;
    }
}

static int
arm_copy_svc (struct gdbarch *gdbarch, uint32_t insn,
	      struct regcache *regs, struct displaced_step_closure *dsc)
{

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: copying svc insn %.8lx\n",
			(unsigned long) insn);

  dsc->modinsn[0] = insn;

  return install_svc (gdbarch, regs, dsc);
}

static int
thumb_copy_svc (struct gdbarch *gdbarch, uint16_t insn,
		struct regcache *regs, struct displaced_step_closure *dsc)
{

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: copying svc insn %.4x\n",
			insn);

  dsc->modinsn[0] = insn;

  return install_svc (gdbarch, regs, dsc);
}

/* Copy undefined instructions.  */

static int
arm_copy_undef (struct gdbarch *gdbarch, uint32_t insn,
		struct displaced_step_closure *dsc)
{
  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog,
			"displaced: copying undefined insn %.8lx\n",
			(unsigned long) insn);

  dsc->modinsn[0] = insn;

  return 0;
}

static int
thumb_32bit_copy_undef (struct gdbarch *gdbarch, uint16_t insn1, uint16_t insn2,
                       struct displaced_step_closure *dsc)
{

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: copying undefined insn "
                       "%.4x %.4x\n", (unsigned short) insn1,
                       (unsigned short) insn2);

  dsc->modinsn[0] = insn1;
  dsc->modinsn[1] = insn2;
  dsc->numinsns = 2;

  return 0;
}

/* Copy unpredictable instructions.  */

static int
arm_copy_unpred (struct gdbarch *gdbarch, uint32_t insn,
		 struct displaced_step_closure *dsc)
{
  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: copying unpredictable insn "
			"%.8lx\n", (unsigned long) insn);

  dsc->modinsn[0] = insn;

  return 0;
}

/* The decode_* functions are instruction decoding helpers.  They mostly follow
   the presentation in the ARM ARM.  */

static int
arm_decode_misc_memhint_neon (struct gdbarch *gdbarch, uint32_t insn,
			      struct regcache *regs,
			      struct displaced_step_closure *dsc)
{
  unsigned int op1 = bits (insn, 20, 26), op2 = bits (insn, 4, 7);
  unsigned int rn = bits (insn, 16, 19);

  if (op1 == 0x10 && (op2 & 0x2) == 0x0 && (rn & 0xe) == 0x0)
    return arm_copy_unmodified (gdbarch, insn, "cps", dsc);
  else if (op1 == 0x10 && op2 == 0x0 && (rn & 0xe) == 0x1)
    return arm_copy_unmodified (gdbarch, insn, "setend", dsc);
  else if ((op1 & 0x60) == 0x20)
    return arm_copy_unmodified (gdbarch, insn, "neon dataproc", dsc);
  else if ((op1 & 0x71) == 0x40)
    return arm_copy_unmodified (gdbarch, insn, "neon elt/struct load/store",
				dsc);
  else if ((op1 & 0x77) == 0x41)
    return arm_copy_unmodified (gdbarch, insn, "unallocated mem hint", dsc);
  else if ((op1 & 0x77) == 0x45)
    return arm_copy_preload (gdbarch, insn, regs, dsc);  /* pli.  */
  else if ((op1 & 0x77) == 0x51)
    {
      if (rn != 0xf)
	return arm_copy_preload (gdbarch, insn, regs, dsc);  /* pld/pldw.  */
      else
	return arm_copy_unpred (gdbarch, insn, dsc);
    }
  else if ((op1 & 0x77) == 0x55)
    return arm_copy_preload (gdbarch, insn, regs, dsc);  /* pld/pldw.  */
  else if (op1 == 0x57)
    switch (op2)
      {
      case 0x1: return arm_copy_unmodified (gdbarch, insn, "clrex", dsc);
      case 0x4: return arm_copy_unmodified (gdbarch, insn, "dsb", dsc);
      case 0x5: return arm_copy_unmodified (gdbarch, insn, "dmb", dsc);
      case 0x6: return arm_copy_unmodified (gdbarch, insn, "isb", dsc);
      default: return arm_copy_unpred (gdbarch, insn, dsc);
      }
  else if ((op1 & 0x63) == 0x43)
    return arm_copy_unpred (gdbarch, insn, dsc);
  else if ((op2 & 0x1) == 0x0)
    switch (op1 & ~0x80)
      {
      case 0x61:
	return arm_copy_unmodified (gdbarch, insn, "unallocated mem hint", dsc);
      case 0x65:
	return arm_copy_preload_reg (gdbarch, insn, regs, dsc);  /* pli reg.  */
      case 0x71: case 0x75:
        /* pld/pldw reg.  */
	return arm_copy_preload_reg (gdbarch, insn, regs, dsc);
      case 0x63: case 0x67: case 0x73: case 0x77:
	return arm_copy_unpred (gdbarch, insn, dsc);
      default:
	return arm_copy_undef (gdbarch, insn, dsc);
      }
  else
    return arm_copy_undef (gdbarch, insn, dsc);  /* Probably unreachable.  */
}

static int
arm_decode_unconditional (struct gdbarch *gdbarch, uint32_t insn,
			  struct regcache *regs,
			  struct displaced_step_closure *dsc)
{
  if (bit (insn, 27) == 0)
    return arm_decode_misc_memhint_neon (gdbarch, insn, regs, dsc);
  /* Switch on bits: 0bxxxxx321xxx0xxxxxxxxxxxxxxxxxxxx.  */
  else switch (((insn & 0x7000000) >> 23) | ((insn & 0x100000) >> 20))
    {
    case 0x0: case 0x2:
      return arm_copy_unmodified (gdbarch, insn, "srs", dsc);

    case 0x1: case 0x3:
      return arm_copy_unmodified (gdbarch, insn, "rfe", dsc);

    case 0x4: case 0x5: case 0x6: case 0x7:
      return arm_copy_b_bl_blx (gdbarch, insn, regs, dsc);

    case 0x8:
      switch ((insn & 0xe00000) >> 21)
	{
	case 0x1: case 0x3: case 0x4: case 0x5: case 0x6: case 0x7:
	  /* stc/stc2.  */
	  return arm_copy_copro_load_store (gdbarch, insn, regs, dsc);

	case 0x2:
	  return arm_copy_unmodified (gdbarch, insn, "mcrr/mcrr2", dsc);

	default:
	  return arm_copy_undef (gdbarch, insn, dsc);
	}

    case 0x9:
      {
	 int rn_f = (bits (insn, 16, 19) == 0xf);
	switch ((insn & 0xe00000) >> 21)
	  {
	  case 0x1: case 0x3:
	    /* ldc/ldc2 imm (undefined for rn == pc).  */
	    return rn_f ? arm_copy_undef (gdbarch, insn, dsc)
			: arm_copy_copro_load_store (gdbarch, insn, regs, dsc);

	  case 0x2:
	    return arm_copy_unmodified (gdbarch, insn, "mrrc/mrrc2", dsc);

	  case 0x4: case 0x5: case 0x6: case 0x7:
	    /* ldc/ldc2 lit (undefined for rn != pc).  */
	    return rn_f ? arm_copy_copro_load_store (gdbarch, insn, regs, dsc)
			: arm_copy_undef (gdbarch, insn, dsc);

	  default:
	    return arm_copy_undef (gdbarch, insn, dsc);
	  }
      }

    case 0xa:
      return arm_copy_unmodified (gdbarch, insn, "stc/stc2", dsc);

    case 0xb:
      if (bits (insn, 16, 19) == 0xf)
        /* ldc/ldc2 lit.  */
	return arm_copy_copro_load_store (gdbarch, insn, regs, dsc);
      else
	return arm_copy_undef (gdbarch, insn, dsc);

    case 0xc:
      if (bit (insn, 4))
	return arm_copy_unmodified (gdbarch, insn, "mcr/mcr2", dsc);
      else
	return arm_copy_unmodified (gdbarch, insn, "cdp/cdp2", dsc);

    case 0xd:
      if (bit (insn, 4))
	return arm_copy_unmodified (gdbarch, insn, "mrc/mrc2", dsc);
      else
	return arm_copy_unmodified (gdbarch, insn, "cdp/cdp2", dsc);

    default:
      return arm_copy_undef (gdbarch, insn, dsc);
    }
}

/* Decode miscellaneous instructions in dp/misc encoding space.  */

static int
arm_decode_miscellaneous (struct gdbarch *gdbarch, uint32_t insn,
			  struct regcache *regs,
			  struct displaced_step_closure *dsc)
{
  unsigned int op2 = bits (insn, 4, 6);
  unsigned int op = bits (insn, 21, 22);
  unsigned int op1 = bits (insn, 16, 19);

  switch (op2)
    {
    case 0x0:
      return arm_copy_unmodified (gdbarch, insn, "mrs/msr", dsc);

    case 0x1:
      if (op == 0x1)  /* bx.  */
	return arm_copy_bx_blx_reg (gdbarch, insn, regs, dsc);
      else if (op == 0x3)
	return arm_copy_unmodified (gdbarch, insn, "clz", dsc);
      else
	return arm_copy_undef (gdbarch, insn, dsc);

    case 0x2:
      if (op == 0x1)
        /* Not really supported.  */
	return arm_copy_unmodified (gdbarch, insn, "bxj", dsc);
      else
	return arm_copy_undef (gdbarch, insn, dsc);

    case 0x3:
      if (op == 0x1)
	return arm_copy_bx_blx_reg (gdbarch, insn,
				regs, dsc);  /* blx register.  */
      else
	return arm_copy_undef (gdbarch, insn, dsc);

    case 0x5:
      return arm_copy_unmodified (gdbarch, insn, "saturating add/sub", dsc);

    case 0x7:
      if (op == 0x1)
	return arm_copy_unmodified (gdbarch, insn, "bkpt", dsc);
      else if (op == 0x3)
        /* Not really supported.  */
	return arm_copy_unmodified (gdbarch, insn, "smc", dsc);

    default:
      return arm_copy_undef (gdbarch, insn, dsc);
    }
}

static int
arm_decode_dp_misc (struct gdbarch *gdbarch, uint32_t insn,
		    struct regcache *regs,
		    struct displaced_step_closure *dsc)
{
  if (bit (insn, 25))
    switch (bits (insn, 20, 24))
      {
      case 0x10:
	return arm_copy_unmodified (gdbarch, insn, "movw", dsc);

      case 0x14:
	return arm_copy_unmodified (gdbarch, insn, "movt", dsc);

      case 0x12: case 0x16:
	return arm_copy_unmodified (gdbarch, insn, "msr imm", dsc);

      default:
	return arm_copy_alu_imm (gdbarch, insn, regs, dsc);
      }
  else
    {
      uint32_t op1 = bits (insn, 20, 24), op2 = bits (insn, 4, 7);

      if ((op1 & 0x19) != 0x10 && (op2 & 0x1) == 0x0)
	return arm_copy_alu_reg (gdbarch, insn, regs, dsc);
      else if ((op1 & 0x19) != 0x10 && (op2 & 0x9) == 0x1)
	return arm_copy_alu_shifted_reg (gdbarch, insn, regs, dsc);
      else if ((op1 & 0x19) == 0x10 && (op2 & 0x8) == 0x0)
	return arm_decode_miscellaneous (gdbarch, insn, regs, dsc);
      else if ((op1 & 0x19) == 0x10 && (op2 & 0x9) == 0x8)
	return arm_copy_unmodified (gdbarch, insn, "halfword mul/mla", dsc);
      else if ((op1 & 0x10) == 0x00 && op2 == 0x9)
	return arm_copy_unmodified (gdbarch, insn, "mul/mla", dsc);
      else if ((op1 & 0x10) == 0x10 && op2 == 0x9)
	return arm_copy_unmodified (gdbarch, insn, "synch", dsc);
      else if (op2 == 0xb || (op2 & 0xd) == 0xd)
	/* 2nd arg means "unpriveleged".  */
	return arm_copy_extra_ld_st (gdbarch, insn, (op1 & 0x12) == 0x02, regs,
				     dsc);
    }

  /* Should be unreachable.  */
  return 1;
}

static int
arm_decode_ld_st_word_ubyte (struct gdbarch *gdbarch, uint32_t insn,
			     struct regcache *regs,
			     struct displaced_step_closure *dsc)
{
  int a = bit (insn, 25), b = bit (insn, 4);
  uint32_t op1 = bits (insn, 20, 24);
  int rn_f = bits (insn, 16, 19) == 0xf;

  if ((!a && (op1 & 0x05) == 0x00 && (op1 & 0x17) != 0x02)
      || (a && (op1 & 0x05) == 0x00 && (op1 & 0x17) != 0x02 && !b))
    return arm_copy_ldr_str_ldrb_strb (gdbarch, insn, regs, dsc, 0, 4, 0);
  else if ((!a && (op1 & 0x17) == 0x02)
	    || (a && (op1 & 0x17) == 0x02 && !b))
    return arm_copy_ldr_str_ldrb_strb (gdbarch, insn, regs, dsc, 0, 4, 1);
  else if ((!a && (op1 & 0x05) == 0x01 && (op1 & 0x17) != 0x03)
	    || (a && (op1 & 0x05) == 0x01 && (op1 & 0x17) != 0x03 && !b))
    return arm_copy_ldr_str_ldrb_strb (gdbarch, insn, regs, dsc, 1, 4, 0);
  else if ((!a && (op1 & 0x17) == 0x03)
	   || (a && (op1 & 0x17) == 0x03 && !b))
    return arm_copy_ldr_str_ldrb_strb (gdbarch, insn, regs, dsc, 1, 4, 1);
  else if ((!a && (op1 & 0x05) == 0x04 && (op1 & 0x17) != 0x06)
	    || (a && (op1 & 0x05) == 0x04 && (op1 & 0x17) != 0x06 && !b))
    return arm_copy_ldr_str_ldrb_strb (gdbarch, insn, regs, dsc, 0, 1, 0);
  else if ((!a && (op1 & 0x17) == 0x06)
	   || (a && (op1 & 0x17) == 0x06 && !b))
    return arm_copy_ldr_str_ldrb_strb (gdbarch, insn, regs, dsc, 0, 1, 1);
  else if ((!a && (op1 & 0x05) == 0x05 && (op1 & 0x17) != 0x07)
	   || (a && (op1 & 0x05) == 0x05 && (op1 & 0x17) != 0x07 && !b))
    return arm_copy_ldr_str_ldrb_strb (gdbarch, insn, regs, dsc, 1, 1, 0);
  else if ((!a && (op1 & 0x17) == 0x07)
	   || (a && (op1 & 0x17) == 0x07 && !b))
    return arm_copy_ldr_str_ldrb_strb (gdbarch, insn, regs, dsc, 1, 1, 1);

  /* Should be unreachable.  */
  return 1;
}

static int
arm_decode_media (struct gdbarch *gdbarch, uint32_t insn,
		  struct displaced_step_closure *dsc)
{
  switch (bits (insn, 20, 24))
    {
    case 0x00: case 0x01: case 0x02: case 0x03:
      return arm_copy_unmodified (gdbarch, insn, "parallel add/sub signed", dsc);

    case 0x04: case 0x05: case 0x06: case 0x07:
      return arm_copy_unmodified (gdbarch, insn, "parallel add/sub unsigned", dsc);

    case 0x08: case 0x09: case 0x0a: case 0x0b:
    case 0x0c: case 0x0d: case 0x0e: case 0x0f:
      return arm_copy_unmodified (gdbarch, insn,
			      "decode/pack/unpack/saturate/reverse", dsc);

    case 0x18:
      if (bits (insn, 5, 7) == 0)  /* op2.  */
	 {
	  if (bits (insn, 12, 15) == 0xf)
	    return arm_copy_unmodified (gdbarch, insn, "usad8", dsc);
	  else
	    return arm_copy_unmodified (gdbarch, insn, "usada8", dsc);
	}
      else
	 return arm_copy_undef (gdbarch, insn, dsc);

    case 0x1a: case 0x1b:
      if (bits (insn, 5, 6) == 0x2)  /* op2[1:0].  */
	return arm_copy_unmodified (gdbarch, insn, "sbfx", dsc);
      else
	return arm_copy_undef (gdbarch, insn, dsc);

    case 0x1c: case 0x1d:
      if (bits (insn, 5, 6) == 0x0)  /* op2[1:0].  */
	 {
	  if (bits (insn, 0, 3) == 0xf)
	    return arm_copy_unmodified (gdbarch, insn, "bfc", dsc);
	  else
	    return arm_copy_unmodified (gdbarch, insn, "bfi", dsc);
	}
      else
	return arm_copy_undef (gdbarch, insn, dsc);

    case 0x1e: case 0x1f:
      if (bits (insn, 5, 6) == 0x2)  /* op2[1:0].  */
	return arm_copy_unmodified (gdbarch, insn, "ubfx", dsc);
      else
	return arm_copy_undef (gdbarch, insn, dsc);
    }

  /* Should be unreachable.  */
  return 1;
}

static int
arm_decode_b_bl_ldmstm (struct gdbarch *gdbarch, int32_t insn,
			struct regcache *regs,
			struct displaced_step_closure *dsc)
{
  if (bit (insn, 25))
    return arm_copy_b_bl_blx (gdbarch, insn, regs, dsc);
  else
    return arm_copy_block_xfer (gdbarch, insn, regs, dsc);
}

static int
arm_decode_ext_reg_ld_st (struct gdbarch *gdbarch, uint32_t insn,
			  struct regcache *regs,
			  struct displaced_step_closure *dsc)
{
  unsigned int opcode = bits (insn, 20, 24);

  switch (opcode)
    {
    case 0x04: case 0x05:  /* VFP/Neon mrrc/mcrr.  */
      return arm_copy_unmodified (gdbarch, insn, "vfp/neon mrrc/mcrr", dsc);

    case 0x08: case 0x0a: case 0x0c: case 0x0e:
    case 0x12: case 0x16:
      return arm_copy_unmodified (gdbarch, insn, "vfp/neon vstm/vpush", dsc);

    case 0x09: case 0x0b: case 0x0d: case 0x0f:
    case 0x13: case 0x17:
      return arm_copy_unmodified (gdbarch, insn, "vfp/neon vldm/vpop", dsc);

    case 0x10: case 0x14: case 0x18: case 0x1c:  /* vstr.  */
    case 0x11: case 0x15: case 0x19: case 0x1d:  /* vldr.  */
      /* Note: no writeback for these instructions.  Bit 25 will always be
	 zero though (via caller), so the following works OK.  */
      return arm_copy_copro_load_store (gdbarch, insn, regs, dsc);
    }

  /* Should be unreachable.  */
  return 1;
}

/* Decode shifted register instructions.  */

static int
thumb2_decode_dp_shift_reg (struct gdbarch *gdbarch, uint16_t insn1,
			    uint16_t insn2,  struct regcache *regs,
			    struct displaced_step_closure *dsc)
{
  /* PC is only allowed to be used in instruction MOV.  */

  unsigned int op = bits (insn1, 5, 8);
  unsigned int rn = bits (insn1, 0, 3);

  if (op == 0x2 && rn == 0xf) /* MOV */
    return thumb2_copy_alu_imm (gdbarch, insn1, insn2, regs, dsc);
  else
    return thumb_copy_unmodified_32bit (gdbarch, insn1, insn2,
					"dp (shift reg)", dsc);
}


/* Decode extension register load/store.  Exactly the same as
   arm_decode_ext_reg_ld_st.  */

static int
thumb2_decode_ext_reg_ld_st (struct gdbarch *gdbarch, uint16_t insn1,
			     uint16_t insn2,  struct regcache *regs,
			     struct displaced_step_closure *dsc)
{
  unsigned int opcode = bits (insn1, 4, 8);

  switch (opcode)
    {
    case 0x04: case 0x05:
      return thumb_copy_unmodified_32bit (gdbarch, insn1, insn2,
					  "vfp/neon vmov", dsc);

    case 0x08: case 0x0c: /* 01x00 */
    case 0x0a: case 0x0e: /* 01x10 */
    case 0x12: case 0x16: /* 10x10 */
      return thumb_copy_unmodified_32bit (gdbarch, insn1, insn2,
					  "vfp/neon vstm/vpush", dsc);

    case 0x09: case 0x0d: /* 01x01 */
    case 0x0b: case 0x0f: /* 01x11 */
    case 0x13: case 0x17: /* 10x11 */
      return thumb_copy_unmodified_32bit (gdbarch, insn1, insn2,
					  "vfp/neon vldm/vpop", dsc);

    case 0x10: case 0x14: case 0x18: case 0x1c:  /* vstr.  */
      return thumb_copy_unmodified_32bit (gdbarch, insn1, insn2,
					  "vstr", dsc);
    case 0x11: case 0x15: case 0x19: case 0x1d:  /* vldr.  */
      return thumb2_copy_copro_load_store (gdbarch, insn1, insn2, regs, dsc);
    }

  /* Should be unreachable.  */
  return 1;
}

static int
arm_decode_svc_copro (struct gdbarch *gdbarch, uint32_t insn, CORE_ADDR to,
		      struct regcache *regs, struct displaced_step_closure *dsc)
{
  unsigned int op1 = bits (insn, 20, 25);
  int op = bit (insn, 4);
  unsigned int coproc = bits (insn, 8, 11);
  unsigned int rn = bits (insn, 16, 19);

  if ((op1 & 0x20) == 0x00 && (op1 & 0x3a) != 0x00 && (coproc & 0xe) == 0xa)
    return arm_decode_ext_reg_ld_st (gdbarch, insn, regs, dsc);
  else if ((op1 & 0x21) == 0x00 && (op1 & 0x3a) != 0x00
	   && (coproc & 0xe) != 0xa)
    /* stc/stc2.  */
    return arm_copy_copro_load_store (gdbarch, insn, regs, dsc);
  else if ((op1 & 0x21) == 0x01 && (op1 & 0x3a) != 0x00
	   && (coproc & 0xe) != 0xa)
    /* ldc/ldc2 imm/lit.  */
    return arm_copy_copro_load_store (gdbarch, insn, regs, dsc);
  else if ((op1 & 0x3e) == 0x00)
    return arm_copy_undef (gdbarch, insn, dsc);
  else if ((op1 & 0x3e) == 0x04 && (coproc & 0xe) == 0xa)
    return arm_copy_unmodified (gdbarch, insn, "neon 64bit xfer", dsc);
  else if (op1 == 0x04 && (coproc & 0xe) != 0xa)
    return arm_copy_unmodified (gdbarch, insn, "mcrr/mcrr2", dsc);
  else if (op1 == 0x05 && (coproc & 0xe) != 0xa)
    return arm_copy_unmodified (gdbarch, insn, "mrrc/mrrc2", dsc);
  else if ((op1 & 0x30) == 0x20 && !op)
    {
      if ((coproc & 0xe) == 0xa)
	return arm_copy_unmodified (gdbarch, insn, "vfp dataproc", dsc);
      else
	return arm_copy_unmodified (gdbarch, insn, "cdp/cdp2", dsc);
    }
  else if ((op1 & 0x30) == 0x20 && op)
    return arm_copy_unmodified (gdbarch, insn, "neon 8/16/32 bit xfer", dsc);
  else if ((op1 & 0x31) == 0x20 && op && (coproc & 0xe) != 0xa)
    return arm_copy_unmodified (gdbarch, insn, "mcr/mcr2", dsc);
  else if ((op1 & 0x31) == 0x21 && op && (coproc & 0xe) != 0xa)
    return arm_copy_unmodified (gdbarch, insn, "mrc/mrc2", dsc);
  else if ((op1 & 0x30) == 0x30)
    return arm_copy_svc (gdbarch, insn, regs, dsc);
  else
    return arm_copy_undef (gdbarch, insn, dsc);  /* Possibly unreachable.  */
}

static int
thumb2_decode_svc_copro (struct gdbarch *gdbarch, uint16_t insn1,
			 uint16_t insn2, struct regcache *regs,
			 struct displaced_step_closure *dsc)
{
  unsigned int coproc = bits (insn2, 8, 11);
  unsigned int op1 = bits (insn1, 4, 9);
  unsigned int bit_5_8 = bits (insn1, 5, 8);
  unsigned int bit_9 = bit (insn1, 9);
  unsigned int bit_4 = bit (insn1, 4);
  unsigned int rn = bits (insn1, 0, 3);

  if (bit_9 == 0)
    {
      if (bit_5_8 == 2)
	return thumb_copy_unmodified_32bit (gdbarch, insn1, insn2,
					    "neon 64bit xfer/mrrc/mrrc2/mcrr/mcrr2",
					    dsc);
      else if (bit_5_8 == 0) /* UNDEFINED.  */
	return thumb_32bit_copy_undef (gdbarch, insn1, insn2, dsc);
      else
	{
	   /*coproc is 101x.  SIMD/VFP, ext registers load/store.  */
	  if ((coproc & 0xe) == 0xa)
	    return thumb2_decode_ext_reg_ld_st (gdbarch, insn1, insn2, regs,
						dsc);
	  else /* coproc is not 101x.  */
	    {
	      if (bit_4 == 0) /* STC/STC2.  */
		return thumb_copy_unmodified_32bit (gdbarch, insn1, insn2,
						    "stc/stc2", dsc);
	      else /* LDC/LDC2 {literal, immeidate}.  */
		return thumb2_copy_copro_load_store (gdbarch, insn1, insn2,
						     regs, dsc);
	    }
	}
    }
  else
    return thumb_copy_unmodified_32bit (gdbarch, insn1, insn2, "coproc", dsc);

  return 0;
}

static void
install_pc_relative (struct gdbarch *gdbarch, struct regcache *regs,
		     struct displaced_step_closure *dsc, int rd)
{
  /* ADR Rd, #imm

     Rewrite as:

     Preparation: Rd <- PC
     Insn: ADD Rd, #imm
     Cleanup: Null.
  */

  /* Rd <- PC */
  int val = displaced_read_reg (regs, dsc, ARM_PC_REGNUM);
  displaced_write_reg (regs, dsc, rd, val, CANNOT_WRITE_PC);
}

static int
thumb_copy_pc_relative_16bit (struct gdbarch *gdbarch, struct regcache *regs,
			      struct displaced_step_closure *dsc,
			      int rd, unsigned int imm)
{

  /* Encoding T2: ADDS Rd, #imm */
  dsc->modinsn[0] = (0x3000 | (rd << 8) | imm);

  install_pc_relative (gdbarch, regs, dsc, rd);

  return 0;
}

static int
thumb_decode_pc_relative_16bit (struct gdbarch *gdbarch, uint16_t insn,
				struct regcache *regs,
				struct displaced_step_closure *dsc)
{
  unsigned int rd = bits (insn, 8, 10);
  unsigned int imm8 = bits (insn, 0, 7);

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog,
			"displaced: copying thumb adr r%d, #%d insn %.4x\n",
			rd, imm8, insn);

  return thumb_copy_pc_relative_16bit (gdbarch, regs, dsc, rd, imm8);
}

static int
thumb_copy_pc_relative_32bit (struct gdbarch *gdbarch, uint16_t insn1,
			      uint16_t insn2, struct regcache *regs,
			      struct displaced_step_closure *dsc)
{
  unsigned int rd = bits (insn2, 8, 11);
  /* Since immediate has the same encoding in ADR ADD and SUB, so we simply
     extract raw immediate encoding rather than computing immediate.  When
     generating ADD or SUB instruction, we can simply perform OR operation to
     set immediate into ADD.  */
  unsigned int imm_3_8 = insn2 & 0x70ff;
  unsigned int imm_i = insn1 & 0x0400; /* Clear all bits except bit 10.  */

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog,
			"displaced: copying thumb adr r%d, #%d:%d insn %.4x%.4x\n",
			rd, imm_i, imm_3_8, insn1, insn2);

  if (bit (insn1, 7)) /* Encoding T2 */
    {
      /* Encoding T3: SUB Rd, Rd, #imm */
      dsc->modinsn[0] = (0xf1a0 | rd | imm_i);
      dsc->modinsn[1] = ((rd << 8) | imm_3_8);
    }
  else /* Encoding T3 */
    {
      /* Encoding T3: ADD Rd, Rd, #imm */
      dsc->modinsn[0] = (0xf100 | rd | imm_i);
      dsc->modinsn[1] = ((rd << 8) | imm_3_8);
    }
  dsc->numinsns = 2;

  install_pc_relative (gdbarch, regs, dsc, rd);

  return 0;
}

static int
thumb_copy_16bit_ldr_literal (struct gdbarch *gdbarch, unsigned short insn1,
			      struct regcache *regs,
			      struct displaced_step_closure *dsc)
{
  unsigned int rt = bits (insn1, 8, 10);
  unsigned int pc;
  int imm8 = (bits (insn1, 0, 7) << 2);
  CORE_ADDR from = dsc->insn_addr;

  /* LDR Rd, #imm8

     Rwrite as:

     Preparation: tmp0 <- R0, tmp2 <- R2, tmp3 <- R3, R2 <- PC, R3 <- #imm8;

     Insn: LDR R0, [R2, R3];
     Cleanup: R2 <- tmp2, R3 <- tmp3, Rd <- R0, R0 <- tmp0 */

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog,
			"displaced: copying thumb ldr r%d [pc #%d]\n"
			, rt, imm8);

  dsc->tmp[0] = displaced_read_reg (regs, dsc, 0);
  dsc->tmp[2] = displaced_read_reg (regs, dsc, 2);
  dsc->tmp[3] = displaced_read_reg (regs, dsc, 3);
  pc = displaced_read_reg (regs, dsc, ARM_PC_REGNUM);
  /* The assembler calculates the required value of the offset from the
     Align(PC,4) value of this instruction to the label.  */
  pc = pc & 0xfffffffc;

  displaced_write_reg (regs, dsc, 2, pc, CANNOT_WRITE_PC);
  displaced_write_reg (regs, dsc, 3, imm8, CANNOT_WRITE_PC);

  dsc->rd = rt;
  dsc->u.ldst.xfersize = 4;
  dsc->u.ldst.rn = 0;
  dsc->u.ldst.immed = 0;
  dsc->u.ldst.writeback = 0;
  dsc->u.ldst.restore_r4 = 0;

  dsc->modinsn[0] = 0x58d0; /* ldr r0, [r2, r3]*/

  dsc->cleanup = &cleanup_load;

  return 0;
}

/* Copy Thumb cbnz/cbz insruction.  */

static int
thumb_copy_cbnz_cbz (struct gdbarch *gdbarch, uint16_t insn1,
		     struct regcache *regs,
		     struct displaced_step_closure *dsc)
{
  int non_zero = bit (insn1, 11);
  unsigned int imm5 = (bit (insn1, 9) << 6) | (bits (insn1, 3, 7) << 1);
  CORE_ADDR from = dsc->insn_addr;
  int rn = bits (insn1, 0, 2);
  int rn_val = displaced_read_reg (regs, dsc, rn);

  dsc->u.branch.cond = (rn_val && non_zero) || (!rn_val && !non_zero);
  /* CBNZ and CBZ do not affect the condition flags.  If condition is true,
     set it INST_AL, so cleanup_branch will know branch is taken, otherwise,
     condition is false, let it be, cleanup_branch will do nothing.  */
  if (dsc->u.branch.cond)
    {
      dsc->u.branch.cond = INST_AL;
      dsc->u.branch.dest = from + 4 + imm5;
    }
  else
      dsc->u.branch.dest = from + 2;

  dsc->u.branch.link = 0;
  dsc->u.branch.exchange = 0;

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: copying %s [r%d = 0x%x]"
			" insn %.4x to %.8lx\n", non_zero ? "cbnz" : "cbz",
			rn, rn_val, insn1, dsc->u.branch.dest);

  dsc->modinsn[0] = THUMB_NOP;

  dsc->cleanup = &cleanup_branch;
  return 0;
}

/* Copy Table Branch Byte/Halfword */
static int
thumb2_copy_table_branch (struct gdbarch *gdbarch, uint16_t insn1,
			  uint16_t insn2, struct regcache *regs,
			  struct displaced_step_closure *dsc)
{
  ULONGEST rn_val, rm_val;
  int is_tbh = bit (insn2, 4);
  CORE_ADDR halfwords = 0;
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);

  rn_val = displaced_read_reg (regs, dsc, bits (insn1, 0, 3));
  rm_val = displaced_read_reg (regs, dsc, bits (insn2, 0, 3));

  if (is_tbh)
    {
      gdb_byte buf[2];

      target_read_memory (rn_val + 2 * rm_val, buf, 2);
      halfwords = extract_unsigned_integer (buf, 2, byte_order);
    }
  else
    {
      gdb_byte buf[1];

      target_read_memory (rn_val + rm_val, buf, 1);
      halfwords = extract_unsigned_integer (buf, 1, byte_order);
    }

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: %s base 0x%x offset 0x%x"
			" offset 0x%x\n", is_tbh ? "tbh" : "tbb",
			(unsigned int) rn_val, (unsigned int) rm_val,
			(unsigned int) halfwords);

  dsc->u.branch.cond = INST_AL;
  dsc->u.branch.link = 0;
  dsc->u.branch.exchange = 0;
  dsc->u.branch.dest = dsc->insn_addr + 4 + 2 * halfwords;

  dsc->cleanup = &cleanup_branch;

  return 0;
}

static void
cleanup_pop_pc_16bit_all (struct gdbarch *gdbarch, struct regcache *regs,
			  struct displaced_step_closure *dsc)
{
  /* PC <- r7 */
  int val = displaced_read_reg (regs, dsc, 7);
  displaced_write_reg (regs, dsc, ARM_PC_REGNUM, val, BX_WRITE_PC);

  /* r7 <- r8 */
  val = displaced_read_reg (regs, dsc, 8);
  displaced_write_reg (regs, dsc, 7, val, CANNOT_WRITE_PC);

  /* r8 <- tmp[0] */
  displaced_write_reg (regs, dsc, 8, dsc->tmp[0], CANNOT_WRITE_PC);

}

static int
thumb_copy_pop_pc_16bit (struct gdbarch *gdbarch, unsigned short insn1,
			 struct regcache *regs,
			 struct displaced_step_closure *dsc)
{
  dsc->u.block.regmask = insn1 & 0x00ff;

  /* Rewrite instruction: POP {rX, rY, ...,rZ, PC}
     to :

     (1) register list is full, that is, r0-r7 are used.
     Prepare: tmp[0] <- r8

     POP {r0, r1, ...., r6, r7}; remove PC from reglist
     MOV r8, r7; Move value of r7 to r8;
     POP {r7}; Store PC value into r7.

     Cleanup: PC <- r7, r7 <- r8, r8 <-tmp[0]

     (2) register list is not full, supposing there are N registers in
     register list (except PC, 0 <= N <= 7).
     Prepare: for each i, 0 - N, tmp[i] <- ri.

     POP {r0, r1, ...., rN};

     Cleanup: Set registers in original reglist from r0 - rN.  Restore r0 - rN
     from tmp[] properly.
  */
  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog,
			"displaced: copying thumb pop {%.8x, pc} insn %.4x\n",
			dsc->u.block.regmask, insn1);

  if (dsc->u.block.regmask == 0xff)
    {
      dsc->tmp[0] = displaced_read_reg (regs, dsc, 8);

      dsc->modinsn[0] = (insn1 & 0xfeff); /* POP {r0,r1,...,r6, r7} */
      dsc->modinsn[1] = 0x46b8; /* MOV r8, r7 */
      dsc->modinsn[2] = 0xbc80; /* POP {r7} */

      dsc->numinsns = 3;
      dsc->cleanup = &cleanup_pop_pc_16bit_all;
    }
  else
    {
      unsigned int num_in_list = bitcount (dsc->u.block.regmask);
      unsigned int new_regmask, bit = 1;
      unsigned int to = 0, from = 0, i, new_rn;

      for (i = 0; i < num_in_list + 1; i++)
	dsc->tmp[i] = displaced_read_reg (regs, dsc, i);

      new_regmask = (1 << (num_in_list + 1)) - 1;

      if (debug_displaced)
	fprintf_unfiltered (gdb_stdlog, _("displaced: POP "
					  "{..., pc}: original reg list %.4x,"
					  " modified list %.4x\n"),
			    (int) dsc->u.block.regmask, new_regmask);

      dsc->u.block.regmask |= 0x8000;
      dsc->u.block.writeback = 0;
      dsc->u.block.cond = INST_AL;

      dsc->modinsn[0] = (insn1 & ~0x1ff) | (new_regmask & 0xff);

      dsc->cleanup = &cleanup_block_load_pc;
    }

  return 0;
}

static void
thumb_process_displaced_16bit_insn (struct gdbarch *gdbarch, uint16_t insn1,
				    struct regcache *regs,
				    struct displaced_step_closure *dsc)
{
  unsigned short op_bit_12_15 = bits (insn1, 12, 15);
  unsigned short op_bit_10_11 = bits (insn1, 10, 11);
  int err = 0;

  /* 16-bit thumb instructions.  */
  switch (op_bit_12_15)
    {
      /* Shift (imme), add, subtract, move and compare.  */
    case 0: case 1: case 2: case 3:
      err = thumb_copy_unmodified_16bit (gdbarch, insn1,
					 "shift/add/sub/mov/cmp",
					 dsc);
      break;
    case 4:
      switch (op_bit_10_11)
	{
	case 0: /* Data-processing */
	  err = thumb_copy_unmodified_16bit (gdbarch, insn1,
					     "data-processing",
					     dsc);
	  break;
	case 1: /* Special data instructions and branch and exchange.  */
	  {
	    unsigned short op = bits (insn1, 7, 9);
	    if (op == 6 || op == 7) /* BX or BLX */
	      err = thumb_copy_bx_blx_reg (gdbarch, insn1, regs, dsc);
	    else if (bits (insn1, 6, 7) != 0) /* ADD/MOV/CMP high registers.  */
	      err = thumb_copy_alu_reg (gdbarch, insn1, regs, dsc);
	    else
	      err = thumb_copy_unmodified_16bit (gdbarch, insn1, "special data",
						 dsc);
	  }
	  break;
	default: /* LDR (literal) */
	  err = thumb_copy_16bit_ldr_literal (gdbarch, insn1, regs, dsc);
	}
      break;
    case 5: case 6: case 7: case 8: case 9: /* Load/Store single data item */
      err = thumb_copy_unmodified_16bit (gdbarch, insn1, "ldr/str", dsc);
      break;
    case 10:
      if (op_bit_10_11 < 2) /* Generate PC-relative address */
	err = thumb_decode_pc_relative_16bit (gdbarch, insn1, regs, dsc);
      else /* Generate SP-relative address */
	err = thumb_copy_unmodified_16bit (gdbarch, insn1, "sp-relative", dsc);
      break;
    case 11: /* Misc 16-bit instructions */
      {
	switch (bits (insn1, 8, 11))
	  {
	  case 1: case 3:  case 9: case 11: /* CBNZ, CBZ */
	    err = thumb_copy_cbnz_cbz (gdbarch, insn1, regs, dsc);
	    break;
	  case 12: case 13: /* POP */
	    if (bit (insn1, 8)) /* PC is in register list.  */
	      err = thumb_copy_pop_pc_16bit (gdbarch, insn1, regs, dsc);
	    else
	      err = thumb_copy_unmodified_16bit (gdbarch, insn1, "pop", dsc);
	    break;
	  case 15: /* If-Then, and hints */
	    if (bits (insn1, 0, 3))
	      /* If-Then makes up to four following instructions conditional.
		 IT instruction itself is not conditional, so handle it as a
		 common unmodified instruction.  */
	      err = thumb_copy_unmodified_16bit (gdbarch, insn1, "If-Then",
						 dsc);
	    else
	      err = thumb_copy_unmodified_16bit (gdbarch, insn1, "hints", dsc);
	    break;
	  default:
	    err = thumb_copy_unmodified_16bit (gdbarch, insn1, "misc", dsc);
	  }
      }
      break;
    case 12:
      if (op_bit_10_11 < 2) /* Store multiple registers */
	err = thumb_copy_unmodified_16bit (gdbarch, insn1, "stm", dsc);
      else /* Load multiple registers */
	err = thumb_copy_unmodified_16bit (gdbarch, insn1, "ldm", dsc);
      break;
    case 13: /* Conditional branch and supervisor call */
      if (bits (insn1, 9, 11) != 7) /* conditional branch */
	err = thumb_copy_b (gdbarch, insn1, dsc);
      else
	err = thumb_copy_svc (gdbarch, insn1, regs, dsc);
      break;
    case 14: /* Unconditional branch */
      err = thumb_copy_b (gdbarch, insn1, dsc);
      break;
    default:
      err = 1;
    }

  if (err)
    internal_error (__FILE__, __LINE__,
		    _("thumb_process_displaced_16bit_insn: Instruction decode error"));
}

static int
decode_thumb_32bit_ld_mem_hints (struct gdbarch *gdbarch,
				 uint16_t insn1, uint16_t insn2,
				 struct regcache *regs,
				 struct displaced_step_closure *dsc)
{
  int rt = bits (insn2, 12, 15);
  int rn = bits (insn1, 0, 3);
  int op1 = bits (insn1, 7, 8);
  int err = 0;

  switch (bits (insn1, 5, 6))
    {
    case 0: /* Load byte and memory hints */
      if (rt == 0xf) /* PLD/PLI */
	{
	  if (rn == 0xf)
	    /* PLD literal or Encoding T3 of PLI(immediate, literal).  */
	    return thumb2_copy_preload (gdbarch, insn1, insn2, regs, dsc);
	  else
	    return thumb_copy_unmodified_32bit (gdbarch, insn1, insn2,
						"pli/pld", dsc);
	}
      else
	{
	  if (rn == 0xf) /* LDRB/LDRSB (literal) */
	    return thumb2_copy_load_literal (gdbarch, insn1, insn2, regs, dsc,
					     1);
	  else
	    return thumb_copy_unmodified_32bit (gdbarch, insn1, insn2,
						"ldrb{reg, immediate}/ldrbt",
						dsc);
	}

      break;
    case 1: /* Load halfword and memory hints.  */
      if (rt == 0xf) /* PLD{W} and Unalloc memory hint.  */
	return thumb_copy_unmodified_32bit (gdbarch, insn1, insn2,
					    "pld/unalloc memhint", dsc);
      else
	{
	  if (rn == 0xf)
	    return thumb2_copy_load_literal (gdbarch, insn1, insn2, regs, dsc,
					     2);
	  else
	    return thumb_copy_unmodified_32bit (gdbarch, insn1, insn2,
						"ldrh/ldrht", dsc);
	}
      break;
    case 2: /* Load word */
      {
	int insn2_bit_8_11 = bits (insn2, 8, 11);

	if (rn == 0xf)
	  return thumb2_copy_load_literal (gdbarch, insn1, insn2, regs, dsc, 4);
	else if (op1 == 0x1) /* Encoding T3 */
	  return thumb2_copy_load_reg_imm (gdbarch, insn1, insn2, regs, dsc,
					   0, 1);
	else /* op1 == 0x0 */
	  {
	    if (insn2_bit_8_11 == 0xc || (insn2_bit_8_11 & 0x9) == 0x9)
	      /* LDR (immediate) */
	      return thumb2_copy_load_reg_imm (gdbarch, insn1, insn2, regs,
					       dsc, bit (insn2, 8), 1);
	    else if (insn2_bit_8_11 == 0xe) /* LDRT */
	      return thumb_copy_unmodified_32bit (gdbarch, insn1, insn2,
						  "ldrt", dsc);
	    else
	      /* LDR (register) */
	      return thumb2_copy_load_reg_imm (gdbarch, insn1, insn2, regs,
					       dsc, 0, 0);
	  }
	break;
      }
    default:
      return thumb_32bit_copy_undef (gdbarch, insn1, insn2, dsc);
      break;
    }
  return 0;
}

static void
thumb_process_displaced_32bit_insn (struct gdbarch *gdbarch, uint16_t insn1,
				    uint16_t insn2, struct regcache *regs,
				    struct displaced_step_closure *dsc)
{
  int err = 0;
  unsigned short op = bit (insn2, 15);
  unsigned int op1 = bits (insn1, 11, 12);

  switch (op1)
    {
    case 1:
      {
	switch (bits (insn1, 9, 10))
	  {
	  case 0:
	    if (bit (insn1, 6))
	      {
		/* Load/store {dual, execlusive}, table branch.  */
		if (bits (insn1, 7, 8) == 1 && bits (insn1, 4, 5) == 1
		    && bits (insn2, 5, 7) == 0)
		  err = thumb2_copy_table_branch (gdbarch, insn1, insn2, regs,
						  dsc);
		else
		  /* PC is not allowed to use in load/store {dual, exclusive}
		     instructions.  */
		  err = thumb_copy_unmodified_32bit (gdbarch, insn1, insn2,
						     "load/store dual/ex", dsc);
	      }
	    else /* load/store multiple */
	      {
		switch (bits (insn1, 7, 8))
		  {
		  case 0: case 3: /* SRS, RFE */
		    err = thumb_copy_unmodified_32bit (gdbarch, insn1, insn2,
						       "srs/rfe", dsc);
		    break;
		  case 1: case 2: /* LDM/STM/PUSH/POP */
		    err = thumb2_copy_block_xfer (gdbarch, insn1, insn2, regs, dsc);
		    break;
		  }
	      }
	    break;

	  case 1:
	    /* Data-processing (shift register).  */
	    err = thumb2_decode_dp_shift_reg (gdbarch, insn1, insn2, regs,
					      dsc);
	    break;
	  default: /* Coprocessor instructions.  */
	    err = thumb2_decode_svc_copro (gdbarch, insn1, insn2, regs, dsc);
	    break;
	  }
      break;
      }
    case 2: /* op1 = 2 */
      if (op) /* Branch and misc control.  */
	{
	  if (bit (insn2, 14)  /* BLX/BL */
	      || bit (insn2, 12) /* Unconditional branch */
	      || (bits (insn1, 7, 9) != 0x7)) /* Conditional branch */
	    err = thumb2_copy_b_bl_blx (gdbarch, insn1, insn2, regs, dsc);
	  else
	    err = thumb_copy_unmodified_32bit (gdbarch, insn1, insn2,
					       "misc ctrl", dsc);
	}
      else
	{
	  if (bit (insn1, 9)) /* Data processing (plain binary imm).  */
	    {
	      int op = bits (insn1, 4, 8);
	      int rn = bits (insn1, 0, 3);
	      if ((op == 0 || op == 0xa) && rn == 0xf)
		err = thumb_copy_pc_relative_32bit (gdbarch, insn1, insn2,
						    regs, dsc);
	      else
		err = thumb_copy_unmodified_32bit (gdbarch, insn1, insn2,
						   "dp/pb", dsc);
	    }
	  else /* Data processing (modified immeidate) */
	    err = thumb_copy_unmodified_32bit (gdbarch, insn1, insn2,
					       "dp/mi", dsc);
	}
      break;
    case 3: /* op1 = 3 */
      switch (bits (insn1, 9, 10))
	{
	case 0:
	  if (bit (insn1, 4))
	    err = decode_thumb_32bit_ld_mem_hints (gdbarch, insn1, insn2,
						   regs, dsc);
	  else /* NEON Load/Store and Store single data item */
	    err = thumb_copy_unmodified_32bit (gdbarch, insn1, insn2,
					       "neon elt/struct load/store",
					       dsc);
	  break;
	case 1: /* op1 = 3, bits (9, 10) == 1 */
	  switch (bits (insn1, 7, 8))
	    {
	    case 0: case 1: /* Data processing (register) */
	      err = thumb_copy_unmodified_32bit (gdbarch, insn1, insn2,
						 "dp(reg)", dsc);
	      break;
	    case 2: /* Multiply and absolute difference */
	      err = thumb_copy_unmodified_32bit (gdbarch, insn1, insn2,
						 "mul/mua/diff", dsc);
	      break;
	    case 3: /* Long multiply and divide */
	      err = thumb_copy_unmodified_32bit (gdbarch, insn1, insn2,
						 "lmul/lmua", dsc);
	      break;
	    }
	  break;
	default: /* Coprocessor instructions */
	  err = thumb2_decode_svc_copro (gdbarch, insn1, insn2, regs, dsc);
	  break;
	}
      break;
    default:
      err = 1;
    }

  if (err)
    internal_error (__FILE__, __LINE__,
		    _("thumb_process_displaced_32bit_insn: Instruction decode error"));

}

static void
thumb_process_displaced_insn (struct gdbarch *gdbarch, CORE_ADDR from,
			      CORE_ADDR to, struct regcache *regs,
			      struct displaced_step_closure *dsc)
{
  enum bfd_endian byte_order_for_code = gdbarch_byte_order_for_code (gdbarch);
  uint16_t insn1
    = read_memory_unsigned_integer (from, 2, byte_order_for_code);

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: process thumb insn %.4x "
			"at %.8lx\n", insn1, (unsigned long) from);

  dsc->is_thumb = 1;
  dsc->insn_size = thumb_insn_size (insn1);
  if (thumb_insn_size (insn1) == 4)
    {
      uint16_t insn2
	= read_memory_unsigned_integer (from + 2, 2, byte_order_for_code);
      thumb_process_displaced_32bit_insn (gdbarch, insn1, insn2, regs, dsc);
    }
  else
    thumb_process_displaced_16bit_insn (gdbarch, insn1, regs, dsc);
}

void
arm_process_displaced_insn (struct gdbarch *gdbarch, CORE_ADDR from,
			    CORE_ADDR to, struct regcache *regs,
			    struct displaced_step_closure *dsc)
{
  int err = 0;
  enum bfd_endian byte_order_for_code = gdbarch_byte_order_for_code (gdbarch);
  uint32_t insn;

  /* Most displaced instructions use a 1-instruction scratch space, so set this
     here and override below if/when necessary.  */
  dsc->numinsns = 1;
  dsc->insn_addr = from;
  dsc->scratch_base = to;
  dsc->cleanup = NULL;
  dsc->wrote_to_pc = 0;

  if (!displaced_in_arm_mode (regs))
    return thumb_process_displaced_insn (gdbarch, from, to, regs, dsc);

  dsc->is_thumb = 0;
  dsc->insn_size = 4;
  insn = read_memory_unsigned_integer (from, 4, byte_order_for_code);
  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: stepping insn %.8lx "
			"at %.8lx\n", (unsigned long) insn,
			(unsigned long) from);

  if ((insn & 0xf0000000) == 0xf0000000)
    err = arm_decode_unconditional (gdbarch, insn, regs, dsc);
  else switch (((insn & 0x10) >> 4) | ((insn & 0xe000000) >> 24))
    {
    case 0x0: case 0x1: case 0x2: case 0x3:
      err = arm_decode_dp_misc (gdbarch, insn, regs, dsc);
      break;

    case 0x4: case 0x5: case 0x6:
      err = arm_decode_ld_st_word_ubyte (gdbarch, insn, regs, dsc);
      break;

    case 0x7:
      err = arm_decode_media (gdbarch, insn, dsc);
      break;

    case 0x8: case 0x9: case 0xa: case 0xb:
      err = arm_decode_b_bl_ldmstm (gdbarch, insn, regs, dsc);
      break;

    case 0xc: case 0xd: case 0xe: case 0xf:
      err = arm_decode_svc_copro (gdbarch, insn, to, regs, dsc);
      break;
    }

  if (err)
    internal_error (__FILE__, __LINE__,
		    _("arm_process_displaced_insn: Instruction decode error"));
}

/* Actually set up the scratch space for a displaced instruction.  */

void
arm_displaced_init_closure (struct gdbarch *gdbarch, CORE_ADDR from,
			    CORE_ADDR to, struct displaced_step_closure *dsc)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  unsigned int i, len, offset;
  enum bfd_endian byte_order_for_code = gdbarch_byte_order_for_code (gdbarch);
  int size = dsc->is_thumb? 2 : 4;
  const gdb_byte *bkp_insn;

  offset = 0;
  /* Poke modified instruction(s).  */
  for (i = 0; i < dsc->numinsns; i++)
    {
      if (debug_displaced)
	{
	  fprintf_unfiltered (gdb_stdlog, "displaced: writing insn ");
	  if (size == 4)
	    fprintf_unfiltered (gdb_stdlog, "%.8lx",
				dsc->modinsn[i]);
	  else if (size == 2)
	    fprintf_unfiltered (gdb_stdlog, "%.4x",
				(unsigned short)dsc->modinsn[i]);

	  fprintf_unfiltered (gdb_stdlog, " at %.8lx\n",
			      (unsigned long) to + offset);

	}
      write_memory_unsigned_integer (to + offset, size,
				     byte_order_for_code,
				     dsc->modinsn[i]);
      offset += size;
    }

  /* Choose the correct breakpoint instruction.  */
  if (dsc->is_thumb)
    {
      bkp_insn = tdep->thumb_breakpoint;
      len = tdep->thumb_breakpoint_size;
    }
  else
    {
      bkp_insn = tdep->arm_breakpoint;
      len = tdep->arm_breakpoint_size;
    }

  /* Put breakpoint afterwards.  */
  write_memory (to + offset, bkp_insn, len);

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: copy %s->%s: ",
			paddress (gdbarch, from), paddress (gdbarch, to));
}

/* Entry point for copying an instruction into scratch space for displaced
   stepping.  */

struct displaced_step_closure *
arm_displaced_step_copy_insn (struct gdbarch *gdbarch,
			      CORE_ADDR from, CORE_ADDR to,
			      struct regcache *regs)
{
  struct displaced_step_closure *dsc
    = xmalloc (sizeof (struct displaced_step_closure));
  arm_process_displaced_insn (gdbarch, from, to, regs, dsc);
  arm_displaced_init_closure (gdbarch, from, to, dsc);

  return dsc;
}

/* Entry point for cleaning things up after a displaced instruction has been
   single-stepped.  */

void
arm_displaced_step_fixup (struct gdbarch *gdbarch,
			  struct displaced_step_closure *dsc,
			  CORE_ADDR from, CORE_ADDR to,
			  struct regcache *regs)
{
  if (dsc->cleanup)
    dsc->cleanup (gdbarch, regs, dsc);

  if (!dsc->wrote_to_pc)
    regcache_cooked_write_unsigned (regs, ARM_PC_REGNUM,
				    dsc->insn_addr + dsc->insn_size);

}

#include "bfd-in2.h"
#include "libcoff.h"

static int
gdb_print_insn_arm (bfd_vma memaddr, disassemble_info *info)
{
  struct gdbarch *gdbarch = info->application_data;

  if (arm_pc_is_thumb (gdbarch, memaddr))
    {
      static asymbol *asym;
      static combined_entry_type ce;
      static struct coff_symbol_struct csym;
      static struct bfd fake_bfd;
      static bfd_target fake_target;

      if (csym.native == NULL)
	{
	  /* Create a fake symbol vector containing a Thumb symbol.
	     This is solely so that the code in print_insn_little_arm() 
	     and print_insn_big_arm() in opcodes/arm-dis.c will detect
	     the presence of a Thumb symbol and switch to decoding
	     Thumb instructions.  */

	  fake_target.flavour = bfd_target_coff_flavour;
	  fake_bfd.xvec = &fake_target;
	  ce.u.syment.n_sclass = C_THUMBEXTFUNC;
	  csym.native = &ce;
	  csym.symbol.the_bfd = &fake_bfd;
	  csym.symbol.name = "fake";
	  asym = (asymbol *) & csym;
	}

      memaddr = UNMAKE_THUMB_ADDR (memaddr);
      info->symbols = &asym;
    }
  else
    info->symbols = NULL;

  if (info->endian == BFD_ENDIAN_BIG)
    return print_insn_big_arm (memaddr, info);
  else
    return print_insn_little_arm (memaddr, info);
}

/* The following define instruction sequences that will cause ARM
   cpu's to take an undefined instruction trap.  These are used to
   signal a breakpoint to GDB.
   
   The newer ARMv4T cpu's are capable of operating in ARM or Thumb
   modes.  A different instruction is required for each mode.  The ARM
   cpu's can also be big or little endian.  Thus four different
   instructions are needed to support all cases.
   
   Note: ARMv4 defines several new instructions that will take the
   undefined instruction trap.  ARM7TDMI is nominally ARMv4T, but does
   not in fact add the new instructions.  The new undefined
   instructions in ARMv4 are all instructions that had no defined
   behaviour in earlier chips.  There is no guarantee that they will
   raise an exception, but may be treated as NOP's.  In practice, it
   may only safe to rely on instructions matching:
   
   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 
   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
   C C C C 0 1 1 x x x x x x x x x x x x x x x x x x x x 1 x x x x
   
   Even this may only true if the condition predicate is true.  The
   following use a condition predicate of ALWAYS so it is always TRUE.
   
   There are other ways of forcing a breakpoint.  GNU/Linux, RISC iX,
   and NetBSD all use a software interrupt rather than an undefined
   instruction to force a trap.  This can be handled by by the
   abi-specific code during establishment of the gdbarch vector.  */

#define ARM_LE_BREAKPOINT {0xFE,0xDE,0xFF,0xE7}
#define ARM_BE_BREAKPOINT {0xE7,0xFF,0xDE,0xFE}
#define THUMB_LE_BREAKPOINT {0xbe,0xbe}
#define THUMB_BE_BREAKPOINT {0xbe,0xbe}

static const gdb_byte arm_default_arm_le_breakpoint[] = ARM_LE_BREAKPOINT;
static const gdb_byte arm_default_arm_be_breakpoint[] = ARM_BE_BREAKPOINT;
static const gdb_byte arm_default_thumb_le_breakpoint[] = THUMB_LE_BREAKPOINT;
static const gdb_byte arm_default_thumb_be_breakpoint[] = THUMB_BE_BREAKPOINT;

/* Determine the type and size of breakpoint to insert at PCPTR.  Uses
   the program counter value to determine whether a 16-bit or 32-bit
   breakpoint should be used.  It returns a pointer to a string of
   bytes that encode a breakpoint instruction, stores the length of
   the string to *lenptr, and adjusts the program counter (if
   necessary) to point to the actual memory location where the
   breakpoint should be inserted.  */

static const unsigned char *
arm_breakpoint_from_pc (struct gdbarch *gdbarch, CORE_ADDR *pcptr, int *lenptr)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  enum bfd_endian byte_order_for_code = gdbarch_byte_order_for_code (gdbarch);

  if (arm_pc_is_thumb (gdbarch, *pcptr))
    {
      *pcptr = UNMAKE_THUMB_ADDR (*pcptr);

      /* If we have a separate 32-bit breakpoint instruction for Thumb-2,
	 check whether we are replacing a 32-bit instruction.  */
      if (tdep->thumb2_breakpoint != NULL)
	{
	  gdb_byte buf[2];
	  if (target_read_memory (*pcptr, buf, 2) == 0)
	    {
	      unsigned short inst1;
	      inst1 = extract_unsigned_integer (buf, 2, byte_order_for_code);
	      if (thumb_insn_size (inst1) == 4)
		{
		  *lenptr = tdep->thumb2_breakpoint_size;
		  return tdep->thumb2_breakpoint;
		}
	    }
	}

      *lenptr = tdep->thumb_breakpoint_size;
      return tdep->thumb_breakpoint;
    }
  else
    {
      *lenptr = tdep->arm_breakpoint_size;
      return tdep->arm_breakpoint;
    }
}

static void
arm_remote_breakpoint_from_pc (struct gdbarch *gdbarch, CORE_ADDR *pcptr,
			       int *kindptr)
{
  arm_breakpoint_from_pc (gdbarch, pcptr, kindptr);

  if (arm_pc_is_thumb (gdbarch, *pcptr) && *kindptr == 4)
    /* The documented magic value for a 32-bit Thumb-2 breakpoint, so
       that this is not confused with a 32-bit ARM breakpoint.  */
    *kindptr = 3;
}

/* Extract from an array REGBUF containing the (raw) register state a
   function return value of type TYPE, and copy that, in virtual
   format, into VALBUF.  */

static void
arm_extract_return_value (struct type *type, struct regcache *regs,
			  gdb_byte *valbuf)
{
  struct gdbarch *gdbarch = get_regcache_arch (regs);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);

  if (TYPE_CODE_FLT == TYPE_CODE (type))
    {
      switch (gdbarch_tdep (gdbarch)->fp_model)
	{
	case ARM_FLOAT_FPA:
	  {
	    /* The value is in register F0 in internal format.  We need to
	       extract the raw value and then convert it to the desired
	       internal type.  */
	    bfd_byte tmpbuf[FP_REGISTER_SIZE];

	    regcache_cooked_read (regs, ARM_F0_REGNUM, tmpbuf);
	    convert_from_extended (floatformat_from_type (type), tmpbuf,
				   valbuf, gdbarch_byte_order (gdbarch));
	  }
	  break;

	case ARM_FLOAT_SOFT_FPA:
	case ARM_FLOAT_SOFT_VFP:
	  /* ARM_FLOAT_VFP can arise if this is a variadic function so
	     not using the VFP ABI code.  */
	case ARM_FLOAT_VFP:
	  regcache_cooked_read (regs, ARM_A1_REGNUM, valbuf);
	  if (TYPE_LENGTH (type) > 4)
	    regcache_cooked_read (regs, ARM_A1_REGNUM + 1,
				  valbuf + INT_REGISTER_SIZE);
	  break;

	default:
	  internal_error (__FILE__, __LINE__,
			  _("arm_extract_return_value: "
			    "Floating point model not supported"));
	  break;
	}
    }
  else if (TYPE_CODE (type) == TYPE_CODE_INT
	   || TYPE_CODE (type) == TYPE_CODE_CHAR
	   || TYPE_CODE (type) == TYPE_CODE_BOOL
	   || TYPE_CODE (type) == TYPE_CODE_PTR
	   || TYPE_CODE (type) == TYPE_CODE_REF
	   || TYPE_CODE (type) == TYPE_CODE_ENUM)
    {
      /* If the type is a plain integer, then the access is
	 straight-forward.  Otherwise we have to play around a bit
	 more.  */
      int len = TYPE_LENGTH (type);
      int regno = ARM_A1_REGNUM;
      ULONGEST tmp;

      while (len > 0)
	{
	  /* By using store_unsigned_integer we avoid having to do
	     anything special for small big-endian values.  */
	  regcache_cooked_read_unsigned (regs, regno++, &tmp);
	  store_unsigned_integer (valbuf, 
				  (len > INT_REGISTER_SIZE
				   ? INT_REGISTER_SIZE : len),
				  byte_order, tmp);
	  len -= INT_REGISTER_SIZE;
	  valbuf += INT_REGISTER_SIZE;
	}
    }
  else
    {
      /* For a structure or union the behaviour is as if the value had
         been stored to word-aligned memory and then loaded into 
         registers with 32-bit load instruction(s).  */
      int len = TYPE_LENGTH (type);
      int regno = ARM_A1_REGNUM;
      bfd_byte tmpbuf[INT_REGISTER_SIZE];

      while (len > 0)
	{
	  regcache_cooked_read (regs, regno++, tmpbuf);
	  memcpy (valbuf, tmpbuf,
		  len > INT_REGISTER_SIZE ? INT_REGISTER_SIZE : len);
	  len -= INT_REGISTER_SIZE;
	  valbuf += INT_REGISTER_SIZE;
	}
    }
}


/* Will a function return an aggregate type in memory or in a
   register?  Return 0 if an aggregate type can be returned in a
   register, 1 if it must be returned in memory.  */

static int
arm_return_in_memory (struct gdbarch *gdbarch, struct type *type)
{
  int nRc;
  enum type_code code;

  CHECK_TYPEDEF (type);

  /* In the ARM ABI, "integer" like aggregate types are returned in
     registers.  For an aggregate type to be integer like, its size
     must be less than or equal to INT_REGISTER_SIZE and the
     offset of each addressable subfield must be zero.  Note that bit
     fields are not addressable, and all addressable subfields of
     unions always start at offset zero.

     This function is based on the behaviour of GCC 2.95.1.
     See: gcc/arm.c: arm_return_in_memory() for details.

     Note: All versions of GCC before GCC 2.95.2 do not set up the
     parameters correctly for a function returning the following
     structure: struct { float f;}; This should be returned in memory,
     not a register.  Richard Earnshaw sent me a patch, but I do not
     know of any way to detect if a function like the above has been
     compiled with the correct calling convention.  */

  /* All aggregate types that won't fit in a register must be returned
     in memory.  */
  if (TYPE_LENGTH (type) > INT_REGISTER_SIZE)
    {
      return 1;
    }

  /* The AAPCS says all aggregates not larger than a word are returned
     in a register.  */
  if (gdbarch_tdep (gdbarch)->arm_abi != ARM_ABI_APCS)
    return 0;

  /* The only aggregate types that can be returned in a register are
     structs and unions.  Arrays must be returned in memory.  */
  code = TYPE_CODE (type);
  if ((TYPE_CODE_STRUCT != code) && (TYPE_CODE_UNION != code))
    {
      return 1;
    }

  /* Assume all other aggregate types can be returned in a register.
     Run a check for structures, unions and arrays.  */
  nRc = 0;

  if ((TYPE_CODE_STRUCT == code) || (TYPE_CODE_UNION == code))
    {
      int i;
      /* Need to check if this struct/union is "integer" like.  For
         this to be true, its size must be less than or equal to
         INT_REGISTER_SIZE and the offset of each addressable
         subfield must be zero.  Note that bit fields are not
         addressable, and unions always start at offset zero.  If any
         of the subfields is a floating point type, the struct/union
         cannot be an integer type.  */

      /* For each field in the object, check:
         1) Is it FP? --> yes, nRc = 1;
         2) Is it addressable (bitpos != 0) and
         not packed (bitsize == 0)?
         --> yes, nRc = 1  
       */

      for (i = 0; i < TYPE_NFIELDS (type); i++)
	{
	  enum type_code field_type_code;
	  field_type_code = TYPE_CODE (check_typedef (TYPE_FIELD_TYPE (type,
								       i)));

	  /* Is it a floating point type field?  */
	  if (field_type_code == TYPE_CODE_FLT)
	    {
	      nRc = 1;
	      break;
	    }

	  /* If bitpos != 0, then we have to care about it.  */
	  if (TYPE_FIELD_BITPOS (type, i) != 0)
	    {
	      /* Bitfields are not addressable.  If the field bitsize is 
	         zero, then the field is not packed.  Hence it cannot be
	         a bitfield or any other packed type.  */
	      if (TYPE_FIELD_BITSIZE (type, i) == 0)
		{
		  nRc = 1;
		  break;
		}
	    }
	}
    }

  return nRc;
}

/* Write into appropriate registers a function return value of type
   TYPE, given in virtual format.  */

static void
arm_store_return_value (struct type *type, struct regcache *regs,
			const gdb_byte *valbuf)
{
  struct gdbarch *gdbarch = get_regcache_arch (regs);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);

  if (TYPE_CODE (type) == TYPE_CODE_FLT)
    {
      gdb_byte buf[MAX_REGISTER_SIZE];

      switch (gdbarch_tdep (gdbarch)->fp_model)
	{
	case ARM_FLOAT_FPA:

	  convert_to_extended (floatformat_from_type (type), buf, valbuf,
			       gdbarch_byte_order (gdbarch));
	  regcache_cooked_write (regs, ARM_F0_REGNUM, buf);
	  break;

	case ARM_FLOAT_SOFT_FPA:
	case ARM_FLOAT_SOFT_VFP:
	  /* ARM_FLOAT_VFP can arise if this is a variadic function so
	     not using the VFP ABI code.  */
	case ARM_FLOAT_VFP:
	  regcache_cooked_write (regs, ARM_A1_REGNUM, valbuf);
	  if (TYPE_LENGTH (type) > 4)
	    regcache_cooked_write (regs, ARM_A1_REGNUM + 1, 
				   valbuf + INT_REGISTER_SIZE);
	  break;

	default:
	  internal_error (__FILE__, __LINE__,
			  _("arm_store_return_value: Floating "
			    "point model not supported"));
	  break;
	}
    }
  else if (TYPE_CODE (type) == TYPE_CODE_INT
	   || TYPE_CODE (type) == TYPE_CODE_CHAR
	   || TYPE_CODE (type) == TYPE_CODE_BOOL
	   || TYPE_CODE (type) == TYPE_CODE_PTR
	   || TYPE_CODE (type) == TYPE_CODE_REF
	   || TYPE_CODE (type) == TYPE_CODE_ENUM)
    {
      if (TYPE_LENGTH (type) <= 4)
	{
	  /* Values of one word or less are zero/sign-extended and
	     returned in r0.  */
	  bfd_byte tmpbuf[INT_REGISTER_SIZE];
	  LONGEST val = unpack_long (type, valbuf);

	  store_signed_integer (tmpbuf, INT_REGISTER_SIZE, byte_order, val);
	  regcache_cooked_write (regs, ARM_A1_REGNUM, tmpbuf);
	}
      else
	{
	  /* Integral values greater than one word are stored in consecutive
	     registers starting with r0.  This will always be a multiple of
	     the regiser size.  */
	  int len = TYPE_LENGTH (type);
	  int regno = ARM_A1_REGNUM;

	  while (len > 0)
	    {
	      regcache_cooked_write (regs, regno++, valbuf);
	      len -= INT_REGISTER_SIZE;
	      valbuf += INT_REGISTER_SIZE;
	    }
	}
    }
  else
    {
      /* For a structure or union the behaviour is as if the value had
         been stored to word-aligned memory and then loaded into 
         registers with 32-bit load instruction(s).  */
      int len = TYPE_LENGTH (type);
      int regno = ARM_A1_REGNUM;
      bfd_byte tmpbuf[INT_REGISTER_SIZE];

      while (len > 0)
	{
	  memcpy (tmpbuf, valbuf,
		  len > INT_REGISTER_SIZE ? INT_REGISTER_SIZE : len);
	  regcache_cooked_write (regs, regno++, tmpbuf);
	  len -= INT_REGISTER_SIZE;
	  valbuf += INT_REGISTER_SIZE;
	}
    }
}


/* Handle function return values.  */

static enum return_value_convention
arm_return_value (struct gdbarch *gdbarch, struct value *function,
		  struct type *valtype, struct regcache *regcache,
		  gdb_byte *readbuf, const gdb_byte *writebuf)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  struct type *func_type = function ? value_type (function) : NULL;
  enum arm_vfp_cprc_base_type vfp_base_type;
  int vfp_base_count;

  if (arm_vfp_abi_for_function (gdbarch, func_type)
      && arm_vfp_call_candidate (valtype, &vfp_base_type, &vfp_base_count))
    {
      int reg_char = arm_vfp_cprc_reg_char (vfp_base_type);
      int unit_length = arm_vfp_cprc_unit_length (vfp_base_type);
      int i;
      for (i = 0; i < vfp_base_count; i++)
	{
	  if (reg_char == 'q')
	    {
	      if (writebuf)
		arm_neon_quad_write (gdbarch, regcache, i,
				     writebuf + i * unit_length);

	      if (readbuf)
		arm_neon_quad_read (gdbarch, regcache, i,
				    readbuf + i * unit_length);
	    }
	  else
	    {
	      char name_buf[4];
	      int regnum;

	      xsnprintf (name_buf, sizeof (name_buf), "%c%d", reg_char, i);
	      regnum = user_reg_map_name_to_regnum (gdbarch, name_buf,
						    strlen (name_buf));
	      if (writebuf)
		regcache_cooked_write (regcache, regnum,
				       writebuf + i * unit_length);
	      if (readbuf)
		regcache_cooked_read (regcache, regnum,
				      readbuf + i * unit_length);
	    }
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }

  if (TYPE_CODE (valtype) == TYPE_CODE_STRUCT
      || TYPE_CODE (valtype) == TYPE_CODE_UNION
      || TYPE_CODE (valtype) == TYPE_CODE_ARRAY)
    {
      if (tdep->struct_return == pcc_struct_return
	  || arm_return_in_memory (gdbarch, valtype))
	return RETURN_VALUE_STRUCT_CONVENTION;
    }

  /* AAPCS returns complex types longer than a register in memory.  */
  if (tdep->arm_abi != ARM_ABI_APCS
      && TYPE_CODE (valtype) == TYPE_CODE_COMPLEX
      && TYPE_LENGTH (valtype) > INT_REGISTER_SIZE)
    return RETURN_VALUE_STRUCT_CONVENTION;

  if (writebuf)
    arm_store_return_value (valtype, regcache, writebuf);

  if (readbuf)
    arm_extract_return_value (valtype, regcache, readbuf);

  return RETURN_VALUE_REGISTER_CONVENTION;
}


static int
arm_get_longjmp_target (struct frame_info *frame, CORE_ADDR *pc)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  CORE_ADDR jb_addr;
  gdb_byte buf[INT_REGISTER_SIZE];
  
  jb_addr = get_frame_register_unsigned (frame, ARM_A1_REGNUM);

  if (target_read_memory (jb_addr + tdep->jb_pc * tdep->jb_elt_size, buf,
			  INT_REGISTER_SIZE))
    return 0;

  *pc = extract_unsigned_integer (buf, INT_REGISTER_SIZE, byte_order);
  return 1;
}

/* Recognize GCC and GNU ld's trampolines.  If we are in a trampoline,
   return the target PC.  Otherwise return 0.  */

CORE_ADDR
arm_skip_stub (struct frame_info *frame, CORE_ADDR pc)
{
  const char *name;
  int namelen;
  CORE_ADDR start_addr;

  /* Find the starting address and name of the function containing the PC.  */
  if (find_pc_partial_function (pc, &name, &start_addr, NULL) == 0)
    return 0;

  /* If PC is in a Thumb call or return stub, return the address of the
     target PC, which is in a register.  The thunk functions are called
     _call_via_xx, where x is the register name.  The possible names
     are r0-r9, sl, fp, ip, sp, and lr.  ARM RealView has similar
     functions, named __ARM_call_via_r[0-7].  */
  if (strncmp (name, "_call_via_", 10) == 0
      || strncmp (name, "__ARM_call_via_", strlen ("__ARM_call_via_")) == 0)
    {
      /* Use the name suffix to determine which register contains the
         target PC.  */
      static char *table[15] =
      {"r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
       "r8", "r9", "sl", "fp", "ip", "sp", "lr"
      };
      int regno;
      int offset = strlen (name) - 2;

      for (regno = 0; regno <= 14; regno++)
	if (strcmp (&name[offset], table[regno]) == 0)
	  return get_frame_register_unsigned (frame, regno);
    }

  /* GNU ld generates __foo_from_arm or __foo_from_thumb for
     non-interworking calls to foo.  We could decode the stubs
     to find the target but it's easier to use the symbol table.  */
  namelen = strlen (name);
  if (name[0] == '_' && name[1] == '_'
      && ((namelen > 2 + strlen ("_from_thumb")
	   && strncmp (name + namelen - strlen ("_from_thumb"), "_from_thumb",
		       strlen ("_from_thumb")) == 0)
	  || (namelen > 2 + strlen ("_from_arm")
	      && strncmp (name + namelen - strlen ("_from_arm"), "_from_arm",
			  strlen ("_from_arm")) == 0)))
    {
      char *target_name;
      int target_len = namelen - 2;
      struct minimal_symbol *minsym;
      struct objfile *objfile;
      struct obj_section *sec;

      if (name[namelen - 1] == 'b')
	target_len -= strlen ("_from_thumb");
      else
	target_len -= strlen ("_from_arm");

      target_name = alloca (target_len + 1);
      memcpy (target_name, name + 2, target_len);
      target_name[target_len] = '\0';

      sec = find_pc_section (pc);
      objfile = (sec == NULL) ? NULL : sec->objfile;
      minsym = lookup_minimal_symbol (target_name, NULL, objfile);
      if (minsym != NULL)
	return SYMBOL_VALUE_ADDRESS (minsym);
      else
	return 0;
    }

  return 0;			/* not a stub */
}

static void
set_arm_command (char *args, int from_tty)
{
  printf_unfiltered (_("\
\"set arm\" must be followed by an apporpriate subcommand.\n"));
  help_list (setarmcmdlist, "set arm ", all_commands, gdb_stdout);
}

static void
show_arm_command (char *args, int from_tty)
{
  cmd_show_list (showarmcmdlist, from_tty, "");
}

static void
arm_update_current_architecture (void)
{
  struct gdbarch_info info;

  /* If the current architecture is not ARM, we have nothing to do.  */
  if (gdbarch_bfd_arch_info (target_gdbarch ())->arch != bfd_arch_arm)
    return;

  /* Update the architecture.  */
  gdbarch_info_init (&info);

  if (!gdbarch_update_p (info))
    internal_error (__FILE__, __LINE__, _("could not update architecture"));
}

static void
set_fp_model_sfunc (char *args, int from_tty,
		    struct cmd_list_element *c)
{
  enum arm_float_model fp_model;

  for (fp_model = ARM_FLOAT_AUTO; fp_model != ARM_FLOAT_LAST; fp_model++)
    if (strcmp (current_fp_model, fp_model_strings[fp_model]) == 0)
      {
	arm_fp_model = fp_model;
	break;
      }

  if (fp_model == ARM_FLOAT_LAST)
    internal_error (__FILE__, __LINE__, _("Invalid fp model accepted: %s."),
		    current_fp_model);

  arm_update_current_architecture ();
}

static void
show_fp_model (struct ui_file *file, int from_tty,
	       struct cmd_list_element *c, const char *value)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (target_gdbarch ());

  if (arm_fp_model == ARM_FLOAT_AUTO
      && gdbarch_bfd_arch_info (target_gdbarch ())->arch == bfd_arch_arm)
    fprintf_filtered (file, _("\
The current ARM floating point model is \"auto\" (currently \"%s\").\n"),
		      fp_model_strings[tdep->fp_model]);
  else
    fprintf_filtered (file, _("\
The current ARM floating point model is \"%s\".\n"),
		      fp_model_strings[arm_fp_model]);
}

static void
arm_set_abi (char *args, int from_tty,
	     struct cmd_list_element *c)
{
  enum arm_abi_kind arm_abi;

  for (arm_abi = ARM_ABI_AUTO; arm_abi != ARM_ABI_LAST; arm_abi++)
    if (strcmp (arm_abi_string, arm_abi_strings[arm_abi]) == 0)
      {
	arm_abi_global = arm_abi;
	break;
      }

  if (arm_abi == ARM_ABI_LAST)
    internal_error (__FILE__, __LINE__, _("Invalid ABI accepted: %s."),
		    arm_abi_string);

  arm_update_current_architecture ();
}

static void
arm_show_abi (struct ui_file *file, int from_tty,
	     struct cmd_list_element *c, const char *value)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (target_gdbarch ());

  if (arm_abi_global == ARM_ABI_AUTO
      && gdbarch_bfd_arch_info (target_gdbarch ())->arch == bfd_arch_arm)
    fprintf_filtered (file, _("\
The current ARM ABI is \"auto\" (currently \"%s\").\n"),
		      arm_abi_strings[tdep->arm_abi]);
  else
    fprintf_filtered (file, _("The current ARM ABI is \"%s\".\n"),
		      arm_abi_string);
}

static void
arm_show_fallback_mode (struct ui_file *file, int from_tty,
			struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file,
		    _("The current execution mode assumed "
		      "(when symbols are unavailable) is \"%s\".\n"),
		    arm_fallback_mode_string);
}

static void
arm_show_force_mode (struct ui_file *file, int from_tty,
		     struct cmd_list_element *c, const char *value)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (target_gdbarch ());

  fprintf_filtered (file,
		    _("The current execution mode assumed "
		      "(even when symbols are available) is \"%s\".\n"),
		    arm_force_mode_string);
}

/* If the user changes the register disassembly style used for info
   register and other commands, we have to also switch the style used
   in opcodes for disassembly output.  This function is run in the "set
   arm disassembly" command, and does that.  */

static void
set_disassembly_style_sfunc (char *args, int from_tty,
			      struct cmd_list_element *c)
{
  set_disassembly_style ();
}

/* Return the ARM register name corresponding to register I.  */
static const char *
arm_register_name (struct gdbarch *gdbarch, int i)
{
  const int num_regs = gdbarch_num_regs (gdbarch);

  if (gdbarch_tdep (gdbarch)->have_vfp_pseudos
      && i >= num_regs && i < num_regs + 32)
    {
      static const char *const vfp_pseudo_names[] = {
	"s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7",
	"s8", "s9", "s10", "s11", "s12", "s13", "s14", "s15",
	"s16", "s17", "s18", "s19", "s20", "s21", "s22", "s23",
	"s24", "s25", "s26", "s27", "s28", "s29", "s30", "s31",
      };

      return vfp_pseudo_names[i - num_regs];
    }

  if (gdbarch_tdep (gdbarch)->have_neon_pseudos
      && i >= num_regs + 32 && i < num_regs + 32 + 16)
    {
      static const char *const neon_pseudo_names[] = {
	"q0", "q1", "q2", "q3", "q4", "q5", "q6", "q7",
	"q8", "q9", "q10", "q11", "q12", "q13", "q14", "q15",
      };

      return neon_pseudo_names[i - num_regs - 32];
    }

  if (i >= ARRAY_SIZE (arm_register_names))
    /* These registers are only supported on targets which supply
       an XML description.  */
    return "";

  return arm_register_names[i];
}

static void
set_disassembly_style (void)
{
  int current;

  /* Find the style that the user wants.  */
  for (current = 0; current < num_disassembly_options; current++)
    if (disassembly_style == valid_disassembly_styles[current])
      break;
  gdb_assert (current < num_disassembly_options);

  /* Synchronize the disassembler.  */
  set_arm_regname_option (current);
}

/* Test whether the coff symbol specific value corresponds to a Thumb
   function.  */

static int
coff_sym_is_thumb (int val)
{
  return (val == C_THUMBEXT
	  || val == C_THUMBSTAT
	  || val == C_THUMBEXTFUNC
	  || val == C_THUMBSTATFUNC
	  || val == C_THUMBLABEL);
}

/* arm_coff_make_msymbol_special()
   arm_elf_make_msymbol_special()
   
   These functions test whether the COFF or ELF symbol corresponds to
   an address in thumb code, and set a "special" bit in a minimal
   symbol to indicate that it does.  */
   
static void
arm_elf_make_msymbol_special(asymbol *sym, struct minimal_symbol *msym)
{
  if (ARM_SYM_BRANCH_TYPE (&((elf_symbol_type *)sym)->internal_elf_sym)
      == ST_BRANCH_TO_THUMB)
    MSYMBOL_SET_SPECIAL (msym);
}

static void
arm_coff_make_msymbol_special(int val, struct minimal_symbol *msym)
{
  if (coff_sym_is_thumb (val))
    MSYMBOL_SET_SPECIAL (msym);
}

static void
arm_objfile_data_free (struct objfile *objfile, void *arg)
{
  struct arm_per_objfile *data = arg;
  unsigned int i;

  for (i = 0; i < objfile->obfd->section_count; i++)
    VEC_free (arm_mapping_symbol_s, data->section_maps[i]);
}

static void
arm_record_special_symbol (struct gdbarch *gdbarch, struct objfile *objfile,
			   asymbol *sym)
{
  const char *name = bfd_asymbol_name (sym);
  struct arm_per_objfile *data;
  VEC(arm_mapping_symbol_s) **map_p;
  struct arm_mapping_symbol new_map_sym;

  gdb_assert (name[0] == '$');
  if (name[1] != 'a' && name[1] != 't' && name[1] != 'd')
    return;

  data = objfile_data (objfile, arm_objfile_data_key);
  if (data == NULL)
    {
      data = OBSTACK_ZALLOC (&objfile->objfile_obstack,
			     struct arm_per_objfile);
      set_objfile_data (objfile, arm_objfile_data_key, data);
      data->section_maps = OBSTACK_CALLOC (&objfile->objfile_obstack,
					   objfile->obfd->section_count,
					   VEC(arm_mapping_symbol_s) *);
    }
  map_p = &data->section_maps[bfd_get_section (sym)->index];

  new_map_sym.value = sym->value;
  new_map_sym.type = name[1];

  /* Assume that most mapping symbols appear in order of increasing
     value.  If they were randomly distributed, it would be faster to
     always push here and then sort at first use.  */
  if (!VEC_empty (arm_mapping_symbol_s, *map_p))
    {
      struct arm_mapping_symbol *prev_map_sym;

      prev_map_sym = VEC_last (arm_mapping_symbol_s, *map_p);
      if (prev_map_sym->value >= sym->value)
	{
	  unsigned int idx;
	  idx = VEC_lower_bound (arm_mapping_symbol_s, *map_p, &new_map_sym,
				 arm_compare_mapping_symbols);
	  VEC_safe_insert (arm_mapping_symbol_s, *map_p, idx, &new_map_sym);
	  return;
	}
    }

  VEC_safe_push (arm_mapping_symbol_s, *map_p, &new_map_sym);
}

static void
arm_write_pc (struct regcache *regcache, CORE_ADDR pc)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  regcache_cooked_write_unsigned (regcache, ARM_PC_REGNUM, pc);

  /* If necessary, set the T bit.  */
  if (arm_apcs_32)
    {
      ULONGEST val, t_bit;
      regcache_cooked_read_unsigned (regcache, ARM_PS_REGNUM, &val);
      t_bit = arm_psr_thumb_bit (gdbarch);
      if (arm_pc_is_thumb (gdbarch, pc))
	regcache_cooked_write_unsigned (regcache, ARM_PS_REGNUM,
					val | t_bit);
      else
	regcache_cooked_write_unsigned (regcache, ARM_PS_REGNUM,
					val & ~t_bit);
    }
}

/* Read the contents of a NEON quad register, by reading from two
   double registers.  This is used to implement the quad pseudo
   registers, and for argument passing in case the quad registers are
   missing; vectors are passed in quad registers when using the VFP
   ABI, even if a NEON unit is not present.  REGNUM is the index of
   the quad register, in [0, 15].  */

static enum register_status
arm_neon_quad_read (struct gdbarch *gdbarch, struct regcache *regcache,
		    int regnum, gdb_byte *buf)
{
  char name_buf[4];
  gdb_byte reg_buf[8];
  int offset, double_regnum;
  enum register_status status;

  xsnprintf (name_buf, sizeof (name_buf), "d%d", regnum << 1);
  double_regnum = user_reg_map_name_to_regnum (gdbarch, name_buf,
					       strlen (name_buf));

  /* d0 is always the least significant half of q0.  */
  if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
    offset = 8;
  else
    offset = 0;

  status = regcache_raw_read (regcache, double_regnum, reg_buf);
  if (status != REG_VALID)
    return status;
  memcpy (buf + offset, reg_buf, 8);

  offset = 8 - offset;
  status = regcache_raw_read (regcache, double_regnum + 1, reg_buf);
  if (status != REG_VALID)
    return status;
  memcpy (buf + offset, reg_buf, 8);

  return REG_VALID;
}

static enum register_status
arm_pseudo_read (struct gdbarch *gdbarch, struct regcache *regcache,
		 int regnum, gdb_byte *buf)
{
  const int num_regs = gdbarch_num_regs (gdbarch);
  char name_buf[4];
  gdb_byte reg_buf[8];
  int offset, double_regnum;

  gdb_assert (regnum >= num_regs);
  regnum -= num_regs;

  if (gdbarch_tdep (gdbarch)->have_neon_pseudos && regnum >= 32 && regnum < 48)
    /* Quad-precision register.  */
    return arm_neon_quad_read (gdbarch, regcache, regnum - 32, buf);
  else
    {
      enum register_status status;

      /* Single-precision register.  */
      gdb_assert (regnum < 32);

      /* s0 is always the least significant half of d0.  */
      if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
	offset = (regnum & 1) ? 0 : 4;
      else
	offset = (regnum & 1) ? 4 : 0;

      xsnprintf (name_buf, sizeof (name_buf), "d%d", regnum >> 1);
      double_regnum = user_reg_map_name_to_regnum (gdbarch, name_buf,
						   strlen (name_buf));

      status = regcache_raw_read (regcache, double_regnum, reg_buf);
      if (status == REG_VALID)
	memcpy (buf, reg_buf + offset, 4);
      return status;
    }
}

/* Store the contents of BUF to a NEON quad register, by writing to
   two double registers.  This is used to implement the quad pseudo
   registers, and for argument passing in case the quad registers are
   missing; vectors are passed in quad registers when using the VFP
   ABI, even if a NEON unit is not present.  REGNUM is the index
   of the quad register, in [0, 15].  */

static void
arm_neon_quad_write (struct gdbarch *gdbarch, struct regcache *regcache,
		     int regnum, const gdb_byte *buf)
{
  char name_buf[4];
  int offset, double_regnum;

  xsnprintf (name_buf, sizeof (name_buf), "d%d", regnum << 1);
  double_regnum = user_reg_map_name_to_regnum (gdbarch, name_buf,
					       strlen (name_buf));

  /* d0 is always the least significant half of q0.  */
  if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
    offset = 8;
  else
    offset = 0;

  regcache_raw_write (regcache, double_regnum, buf + offset);
  offset = 8 - offset;
  regcache_raw_write (regcache, double_regnum + 1, buf + offset);
}

static void
arm_pseudo_write (struct gdbarch *gdbarch, struct regcache *regcache,
		  int regnum, const gdb_byte *buf)
{
  const int num_regs = gdbarch_num_regs (gdbarch);
  char name_buf[4];
  gdb_byte reg_buf[8];
  int offset, double_regnum;

  gdb_assert (regnum >= num_regs);
  regnum -= num_regs;

  if (gdbarch_tdep (gdbarch)->have_neon_pseudos && regnum >= 32 && regnum < 48)
    /* Quad-precision register.  */
    arm_neon_quad_write (gdbarch, regcache, regnum - 32, buf);
  else
    {
      /* Single-precision register.  */
      gdb_assert (regnum < 32);

      /* s0 is always the least significant half of d0.  */
      if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
	offset = (regnum & 1) ? 0 : 4;
      else
	offset = (regnum & 1) ? 4 : 0;

      xsnprintf (name_buf, sizeof (name_buf), "d%d", regnum >> 1);
      double_regnum = user_reg_map_name_to_regnum (gdbarch, name_buf,
						   strlen (name_buf));

      regcache_raw_read (regcache, double_regnum, reg_buf);
      memcpy (reg_buf + offset, buf, 4);
      regcache_raw_write (regcache, double_regnum, reg_buf);
    }
}

static struct value *
value_of_arm_user_reg (struct frame_info *frame, const void *baton)
{
  const int *reg_p = baton;
  return value_of_register (*reg_p, frame);
}

static enum gdb_osabi
arm_elf_osabi_sniffer (bfd *abfd)
{
  unsigned int elfosabi;
  enum gdb_osabi osabi = GDB_OSABI_UNKNOWN;

  elfosabi = elf_elfheader (abfd)->e_ident[EI_OSABI];

  if (elfosabi == ELFOSABI_ARM)
    /* GNU tools use this value.  Check note sections in this case,
       as well.  */
    bfd_map_over_sections (abfd,
			   generic_elf_osabi_sniff_abi_tag_sections, 
			   &osabi);

  /* Anything else will be handled by the generic ELF sniffer.  */
  return osabi;
}

static int
arm_register_reggroup_p (struct gdbarch *gdbarch, int regnum,
			  struct reggroup *group)
{
  /* FPS register's type is INT, but belongs to float_reggroup.  Beside
     this, FPS register belongs to save_regroup, restore_reggroup, and
     all_reggroup, of course.  */
  if (regnum == ARM_FPS_REGNUM)
    return (group == float_reggroup
	    || group == save_reggroup
	    || group == restore_reggroup
	    || group == all_reggroup);
  else
    return default_register_reggroup_p (gdbarch, regnum, group);
}


/* For backward-compatibility we allow two 'g' packet lengths with
   the remote protocol depending on whether FPA registers are
   supplied.  M-profile targets do not have FPA registers, but some
   stubs already exist in the wild which use a 'g' packet which
   supplies them albeit with dummy values.  The packet format which
   includes FPA registers should be considered deprecated for
   M-profile targets.  */

static void
arm_register_g_packet_guesses (struct gdbarch *gdbarch)
{
  if (gdbarch_tdep (gdbarch)->is_m)
    {
      /* If we know from the executable this is an M-profile target,
	 cater for remote targets whose register set layout is the
	 same as the FPA layout.  */
      register_remote_g_packet_guess (gdbarch,
				      /* r0-r12,sp,lr,pc; f0-f7; fps,xpsr */
				      (16 * INT_REGISTER_SIZE)
				      + (8 * FP_REGISTER_SIZE)
				      + (2 * INT_REGISTER_SIZE),
				      tdesc_arm_with_m_fpa_layout);

      /* The regular M-profile layout.  */
      register_remote_g_packet_guess (gdbarch,
				      /* r0-r12,sp,lr,pc; xpsr */
				      (16 * INT_REGISTER_SIZE)
				      + INT_REGISTER_SIZE,
				      tdesc_arm_with_m);

      /* M-profile plus M4F VFP.  */
      register_remote_g_packet_guess (gdbarch,
				      /* r0-r12,sp,lr,pc; d0-d15; fpscr,xpsr */
				      (16 * INT_REGISTER_SIZE)
				      + (16 * VFP_REGISTER_SIZE)
				      + (2 * INT_REGISTER_SIZE),
				      tdesc_arm_with_m_vfp_d16);
    }

  /* Otherwise we don't have a useful guess.  */
}


/* Initialize the current architecture based on INFO.  If possible,
   re-use an architecture from ARCHES, which is a list of
   architectures already created during this debugging session.

   Called e.g. at program startup, when reading a core file, and when
   reading a binary file.  */

static struct gdbarch *
arm_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
{
  struct gdbarch_tdep *tdep;
  struct gdbarch *gdbarch;
  struct gdbarch_list *best_arch;
  enum arm_abi_kind arm_abi = arm_abi_global;
  enum arm_float_model fp_model = arm_fp_model;
  struct tdesc_arch_data *tdesc_data = NULL;
  int i, is_m = 0;
  int have_vfp_registers = 0, have_vfp_pseudos = 0, have_neon_pseudos = 0;
  int have_neon = 0;
  int have_fpa_registers = 1;
  const struct target_desc *tdesc = info.target_desc;

  /* If we have an object to base this architecture on, try to determine
     its ABI.  */

  if (arm_abi == ARM_ABI_AUTO && info.abfd != NULL)
    {
      int ei_osabi, e_flags;

      switch (bfd_get_flavour (info.abfd))
	{
	case bfd_target_aout_flavour:
	  /* Assume it's an old APCS-style ABI.  */
	  arm_abi = ARM_ABI_APCS;
	  break;

	case bfd_target_coff_flavour:
	  /* Assume it's an old APCS-style ABI.  */
	  /* XXX WinCE?  */
	  arm_abi = ARM_ABI_APCS;
	  break;

	case bfd_target_elf_flavour:
	  ei_osabi = elf_elfheader (info.abfd)->e_ident[EI_OSABI];
	  e_flags = elf_elfheader (info.abfd)->e_flags;

	  if (ei_osabi == ELFOSABI_ARM)
	    {
	      /* GNU tools used to use this value, but do not for EABI
		 objects.  There's nowhere to tag an EABI version
		 anyway, so assume APCS.  */
	      arm_abi = ARM_ABI_APCS;
	    }
	  else if (ei_osabi == ELFOSABI_NONE)
	    {
	      int eabi_ver = EF_ARM_EABI_VERSION (e_flags);
	      int attr_arch, attr_profile;

	      switch (eabi_ver)
		{
		case EF_ARM_EABI_UNKNOWN:
		  /* Assume GNU tools.  */
		  arm_abi = ARM_ABI_APCS;
		  break;

		case EF_ARM_EABI_VER4:
		case EF_ARM_EABI_VER5:
		  arm_abi = ARM_ABI_AAPCS;
		  /* EABI binaries default to VFP float ordering.
		     They may also contain build attributes that can
		     be used to identify if the VFP argument-passing
		     ABI is in use.  */
		  if (fp_model == ARM_FLOAT_AUTO)
		    {
#ifdef HAVE_ELF
		      switch (bfd_elf_get_obj_attr_int (info.abfd,
							OBJ_ATTR_PROC,
							Tag_ABI_VFP_args))
			{
			case 0:
			  /* "The user intended FP parameter/result
			     passing to conform to AAPCS, base
			     variant".  */
			  fp_model = ARM_FLOAT_SOFT_VFP;
			  break;
			case 1:
			  /* "The user intended FP parameter/result
			     passing to conform to AAPCS, VFP
			     variant".  */
			  fp_model = ARM_FLOAT_VFP;
			  break;
			case 2:
			  /* "The user intended FP parameter/result
			     passing to conform to tool chain-specific
			     conventions" - we don't know any such
			     conventions, so leave it as "auto".  */
			  break;
			default:
			  /* Attribute value not mentioned in the
			     October 2008 ABI, so leave it as
			     "auto".  */
			  break;
			}
#else
		      fp_model = ARM_FLOAT_SOFT_VFP;
#endif
		    }
		  break;

		default:
		  /* Leave it as "auto".  */
		  warning (_("unknown ARM EABI version 0x%x"), eabi_ver);
		  break;
		}

#ifdef HAVE_ELF
	      /* Detect M-profile programs.  This only works if the
		 executable file includes build attributes; GCC does
		 copy them to the executable, but e.g. RealView does
		 not.  */
	      attr_arch = bfd_elf_get_obj_attr_int (info.abfd, OBJ_ATTR_PROC,
						    Tag_CPU_arch);
	      attr_profile = bfd_elf_get_obj_attr_int (info.abfd,
						       OBJ_ATTR_PROC,
						       Tag_CPU_arch_profile);
	      /* GCC specifies the profile for v6-M; RealView only
		 specifies the profile for architectures starting with
		 V7 (as opposed to architectures with a tag
		 numerically greater than TAG_CPU_ARCH_V7).  */
	      if (!tdesc_has_registers (tdesc)
		  && (attr_arch == TAG_CPU_ARCH_V6_M
		      || attr_arch == TAG_CPU_ARCH_V6S_M
		      || attr_profile == 'M'))
		is_m = 1;
#endif
	    }

	  if (fp_model == ARM_FLOAT_AUTO)
	    {
	      int e_flags = elf_elfheader (info.abfd)->e_flags;

	      switch (e_flags & (EF_ARM_SOFT_FLOAT | EF_ARM_VFP_FLOAT))
		{
		case 0:
		  /* Leave it as "auto".  Strictly speaking this case
		     means FPA, but almost nobody uses that now, and
		     many toolchains fail to set the appropriate bits
		     for the floating-point model they use.  */
		  break;
		case EF_ARM_SOFT_FLOAT:
		  fp_model = ARM_FLOAT_SOFT_FPA;
		  break;
		case EF_ARM_VFP_FLOAT:
		  fp_model = ARM_FLOAT_VFP;
		  break;
		case EF_ARM_SOFT_FLOAT | EF_ARM_VFP_FLOAT:
		  fp_model = ARM_FLOAT_SOFT_VFP;
		  break;
		}
	    }

	  if (e_flags & EF_ARM_BE8)
	    info.byte_order_for_code = BFD_ENDIAN_LITTLE;

	  break;

	default:
	  /* Leave it as "auto".  */
	  break;
	}
    }

  /* Check any target description for validity.  */
  if (tdesc_has_registers (tdesc))
    {
      /* For most registers we require GDB's default names; but also allow
	 the numeric names for sp / lr / pc, as a convenience.  */
      static const char *const arm_sp_names[] = { "r13", "sp", NULL };
      static const char *const arm_lr_names[] = { "r14", "lr", NULL };
      static const char *const arm_pc_names[] = { "r15", "pc", NULL };

      const struct tdesc_feature *feature;
      int valid_p;

      feature = tdesc_find_feature (tdesc,
				    "org.gnu.gdb.arm.core");
      if (feature == NULL)
	{
	  feature = tdesc_find_feature (tdesc,
					"org.gnu.gdb.arm.m-profile");
	  if (feature == NULL)
	    return NULL;
	  else
	    is_m = 1;
	}

      tdesc_data = tdesc_data_alloc ();

      valid_p = 1;
      for (i = 0; i < ARM_SP_REGNUM; i++)
	valid_p &= tdesc_numbered_register (feature, tdesc_data, i,
					    arm_register_names[i]);
      valid_p &= tdesc_numbered_register_choices (feature, tdesc_data,
						  ARM_SP_REGNUM,
						  arm_sp_names);
      valid_p &= tdesc_numbered_register_choices (feature, tdesc_data,
						  ARM_LR_REGNUM,
						  arm_lr_names);
      valid_p &= tdesc_numbered_register_choices (feature, tdesc_data,
						  ARM_PC_REGNUM,
						  arm_pc_names);
      if (is_m)
	valid_p &= tdesc_numbered_register (feature, tdesc_data,
					    ARM_PS_REGNUM, "xpsr");
      else
	valid_p &= tdesc_numbered_register (feature, tdesc_data,
					    ARM_PS_REGNUM, "cpsr");

      if (!valid_p)
	{
	  tdesc_data_cleanup (tdesc_data);
	  return NULL;
	}

      feature = tdesc_find_feature (tdesc,
				    "org.gnu.gdb.arm.fpa");
      if (feature != NULL)
	{
	  valid_p = 1;
	  for (i = ARM_F0_REGNUM; i <= ARM_FPS_REGNUM; i++)
	    valid_p &= tdesc_numbered_register (feature, tdesc_data, i,
						arm_register_names[i]);
	  if (!valid_p)
	    {
	      tdesc_data_cleanup (tdesc_data);
	      return NULL;
	    }
	}
      else
	have_fpa_registers = 0;

      feature = tdesc_find_feature (tdesc,
				    "org.gnu.gdb.xscale.iwmmxt");
      if (feature != NULL)
	{
	  static const char *const iwmmxt_names[] = {
	    "wR0", "wR1", "wR2", "wR3", "wR4", "wR5", "wR6", "wR7",
	    "wR8", "wR9", "wR10", "wR11", "wR12", "wR13", "wR14", "wR15",
	    "wCID", "wCon", "wCSSF", "wCASF", "", "", "", "",
	    "wCGR0", "wCGR1", "wCGR2", "wCGR3", "", "", "", "",
	  };

	  valid_p = 1;
	  for (i = ARM_WR0_REGNUM; i <= ARM_WR15_REGNUM; i++)
	    valid_p
	      &= tdesc_numbered_register (feature, tdesc_data, i,
					  iwmmxt_names[i - ARM_WR0_REGNUM]);

	  /* Check for the control registers, but do not fail if they
	     are missing.  */
	  for (i = ARM_WC0_REGNUM; i <= ARM_WCASF_REGNUM; i++)
	    tdesc_numbered_register (feature, tdesc_data, i,
				     iwmmxt_names[i - ARM_WR0_REGNUM]);

	  for (i = ARM_WCGR0_REGNUM; i <= ARM_WCGR3_REGNUM; i++)
	    valid_p
	      &= tdesc_numbered_register (feature, tdesc_data, i,
					  iwmmxt_names[i - ARM_WR0_REGNUM]);

	  if (!valid_p)
	    {
	      tdesc_data_cleanup (tdesc_data);
	      return NULL;
	    }
	}

      /* If we have a VFP unit, check whether the single precision registers
	 are present.  If not, then we will synthesize them as pseudo
	 registers.  */
      feature = tdesc_find_feature (tdesc,
				    "org.gnu.gdb.arm.vfp");
      if (feature != NULL)
	{
	  static const char *const vfp_double_names[] = {
	    "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7",
	    "d8", "d9", "d10", "d11", "d12", "d13", "d14", "d15",
	    "d16", "d17", "d18", "d19", "d20", "d21", "d22", "d23",
	    "d24", "d25", "d26", "d27", "d28", "d29", "d30", "d31",
	  };

	  /* Require the double precision registers.  There must be either
	     16 or 32.  */
	  valid_p = 1;
	  for (i = 0; i < 32; i++)
	    {
	      valid_p &= tdesc_numbered_register (feature, tdesc_data,
						  ARM_D0_REGNUM + i,
						  vfp_double_names[i]);
	      if (!valid_p)
		break;
	    }
	  if (!valid_p && i == 16)
	    valid_p = 1;

	  /* Also require FPSCR.  */
	  valid_p &= tdesc_numbered_register (feature, tdesc_data,
					      ARM_FPSCR_REGNUM, "fpscr");
	  if (!valid_p)
	    {
	      tdesc_data_cleanup (tdesc_data);
	      return NULL;
	    }

	  if (tdesc_unnumbered_register (feature, "s0") == 0)
	    have_vfp_pseudos = 1;

	  have_vfp_registers = 1;

	  /* If we have VFP, also check for NEON.  The architecture allows
	     NEON without VFP (integer vector operations only), but GDB
	     does not support that.  */
	  feature = tdesc_find_feature (tdesc,
					"org.gnu.gdb.arm.neon");
	  if (feature != NULL)
	    {
	      /* NEON requires 32 double-precision registers.  */
	      if (i != 32)
		{
		  tdesc_data_cleanup (tdesc_data);
		  return NULL;
		}

	      /* If there are quad registers defined by the stub, use
		 their type; otherwise (normally) provide them with
		 the default type.  */
	      if (tdesc_unnumbered_register (feature, "q0") == 0)
		have_neon_pseudos = 1;

	      have_neon = 1;
	    }
	}
    }

  /* If there is already a candidate, use it.  */
  for (best_arch = gdbarch_list_lookup_by_info (arches, &info);
       best_arch != NULL;
       best_arch = gdbarch_list_lookup_by_info (best_arch->next, &info))
    {
      if (arm_abi != ARM_ABI_AUTO
	  && arm_abi != gdbarch_tdep (best_arch->gdbarch)->arm_abi)
	continue;

      if (fp_model != ARM_FLOAT_AUTO
	  && fp_model != gdbarch_tdep (best_arch->gdbarch)->fp_model)
	continue;

      /* There are various other properties in tdep that we do not
	 need to check here: those derived from a target description,
	 since gdbarches with a different target description are
	 automatically disqualified.  */

      /* Do check is_m, though, since it might come from the binary.  */
      if (is_m != gdbarch_tdep (best_arch->gdbarch)->is_m)
	continue;

      /* Found a match.  */
      break;
    }

  if (best_arch != NULL)
    {
      if (tdesc_data != NULL)
	tdesc_data_cleanup (tdesc_data);
      return best_arch->gdbarch;
    }

  tdep = xcalloc (1, sizeof (struct gdbarch_tdep));
  gdbarch = gdbarch_alloc (&info, tdep);

  /* Record additional information about the architecture we are defining.
     These are gdbarch discriminators, like the OSABI.  */
  tdep->arm_abi = arm_abi;
  tdep->fp_model = fp_model;
  tdep->is_m = is_m;
  tdep->have_fpa_registers = have_fpa_registers;
  tdep->have_vfp_registers = have_vfp_registers;
  tdep->have_vfp_pseudos = have_vfp_pseudos;
  tdep->have_neon_pseudos = have_neon_pseudos;
  tdep->have_neon = have_neon;

  arm_register_g_packet_guesses (gdbarch);

  /* Breakpoints.  */
  switch (info.byte_order_for_code)
    {
    case BFD_ENDIAN_BIG:
      tdep->arm_breakpoint = arm_default_arm_be_breakpoint;
      tdep->arm_breakpoint_size = sizeof (arm_default_arm_be_breakpoint);
      tdep->thumb_breakpoint = arm_default_thumb_be_breakpoint;
      tdep->thumb_breakpoint_size = sizeof (arm_default_thumb_be_breakpoint);

      break;

    case BFD_ENDIAN_LITTLE:
      tdep->arm_breakpoint = arm_default_arm_le_breakpoint;
      tdep->arm_breakpoint_size = sizeof (arm_default_arm_le_breakpoint);
      tdep->thumb_breakpoint = arm_default_thumb_le_breakpoint;
      tdep->thumb_breakpoint_size = sizeof (arm_default_thumb_le_breakpoint);

      break;

    default:
      internal_error (__FILE__, __LINE__,
		      _("arm_gdbarch_init: bad byte order for float format"));
    }

  /* On ARM targets char defaults to unsigned.  */
  set_gdbarch_char_signed (gdbarch, 0);

  /* Note: for displaced stepping, this includes the breakpoint, and one word
     of additional scratch space.  This setting isn't used for anything beside
     displaced stepping at present.  */
  set_gdbarch_max_insn_length (gdbarch, 4 * DISPLACED_MODIFIED_INSNS);

  /* This should be low enough for everything.  */
  tdep->lowest_pc = 0x20;
  tdep->jb_pc = -1;	/* Longjump support not enabled by default.  */

  /* The default, for both APCS and AAPCS, is to return small
     structures in registers.  */
  tdep->struct_return = reg_struct_return;

  set_gdbarch_push_dummy_call (gdbarch, arm_push_dummy_call);
  set_gdbarch_frame_align (gdbarch, arm_frame_align);

  set_gdbarch_write_pc (gdbarch, arm_write_pc);

  /* Frame handling.  */
  set_gdbarch_dummy_id (gdbarch, arm_dummy_id);
  set_gdbarch_unwind_pc (gdbarch, arm_unwind_pc);
  set_gdbarch_unwind_sp (gdbarch, arm_unwind_sp);

  frame_base_set_default (gdbarch, &arm_normal_base);

  /* Address manipulation.  */
  set_gdbarch_addr_bits_remove (gdbarch, arm_addr_bits_remove);

  /* Advance PC across function entry code.  */
  set_gdbarch_skip_prologue (gdbarch, arm_skip_prologue);

  /* Detect whether PC is in function epilogue.  */
  set_gdbarch_in_function_epilogue_p (gdbarch, arm_in_function_epilogue_p);

  /* Skip trampolines.  */
  set_gdbarch_skip_trampoline_code (gdbarch, arm_skip_stub);

  /* The stack grows downward.  */
  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);

  /* Breakpoint manipulation.  */
  set_gdbarch_breakpoint_from_pc (gdbarch, arm_breakpoint_from_pc);
  set_gdbarch_remote_breakpoint_from_pc (gdbarch,
					 arm_remote_breakpoint_from_pc);

  /* Information about registers, etc.  */
  set_gdbarch_sp_regnum (gdbarch, ARM_SP_REGNUM);
  set_gdbarch_pc_regnum (gdbarch, ARM_PC_REGNUM);
  set_gdbarch_num_regs (gdbarch, ARM_NUM_REGS);
  set_gdbarch_register_type (gdbarch, arm_register_type);
  set_gdbarch_register_reggroup_p (gdbarch, arm_register_reggroup_p);

  /* This "info float" is FPA-specific.  Use the generic version if we
     do not have FPA.  */
  if (gdbarch_tdep (gdbarch)->have_fpa_registers)
    set_gdbarch_print_float_info (gdbarch, arm_print_float_info);

  /* Internal <-> external register number maps.  */
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, arm_dwarf_reg_to_regnum);
  set_gdbarch_register_sim_regno (gdbarch, arm_register_sim_regno);

  set_gdbarch_register_name (gdbarch, arm_register_name);

  /* Returning results.  */
  set_gdbarch_return_value (gdbarch, arm_return_value);

  /* Disassembly.  */
  set_gdbarch_print_insn (gdbarch, gdb_print_insn_arm);

  /* Minsymbol frobbing.  */
  set_gdbarch_elf_make_msymbol_special (gdbarch, arm_elf_make_msymbol_special);
  set_gdbarch_coff_make_msymbol_special (gdbarch,
					 arm_coff_make_msymbol_special);
  set_gdbarch_record_special_symbol (gdbarch, arm_record_special_symbol);

  /* Thumb-2 IT block support.  */
  set_gdbarch_adjust_breakpoint_address (gdbarch,
					 arm_adjust_breakpoint_address);

  /* Virtual tables.  */
  set_gdbarch_vbit_in_delta (gdbarch, 1);

  /* Hook in the ABI-specific overrides, if they have been registered.  */
  gdbarch_init_osabi (info, gdbarch);

  dwarf2_frame_set_init_reg (gdbarch, arm_dwarf2_frame_init_reg);

  /* Add some default predicates.  */
  if (is_m)
    frame_unwind_append_unwinder (gdbarch, &arm_m_exception_unwind);
  frame_unwind_append_unwinder (gdbarch, &arm_stub_unwind);
  dwarf2_append_unwinders (gdbarch);
  frame_unwind_append_unwinder (gdbarch, &arm_exidx_unwind);
  frame_unwind_append_unwinder (gdbarch, &arm_prologue_unwind);

  /* Now we have tuned the configuration, set a few final things,
     based on what the OS ABI has told us.  */

  /* If the ABI is not otherwise marked, assume the old GNU APCS.  EABI
     binaries are always marked.  */
  if (tdep->arm_abi == ARM_ABI_AUTO)
    tdep->arm_abi = ARM_ABI_APCS;

  /* Watchpoints are not steppable.  */
  set_gdbarch_have_nonsteppable_watchpoint (gdbarch, 1);

  /* We used to default to FPA for generic ARM, but almost nobody
     uses that now, and we now provide a way for the user to force
     the model.  So default to the most useful variant.  */
  if (tdep->fp_model == ARM_FLOAT_AUTO)
    tdep->fp_model = ARM_FLOAT_SOFT_FPA;

  if (tdep->jb_pc >= 0)
    set_gdbarch_get_longjmp_target (gdbarch, arm_get_longjmp_target);

  /* Floating point sizes and format.  */
  set_gdbarch_float_format (gdbarch, floatformats_ieee_single);
  if (tdep->fp_model == ARM_FLOAT_SOFT_FPA || tdep->fp_model == ARM_FLOAT_FPA)
    {
      set_gdbarch_double_format
	(gdbarch, floatformats_ieee_double_littlebyte_bigword);
      set_gdbarch_long_double_format
	(gdbarch, floatformats_ieee_double_littlebyte_bigword);
    }
  else
    {
      set_gdbarch_double_format (gdbarch, floatformats_ieee_double);
      set_gdbarch_long_double_format (gdbarch, floatformats_ieee_double);
    }

  if (have_vfp_pseudos)
    {
      /* NOTE: These are the only pseudo registers used by
	 the ARM target at the moment.  If more are added, a
	 little more care in numbering will be needed.  */

      int num_pseudos = 32;
      if (have_neon_pseudos)
	num_pseudos += 16;
      set_gdbarch_num_pseudo_regs (gdbarch, num_pseudos);
      set_gdbarch_pseudo_register_read (gdbarch, arm_pseudo_read);
      set_gdbarch_pseudo_register_write (gdbarch, arm_pseudo_write);
    }

  if (tdesc_data)
    {
      set_tdesc_pseudo_register_name (gdbarch, arm_register_name);

      tdesc_use_registers (gdbarch, tdesc, tdesc_data);

      /* Override tdesc_register_type to adjust the types of VFP
	 registers for NEON.  */
      set_gdbarch_register_type (gdbarch, arm_register_type);
    }

  /* Add standard register aliases.  We add aliases even for those
     nanes which are used by the current architecture - it's simpler,
     and does no harm, since nothing ever lists user registers.  */
  for (i = 0; i < ARRAY_SIZE (arm_register_aliases); i++)
    user_reg_add (gdbarch, arm_register_aliases[i].name,
		  value_of_arm_user_reg, &arm_register_aliases[i].regnum);

  return gdbarch;
}

static void
arm_dump_tdep (struct gdbarch *gdbarch, struct ui_file *file)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (tdep == NULL)
    return;

  fprintf_unfiltered (file, _("arm_dump_tdep: Lowest pc = 0x%lx"),
		      (unsigned long) tdep->lowest_pc);
}

extern initialize_file_ftype _initialize_arm_tdep; /* -Wmissing-prototypes */

void
_initialize_arm_tdep (void)
{
  struct ui_file *stb;
  long length;
  struct cmd_list_element *new_set, *new_show;
  const char *setname;
  const char *setdesc;
  const char *const *regnames;
  int numregs, i, j;
  static char *helptext;
  char regdesc[1024], *rdptr = regdesc;
  size_t rest = sizeof (regdesc);

  gdbarch_register (bfd_arch_arm, arm_gdbarch_init, arm_dump_tdep);

  arm_objfile_data_key
    = register_objfile_data_with_cleanup (NULL, arm_objfile_data_free);

  /* Add ourselves to objfile event chain.  */
  observer_attach_new_objfile (arm_exidx_new_objfile);
  arm_exidx_data_key
    = register_objfile_data_with_cleanup (NULL, arm_exidx_data_free);

  /* Register an ELF OS ABI sniffer for ARM binaries.  */
  gdbarch_register_osabi_sniffer (bfd_arch_arm,
				  bfd_target_elf_flavour,
				  arm_elf_osabi_sniffer);

  /* Initialize the standard target descriptions.  */
  initialize_tdesc_arm_with_m ();
  initialize_tdesc_arm_with_m_fpa_layout ();
  initialize_tdesc_arm_with_m_vfp_d16 ();
  initialize_tdesc_arm_with_iwmmxt ();
  initialize_tdesc_arm_with_vfpv2 ();
  initialize_tdesc_arm_with_vfpv3 ();
  initialize_tdesc_arm_with_neon ();

  /* Get the number of possible sets of register names defined in opcodes.  */
  num_disassembly_options = get_arm_regname_num_options ();

  /* Add root prefix command for all "set arm"/"show arm" commands.  */
  add_prefix_cmd ("arm", no_class, set_arm_command,
		  _("Various ARM-specific commands."),
		  &setarmcmdlist, "set arm ", 0, &setlist);

  add_prefix_cmd ("arm", no_class, show_arm_command,
		  _("Various ARM-specific commands."),
		  &showarmcmdlist, "show arm ", 0, &showlist);

  /* Sync the opcode insn printer with our register viewer.  */
  parse_arm_disassembler_option ("reg-names-std");

  /* Initialize the array that will be passed to
     add_setshow_enum_cmd().  */
  valid_disassembly_styles
    = xmalloc ((num_disassembly_options + 1) * sizeof (char *));
  for (i = 0; i < num_disassembly_options; i++)
    {
      numregs = get_arm_regnames (i, &setname, &setdesc, &regnames);
      valid_disassembly_styles[i] = setname;
      length = snprintf (rdptr, rest, "%s - %s\n", setname, setdesc);
      rdptr += length;
      rest -= length;
      /* When we find the default names, tell the disassembler to use
	 them.  */
      if (!strcmp (setname, "std"))
	{
          disassembly_style = setname;
          set_arm_regname_option (i);
	}
    }
  /* Mark the end of valid options.  */
  valid_disassembly_styles[num_disassembly_options] = NULL;

  /* Create the help text.  */
  stb = mem_fileopen ();
  fprintf_unfiltered (stb, "%s%s%s",
		      _("The valid values are:\n"),
		      regdesc,
		      _("The default is \"std\"."));
  helptext = ui_file_xstrdup (stb, NULL);
  ui_file_delete (stb);

  add_setshow_enum_cmd("disassembler", no_class,
		       valid_disassembly_styles, &disassembly_style,
		       _("Set the disassembly style."),
		       _("Show the disassembly style."),
		       helptext,
		       set_disassembly_style_sfunc,
		       NULL, /* FIXME: i18n: The disassembly style is
				\"%s\".  */
		       &setarmcmdlist, &showarmcmdlist);

  add_setshow_boolean_cmd ("apcs32", no_class, &arm_apcs_32,
			   _("Set usage of ARM 32-bit mode."),
			   _("Show usage of ARM 32-bit mode."),
			   _("When off, a 26-bit PC will be used."),
			   NULL,
			   NULL, /* FIXME: i18n: Usage of ARM 32-bit
				    mode is %s.  */
			   &setarmcmdlist, &showarmcmdlist);

  /* Add a command to allow the user to force the FPU model.  */
  add_setshow_enum_cmd ("fpu", no_class, fp_model_strings, &current_fp_model,
			_("Set the floating point type."),
			_("Show the floating point type."),
			_("auto - Determine the FP typefrom the OS-ABI.\n\
softfpa - Software FP, mixed-endian doubles on little-endian ARMs.\n\
fpa - FPA co-processor (GCC compiled).\n\
softvfp - Software FP with pure-endian doubles.\n\
vfp - VFP co-processor."),
			set_fp_model_sfunc, show_fp_model,
			&setarmcmdlist, &showarmcmdlist);

  /* Add a command to allow the user to force the ABI.  */
  add_setshow_enum_cmd ("abi", class_support, arm_abi_strings, &arm_abi_string,
			_("Set the ABI."),
			_("Show the ABI."),
			NULL, arm_set_abi, arm_show_abi,
			&setarmcmdlist, &showarmcmdlist);

  /* Add two commands to allow the user to force the assumed
     execution mode.  */
  add_setshow_enum_cmd ("fallback-mode", class_support,
			arm_mode_strings, &arm_fallback_mode_string,
			_("Set the mode assumed when symbols are unavailable."),
			_("Show the mode assumed when symbols are unavailable."),
			NULL, NULL, arm_show_fallback_mode,
			&setarmcmdlist, &showarmcmdlist);
  add_setshow_enum_cmd ("force-mode", class_support,
			arm_mode_strings, &arm_force_mode_string,
			_("Set the mode assumed even when symbols are available."),
			_("Show the mode assumed even when symbols are available."),
			NULL, NULL, arm_show_force_mode,
			&setarmcmdlist, &showarmcmdlist);

  /* Debugging flag.  */
  add_setshow_boolean_cmd ("arm", class_maintenance, &arm_debug,
			   _("Set ARM debugging."),
			   _("Show ARM debugging."),
			   _("When on, arm-specific debugging is enabled."),
			   NULL,
			   NULL, /* FIXME: i18n: "ARM debugging is %s.  */
			   &setdebuglist, &showdebuglist);
}

/* ARM-reversible process record data structures.  */

#define ARM_INSN_SIZE_BYTES 4    
#define THUMB_INSN_SIZE_BYTES 2
#define THUMB2_INSN_SIZE_BYTES 4


#define INSN_S_L_BIT_NUM 20

#define REG_ALLOC(REGS, LENGTH, RECORD_BUF) \
        do  \
          { \
            unsigned int reg_len = LENGTH; \
            if (reg_len) \
              { \
                REGS = XNEWVEC (uint32_t, reg_len); \
                memcpy(&REGS[0], &RECORD_BUF[0], sizeof(uint32_t)*LENGTH); \
              } \
          } \
        while (0)

#define MEM_ALLOC(MEMS, LENGTH, RECORD_BUF) \
        do  \
          { \
            unsigned int mem_len = LENGTH; \
            if (mem_len) \
            { \
              MEMS =  XNEWVEC (struct arm_mem_r, mem_len);  \
              memcpy(&MEMS->len, &RECORD_BUF[0], \
                     sizeof(struct arm_mem_r) * LENGTH); \
            } \
          } \
          while (0)

/* Checks whether insn is already recorded or yet to be decoded. (boolean expression).  */
#define INSN_RECORDED(ARM_RECORD) \
        (0 != (ARM_RECORD)->reg_rec_count || 0 != (ARM_RECORD)->mem_rec_count)

/* ARM memory record structure.  */
struct arm_mem_r
{
  uint32_t len;    /* Record length.  */
  CORE_ADDR addr;  /* Memory address.  */
};

/* ARM instruction record contains opcode of current insn
   and execution state (before entry to decode_insn()),
   contains list of to-be-modified registers and
   memory blocks (on return from decode_insn()).  */

typedef struct insn_decode_record_t
{
  struct gdbarch *gdbarch;
  struct regcache *regcache;
  CORE_ADDR this_addr;          /* Address of the insn being decoded.  */
  uint32_t arm_insn;            /* Should accommodate thumb.  */
  uint32_t cond;                /* Condition code.  */
  uint32_t opcode;              /* Insn opcode.  */
  uint32_t decode;              /* Insn decode bits.  */
  uint32_t mem_rec_count;       /* No of mem records.  */
  uint32_t reg_rec_count;       /* No of reg records.  */
  uint32_t *arm_regs;           /* Registers to be saved for this record.  */
  struct arm_mem_r *arm_mems;   /* Memory to be saved for this record.  */
} insn_decode_record;


/* Checks ARM SBZ and SBO mandatory fields.  */

static int
sbo_sbz (uint32_t insn, uint32_t bit_num, uint32_t len, uint32_t sbo)
{
  uint32_t ones = bits (insn, bit_num - 1, (bit_num -1) + (len - 1));

  if (!len)
    return 1;

  if (!sbo)
    ones = ~ones;

  while (ones)
    {
      if (!(ones & sbo))
        {
          return 0;
        }
      ones = ones >> 1;
    }
  return 1;
}

typedef enum
{
  ARM_RECORD_STRH=1,
  ARM_RECORD_STRD
} arm_record_strx_t;

typedef enum
{
  ARM_RECORD=1,
  THUMB_RECORD,
  THUMB2_RECORD
} record_type_t;


static int
arm_record_strx (insn_decode_record *arm_insn_r, uint32_t *record_buf, 
                 uint32_t *record_buf_mem, arm_record_strx_t str_type)
{

  struct regcache *reg_cache = arm_insn_r->regcache;
  ULONGEST u_regval[2]= {0};

  uint32_t reg_src1 = 0, reg_src2 = 0;
  uint32_t immed_high = 0, immed_low = 0,offset_8 = 0, tgt_mem_addr = 0;
  uint32_t opcode1 = 0;

  arm_insn_r->opcode = bits (arm_insn_r->arm_insn, 21, 24);
  arm_insn_r->decode = bits (arm_insn_r->arm_insn, 4, 7);
  opcode1 = bits (arm_insn_r->arm_insn, 20, 24);


  if (14 == arm_insn_r->opcode || 10 == arm_insn_r->opcode)
    {
      /* 1) Handle misc store, immediate offset.  */
      immed_low = bits (arm_insn_r->arm_insn, 0, 3);
      immed_high = bits (arm_insn_r->arm_insn, 8, 11);
      reg_src1 = bits (arm_insn_r->arm_insn, 16, 19);
      regcache_raw_read_unsigned (reg_cache, reg_src1,
                                  &u_regval[0]);
      if (ARM_PC_REGNUM == reg_src1)
        {
          /* If R15 was used as Rn, hence current PC+8.  */
          u_regval[0] = u_regval[0] + 8;
        }
      offset_8 = (immed_high << 4) | immed_low;
      /* Calculate target store address.  */
      if (14 == arm_insn_r->opcode)
        {
          tgt_mem_addr = u_regval[0] + offset_8;
        }
      else
        {
          tgt_mem_addr = u_regval[0] - offset_8;
        }
      if (ARM_RECORD_STRH == str_type)
        {
          record_buf_mem[0] = 2;
          record_buf_mem[1] = tgt_mem_addr;
          arm_insn_r->mem_rec_count = 1;
        }
      else if (ARM_RECORD_STRD == str_type)
        {
          record_buf_mem[0] = 4;
          record_buf_mem[1] = tgt_mem_addr;
          record_buf_mem[2] = 4;
          record_buf_mem[3] = tgt_mem_addr + 4;
          arm_insn_r->mem_rec_count = 2;
        }
    }
  else if (12 == arm_insn_r->opcode || 8 == arm_insn_r->opcode)
    {
      /* 2) Store, register offset.  */
      /* Get Rm.  */
      reg_src1 = bits (arm_insn_r->arm_insn, 0, 3);
      /* Get Rn.  */
      reg_src2 = bits (arm_insn_r->arm_insn, 16, 19);
      regcache_raw_read_unsigned (reg_cache, reg_src1, &u_regval[0]);
      regcache_raw_read_unsigned (reg_cache, reg_src2, &u_regval[1]);
      if (15 == reg_src2)
        {
          /* If R15 was used as Rn, hence current PC+8.  */
          u_regval[0] = u_regval[0] + 8;
        }
      /* Calculate target store address, Rn +/- Rm, register offset.  */
      if (12 == arm_insn_r->opcode)
        {
          tgt_mem_addr = u_regval[0] + u_regval[1];
        }
      else
        {
          tgt_mem_addr = u_regval[1] - u_regval[0];
        }
      if (ARM_RECORD_STRH == str_type)
        {
          record_buf_mem[0] = 2;
          record_buf_mem[1] = tgt_mem_addr;
          arm_insn_r->mem_rec_count = 1;
        }
      else if (ARM_RECORD_STRD == str_type)
        {
          record_buf_mem[0] = 4;
          record_buf_mem[1] = tgt_mem_addr;
          record_buf_mem[2] = 4;
          record_buf_mem[3] = tgt_mem_addr + 4;
          arm_insn_r->mem_rec_count = 2;
        }
    }
  else if (11 == arm_insn_r->opcode || 15 == arm_insn_r->opcode
           || 2 == arm_insn_r->opcode  || 6 == arm_insn_r->opcode)
    {
      /* 3) Store, immediate pre-indexed.  */
      /* 5) Store, immediate post-indexed.  */
      immed_low = bits (arm_insn_r->arm_insn, 0, 3);
      immed_high = bits (arm_insn_r->arm_insn, 8, 11);
      offset_8 = (immed_high << 4) | immed_low;
      reg_src1 = bits (arm_insn_r->arm_insn, 16, 19);
      regcache_raw_read_unsigned (reg_cache, reg_src1, &u_regval[0]);
      /* Calculate target store address, Rn +/- Rm, register offset.  */
      if (15 == arm_insn_r->opcode || 6 == arm_insn_r->opcode)
        {
          tgt_mem_addr = u_regval[0] + offset_8;
        }
      else
        {
          tgt_mem_addr = u_regval[0] - offset_8;
        }
      if (ARM_RECORD_STRH == str_type)
        {
          record_buf_mem[0] = 2;
          record_buf_mem[1] = tgt_mem_addr;
          arm_insn_r->mem_rec_count = 1;
        }
      else if (ARM_RECORD_STRD == str_type)
        {
          record_buf_mem[0] = 4;
          record_buf_mem[1] = tgt_mem_addr;
          record_buf_mem[2] = 4;
          record_buf_mem[3] = tgt_mem_addr + 4;
          arm_insn_r->mem_rec_count = 2;
        }
      /* Record Rn also as it changes.  */
      *(record_buf) = bits (arm_insn_r->arm_insn, 16, 19);
      arm_insn_r->reg_rec_count = 1;
    }
  else if (9 == arm_insn_r->opcode || 13 == arm_insn_r->opcode
           || 0 == arm_insn_r->opcode || 4 == arm_insn_r->opcode)
    {
      /* 4) Store, register pre-indexed.  */
      /* 6) Store, register post -indexed.  */
      reg_src1 = bits (arm_insn_r->arm_insn, 0, 3);
      reg_src2 = bits (arm_insn_r->arm_insn, 16, 19);
      regcache_raw_read_unsigned (reg_cache, reg_src1, &u_regval[0]);
      regcache_raw_read_unsigned (reg_cache, reg_src2, &u_regval[1]);
      /* Calculate target store address, Rn +/- Rm, register offset.  */
      if (13 == arm_insn_r->opcode || 4 == arm_insn_r->opcode)
        {
          tgt_mem_addr = u_regval[0] + u_regval[1];
        }
      else
        {
          tgt_mem_addr = u_regval[1] - u_regval[0];
        }
      if (ARM_RECORD_STRH == str_type)
        {
          record_buf_mem[0] = 2;
          record_buf_mem[1] = tgt_mem_addr;
          arm_insn_r->mem_rec_count = 1;
        }
      else if (ARM_RECORD_STRD == str_type)
        {
          record_buf_mem[0] = 4;
          record_buf_mem[1] = tgt_mem_addr;
          record_buf_mem[2] = 4;
          record_buf_mem[3] = tgt_mem_addr + 4;
          arm_insn_r->mem_rec_count = 2;
        }
      /* Record Rn also as it changes.  */
      *(record_buf) = bits (arm_insn_r->arm_insn, 16, 19);
      arm_insn_r->reg_rec_count = 1;
    }
  return 0;
}

/* Handling ARM extension space insns.  */

static int
arm_record_extension_space (insn_decode_record *arm_insn_r)
{
  uint32_t ret = 0;  /* Return value: -1:record failure ;  0:success  */
  uint32_t opcode1 = 0, opcode2 = 0, insn_op1 = 0;
  uint32_t record_buf[8], record_buf_mem[8];
  uint32_t reg_src1 = 0;
  uint32_t immed_high = 0, immed_low = 0,offset_8 = 0, tgt_mem_addr = 0;
  struct regcache *reg_cache = arm_insn_r->regcache;
  ULONGEST u_regval = 0;

  gdb_assert (!INSN_RECORDED(arm_insn_r));
  /* Handle unconditional insn extension space.  */

  opcode1 = bits (arm_insn_r->arm_insn, 20, 27);
  opcode2 = bits (arm_insn_r->arm_insn, 4, 7);
  if (arm_insn_r->cond)
    {
      /* PLD has no affect on architectural state, it just affects
         the caches.  */
      if (5 == ((opcode1 & 0xE0) >> 5))
        {
          /* BLX(1) */
          record_buf[0] = ARM_PS_REGNUM;
          record_buf[1] = ARM_LR_REGNUM;
          arm_insn_r->reg_rec_count = 2;
        }
      /* STC2, LDC2, MCR2, MRC2, CDP2: <TBD>, co-processor insn.  */
    }


  opcode1 = bits (arm_insn_r->arm_insn, 25, 27);
  if (3 == opcode1 && bit (arm_insn_r->arm_insn, 4))
    {
      ret = -1;
      /* Undefined instruction on ARM V5; need to handle if later 
         versions define it.  */
    }

  opcode1 = bits (arm_insn_r->arm_insn, 24, 27);
  opcode2 = bits (arm_insn_r->arm_insn, 4, 7);
  insn_op1 = bits (arm_insn_r->arm_insn, 20, 23);

  /* Handle arithmetic insn extension space.  */
  if (!opcode1 && 9 == opcode2 && 1 != arm_insn_r->cond
      && !INSN_RECORDED(arm_insn_r))
    {
      /* Handle MLA(S) and MUL(S).  */
      if (0 <= insn_op1 && 3 >= insn_op1)
      {
        record_buf[0] = bits (arm_insn_r->arm_insn, 12, 15);
        record_buf[1] = ARM_PS_REGNUM;
        arm_insn_r->reg_rec_count = 2;
      }
      else if (4 <= insn_op1 && 15 >= insn_op1)
      {
        /* Handle SMLAL(S), SMULL(S), UMLAL(S), UMULL(S).  */
        record_buf[0] = bits (arm_insn_r->arm_insn, 16, 19);
        record_buf[1] = bits (arm_insn_r->arm_insn, 12, 15);
        record_buf[2] = ARM_PS_REGNUM;
        arm_insn_r->reg_rec_count = 3;
      }
    }

  opcode1 = bits (arm_insn_r->arm_insn, 26, 27);
  opcode2 = bits (arm_insn_r->arm_insn, 23, 24);
  insn_op1 = bits (arm_insn_r->arm_insn, 21, 22);

  /* Handle control insn extension space.  */

  if (!opcode1 && 2 == opcode2 && !bit (arm_insn_r->arm_insn, 20)
      && 1 != arm_insn_r->cond && !INSN_RECORDED(arm_insn_r))
    {
      if (!bit (arm_insn_r->arm_insn,25))
        {
          if (!bits (arm_insn_r->arm_insn, 4, 7))
            {
              if ((0 == insn_op1) || (2 == insn_op1))
                {
                  /* MRS.  */
                  record_buf[0] = bits (arm_insn_r->arm_insn, 12, 15);
                  arm_insn_r->reg_rec_count = 1;
                }
              else if (1 == insn_op1)
                {
                  /* CSPR is going to be changed.  */
                  record_buf[0] = ARM_PS_REGNUM;
                  arm_insn_r->reg_rec_count = 1;
                }
              else if (3 == insn_op1)
                {
                  /* SPSR is going to be changed.  */
                  /* We need to get SPSR value, which is yet to be done.  */
                  printf_unfiltered (_("Process record does not support "
                                     "instruction  0x%0x at address %s.\n"),
                                     arm_insn_r->arm_insn,
                                     paddress (arm_insn_r->gdbarch, 
                                     arm_insn_r->this_addr));
                  return -1;
                }
            }
          else if (1 == bits (arm_insn_r->arm_insn, 4, 7))
            {
              if (1 == insn_op1)
                {
                  /* BX.  */
                  record_buf[0] = ARM_PS_REGNUM;
                  arm_insn_r->reg_rec_count = 1;
                }
              else if (3 == insn_op1)
                {
                  /* CLZ.  */
                  record_buf[0] = bits (arm_insn_r->arm_insn, 12, 15);
                  arm_insn_r->reg_rec_count = 1;
                }
            }
          else if (3 == bits (arm_insn_r->arm_insn, 4, 7))
            {
              /* BLX.  */
              record_buf[0] = ARM_PS_REGNUM;
              record_buf[1] = ARM_LR_REGNUM;
              arm_insn_r->reg_rec_count = 2;
            }
          else if (5 == bits (arm_insn_r->arm_insn, 4, 7))
            {
              /* QADD, QSUB, QDADD, QDSUB */
              record_buf[0] = ARM_PS_REGNUM;
              record_buf[1] = bits (arm_insn_r->arm_insn, 12, 15);
              arm_insn_r->reg_rec_count = 2;
            }
          else if (7 == bits (arm_insn_r->arm_insn, 4, 7))
            {
              /* BKPT.  */
              record_buf[0] = ARM_PS_REGNUM;
              record_buf[1] = ARM_LR_REGNUM;
              arm_insn_r->reg_rec_count = 2;

              /* Save SPSR also;how?  */
              printf_unfiltered (_("Process record does not support "
                                  "instruction 0x%0x at address %s.\n"),
                                  arm_insn_r->arm_insn,
                  paddress (arm_insn_r->gdbarch, arm_insn_r->this_addr));
              return -1;
            }
          else if(8 == bits (arm_insn_r->arm_insn, 4, 7) 
                  || 10 == bits (arm_insn_r->arm_insn, 4, 7)
                  || 12 == bits (arm_insn_r->arm_insn, 4, 7)
                  || 14 == bits (arm_insn_r->arm_insn, 4, 7)
                 )
            {
              if (0 == insn_op1 || 1 == insn_op1)
                {
                  /* SMLA<x><y>, SMLAW<y>, SMULW<y>.  */
                  /* We dont do optimization for SMULW<y> where we
                     need only Rd.  */
                  record_buf[0] = bits (arm_insn_r->arm_insn, 12, 15);
                  record_buf[1] = ARM_PS_REGNUM;
                  arm_insn_r->reg_rec_count = 2;
                }
              else if (2 == insn_op1)
                {
                  /* SMLAL<x><y>.  */
                  record_buf[0] = bits (arm_insn_r->arm_insn, 12, 15);
                  record_buf[1] = bits (arm_insn_r->arm_insn, 16, 19);
                  arm_insn_r->reg_rec_count = 2;
                }
              else if (3 == insn_op1)
                {
                  /* SMUL<x><y>.  */
                  record_buf[0] = bits (arm_insn_r->arm_insn, 12, 15);
                  arm_insn_r->reg_rec_count = 1;
                }
            }
        }
      else
        {
          /* MSR : immediate form.  */
          if (1 == insn_op1)
            {
              /* CSPR is going to be changed.  */
              record_buf[0] = ARM_PS_REGNUM;
              arm_insn_r->reg_rec_count = 1;
            }
          else if (3 == insn_op1)
            {
              /* SPSR is going to be changed.  */
              /* we need to get SPSR value, which is yet to be done  */
              printf_unfiltered (_("Process record does not support "
                                   "instruction 0x%0x at address %s.\n"),
                                    arm_insn_r->arm_insn,
                                    paddress (arm_insn_r->gdbarch, 
                                    arm_insn_r->this_addr));
              return -1;
            }
        }
    }

  opcode1 = bits (arm_insn_r->arm_insn, 25, 27);
  opcode2 = bits (arm_insn_r->arm_insn, 20, 24);
  insn_op1 = bits (arm_insn_r->arm_insn, 5, 6);

  /* Handle load/store insn extension space.  */

  if (!opcode1 && bit (arm_insn_r->arm_insn, 7) 
      && bit (arm_insn_r->arm_insn, 4) && 1 != arm_insn_r->cond
      && !INSN_RECORDED(arm_insn_r))
    {
      /* SWP/SWPB.  */
      if (0 == insn_op1)
        {
          /* These insn, changes register and memory as well.  */
          /* SWP or SWPB insn.  */
          /* Get memory address given by Rn.  */
          reg_src1 = bits (arm_insn_r->arm_insn, 16, 19);
          regcache_raw_read_unsigned (reg_cache, reg_src1, &u_regval);
          /* SWP insn ?, swaps word.  */
          if (8 == arm_insn_r->opcode)
            {
              record_buf_mem[0] = 4;
            }
          else
            {
              /* SWPB insn, swaps only byte.  */
              record_buf_mem[0] = 1;
            }
          record_buf_mem[1] = u_regval;
          arm_insn_r->mem_rec_count = 1;
          record_buf[0] = bits (arm_insn_r->arm_insn, 12, 15);
          arm_insn_r->reg_rec_count = 1;
        }
      else if (1 == insn_op1 && !bit (arm_insn_r->arm_insn, 20))
        {
          /* STRH.  */
          arm_record_strx(arm_insn_r, &record_buf[0], &record_buf_mem[0],
                          ARM_RECORD_STRH);
        }
      else if (2 == insn_op1 && !bit (arm_insn_r->arm_insn, 20))
        {
          /* LDRD.  */
          record_buf[0] = bits (arm_insn_r->arm_insn, 12, 15);
          record_buf[1] = record_buf[0] + 1;
          arm_insn_r->reg_rec_count = 2;
        }
      else if (3 == insn_op1 && !bit (arm_insn_r->arm_insn, 20))
        {
          /* STRD.  */
          arm_record_strx(arm_insn_r, &record_buf[0], &record_buf_mem[0],
                        ARM_RECORD_STRD);
        }
      else if (bit (arm_insn_r->arm_insn, 20) && insn_op1 <= 3)
        {
          /* LDRH, LDRSB, LDRSH.  */
          record_buf[0] = bits (arm_insn_r->arm_insn, 12, 15);
          arm_insn_r->reg_rec_count = 1;
        }

    }

  opcode1 = bits (arm_insn_r->arm_insn, 23, 27);
  if (24 == opcode1 && bit (arm_insn_r->arm_insn, 21)
      && !INSN_RECORDED(arm_insn_r))
    {
      ret = -1;
      /* Handle coprocessor insn extension space.  */
    }

  /* To be done for ARMv5 and later; as of now we return -1.  */
  if (-1 == ret)
    printf_unfiltered (_("Process record does not support instruction x%0x "
                         "at address %s.\n"),arm_insn_r->arm_insn,
                         paddress (arm_insn_r->gdbarch, arm_insn_r->this_addr));


  REG_ALLOC (arm_insn_r->arm_regs, arm_insn_r->reg_rec_count, record_buf);
  MEM_ALLOC (arm_insn_r->arm_mems, arm_insn_r->mem_rec_count, record_buf_mem);

  return ret;
}

/* Handling opcode 000 insns.  */

static int
arm_record_data_proc_misc_ld_str (insn_decode_record *arm_insn_r)
{
  struct regcache *reg_cache = arm_insn_r->regcache;
  uint32_t record_buf[8], record_buf_mem[8];
  ULONGEST u_regval[2] = {0};

  uint32_t reg_src1 = 0, reg_src2 = 0, reg_dest = 0;
  uint32_t immed_high = 0, immed_low = 0, offset_8 = 0, tgt_mem_addr = 0;
  uint32_t opcode1 = 0;

  arm_insn_r->opcode = bits (arm_insn_r->arm_insn, 21, 24);
  arm_insn_r->decode = bits (arm_insn_r->arm_insn, 4, 7);
  opcode1 = bits (arm_insn_r->arm_insn, 20, 24);

  /* Data processing insn /multiply insn.  */
  if (9 == arm_insn_r->decode
      && ((4 <= arm_insn_r->opcode && 7 >= arm_insn_r->opcode)
      ||  (0 == arm_insn_r->opcode || 1 == arm_insn_r->opcode)))
    {
      /* Handle multiply instructions.  */
      /* MLA, MUL, SMLAL, SMULL, UMLAL, UMULL.  */
        if (0 == arm_insn_r->opcode || 1 == arm_insn_r->opcode)
          {
            /* Handle MLA and MUL.  */
            record_buf[0] = bits (arm_insn_r->arm_insn, 16, 19);
            record_buf[1] = ARM_PS_REGNUM;
            arm_insn_r->reg_rec_count = 2;
          }
        else if (4 <= arm_insn_r->opcode && 7 >= arm_insn_r->opcode)
          {
            /* Handle SMLAL, SMULL, UMLAL, UMULL.  */
            record_buf[0] = bits (arm_insn_r->arm_insn, 16, 19);
            record_buf[1] = bits (arm_insn_r->arm_insn, 12, 15);
            record_buf[2] = ARM_PS_REGNUM;
            arm_insn_r->reg_rec_count = 3;
          }
    }
  else if (bit (arm_insn_r->arm_insn, INSN_S_L_BIT_NUM)
           && (11 == arm_insn_r->decode || 13 == arm_insn_r->decode))
    {
      /* Handle misc load insns, as 20th bit  (L = 1).  */
      /* LDR insn has a capability to do branching, if
         MOV LR, PC is precceded by LDR insn having Rn as R15
         in that case, it emulates branch and link insn, and hence we 
         need to save CSPR and PC as well. I am not sure this is right
         place; as opcode = 010 LDR insn make this happen, if R15 was
         used.  */
      reg_dest = bits (arm_insn_r->arm_insn, 12, 15);
      if (15 != reg_dest)
        {
          record_buf[0] = bits (arm_insn_r->arm_insn, 12, 15);
          arm_insn_r->reg_rec_count = 1;
        }
      else
        {
          record_buf[0] = reg_dest;
          record_buf[1] = ARM_PS_REGNUM;
          arm_insn_r->reg_rec_count = 2;
        }
    }
  else if ((9 == arm_insn_r->opcode || 11 == arm_insn_r->opcode)
           && sbo_sbz (arm_insn_r->arm_insn, 5, 12, 0)
           && sbo_sbz (arm_insn_r->arm_insn, 13, 4, 1)
           && 2 == bits (arm_insn_r->arm_insn, 20, 21))
    {
      /* Handle MSR insn.  */
      if (9 == arm_insn_r->opcode)
        {
          /* CSPR is going to be changed.  */
          record_buf[0] = ARM_PS_REGNUM;
          arm_insn_r->reg_rec_count = 1;
        }
      else
        {
          /* SPSR is going to be changed.  */
          /* How to read SPSR value?  */
          printf_unfiltered (_("Process record does not support instruction "
                            "0x%0x at address %s.\n"),
                            arm_insn_r->arm_insn,
                        paddress (arm_insn_r->gdbarch, arm_insn_r->this_addr));
          return -1;
        }
    }
  else if (9 == arm_insn_r->decode
           && (8 == arm_insn_r->opcode || 10 == arm_insn_r->opcode)
           && !bit (arm_insn_r->arm_insn, INSN_S_L_BIT_NUM))
    {
      /* Handling SWP, SWPB.  */
      /* These insn, changes register and memory as well.  */
      /* SWP or SWPB insn.  */

      reg_src1 = bits (arm_insn_r->arm_insn, 16, 19);
      regcache_raw_read_unsigned (reg_cache, reg_src1, &u_regval[0]);
      /* SWP insn ?, swaps word.  */
      if (8 == arm_insn_r->opcode)
        {
          record_buf_mem[0] = 4;
        }
        else
        {
          /* SWPB insn, swaps only byte.  */
          record_buf_mem[0] = 1;
        }
      record_buf_mem[1] = u_regval[0];
      arm_insn_r->mem_rec_count = 1;
      record_buf[0] = bits (arm_insn_r->arm_insn, 12, 15);
      arm_insn_r->reg_rec_count = 1;
    }
  else if (3 == arm_insn_r->decode && 0x12 == opcode1
           && sbo_sbz (arm_insn_r->arm_insn, 9, 12, 1))
    {
      /* Handle BLX, branch and link/exchange.  */
      if (9 == arm_insn_r->opcode)
      {
        /* Branch is chosen by setting T bit of CSPR, bitp[0] of Rm,
           and R14 stores the return address.  */
        record_buf[0] = ARM_PS_REGNUM;
        record_buf[1] = ARM_LR_REGNUM;
        arm_insn_r->reg_rec_count = 2;
      }
    }
  else if (7 == arm_insn_r->decode && 0x12 == opcode1)
    {
      /* Handle enhanced software breakpoint insn, BKPT.  */
      /* CPSR is changed to be executed in ARM state,  disabling normal
         interrupts, entering abort mode.  */
      /* According to high vector configuration PC is set.  */
      /* user hit breakpoint and type reverse, in
         that case, we need to go back with previous CPSR and
         Program Counter.  */
      record_buf[0] = ARM_PS_REGNUM;
      record_buf[1] = ARM_LR_REGNUM;
      arm_insn_r->reg_rec_count = 2;

      /* Save SPSR also; how?  */
      printf_unfiltered (_("Process record does not support instruction "
                           "0x%0x at address %s.\n"),arm_insn_r->arm_insn,
                           paddress (arm_insn_r->gdbarch, 
                           arm_insn_r->this_addr));
      return -1;
    }
  else if (11 == arm_insn_r->decode
           && !bit (arm_insn_r->arm_insn, INSN_S_L_BIT_NUM))
  {
    /* Handle enhanced store insns and DSP insns (e.g. LDRD).  */

    /* Handle str(x) insn */
    arm_record_strx(arm_insn_r, &record_buf[0], &record_buf_mem[0],
                    ARM_RECORD_STRH);
  }
  else if (1 == arm_insn_r->decode && 0x12 == opcode1
           && sbo_sbz (arm_insn_r->arm_insn, 9, 12, 1))
    {
      /* Handle BX, branch and link/exchange.  */
      /* Branch is chosen by setting T bit of CSPR, bitp[0] of Rm.  */
      record_buf[0] = ARM_PS_REGNUM;
      arm_insn_r->reg_rec_count = 1;
    }
  else if (1 == arm_insn_r->decode && 0x16 == opcode1
           && sbo_sbz (arm_insn_r->arm_insn, 9, 4, 1)
           && sbo_sbz (arm_insn_r->arm_insn, 17, 4, 1))
    {
      /* Count leading zeros: CLZ.  */
      record_buf[0] = bits (arm_insn_r->arm_insn, 12, 15);
      arm_insn_r->reg_rec_count = 1;
    }
  else if (!bit (arm_insn_r->arm_insn, INSN_S_L_BIT_NUM)
           && (8 == arm_insn_r->opcode || 10 == arm_insn_r->opcode)
           && sbo_sbz (arm_insn_r->arm_insn, 17, 4, 1)
           && sbo_sbz (arm_insn_r->arm_insn, 1, 12, 0)
          )
    {
      /* Handle MRS insn.  */
      record_buf[0] = bits (arm_insn_r->arm_insn, 12, 15);
      arm_insn_r->reg_rec_count = 1;
    }
  else if (arm_insn_r->opcode <= 15)
    {
      /* Normal data processing insns.  */
      /* Out of 11 shifter operands mode, all the insn modifies destination
         register, which is specified by 13-16 decode.  */
      record_buf[0] = bits (arm_insn_r->arm_insn, 12, 15);
      record_buf[1] = ARM_PS_REGNUM;
      arm_insn_r->reg_rec_count = 2;
    }
  else
    {
      return -1;
    }

  REG_ALLOC (arm_insn_r->arm_regs, arm_insn_r->reg_rec_count, record_buf);
  MEM_ALLOC (arm_insn_r->arm_mems, arm_insn_r->mem_rec_count, record_buf_mem);
  return 0;
}

/* Handling opcode 001 insns.  */

static int
arm_record_data_proc_imm (insn_decode_record *arm_insn_r)
{
  uint32_t record_buf[8], record_buf_mem[8];

  arm_insn_r->opcode = bits (arm_insn_r->arm_insn, 21, 24);
  arm_insn_r->decode = bits (arm_insn_r->arm_insn, 4, 7);

  if ((9 == arm_insn_r->opcode || 11 == arm_insn_r->opcode)
      && 2 == bits (arm_insn_r->arm_insn, 20, 21)
      && sbo_sbz (arm_insn_r->arm_insn, 13, 4, 1)
     )
    {
      /* Handle MSR insn.  */
      if (9 == arm_insn_r->opcode)
        {
          /* CSPR is going to be changed.  */
          record_buf[0] = ARM_PS_REGNUM;
          arm_insn_r->reg_rec_count = 1;
        }
      else
        {
          /* SPSR is going to be changed.  */
        }
    }
  else if (arm_insn_r->opcode <= 15)
    {
      /* Normal data processing insns.  */
      /* Out of 11 shifter operands mode, all the insn modifies destination
         register, which is specified by 13-16 decode.  */
      record_buf[0] = bits (arm_insn_r->arm_insn, 12, 15);
      record_buf[1] = ARM_PS_REGNUM;
      arm_insn_r->reg_rec_count = 2;
    }
  else
    {
      return -1;
    }

  REG_ALLOC (arm_insn_r->arm_regs, arm_insn_r->reg_rec_count, record_buf);
  MEM_ALLOC (arm_insn_r->arm_mems, arm_insn_r->mem_rec_count, record_buf_mem);
  return 0;
}

/* Handling opcode 010 insns.  */

static int
arm_record_ld_st_imm_offset (insn_decode_record *arm_insn_r)
{
  struct regcache *reg_cache = arm_insn_r->regcache;

  uint32_t reg_src1 = 0 , reg_dest = 0;
  uint32_t offset_12 = 0, tgt_mem_addr = 0;
  uint32_t record_buf[8], record_buf_mem[8];

  ULONGEST u_regval = 0;

  arm_insn_r->opcode = bits (arm_insn_r->arm_insn, 21, 24);
  arm_insn_r->decode = bits (arm_insn_r->arm_insn, 4, 7);

  if (bit (arm_insn_r->arm_insn, INSN_S_L_BIT_NUM))
    {
      reg_dest = bits (arm_insn_r->arm_insn, 12, 15);
      /* LDR insn has a capability to do branching, if
         MOV LR, PC is precedded by LDR insn having Rn as R15
         in that case, it emulates branch and link insn, and hence we
         need to save CSPR and PC as well.  */
      if (ARM_PC_REGNUM != reg_dest)
        {
          record_buf[0] = bits (arm_insn_r->arm_insn, 12, 15);
          arm_insn_r->reg_rec_count = 1;
        }
      else
        {
          record_buf[0] = reg_dest;
          record_buf[1] = ARM_PS_REGNUM;
          arm_insn_r->reg_rec_count = 2;
        }
    }
  else
    {
      /* Store, immediate offset, immediate pre-indexed,
         immediate post-indexed.  */
      reg_src1 = bits (arm_insn_r->arm_insn, 16, 19);
      offset_12 = bits (arm_insn_r->arm_insn, 0, 11);
      regcache_raw_read_unsigned (reg_cache, reg_src1, &u_regval);
      /* U == 1 */
      if (bit (arm_insn_r->arm_insn, 23))
        {
          tgt_mem_addr = u_regval + offset_12;
        }
      else
        {
          tgt_mem_addr = u_regval - offset_12;
        }

      switch (arm_insn_r->opcode)
        {
          /* STR.  */
          case 8:
          case 12:
          /* STR.  */
          case 9:
          case 13:
          /* STRT.  */    
          case 1:
          case 5:
          /* STR.  */    
          case 4:
          case 0:
            record_buf_mem[0] = 4;
          break;

          /* STRB.  */
          case 10:
          case 14:
          /* STRB.  */    
          case 11:
          case 15:
          /* STRBT.  */    
          case 3:
          case 7:
          /* STRB.  */    
          case 2:
          case 6:
            record_buf_mem[0] = 1;
          break;

          default:
            gdb_assert_not_reached ("no decoding pattern found");
          break;
        }
      record_buf_mem[1] = tgt_mem_addr;
      arm_insn_r->mem_rec_count = 1;

      if (9 == arm_insn_r->opcode || 11 == arm_insn_r->opcode
          || 13 == arm_insn_r->opcode || 15 == arm_insn_r->opcode
          || 0 == arm_insn_r->opcode || 2 == arm_insn_r->opcode
          || 4 == arm_insn_r->opcode || 6 == arm_insn_r->opcode
          || 1 == arm_insn_r->opcode || 3 == arm_insn_r->opcode
          || 5 == arm_insn_r->opcode || 7 == arm_insn_r->opcode
         )
        {
          /* We are handling pre-indexed mode; post-indexed mode;
             where Rn is going to be changed.  */
          record_buf[0] = reg_src1;
          arm_insn_r->reg_rec_count = 1;
        }
    }

  REG_ALLOC (arm_insn_r->arm_regs, arm_insn_r->reg_rec_count, record_buf);
  MEM_ALLOC (arm_insn_r->arm_mems, arm_insn_r->mem_rec_count, record_buf_mem);
  return 0;
}

/* Handling opcode 011 insns.  */

static int
arm_record_ld_st_reg_offset (insn_decode_record *arm_insn_r)
{
  struct regcache *reg_cache = arm_insn_r->regcache;

  uint32_t shift_imm = 0;
  uint32_t reg_src1 = 0, reg_src2 = 0, reg_dest = 0;
  uint32_t offset_12 = 0, tgt_mem_addr = 0;
  uint32_t record_buf[8], record_buf_mem[8];

  LONGEST s_word;
  ULONGEST u_regval[2];

  arm_insn_r->opcode = bits (arm_insn_r->arm_insn, 21, 24);
  arm_insn_r->decode = bits (arm_insn_r->arm_insn, 4, 7);

  /* Handle enhanced store insns and LDRD DSP insn,
     order begins according to addressing modes for store insns
     STRH insn.  */

  /* LDR or STR?  */
  if (bit (arm_insn_r->arm_insn, INSN_S_L_BIT_NUM))
    {
      reg_dest = bits (arm_insn_r->arm_insn, 12, 15);
      /* LDR insn has a capability to do branching, if
         MOV LR, PC is precedded by LDR insn having Rn as R15
         in that case, it emulates branch and link insn, and hence we
         need to save CSPR and PC as well.  */
      if (15 != reg_dest)
        {
          record_buf[0] = bits (arm_insn_r->arm_insn, 12, 15);
          arm_insn_r->reg_rec_count = 1;
        }
      else
        {
          record_buf[0] = reg_dest;
          record_buf[1] = ARM_PS_REGNUM;
          arm_insn_r->reg_rec_count = 2;
        }
    }
  else
    {
      if (! bits (arm_insn_r->arm_insn, 4, 11))
        {
          /* Store insn, register offset and register pre-indexed,
             register post-indexed.  */
          /* Get Rm.  */
          reg_src1 = bits (arm_insn_r->arm_insn, 0, 3);
          /* Get Rn.  */
          reg_src2 = bits (arm_insn_r->arm_insn, 16, 19);
          regcache_raw_read_unsigned (reg_cache, reg_src1
                                      , &u_regval[0]);
          regcache_raw_read_unsigned (reg_cache, reg_src2
                                      , &u_regval[1]);
          if (15 == reg_src2)
            {
              /* If R15 was used as Rn, hence current PC+8.  */
              /* Pre-indexed mode doesnt reach here ; illegal insn.  */
                u_regval[0] = u_regval[0] + 8;
            }
          /* Calculate target store address, Rn +/- Rm, register offset.  */
          /* U == 1.  */
          if (bit (arm_insn_r->arm_insn, 23))
            {
              tgt_mem_addr = u_regval[0] + u_regval[1];
            }
          else
            {
              tgt_mem_addr = u_regval[1] - u_regval[0];
            }

          switch (arm_insn_r->opcode)
            {
              /* STR.  */
              case 8:
              case 12:
              /* STR.  */    
              case 9:
              case 13:
              /* STRT.  */
              case 1:
              case 5:
              /* STR.  */
              case 0:
              case 4:
                record_buf_mem[0] = 4;
              break;

              /* STRB.  */
              case 10:
              case 14:
              /* STRB.  */
              case 11:
              case 15:
              /* STRBT.  */    
              case 3:
              case 7:
              /* STRB.  */
              case 2:
              case 6:
                record_buf_mem[0] = 1;
              break;

              default:
                gdb_assert_not_reached ("no decoding pattern found");
              break;
            }
          record_buf_mem[1] = tgt_mem_addr;
          arm_insn_r->mem_rec_count = 1;

          if (9 == arm_insn_r->opcode || 11 == arm_insn_r->opcode
              || 13 == arm_insn_r->opcode || 15 == arm_insn_r->opcode
              || 0 == arm_insn_r->opcode || 2 == arm_insn_r->opcode
              || 4 == arm_insn_r->opcode || 6 == arm_insn_r->opcode
              || 1 == arm_insn_r->opcode || 3 == arm_insn_r->opcode
              || 5 == arm_insn_r->opcode || 7 == arm_insn_r->opcode
             )
            {
              /* Rn is going to be changed in pre-indexed mode and
                 post-indexed mode as well.  */
              record_buf[0] = reg_src2;
              arm_insn_r->reg_rec_count = 1;
            }
        }
      else
        {
          /* Store insn, scaled register offset; scaled pre-indexed.  */
          offset_12 = bits (arm_insn_r->arm_insn, 5, 6);
          /* Get Rm.  */
          reg_src1 = bits (arm_insn_r->arm_insn, 0, 3);
          /* Get Rn.  */
          reg_src2 = bits (arm_insn_r->arm_insn, 16, 19);
          /* Get shift_imm.  */
          shift_imm = bits (arm_insn_r->arm_insn, 7, 11);
          regcache_raw_read_unsigned (reg_cache, reg_src1, &u_regval[0]);
          regcache_raw_read_signed (reg_cache, reg_src1, &s_word);
          regcache_raw_read_unsigned (reg_cache, reg_src2, &u_regval[1]);
          /* Offset_12 used as shift.  */
          switch (offset_12)
            {
              case 0:
                /* Offset_12 used as index.  */
                offset_12 = u_regval[0] << shift_imm;
              break;

              case 1:
                offset_12 = (!shift_imm)?0:u_regval[0] >> shift_imm;
              break;

              case 2:
                if (!shift_imm)
                  {
                    if (bit (u_regval[0], 31))
                      {
                        offset_12 = 0xFFFFFFFF;
                      }
                    else
                      {
                        offset_12 = 0;
                      }
                  }
                else
                  {
                    /* This is arithmetic shift.  */
                    offset_12 = s_word >> shift_imm;
                  }
                break;

              case 3:
                if (!shift_imm)
                  {
                    regcache_raw_read_unsigned (reg_cache, ARM_PS_REGNUM,
                                                &u_regval[1]);
                    /* Get C flag value and shift it by 31.  */
                    offset_12 = (((bit (u_regval[1], 29)) << 31) \
                                  | (u_regval[0]) >> 1);
                  }
                else
                  {
                    offset_12 = (u_regval[0] >> shift_imm) \
                                | (u_regval[0] <<
                                (sizeof(uint32_t) - shift_imm));
                  }
              break;

              default:
                gdb_assert_not_reached ("no decoding pattern found");
              break;
            }

          regcache_raw_read_unsigned (reg_cache, reg_src2, &u_regval[1]);
          /* bit U set.  */
          if (bit (arm_insn_r->arm_insn, 23))
            {
              tgt_mem_addr = u_regval[1] + offset_12;
            }
          else
            {
              tgt_mem_addr = u_regval[1] - offset_12;
            }

          switch (arm_insn_r->opcode)
            {
              /* STR.  */
              case 8:
              case 12:
              /* STR.  */    
              case 9:
              case 13:
              /* STRT.  */
              case 1:
              case 5:
              /* STR.  */
              case 0:
              case 4:
                record_buf_mem[0] = 4;
              break;

              /* STRB.  */
              case 10:
              case 14:
              /* STRB.  */
              case 11:
              case 15:
              /* STRBT.  */    
              case 3:
              case 7:
              /* STRB.  */
              case 2:
              case 6:
                record_buf_mem[0] = 1;
              break;

              default:
                gdb_assert_not_reached ("no decoding pattern found");
              break;
            }
          record_buf_mem[1] = tgt_mem_addr;
          arm_insn_r->mem_rec_count = 1;

          if (9 == arm_insn_r->opcode || 11 == arm_insn_r->opcode
              || 13 == arm_insn_r->opcode || 15 == arm_insn_r->opcode
              || 0 == arm_insn_r->opcode || 2 == arm_insn_r->opcode
              || 4 == arm_insn_r->opcode || 6 == arm_insn_r->opcode
              || 1 == arm_insn_r->opcode || 3 == arm_insn_r->opcode
              || 5 == arm_insn_r->opcode || 7 == arm_insn_r->opcode
             )
            {
              /* Rn is going to be changed in register scaled pre-indexed
                 mode,and scaled post indexed mode.  */
              record_buf[0] = reg_src2;
              arm_insn_r->reg_rec_count = 1;
            }
        }
    }

  REG_ALLOC (arm_insn_r->arm_regs, arm_insn_r->reg_rec_count, record_buf);
  MEM_ALLOC (arm_insn_r->arm_mems, arm_insn_r->mem_rec_count, record_buf_mem);
  return 0;
}

/* Handling opcode 100 insns.  */

static int
arm_record_ld_st_multiple (insn_decode_record *arm_insn_r)
{
  struct regcache *reg_cache = arm_insn_r->regcache;

  uint32_t register_list[16] = {0}, register_count = 0, register_bits = 0;
  uint32_t reg_src1 = 0, addr_mode = 0, no_of_regs = 0;
  uint32_t start_address = 0, index = 0;
  uint32_t record_buf[24], record_buf_mem[48];

  ULONGEST u_regval[2] = {0};

  /* This mode is exclusively for load and store multiple.  */
  /* Handle incremenrt after/before and decrment after.before mode;
     Rn is changing depending on W bit, but as of now we store Rn too
     without optimization.  */

  if (bit (arm_insn_r->arm_insn, INSN_S_L_BIT_NUM))
    {
      /* LDM  (1,2,3) where LDM  (3) changes CPSR too.  */

      if (bit (arm_insn_r->arm_insn, 20) && !bit (arm_insn_r->arm_insn, 22))
        {
          register_bits = bits (arm_insn_r->arm_insn, 0, 15);
          no_of_regs = 15;
        }
      else
        {
          register_bits = bits (arm_insn_r->arm_insn, 0, 14);
          no_of_regs = 14;
        }
      /* Get Rn.  */
      reg_src1 = bits (arm_insn_r->arm_insn, 16, 19);
      while (register_bits)
      {
        if (register_bits & 0x00000001)
          register_list[register_count++] = 1;
        register_bits = register_bits >> 1;
      }

        /* Extra space for Base Register and CPSR; wihtout optimization.  */
        record_buf[register_count] = reg_src1;
        record_buf[register_count + 1] = ARM_PS_REGNUM;
        arm_insn_r->reg_rec_count = register_count + 2;

        for (register_count = 0; register_count < no_of_regs; register_count++)
          {
            if  (register_list[register_count])
              {
                /* Register_count gives total no of registers
                and dually working as reg number.  */
                record_buf[index] = register_count;
                index++;
              }
          }

    }
  else
    {
      /* It handles both STM(1) and STM(2).  */
      addr_mode = bits (arm_insn_r->arm_insn, 23, 24);    

      register_bits = bits (arm_insn_r->arm_insn, 0, 15);
      /* Get Rn.  */
      reg_src1 = bits (arm_insn_r->arm_insn, 16, 19);
      regcache_raw_read_unsigned (reg_cache, reg_src1, &u_regval[0]);
      while (register_bits)
        {
          if (register_bits & 0x00000001)
            register_count++;
          register_bits = register_bits >> 1;
        }

      switch (addr_mode)
        {
          /* Decrement after.  */
          case 0:                          
            start_address = (u_regval[0]) - (register_count * 4) + 4;
            arm_insn_r->mem_rec_count = register_count;
            while (register_count)
              {
                record_buf_mem[(register_count * 2) - 1] = start_address;
                record_buf_mem[(register_count * 2) - 2] = 4;
                start_address = start_address + 4;
                register_count--;
              }
          break;    

          /* Increment after.  */
          case 1:
            start_address = u_regval[0];
            arm_insn_r->mem_rec_count = register_count;
            while (register_count)
              {
                record_buf_mem[(register_count * 2) - 1] = start_address;
                record_buf_mem[(register_count * 2) - 2] = 4;
                start_address = start_address + 4;
                register_count--;
              }
          break;    

          /* Decrement before.  */
          case 2:

            start_address = (u_regval[0]) - (register_count * 4);
            arm_insn_r->mem_rec_count = register_count;
            while (register_count)
              {
                record_buf_mem[(register_count * 2) - 1] = start_address;
                record_buf_mem[(register_count * 2) - 2] = 4;
                start_address = start_address + 4;
                register_count--;
              }
          break;    

          /* Increment before.  */
          case 3:
            start_address = u_regval[0] + 4;
            arm_insn_r->mem_rec_count = register_count;
            while (register_count)
              {
                record_buf_mem[(register_count * 2) - 1] = start_address;
                record_buf_mem[(register_count * 2) - 2] = 4;
                start_address = start_address + 4;
                register_count--;
              }
          break;    

          default:
            gdb_assert_not_reached ("no decoding pattern found");
          break;    
        }

      /* Base register also changes; based on condition and W bit.  */
      /* We save it anyway without optimization.  */
      record_buf[0] = reg_src1;
      arm_insn_r->reg_rec_count = 1;
    }

  REG_ALLOC (arm_insn_r->arm_regs, arm_insn_r->reg_rec_count, record_buf);
  MEM_ALLOC (arm_insn_r->arm_mems, arm_insn_r->mem_rec_count, record_buf_mem);
  return 0;
}

/* Handling opcode 101 insns.  */

static int
arm_record_b_bl (insn_decode_record *arm_insn_r)
{
  uint32_t record_buf[8];

  /* Handle B, BL, BLX(1) insns.  */
  /* B simply branches so we do nothing here.  */
  /* Note: BLX(1) doesnt fall here but instead it falls into
     extension space.  */
  if (bit (arm_insn_r->arm_insn, 24))
  {
    record_buf[0] = ARM_LR_REGNUM;
    arm_insn_r->reg_rec_count = 1;
  }

  REG_ALLOC (arm_insn_r->arm_regs, arm_insn_r->reg_rec_count, record_buf);

  return 0;
}

/* Handling opcode 110 insns.  */

static int
arm_record_coproc (insn_decode_record *arm_insn_r)
{
  printf_unfiltered (_("Process record does not support instruction "
                    "0x%0x at address %s.\n"),arm_insn_r->arm_insn,
                    paddress (arm_insn_r->gdbarch, arm_insn_r->this_addr));

  return -1;
}

/* Handling opcode 111 insns.  */

static int
arm_record_coproc_data_proc (insn_decode_record *arm_insn_r)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (arm_insn_r->gdbarch);
  struct regcache *reg_cache = arm_insn_r->regcache;
  uint32_t ret = 0; /* function return value: -1:record failure ;  0:success  */

  /* Handle SWI insn; system call would be handled over here.  */

  arm_insn_r->opcode = bits (arm_insn_r->arm_insn, 24, 27);
  if (15 == arm_insn_r->opcode)
  {
    /* Handle arm syscall insn.  */
    if (tdep->arm_swi_record != NULL)
      {
        ret = tdep->arm_swi_record(reg_cache);
      }
    else
      {
        printf_unfiltered (_("no syscall record support\n"));
        ret = -1;
      }
  }

  printf_unfiltered (_("Process record does not support instruction "
                        "0x%0x at address %s.\n"),arm_insn_r->arm_insn,
                        paddress (arm_insn_r->gdbarch, arm_insn_r->this_addr));
  return ret;
}

/* Handling opcode 000 insns.  */

static int
thumb_record_shift_add_sub (insn_decode_record *thumb_insn_r)
{
  uint32_t record_buf[8];
  uint32_t reg_src1 = 0;

  reg_src1 = bits (thumb_insn_r->arm_insn, 0, 2);

  record_buf[0] = ARM_PS_REGNUM;
  record_buf[1] = reg_src1;
  thumb_insn_r->reg_rec_count = 2;

  REG_ALLOC (thumb_insn_r->arm_regs, thumb_insn_r->reg_rec_count, record_buf);

  return 0;
}


/* Handling opcode 001 insns.  */

static int
thumb_record_add_sub_cmp_mov (insn_decode_record *thumb_insn_r)
{
  uint32_t record_buf[8];
  uint32_t reg_src1 = 0;

  reg_src1 = bits (thumb_insn_r->arm_insn, 8, 10);

  record_buf[0] = ARM_PS_REGNUM;
  record_buf[1] = reg_src1;
  thumb_insn_r->reg_rec_count = 2;

  REG_ALLOC (thumb_insn_r->arm_regs, thumb_insn_r->reg_rec_count, record_buf);

  return 0;
}

/* Handling opcode 010 insns.  */

static int
thumb_record_ld_st_reg_offset (insn_decode_record *thumb_insn_r)
{
  struct regcache *reg_cache =  thumb_insn_r->regcache;
  uint32_t record_buf[8], record_buf_mem[8];

  uint32_t reg_src1 = 0, reg_src2 = 0;
  uint32_t opcode1 = 0, opcode2 = 0, opcode3 = 0;

  ULONGEST u_regval[2] = {0};

  opcode1 = bits (thumb_insn_r->arm_insn, 10, 12);

  if (bit (thumb_insn_r->arm_insn, 12))
    {
      /* Handle load/store register offset.  */
      opcode2 = bits (thumb_insn_r->arm_insn, 9, 10);
      if (opcode2 >= 12 && opcode2 <= 15)
        {
          /* LDR(2), LDRB(2) , LDRH(2), LDRSB, LDRSH.  */
          reg_src1 = bits (thumb_insn_r->arm_insn,0, 2);
          record_buf[0] = reg_src1;
          thumb_insn_r->reg_rec_count = 1;
        }
      else if (opcode2 >= 8 && opcode2 <= 10)
        {
          /* STR(2), STRB(2), STRH(2) .  */
          reg_src1 = bits (thumb_insn_r->arm_insn, 3, 5);
          reg_src2 = bits (thumb_insn_r->arm_insn, 6, 8);
          regcache_raw_read_unsigned (reg_cache, reg_src1, &u_regval[0]);
          regcache_raw_read_unsigned (reg_cache, reg_src2, &u_regval[1]);
          if (8 == opcode2)
            record_buf_mem[0] = 4;    /* STR (2).  */
          else if (10 == opcode2)
            record_buf_mem[0] = 1;    /*  STRB (2).  */
          else if (9 == opcode2)
            record_buf_mem[0] = 2;    /* STRH (2).  */
          record_buf_mem[1] = u_regval[0] + u_regval[1];
          thumb_insn_r->mem_rec_count = 1;
        }
    }
  else if (bit (thumb_insn_r->arm_insn, 11))
    {
      /* Handle load from literal pool.  */
      /* LDR(3).  */
      reg_src1 = bits (thumb_insn_r->arm_insn, 8, 10);
      record_buf[0] = reg_src1;
      thumb_insn_r->reg_rec_count = 1;
    }
  else if (opcode1)
    {
      opcode2 = bits (thumb_insn_r->arm_insn, 8, 9);
      opcode3 = bits (thumb_insn_r->arm_insn, 0, 2);
      if ((3 == opcode2) && (!opcode3))
        {
          /* Branch with exchange.  */
          record_buf[0] = ARM_PS_REGNUM;
          thumb_insn_r->reg_rec_count = 1;
        }
      else
        {
          /* Format 8; special data processing insns.  */
          reg_src1 = bits (thumb_insn_r->arm_insn, 0, 2);
          record_buf[0] = ARM_PS_REGNUM;
          record_buf[1] = reg_src1;
          thumb_insn_r->reg_rec_count = 2;
        }
    }
  else
    {
      /* Format 5; data processing insns.  */
      reg_src1 = bits (thumb_insn_r->arm_insn, 0, 2);
      if (bit (thumb_insn_r->arm_insn, 7))
        {
          reg_src1 = reg_src1 + 8;
        }
      record_buf[0] = ARM_PS_REGNUM;
      record_buf[1] = reg_src1;
      thumb_insn_r->reg_rec_count = 2;
    }

  REG_ALLOC (thumb_insn_r->arm_regs, thumb_insn_r->reg_rec_count, record_buf);
  MEM_ALLOC (thumb_insn_r->arm_mems, thumb_insn_r->mem_rec_count,
             record_buf_mem);

  return 0;
}

/* Handling opcode 001 insns.  */

static int
thumb_record_ld_st_imm_offset (insn_decode_record *thumb_insn_r)
{
  struct regcache *reg_cache = thumb_insn_r->regcache;
  uint32_t record_buf[8], record_buf_mem[8];

  uint32_t reg_src1 = 0;
  uint32_t opcode = 0, immed_5 = 0;

  ULONGEST u_regval = 0;

  opcode = bits (thumb_insn_r->arm_insn, 11, 12);

  if (opcode)
    {
      /* LDR(1).  */
      reg_src1 = bits (thumb_insn_r->arm_insn, 0, 2);
      record_buf[0] = reg_src1;
      thumb_insn_r->reg_rec_count = 1;
    }
  else
    {
      /* STR(1).  */
      reg_src1 = bits (thumb_insn_r->arm_insn, 3, 5);
      immed_5 = bits (thumb_insn_r->arm_insn, 6, 10);
      regcache_raw_read_unsigned (reg_cache, reg_src1, &u_regval);
      record_buf_mem[0] = 4;
      record_buf_mem[1] = u_regval + (immed_5 * 4);
      thumb_insn_r->mem_rec_count = 1;
    }

  REG_ALLOC (thumb_insn_r->arm_regs, thumb_insn_r->reg_rec_count, record_buf);
  MEM_ALLOC (thumb_insn_r->arm_mems, thumb_insn_r->mem_rec_count, 
             record_buf_mem);

  return 0;
}

/* Handling opcode 100 insns.  */

static int
thumb_record_ld_st_stack (insn_decode_record *thumb_insn_r)
{
  struct regcache *reg_cache = thumb_insn_r->regcache;
  uint32_t record_buf[8], record_buf_mem[8];

  uint32_t reg_src1 = 0;
  uint32_t opcode = 0, immed_8 = 0, immed_5 = 0;

  ULONGEST u_regval = 0;

  opcode = bits (thumb_insn_r->arm_insn, 11, 12);

  if (3 == opcode)
    {
      /* LDR(4).  */
      reg_src1 = bits (thumb_insn_r->arm_insn, 8, 10);
      record_buf[0] = reg_src1;
      thumb_insn_r->reg_rec_count = 1;
    }
  else if (1 == opcode)
    {
      /* LDRH(1).  */
      reg_src1 = bits (thumb_insn_r->arm_insn, 0, 2);
      record_buf[0] = reg_src1;
      thumb_insn_r->reg_rec_count = 1;
    }
  else if (2 == opcode)
    {
      /* STR(3).  */
      immed_8 = bits (thumb_insn_r->arm_insn, 0, 7);
      regcache_raw_read_unsigned (reg_cache, ARM_SP_REGNUM, &u_regval);
      record_buf_mem[0] = 4;
      record_buf_mem[1] = u_regval + (immed_8 * 4);
      thumb_insn_r->mem_rec_count = 1;
    }
  else if (0 == opcode)
    {
      /* STRH(1).  */
      immed_5 = bits (thumb_insn_r->arm_insn, 6, 10);
      reg_src1 = bits (thumb_insn_r->arm_insn, 3, 5);
      regcache_raw_read_unsigned (reg_cache, reg_src1, &u_regval);
      record_buf_mem[0] = 2;
      record_buf_mem[1] = u_regval + (immed_5 * 2);
      thumb_insn_r->mem_rec_count = 1;
    }

  REG_ALLOC (thumb_insn_r->arm_regs, thumb_insn_r->reg_rec_count, record_buf);
  MEM_ALLOC (thumb_insn_r->arm_mems, thumb_insn_r->mem_rec_count,
             record_buf_mem);

  return 0;
}

/* Handling opcode 101 insns.  */

static int
thumb_record_misc (insn_decode_record *thumb_insn_r)
{
  struct regcache *reg_cache = thumb_insn_r->regcache;

  uint32_t opcode = 0, opcode1 = 0, opcode2 = 0;
  uint32_t register_bits = 0, register_count = 0;
  uint32_t register_list[8] = {0}, index = 0, start_address = 0;
  uint32_t record_buf[24], record_buf_mem[48];
  uint32_t reg_src1;

  ULONGEST u_regval = 0;

  opcode = bits (thumb_insn_r->arm_insn, 11, 12);
  opcode1 = bits (thumb_insn_r->arm_insn, 8, 12);
  opcode2 = bits (thumb_insn_r->arm_insn, 9, 12);

  if (14 == opcode2)
    {
      /* POP.  */
      register_bits = bits (thumb_insn_r->arm_insn, 0, 7);
      while (register_bits)
        {
          if (register_bits & 0x00000001)
            register_list[register_count++] = 1;
          register_bits = register_bits >> 1;
        }
      record_buf[register_count] = ARM_PS_REGNUM;
      record_buf[register_count + 1] = ARM_SP_REGNUM;
      thumb_insn_r->reg_rec_count = register_count + 2;
      for (register_count = 0; register_count < 8; register_count++)
        {
          if  (register_list[register_count])
            {
              record_buf[index] = register_count;
              index++;
            }
        }
    }
  else if (10 == opcode2)
    {
      /* PUSH.  */
      register_bits = bits (thumb_insn_r->arm_insn, 0, 7);
      regcache_raw_read_unsigned (reg_cache, ARM_PC_REGNUM, &u_regval);
      while (register_bits)
        {
          if (register_bits & 0x00000001)
            register_count++;
          register_bits = register_bits >> 1;
        }
      start_address = u_regval -  \
                  (4 * (bit (thumb_insn_r->arm_insn, 8) + register_count));
      thumb_insn_r->mem_rec_count = register_count;
      while (register_count)
        {
          record_buf_mem[(register_count * 2) - 1] = start_address;
          record_buf_mem[(register_count * 2) - 2] = 4;
          start_address = start_address + 4;
          register_count--;
        }
      record_buf[0] = ARM_SP_REGNUM;
      thumb_insn_r->reg_rec_count = 1;
    }
  else if (0x1E == opcode1)
    {
      /* BKPT insn.  */
      /* Handle enhanced software breakpoint insn, BKPT.  */
      /* CPSR is changed to be executed in ARM state,  disabling normal
         interrupts, entering abort mode.  */
      /* According to high vector configuration PC is set.  */
      /* User hits breakpoint and type reverse, in that case, we need to go back with 
      previous CPSR and Program Counter.  */
      record_buf[0] = ARM_PS_REGNUM;
      record_buf[1] = ARM_LR_REGNUM;
      thumb_insn_r->reg_rec_count = 2;
      /* We need to save SPSR value, which is not yet done.  */
      printf_unfiltered (_("Process record does not support instruction "
                           "0x%0x at address %s.\n"),
                           thumb_insn_r->arm_insn,
                           paddress (thumb_insn_r->gdbarch,
                           thumb_insn_r->this_addr));
      return -1;
    }
  else if ((0 == opcode) || (1 == opcode))
    {
      /* ADD(5), ADD(6).  */
      reg_src1 = bits (thumb_insn_r->arm_insn, 8, 10);
      record_buf[0] = reg_src1;
      thumb_insn_r->reg_rec_count = 1;
    }
  else if (2 == opcode)
    {
      /* ADD(7), SUB(4).  */
      reg_src1 = bits (thumb_insn_r->arm_insn, 8, 10);
      record_buf[0] = ARM_SP_REGNUM;
      thumb_insn_r->reg_rec_count = 1;
    }

  REG_ALLOC (thumb_insn_r->arm_regs, thumb_insn_r->reg_rec_count, record_buf);
  MEM_ALLOC (thumb_insn_r->arm_mems, thumb_insn_r->mem_rec_count,
             record_buf_mem);

  return 0;
}

/* Handling opcode 110 insns.  */

static int
thumb_record_ldm_stm_swi (insn_decode_record *thumb_insn_r)                
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (thumb_insn_r->gdbarch);
  struct regcache *reg_cache = thumb_insn_r->regcache;

  uint32_t ret = 0; /* function return value: -1:record failure ;  0:success  */
  uint32_t reg_src1 = 0;
  uint32_t opcode1 = 0, opcode2 = 0, register_bits = 0, register_count = 0;
  uint32_t register_list[8] = {0}, index = 0, start_address = 0;
  uint32_t record_buf[24], record_buf_mem[48];

  ULONGEST u_regval = 0;

  opcode1 = bits (thumb_insn_r->arm_insn, 8, 12);
  opcode2 = bits (thumb_insn_r->arm_insn, 11, 12);

  if (1 == opcode2)
    {

      /* LDMIA.  */
      register_bits = bits (thumb_insn_r->arm_insn, 0, 7);
      /* Get Rn.  */
      reg_src1 = bits (thumb_insn_r->arm_insn, 8, 10);
      while (register_bits)
        {
          if (register_bits & 0x00000001)
            register_list[register_count++] = 1;
          register_bits = register_bits >> 1;
        }
      record_buf[register_count] = reg_src1;
      thumb_insn_r->reg_rec_count = register_count + 1;
      for (register_count = 0; register_count < 8; register_count++)
        {
          if (register_list[register_count])
            {
              record_buf[index] = register_count;
              index++;
            }
        }
    }
  else if (0 == opcode2)
    {
      /* It handles both STMIA.  */
      register_bits = bits (thumb_insn_r->arm_insn, 0, 7);
      /* Get Rn.  */
      reg_src1 = bits (thumb_insn_r->arm_insn, 8, 10);
      regcache_raw_read_unsigned (reg_cache, reg_src1, &u_regval);
      while (register_bits)
        {
          if (register_bits & 0x00000001)
            register_count++;
          register_bits = register_bits >> 1;
        }
      start_address = u_regval;
      thumb_insn_r->mem_rec_count = register_count;
      while (register_count)
        {
          record_buf_mem[(register_count * 2) - 1] = start_address;
          record_buf_mem[(register_count * 2) - 2] = 4;
          start_address = start_address + 4;
          register_count--;
        }
    }
  else if (0x1F == opcode1)
    {
        /* Handle arm syscall insn.  */
        if (tdep->arm_swi_record != NULL)
          {
            ret = tdep->arm_swi_record(reg_cache);
          }
        else
          {
            printf_unfiltered (_("no syscall record support\n"));
            return -1;
          }
    }

  /* B (1), conditional branch is automatically taken care in process_record,
    as PC is saved there.  */

  REG_ALLOC (thumb_insn_r->arm_regs, thumb_insn_r->reg_rec_count, record_buf);
  MEM_ALLOC (thumb_insn_r->arm_mems, thumb_insn_r->mem_rec_count,
             record_buf_mem);

  return ret;
}

/* Handling opcode 111 insns.  */

static int
thumb_record_branch (insn_decode_record *thumb_insn_r)
{
  uint32_t record_buf[8];
  uint32_t bits_h = 0;

  bits_h = bits (thumb_insn_r->arm_insn, 11, 12);

  if (2 == bits_h || 3 == bits_h)
    {
      /* BL */
      record_buf[0] = ARM_LR_REGNUM;
      thumb_insn_r->reg_rec_count = 1;
    }
  else if (1 == bits_h)
    {
      /* BLX(1). */
      record_buf[0] = ARM_PS_REGNUM;
      record_buf[1] = ARM_LR_REGNUM;
      thumb_insn_r->reg_rec_count = 2;
    }

  /* B(2) is automatically taken care in process_record, as PC is 
     saved there.  */

  REG_ALLOC (thumb_insn_r->arm_regs, thumb_insn_r->reg_rec_count, record_buf);

  return 0;     
}


/* Extracts arm/thumb/thumb2 insn depending on the size, and returns 0 on success 
and positive val on fauilure.  */

static int
extract_arm_insn (insn_decode_record *insn_record, uint32_t insn_size)
{
  gdb_byte buf[insn_size];

  memset (&buf[0], 0, insn_size);
  
  if (target_read_memory (insn_record->this_addr, &buf[0], insn_size))
    return 1;
  insn_record->arm_insn = (uint32_t) extract_unsigned_integer (&buf[0],
                           insn_size, 
                           gdbarch_byte_order (insn_record->gdbarch));
  return 0;
}

typedef int (*sti_arm_hdl_fp_t) (insn_decode_record*);

/* Decode arm/thumb insn depending on condition cods and opcodes; and
   dispatch it.  */

static int
decode_insn (insn_decode_record *arm_record, record_type_t record_type,
                uint32_t insn_size)
{

  /* (Starting from numerical 0); bits 25, 26, 27 decodes type of arm instruction.  */
  static const sti_arm_hdl_fp_t const arm_handle_insn[8] =                    
  {
    arm_record_data_proc_misc_ld_str,   /* 000.  */
    arm_record_data_proc_imm,           /* 001.  */
    arm_record_ld_st_imm_offset,        /* 010.  */
    arm_record_ld_st_reg_offset,        /* 011.  */
    arm_record_ld_st_multiple,          /* 100.  */
    arm_record_b_bl,                    /* 101.  */
    arm_record_coproc,                  /* 110.  */
    arm_record_coproc_data_proc         /* 111.  */
  };

  /* (Starting from numerical 0); bits 13,14,15 decodes type of thumb instruction.  */
  static const sti_arm_hdl_fp_t const thumb_handle_insn[8] =
  { \
    thumb_record_shift_add_sub,        /* 000.  */
    thumb_record_add_sub_cmp_mov,      /* 001.  */
    thumb_record_ld_st_reg_offset,     /* 010.  */
    thumb_record_ld_st_imm_offset,     /* 011.  */
    thumb_record_ld_st_stack,          /* 100.  */
    thumb_record_misc,                 /* 101.  */
    thumb_record_ldm_stm_swi,          /* 110.  */
    thumb_record_branch                /* 111.  */
  };

  uint32_t ret = 0;    /* return value: negative:failure   0:success.  */
  uint32_t insn_id = 0;

  if (extract_arm_insn (arm_record, insn_size))
    {
      if (record_debug)
        {
          printf_unfiltered (_("Process record: error reading memory at "
                              "addr %s len = %d.\n"),
          paddress (arm_record->gdbarch, arm_record->this_addr), insn_size);        
        }
      return -1;
    }
  else if (ARM_RECORD == record_type)
    {
      arm_record->cond = bits (arm_record->arm_insn, 28, 31);
      insn_id = bits (arm_record->arm_insn, 25, 27);
      ret = arm_record_extension_space (arm_record);
      /* If this insn has fallen into extension space 
         then we need not decode it anymore.  */
      if (ret != -1 && !INSN_RECORDED(arm_record))
        {
          ret = arm_handle_insn[insn_id] (arm_record);
        }
    }
  else if (THUMB_RECORD == record_type)
    {
      /* As thumb does not have condition codes, we set negative.  */
      arm_record->cond = -1;
      insn_id = bits (arm_record->arm_insn, 13, 15);
      ret = thumb_handle_insn[insn_id] (arm_record);
    }
  else if (THUMB2_RECORD == record_type)
    {
      printf_unfiltered (_("Process record doesnt support thumb32 instruction "
                           "0x%0x at address %s.\n"),arm_record->arm_insn,
                           paddress (arm_record->gdbarch, 
                           arm_record->this_addr));
      ret = -1;
    }
  else
    {
      /* Throw assertion.  */
      gdb_assert_not_reached ("not a valid instruction, could not decode");
    }

  return ret;
}


/* Cleans up local record registers and memory allocations.  */

static void 
deallocate_reg_mem (insn_decode_record *record)
{
  xfree (record->arm_regs);
  xfree (record->arm_mems);    
}


/* Parse the current instruction and record the values of the registers and    
   memory that will be changed in current instruction to record_arch_list".
   Return -1 if something is wrong.  */

int
arm_process_record (struct gdbarch *gdbarch, struct regcache *regcache, 
                        CORE_ADDR insn_addr)
{

  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  uint32_t no_of_rec = 0;
  uint32_t ret = 0;  /* return value: -1:record failure ;  0:success  */
  ULONGEST t_bit = 0, insn_id = 0;

  ULONGEST u_regval = 0;

  insn_decode_record arm_record;

  memset (&arm_record, 0, sizeof (insn_decode_record));
  arm_record.regcache = regcache;
  arm_record.this_addr = insn_addr;
  arm_record.gdbarch = gdbarch;


  if (record_debug > 1)
    {
      fprintf_unfiltered (gdb_stdlog, "Process record: arm_process_record "
                                      "addr = %s\n",
      paddress (gdbarch, arm_record.this_addr));
    }

  if (extract_arm_insn (&arm_record, 2))
    {
      if (record_debug)
        {
          printf_unfiltered (_("Process record: error reading memory at "
                             "addr %s len = %d.\n"),
                             paddress (arm_record.gdbarch, 
                             arm_record.this_addr), 2);
        }
      return -1;
    }

  /* Check the insn, whether it is thumb or arm one.  */

  t_bit = arm_psr_thumb_bit (arm_record.gdbarch);
  regcache_raw_read_unsigned (arm_record.regcache, ARM_PS_REGNUM, &u_regval);


  if (!(u_regval & t_bit))
    {
      /* We are decoding arm insn.  */
      ret = decode_insn (&arm_record, ARM_RECORD, ARM_INSN_SIZE_BYTES);
    }
  else
    {
      insn_id = bits (arm_record.arm_insn, 11, 15);
      /* is it thumb2 insn?  */
      if ((0x1D == insn_id) || (0x1E == insn_id) || (0x1F == insn_id))
        {
          ret = decode_insn (&arm_record, THUMB2_RECORD, 
                             THUMB2_INSN_SIZE_BYTES);
        }
      else
        {
          /* We are decoding thumb insn.  */
          ret = decode_insn (&arm_record, THUMB_RECORD, THUMB_INSN_SIZE_BYTES);
        }
    }

  if (0 == ret)
    {
      /* Record registers.  */
      record_full_arch_list_add_reg (arm_record.regcache, ARM_PC_REGNUM);
      if (arm_record.arm_regs)
        {
          for (no_of_rec = 0; no_of_rec < arm_record.reg_rec_count; no_of_rec++)
            {
              if (record_full_arch_list_add_reg
		  (arm_record.regcache , arm_record.arm_regs[no_of_rec]))
              ret = -1;
            }
        }
      /* Record memories.  */
      if (arm_record.arm_mems)
        {
          for (no_of_rec = 0; no_of_rec < arm_record.mem_rec_count; no_of_rec++)
            {
              if (record_full_arch_list_add_mem
                  ((CORE_ADDR)arm_record.arm_mems[no_of_rec].addr,
		   arm_record.arm_mems[no_of_rec].len))
                ret = -1;
            }
        }

      if (record_full_arch_list_add_end ())
        ret = -1;
    }


  deallocate_reg_mem (&arm_record);

  return ret;
}

@


1.380
log
@Andrew Haley found a bug on GDB running on ARM when using
--enable-64-bit-bfd.  Basically the issue happens when dealing with "bl"
instructions: GDB does branch destination calculation and (wrongly)
sign-extends the PC.  Here is a piece of his original message explaining
the problem:

>      next_pc = arm_get_next_pc (frame, get_frame_pc (frame));
>
>      /* The Linux kernel offers some user-mode helpers in a high page.  We can
>         not read this page (as of 2.6.23), and even if we could then we couldn't
>         set breakpoints in it, and even if we could then the atomic operations
>         would fail when interrupted.  They are all called as functions and return
>         to the address in LR, so step to there instead.  */
>      if (next_pc > 0xffff0000)
>        next_pc = get_frame_register_unsigned (frame, ARM_LR_REGNUM);
>
>      arm_insert_single_step_breakpoint (gdbarch, aspace, next_pc);
>
>    Unfortunately, branch destination addresses are SIGN EXTENDED to 64
>    bits.  So,
>
>    (top-gdb) p/x next_pc
>    $14 = 0xffffffffb6df2864
>
>    Which triggers the next_pc = get_frame_register_unsigned(), and we
>    cannot step into any branches because the destination PC is wrong.

Anyway, the fix is simple and Andrew himself provided it for us.  It
took a while for me to figure out how to trigger the bug (in order to
write a testcase for it), but I finally made it.

The attached patch fixes the problem (by casting to `unsigned long'
instead of just `long'), and also includes a testcase to reproduce the
issue.

gdb/ChangeLog:

2013-04-22  Andrew Haley  <aph@@redhat.com>

	* arm-tdep.c (BranchDest): Cast result as "unsigned long",
	instead of "long".

gdb/testsuite/ChangeLog:

2013-04-22  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* gdb.arch/arm-bl-branch-dest.c: New file.
	* gdb.arch/arm-bl-branch-dest.exp: Likewise.
@
text
@d2910 1
a2910 1
  if (in_plt_section (addr_in_block, NULL)
@


1.379
log
@-Wpointer-sign: char -> gdb_byte.

-Wpointer-sign catches all these cases across the codebase that should
be using gdb_byte for raw target bytes.  I think these are all
obvious, hence I've collapsed into a single patch.

gdb/
2013-04-19  Pedro Alves  <palves@@redhat.com>

	* aarch64-tdep.c (aarch64_default_breakpoint): Change type to
	gdb_byte[].
	(aarch64_breakpoint_from_pc): Change return type to gdb_byte *.
	* ada-lang.c (ada_value_assign): Use gdb_byte.
	* alphanbsd-tdep.c (sigtramp_retcode): Change type to gdb_byte[].
	(alphanbsd_sigtramp_offset): Use gdb_byte.
	* arm-linux-tdep.c (arm_linux_arm_le_breakpoint)
	(arm_linux_arm_be_breakpoint, eabi_linux_arm_le_breakpoint)
	(eabi_linux_arm_be_breakpoint, arm_linux_thumb_be_breakpoint)
	(arm_linux_thumb_le_breakpoint, arm_linux_thumb2_be_breakpoint)
	(arm_linux_thumb2_le_breakpoint): Change type to gdb_byte[].
	* arm-tdep.c (arm_stub_unwind_sniffer)
	(arm_displaced_init_closure): Use gdb_byte.
	(arm_default_arm_le_breakpoint, arm_default_arm_be_breakpoint)
	(arm_default_thumb_le_breakpoint)
	(arm_default_thumb_be_breakpoint): Change type to gdb_byte[].
	* arm-tdep.h (struct gdbarch_tdep) <arm_breakpoint,
	thumb_breakpoint, thumb2_breakpoint>: Change type to gdb_byte *.
	* arm-wince-tdep.c (arm_wince_le_breakpoint)
	(arm_wince_thumb_le_breakpoint): Change type to gdb_byte[].
	* armnbsd-tdep.c (arm_nbsd_arm_le_breakpoint)
	(arm_nbsd_arm_be_breakpoint, arm_nbsd_thumb_le_breakpoint)
	(arm_nbsd_thumb_be_breakpoint): Change type to gdb_byte[].
	* armobsd-tdep.c (arm_obsd_thumb_le_breakpoint)
	(arm_obsd_thumb_be_breakpoint): Change type to gdb_byte[].
	* cris-tdep.c (push_stack_item, cris_push_dummy_call)
	(cris_store_return_value, cris_extract_return_value): Use
	gdb_byte.
	(constraint): Change type of parameter to char * from signed
	char*.  Use gdb_byte.
	* dwarf2loc.c (read_pieced_value, write_pieced_value): Change type
	of local buffer to gdb_byte *.
	* dwarf2read.c (read_index_from_section): Use gdb_byte.
	(create_dwp_hash_table): Change type of locals to gdb_byte *.
	(add_address_entry): Change type of local buffer to gdb_byte[].
	* frv-tdep.c (frv_adjust_breakpoint_address, find_func_descr)
	(frv_push_dummy_call): Use gdb_byte.
	* hppa-hpux-tdep.c (hppa_hpux_push_dummy_code)
	(hppa_hpux_supply_ss_fpblock, hppa_hpux_supply_ss_wide)
	(hppa_hpux_supply_save_state): Use gdb_byte.
	* hppa-tdep.c (hppa32_push_dummy_call)
	(hppa64_convert_code_addr_to_fptr): Use gdb_byte.
	* ia64-tdep.c (extract_bit_field, replace_bit_field)
	(slotN_contents, replace_slotN_contents): Change type of parameter
	to gdb_byte *.
	(fetch_instruction, ia64_pseudo_register_write)
	(ia64_register_to_value, ia64_value_to_register)
	(ia64_extract_return_value, ia64_store_return_value)
	(ia64_push_dummy_call): Use gdb_byte.
	* m32c-tdep.c (m32c_return_value): Remove cast.
	* m68hc11-tdep.c (m68hc11_pseudo_register_write)
	(m68hc11_push_dummy_call, m68hc11_store_return_value): Use
	gdb_byte.
	* mipsnbsd-tdep.c (mipsnbsd_get_longjmp_target): Use gdb_byte.
	* mn10300-tdep.c (mn10300_store_return_value)
	(mn10300_breakpoint_from_pc, mn10300_push_dummy_call): Use
	gdb_byte.
	* moxie-tdep.c (moxie_process_readu): Use gdb_byte.
	(moxie_process_record): Remove casts.
	* ppc-ravenscar-thread.c (supply_register_at_address)
	(ppc_ravenscar_generic_store_registers): Use gdb_byte.
	* ravenscar-thread.c (get_running_thread_id): Use gdb_byte.
	* remote-m32r-sdi.c (m32r_fetch_register): Use gdb_byte.
	* remote-mips.c (mips_xfer_memory): Use gdb_byte.
	* remote.c (compare_sections_command): Use gdb_byte.
	* score-tdep.c (score7_free_memblock): Change type of parameter to
	gdb_byte *.
	* sh-tdep.c (sh_justify_value_in_reg): Change return type to
	gdb_byte *.  Use gdb_byte.
	(sh_push_dummy_call_fpu): Use gdb_byte.
	(sh_extract_return_value_nofpu, sh_extract_return_value_fpu)
	(sh_store_return_value_nofpu, sh_store_return_value_fpu)
	(sh_register_convert_to_virtual, sh_register_convert_to_raw):
	Change parameter type to 'gdb_byte *'.  Use gdb_byte.
	(sh_pseudo_register_read, sh_pseudo_register_write): Use gdb_byte.
	* sh64-tdep.c (sh64_push_dummy_call): Use gdb_byte.
	(sh64_store_return_value, sh64_register_convert_to_virtual):
	Change parameter type to 'gdb_byte *'.  Use gdb_byte.
	(sh64_pseudo_register_write): Use gdb_byte.
	* solib-darwin.c (darwin_current_sos): Add casts to 'gdb_byte *'.
	* solib-irix.c (fetch_lm_info): Likewise.  Use gdb_byte for byte
	buffer.
	(irix_current_sos): Use gdb_byte.
	* solib-som.c (som_current_sos): Use gdb_byte.
	* sparc-ravenscar-thread.c (supply_register_at_address)
	(sparc_ravenscar_generic_store_registers): Use gdb_byte.
	* spu-multiarch.c (spu_xfer_partial): Add cast to 'char *'.
	* spu-tdep.c (spu_get_overlay_table): Use gdb_byte.
	* tic6x-tdep.c (tic6x_breakpoint_from_pc): Change return type to
	'gdb_byte *'.
	* tic6x-tdep.h (struct gdbarch_tdep) <breakpoint>: Change type to
	'gdb_byte *'.
	* tracepoint.c (tfile_fetch_registers): Use gdb_byte.
	* xstormy16-tdep.c (xstormy16_extract_return_value)
	(xstormy16_store_return_value): Change parameter type to
	'gdb_byte *'.  Adjust.
	(xstormy16_push_dummy_call): Use gdb_byte.
	* xtensa-tdep.c (xtensa_scan_prologue, call0_ret)
	(call0_analyze_prologue, execute_code): Use gdb_byte.
@
text
@d524 1
a524 1
  ((CORE_ADDR) (((long) (addr)) + 8 + (sbits (instr, 0, 23) << 2)))
@


1.378
log
@	* minsyms.h (struct bound_minimal_symbol): New.
	(lookup_minimal_symbol_and_objfile): Return bound_minimal_symbol.
	Remove objfile argument.
	(lookup_minimal_symbol_by_pc_section, lookup_minimal_symbol_by_pc):
	Return bound_minimal_symbol.
	* minsyms.c (lookup_minimal_symbol_by_pc_1)
	(lookup_minimal_symbol_by_pc_section, lookup_minimal_symbol_by_pc):
	Return bound_minimal_symbol.
	(in_gnu_ifunc_stub): Update.
	(lookup_minimal_symbol_and_objfile): Return bound_minimal_symbol.
	Remove 'objfile_p' argument.
	(lookup_solib_trampoline_symbol_by_pc): Update.
	* ada-tasks.c, amd64-windows-tdep.c, arm-tdep.c,
	arm-wince-tdep.c, block.c, blockframe.c, breakpoint.c, btrace.c,
	c-valprint.c, dwarf2loc.c, elfread.c, frame.c, frv-tdep.c,
	glibc-tdep.c, gnu-v2-abi.c, gnu-v3-abi.c, hppa-hpux-tdep.c,
	i386-tdep.c, ia64-tdep.c, infcall.c, infcmd.c, jit.c,
	linux-fork.c, m32c-tdep.c, m68hc11-tdep.c, maint.c,
	mips-tdep.c, p-valprint.c, parse.c, ppc-linux-tdep.c,
	ppc-sysv-tdep.c, printcmd.c, rs6000-tdep.c, sh64-tdep.c,
	stack.c, symtab.c, tui/tui-disasm.c: Update.
@
text
@d2907 1
a2907 1
  char dummy[4];
d8619 1
a8619 1
  const unsigned char *bkp_insn;
d8778 4
a8781 4
static const char arm_default_arm_le_breakpoint[] = ARM_LE_BREAKPOINT;
static const char arm_default_arm_be_breakpoint[] = ARM_BE_BREAKPOINT;
static const char arm_default_thumb_le_breakpoint[] = THUMB_LE_BREAKPOINT;
static const char arm_default_thumb_be_breakpoint[] = THUMB_BE_BREAKPOINT;
@


1.377
log
@Rename record_ prefixes in record-full.h into record_full_.

gdb/
	* record-full.h, record-full.c (record_memory_query): Rename
	to ...
	(record_full_memory_query): ...this. Update all users.
	(record_arch_list_add_reg): Rename to ...
	(record_full_arch_list_add_reg): ...this. Update all users.
	(record_arch_list_add_mem): Rename to ...
	(record_full_arch_list_add_mem): ...this. Update all users.
	(record_arch_list_add_end): Rename to ...
	(record_full_arch_list_add_end): ...this. Update all users.
	(record_gdb_operation_disable_set): Rename to ...
	(record_full_gdb_operation_disable_set): ...this.
	Update all users.
@
text
@d384 1
a384 1
  struct minimal_symbol *sym;
d426 2
a427 2
  if (sym)
    return (MSYMBOL_IS_SPECIAL (sym));
d471 1
a471 1
  struct minimal_symbol *msym;
d474 3
a476 3
  if (msym != NULL
      && SYMBOL_VALUE_ADDRESS (msym) == pc
      && SYMBOL_LINKAGE_NAME (msym) != NULL)
d478 1
a478 1
      const char *name = SYMBOL_LINKAGE_NAME (msym);
d1287 1
a1287 1
  struct minimal_symbol *stack_chk_guard;
d1302 3
a1304 2
  if (stack_chk_guard
      && strncmp (SYMBOL_LINKAGE_NAME (stack_chk_guard), "__stack_chk_guard",
@


1.377.2.1
log
@Andrew Haley found a bug on GDB running on ARM when using
--enable-64-bit-bfd.  Basically the issue happens when dealing with "bl"
instructions: GDB does branch destination calculation and (wrongly)
sign-extends the PC.  Here is a piece of his original message explaining
the problem:

>      next_pc = arm_get_next_pc (frame, get_frame_pc (frame));
>
>      /* The Linux kernel offers some user-mode helpers in a high page.  We can
>         not read this page (as of 2.6.23), and even if we could then we couldn't
>         set breakpoints in it, and even if we could then the atomic operations
>         would fail when interrupted.  They are all called as functions and return
>         to the address in LR, so step to there instead.  */
>      if (next_pc > 0xffff0000)
>        next_pc = get_frame_register_unsigned (frame, ARM_LR_REGNUM);
>
>      arm_insert_single_step_breakpoint (gdbarch, aspace, next_pc);
>
>    Unfortunately, branch destination addresses are SIGN EXTENDED to 64
>    bits.  So,
>
>    (top-gdb) p/x next_pc
>    $14 = 0xffffffffb6df2864
>
>    Which triggers the next_pc = get_frame_register_unsigned(), and we
>    cannot step into any branches because the destination PC is wrong.

Anyway, the fix is simple and Andrew himself provided it for us.  It
took a while for me to figure out how to trigger the bug (in order to
write a testcase for it), but I finally made it.

The attached patch fixes the problem (by casting to `unsigned long'
instead of just `long'), and also includes a testcase to reproduce the
issue.

gdb/ChangeLog:

2013-04-25  Andrew Haley  <aph@@redhat.com>

	* arm-tdep.c (BranchDest): Cast result as "unsigned long",
	instead of "long".

gdb/testsuite/ChangeLog:

2013-04-25  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* gdb.arch/arm-bl-branch-dest.c: New file.
	* gdb.arch/arm-bl-branch-dest.exp: Likewise.
@
text
@d524 1
a524 1
  ((CORE_ADDR) (((unsigned long) (addr)) + 8 + (sbits (instr, 0, 23) << 2)))
@


1.376
log
@Split record.h into record.h and record-full.h.
Split record.c into record.c and record-full.c.

The split leaves the command part in record.c and moves the target part into
record-full.c.

gdb/
	* record.h: Split into this and ...
	* record-full.h: ... this.
	* record.c: Split into this and ...
	* record-full.c: ... this.
	* target.h (target_ops): Add new fields to_info_record,
	to_save_record, to_delete_record, to_record_is_replaying,
	to_goto_record_begin, to_goto_record_end, to_goto_record.
	(target_info_record): New.
	(target_save_record): New.
	(target_supports_delete_record): New.
	(target_delete_record): New.
	(target_record_is_replaying): New.
	(target_goto_record_begin): New.
	(target_goto_record_end): New.
	(target_goto_record): New.
	* target.c (target_info_record): New.
	(target_save_record): New.
	(target_supports_delete_record): New.
	(target_delete_record): New.
	(target_record_is_replaying): New.
	(target_goto_record_begin): New.
	(target_goto_record_end): New.
	(target_goto_record): New.
	* record.h: Declare struct cmd_list_element.
	(record_cmdlist): New declaration.
	(set_record_cmdlist): New declaration.
	(show_record_cmdlist): New declaration.
	(info_record_cmdlist): New declaration.
	(cmd_record_goto): New declaration.
	* record.c: Remove unnecessary includes.
	Include inferior.h.
	(cmd_record_goto): Remove declaration.
	(record_cmdlist): Now extern. Initialize.
	(set_record_cmdlist): Now extern. Initialize.
	(show_record_cmdlist): Now extern. Initialize.
	(info_record_cmdlist): Now extern. Initialize.
	(find_record_target): New.
	(require_record_target): New.
	(cmd_record_start): Update.
	(cmd_record_delete): Remove target-specific code.
	Call target_delete_record.
	(cmd_record_stop): Unpush any record target.
	(set_record_insn_max_num): Move to record-full.c
	(set_record_command): Add comment.
	(show_record_command): Add comment.
	(info_record_command): Update comment.
	Remove target-specific code.
	Call the record target's to_info_record.
	(cmd_record_start): New.
	(cmd_record_goto): Now extern.
	Remove target-specific code.
	Call target_goto_begin,  target_goto_end, or target_goto.
	(_initialize_record): Move record target ops initialization to
	record-full.c.
	Change "record" command help text.
	Move "record restore", "record set", and "record show" commands to
	record-full.c.
	* Makefile.in (SFILES): Add record-full.c.
	(HFILES_NO_SRCDIR): Add record-full.h.
	(COMMON_OBS): Add record-full.o.
	* amd64-linux-tdep.c: Include record-full.h instead of record.h.
	* arm-tdep.c: Include record-full.h.
	* i386-linux-tdep.c: Include record-full.h instead of record.h.
	* i386-tdep.c: Include record-full.h.
	* infrun.c: Include record-full.h.
	* linux-record.c: Include record-full.h.
	* moxie-tdep.c: Include record-full.h.
	* record-full.c: Include record-full.h.
	Change module comment.
	(set_record_full_cmdlist): New.
	(show_record_full_cmdlist): New.
	(record_full_cmdlist): New.
	(record_goto_insn): New declaration.
	(record_save): New declaration.
	(record_check_insn_num): Change query string.
	(record_info): New.
	(record_delete): New.
	(record_is_replaying): New.
	(record_goto_entry): New.
	(record_goto_begin): New.
	(record_goto_end): New.
	(record_goto): New.
	(init_record_ops): Update.
	(init_record_core_ops): Update.
	(cmd_record_save): Rename to record_save. Remove target and arg checks.
	(cmd_record_start): New.
	(set_record_insn_max_num): Moved from record.c
	(set_record_full_command): New.
	(show_record_full_command): New.
	(_initialize_record_full): New.
@
text
@d12604 1
a12604 1
      record_arch_list_add_reg (arm_record.regcache, ARM_PC_REGNUM);
d12609 2
a12610 2
              if (record_arch_list_add_reg (arm_record.regcache , 
                                            arm_record.arm_regs[no_of_rec]))
d12619 1
a12619 1
              if (record_arch_list_add_mem 
d12621 1
a12621 1
                  arm_record.arm_mems[no_of_rec].len))
d12626 1
a12626 1
      if (record_arch_list_add_end ())
@


1.375
log
@Use gdb_byte for bytes from the program being debugged.

gdb_byte should be used for bytes from the program being debugged.  We
have many places using char or unsigned char instead all over the
existing ports, and more ends up added over time due to copy/paste as
new code is based on old code.

I've greped the tree for "char buf[", and fixed all I found.

Tested by building with --enable-targets=all.

2013-03-01  Pedro Alves  <palves@@redhat.com>

	Use gdb_byte for bytes from the program being debugged.

	* arm-tdep.c (arm_store_return_value, arm_get_longjmp_target):
	Change type of local 'buf' to gdb_byte.
	* avr-tdep.c (avr_frame_prev_register, avr_push_dummy_call): Likewise.
	* bfin-tdep.c (bfin_push_dummy_call): Likewise.
	* cris-tdep.c (cris_sigcontext_addr)
	(cris_sigtramp_frame_unwind_cache): Likewise.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp)
	(frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Likewise.
	* frv-tdep.c (frv_pseudo_register_write, frv_analyze_prologue): Likewise.
	* hppa-hpux-tdep.c (hppa32_hpux_find_global_pointer)
	(hppa32_hpux_search_dummy_call_sequence)
	(hppa_hpux_supply_save_state): Likewise.
	* hppa-linux-tdep.c (insns_match_pattern)
	(hppa_linux_find_global_pointer): Likewise.
	* hppa-tdep.c (hppa_in_function_epilogue_p)
	(skip_prologue_hard_way, hppa_frame_cache): Likewise.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Likewise.
	* i386fbsd-tdep.c (i386fbsd_supply_uthread)
	(i386fbsd_collect_uthread): Likewise.
	* ia64-hpux-tdep.c (ia64_hpux_push_dummy_code): Likewise.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Likewise.
	* ia64-tdep.c (examine_prologue, ia64_frame_cache)
	(ia64_frame_prev_register, ia64_sigtramp_frame_cache)
	(ia64_sigtramp_frame_prev_register, ia64_access_reg)
	(ia64_access_rse_reg, ia64_libunwind_frame_this_id)
	(ia64_libunwind_frame_prev_register)
	(ia64_libunwind_sigtramp_frame_this_id)
	(ia64_find_global_pointer_from_dynamic_section)
	(find_extant_func_descr, find_func_descr, ia64_dummy_id)
	(ia64_unwind_pc): Likewise.
	* iq2000-tdep.c (iq2000_store_return_value): Likewise.
	* m68hc11-tdep.c (m68hc11_push_dummy_call)
	(m68hc11_extract_return_value): Likewise.
	* m68klinux-nat.c (fetch_register, store_register): Likewise.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_cr32_write)
	(mep_get_insn, mep_push_dummy_call): Likewise.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target)
	(mips_linux_in_dynsym_stub): Likewise.
	* mn10300-tdep.c (mep_pseudo_cr32_write): Likewise.
	* ppc-linux-nat.c (fetch_register, store_register): Likewise.
	* regcache.c (dump_endian_bytes): Change type of parameter 'buf'
	to gdb_byte.
	* remote-mips.c (mips_set_register): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	* score-tdep.c (score7_fetch_inst): Change type of parameter
	'memblock' and local 'buf' to gdb_byte.
	(score7_malloc_and_get_memblock): Change return type to gdb_byte.
	Change type of local 'buf' to gdb_byte.  Adjust.
	(score7_adjust_memblock_ptr): Change type of parameter 'memblock'
	to gdb_byte**.
	(score7_analyze_prologue): Change type of 'memblock' and
	'memblock_ptr' locals to gdb_byte*.
	* sh64-tdep.c (sh64_extract_return_value)
	(sh64_store_return_value): Change type of local 'buf' to gdb_byte.
	* solib-darwin.c (darwin_current_sos, darwin_read_exec_load_addr):
	* solib-pa64.c (pa64_solib_create_inferior_hook)
	(pa64_open_symbol_file_object): Remove local 'buf'.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start)
	(som_open_symbol_file_object): Likewise.
	* solib-spu.c (spu_current_sos): Likewise.
	* spu-linux-nat.c (spu_fetch_inferior_registers): Likewise.
	* spu-multiarch.c (parse_spufs_run, spu_fetch_registers)
	(spu_store_registers): Likewise.
	* target.c (debug_print_register): Likewise.
	* tic6x-tdep.c (tic6x_get_longjmp_target): Likewise.
	* xstormy16-tdep.c (xstormy16_store_return_value)
	(xstormy16_push_dummy_call, xstormy16_resolve_jmp_table_entry)
	(xstormy16_find_jmp_table_entry): Likewise.
@
text
@d59 1
@


1.374
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d9046 1
a9046 1
      char buf[MAX_REGISTER_SIZE];
d9210 1
a9210 1
  char buf[INT_REGISTER_SIZE];
@


1.373
log
@gdb/
2012-11-21  Yao Qi  <yao@@codesourcery.com>

	PR tdep/7438
	* gdbarch.sh (smash_text_address): Remove.
	* gdbarch.c, gdbarch.h: Regenerate.
	* arm-tdep.c (arm_smash_text_address): Remove.
	(arm_gdbarch_init): Don't call set_gdbarch_smash_text_address.
	* hppa-tdep.c (hppa_smash_text_address): Remove.
	(hppa_addr_bits_remove): Rename from hppa_smash_text_address.
	(hppa_gdbarch_init): Don't call set_gdbarch_smash_text_address.
	Caller update.
	* coffread.c (coff_symtab_read): Caller update.
	* dbxread.c (process_one_symbol): Likewise.
	* elfread.c (record_minimal_symbol): Likewise.
	* somread.c (som_symtab_read): Likewise.
@
text
@d3 1
a3 2
   Copyright (C) 1988-1989, 1991-1993, 1995-1996, 1998-2012 Free
   Software Foundation, Inc.
@


1.372
log
@	ARI fixes: sprintf rule.
	Replace sprintf function calls for char arrays by
	calls to xsnprintf calls.
	* arm-tdep.c (arm_push_dummy_call): Replace sprintf by xsnprintf.
	(arm_dwarf_reg_to_regnum, arm_return_value): Ditto.
	(arm_neon_quad_read, arm_pseudo_read): Ditto.
	(arm_neon_quad_write, arm_pseudo_write): Ditto.
	* breakpoint.c (condition_completer): Ditto.
	(create_tracepoint_from_upload): Ditto.
	* dwarf2read.c (file_full_name): Ditto.
	* gcore.c (gcore_command): Ditto.
	* gnu-nat.c (proc_string, gnu_pid_to_str): Ditto.
	* go32-nat.c (go32_sysinfo): Ditto.
	* interps.c (interp_set): Ditto.
	* m32c-tdep.c (make_types): Ditto.
	* ppc-linux-nat.c (fetch_register, store_register): Ditto.
	* remote-m32r-sdi.c (m32r_open): Ditto.
	* sol-thread.c (td_err_string): Ditto.
	(td_state_string, solaris_pid_to_str): Ditto.
	* symtab.c (gdb_mangle_name): Ditto.
	* cli/cli-script.c (execute_control_command): Ditto.
	(define_command, document_command): Ditto.
	* tui/tui-io.c (tui_rl_display_match_list): Ditto.
	* tui/tui-stack.c (tui_make_status_line): Ditto.
	* tui/tui-win.c (tui_update_gdb_sizes): Ditto.
@
text
@a462 8
/* When reading symbols, we need to zap the low bit of the address,
   which may be set to 1 for Thumb functions.  */
static CORE_ADDR
arm_smash_text_address (struct gdbarch *gdbarch, CORE_ADDR val)
{
  return val & ~1;
}

a10277 1
  set_gdbarch_smash_text_address (gdbarch, arm_smash_text_address);
@


1.371
log
@gdb/
2012-11-14  Daniel Jacobowitz  <dan@@codesourcery.com>
	    Yao Qi  <yao@@codesourcery.com>

	* arm-tdep.c (arm_addr_bits_remove): Do not adjust the low
	bit of EXC_RETURN.
	(arm_m_exception_cache, arm_m_exception_this_id)
	(arm_m_exception_prev_register, arm_m_exception_unwind_sniffer)
	(arm_m_exception_unwind): New.
	(arm_gdbarch_init): Register arm_m_exception_unwind.
@
text
@d3782 2
a3783 1
		      sprintf (name_buf, "%c%d", reg_char, reg_scaled + i);
d4114 1
a4114 1
      sprintf (name_buf, "s%d", reg - 64);
d4125 1
a4125 1
      sprintf (name_buf, "d%d", reg - 256);
d9173 1
a9173 1
	      sprintf (name_buf, "%c%d", reg_char, i);
d9627 1
a9627 1
  sprintf (name_buf, "d%d", regnum << 1);
d9679 1
a9679 1
      sprintf (name_buf, "d%d", regnum >> 1);
d9704 1
a9704 1
  sprintf (name_buf, "d%d", regnum << 1);
d9745 1
a9745 1
      sprintf (name_buf, "d%d", regnum >> 1);
@


1.370
log
@	* gdbarch.sh (target_gdbarch): Remove macro.
	(get_target_gdbarch): Rename to target_gdbarch.
	* gdbarch.c, gdbarch.h: Rebuild.
	* ada-tasks.c, aix-thread.c, amd64-linux-nat.c, arch-utils.c,
	arm-tdep.c, auxv.c, breakpoint.c, bsd-uthread.c, corefile.c,
	darwin-nat-info.c, dcache.c, dsrec.c, exec.c, fbsd-nat.c,
	filesystem.c, gcore.c, gnu-nat.c, i386-darwin-nat.c, i386-nat.c,
	ia64-vms-tdep.c, inf-ptrace.c, infcmd.c, jit.c, linux-nat.c,
	linux-tdep.c, linux-thread-db.c, m32r-rom.c, memattr.c,
	mep-tdep.c, microblaze-tdep.c, mips-linux-nat.c,
	mips-linux-tdep.c, mips-tdep.c, monitor.c, moxie-tdep.c,
	nto-procfs.c, nto-tdep.c, ppc-linux-nat.c, proc-service.c,
	procfs.c, progspace.c, ravenscar-thread.c, record.c,
	remote-m32r-sdi.c, remote-mips.c, remote-sim.c, remote.c,
	rl78-tdep.c, rs6000-nat.c, rx-tdep.c, s390-nat.c, sol-thread.c,
	solib-darwin.c, solib-dsbt.c, solib-frv.c, solib-ia64-hpux.c,
	solib-irix.c, solib-pa64.c, solib-som.c, solib-spu.c,
	solib-sunos.c, solib-svr4.c, solib.c, spu-linux-nat.c,
	spu-multiarch.c, spu-tdep.c, symfile-mem.c, symfile.c, symtab.c,
	target-descriptions.c, target.c, target.h, tracepoint.c,
	windows-nat.c, windows-tdep.c, xcoffsolib.c, cli/cli-dump.c,
	common/agent.c, mi/mi-interp.c, python/py-finishbreakpoint.c,
	python/py-inferior.c, python/python.c: Update.
@
text
@d451 6
d2935 121
d10348 2
@


1.369
log
@2012-11-07  Pedro Alves  <palves@@redhat.com>

	* arm-tdep.c: Make defs.h be the first include.
	* coff-pe-read.c: Ditto.
	* gnu-nat.c: Ditto.
	* go32-nat.c: Ditto.
	* i386-nat.c: Ditto.
	* ppcnbsd-nat.c: Ditto.
	* ada-varobj.h: Don't include defs.h.
	* i386-darwin-tdep.h: Ditto.
	* i386-nat.h: Ditto.
@
text
@d9198 1
a9198 1
  if (gdbarch_bfd_arch_info (target_gdbarch)->arch != bfd_arch_arm)
d9232 1
a9232 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (target_gdbarch);
d9235 1
a9235 1
      && gdbarch_bfd_arch_info (target_gdbarch)->arch == bfd_arch_arm)
d9269 1
a9269 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (target_gdbarch);
d9272 1
a9272 1
      && gdbarch_bfd_arch_info (target_gdbarch)->arch == bfd_arch_arm)
d9295 1
a9295 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (target_gdbarch);
@


1.368
log
@* arm-tdep.c (arm_skip_prologue): Extending producer check to support LLVM compiler.
@
text
@d21 2
a24 1
#include "defs.h"
@


1.367
log
@	* arm-tdep.c (thumb_get_next_pc_raw): Mask off low bits for bx pc
	and blx pc.

testsuite:
	* gdb.arch/thumb-bx-pc.S: New file.
	* gdb.arch/thumb-bx-pc.exp: New file.
@
text
@d1403 2
a1404 1
	      || strncmp (s->producer, "GNU ", sizeof ("GNU ") - 1) == 0))
@


1.366
log
@gdb/
	* gdbtypes.h (enum type_code): Define TYPE_CODE_BITSTRING -1.
	* arm-tdep.c (arm_type_align): Remove code handling TYPE_CODE_BITSTRING.
	* c-typeprint.c (c_type_print_varspec_prefix): Likewise.
	(c_type_print_varspec_suffix): Likewise.
	* eval.c (evaluate_subexp_standard): Likewise.
	* f-typeprint.c (f_type_print_varspec_prefix): Likewise.
	(f_type_print_varspec_suffix): Likewise.
	* gdbtypes.c (is_scalar_type): Likewise.
	(recursive_dump_type): Likewise.
	* infcall.c (value_arg_coerce): Likewise.
	* m2-valprint.c (m2_val_print): Likewise.
	* p-typeprint.c (pascal_type_print_varspec_prefix): Likewise.
	(pascal_type_print_varspec_suffix): Likewise.
	(pascal_type_print_base): Likewise.
	* p-valprint.c (pascal_val_print): Likewise.
	(pascal_val_print): Likewise.
	* valops.c (value_slice): Likewise.
	* valprint.c (scalar_type_p): Likewise.
	* valarith.c (value_bitstring_subscript): Remove.
	(value_concat): Remove code handling TYPE_CODE_BITSTRING.
	Remove comment on TYPE_CODE_BITSTRING.

	* stabsread.c (read_type): Don't set TYPE_CODE (type) to
	TYPE_CODE_BITSTRING.

	* python/py-type.c (pyty_codes): Move ENTRY (TYPE_CODE_BITSTRING) to
	slot 0.

gdb/doc:
	* gdb.texinfo (Types In Python): Mention gdb.TYPE_CODE_BITSTRING
	is deprecated.
@
text
@d4543 1
a4543 1
	nextpc = pc_val;
@


1.365
log
@2012-06-25  Greta Yorsh  <greta.yorsh@@arm.com>

	* gdb/arm-tdep.c (arm_in_function_epilogue_p): Recognize POP with a single
	register as a stack alignment in ARM mode.
@
text
@a3287 1
    case TYPE_CODE_BITSTRING:
@


1.364
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@d3220 3
@


1.363
log
@	gdb/
	* breakpoint.h (bp_location): Add related_address member.
	* inferior.h (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* value.h (using_struct_return): Likewise.
	* gdbarch.sh (return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* breakpoint.c (set_breakpoint_location_function): Initialize
	related_address for bp_gnu_ifunc_resolver breakpoints.
	* elfread.c (elf_gnu_ifunc_resolver_return_stop): Pass the
	requested function's address to gdbarch_return_value.
	* eval.c (evaluate_subexp_standard): Pass the requested
	function's address to using_struct_return.
	* infcall.c (call_function_by_hand): Pass the requested
	function's address to using_struct_return and
	gdbarch_return_value.
	* infcmd.c (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	(print_return_value): Update accordingly.
	(finish_command_continuation): Likewise.
	* stack.c (return_command): Pass the requested function's
	address to using_struct_return and gdbarch_return_value.
	* value.c (using_struct_return): Take a pointer to struct value
	instead of struct type for the function requested.  Pass the
	requested function's address to gdbarch_return_value.
	* python/py-finishbreakpoint.c (finish_breakpoint_object):
	New function_value member, replacing function_type.
	(bpfinishpy_dealloc): Update accordingly.
	(bpfinishpy_pre_stop_hook): Likewise.
	(bpfinishpy_init): Likewise.  Record the requested function's
	address.
	* mips-tdep.c (mips_fval_reg): New enum.
	(mips_o32_push_dummy_call): For MIPS16 FP doubles do not swap
	words put in GP registers.
	(mips_o64_push_dummy_call): Update a comment.
	(mips_o32_return_value): Take a pointer to struct value instead
	of struct type for the function requested and use it to check if
	using the MIPS16 calling convention.  Return the designated
	general purpose registers for floating-point values returned in
	MIPS16 mode.
	(mips_o64_return_value): Likewise.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Update prototype.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* alpha-tdep.c (alpha_return_value): Take a pointer to struct
	value instead of struct type for the function requested.
	* amd64-tdep.c (amd64_return_value): Likewise.
	* amd64-windows-tdep.c (amd64_windows_return_value): Likewise.
	* arm-tdep.c (arm_return_value): Likewise.
	* avr-tdep.c (avr_return_value): Likewise.
	* bfin-tdep.c (bfin_return_value): Likewise.
	* cris-tdep.c (cris_return_value): Likewise.
	* frv-tdep.c (frv_return_value): Likewise.
	* h8300-tdep.c (h8300_return_value): Likewise.
	(h8300h_return_value): Likewise.
	* hppa-tdep.c (hppa32_return_value): Likewise.
	(hppa64_return_value): Likewise.
	* i386-tdep.c (i386_return_value): Likewise.
	* ia64-tdep.c (ia64_return_value): Likewise.
	* iq2000-tdep.c (iq2000_return_value): Likewise.
	* lm32-tdep.c (lm32_return_value): Likewise.
	* m32c-tdep.c (m32c_return_value): Likewise.
	* m32r-tdep.c (m32r_return_value): Likewise.
	* m68hc11-tdep.c (m68hc11_return_value): Likewise.
	* m68k-tdep.c (m68k_return_value): Likewise.
	(m68k_svr4_return_value): Likewise.
	* m88k-tdep.c (m88k_return_value): Likewise.
	* mep-tdep.c (mep_return_value): Likewise.
	* microblaze-tdep.c (microblaze_return_value): Likewise.
	* mn10300-tdep.c (mn10300_return_value): Likewise.
	* moxie-tdep.c (moxie_return_value): Likewise.
	* mt-tdep.c (mt_return_value): Likewise.
	* ppc-linux-tdep.c (ppc_linux_return_value): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Likewise.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Likewise.
	* rl78-tdep.c (rl78_return_value): Likewise.
	* rs6000-aix-tdep.c (rs6000_return_value): Likewise.
	* rx-tdep.c (rx_return_value): Likewise.
	* s390-tdep.c (s390_return_value): Likewise.
	* score-tdep.c (score_return_value): Likewise.
	* sh-tdep.c (sh_return_value_nofpu): Likewise.
	(sh_return_value_fpu): Likewise.
	* sh64-tdep.c (sh64_return_value): Likewise.
	* sparc-tdep.c (sparc32_return_value): Likewise.
	* sparc64-tdep.c (sparc64_return_value): Likewise.
	* spu-tdep.c (spu_return_value): Likewise.
	* tic6x-tdep.c (tic6x_return_value): Likewise.
	* v850-tdep.c (v850_return_value): Likewise.
	* vax-tdep.c (vax_return_value): Likewise.
	* xstormy16-tdep.c (xstormy16_return_value): Likewise.
	* xtensa-tdep.c (xtensa_return_value): Likewise.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.

	gdb/testsuite/
	* gdb.base/return-nodebug.exp: Also test float and double types.
@
text
@a382 1
  struct obj_section *sec;
d1287 1
a1287 1
  unsigned int address, basereg;
a1378 1
  struct symtab_and_line sal;
a1536 1
  CORE_ADDR current_pc;
d5132 1
a5132 1
  gdb_byte *new_buf, *middle;
d5165 1
a5165 1
  int buf_len, buf2_len;
d6865 1
a6865 1
  int load_executed = condition_true (dsc->u.block.cond, status), i;
a8706 2
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

a9280 2
  struct gdbarch_tdep *tdep = gdbarch_tdep (target_gdbarch);

a9569 1
  gdb_byte reg_buf[8];
@


1.362
log
@	* arm-tdep.h (VFP_REGISTER_SIZE): Define.
	* features/arm-with-m-vfp-d16.xml: New file. Describes
	Cortex-M with VFPv4-sp-d16 FPU register layout.
	* features/Makefile (WHICH): Add arm-with-m-vfp-d16.
	* features/arm-with-m-vfp-d16.c: New. Generated from above.
	* arm-tdep.c: Include arm-with-m-vfp-d16.c.
	(arm-register_g_packet_guesses): Add vfp-d16 guess.
	(_initialise_arm_tdep): Initialize arm-with-m-vfp-d16 tdesc.
@
text
@d9014 1
a9014 1
arm_return_value (struct gdbarch *gdbarch, struct type *func_type,
d9019 1
@


1.361
log
@        * features/Makefile (WHICH): Add arm-with-m and arm-with-m-fpa-layout.
        * arm-tdep.c (arm_register_g_packet_guesses): Fix comment.
@
text
@d62 1
d9702 8
d10345 1
@


1.360
log
@       * arm-linux-tdep.c (arm_linux_init_abi): Call
       set_gdbarch_process_record.
       Initialize `arm_swi_record' field.

       * arm-tdep.c (arm_process_record): New function.
       (deallocate_reg_mem): New function.
       (decode_insn): New function.
       (thumb_record_branch): New function.
       (thumb_record_ldm_stm_swi(): New function.
       (thumb_record_misc): New function.
       (thumb_record_ld_st_stack): New function.
       (thumb_record_ld_st_imm_offset): New function.
       (thumb_record_ld_st_reg_offset(): New function.
       (thumb_record_add_sub_cmp_mov): New function.
       (thumb_record_shift_add_sub): New function.
       (arm_record_coproc_data_proc): New function.
       (arm_record_coproc): New function.
       (arm_record_b_bl): New function.
       (arm_record_ld_st_multiple): New function.
       (arm_record_ld_st_reg_offset): New function.
       (arm_record_ld_st_imm_offset): New function.
       (arm_record_data_proc_imm): New function.
       (arm_record_data_proc_misc_ld_str): New function.
       (arm_record_extension_space): New function.
       (arm_record_strx): New function.
       (sbo_sbz): New function.
       (struct insn_decode_record): New structure for arm insn record.
       (REG_ALLOC): New macro for reg allocations.
       (MEM_ALLOC): New macro for memory allocations.

       * arm-tdep.h (struct gdbarch_tdep): New field 'arm_swi_record'
@
text
@d9689 1
a9689 1
				      /* r0-r12,sp,lr,pc; f0-f7; fps,cpsr */
@


1.359
log
@	* arm-tdep.c: Include "remote.h" and "features/arm-with-m-fpa-layout.c".
	(arm_register_g_packet_guesses): New function.
	(arm_gdbarch_init): Don't force a target description with
	registers when the executable is detected as M-profile.  Instead
	set gdbarch->tdep->is_m.  Register `g' packet guesses.
	(_initialize_arm_tdep): Initialize the new target description.
	* features/arm-with-m-fpa-layout.xml: New description.
	* features/arm-with-m-fpa-layout.c: New, generated.
@
text
@d58 2
d10449 2059
@


1.358
log
@	* blockframe.c (find_pc_partial_function_gnu_ifunc): Change type of
	"name" parameter to const char ** from char **.  All callers updated.
	(find_pc_partial_function): Ditto.
	(cache_pc_function_name): Change type to const char * from char *.
	* symtab.h ((find_pc_partial_function_gnu_ifunc): Update.
	(find_pc_partial_function): Update.
	* alpha-tdep.h (struct gdbarch_tdep, member pc_in_sigtramp): Change
	type of "name" parameter to const char * from char *.
	All uses updated.
	* arch-utils.c (generic_in_solib_return_trampoline): Change
	type of "name" parameter to const char * from char *.
	* arch-utils.h (generic_in_solib_return_trampoline): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Change
	type of "name" parameter to const char * from char *.
	* gdbarch.sh (in_solib_return_trampoline): Ditto.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Update.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Update.
	* m32r-linux-tdep.c (m32r_linux_pc_in_sigtramp): Change
	type of "name" parameter to const char * from char *.
	* skip.c (skip_function_pc): Ditto.
	* sparc-sol2-tdep.c (sparc_sol2_pc_in_sigtramp): Ditto.
	* sparc-tdep.h (sparc_sol2_pc_in_sigtramp): Update.
	* sparc64fbsd-tdep.c (sparc64fbsd_pc_in_sigtramp): Ditto.
	* sparc64nbsd-tdep.c (sparc64nbsd_pc_in_sigtramp): Ditto.
	* sparc64obsd-tdep.c (sparc64obsd_pc_in_sigtramp): Ditto.
	* sparcnbsd-tdep.c (sparc32nbsd_pc_in_sigtramp): Ditto.
	* sparcobsd-tdep.c (sparc32obsd_pc_in_sigtramp): Ditto.
	* nbsd-tdep.c (nbsd_pc_in_sigtramp): Similary for "func_name".
	* nbsd-tdep.h (nbsd_pc_in_sigtramp): Update.
@
text
@d43 1
d59 1
d9670 35
d9838 1
a9838 1
		tdesc = tdesc_arm_with_m;
d10095 2
d10333 1
@


1.357
log
@gdb/
	Code cleanup: Make 1440 bytes of data segment read-only.
	* arch-utils.c (endian_enum): Make it const char *const [].
	* arm-tdep.c (fp_model_strings, arm_abi_strings, arm_mode_strings):
	Likewise.
	* breakpoint.c (always_inserted_enums): Likewise.
	* cli/cli-cmds.c (script_ext_enums): Likewise.
	* cli/cli-decode.c (add_setshow_enum_cmd, complete_on_enum): Make the
	enumlist parameter const char *const *.
	* cli/cli-decode.h (struct cmd_list_element): Make the enums field
	const char *const *.
	* command.h (complete_on_enum, add_setshow_enum_cmd): Make the enumlist
	parameter const char *const *.
	* cris-tdep.c (cris_modes): Make it const char *const [].
	* filesystem.c (target_file_system_kinds): Likewise.
	* i386-tdep.c (valid_flavors, valid_conventions): Likewise.
	* infrun.c (follow_fork_mode_kind_names, follow_exec_mode_names)
	(can_use_displaced_stepping_enum, scheduler_enums)
	(exec_direction_names): Likewise.
	* language.c (_initialize_language): Make the type_or_range_names and
	case_sensitive_names variables const char *const [].
	* mips-tdep.c (mips_abi_strings): Make it const char *const [].
	* python/python.c (python_excp_enums): Likewise.
	* remote.c (interrupt_sequence_modes): Likewise.
	* rs6000-tdep.c (powerpc_vector_strings): Likewise.
	* serial.c (logbase_enums): Likewise.
	* sh-tdep.c (sh_cc_enum): Likewise.
	* stack.c (print_frame_arguments_choices, print_entry_values_choices):
	Likewise.
	* symtab.c (multiple_symbols_modes): Likewise.
	* tui/tui-win.c (tui_border_kind_enums, tui_border_mode_enums):
	Likewise.
	* utils.c (internal_problem_modes): Likewise.
@
text
@d9104 1
a9104 1
  char *name;
@


1.356
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d100 1
a100 1
static const char *fp_model_strings[] =
d115 1
a115 1
static const char *arm_abi_strings[] =
d128 1
a128 1
static const char *arm_mode_strings[] =
@


1.355
log
@gdb/
	PR tdep/12797
	* arm-tdep.c (arm_return_value): Handle complex types.

gdb/testsuite/
	PR tdep/12797
	* gdb.base/callfuncs.exp: Remove KFAIL.
@
text
@d3 2
a4 3
   Copyright (C) 1988, 1989, 1991, 1992, 1993, 1995, 1996, 1998, 1999, 2000,
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.354
log
@	* arm-tdep.h (arm_deal_with_atomic_sequence): Add prototype.
	* arm-tdep.c (thumb_deal_with_atomic_sequence_raw): New function.
	(arm_deal_with_atomic_sequence_raw): Likewise.
	(arm_deal_with_atomic_sequence): Likewise.
	(arm_software_single_step): Call it.
	* arm-linux-tdep.c (arm_linux_software_single_step): Likewise.
@
text
@d9064 6
@


1.354.2.1
log
@gdb/
	PR tdep/12797
	* arm-tdep.c (arm_return_value): Handle complex types.

gdb/testsuite/
	PR tdep/12797
	* gdb.base/callfuncs.exp: Remove KFAIL.
@
text
@a9063 6
  /* AAPCS returns complex types longer than a register in memory.  */
  if (tdep->arm_abi != ARM_ABI_APCS
      && TYPE_CODE (valtype) == TYPE_CODE_COMPLEX
      && TYPE_LENGTH (valtype) > INT_REGISTER_SIZE)
    return RETURN_VALUE_STRUCT_CONVENTION;

@


1.354.2.2
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 3
a5 2
   Copyright (C) 1988-1989, 1991-1993, 1995-1996, 1998-2012 Free
   Software Foundation, Inc.
@


1.353
log
@gdb/
* arm-tdep.c (thumb_analyze_prologue): Always fallback on the SP
register when the frame can't be determined.
* arm-tdep.c (arm_analyze_prologue): Ditto.

gdb/testsuite/
* gdb.arch/thumb-prologue.c (switch_stack_to_same): New test function.
(switch_stack_to_other): New test function.
* gdb.arch/thumb-prologue.exp: New test cases.
@
text
@d4882 220
d5112 4
a5115 1
  CORE_ADDR next_pc = arm_get_next_pc (frame, get_frame_pc (frame));
d5117 1
@


1.352
log
@	PR gdb/12703
	* arm-tdep.c (thumb_analyze_prologue): Call thumb_insn_size to check
	whether insn is a 32-bit Thumb-2 instruction.
	(thumb_in_function_epilogue_p): Likewise.
	(thumb_get_next_pc_raw): Likewise.
	(arm_breakpoint_from_pc): Likewise.
@
text
@d1155 1
a1155 1
  else if (pv_is_register (regs[ARM_SP_REGNUM], ARM_SP_REGNUM))
a1160 6
  else
    {
      /* We're just out of luck.  We don't know where the frame is.  */
      cache->framereg = -1;
      cache->framesize = 0;
    }
d1880 1
a1880 1
  else if (pv_is_register (regs[ARM_SP_REGNUM], ARM_SP_REGNUM))
a1885 6
  else
    {
      /* We're just out of luck.  We don't know where the frame is.  */
      framereg = -1;
      framesize = 0;
    }
@


1.351
log
@	gdb/
	* arm-tdep.c (arm_get_next_pc_raw): Use read_memory_unsigned_integer
	to get address.
@
text
@d234 2
d841 1
a841 1
      else if ((insn & 0xe000) == 0xe000)
d3098 1
a3098 1
      else if ((insn & 0xe000) == 0xe000)  /* 32-bit Thumb-2 instruction */
d4340 3
a4342 8
	{
	  /* Advance to the next instruction.  All the 32-bit
	     instructions share a common prefix.  */
	  if ((inst1 & 0xe000) == 0xe000 && (inst1 & 0x1800) != 0)
	    return MAKE_THUMB_ADDR (pc + 4);
	  else
	    return MAKE_THUMB_ADDR (pc + 2);
	}
d4376 1
a4376 1
  else if ((inst1 & 0xe000) == 0xe000) /* 32-bit instruction */
d8472 1
a8472 1
	      if ((inst1 & 0xe000) == 0xe000 && (inst1 & 0x1800) != 0)
@


1.350
log
@	Support displaced stepping for Thumb 16-bit insns.
	gdb/
	* arm-tdep.c (THUMB_NOP) Define.
	(thumb_copy_unmodified_16bit): New.
	(thumb_copy_b, thumb_copy_bx_blx_reg): New.
	(thumb_copy_alu_reg): New.
	(arm_copy_svc): Move some common code to ...
	(install_svc): ... here.  New.
	(thumb_copy_svc): New.
	(install_pc_relative): New.
	(thumb_copy_pc_relative_16bit): New.
	(thumb_decode_pc_relative_16bit): New.
	(thumb_copy_16bit_ldr_literal): New.
	(thumb_copy_cbnz_cbz): New.
	(cleanup_pop_pc_16bit_all): New.
	(thumb_copy_pop_pc_16bit): New.
	(thumb_process_displaced_16bit_insn): New.
	(thumb_process_displaced_32bit_insn): New.
	(thumb_process_displaced_insn): process thumb instruction.

	Support displaced stepping for Thumb 32-bit insns.
	gdb/
	* arm-tdep.c (thumb_copy_unmodified_32bit): New.
	(thumb2_copy_preload): New.
	(thumb2_copy_copro_load_store): New.
	(thumb2_copy_b_bl_blx): New.
	(thumb2_copy_alu_imm): New.
	(thumb2_copy_load_reg_imm): New.
	(thumb2_copy_load_literal): New
	(thumb2_copy_block_xfer): New.
	(thumb_32bit_copy_undef): New.
	(thumb_32bit_copy_unpred): New.
	(thumb2_decode_ext_reg_ld_st): New.
	(thumb2_decode_svc_copro): New.
	(decode_thumb_32bit_store_single_data_item): New.
	(thumb_copy_pc_relative_32bit): New.
	(thumb_decode_pc_relative_32bit): New.
	(decode_thumb_32bit_ld_mem_hints): New.
	(thumb2_copy_table_branch): New
	(thumb_process_displaced_32bit_insn): Process Thumb 32-bit
	instructions.

	gdb/testsuite/
	* gdb.arch/arm-disp-step.S (test_ldr_literal): Test for Thumb
	instructions.
	(test_adr_32bit, test_pop_pc): Likewise.
	(test_ldr_literal_16, test_cbz_cbnz, test_adr): New test for
	Thumb instructions.
	* gdb.arch/arm-disp-step.exp (test_ldm_stm_pc): Match $gdb_prompt
	in gdb_test_multiple.
	(test_ldr_literal_16, test_cbz_cbnz, test_adr): New.
@
text
@d4782 3
a4784 2
		  nextpc = (CORE_ADDR) read_memory_integer ((CORE_ADDR) base,
							    4, byte_order);
d4798 3
d4813 4
a4816 9
		  {
		    unsigned long rn_val =
		    get_frame_register_unsigned (frame,
						 bits (this_instr, 16, 19));
		    nextpc =
		      (CORE_ADDR) read_memory_integer ((CORE_ADDR) (rn_val
								  + offset),
						       4, byte_order);
		  }
@


1.349
log
@	gdb/
	* arm-tdep.c (install_copro_load_store): PC is set 4-byte aligned.
	(install_b_bl_blx): Likewise.
@
text
@d5126 1
d5349 34
d5433 48
d5592 26
d5710 94
d5849 20
d5929 52
d6055 25
d6348 106
d6844 13
a6856 2
/* Cleanup/copy SVC (SWI) instructions.  These two functions are overridden
   for Linux, where some SVC instructions must be treated specially.  */
d6858 7
a6864 5
static void
cleanup_svc (struct gdbarch *gdbarch, struct regcache *regs,
	     struct displaced_step_closure *dsc)
{
  CORE_ADDR resume_addr = dsc->insn_addr + dsc->insn_size;
d6867 2
a6868 2
    fprintf_unfiltered (gdb_stdlog, "displaced: cleanup for svc, resume at "
			"%.8lx\n", (unsigned long) resume_addr);
d6870 3
a6872 2
  displaced_write_reg (regs, dsc, ARM_PC_REGNUM, resume_addr, BRANCH_WRITE_PC);
}
d6874 7
a6880 1
static int
d6882 12
a6893 3
arm_copy_svc (struct gdbarch *gdbarch, uint32_t insn,
	      struct regcache *regs, struct displaced_step_closure *dsc)
{
d6895 2
a6896 3
  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: copying svc insn %.8lx\n",
			(unsigned long) insn);
d6898 51
d6951 1
a6951 3
     Cleanup: pc <- insn_addr + 4.  */

  dsc->modinsn[0] = insn;
d6965 1
d6967 26
d7011 17
d7424 59
d7529 663
d8197 18
a8214 1
  error (_("Displaced stepping is only supported in ARM mode"));
@


1.348
log
@	gdb/
        * arm-tdep.c (install_ldr_str_ldrb_strb): Renamed to ...
        (install_load_store): ... this.  New.
        Change parameter BYTE to SIZE.
        (arm_copy_ldr_str_ldrb_strb): Update caller.
        (arm_decode_ld_st_word_ubyte): Update caller.
@
text
@d5478 2
d5560 5
d5566 1
a5566 1
    dsc->u.branch.dest = dsc->insn_addr + 4 + offset;
d5568 1
a5568 1
    dsc->u.branch.dest = dsc->insn_addr + 8 + offset;
@


1.347
log
@	* symfile-mem.c (symbol_file_add_from_memory): Call do_cleanups.
	* solib-svr4.c (open_symbol_file_object): Call do_cleanups on all
	return paths.  Defer final do_cleanups until last return.
	* arm-tdep.c (arm_exidx_new_objfile): Make null cleanup after
	early return.
@
text
@d5985 1
a5985 1
/* Copy byte/word loads and stores.  */
d5988 4
a5991 4
install_ldr_str_ldrb_strb (struct gdbarch *gdbarch, struct regcache *regs,
			   struct displaced_step_closure *dsc, int load,
			   int immed, int writeback, int byte, int usermode,
			   int rt, int rm, int rn)
d6012 1
a6012 1
  dsc->u.ldst.xfersize = byte ? 1 : 4;
d6045 1
a6045 1
			    int load, int byte, int usermode)
d6059 2
a6060 2
			load ? (byte ? "ldrb" : "ldr")
			     : (byte ? "strb" : "str"), usermode ? "t" : "",
d6064 2
a6065 2
  install_ldr_str_ldrb_strb (gdbarch, regs, dsc, load, immed, writeback, byte,
			     usermode, rt, rm, rn);
d6765 1
a6765 1
    return arm_copy_ldr_str_ldrb_strb (gdbarch, insn, regs, dsc, 0, 0, 0);
d6768 1
a6768 1
    return arm_copy_ldr_str_ldrb_strb (gdbarch, insn, regs, dsc, 0, 0, 1);
d6771 1
a6771 1
    return arm_copy_ldr_str_ldrb_strb (gdbarch, insn, regs, dsc, 1, 0, 0);
d6774 1
a6774 1
    return arm_copy_ldr_str_ldrb_strb (gdbarch, insn, regs, dsc, 1, 0, 1);
@


1.346
log
@	* arm-linux-tdep.c: Include "auxv.h".
	(AT_HWCAP): Define.
	(ARM_LINUX_SIZEOF_VFP): Define.
	(arm_linux_supply_vfp): New function.
	(arm_linux_collect_vfp): Likewise.
	(arm_linux_regset_from_core_section): Handle .reg-arm-vfp sections.
	(arm_linux_fpa_regset_sections): New variable.
	(arm_linux_vfp_regset_sections): Likewise.
	(arm_linux_core_read_description): New function.
	(arm_linux_init_abi): Install arm_linux_core_read_description and
	arm_linux_fpa_regset_sections or arm_linux_vfp_regset_sections as
	appropriate for the architecture.
	* arm-tdep.h (struct gdbarch_tdep): Add member "vfpregset".
	(tdesc_arm_with_m): Declare.
	(tdesc_arm_with_iwmmxt): Likewise.
	(tdesc_arm_with_vfpv2): Likewise.
	(tdesc_arm_with_vfpv3): Likewise.
	(tdesc_arm_with_neon): Likewise.
	* arm-linux-nat.c: Move features/*.c includes ...
	* arm-tdep.c: ... here.
	* arm-linux-nat.c (arm_linux_read_description): Move initializing
	target description data structures ...
	* arm-tdep.c (_initialize_arm_tdep): ... here.
	* arm-linux-nat.c (HWCAP_VFP, HWCAP_IWMMXT, HWCAP_NEON, HWCAP_VFPv3,
	HWCAP_VFPv3D16): Move definitions ...
	* arm-linux-tdep.h: ... here.
@
text
@d2214 1
a2214 1
  struct cleanup *cleanups = make_cleanup (null_cleanup, NULL);
d2225 1
@


1.345
log
@2011-04-28  Yao Qi  <yao@@codesourcery.com>

	* arm-tdep.c (copy_unmodified): Rename to ...
	(arm_copy_unmodified): .. this.  New.
	(copy_preload): Move common part to ...
	(install_preload): .. this.  New.
	(arm_copy_preload): New.
	(copy_preload_reg): Move common part to ...
	(install_preload_reg): ... this.  New.
	(arm_copy_preload_reg): New.
	(copy_b_bl_blx): Move common part to ...
	(install_b_bl_blx): .. this.  New.
	(arm_copy_b_bl_blx): New.
	(copy_bx_blx_reg): Move common part to ...
	(install_bx_blx_reg): ... this. New.
	(arm_copy_bx_blx_reg): New.
	(copy_alu_reg): Move common part to ...
	(install_alu_reg): ... this.  New.
	(arm_copy_alu_reg): New.
	(copy_alu_shifted_reg): Move common part to ...
	(install_alu_shifted_reg): ... this.  New.
	(copy_ldr_str_ldrb_strb): Move common part to ...
	(install_ldr_str_ldrb_strb): ... this.  New.
	(arm_copy_ldr_str_ldrb_strb): New.
	(copy_copro_load_store): Move some common part to ...
	(install_copy_copro_load_store): ... this.  New.
	(arm_copy_copro_load_store): New.
	(copy_svc): Delete.
	(arm_copy_svc): Renamed from copy_svc.
	(copy_undef): Delete.
	(arm_copy_undef): Renamed from copy_undef.
	(decode_ext_reg_ld_st): Delete.
	(arm_decode_ext_reg_ld_st): Renamed from decode_ext_reg_ld_st.
	(decode_svc_copro): Delete.
	(arm_decode_svc_copro): Renamed from decode_svc_copro.
	(copy_copro_load_store, copy_alu_imm): update callers.
	(copy_extra_ld_st, copy_block_xfer): Likewise.
	(decode_misc_memhint_neon, decode_unconditional): Likewise.
	(decode_miscellaneous, decode_dp_misc): Likewise.
	(decode_ld_st_word_ubyte, decode_media): Likewise.
	(decode_b_bl_ldmstm, decode_ext_reg_ld_st): Likewise.
	(decode_svc_copro, decode_misc_memhint_neon): Likewise.
	(decode_unconditional, decode_miscellaneous): Likewise.
	(decode_media, decode_b_bl_ldmstm): Likewise.
	(arm_process_displaced_insn): Likewise..
	(decode_misc_memhint_neon): Delete.
	(arm_decode_misc_memhint_neon): Renamed from decode_misc_memhint_neon.
	(decode_miscellaneous): Delete.
	(arm_decode_miscellaneous): Renamed from decode_miscellaneous.
	(decode_dp_misc): Delete.
	(arm_decode_dp_misc): Renamed from decode_dp_misc.
	(decode_ld_st_word_ubyte): Delete.
	(arm_decode_ld_st_word_ubyte): Renamed from decode_ld_st_word_ubyte.
	(decode_media): Delete.
	(arm_decode_media): Renamed from decode_media.
	(decode_b_bl_ldmstm): Delete.
	(arm_decode_b_bl_ldmstm): Renamed from decode_b_bl_ldmstm.
	(decode_ext_reg_ld_st): Delete.
	(arm_decode_ext_reg_ld_st): Renamed from decode_ext_reg_ld_st.
	(decode_unconditional): Delete.
	(arm_decode_unconditional): Renamed from decode_unconditional.
@
text
@d59 4
d8807 4
@


1.344
log
@gdb
	* windows-tdep.c (windows_xfer_shared_library):
	* windows-nat.c (get_module_name, windows_make_so):
	* v850-tdep.c (v850_handle_pushm):
	* utils.c (null_cleanup, gdb_realpath):
	* ui-out.c (get_next_header):
	* tracepoint.c (clear_traceframe_info):
	* symtab.c (lookup_symtab):
	* serial.h (struct serial_ops):
	* mipsread.c (read_alphacoff_dynamic_symtab):
	* infcmd.c (print_return_value):
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address):
	* f-exp.y (parse_number):
	* exceptions.c (catch_exceptions):
	* dummy-frame.c (dummy_frame_this_id):
	* defs.h (struct cleanup):
	* breakpoint.c (disable_breakpoints_in_unloaded_shlib):
	* arm-tdep.c (arm_push_dummy_call):
	* amd64-tdep.h (amd64_collect_xsave):
	* amd64-tdep.c (amd64_collect_xsave):
	* alpha-tdep.c (alpha_heuristic_frame_unwind_cache):
	* README (typing): Remove duplicate words.
	* cli/cli-decode.c (lookup_cmd_composition): Add comma.
	* infrun.c (siginfo_value_read): Fix typo.
	* solib-frv.c (frv_fdpic_find_global_pointer): Likewise.
	* top.c (source_line_number): Add comma.
gdb/doc
	* gdbint.texinfo (Register Information Functions): Remove
	duplicate "the".
	* gdb.texinfo (Emacs): Remove duplicate "to".
	(GDB/MI Variable Objects): Remove duplicate "the".
	(General Query Packets): Likewise.
gdb/testsuite
	* gdb.mi/mi-nsmoribund.exp:
	* gdb.hp/gdb.objdbg/objdbg01.exp:
	* gdb.base/structs.exp (test_struct_returns):
	* gdb.base/call-sc.exp (test_scalar_returns):
	* gdb.base/bigcore.exp: Remove duplicate words.
gdb/gdbserver
	* win32-low.c (handle_load_dll): Remove duplicate "the".
@
text
@d5330 2
a5331 2
copy_unmodified (struct gdbarch *gdbarch, uint32_t insn,
		 const char *iname, struct displaced_step_closure *dsc)
d5354 3
a5356 3
static int
copy_preload (struct gdbarch *gdbarch, uint32_t insn, struct regcache *regs,
	      struct displaced_step_closure *dsc)
a5357 1
  unsigned int rn = bits (insn, 16, 19);
a5358 8

  if (!insn_references_pc (insn, 0x000f0000ul))
    return copy_unmodified (gdbarch, insn, "preload", dsc);

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: copying preload insn %.8lx\n",
			(unsigned long) insn);

a5367 1

a5369 2
  dsc->modinsn[0] = insn & 0xfff0ffff;

a5370 2

  return 0;
a5372 2
/* Preload instructions with register offset.  */

d5374 1
a5374 2
copy_preload_reg (struct gdbarch *gdbarch, uint32_t insn,
		  struct regcache *regs,
a5377 2
  unsigned int rm = bits (insn, 0, 3);
  ULONGEST rn_val, rm_val;
d5379 2
a5380 2
  if (!insn_references_pc (insn, 0x000f000ful))
    return copy_unmodified (gdbarch, insn, "preload reg", dsc);
d5386 16
d5414 1
d5416 18
a5433 1
  dsc->u.preload.immed = 0;
d5437 1
a5437 2
  dsc->cleanup = &cleanup_preload;

d5456 4
a5459 4
static int
copy_copro_load_store (struct gdbarch *gdbarch, uint32_t insn,
		       struct regcache *regs,
		       struct displaced_step_closure *dsc)
a5460 1
  unsigned int rn = bits (insn, 16, 19);
a5462 7
  if (!insn_references_pc (insn, 0x000f0000ul))
    return copy_unmodified (gdbarch, insn, "copro load/store", dsc);

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: copying coprocessor "
			"load/store insn %.8lx\n", (unsigned long) insn);

d5475 1
a5475 1
  dsc->u.ldst.writeback = bit (insn, 25);
d5478 17
d5497 1
a5497 1
  dsc->cleanup = &cleanup_copro_load_store;
d5536 24
d5561 2
a5562 2
copy_b_bl_blx (struct gdbarch *gdbarch, uint32_t insn,
	       struct regcache *regs, struct displaced_step_closure *dsc)
a5566 1
  CORE_ADDR from = dsc->insn_addr;
a5572 9

  /* Implement "BL<cond> <label>" as:

     Preparation: cond <- instruction condition
     Insn: mov r0, r0  (nop)
     Cleanup: if (condition true) { r14 <- pc; pc <- label }.

     B<cond> similar, but don't set r14 in cleanup.  */

a5582 5
  dsc->u.branch.cond = cond;
  dsc->u.branch.link = link;
  dsc->u.branch.exchange = exchange;
  dsc->u.branch.dest = from + 8 + offset;

d5585 1
a5585 2
  dsc->cleanup = &cleanup_branch;

d5591 4
a5594 3
static int
copy_bx_blx_reg (struct gdbarch *gdbarch, uint32_t insn,
		 struct regcache *regs, struct displaced_step_closure *dsc)
a5595 11
  unsigned int cond = bits (insn, 28, 31);
  /* BX:  x12xxx1x
     BLX: x12xxx3x.  */
  int link = bit (insn, 5);
  unsigned int rm = bits (insn, 0, 3);

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: copying %s register insn "
			"%.8lx\n", (link) ? "blx" : "bx",
			(unsigned long) insn);

d5608 1
d5611 17
d5630 1
a5630 2
  dsc->cleanup = &cleanup_branch;

d5647 2
a5648 2
copy_alu_imm (struct gdbarch *gdbarch, uint32_t insn, struct regcache *regs,
	      struct displaced_step_closure *dsc)
d5657 1
a5657 1
    return copy_unmodified (gdbarch, insn, "ALU immediate", dsc);
d5711 4
a5714 3
static int
copy_alu_reg (struct gdbarch *gdbarch, uint32_t insn, struct regcache *regs,
	      struct displaced_step_closure *dsc)
a5715 5
  unsigned int rn = bits (insn, 16, 19);
  unsigned int rm = bits (insn, 0, 3);
  unsigned int rd = bits (insn, 12, 15);
  unsigned int op = bits (insn, 21, 24);
  int is_mov = (op == 0xd);
a5717 7
  if (!insn_references_pc (insn, 0x000ff00ful))
    return copy_unmodified (gdbarch, insn, "ALU reg", dsc);

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: copying reg %s insn %.8lx\n",
			is_mov ? "move" : "ALU", (unsigned long) insn);

d5741 17
d5763 2
a5764 2
  dsc->cleanup = &cleanup_alu_reg;

d5784 5
a5788 4
static int
copy_alu_shifted_reg (struct gdbarch *gdbarch, uint32_t insn,
		      struct regcache *regs,
		      struct displaced_step_closure *dsc)
d5790 1
a5790 6
  unsigned int rn = bits (insn, 16, 19);
  unsigned int rm = bits (insn, 0, 3);
  unsigned int rd = bits (insn, 12, 15);
  unsigned int rs = bits (insn, 8, 11);
  unsigned int op = bits (insn, 21, 24);
  int is_mov = (op == 0xd), i;
a5792 8
  if (!insn_references_pc (insn, 0x000fff0ful))
    return copy_unmodified (gdbarch, insn, "ALU shifted reg", dsc);

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: copying shifted reg %s insn "
			"%.8lx\n", is_mov ? "move" : "ALU",
			(unsigned long) insn);

d5819 24
d5849 1
a5849 1
  dsc->cleanup = &cleanup_alu_shifted_reg;
d5909 2
a5910 2
copy_extra_ld_st (struct gdbarch *gdbarch, uint32_t insn, int unpriveleged,
		  struct regcache *regs, struct displaced_step_closure *dsc)
d5924 1
a5924 1
    return copy_unmodified (gdbarch, insn, "extra load/store", dsc);
d5982 5
a5986 5
static int
copy_ldr_str_ldrb_strb (struct gdbarch *gdbarch, uint32_t insn,
			struct regcache *regs,
			struct displaced_step_closure *dsc, int load, int byte,
			int usermode)
a5987 4
  int immed = !bit (insn, 25);
  unsigned int rt = bits (insn, 12, 15);
  unsigned int rn = bits (insn, 16, 19);
  unsigned int rm = bits (insn, 0, 3);  /* Only valid if !immed.  */
a5989 9
  if (!insn_references_pc (insn, 0x000ff00ful))
    return copy_unmodified (gdbarch, insn, "load/store", dsc);

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: copying %s%s insn %.8lx\n",
			load ? (byte ? "ldrb" : "ldr")
			     : (byte ? "strb" : "str"), usermode ? "t" : "",
			(unsigned long) insn);

a6005 1

d6010 1
a6010 1
  dsc->u.ldst.writeback = bit (insn, 24) == 0 || bit (insn, 21) != 0;
d6033 29
d6313 3
a6315 2
copy_block_xfer (struct gdbarch *gdbarch, uint32_t insn, struct regcache *regs,
		 struct displaced_step_closure *dsc)
d6327 1
a6327 1
    return copy_unmodified (gdbarch, insn, "ldm/stm", dsc);
d6333 1
a6333 1
      return copy_unmodified (gdbarch, insn, "unpredictable ldm/stm", dsc);
d6443 3
a6445 2
copy_svc (struct gdbarch *gdbarch, uint32_t insn,
	  struct regcache *regs, struct displaced_step_closure *dsc)
d6476 2
a6477 2
copy_undef (struct gdbarch *gdbarch, uint32_t insn,
	    struct displaced_step_closure *dsc)
d6492 2
a6493 2
copy_unpred (struct gdbarch *gdbarch, uint32_t insn,
	     struct displaced_step_closure *dsc)
d6508 3
a6510 3
decode_misc_memhint_neon (struct gdbarch *gdbarch, uint32_t insn,
			  struct regcache *regs,
			  struct displaced_step_closure *dsc)
d6516 1
a6516 1
    return copy_unmodified (gdbarch, insn, "cps", dsc);
d6518 1
a6518 1
    return copy_unmodified (gdbarch, insn, "setend", dsc);
d6520 1
a6520 1
    return copy_unmodified (gdbarch, insn, "neon dataproc", dsc);
d6522 2
a6523 1
    return copy_unmodified (gdbarch, insn, "neon elt/struct load/store", dsc);
d6525 1
a6525 1
    return copy_unmodified (gdbarch, insn, "unallocated mem hint", dsc);
d6527 1
a6527 1
    return copy_preload (gdbarch, insn, regs, dsc);  /* pli.  */
d6531 1
a6531 1
	return copy_preload (gdbarch, insn, regs, dsc);  /* pld/pldw.  */
d6533 1
a6533 1
	return copy_unpred (gdbarch, insn, dsc);
d6536 1
a6536 1
    return copy_preload (gdbarch, insn, regs, dsc);  /* pld/pldw.  */
d6540 5
a6544 5
      case 0x1: return copy_unmodified (gdbarch, insn, "clrex", dsc);
      case 0x4: return copy_unmodified (gdbarch, insn, "dsb", dsc);
      case 0x5: return copy_unmodified (gdbarch, insn, "dmb", dsc);
      case 0x6: return copy_unmodified (gdbarch, insn, "isb", dsc);
      default: return copy_unpred (gdbarch, insn, dsc);
d6547 1
a6547 1
    return copy_unpred (gdbarch, insn, dsc);
d6552 1
a6552 1
	return copy_unmodified (gdbarch, insn, "unallocated mem hint", dsc);
d6554 1
a6554 1
	return copy_preload_reg (gdbarch, insn, regs, dsc);  /* pli reg.  */
d6557 1
a6557 1
	return copy_preload_reg (gdbarch, insn, regs, dsc);
d6559 1
a6559 1
	return copy_unpred (gdbarch, insn, dsc);
d6561 1
a6561 1
	return copy_undef (gdbarch, insn, dsc);
d6564 1
a6564 1
    return copy_undef (gdbarch, insn, dsc);  /* Probably unreachable.  */
d6568 3
a6570 3
decode_unconditional (struct gdbarch *gdbarch, uint32_t insn,
		      struct regcache *regs,
		      struct displaced_step_closure *dsc)
d6573 1
a6573 1
    return decode_misc_memhint_neon (gdbarch, insn, regs, dsc);
d6578 1
a6578 1
      return copy_unmodified (gdbarch, insn, "srs", dsc);
d6581 1
a6581 1
      return copy_unmodified (gdbarch, insn, "rfe", dsc);
d6584 1
a6584 1
      return copy_b_bl_blx (gdbarch, insn, regs, dsc);
d6591 1
a6591 1
	  return copy_copro_load_store (gdbarch, insn, regs, dsc);
d6594 1
a6594 1
	  return copy_unmodified (gdbarch, insn, "mcrr/mcrr2", dsc);
d6597 1
a6597 1
	  return copy_undef (gdbarch, insn, dsc);
d6607 2
a6608 2
	    return rn_f ? copy_undef (gdbarch, insn, dsc)
			: copy_copro_load_store (gdbarch, insn, regs, dsc);
d6611 1
a6611 1
	    return copy_unmodified (gdbarch, insn, "mrrc/mrrc2", dsc);
d6615 2
a6616 2
	    return rn_f ? copy_copro_load_store (gdbarch, insn, regs, dsc)
			: copy_undef (gdbarch, insn, dsc);
d6619 1
a6619 1
	    return copy_undef (gdbarch, insn, dsc);
d6624 1
a6624 1
      return copy_unmodified (gdbarch, insn, "stc/stc2", dsc);
d6629 1
a6629 1
	return copy_copro_load_store (gdbarch, insn, regs, dsc);
d6631 1
a6631 1
	return copy_undef (gdbarch, insn, dsc);
d6635 1
a6635 1
	return copy_unmodified (gdbarch, insn, "mcr/mcr2", dsc);
d6637 1
a6637 1
	return copy_unmodified (gdbarch, insn, "cdp/cdp2", dsc);
d6641 1
a6641 1
	return copy_unmodified (gdbarch, insn, "mrc/mrc2", dsc);
d6643 1
a6643 1
	return copy_unmodified (gdbarch, insn, "cdp/cdp2", dsc);
d6646 1
a6646 1
      return copy_undef (gdbarch, insn, dsc);
d6653 3
a6655 3
decode_miscellaneous (struct gdbarch *gdbarch, uint32_t insn,
		      struct regcache *regs,
		      struct displaced_step_closure *dsc)
d6664 1
a6664 1
      return copy_unmodified (gdbarch, insn, "mrs/msr", dsc);
d6668 1
a6668 1
	return copy_bx_blx_reg (gdbarch, insn, regs, dsc);
d6670 1
a6670 1
	return copy_unmodified (gdbarch, insn, "clz", dsc);
d6672 1
a6672 1
	return copy_undef (gdbarch, insn, dsc);
d6677 1
a6677 1
	return copy_unmodified (gdbarch, insn, "bxj", dsc);
d6679 1
a6679 1
	return copy_undef (gdbarch, insn, dsc);
d6683 1
a6683 1
	return copy_bx_blx_reg (gdbarch, insn,
d6686 1
a6686 1
	return copy_undef (gdbarch, insn, dsc);
d6689 1
a6689 1
      return copy_unmodified (gdbarch, insn, "saturating add/sub", dsc);
d6693 1
a6693 1
	return copy_unmodified (gdbarch, insn, "bkpt", dsc);
d6696 1
a6696 1
	return copy_unmodified (gdbarch, insn, "smc", dsc);
d6699 1
a6699 1
      return copy_undef (gdbarch, insn, dsc);
d6704 3
a6706 2
decode_dp_misc (struct gdbarch *gdbarch, uint32_t insn, struct regcache *regs,
		struct displaced_step_closure *dsc)
d6712 1
a6712 1
	return copy_unmodified (gdbarch, insn, "movw", dsc);
d6715 1
a6715 1
	return copy_unmodified (gdbarch, insn, "movt", dsc);
d6718 1
a6718 1
	return copy_unmodified (gdbarch, insn, "msr imm", dsc);
d6721 1
a6721 1
	return copy_alu_imm (gdbarch, insn, regs, dsc);
d6728 1
a6728 1
	return copy_alu_reg (gdbarch, insn, regs, dsc);
d6730 1
a6730 1
	return copy_alu_shifted_reg (gdbarch, insn, regs, dsc);
d6732 1
a6732 1
	return decode_miscellaneous (gdbarch, insn, regs, dsc);
d6734 1
a6734 1
	return copy_unmodified (gdbarch, insn, "halfword mul/mla", dsc);
d6736 1
a6736 1
	return copy_unmodified (gdbarch, insn, "mul/mla", dsc);
d6738 1
a6738 1
	return copy_unmodified (gdbarch, insn, "synch", dsc);
d6741 2
a6742 2
	return copy_extra_ld_st (gdbarch, insn, (op1 & 0x12) == 0x02, regs,
				 dsc);
d6750 3
a6752 3
decode_ld_st_word_ubyte (struct gdbarch *gdbarch, uint32_t insn,
			 struct regcache *regs,
			 struct displaced_step_closure *dsc)
d6760 1
a6760 1
    return copy_ldr_str_ldrb_strb (gdbarch, insn, regs, dsc, 0, 0, 0);
d6763 1
a6763 1
    return copy_ldr_str_ldrb_strb (gdbarch, insn, regs, dsc, 0, 0, 1);
d6766 1
a6766 1
    return copy_ldr_str_ldrb_strb (gdbarch, insn, regs, dsc, 1, 0, 0);
d6769 1
a6769 1
    return copy_ldr_str_ldrb_strb (gdbarch, insn, regs, dsc, 1, 0, 1);
d6772 1
a6772 1
    return copy_ldr_str_ldrb_strb (gdbarch, insn, regs, dsc, 0, 1, 0);
d6775 1
a6775 1
    return copy_ldr_str_ldrb_strb (gdbarch, insn, regs, dsc, 0, 1, 1);
d6778 1
a6778 1
    return copy_ldr_str_ldrb_strb (gdbarch, insn, regs, dsc, 1, 1, 0);
d6781 1
a6781 1
    return copy_ldr_str_ldrb_strb (gdbarch, insn, regs, dsc, 1, 1, 1);
d6788 2
a6789 2
decode_media (struct gdbarch *gdbarch, uint32_t insn,
	      struct displaced_step_closure *dsc)
d6794 1
a6794 1
      return copy_unmodified (gdbarch, insn, "parallel add/sub signed", dsc);
d6797 1
a6797 1
      return copy_unmodified (gdbarch, insn, "parallel add/sub unsigned", dsc);
d6801 1
a6801 1
      return copy_unmodified (gdbarch, insn,
d6808 1
a6808 1
	    return copy_unmodified (gdbarch, insn, "usad8", dsc);
d6810 1
a6810 1
	    return copy_unmodified (gdbarch, insn, "usada8", dsc);
d6813 1
a6813 1
	 return copy_undef (gdbarch, insn, dsc);
d6817 1
a6817 1
	return copy_unmodified (gdbarch, insn, "sbfx", dsc);
d6819 1
a6819 1
	return copy_undef (gdbarch, insn, dsc);
d6825 1
a6825 1
	    return copy_unmodified (gdbarch, insn, "bfc", dsc);
d6827 1
a6827 1
	    return copy_unmodified (gdbarch, insn, "bfi", dsc);
d6830 1
a6830 1
	return copy_undef (gdbarch, insn, dsc);
d6834 1
a6834 1
	return copy_unmodified (gdbarch, insn, "ubfx", dsc);
d6836 1
a6836 1
	return copy_undef (gdbarch, insn, dsc);
d6844 3
a6846 2
decode_b_bl_ldmstm (struct gdbarch *gdbarch, int32_t insn,
		    struct regcache *regs, struct displaced_step_closure *dsc)
d6849 1
a6849 1
    return copy_b_bl_blx (gdbarch, insn, regs, dsc);
d6851 1
a6851 1
    return copy_block_xfer (gdbarch, insn, regs, dsc);
d6855 3
a6857 3
decode_ext_reg_ld_st (struct gdbarch *gdbarch, uint32_t insn,
		      struct regcache *regs,
		      struct displaced_step_closure *dsc)
d6864 1
a6864 1
      return copy_unmodified (gdbarch, insn, "vfp/neon mrrc/mcrr", dsc);
d6868 1
a6868 1
      return copy_unmodified (gdbarch, insn, "vfp/neon vstm/vpush", dsc);
d6872 1
a6872 1
      return copy_unmodified (gdbarch, insn, "vfp/neon vldm/vpop", dsc);
d6878 1
a6878 1
      return copy_copro_load_store (gdbarch, insn, regs, dsc);
d6886 2
a6887 2
decode_svc_copro (struct gdbarch *gdbarch, uint32_t insn, CORE_ADDR to,
		  struct regcache *regs, struct displaced_step_closure *dsc)
d6895 1
a6895 1
    return decode_ext_reg_ld_st (gdbarch, insn, regs, dsc);
d6899 1
a6899 1
    return copy_copro_load_store (gdbarch, insn, regs, dsc);
d6903 1
a6903 1
    return copy_copro_load_store (gdbarch, insn, regs, dsc);
d6905 1
a6905 1
    return copy_undef (gdbarch, insn, dsc);
d6907 1
a6907 1
    return copy_unmodified (gdbarch, insn, "neon 64bit xfer", dsc);
d6909 1
a6909 1
    return copy_unmodified (gdbarch, insn, "mcrr/mcrr2", dsc);
d6911 1
a6911 1
    return copy_unmodified (gdbarch, insn, "mrrc/mrrc2", dsc);
d6915 1
a6915 1
	return copy_unmodified (gdbarch, insn, "vfp dataproc", dsc);
d6917 1
a6917 1
	return copy_unmodified (gdbarch, insn, "cdp/cdp2", dsc);
d6920 1
a6920 1
    return copy_unmodified (gdbarch, insn, "neon 8/16/32 bit xfer", dsc);
d6922 1
a6922 1
    return copy_unmodified (gdbarch, insn, "mcr/mcr2", dsc);
d6924 1
a6924 1
    return copy_unmodified (gdbarch, insn, "mrc/mrc2", dsc);
d6926 1
a6926 1
    return copy_svc (gdbarch, insn, regs, dsc);
d6928 1
a6928 1
    return copy_undef (gdbarch, insn, dsc);  /* Possibly unreachable.  */
d6968 1
a6968 1
    err = decode_unconditional (gdbarch, insn, regs, dsc);
d6972 1
a6972 1
      err = decode_dp_misc (gdbarch, insn, regs, dsc);
d6976 1
a6976 1
      err = decode_ld_st_word_ubyte (gdbarch, insn, regs, dsc);
d6980 1
a6980 1
      err = decode_media (gdbarch, insn, dsc);
d6984 1
a6984 1
      err = decode_b_bl_ldmstm (gdbarch, insn, regs, dsc);
d6988 1
a6988 1
      err = decode_svc_copro (gdbarch, insn, to, regs, dsc);
@


1.343
log
@2011-04-07  Yao Qi  <yao@@codesourcery.com>

	* arm-linux-tdep.c (arm_linux_copy_svc): Remove parameters INSN
	and TO.
	* arm-tdep.c (cleanup_svc): Handle variable instruction size.
	(arm_copy_svc): Remove parameters INSN and TO.
	(decode_svc_copro): Update caller.
	* arm-tdep.h (struct displaced_step_closure): Remove parameters
	from function pointer `copy_svc_os'.
@
text
@d3561 1
a3561 1
     passed on the stack, and we have to to push them.  */
@


1.342
log
@	* arm-tdep.c (cleanup_branch): Set a correct return address in
	LR for ARM and Thumb.
@
text
@d6361 1
a6361 1
  CORE_ADDR resume_addr = dsc->insn_addr + 4;
d6371 1
a6371 1
copy_svc (struct gdbarch *gdbarch, uint32_t insn, CORE_ADDR to,
a6373 3
  /* Allow OS-specific code to override SVC handling.  */
  if (dsc->u.svc.copy_svc_os)
    return dsc->u.svc.copy_svc_os (gdbarch, insn, to, regs, dsc);
a6384 1
  dsc->cleanup = &cleanup_svc;
d6389 9
a6397 1
  return 0;
d6850 1
a6850 1
    return copy_svc (gdbarch, insn, to, regs, dsc);
@


1.341
log
@	* arm-tdep.c (arm_gdbarch_init): Enfore correct register number
	for "fpscr" in target description.
@
text
@d5496 10
a5505 2
      ULONGEST pc = displaced_read_reg (regs, dsc, ARM_PC_REGNUM);
      displaced_write_reg (regs, dsc, ARM_LR_REGNUM, pc - 4, CANNOT_WRITE_PC);
@


1.340
log
@gdb/
	* arm-tdep.h (arm_insert_single_step_breakpoint): Add prototype.
	* arm-tdep.c (arm_override_mode): New global.
	(arm_pc_is_thumb): Respect arm_override_mode.  Remove single-step
	execution mode heuristics.
	(thumb_get_next_pc_raw): Remove INSERT_BKTP argument; always insert
	second single-step breakpoint if needed, using
	arm_insert_single_step_breakpoint.
	(arm_get_next_pc_raw): Remove INSERT_BKTP argument.  Only handle
	ARM execution mode, do not call thumb_get_next_pc_raw.
	(arm_get_next_pc): Encode execution mode in return value.  Call
	either arm_get_next_pc_raw or thumb_get_next_pc_raw.
	(arm_insert_single_step_breakpoint): New function.
	(arm_software_single_step): Call it.
	* arm-linux-tdep.c (arm_linux_sigreturn_return_addr): Add IS_THUMB
	argument to return execution mode of sigreturn target.
	(arm_linux_syscall_next_pc): Use it.
	(arm_linux_copy_svc): Update call.
	(arm_linux_software_single_step): Call
	arm_insert_single_step_breakpoint.

gdb/testsuite/
	* gdb.arch/thumb-singlestep.S: New file.
	* gdb.arch/thumb-singlestep.exp: Likewise.
@
text
@d8390 2
d8393 4
a8396 1
	  if (!valid_p && i != 16)
@


1.339
log
@	* arm-tdep.c (arm_elf_make_msymbol_special): Use ARM_SYM_BRANCH_TYPE
	instead of checking for STT_ARM_TFUNC symbol type.
@
text
@d136 7
a365 3
static CORE_ADDR arm_get_next_pc_raw (struct frame_info *frame, 
				      CORE_ADDR pc, int insert_bkpt);

d395 4
d429 1
a429 5
     displayed in the mode it will be executed).  
   
     As a further heuristic if we detect that we are doing a single-step we
     see what state executing the current instruction ends up with us being
     in.  */
d431 1
a431 17
    {
      struct frame_info *current_frame = get_current_frame ();
      CORE_ADDR current_pc = get_frame_pc (current_frame);
      int is_thumb = arm_frame_is_thumb (current_frame);
      CORE_ADDR next_pc;
      if (memaddr == current_pc)
	return is_thumb;
      else
	{
	  struct gdbarch *gdbarch = get_frame_arch (current_frame);
	  next_pc = arm_get_next_pc_raw (current_frame, current_pc, FALSE);
	  if (memaddr == gdbarch_addr_bits_remove (gdbarch, next_pc))
	    return IS_THUMB_ADDR (next_pc);
	  else
	    return is_thumb;
	}
    }
d4207 1
a4207 1
thumb_get_next_pc_raw (struct frame_info *frame, CORE_ADDR pc, int insert_bkpt)
d4305 2
a4306 2
	      if (insert_bkpt)
	        insert_single_step_breakpoint (gdbarch, aspace, pc);
d4578 1
a4578 2
   FRAME.  INSERT_BKPT should be TRUE if we want a breakpoint set on 
   the alternative next instruction if there are two options.
d4586 1
a4586 1
arm_get_next_pc_raw (struct frame_info *frame, CORE_ADDR pc, int insert_bkpt)
a4595 3
  if (arm_frame_is_thumb (frame))
    return thumb_get_next_pc_raw (frame, pc, insert_bkpt);

d4848 4
d4855 15
a4869 6
  struct gdbarch *gdbarch = get_frame_arch (frame);
  CORE_ADDR nextpc = 
    gdbarch_addr_bits_remove (gdbarch, 
			      arm_get_next_pc_raw (frame, pc, TRUE));
  if (nextpc == pc)
    error (_("Infinite loop detected"));
d4873 20
d4903 1
d4905 1
a4905 6
  /* NOTE: This may insert the wrong breakpoint instruction when
     single-stepping over a mode-changing instruction, if the
     CPSR heuristics are used.  */

  CORE_ADDR next_pc = arm_get_next_pc (frame, get_frame_pc (frame));
  insert_single_step_breakpoint (gdbarch, aspace, next_pc);
@


1.339.2.1
log
@gdb/
	* arm-tdep.h (arm_insert_single_step_breakpoint): Add prototype.
	* arm-tdep.c (arm_override_mode): New global.
	(arm_pc_is_thumb): Respect arm_override_mode.  Remove single-step
	execution mode heuristics.
	(thumb_get_next_pc_raw): Remove INSERT_BKTP argument; always insert
	second single-step breakpoint if needed, using
	arm_insert_single_step_breakpoint.
	(arm_get_next_pc_raw): Remove INSERT_BKTP argument.  Only handle
	ARM execution mode, do not call thumb_get_next_pc_raw.
	(arm_get_next_pc): Encode execution mode in return value.  Call
	either arm_get_next_pc_raw or thumb_get_next_pc_raw.
	(arm_insert_single_step_breakpoint): New function.
	(arm_software_single_step): Call it.
	* arm-linux-tdep.c (arm_linux_sigreturn_return_addr): Add IS_THUMB
	argument to return execution mode of sigreturn target.
	(arm_linux_syscall_next_pc): Use it.
	(arm_linux_copy_svc): Update call.
	(arm_linux_software_single_step): Call
	arm_insert_single_step_breakpoint.

gdb/testsuite/
	* gdb.arch/thumb-singlestep.S: New file.
	* gdb.arch/thumb-singlestep.exp: Likewise.
@
text
@a135 7
/* Internal override of the execution mode.  -1 means no override,
   0 means override to ARM mode, 1 means override to Thumb mode.
   The effect is the same as if arm_force_mode has been set by the
   user (except the internal override has precedence over a user's
   arm_force_mode override).  */
static int arm_override_mode = -1;

d359 3
a390 4
  /* Respect internal mode override if active.  */
  if (arm_override_mode != -1)
    return arm_override_mode;

d421 5
a425 1
     displayed in the mode it will be executed).  */
d427 17
a443 1
    return arm_frame_is_thumb (get_current_frame ());
d4219 1
a4219 1
thumb_get_next_pc_raw (struct frame_info *frame, CORE_ADDR pc)
d4317 2
a4318 2
	      arm_insert_single_step_breakpoint (gdbarch, aspace,
						 MAKE_THUMB_ADDR (pc));
d4590 2
a4591 1
   FRAME, which is assumed to be executing in ARM mode.
d4599 1
a4599 1
arm_get_next_pc_raw (struct frame_info *frame, CORE_ADDR pc)
d4609 3
a4863 4
/* Determine next PC after current instruction executes.  Will call either
   arm_get_next_pc_raw or thumb_get_next_pc_raw.  Error out if infinite
   loop is detected.  */

d4867 6
a4872 15
  CORE_ADDR nextpc;

  if (arm_frame_is_thumb (frame))
    {
      nextpc = thumb_get_next_pc_raw (frame, pc);
      if (nextpc == MAKE_THUMB_ADDR (pc))
	error (_("Infinite loop detected"));
    }
  else
    {
      nextpc = arm_get_next_pc_raw (frame, pc);
      if (nextpc == pc)
	error (_("Infinite loop detected"));
    }

a4875 20
/* Like insert_single_step_breakpoint, but make sure we use a breakpoint
   of the appropriate mode (as encoded in the PC value), even if this
   differs from what would be expected according to the symbol tables.  */

void
arm_insert_single_step_breakpoint (struct gdbarch *gdbarch,
				   struct address_space *aspace,
				   CORE_ADDR pc)
{
  struct cleanup *old_chain
    = make_cleanup_restore_integer (&arm_override_mode);

  arm_override_mode = IS_THUMB_ADDR (pc);
  pc = gdbarch_addr_bits_remove (gdbarch, pc);

  insert_single_step_breakpoint (gdbarch, aspace, pc);

  do_cleanups (old_chain);
}

d4886 5
d4892 1
a4892 2

  arm_insert_single_step_breakpoint (gdbarch, aspace, next_pc);
@


1.339.2.2
log
@	* arm-tdep.c (arm_gdbarch_init): Enfore correct register number
	for "fpscr" in target description.
@
text
@a8389 2
	  if (!valid_p && i == 16)
	    valid_p = 1;
d8391 1
a8391 4
	  /* Also require FPSCR.  */
	  valid_p &= tdesc_numbered_register (feature, tdesc_data,
					      ARM_FPSCR_REGNUM, "fpscr");
	  if (!valid_p)
@


1.338
log
@	* arm-tdep.c (arm_analyze_prologue): Do not abort parsing when
	encountering a load via a non-SP register.
@
text
@d7796 2
a7797 4
  /* Thumb symbols are of type STT_LOPROC, (synonymous with
     STT_ARM_TFUNC).  */
  if (ELF_ST_TYPE (((elf_symbol_type *)sym)->internal_elf_sym.st_info)
      == STT_LOPROC)
@


1.337
log
@	gdb/
	* frame.c (frame_unwind_register): Throw an error if unwinding the
	register failed.
	* get_prev_frame_1 (get_prev_frame_1): Ask the unwinder if there's
	an unwind stop reason.
	(frame_stop_reason_string): Handle UNWIND_UNAVAILABLE.
	* frame.h (enum unwind_stop_reason) <UNWIND_OUTERMOST,
	UNWIND_UNAVAILABLE>: New.
	* inline-frame.c (inline_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* frame-unwind.c: Include "exceptions.h".
	(frame_unwind_find_by_frame): Swallow NOT_AVAILABLE_ERROR errors.
	(default_frame_unwind_stop_reason): New.
	* frame-unwind.h (frame_unwind_stop_reason_ftype): New typedef.
	(default_frame_unwind_stop_reason): Declare.
	(struct frame_unwind) <stop_reason>: New function pointer.

	* dummy-frame.c: Install default_frame_unwind_stop_reason.
	* dwarf2-frame.c: Include exceptions.h.
	(struct dwarf2_frame_cache) <unavailable_retaddr>: New field.
	(dwarf2_frame_cache): Swallow NOT_AVAILABLE_ERROR errors when
	computing the CFA.  If such an error was thrown, set
	unavailable_retaddr.
	(dwarf2_frame_unwind_stop_reason): New.
	(dwarf2_frame_this_id): Don't build a frame id if the CFA was
	unavailable.
	(dwarf2_frame_unwind): Install dwarf2_frame_unwind_stop_reason.
	(dwarf2_signal_frame_unwind): Ditto.

	* amd64-tdep.c: Include "exceptions.h".
	(struct amd64_frame_cache): New field "base_p".
	(amd64_init_frame_cache): Clear it.
	(amd64_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(amd64_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(amd64_frame_unwind_stop_reason): New.
	(amd64_frame_this_id): Don't build a frame id if the frame base
	was unavailable.
	(amd64_frame_unwind): Install amd64_frame_unwind_stop_reason.
	(amd64_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_sigtramp_frame_unwind_stop_reason): New.
	(amd64_sigtramp_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_sigtramp_frame_unwind): Install
	amd64_sigtramp_frame_unwind_stop_reason.
	(amd64_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_epilogue_frame_unwind_stop_reason): New.
	(amd64_epilogue_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_epilogue_frame_unwind): Install
	amd64_epilogue_frame_unwind_stop_reason.
	* i386-tdep.c: Include "exceptions.h".
	(struct i386_frame_cache): New field "base_p".
	(i386_init_frame_cache): Clear it.
	(i386_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(i386_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(i386_frame_unwind_stop_reason): New.
	(i386_frame_this_id): Don't build a frame id if the frame base was
	unavailable.
	(i386_frame_prev_register): Handle unavailable SP.
	(i386_frame_unwind): Install i386_frame_unwind_stop_reason.
	(i386_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_epilogue_frame_unwind_stop_reason): New.
	(i386_epilogue_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_epilogue_frame_unwind): Install
	i386_epilogue_frame_unwind_stop_reason.
	(i386_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_sigtramp_frame_unwind_stop_reason): New.
	(i386_sigtramp_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_sigtramp_frame_unwind): Install
	i386_sigtramp_frame_unwind_stop_reason.
	* sentinel-frame.c (sentinel_frame_prev_register): Use the value
	type's size, not the register's.
	(sentinel_frame_unwind): Install default_frame_unwind_stop_reason.

	* alpha-mdebug-tdep.c (alpha_mdebug_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* alpha-tdep.c (alpha_sigtramp_frame_unwind)
	(alpha_heuristic_frame_unwind): Ditto.
	* amd64obsd-tdep.c (amd64obsd_trapframe_unwind): Ditto.
	* arm-tdep.c (arm_prologue_unwind, arm_stub_unwind): Ditto.
	* avr-tdep.c (avr_frame_unwind): Ditto.
	* cris-tdep.c (cris_sigtramp_frame_unwind, cris_frame_unwind):
	Ditto.
	* frv-linux-tdep.c (frv_linux_sigtramp_frame_unwind): Ditto.
	* frv-tdep.c (frv_frame_unwind): Ditto.
	* h8300-tdep.c (h8300_frame_unwind): Ditto.
	* hppa-hpux-tdep.c (hppa_hpux_sigtramp_frame_unwind): Ditto.
	* hppa-linux-tdep.c (hppa_linux_sigtramp_frame_unwind): Ditto.
	* hppa-tdep.c (hppa_frame_unwind, hppa_fallback_frame_unwind)
	(hppa_stub_frame_unwind): Ditto.
	* i386obsd-tdep.c (i386obsd_trapframe_unwind): Ditto.
	* ia64-tdep.c (ia64_frame_unwind, ia64_sigtramp_frame_unwind)
	(ia64_libunwind_frame_unwind)
	(ia64_libunwind_sigtramp_frame_unwind): Ditto.
	* iq2000-tdep.c (iq2000_frame_unwind): Ditto.
	* lm32-tdep.c (lm32_frame_unwind): Ditto.
	* m32c-tdep.c (m32c_unwind): Ditto.
	* m32r-linux-tdep.c (m32r_linux_sigtramp_frame_unwind): Ditto.
	* m32r-tdep.c (m32r_frame_unwind): Ditto.
	* m68hc11-tdep.c (m68hc11_frame_unwind): Ditto.
	* m68k-tdep.c (m68k_frame_unwind): Ditto.
	* m68klinux-tdep.c (m68k_linux_sigtramp_frame_unwind): Ditto.
	* m88k-tdep.c (m88k_frame_unwind): Ditto.
	* mep-tdep.c (mep_frame_unwind): Ditto.
	* microblaze-tdep.c (microblaze_frame_unwind): Ditto.
	* mips-tdep.c (mips_insn16_frame_unwind, mips_insn32_frame_unwind)
	(mips_stub_frame_unwind): Ditto.
	* mn10300-tdep.c (mn10300_frame_unwind): Ditto.
	* moxie-tdep.c (moxie_frame_unwind): Ditto.
	* mt-tdep.c (mt_frame_unwind): Ditto.
	* ppc-linux-tdep.c (ppu2spu_unwind): Ditto.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_unwind): Ditto.
	* rs6000-tdep.c (rs6000_frame_unwind): Ditto.
	* s390-tdep.c (s390_frame_unwind, s390_stub_frame_unwind)
	(s390_sigtramp_frame_unwind): Ditto.
	* score-tdep.c (score_prologue_unwind): Ditto.
	* sh-tdep.c (sh_frame_unwind): Ditto.
	* sh64-tdep.c (sh64_frame_unwind): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_sigtramp_frame_unwind): Ditto.
	* sparc-tdep.c (sparc32_frame_unwind): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_sigtramp_frame_unwind): Ditto.
	* sparc64-tdep.c (sparc64_frame_unwind): Ditto.
	* sparc64fbsd-tdep.c (sparc64fbsd_sigtramp_frame_unwind): Ditto.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_frame_unwind): Ditto.
	* sparc64obsd-tdep.c (sparc64obsd_frame_unwind)
	(sparc64obsd_trapframe_unwind): Ditto.
	* sparcnbsd-tdep.c (sparc32nbsd_sigcontext_frame_unwind): Ditto.
	* sparcobsd-tdep.c (sparc32obsd_sigtramp_frame_unwind): Ditto.
	* spu-tdep.c (spu_frame_unwind, spu2ppu_unwind): Ditto.
	* v850-tdep.c (v850_frame_unwind): Ditto.
	* vax-tdep.c (vax_frame_unwind): Ditto.
	* vaxobsd-tdep.c (vaxobsd_sigtramp_frame_unwind): Ditto.
	* xstormy16-tdep.c (frame_unwind xstormy16_frame_unwind): Ditto.
	* xtensa-tdep.c (xtensa_unwind): Ditto.
@
text
@d1859 9
a1867 17
      else if ((insn & 0xfe500000) == 0xe8100000)	/* ldm */
	{
	  /* Ignore block loads from the stack, potentially copying
	     parameters from memory.  */
	  if (pv_is_register (regs[bits (insn, 16, 19)], ARM_SP_REGNUM))
	    continue;
	  else
	    break;
	}
      else if ((insn & 0xfc500000) == 0xe4100000)
	{
	  /* Similarly ignore single loads from the stack.  */
	  if (pv_is_register (regs[bits (insn, 16, 19)], ARM_SP_REGNUM))
	    continue;
	  else
	    break;
	}
@


1.336
log
@	gdb/
	* regcache.h (regcache_raw_read, regcache_raw_read_signed)
	(regcache_raw_read_unsigned, regcache_raw_read_signed)
	(regcache_raw_read_unsigned, regcache_raw_read_part)
	(regcache_cooked_read, regcache_cooked_read_signed)
	(regcache_cooked_read_unsigned, regcache_cooked_read_part)
	(regcache_cooked_read_ftype): Change return to enum
	register_status.
	* regcache.c: Include exceptions.h
	(regcache_save): Adjust to handle REG_UNAVAILABLE registers.
	(do_cooked_read): Change return to enum register_status.  Always
	forward to regcache_cooked_read.
	(regcache_raw_read): Change return to enum register_status.  If
	the register is not REG_VALID, memset the buffer.  Return the
	register's status.
	(regcache_raw_read_signed): Handle non-REG_VALID registers and
	return the register's status.
	(regcache_raw_read_unsigned): Ditto.
	(regcache_cooked_read): Change return to enum register_status.
	Assert that with read-only regcaches, the register's status must
	be known.  If the regcache is read-only, and the register is not
	REG_VALID, memset the buffer.  Return the register's status.
	(regcache_cooked_read_signed): Change return to enum
	register_status.  Handle non-REG_VALID registers and return the
	register's status.
	(regcache_cooked_read_unsigned): Change return to enum
	register_status.  Handle non-REG_VALID registers and return the
	register's status.
	(regcache_xfer_part, regcache_raw_read_part)
	(regcache_cooked_read_part): Change return to enum
	register_status.  Return the register's status.
	(regcache_read_pc): Throw NOT_AVAILABLE_ERROR if the register is
	unavailable.
	(regcache_dump): Handle unavailable cooked registers.
	* frame.c (do_frame_register_read): Adjust interface to match
	regcache_cooked_read_ftype.
	* gdbarch.sh (pseudo_register_read): Change return to enum
	register_status.
	* gdbarch.h, gdbarch.c: Regenerate.

	* i386-tdep.h (i386_pseudo_register_read): Change return to enum
	register_status.
	* i386-tdep.c (i386_pseudo_register_read): Change return to enum
	register_status.  If reading a raw register indicates the raw
	register is not valid, return the raw register's status,
	otherwise, return REG_VALID.
	* amd64-tdep.c (amd64_pseudo_register_read): Change return to enum
	register_status.  Handle non-REG_VALID raw registers and return
	the register's status.
	* arm-tdep.c (arm_neon_quad_read)
	(arm_pseudo_read): Change return to enum register_status.  Handle
	non-REG_VALID raw registers and return the register's status.
	* avr-tdep.c (avr_pseudo_register_read): Ditto.
	* frv-tdep.c (frv_pseudo_register_read): Ditto.
	* h8300-tdep.c (h8300_pseudo_register_read): Ditto.
	* hppa-tdep.c (hppa_pseudo_register_read): Ditto.
	* m32c-tdep.c (m32c_move_reg_t): Change return to enum
	register_status.
	(m32c_raw_read, m32c_raw_write, m32c_banked_read)
	(m32c_banked_write, m32c_sb_read, m32c_sb_write, m32c_part_read)
	(m32c_part_write, m32c_cat_read, m32c_cat_write)
	(m32c_r3r2r1r0_read, m32c_r3r2r1r0_write)
	(m32c_pseudo_register_read): Change return to enum
	register_status.  Adjust.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read): Change return to
	enum register_status.  Return the register's status.
	* mep-tdep.c (mep_pseudo_cr32_read): Change return to enum
	register_status.  Return the register's status.
	(mep_pseudo_cr64_read, mep_pseudo_register_read): Ditto.
	* mips-tdep.c (mips_pseudo_register_read): Ditto.
	* mt-tdep.c (mt_pseudo_register_read): Ditto.
	* rs6000-tdep.c (move_ev_register_func): New typedef.
	(e500_move_ev_register): Use it.  Change return to enum
	register_status.  Return the register's status.
	(do_regcache_raw_read): New function.
	(do_regcache_raw_write): New function.
	(e500_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.  Use
	do_regcache_raw_read.
	(e500_pseudo_register_write): Adjust.  Use do_regcache_raw_write.
	(dfp_pseudo_register_read): Change return to enum register_status.
	Return the register's status.
	(vsx_pseudo_register_read): Ditto.
	(efpr_pseudo_register_read): Ditto.
	(rs6000_pseudo_register_read): Ditto.
	* s390-tdep.c (s390_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.
	* sh64-tdep.c (pseudo_register_read_portions): New function.
	(sh64_pseudo_register_read): Change return to enum
	register_status.  Use pseudo_register_read_portions.  Return the
	register's status.
	* ia64-tdep.c (ia64_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.
	* sh-tdep.c (pseudo_register_read_portions): New function.
	(sh_pseudo_register_read): Change return to enum register_status.
	Use pseudo_register_read_portions.  Return the register's status.
	* sparc-tdep.c (sparc32_pseudo_register_read): Change return to
	enum register_status.  Return the register's status.
	* sparc64-tdep.c (sparc64_pseudo_register_read): Ditto.
	* spu-tdep.c (spu_pseudo_register_read_spu)
	(spu_pseudo_register_read): Ditto.
	* xtensa-tdep.c (xtensa_register_read_masked)
	(xtensa_pseudo_register_read): Ditto.
	* bfin-tdep.c (bfin_pseudo_register_read): Ditto.
@
text
@d2149 1
d2888 1
d2944 1
@


1.335
log
@2011-03-11  Yao Qi  <yao@@codesourcery.com>

	* arm-tdep.c (copy_ldr_str_ldrb_strb): Remove redundant statements.
@
text
@d216 3
a218 3
static void arm_neon_quad_read (struct gdbarch *gdbarch,
				struct regcache *regcache,
				int regnum, gdb_byte *buf);
d7902 1
a7902 1
static void
d7909 1
d7921 3
a7923 1
  regcache_raw_read (regcache, double_regnum, reg_buf);
d7927 3
a7929 1
  regcache_raw_read (regcache, double_regnum + 1, reg_buf);
d7931 2
d7935 1
a7935 1
static void
d7949 1
a7949 1
    arm_neon_quad_read (gdbarch, regcache, regnum - 32, buf);
d7952 2
d7967 4
a7970 2
      regcache_raw_read (regcache, double_regnum, reg_buf);
      memcpy (buf, reg_buf + offset, 4);
@


1.334
log
@2011-03-08  Yao Qi  <yao@@codesourcery.com>

	* arm-tdep.c: Remove prototype declaration displaced_in_arm_mode.
	(displaced_read_reg): Add `dsc' parameter, remove `from' parameter.
	Use cached result instead of calling displaced_in_arm_mode again.
	(branch_write_pc, alu_write_pc, load_write_pc): Add `dsc' parameter.
	(displaced_write_reg, copy_preload, copy_preload_reg): Callers update.
	(cleanup_copro_load_store, copy_copro_load_store): Likewise.
	(cleanup_branch, copy_bx_blx_reg, copy_alu_imm): Likewise.
	(cleanup_alu_reg, copy_alu_reg, cleanup_alu_shifted_reg): Likewise.
	(copy_alu_shifted_reg, cleanup_load, cleanup_store): Likewise.
	(copy_extra_ld_st, copy_ldr_str_ldrb_strb): Likewise.
	(cleanup_block_load_all, cleanup_block_store_pc): Likewise.
	(cleanup_block_load_pc, copy_block_xfer): Likewise.
	* arm-linux-tdep.c (arm_linux_copy_svc): Callers update.
	(arm_catch_kernel_helper_return): Likewise.
	* gdb/arm-tdep.h : Update function declarations.
@
text
@a6005 3
      dsc->modinsn[6] = 0x0;  /* breakpoint location.  */
      dsc->modinsn[7] = 0x0;  /* scratch space.  */

@


1.333
log
@2011-03-03  Yao Qi  <yao@@codesourcery.com>

	* gdb/arm-tdep.c (shifted_reg_val): Replace magic number 15 with
	ARM_PC_REGNUM.
	(thumb_get_next_pc_raw, arm_get_next_pc_raw): Likewise.
	(displaced_write_reg, displaced_read_reg): Likewise.
	(copy_ldr_str_ldrb_strb, cleanup_block_load_all): Likewise.
	(cleanup_block_load_pc, copy_block_xfer): Likewise.
	(cleanup_branch): Replace magic number 14 and 15 with
	ARM_LR_REGNUM and ARM_PC_REGNUM respectively.
@
text
@a5113 2
static int displaced_in_arm_mode (struct regcache *regs);

d5119 2
a5120 1
displaced_read_reg (struct regcache *regs, CORE_ADDR from, int regno)
d5123 1
d5133 1
a5133 1
      if (displaced_in_arm_mode (regs))
d5167 2
a5168 1
branch_write_pc (struct regcache *regs, ULONGEST val)
d5170 1
a5170 1
  if (displaced_in_arm_mode (regs))
d5213 2
a5214 1
load_write_pc (struct regcache *regs, ULONGEST val)
d5219 1
a5219 1
    branch_write_pc (regs, val);
d5225 2
a5226 1
alu_write_pc (struct regcache *regs, ULONGEST val)
d5228 1
a5228 1
  if (DISPLACED_STEPPING_ARCH_VERSION >= 7 && displaced_in_arm_mode (regs))
d5231 1
a5231 1
    branch_write_pc (regs, val);
d5250 1
a5250 1
	  branch_write_pc (regs, val);
d5258 1
a5258 1
	  load_write_pc (regs, val);
d5262 1
a5262 1
	  alu_write_pc (regs, val);
a5351 1
  CORE_ADDR from = dsc->insn_addr;
d5366 2
a5367 2
  dsc->tmp[0] = displaced_read_reg (regs, from, 0);
  rn_val = displaced_read_reg (regs, from, rn);
a5388 1
  CORE_ADDR from = dsc->insn_addr;
d5403 4
a5406 4
  dsc->tmp[0] = displaced_read_reg (regs, from, 0);
  dsc->tmp[1] = displaced_read_reg (regs, from, 1);
  rn_val = displaced_read_reg (regs, from, rn);
  rm_val = displaced_read_reg (regs, from, rm);
d5426 1
a5426 1
  ULONGEST rn_val = displaced_read_reg (regs, dsc->insn_addr, 0);
a5440 1
  CORE_ADDR from = dsc->insn_addr;
d5457 2
a5458 2
  dsc->tmp[0] = displaced_read_reg (regs, from, 0);
  rn_val = displaced_read_reg (regs, from, rn);
d5478 1
a5478 2
  ULONGEST from = dsc->insn_addr;
  uint32_t status = displaced_read_reg (regs, from, ARM_PS_REGNUM);
d5488 1
a5488 1
      ULONGEST pc = displaced_read_reg (regs, from, ARM_PC_REGNUM);
a5552 1
  CORE_ADDR from = dsc->insn_addr;
d5567 1
a5567 1
  dsc->u.branch.dest = displaced_read_reg (regs, from, rm);
d5586 1
a5586 1
  ULONGEST rd_val = displaced_read_reg (regs, dsc->insn_addr, 0);
a5600 1
  CORE_ADDR from = dsc->insn_addr;
d5622 4
a5625 4
  dsc->tmp[0] = displaced_read_reg (regs, from, 0);
  dsc->tmp[1] = displaced_read_reg (regs, from, 1);
  rn_val = displaced_read_reg (regs, from, rn);
  rd_val = displaced_read_reg (regs, from, rd);
d5649 1
a5649 1
  rd_val = displaced_read_reg (regs, dsc->insn_addr, 0);
a5666 1
  CORE_ADDR from = dsc->insn_addr;
d5687 6
a5692 6
  dsc->tmp[0] = displaced_read_reg (regs, from, 0);
  dsc->tmp[1] = displaced_read_reg (regs, from, 1);
  dsc->tmp[2] = displaced_read_reg (regs, from, 2);
  rd_val = displaced_read_reg (regs, from, rd);
  rn_val = displaced_read_reg (regs, from, rn);
  rm_val = displaced_read_reg (regs, from, rm);
d5715 1
a5715 1
  ULONGEST rd_val = displaced_read_reg (regs, dsc->insn_addr, 0);
a5735 1
  CORE_ADDR from = dsc->insn_addr;
d5760 1
a5760 1
    dsc->tmp[i] = displaced_read_reg (regs, from, i);
d5762 4
a5765 4
  rd_val = displaced_read_reg (regs, from, rd);
  rn_val = displaced_read_reg (regs, from, rn);
  rm_val = displaced_read_reg (regs, from, rm);
  rs_val = displaced_read_reg (regs, from, rs);
a5788 1
  CORE_ADDR from = dsc->insn_addr;
d5790 1
a5790 1
  rt_val = displaced_read_reg (regs, from, 0);
d5792 2
a5793 2
    rt_val2 = displaced_read_reg (regs, from, 1);
  rn_val = displaced_read_reg (regs, from, 2);
d5817 1
a5817 2
  CORE_ADDR from = dsc->insn_addr;
  ULONGEST rn_val = displaced_read_reg (regs, from, 2);
a5849 1
  CORE_ADDR from = dsc->insn_addr;
d5865 3
a5867 3
  dsc->tmp[0] = displaced_read_reg (regs, from, 0);
  dsc->tmp[1] = displaced_read_reg (regs, from, 1);
  dsc->tmp[2] = displaced_read_reg (regs, from, 2);
d5869 1
a5869 1
    dsc->tmp[3] = displaced_read_reg (regs, from, 3);
d5871 1
a5871 1
  rt_val = displaced_read_reg (regs, from, rt);
d5873 2
a5874 2
    rt_val2 = displaced_read_reg (regs, from, rt + 1);
  rn_val = displaced_read_reg (regs, from, rn);
d5876 1
a5876 1
    rm_val = displaced_read_reg (regs, from, rm);
a5920 1
  CORE_ADDR from = dsc->insn_addr;
d5931 2
a5932 2
  dsc->tmp[0] = displaced_read_reg (regs, from, 0);
  dsc->tmp[2] = displaced_read_reg (regs, from, 2);
d5934 1
a5934 1
    dsc->tmp[3] = displaced_read_reg (regs, from, 3);
d5936 1
a5936 1
    dsc->tmp[4] = displaced_read_reg (regs, from, 4);
d5938 2
a5939 2
  rt_val = displaced_read_reg (regs, from, rt);
  rn_val = displaced_read_reg (regs, from, rn);
d5941 1
a5941 1
    rm_val = displaced_read_reg (regs, from, rm);
a6040 1
  ULONGEST from = dsc->insn_addr;
d6049 1
a6049 1
  uint32_t status = displaced_read_reg (regs, from, ARM_PS_REGNUM);
d6102 1
a6102 2
  ULONGEST from = dsc->insn_addr;
  uint32_t status = displaced_read_reg (regs, from, ARM_PS_REGNUM);
d6153 1
a6153 2
  ULONGEST from = dsc->insn_addr;
  uint32_t status = displaced_read_reg (regs, from, ARM_PS_REGNUM);
d6176 1
a6176 1
	      ULONGEST rval = displaced_read_reg (regs, from, read_reg);
a6237 1
  CORE_ADDR from = dsc->insn_addr;
d6255 1
a6255 1
  dsc->u.block.xfer_addr = displaced_read_reg (regs, from, rn);
d6291 1
a6291 1
	    dsc->tmp[i] = displaced_read_reg (regs, from, i);
d6348 1
a6348 2
  CORE_ADDR from = dsc->insn_addr;
  CORE_ADDR resume_addr = from + 4;
a6360 2
  CORE_ADDR from = dsc->insn_addr;

@


1.332
log
@2011-03-02  Yao Qi  <yao@@codesourcery.com>

	* arm-tdep.h (struct displaced_step_closure): Add two new fields
	is_thumb and insn_size.
	* arm-tdep.c (displaced_read_reg): Adjust correct pipeline offset
	on both ARM and Thumb mode.
	(arm_process_displaced_insn): Set is_thumb and insn_size.
	(arm_displaced_init_closure): Handle both 16-bit and 32-bit.
	(arm_displaced_step_fixup): Likewise.
@
text
@d4147 1
a4147 1
  res = (rm == 15
d4501 1
a4501 1
	  if (rn == 15)
d4668 4
a4671 2
		nextpc = (rn == 15) ? pc_val + 8
				    : get_frame_register_unsigned (frame, rn);
d4678 3
a4680 2
	    operand1 = (rn == 15) ? pc_val + 8
				  : get_frame_register_unsigned (frame, rn);
d4780 4
a4783 2
		  base = (rn == 15) ? pc_val + 8
				    : get_frame_register_unsigned (frame, rn);
d5125 1
a5125 1
  if (regno == 15)
d5239 1
a5239 1
  if (regno == 15)
d5489 2
a5490 2
      ULONGEST pc = displaced_read_reg (regs, from, 15);
      displaced_write_reg (regs, dsc, 14, pc - 4, CANNOT_WRITE_PC);
d5493 1
a5493 1
  displaced_write_reg (regs, dsc, 15, dsc->u.branch.dest, write_pc);
d5984 1
a5984 1
  if (load || rt != 15)
d6085 1
a6085 1
	while (regno <= 15 && (regmask & (1 << regno)) == 0)
d6167 1
a6167 1
  unsigned int mask = dsc->u.block.regmask, write_reg = 15;
d6254 1
a6254 1
  if (rn != 15 && (insn & 0x8000) == 0)
d6257 1
a6257 1
  if (rn == 15)
@


1.331
log
@	* arm-linux-tdep.c (ARM_LDR_PC_SP_4): Add define.
	(arm_linux_restart_syscall_init): Handle both on-stack and in-kernel
	versions of the trampoline.  Handle Thumb vs. ARM addresses.
	(arm_kernel_linux_restart_syscall_tramp_frame): New global.
	(arm_linux_init_abi): Install it.
	* arm-tdep.c (arm_psr_thumb_bit): Make global.
	* arm-tdep.c (arm_psr_thumb_bit): Add prototype.
@
text
@d5109 2
d5122 11
d5135 2
a5136 2
			    (unsigned long) from + 8);
      return (ULONGEST) from + 8;  /* Pipeline offset.  */
d6877 2
d6922 1
a6922 1
  unsigned int i;
d6924 2
d6927 1
d6932 15
a6946 4
	fprintf_unfiltered (gdb_stdlog, "displaced: writing insn %.8lx at "
			    "%.8lx\n", (unsigned long) dsc->modinsn[i],
			    (unsigned long) to + i * 4);
      write_memory_unsigned_integer (to + i * 4, 4, byte_order_for_code,
d6948 13
d6964 1
a6964 2
  write_memory (to + dsc->numinsns * 4, tdep->arm_breakpoint,
		tdep->arm_breakpoint_size);
d7000 3
a7002 1
    regcache_cooked_write_unsigned (regs, ARM_PC_REGNUM, dsc->insn_addr + 4);
@


1.330
log
@2011-02-25  Michael Snyder  <msnyder@@vmware.com>

	* arm-tdep.c: Fix typos in comments.
	* bsd-uthread.c: Ditto.
	* completer.c: Ditto.
	* corelow.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* cris-tdep.c: Ditto.
	* dbxread.c: Ditto.
	* dwarf2read.c: Ditto.
	* frame.h: Ditto.
	* gdbtypes.h: Ditto.
	* inferior.h: Ditto.
	* mdebugread.c: Ditto.
	* mips-tdep.c: Ditto.
	* ppc-linux-nat.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* printcmd.c: Ditto.
	* sol-thread.c: Ditto.
	* solib-frv.c: Ditto.
	* solist.h: Ditto.
	* sparc64-tdep.c: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* symfile.c: Ditto.
	* valops.c: Ditto.
	* varobj.c: Ditto.
	* vax-nat.c: Ditto.
	* python/py-block.c: Ditto.
	* python/py-symbol.c: Ditto.
	* python/py-symtab.c: Ditto.
	* python/py-value.c: Ditto.
	* tui/tui-win.c: Ditto.
@
text
@d265 1
a265 1
static int
@


1.329
log
@ChangeLog:

	* arm-linux-nat.c: Include "observer.h" and "gdbthread.h".
	(PTRACE_GETHBPREGS, PTRACE_SETHBPREGS): Define.
	(struct arm_linux_hwbp_cap): New type.
	(arm_linux_get_hwbp_cap): New function.
	(arm_linux_get_hw_breakpoint_count): Likewise.
	(arm_linux_get_hw_watchpoint_count): Likewise.
	(arm_linux_can_use_hw_breakpoint): Likewise.
	(arm_hwbp_type): New type.
	(arm_hwbp_control_t): Likewise.
	(struct arm_linux_hw_breakpoint): Likewise.
	(struct arm_linux_thread_points): Likewise.
	(arm_threads): New global variable.
	(arm_linux_find_breakpoints_by_tid): New function.
	(arm_hwbp_control_initialize): Likewise.
	(arm_hwbp_control_is_enabled): Likewise.
	(arm_hwbp_control_disable): Likewise.
	(arm_linux_hw_breakpoint_initialize): Likewise.
	(arm_linux_get_hwbp_type): Likewise.
	(arm_linux_hw_watchpoint_initialize): Likewise.
	(arm_linux_hw_breakpoint_equal): Likewise.
	(arm_linux_insert_hw_breakpoint1): Likewise.
	(arm_linux_remove_hw_breakpoint1): Likewise.
	(arm_linux_insert_hw_breakpoint): Likewise.
	(arm_linux_remove_hw_breakpoint): Likewise.
	(arm_linux_region_ok_for_hw_watchpoint): Likewise.
	(arm_linux_insert_watchpoint): Likewise.
	(arm_linux_remove_watchpoint): Likewise.
	(arm_linux_stopped_data_address): Likewise.
	(arm_linux_stopped_by_watchpoint): Likewise.
	(arm_linux_watchpoint_addr_within_range): Likewise.
	(arm_linux_new_thread): Likewise.
	(arm_linux_thread_exit): Likewise.
	(_initialize_arm_linux_nat): Install hardware breakpoint/watchpoint
	related target callbacks.  Register arm_linux_new_thread and
	arm_linux_thread_exit.
	* arm-tdep.h (arm_pc_is_thumb): Add prototype.
	* arm-tdep.c (arm_pc_is_thumb): Make global.
	(arm_gdbarch_init): Call set_gdbarch_have_nonsteppable_watchpoint.

testsuite/ChangeLog:

	* lib/gdb.exp (skip_hw_breakpoint_tests): Add arm*-*-* target.
	(skip_hw_watchpoint_tests): Likewise.
	(skip_hw_watchpoint_multi_tests): Likewise.
@
text
@d7158 3
a7160 2
      /* If the the type is a plain integer, then the access is
	 straight-forward.  Otherwise we have to play around a bit more.  */
@


1.328
log
@2011-02-18  Yao Qi  <yao@@codesourcery.com>

	* gdb/arm-tdep.c (arm_displaced_step_copy_insn): Move code to ...
	(arm_process_displaced_insn): .. here. Remove parameter INSN.
	(thumb_process_displaced_insn): New.
	* gdb/arm-linux-tdep.c (arm_linux_displaced_step_copy_insn): Update
	call to arm_process_displaced_insn.
	* gdb/arm-tdep.h : Update declaration of arm_process_displaced_insn.
@
text
@d366 1
a366 1
static int
d8556 3
@


1.327
log
@2011-02-16  Yao Qi  <yao@@qiyaows>

	* infrun.c (get_displaced_step_closure_by_addr): New.
	* inferior.h: Declare it.
	* arm-tdep.c: (arm_pc_is_thumb): Call
	get_displaced_step_closure_by_addr.  Adjust MEMADDR if it
	returns non-NULL.
@
text
@d6836 8
d6845 2
a6846 3
arm_process_displaced_insn (struct gdbarch *gdbarch, uint32_t insn,
			    CORE_ADDR from, CORE_ADDR to,
			    struct regcache *regs,
d6850 2
a6851 3

  if (!displaced_in_arm_mode (regs))
    error (_("Displaced stepping is only supported in ARM mode"));
d6861 9
d6940 1
a6940 9
  enum bfd_endian byte_order_for_code = gdbarch_byte_order_for_code (gdbarch);
  uint32_t insn = read_memory_unsigned_integer (from, 4, byte_order_for_code);

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: stepping insn %.8lx "
			"at %.8lx\n", (unsigned long) insn,
			(unsigned long) from);

  arm_process_displaced_insn (gdbarch, insn, from, to, regs, dsc);
@


1.326
log
@2011-02-15  Yao Qi  <yao@@codesourcery.com>

	PR tdep/12352
	* arm-tdep.c (copy_ldr_str_ldrb_strb): Replace PC with SP in
	order to store PC value on stack instead of text section.

2011-02-15  Yao Qi  <yao@@codesourcery.com>

	PR tdep/12352
	* gdb.arch/arm-disp-step.S : New test for str instruction.
	* gdb.arch/arm-disp-step.exp : Likewise
@
text
@d372 14
@


1.325
log
@	* arm-tdep.c (arm_skip_stack_protector): Accept any symbol that
	starts with __stack_chk_guard as stack guard symbol.
@
text
@d5933 13
a5945 7
     scratch+0:  str pc, temp  (*temp = scratch + 8 + offset)
     scratch+4:  ldr r4, temp
     scratch+8:  sub r4, r4, pc  (r4 = scratch + 8 + offset - scratch - 8 - 8)
     scratch+12: add r4, r4, #8  (r4 = offset)
     scratch+16: add r0, r0, r4
     scratch+20: str r0, [r2, #imm] (or str r0, [r2, r3])
     scratch+24: <temp>
d5948 3
a5950 1
     architecture-dependent (sometimes PC+8, sometimes PC+12).  */
d5971 2
a5972 3

      dsc->modinsn[0] = 0xe58ff014;  /* str pc, [pc, #20].  */
      dsc->modinsn[1] = 0xe59f4010;  /* ldr r4, [pc, #16].  */
@


1.324
log
@	* arm-tdep.c (skip_prologue_function): Add GDBARCH and IS_THUMB
	arguments.  Skip in-prologue calls to glibc __aeabi_read_tp
	implementation even if no symbols are available.
	(thumb_analyze_prologue): Update call to skip_prologue_function.
	(arm_analyze_prologue): Likewise.
@
text
@d1299 2
a1300 1
      && strcmp (SYMBOL_LINKAGE_NAME(stack_chk_guard), "__stack_chk_guard"))
@


1.323
log
@	* arm-tdep.c: Include "observer.h".
	(arm_prologue_this_id): Use frame PC if get_frame_func returns 0.
	(arm_exidx_data_key): New static variable.
	(struct arm_exidx_entry, arm_exidx_entry_s): New data types.
	(struct arm_exidx_data): Likewise.
	(arm_exidx_data_free): New function.
	(arm_compare_exidx_entries): Likewise.
	(arm_obj_section_from_vma): Likewise.
	(arm_exidx_new_objfile): Likewise.
	(arm_find_exidx_entry): Likewise.
	(arm_exidx_fill_cache): Likewise.
	(arm_exidx_unwind_sniffer): Likewise.
	(arm_exidx_unwind): New global variable.
	(arm_gdbarch_init): Append unwinder arm_exidx_unwind.
	(_initialize_arm_tdep): Attach arm_exidx_new_objfile to new_objfile
	observer.  Register arm_exidx_data_key as objfile data.
@
text
@d454 3
a456 1
   can be safely ignored during prologue skipping.  */
d458 1
a458 1
skip_prologue_function (CORE_ADDR pc)
d460 1
a461 1
  const char *name;
d464 18
a481 2
  if (msym == NULL || SYMBOL_VALUE_ADDRESS (msym) != pc)
    return 0;
d483 20
a502 22
  name = SYMBOL_LINKAGE_NAME (msym);
  if (name == NULL)
    return 0;

  /* The GNU linker's Thumb call stub to foo is named
     __foo_from_thumb.  */
  if (strstr (name, "_from_thumb") != NULL)
    name += 2;

  /* On soft-float targets, __truncdfsf2 is called to convert promoted
     arguments to their argument types in non-prototyped
     functions.  */
  if (strncmp (name, "__truncdfsf2", strlen ("__truncdfsf2")) == 0)
    return 1;
  if (strncmp (name, "__aeabi_d2f", strlen ("__aeabi_d2f")) == 0)
    return 1;

  /* Internal functions related to thread-local storage.  */
  if (strncmp (name, "__tls_get_addr", strlen ("__tls_get_addr")) == 0)
    return 1;
  if (strncmp (name, "__aeabi_read_tp", strlen ("__aeabi_read_tp")) == 0)
    return 1;
d861 2
a862 1
	      if (!skip_prologue_function (nextpc))
d1834 1
a1834 1
	  if (skip_prologue_function (dest))
@


1.322
log
@	* arm-tdep.c (arm_analyze_load_stack_chk_guard): Avoid build break
	due to accessing uninitialized variable.  Fix indentation.
@
text
@d46 1
d2046 3
d2050 3
d2123 738
d8499 1
d8602 5
@


1.321
log
@2011-01-14  Yao Qi  <yao@@codesourcery.com>

	* arm-tdep.c (arm_register_reggroup_p): FPS register is in
	save_reggroup, restore_reggroup and all_reggroup.
@
text
@d1201 2
a1202 2
       unsigned int insn
	 = read_memory_unsigned_integer (pc, 4, byte_order_for_code);
d1204 9
a1212 9
       if ((insn & 0x0e5f0000) == 0x041f0000) /* ldr Rd, #immed */
	 {
	   address = bits (insn, 0, 11);
	   *destreg = bits (insn, 12, 15);
	   *offset = 4;
	 }
       else if ((insn & 0x0ff00000) == 0x03000000) /* movw Rd, #const */
	 {
	   low = EXTRACT_MOVW_MOVT_IMM_A (insn);
d1214 2
a1215 2
	   insn
	     = read_memory_unsigned_integer (pc + 4, 4, byte_order_for_code);
d1217 8
a1224 7
	   if ((insn & 0x0ff00000) == 0x03400000)       /* movt Rd, #const */
	     high = EXTRACT_MOVW_MOVT_IMM_A (insn);

	   address = (high << 16 | low);
	   *destreg = bits (insn, 12, 15);
	   *offset = 8;
	 }
@


1.320
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* arm-tdep.c: Internationalization.
	* c-lang.c: Ditto.
	* charset.c: Ditto.
	* fork-child.c: Ditto.
	* nto-procfs.c: Ditto.
	* ppc-sysv-tdep.c: Ditto.
	* procfs.c: Ditto.
	* remote-mips.c: Ditto.
	* remote.c: Ditto.
	* rs6000-nat.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* target.c: Ditto.
	* valops.c: Ditto.
	* value.c: Ditto.
	* xml-support.c: Ditto.
	* mi/mi-cmd-break.c: Ditto.
	* mi/mi-cmd-var.c: Ditto.
	* mi/mi-interp.c: Ditto.
	* mi/mi-main.c: Ditto.
@
text
@d7237 3
a7239 1
  /* FPS register's type is INT, but belongs to float_group.  */
d7241 4
a7244 1
    return (group == float_reggroup);
@


1.319
log
@2011-01-07  Michael Snyder  <msnyder@@vmware.com>

	* ada-lang.c: Comment cleanup, mostly periods and spaces.
	* ada-lang.h: Ditto.
	* ada-tasks.c: Ditto.
	* ada-valprint.c: Ditto.
	* aix-threads.c: Ditto.
	* alpha-linux-nat.c: Ditto.
	* alpha-linux-tdep.c: Ditto.
	* alpha-mdebug-tdep.c: Ditto.
	* alpha-nat.c: Ditto.
	* alpha-osf1-tdep.c: Ditto.
	* alpha-tdep.c: Ditto.
	* alphabsd-nat.c: Ditto.
	* alphabsd-tdep.c: Ditto.
	* amd64-darwin-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* amd64-sol2-tdep.c: Ditto.
	* amd64-tdep.c: Ditto.
	* amd64-fbsd-tdep.c: Ditto.
	* amd64-nbsd-tdep.c: Ditto.
	* amd64-obsd-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* arm-tdep.c: Ditto.
	* arm-tdep.h: Ditto.
	* armnbsd-nat.c: Ditto.
	* avr-tdep.c: Ditto.
	* bfin-tdep.c: Ditto.
	* bsd-kvm.c: Ditto.
	* c-typeprintc: Ditto.
	* c-valprint.c: Ditto.
	* coff-pe-read.h: Ditto.
	* coffreead.c: Ditto.
	* cris-tdep.c: Ditto.
	* d-lang.c: Ditto.
	* darwin-nat-info.c: Ditto.
	* darwin-nat.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* dcache.c: Ditto.
	* dcache.h: Ditto.
	* dec-thread.c: Ditto.
	* defs.h: Ditto.
	* demangle.c: Ditto.
	* dicos-tdep.c: Ditto.
	* dictionary.c: Ditto.
	* dictionary.h: Ditto.
	* dink32-rom.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dsrec.c: Ditto.
	* dummy-frame.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* environ.c: Ditto.
	* eval.c: Ditto.
	* event-top.h: Ditto.
	* exceptions.c: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-exp.y: Ditto.
	* f-lang.c: Ditto.
	* f-lang.h: Ditto.
	* f-typeprint.c: Ditto.
	* f-valprint.c: Ditto.
	* fbsd-nat.c: Ditto.
	* findvar.c: Ditto.
	* fork-child.c: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* frv-linux-tdep.c: Ditto.
	* frv-tdep.c: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_string.h: Ditto.
	* gdb_thread_db.h: Ditto.
	* gdb_wait.h: Ditto.
	* gdbarch.sh: Ditto.
	* gdbcore.h: Ditto.
	* gdbthread.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* gnu-nat.c: Ditto.
	* gnu-nat.h: Ditto.
	* gnu-v2-abi.c: Ditto.
	* gnu-v3-abi.c: Ditto.
	* go32-nat.c: Ditto.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
@
text
@d1623 1
a1623 1
	internal_error (__FILE__, __LINE__, "bad value in switch");
d6543 3
a6545 3
	  internal_error
	    (__FILE__, __LINE__,
	     _("arm_store_return_value: Floating point model not supported"));
d6791 1
a6791 1
    internal_error (__FILE__, __LINE__, "could not update architecture");
@


1.318
log
@run copyright.sh for 2011.
@
text
@d22 1
a22 1
#include <ctype.h>		/* XXX for isupper () */
d30 1
a30 1
#include "dis-asm.h"		/* For register styles. */
d68 1
a68 1
#define MSYMBOL_SET_SPECIAL(msym)					\
d848 2
a849 1
	  else if ((insn & 0xffd0) == 0xe900    /* stmdb Rn{!}, { registers } */
d870 2
a871 1
	  else if ((insn & 0xff50) == 0xe940	/* strd Rt, Rt2, [Rn, #+/-imm]{!} */
d943 2
a944 1
	  else if ((insn & 0xffd0) == 0xe890	/* ldmia Rn[!], { registers } */
d951 2
a952 1
	  else if ((insn & 0xffb0) == 0xe950	/* ldrd Rt, Rt2, [Rn, #+/-imm] */
d1230 2
a1231 2
   points to the first instruction of this sequence, return the address of first
   instruction after this sequence, otherwise, return original PC.
d1345 1
a1345 1
   sub fp, ip, #nn @@@@ nn == 20 or 4 depending on second insn */
d1415 1
a1415 1
  /* Like arm_scan_prologue, stop no later than pc + 64. */
d1482 1
a1482 1
  return skip_pc;		/* End of prologue */
d1501 1
a1501 1
   12 bytes.  The frame register is R7. 
d1699 2
a1700 1
      else if ((insn & 0xffff0fff) == 0xe52d0004)	/* str Rd, [sp, #-4]! */
d1723 2
a1724 1
		regs[ARM_SP_REGNUM] = pv_add_constant (regs[ARM_SP_REGNUM], -4);
d1742 2
a1743 1
      else if ((insn & 0xfff00000) == 0xe8800000	/* stm Rn, { registers } */
d1763 2
a1764 1
      else if ((insn & 0xffff7fff) == 0xed6d0103	/* stfe f?, [sp, -#c]! */
d1774 2
a1775 1
      else if ((insn & 0xffbf0fff) == 0xec2d0200	/* sfmfd f0, 4, [sp!] */
d1821 1
a1821 1
	break;			/* Condition not true, exit early */
d2198 2
a2199 1
  return frame_id_build (get_frame_register_unsigned (this_frame, ARM_SP_REGNUM),
d2368 1
a2368 1
     too much about false positives.*/
d3409 1
a3409 1
    val &= val - 1;		/* delete rightmost 1-bit in val */
d3454 1
a3454 1
  CORE_ADDR nextpc = pc + 2;		/* default is next instruction */
d3494 2
a3495 1
	      inst1 = read_memory_unsigned_integer (pc, 2, byte_order_for_code);
d3513 2
a3514 1
		  inst1 = read_memory_unsigned_integer (pc, 2, byte_order_for_code);
d3555 2
a3556 1
		  inst1 = read_memory_unsigned_integer (pc, 2, byte_order_for_code);
d3823 2
a3824 2
   address.
*/
d3895 1
a3895 1
	    /* Multiply into PC */
d3908 3
a3910 2
	    else		/* operand 2 is a shifted register */
	      operand2 = shifted_reg_val (frame, this_instr, c, pc_val, status);
d4252 2
a4253 1
	  buf = extend_buffer_earlier (buf, bpaddr, buf_len, bpaddr - boundary);
d4314 1
a4314 1
      performs such modification, as necessary. A breakpoint is placed after
d4376 2
a4377 1
    regcache_cooked_write_unsigned (regs, ARM_PC_REGNUM, val & ~(ULONGEST) 0x3);
d4379 2
a4380 1
    regcache_cooked_write_unsigned (regs, ARM_PC_REGNUM, val & ~(ULONGEST) 0x1);
d4489 3
a4491 3
   corresponding fields of BITMASK set to 0b1111.  The function returns return 1
   if any of these fields in INSN reference the PC (also 0b1111, r15), else it
   returns 0.  */
d4584 2
a4585 1
copy_preload_reg (struct gdbarch *gdbarch, uint32_t insn, struct regcache *regs,
d4762 2
a4763 1
			"%.8lx\n", (link) ? "blx" : "bx", (unsigned long) insn);
d4786 1
a4786 1
/* Copy/cleanup arithmetic/logic instruction with immediate RHS. */
d4934 2
a4935 1
		      struct regcache *regs, struct displaced_step_closure *dsc)
d5449 2
a5450 1
  /* Block transfers which don't mention PC can be run directly out-of-line.  */
d5456 2
a5457 1
      warning (_("displaced: Unpredictable LDM or STM with base register r15"));
d5603 2
a5604 1
    fprintf_unfiltered (gdb_stdlog, "displaced: copying undefined insn %.8lx\n",
d5691 2
a5692 1
		      struct regcache *regs, struct displaced_step_closure *dsc)
d5776 2
a5777 1
		      struct regcache *regs, struct displaced_step_closure *dsc)
d5805 2
a5806 1
	return copy_bx_blx_reg (gdbarch, insn, regs, dsc);  /* blx register.  */
d5976 2
a5977 1
		      struct regcache *regs, struct displaced_step_closure *dsc)
d6053 2
a6054 1
			    CORE_ADDR from, CORE_ADDR to, struct regcache *regs,
d6236 1
a6236 1
   Even this may only true if the condition predicate is true. The
d6353 3
a6355 3
	  internal_error
	    (__FILE__, __LINE__,
	     _("arm_extract_return_value: Floating point model not supported"));
d6480 2
a6481 1
	  field_type_code = TYPE_CODE (check_typedef (TYPE_FIELD_TYPE (type, i)));
d6873 3
a6875 2
  fprintf_filtered (file, _("\
The current execution mode assumed (when symbols are unavailable) is \"%s\".\n"),
d6885 3
a6887 2
  fprintf_filtered (file, _("\
The current execution mode assumed (even when symbols are available) is \"%s\".\n"),
d7367 2
a7368 1
	      attr_profile = bfd_elf_get_obj_attr_int (info.abfd, OBJ_ATTR_PROC,
d7910 2
a7911 1
		       NULL, /* FIXME: i18n: The disassembly style is \"%s\".  */
d7919 2
a7920 1
			   NULL, /* FIXME: i18n: Usage of ARM 32-bit mode is %s.  */
@


1.317
log
@2010-12-28  Yao Qi  <yao@@codesourcery.com>

	* arm-tdep.c (arm_register_aliases): Remove sp, pc, and fp.
@
text
@d4 1
a4 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
@


1.316
log
@2010-12-23  Yao Qi  <yao@@codesourcery.com>

	* arm-tdep.c (thumb_analyze_prologue): Move some code ...
	(EXTRACT_MOVW_MOVT_IMM_T): ... here.  New macro.
	(EXTRACT_MOVW_MOVT_IMM_A): New macro.
	(arm_analyze_load_stack_chk_guard): New.
	(arm_skip_stack_protector): New.
	(arm_skip_prologue): Adjust post_prologue_pc by
	arm_skip_stack_protector.
@
text
@d138 4
a141 1
/* The standard register names, and all the valid aliases for them.  */
a181 1
  { "sp", 13 },
a182 1
  { "pc", 15 },
a184 1
  { "fp", 11 },
@


1.315
log
@2010-12-23  Yao Qi  <yao@@codesourcery.com>

	* arm-tdep.c (arm_gdbarch_init): Remove invoke to
	set_gdbarch_deprecated_fp_regnum.
@
text
@d499 15
d1022 2
a1023 4
	      unsigned int imm = ((bits (insn, 0, 3) << 12)
				  | (bits (insn, 10, 10) << 11)
				  | (bits (inst2, 12, 14) << 8)
				  | bits (inst2, 0, 7));
d1146 182
d1361 5
@


1.314
log
@2010-12-20  Yao Qi  <yao@@codesourcery.com>

	* arm-tdep.c (arm_register_reggroup_p): New.
	(arm_gdbarch_init): Set arm_register_reggroup_p for hook
	register_reggroup_p.
@
text
@a7471 1
  set_gdbarch_deprecated_fp_regnum (gdbarch, ARM_FP_REGNUM);	/* ??? */
@


1.313
log
@	* arm-tdep.c (arm_in_function_epilogue_p): Fix code when "MOV SP"
	instruction is found.
@
text
@d32 1
d7002 11
d7477 1
@


1.312
log
@	* arm-tdep.c (arm_in_function_epilogue_p): Fix code to avoid
	possible used of uninitialized variable.
@
text
@d2248 1
a2248 1
	found_return = 1;
@


1.311
log
@	* arm-tdep.c (thumb_get_next_pc_raw): Handle Thumb-16 encoding
	for "mov pc, REG" as well.
	(thumb_instruction_changes_pc): Likewise.
@
text
@d2236 1
@


1.310
log
@	* gdb/arm-tdep.c (arm_mode_strings): Add NULL entry at end of array.
@
text
@d540 3
d3578 9
@


1.309
log
@	* arm-tdep.c (thumb_expand_immediate): New function.
	(thumb_instruction_changes_pc): Likewise.
	(thumb2_instruction_changes_pc): Likewise.
	(thumb_analyze_prologue): Handle 32-bit Thumb instructions during
	prologue parsing.  Improved support for optimized code.
	(thumb_scan_prologue): Do not reply on line-number information,
	use same heuristics as arm_scan_prologue insead.
	(skip_prologue_function): Accept functions
	"__tls_get_addr" and "__aeabi_read_tp".
@
text
@d127 2
a128 1
    "thumb"
@


1.308
log
@2010-10-08  Ulrich Weigand  <uweigand@@de.ibm.com>
            Daniel Jacobowitz  <dan@@codesourcery.com>

	* arm-tdep.c (thumb_in_function_epilogue_p)
	(arm_in_function_epilogue_p): New.
	(arm_gdbarch_init): Install arm_in_function_epilogue_p as
	gdbarch_in_function_epilogue_p callback.
@
text
@d479 6
d497 143
d658 1
d796 1
a796 1
      else if ((insn & 0xe000) == 0xe000 && cache == NULL)
a797 1
	  /* Only recognize 32-bit instructions for prologue skipping.  */
d827 23
a849 1
	  else if ((insn & 0xfe50) == 0xe800	/* stm{db,ia} Rn[!], { registers } */
d851 62
d914 3
a916 1
	  else if ((insn & 0xfe50) == 0xe840	/* strd Rt, Rt2, [Rn, #imm] */
d918 1
d920 1
d922 4
a925 2
	      && (inst2 & 0x8000) == 0x0000
	      && pv_is_register (regs[bits (insn, 0, 3)], ARM_SP_REGNUM))
d927 2
a928 16
	  else if ((insn & 0xfbf0) == 0xf100	/* add.w Rd, Rn, #imm */
		   && (inst2 & 0x8000) == 0x0000)
	    /* Since we only recognize this for prologue skipping, do not bother
	       to compute the constant.  */
	    regs[bits (inst2, 8, 11)] = regs[bits (insn, 0, 3)];
	  else if ((insn & 0xfbf0) == 0xf1a0	/* sub.w Rd, Rn, #imm12 */
		   && (inst2 & 0x8000) == 0x0000)
	    /* Since we only recognize this for prologue skipping, do not bother
	       to compute the constant.  */
	    regs[bits (inst2, 8, 11)] = regs[bits (insn, 0, 3)];
	  else if ((insn & 0xfbf0) == 0xf2a0	/* sub.w Rd, Rn, #imm8 */
		   && (inst2 & 0x8000) == 0x0000)
	    /* Since we only recognize this for prologue skipping, do not bother
	       to compute the constant.  */
	    regs[bits (inst2, 8, 11)] = regs[bits (insn, 0, 3)];
	  else if ((insn & 0xff50) == 0xf850	/* ldr.w Rd, [Rn, #imm]{!} */
d930 1
d932 3
a934 1
	  else if ((insn & 0xff50) == 0xe950	/* ldrd Rt, Rt2, [Rn, #imm]{!} */
d936 1
d938 2
a939 1
	  else if ((insn & 0xff50) == 0xf800	/* strb.w or strh.w */
d941 1
d943 115
d1060 3
a1062 5
	      /* We don't know what this instruction is.  We're finished
		 scanning.  NOTE: Recognizing more safe-to-ignore
		 instructions here will improve support for optimized
		 code.  */
	      break;
d1067 5
d1074 3
a1076 5
	  /* We don't know what this instruction is.  We're finished
	     scanning.  NOTE: Recognizing more safe-to-ignore
	     instructions here will improve support for optimized
	     code.  */
	  break;
d1086 3
d1092 1
a1092 1
      return start;
d1125 1
a1125 1
  return start;
d1309 6
a1314 6
      struct symtab_and_line sal = find_pc_line (prologue_start, 0);

      if (sal.line == 0)		/* no line info, use current PC  */
	prologue_end = prev_pc;
      else if (sal.end < prologue_end)	/* next line begins after fn end */
	prologue_end = sal.end;		/* (probably means no prologue)  */
@


1.307
log
@2010-08-30  Yao Qi  <yao@@codesourcery.com>

	* arm-linux-tdep.c (arm_linux_sigreturn_return_addr): New.
	(arm_linux_syscall_next_pc): New.
	(arm_linux_copy_svc): Use arm_linux_sigreturn_return_addr instead.
	(arm_linux_init_abi): Initialize syscall_next_pc.
	* arm-tdep.c (thumb_get_next_pc_raw):  Get next pc of SWI in Thumb mode.
	(arm_get_next_pc_raw): Get next pc of SWI in ARM mode.
	* arm-tdep.h (struct gdbarch_tdep): Add a function pointer syscall_next_pc.
	Declare arm_frame_is_thumb.
@
text
@d1709 197
d7081 3
@


1.306
log
@	* arm-tdep.c: Include features/arm-with-m.c.
	(arm_psr_thumb_bit): New.  Update all uses of CPSR_T to
	call this function.
	(arm_pc_is_thumb): Add a gdbarch argument.  Update all callers.
	Check is_m after force-mode.
	(arm_gdbarch_init): Check the binary before the target description.
	Add check for M profile attribute.  If we have an M-profile device,
	but no target register description, use arm-with-m.  Recognize the
	new org.gnu.gdb.arm.m-profile feature and its xpsr register.
	(_initialize_arm_tdep): Call initialize_tdesc_arm_with_m.
	* arm-tdep.h (XPSR_T): Define.
	(struct gdbarch_tdep): Add is_m member.
	* features/arm-m-profile.xml, features/arm-with-m.c,
	features/arm-with-m.xml: New files.

	doc/
	* gdb.texinfo (ARM Features): Document
	org.gnu.gdb.arm.m-profile.
@
text
@d273 1
a273 1
static int
d2831 10
a2840 1
      if (cond != 0x0f && condition_true (cond, status))    /* 0x0f = SWI */
d3289 1
d3291 8
@


1.305
log
@	* arm-tdep.c (arm_push_dummy_call): Handle pointers to
	typedef'ed function types correctly.
@
text
@d56 2
d260 11
d277 1
d285 1
a285 1
  return (cpsr & CPSR_T) != 0;
d364 1
a364 1
arm_pc_is_thumb (CORE_ADDR memaddr)
d380 4
d836 1
a836 1
	  if (arm_pc_is_thumb (func_addr))
d863 1
a863 1
  if (arm_pc_is_thumb (pc))
d1528 1
d1533 1
a1533 1
	cpsr |= CPSR_T;
d1535 1
a1535 1
	cpsr &= ~CPSR_T;
d1662 1
d1680 1
a1680 1
	cpsr |= CPSR_T;
d1682 1
a1682 1
	cpsr &= ~CPSR_T;
d2031 1
a2031 1
  if (arm_pc_is_thumb (bp_addr))
d2170 1
a2170 1
	  if (arm_pc_is_thumb (regval))
d3375 1
a3375 1
  if (!arm_pc_is_thumb (bpaddr))
d3566 1
d3570 1
a3570 1
  return (ps & CPSR_T) == 0;
d3592 1
d3598 1
a3598 1
      regcache_cooked_write_unsigned (regs, ARM_PS_REGNUM, ps | CPSR_T);
d3603 1
a3603 2
      regcache_cooked_write_unsigned (regs, ARM_PS_REGNUM,
				      ps & ~(ULONGEST) CPSR_T);
d3611 1
a3611 2
      regcache_cooked_write_unsigned (regs, ARM_PS_REGNUM,
				      ps & ~(ULONGEST) CPSR_T);
d5368 3
a5370 1
  if (arm_pc_is_thumb (memaddr))
d5460 1
a5460 1
  if (arm_pc_is_thumb (*pcptr))
d5499 1
a5499 1
  if (arm_pc_is_thumb (*pcptr) && *kindptr == 4)
d6244 1
d6250 1
a6250 1
      ULONGEST val;
d6252 4
a6255 2
      if (arm_pc_is_thumb (pc))
	regcache_cooked_write_unsigned (regcache, ARM_PS_REGNUM, val | CPSR_T);
d6258 1
a6258 1
					val & ~(ULONGEST) CPSR_T);
d6439 1
a6439 1
  int i;
d6443 150
d6595 1
a6595 1
  if (tdesc_has_registers (info.target_desc))
d6606 1
a6606 1
      feature = tdesc_find_feature (info.target_desc,
d6609 8
a6616 1
	return NULL;
d6633 6
a6638 2
      valid_p &= tdesc_numbered_register (feature, tdesc_data,
					  ARM_PS_REGNUM, "cpsr");
d6646 1
a6646 1
      feature = tdesc_find_feature (info.target_desc,
d6663 1
a6663 1
      feature = tdesc_find_feature (info.target_desc,
d6701 1
a6701 1
      feature = tdesc_find_feature (info.target_desc,
d6738 1
a6738 1
	  feature = tdesc_find_feature (info.target_desc,
a6759 128
  /* If we have an object to base this architecture on, try to determine
     its ABI.  */

  if (arm_abi == ARM_ABI_AUTO && info.abfd != NULL)
    {
      int ei_osabi, e_flags;

      switch (bfd_get_flavour (info.abfd))
	{
	case bfd_target_aout_flavour:
	  /* Assume it's an old APCS-style ABI.  */
	  arm_abi = ARM_ABI_APCS;
	  break;

	case bfd_target_coff_flavour:
	  /* Assume it's an old APCS-style ABI.  */
	  /* XXX WinCE?  */
	  arm_abi = ARM_ABI_APCS;
	  break;

	case bfd_target_elf_flavour:
	  ei_osabi = elf_elfheader (info.abfd)->e_ident[EI_OSABI];
	  e_flags = elf_elfheader (info.abfd)->e_flags;

	  if (ei_osabi == ELFOSABI_ARM)
	    {
	      /* GNU tools used to use this value, but do not for EABI
		 objects.  There's nowhere to tag an EABI version
		 anyway, so assume APCS.  */
	      arm_abi = ARM_ABI_APCS;
	    }
	  else if (ei_osabi == ELFOSABI_NONE)
	    {
	      int eabi_ver = EF_ARM_EABI_VERSION (e_flags);

	      switch (eabi_ver)
		{
		case EF_ARM_EABI_UNKNOWN:
		  /* Assume GNU tools.  */
		  arm_abi = ARM_ABI_APCS;
		  break;

		case EF_ARM_EABI_VER4:
		case EF_ARM_EABI_VER5:
		  arm_abi = ARM_ABI_AAPCS;
		  /* EABI binaries default to VFP float ordering.
		     They may also contain build attributes that can
		     be used to identify if the VFP argument-passing
		     ABI is in use.  */
		  if (fp_model == ARM_FLOAT_AUTO)
		    {
#ifdef HAVE_ELF
		      switch (bfd_elf_get_obj_attr_int (info.abfd,
							OBJ_ATTR_PROC,
							Tag_ABI_VFP_args))
			{
			case 0:
			  /* "The user intended FP parameter/result
			     passing to conform to AAPCS, base
			     variant".  */
			  fp_model = ARM_FLOAT_SOFT_VFP;
			  break;
			case 1:
			  /* "The user intended FP parameter/result
			     passing to conform to AAPCS, VFP
			     variant".  */
			  fp_model = ARM_FLOAT_VFP;
			  break;
			case 2:
			  /* "The user intended FP parameter/result
			     passing to conform to tool chain-specific
			     conventions" - we don't know any such
			     conventions, so leave it as "auto".  */
			  break;
			default:
			  /* Attribute value not mentioned in the
			     October 2008 ABI, so leave it as
			     "auto".  */
			  break;
			}
#else
		      fp_model = ARM_FLOAT_SOFT_VFP;
#endif
		    }
		  break;

		default:
		  /* Leave it as "auto".  */
		  warning (_("unknown ARM EABI version 0x%x"), eabi_ver);
		  break;
		}
	    }

	  if (fp_model == ARM_FLOAT_AUTO)
	    {
	      int e_flags = elf_elfheader (info.abfd)->e_flags;

	      switch (e_flags & (EF_ARM_SOFT_FLOAT | EF_ARM_VFP_FLOAT))
		{
		case 0:
		  /* Leave it as "auto".  Strictly speaking this case
		     means FPA, but almost nobody uses that now, and
		     many toolchains fail to set the appropriate bits
		     for the floating-point model they use.  */
		  break;
		case EF_ARM_SOFT_FLOAT:
		  fp_model = ARM_FLOAT_SOFT_FPA;
		  break;
		case EF_ARM_VFP_FLOAT:
		  fp_model = ARM_FLOAT_VFP;
		  break;
		case EF_ARM_SOFT_FLOAT | EF_ARM_VFP_FLOAT:
		  fp_model = ARM_FLOAT_SOFT_VFP;
		  break;
		}
	    }

	  if (e_flags & EF_ARM_BE8)
	    info.byte_order_for_code = BFD_ENDIAN_LITTLE;

	  break;

	default:
	  /* Leave it as "auto".  */
	  break;
	}
    }

d6778 4
d6800 1
d6974 1
a6974 1
      tdesc_use_registers (gdbarch, info.target_desc, tdesc_data);
d7029 3
@


1.304
log
@	* arm-tdep.c (push_stack_item): 'contents' now const.
	(arm_push_dummy_call): Make 'val' const.  Use value_contents, not
	value_contents_writeable.  Introduce new temporary.
@
text
@d2147 1
a2147 1
	  && TYPE_CODE_FUNC == TYPE_CODE (target_type))
@


1.304.2.1
log
@	* arm-tdep.c (arm_push_dummy_call): Handle pointers to
	typedef'ed function types correctly.
@
text
@d2147 1
a2147 1
	  && TYPE_CODE_FUNC == TYPE_CODE (check_typedef (target_type)))
@


1.304.2.2
log
@2010-08-30  Yao Qi  <yao@@codesourcery.com>

	* arm-linux-tdep.c (arm_linux_sigreturn_return_addr): New.
	(arm_linux_syscall_next_pc): New.
	(arm_linux_copy_svc): Use arm_linux_sigreturn_return_addr instead.
	(arm_linux_init_abi): Initialize syscall_next_pc.
	* arm-tdep.c (thumb_get_next_pc_raw):  Get next pc of SWI in Thumb mode.
	(arm_get_next_pc_raw): Get next pc of SWI in ARM mode.
	* arm-tdep.h (struct gdbarch_tdep): Add a function pointer syscall_next_pc.
	Declare arm_frame_is_thumb.
@
text
@d260 1
a260 1
int
d2811 1
a2811 10
      if (cond == 0x0f)  /* 0x0f = SWI */
	{
	  struct gdbarch_tdep *tdep;
	  tdep = gdbarch_tdep (gdbarch);

	  if (tdep->syscall_next_pc != NULL)
	    nextpc = tdep->syscall_next_pc (frame);

	}
      else if (cond != 0x0f && condition_true (cond, status))
a3259 1
	  break;
a3260 8
	  {
	    struct gdbarch_tdep *tdep;
	    tdep = gdbarch_tdep (gdbarch);

	    if (tdep->syscall_next_pc != NULL)
	      nextpc = tdep->syscall_next_pc (frame);

	  }
@


1.303
log
@	ARI fix: Remove ATTRIBUTE_UNUSED throughout.
	* arm-linux-tdep.c (arm_linux_cleanup_svc): Remove
	ATTRIBUTE_UNUSED.
	(cleanup_kernel_helper_return): Likewise.
	* arm-tdep.c (copy_unmodified): Likewise.
	(copy_preload): Likewise.
	(copy_copro_load_store): Likewise.
	(cleanup_branch): Likewise.
	(copy_b_bl_blx): Likewise.
	(copy_bx_blx_reg): Likewise.
	(copy_alu_imm): Likewise.
	(copy_alu_reg): Likewise.
	(copy_alu_shifted_reg): Likewise.
	(cleanup_load): Likewise.
	(cleanup_store): Likewise.
	(cleanup_block_load_pc): Likewise.
	(cleanup_svc): Likewise.
	(copy_undef): Likewise.
	(copy_unpred): Likewise.
	* remote.c (register_remote_support_xml): Likewise.
@
text
@d1700 1
a1700 1
push_stack_item (struct stack_item *prev, void *contents, int len)
d2041 1
a2041 1
      bfd_byte *val;
d2051 1
a2051 1
      val = value_contents_writeable (args[argnum]);
d2152 2
a2153 2
	      val = alloca (len);
	      store_unsigned_integer (val, len, byte_order,
d2155 1
@


1.302
log
@	* arm-tdep.c (thumb_get_next_pc_raw): Correctly detect TBH
	instructions.  Use the PC+4 if the base of the TBB or TBH is the
	PC register.
@
text
@d3705 1
a3705 1
copy_unmodified (struct gdbarch *gdbarch ATTRIBUTE_UNUSED, uint32_t insn,
d3721 1
a3721 1
cleanup_preload (struct gdbarch *gdbarch ATTRIBUTE_UNUSED,
d3806 1
a3806 1
cleanup_copro_load_store (struct gdbarch *gdbarch ATTRIBUTE_UNUSED,
d3860 1
a3860 1
cleanup_branch (struct gdbarch *gdbarch ATTRIBUTE_UNUSED, struct regcache *regs,
d3884 1
a3884 1
copy_b_bl_blx (struct gdbarch *gdbarch ATTRIBUTE_UNUSED, uint32_t insn,
d3931 1
a3931 1
copy_bx_blx_reg (struct gdbarch *gdbarch ATTRIBUTE_UNUSED, uint32_t insn,
d3969 1
a3969 1
cleanup_alu_imm (struct gdbarch *gdbarch ATTRIBUTE_UNUSED,
d4030 1
a4030 1
cleanup_alu_reg (struct gdbarch *gdbarch ATTRIBUTE_UNUSED,
d4099 1
a4099 1
cleanup_alu_shifted_reg (struct gdbarch *gdbarch ATTRIBUTE_UNUSED,
d4173 1
a4173 1
cleanup_load (struct gdbarch *gdbarch ATTRIBUTE_UNUSED, struct regcache *regs,
d4203 1
a4203 1
cleanup_store (struct gdbarch *gdbarch ATTRIBUTE_UNUSED, struct regcache *regs,
d4536 1
a4536 1
cleanup_block_load_pc (struct gdbarch *gdbarch ATTRIBUTE_UNUSED,
d4732 1
a4732 1
cleanup_svc (struct gdbarch *gdbarch ATTRIBUTE_UNUSED, struct regcache *regs,
d4776 1
a4776 1
copy_undef (struct gdbarch *gdbarch ATTRIBUTE_UNUSED, uint32_t insn,
d4791 1
a4791 1
copy_unpred (struct gdbarch *gdbarch ATTRIBUTE_UNUSED, uint32_t insn,
@


1.301
log
@	* arm-tdep.c (skip_prologue_function): New function.
	(submask, bit, bits, sbits, BranchDest): Move higher in the file.
	(thumb_analyze_prologue): Document return value.  Recognize more
	Thumb instructions, skippable calls, and some Thumb-2 instructions.
	Add debug output.
	(arm_skip_prologue): Remove call dummy check.  Check the prologue
	for non-GNU compilers.
	(arm_instruction_changes_pc): New function.
	(arm_analyze_prologue): New function, broken out from
	arm_scan_prologue.  Recognize more ARM instructions and skippable
	calls.  Update comments.  Handle NULL cache.  Return the address
	of the first unrecognized instruction.  Do not skip past other
	instructions which change control flow.  Add debug output.
	(arm_scan_prologue): Use arm_analyze_prologue.
	(ARM_PC_32): Delete.
	(shifted_reg_val): Simplify ARM_PC_32 check.
@
text
@d2962 7
a2968 1
	  CORE_ADDR table, offset, length;
a2969 1
	  table = get_frame_register_unsigned (frame, bits (inst1, 0, 3));
d2974 1
a2974 1
      else if ((inst1 & 0xfff0) == 0xe8d0 && (inst2 & 0xfff0) == 0xf000)
d2977 7
a2983 1
	  CORE_ADDR table, offset, length;
a2984 1
	  table = get_frame_register_unsigned (frame, bits (inst1, 0, 3));
@


1.300
log
@	* arm-tdep.c (arm_make_stub_cache): Delete unused locals reg,
	unwound_fp.
@
text
@d238 5
d432 41
d475 3
a477 1
   clobber the stack frame unexpectedly, or an unknown instruction.  */
d484 1
d535 23
a557 3
      else if ((insn & 0xff00) == 0xaf00)	/* add r7, sp, #imm */
	regs[THUMB_FP_REGNUM] = pv_add_constant (regs[ARM_SP_REGNUM],
						 (insn & 0xff) << 2);
d580 125
d717 4
a783 4
  /* If we're in a dummy frame, don't even try to skip the prologue.  */
  if (deprecated_pc_in_call_dummy (gdbarch, pc))
    return pc;

d791 14
d806 24
a829 1
	return max (pc, post_prologue_pc);
d958 36
a993 64
/* This function decodes an ARM function prologue to determine:
   1) the size of the stack frame
   2) which registers are saved on it
   3) the offsets of saved regs
   4) the offset from the stack pointer to the frame pointer
   This information is stored in the "extra" fields of the frame_info.

   There are two basic forms for the ARM prologue.  The fixed argument
   function call will look like:

   mov    ip, sp
   stmfd  sp!, {fp, ip, lr, pc}
   sub    fp, ip, #4
   [sub sp, sp, #4]

   Which would create this stack frame (offsets relative to FP):
   IP ->   4    (caller's stack)
   FP ->   0    PC (points to address of stmfd instruction + 8 in callee)
   -4   LR (return address in caller)
   -8   IP (copy of caller's SP)
   -12  FP (caller's FP)
   SP -> -28    Local variables

   The frame size would thus be 32 bytes, and the frame offset would be
   28 bytes.  The stmfd call can also save any of the vN registers it
   plans to use, which increases the frame size accordingly.

   Note: The stored PC is 8 off of the STMFD instruction that stored it
   because the ARM Store instructions always store PC + 8 when you read
   the PC register.

   A variable argument function call will look like:

   mov    ip, sp
   stmfd  sp!, {a1, a2, a3, a4}
   stmfd  sp!, {fp, ip, lr, pc}
   sub    fp, ip, #20

   Which would create this stack frame (offsets relative to FP):
   IP ->  20    (caller's stack)
   16  A4
   12  A3
   8  A2
   4  A1
   FP ->   0    PC (points to address of stmfd instruction + 8 in callee)
   -4   LR (return address in caller)
   -8   IP (copy of caller's SP)
   -12  FP (caller's FP)
   SP -> -28    Local variables

   The frame size would thus be 48 bytes, and the frame offset would be
   28 bytes.

   There is another potential complication, which is that the optimizer
   will try to separate the store of fp in the "stmfd" instruction from
   the "sub fp, ip, #NN" instruction.  Almost anything can be there, so
   we just key on the stmfd, and then scan for the "sub fp, ip, #NN"...

   Also, note, the original version of the ARM toolchain claimed that there
   should be an

   instruction at the end of the prologue.  I have never seen GCC produce
   this, and the ARM docs don't mention it.  We still test for it below in
   case it happens...
d995 5
a999 1
 */
d1001 5
a1005 15
static void
arm_scan_prologue (struct frame_info *this_frame,
		   struct arm_prologue_cache *cache)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  enum bfd_endian byte_order_for_code = gdbarch_byte_order_for_code (gdbarch);
  int regno;
  CORE_ADDR prologue_start, prologue_end, current_pc;
  CORE_ADDR prev_pc = get_frame_pc (this_frame);
  CORE_ADDR block_addr = get_frame_address_in_block (this_frame);
  pv_t regs[ARM_FPS_REGNUM];
  struct pv_area *stack;
  struct cleanup *back_to;
  CORE_ADDR offset;
d1007 5
a1011 3
  /* Assume there is no frame until proven otherwise.  */
  cache->framereg = ARM_SP_REGNUM;
  cache->framesize = 0;
d1013 9
a1021 6
  /* Check for Thumb prologue.  */
  if (arm_frame_is_thumb (this_frame))
    {
      thumb_scan_prologue (gdbarch, prev_pc, block_addr, cache);
      return;
    }
d1023 5
a1027 7
  /* Find the function prologue.  If we can't find the function in
     the symbol table, peek in the stack frame to find the PC.  */
  if (find_pc_partial_function (block_addr, NULL, &prologue_start,
				&prologue_end))
    {
      /* One way to find the end of the prologue (which works well
         for unoptimized code) is to do the following:
d1029 6
a1034 1
	    struct symtab_and_line sal = find_pc_line (prologue_start, 0);
d1036 3
a1038 4
	    if (sal.line == 0)
	      prologue_end = prev_pc;
	    else if (sal.end < prologue_end)
	      prologue_end = sal.end;
d1040 4
a1043 6
	 This mechanism is very accurate so long as the optimizer
	 doesn't move any instructions from the function body into the
	 prologue.  If this happens, sal.end will be the last
	 instruction in the first hunk of prologue code just before
	 the first instruction that the scheduler has moved from
	 the body to the prologue.
d1045 4
a1048 29
	 In order to make sure that we scan all of the prologue
	 instructions, we use a slightly less accurate mechanism which
	 may scan more than necessary.  To help compensate for this
	 lack of accuracy, the prologue scanning loop below contains
	 several clauses which'll cause the loop to terminate early if
	 an implausible prologue instruction is encountered.  
	 
	 The expression
	 
	      prologue_start + 64
	    
	 is a suitable endpoint since it accounts for the largest
	 possible prologue plus up to five instructions inserted by
	 the scheduler.  */
         
      if (prologue_end > prologue_start + 64)
	{
	  prologue_end = prologue_start + 64;	/* See above.  */
	}
    }
  else
    {
      /* We have no symbol information.  Our only option is to assume this
	 function has a standard stack frame and the normal frame register.
	 Then, we can find the value of our frame pointer on entrance to
	 the callee (or at the present moment if this is the innermost frame).
	 The value stored there should be the address of the stmfd + 8.  */
      CORE_ADDR frame_loc;
      LONGEST return_value;
d1050 9
a1058 10
      frame_loc = get_frame_register_unsigned (this_frame, ARM_FP_REGNUM);
      if (!safe_read_memory_integer (frame_loc, 4, byte_order, &return_value))
        return;
      else
        {
          prologue_start = gdbarch_addr_bits_remove 
			     (gdbarch, return_value) - 8;
          prologue_end = prologue_start + 64;	/* See above.  */
        }
    }
d1060 14
a1073 2
  if (prev_pc < prologue_end)
    prologue_end = prev_pc;
d1075 1
a1075 1
  /* Now search the prologue looking for instructions that set up the
d1083 1
a1083 12
     traceback.

     In the APCS, the prologue should start with  "mov ip, sp" so
     if we don't see this as the first insn, we will stop.  

     [Note: This doesn't seem to be true any longer, so it's now an
     optional part of the prologue.  - Kevin Buettner, 2001-11-20]

     [Note further: The "mov ip,sp" only seems to be missing in
     frameless functions at optimization level "-O2" or above,
     in which case it is often (but not always) replaced by
     "str lr, [sp, #-4]!".  - Michael Snyder, 2002-04-23]  */
d1102 2
a1103 1
      else if ((insn & 0xfffff000) == 0xe28dc000) /* add ip, sp #n */
d1107 1
d1109 1
a1109 1
	  regs[ARM_IP_REGNUM] = pv_add_constant (regs[ARM_SP_REGNUM], imm);
d1112 2
a1113 1
      else if ((insn & 0xfffff000) == 0xe24dc000) /* sub ip, sp #n */
d1117 1
d1119 1
a1119 1
	  regs[ARM_IP_REGNUM] = pv_add_constant (regs[ARM_SP_REGNUM], -imm);
d1122 1
a1122 1
      else if (insn == 0xe52de004)	/* str lr, [sp, #-4]! */
d1127 2
a1128 1
	  pv_area_store (stack, regs[ARM_SP_REGNUM], 4, regs[ARM_LR_REGNUM]);
d1149 2
a1150 2
      else if ((insn & 0xffffc000) == 0xe54b0000	/* strb rx,[r11,#-n] */
	       || (insn & 0xffffc0f0) == 0xe14b00b0	/* strh rx,[r11,#-n] */
d1156 2
a1157 2
      else if ((insn & 0xffffc000) == 0xe5cd0000	/* strb rx,[sp,#n] */
	       || (insn & 0xffffc0f0) == 0xe1cd00b0	/* strh rx,[sp,#n] */
d1163 6
d1226 12
d1240 24
a1263 2
      else if ((insn & 0xfe200000) == 0xe8200000)	/* ldm? */
	break;			/* Don't scan past a block load */
d1265 6
a1270 3
	/* The optimizer might shove anything into the prologue,
	   so we just skip what we don't recognize.  */
	continue;
d1273 3
d1281 2
a1282 2
      cache->framereg = ARM_FP_REGNUM;
      cache->framesize = -regs[ARM_FP_REGNUM].k;
d1287 2
a1288 2
      cache->framereg = ARM_SP_REGNUM;
      cache->framesize = -regs[ARM_SP_REGNUM].k;
d1293 12
a1304 2
      cache->framereg = -1;
      cache->framesize = 0;
d1307 3
a1309 3
  for (regno = 0; regno < ARM_FPS_REGNUM; regno++)
    if (pv_area_find_reg (stack, gdbarch, regno, &offset))
      cache->saved_regs[regno].addr = offset;
d1312 96
a2567 10
/* Support routines for single stepping.  Calculate the next PC value.  */
#define submask(x) ((1L << ((x) + 1)) - 1)
#define bit(obj,st) (((obj) >> (st)) & 1)
#define bits(obj,st,fn) (((obj) >> (st)) & submask ((fn) - (st)))
#define sbits(obj,st,fn) \
  ((long) (bits(obj,st,fn) | ((long) bit(obj,fn) * ~ submask (fn - st))))
#define BranchDest(addr,instr) \
  ((CORE_ADDR) (((long) (addr)) + 8 + (sbits (instr, 0, 23) << 2)))
#define ARM_PC_32 1

d2586 1
a2586 2
	 ? ((pc_val | (ARM_PC_32 ? 0 : status_reg))
	    + (bit (inst, 4) ? 12 : 8))
@


1.299
log
@	* arm-tdep.c (arm_stub_unwind_sniffer): Add comment.
@
text
@a1200 1
  int reg;
a1201 1
  CORE_ADDR unwound_fp;
@


1.298
log
@2010-03-04  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>

	* arm-tdep.c (arm_pc_is_thumb): Add heuristic that tries to get
	the state right when single stepping.
	(arm_get_next_pc_raw, thumb_get_next_pc_raw): New functions.
	Get the next PC along with the instruction state.
	(thumb_get_next_pc): Remove.
	(arm_get_next_pc): Modified to use arm_get_next_pc_raw.
@
text
@d1239 2
@


1.297
log
@	* arm-tdep.c (thumb_get_next_pc): Correct conditional branch opcode.
@
text
@d337 3
d381 5
a385 1
     displayed in the mode it will be executed).  */
d387 17
a403 1
    return arm_frame_is_thumb (get_current_frame ());
d2339 1
a2339 1
thumb_get_next_pc (struct frame_info *frame, CORE_ADDR pc)
d2351 3
d2392 1
a2392 1
	  return pc;
d2410 1
a2410 1
	      return pc;
d2435 2
a2436 1
	      insert_single_step_breakpoint (gdbarch, aspace, pc);
d2452 1
a2452 1
	      return pc;
d2466 1
a2466 1
	    return pc + 4;
d2468 1
a2468 1
	    return pc + 2;
a2482 3
      nextpc = gdbarch_addr_bits_remove (gdbarch, nextpc);
      if (nextpc == pc)
	error (_("Infinite loop detected"));
d2501 1
d2594 1
a2662 4

      nextpc = gdbarch_addr_bits_remove (gdbarch, nextpc);
      if (nextpc == pc)
	error (_("Infinite loop detected"));
a2674 1

d2678 11
a2688 2
CORE_ADDR
arm_get_next_pc (struct frame_info *frame, CORE_ADDR pc)
d2699 1
a2699 1
    return thumb_get_next_pc (frame, pc);
d2716 1
a2716 4

	  nextpc = gdbarch_addr_bits_remove (gdbarch, nextpc);
	  if (nextpc == pc)
	    error (_("Infinite loop detected"));
d2752 1
a2752 1
		result = (rn == 15) ? pc_val + 8
a2753 6
		nextpc = (CORE_ADDR) gdbarch_addr_bits_remove
				       (gdbarch, result);

		if (nextpc == pc)
		  error (_("Infinite loop detected"));

a2830 2
	    nextpc = (CORE_ADDR) gdbarch_addr_bits_remove
				   (gdbarch, result);
d2832 7
a2838 2
	    if (nextpc == pc)
	      error (_("Infinite loop detected"));
a2877 5

		  nextpc = gdbarch_addr_bits_remove (gdbarch, nextpc);

		  if (nextpc == pc)
		    error (_("Infinite loop detected"));
a2911 4
		  nextpc = gdbarch_addr_bits_remove
			     (gdbarch, nextpc);
		  if (nextpc == pc)
		    error (_("Infinite loop detected"));
a2919 4

	    nextpc = gdbarch_addr_bits_remove (gdbarch, nextpc);
	    if (nextpc == pc)
	      error (_("Infinite loop detected"));
d2938 12
@


1.296
log
@	* arm-tdep.c (arm_find_mapping_symbol): New function, from
	arm_pc_is_thumb.
	(arm_pc_is_thumb): Use arm_find_mapping_symbol.
	(extend_buffer_earlier): New function.
	(MAX_IT_BLOCK_PREFIX, IT_SCAN_THRESHOLD): New constants.
	(arm_adjust_breakpoint_address): New function.
	(arm_gdbarch_init): Register arm_adjust_breakpoint_address.

	testsuite/
	* gdb.arch/thumb2-it.S (it_breakpoints): New function.
	* gdb.arch/thumb2-it.exp (test_it_break): New function.
	(Top level): Call it.
@
text
@d2506 1
a2506 1
	  else if ((inst2 & 0xd000) == 0xc000 && (inst1 & 0x0380) != 0x0380)
@


1.296.2.1
log
@	* arm-tdep.c (thumb_get_next_pc): Correct conditional branch opcode.
@
text
@d2506 1
a2506 1
	  else if ((inst2 & 0xd000) == 0x8000 && (inst1 & 0x0380) != 0x0380)
@


1.295
log
@	* arm-linux-tdep.c (arm_linux_thumb2_be_breakpoint)
	(arm_linux_thumb2_le_breakpoint): New constants.
	(arm_linux_init_abi): Set thumb2_breakpoint and
	thumb2_breakpoint_size.
	* arm-tdep.c (thumb_insn_size, thumb_advance_itstate): New functions.
	(thumb_get_next_pc): Add a comment.  Rename IT to ITSTATE.
	Implement support for single stepping through IT blocks if
	a 32-bit Thumb breakpoint instruction is available.
	(arm_breakpoint_from_pc): If a 32-bit Thumb breakpoint instruction
	is available, use it when needed.
	(arm_remote_breakpoint_from_pc): New function.
	(arm_gdbarch_init): Register arm_remote_breakpoint_from_pc.
	* arm-tdep.h (struct gdbarch_tdep): Correct thumb_breakpoint
	comment.  Add thumb2_breakpoint and thumb2_breakpoint_size.

	gdbserver/
	* linux-arm-low.c (thumb_breakpoint_len): Delete.
	(thumb2_breakpoint): New.
	(arm_breakpoint_at): Check for Thumb-2 breakpoints.

	testsuite/
	* gdb.arch/thumb2-it.S, gdb.arch/thumb2-it.exp: New files.
@
text
@d278 3
a280 3
/* Determine if the program counter specified in MEMADDR is in a Thumb
   function.  This function should be called for addresses unrelated to
   any executing frame; otherwise, prefer arm_frame_is_thumb.  */
d282 2
a283 2
static int
arm_pc_is_thumb (CORE_ADDR memaddr)
a285 11
  struct minimal_symbol *sym;

  /* If bit 0 of the address is set, assume this is a Thumb address.  */
  if (IS_THUMB_ADDR (memaddr))
    return 1;

  /* If the user wants to override the symbol table, let him.  */
  if (strcmp (arm_force_mode_string, "arm") == 0)
    return 0;
  if (strcmp (arm_force_mode_string, "thumb") == 0)
    return 1;
d316 5
a320 1
		    return map_sym->type == 't';
d326 3
a328 1
		  return map_sym->type == 't';
d334 29
d2948 186
d6487 4
@


1.294
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d2259 32
d2295 1
d2302 1
a2302 1
  ULONGEST status, it;
d2315 44
a2358 1
  it = ((status >> 8) & 0xfc) | ((status >> 25) & 0x3);
d2360 40
a2399 5
  /* On GNU/Linux, where this routine is used, we use an undefined
     instruction as a breakpoint.  Unlike BKPT, IT can disable execution
     of the undefined instruction.  So we might miss the breakpoint!  */
  if (((inst1 & 0xff00) == 0xbf00 && (inst1 & 0x000f) != 0) || (it & 0x0f))
    error (_("Stepping through Thumb-2 IT blocks is not yet supported"));
d2401 5
a2405 1
  if (it & 0x0f)
d2408 1
a2408 1
      int cond = it >> 4;
d2419 2
d4869 1
d4874 18
d4902 14
d6244 2
@


1.293
log
@	* arm-tdep.c (arm_skip_stub): Recognize RealView veneer functions.
@
text
@d4 1
a4 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
@


1.292
log
@	Reported by Antti Hatala <ahatala@@nvidia.com>.

	* arm-tdep.c (thumb_get_next_pc): Limit check to IT instructions
	correctly.
@
text
@d5158 4
a5161 2
     are r0-r9, sl, fp, ip, sp, and lr.  */
  if (strncmp (name, "_call_via_", 10) == 0)
@


1.291
log
@2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	Add base multi-executable/process support to GDB.

	gdb/
	* Makefile.in (SFILES): Add progspace.c.
	(COMMON_OBS): Add progspace.o.
	* progspace.h: New.
	* progspace.c: New.

	* breakpoint.h (struct bp_target_info) <placed_address_space>: New
	field.
	(struct bp_location) <pspace>: New field.
	(struct breakpoint) <pspace>: New field.
	(bpstat_stop_status, breakpoint_here_p)
	(moribund_breakpoint_here_p, breakpoint_inserted_here_p)
	(regular_breakpoint_inserted_here_p)
	(software_breakpoint_inserted_here_p, breakpoint_thread_match)
	(set_default_breakpoint): Adjust prototypes.
	(remove_breakpoints_pid, breakpoint_program_space_exit): Declare.
	(insert_single_step_breakpoint, deprecated_insert_raw_breakpoint):
	Adjust prototypes.
	* breakpoint.c (executing_startup): Delete.
	(default_breakpoint_sspace): New.
	(breakpoint_restore_shadows): Skip if the address space doesn't
	match.
	(update_watchpoint): Record the frame's program space in the
	breakpoint location.
	(insert_bp_location): Record the address space in target_info.
	Adjust to pass the symbol space to solib_name_from_address.
	(breakpoint_program_space_exit): New.
	(insert_breakpoint_locations): Switch the symbol space and thread
	when inserting breakpoints.  Don't insert breakpoints in a vfork
	parent waiting for vfork done if we're not attached to the vfork
	child.
	(remove_breakpoints_pid): New.
	(reattach_breakpoints): Switch to a thread of PID.  Ignore
	breakpoints of other symbol spaces.
	(create_internal_breakpoint): Store the symbol space in the sal.
	(create_longjmp_master_breakpoint): Iterate over all symbol
	spaces.
	(update_breakpoints_after_exec): Ignore breakpoints for other
	symbol spaces.
	(remove_breakpoint): Rename to ...
	(remove_breakpoint_1): ... this.  Pass the breakpoints symbol
	space to solib_name_from_address.
	(remove_breakpoint): New.
	(mark_breakpoints_out): Ignore breakpoints from other symbol
	spaces.
	(breakpoint_init_inferior): Ditto.
	(breakpoint_here_p): Add an address space argument and adjust to
	use breakpoint_address_match.
	(moribund_breakpoint_here_p): Ditto.
	(regular_breakpoint_inserted_here_p): Ditto.
	(breakpoint_inserted_here_p): Ditto.
	(software_breakpoint_inserted_here_p): Ditto.
	(breakpoint_thread_match): Ditto.
	(bpstat_check_location): Ditto.
	(bpstat_stop_status): Ditto.
	(print_breakpoint_location): If there's a location to print,
	switch the current symbol space.
	(print_one_breakpoint_location): Add `allflag' argument.
	(print_one_breakpoint): Ditto.	Adjust.
	(do_captured_breakpoint_query): Adjust.
	(breakpoint_1): Adjust.
	(breakpoint_has_pc): Also match the symbol space.
	(describe_other_breakpoints): Add a symbol space argument and
	adjust.
	(set_default_breakpoint): Add a symbol space argument.	Set
	default_breakpoint_sspace.
	(breakpoint_address_match): New.
	(check_duplicates_for): Add an address space argument, and adjust.
	(set_raw_breakpoint): Record the symbol space in the location and
	in the breakpoint.
	(set_longjmp_breakpoint): Skip longjmp master breakpoints from
	other symbol spaces.
	(remove_thread_event_breakpoints, remove_solib_event_breakpoints)
	(disable_breakpoints_in_shlibs): Skip breakpoints from other
	symbol spaces.
	(disable_breakpoints_in_unloaded_shlib): Match symbol spaces.
	(create_catchpoint): Set the symbol space in the sal.
	(disable_breakpoints_before_startup): Skip breakpoints from other
	symbol spaces.	Set executing_startup in the current symbol space.
	(enable_breakpoints_after_startup): Clear executing_startup in the
	current symbol space.  Skip breakpoints from other symbol spaces.
	(clone_momentary_breakpoint): Also copy the symbol space.
	(add_location_to_breakpoint): Set the location's symbol space.
	(bp_loc_is_permanent): Switch thread and symbol space.
	(create_breakpoint): Adjust.
	(expand_line_sal_maybe): Expand comment to mention symbol spaces.
	Switch thread and symbol space when reading memory.
	(parse_breakpoint_sals): Set the symbol space in the sal.
	(break_command_really): Ditto.
	(skip_prologue_sal): Switch and space.
	(resolve_sal_pc): Ditto.
	(watch_command_1): Record the symbol space in the sal.
	(create_ada_exception_breakpoint): Adjust.
	(clear_command): Adjust.  Match symbol spaces.
	(update_global_location_list): Use breakpoint_address_match.
	(breakpoint_re_set_one): Switch thread and space.
	(breakpoint_re_set): Save symbol space.
	(breakpoint_re_set_thread): Also reset the symbol space.
	(deprecated_insert_raw_breakpoint): Add an address space argument.
	Adjust.
	(insert_single_step_breakpoint): Ditto.
	(single_step_breakpoint_inserted_here_p): Ditto.
	(clear_syscall_counts): New.
	(_initialize_breakpoint): Install it as inferior_exit observer.

	* exec.h: Include "progspace.h".
	(exec_bfd, exec_bfd_mtime): New defines.
	(exec_close): Declare.
	* exec.c: Include "gdbthread.h" and "progspace.h".
	(exec_bfd, exec_bfd_mtime, current_target_sections_1): Delete.
	(using_exec_ops): New.
	(exec_close_1): Rename to exec_close, and make public.
	(exec_close): Rename to exec_close_1, and adjust all callers.  Add
	description.  Remove target sections and close executables from
	all program spaces.
	(exec_file_attach): Add comment.
	(add_target_sections): Check on `using_exec_ops' to check if the
	target should be pushed.
	(remove_target_sections): Only unpush the target if there are no
	more target sections in any symbol space.
	* gdbcore.h: Include "exec.h".
	(exec_bfd, exec_bfd_mtime): Remove declarations.

	* frame.h (get_frame_program_space, get_frame_address_space)
	(frame_unwind_program_space): Declare.
	* frame.c (struct frame_info) <pspace, aspace>: New fields.
	(create_sentinel_frame): Add program space argument.  Set the
	pspace and aspace fields of the frame object.
	(get_current_frame, create_new_frame): Adjust.
	(get_frame_program_space): New.
	(frame_unwind_program_space): New.
	(get_frame_address_space): New.
	* stack.c (print_frame_info): Adjust.
	(print_frame): Use the frame's program space.

	* gdbthread.h (any_live_thread_of_process): Declare.
	* thread.c (any_live_thread_of_process): New.
	(switch_to_thread): Switch the program space as well.
	(restore_selected_frame): Don't warn if trying to restore frame
	level 0.

	* inferior.h: Include "progspace.h".
	(detach_fork): Declare.
	(struct inferior) <removable, aspace, pspace>
	<vfork_parent, vfork_child, pending_detach>
	<waiting_for_vfork_done>: New fields.
	<terminal_info>: Remove field.
	<data, num_data>: New fields.
	(register_inferior_data, register_inferior_data_with_cleanup)
	(clear_inferior_data, set_inferior_data, inferior_data): Declare.
	(exit_inferior, exit_inferior_silent, exit_inferior_num_silent)
	(inferior_appeared): Declare.
	(find_inferior_pid): Typo.
	(find_inferior_id, find_inferior_for_program_space): Declare.
	(set_current_inferior, save_current_inferior, prune_inferiors)
	(number_of_inferiors): Declare.
	(inferior_list): Declare.
	* inferior.c: Include "gdbcore.h" and "symfile.h".
	(inferior_list): Make public.
	(delete_inferior_1): Always delete thread silently.
	(find_inferior_id): Make public.
	(current_inferior_): New.
	(current_inferior): Use it.
	(set_current_inferior): New.
	(restore_inferior): New.
	(save_current_inferior): New.
	(free_inferior): Free the per-inferior data.
	(add_inferior_silent): Allocate per-inferior data.
	Call inferior_appeared.
	(delete_threads_of_inferior): New.
	(delete_inferior_1): Adjust interface to take an inferior pointer.
	(delete_inferior): Adjust.
	(delete_inferior_silent): Adjust.
	(exit_inferior_1): New.
	(exit_inferior): New.
	(exit_inferior_silent): New.
	(exit_inferior_num_silent): New.
	(detach_inferior): Adjust.
	(inferior_appeared): New.
	(discard_all_inferiors): Adjust.
	(find_inferior_id): Make public.  Assert pid is not zero.
	(find_inferior_for_program_space): New.
	(have_inferiors): Check if we have any inferior with pid not zero.
	(have_live_inferiors): Go over all pushed targets looking for
	process_stratum.
	(prune_inferiors): New.
	(number_of_inferiors): New.
	(print_inferior): Add executable column.  Print vfork parent/child
	relationships.
	(inferior_command): Adjust to cope with not running inferiors.
	(remove_inferior_command): New.
	(add_inferior_command): New.
	(clone_inferior_command): New.
	(struct inferior_data): New.
	(struct inferior_data_registration): New.
	(struct inferior_data_registry): New.
	(inferior_data_registry): New.
	(register_inferior_data_with_cleanup): New.
	(register_inferior_data): New.
	(inferior_alloc_data): New.
	(inferior_free_data): New.
	(clear_inferior_data): New.
	(set_inferior_data): New.
	(inferior_data): New.
	(initialize_inferiors): New.
	(_initialize_inferiors): Register "add-inferior",
	"remove-inferior" and "clone-inferior" commands.

	* objfiles.h: Include "progspace.h".
	(struct objfile) <pspace>: New field.
	(symfile_objfile, object_files): Don't declare.
	(ALL_PSPACE_OBJFILES): New.
	(ALL_PSPACE_OBJFILES_SAFE): New.
	(ALL_OBJFILES, ALL_OBJFILES_SAFE): Adjust.
	(ALL_PSPACE_SYMTABS): New.
	(ALL_PRIMARY_SYMTABS): Adjust.
	(ALL_PSPACE_PRIMARY_SYMTABS): New.
	(ALL_PSYMTABS): Adjust.
	(ALL_PSPACE_PSYMTABS): New.
	* objfiles.c (object_files, symfile_objfile): Delete.
	(struct objfile_sspace_info): New.
	(objfiles_pspace_data): New.
	(objfiles_pspace_data_cleanup): New.
	(get_objfile_pspace_data): New.
	(objfiles_changed_p): Delete.
	(allocate_objfile): Set the objfile's program space.  Adjust to
	reference objfiles_changed_p in pspace data.
	(free_objfile): Adjust to reference objfiles_changed_p in pspace
	data.
	(objfile_relocate): Ditto.
	(update_section_map): Add pspace argument.  Adjust to iterate over
	objfiles in the passed in pspace.
	(find_pc_section): Delete sections and num_sections statics.
	Adjust to refer to program space's objfiles_changed_p.	Adjust to
	refer to sections and num_sections store in the objfile's pspace
	data.
	(objfiles_changed): Adjust to reference objfiles_changed_p in
	pspace data.
	(_initialize_objfiles): New.
	* linespec.c (decode_all_digits, decode_dollar): Set the sal's
	program space.
	* source.c (current_source_pspace): New.
	(get_current_source_symtab_and_line): Set the sal's program space.
	(set_current_source_symtab_and_line): Set current_source_pspace.
	(select_source_symtab): Ditto.	Use ALL_OBJFILES.
	(forget_cached_source_info): Iterate over all program spaces.
	* symfile.c (clear_symtab_users): Adjust.
	* symmisc.c (print_symbol_bcache_statistics): Iterate over all
	program spaces.
	(print_objfile_statistics): Ditto.
	(maintenance_print_msymbols): Ditto.
	(maintenance_print_objfiles): Ditto.
	(maintenance_info_symtabs): Ditto.
	(maintenance_info_psymtabs): Ditto.
	* symtab.h (SYMTAB_PSPACE): New.
	(struct symtab_and_line) <pspace>: New field.
	* symtab.c (init_sal): Clear the sal's program space.
	(find_pc_sect_symtab): Set the sal's program space.  Switch thread
	and space.
	(append_expanded_sal): Add program space argument.  Iterate over
	all program spaces.
	(expand_line_sal): Iterate over all program spaces.  Switch
	program space.

	* target.h (enum target_waitkind) <TARGET_WAITKIND_VFORK_DONE>: New.
	(struct target_ops) <to_thread_address_space>: New field.
	(target_thread_address_space): Define.
	* target.c (target_detach): Only remove breakpoints from the
	inferior we're detaching.
	(target_thread_address_space): New.

	* defs.h (initialize_progspace): Declare.
	* top.c (gdb_init): Call it.

	* solist.h (struct so_list) <sspace>: New field.
	* solib.h (struct program_space): Forward declare.
	(solib_name_from_address): Adjust prototype.
	* solib.c (so_list_head): Replace with a macro referencing the
	program space.
	(update_solib_list): Set the so's program space.
	(solib_name_from_address): Add a program space argument and adjust.

	* solib-svr4.c (struct svr4_info) <pid>: Delete field.
	<interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low>
	<interp_plt_sect_high>: New fields.
	(svr4_info_p, svr4_info): Delete.
	(solib_svr4_sspace_data): New.
	(get_svr4_info): Rewrite.
	(svr4_sspace_data_cleanup): New.
	(open_symbol_file_object): Adjust.
	(svr4_default_sos): Adjust.
	(svr4_fetch_objfile_link_map): Adjust.
	(interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low)
	(interp_plt_sect_high): Delete.
	(svr4_in_dynsym_resolve_code): Adjust.
	(enable_break): Adjust.
	(svr4_clear_solib): Revert bit that removed the svr4_info here,
	and reinstate clearing debug_base, debug_loader_offset_p,
	debug_loader_offset and debug_loader_name.
	(_initialize_svr4_solib): Register solib_svr4_pspace_data.  Don't
	install an inferior_exit observer anymore.

	* printcmd.c (struct display) <pspace>: New field.
	(display_command): Set the display's sspace.
	(do_one_display): Match the display's sspace.
	(display_uses_solib_p): Ditto.

	* linux-fork.c (detach_fork): Moved to infrun.c.
	(_initialize_linux_fork): Moved "detach-on-fork" command to
	infrun.c.
	* infrun.c (detach_fork): Moved from linux-fork.c.
	(proceed_after_vfork_done): New.
	(handle_vfork_child_exec_or_exit): New.
	(follow_exec_mode_replace, follow_exec_mode_keep)
	(follow_exec_mode_names, follow_exec_mode_string)
	(show_follow_exec_mode_string): New.
	(follow_exec): New.  Reinstate the mark_breakpoints_out call.
	Remove shared libraries before attaching new executable.  If user
	wants to keep the inferior, keep it.
	(displaced_step_fixup): Adjust to pass an address space to the
	breakpoints module.
	(resume): Ditto.
	(clear_proceed_status): In all-stop mode, always clear the proceed
	status of all threads.
	(prepare_to_proceed): Adjust to pass an address space to the
	breakpoints module.
	(proceed): Ditto.
	(adjust_pc_after_break): Ditto.
	(handle_inferior_event): When handling a process exit, switch the
	program space to the inferior's that had exited.  Call
	handle_vfork_child_exec_or_exit.  Adjust to pass an address space
	to the breakpoints module.  In non-stop mode, when following a
	fork and detach-fork is off, also resume the other branch.  Handle
	TARGET_WAITKIND_VFORK_DONE.  Set the program space in sals.
	(normal_stop): Prune inferiors.
	(_initialize_infrun): Install the new "follow-exec-mode" command.
	"detach-on-fork" moved here.

	* regcache.h (get_regcache_aspace): Declare.
	* regcache.c (struct regcache) <aspace>: New field.
	(regcache_xmalloc): Clear the aspace.
	(get_regcache_aspace): New.
	(regcache_cpy): Copy the aspace field.
	(regcache_cpy_no_passthrough): Ditto.
	(get_thread_regcache): Fetch the thread's address space from the
	target, and store it in the regcache.

	* infcall.c (call_function_by_hand): Set the sal's pspace.

	* arch-utils.c (default_has_shared_address_space): New.
	* arch-utils.h (default_has_shared_address_space): Declare.

	* gdbarch.sh (has_shared_address_space): New.
	* gdbarch.h, gdbarch.c: Regenerate.

	* linux-tdep.c: Include auxv.h, target.h, elf/common.h.
	(linux_has_shared_address_space): New.
	(_initialize_linux_tdep): Declare.

	* arm-tdep.c (arm_software_single_step): Pass the frame's address
	space to insert_single_step_breakpoint.
	* arm-linux-tdep.c (arm_linux_software_single_step): Pass the
	frame's pspace to breakpoint functions.
	* cris-tdep.c (crisv32_single_step_through_delay): Ditto.
	(cris_software_single_step): Ditto.
	* mips-tdep.c (deal_with_atomic_sequence): Add frame argument.
	Pass the frame's pspace to breakpoint functions.
	(mips_software_single_step): Adjust.
	(mips_single_step_through_delay): Adjust.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Adjust.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Adjust.
	* solib-irix.c (enable_break): Adjust to pass the current frame's
	address space to breakpoint functions.
	* sparc-tdep.c (sparc_software_single_step): Ditto.
	* spu-tdep.c (spu_software_single_step): Ditto.
	* alpha-tdep.c (alpha_software_single_step): Ditto.
	* record.c (record_wait): Adjust to pass an address space to the
	breakpoints module.

	* fork-child.c (fork_inferior): Set the new inferior's program and
	address spaces.
	* inf-ptrace.c (inf_ptrace_follow_fork): Copy the parent's program
	and address spaces.
	(inf_ptrace_attach): Set the inferior's program and address spaces.
	* linux-nat.c: Include "solib.h".
	(linux_child_follow_fork): Manage parent and child's program and
	address spaces.	 Clone the parent's program space if necessary.
	Don't wait for the vfork to be done here.  Refuse to resume if
	following the vfork parent while leaving the child stopped.
	(resume_callback): Don't resume a vfork parent.
	(linux_nat_resume): Also check for pending events in the
	lp->waitstatus field.
	(linux_handle_extended_wait): Report TARGET_WAITKIND_VFORK_DONE
	events to the core.
	(stop_wait_callback): Don't wait for SIGSTOP on vfork parents.
	(cancel_breakpoint): Adjust.
	* linux-thread-db.c (thread_db_wait): Don't remove thread event
	breakpoints here.
	(thread_db_mourn_inferior): Don't mark breakpoints out here.
	Remove thread event breakpoints after mourning.
	* corelow.c: Include progspace.h.
	(core_open): Set the inferior's program and address spaces.
	* remote.c (remote_add_inferior): Set the new inferior's program
	and address spaces.
	(remote_start_remote): Update address spaces.
	(extended_remote_create_inferior_1): Don't init the thread list if
	we already debugging other inferiors.
	* darwin-nat.c (darwin_attach): Set the new inferior's program and
	address spaces.
	* gnu-nat.c (gnu_attach): Ditto.
	* go32-nat.c (go32_create_inferior): Ditto.
	* inf-ttrace.c (inf_ttrace_follow_fork, inf_ttrace_attach): Ditto.
	* monitor.c (monitor_open): Ditto.
	* nto-procfs.c (procfs_attach, procfs_create_inferior): Ditto.
	* procfs.c (do_attach): Ditto.
	* windows-nat.c (do_initial_windows_stuff): Ditto.

	* inflow.c (inferior_process_group)
	(terminal_init_inferior_with_pgrp, terminal_inferior,
	(terminal_ours_1, inflow_inferior_exit, copy_terminal_info)
	(child_terminal_info, new_tty_postfork, set_sigint_trap): Adjust
	to use per-inferior data instead of inferior->terminal_info.
	(inflow_inferior_data): New.
	(inflow_new_inferior): Delete.
	(inflow_inferior_data_cleanup): New.
	(get_inflow_inferior_data): New.

	* mi/mi-interp.c (mi_new_inferior): Rename to...
	(mi_inferior_appeared): ... this.
	(mi_interpreter_init): Adjust.

	* tui/tui-disasm.c: Include "progspace.h".
	(tui_set_disassem_content): Pass an address space to
	breakpoint_here_p.

	* NEWS: Mention multi-program debugging support.  Mention new
	commands "add-inferior", "clone-inferior", "remove-inferior",
	"maint info program-spaces", and new option "set
	follow-exec-mode".

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* observer.texi (new_inferior): Rename to...
	(inferior_appeared): ... this.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/testsuite/
	* gdb.base/foll-vfork.exp: Adjust to spell out "follow-fork".
	* gdb.base/foll-exec.exp: Adjust to expect a process id before
	"Executing new program".
	* gdb.base/foll-fork.exp: Adjust to spell out "follow-fork".
	* gdb.base/multi-forks.exp: Ditto.  Adjust to the inferior being
	left listed after having been killed.
	* gdb.base/attach.exp: Adjust to spell out "symbol-file".
	* gdb.base/maint.exp: Adjust test.

	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* gdb.multi/Makefile.in: New.
	* gdb.multi/base.exp: New.
	* gdb.multi/goodbye.c: New.
	* gdb.multi/hangout.c: New.
	* gdb.multi/hello.c: New.
	* gdb.multi/bkpt-multi-exec.c: New.
	* gdb.multi/bkpt-multi-exec.exp: New.
	* gdb.multi/crashme.c: New.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Inferiors): Rename node to ...
	(Inferiors and Programs): ... this.  Mention running multiple
	programs in the same debug session.
	<info inferiors>: Mention the new 'Executable' column if "info
	inferiors".  Update examples.  Document the "add-inferior",
	"clone-inferior", "remove-inferior" and "maint info
	program-spaces" commands.
	(Process): Rename node to...
	(Forks): ... this.  Document "set|show follow-exec-mode".
@
text
@d2287 1
a2287 1
  if ((inst1 & 0xff00) == 0xbf00 || (it & 0x0f))
@


1.290
log
@	* arm-tdep.c (arm_push_dummy_call): Set the low bit of LR for
	a Thumb entry point.
	(thumb_get_next_pc): Handle Thumb-2 and ARM v6 instructions.  Refuse
	to single step into IT blocks.
@
text
@d2795 1
d2802 1
a2802 1
  insert_single_step_breakpoint (gdbarch, next_pc);
@


1.289
log
@	ARI fix: OP eol rule.
	* ada-exp.y (block_lookup): Avoid operator at end of line.
	* aix-thread.c (pd_enable): Idem.
	* alpha-tdep.c (alpha_next_pc): Idem.
	* arm-tdep.c (arm_skip_prologue, arm_scan_prologue): Idem.
	(condition_true, coff_sym_is_thumb): Idem.
@
text
@d1630 2
a1631 1
  /* XXX Fix for Thumb.  */
d2269 1
d2273 33
a2320 1
      unsigned long status = get_frame_register_unsigned (frame, ARM_PS_REGNUM);
d2329 1
a2329 1
  else if ((inst1 & 0xf800) == 0xf000)	/* long branch with link, and blx */
d2333 156
a2488 5
      offset = (sbits (inst1, 0, 10) << 12) + (bits (inst2, 0, 10) << 1);
      nextpc = pc_val + offset;
      /* For BLX make sure to clear the low bits.  */
      if (bits (inst2, 11, 12) == 1)
	nextpc = nextpc & 0xfffffffc;
d2501 11
@


1.288
log
@	* objfiles.c (struct objfile_data): Delete member cleanup and replace
	with save, free.
	(register_objfile_data_with_cleanup): Delete arg cleanup and replace
	with save, free.  All callers updated.
	(clear_objfile_data): Replace cleanup loop with separate save and
	free loops.
	* objfiles.h (register_objfile_data_with_cleanup): Update.
	* arm-tdep.c (arm_objfile_data_free): Renamed from
	arm_objfile_data_cleanup, all callers updated.
	* dwarf2read.c (dwarf2_per_objfile_free): Renamed from
	dwarf2_per_objfile_cleanup, all callers updated.
	* python/py-objfile.c (py_free_objfile): Renamed from clean_up_objfile,
	all callers updated.
	* python/py-type.c (save_objfile_types): Renamed from
	clean_up_objfile_types, all callers updated.
@
text
@d613 3
a615 3
      if ((inst & 0xffffc000) == 0xe54b0000 ||	/* strb r(0123),[r11,#-nn] */
	  (inst & 0xffffc0f0) == 0xe14b00b0 ||	/* strh r(0123),[r11,#-nn] */
	  (inst & 0xffffc000) == 0xe50b0000)	/* str  r(0123),[r11,#-nn] */
d618 3
a620 3
      if ((inst & 0xffffc000) == 0xe5cd0000 ||	/* strb r(0123),[sp,#nn] */
	  (inst & 0xffffc0f0) == 0xe1cd00b0 ||	/* strh r(0123),[sp,#nn] */
	  (inst & 0xffffc000) == 0xe58d0000)	/* str  r(0123),[sp,#nn] */
d920 3
a922 3
      else if ((insn & 0xffffc000) == 0xe54b0000 ||	/* strb rx,[r11,#-n] */
	       (insn & 0xffffc0f0) == 0xe14b00b0 ||	/* strh rx,[r11,#-n] */
	       (insn & 0xffffc000) == 0xe50b0000)	/* str  rx,[r11,#-n] */
d927 3
a929 3
      else if ((insn & 0xffffc000) == 0xe5cd0000 ||	/* strb rx,[sp,#n] */
	       (insn & 0xffffc0f0) == 0xe1cd00b0 ||	/* strh rx,[sp,#n] */
	       (insn & 0xffffc000) == 0xe58d0000)	/* str  rx,[sp,#n] */
d2175 3
a2177 2
      return (((status_reg & FLAG_Z) == 0) &&
	      (((status_reg & FLAG_N) == 0) == ((status_reg & FLAG_V) == 0)));
d2179 3
a2181 2
      return (((status_reg & FLAG_Z) != 0) ||
	      (((status_reg & FLAG_N) == 0) != ((status_reg & FLAG_V) == 0)));
d5213 5
a5217 5
  return (val == C_THUMBEXT ||
	  val == C_THUMBSTAT ||
	  val == C_THUMBEXTFUNC ||
	  val == C_THUMBSTATFUNC ||
	  val == C_THUMBLABEL);
@


1.288.2.1
log
@Backport Thumb2 debug support.

2009-11-13  Ramana Radhakrishnan  <ramana.radhakrishnan@@arm.com>

        Backport from mainline.
        2009-07-28  Daniel Jacobowitz  <dan@@codesourcery.com>

        * arm-tdep.c (arm_push_dummy_call): Set the low bit of LR for
        a Thumb entry point.
	(thumb_get_next_pc): Handle Thumb-2 and ARM v6 instructions.
	Refuse to single step into IT blocks.

        2009-10-28  Daniel Jacobowitz  <dan@@codesourcery.com>

        Reported by Antti Hatala <ahatala@@nvidia.com>
        * arm-tdep.c (thumb_get_next_pc): Limit check to IT instructions
        correctly.

A9 integer pipeline description.

2009-10-31  Ramana Radhakrishnan  <ramana.radhakrishnan@@arm.com>

        * config/arm/cortex-a9.md: New - integer pipeline description.
@
text
@d1630 1
a1630 2
  if (arm_pc_is_thumb (bp_addr))
    bp_addr |= 1;
a2265 1
  ULONGEST status, it;
a2268 33
  /* Thumb-2 conditional execution support.  There are eight bits in
     the CPSR which describe conditional execution state.  Once
     reconstructed (they're in a funny order), the low five bits
     describe the low bit of the condition for each instruction and
     how many instructions remain.  The high three bits describe the
     base condition.  One of the low four bits will be set if an IT
     block is active.  These bits read as zero on earlier
     processors.  */
  status = get_frame_register_unsigned (frame, ARM_PS_REGNUM);
  it = ((status >> 8) & 0xfc) | ((status >> 25) & 0x3);

  /* On GNU/Linux, where this routine is used, we use an undefined
     instruction as a breakpoint.  Unlike BKPT, IT can disable execution
     of the undefined instruction.  So we might miss the breakpoint!  */
  if (((inst1 & 0xff00) == 0xbf00 && (inst1 & 0x000f) != 0) || (it & 0x0f))
    error (_("Stepping through Thumb-2 IT blocks is not yet supported"));

  if (it & 0x0f)
    {
      /* We are in a conditional block.  Check the condition.  */
      int cond = it >> 4;

      if (! condition_true (cond, status))
	{
	  /* Advance to the next instruction.  All the 32-bit
	     instructions share a common prefix.  */
	  if ((inst1 & 0xe000) == 0xe000 && (inst1 & 0x1800) != 0)
	    return pc + 4;
	  else
	    return pc + 2;
	}
    }

d2284 1
d2293 1
a2293 1
  else if ((inst1 & 0xe000) == 0xe000) /* 32-bit instruction */
d2297 5
a2301 156

      /* Default to the next instruction.  */
      nextpc = pc + 4;

      if ((inst1 & 0xf800) == 0xf000 && (inst2 & 0x8000) == 0x8000)
	{
	  /* Branches and miscellaneous control instructions.  */

	  if ((inst2 & 0x1000) != 0 || (inst2 & 0xd001) == 0xc000)
	    {
	      /* B, BL, BLX.  */
	      int j1, j2, imm1, imm2;

	      imm1 = sbits (inst1, 0, 10);
	      imm2 = bits (inst2, 0, 10);
	      j1 = bit (inst2, 13);
	      j2 = bit (inst2, 11);

	      offset = ((imm1 << 12) + (imm2 << 1));
	      offset ^= ((!j2) << 22) | ((!j1) << 23);

	      nextpc = pc_val + offset;
	      /* For BLX make sure to clear the low bits.  */
	      if (bit (inst2, 12) == 0)
		nextpc = nextpc & 0xfffffffc;
	    }
	  else if (inst1 == 0xf3de && (inst2 & 0xff00) == 0x3f00)
	    {
	      /* SUBS PC, LR, #imm8.  */
	      nextpc = get_frame_register_unsigned (frame, ARM_LR_REGNUM);
	      nextpc -= inst2 & 0x00ff;
	    }
	  else if ((inst2 & 0xd000) == 0xc000 && (inst1 & 0x0380) != 0x0380)
	    {
	      /* Conditional branch.  */
	      if (condition_true (bits (inst1, 6, 9), status))
		{
		  int sign, j1, j2, imm1, imm2;

		  sign = sbits (inst1, 10, 10);
		  imm1 = bits (inst1, 0, 5);
		  imm2 = bits (inst2, 0, 10);
		  j1 = bit (inst2, 13);
		  j2 = bit (inst2, 11);

		  offset = (sign << 20) + (j2 << 19) + (j1 << 18);
		  offset += (imm1 << 12) + (imm2 << 1);

		  nextpc = pc_val + offset;
		}
	    }
	}
      else if ((inst1 & 0xfe50) == 0xe810)
	{
	  /* Load multiple or RFE.  */
	  int rn, offset, load_pc = 1;

	  rn = bits (inst1, 0, 3);
	  if (bit (inst1, 7) && !bit (inst1, 8))
	    {
	      /* LDMIA or POP */
	      if (!bit (inst2, 15))
		load_pc = 0;
	      offset = bitcount (inst2) * 4 - 4;
	    }
	  else if (!bit (inst1, 7) && bit (inst1, 8))
	    {
	      /* LDMDB */
	      if (!bit (inst2, 15))
		load_pc = 0;
	      offset = -4;
	    }
	  else if (bit (inst1, 7) && bit (inst1, 8))
	    {
	      /* RFEIA */
	      offset = 0;
	    }
	  else if (!bit (inst1, 7) && !bit (inst1, 8))
	    {
	      /* RFEDB */
	      offset = -8;
	    }
	  else
	    load_pc = 0;

	  if (load_pc)
	    {
	      CORE_ADDR addr = get_frame_register_unsigned (frame, rn);
	      nextpc = get_frame_memory_unsigned (frame, addr + offset, 4);
	    }
	}
      else if ((inst1 & 0xffef) == 0xea4f && (inst2 & 0xfff0) == 0x0f00)
	{
	  /* MOV PC or MOVS PC.  */
	  nextpc = get_frame_register_unsigned (frame, bits (inst2, 0, 3));
	}
      else if ((inst1 & 0xff70) == 0xf850 && (inst2 & 0xf000) == 0xf000)
	{
	  /* LDR PC.  */
	  CORE_ADDR base;
	  int rn, load_pc = 1;

	  rn = bits (inst1, 0, 3);
	  base = get_frame_register_unsigned (frame, rn);
	  if (rn == 15)
	    {
	      base = (base + 4) & ~(CORE_ADDR) 0x3;
	      if (bit (inst1, 7))
		base += bits (inst2, 0, 11);
	      else
		base -= bits (inst2, 0, 11);
	    }
	  else if (bit (inst1, 7))
	    base += bits (inst2, 0, 11);
	  else if (bit (inst2, 11))
	    {
	      if (bit (inst2, 10))
		{
		  if (bit (inst2, 9))
		    base += bits (inst2, 0, 7);
		  else
		    base -= bits (inst2, 0, 7);
		}
	    }
	  else if ((inst2 & 0x0fc0) == 0x0000)
	    {
	      int shift = bits (inst2, 4, 5), rm = bits (inst2, 0, 3);
	      base += get_frame_register_unsigned (frame, rm) << shift;
	    }
	  else
	    /* Reserved.  */
	    load_pc = 0;

	  if (load_pc)
	    nextpc = get_frame_memory_unsigned (frame, base, 4);
	}
      else if ((inst1 & 0xfff0) == 0xe8d0 && (inst2 & 0xfff0) == 0xf000)
	{
	  /* TBB.  */
	  CORE_ADDR table, offset, length;

	  table = get_frame_register_unsigned (frame, bits (inst1, 0, 3));
	  offset = get_frame_register_unsigned (frame, bits (inst2, 0, 3));
	  length = 2 * get_frame_memory_unsigned (frame, table + offset, 1);
	  nextpc = pc_val + length;
	}
      else if ((inst1 & 0xfff0) == 0xe8d0 && (inst2 & 0xfff0) == 0xf000)
	{
	  /* TBH.  */
	  CORE_ADDR table, offset, length;

	  table = get_frame_register_unsigned (frame, bits (inst1, 0, 3));
	  offset = 2 * get_frame_register_unsigned (frame, bits (inst2, 0, 3));
	  length = 2 * get_frame_memory_unsigned (frame, table + offset, 2);
	  nextpc = pc_val + length;
	}
a2313 11
  else if ((inst1 & 0xf500) == 0xb100)
    {
      /* CBNZ or CBZ.  */
      int imm = (bit (inst1, 9) << 6) + (bits (inst1, 3, 7) << 1);
      ULONGEST reg = get_frame_register_unsigned (frame, bits (inst1, 0, 2));

      if (bit (inst1, 11) && reg != 0)
	nextpc = pc_val + imm;
      else if (!bit (inst1, 11) && reg == 0)
	nextpc = pc_val + imm;
    }
@


1.287
log
@        * arm-tdep.c (displaced_write_reg): Replace call to abort by call
        to internal_error.
@
text
@d5243 1
a5243 1
arm_objfile_data_cleanup (struct objfile *objfile, void *arg)
d6035 1
a6035 1
    = register_objfile_data_with_cleanup (arm_objfile_data_cleanup);
@


1.286
log
@	* ui-file.h (ui_file_xstrdup): Mention that the length argument
	may be NULL.
	* ui-file.c (ui_file_xstrdup): Don't dereference LENGTH if it is
	NULL.
	* aix-thread.c (aix_thread_extra_thread_info): Pass NULL as length
	parameter to ui_file_xstrdup.
	* arm-tdep.c (_initialize_arm_tdep): Ditto.
	* infrun.c (print_target_wait_results): Ditto.
	* language.c (add_language): Ditto.
	* linespec.c (cplusplus_error): Ditto.
	* remote.c (escape_buffer): Ditto.
	* typeprint.c (type_to_string): Ditto.
	* utils.c (error_stream): Ditto.
	* varobj.c (value_get_print_value): Ditto.
	* xtensa-tdep.c (xtensa_verify_config): Replace `dummy' local with
	`length' local.  Pass it to ui_file_xstrdup, and avoid an strlen
	call.
	* gdbarch.sh (verify_gdbarch): Ditto.
	* gdbarch.c: Regenerate.
	* cli/cli-setshow.c (do_setshow_command): Pass NULL as length
	parameter to ui_file_xstrdup.
	* python/python-frame.c (frapy_str): Ditto.
	* python/python-type.c (typy_str): Use the length local instead of
	calling strlen.
	* python/python-value.c (valpy_str): Pass NULL as length parameter
	to ui_file_xstrdup.
@
text
@d2772 2
a2773 1
	  abort ();
@


1.285
log
@	* arm-linux-tdep.c (arch-utils.h, inferior.h, gdbthread.h, symfile.h):
	Include files.
	(arm_linux_cleanup_svc, arm_linux_copy_svc): New.
	(cleanup_kernel_helper_return, arm_catch_kernel_helper_return): New.
	(arm_linux_displaced_step_copy_insn): New.
	(arm_linux_init_abi): Initialise displaced stepping callbacks.
	* arm-tdep.c (DISPLACED_STEPPING_ARCH_VERSION): New macro.
	(ARM_NOP): New.
	(displaced_read_reg, displaced_in_arm_mode, branch_write_pc)
	(bx_write_pc, load_write_pc, alu_write_pc, displaced_write_reg)
	(insn_references_pc, copy_unmodified, cleanup_preload, copy_preload)
	(copy_preload_reg, cleanup_copro_load_store, copy_copro_load_store)
	(cleanup_branch, copy_b_bl_blx, copy_bx_blx_reg, cleanup_alu_imm)
	(copy_alu_imm, cleanup_alu_reg, copy_alu_reg)
	(cleanup_alu_shifted_reg, copy_alu_shifted_reg, cleanup_load)
	(cleanup_store, copy_extra_ld_st, copy_ldr_str_ldrb_strb)
	(cleanup_block_load_all, cleanup_block_store_pc)
	(cleanup_block_load_pc, copy_block_xfer, cleanup_svc, copy_svc)
	(copy_undef, copy_unpred): New.
	(decode_misc_memhint_neon, decode_unconditional)
	(decode_miscellaneous, decode_dp_misc, decode_ld_st_word_ubyte)
	(decode_media, decode_b_bl_ldmstm, decode_ext_reg_ld_st)
	(decode_svc_copro, arm_process_displaced_insn)
	(arm_displaced_init_closure, arm_displaced_step_copy_insn)
	(arm_displaced_step_fixup): New.
	(arm_gdbarch_init): Initialise max insn length field.
	* arm-tdep.h (DISPLACED_TEMPS, DISPLACED_MODIFIED_INSNS): New
	macros.
	(displaced_step_closure, pc_write_style): New.
	(arm_displaced_init_closure, displaced_read_reg)
	(arm_process_displaced_insn, arm_displaced_init_closure)
	(displaced_read_reg, displaced_write_reg, arm_displaced_step_copy_insn)
	(arm_displaced_step_fixup): Add prototypes.
@
text
@d6084 1
a6084 1
  helptext = ui_file_xstrdup (stb, &length);
@


1.284
log
@	* NEWS: Mention ARM VFP support.
	* target-descriptions.c (tdesc_register_type): Make public.
	(tdesc_unnumbered_register): New function.
	(tdesc_register_reggroup_p): Allow missing
	pseudo_register_reggroup_p.
	* target-descriptions.h (tdesc_register_type): Declare.
	(tdesc_unnumbered_register): Declare.
	* arm-tdep.c (arm_neon_quad_read, arm_neon_quad_write): New functions.
	(arm_push_dummy_call): Use arm_neon_quad_write.
	(arm_neon_double_type, arm_neon_quad_type): New functions.
	(arm_register_type): Handle VFP and NEON registers.  Override the
	types of double-precision registers for NEON.  Disable FPA registers
	if they are not present.
	(arm_dwarf_reg_to_regnum): Add current VFP and NEON register numbers.
	(arm_return_value): Use arm_neon_quad_write and arm_neon_quad_read.
	(arm_register_name): Handle VFP single and NEON quad registers.
	(arm_pseudo_read, arm_pseudo_write): New functions.
	(arm_gdbarch_init): Check for VFP and NEON in the target description.
	Assign numbers to double-precision registers.  Register VFP and NEON
	pseudo registers.  Remove a shadowed "i" variable.
	* arm-tdep.h (enum gdb_regnum): Add ARM_D0_REGNUM and
	ARM_D31_REGNUM.
	(struct gdbarch_tdep): Add have_neon_pseudos, have_neon,
	have_vfp_registers, have_vfp_pseudos, neon_double_type,
	and neon_quad_type.

	* features/Makefile: Make expedite settings only architecture
	specific.
	(WHICH): Add new ARM descriptions.
	* features/arm-with-neon.xml, features/arm-with-vfpv2.c,
	features/arm-with-vfpv3.c, features/arm-vfpv2.xml,
	features/arm-vfpv3.xml, features/arm-with-vfpv2.xml,
	features/arm-with-vfpv3.xml, features/arm-with-neon.c: New files.
	* regformats/arm-with-neon.dat, regformats/arm-with-vfpv2.dat,
	regformats/arm-with-vfpv3.dat: Generate.

	doc/
	* gdb.texinfo (ARM Features): Document org.gnu.gdb.arm.vfp and
	org.gnu.gdb.arm.neon.

	gdbserver/
	* linux-low.c (linux_write_memory): Update debugging output.
	* Makefile.in (clean): Add new descriptions.
	(arm-with-vfpv2.o, arm-with-vfpv2.c, arm-with-vfpv3.o)
	(arm-with-vfpv3.c, arm-with-neon.o, arm-with-neon.c): New rules.
	* configure.srv: Add new files for arm*-*-linux*.
	* linux-arm-low.c: Add new declarations.
	(PTRACE_GETVFPREGS, PTRACE_SETVFPREGS): Define if undefined.
	(arm_hwcap, HWCAP_VFP, HWCAP_IWMMXT, HWCAP_NEON, HWCAP_VFPv3)
	(HWCAP_VFPv3D16): New.
	(arm_fill_wmmxregset, arm_store_wmmxregset): Check HWCAP_IWMMXT
	instead of __IWMMXT__.
	(arm_fill_vfpregset, arm_store_vfpregset, arm_get_hwcap)
	(arm_arch_setup): New.
	(target_regsets): Remove #ifdef.  Add VFP regset.
	(the_low_target): Use arm_arch_setup.

	testsuite/
	* gdb.base/float.exp: Handle VFP registers.
@
text
@d238 5
d2608 50
a2657 2
#include "bfd-in2.h"
#include "libcoff.h"
d2660 1
a2660 1
gdb_print_insn_arm (bfd_vma memaddr, disassemble_info *info)
d2662 1
a2662 7
  if (arm_pc_is_thumb (memaddr))
    {
      static asymbol *asym;
      static combined_entry_type ce;
      static struct coff_symbol_struct csym;
      static struct bfd fake_bfd;
      static bfd_target fake_target;
d2664 1
a2664 7
      if (csym.native == NULL)
	{
	  /* Create a fake symbol vector containing a Thumb symbol.
	     This is solely so that the code in print_insn_little_arm() 
	     and print_insn_big_arm() in opcodes/arm-dis.c will detect
	     the presence of a Thumb symbol and switch to decoding
	     Thumb instructions.  */
d2666 2
a2667 8
	  fake_target.flavour = bfd_target_coff_flavour;
	  fake_bfd.xvec = &fake_target;
	  ce.u.syment.n_sclass = C_THUMBEXTFUNC;
	  csym.native = &ce;
	  csym.symbol.the_bfd = &fake_bfd;
	  csym.symbol.name = "fake";
	  asym = (asymbol *) & csym;
	}
d2669 1
a2669 5
      memaddr = UNMAKE_THUMB_ADDR (memaddr);
      info->symbols = &asym;
    }
  else
    info->symbols = NULL;
d2671 7
a2677 2
  if (info->endian == BFD_ENDIAN_BIG)
    return print_insn_big_arm (memaddr, info);
d2679 1
a2679 1
    return print_insn_little_arm (memaddr, info);
d2682 1
a2682 33
/* The following define instruction sequences that will cause ARM
   cpu's to take an undefined instruction trap.  These are used to
   signal a breakpoint to GDB.
   
   The newer ARMv4T cpu's are capable of operating in ARM or Thumb
   modes.  A different instruction is required for each mode.  The ARM
   cpu's can also be big or little endian.  Thus four different
   instructions are needed to support all cases.
   
   Note: ARMv4 defines several new instructions that will take the
   undefined instruction trap.  ARM7TDMI is nominally ARMv4T, but does
   not in fact add the new instructions.  The new undefined
   instructions in ARMv4 are all instructions that had no defined
   behaviour in earlier chips.  There is no guarantee that they will
   raise an exception, but may be treated as NOP's.  In practice, it
   may only safe to rely on instructions matching:
   
   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 
   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
   C C C C 0 1 1 x x x x x x x x x x x x x x x x x x x x 1 x x x x
   
   Even this may only true if the condition predicate is true. The
   following use a condition predicate of ALWAYS so it is always TRUE.
   
   There are other ways of forcing a breakpoint.  GNU/Linux, RISC iX,
   and NetBSD all use a software interrupt rather than an undefined
   instruction to force a trap.  This can be handled by by the
   abi-specific code during establishment of the gdbarch vector.  */

#define ARM_LE_BREAKPOINT {0xFE,0xDE,0xFF,0xE7}
#define ARM_BE_BREAKPOINT {0xE7,0xFF,0xDE,0xFE}
#define THUMB_LE_BREAKPOINT {0xbe,0xbe}
#define THUMB_BE_BREAKPOINT {0xbe,0xbe}
d2684 4
a2687 4
static const char arm_default_arm_le_breakpoint[] = ARM_LE_BREAKPOINT;
static const char arm_default_arm_be_breakpoint[] = ARM_BE_BREAKPOINT;
static const char arm_default_thumb_le_breakpoint[] = THUMB_LE_BREAKPOINT;
static const char arm_default_thumb_be_breakpoint[] = THUMB_BE_BREAKPOINT;
d2689 1
a2689 7
/* Determine the type and size of breakpoint to insert at PCPTR.  Uses
   the program counter value to determine whether a 16-bit or 32-bit
   breakpoint should be used.  It returns a pointer to a string of
   bytes that encode a breakpoint instruction, stores the length of
   the string to *lenptr, and adjusts the program counter (if
   necessary) to point to the actual memory location where the
   breakpoint should be inserted.  */
d2691 6
a2696 6
static const unsigned char *
arm_breakpoint_from_pc (struct gdbarch *gdbarch, CORE_ADDR *pcptr, int *lenptr)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (arm_pc_is_thumb (*pcptr))
d2698 3
a2700 3
      *pcptr = UNMAKE_THUMB_ADDR (*pcptr);
      *lenptr = tdep->thumb_breakpoint_size;
      return tdep->thumb_breakpoint;
d2704 6
a2709 2
      *lenptr = tdep->arm_breakpoint_size;
      return tdep->arm_breakpoint;
d2713 12
a2724 3
/* Extract from an array REGBUF containing the (raw) register state a
   function return value of type TYPE, and copy that, in virtual
   format, into VALBUF.  */
d2727 1
a2727 2
arm_extract_return_value (struct type *type, struct regcache *regs,
			  gdb_byte *valbuf)
d2729 9
a2737 2
  struct gdbarch *gdbarch = get_regcache_arch (regs);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
d2739 5
a2743 1
  if (TYPE_CODE_FLT == TYPE_CODE (type))
d2745 4
a2748 1
      switch (gdbarch_tdep (gdbarch)->fp_model)
d2750 2
a2751 11
	case ARM_FLOAT_FPA:
	  {
	    /* The value is in register F0 in internal format.  We need to
	       extract the raw value and then convert it to the desired
	       internal type.  */
	    bfd_byte tmpbuf[FP_REGISTER_SIZE];

	    regcache_cooked_read (regs, ARM_F0_REGNUM, tmpbuf);
	    convert_from_extended (floatformat_from_type (type), tmpbuf,
				   valbuf, gdbarch_byte_order (gdbarch));
	  }
d2754 15
a2768 9
	case ARM_FLOAT_SOFT_FPA:
	case ARM_FLOAT_SOFT_VFP:
	  /* ARM_FLOAT_VFP can arise if this is a variadic function so
	     not using the VFP ABI code.  */
	case ARM_FLOAT_VFP:
	  regcache_cooked_read (regs, ARM_A1_REGNUM, valbuf);
	  if (TYPE_LENGTH (type) > 4)
	    regcache_cooked_read (regs, ARM_A1_REGNUM + 1,
				  valbuf + INT_REGISTER_SIZE);
d2772 1
a2772 4
	  internal_error
	    (__FILE__, __LINE__,
	     _("arm_extract_return_value: Floating point model not supported"));
	  break;
a2773 13
    }
  else if (TYPE_CODE (type) == TYPE_CODE_INT
	   || TYPE_CODE (type) == TYPE_CODE_CHAR
	   || TYPE_CODE (type) == TYPE_CODE_BOOL
	   || TYPE_CODE (type) == TYPE_CODE_PTR
	   || TYPE_CODE (type) == TYPE_CODE_REF
	   || TYPE_CODE (type) == TYPE_CODE_ENUM)
    {
      /* If the the type is a plain integer, then the access is
	 straight-forward.  Otherwise we have to play around a bit more.  */
      int len = TYPE_LENGTH (type);
      int regno = ARM_A1_REGNUM;
      ULONGEST tmp;
d2775 1
a2775 12
      while (len > 0)
	{
	  /* By using store_unsigned_integer we avoid having to do
	     anything special for small big-endian values.  */
	  regcache_cooked_read_unsigned (regs, regno++, &tmp);
	  store_unsigned_integer (valbuf, 
				  (len > INT_REGISTER_SIZE
				   ? INT_REGISTER_SIZE : len),
				  byte_order, tmp);
	  len -= INT_REGISTER_SIZE;
	  valbuf += INT_REGISTER_SIZE;
	}
d2779 4
a2782 15
      /* For a structure or union the behaviour is as if the value had
         been stored to word-aligned memory and then loaded into 
         registers with 32-bit load instruction(s).  */
      int len = TYPE_LENGTH (type);
      int regno = ARM_A1_REGNUM;
      bfd_byte tmpbuf[INT_REGISTER_SIZE];

      while (len > 0)
	{
	  regcache_cooked_read (regs, regno++, tmpbuf);
	  memcpy (valbuf, tmpbuf,
		  len > INT_REGISTER_SIZE ? INT_REGISTER_SIZE : len);
	  len -= INT_REGISTER_SIZE;
	  valbuf += INT_REGISTER_SIZE;
	}
d2786 5
a2790 4

/* Will a function return an aggregate type in memory or in a
   register?  Return 0 if an aggregate type can be returned in a
   register, 1 if it must be returned in memory.  */
d2793 1
a2793 1
arm_return_in_memory (struct gdbarch *gdbarch, struct type *type)
d2795 5
a2799 2
  int nRc;
  enum type_code code;
d2801 2
a2802 1
  CHECK_TYPEDEF (type);
d2804 2
a2805 6
  /* In the ARM ABI, "integer" like aggregate types are returned in
     registers.  For an aggregate type to be integer like, its size
     must be less than or equal to INT_REGISTER_SIZE and the
     offset of each addressable subfield must be zero.  Note that bit
     fields are not addressable, and all addressable subfields of
     unions always start at offset zero.
d2807 1
a2807 2
     This function is based on the behaviour of GCC 2.95.1.
     See: gcc/arm.c: arm_return_in_memory() for details.
d2809 2
a2810 6
     Note: All versions of GCC before GCC 2.95.2 do not set up the
     parameters correctly for a function returning the following
     structure: struct { float f;}; This should be returned in memory,
     not a register.  Richard Earnshaw sent me a patch, but I do not
     know of any way to detect if a function like the above has been
     compiled with the correct calling convention.  */
d2812 1
a2812 5
  /* All aggregate types that won't fit in a register must be returned
     in memory.  */
  if (TYPE_LENGTH (type) > INT_REGISTER_SIZE)
    {
      return 1;
d2815 5
a2819 4
  /* The AAPCS says all aggregates not larger than a word are returned
     in a register.  */
  if (gdbarch_tdep (gdbarch)->arm_abi != ARM_ABI_APCS)
    return 0;
d2821 8
a2828 7
  /* The only aggregate types that can be returned in a register are
     structs and unions.  Arrays must be returned in memory.  */
  code = TYPE_CODE (type);
  if ((TYPE_CODE_STRUCT != code) && (TYPE_CODE_UNION != code))
    {
      return 1;
    }
d2830 1
a2830 3
  /* Assume all other aggregate types can be returned in a register.
     Run a check for structures, unions and arrays.  */
  nRc = 0;
d2832 2
a2833 10
  if ((TYPE_CODE_STRUCT == code) || (TYPE_CODE_UNION == code))
    {
      int i;
      /* Need to check if this struct/union is "integer" like.  For
         this to be true, its size must be less than or equal to
         INT_REGISTER_SIZE and the offset of each addressable
         subfield must be zero.  Note that bit fields are not
         addressable, and unions always start at offset zero.  If any
         of the subfields is a floating point type, the struct/union
         cannot be an integer type.  */
d2835 1894
a4728 6
      /* For each field in the object, check:
         1) Is it FP? --> yes, nRc = 1;
         2) Is it addressable (bitpos != 0) and
         not packed (bitsize == 0)?
         --> yes, nRc = 1  
       */
d5852 5
@


1.283
log
@	* arm-tdep.c (enum arm_vfp_cprc_base_type,
	arm_vfp_cprc_unit_length, arm_vfp_cprc_reg_char,
	arm_vfp_cprc_sub_candidate, arm_vfp_call_candidate,
	arm_vfp_abi_for_function): New.
	(arm_push_dummy_call): Handle VFP ABI.
	(arm_extract_return_value, arm_store_return_value): Handle
	ARM_FLOAT_VFP case.
	(arm_return_value): Handle VFP ABI.
	(arm_gdbarch_init): Default fp_model based on Tag_ABI_VFP_args for
	EABI binaries.
@
text
@d211 7
d1719 2
a1720 4
		  sprintf (name_buf, "%c%d", reg_char, reg_scaled + i);
		  regnum = user_reg_map_name_to_regnum (gdbarch, name_buf,
							strlen (name_buf));
		  regcache_cooked_write (regcache, regnum,
d1722 8
d1890 71
d1967 25
d1993 6
a1998 1
    return arm_ext_type (gdbarch);
d2042 28
d3019 25
a3043 11
	  char name_buf[4];
	  int regnum;
	  sprintf (name_buf, "%c%d", reg_char, i);
	  regnum = user_reg_map_name_to_regnum (gdbarch, name_buf,
						strlen (name_buf));
	  if (writebuf)
	    regcache_cooked_write (regcache, regnum,
				   writebuf + i * unit_length);
	  if (readbuf)
	    regcache_cooked_read (regcache, regnum,
				  readbuf + i * unit_length);
d3300 26
d3463 134
d3641 2
d3655 1
a3655 1
      int i, valid_p;
d3737 61
d3941 5
d3965 4
d4108 14
d4123 9
a4131 1
    tdesc_use_registers (gdbarch, info.target_desc, tdesc_data);
@


1.282
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d1376 216
a1591 2
/* We currently only support passing parameters in integer registers.  This
   conforms with GCC's default model.  Several other variants exist and
d1605 10
d1649 3
d1675 53
d1736 2
a1737 1
      if (argreg <= ARM_LAST_ARG_REGNUM
d1765 1
a1765 1
	  if (argreg <= ARM_LAST_ARG_REGNUM)
d2599 3
d2788 3
d2866 25
d3466 4
a3469 1
		  /* EABI binaries default to VFP float ordering.  */
d3471 34
a3504 1
		    fp_model = ARM_FLOAT_SOFT_VFP;
@


1.281
log
@	* defs.h (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter.
	* utils.c (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter, use it instead of current_gdbarch.
	* ui-out.h (ui_out_field_core_addr): Add GDBARCH parameter.
	* ui-out.c (ui_out_field_core_addr): Add GDBARCH parameter,
	use it instead of current_gdbarch.

	Update calls to ui_out_field_core_addr to pass architecture:
	* ada-lang.c (print_one_exception): Update.
	* breakpoint.c (print_one_breakpoint_location,
	print_one_exception_catchpoint): Update.
	* disasm.c (dump_insns): Update.
	* darwin-nat-info.c (darwin_debug_regions_recurse): Update.
	* mi/mi-main.c (mi_cmd_data_read_memory): Update.
	* mi/mi-symbol-cmds.c: Include "objfiles.h".
	(mi_cmd_symbol_list_lines): Update.
	* stack.c (print_frame_info, print_frame): Update.

	Update callers of paddress to pass architecture:
	* ada-tasks.c (info_task): Update.
	* ada-valprint.c (ada_val_print_1): Update.
	* annotate.c (annotate_source, annotate_frame_begin): Update.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints,
	mention): Update.
	* cli/cli-cmds.c (edit_command, list_command, print_disassembly):
	Update.
	* corefile.c (memory_error): Update.
	* c-valprint.c (print_function_pointer_address, c_val_print): Update.
	* disasm.c (dis_asm_print_address): Update.
	* exec.c (print_section_info): Update.
	* f-valprint.c (f_val_print): Update.
	* infcmd.c: Include "arch-utils.h".
	(jump_command, program_info): Update.
	* linux-fork.c: Include "arch-utils.h".
	(info_forks_command): Update.
	* m2-valprint.c (print_function_pointer_address,
	print_unpacked_pointer, print_variable_at_address,
	m2_val_print): Update.
	* m32r-rom.c (m32r_load_section, m32r_load, m32r_upload_command):
	Update.
	* printcmd.c (print_address, print_address_demangle, address_info):
	Update.
	* p-valprint.c (pascal_val_print): Update.
	* source.c: Include "arch-utils.h".
	(line_info): Update.
	* stack.c (frame_info, print_block_frame_labels): Update.
	* symfile.c (add_symbol_file_command, list_overlays_command): Update.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1,
	print_symbol, print_partial_symbols, maintenance_info_psymtabs,
	maintenance_check_symtabs): Update.
	* symtab.c (find_pc_sect_symtab): Update.
	* target.c (deprecated_debug_xfer_memory): Update.
	* tracepoint.c (scope_info): Update.
	* tui/tui-stack.c (tui_make_status_line): Update.
	* valprint.c (val_print_string): Update.

	Update callers of paddr_nz to use paddress instead (keeping
	user-visible output identical):
	* alpha-tdep.c (alpha_heuristic_proc_start): Update.
	* amd64-tdep.c (fixup_riprel, amd64_displaced_step_copy_insn,
	amd64_displaced_step_fixup): Update.
	* arch-utils.c (simple_displaced_step_copy_insn): Update.
	* auxv.c (fprint_target_auxv): Update.
	* breakpoint.c (insert_single_step_breakpoint): Update.
	* buildsym.c (finish_block): Update.
	* cli/cli-dump.c (restore_section_callback): Update.
	* fbsd-nat.c (fbsd_find_memory_regions): Update.
	* frame.c (frame_unwind_register_value): Update.
	* gcore.c (gcore_create_callback): Update.
	* hppa-tdep.c (hppa_frame_cache, hppa_skip_trampoline_code): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_record_modrm,
	i386_record_lea_modrm_addr, i386_record_lea_modrm,
	i386_process_record): Update.
	* ia64-tdep.c (ia64_frame_this_id, ia64_sigtramp_frame_this_id,
	ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id,
	ia64_dummy_id, ia64_access_reg, ia64_access_rse_reg): Update.
	* infrun.c (displaced_step_prepare, displaced_step_fixup,
	handle_inferior_event, insert_step_resume_breakpoint_at_sal,
	insert_longjmp_resume_breakpoint): Update.
	* linux-nat.c (linux_nat_find_memory_regions): Update.
	* linux-record.c (record_linux_system_call): Update.
	* mips-tdep.c (heuristic_proc_start, mips_eabi_push_dummy_call,
	mips_n32n64_push_dummy_call, mips_o32_push_dummy_call,
	mips_o64_push_dummy_call): Update.
	* monitor.c (monitor_error, monitor_remove_breakpoint): Update.
	* record.c (record_arch_list_add_mem, record_wait,
	record_xfer_partial): Update.
	* remote-mips.c (mips_fetch_word, mips_check_lsi_error,
	mips_common_breakpoint): Update.
	* remote-sim.c (gdbsim_xfer_inferior_memory): Update.
	* rs6000-tdep.c (ppc_displaced_step_fixup): Update.
	* solib-som.c (som_current_sos): Update.
	* symfile.c (load_progress, generic_load): Update.
	* symfile-mem.c (add_vsyscall_page): Update.
	* valops.c (value_fetch_lazy): Update.
	* windows-tdep.c (windows_xfer_shared_library): Update.

	Update callers of paddr_nz to use paddress instead (changing
	user-visible output to make it more correct):
	* dwarf2loc.c (locexpr_describe_location): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint,
	ia64_memory_remove_breakpoint): Update.
	* jv-valprint.c (java_value_print): Update.
	* m32c-tdep.c (m32c_m16c_address_to_pointer): Update.
	* monitor.c (monitor_read_memory): Update.

	Update callers of paddr to use paddress instead (changing
	user-visible output to make it more correct):
	* arm-tdep.c (arm_push_dummy_call): Update.
	* breakpoint.c (insert_bp_location, create_thread_event_breakpoint,
	create_breakpoint): Update.
	* darwin-nat-info.c (darwin_debug_regions): Update.
	* dcache.c (dcache_info): Update.
	* dsrec.c (load_srec, make_srec): Update.
	* dwarf2-frame.c (dwarf2_restore_rule, execute_cfa_program,
	dwarf2_frame_cache): Update.
	* gcore.c (gcore_copy_callback): Update.
	* gnu-nat.c (gnu_xfer_memory): Update.
	* mips-linux-nat.c (mips_show_dr): Update.
	* monitor.c (monitor_write_memory, monitor_insert_breakpoint,
	monitor_remove_breakpoint): Update.
	* remote.c (compare_sections_command): Update.
	* remote-m32r-sdi.c (m32r_xfer_memory, m32r_insert_breakpoint,
	m32r_remove_breakpoint, m32r_insert_watchpoint,
	m32r_remove_watchpoint): Update.
	* sol-thread.c (info_cb): Update.
	* symfile.c (load_progress): Update.

	Update callers of paddress or paddr_nz to use hex_string instead
	(changes output of internal/error/debug messages only):
	* dwarf2read.c (dump_die_shallow): Update.
	* frame.c (fprint_field, fprint_frame, frame_pc_unwind,
	get_frame_func, create_new_frame): Update.
	* hppa-tdep.c (find_unwind_entry, unwind_command): Update.
	* ia64-tdep.c (get_kernel_table, ia64_find_proc_info_x,
	ia64_get_dyn_info_list): Update.
	* maint.c (maintenance_translate_address): Update.
	* mi/mi-cmd-var.c (mi_cmd_var_create): Update.
	* target.c (target_flash_erase): Update.

	Update callers of paddr/paddr_nz to use phex/phex_nz instead,
	using an appropriate address size.  Remove use of strlen_paddr.
	* exec.c (exec_files_info): Update.
	* i386-nat.c (i386_show_dr): Update.
	* remote.c (remote_flash_erase): Update.
	* m32r-rom.c (m32r_load_section): Update.
	* monitor.c (monitor_vsprintf, monitor_store_register): Update.
	* remote.c (remote_check_symbols, remote_search_memory): Update.
	* remote-mips.c (mips_request, mips_common_breakpoint): Update.
	* scm-valprint.c (scm_ipruk, scm_scmval_print): Update.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Update.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs,
	sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs,
	sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs,
	sh_dsp_show_regs): Update.
	* xcoffsolib.c (sharedlibrary_command): Update.


	* maint.c (maint_print_section_info): Add ADDR_SIZE parameter.
	Use hex_string_custom instead of paddr.
	(print_bfd_section_info): Pass address size.
	(print_objfile_section_info): Likewise.

	* annotate.h (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* annotate.c (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* source.c (identify_source_line): Update call to annotate_source.
	* stack.c (print_frame_info, print_frame): Update call to
	annotate_frame_begin.

	* breakpoint.c (describe_other_breakpoints): Add GDBARCH parameter.
	(create_breakpoint, create_ada_exception_breakpoint): Update call.

	* stack.c (print_block_frame_labels): Add GDBARCH parameter.
	(print_frame_label_vars): Update call.

	* symmisc.c (print_partial_symbols): Add GDBARCH parameter.
	(dump_psymtab): Update call to print_partial_symbols.
	(struct print_symbol_args): Add GDBARCH member.
	(dump_symtab_1): Set print_symbol_args architecture member.
	(print_symbol): Use it.

	* windows-tdep.h (windows_xfer_shared_library): Add GDBARCH
	parameter.
	* windows-tdep.c (windows_xfer_shared_library): Likewise.
	* i386-cygwin-tdep.c (struct cpms_data): Add GDBARCH member.
	(core_process_module_section): Pass architecture from cpms_data to
	windows_xfer_shared_library.
	(windows_core_xfer_shared_libraries): Initialize cmps_data
	architecture member.
	* windows-nat.c (windows_xfer_shared_libraries): Pass architecture
	to windows_xfer_shared_library.

	* defs.h (print_address): Add GDBARCH parameter.
	* printcmd.c (print_address): Add GDBARCH parameter.
	(print_scalar_formatted, do_examine): Update call.
	* findcmd.c (find_command): Update call.
	* tracepoint.c: Include "arch-utils.h".
	(trace_find_line_command): Update call.
	* tui/tui-disasm.c (tui_disassemble): Update call.

	* value.h (print_address_demangle): Add GDBARCH parameter.
	* printcmd.c (print_address_demangle): Add GDBARCH parameter.
	* c-valprint.c (print_function_pointer_address, c_val_print):
	Update call.
	* f-valprint.c (f_val_print): Update call.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update call.
	* jv-valprint.c (java_val_print): Update call.
	* m2-valprint.c (print_function_pointer_address, m2_val_print):
	Update call.
	* p-valprint.c (pascal_val_print): Update call.

	* disasm.c (gdb_disassemble_info): Install architecture into
	di.application_data field.

testsuite/ChangeLog:

	* gdb.threads/tls-shared.exp: Update to locexpr_describe_location
	change to prefix TLS offset in hex with 0x.

doc/ChangeLog:

	* gdbint.texinfo (Item Output Functions): Update signature
	for ui_out_field_core_addr.
@
text
@a70 13
/* Macros for swapping shorts and ints. In the unlikely case that anybody else needs these,
   move to a general header. (A better solution might be to define memory read routines that
   know whether they are reading code or data.)  */

#define SWAP_SHORT(x) \
  ((((x) & 0xff00) >> 8) | (((x) & 0x00ff) << 8));

#define SWAP_INT(x) \
  (  ((x & 0xff000000) >> 24) \
   | ((x & 0x00ff0000) >> 8)  \
   | ((x & 0x0000ff00) << 8)  \
   | ((x & 0x000000ff) << 24))

d377 1
d393 1
a393 4
      insn = read_memory_unsigned_integer (start, 2);

      if (gdbarch_byte_order_for_code (gdbarch) != gdbarch_byte_order (gdbarch))
	insn = SWAP_SHORT (insn);
d521 1
d560 1
a560 4
      inst = read_memory_unsigned_integer (skip_pc, 4);

      if (gdbarch_byte_order_for_code (gdbarch) != gdbarch_byte_order (gdbarch))
	inst = SWAP_INT (inst);
d740 2
d815 1
a815 1
      if (!safe_read_memory_integer (frame_loc, 4, &return_value))
d858 2
a859 4
      unsigned int insn = read_memory_unsigned_integer (current_pc, 4);

      if (gdbarch_byte_order_for_code (gdbarch) != gdbarch_byte_order (gdbarch))
	insn = SWAP_INT (insn);
d1386 1
d1468 1
a1468 1
	  CORE_ADDR regval = extract_unsigned_integer (val, len);
d1472 2
a1473 1
	      store_unsigned_integer (val, len, MAKE_THUMB_ADDR (regval));
d1488 3
a1490 2
	      CORE_ADDR regval = extract_unsigned_integer (val, partial_len);
	      if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
d1832 2
d1835 1
a1835 1
  unsigned short inst1 = read_memory_unsigned_integer (pc, 2);
d1839 1
a1839 2
  if (gdbarch_byte_order_for_code (gdbarch) != gdbarch_byte_order (gdbarch))
    inst1 = SWAP_SHORT (inst1);
d1849 1
a1849 1
      nextpc = (CORE_ADDR) read_memory_unsigned_integer (sp + offset, 4);
d1867 2
a1868 3
      unsigned short inst2 = read_memory_unsigned_integer (pc + 2, 2);
      if (gdbarch_byte_order_for_code (gdbarch) != gdbarch_byte_order (gdbarch))
	inst2 = SWAP_SHORT (inst2);
d1894 2
d1905 1
a1905 4
  this_instr = read_memory_unsigned_integer (pc, 4);

  if (gdbarch_byte_order_for_code (gdbarch) != gdbarch_byte_order (gdbarch))
    this_instr = SWAP_INT (this_instr);
d2086 1
a2086 1
							    4);
d2124 1
a2124 1
						       4);
d2297 1
d2352 1
a2352 1
				  tmp);
d2487 1
d2531 1
a2531 1
	  store_signed_integer (tmpbuf, INT_REGISTER_SIZE, val);
d2602 3
a2606 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (frame));
d2614 1
a2614 1
  *pc = extract_unsigned_integer (buf, INT_REGISTER_SIZE);
@


1.280
log
@	* breakpoint.h (struct breakpoint): New member GDBARCH.
	* breakpoint.c: Include "arch-utils.h".
	(set_raw_breakpoint_without_location): Add GDBARCH parameter.
	Use it to set breakpoint architecture.
	(set_raw_breakpoint): Add GDBARCH parameter.
	(create_internal_breakpoint): Likewise.
	(create_catchpoint): Likewise.
	(create_fork_vfork_event_catchpoint): Likewise.
	(create_breakpoint): Likewise.
	(create_breakpoints): Likewise.
	(break_command_really): Likewise.
	(create_ada_exception_breakpoint): Likewise.
	Update local callers to pass architecture:
	(create_internal_breakpoint): Update.
	(create_overlay_event_breakpoint): Update.
	(create_longjmp_master_breakpoint): Update.
	(create_thread_event_breakpoint): Update.
	(create_solib_event_breakpoint): Update.
	(create_catchpoint): Update.
	(create_fork_vfork_event_catchpoint): Update.
	(set_momentary_breakpoint): Update.
	(clone_momentary_breakpoint): Update.
	(create_breakpoint): Update.
	(create_breakpoints): Update.
	(break_command_really): Update.
	(break_command_1): Update.
	(set_breakpoint): Update.
	(watch_command_1): Update.
	(catch_fork_command_1): Update.
	(catch_exec_commnd_1): Update.
	(handle_gnu_v3_exceptions): Update.
	(create_ada_exception_breakpoint): Update.
	(catch_ada_exception_command): Update.
	(catch_assert_command): Update.
	(trace_command): Update.

	* breakpoint.h (struct bp_location): New member GDBARCH.
	* breakpoint.c (get_sal_arch): New function.
	(set_raw_breakpoint): Set location architecture.
	(add_location_to_breakpoint): Likewise.
	(clone_momentary_breakpoint): Likewise.
	(watch_command_1): Likewise.
	(update_watchpoint): Likewise.
	(bp_loc_is_permanent): Use location architecture instead of
	current_gdbarch.
	(adjust_breakpoint_address): Add GDBARCH parameter; use it
	instead of current_gdbarch.
	Update callers of adjust_breakpoint_address to pass
	breakpoint location architecture:
	(set_raw_breakpoint): Update.
	(watch_command_1): Update.

        * tracepoint.c: (collect_symbol): Add GDBARCH parameter, use instead
	of current_gdbarch.
	(add_local_symbols): Add GDBARCH parameter.  Pass to collect_symbol.
	(encode_actions): Pass tracepoint architecture to add_local_symbols
	(encode_actions): Use tracepoint architecture instead of
	current_gdbarch.  Pass it to add_local_symbols and collect_symbol.

	* breakpoint.h (struct breakpoint_ops): Replace last_addr parameter
	of print_one callback with last_loc.
	* breakpoint.c (print_one_breakpoint_location): Replace last_addr
	parameter with last_loc.
	(print_one_breakpoint): Likewise.
	(do_captured_breakpoint_query): Update call.
	(breakpoint_1): Pass last_loc instead of last_addr to
	print_one_breakpoint.  Pass last location architecture instead of
	current_gdbarch to set_next_address.
	Update all implementations of the print_one callback:
	* breakpoint.c (print_one_catch_fork): Update.
	(print_one_catch_vfork): Update.
	(print_one_catch_exec): Update.
	(print_one_exception_catchpoint): Update.
	* ada-lang.c (print_one_exception): Update.
	(print_one_catch_exception): Update.
	(print_one_catch_exception_unhandled): Update.
	(print_one_catch_assert): Update.

	* breakpoint.c (print_one_breakpoint_location): Add PRINT_ADDRESS_BITS
	parameter.  Use it instead of gdbarch_addr_bit (current_gdbarch).
	(print_one_breakpoint): Add PRINT_ADDRESS_BITS parameter and pass it
	to print_one_breakpoint_location.
	(breakpoint_address_bits): New function.
	(do_captured_breakpoint_query): Compute number of address bits to print
	and pass it to print_one_breakpoint.
	(breakpoint_1): Likewise.  Use it instead of current_gdbarch.

	* breakpoint.h (create_thread_event_breakpoint): Add GDBARCH.
	* breakpoint.c (create_thread_event_breakpoint): Likewise.
	Update callers to create_thread_event_breakpoint:
	* aix-thread.c (pd_enable): Update.
	* linux-thread-db.c (enable_thread_event): Update.

	* breakpoint.h (create_solib_event_breakpoint): Add GDBARCH.
	* breakpoint.c (create_solib_event_breakpoint): Likewise.
	Update callers to create_solib_event_breakpoint:
	* solib-frv.c (enable_break, enable_break2): Update.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Update.
	* solib-som.c (som_solib_create_inferior_hook): Update.
	* solib-darwin.c (darwin_solib_create_inferior_hook): Update.
	* solib-svr4.c (enable_break): Update.

	* breakpoint.h (insert_single_step_breakpoint): Add GDBARCH.
	* breakpoint.c (insert_single_step_breakpoint): Likewise.
	Update callers to insert_single_step_breakpoint:
	* alpha-tdep.c (alpha_software_single_step): Update.
	* arm-linux-tdep.c (arm_linux_software_single_step): Update.
	* arm-tdep.c (arm_software_single_step): Update.
	* cris-tdep.c (cris_software_single_step): Update.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Update.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Update.
	* sparc-tdep.c (sparc_software_single_step): Update.
	* spu-tdep.c (spu_software_single_step): Update.
	* mips-tdep.c (deal_with_atomic_sequence): Add GDBARCH parameter.
	Pass it to insert_single_step_breakpoint.
	(mips_software_single_step): Pass architecture to
	deal_with_atomic_sequence and insert_single_step_breakpoint.

	* breakpoint.h (deprecated_insert_raw_breakpoint): Add GDBARCH.
	(deprecated_remove_raw_breakpoint): Likewise.
	* breakpoint.c (deprecated_insert_raw_breakpoint): Add GDBARCH.
	(deprecated_remove_raw_breakpoint): Likewise.
	Update callers to deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint:
	* breakpoint.c (single_step_gdbarch): New static variable.
	(insert_single_step_breakpoint): Pass GDBARCH parameter to
	deprecated_insert_raw_breakpoint.  Store it in single_step_gdbarch.
	(remove_single_step_breakpoints): Pass architecture stored in
	single_step_gdbarch to deprecated_remove_raw_breakpoint.
	* rs6000-nat.c (exec_one_dummy_insn): Update.
	* solib-irix.c (enable_break, disable_break): Update.
	* procfs.c (procfs_mourn_inferior): Update.
	(remove_dbx_link_breakpoint): Update.

	* breakpoint.h (set_breakpoint): Add GDBARCH parameter.
	(set_momentary_breakpoint, set_momentary_breakpoint_at_pc): Likewise.
	* breakpoint.c (set_breakpoint): Add GDBARCH parameter.
	(set_momentary_breakpoint, set_momentary_breakpoint_at_pc): Likewise.
	Update callers to set_breakpoint, set_momentary_breakpoint and
	set_momentary_breakpoint_at_pc:
	* breakpoint.c (set_momentary_breakpoint_at_pc): Update.
	(until_break_command): Update.
	* infcall.c (call_function_by_hand): Update.
	* infcmd.c (finish_backward, finish_forward): Update.
	* infrun.c (insert_step_resume_breakpoint_at_sal): Add GDBARCH
	parameter.  Pass it to set_momentary_breakpoint.
	(insert_longjmp_resume_breakpoint): Add GDBARCH parameter.
	Pass it to set_momentary_breakpoint_at_pc.
	(handle_inferior_event): Update.
	(insert_step_resume_breakpoint_at_frame): Update.
	(insert_step_resume_breakpoint_at_caller): Update..
	* mi/mi-cmd-break.c: Include "arch-utils.h".
	(mi_cmd_break_insert): Update.

	* target.h (struct target_ops): Add GDBARCH parameter to
	to_insert_breakpoint, to_remove_breakpoint, to_insert_hw_breakpoint,
	and to_remove_hw_breakpoint members.
	(target_insert_breakpoint, target_remove_breakpoint,
	target_insert_hw_breakpoint, target_remove_hw_breakpoint): Add GDBARCH
	parameter, pass to target routine.
	(memory_remove_breakpoint, memory_insert_breakpoint): Add GDBARCH
	parameter.
	* target.c (debug_to_insert_breakpoint, debug_to_remove_breakpoint,
	debug_to_insert_hw_breakpoint, debug_to_remove_hw_breakpoint): Add
	GDBARCH parameter, pass to target routine.
	(update_current_target): Update function signature.
	* breakpoint.c (insert_bp_location, remove_breakpoint,
	deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint):
	Pass architecture to target_ routines.
	Update all implementations of the target breakpoint routines to take
	GDBARCH parameter and use it instead of GDBARCH as appropriate:
	* corelow.c (ignore): Update.
	* exec.c (ignore): Update.
	* mem-break.c (memory_insert_breakpoint): Update.
	(memory_remove_breakpoint): Update.
	* monitor.c (monitor_insert_breakpoint): Update.
	(monitor_remove_breakpoint): Update.
	* record.c (record_insert_breakpoint): Update.
	(record_beneath_to_insert_breakpoint): Update.
	(record_remove_breakpoint): Update.
	(record_beneath_to_remove_breakpoint): Update.
	* remote.c (remote_insert_breakpoint): Update.
	(remote_remove_breakpoint): Update.
	(remote_insert_hw_breakpoint): Update.
	(remote_remove_hw_breakpoint): Update.
	* remote-m32r-sdi.c (m32r_insert_breakpoint): Update.
	(m32r_remove_breakpoint): Update.
	* remote-mips.c (mips_insert_breakpoint): Update.
	(mips_remove_breakpoint): Update.
	* i386-nat.c (i386_insert_hw_breakpoint): Update.
	(i386_remove_hw_breakpoint): Update.
	* nto-procfs.c (procfs_insert_breakpoint):  Update.
	(procfs_remove_breakpoint): Update.
	(procfs_insert_hw_breakpoint): Update.
	(procfs_remove_hw_breakpoint): Update.

doc/ChangeLog:

	* gdbint.texi (Examples of Use of @@code{ui_out} functions):
	Update example code extrated from breakpoint.c.
@
text
@d1426 1
a1426 1
	fprintf_unfiltered (gdb_stdlog, "struct return in %s = 0x%s\n",
d1428 1
a1428 1
			    paddr (struct_addr));
@


1.279
log
@	* gdbtypes.h (TYPE_OBJFILE_OWNED, TYPE_OWNER): New macros.
	(TYPE_OBJFILE, TYPE_ALLOC, TYPE_ZALLOC): Reimplement.
	(alloc_type_arch): Add prototype.
	(alloc_type_copy): Likewise.
	(get_type_arch): Likewise.
	(arch_type): Likewise.
	(arch_integer_type): Likewise.
	(arch_character_type): Likewise.
	(arch_boolean_type): Likewise.
	(init_float_type): Remove, replace by ...
	(arch_float_type): ... this.
	(init_complex_type): Remove, replace by ...
	(arch_complex_type): ... this.
	(init_flags_type): Remove, replace by ...
	(arch_flags_type): ... this.
	(init_composite_type): Remove, replace by ...
	(arch_composite_type): ... this.

	* gdbtypes.c (alloc_type): No longer support NULL objfile.
	(init_type): Likewise.
	(alloc_type_arch): New function.
	(alloc_type_copy): New function.
	(get_type_arch): New function.

	(smash_type): Preserve type ownership information.
	(make_pointer_type, make_reference_type, make_function_type,
	smash_to_memberptr_type, smash_to_method_type): No longer
	preserve OBJFILE across smash_type calls.
	(make_pointer_type, make_reference_type, make_function_type,
	lookup_memberptr_type, lookup_methodptr_type, allocate_stub_method,
	create_range_type, create_array_type, create_set_type, copy_type):
	Use alloc_type_copy when allocating types.
	(check_typedef): Use alloc_type_arch.
	(copy_type_recursive): Likewise.  Preserve type ownership data
	after copying type.
	(recursive_dump_type): Dump type ownership data.
	(alloc_type_instance): Update type ownership check.
	(copy_type, copy_type_recursive): Likewise.

	(arch_type): New function.
	(arch_integer_type): Likewise.
	(arch_character_type): Likewise.
	(arch_boolean_type): Likewise.
	(init_float_type): Remove, replace by ...
	(arch_float_type): ... this.
	(init_complex_type): Remove, replace by ...
	(arch_complex_type): ... this.
	(init_flags_type): Remove, replace by ...
	(arch_flags_type): ... this.
	(append_flags_type_flag): Move down.
	(init_composite_type): Remove, replace by ...
	(arch_composite_type): ... this.
	(append_composite_type_field_aligned,
	append_composite_type_field): Move down.

	* gdbarch.c (gdbtypes_post_init): Allocate all types
	using per-architecture routines.
	* ada-lang.c (ada_language_arch_info): Likewise.
	* f-lang.c (build_fortran_types): Likewise.
	* jv-lang.c (build_java_types): Likewise.
	* m2-lang.c (build_m2_types): Likewise.
	* scm-lang.c (build_scm_types): Likewise.

	* ada-lang.c (ada_type_of_array): Use alloc_type_copy.
	(packed_array_type): Likewise.
	(ada_template_to_fixed_record_type_1): Likewise.
	(template_to_static_fixed_type): Likewise.
	(to_record_with_fixed_variant_part): Likewise.
	(to_fixed_variant_branch_type): Likewise.
	(to_fixed_array_type): Likewise.
	(to_fixed_range_type): Likewise.
	(empty_record): Use type instead of objfile argument.
	Use alloc_type_copy.
	(to_fixed_variant_branch_type): Update call to empty_record.
	* jv-lang.c (type_from_class): Use alloc_type_arch.

	* arm-tdep.c (arm_ext_type): Allocate per-architecture type.
	* i386-tdep.c (i386_eflags_type, i386_mxcsr_type, i387_ext_type,
	i386_mmx_type, i386_sse_type): Likewise.
	* ia64-tdep.c (ia64_ext_type): Likewise.
	* m32c-tdep.c (make_types): Likewise.
	* m68k-tdep.c (m68k_ps_type, m68881_ext_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64,
	rs6000_builtin_type_vec128): Likewise.
	* sparc-tdep.c (sparc_psr_type, sparc_fsr_type): Likewise.
	* sparc64-tdep.c (sparc64_pstate_type, sparc64_fsr_type,
	sparc64_fprs_type): Likewise.
	* spu-tdep.c (spu_builtin_type_vec128): Likewise.
	* xtensa-tdep.c (xtensa_register_type): Likewise.
	* linux-tdep.c (linux_get_siginfo_type): Likewise.
	* target-descriptions.c (tdesc_gdb_type): Likewise.
	* gnu-v3-abi.c (build_gdb_vtable_type): Likewise.
@
text
@d2183 2
d2190 1
a2190 1
  insert_single_step_breakpoint (next_pc);
@


1.278
log
@	* gdbtypes.h (builtin_type_ieee_single, builtin_type_ieee_double,
	builtin_type_i387_ext, builtin_type_m68881_ext, builtin_type_arm_ext,
	builtin_type_ia64_spill, builtin_type_ia64_quad): Remove.
	(init_float_type, init_complex_type): Add prototypes.
	* gdbtypes.c (builtin_type_ieee_single, builtin_type_ieee_double,
	builtin_type_i387_ext, builtin_type_m68881_ext, builtin_type_arm_ext,
	builtin_type_ia64_spill, builtin_type_ia64_quad): Remove.
	(_initialize_gdbtypes): Do not initialize them.
	(build_flt): Rename to ...
	(init_float_type): ... this.  Make global.
	(build_complex): Rename to ...
	(init_complex_type): ... this.  Make global.  Remove BIT argument.
	(gdbtypes_post_init): Update calls.

	* ada-lang.c (ada_language_arch_info): Use init_float_type.
	* jv-lang.c (build_java_types): Likewise.
	* m2-lang.c (build_m2_types): Likewise.
	* f-lang.c (build_fortran_types): Use init_float_type and
	init_complex_type.

	* target-descriptions.c (tdesc_gdb_type): Call init_float_type instead
	of using builtin_type_ieee_single, builtin_type_ieee_double, or
	builtin_type_arm_ext.

	* ia64-tdep.h (struct gdbarch_tdep): Add ia64_ext_type member.
	* ia64-tdep.c (builtin_type_ia64_ext): Remove.
	(_initialize_ia64_tdep): Do not initialize it.
	(floatformat_valid, floatformat_ia64_ext, floatformats_ia64_ext):
	Move up.
	(ia64_ext_type): New function.
	(ia64_register_reggroup_p, ia64_convert_register_p,
	ia64_register_to_value, ia64_value_to_register,
	ia64_extract_return_value, ia64_store_return_value): Use ia64_ext_type
	instead of builtin_type_ia64_ext.

	* i386-tdep.h (struct gdbarch_tdep): Add i387_ext_type member.
	(i387_ext_type): Add prototype.
	* i386-tdep.c (i387_ext_type): New function.
	(i386_extract_return_value, i386_store_return_value,
	i386_register_type): Use it instead of builtin_type_i387_ext.
	* amd64-tdep.c (amd64_register_type): Likewise.
	* i387-tdep.c (print_i387_value, i387_register_to_value,
	i387_value_to_register): Likewise.
	(print_i387_value, print_i387_ext): Add GDBARCH argument.
	(print_i387_ext, i387_print_float_info): Pass to subroutines.

	* m68k-tdep.h (struct gdbarch_tdep): Add m68881_ext_type member.
	* m68k-tdep.c (m68881_ext_type): New function.
	(m68k_register_type, m68k_convert_register_p): Use it instead
	of builtin_type_m68881_ext.

	* arm-tdep.h (struct gdbarch_tdep): Add arm_ext_type member.
	* arm-tdep.c (arm_ext_type): New function.
	(arm_register_type): Use it instead of builtin_type_arm_ext.

	* alpha-tdep.c (alpha_register_type): Use builtin types
	instead of builtin_type_ieee_double.

	* mips-tdep.c (mips_float_register_type, mips_double_register_type):
	Remove.
	(mips_register_type): Use builtin types instead of
	builtin_type_ieee_single and builtin_type_ieee_double.
	(mips_print_fp_register): Use builtin types instead of
	mips_float_register_type and mips_double_register_type.

	* hppa-tdep.c (hppa32_register_type, hppa64_register_type):
	Use builtin types instead of builtin_type_ieee_single and
	builtin_type_ieee_double.
@
text
@d1604 1
a1604 1
      = init_float_type (-1, "builtin_type_arm_ext",
@


1.277
log
@	* gdbtypes.h (builtin_type_int0, builtin_type_int8, builtin_type_uint8,
	builtin_type_int16, builtin_type_uint16, builtin_type_int32,
	builtin_type_uint32, builtin_type_int64, builtin_type_uint64,
	builtin_type_int128, builtin_type_uint128): Remove.
	(struct builtin_type): New members builtin_int0, builtin_int8,
	builtin_uint8, builtin_int16, builtin_uint16, builtin_int32,
	builtin_uint32, builtin_int64, builtin_uint64, builtin_int128,
	and builtin_uint128.
	* gdbtypes.c (builtin_type_int0, builtin_type_int8, builtin_type_uint8,
	builtin_type_int16, builtin_type_uint16, builtin_type_int32,
	builtin_type_uint32, builtin_type_int64, builtin_type_uint64,
	builtin_type_int128, builtin_type_uint128): Remove.
	(_initialize_gdbtypes): Do not initialize them.
	(gdbtypes_post_init): Initialize fixed-size integer types.

	* dwarf2expr.c (unsigned_address_type, signed_address_type): Add
	GDBARCH argument.  Return platform-specific type.
	(dwarf2_read_address, execute_stack_op): Update calls.

	* target-descriptions.c (tdesc_gdb_type): Use platform-specific types
	instead of global builtin_int_... variables.
	* mi/mi-main.c (mi_cmd_data_read_memory): Likewise.
	* printcmd.c (do_examine): Likewise.
	* jv-exp.y (parse_number): Likewise.

	* alpha-tdep.c (alpha_register_type, alpha_push_dummy_call,
	alpha_store_return_value): Likewise.
	* amd64-linux-tdep.c (amd64_linux_register_type): Likewise.
	* amd64-tdep.c (amd64_register_type): Likewise.
	* arm-tdep.c (arm_register_type): Likewise.
	* avr-tdep.c (avr_register_type): Likewise.
	* cris-tdep.c (cris_register_type, crisv32_register_type): Likewise.
	* frv-tdep.c (frv_register_type): Likewise.
	* h8300-tdep.c h8300_register_type): Likewise.
	* hppa-tdep.c (hppa64_push_dummy_call, hppa32_register_type,
	hppa64_register_type): Likewise.
	* i386-tdep.c (i386_mmx_type, i386_sse_type): Likewise.
	* iq2000-tdep.c (iq2000_register_type): Likewise.
	* lm32-tdep.c (lm32_register_type, lm32_push_dummy_call): Likewise.
	* m32r-tdep.c (m32r_register_type): Likewise.
	* m68hc11-tdep.c (m68hc11_register_type, m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m88k-tdep.c (m88k_register_type, m88k_store_arguments): Likewise.
	* mep-tdep.c (mep_register_type): Likewise.
	* mips-tdep.c (mips_register_type, mips_pseudo_register_type,
	mips_print_fp_register): Likewise.
	* moxie-tdep.c (moxie_register_type): Likewise.
	* mt-tdep.c (mt_copro_register_type, mt_register_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64,
	rs6000_builtin_type_vec128): Likewise.
	* score-tdep.c (score_register_type): Likewise.
	* sparc-tdep.c (sparc32_register_type, sparc32_store_arguments):
	Likewise.
	* sparc64-tdep.c (sparc64_register_type, sparc64_store_arguments):
	Likewise.
	* spu-tdep.c (spu_builtin_type_vec128, spu_register_type): Likewise.
	* v850-tdep.c (v850_register_type): Likewise.
	* xstormy16-tdep.c (xstormy16_register_type): Likewise.
	* xtensa-tdep.c (xtensa_register_type): Likewise.

	* mt-tdep.c (struct gdbarch_tdep): New data structure.
	(mt_gdbarch_init): Alloc TDEP structures.
	(mt_register_type): Cache coprocessor type in TDEP instead of
	static global variable.

	* xtensa-tdep.h (struct gdbarch_tdep): Add type_entries member.
	* xtensa-tdep.c (type_entries): Remove.
	(xtensa_register_type): Cache fixed-size types in TDEP instead
	of in global variable.
@
text
@d1596 14
d1617 1
a1617 1
    return builtin_type_arm_ext;
@


1.276
log
@	* dummy-frame.c (deprecated_pc_in_call_dummy): Add GDBARCH parameter,
	use it instead of current_gdbarch.
	* frame.h (deprecated_pc_in_call_dummy): Add GDBARCH parameter.
	* arm-tdep.c (arm_skip_prologue): Pass architecture to
	deprecated_pc_in_call_dummy.

	* symtab.c (skip_prologue_using_sal): Add GDBARCH parameter.
	Use it instead of current_gdbarch.
	* symtab.h (skip_prologue_using_sal): Add GDBARCH parameter.
	* breakpoint.c (expand_line_sal_maybe): Pass architecture to
	skip_prologue_using_sal.
	* arm-tdep.c (skip_prologue_using_sal): Likewise.
	* lm32-tdep.c (lm32_skip_prologue): Likewise.
	* m32-tdep.c (m32c_skip_prologue): Likewise.
	* mips-tdep.c (mips_skip_prologue): Likewise.
	* moxie-tdep.c (moxie_skip_prologue): Likewise.
	* mt-tdep.c (mt_frame_unwind_cache): Likewise.
	* rs6000-tdep.c (rs6000_skip_prologue): Likewise.
	* frv-tdep.c (frv_analyze_prologue): Add GDBARCH parameter, pass
	it to skip_prologue_using_sal.  Update call sites ...
	(frv_skip_prologue, frv_frame_unwind_cache): ... here.

	* mn10300-tdep.c (struct mn10300_prologue): Add GDBARCH member.
	(check_for_saved): Use it instead of current_gdbarch.
	(mn10300_analyze_prologue): Set it.

	* value.c (using_struct_return): Add GDBARCH parameter.  Use it
	instead of current_gdbarch.
	* value.h (using_struct_return): Add GDBARCH parameter.
	* eval.c (evaluate_subexp_standard): Pass architecture to
	using_struct_return.
	* infcall.c (call_function_by_hand): Likewise.
	* stack.c (return_command): Likewise.
	* sparc-tdep.c (sparc32_push_dummy_code): Likewise.

	* symtab.c (in_prologue): Add GDBARCH parameter.  Use it instead of
	current_gdbarch.
	* symtab.h (in_prologue): Add GDBARCH parameter.
	* infrun.c (handle_inferior_event): Pass architecture to in_prologue.

	* eval.c (evaluate_subexp_standard): Use expression architecture
	instead of current_gdbarch.

	* c-lang.c (evaluate_subexp_c): Use expression architecture and
	language instead of current_gdbarch and current_language.

	* printcmd.c (do_one_display): Use expression architecture instead
	of current_gdbarch.

	* infcmd.c (print_return_value): Use architecture of stop_regcache
	instead of current_gdbarch.
	(print_vector_info, print_float_info): Remove GDBARCH argument,
	use frame architecture instead.
	(vector_info, float_info): Update calls.

	* objc-lang.c (objc_skip_trampoline): Use frame architecture
	instead of current_gdbarch.

	* parse.c (write_dollar_variable): Use parse architecture instead
	of current_gdbarch.

	* source.c (line_info): Use objfile architecture instead of
	current_gdbarch.

	* symtab.c (find_function_start_sal): Use gdbarch instead of
	current_gdbarch.
	(print_msymbol_info): Use objfile architecture instead of
	current_gdbarch.

	* valops.c (value_assign): Use frame architecture instead of
	current_gdbarch.
@
text
@d1611 1
a1611 1
    return builtin_type_int0;
d1613 1
a1613 1
    return builtin_type_uint32;
@


1.275
log
@	* prologue-value.c (make_pv_area): Add ADDR_BIT argument.
	Use it instead of address bits of current_gdbarch.
	* prologue-value.c (make_pv_area): Add ADDR_BIT argument.
	* arm-tdep.c (thumb_analyze_prologue): Pass address bits to
	make_pv_area.
	(arm_scan_prologue): Likewise.
	* m32c-tdep.c (m32c_analyze_prologue): Likewise.
	* mep-tdep.c (mep_analyze_prologue): Likewise.
	* mn10300-tdep.c (mn10300_analyze_prologue): Likewise.
	* s390-tdep.c (s390_analyze_prologue): Likewise.
@
text
@d542 1
a542 1
  if (deprecated_pc_in_call_dummy (pc))
d550 2
a551 1
      CORE_ADDR post_prologue_pc = skip_prologue_using_sal (func_addr);
d563 1
a563 1
  limit_pc = skip_prologue_using_sal (pc);
@


1.274
log
@        Updated copyright notices for most files.
@
text
@d398 1
a398 1
  stack = make_pv_area (ARM_SP_REGNUM);
d865 1
a865 1
  stack = make_pv_area (ARM_SP_REGNUM);
@


1.273
log
@	* xcoffread.c (RECORD_MINIMAL_SYMBOL): Update.
	(scan_xcoff_symtab): Update.
	* mdebugread.c (record_minimal_symbol): Update.
	(parse_partial_symbols): Update.
	* elfread.c (record_minimal_symbol): Update.
	* dbxread.c (record_minimal_symbol): Update.
	* coffread.c (record_minimal_symbol): Update.
	* sh64-tdep.c (MSYMBOL_IS_SPECIAL): Redefine.
	(sh64_elf_make_msymbol_special): Update.
	* mips-tdep.c (mips_elf_make_msymbol_special): Use
	MSYMBOL_TARGET_FLAG_1.
	(mips_elf_make_msymbol_special): Likewise.
	(msymbol_is_special): Likewise.
	* minsyms.c (prim_record_minimal_symbol_and_info): Update.
	(install_minimal_symbols): Likewise.
	(prim_record_minimal_symbol): Update.
	(prim_record_minimal_symbol_and_info): Remove 'info' argument.
	* m68hc11-tdep.c (MSYMBOL_SET_RTC): Redefine.
	(MSYMBOL_SET_RTI): Redefine.
	(MSYMBOL_IS_RTC): Redefine.
	(MSYMBOL_IS_RTI): Redefine.
	* arm-tdep.c (MSYMBOL_SET_SPECIAL): Redefine.
	(MSYMBOL_IS_SPECIAL): Redefine.
	* symtab.h (struct minimal_symbol) <info>: Remove.
	<target_flag_1, target_flag_2>: New fields.
	(MSYMBOL_INFO): Remove.
	(MSYMBOL_TARGET_FLAG_1): New macro.
	(MSYMBOL_TARGET_FLAG_2): Likewise.
	(prim_record_minimal_symbol_and_info): Update.
@
text
@d4 1
a4 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
@


1.272
log
@	* arm-tdep.c (arm_skip_prologue): Call skip_prologue_using_sal
	instead of determining symbol and line info directly.
@
text
@d66 1
a66 2
	MSYMBOL_INFO (msym) = (char *) (((long) MSYMBOL_INFO (msym))	\
					| 0x80000000)
d69 1
a69 1
	(((long) MSYMBOL_INFO (msym) & 0x80000000) != 0)
@


1.271
log
@	* alpha-tdep.c (alpha_register_type): Use builtin_type (gdbarch)
	instead of builtin_type_ macros.
	* amd64-tdep.c (amd64_register_type): Likewise.
	(amd64_get_longjmp_target): Likewise.
	* arm-tdep.c (arm_register_type): Likewise.
	* avr-tdep.c (avr_register_type): Likewise.
	* cris-tdep.c (cris_register_type, crisv32_register_type): Likewise.
	* frv-tdep.c (frv_register_type): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* hppa-tdep.c (hppa32_convert_from_func_ptr_addr,
	hppa_skip_trampoline_code): Likewise.
	* i386-tdep.c (i386_register_type): Likewise.
	(i386_unwind_pc, i386_sse_type): Likewise.
	* ia64-tdep.c (ia64_register_type): Likewise.
	* m32r-tdep.c (m32r_register_type): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m88k-tdep.c (m88k_register_type): Likewise.
	* mep-tdep.c (mep_register_type): Likewise.
	* mips-tdep.c (mips_pseudo_register_type): Likewise.
	* mn10300-tdep.c (mn10300_register_type): Likewise.
	* mt-tdep.c (mt_copro_register_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64): Likewise.
	(rs6000_convert_register_p, rs6000_register_to_value,
	rs6000_value_to_register): Likewise.
	* s390-tdep.c (s390_register_type): Likewise.
	* sh64-tdep.c (sh64_register_type): Likewise.
	(sh64_build_float_register_type, sh64_do_fp_register): Likewise.
	* sh-tdep.c (sh_sh2a_register_type, sh_sh3e_register_type,
	sh_sh4_build_float_register_type, sh_sh4_register_type,
	sh_default_register_type): Likewise.
	* sparc64-tdep.c (sparc64_register_type): Likewise.
	* sparc-tdep.c (sparc32_register_type): Likewise.
	* spu-tdep.c (spu_builtin_type_vec128, spu_register_type): Likewise.
	* v850-tdep.c (v850_register_type): Likewise.
	* vax-tdep.c (vax_register_type): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_unwind_pc,
	xtensa_push_dummy_call): Likewise.

	* std-regs.c (value_of_builtin_frame_fp_reg,
	value_of_builtin_frame_pc_reg): Likewise.
	* target-descriptions.c (tdesc_register_type): Likewise.
@
text
@d539 1
a539 2
  CORE_ADDR func_addr, func_end = 0;
  char *func_name;
d546 20
a565 5
  /* See what the symbol table says.  */

  if (find_pc_partial_function (pc, &func_name, &func_addr, &func_end))
    {
      struct symbol *sym;
a566 17
      /* Found a function.  */
      sym = lookup_symbol (func_name, NULL, VAR_DOMAIN, NULL);
      if (sym && SYMBOL_LANGUAGE (sym) != language_asm)
        {
	  /* Don't use this trick for assembly source files.  */
	  sal = find_pc_line (func_addr, 0);
	  if ((sal.line != 0) && (sal.end < func_end))
	    return sal.end;
        }
    }

  /* Can't find the prologue end in the symbol table, try it the hard way
     by disassembling the instructions.  */

  /* Like arm_scan_prologue, stop no later than pc + 64. */
  if (func_end == 0 || func_end > pc + 64)
    func_end = pc + 64;
d570 1
a570 1
    return thumb_analyze_prologue (gdbarch, pc, func_end, NULL);
d572 1
a572 1
  for (skip_pc = pc; skip_pc < func_end; skip_pc += 4)
@


1.270
log
@	* gdbarch.sh (addr_bits_remove): Change type to 'm'.
	(smash_text_address): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.

	* arch-utils.c (core_addr_identity): Add gdbarch parameter.
	* arch-utils.h (core_addr_identity): Likewise.
	* arm-tdep.c (arm_addr_bits_remove): Likewise.
	(arm_smash_text_address): Likewise.
	* hppa-tdep.c (hppa_smash_text_address): Likewise.
	* m88k-tdep.c (m88k_addr_bits_remove): Likewise.
	* s390-tdep.c (s390_addr_bits_remove): Likewise.

	* mips-tdep.c (mips_addr_bits_remove): Add gdbarch parameter.
	Use it instead of current_gdbarch.

	* arm-tdep.c (arm_prologue_prev_register, arm_unwind_pc,
	arm_dwarf2_prev_register): Update calls.
	* m88k-tdep.c (m88k_unwind_pc): Update call.
@
text
@d1608 1
a1608 1
    return builtin_type_void_data_ptr;
d1610 1
a1610 1
    return builtin_type_void_func_ptr;
@


1.269
log
@	* gdbarch.sh (target_gdbarch): New global variable.
	(deprecated_current_gdbarch_select_hack): Set it.
	* gdbarch.c, gdbarch.h: Regenerate.

	* arch-utils.c (gdbarch_update_p): Use target_gdbarch instead
	of current_gdbarch.
	* target-descriptions.c (target_find_description): Likewise.
	* arm-tdep.c (arm_update_current_architecture): Likewise.
	(show_fp_model, arm_show_abi, arm_show_fallback_mode,
	arm_show_force_mode): Likewise.
	* mips-tdep.c (show_mask_address, show_mipsfpu_command,
	show_mips_abi): Likewise.
	* mep-tdep.c (me_module_register_set, current_me_module): Likewise.

	* target.c (target_translate_tls_address): Use target_gdbarch
	instead of current_gdbarch.
	* remote.c (struct packet_reg): Likewise.
	(get_remote_arch_state, packet_reg_from_regnum,
	packet_reg_from_pnum, remote_check_symbols, remote_wait,
	remote_address_masked, remote_insert_breakpoint,
	remote_insert_hw_breakpoint, remote_read_description): Likewise.
	* remote-m32r-sdi.c (m32r_resume, m32r_wait): Likewise.
	* remote-mips.c (mips_open, mips_common_breakpoint): Likewise.
	* cris-tdep.c (cris_can_use_hardware_watchpoint): Likewise.

	* solib.c (solib_open, solib_map_sections, solib_read_symbols,
	solib_add, info_sharedlibrary_command, solib_address,
	solib_create_inferior_hook, in_solib_dynsym_resolve_code,
	solib_global_lookup): Likewise.
	* solib-frv.c (enable_break2, frv_relocate_main_executable): Likewise.
	* solib-irix.c (irix_current_sos, irix_open_symbol_file_object):
	Likewise.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Likewise.
	* solib-svr4.c (exec_entry_point, enable_break, svr4_free_so,
	set_solib_svr4_fetch_link_map_offsets, svr4_fetch_link_map_offsets):
	Likewise.
	* nto-tdep.c (nto_find_and_open_solib, nto_init_solib_absolute_prefix,
	nto_truncate_ptr): Likewise.
	* mips-linux-tdep.c (mips_linux_in_dynsym_stub): Likewise.
@
text
@d366 1
a366 1
arm_addr_bits_remove (CORE_ADDR val)
d377 1
a377 1
arm_smash_text_address (CORE_ADDR val)
d1099 1
d1117 1
a1117 1
					arm_addr_bits_remove (lr));
d1255 1
a1255 1
  return arm_addr_bits_remove (pc);
d1268 1
d1280 1
a1280 1
					arm_addr_bits_remove (lr));
@


1.268
log
@	* arm-tdep.c (arm_pc_is_thumb): Use obj_section_addr.
	* hppa-hpux-tdep.c (hppa_hpux_find_dummy_bpaddr): Likewise.
	* hppa-linux-tdep.c (hppa_linux_find_global_pointer): Use
	obj_section_addr and obj_section_endaddr.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Likewise.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Likewise.
	* ia64-tdep.c (ia64_find_global_pointer): Likewise.
	(find_extant_func_descr): Likewise.
	* solib-frv.c (frv_relocate_main_executable): Use
	obj_section_addr.
	* xstormy16-tdep.c (xstormy16_find_jmp_table_entry): Use
	obj_section_addr and obj_section_endaddr.
@
text
@d2707 1
a2707 1
  if (gdbarch_bfd_arch_info (current_gdbarch)->arch != bfd_arch_arm)
d2741 1
a2741 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d2744 1
a2744 1
      && gdbarch_bfd_arch_info (current_gdbarch)->arch == bfd_arch_arm)
d2778 1
a2778 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d2781 1
a2781 1
      && gdbarch_bfd_arch_info (current_gdbarch)->arch == bfd_arch_arm)
d2794 1
a2794 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d2805 1
a2805 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
@


1.267
log
@	ARM BE8 support.
	* disasm.c (gdb_disassemble_info): Set endian_code.
	* gdbarch.sh (gdbarch_info): New field byte_order_for_code.
	* gdbarch.h, gdbarch.c: Regenerate.
	* arch-utils.c (initialize_current_architecture): Set the
	default byte_order_for_code.
	(gdbarch_info_init): Ditto.
	(gdbarch_info_fill): Ditto.
	* arm-tdep.c (SWAP_INT, SWAP_SHORT): New macros.
	(thumb_analyze_prologue): Swap halfword if code endianness is
	different from general endianness.
	(arm_skip_prologue): Similarly.
	(arm_scan_prologue): Ditto.
	(thumb_get_next_pc): Ditto.
	(arm_get_next_pc): Ditto.
	(arm_gdbarch_init): Set byte_order_for_code from BE8 flag,
	choose correct endianness for breakpoints.
@
text
@d306 2
a307 1
      struct arm_mapping_symbol map_key = { memaddr - sec->addr, 0 };
@


1.266
log
@	* symtab.h (lookup_symbol_in_language): Remove SYMTAB parameter.
	(lookup_symbol): Likewise.
	* symtab.c (lookup_symbol_in_language): Remove SYMTAB parameter.
	(lookup_symbol): Likewise.
	(search_symbols): Update.

	* linespec.c (find_methods, collect_methods): Update.
	(add_matching_methods, add_constructors): Update.
	(decode_compound, decode_dollar, decode_variable): Update.
	(lookup_prefix_sym): Update.

	(symbol_found): Remove SYM_SYMTAB parameter.
	Use SYMBOL_SYMTAB (sym) instead.

	* gdbtypes.c (lookup_typename): Update.
	(lookup_struct, lookup_union, lookup_enum): Update.
	(lookup_template_type): Update.
	(check_typedef): Update.
	* language.c (lang_bool_type): Update.
	* mdebugread.c (parse_procedure): Update.
	* mi/mi-cmd-stack.c (list_args_or_locals): Update.
	* parse.c (write_dollar_variable): Update.
	* printcmd.c (address_info): Update.
	* source.c (select_source_symtab): Update.
	* stack.c (print_frame_args, print_frame_arg_vars): Update.
	* valops.c (find_function_in_inferior): Update.
	(value_struct_elt_for_reference): Update.
	* value.c (value_static_field, value_fn_field): Update.

	* alpha-mdebug-tdep.c (find_proc_desc): Update.
	* arm-tdep.c (arm_skip_prologue): Update.
	* mt-tdep.c (mt_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_skip_prologue): Update.

	* ada-lang.h (struct ada_symbol_info): Remove SYMTAB member.
	* ada-lang.c (ada_add_block_symbols): Remove SYMTAB parameter.
	(add_defn_to_vec): Likewise.
	(ada_add_block_symbols): Likewise.
	(lookup_cached_symbol, cache_symbol): Likewise.
	(standard_lookup): Update.
	(ada_lookup_symbol_list): Update.

	* c-valprint.c (c_val_print): Update.
	* cp-support.c (cp_lookup_rtti_type): Update.
	* jv-lang.c (java_lookup_class, get_java_object_type): Update.
	* objc-lang.c (lookup_struct_typedef, find_imps): Update.
	* p-valprint.c (pascal_val_print): Update.
	* scm-lang.c (scm_lookup_name): Update.

	* c-exp.y: Update.
	* f-exp.y: Update.
	* jv-exp.y: Update.
	* m2-exp.y: Update.
	* objc-exp.y: Update.
	* p-exp.y: Update.
@
text
@d72 13
d407 3
d578 3
d877 3
d1837 3
d1867 2
d1904 4
d3184 4
d3230 1
a3230 1
  switch (info.byte_order)
@


1.266.4.1
log
@2008-07-17  Michael Snyder  <msnyder@@specifix.com>
	2006-05-02  Michael Snyder  <msnyder@@redhat.com>

	* Target interface for reverse execution.
	* target.h (enum target_waitkind):
	Add new wait event, TARGET_WAITKIND_NO_HISTORY.
	(enum exec_direction_kind): New enum.
	(struct target_ops): New methods to_set_execdir, to_get_execdir.
	* target.c (target_get_execdir): New generic method.
	(target_set_execdir): Ditto.
	* remote.c (remote_get_execdir, remote_set_execdir): New methods.
	(remote_vcont_resume): Jump out if attempting reverse execution.
	(remote_resume): Check for reverse exec direction, and send
	appropriate command to target.
	(remote_wait): Check target response for NO_HISTORY status.
	Also check for empty reply (target doesn't understand "bs" or "bc).
	(_initialize_remote): Add new methods to remote target vector.

	* breakpoint.h (breakpoint_silence): Export.
	* breakpoint.c (breakpoint_silence): New function.
	* infcmd.c (finish_command): Check for reverse exec direction.
	(finish_backward): New function, handle finish cmd in reverse.
	* infrun.c (enum inferior_stop_reason): Add NO_HISTORY reason.
	(handle_inferior_event): Handle TARGET_WAITKIND_NO_HISTORY.
	Handle stepping over a function call in reverse.
	Handle stepping thru a line range in reverse.
	Handle setting a step-resume breakpoint in reverse.
	Handle stepping into a function in reverse.
	Handle stepping between line ranges in reverse.
	(print_stop_reason): Print reason for NO_HISTORY.

	2006-03-31  Michael Snyder  <msnyder@@redhat.com>
	User interface for reverse execution.
	* Makefile.in (reverse.c): New file.
	* reverse.c: New file.  User interface for reverse execution.

	2007-04-18  Daniel Jacobowitz  <dan@@codesourcery.com>

	* infcmd.c (finish_backwards): Correct check for whether to back
	up after finishing.

	* arm-tdep.c (arm_scan_epilogue): New.
	(arm_make_prologue_cache): Use it.
	(arm_epilogue_unwind_sniffer): New.
	(arm_gdbarch_init): Register it.
@
text
@a1013 78
/* This function tries to guess whether we are in the epilogue of an
   ARM function.  We need to detect whether the stack frame has
   already been destroyed - if it has, then neither the prologue
   scanner nor GCC's unwind tables will be valid.  This is very hokey
   and generally unsafe.  */

static int
arm_scan_epilogue (struct frame_info *next_frame,
		   struct arm_prologue_cache *cache)
{
  unsigned int insn;
  gdb_byte buf[4];
  CORE_ADDR prev_pc = frame_pc_unwind (next_frame);

  /* Assume there is no frame until proven otherwise.  */
  if (cache != NULL)
    {
      cache->framereg = ARM_SP_REGNUM;
      cache->framesize = 0;
      cache->frameoffset = 0;
    }

  /* Check for Thumb epilogue.  */
  if (arm_pc_is_thumb (prev_pc))
    /* Not yet implemented.  */
    return 0;

  if (target_read_memory (prev_pc, buf, 4) != 0)
    return 0;
  insn = extract_unsigned_integer (buf, 4);

  if (insn == 0xe12fff1e) /* bx lr */
    /* If this is a return, we have no frame left and no saved
       registers.  */
    return 1;

  return 0;
}

/* This function tries to guess whether we are in the epilogue of an
   ARM function.  We need to detect whether the stack frame has
   already been destroyed - if it has, then neither the prologue
   scanner nor GCC's unwind tables will be valid.  This is very hokey
   and generally unsafe.  */

static int
arm_scan_epilogue (struct frame_info *next_frame,
		   struct arm_prologue_cache *cache)
{
  unsigned int insn;
  gdb_byte buf[4];
  CORE_ADDR prev_pc = frame_pc_unwind (next_frame);

  /* Assume there is no frame until proven otherwise.  */
  if (cache != NULL)
    {
      cache->framereg = ARM_SP_REGNUM;
      cache->framesize = 0;
      cache->frameoffset = 0;
    }

  /* Check for Thumb epilogue.  */
  if (arm_pc_is_thumb (prev_pc))
    /* Not yet implemented.  */
    return 0;

  if (target_read_memory (prev_pc, buf, 4) != 0)
    return 0;
  insn = extract_unsigned_integer (buf, 4);

  if (insn == 0xe12fff1e) /* bx lr */
    /* If this is a return, we have no frame left and no saved
       registers.  */
    return 1;

  return 0;
}

a1134 18
static const struct frame_unwind *
arm_epilogue_unwind_sniffer (struct frame_info *next_frame)
{
  if (arm_scan_epilogue (next_frame, NULL))
    return &arm_prologue_unwind;
  else
    return NULL;
}

static const struct frame_unwind *
arm_epilogue_unwind_sniffer (struct frame_info *next_frame)
{
  if (arm_scan_epilogue (next_frame, NULL))
    return &arm_prologue_unwind;
  else
    return NULL;
}

@


1.266.2.1
log
@2007-04-18  Daniel Jacobowitz  <dan@@codesourcery.com>

	* arm-tdep.c (arm_scan_epilogue): New.
	(arm_make_prologue_cache): Use it.
	(arm_epilogue_unwind_sniffer): New.
	(arm_gdbarch_init): Register it.
@
text
@a1013 78
/* This function tries to guess whether we are in the epilogue of an
   ARM function.  We need to detect whether the stack frame has
   already been destroyed - if it has, then neither the prologue
   scanner nor GCC's unwind tables will be valid.  This is very hokey
   and generally unsafe.  */

static int
arm_scan_epilogue (struct frame_info *next_frame,
		   struct arm_prologue_cache *cache)
{
  unsigned int insn;
  gdb_byte buf[4];
  CORE_ADDR prev_pc = frame_pc_unwind (next_frame);

  /* Assume there is no frame until proven otherwise.  */
  if (cache != NULL)
    {
      cache->framereg = ARM_SP_REGNUM;
      cache->framesize = 0;
      cache->frameoffset = 0;
    }

  /* Check for Thumb epilogue.  */
  if (arm_pc_is_thumb (prev_pc))
    /* Not yet implemented.  */
    return 0;

  if (target_read_memory (prev_pc, buf, 4) != 0)
    return 0;
  insn = extract_unsigned_integer (buf, 4);

  if (insn == 0xe12fff1e) /* bx lr */
    /* If this is a return, we have no frame left and no saved
       registers.  */
    return 1;

  return 0;
}

/* This function tries to guess whether we are in the epilogue of an
   ARM function.  We need to detect whether the stack frame has
   already been destroyed - if it has, then neither the prologue
   scanner nor GCC's unwind tables will be valid.  This is very hokey
   and generally unsafe.  */

static int
arm_scan_epilogue (struct frame_info *next_frame,
		   struct arm_prologue_cache *cache)
{
  unsigned int insn;
  gdb_byte buf[4];
  CORE_ADDR prev_pc = frame_pc_unwind (next_frame);

  /* Assume there is no frame until proven otherwise.  */
  if (cache != NULL)
    {
      cache->framereg = ARM_SP_REGNUM;
      cache->framesize = 0;
      cache->frameoffset = 0;
    }

  /* Check for Thumb epilogue.  */
  if (arm_pc_is_thumb (prev_pc))
    /* Not yet implemented.  */
    return 0;

  if (target_read_memory (prev_pc, buf, 4) != 0)
    return 0;
  insn = extract_unsigned_integer (buf, 4);

  if (insn == 0xe12fff1e) /* bx lr */
    /* If this is a return, we have no frame left and no saved
       registers.  */
    return 1;

  return 0;
}

a1134 18
static const struct frame_unwind *
arm_epilogue_unwind_sniffer (struct frame_info *next_frame)
{
  if (arm_scan_epilogue (next_frame, NULL))
    return &arm_prologue_unwind;
  else
    return NULL;
}

static const struct frame_unwind *
arm_epilogue_unwind_sniffer (struct frame_info *next_frame)
{
  if (arm_scan_epilogue (next_frame, NULL))
    return &arm_prologue_unwind;
  else
    return NULL;
}

@


1.265
log
@	* gdbarch.sh: Delete dwarf_reg_to_regnum.
	* gdbarch.c, gdbarch.h: Regenerated.
	* amd64-tdep.c, arm-tdep.c, h8300-tdep.c, hppa-linux-tdep.c,
	hppa-tdep.c, i386-tdep.c, m32c-tdep.c, m68k-tdep.c, mips-tdep.c,
	s390-tdep.c, xtensa-tdep.c: Do not set dwarf_reg_to_regnum.

	* gdbint.texinfo (Target Conditionals): Delete entry for
	gdbarch_dwarf_reg_to_regnum.
@
text
@d537 1
a537 1
      sym = lookup_symbol (func_name, NULL, VAR_DOMAIN, NULL, NULL);
@


1.264
log
@	* Makefile.in (arm-tdep.o): Update.
	* arm-tdep.c (arm_objfile_data_key, struct arm_mapping_symbol)
	(struct arm_per_objfile, arm_compare_mapping_symbols): New.
	(arm_pc_is_thumb): Use mapping symbols.
	(arm_objfile_data_cleanup, arm_record_special_symbol): New.
	(arm_gdbarch_init): Call set_gdbarch_record_special_symbol.
	(_initialize_arm_tdep): Initialize arm_objfile_data_key.
	* elfread.c (elf_symtab_read): Use gdbarch_record_special_symbol.
	* gdbarch.sh: Add record_special_symbol.
	* gdbarch.c, gdbarch.h: Regenerated.
	* objfiles.c (struct objfile_data): Add cleanup member.
	(register_objfile_data_with_cleanup): New function, from
	register_objfile_data.
	(register_objfile_data): Use it.
	(objfile_free_data): Call clear_objfile_data.
	(clear_objfile_data): Call cleanup functions.
	* objfiles.h (register_objfile_data_with_cleanup): Declare.
@
text
@a3269 1
  set_gdbarch_dwarf_reg_to_regnum (gdbarch, arm_dwarf_reg_to_regnum);
@


1.263
log
@	* arm-tdep.c (arm_prologue_this_id): Compare pc, not func, to
	lowest_pc.
@
text
@d54 1
d72 16
d258 9
d274 1
d287 40
d2857 59
d3286 1
d3376 3
@


1.262
log
@	* arm-tdep.c (arm_mode_strings, arm_fallback_mode_string)
	(arm_force_mode_string, arm_show_fallback_mode)
	(arm_show_force_mode): New.
	(arm_pc_is_thumb): Honor fallback-mode and force-mode.  Use
	arm_frame_is_thumb.
	(_initialize_arm_tdep): Add "set arm fallback-mode"
	and "set arm force-mode".
	* NEWS: Document new commands.

	* gdb.texinfo (ARM): Document set/show arm fallback-mode
	and set/show arm force-mode.
@
text
@d984 1
a984 1
  CORE_ADDR func;
d990 3
a992 5
  func = get_frame_func (this_frame);

  /* This is meant to halt the backtrace at "_start".  Make sure we
     don't halt it at a generic dummy frame. */
  if (func <= gdbarch_tdep (get_frame_arch (this_frame))->lowest_pc)
d999 1
@


1.261
log
@Add lost bit of previous commit.
@
text
@d104 11
d254 6
d263 18
a280 7
    {
      return (MSYMBOL_IS_SPECIAL (sym));
    }
  else
    {
      return 0;
    }
d2692 22
d3337 15
@


1.260
log
@	* arm-linux-tdep.h (ARM_CPSR_REGNUM): Delete definition.
	* arm-tdep.c (arm_frame_is_thumb): New.
	(arm_pc_is_thumb): Clarify comment.
	(thumb_analyze_prologue): Remove PC special case.
	(thumb_scan_prologue): Take a block_addr argument.  Use it for
	find_pc_partial_function.  Remove unused variables.
	(arm_scan_prologue): Use arm_frame_is_thumb.  Use the block address
	for find_pc_partial_function.  Remove PC special case.
	(arm_prologue_prev_register): Add special handling for PC and CPSR.
	(arm_dwarf2_prev_register, arm_dwarf2_frame_init_reg): New.
	(arm_get_next_pc): Use arm_frame_is_thumb.
	(arm_write_pc): Use CPSR_T instead of 0x20.
	(arm_gdbarch_init): Call dwarf2_frame_set_init_reg.
	* arm-tdep.h (enum gdb_regnum): Add ARM_CPSR_REGNUM.
	(CPSR_T): Define.
	* dwarf2-frame.c (dwarf2_frame_prev_register): Handle
	DWARF2_FRAME_REG_FN.
	* dwarf2-frame.h (enum dwarf2_frame_reg_rule): Add
	DWARF2_FRAME_REG_FN.
	(struct dwarf2_frame_state_reg): Add FN to loc union.

	* gdb.arch/thumb-prologue.exp: Do not expect a saved PC.
@
text
@d1165 1
a1165 3
      CORE_ADDR lr, cpsr;

      cpsr = get_frame_register_unsigned (this_frame, prev_regnum);
d1171 1
a1171 1
      return frame_unwind_got_constant (this_frame, prev_regnum, cpsr);
@


1.259
log
@	* arm-linux-tdep.c, arm-tdep.c, armobsd-tdep.c: Update for
	unwinder changes.
@
text
@d214 16
d231 2
a232 1
   function.  */
a292 8
  /* The call instruction saved PC in LR, and the current PC is not
     interesting.  Due to this file's conventions, we want the value
     of LR at this function's entry, not at the call site, so we do
     not record the save of the PC - when the ARM prologue analyzer
     has also been converted to the pv mechanism, we could record the
     save here and remove the hack in prev_register.  */
  regs[ARM_PC_REGNUM] = pv_unknown ();

d547 1
a547 1
		     struct arm_prologue_cache *cache)
a551 9
  /* Which register has been copied to register n?  */
  int saved_reg[16];
  /* findmask:
     bit 0 - push { rlist }
     bit 1 - mov r7, sp  OR  add r7, sp, #imm  (setting of r7)
     bit 2 - sub sp, #simm  OR  add sp, #simm  (adjusting of sp)
  */
  int findmask = 0;
  int i;
d553 2
a554 1
  if (find_pc_partial_function (prev_pc, NULL, &prologue_start, &prologue_end))
d648 1
d659 1
a659 1
  if (arm_pc_is_thumb (prev_pc))
d661 1
a661 1
      thumb_scan_prologue (gdbarch, prev_pc, cache);
d667 2
a668 1
  if (find_pc_partial_function (prev_pc, NULL, &prologue_start, &prologue_end))
a756 2
  regs[ARM_PC_REGNUM] = pv_unknown ();

d989 4
a992 2
     instead.  The saved value of PC points into this frame's
     prologue, not the next frame's resume location.  */
d994 7
a1000 1
    prev_regnum = ARM_LR_REGNUM;
d1008 21
d1146 53
d1780 1
a1780 1
  if (arm_pc_is_thumb (pc))
d2753 1
a2753 1
	regcache_cooked_write_unsigned (regcache, ARM_PS_REGNUM, val | 0x20);
d2756 1
a2756 1
					val & ~(ULONGEST) 0x20);
d3120 2
@


1.258
log
@doc/ChangeLog:
--------------

	* gdb.texinfo (Set SH Calling convention): New @@item.
	(Show SH Calling convention): Ditto.

ChangeLog:
----------

	* NEWS: Add information on calling convention and new SH CLI options.

	* sh-tdep.c (sh_cc_gcc): New static string.
	(sh_cc_renesas): Ditto.
	(sh_cc_enum): New static string array.
	(sh_active_calling_convention): New static string pointer denoting
	active user chosen ABI.
	(sh_is_renesas_calling_convention): New function to return function
	specific ABI, or user choice if necessary.
	(sh_use_struct_convention): Rename first argument and turn around its
	meaning.  Check for renesas ABI and return accordingly.
	(sh_use_struct_convention_nofpu): New function.
	(sh_next_flt_argreg): Get function type as third parameter.  Check
	for renesas ABI and choose floating registers accordingly.
	(sh_push_dummy_call_fpu): Check for ABI and choose argument slot and
	struct return slot accordingly.
	(sh_push_dummy_call_nofpu): Ditto.
	(sh_return_value_nofpu): Call sh_use_struct_convention_nofpu from here.
	Evaluate ABI and give to sh_use_struct_convention_nofpu.
	(sh_return_value_fpu):  Evaluate ABI and give to
	sh_use_struct_convention.
	(show_sh_command): New function.
	(set_sh_command): Ditto.
	(_initialize_sh_tdep): Initialize `set/show sh calling-convention
	CLI command.

	* gdbarch.sh (return_value): Add func_type argument.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Ditto.
	* eval.c (evaluate_subexp_standard): Rename local variable value_type to
	val_type so as not to collide with value_type function.  Call
	using_struct_return with additional function type argument.
	* infcall.c (call_function_by_hand): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* infcmd.c (print_return_value): Take addition func_type argument.
	Call gdbarch_return_value with additional function type argument.
	(finish_command_continuation): Call print_return_value with additional
	function type argument.
	(finish_command): Ditto.
	* sparc-tdep.c (sparc32_push_dummy_code): Call using_struct_return with
	additional function type argument.
	* stack.c (return_command): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* value.c (using_struct_return): Take additional function type argument.
	* value.h (using_struct_return): Accommodate declaration.
	* alpha-tdep.c (alpha_return_value): Add func_type argument.
	* amd64-tdep.c (amd64_return_value): Ditto.
	* arm-tdep.c (arm_return_value): Ditto.
	* avr-tdep.c (avr_return_value): Ditto.
	* cris-tdep.c (cris_return_value): Ditto.
	* frv-tdep.c (frv_return_value): Ditto.
	* h8300-tdep.c (h8300_return_value): Ditto.
	(h8300h_return_value): Ditto.
	* hppa-tdep.c (hppa32_return_value): Ditto.
	(hppa64_return_value): Ditto.
	* i386-tdep.c (i386_return_value): Ditto.
	* ia64-tdep.c (ia64_return_value): Ditto.
	* iq2000-tdep.c (iq2000_return_value): Ditto.
	* m32c-tdep.c (m32c_return_value): Ditto.
	* m32r-tdep.c (m32r_return_value): Ditto.
	* m68hc11-tdep.c (m68hc11_return_value): Ditto.
	* m68k-tdep.c (m68k_return_value): Ditto.
	(m68k_svr4_return_value): Ditto.
	* m88k-tdep.c  (m88k_return_value): Ditto.
	* mep-tdep.c (mep_return_value): Ditto.
	* mips-tdep.c (mips_eabi_return_value): Ditto.
	(mips_n32n64_return_value): Ditto.
	(mips_o32_return_value): Ditto.
	(mips_o64_return_value): Ditto.
	* mn10300-tdep.c (mn10300_return_value): Ditto.
	* mt-tdep.c (mt_return_value): Ditto.
	* ppc-linux-tdep.c (ppc_linux_return_value): Ditto.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Ditto.
	* rs6000-tdep.c (rs6000_return_value): Ditto.
	* s390-tdep.c (s390_return_value): Ditto.
	* score-tdep.c (score_return_value): Ditto.
	* sh-tdep.c (sh_return_value_nofpu): Ditto.
	(sh_return_value_fpu): Ditto.
	* sh64-tdep.c (sh64_return_value): Ditto.
	* sparc-tdep.c (sparc32_return_value): Ditto.
	* sparc64-tdep.c (sparc64_return_value): Ditto.
	* spu-tdep.c (spu_return_value): Ditto.
	* v850-tdep.c (v850_return_value): Ditto.
	* vax-tdep.c (vax_return_value): Ditto.
	* xstormy16-tdep.c (xstormy16_return_value): Ditto.
	* xtensa-tdep.c (xtensa_return_value): Ditto.

	* gdbtypes.h (struct type): Add calling_convention member.
	* dwarf2read.c (read_subroutine_type): Add calling convention read
	from DW_AT_calling_convention attribute to function type.
@
text
@d640 1
a640 1
arm_scan_prologue (struct frame_info *next_frame,
d643 1
a643 1
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
d646 1
a646 1
  CORE_ADDR prev_pc = frame_pc_unwind (next_frame);
d714 1
a714 1
      frame_loc = frame_unwind_register_unsigned (next_frame, ARM_FP_REGNUM);
d919 1
a919 1
arm_make_prologue_cache (struct frame_info *next_frame)
d926 1
a926 1
  cache->saved_regs = trad_frame_alloc_saved_regs (next_frame);
d928 1
a928 1
  arm_scan_prologue (next_frame, cache);
d930 1
a930 1
  unwound_fp = frame_unwind_register_unsigned (next_frame, cache->framereg);
d938 1
a938 1
  for (reg = 0; reg < gdbarch_num_regs (get_frame_arch (next_frame)); reg++)
d949 1
a949 1
arm_prologue_this_id (struct frame_info *next_frame,
d958 1
a958 1
    *this_cache = arm_make_prologue_cache (next_frame);
d961 1
a961 1
  func = frame_func_unwind (next_frame, NORMAL_FRAME);
d965 1
a965 1
  if (func <= gdbarch_tdep (get_frame_arch (next_frame))->lowest_pc)
d976 2
a977 2
static void
arm_prologue_prev_register (struct frame_info *next_frame,
d979 1
a979 6
			    int prev_regnum,
			    int *optimized,
			    enum lval_type *lvalp,
			    CORE_ADDR *addrp,
			    int *realnump,
			    gdb_byte *valuep)
d984 1
a984 1
    *this_cache = arm_make_prologue_cache (next_frame);
d994 1
a994 1
     identified by NEXT_FRAME's stack pointer at the time of the call.
d997 1
a997 6
    {
      *lvalp = not_lval;
      if (valuep)
	store_unsigned_integer (valuep, 4, cache->prev_sp);
      return;
    }
d999 2
a1000 2
  trad_frame_get_prev_register (next_frame, cache->saved_regs, prev_regnum,
				optimized, lvalp, addrp, realnump, valuep);
d1006 3
a1008 1
  arm_prologue_prev_register
a1010 6
static const struct frame_unwind *
arm_prologue_unwind_sniffer (struct frame_info *next_frame)
{
  return &arm_prologue_unwind;
}

d1012 1
a1012 1
arm_make_stub_cache (struct frame_info *next_frame)
d1019 1
a1019 1
  cache->saved_regs = trad_frame_alloc_saved_regs (next_frame);
d1021 1
a1021 1
  cache->prev_sp = frame_unwind_register_unsigned (next_frame, ARM_SP_REGNUM);
d1029 1
a1029 1
arm_stub_this_id (struct frame_info *next_frame,
d1036 1
a1036 1
    *this_cache = arm_make_stub_cache (next_frame);
d1039 1
a1039 2
  *this_id = frame_id_build (cache->prev_sp,
			     frame_pc_unwind (next_frame));
d1042 4
a1045 8
struct frame_unwind arm_stub_unwind = {
  NORMAL_FRAME,
  arm_stub_this_id,
  arm_prologue_prev_register
};

static const struct frame_unwind *
arm_stub_unwind_sniffer (struct frame_info *next_frame)
d1050 1
a1050 1
  addr_in_block = frame_unwind_address_in_block (next_frame, NORMAL_FRAME);
d1052 2
a1053 2
      || target_read_memory (frame_pc_unwind (next_frame), dummy, 4) != 0)
    return &arm_stub_unwind;
d1055 1
a1055 1
  return NULL;
d1058 8
d1067 1
a1067 1
arm_normal_frame_base (struct frame_info *next_frame, void **this_cache)
d1072 1
a1072 1
    *this_cache = arm_make_prologue_cache (next_frame);
d1085 1
a1085 1
/* Assuming NEXT_FRAME->prev is a dummy, return the frame ID of that
d1092 1
a1092 1
arm_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
d1094 2
a1095 2
  return frame_id_build (frame_unwind_register_unsigned (next_frame, ARM_SP_REGNUM),
			 frame_pc_unwind (next_frame));
d2979 1
a2979 1
  set_gdbarch_unwind_dummy_id (gdbarch, arm_unwind_dummy_id);
d3038 3
a3040 3
  frame_unwind_append_sniffer (gdbarch, arm_stub_unwind_sniffer);
  frame_unwind_append_sniffer (gdbarch, dwarf2_frame_sniffer);
  frame_unwind_append_sniffer (gdbarch, arm_prologue_unwind_sniffer);
@


1.257
log
@
	* rs6000-tdep.c (gdb_print_insn_powerpc): Get the current endianess
	from disassemble_info instead of gdbarch_byte_order.

	* mips-tdep.c (gdb_print_insn_mips): Likewise.
	* arm-tdep.c (gdb_print_insn_arm): Likewise.
@
text
@d2376 3
a2378 3
arm_return_value (struct gdbarch *gdbarch, struct type *valtype,
		  struct regcache *regcache, gdb_byte *readbuf,
		  const gdb_byte *writebuf)
@


1.256
log
@	* arm-tdep.c (arm_addr_bits_remove): In non 26-bit mode, don't
	strip bit 1 even if pc doesn't point to thumb code.
@
text
@d2021 1
a2021 1
  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
@


1.255
log
@	* alpha-tdep.c (alpha_heuristic_proc_start)
	(alpha_sigtramp_register_address): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch.

	(alpha_heuristic_frame_unwind_cache): Use get_frame_arch to get at the
	current architecture by frame_info. Update alpha_heuristic_proc_start
	call.

	(alpha_sigtramp_frame_this_id, alpha_sigtramp_frame_prev_register): Use
	get_frame_arch to get at the current architecture by frame_info. Update
	alpha_sigtramp_register_address call.

	* arm-tdep.c (thumb_scan_prologue): Add gdbarch as parameter and replace
	current_gdbarch by gdbarch. Update caller.
	(convert_to_extended, convert_from_extended): Add endianess parameter
	for comparison. Update caller.
	(arm_extract_return_value, arm_store_return_value): Use
	get_regcache_arch to get at the current	architecture.

	* cris-tdep.c (cris_register_size): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch. Update caller.
	(cris_gdb_func, move_to_preg_op, none_reg_mode_move_from_preg_op): Add
	gdbarch as parameter. Update caller. Replace current_gdbarch by gdbarch.

	* h8300-tdep.c (E_PSEUDO_CCR_REGNUM, E_PSEUDO_EXR_REGNUM, BINWORD): Add
	gdbarch	as parameter. Update caller.
	(h8300_init_frame_cache): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch. Update caller.

	* hppa-tdep.c (skip_prologue_hard_way): Add gdbarch as parameter and
	update caller. Replace current_gdbarch by gdbarch.

	* m32c-tdep.c (m32c_skip_trampoline_code): Use get_frame_arch to get at
	the current architecture. Replace current_gdbarch by gdbarch.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache): Likewise.
	(STACK_CORRECTION, USE_PAGE_REGISTER): Replace M6811_TDEP by its
	expression. Add gdbarch as parameter and replace current_gdbarch with
	it. Update caller.
	(M6811_TDEP): Remove.
	(m68hc11_frame_prev_register): Use get_frame_arch to get at the current
	architecture.
	(m68hc11_scan_prologue): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch. Update caller.

	* m68k-tdep.c (m68k_analyze_prologue): Add gdbarch as parameter and
	update caller.
	(m68k_analyze_register_saves): Likewise. Also replace current_gdbarch
	by gdbarch.

	* rs6000-tdep.c (skip_prologue): Add gdbarch as parameter and update
	caller. Relace current_gdbarch by gdbarch.
	(altivec_register_p, spe_register_p): Likewise.
	* ppc-tdep.h (altivec_register_p, spe_register_p): Add gdbarch as
	parameter.
	* ppc-linux-nat.c (fetch_register, store_register): Update caller of
	altivec_register_p and spe_register_p.

	* score-tdep.c (score_fetch_inst): Add gdbarch as parameter. Update
	caller. Replace current_gdbarch by gdbarch.
	(score_analyze_prologue): use get_frame_arch to get at the current
	architecture.

	* sparc-tdep.h (sparc_analyze_prologue): Add gdbarch as parameter.
	* sparc-tdep.c (sparc_analyze_prologue): Likewise. Replace
	current_gdbarch by gdbarch. Update caller.
	(sparc_frame_cache): Use get_frame_arch to get at the current
	architecture.
	* sparce64-tdep.c (sparc64_skip_prologue): Update call of
	sparc_analyze_prologue.

	* mn10300-tdep.c (mn10300_dwarf2_reg_to_regnum): Add gdbarch as
	parameter.
@
text
@d243 1
a243 1
    return (val & (arm_pc_is_thumb (val) ? 0xfffffffe : 0xfffffffc));
@


1.254
log
@
	* gdbarch.sh (skip_prologue): Add gdbarch
	as parameter.
	* gdbarch.{c,h}: Regenerate.

	* alpha-tdep.c (alpha_skip_prologue): Add gdbarch as parameter.
	* amd64-tdep.c (amd64_skip_prologue): Likewise.
	* avr-tdep.c (avr_skip_prologue): Likewise.
	* cris-tdep.c (cris_skip_prologue): Likewise.
	* frv-tdep.c (frv_skip_prologue): Likewise.
	* h8300-tdep.c (h8300_skip_prologue): Likewise.
	* hppa-tdep.c (hppa_skip_prologue): Likewise.
	* i386-tdep.c (i386_skip_prologue): Likewise.
	* ia64-tdep.c (ia64_skip_prologue): Likewise.
	* iq2000-tdep.c (iq2000_skip_prologue): Likewise.
	* m32r-tdep.c (m32r_skip_prologue): Likewise.
	* m68hc11-tdep.c (m68hc11_skip_prologue): Likewise.
	* m68k-tdep.c (m68k_skip_prologue): Likewise.
	* m88k-tdep.c (m88k_skip_prologue): Likewise.
	* mep-tdep.c (mep_skip_prologue): Likewise.
	* mips-tdep.c (mips_skip_prologue): Likewise.
	* mn10300-tdep.c (mn10300_skip_prologue): Likewise.
	* mt-tdep.c (mt_skip_prologue): Likewise.
	* rs6000-tdep.c (rs6000_skip_prologue): Likewise.
	* score-tdep.c (score_skip_prologue): Likewise.
	* sh64-tdep.c (sh64_skip_prologue): Likewise.
	* sh-tdep.c (sh_skip_prologue): Likewise.
	* sparc64-tdep.c (sparc64_skip_prologue): Likewise.
	* sparc-tdep.c (sparc32_skip_prologue): Likewise.
	* spu-tdep.c (spu_skip_prologue): Likewise.
	* v850-tdep.c (v850_skip_prologue): Likewise.
	* vax-tdep.c (vax_skip_prologue): Likewise.
	* xstormy16-tdep.c (xstormy16_skip_prologue): Likewise.
	* xtensa-tdep.c (xtensa_skip_prologue): Likewise.

	* arm-tdep.c (arm_skip_prologue): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch.
	* m32c-tdep.c (m32c_skip_prologue): Likewise.
	* s390-tdep.c (s390_skip_prologue): Likewise.
@
text
@d180 1
a180 1
				   void *);
d182 1
a182 1
				 const void *);
d537 2
a538 1
thumb_scan_prologue (CORE_ADDR prev_pc, struct arm_prologue_cache *cache)
d569 1
a569 2
  thumb_analyze_prologue (current_gdbarch, prologue_start, prologue_end,
			  cache);
d659 1
a659 1
      thumb_scan_prologue (prev_pc, cache);
d1502 1
a1502 1
		       void *dbl)
d1505 2
a1506 1
  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
d1515 2
a1516 1
convert_to_extended (const struct floatformat *fmt, void *dbl, const void *ptr)
d1519 1
d1521 1
a1521 1
  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
d2100 2
d2104 1
a2104 1
      switch (gdbarch_tdep (get_regcache_arch (regs))->fp_model)
d2115 1
a2115 1
				   valbuf);
d2289 2
d2295 1
a2295 1
      switch (gdbarch_tdep (get_regcache_arch (regs))->fp_model)
d2299 2
a2300 1
	  convert_to_extended (floatformat_from_type (type), buf, valbuf);
@


1.253
log
@	Updated copyright notices for most files.
@
text
@d414 1
a414 1
arm_skip_prologue (CORE_ADDR pc)
d452 1
a452 1
    return thumb_analyze_prologue (current_gdbarch, pc, func_end, NULL);
@


1.252
log
@	* gdbarch.sh (stab_reg_to_regnum, dwarf_reg_to_regnum)
	( dwarf2_reg_to_regnum, sdb_reg_to_regnum, ecoff_reg_to_regnum): Add
	gdbarch as parameter.
	* gdbarch.{c,h}: Regenerate.

	* xtensa-tdep.c (xtensa_reg_to_regnum): Add gdbarch as parameter.
	Replace current_gdbarch by gdbarch.
	* s390-tdep.c (s390_dwarf_reg_to_regnum): Likewise.
	* rs6000-tdep.c (rs6000_stab_reg_to_regnum)
	(rs6000_dwarf2_reg_to_regnum): Likewise.
	* mips-tdep.c (mips_stab_reg_to_regnum)
	(mips_dwarf_dwarf2_ecoff_reg_to_regnum): Likewise.
	* mep-tdep.c (mep_debug_reg_to_regnum): Likewise.
	* m32c-tdep.c (m32c_debug_info_reg_to_regnum): Likewise.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise
	* h8300-tdep.c (h8300s_dbg_reg_to_regnum)
	(h8300_dbg_reg_to_regnum): Likewise.
	* amd64-tdep.c (amd64_dwarf_reg_to_regnum): Likewise.
	* arch-utils.c (no_op_reg_to_regnum): Likewise.
	* arch-utils.h (no_op_reg_to_regnum): Likewise.
	* arm-tdep.c (arm_dwarf_reg_to_regnum): Likewise.
	* cris-tdep.c (cris_dwarf2_reg_to_regnum): Likewise.
	* hppa-tdep.c (hppa64_dwarf_reg_to_regnum): Likewise.
	* ia64-tdep.c (ia64_dwarf_reg_to_regnum): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
@
text
@d4 2
a5 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
@


1.251
log
@2007-11-19  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (register_sim_regno): Add gdbarch as parameter.
	* gdbarch.{c,h}: Regenerate.

	* arch-utils.h (legacy_register_sim_regno): Add gdbarch as parameter.
	* score-tdep.c (score_register_sim_regno): Likewise.
	* sim-regno.h (one2one_register_sim_regno): Likewise.

	* arch-utils.c (legacy_register_sim_regno): Add gdbarch as parameter.
	Replace current_gdbarch by gdbarch.
	* sh-tdep.c (sh_sh2a_register_sim_regno)
	(sh_dsp_register_sim_regno): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* mips-tdep.c (mips_register_sim_regno): Likewise.
	* m32c-tdep.c (m32c_register_sim_regno): Likewise.
	* frv-tdep.c (frv_register_sim_regno): Likewise.
	* arm-tdep.c (arm_register_sim_regno): Likewise.
	* remote-sim.c (one2one_register_sim_regno): Likewise.
@
text
@d1433 1
a1433 1
arm_dwarf_reg_to_regnum (int reg)
@


1.250
log
@2007-11-15  Markus Deuling  <deuling@@de.ibm.com>

	* arm-tdep.c (arm_prologue_this_id): Replace LOWEST_PC by its
	expression and use get_frame_arch to replace current_gdbarch by frame's
	architecture.
	*arm-tdep.h (LOWEST_PC): Remove
@
text
@d1465 1
a1465 1
arm_register_sim_regno (int regnum)
d1468 1
a1468 1
  gdb_assert (reg >= 0 && reg < gdbarch_num_regs (current_gdbarch));
@


1.249
log
@*** empty log message ***
@
text
@d964 1
a964 1
  if (func <= LOWEST_PC)
@


1.248
log
@2007-11-02  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (register_name): Add gdbarch parameter.
	* gdbarch.{c,h}: Regenerate.

	* target-descriptions.c (tdesc_register_name): Add gdbarch parameter.
	(tdesc_register_name): Replace current_gdbarch by gdbarch.
	* target-descriptions.h (tdesc_register_name): Add gdbarch parameter.

	* xstormy16-tdep.c (xstormy16_register_name): Add gdbarch parameter.
	* vax-tdep.c (vax_register_name): Add gdbarch parameter.
	* spu-tdep.c (spu_register_name): Add gdbarch parameter.
	* s390-tdep.c (s390_register_name): Add gdbarch parameter.
	* mt-tdep.c (mt_register_name): Add gdbarch parameter.
	(mt_registers_info): Replace current_gdbarch by gdbarch.
	(mt_register_reggroup_p): Add gdbarch to mt_register_name call.
	* mips-tdep.c (mips_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(mips_register_name): Add gdbarch to tdesc_register_name call.
	* mep-tdep.c (mep_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(mep_register_reggroup_p): Add gdbarch to mep_register_name call.
	* m32c-tdep.c (m32c_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	* m88k-tdep.c (m88k_register_name): Add gdbarch parameter.
	* m68k-tdep.c (m68k_register_name): Add gdbarch parameter.
	* m32r-tdep.c (m32r_register_name): Add gdbarch parameter.
	(m32r_frame_unwind_cache): Use get_frame_arch to get at the current
	architecture by frame_info.
	* iq2000-tdep.c (iq2000_register_name): Add gdbarch parameter.
	* ia64-tdep.c (ia64_register_name): Add gdbarch parameter.
	* hppa-tdep.c (hppa32_register_name, hppa64_register_name): Add gdbarch
	parameter.
	* h8300-tdep.c (h8300_register_name, h8300s_register_name)
	(h8300sx_register_name): Add gdbarch parameter.
	* cris-tdep.c (cris_register_name, crisv32_register_name): Add
	gdbarch parameter. Replace current_gdbarch by gdbarch.
	(cris_gdbarch_init): Replace current_gdbarch by gdbarch (comment).
	* avr-tdep.c (avr_register_name): Add gdbarch parameter.
	* arm-tdep.c (arm_register_name): Add gdbarch paramete
	* amd64-tdep.c (amd64_register_name): Add gdbarch parameter. Update
	caller.
	* amd64-tdep.h (amd64_register_name): Add gdbarch parameter.
	* amd64-linux-tdep.c (amd64_linux_register_name): Add gdbarch parameter.
	* alpha-tdep.c (alpha_register_name): Add gdbarch parameter.
	(alpha_cannot_fetch_register, alpha_cannot_store_register): Update call
	of alpha_register_name.
	* frv-tdep.c (frv_register_name): Add gdbarch parameter.
	* i386-tdep.c (i386_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(i386_register_type): Replace ?current_gdbarch by gdbarch.
	* i386-tdep.h (i386_register_name): Add gdbarch parameter.
	* i386-linux-tdep.c (i386_linux_register_name): Add gdbarch parameter.

	* m68hc11-tdep.c (m68hc11_register_name): Add gdbarch parameter.
	(m68hc11_register_reggroup_p): Add gdbarch to call of
	m68hc11_register_name.
	* mn10300-tdep.c (mn10300_generic_register_name, am33_register_name)
	(am33_2_register_name): Add gdbarch parameter.
	(mn10300_frame_unwind_cache): Use get_frame_arch to get at the current
	architecture by frame_info.
	(mn10300_dump_tdep): Replace current_gdbarch by gdbarch.
	* rs6000-tdep.c (rs6000_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	* score-tdep.c (score_register_name): Add gdbarch parameter.
	(score_return_value, score_push_dummy_call): Replace current_gdbarch
	by gdbarch.
	* sh64-tdep.c (sh64_register_name): Add gdbarch parameter.
	(sh64_compact_reg_base_num, sh64_register_convert_to_virtual)
	(sh64_register_convert_to_raw, sh64_fv_reg_base_num)
	(sh64_dr_reg_base_num, sh64_fpp_reg_base_num): Add gdbarch parameter
	and update caller. Replace current_gdbarch by gdbarch.
	(sh64_extract_return_value, sh64_store_return_value): Use
	get_regcache_arch to get at the current architecture by regcache.
	* sh-tdep.c (sh_sh_register_name, sh_sh3_register_name)
	(sh_sh3e_register_name, sh_sh2e_register_name, sh_sh2a_register_name)
	(sh_sh2a_nofpu_register_name, sh_sh_dsp_register_name)
	(sh_sh3_dsp_register_name, sh_sh4_register_name)
	(sh_sh4_nofpu_register_name, sh_sh4al_dsp_register_name): Add gdbarch
	parameter.
	(fv_reg_base_num, dr_reg_base_num, sh_justify_value_in_reg)
	(sh_next_flt_argreg): Add gdbarch parameter and update caller. Replace
	current_gdbarch by gdbarch.
	(sh_extract_return_value_fpu, sh_store_return_value_fpu): Use
	get_regcache_arch to get at the current architecture by regcache.
	* sparc-tdep.c (sparc32_register_name): Add gdbarch parameter.
	* sparc64-tdep.c (sparc64_register_name): Add gdbarch parameter.
	* v850-tdep.c (v850_register_name, v850e_register_name): Add gdbarch
	parameter.
	(v850_unwind_sp, v850_unwind_pc): Replace current_gdbarch by gdbarch.
	* xtensa-tdep.c (xtensa_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(xtensa_pseudo_register_read, xtensa_pseudo_register_write)
	(xtensa_frame_prev_register): Add gdbarch parameter to
	xtensa_register_name call.
@
text
@d2071 1
a2071 1
arm_breakpoint_from_pc (CORE_ADDR *pcptr, int *lenptr)
d2073 1
a2073 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
@


1.247
log
@2007-10-30  Markus Deuling  <deuling@@de.ibm.com>

	* arm-tdep.c (arm_get_next_pc): Replace current_gdbarch by gdbarch.
@
text
@d2599 1
a2599 1
arm_register_name (int i)
@


1.246
log
@	* NEWS: Document target described register support for PowerPC.
	* ppc-tdep.h: Remove ppc_spr constants.
	(struct gdbarch_tdep): Remove regs, ppc_sr0_regnum, and
	ppc_builtin_type_vec128 members.
	(PPC_R0_REGNUM, PPC_F0_REGNUM, PPC_PC_REGNUM, PPC_MSR_REGNUM)
	(PPC_CR_REGNUM, PPC_LR_REGNUM, PPC_CTR_REGNUM, PPC_XER_REGNUM)
	(PPC_FPSCR_REGNUM, PPC_MQ_REGNUM, PPC_SPE_UPPER_GP0_REGNUM)
	(PPC_SPE_ACC_REGNUM, PPC_SPE_FSCR_REGNUM, PPC_VR0_REGNUM)
	(PPC_VSCR_REGNUM, PPC_VRSAVE_REGNUM, PPC_NUM_REGS): New constants.
	* rs6000-tdep.c: Include preparsed descriptions.
	(init_sim_regno_table): Do not iterate over pseudo registers.
	Look up segment registers by name.  Use sim_spr_register_name
	for SPRs.
	(rs6000_register_sim_regno): Call init_sim_regno_table here.
	(rs6000_builtin_type_vec128): Delete.
	(rs6000_register_name): Only handle SPE pseudo registers and upper
	halves.  Call tdesc_register_name for everything else.
	(rs6000_register_type): Delete.  Replace with...
	(rs6000_pseudo_register_type): ...this new function.  Only handle
	SPE pseudo registers.
	(rs6000_register_reggroup_p): Delete.  Replace with...
	(rs6000_pseudo_register_reggroup_p): ...this new function.  Only
	handle SPE pseudo registers.
	(rs6000_convert_register_p): Use ppc_fp0_regnum instead of
	"struct reg".
	(rs6000_register_to_value, rs6000_value_to_register): Remove check
	of reg->fpr.
	(e500_register_reggroup_p): Delete.
	(STR, R, R4, R8, R16, F, P8, R32, R64, R0, A4, S, S4, SN4, S64)
	(COMMON_UISA_REGS, PPC_UISA_SPRS, PPC_UISA_NOFP_SPRS)
	(PPC_SEGMENT_REGS, PPC_OEA_SPRS, PPC_ALTIVEC_REGS, PPC_SPE_GP_REGS)
	(PPC_SPE_UPPER_GP_REGS, PPC_EV_PSEUDO_REGS): Delete macros.
	(registers_powerpc, registers_403, registers_403GC, registers_505)
	(registers_860, registers_601, registers_602, registers_603)
	(registers_604, registers_750, registers_7400, registers_e500): Delete
	variables.
	(struct variant): Delete nregs, npregs, num_tot_regs, and regs.  Add
	tdesc.
	(tot_num_registers, num_registers, num_pseudo_registers): Delete.
	(variants): Delete outdated comment.  Use standard target descriptions
	instead of "struct reg" arrays.
	(init_variants): Delete.
	(rs6000_gdbarch_init): Do not guess word size from the BFD
	architecture if we have a target description.  Select a variant
	before creating a new architecture.  Use the variant's target
	description if the target did not define a register layout.
	Validate target-supplied registers.  Reject mismatches.  Use
	fixed register numbers and new constants instead of magic
	numbers.  Call set_gdbarch_ps_regnum.  Call tdesc_use_registers.
	(_initialize_rs6000_tdep): Initialize the preparsed target
	descriptions.
	* target-descriptions.c (tdesc_predefined_types): Add int128 and
	uint128.
	(tdesc_find_register_early): New function.
	(tdesc_numbered_register): Use it.
	(tdesc_register_size): New function.
	(tdesc_use_registers): Take a target_desc argument.  Do not use
	gdbarch_target_desc.
	* target-descriptions.h (tdesc_use_registers): Update prototype
	and comment.
	(tdesc_register_size): New prototype.
	* Makefile.in (powerpc_32_c, powerpc_403_c, powerpc_403gc_c)
	(powerpc_505_c, powerpc_601_c, powerpc_602_c, powerpc_603_c)
	(powerpc_604_c, powerpc_64_c, powerpc_7400_c, powerpc_750_c)
	(powerpc_860_c, powerpc_e500_c, rs6000_c): New macros.
	(rs6000-tdep.o): Update.
	* arm-tdep.c (arm_gdbarch_init): Update call to tdesc_use_registers.
	* m68k-tdep.c (m68k_gdbarch_init): Likewise.
	* mips-tdep.c (mips_gdbarch_init): Likewise.

	* gdb.texinfo (Predefined Target Types): Add int128
	and uint128.
	(Standard Target Features): Add PowerPC features.

	* gdb.xml/tdesc-regs.exp: Add PowerPC support.

	* sim-ppc.h (sim_spr_register_name): New prototype.

	* gdb-sim.c (regnum2spr): Rename to...
	(sim_spr_register_name): ... this.  Make global.
@
text
@d1722 1
a1722 1
	  nextpc = gdbarch_addr_bits_remove (current_gdbarch, nextpc);
@


1.245
log
@	* arm-tdep.c (struct arm_prologue_cache): Remove frameoffset.
	(thumb_analyze_prologue): Move pv_area_store_would_trash call
	out of loop.  Do not set cache->frameoffset.
	(arm_scan_prologue): Use prologue-value mechanism.  Do not set
	frameoffset.  Simplify framesize.
	(arm_make_prologue_cache, arm_normal_frame_base): Do not use
	frameoffset.
	* arm-tdep.h (enum gdb_regnum): Add ARM_IP_REGNUM.
@
text
@d3077 1
a3077 1
    tdesc_use_registers (gdbarch, tdesc_data);
@


1.244
log
@2007-10-08  Markus Deuling  <deuling@@de.ibm.com>

	* arm-tdep.c (arm_scan_prologue, arm_make_prologue_cache)
	(thumb_get_next_pc, arm_get_next_pc, arm_extract_return_value)
	(arm_store_return_value): Use get_regcache_arch or get_frame_arch to
	get at the current architecture by regcache or byframe, respectively.
	(arm_push_dummy_call, arm_dump_tdep): Replace current_gdbarch by
	gdbarch.
@
text
@d190 3
a192 4
  /* The frame base for this frame is just prev_sp + frame offset -
     frame size.  FRAMESIZE is the size of this stack frame, and
     FRAMEOFFSET if the initial offset from the stack pointer (this
     frame's stack pointer, not PREV_SP) to the frame base.  */
a194 1
  int frameoffset;
d293 3
a295 1
	  int stop = 0;
a304 6
		if (pv_area_store_would_trash (stack, regs[ARM_SP_REGNUM]))
		  {
		    stop = 1;
		    break;
		  }

a308 3

	  if (stop)
	    break;
a363 3
  /* frameoffset is unused for this unwinder.  */
  cache->frameoffset = 0;

d643 1
a643 1
  int regno, sp_offset, fp_offset, ip_offset;
d646 4
a653 1
  cache->frameoffset = 0;
d748 6
a753 1
  sp_offset = fp_offset = ip_offset = 0;
d763 1
a763 1
	  ip_offset = 0;
d771 1
a771 1
	  ip_offset = imm;
d779 1
a779 1
	  ip_offset = -imm;
d784 4
a787 2
	  sp_offset -= 4;
	  cache->saved_regs[ARM_LR_REGNUM].addr = sp_offset;
d797 3
d804 2
a805 2
		sp_offset -= 4;
		cache->saved_regs[regno].addr = sp_offset;
d827 1
a827 2
	  fp_offset = -imm + ip_offset;
	  cache->framereg = ARM_FP_REGNUM;
d834 1
a834 1
	  sp_offset -= imm;
d839 4
a842 1
	  sp_offset -= 12;
d844 1
a844 1
	  cache->saved_regs[regno].addr = sp_offset;
d852 3
d874 3
a876 2
	      sp_offset -= 12;
	      cache->saved_regs[fp_start_reg++].addr = sp_offset;
d889 14
a902 6
  /* The frame size is just the negative of the offset (from the
     original SP) of the last thing thing we pushed on the stack. 
     The frame offset is [new FP] - [new SP].  */
  cache->framesize = -sp_offset;
  if (cache->framereg == ARM_FP_REGNUM)
    cache->frameoffset = fp_offset - sp_offset;
d904 11
a914 1
    cache->frameoffset = 0;
d933 1
a933 1
  cache->prev_sp = unwound_fp + cache->framesize - cache->frameoffset;
d1085 1
a1085 1
  return cache->prev_sp + cache->frameoffset - cache->framesize;
@


1.243
log
@	* arm-linux-tdep.c (arm_linux_software_single_step): New.
	(arm_linux_init_abi): Use it.
	* arm-tdep.c (arm_get_next_pc): Make global.  Handle all-ones
	condition correctly.
	* arm-tdep.h (arm_get_next_pc): Declare.
	* Makefile.in (arm-linux-tdep.o): Update.
@
text
@d651 2
a652 1
arm_scan_prologue (struct frame_info *next_frame, struct arm_prologue_cache *cache)
d654 1
d728 1
a728 1
			     (current_gdbarch, return_value) - 8;
d837 1
a837 1
	       && gdbarch_tdep (current_gdbarch)->have_fpa_registers)
d844 1
a844 1
	       && gdbarch_tdep (current_gdbarch)->have_fpa_registers)
d912 1
a912 1
  for (reg = 0; reg < gdbarch_num_regs (current_gdbarch); reg++)
d1215 1
a1215 1
			    gdbarch_register_name (current_gdbarch, argreg),
d1292 1
a1292 1
	      if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
d1298 1
a1298 1
				      (current_gdbarch, argreg),
d1616 1
d1631 1
a1631 1
      nextpc = gdbarch_addr_bits_remove (current_gdbarch, nextpc);
d1662 1
a1662 1
      nextpc = gdbarch_addr_bits_remove (current_gdbarch, nextpc);
d1673 1
d1738 1
a1738 1
				       (current_gdbarch, result);
d1821 1
a1821 1
				   (current_gdbarch, result);
d1865 1
a1865 1
		  nextpc = gdbarch_addr_bits_remove (current_gdbarch, nextpc);
d1904 1
a1904 1
			     (current_gdbarch, nextpc);
d1916 1
a1916 1
	    nextpc = gdbarch_addr_bits_remove (current_gdbarch, nextpc);
d2073 1
a2073 1
      switch (gdbarch_tdep (current_gdbarch)->fp_model)
d2262 1
a2262 1
      switch (gdbarch_tdep (current_gdbarch)->fp_model)
d3065 1
a3065 1
arm_dump_tdep (struct gdbarch *current_gdbarch, struct ui_file *file)
d3067 1
a3067 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
@


1.242
log
@	PR gdb/2103
	* arm-tdep.c (arm_in_call_stub): Delete.
	(arm_skip_stub): Handle from_arm and from_thumb stubs.
@
text
@d1667 1
a1667 1
static CORE_ADDR
d1683 24
a1706 1
  if (condition_true (bits (this_instr, 28, 31), status))
a1911 4
	    /* BLX */
	    if (bits (this_instr, 28, 31) == INST_NV)
	      nextpc |= bit (this_instr, 24) << 1;

@


1.241
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d2361 2
a2362 20
/* Return non-zero if the PC is inside a thumb call thunk.  */

int
arm_in_call_stub (CORE_ADDR pc, char *name)
{
  CORE_ADDR start_addr;

  /* Find the starting address of the function containing the PC.  If
     the caller didn't give us a name, look it up at the same time.  */
  if (0 == find_pc_partial_function (pc, name ? NULL : &name, 
				     &start_addr, NULL))
    return 0;

  return strncmp (name, "_call_via_r", 11) == 0;
}

/* If PC is in a Thumb call or return stub, return the address of the
   target PC, which is in a register.  The thunk functions are called
   _called_via_xx, where x is the register name.  The possible names
   are r0-r9, sl, fp, ip, sp, and lr.  */
d2368 1
d2375 4
a2378 1
  /* Call thunks always start with "_call_via_".  */
d2388 1
d2391 1
a2391 1
	if (strcmp (&name[10], table[regno]) == 0)
d2395 36
@


1.240
log
@	* arm-tdep.c (arm_gdbarch_init): Allow unknown ABI and FPU settings
	to match any gdbarch with matching OSABI.  Set default ABI and FPU
	after running the OSABI handler.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.239
log
@	* arm-tdep.c (arm_push_dummy_call): Correct padding of partial
	registers for big-endian.
@
text
@a2837 24
  /* Now that we have inferred any architecture settings that we
     can, try to inherit from the last ARM ABI.  */
  if (arches != NULL)
    {
      if (arm_abi == ARM_ABI_AUTO)
	arm_abi = gdbarch_tdep (arches->gdbarch)->arm_abi;

      if (fp_model == ARM_FLOAT_AUTO)
	fp_model = gdbarch_tdep (arches->gdbarch)->fp_model;
    }
  else
    {
      /* There was no prior ARM architecture; fill in default values.  */

      if (arm_abi == ARM_ABI_AUTO)
	arm_abi = ARM_ABI_APCS;

      /* We used to default to FPA for generic ARM, but almost nobody
	 uses that now, and we now provide a way for the user to force
	 the model.  So default to the most useful variant.  */
      if (fp_model == ARM_FLOAT_AUTO)
	fp_model = ARM_FLOAT_SOFT_FPA;
    }

d2843 2
a2844 1
      if (arm_abi != gdbarch_tdep (best_arch->gdbarch)->arm_abi)
d2847 2
a2848 1
      if (fp_model != gdbarch_tdep (best_arch->gdbarch)->fp_model)
d2978 11
d2994 1
a2994 1
  if (fp_model == ARM_FLOAT_SOFT_FPA || fp_model == ARM_FLOAT_FPA)
@


1.238
log
@	* gdbarch.sh (deprecated_register_size): Remove.
	* gdbarch.h, gdbarch.c: Regenerate.

	* arm-tdep.c (arm_push_dummy_call): Replace DEPRECATED_REGISTER_SIZE
	by INT_REGISTER_SIZE.
	(thumb_get_next_pc, arm_return_in_memory): Likewise.
	(arm_gdbarch_init): Do not call set_gdbarch_deprecated_register_size.
	* ia64-tdep.c (ia64_gdbarch_init): Do not call
	set_gdbarch_deprecated_register_size.
@
text
@d1292 2
@


1.237
log
@	* gdbarch.sh (read_pc): Add REGCACHE argument.  Remove PTID argument.
	(write_pc): Likewise.  Remove default implementation, add predicate.
	* gdbarch.c, gdbarch.h: Regenerate.
	* regcache.c (read_pc_pid): Use current regcache instead of calling
	read_register_pid.
	(write_pc_pid): Check gdbarch_write_pc predicate, implement default
	case inline.
	(generic_target_write_pc): Remove.
	* inferior.h (generic_target_write_pc): Remove.
	* frv-tdep.c (frv_gdbarch_init): Do not install it.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Likewise.
	* rs6000-tdep.c (rs6000_gdbarch_init): Likewise.
	* sh64-tdep.c (sh64_gdbarch_init): Likewise.
	* sh-tdep.c (sh_gdbarch_init): Likewise.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Likewise.

	* avr-tdep.c (avr_read_pc): Add REGCACHE argument.  Remove PTID
	argument.  Use REGCACHE instead of calling read_register_pid.
	* hppa-hpux-tdep.c (hppa_hpux_read_pc): Likewise.
	* hppa-tdep.c (hppa_read_pc): Likewise.
	* hppa-tdep.h (hppa_read_pc): Likewise.
	* ia64-tdep.c (ia64_read_pc): Likewise.
	* m32r-tdep.c (m32r_read_pc): Likewise.
	* mep-tdep.c (mep_read_pc): Likewise.
	* mn10300-tdep.c (mn10300_read_pc): Likewise.
	* spu-tdep.c (spu_read_pc): Likewise.

	* arm-tdep.c (arm_write_pc): Add REGCACHE argument.  Remove PTID
	argument.  Use REGCACHE instead of calling write_register_pid.
	* avr-tdep.c (avr_write_pc): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_write_pc): Likewise.
	* hppa-tdep.c (hppa_write_pc): Likewise.
	* hppa-tdep.h (hppa_write_pc): Likewise.
	* i386-linux-tdep.c (i386_linux_write_pc): Likewise.
	* amd64-linux-tdep.c (amd64_linux_write_pc): Likewise.
	* ia64-linux-tdep.c (ia64_linux_write_pc): Likewise.
	* ia64-tdep.c (ia64_write_pc): Likewise.
	* ia64-tdep.h (ia64_write_pc): Likewise.
	* m32r-tdep.c (m32r_write_pc): Likewise.
	* m88k-tdep.c (m88k_write_pc): Likewise.
	* mep-tdep.c (mep_write_pc): Likewise.
	* mips-tdep.c (mips_write_pc): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.
	* mn10300-tdep.c (mn10300_write_pc): Likewise.
	* sparc-tdep.c (sparc_write_pc): Likewise.
	* spu-tdep.c (spu_write_pc): Likewise.

	* mips-tdep.c (read_signed_register): Remove.
	(read_signed_register_pid): Likewise.
	(mips_read_pc): Add REGCACHE argument.  Remove PTID argument.
	Use REGCACHE instead of calling read_signed_register_pid.
@
text
@d1285 1
a1285 1
	  int partial_len = len < DEPRECATED_REGISTER_SIZE ? len : DEPRECATED_REGISTER_SIZE;
d1297 1
a1297 1
				    phex (regval, DEPRECATED_REGISTER_SIZE));
d1307 2
a1308 2
	      si = push_stack_item (si, val, DEPRECATED_REGISTER_SIZE);
	      nstack += DEPRECATED_REGISTER_SIZE;
d1625 1
a1625 1
      offset = bitcount (bits (inst1, 0, 7)) * DEPRECATED_REGISTER_SIZE;
d2141 1
a2141 1
     must be less than or equal to DEPRECATED_REGISTER_SIZE and the
d2158 1
a2158 1
  if (TYPE_LENGTH (type) > DEPRECATED_REGISTER_SIZE)
d2185 1
a2185 1
         DEPRECATED_REGISTER_SIZE and the offset of each addressable
a2970 2
  /* Integer registers are 4 bytes.  */
  set_gdbarch_deprecated_register_size (gdbarch, 4);
@


1.236
log
@	* gdbarch.sh (get_longjmp_target): Add FRAME argument.
	* gdbarch.c, gdbarch.h: Regenerate.
	* infrun.c (handle_inferior_event): Pass current frame to
	gdbarch_get_longjmp_target.

	* alpha-tdep.c (alpha_get_longjmp_target): Add FRAME argument.
	Read registers from FRAME instead of using read_register.
	Use get_frame_arch instead of current_gdbarch.
	* arm-tdep.c (arm_get_longjmp_target): Likewise.
	* i386-tdep.c (i386_get_longjmp_target): Likewise.
	* m68k-tdep.c (m68k_get_longjmp_target): Likewise.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target): Likewise.
	(mips64_linux_get_longjmp_target): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_get_longjmp_target): Likewise.
@
text
@d2591 1
a2591 1
arm_write_pc (CORE_ADDR pc, ptid_t ptid)
d2593 1
a2593 1
  write_register_pid (ARM_PC_REGNUM, pc, ptid);
d2598 2
a2599 1
      CORE_ADDR val = read_register_pid (ARM_PS_REGNUM, ptid);
d2601 1
a2601 1
	write_register_pid (ARM_PS_REGNUM, val | 0x20, ptid);
d2603 2
a2604 1
	write_register_pid (ARM_PS_REGNUM, val & ~(CORE_ADDR) 0x20, ptid);
@


1.235
log
@	* gdbarch.sh (skip_trampoline_code): Add FRAME argument.
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.c (generic_skip_trampoline_code): Add FRAME argument.
	* arch-utils.h (generic_skip_trampoline_code): Likewise.
	* infrun.c (handle_inferior_event): Pass current frame to
	gdbarch_skip_trampoline_code and skip_language_trampoline.

	* language.c (unk_lang_trampoline): Add FRAME argument.
	(skip_language_trampoline): Add FRAME argument.  Pass it to
	skip_trampoline callback.
	* language.h: Add forward declaration of struct frame_info.
	(struct language_defn): Add FRAME argument to skip_trampoline.
	(skip_language_trampoline): Add FRAME argument.
	* cp-abi.c (cplus_skip_trampoline): Add FRAME argument.  Pass it
	to skip_trampoline callback.
	* cp-abi.h: Add forward declaration of struct frame_info.
	(cplus_skip_trampoline): Add FRAME argument.
	(struct cp_abi_ops): Add FRAME argument to skip_trampoline callback.
	* gnu-v3-abi.c (gnuv3_skip_trampoline): Add FRAME argument.  Pass it
	to gdbarch_skip_trampoline_code.
	* objc-lang.c (objc_skip_trampoline): Add FRAME argument.  Pass it
	to gdbarch_skip_trampoline_code.

	* minsyms.c (find_solib_trampoline_target): Add FRAME argument.
	* symtab.h (find_solib_trampoline_target): Likewise.
	* obsd-tdep.c (obsd_skip_solib_resolver): Pass current frame to
	find_solib_trampoline_target.

	* arm-tdep.c (arm_skip_stub): Add FRAME argument.  Read registers
	from FRAME instead of calling read_register.

	* hppa-hpux-tdep.c (hppa_hpux_skip_trampoline_code): Add FRAME
	argument.  Read registers from FRAME instead of using read_register.
	* hppa-tdep.c (hppa_skip_trampoline_code): Likewise.
	* hppa-tdep.h (hppa_skip_trampoline_code): Add FRAME argument.

	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Add FRAME
	argument.

	* m32c-tdep.c (m32c_skip_trampoline_code): Add FRAME argument.

	* mips-tdep.c (mips_skip_trampoline_code): Add FRAME argument.  Read
	registers from FRAME instead of using read_signed_register.

	* ppc-linux-tdep.c (ppc_linux_skip_trampoline_code): Add FRAME
	argument.
	(ppc64_standard_linkage_target): Likewise.  Read registers from FRAME
	instead of using read_register.
	(ppc64_skip_trampoline_code): Add FRAME argument.  Pass it to
	ppc64_standard_linkage_target.
	* rs6000-tdep.c (rs6000_skip_trampoline_code): Add FRAME argument.
	Pass it to find_solib_trampoline_target.  Read registers from FRAME
	instead of using read_register.

	* xstormy16-tdep.c (xstormy16_skip_trampoline_code): Add FRAME
	argument.
@
text
@d2345 1
a2345 1
arm_get_longjmp_target (CORE_ADDR *pc)
d2349 1
a2349 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d2351 1
a2351 1
  jb_addr = read_register (ARM_A1_REGNUM);
@


1.234
log
@	* gdbarch.sh (software_single_step): Replace REGCACHE argument by
	FRAME argument.
	* gdbarch.c, gdbarch.h: Regenerate.
	* infrun.c (resume): Pass current frame to SOFTWARE_SINGLE_STEP.

	* alpha-tdep.c (alpha_next_pc): Add FRAME argument.  Retrieve
	registers from FRAME instead of using read_register.
	(alpha_software_single_step): Replace REGCACHE by FRAME.  Pass FRAME
	to alpha_next_pc.  Use get_frame_pc instead of read_pc.
	* alpha-tdep.h (alpha_software_single_step): Replace REGCACHE
	argument by FRAME.

	* arm-tdep.c (shifted_reg_val): Add FRAME argument.  Read registers
	from FRAME instead of using read_register.
	(thumb_get_next_pc): Likewise.
	(arm_get_next_pc): Likewise.
	(arm_software_single_step): Replace REGCACHE by FRAME.  Pass FRAME
	to arm_get_next_pc.  Use get_frame_pc instead of read_register.
	* arm-tdep.h (arm_software_single_step): Replace REGCACHE
	argument by FRAME.

	* cris-tdep.c (find_step_target): Add FRAME argument.  Read registers
	from FRAME instead of using read_register.
	(cris_software_single_step): Replace REGCACHE by FRAME.  Pass FRAME
	to find_step_target.

	* mips-tdep.c (mips32_next_pc): Add FRAME argument.  Read registers
	from FRAME instead of using read_register / read_signed_register.
	(extended_mips16_next_pc): Likewise.
	(mips16_next_pc): Likewise.
	(mips_next_pc): Likewise.
	(mips_software_single_step): Replace REGCACHE by FRAME.  Pass FRAME
	to mips_next_pc.  Use get_frame_pc instead of read_pc.
	* mips-tdep.h (mips_software_single_step): Replace REGCACHE
	argument by FRAME.

	* rs6000-tdep.c (branch_dest): Add FRAME argument.  Use it instead
	of current frame.  Read registers from FRAME.
	(deal_with_atomic_sequence): Add FRAME argument.  Pass it to
	branch_dest.  Use get_frame_pc instead of read_pc.
	(rs6000_software_single_step): Likewise.
	(bl_to_blrl_insn_p): Do not call branch_dest.
	* rs6000-tdep.h (rs6000_software_single_step): Replace REGCACHE
	argument by FRAME.

	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Add FRAME argument.
	Read registers from FRAME instead of current regcache.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Likewise.
	* sparcnbsd-tdep.c (sparcnbsd_step_trap): Likewise.
	* sparc-tdep.c (sparc_address_from_register): Remove.
	(sparc_analyze_control_transfer): Pass FRAME argument instead of
	GDBARCH.  Pass FRAME to step_trap callback.
	(sparc_step_trap): Add FRAME argument.
	(space_software_single_step): Replace REGCACHE by FRAME.  Pass FRAME
	to sparc_analyze_control_transfer.  Read registers from FRAME instead
	of calling sparc_address_from_register.
	* sparc-tdep.h (struct gdbarch_tdep): Add FRAME argument to
	step_trap callback.
	(sparc_address_from_register): Remove prototype.
	(sparc_software_single_step): Replace REGCACHE argument by FRAME.
	(sparcnbsd_step_trap): Add FRAME argument.

	* spu-tdep.c (spu_software_single_step): Replace REGCACHE argument
	by FRAME.  Read registers from FRAME instead of REGCACHE.
@
text
@d2383 1
a2383 1
arm_skip_stub (CORE_ADDR pc)
d2405 1
a2405 1
	  return read_register (regno);
@


1.233
log
@	* arm-tdep.c (arm_print_float_info): Use register value from FRAME
	instead of calling read_register.

	* avr-tdep.c (avr_push_dummy_call): Write to REGCACHE instead of
	calling write_register.

	* hppa-tdep.c (hppa32_push_dummy_call): Write to REGCACHE instead of
	calling write_register.

	* ia64-tdep.c (find_func_descr): Add REGCACHE parameter.  Use it
	instead of calling read_register.
	(ia64_push_dummy_call): Update call to find_func_descr.  Use REGCACHE
	instead of calling read_register and write_register.

	* m32r-tdep.c (m32r_linux_supply_gregset): Use REGCACHE parameter
	instead of current_regcache.

	* mn10300-tdep.c (mn10300_push_dummy_call): Write to REGCACHE instead
	of calling write_register.
	* mn10300-linux-tdep.c (am33_supply_fpregset_method): Use REGCACHE
	parameter instead of current_regcache.

	* mips-tdep.c (mips2_fp_compat): Add FRAME parameter.  Use it
	instead of calling read_register.
	(mips_read_fp_register_double, mips_print_fp_register): Update calls.
	(mips_eabi_push_dummy_call): Use REGCACHE instead of write_register.
	(mips_n32n64_push_dummy_call): Likewise.
	(mips_o32_push_dummy_call): Likewise.
	(mips_o64_push_dummy_call): Likewise.

	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call): Use REGCACHE
	parameter instead of current_regcache.

	* xtensa-tdep.c (xtensa_register_write_masked): Add REGCACHE parameter.
	Use it instead of read_register and write_register.
	(xtensa_register_read_masked): Likewise.
	(xtensa_pseudo_register_read): Update call.
	(xtensa_pseudo_register_write): Likewise.
	(xtensa_frame_cache): Use register values unwound from NEXT_FRAME
	instead of calling read_register.
	(xtensa_push_dummy_call): Update comment.
@
text
@d1550 2
a1551 2
shifted_reg_val (unsigned long inst, int carry, unsigned long pc_val,
		 unsigned long status_reg)
d1560 2
a1561 1
      shift = (rs == 15 ? pc_val + 8 : read_register (rs)) & 0xFF;
d1569 1
a1569 1
	 : read_register (rm));
d1612 1
a1612 1
thumb_get_next_pc (CORE_ADDR pc)
d1626 1
a1626 1
      sp = read_register (ARM_SP_REGNUM);
d1634 1
a1634 1
      unsigned long status = read_register (ARM_PS_REGNUM);
d1657 1
a1657 1
	nextpc = read_register (bits (inst1, 3, 6));
d1668 1
a1668 1
arm_get_next_pc (CORE_ADDR pc)
d1676 1
a1676 1
    return thumb_get_next_pc (pc);
d1680 1
a1680 1
  status = read_register (ARM_PS_REGNUM);
d1708 2
a1709 1
		result = (rn == 15) ? pc_val + 8 : read_register (rn);
d1722 2
a1723 1
	    operand1 = (rn == 15) ? pc_val + 8 : read_register (rn);
d1733 1
a1733 1
	      operand2 = shifted_reg_val (this_instr, c, pc_val, status);
d1819 2
a1820 1
		  base = (rn == 15) ? pc_val + 8 : read_register (rn);
d1827 1
a1827 1
		       ? shifted_reg_val (this_instr, c, pc_val, status)
d1869 2
a1870 1
		    read_register (bits (this_instr, 16, 19));
d1920 1
a1920 1
arm_software_single_step (struct regcache *regcache)
d1926 1
a1926 1
  CORE_ADDR next_pc = arm_get_next_pc (read_register (ARM_PC_REGNUM));
@


1.232
log
@2007-06-09  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (ADDR_BITS_REMOVE): Replace by gdbarch_addr_bits_remove.
	* value.c (value_as_address): Likewise (comment).
	* remote-mips.c (common_breakpoint): Likewise.
	* regcache.c (read_pc_pid): Likewise.
	* printcmd.c (do_one_display): Likewise.
	* monitor.c (monitor_write_memory, monitor_read_memory)
	(monitor_insert_breakpoint): Likewise.
	* mips-tdep.c (heuristic_proc_start): Likewise.
	* infrun.c (insert_step_resume_breakpoint_at_frame)
	(insert_step_resume_breakpoint_at_caller): Likewise.
	* buildsym.c (record_line): Likewise.
	* arm-tdep.c (arm_scan_prologue, thumb_get_next_pc)
	(arm_get_next_pc): Likewise.
	* armnbsd-nat.c (arm_supply_gregset, fetch_register, store_register)
	(store_regs): Likewise.
	* arm-linux-tdep.c (arm_linux_supply_gregset): Likewise.
	* arm-linux-nat.c (fetch_register, fetch_regs): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d1366 1
a1366 1
  unsigned long status = read_register (ARM_FPS_REGNUM);
@


1.231
log
@2007-06-09  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (REGISTER_NAME): Replace by gdbarch_register_name.
	* tracepoint.c (scope_info): Likewise.
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_register_reggroup_p): Likewise.
	* sh64-tdep.c (sh64_do_fp_register, sh64_do_register)
	(sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_reggroup_p): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	* remote.c (packet_reg): Likewise (comment).
	* reggroups.c (default_register_reggroup_p): Likewise.
	* regcache.c (regcache_dump): Likewise.
	* printcmd.c (address_info): Likewise.
	* ppc-linux-nat.c (fetch_register, store_register): Likewise.
	* mt-dep.c (mt_registers_info): Likewise.
	* mn10300-tdep.c (mn10300_dwarf2_reg_to_regnum): Likewise (comment).
	* mips-tdep.c (mips_register_reggroup_p, mips_read_fp_register_single)
	(mips_read_fp_register_double, mips_print_fp_register)
	(mips_print_register, print_gp_register_row, mips_print_registers_info)
	(mips_register_sim_regno): Likewise.
	* m68klinux-nat.c (regmap, fetch_register, store_register): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_register)
	(inf_ptrace_store_register): Likewise.
	* infcmd.c (default_print_registers_info): Likewise.
	* ia64-linux-nat.c (ia64_linux_fetch_register)
	(ia64_linux_store_register): Likewise.
	* i386-linux-nat.c (fetch_register, store_register): Likewise.
	* i386gnu-nat.c (gnu_fetch_registers, gnu_store_registers): Likewise.
	* hppa-linux-nat.c (fetch_register, store_register): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register)
	(hppa_hpux_store_register): Likewise.
	* findvar.c (locate_var_value): Likewise.
	* dwarf2loc.c (locexpr_describe_location): Likewise.
	* dwarf2-frame.c (execute_cfa_program): Likewise.
	* arm-tdep.c (arm_push_dummy_call): Likewise.
	* arch-utils.c (legacy_register_sim_regno): Likewise.
	* alpha-tdep.c (alpha_register_reggroup_p): Likewise.
	* alpha-nat.c (fetch_osf_core_registers): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers, mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d727 2
a728 1
          prologue_start = ADDR_BITS_REMOVE (return_value) - 8;
d1627 1
a1627 1
      nextpc = ADDR_BITS_REMOVE (nextpc);
d1658 1
a1658 1
      nextpc = ADDR_BITS_REMOVE (nextpc);
d1708 2
a1709 1
		nextpc = (CORE_ADDR) ADDR_BITS_REMOVE (result);
d1790 2
a1791 1
	    nextpc = (CORE_ADDR) ADDR_BITS_REMOVE (result);
d1834 1
a1834 1
		  nextpc = ADDR_BITS_REMOVE (nextpc);
d1871 2
a1872 1
		  nextpc = ADDR_BITS_REMOVE (nextpc);
d1888 1
a1888 1
	    nextpc = ADDR_BITS_REMOVE (nextpc);
@


1.230
log
@2007-05-31  Markus Deuling  <deuling@@de.ibm.com>

	* xtensa-tdep.c (XTENSA_IS_ENTRY, extract_call_winsize)
	(xtensa_register_write_masked, xtensa_register_read_masked)
	(xtensa_extract_return_value, xtensa_store_return_value
	(xtensa_push_dummy_call, xtensa_breakpoint_from_pc): Replace
	TARGET_BYTE_ORDER by gdbarch_byte_order.
	* sh-tdep.c (sh_breakpoint_from_pc, gdb_print_insn_sh)
	(sh_justify_value_in_reg, sh_next_flt_argreg, sh_push_dummy_call_fpu)
	(sh_extract_return_value_fpu, sh_store_return_value_fpu): Likewise.
	* sh64-tdep.c (sh64_breakpoint_from_pc, gdb_print_insn_sh64)
	(sh64_push_dummy_call, sh64_extract_return_value)
	(sh64_store_return_value, sh64_register_convert_to_virtual)
	(sh64_register_convert_to_raw, sh64_pseudo_register_read)
	(sh64_pseudo_register_write, sh64_do_fp_register)
	(sh64_frame_prev_register): Likewise.
	* score-tdep.c (score_print_insn, score_breakpoint_from_pc)
	(score_return_value, score_push_dummy_call, score_fetch_inst): Likewise.
	* rs6000-tdep.c (rs6000_breakpoint_from_pc, rs6000_push_dummy_call)
	(e500_move_ev_register,gdb_print_insn_powerpc): Likewise.
	* remote-m32r-sdi.c (m32r_resume, m32r_wait): Likewise.
	* ppc-linux-nat.c (store_register): Likewise.
	* nto-tdep.c (nto_find_and_open_solib)
	(nto_init_solib_absolute_prefix): Likewise.
	* mips-tdep.c (mips_pseudo_register_read, mips_pseudo_register_write)
	(mips_convert_register_p, mips_eabi_push_dummy_call)
	(mips_n32n64_push_dummy_call, mips_n32n64_return_value)
	(mips_o32_push_dummy_call, mips_o32_return_value)
	(mips_o64_push_dummy_call, mips_o64_return_value, mips_o64_return_value)
	(mips_read_fp_register_single, mips_read_fp_register_double)
	(mips_print_register, print_gp_register_row, gdb_print_insn_mips)
	(mips_breakpoint_from_pc): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_sigtramp_offset): Likewise.
	* mips-linux-tdep.c (mips64_supply_fpregset, mips64_fill_fpregset)
	(mips_linux_o32_sigframe_init): Likewise.
	* m32r-tdep.c (m32r_memory_insert_breakpoint)
	(m32r_memory_remove_breakpoint, m32r_breakpoint_from_pc): Likewise.
	* libunwind-frame.c (libunwind_frame_cache, libunwind_frame_sniffer)
	(libunwind_sigtramp_frame_sniffer, libunwind_get_reg_special): Likewise.
	* iq2000-tdep.c (iq2000_breakpoint_from_pc): Likewise.
	* coffread.c (process_coff_symbol): Likewise.
	* arm-tdep.c (convert_from_extended, convert_to_extended)
	(gdb_print_insn_arm): Likewise.
@
text
@d1214 2
a1215 1
			    REGISTER_NAME (argreg), paddr (struct_addr));
d1293 3
a1295 1
				    argnum, REGISTER_NAME (argreg),
@


1.229
log
@2007-05-31  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (NUM_REGS): Replace by gdbarch_num_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_registers)
	(inf_ptrace_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* i386-linux-nat.c (supply_gregset, fill_gregset)
	(i386_linux_fetch_inferior_registers)
	(i386_linux_store_inferior_registers): Likewise.
	* remote.c (init_remote_state,packet_reg_from_regnum)
	(packet_reg_from_pnum,process_g_packet,remote_fetch_registers)
	(remote_prepare_to_store,store_registers_using_G)
	(remote_store_registers,remote_arch_state): Likewise.
	* tracepoint.c (encode_actions): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* tui/tui-regs.c (tui_show_register_group)
	(tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* xtensa-tdep.c (xtensa_register_name,xtensa_register_type)
	(xtensa_reg_to_regnum,xtensa_pseudo_register_read)
	(xtensa_pseudo_register_write,xtensa_register_reggroup_p): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers)
	(do_win32_store_inferior_registers,fetch_elf_core_registers
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target-descriptions.c (tdesc_use_registers): Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_do_pseudo_register,sh64_print_register)
	(sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* rs6000-nat.c (fetch_register,store_register): Likewise.
	* remote-sim.c (one2one_register_sim_regno,gdbsim_fetch_register)
	(gdbsim_fetch_register,gdbsim_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers,mips_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers)
	(m32r_store_registers): Likewise.
	* reggroups.c (default_register_reggroup_p): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save)
	(regcache_restore,regcache_dump): Likewise.
	* monitor.c (monitor_fetch_registers,monitor_store_registers): Likewise.
	* mips-tdep.c (mips_xfer_register,mips_register_name)
	(mips_register_reggroup_p,mips_pseudo_register_read)
	(mips_pseudo_register_write,mips_convert_register_p,mips_register_type)
	(mips_unwind_pc,mips_unwind_sp,mips_unwind_dummy_id,set_reg_offset)
	(mips16_scan_prologue,mips_insn16_frame_cache,reset_saved_regs)
	(mips32_scan_prologue,mips_insn32_frame_cache,read_next_frame_reg)
	(mips_n32n64_return_value,mips_o32_return_value,mips_o64_return_value)
	(print_gp_register_row,mips_print_registers_info)
	(mips_stab_reg_to_regnum,mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_register_sim_regno): Likewise.
	* mips-linux-tdep.c (mips_linux_o32_sigframe_init)
	(mips_linux_n32n64_sigframe_init): Likewise.
	* mips-linux-nat.c (mips_linux_register_addr)
	(mips64_linux_register_addr): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* mips64obsd-tdep.c (mips64obsd_sigframe_init): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache(: Likewise.
	* m32r-tdep.c (m32r_frame_unwind_cache): Likewise.
	* ia64-linux-nat.c (ia64_register_addr,ia64_cannot_fetch_register)
	(ia64_cannot_store_register,ia64_linux_fetch_registers)
	(ia64_linux_store_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Likewise.
	* h8300-tdep.c (E_PSEUDO_CCR_REGNUM,E_PSEUDO_EXR_REGNUM)
	(h8300_init_frame_cache,h8300_frame_cache,h8300_frame_prev_register)
	(h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache)
	(dwarf2_frame_state_alloc_regs): Likewise.
	* cris-tdep.c (cris_register_size,cris_cannot_fetch_register)
	(cris_cannot_store_register,crisv32_cannot_fetch_register)
	(crisv32_cannot_store_register,cris_register_name): Likewise.
	* avr-tdep.c (avr_frame_unwind_cache): Likewise.
	* arch-utils.c (legacy_register_sim_regno)
	(legacy_virtual_frame_pointer): Likewise.
	* arm-tdep.c (arm_make_prologue_cache,arm_register_sim_regno):Likewise.
	* arm-tdep.h: Likewise (comment).
	* frv-tdep.c (frv_register_sim_regno): Likewise.
	* m68klinux-nat.c (old_fetch_inferior_registers)
	(old_store_inferior_registers): Likewise.
	* m32c-tdep.c (m32c_virtual_frame_pointer): Likewise.
	* irix5-nat.c (fetch_core_registers): Likewise.
	* hppa-tdep.c (hppa_frame_cache): Likewise.
	* hppa-linux-nat.c (hppa_linux_register_addr)
	(hppa_linux_fetch_inferior_registers)
	(hppa_linux_store_inferior_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_inferior_registers)
	(hppa_hpux_store_inferior_registers): Likewise.
	* amd64-nat.c (amd64_native_gregset_reg_offset)
	(amd64_supply_native_gregset,amd64_collect_native_gregset): Likewise.
	* dbug-rom.c (dbug_regname): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache)
	(HARD_PAGE_REGNUM (comment)): Likewise.
	* gdbarch.sh (NUM_PSEUDO_REGS): Replace by gdbarch_num_pseudo_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
	* tui/tui-regs.c (tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_print_register,sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save
	(regcache_restore,regcache_dump): Likewise.
	* mips-tdep.c (print_gp_register_row,mips_print_registers_info)
	(mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_stab_reg_to_regnum): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache): Likewise.
	* frame.h (SIZEOF_FRAME_SAVED_REGS): Likewise.
	* xtensa-tdep.c (xtensa_register_type,xtensa_reg_to_regnum)
	(xtensa_pseudo_register_read,xtensa_pseudo_register_write): Likewise.
	* parse.c: Remove comment.
	* gdbarch.c, gdbarch.h: Regenerate
@
text
@d1473 1
a1473 1
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
d1486 1
a1486 1
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
d1957 1
a1957 1
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
@


1.228
log
@	* config/arm/embed.mt (DEPRECATED_TM_FILE): Set to tm-arm.h.
	* config/arm/tm-embed.h: Delete file.

	* arm-tdep.h (arm_software_single_step): Declare.
	* arm-tdep.c (arm_software_single_step): Make global.
	(arm_gdbarch_init): Move set_gdbarch_software_single_step call
	from here to ...
	* arm-linux-tdep.c (arm_linux_init_abi): ... here ...
	* armnbsd-tdep.c (arm_netbsd_init_abi_common): ... here ...
	* armobsd-tdep.c (armobsd_init_abi): ... here ...
	* arm-wince-tdep.c (arm_wince_init_abi): ... and here.

	* arm-tdep.c (ARM_LE_BREAKPOINT, ARM_BE_BREAKPOINT): No longer
	allow defines to be overriden by TM file.
	(THUMB_LE_BREAKPOINT, THUMB_BE_BREAKPOINT): Likewise.  Also,
	change default to {0xbe,0xbe}.
	* armobsd-tdep.c (arm_obsd_thumb_le_breakpoint,
	arm_obsd_thumb_be_breakpoint): New global variables.
	(armobsd_init_abi): Override tdep->thumb_breakpoint and
	tdep->thumb_breakpoint_size.
	* arm-wince-tdep.c (arm_wince_thumb_le_breakpoint): New variable.
	(arm_wince_init_abi): Override tdep->thumb_breakpoint and
	tdep->thumb_breakpoint_size.

	* arm-tdep.c (arm_gdbarch_init): Add set_gdbarch_skip_trampoline_code.
@
text
@d911 1
a911 1
  for (reg = 0; reg < NUM_REGS; reg++)
d1437 1
a1437 1
  gdb_assert (reg >= 0 && reg < NUM_REGS);
@


1.227
log
@	* gdbarch.sh (software_single_step): Remove "insert_breakpoints_p" and
	"sig" arguments, add "regcache" argument.
	* gdbarch.c, gdbarch.h: Regenerate.

	* infrun.c (resume): Update SOFTWARE_SINGLE_STEP call arguments.
	(handle_inferior_event): Call remove_single_step_breakpoints directly
	instead of calling SOFTWARE_SINGLE_STEP to remove breakpoints.

	* alpha-tdep.c (alpha_software_single_step): Update argument list.
	Remove handling of !insert_breakpoints_p case.
	* arm-tdep.c (arm_software_single_step): Likewise.
	* cris-tdep.c (cris_software_single_step): Likewise.
	* mips-tdep.c (mips_software_single_step): Likewise.
	* rs6000-tdep.c (rs6000_software_single_step): Likewise.
	* sparc-tdep.c (sparc_software_single_step): Likewise.
	* spu-tdep.c (spu_software_single_step): Likewise.

	* alpha-tdep.h (alpha_software_single_step): Update prototype.
	* mips-tdep.h (mips_software_single_step): Likewise.
	* rs6000-tdep.h (rs6000_software_single_step): Likewise.
	* sparc-tdep.h (sparc_software_single_step): Likewise.
@
text
@d1907 1
a1907 1
static int
a1991 4

/* NOTE rearnsha 2002-02-18: for now we allow a non-multi-arch gdb to
   override these definitions.  */
#ifndef ARM_LE_BREAKPOINT
a1992 2
#endif
#ifndef ARM_BE_BREAKPOINT
d1994 2
a1995 7
#endif
#ifndef THUMB_LE_BREAKPOINT
#define THUMB_LE_BREAKPOINT {0xfe,0xdf}
#endif
#ifndef THUMB_BE_BREAKPOINT
#define THUMB_BE_BREAKPOINT {0xdf,0xfe}
#endif
d2931 3
a2963 4
  /* Single stepping.  */
  /* XXX For an RDI target we should ask the target if it can single-step.  */
  set_gdbarch_software_single_step (gdbarch, arm_software_single_step);

@


1.226
log
@2007-04-12  Luis Machado  <luisgpm@@br.ibm.com>

	* gdbarch.sh (software_single_step): Change the return type
	from void to int and reformatted some comments to <= 80
	columns.
	* gdbarch.c, gdbarch.h: Regenerated.
	* alpha-tdep.c (alpha_software_single_step): Likewise.
	* alpha-tdep.h (alpha_software_single_step): Likewise.
	* arm-tdep.c (arm_software_single_step): Likewise.
	* cris-tdep.c (cris_software_single_step): Likewise.
	* mips-tdep.c (mips_software_single_step): Likewise.
	* mips-tdep.h (mips_software_single_step): Likewise.
	* rs6000-tdep.c (rs6000_software_single_step): Likewise.
	* rs6000-tdep.h (rs6000_software_single_step): Likewise.
	* sparc-tdep.c (sparc_software_single_step): Likewise.
	* sparc-tdep.h (sparc_software_single_step): Likewise.
	* spu-tdep.c (spu_software_single_step): Likewise.
	* infrun.c (resume): Check the return value from SOFTWARE_SINGLE_STEP
	and act accordingly.
@
text
@d1905 1
a1905 4
   and breakpoint it.

   single_step() is also called just after the inferior stops.  If we
   had set up a simulated single-step, we undo our damage.  */
d1908 1
a1908 1
arm_software_single_step (enum target_signal sig, int insert_bpt)
d1914 2
a1915 8
  if (insert_bpt)
    {
      CORE_ADDR next_pc = arm_get_next_pc (read_register (ARM_PC_REGNUM));

      insert_single_step_breakpoint (next_pc);
    }
  else
    remove_single_step_breakpoints ();
@


1.225
log
@gdb/

	* configure.tgt: Move mips*-*-pe and sh*-*-pe to
	the obsoletion stanza.
	* NEWS: Mention deleted targets.

	* config/sh/tm-wince.h: Remove.
	* config/sh/wince.mt: Remove.
	* config/mips/tm-wince.h: Remove.
	* config/mips/wince.mt: Remove.

	* wince.c: Remove.
	* wince-stub.c: Remove.
	* wince-stub.h: Remove.
	* Makefile.in (wince.o): Remove rule.
	(wince-stub.o): Likewise.

	* mips-tdep.c (mips_next_pc): Make static.
	* mips-tdep.h (mips_next_pc): Remove declaration.
	* arm-tdep.c (arm_pc_is_thumb): Make static.
	(thumb_get_next_pc): Likewise.
	(arm_get_next_pc): Likewise.
	* arm-tdep.h (arm_pc_is_thumb_dummy): Remove declaration.
	(arm_pc_is_thumb): Likewise.
	(thumb_get_next_pc): Likewise.
	(arm_get_next_pc): Likewise.

gdb/doc/

	* gdb.texinfo (WinCE): Delete obsolete subsection.
@
text
@d1910 1
a1910 1
static void
d1925 2
@


1.225.2.1
log
@Daniel Jacobowitz' update to Michael Snyder's reverse debugging patches
@
text
@a890 39
/* This function tries to guess whether we are in the epilogue of an
   ARM function.  We need to detect whether the stack frame has
   already been destroyed - if it has, then neither the prologue
   scanner nor GCC's unwind tables will be valid.  This is very hokey
   and generally unsafe.  */

static int
arm_scan_epilogue (struct frame_info *next_frame,
		   struct arm_prologue_cache *cache)
{
  unsigned int insn;
  gdb_byte buf[4];
  CORE_ADDR prev_pc = frame_pc_unwind (next_frame);

  /* Assume there is no frame until proven otherwise.  */
  if (cache != NULL)
    {
      cache->framereg = ARM_SP_REGNUM;
      cache->framesize = 0;
      cache->frameoffset = 0;
    }

  /* Check for Thumb epilogue.  */
  if (arm_pc_is_thumb (prev_pc))
    /* Not yet implemented.  */
    return 0;

  if (target_read_memory (prev_pc, buf, 4) != 0)
    return 0;
  insn = extract_unsigned_integer (buf, 4);

  if (insn == 0xe12fff1e) /* bx lr */
    /* If this is a return, we have no frame left and no saved
       registers.  */
    return 1;

  return 0;
}

d901 1
a901 2
  if (arm_scan_epilogue (next_frame, cache) == 0)
    arm_scan_prologue (next_frame, cache);
a997 9
static const struct frame_unwind *
arm_epilogue_unwind_sniffer (struct frame_info *next_frame)
{
  if (arm_scan_epilogue (next_frame, NULL))
    return &arm_prologue_unwind;
  else
    return NULL;
}

a2998 1
  frame_unwind_append_sniffer (gdbarch, arm_epilogue_unwind_sniffer);
@


1.224
log
@	* dwarf2-frame.c (dwarf2_frame_cache, dwarf2_frame_this_id)
	(dwarf2_frame_sniffer): Update.
	(dwarf2_signal_frame_this_id): New function.
	(dwarf2_signal_frame_unwind): Use it.
	(dwarf2_frame_base_sniffer): Use frame_unwind_address_in_block.
	* frame.c (frame_func_unwind): Add this_type argument.
	(get_frame_func): Update.
	(frame_unwind_address_in_block): Add this_type argument and check it.
	Fix a typo.
	(get_frame_address_in_block): Update.
	* frame.h (enum frame_type): Move higher in the file.
	(frame_unwind_address_in_block, frame_func_unwind): Add enum frame_type
	argument.

	* alpha-mdebug-tdep.c, alpha-tdep.c, amd64-tdep.c, amd64obsd-tdep.c,
	arm-tdep.c, avr-tdep.c, cris-tdep.c, frv-tdep.c, h8300-tdep.c,
	hppa-tdep.c, i386-tdep.c, i386obsd-tdep.c, ia64-tdep.c,
	libunwind-frame.c, m32c-tdep.c, m32r-linux-tdep.c, m32r-tdep.c,
	m68hc11-tdep.c, m68k-tdep.c, m88k-tdep.c, mips-mdebug-tdep.c,
	mips-tdep.c, mn10300-tdep.c, mt-tdep.c, rs6000-tdep.c, s390-tdep.c,
	score-tdep.c, sh-tdep.c, sh64-tdep.c, sparc-tdep.c,
	sparc64obsd-tdep.c, spu-tdep.c, v850-tdep.c, vax-tdep.c,
	xstormy16-tdep.c, xtensa-tdep.c: Update calls to
	frame_func_unwind and frame_unwind_address_in_block to specify
	the frame type.  Use frame_unwind_address_in_block instead of
	frame_pc_unwind in sniffers.

	* gdb.arch/i386-signal.c, gdb.arch/i386-signal.exp: New files.
@
text
@d220 1
a220 1
int
d1606 1
a1606 1
CORE_ADDR
d1662 1
a1662 1
CORE_ADDR
@


1.223
log
@	* arm-tdep.c (arm_scan_prologue): Do not record FPA register saves
	if there are no FPA registers.
	(arm_dwarf_reg_to_regnum): New function.
	(arm_register_type, arm_register_name): Return minimal values for
	unsupported registers.
	(arm_register_sim_regno): Handle iWMMXt registers.
	(arm_gdbarch_init): Record missing FPA registers if indicated by
	a target description.  Recognize iWMMXt registers.  Only register
	"info float" for FPA.  Use ARM_NUM_REGS.  Register
	arm_dwarf_reg_to_regnum.
	* arm-tdep.h (enum gdb_regnum): Add ARM_NUM_REGS and iWMMXt
	constants.
	(struct gdbarch_tdep): Add have_fpa_registers.
	* features/xscale-iwmmxt.xml: Update capitalization.
	* regformats/arm-with-iwmmxt.dat: Regenerated.

	* src/gdb/doc/gdb.texinfo (Standard Target Features): Mention
	case insensitivity.
	(ARM Features): Describe org.gnu.gdb.xscale.iwmmxt.

	* gdb.arch/iwmmxt-regs.c, gdb.arch/iwmmxt-regs.exp: Update
	register capitalization.
@
text
@d934 1
a934 1
  func = frame_func_unwind (next_frame);
d1039 1
d1042 2
a1043 1
  if (in_plt_section (frame_unwind_address_in_block (next_frame), NULL)
@


1.222
log
@	* Makefile.in (arm-tdep.o, eval.o, target-descriptions.o)
	(xml-tdesc.o): Update.
	* xml-support.c: Add a comment.
	(gdb_xml_enums_boolean): New variable.
	(gdb_xml_parse_attr_enum): Use strcasecmp.
	* xml-support.h (gdb_xml_enums_boolean): Declare.
	* xml-tdesc.c (struct tdesc_parsing_data): Record current_feature,
	next_regnum, and current_union.
	(tdesc_start_feature, tdesc_start_reg, tdesc_start_union)
	(tdesc_end_union, tdesc_start_field, tdesc_start_vector)
	(field_attributes, union_children, reg_attributes, union_attributes)
	(vector_attributes, feature_attributes, feature_children): New.
	(target_children): Make static.  Add <feature>.
	(tdesc_elements): Make static.
	* target-descriptions.c (struct tdesc_reg, tdesc_reg_p, type_p)
	(struct tdesc_feature, tdesc_feature_p): New types.
	(struct target_desc): Add features member.
	(struct tdesc_arch_data, tdesc_data): New.
	(target_find_description): Clarify error message.  Warn about
	ignored register descriptions.
	(tdesc_has_registers, tdesc_find_feature, tdesc_feature_name)
	(tdesc_named_type, tdesc_data_init, tdesc_data_alloc)
	(tdesc_data_cleanup, tdesc_numbered_register)
	(tdesc_numbered_register_choices, tdesc_find_register)
	(tdesc_register_name, tdesc_register_type)
	(tdesc_remote_register_number, tdesc_register_reggroup_p)
	(set_tdesc_pseudo_register_name, set_tdesc_pseudo_register_type)
	(set_tdesc_pseudo_register_reggroup_p, tdesc_use_registers)
	(tdesc_free_reg, tdesc_create_reg, tdesc_free_feature)
	(tdesc_create_feature, tdesc_record_type): New.
	(free_target_description): Free features.
	(_initialize_target_descriptions): Initialize tdesc_data.
	* arch-utils.c (default_remote_register_number): New.
	* arch-utils.h (default_remote_register_number): New prototype.
	* target-descriptions.h (set_tdesc_pseudo_register_name)
	(set_tdesc_pseudo_register_type, set_tdesc_pseudo_register_reggroup_p)
	(tdesc_use_registers, tdesc_data_alloc, tdesc_data_cleanup)
	(tdesc_numbered_register, tdesc_numbered_register_choices)
	(tdesc_has_registers, tdesc_find_feature, tdesc_feature_name)
	(tdesc_named_type, tdesc_create_feature, tdesc_record_type)
	(tdesc_create_reg): Declare.
	* gdbarch.sh (remote_register_number): New entry.
	* gdbarch.c, gdbarch.h: Regenerate.
	* remote.c (init_remote_state): Use gdbarch_remote_register_number.
	* features/gdb-target.dtd: Add feature, reg, vector, union, and field.

	* arm-tdep.c (arm_register_aliases): New.
	(arm_register_name_strings): Rename to...
	(arm_register_names): ...this.  Make const.  Delete the old version.
	(current_option, arm_register_byte): Delete.
	(set_disassembly_style): Simplify.  Do not adjust arm_register_names.
	(value_of_arm_user_reg): New.
	(arm_gdbarch_init): Verify any described registers.  Call
	tdesc_use_registers.  Don't use arm_register_byte.  Create aliases
	for standard register names.
	(_initialize_arm_tdep): Do not adjust arm_register_names.
	* user-regs.c (struct user_reg): Add baton member.
	(append_user_reg, user_reg_add_builtin, user_regs_init)
	(user_reg_add, value_of_user_reg): Use a baton for user
	register functions.
	* std-regs.c: Update.
	* user-regs.h (user_reg_read_ftype, user_reg_add_builtin)
	(user_reg_add): Add baton argument.
	* NEWS: Mention target description register support.
	* features/arm-core.xml, features/arm-fpa.xml: New.
	* eval.c (evaluate_subexp_standard): Allow ptype $register
	when the program is not running.

	* gdb.texinfo (-target-disconnect): Use @@smallexample.
	(Requirements): Add anchor for Expat.  Update description.
	(Target Descriptions): Mention Expat.
	(Target Description Format): Document new elements.  Use
	@@smallexample.
	(Predefined Target Types, Standard Target Features): New sections.
	* doc/gdbint.texinfo (Target Descriptions): New section.

	* gdb.xml/single-reg.xml, gdb.xml/tdesc-regs.exp,
	gdb.xml/core-only.xml, gdb.xml/extra-regs.xml: New files.
@
text
@d835 2
a836 1
      else if ((insn & 0xffff7fff) == 0xed6d0103)	/* stfe f?, [sp, -#c]! */
d842 2
a843 1
      else if ((insn & 0xffbf0fff) == 0xec2d0200)	/* sfmfd f0, 4, [sp!] */
d1388 4
d1396 34
d1437 9
d2534 5
d2654 1
d2711 37
d2891 1
a2953 1
  set_gdbarch_print_float_info (gdbarch, arm_print_float_info);
d2957 1
a2957 1
  set_gdbarch_num_regs (gdbarch, NUM_GREGS + NUM_FREGS + NUM_SREGS);
d2960 5
d2966 2
@


1.221
log
@	* doublest.c (floatformat_from_length): Use the right element from
	gdbarch floatformats.
	(floatformat_from_type, extract_typed_floating)
	(store_typed_floating): Likewise.
	* doublest.h: Remove declarations for undefined floatformat arrays.
	* gdbarch.sh (float_format, double_format, long_double_format): Change
	to pairs.
	(pformat): Update for pairs.
	* gdbarch.c, gdbarch.h: Regenerated.
	* gdbtypes.c (floatformats_ieee_single, floatformats_ieee_double)
	(floatformats_ieee_double_littlebyte_bigword)
	(floatformats_i387_ext, floatformats_m68881_ext, floatformats_arm_ext)
	(floatformats_ia64_spill, floatformats_ia64_quad, floatformats_vax_f)
	(floatformats_vax_d): New variables.
	(builtin_type_ieee_single, builtin_type_ieee_double)
	(builtin_type_arm_ext, builtin_type_ia64_spill)
	(builtin_type_ia64_quad): Replace arrays with individual types.
	(builtin_type_ieee_single_big, builtin_type_ieee_single_little)
	(builtin_type_ieee_double_big, builtin_type_ieee_double_little)
	(builtin_type_ieee_double_littlebyte_bigword, builtin_type_i960_ext)
	(builtin_type_m88110_ext, builtin_type_m88110_harris_ext)
	(builtin_type_arm_ext_big, builtin_type_arm_ext_littlebyte_bigword)
	(builtin_type_ia64_spill_big, builtin_type_ia64_spill_little)
	(builtin_type_ia64_quad_big, builtin_type_ia64_quad_little): Delete
	unused and endian-specific types.
	(recursive_dump_type): Update for floatformat pairs.
	(build_flt): Move higher.  Handle bit == -1.  Take a floatformat pair.
	(build_gdbtypes): Use build_flt.
	(_initialize_gdbtypes): Update set of initialized types.
	* gdbtypes.h: Update declarations to match gdbtypes.c.
	(struct main_type): Store a pointer to two floatformats.
	* arch-utils.c (default_float_format, default_double_format): Delete.
	* arch-utils.h (default_float_format, default_double_format): Delete.

	* arm-tdep.c, avr-tdep.c, hppa-tdep.c, hppabsd-tdep.c, i386-tdep.c,
	ia64-tdep.c,  iq2000-tdep.c, m68k-tdep.c, m88k-tdep.c,
	mips-linux-tdep.c, mips-tdep.c, mt-tdep.c, ppcobsd-tdep.c,
	sparc-linux-tdep.c, sparc-tdep.c, sparcnbsd-tdep.c, spu-tdep.c,
	vax-tdep.c, alpha-tdep.c, ppc-sysv-tdep.c: Update.
@
text
@d44 2
d108 50
a157 4
/* We have more registers than the disassembler as gdb can print the value
   of special registers as well.
   The general register names are overwritten by whatever is being used by
   the disassembler at the moment. We also adjust the case of cpsr and fps.  */
d159 1
a159 2
/* Initial value: Register names used in ARM's ISA documentation.  */
static char * arm_register_name_strings[] =
a166 1
static char **arm_register_names = arm_register_name_strings;
a172 2
/* Index to that option in the opcodes table.  */
static int current_option;
a1389 17
/* Index within `registers' of the first byte of the space for
   register N.  */

static int
arm_register_byte (int regnum)
{
  if (regnum < ARM_F0_REGNUM)
    return regnum * INT_REGISTER_SIZE;
  else if (regnum < ARM_PS_REGNUM)
    return (NUM_GREGS * INT_REGISTER_SIZE
	    + (regnum - ARM_F0_REGNUM) * FP_REGISTER_SIZE);
  else
    return (NUM_GREGS * INT_REGISTER_SIZE
	    + NUM_FREGS * FP_REGISTER_SIZE
	    + (regnum - ARM_FPS_REGNUM) * STATUS_REGISTER_SIZE);
}

d2491 1
a2491 2
  const char *setname, *setdesc, *const *regnames;
  int numregs, j;
d2493 5
a2497 23
  /* Find the style that the user wants in the opcodes table.  */
  int current = 0;
  numregs = get_arm_regnames (current, &setname, &setdesc, &regnames);
  while ((disassembly_style != setname)
	 && (current < num_disassembly_options))
    get_arm_regnames (++current, &setname, &setdesc, &regnames);
  current_option = current;

  /* Fill our copy.  */
  for (j = 0; j < numregs; j++)
    arm_register_names[j] = (char *) regnames[j];

  /* Adjust case.  */
  if (isupper (*regnames[ARM_PC_REGNUM]))
    {
      arm_register_names[ARM_FPS_REGNUM] = "FPS";
      arm_register_names[ARM_PS_REGNUM] = "CPSR";
    }
  else
    {
      arm_register_names[ARM_FPS_REGNUM] = "fps";
      arm_register_names[ARM_PS_REGNUM] = "cpsr";
    }
d2555 7
d2598 59
d2786 5
a2790 1
    return best_arch->gdbarch;
a2864 1
  set_gdbarch_deprecated_register_byte (gdbarch, arm_register_byte);
d2922 10
d2996 2
a2997 1
      /* Copy the default names (if found) and synchronize disassembler.  */
a3000 3
          current_option = i;
	  for (j = 0; j < numregs; j++)
            arm_register_names[j] = (char *) regnames[j];
@


1.220
log
@2007-01-25  Paul Brook  <paul@@codesourcery.com>

	gdb/
	* arm-tdep.c (arm_get_next_pc): Fix bitfield off-by-one error.
@
text
@d1337 1
a1337 6
    {
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
	return builtin_type_arm_ext_big;
      else
	return builtin_type_arm_ext_littlebyte_bigword;
    }
d2831 9
a2839 1
  switch (info.byte_order)
d2841 2
a2842 26
    case BFD_ENDIAN_BIG:
      set_gdbarch_float_format (gdbarch, &floatformat_ieee_single_big);
      set_gdbarch_double_format (gdbarch, &floatformat_ieee_double_big);
      set_gdbarch_long_double_format (gdbarch, &floatformat_ieee_double_big);
      break;

    case BFD_ENDIAN_LITTLE:
      set_gdbarch_float_format (gdbarch, &floatformat_ieee_single_little);
      if (fp_model == ARM_FLOAT_SOFT_FPA || fp_model == ARM_FLOAT_FPA)
	{
	  set_gdbarch_double_format
	    (gdbarch, &floatformat_ieee_double_littlebyte_bigword);
	  set_gdbarch_long_double_format
	    (gdbarch, &floatformat_ieee_double_littlebyte_bigword);
	}
      else
	{
	  set_gdbarch_double_format (gdbarch, &floatformat_ieee_double_little);
	  set_gdbarch_long_double_format (gdbarch,
					  &floatformat_ieee_double_little);
	}
      break;

    default:
      internal_error (__FILE__, __LINE__,
		      _("arm_gdbarch_init: bad byte order for float format"));
@


1.219
log
@Copyright updates for 2007.
@
text
@d1626 2
a1627 2
	    if (bits (this_instr, 4, 28) == 0x12fff1
		|| bits (this_instr, 4, 28) == 0x12fff3)
@


1.218
log
@	* NEWS: Mention pointer to member improvements.
	* Makefile.in (gnu-v3-abi.o): Delete special rule.
	(eval.o, gnu-v3-abi.o, ia64-tdep.o): Update.
	* ada-valprint.c (ada_print_scalar): Update for new type codes.
	* c-typeprint.c (c_print_type): Update for new type codes.
	(c_type_print_varspec_prefix, c_type_print_varspec_suffix)
	(c_type_print_base): Likewise.
	(c_type_print_args): Rewrite.
	* c-valprint.c (c_val_print): Update for new type codes.  Remove
	support for references to members.  Treat methods like functions.
	* cp-abi.c (cplus_print_method_ptr, cplus_method_ptr_size)
	(cplus_make_method_ptr, cplus_method_ptr_to_value): New.
	* cp-abi.h (cplus_print_method_ptr, cplus_method_ptr_size)
	(cplus_make_method_ptr, cplus_method_ptr_to_value): New prototypes.
	(struct cp_abi_ops): Add corresponding members.
	* cp-valprint.c (cp_print_class_method): Delete.
	(cp_find_class_member): New function.
	(cp_print_class_member): Use it.  Simplify support for bogus
	member pointers.
	* dwarf2read.c (quirk_gcc_member_function_pointer): Use
	lookup_methodptr_type.
	(read_tag_ptr_to_member_type): Likewise, and lookup_memberptr_type.
	* eval.c (evaluate_subexp_standard): Implement EVAL_SKIP for
	OP_SCOPE.  Update call to value_aggregate_elt.  Rewrite member
	pointer support.
	(evaluate_subexp_for_address): Handle OP_SCOPE explicitly.  Handle
	references returned by user defined operators.
	* f-typeprint.c (f_print_type, f_type_print_varspec_prefix)
	(f_type_print_varspec_suffix): Remove support for member pointers.
	* gdbtypes.c (lookup_memberptr_type): Renamed from lookup_member_type
	and adjusted.
	(smash_to_memberptr_type): Likewise, from smash_to_member_type.
	(lookup_methodptr_type): New.
	(rank_one_type): Adjust for TYPE_CODE_MEMBERPTR.
	(recursive_dump_type): Update for new types.
	* gdbtypes.h (enum type_code): Replace TYPE_CODE_MEMBER with
	TYPE_CODE_MEMBERPTR and TYPE_CODE_METHODPTR.
	(lookup_memberptr_type, lookup_methodptr_type)
	(smash_to_memberptr_type): New prototypes.
	(smash_to_method_type): Formatting fix.
	(lookup_member_type, smash_to_member_type): Delete prototypes.
	* gnu-v3-abi.c (gnuv3_get_vtable, gnuv3_get_virtual_fn): New.
	Do not rely on debug information for the vptr or the method's
	enclosing type.  Handle function descriptors for IA64.
	(gnuv3_virtual_fn_field): Rewrite using the new functions.
	(gnuv3_find_method_in, gnuv3_print_method_ptr)
	(gnuv3_method_ptr_size, gnuv3_make_method_ptr)
	(gnuv3_method_ptr_to_value): New.
	(init_gnuv3_ops): Set new members of gnu_v3_abi_ops.
	* hpread.c (hpread_type_lookup): Update for new types.
	* infcall.c (value_arg_coerce): Likewise.
	* m2-typeprint.c (m2_print_type): Remove explicit support
	for member pointers.
	* m2-valprint.c (m2_val_print): Likewise.
	* p-typeprint.c (pascal_type_print_varspec_prefix)
	(pascal_type_print_varspec_suffix, pascal_type_print_base): Likewise.
	* p-valprint.c (pascal_val_print): Likewise.
	(pascal_object_print_class_method, pascal_object_print_class_member):
	Delete.
	* p-lang.h (pascal_object_print_class_method)
	(pascal_object_print_class_member): Delete prototypes.
	* stabsread.c (read_type): Update for new types.
	* typeprint.c (print_type_scalar): Likewise.
	* valops.c (value_struct_elt_for_reference, value_namespace_elt)
	(value_maybe_namespace_elt, value_aggregate_elt): Add want_address
	argument.  Construct a pointer to member if the address of a
	function or data member is requested.
	(value_cast_pointers): Don't modify the input value.
	(value_cast): Adjust pointer to member handling for new types.
	Allow null pointer to member constants.  Don't modify the input
	value.
	(value_ind): Remove pointer to member check.  Handle function
	descriptors for function pointers.
	(value_struct_elt, value_find_oload_method_list, check_field):
	Remove pointer to member checks.
	* value.c (unpack_long): Allow pointers to data members.
	(value_from_longest): Allow member pointers.
	* value.h (value_aggregate_elt): Add want_address.
	* varobj.c (c_variable_editable): Remove check for members.
	* gdbarch.sh: Add vtable_function_descriptors and vbit_in_delta.
	* ia64-tdep.c (ia64_convert_from_func_ptr_addr): Handle descriptors
	in virtual tables.
	(ia64_gdbarch_init): Call set_gdbarch_vtable_function_descriptors.
	* c-lang.h (cp_print_class_method): Delete prototype.
	* arm-tdep.c (arm_gdbarch_init): Call set_gdbarch_vbit_in_delta.
	* mips-tdep.c (mips_gdbarch_init): Likewise.
	* gdbarch.c, gdbarch.h: Regenerated.

	* gdb.cp/classes.exp (test_pointers_to_class_members): Update expected
	output.  Test the types of members and member pointers.
	* gdb.cp/inherit.exp (test_print_mi_member_types): Remove KFAILs for
	gdb/2092.
	* gdb.cp/member-ptr.exp: Search for a comment instead of a
	statement.  Enable for GCC.  Update expected output for some tests
	and add new tests.  Remove obsolete GCC KFAILs.  Allow GCC's class
	layout.
	* gdb.cp/member-ptr.cc (Padding, Padding::vspacer, Base, Base::get_x)
	(Base::vget_base, Left, Left::vget, Right, Right::vget, Diamond)
	(Diamond::vget_base): New.
	(main): Add new tests.
	* gdb.cp/printmethod.exp: Update expected output for member functions.
	* gdb.cp/virtfunc.exp (test_virtual_calls): Add a KFAIL for
	print pEe->D::vg().
@
text
@d3 2
a4 3
   Copyright (C) 1988, 1989, 1991, 1992, 1993, 1995, 1996, 1998, 1999,
   2000, 2001, 2002, 2003, 2004, 2005, 2006
   Free Software Foundation, Inc.
@


1.217
log
@gdb/
	* Makefile.in (arm-tdep.o): Update dependencies.
	* arm-tdep.c (thumb_skip_prologue): Remove.
	(thumb_analyze_prologue): New function.
	(arm_skip_prologue): Use thumb_analyze_prologue.
	(thumb_scan_prologue): Ditto.
gdb/testsuite/
	* gdb.arch/thumb-prologue.c, gdb.arch/thumb-prologue.exp: New files.
@
text
@d2819 3
@


1.216
log
@	* arm-tdep.c (arm_unwind_pc): Use arm_addr_bits_remove.
@
text
@d44 1
d216 3
a218 27
/* A typical Thumb prologue looks like this:
   push    {r7, lr}
   add     sp, sp, #-28
   add     r7, sp, #12
   Sometimes the latter instruction may be replaced by:
   mov     r7, sp
   
   or like this:
   push    {r7, lr}
   mov     r7, sp
   sub	   sp, #12
   
   or, on tpcs, like this:
   sub     sp,#16
   push    {r7, lr}
   (many instructions)
   mov     r7, sp
   sub	   sp, #12

   There is always one instruction of three classes:
   1 - push
   2 - setting of r7
   3 - adjusting of sp
   
   When we have found at least one of each class we are done with the prolog.
   Note that the "sub sp, #NN" before the push does not count.
   */
d221 3
a223 1
thumb_skip_prologue (CORE_ADDR pc, CORE_ADDR func_end)
d225 18
a242 7
  CORE_ADDR current_pc;
  /* findmask:
     bit 0 - push { rlist }
     bit 1 - mov r7, sp  OR  add r7, sp, #imm  (setting of r7)
     bit 2 - sub sp, #simm  OR  add sp, #simm  (adjusting of sp)
  */
  int findmask = 0;
d244 1
a244 3
  for (current_pc = pc;
       current_pc + 2 < func_end && current_pc < pc + 40;
       current_pc += 2)
d246 3
a248 1
      unsigned short insn = read_memory_unsigned_integer (current_pc, 2);
d252 25
a276 1
	  findmask |= 1;			/* push found */
d281 4
a284 2
	  if ((findmask & 1) == 0)		/* before push ? */
	    continue;
d286 2
a287 1
	    findmask |= 4;			/* add/sub sp found */
d290 23
a312 2
	{
	  findmask |= 2;			/* setting of r7 found */
d314 1
a314 5
      else if (insn == 0x466f)			/* mov r7, sp */
	{
	  findmask |= 2;			/* setting of r7 found */
	}
      else if (findmask == (4+2+1))
d316 4
a319 1
	  /* We have found one of each type of prologue instruction */
d322 36
a357 5
      else
	/* Something in the prolog that we don't care about or some
	   instruction from outside the prolog scheduled here for
	   optimization.  */
	continue;
d360 6
a365 1
  return current_pc;
a412 4
  /* Check if this is Thumb code.  */
  if (arm_pc_is_thumb (pc))
    return thumb_skip_prologue (pc, func_end);

d420 4
d538 2
a539 80
  /* Initialize the saved register map.  When register H is copied to
     register L, we will put H in saved_reg[L].  */
  for (i = 0; i < 16; i++)
    saved_reg[i] = i;

  /* Search the prologue looking for instructions that set up the
     frame pointer, adjust the stack pointer, and save registers.
     Do this until all basic prolog instructions are found.  */

  cache->framesize = 0;
  for (current_pc = prologue_start;
       (current_pc < prologue_end) && ((findmask & 7) != 7);
       current_pc += 2)
    {
      unsigned short insn;
      int regno;
      int offset;

      insn = read_memory_unsigned_integer (current_pc, 2);

      if ((insn & 0xfe00) == 0xb400)	/* push { rlist } */
	{
	  int mask;
	  findmask |= 1;		/* push found */
	  /* Bits 0-7 contain a mask for registers R0-R7.  Bit 8 says
	     whether to save LR (R14).  */
	  mask = (insn & 0xff) | ((insn & 0x100) << 6);

	  /* Calculate offsets of saved R0-R7 and LR.  */
	  for (regno = ARM_LR_REGNUM; regno >= 0; regno--)
	    if (mask & (1 << regno))
	      {
		cache->framesize += 4;
		cache->saved_regs[saved_reg[regno]].addr = -cache->framesize;
		/* Reset saved register map.  */
		saved_reg[regno] = regno;
	      }
	}
      else if ((insn & 0xff00) == 0xb000)	/* add sp, #simm  OR  
						   sub sp, #simm */
	{
	  if ((findmask & 1) == 0)		/* before push?  */
	    continue;
	  else
	    findmask |= 4;			/* add/sub sp found */
	  
	  offset = (insn & 0x7f) << 2;		/* get scaled offset */
	  if (insn & 0x80)		/* is it signed? (==subtracting) */
	    {
	      cache->frameoffset += offset;
	      offset = -offset;
	    }
	  cache->framesize -= offset;
	}
      else if ((insn & 0xff00) == 0xaf00)	/* add r7, sp, #imm */
	{
	  findmask |= 2;			/* setting of r7 found */
	  cache->framereg = THUMB_FP_REGNUM;
	  /* get scaled offset */
	  cache->frameoffset = (insn & 0xff) << 2;
	}
      else if (insn == 0x466f)			/* mov r7, sp */
	{
	  findmask |= 2;			/* setting of r7 found */
	  cache->framereg = THUMB_FP_REGNUM;
	  cache->frameoffset = 0;
	  saved_reg[THUMB_FP_REGNUM] = ARM_SP_REGNUM;
	}
      else if ((insn & 0xffc0) == 0x4640)	/* mov r0-r7, r8-r15 */
	{
	  int lo_reg = insn & 7;		/* dest.  register (r0-r7) */
	  int hi_reg = ((insn >> 3) & 7) + 8;	/* source register (r8-15) */
	  saved_reg[lo_reg] = hi_reg;		/* remember hi reg was saved */
	}
      else
	/* Something in the prolog that we don't care about or some
	   instruction from outside the prolog scheduled here for
	   optimization.  */ 
	continue;
    }
@


1.215
log
@	* arm-tdep.c (arm_gdbarch_init): Handle EF_ARM_EABI_VER5.
@
text
@d1049 1
a1049 1
  return IS_THUMB_ADDR (pc) ? UNMAKE_THUMB_ADDR (pc) : pc;
@


1.214
log
@* arm-tdep.h (enum struct_return): New.
(struct gdbarch_tdep): Add struct_return member.
* arm-tdep.c (arm_return_value): Return
RETURN_VALUE_STRUCT_CONVENTION for aggregates when the ABI uses
pcc_struct_return.
(arm_gdbarch_init): Default to reg_struct_return.
* armobsd-tdep.c (armobsd_init_abi): Set pcc_struct_return.
@
text
@d2638 1
@


1.213
log
@Reviewed by Daniel Jacobowitz <drow@@false.org>

	2006-07-31  Fred Fish  <fnf@@specifix.com>
	* arm-tdep.c (arm_make_prologue_cache): Use FRAME_OBSTACK_ZALLOC
	instead of calling frame_obstack_zalloc directly.
	(arm_make_stub_cache): Ditto.
	* frame-unwind.h: Ditto.
	* frame.c (create_new_frame): Ditto.
@
text
@d2262 2
d2268 2
a2269 1
      if (arm_return_in_memory (gdbarch, valtype))
d2763 4
@


1.212
log
@* arm-tdep.c (arm_gdbarch_init): Get default floating-point model
from ELF flags for binaries produced by the GNU toolchain.
@
text
@d858 1
a858 1
  cache = frame_obstack_zalloc (sizeof (struct arm_prologue_cache));
d965 1
a965 1
  cache = frame_obstack_zalloc (sizeof (struct arm_prologue_cache));
@


1.211
log
@* arm-tdep.c (arm_saved_pc_after_call): Delete.
(arm_gdbarch_init): Do not set deprecated_saved_pc_after_call.
@
text
@d2597 1
a2597 1
      int ei_osabi;
d2614 2
d2619 2
a2620 2
		 objects.  There's nowhere to tag an EABI version anyway,
		 so assume APCS.  */
d2625 1
a2625 4
	      int e_flags, eabi_ver;

	      e_flags = elf_elfheader (info.abfd)->e_flags;
	      eabi_ver = EF_ARM_EABI_VERSION (e_flags);
d2642 1
d2644 24
a2667 1
		  arm_abi = ARM_ABI_APCS;
@


1.210
log
@	* arm-tdep.c (arm_register_type): Use unsigned types for registers.
	Add special types for sp and pc.
	* Makefile.in (arm-tdep.o): Update.
@
text
@a214 11
/* Immediately after a function call, return the saved pc.  Can't
   always go through the frames for this because on some machines the
   new frame is not set up until the new function executes some
   instructions.  */

static CORE_ADDR
arm_saved_pc_after_call (struct frame_info *frame)
{
  return ADDR_BITS_REMOVE (read_register (ARM_LR_REGNUM));
}

a2755 3
  /* Get the PC when a frame might not be available.  */
  set_gdbarch_deprecated_saved_pc_after_call (gdbarch, arm_saved_pc_after_call);

@


1.209
log
@	* remote-rdp.c: Deleted.
	* NEWS: Mention removal of remote-rdp.c.

	* Makefile.in (ALLDEPFILES): Remove remote-rdp.c.
	(remote-rdp.o): Delete.
	* README: Remove description of remote-rdp.c.
	* arm-tdep.c (arm_breakpoint_from_pc): Remove obsolete comment.
	* config/arm/embed.mt (TDEPFILES): Remove remote-rdp.o.
@
text
@d43 1
d1360 4
d1365 1
a1365 1
    return builtin_type_int32;
@


1.208
log
@gdb/
	* breakpoint.c (deprecated_read_memory_nobpt): Update to use
	shadow_len.
	(insert_bp_location, reattach_breakpoints, remove_breakpoint)
	(delete_breakpoint): Update calls to changed methods.
	(deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint)
	(single_step_breakpoints, insert_single_step_breakpoint)
	(remove_single_step_breakpoints): New.
	* breakpoint.h (struct bp_target_info): New.
	(struct bp_location): Replace shadow_contents with
	target_info and overlay_target_info.
	(deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint)
	(insert_single_step_breakpoint, remove_single_step_breakpoints): New
	prototypes.
	* gdbarch.sh: Forward declare struct bp_target_info in gdbarch.h.
	(memory_insert_breakpoint, memory_remove_breakpoint): Update second
	argument.
	* mem-break.c (default_memory_insert_breakpoint): Update.  Set
	placed_address, placed_size, and shadow_len.
	(default_memory_remove_breakpoint): Update.  Don't use
	BREAKPOINT_FROM_PC.
	(memory_insert_breakpoint, memory_remove_breakpoint): Update.
	* target.c (update_current_target): Update prototypes for changed
	functions.
	(debug_to_insert_breakpoint, debug_to_remove_breakpoint)
	(debug_to_insert_hw_breakpoint, debug_to_remove_hw_breakpoint):
	Update.
	* target.h: Forward declare struct bp_target_info.
	(struct target_ops): Use a bp_target_info argument for
	to_insert_breakpoint, to_remove_breakpoint,
	to_insert_hw_breakpoint, and to_remove_hw_breakpoint.
	(target_insert_breakpoint, target_remove_breakpoint)
	(target_insert_hw_breakpoint, target_remove_hw_breakpoint)
	(memory_insert_breakpoint, memory_remove_breakpoint)
	(default_memory_insert_breakpoint, default_memory_remove_breakpoint):
	Update.
	* config/i386/nm-i386.h: Forward declare struct bp_target_info.
	(i386_insert_hw_breakpoint, i386_remove_hw_breakpoint): Update.
	(target_insert_hw_breakpoint, target_remove_hw_breakpoint): Likewise.

	* gdbarch.c, gdbarch.h: Regenerated.

	* alpha-tdep.c (alpha_software_single_step): Use
	insert_single_step_breakpoint and remove_single_step_breakpoints.
	Remove unused statics.
	* arm-tdep.c (arm_software_single_step): Likewise.  Add a note.
	* cris-tdep.c (cris_software_single_step): Likewise.
	* mips-tdep.c (mips_software_single_step): Likewise.
	* rs6000-tdep.c (rs6000_software_single_step): Likewise.
	* sparc-tdep.c (sparc_software_single_step): Likewise.
	* wince.c (struct thread_info_struct): Remove step_prev.
	(undoSStep): Use remove_single_step_breakpoints.
	(wince_software_single_step): Use insert_single_step_breakpoint.

	* corelow.c (ignore): Remove unneeded prototype.  Update arguments.
	* exec.c (ignore): Likewise.
	* sol-thread.c (ignore): Likewise.

	* procfs.c (dbx_link_shadow_contents): Delete.
	(dbx_link_bpt): New.
	(procfs_mourn_inferior): Remove it if necessary.
	(remove_dbx_link_breakpoint): Use it.
	(insert_dbx_link_bpt_in_file): Set it.
	(procfs_init_inferior): Don't update dbx_link_bpt_addr.
	* rs6000-nat.c (exec_one_dummy_insn): Use
	deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint.
	* solib-irix.c (shadow_contents, breakpoint_addr): Delete.
	(base_breakpoint): New.
	(disable_break): Use it.
	(enable_break): Set it.

	* i386-nat.c (i386_insert_hw_breakpoint, i386_remove_hw_breakpoint):
	Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint)
	(ia64_memory_remove_breakpoint): Likewise.
	* m32r-tdep.c (m32r_memory_insert_breakpoint)
	(m32r_memory_remove_breakpoint): Likewise.
	* monitor.c (monitor_insert_breakpoint, monitor_remove_breakpoint):
	Likewise.  Remove unnecessary prototypes.  Use placed_address
	and placed_size.  Removed useless read from memory.
	* nto-procfs.c (procfs_insert_breakpoint)
	(procfs_remove_breakpoint, procfs_insert_hw_breakpoint)
	(procfs_remove_hw_breakpoint): Update.
	* ocd.c (ocd_insert_breakpoint, ocd_remove_breakpoint): Likewise.
	* ocd.h (ocd_insert_breakpoint, ocd_remove_breakpoint): Likewise.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Likewise.
	* ppc-tdep.h (ppc_linux_memory_remove_breakpoint): Likewise.
	* remote-e7000.c (e7000_insert_breakpoint)
	(e7000_remove_breakpoint): Likewise.
	* remote-m32r-sdi.c (m32r_insert_breakpoint)
	(m32r_remove_breakpoint): Likewise.
	* remote-mips.c (mips_insert_breakpoint)
	(mips_remove_breakpoint): Likewise.
	* remote-rdp.c (remote_rdp_insert_breakpoint)
	(remote_rdp_remove_breakpoint): Likewise.
	(rdp_step): Use deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint.
	* remote-sds.c (sds_insert_breakpoint, sds_remove_breakpoint):
	Update.
	* remote-sim.c (gdbsim_insert_breakpoint, gdbsim_remove_breakpoint):
	Delete.
	(init_gdbsim_ops): Use memory_insert_breakpoint and
	memory_remove_breakpoint.
	* remote-st.c (st2000_insert_breakpoint)
	(st2000_remove_breakpoint): Update.  Remove unused
	BREAKPOINT_FROM_PC.
	* remote.c (remote_insert_breakpoint, remote_remove_breakpoint):
	Update.  Use placed_address and placed_size.
	(remote_insert_hw_breakpoint, remote_remove_hw_breakpoint): Likewise.
gdb/doc/
	* gdbint.texinfo (x86 Watchpoints, Target Conditionals): Update insert
	and remove breakpoint prototypes.
	(Watchpoints): Move description of target_insert_hw_breakpoint and
	target_remove_hw_breakpoint ...
	(Breakpoints): ... to here.  Document target_insert_breakpoint and
	target_remove_breakpoint.
@
text
@a1966 5
/* XXX ??? from old tm-arm.h: if we're using RDP, then we're inserting
   breakpoints and storing their handles instread of what was in
   memory.  It is nice that this is the same size as a handle -
   otherwise remote-rdp will have to change.  */

@


1.208.6.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@a42 1
#include "gdbtypes.h"
d214 11
d868 1
a868 1
  cache = FRAME_OBSTACK_ZALLOC (struct arm_prologue_cache);
d975 1
a975 1
  cache = FRAME_OBSTACK_ZALLOC (struct arm_prologue_cache);
a1358 4
  else if (regnum == ARM_SP_REGNUM)
    return builtin_type_void_data_ptr;
  else if (regnum == ARM_PC_REGNUM)
    return builtin_type_void_func_ptr;
d1360 1
a1360 1
    return builtin_type_uint32;
d1967 5
a2272 2
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

d2277 1
a2277 2
      if (tdep->struct_return == pcc_struct_return
	  || arm_return_in_memory (gdbarch, valtype))
d2608 1
a2608 1
      int ei_osabi, e_flags;
a2624 2
	  e_flags = elf_elfheader (info.abfd)->e_flags;

d2628 2
a2629 2
		 objects.  There's nowhere to tag an EABI version
		 anyway, so assume APCS.  */
d2634 4
a2637 1
	      int eabi_ver = EF_ARM_EABI_VERSION (e_flags);
a2653 1
		  /* Leave it as "auto".  */
d2655 1
a2655 24
		  break;
		}
	    }

	  if (fp_model == ARM_FLOAT_AUTO)
	    {
	      int e_flags = elf_elfheader (info.abfd)->e_flags;

	      switch (e_flags & (EF_ARM_SOFT_FLOAT | EF_ARM_VFP_FLOAT))
		{
		case 0:
		  /* Leave it as "auto".  Strictly speaking this case
		     means FPA, but almost nobody uses that now, and
		     many toolchains fail to set the appropriate bits
		     for the floating-point model they use.  */
		  break;
		case EF_ARM_SOFT_FLOAT:
		  fp_model = ARM_FLOAT_SOFT_FPA;
		  break;
		case EF_ARM_VFP_FLOAT:
		  fp_model = ARM_FLOAT_VFP;
		  break;
		case EF_ARM_SOFT_FLOAT | EF_ARM_VFP_FLOAT:
		  fp_model = ARM_FLOAT_SOFT_VFP;
a2747 4
  /* The default, for both APCS and AAPCS, is to return small
     structures in registers.  */
  tdep->struct_return = reg_struct_return;

d2767 3
@


1.207
log
@	* arm-tdep.c (thumb_scan_prologue): Don't try to analyze
	the function at zero if we have no symbols.
@
text
@d1852 3
a1854 2
  static int next_pc;		 /* State between setting and unsetting.  */
  static char break_mem[BREAKPOINT_MAX]; /* Temporary storage for mem@@bpt */
d1858 3
a1860 2
      next_pc = arm_get_next_pc (read_register (ARM_PC_REGNUM));
      target_insert_breakpoint (next_pc, break_mem);
d1863 1
a1863 1
    target_remove_breakpoint (next_pc, break_mem);
@


1.206
log
@2006-03-08  Paul Brook  <paul@@codesourcery.com>

	* arm-tdep.c (arm_push_dummy_call): Remove stack alignment.
	(arm_frame_align): New function.
	(arm_gdbarch_init): Use it.
@
text
@d469 3
a471 3
    /* We're in the boondocks: allow for 
       16 pushes, an add, and "mv fp,sp".  */
    prologue_end = prologue_start + 40;
@


1.205
log
@2006-02-15  Paul Brook  <paul@@codesourcery.com>

	* arm-tdep.c (arm_skip_prologue, thumb_get_next_pc, arm_get_next_pc):
	Load insn opcodes as unsigned values.
@
text
@a1175 5
  /* Some platforms require a double-word aligned stack.  Make sure sp
     is correctly aligned before we start.  We always do this even if
     it isn't really needed -- it can never hurt things.  */
  sp &= ~(CORE_ADDR)(2 * DEPRECATED_REGISTER_SIZE - 1);

d1297 11
d2747 1
@


1.205.2.1
log
@2006-03-08  Paul Brook  <paul@@codesourcery.com>

	Backport from mainline.
	* gdb/arm-tdep.c (arm_push_dummy_call): Remove stack alignment.
	(arm_frame_align): New function.
	(arm_gdbarch_init): Use it.
@
text
@d1176 5
a1301 11

/* Always align the frame to an 8-byte boundary.  This is required on
   some platforms and harmless on the rest.  */

static CORE_ADDR
arm_frame_align (struct gdbarch *gdbarch, CORE_ADDR sp)
{
  /* Align the stack to eight bytes.  */
  return sp & ~ (CORE_ADDR) 7;
}

a2740 1
  set_gdbarch_frame_align (gdbarch, arm_frame_align);
@


1.205.2.2
log
@	* configure.tgt (arm*-stellaris-*): Use armv7m configuration.
	* config/arm/armv7m.mt: New file.
	* config/arm/tm-armv7m.h: Likewise.
	* arm-tdep.c (arm_register_name_strings): Use xPSR on ARM V7M.
	(arm_pc_is_thumb): ARM V7M is always Thumb.
	(set_disassembly_style): Use xPSR on ARM V7M.
	(arm_write_pc): Do not set T bit in CSPR on V7M.
@
text
@d118 1
a118 7
 "fps",                         /* 24 */
#ifndef ARM_V7M
 "cpsr"                         /* 25 */
#else
 "xPSR"                         /* 25 */
#endif
};
a177 1
#ifndef ARM_V7M
a193 4
#else
  /* ARMV7M processors are always in Thumb mode.  */
  return 1;
#endif
d2500 1
a2500 7
      arm_register_names[ARM_PS_REGNUM] = 
#ifndef ARM_V7M
	"CPSR"
#else
	"xPSR"
#endif
	;
d2505 1
a2505 7
      arm_register_names[ARM_PS_REGNUM] = 
#ifndef ARM_V7M
	"cpsr"
#else
	"xPSR"
#endif
	;
a2553 1
#ifndef ARM_V7M
a2562 1
#endif
@


1.205.2.3
log
@2006-03-21  Paul Brook  <paul@@codesourcery.com>
	Daniel Jacobowitz <dan@@codesourcery.com>
	Jim Blandy <jimb@@codesourcery.com>

	* gdb/Makefile.in: Add prologue_value.{c,h}
	* gdb/arm-tdep.c: Include prologue-value.h.
	(thumb_skip_prologue): Remove.
	(thumb_analyze_prologue): New function.
	(arm_skip_prologue): Use thumb_analyze_prologue.
	(thumb_scan_prologue): Ditto.
	* gdb/prologue-value.c: New file.
	* gdb/prologue-value.h: New file.
	* gdb/config/arm/embed.mt (TDEPFILES): Add prologue-value.o.
	* gdb/config/arm/linux.mt (TDEPFILES): Add prologue-value.o.
	* gdb/config/arm/nbsd.mt (TDEPFILES): Add prologue-value.o.
	* gdb/config/arm/wince.mt (TDEPFILES): Add prologue-value.o.
	* gdb/testsuite/gdb.arch/thumb-prologue.c: New file.
	* gdb/testsuite/gdb.arch/thumb-prologue.exp: New file.
@
text
@a42 1
#include "prologue-value.h"
d236 30
a265 4
CORE_ADDR
thumb_analyze_prologue (struct gdbarch *gdbarch,
			CORE_ADDR start, CORE_ADDR limit,
			struct arm_prologue_cache *cache)
d267 7
a273 5
  int i;
  pv_t regs[16];
  struct pv_area *stack;
  struct cleanup *back_to;
  CORE_ADDR offset;
d275 3
a277 14
  for (i = 0; i < 16; i++)
    regs[i] = pv_register (i, 0);
  stack = make_pv_area (ARM_SP_REGNUM);
  back_to = make_cleanup_free_pv_area (stack);

  /* The call instruction saved PC in LR, and the current PC is not
     interesting.  Due to this file's conventions, we want the value
     of LR at this function's entry, not at the call site, so we do
     not record the save of the PC - when the ARM prologue analyzer
     has also been converted to the pv mechanism, we could record the
     save here and remove the hack in prev_register.  */
  regs[ARM_PC_REGNUM] = pv_unknown ();

  while (start < limit)
d279 1
a279 3
      unsigned short insn;

      insn = read_memory_unsigned_integer (start, 2);
d281 1
a281 1
      if ((insn & 0xfe00) == 0xb400)
d283 1
a283 25
	  int regno;
	  int mask;
	  int stop = 0;

	  /* Bits 0-7 contain a mask for registers R0-R7.  Bit 8 says
	     whether to save LR (R14).  */
	  mask = (insn & 0xff) | ((insn & 0x100) << 6);

	  /* Calculate offsets of saved R0-R7 and LR.  */
	  for (regno = ARM_LR_REGNUM; regno >= 0; regno--)
	    if (mask & (1 << regno))
	      {
		if (pv_area_store_would_trash (stack, regs[ARM_SP_REGNUM]))
		  {
		    stop = 1;
		    break;
		  }

		regs[ARM_SP_REGNUM] = pv_add_constant (regs[ARM_SP_REGNUM],
						       -4);
		pv_area_store (stack, regs[ARM_SP_REGNUM], 4, regs[regno]);
	      }

	  if (stop)
	    break;
d288 2
a289 4
	  offset = (insn & 0x7f) << 2;		/* get scaled offset */
	  if (insn & 0x80)			/* Check for SUB.  */
	    regs[ARM_SP_REGNUM] = pv_add_constant (regs[ARM_SP_REGNUM],
						   -offset);
d291 1
a291 2
	    regs[ARM_SP_REGNUM] = pv_add_constant (regs[ARM_SP_REGNUM],
						   offset);
d294 6
a299 23
	regs[THUMB_FP_REGNUM] = pv_add_constant (regs[ARM_SP_REGNUM],
						 (insn & 0xff) << 2);
      else if ((insn & 0xff00) == 0x4600)	/* mov hi, lo or mov lo, hi */
	{
	  int dst_reg = (insn & 0x7) + ((insn & 0x80) >> 4);
	  int src_reg = (insn & 0x78) >> 3;
	  regs[dst_reg] = regs[src_reg];
	}
      else if ((insn & 0xf800) == 0x9000)	/* str rd, [sp, #off] */
	{
	  /* Handle stores to the stack.  Normally pushes are used,
	     but with GCC -mtpcs-frame, there may be other stores
	     in the prologue to create the frame.  */
	  int regno = (insn >> 8) & 0x7;
	  pv_t addr;

	  offset = (insn & 0xff) << 2;
	  addr = pv_add_constant (regs[ARM_SP_REGNUM], offset);

	  if (pv_area_store_would_trash (stack, addr))
	    break;

	  pv_area_store (stack, addr, 4, regs[regno]);
d301 1
a301 1
      else
d303 1
a303 4
	  /* We don't know what this instruction is.  We're finished
	     scanning.  NOTE: Recognizing more safe-to-ignore
	     instructions here will improve support for optimized
	     code.  */
d306 5
a310 36

      start += 2;
    }

  if (cache == NULL)
    {
      do_cleanups (back_to);
      return start;
    }

  /* frameoffset is unused for this unwinder.  */
  cache->frameoffset = 0;

  if (pv_is_register (regs[ARM_FP_REGNUM], ARM_SP_REGNUM))
    {
      /* Frame pointer is fp.  Frame size is constant.  */
      cache->framereg = ARM_FP_REGNUM;
      cache->framesize = -regs[ARM_FP_REGNUM].k;
    }
  else if (pv_is_register (regs[THUMB_FP_REGNUM], ARM_SP_REGNUM))
    {
      /* Frame pointer is r7.  Frame size is constant.  */
      cache->framereg = THUMB_FP_REGNUM;
      cache->framesize = -regs[THUMB_FP_REGNUM].k;
    }
  else if (pv_is_register (regs[ARM_SP_REGNUM], ARM_SP_REGNUM))
    {
      /* Try the stack pointer... this is a bit desperate.  */
      cache->framereg = ARM_SP_REGNUM;
      cache->framesize = -regs[ARM_SP_REGNUM].k;
    }
  else
    {
      /* We're just out of luck.  We don't know where the frame is.  */
      cache->framereg = -1;
      cache->framesize = 0;
d313 1
a313 6
  for (i = 0; i < 16; i++)
    if (pv_area_find_reg (stack, gdbarch, i, &offset))
      cache->saved_regs[i].addr = offset;

  do_cleanups (back_to);
  return start;
d361 4
a371 4
  /* Check if this is Thumb code.  */
  if (arm_pc_is_thumb (pc))
    return thumb_analyze_prologue (current_gdbarch, pc, func_end, NULL);

d486 80
a565 2
  thumb_analyze_prologue (current_gdbarch, prologue_start, prologue_end,
			  cache);
@


1.205.2.4
log
@Merge XML and VFP support to this branch.
@
text
@a43 2
#include "available.h"
#include "user-regs.h"
d809 1
a809 2
      else if ((insn & 0xffff7fff) == 0xed6d0103	/* stfe f?, [sp, -#c]! */
	       && gdbarch_tdep (current_gdbarch)->have_fpa_registers)
d815 1
a815 2
      else if ((insn & 0xffbf0fff) == 0xec2d0200	/* sfmfd f0, 4, [sp!] */
	       && gdbarch_tdep (current_gdbarch)->have_fpa_registers)
a1353 10
  struct type *avail_type;

  avail_type = available_register_type (gdbarch, regnum);
  if (avail_type)
    return avail_type;

  if (gdbarch_tdep (current_gdbarch)->have_vfp_pseudos
      && regnum >= NUM_REGS && regnum < NUM_REGS + 32)
    return builtin_type_float;

a1355 3
      if (!gdbarch_tdep (gdbarch)->have_fpa_registers)
	return builtin_type_void;

d1365 3
a1367 1
/* Map DWARF register numbers onto internal GDB register numbers.  */
d1369 1
a1369 1
arm_dwarf_reg_to_regnum (int reg)
d1371 9
a1379 44
  /* Core integer regs.  */
  if (reg >= 0 && reg <= 15)
    return reg;

  /* Legacy FPA encoding.  These were once used in a way which
     overlapped with VFP register numbering, so their use is
     discouraged, but GDB doesn't support the ARM toolchain
     which did that.  */
  if (reg >= 16 && reg <= 23)
    return ARM_F0_REGNUM + reg - 16;

  /* New assignments for the FPA registers.  */
  if (reg >= 96 && reg <= 103)
    return ARM_F0_REGNUM + reg - 96;

  /* VFP v2 registers.  A double precision value is actually
     in d1 rather than s2, but the ABI only defines numbering
     for the single precision registers.  This will "just work"
     in GDB for little endian targets (we'll read eight bytes,
     starting in s0 and then progressing to s1), but will be
     reversed on big endian targets with VFP.  This won't
     be a problem for the new Neon quad registers; you're supposed
     to use DW_OP_piece for those.  */
  if (reg >= 64 && reg <= 95)
    {
      char name_buf[4];

      sprintf (name_buf, "s%d", reg - 64);
      return user_reg_map_name_to_regnum (current_gdbarch, name_buf,
					  strlen (name_buf));
    }

  /* VFP v3 / Neon registers.  This range is also used for VFP v2
     registers, except that it now describes d0 instead of s0.  */
  if (reg >= 256 && reg <= 287)
    {
      char name_buf[4];

      sprintf (name_buf, "d%d", reg - 256);
      return user_reg_map_name_to_regnum (current_gdbarch, name_buf,
					  strlen (name_buf));
    }

  return -1;
d2477 1
a2477 29
  const char *avail_name;

  /* Allow arm_register_names to override the names for standard
     registers from the target, for "set arm disassembler".  */
  if (i <= ARM_PC_REGNUM || i == ARM_PS_REGNUM)
    return arm_register_names[i];
  if (i <= ARM_FPS_REGNUM)
    {
      if (gdbarch_tdep (current_gdbarch)->have_fpa_registers)
	return arm_register_names[i];
      else
	return "";
    }

  if (gdbarch_tdep (current_gdbarch)->have_vfp_pseudos
      && i >= NUM_REGS && i < NUM_REGS + 32)
    {
      static const char *const vfp_pseudo_names[] = {
	"s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7",
	"s8", "s9", "s10", "s11", "s12", "s13", "s14", "s15",
	"s16", "s17", "s18", "s19", "s20", "s21", "s22", "s23",
	"s24", "s25", "s26", "s27", "s28", "s29", "s30", "s31",
      };

      return vfp_pseudo_names[i - NUM_REGS];
    }

  /* Check for target-supplied register numbers.  */
  return available_register_name (current_gdbarch, i);
a2579 51

static void
arm_pseudo_vfp_read (struct gdbarch *gdbarch, struct regcache *regcache,
		     int regnum, gdb_byte *buf)
{
  char name_buf[4];
  gdb_byte reg_buf[8];
  int offset, double_regnum;

  gdb_assert (regnum >= NUM_REGS && regnum <= NUM_REGS + 32);
  regnum -= NUM_REGS;

  /* s0 is always the least significant half of d0.  */
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
    offset = (regnum & 1) ? 0 : 4;
  else
    offset = (regnum & 1) ? 4 : 0;

  sprintf (name_buf, "d%d", regnum >> 1);
  double_regnum = user_reg_map_name_to_regnum (gdbarch, name_buf,
					       strlen (name_buf));

  regcache_raw_read (regcache, double_regnum, reg_buf);
  memcpy (buf, reg_buf + offset, 4);
}

static void
arm_pseudo_vfp_write (struct gdbarch *gdbarch, struct regcache *regcache,
		      int regnum, const gdb_byte *buf)
{
  char name_buf[4];
  gdb_byte reg_buf[8];
  int offset, double_regnum;

  gdb_assert (regnum >= NUM_REGS && regnum <= NUM_REGS + 32);
  regnum -= NUM_REGS;

  /* s0 is always the least significant half of d0.  */
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
    offset = (regnum & 1) ? 0 : 4;
  else
    offset = (regnum & 1) ? 4 : 0;

  sprintf (name_buf, "d%d", regnum >> 1);
  double_regnum = user_reg_map_name_to_regnum (gdbarch, name_buf,
					       strlen (name_buf));

  regcache_raw_read (regcache, double_regnum, reg_buf);
  memcpy (reg_buf + offset, buf, 4);
  regcache_raw_write (regcache, double_regnum, reg_buf);
}
a2599 66
static void
arm_require_register (struct gdb_feature_set *feature_set,
		      const char *name, int regnum)
{
  if (!available_find_named_register (feature_set, name, regnum))
    error (_("target does not provide required register \"%s\""), name);
}

static void
arm_check_feature_set (struct gdbarch *gdbarch,
		       struct gdb_feature_set *feature_set)
{
  static const char *const arm_standard_names[] =
    {
      "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
      "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
      "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "fps",
      "cpsr"
    };
  int i;

  if (!available_find_named_feature (feature_set, "org.gnu.gdb.arm.core"))
    error (_("target does not provide ARM core registers"));

  for (i = 0; i < 16; i++)
    arm_require_register (feature_set, arm_standard_names[i], i);

  arm_require_register (feature_set, arm_standard_names[ARM_PS_REGNUM],
			ARM_PS_REGNUM);

  /* If we have an FPA unit, require the FPA registers and assign them
     fixed numbers.  If we don't have FPA, these register numbers will
     remain unused, since various ARM subtargets hardcode the
     numbering.  */

  if (available_find_named_feature (feature_set, "org.gnu.gdb.arm.fpa"))
    {
      for (i = ARM_F0_REGNUM; i <= ARM_FPS_REGNUM; i++)
	arm_require_register (feature_set, arm_standard_names[i], i);
      gdbarch_tdep (gdbarch)->have_fpa_registers = 1;
    }
  else
    gdbarch_tdep (gdbarch)->have_fpa_registers = 0;

  /* If we have a VFP unit, check whether the single precision registers
     are present.  If not, then we will synthesize them as pseudo
     registers.  */

  if (available_find_named_feature (feature_set, "org.gnu.gdb.arm.vfp"))
    {
      if (available_find_named_register (feature_set, "d0", -1)
	  && !available_find_named_register (feature_set, "s0", -1))
	{
	  /* NOTE: This is the only set of pseudo registers used by
	     the ARM target at the moment.  If more are added, a
	     little more care in numbering will be needed.  */

	  set_gdbarch_num_pseudo_regs (gdbarch, 32);
	  set_gdbarch_pseudo_register_read (gdbarch, arm_pseudo_vfp_read);
	  set_gdbarch_pseudo_register_write (gdbarch, arm_pseudo_vfp_write);
	  gdbarch_tdep (gdbarch)->have_vfp_pseudos = 1;
	}
      gdbarch_tdep (gdbarch)->have_vfp_registers = 1;
    }
}

d2791 1
d2795 1
a2797 16
  set_gdbarch_register_reggroup_p (gdbarch, available_register_reggroup_p);

  if (info.feature_set)
    {
      arm_check_feature_set (gdbarch, info.feature_set);
      record_available_features (gdbarch, info.feature_set);
    }
  else
    /* The legacy layout of the remote "g" packet assumes we have
       the FPA registers, as do some native targets.  */
    gdbarch_tdep (gdbarch)->have_fpa_registers = 1;

  /* This "info float" is FPA-specific.  Use the generic version if we
     do not have FPA.  */
  if (gdbarch_tdep (gdbarch)->have_fpa_registers)
    set_gdbarch_print_float_info (gdbarch, arm_print_float_info);
a2799 2
  set_gdbarch_dwarf_reg_to_regnum (gdbarch, arm_dwarf_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, arm_dwarf_reg_to_regnum);
a2865 2
  set_gdbarch_available_features_support (gdbarch, 1);

@


1.205.2.5
log
@2006-05-03  Paul Brook  <paul@@codesourcery.com>
	Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdb/c-valprint.c: Handle class member typedefs.

	* gdb/symtab.c (skip_prologue_using_sal): Treat two consecutive lines
	at the same address as a prolouge marker.
	* gdb/arm-tdep.c (arm_skip_prologue): Use skip_prologue_using_sal.

	* gdb/dwarf2expr.c (execute_stack_op): Check for bogus DW_OP_reg.

	* gdb/dwarf2read.c (read_structure_type): Use tag name for C++/Java
	classes.

	* Makefile.in (eval.o): Update dependencies.
	* eval.c: Include "ui-out.h" and "exceptions.h".
	(evaluate_subexp_standard): Use TRY_CATCH around value_of_variable.
	Use value_zero if an error occurs when avoiding side effects.
	* varobj.c (varobj_create): Call release_value after evaluate_type.
	(c_value_of_root): Initialize new_val.  Don't release_value a NULL
	value.

	* gdb/c-typeprint.c (cp_type_print_method_args): Don't print type
	details.

	* gdb/dwarf2read.c (dwarf2_debug_line_missing_file_complaint): New
	function.
	(dwarf_decode_lines): Check for line info without a file.
@
text
@a416 11
  /* See if we can determine the end of the prologue via the symbol table.
     If so, then return either PC, or the PC after the prologue, whichever
     is greater.  */
  if (find_pc_partial_function (pc, NULL, &func_addr, NULL))
    {
      CORE_ADDR post_prologue_pc = skip_prologue_using_sal (func_addr);
      if (post_prologue_pc != 0)
        return max (pc, post_prologue_pc);
    }

#if 0
a430 1
#endif
a434 1
  func_end = skip_prologue_using_sal (pc);
@


1.205.2.4.2.1
log
@Merge to branch:
  http://sourceware.org/ml/gdb-patches/2006-04/msg00139.html
@
text
@d1904 2
a1905 3
  /* NOTE: This may insert the wrong breakpoint instruction when
     single-stepping over a mode-changing instruction, if the
     CPSR heuristics are used.  */
d1909 2
a1910 3
      CORE_ADDR next_pc = arm_get_next_pc (read_register (ARM_PC_REGNUM));

      insert_single_step_breakpoint (next_pc);
d1913 1
a1913 1
    remove_single_step_breakpoints ();
@


1.205.2.4.2.2
log
@Actually include patch, not just changelog.
@
text
@a104 11
/* The execution mode to assume.  */
static const char *arm_mode_strings[] =
  {
    "auto",
    "arm",
    "thumb"
  };

static const char *arm_fallback_mode_string = "auto";
static const char *arm_force_mode_string = "auto";

a193 6
  /* If the user wants to override the symbol table, let him.  */
  if (strcmp (arm_force_mode_string, "arm") == 0)
    return 0;
  if (strcmp (arm_force_mode_string, "thumb") == 0)
    return 1;

d197 7
a203 15
    return (MSYMBOL_IS_SPECIAL (sym));

  /* If the user wants to override the fallback mode, let them.  */
  if (strcmp (arm_fallback_mode_string, "arm") == 0)
    return 0;
  if (strcmp (arm_fallback_mode_string, "thumb") == 0)
    return 1;

  /* If we couldn't find any symbol, but we're talking to a running
     target, then trust the current value of $cpsr.  */
  if (target_has_registers)
    return (read_register (ARM_PS_REGNUM) & 0x20) != 0;

  /* Otherwise we're out of luck; we assume ARM.  */
  return 0;
a2512 22
static void
arm_show_fallback_mode (struct ui_file *file, int from_tty,
			struct cmd_list_element *c, const char *value)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  fprintf_filtered (file, _("\
The current execution mode assumed (when symbols are unavailable) is \"%s\".\n"),
		    arm_fallback_mode_string);
}

static void
arm_show_force_mode (struct ui_file *file, int from_tty,
		     struct cmd_list_element *c, const char *value)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  fprintf_filtered (file, _("\
The current execution mode assumed (even when symbols are available) is \"%s\".\n"),
		    arm_force_mode_string);
}

a3202 15
  /* Add two commands to allow the user to force the assumed
     execution mode.  */
  add_setshow_enum_cmd ("fallback-mode", class_support,
			arm_mode_strings, &arm_fallback_mode_string,
			_("Set the mode assumed when symbols are unavailable."),
			_("Show the mode assumed when symbols are unavailable."),
			NULL, NULL, arm_show_fallback_mode,
			&setarmcmdlist, &showarmcmdlist);
  add_setshow_enum_cmd ("force-mode", class_support,
			arm_mode_strings, &arm_force_mode_string,
			_("Set the mode assumed even when symbols are available."),
			_("Show the mode assumed even when symbols are available."),
			NULL, NULL, arm_show_force_mode,
			&setarmcmdlist, &showarmcmdlist);

@


1.205.2.4.2.3
log
@No, really, check in the RIGHT patch!
[Revert half of changes from previous commit.]
@
text
@d105 11
d205 6
d214 15
a228 7
    {
      return (MSYMBOL_IS_SPECIAL (sym));
    }
  else
    {
      return 0;
    }
d2538 22
d3250 15
@


1.205.2.4.2.4
log
@Add experimental support for SymbianOS-related protocol features.
@
text
@a104 11
/* The execution mode to assume.  */
static const char *arm_mode_strings[] =
  {
    "auto",
    "arm",
    "thumb"
  };

static const char *arm_fallback_mode_string = "auto";
static const char *arm_force_mode_string = "auto";

a193 6
  /* If the user wants to override the symbol table, let him.  */
  if (strcmp (arm_force_mode_string, "arm") == 0)
    return 0;
  if (strcmp (arm_force_mode_string, "thumb") == 0)
    return 1;

d197 7
a203 15
    return (MSYMBOL_IS_SPECIAL (sym));

  /* If the user wants to override the fallback mode, let them.  */
  if (strcmp (arm_fallback_mode_string, "arm") == 0)
    return 0;
  if (strcmp (arm_fallback_mode_string, "thumb") == 0)
    return 1;

  /* If we couldn't find any symbol, but we're talking to a running
     target, then trust the current value of $cpsr.  */
  if (target_has_registers)
    return (read_register (ARM_PS_REGNUM) & 0x20) != 0;

  /* Otherwise we're out of luck; we assume ARM.  */
  return 0;
d551 3
a553 3
    /* We're in the boondocks: we have no idea where the start of the
       function is.  */
    return;
a2512 22
static void
arm_show_fallback_mode (struct ui_file *file, int from_tty,
			struct cmd_list_element *c, const char *value)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  fprintf_filtered (file, _("\
The current execution mode assumed (when symbols are unavailable) is \"%s\".\n"),
		    arm_fallback_mode_string);
}

static void
arm_show_force_mode (struct ui_file *file, int from_tty,
		     struct cmd_list_element *c, const char *value)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  fprintf_filtered (file, _("\
The current execution mode assumed (even when symbols are available) is \"%s\".\n"),
		    arm_force_mode_string);
}

a3202 15
  /* Add two commands to allow the user to force the assumed
     execution mode.  */
  add_setshow_enum_cmd ("fallback-mode", class_support,
			arm_mode_strings, &arm_fallback_mode_string,
			_("Set the mode assumed when symbols are unavailable."),
			_("Show the mode assumed when symbols are unavailable."),
			NULL, NULL, arm_show_fallback_mode,
			&setarmcmdlist, &showarmcmdlist);
  add_setshow_enum_cmd ("force-mode", class_support,
			arm_mode_strings, &arm_force_mode_string,
			_("Set the mode assumed even when symbols are available."),
			_("Show the mode assumed even when symbols are available."),
			NULL, NULL, arm_show_force_mode,
			&setarmcmdlist, &showarmcmdlist);

@


1.205.2.4.2.5
log
@	* arm-tdep.c (thumb_heuristic_function_start): New function.
	(thumb_scan_prologue): Use it.
	(arm_prologue_this_id): Adjust LOWEST_PC check.
@
text
@a527 21
/* Attempt to find the start of the function containing PREV_PC, and
   store it in *PROLOGUE_START.  Returns 1 if found, 0 if not.  */

static int
thumb_heuristic_function_start (CORE_ADDR prev_pc, CORE_ADDR *prologue_start)
{
  unsigned short insn;

  /* Right now, we only support a very simple case: if this is a push
     instruction that pushes lr, then we are probably at the very start
     of a function.  */
  insn = read_memory_unsigned_integer (prev_pc, 2);
  if ((insn & 0xff00) == 0xb500)
    {
      *prologue_start = prev_pc;
      return 1;
    }

  return 0;
}

a573 2

      prologue_end = min (prologue_end, prev_pc);
a574 3
  else if (thumb_heuristic_function_start (prev_pc, &prologue_start))
    /* We think we found it!  */
    prologue_end = prev_pc;
d580 2
d938 2
a939 3
     don't halt it just because we don't have a symbol table; so
     we use the PC, not the (possibly unknown) function start.  */
  if (frame_pc_unwind (next_frame) <= LOWEST_PC)
@


1.205.4.1
log
@Initial version of available features support.
@
text
@a42 1
#include "available.h"
a1345 6
  struct type *avail_type;

  avail_type = available_register_type (gdbarch, regnum);
  if (avail_type)
    return avail_type;

d1357 17
a2468 6
  const char *avail_name;

  avail_name = available_register_name (current_gdbarch, i);
  if (avail_name)
    return avail_name;

d2772 1
a2773 2
  set_gdbarch_remote_num_g_packet_regs (gdbarch,
					NUM_GREGS + NUM_FREGS + NUM_SREGS);
a2775 3
  if (info.feature_set)
    record_available_features (gdbarch, info.feature_set);

a2842 2
  set_gdbarch_available_features_support (gdbarch, 1);

@


1.205.4.2
log
@Require targets to provide all their registers if an XML description
is used; fix various bugs this uncovered.  Allow ARM descriptions without
FPA.
@
text
@d808 1
a808 2
      else if ((insn & 0xffff7fff) == 0xed6d0103	/* stfe f?, [sp, -#c]! */
	       && gdbarch_tdep (current_gdbarch)->have_fpa_registers)
d814 1
a814 2
      else if ((insn & 0xffbf0fff) == 0xec2d0200	/* sfmfd f0, 4, [sp!] */
	       && gdbarch_tdep (current_gdbarch)->have_fpa_registers)
a1354 3
      if (!gdbarch_tdep (gdbarch)->have_fpa_registers)
	return builtin_type_void;

d2461 3
a2463 11
  /* Allow arm_register_names to override the names for standard
     registers from the target, for "set arm disassembler".  */
  if (i <= ARM_PC_REGNUM || i == ARM_PS_REGNUM)
    return arm_register_names[i];
  if (i <= ARM_FPS_REGNUM)
    {
      if (gdbarch_tdep (current_gdbarch)->have_fpa_registers)
	return arm_register_names[i];
      else
	return "";
    }
d2465 1
a2465 2
  /* Check for target-supplied register numbers.  */
  return available_register_name (current_gdbarch, i);
a2573 45
static void
arm_require_register (struct gdb_feature_set *feature_set,
		      const char *name, int regnum)
{
  if (!available_find_named_register (feature_set, name, regnum))
    error (_("target does not provide required register \"%s\""), name);
}

static void
arm_check_feature_set (struct gdbarch *gdbarch,
		       struct gdb_feature_set *feature_set)
{
  static const char *const arm_standard_names[] =
    {
      "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
      "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
      "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "fps",
      "cpsr"
    };
  int i;

  if (!available_find_named_feature (feature_set, "org.gnu.gdb.arm.core"))
    error (_("target does not provide ARM core registers"));

  for (i = 0; i < 16; i++)
    arm_require_register (feature_set, arm_standard_names[i], i);

  arm_require_register (feature_set, arm_standard_names[ARM_PS_REGNUM],
			ARM_PS_REGNUM);

  /* If we have an FPA unit, require the FPA registers and assign them
     fixed numbers.  If we don't have FPA, these register numbers will
     remain unused, since various ARM subtargets hardcode the
     numbering.  */

  if (available_find_named_feature (feature_set, "org.gnu.gdb.arm.fpa"))
    {
      for (i = ARM_F0_REGNUM; i <= ARM_FPS_REGNUM; i++)
	arm_require_register (feature_set, arm_standard_names[i], i);
      gdbarch_tdep (gdbarch)->have_fpa_registers = 1;
    }
  else
    gdbarch_tdep (gdbarch)->have_fpa_registers = 0;
}

d2764 1
d2774 1
a2774 13
    {
      arm_check_feature_set (gdbarch, info.feature_set);
      record_available_features (gdbarch, info.feature_set);
    }
  else
    /* The legacy layout of the remote "g" packet assumes we have
       the FPA registers, as do some native targets.  */
    gdbarch_tdep (gdbarch)->have_fpa_registers = 1;

  /* This "info float" is FPA-specific.  Use the generic version if we
     do not have FPA.  */
  if (gdbarch_tdep (gdbarch)->have_fpa_registers)
    set_gdbarch_print_float_info (gdbarch, arm_print_float_info);
@


1.205.4.3
log
@Update g/G packet support.
@
text
@d2827 2
@


1.205.4.4
log
@Basic register group support.
@
text
@a2827 1
  set_gdbarch_register_reggroup_p (gdbarch, available_register_reggroup_p);
@


1.205.4.5
log
@Add support for VFP DWARF information and VFP single-precision
pseudo-registers.
@
text
@a43 1
#include "user-regs.h"
a1354 4
  if (gdbarch_tdep (current_gdbarch)->have_vfp_pseudos
      && regnum >= NUM_REGS && regnum < NUM_REGS + 32)
    return builtin_type_float;

a1368 50
/* Map DWARF register numbers onto internal GDB register numbers.  */
static int
arm_dwarf_reg_to_regnum (int reg)
{
  /* Core integer regs.  */
  if (reg >= 0 && reg <= 15)
    return reg;

  /* Legacy FPA encoding.  These were once used in a way which
     overlapped with VFP register numbering, so their use is
     discouraged, but GDB doesn't support the ARM toolchain
     which did that.  */
  if (reg >= 16 && reg <= 23)
    return ARM_F0_REGNUM + reg - 16;

  /* New assignments for the FPA registers.  */
  if (reg >= 96 && reg <= 103)
    return ARM_F0_REGNUM + reg - 96;

  /* VFP v2 registers.  A double precision value is actually
     in d1 rather than s2, but the ABI only defines numbering
     for the single precision registers.  This will "just work"
     in GDB for little endian targets (we'll read eight bytes,
     starting in s0 and then progressing to s1), but will be
     reversed on big endian targets with VFP.  This won't
     be a problem for the new Neon quad registers; you're supposed
     to use DW_OP_piece for those.  */
  if (reg >= 64 && reg <= 95)
    {
      char name_buf[4];

      sprintf (name_buf, "s%d", reg - 64);
      return user_reg_map_name_to_regnum (current_gdbarch, name_buf,
					  strlen (name_buf));
    }

  /* VFP v3 / Neon registers.  This range is also used for VFP v2
     registers, except that it now describes d0 instead of s0.  */
  if (reg >= 256 && reg <= 287)
    {
      char name_buf[4];

      sprintf (name_buf, "d%d", reg - 256);
      return user_reg_map_name_to_regnum (current_gdbarch, name_buf,
					  strlen (name_buf));
    }

  return -1;
}

a2477 13
  if (gdbarch_tdep (current_gdbarch)->have_vfp_pseudos
      && i >= NUM_REGS && i < NUM_REGS + 32)
    {
      static const char *const vfp_pseudo_names[] = {
	"s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7",
	"s8", "s9", "s10", "s11", "s12", "s13", "s14", "s15",
	"s16", "s17", "s18", "s19", "s20", "s21", "s22", "s23",
	"s24", "s25", "s26", "s27", "s28", "s29", "s30", "s31",
      };

      return vfp_pseudo_names[i - NUM_REGS];
    }

a2567 51

static void
arm_pseudo_vfp_read (struct gdbarch *gdbarch, struct regcache *regcache,
		     int regnum, gdb_byte *buf)
{
  char name_buf[4];
  gdb_byte reg_buf[8];
  int offset, double_regnum;

  gdb_assert (regnum >= NUM_REGS && regnum <= NUM_REGS + 32);
  regnum -= NUM_REGS;

  /* s0 is always the least significant half of d0.  */
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
    offset = (regnum & 1) ? 0 : 4;
  else
    offset = (regnum & 1) ? 4 : 0;

  sprintf (name_buf, "d%d", regnum >> 1);
  double_regnum = user_reg_map_name_to_regnum (gdbarch, name_buf,
					       strlen (name_buf));

  regcache_raw_read (regcache, double_regnum, reg_buf);
  memcpy (buf, reg_buf + offset, 4);
}

static void
arm_pseudo_vfp_write (struct gdbarch *gdbarch, struct regcache *regcache,
		      int regnum, const gdb_byte *buf)
{
  char name_buf[4];
  gdb_byte reg_buf[8];
  int offset, double_regnum;

  gdb_assert (regnum >= NUM_REGS && regnum <= NUM_REGS + 32);
  regnum -= NUM_REGS;

  /* s0 is always the least significant half of d0.  */
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
    offset = (regnum & 1) ? 0 : 4;
  else
    offset = (regnum & 1) ? 4 : 0;

  sprintf (name_buf, "d%d", regnum >> 1);
  double_regnum = user_reg_map_name_to_regnum (gdbarch, name_buf,
					       strlen (name_buf));

  regcache_raw_read (regcache, double_regnum, reg_buf);
  memcpy (reg_buf + offset, buf, 4);
  regcache_raw_write (regcache, double_regnum, reg_buf);
}
a2630 21

  /* If we have a VFP unit, check whether the single precision registers
     are present.  If not, then we will synthesize them as pseudo
     registers.  */

  if (available_find_named_feature (feature_set, "org.gnu.gdb.arm.vfp"))
    {
      if (available_find_named_register (feature_set, "d0", -1)
	  && !available_find_named_register (feature_set, "s0", -1))
	{
	  /* NOTE: This is the only set of pseudo registers used by
	     the ARM target at the moment.  If more are added, a
	     little more care in numbering will be needed.  */

	  set_gdbarch_num_pseudo_regs (gdbarch, 32);
	  set_gdbarch_pseudo_register_read (gdbarch, arm_pseudo_vfp_read);
	  set_gdbarch_pseudo_register_write (gdbarch, arm_pseudo_vfp_write);
	  gdbarch_tdep (gdbarch)->have_vfp_pseudos = 1;
	}
      gdbarch_tdep (gdbarch)->have_vfp_registers = 1;
    }
a2845 2
  set_gdbarch_dwarf_reg_to_regnum (gdbarch, arm_dwarf_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, arm_dwarf_reg_to_regnum);
@


1.204
log
@* arm-tdep.c (arm_return_value): Change type of readbuf and
writebuf arguments to `gdb_byte *'.
@
text
@d363 1
a363 1
      inst = read_memory_integer (skip_pc, 4);
d1543 1
a1543 1
  unsigned short inst1 = read_memory_integer (pc, 2);
d1555 1
a1555 1
      nextpc = (CORE_ADDR) read_memory_integer (sp + offset, 4);
d1573 1
a1573 1
      unsigned short inst2 = read_memory_integer (pc + 2, 2);
d1607 1
a1607 1
  this_instr = read_memory_integer (pc, 4);
@


1.203
log
@	* arm-linux-tdep.c (ARM_SET_R7_SIGRETURN, ARM_SET_R7_RT_SIGRETURN)
	(ARM_EABI_SYSCALL, arm_linux_sigtramp_cache, arm_linux_sigreturn_init)
	(arm_linux_rt_sigreturn_init, arm_linux_sigreturn_tramp_frame)
	(arm_linux_rt_sigreturn_tramp_frame)
	(arm_eabi_linux_sigreturn_tramp_frame)
	(arm_eabi_linux_rt_sigreturn_tramp_frame): New.
	(arm_linux_init_abi): Register the new signal unwinders.
	(arm_linux_in_sigtramp, arm_linux_sigcontext_register_address):
	Delete.
	* arm-tdep.c (SIGCONTEXT_REGISTER_ADDRESS_P)
	(SIGCONTEXT_REGISTER_ADDRESS, arm_make_sigtramp_cache)
	(arm_sigtramp_this_id, arm_sigtramp_prev_register)
	(arm_sigtramp_unwind, arm_sigtramp_unwind_sniffer): Delete.
	(arm_gdbarch_init): Don't register a signal unwinder.
	* config/arm/tm-linux.h (arm_linux_in_sigtramp)
	(arm_linux_sigcontext_register_address): Delete prototypes.
	(DEPRECATED_IN_SIGTRAMP, SIGCONTEXT_REGISTER_ADDRESS): Delete.
	* Makefile.in (arm-linux-tdep.o): Update.
@
text
@d4 2
a5 1
   2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
d2262 2
a2263 2
		  struct regcache *regcache, void *readbuf,
		  const void *writebuf)
@


1.202
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@a53 30
/* Each OS has a different mechanism for accessing the various
   registers stored in the sigcontext structure.

   SIGCONTEXT_REGISTER_ADDRESS should be defined to the name (or
   function pointer) which may be used to determine the addresses
   of the various saved registers in the sigcontext structure.

   For the ARM target, there are three parameters to this function. 
   The first is the pc value of the frame under consideration, the
   second the stack pointer of this frame, and the last is the
   register number to fetch.  

   If the tm.h file does not define this macro, then it's assumed that
   no mechanism is needed and we define SIGCONTEXT_REGISTER_ADDRESS to
   be 0. 
   
   When it comes time to multi-arching this code, see the identically
   named machinery in ia64-tdep.c for an example of how it could be
   done.  It should not be necessary to modify the code below where
   this macro is used.  */

#ifdef SIGCONTEXT_REGISTER_ADDRESS
#ifndef SIGCONTEXT_REGISTER_ADDRESS_P
#define SIGCONTEXT_REGISTER_ADDRESS_P() 1
#endif
#else
#define SIGCONTEXT_REGISTER_ADDRESS(SP,PC,REG) 0
#define SIGCONTEXT_REGISTER_ADDRESS_P() 0
#endif

a1035 78
static struct arm_prologue_cache *
arm_make_sigtramp_cache (struct frame_info *next_frame)
{
  struct arm_prologue_cache *cache;
  int reg;

  cache = frame_obstack_zalloc (sizeof (struct arm_prologue_cache));

  cache->prev_sp = frame_unwind_register_unsigned (next_frame, ARM_SP_REGNUM);

  cache->saved_regs = trad_frame_alloc_saved_regs (next_frame);

  for (reg = 0; reg < NUM_REGS; reg++)
    cache->saved_regs[reg].addr
      = SIGCONTEXT_REGISTER_ADDRESS (cache->prev_sp,
				     frame_pc_unwind (next_frame), reg);

  /* FIXME: What about thumb mode?  */
  cache->framereg = ARM_SP_REGNUM;
  cache->prev_sp
    = read_memory_integer (cache->saved_regs[cache->framereg].addr,
			   register_size (current_gdbarch, cache->framereg));

  return cache;
}

static void
arm_sigtramp_this_id (struct frame_info *next_frame,
		      void **this_cache,
		      struct frame_id *this_id)
{
  struct arm_prologue_cache *cache;

  if (*this_cache == NULL)
    *this_cache = arm_make_sigtramp_cache (next_frame);
  cache = *this_cache;

  /* FIXME drow/2003-07-07: This isn't right if we single-step within
     the sigtramp frame; the PC should be the beginning of the trampoline.  */
  *this_id = frame_id_build (cache->prev_sp, frame_pc_unwind (next_frame));
}

static void
arm_sigtramp_prev_register (struct frame_info *next_frame,
			    void **this_cache,
			    int prev_regnum,
			    int *optimized,
			    enum lval_type *lvalp,
			    CORE_ADDR *addrp,
			    int *realnump,
			    gdb_byte *valuep)
{
  struct arm_prologue_cache *cache;

  if (*this_cache == NULL)
    *this_cache = arm_make_sigtramp_cache (next_frame);
  cache = *this_cache;

  trad_frame_get_prev_register (next_frame, cache->saved_regs, prev_regnum,
				optimized, lvalp, addrp, realnump, valuep);
}

struct frame_unwind arm_sigtramp_unwind = {
  SIGTRAMP_FRAME,
  arm_sigtramp_this_id,
  arm_sigtramp_prev_register
};

static const struct frame_unwind *
arm_sigtramp_unwind_sniffer (struct frame_info *next_frame)
{
  if (SIGCONTEXT_REGISTER_ADDRESS_P ()
      && legacy_pc_in_sigtramp (frame_pc_unwind (next_frame), (char *) 0))
    return &arm_sigtramp_unwind;

  return NULL;
}

a2801 1
  frame_unwind_append_sniffer (gdbarch, arm_sigtramp_unwind_sniffer);
@


1.201
log
@2005-09-26  Paul Brook  <paul@@codesourcery.com>

	* arm-tdep.c (arm_type_align): New function.
	(arm_push_dummy_call): Use it.  Ensure proper argument alignment.
	(arm_extract_struct_value_address): Remove.
	(arm_use_struct_convention): Rename...
	(arm_return_in_memory): ... To this.  Return nonzero for all small
	aggregates under the EABI.
	(arm_return_value): New function.
	(arm_gdbarch_init): Default for VFP float model for EABI binaries.
	Use set_gdbarch_return_value instead of obsolete functions.
	* testsuite/long_long.exp: Exclude eabi targets from arm FPA float
	format test.
@
text
@d3 1
a3 1
   Copyright 1988, 1989, 1991, 1992, 1993, 1995, 1996, 1998, 1999,
d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.201.2.1
log
@2005-03-30  Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdb/Makefile.in (arm-linux-nat.o): Update dependencies.
	* gdb/arm-linux-nat.c: Include "gdb_assert.h".
	(PTRACE_GETWMMXREGS, PTRACE_SETWMMXREGS): Define.
	(arm_linux_has_wmmx_registers): New flag.
	(GET_THREAD_ID): Remove stray punctuation.
	(IWMMXT_REGS_SIZE): Define.
	(fetch_wmmx_regs, store_wmmx_regs): New functions.
	(fetch_inferior_registers, store_inferior_registers): Call them.
	(arm_linux_available_registers): New function.
	* gdb/inftarg.c (child_xfer_partial): Handle
	TARGET_OBJECT_AVAILABLE_REGISTERS.
	* gdb/config/arm/nm-linux.h (arm_linux_available_registers): Add
	prototype.
	(NATIVE_XFER_AVAILABLE_REGISTERS): Define.

	* gdb/gdbserver/linux-arm-low.c (arm_fill_wmmxregset)
	(arm_store_wmmxregset): Remove stray text.
	(arm_available_registers): Remove debugging output.  Use hex.
	* gdb/gdbserver/regcache.c (num_registers): Make global.
	* gdb/gdbserver/server.c (handle_p_packet, handle_P_packet): Check
	the value of regnum.

2005-03-28  Paul Brook  <paul@@codesourcery.com>
	Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdb/Makefile.in: arm-tdep.o depends on $(observer_h).
	* gdb/arm-linux-nat.c (fetch_fpregister, fetch_fpregs,
	store_fpregister, store_fpregs): Rename...
	(fetch_fpa_register, fetch_fpa_regs, store_fpa_register,
	store_fpa_regs): ... to this.
	* gdb/arm-linux-tdep.c (arm_linux_init_abi): Provide ABI specific
	overrides.
	* gdb/arm-tdep.c: Include opserver.h.
	(struct gdbarch_tdep_info): Add.
	(arm_push_dummy_call): Handle doubleword alignment.
	(arm_register_type): Handle iWMMXt and VFP regs.
	(arm_register_byte): Ditto.
	(arm_pseudo_register_read): New function.
	(arm_pseudo_register_write): New function.
	(arm_dwarf_reg_to_regnum): New function.
	(arm_register_sim_regno): Handle iWMMXT regs.
	(arm_register_remote_regno): New function.
	(arm_extract_return_value): Use new macro names.
	(arm_register_name): Handle iWMMXt and VFP registers.
	(arm_sim_available_registers): New function.
	(arm_update_architecture): New function.
	(arm_gdbarch_init): Handle optional register sets.  Register new
	hooks.  Fix misleading error message.
	(_initialize_arm_tdep): Call observer_attach_inferior_created.
	* gdb/arm-tdep.h (ARM_NUM_FP_ARG_REGS, ARM_LAST_FP_ARG_REGNUM,
	FP_REGISTER_SIZE, NUM_FREGS): Rename ...
	(ARM_NUM_FPA_ARG_REGS, ARM_LAST_FPA_ARG_REGNUM, FPA_REGISTER_SIZE,
	NUM_FPA_REGS): ... to this.
	(NUM_IWMMXT_COP0REGS, NUM_IWMMXT_COP1REGS, NUM_IWMMXT_REGS,
	IWMMXT_COP0_REGSIZE, IWMMXT_COP1_REGSIZE, NUM_VFP_XREGS,
	VFP_XREG_SIZE, NUM_VFP_SREGS, VFP_SREG_SIZE, NUM_VFP_PSEUDOS): Define.
	(struct gdbarch_tdep): Add target_has_iwmmxt_regs,
	target_has_vfp_regs, first_iwmmxt_regnum, target_iwmmxt_regnum,
	first_vfp_regnum, first_vfp_pseudo and target_vfp_regnum.
	* gdb/gdbarch.c (struct gdbarch): Add remote_num_g_packet_regs,
	sim_available_registers and register_remote_regno.
	(startup_gdbarch, verify_gdbarch): Ditto.
	(gdbarch_dump): Dump new fields.
	(gdbarch_remote_num_g_packet_regs_p, gdbarch_remote_num_g_packet_regs,
	set_gdbarch_remote_num_g_packet_regs,
	gdbarch_sim_available_registers_p, gdbarch_sim_available_registers,
	set_gdbarch_sim_available_registers, gdbarch_register_remote_regno_p,
	gdbarch_register_remote_regno, set_gdbarch_register_remote_regno):
	New functions.
	* gdb/gdbarch.h: Add prototypes.
	* gdb/gdbarch.sh: Add new fields.
	(deprecated_current_gdbarch_select_hack): Call flush_cached_frames.
	* gdb/remote-sim.h (gdbsim_create_inferior): Call
	observer_notify_inferior_created.
	(gdbsim_xfer_partial): New function.
	(init_gdbsim_ops): Use it.
	* gdb/remote.c (struct remote_state): Add num_g_regs.
	(init_remote_state): Only consider hard regs.  Allow target to provide
	register mapping.
	(packet_reg_from_regnum): Don't check pseudo regs.
	(packet_reg_from_pnum): Ditto.
	(remote_protocol_qPart_availableRegisters): Add.
	(set_remote_protocol_qPart_availableRegisters_packet_cmd,
	show_remote_protocol_qPart_availableRegisters_packet_cmd): New
	functions.
	(fetch_register_using_p, store_register_using_P): Handle arbitrary
	register mappings.
	(fetch_registers_using_g): New function.
	(remote_fetch_registers): Use it.
	(store_registers_using_G): New function.
	(remote_store_registers): Use it.
	(remote_xfer_partial): Handle TARGET_OBJECT_AVAILABLE_REGISTERS.
	(show_remote_cmd): Display availableRegisters.
	(_initialize_remote): Register qPart_availableRegisters.
	* gdb/target.h (enum target_object): Add
	TARGET_OBJECT_AVAILABLE_REGISTERS.
	* gdb/gdbserver/configure.srv (arm*-*-linux*): set
	srv_linux_regsets=yes.
	* gdb/gdbserver/linux-arm-low.c (PTRACE_GETWMMXREGS,
	PTRACE_SETWMMXREGS): Define.
	(arm_fill_gregset, arm_store_gregset, arm_fill_wmmxregset,
	arm_store_wmmxregset, arm_available_registers): New functions.
	(target_regsets): Add.
	(the_low_target): Use arm_available_registers.
	* gdb/gdbserver/linux-low.c (linux_available_registers): New function.
	(linux_target_op): Use it.
	* gdb/gdbserver/linux-low.h (gdbserver/linux-low.h): Add
	available_registers.
	(use_regsets_p): Declare.
	* gdb/gdbserver/regcache.c (g_register_bytes): Add.
	(regcache_invalidate, registers_to_string, registers_from_string):
	Use it.
	(set_register_cache): Set g_register_bytes.
	(supply_register_as_string): New function.
	* gdb/gdbserver/regcache.h (supply_register_as_string): Add prototype.
	* gdb/gdbserver/server.c (handle_query): Handle
	qPart:availableRegisters.
	(handle_p_packet, handle_P_packet): New functions.
	(main): Handle 'p' and 'P' packets.
	* gdb/gdbserver/target.h (struct target_ops): Add available_registers.
	* gdb/regformats/reg-arm.dat: Add last_g_reg and iWMMXT regs.
	* gdb/regformats/regdat.sh: Handle last_g_reg.
	* gdb/regformats/regdef.h (set_register_cache): Update prototype.
@
text
@a41 1
#include "observer.h"
a53 13
/* Extra information which ARM uses to select the appropriate GDB
   architecture.  */

struct gdbarch_tdep_info
{
  /* See the descriptions of these fields in struct gdbarch_tdep.  */

  int target_has_iwmmxt_regs;
  int target_iwmmxt_regnum;
  int target_has_vfp_regs;
  int target_vfp_regnum;
};

d1453 1
a1453 36
  int first;

  first = gdbarch_tdep (gdbarch)->first_iwmmxt_regnum;
  if (first != -1)
    {
      if (regnum >= first && regnum < first + NUM_IWMMXT_COP0REGS)
	return builtin_type_vec64i;

      first += NUM_IWMMXT_COP0REGS;

      if (regnum >= first && regnum < first + NUM_IWMMXT_COP1REGS)
	return builtin_type_int32;
    }

  first = gdbarch_tdep (gdbarch)->first_vfp_regnum;
  if (first != -1)
    {
      if (regnum >= first && regnum < first + NUM_VFP_XREGS)
	return builtin_type_int32;

      first += NUM_VFP_XREGS;

      if (regnum >= first && regnum < first + NUM_VFP_SREGS)
	return builtin_type_float;
    }

  first = gdbarch_tdep (gdbarch)->first_vfp_pseudo;
  if (first != -1)
    {
      first += gdbarch_num_regs (gdbarch);

      if (regnum >= first && regnum < first + NUM_VFP_PSEUDOS)
	return builtin_type_double;
    }

  if (regnum >= ARM_F0_REGNUM && regnum < ARM_F0_REGNUM + NUM_FPA_REGS)
a1469 5
  int offset;
  int first;

  offset = 0;
  first = 0;
d1472 7
a1478 149
  offset += NUM_GREGS * INT_REGISTER_SIZE;
  first += NUM_GREGS;

  if (regnum < first + NUM_FPA_REGS)
    return offset + (regnum - first) * FPA_REGISTER_SIZE;
  offset += NUM_FPA_REGS * FPA_REGISTER_SIZE;
  first += NUM_FPA_REGS;

  if (regnum < first + NUM_SREGS)
    return offset + (regnum - first) * STATUS_REGISTER_SIZE;
  offset += NUM_SREGS * STATUS_REGISTER_SIZE;
  
  first = gdbarch_tdep (current_gdbarch)->first_iwmmxt_regnum;
  if (first != -1)
    {
      if (regnum >= first && regnum < first + NUM_IWMMXT_COP0REGS)
	return offset + (regnum - first) * IWMMXT_COP0_REGSIZE;

      offset += NUM_IWMMXT_COP0REGS * IWMMXT_COP0_REGSIZE;
      first += NUM_IWMMXT_COP0REGS;

      if (regnum >= first && regnum < first + NUM_IWMMXT_COP1REGS)
	return offset + (regnum - first) * IWMMXT_COP1_REGSIZE;

      offset += NUM_IWMMXT_COP1REGS * IWMMXT_COP1_REGSIZE;
    }

  first = gdbarch_tdep (current_gdbarch)->first_vfp_regnum;
  if (first != -1)
    {
      if (regnum >= first && regnum < first + NUM_VFP_XREGS)
	return offset + (regnum - first) * VFP_XREG_SIZE;

      offset += NUM_VFP_XREGS * VFP_XREG_SIZE;
      first += NUM_VFP_XREGS;

      if (regnum >= first && regnum < first + NUM_VFP_SREGS)
	return offset + (regnum - first) * VFP_SREG_SIZE;
    }
  internal_error (__FILE__, __LINE__, _("Bad REGNUM %d"), regnum);
}

static void
arm_pseudo_register_read (struct gdbarch *gdbarch,
			  struct regcache *regcache,
			  int regnum, void *buf)
{
  int first;
  int low_regnum;
  int high_regnum;

  first = gdbarch_tdep (current_gdbarch)->first_vfp_pseudo;
  if (first != -1)
    {
      first += gdbarch_num_regs (gdbarch);

      if (regnum >= first && regnum < first + NUM_VFP_PSEUDOS)
	{
	  regnum = gdbarch_tdep (current_gdbarch)->first_vfp_regnum
	    + NUM_VFP_XREGS + 2 * (regnum - first);
	  if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_LITTLE)
	    {
	      low_regnum = regnum;
	      high_regnum = regnum + 1;
	    }
	  else
	    {
	      low_regnum = regnum + 1;
	      high_regnum = regnum;
	    }
	  regcache_raw_read (regcache, low_regnum, buf);
	  regcache_raw_read (regcache, high_regnum, ((char *)buf) + 4);
	  return;
	}
    }
  internal_error (__FILE__, __LINE__, _("Bad pseudo %d"), regnum);
}

static void
arm_pseudo_register_write (struct gdbarch *gdbarch,
			   struct regcache *regcache,
			   int regnum, const void *buf)
{
  int first;
  int low_regnum;
  int high_regnum;

  first = gdbarch_tdep (current_gdbarch)->first_vfp_pseudo;
  if (first != -1)
    {
      first += gdbarch_num_regs (gdbarch);

      if (regnum >= first && regnum < first + NUM_VFP_PSEUDOS)
	{
	  regnum = gdbarch_tdep (current_gdbarch)->first_vfp_regnum
	    + NUM_VFP_XREGS + 2 * (regnum - first);
	  if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_LITTLE)
	    {
	      low_regnum = regnum;
	      high_regnum = regnum + 1;
	    }
	  else
	    {
	      low_regnum = regnum + 1;
	      high_regnum = regnum;
	    }
	  regcache_raw_write (regcache, low_regnum, buf);
	  regcache_raw_write (regcache, high_regnum + 1, ((char *)buf) + 4);
	  return;
	}
    }
  internal_error (__FILE__, __LINE__, _("Bad pseudo %d"), regnum);
}

/* Map DWARF register numbers onto internal GDB register numbers.  */
static int
arm_dwarf_reg_to_regnum (int reg)
{
  int first;
 
  if (reg >= 0 && reg <= 16)
    return reg; /* Core integer regs.  */
  if (reg >= 16 && reg <= 23)
    return ARM_F0_REGNUM + reg - 16; /* Legacy FPA encoding.  */
  if (reg >= 96 && reg <= 103)
    return ARM_F0_REGNUM + reg - 96; /* FPA regs.  */

  /* VFP regs.  */
  first = gdbarch_tdep (current_gdbarch)->first_vfp_regnum;
  if (first != -1 && reg >= 64 && reg <= 95);
      return first + NUM_VFP_XREGS + reg - 64;;

  /* iWMMXt regs.  */
  first = gdbarch_tdep (current_gdbarch)->first_iwmmxt_regnum;
  if (first != -1)
    {
      if (reg >= 112 && reg <= 127) /* wr0-wr15 */
	return first + reg - 112;
      first += NUM_IWMMXT_COP0REGS;
      if (reg >= 192 && reg <= 199) /* wc0-wc7 */
	return first + reg - 104;
      first += 8;
      if (reg >= 104 && reg <= 111) /*wcgr0-wcgr7 */
	return first + reg - 104;
    }

  warning (_("Unmapped DWARF Register #%d encountered."), reg);

  return -1;
a1487 8
  if (gdbarch_tdep (current_gdbarch)->first_iwmmxt_regnum != -1)
    {
      int first = gdbarch_tdep (current_gdbarch)->first_iwmmxt_regnum;

      if (regnum >= first && regnum < first + NUM_IWMMXT_REGS)
	return SIM_ARM_IWMMXT_COP0R0_REGNUM + (regnum - first);
    }

d1492 1
a1492 1
  if (reg < NUM_FPA_REGS)
d1494 1
a1494 1
  reg -= NUM_FPA_REGS;
a1502 29
/* Map GDB internal REGNUM onto the current remote protocol
   register numbers.  */

static int
arm_register_remote_regno (int regnum)
{
  gdb_assert (regnum >= 0 && regnum < NUM_REGS);

  if (gdbarch_tdep (current_gdbarch)->first_iwmmxt_regnum != -1)
    {
      int first = gdbarch_tdep (current_gdbarch)->first_iwmmxt_regnum;

      if (regnum >= first && regnum < first + NUM_IWMMXT_REGS)
	return gdbarch_tdep (current_gdbarch)->target_iwmmxt_regnum
			     + (regnum - first);
    }

  if (gdbarch_tdep (current_gdbarch)->first_vfp_regnum != -1)
    {
      int first = gdbarch_tdep (current_gdbarch)->first_vfp_regnum;

      if (regnum >= first && regnum < first + NUM_VFP_XREGS + NUM_VFP_SREGS)
	return gdbarch_tdep (current_gdbarch)->target_vfp_regnum
			     + (regnum - first);
    }

  return regnum;
}

d2106 1
a2106 1
	    bfd_byte tmpbuf[FPA_REGISTER_SIZE];
d2574 1
a2574 1
arm_register_name (int regnum)
d2576 1
a2576 51
  int first;

  first = gdbarch_tdep (current_gdbarch)->first_iwmmxt_regnum;
  if (first != -1)
    {
      static const char *const iwmmxt_register_names[] = 
	{
	  "wr0", "wr1", "wr2", "wr3", "wr4", "wr5", "wr6", "wr7",
	  "wr8", "wr9", "wr10", "wr11", "wr12", "wr13", "wr14", "wr15",
	  "wcid", "wcon", "wcssf", "wcasf", "", "", "", "",
	  "wcgr0", "wcgr1", "wcgr2", "wcgr3", "", "", "", ""
	};

      if (regnum >= first && regnum < first + NUM_IWMMXT_REGS)
	return iwmmxt_register_names[regnum - first];
    }

  first = gdbarch_tdep (current_gdbarch)->first_vfp_regnum;
  if (first != -1)
    {
      static const char *const vfp_register_names[] = 
	{
	  "fpsid", "fpscr", "", "", "", "", "", "",
	  "fpexc", "", "", "", "", "", "", "",
	  "s0",  "s1",  "s2",  "s3",  "s4",  "s5",  "s6",  "s7",
	  "s8",  "s9",  "s10", "s11", "s12", "s13", "s14", "s15",
	  "s16", "s17", "s18", "s19", "s20", "s21", "s22", "s23",
	  "s24", "s25", "s26", "s27", "s28", "s29", "s30", "s31"
	};

      if (regnum >= first && regnum < first + NUM_VFP_XREGS + NUM_VFP_SREGS)
	return vfp_register_names[regnum - first];
    }

  first = gdbarch_tdep (current_gdbarch)->first_vfp_pseudo;
  if (first != -1)
    {
      static const char *const vfp_pseudo_names[] = 
	{
	  "d0", "d1", "d2",  "d3",  "d4",  "d5",  "d6",  "d7",
	  "d8", "d9", "d10", "d11", "d12", "d13", "d14", "d15",
	};

      first += gdbarch_num_regs (current_gdbarch);

      if (regnum >= first && regnum < first + NUM_VFP_PSEUDOS)
	return vfp_pseudo_names[regnum - first];
    }

  gdb_assert (regnum < NUM_GREGS + NUM_FPA_REGS + NUM_SREGS);
  return arm_register_names[regnum];
a2683 64

/* */

static char *
arm_sim_available_registers (struct gdbarch *gdbarch,
			     const struct target_ops *target)
{
  /* The built-in simulator supports iWMMXt.  */
  return xstrdup ("iwmmxt");
}

/* Update the current architecture based on architecture features.  */

static void
arm_update_architecture (struct target_ops *target, int from_tty)
{
  struct gdbarch_tdep_info tdep;
  struct gdbarch_info info;
  char buf[64];
  int bytes_read;

  memset (&tdep, 0, sizeof (tdep));

  /* FIXME: Define TARGET_READ_FULL which allocates the buffer large
     enough, modelled on auxv.c.  */
  bytes_read = target_read_partial (target, TARGET_OBJECT_AVAILABLE_REGISTERS,
				    "", buf, 0, 64);

  /* "Parse" the response.  */
  if (bytes_read == 6 && strncmp (buf, "iwmmxt", 6) == 0)
    {
      tdep.target_has_iwmmxt_regs = 1;
      tdep.target_iwmmxt_regnum = -1;
    }
  else if (bytes_read > 6 && strncmp (buf, "iwmmxt:", 7) == 0)
    {
      char *end;
      tdep.target_has_iwmmxt_regs = 1;
      tdep.target_iwmmxt_regnum = strtol (buf + 7, &end, 16);
    }
  else
    {
      tdep.target_has_iwmmxt_regs = 0;
      tdep.target_iwmmxt_regnum = -1;
    }

  if (bytes_read > 3 && strncmp (buf, "vfp:", 4) == 0)
    {
      char *end;
      tdep.target_has_vfp_regs = 1;
      tdep.target_vfp_regnum = strtol (buf + 4, &end, 16);
    }
  else
    {
      tdep.target_has_vfp_regs = 0;
      tdep.target_vfp_regnum = -1;
    }

  /* Update the architecture.  */
  gdbarch_info_init (&info);
  info.tdep_info = &tdep;
  if (!gdbarch_update_p (info))
    internal_error (__FILE__, __LINE__, "could not update architecture");
}
a2700 2
  int nregs;
  int pseudos;
a2794 19
      /* If we have target-specific bits in INFO, then make sure
	 they match.  */
      if (info.tdep_info)
	{
	  if (gdbarch_tdep (best_arch->gdbarch)->target_has_iwmmxt_regs
	      != info.tdep_info->target_has_iwmmxt_regs)
	    continue;
	  if (gdbarch_tdep (best_arch->gdbarch)->target_iwmmxt_regnum
	      != info.tdep_info->target_iwmmxt_regnum)
	    continue;

	  if (gdbarch_tdep (best_arch->gdbarch)->target_has_vfp_regs
	      != info.tdep_info->target_has_vfp_regs)
	    continue;
	  if (gdbarch_tdep (best_arch->gdbarch)->target_vfp_regnum
	      != info.tdep_info->target_vfp_regnum)
	    continue;
	}

a2815 29
  if (info.tdep_info)
    {
      /* If specific target capabilities were requested, use them.  */
      tdep->target_has_iwmmxt_regs = info.tdep_info->target_has_iwmmxt_regs;
      tdep->target_iwmmxt_regnum = info.tdep_info->target_iwmmxt_regnum;
      tdep->target_has_vfp_regs = info.tdep_info->target_has_vfp_regs;
      tdep->target_vfp_regnum = info.tdep_info->target_vfp_regnum;
    }
  else if (arches)
    {
      /* Otherwise, inherit from the last ARM architecture, if any.  */
      tdep->target_has_iwmmxt_regs
	= gdbarch_tdep (arches->gdbarch)->target_has_iwmmxt_regs;
      tdep->target_iwmmxt_regnum
	= gdbarch_tdep (arches->gdbarch)->target_iwmmxt_regnum;
      tdep->target_has_vfp_regs
	= gdbarch_tdep (arches->gdbarch)->target_has_vfp_regs;
      tdep->target_vfp_regnum
	= gdbarch_tdep (arches->gdbarch)->target_vfp_regnum;
    }
  else
    {
      /* Set defaults.  */
      tdep->target_has_iwmmxt_regs = 0;
      tdep->target_iwmmxt_regnum = -1;
      tdep->target_has_vfp_regs = 0;
      tdep->target_vfp_regnum = -1;
    }

d2880 1
a2882 33
  nregs = NUM_GREGS + NUM_FPA_REGS + NUM_SREGS;
  pseudos = 0;
  if (tdep->target_has_iwmmxt_regs)
    {
      tdep->first_iwmmxt_regnum = nregs;
      nregs += NUM_IWMMXT_REGS;
    }
  else
    tdep->first_iwmmxt_regnum = -1;

  if (tdep->target_has_vfp_regs)
    {
      tdep->first_vfp_regnum = nregs;
      nregs += NUM_VFP_XREGS + NUM_VFP_SREGS;
      tdep->first_vfp_pseudo = pseudos;
      pseudos += NUM_VFP_PSEUDOS;
    }
  else
    {
      tdep->first_vfp_regnum = -1;
      tdep->first_vfp_pseudo = -1;
    }

  set_gdbarch_num_regs (gdbarch, nregs);
  set_gdbarch_num_pseudo_regs (gdbarch, pseudos);
  set_gdbarch_pseudo_register_read (gdbarch, arm_pseudo_register_read);
  set_gdbarch_pseudo_register_write (gdbarch, arm_pseudo_register_write);

  /* The FPA registers are included in the remote 'g' packet for
     historic reasons.  */
  set_gdbarch_remote_num_g_packet_regs (gdbarch,
					NUM_GREGS + NUM_FPA_REGS + NUM_SREGS);

a2883 2
  set_gdbarch_dwarf_reg_to_regnum (gdbarch, arm_dwarf_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, arm_dwarf_reg_to_regnum);
a2885 3
  set_gdbarch_sim_available_registers (gdbarch, arm_sim_available_registers);
  set_gdbarch_register_remote_regno (gdbarch, arm_register_remote_regno);

a3080 2

  observer_attach_inferior_created (arm_update_architecture);
@


1.201.2.2
log
@2005-10-20  Paul Brook  <paul@@codesourcery.com>

	* arm-tdep.c (arm_iwmmxt_type): New.
	(arm_build_iwmmxt_type): New function.
	(arm_register_type): Use it.
@
text
@a1460 36
/* Type for iWMMXt registers.  */
static struct type *arm_iwmmxt_type;

/* Construct the type for iWMMXt registers.  */
static struct type *
arm_build_iwmmxt_type (void)
{
  /* The type we're building is this: */
#if 0
  union __gdb_builtin_type_vec64i 
  {
    int64_t uint64;
    int32_t v2_int32[2];
    int16_t v4_int16[4];
    int8_t v8_int8[8];
  };
#endif

  if (!arm_iwmmxt_type)
    {
      struct type *t;

      t = init_composite_type ("__gdb_builtin_type_vec64i", TYPE_CODE_UNION);
      append_composite_type_field (t, "uint64", builtin_type_int64);
      append_composite_type_field (t, "v2_int32", builtin_type_v2_int32);
      append_composite_type_field (t, "v4_int16", builtin_type_v4_int16);
      append_composite_type_field (t, "v8_int8", builtin_type_v8_int8);

      TYPE_FLAGS (t) |= TYPE_FLAG_VECTOR;
      TYPE_NAME (t) = "builtin_type_vec64i";

      arm_iwmmxt_type = t;
    }

  return arm_iwmmxt_type;
}
d1473 1
a1473 1
	return arm_build_iwmmxt_type ();
@


1.201.2.3
log
@        * gdb/arm-tdep.c (submask, bit, bits, sbits): Move macro definitions.
        (thumb_skip_prologue): Don't require frame pointer. Handle Thumb-2
        prologue instructions.
        (thumb_get_insn): New function. Read a Thumb or Thumb-2 instruction
        from memory.
        (arm_skip_prologue): Change comment to include Thumb-2.
        (thumb2_modify_constant): New function. Perform the Thumb-2 12-bit
        immediate transformation.
        (thumb_scan_prologue): Handle Thumb-2 prologue instructions.
@
text
@a210 8
/* Support routines for bitfield extraction.  */

#define submask(x) ((1L << ((x) + 1)) - 1)
#define bit(obj,st) (((obj) >> (st)) & 1)
#define bits(obj,st,fn) (((obj) >> (st)) & submask ((fn) - (st)))
#define sbits(obj,st,fn) \
  ((long) (bits(obj,st,fn) | ((long) bit(obj,fn) * ~ submask (fn - st))))

d268 23
a290 27
/* Read a thumb instruction from memory. 16-bit instructions are returned in
   the lower half of the returned word. 32-bit instructions are returned with
   the first halfword at the most-significant end. If non-zero, the int
   pointed to by length is set to the instruction's length in bytes.  */

static unsigned long
thumb_get_insn (CORE_ADDR addr, int *length)
{
  unsigned long insn = read_memory_unsigned_integer (addr, 2);
  int len = 2;

  if ((insn & 0xf800) > 0xe000)
    {
      insn = (insn << 16) | read_memory_unsigned_integer (addr + 2, 2);
      len = 4;
    }

  if (length)
    *length = len;

  return insn;
}

/* Advance the PC across any function entry prologue instructions, apart
   from those which have been scheduled later into the function. This function
   handles Thumb and Thumb-2 prologues.
   We skip over instructions of the form:
d292 3
a294 10
     - push  OR  stmdb  OR  str rn,[sp,#-4]!  OR  fstmdb
     - mov r7, sp  OR  add r7, sp, #imm
     - sub.n sp, sp, #n  OR  sub.w sp, sp, #n
  
   That is, instructions which push callee-saved registers onto the stack,
   instructions to move SP to FP (if there is one) with a possible offset, and
   instructions to decrement the stack pointer.
 
   GCC usually optimises the frame pointer away at > -O0, so we don't require
   all the above to be present.  */
d300 6
d307 3
a309 1
  for (current_pc = pc; current_pc < func_end && current_pc < pc+40;)
d311 1
a311 2
      int length;
      unsigned long insn = thumb_get_insn (current_pc, &length);
d313 25
a337 13
      /* FIXME: stmdb must store two or more registers!  */
      if ((insn & 0xfffffe00) == 0xb400               /* push  */
	  || (insn & 0xffffa000) == 0xe92d0000        /* stmdb.w sp!,{...}  */
	  || (insn & 0xffff0fff) == 0xf84d0d04        /* str rn, [sp, #-4]!  */
	  || (insn & 0xffff0f00) == 0xed2d0b00)       /* fstmdb[xd] sp!,{..}  */
	;
      else if (insn == 0x466f)                        /* mov r7, sp  */
	;
      else if ((insn & 0xffffff00) == 0xaf00)         /* add r7, sp, #imm  */
	;
      else if ((insn & 0xffffff00) == 0xb000          /* add/sub sp, #n  */
	       || (insn & 0xfbef8f00) == 0xf1ad0d00)  /* sub.w sp, sp, #n  */
	;
d339 5
a343 1
	break;
a344 2
      current_pc += length;
    }
d393 1
a393 1
  /* Check if this is Thumb[-2] code.  */
a463 47
/* Perform the Thumb-2 modify-constant(imm12) transformation.
   This is how the transformation works:
     1. 0...255 are represented as-is.

     2. Otherwise the 32-bit constant is normalized by rotating left until the
     most-significant bit is bit 7. The size of the rotation is then encoded
     in bits 7-11, overwriting bit 7.

     3. Constants of form 0x00XY00XY have bits[11:8] of imm12 set to 0b0001
     and bits[7:0] set to 0xXY.

     4. Constants of form 0xXY00XY00 as above, but bits[11:8] of imm12 are set
     to 0b0010.

     5. Similarly constants of form 0xXYXYXYXY have bits[11:8] set to 0b0011.
*/

static unsigned long
thumb2_modify_constant (unsigned long imm12)
{
  unsigned int rotation = bits (imm12, 7, 11);
  unsigned int replicate = rotation >> 1;  /* bits 8-11.  */

  if (rotation >= 8)
    {
      imm12 = bits (imm12, 0, 6) | 0x80;
      return (imm12 >> rotation) | (imm12 << (32 - rotation));
    }
  else
    {
      switch (replicate)
	{
	case 0:
	  return imm12;

	case 1:
	  return imm12 | (imm12 << 16);

	case 2:
	  return (imm12 << 8) | (imm12 << 24);

	case 3:
	  return imm12 | (imm12 << 8) | (imm12 << 16) | (imm12 << 24);
	}
    }
}

d529 2
a530 1
       (current_pc < prologue_end) && ((findmask & 7) != 7);)
d532 1
a532 2
      unsigned long insn;
      int length;
d536 1
a536 1
      insn = thumb_get_insn (current_pc, &length);
d538 1
a538 1
      if ((insn & 0xfffffe00) == 0xb400)	/* push { rlist } */
d556 1
a556 30
      else if (((insn & 0xffffa000) == 0xe92d0000)
	       && bitcount (insn & 0x5fff) > 1) /* stmfd.w sp!, { rlist }  */
	{
          unsigned int mask;
	  findmask |= 1;

	  /* As above, but Thumb-2 can store R0-R12 and LR.  */
          mask = insn & 0x5fff;

	  for (regno = ARM_LR_REGNUM; regno >= 0; regno--)
	    if (mask & (1 << regno))
	      {
                cache->framesize += 4;
		/* Thumb-2 doesn't need to copy high registers to low registers
		   in order to push them, so we don't need the saved_reg
		   array.  */
		cache->saved_regs[regno].addr = -cache->framesize;
	      }
	}
      else if ((insn & 0xffff0fff) == 0xf84d0d04)  /* str.w rn, [sp, #-4]!  */
	{
	  /* A single callee-saved high register (except LR) is saved with an
	     STR instruction on Thumb-2.  */
          int rn = bits (insn, 12, 15);
	  cache->framesize += 4;
	  /* Again, no need to use saved_reg[] because the high register will
	     be pushed directly when using Thumb-2.  */
	  cache->saved_regs[rn].addr = -cache->framesize;
	}
      else if ((insn & 0xffffff00) == 0xb000)	/* add sp, #simm  OR  
d560 1
a560 1
	    goto next_iter;
d572 1
a572 18
      else if ((insn & 0xfbef8f00) == 0xf1ad0d00)  /* sub.w sp, sp, #imm  */
	{
          unsigned int imm;

	  if ((findmask & 1) == 0)              /* before push?  */
	    goto next_iter;
	  else
	    findmask |= 4;                      /* sub sp found.  */

	  imm = bits (insn, 0, 7) | (bits (insn, 12, 14) << 8)
	        | (bit (insn, 26) << 11);

	  imm = thumb2_modify_constant (imm);

	  cache->frameoffset += imm;
	  cache->framesize += offset;
	}
      else if ((insn & 0xffffff00) == 0xaf00)	/* add r7, sp, #imm */
d586 1
a586 1
      else if ((insn & 0xffffffc0) == 0x4640)	/* mov r0-r7, r8-r15 */
d596 1
a596 4
	goto next_iter;

    next_iter:
      current_pc += length;
d1845 5
@


1.201.2.4
log
@    * gdb/arm-tdep.c (bitcount): Move function higher up in file.
    (thumb2_it_block): New function. Find the next instruction to be
    executed in an IT block.
    (thumb_get_next_pc): Handle 16- and 32-bit Thumb-2 instructions.
@
text
@a222 11
/* Return number of 1-bits in VAL.  */

static int
bitcount (unsigned long val)
{
  int nbits;
  for (nbits = 0; val != 0; nbits++)
    val &= val - 1;		/* delete rightmost 1-bit in val */
  return nbits;
}

d1993 1
d1995 2
a1996 5
/* Find the next instruction to be executed in an IT block.  */

static CORE_ADDR
thumb2_it_block (CORE_ADDR nextpc, unsigned long status, unsigned int cond,
                 unsigned int mask)
d1998 4
a2001 25
  int cond_true = condition_true (cond, status);
  int numinsns;

  if ((mask & 0x7) == 0)
    numinsns = 1;
  else if ((mask & 0x3) == 0)
    numinsns = 2;
  else if ((mask & 0x1) == 0)
    numinsns = 3;
  else
    numinsns = 4;

  for (; numinsns > 0; numinsns--, mask <<= 1)
    {
      int length;
      thumb_get_insn (nextpc, &length);

      if ((cond_true && (mask & 0x8))
	  || (!cond_true && !(mask & 0x8)))
	break;

      nextpc += length;
    }

  return nextpc;
a2003 4
/* Get next Thumb PC. We must consider both 16-bit and 32-bit instructions
   which can modify control flow. Thankfully, this doesn't include most of the
   ALU instructions (unlike ARM).  */

d2007 3
a2009 4
  int length;
  unsigned long inst = thumb_get_insn (pc, &length);
  unsigned long status = read_register (ARM_PS_REGNUM);
  CORE_ADDR nextpc = pc + length;
d2012 1
a2012 39
  /* Check CPSR to see if we're in the middle of an IT block.  */

  if (bits (status, 13, 15) != 0)
    {
      int cond = bits (status, 12, 15);
      int mask = bits (status, 25, 26) | (bits (status, 10, 11) << 2);
      return thumb2_it_block (nextpc, status, cond, mask);
    }

  /* Thumb/Thumb-2 16-bit instructions.  */
 
  /* If-Then. We must:
     (a) Decode the IT instruction.
     (b) Evaluate the current condition.
     (c) Insert breakpoint on one of the following four instructions, depending
     on the IT mask and (2).

     Subsequent conditional instructions are handled by decoding the CPSR,
     above.
  */
  if ((inst & 0xffffff00) == 0xbf00
      && (inst & 0x000f) != 0)
    {
      unsigned int mask = inst & 0xf;
      unsigned int cond = bits (inst, 4, 7);
      return thumb2_it_block (nextpc, status, cond, mask);
    }
  /* Compare zero and branch.  */
  else if ((inst & 0xfffff500) == 0xb100)
    {
      int reg = bits (inst, 0, 2);
      unsigned int regval = read_register (reg);
      int not_equal = bit (inst, 11);
      int do_branch = (regval == 0) ^ not_equal;
      unsigned int offset = (bits (inst, 3, 7) << 1) | (bit (inst, 9) << 6);
      if (do_branch)
	nextpc = pc + 4 + offset;
    }
  else if ((inst & 0xffffff00) == 0xbd00)         /* pop {rlist, pc} */
d2018 1
a2018 1
      offset = bitcount (bits (inst, 0, 7)) * DEPRECATED_REGISTER_SIZE;
d2022 2
d2025 1
a2025 1
  else if ((inst & 0xfffff000) == 0xd000)         /* conditional branch */
d2028 1
a2028 1
      unsigned long cond = bits (inst, 8, 11);
d2030 5
a2034 1
	nextpc = pc + 4 + (sbits (inst, 0, 7) << 1);
d2036 1
a2036 1
  else if ((inst & 0xfffff800) == 0xe000)         /* unconditional branch */
d2038 6
a2043 1
      nextpc = pc + 4 + (sbits (inst, 0, 10) << 1);
d2045 1
a2045 1
  else if ((inst & 0xffffff00) == 0x4700)         /* bx REG, blx REG */
d2047 2
a2048 2
      if (bits (inst, 3, 6) == 0x0f)
	nextpc = pc + 4;
d2050 1
a2050 1
	nextpc = read_register (bits (inst, 3, 6));
d2053 2
a2056 129
  /* 32-bit instructions.  */

  else if ((inst & 0xf800d000) == 0xf0009000      /* B (unconditional)  */
           || (inst & 0xf800d000) == 0xf000d000)  /* BL  */
    {
      unsigned int s = bit (inst, 26);
      unsigned int i1 = bit (inst, 13);
      unsigned int i2 = bit (inst, 11);
      unsigned int offset = (bits (inst, 0, 10) << 1)
	                    | (bits (inst, 16, 25) << 12)
			    | (!(i2 ^ s) << 22)
			    | (!(i1 ^ s) << 23)
			    | (s << 24);
      nextpc = pc + 4 + sbits (offset, 0, 24);
    }
  else if ((inst & 0xf800d000) == 0xf0008000)     /* B (conditional)  */
    {
      unsigned int s = bit (inst, 26);
      unsigned int j1 = bit (inst, 13);
      unsigned int j2 = bit (inst, 11);
      unsigned int offset = (bits (inst, 0, 10) << 1)
	                  | (bits (inst, 16, 21) << 12)
			  | (j1 << 18)
			  | (j2 << 19)
			  | (s << 20);
      unsigned int cond = bits (inst, 22, 25);
      int cond_true = condition_true (cond, status);
      if (cond_true)
	nextpc = pc + 4 + sbits (offset, 0, 20);
    }
  else if ((inst & 0xf800d001) == 0xf000c000)     /* BLX  */
    {
      unsigned int s = bit (inst, 26);
      unsigned int i1 = bit (inst, 13);
      unsigned int i2 = bit (inst, 11);
      unsigned int offset = (bits (inst, 1, 10) << 2)
	                    | (bits (inst, 16, 25) << 12)
			    | (!(i2 ^ s) << 22)
			    | (!(i1 ^ s) << 23)
			    | (s << 24);
      nextpc = ((pc + 4) & 0xfffffffc) + sbits (offset, 0, 24);
    }
  else if (((inst & 0xffd08000) == 0xe9108000     /* LDM rb,{..pc..}  */
            || (inst & 0xffd08000) == 0xe8908000)
           && bitcount (inst & 0x0000dfff) > 1)
    {
      int incr_after = bit (inst, 23);
      /* We know the PC is loaded because of the mask we use to detect the
         instruction. LR cannot be loaded at the same time, so just count
	 r0-r12.  */
      int numregs = bitcount (bits (inst, 0, 12));
      CORE_ADDR base = read_register (bits (inst, 16, 19));
      CORE_ADDR pcaddr = incr_after ? base + 4 * numregs : base - 4;
      nextpc = read_memory_integer (pcaddr, 4) & 0xfffffffe;
    }
  else if ((inst & 0xfff0f000) == 0xf8d0f000)     /* LDR pc, [rn, #imm]  */
    {
      CORE_ADDR base = read_register (bits (inst, 16, 19));
      int offset = bits (inst, 0, 11);
      nextpc = read_memory_integer (base + offset, 4) & 0xfffffffe;
    }
  else if ((inst & 0xfff0ff00) == 0xf850fc00)     /* LDR pc, [rn, #-imm]  */
    {
      CORE_ADDR base = read_register (bits (inst, 16, 19));
      int offset = bits (inst, 0, 7);
      nextpc = read_memory_integer (base - offset, 4) & 0xfffffffe;
    }
  else if ((inst & 0xfff0fd00) == 0xf850f900)     /* LDR pc, [rn], #+/-imm  */
    {
      CORE_ADDR addr = read_register (bits (inst, 16, 19));
      nextpc = read_memory_integer (addr, 4) & 0xfffffffe;
    }
  else if ((inst & 0xfff0fd00) == 0xf850fd00)     /* LDR pc, [rn, #+/-imm]  */
    {
      CORE_ADDR base = read_register (bits (inst, 16, 19));
      int plus = bit (inst, 9);
      int offset = bits (inst, 0, 7);
      CORE_ADDR addr = plus ? base + offset : base - offset;
      nextpc = read_memory_integer (addr, 4) & 0xfffffffe;
    }
  else if ((inst & 0xfff0ffc0) ==0xf850f000)      /* LDR pc, [rn, rm, lsl]  */
    {
      CORE_ADDR base = read_register (bits (inst, 16, 19));
      CORE_ADDR index = read_register (bits (inst, 0, 3));
      int shift = bits (inst, 4, 5);
      nextpc = read_memory_integer (base + (index << shift), 4) & 0xfffffffe;
    }
  else if ((inst & 0xff7ff000) == 0xf85ff000)     /* LDR pc, [pc, #+/-imm]  */
    {
      CORE_ADDR base = (pc + 4) & 0xfffffffc;
      int plus = bit (inst, 23);
      int offset = bits (inst, 0, 11);
      CORE_ADDR addr = plus ? base + offset : base - offset;
      nextpc = read_memory_integer (addr, 4) & 0xfffffffe;
    }
  else if (((inst & 0xffd00000) == 0xe8100000)    /* RFE  */
           || ((inst & 0xffd00000) == 0xe9900000))
    {
      unsigned int incr_after = bit (inst, 23);
      CORE_ADDR base = read_register (bits (inst, 16, 19));
      CORE_ADDR pcaddr = incr_after ? base : base - 8;
      nextpc = read_memory_integer (pcaddr, 4) & 0xfffffffe;
    }
  else if ((inst & 0xffffdf00) == 0xf3de8f00)     /* SUBS PC, LR, #imm  */
    {
      int imm = bits (inst, 0, 7);
      CORE_ADDR lr = read_register (ARM_LR_REGNUM);
      nextpc = lr - imm;
    }
  else if ((inst & 0xfff000f0) == 0xe8d00000)     /* TBB  */
    {
      unsigned int rn = bits (inst, 16, 19);
      CORE_ADDR base = (rn == ARM_PC_REGNUM) ? pc + 4 : read_register (rn);
      unsigned int index = read_register (bits (inst, 0, 3));
      unsigned int offset = read_memory_unsigned_integer (base + index, 1) << 1;
      nextpc = pc + offset;
    }
  else if ((inst & 0xfff000f0) == 0xe8d00010)     /* TBH  */
    {
      unsigned int rn = bits (inst, 16, 19);
      CORE_ADDR base = (rn == ARM_PC_REGNUM) ? pc + 4 : read_register (rn);
      unsigned int index = read_register (bits (inst, 0, 3)) << 1;
      unsigned int offset = read_memory_unsigned_integer (base + index, 2) << 1;
      nextpc = pc + offset;
    }

  if (nextpc == pc)
    error (_("Infinite loop detected"));

@


1.201.2.5
log
@        * gdb/arm-tdep.c (thumb2_modify_constant): Silence compiler warning.
        (thumb_scan_prologue): Fix typo.
@
text
@a517 2

  return 0;
d672 1
a672 1
	  cache->framesize += imm;
@


1.200
log
@* arm-tdep.c (set_disassembly_style, _initialize_arm_tdep):
Consitify regnames.
@
text
@d1207 48
d1306 1
d1314 29
a2174 11
/* Extract from an array REGBUF containing the (raw) register state
   the address in which a function should return its structure value.  */

static CORE_ADDR
arm_extract_struct_value_address (struct regcache *regcache)
{
  ULONGEST ret;

  regcache_cooked_read_unsigned (regcache, ARM_A1_REGNUM, &ret);
  return ret;
}
d2181 1
a2181 1
arm_use_struct_convention (int gcc_p, struct type *type)
d2212 5
d2364 26
d2669 1
a2669 1
  unsigned int elfosabi, eflags;
d2747 3
d2891 1
a2891 4
  set_gdbarch_extract_return_value (gdbarch, arm_extract_return_value);
  set_gdbarch_store_return_value (gdbarch, arm_store_return_value);
  set_gdbarch_deprecated_use_struct_convention (gdbarch, arm_use_struct_convention);
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, arm_extract_struct_value_address);
@


1.199
log
@* arm-tdep.c (arm_prologue_prev_register)
(arm_sigtramp_prev_register): Change type of last argument to
`gdb_byte *'.
@
text
@d2484 1
a2484 1
  const char *setname, *setdesc, **regnames;
d2878 1
a2878 1
  const char **regnames;
@


1.198
log
@* arm-tdep.c (arm_extract_return_value, arm_store_return_value):
Change type of last argument to `gdb_byte *'.
@
text
@d956 1
a956 1
			    void *valuep)
d1116 1
a1116 1
			    void *valuep)
@


1.197
log
@	* arm-tdep.c (fp_model_strings): Add terminating NULL.
	(arm_abi_strings, arm_abi_global, arm_abi_string): New
	variables.
	(arm_extract_return_value, arm_store_return_value): Don't use
	arm_get_fp_model.
	(arm_get_fp_model, arm_set_fp): Delete.
	(arm_update_current_architecture): New function.
	(set_fp_model_sfunc): Call arm_update_current_architecture.
	(show_fp_model): Update output messages.
	(arm_set_abi, arm_show_abi): New functions.
	(arm_elf_osabi_sniffer): Only handle ELFOSABI_ARM.
	(arm_gdbarch_init): Infer the object's ABI separately from its
	OSABI.  Search for a matching architecture.  Honor the global
	ABI and FPU settings.  Set floating point format based on the
	architecture.
	(arm_init_abi_eabi_v1, arm_init_abi_eabi_v2, arm_init_abi_apcs):
	Delete.
	(_initialize_arm_tdep): Don't call gdbarch_register_osabi.
	Create "arm set abi" command.
	* arm-tdep.h (arm_get_fp_model): Delete prototype.
	(enum arm_abi_kind): New type.
	(struct gdbarch_tdep): Add arm_abi field.
	* arm-linux-tdep.c (arm_linux_init_abi): Only override
	tdep->fp_model if it is ARM_FLOAT_AUTO.
	* armnbsd-tdep.c (arm_netbsd_aout_init_abi): Likewise.
	(arm_netbsd_elf_init_abi): Likewise.
	* defs.h (enum gdb_osabi): Delete ARM-specific OSABIs.
	* osabi.c (gdb_osabi_name): Likewise.
@
text
@d2016 2
a2017 3
arm_extract_return_value (struct type *type,
			  struct regcache *regs,
			  void *dst)
a2018 2
  bfd_byte *valbuf = dst;

d2210 1
a2210 1
			const void *src)
a2211 2
  const bfd_byte *valbuf = src;

@


1.196
log
@	* Makefile.in (arm-tdep.o): Update dependencies.
	* arm-tdep.c: Include "objfiles.h" and "dwarf2-frame.h".
	(arm_gdbarch_init): Register dwarf2_frame_sniffer.
@
text
@d110 2
a111 1
  "vfp"
d118 13
d2024 1
a2024 1
      switch (arm_get_fp_model (current_gdbarch))
d2221 1
a2221 1
      switch (arm_get_fp_model (current_gdbarch))
d2378 2
a2379 2
enum arm_float_model
arm_get_fp_model (struct gdbarch *gdbarch)
d2381 1
a2381 2
  if (arm_fp_model == ARM_FLOAT_AUTO)
    return gdbarch_tdep (gdbarch)->fp_model;
d2383 3
a2385 2
  return arm_fp_model;
}
d2387 2
a2388 4
static void
arm_set_fp (struct gdbarch *gdbarch)
{
  enum arm_float_model fp_model = arm_get_fp_model (gdbarch);
d2390 2
a2391 14
  if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_LITTLE 
      && (fp_model == ARM_FLOAT_SOFT_FPA || fp_model == ARM_FLOAT_FPA))
    {
      set_gdbarch_double_format	(gdbarch,
				 &floatformat_ieee_double_littlebyte_bigword);
      set_gdbarch_long_double_format
	(gdbarch, &floatformat_ieee_double_littlebyte_bigword);
    }
  else
    {
      set_gdbarch_double_format (gdbarch, &floatformat_ieee_double_little);
      set_gdbarch_long_double_format (gdbarch,
				      &floatformat_ieee_double_little);
    }
d2411 1
a2411 2
  if (gdbarch_bfd_arch_info (current_gdbarch)->arch == bfd_arch_arm)
    arm_set_fp (current_gdbarch);
d2420 38
a2457 2
  deprecated_show_value_hack (file, from_tty, c, value);
  if (arm_fp_model == ARM_FLOAT_AUTO 
d2459 6
a2464 3
    /* i18n: "the default [floating point model] for the current ABI..." */
    printf_filtered (_("  - the default for the current ABI is \"%s\".\n"),
		     fp_model_strings[tdep->fp_model]);
d2581 6
a2586 64
  switch (elfosabi)
    {
    case ELFOSABI_NONE:  
      /* When elfosabi is ELFOSABI_NONE (0), then the ELF structures in the
	 file are conforming to the base specification for that machine 
	 (there are no OS-specific extensions).  In order to determine the 
	 real OS in use we must look for OS notes that have been added.  */
      bfd_map_over_sections (abfd,
			     generic_elf_osabi_sniff_abi_tag_sections,  
			     &osabi);
      if (osabi == GDB_OSABI_UNKNOWN)
	{
	  /* Existing ARM tools don't set this field, so look at the EI_FLAGS
	     field for more information.  */
	  eflags = EF_ARM_EABI_VERSION(elf_elfheader(abfd)->e_flags);
	  switch (eflags)
	    {
	    case EF_ARM_EABI_VER1:
	      osabi = GDB_OSABI_ARM_EABI_V1;
	      break;

	    case EF_ARM_EABI_VER2:
	      osabi = GDB_OSABI_ARM_EABI_V2;
	      break;

	    case EF_ARM_EABI_UNKNOWN:
	      /* Assume GNU tools.  */
	      osabi = GDB_OSABI_ARM_APCS;
	      break;

	    default:
	      internal_error (__FILE__, __LINE__,
			      _("\
arm_elf_osabi_sniffer: Unknown ARM EABI version 0x%x"),
			      eflags);
	    }
	}
      break;

    case ELFOSABI_ARM:
      /* GNU tools use this value.  Check note sections in this case,
	 as well.  */
      bfd_map_over_sections (abfd,
			     generic_elf_osabi_sniff_abi_tag_sections, 
			     &osabi);
      if (osabi == GDB_OSABI_UNKNOWN)
	{
	  /* Assume APCS ABI.  */
	  osabi = GDB_OSABI_ARM_APCS;
	}
      break;

    case ELFOSABI_FREEBSD:
      osabi = GDB_OSABI_FREEBSD_ELF;
      break;

    case ELFOSABI_NETBSD:
      osabi = GDB_OSABI_NETBSD_ELF;
      break;

    case ELFOSABI_LINUX:
      osabi = GDB_OSABI_LINUX;
      break;
    }
d2588 1
d2605 3
d2609 2
a2610 1
  /* Try to deterimine the ABI of the object we are loading.  */
d2612 1
a2612 1
  if (info.abfd != NULL && info.osabi == GDB_OSABI_UNKNOWN)
d2614 2
d2620 1
a2620 1
	  info.osabi = GDB_OSABI_ARM_APCS;
d2626 36
a2661 1
	  info.osabi = GDB_OSABI_ARM_APCS;
d2665 1
a2665 1
	  /* Leave it as "unknown".  */
d2670 24
d2695 16
a2710 3
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;
d2712 1
a2712 1
  tdep = xmalloc (sizeof (struct gdbarch_tdep));
d2715 4
a2718 4
  /* We used to default to FPA for generic ARM, but almost nobody uses that
     now, and we now provide a way for the user to force the model.  So 
     default to the most useful variant.  */
  tdep->fp_model = ARM_FLOAT_SOFT_FPA;
a2833 1
      
d2838 13
a2850 1
      arm_set_fp (gdbarch);
a2872 21
static void
arm_init_abi_eabi_v1 (struct gdbarch_info info,
		      struct gdbarch *gdbarch)
{
  /* Place-holder.  */
}

static void
arm_init_abi_eabi_v2 (struct gdbarch_info info,
		      struct gdbarch *gdbarch)
{
  /* Place-holder.  */
}

static void
arm_init_abi_apcs (struct gdbarch_info info,
		   struct gdbarch *gdbarch)
{
  /* Place-holder.  */
}

a2895 8
  /* Register some ABI variants for embedded systems.  */
  gdbarch_register_osabi (bfd_arch_arm, 0, GDB_OSABI_ARM_EABI_V1,
                          arm_init_abi_eabi_v1);
  gdbarch_register_osabi (bfd_arch_arm, 0, GDB_OSABI_ARM_EABI_V2,
                          arm_init_abi_eabi_v2);
  gdbarch_register_osabi (bfd_arch_arm, 0, GDB_OSABI_ARM_APCS,
                          arm_init_abi_apcs);

d2973 7
@


1.195
log
@	* arm-tdep.c (target_is_thumb, caller_is_thumb)
	(arm_pc_is_thumb_dummy): Remove.
	(arm_breakpoint_from_pc): Don't call arm_pc_is_thumb_dummy.
@
text
@d40 2
d2759 1
@


1.194
log
@	* arm-tdep.c (arm_make_stub_cache, arm_stub_this_id)
	(arm_stub_unwind, arm_stub_unwind_sniffer): New.
	(arm_gdbarch_init): Add arm_stub_unwind_sniffer.
@
text
@a184 14
/* Flag set by arm_fix_call_dummy that tells whether the target
   function is a Thumb function.  This flag is checked by
   arm_push_arguments.  FIXME: Change the PUSH_ARGUMENTS macro (and
   its use in valops.c) to pass the function address as an additional
   parameter.  */

static int target_is_thumb;

/* Flag set by arm_fix_call_dummy that tells whether the calling
   function is a Thumb function.  This flag is checked by
   arm_pc_is_thumb.  */

static int caller_is_thumb;

a208 21
/* Determine if the program counter specified in MEMADDR is in a call
   dummy being called from a Thumb function.  */

int
arm_pc_is_thumb_dummy (CORE_ADDR memaddr)
{
  CORE_ADDR sp = read_sp ();

  /* FIXME: Until we switch for the new call dummy macros, this heuristic
     is the best we can do.  We are trying to determine if the pc is on
     the stack, which (hopefully) will only happen in a call dummy.
     We hope the current stack pointer is not so far alway from the dummy
     frame location (true if we have not pushed large data structures or
     gone too many levels deep) and that our 1024 is not enough to consider
     code regions as part of the stack (true for most practical purposes).  */
  if (deprecated_pc_in_call_dummy (memaddr))
    return caller_is_thumb;
  else
    return 0;
}

d1982 1
a1982 1
  if (arm_pc_is_thumb (*pcptr) || arm_pc_is_thumb_dummy (*pcptr))
@


1.194.2.1
log
@	* gdb/Makefile.in (arm-tdep.o): Update dependencies.
	* gdb/arm-tdep.c: Include "objfiles.h" and "dwarf2-frame.h".
	(arm_gdbarch_init): Register dwarf2_frame_sniffer.
@
text
@a39 2
#include "objfiles.h"
#include "dwarf2-frame.h"
a2791 1
  frame_unwind_append_sniffer (gdbarch, dwarf2_frame_sniffer);
@


1.194.2.2
log
@	* gdb/arm-tdep.c (target_is_thumb, caller_is_thumb)
	(arm_pc_is_thumb_dummy): Remove.
	(arm_breakpoint_from_pc): Don't call arm_pc_is_thumb_dummy.
@
text
@d187 14
d225 21
d2019 1
a2019 1
  if (arm_pc_is_thumb (*pcptr))
@


1.194.2.3
log
@	* gdb/configure.tgt: Add default OSABI setting for
	arm*-*-linux-gnueabi.
	* gdb/arm-tdep.c (arm_type_align): New function.
	(arm_push_dummy_call): Use it.  Ensure proper argument alignment.
	Don't try to align the stack.
	(arm_frame_align): New function.
	(arm_extract_struct_value_address): Remove.
	(arm_use_struct_convention): Rename...
	(arm_return_in_memory): ... To this.  Return nonzero for all small
	aggregates under the EABI.
	(arm_return_value): New function.
	(arm_elf_osabi_sniffer): Add EF_ARM_EABI_VER4 case.  Handle
	GDB_OSABI_ARM_EABI_V4_LINUX.
	(arm_gdbarch_init): Set different FPU and ABI defaults for EABI
	objects.  Use set_gdbarch_return_value instead of obsolete functions.
	Call set_gdbarch_frame_align.
	(arm_init_abi_eabi_v4): New function.
	(_initialize_arm_tdep): Register GDB_OSABI_ARM_EABI_V4.
	* gdb/arm-linux-tdep.c (ARM_LINUX_EABI_JB_PC): Define.
	(arm_linux_eabi_init_abi): New function.
	(_initialize_arm_linux_tdep): Register GDB_OSABI_ARM_EABI_V4_LINUX.
	* gdb/arm-tdep.h (enum arm_abi_variant): New.
	(struct gdbarch_tdep): Add abi field.
	* gdb/defs.h (enum gdb_osabi): Add GDB_OSABI_ARM_EABI_V4 and
	GDB_OSABI_ARM_EABI_V4_LINUX.
	* gdb/osabi.c (gdb_osabi_name): Add "ARM EABI v4" and
	"ARM EABI v4 GNU/Linux".

	* gdb/testsuite/gdb.base/long_long.exp: Don't expect FPA format for
	ARM EABI targets.
@
text
@a1192 57

/* Return the alignment (in bytes) of the given type.  */

static int
arm_type_align (struct type *t)
{
  int n;
  int align;
  int falign;

  switch (TYPE_CODE (t))
    {
    case TYPE_CODE_UNDEF:
    case TYPE_CODE_FUNC:
    case TYPE_CODE_VOID:
    case TYPE_CODE_STRING:
    case TYPE_CODE_ERROR:
    case TYPE_CODE_MEMBER:
    case TYPE_CODE_METHOD:
    case TYPE_CODE_TEMPLATE:
    case TYPE_CODE_TEMPLATE_ARG:
    case TYPE_CODE_NAMESPACE:
    case TYPE_CODE_TYPEDEF:
    default:
      /* Should never happen, so make something up.  */
      return 4;

    case TYPE_CODE_PTR:
    case TYPE_CODE_ENUM:
    case TYPE_CODE_INT:
    case TYPE_CODE_FLT:
    case TYPE_CODE_SET:
    case TYPE_CODE_RANGE:
    case TYPE_CODE_BITSTRING:
    case TYPE_CODE_REF:
    case TYPE_CODE_CHAR:
    case TYPE_CODE_BOOL:
      return TYPE_LENGTH (t);

    case TYPE_CODE_ARRAY:
    case TYPE_CODE_COMPLEX:
      /* TODO: What about vector types?  */
      return arm_type_align (TYPE_TARGET_TYPE (t));

    case TYPE_CODE_STRUCT:
    case TYPE_CODE_UNION:
      align = 1;
      for (n = 0; n < TYPE_NFIELDS (t); n++)
	{
	  falign = arm_type_align (TYPE_FIELD_TYPE (t, n));
	  if (falign > align)
	    align = falign;
	}
      return align;
    }
}

d1221 5
a1243 1
      int align;
a1250 29
      if (gdbarch_tdep (gdbarch)->abi == ARM_ABI_APCS_GNU)
	{
	  /* The old APCS ABI does not require doubleword alignment.  */
	  align = INT_REGISTER_SIZE;
	}
      else
	{
	  align = arm_type_align (arg_type);

	  /* Round alignment up to one or two words.  */
	  align = (align + INT_REGISTER_SIZE - 1) & ~(INT_REGISTER_SIZE - 1);

	  gdb_assert (align == INT_REGISTER_SIZE
		      || align == INT_REGISTER_SIZE * 2);
	}

      /* Push stack padding for dowubleword alignment.  */
      if (nstack & (align - 1))
	{
	  si = push_stack_item (si, val, INT_REGISTER_SIZE);
	  nstack += INT_REGISTER_SIZE;
	}
      
      /* Doubleword aligned quantities must go in even register pairs.  */
      if (argreg <= ARM_LAST_ARG_REGNUM
	  && align > INT_REGISTER_SIZE
	  && argreg & 1)
	argreg++;

a1316 7
static CORE_ADDR
arm_frame_align (struct gdbarch *gdbarch, CORE_ADDR sp)
{
  /* Align the stack to eight bytes.  */
  return sp & ~ (CORE_ADDR) 7;
}

d2086 11
d2103 1
a2103 1
arm_return_in_memory (struct gdbarch *gdbarch, struct type *type)
a2133 5
  /* The new EABI says all aggregates not larger than a word are returned
     in a register.  */
  if (gdbarch_tdep (gdbarch)->abi != ARM_ABI_APCS_GNU)
    return 0;

a2282 27

/* Handle function return values.  */

static enum return_value_convention
arm_return_value (struct gdbarch *gdbarch, struct type *valtype,
		  struct regcache *regcache, void *readbuf,
		  const void *writebuf)
{
  /* TODO: Only call for aggreagates.  */
  if (TYPE_CODE (valtype) == TYPE_CODE_STRUCT
      || TYPE_CODE (valtype) == TYPE_CODE_UNION
      || TYPE_CODE (valtype) == TYPE_CODE_ARRAY)
    {
      if (arm_return_in_memory (gdbarch, valtype))
	return RETURN_VALUE_STRUCT_CONVENTION;
    }

  if (writebuf)
    arm_store_return_value (valtype, regcache, writebuf);

  if (readbuf)
    arm_extract_return_value (valtype, regcache, readbuf);

  return RETURN_VALUE_REGISTER_CONVENTION;
}


a2567 4
	    case EF_ARM_EABI_VER4:
	      osabi = GDB_OSABI_ARM_EABI_V4;
	      break;

a2579 6
      else if (osabi == GDB_OSABI_LINUX)
	{
	  eflags = EF_ARM_EABI_VERSION (elf_elfheader (abfd)->e_flags);
	  if (eflags == EF_ARM_EABI_VER4)
	    osabi = GDB_OSABI_ARM_EABI_V4_LINUX;
	}
d2656 4
a2659 14
  if (info.osabi == GDB_OSABI_ARM_EABI_V4 || info.osabi == GDB_OSABI_ARM_EABI_V4_LINUX)
    {
      /* Default EABI targets to soft-vfp.  */
      tdep->fp_model = ARM_FLOAT_SOFT_VFP;
      tdep->abi = ARM_ABI_AAPCS;
    }
  else
    {
      /* We used to default to FPA for generic ARM, but almost nobody uses
	 that now, and we now provide a way for the user to force the model.
	 So default to the most useful variant.  */
      tdep->fp_model = ARM_FLOAT_SOFT_FPA;
      tdep->abi = ARM_ABI_APCS_GNU;
    }
a2692 1
  set_gdbarch_frame_align (gdbarch, arm_frame_align);
d2736 4
a2739 1
  set_gdbarch_return_value (gdbarch, arm_return_value);
a2817 7
arm_init_abi_eabi_v4 (struct gdbarch_info info,
		      struct gdbarch *gdbarch)
{
  /* Place-holder.  */
}

static void
a2851 2
  gdbarch_register_osabi (bfd_arch_arm, 0, GDB_OSABI_ARM_EABI_V4,
                          arm_init_abi_eabi_v4);
@


1.194.2.4
log
@2005-03-28  Paul Brook  <paul@@codesourcery.com>
	Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdb/Makefile.in: arm-tdep.o depends on $(observer_h).
	* gdb/arm-linux-nat.c (fetch_fpregister, fetch_fpregs,
	store_fpregister, store_fpregs): Rename...
	(fetch_fpa_register, fetch_fpa_regs, store_fpa_register,
	store_fpa_regs): ... to this.
	* gdb/arm-linux-tdep.c (arm_linux_init_abi): Provide ABI specific
	overrides.
	* gdb/arm-tdep.c: Include opserver.h.
	(struct gdbarch_tdep_info): Add.
	(arm_push_dummy_call): Handle doubleword alignment.
	(arm_register_type): Handle iWMMXt and VFP regs.
	(arm_register_byte): Ditto.
	(arm_pseudo_register_read): New function.
	(arm_pseudo_register_write): New function.
	(arm_dwarf_reg_to_regnum): New function.
	(arm_register_sim_regno): Handle iWMMXT regs.
	(arm_register_remote_regno): New function.
	(arm_extract_return_value): Use new macro names.
	(arm_register_name): Handle iWMMXt and VFP registers.
	(arm_sim_available_registers): New function.
	(arm_update_architecture): New function.
	(arm_gdbarch_init): Handle optional register sets.  Register new
	hooks.  Fix misleading error message.
	(_initialize_arm_tdep): Call observer_attach_inferior_created.
	* gdb/arm-tdep.h (ARM_NUM_FP_ARG_REGS, ARM_LAST_FP_ARG_REGNUM,
	FP_REGISTER_SIZE, NUM_FREGS): Rename ...
	(ARM_NUM_FPA_ARG_REGS, ARM_LAST_FPA_ARG_REGNUM, FPA_REGISTER_SIZE,
	NUM_FPA_REGS): ... to this.
	(NUM_IWMMXT_COP0REGS, NUM_IWMMXT_COP1REGS, NUM_IWMMXT_REGS,
	IWMMXT_COP0_REGSIZE, IWMMXT_COP1_REGSIZE, NUM_VFP_XREGS,
	VFP_XREG_SIZE, NUM_VFP_SREGS, VFP_SREG_SIZE, NUM_VFP_PSEUDOS): Define.
	(struct gdbarch_tdep): Add target_has_iwmmxt_regs,
	target_has_vfp_regs, first_iwmmxt_regnum, target_iwmmxt_regnum,
	first_vfp_regnum, first_vfp_pseudo and target_vfp_regnum.
	* gdb/gdbarch.c (struct gdbarch): Add remote_num_g_packet_regs,
	sim_available_registers and register_remote_regno.
	(startup_gdbarch, verify_gdbarch): Ditto.
	(gdbarch_dump): Dump new fields.
	(gdbarch_remote_num_g_packet_regs_p, gdbarch_remote_num_g_packet_regs,
	set_gdbarch_remote_num_g_packet_regs,
	gdbarch_sim_available_registers_p, gdbarch_sim_available_registers,
	set_gdbarch_sim_available_registers, gdbarch_register_remote_regno_p,
	gdbarch_register_remote_regno, set_gdbarch_register_remote_regno):
	New functions.
	* gdb/gdbarch.h: Add prototypes.
	* gdb/gdbarch.sh: Add new fields.
	(deprecated_current_gdbarch_select_hack): Call flush_cached_frames.
	* gdb/remote-sim.h (gdbsim_create_inferior): Call
	observer_notify_inferior_created.
	(gdbsim_xfer_partial): New function.
	(init_gdbsim_ops): Use it.
	* gdb/remote.c (struct remote_state): Add num_g_regs.
	(init_remote_state): Only consider hard regs.  Allow target to provide
	register mapping.
	(packet_reg_from_regnum): Don't check pseudo regs.
	(packet_reg_from_pnum): Ditto.
	(remote_protocol_qPart_availableRegisters): Add.
	(set_remote_protocol_qPart_availableRegisters_packet_cmd,
	show_remote_protocol_qPart_availableRegisters_packet_cmd): New
	functions.
	(fetch_register_using_p, store_register_using_P): Handle arbitrary
	register mappings.
	(fetch_registers_using_g): New function.
	(remote_fetch_registers): Use it.
	(store_registers_using_G): New function.
	(remote_store_registers): Use it.
	(remote_xfer_partial): Handle TARGET_OBJECT_AVAILABLE_REGISTERS.
	(show_remote_cmd): Display availableRegisters.
	(_initialize_remote): Register qPart_availableRegisters.
	* gdb/target.h (enum target_object): Add
	TARGET_OBJECT_AVAILABLE_REGISTERS.
	* gdb/gdbserver/configure.srv (arm*-*-linux*): set
	srv_linux_regsets=yes.
	* gdb/gdbserver/linux-arm-low.c (PTRACE_GETWMMXREGS,
	PTRACE_SETWMMXREGS): Define.
	(arm_fill_gregset, arm_store_gregset, arm_fill_wmmxregset,
	arm_store_wmmxregset, arm_available_registers): New functions.
	(target_regsets): Add.
	(the_low_target): Use arm_available_registers.
	* gdb/gdbserver/linux-low.c (linux_available_registers): New function.
	(linux_target_op): Use it.
	* gdb/gdbserver/linux-low.h (gdbserver/linux-low.h): Add
	available_registers.
	(use_regsets_p): Declare.
	* gdb/gdbserver/regcache.c (g_register_bytes): Add.
	(regcache_invalidate, registers_to_string, registers_from_string):
	Use it.
	(set_register_cache): Set g_register_bytes.
	(supply_register_as_string): New function.
	* gdb/gdbserver/regcache.h (supply_register_as_string): Add prototype.
	* gdb/gdbserver/server.c (handle_query): Handle
	qPart:availableRegisters.
	(handle_p_packet, handle_P_packet): New functions.
	(main): Handle 'p' and 'P' packets.
	* gdb/gdbserver/target.h (struct target_ops): Add available_registers.
	* gdb/regformats/reg-arm.dat: Add last_g_reg and iWMMXT regs.
	* gdb/regformats/regdat.sh: Handle last_g_reg.
	* gdb/regformats/regdef.h (set_register_cache): Update prototype.
@
text
@a40 1
#include "observer.h"
a53 13
/* Extra information which ARM uses to select the appropriate GDB
   architecture.  */

struct gdbarch_tdep_info
{
  /* See the descriptions of these fields in struct gdbarch_tdep.  */

  int target_has_iwmmxt_regs;
  int target_iwmmxt_regnum;
  int target_has_vfp_regs;
  int target_vfp_regnum;
};

a1303 4
      align = arm_type_align (arg_type);
      /* Round alignment up to a whole number of words.  */
      align = (align + INT_REGISTER_SIZE - 1) & ~(INT_REGISTER_SIZE - 1);
      /* Different ABIs have different maximum alignments.  */
d1306 1
a1306 1
	  /* The APCS ABI only requires word alignment.  */
d1311 7
a1317 3
	  /* The AAPCS requires at most doubleword alignment.  */
	  if (align > INT_REGISTER_SIZE * 2)
	    align = INT_REGISTER_SIZE * 2;
d1320 1
a1320 1
      /* Push stack padding for doubleword alignment.  */
d1450 1
a1450 36
  int first;

  first = gdbarch_tdep (gdbarch)->first_iwmmxt_regnum;
  if (first != -1)
    {
      if (regnum >= first && regnum < first + NUM_IWMMXT_COP0REGS)
	return builtin_type_vec64i;

      first += NUM_IWMMXT_COP0REGS;

      if (regnum >= first && regnum < first + NUM_IWMMXT_COP1REGS)
	return builtin_type_int32;
    }

  first = gdbarch_tdep (gdbarch)->first_vfp_regnum;
  if (first != -1)
    {
      if (regnum >= first && regnum < first + NUM_VFP_XREGS)
	return builtin_type_int32;

      first += NUM_VFP_XREGS;

      if (regnum >= first && regnum < first + NUM_VFP_SREGS)
	return builtin_type_float;
    }

  first = gdbarch_tdep (gdbarch)->first_vfp_pseudo;
  if (first != -1)
    {
      first += gdbarch_num_regs (gdbarch);

      if (regnum >= first && regnum < first + NUM_VFP_PSEUDOS)
	return builtin_type_double;
    }

  if (regnum >= ARM_F0_REGNUM && regnum < ARM_F0_REGNUM + NUM_FPA_REGS)
a1466 5
  int offset;
  int first;

  offset = 0;
  first = 0;
d1469 7
a1475 149
  offset += NUM_GREGS * INT_REGISTER_SIZE;
  first += NUM_GREGS;

  if (regnum < first + NUM_FPA_REGS)
    return offset + (regnum - first) * FPA_REGISTER_SIZE;
  offset += NUM_FPA_REGS * FPA_REGISTER_SIZE;
  first += NUM_FPA_REGS;

  if (regnum < first + NUM_SREGS)
    return offset + (regnum - first) * STATUS_REGISTER_SIZE;
  offset += NUM_SREGS * STATUS_REGISTER_SIZE;
  
  first = gdbarch_tdep (current_gdbarch)->first_iwmmxt_regnum;
  if (first != -1)
    {
      if (regnum >= first && regnum < first + NUM_IWMMXT_COP0REGS)
	return offset + (regnum - first) * IWMMXT_COP0_REGSIZE;

      offset += NUM_IWMMXT_COP0REGS * IWMMXT_COP0_REGSIZE;
      first += NUM_IWMMXT_COP0REGS;

      if (regnum >= first && regnum < first + NUM_IWMMXT_COP1REGS)
	return offset + (regnum - first) * IWMMXT_COP1_REGSIZE;

      offset += NUM_IWMMXT_COP1REGS * IWMMXT_COP1_REGSIZE;
    }

  first = gdbarch_tdep (current_gdbarch)->first_vfp_regnum;
  if (first != -1)
    {
      if (regnum >= first && regnum < first + NUM_VFP_XREGS)
	return offset + (regnum - first) * VFP_XREG_SIZE;

      offset += NUM_VFP_XREGS * VFP_XREG_SIZE;
      first += NUM_VFP_XREGS;

      if (regnum >= first && regnum < first + NUM_VFP_SREGS)
	return offset + (regnum - first) * VFP_SREG_SIZE;
    }
  internal_error (__FILE__, __LINE__, _("Bad REGNUM %d"), regnum);
}

static void
arm_pseudo_register_read (struct gdbarch *gdbarch,
			  struct regcache *regcache,
			  int regnum, void *buf)
{
  int first;
  int low_regnum;
  int high_regnum;

  first = gdbarch_tdep (current_gdbarch)->first_vfp_pseudo;
  if (first != -1)
    {
      first += gdbarch_num_regs (gdbarch);

      if (regnum >= first && regnum < first + NUM_VFP_PSEUDOS)
	{
	  regnum = gdbarch_tdep (current_gdbarch)->first_vfp_regnum
	    + NUM_VFP_XREGS + 2 * (regnum - first);
	  if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_LITTLE)
	    {
	      low_regnum = regnum;
	      high_regnum = regnum + 1;
	    }
	  else
	    {
	      low_regnum = regnum + 1;
	      high_regnum = regnum;
	    }
	  regcache_raw_read (regcache, low_regnum, buf);
	  regcache_raw_read (regcache, high_regnum, ((char *)buf) + 4);
	  return;
	}
    }
  internal_error (__FILE__, __LINE__, _("Bad pseudo %d"), regnum);
}

static void
arm_pseudo_register_write (struct gdbarch *gdbarch,
			   struct regcache *regcache,
			   int regnum, const void *buf)
{
  int first;
  int low_regnum;
  int high_regnum;

  first = gdbarch_tdep (current_gdbarch)->first_vfp_pseudo;
  if (first != -1)
    {
      first += gdbarch_num_regs (gdbarch);

      if (regnum >= first && regnum < first + NUM_VFP_PSEUDOS)
	{
	  regnum = gdbarch_tdep (current_gdbarch)->first_vfp_regnum
	    + NUM_VFP_XREGS + 2 * (regnum - first);
	  if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_LITTLE)
	    {
	      low_regnum = regnum;
	      high_regnum = regnum + 1;
	    }
	  else
	    {
	      low_regnum = regnum + 1;
	      high_regnum = regnum;
	    }
	  regcache_raw_write (regcache, low_regnum, buf);
	  regcache_raw_write (regcache, high_regnum + 1, ((char *)buf) + 4);
	  return;
	}
    }
  internal_error (__FILE__, __LINE__, _("Bad pseudo %d"), regnum);
}

/* Map DWARF register numbers onto internal GDB register numbers.  */
static int
arm_dwarf_reg_to_regnum (int reg)
{
  int first;
 
  if (reg >= 0 && reg <= 16)
    return reg; /* Core integer regs.  */
  if (reg >= 16 && reg <= 23)
    return ARM_F0_REGNUM + reg - 16; /* Legacy FPA encoding.  */
  if (reg >= 96 && reg <= 103)
    return ARM_F0_REGNUM + reg - 96; /* FPA regs.  */

  /* VFP regs.  */
  first = gdbarch_tdep (current_gdbarch)->first_vfp_regnum;
  if (first != -1 && reg >= 64 && reg <= 95);
      return first + NUM_VFP_XREGS + reg - 64;;

  /* iWMMXt regs.  */
  first = gdbarch_tdep (current_gdbarch)->first_iwmmxt_regnum;
  if (first != -1)
    {
      if (reg >= 112 && reg <= 127) /* wr0-wr15 */
	return first + reg - 112;
      first += NUM_IWMMXT_COP0REGS;
      if (reg >= 192 && reg <= 199) /* wc0-wc7 */
	return first + reg - 104;
      first += 8;
      if (reg >= 104 && reg <= 111) /*wcgr0-wcgr7 */
	return first + reg - 104;
    }

  warning (_("Unmapped DWARF Register #%d encountered."), reg);

  return -1;
a1484 8
  if (gdbarch_tdep (current_gdbarch)->first_iwmmxt_regnum != -1)
    {
      int first = gdbarch_tdep (current_gdbarch)->first_iwmmxt_regnum;

      if (regnum >= first && regnum < first + NUM_IWMMXT_REGS)
	return SIM_ARM_IWMMXT_COP0R0_REGNUM + (regnum - first);
    }

d1489 1
a1489 1
  if (reg < NUM_FPA_REGS)
d1491 1
a1491 1
  reg -= NUM_FPA_REGS;
a1499 29
/* Map GDB internal REGNUM onto the current remote protocol
   register numbers.  */

static int
arm_register_remote_regno (int regnum)
{
  gdb_assert (regnum >= 0 && regnum < NUM_REGS);

  if (gdbarch_tdep (current_gdbarch)->first_iwmmxt_regnum != -1)
    {
      int first = gdbarch_tdep (current_gdbarch)->first_iwmmxt_regnum;

      if (regnum >= first && regnum < first + NUM_IWMMXT_REGS)
	return gdbarch_tdep (current_gdbarch)->target_iwmmxt_regnum
			     + (regnum - first);
    }

  if (gdbarch_tdep (current_gdbarch)->first_vfp_regnum != -1)
    {
      int first = gdbarch_tdep (current_gdbarch)->first_vfp_regnum;

      if (regnum >= first && regnum < first + NUM_VFP_XREGS + NUM_VFP_SREGS)
	return gdbarch_tdep (current_gdbarch)->target_vfp_regnum
			     + (regnum - first);
    }

  return regnum;
}

d2106 1
a2106 1
	    bfd_byte tmpbuf[FPA_REGISTER_SIZE];
d2553 1
a2553 1
arm_register_name (int regnum)
d2555 1
a2555 51
  int first;

  first = gdbarch_tdep (current_gdbarch)->first_iwmmxt_regnum;
  if (first != -1)
    {
      static const char *const iwmmxt_register_names[] = 
	{
	  "wr0", "wr1", "wr2", "wr3", "wr4", "wr5", "wr6", "wr7",
	  "wr8", "wr9", "wr10", "wr11", "wr12", "wr13", "wr14", "wr15",
	  "wcid", "wcon", "wcssf", "wcasf", "", "", "", "",
	  "wcgr0", "wcgr1", "wcgr2", "wcgr3", "", "", "", ""
	};

      if (regnum >= first && regnum < first + NUM_IWMMXT_REGS)
	return iwmmxt_register_names[regnum - first];
    }

  first = gdbarch_tdep (current_gdbarch)->first_vfp_regnum;
  if (first != -1)
    {
      static const char *const vfp_register_names[] = 
	{
	  "fpsid", "fpscr", "", "", "", "", "", "",
	  "fpexc", "", "", "", "", "", "", "",
	  "s0",  "s1",  "s2",  "s3",  "s4",  "s5",  "s6",  "s7",
	  "s8",  "s9",  "s10", "s11", "s12", "s13", "s14", "s15",
	  "s16", "s17", "s18", "s19", "s20", "s21", "s22", "s23",
	  "s24", "s25", "s26", "s27", "s28", "s29", "s30", "s31"
	};

      if (regnum >= first && regnum < first + NUM_VFP_XREGS + NUM_VFP_SREGS)
	return vfp_register_names[regnum - first];
    }

  first = gdbarch_tdep (current_gdbarch)->first_vfp_pseudo;
  if (first != -1)
    {
      static const char *const vfp_pseudo_names[] = 
	{
	  "d0", "d1", "d2",  "d3",  "d4",  "d5",  "d6",  "d7",
	  "d8", "d9", "d10", "d11", "d12", "d13", "d14", "d15",
	};

      first += gdbarch_num_regs (current_gdbarch);

      if (regnum >= first && regnum < first + NUM_VFP_PSEUDOS)
	return vfp_pseudo_names[regnum - first];
    }

  gdb_assert (regnum < NUM_GREGS + NUM_FPA_REGS + NUM_SREGS);
  return arm_register_names[regnum];
a2729 64

/* */

static char *
arm_sim_available_registers (struct gdbarch *gdbarch,
			     const struct target_ops *target)
{
  /* The built-in simulator supports iWMMXt.  */
  return xstrdup ("iwmmxt");
}

/* Update the current architecture based on architecture features.  */

static void
arm_update_architecture (struct target_ops *target, int from_tty)
{
  struct gdbarch_tdep_info tdep;
  struct gdbarch_info info;
  char buf[64];
  int bytes_read;

  memset (&tdep, 0, sizeof (tdep));

  /* FIXME: Define TARGET_READ_FULL which allocates the buffer large
     enough, modelled on auxv.c.  */
  bytes_read = target_read_partial (target, TARGET_OBJECT_AVAILABLE_REGISTERS,
				    "", buf, 0, 64);

  /* "Parse" the response.  */
  if (bytes_read == 6 && strncmp (buf, "iwmmxt", 6) == 0)
    {
      tdep.target_has_iwmmxt_regs = 1;
      tdep.target_iwmmxt_regnum = -1;
    }
  else if (bytes_read > 6 && strncmp (buf, "iwmmxt:", 7) == 0)
    {
      char *end;
      tdep.target_has_iwmmxt_regs = 1;
      tdep.target_iwmmxt_regnum = strtol (buf + 7, &end, 16);
    }
  else
    {
      tdep.target_has_iwmmxt_regs = 0;
      tdep.target_iwmmxt_regnum = -1;
    }

  if (bytes_read > 3 && strncmp (buf, "vfp:", 4) == 0)
    {
      char *end;
      tdep.target_has_vfp_regs = 1;
      tdep.target_vfp_regnum = strtol (buf + 4, &end, 16);
    }
  else
    {
      tdep.target_has_vfp_regs = 0;
      tdep.target_vfp_regnum = -1;
    }

  /* Update the architecture.  */
  gdbarch_info_init (&info);
  info.tdep_info = &tdep;
  if (!gdbarch_update_p (info))
    internal_error (__FILE__, __LINE__, "could not update architecture");
}
a2743 3
  struct gdbarch_list *best_arch;
  int nregs;
  int pseudos;
d2749 1
a2749 1
	switch (bfd_get_flavour (info.abfd))
a2767 3
  /* FIXME drow/2005-03-11: For consistency, if there is not a BFD,
     should we inherit info.osabi from the last ARM architecture?  */

d2769 3
a2771 29
  for (best_arch = gdbarch_list_lookup_by_info (arches, &info);
       best_arch != NULL;
       best_arch = gdbarch_list_lookup_by_info (best_arch->next, &info))
    {
      /* If we have target-specific bits in INFO, then make sure
	 they match.  */
      if (info.tdep_info)
	{
	  if (gdbarch_tdep (best_arch->gdbarch)->target_has_iwmmxt_regs
	      != info.tdep_info->target_has_iwmmxt_regs)
	    continue;
	  if (gdbarch_tdep (best_arch->gdbarch)->target_iwmmxt_regnum
	      != info.tdep_info->target_iwmmxt_regnum)
	    continue;

	  if (gdbarch_tdep (best_arch->gdbarch)->target_has_vfp_regs
	      != info.tdep_info->target_has_vfp_regs)
	    continue;
	  if (gdbarch_tdep (best_arch->gdbarch)->target_vfp_regnum
	      != info.tdep_info->target_vfp_regnum)
	    continue;
	}

      /* Found a match.  */
      break;
    }

  if (best_arch != NULL)
    return best_arch->gdbarch;
d2773 1
a2773 1
  tdep = xcalloc (1, sizeof (struct gdbarch_tdep));
d2776 1
a2776 2
  if (info.osabi == GDB_OSABI_ARM_EABI_V4
      || info.osabi == GDB_OSABI_ARM_EABI_V4_LINUX)
a2790 29
  if (info.tdep_info)
    {
      /* If specific target capabilities were requested, use them.  */
      tdep->target_has_iwmmxt_regs = info.tdep_info->target_has_iwmmxt_regs;
      tdep->target_iwmmxt_regnum = info.tdep_info->target_iwmmxt_regnum;
      tdep->target_has_vfp_regs = info.tdep_info->target_has_vfp_regs;
      tdep->target_vfp_regnum = info.tdep_info->target_vfp_regnum;
    }
  else if (arches)
    {
      /* Otherwise, inherit from the last ARM architecture, if any.  */
      tdep->target_has_iwmmxt_regs
	= gdbarch_tdep (arches->gdbarch)->target_has_iwmmxt_regs;
      tdep->target_iwmmxt_regnum
	= gdbarch_tdep (arches->gdbarch)->target_iwmmxt_regnum;
      tdep->target_has_vfp_regs
	= gdbarch_tdep (arches->gdbarch)->target_has_vfp_regs;
      tdep->target_vfp_regnum
	= gdbarch_tdep (arches->gdbarch)->target_vfp_regnum;
    }
  else
    {
      /* Set defaults.  */
      tdep->target_has_iwmmxt_regs = 0;
      tdep->target_iwmmxt_regnum = -1;
      tdep->target_has_vfp_regs = 0;
      tdep->target_vfp_regnum = -1;
    }

d2812 1
a2812 1
		      _("arm_gdbarch_init: bad byte order"));
d2856 1
a2858 33
  nregs = NUM_GREGS + NUM_FPA_REGS + NUM_SREGS;
  pseudos = 0;
  if (tdep->target_has_iwmmxt_regs)
    {
      tdep->first_iwmmxt_regnum = nregs;
      nregs += NUM_IWMMXT_REGS;
    }
  else
    tdep->first_iwmmxt_regnum = -1;

  if (tdep->target_has_vfp_regs)
    {
      tdep->first_vfp_regnum = nregs;
      nregs += NUM_VFP_XREGS + NUM_VFP_SREGS;
      tdep->first_vfp_pseudo = pseudos;
      pseudos += NUM_VFP_PSEUDOS;
    }
  else
    {
      tdep->first_vfp_regnum = -1;
      tdep->first_vfp_pseudo = -1;
    }

  set_gdbarch_num_regs (gdbarch, nregs);
  set_gdbarch_num_pseudo_regs (gdbarch, pseudos);
  set_gdbarch_pseudo_register_read (gdbarch, arm_pseudo_register_read);
  set_gdbarch_pseudo_register_write (gdbarch, arm_pseudo_register_write);

  /* The FPA registers are included in the remote 'g' packet for
     historic reasons.  */
  set_gdbarch_remote_num_g_packet_regs (gdbarch,
					NUM_GREGS + NUM_FPA_REGS + NUM_SREGS);

a2859 2
  set_gdbarch_dwarf_reg_to_regnum (gdbarch, arm_dwarf_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, arm_dwarf_reg_to_regnum);
a2861 3
  set_gdbarch_sim_available_registers (gdbarch, arm_sim_available_registers);
  set_gdbarch_register_remote_regno (gdbarch, arm_register_remote_regno);

a3076 2

  observer_attach_inferior_created (arm_update_architecture);
@


1.193
log
@2005-02-21  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_set_enum_cmd): Delete function.
	(deprecated_add_show_from_set): Delete function.
	* command.h (add_set_enum_cmd): Delete declaration.
	(deprecated_add_show_from_set): Delete declaration.
	* cli/cli-decode.h (add_set_enum_cmd): Delete declaration.
	(deprecated_add_show_from_set): Delete declaration.
	* arm-tdep.c (_initialize_arm_tdep): Update comment.
	* kod.c (kod_set_os): Simplify.
	* infrun.c (set_schedlock_func): Simplify.
	* cli/cli-dump.c (add_dump_command): Update comment.
@
text
@d1016 50
d2790 1
@


1.192
log
@2005-02-17  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Delete
	fprint_setshow parameter.
	* command.h (fprint_setshow_ftype): Delete.
	(add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Delete
	fprint_setshow parameter.
	* aix-thread.c, alpha-tdep.c, arm-tdep.c, breakpoint.c: Update.
	* complaints.c, cris-tdep.c, dwarf2read.c, frame.c: Update.
	* hppa-tdep.c, infcall.c, m32r-rom.c, maint.c: Update.
	* mips-tdep.c, nto-tdep.c, observer.c, remote-rdi.c: Update
	* remote.c, target.c, cli/cli-logging.c: Update.
@
text
@d2851 2
a2852 1
  /* Initialize the array that will be passed to add_set_enum_cmd().  */
@


1.191
log
@2005-02-16  Andrew Cagney  <cagney@@gnu.org>

	Merge setshow print and show parameters.
	* command.h (show_value_ftype): Define.
	(deprecated_show_value_hack): Declare.
	(add_setshow_enum_cmd, add_setshow_auto_boolean_cmd)
	(add_setshow_boolean_cmd, add_setshow_filename_cmd)
	(add_setshow_string_cmd, add_setshow_uinteger_cmd)
	(add_setshow_zinteger_cmd): Change type of show_func to
	show_value_ftype.
	* cli/cli-decode.h (struct cmd_list_element): Replace
	fprint_setshow with show_value_func.
	* cli/cli-decode.c (add_setshow_cmd_full): Update show_func
	parameter.  Set show_value_func.  Do not set cmd_sfunc.
	(add_setshow_enum_cmd, add_setshow_auto_boolean_cmd)
	(add_setshow_boolean_cmd, add_setshow_filename_cmd)
	(add_setshow_string_cmd, add_setshow_uinteger_cmd)
	(add_setshow_zinteger_cmd): Update.
	* complaints.c (complaints_show_value): Replace
	fprint_setshow_complaints.
	(_initialize_complaints): Update.
	* mips-tdep.c (show_mask_address): Update.
	* arm-tdep.c (show_fp_model): Update.
	* cli/cli-setshow.c (do_setshow_command): Call show_value_func
	instead of fprint_setshow.  Use deprecated_show_value_hack.
	(deprecated_show_value_hack): New function.
	* remote.c (add_packet_config_cmd, show_remote_cmd):
	(show_remote_protocol_P_packet_cmd)
	(show_remote_protocol_P_packet_cmd)
	(show_remote_protocol_Z_access_wp_packet_cmd)
	(show_remote_protocol_Z_hardware_bp_packet_cmd)
	(show_remote_protocol_Z_packet_cmd)
	(show_remote_protocol_Z_read_wp_packet_cmd)
	(show_remote_protocol_Z_software_bp_packet_cmd)
	(show_remote_protocol_Z_write_wp_packet_cmd)
	(show_remote_protocol_binary_download_cmd)
	(show_remote_protocol_p_packet_cmd)
	(show_remote_protocol_qPart_auxv_packet_cmd)
	(show_remote_protocol_qSymbol_packet_cmd)
	(show_remote_protocol_vcont_packet_cmd): Update.
@
text
@d2888 1
a2889 1
		       set_disassembly_style_sfunc, NULL,
d2896 1
a2897 1
			   NULL, NULL,
a2908 1
			NULL, /* FIXME: i18n: "The floating point type is \"%s\".  */
d2917 1
a2918 1
			   NULL, NULL,
@


1.190
log
@2005-02-14  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_setshow functions, replace "PRINT:" comment prefix
	with "FIXME: i18n:".
	* aix-thread.c, alpha-tdep.c, arm-tdep.c, breakpoint.c: Update.
	* cris-tdep.c, dwarf2read.c, frame.c, hppa-tdep.c: Update.
	* infcall.c, m32r-rom.c, maint.c, mips-tdep.c: Update.
	* nto-tdep.c, observer.c, remote-rdi.c, remote.c: Update.
	* target.c, cli/cli-logging.c: Update.
@
text
@d2399 2
a2400 2
show_fp_model (char *args, int from_tty,
	       struct cmd_list_element *c)
d2404 1
@


1.189
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_enum_cmd, add_setshow_cmd_full)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Replace
	print string parameter with fprint_setshow function.
	* command.h (fprint_setshow_ftype): Define.  Update declarations.
	* cli/cli-setshow.c (do_setshow_command): When fprint_setshow is
	available, use that.
	* cli/cli-decode.h (struct cmd_list_element): Add field
	fprint_setshow.
	* complaints.c (fprint_setshow_complaints): New function.
	(_initialize_complaints): Pass to add_setshow_zinteger_cmd.
	* hppa-tdep.c (_initialize_hppa_tdep): Replace "print" parameter
	with NULL.
	* mips-tdep.c (_initialize_mips_tdep): Ditto.
	* m32r-rom.c (_initialize_m32r_rom): Ditto.
	* cris-tdep.c (_initialize_cris_tdep): Ditto.
	* arm-tdep.c (_initialize_arm_tdep): Ditto.
	* remote-rdi.c (_initialize_remote_rdi): Ditto.
	* alpha-tdep.c (_initialize_alpha_tdep): Ditto.
	* dwarf2read.c (_initialize_dwarf2_read): Ditto.
	* frame.c (_initialize_frame): Ditto.
	* target.c (initialize_targets): Ditto.
	* maint.c (_initialize_maint_cmds): Ditto.
	* observer.c (_initialize_observer): Ditto.
	* infcall.c (_initialize_infcall): Ditto.
	* breakpoint.c (_initialize_breakpoint): Ditto.
	* cli/cli-logging.c (_initialize_cli_logging): Ditto.
	* remote.c (add_packet_config_cmd, _initialize_remote): Ditto.
@
text
@d2887 1
a2887 1
		       NULL, /* PRINT: The disassembly style is \"%s\".  */
d2895 1
a2895 1
			   NULL, /* PRINT: "Usage of ARM 32-bit mode is %s.  */
d2908 1
a2908 1
			NULL, /* PRINT: "The floating point type is \"%s\".  */
d2917 1
a2917 1
			   NULL, /* PRINT: "ARM debugging is %s.  */
@


1.188
log
@2005-02-09  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_enum_cmd): Drop set_result and
	show_result parameters.
	* mips-tdep.c (_initialize_mips_tdep): Update calls.
	* command.h: Update declaration.
	* arm-tdep.c (_initialize_arm_tdep, _initialize_arm_tdep): Update
	calls.
@
text
@d2887 1
a2887 1
		       _("The disassembly style is \"%s\"."),
d2895 1
a2895 1
			   _("Usage of ARM 32-bit mode is %s."),
d2908 1
a2908 1
			_("The floating point type is \"%s\"."),
d2917 1
a2917 1
			   _("ARM debugging is %s."),
@


1.187
log
@2005-02-09  Andrew Cagney  <cagney@@gnu.org>

	* NEWS: Mention removed commands.
	* m68hc11-tdep.c (show_regs): Delete, unused.
	(_initialize_m68hc11_tdep): Delete deprecated "regs" command.
	* gdb-events.sh: Delete deprecated "set eventdebug" and "show
	eventdebug" commands.
	* gdb-events.c: Regenerate.
	* gdbarch.sh: Delete deprecated "set archdebug" and "show
	archdebug" commands.
	* gdbarch.c: Regenerate.
	* cli/cli-cmds.c (init_cli_cmds): Delete deprecated "set
	remotedebug" and "show remotedebug".
	* arm-tdep.c (_initialize_arm_tdep): Delete deprecated "set arm
	disassembly-flavor", "show arm disassembly-flavor", and
	"othernames" commands.
	(arm_othernames): Delete unused function.
@
text
@d2889 1
a2889 1
		       &setarmcmdlist, &showarmcmdlist, NULL, NULL);
d2910 1
a2910 1
			&setarmcmdlist, &showarmcmdlist, NULL, NULL);
@


1.186
log
@2005-02-06  Andrew Cagney  <cagney@@gnu.org>

	* value.c (value_contents, value_contents_writeable): New
	functions.
	* value.h (VALUE_CONTENTS): Delete macro.
	(value_contents, value_contents_writeable): Declare.
	* xstormy16-tdep.c, value.c, valops.c, valarith.c: Update.
	* stack.c, sparc-tdep.c, sparc64-tdep.c, sh-tdep.c: Update.
	* sh64-tdep.c, scm-valprint.c, scm-exp.c, s390-tdep.c: Update.
	* rs6000-tdep.c, p-valprint.c, printcmd.c: Update.
	* ppc-sysv-tdep.c, mips-tdep.c, mi/mi-main.c: Update.
	* m88k-tdep.c, m68hc11-tdep.c, m32r-tdep.c: Update.
	* jv-valprint.c, ia64-tdep.c, hppa-tdep.c: Update.
	* hpacc-abi.c, f-valprint.c, frv-tdep.c, eval.c: Update.
	* c-valprint.c, cris-tdep.c, cp-valprint.c: Update.
	* cli/cli-dump.c, breakpoint.c, avr-tdep.c, arm-tdep.c: Update.
	* arm-linux-tdep.c, amd64-tdep.c, alpha-tdep.c: Update.
	* ada-valprint.c, ada-lang.c: Update.
@
text
@a2463 13
/* arm_othernames implements the "othernames" command.  This is deprecated
   by the "set arm disassembly" command.  */

static void
arm_othernames (char *names, int n)
{
  /* Circle through the various flavors.  */
  current_option = (current_option + 1) % num_disassembly_options;

  disassembly_style = valid_disassembly_styles[current_option];
  set_disassembly_style ();
}

a2881 14
  /* Add the deprecated disassembly-flavor command.  */
  add_setshow_enum_cmd("disassembly-flavor", no_class,
		       valid_disassembly_styles,
		       &disassembly_style,
		       _("Set the disassembly style."),
		       _("Show the disassembly style."),
		       helptext,
		       _("The disassembly style is \"%s\"."),
		       set_disassembly_style_sfunc, NULL,
		       &setlist, &showlist, &new_set, &new_show);
  deprecate_cmd (new_set, "set arm disassembly");
  deprecate_cmd (new_show, "show arm disassembly");

  /* And now add the new interface.  */
a2911 5
  /* Add the deprecated "othernames" command.  */
  deprecate_cmd (add_com ("othernames", class_obscure, arm_othernames,
			  _("Switch to the next set of register names.")),
		 "set arm disassembly");

@


1.185
log
@2005-01-05  Baurjan Ismagulov  <ibr@@ata.cs.hun.edu.tr>

	Committed by Andrew Cagney.
	* ada-valprint.c, aix-thread.c, alpha-nat.c: I18n markup.
	* alphabsd-nat.c, alphanbsd-tdep.c, amd64-linux-nat.c: I18n markup.
	* amd64-tdep.c,	amd64bsd-nat.c, amd64fbsd-nat.c: I18n markup.
	* arch-utils.c, arm-linux-nat.c, arm-tdep.c: I18n markup.
	* armnbsd-nat.c, armnbsd-tdep.c, auxv.c, avr-tdep.c: I18n markup.
	* aix-thread.c (_initialize_aix_thread): Get rid of the
	deprecated_add_show_from_set call.
	* alpha-tdep.c (_initialize_alpha_tdep): Ditto.
	* arm-tdep.c (_initialize_arm_tdep): Ditto.
	* command.h (add_setshow_enum_cmd): Add arguments for returning
	new list elements.
	* cli/cli-decode.c (add_setshow_enum_cmd): Ditto.
	* mips-tdep.c (_initialize_mips_tdep): Modify calls to
	add_setshow_enum_cmd.
@
text
@d2 3
a4 2
   Copyright 1988, 1989, 1991, 1992, 1993, 1995, 1996, 1998, 1999, 2000,
   2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d1226 1
a1226 1
      char *val;
d1232 1
a1232 1
      val = VALUE_CONTENTS (args[argnum]);
@


1.184
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	* value.h (VALUE_TYPE, VALUE_NEXT, VALUE_OFFSET, VALUE_BITSIZE)
	(VALUE_BITPOS): Delete.
	(value_type, value_offset, value_bitsize, value_bitpos): Declare.
	* value.c (value_type, value_offset, value_bitpos)
	(value_bitsize): New functions.  Update references.
	* arm-tdep.c, gnu-v3-abi.c, hpacc-abi.c, gnu-v2-abi.c: Update.
	* f-valprint.c, cp-valprint.c, c-valprint.c: Update.
	* ada-valprint.c, typeprint.c, scm-valprint.c, scm-exp.c: Update.
	* p-valprint.c, jv-valprint.c, jv-lang.c, varobj.c: Update.
	* objc-lang.c, ada-lang.c, std-regs.c, stack.c: Update.
	* infcall.c, linespec.c, printcmd.c, valarith.c: Update.
	* valops.c, eval.c, findvar.c, breakpoint.c: Update.
	* tracepoint.c, ax-gdb.c, mi/mi-main.c, cli/cli-dump.c:
	* rs6000-tdep.c, ppc-sysv-tdep.c: Update.
@
text
@d1325 6
a1330 4
  printf ("%s FPU type %d\n",
	  (status & (1 << 31)) ? "Hardware" : "Software",
	  type);
  fputs ("mask: ", stdout);
d1332 2
a1333 1
  fputs ("flags: ", stdout);
d1390 1
a1390 1
  internal_error (__FILE__, __LINE__, "Bad REGNUM %d", regnum);
d1555 1
a1555 1
	error ("Infinite loop detected");
d1586 1
a1586 1
	error ("Infinite loop detected");
d1626 1
a1626 1
	      error ("Illegal update to pc in instruction");
d1637 1
a1637 1
		  error ("Infinite loop detected");
d1718 1
a1718 1
	      error ("Infinite loop detected");
d1736 1
a1736 1
		    error ("Illegal update to pc in instruction");
d1761 1
a1761 1
		    error ("Infinite loop detected");
d1797 1
a1797 1
		    error ("Infinite loop detected");
d1813 1
a1813 1
	      error ("Infinite loop detected");
d1824 1
a1824 1
	  fprintf_filtered (gdb_stderr, "Bad bit-field extraction\n");
d2018 1
a2018 1
	     "arm_extract_return_value: Floating point model not supported");
d2208 1
a2208 1
	     "arm_store_return_value: Floating point model not supported");
d2335 2
a2336 1
  printf_unfiltered ("\"set arm\" must be followed by an apporpriate subcommand.\n");
d2390 1
a2390 1
    internal_error (__FILE__, __LINE__, "Invalid fp model accepted: %s.",
d2405 2
a2406 1
    printf_filtered ("  - the default for the current ABI is \"%s\".\n",
d2569 3
a2571 2
			      "arm_elf_osabi_sniffer: Unknown ARM EABI "
			      "version 0x%x", eflags);
d2676 1
a2676 1
		      "arm_gdbarch_init: bad byte order for float format");
d2777 1
a2777 1
		      "arm_gdbarch_init: bad byte order for float format");
d2791 1
a2791 1
  fprintf_unfiltered (file, "arm_dump_tdep: Lowest pc = 0x%lx",
d2829 2
d2852 1
a2852 1
		  "Various ARM-specific commands.",
d2856 1
a2856 1
		  "Various ARM-specific commands.",
a2861 5
  /* Begin creating the help text.  */
  stb = mem_fileopen ();
  fprintf_unfiltered (stb, "Set the disassembly style.\n"
		      "The valid values are:\n");

d2869 3
a2871 2
      fprintf_unfiltered (stb, "%s - %s\n", setname,
			  setdesc);
d2885 6
a2890 2
  /* Finish the creation of the help text.  */
  fprintf_unfiltered (stb, "The default is \"std\".");
d2895 9
a2903 6
  new_set = add_set_enum_cmd ("disassembly-flavor", no_class,
			      valid_disassembly_styles,
			      &disassembly_style,
			      helptext,
			      &setlist);
  set_cmd_sfunc (new_set, set_disassembly_style_sfunc);
d2905 1
a2905 2
  deprecate_cmd (deprecated_add_show_from_set (new_set, &showlist),
		 "show arm disassembly");
d2908 14
a2921 13
  new_set = add_set_enum_cmd ("disassembler", no_class,
			      valid_disassembly_styles, &disassembly_style,
			      helptext, &setarmcmdlist);

  set_cmd_sfunc (new_set, set_disassembly_style_sfunc);
  deprecated_add_show_from_set (new_set, &showarmcmdlist);

  add_setshow_boolean_cmd ("apcs32", no_class, &arm_apcs_32, "\
Set usage of ARM 32-bit mode.", "\
Show usage of ARM 32-bit mode.", "\
When off, a 26-bit PC will be used.\n\
When off, a 26-bit PC will be used.", "\
Usage of ARM 32-bit mode is %s.",
d2926 11
a2936 12
  new_set = add_set_enum_cmd
    ("fpu", no_class, fp_model_strings, &current_fp_model,
     "Set the floating point type.\n"
     "auto - Determine the FP typefrom the OS-ABI.\n"
     "softfpa - Software FP, mixed-endian doubles on little-endian ARMs.\n"
     "fpa - FPA co-processor (GCC compiled).\n"
     "softvfp - Software FP with pure-endian doubles.\n"
     "vfp - VFP co-processor.",
     &setarmcmdlist);
  set_cmd_sfunc (new_set, set_fp_model_sfunc);
  set_cmd_sfunc (deprecated_add_show_from_set (new_set, &showarmcmdlist),
		 show_fp_model);
d2940 1
a2940 1
			  "Switch to the next set of register names."),
d2944 5
a2948 5
  add_setshow_boolean_cmd ("arm", class_maintenance, &arm_debug, "\
Set ARM debugging.", "\
Show ARM debugging.", "\
When on, arm-specific debugging is enabled.", "\
ARM debugging is %s.",
@


1.183
log
@2004-08-02  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (deprecated_register_bytes): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* regcache.c (deprecated_register_bytes): New function.
	* regcache.h (deprecated_register_bytes): Declare.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init_32082): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* remote.c (init_remote_state): Update.
	* remote-vx.c (vx_prepare_to_store): Update.
	* remote-sds.c (sds_fetch_registers, sds_prepare_to_store): Update.
	* irix5-nat.c (fetch_core_registers): Update.
	* cris-tdep.c (cris_register_bytes_ok): Update.
	* config/nm-gnu.h (CHILD_PREPARE_TO_STORE): Update.
@
text
@d1227 1
a1227 1
      arg_type = check_typedef (VALUE_TYPE (args[argnum]));
@


1.182
log
@2004-08-02  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (deprecated_frameless_function_invocation): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arm-tdep.c 	(arm_frameless_function_invocation): Delete.
	(arm_gdbarch_init) Do not set frameless function invocation.
	* frame.h (legacy_frameless_look_for_prologue): Delete declaration.
	* blockframe.c (legacy_frameless_look_for_prologue): Delete function.
	* frv-tdep.c (frv_frameless_function_invocation): Delete.
	(frv_gdbarch_init): Do not set frameless function invocation.
	* sh64-tdep.c (sh64_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* m32r-tdep.c (m32r_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
@
text
@a2712 4
  set_gdbarch_deprecated_register_bytes (gdbarch,
					 (NUM_GREGS * INT_REGISTER_SIZE
					  + NUM_FREGS * FP_REGISTER_SIZE
					  + NUM_SREGS * STATUS_REGISTER_SIZE));
@


1.181
log
@2004-07-30  Ramana Radhakrishnan <ramana.radhakrishnan@@codito.com>

	Committed by Andrew Cagney.
	* arm-tdep.c: Remove references to add_setshow_cmd_full for apcs32 .
@
text
@a271 33
/* Determine whether the function invocation represented by FI has a
   frame on the stack associated with it.  If it does return zero,
   otherwise return 1.  */

static int
arm_frameless_function_invocation (struct frame_info *fi)
{
  CORE_ADDR func_start, after_prologue;
  int frameless;

  /* Sometimes we have functions that do a little setup (like saving the
     vN registers with the stmdb instruction, but DO NOT set up a frame.
     The symbol table will report this as a prologue.  However, it is
     important not to try to parse these partial frames as frames, or we
     will get really confused.

     So I will demand 3 instructions between the start & end of the
     prologue before I call it a real prologue, i.e. at least
	mov ip, sp,
	stmdb sp!, {}
	sub sp, ip, #4.  */

  func_start = (get_frame_func (fi) + DEPRECATED_FUNCTION_START_OFFSET);
  after_prologue = SKIP_PROLOGUE (func_start);

  /* There are some frameless functions whose first two instructions
     follow the standard APCS form, in which case after_prologue will
     be func_start + 8.  */

  frameless = (after_prologue < func_start + 12);
  return frameless;
}

a2688 2
  set_gdbarch_deprecated_frameless_function_invocation (gdbarch, arm_frameless_function_invocation);

@


1.180
log
@2004-07-31  Andrew Cagney  <cagney@@gnu.org>

	* trad-frame.c (trad_frame_get_prev_register): Rename
	trad_frame_get_prev_register.
	* vax-tdep.c (vax_frame_prev_register): Update.
	* trad-frame.h: Update.
	* trad-frame.c (trad_frame_get_register): Update.
	* sparcobsd-tdep.c (sparc32obsd_frame_prev_register): Update.
	* sparcnbsd-tdep.c (sparc32nbsd_sigcontext_frame_prev_register):
	Update.
	* sparc64obsd-tdep.c (sparc64obsd_frame_prev_register): Update.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_frame_prev_register):
	Update.
	* sparc64fbsd-tdep.c (sparc64fbsd_sigtramp_frame_prev_register):
	Update.
	* sparc64-sol2-tdep.c (sparc64_sol2_sigtramp_frame_prev_register):
	Update.
	* sparc-sol2-tdep.c (sparc32_sol2_sigtramp_frame_prev_register):
	Update.
	* sparc-linux-tdep.c (sparc32_linux_sigtramp_frame_prev_register):
	Update.
	* s390-tdep.c (s390_frame_prev_register)
	(s390_stub_frame_prev_register)
	(s390_sigtramp_frame_prev_register): Update.
	* rs6000-tdep.c (rs6000_frame_prev_register): Update.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_prev_register): Update.
	* mips-tdep.c (mips_mdebug_frame_prev_register): Update.
	* m88k-tdep.c (m88k_frame_prev_register)
	* m68hc11-tdep.c (m68hc11_frame_prev_register)
	* m32r-tdep.c (m32r_frame_prev_register): Update.
	* hppa-tdep.c (hppa_frame_prev_register_helper)
	* frv-tdep.c (frv_frame_prev_register): Update.
	* d10v-tdep.c (d10v_frame_prev_register): Update.
	* cris-tdep.c (cris_frame_prev_register): Update.
	* avr-tdep.c (avr_frame_prev_register): Update.
	* arm-tdep.c (arm_prologue_prev_register)
	(arm_sigtramp_prev_register): Update.
@
text
@a2943 11
  add_setshow_cmd_full ("apcs32", no_class,
			var_boolean, (char *) &arm_apcs_32, "\
Set usage of ARM 32-bit mode.", "\
Show usage of ARM 32-bit mode.", "\
Determine the usage of ARM 32-bit mode.", "\
Usage of ARM 32-bit mode is %s.",
			NULL, NULL,
			&setlist, &showlist, &new_set, &new_show);
  deprecate_cmd (new_set, "set arm apcs32");
  deprecate_cmd (new_show, "show arm apcs32");

@


1.179
log
@2004-07-28  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_zinteger_cmd)
	(add_setshow_cmd, add_setshow_auto_boolean_cmd)
	(add_setshow_boolean_cmd, add_setshow_cmd_full): Add help_doc and
	print parameters.  Make string parameters constant.
	* command.h: Update.  Update copyright.
	* remote.c (add_packet_config_cmd, _initialize_remote): Ditto.
	* observer.c (_initialize_observer): Ditto.
	* frame.c (_initialize_frame): Ditto.
	* complaints.c (_initialize_complaints): Ditto.
	* maint.c (_initialize_maint_cmds): Ditto.
	* target.c (initialize_targets): Ditto.
	* cli/cli-logging.c (_initialize_cli_logging): Ditto.
	* infcall.c (_initialize_infcall): Ditto.
	* arm-tdep.c (_initialize_arm_tdep): Ditto.
	* m32r-rom.c (_initialize_m32r_rom): Ditto.
	* remote-rdi.c (_initialize_remote_rdi): Ditto.
	* d10v-tdep.c (_initialize_d10v_tdep): Ditto.
	* mips-tdep.c (_initialize_mips_tdep): Ditto.
@
text
@d1032 2
a1033 2
  trad_frame_prev_register (next_frame, cache->saved_regs, prev_regnum,
			    optimized, lvalp, addrp, realnump, valuep);
d1125 2
a1126 2
  trad_frame_prev_register (next_frame, cache->saved_regs, prev_regnum,
			    optimized, lvalp, addrp, realnump, valuep);
@


1.178
log
@2004-07-26  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (deprecated_add_show_from_set): Deprecate.
	* xcoffsolib.c (_initialize_xcoffsolib): Update.
	* wince.c (_initialize_wince): Update.
	* win32-nat.c (_initialize_win32_nat): Update.
	* varobj.c (_initialize_varobj): Update.
	* valops.c (_initialize_valops): Update.
	* utils.c (initialize_utils, initialize_utils): Update.
	* tui/tui-win.c (_initialize_tui_win): Update.
	* top.c (init_main): Update.
	* symfile.c (_initialize_symfile): Update.
	* source.c (_initialize_source): Update.
	* somsolib.c (_initialize_som_solib): Update.
	* solib.c (_initialize_solib): Update.
	* solib-frv.c (_initialize_frv_solib): Update.
	* serial.c (_initialize_serial): Update.
	* ser-go32.c (_initialize_ser_dos, _initialize_ser_dos): Update.
	* remote.c (_initialize_remote, _initialize_remote): Update.
	* remote-vx.c (_initialize_vx): Update.
	* remote-utils.c (_initialize_sr_support): Update.
	* remote-sds.c (_initialize_remote_sds): Update.
	* remote-mips.c (_initialize_remote_mips): Update.
	* remote-e7000.c (_initialize_remote_e7000): Update.
	* proc-api.c (_initialize_proc_api): Update.
	* printcmd.c: Update.
	* parse.c (_initialize_parse): Update.
	* pa64solib.c (_initialize_pa64_solib): Update.
	* p-valprint.c (_initialize_pascal_valprint): Update.
	* monitor.c (_initialize_remote_monitors): Update.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* mcore-tdep.c (_initialize_mcore_tdep): Update.
	* maint.c (_initialize_maint_cmds): Update.
	* lin-lwp.c (_initialize_lin_lwp): Update.
	* language.c (_initialize_language): Update.
	* kod.c (_initialize_kod): Update.
	* infrun.c (set_schedlock_func, _initialize_infrun): Update.
	* i386-tdep.c (_initialize_i386_tdep): Update.
	* gdbtypes.c (build_gdbtypes, _initialize_gdbtypes): Update.
	* gdbarch.sh: Update.
	* gdbarch.c: Re-generate.
	* gdb-events.sh: Update.
	* gdb-events.c: Re-generate.
	* frame.c (_initialize_frame): Update.
	* exec.c: Update.
	* demangle.c (_initialize_demangler): Update.
	* dcache.c (_initialize_dcache): Update.
	* cris-tdep.c (_initialize_cris_tdep, cris_version_update): Update.
	* cp-valprint.c (_initialize_cp_valprint): Update.
	* corefile.c (_initialize_core): Update.
	* command.h: Update.
	* cli/cli-decode.h: Update.
	* cli/cli-cmds.c (init_cli_cmds): Update.
	* charset.c (_initialize_charset): Update.
	* breakpoint.c (_initialize_breakpoint): Update.
	* arm-tdep.c (_initialize_arm_tdep_initialize_arm_tdep): Update.
	* alpha-tdep.c (_initialize_alpha_tdep): Update.
	* aix-thread.c (_initialize_aix_thread): Update.
@
text
@d2945 5
a2949 3
			var_boolean, (char *) &arm_apcs_32,
			"Set usage of ARM 32-bit mode.",
			"Show usage of ARM 32-bit mode.",
d2955 6
a2960 5
  add_setshow_boolean_cmd ("apcs32", no_class, &arm_apcs_32,
			   "Set usage of ARM 32-bit mode.  "
			   "When off, a 26-bit PC will be used.",
			   "Show usage of ARM 32-bit mode.  "
			   "When off, a 26-bit PC will be used.",
d2984 5
a2988 5
  add_setshow_boolean_cmd ("arm", class_maintenance, &arm_debug,
			   "Set ARM debugging.  "
			   "When on, arm-specific debugging is enabled.",
			   "Show ARM debugging.  "
			   "When on, arm-specific debugging is enabled.",
@


1.177
log
@2004-06-20  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (DEPRECATED_USE_STRUCT_CONVENTION): Deprecated.
	* gdbarch.h, gdbarch.c: Re-generate.
	* values.c (using_struct_return): Update call.
	* mcore-tdep.c: Update comment.
	* infcall.c (call_function_by_hand): Update comment.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* arch-utils.h (always_use_struct_convention): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

Index: doc/ChangeLog
2004-06-20  Andrew Cagney  <cagney@@gnu.org>

	* gdbint.texinfo (Target Architecture Definition): Deprecate
	USE_STRUCT_CONVENTION.
@
text
@d2933 1
a2933 1
  deprecate_cmd (add_show_from_set (new_set, &showlist),
d2942 1
a2942 1
  add_show_from_set (new_set, &showarmcmdlist);
d2972 2
a2973 1
  set_cmd_sfunc (add_show_from_set (new_set, &showarmcmdlist), show_fp_model);
@


1.176
log
@2004-06-18  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (DEPRECATED_FUNCTION_START_OFFSET): Deprecated.
	* gdbarch.h, gdbarch.c: Re-generate.
	* ada-lang.c (ada_finish_decode_line_1): Update.
	* infrun.c (handle_inferior_event): Update.
	* infcall.c (find_function_addr): Update.
	* linespec.c (minsym_found): Update.
	* symtab.c (find_function_start_sal, skip_prologue_using_sal):
	Update.
	* blockframe.c (legacy_frameless_look_for_prologue): Update.
	* cli/cli-cmds.c (disassemble_command): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.

Index: doc/ChangeLog
2004-06-18  Andrew Cagney  <cagney@@gnu.org>

	* gdbint.texinfo (Target Architecture Definition): Deprecate
	FUNCTION_START_OFFSET.
@
text
@d2765 1
a2765 1
  set_gdbarch_use_struct_convention (gdbarch, arm_use_struct_convention);
@


1.175
log
@2004-06-10  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (DEPRECATED_PC_IN_CALL_DUMMY): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.h (deprecated_pc_in_call_dummy): Delete "sp" and "fp"
	parameters.
	* dummy-frame.c (deprecated_pc_in_call_dummy): Update.
	* arm-tdep.c (arm_pc_is_thumb_dummy): Call
	deprecated_pc_in_call_dummy instead of
	DEPRECATED_PC_IN_CALL_DUMMY.
	(arm_skip_prologue): Ditto.
	* xstormy16-tdep.c (xstormy16_pop_frame, xstormy16_scan_prologue)
	(xstormy16_frame_saved_pc, xstormy16_frame_chain): Ditto.
	* v850-tdep.c (v850_find_callers_reg, v850_frame_chain)
	(v850_pop_frame, v850_frame_saved_pc, v850_frame_init_saved_regs):
	Ditto.
	* sh64-tdep.c (sh64_frame_chain, sh64_get_saved_pr)
	(sh64_init_extra_frame_info, sh64_get_saved_register)
	(sh64_pop_frame): Ditto.
	* mips-tdep.c (non_heuristic_proc_desc): Ditto.
	* mcore-tdep.c (mcore_find_callers_reg, mcore_frame_saved_pc)
	(mcore_pop_frame, mcore_init_extra_frame_info): Ditto.
	* h8300-tdep.c (h8300_frame_chain, h8300_frame_saved_pc)
	(h8300_pop_frame): Ditto.
	* blockframe.c (legacy_inside_entry_func)
	(legacy_frame_chain_valid): Ditto.
	* frame.c (frame_type_from_pc, legacy_get_prev_frame): Update call
	to deprecated_pc_in_call_dummy.
@
text
@d294 1
a294 1
  func_start = (get_frame_func (fi) + FUNCTION_START_OFFSET);
@


1.174
log
@2004-06-06  Randolph Chung  <tausq@@debian.org>

	* gdbarch.sh (PUSH_DUMMY_CALL): Change CORE_ADDR func_addr argument
	to struct value *function.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Likewise.
	* infcall.c (call_function_by_hand): Pass entire function value
	to push_dummy_call.

	* Makefile.in (alpha-tdep.o, frv-tdep.o, ia64-tdep.o, mips-tdep.o)
	(ppc-sysv-tdep.o, rs6000-tdep.o): Update dependencies.
	* alpha-tdep.c (alpha_push_dummy_call): Update call signature.
	* amd64-tdep.c (amd64_push_dummy_call): Likewise.
	* arm-tdep.c (arm_push_dummy_call): Likewise.
	* avr-tdep.c (avr_push_dummy_call): Likewise.
	* cris-tdep.c (cris_push_dummy_call): Likewise.
	* d10v-tdep.c (d10v_push_dummy_call): Likewise.
	* frv-tdep.c (frv_push_dummy_call): Likewise.
	* h8300-tdep.c (h8300_push_dummy_call): Likewise.
	* hppa-tdep.c (hppa32_push_dummy_call)
	(hppa64_push_dummy_call): Likewise.
	* i386-tdep.c (i386_push_dummy_call): Likewise.
	* ia64-tdep.c (ia64_push_dummy_call): Likewise.
	* m32r-tdep.c (m32r_push_dummy_call): Likewise.
	* m68hc11-tdep.c (m68hc11_push_dummy_call): Likewise.
	* m68k-tdep.c (m68k_push_dummy_call): Likewise.
	* m88k-tdep.c (m88k_push_dummy_call): Likewise.
	* mips-tdep.c (mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call)
	(mips_o32_push_dummy_call, mips_o64_push_dummy_call): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppc-tdep.h (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.
	* s390-tdep.c (s390_push_dummy_call): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu)
	(sh_push_dummy_call_nofpu): Likewise.
	* sparc-tdep.c (sparc32_push_dummy_call): Likewise.
	* sparc64-tdep.c (sparc64_push_dummy_call): Likewise.
	* vax-tdep.c (vax_push_dummy_call): Likewise.
@
text
@d237 1
a237 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (memaddr, sp, sp + 1024))
d410 1
a410 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (pc, 0, 0))
@


1.173
log
@2004-05-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_CALL_DUMMY_WORDS)
	(DEPRECATED_SIZEOF_CALL_DUMMY_WORDS): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arm-linux-tdep.c (arm_linux_call_dummy_words)
	(arm_linux_init_abi): Do not set deprecated_call_dummy_words or
	deprecated_sizeof_call_dummy_words.
	* arm-tdep.c (arm_call_dummy_words, arm_gdbarch_init): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh64-tdep.c (sh64_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_call_dummy_words, ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* arch-utils.h (legacy_call_dummy_words)
	(legacy_sizeof_call_dummy_words): Delete declarations.
	* arch-utils.c (legacy_call_dummy_words)
	(legacy_sizeof_call_dummy_words): Delete variables.

Index: doc/ChangeLog
2004-05-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	description of DEPRECATED_CALL_DUMMY_WORDS,
	DEPRECATED_SIZEOF_CALL_DUMMY_WORDS, and CALL_DUMMY.
@
text
@d1213 1
a1213 1
arm_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
@


1.172
log
@2004-05-08  Andrew Cagney  <cagney@@redhat.com>

	* ns32k-tdep.c (ns32k_gdbarch_init): Do not set
	deprecated_call_dummy_breakpoint_offset or
	deprecated_call_dummy_start_offset.
	* dummy-frame.c, arm-tdep.c: Update comments.
	* gdbarch.sh (DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET)
	(DEPRECATED_CALL_DUMMY_START_OFFSET): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.

Index: doc/ChangeLog
2004-05-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	reference to DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET.
@
text
@a1175 14
/* DEPRECATED_CALL_DUMMY_WORDS:
   This sequence of words is the instructions

   mov  lr,pc
   mov  pc,r4
   illegal

   Note this is 12 bytes.  */

static LONGEST arm_call_dummy_words[] =
{
  0xe1a0e00f, 0xe1a0f004, 0xe7ffdefe
};

a2711 3

  set_gdbarch_deprecated_call_dummy_words (gdbarch, arm_call_dummy_words);
  set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, 0);
@


1.171
log
@2004-04-30  Andrew Cagney  <cagney@@redhat.com>

	* arm-tdep.c (arm_sigtramp_unwind_sniffer): Call legacy_pc_in_sigtramp.
	* ia64-tdep.c (ia64_sigtramp_frame_sniffer): Ditto.
@
text
@d194 1
a194 1
   arm_pc_is_thumb and arm_call_dummy_breakpoint_offset.  */
@


1.170
log
@2004-04-22  Andrew Cagney  <cagney@@redhat.com>

	* arm-tdep.c (arm_prologue_this_id): Delete redundant cycle test.
	* m68hc11-tdep.c (m68hc11_frame_this_id): Ditto.
	* m32r-tdep.c (m32r_frame_this_id): Ditto.
	* frv-tdep.c (frv_frame_this_id): Ditto.
	* avr-tdep.c (avr_frame_this_id): Ditto.
@
text
@a1137 5
  /* Note: If an ARM DEPRECATED_PC_IN_SIGTRAMP method ever needs to
     compare against the name of the function, the code below will
     have to be changed to first fetch the name of the function and
     then pass this name to DEPRECATED_PC_IN_SIGTRAMP.  */

d1139 1
a1139 1
      && DEPRECATED_PC_IN_SIGTRAMP (frame_pc_unwind (next_frame), (char *) 0))
@


1.169
log
@	* arm-linux-tdep.c (ARM_LINUX_JB_ELEMENT_SIZE): Define to
	INT_REGISTER_SIZE.
	(arm_linux_push_arguments): Use TARGET_DOUBLE_BIT instead of
	FP_REGISTER_VIRTUAL_SIZE.
	* arm-tdep.c (arm_make_sigtramp_cache): Use register_size instead
	of DEPRECATED_REGISTER_RAW_SIZE.
	(arm_register_type): Add gdbarch argument.
	(arm_register_raw_size, arm_register_virtual_size): Delete.
	(arm_register_byte, arm_extract_return_value)
	(arm_store_return_value, arm_get_longjmp_target): Update references
	to INT_REGISTER_RAW_SIZE and FP_REGISTER_RAW_SIZE.
	(arm_gdbarch_init): Likewise.  Don't set
	deprecated_register_raw_size, deprecated_register_virtual_size,
	deprecated_max_register_raw_size,
	deprecated_max_register_virtual_size, or
	deprecated_max_register_virtual_type.  Do set register_type.
	* arm-tdep.h (ARM_MAX_REGISTER_RAW_SIZE)
	(ARM_MAX_REGISTER_VIRTUAL_SIZE, INT_REGISTER_VIRTUAL_SIZE)
	(FP_REGISTER_VIRTUAL_SIZE): Delete.
	(INT_REGISTER_RAW_SIZE): Rename to INT_REGISTER_SIZE.
	(FP_REGISTER_RAW_SIZE): Rename to FP_REGISTER_SIZE.
	* arm-linux-tdep.c (ARM_NBSD_JB_ELEMENT_SIZE): Define to
	INT_REGISTER_SIZE.
	* remote-rdp.c (remote_rdp_fetch_register): Use MAX_REGISTER_SIZE.
	(remote_rdp_store_register): Likewise.
@
text
@a995 9

  /* Check that we're not going round in circles with the same frame
     ID (but avoid applying the test to sentinel frames which do go
     round in circles).  */
  if (frame_relative_level (next_frame) >= 0
      && get_frame_type (next_frame) == NORMAL_FRAME
      && frame_id_eq (get_frame_id (next_frame), id))
    return;

@


1.168
log
@2004-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (PC_IN_SIGTRAMP): Change to a function with
	predicate, deprecate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* alpha-linux-tdep.c (alpha_linux_init_abi): Update.
	* alpha-osf1-tdep.c (alpha_osf1_init_abi): Update.
	* alpha-tdep.c (alpha_sigtramp_frame_sniffer): Update.
	* alphafbsd-tdep.c (alphafbsd_init_abi): Update.
	* alphanbsd-tdep.c (alphanbsd_init_abi): Update.
	* amd64-linux-tdep.c (amd64_linux_init_abi): Update.
	* amd64-tdep.c (amd64_sigtramp_frame_sniffer): Update.
	* amd64nbsd-tdep.c (amd64nbsd_init_abi): Update.
	* amd64obsd-tdep.c (amd64obsd_init_abi): Update.
	* arm-tdep.c (arm_sigtramp_unwind_sniffer): Update.
	* blockframe.c (find_pc_partial_function): Update.
	* breakpoint.c (bpstat_what): Update.
	* frame.c (frame_type_from_pc, legacy_get_prev_frame): Update.
	* frv-linux-tdep.c (frv_linux_init_abi): Update.
	* frv-tdep.c (frv_sigtramp_frame_sniffer): Update.
	* hppa-hpux-tdep.c (hppa_hpux_init_abi): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	* i386-linux-tdep.c (i386_linux_init_abi): Update.
	* i386-nto-tdep.c (i386nto_init_abi): Update.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Update.
	* i386-tdep.c (i386_sigtramp_frame_sniffer)
	(i386_svr4_init_abi, i386_go32_init_abi, i386_gdbarch_init): Update.
	* i386bsd-tdep.c (i386bsd_init_abi): Update.
	* i386nbsd-tdep.c (i386nbsd_init_abi): Update.
	* i386obsd-tdep.c (i386obsd_init_abi): Update.
	* ia64-tdep.c (ia64_sigtramp_frame_sniffer): Update.
	* infrun.c (pc_in_sigtramp): Update.
	* m68k-tdep.c (m68k_sigtramp_frame_sniffer): Update.
	* m68klinux-tdep.c (m68k_linux_init_abi): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mipsnbsd-tdep.c (mipsnbsd_init_abi): Update.
	* ppc-linux-tdep.c: Update comment.
	* ppcnbsd-tdep.c (ppcnbsd_init_abi): Update.
	* shnbsd-tdep.c (shnbsd_init_abi): Update.
	* sparc-linux-tdep.c (sparc32_linux_init_abi): Update.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Update.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Update.
	* sparc64fbsd-tdep.c (sparc64fbsd_init_abi): Update.
	* sparc64nbsd-tdep.c (sparc64nbsd_init_abi): Update.
	* sparc64obsd-tdep.c (sparc64obsd_init_abi): Update.
	* sparcnbsd-tdep.c (sparc32nbsd_init_abi): Update.
	* sparcobsd-tdep.c (sparc32obsd_init_abi): Update.

Index: doc/ChangeLog
2004-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Deprecate
	references to PC_IN_SIGTRAMP.
@
text
@d1097 1
a1097 1
			   DEPRECATED_REGISTER_RAW_SIZE (cache->framereg));
d1399 1
a1399 1
arm_register_type (int regnum)
d1419 1
a1419 1
    return regnum * INT_REGISTER_RAW_SIZE;
d1421 2
a1422 2
    return (NUM_GREGS * INT_REGISTER_RAW_SIZE
	    + (regnum - ARM_F0_REGNUM) * FP_REGISTER_RAW_SIZE);
d1424 2
a1425 2
    return (NUM_GREGS * INT_REGISTER_RAW_SIZE
	    + NUM_FREGS * FP_REGISTER_RAW_SIZE
a1428 28
/* Number of bytes of storage in the actual machine representation for
   register N.  All registers are 4 bytes, except fp0 - fp7, which are
   12 bytes in length.  */

static int
arm_register_raw_size (int regnum)
{
  if (regnum < ARM_F0_REGNUM)
    return INT_REGISTER_RAW_SIZE;
  else if (regnum < ARM_FPS_REGNUM)
    return FP_REGISTER_RAW_SIZE;
  else
    return STATUS_REGISTER_SIZE;
}

/* Number of bytes of storage in a program's representation
   for register N.  */
static int
arm_register_virtual_size (int regnum)
{
  if (regnum < ARM_F0_REGNUM)
    return INT_REGISTER_VIRTUAL_SIZE;
  else if (regnum < ARM_FPS_REGNUM)
    return FP_REGISTER_VIRTUAL_SIZE;
  else
    return STATUS_REGISTER_SIZE;
}

d2057 1
a2057 1
	    bfd_byte tmpbuf[FP_REGISTER_RAW_SIZE];
d2070 1
a2070 1
				  valbuf + INT_REGISTER_RAW_SIZE);
d2099 2
a2100 2
				  (len > INT_REGISTER_RAW_SIZE
				   ? INT_REGISTER_RAW_SIZE : len),
d2102 2
a2103 2
	  len -= INT_REGISTER_RAW_SIZE;
	  valbuf += INT_REGISTER_RAW_SIZE;
d2113 1
a2113 1
      bfd_byte tmpbuf[INT_REGISTER_RAW_SIZE];
d2119 3
a2121 3
		  len > INT_REGISTER_RAW_SIZE ? INT_REGISTER_RAW_SIZE : len);
	  len -= INT_REGISTER_RAW_SIZE;
	  valbuf += INT_REGISTER_RAW_SIZE;
d2245 1
a2245 1
      char buf[ARM_MAX_REGISTER_RAW_SIZE];
d2260 1
a2260 1
				   valbuf + INT_REGISTER_RAW_SIZE);
d2281 1
a2281 1
	  bfd_byte tmpbuf[INT_REGISTER_RAW_SIZE];
d2284 1
a2284 1
	  store_signed_integer (tmpbuf, INT_REGISTER_RAW_SIZE, val);
d2298 2
a2299 2
	      len -= INT_REGISTER_RAW_SIZE;
	      valbuf += INT_REGISTER_RAW_SIZE;
d2310 1
a2310 1
      bfd_byte tmpbuf[INT_REGISTER_RAW_SIZE];
d2315 1
a2315 1
		  len > INT_REGISTER_RAW_SIZE ? INT_REGISTER_RAW_SIZE : len);
d2317 2
a2318 2
	  len -= INT_REGISTER_RAW_SIZE;
	  valbuf += INT_REGISTER_RAW_SIZE;
d2327 1
a2327 1
  char buf[INT_REGISTER_RAW_SIZE];
d2333 1
a2333 1
			  INT_REGISTER_RAW_SIZE))
d2336 1
a2336 1
  *pc = extract_unsigned_integer (buf, INT_REGISTER_RAW_SIZE);
d2780 2
a2781 2
					 (NUM_GREGS * INT_REGISTER_RAW_SIZE
					  + NUM_FREGS * FP_REGISTER_RAW_SIZE
d2784 1
a2784 5
  set_gdbarch_deprecated_register_raw_size (gdbarch, arm_register_raw_size);
  set_gdbarch_deprecated_register_virtual_size (gdbarch, arm_register_virtual_size);
  set_gdbarch_deprecated_max_register_raw_size (gdbarch, FP_REGISTER_RAW_SIZE);
  set_gdbarch_deprecated_max_register_virtual_size (gdbarch, FP_REGISTER_VIRTUAL_SIZE);
  set_gdbarch_deprecated_register_virtual_type (gdbarch, arm_register_type);
@


1.167
log
@	* arm-tdep.c (arm_use_struct_convention): Look through typedefs.
	* gdbtypes.c (check_typedef): Update comments.
@
text
@d1147 4
a1150 4
  /* Note: If an ARM PC_IN_SIGTRAMP method ever needs to compare
     against the name of the function, the code below will have to be
     changed to first fetch the name of the function and then pass
     this name to PC_IN_SIGTRAMP.  */
d1153 1
a1153 1
      && PC_IN_SIGTRAMP (frame_pc_unwind (next_frame), (char *) 0))
@


1.166
log
@	* arm-tdep.c (thumb_get_next_pc): Handle Thumb BLX.
@
text
@d2176 2
d2235 1
a2235 1
	  field_type_code = TYPE_CODE (TYPE_FIELD_TYPE (type, i));
@


1.165
log
@	* arm-tdep.c (thumb_get_next_pc): Handle BX.
	(arm_get_next_pc): Handle BX and BLX.
@
text
@d1654 1
a1654 1
  else if ((inst1 & 0xf800) == 0xf000)	/* long branch with link */
d1659 3
d1663 1
a1663 1
  else if ((inst1 & 0xff80) == 0x4700)	/* branch and exchange (bx) */
@


1.164
log
@2004-02-09  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAMELESS_FUNCTION_INVOCATION): Predicate
	and function replacing FRAMELESS_FUNCTION_INVOCATION.
	* blockframe.c (legacy_frameless_look_for_prologue): Rename
	frameless_look_for_prologue.
	* frame.h (legacy_frameless_look_for_prologue): Rename
	frameless_look_for_prologue.
	* gdbarch.h, gdbarch.c: Re-generate.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	(delta68_frame_args_address): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	(frv_frameless_function_invocation): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	(cris_frameless_function_invocation): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* stack.c (frame_info): Update, call predicate.
	* rs6000-tdep.c (rs6000_frame_chain): Update, call predicate..
	* frame.c (legacy_get_prev_frame): Update, call predicate..
	* arch-utils.c (generic_frameless_function_invocation_not): Delete.
	* arch-utils.h (generic_frameless_function_invocation_not): Delete.
	* alpha-tdep.c (alpha_gdbarch_init): Do not set frameless function
	invocation.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
@
text
@d1660 11
d1711 14
d1889 4
@


1.164.2.1
log
@Merge mainline to intercu branch.
@
text
@d1097 1
a1097 1
			   register_size (current_gdbarch, cache->framereg));
d1147 4
a1150 4
  /* Note: If an ARM DEPRECATED_PC_IN_SIGTRAMP method ever needs to
     compare against the name of the function, the code below will
     have to be changed to first fetch the name of the function and
     then pass this name to DEPRECATED_PC_IN_SIGTRAMP.  */
d1153 1
a1153 1
      && DEPRECATED_PC_IN_SIGTRAMP (frame_pc_unwind (next_frame), (char *) 0))
d1399 1
a1399 1
arm_register_type (struct gdbarch *gdbarch, int regnum)
d1419 1
a1419 1
    return regnum * INT_REGISTER_SIZE;
d1421 2
a1422 2
    return (NUM_GREGS * INT_REGISTER_SIZE
	    + (regnum - ARM_F0_REGNUM) * FP_REGISTER_SIZE);
d1424 2
a1425 2
    return (NUM_GREGS * INT_REGISTER_SIZE
	    + NUM_FREGS * FP_REGISTER_SIZE
d1429 28
d1654 1
a1654 1
  else if ((inst1 & 0xf800) == 0xf000)	/* long branch with link, and blx */
a1658 14
      /* For BLX make sure to clear the low bits.  */
      if (bits (inst2, 11, 12) == 1)
	nextpc = nextpc & 0xfffffffc;
    }
  else if ((inst1 & 0xff00) == 0x4700)	/* bx REG, blx REG */
    {
      if (bits (inst1, 3, 6) == 0x0f)
	nextpc = pc_val;
      else
	nextpc = read_register (bits (inst1, 3, 6));

      nextpc = ADDR_BITS_REMOVE (nextpc);
      if (nextpc == pc)
	error ("Infinite loop detected");
a1699 14
	    /* BX <reg>, BLX <reg> */
	    if (bits (this_instr, 4, 28) == 0x12fff1
		|| bits (this_instr, 4, 28) == 0x12fff3)
	      {
		rn = bits (this_instr, 0, 3);
		result = (rn == 15) ? pc_val + 8 : read_register (rn);
		nextpc = (CORE_ADDR) ADDR_BITS_REMOVE (result);

		if (nextpc == pc)
		  error ("Infinite loop detected");

		return nextpc;
	      }

a1864 4
	    /* BLX */
	    if (bits (this_instr, 28, 31) == INST_NV)
	      nextpc |= bit (this_instr, 24) << 1;

d2053 1
a2053 1
	    bfd_byte tmpbuf[FP_REGISTER_SIZE];
d2066 1
a2066 1
				  valbuf + INT_REGISTER_SIZE);
d2095 2
a2096 2
				  (len > INT_REGISTER_SIZE
				   ? INT_REGISTER_SIZE : len),
d2098 2
a2099 2
	  len -= INT_REGISTER_SIZE;
	  valbuf += INT_REGISTER_SIZE;
d2109 1
a2109 1
      bfd_byte tmpbuf[INT_REGISTER_SIZE];
d2115 3
a2117 3
		  len > INT_REGISTER_SIZE ? INT_REGISTER_SIZE : len);
	  len -= INT_REGISTER_SIZE;
	  valbuf += INT_REGISTER_SIZE;
a2143 2
  CHECK_TYPEDEF (type);

d2201 1
a2201 1
	  field_type_code = TYPE_CODE (check_typedef (TYPE_FIELD_TYPE (type, i)));
d2239 1
a2239 1
      char buf[MAX_REGISTER_SIZE];
d2254 1
a2254 1
				   valbuf + INT_REGISTER_SIZE);
d2275 1
a2275 1
	  bfd_byte tmpbuf[INT_REGISTER_SIZE];
d2278 1
a2278 1
	  store_signed_integer (tmpbuf, INT_REGISTER_SIZE, val);
d2292 2
a2293 2
	      len -= INT_REGISTER_SIZE;
	      valbuf += INT_REGISTER_SIZE;
d2304 1
a2304 1
      bfd_byte tmpbuf[INT_REGISTER_SIZE];
d2309 1
a2309 1
		  len > INT_REGISTER_SIZE ? INT_REGISTER_SIZE : len);
d2311 2
a2312 2
	  len -= INT_REGISTER_SIZE;
	  valbuf += INT_REGISTER_SIZE;
d2321 1
a2321 1
  char buf[INT_REGISTER_SIZE];
d2327 1
a2327 1
			  INT_REGISTER_SIZE))
d2330 1
a2330 1
  *pc = extract_unsigned_integer (buf, INT_REGISTER_SIZE);
d2774 2
a2775 2
					 (NUM_GREGS * INT_REGISTER_SIZE
					  + NUM_FREGS * FP_REGISTER_SIZE
d2778 5
a2782 1
  set_gdbarch_register_type (gdbarch, arm_register_type);
@


1.164.2.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d194 1
a194 1
   arm_pc_is_thumb.  */
d237 1
a237 1
  if (deprecated_pc_in_call_dummy (memaddr))
d272 33
d410 1
a410 1
  if (deprecated_pc_in_call_dummy (pc))
d996 9
d1041 2
a1042 2
  trad_frame_get_prev_register (next_frame, cache->saved_regs, prev_regnum,
				optimized, lvalp, addrp, realnump, valuep);
d1134 2
a1135 2
  trad_frame_get_prev_register (next_frame, cache->saved_regs, prev_regnum,
				optimized, lvalp, addrp, realnump, valuep);
d1147 5
d1153 1
a1153 1
      && legacy_pc_in_sigtramp (frame_pc_unwind (next_frame), (char *) 0))
d1190 14
d1241 1
a1241 1
arm_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
d2741 3
d2753 2
d2779 4
d2796 1
a2796 1
  set_gdbarch_deprecated_use_struct_convention (gdbarch, arm_use_struct_convention);
d2964 1
a2964 1
  deprecate_cmd (deprecated_add_show_from_set (new_set, &showlist),
d2973 1
a2973 1
  deprecated_add_show_from_set (new_set, &showarmcmdlist);
d2975 14
a2988 6
  add_setshow_boolean_cmd ("apcs32", no_class, &arm_apcs_32, "\
Set usage of ARM 32-bit mode.", "\
Show usage of ARM 32-bit mode.", "\
When off, a 26-bit PC will be used.\n\
When off, a 26-bit PC will be used.", "\
Usage of ARM 32-bit mode is %s.",
d3003 1
a3003 2
  set_cmd_sfunc (deprecated_add_show_from_set (new_set, &showarmcmdlist),
		 show_fp_model);
d3011 5
a3015 5
  add_setshow_boolean_cmd ("arm", class_maintenance, &arm_debug, "\
Set ARM debugging.", "\
Show ARM debugging.", "\
When on, arm-specific debugging is enabled.", "\
ARM debugging is %s.",
@


1.164.4.1
log
@	* arm-tdep.c (thumb_get_next_pc): Handle BX.
	(arm_get_next_pc): Handle BX and BLX.
@
text
@a1659 11
  else if ((inst1 & 0xff80) == 0x4700)	/* branch and exchange (bx) */
    {
      if (bits (inst1, 3, 6) == 0x0f)
	nextpc = pc_val;
      else
	nextpc = read_register (bits (inst1, 3, 6));

      nextpc = ADDR_BITS_REMOVE (nextpc);
      if (nextpc == pc)
	error ("Infinite loop detected");
    }
a1699 14
	    /* BX <reg>, BLX <reg> */
	    if (bits (this_instr, 4, 28) == 0x12fff1
		|| bits (this_instr, 4, 28) == 0x12fff3)
	      {
		rn = bits (this_instr, 0, 3);
		result = (rn == 15) ? pc_val + 8 : read_register (rn);
		nextpc = (CORE_ADDR) ADDR_BITS_REMOVE (result);

		if (nextpc == pc)
		  error ("Infinite loop detected");

		return nextpc;
	      }

a1863 4

	    /* BLX */
	    if (bits (this_instr, 28, 31) == INST_NV)
	      nextpc |= bit (this_instr, 24) << 1;
@


1.164.4.2
log
@	* arm-tdep.c (thumb_get_next_pc): Handle Thumb BLX.
@
text
@d1654 1
a1654 1
  else if ((inst1 & 0xf800) == 0xf000)	/* long branch with link, and blx */
a1658 3
      /* For BLX make sure to clear the low bits.  */
      if (bits (inst2, 11, 12) == 1)
	nextpc = nextpc & 0xfffffffc;
d1660 1
a1660 1
  else if ((inst1 & 0xff00) == 0x4700)	/* bx REG, blx REG */
@


1.164.4.3
log
@	* arm-tdep.c (arm_use_struct_convention): Look through typedefs.
	* gdbtypes.c (check_typedef): Update comments.
@
text
@a2175 2
  CHECK_TYPEDEF (type);

d2233 1
a2233 1
	  field_type_code = TYPE_CODE (check_typedef (TYPE_FIELD_TYPE (type, i)));
@


1.164.4.4
log
@	* arm-linux-tdep.c (ARM_LINUX_JB_ELEMENT_SIZE): Define to
	INT_REGISTER_SIZE.
	(arm_linux_push_arguments): Use TARGET_DOUBLE_BIT instead of
	FP_REGISTER_VIRTUAL_SIZE.
	* arm-tdep.c (arm_make_sigtramp_cache): Use register_size instead
	of DEPRECATED_REGISTER_RAW_SIZE.
	(arm_register_type): Add gdbarch argument.
	(arm_register_raw_size, arm_register_virtual_size): Delete.
	(arm_register_byte, arm_extract_return_value)
	(arm_store_return_value, arm_get_longjmp_target): Update references
	to INT_REGISTER_RAW_SIZE and FP_REGISTER_RAW_SIZE.
	(arm_gdbarch_init): Likewise.  Don't set
	deprecated_register_raw_size, deprecated_register_virtual_size,
	deprecated_max_register_raw_size,
	deprecated_max_register_virtual_size, or
	deprecated_max_register_virtual_type.  Do set register_type.
	* arm-tdep.h (ARM_MAX_REGISTER_RAW_SIZE)
	(ARM_MAX_REGISTER_VIRTUAL_SIZE, INT_REGISTER_VIRTUAL_SIZE)
	(FP_REGISTER_VIRTUAL_SIZE): Delete.
	(INT_REGISTER_RAW_SIZE): Rename to INT_REGISTER_SIZE.
	(FP_REGISTER_RAW_SIZE): Rename to FP_REGISTER_SIZE.
	* arm-linux-tdep.c (ARM_NBSD_JB_ELEMENT_SIZE): Define to
	INT_REGISTER_SIZE.
	* remote-rdp.c (remote_rdp_fetch_register): Use MAX_REGISTER_SIZE.
	(remote_rdp_store_register): Likewise.
@
text
@d1097 1
a1097 1
			   register_size (current_gdbarch, cache->framereg));
d1399 1
a1399 1
arm_register_type (struct gdbarch *gdbarch, int regnum)
d1419 1
a1419 1
    return regnum * INT_REGISTER_SIZE;
d1421 2
a1422 2
    return (NUM_GREGS * INT_REGISTER_SIZE
	    + (regnum - ARM_F0_REGNUM) * FP_REGISTER_SIZE);
d1424 2
a1425 2
    return (NUM_GREGS * INT_REGISTER_SIZE
	    + NUM_FREGS * FP_REGISTER_SIZE
d1429 28
d2085 1
a2085 1
	    bfd_byte tmpbuf[FP_REGISTER_SIZE];
d2098 1
a2098 1
				  valbuf + INT_REGISTER_SIZE);
d2127 2
a2128 2
				  (len > INT_REGISTER_SIZE
				   ? INT_REGISTER_SIZE : len),
d2130 2
a2131 2
	  len -= INT_REGISTER_SIZE;
	  valbuf += INT_REGISTER_SIZE;
d2141 1
a2141 1
      bfd_byte tmpbuf[INT_REGISTER_SIZE];
d2147 3
a2149 3
		  len > INT_REGISTER_SIZE ? INT_REGISTER_SIZE : len);
	  len -= INT_REGISTER_SIZE;
	  valbuf += INT_REGISTER_SIZE;
d2273 1
a2273 1
      char buf[MAX_REGISTER_SIZE];
d2288 1
a2288 1
				   valbuf + INT_REGISTER_SIZE);
d2309 1
a2309 1
	  bfd_byte tmpbuf[INT_REGISTER_SIZE];
d2312 1
a2312 1
	  store_signed_integer (tmpbuf, INT_REGISTER_SIZE, val);
d2326 2
a2327 2
	      len -= INT_REGISTER_SIZE;
	      valbuf += INT_REGISTER_SIZE;
d2338 1
a2338 1
      bfd_byte tmpbuf[INT_REGISTER_SIZE];
d2343 1
a2343 1
		  len > INT_REGISTER_SIZE ? INT_REGISTER_SIZE : len);
d2345 2
a2346 2
	  len -= INT_REGISTER_SIZE;
	  valbuf += INT_REGISTER_SIZE;
d2355 1
a2355 1
  char buf[INT_REGISTER_SIZE];
d2361 1
a2361 1
			  INT_REGISTER_SIZE))
d2364 1
a2364 1
  *pc = extract_unsigned_integer (buf, INT_REGISTER_SIZE);
d2808 2
a2809 2
					 (NUM_GREGS * INT_REGISTER_SIZE
					  + NUM_FREGS * FP_REGISTER_SIZE
d2812 5
a2816 1
  set_gdbarch_register_type (gdbarch, arm_register_type);
@


1.163
log
@2004-02-16  Andrew Cagney  <cagney@@redhat.com>

	* arm-tdep.c (arm_set_call_dummy_breakpoint_offset): Delete unused
	function.
@
text
@d2747 1
a2747 2
  set_gdbarch_frameless_function_invocation
    (gdbarch, arm_frameless_function_invocation);
@


1.162
log
@2004-02-14  Elena Zannoni  <ezannoni@@redhat.com>

	* symfile.c (init_entry_point_info, entry_point_address): Move
	from here...
	* objfiles.c (init_entry_point_info, entry_point_address):..to
	here.
	* symfile.h (init_entry_point_info, entry_point_address): Remove
	prototypes.
	* objfiles.h (init_entry_point_info, entry_point_address):Add
	prototypes.
	* cris-tdep.c: Remove include of symfile.h. Add include of
	objfiles.h.
	* infcall.c: Ditto.
	* mcore-tdep.c: Ditto.
	* mn10300-tdep.c: Ditto.
	* sh64-tdep.c: Ditto.
 	* v850-tdep.c: Ditto.
	* arm-tdep.c: Remove include of symfile.h.
	* blockframe.c: Ditto.
	* coffread.c: Ditto.
	* dbxread.c: Ditto.
	* dwarf2read.c: Ditto.
	* dwarfread.c: Ditto.
	* frv-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* mdebugread.c: Ditto.
	* mipsread.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* s390-tdep.c: Ditto.
	* sh-tdep.c: Ditto.
	* xstormy16-tdep.c: Ditto.
	* gdbarch.sh: Remove include of symfile.h.
	* gdbarch.c: Regenerate.
	* solib-irix.c (enable_break): Use entry_point_address().
	Add comment about include file.
	* xcoffread.c: Add comment about include file.
	* Makefile.in (arm-tdep.o, blockframe.o, coffread.o, cris-tdep.o)
	(dbxread.o, dwarf2read.o, dwarfread.o, frv-tdep.o, gdbarch.o)
	(ia64-tdep.o, infcall.o, mcore-tdep.o, mdebugread.o, mipsread.o)
	(mn10300-tdep.o, rs6000-nat.o, s390-tdep.o, sh64-tdep.o)
	(sh-tdep.o, v850-tdep.o, xstormy16-tdep.o): Update dependencies.
@
text
@a1203 19
/* Adjust the call_dummy_breakpoint_offset for the bp_call_dummy
   breakpoint to the proper address in the call dummy, so that
   `finish' after a stop in a call dummy works.

   FIXME rearnsha 2002-02018: Tweeking current_gdbarch is not an
   optimal solution, but the call to arm_fix_call_dummy is immediately
   followed by a call to call_function_by_hand, which is the only
   function where call_dummy_breakpoint_offset is actually used.  */


static void
arm_set_call_dummy_breakpoint_offset (void)
{
  if (caller_is_thumb)
    set_gdbarch_deprecated_call_dummy_breakpoint_offset (current_gdbarch, 4);
  else
    set_gdbarch_deprecated_call_dummy_breakpoint_offset (current_gdbarch, 8);
}

@


1.161
log
@2004-02-12  Andrew Cagney  <cagney@@redhat.com>

	* remote-rdi.c (arm_rdi_start_remote): Delete unused function.
	(arm_rdi_interrupt, arm_rdi_interrupt_twice): Ditto.
	(interrupt_query): Ditto.
	(ofunc): Delete unused variable.
	* cris-tdep.c (cris_abi): Delete unused function.
	(reg_pop_op, move_reg_to_mem_index_inc_op): Ditto.
	(cris_get_wide_opcode, cris_get_short_size): Ditto.
	(cris_get_asr_quick_shift_steps): Ditto.
	(cris_skip_prologue_frameless_p): Ditto.
	* arm-tdep.c (arm_push_return_address): Delete unused function.
	(arm_push_dummy_frame, arm_fix_call_dummy): Ditto.
	* rs6000-tdep.c (rs6000_pc_in_call_dummy): Delete unused function.
	* s390-tdep.c (s390_function_start): Delete unused function.
@
text
@a28 1
#include "symfile.h"
@


1.160
log
@2004-02-11  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FRAME_ARGS_SKIP): Default to 0.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
@
text
@a1190 45
/* Set the return address for a generic dummy frame.  ARM uses the
   entry point.  */

static CORE_ADDR
arm_push_return_address (CORE_ADDR pc, CORE_ADDR sp)
{
  write_register (ARM_LR_REGNUM, entry_point_address ());
  return sp;
}

/* Push an empty stack frame, to record the current PC, etc.  */

static void
arm_push_dummy_frame (void)
{
  CORE_ADDR old_sp = read_register (ARM_SP_REGNUM);
  CORE_ADDR sp = old_sp;
  CORE_ADDR fp, prologue_start;
  int regnum;

  /* Push the two dummy prologue instructions in reverse order,
     so that they'll be in the correct low-to-high order in memory.  */
  /* sub     fp, ip, #4 */
  sp = push_word (sp, 0xe24cb004);
  /*  stmdb   sp!, {r0-r10, fp, ip, lr, pc} */
  prologue_start = sp = push_word (sp, 0xe92ddfff);

  /* Push a pointer to the dummy prologue + 12, because when stm
     instruction stores the PC, it stores the address of the stm
     instruction itself plus 12.  */
  fp = sp = push_word (sp, prologue_start + 12);

  /* Push the processor status.  */
  sp = push_word (sp, read_register (ARM_PS_REGNUM));

  /* Push all 16 registers starting with r15.  */
  for (regnum = ARM_PC_REGNUM; regnum >= 0; regnum--)
    sp = push_word (sp, read_register (regnum));

  /* Update fp (for both Thumb and ARM) and sp.  */
  write_register (ARM_FP_REGNUM, fp);
  write_register (THUMB_FP_REGNUM, fp);
  write_register (ARM_SP_REGNUM, sp);
}

a1221 64
}

/* Fix up the call dummy, based on whether the processor is currently
   in Thumb or ARM mode, and whether the target function is Thumb or
   ARM.  There are three different situations requiring three
   different dummies:

   * ARM calling ARM: uses the call dummy in tm-arm.h, which has already
   been copied into the dummy parameter to this function.
   * ARM calling Thumb: uses the call dummy in tm-arm.h, but with the
   "mov pc,r4" instruction patched to be a "bx r4" instead.
   * Thumb calling anything: uses the Thumb dummy defined below, which
   works for calling both ARM and Thumb functions.

   All three call dummies expect to receive the target function
   address in R4, with the low bit set if it's a Thumb function.  */

static void
arm_fix_call_dummy (char *dummy, CORE_ADDR pc, CORE_ADDR fun, int nargs,
		    struct value **args, struct type *type, int gcc_p)
{
  static short thumb_dummy[4] =
  {
    0xf000, 0xf801,		/*        bl      label */
    0xdf18,			/*        swi     24 */
    0x4720,			/* label: bx      r4 */
  };
  static unsigned long arm_bx_r4 = 0xe12fff14;	/* bx r4 instruction */

  /* Set flag indicating whether the current PC is in a Thumb function.  */
  caller_is_thumb = arm_pc_is_thumb (read_pc ());
  arm_set_call_dummy_breakpoint_offset ();

  /* If the target function is Thumb, set the low bit of the function
     address.  And if the CPU is currently in ARM mode, patch the
     second instruction of call dummy to use a BX instruction to
     switch to Thumb mode.  */
  target_is_thumb = arm_pc_is_thumb (fun);
  if (target_is_thumb)
    {
      fun |= 1;
      if (!caller_is_thumb)
	store_unsigned_integer (dummy + 4, sizeof (arm_bx_r4), arm_bx_r4);
    }

  /* If the CPU is currently in Thumb mode, use the Thumb call dummy
     instead of the ARM one that's already been copied.  This will
     work for both Thumb and ARM target functions.  */
  if (caller_is_thumb)
    {
      int i;
      char *p = dummy;
      int len = sizeof (thumb_dummy) / sizeof (thumb_dummy[0]);

      for (i = 0; i < len; i++)
	{
	  store_unsigned_integer (p, sizeof (thumb_dummy[0]), thumb_dummy[i]);
	  p += sizeof (thumb_dummy[0]);
	}
    }

  /* Put the target address in r4; the call dummy will copy this to
     the PC.  */
  write_register (4, fun);
@


1.159
log
@2004-01-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (EXTRACT_STRUCT_VALUE_ADDRESS): Deprecate.  Add
	comments mentioning extract_returned_value_address.
	* infcmd.c (print_return_value): Update.  Add comments on
	extract_returned_value_address.
	* stack.c (return_command): Add comments on
	extract_returned_value_address.
	* values.c: Update comment.
	* m32r-tdep.c: Update comment.
	* sparc-tdep.c: Update comment.
	* ia64-tdep.c (ia64_use_struct_convention): Update comment.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* m68klinux-tdep.c (m68k_linux_init_abi): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

Index: doc/ChangeLog
2004-01-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	EXTRACT_STRUCT_VALUE_ADDRESS to
	DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS.
@
text
@a2877 1
  set_gdbarch_frame_args_skip (gdbarch, 0);
@


1.158
log
@	* arm-tdep.c (arm_write_pc): New function.
	(arm_gdbarch_init): Call set_gdbarch_write_pc.
@
text
@d2926 1
a2926 2
  set_gdbarch_extract_struct_value_address (gdbarch,
					    arm_extract_struct_value_address);
@


1.157
log
@2004-01-17  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DECR_PC_AFTER_BREAK): Make zero the default.
	* gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	DECR_PC_AFTER_BREAK to zero.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc32_gdbarch_init): Ditto.
	* sh64-tdep.c (sh64_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* m32r-tdep.c (m32r_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-interix-tdep.c (i386_interix_init_abi): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* i386-nto-tdep.c (i386nto_init_abi): Add comment.
@
text
@d3 1
a3 1
   2001, 2002, 2003 Free Software Foundation, Inc.
d2692 15
d2868 2
@


1.156
log
@2004-01-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FUNCTION_START_OFFSET): Make zero the default.
	* gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	FUNCTION_START_OFFSET.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc32_gdbarch_init): Ditto.
	* sh64-tdep.c (sh64_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* m32r-tdep.c (m32r_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
@
text
@a2879 1
  set_gdbarch_decr_pc_after_break (gdbarch, 0);
@


1.155
log
@2003-11-07  Michael Chastain  <mec@@shout.net>

	* symtab.h (struct minimal_symbol): Add size.
	* dbxread.c: Use it.
	* elfread.c: (record_minimal_symbol_and_info): Do not use info.
	Rename to record_minimal_symbol.
	(elf_symtab_read): Set MSYMBOL_SIZE explicitly.
	* minsyms.c (prim_record_minimal_symbol_and_info): Initialize MSYMBOL_SIZE.
	(install_minimal_symbols): Ditto.
	* objfiles.c (terminate_minimal_symbol_table): Ditto.
	* arm-tdep.c: Delete unused MSYMBOL_SIZE.
	* m68hc11-tdep.c: Ditto.
	* mips-tdep.c: Ditto.
	* sh64-tdep.c: Ditto.
@
text
@a2868 3
  /* Offset from address of function to start of its code.  */
  set_gdbarch_function_start_offset (gdbarch, 0);

@


1.154
log
@2003-10-31  Andrew Cagney  <cagney@@redhat.com>

	* avr-tdep.c (avr_frame_this_id): Do not call
	deprecated_inside_entry_file.
	* m68hc11-tdep.c (m68hc11_frame_this_id): Ditto.
	* m32r-tdep.c (m32r_frame_this_id): Ditto.
	* d10v-tdep.c (d10v_frame_this_id): Ditto.
	* arm-tdep.c (arm_prologue_this_id): Ditto.
	* alpha-tdep.c (alpha_heuristic_frame_this_id): Ditto.
@
text
@d84 1
a84 3
   is used for this purpose. This field is already being used to store
   the symbol size, so the assumption is that the symbol size cannot
   exceed 2^31.
d87 1
a87 4
   MSYMBOL_IS_SPECIAL   Tests the "special" bit in a minimal symbol.
   MSYMBOL_SIZE         Returns the size of the minimal symbol,
   			i.e. the "info" field with the "special" bit
   			masked out.  */
a94 3

#define MSYMBOL_SIZE(msym)				\
	((long) MSYMBOL_INFO (msym) & 0x7fffffff)
@


1.153
log
@2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_RAW_SIZE): Rename
	REGISTER_RAW_SIZE.
	* gdbarch.h, gdbarch.c: Re-generate.
	* aix-thread.c, alpha-tdep.h, arm-tdep.c, core-sol2.c: Update.
	* cris-tdep.c, dve3900-rom.c, findvar.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, ia64-tdep.c, infcmd.c, infptrace.c: Update.
	* infrun.c, irix5-nat.c, lynx-nat.c, mips-linux-tdep.c: Update.
	* mips-nat.c, mips-tdep.c, mipsv4-nat.c, mn10300-tdep.c: Update.
	* monitor.c, ns32k-tdep.c, ppc-linux-nat.c, regcache.c: Update.
	* remote-e7000.c, remote-mips.c, remote-sim.c: Update.
	* remote-vxmips.c, remote-vxsparc.c, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, rs6000-tdep.c, s390-tdep.c: Update.
	* sh64-tdep.c, sparc-nat.c, sparc-tdep.c, stack.c: Update.
	* target.c, tracepoint.c, v850-tdep.c, v850ice.c, valops.c: Update.
	* vax-tdep.c, vax-tdep.h, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-vx68.h: Update.
	* config/sparc/tm-sparc.h, config/sparc/tm-sparclynx.h: Update.

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	REGISTER_RAW_SIZE to DEPRECATED_REGISTER_RAW_SIZE.
	* gdb.texinfo (Packets, Stop Reply Packets): Ditto.
	* gdbint.texinfo (Target Architecture Definition): Rename

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c: Rename REGISTER_RAW_SIZE to
	DEPRECATED_REGISTER_RAW_SIZE.
@
text
@d997 1
a997 1
  if (func <= LOWEST_PC || deprecated_inside_entry_file (func))
@


1.152
log
@2003-09-29  Jerome Guitton  <guitton@@act-europe.fr>

	* arm-tdep.c (arm_make_prologue_cache): Use trad_frame_addr_p to
	test if the register has been saved on the stack.
	(arm_scan_prologue_cache): When analysing the instruction
	"str lr, [sp, #-4]", save the address where lr has been stored.
@
text
@d1106 1
a1106 1
			   REGISTER_RAW_SIZE (cache->framereg));
@


1.151
log
@	* arm-tdep.c (arm_skip_prologue): Handle "sub ip, sp #n" and
	"add ip, sp #n" in the prologue.
	(arm_scan_prologue): Ditto.
@
text
@d848 2
a849 1
	  /* Function is frameless: extra_info defaults OK?  */
d971 1
a971 1
    if (cache->saved_regs[reg].addr != 0)
@


1.150
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@d458 6
d716 1
a716 1
  int regno, sp_offset, fp_offset;
d817 1
a817 1
  sp_offset = fp_offset = 0;
d827 17
d885 1
a885 1
	  fp_offset = -imm;
@


1.149
log
@2003-09-12  Andrew Cagney  <cagney@@redhat.com>

	* objfiles.h (struct entry_info): Deprecate "entry_file_lowpc" and
	"entry_file_highpc".  Update comments.
	* defs.h (deprecated_inside_entry_file): Rename
	"inside_entry_file".
	* blockframe.c (deprecated_inside_entry_file): Rename
	"inside_entry_file".
	* frame.c (get_prev_frame): Update.  Use if 0 instead of #if 0.
	* vax-tdep.c (vax_frame_chain): Update.
	* sh64-tdep.c (sh64_frame_chain): Update.
	* sh-tdep.c (sh_frame_chain): Update.
	* rs6000-tdep.c (rs6000_frame_chain): Update.
	* ns32k-tdep.c (ns32k_frame_chain): Update.
	* mips-tdep.c (mips_frame_chain): Update.
	* m68hc11-tdep.c (m68hc11_frame_this_id): Update.
	* m32r-tdep.c (m32r_frame_this_id): Update.
	* i386-interix-tdep.c (i386_interix_frame_chain_valid): Update.
	* frv-tdep.c (frv_frame_this_id): Update.
	* d10v-tdep.c (d10v_frame_this_id): Update.
	* cris-tdep.c (cris_frame_chain): Update.
	* blockframe.c (legacy_frame_chain_valid): Update.
	* avr-tdep.c (avr_frame_this_id): Update.
	* arm-tdep.c (arm_prologue_this_id): Update.
	* alpha-tdep.c (alpha_heuristic_frame_this_id): Update.
	* objfiles.c (objfile_relocate): Update.
	* mipsread.c (mipscoff_symfile_read): Update.
	(mipscoff_symfile_read): Update.
	* mdebugread.c (parse_partial_symbols): Update.
	* dwarfread.c (read_file_scope): Update.
	* dwarf2read.c (read_file_scope): Update.
	* dbxread.c (read_dbx_symtab): Update.
	(read_dbx_symtab): Update.
	* coffread.c (complete_symtab): Update.
@
text
@d1495 1
a1495 1
  register unsigned long status = read_register (ARM_FPS_REGNUM);
d2255 1
a2255 1
  register enum type_code code;
@


1.148
log
@2003-09-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_CALL_DUMMY_ADDRESS): Rename
	CALL_DUMMY_ADDRESS, change to a predicate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* blockframe.c (deprecated_pc_in_call_dummy_at_entry_point):
	Use either DEPRECATED_CALL_DUMMY_ADDRESS or entry_point_address.
	* infcall.c (call_function_by_hand): Ditto.
	* sparc-tdep.c (sparc_push_return_address): Ditto.
	(sparc_gdbarch_init): Set deprecated_call_dummy_address.
	* xstormy16-tdep.c (xstormy16_push_return_address): Replace
	CALL_DUMMY_ADDRESS with entry_point_address.
	* v850-tdep.c (v850_push_return_address): Ditto.
	* s390-tdep.c (s390_push_return_address): Ditto.
	* rs6000-tdep.c (ppc_push_return_address): Ditto.
	* mn10300-tdep.c (mn10300_push_return_address): Ditto.
	* mcore-tdep.c (mcore_push_return_address): Ditto.
	* cris-tdep.c (cris_push_return_address): Ditto.
	* arm-tdep.c (arm_push_return_address): Ditto.
@
text
@d973 1
a973 1
  if (func <= LOWEST_PC || inside_entry_file (func))
@


1.147
log
@	* arm-tdep.c: Include frame-unwind.h, frame-base.h, and
	trad-frame.h.
	(arm_get_cache): Delete macro.
	(struct arm_prologue_cache): Update comments.  Make saved_regs into
	a trad_frame_saved_reg pointer.  Remove unwound_pc; rename unwound_sp
	to prev_sp.
	(thumb_scan_prologue): Update for cache changes.  Don't call
	DEPRECATED_PC_IN_CALL_DUMMY.
	(arm_scan_prologue): Update for cache changes.  Take NEXT_FRAME
	argument and use it in desperation search for our prologue.  Do not
	search past the specified PC.
	(arm_make_prologue_cache): Simplify.

	(arm_prologue_this_id, arm_prologue_prev_register)
	(arm_prologue_unwind, arm_prologue_unwind_sniffer)
	(arm_normal_frame_base, arm_normal_base, arm_make_sigtramp_cache)
	(arm_sigtramp_this_id, arm_sigtramp_prev_register)
	(arm_sigtramp_unwind, arm_sigtramp_unwind_sniffer)
	(arm_unwind_dummy_id, arm_unwind_pc, arm_unwind_sp): New.

	(arm_frame_chain_valid, arm_find_callers_reg)
	(arm_frame_saved_pc, arm_read_fp, arm_frame_init_saved_regs)
	(arm_pop_frame): Delete obsolete methods.
	(arm_minimal_frame_chain, arm_minimal_frame_info): Delete.

	(arm_gdbarch_init): Update for new frame methods.  Register prologue
	and sigtramp unwinders.  Set the default frame base method.

	* Makefile.in (arm-tdep.o): Update dependencies.
	* varobj.c (find_frame_addr_in_frame_chain): Call
	get_frame_base_address.
	* std-regs.c (value_of_builtin_frame_fp_reg): Likewise.
@
text
@d1181 1
a1181 1
  write_register (ARM_LR_REGNUM, CALL_DUMMY_ADDRESS ());
@


1.146
log
@	* arm-tdep.c (arm_minimal_frame_chain): Renamed from
	arm_frame_chain.  Take NEXT_FRAME and CACHE arguments.
	Use the cache instead of DEPRECATED_FRAME_SAVED_PC.
	(arm_minimal_frame_info): Renamed from arm_init_extra_frame_info.
	Take NEXT_FRAME and CACHE arguments.  Call
	FRAMELESS_FUNCTION_INVOCATION instead of checking FROMLEAF argument.
	Set unwound_pc in CACHE instead of modifying the frame argument.
	Don't bother checking the frame type when looking for sigtramp
	frames.
	(arm_make_prologue_cache, arm_frame_chain)
	(arm_init_extra_frame_info): New functions.
@
text
@d37 3
a160 8
/* Define other aspects of the stack frame.  We keep the offsets of
   all saved registers, 'cause we need 'em a lot!  We also keep the
   current size of the stack frame, and the offset of the frame
   pointer from the stack pointer (for frameless functions, and when
   we're still in the prologue of a function with a frame).  */

#define arm_get_cache(fi) ((struct arm_prologue_cache *) get_frame_extra_info (fi))

d163 10
a172 1
  CORE_ADDR unwound_sp, unwound_pc;
d175 2
d178 3
a180 1
  CORE_ADDR saved_regs[1];
a188 6
static int
arm_frame_chain_valid (CORE_ADDR chain, struct frame_info *thisframe)
{
  return (DEPRECATED_FRAME_SAVED_PC (thisframe) >= LOWEST_PC);
}

a510 1
   This information is stored in the "extra" fields of the frame_info.
d527 1
a527 1
thumb_scan_prologue (struct arm_prologue_cache *cache)
d542 1
a542 5
  /* Don't try to scan dummy frames.  */
  if (DEPRECATED_PC_IN_CALL_DUMMY (cache->unwound_pc, 0, 0))
    return;

  if (find_pc_partial_function (cache->unwound_pc, NULL, &prologue_start, &prologue_end))
d547 1
a547 1
	prologue_end = cache->unwound_pc;
d556 1
a556 1
  prologue_end = min (prologue_end, cache->unwound_pc);
d591 1
a591 1
		cache->saved_regs[saved_reg[regno]] = -cache->framesize;
d708 1
a708 1
arm_scan_prologue (struct arm_prologue_cache *cache)
a710 1
  LONGEST return_value;
d712 1
d720 1
a720 1
  if (arm_pc_is_thumb (cache->unwound_pc))
d722 1
a722 1
      thumb_scan_prologue (cache);
d728 1
a728 1
  if (find_pc_partial_function (cache->unwound_pc, NULL, &prologue_start, &prologue_end))
d736 1
a736 1
	      prologue_end = cache->unwound_pc;
d769 10
a778 3
      /* Get address of the stmfd in the prologue of the callee; 
         the saved PC is the address of the stmfd + 8.  */
      if (!safe_read_memory_integer (cache->unwound_sp, 4,  &return_value))
d787 3
d840 1
a840 1
		cache->saved_regs[regno] = sp_offset;
d876 1
a876 1
	  cache->saved_regs[regno] = sp_offset;
d903 1
a903 1
	      cache->saved_regs[fp_start_reg++] = sp_offset;
d926 11
a936 6
/* Find REGNUM on the stack.  Otherwise, it's in an active register.
   One thing we might want to do here is to check REGNUM against the
   clobber mask, and somehow flag it as invalid if it isn't saved on
   the stack somewhere.  This would provide a graceful failure mode
   when trying to get the value of caller-saves registers for an inner
   frame.  */
d938 13
a950 25
static CORE_ADDR
arm_find_callers_reg (struct frame_info *fi, int regnum)
{
  /* NOTE: cagney/2002-05-03: This function really shouldn't be
     needed.  Instead the (still being written) register unwind
     function could be called directly.  */
  for (; fi; fi = get_next_frame (fi))
    {
      if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (fi), 0, 0))
	{
	  return deprecated_read_register_dummy (get_frame_pc (fi),
						 get_frame_base (fi), regnum);
	}
      else if (get_frame_saved_regs (fi)[regnum] != 0)
	{
	  /* NOTE: cagney/2002-05-03: This would normally need to
             handle ARM_SP_REGNUM as a special case as, according to
             the frame.h comments, saved_regs[SP_REGNUM] contains the
             SP value not its address.  It appears that the ARM isn't
             doing this though.  */
	  return read_memory_integer (get_frame_saved_regs (fi)[regnum],
				      REGISTER_RAW_SIZE (regnum));
	}
    }
  return read_register (regnum);
a951 5
/* Function: frame_chain Given a GDB frame, determine the address of
   the calling function's frame.  This will be used to create a new
   GDB frame struct, and then DEPRECATED_INIT_EXTRA_FRAME_INFO and
   DEPRECATED_INIT_FRAME_PC will be called for the new frame.  For
   ARM, we save the frame size when we initialize the frame_info.  */
d953 7
a959 2
CORE_ADDR
arm_minimal_frame_chain (struct frame_info *next_frame, struct arm_prologue_cache *cache)
d961 3
a963 2
  CORE_ADDR caller_pc;
  int framereg = arm_get_cache (next_frame)->framereg;
d965 10
a974 2
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (next_frame), 0, 0))
    return get_frame_base (next_frame);
d976 3
a978 2
  if (get_frame_pc (next_frame) < LOWEST_PC)
    return 0;
d980 1
a980 1
  caller_pc = cache->unwound_pc;
d982 10
a991 45
  /* If the caller is Thumb and the caller is ARM, or vice versa,
     the frame register of the caller is different from ours.
     So we must scan the prologue of the caller to determine its
     frame register number.  */
  /* XXX Fixme, we should try to do this without creating a temporary
     cache!  */
  /* NOTE drow/2003-06-26: I'm quite suspicious of this code... what is it
     really doing?  I have the feeling that it's trying to handle the case
     where my framereg is ARM_FP_REGNUM, and my (Thumb) caller's framereg is
     THUMB_FP_REGNUM, and switching between the two.  But the unwinder should
     be taking care of that.  */
  if (arm_pc_is_thumb (caller_pc) != arm_pc_is_thumb (get_frame_pc (next_frame)))
    {
      struct arm_prologue_cache *cache
	= xcalloc (1, sizeof (struct arm_prologue_cache)
		   + (NUM_REGS + NUM_PSEUDO_REGS - 1) * sizeof (CORE_ADDR));
      struct cleanup *old_chain = make_cleanup (xfree, cache);

      /* Now, scan the prologue and obtain the frame register.  */
      cache->unwound_pc = caller_pc;
      arm_scan_prologue (cache);
      framereg = cache->framereg;

      /* Deallocate the storage associated with the temporary frame
	 created above.  */
      do_cleanups (old_chain);
    }

  /* If the caller used a frame register, return its value.
     Otherwise, return the caller's stack pointer.  */
  if (framereg == ARM_FP_REGNUM || framereg == THUMB_FP_REGNUM)
    return arm_find_callers_reg (next_frame, framereg);
  else
    /* FIXME drow/2003-06-26: The next frame is an opaque thing at this point,
       we should only be using frame methods on it.  What if it's a dummy
       frame, calling a frameless function (framereg == ARM_SP_REGNUM)?  Test
       it.  */
    return get_frame_base (next_frame) + arm_get_cache (next_frame)->framesize;
}

/* This function actually figures out the frame address for a given pc
   and sp.  This is tricky because we sometimes don't use an explicit
   frame pointer, and the previous stack pointer isn't necessarily
   recorded on the stack.  The only reliable way to get this info is
   to examine the prologue.  */
d994 8
a1001 2
arm_minimal_frame_info (struct frame_info *next_frame,
			struct arm_prologue_cache *cache)
d1003 1
a1003 2
  int reg;
  CORE_ADDR sp;
d1005 20
a1024 1
  memset (cache->saved_regs, '\000', sizeof (CORE_ADDR) * (NUM_REGS + NUM_PSEUDO_REGS));
d1026 3
a1028 2
  /* Compute stack pointer for this frame.  We use this value for both
     the sigtramp and call dummy cases.  */
d1030 5
a1034 20
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (next_frame), 0, 0))
    /* For generic dummy frames, pull the value direct from the frame.
       Having an unwind function to do this would be nice.  */
    sp = deprecated_read_register_dummy (get_frame_pc (next_frame),
					 get_frame_base (next_frame),
					 ARM_SP_REGNUM);
  else if (arm_get_cache (next_frame))
    sp = (get_frame_base (next_frame)
	  - arm_get_cache (next_frame)->frameoffset
	  + arm_get_cache (next_frame)->framesize);
  else
    sp = read_sp ();  /* FIXME remove case */

  /* Determine whether or not we're in a sigtramp frame.
     Unfortunately, it isn't sufficient to test (get_frame_type (fi)
     == SIGTRAMP_FRAME) because this value is sometimes set after
     invoking DEPRECATED_INIT_EXTRA_FRAME_INFO.  So we test *both*
     (get_frame_type (fi) == SIGTRAMP_FRAME) and PC_IN_SIGTRAMP to
     determine if we need to use the sigcontext addresses for the
     saved registers.
d1036 10
a1045 4
     Note: If an ARM PC_IN_SIGTRAMP method ever needs to compare
     against the name of the function, the code below will have to be
     changed to first fetch the name of the function and then pass
     this name to PC_IN_SIGTRAMP.  */
d1047 5
a1051 55
  /* FIXME: cagney/2002-11-18: This problem will go away once
     frame.c:get_prev_frame() is modified to set the frame's type
     before calling functions like this.  */

  /* NOTE drow/2003-06-26: This will move to a predicate for a different unwinder shortly.  */

  if (SIGCONTEXT_REGISTER_ADDRESS_P () 
      && PC_IN_SIGTRAMP (cache->unwound_pc, (char *)0))
    {
      for (reg = 0; reg < NUM_REGS; reg++)
	cache->saved_regs[reg] = SIGCONTEXT_REGISTER_ADDRESS (sp, cache->unwound_pc, reg);

      /* FIXME: What about thumb mode?  */
      cache->framereg = ARM_SP_REGNUM;
      cache->unwound_sp = read_memory_integer (cache->saved_regs[cache->framereg], REGISTER_RAW_SIZE (cache->framereg));
      cache->framesize = 0;
      cache->frameoffset = 0;
    }
  else
    {
      /* At this point, the unwound sp is just the result of frame_chain.
	 Then it gets changed below.  */

      arm_scan_prologue (cache);

      if (!next_frame)
	/* This is the innermost frame?  */
	cache->unwound_sp = read_register (cache->framereg);
      else if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (next_frame), 0, 0))
	/* Next inner most frame is a dummy, just grab its frame.
           Dummy frames always have the same FP as their caller.  */
	cache->unwound_sp = get_frame_base (next_frame);
      else if (cache->framereg == ARM_FP_REGNUM
	       || cache->framereg == THUMB_FP_REGNUM)
	{
	  /* not the innermost frame */
	  /* If we have an FP, the callee saved it.  */
	  if (get_frame_saved_regs (next_frame) /**/ && get_frame_saved_regs (next_frame)[cache->framereg] != 0)
	    cache->unwound_sp = read_memory_integer (get_frame_saved_regs (next_frame)[cache->framereg], 4);
	  else if (frame_relative_level (next_frame) == 0
		   && FRAMELESS_FUNCTION_INVOCATION (next_frame))
	    /* If we were called by a frameless fn.  then our frame is
	       still in the frame pointer register on the board...  */
	    cache->unwound_sp = deprecated_read_fp ();
	}

      /* Calculate actual addresses of saved registers using offsets
         determined by arm_scan_prologue.  */
      for (reg = 0; reg < NUM_REGS; reg++)
	if (cache->saved_regs[reg] != 0)
	  cache->saved_regs[reg] = (cache->saved_regs[reg]
				    + cache->unwound_sp
				    + cache->framesize
				    - cache->frameoffset);
    }
d1054 7
d1062 1
a1062 1
arm_make_prologue_cache (struct frame_info *next_frame)
d1065 7
d1073 4
a1076 2
  cache = frame_obstack_zalloc (sizeof (struct arm_prologue_cache)
				+ sizeof (CORE_ADDR) * (NUM_REGS + NUM_PSEUDO_REGS - 1));
d1078 5
a1082 6
  cache->unwound_pc = frame_pc_unwind (next_frame);
  if (frame_relative_level (next_frame) < 0)
    cache->unwound_sp = deprecated_read_fp ();
  else
    cache->unwound_sp = arm_minimal_frame_chain (next_frame, cache);
  arm_minimal_frame_info (next_frame, cache);
d1087 4
a1090 2
static CORE_ADDR
arm_frame_chain (struct frame_info *next_frame)
d1094 7
a1100 2
  cache = arm_make_prologue_cache (next_frame);
  return cache->unwound_sp;
d1104 8
a1111 1
arm_init_extra_frame_info (int fromleaf, struct frame_info *fi)
d1115 13
a1127 1
  cache = arm_make_prologue_cache (deprecated_get_next_frame_hack (fi));
d1129 7
a1135 2
  if (get_frame_saved_regs (fi) == NULL)
    frame_saved_regs_zalloc (fi);
d1137 3
a1139 3
  frame_extra_info_zalloc (fi, (sizeof (struct arm_prologue_cache)
				+ ((NUM_REGS + NUM_PSEUDO_REGS - 1)
				   * sizeof (CORE_ADDR))));
d1141 1
a1141 5
  memcpy (get_frame_extra_info (fi), cache,  (sizeof (struct arm_prologue_cache)
					      + ((NUM_REGS + NUM_PSEUDO_REGS - 1)
						 * sizeof (CORE_ADDR))));
  memcpy (get_frame_saved_regs (fi), cache->saved_regs,
	  (NUM_REGS + NUM_PSEUDO_REGS - 1) * sizeof (CORE_ADDR));
d1144 5
a1148 3
/* Find the caller of this frame.  We do this by seeing if ARM_LR_REGNUM
   is saved in the stack anywhere, otherwise we get it from the
   registers.
d1150 2
a1151 6
   The old definition of this function was a macro:
   #define FRAME_SAVED_PC(FRAME) \
   ADDR_BITS_REMOVE (read_memory_integer ((FRAME)->frame - 4, 4)) */

static CORE_ADDR
arm_frame_saved_pc (struct frame_info *fi)
d1153 2
a1154 18
  /* If a dummy frame, pull the PC out of the frame's register buffer.  */
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (fi), 0, 0))
    return deprecated_read_register_dummy (get_frame_pc (fi),
					   get_frame_base (fi), ARM_PC_REGNUM);

  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (fi),
				   (get_frame_base (fi)
				    - arm_get_cache (fi)->frameoffset),
				   get_frame_base (fi)))
    {
      return read_memory_integer (get_frame_saved_regs (fi)[ARM_PC_REGNUM],
				  REGISTER_RAW_SIZE (ARM_PC_REGNUM));
    }
  else
    {
      CORE_ADDR pc = arm_find_callers_reg (fi, ARM_LR_REGNUM);
      return IS_THUMB_ADDR (pc) ? UNMAKE_THUMB_ADDR (pc) : pc;
    }
d1157 3
a1159 2
/* Return the frame address.  On ARM, it is R11; on Thumb it is R7.
   Examine the Program Status Register to decide which state we're in.  */
d1162 1
a1162 1
arm_read_fp (void)
d1164 3
a1166 4
  if (read_register (ARM_PS_REGNUM) & 0x20)	/* Bit 5 is Thumb state bit */
    return read_register (THUMB_FP_REGNUM);	/* R7 if Thumb */
  else
    return read_register (ARM_FP_REGNUM);	/* R11 if ARM */
d1169 2
a1170 8
/* Store into a struct frame_saved_regs the addresses of the saved
   registers of frame described by FRAME_INFO.  This includes special
   registers such as PC and FP saved in special ways in the stack
   frame.  SP is even more special: the address we return for it IS
   the sp for the next frame.  */

static void
arm_frame_init_saved_regs (struct frame_info *fip)
d1172 1
a1172 5

  if (get_frame_saved_regs (fip))
    return;

  arm_init_extra_frame_info (0, fip);
a1316 34
/* Pop the current frame.  So long as the frame info has been
   initialized properly (see arm_init_extra_frame_info), this code
   works for dummy frames as well as regular frames.  I.e, there's no
   need to have a special case for dummy frames.  */
static void
arm_pop_frame (void)
{
  int regnum;
  struct frame_info *frame = get_current_frame ();
  CORE_ADDR old_SP = (get_frame_base (frame)
		      - arm_get_cache (frame)->frameoffset
		      + arm_get_cache (frame)->framesize);

  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame),
				   get_frame_base (frame),
				   get_frame_base (frame)))
    {
      generic_pop_dummy_frame ();
      flush_cached_frames ();
      return;
    }

  for (regnum = 0; regnum < NUM_REGS; regnum++)
    if (get_frame_saved_regs (frame)[regnum] != 0)
      write_register (regnum,
		  read_memory_integer (get_frame_saved_regs (frame)[regnum],
				       REGISTER_RAW_SIZE (regnum)));

  write_register (ARM_PC_REGNUM, DEPRECATED_FRAME_SAVED_PC (frame));
  write_register (ARM_SP_REGNUM, old_SP);

  flush_cached_frames ();
}

a2796 4
  /* NOTE: cagney/2002-12-06: This can be deleted when this arch is
     ready to unwind the PC first (see frame.c:get_prev_frame()).  */
  set_gdbarch_deprecated_init_frame_pc (gdbarch, init_frame_pc_default);

d2839 4
a2842 4
  set_gdbarch_deprecated_frame_chain_valid (gdbarch, arm_frame_chain_valid);
  set_gdbarch_deprecated_init_extra_frame_info (gdbarch, arm_init_extra_frame_info);
  set_gdbarch_deprecated_target_read_fp (gdbarch, arm_read_fp);
  set_gdbarch_deprecated_frame_chain (gdbarch, arm_frame_chain);
a2844 1
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, arm_frame_saved_pc);
d2846 2
a2847 2
  set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, arm_frame_init_saved_regs);
  set_gdbarch_deprecated_pop_frame (gdbarch, arm_pop_frame);
d2914 4
@


1.145
log
@	* arm-tdep.c (arm_get_cache): Define.
	(struct arm_prologue_cache): Renamed from frame_extra_info.  Add
	unwound_sp, unwound_pc, and saved_regs.
	(thumb_scan_prologue): Take a cache instead of the frame.
	(arm_scan_prologue): Likewise.
	(arm_frame_chain): Create a temporary cache for arm_scan_prologue
	instead of a temporary frame.
	(arm_init_extra_frame_info): Allocate and use a cache.
	(arm_frame_saved_pc, arm_pop_frame): Use the cache.
@
text
@d958 2
a959 2
static CORE_ADDR
arm_frame_chain (struct frame_info *fi)
d962 1
a962 1
  int framereg = arm_get_cache (fi)->framereg;
d964 2
a965 3
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (fi), 0, 0))
    /* A generic call dummy's frame is the same as caller's.  */
    return get_frame_base (fi);
d967 1
a967 1
  if (get_frame_pc (fi) < LOWEST_PC)
d970 1
a970 2
  /* If the caller is the startup code, we're at the end of the chain.  */
  caller_pc = DEPRECATED_FRAME_SAVED_PC (fi);
d978 6
a983 1
  if (arm_pc_is_thumb (caller_pc) != arm_pc_is_thumb (get_frame_pc (fi)))
d1003 1
a1003 1
    return arm_find_callers_reg (fi, framereg);
d1005 5
a1009 1
    return get_frame_base (fi) + arm_get_cache (fi)->framesize;
d1016 1
a1016 4
   to examine the prologue.  FROMLEAF is a little confusing, it means
   this is the next frame up the chain AFTER a frameless function.  If
   this is true, then the frame value for this frame is still in the
   fp register.  */
d1019 2
a1020 1
arm_init_extra_frame_info (int fromleaf, struct frame_info *fi)
d1025 1
a1025 11
  if (get_frame_saved_regs (fi) == NULL)
    frame_saved_regs_zalloc (fi);

  frame_extra_info_zalloc (fi, (sizeof (struct arm_prologue_cache)
				+ ((NUM_REGS + NUM_PSEUDO_REGS - 1)
				   * sizeof (CORE_ADDR))));

  if (get_next_frame (fi))
    deprecated_update_frame_pc_hack (fi, DEPRECATED_FRAME_SAVED_PC (get_next_frame (fi)));

  memset (get_frame_saved_regs (fi), '\000', sizeof get_frame_saved_regs (fi));
d1029 2
a1030 3
  if (!get_next_frame (fi))
    sp = read_sp();
  else if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (get_next_frame (fi)), 0, 0))
d1033 2
a1034 2
    sp = deprecated_read_register_dummy (get_frame_pc (get_next_frame (fi)),
					 get_frame_base (get_next_frame (fi)),
d1036 4
d1041 1
a1041 3
    sp = (get_frame_base (get_next_frame (fi))
	  - arm_get_cache (get_next_frame (fi))->frameoffset
	  + arm_get_cache (get_next_frame (fi))->framesize);
d1060 2
d1063 1
a1063 1
      && ((get_frame_type (fi) == SIGTRAMP_FRAME) || PC_IN_SIGTRAMP (get_frame_pc (fi), (char *)0)))
d1066 1
a1066 1
	get_frame_saved_regs (fi)[reg] = SIGCONTEXT_REGISTER_ADDRESS (sp, get_frame_pc (fi), reg);
d1069 4
a1072 5
      arm_get_cache (fi)->framereg = ARM_SP_REGNUM;
      deprecated_update_frame_base_hack (fi, read_memory_integer (get_frame_saved_regs (fi)[arm_get_cache (fi)->framereg], REGISTER_RAW_SIZE (arm_get_cache (fi)->framereg)));
      arm_get_cache (fi)->framesize = 0;
      arm_get_cache (fi)->frameoffset = 0;

d1076 2
a1077 2
      arm_get_cache (fi)->unwound_pc = get_frame_pc (fi);
      arm_get_cache (fi)->unwound_sp = get_frame_base (fi);
d1079 1
a1079 1
      arm_scan_prologue (arm_get_cache (fi));
d1081 1
a1081 1
      if (!get_next_frame (fi))
d1083 2
a1084 2
	deprecated_update_frame_base_hack (fi, read_register (arm_get_cache (fi)->framereg));
      else if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (get_next_frame (fi)), 0, 0))
d1087 3
a1089 3
	deprecated_update_frame_base_hack (fi, get_frame_base (get_next_frame (fi)));
      else if (arm_get_cache (fi)->framereg == ARM_FP_REGNUM
	       || arm_get_cache (fi)->framereg == THUMB_FP_REGNUM)
d1093 4
a1096 3
	  if (get_frame_saved_regs (get_next_frame (fi))[arm_get_cache (fi)->framereg] != 0)
	    deprecated_update_frame_base_hack (fi, read_memory_integer (get_frame_saved_regs (get_next_frame (fi))[arm_get_cache (fi)->framereg], 4));
	  else if (fromleaf)
d1099 1
a1099 1
	    deprecated_update_frame_base_hack (fi, deprecated_read_fp ());
d1105 5
a1109 5
	if (arm_get_cache (fi)->saved_regs[reg] != 0)
	  get_frame_saved_regs (fi)[reg] = (arm_get_cache (fi)->saved_regs[reg]
					    + get_frame_base (fi)
					    + arm_get_cache (fi)->framesize
					    - arm_get_cache (fi)->frameoffset);
d1113 47
@


1.144
log
@2003-08-24  Andrew Cagney  <cagney@@redhat.com>

	* arm-tdep.c (_initialize_arm_tdep): Simplify by assuming
	GDB_MULTI_ARCH is always non-zero.
	* osabi.c (_initialize_gdb_osabi): Ditto.
	(gdbarch_init_osabi): Ditto.
	* sparc-tdep.c: Ditto for #if code.
@
text
@d164 3
a166 1
struct frame_extra_info
d168 1
d172 1
d526 1
a526 1
thumb_scan_prologue (struct frame_info *fi)
d542 1
a542 2
  if (fi != NULL
      && DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (fi), 0, 0))
d545 1
a545 1
  if (find_pc_partial_function (get_frame_pc (fi), NULL, &prologue_start, &prologue_end))
d550 1
a550 1
	prologue_end = get_frame_pc (fi);
d559 1
a559 1
  prologue_end = min (prologue_end, get_frame_pc (fi));
d570 1
a570 1
  get_frame_extra_info (fi)->framesize = 0;
d593 2
a594 3
		get_frame_extra_info (fi)->framesize += 4;
		get_frame_saved_regs (fi)[saved_reg[regno]] =
		  -(get_frame_extra_info (fi)->framesize);
d610 1
a610 1
	      get_frame_extra_info (fi)->frameoffset += offset;
d613 1
a613 1
	  get_frame_extra_info (fi)->framesize -= offset;
d618 1
a618 1
	  get_frame_extra_info (fi)->framereg = THUMB_FP_REGNUM;
d620 1
a620 1
	  get_frame_extra_info (fi)->frameoffset = (insn & 0xff) << 2;
d625 2
a626 2
	  get_frame_extra_info (fi)->framereg = THUMB_FP_REGNUM;
	  get_frame_extra_info (fi)->frameoffset = 0;
d711 1
a711 1
arm_scan_prologue (struct frame_info *fi)
d718 3
a720 3
  get_frame_extra_info (fi)->framereg = ARM_SP_REGNUM;
  get_frame_extra_info (fi)->framesize = 0;
  get_frame_extra_info (fi)->frameoffset = 0;
d723 1
a723 1
  if (arm_pc_is_thumb (get_frame_pc (fi)))
d725 1
a725 1
      thumb_scan_prologue (fi);
d731 1
a731 1
  if (find_pc_partial_function (get_frame_pc (fi), NULL, &prologue_start, &prologue_end))
d739 1
a739 1
	      prologue_end = get_frame_pc (fi);
d774 1
a774 1
      if (!safe_read_memory_integer (get_frame_base (fi), 4,  &return_value))
d833 1
a833 1
		get_frame_saved_regs (fi)[regno] = sp_offset;
d856 1
a856 1
	  get_frame_extra_info (fi)->framereg = ARM_FP_REGNUM;
d869 1
a869 1
	  get_frame_saved_regs (fi)[regno] = sp_offset;
d896 1
a896 1
	      get_frame_saved_regs (fi)[fp_start_reg++] = sp_offset;
d912 3
a914 3
  get_frame_extra_info (fi)->framesize = -sp_offset;
  if (get_frame_extra_info (fi)->framereg == ARM_FP_REGNUM)
    get_frame_extra_info (fi)->frameoffset = fp_offset - sp_offset;
d916 1
a916 1
    get_frame_extra_info (fi)->frameoffset = 0;
d962 1
a962 1
  int framereg = get_frame_extra_info (fi)->framereg;
d979 1
a979 1
     caller_fi.  */
d982 4
a985 4
      struct cleanup *old_chain = make_cleanup (null_cleanup, NULL);
      struct frame_info *caller_fi =
	deprecated_frame_xmalloc_with_cleanup (SIZEOF_FRAME_SAVED_REGS,
					       sizeof (struct frame_extra_info));
d988 3
a990 3
      deprecated_update_frame_pc_hack (caller_fi, caller_pc);
      arm_scan_prologue (caller_fi);
      framereg = get_frame_extra_info (caller_fi)->framereg;
d1002 1
a1002 1
    return get_frame_base (fi) + get_frame_extra_info (fi)->framesize;
d1023 3
a1025 5
  frame_extra_info_zalloc (fi, sizeof (struct frame_extra_info));

  get_frame_extra_info (fi)->framesize = 0;
  get_frame_extra_info (fi)->frameoffset = 0;
  get_frame_extra_info (fi)->framereg = 0;
d1044 2
a1045 2
	  - get_frame_extra_info (get_next_frame (fi))->frameoffset
	  + get_frame_extra_info (get_next_frame (fi))->framesize);
d1071 4
a1074 4
      get_frame_extra_info (fi)->framereg = ARM_SP_REGNUM;
      deprecated_update_frame_base_hack (fi, read_memory_integer (get_frame_saved_regs (fi)[get_frame_extra_info (fi)->framereg], REGISTER_RAW_SIZE (get_frame_extra_info (fi)->framereg)));
      get_frame_extra_info (fi)->framesize = 0;
      get_frame_extra_info (fi)->frameoffset = 0;
d1079 4
a1082 1
      arm_scan_prologue (fi);
d1086 1
a1086 1
	deprecated_update_frame_base_hack (fi, read_register (get_frame_extra_info (fi)->framereg));
d1091 2
a1092 2
      else if (get_frame_extra_info (fi)->framereg == ARM_FP_REGNUM
	       || get_frame_extra_info (fi)->framereg == THUMB_FP_REGNUM)
d1096 2
a1097 2
	  if (get_frame_saved_regs (get_next_frame (fi))[get_frame_extra_info (fi)->framereg] != 0)
	    deprecated_update_frame_base_hack (fi, read_memory_integer (get_frame_saved_regs (get_next_frame (fi))[get_frame_extra_info (fi)->framereg], 4));
d1107 5
a1111 5
	if (get_frame_saved_regs (fi)[reg] != 0)
	  get_frame_saved_regs (fi)[reg]
	    += (get_frame_base (fi)
		+ get_frame_extra_info (fi)->framesize
		- get_frame_extra_info (fi)->frameoffset);
d1134 1
a1134 1
				    - get_frame_extra_info (fi)->frameoffset),
d1327 2
a1328 2
		      - get_frame_extra_info (frame)->frameoffset
		      + get_frame_extra_info (frame)->framesize);
@


1.143
log
@Missed include update in previous commit.
@
text
@d3027 1
a3027 2
  if (GDB_MULTI_ARCH)
    gdbarch_register (bfd_arch_arm, arm_gdbarch_init, arm_dump_tdep);
@


1.142
log
@* arm-tdep.c (solib-svr4.h): Dont' include it.
(arm_linux_svr4_fetch_link_map_offsets): Move to ...
* arm-linux-tdep.c: ... here.  Make static.
(arm_linux_init_abi): Register it.
(solib-svr4.h): Include it.
* Makefile.in: Update dependencies.
* config/arm/tm-linux.h (SVR4_FETCH_LINK_MAP_OFFSETS): Delete.
(arm_linux_svr4_fetch_link_map_offsets): Delete declaration.
@
text
@a35 1
#include "solib-svr4.h"
@


1.141
log
@2003-06-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Update comments on registers, re-order.
	(deprecated_register_byte): Rename register_byte.
	(deprecated_register_raw_size): Rename register_raw_size.
	(deprecated_register_virtual_size): Rename register_virtual_size.
	(deprecated_register_virtual_type): Rename register_virtual_type.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c: Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
@
text
@a2670 43
/* Fetch, and possibly build, an appropriate link_map_offsets structure
   for ARM linux targets using the struct offsets defined in <link.h>.
   Note, however, that link.h is not actually referred to in this file.
   Instead, the relevant structs offsets were obtained from examining
   link.h.  (We can't refer to link.h from this file because the host
   system won't necessarily have it, or if it does, the structs which
   it defines will refer to the host system, not the target).  */

struct link_map_offsets *
arm_linux_svr4_fetch_link_map_offsets (void)
{
  static struct link_map_offsets lmo;
  static struct link_map_offsets *lmp = 0;

  if (lmp == 0)
    {
      lmp = &lmo;

      lmo.r_debug_size = 8;	/* Actual size is 20, but this is all we
                                   need.  */

      lmo.r_map_offset = 4;
      lmo.r_map_size   = 4;

      lmo.link_map_size = 20;	/* Actual size is 552, but this is all we
                                   need.  */

      lmo.l_addr_offset = 0;
      lmo.l_addr_size   = 4;

      lmo.l_name_offset = 4;
      lmo.l_name_size   = 4;

      lmo.l_next_offset = 12;
      lmo.l_next_size   = 4;

      lmo.l_prev_offset = 16;
      lmo.l_prev_size   = 4;
    }

    return lmp;
}

@


1.140
log
@2003-06-11  Andrew Cagney  <cagney@@redhat.com>

	* xstormy16-tdep.c (xstormy16_push_return_address): Make static.
	(xstormy16_save_dummy_frame_tos): Make static.
	(_initialize_xstormy16_tdep): Add declaration.
	* vax-tdep.c (_initialize_vax_tdep): Add declaration.
	* v850-tdep.c: Make local functions static.
	(_initialize_v850_tdep): Add declaration.
	* sparc-tdep.c: Make local functions static.
	(_initialize_sparc_tdep): Add declaration.
	* sh-tdep.c: Make local functions static.
	(_initialize_sh_tdep): Add declaration.
	* sh3-rom.c (_initialize_sh3_rom): Add declaration.
	* s390-tdep.c: Make local functions static.
	(_initialize_s390_tdep): Add declaration.
	* dbxread.c (find_stab_function_addr): Make static.
	* ppc-bdm.c (_initialize_bdm_ppc): Add declaration.
	* ocd.c (_initialize_remote_ocd): Add declaration.
	* dink32-rom.c (_initialize_dink32_rom): Add declaration.
	* ppcbug-rom.c (_initialize_ppcbug_rom): Add declaration.
	* ns32k-tdep.c (_initialize_ns32k_tdep): Add declaration.
	* ns32knbsd-tdep.c (_initialize_ns32knbsd_tdep): Add declaration.
	* mips-tdep.c (_initialize_mips_tdep): Add declaration.
	* remote-array.c (_initialize_array): Add declaration.
	(_initialize_remote_monitors): Add declaration.
	* remote-mips.c: Make local functions static.
	(_initialize_remote_mips): Add declaration.
	* mcore-tdep.c: Make all local functions static.
	(_initialize_mcore_tdep): Add declaration.
	* dbug-rom.c (_initialize_dbug_rom): Add declaration.
	* abug-rom.c (_initialize_abug_rom): Add declaration.
	* rom68k-rom.c (_initialize_rom68k): Add declaration.
	* cpu32bug-rom.c (_initialize_cpu32bug_rom): Add declaration.
	* m68k-tdep.c (_initialize_m68k_tdep): Add declaration.
	* remote-est.c (_initialize_est): Add declaration.
	* m68hc11-tdep.c (_initialize_m68hc11_tdep): Add declaration.
	(m68hc11_call_dummy_address): Make static.
	* ia64-tdep.c: Make local functions static.
	(_initialize_ia64_tdep): Add declaration.
	* solib-legacy.c (_initialize_svr4_lm): Add declaration.
	* monitor.c (monitor_wait_filter): Make static.
	(_initialize_remote_monitors): Add declaration.
	* remote-hms.c (_initialize_remote_hms): Add declaration.
	* remote-e7000.c (fetch_regs_from_dump): Make static.
	(expect_n): Make static.
	(_initialize_remote_e7000): Add declaration.
	* ser-e7kpc.c: Always include "defs.h".
	(_initialize_ser_e7000pc): Add declaration.
	* h8300-tdep.c (_initialize_h8300_tdep): Add declaration.
	* cris-tdep.c: Make all but one function static.
	(_initialize_cris_tdep): Add declaration.
	* solib-svr4.c (_initialize_svr4_solib): Add declaration.
	* solib.c (update_solib_list): Make static.
	(_initialize_solib): Add declaration.
	* avr-tdep.c (avr_breakpoint_from_pc): Make static.
	(_initialize_avr_tdep): Add declaration.
	* remote-rdi.c (voiddummy): Make static.
	(_initialize_remote_rdi): Add declaration.
	* arm-tdep.c (_initialize_arm_tdep): Add declaration.
	* remote-rdp.c (send_rdp): Make static.
	(_initialize_remote_rdp): Add declaration.
	* alpha-tdep.c (_initialize_alpha_tdep): Add declaration.
@
text
@d2954 1
a2954 1
  set_gdbarch_register_byte (gdbarch, arm_register_byte);
d2960 2
a2961 2
  set_gdbarch_register_raw_size (gdbarch, arm_register_raw_size);
  set_gdbarch_register_virtual_size (gdbarch, arm_register_virtual_size);
d2964 1
a2964 1
  set_gdbarch_register_virtual_type (gdbarch, arm_register_type);
@


1.139
log
@2003-06-09  Andrew Cagney  <cagney@@redhat.com>

	* vax-tdep.c (vax_frame_locals_address): Delete function.
	(vax_gdbarch_init): Do not set frame_locals_address.
	* m68hc11-tdep.c (m68hc11_frame_locals_address): Delete function.
	(m68hc11_gdbarch_init): Do not set frame_locals_address.
	* s390-tdep.c (s390_frame_args_address): Delete function.
	(s390_gdbarch_init): Do not set frame_args_address or
	frame_locals_address.
	* ns32k-tdep.c (ns32k_frame_locals_address): Delete.
	(ns32k_gdbarch_init): Do not set frame_locals_address.
	* hppa-tdep.c (hppa_frame_args_address): Delete function.
	(hppa_frame_locals_address): Delete function.
	(hppa_gdbarch_init): Do not set frame_args_address, or
	frame_locals_address.
	* arm-tdep.c (arm_frame_args_address): Delete.
	(arm_frame_locals_address): Delete.
	(arm_gdbarch_init): Do not set frame_args_address, or
	frame_locals_address.
@
text
@d3057 2
@


1.138
log
@2003-06-09  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FRAME_NUM_ARGS): Change to function with predicate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arch-utils.h (frame_num_args_unknown): Delete both declarations.
	* arch-utils.c (frame_num_args_unknown): Delete function.
	* stack.c (print_args_stub): Use FRAME_NUM_ARGS_P.
	(frame_info): Use FRAME_NUM_ARGS_P.
	* arm-tdep.c (arm_frame_num_args): Delete function.
	(arm_gdbarch_init): Do not set frame_num_args.
	* config/pa/tm-hppa64.h (FRAME_NUM_ARGS): Delete.
	* hppa-tdep.c (hppa_frame_num_args): Delete function.
	(hppa_gdbarch_init): Do not set frame_num_args.
	* config/sparc/tm-sparc.h (FRAME_NUM_ARGS): Delete.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	frame_num_args to default frame_num_args_unknown.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
@
text
@a308 14
/* The address of the arguments in the frame.  */
static CORE_ADDR
arm_frame_args_address (struct frame_info *fi)
{
  return get_frame_base (fi);
}

/* The address of the local variables in the frame.  */
static CORE_ADDR
arm_frame_locals_address (struct frame_info *fi)
{
  return get_frame_base (fi);
}

a2924 2
  set_gdbarch_frame_args_address (gdbarch, arm_frame_args_address);
  set_gdbarch_frame_locals_address (gdbarch, arm_frame_locals_address);
@


1.137
log
@2003-06-01  Andrew Cagney  <cagney@@redhat.com>

	* defs.h (extract_address): Delete declaration.
	* findvar.c (extract_address): Delete function.
	* xstormy16-tdep.c (xstormy16_extract_return_value): Replace
	extract_address with the inline equivalent,
	extract_unsigned_integer.
	(xstormy16_extract_struct_value_address): Ditto.
	(xstormy16_pointer_to_address): Ditto.
	* vax-tdep.c (vax_extract_struct_value_address): Ditto.
	* v850-tdep.c (v850_push_arguments): Ditto.
	(v850_extract_return_value): Ditto.
	(v850_extract_struct_value_address): Ditto.
	* sparcnbsd-tdep.c (sparcnbsd_get_longjmp_target_32): Ditto.
	(sparcnbsd_get_longjmp_target_64): Ditto.
	* sparc-tdep.c (sparc_frame_saved_pc): Ditto.
	(get_longjmp_target): Ditto.
	* sh-tdep.c (sh_extract_struct_value_address): Ditto.
	(sh64_extract_struct_value_address): Ditto.
	(sh_push_arguments): Ditto.
	(sh64_push_arguments): Ditto.
	* remote-vxsparc.c (vx_read_register): Ditto.
	* ppc-linux-tdep.c (ppc_linux_skip_trampoline_code): Ditto.
	* ns32k-tdep.c (ns32k_extract_struct_value_address): Ditto.
	* mn10300-tdep.c (mn10300_extract_struct_value_address): Ditto.
	* mipsv4-nat.c (get_longjmp_target): Ditto.
	* mipsnbsd-tdep.c (mipsnbsd_get_longjmp_target): Ditto.
	* mips-nat.c (get_longjmp_target): Ditto.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target): Ditto.
	* mcore-tdep.c (mcore_extract_struct_value_address): Ditto.
	* m68k-tdep.c (m68k_get_longjmp_target): Ditto.
	* m68hc11-tdep.c (m68hc11_extract_struct_value_address): Ditto.
	* irix5-nat.c (get_longjmp_target): Ditto.
	* irix4-nat.c (get_longjmp_target): Ditto.
	* ia64-tdep.c (generic_elf_find_global_pointer): Ditto.
	(ia64_push_arguments): Ditto.
	* hpux-thread.c (hpux_thread_store_registers): Ditto.
	* h8300-tdep.c (h8300_push_arguments): Ditto.
	(h8300_store_return_value): Ditto.
	(h8300_extract_struct_value_address): Ditto.
	* frv-tdep.c (frv_extract_struct_value_address): Ditto.
	(frv_push_arguments): Ditto.
	* avr-tdep.c (avr_pointer_to_address): Ditto.
	(avr_push_arguments): Ditto.
	* arm-tdep.c (arm_push_dummy_call): Ditto.
	(arm_get_longjmp_target): Ditto.
	* arm-linux-tdep.c (arm_linux_push_arguments): Ditto.
	* alpha-tdep.c (alpha_extract_struct_value_address): Ditto.
	(alpha_get_longjmp_target): Ditto.
@
text
@a322 8
/* The number of arguments being passed in the frame.  */
static int
arm_frame_num_args (struct frame_info *fi)
{
  /* We have no way of knowing.  */
  return -1;
}

a2940 1
  set_gdbarch_frame_num_args (gdbarch, arm_frame_num_args);
@


1.136
log
@2003-05-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (PUSH_DUMMY_CALL): Add "func_addr" parameter.  Rename
	"dummy_addr" to "bp_addr".
	* infcall.c (call_function_by_hand): Pass "funaddr" to
	gdbarch_push_dummy_call.
	* gdbarch.h, gdbarch.c: Re-generate.
	* i386-tdep.c (i386_push_dummy_call): Update.
	* arm-tdep.c (arm_push_dummy_call): Update.
	* d10v-tdep.c (d10v_push_dummy_call): Update.
@
text
@d1468 1
a1468 1
	  CORE_ADDR regval = extract_address (val, len);
d1487 1
a1487 1
	      CORE_ADDR regval = extract_address (val, partial_len);
d2497 1
a2497 1
  *pc = extract_address (buf, INT_REGISTER_RAW_SIZE);
@


1.135
log
@2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_BYTES): Rename REGISTER_BYTES.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arm-linux-tdep.c (arm_linux_extract_return_value): Delete reference.
	* TODO (REGISTER_BYTES): Delete reference.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init_32082): Update.
	(ns32k_gdbarch_init_32382): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* i386-linux-tdep.c (i386_linux_init_abi): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* sparc-tdep.c (sparc_pop_frame): Update.
	* rs6000-tdep.c (rs6000_pop_frame): Update.
	* remote.c (init_remote_state): Update.
	(remote_prepare_to_store): Update.
	* remote-vx.c (vx_prepare_to_store): Update.
	* remote-sds.c (sds_fetch_registers): Update.
	(sds_prepare_to_store): Update.
	* remote-array.c: Update.
	* regcache.c (init_legacy_regcache_descr): Update.
	(init_regcache_descr): Update.
	* mips-tdep.c (mips_eabi_extract_return_value): Update.
	(mips_o64_extract_return_value): Update.
	* irix5-nat.c (fetch_core_registers): Update.
	* irix4-nat.c (fetch_core_registers): Update.
	* i386-tdep.h: Update.
	* hppa-tdep.c (pa_do_registers_info): Update.
	(pa_do_strcat_registers_info): Update.
	* cris-tdep.c (cris_register_bytes_ok): Update.
	* config/nm-gnu.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/sparc/nm-sun4sol2.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/nm-sun4os4.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/nm-nbsd.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/s390/tm-s390.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/pa/tm-hppa64.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-mips.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-irix6.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-irix5.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/m68k/tm-sun3.h (DEPRECATED_REGISTER_BYTES): Update.
	(REGISTER_BYTES_OK): Update.
	* config/m68k/nm-sun3.h (CHILD_PREPARE_TO_STORE): Update.
	* config/ia64/tm-ia64.h (DEPRECATED_REGISTER_BYTES): Update.

Index: doc/ChangeLog
2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	REGISTER_BYTES with DEPRECATED_REGISTER_BYTES.  Fix typo,
	DEPRECATED_REGISTER_SIZE instead of REGISTER_BYTE.

Index: mi/ChangeLog
2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (mi_setup_architecture_data):
@
text
@d1408 4
a1411 3
arm_push_dummy_call (struct gdbarch *gdbarch, struct regcache *regcache,
		     CORE_ADDR dummy_addr, int nargs, struct value **args,
		     CORE_ADDR sp, int struct_return, CORE_ADDR struct_addr)
d1418 2
a1419 2
  /* Set the return address.  For the ARM, the return breakpoint is always
     at DUMMY_ADDR.  */
d1421 1
a1421 1
  regcache_cooked_write_unsigned (regcache, ARM_LR_REGNUM, dummy_addr);
@


1.134
log
@2003-05-14  Elena Zannoni  <ezannoni@@redhat.com>

	* symtab.h (enum domain_enum): Rename from namespace_enum.
	(UNDEF_DOMAIN, VAR_DOMAIN, STRUCT_DOMAIN, LABEL_DOMAIN,
	VARIABLES_DOMAIN, FUNCTIONS_DOMAIN, TYPES_DOMAIN, METHODS_DOMAIN):
	Rename from UNDEF_NAMESPACE, VAR_NAMESPACE, STRUCT_NAMESPACE,
	LABEL_NAMESPACE, VARIABLES_NAMESPACE, FUNCTIONS_NAMESPACE,
	TYPES_NAMESPACE, METHODS_NAMESPACE.
	(SYMBOL_NAMESPACE): Rename to SYMBOL_DOMAIN.
	(struct symbol, struct partial_symbol): Rename field
	'namespace_enum namespace' to 'domain_enum domain'.
	(PSYMBOL_NAMESPACE): Rename to PSYMBOL_DOMAIN.
	Delete old define kludge for namespace.

	* ada-exp.y, ada-lang.c, ada-lang.h, alpha-tdep.c, arm-tdep.c,
	blockframe.c, c-exp.y, c-valprint.c, coffread.c, dbxread.c,
	dwarf2read.c, dwarfread.c, f-exp.y, gdbtypes.c, gdbtypes.h,
	gnu-v3-abi.c, hppa-tdep.c, hpread.c, jv-exp.y, jv-lang.c,
	language.c, linespec.c, m2-exp.y, m3-nat.c, mdebugread.c,
	mips-tdep.c, nlmread.c, objc-exp.y, objc-lang.c, objfiles.c,
	p-exp.y, p-valprint.c, parse.c, printcmd.c, scm-lang.c, source.c,
	stabsread.c, stack.c, symfile.c, symfile.h, symmisc.c, symtab.c,
	valops.c, values.c, xcoffread.c, xstormy16-tdep.c: Replace all
	occurrences of the above.

2003-05-12  Elena Zannoni  <ezannoni@@redhat.com>

	* mi-mi-cmd-stack.c (list_args_or_locals): Rename VAR_NAMESPACE to
	VAR_DOMAIN.
@
text
@d2979 4
a2982 4
  set_gdbarch_register_bytes (gdbarch,
			      (NUM_GREGS * INT_REGISTER_RAW_SIZE
			       + NUM_FREGS * FP_REGISTER_RAW_SIZE
			       + NUM_SREGS * STATUS_REGISTER_SIZE));
@


1.133
log
@2003-05-13  Andrew Cagney  <cagney@@redhat.com>

	* defs.h (store_address): Delete declaration.
	findvar.c (store_address): Delete function.
	* arm-tdep.c (arm_push_dummy_call): Replace store_address with
	store_unsigned_integer.
	* xstormy16-tdep.c (xstormy16_address_to_pointer): Ditto.
	* v850-tdep.c (v850_push_arguments): Ditto.
	* sparc-tdep.c (sparc_get_saved_register): Ditto.
	* sh-tdep.c (sh64_get_saved_register): Ditto.
	* rs6000-tdep.c (rs6000_push_arguments): Ditto.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_arguments): Ditto.
	* mips-tdep.c (mips_eabi_push_arguments): Ditto.
	(mips_get_saved_register): Ditto.
	* ia64-tdep.c (ia64_get_saved_register): Ditto.
	(find_func_descr, ia64_push_arguments): Ditto.
	* i386-tdep.c (i386_push_arguments): Ditto.
	* hpux-thread.c (hpux_thread_fetch_registers): Ditto.
	* frv-tdep.c (frv_push_arguments): Ditto.
	* frame.c (legacy_saved_regs_prev_register): Ditto.
	(deprecated_generic_get_saved_register): Ditto.
	* findvar.c (unsigned_address_to_pointer): Ditto.
	* dwarf2read.c (dwarf2_const_value): Ditto.
	* arm-linux-tdep.c (arm_linux_push_arguments): Ditto.
	* alpha-tdep.c (alpha_push_arguments): Ditto.
@
text
@d446 1
a446 1
      sym = lookup_symbol (func_name, NULL, VAR_NAMESPACE, NULL, NULL);
@


1.132
log
@2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_SIZE): Rename REGISTER_SIZE.
	(DEPRECATED_SIZEOF_CALL_DUMMY_WORDS): Rename
	SIZEOF_CALL_DUMMY_WORDS.
	(DEPRECATED_CALL_DUMMY_WORDS): Rename CALL_DUMMY_WORDS.
	(DEPRECATED_FIX_CALL_DUMMY): Rename FIX_CALL_DUMMY.
	(DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET): Rename
	CALL_DUMMY_BREAKPOINT_OFFSET.
	(DEPRECATED_CALL_DUMMY_START_OFFSET): Rename
	CALL_DUMMY_START_OFFSET.
	(DEPRECATED_CALL_DUMMY_LENGTH): Rename CALL_DUMMY_LENGTH.
	* gdbarch.h, gdbarch.c: Re-generate.
	* alpha-tdep.c, alphafbsd-tdep.c, arm-linux-tdep.c: Update.
	* arm-tdep.c, avr-tdep.c, breakpoint.c, cris-tdep.c: Update.
	* dummy-frame.c, dummy-frame.h, frv-tdep.c, gdbarch.c: Update.
	* gdbarch.h, gdbarch.sh, h8300-tdep.c, hppa-tdep.c: Update.
	* i386-tdep.c, ia64-tdep.c, infcall.c, inferior.h: Update.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c: Update.
	* mips-tdep.c, mn10300-tdep.c, ns32k-tdep.c: Update.
	* rs6000-tdep.c, s390-tdep.c, sh-tdep.c, sol-thread.c: Update.
	* sparc-tdep.c, target.c, v850-tdep.c, valops.c: Update.
	* vax-tdep.c, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/ia64/tm-ia64.h, config/m68k/tm-vx68.h: Update.
	* config/mips/tm-mips.h, config/pa/nm-hppah.h: Update.
	* config/pa/tm-hppa.h, config/pa/tm-hppa64.h: Update.
	* config/s390/tm-s390.h, config/sparc/tm-sp64.h: Update.
	* config/sparc/tm-sparc.h: Update.

Index: doc/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Make
	CALL_DUMMY_WORDS, SIZEOF_CALL_DUMMY_WORDS, CALL_DUMMY_LENGTH,
	FIX_CALL_DUMMY, CALL_DUMMY_BREAKPOINT_OFFSET and
	CALL_DUMMY_BREAKPOINT_OFFSET deprecated.

Index: mi/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (mi_cmd_data_write_register_values): Replace
	REGISTER_SIZE with DEPRECATED_REGISTER_SIZE.

Index: testsuite/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdb.base/watchpoint.exp: Rename CALL_DUMMY_BREAKPOINT_OFFSET to
	DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET in comments.
@
text
@d1471 1
a1471 1
	      store_address (val, len, MAKE_THUMB_ADDR (regval));
@


1.132.4.1
log
@Snap const char * mess.
@
text
@d1471 1
a1471 1
	      store_unsigned_integer (val, len, MAKE_THUMB_ADDR (regval));
@


1.131
log
@2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_TARGET_READ_FP): Replace TARGET_READ_FP.
	(DEPRECATED_FP_REGNUM): Replace FP_REGNUM.
	* gdbarch.h, gdbarch.c: Re-generate.
	* infcall.c (call_function_by_hand): Use DEPRECATED_FP_REGNUM,
	DEPRECATED_TARGET_READ_FP, or "sp" to create the dummy frame ID.
	* inferior.h (deprecated_read_fp): Rename read_fp.
	(generic_target_read_fp): Delete declaration.
	* regcache.c (generic_target_read_fp): Delete function.
	(deprecated_read_fp): Replace read_fp, use
	DEPRECATED_TARGET_READ_FP or DEPRECATED_FP_REGNUM.
	* d10v-tdep.c (d10v_read_fp): Delete function.
	(d10v_gdbarch_init): Do not set deprecated_read_fp.

	* sparc-tdep.c (sparc_gdbarch_init): Do not set
	deprecated_target_read_fp to generic_target_read_fp.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.

	* xstormy16-tdep.c (xstormy16_gdbarch_init): Set
	deprecated_fp_regnum.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.

	* x86-64-tdep.c (x86_64_init_abi): Set deprecated_target_read_fp.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.

	* vax-tdep.c (vax_frame_init_saved_regs): Replace FP_REGNUM with
	DEPRECATED_FP_REGNUM.
	(vax_push_dummy_frame, vax_pop_frame): Ditto.
	* std-regs.c (value_of_builtin_frame_fp_reg): Ditto.
	* sparc-tdep.c (sparc_init_extra_frame_info): Ditto.
	(sparc_push_dummy_frame, sparc64_read_fp): Ditto.
	(sparc32_register_virtual_type): Ditto.
	* sh-tdep.c (sh64_frame_chain): Ditto.
	(sh64_get_saved_register, sh64_pop_frame): Ditto.
	(sh_nofp_frame_init_saved_regs): Ditto.
	(sh64_nofp_frame_init_saved_regs): Ditto.
	(sh_fp_frame_init_saved_regs): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump): Ditto.
	* procfs.c (procfs_fetch_registers): Ditto.
	(procfs_store_registers): Ditto.
	* ns32knbsd-nat.c (fetch_inferior_registers): Ditto.
	(store_inferior_registers, fetch_core_registers): Ditto.
	(fetch_kcore_registers, clear_regs): Ditto.
	* ns32k-tdep.c (ns32k_frame_init_saved_regs): Ditto.
	(ns32k_push_dummy_frame, ns32k_pop_frame): Ditto.
	* nlm/i386.h (DEPRECATED_FP_REGNUM): Ditto.
	* nlm/i386.c (do_status): Ditto.
	* mipsv4-nat.c (supply_gregset): Ditto.
	* mips-tdep.c: Ditto for comments.
	* mips-nat.c (fetch_inferior_registers): Ditto.
	(store_inferior_registers, fetch_core_registers): Ditto.
	* m68k-tdep.c (m68k_push_dummy_frame): Ditto.
	(m68k_pop_frame, m68k_frame_init_saved_regs): Ditto.
	* i386-tdep.c (i386_frame_init_saved_regs): Ditto.
	(i386_do_pop_frame, i386_register_type): Ditto.
	* hppa-tdep.c (hppa_frame_chain): Ditto.
	(hppa_push_dummy_frame, find_dummy_frame_regs): Ditto.
	(hppa_pop_frame, hppa_read_fp): Ditto.
	(skip_prologue_hard_way, hppa_frame_find_saved_regs): Ditto.
	* cris-tdep.c (cris_examine, cris_pop_frame): Ditto.
	* config/vax/nm-vax.h (REGISTER_U_ADDR): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/sparc/tm-sp64.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/s390/tm-s390.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/pa/tm-hppa64.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/ia64/tm-ia64.h (DEPRECATED_FP_REGNUM): Ditto.
	* blockframe.c: Ditto for comments.
	* arch-utils.h: Ditto for comments.
	* arch-utils.c (legacy_virtual_frame_pointer): Ditto.
	* alphanbsd-tdep.c (fetch_core_registers): Ditto.
	* alphabsd-nat.c (fetch_inferior_registers): Ditto.
	* alpha-tdep.h: Ditto for comments.
	* alpha-tdep.c (alpha_cannot_fetch_register): Ditto.
	(alpha_cannot_store_register): Ditto.
	(alpha_push_dummy_frame): Ditto.
	* alpha-nat.c (supply_gregset): Ditto.

	* config/sparc/tm-sp64.h (DEPRECATED_TARGET_READ_FP): Update.
	* config/pa/tm-hppa64.h (DEPRECATED_TARGET_READ_FP): Update.
	* config/sparc/tm-sparc.h: Update comment.

	* hppa-tdep.c (hppa_init_extra_frame_info): Use
	deprecated_read_fp instead of TARGET_READ_FP.
	(hppa_init_extra_frame_info, hppa_frame_chain): Ditto.
	(hppa_push_dummy_frame, hppa_read_fp): Ditto.
	* sparc-tdep.c (sparc_init_extra_frame_info): Use
	deprecated_read_fp instead of read_fp.
	* s390-tdep.c (s390_push_arguments): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* frame.h: Ditto in comments.
	* frame.c (legacy_get_prev_frame): Ditto.
	* dummy-frame.c (dummy_frame_this_id): Ditto.
	* arm-tdep.c (arm_init_extra_frame_info): Ditto.

2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	read_fp, TARGET_READ_FP and FP_REGNUM, with deprecated_read_fp,
	DEPRECATED_TARGET_READ_FP and DEPRECATED_REGNUM.
@
text
@d1240 1
a1240 1
/* CALL_DUMMY_WORDS:
d1268 1
a1268 1
    set_gdbarch_call_dummy_breakpoint_offset (current_gdbarch, 4);
d1270 1
a1270 1
    set_gdbarch_call_dummy_breakpoint_offset (current_gdbarch, 8);
d1433 1
a1433 1
  sp &= ~(CORE_ADDR)(2 * REGISTER_SIZE - 1);
d1480 1
a1480 1
	  int partial_len = len < REGISTER_SIZE ? len : REGISTER_SIZE;
d1490 1
a1490 1
				    phex (regval, REGISTER_SIZE));
d1500 2
a1501 2
	      si = push_stack_item (si, val, REGISTER_SIZE);
	      nstack += REGISTER_SIZE;
d1802 1
a1802 1
      offset = bitcount (bits (inst1, 0, 7)) * REGISTER_SIZE;
d2312 4
a2315 4
     must be less than or equal to REGISTER_SIZE and the offset of
     each addressable subfield must be zero.  Note that bit fields are
     not addressable, and all addressable subfields of unions always
     start at offset zero.
d2329 1
a2329 1
  if (TYPE_LENGTH (type) > REGISTER_SIZE)
d2351 5
a2355 5
         REGISTER_SIZE and the offset of each addressable subfield
         must be zero.  Note that bit fields are not addressable, and
         unions always start at offset zero.  If any of the subfields
         is a floating point type, the struct/union cannot be an
         integer type.  */
d2933 2
a2934 2
  set_gdbarch_call_dummy_words (gdbarch, arm_call_dummy_words);
  set_gdbarch_sizeof_call_dummy_words (gdbarch, 0);
d2994 1
a2994 1
  set_gdbarch_register_size (gdbarch, 4);
@


1.130
log
@2003-04-21  Andrew Cagney  <cagney@@redhat.com>

	* infcall.c: New file.
	* infcall.h: New file.
	* valarith.c: Include "infcall.h".
	* scm-lang.c, objc-lang.cm, hppa-tdep.c, gcore.c: Ditto.
	* eval.c, ada-valprint.c, ada-lang.c: Ditto.
	* Makefile.in (valarith.o, scm-lang.o): Update dependencies.
	(objc-lang.o, hppa-tdep.o, gcore.o): Update dependencies.
	(eval.o, ada-valprint.o, ada-lang.o): Update dependencies.
	(SFILES): Add "infcall.c"
	(COMMON_OBS): Add "infcall.o".
	(infcall.o): Specify dependencies.
	* value.h (call_function_by_hand): Delete declaration.
	* inferior.h (run_stack_dummy): Delete declaration.
	* infcmd.c (breakpoint_auto_delete_contents): Move to "infcall.c".
	(run_stack_dummy): Move to "infcall.c", merged into
	call_function_by_hand.
	* valops.c (call_function_by_hand): Moved to "infcall.c".
	(find_function_addr, value_arg_coerce): Ditto.
	(unwindonsignal_p, coerce_float_to_double): Ditto.
	(_initialize_valops): Move "set/show coerce-float-to-double", and
	"set/show unwindonsignal" commands to "infcall.c".
	* v850-tdep.c, target.h: Update comments.
	* sparc-tdep.c (sparc_fix_call_dummy): Update comments.
	* sh-tdep.c (sh_init_extra_frame_info): Update comments.
	(sh64_init_extra_frame_info): Update comments.
	* mn10300-tdep.c: Update comments.
	* mcore-tdep.c (mcore_init_extra_frame_info): Update comments.
	* config/sparc/tm-sparc.h: Update comments.
	* breakpoint.h: Update comments.
	* avr-tdep.c (avr_init_extra_frame_info): Update comments.
	* arm-tdep.c: Update comment.
@
text
@d1121 1
a1121 1
	    deprecated_update_frame_base_hack (fi, read_fp ());
d2941 1
a2941 1
  set_gdbarch_read_fp (gdbarch, arm_read_fp);
d2975 1
a2975 1
  set_gdbarch_fp_regnum (gdbarch, ARM_FP_REGNUM);	/* ??? */
@


1.129
log
@2003-04-11  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_SAVED_PC_AFTER_CALL): Deprecate
	SAVED_PC_AFTER_CALL.
	* gdbarch.h, gdbarch.c: Regenerate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	(ia64_saved_pc_after_call): Update declaration.
	* i386ly-tdep.c (i386lynx_init_abi): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* ns32knbsd-nat.c (frame_num_args): Update.
	* ns32k-tdep.c (umax_frame_num_args): Update.
	* mips-tdep.c (mips_init_frame_pc_first): Update.
	* infrun.c (step_over_function): Update.
	* i386-linux-tdep.c (skip_hurd_resolver): Update.
	* i386-interix-tdep.c (i386_interix_back_one_frame): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_SAVED_PC_AFTER_CALL): Update.
	(DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/pa/tm-hppa.h (DEPRECATED_SAVED_PC_AFTER_CALL): Update.
	* arm-linux-tdep.c (skip_hurd_resolver): Update.
	* arch-utils.c (init_frame_pc_default): Update.
	* alpha-tdep.c (alpha_init_frame_pc_first): Update.
	* x86-64-tdep.h (x86_64_linux_saved_pc_after_call): Update
	declaration.
@
text
@d1260 2
a1261 2
   followed by a call to run_stack_dummy, which is the only function
   where call_dummy_breakpoint_offset is actually used.  */
@


1.129.2.1
log
@Merge from mainline.
@
text
@d1121 1
a1121 1
	    deprecated_update_frame_base_hack (fi, deprecated_read_fp ());
d1260 2
a1261 2
   followed by a call to call_function_by_hand, which is the only
   function where call_dummy_breakpoint_offset is actually used.  */
d2941 1
a2941 1
  set_gdbarch_deprecated_target_read_fp (gdbarch, arm_read_fp);
d2975 1
a2975 1
  set_gdbarch_deprecated_fp_regnum (gdbarch, ARM_FP_REGNUM);	/* ??? */
@


1.129.2.2
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d446 1
a446 1
      sym = lookup_symbol (func_name, NULL, VAR_DOMAIN, NULL, NULL);
d1240 1
a1240 1
/* DEPRECATED_CALL_DUMMY_WORDS:
d1268 1
a1268 1
    set_gdbarch_deprecated_call_dummy_breakpoint_offset (current_gdbarch, 4);
d1270 1
a1270 1
    set_gdbarch_deprecated_call_dummy_breakpoint_offset (current_gdbarch, 8);
d1433 1
a1433 1
  sp &= ~(CORE_ADDR)(2 * DEPRECATED_REGISTER_SIZE - 1);
d1471 1
a1471 1
	      store_unsigned_integer (val, len, MAKE_THUMB_ADDR (regval));
d1480 1
a1480 1
	  int partial_len = len < DEPRECATED_REGISTER_SIZE ? len : DEPRECATED_REGISTER_SIZE;
d1490 1
a1490 1
				    phex (regval, DEPRECATED_REGISTER_SIZE));
d1500 2
a1501 2
	      si = push_stack_item (si, val, DEPRECATED_REGISTER_SIZE);
	      nstack += DEPRECATED_REGISTER_SIZE;
d1802 1
a1802 1
      offset = bitcount (bits (inst1, 0, 7)) * DEPRECATED_REGISTER_SIZE;
d2312 4
a2315 4
     must be less than or equal to DEPRECATED_REGISTER_SIZE and the
     offset of each addressable subfield must be zero.  Note that bit
     fields are not addressable, and all addressable subfields of
     unions always start at offset zero.
d2329 1
a2329 1
  if (TYPE_LENGTH (type) > DEPRECATED_REGISTER_SIZE)
d2351 5
a2355 5
         DEPRECATED_REGISTER_SIZE and the offset of each addressable
         subfield must be zero.  Note that bit fields are not
         addressable, and unions always start at offset zero.  If any
         of the subfields is a floating point type, the struct/union
         cannot be an integer type.  */
d2933 2
a2934 2
  set_gdbarch_deprecated_call_dummy_words (gdbarch, arm_call_dummy_words);
  set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, 0);
d2979 4
a2982 4
  set_gdbarch_deprecated_register_bytes (gdbarch,
					 (NUM_GREGS * INT_REGISTER_RAW_SIZE
					  + NUM_FREGS * FP_REGISTER_RAW_SIZE
					  + NUM_SREGS * STATUS_REGISTER_SIZE));
d2994 1
a2994 1
  set_gdbarch_deprecated_register_size (gdbarch, 4);
@


1.128
log
@2003-04-06  Andrew Cagney  <cagney@@redhat.com>

	* arm-tdep.c (arm_frameless_function_invocation): Fix typo.
@
text
@d2964 1
a2964 1
  set_gdbarch_saved_pc_after_call (gdbarch, arm_saved_pc_after_call);
@


1.127
log
@2003-04-05  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (frame_func_unwind, get_frame_func): New functions.
	* frame.h (get_frame_func, frame_func_unwind): Declare.
	(struct frame_info): Add field "prev_func" for caching the
	previous frame's function address.
	* arm-tdep.c (arm_frameless_function_invocation): Combine
	get_pc_function_start and get_frame_pc into get_frame_func.
	* sh-tdep.c (sh_nofp_frame_init_saved_regs): Ditto.
	(sh64_nofp_frame_init_saved_regs): Ditto.
	* s390-tdep.c (s390_function_start): Ditto.
	* rs6000-tdep.c (rs6000_pop_frame): Ditto.
	(rs6000_frameless_function_invocation): Ditto.
	(rs6000_frame_saved_pc): Ditto.
	* m68k-tdep.c (m68k_frame_init_saved_regs): Ditto.
	* ia64-tdep.c (ia64_frame_init_saved_regs): Ditto.
	* i386-tdep.c (i386_frameless_signal_p): Ditto.
	(i386_frame_init_saved_regs): Ditto.
	* hppa-tdep.c (hppa_frame_find_saved_regs): Ditto.
	* d10v-tdep.c (d10v_frame_unwind_cache): Combine
	get_pc_function_start and frame_pc_unwind into frame_func_unwind.
	* cris-tdep.c (cris_frame_init_saved_regs): Ditto.
	* blockframe.c (frameless_look_for_prologue): Ditto.
@
text
@d298 1
a298 1
  func_start = (get_frame_func (fi)) + FUNCTION_START_OFFSET);
@


1.126
log
@* arm-tdep.c (push_stack_item): Use xmalloc.
@
text
@d298 1
a298 1
  func_start = (get_pc_function_start (get_frame_pc (fi)) + FUNCTION_START_OFFSET);
@


1.125
log
@2003-04-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_START_OFFSET): Default to zero.
	CALL_DUMMY_LENGTH): Ditto.
	* gdbarch.c: Re-generate.
	* inferior.h (CALL_DUMMY_START_OFFSET): Delete macro.
	(CALL_DUMMY_LENGTH): Delete macro.
	* alpha-tdep.c (alpha_gdbarch_init): Do not set above when zero.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
@
text
@d1386 1
a1386 1
  si->data = malloc (len);
@


1.125.2.1
log
@Merge with mainline.
@
text
@d298 1
a298 1
  func_start = (get_frame_func (fi) + FUNCTION_START_OFFSET);
d1386 1
a1386 1
  si->data = xmalloc (len);
@


1.124
log
@2003-04-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_BREAKPOINT_OFFSET): Default to zero.
	(CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* config/sparc/tm-sp64.h (CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	(CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	* config/pa/tm-hppa64.h (CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	* inferior.h (CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	(CALL_DUMMY_BREAKPOINT_OFFSET): Delete.
	* infcmd.c (run_stack_dummy): Simplify assuming
	CALL_DUMMY_BREAKPOINT_OFFSET_P.
	* infrun.c (handle_inferior_event): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Do not set
	call_dummy_breakpoint_offset or call_dummy_breakpoint_offset_p.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
@
text
@a2934 2
  set_gdbarch_call_dummy_start_offset (gdbarch, 0);
  set_gdbarch_call_dummy_length (gdbarch, 0);
@


1.123
log
@2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FIX_CALL_DUMMY): Change to function with predicate.
	* gdbarch.h, gdbarch.c: Regenerate.
	* inferior.h (FIX_CALL_DUMMY): Delete macro.
	* valops.c (hand_function_call): Only call FIX_CALL_DUMMY when
	available.
	* frame.h (generic_fix_call_dummy): Delete declaration.
	* dummy-frame.h: Update comment.
	* dummy-frame.c (generic_fix_call_dummy): Delete function.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	fix_call_dummy.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
@
text
@a2932 3
  set_gdbarch_call_dummy_breakpoint_offset_p (gdbarch, 1);
  set_gdbarch_call_dummy_breakpoint_offset (gdbarch, 0);

@


1.122
log
@2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Include "symfile.h".
	(CALL_DUMMY_ADDRESS): Default to entry_point_address.
	* gdbarch.h, gdbarch.c: Re-generate.
	* inferior.h (CALL_DUMMY_ADDRESS): Delete macro.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	call_dummy_address, the default is at entry_point_address.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
@
text
@a2940 2
  set_gdbarch_fix_call_dummy (gdbarch, generic_fix_call_dummy);

@


1.121
log
@2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_P): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* inferior.h (CALL_DUMMY_P): Delete macro.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* breakpoint.c (deprecated_frame_in_dummy): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* dummy-frame.c (dummy_frame_this_id): Update comments.
	* rs6000-tdep.c (rs6000_extract_struct_value_address): Ditto.
	* frame.c (legacy_get_prev_frame): Ditto.
	* valops.c (call_function_by_hand): Delete function.
	(hand_function_call): Rename to call_function_by_hand

2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	references to CALL_DUMMY_P.
@
text
@a2942 2
  set_gdbarch_call_dummy_address (gdbarch, entry_point_address);

@


1.120
log
@2003-03-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_DUMMY_WRITE_SP): Replace TARGET_WRITE_SP.
	* gdbarch.h, gdbarch.c: Regenerate.
	* v850-tdep.c (v850_gdbarch_init): Set deprecated_dummy_write_sp.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_push_dummy_frame, sparc_pop_frame): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_DUMMY_WRITE_SP): Update.
	* config/pa/tm-hppa.h (DEPRECATED_DUMMY_WRITE_SP): Define.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* valops.c (hand_function_call): Replace TARGET_WRITE_SP with
	DEPRECATED_DUMMY_WRITE_SP.  Call when the method is available,
	instead of when push_dummy_call is not available.

2003-03-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Remove
	reference to TARGET_WRITE_SP.
@
text
@a2935 2
  set_gdbarch_call_dummy_p (gdbarch, 1);

@


1.119
log
@2003-03-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_PUSH_RETURN_ADDRESS): Replace
	PUSH_RETURN_ADDRESS.
	* gdbarch.h, gdbarch.c: Regenerate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* valops.c (hand_function_call): Update.
@
text
@a2945 1
  set_gdbarch_deprecated_push_return_address (gdbarch, arm_push_return_address);
@


1.118
log
@* arm-tdep.c (arm_push_arguments): Delete.
(struct stack_item): New type.
(push_stack_item, pop_stack_item, arm_push_dummy_call): New functions.
(arm_store_struct_return): Delte.
(arm_gdbarch_init): Register arm_push_dummy_call.  Don't register
arm_push_arguments or arm_store_struct_return.
@
text
@d2946 2
a2947 1
  set_gdbarch_push_return_address (gdbarch, arm_push_return_address);
@


1.117
log
@2003-03-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_PUSH_ARGUMENTS): Rename PUSH_ARGUMENTS.
	(push_dummy_call): New pure multi-arch replacement with gdbarch,
	regcache and dummy_addr parameters.
	* gdbarch.h, gdbarch.c: Re-generate.
	* valops.c (hand_function_call): Use gdbarch_push_dummy_call when
	available; assume it will handle stack alignment and return
	address issues.  Fall back to DEPRECATED_PUSH_ARGUMENTS and
	legacy_push_arguments.
	(legacy_push_arguments): Rename default_push_arguments.
	* value.h (legacy_push_arguments): Rename default_push_arguments.
	* i386-tdep.c (i386_push_arguments): Call legacy_push_arguments.
	* config/sparc/tm-sparc.h (DEPRECATED_PUSH_ARGUMENTS): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_PUSH_ARGUMENTS): Update.
	* config/pa/tm-hppa.h (DEPRECATED_PUSH_ARGUMENTS): Update.
	* config/i386/tm-symmetry.h: Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* arm-linux-tdep.c (arm_linux_init_abi): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

2003-03-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	PUSH_ARGUMENTS with push_dummy_call, add gdbarch, regcache and
	dummy_addr parameters.
@
text
@a1336 131
/* Note: ScottB

   This function does not support passing parameters using the FPA
   variant of the APCS.  It passes any floating point arguments in the
   general registers and/or on the stack.  */

static CORE_ADDR
arm_push_arguments (int nargs, struct value **args, CORE_ADDR sp,
		    int struct_return, CORE_ADDR struct_addr)
{
  CORE_ADDR fp;
  int argnum;
  int argreg;
  int nstack;
  int simd_argreg;
  int second_pass;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  /* Walk through the list of args and determine how large a temporary
     stack is required.  Need to take care here as structs may be
     passed on the stack, and we have to to push them.  On the second
     pass, do the store.  */
  nstack = 0;
  fp = sp;
  for (second_pass = 0; second_pass < 2; second_pass++)
    {
      /* Compute the FP using the information computed during the
         first pass.  */
      if (second_pass)
	fp = sp - nstack;

      simd_argreg = 0;
      argreg = ARM_A1_REGNUM;
      nstack = 0;

      /* The struct_return pointer occupies the first parameter
	 passing register.  */
      if (struct_return)
	{
	  if (second_pass)
	    {
	      if (arm_debug)
		fprintf_unfiltered (gdb_stdlog,
				    "struct return in %s = 0x%s\n",
				    REGISTER_NAME (argreg),
				    paddr (struct_addr));
	      write_register (argreg, struct_addr);
	    }
	  argreg++;
	}

      for (argnum = 0; argnum < nargs; argnum++)
	{
	  int len;
	  struct type *arg_type;
	  struct type *target_type;
	  enum type_code typecode;
	  char *val;
	  
	  arg_type = check_typedef (VALUE_TYPE (args[argnum]));
	  len = TYPE_LENGTH (arg_type);
	  target_type = TYPE_TARGET_TYPE (arg_type);
	  typecode = TYPE_CODE (arg_type);
	  val = VALUE_CONTENTS (args[argnum]);
	  
	  /* If the argument is a pointer to a function, and it is a
	     Thumb function, create a LOCAL copy of the value and set
	     the THUMB bit in it.  */
	  if (second_pass
	      && TYPE_CODE_PTR == typecode
	      && target_type != NULL
	      && TYPE_CODE_FUNC == TYPE_CODE (target_type))
	    {
	      CORE_ADDR regval = extract_address (val, len);
	      if (arm_pc_is_thumb (regval))
		{
		  val = alloca (len);
		  store_address (val, len, MAKE_THUMB_ADDR (regval));
		}
	    }

	  /* Copy the argument to general registers or the stack in
	     register-sized pieces.  Large arguments are split between
	     registers and stack.  */
	  while (len > 0)
	    {
	      int partial_len = len < REGISTER_SIZE ? len : REGISTER_SIZE;
	      
	      if (argreg <= ARM_LAST_ARG_REGNUM)
		{
		  /* The argument is being passed in a general purpose
		     register.  */
		  if (second_pass)
		    {
		      CORE_ADDR regval = extract_address (val,
							  partial_len);
		      if (arm_debug)
			fprintf_unfiltered (gdb_stdlog,
					    "arg %d in %s = 0x%s\n",
					    argnum,
					    REGISTER_NAME (argreg),
					    phex (regval, REGISTER_SIZE));
		      write_register (argreg, regval);
		    }
		  argreg++;
		}
	      else
		{
		  if (second_pass)
		    {
		      /* Push the arguments onto the stack.  */
		      if (arm_debug)
			fprintf_unfiltered (gdb_stdlog,
					    "arg %d @@ 0x%s + %d\n",
					    argnum, paddr (fp), nstack);
		      write_memory (fp + nstack, val, REGISTER_SIZE);
		    }
		  nstack += REGISTER_SIZE;
		}
	      
	      len -= partial_len;
	      val += partial_len;
	    }

	}
    }

  /* Return the bottom of the argument list (pointed to by fp).  */
  return fp;
}

d1371 155
a2482 9
/* Store the address of the place in which to copy the structure the
   subroutine will return.  This is called from call_function.  */

static void
arm_store_struct_return (CORE_ADDR addr, CORE_ADDR sp)
{
  write_register (ARM_A1_REGNUM, addr);
}

d2947 1
a2947 2

  set_gdbarch_deprecated_push_arguments (gdbarch, arm_push_arguments);
a3010 1
  set_gdbarch_deprecated_store_struct_return (gdbarch, arm_store_struct_return);
@


1.116
log
@2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_STORE_STRUCT_RETURN): Replace
	STORE_STRUCT_RETURN.
	* gdbarch.h, gdbarch.c: Regenerate.
	* d10v-tdep.c (d10v_store_struct_return): Delete function.
	(d10v_push_arguments): Set the struct return register.
	(d10v_gdbarch_init): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
@
text
@d2933 1
a2933 1
  set_gdbarch_push_arguments (gdbarch, arm_push_arguments);
@


1.116.2.1
log
@Merge with mainline.
@
text
@d1337 131
a1501 155
/* When arguments must be pushed onto the stack, they go on in reverse
   order.  The code below implements a FILO (stack) to do this.  */

struct stack_item
{
  int len;
  struct stack_item *prev;
  void *data;
};

static struct stack_item *
push_stack_item (struct stack_item *prev, void *contents, int len)
{
  struct stack_item *si;
  si = xmalloc (sizeof (struct stack_item));
  si->data = malloc (len);
  si->len = len;
  si->prev = prev;
  memcpy (si->data, contents, len);
  return si;
}

static struct stack_item *
pop_stack_item (struct stack_item *si)
{
  struct stack_item *dead = si;
  si = si->prev;
  xfree (dead->data);
  xfree (dead);
  return si;
}

/* We currently only support passing parameters in integer registers.  This
   conforms with GCC's default model.  Several other variants exist and
   we should probably support some of them based on the selected ABI.  */

static CORE_ADDR
arm_push_dummy_call (struct gdbarch *gdbarch, struct regcache *regcache,
		     CORE_ADDR dummy_addr, int nargs, struct value **args,
		     CORE_ADDR sp, int struct_return, CORE_ADDR struct_addr)
{
  int argnum;
  int argreg;
  int nstack;
  struct stack_item *si = NULL;

  /* Set the return address.  For the ARM, the return breakpoint is always
     at DUMMY_ADDR.  */
  /* XXX Fix for Thumb.  */
  regcache_cooked_write_unsigned (regcache, ARM_LR_REGNUM, dummy_addr);

  /* Walk through the list of args and determine how large a temporary
     stack is required.  Need to take care here as structs may be
     passed on the stack, and we have to to push them.  */
  nstack = 0;

  argreg = ARM_A1_REGNUM;
  nstack = 0;

  /* Some platforms require a double-word aligned stack.  Make sure sp
     is correctly aligned before we start.  We always do this even if
     it isn't really needed -- it can never hurt things.  */
  sp &= ~(CORE_ADDR)(2 * REGISTER_SIZE - 1);

  /* The struct_return pointer occupies the first parameter
     passing register.  */
  if (struct_return)
    {
      if (arm_debug)
	fprintf_unfiltered (gdb_stdlog, "struct return in %s = 0x%s\n",
			    REGISTER_NAME (argreg), paddr (struct_addr));
      regcache_cooked_write_unsigned (regcache, argreg, struct_addr);
      argreg++;
    }

  for (argnum = 0; argnum < nargs; argnum++)
    {
      int len;
      struct type *arg_type;
      struct type *target_type;
      enum type_code typecode;
      char *val;

      arg_type = check_typedef (VALUE_TYPE (args[argnum]));
      len = TYPE_LENGTH (arg_type);
      target_type = TYPE_TARGET_TYPE (arg_type);
      typecode = TYPE_CODE (arg_type);
      val = VALUE_CONTENTS (args[argnum]);

      /* If the argument is a pointer to a function, and it is a
	 Thumb function, create a LOCAL copy of the value and set
	 the THUMB bit in it.  */
      if (TYPE_CODE_PTR == typecode
	  && target_type != NULL
	  && TYPE_CODE_FUNC == TYPE_CODE (target_type))
	{
	  CORE_ADDR regval = extract_address (val, len);
	  if (arm_pc_is_thumb (regval))
	    {
	      val = alloca (len);
	      store_address (val, len, MAKE_THUMB_ADDR (regval));
	    }
	}

      /* Copy the argument to general registers or the stack in
	 register-sized pieces.  Large arguments are split between
	 registers and stack.  */
      while (len > 0)
	{
	  int partial_len = len < REGISTER_SIZE ? len : REGISTER_SIZE;

	  if (argreg <= ARM_LAST_ARG_REGNUM)
	    {
	      /* The argument is being passed in a general purpose
		 register.  */
	      CORE_ADDR regval = extract_address (val, partial_len);
	      if (arm_debug)
		fprintf_unfiltered (gdb_stdlog, "arg %d in %s = 0x%s\n",
				    argnum, REGISTER_NAME (argreg),
				    phex (regval, REGISTER_SIZE));
	      regcache_cooked_write_unsigned (regcache, argreg, regval);
	      argreg++;
	    }
	  else
	    {
	      /* Push the arguments onto the stack.  */
	      if (arm_debug)
		fprintf_unfiltered (gdb_stdlog, "arg %d @@ sp + %d\n",
				    argnum, nstack);
	      si = push_stack_item (si, val, REGISTER_SIZE);
	      nstack += REGISTER_SIZE;
	    }
	      
	  len -= partial_len;
	  val += partial_len;
	}
    }
  /* If we have an odd number of words to push, then decrement the stack
     by one word now, so first stack argument will be dword aligned.  */
  if (nstack & 4)
    sp -= 4;

  while (si)
    {
      sp -= si->len;
      write_memory (sp, si->data, si->len);
      si = pop_stack_item (si);
    }

  /* Finally, update teh SP register.  */
  regcache_cooked_write_unsigned (regcache, ARM_SP_REGNUM, sp);

  return sp;
}

d2459 9
d2931 1
d2933 1
a2933 1
  set_gdbarch_push_dummy_call (gdbarch, arm_push_dummy_call);
d2997 1
@


1.115
log
@2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_STACK_ADJUST_P): Delete.
	(DEPRECATED_CALL_DUMMY_STACK_ADJUST): Replace
	CALL_DUMMY_STACK_ADJUST with a predicate variable.
	* gdbarch.h, gdbarch.c: Regenerate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	call_dummy_stack_adjust_p.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
	* config/sparc/tm-sp64.h (CALL_DUMMY_STACK_ADJUST): Update.
	* config/sparc/tm-sparc.h (CALL_DUMMY_STACK_ADJUST): Update.
	* config/sparc/tm-sp64.h (CALL_DUMMY_STACK_ADJUST): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.  Do not set
	call_dummy_stack_adjust_p.
	* inferior.h (CALL_DUMMY_STACK_ADJUST_P): Delete macro.
	(CALL_DUMMY_STACK_ADJUST): Delete macro.
	* sparc-tdep.c (sparc32_push_arguments): Update.
	* valops.c (hand_function_call): Update.

2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	reference to CALL_DUMMY_STACK_ADJUST_P.  Rename
	CALL_DUMMY_STACK_ADJUST to DEPRECATED_CALL_DUMMY_STACK_ADJUST.
	Add reference to PUSH_ARGUMENTS.
@
text
@d2997 1
a2997 1
  set_gdbarch_store_struct_return (gdbarch, arm_store_struct_return);
@


1.114
log
@PR cli/548
* arm-tdep.c (_initialize_arm_tdep): Command is "set arm disassembler".
@
text
@a2921 1
  set_gdbarch_call_dummy_stack_adjust_p (gdbarch, 0);
@


1.113
log
@* arm-tdep.c (arm_gdbarch_init): Register the disassembler function.
(_initialize_arm_tdep): Don't set tm_print_insn.
@
text
@d3167 1
a3167 1
  new_set = add_set_enum_cmd ("disassembly", no_class,
@


1.112
log
@Index: ChangeLog
2003-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_CHAIN): Replace FRAME_CHAIN.
	(DEPRECATED_FRAME_CHAIN_VALID): Replace FRAME_CHAIN_VALID.
	* gdbarch.h, gdbarch.c: Regenerate.
	* valops.c (hand_function_call): Update.
	* objfiles.h (DEPRECATED_FRAME_CHAIN_VALID): Update.
	* frame.c (legacy_saved_regs_this_id): Update.
	(legacy_get_prev_frame, get_prev_frame, legacy_frame_p): Update.
	* dummy-frame.h: Update.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/pa/tm-hppa.h (DEPRECATED_FRAME_CHAIN_VALID): Update.
	* config/m68k/tm-vx68.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/m68k/tm-os68k.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/m68k/tm-sun3.h: Update.
	* blockframe.c (inside_main_func, frame_chain_valid): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_frame_chain, sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_frame_saved_pc): Update.
	(rs6000_gdbarch_init, rs6000_frame_saved_pc): Update.
	(frame_get_saved_regs): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_frame_num_args, i386_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	(i386_interix_back_one_frame): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	(hppa_init_extra_frame_info): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

Index: doc/ChangeLog
2003-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Algorithms, Target Architecture Definition):
	Deprecate FRAME_CHAIN and FRAME_CHAIN_VALID.
@
text
@d3007 3
a3106 2

  tm_print_insn = gdb_print_insn_arm;
@


1.111
log
@* arm-tdep.h (arm_float_model): Add AUTO and LAST values.
(arm_get_fp_model): Declare.
* arm-tdep.c (fp_model_strings): New string array.
(arm_fp_model, current_fp_model): New variables.
(arm_get_fp_model): New function.
(arm_set_fp): New function.
(set_fp_model_sfunc): New function.
(show_fp_model): New function.
(_initialize_arm_tdep): Add new command to set/show the FPU.
(arm_extract_return_value): Use arm_get_fp_model.
(arm_store_return_value): Likewise.
(arm_gdbarch_init): Default fpa model is softfpa.  Call arm_set_fp
to initialize the floating-point data types.
* arm-linux-tdep.c (arm_linux_init_abi): The default floating point
model is FPA.
@
text
@d2937 1
a2937 1
  set_gdbarch_frame_chain_valid (gdbarch, arm_frame_chain_valid);
d2940 1
a2940 1
  set_gdbarch_frame_chain (gdbarch, arm_frame_chain);
@


1.110
log
@* arm-tdep.c (show_arm_command): Don't print out help.  Instead, show
the current setting of each value.
(_initialize_arm_tdep): Delete variable new_cmd and add new vars
new_set and new_show.  Use add_setshow_cmd_full and
add_setshow_boolean_cmd as appropriate.  Deprecate "set/show apcs32"
commands and add new version as subcommands of "set/show arm".
@
text
@d106 15
d2188 1
a2188 3
      struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

      switch (tdep->fp_model)
d2203 1
a2203 1
	case ARM_FLOAT_SOFT:
a2380 1
      struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d2383 1
a2383 1
      switch (tdep->fp_model)
d2391 1
a2391 1
	case ARM_FLOAT_SOFT:
d2548 63
d2882 4
a2885 2
  /* This is the way it has always defaulted.  */
  tdep->fp_model = ARM_FLOAT_FPA;
d3033 1
a3033 14
      if (tdep->fp_model == ARM_FLOAT_VFP
	  || tdep->fp_model == ARM_FLOAT_SOFT_VFP)
	{
	  set_gdbarch_double_format (gdbarch, &floatformat_ieee_double_little);
	  set_gdbarch_long_double_format (gdbarch,
					  &floatformat_ieee_double_little);
	}
      else
	{
	  set_gdbarch_double_format
	    (gdbarch, &floatformat_ieee_double_littlebyte_bigword);
	  set_gdbarch_long_double_format
	    (gdbarch, &floatformat_ieee_double_littlebyte_bigword);
	}
d3170 1
d3189 13
@


1.109
log
@* arm-tdep.c (setarmcmdlist, showarmcmdlist): New command lists.
(set_arm_command, show_arm_command): New functions.
(_initialize_arm_tdep): Add them.
(num_disassembly_options): Renamed from num_flavor_options.
(valid_disassembly_styles): Renamed from valid_flavors.
(disassembly_style): Renamed from disassembly_flavor.
(set_disassembly_style_sfunc): Renamed from
set_disassembly_flavor_sfunc.
(set_disassembly_style): Renamed from set_disassembly_flavor.
(arm_othernames): Updated.
(_initialize_arm_tdep): Deprecate "set/show disassembly-flavor"
command.  Add "set/show arm disassembly" commands.  Deprecate
"othernames" command.
@
text
@d2533 1
a2533 1
  help_list (showarmcmdlist, "show arm ", all_commands, gdb_stdout);
d3018 1
a3018 1
  struct cmd_list_element *new_cmd;
d3091 1
a3091 1
  new_cmd = add_set_enum_cmd ("disassembly-flavor", no_class,
d3096 3
a3098 3
  set_cmd_sfunc (new_cmd, set_disassembly_style_sfunc);
  deprecate_cmd (new_cmd, "set arm disassembly");
  deprecate_cmd (add_show_from_set (new_cmd, &showlist),
d3102 22
a3123 10
  new_cmd = add_set_enum_cmd ("disassembly", no_class, valid_disassembly_styles,
			      &disassembly_style, helptext, &setarmcmdlist);

  add_show_from_set (new_cmd, &showarmcmdlist);

  /* ??? Maybe this should be a boolean.  */
  add_show_from_set (add_set_cmd ("apcs32", no_class,
				  var_zinteger, (char *) &arm_apcs_32,
				  "Set usage of ARM 32-bit mode.\n", &setlist),
		     &showlist);
d3131 7
a3137 4
  add_show_from_set (add_set_cmd ("arm", class_maintenance, var_zinteger,
				  &arm_debug, "Set arm debugging.\n"
				  "When non-zero, arm specific debugging is enabled.",
				  &setdebuglist), &showdebuglist);
@


1.108
log
@* arm-tdep.c (prologue_cache): Delete.
(check_prologue_cache, save_prologue_cache): Delete.
(arm_scan_prologue): Don't check or update the prologue_cache.
(arm_gdb_arch_init): Don't initialize it.
(_initialize_arm_tdep): Likewise.
@
text
@d31 1
a31 1
#include "dis-asm.h"		/* For register flavors. */
d102 4
d107 1
a107 1
static int num_flavor_options;
d125 2
a126 2
/* Valid register name flavors.  */
static const char **valid_flavors;
d128 2
a129 2
/* Disassembly flavor to use. Default to "std" register names.  */
static const char *disassembly_flavor;
d134 2
a135 2
   flavor.  */
static void set_disassembly_flavor_sfunc(char *, int,
d137 1
a137 1
static void set_disassembly_flavor (void);
d2523 17
a2539 4
/* If the user changes the register disassembly flavor used for info
   register and other commands, we have to also switch the flavor used
   in opcodes for disassembly output.  This function is run in the set
   disassembly_flavor command, and does that.  */
d2542 1
a2542 1
set_disassembly_flavor_sfunc (char *args, int from_tty,
d2545 1
a2545 1
  set_disassembly_flavor ();
d2556 1
a2556 1
set_disassembly_flavor (void)
d2561 1
a2561 1
  /* Find the flavor that the user wants in the opcodes table.  */
d2564 2
a2565 2
  while ((disassembly_flavor != setname)
	 && (current < num_flavor_options))
d2589 2
a2590 4
/* arm_othernames implements the "othernames" command.  This is kind
   of hacky, and I prefer the set-show disassembly-flavor which is
   also used for the x86 gdb.  I will keep this around, however, in
   case anyone is actually using it.  */
d2596 1
a2596 1
  current_option = (current_option + 1) % num_flavor_options;
d2598 2
a2599 2
  disassembly_flavor = valid_flavors[current_option];
  set_disassembly_flavor ();
d3044 10
a3053 1
  num_flavor_options = get_arm_regname_num_options ();
d3060 2
a3061 2
  fprintf_unfiltered (stb, "Set the disassembly flavor.\n\
The valid values are:\n");
d3064 3
a3066 2
  valid_flavors = xmalloc ((num_flavor_options + 1) * sizeof (char *));
  for (i = 0; i < num_flavor_options; i++)
d3069 1
a3069 1
      valid_flavors[i] = setname;
d3075 1
a3075 1
          disassembly_flavor = setname;
d3083 1
a3083 1
  valid_flavors[num_flavor_options] = NULL;
d3090 1
a3090 1
  /* Add the disassembly-flavor command.  */
d3092 2
a3093 2
			      valid_flavors,
			      &disassembly_flavor,
d3096 10
a3105 2
  set_cmd_sfunc (new_cmd, set_disassembly_flavor_sfunc);
  add_show_from_set (new_cmd, &showlist);
d3114 3
a3116 3

  add_com ("othernames", class_obscure, arm_othernames,
	   "Switch to the next set of register names.");
d3120 3
a3122 3
				  &arm_debug, "Set arm debugging.\n\
When non-zero, arm specific debugging is enabled.", &setdebuglist),
		     &showdebuglist);
@


1.107
log
@2003-03-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_POP_FRAME): Replace POP_FRAME.
	* gdbarch.h, gdbarch.c: Regenerate.
	* valops.c (hand_function_call): Update comment.
	* stack.c (return_command): Update comment.
	* config/sparc/tm-sparc.h (DEPRECATED_POP_FRAME): Update.
	* config/pa/tm-hppa.h (DEPRECATED_POP_FRAME): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

2003-03-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	POP_FRAME with DEPRECATED_POP_FRAME.  Update description.
@
text
@a644 54
/* Check if prologue for this frame's PC has already been scanned.  If
   it has, copy the relevant information about that prologue and
   return non-zero.  Otherwise do not copy anything and return zero.

   The information saved in the cache includes:
   * the frame register number;
   * the size of the stack frame;
   * the offsets of saved regs (relative to the old SP); and
   * the offset from the stack pointer to the frame pointer

   The cache contains only one entry, since this is adequate for the
   typical sequence of prologue scan requests we get.  When performing
   a backtrace, GDB will usually ask to scan the same function twice
   in a row (once to get the frame chain, and once to fill in the
   extra frame information).  */

static struct frame_info *prologue_cache;

static int
check_prologue_cache (struct frame_info *fi)
{
  int i;

  if (get_frame_pc (fi) == get_frame_pc (prologue_cache))
    {
      get_frame_extra_info (fi)->framereg = get_frame_extra_info (prologue_cache)->framereg;
      get_frame_extra_info (fi)->framesize = get_frame_extra_info (prologue_cache)->framesize;
      get_frame_extra_info (fi)->frameoffset = get_frame_extra_info (prologue_cache)->frameoffset;
      for (i = 0; i < NUM_REGS + NUM_PSEUDO_REGS; i++)
	get_frame_saved_regs (fi)[i] = get_frame_saved_regs (prologue_cache)[i];
      return 1;
    }
  else
    return 0;
}


/* Copy the prologue information from fi to the prologue cache.  */

static void
save_prologue_cache (struct frame_info *fi)
{
  int i;

  deprecated_update_frame_pc_hack (prologue_cache, get_frame_pc (fi));
  get_frame_extra_info (prologue_cache)->framereg = get_frame_extra_info (fi)->framereg;
  get_frame_extra_info (prologue_cache)->framesize = get_frame_extra_info (fi)->framesize;
  get_frame_extra_info (prologue_cache)->frameoffset = get_frame_extra_info (fi)->frameoffset;

  for (i = 0; i < NUM_REGS + NUM_PSEUDO_REGS; i++)
    get_frame_saved_regs (prologue_cache)[i] = get_frame_saved_regs (fi)[i];
}


a718 4
  /* Check if this function is already in the cache of frame information.  */
  if (check_prologue_cache (fi))
    return;

a727 1
      save_prologue_cache (fi);
a918 2

  save_prologue_cache (fi);
a2961 16
  /* We can't use SIZEOF_FRAME_SAVED_REGS here, since that still
     references the old architecture vector, not the one we are
     building here.  */
  if (get_frame_saved_regs (prologue_cache) != NULL)
    xfree (get_frame_saved_regs (prologue_cache));

  /* We can't use NUM_REGS nor NUM_PSEUDO_REGS here, since that still
     references the old architecture vector, not the one we are
     building here.  */
  {
    CORE_ADDR *saved_regs = xcalloc (1, (sizeof (CORE_ADDR)
					 * (gdbarch_num_regs (gdbarch)
					    + gdbarch_num_pseudo_regs (gdbarch))));
    deprecated_set_frame_saved_regs_hack (prologue_cache, saved_regs);
  }

a3083 4

  /* Allocate the prologue_cache.  */
  prologue_cache = deprecated_frame_xmalloc ();
  deprecated_set_frame_extra_info_hack (prologue_cache, xcalloc (1, sizeof (struct frame_extra_info)));
@


1.106
log
@2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_SAVED_PC): Replace FRAME_SAVED_PC.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.h: Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* sh-tdep.c (sh_init_extra_frame_info): Update.
	(sh64_init_extra_frame_info): Update.
	* ns32knbsd-nat.c (frame_num_args): Update.
	* m68hc11-tdep.c (m68hc11_init_extra_frame_info): Update.
	* xstormy16-tdep.c (xstormy16_pop_frame): Update.
	(xstormy16_frame_chain_valid): Update.
	* vax-tdep.c (vax_saved_pc_after_call): Update.
	* v850-tdep.c (v850_frame_chain): Update.
	(v850_pop_frame): Update.
	(v850_init_extra_frame_info): Update.
	* sparc-tdep.c (setup_arbitrary_frame): Update.
	* ns32k-tdep.c (umax_frame_num_args): Update.
	* s390-tdep.c (s390_pop_frame_regular): Update.
	* mn10300-tdep.c (mn10300_frame_chain): Update.
	(mn10300_pop_frame_regular): Update.
	(mn10300_init_extra_frame_info): Update.
	* mips-tdep.c (mips_init_frame_pc_first): Update.
	(mips_frame_chain): Update.
	(mips_pop_frame): Update.
	* mcore-tdep.c (mcore_frame_chain): Update.
	(mcore_pop_frame): Update.
	(mcore_init_extra_frame_info): Update.
	* arch-utils.c (init_frame_pc_default): Update.
	* m68k-tdep.c (isi_frame_num_args): Update.
	(delta68_frame_num_args): Update.
	(news_frame_num_args): Update.
	* ia64-tdep.c (ia64_pop_frame_regular): Update.
	* alpha-tdep.c (alpha_init_frame_pc_first): Update.
	(alpha_frame_chain): Update.
	(alpha_pop_frame): Update.
	* hppa-tdep.c (hppa_saved_pc_after_call): Update.
	(hppa_init_extra_frame_info): Update.
	(hppa_frame_chain): Update.
	(hppa_frame_chain_valid): Update.
	* cris-tdep.c (cris_init_extra_frame_info): Update.
	* avr-tdep.c (avr_init_extra_frame_info): Update.
	* arm-tdep.c (arm_frame_chain_valid): Update.
	(arm_init_extra_frame_info): Update.
	(arm_pop_frame): Update.
	* frame.c (frame_pc_unwind): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_SAVED_PC): Update.
	(DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/pa/tm-hppa.h (DEPRECATED_FRAME_SAVED_PC): Update.
	* config/m68k/tm-delta68.h (DEPRECATED_FRAME_SAVED_PC): Update.
	* config/m68k/tm-linux.h (DEPRECATED_FRAME_SAVED_PC): Update.

2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	FRAME_SAVED_PC to DEPRECATED_FRAME_SAVED_PC.
@
text
@d2918 1
a2918 1
  set_gdbarch_pop_frame (gdbarch, arm_pop_frame);
@


1.105
log
@2003-03-03  Andrew Cagney  <cagney@@redhat.com>

	Make MAX_REGISTER_RAW_SIZE and MAX_REGISTER_VIRTUAL_SIZE optional.
	* gdbarch.sh (DEPRECATED_MAX_REGISTER_RAW_SIZE): Variable with
	predicate.  Replace MAX_REGISTER_RAW_SIZE.
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Ditto for
	MAX_REGISTER_VIRTUAL_SIZE.
	* regcache.c (legacy_max_register_raw_size): New function.
	(legacy_max_register_virtual_size): New function.
	* defs.h (MAX_REGISTER_VIRTUAL_SIZE): Define.
	(MAX_REGISTER_RAW_SIZE): Define.
	(legacy_max_register_raw_size): Declare.
	(legacy_max_register_virtual_size): Declare.
	* config/sparc/tm-sparc.h (DEPRECATED_MAX_REGISTER_RAW_SIZE)
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_MAX_REGISTER_RAW_SIZE)
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Ditto.
	* config/pa/tm-hppa.h (DEPRECATED_MAX_REGISTER_RAW_SIZE)
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Ditto.
	* config/pa/tm-hppa64.h (DEPRECATED_MAX_REGISTER_RAW_SIZE): Ditto.
	* config/ia64/tm-ia64.h (DEPRECATED_MAX_REGISTER_RAW_SIZE): Ditto.
	* config/i386/tm-ptx.h (DEPRECATED_MAX_REGISTER_RAW_SIZE): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Do not set
	max_register_raw_size or max_register_virtual_size.
@
text
@d162 1
a162 1
  return (FRAME_SAVED_PC (thisframe) >= LOWEST_PC);
d1035 1
a1035 1
  caller_pc = FRAME_SAVED_PC (fi);
d1093 1
a1093 1
    deprecated_update_frame_pc_hack (fi, FRAME_SAVED_PC (get_next_frame (fi)));
d1538 1
a1538 1
  write_register (ARM_PC_REGNUM, FRAME_SAVED_PC (frame));
d2912 1
a2912 1
  set_gdbarch_frame_saved_pc (gdbarch, arm_frame_saved_pc);
@


1.105.4.1
log
@2003-03-16  Mark Kettenis  <kettenis@@gnu.org>

	Merge with mainline.  Tag is kettenis-i386newframe-20030316-mergepoint.
@
text
@d162 1
a162 1
  return (DEPRECATED_FRAME_SAVED_PC (thisframe) >= LOWEST_PC);
d1035 1
a1035 1
  caller_pc = DEPRECATED_FRAME_SAVED_PC (fi);
d1093 1
a1093 1
    deprecated_update_frame_pc_hack (fi, DEPRECATED_FRAME_SAVED_PC (get_next_frame (fi)));
d1538 1
a1538 1
  write_register (ARM_PC_REGNUM, DEPRECATED_FRAME_SAVED_PC (frame));
d2912 1
a2912 1
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, arm_frame_saved_pc);
d2918 1
a2918 1
  set_gdbarch_deprecated_pop_frame (gdbarch, arm_pop_frame);
@


1.104
log
@Fix merge botch in previous commit.
@
text
@d2953 2
a2954 2
  set_gdbarch_max_register_raw_size (gdbarch, FP_REGISTER_RAW_SIZE);
  set_gdbarch_max_register_virtual_size (gdbarch, FP_REGISTER_VIRTUAL_SIZE);
@


1.103
log
@2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_INIT_SAVED_REGS): Rename
	FRAME_INIT_SAVED_REGS.
	* gdbarch.h, gdbarch.c: Regenerate.
	* stack.c (frame_info): Update.
	* sh-tdep.c (sh_find_callers_reg, sh64_get_saved_pr): Update.
	(sh_init_extra_frame_info, sh64_init_extra_frame_info): Update.
	(sh64_get_saved_register, sh_pop_frame, sh64_pop_frame): Update.
	* ns32k-tdep.c (ns32k_pop_frame): Update.
	* mips-tdep.c (mips_pop_frame): Update.
	* m68hc11-tdep.c (m68hc11_pop_frame): Update.
	* ia64-tdep.c (ia64_frame_chain): Update.
	(ia64_frame_saved_pc, ia64_get_saved_register): Update.
	(ia64_frameless_function_invocation): Update.
	(ia64_init_extra_frame_info): Update.
	(ia64_pop_frame_regular): Update.
	* frame.h (struct frame_info): Update comment.
	(DEPRECATED_FRAME_INIT_SAVED_REGS): Rename macro.
	* frame.c (frame_saved_regs_register_unwind): Update.
	(frame_saved_regs_register_unwind): Update.
	(deprecated_generic_get_saved_register): Update.
	* cris-tdep.c: Update comment.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_INIT_SAVED_REGS):
	Rename macro.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	FRAME_INIT_SAVED_REGS to DEPRECATED_FRAME_INIT_SAVED_REGS.
@
text
@a2917 1
  set_gdbarch_frame_init_saved_regs (gdbarch, arm_frame_init_saved_regs);
@


1.102
log
@2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_INIT_EXTRA_FRAME_INFO): Rename
	INIT_EXTRA_FRAME_INFO.
	* gdbarch.h, gdbarch.c: Regenerate.
	* arm-tdep.c: Update comments.
	* sh-tdep.c, mcore-tdep.c, m68hc11-tdep.c: Ditto.
	* i386-interix-tdep.c, hppa-tdep.c, h8300-tdep.c: Ditto.
	* frame.h, avr-tdep.c: Ditto.
	* frame.c (get_prev_frame): DEPRECATED_INIT_EXTRA_FRAME_INFO.
	(create_new_frame, legacy_get_prev_frame): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_INIT_EXTRA_FRAME_INFO): Rename.
	* config/pa/tm-hppa.h (DEPRECATED_INIT_EXTRA_FRAME_INFO): Rename.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Initialize
	deprecated_init_extra_frame_info instead of init_extra_frame_info.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-interix-tdep.c (i386_interix_init_abi): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.

Index: doc/ChangeLog
2003-02-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo: Rename INIT_EXTRA_FRAME_INFO to
	DEPRECATED_INIT_EXTRA_FRAME_INFO.
@
text
@d2917 1
@


1.101
log
@2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* arm-tdep.c (gdb_print_insn_arm): Rename _bfd to just bfd.
@
text
@d1017 1
a1017 1
   GDB frame struct, and then INIT_EXTRA_FRAME_INFO and
d1115 1
a1115 1
     invoking INIT_EXTRA_FRAME_INFO.  So we test *both*
d2907 1
a2907 1
  set_gdbarch_init_extra_frame_info (gdbarch, arm_init_extra_frame_info);
@


1.100
log
@2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_PUSH_DUMMY_FRAME): Procedure with
	predicate.  Replaces PUSH_DUMMY_FRAME.
	* gdbarch.h, gdbarch.c: Regnerate.
	* valops.c (hand_function_call): Update.  Call
	generic_push_dummy_frame directly.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_PUSH_DUMMY_FRAME): Update.
	* config/pa/tm-hppa.h (DEPRECATED_PUSH_DUMMY_FRAME): Update.
	* inferior.h (PUSH_DUMMY_FRAME): Delete definition.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Don't set
	push_dummy_frame to generic_push_dummy_frame.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
@
text
@d2104 1
a2104 1
      static struct _bfd fake_bfd;
@


1.99
log
@2003-02-21  David Carlton  <carlton@@math.stanford.edu>

	* arm-tdep.c (arm_gdbarch_init): Add break after default label.
@
text
@a2917 1
  set_gdbarch_push_dummy_frame (gdbarch, generic_push_dummy_frame);
@


1.98
log
@2003-02-03  Michael Snyder  <msnyder@@redhat.com>

	* arm-tdep.c: Fix spell-o in comment.
@
text
@d2837 1
@


1.97
log
@2003-01-08  Andrew Cagney  <cagney@@redhat.com>

	* cris-tdep.c (cris_frame_init_saved_regs): Use
	get_frame_saved_regs and SIZEOF_FRAME_SAVED_REGS when copying a
	saved_regs buffer.
	* sh-tdep.c (sh_nofp_frame_init_saved_regs): Ditto.
	(sh64_nofp_frame_init_saved_regs): Ditto.
	(sh_fp_frame_init_saved_regs): Ditto.
	* arm-tdep.c: Use deprecated_set_frame_saved_regs_hack.
	* mips-tdep.c (mips_init_extra_frame_info): Ditto.
	* mcore-tdep.c (analyze_dummy_frame): Ditto.
	* mn10300-tdep.c (analyze_dummy_frame): Ditto.
@
text
@d1506 1
a1506 1
  /* Return the botom of the argument list (pointed to by fp).  */
@


1.97.4.1
log
@Merge with interps-20030203-mergepoint.
@
text
@d1506 1
a1506 1
  /* Return the bottom of the argument list (pointed to by fp).  */
@


1.96
log
@2003-01-08  Andrew Cagney  <cagney@@redhat.com>

	* alpha-tdep.c: Use get_frame_extra_info.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* h8300-tdep.c, ia64-tdep.c, m68hc11-tdep.c, mcore-tdep.c: Ditto.
	* mips-tdep.c, mn10300-tdep.c, s390-tdep.c, sh-tdep.c: Ditto.
	* sparc-tdep.c, xstormy16-tdep.c: Ditto.
@
text
@d3032 6
a3037 4
  prologue_cache->saved_regs = (CORE_ADDR *)
    xcalloc (1, (sizeof (CORE_ADDR)
		 * (gdbarch_num_regs (gdbarch)
		    + gdbarch_num_pseudo_regs (gdbarch))));
@


1.95
log
@2003-01-08  Andrew Cagney  <cagney@@redhat.com>

	* alpha-tdep.c: Use get_next_frame.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* dwarf2cfi.c, h8300-tdep.c, i386-tdep.c, ia64-tdep.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c: Ditto.
	* mips-tdep.c, mn10200-tdep.c, mn10300-tdep.c: Ditto.
	* ns32k-tdep.c, s390-tdep.c, sh-tdep.c, sparc-tdep.c: Ditto.
	* v850-tdep.c, vax-tdep.c, x86-64-linux-tdep.c: Ditto.
	* xstormy16-tdep.c: Ditto.
@
text
@d571 1
a571 1
  fi->extra_info->framesize = 0;
d594 1
a594 1
		fi->extra_info->framesize += 4;
d596 1
a596 1
		  -(fi->extra_info->framesize);
d612 1
a612 1
	      fi->extra_info->frameoffset += offset;
d615 1
a615 1
	  fi->extra_info->framesize -= offset;
d620 1
a620 1
	  fi->extra_info->framereg = THUMB_FP_REGNUM;
d622 1
a622 1
	  fi->extra_info->frameoffset = (insn & 0xff) << 2;
d627 2
a628 2
	  fi->extra_info->framereg = THUMB_FP_REGNUM;
	  fi->extra_info->frameoffset = 0;
d670 3
a672 3
      fi->extra_info->framereg = prologue_cache->extra_info->framereg;
      fi->extra_info->framesize = prologue_cache->extra_info->framesize;
      fi->extra_info->frameoffset = prologue_cache->extra_info->frameoffset;
d690 3
a692 3
  prologue_cache->extra_info->framereg = fi->extra_info->framereg;
  prologue_cache->extra_info->framesize = fi->extra_info->framesize;
  prologue_cache->extra_info->frameoffset = fi->extra_info->frameoffset;
d778 3
a780 3
  fi->extra_info->framereg = ARM_SP_REGNUM;
  fi->extra_info->framesize = 0;
  fi->extra_info->frameoffset = 0;
d917 1
a917 1
	  fi->extra_info->framereg = ARM_FP_REGNUM;
d973 3
a975 3
  fi->extra_info->framesize = -sp_offset;
  if (fi->extra_info->framereg == ARM_FP_REGNUM)
    fi->extra_info->frameoffset = fp_offset - sp_offset;
d977 1
a977 1
    fi->extra_info->frameoffset = 0;
d1025 1
a1025 1
  int framereg = fi->extra_info->framereg;
d1053 1
a1053 1
      framereg = caller_fi->extra_info->framereg;
d1065 1
a1065 1
    return get_frame_base (fi) + fi->extra_info->framesize;
d1088 3
a1090 3
  fi->extra_info->framesize = 0;
  fi->extra_info->frameoffset = 0;
  fi->extra_info->framereg = 0;
d1108 3
a1110 2
    sp = (get_frame_base (get_next_frame (fi)) - get_next_frame (fi)->extra_info->frameoffset
	  + get_next_frame (fi)->extra_info->framesize);
d1136 4
a1139 4
      fi->extra_info->framereg = ARM_SP_REGNUM;
      deprecated_update_frame_base_hack (fi, read_memory_integer (get_frame_saved_regs (fi)[fi->extra_info->framereg], REGISTER_RAW_SIZE (fi->extra_info->framereg)));
      fi->extra_info->framesize = 0;
      fi->extra_info->frameoffset = 0;
d1148 1
a1148 1
	deprecated_update_frame_base_hack (fi, read_register (fi->extra_info->framereg));
d1153 2
a1154 2
      else if (fi->extra_info->framereg == ARM_FP_REGNUM
	       || fi->extra_info->framereg == THUMB_FP_REGNUM)
d1158 2
a1159 2
	  if (get_frame_saved_regs (get_next_frame (fi))[fi->extra_info->framereg] != 0)
	    deprecated_update_frame_base_hack (fi, read_memory_integer (get_frame_saved_regs (get_next_frame (fi))[fi->extra_info->framereg], 4));
d1170 4
a1173 3
	  get_frame_saved_regs (fi)[reg] += (get_frame_base (fi)
					     + fi->extra_info->framesize
					     - fi->extra_info->frameoffset);
d1196 1
a1196 1
				    - fi->extra_info->frameoffset),
d1519 3
a1521 2
  CORE_ADDR old_SP = (get_frame_base (frame) - frame->extra_info->frameoffset
		      + frame->extra_info->framesize);
@


1.94
log
@2003-01-07  Andrew Cagney  <cagney@@redhat.com>

	* alpha-tdep.c: Use get_frame_base.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* h8300-tdep.c, i386-tdep.c, ia64-tdep.c, m68hc11-tdep.c: Ditto.
	* m68k-tdep.c, mcore-tdep.c, mips-tdep.c, mn10200-tdep.c: Ditto.
	* mn10300-tdep.c, ns32k-tdep.c, s390-tdep.c, sh-tdep.c: Ditto.
	* sparc-tdep.c, v850-tdep.c, vax-tdep.c: Ditto.
	* x86-64-linux-tdep.c, xstormy16-tdep.c: Ditto.
	* config/h8500/tm-h8500.h, config/mn10200/tm-mn10200.h: Ditto.
	* config/sparc/tm-sparc.h: Ditto.
@
text
@d995 1
a995 1
  for (; fi; fi = fi->next)
d1092 2
a1093 2
  if (fi->next)
    deprecated_update_frame_pc_hack (fi, FRAME_SAVED_PC (fi->next));
d1099 1
a1099 1
  if (!fi->next)
d1101 1
a1101 1
  else if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (fi->next), 0, 0))
d1104 2
a1105 2
    sp = deprecated_read_register_dummy (get_frame_pc (fi->next),
					 get_frame_base (fi->next),
d1108 2
a1109 2
    sp = (get_frame_base (fi->next) - fi->next->extra_info->frameoffset
	  + fi->next->extra_info->framesize);
d1145 1
a1145 1
      if (!fi->next)
d1148 1
a1148 1
      else if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (fi->next), 0, 0))
d1151 1
a1151 1
	deprecated_update_frame_base_hack (fi, get_frame_base (fi->next));
@


1.93
log
@2003-01-07  Andrew Cagney  <cagney@@redhat.com>

	* arm-tdep.c (arm_init_extra_frame_info): Use
	deprecated_update_frame_base_hack.
	* xstormy16-tdep.c (xstormy16_scan_prologue): Ditto.
	* mn10300-tdep.c (analyze_dummy_frame): Ditto.
	(fix_frame_pointer): Ditto.
	(mn10300_analyze_prologue): Ditto.
@
text
@d294 1
a294 1
  return fi->frame;
d301 1
a301 1
  return fi->frame;
d835 1
a835 1
      if (!safe_read_memory_integer (fi->frame, 4,  &return_value))
d999 2
a1000 1
	  return deprecated_read_register_dummy (get_frame_pc (fi), fi->frame, regnum);
d1029 1
a1029 1
    return fi->frame;
d1065 1
a1065 1
    return fi->frame + fi->extra_info->framesize;
d1104 2
a1105 1
    sp = deprecated_read_register_dummy (get_frame_pc (fi->next), fi->next->frame,
d1108 1
a1108 1
    sp = (fi->next->frame - fi->next->extra_info->frameoffset
d1151 1
a1151 1
	deprecated_update_frame_base_hack (fi, fi->next->frame);
d1169 2
a1170 1
	  get_frame_saved_regs (fi)[reg] += (fi->frame + fi->extra_info->framesize
d1189 2
a1190 1
    return deprecated_read_register_dummy (get_frame_pc (fi), fi->frame, ARM_PC_REGNUM);
d1192 4
a1195 2
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (fi), fi->frame - fi->extra_info->frameoffset,
			fi->frame))
d1517 1
a1517 1
  CORE_ADDR old_SP = (frame->frame - frame->extra_info->frameoffset
d1520 3
a1522 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame), frame->frame, frame->frame))
@


1.92
log
@2003-01-07  Andrew Cagney  <cagney@@redhat.com>

	* xstormy16-tdep.c (xstormy16_init_extra_frame_info): Allocate
	extra_info using frame_extra_info_zalloc.
	* sparc-tdep.c (sparc_init_extra_frame_info): Ditto.
	* sh-tdep.c (sh_init_extra_frame_info): Ditto.
	(sh64_init_extra_frame_info): Ditto.
	* mn10300-tdep.c (mn10300_init_extra_frame_info): Ditto.
	* s390-tdep.c (s390_init_extra_frame_info): Ditto.
	* mips-tdep.c (mips_init_extra_frame_info): Ditto.
	* mcore-tdep.c (mcore_init_extra_frame_info): Ditto.
	* frv-tdep.c (frv_init_extra_frame_info): Ditto.
	* m68hc11-tdep.c (m68hc11_init_extra_frame_info): Ditto.
	* ia64-tdep.c (ia64_init_extra_frame_info): Ditto.
	* h8300-tdep.c (h8300_init_extra_frame_info): Ditto.
	* d10v-tdep.c (d10v_init_extra_frame_info): Ditto.
	* cris-tdep.c (cris_init_extra_frame_info): Ditto.
	* arm-tdep.c (arm_init_extra_frame_info): Ditto.
	* alpha-tdep.c (alpha_init_extra_frame_info): Ditto.

	* mn10300-tdep.c (analyze_dummy_frame): Use
	deprecated_set_frame_extra_info_hack.
	* mcore-tdep.c (analyze_dummy_frame): Ditto.
@
text
@d1134 1
a1134 3
      fi->frame =
	read_memory_integer (get_frame_saved_regs (fi)[fi->extra_info->framereg],
			     REGISTER_RAW_SIZE (fi->extra_info->framereg));
d1145 1
a1145 1
	fi->frame = read_register (fi->extra_info->framereg);
d1149 1
a1149 1
	fi->frame = fi->next->frame;
d1156 1
a1156 2
	    fi->frame =
	      read_memory_integer (get_frame_saved_regs (get_next_frame (fi))[fi->extra_info->framereg], 4);
d1160 1
a1160 1
	    fi->frame = read_fp ();
@


1.91
log
@2003-01-06  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (deprecated_frame_xmalloc_with_cleanup): Declare.
	* frame.c (deprecated_frame_xmalloc_with_cleanup): New function.
	* arm-tdep.c (arm_frame_chain): Allocate caller_fi using
	deprecated_frame_xmalloc_with_cleanup.
	* m32r-tdep.c (m32r_virtual_frame_pointer): Allocate `fi' using
	deprecated_frame_xmalloc.
	* mcore-tdep.c (analyze_dummy_frame): Ditto for dummy.
	* mn10200-tdep.c (mn10200_frame_chain): Ditto for dummy_frame.
@
text
@d1085 1
a1085 2
  fi->extra_info = (struct frame_extra_info *)
    frame_obstack_alloc (sizeof (struct frame_extra_info));
@


1.90
log
@2003-01-05  Andrew Cagney  <ac131313@@redhat.com>

	* arm-tdep.c (prologue_cache): Change to a pointer.
	(_initialize_arm_tdep): Allocate prologue_cache.
	(check_prologue_cache): Update.
	(save_prologue_cache): Update.
	(arm_gdbarch_init): Update.
@
text
@d1044 4
a1047 12
      struct frame_info caller_fi;
      struct cleanup *old_chain;

      /* Create a temporary frame suitable for scanning the caller's
	 prologue.  (Ugh.)  */
      memset (&caller_fi, 0, sizeof (caller_fi));
      caller_fi.extra_info = (struct frame_extra_info *)
	xcalloc (1, sizeof (struct frame_extra_info));
      old_chain = make_cleanup (xfree, caller_fi.extra_info);
      caller_fi.saved_regs = (CORE_ADDR *)
	xcalloc (1, SIZEOF_FRAME_SAVED_REGS);
      make_cleanup (xfree, caller_fi.saved_regs);
d1050 3
a1052 3
      deprecated_update_frame_pc_hack (&caller_fi, caller_pc);
      arm_scan_prologue (&caller_fi);
      framereg = caller_fi.extra_info->framereg;
@


1.89
log
@	* arm-tdep.c (arm_frame_chain_valid):  Remove unnecessary test.
	* d10v-tdep.c (d10v_frame_chain_valid): Remove unnecessary tests.
	* hppa-tdep.c (hppa_frame_chain_valid): Remove unnecessary test.

	* blockframe.c: Include "gdbcmd.h" and "command.h".
	(backtrace_below_main): New variable.
	(file_frame_chain_valid, func_frame_chain_valid)
	(nonnull_frame_chain_valid, generic_file_frame_chain_valid)
	(generic_func_frame_chain_valid): Remove functions.
	(frame_chain_valid, do_flush_frames_sfunc): New functions.
	(_initialize_blockframe): New function.
	* Makefile.in (blockframe.o): Update dependencies.
	* frame.c (frame_saved_regs_id_unwind, get_prev_frame): Remove FIXME
	comment.  Call frame_chain_valid ().
	* frame.h: Remove old prototypes.  Add prototype for
	frame_chain_valid and update comments to match.
	* gdbarch.sh: Change FRAME_CHAIN_VALID into a predicated function.
	Remove old comment.
	* gdbarch.h: Regenerated.
	* gdbarch.c: Regenerated.

Plus updates to all other targets not to provide a FRAME_CHAIN_VALID.
@
text
@d661 1
a661 1
static struct frame_info prologue_cache;
d668 1
a668 1
  if (get_frame_pc (fi) == get_frame_pc (&prologue_cache))
d670 3
a672 3
      fi->extra_info->framereg = prologue_cache.extra_info->framereg;
      fi->extra_info->framesize = prologue_cache.extra_info->framesize;
      fi->extra_info->frameoffset = prologue_cache.extra_info->frameoffset;
d674 1
a674 1
	get_frame_saved_regs (fi)[i] = get_frame_saved_regs (&prologue_cache)[i];
d689 4
a692 4
  deprecated_update_frame_pc_hack (&prologue_cache, get_frame_pc (fi));
  prologue_cache.extra_info->framereg = fi->extra_info->framereg;
  prologue_cache.extra_info->framesize = fi->extra_info->framesize;
  prologue_cache.extra_info->frameoffset = fi->extra_info->frameoffset;
d695 1
a695 1
    get_frame_saved_regs (&prologue_cache)[i] = get_frame_saved_regs (fi)[i];
d3027 2
a3028 2
  if (get_frame_saved_regs (&prologue_cache) != NULL)
    xfree (get_frame_saved_regs (&prologue_cache));
d3033 1
a3033 1
  prologue_cache.saved_regs = (CORE_ADDR *)
d3161 3
a3163 4
  /* Fill in the prologue_cache fields.  */
  prologue_cache.saved_regs = NULL;
  prologue_cache.extra_info = (struct frame_extra_info *)
    xcalloc (1, sizeof (struct frame_extra_info));
@


1.88
log
@	* arch-utils.c (gdbarch_info_init): Set osabi to
	GDB_OSABI_UNINITIALIZED.
	* gdbarch.sh: Add osabi to struct gdbarch and to struct
	gdbarch_info.  Include "osabi.h" in gdbarch.c.  Check osabi
	in gdbarch_list_lookup_by_info and in gdbarch_update_p.
	* gdbarch.c: Regenerated.
	* gdbarch.h: Regenerated.
	* osabi.c (gdbarch_lookup_osabi): Return GDB_OSABI_UNINITIALIZED if
	there's no BFD.
	(gdbarch_init_osabi): Remove osabi argument; use info.osabi.
	* osabi.h (enum gdb_osabi): Move to defs.h.
	(gdbarch_init_osabi): Update prototype.
	* defs.h (enum gdb_osabi): Moved here.
	* Makefile.in: Update dependencies.

Plus updates to alpha, arm, hppa, i386, mips, ns32k, ppc, sh, sparc, and vax
ports to match.
@
text
@d162 1
a162 1
  return (chain != 0 && (FRAME_SAVED_PC (thisframe) >= LOWEST_PC));
@


1.87
log
@gdb/
	* buildsym.h (processing_hp_compilation): Remove obsolete variable.
	* gdbarch.sh Remove include of "value.h" in gdbarch.h.
	(COERCE_FLOAT_TO_DOUBLE): Remove.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* Makefile.in: Remove value_h from gdbarch_h.
	* valops.c (coerce_float_to_double): New variable.
	(default_coerce_float_to_double): Remove.
	(standard_coerce_float_to_double): Remove.
	(value_arg_coerce): Use coerce_float_to_double.
	(_initialize_valops): Add "set coerce-float-to-double".
	* value.h (default_coerce_float_to_double): Remove prototype.
	(standard_coerce_float_to_double): Remove prototype.

	* hpread.c (hpread_process_one_debug_symbol): Mark C++ functions as
	prototyped.
	* mdebugread.c (parse_symbol): Likewise.
	* stabsread.c (define_symbol): Mark all functions as prototyped.

	* hppa-tdep.c (hppa_coerce_float_to_double): Remove.
	* alpha-tdep.c (alpha_gdbarch_init): Remove call to
	set_gdbarch_coerce_float_to_double.
	* arm-tdep.c (arm_gdbarch_init): Likewise.
	* frv-tdep.c (frv_gdbarch_init): Likewise.
	* h8300-tdep.c (h8300_gdbarch_init): Likewise (commented out).
	* i386-sol2-tdep.c (i386_sol2_init_abi): Likewise.
	* mips-tdep.c (mips_gdbarch_init): Likewise.
	(mips_coerce_float_to_double): Remove.
	* rs6000-tdep.c (rs6000_gdbarch_init): Likewise.
	(rs6000_coerce_float_to_double): Remove.
	* s390-tdep.c (s390_gdbarch_init): Likewise.
	* sh-tdep.c (sh_gdbarch_init): Likewise.
	(sh_coerce_float_to_double): Remove.
	* sparc-tdep.c (sparc_gdbarch_init): Likewise.
	(sparc_coerce_float_to_double): Remove.
	* v850-tdep.c (v850_gdbarch_init): Likewise.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Likewise.
	* config/m32r/tm-m32r.h (COERCE_FLOAT_TO_DOUBLE): Remove.
	* config/pa/tm-hppa.h: (COERCE_FLOAT_TO_DOUBLE): Remove.
	(hppa_coerce_float_to_double): Remove prototype.
	* config/sparc/tm-sparc.h (COERCE_FLOAT_TO_DOUBLE): Remove.
doc/
	* gdb.texinfo (Controlling GDB): Add ABI section.  Document
	"set coerce-float-to-double".
	* gdbint.texinfo (COERCE_FLOAT_TO_DOUBLE): Remove documentation.
testsuite/
	* gdb.base/callfuncs.exp: Don't XFAIL unprototyped functions for
	stabs.
	* gdb.base/completion.exp: Allow marker1(void) as well as marker1().
	* gdb.base/whatis.exp: Always allow (void) after function names.
@
text
@d37 1
a2817 1
  enum gdb_osabi osabi = GDB_OSABI_UNKNOWN;
d2821 1
a2821 1
  if (info.abfd != NULL)
d2823 1
a2823 2
      osabi = gdbarch_lookup_osabi (info.abfd);
      if (osabi == GDB_OSABI_UNKNOWN)
d2825 4
a2828 6
	  switch (bfd_get_flavour (info.abfd))
	    {
	    case bfd_target_aout_flavour:
	      /* Assume it's an old APCS-style ABI.  */
	      osabi = GDB_OSABI_ARM_APCS;
	      break;
d2830 5
a2834 5
	    case bfd_target_coff_flavour:
	      /* Assume it's an old APCS-style ABI.  */
	      /* XXX WinCE?  */
	      osabi = GDB_OSABI_ARM_APCS;
	      break;
d2836 2
a2837 3
	    default:
	      /* Leave it as "unknown".  */
	    }
d2841 4
a2844 10
  /* Find a candidate among extant architectures.  */
  for (arches = gdbarch_list_lookup_by_info (arches, &info);
       arches != NULL;
       arches = gdbarch_list_lookup_by_info (arches->next, &info))
    {
      /* Make sure the ABI selection matches.  */
      tdep = gdbarch_tdep (arches->gdbarch);
      if (tdep && tdep->osabi == osabi)
	return arches->gdbarch;
    }
a2852 2
  tdep->osabi = osabi;

d2983 1
a2983 1
  gdbarch_init_osabi (info, gdbarch, osabi);
a3047 3

  fprintf_unfiltered (file, "arm_dump_tdep: OS ABI = %s\n",
		      gdbarch_osabi_name (tdep->osabi));
@


1.86
log
@2003-01-03  Andrew Cagney  <ac131313@@redhat.com>

	* alpha-tdep.c: Use get_frame_saved_regs.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* h8300-tdep.c, i386-tdep.c, ia64-tdep.c, m68hc11-tdep.c: Ditto.
	* m68k-tdep.c, mcore-tdep.c, mips-tdep.c, mn10300-tdep.c: Ditto.
	* ns32k-tdep.c, s390-tdep.c, sh-tdep.c, v850-tdep.c: Ditto.
	* vax-tdep.c, xstormy16-tdep.c: Ditto.
@
text
@d3 1
a3 1
   2001, 2002 Free Software Foundation, Inc.
a2915 2
  set_gdbarch_coerce_float_to_double (gdbarch,
				      standard_coerce_float_to_double);
@


1.85
log
@2003-01-02  Andrew Cagney  <ac131313@@redhat.com>

	* arm-tdep.c: Use get_frame_pc and deprecated_update_frame_pc_hack
	frame accessor methods.
	* alpha-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* dwarf2cfi.c, h8300-tdep.c, i386-tdep.c, ia64-tdep.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c, mips-tdep.c: Ditto.
	* mn10200-tdep.c, mn10300-tdep.c, ns32k-tdep.c: Ditto.
	* s390-tdep.c, sh-tdep.c, sparc-tdep.c, v850-tdep.c: Ditto.
	* vax-tdep.c, x86-64-linux-tdep.c, xstormy16-tdep.c: Ditto.
	* z8k-tdep.c: Ditto.
@
text
@d594 1
a594 1
		fi->saved_regs[saved_reg[regno]] =
d673 1
a673 1
	fi->saved_regs[i] = prologue_cache.saved_regs[i];
d694 1
a694 1
    prologue_cache.saved_regs[i] = fi->saved_regs[i];
d893 1
a893 1
		fi->saved_regs[regno] = sp_offset;
d929 1
a929 1
	  fi->saved_regs[regno] = sp_offset;
d956 1
a956 1
	      fi->saved_regs[fp_start_reg++] = sp_offset;
d1000 1
a1000 1
      else if (fi->saved_regs[regnum] != 0)
d1007 1
a1007 1
	  return read_memory_integer (fi->saved_regs[regnum],
d1089 1
a1089 1
  if (fi->saved_regs == NULL)
d1102 1
a1102 1
  memset (fi->saved_regs, '\000', sizeof fi->saved_regs);
d1138 1
a1138 1
	fi->saved_regs[reg] = SIGCONTEXT_REGISTER_ADDRESS (sp, get_frame_pc (fi), reg);
d1143 1
a1143 1
	read_memory_integer (fi->saved_regs[fi->extra_info->framereg],
d1165 1
a1165 1
	  if (fi->next->saved_regs[fi->extra_info->framereg] != 0)
d1167 1
a1167 2
	      read_memory_integer (fi->next
				   ->saved_regs[fi->extra_info->framereg], 4);
d1177 3
a1179 3
	if (fi->saved_regs[reg] != 0)
	  fi->saved_regs[reg] += (fi->frame + fi->extra_info->framesize
				  - fi->extra_info->frameoffset);
d1202 1
a1202 1
      return read_memory_integer (fi->saved_regs[ARM_PC_REGNUM],
d1234 1
a1234 1
  if (fip->saved_regs)
d1533 1
a1533 1
    if (frame->saved_regs[regnum] != 0)
d1535 1
a1535 1
		  read_memory_integer (frame->saved_regs[regnum],
d3041 2
a3042 2
  if (prologue_cache.saved_regs != NULL)
    xfree (prologue_cache.saved_regs);
@


1.84
log
@* osabi.c: Include "gdb_assert.h" and "gdb_string.h".
(struct gdb_osabi_handler): Remove member `arch'.  Add member
`arch_info'.
(gdbarch_register_osabi): Add new argument `machine'.  Use ot to
construct a `struct bfd_arch_info' and store it in the `struct
gdb_osabi_handler' that is created.
(gdbarch_init_osabi): Check for compatibility based on machine
type and architecture.
* osabi.h (gdbarch_register_osabi): Adjust prototype and update
comment.
* alpha-linux-tdep.c (_initialize_alpha_linux_tdep): Add 0 as
second argument in call to gdbarch_register_osabi.
* alpha-osf1-tdep.c (_initialize_alpha_osf1_tdep): Likewise.
* alphafbsd-tdep.c (_initialize_alphafbsd_tdep): Likewise.
* alphanbsd-tdep.c (_initialize_alphanbsd_tdep): Likewise.
* arm-linux-tdep.c (_initialize_arm_linux_tdep): Likewise.
* arm-tdep.c (_initialize_arm_tdep): Likewise.
* armnbsd-tdep.c (_initialize_armnbsd_tdep): Likewise.
* hppa-hpux-tdep.c (_initialize_hppa_hpux_tdep): Likewise.
* i386-interix-tdep.c (_initialize_i386_interix_tdep): Likewise.
* i386-linux-tdep.c (_initialize_i386_linux_tdep): Likewise.
* i386-sol2-tdep.c (_initialize_i386_sol2_tdep): Likewise.
* i386-tdep.c (_initialize_i386_tdep): Likewise.
* i386bsd-tdep.c (_initialize_i386bsd_tdep): Likewise.
* i386gnu-tdep.c (_initialize_i386gnu_tdep): Likewise.
* i386ly-tdep.c (_initialize_i386lynx_tdep): Renamed from
_initialize_i386bsd_tdep and updated likewise.
* i386nbsd-tdep.c (_initialize_i386nbsd_tdep): Likewise.
* i386obsd-tdep.c (_initialize_i386obsd_tdep): Likewise.
* mips-irix-tdep.c (_initialize_mips_irix_tdep): Likewise.
* mips-linux-tdep.c (_initialize_mips_linux_tdep): Likewise.
* mipsnbsd-tdep.c (_initialize_mipsnbsd__tdep): Likewise.
* ns32knbsd-tdep.c (_initialize_ns32kmnsd_tdep): Likewise.
* ppc-linux-tdep.c (_initialize_ppc_linux_tdep): Likewise.
* ppcnbsd-tdep.c (_initialize_ppcnbsd_tdep): Likewise.
* shnbsd-tdep.c (_initialize_shnbsd_tdep): Likewise.
* sparcnbsd-tdep.c (_initialize_sparcnbsd_tdep): Likewise.
@
text
@d278 1
a278 1
  func_start = (get_pc_function_start ((fi)->pc) + FUNCTION_START_OFFSET);
d542 1
a542 1
      && DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, 0, 0))
d545 1
a545 1
  if (find_pc_partial_function (fi->pc, NULL, &prologue_start, &prologue_end))
d550 1
a550 1
	prologue_end = fi->pc;
d559 1
a559 1
  prologue_end = min (prologue_end, fi->pc);
d667 1
a667 1
  if (fi->pc == prologue_cache.pc)
d688 1
a688 1
  prologue_cache.pc = fi->pc;
d782 1
a782 1
  if (arm_pc_is_thumb (fi->pc))
d791 1
a791 1
  if (find_pc_partial_function (fi->pc, NULL, &prologue_start, &prologue_end))
d799 1
a799 1
	      prologue_end = fi->pc;
d996 1
a996 1
      if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, 0, 0))
d998 1
a998 1
	  return deprecated_read_register_dummy (fi->pc, fi->frame, regnum);
d1025 1
a1025 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, 0, 0))
d1029 1
a1029 1
  if (fi->pc < LOWEST_PC)
d1041 1
a1041 1
  if (arm_pc_is_thumb (caller_pc) != arm_pc_is_thumb (fi->pc))
d1057 1
a1057 1
      caller_fi.pc = caller_pc;
d1100 1
a1100 1
    fi->pc = FRAME_SAVED_PC (fi->next);
d1108 1
a1108 1
  else if (DEPRECATED_PC_IN_CALL_DUMMY (fi->next->pc, 0, 0))
d1111 1
a1111 1
    sp = deprecated_read_register_dummy (fi->next->pc, fi->next->frame,
d1135 1
a1135 1
      && ((get_frame_type (fi) == SIGTRAMP_FRAME) || PC_IN_SIGTRAMP (fi->pc, (char *)0)))
d1138 1
a1138 1
	fi->saved_regs[reg] = SIGCONTEXT_REGISTER_ADDRESS (sp, fi->pc, reg);
d1156 1
a1156 1
      else if (DEPRECATED_PC_IN_CALL_DUMMY (fi->next->pc, 0, 0))
d1197 2
a1198 2
  if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, 0, 0))
    return deprecated_read_register_dummy (fi->pc, fi->frame, ARM_PC_REGNUM);
d1200 1
a1200 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, fi->frame - fi->extra_info->frameoffset,
d1526 1
a1526 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
@


1.83
log
@* arm-tdep.c (convert_from_extended): New argument to hold the
type of floating point result we want to convert to.  Make input
argument const.  Fix all callers.
(convert_to_extended): Similarly.
(arm_extract_return_value): Now takes a regcache argument.  Change
code to use regcache accessor functions.  Correctly extract
smaller-than-word results on big-endian machines.
(arm_store_return_value): Now takes a regcache argument.  Change
code to use regcache accessor functions.  Correctly zero/sign extend
smaller than word results before storing into r0.
(arm_gdbarch_init): Register new-style extract_return_value and
store_return_value functions.
@
text
@d3113 1
a3113 1
  gdbarch_register_osabi (bfd_arch_arm, GDB_OSABI_ARM_EABI_V1,
d3115 1
a3115 1
  gdbarch_register_osabi (bfd_arch_arm, GDB_OSABI_ARM_EABI_V2,
d3117 1
a3117 1
  gdbarch_register_osabi (bfd_arch_arm, GDB_OSABI_ARM_APCS,
@


1.82
log
@2002-12-10  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_INIT_FRAME_PC): Rename INIT_FRAME_PC.
	Change to a function with predicate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.c (get_prev_frame): Update.  Test
	DEPRECATED_INIT_FRAME_PC_P.
	* config/sparc/tm-sparc.h (DEPRECATED_INIT_FRAME_PC): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC): Update.
	* config/mn10200/tm-mn10200.h (DEPRECATED_INIT_FRAME_PC): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	* arm-tdep.c: Update comments.
	* h8300-tdep.c (h8300_gdbarch_init): Explicitly set init_frame_pc.
	* config/m32r/tm-m32r.h (DEPRECATED_INIT_FRAME_PC): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* config/z8k/tm-z8k.h (INIT_FRAME_PC_FIRST): Delete macro.
	(DEPRECATED_INIT_FRAME_PC): Rename INIT_FRAME_PC.
@
text
@d134 4
a137 1
static void convert_from_extended (void *ptr, void *dbl);
d1670 2
a1671 1
convert_from_extended (void *ptr, void *dbl)
d1679 1
a1679 1
  floatformat_from_doublest (TARGET_DOUBLE_FORMAT, &d, dbl);
d1683 1
a1683 1
convert_to_extended (void *dbl, void *ptr)
d1686 1
a1686 1
  floatformat_to_doublest (TARGET_DOUBLE_FORMAT, ptr, &d);
d2224 2
a2225 2
			  char regbuf[REGISTER_BYTES],
			  char *valbuf)
d2227 2
d2236 10
a2245 2
	  convert_from_extended (&regbuf[REGISTER_BYTE (ARM_F0_REGNUM)],
				 valbuf);
d2250 4
a2253 2
	  memcpy (valbuf, &regbuf[REGISTER_BYTE (ARM_A1_REGNUM)],
		  TYPE_LENGTH (type));
d2263 26
d2290 17
a2306 2
    memcpy (valbuf, &regbuf[REGISTER_BYTE (ARM_A1_REGNUM)],
	    TYPE_LENGTH (type));
d2419 2
a2420 1
arm_store_return_value (struct type *type, char *valbuf)
d2422 2
d2433 2
a2434 3
	  convert_to_extended (valbuf, buf);
	  deprecated_write_register_bytes (REGISTER_BYTE (ARM_F0_REGNUM), buf,
					   FP_REGISTER_RAW_SIZE);
d2439 4
a2442 2
	  deprecated_write_register_bytes (ARM_A1_REGNUM, valbuf,
					   TYPE_LENGTH (type));
d2452 33
d2486 17
a2502 2
    deprecated_write_register_bytes (ARM_A1_REGNUM, valbuf,
				     TYPE_LENGTH (type));
d2981 2
a2982 2
  set_gdbarch_deprecated_extract_return_value (gdbarch, arm_extract_return_value);
  set_gdbarch_deprecated_store_return_value (gdbarch, arm_store_return_value);
@


1.81
log
@2002-12-01  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (DEPRECATED_PC_IN_CALL_DUMMY): Rename
	PC_IN_CALL_DUMMY.  Change to predicate.  Always allow call.
	* gdbarch.h, gdbarch.c: Re-generate.
	* config/sparc/tm-sparc.h, config/sparc/tm-sp64.h: Update.
	* config/mn10200/tm-mn10200.h, config/h8500/tm-h8500.h: Update.
	* config/pa/tm-hppa.h, frame.h: Update.
	* x86-64-tdep.c, vax-tdep.c, sparc-tdep.c: Update.
	* s390-tdep.c, ns32k-tdep.c, mn10300-tdep.c: Update.
	* m68k-tdep.c, i386-tdep.c, frv-tdep.c: Update.
	* cris-tdep.c, alpha-tdep.c: Update.
	* frame.c (set_unwind_by_pc, create_new_frame): Use either
	DEPRECATED_PC_IN_CALL_DUMMY or pc_in_dummy_frame.
	(get_prev_frame): Ditto.

Index: doc/ChangeLog
2002-12-01  Andrew Cagney  <ac131313@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	PC_IN_CALL_DUMMY.
@
text
@d1012 3
a1014 3
   GDB frame struct, and then INIT_EXTRA_FRAME_INFO and INIT_FRAME_PC
   will be called for the new frame.  For ARM, we save the frame size
   when we initialize the frame_info.  */
d2750 4
@


1.80
log
@2002-11-28  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (DEPRECATED_USE_GENERIC_DUMMY_FRAMES): Rename
	USE_GENERIC_DUMMY_FRAMES.
	* gdbarch.h, gdbarch.c: Regenerate.
	* valops.c, frame.c: Update.
	* config/z8k/tm-z8k.h, config/mn10200/tm-mn10200.h: Update.
	* config/m32r/tm-m32r.h, config/h8500/tm-h8500.h: Update.
	* config/pa/tm-hppa.h, blockframe.c: Update.
	* vax-tdep.c, sparc-tdep.c, ns32k-tdep.c: Ditto.
	* m68k-tdep.c, alpha-tdep.c: Ditto.

	* arm-tdep.c: Eliminate USE_GENERIC_DUMMY_FRAMES as always 1.
	* mips-tdep.c: Ditto.

Index: doc/ChangeLog
2002-11-28  Andrew Cagney  <ac131313@@redhat.com>

	* gdbint.texinfo (Host Definition): Delete documentation on
	USE_GENERIC_DUMMY_FRAMES.
@
text
@d218 1
a218 1
  if (PC_IN_CALL_DUMMY (memaddr, sp, sp + 1024))
d413 1
a413 1
  if (PC_IN_CALL_DUMMY (pc, 0, 0))
d539 1
a539 1
      && PC_IN_CALL_DUMMY (fi->pc, 0, 0))
d993 1
a993 1
      if (PC_IN_CALL_DUMMY (fi->pc, 0, 0))
d1022 1
a1022 1
  if (PC_IN_CALL_DUMMY (fi->pc, 0, 0))
d1105 1
a1105 1
  else if (PC_IN_CALL_DUMMY (fi->next->pc, 0, 0))
d1153 1
a1153 1
      else if (PC_IN_CALL_DUMMY (fi->next->pc, 0, 0))
d1194 1
a1194 1
  if (PC_IN_CALL_DUMMY (fi->pc, 0, 0))
d1197 1
a1197 1
  if (PC_IN_CALL_DUMMY (fi->pc, fi->frame - fi->extra_info->frameoffset,
d1523 1
a1523 1
  if (PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
@


1.79
log
@2002-11-27  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_LOCATION): Default to AT_ENTRY_POINT.
	(USE_GENERIC_DUMMY_FRAMES): Default to true.
	(PC_IN_CALL_DUMMY): Default to generic_pc_in_call_dummy.
	* gdbarch.c, gdbarch.h: Re-generate.
	* inferior.h (USE_GENERIC_DUMMY_FRAMES): Delete macro definition.
	(CALL_DUMMY_LOCATION): Delete macro definition.
	(PC_IN_CALL_DUMMY): Delete macro definitions.

	* arm-tdep.c (arm_gdbarch_init): Do not set pc_in_call_dummy,
	default is already generic_pc_in_call_dummy.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.

	* arm-tdep.c (arm_gdbarch_init): Do not set
	use_generic_dummy_frames, default is already 1.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* x86-64-tdep.c (x86_64_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.

	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	call_dummy_location, default is already AT_ENTRY_POINT.
	* x86-64-tdep.c (x86_64_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
@
text
@d413 1
a413 2
  if (USE_GENERIC_DUMMY_FRAMES
      && PC_IN_CALL_DUMMY (pc, 0, 0))
d538 1
a538 2
  if (USE_GENERIC_DUMMY_FRAMES
      && fi != NULL
d993 1
a993 2
      if (USE_GENERIC_DUMMY_FRAMES
	  && PC_IN_CALL_DUMMY (fi->pc, 0, 0))
d1022 1
a1022 2
  if (USE_GENERIC_DUMMY_FRAMES
      && PC_IN_CALL_DUMMY (fi->pc, 0, 0))
d1105 1
a1105 2
  else if (USE_GENERIC_DUMMY_FRAMES
	   && PC_IN_CALL_DUMMY (fi->next->pc, 0, 0))
a1145 27
  else if (!USE_GENERIC_DUMMY_FRAMES
	   && PC_IN_CALL_DUMMY (fi->pc, sp, fi->frame))
    {
      CORE_ADDR rp;
      CORE_ADDR callers_sp;

      /* Set rp point at the high end of the saved registers.  */
      rp = fi->frame - REGISTER_SIZE;

      /* Fill in addresses of saved registers.  */
      fi->saved_regs[ARM_PS_REGNUM] = rp;
      rp -= REGISTER_RAW_SIZE (ARM_PS_REGNUM);
      for (reg = ARM_PC_REGNUM; reg >= 0; reg--)
	{
	  fi->saved_regs[reg] = rp;
	  rp -= REGISTER_RAW_SIZE (reg);
	}

      callers_sp = read_memory_integer (fi->saved_regs[ARM_SP_REGNUM],
                                        REGISTER_RAW_SIZE (ARM_SP_REGNUM));
      if (arm_pc_is_thumb (fi->pc))
	fi->extra_info->framereg = THUMB_FP_REGNUM;
      else
	fi->extra_info->framereg = ARM_FP_REGNUM;
      fi->extra_info->framesize = callers_sp - sp;
      fi->extra_info->frameoffset = fi->frame - sp;
    }
d1153 1
a1153 2
      else if (USE_GENERIC_DUMMY_FRAMES
	       && PC_IN_CALL_DUMMY (fi->next->pc, 0, 0))
d1194 1
a1194 2
  if (USE_GENERIC_DUMMY_FRAMES
      && PC_IN_CALL_DUMMY (fi->pc, 0, 0))
d1523 1
a1523 2
  if (USE_GENERIC_DUMMY_FRAMES
      && PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
@


1.78
log
@2002-11-24  Andrew Cagney  <ac131313@@redhat.com>

	* arm-tdep.c (arm_gdbarch_init): Do not set get_saved_register.
@
text
@a2821 3
  set_gdbarch_use_generic_dummy_frames (gdbarch, 1);
  set_gdbarch_call_dummy_location (gdbarch, AT_ENTRY_POINT);

a2833 1
  set_gdbarch_pc_in_call_dummy (gdbarch, generic_pc_in_call_dummy);
@


1.77
log
@2002-11-23  Andrew Cagney  <ac131313@@redhat.com>

	* arm-tdep.c (arm_gdbarch_init): Remove old style non-generic
	dummy frame initialization code.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
@
text
@a2841 1
  set_gdbarch_get_saved_register (gdbarch, deprecated_generic_get_saved_register);
@


1.76
log
@2002-11-18  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (enum frame_type): Define.
	(get_frame_type): Declare.
	(struct frame_info): Add field `type'.  Delete field
	signal_handler_caller.
	(deprecated_set_frame_signal_handler_caller): Declare.
	* frame.c (get_frame_type): New function.
	(deprecated_set_frame_type): New function.
	(create_new_frame): Set the frame's type.
	(get_prev_frame): Similar.
	* sparc-tdep.c: Use get_frame_type instead of signal_handler_caller.
	* s390-tdep.c: Ditto.
	* m68klinux-nat.c: Ditto.
	* ns32k-tdep.c: Ditto.
	* x86-64-linux-tdep.c: Ditto.
	* vax-tdep.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* i386-interix-tdep.c: Ditto.
	* mips-tdep.c: Ditto.
	* m68k-tdep.c: Ditto.
	* hppa-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* cris-tdep.c: Ditto.
	* arm-tdep.c: Ditto.
	* alpha-tdep.c: Ditto.
	* i386-tdep.c: Ditto.
	* stack.c: Ditto.
	* ada-lang.c: Ditto.
	* blockframe.c: Update.
	* i386-interix-tdep.c (i386_interix_back_one_frame): Use
	deprecated_set_frame_type instead of signal_handler_caller.
	* ppc-linux-tdep.c (ppc_linux_init_extra_frame_info): Ditto.
	* rs6000-tdep.c (rs6000_init_extra_frame_info): Ditto.
	* breakpoint.h: Delete FIXME suggesting get_frame_type.

Index: tui/ChangeLog
2002-11-18  Andrew Cagney  <ac131313@@redhat.com>

	* tuiStack.c (tuiShowFrameInfo): Use get_frame_type instead of
	signal_handler_caller.
@
text
@a2821 25
#if OLD_STYLE_ARM_DUMMY_FRAMES
  /* NOTE: cagney/2002-05-07: Enable the below to restore the old ARM
     specific (non-generic) dummy frame code.  Might be useful if
     there appears to be a problem with the generic dummy frame
     mechanism that replaced it.  */
  set_gdbarch_use_generic_dummy_frames (gdbarch, 0);

  /* Call dummy code.  */
  set_gdbarch_call_dummy_location (gdbarch, ON_STACK);
  set_gdbarch_call_dummy_breakpoint_offset_p (gdbarch, 1);
  /* We have to give this a value now, even though we will re-set it 
     during each call to arm_fix_call_dummy.  */
  set_gdbarch_call_dummy_breakpoint_offset (gdbarch, 8);
  set_gdbarch_call_dummy_p (gdbarch, 1);
  set_gdbarch_call_dummy_stack_adjust_p (gdbarch, 0);

  set_gdbarch_call_dummy_words (gdbarch, arm_call_dummy_words);
  set_gdbarch_sizeof_call_dummy_words (gdbarch, sizeof (arm_call_dummy_words));
  set_gdbarch_call_dummy_start_offset (gdbarch, 0);
  set_gdbarch_call_dummy_length (gdbarch, 0);

  set_gdbarch_fix_call_dummy (gdbarch, arm_fix_call_dummy);

  set_gdbarch_pc_in_call_dummy (gdbarch, pc_in_call_dummy_on_stack);
#else
a2840 1
#endif
a2859 7
#if OLD_STYLE_ARM_DUMMY_FRAMES
  /* NOTE: cagney/2002-05-07: Enable the below to restore the old ARM
     specific (non-generic) dummy frame code.  Might be useful if
     there appears to be a problem with the generic dummy frame
     mechanism that replaced it.  */
  set_gdbarch_push_dummy_frame (gdbarch, arm_push_dummy_frame);
#else
a2860 1
#endif
@


1.75
log
@2002-11-13  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (deprecated_read_register_bytes): Rename
	read_register_bytes.
	(deprecated_write_register_bytes): Rename write_register_bytes.
	* alpha-tdep.c, arm-tdep.c, cris-tdep.c, d10v-tdep.c: Update.
	* dwarf2cfi.c, frv-tdep.c, hppa-tdep.c, ia64-tdep.c: Update.
	* m68k-tdep.c, mcore-tdep.c, mips-tdep.c, mn10300-tdep.c: Update.
	* ns32k-tdep.c, regcache.c, remote-sds.c, remote-vx.c: Update.
	* remote.c, rs6000-tdep.c, s390-tdep.c, sh-tdep.c: Update.
	* sparc-tdep.c, v850-tdep.c, vax-tdep.c, x86-64-tdep.c: Update.
	* xstormy16-tdep.c, z8k-tdep.c, config/nm-gnu.h: Update.
	* config/nm-m3.h, config/h8500/tm-h8500.h: Update.
	* config/i386/nm-ptx4.h, config/i386/nm-symmetry.h: Update.
	* config/m32r/tm-m32r.h, config/m68k/nm-sun3.h: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-linux.h: Update.
	* config/mn10200/tm-mn10200.h, config/pa/tm-hppa64.h: Update.
	* config/sparc/nm-nbsd.h, config/sparc/nm-sun4os4.h: Update.
	* config/sparc/nm-sun4sol2.h, config/sparc/tm-sparclet.h: Update.

2002-11-13  Andrew Cagney  <ac131313@@redhat.com>

	* mi-main.c (mi_cmd_data_write_register_values): Use
	deprecated_write_register_bytes instead of write_register_bytes.
@
text
@d1120 6
a1125 5
     Unfortunately, it isn't sufficient to test
     fi->signal_handler_caller because this value is sometimes set
     after invoking INIT_EXTRA_FRAME_INFO.  So we test *both*
     fi->signal_handler_caller and PC_IN_SIGTRAMP to determine if we
     need to use the sigcontext addresses for the saved registers.
d1132 4
d1137 1
a1137 1
      && (fi->signal_handler_caller || PC_IN_SIGTRAMP (fi->pc, (char *)0)))
@


1.74
log
@2002-11-01  Andrew Cagney  <cagney@@redhat.com>

	* frame.h (deprecated_generic_get_saved_register): Rename
	generic_get_saved_register.
	* blockframe.c (deprecated_generic_get_saved_register): Update.
	* xstormy16-tdep.c (xstormy16_get_saved_register): Update.
	(xstormy16_frame_saved_register): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_get_saved_register): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* config/m32r/tm-m32r.h (GET_SAVED_REGISTER): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
@
text
@d2404 2
a2405 2
	  write_register_bytes (REGISTER_BYTE (ARM_F0_REGNUM), buf,
				FP_REGISTER_RAW_SIZE);
d2410 2
a2411 1
	  write_register_bytes (ARM_A1_REGNUM, valbuf, TYPE_LENGTH (type));
d2422 2
a2423 1
    write_register_bytes (ARM_A1_REGNUM, valbuf, TYPE_LENGTH (type));
@


1.73
log
@2002-09-17  Andrew Cagney  <cagney@@redhat.com>

	* h8300-tdep.c (h8300_frame_chain):
	(h8300_frame_saved_pc):

	* blockframe.c (deprecated_read_register_dummy): Rename
	generic_read_register_dummy.
	* frame.c (frame_unwind_signed_register): New function.
	(frame_unwind_unsigned_register): New function.
	* frame.h (frame_unwind_signed_register): Declare.
	(frame_unwind_unsigned_register): Declare.
	(deprecated_read_register_dummy): Rename
	generic_read_register_dummy.

	* xstormy16-tdep.c (xstormy16_frame_saved_pc): Update.
	* rs6000-tdep.c (rs6000_frame_saved_pc): Update.
	* s390-tdep.c (s390_frame_saved_pc_nofix): Update.
	(s390_frame_chain): Update.
	* v850-tdep.c (v850_find_callers_reg): Update.
	(v850_frame_saved_pc): Update.
	* m32r-tdep.c (m32r_init_extra_frame_info): Update.
	(m32r_find_callers_reg): Update.
	(m32r_frame_saved_pc): Update.
	* sh-tdep.c (sh_find_callers_reg): Update.
	(sh64_get_saved_pr): Update.
	(sh_init_extra_frame_info): Update.
	(sh_init_extra_frame_info): Update.
	(sh64_init_extra_frame_info): Update.
	(sh64_init_extra_frame_info): Update.
	* mcore-tdep.c (mcore_find_callers_reg): Update.
	(mcore_frame_saved_pc): Update.
	(mcore_init_extra_frame_info): Update.
	* i386-tdep.c (i386_frame_saved_pc): Update.
	* ia64-tdep.c (ia64_frame_saved_pc): Update.
	(ia64_init_extra_frame_info): Update.
	(ia64_init_extra_frame_info): Update.
	* d10v-tdep.c (d10v_frame_saved_pc): Update.
	* cris-tdep.c (cris_init_extra_frame_info): Update.
	* avr-tdep.c (avr_frame_chain): Update.
	(avr_init_extra_frame_info): Update.
	(avr_frame_saved_pc): Update.
	* arm-tdep.c (arm_find_callers_reg): Update.
	(arm_init_extra_frame_info): Update.
	(arm_frame_saved_pc): Update.
@
text
@d2861 1
a2861 1
  set_gdbarch_get_saved_register (gdbarch, generic_get_saved_register);
@


1.73.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   2001, 2002, 2003 Free Software Foundation, Inc.
d31 1
a31 1
#include "dis-asm.h"		/* For register styles. */
d36 1
a36 4
#include "osabi.h"
#include "frame-unwind.h"
#include "frame-base.h"
#include "trad-frame.h"
d81 3
a83 1
   is used for this purpose.
d86 4
a89 1
   MSYMBOL_IS_SPECIAL   Tests the "special" bit in a minimal symbol.  */
d98 2
a99 18
/* The list of available "set arm ..." and "show arm ..." commands.  */
static struct cmd_list_element *setarmcmdlist = NULL;
static struct cmd_list_element *showarmcmdlist = NULL;

/* The type of floating-point to use.  Keep this in sync with enum
   arm_float_model, and the help string in _initialize_arm_tdep.  */
static const char *fp_model_strings[] =
{
  "auto",
  "softfpa",
  "fpa",
  "softvfp",
  "vfp"
};

/* A variable that can be configured by the user.  */
static enum arm_float_model arm_fp_model = ARM_FLOAT_AUTO;
static const char *current_fp_model = "auto";
d102 1
a102 1
static int num_disassembly_options;
d120 2
a121 2
/* Valid register name styles.  */
static const char **valid_disassembly_styles;
d123 2
a124 2
/* Disassembly style to use. Default to "std" register names.  */
static const char *disassembly_style;
d129 2
a130 2
   style.  */
static void set_disassembly_style_sfunc(char *, int,
d132 3
a134 1
static void set_disassembly_style (void);
d136 5
a140 16
static void convert_from_extended (const struct floatformat *, const void *,
				   void *);
static void convert_to_extended (const struct floatformat *, void *,
				 const void *);

struct arm_prologue_cache
{
  /* The stack pointer at the time this frame was created; i.e. the
     caller's stack pointer when this function was called.  It is used
     to identify this frame.  */
  CORE_ADDR prev_sp;

  /* The frame base for this frame is just prev_sp + frame offset -
     frame size.  FRAMESIZE is the size of this stack frame, and
     FRAMEOFFSET if the initial offset from the stack pointer (this
     frame's stack pointer, not PREV_SP) to the frame base.  */
d142 2
a145 2

  /* The register used to hold the frame pointer for this frame.  */
a146 3

  /* Saved register offsets.  */
  struct trad_frame_saved_reg *saved_regs;
d155 6
d218 1
a218 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (memaddr, sp, sp + 1024))
d275 1
a275 1
  func_start = (get_frame_func (fi) + FUNCTION_START_OFFSET);
d286 22
d413 2
a414 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (pc, 0, 0))
d424 1
a424 1
      sym = lookup_symbol (func_name, NULL, VAR_DOMAIN, NULL, NULL);
a452 6
      if ((inst & 0xfffff000) == 0xe28dc000)    /* add ip, sp #n */
	continue;

      if ((inst & 0xfffff000) == 0xe24dc000)    /* sub ip, sp #n */
	continue;

d506 1
d523 1
a523 1
thumb_scan_prologue (CORE_ADDR prev_pc, struct arm_prologue_cache *cache)
d538 7
a544 1
  if (find_pc_partial_function (prev_pc, NULL, &prologue_start, &prologue_end))
d549 1
a549 1
	prologue_end = prev_pc;
d558 1
a558 1
  prologue_end = min (prologue_end, prev_pc);
d569 1
a569 1
  cache->framesize = 0;
d592 3
a594 2
		cache->framesize += 4;
		cache->saved_regs[saved_reg[regno]].addr = -cache->framesize;
d610 1
a610 1
	      cache->frameoffset += offset;
d613 1
a613 1
	  cache->framesize -= offset;
d618 1
a618 1
	  cache->framereg = THUMB_FP_REGNUM;
d620 1
a620 1
	  cache->frameoffset = (insn & 0xff) << 2;
d625 2
a626 2
	  cache->framereg = THUMB_FP_REGNUM;
	  cache->frameoffset = 0;
d643 54
d765 1
a765 1
arm_scan_prologue (struct frame_info *next_frame, struct arm_prologue_cache *cache)
d767 2
a768 1
  int regno, sp_offset, fp_offset, ip_offset;
d770 4
a773 1
  CORE_ADDR prev_pc = frame_pc_unwind (next_frame);
d776 3
a778 3
  cache->framereg = ARM_SP_REGNUM;
  cache->framesize = 0;
  cache->frameoffset = 0;
d781 1
a781 1
  if (arm_pc_is_thumb (prev_pc))
d783 2
a784 1
      thumb_scan_prologue (prev_pc, cache);
d790 1
a790 1
  if (find_pc_partial_function (prev_pc, NULL, &prologue_start, &prologue_end))
d798 1
a798 1
	      prologue_end = prev_pc;
d831 3
a833 10
      /* We have no symbol information.  Our only option is to assume this
	 function has a standard stack frame and the normal frame register.
	 Then, we can find the value of our frame pointer on entrance to
	 the callee (or at the present moment if this is the innermost frame).
	 The value stored there should be the address of the stmfd + 8.  */
      CORE_ADDR frame_loc;
      LONGEST return_value;

      frame_loc = frame_unwind_register_unsigned (next_frame, ARM_FP_REGNUM);
      if (!safe_read_memory_integer (frame_loc, 4, &return_value))
a841 3
  if (prev_pc < prologue_end)
    prologue_end = prev_pc;

d863 1
a863 1
  sp_offset = fp_offset = ip_offset = 0;
a872 17
	  ip_offset = 0;
	  continue;
	}
      else if ((insn & 0xfffff000) == 0xe28dc000) /* add ip, sp #n */
	{
	  unsigned imm = insn & 0xff;                   /* immediate value */
	  unsigned rot = (insn & 0xf00) >> 7;           /* rotate amount */
	  imm = (imm >> rot) | (imm << (32 - rot));
	  ip_offset = imm;
	  continue;
	}
      else if ((insn & 0xfffff000) == 0xe24dc000) /* sub ip, sp #n */
	{
	  unsigned imm = insn & 0xff;                   /* immediate value */
	  unsigned rot = (insn & 0xf00) >> 7;           /* rotate amount */
	  imm = (imm >> rot) | (imm << (32 - rot));
	  ip_offset = -imm;
d877 1
a877 2
	  sp_offset -= 4;
	  cache->saved_regs[ARM_LR_REGNUM].addr = sp_offset;
d892 1
a892 1
		cache->saved_regs[regno].addr = sp_offset;
d914 2
a915 2
	  fp_offset = -imm + ip_offset;
	  cache->framereg = ARM_FP_REGNUM;
d928 1
a928 1
	  cache->saved_regs[regno].addr = sp_offset;
d955 1
a955 1
	      cache->saved_regs[fp_start_reg++].addr = sp_offset;
d971 3
a973 3
  cache->framesize = -sp_offset;
  if (cache->framereg == ARM_FP_REGNUM)
    cache->frameoffset = fp_offset - sp_offset;
d975 1
a975 12
    cache->frameoffset = 0;
}

static struct arm_prologue_cache *
arm_make_prologue_cache (struct frame_info *next_frame)
{
  int reg;
  struct arm_prologue_cache *cache;
  CORE_ADDR unwound_fp;

  cache = frame_obstack_zalloc (sizeof (struct arm_prologue_cache));
  cache->saved_regs = trad_frame_alloc_saved_regs (next_frame);
d977 1
a977 15
  arm_scan_prologue (next_frame, cache);

  unwound_fp = frame_unwind_register_unsigned (next_frame, cache->framereg);
  if (unwound_fp == 0)
    return cache;

  cache->prev_sp = unwound_fp + cache->framesize - cache->frameoffset;

  /* Calculate actual addresses of saved registers using offsets
     determined by arm_scan_prologue.  */
  for (reg = 0; reg < NUM_REGS; reg++)
    if (trad_frame_addr_p (cache->saved_regs, reg))
      cache->saved_regs[reg].addr += cache->prev_sp;

  return cache;
d980 6
a985 2
/* Our frame ID for a normal frame is the current function's starting PC
   and the caller's SP when we were called.  */
d987 2
a988 4
static void
arm_prologue_this_id (struct frame_info *next_frame,
		      void **this_cache,
		      struct frame_id *this_id)
d990 20
a1009 63
  struct arm_prologue_cache *cache;
  struct frame_id id;
  CORE_ADDR func;

  if (*this_cache == NULL)
    *this_cache = arm_make_prologue_cache (next_frame);
  cache = *this_cache;

  func = frame_func_unwind (next_frame);

  /* This is meant to halt the backtrace at "_start".  Make sure we
     don't halt it at a generic dummy frame. */
  if (func <= LOWEST_PC)
    return;

  /* If we've hit a wall, stop.  */
  if (cache->prev_sp == 0)
    return;

  id = frame_id_build (cache->prev_sp, func);

  /* Check that we're not going round in circles with the same frame
     ID (but avoid applying the test to sentinel frames which do go
     round in circles).  */
  if (frame_relative_level (next_frame) >= 0
      && get_frame_type (next_frame) == NORMAL_FRAME
      && frame_id_eq (get_frame_id (next_frame), id))
    return;

  *this_id = id;
}

static void
arm_prologue_prev_register (struct frame_info *next_frame,
			    void **this_cache,
			    int prev_regnum,
			    int *optimized,
			    enum lval_type *lvalp,
			    CORE_ADDR *addrp,
			    int *realnump,
			    void *valuep)
{
  struct arm_prologue_cache *cache;

  if (*this_cache == NULL)
    *this_cache = arm_make_prologue_cache (next_frame);
  cache = *this_cache;

  /* If we are asked to unwind the PC, then we need to return the LR
     instead.  The saved value of PC points into this frame's
     prologue, not the next frame's resume location.  */
  if (prev_regnum == ARM_PC_REGNUM)
    prev_regnum = ARM_LR_REGNUM;

  /* SP is generally not saved to the stack, but this frame is
     identified by NEXT_FRAME's stack pointer at the time of the call.
     The value was already reconstructed into PREV_SP.  */
  if (prev_regnum == ARM_SP_REGNUM)
    {
      *lvalp = not_lval;
      if (valuep)
	store_unsigned_integer (valuep, 4, cache->prev_sp);
      return;
d1011 1
a1011 3

  trad_frame_prev_register (next_frame, cache->saved_regs, prev_regnum,
			    optimized, lvalp, addrp, realnump, valuep);
d1013 5
d1019 2
a1020 8
struct frame_unwind arm_prologue_unwind = {
  NORMAL_FRAME,
  arm_prologue_this_id,
  arm_prologue_prev_register
};

static const struct frame_unwind *
arm_prologue_unwind_sniffer (struct frame_info *next_frame)
d1022 2
a1023 2
  return &arm_prologue_unwind;
}
d1025 4
a1028 4
static CORE_ADDR
arm_normal_frame_base (struct frame_info *next_frame, void **this_cache)
{
  struct arm_prologue_cache *cache;
d1030 2
a1031 3
  if (*this_cache == NULL)
    *this_cache = arm_make_prologue_cache (next_frame);
  cache = *this_cache;
d1033 2
a1034 2
  return cache->prev_sp + cache->frameoffset - cache->framesize;
}
d1036 47
a1082 6
struct frame_base arm_normal_base = {
  &arm_prologue_unwind,
  arm_normal_frame_base,
  arm_normal_frame_base,
  arm_normal_frame_base
};
d1084 2
a1085 2
static struct arm_prologue_cache *
arm_make_sigtramp_cache (struct frame_info *next_frame)
a1086 1
  struct arm_prologue_cache *cache;
d1088 1
d1090 2
a1091 1
  cache = frame_obstack_zalloc (sizeof (struct arm_prologue_cache));
d1093 2
a1094 1
  cache->prev_sp = frame_unwind_register_unsigned (next_frame, ARM_SP_REGNUM);
d1096 29
a1124 1
  cache->saved_regs = trad_frame_alloc_saved_regs (next_frame);
d1126 4
a1129 4
  for (reg = 0; reg < NUM_REGS; reg++)
    cache->saved_regs[reg].addr
      = SIGCONTEXT_REGISTER_ADDRESS (cache->prev_sp,
				     frame_pc_unwind (next_frame), reg);
d1131 13
a1143 5
  /* FIXME: What about thumb mode?  */
  cache->framereg = ARM_SP_REGNUM;
  cache->prev_sp
    = read_memory_integer (cache->saved_regs[cache->framereg].addr,
			   DEPRECATED_REGISTER_RAW_SIZE (cache->framereg));
d1145 6
a1150 2
  return cache;
}
d1152 2
a1153 6
static void
arm_sigtramp_this_id (struct frame_info *next_frame,
		      void **this_cache,
		      struct frame_id *this_id)
{
  struct arm_prologue_cache *cache;
d1155 8
a1162 3
  if (*this_cache == NULL)
    *this_cache = arm_make_sigtramp_cache (next_frame);
  cache = *this_cache;
d1164 43
a1206 3
  /* FIXME drow/2003-07-07: This isn't right if we single-step within
     the sigtramp frame; the PC should be the beginning of the trampoline.  */
  *this_id = frame_id_build (cache->prev_sp, frame_pc_unwind (next_frame));
a1208 11
static void
arm_sigtramp_prev_register (struct frame_info *next_frame,
			    void **this_cache,
			    int prev_regnum,
			    int *optimized,
			    enum lval_type *lvalp,
			    CORE_ADDR *addrp,
			    int *realnump,
			    void *valuep)
{
  struct arm_prologue_cache *cache;
d1210 7
a1216 3
  if (*this_cache == NULL)
    *this_cache = arm_make_sigtramp_cache (next_frame);
  cache = *this_cache;
d1218 2
a1219 12
  trad_frame_prev_register (next_frame, cache->saved_regs, prev_regnum,
			    optimized, lvalp, addrp, realnump, valuep);
}

struct frame_unwind arm_sigtramp_unwind = {
  SIGTRAMP_FRAME,
  arm_sigtramp_this_id,
  arm_sigtramp_prev_register
};

static const struct frame_unwind *
arm_sigtramp_unwind_sniffer (struct frame_info *next_frame)
d1221 4
a1224 4
  /* Note: If an ARM PC_IN_SIGTRAMP method ever needs to compare
     against the name of the function, the code below will have to be
     changed to first fetch the name of the function and then pass
     this name to PC_IN_SIGTRAMP.  */
d1226 11
a1236 5
  if (SIGCONTEXT_REGISTER_ADDRESS_P ()
      && PC_IN_SIGTRAMP (frame_pc_unwind (next_frame), (char *) 0))
    return &arm_sigtramp_unwind;

  return NULL;
d1239 2
a1240 5
/* Assuming NEXT_FRAME->prev is a dummy, return the frame ID of that
   dummy frame.  The frame ID's base needs to match the TOS value
   saved by save_dummy_frame_tos() and returned from
   arm_push_dummy_call, and the PC needs to match the dummy frame's
   breakpoint.  */
d1242 2
a1243 2
static struct frame_id
arm_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
d1245 4
a1248 2
  return frame_id_build (frame_unwind_register_unsigned (next_frame, ARM_SP_REGNUM),
			 frame_pc_unwind (next_frame));
d1251 5
a1255 3
/* Given THIS_FRAME, find the previous frame's resume PC (which will
   be used to construct the previous frame's ID, after looking up the
   containing function).  */
d1257 2
a1258 2
static CORE_ADDR
arm_unwind_pc (struct gdbarch *gdbarch, struct frame_info *this_frame)
a1259 4
  CORE_ADDR pc;
  pc = frame_unwind_register_unsigned (this_frame, ARM_PC_REGNUM);
  return IS_THUMB_ADDR (pc) ? UNMAKE_THUMB_ADDR (pc) : pc;
}
d1261 4
a1264 4
static CORE_ADDR
arm_unwind_sp (struct gdbarch *gdbarch, struct frame_info *this_frame)
{
  return frame_unwind_register_unsigned (this_frame, ARM_SP_REGNUM);
d1273 1
a1273 1
  write_register (ARM_LR_REGNUM, entry_point_address ());
d1312 1
a1312 1
/* DEPRECATED_CALL_DUMMY_WORDS:
d1332 2
a1333 2
   followed by a call to call_function_by_hand, which is the only
   function where call_dummy_breakpoint_offset is actually used.  */
d1340 1
a1340 1
    set_gdbarch_deprecated_call_dummy_breakpoint_offset (current_gdbarch, 4);
d1342 1
a1342 1
    set_gdbarch_deprecated_call_dummy_breakpoint_offset (current_gdbarch, 8);
d1409 1
a1409 2
/* When arguments must be pushed onto the stack, they go on in reverse
   order.  The code below implements a FILO (stack) to do this.  */
d1411 3
a1413 32
struct stack_item
{
  int len;
  struct stack_item *prev;
  void *data;
};

static struct stack_item *
push_stack_item (struct stack_item *prev, void *contents, int len)
{
  struct stack_item *si;
  si = xmalloc (sizeof (struct stack_item));
  si->data = xmalloc (len);
  si->len = len;
  si->prev = prev;
  memcpy (si->data, contents, len);
  return si;
}

static struct stack_item *
pop_stack_item (struct stack_item *si)
{
  struct stack_item *dead = si;
  si = si->prev;
  xfree (dead->data);
  xfree (dead);
  return si;
}

/* We currently only support passing parameters in integer registers.  This
   conforms with GCC's default model.  Several other variants exist and
   we should probably support some of them based on the selected ABI.  */
d1416 2
a1417 4
arm_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
		     struct regcache *regcache, CORE_ADDR bp_addr, int nargs,
		     struct value **args, CORE_ADDR sp, int struct_return,
		     CORE_ADDR struct_addr)
d1419 1
d1423 3
a1425 6
  struct stack_item *si = NULL;

  /* Set the return address.  For the ARM, the return breakpoint is
     always at BP_ADDR.  */
  /* XXX Fix for Thumb.  */
  regcache_cooked_write_unsigned (regcache, ARM_LR_REGNUM, bp_addr);
d1429 2
a1430 1
     passed on the stack, and we have to to push them.  */
d1432 15
a1446 40

  argreg = ARM_A1_REGNUM;
  nstack = 0;

  /* Some platforms require a double-word aligned stack.  Make sure sp
     is correctly aligned before we start.  We always do this even if
     it isn't really needed -- it can never hurt things.  */
  sp &= ~(CORE_ADDR)(2 * DEPRECATED_REGISTER_SIZE - 1);

  /* The struct_return pointer occupies the first parameter
     passing register.  */
  if (struct_return)
    {
      if (arm_debug)
	fprintf_unfiltered (gdb_stdlog, "struct return in %s = 0x%s\n",
			    REGISTER_NAME (argreg), paddr (struct_addr));
      regcache_cooked_write_unsigned (regcache, argreg, struct_addr);
      argreg++;
    }

  for (argnum = 0; argnum < nargs; argnum++)
    {
      int len;
      struct type *arg_type;
      struct type *target_type;
      enum type_code typecode;
      char *val;

      arg_type = check_typedef (VALUE_TYPE (args[argnum]));
      len = TYPE_LENGTH (arg_type);
      target_type = TYPE_TARGET_TYPE (arg_type);
      typecode = TYPE_CODE (arg_type);
      val = VALUE_CONTENTS (args[argnum]);

      /* If the argument is a pointer to a function, and it is a
	 Thumb function, create a LOCAL copy of the value and set
	 the THUMB bit in it.  */
      if (TYPE_CODE_PTR == typecode
	  && target_type != NULL
	  && TYPE_CODE_FUNC == TYPE_CODE (target_type))
d1448 1
a1448 2
	  CORE_ADDR regval = extract_unsigned_integer (val, len);
	  if (arm_pc_is_thumb (regval))
d1450 6
a1455 2
	      val = alloca (len);
	      store_unsigned_integer (val, len, MAKE_THUMB_ADDR (regval));
d1457 1
d1460 1
a1460 4
      /* Copy the argument to general registers or the stack in
	 register-sized pieces.  Large arguments are split between
	 registers and stack.  */
      while (len > 0)
d1462 19
a1480 3
	  int partial_len = len < DEPRECATED_REGISTER_SIZE ? len : DEPRECATED_REGISTER_SIZE;

	  if (argreg <= ARM_LAST_ARG_REGNUM)
d1482 6
a1487 9
	      /* The argument is being passed in a general purpose
		 register.  */
	      CORE_ADDR regval = extract_unsigned_integer (val, partial_len);
	      if (arm_debug)
		fprintf_unfiltered (gdb_stdlog, "arg %d in %s = 0x%s\n",
				    argnum, REGISTER_NAME (argreg),
				    phex (regval, DEPRECATED_REGISTER_SIZE));
	      regcache_cooked_write_unsigned (regcache, argreg, regval);
	      argreg++;
d1489 5
a1493 1
	  else
d1495 36
a1530 6
	      /* Push the arguments onto the stack.  */
	      if (arm_debug)
		fprintf_unfiltered (gdb_stdlog, "arg %d @@ sp + %d\n",
				    argnum, nstack);
	      si = push_stack_item (si, val, DEPRECATED_REGISTER_SIZE);
	      nstack += DEPRECATED_REGISTER_SIZE;
d1532 1
a1532 3
	      
	  len -= partial_len;
	  val += partial_len;
a1534 4
  /* If we have an odd number of words to push, then decrement the stack
     by one word now, so first stack argument will be dword aligned.  */
  if (nstack & 4)
    sp -= 4;
d1536 18
a1553 1
  while (si)
d1555 3
a1557 3
      sp -= si->len;
      write_memory (sp, si->data, si->len);
      si = pop_stack_item (si);
d1560 5
a1564 2
  /* Finally, update teh SP register.  */
  regcache_cooked_write_unsigned (regcache, ARM_SP_REGNUM, sp);
d1566 4
a1569 1
  return sp;
d1594 1
a1594 1
  unsigned long status = read_register (ARM_FPS_REGNUM);
d1697 1
a1697 2
convert_from_extended (const struct floatformat *fmt, const void *ptr,
		       void *dbl)
d1705 1
a1705 1
  floatformat_from_doublest (fmt, &d, dbl);
d1709 1
a1709 1
convert_to_extended (const struct floatformat *fmt, void *dbl, const void *ptr)
d1712 1
a1712 1
  floatformat_to_doublest (fmt, ptr, &d);
d1847 1
a1847 1
      offset = bitcount (bits (inst1, 0, 7)) * DEPRECATED_REGISTER_SIZE;
d2131 1
a2131 1
      static struct bfd fake_bfd;
d2250 2
a2251 2
			  struct regcache *regs,
			  void *dst)
a2252 2
  bfd_byte *valbuf = dst;

d2255 3
a2257 1
      switch (arm_get_fp_model (current_gdbarch))
d2260 2
a2261 10
	  {
	    /* The value is in register F0 in internal format.  We need to
	       extract the raw value and then convert it to the desired
	       internal type.  */
	    bfd_byte tmpbuf[FP_REGISTER_RAW_SIZE];

	    regcache_cooked_read (regs, ARM_F0_REGNUM, tmpbuf);
	    convert_from_extended (floatformat_from_type (type), tmpbuf,
				   valbuf);
	  }
d2264 1
a2264 1
	case ARM_FLOAT_SOFT_FPA:
d2266 2
a2267 4
	  regcache_cooked_read (regs, ARM_A1_REGNUM, valbuf);
	  if (TYPE_LENGTH (type) > 4)
	    regcache_cooked_read (regs, ARM_A1_REGNUM + 1,
				  valbuf + INT_REGISTER_RAW_SIZE);
a2276 26
  else if (TYPE_CODE (type) == TYPE_CODE_INT
	   || TYPE_CODE (type) == TYPE_CODE_CHAR
	   || TYPE_CODE (type) == TYPE_CODE_BOOL
	   || TYPE_CODE (type) == TYPE_CODE_PTR
	   || TYPE_CODE (type) == TYPE_CODE_REF
	   || TYPE_CODE (type) == TYPE_CODE_ENUM)
    {
      /* If the the type is a plain integer, then the access is
	 straight-forward.  Otherwise we have to play around a bit more.  */
      int len = TYPE_LENGTH (type);
      int regno = ARM_A1_REGNUM;
      ULONGEST tmp;

      while (len > 0)
	{
	  /* By using store_unsigned_integer we avoid having to do
	     anything special for small big-endian values.  */
	  regcache_cooked_read_unsigned (regs, regno++, &tmp);
	  store_unsigned_integer (valbuf, 
				  (len > INT_REGISTER_RAW_SIZE
				   ? INT_REGISTER_RAW_SIZE : len),
				  tmp);
	  len -= INT_REGISTER_RAW_SIZE;
	  valbuf += INT_REGISTER_RAW_SIZE;
	}
    }
d2278 2
a2279 17
    {
      /* For a structure or union the behaviour is as if the value had
         been stored to word-aligned memory and then loaded into 
         registers with 32-bit load instruction(s).  */
      int len = TYPE_LENGTH (type);
      int regno = ARM_A1_REGNUM;
      bfd_byte tmpbuf[INT_REGISTER_RAW_SIZE];

      while (len > 0)
	{
	  regcache_cooked_read (regs, regno++, tmpbuf);
	  memcpy (valbuf, tmpbuf,
		  len > INT_REGISTER_RAW_SIZE ? INT_REGISTER_RAW_SIZE : len);
	  len -= INT_REGISTER_RAW_SIZE;
	  valbuf += INT_REGISTER_RAW_SIZE;
	}
    }
d2302 1
a2302 1
  enum type_code code;
d2306 4
a2309 4
     must be less than or equal to DEPRECATED_REGISTER_SIZE and the
     offset of each addressable subfield must be zero.  Note that bit
     fields are not addressable, and all addressable subfields of
     unions always start at offset zero.
d2323 1
a2323 1
  if (TYPE_LENGTH (type) > DEPRECATED_REGISTER_SIZE)
d2345 5
a2349 5
         DEPRECATED_REGISTER_SIZE and the offset of each addressable
         subfield must be zero.  Note that bit fields are not
         addressable, and unions always start at offset zero.  If any
         of the subfields is a floating point type, the struct/union
         cannot be an integer type.  */
d2392 1
a2392 2
arm_store_return_value (struct type *type, struct regcache *regs,
			const void *src)
a2393 2
  const bfd_byte *valbuf = src;

d2396 1
d2399 1
a2399 1
      switch (arm_get_fp_model (current_gdbarch))
d2403 3
a2405 2
	  convert_to_extended (floatformat_from_type (type), buf, valbuf);
	  regcache_cooked_write (regs, ARM_F0_REGNUM, buf);
d2408 1
a2408 1
	case ARM_FLOAT_SOFT_FPA:
d2410 1
a2410 4
	  regcache_cooked_write (regs, ARM_A1_REGNUM, valbuf);
	  if (TYPE_LENGTH (type) > 4)
	    regcache_cooked_write (regs, ARM_A1_REGNUM + 1, 
				   valbuf + INT_REGISTER_RAW_SIZE);
d2420 3
a2422 13
  else if (TYPE_CODE (type) == TYPE_CODE_INT
	   || TYPE_CODE (type) == TYPE_CODE_CHAR
	   || TYPE_CODE (type) == TYPE_CODE_BOOL
	   || TYPE_CODE (type) == TYPE_CODE_PTR
	   || TYPE_CODE (type) == TYPE_CODE_REF
	   || TYPE_CODE (type) == TYPE_CODE_ENUM)
    {
      if (TYPE_LENGTH (type) <= 4)
	{
	  /* Values of one word or less are zero/sign-extended and
	     returned in r0.  */
	  bfd_byte tmpbuf[INT_REGISTER_RAW_SIZE];
	  LONGEST val = unpack_long (type, valbuf);
d2424 2
a2425 10
	  store_signed_integer (tmpbuf, INT_REGISTER_RAW_SIZE, val);
	  regcache_cooked_write (regs, ARM_A1_REGNUM, tmpbuf);
	}
      else
	{
	  /* Integral values greater than one word are stored in consecutive
	     registers starting with r0.  This will always be a multiple of
	     the regiser size.  */
	  int len = TYPE_LENGTH (type);
	  int regno = ARM_A1_REGNUM;
d2427 4
a2430 26
	  while (len > 0)
	    {
	      regcache_cooked_write (regs, regno++, valbuf);
	      len -= INT_REGISTER_RAW_SIZE;
	      valbuf += INT_REGISTER_RAW_SIZE;
	    }
	}
    }
  else
    {
      /* For a structure or union the behaviour is as if the value had
         been stored to word-aligned memory and then loaded into 
         registers with 32-bit load instruction(s).  */
      int len = TYPE_LENGTH (type);
      int regno = ARM_A1_REGNUM;
      bfd_byte tmpbuf[INT_REGISTER_RAW_SIZE];

      while (len > 0)
	{
	  memcpy (tmpbuf, valbuf,
		  len > INT_REGISTER_RAW_SIZE ? INT_REGISTER_RAW_SIZE : len);
	  regcache_cooked_write (regs, regno++, tmpbuf);
	  len -= INT_REGISTER_RAW_SIZE;
	  valbuf += INT_REGISTER_RAW_SIZE;
	}
    }
d2446 1
a2446 1
  *pc = extract_unsigned_integer (buf, INT_REGISTER_RAW_SIZE);
d2500 4
a2503 80
static void
set_arm_command (char *args, int from_tty)
{
  printf_unfiltered ("\"set arm\" must be followed by an apporpriate subcommand.\n");
  help_list (setarmcmdlist, "set arm ", all_commands, gdb_stdout);
}

static void
show_arm_command (char *args, int from_tty)
{
  cmd_show_list (showarmcmdlist, from_tty, "");
}

enum arm_float_model
arm_get_fp_model (struct gdbarch *gdbarch)
{
  if (arm_fp_model == ARM_FLOAT_AUTO)
    return gdbarch_tdep (gdbarch)->fp_model;

  return arm_fp_model;
}

static void
arm_set_fp (struct gdbarch *gdbarch)
{
  enum arm_float_model fp_model = arm_get_fp_model (gdbarch);

  if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_LITTLE 
      && (fp_model == ARM_FLOAT_SOFT_FPA || fp_model == ARM_FLOAT_FPA))
    {
      set_gdbarch_double_format	(gdbarch,
				 &floatformat_ieee_double_littlebyte_bigword);
      set_gdbarch_long_double_format
	(gdbarch, &floatformat_ieee_double_littlebyte_bigword);
    }
  else
    {
      set_gdbarch_double_format (gdbarch, &floatformat_ieee_double_little);
      set_gdbarch_long_double_format (gdbarch,
				      &floatformat_ieee_double_little);
    }
}

static void
set_fp_model_sfunc (char *args, int from_tty,
		    struct cmd_list_element *c)
{
  enum arm_float_model fp_model;

  for (fp_model = ARM_FLOAT_AUTO; fp_model != ARM_FLOAT_LAST; fp_model++)
    if (strcmp (current_fp_model, fp_model_strings[fp_model]) == 0)
      {
	arm_fp_model = fp_model;
	break;
      }

  if (fp_model == ARM_FLOAT_LAST)
    internal_error (__FILE__, __LINE__, "Invalid fp model accepted: %s.",
		    current_fp_model);

  if (gdbarch_bfd_arch_info (current_gdbarch)->arch == bfd_arch_arm)
    arm_set_fp (current_gdbarch);
}

static void
show_fp_model (char *args, int from_tty,
	       struct cmd_list_element *c)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  if (arm_fp_model == ARM_FLOAT_AUTO 
      && gdbarch_bfd_arch_info (current_gdbarch)->arch == bfd_arch_arm)
    printf_filtered ("  - the default for the current ABI is \"%s\".\n",
		     fp_model_strings[tdep->fp_model]);
}

/* If the user changes the register disassembly style used for info
   register and other commands, we have to also switch the style used
   in opcodes for disassembly output.  This function is run in the "set
   arm disassembly" command, and does that.  */
d2506 1
a2506 1
set_disassembly_style_sfunc (char *args, int from_tty,
d2509 1
a2509 1
  set_disassembly_style ();
d2520 1
a2520 1
set_disassembly_style (void)
d2525 1
a2525 1
  /* Find the style that the user wants in the opcodes table.  */
d2528 2
a2529 2
  while ((disassembly_style != setname)
	 && (current < num_disassembly_options))
d2553 4
a2556 2
/* arm_othernames implements the "othernames" command.  This is deprecated
   by the "set arm disassembly" command.  */
d2562 1
a2562 1
  current_option = (current_option + 1) % num_disassembly_options;
d2564 45
a2608 2
  disassembly_style = valid_disassembly_styles[current_option];
  set_disassembly_style ();
d2737 1
d2741 1
a2741 1
  if (info.abfd != NULL && info.osabi == GDB_OSABI_UNKNOWN)
d2743 2
a2744 1
      switch (bfd_get_flavour (info.abfd))
d2746 6
a2751 4
	case bfd_target_aout_flavour:
	  /* Assume it's an old APCS-style ABI.  */
	  info.osabi = GDB_OSABI_ARM_APCS;
	  break;
d2753 5
a2757 5
	case bfd_target_coff_flavour:
	  /* Assume it's an old APCS-style ABI.  */
	  /* XXX WinCE?  */
	  info.osabi = GDB_OSABI_ARM_APCS;
	  break;
d2759 3
a2761 3
	default:
	  /* Leave it as "unknown".  */
	  break;
d2765 10
a2774 4
  /* If there is already a candidate, use it.  */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;
d2779 4
a2782 4
  /* We used to default to FPA for generic ARM, but almost nobody uses that
     now, and we now provide a way for the user to force the model.  So 
     default to the most useful variant.  */
  tdep->fp_model = ARM_FLOAT_SOFT_FPA;
d2815 45
a2859 2
  set_gdbarch_deprecated_call_dummy_words (gdbarch, arm_call_dummy_words);
  set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, 0);
d2861 4
a2864 1
  set_gdbarch_push_dummy_call (gdbarch, arm_push_dummy_call);
d2867 4
a2870 4
  set_gdbarch_unwind_dummy_id (gdbarch, arm_unwind_dummy_id);
  set_gdbarch_unwind_pc (gdbarch, arm_unwind_pc);
  set_gdbarch_unwind_sp (gdbarch, arm_unwind_sp);

d2873 4
d2878 11
a2888 2

  frame_base_set_default (gdbarch, &arm_normal_base);
d2901 1
a2901 1
  set_gdbarch_deprecated_saved_pc_after_call (gdbarch, arm_saved_pc_after_call);
d2912 1
a2912 1
  set_gdbarch_deprecated_fp_regnum (gdbarch, ARM_FP_REGNUM);	/* ??? */
d2915 5
a2919 5
  set_gdbarch_deprecated_register_byte (gdbarch, arm_register_byte);
  set_gdbarch_deprecated_register_bytes (gdbarch,
					 (NUM_GREGS * INT_REGISTER_RAW_SIZE
					  + NUM_FREGS * FP_REGISTER_RAW_SIZE
					  + NUM_SREGS * STATUS_REGISTER_SIZE));
d2921 5
a2925 5
  set_gdbarch_deprecated_register_raw_size (gdbarch, arm_register_raw_size);
  set_gdbarch_deprecated_register_virtual_size (gdbarch, arm_register_virtual_size);
  set_gdbarch_deprecated_max_register_raw_size (gdbarch, FP_REGISTER_RAW_SIZE);
  set_gdbarch_deprecated_max_register_virtual_size (gdbarch, FP_REGISTER_VIRTUAL_SIZE);
  set_gdbarch_deprecated_register_virtual_type (gdbarch, arm_register_type);
d2931 1
a2931 1
  set_gdbarch_deprecated_register_size (gdbarch, 4);
d2935 3
a2937 2
  set_gdbarch_extract_return_value (gdbarch, arm_extract_return_value);
  set_gdbarch_store_return_value (gdbarch, arm_store_return_value);
a2945 3
  /* Disassembly.  */
  set_gdbarch_print_insn (gdbarch, gdb_print_insn_arm);

d2952 1
a2952 5
  gdbarch_init_osabi (info, gdbarch);

  /* Add some default predicates.  */
  frame_unwind_append_sniffer (gdbarch, arm_sigtramp_unwind_sniffer);
  frame_unwind_append_sniffer (gdbarch, arm_prologue_unwind_sniffer);
d2972 14
a2985 1
      arm_set_fp (gdbarch);
d2993 14
d3018 3
a3045 2
extern initialize_file_ftype _initialize_arm_tdep; /* -Wmissing-prototypes */

d3051 1
a3051 1
  struct cmd_list_element *new_set, *new_show;
d3058 2
a3059 1
  gdbarch_register (bfd_arch_arm, arm_gdbarch_init, arm_dump_tdep);
d3067 1
a3067 1
  gdbarch_register_osabi (bfd_arch_arm, 0, GDB_OSABI_ARM_EABI_V1,
d3069 1
a3069 1
  gdbarch_register_osabi (bfd_arch_arm, 0, GDB_OSABI_ARM_EABI_V2,
d3071 1
a3071 1
  gdbarch_register_osabi (bfd_arch_arm, 0, GDB_OSABI_ARM_APCS,
d3074 2
d3077 1
a3077 10
  num_disassembly_options = get_arm_regname_num_options ();

  /* Add root prefix command for all "set arm"/"show arm" commands.  */
  add_prefix_cmd ("arm", no_class, set_arm_command,
		  "Various ARM-specific commands.",
		  &setarmcmdlist, "set arm ", 0, &setlist);

  add_prefix_cmd ("arm", no_class, show_arm_command,
		  "Various ARM-specific commands.",
		  &showarmcmdlist, "show arm ", 0, &showlist);
d3084 2
a3085 2
  fprintf_unfiltered (stb, "Set the disassembly style.\n"
		      "The valid values are:\n");
d3088 2
a3089 3
  valid_disassembly_styles
    = xmalloc ((num_disassembly_options + 1) * sizeof (char *));
  for (i = 0; i < num_disassembly_options; i++)
d3092 1
a3092 1
      valid_disassembly_styles[i] = setname;
d3098 1
a3098 1
          disassembly_style = setname;
d3106 1
a3106 1
  valid_disassembly_styles[num_disassembly_options] = NULL;
d3113 4
a3116 4
  /* Add the deprecated disassembly-flavor command.  */
  new_set = add_set_enum_cmd ("disassembly-flavor", no_class,
			      valid_disassembly_styles,
			      &disassembly_style,
d3119 8
a3126 42
  set_cmd_sfunc (new_set, set_disassembly_style_sfunc);
  deprecate_cmd (new_set, "set arm disassembly");
  deprecate_cmd (add_show_from_set (new_set, &showlist),
		 "show arm disassembly");

  /* And now add the new interface.  */
  new_set = add_set_enum_cmd ("disassembler", no_class,
			      valid_disassembly_styles, &disassembly_style,
			      helptext, &setarmcmdlist);

  set_cmd_sfunc (new_set, set_disassembly_style_sfunc);
  add_show_from_set (new_set, &showarmcmdlist);

  add_setshow_cmd_full ("apcs32", no_class,
			var_boolean, (char *) &arm_apcs_32,
			"Set usage of ARM 32-bit mode.",
			"Show usage of ARM 32-bit mode.",
			NULL, NULL,
			&setlist, &showlist, &new_set, &new_show);
  deprecate_cmd (new_set, "set arm apcs32");
  deprecate_cmd (new_show, "show arm apcs32");

  add_setshow_boolean_cmd ("apcs32", no_class, &arm_apcs_32,
			   "Set usage of ARM 32-bit mode.  "
			   "When off, a 26-bit PC will be used.",
			   "Show usage of ARM 32-bit mode.  "
			   "When off, a 26-bit PC will be used.",
			   NULL, NULL,
			   &setarmcmdlist, &showarmcmdlist);

  /* Add a command to allow the user to force the FPU model.  */
  new_set = add_set_enum_cmd
    ("fpu", no_class, fp_model_strings, &current_fp_model,
     "Set the floating point type.\n"
     "auto - Determine the FP typefrom the OS-ABI.\n"
     "softfpa - Software FP, mixed-endian doubles on little-endian ARMs.\n"
     "fpa - FPA co-processor (GCC compiled).\n"
     "softvfp - Software FP with pure-endian doubles.\n"
     "vfp - VFP co-processor.",
     &setarmcmdlist);
  set_cmd_sfunc (new_set, set_fp_model_sfunc);
  set_cmd_sfunc (add_show_from_set (new_set, &showarmcmdlist), show_fp_model);
d3129 8
a3136 3
  deprecate_cmd (add_com ("othernames", class_obscure, arm_othernames,
			  "Switch to the next set of register names."),
		 "set arm disassembly");
d3139 4
a3142 7
  add_setshow_boolean_cmd ("arm", class_maintenance, &arm_debug,
			   "Set ARM debugging.  "
			   "When on, arm-specific debugging is enabled.",
			   "Show ARM debugging.  "
			   "When on, arm-specific debugging is enabled.",
			   NULL, NULL,
			   &setdebuglist, &showdebuglist);
@


1.73.4.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004 Free Software Foundation, Inc.
a2691 15
static void
arm_write_pc (CORE_ADDR pc, ptid_t ptid)
{
  write_register_pid (ARM_PC_REGNUM, pc, ptid);

  /* If necessary, set the T bit.  */
  if (arm_apcs_32)
    {
      CORE_ADDR val = read_register_pid (ARM_PS_REGNUM, ptid);
      if (arm_pc_is_thumb (pc))
	write_register_pid (ARM_PS_REGNUM, val | 0x20, ptid);
      else
	write_register_pid (ARM_PS_REGNUM, val & ~(CORE_ADDR) 0x20, ptid);
    }
}
a2853 2
  set_gdbarch_write_pc (gdbarch, arm_write_pc);

d2869 3
d2883 1
d2913 2
a2914 1
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, arm_extract_struct_value_address);
@


1.73.2.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d2404 2
a2405 2
	  deprecated_write_register_bytes (REGISTER_BYTE (ARM_F0_REGNUM), buf,
					   FP_REGISTER_RAW_SIZE);
d2410 1
a2410 2
	  deprecated_write_register_bytes (ARM_A1_REGNUM, valbuf,
					   TYPE_LENGTH (type));
d2421 1
a2421 2
    deprecated_write_register_bytes (ARM_A1_REGNUM, valbuf,
				     TYPE_LENGTH (type));
d2861 1
a2861 1
  set_gdbarch_get_saved_register (gdbarch, deprecated_generic_get_saved_register);
@


1.73.2.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d134 1
a134 4
static void convert_from_extended (const struct floatformat *, const void *,
				   void *);
static void convert_to_extended (const struct floatformat *, void *,
				 const void *);
d218 1
a218 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (memaddr, sp, sp + 1024))
d413 2
a414 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (pc, 0, 0))
d539 3
a541 2
  if (fi != NULL
      && DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, 0, 0))
d995 2
a996 1
      if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, 0, 0))
d1015 3
a1017 3
   GDB frame struct, and then INIT_EXTRA_FRAME_INFO and
   DEPRECATED_INIT_FRAME_PC will be called for the new frame.  For
   ARM, we save the frame size when we initialize the frame_info.  */
d1025 2
a1026 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, 0, 0))
d1109 2
a1110 1
  else if (DEPRECATED_PC_IN_CALL_DUMMY (fi->next->pc, 0, 0))
d1120 5
a1124 6
     Unfortunately, it isn't sufficient to test (get_frame_type (fi)
     == SIGTRAMP_FRAME) because this value is sometimes set after
     invoking INIT_EXTRA_FRAME_INFO.  So we test *both*
     (get_frame_type (fi) == SIGTRAMP_FRAME) and PC_IN_SIGTRAMP to
     determine if we need to use the sigcontext addresses for the
     saved registers.
a1130 4
  /* FIXME: cagney/2002-11-18: This problem will go away once
     frame.c:get_prev_frame() is modified to set the frame's type
     before calling functions like this.  */

d1132 1
a1132 1
      && ((get_frame_type (fi) == SIGTRAMP_FRAME) || PC_IN_SIGTRAMP (fi->pc, (char *)0)))
d1146 27
d1180 2
a1181 1
      else if (DEPRECATED_PC_IN_CALL_DUMMY (fi->next->pc, 0, 0))
d1222 2
a1223 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, 0, 0))
d1226 1
a1226 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, fi->frame - fi->extra_info->frameoffset,
d1552 2
a1553 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
d1697 1
a1697 2
convert_from_extended (const struct floatformat *fmt, const void *ptr,
		       void *dbl)
d1705 1
a1705 1
  floatformat_from_doublest (fmt, &d, dbl);
d1709 1
a1709 1
convert_to_extended (const struct floatformat *fmt, void *dbl, const void *ptr)
d1712 1
a1712 1
  floatformat_to_doublest (fmt, ptr, &d);
d2250 2
a2251 2
			  struct regcache *regs,
			  void *dst)
a2252 2
  bfd_byte *valbuf = dst;

d2260 2
a2261 10
	  {
	    /* The value is in register F0 in internal format.  We need to
	       extract the raw value and then convert it to the desired
	       internal type.  */
	    bfd_byte tmpbuf[FP_REGISTER_RAW_SIZE];

	    regcache_cooked_read (regs, ARM_F0_REGNUM, tmpbuf);
	    convert_from_extended (floatformat_from_type (type), tmpbuf,
				   valbuf);
	  }
d2266 2
a2267 4
	  regcache_cooked_read (regs, ARM_A1_REGNUM, valbuf);
	  if (TYPE_LENGTH (type) > 4)
	    regcache_cooked_read (regs, ARM_A1_REGNUM + 1,
				  valbuf + INT_REGISTER_RAW_SIZE);
a2276 26
  else if (TYPE_CODE (type) == TYPE_CODE_INT
	   || TYPE_CODE (type) == TYPE_CODE_CHAR
	   || TYPE_CODE (type) == TYPE_CODE_BOOL
	   || TYPE_CODE (type) == TYPE_CODE_PTR
	   || TYPE_CODE (type) == TYPE_CODE_REF
	   || TYPE_CODE (type) == TYPE_CODE_ENUM)
    {
      /* If the the type is a plain integer, then the access is
	 straight-forward.  Otherwise we have to play around a bit more.  */
      int len = TYPE_LENGTH (type);
      int regno = ARM_A1_REGNUM;
      ULONGEST tmp;

      while (len > 0)
	{
	  /* By using store_unsigned_integer we avoid having to do
	     anything special for small big-endian values.  */
	  regcache_cooked_read_unsigned (regs, regno++, &tmp);
	  store_unsigned_integer (valbuf, 
				  (len > INT_REGISTER_RAW_SIZE
				   ? INT_REGISTER_RAW_SIZE : len),
				  tmp);
	  len -= INT_REGISTER_RAW_SIZE;
	  valbuf += INT_REGISTER_RAW_SIZE;
	}
    }
d2278 2
a2279 17
    {
      /* For a structure or union the behaviour is as if the value had
         been stored to word-aligned memory and then loaded into 
         registers with 32-bit load instruction(s).  */
      int len = TYPE_LENGTH (type);
      int regno = ARM_A1_REGNUM;
      bfd_byte tmpbuf[INT_REGISTER_RAW_SIZE];

      while (len > 0)
	{
	  regcache_cooked_read (regs, regno++, tmpbuf);
	  memcpy (valbuf, tmpbuf,
		  len > INT_REGISTER_RAW_SIZE ? INT_REGISTER_RAW_SIZE : len);
	  len -= INT_REGISTER_RAW_SIZE;
	  valbuf += INT_REGISTER_RAW_SIZE;
	}
    }
d2392 1
a2392 2
arm_store_return_value (struct type *type, struct regcache *regs,
			const void *src)
a2393 2
  const bfd_byte *valbuf = src;

d2403 3
a2405 2
	  convert_to_extended (floatformat_from_type (type), buf, valbuf);
	  regcache_cooked_write (regs, ARM_F0_REGNUM, buf);
d2410 2
a2411 4
	  regcache_cooked_write (regs, ARM_A1_REGNUM, valbuf);
	  if (TYPE_LENGTH (type) > 4)
	    regcache_cooked_write (regs, ARM_A1_REGNUM + 1, 
				   valbuf + INT_REGISTER_RAW_SIZE);
a2420 33
  else if (TYPE_CODE (type) == TYPE_CODE_INT
	   || TYPE_CODE (type) == TYPE_CODE_CHAR
	   || TYPE_CODE (type) == TYPE_CODE_BOOL
	   || TYPE_CODE (type) == TYPE_CODE_PTR
	   || TYPE_CODE (type) == TYPE_CODE_REF
	   || TYPE_CODE (type) == TYPE_CODE_ENUM)
    {
      if (TYPE_LENGTH (type) <= 4)
	{
	  /* Values of one word or less are zero/sign-extended and
	     returned in r0.  */
	  bfd_byte tmpbuf[INT_REGISTER_RAW_SIZE];
	  LONGEST val = unpack_long (type, valbuf);

	  store_signed_integer (tmpbuf, INT_REGISTER_RAW_SIZE, val);
	  regcache_cooked_write (regs, ARM_A1_REGNUM, tmpbuf);
	}
      else
	{
	  /* Integral values greater than one word are stored in consecutive
	     registers starting with r0.  This will always be a multiple of
	     the regiser size.  */
	  int len = TYPE_LENGTH (type);
	  int regno = ARM_A1_REGNUM;

	  while (len > 0)
	    {
	      regcache_cooked_write (regs, regno++, valbuf);
	      len -= INT_REGISTER_RAW_SIZE;
	      valbuf += INT_REGISTER_RAW_SIZE;
	    }
	}
    }
d2422 2
a2423 17
    {
      /* For a structure or union the behaviour is as if the value had
         been stored to word-aligned memory and then loaded into 
         registers with 32-bit load instruction(s).  */
      int len = TYPE_LENGTH (type);
      int regno = ARM_A1_REGNUM;
      bfd_byte tmpbuf[INT_REGISTER_RAW_SIZE];

      while (len > 0)
	{
	  memcpy (tmpbuf, valbuf,
		  len > INT_REGISTER_RAW_SIZE ? INT_REGISTER_RAW_SIZE : len);
	  regcache_cooked_write (regs, regno++, tmpbuf);
	  len -= INT_REGISTER_RAW_SIZE;
	  valbuf += INT_REGISTER_RAW_SIZE;
	}
    }
a2780 4
  /* NOTE: cagney/2002-12-06: This can be deleted when this arch is
     ready to unwind the PC first (see frame.c:get_prev_frame()).  */
  set_gdbarch_deprecated_init_frame_pc (gdbarch, init_frame_pc_default);

d2817 28
d2857 1
d2861 1
d2863 1
d2881 7
d2889 1
d2937 2
a2938 2
  set_gdbarch_extract_return_value (gdbarch, arm_extract_return_value);
  set_gdbarch_store_return_value (gdbarch, arm_store_return_value);
d3069 1
a3069 1
  gdbarch_register_osabi (bfd_arch_arm, 0, GDB_OSABI_ARM_EABI_V1,
d3071 1
a3071 1
  gdbarch_register_osabi (bfd_arch_arm, 0, GDB_OSABI_ARM_EABI_V2,
d3073 1
a3073 1
  gdbarch_register_osabi (bfd_arch_arm, 0, GDB_OSABI_ARM_APCS,
@


1.73.2.3
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d3 1
a3 1
   2001, 2002, 2003 Free Software Foundation, Inc.
a36 1
#include "osabi.h"
d161 1
a161 1
  return (FRAME_SAVED_PC (thisframe) >= LOWEST_PC);
d278 1
a278 1
  func_start = (get_pc_function_start (get_frame_pc (fi)) + FUNCTION_START_OFFSET);
d293 1
a293 1
  return get_frame_base (fi);
d300 1
a300 1
  return get_frame_base (fi);
d542 1
a542 1
      && DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (fi), 0, 0))
d545 1
a545 1
  if (find_pc_partial_function (get_frame_pc (fi), NULL, &prologue_start, &prologue_end))
d550 1
a550 1
	prologue_end = get_frame_pc (fi);
d559 1
a559 1
  prologue_end = min (prologue_end, get_frame_pc (fi));
d570 1
a570 1
  get_frame_extra_info (fi)->framesize = 0;
d593 3
a595 3
		get_frame_extra_info (fi)->framesize += 4;
		get_frame_saved_regs (fi)[saved_reg[regno]] =
		  -(get_frame_extra_info (fi)->framesize);
d611 1
a611 1
	      get_frame_extra_info (fi)->frameoffset += offset;
d614 1
a614 1
	  get_frame_extra_info (fi)->framesize -= offset;
d619 1
a619 1
	  get_frame_extra_info (fi)->framereg = THUMB_FP_REGNUM;
d621 1
a621 1
	  get_frame_extra_info (fi)->frameoffset = (insn & 0xff) << 2;
d626 2
a627 2
	  get_frame_extra_info (fi)->framereg = THUMB_FP_REGNUM;
	  get_frame_extra_info (fi)->frameoffset = 0;
d660 1
a660 1
static struct frame_info *prologue_cache;
d667 1
a667 1
  if (get_frame_pc (fi) == get_frame_pc (prologue_cache))
d669 3
a671 3
      get_frame_extra_info (fi)->framereg = get_frame_extra_info (prologue_cache)->framereg;
      get_frame_extra_info (fi)->framesize = get_frame_extra_info (prologue_cache)->framesize;
      get_frame_extra_info (fi)->frameoffset = get_frame_extra_info (prologue_cache)->frameoffset;
d673 1
a673 1
	get_frame_saved_regs (fi)[i] = get_frame_saved_regs (prologue_cache)[i];
d688 4
a691 4
  deprecated_update_frame_pc_hack (prologue_cache, get_frame_pc (fi));
  get_frame_extra_info (prologue_cache)->framereg = get_frame_extra_info (fi)->framereg;
  get_frame_extra_info (prologue_cache)->framesize = get_frame_extra_info (fi)->framesize;
  get_frame_extra_info (prologue_cache)->frameoffset = get_frame_extra_info (fi)->frameoffset;
d694 1
a694 1
    get_frame_saved_regs (prologue_cache)[i] = get_frame_saved_regs (fi)[i];
d777 3
a779 3
  get_frame_extra_info (fi)->framereg = ARM_SP_REGNUM;
  get_frame_extra_info (fi)->framesize = 0;
  get_frame_extra_info (fi)->frameoffset = 0;
d782 1
a782 1
  if (arm_pc_is_thumb (get_frame_pc (fi)))
d791 1
a791 1
  if (find_pc_partial_function (get_frame_pc (fi), NULL, &prologue_start, &prologue_end))
d799 1
a799 1
	      prologue_end = get_frame_pc (fi);
d834 1
a834 1
      if (!safe_read_memory_integer (get_frame_base (fi), 4,  &return_value))
d893 1
a893 1
		get_frame_saved_regs (fi)[regno] = sp_offset;
d916 1
a916 1
	  get_frame_extra_info (fi)->framereg = ARM_FP_REGNUM;
d929 1
a929 1
	  get_frame_saved_regs (fi)[regno] = sp_offset;
d956 1
a956 1
	      get_frame_saved_regs (fi)[fp_start_reg++] = sp_offset;
d972 3
a974 3
  get_frame_extra_info (fi)->framesize = -sp_offset;
  if (get_frame_extra_info (fi)->framereg == ARM_FP_REGNUM)
    get_frame_extra_info (fi)->frameoffset = fp_offset - sp_offset;
d976 1
a976 1
    get_frame_extra_info (fi)->frameoffset = 0;
d994 1
a994 1
  for (; fi; fi = get_next_frame (fi))
d996 1
a996 1
      if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (fi), 0, 0))
d998 1
a998 2
	  return deprecated_read_register_dummy (get_frame_pc (fi),
						 get_frame_base (fi), regnum);
d1000 1
a1000 1
      else if (get_frame_saved_regs (fi)[regnum] != 0)
d1007 1
a1007 1
	  return read_memory_integer (get_frame_saved_regs (fi)[regnum],
d1023 1
a1023 1
  int framereg = get_frame_extra_info (fi)->framereg;
d1025 1
a1025 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (fi), 0, 0))
d1027 1
a1027 1
    return get_frame_base (fi);
d1029 1
a1029 1
  if (get_frame_pc (fi) < LOWEST_PC)
d1041 1
a1041 1
  if (arm_pc_is_thumb (caller_pc) != arm_pc_is_thumb (get_frame_pc (fi)))
d1043 12
a1054 4
      struct cleanup *old_chain = make_cleanup (null_cleanup, NULL);
      struct frame_info *caller_fi =
	deprecated_frame_xmalloc_with_cleanup (SIZEOF_FRAME_SAVED_REGS,
					       sizeof (struct frame_extra_info));
d1057 3
a1059 3
      deprecated_update_frame_pc_hack (caller_fi, caller_pc);
      arm_scan_prologue (caller_fi);
      framereg = get_frame_extra_info (caller_fi)->framereg;
d1071 1
a1071 1
    return get_frame_base (fi) + get_frame_extra_info (fi)->framesize;
d1089 1
a1089 1
  if (get_frame_saved_regs (fi) == NULL)
d1092 2
a1093 1
  frame_extra_info_zalloc (fi, sizeof (struct frame_extra_info));
d1095 3
a1097 3
  get_frame_extra_info (fi)->framesize = 0;
  get_frame_extra_info (fi)->frameoffset = 0;
  get_frame_extra_info (fi)->framereg = 0;
d1099 2
a1100 2
  if (get_next_frame (fi))
    deprecated_update_frame_pc_hack (fi, FRAME_SAVED_PC (get_next_frame (fi)));
d1102 1
a1102 1
  memset (get_frame_saved_regs (fi), '\000', sizeof get_frame_saved_regs (fi));
d1106 1
a1106 1
  if (!get_next_frame (fi))
d1108 1
a1108 1
  else if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (get_next_frame (fi)), 0, 0))
d1111 1
a1111 2
    sp = deprecated_read_register_dummy (get_frame_pc (get_next_frame (fi)),
					 get_frame_base (get_next_frame (fi)),
d1114 2
a1115 3
    sp = (get_frame_base (get_next_frame (fi))
	  - get_frame_extra_info (get_next_frame (fi))->frameoffset
	  + get_frame_extra_info (get_next_frame (fi))->framesize);
d1135 1
a1135 1
      && ((get_frame_type (fi) == SIGTRAMP_FRAME) || PC_IN_SIGTRAMP (get_frame_pc (fi), (char *)0)))
d1138 1
a1138 1
	get_frame_saved_regs (fi)[reg] = SIGCONTEXT_REGISTER_ADDRESS (sp, get_frame_pc (fi), reg);
d1141 6
a1146 4
      get_frame_extra_info (fi)->framereg = ARM_SP_REGNUM;
      deprecated_update_frame_base_hack (fi, read_memory_integer (get_frame_saved_regs (fi)[get_frame_extra_info (fi)->framereg], REGISTER_RAW_SIZE (get_frame_extra_info (fi)->framereg)));
      get_frame_extra_info (fi)->framesize = 0;
      get_frame_extra_info (fi)->frameoffset = 0;
d1153 1
a1153 1
      if (!get_next_frame (fi))
d1155 2
a1156 2
	deprecated_update_frame_base_hack (fi, read_register (get_frame_extra_info (fi)->framereg));
      else if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (get_next_frame (fi)), 0, 0))
d1159 3
a1161 3
	deprecated_update_frame_base_hack (fi, get_frame_base (get_next_frame (fi)));
      else if (get_frame_extra_info (fi)->framereg == ARM_FP_REGNUM
	       || get_frame_extra_info (fi)->framereg == THUMB_FP_REGNUM)
d1165 4
a1168 2
	  if (get_frame_saved_regs (get_next_frame (fi))[get_frame_extra_info (fi)->framereg] != 0)
	    deprecated_update_frame_base_hack (fi, read_memory_integer (get_frame_saved_regs (get_next_frame (fi))[get_frame_extra_info (fi)->framereg], 4));
d1172 1
a1172 1
	    deprecated_update_frame_base_hack (fi, read_fp ());
d1178 3
a1180 5
	if (get_frame_saved_regs (fi)[reg] != 0)
	  get_frame_saved_regs (fi)[reg]
	    += (get_frame_base (fi)
		+ get_frame_extra_info (fi)->framesize
		- get_frame_extra_info (fi)->frameoffset);
d1197 5
a1201 8
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (fi), 0, 0))
    return deprecated_read_register_dummy (get_frame_pc (fi),
					   get_frame_base (fi), ARM_PC_REGNUM);

  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (fi),
				   (get_frame_base (fi)
				    - get_frame_extra_info (fi)->frameoffset),
				   get_frame_base (fi)))
d1203 1
a1203 1
      return read_memory_integer (get_frame_saved_regs (fi)[ARM_PC_REGNUM],
d1235 1
a1235 1
  if (get_frame_saved_regs (fip))
d1510 1
a1510 1
  /* Return the bottom of the argument list (pointed to by fp).  */
d1523 4
a1526 7
  CORE_ADDR old_SP = (get_frame_base (frame)
		      - get_frame_extra_info (frame)->frameoffset
		      + get_frame_extra_info (frame)->framesize);

  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame),
				   get_frame_base (frame),
				   get_frame_base (frame)))
d1534 1
a1534 1
    if (get_frame_saved_regs (frame)[regnum] != 0)
d1536 1
a1536 1
		  read_memory_integer (get_frame_saved_regs (frame)[regnum],
d2818 1
d2822 1
a2822 1
  if (info.abfd != NULL && info.osabi == GDB_OSABI_UNKNOWN)
d2824 2
a2825 1
      switch (bfd_get_flavour (info.abfd))
d2827 6
a2832 4
	case bfd_target_aout_flavour:
	  /* Assume it's an old APCS-style ABI.  */
	  info.osabi = GDB_OSABI_ARM_APCS;
	  break;
d2834 5
a2838 5
	case bfd_target_coff_flavour:
	  /* Assume it's an old APCS-style ABI.  */
	  /* XXX WinCE?  */
	  info.osabi = GDB_OSABI_ARM_APCS;
	  break;
d2840 3
a2842 2
	default:
	  /* Leave it as "unknown".  */
d2846 10
a2855 4
  /* If there is already a candidate, use it.  */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;
d2864 2
d2917 2
d2998 1
a2998 1
  gdbarch_init_osabi (info, gdbarch);
d3042 2
a3043 2
  if (get_frame_saved_regs (prologue_cache) != NULL)
    xfree (get_frame_saved_regs (prologue_cache));
d3048 4
a3051 6
  {
    CORE_ADDR *saved_regs = xcalloc (1, (sizeof (CORE_ADDR)
					 * (gdbarch_num_regs (gdbarch)
					    + gdbarch_num_pseudo_regs (gdbarch))));
    deprecated_set_frame_saved_regs_hack (prologue_cache, saved_regs);
  }
d3064 3
d3179 4
a3182 3
  /* Allocate the prologue_cache.  */
  prologue_cache = deprecated_frame_xmalloc ();
  deprecated_set_frame_extra_info_hack (prologue_cache, xcalloc (1, sizeof (struct frame_extra_info)));
@


1.73.2.4
log
@2003-02-21  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (locate_compound_sym): Update call to
	lookup_symbol_namespace.
	* symtab.c (make_symbol_overload_list): Delete namespace_len
	argument.
	* symtab.h: Update declaration for make_symbol_overload_list.
	* valops.c (find_oload_champ_namespace_loop): New format for
	make_symbol_overload_list.
	* symtab.c (lookup_symbol_namespace): Delete namespace_len
	argument.
	(lookup_symbol_aux_using_loop): Update call to
	lookup_symbol_namespace.
	(make_symbol_overload_list_using): Delete namespace_len argument.
	* linespec.c (decode_namespace): Update call to
	lookup_symbol_namespace.
	* valops.c (value_namespace_elt): Ditto.
	* symtab.c (lookup_nested_type): Ditto.
	* symtab.h: Update declaration for lookup_symbol_namespace.
	* block.c (block_all_usings): Delete.
	(block_using): Make static.
	(block_using_iterator_next): New using_direct format.
	(block_using_iterator_first): Ditto.
	* buildsym.c (scan_for_anonymous_namespaces): Rename variables.
	(add_using_directive): New using functions.
	(end_symtab): Use cp_copy_usings.
	(copy_usings_to_obstack): Delete.
	* block.c: Tweak initial comment.
	(struct namespace_info): Move here.
	(block_initialize_namespace): Set scope to NULL!
	* block.h: Add compilation guards.
	Reorder and update declarations.
	* cp-support.c (cp_find_first_component): Return unsigned int.
	(cp_entire_prefix_len): New.
	(cp_add_using_obstack): Delete.
	(cp_add_using_xmalloc): Delete.
	(cp_copy_usings): Rewrite.
	(cp_free_usings): Delete.
	(cp_add_using): New.
	(cp_is_anonymous): Delete second argument.
	(xstrndup): New.
	* cp-support.h: Add compilation guards.
	Update declarations.
	* coffread.c: New variable coff_source_file.
	(coff_start_symtab): Use coff_source_file.
	(complete_symtab): Ditto.
	(coff_end_symtab): Ditto.
	(coff_symtab_read): Ditto.
	* dbxread.c (find_stab_function_addr): Const fix.
	* buildsym.h: Const fix.
	* buildsym.c (start_symtab): Const fix.
	(start_subfile): Ditto.
	* cp-support.c (cp_add_using_xmalloc): Copy name.
	* dwarf2read.c (read_namespace): Loop through extensions
	correctly.
	(read_file_scope): Const fix.
	(dwarf2_add_field): Ditto.
	(read_structure_scope): Ditto.
	(read_enumeration): Ditto.
	(read_typedef): Ditto.
	* buildsym.c (finish_block): Update comments and simplify code
	when setting scope.
	* buildsym.h: Add opaque declaration of 'struct block'.
	Change comment before processing_current_prefix.
	* arm-tdep.c (arm_gdbarch_init): Add break; after default:.
@
text
@a2836 1
	  break;
@


1.73.2.5
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d1017 1
a1017 1
   GDB frame struct, and then DEPRECATED_INIT_EXTRA_FRAME_INFO and
d1115 1
a1115 1
     invoking DEPRECATED_INIT_EXTRA_FRAME_INFO.  So we test *both*
d2104 1
a2104 1
      static struct bfd fake_bfd;
d2907 1
a2907 1
  set_gdbarch_deprecated_init_extra_frame_info (gdbarch, arm_init_extra_frame_info);
d2917 2
a2918 1
  set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, arm_frame_init_saved_regs);
d2954 2
a2955 2
  set_gdbarch_deprecated_max_register_raw_size (gdbarch, FP_REGISTER_RAW_SIZE);
  set_gdbarch_deprecated_max_register_virtual_size (gdbarch, FP_REGISTER_VIRTUAL_SIZE);
@


1.73.2.6
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d31 1
a31 1
#include "dis-asm.h"		/* For register styles. */
a101 19
/* The list of available "set arm ..." and "show arm ..." commands.  */
static struct cmd_list_element *setarmcmdlist = NULL;
static struct cmd_list_element *showarmcmdlist = NULL;

/* The type of floating-point to use.  Keep this in sync with enum
   arm_float_model, and the help string in _initialize_arm_tdep.  */
static const char *fp_model_strings[] =
{
  "auto",
  "softfpa",
  "fpa",
  "softvfp",
  "vfp"
};

/* A variable that can be configured by the user.  */
static enum arm_float_model arm_fp_model = ARM_FLOAT_AUTO;
static const char *current_fp_model = "auto";

d103 1
a103 1
static int num_disassembly_options;
d121 2
a122 2
/* Valid register name styles.  */
static const char **valid_disassembly_styles;
d124 2
a125 2
/* Disassembly style to use. Default to "std" register names.  */
static const char *disassembly_style;
d130 2
a131 2
   style.  */
static void set_disassembly_style_sfunc(char *, int,
d133 1
a133 1
static void set_disassembly_style (void);
d162 1
a162 1
  return (DEPRECATED_FRAME_SAVED_PC (thisframe) >= LOWEST_PC);
d279 1
a279 1
  func_start = (get_frame_func (fi) + FUNCTION_START_OFFSET);
d645 54
d773 4
d786 1
d978 2
d1035 1
a1035 1
  caller_pc = DEPRECATED_FRAME_SAVED_PC (fi);
d1093 1
a1093 1
    deprecated_update_frame_pc_hack (fi, DEPRECATED_FRAME_SAVED_PC (get_next_frame (fi)));
d1379 131
d1538 1
a1538 1
  write_register (ARM_PC_REGNUM, DEPRECATED_FRAME_SAVED_PC (frame));
a1543 155
/* When arguments must be pushed onto the stack, they go on in reverse
   order.  The code below implements a FILO (stack) to do this.  */

struct stack_item
{
  int len;
  struct stack_item *prev;
  void *data;
};

static struct stack_item *
push_stack_item (struct stack_item *prev, void *contents, int len)
{
  struct stack_item *si;
  si = xmalloc (sizeof (struct stack_item));
  si->data = xmalloc (len);
  si->len = len;
  si->prev = prev;
  memcpy (si->data, contents, len);
  return si;
}

static struct stack_item *
pop_stack_item (struct stack_item *si)
{
  struct stack_item *dead = si;
  si = si->prev;
  xfree (dead->data);
  xfree (dead);
  return si;
}

/* We currently only support passing parameters in integer registers.  This
   conforms with GCC's default model.  Several other variants exist and
   we should probably support some of them based on the selected ABI.  */

static CORE_ADDR
arm_push_dummy_call (struct gdbarch *gdbarch, struct regcache *regcache,
		     CORE_ADDR dummy_addr, int nargs, struct value **args,
		     CORE_ADDR sp, int struct_return, CORE_ADDR struct_addr)
{
  int argnum;
  int argreg;
  int nstack;
  struct stack_item *si = NULL;

  /* Set the return address.  For the ARM, the return breakpoint is always
     at DUMMY_ADDR.  */
  /* XXX Fix for Thumb.  */
  regcache_cooked_write_unsigned (regcache, ARM_LR_REGNUM, dummy_addr);

  /* Walk through the list of args and determine how large a temporary
     stack is required.  Need to take care here as structs may be
     passed on the stack, and we have to to push them.  */
  nstack = 0;

  argreg = ARM_A1_REGNUM;
  nstack = 0;

  /* Some platforms require a double-word aligned stack.  Make sure sp
     is correctly aligned before we start.  We always do this even if
     it isn't really needed -- it can never hurt things.  */
  sp &= ~(CORE_ADDR)(2 * REGISTER_SIZE - 1);

  /* The struct_return pointer occupies the first parameter
     passing register.  */
  if (struct_return)
    {
      if (arm_debug)
	fprintf_unfiltered (gdb_stdlog, "struct return in %s = 0x%s\n",
			    REGISTER_NAME (argreg), paddr (struct_addr));
      regcache_cooked_write_unsigned (regcache, argreg, struct_addr);
      argreg++;
    }

  for (argnum = 0; argnum < nargs; argnum++)
    {
      int len;
      struct type *arg_type;
      struct type *target_type;
      enum type_code typecode;
      char *val;

      arg_type = check_typedef (VALUE_TYPE (args[argnum]));
      len = TYPE_LENGTH (arg_type);
      target_type = TYPE_TARGET_TYPE (arg_type);
      typecode = TYPE_CODE (arg_type);
      val = VALUE_CONTENTS (args[argnum]);

      /* If the argument is a pointer to a function, and it is a
	 Thumb function, create a LOCAL copy of the value and set
	 the THUMB bit in it.  */
      if (TYPE_CODE_PTR == typecode
	  && target_type != NULL
	  && TYPE_CODE_FUNC == TYPE_CODE (target_type))
	{
	  CORE_ADDR regval = extract_address (val, len);
	  if (arm_pc_is_thumb (regval))
	    {
	      val = alloca (len);
	      store_address (val, len, MAKE_THUMB_ADDR (regval));
	    }
	}

      /* Copy the argument to general registers or the stack in
	 register-sized pieces.  Large arguments are split between
	 registers and stack.  */
      while (len > 0)
	{
	  int partial_len = len < REGISTER_SIZE ? len : REGISTER_SIZE;

	  if (argreg <= ARM_LAST_ARG_REGNUM)
	    {
	      /* The argument is being passed in a general purpose
		 register.  */
	      CORE_ADDR regval = extract_address (val, partial_len);
	      if (arm_debug)
		fprintf_unfiltered (gdb_stdlog, "arg %d in %s = 0x%s\n",
				    argnum, REGISTER_NAME (argreg),
				    phex (regval, REGISTER_SIZE));
	      regcache_cooked_write_unsigned (regcache, argreg, regval);
	      argreg++;
	    }
	  else
	    {
	      /* Push the arguments onto the stack.  */
	      if (arm_debug)
		fprintf_unfiltered (gdb_stdlog, "arg %d @@ sp + %d\n",
				    argnum, nstack);
	      si = push_stack_item (si, val, REGISTER_SIZE);
	      nstack += REGISTER_SIZE;
	    }
	      
	  len -= partial_len;
	  val += partial_len;
	}
    }
  /* If we have an odd number of words to push, then decrement the stack
     by one word now, so first stack argument will be dword aligned.  */
  if (nstack & 4)
    sp -= 4;

  while (si)
    {
      sp -= si->len;
      write_memory (sp, si->data, si->len);
      si = pop_stack_item (si);
    }

  /* Finally, update teh SP register.  */
  regcache_cooked_write_unsigned (regcache, ARM_SP_REGNUM, sp);

  return sp;
}

d2230 3
a2232 1
      switch (arm_get_fp_model (current_gdbarch))
d2247 1
a2247 1
	case ARM_FLOAT_SOFT_FPA:
d2425 1
d2428 1
a2428 1
      switch (arm_get_fp_model (current_gdbarch))
d2436 1
a2436 1
	case ARM_FLOAT_SOFT_FPA:
d2504 9
d2580 4
a2583 6
static void
set_arm_command (char *args, int from_tty)
{
  printf_unfiltered ("\"set arm\" must be followed by an apporpriate subcommand.\n");
  help_list (setarmcmdlist, "set arm ", all_commands, gdb_stdout);
}
d2586 1
a2586 75
show_arm_command (char *args, int from_tty)
{
  cmd_show_list (showarmcmdlist, from_tty, "");
}

enum arm_float_model
arm_get_fp_model (struct gdbarch *gdbarch)
{
  if (arm_fp_model == ARM_FLOAT_AUTO)
    return gdbarch_tdep (gdbarch)->fp_model;

  return arm_fp_model;
}

static void
arm_set_fp (struct gdbarch *gdbarch)
{
  enum arm_float_model fp_model = arm_get_fp_model (gdbarch);

  if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_LITTLE 
      && (fp_model == ARM_FLOAT_SOFT_FPA || fp_model == ARM_FLOAT_FPA))
    {
      set_gdbarch_double_format	(gdbarch,
				 &floatformat_ieee_double_littlebyte_bigword);
      set_gdbarch_long_double_format
	(gdbarch, &floatformat_ieee_double_littlebyte_bigword);
    }
  else
    {
      set_gdbarch_double_format (gdbarch, &floatformat_ieee_double_little);
      set_gdbarch_long_double_format (gdbarch,
				      &floatformat_ieee_double_little);
    }
}

static void
set_fp_model_sfunc (char *args, int from_tty,
		    struct cmd_list_element *c)
{
  enum arm_float_model fp_model;

  for (fp_model = ARM_FLOAT_AUTO; fp_model != ARM_FLOAT_LAST; fp_model++)
    if (strcmp (current_fp_model, fp_model_strings[fp_model]) == 0)
      {
	arm_fp_model = fp_model;
	break;
      }

  if (fp_model == ARM_FLOAT_LAST)
    internal_error (__FILE__, __LINE__, "Invalid fp model accepted: %s.",
		    current_fp_model);

  if (gdbarch_bfd_arch_info (current_gdbarch)->arch == bfd_arch_arm)
    arm_set_fp (current_gdbarch);
}

static void
show_fp_model (char *args, int from_tty,
	       struct cmd_list_element *c)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  if (arm_fp_model == ARM_FLOAT_AUTO 
      && gdbarch_bfd_arch_info (current_gdbarch)->arch == bfd_arch_arm)
    printf_filtered ("  - the default for the current ABI is \"%s\".\n",
		     fp_model_strings[tdep->fp_model]);
}

/* If the user changes the register disassembly style used for info
   register and other commands, we have to also switch the style used
   in opcodes for disassembly output.  This function is run in the "set
   arm disassembly" command, and does that.  */

static void
set_disassembly_style_sfunc (char *args, int from_tty,
d2589 1
a2589 1
  set_disassembly_style ();
d2600 1
a2600 1
set_disassembly_style (void)
d2605 1
a2605 1
  /* Find the style that the user wants in the opcodes table.  */
d2608 2
a2609 2
  while ((disassembly_style != setname)
	 && (current < num_disassembly_options))
d2633 4
a2636 2
/* arm_othernames implements the "othernames" command.  This is deprecated
   by the "set arm disassembly" command.  */
d2642 1
a2642 1
  current_option = (current_option + 1) % num_disassembly_options;
d2644 2
a2645 2
  disassembly_style = valid_disassembly_styles[current_option];
  set_disassembly_style ();
d2853 2
a2854 4
  /* We used to default to FPA for generic ARM, but almost nobody uses that
     now, and we now provide a way for the user to force the model.  So 
     default to the most useful variant.  */
  tdep->fp_model = ARM_FLOAT_SOFT_FPA;
d2887 6
d2895 7
d2903 1
a2903 1
  set_gdbarch_push_dummy_call (gdbarch, arm_push_dummy_call);
d2906 1
a2906 1
  set_gdbarch_deprecated_frame_chain_valid (gdbarch, arm_frame_chain_valid);
d2909 1
a2909 1
  set_gdbarch_deprecated_frame_chain (gdbarch, arm_frame_chain);
d2912 1
a2912 1
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, arm_frame_saved_pc);
d2918 1
a2918 1
  set_gdbarch_deprecated_pop_frame (gdbarch, arm_pop_frame);
d2931 1
a2931 1
  set_gdbarch_deprecated_saved_pc_after_call (gdbarch, arm_saved_pc_after_call);
d2967 1
a2975 3
  /* Disassembly.  */
  set_gdbarch_print_insn (gdbarch, gdb_print_insn_arm);

d3002 14
a3015 1
      arm_set_fp (gdbarch);
d3023 16
d3080 1
a3080 1
  struct cmd_list_element *new_set, *new_show;
d3103 2
d3106 1
a3106 10
  num_disassembly_options = get_arm_regname_num_options ();

  /* Add root prefix command for all "set arm"/"show arm" commands.  */
  add_prefix_cmd ("arm", no_class, set_arm_command,
		  "Various ARM-specific commands.",
		  &setarmcmdlist, "set arm ", 0, &setlist);

  add_prefix_cmd ("arm", no_class, show_arm_command,
		  "Various ARM-specific commands.",
		  &showarmcmdlist, "show arm ", 0, &showlist);
d3113 2
a3114 2
  fprintf_unfiltered (stb, "Set the disassembly style.\n"
		      "The valid values are:\n");
d3117 2
a3118 3
  valid_disassembly_styles
    = xmalloc ((num_disassembly_options + 1) * sizeof (char *));
  for (i = 0; i < num_disassembly_options; i++)
d3121 1
a3121 1
      valid_disassembly_styles[i] = setname;
d3127 1
a3127 1
          disassembly_style = setname;
d3135 1
a3135 1
  valid_disassembly_styles[num_disassembly_options] = NULL;
d3142 4
a3145 4
  /* Add the deprecated disassembly-flavor command.  */
  new_set = add_set_enum_cmd ("disassembly-flavor", no_class,
			      valid_disassembly_styles,
			      &disassembly_style,
d3148 8
a3155 42
  set_cmd_sfunc (new_set, set_disassembly_style_sfunc);
  deprecate_cmd (new_set, "set arm disassembly");
  deprecate_cmd (add_show_from_set (new_set, &showlist),
		 "show arm disassembly");

  /* And now add the new interface.  */
  new_set = add_set_enum_cmd ("disassembler", no_class,
			      valid_disassembly_styles, &disassembly_style,
			      helptext, &setarmcmdlist);

  set_cmd_sfunc (new_set, set_disassembly_style_sfunc);
  add_show_from_set (new_set, &showarmcmdlist);

  add_setshow_cmd_full ("apcs32", no_class,
			var_boolean, (char *) &arm_apcs_32,
			"Set usage of ARM 32-bit mode.",
			"Show usage of ARM 32-bit mode.",
			NULL, NULL,
			&setlist, &showlist, &new_set, &new_show);
  deprecate_cmd (new_set, "set arm apcs32");
  deprecate_cmd (new_show, "show arm apcs32");

  add_setshow_boolean_cmd ("apcs32", no_class, &arm_apcs_32,
			   "Set usage of ARM 32-bit mode.  "
			   "When off, a 26-bit PC will be used.",
			   "Show usage of ARM 32-bit mode.  "
			   "When off, a 26-bit PC will be used.",
			   NULL, NULL,
			   &setarmcmdlist, &showarmcmdlist);

  /* Add a command to allow the user to force the FPU model.  */
  new_set = add_set_enum_cmd
    ("fpu", no_class, fp_model_strings, &current_fp_model,
     "Set the floating point type.\n"
     "auto - Determine the FP typefrom the OS-ABI.\n"
     "softfpa - Software FP, mixed-endian doubles on little-endian ARMs.\n"
     "fpa - FPA co-processor (GCC compiled).\n"
     "softvfp - Software FP with pure-endian doubles.\n"
     "vfp - VFP co-processor.",
     &setarmcmdlist);
  set_cmd_sfunc (new_set, set_fp_model_sfunc);
  set_cmd_sfunc (add_show_from_set (new_set, &showarmcmdlist), show_fp_model);
d3158 7
a3164 3
  deprecate_cmd (add_com ("othernames", class_obscure, arm_othernames,
			  "Switch to the next set of register names."),
		 "set arm disassembly");
d3167 4
a3170 7
  add_setshow_boolean_cmd ("arm", class_maintenance, &arm_debug,
			   "Set ARM debugging.  "
			   "When on, arm-specific debugging is enabled.",
			   "Show ARM debugging.  "
			   "When on, arm-specific debugging is enabled.",
			   NULL, NULL,
			   &setdebuglist, &showdebuglist);
@


1.73.2.7
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@d1121 1
a1121 1
	    deprecated_update_frame_base_hack (fi, deprecated_read_fp ());
d1260 2
a1261 2
   followed by a call to call_function_by_hand, which is the only
   function where call_dummy_breakpoint_offset is actually used.  */
d2941 1
a2941 1
  set_gdbarch_deprecated_target_read_fp (gdbarch, arm_read_fp);
d2975 1
a2975 1
  set_gdbarch_deprecated_fp_regnum (gdbarch, ARM_FP_REGNUM);	/* ??? */
@


1.73.2.8
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d446 1
a446 1
      sym = lookup_symbol (func_name, NULL, VAR_DOMAIN, NULL, NULL);
d1240 1
a1240 1
/* DEPRECATED_CALL_DUMMY_WORDS:
d1268 1
a1268 1
    set_gdbarch_deprecated_call_dummy_breakpoint_offset (current_gdbarch, 4);
d1270 1
a1270 1
    set_gdbarch_deprecated_call_dummy_breakpoint_offset (current_gdbarch, 8);
d1433 1
a1433 1
  sp &= ~(CORE_ADDR)(2 * DEPRECATED_REGISTER_SIZE - 1);
d1471 1
a1471 1
	      store_unsigned_integer (val, len, MAKE_THUMB_ADDR (regval));
d1480 1
a1480 1
	  int partial_len = len < DEPRECATED_REGISTER_SIZE ? len : DEPRECATED_REGISTER_SIZE;
d1490 1
a1490 1
				    phex (regval, DEPRECATED_REGISTER_SIZE));
d1500 2
a1501 2
	      si = push_stack_item (si, val, DEPRECATED_REGISTER_SIZE);
	      nstack += DEPRECATED_REGISTER_SIZE;
d1802 1
a1802 1
      offset = bitcount (bits (inst1, 0, 7)) * DEPRECATED_REGISTER_SIZE;
d2312 4
a2315 4
     must be less than or equal to DEPRECATED_REGISTER_SIZE and the
     offset of each addressable subfield must be zero.  Note that bit
     fields are not addressable, and all addressable subfields of
     unions always start at offset zero.
d2329 1
a2329 1
  if (TYPE_LENGTH (type) > DEPRECATED_REGISTER_SIZE)
d2351 5
a2355 5
         DEPRECATED_REGISTER_SIZE and the offset of each addressable
         subfield must be zero.  Note that bit fields are not
         addressable, and unions always start at offset zero.  If any
         of the subfields is a floating point type, the struct/union
         cannot be an integer type.  */
d2933 2
a2934 2
  set_gdbarch_deprecated_call_dummy_words (gdbarch, arm_call_dummy_words);
  set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, 0);
d2979 4
a2982 4
  set_gdbarch_deprecated_register_bytes (gdbarch,
					 (NUM_GREGS * INT_REGISTER_RAW_SIZE
					  + NUM_FREGS * FP_REGISTER_RAW_SIZE
					  + NUM_SREGS * STATUS_REGISTER_SIZE));
d2994 1
a2994 1
  set_gdbarch_deprecated_register_size (gdbarch, 4);
@


1.73.2.9
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d36 1
d309 22
d1408 3
a1410 4
arm_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
		     struct regcache *regcache, CORE_ADDR bp_addr, int nargs,
		     struct value **args, CORE_ADDR sp, int struct_return,
		     CORE_ADDR struct_addr)
d1417 2
a1418 2
  /* Set the return address.  For the ARM, the return breakpoint is
     always at BP_ADDR.  */
d1420 1
a1420 1
  regcache_cooked_write_unsigned (regcache, ARM_LR_REGNUM, bp_addr);
d1467 1
a1467 1
	  CORE_ADDR regval = extract_unsigned_integer (val, len);
d1486 1
a1486 1
	      CORE_ADDR regval = extract_unsigned_integer (val, partial_len);
d2496 1
a2496 1
  *pc = extract_unsigned_integer (buf, INT_REGISTER_RAW_SIZE);
d2692 43
d2946 3
d2978 1
a2978 1
  set_gdbarch_deprecated_register_byte (gdbarch, arm_register_byte);
d2984 2
a2985 2
  set_gdbarch_deprecated_register_raw_size (gdbarch, arm_register_raw_size);
  set_gdbarch_deprecated_register_virtual_size (gdbarch, arm_register_virtual_size);
d2988 1
a2988 1
  set_gdbarch_deprecated_register_virtual_type (gdbarch, arm_register_type);
a3079 2

extern initialize_file_ftype _initialize_arm_tdep; /* -Wmissing-prototypes */
@


1.73.2.10
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@a36 3
#include "frame-unwind.h"
#include "frame-base.h"
#include "trad-frame.h"
d158 7
a164 1
struct arm_prologue_cache
a165 10
  /* The stack pointer at the time this frame was created; i.e. the
     caller's stack pointer when this function was called.  It is used
     to identify this frame.  */
  CORE_ADDR prev_sp;

  /* The frame base for this frame is just prev_sp + frame offset -
     frame size.  FRAMESIZE is the size of this stack frame, and
     FRAMEOFFSET if the initial offset from the stack pointer (this
     frame's stack pointer, not PREV_SP) to the frame base.  */

a167 2

  /* The register used to hold the frame pointer for this frame.  */
a168 3

  /* Saved register offsets.  */
  struct trad_frame_saved_reg *saved_regs;
d177 6
d505 1
d522 1
a522 1
thumb_scan_prologue (CORE_ADDR prev_pc, struct arm_prologue_cache *cache)
d537 6
a542 1
  if (find_pc_partial_function (prev_pc, NULL, &prologue_start, &prologue_end))
d547 1
a547 1
	prologue_end = prev_pc;
d556 1
a556 1
  prologue_end = min (prologue_end, prev_pc);
d567 1
a567 1
  cache->framesize = 0;
d590 3
a592 2
		cache->framesize += 4;
		cache->saved_regs[saved_reg[regno]].addr = -cache->framesize;
d608 1
a608 1
	      cache->frameoffset += offset;
d611 1
a611 1
	  cache->framesize -= offset;
d616 1
a616 1
	  cache->framereg = THUMB_FP_REGNUM;
d618 1
a618 1
	  cache->frameoffset = (insn & 0xff) << 2;
d623 2
a624 2
	  cache->framereg = THUMB_FP_REGNUM;
	  cache->frameoffset = 0;
d709 1
a709 1
arm_scan_prologue (struct frame_info *next_frame, struct arm_prologue_cache *cache)
d712 1
a713 1
  CORE_ADDR prev_pc = frame_pc_unwind (next_frame);
d716 3
a718 3
  cache->framereg = ARM_SP_REGNUM;
  cache->framesize = 0;
  cache->frameoffset = 0;
d721 1
a721 1
  if (arm_pc_is_thumb (prev_pc))
d723 1
a723 1
      thumb_scan_prologue (prev_pc, cache);
d729 1
a729 1
  if (find_pc_partial_function (prev_pc, NULL, &prologue_start, &prologue_end))
d737 1
a737 1
	      prologue_end = prev_pc;
d770 3
a772 10
      /* We have no symbol information.  Our only option is to assume this
	 function has a standard stack frame and the normal frame register.
	 Then, we can find the value of our frame pointer on entrance to
	 the callee (or at the present moment if this is the innermost frame).
	 The value stored there should be the address of the stmfd + 8.  */
      CORE_ADDR frame_loc;
      LONGEST return_value;

      frame_loc = frame_unwind_register_unsigned (next_frame, ARM_FP_REGNUM);
      if (!safe_read_memory_integer (frame_loc, 4, &return_value))
a780 3
  if (prev_pc < prologue_end)
    prologue_end = prev_pc;

d831 1
a831 1
		cache->saved_regs[regno].addr = sp_offset;
d854 1
a854 1
	  cache->framereg = ARM_FP_REGNUM;
d867 1
a867 1
	  cache->saved_regs[regno].addr = sp_offset;
d894 1
a894 1
	      cache->saved_regs[fp_start_reg++].addr = sp_offset;
d910 5
a914 5
  cache->framesize = -sp_offset;
  if (cache->framereg == ARM_FP_REGNUM)
    cache->frameoffset = fp_offset - sp_offset;
  else
    cache->frameoffset = 0;
d917 9
a925 2
static struct arm_prologue_cache *
arm_make_prologue_cache (struct frame_info *next_frame)
d927 22
a948 22
  int reg;
  struct arm_prologue_cache *cache;
  CORE_ADDR unwound_fp;

  cache = frame_obstack_zalloc (sizeof (struct arm_prologue_cache));
  cache->saved_regs = trad_frame_alloc_saved_regs (next_frame);

  arm_scan_prologue (next_frame, cache);

  unwound_fp = frame_unwind_register_unsigned (next_frame, cache->framereg);
  if (unwound_fp == 0)
    return cache;

  cache->prev_sp = unwound_fp + cache->framesize - cache->frameoffset;

  /* Calculate actual addresses of saved registers using offsets
     determined by arm_scan_prologue.  */
  for (reg = 0; reg < NUM_REGS; reg++)
    if (cache->saved_regs[reg].addr != 0)
      cache->saved_regs[reg].addr += cache->prev_sp;

  return cache;
d950 5
d956 2
a957 7
/* Our frame ID for a normal frame is the current function's starting PC
   and the caller's SP when we were called.  */

static void
arm_prologue_this_id (struct frame_info *next_frame,
		      void **this_cache,
		      struct frame_id *this_id)
d959 2
a960 3
  struct arm_prologue_cache *cache;
  struct frame_id id;
  CORE_ADDR func;
d962 3
a964 3
  if (*this_cache == NULL)
    *this_cache = arm_make_prologue_cache (next_frame);
  cache = *this_cache;
d966 2
a967 6
  func = frame_func_unwind (next_frame);

  /* This is meant to halt the backtrace at "_start".  Make sure we
     don't halt it at a generic dummy frame. */
  if (func <= LOWEST_PC || deprecated_inside_entry_file (func))
    return;
d969 2
a970 5
  /* If we've hit a wall, stop.  */
  if (cache->prev_sp == 0)
    return;

  id = frame_id_build (cache->prev_sp, func);
d972 39
a1010 10
  /* Check that we're not going round in circles with the same frame
     ID (but avoid applying the test to sentinel frames which do go
     round in circles).  */
  if (frame_relative_level (next_frame) >= 0
      && get_frame_type (next_frame) == NORMAL_FRAME
      && frame_id_eq (get_frame_id (next_frame), id))
    return;

  *this_id = id;
}
d1013 1
a1013 44
arm_prologue_prev_register (struct frame_info *next_frame,
			    void **this_cache,
			    int prev_regnum,
			    int *optimized,
			    enum lval_type *lvalp,
			    CORE_ADDR *addrp,
			    int *realnump,
			    void *valuep)
{
  struct arm_prologue_cache *cache;

  if (*this_cache == NULL)
    *this_cache = arm_make_prologue_cache (next_frame);
  cache = *this_cache;

  /* If we are asked to unwind the PC, then we need to return the LR
     instead.  The saved value of PC points into this frame's
     prologue, not the next frame's resume location.  */
  if (prev_regnum == ARM_PC_REGNUM)
    prev_regnum = ARM_LR_REGNUM;

  /* SP is generally not saved to the stack, but this frame is
     identified by NEXT_FRAME's stack pointer at the time of the call.
     The value was already reconstructed into PREV_SP.  */
  if (prev_regnum == ARM_SP_REGNUM)
    {
      *lvalp = not_lval;
      if (valuep)
	store_unsigned_integer (valuep, 4, cache->prev_sp);
      return;
    }

  trad_frame_prev_register (next_frame, cache->saved_regs, prev_regnum,
			    optimized, lvalp, addrp, realnump, valuep);
}

struct frame_unwind arm_prologue_unwind = {
  NORMAL_FRAME,
  arm_prologue_this_id,
  arm_prologue_prev_register
};

static const struct frame_unwind *
arm_prologue_unwind_sniffer (struct frame_info *next_frame)
d1015 2
a1016 2
  return &arm_prologue_unwind;
}
d1018 2
a1019 4
static CORE_ADDR
arm_normal_frame_base (struct frame_info *next_frame, void **this_cache)
{
  struct arm_prologue_cache *cache;
d1021 1
a1021 3
  if (*this_cache == NULL)
    *this_cache = arm_make_prologue_cache (next_frame);
  cache = *this_cache;
d1023 31
a1053 2
  return cache->prev_sp + cache->frameoffset - cache->framesize;
}
d1055 4
a1058 6
struct frame_base arm_normal_base = {
  &arm_prologue_unwind,
  arm_normal_frame_base,
  arm_normal_frame_base,
  arm_normal_frame_base
};
d1060 3
a1062 5
static struct arm_prologue_cache *
arm_make_sigtramp_cache (struct frame_info *next_frame)
{
  struct arm_prologue_cache *cache;
  int reg;
d1064 5
a1068 1
  cache = frame_obstack_zalloc (sizeof (struct arm_prologue_cache));
d1070 5
a1074 1
  cache->prev_sp = frame_unwind_register_unsigned (next_frame, ARM_SP_REGNUM);
d1076 4
a1079 1
  cache->saved_regs = trad_frame_alloc_saved_regs (next_frame);
d1081 19
a1099 4
  for (reg = 0; reg < NUM_REGS; reg++)
    cache->saved_regs[reg].addr
      = SIGCONTEXT_REGISTER_ADDRESS (cache->prev_sp,
				     frame_pc_unwind (next_frame), reg);
d1101 9
a1109 7
  /* FIXME: What about thumb mode?  */
  cache->framereg = ARM_SP_REGNUM;
  cache->prev_sp
    = read_memory_integer (cache->saved_regs[cache->framereg].addr,
			   REGISTER_RAW_SIZE (cache->framereg));

  return cache;
a1111 6
static void
arm_sigtramp_this_id (struct frame_info *next_frame,
		      void **this_cache,
		      struct frame_id *this_id)
{
  struct arm_prologue_cache *cache;
d1113 3
a1115 3
  if (*this_cache == NULL)
    *this_cache = arm_make_sigtramp_cache (next_frame);
  cache = *this_cache;
d1117 3
a1119 4
  /* FIXME drow/2003-07-07: This isn't right if we single-step within
     the sigtramp frame; the PC should be the beginning of the trampoline.  */
  *this_id = frame_id_build (cache->prev_sp, frame_pc_unwind (next_frame));
}
d1121 2
a1122 9
static void
arm_sigtramp_prev_register (struct frame_info *next_frame,
			    void **this_cache,
			    int prev_regnum,
			    int *optimized,
			    enum lval_type *lvalp,
			    CORE_ADDR *addrp,
			    int *realnump,
			    void *valuep)
d1124 4
a1127 1
  struct arm_prologue_cache *cache;
d1129 13
a1141 6
  if (*this_cache == NULL)
    *this_cache = arm_make_sigtramp_cache (next_frame);
  cache = *this_cache;

  trad_frame_prev_register (next_frame, cache->saved_regs, prev_regnum,
			    optimized, lvalp, addrp, realnump, valuep);
d1144 2
a1145 5
struct frame_unwind arm_sigtramp_unwind = {
  SIGTRAMP_FRAME,
  arm_sigtramp_this_id,
  arm_sigtramp_prev_register
};
d1147 2
a1148 2
static const struct frame_unwind *
arm_sigtramp_unwind_sniffer (struct frame_info *next_frame)
d1150 4
a1153 10
  /* Note: If an ARM PC_IN_SIGTRAMP method ever needs to compare
     against the name of the function, the code below will have to be
     changed to first fetch the name of the function and then pass
     this name to PC_IN_SIGTRAMP.  */

  if (SIGCONTEXT_REGISTER_ADDRESS_P ()
      && PC_IN_SIGTRAMP (frame_pc_unwind (next_frame), (char *) 0))
    return &arm_sigtramp_unwind;

  return NULL;
d1156 5
a1160 5
/* Assuming NEXT_FRAME->prev is a dummy, return the frame ID of that
   dummy frame.  The frame ID's base needs to match the TOS value
   saved by save_dummy_frame_tos() and returned from
   arm_push_dummy_call, and the PC needs to match the dummy frame's
   breakpoint.  */
d1162 2
a1163 2
static struct frame_id
arm_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
a1164 3
  return frame_id_build (frame_unwind_register_unsigned (next_frame, ARM_SP_REGNUM),
			 frame_pc_unwind (next_frame));
}
d1166 2
a1167 11
/* Given THIS_FRAME, find the previous frame's resume PC (which will
   be used to construct the previous frame's ID, after looking up the
   containing function).  */

static CORE_ADDR
arm_unwind_pc (struct gdbarch *gdbarch, struct frame_info *this_frame)
{
  CORE_ADDR pc;
  pc = frame_unwind_register_unsigned (this_frame, ARM_PC_REGNUM);
  return IS_THUMB_ADDR (pc) ? UNMAKE_THUMB_ADDR (pc) : pc;
}
d1169 1
a1169 4
static CORE_ADDR
arm_unwind_sp (struct gdbarch *gdbarch, struct frame_info *this_frame)
{
  return frame_unwind_register_unsigned (this_frame, ARM_SP_REGNUM);
d1178 1
a1178 1
  write_register (ARM_LR_REGNUM, entry_point_address ());
d1314 34
d1526 1
a1526 1
  unsigned long status = read_register (ARM_FPS_REGNUM);
d2286 1
a2286 1
  enum type_code code;
d2828 4
d2874 4
a2877 4
  set_gdbarch_unwind_dummy_id (gdbarch, arm_unwind_dummy_id);
  set_gdbarch_unwind_pc (gdbarch, arm_unwind_pc);
  set_gdbarch_unwind_sp (gdbarch, arm_unwind_sp);

d2880 1
d2882 2
a2883 2

  frame_base_set_default (gdbarch, &arm_normal_base);
a2950 4
  /* Add some default predicates.  */
  frame_unwind_append_sniffer (gdbarch, arm_sigtramp_unwind_sniffer);
  frame_unwind_append_sniffer (gdbarch, arm_prologue_unwind_sniffer);

d3027 2
a3028 1
  gdbarch_register (bfd_arch_arm, arm_gdbarch_init, arm_dump_tdep);
@


1.73.2.11
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@a457 6
      if ((inst & 0xfffff000) == 0xe28dc000)    /* add ip, sp #n */
	continue;

      if ((inst & 0xfffff000) == 0xe24dc000)    /* sub ip, sp #n */
	continue;

d710 1
a710 1
  int regno, sp_offset, fp_offset, ip_offset;
d811 1
a811 1
  sp_offset = fp_offset = ip_offset = 0;
a820 17
	  ip_offset = 0;
	  continue;
	}
      else if ((insn & 0xfffff000) == 0xe28dc000) /* add ip, sp #n */
	{
	  unsigned imm = insn & 0xff;                   /* immediate value */
	  unsigned rot = (insn & 0xf00) >> 7;           /* rotate amount */
	  imm = (imm >> rot) | (imm << (32 - rot));
	  ip_offset = imm;
	  continue;
	}
      else if ((insn & 0xfffff000) == 0xe24dc000) /* sub ip, sp #n */
	{
	  unsigned imm = insn & 0xff;                   /* immediate value */
	  unsigned rot = (insn & 0xf00) >> 7;           /* rotate amount */
	  imm = (imm >> rot) | (imm << (32 - rot));
	  ip_offset = -imm;
d825 1
a825 2
	  sp_offset -= 4;
	  cache->saved_regs[ARM_LR_REGNUM].addr = sp_offset;
d862 1
a862 1
	  fp_offset = -imm + ip_offset;
d947 1
a947 1
    if (trad_frame_addr_p (cache->saved_regs, reg))
d973 1
a973 1
  if (func <= LOWEST_PC)
d1082 1
a1082 1
			   DEPRECATED_REGISTER_RAW_SIZE (cache->framereg));
@


1.73.2.12
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d84 3
a86 1
   is used for this purpose.
d89 4
a92 1
   MSYMBOL_IS_SPECIAL   Tests the "special" bit in a minimal symbol.  */
d100 3
@


1.73.2.13
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004 Free Software Foundation, Inc.
a2691 15
static void
arm_write_pc (CORE_ADDR pc, ptid_t ptid)
{
  write_register_pid (ARM_PC_REGNUM, pc, ptid);

  /* If necessary, set the T bit.  */
  if (arm_apcs_32)
    {
      CORE_ADDR val = read_register_pid (ARM_PS_REGNUM, ptid);
      if (arm_pc_is_thumb (pc))
	write_register_pid (ARM_PS_REGNUM, val | 0x20, ptid);
      else
	write_register_pid (ARM_PS_REGNUM, val & ~(CORE_ADDR) 0x20, ptid);
    }
}
a2853 2
  set_gdbarch_write_pc (gdbarch, arm_write_pc);

d2869 3
d2883 1
@


1.72
log
@2002-09-05  Michael Snyder  <msnyder@@redhat.com>

	* arm-tdep.c (arm_extract_return_value): Use new regcache method.
@
text
@d998 1
a998 1
	  return generic_read_register_dummy (fi->pc, fi->frame, regnum);
d1113 2
a1114 2
    sp = generic_read_register_dummy (fi->next->pc, fi->next->frame,
				      ARM_SP_REGNUM);
d1224 1
a1224 1
    return generic_read_register_dummy (fi->pc, fi->frame, ARM_PC_REGNUM);
@


1.71
log
@2002-09-05  Michael Snyder  <msnyder@@redhat.com>

	* arm-tdep.c (arm_init_extra_frame_info): Distinguish between
	generic_dummy_frame method and old method.  Also distinguish
	between ARM_FP_REGNUM and THUMB_FP_REGNUM.
@
text
@d2286 1
a2286 1
arm_extract_struct_value_address (char *regbuf)
d2288 4
a2291 1
  return extract_address (regbuf, REGISTER_RAW_SIZE(ARM_A1_REGNUM));
d2939 1
a2939 1
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch,
@


1.70
log
@* arm-tdep.c (arm_addr_bits_remove): Don't check for Thumb mode
if arm_apcs_32 is false.
@
text
@d1146 2
a1147 1
  else if (PC_IN_CALL_DUMMY (fi->pc, sp, fi->frame))
d1166 4
a1169 1
      fi->extra_info->framereg = ARM_FP_REGNUM;
@


1.69
log
@Index: ChangeLog
===================================================================
RCS file: /cvs/src/src/gdb/ChangeLog,v
retrieving revision 1.3144
diff -u -r1.3144 ChangeLog
--- ChangeLog	23 Aug 2002 23:05:38 -0000	1.3144
+++ ChangeLog	23 Aug 2002 23:14:45 -0000
@@@@ -1,3 +1,53 @@@@
2002-08-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (STORE_RETURN_VALUE): Add regcache parameter.
	(DEPRECATED_STORE_RETURN_VALUE): New method.
	(EXTRACT_RETURN_VALUE): Make buffer parameter a void pointer.
	* gdbarch.h, gdbarch.c: Re-generate.

	* values.c (set_return_value): Pass current_regcache to
	STORE_RETURN_VALUE.
	* arch-utils.h (legacy_store_return_value): Declare.
	* arch-utils.c (legacy_store_return_value): New function.
	(legacy_extract_return_value): Update parameters.

	* config/pa/tm-hppa.h (DEPRECATED_STORE_RETURN_VALUE): Rename
	STORE_RETURN_VALUE.
	* config/pa/tm-hppa64.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/z8k/tm-z8k.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/sparc/tm-sparclet.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/mn10200/tm-mn10200.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/m68k/tm-linux.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/m68k/tm-delta68.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/m32r/tm-m32r.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/h8500/tm-h8500.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/h8300/tm-h8300.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.

	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* i386-tdep.c (i386_extract_return_value): Update.
	* arch-utils.c (legacy_extract_return_value): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.

Index: doc/ChangeLog
2002-08-21  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Update
	STORE_RETURN_VALUE, mention regcache.
@
text
@d228 2
a229 2
  if (arm_pc_is_thumb (val))
    return (val & (arm_apcs_32 ? 0xfffffffe : 0x03fffffe));
d231 1
a231 1
    return (val & (arm_apcs_32 ? 0xfffffffc : 0x03fffffc));
@


1.68
log
@2002-08-15  Andrew Cagney  <ac131313@@redhat.com>
* gdbarch.sh (PRINT_FLOAT_INFO): Change to a predicate method.
Add `args' parameter.
* gdbarch.h, gdbarch.c: Regenerate.

* arm-tdep.c (arm_print_float_info): Add the parameter `args'.

* infcmd.c (float_info): Call print_float_info.
(print_float_info): New function.  By default, print the
floating-point registers.

* arch-utils.h (default_print_float_info): Delete declaration.
* arch-utils.c (default_print_float_info): Delete function.
@
text
@d2929 1
a2929 1
  set_gdbarch_store_return_value (gdbarch, arm_store_return_value);
@


1.67
log
@* cris-tdep.c (cris_saved_pc_after_call): Fix parameter type.
Make static.
* arm-tdep.c (arm_register_name): Make return type constant.
@
text
@d1588 1
a1588 1
		      struct frame_info *frame)
@


1.66
log
@+	* gdbarch.sh (DEPRECATED_EXTRACT_RETURN_VALUE): Rename
+	EXTRACT_RETURN_VALUE.
+	(DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS): Rename
+	EXTRACT_STRUCT_VALUE_ADDRESS.
+	* gdbarch.h, gdbarch.c: Regenerate.
+
+	* values.c (value_being_returned): Handle
+	DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS.
+	(EXTRACT_RETURN_VALUE): Define as DEPRECATED_EXTRACT_RETURN_VALUE.
+
+	* arm-linux-tdep.c (arm_linux_init_abi): Update.
+	* arm-tdep.c (arm_gdbarch_init): Update.
+	* avr-tdep.c (avr_gdbarch_init): Update.
+	* cris-tdep.c (cris_gdbarch_init): Update.
+	* d10v-tdep.c (d10v_gdbarch_init): Update.
+	* ia64-tdep.c (ia64_gdbarch_init): Update.
+	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
+	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
+	* s390-tdep.c (s390_gdbarch_init): Update.
+	* sh-tdep.c (sh_gdbarch_init): Update.
+	* s390-tdep.c (s390_gdbarch_init): Update.
+	* sparc-tdep.c (sparc_gdbarch_init): Update.
+	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
+	* v850-tdep.c (v850_gdbarch_init): Update.
+	* vax-tdep.c (vax_gdbarch_init): Update.
+	* x86-64-tdep.c (x86_64_gdbarch_init): Update.
+	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
+
+	* config/arc/tm-arc.h: Update.
+	* config/d30v/tm-d30v.h: Update.
+	* config/fr30/tm-fr30.h: Update.
+	* config/h8300/tm-h8300.h: Update.
* config/h8500/tm-h8500.h: Update.
* config/i386/tm-i386.h: Update.
* config/i386/tm-ptx.h: Update.
* config/i386/tm-symmetry.h: Update.
* config/i960/tm-i960.h: Update.
* config/m32r/tm-m32r.h: Update.
* config/m68k/tm-delta68.h: Update.
* config/m68k/tm-linux.h: Update.
* config/m68k/tm-m68k.h: Update.
* config/m88k/tm-m88k.h: Update.
* config/mcore/tm-mcore.h: Update.
* config/mips/tm-mips.h: Update.
* config/mn10200/tm-mn10200.h: Update.
* config/pa/tm-hppa.h: Update.
* config/pa/tm-hppa64.h: Update.
* config/sparc/tm-sp64.h: Update.
* config/sparc/tm-sparc.h: Update.
* config/sparc/tm-sparclet.h: Update.
* config/z8k/tm-z8k.h: Update.
@
text
@d2506 1
a2506 1
static char *
@


1.65
log
@* arm-tdep.c (arm_push_arguments): Rewrite using a two-pass loop.
(arm_debug): New static variable.
(_initialize_arm_tdep): Add ``set debug arm'' command.
@
text
@d2928 1
a2928 1
  set_gdbarch_extract_return_value (gdbarch, arm_extract_return_value);
d2932 1
a2932 1
  set_gdbarch_extract_struct_value_address (gdbarch,
@


1.64
log
@Add the file include/gdb/sim-arm.h defining an enum that specifies the
register numbering used by the GDB<->SIM interface.
@
text
@d47 2
d1415 7
a1421 2
  char *fp;
  int argnum, argreg, nstack_size;
d1425 29
a1453 64
     passed on the stack, and we have to to push them.  */
  nstack_size = -4 * REGISTER_SIZE;	/* Some arguments go into A1-A4.  */
  if (struct_return)			/* The struct address goes in A1.  */
    nstack_size += REGISTER_SIZE;

  /* Walk through the arguments and add their size to nstack_size.  */
  for (argnum = 0; argnum < nargs; argnum++)
    {
      int len;
      struct type *arg_type;

      arg_type = check_typedef (VALUE_TYPE (args[argnum]));
      len = TYPE_LENGTH (arg_type);

      nstack_size += len;
    }

  /* Allocate room on the stack, and initialize our stack frame
     pointer.  */
  fp = NULL;
  if (nstack_size > 0)
    {
      sp -= nstack_size;
      fp = (char *) sp;
    }

  /* Initialize the integer argument register pointer.  */
  argreg = ARM_A1_REGNUM;

  /* The struct_return pointer occupies the first parameter passing
     register.  */
  if (struct_return)
    write_register (argreg++, struct_addr);

  /* Process arguments from left to right.  Store as many as allowed
     in the parameter passing registers (A1-A4), and save the rest on
     the temporary stack.  */
  for (argnum = 0; argnum < nargs; argnum++)
    {
      int len;
      char *val;
      CORE_ADDR regval;
      enum type_code typecode;
      struct type *arg_type, *target_type;

      arg_type = check_typedef (VALUE_TYPE (args[argnum]));
      target_type = TYPE_TARGET_TYPE (arg_type);
      len = TYPE_LENGTH (arg_type);
      typecode = TYPE_CODE (arg_type);
      val = (char *) VALUE_CONTENTS (args[argnum]);

#if 1
      /* I don't know why this code was disable. The only logical use
         for a function pointer is to call that function, so setting
         the mode bit is perfectly fine.  FN */
      /* If the argument is a pointer to a function, and it is a Thumb
         function, set the low bit of the pointer.  */
      if (TYPE_CODE_PTR == typecode
	  && NULL != target_type
	  && TYPE_CODE_FUNC == TYPE_CODE (target_type))
	{
	  CORE_ADDR regval = extract_address (val, len);
	  if (arm_pc_is_thumb (regval))
	    store_address (val, len, MAKE_THUMB_ADDR (regval));
d1455 2
a1456 5
#endif
      /* Copy the argument to general registers or the stack in
         register-sized pieces.  Large arguments are split between
         registers and stack.  */
      while (len > 0)
d1458 19
a1476 3
	  int partial_len = len < REGISTER_SIZE ? len : REGISTER_SIZE;

	  if (argreg <= ARM_LAST_ARG_REGNUM)
d1478 6
a1483 3
	      /* It's an argument being passed in a general register.  */
	      regval = extract_address (val, partial_len);
	      write_register (argreg++, regval);
d1485 5
a1489 1
	  else
d1491 36
a1526 3
	      /* Push the arguments onto the stack.  */
	      write_memory ((CORE_ADDR) fp, val, REGISTER_SIZE);
	      fp += REGISTER_SIZE;
a1528 2
	  len -= partial_len;
	  val += partial_len;
d1532 2
a1533 2
  /* Return adjusted stack pointer.  */
  return sp;
d3130 6
@


1.63
log
@Make print_float_info() multi-arch pure.  Add ui_file and frame parameters.
@
text
@d39 1
d45 2
d1642 21
d2896 3
@


1.62
log
@* Makefile.in (SFILES): Add osabi.c.
(COMMON_OBS): Add osabi.o.
(osabi.o): New dependency list.
* osabi.c: New file.
* osabi.h: New file.
* doc/gdbint.texinfo: Document new generic OS ABI framework.

* Makefile.in (alpha_tdep_h): Define and use instead of
alpha-tdep.h.
* alpha-tdep.c (alpha_abi_names, process_note_abi_tag_sections,
get_elfosabi, alpha_abi_handler_list, alpha_gdbarch_register_os_abi):
Remove.
(alpha_gdbarch_init, alpha_dump_tdep): Use generic OS ABI framework.
* alpha-tdep.h: Include osabi.h.
(alpha_abi): Remove.
(gdbarch_tdep): Use generic OS ABI framework.
* alpha-linux-tdep.c (_initialize_alpha_linux_tdep): Use
gdbarch_register_osabi.
* alpha-osf1-tdep.c (_initialize_alpha_osf1_tdep): Likewise.
* alphafbsd-tdep.c (_initialize_alphafbsd_tdep): Likewise.
* alphanbsd-tdep.c (_initialize_alphanbsd_tdep): Likewise.

* Makefile.in (sh_tdep_h): Add osabi.h.
* sh-tdep.h (sh_osabi): Remove.
(gdbarch_tdep): Use generic OS ABI framework.
* sh-tdep.c (sh_osabi_names, process_note_abi_tag_sections,
sh_osabi_handler_list, sh_gdbarch_register_os_abi): Remove.
(sh_gdbarch_init, sh_dump_tdep): Use generic OS ABI framework.
* shnbsd-tdep.c (_initialize_shnbsd_tdep): Use gdbarch_register_osabi.

* Makefile.in (arm_tdep_h): Define and use instead of arm-tdep.h.
* arm-linux-tdep.c (_initialize_arm_linux_tdep): Use
gdbarch_register_osabi.
* arm-tdep.c (arm_abi_names, process_note_abi_tag_sections,
arm_abi_handler_list, arm_gdbarch_register_os_abi): Remove.
(get_elfosabi): Rename to...
(arm_elf_osabi_sniffer): ...this.  Adjust to use generic OS
ABI framework support routines.
(arm_gdbarch_init): Use generic OS ABI framework.
(arm_dump_tdep): Likewise.
(_initialize_arm_tdep): Likewise.
* arm-tdep.h: Include osabi.h.
(arm_abi): Remove.
(gdbarch_tdep): Remove arm_abi and abi_name members.  Add
osabi member.
(arm_gdbarch_register_os_abi): Remove prototype.
* armnbsd-tdep.c (arm_netbsd_aout_osabi_sniffer): New function.
(_initialize_arm_netbsd_tdep): Use gdbarch_register_osabi.

* Makefile.in (mips-tdep.o): Add osabi.h to dependency list.
* mips-tdep.c: Include osabi.h.
(gdbarch_tdep, mips_gdbarch_init, mips_dump_tdep): Use generic
OS ABI framework.
@
text
@d1561 2
a1562 1
arm_print_float_info (void)
@


1.62.2.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@a38 1
#include "gdb/sim-arm.h"
a43 4
#include "gdb_assert.h"

static int arm_debug;

d1410 2
a1411 7
  CORE_ADDR fp;
  int argnum;
  int argreg;
  int nstack;
  int simd_argreg;
  int second_pass;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1415 70
a1484 18
     passed on the stack, and we have to to push them.  On the second
     pass, do the store.  */
  nstack = 0;
  fp = sp;
  for (second_pass = 0; second_pass < 2; second_pass++)
    {
      /* Compute the FP using the information computed during the
         first pass.  */
      if (second_pass)
	fp = sp - nstack;

      simd_argreg = 0;
      argreg = ARM_A1_REGNUM;
      nstack = 0;

      /* The struct_return pointer occupies the first parameter
	 passing register.  */
      if (struct_return)
d1486 1
a1486 11
	  if (second_pass)
	    {
	      if (arm_debug)
		fprintf_unfiltered (gdb_stdlog,
				    "struct return in %s = 0x%s\n",
				    REGISTER_NAME (argreg),
				    paddr (struct_addr));
	      write_register (argreg, struct_addr);
	    }
	  argreg++;
	}
d1488 1
a1488 21
      for (argnum = 0; argnum < nargs; argnum++)
	{
	  int len;
	  struct type *arg_type;
	  struct type *target_type;
	  enum type_code typecode;
	  char *val;
	  
	  arg_type = check_typedef (VALUE_TYPE (args[argnum]));
	  len = TYPE_LENGTH (arg_type);
	  target_type = TYPE_TARGET_TYPE (arg_type);
	  typecode = TYPE_CODE (arg_type);
	  val = VALUE_CONTENTS (args[argnum]);
	  
	  /* If the argument is a pointer to a function, and it is a
	     Thumb function, create a LOCAL copy of the value and set
	     the THUMB bit in it.  */
	  if (second_pass
	      && TYPE_CODE_PTR == typecode
	      && target_type != NULL
	      && TYPE_CODE_FUNC == TYPE_CODE (target_type))
d1490 3
a1492 6
	      CORE_ADDR regval = extract_address (val, len);
	      if (arm_pc_is_thumb (regval))
		{
		  val = alloca (len);
		  store_address (val, len, MAKE_THUMB_ADDR (regval));
		}
d1494 1
a1494 5

	  /* Copy the argument to general registers or the stack in
	     register-sized pieces.  Large arguments are split between
	     registers and stack.  */
	  while (len > 0)
d1496 3
a1498 36
	      int partial_len = len < REGISTER_SIZE ? len : REGISTER_SIZE;
	      
	      if (argreg <= ARM_LAST_ARG_REGNUM)
		{
		  /* The argument is being passed in a general purpose
		     register.  */
		  if (second_pass)
		    {
		      CORE_ADDR regval = extract_address (val,
							  partial_len);
		      if (arm_debug)
			fprintf_unfiltered (gdb_stdlog,
					    "arg %d in %s = 0x%s\n",
					    argnum,
					    REGISTER_NAME (argreg),
					    phex (regval, REGISTER_SIZE));
		      write_register (argreg, regval);
		    }
		  argreg++;
		}
	      else
		{
		  if (second_pass)
		    {
		      /* Push the arguments onto the stack.  */
		      if (arm_debug)
			fprintf_unfiltered (gdb_stdlog,
					    "arg %d @@ 0x%s + %d\n",
					    argnum, paddr (fp), nstack);
		      write_memory (fp + nstack, val, REGISTER_SIZE);
		    }
		  nstack += REGISTER_SIZE;
		}
	      
	      len -= partial_len;
	      val += partial_len;
d1501 2
d1506 2
a1507 2
  /* Return the botom of the argument list (pointed to by fp).  */
  return fp;
d1561 1
a1561 2
arm_print_float_info (struct gdbarch *gdbarch, struct ui_file *file,
		      struct frame_info *frame)
a1637 21
/* Map GDB internal REGNUM onto the Arm simulator register numbers.  */
static int
arm_register_sim_regno (int regnum)
{
  int reg = regnum;
  gdb_assert (reg >= 0 && reg < NUM_REGS);

  if (reg < NUM_GREGS)
    return SIM_ARM_R0_REGNUM + reg;
  reg -= NUM_GREGS;

  if (reg < NUM_FREGS)
    return SIM_ARM_FP0_REGNUM + reg;
  reg -= NUM_FREGS;

  if (reg < NUM_SREGS)
    return SIM_ARM_FPS_REGNUM + reg;
  reg -= NUM_SREGS;

  internal_error (__FILE__, __LINE__, "Bad REGNUM %d", regnum);
}
a2871 3
  /* Internal <-> external register number maps.  */
  set_gdbarch_register_sim_regno (gdbarch, arm_register_sim_regno);

d2877 1
a2877 1
  set_gdbarch_deprecated_extract_return_value (gdbarch, arm_extract_return_value);
d2881 1
a2881 1
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch,
a3078 6

  /* Debugging flag.  */
  add_show_from_set (add_set_cmd ("arm", class_maintenance, var_zinteger,
				  &arm_debug, "Set arm debugging.\n\
When non-zero, arm specific debugging is enabled.", &setdebuglist),
		     &showdebuglist);
@


1.62.2.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d2506 1
a2506 1
static const char *
@


1.62.2.3
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d1588 1
a1588 1
		      struct frame_info *frame, const char *args)
d2929 1
a2929 1
  set_gdbarch_deprecated_store_return_value (gdbarch, arm_store_return_value);
@


1.62.2.4
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d228 2
a229 2
  if (arm_apcs_32)
    return (val & (arm_pc_is_thumb (val) ? 0xfffffffe : 0xfffffffc));
d231 1
a231 1
    return (val & 0x03fffffc);
d998 1
a998 1
	  return deprecated_read_register_dummy (fi->pc, fi->frame, regnum);
d1113 2
a1114 2
    sp = deprecated_read_register_dummy (fi->next->pc, fi->next->frame,
					 ARM_SP_REGNUM);
d1146 1
a1146 2
  else if (!USE_GENERIC_DUMMY_FRAMES
	   && PC_IN_CALL_DUMMY (fi->pc, sp, fi->frame))
d1165 1
a1165 4
      if (arm_pc_is_thumb (fi->pc))
	fi->extra_info->framereg = THUMB_FP_REGNUM;
      else
	fi->extra_info->framereg = ARM_FP_REGNUM;
d1220 1
a1220 1
    return deprecated_read_register_dummy (fi->pc, fi->frame, ARM_PC_REGNUM);
d2282 1
a2282 1
arm_extract_struct_value_address (struct regcache *regcache)
d2284 1
a2284 4
  ULONGEST ret;

  regcache_cooked_read_unsigned (regcache, ARM_A1_REGNUM, &ret);
  return ret;
d2932 1
a2932 1
  set_gdbarch_extract_struct_value_address (gdbarch,
@


1.62.2.5
log
@merge from mainline
@
text
@d2861 1
a2861 1
  set_gdbarch_get_saved_register (gdbarch, deprecated_generic_get_saved_register);
@


1.61
log
@2002-05-16  Michael Snyder  <msnyder@@redhat.com>

	* arm-tdep.c: Spelling fix in comment.
@
text
@a95 17
/* This table matches the indices assigned to enum arm_abi. 
   Keep them in sync.  */

static const char * const arm_abi_names[] =
{
  "<unknown>",
  "ARM EABI (version 1)",
  "ARM EABI (version 2)",
  "GNU/Linux",
  "NetBSD (a.out)",
  "NetBSD (ELF)",
  "APCS",
  "FreeBSD",
  "Windows CE",
  NULL
};

d2594 2
a2595 2
static void
process_note_abi_tag_sections (bfd *abfd, asection *sect, void *obj)
d2597 2
a2598 3
  enum arm_abi *os_ident_ptr = obj;
  const char *name;
  unsigned int sectsize;
d2600 1
a2600 2
  name = bfd_get_section_name (abfd, sect);
  sectsize = bfd_section_size (abfd, sect);
d2602 1
a2602 1
  if (strcmp (name, ".note.ABI-tag") == 0 && sectsize > 0)
d2604 14
a2617 24
      unsigned int name_length, data_length, note_type;
      char *note;

      /* If the section is larger than this, it's probably not what we are
	 looking for.  */
      if (sectsize > 128)
	sectsize = 128;

      note = alloca (sectsize);

      bfd_get_section_contents (abfd, sect, note,
                                (file_ptr) 0, (bfd_size_type) sectsize);

      name_length = bfd_h_get_32 (abfd, note);
      data_length = bfd_h_get_32 (abfd, note + 4);
      note_type   = bfd_h_get_32 (abfd, note + 8);

      if (name_length == 4 && data_length == 16 && note_type == 1
          && strcmp (note + 12, "GNU") == 0)
	{
	  int os_number = bfd_h_get_32 (abfd, note + 16);

	  /* The case numbers are from abi-tags in glibc.  */
	  switch (os_number)
d2619 2
a2620 2
	    case 0 :
	      *os_ident_ptr = ARM_ABI_LINUX;
d2623 2
a2624 4
	    case 1 :
	      internal_error
		(__FILE__, __LINE__,
		 "process_note_abi_sections: Hurd objects not supported");
d2627 3
a2629 4
	    case 2 :
	      internal_error
		(__FILE__, __LINE__,
		 "process_note_abi_sections: Solaris objects not supported");
d2632 4
a2635 6
	    default :
	      internal_error
		(__FILE__, __LINE__,
		 "process_note_abi_sections: unknown OS number %d",
		 os_number);
	      break;
d2638 1
a2638 6
    }
  /* NetBSD uses a similar trick.  */
  else if (strcmp (name, ".note.netbsd.ident") == 0 && sectsize > 0)
    {
      unsigned int name_length, desc_length, note_type;
      char *note;
d2640 3
a2642 43
      /* If the section is larger than this, it's probably not what we are
	 looking for.  */
      if (sectsize > 128)
	sectsize = 128;

      note = alloca (sectsize);

      bfd_get_section_contents (abfd, sect, note,
                                (file_ptr) 0, (bfd_size_type) sectsize);

      name_length = bfd_h_get_32 (abfd, note);
      desc_length = bfd_h_get_32 (abfd, note + 4);
      note_type   = bfd_h_get_32 (abfd, note + 8);

      if (name_length == 7 && desc_length == 4 && note_type == 1
          && strcmp (note + 12, "NetBSD") == 0)
	/* XXX Should we check the version here?
	   Probably not necessary yet.  */
	*os_ident_ptr = ARM_ABI_NETBSD_ELF;
    }
}

/* Return one of the ELFOSABI_ constants for BFDs representing ELF
   executables.  If it's not an ELF executable or if the OS/ABI couldn't
   be determined, simply return -1.  */

static int
get_elfosabi (bfd *abfd)
{
  int elfosabi;
  enum arm_abi arm_abi = ARM_ABI_UNKNOWN;

  elfosabi = elf_elfheader (abfd)->e_ident[EI_OSABI];

  /* When elfosabi is 0 (ELFOSABI_NONE), this is supposed to indicate
     that we're on a SYSV system.  However, GNU/Linux uses a note section
     to record OS/ABI info, but leaves e_ident[EI_OSABI] zero.  So we
     have to check the note sections too.

     GNU/ARM tools set the EI_OSABI field to ELFOSABI_ARM, so handle that
     as well.  */
  if (elfosabi == 0 || elfosabi == ELFOSABI_ARM)
    {
d2644 3
a2646 14
			     process_note_abi_tag_sections,
			     &arm_abi);
    }

  if (arm_abi != ARM_ABI_UNKNOWN)
    return arm_abi;

  switch (elfosabi)
    {
    case ELFOSABI_NONE:
      /* Existing ARM Tools don't set this field, so look at the EI_FLAGS
	 field for more information.  */

      switch (EF_ARM_EABI_VERSION(elf_elfheader(abfd)->e_flags))
d2648 4
a2651 2
	case EF_ARM_EABI_VER1:
	  return ARM_ABI_EABI_V1;
d2653 2
a2654 13
	case EF_ARM_EABI_VER2:
	  return ARM_ABI_EABI_V2;

	case EF_ARM_EABI_UNKNOWN:
	  /* Assume GNU tools.  */
	  return ARM_ABI_APCS;

	default:
	  internal_error (__FILE__, __LINE__,
			  "get_elfosabi: Unknown ARM EABI version 0x%lx",
			  EF_ARM_EABI_VERSION(elf_elfheader(abfd)->e_flags));

	}
d2658 2
a2659 4
      return ARM_ABI_NETBSD_ELF;

    case ELFOSABI_FREEBSD:
      return ARM_ABI_FREEBSD;
d2662 2
a2663 7
      return ARM_ABI_LINUX;

    case ELFOSABI_ARM:
      /* Assume GNU tools with the old APCS abi.  */
      return ARM_ABI_APCS;

    default:
d2666 1
a2666 39
  return ARM_ABI_UNKNOWN;
}

struct arm_abi_handler
{
  struct arm_abi_handler *next;
  enum arm_abi abi;
  void (*init_abi)(struct gdbarch_info, struct gdbarch *);
};

struct arm_abi_handler *arm_abi_handler_list = NULL;

void
arm_gdbarch_register_os_abi (enum arm_abi abi,
			     void (*init_abi)(struct gdbarch_info,
					      struct gdbarch *))
{
  struct arm_abi_handler **handler_p;

  for (handler_p = &arm_abi_handler_list; *handler_p != NULL;
       handler_p = &(*handler_p)->next)
    {
      if ((*handler_p)->abi == abi)
	{
	  internal_error
	    (__FILE__, __LINE__,
	     "arm_gdbarch_register_os_abi: A handler for this ABI variant (%d)"
	     " has already been registered", (int)abi);
	  /* If user wants to continue, override previous definition.  */
	  (*handler_p)->init_abi = init_abi;
	  return;
	}
    }

  (*handler_p)
    = (struct arm_abi_handler *) xmalloc (sizeof (struct arm_abi_handler));
  (*handler_p)->next = NULL;
  (*handler_p)->abi = abi;
  (*handler_p)->init_abi = init_abi;
d2669 1
d2682 1
a2682 2
  enum arm_abi arm_abi = ARM_ABI_UNKNOWN;
  struct arm_abi_handler *abi_handler;
d2688 2
a2689 1
      switch (bfd_get_flavour (info.abfd))
d2691 6
a2696 3
	case bfd_target_elf_flavour:
	  arm_abi = get_elfosabi (info.abfd);
	  break;
d2698 5
a2702 7
	case bfd_target_aout_flavour:
	  if (strcmp (bfd_get_target(info.abfd), "a.out-arm-netbsd") == 0)
	    arm_abi = ARM_ABI_NETBSD_AOUT;
	  else
	    /* Assume it's an old APCS-style ABI.  */
	    arm_abi = ARM_ABI_APCS;
	  break;
d2704 3
a2706 9
	case bfd_target_coff_flavour:
	  /* Assume it's an old APCS-style ABI.  */
	  /* XXX WinCE?  */
	  arm_abi = ARM_ABI_APCS;
	  break;

	default:
	  /* Not sure what to do here, leave the ABI as unknown.  */
	  break;
d2717 1
a2717 1
      if (tdep && tdep->arm_abi == arm_abi)
d2724 1
a2724 9
  tdep->arm_abi = arm_abi;
  if (arm_abi < ARM_ABI_INVALID)
    tdep->abi_name = arm_abi_names[arm_abi];
  else
    {
      internal_error (__FILE__, __LINE__, "Invalid setting of arm_abi %d",
		      (int) arm_abi);
      tdep->abi_name = "<invalid>";
    }
d2894 1
a2894 32
  if (arm_abi == ARM_ABI_UNKNOWN)
    {
      /* Don't complain about not knowing the ABI variant if we don't 
	 have an inferior.  */
      if (info.abfd)
	fprintf_filtered
	  (gdb_stderr, "GDB doesn't recognize the ABI of the inferior.  "
	   "Attempting to continue with the default ARM settings");
    }
  else
    {
      for (abi_handler = arm_abi_handler_list; abi_handler != NULL;
	   abi_handler = abi_handler->next)
	if (abi_handler->abi == arm_abi)
	  break;

      if (abi_handler)
	abi_handler->init_abi (info, gdbarch);
      else
	{
	  /* We assume that if GDB_MULTI_ARCH is less than 
	     GDB_MULTI_ARCH_TM that an ABI variant can be supported by
	     overriding definitions in this file.  */
	  if (GDB_MULTI_ARCH > GDB_MULTI_ARCH_PARTIAL)
	    fprintf_filtered
	      (gdb_stderr,
	       "A handler for the ABI variant \"%s\" is not built into this "
	       "configuration of GDB.  "
	       "Attempting to continue with the default ARM settings",
	       arm_abi_names[arm_abi]);
	}
    }
d2960 2
a2961 6
  if (tdep->abi_name != NULL)
    fprintf_unfiltered (file, "arm_dump_tdep: ABI = %s\n", tdep->abi_name);
  else
    internal_error (__FILE__, __LINE__,
		    "arm_dump_tdep: illegal setting of tdep->arm_abi (%d)",
		    (int) tdep->arm_abi);
d3003 5
d3009 6
a3014 3
  arm_gdbarch_register_os_abi (ARM_ABI_EABI_V1, arm_init_abi_eabi_v1);
  arm_gdbarch_register_os_abi (ARM_ABI_EABI_V2, arm_init_abi_eabi_v2);
  arm_gdbarch_register_os_abi (ARM_ABI_APCS, arm_init_abi_apcs);
@


1.60
log
@2002-05-09  Michael Snyder  <msnyder@@redhat.com>

	* arm-tdep.c (arm_scan_prologue): Accept strb r(0123),[r11,#-nn],
	strh r(0123),[r11,#-nn], str r(0123),[r11,#-nn], as well as
	strb r(0123),[sp,#nn], strh r(0123),[sp,#nn] and
	str r(0123),[sp,#nn].
	(arm_skip_prologue): Ditto.  Also make disassembly
	order-independent by placing it in a loop.
@
text
@d96 1
a96 1
/* This table matches the indicees assigned to enum arm_abi. 
@


1.60.2.1
log
@merge from trunk
@
text
@a38 1
#include "gdb/sim-arm.h"
a43 4
#include "gdb_assert.h"

static int arm_debug;

d96 17
d1427 2
a1428 7
  CORE_ADDR fp;
  int argnum;
  int argreg;
  int nstack;
  int simd_argreg;
  int second_pass;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1432 70
a1501 18
     passed on the stack, and we have to to push them.  On the second
     pass, do the store.  */
  nstack = 0;
  fp = sp;
  for (second_pass = 0; second_pass < 2; second_pass++)
    {
      /* Compute the FP using the information computed during the
         first pass.  */
      if (second_pass)
	fp = sp - nstack;

      simd_argreg = 0;
      argreg = ARM_A1_REGNUM;
      nstack = 0;

      /* The struct_return pointer occupies the first parameter
	 passing register.  */
      if (struct_return)
d1503 1
a1503 11
	  if (second_pass)
	    {
	      if (arm_debug)
		fprintf_unfiltered (gdb_stdlog,
				    "struct return in %s = 0x%s\n",
				    REGISTER_NAME (argreg),
				    paddr (struct_addr));
	      write_register (argreg, struct_addr);
	    }
	  argreg++;
	}
d1505 1
a1505 21
      for (argnum = 0; argnum < nargs; argnum++)
	{
	  int len;
	  struct type *arg_type;
	  struct type *target_type;
	  enum type_code typecode;
	  char *val;
	  
	  arg_type = check_typedef (VALUE_TYPE (args[argnum]));
	  len = TYPE_LENGTH (arg_type);
	  target_type = TYPE_TARGET_TYPE (arg_type);
	  typecode = TYPE_CODE (arg_type);
	  val = VALUE_CONTENTS (args[argnum]);
	  
	  /* If the argument is a pointer to a function, and it is a
	     Thumb function, create a LOCAL copy of the value and set
	     the THUMB bit in it.  */
	  if (second_pass
	      && TYPE_CODE_PTR == typecode
	      && target_type != NULL
	      && TYPE_CODE_FUNC == TYPE_CODE (target_type))
d1507 3
a1509 6
	      CORE_ADDR regval = extract_address (val, len);
	      if (arm_pc_is_thumb (regval))
		{
		  val = alloca (len);
		  store_address (val, len, MAKE_THUMB_ADDR (regval));
		}
d1511 1
a1511 5

	  /* Copy the argument to general registers or the stack in
	     register-sized pieces.  Large arguments are split between
	     registers and stack.  */
	  while (len > 0)
d1513 3
a1515 36
	      int partial_len = len < REGISTER_SIZE ? len : REGISTER_SIZE;
	      
	      if (argreg <= ARM_LAST_ARG_REGNUM)
		{
		  /* The argument is being passed in a general purpose
		     register.  */
		  if (second_pass)
		    {
		      CORE_ADDR regval = extract_address (val,
							  partial_len);
		      if (arm_debug)
			fprintf_unfiltered (gdb_stdlog,
					    "arg %d in %s = 0x%s\n",
					    argnum,
					    REGISTER_NAME (argreg),
					    phex (regval, REGISTER_SIZE));
		      write_register (argreg, regval);
		    }
		  argreg++;
		}
	      else
		{
		  if (second_pass)
		    {
		      /* Push the arguments onto the stack.  */
		      if (arm_debug)
			fprintf_unfiltered (gdb_stdlog,
					    "arg %d @@ 0x%s + %d\n",
					    argnum, paddr (fp), nstack);
		      write_memory (fp + nstack, val, REGISTER_SIZE);
		    }
		  nstack += REGISTER_SIZE;
		}
	      
	      len -= partial_len;
	      val += partial_len;
d1518 2
d1523 2
a1524 2
  /* Return the botom of the argument list (pointed to by fp).  */
  return fp;
d1578 1
a1578 2
arm_print_float_info (struct gdbarch *gdbarch, struct ui_file *file,
		      struct frame_info *frame)
a1654 21
/* Map GDB internal REGNUM onto the Arm simulator register numbers.  */
static int
arm_register_sim_regno (int regnum)
{
  int reg = regnum;
  gdb_assert (reg >= 0 && reg < NUM_REGS);

  if (reg < NUM_GREGS)
    return SIM_ARM_R0_REGNUM + reg;
  reg -= NUM_GREGS;

  if (reg < NUM_FREGS)
    return SIM_ARM_FP0_REGNUM + reg;
  reg -= NUM_FREGS;

  if (reg < NUM_SREGS)
    return SIM_ARM_FPS_REGNUM + reg;
  reg -= NUM_SREGS;

  internal_error (__FILE__, __LINE__, "Bad REGNUM %d", regnum);
}
d2611 2
a2612 2
static enum gdb_osabi
arm_elf_osabi_sniffer (bfd *abfd)
d2614 3
a2616 2
  unsigned int elfosabi, eflags;
  enum gdb_osabi osabi = GDB_OSABI_UNKNOWN;
d2618 2
a2619 1
  elfosabi = elf_elfheader (abfd)->e_ident[EI_OSABI];
d2621 1
a2621 1
  switch (elfosabi)
d2623 24
a2646 14
    case ELFOSABI_NONE:  
      /* When elfosabi is ELFOSABI_NONE (0), then the ELF structures in the
	 file are conforming to the base specification for that machine 
	 (there are no OS-specific extensions).  In order to determine the 
	 real OS in use we must look for OS notes that have been added.  */
      bfd_map_over_sections (abfd,
			     generic_elf_osabi_sniff_abi_tag_sections,  
			     &osabi);
      if (osabi == GDB_OSABI_UNKNOWN)
	{
	  /* Existing ARM tools don't set this field, so look at the EI_FLAGS
	     field for more information.  */
	  eflags = EF_ARM_EABI_VERSION(elf_elfheader(abfd)->e_flags);
	  switch (eflags)
d2648 2
a2649 2
	    case EF_ARM_EABI_VER1:
	      osabi = GDB_OSABI_ARM_EABI_V1;
d2652 4
a2655 2
	    case EF_ARM_EABI_VER2:
	      osabi = GDB_OSABI_ARM_EABI_V2;
d2658 4
a2661 3
	    case EF_ARM_EABI_UNKNOWN:
	      /* Assume GNU tools.  */
	      osabi = GDB_OSABI_ARM_APCS;
d2664 6
a2669 4
	    default:
	      internal_error (__FILE__, __LINE__,
			      "arm_elf_osabi_sniffer: Unknown ARM EABI "
			      "version 0x%x", eflags);
d2672 40
a2711 1
      break;
d2713 9
a2721 3
    case ELFOSABI_ARM:
      /* GNU tools use this value.  Check note sections in this case,
	 as well.  */
d2723 14
a2736 3
			     generic_elf_osabi_sniff_abi_tag_sections, 
			     &osabi);
      if (osabi == GDB_OSABI_UNKNOWN)
d2738 15
a2752 2
	  /* Assume APCS ABI.  */
	  osabi = GDB_OSABI_ARM_APCS;
d2756 3
d2760 23
a2782 2
      osabi = GDB_OSABI_FREEBSD_ELF;
      break;
d2784 6
a2789 3
    case ELFOSABI_NETBSD:
      osabi = GDB_OSABI_NETBSD_ELF;
      break;
d2791 13
a2803 3
    case ELFOSABI_LINUX:
      osabi = GDB_OSABI_LINUX;
      break;
d2806 5
a2810 1
  return osabi;
a2812 1

d2825 2
a2826 1
  enum gdb_osabi osabi = GDB_OSABI_UNKNOWN;
d2832 1
a2832 2
      osabi = gdbarch_lookup_osabi (info.abfd);
      if (osabi == GDB_OSABI_UNKNOWN)
d2834 11
a2844 6
	  switch (bfd_get_flavour (info.abfd))
	    {
	    case bfd_target_aout_flavour:
	      /* Assume it's an old APCS-style ABI.  */
	      osabi = GDB_OSABI_ARM_APCS;
	      break;
d2846 5
a2850 5
	    case bfd_target_coff_flavour:
	      /* Assume it's an old APCS-style ABI.  */
	      /* XXX WinCE?  */
	      osabi = GDB_OSABI_ARM_APCS;
	      break;
d2852 3
a2854 3
	    default:
	      /* Leave it as "unknown".  */
	    }
d2865 1
a2865 1
      if (tdep && tdep->osabi == osabi)
d2872 9
a2880 1
  tdep->osabi = osabi;
a3027 3
  /* Internal <-> external register number maps.  */
  set_gdbarch_register_sim_regno (gdbarch, arm_register_sim_regno);

d3033 1
a3033 1
  set_gdbarch_deprecated_extract_return_value (gdbarch, arm_extract_return_value);
d3037 1
a3037 1
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch,
d3050 32
a3081 1
  gdbarch_init_osabi (info, gdbarch, osabi);
d3147 6
a3152 2
  fprintf_unfiltered (file, "arm_dump_tdep: OS ABI = %s\n",
		      gdbarch_osabi_name (tdep->osabi));
a3193 5
  /* Register an ELF OS ABI sniffer for ARM binaries.  */
  gdbarch_register_osabi_sniffer (bfd_arch_arm,
				  bfd_target_elf_flavour,
				  arm_elf_osabi_sniffer);

d3195 3
a3197 6
  gdbarch_register_osabi (bfd_arch_arm, GDB_OSABI_ARM_EABI_V1,
                          arm_init_abi_eabi_v1);
  gdbarch_register_osabi (bfd_arch_arm, GDB_OSABI_ARM_EABI_V2,
                          arm_init_abi_eabi_v2);
  gdbarch_register_osabi (bfd_arch_arm, GDB_OSABI_ARM_APCS,
                          arm_init_abi_apcs);
a3261 6

  /* Debugging flag.  */
  add_show_from_set (add_set_cmd ("arm", class_maintenance, var_zinteger,
				  &arm_debug, "Set arm debugging.\n\
When non-zero, arm specific debugging is enabled.", &setdebuglist),
		     &showdebuglist);
@


1.59
log
@* arm-tdep.c (arm_skip_prologue): Handle generic dummy frames.
(thumb_scan_prologue): Ditto.
(arm_find_callers_reg): Ditto.
(arm_frame_chain): Ditto.
(arm_init_extra_frame_info): Ditto.
(arm_frame_saved_pc): Ditto.
(arm_pop_frame): Ditto.
(arm_push_return_address): New function.
(arm_gdbarch_init): Initialize use_generic_dummy_frames,
call_dummy_location, call_dummy_breakpoint_offset_p,
call_dummy_breakpoint_offset, call_dummy_p,
call_dummy_stack_adjust_p, call_dummy_words,
sizeof_call_dummy_words, call_dummy_start_offset,
call_dummy_length, fix_call_dummy, pc_in_call_dummy,
call_dummy_address, push_return_address and push_dummy_frame for
generic dummy frames.
@
text
@d420 1
a420 1
  CORE_ADDR func_addr, func_end;
d452 6
a457 4
  skip_pc = pc;
  inst = read_memory_integer (skip_pc, 4);
  /* "mov ip, sp" is no longer a required part of the prologue.  */
  if (inst == 0xe1a0c00d)			/* mov ip, sp */
a458 1
      skip_pc += 4;
a459 1
    }
d461 23
a483 6
  /* Some prologues begin with "str lr, [sp, #-4]!".  */
  if (inst == 0xe52de004)			/* str lr, [sp, #-4]! */
    {
      skip_pc += 4;
      inst = read_memory_integer (skip_pc, 4);
    }
d485 2
a486 5
  if ((inst & 0xfffffff0) == 0xe92d0000)	/* stmfd sp!,{a1,a2,a3,a4} */
    {
      skip_pc += 4;
      inst = read_memory_integer (skip_pc, 4);
    }
d488 2
a489 5
  if ((inst & 0xfffff800) == 0xe92dd800)	/* stmfd sp!,{fp,ip,lr,pc} */
    {
      skip_pc += 4;
      inst = read_memory_integer (skip_pc, 4);
    }
d491 2
a492 20
  /* Any insns after this point may float into the code, if it makes
     for better instruction scheduling, so we skip them only if we
     find them, but still consider the function to be frame-ful.  */

  /* We may have either one sfmfd instruction here, or several stfe
     insns, depending on the version of floating point code we
     support.  */
  if ((inst & 0xffbf0fff) == 0xec2d0200)	/* sfmfd fn, <cnt>, [sp]! */
    {
      skip_pc += 4;
      inst = read_memory_integer (skip_pc, 4);
    }
  else
    {
      while ((inst & 0xffff8fff) == 0xed6d0103)	/* stfe fn, [sp, #-12]! */
	{
	  skip_pc += 4;
	  inst = read_memory_integer (skip_pc, 4);
	}
    }
d494 4
a497 5
  if ((inst & 0xfffff000) == 0xe24cb000)	/* sub fp, ip, #nn */
    {
      skip_pc += 4;
      inst = read_memory_integer (skip_pc, 4);
    }
d499 4
a502 5
  if ((inst & 0xfffff000) == 0xe24dd000)	/* sub sp, sp, #nn */
    {
      skip_pc += 4;
      inst = read_memory_integer (skip_pc, 4);
    }
d504 2
a505 4
  while ((inst & 0xffffcfc0) == 0xe50b0000)	/* str r(0123), [r11, #-nn] */
    {
      skip_pc += 4;
      inst = read_memory_integer (skip_pc, 4);
d508 1
a508 1
  return skip_pc;
d600 1
a600 1
	  /* Calculate offsets of saved R0-R7 and LR. */
d614 1
a614 1
	  if ((findmask & 1) == 0)  		/* before push?  */
d860 1
a860 1
     a frame, which will confuse stack traceback, as well ad"finish" 
d873 1
a873 1
     "str lr, [sp, #-4]!".  - Michael Snyder, 2002-04-23]   */
d907 10
a916 1
      else if ((insn & 0xffffcfc0) == 0xe50b0000)	/* str rx, [r11, -n] */
d972 1
a972 1
      else if ((insn & 0xfe200000) == 0xe8200000) /* ldm? */
d2073 1
a2073 1
  static int next_pc;		/* State between setting and unsetting.  */
@


1.58
log
@* arm-tdep.h (ARM_MAX_REGISTER_RAW_SIZE): Define.
(ARM_MAX_REGISTER_VIRTUAL_SIZE): Define.
* arm-tdep.c (arm_store_return_value): Use them.
Use FP_REGISTER_RAW_SIZE when setting the FPA return value.
* remote-rdp.c (remote_rdp_fetch_register): Use
ARM_MAX_REGISTER_RAW_SIZE.
(remote_rdp_store_register): Likewise.
@
text
@d424 5
d561 6
d1004 3
d1008 17
a1024 9

#if 0	/* FIXME: enable this code if we convert to new call dummy scheme.  */
    if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
      return generic_read_register_dummy (fi->pc, fi->frame, regnum);
    else
#endif
    if (fi->saved_regs[regnum] != 0)
      return read_memory_integer (fi->saved_regs[regnum],
				  REGISTER_RAW_SIZE (regnum));
d1036 2
a1037 2
#if 0	/* FIXME: enable this code if we convert to new call dummy scheme.  */
  CORE_ADDR fn_start, callers_pc, fp;
d1039 4
a1042 16
  /* Is this a dummy frame?  */
  if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
    return fi->frame;		/* dummy frame same as caller's frame */

  /* Is caller-of-this a dummy frame?  */
  callers_pc = FRAME_SAVED_PC (fi);	/* find out who called us: */
  fp = arm_find_callers_reg (fi, ARM_FP_REGNUM);
  if (PC_IN_CALL_DUMMY (callers_pc, fp, fp))
    return fp;		/* dummy frame's frame may bear no relation to ours */

  if (find_pc_partial_function (fi->pc, 0, &fn_start, 0))
    if (fn_start == entry_point_address ())
      return 0;			/* in _start fn, don't chain further */
#endif
  CORE_ADDR caller_pc, fn_start;
  int framereg = fi->extra_info->framereg;
a1048 3
  if (find_pc_partial_function (caller_pc, 0, &fn_start, 0))
    if (fn_start == entry_point_address ())
      return 0;
a1118 14
#if 0	/* FIXME: enable this code if we convert to new call dummy scheme.  */
  if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
    {
      /* We need to setup fi->frame here because run_stack_dummy gets
         it wrong by assuming it's always FP.  */
      fi->frame = generic_read_register_dummy (fi->pc, fi->frame,
					       ARM_SP_REGNUM);
      fi->extra_info->framesize = 0;
      fi->extra_info->frameoffset = 0;
      return;
    }
  else
#endif

d1123 6
d1190 5
d1231 3
a1233 2
#if 0	/* FIXME: enable this code if we convert to new call dummy scheme.  */
  if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
d1235 1
a1235 2
  else
#endif
d1277 10
d1541 8
d2918 5
d2942 21
d2982 5
d2988 3
@


1.57
log
@2002-04-30  Michael Snyder  <msnyder@@redhat.com>

	* arm-tdep.c: Whitespace clean-ups.
@
text
@d2339 1
a2339 1
      char buf[MAX_REGISTER_RAW_SIZE];
d2347 1
a2347 1
				MAX_REGISTER_RAW_SIZE);
@


1.56
log
@2002-04-30  Michael Snyder  <msnyder@@redhat.com>

	* arm-tdep.c (arm_skip_prologue): Fix thinko; two lines
	should have been removed as part of 4/24 change.
@
text
@d96 2
a97 2
/* This table matches the indicees assigned to enum arm_abi.  Keep
   them in sync.  */
d113 1
a113 1
/* Number of different reg name sets (options). */
d119 1
a119 1
   the disassembler at the moment. We also adjust the case of cpsr and fps. */
d121 1
a121 1
/* Initial value: Register names used in ARM's ISA documentation. */
d129 1
a129 1
 "fps", "cpsr" }; 		/* 24 25       */
d135 1
a135 1
/* Disassembly flavor to use. Default to "std" register names. */
d137 1
a137 1
/* Index to that option in the opcodes table. */
d152 1
a152 1
   we're still in the prologue of a function with a frame) */
d173 1
a173 1
/* Set to true if the 32-bit mode is in use. */
d229 1
a229 1
     code regions as part of the stack (true for most practical purposes) */
d292 1
a292 1
     be func_start + 8. */
d359 2
a360 2
  for (current_pc = pc; 
       current_pc + 2 < func_end && current_pc < pc + 40; 
d365 1
a365 1
      if ((insn & 0xfe00) == 0xb400)	/* push { rlist } */
d367 1
a367 1
	  findmask |= 1;  /* push found */
d372 1
a372 1
	  if ((findmask & 1) == 0)  /* before push ? */
d375 1
a375 1
	    findmask |= 4;  /* add/sub sp found */
d379 1
a379 1
	  findmask |= 2;  /* setting of r7 found */
d383 1
a383 1
	  findmask |= 2;  /* setting of r7 found */
d391 1
a391 1
	/* something in the prolog that we don't care about or some
d393 1
a393 1
	   optimization */
d434 1
a434 1
	  /* Don't use this trick for assembly source files. */
d446 1
a446 1
     by disassembling the instructions. */
d450 1
a450 1
  if (inst == 0xe1a0c00d)       /* mov ip, sp */
d457 1
a457 1
  if (inst == 0xe52de004)                       /* str lr, [sp, #-4]! */
d477 1
a477 1
     find them, but still consdier the function to be frame-ful.  */
d508 1
a508 1
  while ((inst & 0xffffcfc0) == 0xe50b0000)     /* str r(0123), [r11, #-nn] */
d516 1
d546 1
a546 1
  /* Which register has been copied to register n? */
d560 1
a560 1
      if (sal.line == 0)	/* no line info, use current PC */
d563 1
a563 1
	prologue_end = sal.end;	/* (probably means no prologue)  */
d595 1
a595 1
	  findmask |= 1;  /* push found */
d614 1
a614 1
	  if ((findmask & 1) == 0)  /* before push ? */
d617 1
a617 1
	    findmask |= 4;  /* add/sub sp found */
d619 2
a620 2
	  offset = (insn & 0x7f) << 2;	/* get scaled offset */
	  if (insn & 0x80)	/* is it signed? (==subtracting) */
d629 1
a629 1
	  findmask |= 2;  /* setting of r7 found */
d636 1
a636 1
	  findmask |= 2;  /* setting of r7 found */
d645 1
a645 1
	  saved_reg[lo_reg] = hi_reg;	/* remember hi reg was saved */
d783 1
a783 1
  /* Check if this function is already in the cache of frame information. */
d834 1
a834 1
	 the scheduler. */
d838 1
a838 1
	  prologue_end = prologue_start + 64;	/* See above. */
d843 2
a844 2
      /* Get address of the stmfd in the prologue of the callee; the saved
         PC is the address of the stmfd + 8.  */
d850 1
a850 1
          prologue_end = prologue_start + 64;   /* See above. */
d877 2
a878 2
  for (current_pc = prologue_start; 
       current_pc < prologue_end; 
d883 1
a883 1
      if (insn == 0xe1a0c00d)           /* mov ip, sp */
d887 1
a887 1
      else if (insn == 0xe52de004)      /* str lr, [sp, #-4]! */
d899 1
a899 1
	  /* Calculate offsets of saved registers. */
d907 1
a907 1
      else if ((insn & 0xffffcfc0) == 0xe50b0000)       /* str rx, [r11, -n] */
d914 2
a915 2
	  unsigned imm = insn & 0xff;	/* immediate value */
	  unsigned rot = (insn & 0xf00) >> 7;	/* rotate amount */
d922 2
a923 2
	  unsigned imm = insn & 0xff;	/* immediate value */
	  unsigned rot = (insn & 0xf00) >> 7;	/* rotate amount */
d938 1
a938 1
	  if ((insn & 0x800) == 0x800)	/* N0 is set */
d962 1
a962 1
	break;	/* Condition not true, exit early */
d964 1
a964 1
	break;	/* Don't scan past a block load */
d967 1
a967 1
	   so we just skip what we don't recognize. */
d971 3
a973 3
  /* The frame size is just the negative of the offset (from the original SP)
     of the last thing thing we pushed on the stack.  The frame offset is
     [new FP] - [new SP].  */
d1017 1
a1017 1
  /* is this a dummy frame? */
d1021 1
a1021 1
  /* is caller-of-this a dummy frame? */
d1025 1
a1025 1
    return fp;			/* dummy frame's frame may bear no relation to ours */
d1046 1
a1046 1
     frame register number. */
d1152 1
a1152 1
      /* FIXME: What about thumb mode? */
d1189 1
a1189 1
	/* this is the innermost frame? */
d1195 1
a1195 1
	  /* If we have an FP, the callee saved it. */
d1202 1
a1202 1
	       still in the frame pointer register on the board... */
d1368 1
a1368 1
  /* Set flag indicating whether the current PC is in a Thumb function. */
d1401 1
a1401 1
     the PC. */
d1422 1
a1422 1
  if (struct_return)		/* The struct address goes in A1.  */
d1474 1
a1474 1
         the mode bit is perfectly fine. FN */
d1783 1
a1783 1
  CORE_ADDR nextpc = pc + 2;	/* default is next instruction */
d1803 1
a1803 1
      if (cond != 0x0f && condition_true (cond, status))	/* 0x0f = SWI */
d1841 1
a1841 1
	case 0x1:		/* data processing */
d2047 2
a2048 2
   single_step is also called just after the inferior stops.  If we had
   set up a simulated single-step, we undo our damage.  */
d2053 1
a2053 1
  static int next_pc; /* State between setting and unsetting. */
d2169 1
a2169 1
   otherwise remote-rdp will have to change. */
d2367 1
a2367 1
   subroutine will return.  This is called from call_function. */
d2401 2
a2402 1
  if (find_pc_partial_function (pc, name ? NULL : &name, &start_addr, NULL) == 0)
d2445 1
a2445 1
   disassembly_flavor command, and does that. */
d2467 1
a2467 1
  /* Find the flavor that the user wants in the opcodes table. */
d2475 1
a2475 1
  /* Fill our copy. */
d2479 1
a2479 1
  /* Adjust case. */
d2491 1
a2491 1
  /* Synchronize the disassembler. */
d2498 1
a2498 1
   case anyone is actually using it. */
d2503 1
a2503 1
  /* Circle through the various flavors. */
d2507 1
a2507 1
  set_disassembly_flavor (); 
d2516 1
a2516 1
   it defines will refer to the host system, not the target.)  */
d2529 1
a2529 1
                                   need. */
d2535 1
a2535 1
                                   need. */
d2894 1
a2894 1
  tdep->jb_pc = -1; /* Longjump support not enabled by default.  */
d2959 1
a2959 1
  set_gdbarch_fp_regnum (gdbarch, ARM_FP_REGNUM); /* ??? */
d3147 1
a3147 1
  /* Get the number of possible sets of register names defined in opcodes. */
d3150 1
a3150 1
  /* Sync the opcode insn printer with our register viewer: */
d3153 1
a3153 1
  /* Begin creating the help text. */
d3158 1
a3158 1
  /* Initialize the array that will be passed to add_set_enum_cmd(). */
d3166 1
a3166 1
      /* Copy the default names (if found) and synchronize disassembler. */
d3176 1
a3176 1
  /* Mark the end of valid options. */
d3179 1
a3179 1
  /* Finish the creation of the help text. */
d3184 1
a3184 1
  /* Add the disassembly-flavor command */
d3199 1
a3199 1
  /* Add the deprecated "othernames" command */
@


1.55
log
@2002-04-24  Michael Snyder  <msnyder@@redhat.com>

        * arm-tdep.c (arm_scan_prologue): Move "mov ip, sp" into the
        loop.  Add handling for "str lr, [sp, #-4]!" and for saves
        of argument regs ("str r(0123), [r11, #-nn"]).
        (arm_skip_prologue): Better handling for frameless functions.
        Treat "mov ip, sp" as optional.  Recognize "str lr, [sp, #-4]".
        (arm_skip_prologue): Recognize str r(0123), [r11, #-nn].
@
text
@a462 2
  skip_pc += 4;
  inst = read_memory_integer (skip_pc, 4);
@


1.54
log
@* arm-tdep.c (arm_gdbarch_init): Add comment that NUM_REGS nor
NUM_PSEUDO_REGS can be used.
@
text
@d449 13
a461 2
  if (inst != 0xe1a0c00d)	/* mov ip, sp */
    return pc;
d465 1
a465 1
  if ((inst & 0xfffffff0) == 0xe92d0000)	/* stmfd sp!,{a1,a2,a3,a4}  */
d471 5
a475 5
  if ((inst & 0xfffff800) != 0xe92dd800)	/* stmfd sp!,{...,fp,ip,lr,pc} */
    return pc;

  skip_pc += 4;
  inst = read_memory_integer (skip_pc, 4);
d491 1
a491 1
      while ((inst & 0xffff8fff) == 0xed6d0103)		/* stfe fn, [sp, #-12]! */
d504 11
a514 2
  if ((inst & 0xfffff000) == 0xe24dd000)                /* sub sp, sp, #nn */
    skip_pc += 4;
d866 9
a874 3
     if we don't see this as the first insn, we will stop.  [Note:
     This doesn't seem to be true any longer, so it's now an optional
     part of the prologue.  - Kevin Buettner, 2001-11-20]  */
d878 3
a880 7
  if (read_memory_unsigned_integer (prologue_start, 4)
      == 0xe1a0c00d)		/* mov ip, sp */
    current_pc = prologue_start + 4;
  else
    current_pc = prologue_start;

  for (; current_pc < prologue_end; current_pc += 4)
d884 10
a893 1
      if ((insn & 0xffff0000) == 0xe92d0000)
d907 5
@


1.53
log
@* arch-utils.h: Update copyright.

* gdbarch.sh (PC_IN_SIGTRAMP): Add.
* gdbarch.h, gdbarch.c: Re-generate.

* inferior.h (IN_SIGTRAMP): Delete definition.
* arch-utils.c (legacy_pc_in_sigtramp): New function.
* arch-utils.h (legacy_pc_in_sigtramp): Declare.

* mips-tdep.c (mips_init_extra_frame_info): Use PC_IN_SIGTRAMP.
(mips_dump_tdep): Do not print value of IN_SIGTRAMP.
* hppa-tdep.c (pc_in_interrupt_handler):  Use PC_IN_SIGTRAMP.
(find_proc_framesize): Ditto.
* alpha-tdep.c (alpha_osf_skip_sigtramp_frame): Ditto.
(alpha_init_extra_frame_info): Ditto.
* infrun.c (handle_inferior_event): Ditto.
(handle_inferior_event): Ditto.
(check_sigtramp2): Ditto.
* blockframe.c (create_new_frame): Ditto.
(get_prev_frame): Ditto.
* ppc-linux-tdep.c: Update comments.
* i386-linux-tdep.c: Update comments.
* breakpoint.c (bpstat_what): Update comment.

* gdbint.texinfo (Target Architecture Definition): Replace
IN_SIGTRAMP with PC_IN_SIGTRAMP.
@
text
@d3038 3
@


1.52
log
@2002-04-22  Michael Snyder  <msnyder@@redhat.com>

	* arm-tdep.c (arm_skip_prologue): Recognize "sub sp, sp, #nn".
@
text
@d1099 1
a1099 1
  /* Determine whether or not we're in a sigtramp frame. 
d1103 2
a1104 2
     fi->signal_handler_caller and IN_SIGTRAMP to determine if we need
     to use the sigcontext addresses for the saved registers.
d1106 4
a1109 4
     Note: If an ARM IN_SIGTRAMP method ever needs to compare against
     the name of the function, the code below will have to be changed
     to first fetch the name of the function and then pass this name
     to IN_SIGTRAMP.  */
d1112 1
a1112 1
      && (fi->signal_handler_caller || IN_SIGTRAMP (fi->pc, (char *)0)))
@


1.51
log
@2002-04-22  Michael Snyder  <msnyder@@redhat.com>

	* arm-tdep.c: Some whitespace and coding standards tweaks.
@
text
@d488 6
@


1.50
log
@* arm-tdep.c (arm_breakpoint_from_pc): Make static.  Make return
type const.
@
text
@d137 2
a138 1
static int current_option;	/* Index to that option in the opcodes table. */
d352 6
a357 5
  int findmask = 0;  	/* findmask:
      			   bit 0 - push { rlist }
			   bit 1 - mov r7, sp  OR  add r7, sp, #imm  (setting of r7)
      			   bit 2 - sub sp, #simm  OR  add sp, #simm  (adjusting of sp)
			*/
d359 3
a361 1
  for (current_pc = pc; current_pc + 2 < func_end && current_pc < pc + 40; current_pc += 2)
d369 2
a370 1
      else if ((insn & 0xff00) == 0xb000)	/* add sp, #simm  OR  sub sp, #simm */
d387 2
a388 1
	  break;	/* We have found one of each type of prologue instruction */
d391 4
a394 2
	continue;	/* something in the prolog that we don't care about or some
	  		   instruction from outside the prolog scheduled here for optimization */
d400 2
a401 2
/* Advance the PC across any function entry prologue instructions to reach
   some "real" code.
d511 2
a512 2
   The comments for thumb_skip_prolog() describe the algorithm we use to detect
   the end of the prolog */
d521 8
a528 6
  int saved_reg[16];		/* which register has been copied to register n? */
  int findmask = 0;  	/* findmask:
      			   bit 0 - push { rlist }
			   bit 1 - mov r7, sp  OR  add r7, sp, #imm  (setting of r7)
      			   bit 2 - sub sp, #simm  OR  add sp, #simm  (adjusting of sp)
			*/
d541 3
a543 2
    prologue_end = prologue_start + 40;		/* We're in the boondocks: allow for */
  /* 16 pushes, an add, and "mv fp,sp" */
d582 2
a583 1
		saved_reg[regno] = regno;	/* reset saved register map */
d586 2
a587 1
      else if ((insn & 0xff00) == 0xb000)	/* add sp, #simm  OR  sub sp, #simm */
d618 1
a618 1
	  int lo_reg = insn & 7;	/* dest. register (r0-r7) */
d623 4
a626 2
	continue;	/* something in the prolog that we don't care about or some
	  		   instruction from outside the prolog scheduled here for optimization */
d954 1
a954 1
#if 0				/* FIXME: enable this code if we convert to new call dummy scheme.  */
d973 1
a973 1
#if 0				/* FIXME: enable this code if we convert to new call dummy scheme.  */
d1071 1
a1071 1
#if 0				/* FIXME: enable this code if we convert to new call dummy scheme.  */
d1074 2
a1075 2
      /* We need to setup fi->frame here because run_stack_dummy gets it wrong
         by assuming it's always FP.  */
d1085 2
a1086 2
  /* Compute stack pointer for this frame.  We use this value for both the
     sigtramp and call dummy cases.  */
d1186 1
a1186 1
#if 0				/* FIXME: enable this code if we convert to new call dummy scheme.  */
d1474 4
a1477 4
/* Pop the current frame.  So long as the frame info has been initialized
   properly (see arm_init_extra_frame_info), this code works for dummy frames
   as well as regular frames.  I.e, there's no need to have a special case
   for dummy frames.  */
d2040 5
a2044 4
	  /* Create a fake symbol vector containing a Thumb symbol.  This is
	     solely so that the code in print_insn_little_arm() and
	     print_insn_big_arm() in opcodes/arm-dis.c will detect the presence
	     of a Thumb symbol and switch to decoding Thumb instructions.  */
d2400 4
a2403 4
/* If the user changes the register disassembly flavor used for info register
   and other commands, we have to also switch the flavor used in opcodes
   for disassembly output.
   This function is run in the set disassembly_flavor command, and does that. */
d2751 3
a2753 3
/* Initialize the current architecture based on INFO.  If possible, re-use an
   architecture from ARCHES, which is a list of architectures already created
   during this debugging session.
d2755 2
a2756 2
   Called e.g. at program startup, when reading a core file, and when reading
   a binary file.  */
@


1.49
log
@* arm-tdep.c (arm_gdbarch_init): Use gdbarch_num_pseudo_regs
instead of NUM_PSEUDO_REGS.
@
text
@d2114 1
a2114 1
unsigned char *
@


1.48
log
@* arm-tdep.h (enum arm_float_model): New enum.
(struct gdbarch_tdep): Add fp_model.
* arm-tdep.c (arm_gdbarch_init): Set fp_model in tdep.  Defer setting
up floating-point conversions until we know the floating-point model
in use by the inferior.  Don't complain about being unable to
determine the ABI of the inferior when we don't have one.
(arm_extract_return_value): Support different floating-point models.
(arm_store_return_value): Likewise.
* armnbsd-tdep.c (arm_netbsd_aout_init_abi): Set fp_model in tdep to
ARM_FLOAT_SOFT.
(arm_netbsd_elf_init_abi): Set fp_model to ARM_FLOAT_SOFT_VFP.
@
text
@d3018 2
a3019 1
		 * (gdbarch_num_regs (gdbarch) + NUM_PSEUDO_REGS)));
@


1.47
log
@* arm-tdep.c (arm_gdbarch_init): Initialize TARGET_CHAR_SIGNED.
Initialize CALL_DUMMY_LENGTH.
@
text
@d2142 23
a2164 1
    convert_from_extended (&regbuf[REGISTER_BYTE (ARM_F0_REGNUM)], valbuf);
d2281 1
d2284 20
a2303 4
      convert_to_extended (valbuf, buf);
      /* XXX Is this correct for soft-float?  */
      write_register_bytes (REGISTER_BYTE (ARM_F0_REGNUM), buf,
			    MAX_REGISTER_RAW_SIZE);
d2306 1
a2306 1
    write_register_bytes (0, valbuf, TYPE_LENGTH (type));
d2804 4
a2807 1
  /* Breakpoints and floating point sizes and format.  */
a2815 4
      set_gdbarch_float_format (gdbarch, &floatformat_ieee_single_big);
      set_gdbarch_double_format (gdbarch, &floatformat_ieee_double_big);
      set_gdbarch_long_double_format (gdbarch, &floatformat_ieee_double_big);
      
a2823 6
      set_gdbarch_float_format (gdbarch, &floatformat_ieee_single_little);
      set_gdbarch_double_format (gdbarch,
				 &floatformat_ieee_double_littlebyte_bigword);
      set_gdbarch_long_double_format (gdbarch,
				 &floatformat_ieee_double_littlebyte_bigword);

d2940 6
a2945 3
      fprintf_filtered
	(gdb_stderr, "GDB doesn't recognize the ABI of the inferior.  "
	 "Attempting to continue with the default ARM settings");
d2976 33
@


1.46
log
@* arm-tdep.c (arm_set_call_dummy_breakpoint_offset): New function.
(arm_fix_call_dummy): Call it.
(arm_call_dummy_breakpoint_offset): Delete.
(arm_gdbarch_init): Initialize call_dummy_breakpoint_offset.
* config/arm/tm-arm.h (CALL_DUMMY_BREAKPOINT_OFFSET): Delete.
@
text
@d1270 4
a1273 4
   XXX Tweeking current_gdbarch is not an optimal solution, but the
   call to arm_fix_call_dummy is immediately followed by a call to
   run_stack_dummy, which is the only function where
   call_dummy_breakpoint_offset is actually used.  */
d2081 2
a2082 2
/* XXX for now we allow a non-multi-arch gdb to override these
   definitions.  */
d2799 3
d2820 1
@


1.45
log
@* arm-tdep.c (arm_gdbarch_init): Initialize coerce_float_to_double.
* config/arm/tm-arm.h (COERCE_FLOAT_TO_DOUBLE): Delete.
@
text
@d1266 19
d1314 1
a1348 16
/* Return the offset in the call dummy of the instruction that needs
   to have a breakpoint placed on it.  This is the offset of the 'swi
   24' instruction, which is no longer actually used, but simply acts
   as a place-holder now.

   This implements the CALL_DUMMY_BREAK_OFFSET macro.  */

int
arm_call_dummy_breakpoint_offset (void)
{
  if (caller_is_thumb)
    return 4;
  else
    return 8;
}

d2808 3
@


1.44
log
@* gdbarch.sh (GET_LONGJMP_TARGET): Add rule.
* gdbarch.c gdbarch.h: Regenerate.
* breakpoint.c (create_longjmp_breakpoint): Always compile this
function.
(breakpoint_reset): Test GET_LONGJMP_TARGET_P().
* infrun.c (GET_LONGJMP_TARGET): Delete default definition.
(handle_inferior_event): Test GET_LONGJMP_TARGET_P().

* arm-tdep.h (struct gdbarch_tdep): Add jb_pc and jb_elt_size fields.
* arm-tdep.c (arm_get_longjmp_target): New function.
(arm_gdbarch_init): Initialize jb_pc to -1.  If ABI handler changes
this to a positive value register arm_get_longjmp_target as the
longjmp handler.
* arm-linux-tdep.c (arm_get_longjmp_target): Delete.
(arm_linux_init_abi): Set up longjmp description in tdep.
* armnbsd-nat.c (get_longjmp_target): Delete.
* armnbsd-tdep.c (arm_netbsd_init_abi_common): Set up longjmp
description in tdep.
* config/arm/tm-nbsd.h (JB_ELEMENT_SIZE, JB_PC): Delete.
(get_longjmp_target): Delete declaration.
(GET_LONGJMP_TARGET): Delete.
* config/arm/tm-linux.h (arm_get_longjmp_target): Delete declaration.
(GET_LONGJMP_TARGET): Delete.
@
text
@d2524 1
a2524 1
	  /* The case numbers are from abi-tags in glibc */
d2582 1
a2582 1
   be determined, simply return -1. */
d2598 1
a2598 1
     as well.*/
d2697 1
a2697 1
   a binary file. */
d2737 1
a2737 1
  /* Find a candidate among extant architectures. */
d2817 2
@


1.43
log
@* arm-tdep.h (struct gdbarch_tdep): Add fields for breakpoint
descriptions.
* arm-tdep.c (arm_default_arm_le_breakpoint)
(arm_default_arm_be_breakpoint, arm_default_thumb_le_breakpoint)
(arm_default_thumb_be_breakpoint): New.  Initialize them from
traditional breakpoint defines.
(arm_breakpoint_from_pc): Use new gdbarch_tdep entries.
(arm_gdbarch_init): Initialize new breakpoint variables.
* arm-linux-tdep.c (arm_linux_arm_le_breakpoint): New.
(arm_linux_init_abi): Initialize linux-specific breakpoint.
* armnbsd-tdep.c (arm_nbsd_arm_le_breakpoint): New.
(arm_netbsd_aout_init_abi, arm_netbsd_elf_init_abi): Split common
code out to ...
(arm_netbsd_init_abi_common): ... here; new function.
* config/arm/tm-arm.h (ARM_LE_BREAKPOINT, ARM_BE_BREAKPOINT)
(THUMB_LE_BREAKPOINT, THUMB_BE_BREAKPOINT): Delete.
* config/arm/tm-linux.h (ARM_LE_BREAKPOINT): Delete.
* config/arm/tm-nbsd.h (ARM_LE_BREAKPOINT): Delete.
@
text
@d2275 17
d2795 1
d2797 1
d2925 3
@


1.42
log
@* arm-tdep.h (enum arm_abi): New enum.
(struct gdbarch_tdep): New structure.
(LOWEST_PC): Provide a default.
(arm_gdbarch_register_os_abi): Declare new function.
* arm-tdep.c (arm_abi_names): New array.
(process_note_abi_tag_sections): New function.
(get_elfosabi): New function.
(arm_gdbarch_register_os_abi): New function.
(arm_gdbarch_init): Try to determine the ABI of the inferior.  If
support for that ABI has been built in, then call the appropriate
configuration routine.  Use gdbarch_num_regs() to get the number
of registers.
(arm_dump_tdep): New function.
(arm_init_abi_eabi_v1, arm_init_abi_eabi_v2, arm_init_abi_apcs): New
place-holder functions.
(_initialize_arm_tdep): Register them.
* config/arm/tm-arm.h (LOWEST_PC): Delete.

* armnbsd-tdep.c: New file.
* Makefile.in (armnbsd-tdep.o): Add dependencies.
* config/arm/nbsd.mt (TDEPFILES): Add it.
* config/arm/tm-nbsd.h (LOWEST_PC): Delete.

* armnbsd-nat.c: Include regcache.h.
* Makefile.in (armnbsd-nat.o): Update dependency list.

* arm-tdep.c (arm_get_next_pc): Use printf_filtered for error message.
@
text
@d2047 50
d2113 2
d2117 3
a2119 14
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
	{
	  static char thumb_breakpoint[] = THUMB_BE_BREAKPOINT;
	  *pcptr = UNMAKE_THUMB_ADDR (*pcptr);
	  *lenptr = sizeof (thumb_breakpoint);
	  return thumb_breakpoint;
	}
      else
	{
	  static char thumb_breakpoint[] = THUMB_LE_BREAKPOINT;
	  *pcptr = UNMAKE_THUMB_ADDR (*pcptr);
	  *lenptr = sizeof (thumb_breakpoint);
	  return thumb_breakpoint;
	}
d2123 2
a2124 12
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
	{
	  static char arm_breakpoint[] = ARM_BE_BREAKPOINT;
	  *lenptr = sizeof (arm_breakpoint);
	  return arm_breakpoint;
	}
      else
	{
	  static char arm_breakpoint[] = ARM_LE_BREAKPOINT;
	  *lenptr = sizeof (arm_breakpoint);
	  return arm_breakpoint;
	}
d2744 1
a2744 1
  /* Floating point sizes and format.  */
d2748 5
d2756 1
d2760 5
d2770 1
@


1.41
log
@	* arm-tdep.c (arm_push_arguments): Eliminate special float type
	handling.
	* config/arm/tm-arm.h (COERCE_FLOAT_TO_DOUBLE): Define to call
	standard_coerce_float_to_double().
@
text
@d42 1
d96 17
d1974 1
a1974 1
	  fprintf (stderr, "Bad bit-field extraction\n");
d2441 210
d2654 1
d2656 2
d2659 1
a2659 2
  if (arches != NULL)
    return arches->gdbarch;
d2661 51
a2711 2
  /* XXX We'll probably need to set the tdep field soon.  */
  gdbarch = gdbarch_alloc (&info, NULL);
d2735 2
d2830 35
a2864 2
  /* XXX We can't do this until NUM_REGS is set for the architecture.
     Even then, we can't use SIZEOF_FRAME_SAVED_REGS, since that still
d2872 1
a2872 1
		 * (NUM_GREGS + NUM_FREGS + NUM_SREGS + NUM_PSEUDO_REGS)));
d2877 40
d2930 6
a2935 1
    register_gdbarch_init (bfd_arch_arm, arm_gdbarch_init);
@


1.40
log
@* arm-tdep.c (arm_use_struct_convention): Make static.  Move to be
with other related struct-returning functions.
(arm_extract_struct_value_address): New function.
(arm_gdbarch_init): Initialize the above in multi-arch vector.  Also
initialize float_format, double_format and long_double_format as
appropriate to the endianness of the target.
* config/arm/tm-arm.h (TARGET_DOUBLE_FORMAT): Delete.
(arm_use_struct_convention): Delete declaration.
(USE_STRUCT_CONVENTION, EXTRACT_STRUCT_VALUE_ADDRESS): Delete.
@
text
@d1356 1
a1356 6
      /* ANSI C code passes float arguments as integers, K&R code
         passes float arguments as doubles.  Correct for this here.  */
      if (TYPE_CODE_FLT == TYPE_CODE (arg_type) && REGISTER_SIZE == len)
	nstack_size += FP_REGISTER_VIRTUAL_SIZE;
      else
	nstack_size += len;
a1392 15
      /* ANSI C code passes float arguments as integers, K&R code
         passes float arguments as doubles.  The .stabs record for 
         for ANSI prototype floating point arguments records the
         type as FP_INTEGER, while a K&R style (no prototype)
         .stabs records the type as FP_FLOAT.  In this latter case
         the compiler converts the float arguments to double before
         calling the function.  */
      if (TYPE_CODE_FLT == typecode && REGISTER_SIZE == len)
	{
	  DOUBLEST dblval;
	  dblval = extract_floating (val, len);
	  len = TARGET_DOUBLE_BIT / TARGET_CHAR_BIT;
	  val = alloca (len);
	  store_floating (val, len, dblval);
	}
@


1.39
log
@* arm-tdep.h: New file.
* arm-tdep.c: Include arm-tdep.h.
(arm_addr_bits_remove, arm_smash_text_address, arm_saved_pc_after_call)
(arm_skip_prologue, arm_call_dummy_words, arm_fix_call_dummy)
(arm_print_float_info, arm_register_type, convert_to_extended)
(arm_elf_make_msymbols_special, arm_coff_make_msymbol_special)
(arm_extract_return_value, arm_register_name): Make static.
(arm_software_single_step): Similarly.  Fix types in declaration.
(arm_register_byte, arm_register_raw_size, arm_register_virtual_size)
(arm_store_return_value, arm_store_struct_return): New functions.
(arm_gdbarch_init): Register the above functions.  Also register
call_dummy_start_offset, sizeof_call_dummy_words,
function_start_offset, inner_than, decr_pc_after_break, fp_regnum,
sp_regnum, pc_regnum, register_bytes, num_regs, max_register_raw_size,
max_register_virtual_size, register_size.  Set up
prologue_cache.saved_regs here, rather than ...
(_initialize_arm_tdep): ... here.
* config/arm/tm-arm.h (struct type, struct value): Delete forward
declarations.
(arm_addr_bits_remove, arm_smash_text_address, arm_saved_pc_after_call)
(arm_skip_prologue, arm_call_dummy_words, arm_fix_call_dummy)
(arm_print_float_info, arm_register_type, convert_to_extended)
(arm_elf_make_msymbols_special, arm_coff_make_msymbol_special)
(arm_extract_return_value, arm_register_name): Delete declarations.
(SMASH_TEXT_ADDRESS, ADDR_BITS_REMOVE, FUNCTION_START_OFFSET)
(SKIP_PROLOGUE, SAVED_PC_AFTER_CALL, INNER_THAN, BREAKPOINT_FROM_PC)
(DECR_PC_AFTER_BREAK, PRINT_FLOAT_INFO, REGISTER_SIZE, NUM_REGS)
(REGISTER_NAME, REGISTER_BYTES, REGISTER_BYTE, REGISTER_RAW_SIZE)
(REGISTER_VIRTUAL_SIZE, MAX_REGISTER_RAW_SIZE)
(MAX_REGISTER_VIRTUAL_SIZE, REGISTER_VIRTUAL_TYPE, STORE_STRUCT_RETURN)
(EXTRACT_RETURN_VALUE, STORE_RETURN_VALUE, CALL_DUMMY_WORDS)
(SIZEOF_CALL_DUMMY_WORDS, CALL_DUMMY_START_OFFSET, FIX_CALL_DUMMY)
(SOFTWARE_SINGLE_STEP_P, SOFTWARE_SINGLE_STEP)
(ELF_MAKE_MSYMBOL_SPECIAL, COFF_MAKE_MSYMBOL_SPECIAL) Delete.
(arm_pc_is_thumb, arm_pc_is_thumb_dummy, thumb_get_next_pc)
(arm_get_next_pc): No-longer static -- these are needed by the RDI
interface.
* arm-linux-nat.c arm-linux-tdep.c armnbsd-nat.c: Include arm-tdep.h.
* remote-rdi.c remote-rdp.c: Likewise.
* Makefile.in (arm-linux-nat.o, arm-linux-tdep.o arm-tdep.o)
(armnbsd-nat.o, remote-rdi.o, remote_rdp.o): Update dependencies.
* config/arm/tm-nbsd.h (SOFTWARE_SINGLE_STEP_P): Delete bogus
definition.

* arm-tdep.h (ARM_A1_REGNUM, ARM_A4_REGNUM, ARM_AP_REGNUM)
(ARM_SP_REGNUM, ARM_LR_REGNUM, ARM_PC_REGNUM, ARM_F0_REGNUM)
(ARM_F3_REGNUM, ARM_F7_REGNUM, ARM_FPS_REGNUM, ARM_PS_REGNUM): Renamed
from non-ARM_ prefixed definitions.
* arm-tdep.c armnbsd-nat.c arm-linux-nat.c arm-linux-tdep.c: Update
all uses of above.
* remote-rdi.c remote-rdp.c: Likewise.
* arm-linux-nat.c (ARM_CPSR_REGNUM): Renamed from CPSR_REGNUM.
@
text
@a147 94
/* Will a function return an aggregate type in memory or in a
   register?  Return 0 if an aggregate type can be returned in a
   register, 1 if it must be returned in memory.  */

int
arm_use_struct_convention (int gcc_p, struct type *type)
{
  int nRc;
  register enum type_code code;

  /* In the ARM ABI, "integer" like aggregate types are returned in
     registers.  For an aggregate type to be integer like, its size
     must be less than or equal to REGISTER_SIZE and the offset of
     each addressable subfield must be zero.  Note that bit fields are
     not addressable, and all addressable subfields of unions always
     start at offset zero.

     This function is based on the behaviour of GCC 2.95.1.
     See: gcc/arm.c: arm_return_in_memory() for details.

     Note: All versions of GCC before GCC 2.95.2 do not set up the
     parameters correctly for a function returning the following
     structure: struct { float f;}; This should be returned in memory,
     not a register.  Richard Earnshaw sent me a patch, but I do not
     know of any way to detect if a function like the above has been
     compiled with the correct calling convention.  */

  /* All aggregate types that won't fit in a register must be returned
     in memory.  */
  if (TYPE_LENGTH (type) > REGISTER_SIZE)
    {
      return 1;
    }

  /* The only aggregate types that can be returned in a register are
     structs and unions.  Arrays must be returned in memory.  */
  code = TYPE_CODE (type);
  if ((TYPE_CODE_STRUCT != code) && (TYPE_CODE_UNION != code))
    {
      return 1;
    }

  /* Assume all other aggregate types can be returned in a register.
     Run a check for structures, unions and arrays.  */
  nRc = 0;

  if ((TYPE_CODE_STRUCT == code) || (TYPE_CODE_UNION == code))
    {
      int i;
      /* Need to check if this struct/union is "integer" like.  For
         this to be true, its size must be less than or equal to
         REGISTER_SIZE and the offset of each addressable subfield
         must be zero.  Note that bit fields are not addressable, and
         unions always start at offset zero.  If any of the subfields
         is a floating point type, the struct/union cannot be an
         integer type.  */

      /* For each field in the object, check:
         1) Is it FP? --> yes, nRc = 1;
         2) Is it addressable (bitpos != 0) and
         not packed (bitsize == 0)?
         --> yes, nRc = 1  
       */

      for (i = 0; i < TYPE_NFIELDS (type); i++)
	{
	  enum type_code field_type_code;
	  field_type_code = TYPE_CODE (TYPE_FIELD_TYPE (type, i));

	  /* Is it a floating point type field?  */
	  if (field_type_code == TYPE_CODE_FLT)
	    {
	      nRc = 1;
	      break;
	    }

	  /* If bitpos != 0, then we have to care about it.  */
	  if (TYPE_FIELD_BITPOS (type, i) != 0)
	    {
	      /* Bitfields are not addressable.  If the field bitsize is 
	         zero, then the field is not packed.  Hence it cannot be
	         a bitfield or any other packed type.  */
	      if (TYPE_FIELD_BITSIZE (type, i) == 0)
		{
		  nRc = 1;
		  break;
		}
	    }
	}
    }

  return nRc;
}

d2115 103
d2454 22
d2556 3
@


1.38
log
@* arm-tdep.c (arm_frameless_function_invocation)
(arm_frame_args_address, arm_frame_locals_address, arm_frame_num_args)
(arm_frame_chain, arm_init_extra_frame_info, arm_frame_saved_pc)
(arm_read_fp, arm_frame_init_saved_regs, arm_push_dummy_frame)
(arm_pop_frame, arm_get_next_pc): Make static.
(arm_gdbarch_init): Register above in gdbarch structure.
(arm_read_fp): Renamed from arm_target_read_fp.
(arm_pc_is_thumb, arm_pc_is_thumb_dummy): Make static.
* config/arm/tm-arm.h (arm_frameless_function_invocation)
(arm_frame_args_address, arm_frame_locals_address, arm_frame_num_args)
(arm_frame_chain, arm_init_extra_frame_info, arm_frame_saved_pc)
(arm_target_read_fp, arm_frame_init_saved_regs, arm_push_dummy_frame)
(arm_pop_frame, arm_get_next_pc, arm_pc_is_thumb)
(arm_pc_is_thumb_dummy): Delete declarations.
@
text
@d22 2
a30 1
#include "coff/internal.h"	/* Internal format of COFF symbols in BFD */
a31 1
#include <ctype.h>		/* for isupper () */
d35 1
d37 3
d269 1
a269 1
static int
d293 1
a293 1
static int
d312 1
a312 1
CORE_ADDR
d323 1
a323 1
CORE_ADDR
d329 6
a334 1
CORE_ADDR
d337 1
a337 1
  return ADDR_BITS_REMOVE (read_register (LR_REGNUM));
d468 4
a471 1
/* The APCS (ARM Procedure Call Standard) defines the following
d483 1
a483 1
CORE_ADDR
d641 1
a641 1
	  for (regno = LR_REGNUM; regno >= 0; regno--)
d677 1
a677 1
	  saved_reg[THUMB_FP_REGNUM] = SP_REGNUM;
d824 1
a824 1
  fi->extra_info->framereg = SP_REGNUM;
d925 1
a925 1
	  for (regno = PC_REGNUM; regno >= 0; regno--)
d938 1
a938 1
	  fi->extra_info->framereg = FP_REGNUM;
d950 1
a950 1
	  regno = F0_REGNUM + ((insn >> 12) & 0x07);
d973 1
a973 1
	  fp_start_reg = F0_REGNUM + ((insn >> 12) & 0x7);
d995 1
a995 1
  if (fi->extra_info->framereg == FP_REGNUM)
d1043 1
a1043 1
  fp = arm_find_callers_reg (fi, FP_REGNUM);
d1096 1
a1096 1
  if (framereg == FP_REGNUM || framereg == THUMB_FP_REGNUM)
d1137 2
a1138 1
      fi->frame = generic_read_register_dummy (fi->pc, fi->frame, SP_REGNUM);
d1173 1
a1173 1
      fi->extra_info->framereg = SP_REGNUM;
d1190 3
a1192 3
      fi->saved_regs[PS_REGNUM] = rp;
      rp -= REGISTER_RAW_SIZE (PS_REGNUM);
      for (reg = PC_REGNUM; reg >= 0; reg--)
d1198 3
a1200 3
      callers_sp = read_memory_integer (fi->saved_regs[SP_REGNUM],
                                        REGISTER_RAW_SIZE (SP_REGNUM));
      fi->extra_info->framereg = FP_REGNUM;
d1211 1
a1211 1
      else if (fi->extra_info->framereg == FP_REGNUM
d1236 1
a1236 1
/* Find the caller of this frame.  We do this by seeing if LR_REGNUM
d1249 1
a1249 1
    return generic_read_register_dummy (fi->pc, fi->frame, PC_REGNUM);
d1255 2
a1256 2
      return read_memory_integer (fi->saved_regs[PC_REGNUM],
				  REGISTER_RAW_SIZE (PC_REGNUM));
d1260 1
a1260 1
      CORE_ADDR pc = arm_find_callers_reg (fi, LR_REGNUM);
d1271 1
a1271 1
  if (read_register (PS_REGNUM) & 0x20)		/* Bit 5 is Thumb state bit */
d1274 1
a1274 1
    return read_register (FP_REGNUM);	/* R11 if ARM */
d1298 1
a1298 1
  CORE_ADDR old_sp = read_register (SP_REGNUM);
d1316 1
a1316 1
  sp = push_word (sp, read_register (PS_REGNUM));
d1319 1
a1319 1
  for (regnum = PC_REGNUM; regnum >= 0; regnum--)
d1323 1
a1323 1
  write_register (FP_REGNUM, fp);
d1325 1
a1325 1
  write_register (SP_REGNUM, sp);
d1337 1
a1337 1
LONGEST arm_call_dummy_words[] =
d1357 1
a1357 1
void
d1468 1
a1468 1
  argreg = A1_REGNUM;
d1569 2
a1570 2
  write_register (PC_REGNUM, FRAME_SAVED_PC (frame));
  write_register (SP_REGNUM, old_SP);
d1593 1
a1593 1
void
d1596 1
a1596 1
  register unsigned long status = read_register (FPS_REGNUM);
d1609 4
a1612 1
struct type *
d1615 1
a1615 1
  if (regnum >= F0_REGNUM && regnum < F0_REGNUM + NUM_FREGS)
d1626 46
d1689 1
a1689 1
void
d1814 1
a1814 1
static CORE_ADDR
d1829 1
a1829 1
      sp = read_register (SP_REGNUM);
d1837 1
a1837 1
      unsigned long status = read_register (PS_REGNUM);
d1856 1
a1856 1
static CORE_ADDR
d1869 1
a1869 1
  status = read_register (PS_REGNUM);
d2086 2
a2087 2
void
arm_software_single_step (int ignore, int insert_bpt)
d2094 1
a2094 1
      next_pc = arm_get_next_pc (read_register (PC_REGNUM));
d2143 2
a2144 2
/* This function implements the BREAKPOINT_FROM_PC macro.  It uses the
   program counter value to determine whether a 16-bit or 32-bit
d2151 5
d2197 1
a2197 1
void
d2203 1
a2203 1
    convert_from_extended (&regbuf[REGISTER_BYTE (F0_REGNUM)], valbuf);
d2205 30
a2234 1
    memcpy (valbuf, &regbuf[REGISTER_BYTE (A1_REGNUM)], TYPE_LENGTH (type));
d2299 2
a2300 2
char *
arm_register_name(int i)
d2324 1
a2324 1
  if (isupper (*regnames[PC_REGNUM]))
d2326 2
a2327 2
      arm_register_names[FPS_REGNUM] = "FPS";
      arm_register_names[PS_REGNUM] = "CPSR";
d2331 2
a2332 2
      arm_register_names[FPS_REGNUM] = "fps";
      arm_register_names[PS_REGNUM] = "cpsr";
d2417 1
a2417 1
void
d2427 1
a2427 1
void
d2453 6
d2480 65
d2624 1
a2626 2
  prologue_cache.saved_regs = (CORE_ADDR *)
    xcalloc (1, SIZEOF_FRAME_SAVED_REGS);
@


1.37
log
@* arm-tdep.c (arm_frame_chain_valid): Make static.
(arm_push_arguments): Likewise.
(arm_gdbarch_init): New function.
(_initialize_arm_tdep): Call it.
* config/arm/tm-arm.h (GDB_MULTI_ARCH): Set to 1.
(TARGET_DOUBLE_FORMAT): Test TARGET_BYTE_ORDER, not target_byte_order.
(FRAME_CHAIN_VALID): Delete.
(arm_frame_chain_valid): Delete declaration.
(PUSH_ARGUMENTS): Delete.
(arm_push_arguments): Delete declaration.
(CALL_DUMMY_P): Delete.
@
text
@d265 1
a265 1
int
d289 1
a289 1
int
d335 1
a335 1
int
d365 1
a365 1
CORE_ADDR
d372 1
a372 1
CORE_ADDR
d379 1
a379 1
int
d1013 5
a1017 17
/* *INDENT-OFF* */
/* Function: frame_chain
   Given a GDB frame, determine the address of the calling function's frame.
   This will be used to create a new GDB frame struct, and then
   INIT_EXTRA_FRAME_INFO and INIT_FRAME_PC will be called for the new frame.
   For ARM, we save the frame size when we initialize the frame_info.

   The original definition of this function was a macro in tm-arm.h:
      { In the case of the ARM, the frame's nominal address is the FP value,
	 and 12 bytes before comes the saved previous FP value as a 4-byte word.  }

      #define FRAME_CHAIN(thisframe)  \
	((thisframe)->pc >= LOWEST_PC ?    \
	 read_memory_integer ((thisframe)->frame - 12, 4) :\
	 0)
*/
/* *INDENT-ON* */
d1019 1
a1019 1
CORE_ADDR
d1099 1
a1099 1
void
d1231 1
a1231 1
CORE_ADDR
d1255 2
a1256 2
CORE_ADDR
arm_target_read_fp (void)
d1264 5
a1268 1
/* Calculate the frame offsets of the saved registers (ARM version).  */
d1270 1
a1270 1
void
d1280 3
a1282 1
void
d1542 1
a1542 1
void
d1794 1
a1794 1
CORE_ADDR
d2362 1
d2364 14
@


1.36
log
@* arm-tdep.c: Include elf-bfd.h and coff/internal.h.
(MSYMBOL_SET_SPECIAL, MSYMBOL_IS_SPECIAL, MSYMBOL_SIZE): Move defines
to here from config/tm-arm.h.
(coff_sym_is_thumb): Make static.
(arm_elf_make_msymbol_special): New function.
(arm_coff_make_msymbol_special): New function.
* config/arm/tm-arm.h (MSYMBOL_SET_SPECIAL): Delete definition.
(MSYMBOL_IS_SPECIAL, MSYMBOL_SIZE): Likewise.
(coff_sym_is_thumb): Delete declaration.
(arm_elf_make_msymbol_special): Declare.
(arm_coff_make_msymbol_special): Declare.
(ELF_MAKE_MSYMBOL_SPECIAL): Call arm_elf_make_msymbol_special.
(COFF_MAKE_MSYMBOL_SPECIAL): Call arm_coff_make_msymbol_special.
@
text
@d238 1
a238 1
int
d1420 1
a1420 1
CORE_ADDR
d2344 29
d2384 3
@


1.35
log
@* arm-tdep.c (arm_software_single_step): ANSIfy function declaration.
@
text
@d36 2
d69 21
a89 1
extern void _initialize_arm_tdep (void);
d2307 37
a2419 13
}

/* Test whether the coff symbol specific value corresponds to a Thumb
   function.  */

int
coff_sym_is_thumb (int val)
{
  return (val == C_THUMBEXT ||
	  val == C_THUMBSTAT ||
	  val == C_THUMBEXTFUNC ||
	  val == C_THUMBSTATFUNC ||
	  val == C_THUMBLABEL);
@


1.34
log
@* gdbarch.sh (PRINT_FLOAT_INFO): Add rule.
* gdbarch.c gdbarch.h: Regenerate.
* arch-utils.c (default_print_float_info): New function.
* arch-utils.h (default_print_float_info): Prototype it.
* infcmd.c (float_info): Call PRINT_FLOAT_INFO.
* doc/gdbint.texinfo (FLOAT_INFO): Mark as deprecated.
(PRINT_FLOAT_INFO): Document it.

* arm-tdep.c (arm_print_float_info): Renamed from arm_float_info.
* config/arm/tm-arm.h (FLOAT_INFO): Delete.
(PRINT_FLOAT_INFO): Define.
@
text
@d2009 1
a2009 3
arm_software_single_step (ignore, insert_bpt)
     int ignore; /* Signal, not needed */
     int insert_bpt;
@


1.33
log
@* cli/cli-decode.c (do_cfunc, set_cmd_cfunc): New functions.
(do_sfunc, set_cmd_sfunc): New functions.

* command.h (struct cmd_list_element): Add field func.
* cli/cli-decode.h (struct cmd_list_element): Ditto.
* command.h (set_cmd_sfunc, set_cmd_cfunc): Declare.
* cli/cli-decode.h: Ditto.

* cli/cli-decode.c (help_cmd): Test for func not cfunc/sfunc.
(help_all, help_cmd_list): Ditto.
(find_cmd, complete_on_cmdlist): Ditto.
* top.c (execute_command): Ditto.

* cli/cli-setshow.c (do_setshow_command): Call func instead of
function.sfunc.

* infcmd.c (notice_args_read): Fix function signature.

* cli/cli-cmds.c (init_cli_cmds): Use set_cmd_sfunc.
* cli/cli-decode.c (add_set_cmd): Ditto.
* utils.c (initialize_utils): Ditto.
* maint.c (_initialize_maint_cmds): Ditto.
* infrun.c (_initialize_infrun): Ditto.
* demangle.c (_initialize_demangler): Ditto.
* remote.c (add_packet_config_cmd): Ditto.
* mips-tdep.c (_initialize_mips_tdep): Ditto.
* cris-tdep.c (_initialize_cris_tdep): Ditto.
* proc-api.c (_initialize_proc_api): Ditto.
* kod.c (_initialize_kod): Ditto.
* valprint.c (_initialize_valprint): Ditto.
* top.c (init_main): Ditto.
* infcmd.c (_initialize_infcmd): Ditto.
* corefile.c (_initialize_core): Ditto.
* arm-tdep.c (_initialize_arm_tdep): Ditto.
* arch-utils.c (initialize_current_architecture): Ditto.
(_initialize_gdbarch_utils): Ditto.
* alpha-tdep.c (_initialize_alpha_tdep): Ditto.

* cli/cli-decode.c (add_cmd): Use set_cmd_cfunc.
* wince.c (_initialize_inftarg): Ditto.
* symfile.c (_initialize_symfile): Ditto.
* mips-tdep.c (_initialize_mips_tdep): Ditto.
* language.c (_initialize_language): Ditto.
* arc-tdep.c (_initialize_arc_tdep): Ditto.
@
text
@d1562 2
d1565 1
a1565 1
arm_float_info (void)
@


1.32
log
@* gdbarch.sh (copyright): Update years in generated header.
(SMASH_TEXT_ADDRESS): Add rule.
*gdbarch.h, gdbarch.c: Re-generate.
* coffread.c: Multi-arch uses of SMASH_TEXT_ADDRESS.
* dbxread.c: Likewise.
* dwarfread.c: Likewise.
* elfread.c: Likewise.
* somread.c: Likewise.

* arm-tdep.c (arm_smash_text_address): New function.
* config/arm/tm-arm.h (SMASH_TEXT_ADDRESS): Define in terms of above.
@
text
@d2342 1
a2342 1
  new_cmd->function.sfunc = set_disassembly_flavor_sfunc;
@


1.31
log
@* arm-tdep.c (arm_frameless_function_invocation): Add some comments.
(arm_frame_args_address, arm_frame_locals_address): New functions.
(arm_frame_num_args): New function.
* config/tm-arm.h (FRAME_ARGS_ADDRESS): Call arm_frame_args_address.
(FRAME_LOCALS_ADDRESS): Call arm_frame_locals_address.
(FRMA_NUM_ARGS): Call arm_frame_num_args.
@
text
@d285 1
d293 8
@


1.30
log
@* arm-tdep.c (arm_call_dummy_words): Define.
* arm-linux-tdep.c (arm_linux_call_dummy_words): Define.
* config/arm/tm-arm.h (CALL_DUMMY_P): Define.
(CALL_DUMMY_WORDS): Define.
(arm_call_dummy_words): Declare.
* config/arm/tm-linux.h (CALL_DUMMY_WORDS): Define.
(arm_linux_call_dummy_words): Declare.
@
text
@d300 4
d310 12
d331 22
@


1.29
log
@Approved by fnasser@@redhat.com:

	2002-01-21  Fred Fish  <fnf@@redhat.com>
	* arm-tdep.c (thumb_skip_prologue): Quit scanning prologue
	when we have found all instructions we are looking for.
@
text
@d1252 14
@


1.28
log
@* arm-tdep.c (arm_register_name): New function.
(arm_registers_names): Make static.
* config/arm/tm-arm.h (arm_register_names): Delete declaration.
(arm_register_name): Declare.
(REGISTER_NAME): Use it.
@
text
@d378 4
@


1.27
log
@Richard Earnshaw  <rearnsha@@arm.com>
and Kevin Buettner  <kevinb@@redhat.com>
Convert arm targets to new FRAME interface.
* arm-tdep.c (struct frame_extra_info): Remove fsr.
(arm_frame_find_save_regs): Delete.
(arm_frame_init_saved_regs): New.
(arm_init_extra_frame_info): Alloacte saved_regs as required.
Allocate extra_info as required.  Convert all uses of fsr.regs
to use saved_regs, similarly all uses of EXTRA_FRAME_INFO fields
to use extra_info.
(thumb_scan_prologue, arm_scan_prologue, arm_find_callers_reg)
(arm_frame_chain, arm_frame_saved_pc, arm_pop_frame): Likewise.
(check_prologue_cache, save_prologue_cache): Likewise.
(_initialize_arm_tdep): Ensure prologue_cache is correctly set up.
* config/arm/tm-arm.h (EXTRA_FRAME_INFO): Delete.
(FRAME_FIND_SAVED_REGS): Delete.
(arm_frame_find_saved_regs): Delete prototype.
(arm_frame_init_saved_regs): New prototype.
(FRAME_INIT_SAVED_REGS): Define.
@
text
@d86 1
a86 1
char **arm_register_names = arm_register_name_strings;
d2121 7
@


1.26
log
@MAINTAINERS (write-after-approval): Add myself.

arm-tdep.c (arm_init_extra_frame_info): Cast NULL argument to
IN_SIGTRAMP.
@
text
@d3 1
a3 1
   2001 Free Software Foundation, Inc.
d110 5
a114 6
  {
    struct frame_saved_regs fsr;
    int framesize;
    int frameoffset;
    int framereg;
  };
d536 1
a536 1
  fi->framesize = 0;
d559 3
a561 2
		fi->framesize += 4;
		fi->fsr.regs[saved_reg[regno]] = -(fi->framesize);
d575 1
a575 1
	      fi->frameoffset += offset;
d578 1
a578 1
	  fi->framesize -= offset;
d583 3
a585 2
	  fi->framereg = THUMB_FP_REGNUM;
	  fi->frameoffset = (insn & 0xff) << 2;		/* get scaled offset */
d590 2
a591 2
	  fi->framereg = THUMB_FP_REGNUM;
	  fi->frameoffset = 0;
d631 5
a635 5
      fi->framereg = prologue_cache.framereg;
      fi->framesize = prologue_cache.framesize;
      fi->frameoffset = prologue_cache.frameoffset;
      for (i = 0; i < NUM_REGS; i++)
	fi->fsr.regs[i] = prologue_cache.fsr.regs[i];
d651 3
a653 3
  prologue_cache.framereg = fi->framereg;
  prologue_cache.framesize = fi->framesize;
  prologue_cache.frameoffset = fi->frameoffset;
d655 2
a656 2
  for (i = 0; i < NUM_REGS; i++)
    prologue_cache.fsr.regs[i] = fi->fsr.regs[i];
d739 3
a741 3
  fi->framereg = SP_REGNUM;
  fi->framesize = 0;
  fi->frameoffset = 0;
d844 1
a844 1
		fi->fsr.regs[regno] = sp_offset;
d853 1
a853 1
	  fi->framereg = FP_REGNUM;
d866 1
a866 1
	  fi->fsr.regs[regno] = sp_offset;
d893 1
a893 1
	      fi->fsr.regs[fp_start_reg++] = sp_offset;
d909 3
a911 3
  fi->framesize = -sp_offset;
  if (fi->framereg == FP_REGNUM)
    fi->frameoffset = fp_offset - sp_offset;
d913 1
a913 1
    fi->frameoffset = 0;
d935 2
a936 2
    if (fi->fsr.regs[regnum] != 0)
      return read_memory_integer (fi->fsr.regs[regnum],
d979 1
a979 2
  struct frame_info caller_fi;
  int framereg = fi->framereg;
d994 2
d998 5
d1004 8
d1014 5
a1018 1
      framereg = caller_fi.framereg;
d1026 1
a1026 1
    return fi->frame + fi->framesize;
d1044 10
d1057 1
a1057 1
  memset (fi->fsr.regs, '\000', sizeof fi->fsr.regs);
d1065 2
a1066 2
      fi->framesize = 0;
      fi->frameoffset = 0;
d1077 2
a1078 1
    sp = fi->next->frame - fi->next->frameoffset + fi->next->framesize;
d1096 1
a1096 1
	fi->fsr.regs[reg] = SIGCONTEXT_REGISTER_ADDRESS (sp, fi->pc, reg);
d1099 6
a1104 5
      fi->framereg = SP_REGNUM;
      fi->frame = read_memory_integer (fi->fsr.regs[fi->framereg],
                                       REGISTER_RAW_SIZE (fi->framereg));
      fi->framesize = 0;
      fi->frameoffset = 0;
d1116 1
a1116 1
      fi->fsr.regs[PS_REGNUM] = rp;
d1120 1
a1120 1
	  fi->fsr.regs[reg] = rp;
d1124 1
a1124 1
      callers_sp = read_memory_integer (fi->fsr.regs[SP_REGNUM],
d1126 3
a1128 3
      fi->framereg = FP_REGNUM;
      fi->framesize = callers_sp - sp;
      fi->frameoffset = fi->frame - sp;
d1136 3
a1138 2
	fi->frame = read_register (fi->framereg);
      else if (fi->framereg == FP_REGNUM || fi->framereg == THUMB_FP_REGNUM)
d1142 1
a1142 1
	  if (fi->next->fsr.regs[fi->framereg] != 0)
d1144 2
a1145 1
	      read_memory_integer (fi->next->fsr.regs[fi->framereg], 4);
d1155 3
a1157 2
	if (fi->fsr.regs[reg] != 0)
	  fi->fsr.regs[reg] += fi->frame + fi->framesize - fi->frameoffset;
d1178 2
a1179 1
  if (PC_IN_CALL_DUMMY (fi->pc, fi->frame - fi->frameoffset, fi->frame))
d1181 2
a1182 1
      return read_memory_integer (fi->fsr.regs[PC_REGNUM], REGISTER_RAW_SIZE (PC_REGNUM));
d1206 1
a1206 2
arm_frame_find_saved_regs (struct frame_info *fi,
			   struct frame_saved_regs *regaddr)
d1208 5
a1212 1
  memcpy (regaddr, &fi->fsr, sizeof (struct frame_saved_regs));
d1466 2
a1467 1
  CORE_ADDR old_SP = frame->frame - frame->frameoffset + frame->framesize;
d1470 1
a1470 1
    if (frame->fsr.regs[regnum] != 0)
d1472 1
a1472 1
		  read_memory_integer (frame->fsr.regs[regnum],
d2283 6
@


1.25
log
@s/BIG_ENDIAN/BFD_ENDIAN_BIG/
@
text
@d1063 1
a1063 1
      && (fi->signal_handler_caller || IN_SIGTRAMP (fi->pc, 0)))
@


1.24
log
@	* arm-tdep.c (arm_scan_prologue): Don't require "mov ip, sp"
	to be the first instruction in the prologue.  Also, revise
	the way the frame offset is computed for frameless functions.
@
text
@d1478 1
a1478 1
      if (TARGET_BYTE_ORDER == BIG_ENDIAN)
d1496 1
a1496 1
  if (TARGET_BYTE_ORDER == BIG_ENDIAN)
d1509 1
a1509 1
  if (TARGET_BYTE_ORDER == BIG_ENDIAN)
d1954 1
a1954 1
  if (TARGET_BYTE_ORDER == BIG_ENDIAN)
d1973 1
a1973 1
      if (TARGET_BYTE_ORDER == BIG_ENDIAN)
d1990 1
a1990 1
      if (TARGET_BYTE_ORDER == BIG_ENDIAN)
@


1.23
log
@Fix some ARM call dummy problems.
@
text
@d815 3
a817 1
     if we don't see this as the first insn, we will stop.  */
d823 5
d829 6
a834 2
      for (current_pc = prologue_start + 4; current_pc < prologue_end;
	   current_pc += 4)
d836 1
a836 1
	  unsigned int insn = read_memory_unsigned_integer (current_pc, 4);
d838 33
a870 6
	  if ((insn & 0xffff0000) == 0xe92d0000)
	    /* stmfd sp!, {..., fp, ip, lr, pc}
	       or
	       stmfd sp!, {a1, a2, a3, a4}  */
	    {
	      int mask = insn & 0xffff;
d872 1
a872 9
	      /* Calculate offsets of saved registers. */
	      for (regno = PC_REGNUM; regno >= 0; regno--)
		if (mask & (1 << regno))
		  {
		    sp_offset -= 4;
		    fi->fsr.regs[regno] = sp_offset;
		  }
	    }
	  else if ((insn & 0xfffff000) == 0xe24cb000)	/* sub fp, ip #n */
d874 4
a877 5
	      unsigned imm = insn & 0xff;	/* immediate value */
	      unsigned rot = (insn & 0xf00) >> 7;	/* rotate amount */
	      imm = (imm >> rot) | (imm << (32 - rot));
	      fp_offset = -imm;
	      fi->framereg = FP_REGNUM;
d879 1
a879 1
	  else if ((insn & 0xfffff000) == 0xe24dd000)	/* sub sp, sp #n */
d881 4
a884 4
	      unsigned imm = insn & 0xff;	/* immediate value */
	      unsigned rot = (insn & 0xf00) >> 7;	/* rotate amount */
	      imm = (imm >> rot) | (imm << (32 - rot));
	      sp_offset -= imm;
d886 4
a889 1
	  else if ((insn & 0xffff7fff) == 0xed6d0103)	/* stfe f?, [sp, -#c]! */
d892 1
a892 2
	      regno = F0_REGNUM + ((insn >> 12) & 0x07);
	      fi->fsr.regs[regno] = sp_offset;
a893 36
	  else if ((insn & 0xffbf0fff) == 0xec2d0200)	/* sfmfd f0, 4, [sp!] */
	    {
	      int n_saved_fp_regs;
	      unsigned int fp_start_reg, fp_bound_reg;

	      if ((insn & 0x800) == 0x800)	/* N0 is set */
		{
		  if ((insn & 0x40000) == 0x40000)	/* N1 is set */
		    n_saved_fp_regs = 3;
		  else
		    n_saved_fp_regs = 1;
		}
	      else
		{
		  if ((insn & 0x40000) == 0x40000)	/* N1 is set */
		    n_saved_fp_regs = 2;
		  else
		    n_saved_fp_regs = 4;
		}

	      fp_start_reg = F0_REGNUM + ((insn >> 12) & 0x7);
	      fp_bound_reg = fp_start_reg + n_saved_fp_regs;
	      for (; fp_start_reg < fp_bound_reg; fp_start_reg++)
		{
		  sp_offset -= 12;
		  fi->fsr.regs[fp_start_reg++] = sp_offset;
		}
	    }
	  else if ((insn & 0xf0000000) != 0xe0000000)
	    break;	/* Condition not true, exit early */
	  else if ((insn & 0xfe200000) == 0xe8200000) /* ldm? */
	    break;	/* Don't scan past a block load */
	  else
	    /* The optimizer might shove anything into the prologue,
	       so we just skip what we don't recognize. */
	    continue;
d895 8
d909 4
a912 1
  fi->frameoffset = fp_offset - sp_offset;
@


1.22
log
@2001-12-19  Elena Zannoni  <ezannoni@@redhat.com>

        * corefile.c (do_captured_read_memory_integer,
        safe_read_memory_integer): New functions.
        * gdbcore.h (safe_read_memory_integer): Export.
        * arm-tdep.c (arm_scan_prologue): Use safe_read_memory_integer,
        to read the frame value, to capture calls to error().
@
text
@d1017 1
d1037 7
d1054 1
a1054 1
     to IN_SIGTRAMP. */
a1058 7
      CORE_ADDR sp;

      if (!fi->next)
	sp = read_sp();
      else
	sp = fi->next->frame - fi->next->frameoffset + fi->next->framesize;

d1064 2
a1065 1
      fi->frame = read_memory_integer (fi->fsr.regs[fi->framereg], 4);
d1070 23
d1138 5
a1188 3
  sp = push_word (sp, read_register (PC_REGNUM));	/* FIXME: was PS_REGNUM */
  sp = push_word (sp, old_sp);
  sp = push_word (sp, read_register (FP_REGNUM));
d1190 5
a1194 1
  for (regnum = 10; regnum >= 0; regnum--)
d1197 1
d1412 4
d1421 1
d1423 5
a1427 9
  if (!PC_IN_CALL_DUMMY(frame->pc, frame->frame, read_fp()))
    {
      CORE_ADDR old_SP;

      old_SP = read_register (frame->framereg);
      for (regnum = 0; regnum < NUM_REGS; regnum++)
        if (frame->fsr.regs[regnum] != 0)
          write_register (regnum,
		      read_memory_integer (frame->fsr.regs[regnum], 4));
d1429 2
a1430 23
      write_register (PC_REGNUM, FRAME_SAVED_PC (frame));
      write_register (SP_REGNUM, old_SP);
    }
  else
    {
      CORE_ADDR sp;

      sp = read_register (FP_REGNUM);
      sp -= sizeof(CORE_ADDR); /* we don't care about this first word */

      write_register (PC_REGNUM, read_memory_integer (sp, 4));
      sp -= sizeof(CORE_ADDR);
      write_register (SP_REGNUM, read_memory_integer (sp, 4));
      sp -= sizeof(CORE_ADDR);
      write_register (FP_REGNUM, read_memory_integer (sp, 4));
      sp -= sizeof(CORE_ADDR);

      for (regnum = 10; regnum >= 0; regnum--)
        {
          write_register (regnum, read_memory_integer (sp, 4));
          sp -= sizeof(CORE_ADDR);
        }
    }
@


1.21
log
@2001-12-19  Fernando Nasser  <fnasser@@redhat.com>

	* config/arm/tm-arm.h: Properly define SOFTWARE_SINGLE_STEP_P.
	Always define SOFTWARE_SINGLE_STEP.
	* config/arm/tm-embed.h: Properly define SOFTWARE_SINGLE_STEP_P.
	* arm-tdep.c (arm_get_next_pc, thumb_get_next_pc, bitcount,
	shifted_reg_val): Always compile these functions.
	(arm_software_single_step): Fix second argument in function calls.
@
text
@d730 1
d795 7
a801 3
      prologue_start = ADDR_BITS_REMOVE (read_memory_integer (fi->frame, 4))
	- 8;
      prologue_end = prologue_start + 64;	/* See above. */
@


1.20
log
@2001-12-17  Fernando Nasser  <fnasser@@redhat.com>

	From Richard Earnshaw <rearnsha@@arm.com>:
	* arm-tdep.c (arm_software_single_step): New function. Implements
	software single-stepping for ARM targets.
	(arm_get_next_pc, thumb_get_next_pc, bitcount, shifted_reg_val): Only
	needed for software single-stepping.
	* config/arm/tm-arm.h: Activate SOFTWARE_SINGLE_STEP_P.
@
text
@a1534 1
#if SOFTWARE_SINGLE_STEP_P
d1889 1
a1889 1
      target_insert_breakpoint (next_pc, &break_mem);
d1892 1
a1892 1
    target_remove_breakpoint (next_pc, &break_mem);
a1893 1
#endif /* SOFTWARE_SINGLE_STEP_P */
@


1.19
log
@	* arm-tdep.c (arm_skip_prologue): Always skip prologue by scanning
	the prologue if source is assembler.
@
text
@d1535 2
d1870 26
@


1.18
log
@Define SVR4 link map offset fetcher for Linux/ARM.
@
text
@d405 1
d410 1
a410 1
  if (find_pc_partial_function (pc, NULL, &func_addr, &func_end))
d412 11
a422 3
      sal = find_pc_line (func_addr, 0);
      if ((sal.line != 0) && (sal.end < func_end))
	return sal.end;
@


1.17
log
@* arm-tdep.c (arm_register_type): New function.
(arm_register_convertible): Delete.
(arm_register_convert_to_virtual): Delete.
(arm_register_convert_to_raw): Delete.
* config/arm/tm-arm.h (REGISTER_CONVERTIBLE): Delete.
(REGISTER_CONVERT_TO_VIRTUAL): Delete.
(REGISTER_CONVERT_TO_RAW): Delete.
(REGISTER_VIRTUAL_TYPE): Redefine as call to arm_register_type.
(arm_register_type): Declare.
@
text
@d35 1
d2070 43
@


1.16
log
@Add explicit #include of "value.h".
@
text
@d1440 14
a1480 34
}

/* Nonzero if register N requires conversion from raw format to
   virtual format.  */

int
arm_register_convertible (unsigned int regnum)
{
  return ((regnum - F0_REGNUM) < 8);
}

/* Convert data from raw format for register REGNUM in buffer FROM to
   virtual format with type TYPE in buffer TO.  */

void
arm_register_convert_to_virtual (unsigned int regnum, struct type *type,
				 void *from, void *to)
{
  double val;

  convert_from_extended (from, &val);
  store_floating (to, TYPE_LENGTH (type), val);
}

/* Convert data from virtual format with type TYPE in buffer FROM to
   raw format for register REGNUM in buffer TO.  */

void
arm_register_convert_to_raw (unsigned int regnum, struct type *type,
			     void *from, void *to)
{
  double val = extract_floating (from, TYPE_LENGTH (type));

  convert_to_extended (&val, to);
@


1.15
log
@* arm-tdep.c (convert_from_extended, convert_to_extended): Delete
assembler version of function.
(convert_from_extended, convert_to_extended): Rewrite. Use
floatformat_to_doublest, floatformat_from_doublest,
floatformat_arm_ext_big, floatformat_arm_ext_littlebyte_bigword.
(arm_push_arguments): Use extract_floating and store_floating to
perform floating point conversions.
(SWAP_TARGET_AND_HOST): Delete macro.
* arm-linux-tdep.c (arm_linux_push_arguments): Use
extract_floating and store_floating to perform floating point
conversions.
@
text
@d34 1
@


1.14
log
@* defs.h (HOST_FLOAT_FORMAT, HOST_DOUBLE_FORMAT)
(HOST_FLOAT_FORMAT, HOST_DOUBLE_FORMAT)
(HOST_LONG_DOUBLE_FORMAT, DOUBLEST)
(floatformat_to_doublest, floatformat_from_doublest)
(floatformat_is_negative, floatformat_is_nan)
(floatformat_mantissa, store_floating)
(extract_floating): Move declaration from here.
* doublest.h: To here.  New file.
* utils.c (get_field, floatformat_to_doublest, put_field)
(ldfrexp, floatformat_from_doublest, floatformat_is_negative)
(floatformat_is_nan, floatformat_mantissa)
(FLOATFORMAT_CHAR_BIT): Move from here.
* doublest.c: To here.  New file.
* findvar.c (store_floating, extract_floating): Move from here.
* doublest.c: To here.
* Makefile.in (SFILES): Add doublest.c.
(COMMON_OBS): Add doublest.o.
(doublest.o): Specify dependencies.
(doublest_h): Define.

* config/m88k/tm-m88k.h: Include "doublest.h".
* config/i960/tm-i960.h: Ditto.
* config/i386/tm-symmetry.h: Ditto.
* rs6000-tdep.c, valarith.c: Ditto.
* valprint.c, stabsread.c, sh-tdep.c: Ditto.
* ia64-tdep.c, i387-tdep.c, i386-tdep.c: Ditto.
* values.c, arm-tdep.c, arm-linux-tdep.c: Ditto.
* alpha-tdep.c, ax.h, expression.h: Ditto.
* sh-tdep.c, parse.c, top.c, value.h: Ditto.

* Makefile.in (arm-tdep.o): Add $(doublest_h).
(i386-tdep.o, i387-tdep.o, ia64-tdep.o): Ditto.
(rs6000-tdep.o, stabsread.o, valarith.o): Ditto.
(values.o, valprint.o, arm-linux-tdep.o): Ditto.
(alpha-tdep.o, ax_h, parse.o, top.o, value_h): Ditto.
(parser_defs_h): Ditto.
(expression_h): Add $(doublest_h) and $(symtab_h).
@
text
@a120 18
#define SWAP_TARGET_AND_HOST(buffer,len) 				\
  do									\
    {									\
      if (TARGET_BYTE_ORDER != HOST_BYTE_ORDER)				\
	{								\
	  char tmp;							\
	  char *p = (char *)(buffer);					\
	  char *q = ((char *)(buffer)) + len - 1;		   	\
	  for (; p < q; p++, q--)				 	\
	    {								\
	      tmp = *q;							\
	      *q = *p;							\
	      *p = tmp;							\
	    }								\
	}								\
    }									\
  while (0)

a1294 1
      double dbl_arg;
d1314 5
a1318 16
	  float f;
	  double d;
	  char * bufo = (char *) &d;
	  char * bufd = (char *) &dbl_arg;

	  len = sizeof (double);
	  f = *(float *) val;
	  SWAP_TARGET_AND_HOST (&f, sizeof (float));  /* adjust endianess */
	  d = f;
	  /* We must revert the longwords so they get loaded into the
	     the right registers. */
	  memcpy (bufd, bufo + len / 2, len / 2);
	  SWAP_TARGET_AND_HOST (bufd, len / 2);  /* adjust endianess */
	  memcpy (bufd + len / 2, bufo, len / 2);
	  SWAP_TARGET_AND_HOST (bufd + len / 2, len / 2); /* adjust endianess */
	  val = (char *) &dbl_arg;
d1439 4
a1442 4
#if 0
/* FIXME:  The generated assembler works but sucks.  Instead of using
   r0, r1 it pushes them on the stack, then loads them into r3, r4 and
   uses those registers.  I must be missing something.  ScottB  */
a1443 20
void
convert_from_extended (void *ptr, void *dbl)
{
  __asm__ ("
	   ldfe f0,[%0]
	   stfd f0,[%1] "
:				/* no output */
:	   "r" (ptr), "r" (dbl));
}

void
convert_to_extended (void *dbl, void *ptr)
{
  __asm__ ("
	   ldfd f0,[%0]
	   stfe f0,[%1] "
:				/* no output */
:	   "r" (dbl), "r" (ptr));
}
#else
d1447 7
a1453 1
  *(double *) dbl = *(double *) ptr;
d1459 7
a1465 1
  *(double *) ptr = *(double *) dbl;
a1466 1
#endif
@


1.13
log
@s/value_ptr/struct value */
@
text
@d33 1
@


1.12
log
@Update/correct copyright notices.
@
text
@d1189 1
a1189 1
		    value_ptr *args, struct type *type, int gcc_p)
d1258 1
a1258 1
arm_push_arguments (int nargs, value_ptr * args, CORE_ADDR sp,
@


1.12.2.1
log
@Typesystem work initial import.
Note that this currently isn't building, i'm in the middle of converting make_function_type/lookup_function_type
@
text
@d1356 2
a1357 2
	  && POINTER_TARGET_TYPE (arg_type) != NULL
	  && TYPE_CODE_FUNC == TYPE_CODE (POINTER_TARGET_TYPE (arg_type)))
@


1.11
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 2
   Copyright 1988, 1989, 1991, 1992, 1993, 1995, 1996, 1997, 1998,
   1999, 2000, 2001 Free Software Foundation, Inc.
@


1.10
log
@	* arm-tdep.c (check_prologue_cache): Fix off by 1 error.
	(save_prologue_cache): Ditto.
@
text
@d2 2
a3 2
   Copyright 1988, 1989, 1991, 1992, 1993, 1995, 1996, 1997, 1998, 1999, 2000
   Free Software Foundation, Inc.
d32 1
@


1.9
log
@Wed Sep  6 23:15:43 2000  Andrew Cagney  <cagney@@b1.cygnus.com>

        * remote-rdi.c (voiddummy): Update function signature to match
        struct Dbg_HostosInterface's reset method.
        * remote-rdp.c (rdp_step): Fix handle parameter to
        remote_rdp_insert_breakpoint and remote_rdp_remove_breakpoint.

        * arm-tdep.c (SIGCONTEXT_REGISTER_ADDRESS_P): Provide default
        definition.
        (arm_init_extra_frame_info): Use.
@
text
@d638 1
a638 1
      for (i = 0; i <= NUM_REGS; i++)
d659 1
a659 1
  for (i = 0; i <= NUM_REGS; i++)
@


1.8
log
@Add support for backtracing through signal handlers on Linux/ARM.  Also,
make prologue scanning code somewhat less naive about optimized code
on GNU/Linux/ARM.
@
text
@d54 7
a60 2
#ifndef SIGCONTEXT_REGISTER_ADDRESS
#define SIGCONTEXT_REGISTER_ADDRESS 0
d1048 1
a1048 1
  if (SIGCONTEXT_REGISTER_ADDRESS 
@


1.7
log
@Change signature of function add_set_enum_cmd() so that it uses
constant character pointers.  Update everything.
As a consequence fix infrun's follow-fork plugging a small memory leak.
@
text
@d33 25
d254 1
a254 1
arm_pc_is_thumb (bfd_vma memaddr)
d278 1
a278 1
arm_pc_is_thumb_dummy (bfd_vma memaddr)
d753 4
a756 3
      /* Assume the prologue is everything between the first instruction
         in the function and the first source line.  */
      struct symtab_and_line sal = find_pc_line (prologue_start, 0);
d758 31
a788 4
      if (sal.line == 0)	/* no line info, use current PC */
	prologue_end = fi->pc;
      else if (sal.end < prologue_end)	/* next line begins after fn end */
	prologue_end = sal.end;	/* (probably means no prologue)  */
d796 1
a796 4
      prologue_end = prologue_start + 64;	/* This is all the insn's
						   that could be in the prologue,
						   plus room for 5 insn's inserted
						   by the scheduler.  */
d886 4
d1030 34
@


1.6
log
@Fix signature of add_set_enum_cmd.  Change VAR parameter to char**.
Cleanup signature of add_set_cmd.  Change VAR parameter to void*.
@
text
@d55 1
a55 1
static char **valid_flavors;
d58 1
a58 1
static char *disassembly_flavor;
d2040 3
a2042 1
  const char *setname, *setdesc, **regnames;
d2064 1
a2064 1
      valid_flavors[i] = (char *) setname;
d2070 1
a2070 1
          disassembly_flavor = (char *) setname;
@


1.5
log
@        * arm-tdep.c (thumb_skip_prologue): Take function end addr argument
        so that we can stop searching for the prologue past the function end
        (arm_skip_prologue): Call thumb_skip_prologue with function end addr
@
text
@d2086 1
a2086 1
			      (char *) &disassembly_flavor,
@


1.4
log
@Include <ctype.h> for isupper().
@
text
@d331 1
a331 1
thumb_skip_prologue (CORE_ADDR pc)
d340 1
a340 1
  for (current_pc = pc; current_pc < pc + 40; current_pc += 2)
d402 1
a402 1
    return thumb_skip_prologue (pc);
@


1.3
log
@2000-02-17  Fernando Nasser  <fnasser@@totem.to.cygnus.com>

	* arm-tdep.c: Use header file instead of extern declarations for
	the {get,set}_arm_regname* functions.
@
text
@d31 1
@


1.2
log
@2000-02-16  Fernando Nasser  <fnasser@@totem.to.cygnus.com>

	* arm-tdep.c (set_disassembly_flavor, arm_othernames,
	_initialize_arm_tdep): Allows the user to choose between any of
	the flavors available for the disassembly to be used in the "info
	reg" command and elsewhere in gdb.  It prevents having to maintain
	this information in two places by using the data kept in the
	opcodes directory.
@
text
@d30 1
a32 10

/* From opcodes/arm-dis.c */

extern int get_arm_regname_num_options (void);

extern int set_arm_regname_option (int option);

extern int get_arm_regnames (int option, const char **setname,
			     const char **setdescription,
			     const char ***regnames);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 2
/* Target-dependent code for the Acorn Risc Machine, for GDB, the GNU Debugger.
   Copyright (C) 1988, 1989, 1991, 1992, 1993, 1995, 1996, 1998, 1999
d5 1
a5 1
This file is part of GDB.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d31 62
a92 10
/*
  The following macros are actually wrong.  Neither arm nor thumb can
  or should set the lsb on addr.
  The thumb addresses are mod 2, so (addr & 2) would be a good heuristic
  to use when checking for thumb (see arm_pc_is_thumb() below).
  Unfortunately, something else depends on these (incorrect) macros, so
  fixing them actually breaks gdb.  I didn't have time to investigate. Z.R.
*/
/* Thumb function addresses are odd (bit 0 is set).  Here are some
   macros to test, set, or clear bit 0 of addresses.  */
d97 22
a118 7
/* Macros to round N up or down to the next A boundary; A must be
   a power of two. */
#define ROUND_DOWN(n,a) 	((n) & ~((a) - 1))
#define ROUND_UP(n,a) 		(((n) + (a) - 1) & ~((a) - 1))
  
/* Should call_function allocate stack space for a struct return?  */
/* The system C compiler uses a similar structure return convention to gcc */
d120 1
a120 3
arm_use_struct_convention (gcc_p, type)
     int gcc_p;
     struct type *type;
d122 85
a206 1
  return (TYPE_LENGTH (type) > 4);
d210 1
a210 3
arm_frame_chain_valid (chain, thisframe)
     CORE_ADDR chain;
     struct frame_info *thisframe;
a211 1
#define LOWEST_PC 0x20  /* the first 0x20 bytes are the trap vectors. */
d219 5
a223 4
/* Flag set by arm_fix_call_dummy that tells whether the target function
   is a Thumb function.  This flag is checked by arm_push_arguments.
   FIXME: Change the PUSH_ARGUMENTS macro (and its use in valops.c) to
   pass the function address as an additional parameter.  */
d227 3
a229 3
/* Flag set by arm_fix_call_dummy that tells whether the calling function
   is a Thumb function.  This flag is checked by arm_pc_is_thumb
   and arm_call_dummy_breakpoint_offset.  */
d233 2
a234 1
/* Tell if the program counter value in MEMADDR is in a Thumb function.  */
d237 1
a237 2
arm_pc_is_thumb (memaddr)
     bfd_vma memaddr;
d239 1
a239 2
  struct minimal_symbol * sym;
  CORE_ADDR sp;
d241 1
a241 1
  /* If bit 0 of the address is set, assume this is a Thumb address. */
d245 1
a245 1
  /* Thumb function have a "special" bit set in minimal symbols */
d249 1
a249 1
      return (MSYMBOL_IS_SPECIAL(sym));
d252 3
a254 1
    return 0;
d257 2
a258 2
/* Tell if the program counter value in MEMADDR is in a call dummy that
   is being called from a Thumb function.  */
d261 1
a261 2
arm_pc_is_thumb_dummy (memaddr)
     bfd_vma memaddr;
d263 1
a263 1
  CORE_ADDR sp = read_sp();
d265 8
a272 1
  if (PC_IN_CALL_DUMMY (memaddr, sp, sp+64))
d279 1
a279 2
arm_addr_bits_remove (val)
     CORE_ADDR val;
d288 1
a288 2
arm_saved_pc_after_call (frame)
     struct frame_info *frame;
d293 17
d311 3
a313 3
        push    {r7, lr}
        add     sp, sp, #-28
        add     r7, sp, #12
d315 22
a336 2
        mov     r7, sp 
*/
d339 1
a339 2
thumb_skip_prologue (pc)
     CORE_ADDR pc;
d342 5
d348 1
a348 1
  for (current_pc = pc; current_pc < pc + 20; current_pc += 2)
d352 22
a373 6
      if (   (insn & 0xfe00) != 0xb400		/* push {..., r7, lr} */
	  && (insn & 0xff00) != 0xb000		/* add sp, #simm */
	  && (insn & 0xff00) != 0xaf00		/* add r7, sp, #imm */
	  && insn != 0x466f			/* mov r7, sp */
	  && (insn & 0xffc0) != 0x4640)		/* mov r0-r7, r8-r15 */
	break;
d379 2
a380 1
/* APCS (ARM procedure call standard) defines the following prologue:
d382 8
a389 9
   mov		ip, sp
  [stmfd	sp!, {a1,a2,a3,a4}]
   stmfd	sp!, {...,fp,ip,lr,pc}
  [stfe		f7, [sp, #-12]!]
  [stfe		f6, [sp, #-12]!]
  [stfe		f5, [sp, #-12]!]
  [stfe		f4, [sp, #-12]!]
   sub		fp, ip, #nn	// nn == 20 or 4 depending on second ins
*/
d392 1
a392 2
arm_skip_prologue (pc)
     CORE_ADDR pc;
d399 3
a401 2
  /* See what the symbol table says. */
  if (find_pc_partial_function (pc, NULL, & func_addr, & func_end))
d404 1
a404 1
      if (sal.line != 0 && sal.end < func_end)
d416 1
a416 1
  if (inst != 0xe1a0c00d)  /* mov ip, sp */
d421 1
a421 1
  if ((inst & 0xfffffff0) == 0xe92d0000)  /* stmfd sp!,{a1,a2,a3,a4}  */
d427 1
a427 1
  if ((inst & 0xfffff800) != 0xe92dd800)  /* stmfd sp!,{...,fp,ip,lr,pc} */
d434 2
a435 2
     for better instruction scheduling, so we skip them only if
     we find them, but still consdier the function to be frame-ful  */
d437 4
a440 3
  /* We may have either one sfmfd instruction here, or several stfe insns,
     depending on the version of floating point code we support.  */
  if ((inst & 0xffbf0fff) == 0xec2d0200)  /* sfmfd fn, <cnt>, [sp]! */
d447 5
a451 5
      while ((inst & 0xffff8fff) == 0xed6d0103) /* stfe fn, [sp, #-12]! */
        {
          skip_pc += 4;
          inst = read_memory_integer (skip_pc, 4);
        }
d454 1
a454 1
  if ((inst & 0xfffff000) == 0xe24cb000) /* sub fp, ip, #nn */
d459 1
a459 3



d468 2
a469 5
   A typical Thumb function prologue might look like this:
	push {r7, lr}
	sub  sp, #28,
	add  r7, sp, #12
   Which would create this stack frame (offsets relative to FP)
d476 6
a481 2
   12 bytes.  The frame register is R7.  */
	
d483 1
a483 2
thumb_scan_prologue (fi)
     struct frame_info * fi;
d488 7
a494 2
  int       saved_reg[16];	/* which register has been copied to register n? */
  int       i;
d496 1
a496 1
  if (find_pc_partial_function (fi->pc, NULL, & prologue_start, & prologue_end))
d500 1
a500 1
      if (sal.line == 0)		/* no line info, use current PC */
d503 1
a503 1
	prologue_end = sal.end;		/* (probably means no prologue)  */
d506 2
a507 2
    prologue_end = prologue_start + 40; /* We're in the boondocks: allow for */
					/* 16 pushes, an add, and "mv fp,sp" */
d517 2
a518 1
     frame pointer, adjust the stack pointer, and save registers.  */
d521 3
a523 1
  for (current_pc = prologue_start; current_pc < prologue_end; current_pc += 2)
d531 1
a531 1
      if ((insn & 0xfe00) == 0xb400)		/* push { rlist } */
d533 2
d537 1
a537 1
	  int mask = (insn & 0xff) | ((insn & 0x100) << 6);
d542 1
a542 1
 	      {
d548 1
a548 1
      else if ((insn & 0xff00) == 0xb000)	/* add sp, #simm */
d550 11
a560 3
	  offset = (insn & 0x7f) << 2;		/* get scaled offset */
	  if (insn & 0x80)			/* is it signed? */
	     offset = -offset;
d565 1
d567 1
a567 1
	  fi->frameoffset = (insn & 0xff) << 2;	/* get scaled offset */
d571 1
d578 1
a578 1
	  int lo_reg = insn & 7;		/* dest. register (r0-r7) */
d580 1
a580 1
	  saved_reg[lo_reg] = hi_reg;		/* remember hi reg was saved */
d583 2
a584 1
	break;				/* anything else isn't prologue */
d588 2
a589 3
/* Function: check_prologue_cache
   Check if prologue for this frame's PC has already been scanned.
   If it has, copy the relevant information about that prologue and
d593 10
a602 11
     * the frame register number;
     * the size of the stack frame;
     * the offsets of saved regs (relative to the old SP); and
     * the offset from the stack pointer to the frame pointer

   The cache contains only one entry, since this is adequate
   for the typical sequence of prologue scan requests we get.
   When performing a backtrace, GDB will usually ask to scan
   the same function twice in a row (once to get the frame chain,
   and once to fill in the extra frame information).
*/
d607 1
a607 2
check_prologue_cache (fi)
     struct frame_info * fi;
d625 1
a625 3
/* Function: save_prologue_cache
   Copy the prologue information from fi to the prologue cache.
*/
d628 1
a628 2
save_prologue_cache (fi)
     struct frame_info * fi;
d632 3
a634 3
  prologue_cache.pc          = fi->pc;
  prologue_cache.framereg    = fi->framereg;
  prologue_cache.framesize   = fi->framesize;
d636 1
a636 1
  
d642 5
a646 6
/* Function: arm_scan_prologue
   This function decodes an ARM function prologue to determine:
     1) the size of the stack frame
     2) which registers are saved on it
     3) the offsets of saved regs
     4) the offset from the stack pointer to the frame pointer
d649 8
a656 5
   A typical Arm function prologue might look like this:
	mov    ip, sp
	stmfd  sp!, {fp, ip, lr, pc}
	sub    fp, ip, #4
	sub    sp, sp, #16
d658 7
a664 6
     IP ->   4	(caller's stack)
     FP ->   0	PC (points to address of stmfd instruction + 12 in callee)
	    -4	LR (return address in caller)
	    -8	IP (copy of caller's SP)
     	   -12	FP (caller's FP)
     SP -> -28	Local variables
d666 42
a707 1
   28 bytes.  */
d710 1
a710 2
arm_scan_prologue (fi)
     struct frame_info * fi;
d720 2
a721 2
  fi->framereg    = SP_REGNUM;
  fi->framesize   = 0;
d740 1
a740 1
      if (sal.line == 0)		/* no line info, use current PC */
d743 1
a743 1
	prologue_end = sal.end;		/* (probably means no prologue)  */
d748 7
a754 3
         PC is the address of the stmfd + 12.  */
      prologue_start = (read_memory_integer (fi->frame, 4) & 0x03fffffc) - 12;
      prologue_end = prologue_start + 40; /* FIXME: should be big enough */
d758 11
a768 1
     frame pointer, adjust the stack pointer, and save registers.  */
d771 3
a773 1
  for (current_pc = prologue_start; current_pc < prologue_end; current_pc += 4)
d775 45
a819 1
      unsigned int insn = read_memory_unsigned_integer (current_pc, 4);
d821 14
a834 3
      if ((insn & 0xffff0000) == 0xe92d0000)	/* stmfd sp!, {..., r7, lr} */
	{
	  int mask = insn & 0xffff;
d836 12
a847 7
	  /* Calculate offsets of saved registers. */
	  for (regno = PC_REGNUM; regno >= 0; regno--)
	    if (mask & (1 << regno))
	      {
		sp_offset -= 4;
		fi->fsr.regs[regno] = sp_offset;
	      }
a848 25
      else if ((insn & 0xfffff000) == 0xe24cb000)	/* sub fp, ip #n */
	{
	  unsigned imm = insn & 0xff;			/* immediate value */
	  unsigned rot = (insn & 0xf00) >> 7;		/* rotate amount */
	  imm = (imm >> rot) | (imm << (32-rot));
	  fp_offset = -imm;
	  fi->framereg = FP_REGNUM;
	}
      else if ((insn & 0xfffff000) == 0xe24dd000)	/* sub sp, sp #n */
	{
	  unsigned imm = insn & 0xff;			/* immediate value */
	  unsigned rot = (insn & 0xf00) >> 7;		/* rotate amount */
	  imm = (imm >> rot) | (imm << (32-rot));
	  sp_offset -= imm;
	}
      else if ((insn & 0xffff7fff) == 0xed6d0103) /* stfe f?, [sp, -#c]! */
	{
	  sp_offset -= 12;
	  regno = F0_REGNUM + ((insn >> 12) & 0x07);
	  fi->fsr.regs[regno] = sp_offset;
	}
      else if (insn == 0xe1a0c00d)			/* mov ip, sp */
	continue;
      else
	break;	/* not a recognized prologue instruction */
d856 1
a856 1
  
d860 6
a865 7

/* Function: find_callers_reg
   Find REGNUM on the stack.  Otherwise, it's in an active register.  One thing
   we might want to do here is to check REGNUM against the clobber mask, and
   somehow flag it as invalid if it isn't saved on the stack somewhere.  This
   would provide a graceful failure mode when trying to get the value of
   caller-saves registers for an inner frame.  */
d868 1
a868 3
arm_find_callers_reg (fi, regnum)
     struct frame_info * fi;
     int regnum;
d871 2
a872 2
    
#if 0	/* FIXME: enable this code if we convert to new call dummy scheme.  */
d877 3
a879 3
      if (fi->fsr.regs[regnum] != 0)
	return read_memory_integer (fi->fsr.regs[regnum], 
				  REGISTER_RAW_SIZE(regnum));
d882 1
a882 2


d898 1
d901 1
a901 2
arm_frame_chain (fi)
     struct frame_info * fi;
d903 1
a903 1
#if 0	/* FIXME: enable this code if we convert to new call dummy scheme.  */
d908 1
a908 1
    return fi->frame;	/* dummy frame same as caller's frame */
d911 1
a911 1
  callers_pc = FRAME_SAVED_PC(fi);  /* find out who called us: */
d913 2
a914 2
  if (PC_IN_CALL_DUMMY (callers_pc, fp, fp))	
    return fp;		/* dummy frame's frame may bear no relation to ours */
d918 1
a918 1
      return 0;		/* in _start fn, don't chain further */
d939 1
a939 1
      memset (& caller_fi, 0, sizeof (caller_fi));
d941 1
a941 1
      arm_scan_prologue (& caller_fi);
d953 8
a960 6
/* Function: init_extra_frame_info
   This function actually figures out the frame address for a given pc and
   sp.  This is tricky  because we sometimes don't use an explicit
   frame pointer, and the previous stack pointer isn't necessarily recorded
   on the stack.  The only reliable way to get this info is to
   examine the prologue.  */
d963 1
a963 2
arm_init_extra_frame_info (fi)
     struct frame_info * fi;
d972 1
a972 1
#if 0	/* FIXME: enable this code if we convert to new call dummy scheme.  */
d976 3
a978 3
	 by assuming it's always FP.  */
      fi->frame       = generic_read_register_dummy (fi->pc, fi->frame, SP_REGNUM);
      fi->framesize   = 0;
d982 1
a982 1
  else 
d987 2
a988 1
      if (!fi->next)			/* this is the innermost frame? */
d990 4
a993 3
      else			 	/* not the innermost frame */
	/* If we have an FP,  the callee saved it. */
	if (fi->framereg == FP_REGNUM || fi->framereg == THUMB_FP_REGNUM)
d995 7
a1001 2
	    fi->frame = read_memory_integer (fi->next->fsr.regs[fi->framereg],
					     4);
d1003 2
a1004 2
      /* Calculate actual addresses of saved registers using offsets determined
         by arm_scan_prologue.  */
d1012 3
a1014 3
/* Function: frame_saved_pc
   Find the caller of this frame.  We do this by seeing if LR_REGNUM is saved
   in the stack anywhere, otherwise we get it from the registers.
d1017 2
a1018 3
     #define FRAME_SAVED_PC(FRAME) \
	ADDR_BITS_REMOVE (read_memory_integer ((FRAME)->frame - 4, 4))
*/
d1021 1
a1021 2
arm_frame_saved_pc (fi)
     struct frame_info * fi;
d1023 1
a1023 1
#if 0	/* FIXME: enable this code if we convert to new call dummy scheme.  */
a1033 1

d1038 1
a1038 1
arm_target_read_fp ()
d1043 1
a1043 1
    return read_register (FP_REGNUM);		/* R11 if ARM */
d1046 1
a1047 1
/* Calculate the frame offsets of the saved registers (ARM version). */
d1049 2
a1050 3
arm_frame_find_saved_regs (fi, regaddr)
     struct frame_info *fi;
     struct frame_saved_regs *regaddr;
a1054 1

d1056 1
a1056 1
arm_push_dummy_frame ()
d1070 2
a1071 2
  /* push a pointer to the dummy prologue + 12, because when
     stm instruction stores the PC, it stores the address of the stm
d1074 1
a1074 1
  sp = push_word (sp, read_register (PC_REGNUM)); /* FIXME: was PS_REGNUM */
d1077 2
a1078 2
  
  for (regnum = 10; regnum >= 0; regnum --)
d1080 1
a1080 1
  
d1087 2
a1088 2
   in Thumb or ARM mode, and whether the target function is Thumb
   or ARM.  There are three different situations requiring three
d1092 1
a1092 1
     been copied into the dummy parameter to this function.
d1094 1
a1094 1
     "mov pc,r4" instruction patched to be a "bx r4" instead.
d1096 1
a1096 1
     works for calling both ARM and Thumb functions.
d1098 2
a1099 3
   All three call dummies expect to receive the target function address
   in R4, with the low bit set if it's a Thumb function.
*/
d1102 2
a1103 8
arm_fix_call_dummy (dummy, pc, fun, nargs, args, type, gcc_p)
     char *        dummy;
     CORE_ADDR     pc;
     CORE_ADDR     fun;
     int           nargs;
     value_ptr *   args;
     struct type * type;
     int           gcc_p;
d1107 3
a1109 3
    0xf000, 0xf801,	/*	  bl      label */
    0xdf18,		/*	  swi     24 */
    0x4720,		/* label: bx	  r4 */
d1114 1
a1114 1
  caller_is_thumb = arm_pc_is_thumb (read_pc());
d1116 4
a1119 3
  /* If the target function is Thumb, set the low bit of the function address.
     And if the CPU is currently in ARM mode, patch the second instruction
     of call dummy to use a BX instruction to switch to Thumb mode.  */
d1144 2
a1145 1
  /* Put the target address in r4; the call dummy will copy this to the PC. */
a1148 1

d1150 2
a1151 2
   to have a breakpoint placed on it.  This is the offset of the 'swi 24'
   instruction, which is no longer actually used, but simply acts
d1154 1
a1154 2
   This implements the CALL_DUMMY_BREAK_OFFSET macro.
*/
d1157 1
a1157 1
arm_call_dummy_breakpoint_offset ()
d1165 5
d1172 16
a1187 13
arm_push_arguments(nargs, args, sp, struct_return, struct_addr)
     int         nargs;
     value_ptr * args;
     CORE_ADDR   sp;
     int         struct_return;
     CORE_ADDR   struct_addr;
{
  int argreg;
  int float_argreg;
  int argnum;
  int stack_offset;
  struct stack_arg {
      char *val;
d1189 12
a1200 5
      int offset;
    };
  struct stack_arg *stack_args =
      (struct stack_arg*)alloca (nargs * sizeof (struct stack_arg));
  int nstack_args = 0;
d1202 8
d1211 1
a1211 1
  /* Initialize the integer and float register pointers.  */
a1212 1
  float_argreg = F0_REGNUM;
d1214 2
a1215 1
  /* the struct_return pointer occupies the first parameter-passing reg */
d1217 1
a1217 1
      write_register (argreg++, struct_addr);
d1219 49
a1267 21
  /* The offset onto the stack at which we will start copying parameters
     (after the registers are used up) begins at 16 in the old ABI.
     This leaves room for the "home" area for register parameters.  */
  stack_offset = REGISTER_SIZE * 4;

  /* Process args from left to right.  Store as many as allowed in
	registers, save the rest to be pushed on the stack */
  for(argnum = 0; argnum < nargs; argnum++)
    {
      char *         val;
      value_ptr      arg = args[argnum];
      struct type *  arg_type = check_typedef (VALUE_TYPE (arg));
      struct type *  target_type = TYPE_TARGET_TYPE (arg_type);
      int            len = TYPE_LENGTH (arg_type);
      enum type_code typecode = TYPE_CODE (arg_type);
      CORE_ADDR      regval;
      int newarg;

      val = (char *) VALUE_CONTENTS (arg);

      /* If the argument is a pointer to a function, and it's a Thumb
d1269 3
a1271 3
      if (typecode == TYPE_CODE_PTR
	  && target_type != NULL
	  && TYPE_CODE (target_type) == TYPE_CODE_FUNC)
d1273 1
a1273 1
	  regval = extract_address (val, len);
a1276 15

#define MAPCS_FLOAT 0	/* --mapcs-float not implemented by the compiler yet */
#if MAPCS_FLOAT
      /* Up to four floating point arguments can be passed in floating
         point registers on ARM (not on Thumb).  */
      if (typecode == TYPE_CODE_FLT
	  && float_argreg <= ARM_LAST_FP_ARG_REGNUM
	  && !target_is_thumb)
	{
	  /* This is a floating point value that fits entirely
	     in a single register.  */
	  regval = extract_address (val, len);
	  write_register (float_argreg++, regval);
	}
      else
d1278 4
d1283 3
a1285 4
	  /* Copy the argument to general registers or the stack in
	     register-sized pieces.  Large arguments are split between
	     registers and stack.  */
	  while (len > 0)
d1287 10
a1296 4
	      if (argreg <= ARM_LAST_ARG_REGNUM)
		{
	          int partial_len = len < REGISTER_SIZE ? len : REGISTER_SIZE;
		  regval = extract_address (val, partial_len);
d1298 2
a1299 15
		  /* It's a simple argument being passed in a general
		     register.  */
		  write_register (argreg, regval);
		  argreg++;
	          len -= partial_len;
	          val += partial_len;
		}
	      else
		{
		  /* keep for later pushing */
		  stack_args[nstack_args].val = val;
		  stack_args[nstack_args++].len = len;
		  break;
		}
	    }
a1301 7
    /* now do the real stack pushing, process args right to left */
    while(nstack_args--)
      {
	sp -= stack_args[nstack_args].len;
	write_memory(sp, stack_args[nstack_args].val,
		stack_args[nstack_args].len);
      }
d1308 1
a1308 1
arm_pop_frame ()
a1309 1
  struct frame_info *frame = get_current_frame();
d1311 5
d1317 4
a1320 3
  for (regnum = 0; regnum < NUM_REGS; regnum++)
    if (frame->fsr.regs[regnum] != 0)
      write_register (regnum, 
d1323 23
a1345 2
  write_register (PC_REGNUM, FRAME_SAVED_PC (frame));
  write_register (SP_REGNUM, read_register (frame->framereg));
d1351 1
a1351 2
print_fpu_flags (flags)
     int flags;
d1353 11
a1363 6
    if (flags & (1 << 0)) fputs ("IVO ", stdout);
    if (flags & (1 << 1)) fputs ("DVZ ", stdout);
    if (flags & (1 << 2)) fputs ("OFL ", stdout);
    if (flags & (1 << 3)) fputs ("UFL ", stdout);
    if (flags & (1 << 4)) fputs ("INX ", stdout);
    putchar ('\n');
d1367 1
a1367 1
arm_float_info ()
d1369 2
a1370 2
    register unsigned long status = read_register (FPS_REGNUM);
    int type;
d1372 40
a1411 30
    type = (status >> 24) & 127;
    printf ("%s FPU type %d\n",
	    (status & (1<<31)) ? "Hardware" : "Software",
	    type);
    fputs ("mask: ", stdout);
    print_fpu_flags (status >> 16);
    fputs ("flags: ", stdout);
    print_fpu_flags (status);
}

static char *original_register_names[] =
{ "a1", "a2", "a3", "a4", /*  0  1  2  3 */
  "v1", "v2", "v3", "v4", /*  4  5  6  7 */
  "v5", "v6", "sl", "fp", /*  8  9 10 11 */
  "ip", "sp", "lr", "pc", /* 12 13 14 15 */
  "f0", "f1", "f2", "f3", /* 16 17 18 19 */
  "f4", "f5", "f6", "f7", /* 20 21 22 23 */
  "fps","ps" }            /* 24 25       */;

/* These names are the ones which gcc emits, and 
   I find them less confusing.  Toggle between them
   using the `othernames' command. */
static char *additional_register_names[] =
{ "r0", "r1", "r2", "r3", /*  0  1  2  3 */
  "r4", "r5", "r6", "r7", /*  4  5  6  7 */
  "r8", "r9", "sl", "fp", /*  8  9 10 11 */
  "ip", "sp", "lr", "pc", /* 12 13 14 15 */
  "f0", "f1", "f2", "f3", /* 16 17 18 19 */
  "f4", "f5", "f6", "f7", /* 20 21 22 23 */
  "fps","ps" }            /* 24 25       */;
d1413 6
a1418 1
char **arm_register_names = original_register_names;
d1420 2
d1423 2
a1424 2
static void
arm_othernames ()
d1426 1
a1426 5
  static int toggle;
  arm_register_names = (toggle
			? additional_register_names
			: original_register_names);
  toggle = !toggle;
d1429 2
a1430 2
/* FIXME:  Fill in with the 'right thing', see asm 
   template in arm-convert.s */
d1432 3
a1434 4
void 
convert_from_extended (ptr, dbl)
     void * ptr;
     double * dbl;
d1436 4
a1439 1
  *dbl = *(double*)ptr;
d1442 6
a1447 4
void 
convert_to_extended (dbl, ptr)
     void * ptr;
     double * dbl;
d1449 3
a1451 1
  *(double*)ptr = *dbl;
d1455 1
a1455 3
condition_true (cond, status_reg)
     unsigned long cond;
     unsigned long status_reg;
d1506 2
a1507 5
shifted_reg_val (inst, carry, pc_val, status_reg)
     unsigned long inst;
     int carry;
     unsigned long pc_val;
     unsigned long status_reg;
d1512 2
a1513 2
 
  if (bit(inst, 4))
d1520 2
a1521 2
 
  res = (rm == 15 
d1523 1
a1523 1
	    + (bit (inst, 4) ? 12 : 8)) 
d1528 1
a1528 1
    case 0: /* LSL */
d1531 2
a1532 2
      
    case 1: /* LSR */
d1536 3
a1538 2
    case 2: /* ASR */
      if (shift >= 32) shift = 31;
d1543 1
a1543 1
    case 3: /* ROR/RRX */
d1548 1
a1548 1
	res = (res >> shift) | (res << (32-shift));
a1554 1

d1558 1
a1558 2
bitcount (val)
     unsigned long val;
d1562 1
a1562 1
    val &= val - 1;	/* delete rightmost 1-bit in val */
a1565 1

d1567 1
a1567 2
thumb_get_next_pc (pc)
     CORE_ADDR pc;
d1569 1
a1569 1
  unsigned long pc_val = ((unsigned long)pc) + 4;	/* PC after prefetch */
d1571 1
a1571 1
  CORE_ADDR nextpc = pc + 2;		/* default is next instruction */
d1590 1
a1590 1
      unsigned long cond = bits (inst1, 8, 11); 
d1601 1
a1601 1
      offset = (sbits (inst1, 0, 10) << 12) + (bits  (inst2, 0, 10) << 1);
a1607 1

d1609 1
a1609 2
arm_get_next_pc (pc)
     CORE_ADDR pc;
d1622 1
a1622 1
  nextpc = (CORE_ADDR) (pc_val + 4);  /* Default case */
d1628 4
a1631 2
	case 0x0: case 0x1: /* data processing */
	case 0x2: case 0x3:
d1636 1
a1636 1
 
d1641 1
a1641 1
		&& bits (this_instr, 4, 7) == 9)  /* multiply */
d1648 1
a1648 1
 
d1653 2
a1654 2
		operand2 = ((immval >> rotate) | (immval << (32-rotate)))
			   & 0xffffffff;
d1656 1
a1656 1
	    else  /* operand 2 is a shifted register */
d1658 1
a1658 1
 
d1661 1
a1661 1
	      case 0x0: /*and*/
d1665 1
a1665 1
	      case 0x1: /*eor*/
d1669 1
a1669 1
	      case 0x2: /*sub*/
d1673 1
a1673 1
	      case 0x3: /*rsb*/
d1677 1
a1677 1
	      case 0x4:  /*add*/
d1681 1
a1681 1
	      case 0x5: /*adc*/
d1685 1
a1685 1
	      case 0x6: /*sbc*/
d1689 1
a1689 1
	      case 0x7: /*rsc*/
d1693 4
a1696 1
	      case 0x8: case 0x9: case 0xa: case 0xb: /* tst, teq, cmp, cmn */
d1700 1
a1700 1
	      case 0xc: /*orr*/
d1704 1
a1704 1
	      case 0xd: /*mov*/
d1707 1
a1707 1
                break;
d1709 1
a1709 1
	      case 0xe: /*bic*/
d1713 1
a1713 1
	      case 0xf: /*mvn*/
d1723 5
a1727 3
 
	case 0x4: case 0x5: /* data transfer */
	case 0x6: case 0x7:
d1734 1
a1734 1
		  unsigned long  rn;
d1736 1
a1736 1
 
d1748 3
a1750 3
			(bit (this_instr, 25)
			 ? shifted_reg_val (this_instr, c, pc_val)
			 : bits (this_instr, 0, 11));
d1757 1
a1757 1
		  nextpc = (CORE_ADDR) read_memory_integer ((CORE_ADDR) base, 
d1759 1
a1759 1
 
d1767 3
a1769 2
 
	case 0x8: case 0x9: /* block transfer */
d1783 1
a1783 1
		      if (bit (this_instr, 24)) /* pre */
d1788 1
a1788 1
 
d1790 2
a1791 2
		    unsigned long rn_val = 
		      read_register (bits (this_instr, 16, 19));
d1794 1
a1794 1
								    + offset),
d1803 3
a1805 3
 
	case 0xb:           /* branch & link */
	case 0xa:           /* branch */
d1814 5
a1818 4
 
	case 0xc: case 0xd:
	case 0xe:           /* coproc ops */
	case 0xf:           /* SWI */
d1834 1
a1834 3
gdb_print_insn_arm (memaddr, info)
     bfd_vma memaddr;
     disassemble_info * info;
d1838 5
a1842 5
      static asymbol *                  asym;
      static combined_entry_type        ce;
      static struct coff_symbol_struct  csym;
      static struct _bfd                fake_bfd;
      static bfd_target                 fake_target;
d1850 3
a1852 3
	     
	  fake_target.flavour  = bfd_target_coff_flavour;
	  fake_bfd.xvec        = & fake_target;
d1854 4
a1857 4
	  csym.native          = & ce;
	  csym.symbol.the_bfd  = & fake_bfd;
	  csym.symbol.name     = "fake";
	  asym                 = (asymbol *) & csym;
d1859 1
a1859 1
      
d1861 1
a1861 1
      info->symbols = & asym;
d1865 1
a1865 1
  
d1872 6
a1877 16
/* Sequence of bytes for breakpoint instruction.  */
#define ARM_LE_BREAKPOINT {0xFE,0xDE,0xFF,0xE7} /* Recognized illegal opcodes */
#define ARM_BE_BREAKPOINT {0xE7,0xFF,0xDE,0xFE} 
#define THUMB_LE_BREAKPOINT {0xfe,0xdf}       
#define THUMB_BE_BREAKPOINT {0xdf,0xfe}       

/* The following has been superseded by BREAKPOINT_FOR_PC, but
   is defined merely to keep mem-break.c happy.  */
#define LITTLE_BREAKPOINT ARM_LE_BREAKPOINT
#define BIG_BREAKPOINT    ARM_BE_BREAKPOINT

/* This function implements the BREAKPOINT_FROM_PC macro.  It uses the program
   counter value to determine whether a 16- or 32-bit breakpoint should be
   used.  It returns a pointer to a string of bytes that encode a breakpoint
   instruction, stores the length of the string to *lenptr, and adjusts pc
   (if necessary) to point to the actual memory location where the
d1881 1
a1881 3
arm_breakpoint_from_pc (pcptr, lenptr)
     CORE_ADDR * pcptr;
     int * lenptr;
d1886 6
a1891 6
        {
          static char thumb_breakpoint[] = THUMB_BE_BREAKPOINT;
          *pcptr = UNMAKE_THUMB_ADDR (*pcptr);
          *lenptr = sizeof (thumb_breakpoint);
          return thumb_breakpoint;
         }
d1893 6
a1898 6
        {
          static char thumb_breakpoint[] = THUMB_LE_BREAKPOINT;
          *pcptr = UNMAKE_THUMB_ADDR (*pcptr);
          *lenptr = sizeof (thumb_breakpoint);
          return thumb_breakpoint;
        }
d1903 5
a1907 5
        {
          static char arm_breakpoint[] = ARM_BE_BREAKPOINT;
          *lenptr = sizeof (arm_breakpoint);
          return arm_breakpoint;
        }
d1909 5
a1913 5
        {
          static char arm_breakpoint[] = ARM_LE_BREAKPOINT;
          *lenptr = sizeof (arm_breakpoint);
          return arm_breakpoint;
        }
d1916 17
a1932 2
/* Return non-zero if the PC is inside a call thunk (aka stub or trampoline).
   This implements the IN_SOLIB_CALL_TRAMPOLINE macro.  */
d1935 1
a1935 3
arm_in_call_stub (pc, name)
     CORE_ADDR pc;
     char * name;
d1939 2
a1940 2
  /* Find the starting address of the function containing the PC.  If the
     caller didn't give us a name, look it up at the same time.  */
d1947 4
a1950 5

/* If PC is in a Thumb call or return stub, return the address of the target
   PC, which is in a register.  The thunk functions are called _called_via_xx,
   where x is the register name.  The possible names are r0-r9, sl, fp, ip,
   sp, and lr. */
d1953 1
a1953 2
arm_skip_stub (pc)
     CORE_ADDR pc;
d1955 1
a1955 1
  char * name;
d1965 6
a1970 6
      /* Use the name suffix to determine which register contains
         the target PC.  */
      static char *table[15] = 
	{ "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
	  "r8", "r9", "sl", "fp", "ip", "sp", "lr"
	};
d1977 2
a1978 1
  return 0;	/* not a stub */
d1981 60
d2043 1
a2043 1
_initialize_arm_tdep ()
d2045 7
d2054 45
a2098 2
  add_com ("othernames", class_obscure, arm_othernames,
	   "Switch to the other set of register names.");
d2102 1
a2102 1
				  var_zinteger, (char *)&arm_apcs_32,
d2104 3
a2106 1
		     & showlist);
d2108 2
d2112 3
a2114 1
/* Test whether the coff symbol specific value corresponds to a Thumb function */
d2116 1
a2116 1
coff_sym_is_thumb(int val)
d2118 5
a2122 5
	return (val == C_THUMBEXT ||
      val == C_THUMBSTAT ||
      val == C_THUMBEXTFUNC ||
      val == C_THUMBSTATFUNC ||
      val == C_THUMBLABEL);
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d1 2
a2 2
/* Target-dependent code for the Acorn Risc Machine (ARM).
   Copyright (C) 1988, 1989, 1991, 1992, 1993, 1995-1999
d482 1
a482 1
      prologue_start = ADDR_BITS_REMOVE(read_memory_integer (fi->frame, 4)) - 12;
a976 1
  CORE_ADDR old_SP;
a977 1
  old_SP = read_register (frame->framereg);
d984 1
a984 1
  write_register (SP_REGNUM, old_SP);
@


1.1.1.3
log
@import gdb-1999-05-25 snapshot
@
text
@a139 13
int
arm_frameless_function_invocation (fi)
     struct frame_info *fi;
{
  int frameless;
  CORE_ADDR func_start, after_prologue;
  func_start = (get_pc_function_start ((fi)->pc) + FUNCTION_START_OFFSET);
  after_prologue = func_start;
  SKIP_PROLOGUE (after_prologue);
  frameless = (after_prologue == func_start);
  return frameless;
}

@


1.1.1.4
log
@import gdb-1999-06-28 snapshot
@
text
@d48 1
a48 26

static char *APCS_register_names[] =
{ "a1", "a2", "a3", "a4", /*  0  1  2  3 */
  "v1", "v2", "v3", "v4", /*  4  5  6  7 */
  "v5", "v6", "sl", "fp", /*  8  9 10 11 */
  "ip", "sp", "lr", "pc", /* 12 13 14 15 */
  "f0", "f1", "f2", "f3", /* 16 17 18 19 */
  "f4", "f5", "f6", "f7", /* 20 21 22 23 */
  "fps","ps" }            /* 24 25       */;

/* These names are the ones which gcc emits, and 
   I find them less confusing.  Toggle between them
   using the `othernames' command. */
static char *additional_register_names[] =
{ "r0", "r1", "r2", "r3", /*  0  1  2  3 */
  "r4", "r5", "r6", "r7",    /*  4  5  6  7 */
  "r8", "r9", "r10", "r11",  /*  8  9 10 11 */
  "r12", "r13", "r14", "pc", /* 12 13 14 15 */
  "f0", "f1", "f2", "f3",    /* 16 17 18 19 */
  "f4", "f5", "f6", "f7",    /* 20 21 22 23 */
  "fps","ps" }               /* 24 25       */;

/* By default use the APCS registers names */

char **arm_register_names = APCS_register_names;

d1032 24
d1059 5
a1063 9

  if (arm_register_names ==  APCS_register_names) { 
    arm_register_names =  additional_register_names;
    arm_toggle_regnames ();
  } else {
    arm_register_names =  APCS_register_names;
    arm_toggle_regnames ();
  }    
    
a1618 2
  int regname_is_APCS = (arm_register_names ==  APCS_register_names);

a1619 2
  
  /* Sync the opcode insn printer with our register viewer: */
a1620 3
  if (arm_toggle_regnames () != regname_is_APCS)
    arm_toggle_regnames ();
     
@


1.1.1.5
log
@import gdb-1999-07-07 post reformat
@
text
@d5 1
a5 1
   This file is part of GDB.
d7 13
a19 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d31 7
a37 7
   The following macros are actually wrong.  Neither arm nor thumb can
   or should set the lsb on addr.
   The thumb addresses are mod 2, so (addr & 2) would be a good heuristic
   to use when checking for thumb (see arm_pc_is_thumb() below).
   Unfortunately, something else depends on these (incorrect) macros, so
   fixing them actually breaks gdb.  I didn't have time to investigate. Z.R.
 */
d50 7
a56 7
{"a1", "a2", "a3", "a4",	/*  0  1  2  3 */
 "v1", "v2", "v3", "v4",	/*  4  5  6  7 */
 "v5", "v6", "sl", "fp",	/*  8  9 10 11 */
 "ip", "sp", "lr", "pc",	/* 12 13 14 15 */
 "f0", "f1", "f2", "f3",	/* 16 17 18 19 */
 "f4", "f5", "f6", "f7",	/* 20 21 22 23 */
 "fps", "ps"} /* 24 25       */ ;
d62 7
a68 7
{"r0", "r1", "r2", "r3",	/*  0  1  2  3 */
 "r4", "r5", "r6", "r7",	/*  4  5  6  7 */
 "r8", "r9", "r10", "r11",	/*  8  9 10 11 */
 "r12", "r13", "r14", "pc",	/* 12 13 14 15 */
 "f0", "f1", "f2", "f3",	/* 16 17 18 19 */
 "f4", "f5", "f6", "f7",	/* 20 21 22 23 */
 "fps", "ps"} /* 24 25       */ ;
d89 1
a89 1
#define LOWEST_PC 0x20		/* the first 0x20 bytes are the trap vectors. */
d116 1
a116 1
  struct minimal_symbol *sym;
d127 1
a127 1
      return (MSYMBOL_IS_SPECIAL (sym));
d140 1
a140 1
  CORE_ADDR sp = read_sp ();
d142 1
a142 1
  if (PC_IN_CALL_DUMMY (memaddr, sp, sp + 64))
d179 3
a181 3
   push    {r7, lr}
   add     sp, sp, #-28
   add     r7, sp, #12
d183 2
a184 2
   mov     r7, sp 
 */
d196 4
a199 4
      if ((insn & 0xfe00) != 0xb400	/* push {..., r7, lr} */
	  && (insn & 0xff00) != 0xb000	/* add sp, #simm */
	  && (insn & 0xff00) != 0xaf00	/* add r7, sp, #imm */
	  && insn != 0x466f	/* mov r7, sp */
d209 9
a217 9
   mov          ip, sp
   [stmfd       sp!, {a1,a2,a3,a4}]
   stmfd        sp!, {...,fp,ip,lr,pc}
   [stfe                f7, [sp, #-12]!]
   [stfe                f6, [sp, #-12]!]
   [stfe                f5, [sp, #-12]!]
   [stfe                f4, [sp, #-12]!]
   sub          fp, ip, #nn     // nn == 20 or 4 depending on second ins
 */
d229 1
a229 1
  if (find_pc_partial_function (pc, NULL, &func_addr, &func_end))
d244 1
a244 1
  if (inst != 0xe1a0c00d)	/* mov ip, sp */
d249 1
a249 1
  if ((inst & 0xfffffff0) == 0xe92d0000)	/* stmfd sp!,{a1,a2,a3,a4}  */
d255 1
a255 1
  if ((inst & 0xfffff800) != 0xe92dd800)	/* stmfd sp!,{...,fp,ip,lr,pc} */
d267 1
a267 1
  if ((inst & 0xffbf0fff) == 0xec2d0200)	/* sfmfd fn, <cnt>, [sp]! */
d274 5
a278 5
      while ((inst & 0xffff8fff) == 0xed6d0103)		/* stfe fn, [sp, #-12]! */
	{
	  skip_pc += 4;
	  inst = read_memory_integer (skip_pc, 4);
	}
d281 1
a281 1
  if ((inst & 0xfffff000) == 0xe24cb000)	/* sub fp, ip, #nn */
d286 3
a288 1
/* *INDENT-OFF* */
d309 1
a309 5
/* *INDENT-ON* */




d312 1
a312 1
     struct frame_info *fi;
d317 2
a318 2
  int saved_reg[16];		/* which register has been copied to register n? */
  int i;
d320 1
a320 1
  if (find_pc_partial_function (fi->pc, NULL, &prologue_start, &prologue_end))
d324 1
a324 1
      if (sal.line == 0)	/* no line info, use current PC */
d327 1
a327 1
	prologue_end = sal.end;	/* (probably means no prologue)  */
d330 2
a331 2
    prologue_end = prologue_start + 40;		/* We're in the boondocks: allow for */
  /* 16 pushes, an add, and "mv fp,sp" */
d352 1
a352 1
      if ((insn & 0xfe00) == 0xb400)	/* push { rlist } */
d361 1
a361 1
	      {
d369 3
a371 3
	  offset = (insn & 0x7f) << 2;	/* get scaled offset */
	  if (insn & 0x80)	/* is it signed? */
	    offset = -offset;
d377 1
a377 1
	  fi->frameoffset = (insn & 0xff) << 2;		/* get scaled offset */
d379 1
a379 1
      else if (insn == 0x466f)	/* mov r7, sp */
d387 1
a387 1
	  int lo_reg = insn & 7;	/* dest. register (r0-r7) */
d389 1
a389 1
	  saved_reg[lo_reg] = hi_reg;	/* remember hi reg was saved */
d392 1
a392 1
	break;			/* anything else isn't prologue */
d402 4
a405 4
   * the frame register number;
   * the size of the stack frame;
   * the offsets of saved regs (relative to the old SP); and
   * the offset from the stack pointer to the frame pointer
d412 1
a412 1
 */
d418 1
a418 1
     struct frame_info *fi;
d438 1
a438 1
 */
d442 1
a442 1
     struct frame_info *fi;
d446 3
a448 3
  prologue_cache.pc = fi->pc;
  prologue_cache.framereg = fi->framereg;
  prologue_cache.framesize = fi->framesize;
d450 1
a450 1

d458 4
a461 4
   1) the size of the stack frame
   2) which registers are saved on it
   3) the offsets of saved regs
   4) the offset from the stack pointer to the frame pointer
d465 4
a468 4
   mov    ip, sp
   stmfd  sp!, {fp, ip, lr, pc}
   sub    fp, ip, #4
   sub    sp, sp, #16
d470 6
a475 6
   IP ->   4    (caller's stack)
   FP ->   0    PC (points to address of stmfd instruction + 12 in callee)
   -4   LR (return address in caller)
   -8   IP (copy of caller's SP)
   -12  FP (caller's FP)
   SP -> -28    Local variables
d481 1
a481 1
     struct frame_info *fi;
d491 2
a492 2
  fi->framereg = SP_REGNUM;
  fi->framesize = 0;
d511 1
a511 1
      if (sal.line == 0)	/* no line info, use current PC */
d514 1
a514 1
	prologue_end = sal.end;	/* (probably means no prologue)  */
d520 2
a521 2
      prologue_start = ADDR_BITS_REMOVE (read_memory_integer (fi->frame, 4)) - 12;
      prologue_end = prologue_start + 40;	/* FIXME: should be big enough */
d546 3
a548 3
	  unsigned imm = insn & 0xff;	/* immediate value */
	  unsigned rot = (insn & 0xf00) >> 7;	/* rotate amount */
	  imm = (imm >> rot) | (imm << (32 - rot));
d554 3
a556 3
	  unsigned imm = insn & 0xff;	/* immediate value */
	  unsigned rot = (insn & 0xf00) >> 7;	/* rotate amount */
	  imm = (imm >> rot) | (imm << (32 - rot));
d559 1
a559 1
      else if ((insn & 0xffff7fff) == 0xed6d0103)	/* stfe f?, [sp, -#c]! */
d565 1
a565 1
      else if (insn == 0xe1a0c00d)	/* mov ip, sp */
d568 1
a568 1
	break;			/* not a recognized prologue instruction */
d576 1
a576 1

d590 1
a590 1
     struct frame_info *fi;
d594 2
a595 2

#if 0				/* FIXME: enable this code if we convert to new call dummy scheme.  */
d600 3
a602 3
    if (fi->fsr.regs[regnum] != 0)
      return read_memory_integer (fi->fsr.regs[regnum],
				  REGISTER_RAW_SIZE (regnum));
d605 2
a606 1
/* *INDENT-OFF* */
a621 4
/* *INDENT-ON* */



d625 1
a625 1
     struct frame_info *fi;
d627 1
a627 1
#if 0				/* FIXME: enable this code if we convert to new call dummy scheme.  */
d632 1
a632 1
    return fi->frame;		/* dummy frame same as caller's frame */
d635 1
a635 1
  callers_pc = FRAME_SAVED_PC (fi);	/* find out who called us: */
d637 2
a638 2
  if (PC_IN_CALL_DUMMY (callers_pc, fp, fp))
    return fp;			/* dummy frame's frame may bear no relation to ours */
d642 1
a642 1
      return 0;			/* in _start fn, don't chain further */
d663 1
a663 1
      memset (&caller_fi, 0, sizeof (caller_fi));
d665 1
a665 1
      arm_scan_prologue (&caller_fi);
d686 1
a686 1
     struct frame_info *fi;
d695 1
a695 1
#if 0				/* FIXME: enable this code if we convert to new call dummy scheme.  */
d699 3
a701 3
         by assuming it's always FP.  */
      fi->frame = generic_read_register_dummy (fi->pc, fi->frame, SP_REGNUM);
      fi->framesize = 0;
d705 1
a705 1
  else
d710 1
a710 1
      if (!fi->next)		/* this is the innermost frame? */
d712 6
a717 6
      else
	/* not the innermost frame */
	/* If we have an FP,  the callee saved it. */ if (fi->framereg == FP_REGNUM || fi->framereg == THUMB_FP_REGNUM)
	if (fi->next->fsr.regs[fi->framereg] != 0)
	  fi->frame = read_memory_integer (fi->next->fsr.regs[fi->framereg],
					   4);
d733 3
a735 3
   #define FRAME_SAVED_PC(FRAME) \
   ADDR_BITS_REMOVE (read_memory_integer ((FRAME)->frame - 4, 4))
 */
d739 1
a739 1
     struct frame_info *fi;
d741 1
a741 1
#if 0				/* FIXME: enable this code if we convert to new call dummy scheme.  */
d762 1
a762 1
    return read_register (FP_REGNUM);	/* R11 if ARM */
d795 1
a795 1
  sp = push_word (sp, read_register (PC_REGNUM));	/* FIXME: was PS_REGNUM */
d798 2
a799 2

  for (regnum = 10; regnum >= 0; regnum--)
d801 1
a801 1

d813 1
a813 1
   been copied into the dummy parameter to this function.
d815 1
a815 1
   "mov pc,r4" instruction patched to be a "bx r4" instead.
d817 1
a817 1
   works for calling both ARM and Thumb functions.
d821 1
a821 1
 */
d825 7
a831 7
     char *dummy;
     CORE_ADDR pc;
     CORE_ADDR fun;
     int nargs;
     value_ptr *args;
     struct type *type;
     int gcc_p;
d835 3
a837 3
    0xf000, 0xf801,		/*        bl      label */
    0xdf18,			/*        swi     24 */
    0x4720,			/* label: bx      r4 */
d842 1
a842 1
  caller_is_thumb = arm_pc_is_thumb (read_pc ());
d882 1
a882 1
 */
d895 6
a900 6
arm_push_arguments (nargs, args, sp, struct_return, struct_addr)
     int nargs;
     value_ptr *args;
     CORE_ADDR sp;
     int struct_return;
     CORE_ADDR struct_addr;
d906 1
a906 2
  struct stack_arg
    {
d912 1
a912 1
  (struct stack_arg *) alloca (nargs * sizeof (struct stack_arg));
d922 1
a922 1
    write_register (argreg++, struct_addr);
d930 2
a931 2
     registers, save the rest to be pushed on the stack */
  for (argnum = 0; argnum < nargs; argnum++)
d933 5
a937 5
      char *val;
      value_ptr arg = args[argnum];
      struct type *arg_type = check_typedef (VALUE_TYPE (arg));
      struct type *target_type = TYPE_TARGET_TYPE (arg_type);
      int len = TYPE_LENGTH (arg_type);
d939 1
a939 1
      CORE_ADDR regval;
d955 1
a955 1
#define MAPCS_FLOAT 0		/* --mapcs-float not implemented by the compiler yet */
d978 1
a978 1
		  int partial_len = len < REGISTER_SIZE ? len : REGISTER_SIZE;
d985 2
a986 2
		  len -= partial_len;
		  val += partial_len;
d998 7
a1004 7
  /* now do the real stack pushing, process args right to left */
  while (nstack_args--)
    {
      sp -= stack_args[nstack_args].len;
      write_memory (sp, stack_args[nstack_args].val,
		    stack_args[nstack_args].len);
    }
d1013 1
a1013 1
  struct frame_info *frame = get_current_frame ();
d1020 1
a1020 1
      write_register (regnum,
d1033 6
a1038 11
  if (flags & (1 << 0))
    fputs ("IVO ", stdout);
  if (flags & (1 << 1))
    fputs ("DVZ ", stdout);
  if (flags & (1 << 2))
    fputs ("OFL ", stdout);
  if (flags & (1 << 3))
    fputs ("UFL ", stdout);
  if (flags & (1 << 4))
    fputs ("INX ", stdout);
  putchar ('\n');
d1044 2
a1045 2
  register unsigned long status = read_register (FPS_REGNUM);
  int type;
d1047 8
a1054 8
  type = (status >> 24) & 127;
  printf ("%s FPU type %d\n",
	  (status & (1 << 31)) ? "Hardware" : "Software",
	  type);
  fputs ("mask: ", stdout);
  print_fpu_flags (status >> 16);
  fputs ("flags: ", stdout);
  print_fpu_flags (status);
d1061 8
a1068 11
  if (arm_register_names == APCS_register_names)
    {
      arm_register_names = additional_register_names;
      arm_toggle_regnames ();
    }
  else
    {
      arm_register_names = APCS_register_names;
      arm_toggle_regnames ();
    }

d1074 1
a1074 1
void
d1076 2
a1077 2
     void *ptr;
     double *dbl;
d1079 1
a1079 1
  *dbl = *(double *) ptr;
d1082 1
a1082 1
void
d1084 2
a1085 2
     void *ptr;
     double *dbl;
d1087 1
a1087 1
  *(double *) ptr = *dbl;
d1126 1
a1126 1
	    (((status_reg & FLAG_N) == 0) == ((status_reg & FLAG_V) == 0)));
d1129 1
a1129 1
	    (((status_reg & FLAG_N) == 0) != ((status_reg & FLAG_V) == 0)));
d1153 2
a1154 2

  if (bit (inst, 4))
d1161 2
a1162 2

  res = (rm == 15
d1164 1
a1164 1
	    + (bit (inst, 4) ? 12 : 8))
d1169 1
a1169 1
    case 0:			/* LSL */
d1172 2
a1173 2

    case 1:			/* LSR */
d1177 2
a1178 3
    case 2:			/* ASR */
      if (shift >= 32)
	shift = 31;
d1183 1
a1183 1
    case 3:			/* ROR/RRX */
d1188 1
a1188 1
	res = (res >> shift) | (res << (32 - shift));
d1204 1
a1204 1
    val &= val - 1;		/* delete rightmost 1-bit in val */
d1213 1
a1213 1
  unsigned long pc_val = ((unsigned long) pc) + 4;	/* PC after prefetch */
d1215 1
a1215 1
  CORE_ADDR nextpc = pc + 2;	/* default is next instruction */
d1234 1
a1234 1
      unsigned long cond = bits (inst1, 8, 11);
d1245 1
a1245 1
      offset = (sbits (inst1, 0, 10) << 12) + (bits (inst2, 0, 10) << 1);
d1268 1
a1268 1
  nextpc = (CORE_ADDR) (pc_val + 4);	/* Default case */
d1274 2
a1275 4
	case 0x0:
	case 0x1:		/* data processing */
	case 0x2:
	case 0x3:
d1280 1
a1280 1

d1285 1
a1285 1
		&& bits (this_instr, 4, 7) == 9)	/* multiply */
d1292 1
a1292 1

d1297 2
a1298 2
		operand2 = ((immval >> rotate) | (immval << (32 - rotate)))
		  & 0xffffffff;
d1300 1
a1300 1
	    else		/* operand 2 is a shifted register */
d1302 1
a1302 1

d1305 1
a1305 1
	      case 0x0:	/*and */
d1309 1
a1309 1
	      case 0x1:	/*eor */
d1313 1
a1313 1
	      case 0x2:	/*sub */
d1317 1
a1317 1
	      case 0x3:	/*rsb */
d1321 1
a1321 1
	      case 0x4:	/*add */
d1325 1
a1325 1
	      case 0x5:	/*adc */
d1329 1
a1329 1
	      case 0x6:	/*sbc */
d1333 1
a1333 1
	      case 0x7:	/*rsc */
d1337 1
a1337 4
	      case 0x8:
	      case 0x9:
	      case 0xa:
	      case 0xb:	/* tst, teq, cmp, cmn */
d1341 1
a1341 1
	      case 0xc:	/*orr */
d1345 1
a1345 1
	      case 0xd:	/*mov */
d1348 1
a1348 1
		break;
d1350 1
a1350 1
	      case 0xe:	/*bic */
d1354 1
a1354 1
	      case 0xf:	/*mvn */
d1364 3
a1366 5

	case 0x4:
	case 0x5:		/* data transfer */
	case 0x6:
	case 0x7:
d1373 1
a1373 1
		  unsigned long rn;
d1375 1
a1375 1

d1387 3
a1389 3
		      (bit (this_instr, 25)
		       ? shifted_reg_val (this_instr, c, pc_val)
		       : bits (this_instr, 0, 11));
d1396 1
a1396 1
		  nextpc = (CORE_ADDR) read_memory_integer ((CORE_ADDR) base,
d1398 1
a1398 1

d1406 2
a1407 3

	case 0x8:
	case 0x9:		/* block transfer */
d1421 1
a1421 1
		      if (bit (this_instr, 24))		/* pre */
d1426 1
a1426 1

d1428 2
a1429 2
		    unsigned long rn_val =
		    read_register (bits (this_instr, 16, 19));
d1432 1
a1432 1
								  + offset),
d1441 3
a1443 3

	case 0xb:		/* branch & link */
	case 0xa:		/* branch */
d1452 4
a1455 5

	case 0xc:
	case 0xd:
	case 0xe:		/* coproc ops */
	case 0xf:		/* SWI */
d1473 1
a1473 1
     disassemble_info *info;
d1477 5
a1481 5
      static asymbol *asym;
      static combined_entry_type ce;
      static struct coff_symbol_struct csym;
      static struct _bfd fake_bfd;
      static bfd_target fake_target;
d1489 3
a1491 3

	  fake_target.flavour = bfd_target_coff_flavour;
	  fake_bfd.xvec = &fake_target;
d1493 4
a1496 4
	  csym.native = &ce;
	  csym.symbol.the_bfd = &fake_bfd;
	  csym.symbol.name = "fake";
	  asym = (asymbol *) & csym;
d1498 1
a1498 1

d1500 1
a1500 1
      info->symbols = &asym;
d1504 1
a1504 1

d1512 4
a1515 4
#define ARM_LE_BREAKPOINT {0xFE,0xDE,0xFF,0xE7}		/* Recognized illegal opcodes */
#define ARM_BE_BREAKPOINT {0xE7,0xFF,0xDE,0xFE}
#define THUMB_LE_BREAKPOINT {0xfe,0xdf}
#define THUMB_BE_BREAKPOINT {0xdf,0xfe}
d1531 2
a1532 2
     CORE_ADDR *pcptr;
     int *lenptr;
d1537 6
a1542 6
	{
	  static char thumb_breakpoint[] = THUMB_BE_BREAKPOINT;
	  *pcptr = UNMAKE_THUMB_ADDR (*pcptr);
	  *lenptr = sizeof (thumb_breakpoint);
	  return thumb_breakpoint;
	}
d1544 6
a1549 6
	{
	  static char thumb_breakpoint[] = THUMB_LE_BREAKPOINT;
	  *pcptr = UNMAKE_THUMB_ADDR (*pcptr);
	  *lenptr = sizeof (thumb_breakpoint);
	  return thumb_breakpoint;
	}
d1554 5
a1558 5
	{
	  static char arm_breakpoint[] = ARM_BE_BREAKPOINT;
	  *lenptr = sizeof (arm_breakpoint);
	  return arm_breakpoint;
	}
d1560 5
a1564 5
	{
	  static char arm_breakpoint[] = ARM_LE_BREAKPOINT;
	  *lenptr = sizeof (arm_breakpoint);
	  return arm_breakpoint;
	}
d1573 1
a1573 1
     char *name;
d1595 1
a1595 1
  char *name;
d1607 4
a1610 4
      static char *table[15] =
      {"r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
       "r8", "r9", "sl", "fp", "ip", "sp", "lr"
      };
d1617 1
a1617 1
  return 0;			/* not a stub */
d1624 1
a1624 1
  int regname_is_APCS = (arm_register_names == APCS_register_names);
d1627 1
a1627 1

d1632 1
a1632 1

d1638 3
a1640 3
				  var_zinteger, (char *) &arm_apcs_32,
			       "Set usage of ARM 32-bit mode.\n", &setlist),
		     &showlist);
d1646 1
a1646 1
coff_sym_is_thumb (int val)
d1648 5
a1652 5
  return (val == C_THUMBEXT ||
	  val == C_THUMBSTAT ||
	  val == C_THUMBEXTFUNC ||
	  val == C_THUMBSTATFUNC ||
	  val == C_THUMBLABEL);
@


1.1.1.6
log
@import gdb-1999-08-09 snapshot
@
text
@d50 8
a57 8
static char *apcs_register_names[] =
{ "a1", "a2", "a3", "a4", /*  0  1  2  3 */
  "v1", "v2", "v3", "v4", /*  4  5  6  7 */
  "v5", "v6", "sl", "fp", /*  8  9 10 11 */
  "ip", "sp", "lr", "pc", /* 12 13 14 15 */
  "f0", "f1", "f2", "f3", /* 16 17 18 19 */
  "f4", "f5", "f6", "f7", /* 20 21 22 23 */
  "fps","ps" }            /* 24 25       */;
d63 7
a69 7
{ "r0", "r1", "r2", "r3", /*  0  1  2  3 */
  "r4", "r5", "r6", "r7",    /*  4  5  6  7 */
  "r8", "r9", "r10", "r11",  /*  8  9 10 11 */
  "r12", "r13", "r14", "pc", /* 12 13 14 15 */
  "f0", "f1", "f2", "f3",    /* 16 17 18 19 */
  "f4", "f5", "f6", "f7",    /* 20 21 22 23 */
  "fps","ps" }               /* 24 25       */;
d73 1
a73 16
char **arm_register_names = apcs_register_names;
/* This is the variable the is set with "set disassembly-flavor",
 and its legitimate values. */
static char apcs_flavor[] = "apcs";
static char r_prefix_flavor[] = "r-prefix";
static char *valid_flavors[] = {
  apcs_flavor,
  r_prefix_flavor,
  NULL
};
static char *disassembly_flavor = apcs_flavor;

/* This is used to keep the bfd arch_info in sync with the disassembly flavor.  */
static void set_disassembly_flavor_sfunc PARAMS ((char *, int, \
						  struct cmd_list_element *));
static void set_disassembly_flavor ();
d170 1
a171 2
  int frameless;
  
d175 1
a175 5
  /* There are some frameless functions whose first two instructions
     follow the standard APCS form, in which case after_prologue
     will be func_start + 8. */
  
  frameless = (after_prologue < func_start + 12);
d229 1
a229 2
  /* See what the symbol table says.  */
  
d233 1
a233 1
      if ((sal.line != 0) && (sal.end < func_end))
d467 5
a471 8
   There are two basic forms for the ARM prologue.  The fixed argument
   function call will look like:
   
	mov    ip, sp
	stmfd  sp!, {fp, ip, lr, pc}
	sub    fp, ip, #4
        [sub sp, sp, #4]

d473 6
a478 7
     IP ->   4	(caller's stack)
     FP ->   0	PC (points to address of stmfd instruction + 8 in callee)
	    -4	LR (return address in caller)
	    -8	IP (copy of caller's SP)
     	   -12	FP (caller's FP)
     SP -> -28	Local variables
     
d480 1
a480 42
   28 bytes.  The stmfd call can also save any of the vN registers it
   plans to use, which increases the frame size accordingly.

   Note: The stored PC is 8 off of the STMFD instruction that stored it
   because the ARM Store instructions always store PC + 8 when you read
   the PC register.
   
   A variable argument function call will look like:

	mov    ip, sp
	stmfd  sp!, {a1, a2, a3, a4}
	stmfd  sp!, {fp, ip, lr, pc}
	sub    fp, ip, #20
   
   Which would create this stack frame (offsets relative to FP):
     IP ->  20	(caller's stack)
            16  A4
	    12  A3
	     8  A2
	     4  A1
     FP ->   0	PC (points to address of stmfd instruction + 8 in callee)
	    -4	LR (return address in caller)
	    -8	IP (copy of caller's SP)
     	   -12	FP (caller's FP)
     SP -> -28	Local variables

   The frame size would thus be 48 bytes, and the frame offset would be
   28 bytes.

   There is another potential complication, which is that the optimizer
   will try to separate the store of fp in the "stmfd" instruction from
   the "sub fp, ip, #NN" instruction.  Almost anything can be there, so
   we just key on the stmfd, and then scan for the "sub fp, ip, #NN"...

   Also, note, the original version of the ARM toolchain claimed that there
   should be an

   instruction at the end of the prologue.  I have never seen GCC produce
   this, and the ARM docs don't mention it.  We still test for it below in
   case it happens...
   
*/
d522 3
a524 7
         PC is the address of the stmfd + 8.  */
      prologue_start = ADDR_BITS_REMOVE(read_memory_integer (fi->frame, 4))
	- 8;
      prologue_end = prologue_start + 64; /* This is all the insn's
					     that could be in the prologue,
					     plus room for 5 insn's inserted
					     by the scheduler.  */
d528 1
a528 8
     frame pointer, adjust the stack pointer, and save registers.
     
     Be careful, however, and if it doesn't look like a prologue,
     don't try to scan it.  If, for instance, a frameless function
     begins with stmfd sp!, then we will tell ourselves there is
     a frame, which will confuse stack traceback, as well ad"finish" 
     and other operations that rely on a knowledge of the stack
     traceback.
d530 4
a533 2
     In the APCS, the prologue should start with  "mov ip, sp" so
     if we don't see this as the first insn, we will stop.  */
d535 3
a537 1
  sp_offset = fp_offset = 0;
d539 24
a562 5
  if (read_memory_unsigned_integer (prologue_start, 4) 
                                           == 0xe1a0c00d)  /* mov ip, sp */
    {
      for (current_pc = prologue_start +4; current_pc < prologue_end;
	   current_pc += 4)
d564 3
a566 69
	  unsigned int insn = read_memory_unsigned_integer (current_pc, 4);
	  
	  if ((insn & 0xffff0000) == 0xe92d0000)
	    /* stmfd sp!, {..., fp, ip, lr, pc}
	       or
	       stmfd sp!, {a1, a2, a3, a4}  */
	    {
	      int mask = insn & 0xffff;
	      
	      /* Calculate offsets of saved registers. */
	      for (regno = PC_REGNUM; regno >= 0; regno--)
		if (mask & (1 << regno))
		  {
		    sp_offset -= 4;
		    fi->fsr.regs[regno] = sp_offset;
		  }
	    }
	  else if ((insn & 0xfffff000) == 0xe24cb000)	  /* sub fp, ip #n */
	    {
	      unsigned imm = insn & 0xff;		  /* immediate value */
	      unsigned rot = (insn & 0xf00) >> 7;	  /* rotate amount */
	      imm = (imm >> rot) | (imm << (32-rot));
	      fp_offset = -imm;
	      fi->framereg = FP_REGNUM;
	    }
	  else if ((insn & 0xfffff000) == 0xe24dd000)	  /* sub sp, sp #n */
	    {
	      unsigned imm = insn & 0xff;		  /* immediate value */
	      unsigned rot = (insn & 0xf00) >> 7;	  /* rotate amount */
	      imm = (imm >> rot) | (imm << (32-rot));
	      sp_offset -= imm;
	    }
	  else if ((insn & 0xffff7fff) == 0xed6d0103) /* stfe f?, [sp, -#c]! */
	    {
	      sp_offset -= 12;
	      regno = F0_REGNUM + ((insn >> 12) & 0x07);
	      fi->fsr.regs[regno] = sp_offset;
	    }
	  else if ((insn & 0xffbf0fff) == 0xec2d0200) /* sfmfd f0, 4, [sp!] */
	    {
	      int n_saved_fp_regs, i;
	      unsigned int fp_start_reg, fp_bound_reg;
	      
	      if ((insn & 0x800) == 0x800) /* N0 is set */
		{  
		  if ((insn & 0x40000) == 0x40000) /* N1 is set */
		    n_saved_fp_regs = 3;
		  else
		    n_saved_fp_regs = 1;
		}
	      else
		{  
		  if ((insn & 0x40000) == 0x40000) /* N1 is set */
		    n_saved_fp_regs = 2;
		  else
		    n_saved_fp_regs = 4;
		}
	      
	      fp_start_reg = F0_REGNUM + ((insn >> 12) & 0x7);
	      fp_bound_reg = fp_start_reg + n_saved_fp_regs;
	      for (; fp_start_reg < fp_bound_reg; fp_start_reg++)
		{
		  sp_offset -= 12;
		  fi->fsr.regs[fp_start_reg++] = sp_offset;
		}
	    }
	  else
	    continue;  /* The optimizer might shove anything into the
			  prologue, so we just skip what we don't recognize. */
d568 4
d579 1
a579 1
  
d688 1
a688 4
   examine the prologue.
   FROMLEAF is a little confusing, it means this is the next frame up
   the chain AFTER a frameless function.  If this is true, then the
   frame value for this frame is still in the fp register.  */
d691 2
a692 3
arm_init_extra_frame_info (fromleaf, fi)
     int fromleaf;
     struct frame_info * fi;
d718 6
a723 10
      else			 	/* not the innermost frame */
	/* If we have an FP,  the callee saved it. */
	if (fi->framereg == FP_REGNUM || fi->framereg == THUMB_FP_REGNUM)
	  if (fi->next->fsr.regs[fi->framereg] != 0)
	    fi->frame = read_memory_integer (fi->next->fsr.regs[fi->framereg],
					     4);
          else if (fromleaf) /* If we were called by a frameless fn.
				 then our frame is still in the frame pointer
				 register on the board... */
	    fi->frame = read_fp ();
d1061 1
a1061 1
	  (status & (1<<31)) ? "Hardware" : "Software",
a1068 16
/* If the disassembly mode is APCS, we have to also switch the
   bfd mach_type.  This function is run in the set disassembly_flavor
   command, and does that.  */

static void
set_disassembly_flavor_sfunc (args, from_tty, c)
     char *args;
     int from_tty;
     struct cmd_list_element *c;
{
  set_disassembly_flavor ();
  
  if (disassembly_flavor_hook != NULL)
    disassembly_flavor_hook(args, from_tty);
}

d1070 1
a1070 1
set_disassembly_flavor ()
a1071 18
  if (disassembly_flavor == apcs_flavor)
    {
      if (arm_toggle_regnames () == 0)
	arm_toggle_regnames ();
      arm_register_names = apcs_register_names;
    }
  else if (disassembly_flavor == r_prefix_flavor)
    {
      if (arm_toggle_regnames () == 1)
	arm_toggle_regnames ();
      arm_register_names =  additional_register_names;
    }       
}

/* arm_othernames implements the "othernames" command.  This is kind of
   hacky, and I prefer the set-show disassembly-flavor which is also used
   for the x86 gdb.  I will keep this around, however, in case anyone is
   actually using it. */
d1073 1
a1073 4
static void
arm_othernames ()
{
  if (disassembly_flavor == r_prefix_flavor)
d1075 2
a1076 2
      disassembly_flavor = apcs_flavor;
      set_disassembly_flavor ();
d1080 2
a1081 2
      disassembly_flavor = r_prefix_flavor;
      set_disassembly_flavor ();
d1083 1
d1649 1
a1649 1
  struct cmd_list_element *new_cmd;
d1652 1
a1652 1
  
d1655 1
a1655 1
  if (arm_toggle_regnames () != 1)
a1657 2
  /* Add the deprecated "othernames" command */
  
a1660 12
  /* Add the disassembly-flavor command */
  
  new_cmd = add_set_enum_cmd ("disassembly-flavor", no_class,
				  valid_flavors,
				  (char *) &disassembly_flavor,
				  "Set the disassembly flavor, \
the valid values are \"apcs\" and \"r-prefix\", \
and the default value is \"apcs\".",
				  &setlist);
  new_cmd->function.sfunc = set_disassembly_flavor_sfunc;
  add_show_from_set(new_cmd, &showlist);
  
d1663 3
a1665 3
				  var_zinteger, (char *)&arm_apcs_32,
				  "Set usage of ARM 32-bit mode.\n", &setlist),
		     & showlist);
@


1.1.1.7
log
@import gdb-1999-08-16 snapshot
@
text
@d189 2
a190 2
  after_prologue = SKIP_PROLOGUE (func_start);
  
d1204 3
@


1.1.1.8
log
@import gdb-1999-08-30 snapshot
@
text
@d836 1
a836 2
      if (!fi->next)
	/* this is the innermost frame? */
d838 1
a838 2
      else
	/* not the innermost frame */
d841 7
a847 10
	  {
	    if (fi->next->fsr.regs[fi->framereg] != 0)
	      fi->frame =
		read_memory_integer (fi->next->fsr.regs[fi->framereg], 4);
	    else if (fromleaf)
	      /* If we were called by a frameless fn.  then our frame
		 is still in the frame pointer register on the
		 board... */
	      fi->frame = read_fp ();
	  }
d1249 1
a1249 1
     void *dbl;
d1251 1
a1251 1
  *(double *) dbl = *(double *) ptr;
d1257 1
a1257 1
     void *dbl;
d1259 1
a1259 1
  *(double *) ptr = *(double *) dbl;
@


1.1.1.9
log
@import gdb-1999-11-01 snapshot
@
text
@d1701 2
a1702 2
#define THUMB_LE_BREAKPOINT {0xbe,0xbe}       
#define THUMB_BE_BREAKPOINT {0xbe,0xbe}       
@


1.1.1.10
log
@import gdb-1999-12-21 snapshot
@
text
@d1 2
a2 2
/* Common target dependent code for GDB on ARM systems.
   Copyright 1988, 1989, 1991, 1992, 1993, 1995-1999
a30 2
extern void _initialize_arm_tdep (void);

d45 5
a49 1
/* Default register names as specified by APCS.  */
d51 19
a69 7
{"a1", "a2", "a3", "a4",	/*  0  1  2  3 */
 "v1", "v2", "v3", "v4",	/*  4  5  6  7 */
 "v5", "v6", "sl", "fp",	/*  8  9 10 11 */
 "ip", "sp", "lr", "pc",	/* 12 13 14 15 */
 "f0", "f1", "f2", "f3",	/* 16 17 18 19 */
 "f4", "f5", "f6", "f7",	/* 20 21 22 23 */
 "fps", "ps"} /* 24 25       */ ;
d71 1
a71 9
/* Alternate set of registers names used by GCC.  */
static char *additional_register_names[] =
{"r0", "r1", "r2", "r3",	/*  0  1  2  3 */
 "r4", "r5", "r6", "r7",	/*  4  5  6  7 */
 "r8", "r9", "r10", "r11",	/*  8  9 10 11 */
 "r12", "r13", "r14", "pc",	/* 12 13 14 15 */
 "f0", "f1", "f2", "f3",	/* 16 17 18 19 */
 "f4", "f5", "f6", "f7",	/* 20 21 22 23 */
 "fps", "ps"} /* 24 25       */ ;
a72 2
/* This is the variable that is set with "set disassembly-flavor".
   By default use the APCS registers names.  */
d74 2
a75 2

/* Valid register name flavours.  */
d78 1
a78 2
static char *valid_flavors[] =
{
a82 2

/* Disassembly flavor to use.  */
d85 4
a88 25
/* This is used to keep the bfd arch_info in sync with the disassembly
   flavor.  */
static void set_disassembly_flavor_sfunc(char *, int,
					 struct cmd_list_element *);
static void set_disassembly_flavor (void);

static void convert_from_extended (void *ptr, void *dbl);

/* Define other aspects of the stack frame.  We keep the offsets of
   all saved registers, 'cause we need 'em a lot!  We also keep the
   current size of the stack frame, and the offset of the frame
   pointer from the stack pointer (for frameless functions, and when
   we're still in the prologue of a function with a frame) */

struct frame_extra_info
  {
    struct frame_saved_regs fsr;
    int framesize;
    int frameoffset;
    int framereg;
  };

/* Will a function return an aggregate type in memory or in a
   register?  Return 0 if an aggregate type can be returned in a
   register, 1 if it must be returned in memory.  */
d90 2
d93 3
a95 1
arm_use_struct_convention (int gcc_p, struct type *type)
d97 1
a97 85
  int nRc;
  register enum type_code code;

  /* In the ARM ABI, "integer" like aggregate types are returned in
     registers.  For an aggregate type to be integer like, its size
     must be less than or equal to REGISTER_SIZE and the offset of
     each addressable subfield must be zero.  Note that bit fields are
     not addressable, and all addressable subfields of unions always
     start at offset zero.

     This function is based on the behaviour of GCC 2.95.1.
     See: gcc/arm.c: arm_return_in_memory() for details.

     Note: All versions of GCC before GCC 2.95.2 do not set up the
     parameters correctly for a function returning the following
     structure: struct { float f;}; This should be returned in memory,
     not a register.  Richard Earnshaw sent me a patch, but I do not
     know of any way to detect if a function like the above has been
     compiled with the correct calling convention.  */

  /* All aggregate types that won't fit in a register must be returned
     in memory.  */
  if (TYPE_LENGTH (type) > REGISTER_SIZE)
    {
      return 1;
    }

  /* The only aggregate types that can be returned in a register are
     structs and unions.  Arrays must be returned in memory.  */
  code = TYPE_CODE (type);
  if ((TYPE_CODE_STRUCT != code) && (TYPE_CODE_UNION != code))
    {
      return 1;
    }

  /* Assume all other aggregate types can be returned in a register.
     Run a check for structures, unions and arrays.  */
  nRc = 0;

  if ((TYPE_CODE_STRUCT == code) || (TYPE_CODE_UNION == code))
    {
      int i;
      /* Need to check if this struct/union is "integer" like.  For
         this to be true, its size must be less than or equal to
         REGISTER_SIZE and the offset of each addressable subfield
         must be zero.  Note that bit fields are not addressable, and
         unions always start at offset zero.  If any of the subfields
         is a floating point type, the struct/union cannot be an
         integer type.  */

      /* For each field in the object, check:
         1) Is it FP? --> yes, nRc = 1;
         2) Is it addressable (bitpos != 0) and
         not packed (bitsize == 0)?
         --> yes, nRc = 1  
       */

      for (i = 0; i < TYPE_NFIELDS (type); i++)
	{
	  enum type_code field_type_code;
	  field_type_code = TYPE_CODE (TYPE_FIELD_TYPE (type, i));

	  /* Is it a floating point type field?  */
	  if (field_type_code == TYPE_CODE_FLT)
	    {
	      nRc = 1;
	      break;
	    }

	  /* If bitpos != 0, then we have to care about it.  */
	  if (TYPE_FIELD_BITPOS (type, i) != 0)
	    {
	      /* Bitfields are not addressable.  If the field bitsize is 
	         zero, then the field is not packed.  Hence it cannot be
	         a bitfield or any other packed type.  */
	      if (TYPE_FIELD_BITSIZE (type, i) == 0)
		{
		  nRc = 1;
		  break;
		}
	    }
	}
    }

  return nRc;
d101 3
a103 1
arm_frame_chain_valid (CORE_ADDR chain, struct frame_info *thisframe)
d105 1
d113 4
a116 5
/* Flag set by arm_fix_call_dummy that tells whether the target
   function is a Thumb function.  This flag is checked by
   arm_push_arguments.  FIXME: Change the PUSH_ARGUMENTS macro (and
   its use in valops.c) to pass the function address as an additional
   parameter.  */
d120 3
a122 3
/* Flag set by arm_fix_call_dummy that tells whether the calling
   function is a Thumb function.  This flag is checked by
   arm_pc_is_thumb and arm_call_dummy_breakpoint_offset.  */
d126 1
a126 2
/* Determine if the program counter specified in MEMADDR is in a Thumb
   function.  */
d129 2
a130 1
arm_pc_is_thumb (bfd_vma memaddr)
d133 1
d135 1
a135 1
  /* If bit 0 of the address is set, assume this is a Thumb address.  */
d139 1
a139 1
  /* Thumb functions have a "special" bit set in minimal symbols.  */
d146 1
a146 3
    {
      return 0;
    }
d149 2
a150 2
/* Determine if the program counter specified in MEMADDR is in a call
   dummy being called from a Thumb function.  */
d153 2
a154 1
arm_pc_is_thumb_dummy (bfd_vma memaddr)
d165 2
a166 1
arm_addr_bits_remove (CORE_ADDR val)
d175 2
a176 1
arm_saved_pc_after_call (struct frame_info *frame)
d182 2
a183 1
arm_frameless_function_invocation (struct frame_info *fi)
d187 1
a187 1

d190 1
a190 1

d192 3
a194 3
     follow the standard APCS form, in which case after_prologue will
     be func_start + 8. */

d205 1
a205 1
   */
d208 2
a209 1
thumb_skip_prologue (CORE_ADDR pc)
d217 5
a221 5
      if ((insn & 0xfe00) != 0xb400	/* push {..., r7, lr}   */
	  && (insn & 0xff00) != 0xb000	/* add sp, #simm        */
	  && (insn & 0xff00) != 0xaf00	/* add r7, sp, #imm     */
	  && insn != 0x466f	/* mov r7, sp           */
	  && (insn & 0xffc0) != 0x4640)		/* mov r0-r7, r8-r15    */
d228 1
a228 2
/* The APCS (ARM Procedure Call Standard) defines the following
   prologue:
d233 6
a238 5
   [stfe        f7, [sp, #-12]!]
   [stfe        f6, [sp, #-12]!]
   [stfe        f5, [sp, #-12]!]
   [stfe        f4, [sp, #-12]!]
   sub fp, ip, #nn @@@@ nn == 20 or 4 depending on second insn */
d241 2
a242 1
arm_skip_prologue (CORE_ADDR pc)
d250 1
a250 1

d284 2
a285 2
     for better instruction scheduling, so we skip them only if we
     find them, but still consdier the function to be frame-ful.  */
d287 2
a288 3
  /* We may have either one sfmfd instruction here, or several stfe
     insns, depending on the version of floating point code we
     support.  */
d331 3
d335 2
a336 1
thumb_scan_prologue (struct frame_info *fi)
d420 3
a422 2
/* Check if prologue for this frame's PC has already been scanned.  If
   it has, copy the relevant information about that prologue and
d431 6
a436 5
   The cache contains only one entry, since this is adequate for the
   typical sequence of prologue scan requests we get.  When performing
   a backtrace, GDB will usually ask to scan the same function twice
   in a row (once to get the frame chain, and once to fill in the
   extra frame information).  */
d441 2
a442 1
check_prologue_cache (struct frame_info *fi)
d460 3
a462 1
/* Copy the prologue information from fi to the prologue cache.  */
d465 2
a466 1
save_prologue_cache (struct frame_info *fi)
d480 2
a481 1
/* This function decodes an ARM function prologue to determine:
d490 5
a494 5

   mov    ip, sp
   stmfd  sp!, {fp, ip, lr, pc}
   sub    fp, ip, #4
   [sub sp, sp, #4]
d497 7
a503 7
   IP ->   4    (caller's stack)
   FP ->   0    PC (points to address of stmfd instruction + 8 in callee)
   -4   LR (return address in caller)
   -8   IP (copy of caller's SP)
   -12  FP (caller's FP)
   SP -> -28    Local variables

d511 1
a511 1

d514 5
a518 5
   mov    ip, sp
   stmfd  sp!, {a1, a2, a3, a4}
   stmfd  sp!, {fp, ip, lr, pc}
   sub    fp, ip, #20

d520 10
a529 10
   IP ->  20    (caller's stack)
   16  A4
   12  A3
   8  A2
   4  A1
   FP ->   0    PC (points to address of stmfd instruction + 8 in callee)
   -4   LR (return address in caller)
   -8   IP (copy of caller's SP)
   -12  FP (caller's FP)
   SP -> -28    Local variables
d545 2
a546 2

 */
d549 2
a550 1
arm_scan_prologue (struct frame_info *fi)
d589 1
a589 1
      prologue_start = ADDR_BITS_REMOVE (read_memory_integer (fi->frame, 4))
d591 4
a594 4
      prologue_end = prologue_start + 64;	/* This is all the insn's
						   that could be in the prologue,
						   plus room for 5 insn's inserted
						   by the scheduler.  */
d599 1
a599 1

d612 2
a613 2
  if (read_memory_unsigned_integer (prologue_start, 4)
      == 0xe1a0c00d)		/* mov ip, sp */
d615 1
a615 1
      for (current_pc = prologue_start + 4; current_pc < prologue_end;
d619 1
a619 1

d626 1
a626 1

d635 1
a635 1
	  else if ((insn & 0xfffff000) == 0xe24cb000)	/* sub fp, ip #n */
d637 3
a639 3
	      unsigned imm = insn & 0xff;	/* immediate value */
	      unsigned rot = (insn & 0xf00) >> 7;	/* rotate amount */
	      imm = (imm >> rot) | (imm << (32 - rot));
d643 1
a643 1
	  else if ((insn & 0xfffff000) == 0xe24dd000)	/* sub sp, sp #n */
d645 3
a647 3
	      unsigned imm = insn & 0xff;	/* immediate value */
	      unsigned rot = (insn & 0xf00) >> 7;	/* rotate amount */
	      imm = (imm >> rot) | (imm << (32 - rot));
d650 1
a650 1
	  else if ((insn & 0xffff7fff) == 0xed6d0103)	/* stfe f?, [sp, -#c]! */
d656 1
a656 1
	  else if ((insn & 0xffbf0fff) == 0xec2d0200)	/* sfmfd f0, 4, [sp!] */
d658 1
a658 1
	      int n_saved_fp_regs;
d660 4
a663 4

	      if ((insn & 0x800) == 0x800)	/* N0 is set */
		{
		  if ((insn & 0x40000) == 0x40000)	/* N1 is set */
d669 2
a670 2
		{
		  if ((insn & 0x40000) == 0x40000)	/* N1 is set */
d675 1
a675 1

d685 2
a686 3
	    /* The optimizer might shove anything into the prologue,
	       so we just skip what we don't recognize. */
	    continue;
d695 1
a695 1

d699 7
a705 6
/* Find REGNUM on the stack.  Otherwise, it's in an active register.
   One thing we might want to do here is to check REGNUM against the
   clobber mask, and somehow flag it as invalid if it isn't saved on
   the stack somewhere.  This would provide a graceful failure mode
   when trying to get the value of caller-saves registers for an inner
   frame.  */
d708 3
a710 1
arm_find_callers_reg (struct frame_info *fi, int regnum)
d742 3
d746 2
a747 1
arm_frame_chain (struct frame_info *fi)
d799 9
a807 8
/* This function actually figures out the frame address for a given pc
   and sp.  This is tricky because we sometimes don't use an explicit
   frame pointer, and the previous stack pointer isn't necessarily
   recorded on the stack.  The only reliable way to get this info is
   to examine the prologue.  FROMLEAF is a little confusing, it means
   this is the next frame up the chain AFTER a frameless function.  If
   this is true, then the frame value for this frame is still in the
   fp register.  */
d810 3
a812 1
arm_init_extra_frame_info (int fromleaf, struct frame_info *fi)
d839 14
a852 12
      else if (fi->framereg == FP_REGNUM || fi->framereg == THUMB_FP_REGNUM)
	{
	  /* not the innermost frame */
	  /* If we have an FP, the callee saved it. */
	  if (fi->next->fsr.regs[fi->framereg] != 0)
	    fi->frame =
	      read_memory_integer (fi->next->fsr.regs[fi->framereg], 4);
	  else if (fromleaf)
	    /* If we were called by a frameless fn.  then our frame is
	       still in the frame pointer register on the board... */
	    fi->frame = read_fp ();
	}
d854 2
a855 2
      /* Calculate actual addresses of saved registers using offsets
         determined by arm_scan_prologue.  */
d863 3
a865 3
/* Find the caller of this frame.  We do this by seeing if LR_REGNUM
   is saved in the stack anywhere, otherwise we get it from the
   registers.
d869 2
a870 1
   ADDR_BITS_REMOVE (read_memory_integer ((FRAME)->frame - 4, 4)) */
d873 2
a874 1
arm_frame_saved_pc (struct frame_info *fi)
d887 1
d892 1
a892 1
arm_target_read_fp (void)
a899 1
/* Calculate the frame offsets of the saved registers (ARM version).  */
d901 1
d903 3
a905 2
arm_frame_find_saved_regs (struct frame_info *fi,
			   struct frame_saved_regs *regaddr)
d910 1
d912 1
a912 1
arm_push_dummy_frame (void)
d926 2
a927 2
  /* Push a pointer to the dummy prologue + 12, because when stm
     instruction stores the PC, it stores the address of the stm
d943 2
a944 2
   in Thumb or ARM mode, and whether the target function is Thumb or
   ARM.  There are three different situations requiring three
d954 3
a956 2
   All three call dummies expect to receive the target function
   address in R4, with the low bit set if it's a Thumb function.  */
d959 8
a966 2
arm_fix_call_dummy (char *dummy, CORE_ADDR pc, CORE_ADDR fun, int nargs,
		    value_ptr *args, struct type *type, int gcc_p)
d979 3
a981 4
  /* If the target function is Thumb, set the low bit of the function
     address.  And if the CPU is currently in ARM mode, patch the
     second instruction of call dummy to use a BX instruction to
     switch to Thumb mode.  */
d1006 1
a1006 2
  /* Put the target address in r4; the call dummy will copy this to
     the PC. */
d1010 1
d1012 2
a1013 2
   to have a breakpoint placed on it.  This is the offset of the 'swi
   24' instruction, which is no longer actually used, but simply acts
d1016 2
a1017 1
   This implements the CALL_DUMMY_BREAK_OFFSET macro.  */
d1020 1
a1020 1
arm_call_dummy_breakpoint_offset (void)
a1027 5
/* Note: ScottB

   This function does not support passing parameters using the FPA
   variant of the APCS.  It passes any floating point arguments in the
   general registers and/or on the stack.  */
d1030 12
a1041 15
arm_push_arguments (int nargs, value_ptr * args, CORE_ADDR sp,
		    int struct_return, CORE_ADDR struct_addr)
{
  char *fp;
  int argnum, argreg, nstack_size;

  /* Walk through the list of args and determine how large a temporary
     stack is required.  Need to take care here as structs may be
     passed on the stack, and we have to to push them.  */
  nstack_size = -4 * REGISTER_SIZE;	/* Some arguments go into A1-A4.  */
  if (struct_return)		/* The struct address goes in A1.  */
    nstack_size += REGISTER_SIZE;

  /* Walk through the arguments and add their size to nstack_size.  */
  for (argnum = 0; argnum < nargs; argnum++)
d1043 1
d1045 5
a1049 4
      struct type *arg_type;

      arg_type = check_typedef (VALUE_TYPE (args[argnum]));
      len = TYPE_LENGTH (arg_type);
a1050 7
      /* ANSI C code passes float arguments as integers, K&R code
         passes float arguments as doubles.  Correct for this here.  */
      if (TYPE_CODE_FLT == TYPE_CODE (arg_type) && REGISTER_SIZE == len)
	nstack_size += FP_REGISTER_VIRTUAL_SIZE;
      else
	nstack_size += len;
    }
d1052 1
a1052 10
  /* Allocate room on the stack, and initialize our stack frame
     pointer.  */
  fp = NULL;
  if (nstack_size > 0)
    {
      sp -= nstack_size;
      fp = (char *) sp;
    }

  /* Initialize the integer argument register pointer.  */
d1054 1
d1056 1
a1056 2
  /* The struct_return pointer occupies the first parameter passing
     register.  */
d1060 7
a1066 3
  /* Process arguments from left to right.  Store as many as allowed
     in the parameter passing registers (A1-A4), and save the rest on
     the temporary stack.  */
a1068 1
      int len;
d1070 5
a1074 1
      double dbl_arg;
d1076 1
a1076 2
      enum type_code typecode;
      struct type *arg_type, *target_type;
d1078 3
a1080 22
      arg_type = check_typedef (VALUE_TYPE (args[argnum]));
      target_type = TYPE_TARGET_TYPE (arg_type);
      len = TYPE_LENGTH (arg_type);
      typecode = TYPE_CODE (arg_type);
      val = (char *) VALUE_CONTENTS (args[argnum]);

      /* ANSI C code passes float arguments as integers, K&R code
         passes float arguments as doubles.  The .stabs record for 
         for ANSI prototype floating point arguments records the
         type as FP_INTEGER, while a K&R style (no prototype)
         .stabs records the type as FP_FLOAT.  In this latter case
         the compiler converts the float arguments to double before
         calling the function.  */
      if (TYPE_CODE_FLT == typecode && REGISTER_SIZE == len)
	{
	  float f = *(float *) val;
	  dbl_arg = f;
	  val = (char *) &dbl_arg;
	  len = sizeof (double);
	}
#if 0
      /* If the argument is a pointer to a function, and it is a Thumb
d1082 3
a1084 3
      if (TYPE_CODE_PTR == typecode
	  && NULL != target_type
	  && TYPE_CODE_FUNC == TYPE_CODE (target_type))
d1086 1
a1086 1
	  CORE_ADDR regval = extract_address (val, len);
d1090 15
a1105 4
      /* Copy the argument to general registers or the stack in
         register-sized pieces.  Large arguments are split between
         registers and stack.  */
      while (len > 0)
d1107 9
a1115 1
	  int partial_len = len < REGISTER_SIZE ? len : REGISTER_SIZE;
d1117 14
a1130 5
	  if (argreg <= ARM_LAST_ARG_REGNUM)
	    {
	      /* It's an argument being passed in a general register.  */
	      regval = extract_address (val, partial_len);
	      write_register (argreg++, regval);
a1131 9
	  else
	    {
	      /* Push the arguments onto the stack.  */
	      write_memory ((CORE_ADDR) fp, val, REGISTER_SIZE);
	      fp += REGISTER_SIZE;
	    }

	  len -= partial_len;
	  val += partial_len;
d1134 7
d1147 1
a1147 1
arm_pop_frame (void)
d1166 2
a1167 1
print_fpu_flags (int flags)
d1183 1
a1183 1
arm_float_info (void)
d1190 1
a1190 1
	  (status & (1 << 31)) ? "Hardware" : "Software",
d1203 4
a1206 2
set_disassembly_flavor_sfunc (char *args, int from_tty,
			      struct cmd_list_element *c)
d1212 1
a1212 1
set_disassembly_flavor (void)
d1224 2
a1225 2
      arm_register_names = additional_register_names;
    }
d1228 4
a1231 4
/* arm_othernames implements the "othernames" command.  This is kind
   of hacky, and I prefer the set-show disassembly-flavor which is
   also used for the x86 gdb.  I will keep this around, however, in
   case anyone is actually using it. */
d1234 1
a1234 1
arm_othernames (char *names, int n)
d1248 2
a1249 4
#if 0
/* FIXME:  The generated assembler works but sucks.  Instead of using
   r0, r1 it pushes them on the stack, then loads them into r3, r4 and
   uses those registers.  I must be missing something.  ScottB  */
d1252 3
a1254 21
convert_from_extended (void *ptr, void *dbl)
{
  __asm__ ("
	   ldfe f0,[%0]
	   stfd f0,[%1] "
:				/* no output */
:	   "r" (ptr), "r" (dbl));
}

void
convert_to_extended (void *dbl, void *ptr)
{
  __asm__ ("
	   ldfd f0,[%0]
	   stfe f0,[%1] "
:				/* no output */
:	   "r" (dbl), "r" (ptr));
}
#else
static void
convert_from_extended (void *ptr, void *dbl)
d1260 3
a1262 1
convert_to_extended (void *dbl, void *ptr)
a1265 35
#endif

/* Nonzero if register N requires conversion from raw format to
   virtual format.  */

int
arm_register_convertible (unsigned int regnum)
{
  return ((regnum - F0_REGNUM) < 8);
}

/* Convert data from raw format for register REGNUM in buffer FROM to
   virtual format with type TYPE in buffer TO.  */

void
arm_register_convert_to_virtual (unsigned int regnum, struct type *type,
				 void *from, void *to)
{
  double val;

  convert_from_extended (from, &val);
  store_floating (to, TYPE_LENGTH (type), val);
}

/* Convert data from virtual format with type TYPE in buffer FROM to
   raw format for register REGNUM in buffer TO.  */

void
arm_register_convert_to_raw (unsigned int regnum, struct type *type,
			     void *from, void *to)
{
  double val = extract_floating (from, TYPE_LENGTH (type));

  convert_to_extended (&val, to);
}
d1268 3
a1270 1
condition_true (unsigned long cond, unsigned long status_reg)
d1303 1
a1303 1
	      (((status_reg & FLAG_N) == 0) == ((status_reg & FLAG_V) == 0)));
d1306 1
a1306 1
	      (((status_reg & FLAG_N) == 0) != ((status_reg & FLAG_V) == 0)));
d1321 5
a1325 2
shifted_reg_val (unsigned long inst, int carry, unsigned long pc_val,
		 unsigned long status_reg)
d1373 1
d1377 2
a1378 1
bitcount (unsigned long val)
d1386 1
d1388 2
a1389 1
thumb_get_next_pc (CORE_ADDR pc)
d1430 1
d1432 2
a1433 1
arm_get_next_pc (CORE_ADDR pc)
d1573 1
a1573 1
		       ? shifted_reg_val (this_instr, c, pc_val, status)
d1658 3
a1660 1
gdb_print_insn_arm (bfd_vma memaddr, disassemble_info *info)
d1698 16
a1713 6
/* This function implements the BREAKPOINT_FROM_PC macro.  It uses the
   program counter value to determine whether a 16-bit or 32-bit
   breakpoint should be used.  It returns a pointer to a string of
   bytes that encode a breakpoint instruction, stores the length of
   the string to *lenptr, and adjusts the program counter (if
   necessary) to point to the actual memory location where the
d1717 3
a1719 1
arm_breakpoint_from_pc (CORE_ADDR *pcptr, int *lenptr)
d1754 2
a1755 17

/* Extract from an array REGBUF containing the (raw) register state a
   function return value of type TYPE, and copy that, in virtual
   format, into VALBUF.  */

void
arm_extract_return_value (struct type *type,
			  char regbuf[REGISTER_BYTES],
			  char *valbuf)
{
  if (TYPE_CODE_FLT == TYPE_CODE (type))
    convert_from_extended (&regbuf[REGISTER_BYTE (F0_REGNUM)], valbuf);
  else
    memcpy (valbuf, &regbuf[REGISTER_BYTE (A1_REGNUM)], TYPE_LENGTH (type));
}

/* Return non-zero if the PC is inside a thumb call thunk.  */
d1758 3
a1760 1
arm_in_call_stub (CORE_ADDR pc, char *name)
d1764 2
a1765 2
  /* Find the starting address of the function containing the PC.  If
     the caller didn't give us a name, look it up at the same time.  */
d1772 5
a1776 4
/* If PC is in a Thumb call or return stub, return the address of the
   target PC, which is in a register.  The thunk functions are called
   _called_via_xx, where x is the register name.  The possible names
   are r0-r9, sl, fp, ip, sp, and lr.  */
d1779 2
a1780 1
arm_skip_stub (CORE_ADDR pc)
d1792 2
a1793 2
      /* Use the name suffix to determine which register contains the
         target PC.  */
a1803 1

d1807 1
d1809 1
a1809 1
_initialize_arm_tdep (void)
d1814 1
a1814 1

d1821 1
a1821 1

d1826 1
a1826 1

d1828 3
a1830 3
			      valid_flavors,
			      (char *) &disassembly_flavor,
			      "Set the disassembly flavor, \
d1833 1
a1833 1
			      &setlist);
d1835 2
a1836 2
  add_show_from_set (new_cmd, &showlist);

d1839 1
a1839 1
				  var_zinteger, (char *) &arm_apcs_32,
d1841 1
a1841 1
		     &showlist);
d1845 1
a1845 3
/* Test whether the coff symbol specific value corresponds to a Thumb
   function.  */

@


1.1.1.11
log
@import gdb-2000-01-31 snapshot
@
text
@d2 1
a2 1
   Copyright 1988, 1989, 1991, 1992, 1993, 1995, 1996, 1997, 1998, 1999, 2000
d48 1
a48 1
static char * atpcs_register_names[] =
d51 2
a52 2
 "v5", "v6", "v7", "v8",	/*  8  9 10 11 */
 "IP", "SP", "LR", "PC",	/* 12 13 14 15 */
d55 1
a55 1
 "FPS", "PS" }; 		/* 24 25       */
d58 8
a65 8
static char * additional_register_names[] =
{"r0",  "r1",  "r2",  "r3",	/*  0  1  2  3 */
 "r4",  "r5",  "r6",  "r7",	/*  4  5  6  7 */
 "r8",  "r9",  "r10", "r11",	/*  8  9 10 11 */
 "r12", "sp",  "lr",  "pc",	/* 12 13 14 15 */
 "f0",  "f1",  "f2",  "f3",	/* 16 17 18 19 */
 "f4",  "f5",  "f6",  "f7",	/* 20 21 22 23 */
 "fps", "ps" }; 		/* 24 25       */
d69 1
a69 1
char ** arm_register_names = atpcs_register_names;
d74 1
a74 1
static char * valid_flavors[] =
d299 1
a299 21
   mov     r7, sp
   
   or like this:
   push    {r7, lr}
   mov     r7, sp
   sub	   sp, #12
   
   or, on tpcs, like this:
   sub     sp,#16
   push    {r7, lr}
   (many instructions)
   mov     r7, sp
   sub	   sp, #12

   There is always one instruction of three classes:
   1 - push
   2 - setting of r7
   3 - adjusting of sp
   
   When we have found at least one of each class we are done with the prolog.
   Note that the "sub sp, #NN" before the push does not count.
a305 5
  int findmask = 0;  	/* findmask:
      			   bit 0 - push { rlist }
			   bit 1 - mov r7, sp  OR  add r7, sp, #imm  (setting of r7)
      			   bit 2 - sub sp, #simm  OR  add sp, #simm  (adjusting of sp)
			*/
d307 1
a307 1
  for (current_pc = pc; current_pc < pc + 40; current_pc += 2)
d311 6
a316 22
      if ((insn & 0xfe00) == 0xb400)	/* push { rlist } */
	{
	  findmask |= 1;  /* push found */
	}
      else if ((insn & 0xff00) == 0xb000)	/* add sp, #simm  OR  sub sp, #simm */
	{
	  if ((findmask & 1) == 0)  /* before push ? */
	    continue;
	  else
	    findmask |= 4;  /* add/sub sp found */
	}
      else if ((insn & 0xff00) == 0xaf00)	/* add r7, sp, #imm */
	{
	  findmask |= 2;  /* setting of r7 found */
	}
      else if (insn == 0x466f)			/* mov r7, sp */
	{
	  findmask |= 2;  /* setting of r7 found */
	}
      else
	continue;	/* something in the prolog that we don't care about or some
	  		   instruction from outside the prolog scheduled here for optimization */
d411 5
a415 2
   A typical Thumb function prologue would create this stack frame
   (offsets relative to FP)
d422 1
a422 4
   12 bytes.  The frame register is R7. 
   
   The comments for thumb_skip_prolog() describe the algorithm we use to detect
   the end of the prolog */
a431 5
  int findmask = 0;  	/* findmask:
      			   bit 0 - push { rlist }
			   bit 1 - mov r7, sp  OR  add r7, sp, #imm  (setting of r7)
      			   bit 2 - sub sp, #simm  OR  add sp, #simm  (adjusting of sp)
			*/
d455 1
a455 2
     frame pointer, adjust the stack pointer, and save registers.
     Do this until all basic prolog instructions are found.  */
d458 1
a458 3
  for (current_pc = prologue_start;
       (current_pc < prologue_end) && ((findmask & 7) != 7);
       current_pc += 2)
a467 2
	  int mask;
	  findmask |= 1;  /* push found */
d470 1
a470 1
	  mask = (insn & 0xff) | ((insn & 0x100) << 6);
d481 1
a481 1
      else if ((insn & 0xff00) == 0xb000)	/* add sp, #simm  OR  sub sp, #simm */
a482 5
	  if ((findmask & 1) == 0)  /* before push ? */
	    continue;
	  else
	    findmask |= 4;  /* add/sub sp found */
	  
d484 2
a485 5
	  if (insn & 0x80)	/* is it signed? (==subtracting) */
	    {
	      fi->frameoffset += offset;
	      offset = -offset;
	    }
a489 1
	  findmask |= 2;  /* setting of r7 found */
d493 1
a493 1
      else if (insn == 0x466f)			/* mov r7, sp */
a494 1
	  findmask |= 2;  /* setting of r7 found */
d506 1
a506 2
	continue;	/* something in the prolog that we don't care about or some
	  		   instruction from outside the prolog scheduled here for optimization */
d1173 1
a1173 4
#if 1
      /* I don't know why this code was disable. The only logical use
         for a function pointer is to call that function, so setting
         the mode bit is perfectly fine. FN */
d1281 3
a1283 2
      parse_arm_disassembler_option ("reg-names-atpcs");
      arm_register_names = atpcs_register_names;
d1287 2
a1288 1
      parse_arm_disassembler_option ("reg-names-std");
d1920 3
a1922 1
  parse_arm_disassembler_option ("reg-names-atpcs");
@


1.1.1.12
log
@import gdb-2000-02-02 snapshot
@
text
@a105 18
#define SWAP_TARGET_AND_HOST(buffer,len) 				\
  do									\
    {									\
      if (TARGET_BYTE_ORDER != HOST_BYTE_ORDER)				\
	{								\
	  char tmp;							\
	  char *p = (char *)(buffer);					\
	  char *q = ((char *)(buffer)) + len - 1;		   	\
	  for (; p < q; p++, q--)				 	\
	    {								\
	      tmp = *q;							\
	      *q = *p;							\
	      *p = tmp;							\
	    }								\
	}								\
    }									\
  while (0)

a254 1
  CORE_ADDR fp = read_fp ();
d256 1
a256 1
  if (PC_IN_CALL_DUMMY (memaddr, sp, fp))
d1230 3
a1232 5
	  float f;
	  double d;
	  char * bufo = (char *) &d;
	  char * bufd = (char *) &dbl_arg;

a1233 10
	  f = *(float *) val;
	  SWAP_TARGET_AND_HOST (&f, sizeof (float));  /* adjust endianess */
	  d = f;
	  /* We must revert the longwords so they get loaded into the
	     the right registers. */
	  memcpy (bufd, bufo + len / 2, len / 2);
	  SWAP_TARGET_AND_HOST (bufd, len / 2);  /* adjust endianess */
	  memcpy (bufd + len / 2, bufo, len / 2);
	  SWAP_TARGET_AND_HOST (bufd + len / 2, len / 2); /* adjust endianess */
	  val = (char *) &dbl_arg;
d1282 1
d1284 1
a1284 5
  struct frame_info *frame = get_current_frame ();

  if (!PC_IN_CALL_DUMMY(frame->pc, frame->frame, read_fp()))
    {
      CORE_ADDR old_SP;
d1286 4
a1289 4
      old_SP = read_register (frame->framereg);
      for (regnum = 0; regnum < NUM_REGS; regnum++)
        if (frame->fsr.regs[regnum] != 0)
          write_register (regnum,
d1292 2
a1293 23
      write_register (PC_REGNUM, FRAME_SAVED_PC (frame));
      write_register (SP_REGNUM, old_SP);
    }
  else
    {
      CORE_ADDR sp;

      sp = read_register (FP_REGNUM);
      sp -= sizeof(CORE_ADDR); /* we don't care about this first word */

      write_register (PC_REGNUM, read_memory_integer (sp, 4));
      sp -= sizeof(CORE_ADDR);
      write_register (SP_REGNUM, read_memory_integer (sp, 4));
      sp -= sizeof(CORE_ADDR);
      write_register (FP_REGNUM, read_memory_integer (sp, 4));
      sp -= sizeof(CORE_ADDR);

      for (regnum = 10; regnum >= 0; regnum--)
        {
          write_register (regnum, read_memory_integer (sp, 4));
          sp -= sizeof(CORE_ADDR);
        }
    }
@


1.1.1.13
log
@import gdb-2000-02-04 snapshot
@
text
@d273 1
d275 1
a275 8
  /* FIXME: Until we switch for the new call dummy macros, this heuristic
     is the best we can do.  We are trying to determine if the pc is on
     the stack, which (hopefully) will only happen in a call dummy.
     We hope the current stack pointer is not so far alway from the dummy
     frame location (true if we have not pushed large data structures or
     gone too many levels deep) and that our 1024 is not enough to consider
     code regions as part of the stack (true for most practical purposes) */
  if (PC_IN_CALL_DUMMY (memaddr, sp, sp + 1024))
@


