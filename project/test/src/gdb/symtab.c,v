head	1.371;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.349
	gdb_7_6-2013-04-26-release:1.349
	gdb_7_6-branch:1.349.0.2
	gdb_7_6-2013-03-12-branchpoint:1.349
	gdb_7_5_1-2012-11-29-release:1.319
	gdb_7_5-2012-08-17-release:1.319
	gdb_7_5-branch:1.319.0.2
	gdb_7_5-2012-07-18-branchpoint:1.319
	gdb_7_4_1-2012-04-26-release:1.288.2.1
	gdb_7_4-2012-01-24-release:1.288.2.1
	gdb_7_4-branch:1.288.0.2
	gdb_7_4-2011-12-13-branchpoint:1.288
	gdb_7_3_1-2011-09-04-release:1.262.2.6
	gdb_7_3-2011-07-26-release:1.262.2.6
	gdb_7_3-branch:1.262.0.2
	gdb_7_3-2011-04-01-branchpoint:1.262
	gdb_7_2-2010-09-02-release:1.240.2.1
	gdb_7_2-branch:1.240.0.2
	gdb_7_2-2010-07-07-branchpoint:1.240
	gdb_7_1-2010-03-18-release:1.224
	gdb_7_1-branch:1.224.0.2
	gdb_7_1-2010-02-18-branchpoint:1.224
	gdb_7_0_1-2009-12-22-release:1.215
	gdb_7_0-2009-10-06-release:1.215
	gdb_7_0-branch:1.215.0.2
	gdb_7_0-2009-09-16-branchpoint:1.215
	arc-sim-20090309:1.173
	msnyder-checkpoint-072509-branch:1.214.0.2
	msnyder-checkpoint-072509-branchpoint:1.214
	arc-insight_6_8-branch:1.173.0.6
	arc-insight_6_8-branchpoint:1.173
	insight_6_8-branch:1.173.0.4
	insight_6_8-branchpoint:1.173
	reverse-20081226-branch:1.199.0.4
	reverse-20081226-branchpoint:1.199
	multiprocess-20081120-branch:1.199.0.2
	multiprocess-20081120-branchpoint:1.199
	reverse-20080930-branch:1.197.0.2
	reverse-20080930-branchpoint:1.197
	reverse-20080717-branch:1.191.0.2
	reverse-20080717-branchpoint:1.191
	msnyder-reverse-20080609-branch:1.189.0.2
	msnyder-reverse-20080609-branchpoint:1.189
	drow-reverse-20070409-branch:1.156.0.2
	drow-reverse-20070409-branchpoint:1.156
	gdb_6_8-2008-03-27-release:1.173
	gdb_6_8-branch:1.173.0.2
	gdb_6_8-2008-02-26-branchpoint:1.173
	gdb_6_7_1-2007-10-29-release:1.164
	gdb_6_7-2007-10-10-release:1.164
	gdb_6_7-branch:1.164.0.2
	gdb_6_7-2007-09-07-branchpoint:1.164
	insight_6_6-20070208-release:1.148
	gdb_6_6-2006-12-18-release:1.148
	gdb_6_6-branch:1.148.0.2
	gdb_6_6-2006-11-15-branchpoint:1.148
	insight_6_5-20061003-release:1.147
	gdb-csl-symbian-6_4_50_20060226-12:1.146.8.1
	gdb-csl-sourcerygxx-3_4_4-25:1.145
	nickrob-async-20060828-mergepoint:1.147
	gdb-csl-symbian-6_4_50_20060226-11:1.146
	gdb-csl-sourcerygxx-4_1-17:1.146.2.1
	gdb-csl-20060226-branch-local-2:1.146.2.1
	gdb-csl-sourcerygxx-4_1-14:1.146.2.1
	gdb-csl-sourcerygxx-4_1-13:1.146.2.1
	gdb-csl-sourcerygxx-4_1-12:1.146.2.1
	gdb-csl-sourcerygxx-3_4_4-21:1.146.2.1
	gdb_6_5-20060621-release:1.147
	gdb-csl-sourcerygxx-4_1-9:1.146.2.1
	gdb-csl-sourcerygxx-4_1-8:1.146.2.1
	gdb-csl-sourcerygxx-4_1-7:1.146.2.1
	gdb-csl-arm-2006q1-6:1.146.2.1
	gdb-csl-sourcerygxx-4_1-6:1.146.2.1
	gdb-csl-symbian-6_4_50_20060226-10:1.146
	gdb-csl-symbian-6_4_50_20060226-9:1.146
	gdb-csl-symbian-6_4_50_20060226-8:1.146
	gdb-csl-coldfire-4_1-11:1.146.2.1
	gdb-csl-sourcerygxx-3_4_4-19:1.146.2.1
	gdb-csl-coldfire-4_1-10:1.146.2.1
	gdb_6_5-branch:1.147.0.4
	gdb_6_5-2006-05-14-branchpoint:1.147
	gdb-csl-sourcerygxx-4_1-5:1.146.2.1
	nickrob-async-20060513-branch:1.147.0.2
	nickrob-async-20060513-branchpoint:1.147
	gdb-csl-sourcerygxx-4_1-4:1.146.2.1
	msnyder-reverse-20060502-branch:1.146.0.12
	msnyder-reverse-20060502-branchpoint:1.146
	gdb-csl-morpho-4_1-4:1.146
	gdb-csl-sourcerygxx-3_4_4-17:1.146
	readline_5_1-import-branch:1.146.0.10
	readline_5_1-import-branchpoint:1.146
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.146
	gdb-csl-symbian-20060226-branch:1.146.0.8
	gdb-csl-symbian-20060226-branchpoint:1.146
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.146
	msnyder-reverse-20060331-branch:1.146.0.6
	msnyder-reverse-20060331-branchpoint:1.146
	gdb-csl-available-20060303-branch:1.146.0.4
	gdb-csl-available-20060303-branchpoint:1.146
	gdb-csl-20060226-branch:1.146.0.2
	gdb-csl-20060226-branchpoint:1.146
	gdb_6_4-20051202-release:1.145
	msnyder-fork-checkpoint-branch:1.145.0.12
	msnyder-fork-checkpoint-branchpoint:1.145
	gdb-csl-gxxpro-6_3-branch:1.145.0.10
	gdb-csl-gxxpro-6_3-branchpoint:1.145
	gdb_6_4-branch:1.145.0.8
	gdb_6_4-2005-11-01-branchpoint:1.145
	gdb-csl-arm-20051020-branch:1.145.0.6
	gdb-csl-arm-20051020-branchpoint:1.145
	msnyder-tracepoint-checkpoint-branch:1.145.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.145
	gdb-csl-arm-20050325-2005-q1b:1.145
	gdb-csl-arm-20050325-2005-q1a:1.145
	csl-arm-20050325-branch:1.145.0.2
	csl-arm-20050325-branchpoint:1.145
	gdb-post-i18n-errorwarning-20050211:1.142
	gdb-pre-i18n-errorwarning-20050211:1.141
	gdb_6_3-20041109-release:1.140
	gdb_6_3-branch:1.140.0.2
	gdb_6_3-20041019-branchpoint:1.140
	drow_intercu-merge-20040921:1.139
	drow_intercu-merge-20040915:1.136
	jimb-gdb_6_2-e500-branch:1.134.0.6
	jimb-gdb_6_2-e500-branchpoint:1.134
	gdb_6_2-20040730-release:1.134
	gdb_6_2-branch:1.134.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.134
	gdb_6_1_1-20040616-release:1.128
	gdb_6_1-2004-04-05-release:1.128
	drow_intercu-merge-20040402:1.128
	drow_intercu-merge-20040327:1.128
	ezannoni_pie-20040323-branch:1.128.0.8
	ezannoni_pie-20040323-branchpoint:1.128
	cagney_tramp-20040321-mergepoint:1.128
	cagney_tramp-20040309-branch:1.128.0.6
	cagney_tramp-20040309-branchpoint:1.128
	gdb_6_1-branch:1.128.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.128
	drow_intercu-20040221-branch:1.128.0.2
	drow_intercu-20040221-branchpoint:1.128
	cagney_bfdfile-20040213-branch:1.126.0.2
	cagney_bfdfile-20040213-branchpoint:1.126
	drow-cplus-merge-20040208:1.126
	carlton_dictionary-20040126-merge:1.125
	cagney_bigcore-20040122-branch:1.124.0.2
	cagney_bigcore-20040122-branchpoint:1.124
	drow-cplus-merge-20040113:1.124
	drow-cplus-merge-20031224:1.124
	drow-cplus-merge-20031220:1.124
	carlton_dictionary-20031215-merge:1.123
	drow-cplus-merge-20031214:1.123
	carlton-dictionary-20031111-merge:1.122
	gdb_6_0-2003-10-04-release:1.113.4.1
	kettenis_sparc-20030918-branch:1.116.0.4
	kettenis_sparc-20030918-branchpoint:1.116
	carlton_dictionary-20030917-merge:1.116
	ezannoni_pie-20030916-branchpoint:1.116
	ezannoni_pie-20030916-branch:1.116.0.2
	cagney_x86i386-20030821-branch:1.114.0.2
	cagney_x86i386-20030821-branchpoint:1.114
	carlton_dictionary-20030805-merge:1.113
	carlton_dictionary-20030627-merge:1.113
	gdb_6_0-branch:1.113.0.4
	gdb_6_0-2003-06-23-branchpoint:1.113
	jimb-ppc64-linux-20030613-branch:1.113.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.113
	cagney_convert-20030606-branch:1.109.0.6
	cagney_convert-20030606-branchpoint:1.109
	cagney_writestrings-20030508-branch:1.102.0.4
	cagney_writestrings-20030508-branchpoint:1.102
	jimb-ppc64-linux-20030528-branch:1.109.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.109
	carlton_dictionary-20030523-merge:1.109
	cagney_fileio-20030521-branch:1.109.0.2
	cagney_fileio-20030521-branchpoint:1.109
	kettenis_i386newframe-20030517-mergepoint:1.104
	jimb-ppc64-linux-20030509-branch:1.102.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.102
	kettenis_i386newframe-20030504-mergepoint:1.102
	carlton_dictionary-20030430-merge:1.102
	kettenis_i386newframe-20030419-branch:1.101.0.2
	kettenis_i386newframe-20030419-branchpoint:1.101
	carlton_dictionary-20030416-merge:1.101
	cagney_frameaddr-20030409-mergepoint:1.99
	kettenis_i386newframe-20030406-branch:1.99.0.12
	kettenis_i386newframe-20030406-branchpoint:1.99
	cagney_frameaddr-20030403-branchpoint:1.99
	cagney_frameaddr-20030403-branch:1.99.0.10
	cagney_framebase-20030330-mergepoint:1.99
	cagney_framebase-20030326-branch:1.99.0.8
	cagney_framebase-20030326-branchpoint:1.99
	cagney_lazyid-20030317-branch:1.99.0.6
	cagney_lazyid-20030317-branchpoint:1.99
	kettenis-i386newframe-20030316-mergepoint:1.99
	offbyone-20030313-branch:1.99.0.4
	offbyone-20030313-branchpoint:1.99
	kettenis-i386newframe-20030308-branch:1.99.0.2
	kettenis-i386newframe-20030308-branchpoint:1.99
	carlton_dictionary-20030305-merge:1.99
	cagney_offbyone-20030303-branch:1.98.0.2
	cagney_offbyone-20030303-branchpoint:1.98
	carlton_dictionary-20030207-merge:1.87
	interps-20030203-mergepoint:1.86
	interps-20030202-branch:1.86.0.2
	interps-20030202-branchpoint:1.86
	cagney-unwind-20030108-branch:1.84.0.2
	cagney-unwind-20030108-branchpoint:1.84
	carlton_dictionary-20021223-merge:1.83
	gdb_5_3-2002-12-12-release:1.69
	carlton_dictionary-20021115-merge:1.78
	kseitz_interps-20021105-merge:1.76
	kseitz_interps-20021103-merge:1.75
	drow-cplus-merge-20021020:1.70
	drow-cplus-merge-20021025:1.74
	carlton_dictionary-20021025-merge:1.74
	carlton_dictionary-20021011-merge:1.70
	drow-cplus-branch:1.70.0.4
	drow-cplus-branchpoint:1.70
	kseitz_interps-20020930-merge:1.70
	carlton_dictionary-20020927-merge:1.70
	carlton_dictionary-branch:1.70.0.2
	carlton_dictionary-20020920-branchpoint:1.70
	gdb_5_3-branch:1.69.0.2
	gdb_5_3-2002-09-04-branchpoint:1.69
	kseitz_interps-20020829-merge:1.68
	cagney_sysregs-20020825-branch:1.68.0.4
	cagney_sysregs-20020825-branchpoint:1.68
	readline_4_3-import-branch:1.68.0.2
	readline_4_3-import-branchpoint:1.68
	gdb_5_2_1-2002-07-23-release:1.57
	kseitz_interps-20020528-branch:1.63.0.4
	kseitz_interps-20020528-branchpoint:1.63
	cagney_regbuf-20020515-branch:1.63.0.2
	cagney_regbuf-20020515-branchpoint:1.63
	jimb-macro-020506-branch:1.62.0.2
	jimb-macro-020506-branchpoint:1.62
	gdb_5_2-2002-04-29-release:1.57
	gdb_5_2-branch:1.57.0.2
	gdb_5_2-2002-03-03-branchpoint:1.57
	gdb_5_1_1-2002-01-24-release:1.42
	gdb_5_1_0_1-2002-01-03-release:1.42
	cygnus_cvs_20020108_pre:1.51
	gdb_5_1_0_1-2002-01-03-branchpoint:1.42
	gdb_5_1_0_1-2002-01-03-branch:1.42.0.6
	gdb_5_1-2001-11-21-release:1.42
	gdb_s390-2001-09-26-branch:1.42.0.4
	gdb_s390-2001-09-26-branchpoint:1.42
	gdb_5_1-2001-07-29-branch:1.42.0.2
	gdb_5_1-2001-07-29-branchpoint:1.42
	dberlin-typesystem-branch:1.41.0.2
	dberlin-typesystem-branchpoint:1.41
	gdb-post-ptid_t-2001-05-03:1.35
	gdb-pre-ptid_t-2001-05-03:1.35
	insight-precleanup-2001-01-01:1.25
	gdb-post-protoization-2000-07-29:1.10
	gdb-pre-protoization-2000-07-29:1.9
	gdb-premipsmulti-2000-06-06-branch:1.7.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.7
	gdb-post-params-removal-2000-06-04:1.6
	gdb-pre-params-removal-2000-06-04:1.6
	gdb-post-params-removal-2000-05-28:1.5
	gdb-pre-params-removal-2000-05-28:1.4
	gdb_5_0-2000-05-19-release:1.3
	gdb_4_18_2-2000-05-18-release:1.3
	gdb_4_95_1-2000-05-11-snapshot:1.3
	gdb_4_95_0-2000-04-27-snapshot:1.3
	gdb_5_0-2000-04-10-branch:1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.3
	repo-unification-2000-02-06:1.1.1.13
	insight-2000-02-04:1.1.1.13
	gdb-2000-02-04:1.1.1.13
	gdb-2000-02-02:1.1.1.13
	gdb-2000-02-01:1.1.1.12
	gdb-2000-01-31:1.1.1.12
	gdb-2000-01-26:1.1.1.11
	gdb-2000-01-24:1.1.1.11
	gdb-2000-01-17:1.1.1.11
	gdb-2000-01-10:1.1.1.11
	gdb-2000-01-05:1.1.1.11
	gdb-1999-12-21:1.1.1.11
	gdb-1999-12-13:1.1.1.11
	gdb-1999-12-07:1.1.1.11
	gdb-1999-12-06:1.1.1.11
	gdb-1999-11-16:1.1.1.11
	gdb-1999-11-08:1.1.1.11
	gdb-1999-11-01:1.1.1.11
	gdb-1999-10-25:1.1.1.11
	gdb-1999-10-18:1.1.1.11
	gdb-1999-10-11:1.1.1.10
	gdb-1999-10-04:1.1.1.10
	gdb-1999-09-28:1.1.1.10
	gdb-1999-09-21:1.1.1.10
	gdb-1999-09-13:1.1.1.9
	gdb-1999-09-08:1.1.1.9
	gdb-1999-08-30:1.1.1.8
	gdb-1999-08-23:1.1.1.8
	gdb-1999-08-16:1.1.1.8
	gdb-1999-08-09:1.1.1.8
	gdb-1999-08-02:1.1.1.8
	gdb-1999-07-26:1.1.1.7
	gdb-1999-07-19:1.1.1.7
	gdb-1999-07-12:1.1.1.7
	gdb-post-reformat-19990707:1.1.1.7
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.7
	gdb-pre-reformat-19990707:1.1.1.6
	gdb-1999-07-07:1.1.1.6
	gdb-1999-07-05:1.1.1.6
	gdb-1999-06-28:1.1.1.6
	gdb-1999-06-21:1.1.1.5
	gdb-1999-06-14:1.1.1.5
	gdb-1999-06-07:1.1.1.5
	gdb-1999-06-01:1.1.1.4
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.4
	gdb-1999-05-19:1.1.1.3
	gdb-1999-05-10:1.1.1.3
	gdb-19990504:1.1.1.3
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.371
date	2013.10.07.19.40.38;	author tromey;	state Exp;
branches;
next	1.370;

1.370
date	2013.10.02.09.22.43;	author brobecke;	state Exp;
branches;
next	1.369;

1.369
date	2013.10.02.09.22.32;	author brobecke;	state Exp;
branches;
next	1.368;

1.368
date	2013.09.25.21.51.27;	author devans;	state Exp;
branches;
next	1.367;

1.367
date	2013.08.07.20.03.52;	author tromey;	state Exp;
branches;
next	1.366;

1.366
date	2013.08.05.15.51.02;	author tromey;	state Exp;
branches;
next	1.365;

1.365
date	2013.08.01.23.47.02;	author devans;	state Exp;
branches;
next	1.364;

1.364
date	2013.07.29.20.15.47;	author devans;	state Exp;
branches;
next	1.363;

1.363
date	2013.07.29.20.04.16;	author devans;	state Exp;
branches;
next	1.362;

1.362
date	2013.05.30.17.20.02;	author tromey;	state Exp;
branches;
next	1.361;

1.361
date	2013.04.15.17.30.36;	author tromey;	state Exp;
branches;
next	1.360;

1.360
date	2013.04.08.20.18.11;	author tromey;	state Exp;
branches;
next	1.359;

1.359
date	2013.04.08.20.04.42;	author tromey;	state Exp;
branches;
next	1.358;

1.358
date	2013.04.08.19.59.09;	author tromey;	state Exp;
branches;
next	1.357;

1.357
date	2013.04.08.19.56.03;	author tromey;	state Exp;
branches;
next	1.356;

1.356
date	2013.04.08.19.53.18;	author tromey;	state Exp;
branches;
next	1.355;

1.355
date	2013.04.08.19.48.30;	author tromey;	state Exp;
branches;
next	1.354;

1.354
date	2013.03.20.18.35.22;	author tromey;	state Exp;
branches;
next	1.353;

1.353
date	2013.03.20.18.33.05;	author tromey;	state Exp;
branches;
next	1.352;

1.352
date	2013.03.14.18.56.02;	author tromey;	state Exp;
branches;
next	1.351;

1.351
date	2013.03.14.16.36.27;	author jkratoch;	state Exp;
branches;
next	1.350;

1.350
date	2013.03.13.18.34.54;	author palves;	state Exp;
branches;
next	1.349;

1.349
date	2013.03.07.21.57.30;	author kseitz;	state Exp;
branches;
next	1.348;

1.348
date	2013.03.05.21.15.34;	author devans;	state Exp;
branches;
next	1.347;

1.347
date	2013.02.03.16.20.19;	author jkratoch;	state Exp;
branches;
next	1.346;

1.346
date	2013.02.03.16.13.29;	author jkratoch;	state Exp;
branches;
next	1.345;

1.345
date	2013.02.03.16.03.07;	author jkratoch;	state Exp;
branches;
next	1.344;

1.344
date	2013.02.03.16.00.35;	author jkratoch;	state Exp;
branches;
next	1.343;

1.343
date	2013.02.03.15.54.16;	author jkratoch;	state Exp;
branches;
next	1.342;

1.342
date	2013.01.31.18.31.48;	author aristovski;	state Exp;
branches;
next	1.341;

1.341
date	2013.01.24.20.36.01;	author tdaitx;	state Exp;
branches;
next	1.340;

1.340
date	2013.01.21.18.03.08;	author tromey;	state Exp;
branches;
next	1.339;

1.339
date	2013.01.21.18.01.34;	author tromey;	state Exp;
branches;
next	1.338;

1.338
date	2013.01.17.20.40.43;	author jkratoch;	state Exp;
branches;
next	1.337;

1.337
date	2013.01.17.19.55.18;	author jkratoch;	state Exp;
branches;
next	1.336;

1.336
date	2013.01.09.20.46.03;	author devans;	state Exp;
branches;
next	1.335;

1.335
date	2013.01.01.06.32.52;	author brobecke;	state Exp;
branches;
next	1.334;

1.334
date	2012.12.28.09.05.40;	author jkratoch;	state Exp;
branches;
next	1.333;

1.333
date	2012.12.25.08.03.31;	author jkratoch;	state Exp;
branches;
next	1.332;

1.332
date	2012.12.18.19.26.28;	author tromey;	state Exp;
branches;
next	1.331;

1.331
date	2012.12.16.18.57.16;	author jkratoch;	state Exp;
branches;
next	1.330;

1.330
date	2012.12.14.21.19.09;	author tromey;	state Exp;
branches;
next	1.329;

1.329
date	2012.12.14.17.47.39;	author tromey;	state Exp;
branches;
next	1.328;

1.328
date	2012.12.14.17.16.16;	author tromey;	state Exp;
branches;
next	1.327;

1.327
date	2012.12.10.20.30.05;	author devans;	state Exp;
branches;
next	1.326;

1.326
date	2012.12.07.20.09.08;	author tromey;	state Exp;
branches;
next	1.325;

1.325
date	2012.12.03.19.59.13;	author tromey;	state Exp;
branches;
next	1.324;

1.324
date	2012.11.27.07.41.43;	author qiyao;	state Exp;
branches;
next	1.323;

1.323
date	2012.11.20.22.51.04;	author muller;	state Exp;
branches;
next	1.322;

1.322
date	2012.11.09.19.58.01;	author tromey;	state Exp;
branches;
next	1.321;

1.321
date	2012.10.18.20.14.44;	author tromey;	state Exp;
branches;
next	1.320;

1.320
date	2012.09.25.12.38.56;	author brobecke;	state Exp;
branches;
next	1.319;

1.319
date	2012.07.16.03.07.01;	author devans;	state Exp;
branches;
next	1.318;

1.318
date	2012.07.13.21.50.27;	author devans;	state Exp;
branches;
next	1.317;

1.317
date	2012.07.13.18.41.21;	author devans;	state Exp;
branches;
next	1.316;

1.316
date	2012.06.29.22.46.45;	author devans;	state Exp;
branches;
next	1.315;

1.315
date	2012.06.28.18.56.52;	author devans;	state Exp;
branches;
next	1.314;

1.314
date	2012.06.26.20.14.02;	author devans;	state Exp;
branches;
next	1.313;

1.313
date	2012.06.19.00.53.34;	author devans;	state Exp;
branches;
next	1.312;

1.312
date	2012.06.13.15.47.14;	author tromey;	state Exp;
branches;
next	1.311;

1.311
date	2012.06.05.13.50.50;	author brobecke;	state Exp;
branches;
next	1.310;

1.310
date	2012.06.05.13.50.40;	author brobecke;	state Exp;
branches;
next	1.309;

1.309
date	2012.06.04.03.07.03;	author devans;	state Exp;
branches;
next	1.308;

1.308
date	2012.06.04.02.57.28;	author devans;	state Exp;
branches;
next	1.307;

1.307
date	2012.06.02.04.34.23;	author sergiodj;	state Exp;
branches;
next	1.306;

1.306
date	2012.05.24.02.51.48;	author devans;	state Exp;
branches;
next	1.305;

1.305
date	2012.05.24.00.23.13;	author devans;	state Exp;
branches;
next	1.304;

1.304
date	2012.05.18.21.02.50;	author sergiodj;	state Exp;
branches;
next	1.303;

1.303
date	2012.05.10.19.50.08;	author tromey;	state Exp;
branches;
next	1.302;

1.302
date	2012.05.10.16.24.40;	author brobecke;	state Exp;
branches;
next	1.301;

1.301
date	2012.04.27.20.47.56;	author sergiodj;	state Exp;
branches;
next	1.300;

1.300
date	2012.04.25.14.07.20;	author devans;	state Exp;
branches;
next	1.299;

1.299
date	2012.03.21.21.59.19;	author kevinb;	state Exp;
branches;
next	1.298;

1.298
date	2012.03.01.21.13.59;	author palves;	state Exp;
branches;
next	1.297;

1.297
date	2012.02.07.04.48.22;	author devans;	state Exp;
branches;
next	1.296;

1.296
date	2012.02.02.14.58.31;	author tromey;	state Exp;
branches;
next	1.295;

1.295
date	2012.02.01.16.10.31;	author gary;	state Exp;
branches;
next	1.294;

1.294
date	2012.01.28.18.08.20;	author jkratoch;	state Exp;
branches;
next	1.293;

1.293
date	2012.01.26.23.41.54;	author devans;	state Exp;
branches;
next	1.292;

1.292
date	2012.01.26.23.22.23;	author devans;	state Exp;
branches;
next	1.291;

1.291
date	2012.01.26.04.21.40;	author brobecke;	state Exp;
branches;
next	1.290;

1.290
date	2012.01.16.20.40.50;	author tromey;	state Exp;
branches;
next	1.289;

1.289
date	2012.01.04.08.17.13;	author brobecke;	state Exp;
branches;
next	1.288;

1.288
date	2011.12.06.18.54.39;	author tromey;	state Exp;
branches
	1.288.2.1;
next	1.287;

1.287
date	2011.11.15.17.40.01;	author devans;	state Exp;
branches;
next	1.286;

1.286
date	2011.11.11.00.43.04;	author devans;	state Exp;
branches;
next	1.285;

1.285
date	2011.10.29.07.26.07;	author jkratoch;	state Exp;
branches;
next	1.284;

1.284
date	2011.10.28.17.29.37;	author sterling;	state Exp;
branches;
next	1.283;

1.283
date	2011.07.21.15.13.29;	author ratmice;	state Exp;
branches;
next	1.282;

1.282
date	2011.07.05.20.30.19;	author tromey;	state Exp;
branches;
next	1.281;

1.281
date	2011.07.04.18.51.12;	author bauermann;	state Exp;
branches;
next	1.280;

1.280
date	2011.07.04.18.47.09;	author bauermann;	state Exp;
branches;
next	1.279;

1.279
date	2011.07.04.18.31.25;	author bauermann;	state Exp;
branches;
next	1.278;

1.278
date	2011.07.01.19.18.36;	author jkratoch;	state Exp;
branches;
next	1.277;

1.277
date	2011.06.20.17.53.33;	author tromey;	state Exp;
branches;
next	1.276;

1.276
date	2011.06.17.20.46.47;	author tromey;	state Exp;
branches;
next	1.275;

1.275
date	2011.06.10.21.50.54;	author jkratoch;	state Exp;
branches;
next	1.274;

1.274
date	2011.05.18.16.30.36;	author tromey;	state Exp;
branches;
next	1.273;

1.273
date	2011.05.11.18.29.01;	author bauermann;	state Exp;
branches;
next	1.272;

1.272
date	2011.05.06.15.06.46;	author jkratoch;	state Exp;
branches;
next	1.271;

1.271
date	2011.05.06.13.47.07;	author jkratoch;	state Exp;
branches;
next	1.270;

1.270
date	2011.04.28.17.37.06;	author jkratoch;	state Exp;
branches;
next	1.269;

1.269
date	2011.04.27.20.03.03;	author jkratoch;	state Exp;
branches;
next	1.268;

1.268
date	2011.04.27.19.55.10;	author jkratoch;	state Exp;
branches;
next	1.267;

1.267
date	2011.04.20.19.42.50;	author jkratoch;	state Exp;
branches;
next	1.266;

1.266
date	2011.04.19.18.04.07;	author tromey;	state Exp;
branches;
next	1.265;

1.265
date	2011.04.09.19.35.11;	author jkratoch;	state Exp;
branches;
next	1.264;

1.264
date	2011.04.04.17.41.07;	author tromey;	state Exp;
branches;
next	1.263;

1.263
date	2011.04.04.14.10.12;	author tromey;	state Exp;
branches;
next	1.262;

1.262
date	2011.03.28.20.21.04;	author jkratoch;	state Exp;
branches
	1.262.2.1;
next	1.261;

1.261
date	2011.03.24.19.39.49;	author tromey;	state Exp;
branches;
next	1.260;

1.260
date	2011.03.23.18.23.55;	author ktietz;	state Exp;
branches;
next	1.259;

1.259
date	2011.02.27.22.11.06;	author msnyder;	state Exp;
branches;
next	1.258;

1.258
date	2011.02.13.09.09.36;	author jkratoch;	state Exp;
branches;
next	1.257;

1.257
date	2011.01.11.21.53.24;	author msnyder;	state Exp;
branches;
next	1.256;

1.256
date	2011.01.05.22.22.53;	author msnyder;	state Exp;
branches;
next	1.255;

1.255
date	2011.01.01.15.33.16;	author brobecke;	state Exp;
branches;
next	1.254;

1.254
date	2010.10.17.18.49.46;	author jkratoch;	state Exp;
branches;
next	1.253;

1.253
date	2010.09.08.17.17.42;	author tromey;	state Exp;
branches;
next	1.252;

1.252
date	2010.09.01.21.50.26;	author tromey;	state Exp;
branches;
next	1.251;

1.251
date	2010.08.19.09.04.13;	author brobecke;	state Exp;
branches;
next	1.250;

1.250
date	2010.08.09.20.13.51;	author swagiaal;	state Exp;
branches;
next	1.249;

1.249
date	2010.08.09.19.42.48;	author swagiaal;	state Exp;
branches;
next	1.248;

1.248
date	2010.08.03.22.35.41;	author devans;	state Exp;
branches;
next	1.247;

1.247
date	2010.07.28.16.23.59;	author tromey;	state Exp;
branches;
next	1.246;

1.246
date	2010.07.23.17.42.13;	author kseitz;	state Exp;
branches;
next	1.245;

1.245
date	2010.07.16.19.23.56;	author swagiaal;	state Exp;
branches;
next	1.244;

1.244
date	2010.07.16.19.00.56;	author swagiaal;	state Exp;
branches;
next	1.243;

1.243
date	2010.07.16.18.39.10;	author swagiaal;	state Exp;
branches;
next	1.242;

1.242
date	2010.07.13.20.52.52;	author tromey;	state Exp;
branches;
next	1.241;

1.241
date	2010.07.13.20.49.26;	author tromey;	state Exp;
branches;
next	1.240;

1.240
date	2010.06.29.16.53.09;	author devans;	state Exp;
branches
	1.240.2.1;
next	1.239;

1.239
date	2010.06.28.20.35.52;	author jkratoch;	state Exp;
branches;
next	1.238;

1.238
date	2010.06.02.22.41.55;	author jkratoch;	state Exp;
branches;
next	1.237;

1.237
date	2010.05.16.23.49.58;	author msnyder;	state Exp;
branches;
next	1.236;

1.236
date	2010.05.06.01.16.15;	author msnyder;	state Exp;
branches;
next	1.235;

1.235
date	2010.04.30.17.43.55;	author tromey;	state Exp;
branches;
next	1.234;

1.234
date	2010.04.29.14.45.38;	author brobecke;	state Exp;
branches;
next	1.233;

1.233
date	2010.04.23.12.08.06;	author cmoller;	state Exp;
branches;
next	1.232;

1.232
date	2010.04.22.23.15.41;	author jkratoch;	state Exp;
branches;
next	1.231;

1.231
date	2010.04.09.15.31.41;	author uweigand;	state Exp;
branches;
next	1.230;

1.230
date	2010.03.26.19.41.50;	author uweigand;	state Exp;
branches;
next	1.229;

1.229
date	2010.03.24.21.24.07;	author tromey;	state Exp;
branches;
next	1.228;

1.228
date	2010.03.24.21.06.31;	author drow;	state Exp;
branches;
next	1.227;

1.227
date	2010.03.15.17.29.36;	author swagiaal;	state Exp;
branches;
next	1.226;

1.226
date	2010.03.10.18.20.07;	author tromey;	state Exp;
branches;
next	1.225;

1.225
date	2010.03.09.18.09.07;	author kseitz;	state Exp;
branches;
next	1.224;

1.224
date	2010.01.26.15.48.25;	author swagiaal;	state Exp;
branches;
next	1.223;

1.223
date	2010.01.14.21.09.04;	author jkratoch;	state Exp;
branches;
next	1.222;

1.222
date	2010.01.06.10.11.04;	author gingold;	state Exp;
branches;
next	1.221;

1.221
date	2010.01.01.07.31.42;	author brobecke;	state Exp;
branches;
next	1.220;

1.220
date	2009.12.28.21.29.53;	author drow;	state Exp;
branches;
next	1.219;

1.219
date	2009.11.18.16.28.42;	author tromey;	state Exp;
branches;
next	1.218;

1.218
date	2009.11.16.18.40.23;	author tromey;	state Exp;
branches;
next	1.217;

1.217
date	2009.11.09.22.02.55;	author brobecke;	state Exp;
branches;
next	1.216;

1.216
date	2009.10.19.09.51.42;	author palves;	state Exp;
branches;
next	1.215;

1.215
date	2009.08.24.22.00.55;	author kseitz;	state Exp;
branches;
next	1.214;

1.214
date	2009.07.23.16.03.13;	author ppluzhnikov;	state Exp;
branches;
next	1.213;

1.213
date	2009.07.02.17.21.07;	author uweigand;	state Exp;
branches;
next	1.212;

1.212
date	2009.06.29.13.18.37;	author uweigand;	state Exp;
branches;
next	1.211;

1.211
date	2009.06.28.00.20.22;	author drow;	state Exp;
branches;
next	1.210;

1.210
date	2009.06.17.18.43.24;	author uweigand;	state Exp;
branches;
next	1.209;

1.209
date	2009.06.11.14.24.24;	author palves;	state Exp;
branches;
next	1.208;

1.208
date	2009.05.23.10.11.42;	author eliz;	state Exp;
branches;
next	1.207;

1.207
date	2009.04.27.11.57.46;	author guitton;	state Exp;
branches;
next	1.206;

1.206
date	2009.03.31.20.21.07;	author tromey;	state Exp;
branches;
next	1.205;

1.205
date	2009.03.13.21.02.58;	author tromey;	state Exp;
branches;
next	1.204;

1.204
date	2009.03.02.06.33.24;	author devans;	state Exp;
branches;
next	1.203;

1.203
date	2009.02.23.03.07.14;	author brobecke;	state Exp;
branches;
next	1.202;

1.202
date	2009.02.21.16.14.49;	author palves;	state Exp;
branches;
next	1.201;

1.201
date	2009.02.06.21.33.58;	author bauermann;	state Exp;
branches;
next	1.200;

1.200
date	2009.01.03.05.57.53;	author brobecke;	state Exp;
branches;
next	1.199;

1.199
date	2008.10.01.17.25.22;	author tromey;	state Exp;
branches
	1.199.2.1;
next	1.198;

1.198
date	2008.10.01.16.56.52;	author tromey;	state Exp;
branches;
next	1.197;

1.197
date	2008.09.30.17.21.28;	author tromey;	state Exp;
branches;
next	1.196;

1.196
date	2008.09.22.14.56.17;	author drow;	state Exp;
branches;
next	1.195;

1.195
date	2008.09.05.11.37.17;	author uweigand;	state Exp;
branches;
next	1.194;

1.194
date	2008.08.21.18.40.34;	author drow;	state Exp;
branches;
next	1.193;

1.193
date	2008.08.20.11.21.44;	author palves;	state Exp;
branches;
next	1.192;

1.192
date	2008.07.21.16.47.10;	author tromey;	state Exp;
branches;
next	1.191;

1.191
date	2008.07.13.16.58.19;	author brobecke;	state Exp;
branches;
next	1.190;

1.190
date	2008.06.11.22.03.49;	author muller;	state Exp;
branches;
next	1.189;

1.189
date	2008.05.27.19.29.51;	author schwab;	state Exp;
branches;
next	1.188;

1.188
date	2008.05.22.17.00.07;	author uweigand;	state Exp;
branches;
next	1.187;

1.187
date	2008.05.22.16.59.01;	author uweigand;	state Exp;
branches;
next	1.186;

1.186
date	2008.05.22.16.58.02;	author uweigand;	state Exp;
branches;
next	1.185;

1.185
date	2008.05.19.18.37.07;	author palves;	state Exp;
branches;
next	1.184;

1.184
date	2008.05.19.15.50.10;	author uweigand;	state Exp;
branches;
next	1.183;

1.183
date	2008.05.19.15.49.14;	author uweigand;	state Exp;
branches;
next	1.182;

1.182
date	2008.05.16.12.58.48;	author uweigand;	state Exp;
branches;
next	1.181;

1.181
date	2008.05.05.14.37.32;	author aristovski;	state Exp;
branches;
next	1.180;

1.180
date	2008.05.04.17.27.01;	author jkratoch;	state Exp;
branches;
next	1.179;

1.179
date	2008.05.03.22.20.13;	author drow;	state Exp;
branches;
next	1.178;

1.178
date	2008.05.03.00.37.34;	author uweigand;	state Exp;
branches;
next	1.177;

1.177
date	2008.04.19.11.39.50;	author kettenis;	state Exp;
branches;
next	1.176;

1.176
date	2008.04.06.08.56.36;	author vprus;	state Exp;
branches;
next	1.175;

1.175
date	2008.04.03.21.39.16;	author brobecke;	state Exp;
branches;
next	1.174;

1.174
date	2008.03.21.15.33.10;	author drow;	state Exp;
branches;
next	1.173;

1.173
date	2008.02.05.22.17.40;	author brobecke;	state Exp;
branches;
next	1.172;

1.172
date	2008.02.01.23.12.23;	author brobecke;	state Exp;
branches;
next	1.171;

1.171
date	2008.01.03.21.30.13;	author bauermann;	state Exp;
branches;
next	1.170;

1.170
date	2008.01.01.22.53.13;	author drow;	state Exp;
branches;
next	1.169;

1.169
date	2007.12.31.18.38.43;	author drow;	state Exp;
branches;
next	1.168;

1.168
date	2007.12.18.16.02.54;	author drow;	state Exp;
branches;
next	1.167;

1.167
date	2007.10.24.13.25.16;	author cseo;	state Exp;
branches;
next	1.166;

1.166
date	2007.10.09.06.59.27;	author muller;	state Exp;
branches;
next	1.165;

1.165
date	2007.09.24.07.40.32;	author vprus;	state Exp;
branches;
next	1.164;

1.164
date	2007.08.29.18.34.46;	author brobecke;	state Exp;
branches;
next	1.163;

1.163
date	2007.08.23.18.08.42;	author brobecke;	state Exp;
branches;
next	1.162;

1.162
date	2007.07.03.12.14.43;	author uweigand;	state Exp;
branches;
next	1.161;

1.161
date	2007.06.18.18.23.08;	author uweigand;	state Exp;
branches;
next	1.160;

1.160
date	2007.06.13.17.59.50;	author uweigand;	state Exp;
branches;
next	1.159;

1.159
date	2007.06.09.14.15.52;	author uweigand;	state Exp;
branches;
next	1.158;

1.158
date	2007.06.05.22.47.50;	author uweigand;	state Exp;
branches;
next	1.157;

1.157
date	2007.04.17.15.07.21;	author schwab;	state Exp;
branches;
next	1.156;

1.156
date	2007.03.28.00.12.15;	author palves;	state Exp;
branches;
next	1.155;

1.155
date	2007.03.13.17.34.22;	author drow;	state Exp;
branches;
next	1.154;

1.154
date	2007.01.21.16.55.49;	author drow;	state Exp;
branches;
next	1.153;

1.153
date	2007.01.21.16.49.40;	author drow;	state Exp;
branches;
next	1.152;

1.152
date	2007.01.09.22.43.08;	author drow;	state Exp;
branches;
next	1.151;

1.151
date	2007.01.09.17.58.59;	author drow;	state Exp;
branches;
next	1.150;

1.150
date	2007.01.04.22.21.28;	author drow;	state Exp;
branches;
next	1.149;

1.149
date	2006.11.28.16.23.32;	author drow;	state Exp;
branches;
next	1.148;

1.148
date	2006.10.17.20.17.44;	author drow;	state Exp;
branches;
next	1.147;

1.147
date	2006.05.11.09.29.52;	author fnf;	state Exp;
branches;
next	1.146;

1.146
date	2005.12.17.22.34.03;	author eliz;	state Exp;
branches
	1.146.2.1
	1.146.8.1;
next	1.145;

1.145
date	2005.03.08.04.34.44;	author brobecke;	state Exp;
branches;
next	1.144;

1.144
date	2005.02.15.15.49.21;	author cagney;	state Exp;
branches;
next	1.143;

1.143
date	2005.02.11.18.13.53;	author cagney;	state Exp;
branches;
next	1.142;

1.142
date	2005.02.11.04.06.06;	author cagney;	state Exp;
branches;
next	1.141;

1.141
date	2004.10.22.20.58.56;	author brobecke;	state Exp;
branches;
next	1.140;

1.140
date	2004.10.02.09.55.15;	author hilfingr;	state Exp;
branches;
next	1.139;

1.139
date	2004.09.20.20.18.39;	author jjohnstn;	state Exp;
branches;
next	1.138;

1.138
date	2004.09.20.18.31.02;	author drow;	state Exp;
branches;
next	1.137;

1.137
date	2004.09.19.22.49.23;	author drow;	state Exp;
branches;
next	1.136;

1.136
date	2004.09.11.10.24.51;	author hilfingr;	state Exp;
branches;
next	1.135;

1.135
date	2004.08.10.21.16.13;	author cagney;	state Exp;
branches;
next	1.134;

1.134
date	2004.07.08.11.18.27;	author bobbybrasko;	state Exp;
branches;
next	1.133;

1.133
date	2004.06.18.21.36.15;	author cagney;	state Exp;
branches;
next	1.132;

1.132
date	2004.06.10.20.05.44;	author bobbybrasko;	state Exp;
branches;
next	1.131;

1.131
date	2004.05.24.16.11.17;	author kevinb;	state Exp;
branches;
next	1.130;

1.130
date	2004.05.20.09.51.33;	author hilfingr;	state Exp;
branches;
next	1.129;

1.129
date	2004.04.08.21.18.13;	author cagney;	state Exp;
branches;
next	1.128;

1.128
date	2004.02.19.19.01.26;	author ezannoni;	state Exp;
branches
	1.128.2.1;
next	1.127;

1.127
date	2004.02.17.15.21.22;	author cagney;	state Exp;
branches;
next	1.126;

1.126
date	2004.02.07.23.13.47;	author ezannoni;	state Exp;
branches;
next	1.125;

1.125
date	2004.01.23.23.03.30;	author carlton;	state Exp;
branches;
next	1.124;

1.124
date	2003.12.17.22.21.02;	author jjohnstn;	state Exp;
branches;
next	1.123;

1.123
date	2003.11.22.16.01.03;	author cagney;	state Exp;
branches;
next	1.122;

1.122
date	2003.11.08.00.13.03;	author cagney;	state Exp;
branches;
next	1.121;

1.121
date	2003.11.04.22.22.31;	author cagney;	state Exp;
branches;
next	1.120;

1.120
date	2003.10.21.22.56.38;	author ezannoni;	state Exp;
branches;
next	1.119;

1.119
date	2003.10.20.14.38.42;	author cagney;	state Exp;
branches;
next	1.118;

1.118
date	2003.09.20.02.39.31;	author cgf;	state Exp;
branches;
next	1.117;

1.117
date	2003.09.20.02.38.39;	author cgf;	state Exp;
branches;
next	1.116;

1.116
date	2003.09.16.18.56.35;	author cagney;	state Exp;
branches;
next	1.115;

1.115
date	2003.09.14.16.32.14;	author cagney;	state Exp;
branches;
next	1.114;

1.114
date	2003.08.08.14.04.02;	author ezannoni;	state Exp;
branches;
next	1.113;

1.113
date	2003.06.12.15.52.08;	author carlton;	state Exp;
branches
	1.113.4.1;
next	1.112;

1.112
date	2003.06.12.15.33.45;	author carlton;	state Exp;
branches;
next	1.111;

1.111
date	2003.06.11.23.29.48;	author carlton;	state Exp;
branches;
next	1.110;

1.110
date	2003.06.11.22.27.14;	author carlton;	state Exp;
branches;
next	1.109;

1.109
date	2003.05.20.01.55.17;	author carlton;	state Exp;
branches;
next	1.108;

1.108
date	2003.05.20.01.26.58;	author carlton;	state Exp;
branches;
next	1.107;

1.107
date	2003.05.20.01.12.47;	author carlton;	state Exp;
branches;
next	1.106;

1.106
date	2003.05.19.02.34.34;	author fedor;	state Exp;
branches;
next	1.105;

1.105
date	2003.05.18.15.29.31;	author carlton;	state Exp;
branches;
next	1.104;

1.104
date	2003.05.15.14.28.57;	author ezannoni;	state Exp;
branches;
next	1.103;

1.103
date	2003.05.14.17.43.19;	author ezannoni;	state Exp;
branches;
next	1.102;

1.102
date	2003.04.29.02.34.24;	author fedor;	state Exp;
branches
	1.102.4.1;
next	1.101;

1.101
date	2003.04.14.19.56.32;	author carlton;	state Exp;
branches
	1.101.2.1;
next	1.100;

1.100
date	2003.04.14.19.55.27;	author carlton;	state Exp;
branches;
next	1.99;

1.99
date	2003.03.04.17.06.21;	author carlton;	state Exp;
branches;
next	1.98;

1.98
date	2003.03.03.18.34.12;	author carlton;	state Exp;
branches;
next	1.97;

1.97
date	2003.03.03.18.01.33;	author carlton;	state Exp;
branches;
next	1.96;

1.96
date	2003.02.27.20.48.03;	author carlton;	state Exp;
branches;
next	1.95;

1.95
date	2003.02.25.21.36.20;	author carlton;	state Exp;
branches;
next	1.94;

1.94
date	2003.02.24.23.40.50;	author carlton;	state Exp;
branches;
next	1.93;

1.93
date	2003.02.24.23.37.02;	author carlton;	state Exp;
branches;
next	1.92;

1.92
date	2003.02.21.15.24.18;	author drow;	state Exp;
branches;
next	1.91;

1.91
date	2003.02.21.03.00.27;	author fedor;	state Exp;
branches;
next	1.90;

1.90
date	2003.02.20.22.07.38;	author carlton;	state Exp;
branches;
next	1.89;

1.89
date	2003.02.20.17.17.25;	author carlton;	state Exp;
branches;
next	1.88;

1.88
date	2003.02.20.00.01.06;	author carlton;	state Exp;
branches;
next	1.87;

1.87
date	2003.02.04.18.07.01;	author drow;	state Exp;
branches;
next	1.86;

1.86
date	2003.02.01.20.51.05;	author cagney;	state Exp;
branches;
next	1.85;

1.85
date	2003.01.13.21.59.53;	author drow;	state Exp;
branches;
next	1.84;

1.84
date	2003.01.02.14.27.26;	author cagney;	state Exp;
branches;
next	1.83;

1.83
date	2002.12.23.16.43.18;	author carlton;	state Exp;
branches;
next	1.82;

1.82
date	2002.12.17.18.34.06;	author carlton;	state Exp;
branches;
next	1.81;

1.81
date	2002.12.05.21.26.57;	author carlton;	state Exp;
branches;
next	1.80;

1.80
date	2002.12.05.21.07.49;	author carlton;	state Exp;
branches;
next	1.79;

1.79
date	2002.12.04.22.54.59;	author carlton;	state Exp;
branches;
next	1.78;

1.78
date	2002.11.06.23.27.58;	author ezannoni;	state Exp;
branches;
next	1.77;

1.77
date	2002.11.05.20.33.01;	author carlton;	state Exp;
branches;
next	1.76;

1.76
date	2002.11.05.16.59.57;	author carlton;	state Exp;
branches;
next	1.75;

1.75
date	2002.10.28.17.05.56;	author carlton;	state Exp;
branches;
next	1.74;

1.74
date	2002.10.24.21.02.53;	author ezannoni;	state Exp;
branches;
next	1.73;

1.73
date	2002.10.23.23.36.16;	author carlton;	state Exp;
branches;
next	1.72;

1.72
date	2002.10.23.20.09.07;	author ezannoni;	state Exp;
branches;
next	1.71;

1.71
date	2002.10.23.18.16.44;	author ezannoni;	state Exp;
branches;
next	1.70;

1.70
date	2002.09.20.14.58.58;	author fnasser;	state Exp;
branches
	1.70.2.1
	1.70.4.1;
next	1.69;

1.69
date	2002.08.30.03.24.00;	author jimb;	state Exp;
branches;
next	1.68;

1.68
date	2002.08.01.17.18.33;	author cagney;	state Exp;
branches;
next	1.67;

1.67
date	2002.07.30.15.42.07;	author drow;	state Exp;
branches;
next	1.66;

1.66
date	2002.07.29.22.55.26;	author cagney;	state Exp;
branches;
next	1.65;

1.65
date	2002.07.11.20.46.19;	author drow;	state Exp;
branches;
next	1.64;

1.64
date	2002.07.04.15.22.42;	author drow;	state Exp;
branches;
next	1.63;

1.63
date	2002.05.12.04.20.06;	author cagney;	state Exp;
branches
	1.63.4.1;
next	1.62;

1.62
date	2002.04.06.18.28.20;	author cagney;	state Exp;
branches;
next	1.61;

1.61
date	2002.04.05.22.04.41;	author jimb;	state Exp;
branches;
next	1.60;

1.60
date	2002.04.05.16.42.04;	author brobecke;	state Exp;
branches;
next	1.59;

1.59
date	2002.03.27.23.10.23;	author jimb;	state Exp;
branches;
next	1.58;

1.58
date	2002.03.22.18.57.08;	author drow;	state Exp;
branches;
next	1.57;

1.57
date	2002.02.27.18.22.24;	author schauer;	state Exp;
branches;
next	1.56;

1.56
date	2002.02.24.01.44.00;	author cagney;	state Exp;
branches;
next	1.55;

1.55
date	2002.02.22.00.17.13;	author fnf;	state Exp;
branches;
next	1.54;

1.54
date	2002.02.11.03.21.53;	author drow;	state Exp;
branches;
next	1.53;

1.53
date	2002.01.31.05.03.31;	author drow;	state Exp;
branches;
next	1.52;

1.52
date	2002.01.17.22.15.17;	author cagney;	state Exp;
branches;
next	1.51;

1.51
date	2001.12.21.22.32.37;	author tromey;	state Exp;
branches;
next	1.50;

1.50
date	2001.12.03.19.30.39;	author msnyder;	state Exp;
branches;
next	1.49;

1.49
date	2001.11.27.00.03.22;	author jimb;	state Exp;
branches;
next	1.48;

1.48
date	2001.11.13.16.42.50;	author jimb;	state Exp;
branches;
next	1.47;

1.47
date	2001.11.05.23.27.31;	author msnyder;	state Exp;
branches;
next	1.46;

1.46
date	2001.10.17.07.12.57;	author jsm;	state Exp;
branches;
next	1.45;

1.45
date	2001.10.16.03.23.35;	author ezannoni;	state Exp;
branches;
next	1.44;

1.44
date	2001.10.12.23.51.29;	author drow;	state Exp;
branches;
next	1.43;

1.43
date	2001.10.12.03.38.12;	author tromey;	state Exp;
branches;
next	1.42;

1.42
date	2001.07.07.17.19.50;	author cagney;	state Exp;
branches;
next	1.41;

1.41
date	2001.06.13.18.30.07;	author cagney;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2001.06.12.15.03.04;	author cagney;	state Exp;
branches;
next	1.39;

1.39
date	2001.06.11.16.05.24;	author eliz;	state Exp;
branches;
next	1.38;

1.38
date	2001.05.14.18.49.54;	author kettenis;	state Exp;
branches;
next	1.37;

1.37
date	2001.05.11.17.48.31;	author msnyder;	state Exp;
branches;
next	1.36;

1.36
date	2001.05.06.06.07.20;	author eliz;	state Exp;
branches;
next	1.35;

1.35
date	2001.04.27.00.19.09;	author jimb;	state Exp;
branches;
next	1.34;

1.34
date	2001.04.01.19.50.50;	author dberlin;	state Exp;
branches;
next	1.33;

1.33
date	2001.03.27.01.17.47;	author kevinb;	state Exp;
branches;
next	1.32;

1.32
date	2001.03.06.08.21.17;	author kevinb;	state Exp;
branches;
next	1.31;

1.31
date	2001.02.27.21.57.09;	author taylor;	state Exp;
branches;
next	1.30;

1.30
date	2001.02.25.04.45.11;	author kevinb;	state Exp;
branches;
next	1.29;

1.29
date	2001.02.20.00.09.01;	author ezannoni;	state Exp;
branches;
next	1.28;

1.28
date	2001.01.30.02.49.36;	author chastain;	state Exp;
branches;
next	1.27;

1.27
date	2001.01.19.08.01.46;	author cagney;	state Exp;
branches;
next	1.26;

1.26
date	2001.01.18.23.38.26;	author jimb;	state Exp;
branches;
next	1.25;

1.25
date	2000.12.15.01.01.50;	author kevinb;	state Exp;
branches;
next	1.24;

1.24
date	2000.12.01.00.41.27;	author fnasser;	state Exp;
branches;
next	1.23;

1.23
date	2000.11.19.17.27.38;	author jimb;	state Exp;
branches;
next	1.22;

1.22
date	2000.11.10.23.02.56;	author fnasser;	state Exp;
branches;
next	1.21;

1.21
date	2000.11.02.03.18.49;	author kevinb;	state Exp;
branches;
next	1.20;

1.20
date	2000.10.30.21.50.58;	author jtc;	state Exp;
branches;
next	1.19;

1.19
date	2000.10.28.22.15.09;	author kevinb;	state Exp;
branches;
next	1.18;

1.18
date	2000.10.27.15.02.42;	author davea;	state Exp;
branches;
next	1.17;

1.17
date	2000.10.12.19.34.27;	author ezannoni;	state Exp;
branches;
next	1.16;

1.16
date	2000.10.12.16.53.06;	author ezannoni;	state Exp;
branches;
next	1.15;

1.15
date	2000.09.04.08.29.25;	author muller;	state Exp;
branches;
next	1.14;

1.14
date	2000.09.01.18.37.05;	author kevinb;	state Exp;
branches;
next	1.13;

1.13
date	2000.08.25.20.51.19;	author taylor;	state Exp;
branches;
next	1.12;

1.12
date	2000.08.11.01.02.35;	author guo;	state Exp;
branches;
next	1.11;

1.11
date	2000.08.04.23.13.50;	author kevinb;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.30.01.48.27;	author kevinb;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.11.07.56.23;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.14.00.59.07;	author kevinb;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.05.20.49.53;	author dberlin;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.29.13.18.15;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.28.01.12.30;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.03.13.45.17;	author ezannoni;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.04.02.08.52;	author hjl;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.08.04.39.02;	author kingdon;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.06;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.288.2.1
date	2012.01.06.04.43.31;	author brobecke;	state Exp;
branches;
next	;

1.262.2.1
date	2011.04.20.20.10.29;	author jkratoch;	state Exp;
branches;
next	1.262.2.2;

1.262.2.2
date	2011.05.06.13.53.15;	author jkratoch;	state Exp;
branches;
next	1.262.2.3;

1.262.2.3
date	2011.05.06.15.13.37;	author jkratoch;	state Exp;
branches;
next	1.262.2.4;

1.262.2.4
date	2011.06.10.21.56.04;	author jkratoch;	state Exp;
branches;
next	1.262.2.5;

1.262.2.5
date	2011.07.02.19.33.09;	author jkratoch;	state Exp;
branches;
next	1.262.2.6;

1.262.2.6
date	2011.07.02.20.03.43;	author jkratoch;	state Exp;
branches;
next	;

1.240.2.1
date	2010.08.19.09.12.33;	author brobecke;	state Exp;
branches;
next	;

1.199.2.1
date	2008.11.21.02.31.58;	author shebs;	state Exp;
branches;
next	;

1.146.2.1
date	2006.05.03.16.30.56;	author pbrook;	state Exp;
branches;
next	;

1.146.8.1
date	2006.09.28.20.18.16;	author drow;	state Exp;
branches;
next	;

1.128.2.1
date	2004.09.16.17.01.23;	author drow;	state Exp;
branches;
next	1.128.2.2;

1.128.2.2
date	2004.09.21.20.44.17;	author drow;	state Exp;
branches;
next	;

1.113.4.1
date	2003.08.08.14.06.26;	author ezannoni;	state Exp;
branches;
next	;

1.102.4.1
date	2003.06.03.20.54.40;	author cagney;	state Exp;
branches;
next	;

1.101.2.1
date	2003.05.04.11.37.45;	author kettenis;	state Exp;
branches;
next	1.101.2.2;

1.101.2.2
date	2003.05.18.09.44.24;	author kettenis;	state Exp;
branches;
next	;

1.70.2.1
date	2002.09.20.18.52.16;	author carlton;	state Exp;
branches;
next	1.70.2.2;

1.70.2.2
date	2002.09.24.00.04.51;	author carlton;	state Exp;
branches;
next	1.70.2.3;

1.70.2.3
date	2002.09.27.00.18.18;	author carlton;	state Exp;
branches;
next	1.70.2.4;

1.70.2.4
date	2002.09.30.22.57.22;	author carlton;	state Exp;
branches;
next	1.70.2.5;

1.70.2.5
date	2002.10.08.00.12.23;	author carlton;	state Exp;
branches;
next	1.70.2.6;

1.70.2.6
date	2002.10.11.21.56.48;	author carlton;	state Exp;
branches;
next	1.70.2.7;

1.70.2.7
date	2002.10.15.00.20.32;	author carlton;	state Exp;
branches;
next	1.70.2.8;

1.70.2.8
date	2002.10.15.23.59.21;	author carlton;	state Exp;
branches;
next	1.70.2.9;

1.70.2.9
date	2002.10.18.23.42.58;	author carlton;	state Exp;
branches;
next	1.70.2.10;

1.70.2.10
date	2002.10.22.23.22.56;	author carlton;	state Exp;
branches;
next	1.70.2.11;

1.70.2.11
date	2002.10.25.23.49.55;	author carlton;	state Exp;
branches;
next	1.70.2.12;

1.70.2.12
date	2002.10.29.01.07.47;	author carlton;	state Exp;
branches;
next	1.70.2.13;

1.70.2.13
date	2002.11.07.00.59.50;	author carlton;	state Exp;
branches;
next	1.70.2.14;

1.70.2.14
date	2002.11.14.00.07.54;	author carlton;	state Exp;
branches;
next	1.70.2.15;

1.70.2.15
date	2002.11.15.01.10.42;	author carlton;	state Exp;
branches;
next	1.70.2.16;

1.70.2.16
date	2002.11.15.19.18.59;	author carlton;	state Exp;
branches;
next	1.70.2.17;

1.70.2.17
date	2002.11.16.00.16.57;	author carlton;	state Exp;
branches;
next	1.70.2.18;

1.70.2.18
date	2002.11.20.01.09.53;	author carlton;	state Exp;
branches;
next	1.70.2.19;

1.70.2.19
date	2002.11.23.00.42.54;	author carlton;	state Exp;
branches;
next	1.70.2.20;

1.70.2.20
date	2002.11.28.00.53.24;	author carlton;	state Exp;
branches;
next	1.70.2.21;

1.70.2.21
date	2002.12.18.00.45.42;	author carlton;	state Exp;
branches;
next	1.70.2.22;

1.70.2.22
date	2002.12.19.01.03.06;	author carlton;	state Exp;
branches;
next	1.70.2.23;

1.70.2.23
date	2002.12.21.00.17.44;	author carlton;	state Exp;
branches;
next	1.70.2.24;

1.70.2.24
date	2002.12.24.01.23.49;	author carlton;	state Exp;
branches;
next	1.70.2.25;

1.70.2.25
date	2003.01.07.01.28.23;	author carlton;	state Exp;
branches;
next	1.70.2.26;

1.70.2.26
date	2003.01.21.01.02.30;	author carlton;	state Exp;
branches;
next	1.70.2.27;

1.70.2.27
date	2003.01.29.01.23.19;	author carlton;	state Exp;
branches;
next	1.70.2.28;

1.70.2.28
date	2003.02.01.01.17.22;	author carlton;	state Exp;
branches;
next	1.70.2.29;

1.70.2.29
date	2003.02.07.19.17.53;	author carlton;	state Exp;
branches;
next	1.70.2.30;

1.70.2.30
date	2003.02.12.00.38.07;	author carlton;	state Exp;
branches;
next	1.70.2.31;

1.70.2.31
date	2003.02.12.23.37.09;	author carlton;	state Exp;
branches;
next	1.70.2.32;

1.70.2.32
date	2003.02.22.01.33.13;	author carlton;	state Exp;
branches;
next	1.70.2.33;

1.70.2.33
date	2003.02.28.01.04.25;	author carlton;	state Exp;
branches;
next	1.70.2.34;

1.70.2.34
date	2003.03.06.00.56.32;	author carlton;	state Exp;
branches;
next	1.70.2.35;

1.70.2.35
date	2003.03.07.22.52.55;	author carlton;	state Exp;
branches;
next	1.70.2.36;

1.70.2.36
date	2003.04.16.19.56.56;	author carlton;	state Exp;
branches;
next	1.70.2.37;

1.70.2.37
date	2003.05.01.00.46.52;	author carlton;	state Exp;
branches;
next	1.70.2.38;

1.70.2.38
date	2003.05.23.18.40.45;	author carlton;	state Exp;
branches;
next	1.70.2.39;

1.70.2.39
date	2003.05.23.22.28.54;	author carlton;	state Exp;
branches;
next	1.70.2.40;

1.70.2.40
date	2003.06.27.21.50.11;	author carlton;	state Exp;
branches;
next	1.70.2.41;

1.70.2.41
date	2003.09.17.21.28.33;	author carlton;	state Exp;
branches;
next	1.70.2.42;

1.70.2.42
date	2003.09.30.18.16.07;	author carlton;	state Exp;
branches;
next	1.70.2.43;

1.70.2.43
date	2003.11.11.23.50.58;	author carlton;	state Exp;
branches;
next	1.70.2.44;

1.70.2.44
date	2003.12.16.00.00.50;	author carlton;	state Exp;
branches;
next	1.70.2.45;

1.70.2.45
date	2004.01.26.19.11.33;	author carlton;	state Exp;
branches;
next	;

1.70.4.1
date	2002.10.11.16.20.45;	author carlton;	state Exp;
branches;
next	1.70.4.2;

1.70.4.2
date	2002.10.22.19.59.36;	author carlton;	state Exp;
branches;
next	1.70.4.3;

1.70.4.3
date	2002.10.26.17.12.09;	author drow;	state Exp;
branches;
next	1.70.4.4;

1.70.4.4
date	2002.11.22.17.15.55;	author carlton;	state Exp;
branches;
next	1.70.4.5;

1.70.4.5
date	2003.12.14.20.27.32;	author drow;	state Exp;
branches;
next	1.70.4.6;

1.70.4.6
date	2003.12.20.18.16.49;	author drow;	state Exp;
branches;
next	1.70.4.7;

1.70.4.7
date	2004.02.09.19.43.48;	author drow;	state Exp;
branches;
next	;

1.63.4.1
date	2002.07.22.21.47.03;	author kseitz;	state Exp;
branches;
next	1.63.4.2;

1.63.4.2
date	2002.08.09.18.34.27;	author kseitz;	state Exp;
branches;
next	1.63.4.3;

1.63.4.3
date	2002.10.01.00.46.14;	author kseitz;	state Exp;
branches;
next	1.63.4.4;

1.63.4.4
date	2002.11.04.00.17.33;	author ezannoni;	state Exp;
branches;
next	1.63.4.5;

1.63.4.5
date	2002.11.05.20.31.21;	author ezannoni;	state Exp;
branches;
next	;

1.41.2.1
date	2001.07.06.19.17.03;	author dberlin;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.06;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.25.32;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.05.05.14.42.59;	author shebs;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.05.25.18.03.31;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.06.07.19.17.54;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.06.28.16.01.02;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.07.07.20.10.33;	author jsm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	99.08.02.23.46.10;	author jsm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	99.09.08.23.59.35;	author shebs;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	99.09.22.03.25.06;	author jsm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	99.10.19.02.46.39;	author jsm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2000.02.01.03.19.07;	author jsm;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2000.02.03.04.14.36;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.371
log
@move the demangled_names_hash into the per-BFD

This moves the demangled_names_hash from the objfile into the per-BFD
object.  This is part of the objfile splitting project.

The demangled names hash is independent of the program space.  And, it
is needed by the symbol tables.  Both of these things indicate that it
must be pushed into the per-BFD object, which this patch does.

Built and regtested on x86-64 Fedora 18.

	* objfiles.c (free_objfile_per_bfd_storage): Delete the
	demangled_names_hash.
	(free_objfile): Don't delete the demangled_names_hash.
	* objfiles.h (struct objfile_per_bfd_storage)
	<demangled_names_hash>: New field.
	(struct objfile) <demangled_names_hash>: Move to
	objfile_per_bfd_storage.
	* symfile.c (reread_symbols): Don't delete the
	demangled_names_hash.
	* symtab.c (create_demangled_names_hash): Update.
	(symbol_set_names): Update.
@
text
@/* Symbol table lookup for the GNU debugger, GDB.

   Copyright (C) 1986-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "symtab.h"
#include "gdbtypes.h"
#include "gdbcore.h"
#include "frame.h"
#include "target.h"
#include "value.h"
#include "symfile.h"
#include "objfiles.h"
#include "gdbcmd.h"
#include "gdb_regex.h"
#include "expression.h"
#include "language.h"
#include "demangle.h"
#include "inferior.h"
#include "source.h"
#include "filenames.h"		/* for FILENAME_CMP */
#include "objc-lang.h"
#include "d-lang.h"
#include "ada-lang.h"
#include "go-lang.h"
#include "p-lang.h"
#include "addrmap.h"
#include "cli/cli-utils.h"

#include "hashtab.h"

#include "gdb_obstack.h"
#include "block.h"
#include "dictionary.h"

#include <sys/types.h>
#include <fcntl.h>
#include "gdb_string.h"
#include "gdb_stat.h"
#include <ctype.h>
#include "cp-abi.h"
#include "cp-support.h"
#include "observer.h"
#include "gdb_assert.h"
#include "solist.h"
#include "macrotab.h"
#include "macroscope.h"

#include "psymtab.h"
#include "parser-defs.h"

/* Prototypes for local functions */

static void rbreak_command (char *, int);

static void types_info (char *, int);

static void functions_info (char *, int);

static void variables_info (char *, int);

static void sources_info (char *, int);

static int find_line_common (struct linetable *, int, int *, int);

static struct symbol *lookup_symbol_aux (const char *name,
					 const struct block *block,
					 const domain_enum domain,
					 enum language language,
					 struct field_of_this_result *is_a_field_of_this);

static
struct symbol *lookup_symbol_aux_local (const char *name,
					const struct block *block,
					const domain_enum domain,
					enum language language);

static
struct symbol *lookup_symbol_aux_symtabs (int block_index,
					  const char *name,
					  const domain_enum domain);

static
struct symbol *lookup_symbol_aux_quick (struct objfile *objfile,
					int block_index,
					const char *name,
					const domain_enum domain);

void _initialize_symtab (void);

/* */

/* When non-zero, print debugging messages related to symtab creation.  */
int symtab_create_debug = 0;

/* Non-zero if a file may be known by two different basenames.
   This is the uncommon case, and significantly slows down gdb.
   Default set to "off" to not slow down the common case.  */
int basenames_may_differ = 0;

/* Allow the user to configure the debugger behavior with respect
   to multiple-choice menus when more than one symbol matches during
   a symbol lookup.  */

const char multiple_symbols_ask[] = "ask";
const char multiple_symbols_all[] = "all";
const char multiple_symbols_cancel[] = "cancel";
static const char *const multiple_symbols_modes[] =
{
  multiple_symbols_ask,
  multiple_symbols_all,
  multiple_symbols_cancel,
  NULL
};
static const char *multiple_symbols_mode = multiple_symbols_all;

/* Read-only accessor to AUTO_SELECT_MODE.  */

const char *
multiple_symbols_select_mode (void)
{
  return multiple_symbols_mode;
}

/* Block in which the most recently searched-for symbol was found.
   Might be better to make this a parameter to lookup_symbol and
   value_of_this.  */

const struct block *block_found;

/* Return the name of a domain_enum.  */

const char *
domain_name (domain_enum e)
{
  switch (e)
    {
    case UNDEF_DOMAIN: return "UNDEF_DOMAIN";
    case VAR_DOMAIN: return "VAR_DOMAIN";
    case STRUCT_DOMAIN: return "STRUCT_DOMAIN";
    case LABEL_DOMAIN: return "LABEL_DOMAIN";
    case COMMON_BLOCK_DOMAIN: return "COMMON_BLOCK_DOMAIN";
    default: gdb_assert_not_reached ("bad domain_enum");
    }
}

/* Return the name of a search_domain .  */

const char *
search_domain_name (enum search_domain e)
{
  switch (e)
    {
    case VARIABLES_DOMAIN: return "VARIABLES_DOMAIN";
    case FUNCTIONS_DOMAIN: return "FUNCTIONS_DOMAIN";
    case TYPES_DOMAIN: return "TYPES_DOMAIN";
    case ALL_DOMAIN: return "ALL_DOMAIN";
    default: gdb_assert_not_reached ("bad search_domain");
    }
}

/* See whether FILENAME matches SEARCH_NAME using the rule that we
   advertise to the user.  (The manual's description of linespecs
   describes what we advertise).  Returns true if they match, false
   otherwise.  */

int
compare_filenames_for_search (const char *filename, const char *search_name)
{
  int len = strlen (filename);
  size_t search_len = strlen (search_name);

  if (len < search_len)
    return 0;

  /* The tail of FILENAME must match.  */
  if (FILENAME_CMP (filename + len - search_len, search_name) != 0)
    return 0;

  /* Either the names must completely match, or the character
     preceding the trailing SEARCH_NAME segment of FILENAME must be a
     directory separator.

     The check !IS_ABSOLUTE_PATH ensures SEARCH_NAME "/dir/file.c"
     cannot match FILENAME "/path//dir/file.c" - as user has requested
     absolute path.  The sama applies for "c:\file.c" possibly
     incorrectly hypothetically matching "d:\dir\c:\file.c".

     The HAS_DRIVE_SPEC purpose is to make FILENAME "c:file.c"
     compatible with SEARCH_NAME "file.c".  In such case a compiler had
     to put the "c:file.c" name into debug info.  Such compatibility
     works only on GDB built for DOS host.  */
  return (len == search_len
	  || (!IS_ABSOLUTE_PATH (search_name)
	      && IS_DIR_SEPARATOR (filename[len - search_len - 1]))
	  || (HAS_DRIVE_SPEC (filename)
	      && STRIP_DRIVE_SPEC (filename) == &filename[len - search_len]));
}

/* Check for a symtab of a specific name by searching some symtabs.
   This is a helper function for callbacks of iterate_over_symtabs.

   If NAME is not absolute, then REAL_PATH is NULL
   If NAME is absolute, then REAL_PATH is the gdb_realpath form of NAME.

   The return value, NAME, REAL_PATH, CALLBACK, and DATA
   are identical to the `map_symtabs_matching_filename' method of
   quick_symbol_functions.

   FIRST and AFTER_LAST indicate the range of symtabs to search.
   AFTER_LAST is one past the last symtab to search; NULL means to
   search until the end of the list.  */

int
iterate_over_some_symtabs (const char *name,
			   const char *real_path,
			   int (*callback) (struct symtab *symtab,
					    void *data),
			   void *data,
			   struct symtab *first,
			   struct symtab *after_last)
{
  struct symtab *s = NULL;
  const char* base_name = lbasename (name);

  for (s = first; s != NULL && s != after_last; s = s->next)
    {
      if (compare_filenames_for_search (s->filename, name))
	{
	  if (callback (s, data))
	    return 1;
	  continue;
	}

      /* Before we invoke realpath, which can get expensive when many
	 files are involved, do a quick comparison of the basenames.  */
      if (! basenames_may_differ
	  && FILENAME_CMP (base_name, lbasename (s->filename)) != 0)
	continue;

      if (compare_filenames_for_search (symtab_to_fullname (s), name))
	{
	  if (callback (s, data))
	    return 1;
	  continue;
	}

      /* If the user gave us an absolute path, try to find the file in
	 this symtab and use its absolute path.  */
      if (real_path != NULL)
	{
	  const char *fullname = symtab_to_fullname (s);

	  gdb_assert (IS_ABSOLUTE_PATH (real_path));
	  gdb_assert (IS_ABSOLUTE_PATH (name));
	  if (FILENAME_CMP (real_path, fullname) == 0)
	    {
	      if (callback (s, data))
		return 1;
	      continue;
	    }
	}
    }

  return 0;
}

/* Check for a symtab of a specific name; first in symtabs, then in
   psymtabs.  *If* there is no '/' in the name, a match after a '/'
   in the symtab filename will also work.

   Calls CALLBACK with each symtab that is found and with the supplied
   DATA.  If CALLBACK returns true, the search stops.  */

void
iterate_over_symtabs (const char *name,
		      int (*callback) (struct symtab *symtab,
				       void *data),
		      void *data)
{
  struct objfile *objfile;
  char *real_path = NULL;
  struct cleanup *cleanups = make_cleanup (null_cleanup, NULL);

  /* Here we are interested in canonicalizing an absolute path, not
     absolutizing a relative path.  */
  if (IS_ABSOLUTE_PATH (name))
    {
      real_path = gdb_realpath (name);
      make_cleanup (xfree, real_path);
      gdb_assert (IS_ABSOLUTE_PATH (real_path));
    }

  ALL_OBJFILES (objfile)
  {
    if (iterate_over_some_symtabs (name, real_path, callback, data,
				   objfile->symtabs, NULL))
      {
	do_cleanups (cleanups);
	return;
      }
  }

  /* Same search rules as above apply here, but now we look thru the
     psymtabs.  */

  ALL_OBJFILES (objfile)
  {
    if (objfile->sf
	&& objfile->sf->qf->map_symtabs_matching_filename (objfile,
							   name,
							   real_path,
							   callback,
							   data))
      {
	do_cleanups (cleanups);
	return;
      }
  }

  do_cleanups (cleanups);
}

/* The callback function used by lookup_symtab.  */

static int
lookup_symtab_callback (struct symtab *symtab, void *data)
{
  struct symtab **result_ptr = data;

  *result_ptr = symtab;
  return 1;
}

/* A wrapper for iterate_over_symtabs that returns the first matching
   symtab, or NULL.  */

struct symtab *
lookup_symtab (const char *name)
{
  struct symtab *result = NULL;

  iterate_over_symtabs (name, lookup_symtab_callback, &result);
  return result;
}


/* Mangle a GDB method stub type.  This actually reassembles the pieces of the
   full method name, which consist of the class name (from T), the unadorned
   method name from METHOD_ID, and the signature for the specific overload,
   specified by SIGNATURE_ID.  Note that this function is g++ specific.  */

char *
gdb_mangle_name (struct type *type, int method_id, int signature_id)
{
  int mangled_name_len;
  char *mangled_name;
  struct fn_field *f = TYPE_FN_FIELDLIST1 (type, method_id);
  struct fn_field *method = &f[signature_id];
  const char *field_name = TYPE_FN_FIELDLIST_NAME (type, method_id);
  const char *physname = TYPE_FN_FIELD_PHYSNAME (f, signature_id);
  const char *newname = type_name_no_tag (type);

  /* Does the form of physname indicate that it is the full mangled name
     of a constructor (not just the args)?  */
  int is_full_physname_constructor;

  int is_constructor;
  int is_destructor = is_destructor_name (physname);
  /* Need a new type prefix.  */
  char *const_prefix = method->is_const ? "C" : "";
  char *volatile_prefix = method->is_volatile ? "V" : "";
  char buf[20];
  int len = (newname == NULL ? 0 : strlen (newname));

  /* Nothing to do if physname already contains a fully mangled v3 abi name
     or an operator name.  */
  if ((physname[0] == '_' && physname[1] == 'Z')
      || is_operator_name (field_name))
    return xstrdup (physname);

  is_full_physname_constructor = is_constructor_name (physname);

  is_constructor = is_full_physname_constructor 
    || (newname && strcmp (field_name, newname) == 0);

  if (!is_destructor)
    is_destructor = (strncmp (physname, "__dt", 4) == 0);

  if (is_destructor || is_full_physname_constructor)
    {
      mangled_name = (char *) xmalloc (strlen (physname) + 1);
      strcpy (mangled_name, physname);
      return mangled_name;
    }

  if (len == 0)
    {
      xsnprintf (buf, sizeof (buf), "__%s%s", const_prefix, volatile_prefix);
    }
  else if (physname[0] == 't' || physname[0] == 'Q')
    {
      /* The physname for template and qualified methods already includes
         the class name.  */
      xsnprintf (buf, sizeof (buf), "__%s%s", const_prefix, volatile_prefix);
      newname = NULL;
      len = 0;
    }
  else
    {
      xsnprintf (buf, sizeof (buf), "__%s%s%d", const_prefix,
		 volatile_prefix, len);
    }
  mangled_name_len = ((is_constructor ? 0 : strlen (field_name))
		      + strlen (buf) + len + strlen (physname) + 1);

  mangled_name = (char *) xmalloc (mangled_name_len);
  if (is_constructor)
    mangled_name[0] = '\0';
  else
    strcpy (mangled_name, field_name);

  strcat (mangled_name, buf);
  /* If the class doesn't have a name, i.e. newname NULL, then we just
     mangle it using 0 for the length of the class.  Thus it gets mangled
     as something starting with `::' rather than `classname::'.  */
  if (newname != NULL)
    strcat (mangled_name, newname);

  strcat (mangled_name, physname);
  return (mangled_name);
}

/* Initialize the cplus_specific structure.  'cplus_specific' should
   only be allocated for use with cplus symbols.  */

static void
symbol_init_cplus_specific (struct general_symbol_info *gsymbol,
			    struct obstack *obstack)
{
  /* A language_specific structure should not have been previously
     initialized.  */
  gdb_assert (gsymbol->language_specific.cplus_specific == NULL);
  gdb_assert (obstack != NULL);

  gsymbol->language_specific.cplus_specific =
    OBSTACK_ZALLOC (obstack, struct cplus_specific);
}

/* Set the demangled name of GSYMBOL to NAME.  NAME must be already
   correctly allocated.  For C++ symbols a cplus_specific struct is
   allocated so OBJFILE must not be NULL.  If this is a non C++ symbol
   OBJFILE can be NULL.  */

void
symbol_set_demangled_name (struct general_symbol_info *gsymbol,
                           const char *name,
                           struct obstack *obstack)
{
  if (gsymbol->language == language_cplus)
    {
      if (gsymbol->language_specific.cplus_specific == NULL)
	symbol_init_cplus_specific (gsymbol, obstack);

      gsymbol->language_specific.cplus_specific->demangled_name = name;
    }
  else if (gsymbol->language == language_ada)
    {
      if (name == NULL)
	{
	  gsymbol->ada_mangled = 0;
	  gsymbol->language_specific.obstack = obstack;
	}
      else
	{
	  gsymbol->ada_mangled = 1;
	  gsymbol->language_specific.mangled_lang.demangled_name = name;
	}
    }
  else
    gsymbol->language_specific.mangled_lang.demangled_name = name;
}

/* Return the demangled name of GSYMBOL.  */

const char *
symbol_get_demangled_name (const struct general_symbol_info *gsymbol)
{
  if (gsymbol->language == language_cplus)
    {
      if (gsymbol->language_specific.cplus_specific != NULL)
	return gsymbol->language_specific.cplus_specific->demangled_name;
      else
	return NULL;
    }
  else if (gsymbol->language == language_ada)
    {
      if (!gsymbol->ada_mangled)
	return NULL;
      /* Fall through.  */
    }

  return gsymbol->language_specific.mangled_lang.demangled_name;
}


/* Initialize the language dependent portion of a symbol
   depending upon the language for the symbol.  */

void
symbol_set_language (struct general_symbol_info *gsymbol,
                     enum language language,
		     struct obstack *obstack)
{
  gsymbol->language = language;
  if (gsymbol->language == language_d
      || gsymbol->language == language_go
      || gsymbol->language == language_java
      || gsymbol->language == language_objc
      || gsymbol->language == language_fortran)
    {
      symbol_set_demangled_name (gsymbol, NULL, obstack);
    }
  else if (gsymbol->language == language_ada)
    {
      gdb_assert (gsymbol->ada_mangled == 0);
      gsymbol->language_specific.obstack = obstack;
    }
  else if (gsymbol->language == language_cplus)
    gsymbol->language_specific.cplus_specific = NULL;
  else
    {
      memset (&gsymbol->language_specific, 0,
	      sizeof (gsymbol->language_specific));
    }
}

/* Functions to initialize a symbol's mangled name.  */

/* Objects of this type are stored in the demangled name hash table.  */
struct demangled_name_entry
{
  const char *mangled;
  char demangled[1];
};

/* Hash function for the demangled name hash.  */

static hashval_t
hash_demangled_name_entry (const void *data)
{
  const struct demangled_name_entry *e = data;

  return htab_hash_string (e->mangled);
}

/* Equality function for the demangled name hash.  */

static int
eq_demangled_name_entry (const void *a, const void *b)
{
  const struct demangled_name_entry *da = a;
  const struct demangled_name_entry *db = b;

  return strcmp (da->mangled, db->mangled) == 0;
}

/* Create the hash table used for demangled names.  Each hash entry is
   a pair of strings; one for the mangled name and one for the demangled
   name.  The entry is hashed via just the mangled name.  */

static void
create_demangled_names_hash (struct objfile *objfile)
{
  /* Choose 256 as the starting size of the hash table, somewhat arbitrarily.
     The hash table code will round this up to the next prime number.
     Choosing a much larger table size wastes memory, and saves only about
     1% in symbol reading.  */

  objfile->per_bfd->demangled_names_hash = htab_create_alloc
    (256, hash_demangled_name_entry, eq_demangled_name_entry,
     NULL, xcalloc, xfree);
}

/* Try to determine the demangled name for a symbol, based on the
   language of that symbol.  If the language is set to language_auto,
   it will attempt to find any demangling algorithm that works and
   then set the language appropriately.  The returned name is allocated
   by the demangler and should be xfree'd.  */

static char *
symbol_find_demangled_name (struct general_symbol_info *gsymbol,
			    const char *mangled)
{
  char *demangled = NULL;

  if (gsymbol->language == language_unknown)
    gsymbol->language = language_auto;

  if (gsymbol->language == language_objc
      || gsymbol->language == language_auto)
    {
      demangled =
	objc_demangle (mangled, 0);
      if (demangled != NULL)
	{
	  gsymbol->language = language_objc;
	  return demangled;
	}
    }
  if (gsymbol->language == language_cplus
      || gsymbol->language == language_auto)
    {
      demangled =
        gdb_demangle (mangled, DMGL_PARAMS | DMGL_ANSI);
      if (demangled != NULL)
	{
	  gsymbol->language = language_cplus;
	  return demangled;
	}
    }
  if (gsymbol->language == language_java)
    {
      demangled =
        gdb_demangle (mangled,
		      DMGL_PARAMS | DMGL_ANSI | DMGL_JAVA);
      if (demangled != NULL)
	{
	  gsymbol->language = language_java;
	  return demangled;
	}
    }
  if (gsymbol->language == language_d
      || gsymbol->language == language_auto)
    {
      demangled = d_demangle(mangled, 0);
      if (demangled != NULL)
	{
	  gsymbol->language = language_d;
	  return demangled;
	}
    }
  /* FIXME(dje): Continually adding languages here is clumsy.
     Better to just call la_demangle if !auto, and if auto then call
     a utility routine that tries successive languages in turn and reports
     which one it finds.  I realize the la_demangle options may be different
     for different languages but there's already a FIXME for that.  */
  if (gsymbol->language == language_go
      || gsymbol->language == language_auto)
    {
      demangled = go_demangle (mangled, 0);
      if (demangled != NULL)
	{
	  gsymbol->language = language_go;
	  return demangled;
	}
    }

  /* We could support `gsymbol->language == language_fortran' here to provide
     module namespaces also for inferiors with only minimal symbol table (ELF
     symbols).  Just the mangling standard is not standardized across compilers
     and there is no DW_AT_producer available for inferiors with only the ELF
     symbols to check the mangling kind.  */
  return NULL;
}

/* Set both the mangled and demangled (if any) names for GSYMBOL based
   on LINKAGE_NAME and LEN.  Ordinarily, NAME is copied onto the
   objfile's obstack; but if COPY_NAME is 0 and if NAME is
   NUL-terminated, then this function assumes that NAME is already
   correctly saved (either permanently or with a lifetime tied to the
   objfile), and it will not be copied.

   The hash table corresponding to OBJFILE is used, and the memory
   comes from the per-BFD storage_obstack.  LINKAGE_NAME is copied,
   so the pointer can be discarded after calling this function.  */

/* We have to be careful when dealing with Java names: when we run
   into a Java minimal symbol, we don't know it's a Java symbol, so it
   gets demangled as a C++ name.  This is unfortunate, but there's not
   much we can do about it: but when demangling partial symbols and
   regular symbols, we'd better not reuse the wrong demangled name.
   (See PR gdb/1039.)  We solve this by putting a distinctive prefix
   on Java names when storing them in the hash table.  */

/* FIXME: carlton/2003-03-13: This is an unfortunate situation.  I
   don't mind the Java prefix so much: different languages have
   different demangling requirements, so it's only natural that we
   need to keep language data around in our demangling cache.  But
   it's not good that the minimal symbol has the wrong demangled name.
   Unfortunately, I can't think of any easy solution to that
   problem.  */

#define JAVA_PREFIX "##JAVA$$"
#define JAVA_PREFIX_LEN 8

void
symbol_set_names (struct general_symbol_info *gsymbol,
		  const char *linkage_name, int len, int copy_name,
		  struct objfile *objfile)
{
  struct demangled_name_entry **slot;
  /* A 0-terminated copy of the linkage name.  */
  const char *linkage_name_copy;
  /* A copy of the linkage name that might have a special Java prefix
     added to it, for use when looking names up in the hash table.  */
  const char *lookup_name;
  /* The length of lookup_name.  */
  int lookup_len;
  struct demangled_name_entry entry;
  struct objfile_per_bfd_storage *per_bfd = objfile->per_bfd;

  if (gsymbol->language == language_ada)
    {
      /* In Ada, we do the symbol lookups using the mangled name, so
         we can save some space by not storing the demangled name.

         As a side note, we have also observed some overlap between
         the C++ mangling and Ada mangling, similarly to what has
         been observed with Java.  Because we don't store the demangled
         name with the symbol, we don't need to use the same trick
         as Java.  */
      if (!copy_name)
	gsymbol->name = linkage_name;
      else
	{
	  char *name = obstack_alloc (&per_bfd->storage_obstack, len + 1);

	  memcpy (name, linkage_name, len);
	  name[len] = '\0';
	  gsymbol->name = name;
	}
      symbol_set_demangled_name (gsymbol, NULL, &per_bfd->storage_obstack);

      return;
    }

  if (per_bfd->demangled_names_hash == NULL)
    create_demangled_names_hash (objfile);

  /* The stabs reader generally provides names that are not
     NUL-terminated; most of the other readers don't do this, so we
     can just use the given copy, unless we're in the Java case.  */
  if (gsymbol->language == language_java)
    {
      char *alloc_name;

      lookup_len = len + JAVA_PREFIX_LEN;
      alloc_name = alloca (lookup_len + 1);
      memcpy (alloc_name, JAVA_PREFIX, JAVA_PREFIX_LEN);
      memcpy (alloc_name + JAVA_PREFIX_LEN, linkage_name, len);
      alloc_name[lookup_len] = '\0';

      lookup_name = alloc_name;
      linkage_name_copy = alloc_name + JAVA_PREFIX_LEN;
    }
  else if (linkage_name[len] != '\0')
    {
      char *alloc_name;

      lookup_len = len;
      alloc_name = alloca (lookup_len + 1);
      memcpy (alloc_name, linkage_name, len);
      alloc_name[lookup_len] = '\0';

      lookup_name = alloc_name;
      linkage_name_copy = alloc_name;
    }
  else
    {
      lookup_len = len;
      lookup_name = linkage_name;
      linkage_name_copy = linkage_name;
    }

  entry.mangled = lookup_name;
  slot = ((struct demangled_name_entry **)
	  htab_find_slot (per_bfd->demangled_names_hash,
			  &entry, INSERT));

  /* If this name is not in the hash table, add it.  */
  if (*slot == NULL
      /* A C version of the symbol may have already snuck into the table.
	 This happens to, e.g., main.init (__go_init_main).  Cope.  */
      || (gsymbol->language == language_go
	  && (*slot)->demangled[0] == '\0'))
    {
      char *demangled_name = symbol_find_demangled_name (gsymbol,
							 linkage_name_copy);
      int demangled_len = demangled_name ? strlen (demangled_name) : 0;

      /* Suppose we have demangled_name==NULL, copy_name==0, and
	 lookup_name==linkage_name.  In this case, we already have the
	 mangled name saved, and we don't have a demangled name.  So,
	 you might think we could save a little space by not recording
	 this in the hash table at all.
	 
	 It turns out that it is actually important to still save such
	 an entry in the hash table, because storing this name gives
	 us better bcache hit rates for partial symbols.  */
      if (!copy_name && lookup_name == linkage_name)
	{
	  *slot = obstack_alloc (&per_bfd->storage_obstack,
				 offsetof (struct demangled_name_entry,
					   demangled)
				 + demangled_len + 1);
	  (*slot)->mangled = lookup_name;
	}
      else
	{
	  char *mangled_ptr;

	  /* If we must copy the mangled name, put it directly after
	     the demangled name so we can have a single
	     allocation.  */
	  *slot = obstack_alloc (&per_bfd->storage_obstack,
				 offsetof (struct demangled_name_entry,
					   demangled)
				 + lookup_len + demangled_len + 2);
	  mangled_ptr = &((*slot)->demangled[demangled_len + 1]);
	  strcpy (mangled_ptr, lookup_name);
	  (*slot)->mangled = mangled_ptr;
	}

      if (demangled_name != NULL)
	{
	  strcpy ((*slot)->demangled, demangled_name);
	  xfree (demangled_name);
	}
      else
	(*slot)->demangled[0] = '\0';
    }

  gsymbol->name = (*slot)->mangled + lookup_len - len;
  if ((*slot)->demangled[0] != '\0')
    symbol_set_demangled_name (gsymbol, (*slot)->demangled,
			       &per_bfd->storage_obstack);
  else
    symbol_set_demangled_name (gsymbol, NULL, &per_bfd->storage_obstack);
}

/* Return the source code name of a symbol.  In languages where
   demangling is necessary, this is the demangled name.  */

const char *
symbol_natural_name (const struct general_symbol_info *gsymbol)
{
  switch (gsymbol->language)
    {
    case language_cplus:
    case language_d:
    case language_go:
    case language_java:
    case language_objc:
    case language_fortran:
      if (symbol_get_demangled_name (gsymbol) != NULL)
	return symbol_get_demangled_name (gsymbol);
      break;
    case language_ada:
      return ada_decode_symbol (gsymbol);
    default:
      break;
    }
  return gsymbol->name;
}

/* Return the demangled name for a symbol based on the language for
   that symbol.  If no demangled name exists, return NULL.  */

const char *
symbol_demangled_name (const struct general_symbol_info *gsymbol)
{
  const char *dem_name = NULL;

  switch (gsymbol->language)
    {
    case language_cplus:
    case language_d:
    case language_go:
    case language_java:
    case language_objc:
    case language_fortran:
      dem_name = symbol_get_demangled_name (gsymbol);
      break;
    case language_ada:
      dem_name = ada_decode_symbol (gsymbol);
      break;
    default:
      break;
    }
  return dem_name;
}

/* Return the search name of a symbol---generally the demangled or
   linkage name of the symbol, depending on how it will be searched for.
   If there is no distinct demangled name, then returns the same value
   (same pointer) as SYMBOL_LINKAGE_NAME.  */

const char *
symbol_search_name (const struct general_symbol_info *gsymbol)
{
  if (gsymbol->language == language_ada)
    return gsymbol->name;
  else
    return symbol_natural_name (gsymbol);
}

/* Initialize the structure fields to zero values.  */

void
init_sal (struct symtab_and_line *sal)
{
  sal->pspace = NULL;
  sal->symtab = 0;
  sal->section = 0;
  sal->line = 0;
  sal->pc = 0;
  sal->end = 0;
  sal->explicit_pc = 0;
  sal->explicit_line = 0;
  sal->probe = NULL;
}


/* Return 1 if the two sections are the same, or if they could
   plausibly be copies of each other, one in an original object
   file and another in a separated debug file.  */

int
matching_obj_sections (struct obj_section *obj_first,
		       struct obj_section *obj_second)
{
  asection *first = obj_first? obj_first->the_bfd_section : NULL;
  asection *second = obj_second? obj_second->the_bfd_section : NULL;
  struct objfile *obj;

  /* If they're the same section, then they match.  */
  if (first == second)
    return 1;

  /* If either is NULL, give up.  */
  if (first == NULL || second == NULL)
    return 0;

  /* This doesn't apply to absolute symbols.  */
  if (first->owner == NULL || second->owner == NULL)
    return 0;

  /* If they're in the same object file, they must be different sections.  */
  if (first->owner == second->owner)
    return 0;

  /* Check whether the two sections are potentially corresponding.  They must
     have the same size, address, and name.  We can't compare section indexes,
     which would be more reliable, because some sections may have been
     stripped.  */
  if (bfd_get_section_size (first) != bfd_get_section_size (second))
    return 0;

  /* In-memory addresses may start at a different offset, relativize them.  */
  if (bfd_get_section_vma (first->owner, first)
      - bfd_get_start_address (first->owner)
      != bfd_get_section_vma (second->owner, second)
	 - bfd_get_start_address (second->owner))
    return 0;

  if (bfd_get_section_name (first->owner, first) == NULL
      || bfd_get_section_name (second->owner, second) == NULL
      || strcmp (bfd_get_section_name (first->owner, first),
		 bfd_get_section_name (second->owner, second)) != 0)
    return 0;

  /* Otherwise check that they are in corresponding objfiles.  */

  ALL_OBJFILES (obj)
    if (obj->obfd == first->owner)
      break;
  gdb_assert (obj != NULL);

  if (obj->separate_debug_objfile != NULL
      && obj->separate_debug_objfile->obfd == second->owner)
    return 1;
  if (obj->separate_debug_objfile_backlink != NULL
      && obj->separate_debug_objfile_backlink->obfd == second->owner)
    return 1;

  return 0;
}

struct symtab *
find_pc_sect_symtab_via_partial (CORE_ADDR pc, struct obj_section *section)
{
  struct objfile *objfile;
  struct minimal_symbol *msymbol;

  /* If we know that this is not a text address, return failure.  This is
     necessary because we loop based on texthigh and textlow, which do
     not include the data ranges.  */
  msymbol = lookup_minimal_symbol_by_pc_section (pc, section).minsym;
  if (msymbol
      && (MSYMBOL_TYPE (msymbol) == mst_data
	  || MSYMBOL_TYPE (msymbol) == mst_bss
	  || MSYMBOL_TYPE (msymbol) == mst_abs
	  || MSYMBOL_TYPE (msymbol) == mst_file_data
	  || MSYMBOL_TYPE (msymbol) == mst_file_bss))
    return NULL;

  ALL_OBJFILES (objfile)
  {
    struct symtab *result = NULL;

    if (objfile->sf)
      result = objfile->sf->qf->find_pc_sect_symtab (objfile, msymbol,
						     pc, section, 0);
    if (result)
      return result;
  }

  return NULL;
}

/* Debug symbols usually don't have section information.  We need to dig that
   out of the minimal symbols and stash that in the debug symbol.  */

void
fixup_section (struct general_symbol_info *ginfo,
	       CORE_ADDR addr, struct objfile *objfile)
{
  struct minimal_symbol *msym;

  /* First, check whether a minimal symbol with the same name exists
     and points to the same address.  The address check is required
     e.g. on PowerPC64, where the minimal symbol for a function will
     point to the function descriptor, while the debug symbol will
     point to the actual function code.  */
  msym = lookup_minimal_symbol_by_pc_name (addr, ginfo->name, objfile);
  if (msym)
    ginfo->section = SYMBOL_SECTION (msym);
  else
    {
      /* Static, function-local variables do appear in the linker
	 (minimal) symbols, but are frequently given names that won't
	 be found via lookup_minimal_symbol().  E.g., it has been
	 observed in frv-uclinux (ELF) executables that a static,
	 function-local variable named "foo" might appear in the
	 linker symbols as "foo.6" or "foo.3".  Thus, there is no
	 point in attempting to extend the lookup-by-name mechanism to
	 handle this case due to the fact that there can be multiple
	 names.

	 So, instead, search the section table when lookup by name has
	 failed.  The ``addr'' and ``endaddr'' fields may have already
	 been relocated.  If so, the relocation offset (i.e. the
	 ANOFFSET value) needs to be subtracted from these values when
	 performing the comparison.  We unconditionally subtract it,
	 because, when no relocation has been performed, the ANOFFSET
	 value will simply be zero.

	 The address of the symbol whose section we're fixing up HAS
	 NOT BEEN adjusted (relocated) yet.  It can't have been since
	 the section isn't yet known and knowing the section is
	 necessary in order to add the correct relocation value.  In
	 other words, we wouldn't even be in this function (attempting
	 to compute the section) if it were already known.

	 Note that it is possible to search the minimal symbols
	 (subtracting the relocation value if necessary) to find the
	 matching minimal symbol, but this is overkill and much less
	 efficient.  It is not necessary to find the matching minimal
	 symbol, only its section.

	 Note that this technique (of doing a section table search)
	 can fail when unrelocated section addresses overlap.  For
	 this reason, we still attempt a lookup by name prior to doing
	 a search of the section table.  */

      struct obj_section *s;
      int fallback = -1;

      ALL_OBJFILE_OSECTIONS (objfile, s)
	{
	  int idx = s - objfile->sections;
	  CORE_ADDR offset = ANOFFSET (objfile->section_offsets, idx);

	  if (fallback == -1)
	    fallback = idx;

	  if (obj_section_addr (s) - offset <= addr
	      && addr < obj_section_endaddr (s) - offset)
	    {
	      ginfo->section = idx;
	      return;
	    }
	}

      /* If we didn't find the section, assume it is in the first
	 section.  If there is no allocated section, then it hardly
	 matters what we pick, so just pick zero.  */
      if (fallback == -1)
	ginfo->section = 0;
      else
	ginfo->section = fallback;
    }
}

struct symbol *
fixup_symbol_section (struct symbol *sym, struct objfile *objfile)
{
  CORE_ADDR addr;

  if (!sym)
    return NULL;

  /* We either have an OBJFILE, or we can get at it from the sym's
     symtab.  Anything else is a bug.  */
  gdb_assert (objfile || SYMBOL_SYMTAB (sym));

  if (objfile == NULL)
    objfile = SYMBOL_SYMTAB (sym)->objfile;

  if (SYMBOL_OBJ_SECTION (objfile, sym))
    return sym;

  /* We should have an objfile by now.  */
  gdb_assert (objfile);

  switch (SYMBOL_CLASS (sym))
    {
    case LOC_STATIC:
    case LOC_LABEL:
      addr = SYMBOL_VALUE_ADDRESS (sym);
      break;
    case LOC_BLOCK:
      addr = BLOCK_START (SYMBOL_BLOCK_VALUE (sym));
      break;

    default:
      /* Nothing else will be listed in the minsyms -- no use looking
	 it up.  */
      return sym;
    }

  fixup_section (&sym->ginfo, addr, objfile);

  return sym;
}

/* Compute the demangled form of NAME as used by the various symbol
   lookup functions.  The result is stored in *RESULT_NAME.  Returns a
   cleanup which can be used to clean up the result.

   For Ada, this function just sets *RESULT_NAME to NAME, unmodified.
   Normally, Ada symbol lookups are performed using the encoded name
   rather than the demangled name, and so it might seem to make sense
   for this function to return an encoded version of NAME.
   Unfortunately, we cannot do this, because this function is used in
   circumstances where it is not appropriate to try to encode NAME.
   For instance, when displaying the frame info, we demangle the name
   of each parameter, and then perform a symbol lookup inside our
   function using that demangled name.  In Ada, certain functions
   have internally-generated parameters whose name contain uppercase
   characters.  Encoding those name would result in those uppercase
   characters to become lowercase, and thus cause the symbol lookup
   to fail.  */

struct cleanup *
demangle_for_lookup (const char *name, enum language lang,
		     const char **result_name)
{
  char *demangled_name = NULL;
  const char *modified_name = NULL;
  struct cleanup *cleanup = make_cleanup (null_cleanup, 0);

  modified_name = name;

  /* If we are using C++, D, Go, or Java, demangle the name before doing a
     lookup, so we can always binary search.  */
  if (lang == language_cplus)
    {
      demangled_name = gdb_demangle (name, DMGL_ANSI | DMGL_PARAMS);
      if (demangled_name)
	{
	  modified_name = demangled_name;
	  make_cleanup (xfree, demangled_name);
	}
      else
	{
	  /* If we were given a non-mangled name, canonicalize it
	     according to the language (so far only for C++).  */
	  demangled_name = cp_canonicalize_string (name);
	  if (demangled_name)
	    {
	      modified_name = demangled_name;
	      make_cleanup (xfree, demangled_name);
	    }
	}
    }
  else if (lang == language_java)
    {
      demangled_name = gdb_demangle (name,
				     DMGL_ANSI | DMGL_PARAMS | DMGL_JAVA);
      if (demangled_name)
	{
	  modified_name = demangled_name;
	  make_cleanup (xfree, demangled_name);
	}
    }
  else if (lang == language_d)
    {
      demangled_name = d_demangle (name, 0);
      if (demangled_name)
	{
	  modified_name = demangled_name;
	  make_cleanup (xfree, demangled_name);
	}
    }
  else if (lang == language_go)
    {
      demangled_name = go_demangle (name, 0);
      if (demangled_name)
	{
	  modified_name = demangled_name;
	  make_cleanup (xfree, demangled_name);
	}
    }

  *result_name = modified_name;
  return cleanup;
}

/* Find the definition for a specified symbol name NAME
   in domain DOMAIN, visible from lexical block BLOCK.
   Returns the struct symbol pointer, or zero if no symbol is found.
   C++: if IS_A_FIELD_OF_THIS is nonzero on entry, check to see if
   NAME is a field of the current implied argument `this'.  If so set
   *IS_A_FIELD_OF_THIS to 1, otherwise set it to zero.
   BLOCK_FOUND is set to the block in which NAME is found (in the case of
   a field of `this', value_of_this sets BLOCK_FOUND to the proper value.)  */

/* This function (or rather its subordinates) have a bunch of loops and
   it would seem to be attractive to put in some QUIT's (though I'm not really
   sure whether it can run long enough to be really important).  But there
   are a few calls for which it would appear to be bad news to quit
   out of here: e.g., find_proc_desc in alpha-mdebug-tdep.c.  (Note
   that there is C++ code below which can error(), but that probably
   doesn't affect these calls since they are looking for a known
   variable and thus can probably assume it will never hit the C++
   code).  */

struct symbol *
lookup_symbol_in_language (const char *name, const struct block *block,
			   const domain_enum domain, enum language lang,
			   struct field_of_this_result *is_a_field_of_this)
{
  const char *modified_name;
  struct symbol *returnval;
  struct cleanup *cleanup = demangle_for_lookup (name, lang, &modified_name);

  returnval = lookup_symbol_aux (modified_name, block, domain, lang,
				 is_a_field_of_this);
  do_cleanups (cleanup);

  return returnval;
}

/* Behave like lookup_symbol_in_language, but performed with the
   current language.  */

struct symbol *
lookup_symbol (const char *name, const struct block *block,
	       domain_enum domain,
	       struct field_of_this_result *is_a_field_of_this)
{
  return lookup_symbol_in_language (name, block, domain,
				    current_language->la_language,
				    is_a_field_of_this);
}

/* Look up the `this' symbol for LANG in BLOCK.  Return the symbol if
   found, or NULL if not found.  */

struct symbol *
lookup_language_this (const struct language_defn *lang,
		      const struct block *block)
{
  if (lang->la_name_of_this == NULL || block == NULL)
    return NULL;

  while (block)
    {
      struct symbol *sym;

      sym = lookup_block_symbol (block, lang->la_name_of_this, VAR_DOMAIN);
      if (sym != NULL)
	{
	  block_found = block;
	  return sym;
	}
      if (BLOCK_FUNCTION (block))
	break;
      block = BLOCK_SUPERBLOCK (block);
    }

  return NULL;
}

/* Given TYPE, a structure/union,
   return 1 if the component named NAME from the ultimate target
   structure/union is defined, otherwise, return 0.  */

static int
check_field (struct type *type, const char *name,
	     struct field_of_this_result *is_a_field_of_this)
{
  int i;

  /* The type may be a stub.  */
  CHECK_TYPEDEF (type);

  for (i = TYPE_NFIELDS (type) - 1; i >= TYPE_N_BASECLASSES (type); i--)
    {
      const char *t_field_name = TYPE_FIELD_NAME (type, i);

      if (t_field_name && (strcmp_iw (t_field_name, name) == 0))
	{
	  is_a_field_of_this->type = type;
	  is_a_field_of_this->field = &TYPE_FIELD (type, i);
	  return 1;
	}
    }

  /* C++: If it was not found as a data field, then try to return it
     as a pointer to a method.  */

  for (i = TYPE_NFN_FIELDS (type) - 1; i >= 0; --i)
    {
      if (strcmp_iw (TYPE_FN_FIELDLIST_NAME (type, i), name) == 0)
	{
	  is_a_field_of_this->type = type;
	  is_a_field_of_this->fn_field = &TYPE_FN_FIELDLIST (type, i);
	  return 1;
	}
    }

  for (i = TYPE_N_BASECLASSES (type) - 1; i >= 0; i--)
    if (check_field (TYPE_BASECLASS (type, i), name, is_a_field_of_this))
      return 1;

  return 0;
}

/* Behave like lookup_symbol except that NAME is the natural name
   (e.g., demangled name) of the symbol that we're looking for.  */

static struct symbol *
lookup_symbol_aux (const char *name, const struct block *block,
		   const domain_enum domain, enum language language,
		   struct field_of_this_result *is_a_field_of_this)
{
  struct symbol *sym;
  const struct language_defn *langdef;

  /* Make sure we do something sensible with is_a_field_of_this, since
     the callers that set this parameter to some non-null value will
     certainly use it later.  If we don't set it, the contents of
     is_a_field_of_this are undefined.  */
  if (is_a_field_of_this != NULL)
    memset (is_a_field_of_this, 0, sizeof (*is_a_field_of_this));

  /* Search specified block and its superiors.  Don't search
     STATIC_BLOCK or GLOBAL_BLOCK.  */

  sym = lookup_symbol_aux_local (name, block, domain, language);
  if (sym != NULL)
    return sym;

  /* If requested to do so by the caller and if appropriate for LANGUAGE,
     check to see if NAME is a field of `this'.  */

  langdef = language_def (language);

  /* Don't do this check if we are searching for a struct.  It will
     not be found by check_field, but will be found by other
     means.  */
  if (is_a_field_of_this != NULL && domain != STRUCT_DOMAIN)
    {
      struct symbol *sym = lookup_language_this (langdef, block);

      if (sym)
	{
	  struct type *t = sym->type;

	  /* I'm not really sure that type of this can ever
	     be typedefed; just be safe.  */
	  CHECK_TYPEDEF (t);
	  if (TYPE_CODE (t) == TYPE_CODE_PTR
	      || TYPE_CODE (t) == TYPE_CODE_REF)
	    t = TYPE_TARGET_TYPE (t);

	  if (TYPE_CODE (t) != TYPE_CODE_STRUCT
	      && TYPE_CODE (t) != TYPE_CODE_UNION)
	    error (_("Internal error: `%s' is not an aggregate"),
		   langdef->la_name_of_this);

	  if (check_field (t, name, is_a_field_of_this))
	    return NULL;
	}
    }

  /* Now do whatever is appropriate for LANGUAGE to look
     up static and global variables.  */

  sym = langdef->la_lookup_symbol_nonlocal (name, block, domain);
  if (sym != NULL)
    return sym;

  /* Now search all static file-level symbols.  Not strictly correct,
     but more useful than an error.  */

  return lookup_static_symbol_aux (name, domain);
}

/* Search all static file-level symbols for NAME from DOMAIN.  Do the symtabs
   first, then check the psymtabs.  If a psymtab indicates the existence of the
   desired name as a file-level static, then do psymtab-to-symtab conversion on
   the fly and return the found symbol.  */

struct symbol *
lookup_static_symbol_aux (const char *name, const domain_enum domain)
{
  struct objfile *objfile;
  struct symbol *sym;

  sym = lookup_symbol_aux_symtabs (STATIC_BLOCK, name, domain);
  if (sym != NULL)
    return sym;

  ALL_OBJFILES (objfile)
  {
    sym = lookup_symbol_aux_quick (objfile, STATIC_BLOCK, name, domain);
    if (sym != NULL)
      return sym;
  }

  return NULL;
}

/* Check to see if the symbol is defined in BLOCK or its superiors.
   Don't search STATIC_BLOCK or GLOBAL_BLOCK.  */

static struct symbol *
lookup_symbol_aux_local (const char *name, const struct block *block,
                         const domain_enum domain,
                         enum language language)
{
  struct symbol *sym;
  const struct block *static_block = block_static_block (block);
  const char *scope = block_scope (block);
  
  /* Check if either no block is specified or it's a global block.  */

  if (static_block == NULL)
    return NULL;

  while (block != static_block)
    {
      sym = lookup_symbol_aux_block (name, block, domain);
      if (sym != NULL)
	return sym;

      if (language == language_cplus || language == language_fortran)
        {
          sym = cp_lookup_symbol_imports_or_template (scope, name, block,
						      domain);
          if (sym != NULL)
            return sym;
        }

      if (BLOCK_FUNCTION (block) != NULL && block_inlined_p (block))
	break;
      block = BLOCK_SUPERBLOCK (block);
    }

  /* We've reached the edge of the function without finding a result.  */

  return NULL;
}

/* Look up OBJFILE to BLOCK.  */

struct objfile *
lookup_objfile_from_block (const struct block *block)
{
  struct objfile *obj;
  struct symtab *s;

  if (block == NULL)
    return NULL;

  block = block_global_block (block);
  /* Go through SYMTABS.  */
  ALL_SYMTABS (obj, s)
    if (block == BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), GLOBAL_BLOCK))
      {
	if (obj->separate_debug_objfile_backlink)
	  obj = obj->separate_debug_objfile_backlink;

	return obj;
      }

  return NULL;
}

/* Look up a symbol in a block; if found, fixup the symbol, and set
   block_found appropriately.  */

struct symbol *
lookup_symbol_aux_block (const char *name, const struct block *block,
			 const domain_enum domain)
{
  struct symbol *sym;

  sym = lookup_block_symbol (block, name, domain);
  if (sym)
    {
      block_found = block;
      return fixup_symbol_section (sym, NULL);
    }

  return NULL;
}

/* Check all global symbols in OBJFILE in symtabs and
   psymtabs.  */

struct symbol *
lookup_global_symbol_from_objfile (const struct objfile *main_objfile,
				   const char *name,
				   const domain_enum domain)
{
  const struct objfile *objfile;
  struct symbol *sym;
  struct blockvector *bv;
  const struct block *block;
  struct symtab *s;

  for (objfile = main_objfile;
       objfile;
       objfile = objfile_separate_debug_iterate (main_objfile, objfile))
    {
      /* Go through symtabs.  */
      ALL_OBJFILE_PRIMARY_SYMTABS (objfile, s)
	{
	  bv = BLOCKVECTOR (s);
	  block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
	  sym = lookup_block_symbol (block, name, domain);
	  if (sym)
	    {
	      block_found = block;
	      return fixup_symbol_section (sym, (struct objfile *)objfile);
	    }
	}

      sym = lookup_symbol_aux_quick ((struct objfile *) objfile, GLOBAL_BLOCK,
				     name, domain);
      if (sym)
	return sym;
    }

  return NULL;
}

/* Check to see if the symbol is defined in one of the OBJFILE's
   symtabs.  BLOCK_INDEX should be either GLOBAL_BLOCK or STATIC_BLOCK,
   depending on whether or not we want to search global symbols or
   static symbols.  */

static struct symbol *
lookup_symbol_aux_objfile (struct objfile *objfile, int block_index,
			   const char *name, const domain_enum domain)
{
  struct symbol *sym = NULL;
  struct blockvector *bv;
  const struct block *block;
  struct symtab *s;

  ALL_OBJFILE_PRIMARY_SYMTABS (objfile, s)
    {
      bv = BLOCKVECTOR (s);
      block = BLOCKVECTOR_BLOCK (bv, block_index);
      sym = lookup_block_symbol (block, name, domain);
      if (sym)
	{
	  block_found = block;
	  return fixup_symbol_section (sym, objfile);
	}
    }

  return NULL;
}

/* Same as lookup_symbol_aux_objfile, except that it searches all
   objfiles.  Return the first match found.  */

static struct symbol *
lookup_symbol_aux_symtabs (int block_index, const char *name,
			   const domain_enum domain)
{
  struct symbol *sym;
  struct objfile *objfile;

  ALL_OBJFILES (objfile)
  {
    sym = lookup_symbol_aux_objfile (objfile, block_index, name, domain);
    if (sym)
      return sym;
  }

  return NULL;
}

/* Wrapper around lookup_symbol_aux_objfile for search_symbols.
   Look up LINKAGE_NAME in DOMAIN in the global and static blocks of OBJFILE
   and all related objfiles.  */

static struct symbol *
lookup_symbol_in_objfile_from_linkage_name (struct objfile *objfile,
					    const char *linkage_name,
					    domain_enum domain)
{
  enum language lang = current_language->la_language;
  const char *modified_name;
  struct cleanup *cleanup = demangle_for_lookup (linkage_name, lang,
						 &modified_name);
  struct objfile *main_objfile, *cur_objfile;

  if (objfile->separate_debug_objfile_backlink)
    main_objfile = objfile->separate_debug_objfile_backlink;
  else
    main_objfile = objfile;

  for (cur_objfile = main_objfile;
       cur_objfile;
       cur_objfile = objfile_separate_debug_iterate (main_objfile, cur_objfile))
    {
      struct symbol *sym;

      sym = lookup_symbol_aux_objfile (cur_objfile, GLOBAL_BLOCK,
				       modified_name, domain);
      if (sym == NULL)
	sym = lookup_symbol_aux_objfile (cur_objfile, STATIC_BLOCK,
					 modified_name, domain);
      if (sym != NULL)
	{
	  do_cleanups (cleanup);
	  return sym;
	}
    }

  do_cleanups (cleanup);
  return NULL;
}

/* A helper function that throws an exception when a symbol was found
   in a psymtab but not in a symtab.  */

static void ATTRIBUTE_NORETURN
error_in_psymtab_expansion (int kind, const char *name, struct symtab *symtab)
{
  error (_("\
Internal: %s symbol `%s' found in %s psymtab but not in symtab.\n\
%s may be an inlined function, or may be a template function\n	 \
(if a template, try specifying an instantiation: %s<type>)."),
	 kind == GLOBAL_BLOCK ? "global" : "static",
	 name, symtab_to_filename_for_display (symtab), name, name);
}

/* A helper function for lookup_symbol_aux that interfaces with the
   "quick" symbol table functions.  */

static struct symbol *
lookup_symbol_aux_quick (struct objfile *objfile, int kind,
			 const char *name, const domain_enum domain)
{
  struct symtab *symtab;
  struct blockvector *bv;
  const struct block *block;
  struct symbol *sym;

  if (!objfile->sf)
    return NULL;
  symtab = objfile->sf->qf->lookup_symbol (objfile, kind, name, domain);
  if (!symtab)
    return NULL;

  bv = BLOCKVECTOR (symtab);
  block = BLOCKVECTOR_BLOCK (bv, kind);
  sym = lookup_block_symbol (block, name, domain);
  if (!sym)
    error_in_psymtab_expansion (kind, name, symtab);
  return fixup_symbol_section (sym, objfile);
}

/* A default version of lookup_symbol_nonlocal for use by languages
   that can't think of anything better to do.  This implements the C
   lookup rules.  */

struct symbol *
basic_lookup_symbol_nonlocal (const char *name,
			      const struct block *block,
			      const domain_enum domain)
{
  struct symbol *sym;

  /* NOTE: carlton/2003-05-19: The comments below were written when
     this (or what turned into this) was part of lookup_symbol_aux;
     I'm much less worried about these questions now, since these
     decisions have turned out well, but I leave these comments here
     for posterity.  */

  /* NOTE: carlton/2002-12-05: There is a question as to whether or
     not it would be appropriate to search the current global block
     here as well.  (That's what this code used to do before the
     is_a_field_of_this check was moved up.)  On the one hand, it's
     redundant with the lookup_symbol_aux_symtabs search that happens
     next.  On the other hand, if decode_line_1 is passed an argument
     like filename:var, then the user presumably wants 'var' to be
     searched for in filename.  On the third hand, there shouldn't be
     multiple global variables all of which are named 'var', and it's
     not like decode_line_1 has ever restricted its search to only
     global variables in a single filename.  All in all, only
     searching the static block here seems best: it's correct and it's
     cleanest.  */

  /* NOTE: carlton/2002-12-05: There's also a possible performance
     issue here: if you usually search for global symbols in the
     current file, then it would be slightly better to search the
     current global block before searching all the symtabs.  But there
     are other factors that have a much greater effect on performance
     than that one, so I don't think we should worry about that for
     now.  */

  sym = lookup_symbol_static (name, block, domain);
  if (sym != NULL)
    return sym;

  return lookup_symbol_global (name, block, domain);
}

/* Lookup a symbol in the static block associated to BLOCK, if there
   is one; do nothing if BLOCK is NULL or a global block.  */

struct symbol *
lookup_symbol_static (const char *name,
		      const struct block *block,
		      const domain_enum domain)
{
  const struct block *static_block = block_static_block (block);

  if (static_block != NULL)
    return lookup_symbol_aux_block (name, static_block, domain);
  else
    return NULL;
}

/* Private data to be used with lookup_symbol_global_iterator_cb.  */

struct global_sym_lookup_data
{
  /* The name of the symbol we are searching for.  */
  const char *name;

  /* The domain to use for our search.  */
  domain_enum domain;

  /* The field where the callback should store the symbol if found.
     It should be initialized to NULL before the search is started.  */
  struct symbol *result;
};

/* A callback function for gdbarch_iterate_over_objfiles_in_search_order.
   It searches by name for a symbol in the GLOBAL_BLOCK of the given
   OBJFILE.  The arguments for the search are passed via CB_DATA,
   which in reality is a pointer to struct global_sym_lookup_data.  */

static int
lookup_symbol_global_iterator_cb (struct objfile *objfile,
				  void *cb_data)
{
  struct global_sym_lookup_data *data =
    (struct global_sym_lookup_data *) cb_data;

  gdb_assert (data->result == NULL);

  data->result = lookup_symbol_aux_objfile (objfile, GLOBAL_BLOCK,
					    data->name, data->domain);
  if (data->result == NULL)
    data->result = lookup_symbol_aux_quick (objfile, GLOBAL_BLOCK,
					    data->name, data->domain);

  /* If we found a match, tell the iterator to stop.  Otherwise,
     keep going.  */
  return (data->result != NULL);
}

/* Lookup a symbol in all files' global blocks (searching psymtabs if
   necessary).  */

struct symbol *
lookup_symbol_global (const char *name,
		      const struct block *block,
		      const domain_enum domain)
{
  struct symbol *sym = NULL;
  struct objfile *objfile = NULL;
  struct global_sym_lookup_data lookup_data;

  /* Call library-specific lookup procedure.  */
  objfile = lookup_objfile_from_block (block);
  if (objfile != NULL)
    sym = solib_global_lookup (objfile, name, domain);
  if (sym != NULL)
    return sym;

  memset (&lookup_data, 0, sizeof (lookup_data));
  lookup_data.name = name;
  lookup_data.domain = domain;
  gdbarch_iterate_over_objfiles_in_search_order
    (objfile != NULL ? get_objfile_arch (objfile) : target_gdbarch (),
     lookup_symbol_global_iterator_cb, &lookup_data, objfile);

  return lookup_data.result;
}

int
symbol_matches_domain (enum language symbol_language,
		       domain_enum symbol_domain,
		       domain_enum domain)
{
  /* For C++ "struct foo { ... }" also defines a typedef for "foo".
     A Java class declaration also defines a typedef for the class.
     Similarly, any Ada type declaration implicitly defines a typedef.  */
  if (symbol_language == language_cplus
      || symbol_language == language_d
      || symbol_language == language_java
      || symbol_language == language_ada)
    {
      if ((domain == VAR_DOMAIN || domain == STRUCT_DOMAIN)
	  && symbol_domain == STRUCT_DOMAIN)
	return 1;
    }
  /* For all other languages, strict match is required.  */
  return (symbol_domain == domain);
}

/* Look up a type named NAME in the struct_domain.  The type returned
   must not be opaque -- i.e., must have at least one field
   defined.  */

struct type *
lookup_transparent_type (const char *name)
{
  return current_language->la_lookup_transparent_type (name);
}

/* A helper for basic_lookup_transparent_type that interfaces with the
   "quick" symbol table functions.  */

static struct type *
basic_lookup_transparent_type_quick (struct objfile *objfile, int kind,
				     const char *name)
{
  struct symtab *symtab;
  struct blockvector *bv;
  struct block *block;
  struct symbol *sym;

  if (!objfile->sf)
    return NULL;
  symtab = objfile->sf->qf->lookup_symbol (objfile, kind, name, STRUCT_DOMAIN);
  if (!symtab)
    return NULL;

  bv = BLOCKVECTOR (symtab);
  block = BLOCKVECTOR_BLOCK (bv, kind);
  sym = lookup_block_symbol (block, name, STRUCT_DOMAIN);
  if (!sym)
    error_in_psymtab_expansion (kind, name, symtab);

  if (!TYPE_IS_OPAQUE (SYMBOL_TYPE (sym)))
    return SYMBOL_TYPE (sym);

  return NULL;
}

/* The standard implementation of lookup_transparent_type.  This code
   was modeled on lookup_symbol -- the parts not relevant to looking
   up types were just left out.  In particular it's assumed here that
   types are available in struct_domain and only at file-static or
   global blocks.  */

struct type *
basic_lookup_transparent_type (const char *name)
{
  struct symbol *sym;
  struct symtab *s = NULL;
  struct blockvector *bv;
  struct objfile *objfile;
  struct block *block;
  struct type *t;

  /* Now search all the global symbols.  Do the symtab's first, then
     check the psymtab's.  If a psymtab indicates the existence
     of the desired name as a global, then do psymtab-to-symtab
     conversion on the fly and return the found symbol.  */

  ALL_OBJFILES (objfile)
  {
    ALL_OBJFILE_PRIMARY_SYMTABS (objfile, s)
      {
	bv = BLOCKVECTOR (s);
	block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
	sym = lookup_block_symbol (block, name, STRUCT_DOMAIN);
	if (sym && !TYPE_IS_OPAQUE (SYMBOL_TYPE (sym)))
	  {
	    return SYMBOL_TYPE (sym);
	  }
      }
  }

  ALL_OBJFILES (objfile)
  {
    t = basic_lookup_transparent_type_quick (objfile, GLOBAL_BLOCK, name);
    if (t)
      return t;
  }

  /* Now search the static file-level symbols.
     Not strictly correct, but more useful than an error.
     Do the symtab's first, then
     check the psymtab's.  If a psymtab indicates the existence
     of the desired name as a file-level static, then do psymtab-to-symtab
     conversion on the fly and return the found symbol.  */

  ALL_OBJFILES (objfile)
  {
    ALL_OBJFILE_PRIMARY_SYMTABS (objfile, s)
      {
	bv = BLOCKVECTOR (s);
	block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
	sym = lookup_block_symbol (block, name, STRUCT_DOMAIN);
	if (sym && !TYPE_IS_OPAQUE (SYMBOL_TYPE (sym)))
	  {
	    return SYMBOL_TYPE (sym);
	  }
      }
  }

  ALL_OBJFILES (objfile)
  {
    t = basic_lookup_transparent_type_quick (objfile, STATIC_BLOCK, name);
    if (t)
      return t;
  }

  return (struct type *) 0;
}

/* Search BLOCK for symbol NAME in DOMAIN.

   Note that if NAME is the demangled form of a C++ symbol, we will fail
   to find a match during the binary search of the non-encoded names, but
   for now we don't worry about the slight inefficiency of looking for
   a match we'll never find, since it will go pretty quick.  Once the
   binary search terminates, we drop through and do a straight linear
   search on the symbols.  Each symbol which is marked as being a ObjC/C++
   symbol (language_cplus or language_objc set) has both the encoded and
   non-encoded names tested for a match.  */

struct symbol *
lookup_block_symbol (const struct block *block, const char *name,
		     const domain_enum domain)
{
  struct block_iterator iter;
  struct symbol *sym;

  if (!BLOCK_FUNCTION (block))
    {
      for (sym = block_iter_name_first (block, name, &iter);
	   sym != NULL;
	   sym = block_iter_name_next (name, &iter))
	{
	  if (symbol_matches_domain (SYMBOL_LANGUAGE (sym),
				     SYMBOL_DOMAIN (sym), domain))
	    return sym;
	}
      return NULL;
    }
  else
    {
      /* Note that parameter symbols do not always show up last in the
	 list; this loop makes sure to take anything else other than
	 parameter symbols first; it only uses parameter symbols as a
	 last resort.  Note that this only takes up extra computation
	 time on a match.  */

      struct symbol *sym_found = NULL;

      for (sym = block_iter_name_first (block, name, &iter);
	   sym != NULL;
	   sym = block_iter_name_next (name, &iter))
	{
	  if (symbol_matches_domain (SYMBOL_LANGUAGE (sym),
				     SYMBOL_DOMAIN (sym), domain))
	    {
	      sym_found = sym;
	      if (!SYMBOL_IS_ARGUMENT (sym))
		{
		  break;
		}
	    }
	}
      return (sym_found);	/* Will be NULL if not found.  */
    }
}

/* Iterate over the symbols named NAME, matching DOMAIN, in BLOCK.
   
   For each symbol that matches, CALLBACK is called.  The symbol and
   DATA are passed to the callback.
   
   If CALLBACK returns zero, the iteration ends.  Otherwise, the
   search continues.  */

void
iterate_over_symbols (const struct block *block, const char *name,
		      const domain_enum domain,
		      symbol_found_callback_ftype *callback,
		      void *data)
{
  struct block_iterator iter;
  struct symbol *sym;

  for (sym = block_iter_name_first (block, name, &iter);
       sym != NULL;
       sym = block_iter_name_next (name, &iter))
    {
      if (symbol_matches_domain (SYMBOL_LANGUAGE (sym),
				 SYMBOL_DOMAIN (sym), domain))
	{
	  if (!callback (sym, data))
	    return;
	}
    }
}

/* Find the symtab associated with PC and SECTION.  Look through the
   psymtabs and read in another symtab if necessary.  */

struct symtab *
find_pc_sect_symtab (CORE_ADDR pc, struct obj_section *section)
{
  struct block *b;
  struct blockvector *bv;
  struct symtab *s = NULL;
  struct symtab *best_s = NULL;
  struct objfile *objfile;
  CORE_ADDR distance = 0;
  struct minimal_symbol *msymbol;

  /* If we know that this is not a text address, return failure.  This is
     necessary because we loop based on the block's high and low code
     addresses, which do not include the data ranges, and because
     we call find_pc_sect_psymtab which has a similar restriction based
     on the partial_symtab's texthigh and textlow.  */
  msymbol = lookup_minimal_symbol_by_pc_section (pc, section).minsym;
  if (msymbol
      && (MSYMBOL_TYPE (msymbol) == mst_data
	  || MSYMBOL_TYPE (msymbol) == mst_bss
	  || MSYMBOL_TYPE (msymbol) == mst_abs
	  || MSYMBOL_TYPE (msymbol) == mst_file_data
	  || MSYMBOL_TYPE (msymbol) == mst_file_bss))
    return NULL;

  /* Search all symtabs for the one whose file contains our address, and which
     is the smallest of all the ones containing the address.  This is designed
     to deal with a case like symtab a is at 0x1000-0x2000 and 0x3000-0x4000
     and symtab b is at 0x2000-0x3000.  So the GLOBAL_BLOCK for a is from
     0x1000-0x4000, but for address 0x2345 we want to return symtab b.

     This happens for native ecoff format, where code from included files
     gets its own symtab.  The symtab for the included file should have
     been read in already via the dependency mechanism.
     It might be swifter to create several symtabs with the same name
     like xcoff does (I'm not sure).

     It also happens for objfiles that have their functions reordered.
     For these, the symtab we are looking for is not necessarily read in.  */

  ALL_PRIMARY_SYMTABS (objfile, s)
  {
    bv = BLOCKVECTOR (s);
    b = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);

    if (BLOCK_START (b) <= pc
	&& BLOCK_END (b) > pc
	&& (distance == 0
	    || BLOCK_END (b) - BLOCK_START (b) < distance))
      {
	/* For an objfile that has its functions reordered,
	   find_pc_psymtab will find the proper partial symbol table
	   and we simply return its corresponding symtab.  */
	/* In order to better support objfiles that contain both
	   stabs and coff debugging info, we continue on if a psymtab
	   can't be found.  */
	if ((objfile->flags & OBJF_REORDERED) && objfile->sf)
	  {
	    struct symtab *result;

	    result
	      = objfile->sf->qf->find_pc_sect_symtab (objfile,
						      msymbol,
						      pc, section,
						      0);
	    if (result)
	      return result;
	  }
	if (section != 0)
	  {
	    struct block_iterator iter;
	    struct symbol *sym = NULL;

	    ALL_BLOCK_SYMBOLS (b, iter, sym)
	      {
		fixup_symbol_section (sym, objfile);
		if (matching_obj_sections (SYMBOL_OBJ_SECTION (objfile, sym),
					   section))
		  break;
	      }
	    if (sym == NULL)
	      continue;		/* No symbol in this symtab matches
				   section.  */
	  }
	distance = BLOCK_END (b) - BLOCK_START (b);
	best_s = s;
      }
  }

  if (best_s != NULL)
    return (best_s);

  /* Not found in symtabs, search the "quick" symtabs (e.g. psymtabs).  */

  ALL_OBJFILES (objfile)
  {
    struct symtab *result;

    if (!objfile->sf)
      continue;
    result = objfile->sf->qf->find_pc_sect_symtab (objfile,
						   msymbol,
						   pc, section,
						   1);
    if (result)
      return result;
  }

  return NULL;
}

/* Find the symtab associated with PC.  Look through the psymtabs and read
   in another symtab if necessary.  Backward compatibility, no section.  */

struct symtab *
find_pc_symtab (CORE_ADDR pc)
{
  return find_pc_sect_symtab (pc, find_pc_mapped_section (pc));
}


/* Find the source file and line number for a given PC value and SECTION.
   Return a structure containing a symtab pointer, a line number,
   and a pc range for the entire source line.
   The value's .pc field is NOT the specified pc.
   NOTCURRENT nonzero means, if specified pc is on a line boundary,
   use the line that ends there.  Otherwise, in that case, the line
   that begins there is used.  */

/* The big complication here is that a line may start in one file, and end just
   before the start of another file.  This usually occurs when you #include
   code in the middle of a subroutine.  To properly find the end of a line's PC
   range, we must search all symtabs associated with this compilation unit, and
   find the one whose first PC is closer than that of the next line in this
   symtab.  */

/* If it's worth the effort, we could be using a binary search.  */

struct symtab_and_line
find_pc_sect_line (CORE_ADDR pc, struct obj_section *section, int notcurrent)
{
  struct symtab *s;
  struct linetable *l;
  int len;
  int i;
  struct linetable_entry *item;
  struct symtab_and_line val;
  struct blockvector *bv;
  struct bound_minimal_symbol msymbol;
  struct minimal_symbol *mfunsym;
  struct objfile *objfile;

  /* Info on best line seen so far, and where it starts, and its file.  */

  struct linetable_entry *best = NULL;
  CORE_ADDR best_end = 0;
  struct symtab *best_symtab = 0;

  /* Store here the first line number
     of a file which contains the line at the smallest pc after PC.
     If we don't find a line whose range contains PC,
     we will use a line one less than this,
     with a range from the start of that file to the first line's pc.  */
  struct linetable_entry *alt = NULL;

  /* Info on best line seen in this file.  */

  struct linetable_entry *prev;

  /* If this pc is not from the current frame,
     it is the address of the end of a call instruction.
     Quite likely that is the start of the following statement.
     But what we want is the statement containing the instruction.
     Fudge the pc to make sure we get that.  */

  init_sal (&val);		/* initialize to zeroes */

  val.pspace = current_program_space;

  /* It's tempting to assume that, if we can't find debugging info for
     any function enclosing PC, that we shouldn't search for line
     number info, either.  However, GAS can emit line number info for
     assembly files --- very helpful when debugging hand-written
     assembly code.  In such a case, we'd have no debug info for the
     function, but we would have line info.  */

  if (notcurrent)
    pc -= 1;

  /* elz: added this because this function returned the wrong
     information if the pc belongs to a stub (import/export)
     to call a shlib function.  This stub would be anywhere between
     two functions in the target, and the line info was erroneously
     taken to be the one of the line before the pc.  */

  /* RT: Further explanation:

   * We have stubs (trampolines) inserted between procedures.
   *
   * Example: "shr1" exists in a shared library, and a "shr1" stub also
   * exists in the main image.
   *
   * In the minimal symbol table, we have a bunch of symbols
   * sorted by start address.  The stubs are marked as "trampoline",
   * the others appear as text. E.g.:
   *
   *  Minimal symbol table for main image
   *     main:  code for main (text symbol)
   *     shr1: stub  (trampoline symbol)
   *     foo:   code for foo (text symbol)
   *     ...
   *  Minimal symbol table for "shr1" image:
   *     ...
   *     shr1: code for shr1 (text symbol)
   *     ...
   *
   * So the code below is trying to detect if we are in the stub
   * ("shr1" stub), and if so, find the real code ("shr1" trampoline),
   * and if found,  do the symbolization from the real-code address
   * rather than the stub address.
   *
   * Assumptions being made about the minimal symbol table:
   *   1. lookup_minimal_symbol_by_pc() will return a trampoline only
   *      if we're really in the trampoline.s If we're beyond it (say
   *      we're in "foo" in the above example), it'll have a closer
   *      symbol (the "foo" text symbol for example) and will not
   *      return the trampoline.
   *   2. lookup_minimal_symbol_text() will find a real text symbol
   *      corresponding to the trampoline, and whose address will
   *      be different than the trampoline address.  I put in a sanity
   *      check for the address being the same, to avoid an
   *      infinite recursion.
   */
  msymbol = lookup_minimal_symbol_by_pc (pc);
  if (msymbol.minsym != NULL)
    if (MSYMBOL_TYPE (msymbol.minsym) == mst_solib_trampoline)
      {
	mfunsym
	  = lookup_minimal_symbol_text (SYMBOL_LINKAGE_NAME (msymbol.minsym),
					NULL);
	if (mfunsym == NULL)
	  /* I eliminated this warning since it is coming out
	   * in the following situation:
	   * gdb shmain // test program with shared libraries
	   * (gdb) break shr1  // function in shared lib
	   * Warning: In stub for ...
	   * In the above situation, the shared lib is not loaded yet,
	   * so of course we can't find the real func/line info,
	   * but the "break" still works, and the warning is annoying.
	   * So I commented out the warning.  RT */
	  /* warning ("In stub for %s; unable to find real function/line info",
	     SYMBOL_LINKAGE_NAME (msymbol)); */
	  ;
	/* fall through */
	else if (SYMBOL_VALUE_ADDRESS (mfunsym)
		 == SYMBOL_VALUE_ADDRESS (msymbol.minsym))
	  /* Avoid infinite recursion */
	  /* See above comment about why warning is commented out.  */
	  /* warning ("In stub for %s; unable to find real function/line info",
	     SYMBOL_LINKAGE_NAME (msymbol)); */
	  ;
	/* fall through */
	else
	  return find_pc_line (SYMBOL_VALUE_ADDRESS (mfunsym), 0);
      }


  s = find_pc_sect_symtab (pc, section);
  if (!s)
    {
      /* If no symbol information, return previous pc.  */
      if (notcurrent)
	pc++;
      val.pc = pc;
      return val;
    }

  bv = BLOCKVECTOR (s);
  objfile = s->objfile;

  /* Look at all the symtabs that share this blockvector.
     They all have the same apriori range, that we found was right;
     but they have different line tables.  */

  ALL_OBJFILE_SYMTABS (objfile, s)
    {
      if (BLOCKVECTOR (s) != bv)
	continue;

      /* Find the best line in this symtab.  */
      l = LINETABLE (s);
      if (!l)
	continue;
      len = l->nitems;
      if (len <= 0)
	{
	  /* I think len can be zero if the symtab lacks line numbers
	     (e.g. gcc -g1).  (Either that or the LINETABLE is NULL;
	     I'm not sure which, and maybe it depends on the symbol
	     reader).  */
	  continue;
	}

      prev = NULL;
      item = l->item;		/* Get first line info.  */

      /* Is this file's first line closer than the first lines of other files?
         If so, record this file, and its first line, as best alternate.  */
      if (item->pc > pc && (!alt || item->pc < alt->pc))
	alt = item;

      for (i = 0; i < len; i++, item++)
	{
	  /* Leave prev pointing to the linetable entry for the last line
	     that started at or before PC.  */
	  if (item->pc > pc)
	    break;

	  prev = item;
	}

      /* At this point, prev points at the line whose start addr is <= pc, and
         item points at the next line.  If we ran off the end of the linetable
         (pc >= start of the last line), then prev == item.  If pc < start of
         the first line, prev will not be set.  */

      /* Is this file's best line closer than the best in the other files?
         If so, record this file, and its best line, as best so far.  Don't
         save prev if it represents the end of a function (i.e. line number
         0) instead of a real line.  */

      if (prev && prev->line && (!best || prev->pc > best->pc))
	{
	  best = prev;
	  best_symtab = s;

	  /* Discard BEST_END if it's before the PC of the current BEST.  */
	  if (best_end <= best->pc)
	    best_end = 0;
	}

      /* If another line (denoted by ITEM) is in the linetable and its
         PC is after BEST's PC, but before the current BEST_END, then
	 use ITEM's PC as the new best_end.  */
      if (best && i < len && item->pc > best->pc
          && (best_end == 0 || best_end > item->pc))
	best_end = item->pc;
    }

  if (!best_symtab)
    {
      /* If we didn't find any line number info, just return zeros.
	 We used to return alt->line - 1 here, but that could be
	 anywhere; if we don't have line number info for this PC,
	 don't make some up.  */
      val.pc = pc;
    }
  else if (best->line == 0)
    {
      /* If our best fit is in a range of PC's for which no line
	 number info is available (line number is zero) then we didn't
	 find any valid line information.  */
      val.pc = pc;
    }
  else
    {
      val.symtab = best_symtab;
      val.line = best->line;
      val.pc = best->pc;
      if (best_end && (!alt || best_end < alt->pc))
	val.end = best_end;
      else if (alt)
	val.end = alt->pc;
      else
	val.end = BLOCK_END (BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK));
    }
  val.section = section;
  return val;
}

/* Backward compatibility (no section).  */

struct symtab_and_line
find_pc_line (CORE_ADDR pc, int notcurrent)
{
  struct obj_section *section;

  section = find_pc_overlay (pc);
  if (pc_in_unmapped_range (pc, section))
    pc = overlay_mapped_address (pc, section);
  return find_pc_sect_line (pc, section, notcurrent);
}

/* Find line number LINE in any symtab whose name is the same as
   SYMTAB.

   If found, return the symtab that contains the linetable in which it was
   found, set *INDEX to the index in the linetable of the best entry
   found, and set *EXACT_MATCH nonzero if the value returned is an
   exact match.

   If not found, return NULL.  */

struct symtab *
find_line_symtab (struct symtab *symtab, int line,
		  int *index, int *exact_match)
{
  int exact = 0;  /* Initialized here to avoid a compiler warning.  */

  /* BEST_INDEX and BEST_LINETABLE identify the smallest linenumber > LINE
     so far seen.  */

  int best_index;
  struct linetable *best_linetable;
  struct symtab *best_symtab;

  /* First try looking it up in the given symtab.  */
  best_linetable = LINETABLE (symtab);
  best_symtab = symtab;
  best_index = find_line_common (best_linetable, line, &exact, 0);
  if (best_index < 0 || !exact)
    {
      /* Didn't find an exact match.  So we better keep looking for
         another symtab with the same name.  In the case of xcoff,
         multiple csects for one source file (produced by IBM's FORTRAN
         compiler) produce multiple symtabs (this is unavoidable
         assuming csects can be at arbitrary places in memory and that
         the GLOBAL_BLOCK of a symtab has a begin and end address).  */

      /* BEST is the smallest linenumber > LINE so far seen,
         or 0 if none has been seen so far.
         BEST_INDEX and BEST_LINETABLE identify the item for it.  */
      int best;

      struct objfile *objfile;
      struct symtab *s;

      if (best_index >= 0)
	best = best_linetable->item[best_index].line;
      else
	best = 0;

      ALL_OBJFILES (objfile)
      {
	if (objfile->sf)
	  objfile->sf->qf->expand_symtabs_with_fullname (objfile,
						   symtab_to_fullname (symtab));
      }

      ALL_SYMTABS (objfile, s)
      {
	struct linetable *l;
	int ind;

	if (FILENAME_CMP (symtab->filename, s->filename) != 0)
	  continue;
	if (FILENAME_CMP (symtab_to_fullname (symtab),
			  symtab_to_fullname (s)) != 0)
	  continue;	
	l = LINETABLE (s);
	ind = find_line_common (l, line, &exact, 0);
	if (ind >= 0)
	  {
	    if (exact)
	      {
		best_index = ind;
		best_linetable = l;
		best_symtab = s;
		goto done;
	      }
	    if (best == 0 || l->item[ind].line < best)
	      {
		best = l->item[ind].line;
		best_index = ind;
		best_linetable = l;
		best_symtab = s;
	      }
	  }
      }
    }
done:
  if (best_index < 0)
    return NULL;

  if (index)
    *index = best_index;
  if (exact_match)
    *exact_match = exact;

  return best_symtab;
}

/* Given SYMTAB, returns all the PCs function in the symtab that
   exactly match LINE.  Returns NULL if there are no exact matches,
   but updates BEST_ITEM in this case.  */

VEC (CORE_ADDR) *
find_pcs_for_symtab_line (struct symtab *symtab, int line,
			  struct linetable_entry **best_item)
{
  int start = 0;
  VEC (CORE_ADDR) *result = NULL;

  /* First, collect all the PCs that are at this line.  */
  while (1)
    {
      int was_exact;
      int idx;

      idx = find_line_common (LINETABLE (symtab), line, &was_exact, start);
      if (idx < 0)
	break;

      if (!was_exact)
	{
	  struct linetable_entry *item = &LINETABLE (symtab)->item[idx];

	  if (*best_item == NULL || item->line < (*best_item)->line)
	    *best_item = item;

	  break;
	}

      VEC_safe_push (CORE_ADDR, result, LINETABLE (symtab)->item[idx].pc);
      start = idx + 1;
    }

  return result;
}


/* Set the PC value for a given source file and line number and return true.
   Returns zero for invalid line number (and sets the PC to 0).
   The source file is specified with a struct symtab.  */

int
find_line_pc (struct symtab *symtab, int line, CORE_ADDR *pc)
{
  struct linetable *l;
  int ind;

  *pc = 0;
  if (symtab == 0)
    return 0;

  symtab = find_line_symtab (symtab, line, &ind, NULL);
  if (symtab != NULL)
    {
      l = LINETABLE (symtab);
      *pc = l->item[ind].pc;
      return 1;
    }
  else
    return 0;
}

/* Find the range of pc values in a line.
   Store the starting pc of the line into *STARTPTR
   and the ending pc (start of next line) into *ENDPTR.
   Returns 1 to indicate success.
   Returns 0 if could not find the specified line.  */

int
find_line_pc_range (struct symtab_and_line sal, CORE_ADDR *startptr,
		    CORE_ADDR *endptr)
{
  CORE_ADDR startaddr;
  struct symtab_and_line found_sal;

  startaddr = sal.pc;
  if (startaddr == 0 && !find_line_pc (sal.symtab, sal.line, &startaddr))
    return 0;

  /* This whole function is based on address.  For example, if line 10 has
     two parts, one from 0x100 to 0x200 and one from 0x300 to 0x400, then
     "info line *0x123" should say the line goes from 0x100 to 0x200
     and "info line *0x355" should say the line goes from 0x300 to 0x400.
     This also insures that we never give a range like "starts at 0x134
     and ends at 0x12c".  */

  found_sal = find_pc_sect_line (startaddr, sal.section, 0);
  if (found_sal.line != sal.line)
    {
      /* The specified line (sal) has zero bytes.  */
      *startptr = found_sal.pc;
      *endptr = found_sal.pc;
    }
  else
    {
      *startptr = found_sal.pc;
      *endptr = found_sal.end;
    }
  return 1;
}

/* Given a line table and a line number, return the index into the line
   table for the pc of the nearest line whose number is >= the specified one.
   Return -1 if none is found.  The value is >= 0 if it is an index.
   START is the index at which to start searching the line table.

   Set *EXACT_MATCH nonzero if the value returned is an exact match.  */

static int
find_line_common (struct linetable *l, int lineno,
		  int *exact_match, int start)
{
  int i;
  int len;

  /* BEST is the smallest linenumber > LINENO so far seen,
     or 0 if none has been seen so far.
     BEST_INDEX identifies the item for it.  */

  int best_index = -1;
  int best = 0;

  *exact_match = 0;

  if (lineno <= 0)
    return -1;
  if (l == 0)
    return -1;

  len = l->nitems;
  for (i = start; i < len; i++)
    {
      struct linetable_entry *item = &(l->item[i]);

      if (item->line == lineno)
	{
	  /* Return the first (lowest address) entry which matches.  */
	  *exact_match = 1;
	  return i;
	}

      if (item->line > lineno && (best == 0 || item->line < best))
	{
	  best = item->line;
	  best_index = i;
	}
    }

  /* If we got here, we didn't get an exact match.  */
  return best_index;
}

int
find_pc_line_pc_range (CORE_ADDR pc, CORE_ADDR *startptr, CORE_ADDR *endptr)
{
  struct symtab_and_line sal;

  sal = find_pc_line (pc, 0);
  *startptr = sal.pc;
  *endptr = sal.end;
  return sal.symtab != 0;
}

/* Given a function start address FUNC_ADDR and SYMTAB, find the first
   address for that function that has an entry in SYMTAB's line info
   table.  If such an entry cannot be found, return FUNC_ADDR
   unaltered.  */

static CORE_ADDR
skip_prologue_using_lineinfo (CORE_ADDR func_addr, struct symtab *symtab)
{
  CORE_ADDR func_start, func_end;
  struct linetable *l;
  int i;

  /* Give up if this symbol has no lineinfo table.  */
  l = LINETABLE (symtab);
  if (l == NULL)
    return func_addr;

  /* Get the range for the function's PC values, or give up if we
     cannot, for some reason.  */
  if (!find_pc_partial_function (func_addr, NULL, &func_start, &func_end))
    return func_addr;

  /* Linetable entries are ordered by PC values, see the commentary in
     symtab.h where `struct linetable' is defined.  Thus, the first
     entry whose PC is in the range [FUNC_START..FUNC_END[ is the
     address we are looking for.  */
  for (i = 0; i < l->nitems; i++)
    {
      struct linetable_entry *item = &(l->item[i]);

      /* Don't use line numbers of zero, they mark special entries in
	 the table.  See the commentary on symtab.h before the
	 definition of struct linetable.  */
      if (item->line > 0 && func_start <= item->pc && item->pc < func_end)
	return item->pc;
    }

  return func_addr;
}

/* Given a function symbol SYM, find the symtab and line for the start
   of the function.
   If the argument FUNFIRSTLINE is nonzero, we want the first line
   of real code inside the function.  */

struct symtab_and_line
find_function_start_sal (struct symbol *sym, int funfirstline)
{
  struct symtab_and_line sal;

  fixup_symbol_section (sym, NULL);
  sal = find_pc_sect_line (BLOCK_START (SYMBOL_BLOCK_VALUE (sym)),
			   SYMBOL_OBJ_SECTION (SYMBOL_OBJFILE (sym), sym), 0);

  /* We always should have a line for the function start address.
     If we don't, something is odd.  Create a plain SAL refering
     just the PC and hope that skip_prologue_sal (if requested)
     can find a line number for after the prologue.  */
  if (sal.pc < BLOCK_START (SYMBOL_BLOCK_VALUE (sym)))
    {
      init_sal (&sal);
      sal.pspace = current_program_space;
      sal.pc = BLOCK_START (SYMBOL_BLOCK_VALUE (sym));
      sal.section = SYMBOL_OBJ_SECTION (SYMBOL_OBJFILE (sym), sym);
    }

  if (funfirstline)
    skip_prologue_sal (&sal);

  return sal;
}

/* Adjust SAL to the first instruction past the function prologue.
   If the PC was explicitly specified, the SAL is not changed.
   If the line number was explicitly specified, at most the SAL's PC
   is updated.  If SAL is already past the prologue, then do nothing.  */

void
skip_prologue_sal (struct symtab_and_line *sal)
{
  struct symbol *sym;
  struct symtab_and_line start_sal;
  struct cleanup *old_chain;
  CORE_ADDR pc, saved_pc;
  struct obj_section *section;
  const char *name;
  struct objfile *objfile;
  struct gdbarch *gdbarch;
  struct block *b, *function_block;
  int force_skip, skip;

  /* Do not change the SAL if PC was specified explicitly.  */
  if (sal->explicit_pc)
    return;

  old_chain = save_current_space_and_thread ();
  switch_to_program_space_and_thread (sal->pspace);

  sym = find_pc_sect_function (sal->pc, sal->section);
  if (sym != NULL)
    {
      fixup_symbol_section (sym, NULL);

      pc = BLOCK_START (SYMBOL_BLOCK_VALUE (sym));
      section = SYMBOL_OBJ_SECTION (SYMBOL_OBJFILE (sym), sym);
      name = SYMBOL_LINKAGE_NAME (sym);
      objfile = SYMBOL_SYMTAB (sym)->objfile;
    }
  else
    {
      struct bound_minimal_symbol msymbol
        = lookup_minimal_symbol_by_pc_section (sal->pc, sal->section);

      if (msymbol.minsym == NULL)
	{
	  do_cleanups (old_chain);
	  return;
	}

      objfile = msymbol.objfile;
      pc = SYMBOL_VALUE_ADDRESS (msymbol.minsym);
      section = SYMBOL_OBJ_SECTION (objfile, msymbol.minsym);
      name = SYMBOL_LINKAGE_NAME (msymbol.minsym);
    }

  gdbarch = get_objfile_arch (objfile);

  /* Process the prologue in two passes.  In the first pass try to skip the
     prologue (SKIP is true) and verify there is a real need for it (indicated
     by FORCE_SKIP).  If no such reason was found run a second pass where the
     prologue is not skipped (SKIP is false).  */

  skip = 1;
  force_skip = 1;

  /* Be conservative - allow direct PC (without skipping prologue) only if we
     have proven the CU (Compilation Unit) supports it.  sal->SYMTAB does not
     have to be set by the caller so we use SYM instead.  */
  if (sym && SYMBOL_SYMTAB (sym)->locations_valid)
    force_skip = 0;

  saved_pc = pc;
  do
    {
      pc = saved_pc;

      /* If the function is in an unmapped overlay, use its unmapped LMA address,
	 so that gdbarch_skip_prologue has something unique to work on.  */
      if (section_is_overlay (section) && !section_is_mapped (section))
	pc = overlay_unmapped_address (pc, section);

      /* Skip "first line" of function (which is actually its prologue).  */
      pc += gdbarch_deprecated_function_start_offset (gdbarch);
      if (skip)
	pc = gdbarch_skip_prologue (gdbarch, pc);

      /* For overlays, map pc back into its mapped VMA range.  */
      pc = overlay_mapped_address (pc, section);

      /* Calculate line number.  */
      start_sal = find_pc_sect_line (pc, section, 0);

      /* Check if gdbarch_skip_prologue left us in mid-line, and the next
	 line is still part of the same function.  */
      if (skip && start_sal.pc != pc
	  && (sym ? (BLOCK_START (SYMBOL_BLOCK_VALUE (sym)) <= start_sal.end
		     && start_sal.end < BLOCK_END (SYMBOL_BLOCK_VALUE (sym)))
	      : (lookup_minimal_symbol_by_pc_section (start_sal.end, section).minsym
		 == lookup_minimal_symbol_by_pc_section (pc, section).minsym)))
	{
	  /* First pc of next line */
	  pc = start_sal.end;
	  /* Recalculate the line number (might not be N+1).  */
	  start_sal = find_pc_sect_line (pc, section, 0);
	}

      /* On targets with executable formats that don't have a concept of
	 constructors (ELF with .init has, PE doesn't), gcc emits a call
	 to `__main' in `main' between the prologue and before user
	 code.  */
      if (gdbarch_skip_main_prologue_p (gdbarch)
	  && name && strcmp_iw (name, "main") == 0)
	{
	  pc = gdbarch_skip_main_prologue (gdbarch, pc);
	  /* Recalculate the line number (might not be N+1).  */
	  start_sal = find_pc_sect_line (pc, section, 0);
	  force_skip = 1;
	}
    }
  while (!force_skip && skip--);

  /* If we still don't have a valid source line, try to find the first
     PC in the lineinfo table that belongs to the same function.  This
     happens with COFF debug info, which does not seem to have an
     entry in lineinfo table for the code after the prologue which has
     no direct relation to source.  For example, this was found to be
     the case with the DJGPP target using "gcc -gcoff" when the
     compiler inserted code after the prologue to make sure the stack
     is aligned.  */
  if (!force_skip && sym && start_sal.symtab == NULL)
    {
      pc = skip_prologue_using_lineinfo (pc, SYMBOL_SYMTAB (sym));
      /* Recalculate the line number.  */
      start_sal = find_pc_sect_line (pc, section, 0);
    }

  do_cleanups (old_chain);

  /* If we're already past the prologue, leave SAL unchanged.  Otherwise
     forward SAL to the end of the prologue.  */
  if (sal->pc >= pc)
    return;

  sal->pc = pc;
  sal->section = section;

  /* Unless the explicit_line flag was set, update the SAL line
     and symtab to correspond to the modified PC location.  */
  if (sal->explicit_line)
    return;

  sal->symtab = start_sal.symtab;
  sal->line = start_sal.line;
  sal->end = start_sal.end;

  /* Check if we are now inside an inlined function.  If we can,
     use the call site of the function instead.  */
  b = block_for_pc_sect (sal->pc, sal->section);
  function_block = NULL;
  while (b != NULL)
    {
      if (BLOCK_FUNCTION (b) != NULL && block_inlined_p (b))
	function_block = b;
      else if (BLOCK_FUNCTION (b) != NULL)
	break;
      b = BLOCK_SUPERBLOCK (b);
    }
  if (function_block != NULL
      && SYMBOL_LINE (BLOCK_FUNCTION (function_block)) != 0)
    {
      sal->line = SYMBOL_LINE (BLOCK_FUNCTION (function_block));
      sal->symtab = SYMBOL_SYMTAB (BLOCK_FUNCTION (function_block));
    }
}

/* If P is of the form "operator[ \t]+..." where `...' is
   some legitimate operator text, return a pointer to the
   beginning of the substring of the operator text.
   Otherwise, return "".  */

static char *
operator_chars (char *p, char **end)
{
  *end = "";
  if (strncmp (p, "operator", 8))
    return *end;
  p += 8;

  /* Don't get faked out by `operator' being part of a longer
     identifier.  */
  if (isalpha (*p) || *p == '_' || *p == '$' || *p == '\0')
    return *end;

  /* Allow some whitespace between `operator' and the operator symbol.  */
  while (*p == ' ' || *p == '\t')
    p++;

  /* Recognize 'operator TYPENAME'.  */

  if (isalpha (*p) || *p == '_' || *p == '$')
    {
      char *q = p + 1;

      while (isalnum (*q) || *q == '_' || *q == '$')
	q++;
      *end = q;
      return p;
    }

  while (*p)
    switch (*p)
      {
      case '\\':			/* regexp quoting */
	if (p[1] == '*')
	  {
	    if (p[2] == '=')		/* 'operator\*=' */
	      *end = p + 3;
	    else			/* 'operator\*'  */
	      *end = p + 2;
	    return p;
	  }
	else if (p[1] == '[')
	  {
	    if (p[2] == ']')
	      error (_("mismatched quoting on brackets, "
		       "try 'operator\\[\\]'"));
	    else if (p[2] == '\\' && p[3] == ']')
	      {
		*end = p + 4;	/* 'operator\[\]' */
		return p;
	      }
	    else
	      error (_("nothing is allowed between '[' and ']'"));
	  }
	else
	  {
	    /* Gratuitous qoute: skip it and move on.  */
	    p++;
	    continue;
	  }
	break;
      case '!':
      case '=':
      case '*':
      case '/':
      case '%':
      case '^':
	if (p[1] == '=')
	  *end = p + 2;
	else
	  *end = p + 1;
	return p;
      case '<':
      case '>':
      case '+':
      case '-':
      case '&':
      case '|':
	if (p[0] == '-' && p[1] == '>')
	  {
	    /* Struct pointer member operator 'operator->'.  */
	    if (p[2] == '*')
	      {
		*end = p + 3;	/* 'operator->*' */
		return p;
	      }
	    else if (p[2] == '\\')
	      {
		*end = p + 4;	/* Hopefully 'operator->\*' */
		return p;
	      }
	    else
	      {
		*end = p + 2;	/* 'operator->' */
		return p;
	      }
	  }
	if (p[1] == '=' || p[1] == p[0])
	  *end = p + 2;
	else
	  *end = p + 1;
	return p;
      case '~':
      case ',':
	*end = p + 1;
	return p;
      case '(':
	if (p[1] != ')')
	  error (_("`operator ()' must be specified "
		   "without whitespace in `()'"));
	*end = p + 2;
	return p;
      case '?':
	if (p[1] != ':')
	  error (_("`operator ?:' must be specified "
		   "without whitespace in `?:'"));
	*end = p + 2;
	return p;
      case '[':
	if (p[1] != ']')
	  error (_("`operator []' must be specified "
		   "without whitespace in `[]'"));
	*end = p + 2;
	return p;
      default:
	error (_("`operator %s' not supported"), p);
	break;
      }

  *end = "";
  return *end;
}


/* Cache to watch for file names already seen by filename_seen.  */

struct filename_seen_cache
{
  /* Table of files seen so far.  */
  htab_t tab;
  /* Initial size of the table.  It automagically grows from here.  */
#define INITIAL_FILENAME_SEEN_CACHE_SIZE 100
};

/* filename_seen_cache constructor.  */

static struct filename_seen_cache *
create_filename_seen_cache (void)
{
  struct filename_seen_cache *cache;

  cache = XNEW (struct filename_seen_cache);
  cache->tab = htab_create_alloc (INITIAL_FILENAME_SEEN_CACHE_SIZE,
				  filename_hash, filename_eq,
				  NULL, xcalloc, xfree);

  return cache;
}

/* Empty the cache, but do not delete it.  */

static void
clear_filename_seen_cache (struct filename_seen_cache *cache)
{
  htab_empty (cache->tab);
}

/* filename_seen_cache destructor.
   This takes a void * argument as it is generally used as a cleanup.  */

static void
delete_filename_seen_cache (void *ptr)
{
  struct filename_seen_cache *cache = ptr;

  htab_delete (cache->tab);
  xfree (cache);
}

/* If FILE is not already in the table of files in CACHE, return zero;
   otherwise return non-zero.  Optionally add FILE to the table if ADD
   is non-zero.

   NOTE: We don't manage space for FILE, we assume FILE lives as long
   as the caller needs.  */

static int
filename_seen (struct filename_seen_cache *cache, const char *file, int add)
{
  void **slot;

  /* Is FILE in tab?  */
  slot = htab_find_slot (cache->tab, file, add ? INSERT : NO_INSERT);
  if (*slot != NULL)
    return 1;

  /* No; maybe add it to tab.  */
  if (add)
    *slot = (char *) file;

  return 0;
}

/* Data structure to maintain printing state for output_source_filename.  */

struct output_source_filename_data
{
  /* Cache of what we've seen so far.  */
  struct filename_seen_cache *filename_seen_cache;

  /* Flag of whether we're printing the first one.  */
  int first;
};

/* Slave routine for sources_info.  Force line breaks at ,'s.
   NAME is the name to print.
   DATA contains the state for printing and watching for duplicates.  */

static void
output_source_filename (const char *name,
			struct output_source_filename_data *data)
{
  /* Since a single source file can result in several partial symbol
     tables, we need to avoid printing it more than once.  Note: if
     some of the psymtabs are read in and some are not, it gets
     printed both under "Source files for which symbols have been
     read" and "Source files for which symbols will be read in on
     demand".  I consider this a reasonable way to deal with the
     situation.  I'm not sure whether this can also happen for
     symtabs; it doesn't hurt to check.  */

  /* Was NAME already seen?  */
  if (filename_seen (data->filename_seen_cache, name, 1))
    {
      /* Yes; don't print it again.  */
      return;
    }

  /* No; print it and reset *FIRST.  */
  if (! data->first)
    printf_filtered (", ");
  data->first = 0;

  wrap_here ("");
  fputs_filtered (name, gdb_stdout);
}

/* A callback for map_partial_symbol_filenames.  */

static void
output_partial_symbol_filename (const char *filename, const char *fullname,
				void *data)
{
  output_source_filename (fullname ? fullname : filename, data);
}

static void
sources_info (char *ignore, int from_tty)
{
  struct symtab *s;
  struct objfile *objfile;
  struct output_source_filename_data data;
  struct cleanup *cleanups;

  if (!have_full_symbols () && !have_partial_symbols ())
    {
      error (_("No symbol table is loaded.  Use the \"file\" command."));
    }

  data.filename_seen_cache = create_filename_seen_cache ();
  cleanups = make_cleanup (delete_filename_seen_cache,
			   data.filename_seen_cache);

  printf_filtered ("Source files for which symbols have been read in:\n\n");

  data.first = 1;
  ALL_SYMTABS (objfile, s)
  {
    const char *fullname = symtab_to_fullname (s);

    output_source_filename (fullname, &data);
  }
  printf_filtered ("\n\n");

  printf_filtered ("Source files for which symbols "
		   "will be read in on demand:\n\n");

  clear_filename_seen_cache (data.filename_seen_cache);
  data.first = 1;
  map_partial_symbol_filenames (output_partial_symbol_filename, &data,
				1 /*need_fullname*/);
  printf_filtered ("\n");

  do_cleanups (cleanups);
}

/* Compare FILE against all the NFILES entries of FILES.  If BASENAMES is
   non-zero compare only lbasename of FILES.  */

static int
file_matches (const char *file, char *files[], int nfiles, int basenames)
{
  int i;

  if (file != NULL && nfiles != 0)
    {
      for (i = 0; i < nfiles; i++)
	{
	  if (compare_filenames_for_search (file, (basenames
						   ? lbasename (files[i])
						   : files[i])))
	    return 1;
	}
    }
  else if (nfiles == 0)
    return 1;
  return 0;
}

/* Free any memory associated with a search.  */

void
free_search_symbols (struct symbol_search *symbols)
{
  struct symbol_search *p;
  struct symbol_search *next;

  for (p = symbols; p != NULL; p = next)
    {
      next = p->next;
      xfree (p);
    }
}

static void
do_free_search_symbols_cleanup (void *symbolsp)
{
  struct symbol_search *symbols = *(struct symbol_search **) symbolsp;

  free_search_symbols (symbols);
}

struct cleanup *
make_cleanup_free_search_symbols (struct symbol_search **symbolsp)
{
  return make_cleanup (do_free_search_symbols_cleanup, symbolsp);
}

/* Helper function for sort_search_symbols_remove_dups and qsort.  Can only
   sort symbols, not minimal symbols.  */

static int
compare_search_syms (const void *sa, const void *sb)
{
  struct symbol_search *sym_a = *(struct symbol_search **) sa;
  struct symbol_search *sym_b = *(struct symbol_search **) sb;
  int c;

  c = FILENAME_CMP (sym_a->symtab->filename, sym_b->symtab->filename);
  if (c != 0)
    return c;

  if (sym_a->block != sym_b->block)
    return sym_a->block - sym_b->block;

  return strcmp (SYMBOL_PRINT_NAME (sym_a->symbol),
		 SYMBOL_PRINT_NAME (sym_b->symbol));
}

/* Sort the NFOUND symbols in list FOUND and remove duplicates.
   The duplicates are freed, and the new list is returned in
   *NEW_HEAD, *NEW_TAIL.  */

static void
sort_search_symbols_remove_dups (struct symbol_search *found, int nfound,
				 struct symbol_search **new_head,
				 struct symbol_search **new_tail)
{
  struct symbol_search **symbols, *symp, *old_next;
  int i, j, nunique;

  gdb_assert (found != NULL && nfound > 0);

  /* Build an array out of the list so we can easily sort them.  */
  symbols = (struct symbol_search **) xmalloc (sizeof (struct symbol_search *)
					       * nfound);
  symp = found;
  for (i = 0; i < nfound; i++)
    {
      gdb_assert (symp != NULL);
      gdb_assert (symp->block >= 0 && symp->block <= 1);
      symbols[i] = symp;
      symp = symp->next;
    }
  gdb_assert (symp == NULL);

  qsort (symbols, nfound, sizeof (struct symbol_search *),
	 compare_search_syms);

  /* Collapse out the dups.  */
  for (i = 1, j = 1; i < nfound; ++i)
    {
      if (compare_search_syms (&symbols[j - 1], &symbols[i]) != 0)
	symbols[j++] = symbols[i];
      else
	xfree (symbols[i]);
    }
  nunique = j;
  symbols[j - 1]->next = NULL;

  /* Rebuild the linked list.  */
  for (i = 0; i < nunique - 1; i++)
    symbols[i]->next = symbols[i + 1];
  symbols[nunique - 1]->next = NULL;

  *new_head = symbols[0];
  *new_tail = symbols[nunique - 1];
  xfree (symbols);
}

/* An object of this type is passed as the user_data to the
   expand_symtabs_matching method.  */
struct search_symbols_data
{
  int nfiles;
  char **files;

  /* It is true if PREG contains valid data, false otherwise.  */
  unsigned preg_p : 1;
  regex_t preg;
};

/* A callback for expand_symtabs_matching.  */

static int
search_symbols_file_matches (const char *filename, void *user_data,
			     int basenames)
{
  struct search_symbols_data *data = user_data;

  return file_matches (filename, data->files, data->nfiles, basenames);
}

/* A callback for expand_symtabs_matching.  */

static int
search_symbols_name_matches (const char *symname, void *user_data)
{
  struct search_symbols_data *data = user_data;

  return !data->preg_p || regexec (&data->preg, symname, 0, NULL, 0) == 0;
}

/* Search the symbol table for matches to the regular expression REGEXP,
   returning the results in *MATCHES.

   Only symbols of KIND are searched:
   VARIABLES_DOMAIN - search all symbols, excluding functions, type names,
                      and constants (enums)
   FUNCTIONS_DOMAIN - search all functions
   TYPES_DOMAIN     - search all type names
   ALL_DOMAIN       - an internal error for this function

   free_search_symbols should be called when *MATCHES is no longer needed.

   Within each file the results are sorted locally; each symtab's global and
   static blocks are separately alphabetized.
   Duplicate entries are removed.  */

void
search_symbols (char *regexp, enum search_domain kind,
		int nfiles, char *files[],
		struct symbol_search **matches)
{
  struct symtab *s;
  struct blockvector *bv;
  struct block *b;
  int i = 0;
  struct block_iterator iter;
  struct symbol *sym;
  struct objfile *objfile;
  struct minimal_symbol *msymbol;
  int found_misc = 0;
  static const enum minimal_symbol_type types[]
    = {mst_data, mst_text, mst_abs};
  static const enum minimal_symbol_type types2[]
    = {mst_bss, mst_file_text, mst_abs};
  static const enum minimal_symbol_type types3[]
    = {mst_file_data, mst_solib_trampoline, mst_abs};
  static const enum minimal_symbol_type types4[]
    = {mst_file_bss, mst_text_gnu_ifunc, mst_abs};
  enum minimal_symbol_type ourtype;
  enum minimal_symbol_type ourtype2;
  enum minimal_symbol_type ourtype3;
  enum minimal_symbol_type ourtype4;
  struct symbol_search *found;
  struct symbol_search *tail;
  struct search_symbols_data datum;
  int nfound;

  /* OLD_CHAIN .. RETVAL_CHAIN is always freed, RETVAL_CHAIN .. current
     CLEANUP_CHAIN is freed only in the case of an error.  */
  struct cleanup *old_chain = make_cleanup (null_cleanup, NULL);
  struct cleanup *retval_chain;

  gdb_assert (kind <= TYPES_DOMAIN);

  ourtype = types[kind];
  ourtype2 = types2[kind];
  ourtype3 = types3[kind];
  ourtype4 = types4[kind];

  *matches = NULL;
  datum.preg_p = 0;

  if (regexp != NULL)
    {
      /* Make sure spacing is right for C++ operators.
         This is just a courtesy to make the matching less sensitive
         to how many spaces the user leaves between 'operator'
         and <TYPENAME> or <OPERATOR>.  */
      char *opend;
      char *opname = operator_chars (regexp, &opend);
      int errcode;

      if (*opname)
	{
	  int fix = -1;		/* -1 means ok; otherwise number of
                                    spaces needed.  */

	  if (isalpha (*opname) || *opname == '_' || *opname == '$')
	    {
	      /* There should 1 space between 'operator' and 'TYPENAME'.  */
	      if (opname[-1] != ' ' || opname[-2] == ' ')
		fix = 1;
	    }
	  else
	    {
	      /* There should 0 spaces between 'operator' and 'OPERATOR'.  */
	      if (opname[-1] == ' ')
		fix = 0;
	    }
	  /* If wrong number of spaces, fix it.  */
	  if (fix >= 0)
	    {
	      char *tmp = (char *) alloca (8 + fix + strlen (opname) + 1);

	      sprintf (tmp, "operator%.*s%s", fix, " ", opname);
	      regexp = tmp;
	    }
	}

      errcode = regcomp (&datum.preg, regexp,
			 REG_NOSUB | (case_sensitivity == case_sensitive_off
				      ? REG_ICASE : 0));
      if (errcode != 0)
	{
	  char *err = get_regcomp_error (errcode, &datum.preg);

	  make_cleanup (xfree, err);
	  error (_("Invalid regexp (%s): %s"), err, regexp);
	}
      datum.preg_p = 1;
      make_regfree_cleanup (&datum.preg);
    }

  /* Search through the partial symtabs *first* for all symbols
     matching the regexp.  That way we don't have to reproduce all of
     the machinery below.  */

  datum.nfiles = nfiles;
  datum.files = files;
  ALL_OBJFILES (objfile)
  {
    if (objfile->sf)
      objfile->sf->qf->expand_symtabs_matching (objfile,
						(nfiles == 0
						 ? NULL
						 : search_symbols_file_matches),
						search_symbols_name_matches,
						kind,
						&datum);
  }

  /* Here, we search through the minimal symbol tables for functions
     and variables that match, and force their symbols to be read.
     This is in particular necessary for demangled variable names,
     which are no longer put into the partial symbol tables.
     The symbol will then be found during the scan of symtabs below.

     For functions, find_pc_symtab should succeed if we have debug info
     for the function, for variables we have to call
     lookup_symbol_in_objfile_from_linkage_name to determine if the variable
     has debug info.
     If the lookup fails, set found_misc so that we will rescan to print
     any matching symbols without debug info.
     We only search the objfile the msymbol came from, we no longer search
     all objfiles.  In large programs (1000s of shared libs) searching all
     objfiles is not worth the pain.  */

  if (nfiles == 0 && (kind == VARIABLES_DOMAIN || kind == FUNCTIONS_DOMAIN))
    {
      ALL_MSYMBOLS (objfile, msymbol)
      {
        QUIT;

	if (msymbol->created_by_gdb)
	  continue;

	if (MSYMBOL_TYPE (msymbol) == ourtype
	    || MSYMBOL_TYPE (msymbol) == ourtype2
	    || MSYMBOL_TYPE (msymbol) == ourtype3
	    || MSYMBOL_TYPE (msymbol) == ourtype4)
	  {
	    if (!datum.preg_p
		|| regexec (&datum.preg, SYMBOL_NATURAL_NAME (msymbol), 0,
			    NULL, 0) == 0)
	      {
		/* Note: An important side-effect of these lookup functions
		   is to expand the symbol table if msymbol is found, for the
		   benefit of the next loop on ALL_PRIMARY_SYMTABS.  */
		if (kind == FUNCTIONS_DOMAIN
		    ? find_pc_symtab (SYMBOL_VALUE_ADDRESS (msymbol)) == NULL
		    : (lookup_symbol_in_objfile_from_linkage_name
		       (objfile, SYMBOL_LINKAGE_NAME (msymbol), VAR_DOMAIN)
		       == NULL))
		  found_misc = 1;
	      }
	  }
      }
    }

  found = NULL;
  tail = NULL;
  nfound = 0;
  retval_chain = make_cleanup_free_search_symbols (&found);

  ALL_PRIMARY_SYMTABS (objfile, s)
  {
    bv = BLOCKVECTOR (s);
    for (i = GLOBAL_BLOCK; i <= STATIC_BLOCK; i++)
      {
	b = BLOCKVECTOR_BLOCK (bv, i);
	ALL_BLOCK_SYMBOLS (b, iter, sym)
	  {
	    struct symtab *real_symtab = SYMBOL_SYMTAB (sym);

	    QUIT;

	    /* Check first sole REAL_SYMTAB->FILENAME.  It does not need to be
	       a substring of symtab_to_fullname as it may contain "./" etc.  */
	    if ((file_matches (real_symtab->filename, files, nfiles, 0)
		 || ((basenames_may_differ
		      || file_matches (lbasename (real_symtab->filename),
				       files, nfiles, 1))
		     && file_matches (symtab_to_fullname (real_symtab),
				      files, nfiles, 0)))
		&& ((!datum.preg_p
		     || regexec (&datum.preg, SYMBOL_NATURAL_NAME (sym), 0,
				 NULL, 0) == 0)
		    && ((kind == VARIABLES_DOMAIN
			 && SYMBOL_CLASS (sym) != LOC_TYPEDEF
			 && SYMBOL_CLASS (sym) != LOC_UNRESOLVED
			 && SYMBOL_CLASS (sym) != LOC_BLOCK
			 /* LOC_CONST can be used for more than just enums,
			    e.g., c++ static const members.
			    We only want to skip enums here.  */
			 && !(SYMBOL_CLASS (sym) == LOC_CONST
			      && TYPE_CODE (SYMBOL_TYPE (sym))
			      == TYPE_CODE_ENUM))
			|| (kind == FUNCTIONS_DOMAIN 
			    && SYMBOL_CLASS (sym) == LOC_BLOCK)
			|| (kind == TYPES_DOMAIN
			    && SYMBOL_CLASS (sym) == LOC_TYPEDEF))))
	      {
		/* match */
		struct symbol_search *psr = (struct symbol_search *)
		  xmalloc (sizeof (struct symbol_search));
		psr->block = i;
		psr->symtab = real_symtab;
		psr->symbol = sym;
		memset (&psr->msymbol, 0, sizeof (psr->msymbol));
		psr->next = NULL;
		if (tail == NULL)
		  found = psr;
		else
		  tail->next = psr;
		tail = psr;
		nfound ++;
	      }
	  }
      }
  }

  if (found != NULL)
    {
      sort_search_symbols_remove_dups (found, nfound, &found, &tail);
      /* Note: nfound is no longer useful beyond this point.  */
    }

  /* If there are no eyes, avoid all contact.  I mean, if there are
     no debug symbols, then print directly from the msymbol_vector.  */

  if (found_misc || (nfiles == 0 && kind != FUNCTIONS_DOMAIN))
    {
      ALL_MSYMBOLS (objfile, msymbol)
      {
        QUIT;

	if (msymbol->created_by_gdb)
	  continue;

	if (MSYMBOL_TYPE (msymbol) == ourtype
	    || MSYMBOL_TYPE (msymbol) == ourtype2
	    || MSYMBOL_TYPE (msymbol) == ourtype3
	    || MSYMBOL_TYPE (msymbol) == ourtype4)
	  {
	    if (!datum.preg_p
		|| regexec (&datum.preg, SYMBOL_NATURAL_NAME (msymbol), 0,
			    NULL, 0) == 0)
	      {
		/* For functions we can do a quick check of whether the
		   symbol might be found via find_pc_symtab.  */
		if (kind != FUNCTIONS_DOMAIN
		    || find_pc_symtab (SYMBOL_VALUE_ADDRESS (msymbol)) == NULL)
		  {
		    if (lookup_symbol_in_objfile_from_linkage_name
			(objfile, SYMBOL_LINKAGE_NAME (msymbol), VAR_DOMAIN)
			== NULL)
		      {
			/* match */
			struct symbol_search *psr = (struct symbol_search *)
			  xmalloc (sizeof (struct symbol_search));
			psr->block = i;
			psr->msymbol.minsym = msymbol;
			psr->msymbol.objfile = objfile;
			psr->symtab = NULL;
			psr->symbol = NULL;
			psr->next = NULL;
			if (tail == NULL)
			  found = psr;
			else
			  tail->next = psr;
			tail = psr;
		      }
		  }
	      }
	  }
      }
    }

  discard_cleanups (retval_chain);
  do_cleanups (old_chain);
  *matches = found;
}

/* Helper function for symtab_symbol_info, this function uses
   the data returned from search_symbols() to print information
   regarding the match to gdb_stdout.  */

static void
print_symbol_info (enum search_domain kind,
		   struct symtab *s, struct symbol *sym,
		   int block, const char *last)
{
  const char *s_filename = symtab_to_filename_for_display (s);

  if (last == NULL || filename_cmp (last, s_filename) != 0)
    {
      fputs_filtered ("\nFile ", gdb_stdout);
      fputs_filtered (s_filename, gdb_stdout);
      fputs_filtered (":\n", gdb_stdout);
    }

  if (kind != TYPES_DOMAIN && block == STATIC_BLOCK)
    printf_filtered ("static ");

  /* Typedef that is not a C++ class.  */
  if (kind == TYPES_DOMAIN
      && SYMBOL_DOMAIN (sym) != STRUCT_DOMAIN)
    typedef_print (SYMBOL_TYPE (sym), sym, gdb_stdout);
  /* variable, func, or typedef-that-is-c++-class.  */
  else if (kind < TYPES_DOMAIN
	   || (kind == TYPES_DOMAIN
	       && SYMBOL_DOMAIN (sym) == STRUCT_DOMAIN))
    {
      type_print (SYMBOL_TYPE (sym),
		  (SYMBOL_CLASS (sym) == LOC_TYPEDEF
		   ? "" : SYMBOL_PRINT_NAME (sym)),
		  gdb_stdout, 0);

      printf_filtered (";\n");
    }
}

/* This help function for symtab_symbol_info() prints information
   for non-debugging symbols to gdb_stdout.  */

static void
print_msymbol_info (struct bound_minimal_symbol msymbol)
{
  struct gdbarch *gdbarch = get_objfile_arch (msymbol.objfile);
  char *tmp;

  if (gdbarch_addr_bit (gdbarch) <= 32)
    tmp = hex_string_custom (SYMBOL_VALUE_ADDRESS (msymbol.minsym)
			     & (CORE_ADDR) 0xffffffff,
			     8);
  else
    tmp = hex_string_custom (SYMBOL_VALUE_ADDRESS (msymbol.minsym),
			     16);
  printf_filtered ("%s  %s\n",
		   tmp, SYMBOL_PRINT_NAME (msymbol.minsym));
}

/* This is the guts of the commands "info functions", "info types", and
   "info variables".  It calls search_symbols to find all matches and then
   print_[m]symbol_info to print out some useful information about the
   matches.  */

static void
symtab_symbol_info (char *regexp, enum search_domain kind, int from_tty)
{
  static const char * const classnames[] =
    {"variable", "function", "type"};
  struct symbol_search *symbols;
  struct symbol_search *p;
  struct cleanup *old_chain;
  const char *last_filename = NULL;
  int first = 1;

  gdb_assert (kind <= TYPES_DOMAIN);

  /* Must make sure that if we're interrupted, symbols gets freed.  */
  search_symbols (regexp, kind, 0, (char **) NULL, &symbols);
  old_chain = make_cleanup_free_search_symbols (&symbols);

  if (regexp != NULL)
    printf_filtered (_("All %ss matching regular expression \"%s\":\n"),
		     classnames[kind], regexp);
  else
    printf_filtered (_("All defined %ss:\n"), classnames[kind]);

  for (p = symbols; p != NULL; p = p->next)
    {
      QUIT;

      if (p->msymbol.minsym != NULL)
	{
	  if (first)
	    {
	      printf_filtered (_("\nNon-debugging symbols:\n"));
	      first = 0;
	    }
	  print_msymbol_info (p->msymbol);
	}
      else
	{
	  print_symbol_info (kind,
			     p->symtab,
			     p->symbol,
			     p->block,
			     last_filename);
	  last_filename = symtab_to_filename_for_display (p->symtab);
	}
    }

  do_cleanups (old_chain);
}

static void
variables_info (char *regexp, int from_tty)
{
  symtab_symbol_info (regexp, VARIABLES_DOMAIN, from_tty);
}

static void
functions_info (char *regexp, int from_tty)
{
  symtab_symbol_info (regexp, FUNCTIONS_DOMAIN, from_tty);
}


static void
types_info (char *regexp, int from_tty)
{
  symtab_symbol_info (regexp, TYPES_DOMAIN, from_tty);
}

/* Breakpoint all functions matching regular expression.  */

void
rbreak_command_wrapper (char *regexp, int from_tty)
{
  rbreak_command (regexp, from_tty);
}

/* A cleanup function that calls end_rbreak_breakpoints.  */

static void
do_end_rbreak_breakpoints (void *ignore)
{
  end_rbreak_breakpoints ();
}

static void
rbreak_command (char *regexp, int from_tty)
{
  struct symbol_search *ss;
  struct symbol_search *p;
  struct cleanup *old_chain;
  char *string = NULL;
  int len = 0;
  char **files = NULL, *file_name;
  int nfiles = 0;

  if (regexp)
    {
      char *colon = strchr (regexp, ':');

      if (colon && *(colon + 1) != ':')
	{
	  int colon_index;

	  colon_index = colon - regexp;
	  file_name = alloca (colon_index + 1);
	  memcpy (file_name, regexp, colon_index);
	  file_name[colon_index--] = 0;
	  while (isspace (file_name[colon_index]))
	    file_name[colon_index--] = 0; 
	  files = &file_name;
	  nfiles = 1;
	  regexp = skip_spaces (colon + 1);
	}
    }

  search_symbols (regexp, FUNCTIONS_DOMAIN, nfiles, files, &ss);
  old_chain = make_cleanup_free_search_symbols (&ss);
  make_cleanup (free_current_contents, &string);

  start_rbreak_breakpoints ();
  make_cleanup (do_end_rbreak_breakpoints, NULL);
  for (p = ss; p != NULL; p = p->next)
    {
      if (p->msymbol.minsym == NULL)
	{
	  const char *fullname = symtab_to_fullname (p->symtab);

	  int newlen = (strlen (fullname)
			+ strlen (SYMBOL_LINKAGE_NAME (p->symbol))
			+ 4);

	  if (newlen > len)
	    {
	      string = xrealloc (string, newlen);
	      len = newlen;
	    }
	  strcpy (string, fullname);
	  strcat (string, ":'");
	  strcat (string, SYMBOL_LINKAGE_NAME (p->symbol));
	  strcat (string, "'");
	  break_command (string, from_tty);
	  print_symbol_info (FUNCTIONS_DOMAIN,
			     p->symtab,
			     p->symbol,
			     p->block,
			     symtab_to_filename_for_display (p->symtab));
	}
      else
	{
	  int newlen = (strlen (SYMBOL_LINKAGE_NAME (p->msymbol.minsym)) + 3);

	  if (newlen > len)
	    {
	      string = xrealloc (string, newlen);
	      len = newlen;
	    }
	  strcpy (string, "'");
	  strcat (string, SYMBOL_LINKAGE_NAME (p->msymbol.minsym));
	  strcat (string, "'");

	  break_command (string, from_tty);
	  printf_filtered ("<function, no debug info> %s;\n",
			   SYMBOL_PRINT_NAME (p->msymbol.minsym));
	}
    }

  do_cleanups (old_chain);
}


/* Evaluate if NAME matches SYM_TEXT and SYM_TEXT_LEN.

   Either sym_text[sym_text_len] != '(' and then we search for any
   symbol starting with SYM_TEXT text.

   Otherwise sym_text[sym_text_len] == '(' and then we require symbol name to
   be terminated at that point.  Partial symbol tables do not have parameters
   information.  */

static int
compare_symbol_name (const char *name, const char *sym_text, int sym_text_len)
{
  int (*ncmp) (const char *, const char *, size_t);

  ncmp = (case_sensitivity == case_sensitive_on ? strncmp : strncasecmp);

  if (ncmp (name, sym_text, sym_text_len) != 0)
    return 0;

  if (sym_text[sym_text_len] == '(')
    {
      /* User searches for `name(someth...'.  Require NAME to be terminated.
	 Normally psymtabs and gdbindex have no parameter types so '\0' will be
	 present but accept even parameters presence.  In this case this
	 function is in fact strcmp_iw but whitespace skipping is not supported
	 for tab completion.  */

      if (name[sym_text_len] != '\0' && name[sym_text_len] != '(')
	return 0;
    }

  return 1;
}

/* Free any memory associated with a completion list.  */

static void
free_completion_list (VEC (char_ptr) **list_ptr)
{
  int i;
  char *p;

  for (i = 0; VEC_iterate (char_ptr, *list_ptr, i, p); ++i)
    xfree (p);
  VEC_free (char_ptr, *list_ptr);
}

/* Callback for make_cleanup.  */

static void
do_free_completion_list (void *list)
{
  free_completion_list (list);
}

/* Helper routine for make_symbol_completion_list.  */

static VEC (char_ptr) *return_val;

#define COMPLETION_LIST_ADD_SYMBOL(symbol, sym_text, len, text, word) \
      completion_list_add_name \
	(SYMBOL_NATURAL_NAME (symbol), (sym_text), (len), (text), (word))

/*  Test to see if the symbol specified by SYMNAME (which is already
   demangled for C++ symbols) matches SYM_TEXT in the first SYM_TEXT_LEN
   characters.  If so, add it to the current completion list.  */

static void
completion_list_add_name (const char *symname,
			  const char *sym_text, int sym_text_len,
			  const char *text, const char *word)
{
  /* Clip symbols that cannot match.  */
  if (!compare_symbol_name (symname, sym_text, sym_text_len))
    return;

  /* We have a match for a completion, so add SYMNAME to the current list
     of matches.  Note that the name is moved to freshly malloc'd space.  */

  {
    char *new;

    if (word == sym_text)
      {
	new = xmalloc (strlen (symname) + 5);
	strcpy (new, symname);
      }
    else if (word > sym_text)
      {
	/* Return some portion of symname.  */
	new = xmalloc (strlen (symname) + 5);
	strcpy (new, symname + (word - sym_text));
      }
    else
      {
	/* Return some of SYM_TEXT plus symname.  */
	new = xmalloc (strlen (symname) + (sym_text - word) + 5);
	strncpy (new, word, sym_text - word);
	new[sym_text - word] = '\0';
	strcat (new, symname);
      }

    VEC_safe_push (char_ptr, return_val, new);
  }
}

/* ObjC: In case we are completing on a selector, look as the msymbol
   again and feed all the selectors into the mill.  */

static void
completion_list_objc_symbol (struct minimal_symbol *msymbol,
			     const char *sym_text, int sym_text_len,
			     const char *text, const char *word)
{
  static char *tmp = NULL;
  static unsigned int tmplen = 0;

  const char *method, *category, *selector;
  char *tmp2 = NULL;

  method = SYMBOL_NATURAL_NAME (msymbol);

  /* Is it a method?  */
  if ((method[0] != '-') && (method[0] != '+'))
    return;

  if (sym_text[0] == '[')
    /* Complete on shortened method method.  */
    completion_list_add_name (method + 1, sym_text, sym_text_len, text, word);

  while ((strlen (method) + 1) >= tmplen)
    {
      if (tmplen == 0)
	tmplen = 1024;
      else
	tmplen *= 2;
      tmp = xrealloc (tmp, tmplen);
    }
  selector = strchr (method, ' ');
  if (selector != NULL)
    selector++;

  category = strchr (method, '(');

  if ((category != NULL) && (selector != NULL))
    {
      memcpy (tmp, method, (category - method));
      tmp[category - method] = ' ';
      memcpy (tmp + (category - method) + 1, selector, strlen (selector) + 1);
      completion_list_add_name (tmp, sym_text, sym_text_len, text, word);
      if (sym_text[0] == '[')
	completion_list_add_name (tmp + 1, sym_text, sym_text_len, text, word);
    }

  if (selector != NULL)
    {
      /* Complete on selector only.  */
      strcpy (tmp, selector);
      tmp2 = strchr (tmp, ']');
      if (tmp2 != NULL)
	*tmp2 = '\0';

      completion_list_add_name (tmp, sym_text, sym_text_len, text, word);
    }
}

/* Break the non-quoted text based on the characters which are in
   symbols.  FIXME: This should probably be language-specific.  */

static const char *
language_search_unquoted_string (const char *text, const char *p)
{
  for (; p > text; --p)
    {
      if (isalnum (p[-1]) || p[-1] == '_' || p[-1] == '\0')
	continue;
      else
	{
	  if ((current_language->la_language == language_objc))
	    {
	      if (p[-1] == ':')     /* Might be part of a method name.  */
		continue;
	      else if (p[-1] == '[' && (p[-2] == '-' || p[-2] == '+'))
		p -= 2;             /* Beginning of a method name.  */
	      else if (p[-1] == ' ' || p[-1] == '(' || p[-1] == ')')
		{                   /* Might be part of a method name.  */
		  const char *t = p;

		  /* Seeing a ' ' or a '(' is not conclusive evidence
		     that we are in the middle of a method name.  However,
		     finding "-[" or "+[" should be pretty un-ambiguous.
		     Unfortunately we have to find it now to decide.  */

		  while (t > text)
		    if (isalnum (t[-1]) || t[-1] == '_' ||
			t[-1] == ' '    || t[-1] == ':' ||
			t[-1] == '('    || t[-1] == ')')
		      --t;
		    else
		      break;

		  if (t[-1] == '[' && (t[-2] == '-' || t[-2] == '+'))
		    p = t - 2;      /* Method name detected.  */
		  /* Else we leave with p unchanged.  */
		}
	    }
	  break;
	}
    }
  return p;
}

static void
completion_list_add_fields (struct symbol *sym, const char *sym_text,
			    int sym_text_len, const char *text,
			    const char *word)
{
  if (SYMBOL_CLASS (sym) == LOC_TYPEDEF)
    {
      struct type *t = SYMBOL_TYPE (sym);
      enum type_code c = TYPE_CODE (t);
      int j;

      if (c == TYPE_CODE_UNION || c == TYPE_CODE_STRUCT)
	for (j = TYPE_N_BASECLASSES (t); j < TYPE_NFIELDS (t); j++)
	  if (TYPE_FIELD_NAME (t, j))
	    completion_list_add_name (TYPE_FIELD_NAME (t, j),
				      sym_text, sym_text_len, text, word);
    }
}

/* Type of the user_data argument passed to add_macro_name or
   expand_partial_symbol_name.  The contents are simply whatever is
   needed by completion_list_add_name.  */
struct add_name_data
{
  const char *sym_text;
  int sym_text_len;
  const char *text;
  const char *word;
};

/* A callback used with macro_for_each and macro_for_each_in_scope.
   This adds a macro's name to the current completion list.  */

static void
add_macro_name (const char *name, const struct macro_definition *ignore,
		struct macro_source_file *ignore2, int ignore3,
		void *user_data)
{
  struct add_name_data *datum = (struct add_name_data *) user_data;

  completion_list_add_name ((char *) name,
			    datum->sym_text, datum->sym_text_len,
			    datum->text, datum->word);
}

/* A callback for expand_partial_symbol_names.  */

static int
expand_partial_symbol_name (const char *name, void *user_data)
{
  struct add_name_data *datum = (struct add_name_data *) user_data;

  return compare_symbol_name (name, datum->sym_text, datum->sym_text_len);
}

VEC (char_ptr) *
default_make_symbol_completion_list_break_on (const char *text,
					      const char *word,
					      const char *break_on,
					      enum type_code code)
{
  /* Problem: All of the symbols have to be copied because readline
     frees them.  I'm not going to worry about this; hopefully there
     won't be that many.  */

  struct symbol *sym;
  struct symtab *s;
  struct minimal_symbol *msymbol;
  struct objfile *objfile;
  struct block *b;
  const struct block *surrounding_static_block, *surrounding_global_block;
  struct block_iterator iter;
  /* The symbol we are completing on.  Points in same buffer as text.  */
  const char *sym_text;
  /* Length of sym_text.  */
  int sym_text_len;
  struct add_name_data datum;
  struct cleanup *back_to;

  /* Now look for the symbol we are supposed to complete on.  */
  {
    const char *p;
    char quote_found;
    const char *quote_pos = NULL;

    /* First see if this is a quoted string.  */
    quote_found = '\0';
    for (p = text; *p != '\0'; ++p)
      {
	if (quote_found != '\0')
	  {
	    if (*p == quote_found)
	      /* Found close quote.  */
	      quote_found = '\0';
	    else if (*p == '\\' && p[1] == quote_found)
	      /* A backslash followed by the quote character
	         doesn't end the string.  */
	      ++p;
	  }
	else if (*p == '\'' || *p == '"')
	  {
	    quote_found = *p;
	    quote_pos = p;
	  }
      }
    if (quote_found == '\'')
      /* A string within single quotes can be a symbol, so complete on it.  */
      sym_text = quote_pos + 1;
    else if (quote_found == '"')
      /* A double-quoted string is never a symbol, nor does it make sense
         to complete it any other way.  */
      {
	return NULL;
      }
    else
      {
	/* It is not a quoted string.  Break it based on the characters
	   which are in symbols.  */
	while (p > text)
	  {
	    if (isalnum (p[-1]) || p[-1] == '_' || p[-1] == '\0'
		|| p[-1] == ':' || strchr (break_on, p[-1]) != NULL)
	      --p;
	    else
	      break;
	  }
	sym_text = p;
      }
  }

  sym_text_len = strlen (sym_text);

  /* Prepare SYM_TEXT_LEN for compare_symbol_name.  */

  if (current_language->la_language == language_cplus
      || current_language->la_language == language_java
      || current_language->la_language == language_fortran)
    {
      /* These languages may have parameters entered by user but they are never
	 present in the partial symbol tables.  */

      const char *cs = memchr (sym_text, '(', sym_text_len);

      if (cs)
	sym_text_len = cs - sym_text;
    }
  gdb_assert (sym_text[sym_text_len] == '\0' || sym_text[sym_text_len] == '(');

  return_val = NULL;
  back_to = make_cleanup (do_free_completion_list, &return_val);

  datum.sym_text = sym_text;
  datum.sym_text_len = sym_text_len;
  datum.text = text;
  datum.word = word;

  /* Look through the partial symtabs for all symbols which begin
     by matching SYM_TEXT.  Expand all CUs that you find to the list.
     The real names will get added by COMPLETION_LIST_ADD_SYMBOL below.  */
  expand_partial_symbol_names (expand_partial_symbol_name, &datum);

  /* At this point scan through the misc symbol vectors and add each
     symbol you find to the list.  Eventually we want to ignore
     anything that isn't a text symbol (everything else will be
     handled by the psymtab code above).  */

  if (code == TYPE_CODE_UNDEF)
    {
      ALL_MSYMBOLS (objfile, msymbol)
	{
	  QUIT;
	  COMPLETION_LIST_ADD_SYMBOL (msymbol, sym_text, sym_text_len, text,
				      word);

	  completion_list_objc_symbol (msymbol, sym_text, sym_text_len, text,
				       word);
	}
    }

  /* Search upwards from currently selected frame (so that we can
     complete on local vars).  Also catch fields of types defined in
     this places which match our text string.  Only complete on types
     visible from current context.  */

  b = get_selected_block (0);
  surrounding_static_block = block_static_block (b);
  surrounding_global_block = block_global_block (b);
  if (surrounding_static_block != NULL)
    while (b != surrounding_static_block)
      {
	QUIT;

	ALL_BLOCK_SYMBOLS (b, iter, sym)
	  {
	    if (code == TYPE_CODE_UNDEF)
	      {
		COMPLETION_LIST_ADD_SYMBOL (sym, sym_text, sym_text_len, text,
					    word);
		completion_list_add_fields (sym, sym_text, sym_text_len, text,
					    word);
	      }
	    else if (SYMBOL_DOMAIN (sym) == STRUCT_DOMAIN
		     && TYPE_CODE (SYMBOL_TYPE (sym)) == code)
	      COMPLETION_LIST_ADD_SYMBOL (sym, sym_text, sym_text_len, text,
					  word);
	  }

	/* Stop when we encounter an enclosing function.  Do not stop for
	   non-inlined functions - the locals of the enclosing function
	   are in scope for a nested function.  */
	if (BLOCK_FUNCTION (b) != NULL && block_inlined_p (b))
	  break;
	b = BLOCK_SUPERBLOCK (b);
      }

  /* Add fields from the file's types; symbols will be added below.  */

  if (code == TYPE_CODE_UNDEF)
    {
      if (surrounding_static_block != NULL)
	ALL_BLOCK_SYMBOLS (surrounding_static_block, iter, sym)
	  completion_list_add_fields (sym, sym_text, sym_text_len, text, word);

      if (surrounding_global_block != NULL)
	ALL_BLOCK_SYMBOLS (surrounding_global_block, iter, sym)
	  completion_list_add_fields (sym, sym_text, sym_text_len, text, word);
    }

  /* Go through the symtabs and check the externs and statics for
     symbols which match.  */

  ALL_PRIMARY_SYMTABS (objfile, s)
  {
    QUIT;
    b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), GLOBAL_BLOCK);
    ALL_BLOCK_SYMBOLS (b, iter, sym)
      {
	if (code == TYPE_CODE_UNDEF
	    || (SYMBOL_DOMAIN (sym) == STRUCT_DOMAIN
		&& TYPE_CODE (SYMBOL_TYPE (sym)) == code))
	  COMPLETION_LIST_ADD_SYMBOL (sym, sym_text, sym_text_len, text, word);
      }
  }

  ALL_PRIMARY_SYMTABS (objfile, s)
  {
    QUIT;
    b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), STATIC_BLOCK);
    ALL_BLOCK_SYMBOLS (b, iter, sym)
      {
	if (code == TYPE_CODE_UNDEF
	    || (SYMBOL_DOMAIN (sym) == STRUCT_DOMAIN
		&& TYPE_CODE (SYMBOL_TYPE (sym)) == code))
	  COMPLETION_LIST_ADD_SYMBOL (sym, sym_text, sym_text_len, text, word);
      }
  }

  /* Skip macros if we are completing a struct tag -- arguable but
     usually what is expected.  */
  if (current_language->la_macro_expansion == macro_expansion_c
      && code == TYPE_CODE_UNDEF)
    {
      struct macro_scope *scope;

      /* Add any macros visible in the default scope.  Note that this
	 may yield the occasional wrong result, because an expression
	 might be evaluated in a scope other than the default.  For
	 example, if the user types "break file:line if <TAB>", the
	 resulting expression will be evaluated at "file:line" -- but
	 at there does not seem to be a way to detect this at
	 completion time.  */
      scope = default_macro_scope ();
      if (scope)
	{
	  macro_for_each_in_scope (scope->file, scope->line,
				   add_macro_name, &datum);
	  xfree (scope);
	}

      /* User-defined macros are always visible.  */
      macro_for_each (macro_user_macros, add_macro_name, &datum);
    }

  discard_cleanups (back_to);
  return (return_val);
}

VEC (char_ptr) *
default_make_symbol_completion_list (const char *text, const char *word,
				     enum type_code code)
{
  return default_make_symbol_completion_list_break_on (text, word, "", code);
}

/* Return a vector of all symbols (regardless of class) which begin by
   matching TEXT.  If the answer is no symbols, then the return value
   is NULL.  */

VEC (char_ptr) *
make_symbol_completion_list (const char *text, const char *word)
{
  return current_language->la_make_symbol_completion_list (text, word,
							   TYPE_CODE_UNDEF);
}

/* Like make_symbol_completion_list, but only return STRUCT_DOMAIN
   symbols whose type code is CODE.  */

VEC (char_ptr) *
make_symbol_completion_type (const char *text, const char *word,
			     enum type_code code)
{
  gdb_assert (code == TYPE_CODE_UNION
	      || code == TYPE_CODE_STRUCT
	      || code == TYPE_CODE_CLASS
	      || code == TYPE_CODE_ENUM);
  return current_language->la_make_symbol_completion_list (text, word, code);
}

/* Like make_symbol_completion_list, but suitable for use as a
   completion function.  */

VEC (char_ptr) *
make_symbol_completion_list_fn (struct cmd_list_element *ignore,
				const char *text, const char *word)
{
  return make_symbol_completion_list (text, word);
}

/* Like make_symbol_completion_list, but returns a list of symbols
   defined in a source file FILE.  */

VEC (char_ptr) *
make_file_symbol_completion_list (const char *text, const char *word,
				  const char *srcfile)
{
  struct symbol *sym;
  struct symtab *s;
  struct block *b;
  struct block_iterator iter;
  /* The symbol we are completing on.  Points in same buffer as text.  */
  const char *sym_text;
  /* Length of sym_text.  */
  int sym_text_len;

  /* Now look for the symbol we are supposed to complete on.
     FIXME: This should be language-specific.  */
  {
    const char *p;
    char quote_found;
    const char *quote_pos = NULL;

    /* First see if this is a quoted string.  */
    quote_found = '\0';
    for (p = text; *p != '\0'; ++p)
      {
	if (quote_found != '\0')
	  {
	    if (*p == quote_found)
	      /* Found close quote.  */
	      quote_found = '\0';
	    else if (*p == '\\' && p[1] == quote_found)
	      /* A backslash followed by the quote character
	         doesn't end the string.  */
	      ++p;
	  }
	else if (*p == '\'' || *p == '"')
	  {
	    quote_found = *p;
	    quote_pos = p;
	  }
      }
    if (quote_found == '\'')
      /* A string within single quotes can be a symbol, so complete on it.  */
      sym_text = quote_pos + 1;
    else if (quote_found == '"')
      /* A double-quoted string is never a symbol, nor does it make sense
         to complete it any other way.  */
      {
	return NULL;
      }
    else
      {
	/* Not a quoted string.  */
	sym_text = language_search_unquoted_string (text, p);
      }
  }

  sym_text_len = strlen (sym_text);

  return_val = NULL;

  /* Find the symtab for SRCFILE (this loads it if it was not yet read
     in).  */
  s = lookup_symtab (srcfile);
  if (s == NULL)
    {
      /* Maybe they typed the file with leading directories, while the
	 symbol tables record only its basename.  */
      const char *tail = lbasename (srcfile);

      if (tail > srcfile)
	s = lookup_symtab (tail);
    }

  /* If we have no symtab for that file, return an empty list.  */
  if (s == NULL)
    return (return_val);

  /* Go through this symtab and check the externs and statics for
     symbols which match.  */

  b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), GLOBAL_BLOCK);
  ALL_BLOCK_SYMBOLS (b, iter, sym)
    {
      COMPLETION_LIST_ADD_SYMBOL (sym, sym_text, sym_text_len, text, word);
    }

  b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), STATIC_BLOCK);
  ALL_BLOCK_SYMBOLS (b, iter, sym)
    {
      COMPLETION_LIST_ADD_SYMBOL (sym, sym_text, sym_text_len, text, word);
    }

  return (return_val);
}

/* A helper function for make_source_files_completion_list.  It adds
   another file name to a list of possible completions, growing the
   list as necessary.  */

static void
add_filename_to_list (const char *fname, const char *text, const char *word,
		      VEC (char_ptr) **list)
{
  char *new;
  size_t fnlen = strlen (fname);

  if (word == text)
    {
      /* Return exactly fname.  */
      new = xmalloc (fnlen + 5);
      strcpy (new, fname);
    }
  else if (word > text)
    {
      /* Return some portion of fname.  */
      new = xmalloc (fnlen + 5);
      strcpy (new, fname + (word - text));
    }
  else
    {
      /* Return some of TEXT plus fname.  */
      new = xmalloc (fnlen + (text - word) + 5);
      strncpy (new, word, text - word);
      new[text - word] = '\0';
      strcat (new, fname);
    }
  VEC_safe_push (char_ptr, *list, new);
}

static int
not_interesting_fname (const char *fname)
{
  static const char *illegal_aliens[] = {
    "_globals_",	/* inserted by coff_symtab_read */
    NULL
  };
  int i;

  for (i = 0; illegal_aliens[i]; i++)
    {
      if (filename_cmp (fname, illegal_aliens[i]) == 0)
	return 1;
    }
  return 0;
}

/* An object of this type is passed as the user_data argument to
   map_partial_symbol_filenames.  */
struct add_partial_filename_data
{
  struct filename_seen_cache *filename_seen_cache;
  const char *text;
  const char *word;
  int text_len;
  VEC (char_ptr) **list;
};

/* A callback for map_partial_symbol_filenames.  */

static void
maybe_add_partial_symtab_filename (const char *filename, const char *fullname,
				   void *user_data)
{
  struct add_partial_filename_data *data = user_data;

  if (not_interesting_fname (filename))
    return;
  if (!filename_seen (data->filename_seen_cache, filename, 1)
      && filename_ncmp (filename, data->text, data->text_len) == 0)
    {
      /* This file matches for a completion; add it to the
	 current list of matches.  */
      add_filename_to_list (filename, data->text, data->word, data->list);
    }
  else
    {
      const char *base_name = lbasename (filename);

      if (base_name != filename
	  && !filename_seen (data->filename_seen_cache, base_name, 1)
	  && filename_ncmp (base_name, data->text, data->text_len) == 0)
	add_filename_to_list (base_name, data->text, data->word, data->list);
    }
}

/* Return a vector of all source files whose names begin with matching
   TEXT.  The file names are looked up in the symbol tables of this
   program.  If the answer is no matchess, then the return value is
   NULL.  */

VEC (char_ptr) *
make_source_files_completion_list (const char *text, const char *word)
{
  struct symtab *s;
  struct objfile *objfile;
  size_t text_len = strlen (text);
  VEC (char_ptr) *list = NULL;
  const char *base_name;
  struct add_partial_filename_data datum;
  struct filename_seen_cache *filename_seen_cache;
  struct cleanup *back_to, *cache_cleanup;

  if (!have_full_symbols () && !have_partial_symbols ())
    return list;

  back_to = make_cleanup (do_free_completion_list, &list);

  filename_seen_cache = create_filename_seen_cache ();
  cache_cleanup = make_cleanup (delete_filename_seen_cache,
				filename_seen_cache);

  ALL_SYMTABS (objfile, s)
    {
      if (not_interesting_fname (s->filename))
	continue;
      if (!filename_seen (filename_seen_cache, s->filename, 1)
	  && filename_ncmp (s->filename, text, text_len) == 0)
	{
	  /* This file matches for a completion; add it to the current
	     list of matches.  */
	  add_filename_to_list (s->filename, text, word, &list);
	}
      else
	{
	  /* NOTE: We allow the user to type a base name when the
	     debug info records leading directories, but not the other
	     way around.  This is what subroutines of breakpoint
	     command do when they parse file names.  */
	  base_name = lbasename (s->filename);
	  if (base_name != s->filename
	      && !filename_seen (filename_seen_cache, base_name, 1)
	      && filename_ncmp (base_name, text, text_len) == 0)
	    add_filename_to_list (base_name, text, word, &list);
	}
    }

  datum.filename_seen_cache = filename_seen_cache;
  datum.text = text;
  datum.word = word;
  datum.text_len = text_len;
  datum.list = &list;
  map_partial_symbol_filenames (maybe_add_partial_symtab_filename, &datum,
				0 /*need_fullname*/);

  do_cleanups (cache_cleanup);
  discard_cleanups (back_to);

  return list;
}

/* Determine if PC is in the prologue of a function.  The prologue is the area
   between the first instruction of a function, and the first executable line.
   Returns 1 if PC *might* be in prologue, 0 if definately *not* in prologue.

   If non-zero, func_start is where we think the prologue starts, possibly
   by previous examination of symbol table information.  */

int
in_prologue (struct gdbarch *gdbarch, CORE_ADDR pc, CORE_ADDR func_start)
{
  struct symtab_and_line sal;
  CORE_ADDR func_addr, func_end;

  /* We have several sources of information we can consult to figure
     this out.
     - Compilers usually emit line number info that marks the prologue
       as its own "source line".  So the ending address of that "line"
       is the end of the prologue.  If available, this is the most
       reliable method.
     - The minimal symbols and partial symbols, which can usually tell
       us the starting and ending addresses of a function.
     - If we know the function's start address, we can call the
       architecture-defined gdbarch_skip_prologue function to analyze the
       instruction stream and guess where the prologue ends.
     - Our `func_start' argument; if non-zero, this is the caller's
       best guess as to the function's entry point.  At the time of
       this writing, handle_inferior_event doesn't get this right, so
       it should be our last resort.  */

  /* Consult the partial symbol table, to find which function
     the PC is in.  */
  if (! find_pc_partial_function (pc, NULL, &func_addr, &func_end))
    {
      CORE_ADDR prologue_end;

      /* We don't even have minsym information, so fall back to using
         func_start, if given.  */
      if (! func_start)
	return 1;		/* We *might* be in a prologue.  */

      prologue_end = gdbarch_skip_prologue (gdbarch, func_start);

      return func_start <= pc && pc < prologue_end;
    }

  /* If we have line number information for the function, that's
     usually pretty reliable.  */
  sal = find_pc_line (func_addr, 0);

  /* Now sal describes the source line at the function's entry point,
     which (by convention) is the prologue.  The end of that "line",
     sal.end, is the end of the prologue.

     Note that, for functions whose source code is all on a single
     line, the line number information doesn't always end up this way.
     So we must verify that our purported end-of-prologue address is
     *within* the function, not at its start or end.  */
  if (sal.line == 0
      || sal.end <= func_addr
      || func_end <= sal.end)
    {
      /* We don't have any good line number info, so use the minsym
	 information, together with the architecture-specific prologue
	 scanning code.  */
      CORE_ADDR prologue_end = gdbarch_skip_prologue (gdbarch, func_addr);

      return func_addr <= pc && pc < prologue_end;
    }

  /* We have line number info, and it looks good.  */
  return func_addr <= pc && pc < sal.end;
}

/* Given PC at the function's start address, attempt to find the
   prologue end using SAL information.  Return zero if the skip fails.

   A non-optimized prologue traditionally has one SAL for the function
   and a second for the function body.  A single line function has
   them both pointing at the same line.

   An optimized prologue is similar but the prologue may contain
   instructions (SALs) from the instruction body.  Need to skip those
   while not getting into the function body.

   The functions end point and an increasing SAL line are used as
   indicators of the prologue's endpoint.

   This code is based on the function refine_prologue_limit
   (found in ia64).  */

CORE_ADDR
skip_prologue_using_sal (struct gdbarch *gdbarch, CORE_ADDR func_addr)
{
  struct symtab_and_line prologue_sal;
  CORE_ADDR start_pc;
  CORE_ADDR end_pc;
  struct block *bl;

  /* Get an initial range for the function.  */
  find_pc_partial_function (func_addr, NULL, &start_pc, &end_pc);
  start_pc += gdbarch_deprecated_function_start_offset (gdbarch);

  prologue_sal = find_pc_line (start_pc, 0);
  if (prologue_sal.line != 0)
    {
      /* For languages other than assembly, treat two consecutive line
	 entries at the same address as a zero-instruction prologue.
	 The GNU assembler emits separate line notes for each instruction
	 in a multi-instruction macro, but compilers generally will not
	 do this.  */
      if (prologue_sal.symtab->language != language_asm)
	{
	  struct linetable *linetable = LINETABLE (prologue_sal.symtab);
	  int idx = 0;

	  /* Skip any earlier lines, and any end-of-sequence marker
	     from a previous function.  */
	  while (linetable->item[idx].pc != prologue_sal.pc
		 || linetable->item[idx].line == 0)
	    idx++;

	  if (idx+1 < linetable->nitems
	      && linetable->item[idx+1].line != 0
	      && linetable->item[idx+1].pc == start_pc)
	    return start_pc;
	}

      /* If there is only one sal that covers the entire function,
	 then it is probably a single line function, like
	 "foo(){}".  */
      if (prologue_sal.end >= end_pc)
	return 0;

      while (prologue_sal.end < end_pc)
	{
	  struct symtab_and_line sal;

	  sal = find_pc_line (prologue_sal.end, 0);
	  if (sal.line == 0)
	    break;
	  /* Assume that a consecutive SAL for the same (or larger)
	     line mark the prologue -> body transition.  */
	  if (sal.line >= prologue_sal.line)
	    break;
	  /* Likewise if we are in a different symtab altogether
	     (e.g. within a file included via #include).  */
	  if (sal.symtab != prologue_sal.symtab)
	    break;

	  /* The line number is smaller.  Check that it's from the
	     same function, not something inlined.  If it's inlined,
	     then there is no point comparing the line numbers.  */
	  bl = block_for_pc (prologue_sal.end);
	  while (bl)
	    {
	      if (block_inlined_p (bl))
		break;
	      if (BLOCK_FUNCTION (bl))
		{
		  bl = NULL;
		  break;
		}
	      bl = BLOCK_SUPERBLOCK (bl);
	    }
	  if (bl != NULL)
	    break;

	  /* The case in which compiler's optimizer/scheduler has
	     moved instructions into the prologue.  We look ahead in
	     the function looking for address ranges whose
	     corresponding line number is less the first one that we
	     found for the function.  This is more conservative then
	     refine_prologue_limit which scans a large number of SALs
	     looking for any in the prologue.  */
	  prologue_sal = sal;
	}
    }

  if (prologue_sal.end < end_pc)
    /* Return the end of this line, or zero if we could not find a
       line.  */
    return prologue_sal.end;
  else
    /* Don't return END_PC, which is past the end of the function.  */
    return prologue_sal.pc;
}

/* Track MAIN */
static char *name_of_main;
enum language language_of_main = language_unknown;

void
set_main_name (const char *name)
{
  if (name_of_main != NULL)
    {
      xfree (name_of_main);
      name_of_main = NULL;
      language_of_main = language_unknown;
    }
  if (name != NULL)
    {
      name_of_main = xstrdup (name);
      language_of_main = language_unknown;
    }
}

/* Deduce the name of the main procedure, and set NAME_OF_MAIN
   accordingly.  */

static void
find_main_name (void)
{
  const char *new_main_name;

  /* Try to see if the main procedure is in Ada.  */
  /* FIXME: brobecker/2005-03-07: Another way of doing this would
     be to add a new method in the language vector, and call this
     method for each language until one of them returns a non-empty
     name.  This would allow us to remove this hard-coded call to
     an Ada function.  It is not clear that this is a better approach
     at this point, because all methods need to be written in a way
     such that false positives never be returned.  For instance, it is
     important that a method does not return a wrong name for the main
     procedure if the main procedure is actually written in a different
     language.  It is easy to guaranty this with Ada, since we use a
     special symbol generated only when the main in Ada to find the name
     of the main procedure.  It is difficult however to see how this can
     be guarantied for languages such as C, for instance.  This suggests
     that order of call for these methods becomes important, which means
     a more complicated approach.  */
  new_main_name = ada_main_name ();
  if (new_main_name != NULL)
    {
      set_main_name (new_main_name);
      return;
    }

  new_main_name = go_main_name ();
  if (new_main_name != NULL)
    {
      set_main_name (new_main_name);
      return;
    }

  new_main_name = pascal_main_name ();
  if (new_main_name != NULL)
    {
      set_main_name (new_main_name);
      return;
    }

  /* The languages above didn't identify the name of the main procedure.
     Fallback to "main".  */
  set_main_name ("main");
}

char *
main_name (void)
{
  if (name_of_main == NULL)
    find_main_name ();

  return name_of_main;
}

/* Handle ``executable_changed'' events for the symtab module.  */

static void
symtab_observer_executable_changed (void)
{
  /* NAME_OF_MAIN may no longer be the same, so reset it for now.  */
  set_main_name (NULL);
}

/* Return 1 if the supplied producer string matches the ARM RealView
   compiler (armcc).  */

int
producer_is_realview (const char *producer)
{
  static const char *const arm_idents[] = {
    "ARM C Compiler, ADS",
    "Thumb C Compiler, ADS",
    "ARM C++ Compiler, ADS",
    "Thumb C++ Compiler, ADS",
    "ARM/Thumb C/C++ Compiler, RVCT",
    "ARM C/C++ Compiler, RVCT"
  };
  int i;

  if (producer == NULL)
    return 0;

  for (i = 0; i < ARRAY_SIZE (arm_idents); i++)
    if (strncmp (producer, arm_idents[i], strlen (arm_idents[i])) == 0)
      return 1;

  return 0;
}



/* The next index to hand out in response to a registration request.  */

static int next_aclass_value = LOC_FINAL_VALUE;

/* The maximum number of "aclass" registrations we support.  This is
   constant for convenience.  */
#define MAX_SYMBOL_IMPLS (LOC_FINAL_VALUE + 10)

/* The objects representing the various "aclass" values.  The elements
   from 0 up to LOC_FINAL_VALUE-1 represent themselves, and subsequent
   elements are those registered at gdb initialization time.  */

static struct symbol_impl symbol_impl[MAX_SYMBOL_IMPLS];

/* The globally visible pointer.  This is separate from 'symbol_impl'
   so that it can be const.  */

const struct symbol_impl *symbol_impls = &symbol_impl[0];

/* Make sure we saved enough room in struct symbol.  */

gdb_static_assert (MAX_SYMBOL_IMPLS <= (1 << SYMBOL_ACLASS_BITS));

/* Register a computed symbol type.  ACLASS must be LOC_COMPUTED.  OPS
   is the ops vector associated with this index.  This returns the new
   index, which should be used as the aclass_index field for symbols
   of this type.  */

int
register_symbol_computed_impl (enum address_class aclass,
			       const struct symbol_computed_ops *ops)
{
  int result = next_aclass_value++;

  gdb_assert (aclass == LOC_COMPUTED);
  gdb_assert (result < MAX_SYMBOL_IMPLS);
  symbol_impl[result].aclass = aclass;
  symbol_impl[result].ops_computed = ops;

  /* Sanity check OPS.  */
  gdb_assert (ops != NULL);
  gdb_assert (ops->tracepoint_var_ref != NULL);
  gdb_assert (ops->describe_location != NULL);
  gdb_assert (ops->read_needs_frame != NULL);
  gdb_assert (ops->read_variable != NULL);

  return result;
}

/* Register a function with frame base type.  ACLASS must be LOC_BLOCK.
   OPS is the ops vector associated with this index.  This returns the
   new index, which should be used as the aclass_index field for symbols
   of this type.  */

int
register_symbol_block_impl (enum address_class aclass,
			    const struct symbol_block_ops *ops)
{
  int result = next_aclass_value++;

  gdb_assert (aclass == LOC_BLOCK);
  gdb_assert (result < MAX_SYMBOL_IMPLS);
  symbol_impl[result].aclass = aclass;
  symbol_impl[result].ops_block = ops;

  /* Sanity check OPS.  */
  gdb_assert (ops != NULL);
  gdb_assert (ops->find_frame_base_location != NULL);

  return result;
}

/* Register a register symbol type.  ACLASS must be LOC_REGISTER or
   LOC_REGPARM_ADDR.  OPS is the register ops vector associated with
   this index.  This returns the new index, which should be used as
   the aclass_index field for symbols of this type.  */

int
register_symbol_register_impl (enum address_class aclass,
			       const struct symbol_register_ops *ops)
{
  int result = next_aclass_value++;

  gdb_assert (aclass == LOC_REGISTER || aclass == LOC_REGPARM_ADDR);
  gdb_assert (result < MAX_SYMBOL_IMPLS);
  symbol_impl[result].aclass = aclass;
  symbol_impl[result].ops_register = ops;

  return result;
}

/* Initialize elements of 'symbol_impl' for the constants in enum
   address_class.  */

static void
initialize_ordinary_address_classes (void)
{
  int i;

  for (i = 0; i < LOC_FINAL_VALUE; ++i)
    symbol_impl[i].aclass = i;
}



/* Initialize the symbol SYM.  */

void
initialize_symbol (struct symbol *sym)
{
  memset (sym, 0, sizeof (*sym));
  SYMBOL_SECTION (sym) = -1;
}

/* Allocate and initialize a new 'struct symbol' on OBJFILE's
   obstack.  */

struct symbol *
allocate_symbol (struct objfile *objfile)
{
  struct symbol *result;

  result = OBSTACK_ZALLOC (&objfile->objfile_obstack, struct symbol);
  SYMBOL_SECTION (result) = -1;

  return result;
}

/* Allocate and initialize a new 'struct template_symbol' on OBJFILE's
   obstack.  */

struct template_symbol *
allocate_template_symbol (struct objfile *objfile)
{
  struct template_symbol *result;

  result = OBSTACK_ZALLOC (&objfile->objfile_obstack, struct template_symbol);
  SYMBOL_SECTION (&result->base) = -1;

  return result;
}



void
_initialize_symtab (void)
{
  initialize_ordinary_address_classes ();

  add_info ("variables", variables_info, _("\
All global and static variable names, or those matching REGEXP."));
  if (dbx_commands)
    add_com ("whereis", class_info, variables_info, _("\
All global and static variable names, or those matching REGEXP."));

  add_info ("functions", functions_info,
	    _("All function names, or those matching REGEXP."));

  /* FIXME:  This command has at least the following problems:
     1.  It prints builtin types (in a very strange and confusing fashion).
     2.  It doesn't print right, e.g. with
     typedef struct foo *FOO
     type_print prints "FOO" when we want to make it (in this situation)
     print "struct foo *".
     I also think "ptype" or "whatis" is more likely to be useful (but if
     there is much disagreement "info types" can be fixed).  */
  add_info ("types", types_info,
	    _("All type names, or those matching REGEXP."));

  add_info ("sources", sources_info,
	    _("Source files in the program."));

  add_com ("rbreak", class_breakpoint, rbreak_command,
	   _("Set a breakpoint for all functions matching REGEXP."));

  if (xdb_commands)
    {
      add_com ("lf", class_info, sources_info,
	       _("Source files in the program"));
      add_com ("lg", class_info, variables_info, _("\
All global and static variable names, or those matching REGEXP."));
    }

  add_setshow_enum_cmd ("multiple-symbols", no_class,
                        multiple_symbols_modes, &multiple_symbols_mode,
                        _("\
Set the debugger behavior when more than one symbol are possible matches\n\
in an expression."), _("\
Show how the debugger handles ambiguities in expressions."), _("\
Valid values are \"ask\", \"all\", \"cancel\", and the default is \"all\"."),
                        NULL, NULL, &setlist, &showlist);

  add_setshow_boolean_cmd ("basenames-may-differ", class_obscure,
			   &basenames_may_differ, _("\
Set whether a source file may have multiple base names."), _("\
Show whether a source file may have multiple base names."), _("\
(A \"base name\" is the name of a file with the directory part removed.\n\
Example: The base name of \"/home/user/hello.c\" is \"hello.c\".)\n\
If set, GDB will canonicalize file names (e.g., expand symlinks)\n\
before comparing them.  Canonicalization is an expensive operation,\n\
but it allows the same file be known by more than one base name.\n\
If not set (the default), all source files are assumed to have just\n\
one base name, and gdb will do file name comparisons more efficiently."),
			   NULL, NULL,
			   &setlist, &showlist);

  add_setshow_boolean_cmd ("symtab-create", no_class, &symtab_create_debug,
			   _("Set debugging of symbol table creation."),
			   _("Show debugging of symbol table creation."), _("\
When enabled, debugging messages are printed when building symbol tables."),
			    NULL,
			    NULL,
			    &setdebuglist, &showdebuglist);

  observer_attach_executable_changed (symtab_observer_executable_changed);
}
@


1.370
log
@Use FILENAME_CMP to compare filenames in compare_search_syms.

gdb/ChangeLog:

        * symtab.c (compare_search_syms): Use FILENAME_CMP instead of
        strcmp to compare two symtab filenames.
@
text
@d595 1
a595 1
  objfile->demangled_names_hash = htab_create_alloc
d690 1
a690 1
   comes from that objfile's objfile_obstack.  LINKAGE_NAME is copied,
d726 1
d742 1
a742 1
	  char *name = obstack_alloc (&objfile->objfile_obstack, len + 1);
d748 1
a748 1
      symbol_set_demangled_name (gsymbol, NULL, &objfile->objfile_obstack);
d753 1
a753 1
  if (objfile->demangled_names_hash == NULL)
d793 1
a793 1
	  htab_find_slot (objfile->demangled_names_hash,
d818 1
a818 1
	  *slot = obstack_alloc (&objfile->objfile_obstack,
d831 1
a831 1
	  *slot = obstack_alloc (&objfile->objfile_obstack,
d852 1
a852 1
			       &objfile->objfile_obstack);
d854 1
a854 1
    symbol_set_demangled_name (gsymbol, NULL, &objfile->objfile_obstack);
@


1.369
log
@Delete search_symbols_equal (use compare_search_syms instead).

This avoids duplicating the logic comparing two symbol_search
objects (in search_symbols_equal and compare_search_syms).

gdb/ChangeLog:

        * symtab.c (search_symbols_equal): Delete.
        (sort_search_symbols_remove_dups): Replace call to
        search_symbols_equal by call to compare_search_syms,
        adjusting as necessary.
@
text
@d3339 1
a3339 1
  c = strcmp (sym_a->symtab->filename, sym_b->symtab->filename);
@


1.368
log
@	* symtab.c (domain_name, search_domain_name): New functions.
	* symtab.h (domain_name, search_domain_name): Declare.
@
text
@a3349 13
/* Helper function for sort_search_symbols_remove_dups.
   Return TRUE if symbols A, B are equal.  */

static int
search_symbols_equal (const struct symbol_search *a,
		      const struct symbol_search *b)
{
  return (strcmp (a->symtab->filename, b->symtab->filename) == 0
	  && a->block == b->block
	  && strcmp (SYMBOL_PRINT_NAME (a->symbol),
		     SYMBOL_PRINT_NAME (b->symbol)) == 0);
}

d3383 1
a3383 1
      if (! search_symbols_equal (symbols[j - 1], symbols[i]))
@


1.367
log
@use language of the main symbol

With "dwz -m", "main" appears in both the PU and the importing CU when
running anon-struct.exp.  However, the PU does not have a file name.
So, find_main_filename returns the empty string, making
deduce_language_from_filename return language_unknown.

This patch fixes this problem by changing gdb to use the ordinary
symbol-lookup functions to find "main"'s symbol.  Then, it examines the
symbol's language.

I think this is cleaner than the current approach.  For one thing it
avoids trying to guess the language based on the source file name,
instead deferring to the presumably more reliable debuginfo.

Another possible fix would have been to change how the file name is
found via the "qf" methods.  However, I think the approach given is
preferable for the reason outlined above.

This required a minor test suite change, as now a symtab is expanded
during the search for "main".

Built and regtested (both ways) on x86-64 Fedora 18.

	* symfile.c (set_initial_language): Look up "main" symbol
	and use its language.
	* symtab.c (find_main_filename): Remove.
	* symtab.h (find_main_filename): Remove.

	* gdb.base/maint.exp: Allow zero symtabs to be expanded.
@
text
@d146 31
@


1.366
log
@remove msymbol_objfile

This is another patch in my ongoing series to "split" objfile to share
more read-only data across inferiors.  See

    http://sourceware.org/gdb/wiki/ObjfileSplitting

When symbols are finally shared, there will be no back-link from the
symbol to its containing objfile, because there may be more than one
such objfile.  So, all such back-links must be removed.

One hidden back-link is the msymbol_objfile function.  Since
(eventually) a symbol may appear in more than one objfile, trying to
look up the objfile given just a symbol cannot work.

This patch removes msymbol_objfile in favor of using a bound minimal
symbol.  It introduces a new function to make this conversion simpler
in some spots.

The bonus of this patch is that using msymbol_objfile is slower than
simply looking up the owning objfile in the first place.

Built and regtested on x86-64 Fedora 18.

	* ada-exp.y (write_var_or_type): Use bound_minimal_symbol.
	* ada-lang.c (ada_lookup_simple_minsym): Return
	bound_minimal_symbol.
	* ada-lang.h (ada_lookup_simple_minsym): Update.
	* c-exp.y (variable): Use lookup_bound_minimal_symbol.
	* f-exp.y (variable): Use lookup_bound_minimal_symbol.
	* go-exp.y (variable): Use lookup_bound_minimal_symbol.
	* jv-exp.y (push_expression_name): Use lookup_bound_minimal_symbol.
	* m2-exp.y (variable): Use lookup_bound_minimal_symbol.
	* minsyms.c (msymbol_objfile): Remove.
	(lookup_minimal_symbol_internal): New function, from
	lookup_minimal_symbol.
	(lookup_minimal_symbol): Rewrite using
	lookup_minimal_symbol_internal.
	(lookup_bound_minimal_symbol): New function.
	* minsyms.h (msymbol_objfile): Remove.
	(lookup_bound_minimal_symbol): Declare.
	* p-exp.y (variable): Use lookup_bound_minimal_symbol.
	* parse.c (write_exp_msymbol): Change parameter to a
	bound_minimal_symbol.
	(write_dollar_variable): Use lookup_bound_minimal_symbol.
	* parser-defs.h (write_exp_msymbol): Update.
	* printcmd.c (address_info): Use lookup_bound_minimal_symbol.
	* symfile.c (simple_read_overlay_table): Use
	lookup_bound_minimal_symbol.
	* symtab.c (skip_prologue_sal): Don't use msymbol_objfile.
	(search_symbols): Likewise.
	(print_msymbol_info): Take a bound_minimal_symbol argument.
	(symtab_symbol_info, rbreak_command): Update.
	* symtab.h (struct symbol_search) <msymbol>: Change type
	to bound_minimal_symbol.
	* valops.c (find_function_in_inferior): Use
	lookup_bound_minimal_symbol.
	* value.c (value_fn_field): Use lookup_bound_minimal_symbol.
@
text
@a1951 23
/* Find the name of the file containing main().  */
/* FIXME:  What about languages without main() or specially linked
   executables that have no main() ?   */

const char *
find_main_filename (void)
{
  struct objfile *objfile;
  char *name = main_name ();

  ALL_OBJFILES (objfile)
  {
    const char *result;

    if (!objfile->sf)
      continue;
    result = objfile->sf->qf->find_symbol_file (objfile, name);
    if (result)
      return result;
  }
  return (NULL);
}

@


1.365
log
@	* symtab.c (do_free_search_symbols_cleanup): Change arg to,
	effectively, struct symbol_search **.
	(make_cleanup_free_search_symbols): Change arg to struct
	symbol_search **.  All callers updated.
	(compare_search_syms): Compare symtab file name and block as well.
	(search_symbols_equal): New function.
	(sort_search_symbols_remove_dups): Renamed from sort_search_symbols.
	New args new_head, new_tail.  Result is now void.  Remove dups after
	sorting the symbols.
	(search_symbols): Sort all found symbols once, after all have been
	found, and remove duplicates.  Simplify cleanup tracking of result.
	* symtab.h (make_cleanup_free_search_symbols): Update prototype.
@
text
@a103 2
static void print_msymbol_info (struct minimal_symbol *);

d2833 2
a2834 2
      struct minimal_symbol *msymbol
        = lookup_minimal_symbol_by_pc_section (sal->pc, sal->section).minsym;
d2836 1
a2836 1
      if (msymbol == NULL)
d2842 4
a2845 4
      objfile = msymbol_objfile (msymbol);
      pc = SYMBOL_VALUE_ADDRESS (msymbol);
      section = SYMBOL_OBJ_SECTION (objfile, msymbol);
      name = SYMBOL_LINKAGE_NAME (msymbol);
d3667 1
a3667 1
		psr->msymbol = NULL;
d3720 2
a3721 1
			psr->msymbol = msymbol;
d3785 1
a3785 1
print_msymbol_info (struct minimal_symbol *msymbol)
d3787 1
a3787 1
  struct gdbarch *gdbarch = get_objfile_arch (msymbol_objfile (msymbol));
d3791 1
a3791 1
    tmp = hex_string_custom (SYMBOL_VALUE_ADDRESS (msymbol)
d3795 1
a3795 1
    tmp = hex_string_custom (SYMBOL_VALUE_ADDRESS (msymbol),
d3798 1
a3798 1
		   tmp, SYMBOL_PRINT_NAME (msymbol));
d3833 1
a3833 1
      if (p->msymbol != NULL)
d3930 1
a3930 1
      if (p->msymbol == NULL)
d3956 1
a3956 1
	  int newlen = (strlen (SYMBOL_LINKAGE_NAME (p->msymbol)) + 3);
d3964 1
a3964 1
	  strcat (string, SYMBOL_LINKAGE_NAME (p->msymbol));
d3969 1
a3969 1
			   SYMBOL_PRINT_NAME (p->msymbol));
@


1.364
log
@	* symtab.c (iterate_over_some_symtabs): Add comment.
@
text
@d3310 1
a3310 1
do_free_search_symbols_cleanup (void *symbols)
d3312 2
d3318 1
a3318 1
make_cleanup_free_search_symbols (struct symbol_search *symbols)
d3320 1
a3320 1
  return make_cleanup (do_free_search_symbols_cleanup, symbols);
d3323 1
a3323 1
/* Helper function for sort_search_symbols and qsort.  Can only
d3329 7
a3335 2
  struct symbol_search **sym_a = (struct symbol_search **) sa;
  struct symbol_search **sym_b = (struct symbol_search **) sb;
d3337 5
a3341 2
  return strcmp (SYMBOL_PRINT_NAME ((*sym_a)->symbol),
		 SYMBOL_PRINT_NAME ((*sym_b)->symbol));
d3344 2
a3345 3
/* Sort the ``nfound'' symbols in the list after prevtail.  Leave
   prevtail where it is, but update its next pointer to point to
   the first of the sorted symbols.  */
d3347 18
a3364 2
static struct symbol_search *
sort_search_symbols (struct symbol_search *prevtail, int nfound)
d3367 3
a3369 1
  int i;
d3371 1
d3374 1
a3374 1
  symp = prevtail->next;
d3377 2
d3382 1
a3382 2
  /* Generally NULL.  */
  old_next = symp;
d3387 2
a3388 2
  symp = prevtail;
  for (i = 0; i < nfound; i++)
d3390 4
a3393 2
      symp->next = symbols[i];
      symp = symp->next;
d3395 7
a3401 1
  symp->next = old_next;
d3403 2
a3405 1
  return symp;
d3453 3
a3455 2
   The results are sorted locally; each symtab's global and static blocks are
   separately alphabetized.  */
d3483 1
a3483 2
  struct symbol_search *sr;
  struct symbol_search *psr;
d3486 1
d3500 1
a3500 2
  sr = *matches = NULL;
  tail = NULL;
a3571 2
  retval_chain = make_cleanup (null_cleanup, NULL);

d3620 5
a3629 3
	struct symbol_search *prevtail = tail;
	int nfound = 0;

d3664 1
a3664 1
		psr = (struct symbol_search *)
d3672 1
a3672 1
		  sr = psr;
a3678 15
	if (nfound > 0)
	  {
	    if (prevtail == NULL)
	      {
		struct symbol_search dummy;

		dummy.next = sr;
		tail = sort_search_symbols (&dummy, nfound);
		sr = dummy.next;

		make_cleanup_free_search_symbols (sr);
	      }
	    else
	      tail = sort_search_symbols (prevtail, nfound);
	  }
d3682 6
d3719 1
a3719 1
			psr = (struct symbol_search *)
d3727 1
a3727 4
			  {
			    sr = psr;
			    make_cleanup_free_search_symbols (sr);
			  }
d3740 1
a3740 1
  *matches = sr;
d3822 1
a3822 1
  old_chain = make_cleanup_free_search_symbols (symbols);
d3924 1
a3924 1
  old_chain = make_cleanup_free_search_symbols (ss);
@


1.363
log
@	* symtab.c (iterate_over_some_symtabs): Fix indentation.
@
text
@d189 3
a235 1

@


1.362
log
@fix symtab.c

search_symbols had some bad code resulting in a cleanup being both
discarded and run.

	* symtab.c (search_symbols): Introduce a null cleanup for
	'retval_chain'.
@
text
@d218 5
a222 5
    /* Before we invoke realpath, which can get expensive when many
       files are involved, do a quick comparison of the basenames.  */
    if (! basenames_may_differ
	&& FILENAME_CMP (base_name, lbasename (s->filename)) != 0)
      continue;
d224 6
a229 6
    if (compare_filenames_for_search (symtab_to_fullname (s), name))
      {
	if (callback (s, data))
	  return 1;
	continue;
      }
d231 2
a232 2
    /* If the user gave us an absolute path, try to find the file in
       this symtab and use its absolute path.  */
d234 3
a236 3
    if (real_path != NULL)
      {
        const char *fullname = symtab_to_fullname (s);
d238 9
a246 9
	gdb_assert (IS_ABSOLUTE_PATH (real_path));
	gdb_assert (IS_ABSOLUTE_PATH (name));
	if (FILENAME_CMP (real_path, fullname) == 0)
	  {
	    if (callback (s, data))
	      return 1;
	    continue;
	  }
      }
@


1.361
log
@	PR c++/11990:
	* c-lang.c (cplus_language_defn): Use gdb_demangle.
	* c-typeprint.c (c_type_print_base): Use gdb_demangle.
	* cp-support.c (mangled_name_to_comp): Use gdb_demangle.
	(gdb_demangle): New function.
	* cp-support.h (gdb_demangle): Declare.
	* dwarf2read.c (dwarf2_physname, fixup_partial_die)
	(dwarf2_name): Use gdb_demangle.
	* gdbtypes.c (check_stub_method): Use gdb_demangle.
	* gnu-v3-abi.c (gnuv3_rtti_type): Strip @@plt and version
	suffixes from name.
	(gnuv3_print_method_ptr): Use gdb_demangle.
	* jv-lang.c (java_demangle): Use gdb_demangle.
	* jv-typeprint.c (java_type_print_base): Use gdb_demangle.
	* language.c (unk_lang_demangle): Use gdb_demangle.
	* symtab.c (symbol_find_demangled_name)
	(demangle_for_lookup): Use gdb_demangle.
@
text
@d3532 1
a3532 1
  retval_chain = old_chain;
@


1.360
log
@	PR symtab/8424:
	* blockframe.c (find_pc_partial_function_gnu_ifunc): Check
	SYMBOL_SECTION, not SYMBOL_OBJ_SECTION.
	* breakpoint.c (resolve_sal_pc): Update.
	* elfread.c (elf_gnu_ifunc_record_cache): Update.
	* findvar.c (struct minsym_lookup_data) <objfile>: New field.
	(minsym_lookup_iterator_cb): Use it.
	(default_read_var_value): Update.
	* hppa-hpux-tdep.c (hppa64_hpux_in_solib_call_trampoline):
	Update.
	* infcmd.c (jump_command): Update.
	* linespec.c (minsym_found): Update.
	* maint.c (maintenance_translate_address): Update.
	* minsyms.c (lookup_minimal_symbol_by_pc_section_1): Update.
	(prim_record_minimal_symbol_full): Don't set SYMBOL_OBJ_SECTION.
	* parse.c (write_exp_msymbol): Update.
	* printcmd.c (address_info): Update.
	* psymtab.c (find_pc_sect_psymbol): Update.
	(fixup_psymbol_section): Check SYMBOL_SECTION, not
	SYMBOL_OBJ_SECTION.
	(add_psymbol_to_bcache): Correctly initialize SYMBOL_SECTION.
	Don't initialize SYMBOL_OBJ_SECTION.
	* spu-tdep.c (spu_catch_start): Update.
	* stabsread.c (define_symbol): Don't set SYMBOL_SECTION.
	* symmisc.c (dump_msymbols, print_symbol): Update.
	* symtab.c (fixup_section): Don't set 'obj_section'.  Change
	how fallback section is computed.
	(fixup_symbol_section): Update.
	(find_pc_sect_symtab, find_function_start_sal, skip_prologue_sal):
	Update.
	(allocate_symbol, initialize_symbol, allocate_template_symbol):
	Initialize SYMBOL_SECTION.
	* symtab.h (struct general_symbol_info) <section>: Update comment.
	<obj_section>: Remove.
	(SYMBOL_OBJ_SECTION): Add 'objfile' argument.  Rewrite.
	(SYMBOL_OBJFILE): New macro.
@
text
@d599 1
a599 1
        cplus_demangle (mangled, DMGL_PARAMS | DMGL_ANSI);
d609 2
a610 2
        cplus_demangle (mangled,
                        DMGL_PARAMS | DMGL_ANSI | DMGL_JAVA);
d1163 1
a1163 1
      demangled_name = cplus_demangle (name, DMGL_ANSI | DMGL_PARAMS);
d1183 2
a1184 2
      demangled_name = cplus_demangle (name,
		      		       DMGL_ANSI | DMGL_PARAMS | DMGL_JAVA);
@


1.359
log
@	* coffread.c (cs_to_section): Use gdb_bfd_section_index.
	* elfread.c (record_minimal_symbol, elf_symtab_read): Use
	gdb_bfd_section_index.
	* gdb_bfd.c (gdb_bfd_section_index, gdb_bfd_count_sections):
	New functions.
	* gdb_bfd.h (gdb_bfd_section_index, gdb_bfd_count_sections):
	Declare.
	* machoread.c (macho_symtab_add_minsym, macho_symfile_offsets):
	Update.
	* objfiles.c (add_to_objfile_sections_full): New function.
	(add_to_objfile_sections): Use it.
	(build_section_table): Rewrite.
	(objfile_relocate1): Use gdb_bfd_section_index.  Update.
	* objfiles.h (obj_section_offset): Use gdb_bfd_section_index.
	(struct objfile) <sections>: Update comment.
	(ALL_OBJFILE_OSECTIONS): Skip sections where the_bfd_section
	is NULL.
	(ALL_OBJSECTIONS): Use it.
	* solib-dsbt.c (dsbt_relocate_main_executable): Update.
	* solib-frv.c (frv_relocate_main_executable): Update.
	* solib-target.c (solib_target_relocate_section_addresses):
	Use gdb_bfd_section_index.
	* symfile.c (build_section_addr_info_from_section_table):
	Use gdb_bfd_section_index.
	(build_section_addr_info_from_bfd, place_section): Likewise.
	* symtab.c (fixup_section): Update.
	* xcoffread.c (find_targ_sec): Use gdb_bfd_section_index.
@
text
@d1021 1
a1021 4
    {
      ginfo->obj_section = SYMBOL_OBJ_SECTION (msym);
      ginfo->section = SYMBOL_SECTION (msym);
    }
d1061 1
d1068 3
a1073 1
	      ginfo->obj_section = s;
d1078 8
a1096 3
  if (SYMBOL_OBJ_SECTION (sym))
    return sym;

d1104 3
d2142 2
a2143 1
		if (matching_obj_sections (SYMBOL_OBJ_SECTION (sym), section))
d2775 1
a2775 1
			   SYMBOL_OBJ_SECTION (sym), 0);
d2786 1
a2786 1
      sal.section = SYMBOL_OBJ_SECTION (sym);
d2827 1
a2827 1
      section = SYMBOL_OBJ_SECTION (sym);
d2842 1
d2844 1
a2844 1
      section = SYMBOL_OBJ_SECTION (msymbol);
a2845 1
      objfile = msymbol_objfile (msymbol);
d5158 1
d5170 1
d5184 1
@


1.358
log
@	* minsyms.h (struct bound_minimal_symbol): New.
	(lookup_minimal_symbol_and_objfile): Return bound_minimal_symbol.
	Remove objfile argument.
	(lookup_minimal_symbol_by_pc_section, lookup_minimal_symbol_by_pc):
	Return bound_minimal_symbol.
	* minsyms.c (lookup_minimal_symbol_by_pc_1)
	(lookup_minimal_symbol_by_pc_section, lookup_minimal_symbol_by_pc):
	Return bound_minimal_symbol.
	(in_gnu_ifunc_stub): Update.
	(lookup_minimal_symbol_and_objfile): Return bound_minimal_symbol.
	Remove 'objfile_p' argument.
	(lookup_solib_trampoline_symbol_by_pc): Update.
	* ada-tasks.c, amd64-windows-tdep.c, arm-tdep.c,
	arm-wince-tdep.c, block.c, blockframe.c, breakpoint.c, btrace.c,
	c-valprint.c, dwarf2loc.c, elfread.c, frame.c, frv-tdep.c,
	glibc-tdep.c, gnu-v2-abi.c, gnu-v3-abi.c, hppa-hpux-tdep.c,
	i386-tdep.c, ia64-tdep.c, infcall.c, infcmd.c, jit.c,
	linux-fork.c, m32c-tdep.c, m68hc11-tdep.c, maint.c,
	mips-tdep.c, p-valprint.c, parse.c, ppc-linux-tdep.c,
	ppc-sysv-tdep.c, printcmd.c, rs6000-tdep.c, sh64-tdep.c,
	stack.c, symtab.c, tui/tui-disasm.c: Update.
@
text
@d1067 1
a1067 1
	  int idx = s->the_bfd_section->index;
@


1.357
log
@	* ada-lang.c (ada_decode_symbol): Check and set 'ada_mangled'.
	Use symbol's obstack, not an objfile.
	* coffread.c (process_coff_symbol): Update.
	* dwarf2read.c (fixup_go_packaging, new_symbol_full): Update.
	* jv-lang.c (add_class_symbol): Update.
	* mdebugread.c (new_symbol): Update.
	* minsyms.c (prim_record_minimal_symbol_full)
	(terminate_minimal_symbol_table): Update.
	* psymtab.c (add_psymbol_to_bcache): Clear entire symbol.  Update.
	* stabsread.c (define_symbol, read_enum_type): Update.
	* symtab.c (symbol_set_demangled_name, symbol_get_demangled_name):
	Handle Ada specially.
	(symbol_set_language): Add 'obstack' argument.
	(symbol_set_names): Update.
	(symbol_natural_name, symbol_demangled_name): Always use
	ada_decode_symbol.
	* symtab.h (struct general_symbol_info)
	<language_specific::obstack>: New field.
	<ada_mangled>: New field.
	(SYMBOL_SET_LANGUAGE): Add 'obstack' argument.
	(symbol_set_language): Update.
@
text
@d982 1
a982 1
  msymbol = lookup_minimal_symbol_by_pc_section (pc, section);
d2074 1
a2074 1
  msymbol = lookup_minimal_symbol_by_pc_section (pc, section);
d2205 1
a2205 1
  struct minimal_symbol *msymbol;
d2291 2
a2292 2
  if (msymbol != NULL)
    if (MSYMBOL_TYPE (msymbol) == mst_solib_trampoline)
d2294 3
a2296 2
	mfunsym = lookup_minimal_symbol_text (SYMBOL_LINKAGE_NAME (msymbol),
					      NULL);
d2312 1
a2312 1
		 == SYMBOL_VALUE_ADDRESS (msymbol))
d2825 1
a2825 1
        = lookup_minimal_symbol_by_pc_section (sal->pc, sal->section);
d2881 2
a2882 2
	      : (lookup_minimal_symbol_by_pc_section (start_sal.end, section)
		 == lookup_minimal_symbol_by_pc_section (pc, section))))
@


1.356
log
@	* symtab.c (symbol_init_cplus_specific, symbol_set_demangled_name):
	Take an obstack, not an objfile.
	(symbol_set_names): Update.
	* symtab.h (symbol_set_demangled_name): Update.
@
text
@d451 13
d480 8
a487 2
  else
    return gsymbol->language_specific.mangled_lang.demangled_name;
d496 2
a497 1
                     enum language language)
d506 6
a511 1
      symbol_set_demangled_name (gsymbol, NULL, NULL);
d716 1
a716 1
      symbol_set_demangled_name (gsymbol, NULL, NULL);
d843 1
a843 5
      if (symbol_get_demangled_name (gsymbol) != NULL)
	return symbol_get_demangled_name (gsymbol);
      else
	return ada_decode_symbol (gsymbol);
      break;
d869 1
a869 3
      dem_name = symbol_get_demangled_name (gsymbol);
      if (dem_name == NULL)
	dem_name = ada_decode_symbol (gsymbol);
@


1.355
log
@	* coffread.c (process_coff_symbol, coff_read_enum_type): Call
	allocate_symbol.
	* dwarf2read.c (fixup_go_packaging): Call allocate_symbol.
	(read_func_scope): Call allocate_template_symbol.
	(new_symbol_full): Call allocate_symbol.
	* jit.c (finalize_symtab): Call allocate_symbol.
	* jv-lang.c (add_class_symbol): Call allocate_symbol.
	* mdebugread.c (parse_symbol, new_block): Call allocate_symbol.
	* stabsread.c (patch_block_stabs, define_symbol, read_enum_type)
	(common_block_end): Call allocate_symbol.
	* symtab.c (allocate_symbol, initialize_symbol)
	(allocate_template_symbol): New functions.
	* symtab.c (allocate_symbol, initialize_symbol)
	(allocate_template_symbol): Declare.
	* xcoffread.c (process_xcoff_symbol): Call initialize_symbol.
@
text
@d423 1
a423 1
                           struct objfile *objfile)
d428 1
a428 1
  gdb_assert (objfile != NULL);
d431 1
a431 1
      OBSTACK_ZALLOC (&objfile->objfile_obstack, struct cplus_specific);
d442 1
a442 1
                           struct objfile *objfile)
d447 1
a447 1
	symbol_init_cplus_specific (gsymbol, objfile);
d794 2
a795 1
    symbol_set_demangled_name (gsymbol, (*slot)->demangled, objfile);
d797 1
a797 1
    symbol_set_demangled_name (gsymbol, NULL, objfile);
@


1.354
log
@	* ax-gdb.c (gen_var_ref): Unconditionally call via computed ops,
	if possible.
	* dwarf2read.c (read_func_scope): Remove old FIXME.
	* eval.c (evaluate_subexp_standard): Check SYMBOL_COMPUTED_OPS,
	not LOC_COMPUTED.
	* findvar.c (symbol_read_needs_frame, default_read_var_value):
	Unconditionally call via computed ops, if possible.
	* printcmd.c (address_info): Unconditionally call via computed ops,
	if possible.
	* stack.c (read_frame_arg): Unconditionally call via computed ops,
	if possible.
	* symtab.c (register_symbol_computed_impl): Sanity check 'ops'.
	* tracepoint.c (scope_info): Unconditionally call via computed ops,
	if possible.
@
text
@d5122 36
@


1.353
log
@2013-03-20  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	    Tom Tromey  <tromey@@redhat.com>

	PR symtab/8421:
	* coffread.c (coff_register_index): New global.
	(process_coff_symbol, coff_read_enum_type): Set
	SYMBOL_ACLASS_INDEX.
	(_initialize_coffread): Initialize new global.
	* dwarf2loc.c (locexpr_find_frame_base_location)
	(dwarf2_block_frame_base_locexpr_funcs)
	(loclist_find_frame_base_location)
	(dwarf2_block_frame_base_loclist_funcs): New.
	(dwarf_expr_frame_base_1): Call SYMBOL_BLOCK_OPS, remove internal_error.
	(dwarf2_locexpr_funcs, dwarf2_loclist_funcs): Add location_has_loclist.
	* dwarf2loc.h (dwarf2_block_frame_base_locexpr_funcs)
	(dwarf2_block_frame_base_loclist_funcs): New.
	* dwarf2read.c (dwarf2_locexpr_index, dwarf2_loclist_index)
	(dwarf2_locexpr_block_index, dwarf2_loclist_block_index): New
	globals.
	(read_func_scope): Update.
	(fixup_go_packaging, mark_common_block_symbol_computed)
	(var_decode_location, new_symbol_full, dwarf2_const_value):
	Set SYMBOL_ACLASS_INDEX.
	(dwarf2_symbol_mark_computed): Likewise.  Add 'is_block' argument.
	(_initialize_dwarf2_read): Initialize new globals.
	* jit.c (finalize_symtab): Set SYMBOL_ACLASS_INDEX.
	* jv-lang.c (add_class_symbol): Set SYMBOL_ACLASS_INDEX.
	* mdebugread.c (mdebug_register_index, mdebug_regparm_index): New
	globals.
	(parse_symbol, psymtab_to_symtab_1): Set SYMBOL_ACLASS_INDEX.
	(_initialize_mdebugread): Initialize new globals.
	* psympriv.h (struct partial_symbol) <aclass>: Update comment.
	* stabsread.c (patch_block_stabs): Set SYMBOL_ACLASS_INDEX.
	(stab_register_index, stab_regparm_index): New globals.
	(define_symbol, read_enum_type, common_block_end): Set
	SYMBOL_ACLASS_INDEX.
	(_initialize_stabsread): Initialize new globals.
	* symtab.c (next_aclass_value, symbol_impl, symbol_impls): New
	globals.
	(MAX_SYMBOL_IMPLS): New define.
	(register_symbol_computed_impl, register_symbol_block_impl)
	(register_symbol_register_impl)
	(initialize_ordinary_address_classes): New functions.
	(_initialize_symtab): Call initialize_ordinary_address_classes.
	* symtab.h (enum address_class) <LOC_FINAL_VALUE>: New constant.
	(struct symbol_impl): New.
	(SYMBOL_ACLASS_BITS): New define.
	(struct symbol) <aclass, ops>: Remove fields.
	<aclass_index>: New field.
	(symbol_impls): Declare.
	(SYMBOL_CLASS, SYMBOL_COMPUTED_OPS, SYMBOL_REGISTER_OPS): Redefine.
	(SYMBOL_IMPL, SYMBOL_ACLASS_INDEX): New defines.
	(register_symbol_computed_impl, register_symbol_block_impl)
	(register_symbol_register_impl): Declare.
	(struct symbol_computed_ops): Add location_has_loclist.
	(struct symbol_block_ops): New.
	(SYMBOL_BLOCK_OPS): New.
	* xcoffread.c (process_xcoff_symbol): Set SYMBOL_ACLASS_INDEX.
@
text
@d5056 7
@


1.352
log
@	* symtab.c (error_in_psymtab_expansion): New function.
	(lookup_symbol_aux_quick)
	(basic_lookup_transparent_type_quick): Remove "last resort"
	code.  Use error_in_psymtab_expansion.
@
text
@d5015 100
d5118 2
@


1.351
log
@gdb/
	* dwarf2read.c (dw2_map_symtabs_matching_filename): Put continue after
	any successful compare_filenames_for_search or FILENAME_CMP.
	* psymtab.c (partial_map_symtabs_matching_filename): Likewise.
	* symtab.c (iterate_over_some_symtabs): Likewise.
@
text
@d1619 14
d1655 1
a1655 24
    {
      /* This shouldn't be necessary, but as a last resort try
	 looking in the statics even though the psymtab claimed
	 the symbol was global, or vice-versa.  It's possible
	 that the psymtab gets it wrong in some cases.  */

      /* FIXME: carlton/2002-09-30: Should we really do that?
	 If that happens, isn't it likely to be a GDB error, in
	 which case we should fix the GDB error rather than
	 silently dealing with it here?  So I'd vote for
	 removing the check for the symbol in the other
	 block.  */
      block = BLOCKVECTOR_BLOCK (bv,
				 kind == GLOBAL_BLOCK ?
				 STATIC_BLOCK : GLOBAL_BLOCK);
      sym = lookup_block_symbol (block, name, domain);
      if (!sym)
	error (_("\
Internal: %s symbol `%s' found in %s psymtab but not in symtab.\n\
%s may be an inlined function, or may be a template function\n\
(if a template, try specifying an instantiation: %s<type>)."),
	       kind == GLOBAL_BLOCK ? "global" : "static",
	       name, symtab_to_filename_for_display (symtab), name, name);
    }
d1843 1
a1843 2
    {
      int other_kind = kind == GLOBAL_BLOCK ? STATIC_BLOCK : GLOBAL_BLOCK;
a1844 15
      /* This shouldn't be necessary, but as a last resort
       * try looking in the 'other kind' even though the psymtab
       * claimed the symbol was one thing.  It's possible that
       * the psymtab gets it wrong in some cases.
       */
      block = BLOCKVECTOR_BLOCK (bv, other_kind);
      sym = lookup_block_symbol (block, name, STRUCT_DOMAIN);
      if (!sym)
	/* FIXME; error is wrong in one case.  */
	error (_("\
Internal: global symbol `%s' found in %s psymtab but not in symtab.\n\
%s may be an inlined function, or may be a template function\n\
(if a template, try specifying an instantiation: %s<type>)."),
	       name, symtab_to_filename_for_display (symtab), name, name);
    }
@


1.350
log
@Constify strings in tracepoint.c, lookup_cmd and the completers.

This is sort of a continuation of Keith's parse_exp_1 constification
patch.  It started out by undoing these bits:

  @@@@ -754,9 +754,12 @@@@ validate_actionline (char **line, struct
   	  tmp_p = p;
   	  for (loc = t->base.loc; loc; loc = loc->next)
   	    {
  -	      p = tmp_p;
  -	      exp = parse_exp_1 (&p, loc->address,
  +	      const char *q;
  +
  +	      q = tmp_p;
  +	      exp = parse_exp_1 (&q, loc->address,
   				 block_for_pc (loc->address), 1);
  +	      p = (char *) q;

and progressively making more things const upwards, fixing fallout,
rinse repeat, until GDB built again (--enable-targets=all).

That ended up constifying lookup_cmd/add_cmd and (lots of) friends,
and the completers.

I didn't try to constify the command hooks themselves, because I know
upfront there are commands that write to the command string argument,
and I think I managed to stop at a nice non-hacky split point already.

I think the only non-really-super-obvious changes are
tracepoint.c:validate_actionline, and tracepoint.c:trace_dump_actions.

The rest is just mostly about 'char *' => 'const char *', 'char **'=>
'const char **', and the occasional (e.g., deprecated_cmd_warning)
case of 'char **'=> 'const char *', where/when I noticed that nothing
actually cares about the pointer to pointer output.

Tested on x86_64 Fedora 17, native and gdbserver.

gdb/
2013-03-13  Pedro Alves  <palves@@redhat.com>

	* ada-lang.c (struct add_partial_datum) <text, text0, word>: Make
	fields const.
	(ada_make_symbol_completion_list): Make "text0" parameter const.
	* ax-gdb.c (agent_eval_command_one): Make "exp" parameter const.
	* breakpoint.c (condition_completer): Make "text" and "word"
	parameters const.  Adjust.
	(check_tracepoint_command): Adjust to validate_actionline
	prototype change.
	(catch_syscall_completer): Make "text" and "word" parameters
	const.
	* cli/cli-cmds.c (show_user): Make "comname" local const.
	(valid_command_p): Make "command" parameter const.
	(alias_command): Make "alias_prefix" and "command_prefix" locals
	const.
	* cli/cli-decode.c (add_cmd): Make "name" parameter const.
	(add_alias_cmd): Make "name" and "oldname" parameters const.
	Adjust.  No longer make copy of OLDNAME.
	(add_prefix_cmd, add_abbrev_prefix_cmd, add_set_or_show_cmd)
	(add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_string_noescape_cmd)
	(add_setshow_optional_filename_cmd, add_setshow_integer_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd)
	(add_setshow_zuinteger_unlimited_cmd, add_setshow_zuinteger_cmd)
	(delete_cmd, add_info, add_info_alias, add_com, add_com_alias):
	Make "name" parameter const.
	(help_cmd): Rename "command" parameter to "arg".  New const local
	"command".
	(find_cmd): Make "command" parameter const.
	(lookup_cmd_1): Make "text" parameter pointer to const.  Adjust to
	deprecated_cmd_warning prototype change.
	(undef_cmd_error): Make "cmdtype" parameter const.
	(lookup_cmd): Make "line" parameter const.
	(deprecated_cmd_warning): Change type of "text" parameter to
	pointer to const char, from pointer to pointer to char.  Adjust.
	(lookup_cmd_composition): Make "text" parameter const.
	(complete_on_cmdlist, complete_on_enum): Make "text" and "word"
	parameters const.
	* cli/cli-decode.h (struct cmd_list_element) <name>: Make field
	const.
	* cli/cli-script.c (validate_comname): Make "tem" local const.
	(define_command): New const local "tem_c".  Use it in calls to
	lookup_cmd.
	(document_command): Make "tem" and "comfull" locals const.
	(show_user_1): Make "prefix" and "name" parameters const.
	* cli-script.h (show_user_1): Make "prefix" and "name" parameters
	const.
	* command.h (add_cmd, add_alias_cmd, add_prefix_cmd)
	(add_abbrev_prefix_cmd, completer_ftype, lookup_cmd, lookup_cmd_1)
	(deprecated_cmd_warning, lookup_cmd_composition, add_com)
	(add_com_alias, add_info, add_info_alias, complete_on_cmdlist)
	(complete_on_enum, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_string_noescape_cmd)
	(add_setshow_optional_filename_cmd, add_setshow_integer_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd)
	(add_setshow_zuinteger_cmd, add_setshow_zuinteger_unlimited_cmd):
	Change prototypes, constifying strings.
	* completer.c (noop_completer, filename_completer): Make "text"
	and "prefix" parameters const.
	(location_completer, expression_completer)
	(complete_line_internal): Make "text" and "prefix" parameters
	const and adjust.
	(command_completer, signal_completer): Make "text" and "prefix"
	parameters const.
	* completer.h (noop_completer, filename_completer)
	(expression_completer, location_completer, command_completer)
	(signal_completer): Change prototypes.
	* corefile.c (complete_set_gnutarget): Make "text" and "word"
	parameters const.
	* cp-abi.c (cp_abi_completer): Likewise.
	* expression.h (parse_expression_for_completion): Change
	prototype.
	* f-lang.c (f_make_symbol_completion_list): Make "text" and "word"
	parameters const.
	* infcmd.c (_initialize_infcmd): Make "cmd_name" local const.
	* infrun.c (handle_completer): Make "text" and "word" parameters
	const.
	* interps.c (interpreter_completer): Make "text" and "word"
	parameters const.
	* language.h (struct language_defn)
	<la_make_symbol_completion_list>: Make "text" and "word"
	parameters const.
	* parse.c (parse_exp_1): Move const hack to parse_exp_in_context.
	(parse_exp_in_context): Rename to ...
	(parse_exp_in_context_1): ... this.
	(parse_exp_in_context): Reimplement, with const hack from
	parse_exp_1.
	(parse_expression_for_completion): Make "string" parameter const.
	* printcmd.c (decode_format): Make "string_ptr" parameter pointer
	to pointer to const char.  Adjust.
	(print_command_1): Make "exp" parameter const.
	(output_command): Rename to ...
	(output_command_const): ... this.  Make "exp" parameter const.
	(output_command): Reimplement.
	(x_command): Adjust.
	(display_command): Rename "exp" parameter to "arg".  New "exp"
	local, const version of "arg".
	* python/py-auto-load.c (gdbpy_initialize_auto_load): Make
	"cmd_name" local const.
	* python/py-cmd.c (cmdpy_destroyer): Cast const away in xfree
	call.
	(cmdpy_completer): Make "text" and "word" parameters const.
	(gdbpy_parse_command_name): Make "prefix_text2" local const.
	* python/py-param.c (add_setshow_generic): Make "tmp_name" local
	const.
	* remote.c (_initialize_remote): Make "cmd_name" local const.
	* symtab.c (language_search_unquoted_string): Make "text" and "p"
	parameters const.  Adjust.
	(completion_list_add_fields): Make "sym_text", "text" and "word"
	parameters const.
	(struct add_name_data) <sym_text, text, word>: Make fields const.
	(default_make_symbol_completion_list_break_on): Make "text" and
	"word" parameters const.  Adjust locals.
	(default_make_symbol_completion_list)
	(make_symbol_completion_list, make_symbol_completion_type)
	(make_symbol_completion_list_fn): Make "text" and "word"
	parameters const.
	(make_file_symbol_completion_list): Make "text", "word" and
	"srcfile" parameters const.  Adjust locals.
	(add_filename_to_list): Make "text" and "word" parameters const.
	(struct add_partial_filename_data) <text, word>: Make fields
	const.
	(make_source_files_completion_list): Make "text" and "word"
	parameters const.
	* symtab.h (default_make_symbol_completion_list_break_on)
	(default_make_symbol_completion_list, make_symbol_completion_list)
	(make_symbol_completion_type enum type_code)
	(make_symbol_completion_list_fn make_file_symbol_completion_list)
	(make_source_files_completion_list): Change prototype.
	* top.c (execute_command): Adjust to pass pointer to pointer to
	const char to lookup_cmd, and to deprecated_cmd_warning prototype
	change.
	(set_verbose): Make "cmdname" local const.
	* tracepoint.c (decode_agent_options): Make "exp" parameter const,
	and adjust.
	(validate_actionline): Make "line" parameter a pointer to const
	char, and adjust.
	(encode_actions_1): Make "action_exp" local const, and adjust.
	(encode_actions): Adjust.
	(replace_comma): Delete.
	(trace_dump_actions): Make "action_exp" and "next_comma" locals
	const, and adjust.  Don't frob the action string while splitting
	it at commas.  Instead, make a copy of each split substring in
	turn.
	(trace_dump_command): Adjust to validate_actionline prototype
	change.
	* tracepoint.h (decode_agent_options, decode_agent_options)
	(encode_actions, validate_actionline): Change prototypes.
	* valprint.h (output_command): Delete declaration.
	(output_command_const): Declare.
	* value.c (function_destroyer): Cast const away in xfree call.
@
text
@d215 1
d228 1
d244 1
@


1.349
log
@	* breakpoint.c (catch_syscall_split_args): Use skip_spaces.
	(trace_pass_command): Likewise.
	* cli/cli-cmds.c: Include cli/cli-utils.h.
	(source_command): Use skip-spaces.
	(disassemble_command): Likewise.
	* findcmd.c: Include cli/cli-utils.h.
	(parse_find_args): Use skip_spaces.
	* go32-nat.c: Include cli/cli-utils.h.
	(go32_sldt): Use skip_spaces.
	(go32_sgdt): Likewise.
	(go32_sidt): Likewise.
	(go32_pde): Likewise.
	(go32_pte): Likewise.
	(go32_pte_for_address): Likewise.
	* infcmd.c: Include cli/cli-utils.h.
	(registers_info): Use skip_spaces.
	* linux-tdep.c (read_mapping): Use skip_spaces_const.
	(linux_info_proc): Likewise.
	* linux-thread-db.c: Include cli/cli-utils.h.
	(info_auto_load_libthread_db): Use skip_spaces_const.
	* m32r-rom.c: Include cli/cli-utils.h.
	(m32r_upload_command): Use skip_spaces.
	* maint.c: Include cli/cli-utils.h.
	(maintenance_translate_address): Use skip_spaces.
	* mi/mi-parse.c: Include cli/cli-utils.h.
	(mi_parse_argv): Use skip_spaces.
	(mi_parse): Likewise.
	* minsyms.c: Include cli/cli-utils.h.
	(msymbol_hash_iw): Use skip_spaces_const.
	* objc-lang.c: Include cli/cli-utils.h.
	(parse_selector): Use skip_spaces.
	(parse_method): Likewise.
	* python/python.c: Include cli/cli-utils.h.
	(python_interactive_command)[HAVE_PYTHON]: Use skip_spaces.
	(python_command)[HAVE_PYTHON]: Likewise.
	(python_interactive_command)[!HAVE_PYTHON]: Likewise.
	* remote-m32r-sdi.c: Include cli/cli-utils.h.
	(m32r_load): Use skip_spaces.
	* serial.c: Include cli/cli-utils.h.
	(serial_open): Use skip_spaces_const.
	* stack.c: Include cli/cli-utils.h.
	(parse_frame_specification_1): Use skip_spaces_const.
	* symfile.c: Include cli/cli-utils.h.
	(set_ext_lang_command): Use skip_spaces.
	* symtab.c: Include cli/cli-utils.h.
	(rbreak_command): Use skip_spaces.
	* thread.c (thread_name_command): Use skip_spaces.
	* tracepoint.c (validate_actionline): Use skip_spaces.
	(encode_actions_1): Likewise.
	(trace_find_range_command): Likewise.
	(trace_find_outside_command): Likewise.
	(trace_dump_actions): Likewise.
@
text
@d4111 2
a4112 2
static char *
language_search_unquoted_string (char *text, char *p)
d4128 1
a4128 1
		  char *t = p;
d4155 3
a4157 2
completion_list_add_fields (struct symbol *sym, char *sym_text,
			    int sym_text_len, char *text, char *word)
d4178 1
a4178 1
  char *sym_text;
d4180 2
a4181 2
  char *text;
  char *word;
d4210 2
a4211 1
default_make_symbol_completion_list_break_on (char *text, char *word,
d4227 1
a4227 1
  char *sym_text;
d4235 1
a4235 1
    char *p;
d4237 1
a4237 1
    char *quote_pos = NULL;
d4442 1
a4442 1
default_make_symbol_completion_list (char *text, char *word,
d4453 1
a4453 1
make_symbol_completion_list (char *text, char *word)
d4463 2
a4464 1
make_symbol_completion_type (char *text, char *word, enum type_code code)
d4478 1
a4478 1
				char *text, char *word)
d4487 2
a4488 1
make_file_symbol_completion_list (char *text, char *word, char *srcfile)
d4495 1
a4495 1
  char *sym_text;
d4502 1
a4502 1
    char *p;
d4504 1
a4504 1
    char *quote_pos = NULL;
d4586 1
a4586 1
add_filename_to_list (const char *fname, char *text, char *word,
d4637 2
a4638 2
  char *text;
  char *word;
d4677 1
a4677 1
make_source_files_completion_list (char *text, char *word)
@


1.348
log
@	* ada-lang.c (ada_lookup_symbol_list_worker): New function, contents
	of old ada_lookup_symbol_list.  In !full_search case, don't
	search superblocks.
	(ada_lookup_symbol_list): Delete arg full_search, all callers
	updated.  Call ada_lookup_symbol_list_worker.
	(ada_iterate_over_symbols): Call ada_lookup_symbol_list_worker.
	* ada-lang.h (ada_lookup_symbol_list): Update.
	* language.h (language_defn): Update comment for
	la_iterate_over_symbols.
	* linespec.c (iterate_over_file_blocks): New function.
	(iterate_over_all_matching_symtabs): Call it.
	(lookup_prefix_sym): Ditto.
	(get_current_search_block): New function.
	(get_search_block): Delete.
	(find_label_symbols): Call get_current_search_block.
	(add_matching_symbols_to_info): Call iterate_over_file_blocks.
	* symtab.c (iterate_over_symbols): Don't search superblocks.
@
text
@d43 1
d3883 1
a3883 2
	  regexp = colon + 1;
	  while (isspace (*regexp))  regexp++; 
@


1.347
log
@gdb/
	* dwarf2read.c (dw2_expand_symtabs_matching): Add basenames parameter
	to the file_matcher parameter.  Pass 0 to it.
	(dwarf2_create_include_psymtab): Copy also DIRNAME.
	* psymtab.c (partial_map_symtabs_matching_filename): Drop handling of
	NULL psymtab_to_fullname result.
	(psymtab_to_fullname): Remove variable r.  Never return NULL, assemble
	an expected filename instead.
	(expand_symtabs_matching_via_partial): Add basenames parameter to the
	file_matcher parameter.  Call also psymtab_to_fullname, after newly
	considering BASENAMES_MAY_DIFFER.
	* source.c (rewrite_source_path): Remove static.
	* source.h (rewrite_source_path): New declaration.
	* symfile.h (struct quick_symbol_functions): Add basenames parameter to
	the expand_symtabs_matching field.  Comment it.
	* symtab.c (file_matches): New function comment.  Add parameter
	basenames, implement it.
	(search_symbols_file_matches): Add basenames parameter.  Update the
	file_matches caller.
	(search_symbols): Match FILES also against symtab_to_fullname.
	Optimize it for BASENAMES_MAY_DIFFER.

gdb/testsuite/
	* gdb.base/fullpath-expand-func.c: New file.
	* gdb.base/fullpath-expand.c: New file.
	* gdb.base/fullpath-expand.exp: New file.
	* gdb.base/realname-expand-real.c: New file.
	* gdb.base/realname-expand.c: New file.
	* gdb.base/realname-expand.exp: New file.
@
text
@d2026 1
a2026 2
/* Iterate over the symbols named NAME, matching DOMAIN, starting with
   BLOCK.
d2032 1
a2032 3
   search continues.  This function iterates upward through blocks.
   When the outermost block has been finished, the function
   returns.  */
d2040 6
a2045 1
  while (block)
d2047 2
a2048 6
      struct block_iterator iter;
      struct symbol *sym;

      for (sym = block_iter_name_first (block, name, &iter);
	   sym != NULL;
	   sym = block_iter_name_next (name, &iter))
d2050 2
a2051 6
	  if (symbol_matches_domain (SYMBOL_LANGUAGE (sym),
				     SYMBOL_DOMAIN (sym), domain))
	    {
	      if (!callback (sym, data))
		return;
	    }
a2052 2

      block = BLOCK_SUPERBLOCK (block);
@


1.346
log
@gdb/
	* ada-lang.c (user_select_syms): Replace symtab->filename refererences
	by symtab_to_filename_for_display calls.
	* breakpoint.c (print_breakpoint_location, resolve_sal_pc): Likewise.
	(clear_command): New variable sal_fullname, initialize it.  Replace
	compare_filenames_for_search by filename_cmp with sal_fullname.
	(say_where, update_static_tracepoint): Replace symtab->filename
	refererences by symtab_to_filename_for_display calls.
	* cli/cli-cmds.c (edit_command, list_command, ambiguous_line_spec):
	Likewise.
	* dwarf2read.c: Include source.h.
	(fixup_go_packaging): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* linespec.c (add_sal_to_sals): Rename variable filename to fullname.
	Replace symtab->filename refererences by symtab_to_filename_for_display
	calls.
	(create_sals_line_offset, convert_linespec_to_sals): New variable
	fullname, initialize it, replace symtab->filename reference by the
	variable.
	* linux-fork.c: Include source.h.
	(info_checkpoints_command): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* macroscope.c (sal_macro_scope): Replace symtab->filename refererences
	by symtab_to_filename_for_display calls.
	* mdebugread.c: Include source.h.
	(psymtab_to_symtab_1): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* mi/mi-cmd-file.c (mi_cmd_file_list_exec_source_file)
	(mi_cmd_file_list_exec_source_files): Likewise.
	* printcmd.c: Include source.h.
	(build_address_symbolic): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* psymtab.c (partial_map_symtabs_matching_filename)
	(read_psymtabs_with_fullname): Call compare_filenames_for_search also
	with psymtab_to_fullname.
	* python/py-symtab.c (stpy_str): Replace symtab->filename refererences
	by symtab_to_filename_for_display calls.
	(stpy_get_filename): New variable filename, initialize it, use instead
	of symtab->filename refererences.
	(salpy_str): Make variable filename const char *.  Replace
	symtab->filename refererences by symtab_to_filename_for_display calls.
	* skip.c: Include source.h and filenames.h.
	(skip_file_command): Remove const from the symtab variable.  Replace
	symtab->filename refererences by symtab_to_fullname call.
	(function_name_is_marked_for_skip): New variables searched_for_fullname
	and fullname.  Use them to search also with symtab's fullname.
	* source.c (find_source_lines): Replace symtab->filename refererences
	by symtab_to_filename_for_display calls.
	(print_source_lines_base): New variable filename, use it instead of
	symtab->filename.  Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	(line_info, forward_search_command): Replace symtab->filename
	refererences by symtab_to_filename_for_display calls.
	(reverse_search_command): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.  New variable filename for it.
	* stack.c (frame_info): Likewise.
	* symmisc.c: Include source.h.
	(dump_objfile, dump_symtab_1, maintenance_print_symbols)
	(maintenance_info_symtabs): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* symtab.c (iterate_over_some_symtabs): Call
	compare_filenames_for_search also with symtab_to_fullname.
	(lookup_symbol_aux_quick, basic_lookup_transparent_type_quick): Replace
	symtab->filename refererences by symtab_to_filename_for_display calls.
	(find_line_symtab): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	(file_matches): Replace filename_cmp by compare_filenames_for_search.
	(print_symbol_info): Make the last parameter const char *.  New
	variable s_filename.  Use it in the function.
	(symtab_symbol_info): Make the last_filename variable const char *.
	Replace symtab->filename refererences by symtab_to_filename_for_display
	calls.
	(rbreak_command): New variable fullname.  Use it.  Replace
	symtab->filename refererence by symtab_to_filename_for_display call.
	* tracepoint.c (set_traceframe_context, trace_find_line_command)
	(print_one_static_tracepoint_marker): Replace symtab->filename
	refererences by symtab_to_filename_for_display calls.
	* tui/tui-source.c (tui_set_source_content): New variables filename and
	s_filename.  Replace symtab->filename refererences by this variable.
	Replace other symtab->filename refererences by
	symtab_to_filename_for_display calls.
@
text
@d3268 3
d3272 1
a3272 1
file_matches (const char *file, char *files[], int nfiles)
d3280 3
a3282 1
	  if (compare_filenames_for_search (file, files[i]))
d3382 2
a3383 1
search_symbols_file_matches (const char *filename, void *user_data)
d3387 1
a3387 1
  return file_matches (filename, data->files, data->nfiles);
d3596 8
a3603 1
	    if (file_matches (real_symtab->filename, files, nfiles)
@


1.345
log
@gdb/
	Code cleanup.
	* dwarf2read.c (dw2_expand_symtabs_with_filename): Rename to ...
	(dw2_expand_symtabs_with_fullname): ... here.  Rename parameter
	filename to fullname.  Rename variable this_name to this_fullname.
	Lowercase FILENAME_CMP call.
	(dw2_find_symbol_file): New comment for the returned string.
	(dwarf2_gdb_index_functions): Rename the function to
	dw2_expand_symtabs_with_fullname.
	* psymtab.c (read_psymtabs_with_filename): Rename to ...
	(read_psymtabs_with_fullname): ... here.  Rename parameter filename to
	fullname.
	(psym_functions): Rename the function to read_psymtabs_with_fullname.
	* symfile.h (struct quick_symbol_functions): Rename field
	expand_symtabs_with_filename to expand_symtabs_with_fullname and its
	parameter filename to fullname.  Document returned string meaning for
	find_symbol_file.
	* symtab.c (find_line_symtab): Rename the called function to
	expand_symtabs_with_fullname.
@
text
@d222 6
d1659 1
a1659 1
	       name, symtab->filename, name, name);
d1864 1
a1864 1
	       name, symtab->filename, name, name);
d2511 1
a2511 1
							 symtab->filename);
d3277 1
a3277 1
	  if (filename_cmp (files[i], lbasename (file)) == 0)
d3708 1
a3708 1
		   int block, char *last)
d3710 3
a3712 1
  if (last == NULL || filename_cmp (last, s->filename) != 0)
d3715 1
a3715 1
      fputs_filtered (s->filename, gdb_stdout);
d3773 1
a3773 1
  char *last_filename = NULL;
d3808 1
a3808 1
	  last_filename = p->symtab->filename;
d3892 3
a3894 1
	  int newlen = (strlen (p->symtab->filename)
d3903 1
a3903 1
	  strcpy (string, p->symtab->filename);
d3912 1
a3912 1
			     p->symtab->filename);
@


1.344
log
@gdb/
	Code cleanup.
	* breakpoint.c (clear_command): Remove variable is_abs, unify the
	call of filename_cmp with compare_filenames_for_search.
	* dwarf2read.c (dw2_map_symtabs_matching_filename): Remove variable
	is_abs, unify the call of FILENAME_CMP with
	compare_filenames_for_search.  New gdb_asserts for real_path and name.
	Unify the call of compare_filenames_for_search with FILENAME_CMP.
	* psymtab.c (partial_map_symtabs_matching_filename): Likewise.
	* symfile.h (struct quick_symbol_functions): Extend the comment for
	map_symtabs_matching_filename.
	* symtab.c (compare_filenames_for_search): Remove the function comment
	relative path requirement.  Handle absolute filenames, with a comment.
	(iterate_over_some_symtabs): Remove variable is_abs, unify the call of
	FILENAME_CMP with compare_filenames_for_search.  New gdb_asserts for
	real_path and name.  Unify the call of compare_filenames_for_search
	with FILENAME_CMP.
	(iterate_over_symtabs): New gdb_assert on REAL_PATH.

gdb/testsuite/
	* gdb.mi/mi-fullname-deleted.exp: Use double last slash for $srcfileabs.
	(compare_filenames_for_search does not match)
	(compare_filenames_for_search does match): New tests.
@
text
@d2504 1
a2504 1
	  objfile->sf->qf->expand_symtabs_with_filename (objfile,
@


1.343
log
@gdb/
	Replace xfullpath calls by gdb_realpath calls.
	* cli/cli-cmds.c (find_and_open_script): Remove xfullpath from the
	function comment.
	* dwarf2read.c (dw2_map_expand_apply): Remove parameter full_path.
	Remove it from the iterate_over_some_symtabs call.
	(dw2_map_symtabs_matching_filename): Remove parameter full_path.
	Remove it from the dw2_map_expand_apply calls, remove a block handling
	it.
	* psymtab.c (partial_map_expand_apply): Remove parameter full_path.
	Remove it from the iterate_over_some_symtabs call.
	(partial_map_symtabs_matching_filename): Remove parameter full_path.
	Remove it from the partial_map_expand_apply calls, remove a block
	handling it.  Drop gdb_realpath call and cleanups from the real_path
	handling.
	* source.c (openp): Drop the comment part about xfullpath.  Replace
	xfullpath calls by gdb_realpath calls.
	(find_and_open_source): Replace xfullpath call by gdb_realpath call.
	* symfile.h (struct quick_symbol_functions): Remove parameter full_path
	from method map_symtabs_matching_filename and its comment.
	* symmisc.c (maintenance_print_msymbols): Replace xfullpath call by
	gdb_realpath call.
	* symtab.c (iterate_over_some_symtabs): Remove parameter full_path,
	remove it also from the function comment, remove a block handling it.
	Drop gdb_realpath call and cleanups from the real_path handling.
	(iterate_over_symtabs): Drop variable full_path and its use.
	* symtab.h (iterate_over_some_symtabs): Remove parameter full_path.
	* utils.c (xfullpath): Remove.
	* utils.h (xfullpath): Remove.

gdb/testsuite/
	* gdb.gdb/xfullpath.exp: Replace xfullpath calls by gdb_realpath calls.
@
text
@d149 2
a150 2
   describes what we advertise).  We assume that SEARCH_NAME is
   a relative path.  Returns true if they match, false otherwise.  */
d169 5
d179 2
a180 1
	  || IS_DIR_SEPARATOR (filename[len - search_len - 1])
a206 1
  int is_abs = IS_ABSOLUTE_PATH (name);
d210 1
a210 8
      /* Exact match is always ok.  */
      if (FILENAME_CMP (name, s->filename) == 0)
	{
	  if (callback (s, data))
	    return 1;
	}

      if (!is_abs && compare_filenames_for_search (s->filename, name))
d229 2
a235 6

	if (!is_abs && compare_filenames_for_search (fullname, name))
	  {
	    if (callback (s, data))
	      return 1;
	  }
d265 1
@


1.342
log
@2013-01-31  Aleksandar Ristovski  <aristovski@@qnx.com>

        * dwarf2-frame.c (dwarf2_compile_cfa_to_ax): Remove unused num_regs.
        * symtab.c (iterate_over_symtabs): Remove unused s.
        (find_pc_sect_symtab): Remove unused pspAce.
        (find_pc_sect_line): Remove unused alt_symtab.
        (find_pcs_for_symtab_line): Remove unused ix, previous_function.
        (completion_list_add_name): Remove unused newsize.

Reference: http://sourceware.org/ml/gdb-patches/2013-01/msg00764.html
@
text
@d182 1
a182 1
   The return value, NAME, FULL_PATH, REAL_PATH, CALLBACK, and DATA
a191 1
			   const char *full_path,
a226 17
    if (full_path != NULL)
      {
        const char *fp = symtab_to_fullname (s);

        if (FILENAME_CMP (full_path, fp) == 0)
          {
	    if (callback (s, data))
	      return 1;
          }

	if (!is_abs && compare_filenames_for_search (fp, name))
	  {
	    if (callback (s, data))
	      return 1;
	  }
      }

a229 2
	char *rp = gdb_realpath (fullname);
	struct cleanup *cleanups = make_cleanup (xfree, rp);
d231 1
a231 1
	if (FILENAME_CMP (real_path, rp) == 0)
d234 1
a234 4
	      {
		do_cleanups (cleanups);
		return 1;
	      }
d237 1
a237 1
	if (!is_abs && compare_filenames_for_search (rp, name))
d240 1
a240 4
	      {
		do_cleanups (cleanups);
		return 1;
	      }
a241 1
	do_cleanups (cleanups);
a262 1
  char *full_path = NULL;
a268 2
      full_path = xfullpath (name);
      make_cleanup (xfree, full_path);
d275 1
a275 1
    if (iterate_over_some_symtabs (name, full_path, real_path, callback, data,
a290 1
							   full_path,
@


1.341
log
@gdb/
    * symtab.c (skip_prologue_using_sal): Consider a file
    change the same as an increased line number

gdb/testsuite/
    * gdb.base/prologue-include.c: New file.
    * gdb.base/prologue-include.exp: New file.
    * gdb.base/prologue-include.h: New file.
@
text
@a287 1
  struct symtab *s = NULL;
a2104 1
  struct program_space *pspace;
a2107 2
  pspace = current_program_space;

a2259 1
  struct symtab *alt_symtab = 0;
d2404 1
a2404 4
	{
	  alt = item;
	  alt_symtab = s;
	}
d2595 1
a2595 2
  int start = 0, ix;
  struct symbol *previous_function = NULL;
a4034 2
  int newsize;

@


1.340
log
@	* symtab.c (struct demangled_name_entry) <mangled>: Now const.
	(symbol_set_names): Remove casts.  Handle field const-ness.
@
text
@d4908 4
@


1.339
log
@	* dwarf2read.c (new_symbol_full): Remove cast.
	* symtab.c (symbol_set_demangled_name): Make 'name' const.
	* symtab.h (symbol_set_demangled_name): Update.
@
text
@d529 1
a529 1
  char *mangled;
d761 1
a761 1
  entry.mangled = (char *) lookup_name;
d792 1
a792 1
	  (*slot)->mangled = (char *) lookup_name;
d796 2
d805 3
a807 2
	  (*slot)->mangled = &((*slot)->demangled[demangled_len + 1]);
	  strcpy ((*slot)->mangled, lookup_name);
@


1.338
log
@gdb/
	* symtab.c (compare_filenames_for_search): New comment for
	HAS_DRIVE_SPEC.

gdb/testsuite/
	* gdb.dwarf2/dw2-dos-drive.S: New file.
	* gdb.dwarf2/dw2-dos-drive.exp: New file.
@
text
@d468 1
a468 1
                           char *name,
@


1.337
log
@gdb/
	* symtab.c (iterate_over_some_symtabs): New variable cleanups,
	initialize it by existing make_cleanup.  Call new do_cleanups.
@
text
@d167 6
a172 1
     directory separator.  */
@


1.336
log
@	* symfile.h (quick_symbol_functions): Delete member
	pre_expand_symtabs_matching.  All uses removed.
	* dwarf2read.c (dw2_lookup_symbol): Implement.
	(dw2_do_expand_symtabs_matching): Delete.
	(dw2_pre_expand_symtabs_matching): Delete.
	(struct dw2_symtab_iterator): New type.
	(dw2_symtab_iter_init, dw2_symtab_iter_next): New functions.
	(dw2_expand_symtabs_for_function): Rewrite.
	(dwarf2_gdb_index_functions): Update.
	* psymtab.c (pre_expand_symtabs_matching_psymtabs): Delete.
	(psym_functions): Update.
@
text
@d244 1
a245 1
	make_cleanup (xfree, rp);
d249 4
a252 1
	      return 1;
d258 4
a261 1
	      return 1;
d263 1
@


1.335
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@a1553 4
  if (objfile->sf)
    objfile->sf->qf->pre_expand_symtabs_matching (objfile, block_index,
						  name, domain);

a1910 5
    if (objfile->sf)
      objfile->sf->qf->pre_expand_symtabs_matching (objfile,
						    GLOBAL_BLOCK,
						    name, STRUCT_DOMAIN);

a1938 4
    if (objfile->sf)
      objfile->sf->qf->pre_expand_symtabs_matching (objfile, STATIC_BLOCK,
						    name, STRUCT_DOMAIN);

@


1.334
log
@gdb/
	* symtab.c (find_line_symtab): Call symtab_to_fullname instead of
	accessing FULLNAME directly.
@
text
@d3 1
a3 1
   Copyright (C) 1986-2004, 2007-2012 Free Software Foundation, Inc.
@


1.333
log
@gdb/
	* ada-lang.c (is_known_support_routine): New variable fullname.  Use
	access call to verify the symtab_to_fullname result.
	* breakpoint.c (print_breakpoint_location, update_static_tracepoint):
	Remove NULL check of symtab_to_fullname result.
	* cli/cli-cmds.c (edit_command): Likewise.
	* mi/mi-cmd-file.c (mi_cmd_file_list_exec_source_file)
	(mi_cmd_file_list_exec_source_files): Likewise.
	* python/py-symtab.c (stpy_fullname): Likewise.
	* source.c (symtab_to_fullname): Update function comment.  Rename
	variable r to fd, move it to inner block.  Always provide non-NULL
	result.
	(print_source_lines_base): Remove NULL check of symtab_to_fullname
	result.
	* stack.c (print_frame): Likewise.
	* symtab.c (iterate_over_some_symtabs, find_line_symtab, sources_info):
	Likewise.
	* tracepoint.c (print_one_static_tracepoint_marker): Likewise.

gdb/doc/
	* gdb.texinfo (GDB/MI Data Manipulation) (fullname): Make it always
	present.
	(GDB/MI File Commands) (-file-list-exec-source-files): Make the
	fullname output always present.

gdb/testsuite/
	* gdb.mi/mi-fullname-deleted.exp: New file.
@
text
@d2557 2
a2558 1
	if (FILENAME_CMP (symtab->fullname, symtab_to_fullname (s)) != 0)
@


1.332
log
@	* Makefile.in (init.c): Declare initialize_all_files;
	don't include call-cmds.h.
	* call-cmds.h: Remove.
	* symtab.c: Don't include call-cmds.h.
	* top.c: Don't include call-cmds.h.  Declare
	initialize_all_files.
@
text
@d227 1
a227 1
        if (fp != NULL && FILENAME_CMP (full_path, fp) == 0)
d233 1
a233 1
	if (fp != NULL && !is_abs && compare_filenames_for_search (fp, name))
d243 1
d245 6
a250 3
        if (fullname != NULL)
          {
            char *rp = gdb_realpath (fullname);
d252 5
a256 13
            make_cleanup (xfree, rp);
            if (FILENAME_CMP (real_path, rp) == 0)
	      {
		if (callback (s, data))
		  return 1;
	      }

	    if (!is_abs && compare_filenames_for_search (rp, name))
	      {
		if (callback (s, data))
		  return 1;
	      }
          }
a2549 3
      /* Get symbol full file name if possible.  */
      symtab_to_fullname (symtab);

d2557 1
a2557 3
	if (symtab->fullname != NULL
	    && symtab_to_fullname (s) != NULL
	    && FILENAME_CMP (symtab->fullname, s->fullname) != 0)
d3288 1
a3288 1
    output_source_filename (fullname ? fullname : s->filename, &data);
@


1.331
log
@gdb/
	Code cleanup.
	* breakpoint.c (clear_command): Remove variable sal_name_len and its
	initialization, remove it from the compare_filenames_for_search call.
	* dwarf2read.c (dw2_map_symtabs_matching_filename): Remove variable
	name_len and its initialization, remove it from the
	compare_filenames_for_search calls.
	* psymtab.c (partial_map_symtabs_matching_filename): Likewise.
	* symtab.c (compare_filenames_for_search): Remove the search_len
	parameter, update the function comment, new variable search_len
	initialized from SEARCH_NAME.
	(iterate_over_some_symtabs): Remove variable name_len and its
	initialization, remove it from the compare_filenames_for_search calls.
	* symtab.h (compare_filenames_for_search): Remove the search_len
	parameter,
@
text
@a29 1
#include "call-cmds.h"
@


1.330
log
@	PR c++/8888:
	* symtab.c (lookup_symbol_aux): If constructor is found, consider
	returning the type instead.
	* c-exp.y (classify_name): Check STRUCT_DOMAIN if a constructor is
	found.
testsuite
	* gdb.cp/member-name.exp: New file.
	* gdb.cp/member-name.cc: New file.
@
text
@d150 2
a151 3
   describes what we advertise).  SEARCH_LEN is the length of
   SEARCH_NAME.  We assume that SEARCH_NAME is a relative path.
   Returns true if they match, false otherwise.  */
d154 1
a154 2
compare_filenames_for_search (const char *filename, const char *search_name,
			      int search_len)
d157 1
a197 1
  int name_len = strlen (name);
d209 1
a209 1
      if (!is_abs && compare_filenames_for_search (s->filename, name, name_len))
d234 1
a234 2
	if (fp != NULL && !is_abs && compare_filenames_for_search (fp, name,
								   name_len))
d256 1
a256 1
	    if (!is_abs && compare_filenames_for_search (rp, name, name_len))
@


1.329
log
@	* c-exp.y (block, variable, name_not_typename, lex_one_token,
	classify_name): Update.
	* c-valprint.c (c_val_print): Update.
	* f-exp.y (yylex): Update.
	* go-exp.y (package_name_p, classify_packaged_name)
	(classify_name): Update.
	* jv-exp.y (push_variable): Update.
	* m2-exp.y (variable): Update.
	* mi/mi-cmd-stack.c (list_args_or_locals): Update.
	* p-exp.y (block, variable, yylex): Update.
	* p-valprint.c (pascal_val_print): Update.
	* parse.c (write_dollar_variable): Update.
	* printcmd.c (address_info): Update.
	* python/py-symbol.c (gdbpy_lookup_symbol): Update.
	* symtab.c (lookup_symbol_aux, lookup_symbol_in_language)
	(lookup_symbol): Change type of 'is_a_field_of_this'.
	(check_field): Add 'is_a_field_of_this' argument.
	* symtab.h (struct field_of_this_result): New.
	(lookup_symbol, lookup_symbol_in_language): Update.
@
text
@d1357 4
a1360 1
  if (is_a_field_of_this != NULL)
@


1.328
log
@	* symtab.c (check_field): Now static.  Move from...
	* valops.c (check_field): ... here.  Remove.
	* value.h (check_field): Don't declare.
@
text
@d85 1
a85 1
					 int *is_a_field_of_this);
d1228 1
a1228 1
			   int *is_a_field_of_this)
d1246 2
a1247 1
	       domain_enum domain, int *is_a_field_of_this)
d1287 2
a1288 1
check_field (struct type *type, const char *name)
d1300 5
a1304 1
	return 1;
d1313 5
a1317 1
	return 1;
d1321 1
a1321 1
    if (check_field (TYPE_BASECLASS (type, i), name))
d1333 1
a1333 1
		   int *is_a_field_of_this)
d1340 2
a1341 3
     certainly use it later and expect it to be either 0 or 1.
     If we don't set it, the contents of is_a_field_of_this are
     undefined.  */
d1343 1
a1343 1
    *is_a_field_of_this = 0;
d1377 2
a1378 5
	  if (check_field (t, name))
	    {
	      *is_a_field_of_this = 1;
	      return NULL;
	    }
@


1.327
log
@	* symtab.c (find_pc_sect_symtab): Add comment.
@
text
@d1281 36
@


1.326
log
@	* ada-lang.c (ada_make_symbol_completion_list): Add 'code'
	argument, assertion.
	* c-exp.y (typebase): Add completion productions.
	* completer.c (expression_completer): Handle tag completion.
	* expression.h (parse_expression_for_completion): Add argument.
	* f-lang.c (f_make_symbol_completion_list): Add 'code'
	argument.
	* language.h (struct language_defn)
	<la_make_symbol_completion_list>: Add 'code' argument.
	* parse.c (expout_tag_completion_type, expout_completion_name):
	New globals.
	(mark_struct_expression): Add assertion.
	(mark_completion_tag): New function.
	(parse_exp_in_context): Initialize new globals.
	(parse_expression_for_completion): Add 'code' argument.  Handle
	tag completion.
	* parser-defs.h (mark_completion_tag): Declare.
	* symtab.c (default_make_symbol_completion_list_break_on): Add
	'code' argument.  Update.
	(default_make_symbol_completion_list): Add 'code' argument.
	(make_symbol_completion_list): Update.
	(make_symbol_completion_type): New function.
	* symtab.h (default_make_symbol_completion_list_break_on)
	(default_make_symbol_completion_list): Update.
	(make_symbol_completion_type): Declare.
testsuite
	* gdb.base/break1.c (enum some_enum, union some_union): New.
	(some_enum_global, some_union_global, some_value): New globals.
	* gdb.base/completion.exp: Add tag completion tests.
@
text
@d2153 2
@


1.325
log
@	* ada-exp.y (write_object_renaming, write_var_or_type)
	(write_ambiguous_var, write_var_from_sym): Make blocks const.
	* ada-lang.c (replace_operator_with_call)
	(find_old_style_renaming_symbol): Make blocks const.
	* ada-lang.h (ada_find_renaming_symbol): Update.
	(struct ada_symbol_info) <block>: Now const.
	* breakpoint.c (watch_command_1): Update.
	* breakpoint.h (struct watchpoint) <exp_valid_block,
	cond_exp_valid_block>: Now const.
	* c-exp.y (classify_inner_name, classify_name): Make block
	argument const.
	* expprint.c (print_subexp_standard) <OP_VAR_VALUE>: Make 'b'
	const.
	* expression.h (innermost_block, parse_exp_1): Update.
	(union exp_element) <block>: Now const.
	* gdbtypes.c (lookup_template_type, lookup_enum, lookup_union)
	(lookup_struct): Make block argument const.
	* gdbtypes.h (lookup_template_type): Update.
	* go-exp.y (classify_name, classify_packaged_name)
	(package_name_p): Make block argument const.
	* objc-lang.c (lookup_struct_typedef): Make block argument const.
	* objc-lang.h (lookup_struct_typedef): Update.
	* parse.c (parse_exp_in_context, parse_exp_1)
	(write_exp_elt_block): Make block arguments const.
	(expression_context_block, innermost_block): Now const.
	* parser-defs.h (write_exp_elt_block): Update.
	(expression_context_block, innermost_block, block_found): Now
	const.
	* printcmd.c (struct display) <block>: Now const.
	* symtab.h (lookup_struct, lookup_union, lookup_enum): Update.
	* valops.c (address_of_variable): Make block argument const.
	* value.h (value_of_variable): Update.
	* varobj.c (struct varobj_root) <valid_block>: Now const.
@
text
@d4205 2
a4206 1
					      const char *break_on)
d4313 7
a4319 4
  ALL_MSYMBOLS (objfile, msymbol)
  {
    QUIT;
    COMPLETION_LIST_ADD_SYMBOL (msymbol, sym_text, sym_text_len, text, word);
d4321 4
a4324 2
    completion_list_objc_symbol (msymbol, sym_text, sym_text_len, text, word);
  }
d4341 11
a4351 4
	    COMPLETION_LIST_ADD_SYMBOL (sym, sym_text, sym_text_len, text,
					word);
	    completion_list_add_fields (sym, sym_text, sym_text_len, text,
					word);
d4364 10
a4373 7
  if (surrounding_static_block != NULL)
    ALL_BLOCK_SYMBOLS (surrounding_static_block, iter, sym)
      completion_list_add_fields (sym, sym_text, sym_text_len, text, word);

  if (surrounding_global_block != NULL)
      ALL_BLOCK_SYMBOLS (surrounding_global_block, iter, sym)
	completion_list_add_fields (sym, sym_text, sym_text_len, text, word);
d4384 4
a4387 1
	COMPLETION_LIST_ADD_SYMBOL (sym, sym_text, sym_text_len, text, word);
d4397 4
a4400 1
	COMPLETION_LIST_ADD_SYMBOL (sym, sym_text, sym_text_len, text, word);
d4404 4
a4407 1
  if (current_language->la_macro_expansion == macro_expansion_c)
d4435 2
a4436 1
default_make_symbol_completion_list (char *text, char *word)
d4438 1
a4438 1
  return default_make_symbol_completion_list_break_on (text, word, "");
d4448 15
a4462 1
  return current_language->la_make_symbol_completion_list (text, word);
@


1.324
log
@gdb/
2012-11-27  Yao Qi  <yao@@codesourcery.com>

	* symtab.c (symtab_symbol_info): Fix a -Wformat-extra-args
	warning.
	Add i18n markup.
@
text
@d65 1
@


1.323
log
@	ARI fixes: sprintf rule.
	Replace sprintf function calls for char arrays by
	calls to xsnprintf calls.
	* arm-tdep.c (arm_push_dummy_call): Replace sprintf by xsnprintf.
	(arm_dwarf_reg_to_regnum, arm_return_value): Ditto.
	(arm_neon_quad_read, arm_pseudo_read): Ditto.
	(arm_neon_quad_write, arm_pseudo_write): Ditto.
	* breakpoint.c (condition_completer): Ditto.
	(create_tracepoint_from_upload): Ditto.
	* dwarf2read.c (file_full_name): Ditto.
	* gcore.c (gcore_command): Ditto.
	* gnu-nat.c (proc_string, gnu_pid_to_str): Ditto.
	* go32-nat.c (go32_sysinfo): Ditto.
	* interps.c (interp_set): Ditto.
	* m32c-tdep.c (make_types): Ditto.
	* ppc-linux-nat.c (fetch_register, store_register): Ditto.
	* remote-m32r-sdi.c (m32r_open): Ditto.
	* sol-thread.c (td_err_string): Ditto.
	(td_state_string, solaris_pid_to_str): Ditto.
	* symtab.c (gdb_mangle_name): Ditto.
	* cli/cli-script.c (execute_control_command): Ditto.
	(define_command, document_command): Ditto.
	* tui/tui-io.c (tui_rl_display_match_list): Ditto.
	* tui/tui-stack.c (tui_make_status_line): Ditto.
	* tui/tui-win.c (tui_update_gdb_sizes): Ditto.
@
text
@d3781 5
a3785 4
  printf_filtered (regexp
		   ? "All %ss matching regular expression \"%s\":\n"
		   : "All defined %ss:\n",
		   classnames[kind], regexp);
d3795 1
a3795 1
	      printf_filtered ("\nNon-debugging symbols:\n");
@


1.322
log
@	* gdbarch.sh (target_gdbarch): Remove macro.
	(get_target_gdbarch): Rename to target_gdbarch.
	* gdbarch.c, gdbarch.h: Rebuild.
	* ada-tasks.c, aix-thread.c, amd64-linux-nat.c, arch-utils.c,
	arm-tdep.c, auxv.c, breakpoint.c, bsd-uthread.c, corefile.c,
	darwin-nat-info.c, dcache.c, dsrec.c, exec.c, fbsd-nat.c,
	filesystem.c, gcore.c, gnu-nat.c, i386-darwin-nat.c, i386-nat.c,
	ia64-vms-tdep.c, inf-ptrace.c, infcmd.c, jit.c, linux-nat.c,
	linux-tdep.c, linux-thread-db.c, m32r-rom.c, memattr.c,
	mep-tdep.c, microblaze-tdep.c, mips-linux-nat.c,
	mips-linux-tdep.c, mips-tdep.c, monitor.c, moxie-tdep.c,
	nto-procfs.c, nto-tdep.c, ppc-linux-nat.c, proc-service.c,
	procfs.c, progspace.c, ravenscar-thread.c, record.c,
	remote-m32r-sdi.c, remote-mips.c, remote-sim.c, remote.c,
	rl78-tdep.c, rs6000-nat.c, rx-tdep.c, s390-nat.c, sol-thread.c,
	solib-darwin.c, solib-dsbt.c, solib-frv.c, solib-ia64-hpux.c,
	solib-irix.c, solib-pa64.c, solib-som.c, solib-spu.c,
	solib-sunos.c, solib-svr4.c, solib.c, spu-linux-nat.c,
	spu-multiarch.c, spu-tdep.c, symfile-mem.c, symfile.c, symtab.c,
	target-descriptions.c, target.c, target.h, tracepoint.c,
	windows-nat.c, windows-tdep.c, xcoffsolib.c, cli/cli-dump.c,
	common/agent.c, mi/mi-interp.c, python/py-finishbreakpoint.c,
	python/py-inferior.c, python/python.c: Update.
@
text
@d405 1
a405 1
      sprintf (buf, "__%s%s", const_prefix, volatile_prefix);
d411 1
a411 1
      sprintf (buf, "__%s%s", const_prefix, volatile_prefix);
d417 2
a418 1
      sprintf (buf, "__%s%s%d", const_prefix, volatile_prefix, len);
@


1.321
log
@	* tracepoint.c (print_one_static_tracepoint_marker): Constify.
	* symtab.c (iterate_over_some_symtabs): Constify.
	* source.h (symtab_to_fullname): Return 'const char *'.
	* source.c (symtab_to_fullname): Return 'const char *'.
	* python/py-symtab.c (stpy_fullname): Constify.
	* cli/cli-cmds.c (edit_command): Constify.
	* breakpoint.c (print_breakpoint_location)
	(update_static_tracepoint): Constify.
@
text
@d1770 1
a1770 1
    (objfile != NULL ? get_objfile_arch (objfile) : target_gdbarch,
@


1.320
log
@Fix typo in skip_prologue_sal's comment.

gdb/ChangeLog:

        * symtab.c (skip_prologue_sal): Fix typo in comment.
@
text
@d245 1
a245 1
        char *fullname = symtab_to_fullname (s);
@


1.319
log
@	* symtab.c (filename_seen_cache): Delete members "tab_alloc_size",
	"tab_cur_size".  Change member "tab" to be a htab_t.
	(create_filename_seen_cache): Update.
	(clear_filename_seen_cache, delete_filename_seen_cache): Update.
	(filename_seen): Update.
@
text
@d2813 1
a2813 1
  /* Do not change the SAL is PC was specified explicitly.  */
@


1.318
log
@	* symtab.c (filename_seen): Update comment.
@
text
@d3111 2
a3112 4
  const char **tab;

  /* Allocated size of tab in elements.  */
  int tab_alloc_size;
a3113 3

  /* Current size of tab in elements.  */
  int tab_cur_size;
d3124 3
a3126 3
  cache->tab_alloc_size = INITIAL_FILENAME_SEEN_CACHE_SIZE;
  cache->tab = XNEWVEC (const char *, cache->tab_alloc_size);
  cache->tab_cur_size = 0;
d3134 1
a3134 1
clear_filename_seen_cache (struct filename_seen_cache * cache)
d3136 1
a3136 1
  cache->tab_cur_size = 0;
d3147 1
a3147 1
  xfree (cache->tab);
d3153 4
a3156 1
   is non-zero.  */
d3161 1
a3161 1
  const char **p;
d3164 3
a3166 3
  for (p = cache->tab; p < cache->tab + cache->tab_cur_size; p++)
    if (filename_cmp (*p, file) == 0)
      return 1;
d3170 1
a3170 9
    {
      if (cache->tab_cur_size == cache->tab_alloc_size)
	{
	  cache->tab_alloc_size *= 2;
	  cache->tab = XRESIZEVEC (const char *, cache->tab,
				   cache->tab_alloc_size);
	}
      cache->tab[cache->tab_cur_size++] = file;
    }
@


1.317
log
@	* symtab.c (output_source_filename): Delete unnecessary forward decl.
	(filename_seen_cache): New struct.
	(INITIAL_FILENAME_SEEN_CACHE_SIZE): New macro.
	(create_filename_seen_cache): New function.
	(clear_filename_seen_cache, delete_filename_seen_cache): New functions.
	(filename_seen): Delete arg "first".  New arg "cache".  All callers
	updated.
	(output_source_filename_data): New struct.
	(output_source_filename): Delete arg "first".  New arg "data".
	All callers updated.
	(sources_info): Delete local "first".  New locals "data", "cleanups".
	Rewrite to use filename_seen_cache.
	(add_partial_filename_data): Delete member "first".  New member
	"filename_seen_cache".  All uses updated.
	(make_source_files_completion_list): Rewrite to use
	filename_seen_cache.
@
text
@d3156 1
a3156 1
/* If FILE is not already in the table of files, return zero;
d3158 1
a3158 2
   is non-zero.  If *FIRST is non-zero, forget the old table
   contents.  */
@


1.316
log
@	* linespec.c: #include "stack.h".
	(decode_line_with_current_source): Moved here from symtab.c and
	renamed from decode_line_spec.  All callers updated.
	(decode_line_with_last_displayed): Moved here from breakpoint.c and
	renamed from decode_line_spec_1.  All callers updated.
	* linespec.h (decode_line_with_current_source): Move declaration here
	from symtab.h and renamed from decode_line_spec.
	(decode_line_with_last_displayed): Move declaration here from symtab.h
	and renamed from decode_line_spec_1.
	* macrocmd.c: #include "linespec.h".
	* symtab.c: Remove #include "linespec.h".
@
text
@a77 2
static void output_source_filename (const char *, int *);

d3106 50
d3162 1
a3162 1
filename_seen (const char *file, int add, int *first)
a3163 8
  /* Table of files seen so far.  */
  static const char **tab = NULL;
  /* Allocated size of tab in elements.
     Start with one 256-byte block (when using GNU malloc.c).
     24 is the malloc overhead when range checking is in effect.  */
  static int tab_alloc_size = (256 - 24) / sizeof (char *);
  /* Current size of tab in elements.  */
  static int tab_cur_size;
a3165 7
  if (*first)
    {
      if (tab == NULL)
	tab = (const char **) xmalloc (tab_alloc_size * sizeof (*tab));
      tab_cur_size = 0;
    }

d3167 1
a3167 1
  for (p = tab; p < tab + tab_cur_size; p++)
d3174 1
a3174 1
      if (tab_cur_size == tab_alloc_size)
d3176 3
a3178 3
	  tab_alloc_size *= 2;
	  tab = (const char **) xrealloc ((char *) tab,
					  tab_alloc_size * sizeof (*tab));
d3180 1
a3180 1
      tab[tab_cur_size++] = file;
d3186 11
d3198 2
a3199 2
   NAME is the name to print and *FIRST is nonzero if this is the first
   name printed.  Set *FIRST to zero.  */
d3202 2
a3203 1
output_source_filename (const char *name, int *first)
d3215 1
a3215 1
  if (filename_seen (name, 1, first))
d3220 1
d3222 3
a3224 8
  if (*first)
    {
      *first = 0;
    }
  else
    {
      printf_filtered (", ");
    }
d3244 2
a3245 1
  int first;
d3252 4
d3258 1
a3258 1
  first = 1;
d3263 1
a3263 1
    output_source_filename (fullname ? fullname : s->filename, &first);
d3270 3
a3272 2
  first = 1;
  map_partial_symbol_filenames (output_partial_symbol_filename, &first,
d3275 2
d4595 1
a4595 1
  int *first;
d4612 1
a4612 1
  if (!filename_seen (filename, 1, data->first)
d4624 1
a4624 1
	  && !filename_seen (base_name, 1, data->first)
a4639 1
  int first = 1;
d4644 2
a4645 1
  struct cleanup *back_to;
d4652 4
d4660 1
a4660 1
      if (!filename_seen (s->filename, 1, &first)
d4675 1
a4675 1
	      && !filename_seen (base_name, 1, &first)
d4681 1
a4681 1
  datum.first = &first;
d4688 2
@


1.315
log
@	* symtab.c (lookup_symbol_aux_objfile): Use
	ALL_OBJFILE_PRIMARY_SYMTABS.
@
text
@a35 1
#include "linespec.h"
a4822 21
struct symtabs_and_lines
decode_line_spec (char *string, int flags)
{
  struct symtabs_and_lines sals;
  struct symtab_and_line cursal;

  if (string == 0)
    error (_("Empty line specification."));

  /* We use whatever is set as the current source line.  We do not try
     and get a default  or it will recursively call us!  */
  cursal = get_current_source_symtab_and_line ();

  sals = decode_line_1 (&string, flags,
			cursal.symtab, cursal.line);

  if (*string)
    error (_("Junk at end of line specification: %s"), string);
  return sals;
}

@


1.314
log
@	* NEWS: Mention new options "set debug dwarf2-read" and
	"set debug symtab-create".
	* dwarf2read.c (dwarf2_read_debug): New static global.
	(dwarf2_build_psymtabs_hard): Add debugging printfs.
	(process_queue): Ditto.
	(process_full_comp_unit): Ditto.
	(_initialize_dwarf2_read): Add new option "set debug dwarf2-read".
	* elfread.c (elf_symfile_read): Add debugging printf.
	* minsyms.c (install_minimal_symbols): Ditto.
	* psymtab.c (allocate_psymtab): Ditto.
	* symfile.c (allocate_symtab): Ditto.
	* symtab.c (symtab_create_debug): New global.
	(_initialize_symtab): Add new option "set debug symtab-create".
	* symtab.h (symtab_create_debug): Declare.

	doc/
	* gdb.texinfo (Debugging Output): Document debug options dwarf2-read
	and symtab-create.
@
text
@d1522 11
a1532 12
  ALL_OBJFILE_SYMTABS (objfile, s)
    if (s->primary)
      {
	bv = BLOCKVECTOR (s);
	block = BLOCKVECTOR_BLOCK (bv, block_index);
	sym = lookup_block_symbol (block, name, domain);
	if (sym)
	  {
	    block_found = block;
	    return fixup_symbol_section (sym, objfile);
	  }
      }
@


1.313
log
@	* symtab.h (minimal_symbol): New member created_by_gdb.
	* elfread.c (elf_symtab_read): Set created_by_gdb for @@plt minsym
	created by gdb.
	* symtab.c (lookup_symbol_in_objfile_from_linkage_name): New function.
	(search_symbols): Call it instead of lookup_symbol.
	Skip symbols created by gdb.  Only scan minsyms if nfiles == 0.

	testsuite:
	* gdb.base/info-fun.exp: New file.
	* gdb.base/info-fun.c: New file.
	* gdb.base/info-fun-solib.c: New file.
@
text
@d112 3
d5020 8
@


1.312
log
@	* ada-lang.c (ada_make_symbol_completion_list): Return a VEC.
	* breakpoint.c (catch_syscall_completer): Return a VEC.
	* cli/cli-cmds.c (complete_command): Update.
	* cli/cli-decode.c (complete_on_cmdlist): Return a VEC.
	(complete_on_enum): Likewise.
	* command.h: Include gdb_vecs.h.
	(completer_ftype): Change return type.
	(complete_on_cmdlist, complete_on_enum): Likewise.
	* completer.c (noop_completer, filename_completer)
	(location_completer): Return a VEC.
	(add_struct_fields): Remove 'nextp' argument.  Change 'output'
	to a VEC.
	(expression_completer, complete_line_internal, complete_line)
	(command_completer): Return a VEC.
	(gdb_completion_word_break_characters, line_completion_function):
	Update.
	* completer.h: Include gdb_vecs.h.
	(complete_line, noop_completer, filename_completer)
	(expression_completer, location_completer, command_completer):
	Update.
	* f-lang.c (f_word_break_characters): Return a VEC.
	* interps.c (interpreter_completer): Return a VEC.
	* language.h (struct language_defn)
	<la_make_symbol_completion_list>: Return a VEC.
	* python/py-cmd.c (cmdpy_completer): Return a VEC.
	* symtab.c (free_completion_list): Take a VEC.
	(return_val_size, return_val_index): Remove.
	(return_val): Now a VEC.
	(completion_list_add_name): Update.
	(default_make_symbol_completion_list_break_on)
	(default_make_symbol_completion_list, make_symbol_completion_list)
	(make_symbol_completion_list_fn, make_file_symbol_completion_list):
	Return a VEC.
	(add_filename_to_list): Update.
	(struct add_partial_filename_data) <list_used, list_alloced>: Remove.
	<list>: Now a VEC.
	(maybe_add_partial_symtab_filename): Update.
	(make_source_files_completion_list): Return a VEC.
	* symtab.h (default_make_symbol_completion_list_break_on)
	(default_make_symbol_completion_list, make_symbol_completion_list)
	(make_symbol_completion_list_fn, make_file_symbol_completion_list)
	(make_source_files_completion_list): Update.
@
text
@d1555 42
d3495 3
a3497 2
     for the function, for variables we have to call lookup_symbol
     to determine if the variable has debug info.
d3499 4
a3502 1
     any matching symbols without debug info.  */
d3510 3
d3522 9
a3530 15
		if (0 == find_pc_symtab (SYMBOL_VALUE_ADDRESS (msymbol)))
		  {
		    /* FIXME: carlton/2003-02-04: Given that the
		       semantics of lookup_symbol keeps on changing
		       slightly, it would be a nice idea if we had a
		       function lookup_symbol_minsym that found the
		       symbol associated to a given minimal symbol (if
		       any).  */
		    if (kind == FUNCTIONS_DOMAIN
			|| lookup_symbol (SYMBOL_LINKAGE_NAME (msymbol),
					  (struct block *) NULL,
					  VAR_DOMAIN, 0)
			== NULL)
		      found_misc = 1;
		  }
d3607 1
a3607 1
  if (found_misc || kind != FUNCTIONS_DOMAIN)
d3613 3
d3625 4
a3628 3
		/* Functions:  Look up by address.  */
		if (kind != FUNCTIONS_DOMAIN ||
		    (0 == find_pc_symtab (SYMBOL_VALUE_ADDRESS (msymbol))))
d3630 3
a3632 4
		    /* Variables/Absolutes:  Look up by name.  */
		    if (lookup_symbol (SYMBOL_LINKAGE_NAME (msymbol),
				       (struct block *) NULL, VAR_DOMAIN, 0)
			 == NULL)
@


1.311
log
@New "iterate_over_objfiles_in_search_order" gdbarch method.

This patch introduces the "iterate_over_objfiles_in_search_order"
gdbarch method, as well as its default implementation, and converts
the areas where it will matter to using this gdbarch method.

The default method implementation is the only one installed, and
the changes should have no functional impact in terms of behavior.
This only paves the way for the architectures that will need their
own version.

gdb/ChangeLog:

        * gdbarch.sh: Add generation of
        "iterate_over_objfiles_in_search_order_cb_ftype" typedef in
        gdbarch.h.  Add include of "objfiles.h" in gdbarch.c.
        (iterate_over_objfiles_in_search_order): New gdbarch method.
        * gdbarch.h, gdbarch.c: Regenerate.
        * objfiles.h (default_iterate_over_objfiles_in_search_order):
        Add declaration.
        * objfiles.c (default_iterate_over_objfiles_in_search_order):
        New function.
        * symtab.c (lookup_symbol_aux_objfile): New function, extracted
        out of lookup_symbol_aux_symtabs.
        (lookup_symbol_aux_symtabs): Replace extracted-out code by
        call to lookup_symbol_aux_objfile.
        (struct global_sym_lookup_data): New type.
        (lookup_symbol_global_iterator_cb): New function.
        (lookup_symbol_global): Search for symbol using
        gdbarch_iterate_over_objfiles_in_search_order and
        lookup_symbol_global_iterator_cb.
        * findvar.c (struct minsym_lookup_data): New type.
        (minsym_lookup_iterator_cb): New function.
        (default_read_var_value) [case LOC_UNRESOLVED]: Resolve the
        symbol's address via gdbarch_iterate_over_objfiles_in_search_order
        and minsym_lookup_iterator_cb.
@
text
@d3884 1
a3884 1
free_completion_list (char ***list_ptr)
d3886 2
a3887 2
  int i = 0;
  char **list = *list_ptr;
d3889 3
a3891 6
  while (list[i] != NULL)
    {
      xfree (list[i]);
      i++;
    }
  xfree (list);
d3904 1
a3904 3
static int return_val_size;
static int return_val_index;
static char **return_val;
d3951 1
a3951 7
    if (return_val_index + 3 > return_val_size)
      {
	newsize = (return_val_size *= 2) * sizeof (char *);
	return_val = (char **) xrealloc ((char *) return_val, newsize);
      }
    return_val[return_val_index++] = new;
    return_val[return_val_index] = NULL;
d4115 1
a4115 1
char **
d4170 1
a4170 3
	return_val = (char **) xmalloc (sizeof (char *));
	return_val[0] = NULL;
	return return_val;
d4206 1
a4206 4
  return_val_size = 100;
  return_val_index = 0;
  return_val = (char **) xmalloc ((return_val_size + 1) * sizeof (char *));
  return_val[0] = NULL;
d4321 1
a4321 1
char **
d4327 3
a4329 3
/* Return a NULL terminated array of all symbols (regardless of class)
   which begin by matching TEXT.  If the answer is no symbols, then
   the return value is an array which contains only a NULL pointer.  */
d4331 1
a4331 1
char **
d4340 1
a4340 1
char **
d4350 1
a4350 1
char **
d4396 1
a4396 3
	return_val = (char **) xmalloc (sizeof (char *));
	return_val[0] = NULL;
	return return_val;
d4407 1
a4407 4
  return_val_size = 10;
  return_val_index = 0;
  return_val = (char **) xmalloc ((return_val_size + 1) * sizeof (char *));
  return_val[0] = NULL;
d4450 1
a4450 1
		      char ***list, int *list_used, int *list_alloced)
a4454 7
  if (*list_used + 1 >= *list_alloced)
    {
      *list_alloced *= 2;
      *list = (char **) xrealloc ((char *) *list,
				  *list_alloced * sizeof (char *));
    }

d4475 1
a4475 2
  (*list)[*list_used] = new;
  (*list)[++*list_used] = NULL;
d4503 1
a4503 3
  char ***list;
  int *list_used;
  int *list_alloced;
d4521 1
a4521 2
      add_filename_to_list (filename, data->text, data->word,
			    data->list, data->list_used, data->list_alloced);
d4530 1
a4530 2
	add_filename_to_list (base_name, data->text, data->word,
			      data->list, data->list_used, data->list_alloced);
d4534 4
a4537 4
/* Return a NULL terminated array of all source files whose names
   begin with matching TEXT.  The file names are looked up in the
   symbol tables of this program.  If the answer is no matchess, then
   the return value is an array which contains only a NULL pointer.  */
d4539 1
a4539 1
char **
a4544 2
  int list_alloced = 1;
  int list_used = 0;
d4546 1
a4546 1
  char **list = (char **) xmalloc (list_alloced * sizeof (char *));
a4550 2
  list[0] = NULL;

d4565 1
a4565 2
	  add_filename_to_list (s->filename, text, word,
				&list, &list_used, &list_alloced);
d4577 1
a4577 2
	    add_filename_to_list (base_name, text, word,
				  &list, &list_used, &list_alloced);
a4585 2
  datum.list_used = &list_used;
  datum.list_alloced = &list_alloced;
@


1.310
log
@Revert "Search global symbols from the expression's block objfile first."

The search order used in this patch breaks global symbol lookups
for certain symbols when copy-relocation is used.  A slightly different
search order will be implemented later.

gdb/ChangeLog:

        Revert the following patch:
        * findvar.c (default_read_var_value): For LOC_UNRESOLVED symbols,
        try locating the symbol in the symbol's own objfile first, before
        extending the search to all objfiles.
        * symtab.c (lookup_symbol_aux_objfile): New function, extracted
        out of lookup_symbol_aux_symtabs.
        (lookup_symbol_aux_symtabs): Add new parameter "exclude_objfile".
        Replace extracted-out code by call to lookup_symbol_aux_objfile.
        Do not search EXCLUDE_OBJFILE.
        (lookup_static_symbol_aux): Update call to lookup_symbol_aux_symtabs.
        (lookup_symbol_global): Search for matches in the block's objfile
        first, before searching all other objfiles.
@
text
@d1501 2
a1502 2
/* Check to see if the symbol is defined in one of the symtabs.
   BLOCK_INDEX should be either GLOBAL_BLOCK or STATIC_BLOCK,
d1507 32
a1543 3
  struct blockvector *bv;
  const struct block *block;
  struct symtab *s;
d1547 3
a1549 17
    if (objfile->sf)
      objfile->sf->qf->pre_expand_symtabs_matching (objfile,
						    block_index,
						    name, domain);

    ALL_OBJFILE_SYMTABS (objfile, s)
      if (s->primary)
	{
	  bv = BLOCKVECTOR (s);
	  block = BLOCKVECTOR_BLOCK (bv, block_index);
	  sym = lookup_block_symbol (block, name, domain);
	  if (sym)
	    {
	      block_found = block;
	      return fixup_symbol_section (sym, objfile);
	    }
	}
d1666 40
d1716 1
d1725 6
a1730 3
  sym = lookup_symbol_aux_symtabs (GLOBAL_BLOCK, name, domain);
  if (sym != NULL)
    return sym;
d1732 1
a1732 8
  ALL_OBJFILES (objfile)
  {
    sym = lookup_symbol_aux_quick (objfile, GLOBAL_BLOCK, name, domain);
    if (sym)
      return sym;
  }

  return NULL;
@


1.309
log
@	* symtab.c (lookup_global_symbol_from_objfile): Only scan blockvector
	of primary symtab.
	(basic_lookup_transparent_type): Ditto.
@
text
@d98 1
a98 2
					  const domain_enum domain,
					  struct objfile *exclude_objfile);
d1362 1
a1362 1
  sym = lookup_symbol_aux_symtabs (STATIC_BLOCK, name, domain, NULL);
d1501 2
a1502 2
/* Check to see if the symbol is defined in one of the OBJFILE's
   symtabs.  BLOCK_INDEX should be either GLOBAL_BLOCK or STATIC_BLOCK,
d1507 2
a1508 2
lookup_symbol_aux_objfile (struct objfile *objfile, int block_index,
			   const char *name, const domain_enum domain)
d1510 2
a1511 1
  struct symbol *sym = NULL;
d1516 6
a1521 3
  if (objfile->sf)
    objfile->sf->qf->pre_expand_symtabs_matching (objfile, block_index,
						  name, domain);
d1523 2
a1524 6
  ALL_OBJFILE_PRIMARY_SYMTABS (objfile, s)
    {
      bv = BLOCKVECTOR (s);
      block = BLOCKVECTOR_BLOCK (bv, block_index);
      sym = lookup_block_symbol (block, name, domain);
      if (sym)
d1526 8
a1533 2
	  block_found = block;
	  return fixup_symbol_section (sym, objfile);
a1534 26
    }

  return NULL;
}

/* Same as lookup_symbol_aux_objfile, except that it searches all
   objfiles except for EXCLUDE_OBJFILE.  Return the first match found.

   If EXCLUDE_OBJFILE is NULL, then all objfiles are searched.  */

static struct symbol *
lookup_symbol_aux_symtabs (int block_index, const char *name,
			   const domain_enum domain,
			   struct objfile *exclude_objfile)
{
  struct symbol *sym;
  struct objfile *objfile;

  ALL_OBJFILES (objfile)
  {
    if (objfile != exclude_objfile)
      {
	sym = lookup_symbol_aux_objfile (objfile, block_index, name, domain);
	if (sym)
	  return sym;
      }
a1659 1
  struct objfile *block_objfile = NULL;
d1663 3
a1665 3
  block_objfile = lookup_objfile_from_block (block);
  if (block_objfile != NULL)
    sym = solib_global_lookup (block_objfile, name, domain);
d1669 1
a1669 19
  /* If BLOCK_OBJFILE is not NULL, then search this objfile first.
     In case the global symbol is defined in multiple objfiles,
     we have a better chance of finding the most relevant symbol.  */

  if (block_objfile != NULL)
    {
      sym = lookup_symbol_aux_objfile (block_objfile, GLOBAL_BLOCK,
				       name, domain);
      if (sym == NULL)
	sym = lookup_symbol_aux_quick (block_objfile, GLOBAL_BLOCK,
				       name, domain);
      if (sym != NULL)
	return sym;
    }

  /* Symbol not found in the BLOCK_OBJFILE, so try all the other
     objfiles, starting with symtabs first, and then partial symtabs.  */

  sym = lookup_symbol_aux_symtabs (GLOBAL_BLOCK, name, domain, block_objfile);
d1675 3
a1677 6
    if (objfile != block_objfile)
      {
	sym = lookup_symbol_aux_quick (objfile, GLOBAL_BLOCK, name, domain);
	if (sym)
	  return sym;
      }
@


1.308
log
@	* objfiles.h (ALL_OBJFILE_PRIMARY_SYMTABS): New macro.
	(ALL_PRIMARY_SYMTABS): Use it.
	(ALL_PSPACE_PRIMARY_SYMTABS): Ditto.
	* dwarf2read.c (dw2_find_symbol_file): Ditto.
	* linespec.c (iterate_over_all_matching_symtabs): Ditto.
	* symtab.c (lookup_symbol_aux_objfile): Ditto.
	(basic_lookup_transparent_type): Ditto.
@
text
@d1481 11
a1491 11
      ALL_OBJFILE_SYMTABS (objfile, s)
        {
          bv = BLOCKVECTOR (s);
          block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
          sym = lookup_block_symbol (block, name, domain);
          if (sym)
            {
              block_found = block;
              return fixup_symbol_section (sym, (struct objfile *)objfile);
            }
        }
d1863 1
a1863 1
    ALL_OBJFILE_SYMTABS (objfile, s)
@


1.307
log
@2012-06-02  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* symtab.c (symbol_demangled_name): New variable `dem_name'.  Use
	it to optimize resolution of demangled name.
@
text
@d1520 11
a1530 12
  ALL_OBJFILE_SYMTABS (objfile, s)
    if (s->primary)
      {
	bv = BLOCKVECTOR (s);
	block = BLOCKVECTOR_BLOCK (bv, block_index);
	sym = lookup_block_symbol (block, name, domain);
	if (sym)
	  {
	    block_found = block;
	    return fixup_symbol_section (sym, objfile);
	  }
      }
d1831 10
a1840 11
    ALL_OBJFILE_SYMTABS (objfile, s)
      if (s->primary)
	{
	  bv = BLOCKVECTOR (s);
	  block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
	  sym = lookup_block_symbol (block, name, STRUCT_DOMAIN);
	  if (sym && !TYPE_IS_OPAQUE (SYMBOL_TYPE (sym)))
	    {
	      return SYMBOL_TYPE (sym);
	    }
	}
@


1.306
log
@	* symtab.c (search_symbols): Formatting fixes.
	(print_symbol_info): Formatting fixes.
@
text
@d853 2
d863 1
a863 2
      if (symbol_get_demangled_name (gsymbol) != NULL)
	return symbol_get_demangled_name (gsymbol);
d866 3
a868 4
      if (symbol_get_demangled_name (gsymbol) != NULL)
	return symbol_get_demangled_name (gsymbol);
      else
	return ada_decode_symbol (gsymbol);
d873 1
a873 1
  return NULL;
@


1.305
log
@	* symtab.c (search_symbols): Pass NULL for file_matcher to
	expand_symtabs_matching if there are no files to match.
@
text
@d3457 4
a3460 4
	if (MSYMBOL_TYPE (msymbol) == ourtype ||
	    MSYMBOL_TYPE (msymbol) == ourtype2 ||
	    MSYMBOL_TYPE (msymbol) == ourtype3 ||
	    MSYMBOL_TYPE (msymbol) == ourtype4)
d3489 4
a3492 4
      for (i = GLOBAL_BLOCK; i <= STATIC_BLOCK; i++)
	{
	  struct symbol_search *prevtail = tail;
	  int nfound = 0;
d3494 4
a3497 4
	  b = BLOCKVECTOR_BLOCK (bv, i);
	  ALL_BLOCK_SYMBOLS (b, iter, sym)
	    {
	      struct symtab *real_symtab = SYMBOL_SYMTAB (sym);
d3499 1
a3499 1
	      QUIT;
d3501 40
a3540 40
	      if (file_matches (real_symtab->filename, files, nfiles)
		  && ((!datum.preg_p
		       || regexec (&datum.preg, SYMBOL_NATURAL_NAME (sym), 0,
				   NULL, 0) == 0)
		      && ((kind == VARIABLES_DOMAIN
			   && SYMBOL_CLASS (sym) != LOC_TYPEDEF
			   && SYMBOL_CLASS (sym) != LOC_UNRESOLVED
			   && SYMBOL_CLASS (sym) != LOC_BLOCK
			   /* LOC_CONST can be used for more than just enums,
			      e.g., c++ static const members.
			      We only want to skip enums here.  */
			   && !(SYMBOL_CLASS (sym) == LOC_CONST
				&& TYPE_CODE (SYMBOL_TYPE (sym))
				== TYPE_CODE_ENUM))
			  || (kind == FUNCTIONS_DOMAIN 
			      && SYMBOL_CLASS (sym) == LOC_BLOCK)
			  || (kind == TYPES_DOMAIN
			      && SYMBOL_CLASS (sym) == LOC_TYPEDEF))))
		{
		  /* match */
		  psr = (struct symbol_search *)
		    xmalloc (sizeof (struct symbol_search));
		  psr->block = i;
		  psr->symtab = real_symtab;
		  psr->symbol = sym;
		  psr->msymbol = NULL;
		  psr->next = NULL;
		  if (tail == NULL)
		    sr = psr;
		  else
		    tail->next = psr;
		  tail = psr;
		  nfound ++;
		}
	    }
	  if (nfound > 0)
	    {
	      if (prevtail == NULL)
		{
		  struct symbol_search dummy;
d3542 3
a3544 3
		  dummy.next = sr;
		  tail = sort_search_symbols (&dummy, nfound);
		  sr = dummy.next;
d3546 6
a3551 6
		  make_cleanup_free_search_symbols (sr);
		}
	      else
		tail = sort_search_symbols (prevtail, nfound);
	    }
	}
d3563 4
a3566 4
	if (MSYMBOL_TYPE (msymbol) == ourtype ||
	    MSYMBOL_TYPE (msymbol) == ourtype2 ||
	    MSYMBOL_TYPE (msymbol) == ourtype3 ||
	    MSYMBOL_TYPE (msymbol) == ourtype4)
d3633 3
a3635 3
  else if (kind < TYPES_DOMAIN ||
	   (kind == TYPES_DOMAIN &&
	    SYMBOL_DOMAIN (sym) == STRUCT_DOMAIN))
@


1.304
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@d3429 3
a3431 1
						search_symbols_file_matches,
@


1.303
log
@	* tracepoint.c (scope_info): Update.
	* symtab.c (lookup_block_symbol, iterate_over_symbols)
	(find_pc_sect_symtab, search_symbols)
	(default_make_symbol_completion_list_break_on)
	(make_file_symbol_completion_list): Update.
	* symmisc.c (dump_symtab_1): Update.
	* stack.c (print_frame_args, iterate_over_block_locals)
	(print_frame_labels, iterate_over_block_arg_vars): Update.
	* python/py-block.c (block_object) <dict>: Remove.
	<block>: New field.
	<iter>: Change type.
	(blpy_iter): Update.
	(blpy_block_syms_iternext): Update.
	* psymtab.c (map_block): Use block iterators.
	* objfiles.c (objfile_relocate1): Use ALL_DICT_SYMBOLS.
	* mi/mi-cmd-stack.c (list_args_or_locals): Update.
	* mdebugread.c (parse_symbol, mylookup_symbol): Update.
	* infrun.c (check_exception_resume): Update.
	* cp-support.c (make_symbol_overload_list_block): Update.
	* coffread.c (patch_opaque_types): Update.
	* buildsym.c (finish_block, end_symtab): Use ALL_DICT_SYMBOLS.
	* block.h (struct block_iterator): New.
	(block_iterator_first, block_iterator_next, block_iter_name_first)
	(block_iter_name_next, block_iter_match_first)
	(block_iter_match_next): Declare.
	(ALL_BLOCK_SYMBOLS): Redefine.
	* block.c (block_iterator_first, block_iterator_next)
	(block_iter_name_first, block_iter_name_next)
	(block_iter_match_first, block_iter_match_next): New functions.
	* ada-lang.c (ada_add_block_symbols)
	(ada_make_symbol_completion_list): Use block iterator.
@
text
@a158 1
  int offset;
a197 1
  struct cleanup *cleanup;
a3333 1
  char *val;
@


1.302
log
@Search global symbols from the expression's block objfile first.

gdb/ChangeLog:

        * findvar.c (default_read_var_value): For LOC_UNRESOLVED symbols,
        try locating the symbol in the symbol's own objfile first, before
        extending the search to all objfiles.
        * symtab.c (lookup_symbol_aux_objfile): New function, extracted
        out of lookup_symbol_aux_symtabs.
        (lookup_symbol_aux_symtabs): Add new parameter "exclude_objfile".
        Replace extracted-out code by call to lookup_symbol_aux_objfile.
        Do not search EXCLUDE_OBJFILE.
        (lookup_static_symbol_aux): Update call to lookup_symbol_aux_symtabs.
        (lookup_symbol_global): Search for matches in the block's objfile
        first, before searching all other objfiles.
@
text
@d1927 1
a1927 1
  struct dict_iterator iter;
d1932 1
a1932 1
      for (sym = dict_iter_name_first (BLOCK_DICT (block), name, &iter);
d1934 1
a1934 1
	   sym = dict_iter_name_next (name, &iter))
d1952 1
a1952 1
      for (sym = dict_iter_name_first (BLOCK_DICT (block), name, &iter);
d1954 1
a1954 1
	   sym = dict_iter_name_next (name, &iter))
d1989 1
a1989 1
      struct dict_iterator iter;
d1992 1
a1992 1
      for (sym = dict_iter_name_first (BLOCK_DICT (block), name, &iter);
d1994 1
a1994 1
	   sym = dict_iter_name_next (name, &iter))
d2084 1
a2084 1
	    struct dict_iterator iter;
d3332 1
a3332 1
  struct dict_iterator iter;
d4134 1
a4134 1
  struct dict_iterator iter;
d4366 1
a4366 1
  struct dict_iterator iter;
@


1.301
log
@2012-04-27  Sergio Durigan Junior  <sergiodj@@redhat.com>
	    Tom Tromey  <tromey@@redhat.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* Makefile.in (SFILES): Add `probe' and `stap-probe'.
	(COMMON_OBS): Likewise.
	(HFILES_NO_SRCDIR): Add `probe'.
	* NEWS: Mention support for static and SystemTap probes.
	* amd64-tdep.c (amd64_init_abi): Initializing proper fields used by
	SystemTap probes' arguments parser.
	* arm-linux-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(arm_stap_is_single_operand): New function.
	(arm_stap_parse_special_token): Likewise.
	(arm_linux_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* ax-gdb.c (require_rvalue): Removing static declaration.
	(gen_expr): Likewise.
	* ax-gdb.h (gen_expr): Declaring function.
	(require_rvalue): Likewise.
	* breakpoint.c: Include `gdb_regex.h' and `probe.h'.
	(bkpt_probe_breakpoint_ops): New variable.
	(momentary_breakpoint_from_master): Set the `probe' value.
	(add_location_to_breakpoint): Likewise.
	(break_command_1): Using proper breakpoint_ops according to the
	argument passed by the user in the command line.
	(bkpt_probe_insert_location): New function.
	(bkpt_probe_remove_location): Likewise.
	(bkpt_probe_create_sals_from_address): Likewise.
	(bkpt_probe_decode_linespec): Likewise.
	(tracepoint_probe_create_sals_from_address): Likewise.
	(tracepoint_probe_decode_linespec): Likewise.
	(tracepoint_probe_breakpoint_ops): New variable.
	(trace_command): Using proper breakpoint_ops according to the
	argument passed by the user in the command line.
	(initialize_breakpoint_ops): Initializing breakpoint_ops for
	static probes on breakpoints and tracepoints.
	* breakpoint.h (struct bp_location) <probe>: New field.
	* cli-utils.c (skip_spaces_const): New function.
	(extract_arg): Likewise.
	* cli-utils.h (skip_spaces_const): Likewise.
	(extract_arg): Likewise.
	* coffread.c (coff_sym_fns): Add `sym_probe_fns' value.
	* configure.ac: Append `stap-probe.o' to be generated when ELF
	support is present.
	* configure: Regenerate.
	* dbxread.c (aout_sym_fns): Add `sym_probe_fns' value.
	* elfread.c: Include `probe.h' and `arch-utils.h'.
	(probe_key): New variable.
	(elf_get_probes): New function.
	(elf_get_probe_argument_count): Likewise.
	(elf_evaluate_probe_argument): Likewise.
	(elf_compile_to_ax): Likewise.
	(elf_symfile_relocate_probe): Likewise.
	(stap_probe_key_free): Likewise.
	(elf_probe_fns): New variable.
	(elf_sym_fns): Add `sym_probe_fns' value.
	(elf_sym_fns_lazy_psyms): Likewise.
	(elf_sym_fns_gdb_index): Likewise.
	(_initialize_elfread): Initialize objfile cache for static
	probes.
	* gdb_vecs.h (struct probe): New forward declaration.
	(probe_p): New VEC declaration.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* gdbarch.sh (stap_integer_prefix): New variable.
	(stap_integer_suffix): Likewise.
	(stap_register_prefix): Likewise.
	(stap_register_suffix): Likewise.
	(stap_register_indirection_prefix): Likewise.
	(stap_register_indirection_suffix): Likewise.
	(stap_gdb_register_prefix): Likewise.
	(stap_gdb_register_suffix): Likewise.
	(stap_is_single_operand): New function.
	(stap_parse_special_token): Likewise.
	(struct stap_parse_info): Forward declaration.
	* i386-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(i386_stap_is_single_operand): New function.
	(i386_stap_parse_special_token): Likewise.
	(i386_elf_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* i386-tdep.h (i386_stap_is_single_operand): New function.
	(i386_stap_parse_special_token): Likewise.
	* machoread.c (macho_sym_fns): Add `sym_probe_fns' value.
	* mipsread.c (ecoff_sym_fns): Likewise.
	* objfiles.c (objfile_relocate1): Support relocation for static
	probes.
	* parse.c (prefixify_expression): Remove static declaration.
	(initialize_expout): Likewise.
	(reallocate_expout): Likewise.
	* parser-defs.h (initialize_expout): Declare function.
	(reallocate_expout): Likewise.
	(prefixify_expression): Likewise.
	* ppc-linux-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(ppc_stap_is_single_operand): New function.
	(ppc_stap_parse_special_token): Likewise.
	(ppc_linux_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* probe.c: New file, for generic statically defined probe support.
	* probe.h: Likewise.
	* s390-tdep.c: Including headers needed to perform the parsing of
	SystemTap probes' arguments.
	(s390_stap_is_single_operand): New function.
	(s390_gdbarch_init): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* somread.c (som_sym_fns): Add `sym_probe_fns' value.
	* stap-probe.c: New file, for SystemTap probe support.
	* stap-probe.h: Likewise.
	* symfile.h: Include `gdb_vecs.h'.
	(struct sym_probe_fns): New struct.
	(struct sym_fns) <sym_probe_fns>: New field.
	* symtab.c (init_sal): Initialize `probe' field.
	* symtab.h (struct probe): Forward declaration.
	(struct symtab_and_line) <probe>: New field.
	* tracepoint.c (start_tracing): Adjust semaphore on breakpoints
	locations.
	(stop_tracing): Likewise.
	* xcoffread.c (xcoff_sym_fns): Add `sym_probe_fns' value.
@
text
@d98 2
a99 1
					  const domain_enum domain);
d1365 1
a1365 1
  sym = lookup_symbol_aux_symtabs (STATIC_BLOCK, name, domain);
d1504 2
a1505 2
/* Check to see if the symbol is defined in one of the symtabs.
   BLOCK_INDEX should be either GLOBAL_BLOCK or STATIC_BLOCK,
d1510 34
d1545 2
a1546 1
			   const domain_enum domain)
a1549 3
  struct blockvector *bv;
  const struct block *block;
  struct symtab *s;
d1553 6
a1558 17
    if (objfile->sf)
      objfile->sf->qf->pre_expand_symtabs_matching (objfile,
						    block_index,
						    name, domain);

    ALL_OBJFILE_SYMTABS (objfile, s)
      if (s->primary)
	{
	  bv = BLOCKVECTOR (s);
	  block = BLOCKVECTOR_BLOCK (bv, block_index);
	  sym = lookup_block_symbol (block, name, domain);
	  if (sym)
	    {
	      block_found = block;
	      return fixup_symbol_section (sym, objfile);
	    }
	}
d1684 1
d1688 3
a1690 3
  objfile = lookup_objfile_from_block (block);
  if (objfile != NULL)
    sym = solib_global_lookup (objfile, name, domain);
d1694 19
a1712 1
  sym = lookup_symbol_aux_symtabs (GLOBAL_BLOCK, name, domain);
d1718 6
a1723 3
    sym = lookup_symbol_aux_quick (objfile, GLOBAL_BLOCK, name, domain);
    if (sym)
      return sym;
@


1.300
log
@	Initial pass at Go language support.
	* NEWS: Mention Go.
	* Makefile.in (SFILES): Add go-exp.y, go-lang.c, go-typeprint.c,
	go-valprint.c.
	(COMMON_OBS): Add go-lang.o, go-val.print.o, go-typeprint.o.
	(YYFILES): Add go-exp.c.
	(YYOBJ): Add go-exp.o.
	(local-maintainer-clean): Delete go-exp.c.
	* defs.h (enum language): Add language_go.
	* dwarf2read.c: #include "go-lang.h".
	(fixup_go_packaging): New function.
	(process_full_comp_unit): Call it when processing Go CUs.
	(dwarf2_physname): Add Go support.
	(read_file_scope): Handle missing language spec for GNU Go.
	(set_cu_language): Handle DW_LANG_Go.
	* go-exp.y: New file.
	* go-lang.h: New file.
	* go-lang.c: New file.
	* go-typeprint.c: New file.
	* go-valprint.c: New file.
	* symtab.c: #include "go-lang.h".
	(symbol_set_language): Handle language_go.
	(symbol_find_demangled_name, symbol_set_names): Ditto.
	(symbol_natural_name, demangle_for_lookup, find_main_name): Ditto.

	testsuite/
	* configure.ac: Create gdb.go/Makefile.
	* configure: Regenerate.
	* gdb.base/default.exp: Add "go" to "set language" testing.
	* gdb.go/Makefile.in: New file.
	* gdb.go/basic-types.exp: New file.
	* gdb.go/chan.exp: New file.
	* gdb.go/chan.go: New file.
	* gdb.go/handcall.exp: New file.
	* gdb.go/handcall.go: New file.
	* gdb.go/hello.exp: New file.
	* gdb.go/hello.go: New file.
	* gdb.go/integers.exp: New file.
	* gdb.go/integers.go: New file.
	* gdb.go/methods.exp: New file.
	* gdb.go/methods.go: New file.
	* gdb.go/package.exp: New file.
	* gdb.go/package1.go: New file.
	* gdb.go/package2.go: New file.
	* gdb.go/print.exp: New file.
	* gdb.go/strings.exp: New file.
	* gdb.go/strings.go: New file.
	* gdb.go/types.exp: New file.
	* gdb.go/types.go: New file.
	* gdb.go/unsafe.exp: New file.
	* gdb.go/unsafe.go: New file.
	* lib/future.exp: Add Go support.
	(gdb_find_go, gdb_find_go_linker): New procs.
	(gdb_default_target_compile): Add Go support.
	* lib/gdb.exp (skip_go_tests): New proc.
	* lib/go.exp: New file.

	doc/
	* gdb.texinfo (Supported Languages): Add Go.
	(Go): New node.
@
text
@d904 1
@


1.299
log
@	* symtab.c (skip_prologue_sal): Change test to check for "main()"
	in addition to "main".
@
text
@d42 1
d504 1
d625 16
d763 5
a767 1
  if (*slot == NULL)
d829 1
d858 1
d1150 1
a1150 1
  /* If we are using C++, D, or Java, demangle the name before doing a
d1191 9
d4838 7
@


1.298
log
@2012-03-01  Pedro Alves  <palves@@redhat.com>

	* amd64-linux-tdep.c (amd64_linux_record_signal): Make static.
	* breakpoint.c (create_exception_master_breakpoint, trace_command)
	(ftrace_command, strace_command): Make static.
	* d-lang.c (_initialize_d_language): Declare.
	* dwarf2expr.c (_initialize_dwarf2expr): Declare.
	* dwarf2loc.c (_initialize_dwarf2loc):
	* dwarf2read.c (process_psymtab_comp_unit): Make static.
	* exec.c (exec_get_section_table): Make static.
	* i386-linux-tdep.c (i386_linux_record_signal): Make static.
	* infcmd.c (ensure_valid_thread, ensure_not_tfind_mode): Make static.
	* inferior.c (remove_inferior_command, add_inferior_command)
	(clone_inferior_command): Make static.
	* linux-nat.c (linux_nat_thread_address_space)
	(linux_nat_core_of_thread): Make static.
	* linux-tdep.c (_initialize_linux_tdep): Declare.
	* objc-lang.c (_initialize_objc_lang): Declare.
	* opencl-lang.c (builtin_opencl_type, opencl_language_arch_info):
	Make static.
	(_initialize_opencl_language): Declare.
	* record.c (_initialize_record): Declare.
	* remote.c (demand_private_info, remote_get_tib_address)
	(remote_supports_cond_tracepoints)
	(remote_supports_fast_tracepoints, remote_get_tracepoint_status):
	Make static.
	* skip.c (_initialize_step_skip): Declare.
	* symtab.c (skip_prologue_using_lineinfo): Make static.
	* tracepoint.c (delete_trace_state_variable)
	(trace_variable_command, delete_trace_variable_command)
	(get_uploaded_tsv, find_matching_tracepoint_location)
	(find_matching_tsv, create_tsv_from_upload, get_traceframe_info):
	Make static.
	* value.c (pack_unsigned_long): Make static.
	* varobj.c (varobj_ensure_python_env): Make static.
	* windows-tdep.c (_initialize_windows_tdep): Declare.
	* xml-syscall.c (make_cleanup_free_syscalls_info): Make static.
@
text
@d2779 1
a2779 1
	  && name && strcmp (name, "main") == 0)
@


1.297
log
@	* gdbtypes.h (struct main_type): Change type of name,tag_name,
	and fields.name members from char * to const char *.  All uses updated.
	(struct cplus_struct_type): Change type of fn_fieldlists.name member
	from char * to const char *.  All uses updated.
	(type_name_no_tag): Update.
	(lookup_unsigned_typename, lookup_signed_typename): Update.
	* gdbtypes.c (type_name_no_tag): Change result type
	from char * to const char *.  All callers updated.
	(lookup_unsigned_typename, lookup_signed_typename): Change type of
	name parameter from char * to const char *.
	* symtab.h (struct cplus_specific): Change type of demangled_name
	member from char * to const char *.  All uses updated.
	(struct general_symbol_info): Change type of name and
	mangled_lang.demangled_name members from char * to const char *.
	All uses updated.
	(symbol_get_demangled_name, symbol_natural_name): Update.
	(symbol_demangled_name, symbol_search_name): Update.
	* symtab.c (symbol_get_demangled_name): Change result type
	from char * to const char *.  All callers updated.
	(symbol_natural_name, symbol_demangled_name): Ditto.
	(symbol_search_name): Ditto.
	(completion_list_add_name): Change type of symname,sym_text,
	text,word parameters from char * to const char *.
	(completion_list_objc_symbol): Change type of sym_text,
	text,word parameters from char * to const char *.
	* ada-lang.c (find_struct_field): Change type of name parameter
	from char * to const char *.
	(encoded_ordered_before): Similarly for N0,N1 parameters.
	(old_renaming_is_invisible): Similarly for function_name parameter.
	(ada_type_name): Change result type from char * to const char *.
	All callers updated.
	* ada-lang.h (ada_type_name): Update.
	* buildsym.c (hashname): Change type of name parameter
	from char * to const char *.
	* buildsym.h (hashname): Update.
	* dbxread.c (end_psymtab): Change type of include_list parameter
	from char ** to const char **.
	* dwarf2read.c (determine_prefix): Change result type
	from char * to const char *.  All callers updated.
	* f-lang.c (find_common_for_function): Change type of name, funcname
	parameters from char * to const char *.
	* f-lang.c (find_common_for_function): Update.
	* f-valprint.c (list_all_visible_commons): Change type of funcname
	parameters from char * to const char *.
	* gdbarch.sh (static_transform_name): Change type of name parameter
	and result from char * to const char *.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* i386-sol2-tdep.c (i386_sol2_static_transform_name): Change type
	of name parameter from char * to const char *.
	* jv-lang.c (java_primitive_type_from_name): Ditto.
	(java_demangled_signature_length): Similarly for signature parameter.
	(java_demangled_signature_copy): Ditto.
	(java_demangle_type_signature): Ditto.
	* jv-lang.h (java_primitive_type_from_name): Update.
	(java_demangle_type_signature): Update.
	* objc-lang.c (specialcmp): Change type of a,b parameters
	from char * to const char *.
	* p-lang.c (is_pascal_string_type): Change type of arrayname parameter
	from char * to const char *.  All callers updated.
	* p-lang.h (is_pascal_string_type): Update.
	* solib-frv.c (find_canonical_descriptor_in_load_object): Change type
	of name parameter from char * to const char *.
	* sparc-sol2-tdep.c (sparc_sol2_static_transform_name): Ditto.
	* utils.c (fprintf_symbol_filtered): Ditto.
	* defs.h (fprintf_symbol_filtered): Update.
	* sparc-tdep.h (sparc_sol2_static_transform_name): Update.
	* stabsread.h (end_psymtab): Update.
	* stack.c (find_frame_funname): Change type of funname parameter
	from char ** to const char **.
	* stack.h (find_frame_funname): Update.
	* typeprint.c (type_print): Change type of varstring parameter
	from char * to const char *.
	* value.h (type_print): Update.
	* xcoffread.c (xcoff_start_psymtab): Change type of filename parameter
	from char * to const char *.  All callers updated.
	(xcoff_end_psymtab): Change type of include_list parameter
	from char ** to const char **.  All callers updated.
	(swap_sym): Similarly for name parameter.  All callers updated.
	* coffread.c (patch_type): Add (char*) cast to xfree parameter.
	Use xstrdup.
	(process_coff_symbol): Use xstrdup.
	* stabsread.c (stabs_method_name_from_physname): Renamed from
	update_method_name_from_physname.  Change result type from void
	to char *.  All callers updated.
	(read_member_functions): In has_destructor case, store name in objfile
	obstack instead of malloc space.  In !has_stub case, fix mem leak.
@
text
@d2603 1
a2603 1
CORE_ADDR
@


1.296
log
@	PR gdb/9307:
	* symtab.c (lookup_language_this): Set block_found.
gdb/testsuite
	* gdb.cp/dispcxx.exp: New file.
	* gdb.cp/dispcxx.cc: New file.
@
text
@a67 2
static void completion_list_add_name (char *, char *, int, char *, char *);

d367 1
a367 1
  char *field_name = TYPE_FN_FIELDLIST_NAME (type, method_id);
d369 1
a369 1
  char *newname = type_name_no_tag (type);
d479 1
a479 1
char *
d687 1
a687 1
	gsymbol->name = (char *) linkage_name;
d690 5
a694 3
	  gsymbol->name = obstack_alloc (&objfile->objfile_obstack, len + 1);
	  memcpy (gsymbol->name, linkage_name, len);
	  gsymbol->name[len] = '\0';
d800 1
a800 1
char *
d828 1
a828 1
char *
d858 1
a858 1
char *
d3836 3
a3838 2
completion_list_add_name (char *symname, char *sym_text, int sym_text_len,
			  char *text, char *word)
d3886 3
a3888 2
completion_list_objc_symbol (struct minimal_symbol *msymbol, char *sym_text,
			     int sym_text_len, char *text, char *word)
d3893 1
a3893 1
  char *method, *category, *selector;
@


1.295
log
@2012-02-01  Gary Benson  <gbenson@@redhat.com>

	* symtab.h (symbol_name_match_p_ftype): New typedef.
	(iterate_over_symbols): Use the above.
	* symtab.c (iterate_over_symbols): Likewise.
	* language.h (language_defn->la_iterate_over_symbols): Likewise.
	* ada-lang.c (ada_iterate_over_symbols): Likewise.
	* linespec.c (iterate_over_all_matching_symtabs): Likewise.
	(iterate_name_matcher): Document return values.
	(collect_one_symbol): Likewise.
	(collect_function_symbols): Likewise.
	(collect_symbols): Likewise.
@
text
@d1235 4
a1238 1
	return sym;
@


1.294
log
@gdb/
	Code cleanup: Make 1440 bytes of data segment read-only.
	* arch-utils.c (endian_enum): Make it const char *const [].
	* arm-tdep.c (fp_model_strings, arm_abi_strings, arm_mode_strings):
	Likewise.
	* breakpoint.c (always_inserted_enums): Likewise.
	* cli/cli-cmds.c (script_ext_enums): Likewise.
	* cli/cli-decode.c (add_setshow_enum_cmd, complete_on_enum): Make the
	enumlist parameter const char *const *.
	* cli/cli-decode.h (struct cmd_list_element): Make the enums field
	const char *const *.
	* command.h (complete_on_enum, add_setshow_enum_cmd): Make the enumlist
	parameter const char *const *.
	* cris-tdep.c (cris_modes): Make it const char *const [].
	* filesystem.c (target_file_system_kinds): Likewise.
	* i386-tdep.c (valid_flavors, valid_conventions): Likewise.
	* infrun.c (follow_fork_mode_kind_names, follow_exec_mode_names)
	(can_use_displaced_stepping_enum, scheduler_enums)
	(exec_direction_names): Likewise.
	* language.c (_initialize_language): Make the type_or_range_names and
	case_sensitive_names variables const char *const [].
	* mips-tdep.c (mips_abi_strings): Make it const char *const [].
	* python/python.c (python_excp_enums): Likewise.
	* remote.c (interrupt_sequence_modes): Likewise.
	* rs6000-tdep.c (powerpc_vector_strings): Likewise.
	* serial.c (logbase_enums): Likewise.
	* sh-tdep.c (sh_cc_enum): Likewise.
	* stack.c (print_frame_arguments_choices, print_entry_values_choices):
	Likewise.
	* symtab.c (multiple_symbols_modes): Likewise.
	* tui/tui-win.c (tui_border_kind_enums, tui_border_mode_enums):
	Likewise.
	* utils.c (internal_problem_modes): Likewise.
@
text
@d1903 1
a1903 1
		      int (*callback) (struct symbol *, void *),
@


1.293
log
@	* symtab.c: Whitespace cleanup, no code changes.
@
text
@d125 1
a125 1
static const char *multiple_symbols_modes[] =
@


1.292
log
@	* symtab.c (lookup_symbol_in_language): Improve comment.
	(lookup_symbol_aux): Fix comment.
@
text
@d462 1
d480 1
d498 1
d530 1
d540 1
d827 1
d857 1
d868 1
a1807 1

d2599 1
d2671 1
d2844 1
d2983 1
d3027 1
d3061 1
d3120 1
d3148 1
d3162 1
d3208 1
d3218 1
d4014 1
d4028 1
d4449 1
@


1.291
log
@Remove language param from name_matcher in struct quick_symbol_functions

The quick_symbol_functions struct contains a field which is pointer
a function which takes another function, called name_matcher, as
its parameter.  This name_matcher currently has 3 arguments, one
of them being the language. This parameter is no longer used, and
thus deleted.

gdb/ChangeLog:

        * symfile.h (struct quick_symbol_functions) [expand_symtabs_matching]:
        Remove language parameter from name_matcher.  Adjust the comment.
        * symtab.c (search_symbols_name_matches, expand_partial_symbol_name):
        Remove language parameter.
        * ada-lang.c (ada_expand_partial_symbol_name): Likewise.
        * linespec.c (iterate_name_matcher): Likewise.
        * dwarf2read.c (dw2_expand_symtabs_matching): Adjust type of
        name_matcher.  Adjust call accordingly.
        * psymtab.c (expand_symtabs_matching_via_partial): Likewise.
        (maintenance_check_symtabs): Adjust type of parameter "fun".
        * psymtab.h (maintenance_check_symtabs): Likewise.
@
text
@d1173 3
a1175 3
/* This function has a bunch of loops in it and it would seem to be
   attractive to put in some QUIT's (though I'm not really sure
   whether it can run long enough to be really important).  But there
d1177 1
a1177 1
   out of here: find_proc_desc in alpha-tdep.c and mips-tdep.c.  (Note
d1237 1
a1237 3
   of the symbol that we're looking for and, if LINKAGE_NAME is
   non-NULL, ensure that the symbol's linkage name matches as
   well.  */
@


1.290
log
@gdb
	* NEWS: Add item.
	* symtab.h (compare_filenames_for_search): Declare.
	* symtab.c (compare_filenames_for_search): New function.
	(iterate_over_some_symtabs): Use it.
	* symfile.h (struct quick_symbol_functions)
	<map_symtabs_matching_filename>: Change spec.
	* psymtab.c (partial_map_symtabs_matching_filename): Use
	compare_filenames_for_search.  Update for new spec.
	* dwarf2read.c (dw2_map_symtabs_matching_filename): Use
	compare_filenames_for_search.  Update for new spec.
	* breakpoint.c (clear_command): Use compare_filenames_for_search.
gdb/doc
	* gdb.texinfo (Specify Location): Document relative file name
	handling.
gdb/testsuite
	* gdb.linespec/linespec.exp: Change some tests to use $decimal.
	Add tests for relative directory.
@
text
@d3204 1
a3204 2
search_symbols_name_matches (const struct language_defn *language,
			     const char *symname, void *user_data)
d4012 1
a4012 2
expand_partial_symbol_name (const struct language_defn *language,
			    const char *name, void *user_data)
@


1.289
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d148 29
d201 2
d206 1
d213 6
d237 7
d260 6
a269 14
  /* Now, search for a matching tail (only if name doesn't have any dirs).  */

  if (lbasename (name) == name)
    {
      for (s = first; s != NULL && s != after_last; s = s->next)
	{
	  if (FILENAME_CMP (lbasename (s->filename), name) == 0)
	    {
	      if (callback (s, data))
		return 1;
	    }
	}
    }

@


1.288
log
@the "ambiguous linespec" series
gdb
2011-12-06  Joel Brobecker  <brobecker@@acacore.com>

        * language.h (struct language_defn): Add new component
        la_symbol_name_compare.
        * symfile.h (struct quick_symbol_functions): Update the profile
        of parameter "name_matcher" for the expand_symtabs_matching
        method.  Update the documentation accordingly.
        * ada-lang.h (ada_name_for_lookup): Add declaration.
        * ada-lang.c (ada_name_for_lookup): New function, extracted out
        from ada_iterate_over_symbols.
        (ada_iterate_over_symbols): Do not encode symbol name anymore.
        (ada_expand_partial_symbol_name): Adjust profile.
        (ada_language_defn): Add value for la_symbol_name_compare field.
        * linespec.c: #include "ada-lang.h".
        (iterate_name_matcher): Add language parameter. Replace call
        to strcmp_iw by call to language->la_symbol_name_compare.
        (decode_variable): Encode COPY if current language is Ada.
        * dwarf2read.c (dw2_expand_symtabs_matching): Adjust profile
        of name_matcher parameter.  Adjust call to name_matcher.
        * psymtab.c (expand_symtabs_matching_via_partial): Likewise.
        (expand_partial_symbol_names): Update profile of parameter "fun".
        * psymtab.h (expand_partial_symbol_names): Update profile of
        parameter "fun".
        * symtab.c (demangle_for_lookup): Update function documentation.
        (search_symbols_name_matches): Add language parameter.
        (expand_partial_symbol_name): Likewise.
        * c-lang.c (c_language_defn, cplus_language_defn)
        (asm_language_defn, minimal_language_defn): Add value for
        la_symbol_name_compare field.
        * d-lang.c (d_language_defn): Likewise.
        * f-lang.c (f_language_defn): Ditto.
        * jv-lang.c (java_language_defn): Ditto.
        * m2-lang.c (m2_language_defn): Ditto.
        * objc-lang.c (objc_language_defn): Ditto.
        * opencl-lang.c (opencl_language_defn): Ditto.
        * p-lang.c (pascal_language_defn): Ditto.
        * language.c (unknown_language_defn, auto_language_defn)
        (local_language_defn): Ditto.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* linespec.c (iterate_over_all_matching_symtabs): Use
	LA_ITERATE_OVER_SYMBOLS.
	(lookup_prefix_sym, add_matching_symbols_to_info): Likewise.
	(find_function_symbols, decode_variable): Remove Ada special
	case.
	* language.h (struct language_defn) <la_iterate_over_symbols>: New
	field.
	(LA_ITERATE_OVER_SYMBOLS): New macro.
	* language.c (unknown_language_defn, auto_language_defn)
	(local_language_defn): Update.
	* c-lang.c (c_language_defn, cplus_language_defn)
	(asm_language_defn, minimal_language_defn): Update.
	* d-lang.c (d_language_defn): Update.
	* f-lang.c (f_language_defn): Update.
	* jv-lang.c (java_language_defn): Update.
	* m2-lang.c (m2_language_defn): Update.
	* objc-lang.c (objc_language_defn): Update.
	* opencl-lang.c (opencl_language_defn): Update.
	* p-lang.c (pascal_language_defn): Update.
	* ada-lang.c (ada_iterate_over_symbols): New function.
	(ada_language_defn): Update.

2011-12-06  Tom Tromey  <tromey@@redhat.com>
	    Joel Brobecker  <brobecker@@acacore.com>

	PR breakpoints/13105, PR objc/8341, PR objc/8343, PR objc/8366,
	PR objc/8535, PR breakpoints/11657, PR breakpoints/11970,
	PR breakpoints/12023, PR breakpoints/12334, PR breakpoints/12856,
	PR shlibs/8929, PR shlibs/7393:
	* python/py-type.c (compare_maybe_null_strings): Rename from
	compare_strings.
	(check_types_equal): Update.
	* utils.c (compare_strings): New function.
	* tui/tui-winsource.c (tui_update_breakpoint_info): Update for
	location changes.
	* tracepoint.c (scope_info): Update.
	(trace_find_line_command): Use DECODE_LINE_FUNFIRSTLINE.
	* symtab.h (iterate_over_minimal_symbols)
	(iterate_over_some_symtabs, iterate_over_symtabs)
	(find_pcs_for_symtab_line, iterate_over_symbols)
	(demangle_for_lookup): Declare.
	(expand_line_sal): Remove.
	* symtab.c (iterate_over_some_symtabs, iterate_over_symtabs)
	(lookup_symtab_callback): New functions.
	(lookup_symtab): Rewrite.
	(demangle_for_lookup): New function, extract from
	lookup_symbol_in_language.
	(lookup_symbol_in_language): Use it.
	(iterate_over_symbols): New function.
	(find_line_symtab): Update.
	(find_pcs_for_symtab_line): New functions.
	(find_line_common): Add 'start' argument.
	(decode_line_spec): Update.  Change argument to 'flags', change
	interpretation.
	(append_expanded_sal): Remove.
	(append_exact_match_to_sals): Remove.
	(expand_line_sal): Remove.
	* symfile.h (struct quick_symbol_functions) <lookup_symtab>:
	Remove.
	<map_symtabs_matching_filename>: New field.
	* stack.c (func_command): Only look in the current program space.
	Use DECODE_LINE_FUNFIRSTLINE.
	* source.c (line_info): Set pspace on sal.  Check program space in
	the loop.  Use DECODE_LINE_LIST_MODE.
	(select_source_symtab): Use DECODE_LINE_FUNFIRSTLINE.
	* solib-target.c: Remove DEF_VEC_I(CORE_ADDR).
	* python/python.c (gdbpy_decode_line): Update.
	* psymtab.c (partial_map_expand_apply): New function.
	(partial_map_symtabs_matching_filename): Rename from
	lookup_partial_symbol.  Update arguments.
	(lookup_symtab_via_partial_symtab): Remove.
	(psym_functions): Update.
	* objc-lang.h (parse_selector, parse_method): Don't declare.
	(find_imps): Update.
	* objc-lang.c (parse_selector, parse_method): Now static.
	(find_methods): Change arguments.  Fill in a vector of symbol
	names.
	(uniquify_strings): New function.
	(find_imps): Change arguments.
	* minsyms.c (iterate_over_minimal_symbols): New function.
	* linespec.h (enum decode_line_flags): New.
	(struct linespec_sals): New.
	(struct linespec_result) <canonical>: Remove.
	<pre_expanded, addr_string, sals>: New fields.
	(destroy_linespec_result, make_cleanup_destroy_linespec_result)
	(decode_line_full): Declare.
	(decode_line_1): Update.
	* linespec.c (struct address_entry, struct linespec_state, struct
	collect_info): New types.
	(add_sal_to_sals_basic, add_sal_to_sals, hash_address_entry)
	(eq_address_entry, maybe_add_address): New functions.
	(total_number_of_methods): Remove.
	(iterate_name_matcher, iterate_over_all_matching_symtabs): New
	functions.
	(find_methods): Change arguments.  Don't canonicalize input.
	Simplify logic.
	(add_matching_methods, add_constructors)
	(build_canonical_line_spec): Remove.
	(filter_results, convert_results_to_lsals): New functions.
	(decode_line_2): Change arguments.  Rewrite for new data
	structures.
	(decode_line_internal): Rename from decode_line_1.  Change
	arguments.  Add cleanups.  Update for new data structures.
	(linespec_state_constructor, linespec_state_destructor)
	(decode_line_full, decode_line_1): New functions.
	(decode_indirect): Change arguments.  Update.
	(locate_first_half): Use skip_spaces.
	(decode_objc): Change arguments.  Update for new data structures.
	Simplify logic.
	(decode_compound): Change arguments.  Add cleanups.  Remove
	fallback code, replace with error.
	(struct decode_compound_collector): New type.
	(collect_one_symbol): New function.
	(lookup_prefix_sym): Change arguments.  Update.
	(compare_symbol_name, add_all_symbol_names_from_pspace)
	(find_superclass_methods ): New functions.
	(find_method): Rewrite.
	(struct symtab_collector): New type.
	(add_symtabs_to_list, collect_symtabs_from_filename): New
	functions.
	(symtabs_from_filename): Change API.  Rename from
	symtab_from_filename.
	(collect_function_symbols): New function.
	(find_function_symbols): Change API.  Rename from
	find_function_symbol.  Rewrite.
	(decode_all_digits): Change arguments.  Rewrite.
	(decode_dollar): Change arguments.  Use decode_variable.
	(decode_label): Change arguments.  Rewrite.
	(collect_symbols): New function.
	(minsym_found): Change arguments.  Rewrite.
	(check_minsym, search_minsyms_for_name)
	(add_matching_symbols_to_info): New function.
	(decode_variable): Change arguments.  Iterate over all symbols.
	(symbol_found): Remove.
	(symbol_to_sal): New function.
	(init_linespec_result, destroy_linespec_result)
	(cleanup_linespec_result, make_cleanup_destroy_linespec_result):
	New functions.
	(decode_digits_list_mode, decode_digits_ordinary): New functions.
	* dwarf2read.c (dw2_map_expand_apply): New function.
	(dw2_map_symtabs_matching_filename): Rename from
	dw2_lookup_symtab.  Change arguments.
	(dwarf2_gdb_index_functions): Update.
	* dwarf2loc.c: Remove DEF_VEC_I(CORE_ADDR).
	* defs.h (compare_strings): Declare.
	* cli/cli-cmds.c (compare_strings): Move to utils.c.
	(edit_command, list_command): Use DECODE_LINE_LIST_MODE.  Call
	filter_sals.
	(compare_symtabs, filter_sals): New functions.
	* breakpoint.h (struct bp_location) <line_number, source_file>:
	New fields.
	(struct breakpoint) <line_number, source_file>: Remove.
	<filter>: New field.
	* breakpoint.c (print_breakpoint_location, init_raw_breakpoint)
	(momentary_breakpoint_from_master, add_location_to_breakpoint):
	Update for changes to locations.
	(init_breakpoint_sal): Add 'filter' argument.  Set 'filter' on
	breakpoint.
	(create_breakpoint_sal): Add 'filter' argument.
	(remove_sal, expand_line_sal_maybe): Remove.
	(create_breakpoints_sal): Remove 'sals' argument.  Handle
	pre-expanded sals and the filter.
	(parse_breakpoint_sals): Use decode_line_full.
	(check_fast_tracepoint_sals): Use get_sal_arch.
	(create_breakpoint): Create a linespec_sals.  Update.
	(break_range_command): Use decode_line_full.  Update.
	(until_break_command): Update.
	(clear_command): Update match conditions for linespec.c changes.
	Use DECODE_LINE_LIST_MODE.
	(say_where): Update for changes to locations.
	(bp_location_dtor): Free 'source_file'.
	(base_breakpoint_dtor): Free 'filter'.  Don't free 'source_file'.
	(update_static_tracepoint): Update for changes to locations.
	(update_breakpoint_locations): Disable ranged breakpoint if too
	many locations match.  Update.
	(addr_string_to_sals): Use decode_line_full.  Resolve all sal
	PCs.
	(breakpoint_re_set_default): Don't call expand_line_sal_maybe.
	(decode_line_spec_1): Update.  Change argument name to 'flags',
	change interpretation.
	* block.h (block_containing_function): Declare.
	* block.c (block_containing_function): New function.
	* skip.c (skip_function_command): Update.
	(skip_re_set): Update.
	* infcmd.c (jump_command): Use DECODE_LINE_FUNFIRSTLINE.
	* mi/mi-main.c (mi_cmd_trace_find): Use DECODE_LINE_FUNFIRSTLINE.
	* NEWS: Add entry.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* elfread.c (elf_gnu_ifunc_resolver_return_stop): Allow
	breakpoint's pspace to be NULL.
	* breakpoint.h (struct breakpoint) <pspace>: Update comment.
	* breakpoint.c (init_raw_breakpoint): Conditionally set
	breakpoint's pspace.
	(init_breakpoint_sal): Don't set breakpoint's pspace.
	(prepare_re_set_context): Conditionally switch program space.
	(addr_string_to_sals): Check executing_startup on location's
	program space.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* breakpoint.h (enum enable_state) <bp_startup_disabled>: Remove.
	* breakpoint.c (should_be_inserted): Explicitly check if program
	space is executing startup.
	(describe_other_breakpoints): Update.
	(disable_breakpoints_before_startup): Change executing_startup
	earlier.  Remove loop.
	(enable_breakpoints_after_startup): Likewise.
	(init_breakpoint_sal): Don't use bp_startup_disabled.
	(create_breakpoint): Don't use bp_startup_disabled.
	(update_global_location_list): Use should_be_inserted.
	(bkpt_re_set): Update.
gdb/testsuite
2011-12-06  Joel Brobecker  <brobecker@@acacore.com>

        * gdb.ada/fullname_bp.exp: Add tests for other valid linespecs
        involving a fully qualified function name.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.ada/homonym.exp: Add three breakpoint tests.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.base/solib-weak.exp (do_test): Remove kfail.
	* gdb.trace/tracecmd.exp: Disable pending breakpoints earlier.
	* gdb.objc/objcdecode.exp: Update for output changes.
	* gdb.linespec/linespec.exp: New file.
	* gdb.linespec/lspec.cc: New file.
	* gdb.linespec/lspec.h: New file.
	* gdb.linespec/body.h: New file.
	* gdb.linespec/base/two/thefile.cc: New file.
	* gdb.linespec/base/one/thefile.cc: New file.
	* gdb.linespec/Makefile.in: New file.
	* gdb.cp/templates.exp (test_template_breakpoints): Update for
	output changes.
	* gdb.cp/re-set-overloaded.exp: Remove kfail.
	* gdb.cp/ovldbreak.exp: Update for output changes.  "all" test now
	makes one breakpoint.
	* gdb.cp/method2.exp (test_break): Update for output changes.
	* gdb.cp/mb-templates.exp: Update for output changes.
	* gdb.cp/mb-inline.exp: Update for output changes.
	* gdb.cp/mb-ctor.exp: Update for output changes.
	* gdb.cp/ovsrch.exp: Use fully-qualified names.
	* gdb.base/solib-symbol.exp: Run to main later.  Breakpoint now
	has multiple matches.
	* gdb.base/sepdebug.exp: Disable pending breakpoints.  Update for
	error message change.
	* gdb.base/list.exp (test_list_filename_and_number): Update for
	error message change.
	* gdb.base/break.exp: Disable pending breakpoints.  Update for
	output changes.
	* configure.ac: Add gdb.linespec.
	* configure: Rebuild.
	* Makefile.in (ALL_SUBDIRS): Add gdb.linespec.
gdb/doc
2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.texinfo (Set Breaks): Update for new behavior.
@
text
@d3 1
a3 3
   Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2007, 2008, 2009,
   2010, 2011 Free Software Foundation, Inc.
@


1.288.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 3
a5 1
   Copyright (C) 1986-2004, 2007-2012 Free Software Foundation, Inc.
@


1.287
log
@	* NEWS: Mention new parameter basenames-may-differ.
	* dwarf2read.c (dw2_lookup_symtab): Avoid calling gdb_realpath if
	! basenames_may_differ.
	* psymtab.c (lookup_partial_symtab): Ditto.
	* symtab.c (lookup_symtab): Ditto.
	(basenames_may_differ): New global.
	(_initialize_symtab): New parameter basenames-may-differ.
	* symtab.h (basenames_may_differ): Declare.

	doc/
	* gdb.texinfo (Files): Document basenames-may-differ.
@
text
@d84 1
a84 1
static int find_line_common (struct linetable *, int, int *);
d150 10
a159 3
/* Check for a symtab of a specific name; first in symtabs, then in
   psymtabs.  *If* there is no '/' in the name, a match after a '/'
   in the symtab filename will also work.  */
d161 9
a169 2
struct symtab *
lookup_symtab (const char *name)
a170 1
  int found;
a171 3
  struct objfile *objfile;
  char *real_path = NULL;
  char *full_path = NULL;
d175 1
a175 5
  cleanup = make_cleanup (null_cleanup, NULL);

  /* Here we are interested in canonicalizing an absolute path, not
     absolutizing a relative path.  */
  if (IS_ABSOLUTE_PATH (name))
d177 5
a181 17
      full_path = xfullpath (name);
      make_cleanup (xfree, full_path);
      real_path = gdb_realpath (name);
      make_cleanup (xfree, real_path);
    }

got_symtab:

  /* First, search for an exact match.  */

  ALL_SYMTABS (objfile, s)
  {
    if (FILENAME_CMP (name, s->filename) == 0)
      {
	do_cleanups (cleanup);
	return s;
      }
d198 2
a199 2
	    do_cleanups (cleanup);
            return s;
d213 4
a216 4
              {
		do_cleanups (cleanup);
                return s;
              }
d219 1
a219 1
  }
a223 1
    ALL_SYMTABS (objfile, s)
d225 1
a225 1
      if (FILENAME_CMP (lbasename (s->filename), name) == 0)
d227 5
a231 2
	  do_cleanups (cleanup);
	  return s;
d235 42
a279 1
  found = 0;
d283 6
a288 2
	&& objfile->sf->qf->lookup_symtab (objfile, name, full_path, real_path,
					   &s))
d290 2
a291 2
	found = 1;
	break;
d295 21
a315 10
  if (s != NULL)
    {
      do_cleanups (cleanup);
      return s;
    }
  if (!found)
    {
      do_cleanups (cleanup);
      return NULL;
    }
d317 2
a318 9
  /* At this point, we have located the psymtab for this file, but
     the conversion to a symtab has failed.  This usually happens
     when we are looking up an include file.  In this case,
     PSYMTAB_TO_SYMTAB doesn't return a symtab, even though one has
     been created.  So, we need to run through the symtabs again in
     order to find the file.
     XXX - This is a crock, and should be fixed inside of the
     symbol parsing routines.  */
  goto got_symtab;
d320 1
d1055 17
a1071 18
/* Find the definition for a specified symbol name NAME
   in domain DOMAIN, visible from lexical block BLOCK.
   Returns the struct symbol pointer, or zero if no symbol is found.
   C++: if IS_A_FIELD_OF_THIS is nonzero on entry, check to see if
   NAME is a field of the current implied argument `this'.  If so set
   *IS_A_FIELD_OF_THIS to 1, otherwise set it to zero.
   BLOCK_FOUND is set to the block in which NAME is found (in the case of
   a field of `this', value_of_this sets BLOCK_FOUND to the proper value.)  */

/* This function has a bunch of loops in it and it would seem to be
   attractive to put in some QUIT's (though I'm not really sure
   whether it can run long enough to be really important).  But there
   are a few calls for which it would appear to be bad news to quit
   out of here: find_proc_desc in alpha-tdep.c and mips-tdep.c.  (Note
   that there is C++ code below which can error(), but that probably
   doesn't affect these calls since they are looking for a known
   variable and thus can probably assume it will never hit the C++
   code).  */
d1073 3
a1075 4
struct symbol *
lookup_symbol_in_language (const char *name, const struct block *block,
			   const domain_enum domain, enum language lang,
			   int *is_a_field_of_this)
a1078 1
  struct symbol *returnval;
d1125 32
d1849 38
d2312 1
a2312 1
  best_index = find_line_common (best_linetable, line, &exact);
d2357 1
a2357 1
	ind = find_line_common (l, line, &exact);
d2388 40
d2496 1
d2502 1
a2502 1
		  int *exact_match)
d2522 1
a2522 1
  for (i = 0; i < len; i++)
d3169 2
a3170 1
search_symbols_name_matches (const char *symname, void *user_data)
d3978 2
a3979 1
expand_partial_symbol_name (const char *name, void *user_data)
d4677 1
a4677 1
decode_line_spec (char *string, int funfirstline)
d4689 2
a4690 3
  sals = decode_line_1 (&string, funfirstline,
			cursal.symtab, cursal.line,
			NULL);
a4777 205
/* Helper to expand_line_sal below.  Appends new sal to SAL,
   initializing it from SYMTAB, LINENO and PC.  */
static void
append_expanded_sal (struct symtabs_and_lines *sal,
		     struct program_space *pspace,
		     struct symtab *symtab,
		     int lineno, CORE_ADDR pc)
{
  sal->sals = xrealloc (sal->sals,
			sizeof (sal->sals[0])
			* (sal->nelts + 1));
  init_sal (sal->sals + sal->nelts);
  sal->sals[sal->nelts].pspace = pspace;
  sal->sals[sal->nelts].symtab = symtab;
  sal->sals[sal->nelts].section = NULL;
  sal->sals[sal->nelts].end = 0;
  sal->sals[sal->nelts].line = lineno;
  sal->sals[sal->nelts].pc = pc;
  ++sal->nelts;
}

/* Helper to expand_line_sal below.  Search in the symtabs for any
   linetable entry that exactly matches FULLNAME and LINENO and append
   them to RET.  If FULLNAME is NULL or if a symtab has no full name,
   use FILENAME and LINENO instead.  If there is at least one match,
   return 1; otherwise, return 0, and return the best choice in BEST_ITEM
   and BEST_SYMTAB.  */

static int
append_exact_match_to_sals (char *filename, char *fullname, int lineno,
			    struct symtabs_and_lines *ret,
			    struct linetable_entry **best_item,
			    struct symtab **best_symtab)
{
  struct program_space *pspace;
  struct objfile *objfile;
  struct symtab *symtab;
  int exact = 0;
  int j;
  *best_item = 0;
  *best_symtab = 0;

  ALL_PSPACES (pspace)
    ALL_PSPACE_SYMTABS (pspace, objfile, symtab)
    {
      if (FILENAME_CMP (filename, symtab->filename) == 0)
	{
	  struct linetable *l;
	  int len;

	  if (fullname != NULL
	      && symtab_to_fullname (symtab) != NULL
    	      && FILENAME_CMP (fullname, symtab->fullname) != 0)
    	    continue;		  
	  l = LINETABLE (symtab);
	  if (!l)
	    continue;
	  len = l->nitems;

	  for (j = 0; j < len; j++)
	    {
	      struct linetable_entry *item = &(l->item[j]);

	      if (item->line == lineno)
		{
		  exact = 1;
		  append_expanded_sal (ret, objfile->pspace,
				       symtab, lineno, item->pc);
		}
	      else if (!exact && item->line > lineno
		       && (*best_item == NULL
			   || item->line < (*best_item)->line))
		{
		  *best_item = item;
		  *best_symtab = symtab;
		}
	    }
	}
    }
  return exact;
}

/* Compute a set of all sals in all program spaces that correspond to
   same file and line as SAL and return those.  If there are several
   sals that belong to the same block, only one sal for the block is
   included in results.  */

struct symtabs_and_lines
expand_line_sal (struct symtab_and_line sal)
{
  struct symtabs_and_lines ret;
  int i, j;
  struct objfile *objfile;
  int lineno;
  int deleted = 0;
  struct block **blocks = NULL;
  int *filter;
  struct cleanup *old_chain;

  ret.nelts = 0;
  ret.sals = NULL;

  /* Only expand sals that represent file.c:line.  */
  if (sal.symtab == NULL || sal.line == 0 || sal.pc != 0)
    {
      ret.sals = xmalloc (sizeof (struct symtab_and_line));
      ret.sals[0] = sal;
      ret.nelts = 1;
      return ret;
    }
  else
    {
      struct program_space *pspace;
      struct linetable_entry *best_item = 0;
      struct symtab *best_symtab = 0;
      int exact = 0;
      char *match_filename;

      lineno = sal.line;
      match_filename = sal.symtab->filename;

      /* We need to find all symtabs for a file which name
	 is described by sal.  We cannot just directly
	 iterate over symtabs, since a symtab might not be
	 yet created.  We also cannot iterate over psymtabs,
	 calling PSYMTAB_TO_SYMTAB and working on that symtab,
	 since PSYMTAB_TO_SYMTAB will return NULL for psymtab
	 corresponding to an included file.  Therefore, we do
	 first pass over psymtabs, reading in those with
	 the right name.  Then, we iterate over symtabs, knowing
	 that all symtabs we're interested in are loaded.  */

      old_chain = save_current_program_space ();
      ALL_PSPACES (pspace)
      {
	set_current_program_space (pspace);
	ALL_PSPACE_OBJFILES (pspace, objfile)
	{
	  if (objfile->sf)
	    objfile->sf->qf->expand_symtabs_with_filename (objfile,
							   sal.symtab->filename);
	}
      }
      do_cleanups (old_chain);

      /* Now search the symtab for exact matches and append them.  If
	 none is found, append the best_item and all its exact
	 matches.  */
      symtab_to_fullname (sal.symtab);
      exact = append_exact_match_to_sals (sal.symtab->filename,
					  sal.symtab->fullname, lineno,
					  &ret, &best_item, &best_symtab);
      if (!exact && best_item)
	append_exact_match_to_sals (best_symtab->filename,
				    best_symtab->fullname, best_item->line,
				    &ret, &best_item, &best_symtab);
    }

  /* For optimized code, compiler can scatter one source line accross
     disjoint ranges of PC values, even when no duplicate functions
     or inline functions are involved.  For example, 'for (;;)' inside
     non-template non-inline non-ctor-or-dtor function can result
     in two PC ranges.  In this case, we don't want to set breakpoint
     on first PC of each range.  To filter such cases, we use containing
     blocks -- for each PC found above we see if there are other PCs
     that are in the same block.  If yes, the other PCs are filtered out.  */

  old_chain = save_current_program_space ();
  filter = alloca (ret.nelts * sizeof (int));
  blocks = alloca (ret.nelts * sizeof (struct block *));
  for (i = 0; i < ret.nelts; ++i)
    {
      set_current_program_space (ret.sals[i].pspace);

      filter[i] = 1;
      blocks[i] = block_for_pc_sect (ret.sals[i].pc, ret.sals[i].section);
    }
  do_cleanups (old_chain);

  for (i = 0; i < ret.nelts; ++i)
    if (blocks[i] != NULL)
      for (j = i+1; j < ret.nelts; ++j)
	if (blocks[j] == blocks[i])
	  {
	    filter[j] = 0;
	    ++deleted;
	    break;
	  }

  {
    struct symtab_and_line *final =
      xmalloc (sizeof (struct symtab_and_line) * (ret.nelts-deleted));

    for (i = 0, j = 0; i < ret.nelts; ++i)
      if (filter[i])
	final[j++] = ret.sals[i];

    ret.nelts -= deleted;
    xfree (ret.sals);
    ret.sals = final;
  }

  return ret;
}

@


1.286
log
@	* dwarf2read.c (dw2_map_symbol_filenames): New parameter
	`need_fullname'.
	* psymtab.c (map_symbol_filenames_psymtab): Ditto.
	(map_partial_symbol_filenames): Ditto.  All callers updated.
	* psymtab.h (map_partial_symbol_filenames): Update prototype.
	* symfile.h (struct quick_symbol_functions, map_symbol_filenames): New
	parameter need_fullname.
@
text
@d115 5
d163 1
d189 6
d4900 14
@


1.285
log
@gdb/
	Code cleanup.
	* symtab.c (skip_prologue_sal): Code reformatting.
@
text
@d2884 2
a2885 1
  map_partial_symbol_filenames (output_partial_symbol_filename, &first);
d4318 2
a4319 1
  map_partial_symbol_filenames (maybe_add_partial_symtab_filename, &datum);
@


1.284
log
@11-10-28  Sterling Augustine  <saugustine@@google.com>

	* psymtab.c (map_symbol_filenames_psymtab): Call QUIT.
	* symtab.c (free_completion_list): New function.
	(do_free_completion_list): Likewise.
	(default_make_symbol_completion_list_break_on): New variable
	back_to. Call make_cleanup and discard_cleanups.
	(make_source_files_completion_list): Likewise.
@
text
@d2552 2
a2553 2
	  && (sym? (BLOCK_START (SYMBOL_BLOCK_VALUE (sym)) <= start_sal.end
		    && start_sal.end < BLOCK_END (SYMBOL_BLOCK_VALUE (sym)))
@


1.283
log
@PR macros/12999
* macrotab.h (macro_callback_fn): Add new arguments to callback.
* macrotab.c (foreach_macro): Ditto.
(foreach_macro_in_scope): Ditto.
* macrocmd.c (print_macro_callback): New function.
(info_macro_command): Move some code to print_macro_definition.
(print_macro_definition): New function.
(print_one_macro): Add new arguments to callback.

testsuite/
* gdb.base/info-macros.c: New test sources.
* gdb.base/info-macros.exp: New tests.

docs/
* gdb.texinfo (Macros): Add info definitions and info macros commands.
Update text and cindex entries for info macro command.
@
text
@d3576 24
d3837 1
d3914 1
d4024 1
d4274 1
d4281 2
d4318 1
@


1.282
log
@	* symtab.c (operator_chars): Now static.
	* linespec.c (operator_chars): Don't declare.
@
text
@d3774 1
@


1.281
log
@	* symtab.c (in_prologue): Remove mention of ppc's refine_prologue_limit.
@
text
@a85 4
/* This one is used by linespec.c */

char *operator_chars (char *p, char **end);

d2636 1
a2636 1
char *
@


1.280
log
@	* symtab.c (expand_line_sal): Remove empty line.
@
text
@d4382 2
a4383 2
   This code is based on the function refine_prologue_limit (versions
   found in both ia64 and ppc).  */
@


1.279
log
@	* breakpoint.c: Fix typos in comments.
	* linespec.c: Likewise.
	* symtab.c: Likewise.
@
text
@a4756 1

@


1.278
log
@gdb/
	* symtab.c (symbol_find_demangled_name): Likewise.

gdb/testsuite/
	* gdb.cp/no-dmgl-verbose.cc: New file.
	* gdb.cp/no-dmgl-verbose.exp: New file.
@
text
@d4400 1
a4400 1
      /* For langauges other than assembly, treat two consecutive line
@


1.277
log
@	* symtab.c (lookup_language_this): End loop if block is NULL.
@
text
@d503 1
a503 1
        cplus_demangle (mangled, DMGL_PARAMS | DMGL_ANSI | DMGL_VERBOSE);
@


1.276
log
@	* valops.c (value_of_this): Use lookup_language_this.
	* symtab.h (lookup_language_this): Declare.
	* symtab.c (lookup_language_this): New function.
	(lookup_symbol_aux): Use lookup_language_this.
	* ax-gdb.c (gen_expr) <OP_THIS>: Use lookup_language_this.
@
text
@d1103 1
a1103 1
  while (1)
d1111 1
a1111 1
	return NULL;
d1114 2
@


1.275
log
@gdb/
	* symtab.c (output_partial_symbol_filename): Exchange the filename and
	fullname parameters order.

gdb/testsuite/
	* gdb.dwarf2/dw2-filename.exp (info sources): New testcase.
@
text
@d1093 23
d1149 1
a1149 2
  if (langdef->la_name_of_this != NULL && is_a_field_of_this != NULL
      && block != NULL)
d1151 1
a1151 2
      struct symbol *sym = NULL;
      const struct block *function_block = block;
a1152 8
      /* 'this' is only defined in the function's block, so find the
	 enclosing function block.  */
      for (; function_block && !BLOCK_FUNCTION (function_block);
	   function_block = BLOCK_SUPERBLOCK (function_block));

      if (function_block && !dict_empty (BLOCK_DICT (function_block)))
	sym = lookup_block_symbol (function_block, langdef->la_name_of_this,
				   VAR_DOMAIN);
@


1.274
log
@	* value.c (value_fn_field): Constify.
	* symtab.c (gdb_mangle_name): Constify.
	* stabsread.c (update_method_name_from_physname): Make 'physname'
	argument const.
	* p-typeprint.c (pascal_type_print_method_args): Make arguments
	const.  Use explicit fputc_filtered loop.
	(pascal_type_print_base): Constify.
	* p-lang.h (pascal_type_print_method_args): Update.
	* linespec.c (add_matching_methods): Constify.
	(add_constructors): Likewise.
	* jv-typeprint.c (java_type_print_base): Constify.
	* gdbtypes.h (struct cplus_struct_type)
	<fn_fieldlist.fn_field.physname>: Now const.
	* dwarf2read.c (compute_delayed_physnames): Constify.
	(dwarf2_add_member_fn): Likewise.
	* c-typeprint.c (c_type_print_base): Constify.  Use cleanups.
@
text
@d2840 1
a2840 1
output_partial_symbol_filename (const char *fullname, const char *filename,
@


1.273
log
@	* symtab.c (lookup_symtab): Run cleanup before returning.
@
text
@d281 1
a281 1
  char *physname = TYPE_FN_FIELD_PHYSNAME (f, signature_id);
@


1.272
log
@gdb/
	PR 12573
	* dwarf2read.c (struct dwarf2_cu): New field has_loclist.
	(producer_is_gcc_ge_4_0): New function.
	(process_full_comp_unit): Set also symtab->locations_valid.  Move the
	symtab->language code.
	(var_decode_location): Set cu->has_loclist.
	* symtab.c (skip_prologue_sal): New variables saved_pc, force_skip and
	skip.  Intialize force_skip from locations_valid.  Move the prologue
	skipping code into two passes.
	* symtab.h (struct symtab): Make the primary field a bitfield.  New
	field locations_valid.

gdb/testsuite/
	PR 12573
	* gdb.dwarf2/dw2-skip-prologue.S: New file.
	* gdb.dwarf2/dw2-skip-prologue.c: New file.
	* gdb.dwarf2/dw2-skip-prologue.exp: New file.
@
text
@d161 3
d183 1
d196 1
d212 1
d225 4
a228 1
	return s;
d247 4
a250 1
    return s;
d252 4
a255 1
    return NULL;
@


1.271
log
@gdb/
	* symtab.c (compare_symbol_name): New function.
	(completion_list_add_name, expand_partial_symbol_name): Call it,
	remove the variable ncmp.
	(default_make_symbol_completion_list_break_on): Reduce SYM_TEXT_LEN,
	gdb_assert it.

gdb/testsuite/
	* gdb.cp/psymtab-parameter.cc: New file.
	* gdb.cp/psymtab-parameter.exp: New file.
@
text
@d2444 1
a2444 1
  CORE_ADDR pc;
d2450 1
d2488 33
a2520 26
  /* If the function is in an unmapped overlay, use its unmapped LMA address,
     so that gdbarch_skip_prologue has something unique to work on.  */
  if (section_is_overlay (section) && !section_is_mapped (section))
    pc = overlay_unmapped_address (pc, section);

  /* Skip "first line" of function (which is actually its prologue).  */
  pc += gdbarch_deprecated_function_start_offset (gdbarch);
  pc = gdbarch_skip_prologue (gdbarch, pc);

  /* For overlays, map pc back into its mapped VMA range.  */
  pc = overlay_mapped_address (pc, section);

  /* Calculate line number.  */
  start_sal = find_pc_sect_line (pc, section, 0);

  /* Check if gdbarch_skip_prologue left us in mid-line, and the next
     line is still part of the same function.  */
  if (start_sal.pc != pc
      && (sym? (BLOCK_START (SYMBOL_BLOCK_VALUE (sym)) <= start_sal.end
	        && start_sal.end < BLOCK_END (SYMBOL_BLOCK_VALUE (sym)))
          : (lookup_minimal_symbol_by_pc_section (start_sal.end, section)
             == lookup_minimal_symbol_by_pc_section (pc, section))))
    {
      /* First pc of next line */
      pc = start_sal.end;
      /* Recalculate the line number (might not be N+1).  */
a2521 1
    }
d2523 26
a2548 10
  /* On targets with executable formats that don't have a concept of
     constructors (ELF with .init has, PE doesn't), gcc emits a call
     to `__main' in `main' between the prologue and before user
     code.  */
  if (gdbarch_skip_main_prologue_p (gdbarch)
      && name && strcmp (name, "main") == 0)
    {
      pc = gdbarch_skip_main_prologue (gdbarch, pc);
      /* Recalculate the line number (might not be N+1).  */
      start_sal = find_pc_sect_line (pc, section, 0);
d2550 1
d2560 1
a2560 1
  if (sym && start_sal.symtab == NULL)
@


1.270
log
@gdb/
	* symtab.c (expand_partial_symbol_name): New variable NCMP.  Support
	case insensitive comparison.
@
text
@d3492 34
a3544 3
  int (*ncmp) (const char *, const char *, size_t);

  ncmp = (case_sensitivity == case_sensitive_on ? strncmp : strncasecmp);
d3547 2
a3548 5

  if (ncmp (symname, sym_text, sym_text_len) != 0)
    {
      return;
    }
a3737 1
  int (*ncmp) (const char *, const char *, size_t);
d3739 1
a3739 3
  ncmp = (case_sensitivity == case_sensitive_on ? strncmp : strncasecmp);

  return ncmp (name, datum->sym_text, datum->sym_text_len) == 0;
d3818 16
@


1.269
log
@gdb/doc/
	* gdb.texinfo (Index Section Format): Change the version to 5.
	Describe the different formula.

gdb/
	Case insensitive lookups implementation.
	* dwarf2read.c: Include ctype.h.
	(struct mapped_index): New field version.
	(mapped_index_string_hash): New parameter index_version.  New comment
	for it.  Call tolower appropriately.
	(find_slot_in_mapped_hash): New variable cmp, initialize it, use it.
	Choose the right index version for mapped_index_string_hash.
	(dwarf2_read_index): Support also the index version 5.  Initialize the
	new struct mapped_index field version.
	(hash_strtab_entry): Pass INT_MAX for the new parameter, explain why.
	(find_slot): Explain the version needs.  Pass INT_MAX for the new
	parameter.
	(write_psymtabs_to_index): Produce version 5.
	* minsyms.c (lookup_minimal_symbol): New variable cmp, initialize it,
	use it.  New comment for SYMBOL_MATCHES_SEARCH_NAME.
	* psymtab.c (lookup_partial_symbol): Find the
	SYMBOL_MATCHES_SEARCH_NAME start of the found block of matching
	entries.
	* symtab.c (lookup_symbol_in_language): Remove the case_sensitive_off
	NAME lowercasing.
	(search_symbols): Pass REG_ICASE to regcomp for case_sensitive_off.
	(completion_list_add_name): New variable ncmp, initialize it, use it.
	* symtab.h (SYMBOL_HASH_NEXT): Always call tolower.
	* utils.c (strcmp_iw): Support case_sensitive_off.
	(strcmp_iw_ordered): Sort in a way compatible with case_sensitive_off.
	New function comment part.  New variables saved_string1,
	saved_string2 and case_pass.  Add a proper second pass.

gdb/testsuite/
	* gdb.base/fortran-sym-case.c: New file.
	* gdb.base/fortran-sym-case.exp: New file.
	* gdb.dwarf2/dw2-case-insensitive-debug.S: New file.
	* gdb.dwarf2/dw2-case-insensitive.c: New file.
	* gdb.dwarf2/dw2-case-insensitive.exp: New file.
@
text
@d3710 1
d3712 3
a3714 1
  return strncmp (name, datum->sym_text, datum->sym_text_len) == 0;
@


1.268
log
@gdb/
	Replace re_comp/re_exec by regcomp/regexec.
	* symtab.c (struct search_symbols_data): New fields preg, preg_p.
	(search_symbols_name_matches): Use them, use regexec.
	(search_symbols): New variable retval_chain, adjust the use of
	old_chain against it.  Replace re_comp by regcomp.  Use the new struct
	search_symbols_data fields, use regexec instead of re_exec.
@
text
@a1058 13
  if (case_sensitivity == case_sensitive_off)
    {
      char *copy;
      int len, i;

      len = strlen (name);
      copy = (char *) alloca (len + 1);
      for (i= 0; i < len; i++)
        copy[i] = tolower (name[i]);
      copy[len] = 0;
      modified_name = copy;
    }

d3059 3
a3061 1
      errcode = regcomp (&datum.preg, regexp, REG_NOSUB);
d3511 3
d3517 1
a3517 1
  if (strncmp (symname, sym_text, sym_text_len) != 0)
@


1.267
log
@gdb/
	* ada-lang.c (struct add_partial_datum): Update the comment for
	expand_partial_symbol_name.
	(ada_add_partial_symbol_completions): Rename to ...
	(ada_expand_partial_symbol_name): ... here, change return type, update
	function comment, call symbol_completion_match instead of
	symbol_completion_add.
	(ada_make_symbol_completion_list): Use now expand_partial_symbol_names
	and ada_expand_partial_symbol_name.
	* dwarf2read.c (dw2_expand_symtabs_matching): Support NULL
	FILE_MATCHER.
	(dw2_map_symbol_names): Remove.
	(dwarf2_gdb_index_functions): Unlist dw2_map_symbol_names.
	* psymtab.c (map_symbol_names_psymtab): Remove.
	(expand_symtabs_matching_via_partial): Support NULL FILE_MATCHER.
	Support KIND == ALL_DOMAIN.  Exchange the NAME_MATCHER and KIND check
	order.
	(psym_functions): Unlist map_symbol_names_psymtab.
	(map_partial_symbol_names): Rename to ...
	(expand_partial_symbol_names): ... here, change the FUN type, call
	expand_symtabs_matching with ALL_DOMAIN and NULL FILE_MATCHER now.
	* psymtab.h (map_partial_symbol_names): Rename to ...
	(expand_partial_symbol_names): ... here, change the FUN type.
	* symfile.h (struct quick_symbol_functions): Update the description of
	expand_symtabs_matching.  Remove map_symbol_names.
	* symtab.c (search_symbols): Add ALL_DOMAIN to the function comment.
	(struct add_name_data): Update the comment for
	expand_partial_symbol_name.
	(add_partial_symbol_name): Rename to ...
	(expand_partial_symbol_name): ... here.  Replace
	completion_list_add_name call by strncmp.
	(default_make_symbol_completion_list_break_on): Use now
	expand_partial_symbol_names and expand_partial_symbol_name.
	* symtab.h (enum search_domain): New element ALL_DOMAIN.

gdb/testsuite/
	* gdb.cp/cpcompletion.exp (complete class methods)
	(complete class methods beginning with F): Move them above runto.  New
	comment about the runto delimiter.
@
text
@d2948 4
a2951 1
  char *regexp;
d2969 1
a2969 1
  return data->regexp == NULL || re_exec (symname);
a3016 1
  struct cleanup *old_chain = NULL;
d3019 5
d3033 1
d3043 1
d3072 10
a3081 2
      if (0 != (val = re_comp (regexp)))
	error (_("Invalid regexp (%s): %s"), val, regexp);
a3089 1
  datum.regexp = regexp;
d3100 2
d3125 3
a3127 2
	    if (regexp == NULL
		|| re_exec (SYMBOL_NATURAL_NAME (msymbol)) != 0)
d3165 3
a3167 2
		  && ((regexp == NULL
		       || re_exec (SYMBOL_NATURAL_NAME (sym)) != 0)
d3209 1
a3209 1
		  old_chain = make_cleanup_free_search_symbols (sr);
d3231 3
a3233 2
	    if (regexp == NULL
		|| re_exec (SYMBOL_NATURAL_NAME (msymbol)) != 0)
d3255 1
a3255 1
			    old_chain = make_cleanup_free_search_symbols (sr);
d3267 2
a3269 2
  if (sr != NULL)
    discard_cleanups (old_chain);
@


1.266
log
@gdb
	* windows-tdep.c (windows_xfer_shared_library):
	* windows-nat.c (get_module_name, windows_make_so):
	* v850-tdep.c (v850_handle_pushm):
	* utils.c (null_cleanup, gdb_realpath):
	* ui-out.c (get_next_header):
	* tracepoint.c (clear_traceframe_info):
	* symtab.c (lookup_symtab):
	* serial.h (struct serial_ops):
	* mipsread.c (read_alphacoff_dynamic_symtab):
	* infcmd.c (print_return_value):
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address):
	* f-exp.y (parse_number):
	* exceptions.c (catch_exceptions):
	* dummy-frame.c (dummy_frame_this_id):
	* defs.h (struct cleanup):
	* breakpoint.c (disable_breakpoints_in_unloaded_shlib):
	* arm-tdep.c (arm_push_dummy_call):
	* amd64-tdep.h (amd64_collect_xsave):
	* amd64-tdep.c (amd64_collect_xsave):
	* alpha-tdep.c (alpha_heuristic_frame_unwind_cache):
	* README (typing): Remove duplicate words.
	* cli/cli-decode.c (lookup_cmd_composition): Add comma.
	* infrun.c (siginfo_value_read): Fix typo.
	* solib-frv.c (frv_fdpic_find_global_pointer): Likewise.
	* top.c (source_line_number): Add comma.
gdb/doc
	* gdbint.texinfo (Register Information Functions): Remove
	duplicate "the".
	* gdb.texinfo (Emacs): Remove duplicate "to".
	(GDB/MI Variable Objects): Remove duplicate "the".
	(General Query Packets): Likewise.
gdb/testsuite
	* gdb.mi/mi-nsmoribund.exp:
	* gdb.hp/gdb.objdbg/objdbg01.exp:
	* gdb.base/structs.exp (test_struct_returns):
	* gdb.base/call-sc.exp (test_scalar_returns):
	* gdb.base/bigcore.exp: Remove duplicate words.
gdb/gdbserver
	* win32-low.c (handle_load_dll): Remove duplicate "the".
@
text
@d2977 1
d3669 1
a3669 1
   add_partial_symbol_name.  The contents are simply whatever is
d3692 3
a3694 3
/* A callback for map_partial_symbol_names.  */
static void
add_partial_symbol_name (const char *name, void *user_data)
d3698 1
a3698 3
  completion_list_add_name ((char *) name,
			    datum->sym_text, datum->sym_text_len,
			    datum->text, datum->word);
d3788 3
a3790 2
     by matching SYM_TEXT.  Add each one that you find to the list.  */
  map_partial_symbol_names (add_partial_symbol_name, &datum);
@


1.265
log
@gdb/
	Code cleanup.
	* symtab.c (search_symbols): Reorder the KIND description in the
	function comment.  Remove the unused 4th element of types, types2,
	types3 and types4.  New gdb_assert on KIND.
	(symtab_symbol_info): Remove the unused 4th element of classnames.
	New gdb_assert on KIND.
	* symtab.h (enum search_domain): New warning in the enum comment.
	Assign numbers to the elements VARIABLES_DOMAIN, FUNCTIONS_DOMAIN and
	TYPES_DOMAIN.
@
text
@d248 1
a248 1
     XXX - This is a crock, and should be fixed inside of the the
@


1.264
log
@	* tracepoint.c (scope_info): Update.
	* symtab.c (decode_line_spec): Update.
	* python/python.c (gdbpy_decode_line): Update.
	* linespec.h (decode_line_1): Update.
	* linespec.c (decode_line_1): Remove 'not_found_ptr' argument.
	(decode_compound, find_method, symtab_from_filename)
	(decode_variable): Likewise.
	* cli/cli-cmds.c (edit_command): Update.
	(list_command): Update.
	* breakpoint.c (parse_breakpoint_sals): Remove 'not_found_ptr'
	argument.
	(create_breakpoint): Update.
	(until_break_command): Update.
	(addr_string_to_sals): Update.
	(decode_line_spec_1): Update.
@
text
@d2973 2
a2976 2
   VARIABLES_DOMAIN - search all symbols, excluding functions, type names,
   and constants (enums)
d2999 1
a2999 1
    = {mst_data, mst_text, mst_abs, mst_unknown};
d3001 1
a3001 1
    = {mst_bss, mst_file_text, mst_abs, mst_unknown};
d3003 1
a3003 1
    = {mst_file_data, mst_solib_trampoline, mst_abs, mst_unknown};
d3005 1
a3005 1
    = {mst_file_bss, mst_text_gnu_ifunc, mst_abs, mst_unknown};
d3016 2
d3316 1
a3316 1
    {"variable", "function", "type", "method"};
d3323 2
@


1.263
log
@	* symtab.h (domain_enum): Split in two...
	(enum search_domain): New.
	(search_symbols): Update.
	* symtab.c (print_symbol_info, symtab_symbol_info): Remove
	redundant declarations.
	(search_symbols): Change 'kind' argument to search_domain.
	Update.
	(print_symbol_info): Likewise.
	(symtab_symbol_info): Likewise.
	* symfile.h (struct quick_symbol_functions)
	<pre_expand_symtabs_matching>: Change type of 'kind' argument.
	<expand_symtabs_matching>: Likewise.
	* psymtab.c (pre_expand_symtabs_matching_psymtabs): Update.
	(expand_symtabs_matching_via_partial): Update.
	* dwarf2read.c (dw2_pre_expand_symtabs_matching): Update.
	(dw2_expand_symtabs_for_function): Update.
	* block.h: Moved anonymous enum...
	* defs.h (enum block_enum): ... here.  Now named.
@
text
@d4378 1
a4378 1
			NULL, NULL);
@


1.262
log
@gdb/
	GDB internal type support for STT_GNU_IFUNC.
	* elfread.c (record_minimal_symbol): Support mst_text_gnu_ifunc.
	(elf_symtab_read): Set mst_text_gnu_ifunc for
	BSF_GNU_INDIRECT_FUNCTION.
	* eval.c (evaluate_subexp_standard): Support TYPE_GNU_IFUNC.
	* gdbtypes.c (init_type): Support TYPE_FLAG_GNU_IFUNC,
	builtin_func_func, nodebug_text_gnu_ifunc_symbol and
	nodebug_got_plt_symbol.
	* gdbtypes.h (enum type_flag_value): New entry TYPE_FLAG_GNU_IFUNC.
	(TYPE_GNU_IFUNC): New.
	(struct main_type): New field flag_gnu_ifunc.
	(struct builtin_type): New field builtin_func_func.
	(struct objfile_type): New fields nodebug_text_gnu_ifunc_symbol and
	nodebug_got_plt_symbol.
	* minsyms.c (lookup_minimal_symbol_text): Support mst_text_gnu_ifunc.
	(in_gnu_ifunc_stub): New.
	(prim_record_minimal_symbol, find_solib_trampoline_target): Support
	mst_text_gnu_ifunc.
	* parse.c (write_exp_msymbol): New variable ifunc_msym.  Detect and
	support mst_text_gnu_ifunc.  Support mst_slot_got_plt.
	* solib-svr4.c (svr4_in_dynsym_resolve_code): Return true also for
	in_gnu_ifunc_stub.
	* symmisc.c (dump_msymbols): Support mst_text_gnu_ifunc.
	* symtab.c (search_symbols): Likewise.
	* symtab.h (enum minimal_symbol_type): New fields mst_text_gnu_ifunc
	and mst_slot_got_plt.
	(in_gnu_ifunc_stub): New declaration.
@
text
@a112 3
static void print_symbol_info (domain_enum,
			       struct symtab *, struct symbol *, int, char *);

a114 2
static void symtab_symbol_info (char *, domain_enum, int);

d2984 2
a2985 1
search_symbols (char *regexp, domain_enum kind, int nfiles, char *files[],
d3016 4
a3019 7
  if (kind < VARIABLES_DOMAIN)
    error (_("must search on specific domain"));

  ourtype = types[(int) (kind - VARIABLES_DOMAIN)];
  ourtype2 = types2[(int) (kind - VARIABLES_DOMAIN)];
  ourtype3 = types3[(int) (kind - VARIABLES_DOMAIN)];
  ourtype4 = types4[(int) (kind - VARIABLES_DOMAIN)];
d3253 2
a3254 1
print_symbol_info (domain_enum kind, struct symtab *s, struct symbol *sym,
d3311 1
a3311 1
symtab_symbol_info (char *regexp, domain_enum kind, int from_tty)
d3328 1
a3328 1
		   classnames[(int) (kind - VARIABLES_DOMAIN)], regexp);
@


1.262.2.1
log
@gdb/
	* ada-lang.c (struct add_partial_datum): Update the comment for
	expand_partial_symbol_name.
	(ada_add_partial_symbol_completions): Rename to ...
	(ada_expand_partial_symbol_name): ... here, change return type, update
	function comment, call symbol_completion_match instead of
	symbol_completion_add.
	(ada_make_symbol_completion_list): Use now expand_partial_symbol_names
	and ada_expand_partial_symbol_name.
	* dwarf2read.c (dw2_expand_symtabs_matching): Support NULL
	FILE_MATCHER.
	(dw2_map_symbol_names): Remove.
	(dwarf2_gdb_index_functions): Unlist dw2_map_symbol_names.
	* psymtab.c (map_symbol_names_psymtab): Remove.
	(expand_symtabs_matching_via_partial): Support NULL FILE_MATCHER.
	Support KIND == ALL_DOMAIN.  Exchange the NAME_MATCHER and KIND check
	order.
	(psym_functions): Unlist map_symbol_names_psymtab.
	(map_partial_symbol_names): Rename to ...
	(expand_partial_symbol_names): ... here, change the FUN type, call
	expand_symtabs_matching with ALL_DOMAIN and NULL FILE_MATCHER now.
	* psymtab.h (map_partial_symbol_names): Rename to ...
	(expand_partial_symbol_names): ... here, change the FUN type.
	* symfile.h (struct quick_symbol_functions): Update the description of
	expand_symtabs_matching.  Remove map_symbol_names.
	* symtab.c (search_symbols): Add ALL_DOMAIN to the function comment.
	(struct add_name_data): Update the comment for
	expand_partial_symbol_name.
	(add_partial_symbol_name): Rename to ...
	(expand_partial_symbol_name): ... here.  Replace
	completion_list_add_name call by strncmp.
	(default_make_symbol_completion_list_break_on): Use now
	expand_partial_symbol_names and expand_partial_symbol_name.
	* symtab.h (enum search_domain): New element ALL_DOMAIN.

gdb/testsuite/
	* gdb.cp/cpcompletion.exp (complete class methods)
	(complete class methods beginning with F): Move them above runto.  New
	comment about the runto delimiter.
@
text
@a2981 1
   ALL_DOMAIN       - an internal error for this function
d3020 1
a3020 1
  if (kind < VARIABLES_DOMAIN || kind >= ALL_DOMAIN)
d3670 1
a3670 1
   expand_partial_symbol_name.  The contents are simply whatever is
d3693 3
a3695 3
/* A callback for expand_partial_symbol_names.  */
static int
expand_partial_symbol_name (const char *name, void *user_data)
d3699 3
a3701 1
  return strncmp (name, datum->sym_text, datum->sym_text_len) == 0;
d3791 2
a3792 3
     by matching SYM_TEXT.  Expand all CUs that you find to the list.
     The real names will get added by COMPLETION_LIST_ADD_SYMBOL below.  */
  expand_partial_symbol_names (expand_partial_symbol_name, &datum);
@


1.262.2.2
log
@gdb/
	* symtab.c (compare_symbol_name): New function.
	(completion_list_add_name, expand_partial_symbol_name): Call it,
	remove the variable ncmp.
	(default_make_symbol_completion_list_break_on): Reduce SYM_TEXT_LEN,
	gdb_assert it.

gdb/testsuite/
	* gdb.cp/psymtab-parameter.cc: New file.
	* gdb.cp/psymtab-parameter.exp: New file.
@
text
@a3483 30
/* Evaluate if NAME matches SYM_TEXT and SYM_TEXT_LEN.

   Either sym_text[sym_text_len] != '(' and then we search for any
   symbol starting with SYM_TEXT text.

   Otherwise sym_text[sym_text_len] == '(' and then we require symbol name to
   be terminated at that point.  Partial symbol tables do not have parameters
   information.  */

static int
compare_symbol_name (const char *name, const char *sym_text, int sym_text_len)
{
  if (strncmp (name, sym_text, sym_text_len) != 0)
    return 0;

  if (sym_text[sym_text_len] == '(')
    {
      /* User searches for `name(someth...'.  Require NAME to be terminated.
	 Normally psymtabs and gdbindex have no parameter types so '\0' will be
	 present but accept even parameters presence.  In this case this
	 function is in fact strcmp_iw but whitespace skipping is not supported
	 for tab completion.  */

      if (name[sym_text_len] != '\0' && name[sym_text_len] != '(')
	return 0;
    }

  return 1;
}

d3505 5
a3509 2
  if (!compare_symbol_name (symname, sym_text, sym_text_len))
    return;
d3700 1
a3700 1
  return compare_symbol_name (name, datum->sym_text, datum->sym_text_len);
a3778 16
  /* Prepare SYM_TEXT_LEN for compare_symbol_name.  */

  if (current_language->la_language == language_cplus
      || current_language->la_language == language_java
      || current_language->la_language == language_fortran)
    {
      /* These languages may have parameters entered by user but they are never
	 present in the partial symbol tables.  */

      const char *cs = memchr (sym_text, '(', sym_text_len);

      if (cs)
	sym_text_len = cs - sym_text;
    }
  gdb_assert (sym_text[sym_text_len] == '\0' || sym_text[sym_text_len] == '(');

@


1.262.2.3
log
@gdb/
	PR 12573
	* dwarf2read.c (struct dwarf2_cu): New field has_loclist.
	(producer_is_gcc_ge_4_0): New function.
	(process_full_comp_unit): Set also symtab->locations_valid.  Move the
	symtab->language code.
	(var_decode_location): Set cu->has_loclist.
	* symtab.c (skip_prologue_sal): New variables saved_pc, force_skip and
	skip.  Intialize force_skip from locations_valid.  Move the prologue
	skipping code into two passes.
	* symtab.h (struct symtab): Make the primary field a bitfield.  New
	field locations_valid.

gdb/testsuite/
	PR 12573
	* gdb.dwarf2/dw2-skip-prologue.S: New file.
	* gdb.dwarf2/dw2-skip-prologue.c: New file.
	* gdb.dwarf2/dw2-skip-prologue.exp: New file.
@
text
@d2462 1
a2462 1
  CORE_ADDR pc, saved_pc;
a2467 1
  int force_skip, skip;
d2505 28
a2532 28
  /* Process the prologue in two passes.  In the first pass try to skip the
     prologue (SKIP is true) and verify there is a real need for it (indicated
     by FORCE_SKIP).  If no such reason was found run a second pass where the
     prologue is not skipped (SKIP is false).  */

  skip = 1;
  force_skip = 1;

  /* Be conservative - allow direct PC (without skipping prologue) only if we
     have proven the CU (Compilation Unit) supports it.  sal->SYMTAB does not
     have to be set by the caller so we use SYM instead.  */
  if (sym && SYMBOL_SYMTAB (sym)->locations_valid)
    force_skip = 0;

  saved_pc = pc;
  do
    {
      pc = saved_pc;

      /* If the function is in an unmapped overlay, use its unmapped LMA address,
	 so that gdbarch_skip_prologue has something unique to work on.  */
      if (section_is_overlay (section) && !section_is_mapped (section))
	pc = overlay_unmapped_address (pc, section);

      /* Skip "first line" of function (which is actually its prologue).  */
      pc += gdbarch_deprecated_function_start_offset (gdbarch);
      if (skip)
	pc = gdbarch_skip_prologue (gdbarch, pc);
d2534 9
a2542 4
      /* For overlays, map pc back into its mapped VMA range.  */
      pc = overlay_mapped_address (pc, section);

      /* Calculate line number.  */
a2543 27

      /* Check if gdbarch_skip_prologue left us in mid-line, and the next
	 line is still part of the same function.  */
      if (skip && start_sal.pc != pc
	  && (sym? (BLOCK_START (SYMBOL_BLOCK_VALUE (sym)) <= start_sal.end
		    && start_sal.end < BLOCK_END (SYMBOL_BLOCK_VALUE (sym)))
	      : (lookup_minimal_symbol_by_pc_section (start_sal.end, section)
		 == lookup_minimal_symbol_by_pc_section (pc, section))))
	{
	  /* First pc of next line */
	  pc = start_sal.end;
	  /* Recalculate the line number (might not be N+1).  */
	  start_sal = find_pc_sect_line (pc, section, 0);
	}

      /* On targets with executable formats that don't have a concept of
	 constructors (ELF with .init has, PE doesn't), gcc emits a call
	 to `__main' in `main' between the prologue and before user
	 code.  */
      if (gdbarch_skip_main_prologue_p (gdbarch)
	  && name && strcmp (name, "main") == 0)
	{
	  pc = gdbarch_skip_main_prologue (gdbarch, pc);
	  /* Recalculate the line number (might not be N+1).  */
	  start_sal = find_pc_sect_line (pc, section, 0);
	  force_skip = 1;
	}
a2544 1
  while (!force_skip && skip--);
d2554 1
a2554 1
  if (!force_skip && sym && start_sal.symtab == NULL)
@


1.262.2.4
log
@gdb/
	* symtab.c (output_partial_symbol_filename): Exchange the filename and
	fullname parameters order.

gdb/testsuite/
	* gdb.dwarf2/dw2-filename.exp (info sources): New testcase.
@
text
@d2843 1
a2843 1
output_partial_symbol_filename (const char *filename, const char *fullname,
@


1.262.2.5
log
@commit 7f71565092a430e0a7509868b7279497db6f7cbe
Author: Tom Tromey <tromey@@redhat.com>
Date:   Mon Apr 4 17:41:05 2011 +0000

gdb/
	* tracepoint.c (scope_info): Update.
	* symtab.c (decode_line_spec): Update.
	* python/python.c (gdbpy_decode_line): Update.
	* linespec.h (decode_line_1): Update.
	* linespec.c (decode_line_1): Remove 'not_found_ptr' argument.
	(decode_compound, find_method, symtab_from_filename)
	(decode_variable): Likewise.
	* cli/cli-cmds.c (edit_command): Update.
	(list_command): Update.
	* breakpoint.c (parse_breakpoint_sals): Remove 'not_found_ptr'
	argument.
	(create_breakpoint): Update.
	(until_break_command): Update.
	(addr_string_to_sals): Update.
	(decode_line_spec_1): Update.
@
text
@d4451 1
a4451 1
			NULL);
@


1.262.2.6
log
@commit 21c4d3196c52ae3cf2c65d1eb42b9b70fc9da374
Author: Jan Kratochvil <jan.kratochvil@@redhat.com>
Date:   Fri Jul 1 19:18:35 2011 +0000

gdb/
	* symtab.c (symbol_find_demangled_name): Remove DMGL_VERBOSE.

gdb/testsuite/
	* gdb.cp/no-dmgl-verbose.cc: New file.
	* gdb.cp/no-dmgl-verbose.exp: New file.
@
text
@d493 1
a493 1
        cplus_demangle (mangled, DMGL_PARAMS | DMGL_ANSI);
@


1.261
log
@	* symtab.c (decode_line_spec): Update.
	* linespec.c (build_canonical_line_spec): Change type of
	'canonical'.
	(decode_line_2, decode_line_1, decode_objc, decode_compound)
	(find_method, decode_all_digits, decode_dollar, decode_label)
	(symbol_found): Likewise.
	(init_linespec_result): New function.
	* breakpoint.c (struct captured_parse_breakpoint_args)
	<canonical_p>: New field, replaces addr_string_p.
	(create_breakpoints_sal): Add 'canonical' parameter, replacing
	'addr_string'.
	(parse_breakpoint_sals): Likewise.
	(do_captured_parse_breakpoint): Update.
	(create_breakpoint): Use struct linespec_result.
	(until_break_command): Update.
	(breakpoint_re_set_one): Update.
	(decode_line_spec_1): Update.
	* linespec.h (struct linespec_result): New.
	(init_linespec_result): Declare.
@
text
@d3009 1
a3009 1
    = {mst_file_bss, mst_text, mst_abs, mst_unknown};
@


1.260
log
@2011-03-23  Kai Tietz  <ktietz@@redhat.com>

	* breakpoint.c (clear_command): Use filename_cmp
	instead of strcmp for comparison.
	* buildsym.c (watch_main_source_file_lossage): Likewise.
	(patch_subfile_names): Use IS_DIR_SEPARATOR instead of
	checking just for slash.
	* dbxread.c (read_dbx_symtab): Use lbasename instead of
	strrchr and filename_cmp instead of strcmp for filenames.
	(add_old_header_file): Use filename_cmp
	instead of strcmp for comparison.
	* exec.c (exec_set_section_address): Likewise.
	* macrotab.c (macro_lookup_inclusion): Likewise.
	(macro_lookup_inclusion): Likewise.
	* elfread.c (_initialize_elfread): Likewise.
	(elfstab_offset_sections): Likewise.
	(elfstab_offset_sections): Use lbasename instead of
	strrchr.
	* mdebugread.c (parse_partial_symbols): Likewise.
	(arse_partial_symbols): Use filename_(n)cmp instead of
	str(n)cmp for comparison.
	* minsyms.c (lookup_minimal_symbol): Likewise.
	* psymtab.c (read_psymtabs_with_filename): Likewise.
	* solib.c (solib_read_symbols): Likewise.
	(reload_shared_libraries_1): Likewise.
	* symmisc.c (maintenance_print_symbols): Likewise.
	* symfile.c (separate_debug_file_exists): Likewise.
	(reread_symbols): Likewise.
	(find_separate_debug_file_by_debuglink): Likewise.
	* remote-fileio.c (remote_fileio_func_rename): Likewise.
	* source.c (add_path): Likewise.
	* symtab.c (filename_seen): Likewise.
	(file_matches): Likewise.
	(print_symbol_info): Likewise.
	(maybe_add_partial_symtab_filename): Likewise.
	(make_source_files_completion_list): Likewise.
	* xml-syscall.c (init_sysinfo): Likewise.
	* windows-nat.c (_initialize_check_for_gdb_ini): Use
	IS_DIR_SEPARATOR for checking for trailing path separator.
@
text
@d4384 1
a4384 1
			(char ***) NULL, NULL);
@


1.259
log
@2011-02-27  Michael Snyder  <msnyder@@vmware.com>

	* symtab.c (rbreak_command): Move variable 'file_name' to
	outer scope.
@
text
@d2764 1
a2764 1
    if (strcmp (*p, file) == 0)
d2865 1
a2865 1
	  if (strcmp (files[i], lbasename (file)) == 0)
d3263 1
a3263 1
  if (last == NULL || strcmp (last, s->filename) != 0)
d4076 1
a4076 1
      if (strcmp (fname, illegal_aliens[i]) == 0)
d4105 1
a4105 6
#if HAVE_DOS_BASED_FILE_SYSTEM
      && strncasecmp (filename, data->text, data->text_len) == 0
#else
      && strncmp (filename, data->text, data->text_len) == 0
#endif
      )
d4118 1
a4118 6
#if HAVE_DOS_BASED_FILE_SYSTEM
	  && strncasecmp (base_name, data->text, data->text_len) == 0
#else
	  && strncmp (base_name, data->text, data->text_len) == 0
#endif
	  )
d4152 1
a4152 6
#if HAVE_DOS_BASED_FILE_SYSTEM
	  && strncasecmp (s->filename, text, text_len) == 0
#else
	  && strncmp (s->filename, text, text_len) == 0
#endif
	  )
d4168 1
a4168 6
#if HAVE_DOS_BASED_FILE_SYSTEM
	      && strncasecmp (base_name, text, text_len) == 0
#else
	      && strncmp (base_name, text, text_len) == 0
#endif
	      )
@


1.258
log
@gdb/
	* symtab.c (find_pc_sect_line): New variable objfile, initialize it
	from S.  Iterate S using ALL_OBJFILE_SYMTABS.  Verify BV for each S.
	* symtab.h (struct symtab) <next>: Comment extension.
@
text
@d3406 1
a3406 1
  char **files = NULL;
a3415 1
	  char * file_name;
@


1.257
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* s390-tdep.c: Comment cleanup, mostly periods and spaces.
	* score-tdep.c: Ditto.
	* score-tdep.h: Ditto.
	* ser-base.c: Ditto.
	* ser-go32.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* ser-mingw.c: Ditto.
	* ser-pipe.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* sh64-tdep.c: Ditto.
	* shnbsd-nat.c: Ditto.
	* sh-tdep.c: Ditto.
	* sh-tdep.h: Ditto.
	* solib.c: Ditto.
	* solib-darwin.c: Ditto.
	* solib-frv.c: Ditto.
	* solib.h: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-spu.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solist.h: Ditto.
	* sol-thread.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* source.h: Ditto.
	* sparc64-linux-tdep.c: Ditto.
	* sparc64-tdep.c: Ditto.
	* sparc-linux-nat.c: Ditto.
	* sparc-linux-tdep.c: Ditto.
	* sparc-sol2-nat.c: Ditto.
	* sparc-sol2-tdep.c: Ditto.
	* sparc-tdep.c: Ditto.
	* sparc-tdep.h: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.h: Ditto.
	* stack.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target.c: Ditto.
	* target-descriptions.c: Ditto.
	* target-descriptions.h: Ditto.
	* target.h: Ditto.
	* target-memory.c: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* trad-frame.h: Ditto.
	* typeprint.c: Ditto.
@
text
@d1907 1
d2035 1
d2041 1
a2041 1
  for (; s && BLOCKVECTOR (s) == bv; s = s->next)
d2043 3
@


1.256
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d150 1
a150 1
   value_of_this. */
d179 1
a179 1
  /* First, search for an exact match */
d218 1
a218 1
  /* Now, search for a matching tail (only if name doesn't have any dirs) */
d254 1
a254 1
     symbol parsing routines. */
d261 1
a261 1
   specified by SIGNATURE_ID.  Note that this function is g++ specific. */
d335 1
a335 1
     as something starting with `::' rather than `classname::'. */
d361 1
a361 1
   allocated so OBJFILE must not be NULL. If this is a non C++ symbol
d396 1
a396 1
   depending upon the language for the symbol. */
d722 1
a722 1
   that symbol.  If no demangled name exists, return NULL. */
d751 1
a751 1
   (same pointer) as SYMBOL_LINKAGE_NAME. */
d998 1
a998 1
   a field of `this', value_of_this sets BLOCK_FOUND to the proper value.) */
d1023 1
a1023 1
     lookup, so we can always binary search. */
d1183 1
a1183 1
   the fly and return the found symbol. */
d1394 1
a1394 1
	 the symbol was global, or vice-versa. It's possible
d1570 1
a1570 1
       * claimed the symbol was one thing. It's possible that
d1576 1
a1576 1
	/* FIXME; error is wrong in one case */
d1606 1
a1606 1
     check the psymtab's. If a psymtab indicates the existence
d1640 1
a1640 1
     check the psymtab's. If a psymtab indicates the existence
d1642 1
a1642 2
     conversion on the fly and return the found symbol.
   */
d1673 1
a1673 1
/* Find the name of the file containing main(). */
d1675 1
a1675 1
   executables that have no main() ? */
d1705 1
a1705 2
   non-encoded names tested for a match.
*/
d1750 1
a1750 1
      return (sym_found);	/* Will be NULL if not found. */
d1755 1
a1755 1
   psymtabs and read in another symtab if necessary. */
d1792 1
a1792 1
     gets its own symtab. The symtab for the included file should have
d1815 1
a1815 1
	   can't be found. */
d1840 2
a1841 1
	      continue;		/* no symbol in this symtab matches section */
d1868 2
a1869 2
/* Find the symtab associated with PC.  Look through the psymtabs and
   read in another symtab if necessary.  Backward compatibility, no section */
d1948 1
a1948 1
     to call a shlib function. This stub would be anywhere between
d1950 2
a1951 2
     taken to be the one of the line before the pc.
   */
d1960 1
a1960 1
   * sorted by start address. The stubs are marked as "trampoline",
d1980 1
a1980 1
   *      if we're really in the trampoline. If we're beyond it (say
d1986 1
a1986 1
   *      be different than the trampoline address. I put in a sanity
d2005 1
a2005 1
	   * So I commented out the warning. RT */
d2007 2
a2008 1
	     SYMBOL_LINKAGE_NAME (msymbol)) */ ;
d2013 1
a2013 1
	  /* See above comment about why warning is commented out */
d2015 2
a2016 1
	     SYMBOL_LINKAGE_NAME (msymbol)) */ ;
d2026 1
a2026 1
      /* if no symbol information, return previous pc */
d2056 1
a2056 1
      item = l->item;		/* Get first line info */
d2116 1
a2116 1
	 find any valid line information. */
d2135 1
a2135 1
/* Backward compatibility (no section) */
d2616 1
a2616 1
  /* Recognize 'operator TYPENAME'. */
d2655 1
a2655 1
	    /* Gratuitous qoute: skip it and move on. */
d2679 1
a2679 1
	    /* Struct pointer member operator 'operator->'. */
d2869 1
a2869 1
/* Free any memory associated with a search. */
d2981 2
a2982 2
   separately alphabetized.
 */
d3031 1
a3031 1
         and <TYPENAME> or <OPERATOR>. */
d3042 1
a3042 1
	      /* There should 1 space between 'operator' and 'TYPENAME'. */
d3048 1
a3048 1
	      /* There should 0 spaces between 'operator' and 'OPERATOR'. */
d3052 1
a3052 1
	  /* If wrong number of spaces, fix it. */
d3068 1
a3068 1
     the machinery below. */
d3093 1
a3093 2
     any matching symbols without debug info.
   */
d3213 1
a3213 1
		/* Functions:  Look up by address. */
d3217 1
a3217 1
		    /* Variables/Absolutes:  Look up by name */
d3252 2
a3253 2
   regarding the match to gdb_stdout.
 */
d3268 1
a3268 1
  /* Typedef that is not a C++ class */
d3272 1
a3272 1
  /* variable, func, or typedef-that-is-c++-class */
d3287 2
a3288 2
   for non-debugging symbols to gdb_stdout.
 */
d3307 1
a3307 1
   "info variables". It calls search_symbols to find all matches and then
d3309 2
a3310 2
   matches.
 */
d3322 1
a3322 1
  /* must make sure that if we're interrupted, symbols gets freed */
d3377 1
a3377 1
/* Breakpoint all functions matching regular expression. */
d3491 1
a3491 1
   characters.  If so, add it to the current completion list. */
d3499 1
a3499 1
  /* clip symbols that cannot match */
d3507 1
a3507 1
     of matches. Note that the name is moved to freshly malloc'd space. */
d3602 1
a3602 1
   symbols. FIXME: This should probably be language-specific. */
d3615 1
a3615 1
	      if (p[-1] == ':')     /* might be part of a method name */
d3618 1
a3618 1
		p -= 2;             /* beginning of a method name */
d3620 1
a3620 1
		{                   /* might be part of a method name */
d3637 2
a3638 2
		    p = t - 2;      /* method name detected */
		  /* else we leave with p unchanged */
d3806 1
a3806 1
     visible from current context. */
d4207 1
a4207 2
   by previous examination of symbol table information.
 */
d4331 1
a4331 1
	 "foo(){}". */
d4371 1
a4371 1
	     looking for any in the prologue */
d4394 2
a4395 2
  /* We use whatever is set as the current source line. We do not try
     and get a default  or it will recursively call us! */
d4442 1
a4442 1
     such that false positives never be returned. For instance, it is
d4447 1
a4447 1
     of the main procedure. It is difficult however to see how this can
@


1.255
log
@run copyright.sh for 2011.
@
text
@d294 2
a295 2
  is_constructor =
    is_full_physname_constructor || (newname && strcmp (field_name, newname) == 0);
d1408 4
a1411 1
	error (_("Internal: %s symbol `%s' found in %s psymtab but not in symtab.\n%s may be an inlined function, or may be a template function\n(if a template, try specifying an instantiation: %s<type>)."),
d1577 2
a1578 1
	error (_("Internal: global symbol `%s' found in %s psymtab but not in symtab.\n\
d2007 2
a2008 1
	  /* warning ("In stub for %s; unable to find real function/line info", SYMBOL_LINKAGE_NAME (msymbol)) */ ;
d2010 2
a2011 1
	else if (SYMBOL_VALUE_ADDRESS (mfunsym) == SYMBOL_VALUE_ADDRESS (msymbol))
d2014 2
a2015 1
	  /* warning ("In stub for %s; unable to find real function/line info", SYMBOL_LINKAGE_NAME (msymbol)) */ ;
d2633 1
a2633 1
	    if (p[2] == '=')	/* 'operator\*=' */
d2642 2
a2643 1
	      error (_("mismatched quoting on brackets, try 'operator\\[\\]'"));
d2706 2
a2707 1
	  error (_("`operator ()' must be specified without whitespace in `()'"));
d2712 2
a2713 1
	  error (_("`operator ?:' must be specified without whitespace in `?:'"));
d2718 2
a2719 1
	  error (_("`operator []' must be specified without whitespace in `[]'"));
d2842 2
a2843 1
  printf_filtered ("Source files for which symbols will be read in on demand:\n\n");
d3036 2
a3037 1
	  int fix = -1;		/* -1 means ok; otherwise number of spaces needed. */
d3155 6
a3160 3
				&& TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_ENUM))
			  || (kind == FUNCTIONS_DOMAIN && SYMBOL_CLASS (sym) == LOC_BLOCK)
			  || (kind == TYPES_DOMAIN && SYMBOL_CLASS (sym) == LOC_TYPEDEF))))
d3163 2
a3164 1
		  psr = (struct symbol_search *) xmalloc (sizeof (struct symbol_search));
d3223 2
a3224 1
			psr = (struct symbol_search *) xmalloc (sizeof (struct symbol_search));
@


1.254
log
@gdb/
	Fix the `stopped language detection' testcase for gcc-4.5.
	* dwarf2read.c (read_partial_die): Set also LANGUAGE_OF_MAIN.
	* symfile.c (set_initial_language): Move variable filename to a more
	inner block.  Prefer LANGUAGE_OF_MAIN.
	* symtab.c (language_of_main): New variable.
	(set_main_name): Always reset LANGUAGE_OF_MAIN.
	* symtab.h (language_of_main): New declaration.
@
text
@d5 1
a5 1
   2010 Free Software Foundation, Inc.
@


1.253
log
@	Revert:
	2010-09-01  Tom Tromey  <tromey@@redhat.com>
	* dwarf2read.c, gdbtypes.c, psymtab.c, symfile.h, symtab.c,
	symtab.h: Revert earlier change.
@
text
@d4392 1
d4401 1
d4406 1
@


1.252
log
@	* symtab.h (lookup_type_symbol): Declare.
	* symtab.c (lookup_symbol_in_language_full): Rename from
	lookup_symbol_in_language.  Add 'for_type' argument.
	(lookup_symbol_in_language): New function.
	(lookup_type_symbol): Likewise.
	(lookup_symbol_aux): Add 'for_type' argument.
	(match_symbol_aux): New function.
	(lookup_symbol_aux_symtabs): Use expand_one_symtab_matching.
	(match_transparent_type): New function.
	(basic_lookup_transparent_type): Use expand_one_symtab_matching.
	* symfile.h (struct quick_symbol_functions)
	<pre_expand_symtabs_matching>: Remove.
	<expand_one_symtab_matching>: New field.
	* psymtab.c (expand_one_symtab_matching_psymtabs): New function.
	(pre_expand_symtabs_matching_psymtabs): Remove.
	(psym_functions): Update.
	* gdbtypes.c (lookup_typename): Use lookup_type_symbol.
	* dwarf2read.c (dw2_lookup_symbol): Update comment.
	(dw2_pre_expand_symtabs_matching): Remove.
	(dw2_expand_one_symtab_matching): New function.
	(dwarf2_gdb_index_functions): Update.
@
text
@d94 1
a94 2
					 int *is_a_field_of_this,
					 int for_type);
a996 2
   FOR_TYPE is non-zero if searching specifically for a type; zero
   otherwise.
d1010 4
a1013 4
static struct symbol *
lookup_symbol_in_language_full (const char *name, const struct block *block,
				const domain_enum domain, enum language lang,
				int *is_a_field_of_this, int for_type)
d1078 1
a1078 1
				 is_a_field_of_this, for_type);
a1083 29
/* Find the definition for a specified symbol name NAME
   in domain DOMAIN, visible from lexical block BLOCK.
   Returns the struct symbol pointer, or zero if no symbol is found.
   C++: if IS_A_FIELD_OF_THIS is nonzero on entry, check to see if
   NAME is a field of the current implied argument `this'.  If so set
   *IS_A_FIELD_OF_THIS to 1, otherwise set it to zero.
   BLOCK_FOUND is set to the block in which NAME is found (in the case of
   a field of `this', value_of_this sets BLOCK_FOUND to the proper value.) */

struct symbol *
lookup_symbol_in_language (const char *name, const struct block *block,
			   const domain_enum domain, enum language lang,
			   int *is_a_field_of_this)
{
  return lookup_symbol_in_language_full (name, block, domain, lang,
					 is_a_field_of_this, 0);
}

/* Like lookup_symbol_in_language, but search specifically for a
   type.  */

struct symbol *
lookup_type_symbol (const char *name, const struct block *block,
		    const domain_enum domain, enum language lang)
{
  return lookup_symbol_in_language_full (name, block, domain, lang,
					 NULL, 1);
}

d1104 1
a1104 2
		   int *is_a_field_of_this,
		   int for_type)
d1168 1
a1168 2
     up static and global variables.  If we are searching for a type,
     we bypass this lookup, because types aren't global.  */
d1170 3
a1172 6
  if (!for_type)
    {
      sym = langdef->la_lookup_symbol_nonlocal (name, block, domain);
      if (sym != NULL)
	return sym;
    }
d1174 2
a1175 4
  /* Now search all static file-level symbols.  When searching for a
     type, this is what we generally want, because types are put into
     the file scope.  For other objects, not strictly correct, but
     more useful than an error.  */
a1329 29
/* A helper for lookup_symbol_aux_symtabs that is passed as a callback
   to the expand_one_symtab_matching quick function.  */

static struct symbol *
match_symbol_aux (struct symtab *symtab,
		  int kind, const char *name, domain_enum domain,
		  void *arg)
{
  struct objfile *objfile = arg;

  if (symtab->primary)
    {
      struct symbol *sym;
      struct blockvector *bv;
      const struct block *block;

      bv = BLOCKVECTOR (symtab);
      block = BLOCKVECTOR_BLOCK (bv, kind);
      sym = lookup_block_symbol (block, name, domain);
      if (sym)
	{
	  block_found = block;
	  return fixup_symbol_section (sym, objfile);
	}
    }

  return NULL;
}

d1347 5
a1363 11

    if (objfile->sf)
      {
	sym = objfile->sf->qf->expand_one_symtab_matching (objfile,
							   block_index,
							   name, domain,
							   match_symbol_aux,
							   objfile);
	if (sym)
	  return sym;
      }
a1584 24
/* A helper function for basic_lookup_transparent_type that is passed
   to the expand_one_symtab_matching quick function.  */

static struct symbol *
match_transparent_type (struct symtab *symtab,
			int kind, const char *name, domain_enum domain,
			void *data)
{
  if (symtab->primary)
    {
      struct blockvector *bv;
      struct block *block;
      struct symbol *sym;

      bv = BLOCKVECTOR (symtab);
      block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
      sym = lookup_block_symbol (block, name, STRUCT_DOMAIN);
      if (sym && !TYPE_IS_OPAQUE (SYMBOL_TYPE (sym)))
	return sym;
    }

  return NULL;
}

d1608 5
a1623 12

    if (objfile->sf)
      {
	sym
	  = objfile->sf->qf->expand_one_symtab_matching (objfile,
							 GLOBAL_BLOCK, name,
							 STRUCT_DOMAIN,
							 match_transparent_type,
							 NULL);
	if (sym)
	  return SYMBOL_TYPE (sym);
      }
d1643 4
a1656 12

    if (objfile->sf)
      {
	sym
	  = objfile->sf->qf->expand_one_symtab_matching (objfile,
							 STATIC_BLOCK, name,
							 STRUCT_DOMAIN,
							 match_transparent_type,
							 NULL);
	if (sym)
	  return SYMBOL_TYPE (sym);
      }
@


1.251
log
@Fix regression in -file-list-exec-source-files command.

See http://sourceware.org/ml/gdb/2010-07/msg00118.html for
a description of the problem. Namely, the file and fullname
fields are inverted in the output of the -file-list-exec-source-files
GDB/MI command:

    (gdb) interpreter-exec mi -file-list-exec-source-files
    ^done,files=[{file="/takamaka.a/brobecke/ex/list-exec-source-files/foo.c",fullname="foo.c"},{file="/takamaka.a/brobecke/ex/list-exec-source-files/foo.c",fullname="foo.c"},{file="",fullname="init.c"},{file="",fullname="../sysdeps/x86_64/elf/start.S"},{file="",fullname="../sysdeps/x86_64/elf/start.S"}]

It turns out to be a silly thinko: The map_symbol_filenames function
calls the psymtab version of map_symbol_filenames routine, and this
version called the callback function with filename and fullname
in the wrong order (fullname/filename instead of filename/fullname).

The routine description in symfile.h confirst that expected order for
the FUN callback parameters:

    /* Call a callback for every file defined in OBJFILE.  FUN is the
       callback.  It is passed the file's name, the file's full name,
       and the DATA passed to this function.  */
    void (*map_symbol_filenames) (struct objfile *objfile,
                                  void (*fun) (const char *, const char *,
                                               void *),
                                  void *data);

Fixing this error uncovered another location where the arguments
were reversed: maybe_add_partial_symtab_filename.  Once the first
error was fixed, the debugger would crash while attempting to do
completion, because it was given a NULL fullname instead of the
non-NULL filename.

gdb/ChangeLog:

        * psymtab.c (map_symbol_filenames_psymtab): Call FUN with
        the arguments in the correct order.
        * symtab.c (maybe_add_partial_symtab_filename): Declare
        the arguments in the correct order.
@
text
@d94 2
a95 1
					 int *is_a_field_of_this);
d998 2
d1013 4
a1016 4
struct symbol *
lookup_symbol_in_language (const char *name, const struct block *block,
			   const domain_enum domain, enum language lang,
			   int *is_a_field_of_this)
d1081 1
a1081 1
				 is_a_field_of_this);
d1087 29
d1136 2
a1137 1
		   int *is_a_field_of_this)
d1201 2
a1202 1
     up static and global variables.  */
d1204 6
a1209 3
  sym = langdef->la_lookup_symbol_nonlocal (name, block, domain);
  if (sym != NULL)
    return sym;
d1211 4
a1214 2
  /* Now search all static file-level symbols.  Not strictly correct,
     but more useful than an error.  */
d1369 29
a1414 5
    if (objfile->sf)
      objfile->sf->qf->pre_expand_symtabs_matching (objfile,
						    block_index,
						    name, domain);

d1427 11
d1659 24
a1705 5
    if (objfile->sf)
      objfile->sf->qf->pre_expand_symtabs_matching (objfile,
						    GLOBAL_BLOCK,
						    name, STRUCT_DOMAIN);

d1717 12
a1747 4
    if (objfile->sf)
      objfile->sf->qf->pre_expand_symtabs_matching (objfile, STATIC_BLOCK,
						    name, STRUCT_DOMAIN);

d1758 12
@


1.250
log
@Fixed stabs cplus_specific issue

2010-08-09  Sami Wagiaalla  <swagiaal@@redhat.com>

	* symtab.c (symbol_get_demangled_name): Remove assertion and
	return NULL when language_specific.cplus_specific is not initialized.
	* stabsread.c (define_symbol): Set the name before calling
	cp_scan_for_anonymous_namespaces.
@
text
@d4075 1
a4075 1
maybe_add_partial_symtab_filename (const char *fullname, const char *filename,
@


1.249
log
@create and use symbol_set_language.

2010-08-09  Sami Wagiaalla  <swagiaal@@redhat.com>

	* symtab.h: Renamed SYMBOL_INIT_LANGUAGE_SPECIFIC to
	SYMBOL_SET_LANGUAGE.
	(symbol_init_language_specific): Renamed to symbol_set_language.
	* symtab.c (symbol_init_language_specific): Removed redundant check
	for language_cplus.
	Renamed to symbol_set_language.
	* stabsread.c (define_symbol): Updated.
	(read_enum_type): Updated
	* psymtab.c (add_psymbol_to_bcache): Updated.
	* minsyms.c (install_minimal_symbols): Updated.
	* coffread.c (process_coff_symbol): SYMBOL_SET_LANGUAGE instead of
	SYMBOL_LANGUAGE to set the language.
	* minsyms.c (prim_record_minimal_symbol_full): Ditto.
	* mdebugread.c (new_symbol): Ditto.
	* cp-namespace.c (check_one_possible_namespace_symbol): Ditto.
	* dwarf2read.c (new_symbol_full): Ditto.
	* jv-lang.c (add_class_symbol): Ditto.
@
text
@d385 4
a388 2
      gdb_assert (gsymbol->language_specific.cplus_specific != NULL);
      return gsymbol->language_specific.cplus_specific->demangled_name;
@


1.248
log
@	* breakpoint.c (bpdisp_text): Constify bpdisps.
	* solib-svr4.c (solib_break_names): Constify.
	(bkpt_names, main_name_list): Constify.
	(match_main): Constify soname arg.
	(bfd_lookup_symbol): Constify symname arg.
	(enable_break): Constify bkpt_namep.
	* symtab.c (search_symbols): Constify types, types2, types3, types4.
	(symtab_symbol_info): Constify classnames.
@
text
@d396 2
a397 2
symbol_init_language_specific (struct general_symbol_info *gsymbol,
			       enum language language)
a398 1

d400 1
a400 2
  if (gsymbol->language == language_cplus
      || gsymbol->language == language_d
@


1.247
log
@gdb
	PR c++/9946:
	* symfile.c (reread_symbols): Clear template_symbols.
	* symtab.h (struct symbol) <is_cplus_template_function>: New
	field.
	(SYMBOL_IS_CPLUS_TEMPLATE_FUNCTION): New macro.
	(struct template_symbol): New.
	* symtab.c (lookup_symbol_aux_local): Use
	cp_lookup_symbol_imports_or_template.
	* objfiles.h (struct objfile) <template_symbols>: New field.
	* objfiles.c (relocate_one_symbol): New function.
	(objfile_relocate1): Use it.  Relocate isolated symbols.
	* gdbtypes.h (struct cplus_struct_type) <n_template_arguments,
	template_arguments>: New fields.
	(TYPE_N_TEMPLATE_ARGUMENTS): New macro.
	(TYPE_TEMPLATE_ARGUMENTS): Likewise.
	(TYPE_TEMPLATE_ARGUMENT): Likewise.
	(lookup_typename): Update.
	* gdbtypes.c (lookup_typename): Constify "block" argument.
	* dwarf2read.c: Include vec.h.
	(symbolp): New typedef.
	(read_func_scope): Read template arguments.  Allocate a
	template_symbol when needed.
	(read_structure_type): Read template arguments.
	(new_symbol_full): New function, from new_symbol.  Handle
	DW_TAG_template_type_param and DW_TAG_template_value_param.
	(new_symbol): Rewrite as wrapper.
	* cp-support.h (cp_lookup_symbol_imports_or_template): Declare.
	* cp-namespace.c: Include language.h.
	(search_symbol_list): New function.
	(cp_lookup_symbol_imports_or_template): Likewise.
gdb/testsuite
	PR c++/9946:
	* gdb.cp/temargs.exp: New file.
	* gdb.cp/temargs.cc: New file.
@
text
@d2984 1
a2984 1
  static enum minimal_symbol_type types[]
d2986 1
a2986 1
  static enum minimal_symbol_type types2[]
d2988 1
a2988 1
  static enum minimal_symbol_type types3[]
d2990 1
a2990 1
  static enum minimal_symbol_type types4[]
d3296 2
a3297 1
  static char *classnames[] = {"variable", "function", "type", "method"};
@


1.246
log
@	* symtab.c (basic_lookup_transparent_type): Call pre-expand
	hook for STATIC_BLOCK types, too.
@
text
@d1230 2
a1231 6
          sym = cp_lookup_symbol_imports (scope,
                                          name,
                                          block,
                                          domain,
                                          1,
                                          1);
@


1.245
log
@Use allocated cplus_specific for cplus symbols.

2010-07-16  Sami Wagiaalla  <swagiaal@@redhat.com>

	* symtab.h (symbol_set_demangled_name): Now takes an optional objfile*
	argument.
	(cplus_specific): New struct.
	* symtab.c (symbol_set_demangled_name): Updated.
	Use cplus_specific for cplus symbols.
	(symbol_get_demangled_name): Retrive the name from the cplus_specific
	struct for cplus symbols.
	(symbol_init_language_specific): Set cplus_specific for cplus symbols.
	(symbol_set_names): Pass objfile to symbol_set_demangled_name.
	* symtab.c (symbol_init_cplus_specific): New function.
@
text
@d1645 1
a1645 1
  ALL_PRIMARY_SYMTABS (objfile, s)
d1647 5
a1651 4
    bv = BLOCKVECTOR (s);
    block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
    sym = lookup_block_symbol (block, name, STRUCT_DOMAIN);
    if (sym && !TYPE_IS_OPAQUE (SYMBOL_TYPE (sym)))
d1653 7
a1659 1
	return SYMBOL_TYPE (sym);
@


1.244
log
@Use setter and getter for demangled_name.

2010-07-16  Sami Wagiaalla  <swagiaal@@redhat.com>

	* symtab.h (symbol_set_demangled_name): New function.
	(symbol_get_demangled_name): New function.
	* symtab.c (symbol_set_demangled_name): New function.
	(symbol_get_demangled_name): New function.
	(symbol_init_language_specific): Use demangled_name setter and getter.
	(symbol_set_names): Ditto.
	(symbol_natural_name): Ditto.
	(symbol_demangled_name): Ditto.
	* dwarf2read.c (new_symbol): Ditto.
@
text
@d343 16
d360 3
a362 1
   correctly allocated.  */
d365 2
a366 1
                           char *name)
d368 9
a376 1
  gsymbol->language_specific.mangled_lang.demangled_name = name;
d383 7
a389 1
  return gsymbol->language_specific.mangled_lang.demangled_name;
d399 1
d407 1
a407 1
      symbol_set_demangled_name (gsymbol, NULL);
d409 2
d592 1
a592 1
      symbol_set_demangled_name (gsymbol, NULL);
d688 1
a688 1
    symbol_set_demangled_name (gsymbol, (*slot)->demangled);
d690 1
a690 1
    symbol_set_demangled_name (gsymbol, NULL);
@


1.243
log
@Rename cplus_specific mangled_lang.

2010-07-16  Sami Wagiaalla  <swagiaal@@redhat.com>

	* symtab.h: Renamed cplus_specific to mangled_lang.
	* symtab.c (symbol_init_language_specific): Updated.
	(symbol_set_names): Updated.
	(symbol_natural_name): Updated.
	(symbol_demangled_name): Updated.
	* ada-lang.c (ada_decode_symbol): Updated.
	* dwarf2read.c (new_symbol): Updated.
@
text
@d343 16
d373 1
a373 1
      gsymbol->language_specific.mangled_lang.demangled_name = NULL;
d556 1
a556 1
      gsymbol->language_specific.mangled_lang.demangled_name = NULL;
d652 1
a652 2
    gsymbol->language_specific.mangled_lang.demangled_name
      = (*slot)->demangled;
d654 1
a654 1
    gsymbol->language_specific.mangled_lang.demangled_name = NULL;
d670 2
a671 2
      if (gsymbol->language_specific.mangled_lang.demangled_name != NULL)
	return gsymbol->language_specific.mangled_lang.demangled_name;
d674 2
a675 2
      if (gsymbol->language_specific.mangled_lang.demangled_name != NULL)
	return gsymbol->language_specific.mangled_lang.demangled_name;
d697 2
a698 2
      if (gsymbol->language_specific.mangled_lang.demangled_name != NULL)
	return gsymbol->language_specific.mangled_lang.demangled_name;
d701 2
a702 2
      if (gsymbol->language_specific.mangled_lang.demangled_name != NULL)
	return gsymbol->language_specific.mangled_lang.demangled_name;
@


1.242
log
@	* symfile.c (set_initial_language): Update.
	(deduce_language_from_filename): Argument type now const.
	* symtab.h (find_main_filename): Update.
	(deduce_language_from_filename): Update.
	* symtab.c (find_main_filename): Make result const.
	* dwarf2read.c (dw2_find_symbol_file): Change return type.
	* psymtab.c (find_symbol_file_from_partial): Change return type.
	* symfile.h (struct quick_symbol_functions) <find_symbol_file>:
	Make result const.
@
text
@d357 1
a357 1
      gsymbol->language_specific.cplus_specific.demangled_name = NULL;
d540 1
a540 1
      gsymbol->language_specific.cplus_specific.demangled_name = NULL;
d636 1
a636 1
    gsymbol->language_specific.cplus_specific.demangled_name
d639 1
a639 1
    gsymbol->language_specific.cplus_specific.demangled_name = NULL;
d655 2
a656 2
      if (gsymbol->language_specific.cplus_specific.demangled_name != NULL)
	return gsymbol->language_specific.cplus_specific.demangled_name;
d659 2
a660 2
      if (gsymbol->language_specific.cplus_specific.demangled_name != NULL)
	return gsymbol->language_specific.cplus_specific.demangled_name;
d682 2
a683 2
      if (gsymbol->language_specific.cplus_specific.demangled_name != NULL)
	return gsymbol->language_specific.cplus_specific.demangled_name;
d686 2
a687 2
      if (gsymbol->language_specific.cplus_specific.demangled_name != NULL)
	return gsymbol->language_specific.cplus_specific.demangled_name;
@


1.241
log
@	* symtab.c (lookup_symbol_aux_symtabs): Call pre-expand hook.
	(basic_lookup_transparent_type): Likewise.
	* symfile.h (struct quick_symbol_functions)
	<pre_expand_symtabs_matching>: New field.
	* psymtab.c (pre_expand_symtabs_matching_psymtabs): New function.
	(psym_functions): Update.
@
text
@d1620 1
a1620 1
char *
d1624 1
a1624 1
  char *result, *name = main_name ();
d1628 2
@


1.240
log
@	PR c++/11702
	* NEWS: Add entry.
	* dwarf2read.c (dwarf2_add_field): If DW_AT_const_value is present,
	create a symbol for the field and record the value.
	(new_symbol): Handle DW_TAG_member.
	* gdbtypes.c (field_is_static): Remove FIXME.
	* symtab.c (search_symbols): When searching for VARIABLES_DOMAIN,
	only ignore LOC_CONST symbols that are enums.

	testsuite/
	Test PR c++/11702.
	* gdb.cp/m-static.exp: Add testcase.
	* gdb.cp/m-static.h (gnu_obj_4): Add initialized static const member.
@
text
@d1298 1
a1298 1
  ALL_PRIMARY_SYMTABS (objfile, s)
d1300 17
a1316 8
    bv = BLOCKVECTOR (s);
    block = BLOCKVECTOR_BLOCK (bv, block_index);
    sym = lookup_block_symbol (block, name, domain);
    if (sym)
      {
	block_found = block;
	return fixup_symbol_section (sym, objfile);
      }
d1559 1
a1559 1
  ALL_PRIMARY_SYMTABS (objfile, s)
d1561 16
a1576 7
    bv = BLOCKVECTOR (s);
    block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
    sym = lookup_block_symbol (block, name, STRUCT_DOMAIN);
    if (sym && !TYPE_IS_OPAQUE (SYMBOL_TYPE (sym)))
      {
	return SYMBOL_TYPE (sym);
      }
@


1.240.2.1
log
@Fix regression in -file-list-exec-source-files command.

See http://sourceware.org/ml/gdb/2010-07/msg00118.html for
a description of the problem. Namely, the file and fullname
fields are inverted in the output of the -file-list-exec-source-files
GDB/MI command:

    (gdb) interpreter-exec mi -file-list-exec-source-files
    ^done,files=[{file="/takamaka.a/brobecke/ex/list-exec-source-files/foo.c",fullname="foo.c"},{file="/takamaka.a/brobecke/ex/list-exec-source-files/foo.c",fullname="foo.c"},{file="",fullname="init.c"},{file="",fullname="../sysdeps/x86_64/elf/start.S"},{file="",fullname="../sysdeps/x86_64/elf/start.S"}]

It turns out to be a silly thinko: The map_symbol_filenames function
calls the psymtab version of map_symbol_filenames routine, and this
version called the callback function with filename and fullname
in the wrong order (fullname/filename instead of filename/fullname).

The routine description in symfile.h confirst that expected order for
the FUN callback parameters:

    /* Call a callback for every file defined in OBJFILE.  FUN is the
       callback.  It is passed the file's name, the file's full name,
       and the DATA passed to this function.  */
    void (*map_symbol_filenames) (struct objfile *objfile,
                                  void (*fun) (const char *, const char *,
                                               void *),
                                  void *data);

Fixing this error uncovered another location where the arguments
were reversed: maybe_add_partial_symtab_filename.  Once the first
error was fixed, the debugger would crash while attempting to do
completion, because it was given a NULL fullname instead of the
non-NULL filename.

gdb/ChangeLog:

        * psymtab.c (map_symbol_filenames_psymtab): Call FUN with
        the arguments in the correct order.
        * symtab.c (maybe_add_partial_symtab_filename): Declare
        the arguments in the correct order.
@
text
@d4000 1
a4000 1
maybe_add_partial_symtab_filename (const char *filename, const char *fullname,
@


1.239
log
@gdb/
	* cp-namespace.c (cp_lookup_nested_type): New variable
	concatenated_name.  Turn the current return condition into a reverse
	one.  Call also lookup_static_symbol_aux on the constructed qualified
	name.
	* symtab.c (lookup_symbol_aux): Move variable objfile and searching in
	other files into a called ...
	(lookup_static_symbol_aux): ... new function here.
	* symtab.h (lookup_static_symbol_aux): New prototype.
	* valops.c (value_maybe_namespace_elt): Call also
	lookup_static_symbol_aux if we failed otherwise.

gdb/testsuite/
	* gdb.cp/namespace.exp (whatis C::cOtherFileType)
	(whatis ::C::cOtherFileType, whatis C::cOtherFileVar)
	(whatis ::C::cOtherFileVar, print C::cOtherFileVar)
	(print ::C::cOtherFileVar)
	(whatis C::OtherFileClass::cOtherFileClassType)
	(whatis ::C::OtherFileClass::cOtherFileClassType)
	(print C::OtherFileClass::cOtherFileClassVar)
	(print ::cOtherFileClassVar)
	(print ::C::OtherFileClass::cOtherFileClassVar): New tests.
	(ptype OtherFileClass, ptype ::C::OtherFileClass): Permit arbitrary
	trailing content.
	* gdb.cp/namespace1.cc (C::OtherFileClass::cOtherFileClassType)
	(C::OtherFileClass::cOtherFileClassVar)
	(C::OtherFileClass::cOtherFileClassVar_use, C::cOtherFileType)
	(C::cOtherFileVar, C::cOtherFileVar_use): New.
@
text
@d3060 2
a3061 1
		      && ((kind == VARIABLES_DOMAIN && SYMBOL_CLASS (sym) != LOC_TYPEDEF
d3064 5
a3068 1
			   && SYMBOL_CLASS (sym) != LOC_CONST)
@


1.238
log
@gdb/
	Support DW_TAG_module as separate namespaces.
	* dwarf2read.c (typename_concat): New parameter physname.
	(read_module_type): New function and declaration.
	(scan_partial_symbols): Scan also DW_TAG_module children.
	(partial_die_parent_scope): Accept scope even from DW_TAG_module. Pass
	to typename_concat backward compatible physname value 0.
	(partial_die_full_name, read_namespace_type): Pass to typename_concat
	backward compatible physname value 0.
	(add_partial_module, read_module): Remove FIXME comment.
	(process_die) <DW_TAG_module>: Set PROCESSING_HAS_NAMESPACE_INFO.
	(die_needs_namespace) <DW_TAG_variable>: Allow returning true even for
	DIEs under DW_TAG_module.
	(dwarf2_compute_name): Move the ada block for DW_AT_linkage_name and
	DW_AT_MIPS_linkage_name first, extend it for language_fortran
	&& physname and return there instead of just setting NAME.  Extend
	the main block for language_fortran.  Pass physname parameter to the
	typename_concat call.
	(read_import_statement, read_func_scope, get_scope_pc_bounds)
	(load_partial_dies, determine_prefix): Support also DW_TAG_module.
	(new_symbol): Fill in cplus_specific.demangled_name if it is still
	missing from SYMBOL_SET_NAMES in the language_fortran case.
	(new_symbol) <DW_TAG_variable>: Force LOC_UNRESOLVED for gfortran module
	variables.
	(read_type_die) <DW_TAG_module>: New.
	(MAX_SEP_LEN): Increase to 7.
	(typename_concat): New parameter physname.  New variable lead.  Support
	also language_fortran.
	* f-exp.y (yylex): Consider : also as a symbol name character class.
	* f-lang.c: Include cp-support.h.
	(f_word_break_characters, f_make_symbol_completion_list): New functions.
	(f_language_defn): Use cp_lookup_symbol_nonlocal,
	f_word_break_characters and f_make_symbol_completion_list.
	* f-typeprint.c (f_type_print_base) <TYPE_CODE_MODULE>: New.
	* gdbtypes.h (enum type_code) <TYPE_CODE_MODULE>: New.
	* symtab.c (symbol_init_language_specific): Support language_fortran.
	(symbol_find_demangled_name): New comment on language_fortran.
	(symbol_natural_name, symbol_demangled_name): Use demangled_name even
	for language_fortran.
	(lookup_symbol_aux_local): Check imports also for language_fortran.
	(default_make_symbol_completion_list): Rename to ...
	(default_make_symbol_completion_list_break_on): ... this name.  New
	parameter break_on, use it.
	(default_make_symbol_completion_list): New stub.
	* symtab.h (default_make_symbol_completion_list_break_on): New
	prototype.

gdb/testsuite/
	Support DW_TAG_module as separate namespaces.
	* gdb.fortran/library-module.exp, gdb.fortran/library-module-main.f90,
	gdb.fortran/library-module-lib.f90: New.
	* gdb.fortran/module.exp: Replace startup by a prepare_for_testing call.
	(print i): Remove.
	(continue to breakpoint: i-is-1, print var_i value 1)
	(continue to breakpoint: i-is-2, print var_i value 2)
	(continue to breakpoint: a-b-c-d, print var_a, print var_b, print var_c)
	(print var_d, print var_i value 14, ptype modmany, complete `modm)
	(complete `modmany, complete `modmany`, complete `modmany`var)
	(show language, setting breakpoint at module): New tests.
	* gdb.fortran/module.f90 (module mod): Remove.
	(module mod1, module mod2, module modmany, subroutine sub1)
	(subroutine sub2, program module): New.
@
text
@a1056 1
  struct objfile *objfile;
d1124 15
a1138 4
     but more useful than an error.  Do the symtabs first, then check
     the psymtabs.  If a psymtab indicates the existence of the
     desired name as a file-level static, then do psymtab-to-symtab
     conversion on the fly and return the found symbol. */
@


1.237
log
@2010-05-16  Michael Snyder  <msnyder@@vmware.com>

	* scm-exp.c: White space.
	* scm-lang.c: White space.
	* scm-valprint.c: White space.
	* sentinel-frame.c: White space.
	* ser-base.c: White space.
	* ser-go32.c: White space.
	* serial.c: White space.
	* ser-mingw.c: White space.
	* ser-pipe.c: White space.
	* ser-tcp.c: White space.
	* ser-unix.c: White space.
	* solib.c: White space.
	* solib-darwin.c: White space.
	* solib-frv.c: White space.
	* solib-irix.c: White space.
	* solib-osf.c: White space.
	* solib-pa64.c: White space.
	* solib-som.c: White space.
	* solib-spu.c: White space.
	* solib-svr4.c: White space.
	* solib-target.c: White space.
	* source.c: White space.
	* stabsread.c: White space.
	* stack.c: White space.
	* std-regs.c: White space.
	* symfile.c: White space.
	* symmisc.c: White space.
	* symtab.c: White space.
@
text
@d354 2
a355 1
      || gsymbol->language == language_objc)
d469 5
d654 1
d681 1
d1167 1
a1167 1
      if (language == language_cplus)
d3593 2
a3594 1
default_make_symbol_completion_list (char *text, char *word)
d3657 1
a3657 1
		|| p[-1] == ':')
d3783 6
@


1.236
log
@2010-05-05  Michael Snyder  <msnyder@@vmware.com>

	* psymtab.c (lookup_partial_symbol): Delete unused variable.
	(find_last_source_symtab_from_partial): Delete unused variable.
	* symfile.c (place_section): Delete unused variable.
	(default_symfile_offsets): Delete unused variable.
	(get_debug_link_info): Delete unused variable.
	(find_separate_debug_file_by_debuglink): Delete unused variable.
	(add_symbol_file_command): Delete unused variable.
	(symfile_find_segment_sections): Delete unused variable.
	* symmisc.c (free_symtab): Delete unused variable.
	(dump_symtab_1): Delete unused variable.
	* symtab.c (lookup_symbil_aux_quick): Delete unused variable.
	(find_pc_sect_symtab): Delete unused variable.
	(skip_prologue_using_lineinfo): Delete unused variable.
	(sources_info): Delete unused variable.
	(completion_list_add_name): Delete unused variable.
	(expand_line_sal): Delete unused variable.
@
text
@d194 1
d204 1
d208 1
d326 6
a331 7
    {
      mangled_name = (char *) xmalloc (mangled_name_len);
      if (is_constructor)
	mangled_name[0] = '\0';
      else
	strcpy (mangled_name, field_name);
    }
d379 1
d389 1
d548 1
a549 1

d561 1
a562 1

d803 1
d873 1
d963 2
a964 2
  /* If we are using C++, D, or Java, demangle the name before doing a lookup, so
     we can always binary search. */
d1076 1
d1725 1
d1759 1
d2059 2
a2060 1
find_line_symtab (struct symtab *symtab, int line, int *index, int *exact_match)
d2269 1
d2385 1
d2521 1
d2734 1
d2851 1
d2860 1
d2893 1
a2893 2
  =
  {mst_data, mst_text, mst_abs, mst_unknown};
d2895 1
a2895 2
  =
  {mst_bss, mst_file_text, mst_abs, mst_unknown};
d2897 1
a2897 2
  =
  {mst_file_data, mst_solib_trampoline, mst_abs, mst_unknown};
d2899 1
a2899 2
  =
  {mst_file_bss, mst_text, mst_abs, mst_unknown};
d2929 1
d2933 1
d2950 1
d3031 1
d3036 1
d3199 1
a3199 3
  static char *classnames[]
  =
  {"variable", "function", "type", "method"};
d3291 1
d3323 1
d3342 2
a3343 2
	  int newlen = (strlen (SYMBOL_LINKAGE_NAME (p->msymbol))
			+ 3);
d3395 1
d3567 1
d3578 1
d3993 1
d4412 1
@


1.235
log
@	* symtab.c (symbol_set_names): Fix typo.
@
text
@a1297 1
  struct partial_symtab *ps;
a1662 1
  struct partial_symtab *ps;
d2274 1
a2274 3
  int ind, i, len;
  int best_lineno = 0;
  CORE_ADDR best_pc = func_addr;
a2706 1
  struct partial_symtab *ps;
a3364 1
  int i;
a4171 1
	  int exact;
d4431 1
a4431 1
  struct symtabs_and_lines ret, this_line;
a4433 2
  struct partial_symtab *psymtab;
  struct symtab *symtab;
a4512 3
      struct blockvector *bl;
      struct block *b;

@


1.234
log
@D language support.

gdb/ChangeLog:

        D language support.
        * Makefile.in (SFILES): Add d-lang.c d-valprint.c.
        (COMMON_OBS): Add d-lang.o d-valprint.o.
        (HFILES_NO_SRCDIR): Add d-lang.h.
        * NEWS: Mention D language support.
        * c-lang.c (c_emit_char, exp_descriptor_c): Make public.
        * c-lang.h (c_emit_char, exp_descriptor_c): Add declaration.
        * d-lang.c: New file.
        * d-lang.h: New file.
        * d-valprint.c: New file.
        * defs.h (enum language): Add language_d.
        * dwarf2read.c (set_cu_language): Add DW_LANG_D.
        * language.c (binop_result_type, integral_type, character_type)
        (string_type, boolean_type, structured_type): Add language_d.
        * symfile.c (init_filename_language_table): Add language_d.
        * symtab.c: Include d-lang.h.
        (symbol_init_language_specific, symbol_find_demangled_name)
        (symbol_natural_name, lookup_symbol_in_language)
        (symbol_demangled_name, symbol_matches_domain): Add language_d.

gdb/doc/ChangeLog:

        * gdb.texinfo: (Summary) Add mention about D language support.
        (Filenames): Add D suffixes.
        (D): New node.

gdb/testsuite/ChangeLog:

        * gdb.base/default.exp: Fix "set language" test.
@
text
@d593 1
a593 1
	 us better backache hit rates for partial symbols.  */
@


1.233
log
@PR 10179
* symtab.c (rbreak_command): Added code to include a filename
specification in the rbreak argument.
* NEWS: Added a brief description of filename-qualified rbreak.
* gdb.base/Makefile.in (EXECUTABLES): Added pr10179.
* gdb.base/pr10179-a.c:
* gdb.base/pr10179-b.c:
* gdb.base/pr10179.exp: New files.
* gdb.texinfo (Setting Breakpoints): Added description of
filename-qualified rbreak.
* refcard.tex (Breakpoints and Watchpoints): Added brief
description of filename-qualified rbreak.
@
text
@d42 1
d350 1
d454 10
d641 1
d667 1
d957 1
a957 1
  /* If we are using C++ or Java, demangle the name before doing a lookup, so
d989 9
d1438 1
@


1.232
log
@gdb/
	Fix crashes on dangling display expressions.
	* ada-lang.c (ada_operator_check): New function.
	(ada_exp_descriptor): Fill-in the field operator_check.
	* c-lang.c (exp_descriptor_c): Fill-in the field operator_check.
	* jv-lang.c (exp_descriptor_java): Likewise.
	* m2-lang.c (exp_descriptor_modula2): Likewise.
	* scm-lang.c (exp_descriptor_scm): Likewise.
	* parse.c (exp_descriptor_standard): Likewise.
	(operator_check_standard): New function.
	(exp_iterate, exp_uses_objfile_iter, exp_uses_objfile): New functions.
	* parser-defs.h (struct exp_descriptor): New field operator_check.
	(operator_check_standard, exp_uses_objfile): New declarations.
	* printcmd.c: Remove the inclusion of solib.h.
	(display_uses_solib_p): Remove the function.
	(clear_dangling_display_expressions): Call lookup_objfile_from_block
	and exp_uses_objfile instead of display_uses_solib_p.
	* solist.h (struct so_list) <objfile>: New comment.
	* symtab.c (lookup_objfile_from_block): Remove the static qualifier.
	* symtab.h (lookup_objfile_from_block): New declaration.
	(struct general_symbol_info) <obj_section>: Extend the comment.

gdb/testsuite/
	Fix crashes on dangling display expressions.
	* gdb.base/solib-display.exp: Call gdb_gnu_strip_debug if LIBSEPDEBUG
	is SEP.
	(lib_flags): Remove the "debug" keyword.
	(libsepdebug): New variable for iterating new loop.
	(save_pf_prefix): New variable wrapping the loop.
	(sep_lib_flags): New variable derived from LIB_FLAGS.  Use it.
	* lib/gdb.exp (gdb_gnu_strip_debug): Document the return code.
@
text
@d3251 2
d3254 22
a3275 1
  search_symbols (regexp, FUNCTIONS_DOMAIN, 0, (char **) NULL, &ss);
@


1.231
log
@	* symtab.c (find_function_start_sal): Never return SAL pointing
	before function start address, even if line info is missing.
@
text
@d1153 1
a1153 1
static struct objfile *
@


1.230
log
@	* breakpoint.c (expand_line_sal_maybe): Always call skip_prologue_sal.
	(skip_prologue_sal): Remove local definition.
	(resolve_sal_pc): Remove now unnecessary code.
	* linespec.c (minsym_found): Call skip_prologue_sal.
	* symtab.c (find_function_start_pc): Remove.
	(find_function_start_sal): Extract prologue skipping into ...
	(skip_prologue_sal): ... this new function.  Handle code both
	with and without debug info.  Respect SAL's explicit_pc and
	explicit_line flags.  Inline old find_function_start_pc.
	* symtab.h (find_function_start_pc): Remove.
	(skip_prologue_sal): Add prototype.
@
text
@d2298 12
@


1.229
log
@gdb
	PR breakpoints/9352:
	* NEWS: Mention changes to `commands' and `rbreak'.
	* symtab.c (do_end_rbreak_breakpoints): New function.
	(rbreak_command): Call start_rbreak_breakpoints; arrange to call
	end_rbreak_breakpoints.
	* breakpoint.c (breakpoint_count, tracepoint_count): Now static.
	(set_breakpoint_count): Likewise.  Clear last_was_multi.
	(multi_start, multi_end, last_was_multi): New globals.
	(start_rbreak_breakpoints, end_rbreak_breakpoints): New
	functions.
	(struct commands_info): New
	(do_map_commands_command): New function.
	(commands_command_1): New function.
	(commands_command): Use it.
	(commands_from_control_command): Likewise.
	(do_delete_breakpoint): New function.
	(delete_command): Use it.
	(map_breakpoint_numbers): Add 'data' argument.  Pass to callback.
	(do_map_disable_breakpoint): New function.
	(disable_command): Use it.
	(do_map_enable_breakpoint): New function.
	(enable_command): Use it.
	(enable_once_breakpoint): Add argument.
	(enable_once_command): Update.
	(enable_delete_breakpoint): Add argument.
	(enable_delete_command): Update.
	(break_command_really): Set last_was_multi when needed.
	(check_tracepoint_command): Fix formatting.
	(validate_commands_for_breakpoint): New function.
	(breakpoint_set_commands): Use it.
	(tracepoint_save_command): Update.
	* breakpoint.h (start_rbreak_breakpoints, end_rbreak_breakpoints):
	Declare.
gdb/doc
	PR breakpoints/9352:
	* gdb.texinfo (Break Commands): Update.
gdb/testsuite
	PR breakpoints/9352:
	* gdb.base/default.exp: Update.
	* gdb.base/commands.exp: Update.
	* gdb.cp/extern-c.exp: Test setting commands on multiple
	breakpoints at once.
@
text
@a2242 20
/* Given a function start address PC and SECTION, find the first
   address after the function prologue.  */
CORE_ADDR
find_function_start_pc (struct gdbarch *gdbarch,
			CORE_ADDR pc, struct obj_section *section)
{
  /* If the function is in an unmapped overlay, use its unmapped LMA address,
     so that gdbarch_skip_prologue has something unique to work on.  */
  if (section_is_overlay (section) && !section_is_mapped (section))
    pc = overlay_unmapped_address (pc, section);

  pc += gdbarch_deprecated_function_start_offset (gdbarch);
  pc = gdbarch_skip_prologue (gdbarch, pc);

  /* For overlays, map pc back into its mapped VMA range.  */
  pc = overlay_mapped_address (pc, section);

  return pc;
}

d2292 1
a2292 3
  struct block *block = SYMBOL_BLOCK_VALUE (sym);
  struct objfile *objfile = lookup_objfile_from_block (block);
  struct gdbarch *gdbarch = get_objfile_arch (objfile);
d2294 20
d2315 4
a2318 1
  struct symtab_and_line sal;
d2321 3
a2323 1
  struct cleanup *old_chain;
d2326 1
a2326 1
  switch_to_program_space_and_thread (objfile->pspace);
d2328 11
a2338 3
  pc = BLOCK_START (block);
  fixup_symbol_section (sym, objfile);
  if (funfirstline)
d2340 12
a2351 2
      /* Skip "first line" of function (which is actually its prologue).  */
      pc = find_function_start_pc (gdbarch, pc, SYMBOL_OBJ_SECTION (sym));
d2353 17
a2369 1
  sal = find_pc_sect_line (pc, SYMBOL_OBJ_SECTION (sym), 0);
d2373 5
a2377 3
  if (sal.pc != pc
      && BLOCK_START (block) <= sal.end
      && sal.end < BLOCK_END (block))
d2380 1
a2380 1
      pc = sal.end;
d2382 1
a2382 1
      sal = find_pc_sect_line (pc, SYMBOL_OBJ_SECTION (sym), 0);
d2389 2
a2390 4
  if (funfirstline
      && gdbarch_skip_main_prologue_p (gdbarch)
      && SYMBOL_LINKAGE_NAME (sym)
      && strcmp (SYMBOL_LINKAGE_NAME (sym), "main") == 0)
d2394 1
a2394 1
      sal = find_pc_sect_line (pc, SYMBOL_OBJ_SECTION (sym), 0);
d2405 1
a2405 1
  if (funfirstline && sal.symtab == NULL)
d2409 1
a2409 1
      sal = find_pc_sect_line (pc, SYMBOL_OBJ_SECTION (sym), 0);
d2412 18
a2429 2
  sal.pc = pc;
  sal.pspace = objfile->pspace;
d2433 1
a2433 1
  b = block_for_pc_sect (sal.pc, SYMBOL_OBJ_SECTION (sym));
d2446 2
a2447 2
      sal.line = SYMBOL_LINE (BLOCK_FUNCTION (function_block));
      sal.symtab = SYMBOL_SYMTAB (BLOCK_FUNCTION (function_block));
a2448 3

  do_cleanups (old_chain);
  return sal;
@


1.228
log
@	* dwarf2-frame.c (dwarf2_frame_find_quirks): Use producer_is_realview.
	* dwarf2read.c (load_full_comp_unit): Read DW_AT_producer.
	(read_structure_type): For RealView, set TYPE_STUB on structures with
	no byte size and no children.
	(read_subroutine_type): Mark functions as prototyped by default.
	* symtab.c (producer_is_realview): New function.
	* symtab.h (expand_line_sal): Fix declaration formatting.
	(producer_is_realview): Declare.

	testsuite/
	* gdb.base/callfuncs.exp (do_function_calls): Add XFAILs for RealView.
	* gdb.base/ptype.exp (ptype_maybe_prototyped): Add overprototyped
	argument.  Handle "short" and "long".
	(Top level): Pass overprototyped output for old_fptr and xptr.
@
text
@d3173 8
d3187 2
d3192 1
d3194 2
d3200 8
a3207 3
	  char *string = alloca (strlen (p->symtab->filename)
				 + strlen (SYMBOL_LINKAGE_NAME (p->symbol))
				 + 4);
d3221 7
a3227 2
	  char *string = alloca (strlen (SYMBOL_LINKAGE_NAME (p->msymbol))
				 + 3);
@


1.227
log
@
    2010-03-15  Sami Wagiaalla  <swagiaal@@redhat.com>

        PR c++/7936:
        * cp-support.h: Added char *declaration element to using_direct
        data struct.
        (cp_add_using): Added char *declaration argument.
        (cp_add_using_directive): Ditto.
        (cp_lookup_symbol_imports): made extern.
        * cp-namespace.c: Updated with the above changes.
        * dwarf2read.c (read_import_statement): Ditto.
        (read_namespace): Ditto.
        (read_import_statement): Support import declarations.
        * cp-namespace.c (cp_lookup_symbol_imports): Check for imported
        declarations.
        Added support for 'declaration_only' search.
        (cp_lookup_symbol_namespace): Attempt to search for the name as
        is before consideration of imports.
        * symtab.c (lookup_symbol_aux_local): Added a 'declaration_only'
        search at every block level search.
        Now takes language argument.
        (lookup_symbol_aux): Updated.

    2010-03-15  Sami Wagiaalla  <swagiaal@@redhat.com>

        * gdb.cp/shadow.exp: Removed kfail; test has been fix.
        * gdb.cp/nsusing.exp: Ditto.
@
text
@d4427 25
@


1.226
log
@gdb
	* xcoffread.c: Include psymtab.h.
	(xcoff_sym_fns): Update.
	* symtab.h (struct partial_symbol): Remove.
	(PSYMBOL_DOMAIN, PSYMBOL_CLASS): Remove.
	(struct partial_symtab): Remove.
	(PSYMTAB_TO_SYMTAB): Remove.
	(lookup_partial_symbol, lookup_partial_symtab, find_pc_psymtab)
	(find_pc_sect_psymtab): Remove.
	(find_pc_sect_symtab_via_partial): Declare.
	(find_pc_psymtab, find_pc_sect_psymbol, psymtab_to_symtab)
	(find_main_psymtab): Remove.
	(find_main_filename): Declare.
	(fixup_psymbol_section): Remove.
	(fixup_section): Declare.
	* symtab.c: Include psymtab.h.
	(lookup_symtab): Use lookup_symtab method.
	(lookup_partial_symtab): Remove.
	(find_pc_sect_psymtab_closer): Remove.
	(find_pc_sect_psymtab): Remove.
	(find_pc_sect_symtab_via_partial): New function.
	(find_pc_psymtab, find_pc_sect_psymbol, find_pc_psymbol): Remove.
	(fixup_section): No longer static.
	(fixup_psymbol_section): Remove.
	(lookup_symbol_aux): Use lookup_symbol_aux_quick.
	(lookup_global_symbol_from_objfile): Likewise.
	(lookup_symbol_aux_psymtabs): Remove.
	(lookup_symbol_aux_quick): New function.
	(lookup_symbol_global): Use lookup_symbol_aux_quick.
	(lookup_partial_symbol): Remove.
	(basic_lookup_transparent_type_quick): New function.
	(basic_lookup_transparent_type): Use it.
	(find_main_psymtab): Remove.
	(find_main_filename): New function.
	(find_pc_sect_symtab): Use find_pc_sect_symtab method.
	(find_line_symtab): Use expand_symtabs_with_filename method.
	(output_partial_symbol_filename): New function.
	(sources_info): Use map_partial_symbol_filenames.
	(struct search_symbols_data): New type.
	(search_symbols_file_matches): New function.
	(search_symbols_name_matches): Likewise.
	(search_symbols): Use expand_symtabs_matching method.
	(struct add_name_data): Rename from add_macro_name_data.
	(add_macro_name): Update.
	(add_partial_symbol_name): New function.
	(default_make_symbol_completion_list): Use
	map_partial_symbol_names.
	(struct add_partial_symbol_name): New type.
	(maybe_add_partial_symtab_filename): New function.
	(make_source_files_completion_list): Use
	map_partial_symbol_filenames.
	(expand_line_sal): Use expand_symtabs_with_filename method.
	* symmisc.c: Include psymtab.h.
	(print_objfile_statistics): Use print_stats method.
	(dump_objfile): Use dump method.
	(dump_psymtab, maintenance_print_psymbols)
	(maintenance_info_psymtabs, maintenance_check_symtabs)
	(extend_psymbol_list): Remove.
	* symfile.h (struct quick_symbol_functions): New struct.
	(struct sym_fns) <qf>: New field.
	(sort_pst_symbols): Remove.
	(increment_reading_symtab): Declare.
	* symfile.c: Include psymtab.h.
	(compare_psymbols, sort_pst_symbols): Remove.
	(psymtab_to_symtab): Remove.
	(increment_reading_symtab): New function.
	(symbol_file_add_with_addrs_or_offsets): Use expand_all_symtabs
	method.
	(set_initial_language): Use find_main_filename.
	(allocate_psymtab, discard_psymtab, cashier_psymtab): Remove.
	(free_named_symtabs): Remove unused code.
	(start_psymtab_common, add_psymbol_to_bcache)
	(append_psymbol_to_list, add_psymbol_to_list, init_psymbol_list):
	Remove.
	* stack.c: Include psymtab.h, symfile.h.
	(backtrace_command_1): Use find_pc_sect_symtab_via_partial.
	* source.h (psymtab_to_fullname): Don't declare.
	* source.c: Include psymtab.h.
	(select_source_symtab): Use find_last_source_symtab method.
	(forget_cached_source_info): Use forget_cached_source_info
	method.
	(find_and_open_source): No longer static.
	(psymtab_to_fullname): Remove.
	* somread.c: Include psymtab.h.
	(som_sym_fns): Update.
	* psympriv.h: New file.
	* psymtab.h: New file.
	* psymtab.c: New file.
	* objfiles.h: (ALL_OBJFILE_PSYMTABS): Remove.
	(ALL_PSYMTABS, ALL_PSPACE_PSYMTABS): Likewise.
	* objfiles.c: Include psymtab.h.
	(objfile_relocate1): Use relocate method.
	(objfile_has_partial_symbols): Use has_symbols method.
	* mipsread.c: Include psymtab.h.
	(ecoff_sym_fns): Update.
	* mi/mi-cmd-file.c: Include psymtab.h.
	(print_partial_file_name): New function.
	(mi_cmd_file_list_exec_source_files): Use
	map_partial_symbol_filenames.
	* mdebugread.c: Include psympriv.h.
	* machoread.c: Include psympriv.h.
	(macho_sym_fns): Update.
	* m2-exp.y (yylex): Use lookup_symtab.
	* elfread.c: Include psympriv.h.
	(elf_sym_fns): Update.
	* dwarf2read.c: Include psympriv.h.
	* dbxread.c: Include psympriv.h.
	(aout_sym_fns): Update.
	* cp-support.c: Include psymtab.h.
	(read_in_psymtabs): Remove.
	(make_symbol_overload_list_qualified): Use
	expand_symtabs_for_function method.
	* coffread.c: Include psympriv.h.
	(coff_sym_fns): Update.
	* blockframe.c: Include psymtab.h.
	(find_pc_partial_function): Use find_pc_sect_symtab method.
	* ada-lang.h (ada_update_initial_language): Update.
	* ada-lang.c: Include psymtab.h.
	(ada_update_initial_language): Remove 'main_pst' argument.
	(ada_lookup_partial_symbol): Remove.
	(struct ada_psym_data): New type.
	(ada_add_psyms): New function.
	(ada_add_non_local_symbols): Use map_ada_symtabs method.
	(struct add_partial_datum): New type.
	(ada_add_partial_symbol_completions): New function.
	(ada_make_symbol_completion_list): Use map_partial_symbol_names.
	(ada_exception_support_info_sniffer): Update.
	* Makefile.in (SFILES): Add psymtab.c.
	(COMMON_OBS): Add psymtab.o.
	(HFILES_NO_SRCDIR): Add psymtab.h, psympriv.h.
gdb/doc
	* gdbint.texinfo (Symbol Handling): Update.
@
text
@d98 2
a99 1
					const domain_enum domain);
d1033 1
a1033 1
  sym = lookup_symbol_aux_local (name, block, domain);
d1038 1
a1038 1
     check to see if NAME is a field of `this'. */
d1111 2
a1112 1
			 const domain_enum domain)
d1116 2
a1117 1

d1129 12
@


1.225
log
@dwarf2_physname patchset:

	Based on work from Daniel Jacobowitz  <dan@@codesourcery.com>
	* c-typeprint.c (cp_type_print_method_args): For non-static methods,
	print out const or volatile qualifiers, too.
	(c_type_print_args): Add parameters show_artificial and language.
	Skip artificial parameters when requested.
	Use the appropriate language printer.
	(c_type_print_varspec): Tell c_type_print_args to skip artificial
	parameters and pass language_c.
	* dwarf2read.c (die_list): New file global.
	(struct partial_die_info): Update comments for name field.
	(pdi_needs_namespace): Renamed to ...
	(die_needs_namespace): ... this. Rewrite.
	(dwarf2_linkage_name): Remove.
	(add_partial_symbol): Do not predicate the call to
	partial_die_full_name based on pdi_needs_namespace.
	Remove call to cp_check_possible_namespace_symbols and associated
	outdated comments.
	(guess_structure_name): Do not inspect child subprogram DIEs.
	(dwarf2_fullname): Update comments.
	Use die_needs_namespace to assist in computing the name.
	(read_func_scope): Use dwarf2_name to get the DIE's name.
	Use dwarf2_physname to get the "linkage name" of the DIE.
	(dwarf2_add_member_field): Use dwarf2_physname instead of
	dwarf2_linkage_name.
	(read_structure_type): For structs and classes, set TYPE_NAME, too.
	(determine_class): Remove.
	(read_partial_die): Ignore DW_AT_MIPS_linkage_name for all languages
	except Ada.
	(new_symbol): Unconditionally call dwarf2_name.
	Compute the "linkage name" using dwarf2_physname.
	Use dwarf2_name instead of dwarf2_full_name for enumerator DIEs.
	When determining to scan for anonymous C++ namespaces, ignore
	the linkage name.
	(dwarf2_physname): New function.
	(dwarf2_full_name): Move content to new function and call
	that.
	(dwarf2_compute_name): "New" function.
	(_initialize_dwarf2_read): Initialize die_list.
	* gnu-v3-eabi.c (gnu_v3_find_method_in): Remove unused variable
	physname.
	(gnu_v3_print_method_ptr): Use the physname for virtual methods
	without a demangled name.
	Print out type information for non-virtual methods.
        * linespec.c (decode_line_1): Force ANY string using "::" (or
	"." for java) to use decode_compound, and clean up any stray quoting.
        If we found a file symtab, re-evaluate whether the remainder is_quoted.
        (decode_compound): Stop consuming at an open parenthesis.
        Keep template parameters.
        Keep any overload information.
        Keep keywords like "const".
        Remove paren_pointer.
        Move is_quoted check from set_flags to here.
        Remove #if 0 code from 2000. Ten years is long enough.
        (find_method): Before comparing symbol names, canonicalize the string
        from the user.
        If a specific overload is requested, find it. Otherwise throw an error.
	(find_method_overload_end): New function.
	(set_flags): Remove.
        (decode_compound): Assume that parentheses are matched.
        It's a lot easier.
	* symtab.c (symbol_find_demangled_name): Add DMGL_VERBOSE flag
	to cplus_demangle.
	* linespec.c (decode_line_1): Keep important keywords like
	"const" and "volatile".
	* symtab.h (SYMBOL_CPLUS_DEMANGLED_NAME): Remove.
	* typeprint.h (c_type_print_args): Add declaration.
	* ui-file.c (do_ui_file_obsavestring): New function.
	(ui_file_obsavestring): New function.
	* ui-file.h (ui_file_obsavestring): Add declaration.
	* valops.c (find_overload_match): Resolve the object to
	a non-pointer type.
	If the object is a data member, search the object for the member
	and return with staticp set.
	Use SYMBOL_NATURAL_NAME instead of SYMBOL_CPLUS_DEMANGLED_NAME.
	Do not attempt to extract a function name from non-function types.
	If the extracted function name and the original name are the same,
	we don't have a C++ method.

	From Jan Kratochvil  <jan.kratochvil@@redhat.com>:
    	* dwarf2read.c (new_symbol <DW_TAG_enumerator>): Call dwarf2_full_name.

	* ada-lang.c (ada_lookup_symbol): Remove linkage_name parameters
	and arguments from symbol lookups.
	* ax-gdb.c (gen_expr): Likewise.
	* cp-namespace.c (cp_lookup_symbol_nonlocal, lookup_namespace_scope,
	cp_lookup_symbol_namespace, lookup_symbol_file, lookup_nested_type,
	lookup_possible_namespace_symbol): Likewise.
	* cp-support.c (read_in_psymtabs): Likewise.
	* cp-support.h (cp_lookup_symbol_nonlocal): Likewise.
	* language.h (la_lookup_symbol_nonlocal): Likewise.
	* scm-valprint.c (scm_inferior_print): Likewise.
	* solib-darwin.c (darwin_relocate_section_addresses): Likewise.
	* solib-svr.c (elf_lookup_lib): Likewise.
	* solib.c (show_auto_solib_add): Likewise.
	* solist.h (lookup_lib_global, solib_global_lookup): Likewise.
	* symmisc.c (maintenance_check_symtabs): Likewise.
	* symtab.c (lookup_symbol_in_language, lookup_symbol_aux,
	lookup_symbol_aux_local, lookup_symbol_aux_block,
	lookup_symbol_from_objfile, lookup_symbol_aux_symtabs,
	lookup_symbol_aux_psymtabs,basic_lookup_symbol_nonlocal,
	lookup_symbol_static, lookup_symbol_global, symbol_matches_domain,
	basic_lookup_transparent_type, find_main_psymtab,
	lookup_block_symbol): Likewise.
	* symtab.h (basic_lookp_symbol_nonlocal, lookup_symbol_static,
	lookup_symbol_global, lookup_symbol_aux_block,
	lookup_symbol_partial_symbol, lookup_block_symbol,
	lookup_global_symbol, value_maybe_namespace_elt): Likewise.
@
text
@d65 2
d106 4
a109 5
struct symbol *lookup_symbol_aux_psymtabs (int block_index,
					   const char *name,
					   const domain_enum domain);

static int file_matches (char *, char **, int);
d159 2
a160 2
  struct symtab *s;
  struct partial_symtab *ps;
d225 11
a235 3
  ps = lookup_partial_symtab (name);
  if (!ps)
    return (NULL);
d237 1
a237 7
  if (ps->readin)
    error (_("Internal: readin %s pst for `%s' found when no symtab found."),
	   ps->filename, name);

  s = PSYMTAB_TO_SYMTAB (ps);

  if (s)
d239 2
a251 69

/* Lookup the partial symbol table of a source file named NAME.
   *If* there is no '/' in the name, a match after a '/'
   in the psymtab filename will also work.  */

struct partial_symtab *
lookup_partial_symtab (const char *name)
{
  struct partial_symtab *pst;
  struct objfile *objfile;
  char *full_path = NULL;
  char *real_path = NULL;

  /* Here we are interested in canonicalizing an absolute path, not
     absolutizing a relative path.  */
  if (IS_ABSOLUTE_PATH (name))
    {
      full_path = xfullpath (name);
      make_cleanup (xfree, full_path);
      real_path = gdb_realpath (name);
      make_cleanup (xfree, real_path);
    }

  ALL_PSYMTABS (objfile, pst)
  {
    if (FILENAME_CMP (name, pst->filename) == 0)
      {
	return (pst);
      }

    /* If the user gave us an absolute path, try to find the file in
       this symtab and use its absolute path.  */
    if (full_path != NULL)
      {
	psymtab_to_fullname (pst);
	if (pst->fullname != NULL
	    && FILENAME_CMP (full_path, pst->fullname) == 0)
	  {
	    return pst;
	  }
      }

    if (real_path != NULL)
      {
        char *rp = NULL;
	psymtab_to_fullname (pst);
        if (pst->fullname != NULL)
          {
            rp = gdb_realpath (pst->fullname);
            make_cleanup (xfree, rp);
          }
	if (rp != NULL && FILENAME_CMP (real_path, rp) == 0)
	  {
	    return pst;
	  }
      }
  }

  /* Now, search for a matching tail (only if name doesn't have any dirs) */

  if (lbasename (name) == name)
    ALL_PSYMTABS (objfile, pst)
    {
      if (FILENAME_CMP (lbasename (pst->filename), name) == 0)
	return (pst);
    }

  return (NULL);
}
d763 2
a764 83
/* Find which partial symtab contains PC and SECTION starting at psymtab PST.
   We may find a different psymtab than PST.  See FIND_PC_SECT_PSYMTAB.  */

static struct partial_symtab *
find_pc_sect_psymtab_closer (CORE_ADDR pc, struct obj_section *section,
			     struct partial_symtab *pst,
			     struct minimal_symbol *msymbol)
{
  struct objfile *objfile = pst->objfile;
  struct partial_symtab *tpst;
  struct partial_symtab *best_pst = pst;
  CORE_ADDR best_addr = pst->textlow;

  /* An objfile that has its functions reordered might have
     many partial symbol tables containing the PC, but
     we want the partial symbol table that contains the
     function containing the PC.  */
  if (!(objfile->flags & OBJF_REORDERED) &&
      section == 0)	/* can't validate section this way */
    return pst;

  if (msymbol == NULL)
    return (pst);

  /* The code range of partial symtabs sometimes overlap, so, in
     the loop below, we need to check all partial symtabs and
     find the one that fits better for the given PC address. We
     select the partial symtab that contains a symbol whose
     address is closest to the PC address.  By closest we mean
     that find_pc_sect_symbol returns the symbol with address
     that is closest and still less than the given PC.  */
  for (tpst = pst; tpst != NULL; tpst = tpst->next)
    {
      if (pc >= tpst->textlow && pc < tpst->texthigh)
	{
	  struct partial_symbol *p;
	  CORE_ADDR this_addr;

	  /* NOTE: This assumes that every psymbol has a
	     corresponding msymbol, which is not necessarily
	     true; the debug info might be much richer than the
	     object's symbol table.  */
	  p = find_pc_sect_psymbol (tpst, pc, section);
	  if (p != NULL
	      && SYMBOL_VALUE_ADDRESS (p)
	      == SYMBOL_VALUE_ADDRESS (msymbol))
	    return tpst;

	  /* Also accept the textlow value of a psymtab as a
	     "symbol", to provide some support for partial
	     symbol tables with line information but no debug
	     symbols (e.g. those produced by an assembler).  */
	  if (p != NULL)
	    this_addr = SYMBOL_VALUE_ADDRESS (p);
	  else
	    this_addr = tpst->textlow;

	  /* Check whether it is closer than our current
	     BEST_ADDR.  Since this symbol address is
	     necessarily lower or equal to PC, the symbol closer
	     to PC is the symbol which address is the highest.
	     This way we return the psymtab which contains such
	     best match symbol. This can help in cases where the
	     symbol information/debuginfo is not complete, like
	     for instance on IRIX6 with gcc, where no debug info
	     is emitted for statics. (See also the nodebug.exp
	     testcase.) */
	  if (this_addr > best_addr)
	    {
	      best_addr = this_addr;
	      best_pst = tpst;
	    }
	}
    }
  return best_pst;
}

/* Find which partial symtab contains PC and SECTION.  Return 0 if
   none.  We return the psymtab that contains a symbol whose address
   exactly matches PC, or, if we cannot find an exact match, the
   psymtab that contains a symbol whose address is closest to PC.  */
struct partial_symtab *
find_pc_sect_psymtab (CORE_ADDR pc, struct obj_section *section)
a780 3
  /* Try just the PSYMTABS_ADDRMAP mapping first as it has better granularity
     than the later used TEXTLOW/TEXTHIGH one.  */

d782 8
a789 58
    if (objfile->psymtabs_addrmap != NULL)
      {
	struct partial_symtab *pst;

	pst = addrmap_find (objfile->psymtabs_addrmap, pc);
	if (pst != NULL)
	  {
	    /* FIXME: addrmaps currently do not handle overlayed sections,
	       so fall back to the non-addrmap case if we're debugging
	       overlays and the addrmap returned the wrong section.  */
	    if (overlay_debugging && msymbol && section)
	      {
		struct partial_symbol *p;
		/* NOTE: This assumes that every psymbol has a
		   corresponding msymbol, which is not necessarily
		   true; the debug info might be much richer than the
		   object's symbol table.  */
		p = find_pc_sect_psymbol (pst, pc, section);
		if (!p
		    || SYMBOL_VALUE_ADDRESS (p)
		       != SYMBOL_VALUE_ADDRESS (msymbol))
		  continue;
	      }

	    /* We do not try to call FIND_PC_SECT_PSYMTAB_CLOSER as
	       PSYMTABS_ADDRMAP we used has already the best 1-byte
	       granularity and FIND_PC_SECT_PSYMTAB_CLOSER may mislead us into
	       a worse chosen section due to the TEXTLOW/TEXTHIGH ranges
	       overlap.  */

	    return pst;
	  }
      }

  /* Existing PSYMTABS_ADDRMAP mapping is present even for PARTIAL_SYMTABs
     which still have no corresponding full SYMTABs read.  But it is not
     present for non-DWARF2 debug infos not supporting PSYMTABS_ADDRMAP in GDB
     so far.  */

  ALL_OBJFILES (objfile)
    {
      struct partial_symtab *pst;

      /* Check even OBJFILE with non-zero PSYMTABS_ADDRMAP as only several of
	 its CUs may be missing in PSYMTABS_ADDRMAP as they may be varying
	 debug info type in single OBJFILE.  */

      ALL_OBJFILE_PSYMTABS (objfile, pst)
	if (pc >= pst->textlow && pc < pst->texthigh)
	  {
	    struct partial_symtab *best_pst;

	    best_pst = find_pc_sect_psymtab_closer (pc, section, pst,
						    msymbol);
	    if (best_pst != NULL)
	      return best_pst;
	  }
    }
a792 90

/* Find which partial symtab contains PC.  Return 0 if none.
   Backward compatibility, no section */

struct partial_symtab *
find_pc_psymtab (CORE_ADDR pc)
{
  return find_pc_sect_psymtab (pc, find_pc_mapped_section (pc));
}

/* Find which partial symbol within a psymtab matches PC and SECTION.
   Return 0 if none.  Check all psymtabs if PSYMTAB is 0.  */

struct partial_symbol *
find_pc_sect_psymbol (struct partial_symtab *psymtab, CORE_ADDR pc,
		      struct obj_section *section)
{
  struct partial_symbol *best = NULL, *p, **pp;
  CORE_ADDR best_pc;

  if (!psymtab)
    psymtab = find_pc_sect_psymtab (pc, section);
  if (!psymtab)
    return 0;

  /* Cope with programs that start at address 0 */
  best_pc = (psymtab->textlow != 0) ? psymtab->textlow - 1 : 0;

  /* Search the global symbols as well as the static symbols, so that
     find_pc_partial_function doesn't use a minimal symbol and thus
     cache a bad endaddr.  */
  for (pp = psymtab->objfile->global_psymbols.list + psymtab->globals_offset;
    (pp - (psymtab->objfile->global_psymbols.list + psymtab->globals_offset)
     < psymtab->n_global_syms);
       pp++)
    {
      p = *pp;
      if (SYMBOL_DOMAIN (p) == VAR_DOMAIN
	  && SYMBOL_CLASS (p) == LOC_BLOCK
	  && pc >= SYMBOL_VALUE_ADDRESS (p)
	  && (SYMBOL_VALUE_ADDRESS (p) > best_pc
	      || (psymtab->textlow == 0
		  && best_pc == 0 && SYMBOL_VALUE_ADDRESS (p) == 0)))
	{
	  if (section)		/* match on a specific section */
	    {
	      fixup_psymbol_section (p, psymtab->objfile);
	      if (!matching_obj_sections (SYMBOL_OBJ_SECTION (p), section))
		continue;
	    }
	  best_pc = SYMBOL_VALUE_ADDRESS (p);
	  best = p;
	}
    }

  for (pp = psymtab->objfile->static_psymbols.list + psymtab->statics_offset;
    (pp - (psymtab->objfile->static_psymbols.list + psymtab->statics_offset)
     < psymtab->n_static_syms);
       pp++)
    {
      p = *pp;
      if (SYMBOL_DOMAIN (p) == VAR_DOMAIN
	  && SYMBOL_CLASS (p) == LOC_BLOCK
	  && pc >= SYMBOL_VALUE_ADDRESS (p)
	  && (SYMBOL_VALUE_ADDRESS (p) > best_pc
	      || (psymtab->textlow == 0
		  && best_pc == 0 && SYMBOL_VALUE_ADDRESS (p) == 0)))
	{
	  if (section)		/* match on a specific section */
	    {
	      fixup_psymbol_section (p, psymtab->objfile);
	      if (!matching_obj_sections (SYMBOL_OBJ_SECTION (p), section))
		continue;
	    }
	  best_pc = SYMBOL_VALUE_ADDRESS (p);
	  best = p;
	}
    }

  return best;
}

/* Find which partial symbol within a psymtab matches PC.  Return 0 if none.
   Check all psymtabs if PSYMTAB is 0.  Backwards compatibility, no section. */

struct partial_symbol *
find_pc_psymbol (struct partial_symtab *psymtab, CORE_ADDR pc)
{
  return find_pc_sect_psymbol (psymtab, pc, find_pc_mapped_section (pc));
}
d797 1
a797 1
static void
a910 31
struct partial_symbol *
fixup_psymbol_section (struct partial_symbol *psym, struct objfile *objfile)
{
  CORE_ADDR addr;

  if (!psym)
    return NULL;

  if (SYMBOL_OBJ_SECTION (psym))
    return psym;

  gdb_assert (objfile);

  switch (SYMBOL_CLASS (psym))
    {
    case LOC_STATIC:
    case LOC_LABEL:
    case LOC_BLOCK:
      addr = SYMBOL_VALUE_ADDRESS (psym);
      break;
    default:
      /* Nothing else will be listed in the minsyms -- no use looking
	 it up.  */
      return psym;
    }

  fixup_section (&psym->ginfo, addr, objfile);

  return psym;
}

d1019 1
d1095 6
a1100 3
  sym = lookup_symbol_aux_psymtabs (STATIC_BLOCK, name, domain);
  if (sym != NULL)
    return sym;
a1192 1
  struct partial_symtab *ps;
d1211 4
a1214 13
      /* Now go through psymtabs.  */
      ALL_OBJFILE_PSYMTABS (objfile, ps)
        {
          if (!ps->readin
              && lookup_partial_symbol (ps, name, 1, domain))
            {
              s = PSYMTAB_TO_SYMTAB (ps);
              bv = BLOCKVECTOR (s);
              block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
              sym = lookup_block_symbol (block, name, domain);
              return fixup_symbol_section (sym, (struct objfile *)objfile);
            }
        }
d1250 2
a1251 4
/* Check to see if the symbol is defined in one of the partial
   symtabs.  BLOCK_INDEX should be either GLOBAL_BLOCK or
   STATIC_BLOCK, depending on whether or not we want to search global
   symbols or static symbols.  */
d1254 2
a1255 2
lookup_symbol_aux_psymtabs (int block_index, const char *name,
			    const domain_enum domain)
d1257 1
a1257 2
  struct symbol *sym;
  struct objfile *objfile;
d1261 1
a1261 2
  struct symtab *s;
  const int psymtab_index = (block_index == GLOBAL_BLOCK ? 1 : 0);
d1263 5
a1267 34
  ALL_PSYMTABS (objfile, ps)
  {
    if (!ps->readin
	&& lookup_partial_symbol (ps, name, psymtab_index, domain))
      {
	s = PSYMTAB_TO_SYMTAB (ps);
	bv = BLOCKVECTOR (s);
	block = BLOCKVECTOR_BLOCK (bv, block_index);
	sym = lookup_block_symbol (block, name, domain);
	if (!sym)
	  {
	    /* This shouldn't be necessary, but as a last resort try
	       looking in the statics even though the psymtab claimed
	       the symbol was global, or vice-versa. It's possible
	       that the psymtab gets it wrong in some cases.  */

	    /* FIXME: carlton/2002-09-30: Should we really do that?
	       If that happens, isn't it likely to be a GDB error, in
	       which case we should fix the GDB error rather than
	       silently dealing with it here?  So I'd vote for
	       removing the check for the symbol in the other
	       block.  */
	    block = BLOCKVECTOR_BLOCK (bv,
				       block_index == GLOBAL_BLOCK ?
				       STATIC_BLOCK : GLOBAL_BLOCK);
	    sym = lookup_block_symbol (block, name, domain);
	    if (!sym)
	      error (_("Internal: %s symbol `%s' found in %s psymtab but not in symtab.\n%s may be an inlined function, or may be a template function\n(if a template, try specifying an instantiation: %s<type>)."),
		     block_index == GLOBAL_BLOCK ? "global" : "static",
		     name, ps->filename, name, name);
	  }
	return fixup_symbol_section (sym, objfile);
      }
  }
d1269 26
a1294 1
  return NULL;
d1381 8
a1388 1
  return lookup_symbol_aux_psymtabs (GLOBAL_BLOCK, name, domain);
d1411 3
a1413 2
/* Look, in partial_symtab PST, for symbol whose natural name is NAME.
   Check the global symbols if GLOBAL, the static symbols if not. */
d1415 2
a1416 3
struct partial_symbol *
lookup_partial_symbol (struct partial_symtab *pst, const char *name,
		       int global, domain_enum domain)
d1418 2
a1419 5
  struct partial_symbol *temp;
  struct partial_symbol **start, **psym;
  struct partial_symbol **top, **real_top, **bottom, **center;
  int length = (global ? pst->n_global_syms : pst->n_static_syms);
  int do_linear_search = 1;
d1421 2
a1422 7
  if (length == 0)
    {
      return (NULL);
    }
  start = (global ?
	   pst->objfile->global_psymbols.list + pst->globals_offset :
	   pst->objfile->static_psymbols.list + pst->statics_offset);
d1424 8
a1431 3
  if (global)			/* This means we can use a binary search. */
    {
      do_linear_search = 0;
d1433 5
a1437 5
      /* Binary search.  This search is guaranteed to end with center
         pointing at the earliest partial symbol whose name might be
         correct.  At that point *all* partial symbols with an
         appropriate name will be checked against the correct
         domain.  */
d1439 6
a1444 24
      bottom = start;
      top = start + length - 1;
      real_top = top;
      while (top > bottom)
	{
	  center = bottom + (top - bottom) / 2;
	  if (!(center < top))
	    internal_error (__FILE__, __LINE__, _("failed internal consistency check"));
	  if (!do_linear_search
	      && (SYMBOL_LANGUAGE (*center) == language_java))
	    {
	      do_linear_search = 1;
	    }
	  if (strcmp_iw_ordered (SYMBOL_SEARCH_NAME (*center), name) >= 0)
	    {
	      top = center;
	    }
	  else
	    {
	      bottom = center + 1;
	    }
	}
      if (!(top == bottom))
	internal_error (__FILE__, __LINE__, _("failed internal consistency check"));
d1446 13
a1458 8
      while (top <= real_top
	     && SYMBOL_MATCHES_SEARCH_NAME (*top, name))
	{
	  if (symbol_matches_domain (SYMBOL_LANGUAGE (*top),
				     SYMBOL_DOMAIN (*top), domain))
	    return (*top);
	  top++;
	}
d1460 2
d1463 1
a1463 25
  /* Can't use a binary search or else we found during the binary search that
     we should also do a linear search. */

  if (do_linear_search)
    {
      for (psym = start; psym < start + length; psym++)
	{
	  if (symbol_matches_domain (SYMBOL_LANGUAGE (*psym),
				     SYMBOL_DOMAIN (*psym), domain)
	      && SYMBOL_MATCHES_SEARCH_NAME (*psym, name))
	    return (*psym);
	}
    }

  return (NULL);
}

/* Look up a type named NAME in the struct_domain.  The type returned
   must not be opaque -- i.e., must have at least one field
   defined.  */

struct type *
lookup_transparent_type (const char *name)
{
  return current_language->la_lookup_transparent_type (name);
a1476 1
  struct partial_symtab *ps;
d1480 1
d1498 1
a1498 1
  ALL_PSYMTABS (objfile, ps)
d1500 3
a1502 24
    if (!ps->readin && lookup_partial_symbol (ps, name, 1, STRUCT_DOMAIN))
      {
	s = PSYMTAB_TO_SYMTAB (ps);
	bv = BLOCKVECTOR (s);
	block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
	sym = lookup_block_symbol (block, name, STRUCT_DOMAIN);
	if (!sym)
	  {
	    /* This shouldn't be necessary, but as a last resort
	     * try looking in the statics even though the psymtab
	     * claimed the symbol was global. It's possible that
	     * the psymtab gets it wrong in some cases.
	     */
	    block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
	    sym = lookup_block_symbol (block, name, STRUCT_DOMAIN);
	    if (!sym)
	      error (_("Internal: global symbol `%s' found in %s psymtab but not in symtab.\n\
%s may be an inlined function, or may be a template function\n\
(if a template, try specifying an instantiation: %s<type>)."),
		     name, ps->filename, name, name);
	  }
	if (!TYPE_IS_OPAQUE (SYMBOL_TYPE (sym)))
	  return SYMBOL_TYPE (sym);
      }
d1524 1
a1524 1
  ALL_PSYMTABS (objfile, ps)
d1526 3
a1528 24
    if (!ps->readin && lookup_partial_symbol (ps, name, 0, STRUCT_DOMAIN))
      {
	s = PSYMTAB_TO_SYMTAB (ps);
	bv = BLOCKVECTOR (s);
	block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
	sym = lookup_block_symbol (block, name, STRUCT_DOMAIN);
	if (!sym)
	  {
	    /* This shouldn't be necessary, but as a last resort
	     * try looking in the globals even though the psymtab
	     * claimed the symbol was static. It's possible that
	     * the psymtab gets it wrong in some cases.
	     */
	    block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
	    sym = lookup_block_symbol (block, name, STRUCT_DOMAIN);
	    if (!sym)
	      error (_("Internal: static symbol `%s' found in %s psymtab but not in symtab.\n\
%s may be an inlined function, or may be a template function\n\
(if a template, try specifying an instantiation: %s<type>)."),
		     name, ps->filename, name, name);
	  }
	if (!TYPE_IS_OPAQUE (SYMBOL_TYPE (sym)))
	  return SYMBOL_TYPE (sym);
      }
d1530 1
d1535 1
a1535 1
/* Find the psymtab containing main(). */
d1539 2
a1540 2
struct partial_symtab *
find_main_psymtab (void)
a1541 1
  struct partial_symtab *pst;
d1543 1
d1545 1
a1545 1
  ALL_PSYMTABS (objfile, pst)
d1547 5
a1551 4
    if (lookup_partial_symbol (pst, main_name (), 1, VAR_DOMAIN))
      {
	return (pst);
      }
d1678 1
a1678 1
	if ((objfile->flags & OBJF_REORDERED) && objfile->psymtabs)
d1680 8
a1687 3
	    ps = find_pc_sect_psymtab (pc, section);
	    if (ps)
	      return PSYMTAB_TO_SYMTAB (ps);
d1711 14
a1724 14
  s = NULL;
  ps = find_pc_sect_psymtab (pc, section);
  if (ps)
    {
      if (ps->readin)
	/* Might want to error() here (in case symtab is corrupt and
	   will cause a core dump), but maybe we can successfully
	   continue, so let's not.  */
	warning (_("\
(Internal error: pc %s in read in psymtab, but not in symtab.)\n"),
		 paddress (get_objfile_arch (ps->objfile), pc));
      s = PSYMTAB_TO_SYMTAB (ps);
    }
  return (s);
a2043 1
      struct partial_symtab *p;
d2050 1
a2050 1
      ALL_PSYMTABS (objfile, p)
d2052 3
a2054 3
        if (FILENAME_CMP (symtab->filename, p->filename) != 0)
          continue;
        PSYMTAB_TO_SYMTAB (p);
d2598 8
d2632 1
a2632 8
  ALL_PSYMTABS (objfile, ps)
  {
    if (!ps->readin)
      {
	const char *fullname = psymtab_to_fullname (ps);
	output_source_filename (fullname ? fullname : ps->filename, &first);
      }
  }
d2637 1
a2637 1
file_matches (char *file, char *files[], int nfiles)
d2727 25
a2770 1
  struct partial_symtab *ps;
a2775 1
  struct partial_symbol **psym;
d2800 1
d2853 4
a2856 1
  ALL_PSYMTABS (objfile, ps)
d2858 6
a2863 52
    struct partial_symbol **bound, **gbound, **sbound;
    int keep_going = 1;

    if (ps->readin)
      continue;

    gbound = objfile->global_psymbols.list + ps->globals_offset + ps->n_global_syms;
    sbound = objfile->static_psymbols.list + ps->statics_offset + ps->n_static_syms;
    bound = gbound;

    /* Go through all of the symbols stored in a partial
       symtab in one loop. */
    psym = objfile->global_psymbols.list + ps->globals_offset;
    while (keep_going)
      {
	if (psym >= bound)
	  {
	    if (bound == gbound && ps->n_static_syms != 0)
	      {
		psym = objfile->static_psymbols.list + ps->statics_offset;
		bound = sbound;
	      }
	    else
	      keep_going = 0;
	    continue;
	  }
	else
	  {
	    QUIT;

	    /* If it would match (logic taken from loop below)
	       load the file and go on to the next one.  We check the
	       filename here, but that's a bit bogus: we don't know
	       what file it really comes from until we have full
	       symtabs.  The symbol might be in a header file included by
	       this psymtab.  This only affects Insight.  */
	    if (file_matches (ps->filename, files, nfiles)
		&& ((regexp == NULL
		     || re_exec (SYMBOL_NATURAL_NAME (*psym)) != 0)
		    && ((kind == VARIABLES_DOMAIN && SYMBOL_CLASS (*psym) != LOC_TYPEDEF
			 && SYMBOL_CLASS (*psym) != LOC_UNRESOLVED
			 && SYMBOL_CLASS (*psym) != LOC_BLOCK
			 && SYMBOL_CLASS (*psym) != LOC_CONST)
			|| (kind == FUNCTIONS_DOMAIN && SYMBOL_CLASS (*psym) == LOC_BLOCK)
			|| (kind == TYPES_DOMAIN && SYMBOL_CLASS (*psym) == LOC_TYPEDEF))))
	      {
		PSYMTAB_TO_SYMTAB (ps);
		keep_going = 0;
	      }
	  }
	psym++;
      }
d3390 4
a3393 4
/* Type of the user_data argument passed to add_macro_name.  The
   contents are simply whatever is needed by
   completion_list_add_name.  */
struct add_macro_name_data
d3407 11
a3417 1
  struct add_macro_name_data *datum = (struct add_macro_name_data *) user_data;
a3431 1
  struct partial_symtab *ps;
a3436 1
  struct partial_symbol **psym;
d3441 1
d3503 5
d3510 1
a3510 27

  ALL_PSYMTABS (objfile, ps)
  {
    /* If the psymtab's been read in we'll get it when we search
       through the blockvector.  */
    if (ps->readin)
      continue;

    for (psym = objfile->global_psymbols.list + ps->globals_offset;
	 psym < (objfile->global_psymbols.list + ps->globals_offset
		 + ps->n_global_syms);
	 psym++)
      {
	/* If interrupted, then quit. */
	QUIT;
	COMPLETION_LIST_ADD_SYMBOL (*psym, sym_text, sym_text_len, text, word);
      }

    for (psym = objfile->static_psymbols.list + ps->statics_offset;
	 psym < (objfile->static_psymbols.list + ps->statics_offset
		 + ps->n_static_syms);
	 psym++)
      {
	QUIT;
	COMPLETION_LIST_ADD_SYMBOL (*psym, sym_text, sym_text_len, text, word);
      }
  }
a3589 6
      struct add_macro_name_data datum;

      datum.sym_text = sym_text;
      datum.sym_text_len = sym_text_len;
      datum.text = text;
      datum.word = word;
d3794 51
a3853 1
  struct partial_symtab *ps;
d3861 1
d3905 8
a3912 36
  ALL_PSYMTABS (objfile, ps)
    {
      if (not_interesting_fname (ps->filename))
	continue;
      if (!ps->readin)
	{
	  if (!filename_seen (ps->filename, 1, &first)
#if HAVE_DOS_BASED_FILE_SYSTEM
	      && strncasecmp (ps->filename, text, text_len) == 0
#else
	      && strncmp (ps->filename, text, text_len) == 0
#endif
	      )
	    {
	      /* This file matches for a completion; add it to the
		 current list of matches.  */
	      add_filename_to_list (ps->filename, text, word,
				    &list, &list_used, &list_alloced);

	    }
	  else
	    {
	      base_name = lbasename (ps->filename);
	      if (base_name != ps->filename
		  && !filename_seen (base_name, 1, &first)
#if HAVE_DOS_BASED_FILE_SYSTEM
		  && strncasecmp (base_name, text, text_len) == 0
#else
		  && strncmp (base_name, text, text_len) == 0
#endif
		  )
		add_filename_to_list (base_name, text, word,
				      &list, &list_used, &list_alloced);
	    }
	}
    }
d4337 3
a4339 1
	ALL_PSPACE_PSYMTABS (pspace, objfile, psymtab)
d4341 3
a4343 6
	  if (FILENAME_CMP (match_filename, psymtab->filename) == 0)
	    {
	      set_current_program_space (pspace);

	      PSYMTAB_TO_SYMTAB (psymtab);
	    }
d4345 1
@


1.224
log
@2010-01-26  Sami Wagiaalla  <swagiaal@@redhat.com>

	* gdb.cp/namespace-using.exp: Add test for printing of namespaces
	imported into file scope.
	Marked test as xfail.
	* gdb.cp/namespace-using.cc (marker5): New function.
	* gdb.cp/shadow.exp: New test.
	* gdb.cp/shadow.cc: New test program.
	* gdb.cp/nsimport.exp: New test.
	* gdb.cp/nsimport.cc: New test program.

2010-01-26  Sami Wagiaalla  <swagiaal@@redhat.com>

	PR gdb/10929:
	* dwarf2read.c (read_lexical_block_scope): Create blocks for
	scopes which contain using directives even if they contain no
	declarations.
	* symtab.c (lookup_symbol_aux): Pass lowest level block to
	la_lookup_symbol_nonlocal.
	* cp-namespace.c (cp_lookup_symbol_nonlocal): call
	cp_lookup_symbol_namespace.
	(cp_lookup_symbol_namespace): Perform an import lookup at every
	block level.
	(cp_lookup_symbol_imports): New function.
	(cp_lookup_symbol_in_namespace): New function.
@
text
@a87 1
					 const char *linkage_name,
a94 1
					const char *linkage_name,
a100 1
					  const char *linkage_name,
a105 1
					   const char *linkage_name,
d497 1
a497 1
        cplus_demangle (mangled, DMGL_PARAMS | DMGL_ANSI);
a1255 1
  const char *mangled_name = NULL;
a1267 1
	  mangled_name = name;
a1288 1
	  mangled_name = name;
d1307 2
a1308 2
  returnval = lookup_symbol_aux (modified_name, mangled_name, block,
				 domain, lang, is_a_field_of_this);
d1332 3
a1334 3
lookup_symbol_aux (const char *name, const char *linkage_name,
		   const struct block *block, const domain_enum domain,
		   enum language language, int *is_a_field_of_this)
d1350 1
a1350 1
  sym = lookup_symbol_aux_local (name, linkage_name, block, domain);
d1371 1
a1371 1
				   NULL, VAR_DOMAIN);
d1399 1
a1399 1
  sym = langdef->la_lookup_symbol_nonlocal (name, linkage_name, block, domain);
d1409 1
a1409 1
  sym = lookup_symbol_aux_symtabs (STATIC_BLOCK, name, linkage_name, domain);
d1413 1
a1413 1
  sym = lookup_symbol_aux_psymtabs (STATIC_BLOCK, name, linkage_name, domain);
d1424 1
a1424 2
lookup_symbol_aux_local (const char *name, const char *linkage_name,
			 const struct block *block,
d1437 1
a1437 1
      sym = lookup_symbol_aux_block (name, linkage_name, block, domain);
d1480 1
a1480 2
lookup_symbol_aux_block (const char *name, const char *linkage_name,
			 const struct block *block,
d1485 1
a1485 1
  sym = lookup_block_symbol (block, name, linkage_name, domain);
a1500 1
				   const char *linkage_name,
d1519 1
a1519 1
          sym = lookup_block_symbol (block, name, linkage_name, domain);
d1531 1
a1531 2
              && lookup_partial_symbol (ps, name, linkage_name,
                                        1, domain))
d1536 1
a1536 1
              sym = lookup_block_symbol (block, name, linkage_name, domain);
d1551 1
a1551 2
lookup_symbol_aux_symtabs (int block_index,
			   const char *name, const char *linkage_name,
d1564 1
a1564 1
    sym = lookup_block_symbol (block, name, linkage_name, domain);
a1581 1
			    const char *linkage_name,
d1595 1
a1595 2
	&& lookup_partial_symbol (ps, name, linkage_name,
				  psymtab_index, domain))
d1600 1
a1600 1
	sym = lookup_block_symbol (block, name, linkage_name, domain);
d1617 1
a1617 1
	    sym = lookup_block_symbol (block, name, linkage_name, domain);
a1635 1
			      const char *linkage_name,
d1669 1
a1669 1
  sym = lookup_symbol_static (name, linkage_name, block, domain);
d1673 1
a1673 1
  return lookup_symbol_global (name, linkage_name, block, domain);
a1680 1
		      const char *linkage_name,
d1687 1
a1687 1
    return lookup_symbol_aux_block (name, linkage_name, static_block, domain);
a1696 1
		      const char *linkage_name,
d1706 1
a1706 1
    sym = solib_global_lookup (objfile, name, linkage_name, domain);
d1710 1
a1710 1
  sym = lookup_symbol_aux_symtabs (GLOBAL_BLOCK, name, linkage_name, domain);
d1714 1
a1714 1
  return lookup_symbol_aux_psymtabs (GLOBAL_BLOCK, name, linkage_name, domain);
d1738 1
a1738 3
   If LINKAGE_NAME is non-NULL, check in addition that the symbol's
   linkage name matches it.  Check the global symbols if GLOBAL, the
   static symbols if not */
d1742 1
a1742 2
		       const char *linkage_name, int global,
		       domain_enum domain)
d1794 1
a1794 3
	     && (linkage_name != NULL
		 ? strcmp (SYMBOL_LINKAGE_NAME (*top), linkage_name) == 0
		 : SYMBOL_MATCHES_SEARCH_NAME (*top,name)))
d1811 3
a1813 9
				     SYMBOL_DOMAIN (*psym), domain))
	    {
	      if (linkage_name != NULL
		  ? strcmp (SYMBOL_LINKAGE_NAME (*psym), linkage_name) == 0
		  : SYMBOL_MATCHES_SEARCH_NAME (*psym, name))
		{
		  return (*psym);
		}
	    }
d1855 1
a1855 1
    sym = lookup_block_symbol (block, name, NULL, STRUCT_DOMAIN);
d1864 1
a1864 2
    if (!ps->readin && lookup_partial_symbol (ps, name, NULL,
					      1, STRUCT_DOMAIN))
d1869 1
a1869 1
	sym = lookup_block_symbol (block, name, NULL, STRUCT_DOMAIN);
d1878 1
a1878 1
	    sym = lookup_block_symbol (block, name, NULL, STRUCT_DOMAIN);
d1902 1
a1902 1
    sym = lookup_block_symbol (block, name, NULL, STRUCT_DOMAIN);
d1911 1
a1911 1
    if (!ps->readin && lookup_partial_symbol (ps, name, NULL, 0, STRUCT_DOMAIN))
d1916 1
a1916 1
	sym = lookup_block_symbol (block, name, NULL, STRUCT_DOMAIN);
d1925 1
a1925 1
	    sym = lookup_block_symbol (block, name, NULL, STRUCT_DOMAIN);
d1952 1
a1952 1
    if (lookup_partial_symbol (pst, main_name (), NULL, 1, VAR_DOMAIN))
a1969 3

   If LINKAGE_NAME is non-NULL, verify that any symbol we find has this
   particular mangled name.
a1973 1
		     const char *linkage_name,
d1986 1
a1986 3
				     SYMBOL_DOMAIN (sym), domain)
	      && (linkage_name != NULL
		  ? strcmp (SYMBOL_LINKAGE_NAME (sym), linkage_name) == 0 : 1))
d2006 1
a2006 3
				     SYMBOL_DOMAIN (sym), domain)
	      && (linkage_name != NULL
		  ? strcmp (SYMBOL_LINKAGE_NAME (sym), linkage_name) == 0 : 1))
@


1.223
log
@gdb/
	* solib-svr4.c (scan_dyntag): Remove variable dyn_addr.  New variable
	target_section.  Find SECT in current_target_sections, gdb_assert it.
	(elf_lookup_lib_symbol): Pass the binary file if given symfile_objfile.
	New variable abfd.
	* symtab.c (lookup_objfile_from_block): Return the binary file instead
	of separate debug info file.

gdb/testsuite/
	* gdb.base/break-interp.exp (test_core): New proc.
	(test_ld): Call it.
@
text
@d1370 1
d1373 2
a1374 2
      for (; block && !BLOCK_FUNCTION (block);
	   block = BLOCK_SUPERBLOCK (block));
d1376 2
a1377 2
      if (block && !dict_empty (BLOCK_DICT (block)))
	sym = lookup_block_symbol (block, langdef->la_name_of_this,
@


1.222
log
@2010-01-06  Tristan Gingold  <gingold@@adacore.com>

	* symtab.c (lookup_global_symbol_from_objfile): Rename objfile
	parameter to main_objfile.  Iterate on all separate debug objfiles.
	* symfile.h (symbol_file_add_separate)
	(find_separate_debug_file_by_debuglink): Remove parameter names.
	* symfile.c (symbol_file_add_separate): Use add_separate_objfile.
	(reread_symbols): Use free_objfile_separate_debug.
	* objfiles.h (struct objfile): Add separate_debug_objfile_link.
	Adjust comment.
	(objfile_separate_debug_iterate, add_separate_debug_objfile)
	(free_objfile_separate_debug): New prototypes.
	* objfiles.c (objfile_separate_debug_iterate): New function.
	(add_separate_debug_objfile, free_objfile_separate_debug): New
	functions.
	(free_objfile): Use free_objfile_separate_debug.  Adjust for
	multiple separate debug objfile.
	(objfile_has_symbols): Adjust comment.  Iterate on all separate
	debug objfiles.
	* minsyms.c (lookup_minimal_symbol): Adjust for multiple separate
	debug objfile.
	(lookup_minimal_symbol_text): Ditto.
	(lookup_minimal_symbol_by_pc_name): Ditto.
	(lookup_minimal_symbol_solib_trampoline): Ditto.
	(lookup_minimal_symbol_by_pc_section_1): Iterate on all separate
	debug objfiles.
@
text
@d1473 6
a1478 1
      return obj;
@


1.221
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d1502 1
a1502 1
lookup_global_symbol_from_objfile (const struct objfile *objfile,
d1507 1
d1514 32
a1545 31
  /* Go through symtabs.  */
  ALL_OBJFILE_SYMTABS (objfile, s)
  {
    bv = BLOCKVECTOR (s);
    block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
    sym = lookup_block_symbol (block, name, linkage_name, domain);
    if (sym)
      {
	block_found = block;
	return fixup_symbol_section (sym, (struct objfile *)objfile);
      }
  }

  /* Now go through psymtabs.  */
  ALL_OBJFILE_PSYMTABS (objfile, ps)
  {
    if (!ps->readin
	&& lookup_partial_symbol (ps, name, linkage_name,
				  1, domain))
      {
	s = PSYMTAB_TO_SYMTAB (ps);
	bv = BLOCKVECTOR (s);
	block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
	sym = lookup_block_symbol (block, name, linkage_name, domain);
	return fixup_symbol_section (sym, (struct objfile *)objfile);
      }
  }

  if (objfile->separate_debug_objfile)
    return lookup_global_symbol_from_objfile (objfile->separate_debug_objfile,
					      name, linkage_name, domain);
@


1.220
log
@	* NEWS: Document "info variables" change.
	* dwarf2read.c (new_symbol): Add file-scope external unresolved
	symbols to global_symbols.
	* symtab.c (search_symbols): Skip LOC_UNRESOLVED symbols.

	doc/
	* gdb.texinfo (Symbols): "info variables" prints definitions, not
	declarations.
@
text
@d4 2
a5 2
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2007, 2008, 2009
   Free Software Foundation, Inc.
@


1.219
log
@	* symtab.c (symbol_set_names): Correctly set 'name' on symbol when
	lookup name differs.
@
text
@d3299 3
a3301 1
			 && SYMBOL_CLASS (*psym) != LOC_BLOCK)
d3377 1
@


1.218
log
@	* xcoffread.c (scan_xcoff_symtab): Update.
	* symfile.h (add_psymbol_to_list): Update prototype.
	* symfile.c (add_psymbol_to_bcache): Add copy_name argument.
	(add_psymbol_to_list): Likewise.
	* stabsread.c (define_symbol): Update.
	* mdebugread.c (parse_partial_symbols): Update.
	(handle_psymbol_enumerators): Update.
	(new_symbol): Update.
	* dbxread.c (read_dbx_symtab): Update.
	* coffread.c (process_coff_symbol): Update.
	* symtab.h (prim_record_minimal_symbol_full): Declare.
	(SYMBOL_SET_NAMES): Add copy_name argument.
	* symtab.c (struct demangled_name_entry): New struct.
	(hash_demangled_name_entry): New function.
	(eq_demangled_name_entry): Likewise.
	(create_demangled_names_hash): Use new functions.
	(symbol_set_names): Use struct demangled_name_entry.  Add
	copy_name argument.
	* minsyms.c (prim_record_minimal_symbol_full): New function.
	(prim_record_minimal_symbol_and_info): Use it.
	* elfread.c (record_minimal_symbol): Add name_len and copy_name
	arguments.  Call prim_record_minimal_symbol_full.
	(elf_symtab_read): Add copy_names argument.
	(elf_symfile_read): Update calls to elf_symtab_read.
	* dwarf2read.c (add_partial_symbol): Don't copy symbol names.
	(load_partial_dies): Likewise.
	(new_symbol): Likewise.
	* cp-namespace.c (check_one_possible_namespace_symbol): Don't save
	name on the obstack.  Update call to SYMBOL_SET_NAMES.
@
text
@d679 1
a679 1
  gsymbol->name = (*slot)->mangled;
@


1.217
log
@        PR mi/9583:
        * symtab.c (find_line_symtab, append_exact_match_to_sals)
        (expand_line_sal): Use full filename when setting breakpoints if
        available
@
text
@d430 24
d467 1
a467 1
    (256, htab_hash_string, (int (*) (const void *, const void *)) streq,
d523 9
a531 4
   on LINKAGE_NAME and LEN.  The hash table corresponding to OBJFILE
   is used, and the memory comes from that objfile's objfile_obstack.
   LINKAGE_NAME is copied, so the pointer can be discarded after
   calling this function.  */
d554 2
a555 1
		  const char *linkage_name, int len, struct objfile *objfile)
d557 1
a557 1
  char **slot;
d565 1
a565 3

  if (objfile->demangled_names_hash == NULL)
    create_demangled_names_hash (objfile);
d577 8
a584 3
      gsymbol->name = obstack_alloc (&objfile->objfile_obstack, len + 1);
      memcpy (gsymbol->name, linkage_name, len);
      gsymbol->name[len] = '\0';
d590 3
d628 4
a631 2
  slot = (char **) htab_find_slot (objfile->demangled_names_hash,
				   lookup_name, INSERT);
d640 30
a669 6
      /* If there is a demangled name, place it right after the mangled name.
	 Otherwise, just place a second zero byte after the end of the mangled
	 name.  */
      *slot = obstack_alloc (&objfile->objfile_obstack,
			     lookup_len + demangled_len + 2);
      memcpy (*slot, lookup_name, lookup_len + 1);
d672 1
a672 1
	  memcpy (*slot + lookup_len + 1, demangled_name, demangled_len + 1);
d676 1
a676 1
	(*slot)[lookup_len + 1] = '\0';
d679 2
a680 2
  gsymbol->name = *slot + lookup_len - len;
  if ((*slot)[lookup_len + 1] != '\0')
d682 1
a682 1
      = &(*slot)[lookup_len + 1];
@


1.216
log
@2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	Add base multi-executable/process support to GDB.

	gdb/
	* Makefile.in (SFILES): Add progspace.c.
	(COMMON_OBS): Add progspace.o.
	* progspace.h: New.
	* progspace.c: New.

	* breakpoint.h (struct bp_target_info) <placed_address_space>: New
	field.
	(struct bp_location) <pspace>: New field.
	(struct breakpoint) <pspace>: New field.
	(bpstat_stop_status, breakpoint_here_p)
	(moribund_breakpoint_here_p, breakpoint_inserted_here_p)
	(regular_breakpoint_inserted_here_p)
	(software_breakpoint_inserted_here_p, breakpoint_thread_match)
	(set_default_breakpoint): Adjust prototypes.
	(remove_breakpoints_pid, breakpoint_program_space_exit): Declare.
	(insert_single_step_breakpoint, deprecated_insert_raw_breakpoint):
	Adjust prototypes.
	* breakpoint.c (executing_startup): Delete.
	(default_breakpoint_sspace): New.
	(breakpoint_restore_shadows): Skip if the address space doesn't
	match.
	(update_watchpoint): Record the frame's program space in the
	breakpoint location.
	(insert_bp_location): Record the address space in target_info.
	Adjust to pass the symbol space to solib_name_from_address.
	(breakpoint_program_space_exit): New.
	(insert_breakpoint_locations): Switch the symbol space and thread
	when inserting breakpoints.  Don't insert breakpoints in a vfork
	parent waiting for vfork done if we're not attached to the vfork
	child.
	(remove_breakpoints_pid): New.
	(reattach_breakpoints): Switch to a thread of PID.  Ignore
	breakpoints of other symbol spaces.
	(create_internal_breakpoint): Store the symbol space in the sal.
	(create_longjmp_master_breakpoint): Iterate over all symbol
	spaces.
	(update_breakpoints_after_exec): Ignore breakpoints for other
	symbol spaces.
	(remove_breakpoint): Rename to ...
	(remove_breakpoint_1): ... this.  Pass the breakpoints symbol
	space to solib_name_from_address.
	(remove_breakpoint): New.
	(mark_breakpoints_out): Ignore breakpoints from other symbol
	spaces.
	(breakpoint_init_inferior): Ditto.
	(breakpoint_here_p): Add an address space argument and adjust to
	use breakpoint_address_match.
	(moribund_breakpoint_here_p): Ditto.
	(regular_breakpoint_inserted_here_p): Ditto.
	(breakpoint_inserted_here_p): Ditto.
	(software_breakpoint_inserted_here_p): Ditto.
	(breakpoint_thread_match): Ditto.
	(bpstat_check_location): Ditto.
	(bpstat_stop_status): Ditto.
	(print_breakpoint_location): If there's a location to print,
	switch the current symbol space.
	(print_one_breakpoint_location): Add `allflag' argument.
	(print_one_breakpoint): Ditto.	Adjust.
	(do_captured_breakpoint_query): Adjust.
	(breakpoint_1): Adjust.
	(breakpoint_has_pc): Also match the symbol space.
	(describe_other_breakpoints): Add a symbol space argument and
	adjust.
	(set_default_breakpoint): Add a symbol space argument.	Set
	default_breakpoint_sspace.
	(breakpoint_address_match): New.
	(check_duplicates_for): Add an address space argument, and adjust.
	(set_raw_breakpoint): Record the symbol space in the location and
	in the breakpoint.
	(set_longjmp_breakpoint): Skip longjmp master breakpoints from
	other symbol spaces.
	(remove_thread_event_breakpoints, remove_solib_event_breakpoints)
	(disable_breakpoints_in_shlibs): Skip breakpoints from other
	symbol spaces.
	(disable_breakpoints_in_unloaded_shlib): Match symbol spaces.
	(create_catchpoint): Set the symbol space in the sal.
	(disable_breakpoints_before_startup): Skip breakpoints from other
	symbol spaces.	Set executing_startup in the current symbol space.
	(enable_breakpoints_after_startup): Clear executing_startup in the
	current symbol space.  Skip breakpoints from other symbol spaces.
	(clone_momentary_breakpoint): Also copy the symbol space.
	(add_location_to_breakpoint): Set the location's symbol space.
	(bp_loc_is_permanent): Switch thread and symbol space.
	(create_breakpoint): Adjust.
	(expand_line_sal_maybe): Expand comment to mention symbol spaces.
	Switch thread and symbol space when reading memory.
	(parse_breakpoint_sals): Set the symbol space in the sal.
	(break_command_really): Ditto.
	(skip_prologue_sal): Switch and space.
	(resolve_sal_pc): Ditto.
	(watch_command_1): Record the symbol space in the sal.
	(create_ada_exception_breakpoint): Adjust.
	(clear_command): Adjust.  Match symbol spaces.
	(update_global_location_list): Use breakpoint_address_match.
	(breakpoint_re_set_one): Switch thread and space.
	(breakpoint_re_set): Save symbol space.
	(breakpoint_re_set_thread): Also reset the symbol space.
	(deprecated_insert_raw_breakpoint): Add an address space argument.
	Adjust.
	(insert_single_step_breakpoint): Ditto.
	(single_step_breakpoint_inserted_here_p): Ditto.
	(clear_syscall_counts): New.
	(_initialize_breakpoint): Install it as inferior_exit observer.

	* exec.h: Include "progspace.h".
	(exec_bfd, exec_bfd_mtime): New defines.
	(exec_close): Declare.
	* exec.c: Include "gdbthread.h" and "progspace.h".
	(exec_bfd, exec_bfd_mtime, current_target_sections_1): Delete.
	(using_exec_ops): New.
	(exec_close_1): Rename to exec_close, and make public.
	(exec_close): Rename to exec_close_1, and adjust all callers.  Add
	description.  Remove target sections and close executables from
	all program spaces.
	(exec_file_attach): Add comment.
	(add_target_sections): Check on `using_exec_ops' to check if the
	target should be pushed.
	(remove_target_sections): Only unpush the target if there are no
	more target sections in any symbol space.
	* gdbcore.h: Include "exec.h".
	(exec_bfd, exec_bfd_mtime): Remove declarations.

	* frame.h (get_frame_program_space, get_frame_address_space)
	(frame_unwind_program_space): Declare.
	* frame.c (struct frame_info) <pspace, aspace>: New fields.
	(create_sentinel_frame): Add program space argument.  Set the
	pspace and aspace fields of the frame object.
	(get_current_frame, create_new_frame): Adjust.
	(get_frame_program_space): New.
	(frame_unwind_program_space): New.
	(get_frame_address_space): New.
	* stack.c (print_frame_info): Adjust.
	(print_frame): Use the frame's program space.

	* gdbthread.h (any_live_thread_of_process): Declare.
	* thread.c (any_live_thread_of_process): New.
	(switch_to_thread): Switch the program space as well.
	(restore_selected_frame): Don't warn if trying to restore frame
	level 0.

	* inferior.h: Include "progspace.h".
	(detach_fork): Declare.
	(struct inferior) <removable, aspace, pspace>
	<vfork_parent, vfork_child, pending_detach>
	<waiting_for_vfork_done>: New fields.
	<terminal_info>: Remove field.
	<data, num_data>: New fields.
	(register_inferior_data, register_inferior_data_with_cleanup)
	(clear_inferior_data, set_inferior_data, inferior_data): Declare.
	(exit_inferior, exit_inferior_silent, exit_inferior_num_silent)
	(inferior_appeared): Declare.
	(find_inferior_pid): Typo.
	(find_inferior_id, find_inferior_for_program_space): Declare.
	(set_current_inferior, save_current_inferior, prune_inferiors)
	(number_of_inferiors): Declare.
	(inferior_list): Declare.
	* inferior.c: Include "gdbcore.h" and "symfile.h".
	(inferior_list): Make public.
	(delete_inferior_1): Always delete thread silently.
	(find_inferior_id): Make public.
	(current_inferior_): New.
	(current_inferior): Use it.
	(set_current_inferior): New.
	(restore_inferior): New.
	(save_current_inferior): New.
	(free_inferior): Free the per-inferior data.
	(add_inferior_silent): Allocate per-inferior data.
	Call inferior_appeared.
	(delete_threads_of_inferior): New.
	(delete_inferior_1): Adjust interface to take an inferior pointer.
	(delete_inferior): Adjust.
	(delete_inferior_silent): Adjust.
	(exit_inferior_1): New.
	(exit_inferior): New.
	(exit_inferior_silent): New.
	(exit_inferior_num_silent): New.
	(detach_inferior): Adjust.
	(inferior_appeared): New.
	(discard_all_inferiors): Adjust.
	(find_inferior_id): Make public.  Assert pid is not zero.
	(find_inferior_for_program_space): New.
	(have_inferiors): Check if we have any inferior with pid not zero.
	(have_live_inferiors): Go over all pushed targets looking for
	process_stratum.
	(prune_inferiors): New.
	(number_of_inferiors): New.
	(print_inferior): Add executable column.  Print vfork parent/child
	relationships.
	(inferior_command): Adjust to cope with not running inferiors.
	(remove_inferior_command): New.
	(add_inferior_command): New.
	(clone_inferior_command): New.
	(struct inferior_data): New.
	(struct inferior_data_registration): New.
	(struct inferior_data_registry): New.
	(inferior_data_registry): New.
	(register_inferior_data_with_cleanup): New.
	(register_inferior_data): New.
	(inferior_alloc_data): New.
	(inferior_free_data): New.
	(clear_inferior_data): New.
	(set_inferior_data): New.
	(inferior_data): New.
	(initialize_inferiors): New.
	(_initialize_inferiors): Register "add-inferior",
	"remove-inferior" and "clone-inferior" commands.

	* objfiles.h: Include "progspace.h".
	(struct objfile) <pspace>: New field.
	(symfile_objfile, object_files): Don't declare.
	(ALL_PSPACE_OBJFILES): New.
	(ALL_PSPACE_OBJFILES_SAFE): New.
	(ALL_OBJFILES, ALL_OBJFILES_SAFE): Adjust.
	(ALL_PSPACE_SYMTABS): New.
	(ALL_PRIMARY_SYMTABS): Adjust.
	(ALL_PSPACE_PRIMARY_SYMTABS): New.
	(ALL_PSYMTABS): Adjust.
	(ALL_PSPACE_PSYMTABS): New.
	* objfiles.c (object_files, symfile_objfile): Delete.
	(struct objfile_sspace_info): New.
	(objfiles_pspace_data): New.
	(objfiles_pspace_data_cleanup): New.
	(get_objfile_pspace_data): New.
	(objfiles_changed_p): Delete.
	(allocate_objfile): Set the objfile's program space.  Adjust to
	reference objfiles_changed_p in pspace data.
	(free_objfile): Adjust to reference objfiles_changed_p in pspace
	data.
	(objfile_relocate): Ditto.
	(update_section_map): Add pspace argument.  Adjust to iterate over
	objfiles in the passed in pspace.
	(find_pc_section): Delete sections and num_sections statics.
	Adjust to refer to program space's objfiles_changed_p.	Adjust to
	refer to sections and num_sections store in the objfile's pspace
	data.
	(objfiles_changed): Adjust to reference objfiles_changed_p in
	pspace data.
	(_initialize_objfiles): New.
	* linespec.c (decode_all_digits, decode_dollar): Set the sal's
	program space.
	* source.c (current_source_pspace): New.
	(get_current_source_symtab_and_line): Set the sal's program space.
	(set_current_source_symtab_and_line): Set current_source_pspace.
	(select_source_symtab): Ditto.	Use ALL_OBJFILES.
	(forget_cached_source_info): Iterate over all program spaces.
	* symfile.c (clear_symtab_users): Adjust.
	* symmisc.c (print_symbol_bcache_statistics): Iterate over all
	program spaces.
	(print_objfile_statistics): Ditto.
	(maintenance_print_msymbols): Ditto.
	(maintenance_print_objfiles): Ditto.
	(maintenance_info_symtabs): Ditto.
	(maintenance_info_psymtabs): Ditto.
	* symtab.h (SYMTAB_PSPACE): New.
	(struct symtab_and_line) <pspace>: New field.
	* symtab.c (init_sal): Clear the sal's program space.
	(find_pc_sect_symtab): Set the sal's program space.  Switch thread
	and space.
	(append_expanded_sal): Add program space argument.  Iterate over
	all program spaces.
	(expand_line_sal): Iterate over all program spaces.  Switch
	program space.

	* target.h (enum target_waitkind) <TARGET_WAITKIND_VFORK_DONE>: New.
	(struct target_ops) <to_thread_address_space>: New field.
	(target_thread_address_space): Define.
	* target.c (target_detach): Only remove breakpoints from the
	inferior we're detaching.
	(target_thread_address_space): New.

	* defs.h (initialize_progspace): Declare.
	* top.c (gdb_init): Call it.

	* solist.h (struct so_list) <sspace>: New field.
	* solib.h (struct program_space): Forward declare.
	(solib_name_from_address): Adjust prototype.
	* solib.c (so_list_head): Replace with a macro referencing the
	program space.
	(update_solib_list): Set the so's program space.
	(solib_name_from_address): Add a program space argument and adjust.

	* solib-svr4.c (struct svr4_info) <pid>: Delete field.
	<interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low>
	<interp_plt_sect_high>: New fields.
	(svr4_info_p, svr4_info): Delete.
	(solib_svr4_sspace_data): New.
	(get_svr4_info): Rewrite.
	(svr4_sspace_data_cleanup): New.
	(open_symbol_file_object): Adjust.
	(svr4_default_sos): Adjust.
	(svr4_fetch_objfile_link_map): Adjust.
	(interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low)
	(interp_plt_sect_high): Delete.
	(svr4_in_dynsym_resolve_code): Adjust.
	(enable_break): Adjust.
	(svr4_clear_solib): Revert bit that removed the svr4_info here,
	and reinstate clearing debug_base, debug_loader_offset_p,
	debug_loader_offset and debug_loader_name.
	(_initialize_svr4_solib): Register solib_svr4_pspace_data.  Don't
	install an inferior_exit observer anymore.

	* printcmd.c (struct display) <pspace>: New field.
	(display_command): Set the display's sspace.
	(do_one_display): Match the display's sspace.
	(display_uses_solib_p): Ditto.

	* linux-fork.c (detach_fork): Moved to infrun.c.
	(_initialize_linux_fork): Moved "detach-on-fork" command to
	infrun.c.
	* infrun.c (detach_fork): Moved from linux-fork.c.
	(proceed_after_vfork_done): New.
	(handle_vfork_child_exec_or_exit): New.
	(follow_exec_mode_replace, follow_exec_mode_keep)
	(follow_exec_mode_names, follow_exec_mode_string)
	(show_follow_exec_mode_string): New.
	(follow_exec): New.  Reinstate the mark_breakpoints_out call.
	Remove shared libraries before attaching new executable.  If user
	wants to keep the inferior, keep it.
	(displaced_step_fixup): Adjust to pass an address space to the
	breakpoints module.
	(resume): Ditto.
	(clear_proceed_status): In all-stop mode, always clear the proceed
	status of all threads.
	(prepare_to_proceed): Adjust to pass an address space to the
	breakpoints module.
	(proceed): Ditto.
	(adjust_pc_after_break): Ditto.
	(handle_inferior_event): When handling a process exit, switch the
	program space to the inferior's that had exited.  Call
	handle_vfork_child_exec_or_exit.  Adjust to pass an address space
	to the breakpoints module.  In non-stop mode, when following a
	fork and detach-fork is off, also resume the other branch.  Handle
	TARGET_WAITKIND_VFORK_DONE.  Set the program space in sals.
	(normal_stop): Prune inferiors.
	(_initialize_infrun): Install the new "follow-exec-mode" command.
	"detach-on-fork" moved here.

	* regcache.h (get_regcache_aspace): Declare.
	* regcache.c (struct regcache) <aspace>: New field.
	(regcache_xmalloc): Clear the aspace.
	(get_regcache_aspace): New.
	(regcache_cpy): Copy the aspace field.
	(regcache_cpy_no_passthrough): Ditto.
	(get_thread_regcache): Fetch the thread's address space from the
	target, and store it in the regcache.

	* infcall.c (call_function_by_hand): Set the sal's pspace.

	* arch-utils.c (default_has_shared_address_space): New.
	* arch-utils.h (default_has_shared_address_space): Declare.

	* gdbarch.sh (has_shared_address_space): New.
	* gdbarch.h, gdbarch.c: Regenerate.

	* linux-tdep.c: Include auxv.h, target.h, elf/common.h.
	(linux_has_shared_address_space): New.
	(_initialize_linux_tdep): Declare.

	* arm-tdep.c (arm_software_single_step): Pass the frame's address
	space to insert_single_step_breakpoint.
	* arm-linux-tdep.c (arm_linux_software_single_step): Pass the
	frame's pspace to breakpoint functions.
	* cris-tdep.c (crisv32_single_step_through_delay): Ditto.
	(cris_software_single_step): Ditto.
	* mips-tdep.c (deal_with_atomic_sequence): Add frame argument.
	Pass the frame's pspace to breakpoint functions.
	(mips_software_single_step): Adjust.
	(mips_single_step_through_delay): Adjust.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Adjust.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Adjust.
	* solib-irix.c (enable_break): Adjust to pass the current frame's
	address space to breakpoint functions.
	* sparc-tdep.c (sparc_software_single_step): Ditto.
	* spu-tdep.c (spu_software_single_step): Ditto.
	* alpha-tdep.c (alpha_software_single_step): Ditto.
	* record.c (record_wait): Adjust to pass an address space to the
	breakpoints module.

	* fork-child.c (fork_inferior): Set the new inferior's program and
	address spaces.
	* inf-ptrace.c (inf_ptrace_follow_fork): Copy the parent's program
	and address spaces.
	(inf_ptrace_attach): Set the inferior's program and address spaces.
	* linux-nat.c: Include "solib.h".
	(linux_child_follow_fork): Manage parent and child's program and
	address spaces.	 Clone the parent's program space if necessary.
	Don't wait for the vfork to be done here.  Refuse to resume if
	following the vfork parent while leaving the child stopped.
	(resume_callback): Don't resume a vfork parent.
	(linux_nat_resume): Also check for pending events in the
	lp->waitstatus field.
	(linux_handle_extended_wait): Report TARGET_WAITKIND_VFORK_DONE
	events to the core.
	(stop_wait_callback): Don't wait for SIGSTOP on vfork parents.
	(cancel_breakpoint): Adjust.
	* linux-thread-db.c (thread_db_wait): Don't remove thread event
	breakpoints here.
	(thread_db_mourn_inferior): Don't mark breakpoints out here.
	Remove thread event breakpoints after mourning.
	* corelow.c: Include progspace.h.
	(core_open): Set the inferior's program and address spaces.
	* remote.c (remote_add_inferior): Set the new inferior's program
	and address spaces.
	(remote_start_remote): Update address spaces.
	(extended_remote_create_inferior_1): Don't init the thread list if
	we already debugging other inferiors.
	* darwin-nat.c (darwin_attach): Set the new inferior's program and
	address spaces.
	* gnu-nat.c (gnu_attach): Ditto.
	* go32-nat.c (go32_create_inferior): Ditto.
	* inf-ttrace.c (inf_ttrace_follow_fork, inf_ttrace_attach): Ditto.
	* monitor.c (monitor_open): Ditto.
	* nto-procfs.c (procfs_attach, procfs_create_inferior): Ditto.
	* procfs.c (do_attach): Ditto.
	* windows-nat.c (do_initial_windows_stuff): Ditto.

	* inflow.c (inferior_process_group)
	(terminal_init_inferior_with_pgrp, terminal_inferior,
	(terminal_ours_1, inflow_inferior_exit, copy_terminal_info)
	(child_terminal_info, new_tty_postfork, set_sigint_trap): Adjust
	to use per-inferior data instead of inferior->terminal_info.
	(inflow_inferior_data): New.
	(inflow_new_inferior): Delete.
	(inflow_inferior_data_cleanup): New.
	(get_inflow_inferior_data): New.

	* mi/mi-interp.c (mi_new_inferior): Rename to...
	(mi_inferior_appeared): ... this.
	(mi_interpreter_init): Adjust.

	* tui/tui-disasm.c: Include "progspace.h".
	(tui_set_disassem_content): Pass an address space to
	breakpoint_here_p.

	* NEWS: Mention multi-program debugging support.  Mention new
	commands "add-inferior", "clone-inferior", "remove-inferior",
	"maint info program-spaces", and new option "set
	follow-exec-mode".

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* observer.texi (new_inferior): Rename to...
	(inferior_appeared): ... this.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/testsuite/
	* gdb.base/foll-vfork.exp: Adjust to spell out "follow-fork".
	* gdb.base/foll-exec.exp: Adjust to expect a process id before
	"Executing new program".
	* gdb.base/foll-fork.exp: Adjust to spell out "follow-fork".
	* gdb.base/multi-forks.exp: Ditto.  Adjust to the inferior being
	left listed after having been killed.
	* gdb.base/attach.exp: Adjust to spell out "symbol-file".
	* gdb.base/maint.exp: Adjust test.

	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* gdb.multi/Makefile.in: New.
	* gdb.multi/base.exp: New.
	* gdb.multi/goodbye.c: New.
	* gdb.multi/hangout.c: New.
	* gdb.multi/hello.c: New.
	* gdb.multi/bkpt-multi-exec.c: New.
	* gdb.multi/bkpt-multi-exec.exp: New.
	* gdb.multi/crashme.c: New.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Inferiors): Rename node to ...
	(Inferiors and Programs): ... this.  Mention running multiple
	programs in the same debug session.
	<info inferiors>: Mention the new 'Executable' column if "info
	inferiors".  Update examples.  Document the "add-inferior",
	"clone-inferior", "remove-inferior" and "maint info
	program-spaces" commands.
	(Process): Rename node to...
	(Forks): ... this.  Document "set|show follow-exec-mode".
@
text
@d2419 1
a2419 1
        if (strcmp (symtab->filename, p->filename) != 0)
d2424 3
d2432 1
a2432 1
	if (strcmp (symtab->filename, s->filename) != 0)
d2434 4
d4601 5
a4605 3
   linetable entry that exactly matches FILENAME and LINENO and append
   them to RET. If there is at least one match, return 1; otherwise,
   return 0, and return the best choice in BEST_ITEM and BEST_SYMTAB.  */
d4608 1
a4608 1
append_exact_match_to_sals (char *filename, int lineno,
d4624 1
a4624 1
      if (strcmp (filename, symtab->filename) == 0)
d4628 4
d4716 1
a4716 1
	  if (strcmp (match_filename, psymtab->filename) == 0)
d4728 3
a4730 1
      exact = append_exact_match_to_sals (match_filename, lineno,
d4733 2
a4734 1
	append_exact_match_to_sals (best_symtab->filename, best_item->line,
@


1.215
log
@	* symtab.c (default_make_symbol_completion_list): Keep
	':', too, so that we can limit searches in namespaces
	and classes.
@
text
@d693 1
d1998 1
d2002 2
d2159 2
d2665 5
d2721 1
d2742 1
d4576 1
d4584 1
d4604 1
d4611 3
a4613 2
  
  ALL_SYMTABS (objfile, symtab)
d4631 2
a4632 1
		  append_expanded_sal (ret, symtab, lineno, item->pc);
d4647 4
a4650 5
/* Compute a set of all sals in
   the entire program that correspond to same file
   and line as SAL and return those.  If there
   are several sals that belong to the same block,
   only one sal for the block is included in results.  */
d4664 1
d4669 1
d4679 1
d4683 1
d4686 1
d4699 3
a4701 1
      ALL_PSYMTABS (objfile, psymtab)
d4703 6
a4708 3
	  if (strcmp (sal.symtab->filename,
		      psymtab->filename) == 0)
	    PSYMTAB_TO_SYMTAB (psymtab);
d4710 1
d4715 1
a4715 1
      exact = append_exact_match_to_sals (sal.symtab->filename, lineno,
d4731 1
d4736 5
d4742 2
a4743 1
      blocks[i] = block_for_pc (ret.sals[i].pc);
d4745 1
@


1.214
log
@2009-07-23  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* symtab.c (search_symbols): Add QUIT.
@
text
@d3839 2
a3840 1
	    if (isalnum (p[-1]) || p[-1] == '_' || p[-1] == '\0')
@


1.213
log
@	* defs.h (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter.
	* utils.c (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter, use it instead of current_gdbarch.
	* ui-out.h (ui_out_field_core_addr): Add GDBARCH parameter.
	* ui-out.c (ui_out_field_core_addr): Add GDBARCH parameter,
	use it instead of current_gdbarch.

	Update calls to ui_out_field_core_addr to pass architecture:
	* ada-lang.c (print_one_exception): Update.
	* breakpoint.c (print_one_breakpoint_location,
	print_one_exception_catchpoint): Update.
	* disasm.c (dump_insns): Update.
	* darwin-nat-info.c (darwin_debug_regions_recurse): Update.
	* mi/mi-main.c (mi_cmd_data_read_memory): Update.
	* mi/mi-symbol-cmds.c: Include "objfiles.h".
	(mi_cmd_symbol_list_lines): Update.
	* stack.c (print_frame_info, print_frame): Update.

	Update callers of paddress to pass architecture:
	* ada-tasks.c (info_task): Update.
	* ada-valprint.c (ada_val_print_1): Update.
	* annotate.c (annotate_source, annotate_frame_begin): Update.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints,
	mention): Update.
	* cli/cli-cmds.c (edit_command, list_command, print_disassembly):
	Update.
	* corefile.c (memory_error): Update.
	* c-valprint.c (print_function_pointer_address, c_val_print): Update.
	* disasm.c (dis_asm_print_address): Update.
	* exec.c (print_section_info): Update.
	* f-valprint.c (f_val_print): Update.
	* infcmd.c: Include "arch-utils.h".
	(jump_command, program_info): Update.
	* linux-fork.c: Include "arch-utils.h".
	(info_forks_command): Update.
	* m2-valprint.c (print_function_pointer_address,
	print_unpacked_pointer, print_variable_at_address,
	m2_val_print): Update.
	* m32r-rom.c (m32r_load_section, m32r_load, m32r_upload_command):
	Update.
	* printcmd.c (print_address, print_address_demangle, address_info):
	Update.
	* p-valprint.c (pascal_val_print): Update.
	* source.c: Include "arch-utils.h".
	(line_info): Update.
	* stack.c (frame_info, print_block_frame_labels): Update.
	* symfile.c (add_symbol_file_command, list_overlays_command): Update.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1,
	print_symbol, print_partial_symbols, maintenance_info_psymtabs,
	maintenance_check_symtabs): Update.
	* symtab.c (find_pc_sect_symtab): Update.
	* target.c (deprecated_debug_xfer_memory): Update.
	* tracepoint.c (scope_info): Update.
	* tui/tui-stack.c (tui_make_status_line): Update.
	* valprint.c (val_print_string): Update.

	Update callers of paddr_nz to use paddress instead (keeping
	user-visible output identical):
	* alpha-tdep.c (alpha_heuristic_proc_start): Update.
	* amd64-tdep.c (fixup_riprel, amd64_displaced_step_copy_insn,
	amd64_displaced_step_fixup): Update.
	* arch-utils.c (simple_displaced_step_copy_insn): Update.
	* auxv.c (fprint_target_auxv): Update.
	* breakpoint.c (insert_single_step_breakpoint): Update.
	* buildsym.c (finish_block): Update.
	* cli/cli-dump.c (restore_section_callback): Update.
	* fbsd-nat.c (fbsd_find_memory_regions): Update.
	* frame.c (frame_unwind_register_value): Update.
	* gcore.c (gcore_create_callback): Update.
	* hppa-tdep.c (hppa_frame_cache, hppa_skip_trampoline_code): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_record_modrm,
	i386_record_lea_modrm_addr, i386_record_lea_modrm,
	i386_process_record): Update.
	* ia64-tdep.c (ia64_frame_this_id, ia64_sigtramp_frame_this_id,
	ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id,
	ia64_dummy_id, ia64_access_reg, ia64_access_rse_reg): Update.
	* infrun.c (displaced_step_prepare, displaced_step_fixup,
	handle_inferior_event, insert_step_resume_breakpoint_at_sal,
	insert_longjmp_resume_breakpoint): Update.
	* linux-nat.c (linux_nat_find_memory_regions): Update.
	* linux-record.c (record_linux_system_call): Update.
	* mips-tdep.c (heuristic_proc_start, mips_eabi_push_dummy_call,
	mips_n32n64_push_dummy_call, mips_o32_push_dummy_call,
	mips_o64_push_dummy_call): Update.
	* monitor.c (monitor_error, monitor_remove_breakpoint): Update.
	* record.c (record_arch_list_add_mem, record_wait,
	record_xfer_partial): Update.
	* remote-mips.c (mips_fetch_word, mips_check_lsi_error,
	mips_common_breakpoint): Update.
	* remote-sim.c (gdbsim_xfer_inferior_memory): Update.
	* rs6000-tdep.c (ppc_displaced_step_fixup): Update.
	* solib-som.c (som_current_sos): Update.
	* symfile.c (load_progress, generic_load): Update.
	* symfile-mem.c (add_vsyscall_page): Update.
	* valops.c (value_fetch_lazy): Update.
	* windows-tdep.c (windows_xfer_shared_library): Update.

	Update callers of paddr_nz to use paddress instead (changing
	user-visible output to make it more correct):
	* dwarf2loc.c (locexpr_describe_location): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint,
	ia64_memory_remove_breakpoint): Update.
	* jv-valprint.c (java_value_print): Update.
	* m32c-tdep.c (m32c_m16c_address_to_pointer): Update.
	* monitor.c (monitor_read_memory): Update.

	Update callers of paddr to use paddress instead (changing
	user-visible output to make it more correct):
	* arm-tdep.c (arm_push_dummy_call): Update.
	* breakpoint.c (insert_bp_location, create_thread_event_breakpoint,
	create_breakpoint): Update.
	* darwin-nat-info.c (darwin_debug_regions): Update.
	* dcache.c (dcache_info): Update.
	* dsrec.c (load_srec, make_srec): Update.
	* dwarf2-frame.c (dwarf2_restore_rule, execute_cfa_program,
	dwarf2_frame_cache): Update.
	* gcore.c (gcore_copy_callback): Update.
	* gnu-nat.c (gnu_xfer_memory): Update.
	* mips-linux-nat.c (mips_show_dr): Update.
	* monitor.c (monitor_write_memory, monitor_insert_breakpoint,
	monitor_remove_breakpoint): Update.
	* remote.c (compare_sections_command): Update.
	* remote-m32r-sdi.c (m32r_xfer_memory, m32r_insert_breakpoint,
	m32r_remove_breakpoint, m32r_insert_watchpoint,
	m32r_remove_watchpoint): Update.
	* sol-thread.c (info_cb): Update.
	* symfile.c (load_progress): Update.

	Update callers of paddress or paddr_nz to use hex_string instead
	(changes output of internal/error/debug messages only):
	* dwarf2read.c (dump_die_shallow): Update.
	* frame.c (fprint_field, fprint_frame, frame_pc_unwind,
	get_frame_func, create_new_frame): Update.
	* hppa-tdep.c (find_unwind_entry, unwind_command): Update.
	* ia64-tdep.c (get_kernel_table, ia64_find_proc_info_x,
	ia64_get_dyn_info_list): Update.
	* maint.c (maintenance_translate_address): Update.
	* mi/mi-cmd-var.c (mi_cmd_var_create): Update.
	* target.c (target_flash_erase): Update.

	Update callers of paddr/paddr_nz to use phex/phex_nz instead,
	using an appropriate address size.  Remove use of strlen_paddr.
	* exec.c (exec_files_info): Update.
	* i386-nat.c (i386_show_dr): Update.
	* remote.c (remote_flash_erase): Update.
	* m32r-rom.c (m32r_load_section): Update.
	* monitor.c (monitor_vsprintf, monitor_store_register): Update.
	* remote.c (remote_check_symbols, remote_search_memory): Update.
	* remote-mips.c (mips_request, mips_common_breakpoint): Update.
	* scm-valprint.c (scm_ipruk, scm_scmval_print): Update.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Update.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs,
	sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs,
	sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs,
	sh_dsp_show_regs): Update.
	* xcoffsolib.c (sharedlibrary_command): Update.


	* maint.c (maint_print_section_info): Add ADDR_SIZE parameter.
	Use hex_string_custom instead of paddr.
	(print_bfd_section_info): Pass address size.
	(print_objfile_section_info): Likewise.

	* annotate.h (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* annotate.c (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* source.c (identify_source_line): Update call to annotate_source.
	* stack.c (print_frame_info, print_frame): Update call to
	annotate_frame_begin.

	* breakpoint.c (describe_other_breakpoints): Add GDBARCH parameter.
	(create_breakpoint, create_ada_exception_breakpoint): Update call.

	* stack.c (print_block_frame_labels): Add GDBARCH parameter.
	(print_frame_label_vars): Update call.

	* symmisc.c (print_partial_symbols): Add GDBARCH parameter.
	(dump_psymtab): Update call to print_partial_symbols.
	(struct print_symbol_args): Add GDBARCH member.
	(dump_symtab_1): Set print_symbol_args architecture member.
	(print_symbol): Use it.

	* windows-tdep.h (windows_xfer_shared_library): Add GDBARCH
	parameter.
	* windows-tdep.c (windows_xfer_shared_library): Likewise.
	* i386-cygwin-tdep.c (struct cpms_data): Add GDBARCH member.
	(core_process_module_section): Pass architecture from cpms_data to
	windows_xfer_shared_library.
	(windows_core_xfer_shared_libraries): Initialize cmps_data
	architecture member.
	* windows-nat.c (windows_xfer_shared_libraries): Pass architecture
	to windows_xfer_shared_library.

	* defs.h (print_address): Add GDBARCH parameter.
	* printcmd.c (print_address): Add GDBARCH parameter.
	(print_scalar_formatted, do_examine): Update call.
	* findcmd.c (find_command): Update call.
	* tracepoint.c: Include "arch-utils.h".
	(trace_find_line_command): Update call.
	* tui/tui-disasm.c (tui_disassemble): Update call.

	* value.h (print_address_demangle): Add GDBARCH parameter.
	* printcmd.c (print_address_demangle): Add GDBARCH parameter.
	* c-valprint.c (print_function_pointer_address, c_val_print):
	Update call.
	* f-valprint.c (f_val_print): Update call.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update call.
	* jv-valprint.c (java_val_print): Update call.
	* m2-valprint.c (print_function_pointer_address, m2_val_print):
	Update call.
	* p-valprint.c (pascal_val_print): Update call.

	* disasm.c (gdb_disassemble_info): Install architecture into
	di.application_data field.

testsuite/ChangeLog:

	* gdb.threads/tls-shared.exp: Update to locexpr_describe_location
	change to prefix TLS offset in hex with 0x.

doc/ChangeLog:

	* gdbint.texinfo (Item Output Functions): Update signature
	for ui_out_field_core_addr.
@
text
@d3246 2
d3338 2
@


1.212
log
@	* gdbtypes.h (struct builtin_type): Remove builtin_core_addr,
	nodebug_text_symbol, nodebug_data_symbol, nodebug_unknown_symbol,
	and nodebug_tls_symbol members.
	(struct objfile_type): New data structure.
	(objfile_type): Add prototype.
	* gdbtypes.c (gdbtypes_post_init): Remove initialization code
	for types no longer in struct builtin_type.
	(objfile_type_data): New static variable.
	(_initialize_gdbtypes): Initialize it.
	(objfile_type): New function.

	* gdbtypes.h (builtin_type_error): Remove.
	* gdbtypes.c (build_complex): Do not use builtin_type_error.
	* symtab.c (builtin_type_error): Remove.
	(_initialize_symtab): Remove initialization.

	* stabsread.c (dbx_lookup_type, define_symbol, error_type,
	rs6000_builtin_type, read_range_type): Use per-objfile types
	instead of global or per-architecture builtin types.
	* coffread.c (decode_type): Likewise.
	* dwarf2read.c (read_array_type, read_tag_string_type,
	new_symbol, die_type): Likewise.
	* mdebugread.c (parse_symbol, basic_type, upgrade_type,
	parse_procedure, psymtab_to_symtab_1): Likewise.
	* xcoffread.c (process_xcoff_symbol): Likewise.
	* parse.c (write_exp_msymbol): Likewise.

	* stabsread.c (rs6000_builtin_type_data): New static variable.
	(_initialize_stabsread): Initialize it.
	(rs6000_builtin_type): Add OBJFILE argument.  Allocate builtin
	types per-objfile instead of globally.

	* stabsread.c (dbx_lookup_type): Add OBJFILE argument.  Use it
	instead of current_objfile; pass it to rs6000_builtin_type.
	(dbx_alloc_type, read_type, read_range_type): Update calls.
	(cleanup_undefined_types_noname): Add OBJFILE argument and
	pass it to dbx_lookup_type.
	(cleanup_undefined_types): Add OBJFILE argument and pass it
	to cleanup_undefined_types_noname.
	* stabsread.h (cleanup_undefined_types): Add OBJFILE argument.
	* buildsym.c (end_symtab): Update call.
@
text
@d2082 2
a2083 2
(Internal error: pc 0x%s in read in psymtab, but not in symtab.)\n"),
		 paddr_nz (pc));
@


1.211
log
@	gdb/
	* NEWS: Document inlined function support.
	* Makefile.in (SFILES): Add inline-frame.c.
	(COMMON_OBS): Add inline-frame.o.
	* block.c (contained_in): Rewrite to use lexical nesting.
	(block_linkage_function): Skip inlined function blocks.
	(block_inlined_p): New.
	* block.h (struct block): Update comment.
	(block_inlined_p): New prototype.
	* blockframe.c (get_frame_block): Handle inlined functions.
	(get_frame_function): Do not use block_linkage_function.
	(block_innermost_frame): Use get_frame_block and contained_in.
	* breakpoint.c (watchpoint_check): Remove extra reinit_frame_cache.
	Skip over inlined functions.  Simplify epilogue check.
	(bpstat_check_breakpoint_conditions): Use get_stack_frame_id.
	Update comments.
	(set_momentary_breakpoint): Only accept non-inlined frames.
	(watch_command_1): Use frame_unwind_caller_pc and
	frame_unwind_caller_id instead of get_prev_frame.
	(until_break_command): Likewise.  Use get_stack_frame_id.
	* buildsym.c (end_symtab): Set SYMBOL_SYMTAB for block functions.
	* dwarf2loc.c (dwarf_expr_frame_base): Use block_linkage_function.
	* dwarf2read.c (process_die): Handle DW_TAG_inlined_subroutine.
	(read_func_scope, new_symbol): Likewise.  Handle arguments specially
	for inlined functions without call site information.
	(inherit_abstract_dies): Allow tag mismatch for inlined subroutines.
	(die_specification): Treat DW_AT_abstract_origin as a specification.
	(read_type_die): Handle DW_TAG_inlined_subroutine.
	* frame-unwind.c (frame_unwind_init): Add inline_frame_unwind.
	* frame.c (fprint_frame_id): Print inline depth.
	(fprint_frame_type): Handle INLINE_FRAME and SENTINEL_FRAME.
	(skip_inlined_frames, get_stack_frame_id): New.
	(frame_unwind_caller_id): Use skip_inlined_frames.
	(frame_id_inlined_p): New.
	(frame_id_eq): Make the logic match the comments.  Add inline_depth
	check.
	(frame_id_inner): Handle inlined functions.
	(frame_unwind_pc): New function, copied from frame_unwind_caller_pc.
	(frame_unwind_caller_pc): Use skip_inlined_frames and frame_unwind_pc.
	(get_prev_frame_1): Check for inline frames.  Split out frame
	allocation to get_prev_frame_raw.
	(get_prev_frame_raw): New function.
	(get_prev_frame): Handle inline frames.
	(get_frame_pc): Use frame_unwind_pc.
	(get_frame_address_in_block): Skip inlined frames on both sides.
	(pc_notcurrent): Delete.
	(find_frame_sal): Rewrite to handle inline call sites.  Use
	get_frame_address_in_block.
	(deprecated_update_frame_pc_hack): Make static.
	* frame.h: Update comments.
	(struct frame_id): Add inline_depth.
	(enum frame_type): Add INLINE_FRAME.
	(frame_id_inlined_p, get_stack_frame_id): New prototypes.
	* gdbthread.h (struct thread_info): Add step_stack_frame_id field.
	* infcmd.c (set_step_frame): New function.
	(step_once): Use set_step_frame.  Handle inlined functions.
	(until_next_command): Use set_step_frame.
	(finish_backward), finish_forward): Use get_stack_frame_id.
	(finish_command): Support inlined functions.
	* inferior.h (set_step_info): New prototype.
	* infrun.c (RESUME_ALL): Use minus_one_ptid.
	(clear_proceed_status): Clear step_stack_frame_id.
	(init_wait_for_inferior): Call clear_inline_frame_state.
	(init_execution_control_state): Make static.
	(set_step_info): New function.
	(init_thread_stepping_state): Do not set the symtab or line here.
	(stepped_in_from): New function.
	(handle_inferior_event): Handle inlined functions.  Use set_step_info.
	(insert_step_resume_breakpoint_at_frame): Use get_stack_frame_id.
	(struct inferior_status): Add step_stack_frame_id.
	(save_inferior_status, restore_inferior_status): Save and restore
	step_stack_frame_id.
	* inline-frame.c, inline-frame.h: New files.
	* minsyms.c (prim_record_minimal_symbol_and_info): Use XCALLOC.
	* regcache.c (regcache_write_pc): Call reinit_frame_cache.
	* s390-tdep.c (s390_prologue_frame_unwind_cache): Handle INLINE_FRAME.
	* stack.c (frame_show_address): New.
	(print_frame_info, print_frame): Use it.
	(find_frame_funname): Use get_frame_function.  Handle inlined blocks.
	(frame_info): Mark inlined functions.
	(backtrace_command_1): Use get_current_user_frame.
	(print_frame_local_vars, print_frame_label_vars): Update comments.
	(return_command): Refuse inlined functions.
	* symtab.c (lookup_symbol_aux_local): Stop at inlined function
	boundaries.
	(find_function_start_sal): Avoid inlined functions.
	(completion_list_add_fields): New function.
	(default_make_symbol_completion_list): Use it.  Use block_static_block
	and block_global_block.  Check for inlined functions.
	(skip_prologue_using_sal): Avoid line number comparison across
	inlining.
	* symtab.h (struct symbol): Add is_inlined.
	(SYMBOL_INLINED): New.
	* target.c (target_resume): Call clear_inline_frame_state.
	* valops.c (value_of_variable): Check block_inlined_p.

	gdb/doc/
	* gdb.texinfo (Debugging Optimized Code): New chapter.
	(Compiling for Debugging): Reference it.  Move some
	text to the new section.

	gdb/testsuite/
	* gdb.base/break.exp: Add an XFAIL for gcc/36748.
	* gdb.cp/annota2.exp: Accept frames-invalid in more places.
	* gdb.opt/Makefile.in (EXECUTABLES): Update.
	* gdb.opt/clobbered-registers-O2.exp: Update to GPL v3.
	* gdb.opt/inline-bt.c, gdb.opt/inline-bt.exp,
	gdb.opt/inline-cmds.c, gdb.opt/inline-cmds.exp,
	gdb.opt/inline-locals.c, gdb.opt/inline-locals.exp,
	gdb.opt/inline-markers.c: New files.
	* lib/gdb.exp (skip_inline_frame_tests): New function.
	(skip_inline_var_tests): New function.
@
text
@a148 3
/* The single non-language-specific builtin type */
struct type *builtin_type_error;

a4778 4
  /* Initialize the one built-in type that isn't language dependent... */
  builtin_type_error = init_type (TYPE_CODE_ERROR, 0, 0,
				  "<unknown type>", (struct objfile *) NULL);

@


1.210
log
@	* dummy-frame.c (deprecated_pc_in_call_dummy): Add GDBARCH parameter,
	use it instead of current_gdbarch.
	* frame.h (deprecated_pc_in_call_dummy): Add GDBARCH parameter.
	* arm-tdep.c (arm_skip_prologue): Pass architecture to
	deprecated_pc_in_call_dummy.

	* symtab.c (skip_prologue_using_sal): Add GDBARCH parameter.
	Use it instead of current_gdbarch.
	* symtab.h (skip_prologue_using_sal): Add GDBARCH parameter.
	* breakpoint.c (expand_line_sal_maybe): Pass architecture to
	skip_prologue_using_sal.
	* arm-tdep.c (skip_prologue_using_sal): Likewise.
	* lm32-tdep.c (lm32_skip_prologue): Likewise.
	* m32-tdep.c (m32c_skip_prologue): Likewise.
	* mips-tdep.c (mips_skip_prologue): Likewise.
	* moxie-tdep.c (moxie_skip_prologue): Likewise.
	* mt-tdep.c (mt_frame_unwind_cache): Likewise.
	* rs6000-tdep.c (rs6000_skip_prologue): Likewise.
	* frv-tdep.c (frv_analyze_prologue): Add GDBARCH parameter, pass
	it to skip_prologue_using_sal.  Update call sites ...
	(frv_skip_prologue, frv_frame_unwind_cache): ... here.

	* mn10300-tdep.c (struct mn10300_prologue): Add GDBARCH member.
	(check_for_saved): Use it instead of current_gdbarch.
	(mn10300_analyze_prologue): Set it.

	* value.c (using_struct_return): Add GDBARCH parameter.  Use it
	instead of current_gdbarch.
	* value.h (using_struct_return): Add GDBARCH parameter.
	* eval.c (evaluate_subexp_standard): Pass architecture to
	using_struct_return.
	* infcall.c (call_function_by_hand): Likewise.
	* stack.c (return_command): Likewise.
	* sparc-tdep.c (sparc32_push_dummy_code): Likewise.

	* symtab.c (in_prologue): Add GDBARCH parameter.  Use it instead of
	current_gdbarch.
	* symtab.h (in_prologue): Add GDBARCH parameter.
	* infrun.c (handle_inferior_event): Pass architecture to in_prologue.

	* eval.c (evaluate_subexp_standard): Use expression architecture
	instead of current_gdbarch.

	* c-lang.c (evaluate_subexp_c): Use expression architecture and
	language instead of current_gdbarch and current_language.

	* printcmd.c (do_one_display): Use expression architecture instead
	of current_gdbarch.

	* infcmd.c (print_return_value): Use architecture of stop_regcache
	instead of current_gdbarch.
	(print_vector_info, print_float_info): Remove GDBARCH argument,
	use frame architecture instead.
	(vector_info, float_info): Update calls.

	* objc-lang.c (objc_skip_trampoline): Use frame architecture
	instead of current_gdbarch.

	* parse.c (write_dollar_variable): Use parse architecture instead
	of current_gdbarch.

	* source.c (line_info): Use objfile architecture instead of
	current_gdbarch.

	* symtab.c (find_function_start_sal): Use gdbarch instead of
	current_gdbarch.
	(print_msymbol_info): Use objfile architecture instead of
	current_gdbarch.

	* valops.c (value_assign): Use frame architecture instead of
	current_gdbarch.
@
text
@d1387 3
d1393 1
a1393 1
  /* We've reached the static block without finding a result.  */
d2660 1
d2714 19
d3733 18
d3786 2
a3787 1
  struct block *b, *surrounding_static_block = 0;
a3788 1
  int j;
d3898 11
a3908 1
     complete on local vars.  */
d3910 15
a3924 6
  for (b = get_selected_block (0); b != NULL; b = BLOCK_SUPERBLOCK (b))
    {
      if (!BLOCK_SUPERBLOCK (b))
	{
	  surrounding_static_block = b;		/* For elmin of dups */
	}
d3926 1
a3926 2
      /* Also catch fields of types defined in this places which match our
         text string.  Only complete on types visible from current context. */
d3928 3
a3930 8
      ALL_BLOCK_SYMBOLS (b, iter, sym)
	{
	  QUIT;
	  COMPLETION_LIST_ADD_SYMBOL (sym, sym_text, sym_text_len, text, word);
	  if (SYMBOL_CLASS (sym) == LOC_TYPEDEF)
	    {
	      struct type *t = SYMBOL_TYPE (sym);
	      enum type_code c = TYPE_CODE (t);
d3932 3
a3934 14
	      if (c == TYPE_CODE_UNION || c == TYPE_CODE_STRUCT)
		{
		  for (j = TYPE_N_BASECLASSES (t); j < TYPE_NFIELDS (t); j++)
		    {
		      if (TYPE_FIELD_NAME (t, j))
			{
			  completion_list_add_name (TYPE_FIELD_NAME (t, j),
					sym_text, sym_text_len, text, word);
			}
		    }
		}
	    }
	}
    }
a3952 3
    /* Don't do this block twice.  */
    if (b == surrounding_static_block)
      continue;
d4418 19
@


1.209
log
@	* symtab.c (append_expanded_sal): Remove unused local variables.
@
text
@d2684 1
a2684 1
      && gdbarch_skip_main_prologue_p (current_gdbarch)
d2688 1
a2688 1
      pc = gdbarch_skip_main_prologue (current_gdbarch, pc);
d3402 1
d3405 1
a3405 1
  if (gdbarch_addr_bit (current_gdbarch) <= 32)
d4241 1
a4241 1
in_prologue (CORE_ADDR pc, CORE_ADDR func_start)
d4273 1
a4273 1
      prologue_end = gdbarch_skip_prologue (current_gdbarch, func_start);
d4297 1
a4297 2
      CORE_ADDR prologue_end = gdbarch_skip_prologue
			         (current_gdbarch, func_addr);
d4324 1
a4324 1
skip_prologue_using_sal (CORE_ADDR func_addr)
d4333 1
a4333 1
  start_pc += gdbarch_deprecated_function_start_offset (current_gdbarch);
@


1.208
log
@
	* symtab.c (skip_prologue_using_lineinfo): New function.
	(find_function_start_sal): Use it to get to the first line of
	function's body that has an entry in the lineinfo table.
@
text
@a4504 2
  CORE_ADDR func_addr, func_end;

@


1.207
log
@	* symtab.c (append_exact_match_to_sals): New function, extracted
	from expand_line_sal.
	(expand_line_sal): Use append_exact_match_to_sals to append exact
	matches. If none found, append all best items.
@
text
@d2602 41
d2693 15
@


1.206
log
@gdb

2009-03-31  Daniel Jacobowitz  <dan@@codesourcery.com>
	    Keith Seitz  <keiths@@redhat.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

	PR gdb/6817
	* Makefile.in (dbxread.o): Update.
	* dbxread.c (read_dbx_symtab): Use cp_canonicalize_string.
	* dwarf2read.c (GDB_FORM_cached_string): New.
	(read_partial_die): Use dwarf2_canonicalize_name.
	(dwarf2_linkage_name): Use dwarf2_name.
	(dwarf2_canonicalize_name): New.
	(dwarf2_name): Use dwarf2_canonicalize_name.
	(dwarf_form_name, dump_die): Handle GDB_FORM_cached_string.
	* stabsread.c (define_symbol, read_type): Use cp_canonicalize_string.
	* symtab.c (lookup_symbol_in_language): Canonicalize input before
	searching.
	* cp-name-parser.y: operator() requires two parameters,
	according to libiberty.
	* minsyms.c (lookup_minimal_symbol): Canonicalize input
	before searching.
	* NEWS: Update.

gdb/testsuite

2009-03-31  Daniel Jacobowitz  <dan@@codesourcery.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

	PR gdb/931
	* gdb.cp/gdb1355.exp (f_li, f_lui, f_si, f_sui): Allow canonical
	output.
	* gdb.cp/templates.exp: Allow canonical output.  Remove KFAILs
	for gdb/931.
	* dw2-strp.S (DW_AT_language): Change to C++.
	(DW_TAG_variable (name ""), Abbrev code 7, .Lemptyname): New.
@
text
@d4463 51
d4569 5
a4573 34
      /* For each symtab, we add all pcs to ret.sals.  I'm actually
	 not sure what to do if we have exact match in one symtab,
	 and non-exact match on another symtab.  */

      ALL_SYMTABS (objfile, symtab)
	{
	  if (strcmp (sal.symtab->filename,
		      symtab->filename) == 0)
	    {
	      struct linetable *l;
	      int len;
	      l = LINETABLE (symtab);
	      if (!l)
		continue;
	      len = l->nitems;

	      for (j = 0; j < len; j++)
		{
		  struct linetable_entry *item = &(l->item[j]);

		  if (item->line == lineno)
		    {
		      exact = 1;
		      append_expanded_sal (&ret, symtab, lineno, item->pc);
		    }
		  else if (!exact && item->line > lineno
			   && (best_item == NULL || item->line < best_item->line))
		    {
		      best_item = item;
		      best_symtab = symtab;
		    }
		}
	    }
	}
d4575 2
a4576 1
	append_expanded_sal (&ret, best_symtab, lineno, best_item->pc);
@


1.205
log
@	* symtab.c (lookup_symbol_in_language): Use a cleanup.
@
text
@d58 1
d1217 11
@


1.204
log
@	* symtab.c: Remove trailing whitespace throughout the file.
	(expand_line_sal): Fix some typos and whitespace.
@
text
@a1199 1
  int needtofreename = 0;
d1201 1
d1214 1
a1214 1
	  needtofreename = 1;
d1225 1
a1225 1
	  needtofreename = 1;
d1244 1
a1244 2
  if (needtofreename)
    xfree (demangled_name);
@


1.203
log
@(tiny change)

        * symtab.c (find_line_symtab): Initialize exact to avoid
        a compiler warning.
@
text
@d152 1
a152 1
   Might be better to make this a parameter to lookup_symbol and 
d190 1
a190 1
      
d193 1
a193 1
    
d440 1
a440 1
     The hash table code will round this up to the next prime number. 
d633 1
a633 1
  switch (gsymbol->language) 
d658 1
a658 1
  switch (gsymbol->language) 
d680 1
a680 1
   If there is no distinct demangled name, then returns the same value 
d881 1
a881 1
	       so fall back to the non-addrmap case if we're debugging 
d935 1
a935 1
/* Find which partial symtab contains PC.  Return 0 if none. 
d944 1
a944 1
/* Find which partial symbol within a psymtab matches PC and SECTION.  
d1016 1
a1016 1
/* Find which partial symbol within a psymtab matches PC.  Return 0 if none.  
d1056 1
a1056 1
	 
d1064 1
a1064 1
	 
d1076 2
a1077 2
	 symbol, only its section.  
	 
d1082 1
a1082 1
	 
d1178 1
a1178 1
   *IS_A_FIELD_OF_THIS to 1, otherwise set it to zero. 
d1219 1
a1219 1
      demangled_name = cplus_demangle (name, 
d1247 1
a1247 1
  return returnval;	 
d1301 1
a1301 1
      for (; block && !BLOCK_FUNCTION (block); 
d1310 1
a1310 1
	  
d1317 1
a1317 1
	  
d1320 1
a1320 1
	    error (_("Internal error: `%s' is not an aggregate"), 
d1322 1
a1322 1
	  
d1347 1
a1347 1
  
d1653 1
a1653 1
symbol_matches_domain (enum language symbol_language, 
d1657 1
a1657 1
  /* For C++ "struct foo { ... }" also defines a typedef for "foo".  
d1687 1
a1687 1
  
d1695 1
a1695 1
  
d1747 1
a1747 1
    {			
d1750 1
a1750 1
	  if (symbol_matches_domain (SYMBOL_LANGUAGE (*psym), 
d1915 1
a1915 1
   symbol (language_cplus or language_objc set) has both the encoded and 
d2157 2
a2158 2
     two functions in the target, and the line info was erroneously 
     taken to be the one of the line before the pc. 
d2171 1
a2171 1
   *  Minimal symbol table for main image 
d2189 1
a2189 1
   *      we're in "foo" in the above example), it'll have a closer 
d2210 1
a2210 1
	   * In the above situation, the shared lib is not loaded yet, 
d2702 1
a2702 1
	else 
d3546 1
a3546 1
    
d3549 1
a3549 1
    
d3559 1
a3559 1
    
d3571 1
a3571 1
    
d3573 1
a3573 1
    
d3583 1
a3583 1
    
d3591 1
a3591 1
	
d3784 1
a3784 1
    
d4336 1
a4336 1
  
d4339 1
a4339 1
    
d4341 1
a4341 1
     and get a default  or it will recursively call us! */  
d4343 1
a4343 1
  
d4396 1
a4396 1
    { 
d4403 1
a4403 1
    { 
d4439 3
a4441 3
  
  sal->sals = xrealloc (sal->sals, 
			sizeof (sal->sals[0]) 
d4447 1
a4447 1
  sal->sals[sal->nelts].line = lineno;  
d4449 1
a4449 1
  ++sal->nelts;      
d4457 1
a4457 1
   
d4489 2
a4490 2
      /* We meed to find all symtabs for a file which name
	 is described by sal. We cannot just directly 
d4492 1
a4492 1
	 yet created. We also cannot iterate over psymtabs,
d4495 1
a4495 1
	 corresponding to an included file. Therefore, we do
d4507 1
a4507 2
	 
      /* For each symtab, we add all pcs to ret.sals. I'm actually
d4509 2
a4510 2
	 and non-exact match on another symtab.
      */
d4531 1
a4531 1
		    }      
a4533 1
		  
d4552 1
a4552 1
     that are in the same block.  If yes, the other PCs are filtered out.  */  
d4571 1
a4571 1
  
d4573 1
a4573 1
    struct symtab_and_line *final = 
d4575 1
a4575 1
    
d4579 1
a4579 1
    
a4600 1
  
@


1.202
log
@2008-02-21  Pedro Alves  <pedro@@codesorcery.com>

	Silence a few -Wmissing-prototypes warnings.

	PR build/9877:
	* amd64-nat.c: Include "amd64-nat.h".
	* fork-child.c (_initialize_fork_child): Ditto.
	* gcore.c (_initialize_gcore): Ditto.
	* inf-ptrace.c: Include "inf-ptrace.h".
	(inf_ptrace_store_registers): Make it static.
	* linux-nat.c (linux_nat_terminal_ours): Make it static.
	(_initialize_linux_nat): Declare before definition.
	* linux-tdep.c: Include "linux-tdep.h".
	* linux-thread-db.c (_initialize_thread_db): Declare before
	definition.
	* proc-service.c (_initialize_proc_service): Ditto.
	* remote.c (remote_send_printf): Make it static.
	* solib.c: Include "solib.h".
	* symfile-mem.c (_initialize_symfile_mem): Declare before
	definition.
	* ada-lang.c (ada_la_decode, ada_match_name)
	(ada_suppress_symbol_printing, ada_is_array_type)
	(ada_value_ptr_subscript, ada_array_length)
	(ada_to_static_fixed_value): Make them static.
	(_initialize_ada_language): Declare before definition.
	* ada-tasks.c (ada_get_task_number, ada_get_environment_task)
	(ada_task_list_changed, ada_new_objfile_observer): Make them
	static.
	(_initialize_tasks): Declare before definition.
	* addrmap.c (_initialize_addrmap): Declare before definition.
	* auxv.c (default_auxv_parse): Make it static.
	* bfd-target.c (target_bfd_xfer_partial, target_bfd_xclose): Make
	them static.
	* breakpoint.c (remove_sal): Add line break.
	(expand_line_sal_maybe): Make it static.
	* cp-name-parser.y: Include "cp-support.h".
	* cp-valprint.c (cp_find_class_member): Make it static.
	* eval.c (value_f90_subarray): Ditto.
	* exceptions.c (print_any_exception): Ditto.
	* findcmd.c (_initialize_mem_search): Declare before definition.
	* frame.c (frame_observer_target_changed): Make it static.
	* gnu-v3-abi.c (gnuv3_find_method_in): Make it static.
	* inf-child.c: Include "inf-child.h".
	* inferior.h (valid_inferior_id): Rename to ...
	(valid_gdb_inferior_id): ... this.
	* infrun.c (infrun_thread_stop_requested, siginfo_make_value):
	Make them static.
	* jv-lang.c (java_language_arch_info): Make it static.
	* m2-typeprint.c (m2_get_discrete_bounds): Ditto.
	* osdata.c (info_osdata_command): Make it static.
	* regcache.c (regcache_observer_target_changed): Make it static.
	* reverse.c (_initialize_reverse): Declare before definition.
	* stabsread.c (cleanup_undefined_types_noname)
	(cleanup_undefined_types_1): Make them static.
	* symfile.c (place_section): Make it static.
	* symtab.c (find_pc_sect_psymtab_closer): Make it static.
	* target-descriptions.c (_initialize_target_descriptions): Declare
	before definition.
	* target.c (default_get_ada_task_ptid, find_default_can_async_p)
	(find_default_is_async_p, find_default_supports_non_stop): Make
	them static.
	(target_supports_non_stop): Add prototype.
	(dummy_pid_to_str): Make it static.
	* utils.c (_initialize_utils): Declare before definition.
	* ada-exp.y (_initialize_ada_exp): Declare before definition.
	* solib-svr4.c (HAS_LM_DYNAMIC_FROM_LINK_MAP): Add a prototype.
	* target.h (struct target_ops): Add a prototype to the
	to_can_execute_reverse callback.
	* macroscope.c (_initialize_macroscope): Declare before definition.
	* cp-namespace.c (_initialize_cp_namespace): Declare before definition.
	* python/python.c (_initialize_python): Declare before definition.
	* tui/tui-command.c: Include "tui/tui-command.h".
	* tui/tui-data.c (init_content_element, init_win_info): Make them
	static.
	* tui/tui-disasm.c: Include "tui/tui-disasm.h".
	* tui/tui-interp.c (_initialize_tui_interp): Declare before
	definition.
	* tui/tui-layout.c: Include "tui/tui-layout.h".
	(_initialize_tui_layout): Declare before definition.
	* tui/tui-regs.c: Include "tui/tui-regs.h".
	(tui_display_reg_element_at_line): Make it static.
	(_initialize_tui_regs): Declare before definition.
	* tui/tui-stack.c (_initialize_tui_stack): Declare before
	definition.
	* tui/tui-win.c: Include "tui/tui-win.h".
	(_initialize_tui_win): Declare before definition.
	(tui_sigwinch_handler): Make it static.  Wrap in ifdef SIGWINCH.
	* tui/tui-win.h (tui_sigwinch_handler): Delete declaration.
	(tui_get_cmd_list): Add a prototype.
	* tui/tui-windata.c: Include tui-windata.h.
	* tui/tui-wingeneral.c (box_win): Make it static.
	* cli/cli-logging.c (show_logging_command): Make it static.
	(_initialize_cli_logging): Declare before definition.
	* mi/mi-common.c (_initialize_gdb_mi_common): Declare before
	definition.
@
text
@d2364 1
a2364 1
  int exact;
@


1.201
log
@gdb/
2009-02-06  Tom Tromey  <tromey@@redhat.com>

	* Makefile.in (SUBDIR_PYTHON_OBS): Add python-cmd.o.
	(SUBDIR_PYTHON_SRCS): Add python-cmd.c.
	(python-cmd.o): New target.
	* cli/cli-decode.c (set_cmd_completer): Add self parameter to
	completer prototype.
	(add_cmd): Initialize destroyer member of cmd_list_element. Use
	make_symbol_completion_list_fn as completer.
	(delete_cmd): Call destroyer if one is set.
	* cli/cli-decode.h (cmd_list_element): Add cmd parameter to
	completer member.  Add destroyer member.
	(set_cmd_completer): Add self parameter to
	completer prototype.
	* command.h (set_cmd_completer): Add cmd parameter to
	completer prototype.
	* completer.c (noop_completer, filename_completer,
	location_completer, expression_completer, command_completer): Adapt
	to new completer prototype.
	(complete_line_internal): Pass new parameter to completer function.
	* completer.h (noop_completer, filename_completer,
	location_completer, expression_completer, command_completer): Adapt
	prototypes to new completer prototype.
	* interps.c (interpreter_completer): Adapt to new completer
	prototype.
	* python/python-cmd.c: New file.
	* python/python-internal.h (gdbpy_initialize_commands): Add
	prototype.
	(gdbpy_doc_cst): Add forward declaration.
	* python/python.c (gdbpy_doc_cst): Declare.
	(_initialize_python): Call gdbpy_initialize_commands.  Initialize
	gdbpy_doc_cst.
	* symtab.c (make_symbol_completion_list_fn): New function.
	* symtab.h (make_symbol_completion_list_fn): Add prototype.

gdb/doc/
2009-02-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.texinfo (Python API): Add entry for Commands In Python.
	(Commands In Python): New node.

gdb/testsuite/
2009-02-06  Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	* gdb.python/python-cmd.exp: New file.
@
text
@d773 1
a773 1
struct partial_symtab *
@


1.200
log
@        Updated copyright notices for most files.
@
text
@d3893 10
@


1.199
log
@	* symtab.c (search_symbols): Update.
	* symtab.h (domain_enum_tag) <METHODS_DOMAIN>: Remove.
@
text
@d4 1
a4 1
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2007, 2008
@


1.199.2.1
log
@2008-11-20  Stan Shebs  <stan@@codesourcery.com>

	Multi-process (primarily multi-exec) support.

	2008-10-14  Stan Shebs  <stan@@codesourcery.com>

	* blockframe.c (get_frame_block): Get inferior from frame.
	* block.c (block_for_pc_inf): New function.
	* block.h (block_for_pc_inf): Declare.
	* symfile.c (find_pc_inf_sect): New function.
	* symfile.h (find_pc_inf_sect): Declare.
	* symtab.c (find_pc_inf_line): New function.
	* symtab.h (find_pc_inf_line): Declare.
	* frame.c (struct frame_info) New field inferior.
	(fprint_frame_id): Display inferior.
	(get_frame_id): Set inferior_num from inferior.
	(frame_id_eq): Compare inferiors.
	(create_sentinel_frame): Set inferior.
	(create_new_frame): Copy inferior from sentinel.
	(get_prev_frame_raw): Copy inferior from next frame.
	(find_frame_sal): Use find_pc_inf_line.
	(get_frame_inferior): New function.
	* frame.h (struct frame_id): New field inferior_num.

	* breakpoint.c (expand_sals_by_inferiors): Copy section from input
	sal to expanded sals.
	* symtab.c (expand_line_sal): Ditto.

	2008-10-10  Stan Shebs  <stan@@codesourcery.com>

	* remote.c (discard_pending_stop_replies): Initialize prev.
	* infrun.c (infrun_thread_stop_requested): Ditto.

	2008-10-08  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (struct inferior): Rename environ field to inf_environ.
	* inferior.c (print_inferior): Ditto.

	2008-10-01  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (detach_fork): Declare here...
	* linux-fork.h (detach_fork): ...instead of here.
	* linux-fork.c (detach_fork): Move to...
	* infrun.c (detach_fork): ...here.
	* remote.c (detach_fork): Remove decl.

	2008-09-30  Stan Shebs  <stan@@codesourcery.com>

	* linespec.c (decode_line_1): Better default for one-exec case.
	* remote (remote_start_remote): Use the exec in the one-exec case.

	2008-09-29  Stan Shebs  <stan@@codesourcery.com>

	* infcmd.c (attach_command): If only one exec, assume it is the
	attached inferior's exec.
	(attach_command_post_wait): Set inferior's exec from
	the one that was found.
	* inf-ptrace.c (inf_ptrace_attach): Only report exec file if
	if there is just one present.
	(inf_ptrace_detach): Use inferior to get correct exec name.

	2008-09-29  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (print_inferior): Use exec short names, and drop
	unused address space display.

	2008-09-26  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (should_be_inserted): Test for no inferior.
	(clone_breakpoint_location): New function, broken out from...
	(update_breakpoint_inferiors): ...here, also tweak conditions
	for adding a location.
	(insert_breakpoint_location): Don't count non-running inferiors.
	(remove_breakpoint): Set tmp_inf.
	(print_one_breakpoint_location): Add allflag arg, use to always
	show inf.
	(print_one_breakpoint): Add allflag arg.
	(do_captured_breakpoint_query): Fix caller.
	(breakpoint_1): Ditto.
	* exec.c (create_exec): Save full pathname as exec name.
	(find_exec_by_name): Use find_exec_by_substr.
	* fork-child.c (fork_inferior): Warn if exec not found for new
	inferior.

	2008-09-25  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (should_be_inserted): Don't insert in inferiors
	that are not running.
	(update_breakpoint_inferiors): New function.
	(insert_breakpoints): Call it.
	(insert_breakpoint_locations): Don't insert in inferiors that are
	not running.
	(set_raw_breakpoint_without_location): Set trigger set from
	current itset here...
	(set_raw_breakpoint): Instead of here. Also add default fillins
	for the location's inferior.
	(add_location_to_breakpoint): Similarly.
	(expand_sals_by_inferiors): New function.
	(breakpoint_re_set_one): Call it.
	(resolve_sal_pc): Don't set sal inferior.
	* breakpoint.h (struct breakpoint): Remove exec field, never used.
	* inferior.h (inferior_list): Declare.
	* inferior.c (inferior_list): Make public.
	(add_inferior_to_itset): Auto-add inferiors after exec's inferior.
	(first_inferior_in_set): Check for zero-length vector.
	* exec.c (xfer_memory): Use tmp_inf as inferior if set.
	* infcmd.c (focus_command): Improve user feedback.
	* linespec.c (build_canonical_line_spec): Record exec name as part
	of canonical spec.
	(symbol_found): Canonicalize specs more.
	(decode_indirect): Revert rewrite from 2008-09-14.
	(decode_sharp): Use find_exec_by_substr, better error messages.
	* minsyms.c (lookup_minimal_symbol_in_exec): New function.
	(lookup_minimal_symbol_in_exec_1): New function, body of
	lookup_minimal_symbol.
	* symtab.h (lookup_minimal_symbol_in_exec): Declare.
	* symtab.c (find_function_start_sal): Set inferior to use.
	(append_expanded_sal): Return pointer to the new sal.
	* remote.c (remote_xfer_memory): Better parms to ptid_build, remove
	debug print.
	(remote_xfer_partial): Ditto.

	2008-09-22  Pedro Alves  <pedro@@codesourcery.com>

	* inferior.c (itset_member): Fix typo.

	2008-09-22  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (current_inf): Remove declaration.
	(tmp_inf): Declare.
	* inferior.c (current_inf): Remove.
	(tmp_inf): New global, hack to bypass passing inferior throughout
	target stack.
	(print_inferior): Don't report current_inf.
	(add_inferior_command): Don't use current_inf.
	(name_inferior_command): Use first inferior of current_itset.
	(update_itset): Handle NULL case.
	(add_inferior_itset): Recursively add all inferiors derived from
	an exec if the exec's own inferior is present.
	(first_inferior_in_set): New function.
	(free_inferior): Comment out until references cleared reliably.
	* infcmd.c (focus_command): Don't set current_inf.
	(get_inferior_args): Use first_inferior_in_set instead of
	current_inf.
	(set_inferior_args): Ditto.
	(set_inferior_args_vector): Ditto.
	(notice_args_set): Ditto.
	* breakpoint.c (insert_breakpoint_locations): Remove insertion test
	using current_inf, set tmp_inf.
	(reattach_breakpoints): Set tmp_inf.
	(bpstat_check_breakpoint_conditions): Test trigger set here...
	(bpstat_stop_status): ... instead of here.
	(bpstat_check_trigger_set): Add special case for exec's own
	inferior.
	(print_one_breakpoint_location): Also test for multiple inferiors
	before displaying location's inferior, flag trigger set with "i/t"
	instead of "focus".
	(check_duplicates): Pass location's inferior to...
	(check_duplicates_for): Add inferior arg and use.
	(set_raw_breakpoint): Override sal inferior with one from the
	trigger set.
	(add_location_to_breakpoint): Ditto.
	* remote.c (remote_xfer_memory): Switch inferiors if tmp_inf is
	set to something different from inferior_ptid.
	(remote_xfer_partial): Ditto.
	* top.c (execute_command): Always update the current itset.

	2008-09-19  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (set_inferior_exec): New function.
	(set_inferior_exec_command): New command.
	* inferior.h: Declare set_inferior_exec.
	* fork-child.c (fork_inferior): Set the inferior's exec.
	* remote.c (extended_remote_create_inferior_1): Ditto.
	gdb/doc/
	* gdb.texinfo (Debugging Multiple Programs): Describe set-exec.

	2008-09-18  Stan Shebs  <stan@@codesourcery.com>

	* target.c (target_resize_to_sections): Adjust execs' section
	tables too.

	2008-09-17  Stan Shebs  <stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Invoking GDB): Describe multiple program args.
	(File Options): Describe multi-program effects.
	(Multiple Programs): New section, multi-program debugging.
	(Forks): Rename section from "Processes".
	(Specify Location): Describe the #-syntax.
	(Variables): Describe the #-syntax.
	(Files): Describe add-file and add-exec-file.
	(Maintenance Commands): Describe maint print execs.

	2008-09-15  Stan Shebs  <stan@@codesourcery.com>

	* exec.c (addr_space_info_command): Don't try to display host address.

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* c-exp.y: (yylex): Accept '#' in identifiers.
	* linespec.c (decode_sharp): New function.
	(decode_line_1): Use it for #-syntax.
	(decode_indirect): Rewrite to accept exec arg and iterate over
	inferiors.
	(struct d_i_data): New struct for inferior iteration.
	(decode_indirect_callback): New function.
	(decode_variable): Pass in exec, use in symbol lookup.

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.h (struct bp_location): Add inferior field instead
	of address space field.
	* breakpoint.c (insert_breakpoint_locations): Only insert in
	appropriate inferior.
	(bpstat_check_trigger_set): New function.
	(bpstat_stop_status): Call it, check location's inferior also.
	(print_one_breakpoint_location): Report location's inferior.
	(set_raw_breakpoint): Set location inferior, clear an experiment.
	(add_location_to_breakpoint): Ditto.
	(expand_line_sal_maybe): Check for non-NULL original function.
	(resolve_sal_pc): Set sal inferior.
	(clear_command): Be careful to not clear anything twice.
	* symtab.h: Update declarations of symbol lookups.
	(struct symtab_and_line): Change address space to inferior field.
	* symtab.c (init_sal): Clear inferior field.
	(append_expanded_sal): Set inferior.
	(lookup_symbol_in_language_1): New function.
	(lookup_symbol_in_language): Call it.
	(lookup_symbol_in_exec_in_language): New function.
	(lookup_symbol): Detect #-syntax and find exec to use.
	(lookup_symbol_aux): Add exec argument and use it.
	(lookup_symbol_aux_symtabs): Ditto.
	(lookup_symbol_aux_psymtabs): Ditto.
	(basic_lookup_symbol_nonlocal): Ditto.
	(lookup_symbol_static): Ditto.
	(lookup_symbol_global): Ditto.
	* ada-lang.c (cp_lookup_symbol_nonlocal): Ditto.
	* cp-support.h (cp_lookup_symbol_nonlocal): Ditto.
	* cp-namespace.c (cp_lookup_symbol_nonlocal): Ditto.
	* language.h (struct language_defn): Ditto.
	* scm-valprint.c (scm_inferior_print): Add exec arg to
	lookup_symbol_global.
	* source.c (select_source_symtab): Use current_exec.
	* addrspace.h (struct addr_space): New field num.
	* exec.h (struct exec): New fields sections and sections_end.
	* exec.c (exec_file_attach_1): Set them from exec_ops, set
	inferior's address space name from exec.
	(find_exec_by_substr): New function.
	(build_section_table): Don't free old table.
	(print_section_info): Use exec's section table.
	(next_address_space_num): New global, numbering for address spaces.
	(new_address_space): Use it.
	(addr_space_info_command): Display it.
	* infcmd.c (set_current_exec): Set exec_ops section table.
	* inferior.h (update_itset): Declare.
	* inferior.c (add_inferior_silent): Set address space.
	(print_inferior): Display it.
	(number_of_inferiors): New function.
	(itset_member): New function.

	2008-09-04  Stan Shebs  <stan@@codesourcery.com>

	* corefile.c (close_exec_file): Remove #if 0 block.
	(validate_files): Use first_exec instead of exec_bfd.
	(get_exec_file): Ditto.
	* corelow.c (core_open): Ditto.
	* utils.c (string_to_core_addr): Ditto.
	* arch-utils.c (gdbarch_update_p): Ditto.
	* linux-thread-db.c (enable_thread_event): Ditto.
	(thread_db_get_thread_local_address ): Ditto.
	* exec.c (find_exec_by_name): Test short name also.
	(file_command): Set current exec.

	2008-09-03  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (add_threads_to_itset): Default to including all
	of an inferior's threads.

	2008-08-31  Stan Shebs  <stan@@codesourcery.com>

	Parsing for i/t sets.
	* inferior.h (struct itset_entry): New struct.
	(struct itset): Make thread lists be per-inferior, add parse state
	variables.
	* inferior.c: (add_inferior_command): Add error checking and
	confirmation.
	(remove_inferior_command): Update for itset restructuring.
	(new_itset): Don't pass in dynamic-ness, call parse_itset_spec.
	(update_itset): Similarly.
	(parse_itset_spec): New, parsing of itset spec.
	(parse_itset_list, parse_itset_range, etc): New.
	(make_itset_from_spec): Rewrite.
	(dump_itset): Rewrite to reflect itset structure.
	* infcmd.c (focus_command): Similarly.

	2008-08-25  Stan Shebs  <stan@@codesourcery.com>

	First part of multiprocess support.
	* Makefile.in (COMMON_OBS): Add inferior.o.
	* addrspace.h: New file.
	* breakpoints.h (struct bp_location): Add address space field.
	(struct breakpoint): Add trigger set and exec fields.
	* breakpoints.c (print_one_breakpoint_location): Display trigger
	set.
	(set_raw_breakpoint): Set trigger set from current itset.
	* corefile.c (reopen_exec_file): Rewrite for multiple execs.
	(get_exec_file): Add case for current_exec.
	* corelow.c (is_core_file): New function.
	(core_files_info): Pass additional arg to print_section_info.
	* exec.h (struct exec): New struct.
	* exec.c (execs): New global.
	(exec_bfd_mtime): Remove.
	(last_exec_created, current_exec, first_exec): New globals.
	(exec_close): Clear all exec objects.
	(exec_file_clear): Tweak user message.
	(exec_file_add): New function.
	(exec_file_attach_1): New function, body of exec_file_attach,
	plus new code to handle multiple execs.
	(exec_file_attach): Call it.
	(exec_file_update): New function.
	(create_exec, find_exec_by_name, number_of_execs): New functions.
	(exec_file_command): Rephrase query, set current exec.
	(add_exec_file_command): New command.
	(add_file_command): New command.
	(print_section_info): Add exec argument.
	(exec_files_info): Rewrite for multiple execs.
	(maintenance_print_execs): New function.
	(new_address_space): New function.
	(addr_space_info_command): New command.
	* gdbcore.h (exec_bfd_mtime): Remove decl.
	(exec_file_add): Declare.
	* infcmd.c: Include exec.h.
	(current_itset): New global.
	(set_current_exec): New function.
	(focus_command): New command.
	(get_inferior_args): Maybe get from the current inferior.
	(set_inferior_args): Also set in current inferior.
	(set_inferior_args_vector): Similarly.
	(notice_args_set): Similarly.
	(attach_command): Rephrase query.
	* inferior.h (struct inferior): New struct.
	(struct itset): New struct.
	* inferior.c: New file, management of multiple inferiors.
	* main.c (captured_main): Rewrite to allow multiple executables,
	pids, and corefiles on the command line.
	* maint.c (maintenance_info_sections): Rewrite for multiple execs.
	* objfiles.h (struct objfile): New field for exec.
	(ALL_OBJFILES_FOR_EXEC, ALL_PRIMARY_SYMTABS_FOR_EXEC,
	ALL_PSYMTABS_FOR_EXEC): New macros.
	* objfiles.c (allocate_objfile): Clear exec field.
	* solib.c (clear_solib): Use first_exec instead of exec_bfd.
	* source.c (select_source_symtab): Use ALL_OBJFILES_FOR_EXEC.
	(find_source_lines): Use mtime from exec.
	* symfile.c (syms_from_objfile): Don't clear objfile if multiple
	execs.
	(new_symfile_objfile): Get objfile's exec from last_exec_created.
	(symbol_file_clear): Rephrase messages.
	(reread_symbols): Update objfile's exec if necessary.
	* symmisc.c (dump_objfile): Dump objfile's exec also.
	(maintenance_print_objfiles): Report symfile_objfile.
	* symtab.h (struct symtab_and_line): Add address space field.
	* symtab.c (find_pc_sect_psymtab): Look for a plausible exec, and
	then use it.
	(lookup_symbol_aux_symtabs): Use current exec.
	(lookup_symbol_aux_symtabs): Ditto.
	(basic_lookup_transparent_type): Ditto.
	(find_pc_sect_symtab): Ditto.
	* target.h (print_section_info): Add arg to decl.
	* tui/tui-win.c: Rename "focus" command to "ffocus".

gdb/testsuite:

2008-11-20  Stan Shebs  <stan@@codesourcery.com>

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* gdb.gdb/selftest.exp: Update to reflect current sources.
	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* configure.ac (AC_OUTPUT): Add gdb.multi/Makefile.
	* configure: Regenerate.

	* gdb.multi/Makefile.in: New.
	* gdb.multi/hello.c, hangout.c, goodbye.c: New source files.
	* gdb.multi/base.exp: New file, basic multiprocess tests.

	2008-08-25  Stan Shebs  <stan@@codesourcery.com>

	* config/monitor.exp: Match on rephrased message.
	* gdb.base/attach.exp: Ditto.
	* gdb.base/default.exp: Ditto.
	* lib/gdb.exp: Ditto.
@
text
@a30 1
#include "exec.h"
a88 1
					 const struct exec *exec,
a102 1
					  const struct exec *exec,
a108 1
					   const struct exec *exec,
a699 1
  sal->inferior = NULL;
a854 1
  struct exec *exec;
a870 14
  exec = NULL;
#if 0
  if (section)
    {
      int ix;
      struct exec *ex;
      for (ix = 0; VEC_iterate(exec_p, execs, ix, ex); ++ix)
	if (strcmp (section->owner->filename, ex->ebfd->filename) == 0)
	  {
	    exec = ex;
	    break;
	  }
    }
#endif
d872 1
a872 1
  ALL_OBJFILES_FOR_EXEC (objfile, exec)
d912 1
a912 1
  ALL_OBJFILES_FOR_EXEC (objfile, exec)
a1191 6
extern struct symbol *
lookup_symbol_in_language_1 (const char *name, const struct block *block,
			     const struct exec *exec,
			     const domain_enum domain, enum language lang,
			     int *is_a_field_of_this);

a1196 20
  return lookup_symbol_in_language_1 (name, block, current_exec, domain, lang,
				      is_a_field_of_this);
}

struct symbol *
lookup_symbol_in_exec_in_language (const char *name, const struct block *block,
				   const struct exec *exec,
				   const domain_enum domain, enum language lang,
				   int *is_a_field_of_this)
{
  return lookup_symbol_in_language_1 (name, block, exec, domain, lang,
				      is_a_field_of_this);
}

struct symbol *
lookup_symbol_in_language_1 (const char *name, const struct block *block,
			     const struct exec *exec,
			     const domain_enum domain, enum language lang,
			     int *is_a_field_of_this)
{
d1242 1
a1242 1
  returnval = lookup_symbol_aux (modified_name, mangled_name, block, exec,
a1256 14
  if (*name == '#')
    {
      char *name2 = strchr (name + 1, '#');
      struct exec *exec = current_exec;

      if (name2)
	{
	  exec = find_exec_by_substr (((char *) name) + 1, name2);
	  return lookup_symbol_in_exec_in_language (name2 + 1, block, exec, domain,
						    current_language->la_language,
						    is_a_field_of_this);
	}
    }

a1261 10
struct symbol *
lookup_symbol_in_exec (const char *name, const struct block *block,
		       const struct exec *exec,
		       domain_enum domain, int *is_a_field_of_this)
{
  return lookup_symbol_in_exec_in_language (name, block, exec, domain,
					    current_language->la_language,
					    is_a_field_of_this);
}

d1269 1
a1269 2
		   const struct block *block, const struct exec *exec,
		   const domain_enum domain,
d1334 1
a1334 1
  sym = langdef->la_lookup_symbol_nonlocal (name, linkage_name, block, exec, domain);
d1344 1
a1344 1
  sym = lookup_symbol_aux_symtabs (STATIC_BLOCK, name, linkage_name, exec, domain);
d1348 1
a1348 1
  sym = lookup_symbol_aux_psymtabs (STATIC_BLOCK, name, linkage_name, exec, domain);
a1481 1
			   const struct exec *exec,			   
d1490 1
a1490 1
  ALL_PRIMARY_SYMTABS_FOR_EXEC (objfile, exec, s)
a1512 1
			    const struct exec *exec,
d1523 1
a1523 1
  ALL_PSYMTABS_FOR_EXEC (objfile, exec, ps)
a1569 1
			      const struct exec *exec,
d1602 1
a1602 1
  sym = lookup_symbol_static (name, linkage_name, block, exec, domain);
d1606 1
a1606 1
  return lookup_symbol_global (name, linkage_name, block, exec, domain);
a1615 1
		      const struct exec *exec,
a1632 1
		      const struct exec *exec,
d1645 1
a1645 1
  sym = lookup_symbol_aux_symtabs (GLOBAL_BLOCK, name, linkage_name, exec, domain);
d1649 1
a1649 1
  return lookup_symbol_aux_psymtabs (GLOBAL_BLOCK, name, linkage_name, exec, domain);
d1797 1
a1797 1
  ALL_PRIMARY_SYMTABS_FOR_EXEC (objfile, current_exec, s)
d1845 1
a1845 1
  ALL_PRIMARY_SYMTABS_FOR_EXEC (objfile, current_exec, s)
a1985 1
  struct exec *exec;
d2018 1
a2018 16
  exec = NULL;
#if 0
  if (section)
    {
      int ix;
      struct exec *ex;
      for (ix = 0; VEC_iterate(exec_p, execs, ix, ex); ++ix)
	if (strcmp (section->owner->filename, ex->ebfd->filename) == 0)
	  {
	    exec = ex;
	    break;
	  }
    }
#endif

  ALL_PRIMARY_SYMTABS_FOR_EXEC (objfile, exec, s)
a2337 32
struct symtab_and_line
find_pc_inf_line (CORE_ADDR pc, struct inferior *inf, int notcurrent)
{
  struct objfile *objfile;
  struct obj_section *osect;
  asection *section;
  int size;
  struct symtab_and_line sal;

  if (!inf || number_of_execs () <= 1)
    return find_pc_line (pc, notcurrent);

  ALL_OBJSECTIONS (objfile, osect)
    {
      if (objfile->exec == inf->exec)
	{
	  section = osect->the_bfd_section;
	  if (section)
	    {
	      size = bfd_get_section_size (section);
	      if (section->vma <= pc && pc < section->vma + size)
		{
		  sal = find_pc_sect_line (pc, osect, notcurrent);
		  sal.inferior = inf;
		  return sal;
		}
	    }
	}
    }
  return find_pc_line (pc, notcurrent);
}

a2609 1
      tmp_inf = ((objfile && objfile->exec) ? objfile->exec->inferior : NULL);
a2611 1
      tmp_inf = NULL;
d4423 1
a4423 1
/*static*/ struct symtab_and_line *
d4428 1
a4428 1
  struct symtab_and_line *new_sal;
d4433 6
a4438 7
  new_sal = sal->sals + sal->nelts;
  init_sal (new_sal);
  new_sal->symtab = symtab;
  new_sal->section = NULL;
  new_sal->end = 0;
  new_sal->line = lineno;  
  new_sal->pc = pc;
a4439 1
  return new_sal;
a4521 1
		      ret.sals[ret.nelts-1].section = sal.section;
d4551 1
a4551 1
      blocks[i] = block_for_pc_sect (ret.sals[i].pc, ret.sals[i].section);
@


1.198
log
@	* symtab.c (find_pc_sect_psymtab): Use MSYMBOL_TYPE.
	(find_pc_sect_symtab): Likewise.
	* symmisc.c (dump_msymbols): Use MSYMBOL_TYPE.
	* solib-som.c (som_solib_desire_dynamic_linker_symbols): Use
	MSYMBOL_TYPE, not SYMBOL_TYPE.
	* parse.c (write_exp_msymbol): Use MSYMBOL_TYPE.
	* objc-lang.c (find_methods): Use MSYMBOL_TYPE.
	* minsyms.c (lookup_minimal_symbol_by_pc_section_1): Use
	MSYMBOL_TYPE.
	* m2-exp.y (yylex): Use SYMBOL_CLASS.
@
text
@a2991 1
   METHODS_DOMAIN   - search all methods NOT IMPLEMENTED
d3132 1
a3132 2
			|| (kind == TYPES_DOMAIN && SYMBOL_CLASS (*psym) == LOC_TYPEDEF)
			|| (kind == METHODS_DOMAIN && SYMBOL_CLASS (*psym) == LOC_BLOCK))))
d3207 1
a3207 2
			  || (kind == TYPES_DOMAIN && SYMBOL_CLASS (sym) == LOC_TYPEDEF)
			  || (kind == METHODS_DOMAIN && SYMBOL_CLASS (sym) == LOC_BLOCK))))
@


1.197
log
@gdb
	PR gdb/2484:
	* symtab.c (struct add_macro_name_data): New struct.
	(add_macro_name): New function.
	(default_make_symbol_completion_list): Complete macro names.
	* scm-lang.c (scm_language_defn): Update.
	* p-lang.c (pascal_language_defn): Update.
	* objc-lang.c (objc_language_defn): Update.
	* macrotab.h (macro_callback_fn): Add user_data argument.
	(macro_for_each): Likewise.
	(macro_for_each_in_scope): Declare.
	* macrotab.c: (struct macro_for_each_data): New struct.
	(foreach_macro): Use it.
	(macro_for_each): Likewise.
	(foreach_macro_in_scope): New function.
	(macro_for_each_in_scope): Likewise.
	* macrocmd.c (print_one_macro): Add argument.
	(macro_list_command): Pass NULL to macro_for_each.
	* m2-lang.c (m2_language_defn): Update.
	* language.h (struct language_defn) <la_macro_expansion>: New
	field.
	(macro_expansion): New enum.
	* language.c (unknown_language_defn): Update.  Fix order of
	initializers.
	(auto_language_defn): Likewise.
	(local_language_defn): Update.
	* jv-lang.c (java_language_defn): Update.
	* f-lang.c (f_language_defn): Update.
	* c-lang.c (c_language_defn): Update.
	(cplus_language_defn): Likewise.
	(asm_language_defn): Likewise.
	(minimal_language_defn): Likewise.
	* ada-lang.c (ada_language_defn): Update.
gdb/testsuite
	* gdb.base/macscp.exp: Add completion tests.
	* gdb.base/macscp1.c (FIFTY_SEVEN): New macro.
	(TWENTY_THREE): Likewise.
	(FORTY_EIGHT): Likewise.
@
text
@d862 5
a866 5
      && (msymbol->type == mst_data
	  || msymbol->type == mst_bss
	  || msymbol->type == mst_abs
	  || msymbol->type == mst_file_data
	  || msymbol->type == mst_file_bss))
d1996 5
a2000 5
      && (msymbol->type == mst_data
	  || msymbol->type == mst_bss
	  || msymbol->type == mst_abs
	  || msymbol->type == mst_file_data
	  || msymbol->type == mst_file_bss))
@


1.196
log
@	* symtab.c (skip_prologue_using_sal): Treat two consecutive lines
	at the same address as a prologue marker.  Do not skip an entire
	function.
@
text
@d61 2
d3645 23
d3854 29
@


1.195
log
@	* breakpoint.h (struct bp_location): Change type of section
	member to "struct obj_section *".
	* tracepoint.h (struct tracepoint): Likewise.
	* symtab.h (struct general_symbol_info): Replace bfd_section
	member with obj_section.
	(struct symtab_and_line): Change type of section member to
	"struct obj_section *".
	(SYMBOL_BFD_SECTION): Remove macro, replace by ...
	(SYMBOL_OBJ_SECTION): ... this.

	* minsym.c (prim_record_minimal_symbol_and_info): Record symbol
	section as obj_section instead of bfd_section.

	* ada-lang.c (ada_decode_symbol): Use gsymbol->obj_section
	directly instead of looking of obj_section from bfd_section.

	* objfiles.h (find_pc_sect_section): Remove.
	* objfiles.c (find_pc_sect_section): Remove.
	(find_pc_section): Inline find_pc_sect_section code.

	* symfile.h (find_pc_overlay): Return struct obj_section *.
	(find_pc_mapped_section): Likewise.
	(section_is_overlay, section_is_mapped): Change type of section
	argument to struct obj_section *.
	(pc_in_mapped_range, pc_in_unmapped_range): Likewise.
	(overlay_mapped_address, overlay_unmapped_address): Likewise.
	(symbol_overlayed_address): Likewise.
	* symtab.h (symbol_overlayed_address): Likewise.
	* symfile.c (overlay_is_mapped): Remove.
	(section_is_mapped): Inline overlay_is_mapped code.  Update.
	(overlay_invalidate_all): Update.
	(section_is_overlay): Change section argument to type
	"struct obj_section *".  Use bfd_ methods.
	(pc_in_unmapped_range): Likewise.  Handle relocated sections.
	(pc_in_mapped_range): Likewise.  Handle relocated sections.
	(sections_overlap): Likewise.
	(overlay_unmapped_address): Likewise.
	(overlay_mapped_address): Likewise.
	(symbol_overlayed_address): Likewise.
	(find_pc_overlay): Return struct obj_section *.
	(find_pc_mapped_section): Likewise.
	(list_overlays_command): Update.
	(map_overlay_command, unmap_overlay_command): Update.
	(simple_overlay_update): Update.

	* block.h (blockvector_for_pc_sect): Change section argument
	to type "struct obj_section *".
	(block_for_pc_sect): Likewise.
	* block.c (blockvector_for_pc_sect): Change section argument
	to type "struct obj_section *".
	(block_for_pc_sect): Likewise.
	* symtab.h (find_pc_sect_function, find_pc_sect_psymtab,
	find_pc_sect_symtab, find_pc_sect_psymbol, find_pc_sect_line,
	lookup_minimal_symbol_by_pc_section, find_function_start_pc): Likewise.
	(matching_bfd_sections): Rename to ...
	(matching_obj_sections): ... this.  Update argument types.
	* blockframe.c (find_pc_sect_function): Likewise.
	* breakpoint.c (describe_other_breakpoints): Likewise.
	(breakpoint_has_pc, check_duplicates_for): Likewise.
	* minsyms.c (lookup_minimal_symbol_by_pc_section_1): Likewise.
	(lookup_minimal_symbol_by_pc_section): Likewise.
	* symtab.c (find_pc_sect_psymtab_closer): Likewise.
	(find_pc_sect_psymtab, find_pc_sect_psymbol, find_pc_sect_symtab,
	find_pc_sect_line, find_function_start_pc): Likewise.
	(matching_bfd_sections): Rename to ...
	(matching_obj_sections): ... this.  Update argument types.

	* blockframe.c (find_pc_partial_function): Update to section
	type changes.  No longer call find_pc_sect_section.
	(cache_pc_function_section): Change to type "struct obj_section *".
	* breakpoint.c (resolve_sal_pc): Update to section type changes.
	* exec.c (xfer_memory): Likewise.
	* findvar.c (read_var_value): Likewise.
	* infcmd.c (jump_command): Likewise.
	* linespec.c (minsym_found): Likewise.
	* maint.c (maintenance_translate_address): Likewise.
	* minsyms.c (lookup_minimal_symbol_by_pc_section_1): Likewise.
	(lookup_solib_trampoline_symbol_by_pc): Likewise.
	* parse.c (write_exp_msymbol): Likewise.
	* printcmd.c (build_address_symbolic): Likewise.
	(address_info, sym_info): Likewise.
	* symmisc.c (dump_msymbols, print_symbol): Likewise.
	* symtab.c (fixup_section): Likewise.
	(fixup_symbol_section, fixup_psymbol_section): Likewise.
	(find_pc_line, find_function_start_sal): Likewise.
	* target.c (memory_xfer_partial): Likewise.
	* hppa-hpux-tdep.c (hppa64_hpux_in_solib_call_trampoline): Likewise.
	* spu-tdep.c (spu_overlay_update): Likewise.
@
text
@d4201 1
d4210 23
d4238 1
d4260 8
a4267 1
  return prologue_sal.end;
@


1.194
log
@	* buildsym.c (add_symbol_to_list): Do not call
	cp_scan_for_anonymous_namespaces here.
	(finish_block): Do not call cp_set_block_scope here.
	* cp-namespace.c (processing_has_namespace_info)
	(processing_current_prefix): Delete.
	(cp_initialize_namespace): Do not initialize
	processing_has_namespace_info.
	(cp_scan_for_anonymous_namespaces): Use SYMBOL_DEMANGLED_NAME.  Do
	not check processing_has_namespace_info.
	(cp_set_block_scope): Take prefix and namespace info flag as
	arguments.  Honor namespaces regardless of a demangled name.
	* cp-support.h (processing_has_namespace_info)
	(processing_current_prefix): Delete declarations.
	(cp_set_block_scope): Update prototype.
	* dwarf2read.c (processing_has_namespace_info)
	(processing_current_prefix): New static variables.
	(read_file_scope): Initialize processing_has_namespace_info.
	(read_func_scope): Call cp_set_block_scope for C++.
	(new_symbol): Call cp_scan_for_anonymous_namespaces for C++.
	* symtab.c (symbol_demangled_name): Accept a const argument.
	* symtab.h (symbol_demangled_name): Update prototype.
@
text
@d708 2
a709 1
matching_bfd_sections (asection *first, asection *second)
d711 2
d772 1
a772 1
find_pc_sect_psymtab_closer (CORE_ADDR pc, asection *section,
d850 1
a850 1
find_pc_sect_psymtab (CORE_ADDR pc, asection *section)
d947 1
a947 1
		      asection *section)
d979 1
a979 1
	      if (!matching_bfd_sections (SYMBOL_BFD_SECTION (p), section))
d1003 1
a1003 1
	      if (!matching_bfd_sections (SYMBOL_BFD_SECTION (p), section))
d1040 1
a1040 1
      ginfo->bfd_section = SYMBOL_BFD_SECTION (msym);
d1090 1
a1090 1
	      ginfo->bfd_section = s->the_bfd_section;
d1106 1
a1106 1
  if (SYMBOL_BFD_SECTION (sym))
d1148 1
a1148 1
  if (SYMBOL_BFD_SECTION (psym))
d1976 1
a1976 1
find_pc_sect_symtab (CORE_ADDR pc, asection *section)
d2046 1
a2046 1
		if (matching_bfd_sections (SYMBOL_BFD_SECTION (sym), section))
d2104 1
a2104 1
find_pc_sect_line (CORE_ADDR pc, struct bfd_section *section, int notcurrent)
d2341 1
a2341 1
  asection *section;
d2573 1
a2573 1
			CORE_ADDR pc, asection *section)
d2609 1
a2609 1
      pc = find_function_start_pc (gdbarch, pc, SYMBOL_BFD_SECTION (sym));
d2611 1
a2611 1
  sal = find_pc_sect_line (pc, SYMBOL_BFD_SECTION (sym), 0);
d2622 1
a2622 1
      sal = find_pc_sect_line (pc, SYMBOL_BFD_SECTION (sym), 0);
d2636 1
a2636 1
      sal = find_pc_sect_line (pc, SYMBOL_BFD_SECTION (sym), 0);
@


1.193
log
@	* objfiles.h (struct obj_section): Remove addr and endaddr fields.
	(obj_section_offset, obj_section_addr, obj_section_endaddr): New
	macros.
	* objfiles.c (add_to_objfile_sections): Don't set addr, endaddr
	and offset.  Use size_t instead of unsigned long.
	(build_objfile_section_table): Use size_t instead of unsigned
	long.
	(objfile_relocate): Don't relocate s->addr and s->endaddr, they're
	gone.
	(find_pc_sect_section): Use obj_section_addr and
	obj_section_endaddr.
	* symfile.c (symfile.c): Remove code that maps sections
	offsets in "addr" to the object's sections.
	* blockframe.c (find_pc_partial_function): Use obj_section_endaddr.
	* gcore.c (gcore_create_callback): Use obj_section_addr and
	obj_section_endaddr.
	* maint.c (print_objfile_section_info): Likewise.
	* printcmd.c (sym_info): Use obj_section_addr and
	obj_section_endaddr.
	* symtab.c (fixup_section): Likewise.
@
text
@d654 1
a654 1
symbol_demangled_name (struct general_symbol_info *gsymbol)
@


1.192
log
@gdb
	* symfile.c (reread_symbols): Don't pass argument to observer.
	* exec.c (exec_file_attach): Don't pass argument to observer.
	* ada-lang.c (ada_executable_changed_observer): Remove argument.
	* symtab.c (symtab_observer_executable_changed): Remove argument.
	* observer.sh: Handle functions with no arguments.
gdb/doc
	* observer.texi (GDB Observers): Remove obsolete comment.
	<executable_changed>: Remove argument.
@
text
@d1084 2
a1085 1
	  if (s->addr - offset <= addr && addr < s->endaddr - offset)
@


1.191
log
@      * symtab.c (expand_line_sal): Fix a memory leak.
@
text
@d4328 1
a4328 1
symtab_observer_executable_changed (void *unused)
@


1.190
log
@	* gdbarch.sh (gdbarch_skip_main_prologue): New.
	* gdbarch.h, gdbarch.c: Regenerate.
	* i386-tdep.h (i386_skip_main_prologue): Declare.
	* i386-tdep.c (i386_skip_main_prologue): New.
	* i386-cygwin-tdep.c (i386_cygwin_init_abi): Register
	i386_skip_main_prologue as gdbarch_skip_main_prologue gdbarch callback.
	* symtab.c (find_function_start_sal): When pc points at the "main"
	function, call gdbarch_skip_main_prologue.
@
text
@d4459 2
a4460 2
  filter = xmalloc (ret.nelts * sizeof (int));
  blocks = xmalloc (ret.nelts * sizeof (struct block *));
@


1.189
log
@	* symtab.h (enum address_class): Remove LOC_REGPARM and
	LOC_COMPUTED_ARG.
	(struct symbol): Add is_argument.
	(SYMBOL_IS_ARGUMENT): Define.

	* ada-lang.c (ada_add_block_symbols): Use SYMBOL_IS_ARGUMENT.
	* buildsym.c (finish_block): Likewise.
	* stack.c (print_frame_args, print_block_frame_locals)
	(print_frame_arg_vars): Likewise.
	* symtab.c (lookup_block_symbol): Likewise.
	* tracepoint.c (add_local_symbols): Likewise.
	* mi/mi-cmd-stack.c (list_args_or_locals): Likewise.

	* coffread.c (process_coff_symbol): Set SYMBOL_IS_ARGUMENT.
	* dwarf2read.c (new_symbol): Likewise.
	* mdebugread.c (parse_symbol): Likewise.
	* stabsread.c (define_symbol): Likewise.

	* ada-exp.y (select_possible_type_sym): Don't handle LOC_REGPARM
	and LOC_COMPUTED_ARG.
	* ada-lang.c (resolve_subexp, symtab_for_sym): Likewise.
	* ax-gdb.c (gen_var_ref): Likewise.
	* eval.c (evaluate_subexp_for_address): Likewise.
	* findvar.c (symbol_read_needs_frame, read_var_value): Likewise.
	* m2-exp.y (yylex): Likewise.
	* printcmd.c (address_info): Likewise.
	* symmisc.c (print_symbol, print_partial_symbols): Likewise.
	* tracepoint.c (collect_symbol, scope_info): Likewise.

testsuite/:
	* gdb.base/frame-args.exp: Handle arguments that are optimized
	out.
@
text
@d2620 15
@


1.188
log
@	* symtab.h (enum address_class): Remove LOC_BASEREG and
	LOC_BASEREG_ARG.
	(struct symbol): Remove "basereg" member of "aux_value" union.
	(SYMBOL_BASEREG): Remove.

	* ada-exp.y (select_possible_type_sym): Do not handle LOC_BASEREG
	or LOC_BASEREG_ARG.
	* ada-lang.c (resolve_subexp, symtab_for_sym): Likewise.
	(ada_add_block_symbols): Likewise.
	* ax-gdb.c (gen_var_ref): Likewise.
	* buildsym.c (finish_block): Likewise.
	* findvar.c (symbol_read_needs_frame, read_var_value): Likewise.
	* m2-exp.y (yylex): Likewise.
	* mi/mi-cmd-stack.c (list_args_or_locals): Likewise.
	* printcmd.c (address_info): Likewise.
	* stack.c (print_frame_args, print_block_frame_locals): Likewise.
	(print_frame_arg_vars): Likewise.
	* symmisc.c (print_symbol): Likewise.
	* symtab.c (lookup_block_symbol): Likewise.
	* tracepoint.c (collect_symbol, add_local_symbols): Likewise.
	(scope_info): Likewise.
@
text
@d1958 1
a1958 5
	      if (SYMBOL_CLASS (sym) != LOC_ARG &&
		  SYMBOL_CLASS (sym) != LOC_REF_ARG &&
		  SYMBOL_CLASS (sym) != LOC_REGPARM &&
		  SYMBOL_CLASS (sym) != LOC_REGPARM_ADDR &&
		  SYMBOL_CLASS (sym) != LOC_COMPUTED_ARG)
@


1.187
log
@	* symtab.h (enum address_class): Remove LOC_LOCAL_ARG.

	* ada-exp.y (select_possible_type_sym): Do not handle LOC_LOCAL_ARG.
	* ada-lang.c (resolve_subexp, symtab_for_sym): Likewise.
	(ada_add_block_symbols): Likewise.
	* ax-gdb.c (gen_var_ref): Likewise.
	* buildsyms.c (finish_block): Likewise.
	* findvar.c (symbol_read_needs_frame, read_var_value): Likewise.
	* m2-exp.y (yylex): Likewise.
	* mi/mi-cmd-stack.c (list_args_or_locals): Likewise.
	* printcmd.c (address_info): Likewise.
	* stack.c (print_frame_args, print_frame_arg_vars): Likewise.
	* symmisc.c (print_symbol, print_partial_symbols): Likewise.
	* symtab.c (lookup_block_symbol): Likewise.
	* tracepoint.c (collect_symbol, add_local_symbols): Likewise.
	(scope_info): Likewise.
@
text
@a1961 1
		  SYMBOL_CLASS (sym) != LOC_BASEREG_ARG &&
@


1.186
log
@	* symtab.h (enum address_class): Remove LOC_INDIRECT and
	LOC_HP_THREAD_LOCAL_STATIC.

	* findvar.c (symbol_read_needs_frame, read_var_value): Do not
	handle LOC_INDIRECT or LOC_HP_THREAD_LOCAL_STATIC.
	(read_var_value): Likewise.
	* buildsym.c (finish_block): Likewise.
	* objfiles.c (objfile_relocate): Likewise.
	* printcmd.c (address_info): Likewise.
	* symmisc.c (print_symbol, print_partial_symbols): Likewise.
	* tracepoint.c (scope_info): Likewise.
@
text
@a1958 1
		  SYMBOL_CLASS (sym) != LOC_LOCAL_ARG &&
@


1.185
log
@	* symtab.h (lookup_symbol_in_language): Update comment.
	* symtab.c (lookup_symbol_aux_block): Update comment.
	* ada-lang.c (ada_lookup_symbol_list): Update comment.
@
text
@a1118 1
    case LOC_INDIRECT:
a1152 1
    case LOC_INDIRECT:
@


1.184
log
@	* symtab.h (lookup_symbol_in_language): Remove SYMTAB parameter.
	(lookup_symbol): Likewise.
	* symtab.c (lookup_symbol_in_language): Remove SYMTAB parameter.
	(lookup_symbol): Likewise.
	(search_symbols): Update.

	* linespec.c (find_methods, collect_methods): Update.
	(add_matching_methods, add_constructors): Update.
	(decode_compound, decode_dollar, decode_variable): Update.
	(lookup_prefix_sym): Update.

	(symbol_found): Remove SYM_SYMTAB parameter.
	Use SYMBOL_SYMTAB (sym) instead.

	* gdbtypes.c (lookup_typename): Update.
	(lookup_struct, lookup_union, lookup_enum): Update.
	(lookup_template_type): Update.
	(check_typedef): Update.
	* language.c (lang_bool_type): Update.
	* mdebugread.c (parse_procedure): Update.
	* mi/mi-cmd-stack.c (list_args_or_locals): Update.
	* parse.c (write_dollar_variable): Update.
	* printcmd.c (address_info): Update.
	* source.c (select_source_symtab): Update.
	* stack.c (print_frame_args, print_frame_arg_vars): Update.
	* valops.c (find_function_in_inferior): Update.
	(value_struct_elt_for_reference): Update.
	* value.c (value_static_field, value_fn_field): Update.

	* alpha-mdebug-tdep.c (find_proc_desc): Update.
	* arm-tdep.c (arm_skip_prologue): Update.
	* mt-tdep.c (mt_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_skip_prologue): Update.

	* ada-lang.h (struct ada_symbol_info): Remove SYMTAB member.
	* ada-lang.c (ada_add_block_symbols): Remove SYMTAB parameter.
	(add_defn_to_vec): Likewise.
	(ada_add_block_symbols): Likewise.
	(lookup_cached_symbol, cache_symbol): Likewise.
	(standard_lookup): Update.
	(ada_lookup_symbol_list): Update.

	* c-valprint.c (c_val_print): Update.
	* cp-support.c (cp_lookup_rtti_type): Update.
	* jv-lang.c (java_lookup_class, get_java_object_type): Update.
	* objc-lang.c (lookup_struct_typedef, find_imps): Update.
	* p-valprint.c (pascal_val_print): Update.
	* scm-lang.c (scm_lookup_name): Update.

	* c-exp.y: Update.
	* f-exp.y: Update.
	* jv-exp.y: Update.
	* m2-exp.y: Update.
	* objc-exp.y: Update.
	* p-exp.y: Update.
@
text
@a1171 2
   If SYMTAB is non-NULL, store the symbol table in which the
   symbol was found there, or NULL if not found.
d1400 2
a1401 2
/* Look up a symbol in a block; if found, locate its symtab, fixup the
   symbol, and set block_found appropriately.  */
@


1.183
log
@	* language.h (struct language_defn): Remove SYMTAB parameter from
	la_lookup_symbol_nonlocal callback function pointer.

	* ada-lang.h (ada_lookup_encoded_symbol): Remove SYMTAB parameter.
	(ada_lookup_encoded_symbol): Likewise.
	* ada-lang.c (ada_lookup_encoded_symbol): Remove SYMTAB parameter.
	Always call fixup_symbol_section.
	(ada_lookup_symbol): Remove SYMTAB parameter.
	(ada_lookup_symbol_nonlocal): Likewise.
	* ada-exp.y (write_object_renaming): Update.
	(find_primitive_type): Likewise.

	* cp-support.h (cp_lookup_symbol_nonlocal): Remove SYMTAB parameter.
	(cp_lookup_symbol_namespace): Likewise.
	* cp-namespace.c (lookup_namespace_scope): Remove SYMTAB parameter.
	(lookup_symbol_file): Likewise.
	(lookup_possible_namespace_symbol): Likewise.
	(cp_lookup_symbol_nonlocal): Likewise.
	(cp_lookup_symbol_namespace): Likewise.
	(cp_lookup_nested_type): Update.

	* scm-valprint.c (scm_inferior_print): Update.
	* valops.c (value_maybe_namespace_elt): Update.

	* solist.h (struct target_so_ops): Remove SYMTAB parameter from
	lookup_lib_global_symbol callback function pointer.
	(solib_global_lookup): Remove SYMTAB parameter.
	* solib.c (solib_global_lookup): Remove SYMTAB parameter.
	* solib-svr4.c (elf_lookup_lib_symbol): Likewise.

	* symtab.h (basic_lookup_symbol_nonlocal): Remove SYMTAB parameter.
	(lookup_symbol_static): Likewise.
	(lookup_symbol_global): Likewise.
	(lookup_symbol_aux_block): Likewise.
	(lookup_global_symbol_from_objfile): Likewise.
	* symtab.c (lookup_symbol_aux): Remove SYMTAB parameter.
	(lookup_symbol_aux_local): Likewise.
	(lookup_symbol_aux_block): Likewise.
	(lookup_symbol_aux_symtabs): Likewise.
	(lookup_symbol_aux_psymtabs): Likewise.
	(lookup_global_symbol_from_objfile): Likewise.
	(basic_lookup_symbol_nonlocal): Likewise.
	(lookup_symbol_static): Likewise.
	(lookup_symbol_global): Likewise.

	(lookup_symbol_in_language): Do not pass SYMTAB to lookup_symbol_aux.
@
text
@d1193 1
a1193 2
			   int *is_a_field_of_this,
			   struct symtab **symtab)
a1244 4
  /* Override the returned symtab with the symbol's specific one.  */
  if (returnval != NULL && symtab != NULL)
    *symtab = SYMBOL_SYMTAB (returnval);

d1253 1
a1253 2
	       domain_enum domain, int *is_a_field_of_this,
	       struct symtab **symtab)
d1257 1
a1257 1
				    is_a_field_of_this, symtab);
d3169 1
a3169 2
					  VAR_DOMAIN,
					  0, (struct symtab **) NULL)
d3255 2
a3256 2
				       (struct block *) NULL, VAR_DOMAIN,
				       0, (struct symtab **) NULL) == NULL)
@


1.182
log
@gdb/

2008-05-15  Pedro Alves  <pedro@@codesourcery.com>
	    Ulrich Weigand  <uweigand@@de.ibm.com>

	* minsyms.c (lookup_minimal_symbol_by_pc_name): New function.
	* symtab.h (lookup_minimal_symbol_by_pc_name): Add prototype.

	* symtab.c (fixup_section): Remove prototype.  Add ADDR parameter;
	use it instead of ginfo->value.address.  Look up minimal symbol by
	address and name.  Assume OBJFILE is non-NULL.
	(fixup_symbol_section): Ensure we always have an objfile to look
	into.  Extract and pass to fixup_section the symbol's address that
	will match the minimal symbol's address.
	(fixup_psymbol_section): Likewise.

	(find_pc_sect_psymtab): Fall back to non-addrmap case when debugging
	overlays and the addrmap returned the wrong section.

	* dwarf2read.c (var_decode_location): Set SYMBOL_CLASS before
	calling fixup_symbol_section.


gdb/testsuite/

2008-05-15  Pedro Alves  <pedro@@codesourcery.com>

	* gdb.base/fixsection.exp: New file.
	* gdb.base/fixsection0.c: New file.
	* gdb.base/fixsection1.c: New file.
@
text
@d89 1
a89 2
					 int *is_a_field_of_this,
					 struct symtab **symtab);
d95 1
a95 2
					const domain_enum domain,
					struct symtab **symtab);
d101 1
a101 2
					  const domain_enum domain,
					  struct symtab **symtab);
d107 1
a107 2
					   const domain_enum domain,
					   struct symtab **symtab);
d1242 1
a1242 2
				 domain, lang,
				 is_a_field_of_this, symtab);
d1274 1
a1274 2
		   enum language language,
		   int *is_a_field_of_this, struct symtab **symtab)
d1290 1
a1290 2
  sym = lookup_symbol_aux_local (name, linkage_name, block, domain,
				 symtab);
a1329 2
	      if (symtab != NULL)
		*symtab = NULL;
d1338 1
a1338 2
  sym = langdef->la_lookup_symbol_nonlocal (name, linkage_name,
					     block, domain, symtab);
d1348 1
a1348 2
  sym = lookup_symbol_aux_symtabs (STATIC_BLOCK, name, linkage_name,
				   domain, symtab);
d1352 1
a1352 2
  sym = lookup_symbol_aux_psymtabs (STATIC_BLOCK, name, linkage_name,
				    domain, symtab);
a1355 2
  if (symtab != NULL)
    *symtab = NULL;
d1365 1
a1365 2
			 const domain_enum domain,
			 struct symtab **symtab)
d1377 1
a1377 2
      sym = lookup_symbol_aux_block (name, linkage_name, block, domain,
				     symtab);
d1414 1
a1414 2
			 const domain_enum domain,
			 struct symtab **symtab)
a1416 4
  struct objfile *objfile = NULL;
  struct blockvector *bv;
  struct block *b;
  struct symtab *s = NULL;
d1422 1
a1422 17
      if (symtab != NULL)
	{
	  /* Search the list of symtabs for one which contains the
	     address of the start of this block.  */
	  ALL_PRIMARY_SYMTABS (objfile, s)
	    {
	      bv = BLOCKVECTOR (s);
	      b = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
	      if (BLOCK_START (b) <= BLOCK_START (block)
		  && BLOCK_END (b) > BLOCK_START (block))
		goto found;
	    }
	found:
	  *symtab = s;
	}
      
      return fixup_symbol_section (sym, objfile);
d1435 1
a1435 2
				   const domain_enum domain,
				   struct symtab **symtab)
a1451 2
	if (symtab != NULL)
	  *symtab = s;
a1466 2
	if (symtab != NULL)
	  *symtab = s;
d1473 1
a1473 2
					      name, linkage_name, domain,
					      symtab);
d1486 1
a1486 2
			   const domain_enum domain,
			   struct symtab **symtab)
a1501 2
	if (symtab != NULL)
	  *symtab = s;
d1517 1
a1517 2
			    const domain_enum domain,
			    struct symtab **symtab)
a1558 2
	if (symtab != NULL)
	  *symtab = s;
d1574 1
a1574 2
			      const domain_enum domain,
			      struct symtab **symtab)
d1606 1
a1606 1
  sym = lookup_symbol_static (name, linkage_name, block, domain, symtab);
d1610 1
a1610 1
  return lookup_symbol_global (name, linkage_name, block, domain, symtab);
d1620 1
a1620 2
		      const domain_enum domain,
		      struct symtab **symtab)
d1625 1
a1625 2
    return lookup_symbol_aux_block (name, linkage_name, static_block,
				    domain, symtab);
d1637 1
a1637 2
		      const domain_enum domain,
		      struct symtab **symtab)
d1645 1
a1645 1
    sym = solib_global_lookup (objfile, name, linkage_name, domain, symtab);
d1649 1
a1649 2
  sym = lookup_symbol_aux_symtabs (GLOBAL_BLOCK, name, linkage_name,
				   domain, symtab);
d1653 1
a1653 2
  return lookup_symbol_aux_psymtabs (GLOBAL_BLOCK, name, linkage_name,
				     domain, symtab);
@


1.181
log
@	* ada-lang.c: Update throughout to use symbol_matches_domain
	instead of matching the symbol domain explictly.
	* dwarf2read.c (add_partial_symbol): Do not add new psym for
	STRUCT_DOMAIN. Make sure you recognize c++ struct and java and ada
	class as typedefs. See lookup_partial_symbol function.
	(new_symbol): Similar to add_partial_symbol, do not create
	symbol for the typedef. See lookup_block_symbol.
	* symtab.c (symbol_matches_domain): New function, takes care
	of dual meaning of STRUCT_DOMAIN symbol for c++, ada and java.
	(lookup_partial_symbol): Use symbol_matches_domain to see if the
	found psym domain matches the given domain.
	(lookup_block_symbol): Likewise.
@
text
@a112 2
static void fixup_section (struct general_symbol_info *, struct objfile *);

d879 17
d1028 2
a1029 1
fixup_section (struct general_symbol_info *ginfo, struct objfile *objfile)
a1031 1
  msym = lookup_minimal_symbol (ginfo->name, NULL, objfile);
d1038 2
a1039 2
  if (msym
      && SYMBOL_VALUE_ADDRESS (msym) == ginfo->value.address)
d1044 1
a1044 1
  else if (objfile)
a1081 1
      CORE_ADDR addr;
a1082 3

      addr = ginfo->value.address;

d1101 2
d1109 28
a1136 1
  fixup_section (&sym->ginfo, objfile);
d1144 2
d1152 17
a1168 1
  fixup_section (&psym->ginfo, objfile);
@


1.180
log
@	gdb/
	* Makefile.in: Update dependencies.
	* dwarf2read.c: Include "addrmap.h"
	(struct dwarf2_cu): New fields RANGES_OFFSET and HAS_RANGES_OFFSET.
	(dwarf2_ranges_read): New prototype.
	(dwarf2_build_psymtabs_hard): Initialize and prepare PSYMTABS_ADDRMAP.
	Add discontiguous range to PSYMTABS_ADDRMAP by DWARF2_RANGES_READ on
	HAS_RANGES_OFFSET, otherwise add there the contiguous range.
	(dwarf2_ranges_read): New parameter RANGES_PST, update the function
	comment for it.  Add the found ranges to RANGES_PST.  New variable
	BASEADDR, initialize it the common way.
	(dwarf2_get_pc_bounds): Update the caller for the new parameter.
	(read_partial_die): `DW_AT_ranges' now only sets RANGES_OFFSET and
	HAS_RANGES_OFFSET for the later processing.
	* objfiles.h (struct objfile): New field PSYMTABS_ADDRMAP.
	* symtab.c: Include "addrmap.h"
	(find_pc_sect_psymtab): Support reading the field PSYMTABS_ADDRMAP.
	Move the psymtab locator into ...
	(find_pc_sect_psymtab_closer): ... a new function.

	gdb/testsuite/
	* gdb.dwarf2/dw2-ranges.S: Merge the secondary section with `.fini'.
	* gdb.dwarf2/dw2-ranges.exp: Compile also `dw2-ranges2.S' and
	`dw2-ranges3.S' and test also their MAIN2, FUNC2 and MAIN3 symbols.
	* gdb.dwarf2/dw2-ranges2.S, gdb.dwarf2/dw2-ranges3.S: New files.
@
text
@d1653 20
d1737 3
a1739 4
	  if (SYMBOL_DOMAIN (*top) == domain)
	    {
		  return (*top);
	    }
d1751 2
a1752 1
	  if (domain == SYMBOL_DOMAIN (*psym))
d1937 2
a1938 1
	  if (SYMBOL_DOMAIN (sym) == domain
d1959 2
a1960 1
	  if (SYMBOL_DOMAIN (sym) == domain
@


1.179
log
@	* alpha-tdep.h (ALPHA_REGISTER_BYTES): Delete.
	* arm-tdep.h (STATUS_REGISTER_SIZE): Delete.
	* breakpoint.c (args_for_catchpoint_enable, current_exception_event):
	Delete.
	* c-typeprint.c (c_type_print_base): Delete handling of template
	instantiations.
	* cp-support.h (METHOD_PTR_IS_VIRTUAL, METHOD_PTR_FROM_VOFFSET)
	(METHOD_PTR_TO_VOFFSET): Delete.
	* defs.h (QUIT_FIXME): Delete.
	* f-lang.h (DEFAULT_DOTMAIN_NAME_IN_MF77, DEFAULT_MAIN_NAME_IN_MF77)
	(DEFAULT_DOTMAIN_NAME_IN_XLF_BUGGY, DEFAULT_DOTMAIN_NAME_IN_XLF): Delete.
	* gdbtypes.h (struct cplus_struct_type): Delete is_inlined,
	ninstantiations, and instantiations.
	(TYPE_INSTANTIATIONS, TYPE_NINSTANTIATIONS, TYPE_INSTANTIATION)
	(TYPE_FN_FIELD_INLINED): Delete.
	* srec.h (SREC_BINARY): Delete.
	* symtab.c (symbol_init_demangled_name): Delete.
	* symtab.h (SYMBOL_INIT_DEMANGLED_NAME, symbol_init_demangled_name)
	(SYMBOL_OBJFILE, struct exception_event_record, CURRENT_EXCEPTION_KIND)
	(CURRENT_EXCEPTION_CATCH_SAL, CURRENT_EXCEPTION_CATCH_LINE)
	(CURRENT_EXCEPTION_CATCH_FILE, CURRENT_EXCEPTION_CATCH_PC)
	(CURRENT_EXCEPTION_THROW_SAL, CURRENT_EXCEPTION_THROW_LINE)
	(CURRENT_EXCEPTION_THROW_FILE, CURRENT_EXCEPTION_THROW_PC): Delete.
	* target.h (enum thread_control_capabilities): Delete tc_switch.
	(target_can_switch_threads): Delete.
@
text
@d44 1
d771 77
a854 1
  struct partial_symtab *pst;
d870 5
a874 3
  ALL_PSYMTABS (objfile, pst)
  {
    if (pc >= pst->textlow && pc < pst->texthigh)
d876 4
a879 23
	struct partial_symtab *tpst;
	struct partial_symtab *best_pst = pst;
	CORE_ADDR best_addr = pst->textlow;

	/* An objfile that has its functions reordered might have
	   many partial symbol tables containing the PC, but
	   we want the partial symbol table that contains the
	   function containing the PC.  */
	if (!(objfile->flags & OBJF_REORDERED) &&
	    section == 0)	/* can't validate section this way */
	  return (pst);

	if (msymbol == NULL)
	  return (pst);

	/* The code range of partial symtabs sometimes overlap, so, in
	   the loop below, we need to check all partial symtabs and
	   find the one that fits better for the given PC address. We
	   select the partial symtab that contains a symbol whose
	   address is closest to the PC address.  By closest we mean
	   that find_pc_sect_symbol returns the symbol with address
	   that is closest and still less than the given PC.  */
	for (tpst = pst; tpst != NULL; tpst = tpst->next)
d881 5
a885 4
	    if (pc >= tpst->textlow && pc < tpst->texthigh)
	      {
		struct partial_symbol *p;
		CORE_ADDR this_addr;
d887 1
a887 35
		/* NOTE: This assumes that every psymbol has a
		   corresponding msymbol, which is not necessarily
		   true; the debug info might be much richer than the
		   object's symbol table.  */
		p = find_pc_sect_psymbol (tpst, pc, section);
		if (p != NULL
		    && SYMBOL_VALUE_ADDRESS (p)
		    == SYMBOL_VALUE_ADDRESS (msymbol))
		  return (tpst);

		/* Also accept the textlow value of a psymtab as a
		   "symbol", to provide some support for partial
		   symbol tables with line information but no debug
		   symbols (e.g. those produced by an assembler).  */
		if (p != NULL)
		  this_addr = SYMBOL_VALUE_ADDRESS (p);
		else
		  this_addr = tpst->textlow;

		/* Check whether it is closer than our current
		   BEST_ADDR.  Since this symbol address is
		   necessarily lower or equal to PC, the symbol closer
		   to PC is the symbol which address is the highest.
		   This way we return the psymtab which contains such
		   best match symbol. This can help in cases where the
		   symbol information/debuginfo is not complete, like
		   for instance on IRIX6 with gcc, where no debug info
		   is emitted for statics. (See also the nodebug.exp
		   testcase.) */
		if (this_addr > best_addr)
		  {
		    best_addr = this_addr;
		    best_pst = tpst;
		  }
	      }
a888 1
	return (best_pst);
d890 27
a916 2
  }
  return (NULL);
@


1.178
log
@	* linespec.c: Include "target.h".
	(minsym_found): Handle minimal symbols pointing to function
	descriptors.  Use find_function_start_pc.
	* minsyms.c (msymbol_objfile): New function.
	* parse.c (write_exp_msymbol): Handle minimal symbols pointing
	to function descriptors.
	* symtab.c (fixup_section): Only use minimal symbol at the same
	address to determine section of a symbol.
	(find_function_start_pc): New function.
	(find_function_start_sal): Use it.
	* symtab.h (msymbol_objfile): Add prototype.
	(find_function_start_pc): Likewise.
	* value.c: Include "objfiles.h".
	(value_fn_field): Handle minimal symbols pointing to function
	descriptors.
	* Makefile.in (linespec.o): Update dependencies.
	(value.o): Likewise.
@
text
@a629 34
/* Initialize the demangled name of GSYMBOL if possible.  Any required space
   to store the name is obtained from the specified obstack.  The function
   symbol_set_names, above, should be used instead where possible for more
   efficient memory usage.  */

void
symbol_init_demangled_name (struct general_symbol_info *gsymbol,
                            struct obstack *obstack)
{
  char *mangled = gsymbol->name;
  char *demangled = NULL;

  demangled = symbol_find_demangled_name (gsymbol, mangled);
  if (gsymbol->language == language_cplus
      || gsymbol->language == language_java
      || gsymbol->language == language_objc)
    {
      if (demangled)
	{
	  gsymbol->language_specific.cplus_specific.demangled_name
	    = obsavestring (demangled, strlen (demangled), obstack);
	  xfree (demangled);
	}
      else
	gsymbol->language_specific.cplus_specific.demangled_name = NULL;
    }
  else
    {
      /* Unknown language; just clean up quietly.  */
      if (demangled)
	xfree (demangled);
    }
}

@


1.177
log
@* symtab.c: (multiple_symbols_modes, multiple_symbols_ask)
(multiple_symbols_cancel): Remove extra const.
* symtab.h: Likewise.
@
text
@d1001 7
a1007 1
  if (msym)
d2539 20
d2567 4
d2574 2
a2575 2
  pc = BLOCK_START (SYMBOL_BLOCK_VALUE (sym));
  fixup_symbol_section (sym, NULL);
d2577 3
a2579 14
    {				/* skip "first line" of function (which is actually its prologue) */
      asection *section = SYMBOL_BFD_SECTION (sym);
      /* If function is in an unmapped overlay, use its unmapped LMA
         address, so that gdbarch_skip_prologue has something unique to work
         on */
      if (section_is_overlay (section) &&
	  !section_is_mapped (section))
	pc = overlay_unmapped_address (pc, section);

      pc += gdbarch_deprecated_function_start_offset (current_gdbarch);
      pc = gdbarch_skip_prologue (current_gdbarch, pc);

      /* For overlays, map pc back into its mapped VMA range */
      pc = overlay_mapped_address (pc, section);
d2586 2
a2587 2
      && BLOCK_START (SYMBOL_BLOCK_VALUE (sym)) <= sal.end
      && sal.end < BLOCK_END (SYMBOL_BLOCK_VALUE (sym)))
@


1.176
log
@	Fix breakpoint condition that use member variables.
        * valops.c (check_field): Remove.
        (check_field_in): Rename to check_field.
        (value_of_this): Use la_name_of_this.
        * value.h (check_field): Adjust prototype.

        * language.h (la_value_of_this): Rename to la_name_of_this.
        * language.c (unknown_language_defn): Specify "this" for
        name_of_this.
        (auto_language_defn): Likewise.
        (local_language_defn): Likewise.
        * ada-lang.c (ada_language_defn): Adjust comment.
        * c-lang.c (c_language_defn): Adjust comment.
        (cplus_language_defn): Specify "this" for name_of_this.
        (asm_language_defn): Adjust comment.
        (minimal_language_defn): Adjust comment.
        * f-lang.c (f_language_defn): Specify NULL for name_of_this.
        * jv-lang.c (java_language_defn): Specify "this" for name_of_this.
        * m2-lang.c (m2_language_defn): Specify "this" for name_of_this.
        * objc-lang.c (objc_language_defn): Specify "self" for
        name_of_this.
        * p-lang.c (pascal_language_defn): Specify "this" for
        name_of_this.
        * scm-lang.c (scm_language_defn): Specify NULL for name_of_this.

        * symtab.c (lookup_symbol_aux): Lookup "this" in the
        proper scope, and check for field in type of "this", without
        trying to create a value.
@
text
@d131 3
a133 3
const char const multiple_symbols_ask[] = "ask";
const char const multiple_symbols_all[] = "all";
const char const multiple_symbols_cancel[] = "cancel";
@


1.175
log
@        * symtab.c (multiple_symbols_ask, multiple_symbols_all)
        (multiple_symbols_cancel): New constants.
        (multiple_symbols_modes, multiple_symbols_mode): New static globals.
        (multiple_symbols_select_mode): New function.
        (_initialize_symtab): Add new set/show multiple-symbols commands.
        * symtab.h (multiple_symbols_ask, multiple_symbols_all)
        (multiple_symbols_cancel, multiple_symbols_select_mode): Declare.
        * ada-lang.c (user_select_syms): Add handling of new multiple-symbols
        setting.
        * linespec.c (decode_line_2): Likewise.
@
text
@d1225 2
a1226 2
  if (langdef->la_value_of_this != NULL
      && is_a_field_of_this != NULL)
d1228 32
a1259 8
      struct value *v = langdef->la_value_of_this (0);

      if (v && check_field (v, name))
	{
	  *is_a_field_of_this = 1;
	  if (symtab != NULL)
	    *symtab = NULL;
	  return NULL;
@


1.174
log
@2008-03-21  Chris Demetriou  <cgd@@google.com>

        * symtab.c (rbreak_command): Quote symbol name before passing
	it to break_command.

	* gdb.base/break.exp (rbreak junk): New test for rbreak
	"Junk at end of arguments" issue.
@
text
@d127 24
d4449 9
@


1.173
log
@        * language.h (struct language_defn): Add new field
        la_make_symbol_completion_list.
        * symtab.c (default_make_symbol_completion_list): Renames
        make_symbol_completion_list.
        (make_symbol_completion_list): New function.
        * symtab.h (default_make_symbol_completion_list): Add declaration.
        * langauge.c (unknown_language): Set la_make_symbol_completion_list.
        (auto_language, local_language): Likewise.
        * objc-lang.c (objc_language_defn): Likewise.
        * scm-lang.c (scm_language_defn): Likewise.
        * m2-lang.c (m2_language_defn): Likewise.
        * f-lang.c (f_language_defn): Likewise.
        * jv-lang.c (java_language_defn): Likewise.
        * p-lang.c (pascal_language_defn): Likewise.
        * c-lang.c (c_language_defn, cplus_language_defn, asm_language_defn)
        (minimal_language_defn): Likewise.
        * ada-lang.c (struct string_vector): New structure.
        (new_string_vector, string_vector_append, ada_unqualified_name)
        (add_angle_brackets, symbol_completion_match, symbol_completion_add)
        (ada_make_symbol_completion_list): New functions.
        (ada_language_defn): Set la_make_symbol_completion_list.
        * ada-lang.h (ada_make_symbol_completion_list): Remove declaration,
        this function is static.
@
text
@d3348 7
a3354 1
	  break_command (SYMBOL_LINKAGE_NAME (p->msymbol), from_tty);
@


1.172
log
@        * symtab.c (symbol_set_names): Do not add an entry in the demangling
        hash table for Ada symbols. Just store the linkage name as is,
        and leave the demangled_name as NULL.
@
text
@a3525 8

/* Return a NULL terminated array of all symbols (regardless of class)
   which begin by matching TEXT.  If the answer is no symbols, then
   the return value is an array which contains only a NULL pointer.

   Problem: All of the symbols have to be copied because readline frees them.
   I'm not going to worry about this; hopefully there won't be that many.  */

d3527 1
a3527 1
make_symbol_completion_list (char *text, char *word)
d3529 4
d3547 1
a3547 2
  /* Now look for the symbol we are supposed to complete on.
     FIXME: This should be language-specific.  */
d3715 10
@


1.171
log
@	* symtab.c (find_pc_sect_line): Use SYMBOL_VALUE_ADDRESS instead
	of SYMBOL_VALUE when working with function symbols.
@
text
@d520 18
@


1.170
log
@	Updated copyright notices for most files.
@
text
@d2112 1
a2112 1
	else if (SYMBOL_VALUE (mfunsym) == SYMBOL_VALUE (msymbol))
d2118 1
a2118 1
	  return find_pc_line (SYMBOL_VALUE (mfunsym), 0);
@


1.169
log
@	* remote.c (unpack_nibble): Use fromhex.
	* symtab.c (find_line_common): Always set exact_match.
@
text
@d4 1
a4 1
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2007
@


1.168
log
@	* minsyms.c (lookup_minimal_symbol): Also check the separate
	debug objfile.
	(lookup_minimal_symbol_text): Likewise.
	(lookup_minimal_symbol_solib_trampoline): Likewise.
	* symtab.c (lookup_global_symbol_from_objfile): Likewise.
@
text
@d2427 2
a2453 2

  *exact_match = 0;
@


1.167
log
@	* symtab.c (find_line_symtab): scan through psymtabs
	when exact_match is zero.
@
text
@d1366 5
@


1.166
log
@2007-10-09  Pierre Muller  <muller@@ics.u-strasbg.fr>

        * p-lang.h (pascal_main_name): Add declaration.
        * p-lang.c (GPC_P_INITIALIZE, GPC_MAIN_PROGRAM_NAME_1)
        (GPC_MAIN_PROGRAM_NAME_2): New constants.
        (pascal_main_name): New function.
        * symtab.c: Include p-lang.h.
        (find_main_name): Add call to pascal_main_name.
        * Makefile.in (symtab.o): Add dependency on p-lang.h.
@
text
@d2284 1
d2291 7
@


1.165
log
@	* breakpoint.c (remove_sal): New.
	(expand_line_sal_maybe): New.
	(create_breakpoints): Call expand_line_sal_maybe.
	(clear_command): Add comment.
	(breakpoint_re_set_one): Call expand_line_sal_maybe.
	* linespec.c (decode_indirect): Set explicit_pc to 1.
	(decode_all_digits): Set explicit_line to 1.
	(append_expanded_sal): New.
	(expand_line_sal): New.
	* linespec.h (expand_line_sal): Declare.
	* symtab.c (init_sal): Initialize explicit_pc
	and explicit_line.
	* symtab.h (struct symtab_and_line): New fields
	explicit_pc and explicit_line.
@
text
@d43 1
d4130 1
a4130 1
  char *new_main_name;
d4155 7
@


1.164
log
@        * symtab.c: Remove a function that has been commented out 3 years ago.
@
text
@d694 2
d4177 160
@


1.163
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@a110 9
#if 0
static
struct symbol *lookup_symbol_aux_minsyms (const char *name,
					  const char *linkage_name,
					  const domain_enum domain,
					  int *is_a_field_of_this,
					  struct symtab **symtab);
#endif

a1459 126
#if 0
/* Check for the possibility of the symbol being a function or a
   mangled variable that is stored in one of the minimal symbol
   tables.  Eventually, all global symbols might be resolved in this
   way.  */

/* NOTE: carlton/2002-12-05: At one point, this function was part of
   lookup_symbol_aux, and what are now 'return' statements within
   lookup_symbol_aux_minsyms returned from lookup_symbol_aux, even if
   sym was NULL.  As far as I can tell, this was basically accidental;
   it didn't happen every time that msymbol was non-NULL, but only if
   some additional conditions held as well, and it caused problems
   with HP-generated symbol tables.  */

/* NOTE: carlton/2003-05-14: This function was once used as part of
   lookup_symbol.  It is currently unnecessary for correctness
   reasons, however, and using it doesn't seem to be any faster than
   using lookup_symbol_aux_psymtabs, so I'm commenting it out.  */

static struct symbol *
lookup_symbol_aux_minsyms (const char *name,
			   const char *linkage_name,
			   const domain_enum domain,
			   int *is_a_field_of_this,
			   struct symtab **symtab)
{
  struct symbol *sym;
  struct blockvector *bv;
  const struct block *block;
  struct minimal_symbol *msymbol;
  struct symtab *s;

  if (domain == VAR_DOMAIN)
    {
      msymbol = lookup_minimal_symbol (name, NULL, NULL);

      if (msymbol != NULL)
	{
	  /* OK, we found a minimal symbol in spite of not finding any
	     symbol. There are various possible explanations for
	     this. One possibility is the symbol exists in code not
	     compiled -g. Another possibility is that the 'psymtab'
	     isn't doing its job.  A third possibility, related to #2,
	     is that we were confused by name-mangling. For instance,
	     maybe the psymtab isn't doing its job because it only
	     know about demangled names, but we were given a mangled
	     name...  */

	  /* We first use the address in the msymbol to try to locate
	     the appropriate symtab. Note that find_pc_sect_symtab()
	     has a side-effect of doing psymtab-to-symtab expansion,
	     for the found symtab.  */
	  s = find_pc_sect_symtab (SYMBOL_VALUE_ADDRESS (msymbol),
				   SYMBOL_BFD_SECTION (msymbol));
	  if (s != NULL)
	    {
	      /* This is a function which has a symtab for its address.  */
	      bv = BLOCKVECTOR (s);
	      block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);

	      /* This call used to pass `SYMBOL_LINKAGE_NAME (msymbol)' as the
	         `name' argument to lookup_block_symbol.  But the name
	         of a minimal symbol is always mangled, so that seems
	         to be clearly the wrong thing to pass as the
	         unmangled name.  */
	      sym =
		lookup_block_symbol (block, name, linkage_name, domain);
	      /* We kept static functions in minimal symbol table as well as
	         in static scope. We want to find them in the symbol table. */
	      if (!sym)
		{
		  block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
		  sym = lookup_block_symbol (block, name,
					     linkage_name, domain);
		}

	      /* NOTE: carlton/2002-12-04: The following comment was
		 taken from a time when two versions of this function
		 were part of the body of lookup_symbol_aux: this
		 comment was taken from the version of the function
		 that was #ifdef HPUXHPPA, and the comment was right
		 before the 'return NULL' part of lookup_symbol_aux.
		 (Hence the "Fall through and return 0" comment.)
		 Elena did some digging into the situation for
		 Fortran, and she reports:

		 "I asked around (thanks to Jeff Knaggs), and I think
		 the story for Fortran goes like this:

		 "Apparently, in older Fortrans, '_' was not part of
		 the user namespace.  g77 attached a final '_' to
		 procedure names as the exported symbols for linkage
		 (foo_) , but the symbols went in the debug info just
		 like 'foo'. The rationale behind this is not
		 completely clear, and maybe it was done to other
		 symbols as well, not just procedures."  */

	      /* If we get here with sym == 0, the symbol was 
	         found in the minimal symbol table
	         but not in the symtab.
	         Fall through and return 0 to use the msymbol 
	         definition of "foo_".
	         (Note that outer code generally follows up a call
	         to this routine with a call to lookup_minimal_symbol(),
	         so a 0 return means we'll just flow into that other routine).

	         This happens for Fortran  "foo_" symbols,
	         which are "foo" in the symtab.

	         This can also happen if "asm" is used to make a
	         regular symbol but not a debugging symbol, e.g.
	         asm(".globl _main");
	         asm("_main:");
	       */

	      if (symtab != NULL && sym != NULL)
		*symtab = s;
	      return fixup_symbol_section (sym, s->objfile);
	    }
	}
    }

  return NULL;
}
#endif /* 0 */

@


1.162
log
@2007-07-03  Markus Deuling  <deuling@@de.ibm.com>

	* cp-namespace.c (lookup_symbol_file): Add block to
	lookup_symbol_global call.
	* Makefile.in (solist_h): Add dependency on symtab header.
	(symtab.o): Add dependency on solist header.
	* solib.c (solib_global_lookup): New function.
	* solib-svr4.c (scan_dyntag): Likewise.
	(elf_locate_base): Call helper routine scan_dyntag.
	(elf_lookup_lib_symbol): New function.
	(_initialize_svr4_solib): Add elf_lookup_lib_symbol to svr4_so_ops.
	* solist.h (symtab.h): New include.
	(struct target_so_ops): New member lookup_lib_global_symbol.
	(solib_global_lookup): New prototype.
	* symtab.c: New include solist.h.
	(lookup_objfile_from_block): New function.
	(lookup_global_symbol_from_objfile): New function.
	(basic_lookup_symbol_nonlocal): Add block to lookup_symbol_global call.
	(lookup_symbol_global): Call library-specific lookup procedure.
	* symtab.h (lookup_global_symbol_from_objfile): New prototype.

	* NEWS: Document framework.

testsuite/

	* gdb.base/solib-symbol.exp: New file (testcase multiple symbol lookup).
	* gdb.base/solib-symbol-lib.c: Likewise.
	* gdb.base/solib-symbol-main.c: Likewise.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d20 1
a20 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.161
log
@2007-06-18  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (DEPRECATED_FUNCTION_START_OFFSET): Replace by
	gdbarch_deprecated_function_start_offset.
	* symtab.c (find_function_start_sal)skip_prologue_using_sal): Likewise.
	* linespec.c (minsym_found): Likewise.
	* infrun.c (handle_inferior_event): Likewise.
	* infcall.c (find_function_addr): Likewise.
	* cli/cli-cmds.c (disassemble_command): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d60 1
d1265 20
d1326 51
d1642 1
a1642 1
  return lookup_symbol_global (name, linkage_name, domain, symtab);
d1670 1
d1674 9
a1682 1
  struct symbol *sym;
@


1.160
log
@2007-06-13  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_ADDR_BIT): Replace by gdbarch_addr_bit.
	* valops.c (value_cast): Likewise.
	* utils.c (strlen_paddr, paddr, paddr_nz, paddress): Likewise.
	* ui-out.c (ui_out_field_core_addr): Likewise.
	* tracepoint.c (tracepoints_info): Likewise.
	* symtab.c (print_msymbol_info): Likewise.
	* solib-irix.c (irix_current_sos)
	(irix_open_symbol_file_object): Likewise.
	* remote.c (build_remote_gdbarch_data): Likewise.
	* prologue-value.c (make_pv_area): Likewise.
	* procfs.c (info_mappings_callback): Likewise.
	* printcmd.c (print_scalar_formatted)
	(deprecated_print_address_numeric): Likewise.
	* memattr.c (mem_info_command): Likewise.
	* linux-nat.c (linux_nat_info_proc_cmd): Likewise.
	* gdbtypes.c (build_flt, gdbtypes_post_init): Likewise.
	* exec.c (print_section_info): Likewise.
	* dwarf2read.c (read_subrange_type): Likewise.
	* dwarf2loc.c (find_location_expression): Likewise.
	* dwarf2expr.c (dwarf2_read_address, unsigned_address_type)
	(signed_address_type, execute_stack_op): Likewise.
	* breakpoint.c (print_one_breakpoint, breakpoint_1): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d2530 1
a2530 1
      pc += DEPRECATED_FUNCTION_START_OFFSET;
d4104 1
a4104 1
  start_pc += DEPRECATED_FUNCTION_START_OFFSET;
@


1.159
log
@2007-06-09  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (SKIP_PROLOGUE): Replace by gdbarch_skip_prologue.
	* symtab.c (find_function_start_sal, in_prologue): Likewise.
	* linespec.c (minsym_found): Likewise.
	* infrun.c (step_into_function): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d3249 1
a3249 1
  if (TARGET_ADDR_BIT <= 32)
@


1.158
log
@	* hppa-hpux-tdep.c (args_for_find_stub, HP_ACC_EH_notify_hook,
	HP_ACC_EH_set_hook_value, HP_ACC_EH_notify_callback, HP_ACC_EH_break,
	HP_ACC_EH_catch_throw, HP_ACC_EH_catch_catch, __eh_notification,
	hp_cxx_exception_support, hp_cxx_exception_support_initialized,
	eh_notify_hook_addr, eh_notify_callback_addr, eh_break_addr,
	eh_catch_throw_addr, break_callback_sal, setup_d_pid_in_inferior,
	find_stub_with_shl_get, cover_find_stub_with_shl_get,
	initialize_hp_cxx_exception_support, child_enable_exception_callback,
	current_ex_event, child_get_current_exception_event): Remove.
	(hppa_hpux_inferior_created): Remove.
	(hppa_hpux_init_abi): Do not install hppa_hpux_inferior_created.

	* breakpoint.h (deprecated_exception_catchpoints_are_fragile): Remove.
	(deprecated_exception_support_initialized): Remove.
	* breakpoint.c (deprecated_exception_catchpoints_are_fragile): Remove.
	(deprecated_exception_support_initialized): Remove.
	(breakpoint_init_inferior): Remove handling of non-zero
	deprecated_exception_catchpoints_are_fragile.

	* symtab.h (deprecated_hp_som_som_object_present): Remove.
	* symtab.c (deprecated_hp_som_som_object_present): Remove.
	* c-typeprint.c (c_type_print_base): Remove handling of non-zero
	deprecated_hp_som_som_object_present.
	* eval.c (evaluate_subexp_standard): Likewise.
	* valops.c (value_cast): Likewise.

	* parse.c (parse_nested_classes_for_hpacc, coloncolon): Remove.
	* parser-defs.h (parse_nested_classes_for_hpacc): Remove.
	* c-exp.y (yylex): Do not call parse_nested_classes_for_hpacc.
@
text
@d2524 2
a2525 1
         address, so that SKIP_PROLOGUE has something unique to work on */
d2531 1
a2531 1
      pc = SKIP_PROLOGUE (pc);
d2538 1
a2538 1
  /* Check if SKIP_PROLOGUE left us in mid-line, and the next
d4026 1
a4026 1
       architecture-defined SKIP_PROLOGUE function to analyze the
d4044 1
a4044 1
      prologue_end = SKIP_PROLOGUE (func_start);
d4068 2
a4069 1
      CORE_ADDR prologue_end = SKIP_PROLOGUE (func_addr);
@


1.157
log
@	* symtab.c (skip_prologue_using_sal): Allow the end of the prologue
	sal to be bigger than the end of the function.
@
text
@a120 4
/* This flag is used in hppa-tdep.c, and set in hp-symtab-read.c.
   Signals the presence of objects compiled by HP compilers.  */
int deprecated_hp_som_som_object_present = 0;

@


1.156
log
@	* linespec.c: Include language.h.
	(find_methods): Add language parameter.  Call
	lookup_symbol_in_language.  Pass language down.
	(add_matching_methods): Likewise.  Call
	lookup_symbol_in_language.
	(add_constructors): Likewise.
	(find_method): Pass sym_class to collect_methods.
	(collect_methods): Add sym_class parameter.  Pass language
	down.
	* symtab.c (lookup_symbol): Rename to ...
	(lookup_symbol_in_language): ... this.  Add language
	parameter.  Use passed language instead of current_language.
	(lookup_symbol): New as wrapper around
	lookup_symbol_in_language.
	(lookup_symbol_aux): Add language parameter.  Use passed
	language instead of current_language.
	(search_symbols): Indent.
	* symtab.h (enum language): Forward declare.
	(lookup_symbol_in_language): Declare.
	(lookup_symbol): Update description.
	* ada-lang.h (lookup_symbol_in_language): Remove declaration.
	* ada-lang.c (restore_language): Remove.
	(lookup_symbol_in_language): Remove.
@
text
@d4114 1
a4114 1
      if (prologue_sal.end == end_pc)
@


1.155
log
@	* rs6000-tdep.c (rs6000_skip_prologue): Use skip_prologue_using_sal.
	(rs6000_in_function_epilogue_p): Use extract_unsigned_integer.
	(refine_prologue_limit): Delete.
	(skip_prologue): Don't call it.  Use extract_unsigned_integer.
	Assume lim_pc is set.  Correct check for incomplete prologues.
	Do not skip clobbers of the frame pointer.
	* symtab.c (skip_prologue_using_sal): Fail if there is only one
	sal.

	* gdb.arch/powerpc-prologue.c (optimized_1_marker, gdb2029_marker)
	(optimized_1): New.
	(main): Call optimized_1.
	(gdb2029): Correct typos.  Call gdb2029_marker.
	* gdb.arch/powerpc-prologue.exp: Run new test.  Use a breakpoint
	for gdb2029.
@
text
@d87 1
d1083 4
a1086 3
lookup_symbol (const char *name, const struct block *block,
	       const domain_enum domain, int *is_a_field_of_this,
	       struct symtab **symtab)
d1098 1
a1098 1
  if (current_language->la_language == language_cplus)
d1108 1
a1108 1
  else if (current_language->la_language == language_java)
d1134 2
a1135 1
				 domain, is_a_field_of_this, symtab);
d1146 14
a1159 1
/* Behave like lookup_symbol_aux except that NAME is the natural name
d1167 1
d1171 1
d1189 4
a1192 2
  /* If requested to do so by the caller and if appropriate for the
     current language, check to see if NAME is a field of `this'. */
d1194 1
a1194 1
  if (current_language->la_value_of_this != NULL
d1197 1
a1197 1
      struct value *v = current_language->la_value_of_this (0);
d1208 1
a1208 1
  /* Now do whatever is appropriate for the current language to look
d1211 2
a1212 3
  sym = current_language->la_lookup_symbol_nonlocal (name, linkage_name,
						     block, domain,
						     symtab);
d3092 2
a3093 1
					0, (struct symtab **) NULL) == NULL)
@


1.154
log
@	* objfiles.h (ALL_PRIMARY_SYMTABS): Define.

	* ada-lang.c (symtab_for_sym, ada_lookup_symbol_list)
	(ada_lookup_symbol): Use ALL_PRIMARY_SYMTABS.
	* cp-support.c (make_symbol_overload_list_qualified): Likewise.
	* symtab.c (lookup_symbol_aux_block, lookup_symbol_aux_symtabs)
	(basic_lookup_transparent_type, find_pc_sect_symtab, search_symbols)
	(make_symbol_completion_list): Likewise.
@
text
@d4095 1
a4095 1
	return start_pc;
@


1.153
log
@2007-01-21  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* buildsym.c (end_symtab): Use preallocated symtab if available.
	Fill in SYMBOL_SYMTAB.
	* buildsym.h (struct subfile): Add symtab member.
	* dwarf2read.c (struct dwarf2_cu): Add line_header.
	(struct file_entry): Add symtab.
	(free_cu_line_header): New function.
	(read_file_scope): Use it.  Save line_header in the cu.  Process
	lines before DIEs.
	(add_file_name): Initialize new symtab member.
	(dwarf_decode_lines): Create symtabs for included files.
	(new_symbol): Set SYMBOL_SYMTAB.
	* symtab.c (lookup_symbol): Use SYMBOL_SYMTAB.
	(search_symbols): Likewise.
	* symtab.h (struct symbol): Add symtab member.
	(SYMBOL_SYMTAB): Define.

	* gdb.base/included.c, gdb.base/included.exp,
	gdb.base/included.h: New files.
@
text
@d1272 1
a1272 1
	  ALL_SYMTABS (objfile, s)
d1307 1
a1307 1
  ALL_SYMTABS (objfile, s)
d1722 1
a1722 1
  ALL_SYMTABS (objfile, s)
d1770 1
a1770 1
  ALL_SYMTABS (objfile, s)
d1947 1
a1947 1
  ALL_SYMTABS (objfile, s)
a2899 1
  struct blockvector *prev_bv = 0;
d3081 1
a3081 1
  ALL_SYMTABS (objfile, s)
a3083 6
    /* Often many files share a blockvector.
       Scan each blockvector only once so that
       we don't get every symbol many times.
       It happens that the first symtab in the list
       for any given blockvector is the main file.  */
    if (bv != prev_bv)
a3134 1
    prev_bv = bv;
d3699 1
a3699 1
  ALL_SYMTABS (objfile, s)
d3709 1
a3709 1
  ALL_SYMTABS (objfile, s)
@


1.152
log
@2007-01-09  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* symtab.c (matching_bfd_sections): Fix VMA matching for
	prelinked objects.

	* gdb.base/relativedebug.c, gdb.base/relativedebug.exp: New files.
@
text
@d1136 4
d3015 5
a3019 1
	       load the file and go on to the next one */
d3098 1
d3100 2
a3101 1
	      if (file_matches (s->filename, files, nfiles)
d3114 1
a3114 1
		  psr->symtab = s;
@


1.151
log
@Copyright updates for 2007.
@
text
@d742 1
d744 3
a746 1
      != bfd_get_section_vma (second->owner, second))
@


1.150
log
@	* symtab.c (find_pc_sect_psymtab): Add comments.  Handle psymtabs
	with no symbols.
@
text
@d3 2
a4 2
   Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
@


1.149
log
@	* symtab.c (find_pc_sect_line): Do not return a line before
	the start of a symtab.
@
text
@d798 1
a798 1
	struct partial_symbol *best_psym = NULL;
d823 1
d825 4
d834 5
d840 15
d856 2
a857 20
		    /* We found a symbol in this partial symtab which
		       matches (or is closest to) PC, check whether it
		       is closer than our current BEST_PSYM.  Since
		       this symbol address is necessarily lower or
		       equal to PC, the symbol closer to PC is the
		       symbol which address is the highest.  */
		    /* This way we return the psymtab which contains
		       such best match symbol. This can help in cases
		       where the symbol information/debuginfo is not
		       complete, like for instance on IRIX6 with gcc,
		       where no debug info is emitted for
		       statics. (See also the nodebug.exp
		       testcase.)  */
		    if (best_psym == NULL
			|| SYMBOL_VALUE_ADDRESS (p)
			> SYMBOL_VALUE_ADDRESS (best_psym))
		      {
			best_psym = p;
			best_pst = tpst;
		      }
a858 1

@


1.148
log
@gdb/
	* Makefile.in (symtab.o): Update.
	* symtab.h (matching_bfd_section): New prototype.
	* symtab.c (matching_bfd_section): New.
	(find_pc_sect_psymbol, find_pc_sect_symtab): Use it.
	* minsyms.c (lookup_minimal_symbol_by_pc_section): Likewise.
	* printcmd.c (sym_info): Ignore separate debug objfiles.
gdb/testsuite/
	* gdb.base/sepdebug.exp: Remove debug format test.
	* lib/gdb.exp (gdb_gnu_strip_debug): Perform debug format test.
	Handle no-symtab.
	* gdb.base/sepsymtab.c, gdb.base/sepsymtab.exp: New.
@
text
@d2225 5
a2229 17
      if (!alt_symtab)
	{			/* If we didn't find any line # info, just
				   return zeros.  */
	  val.pc = pc;
	}
      else
	{
	  val.symtab = alt_symtab;
	  val.line = alt->line - 1;

	  /* Don't return line 0, that means that we didn't find the line.  */
	  if (val.line == 0)
	    ++val.line;

	  val.pc = BLOCK_END (BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK));
	  val.end = alt->pc;
	}
@


1.147
log
@Reviewed and approved by Jim Blandy <jimb@@codesourcery.com>

	2006-05-11  Fred Fish  <fnf@@specifix.com>
	* symtab.c (skip_prologue_using_sal): Handle single line functions
	like "foo(){}", which may optimize down to a single return inst.
@
text
@d59 1
d710 58
d907 1
a907 1
	      if (SYMBOL_BFD_SECTION (p) != section)
d931 1
a931 1
	      if (SYMBOL_BFD_SECTION (p) != section)
d1964 1
a1964 1
		if (section == SYMBOL_BFD_SECTION (sym))
@


1.146
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d4033 5
@


1.146.8.1
log
@        gdb/
        * buildsym.c, symtab.c: Add local hack for FILENAME_CMP testing.
        * utils.c (cygwin_filename_cmp): New.

        Backport:
        2006-04-21  Frederic Riss  <frederic.riss@@st.com>
        * dwarf2read.c (dwarf2_start_subfile): Change prototype to accept
        compilation directory as last argument.
        Always pass comp_dir as second argument to start_subfile and prepend
        dirname to the filename when necessary.
        Remove now superfluous search for pre-existing subfile.
        (dwarf_decode_lines): Pass the compilation directory to
        dwarf2_start_subfile.

        gdb/testsuite/
        * config/symbian.exp (gdb_target_symbian): Handle a running target.
        (gdb_load): Add return value.

        * gdb.base/completion.exp: Test arg rather than a.  Handle
        very small lists of symbols.

        * gdb.base/list.exp: Differentiate run behavior based on
        use_gdb_stub.

        * gdb.base/maint.exp: Accept local symbols.  Accept missing .data.

        * gdb.base/remote.exp: Update packet limits.

        * gdb.base/varargs.exp: Don't pass an empty list item.

        * lib/gdb.exp (fullname_syntax): Recognize forward slashes in DOS
        paths.

        Backport:
        2006-06-22  Daniel Jacobowitz  <dan@@codesourcery.com>
        * gdb.base/gdb1555.exp: Use gdb_compile_shlib.  Skip if not
        native.

        2006-06-22  Daniel Jacobowitz  <dan@@codesourcery.com>
        * gdb.stabs/exclfwd.exp: Skip the test if configure did not
        enable stabs testing.

        2006-05-06  Ulrich Weigand  <Ulrich.Weigand@@de.ibm.com>
        * gdb.mi/mi-basics.exp: Add missing serial number to
        expected output in some mi_gdb_test statements.
        * gdb.mi/mi2-basics.exp: Likewise.
@
text
@a59 7
#ifdef __CYGWIN__
/* LOCAL: Hack for testing using a Windows compiler and a Cygwin GDB.  */
int cygwin_filename_cmp (const char *lhs, const char *rhs);
#undef FILENAME_CMP
#define FILENAME_CMP cygwin_filename_cmp
#endif

@


1.146.2.1
log
@2006-05-03  Paul Brook  <paul@@codesourcery.com>
	Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdb/c-valprint.c: Handle class member typedefs.

	* gdb/symtab.c (skip_prologue_using_sal): Treat two consecutive lines
	at the same address as a prolouge marker.
	* gdb/arm-tdep.c (arm_skip_prologue): Use skip_prologue_using_sal.

	* gdb/dwarf2expr.c (execute_stack_op): Check for bogus DW_OP_reg.

	* gdb/dwarf2read.c (read_structure_type): Use tag name for C++/Java
	classes.

	* Makefile.in (eval.o): Update dependencies.
	* eval.c: Include "ui-out.h" and "exceptions.h".
	(evaluate_subexp_standard): Use TRY_CATCH around value_of_variable.
	Use value_zero if an error occurs when avoiding side effects.
	* varobj.c (varobj_create): Call release_value after evaluate_type.
	(c_value_of_root): Initialize new_val.  Don't release_value a NULL
	value.

	* gdb/c-typeprint.c (cp_type_print_method_args): Don't print type
	details.

	* gdb/dwarf2read.c (dwarf2_debug_line_missing_file_complaint): New
	function.
	(dwarf_decode_lines): Check for line info without a file.
@
text
@a4032 23
      /* For langauges other than assembly, treat two consecutive line
	 entries at the same address as a zero-instruction prologue.
	 The GNU assembler emits separate line notes for each instruction
	 in a multi-instruction macro, but compilers generally will not
	 do this.  */
      if (prologue_sal.symtab->language != language_asm)
	{
	  struct linetable *linetable = LINETABLE (prologue_sal.symtab);
	  int exact;
	  int idx = 0;

	  /* Skip any earlier lines, and any end-of-sequence marker
	     from a previous function.  */
	  while (linetable->item[idx].pc != prologue_sal.pc
		 || linetable->item[idx].line == 0)
	    idx++;

	  if (idx+1 < linetable->nitems
	      && linetable->item[idx+1].line != 0
	      && linetable->item[idx+1].pc == start_pc)
	    return start_pc;
	}

d4054 1
a4054 8

  if (prologue_sal.end < end_pc)
    /* Return the end of this line, or zero if we could not find a
       line.  */
    return prologue_sal.end;
  else
    /* Don't return END_PC, which is past the end of the function.  */
    return prologue_sal.pc;
@


1.145
log
@        * doc/observer.texi (executable_changed): New observer.
        * symtab.c: Include "observer.h".
        (find_main_name): New function.
        (main_name): If name_of_main is unset, then compute it
        using find_main_name.
        (symtab_observer_executable_changed): New function.
        (_initialize_symtab): Attach executable_changed observer.
        * exec.c: Include "observer.h".
        (exec_file_attach): Emit executable_changed notification.
        * symfile.c: Include "observer.h".
        (reread_symbols): Send an executable_changed if appropriate.
        * Makefile.in (exec.o): Add dependency on observer.h.
        (symfile.o): Likewise.
        (symtab.o): Likewise.
@
text
@d3 1
a3 1
   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,
d21 2
a22 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.144
log
@2005-02-15  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_com, add_info and add_prefix_cmd.
	* breakpoint.c, cp-support.c, dcache.c, dwarf2read.c: Update.
	* exec.c, f-valprint.c, frame.c, gcore.c, gnu-nat.c: Update.
	* go32-nat.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* kod.c, language.c, linux-nat.c, m32r-rom.c, macrocmd.c: Update.
	* maint.c, memattr.c, mips-tdep.c, nto-procfs.c, objc-lang.c: Update.
	* ocd.c, pa64solib.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote-e7000.c, remote-m32r-sdi.c, remote-mips.c: Update.
	* remote-sds.c, remote-sim.c, remote-st.c, remote-utils.c: Update.
	* remote.c, rs6000-tdep.c, ser-go32.c, serial.c: Update.
	* sh-tdep.c, solib.c, somsolib.c, source.c, stack.c: Update.
	* symfile.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, typeprint.c, utils.c, valprint.c: Update.
	* win32-nat.c, xcoffsolib.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-layout.c, tui/tui-regs.c: Update.
	* tui/tui-stack.c, tui/tui-win.c: Update.
@
text
@d58 1
d4096 36
d4135 4
a4138 4
  if (name_of_main != NULL)
    return name_of_main;
  else
    return "main";
d4141 8
d4191 2
@


1.143
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d4108 2
a4109 2
  add_info ("variables", variables_info,
	 "All global and static variable names, or those matching REGEXP.");
d4111 2
a4112 2
    add_com ("whereis", class_info, variables_info,
	 "All global and static variable names, or those matching REGEXP.");
d4115 1
a4115 1
	    "All function names, or those matching REGEXP.");
d4127 1
a4127 1
	    "All type names, or those matching REGEXP.");
d4130 1
a4130 1
	    "Source files in the program.");
d4133 1
a4133 1
	   "Set a breakpoint for all functions matching REGEXP.");
d4137 4
a4140 3
      add_com ("lf", class_info, sources_info, "Source files in the program");
      add_com ("lg", class_info, variables_info,
	 "All global and static variable names, or those matching REGEXP.");
@


1.142
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d1565 1
a1565 1
	    internal_error (__FILE__, __LINE__, "failed internal consistency check");
d1581 1
a1581 1
	internal_error (__FILE__, __LINE__, "failed internal consistency check");
@


1.141
log
@        * symtab.c (symbol_search_name): Minor reformatting.
@
text
@d224 1
a224 1
    error ("Internal: readin %s pst for `%s' found when no symtab found.",
d1298 1
a1298 1
	      error ("Internal: %s symbol `%s' found in %s psymtab but not in symtab.\n%s may be an inlined function, or may be a template function\n(if a template, try specifying an instantiation: %s<type>).",
d1679 1
a1679 1
	      error ("Internal: global symbol `%s' found in %s psymtab but not in symtab.\n\
d1681 1
a1681 1
(if a template, try specifying an instantiation: %s<type>).",
d1726 1
a1726 1
	      error ("Internal: static symbol `%s' found in %s psymtab but not in symtab.\n\
d1728 1
a1728 1
(if a template, try specifying an instantiation: %s<type>).",
d1926 2
a1927 2
	warning ("\
(Internal error: pc 0x%s in read in psymtab, but not in symtab.)\n",
d2524 1
a2524 1
	      error ("mismatched quoting on brackets, try 'operator\\[\\]'");
d2531 1
a2531 1
	      error ("nothing is allowed between '[' and ']'");
d2587 1
a2587 1
	  error ("`operator ()' must be specified without whitespace in `()'");
d2592 1
a2592 1
	  error ("`operator ?:' must be specified without whitespace in `?:'");
d2597 1
a2597 1
	  error ("`operator []' must be specified without whitespace in `[]'");
d2601 1
a2601 1
	error ("`operator %s' not supported", p);
d2699 1
a2699 1
      error ("No symbol table is loaded.  Use the \"file\" command.");
d2871 1
a2871 1
    error ("must search on specific domain");
d2914 1
a2914 1
	error ("Invalid regexp (%s): %s", val, regexp);
d4063 1
a4063 1
    error ("Empty line specification.");
d4074 1
a4074 1
    error ("Junk at end of line specification: %s", string);
@


1.140
log
@Turn on initial Ada support (mainly expression evaluation).

* Makefile.in (SFILES): Remove ada-tasks.c.
(HFILES_NO_SRCDIR): Add ada-lang.h.
(COMMON_OBS): Add ada-lang.o, ada-typeprint.o, ada-valprint.o.
(YYOBJ): Add ada-exp.o.
(rule .l.c): Generalize to not mention ada.
* symtab.c: Include ada-lang.h.
(symbol_natural_name, symbol_demangled_name)
(symbol_search_name): Add Ada case.
@
text
@d687 3
a689 1
char *symbol_search_name (const struct general_symbol_info *gsymbol) {
@


1.139
log
@
2004-09-20  Jeff Johnston  <jjohnstn@@redhat.com>

        * dwarf2read.c (typename_concat): Change prototype to accept obstack
        and dwarf2_cu struct pointer as arguments.  Change function to use
        obstack if provided and use dwarf2_cu to determine language-specific
        separator.
        (partial_die_parent_scope): Change comment to include java.  Use
        new version of typename_concat instead of obconcat.
        (partial_die_full_name): Use typename_concat.
        (read_namespace): Ditto.
        (read_enumeration_type): Use typename_concat instead of obconcat.
        (new_symbol): Ditto.
        (add_partial_symbol): Enhance tests for C++ to also test for Java.
        (guess_structure_name): Ditto.
        (read_subroutine_type): Ditto.
        (read_structure_type): Ditto.
        (is_vtable_name): Add Java support.
        (determine_class_name): Switch to new typename_concat call.
        (determine_prefix): Switch to new typename_concat call.
        * jv-exp.y (FuncStart): New pattern.
        (MethodInvocation): Add support for simple function calls.  Change
        warning message for other forms of inferior call currently not
        supported.
        * valarith.c (value_subscript): Treat an array with upper-bound
        of -1 as unknown size.
@
text
@d44 1
d638 1
a638 4
  if ((gsymbol->language == language_cplus
       || gsymbol->language == language_java
       || gsymbol->language == language_objc)
      && (gsymbol->language_specific.cplus_specific.demangled_name != NULL))
d640 14
a653 5
      return gsymbol->language_specific.cplus_specific.demangled_name;
    }
  else
    {
      return gsymbol->name;
d655 1
d663 18
a680 7
  if (gsymbol->language == language_cplus
      || gsymbol->language == language_java
      || gsymbol->language == language_objc)
    return gsymbol->language_specific.cplus_specific.demangled_name;

  else 
    return NULL;
d688 4
a691 1
  return symbol_natural_name (gsymbol);
@


1.138
log
@	* symtab.c (lookup_partial_symtab): Use psymtab_to_fullname.
	(lookup_partial_symtab): Use symtab_to_fullname.
@
text
@d1001 1
a1001 1
  /* If we are using C++ language, demangle the name before doing a lookup, so
d1013 11
@


1.137
log
@	* symtab.c (output_source_filename): Mark first argument as const.
	(sources_info): Use symtab_to_fullname and psymtab_to_fullname
	for "info sources" output.
@
text
@d275 1
a275 2
	if (pst->fullname == NULL)
	  source_full_path_of (pst->filename, &pst->fullname);
d286 1
a286 2
	if (pst->fullname == NULL)
	  source_full_path_of (pst->filename, &pst->fullname);
@


1.136
log
@* language.c (local_hex_format_custom): Remove.
(local_hex_string): Rename to hex_string, use C format, and move to
utils.c
(local_hex_string_custom): Rename to hex_string_custom and change
interface.  Now uses C format.  Move to utils.c
(local_octal_format_custom): Remove.
(local_decimal_format_custom): Remove.
(unknown_language_defn): Remove language-specific number
formatting entries.
(auto_language_defn): Ditto.
(local_language_defn): Ditto.
* language.h (struct language_format_info): Delete declaration.
(struct language_defn): Remove language_format_info fields
la_binary_format, la_octal_format, la_decimal_format, la_hex_format.
(local_binary_format): Remove macro.
(local_binary_format_prefix): Remove macro.
(local_binary_format_specifier): Remove macro.
(local_binary_format_suffix): Remove macro.
(local_octal_format): Remove macro.
(local_octal_format_prefix): Remove macro.
(local_octal_format_specifier): Remove macro.
(local_octal_format_suffix): Remove macro.
(local_decimal_format): Remove macro.
(local_decimal_format_prefix): Remove macro.
(local_decimal_format_specifier): Remove macro.
(local_decimal_format_suffix): Remove macro.
(local_hex_format): Remove macro.
(local_hex_format_prefix): Remove macro.
(local_hex_format_specifier): Remove macro.
(local_hex_format_suffix): Remove macro.
(local_decimal_format_custom): Remove.
(local_octal_format_custom): Remove.
(local_hex_format_custom): Remove.
(local_hex_string): Rename to hex_string and move to defs.h.
(local_hex_string_custom): Rename to hex_string_custom, change
interface, and move to defs.h.
* utils.c: (int_string): New function.
(hex_string): New function (from language.c).
(hex_string_custom): New function (from language.c).
(octal2str): New function.
(decimal2str): Add width parameter.
(paddr_u): Use new decimal2str interface.
(paddr_d): Ditto.
* defs.h (hex_string): Declare.
(hex_string_custom): Declare.
(int_string): Declare.
* printcmd.c (print_scalar_formatted): Remove localized binary
formatting.
* valprint.c (print_longest): Use int_string.
(print_floating): Use C hex format.
(print_hex_chars): Ditto.
(print_binary_chars): Remove language-specific formatting.
(print_octal_chars): Use C octal format.
(print_decimal_chars): Delocalize format.
(print_decimal): Remove.
* ada-lang.c (ada_language_defn): Remove language-specific number
formatting entries.
* p-lang.c (pascal_language_defn): Ditto.
* c-lang.c (c_language_defn): Ditto.
(cplus_language_defn): Ditto.
(asm_language_defn): Ditto.
(minimal_language_defn): Ditto.
* f-lang.c (f_language_defn): Ditto.
* jv-lang.c (java_language_defn): Ditto.
* m2-lang.c (m2_language_defn): Ditto.
* scm-lang.c (scm_language_defn): Ditto.
* objc-lang.c (objc_language_defn): Ditto.
* memattr.c (mem_info_command): Use renamed hex_string_custom with
new interface.
* pa64solib.c (pa64_sharedlibrary_info_command): Ditto.
* ui-out.c (ui_out_field_core_addr): Ditto.
* breakpoint.c (breakpoint_adjustment_warning): Ditto.
* exec.c (print_section_info): Ditto.
* i387-tdep.c (print_i387_status_word): Ditto.
(print_i387_control_word): Ditto.
(i387_print_float_info): Ditto.
* maint.c (maint_print_section_info): Ditto.
* solib.c (info_sharedlibrary_command): Ditto.
* somsolib.c (som_sharedlibrary_info_command): Ditto.
* symtab.c (print_msymbol_info): Ditto.
* tracepoint.c (tracepoints_info): Ditto.
* solib-frv.c (lm_base): Ditto.
(frv_current_sos): Ditto.
(enable_break2): Ditto.
(enable_break): Ditto.
* dbxread.c (read_dbx_symtab): Use renamed hex_string.
(process_one_symbol): Ditto.
* infcmd.c (program_info): Ditto.
* mdebugread.c (parse_partial_symbols): Ditto.
* symfile.c (add_symbol_file_command): Ditto.
* cli/cli-cmds.c (edit_command): Ditto.
(list_command): Ditto.
* infcall.c (call_function_by_hand): Ditto.
* remote-vx.c (vx_run_files_info): Ditto.
(vx_wait): Ditto.
(vx_attach): Ditto.
(vx_detach): Ditto.
(vx_kill): Ditto.
* aix-thread.c (pdc_symbol_addrs): Ditto.
(pdc_read_regs): Ditto.
(pdc_write_regs): Ditto.
(pdc_read_data): Ditto.
(pdc_write_data): Ditto.
* d10v-tdep.c (display_trace): Ditto.
* rs6000-nat.c (find_toc_address): Ditto.
* aix-thread.c: Don't include language.h.
* buildsym.c: Ditto.
* dbxread.c: Ditto.
* mdebugread.c: Ditto.
* rs6000-nat.c: Ditto.
* buildsym.c (make_blockvector): Use renamed hex_string.
@
text
@d72 1
a72 1
static void output_source_filename (char *, int *);
d2625 1
a2625 1
output_source_filename (char *name, int *first)
d2674 2
a2675 1
    output_source_filename (s->filename, &first);
d2686 2
a2687 1
	output_source_filename (ps->filename, &first);
@


1.135
log
@2004-08-10  Andrew Cagney  <cagney@@gnu.org>

	* defs.h (xmcalloc): Delete declaration.
	* utils.c (xmcalloc): Delete.
	(xcalloc): Inline calls to xmcalloc and mcalloc.
	* ada-lang.c (_initialize_ada_language): Use htab_create_alloc,
	xcalloc and xfree.
	* symtab.c (create_demangled_names_hash): Ditto.
@
text
@d3139 3
a3141 3
    tmp = local_hex_string_custom (SYMBOL_VALUE_ADDRESS (msymbol)
				   & (CORE_ADDR) 0xffffffff,
				   "08l");
d3143 2
a3144 2
    tmp = local_hex_string_custom (SYMBOL_VALUE_ADDRESS (msymbol),
				   "016l");
@


1.134
log
@Fix crash in symtab.c.
@
text
@d434 1
a434 1
  objfile->demangled_names_hash = htab_create_alloc_ex
d436 1
a436 1
     NULL, objfile->md, xmcalloc, xmfree);
@


1.133
log
@2004-06-18  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (DEPRECATED_FUNCTION_START_OFFSET): Deprecated.
	* gdbarch.h, gdbarch.c: Re-generate.
	* ada-lang.c (ada_finish_decode_line_1): Update.
	* infrun.c (handle_inferior_event): Update.
	* infcall.c (find_function_addr): Update.
	* linespec.c (minsym_found): Update.
	* symtab.c (find_function_start_sal, skip_prologue_using_sal):
	Update.
	* blockframe.c (legacy_frameless_look_for_prologue): Update.
	* cli/cli-cmds.c (disassemble_command): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.

Index: doc/ChangeLog
2004-06-18  Andrew Cagney  <cagney@@gnu.org>

	* gdbint.texinfo (Target Architecture Definition): Deprecate
	FUNCTION_START_OFFSET.
@
text
@d184 5
a188 5
	const char *fp = symtab_to_fullname (s);
	if (FILENAME_CMP (full_path, fp) == 0)
	  {
	    return s;
	  }
d193 10
a202 6
	char *rp = gdb_realpath (symtab_to_fullname (s));
        make_cleanup (xfree, rp);
	if (FILENAME_CMP (real_path, rp) == 0)
	  {
	    return s;
	  }
@


1.132
log
@Add the -file-list-exec-source-files command to MI.
@
text
@d2416 1
a2416 1
      pc += FUNCTION_START_OFFSET;
d3988 1
a3988 1
  start_pc += FUNCTION_START_OFFSET;
@


1.131
log
@	* symtab.c (fixup_section): Search section table when lookup by
	name fails.
@
text
@d184 1
a184 1
	const char *fp = symtab_to_filename (s);
d193 1
a193 1
	char *rp = gdb_realpath (symtab_to_filename (s));
@


1.130
log
@* symtab.h (SYMBOL_SEARCH_NAME): New definition.
(SYMBOL_MATCHES_SEARCH_NAME): New definition.
(symbol_search_name): Declare.

* dictionary.c (iter_name_first_hashed): Match on SYMBOL_SEARCH_NAME.
(iter_name_next_hashed): Ditto.
(iter_name_next_linear): Ditto.
(insert_symbol_hashed): Hash on SYMBOL_SEARCH_NAME.

* symtab.c (lookup_partial_symbol): Assume symbols ordered by
search name, using SYMBOL_SEARCH_NAME and SYMBOL_MATCHES_SEARCH_NAME.
(symbol_search_name): New function.

* symfile.c (compare_psymbols): Order by SYMBOL_SEARCH_NAME.

* minsyms.c (build_minimal_symbol_hash_tables): Change
test for adding to demangled hash table to check for difference
between SYMBOL_SEARCH_NAME and SYMBOL_LINKAGE_NAME.
@
text
@d879 56
@


1.129
log
@2004-04-08  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.h (deprecated_exception_catchpoints_are_fragile)
	(deprecated_exception_support_initialized): Declare.
	* hppa-hpux-tdep.c (initialize_hp_cxx_exception_support)
	(initialize_hp_cxx_exception_support)
	(child_enable_exception_callback): Update.
	* breakpoint.c (deprecated_exception_catchpoints_are_fragile)
	(deprecated_exception_support_initialized): Rename
	deprecated_exception_catchpoints_are_fragile and
	deprecated_exception_support_initialized.
	(breakpoint_init_inferior, breakpoint_init_inferior): Update.

	* symtab.c (deprecated_hp_som_som_object_present): Rename
	hp_som_som_object_present.
	* symtab.h (deprecated_hp_som_som_object_present): Declare.
	* symfile.c (hp_som_som_object_present, RESET_HP_UX_GLOBALS):
	Update.  Delete extern declaration.
	* valops.c (hp_som_som_object_present): Ditto.
	* parse.c (deprecated_hp_som_som_object_present)
	(parse_nested_classes_for_hpacc): Ditto.
	* hpread.c (hp_som_som_object_present, hpread_expand_symtab): Ditto.
	* hppa-hpux-tdep.c (hp_som_som_object_present)
	(initialize_hp_cxx_exception_support): Ditto.
	* eval.c (hp_som_som_object_present, evaluate_subexp_standard): Ditto.
	* cp-valprint.c (hp_som_som_object_present)
	(cp_print_class_method): Ditto.
	* c-typeprint.c (hp_som_som_object_present):
	(c_type_print_base): Ditto.
	* c-exp.y (hp_som_som_object_present): Ditto.
@
text
@d662 8
d1478 1
a1478 1
	  if (strcmp_iw_ordered (SYMBOL_NATURAL_NAME (*center), name) >= 0)
d1493 1
a1493 1
		 : SYMBOL_MATCHES_NATURAL_NAME (*top,name)))
d1514 1
a1514 1
		  : SYMBOL_MATCHES_NATURAL_NAME (*psym, name))
@


1.128
log
@2004-02-19  Joel Brobecker  <brobecker@@gnat.com>

	Committed by Elena Zannoni  <ezannoni@@redhat.com>
	* symtab.c (find_pc_sect_psymtab): Return the psymtab that
	contains a symbol wich is the best, non-exact match for the given
	pc.  Update comments.
@
text
@d117 3
a119 3
/* This flag is used in hppa-tdep.c, and set in hp-symtab-read.c */
/* Signals the presence of objects compiled by HP compilers */
int hp_som_som_object_present = 0;
@


1.128.2.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d117 3
a119 3
/* This flag is used in hppa-tdep.c, and set in hp-symtab-read.c.
   Signals the presence of objects compiled by HP compilers.  */
int deprecated_hp_som_som_object_present = 0;
d184 5
a188 5
        const char *fp = symtab_to_fullname (s);
        if (fp != NULL && FILENAME_CMP (full_path, fp) == 0)
          {
            return s;
          }
d193 6
a198 10
        char *fullname = symtab_to_fullname (s);
        if (fullname != NULL)
          {
            char *rp = gdb_realpath (fullname);
            make_cleanup (xfree, rp);
            if (FILENAME_CMP (real_path, rp) == 0)
              {
                return s;
              }
          }
d430 1
a430 1
  objfile->demangled_names_hash = htab_create_alloc
d432 1
a432 1
     NULL, xcalloc, xfree);
a661 8
/* Return the search name of a symbol---generally the demangled or
   linkage name of the symbol, depending on how it will be searched for.
   If there is no distinct demangled name, then returns the same value 
   (same pointer) as SYMBOL_LINKAGE_NAME. */
char *symbol_search_name (const struct general_symbol_info *gsymbol) {
  return symbol_natural_name (gsymbol);
}

a870 56
  else if (objfile)
    {
      /* Static, function-local variables do appear in the linker
	 (minimal) symbols, but are frequently given names that won't
	 be found via lookup_minimal_symbol().  E.g., it has been
	 observed in frv-uclinux (ELF) executables that a static,
	 function-local variable named "foo" might appear in the
	 linker symbols as "foo.6" or "foo.3".  Thus, there is no
	 point in attempting to extend the lookup-by-name mechanism to
	 handle this case due to the fact that there can be multiple
	 names.
	 
	 So, instead, search the section table when lookup by name has
	 failed.  The ``addr'' and ``endaddr'' fields may have already
	 been relocated.  If so, the relocation offset (i.e. the
	 ANOFFSET value) needs to be subtracted from these values when
	 performing the comparison.  We unconditionally subtract it,
	 because, when no relocation has been performed, the ANOFFSET
	 value will simply be zero.
	 
	 The address of the symbol whose section we're fixing up HAS
	 NOT BEEN adjusted (relocated) yet.  It can't have been since
	 the section isn't yet known and knowing the section is
	 necessary in order to add the correct relocation value.  In
	 other words, we wouldn't even be in this function (attempting
	 to compute the section) if it were already known.

	 Note that it is possible to search the minimal symbols
	 (subtracting the relocation value if necessary) to find the
	 matching minimal symbol, but this is overkill and much less
	 efficient.  It is not necessary to find the matching minimal
	 symbol, only its section.  
	 
	 Note that this technique (of doing a section table search)
	 can fail when unrelocated section addresses overlap.  For
	 this reason, we still attempt a lookup by name prior to doing
	 a search of the section table.  */
	 
      CORE_ADDR addr;
      struct obj_section *s;

      addr = ginfo->value.address;

      ALL_OBJFILE_OSECTIONS (objfile, s)
	{
	  int idx = s->the_bfd_section->index;
	  CORE_ADDR offset = ANOFFSET (objfile->section_offsets, idx);

	  if (s->addr - offset <= addr && addr < s->endaddr - offset)
	    {
	      ginfo->bfd_section = s->the_bfd_section;
	      ginfo->section = idx;
	      return;
	    }
	}
    }
d1470 1
a1470 1
	  if (strcmp_iw_ordered (SYMBOL_SEARCH_NAME (*center), name) >= 0)
d1485 1
a1485 1
		 : SYMBOL_MATCHES_SEARCH_NAME (*top,name)))
d1506 1
a1506 1
		  : SYMBOL_MATCHES_SEARCH_NAME (*psym, name))
d2352 1
a2352 1
      pc += DEPRECATED_FUNCTION_START_OFFSET;
d3071 3
a3073 3
    tmp = hex_string_custom (SYMBOL_VALUE_ADDRESS (msymbol)
			     & (CORE_ADDR) 0xffffffff,
			     8);
d3075 2
a3076 2
    tmp = hex_string_custom (SYMBOL_VALUE_ADDRESS (msymbol),
			     16);
d3924 1
a3924 1
  start_pc += DEPRECATED_FUNCTION_START_OFFSET;
@


1.128.2.2
log
@Merge from mainline.
@
text
@d72 1
a72 1
static void output_source_filename (const char *, int *);
d275 2
a276 1
	psymtab_to_fullname (pst);
d287 2
a288 1
	psymtab_to_fullname (pst);
d1003 1
a1003 1
  /* If we are using C++ or Java, demangle the name before doing a lookup, so
a1014 11
  else if (current_language->la_language == language_java)
    {
      demangled_name = cplus_demangle (name, 
		      		       DMGL_ANSI | DMGL_PARAMS | DMGL_JAVA);
      if (demangled_name)
	{
	  mangled_name = name;
	  modified_name = demangled_name;
	  needtofreename = 1;
	}
    }
d2625 1
a2625 1
output_source_filename (const char *name, int *first)
d2674 1
a2674 2
    const char *fullname = symtab_to_fullname (s);
    output_source_filename (fullname ? fullname : s->filename, &first);
d2685 1
a2685 2
	const char *fullname = psymtab_to_fullname (ps);
	output_source_filename (fullname ? fullname : ps->filename, &first);
@


1.127
log
@2004-02-17  Andrew Cagney  <cagney@@redhat.com>

	* symtab.c (skip_prologue_using_sal): New function.
	* symtab.h (skip_prologue_using_sal): Declare.
	* frv-tdep.c: Include "symtab.h".
	(skip_prologue_using_sal): Delete function.
	* mips-tdep.c (skip_prologue_using_sal): Delete function.
	* rs6000-tdep.c (refine_prologue_limit): Mention
	skip_prologue_using_sal.
	* ia64-tdep.c (refine_prologue_limit): Ditto.
	* Makefile.in: Update dependencies.
@
text
@d675 4
a678 2
/* Find which partial symtab on contains PC and SECTION.  Return 0 if none.  */

d703 2
d717 7
d735 24
d761 1
a761 1
	return (pst);
@


1.126
log
@2004-02-07  Elena Zannoni  <ezannoni@@redhat.com>

	* buildsym.c (free_pending_blocks, finish_block)
	(record_pending_block, make_blockvector, end_symtab): Replace
	symbol_obstack with objfile_obstack.
	* coffread.c (process_coff_symbol, coff_read_struct_type)
	(coff_read_enum_type): Ditto.
	* cp-namespace.c (initialize_namespace_symtab)
	(check_one_possible_namespace_symbol): Ditto.
	* dwarf2read.c (new_symbol, dwarf2_const_value, macro_start_file)
	(dwarf2_symbol_mark_computed): Ditto.
	* dwarfread.c (enum_type, new_symbol, synthesize_typedef): Ditto.
	* elfread.c (elf_symtab_read): Ditto.
	* hpread.c (hpread_symfile_init, hpread_symfile_init)
	(hpread_read_enum_type, hpread_read_function_type)
	(hpread_read_doc_function_type, hpread_process_one_debug_symbol):
	Ditto.
	* jv-lang.c (get_java_class_symtab, add_class_symbol)
	(java_link_class_type): Ditto.
	* mdebugread.c (parse_symbol, psymtab_to_symtab_1, new_symtab)
	(new_symbol): Ditto.
	* minsyms.c (install_minimal_symbols): Ditto.
	* objfiles.c (allocate_objfile): Remove init of symbol_obstack.
	(terminate_minimal_symbol_table): Replace symbol_obstack with
	objfile_obstack.
	(free_objfile): Remove freeing of symbol_obstack.
	* objfiles.h: Remove symbol_obstack field.
	* pa64solib.c (add_to_solist): Replace symbol_obstack with
	objfile_obstack.
	* solib-sunos.c (allocate_rt_common_objfile): Remove init of
	symbol_obstack.
	(solib_add_common_symbols): Replace symbol_obstack with
	objfile_obstack.
	* somsolib.c (som_solib_add): Ditto.
	* stabsread.c (patch_block_stabs, define_symbol, read_enum_type)
	(common_block_start, common_block_end): Ditto.
	* symfile.c (reread_symbols): Remove freeing and init of
	symbol_obstack.
	(allocate_symtab): Rename symbol_obstack to objfile_obstack.
	* symfile.h: Update comment.
	* symmisc.c (print_objfile_statistics): Remove symbol_obstack
	stats printing.
	* symtab.c (symbol_set_names): Replace symbol_obstack with
	objfile_obstack.
	* symtab.h (struct general_symbol_info, struct minimal_symbol):
	Update comments.
	* xcoffread.c (read_xcoff_symtab, SYMBOL_DUP, SYMNAME_ALLOC)
	(init_stringtab, xcoff_initial_scan): Replace symbol_obstack with
	objfile_obstack.
@
text
@d3863 54
@


1.125
log
@2004-01-23  David Carlton  <carlton@@kealia.com>

	Partial workaround for PR c++/1511:
	* cp-namespace.c: Include frame.h.
	(cp_lookup_transparent_type): New
	(cp_lookup_transparent_type_loop): New.
	* cp-support.h: Declare cp_lookup_transparent_type.
	* symtab.c (basic_lookup_transparent_type): Renamed from
	lookup_transparent_type.
	(lookup_transparent_type): Replace old body by a call to
	current_language->la_lookup_transparent_type.
	* symtab.h: Update copyright.  Declare
	basic_lookup_transparent_type.
	* language.h: Update copyright.
	(struct language_defn): Add la_lookup_transparent_type.
	* language.c: Update copyright.
	(unknown_language_defn): Add basic_lookup_transparent_type.
	(auto_language_defn): Add basic_lookup_transparent_type.
	(local_language_defn): Add basic_lookup_transparent_type.
	* ada-lang.c: Update copyright.
	(ada_language_defn): Add basic_lookup_transparent_type.
	* c-lang.c: Update copyright.
	(c_language_defn): Add basic_lookup_transparent_type.
	(cplus_language_defn): Add basic_lookup_transparent_type.
	(asm_language_defn): Add basic_lookup_transparent_type.
	(minimal_language_defn): Add basic_lookup_transparent_type.
	* f-lang.c: Update copyright.
	(f_language_defn): Add basic_lookup_transparent_type.
	* jv-lang.c: Update copyright.
	(java_language_defn): Add basic_lookup_transparent_type.
	* m2-lang.c: Update copyright.
	(m2_language_defn): Add basic_lookup_transparent_type.
	* objc-lang.c: Update copyright.
	(objc_language_defn): Add basic_lookup_transparent_type.
	* p-lang.c: Update copyright.
	(p_language_defn): Add basic_lookup_transparent_type.
	* scm-lang.c: Update copyright.
	(scm_language_defn): Add basic_lookup_transparent_type.
	* Makefile.in (cp-namespace.o): Depend on frame.h.

2004-01-23  David Carlton  <carlton@@kealia.com>

	* gdb.cp/rtti.exp: Don't include full path in ${srcfile}.  Add
	test for cp_lookup_transparent_type.
	* gdb.cp/rtti1.cc: Update copyright.  Add n2::func and refer_to;
	call them.
@
text
@d488 1
a488 1
   is used, and the memory comes from that objfile's symbol_obstack.
d575 1
a575 1
      *slot = obstack_alloc (&objfile->symbol_obstack,
@


1.124
log
@
2003-12-17  Jeff Johnston  <jjohnstn@@redhat.com>

        * symtab.c (decode_line_spec): Change call to decode_line_1.
@
text
@d4 1
a4 1
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d1483 2
a1484 1
   must not be opaque -- i.e., must have at least one field defined
d1486 5
a1490 3
   This code was modelled on lookup_symbol -- the parts not relevant to looking
   up types were just left out.  In particular it's assumed here that types
   are available in struct_domain and only at file-static or global blocks. */
d1492 5
d1499 1
a1499 1
lookup_transparent_type (const char *name)
@


1.123
log
@2003-11-22  Andrew Cagney  <cagney@@redhat.com>

	* config/powerpc/tm-linux.h (PROLOGUE_FIRSTLINE_OVERLAP): Delete
	#if 0'ed macro.
	* infrun.c (step_into_function): Delete #ifdef
	PROLOGUE_FIRSTLINE_OVERLAP code.
	* symtab.c (find_function_start_sal): Ditto.
@
text
@d3871 1
a3871 1
			(char ***) NULL);
@


1.122
log
@2003-11-07  Andrew Cagney  <cagney@@redhat.com>

	* top.c (print_gdb_version): Replace STREQ with strcmp.
	* valops.c (value_struct_elt_for_reference): Ditto.
	(value_struct_elt_for_reference): Ditto.
	* symtab.c (gdb_mangle_name): Ditto.
	(find_line_symtab): Ditto.
	* symmisc.c (maintenance_print_symbols): Ditto.
	* symfile.c (symbol_file_command): Ditto.
	* stabsread.c (define_symbol, read_type): Ditto.
	(cleanup_undefined_types, scan_file_globals): Ditto.
	* solib.c (solib_map_sections): Ditto.
	* solib-svr4.c (bfd_lookup_symbol): Ditto.
	* rs6000-tdep.c (skip_prologue): Ditto.
	* p-valprint.c (pascal_value_print): Ditto.
	(pascal_object_is_vtbl_ptr_type): Ditto.
	* objfiles.c (in_plt_section): Ditto.
	* minsyms.c (lookup_minimal_symbol): Ditto.
	(compact_minimal_symbols): Ditto.
	(find_solib_trampoline_target): Ditto.
	* mdebugread.c (parse_type): Ditto.
	* language.c (set_language_command): Ditto.
	(set_type_command, set_range_command): Ditto.
	* f-lang.c (add_common_block): Ditto.
	(add_common_block): Ditto.
	(find_first_common_named): Ditto.
	(patch_all_commons_by_name): Ditto.
	* elfread.c (elf_locate_sections): Ditto.
	(elf_locate_sections): Ditto.
	(elfstab_offset_sections): Ditto.
	* dwarf2read.c (dwarf2_locate_sections): Ditto.
	* dbxread.c (add_old_header_file): Ditto.
	(find_corresponding_bincl_psymtab): Ditto.
	(read_dbx_symtab, process_one_symbol): Ditto.
	* coffread.c (patch_opaque_types): Ditto.
	* cli/cli-decode.c (delete_cmd): Ditto.
	* cli/cli-cmds.c (pwd_command, list_command): Ditto.
	* c-typeprint.c (c_type_print_base): Ditto.
	* breakpoint.c (bpstat_stop_status): Ditto.
	(clear_command, breakpoint_re_set_one): Ditto.
@
text
@a2316 4
#ifdef PROLOGUE_FIRSTLINE_OVERLAP
  /* Convex: no need to suppress code on first line, if any */
  sal.pc = pc;
#else
a2328 1
#endif
@


1.121
log
@2003-11-04  Andrew Cagney  <cagney@@redhat.com>

	* symtab.c (find_active_alias): Delete function.
	(lookup_block_symbol): Delete alias code.
	* stabsread.c (resolve_live_range): Delete function.
	(add_live_range): Delete function.
	(resolve_symbol_reference): Delete function.
	(define_symbol): Delete live range and alias code.
	(scan_file_globals): Delete alias code.
	* symtab.h (SYMBOL_RANGES): Delete macro.
	(struct range_list): Delete structure.
	(struct symbol): Delete field "ranges".
	(SYMBOL_ALIASES): Delete macro.
	(struct alias_list): Delete structure.
	(struct symbol): Delete field "aliases".
@
text
@d346 1
a346 1
    is_full_physname_constructor || (newname && STREQ (field_name, newname));
d2128 1
a2128 1
	if (!STREQ (symtab->filename, s->filename))
@


1.120
log
@2003-10-21  Elena Zannoni  <ezannoni@@redhat.com>

	* minsyms.c (lookup_minimal_symbol_text): Remove unused parameter.
	Remove SOFUN_ADDRESS_MAYBE_MISSING ifdeffed code.
	* symtab.h (lookup_minimal_symbol_text): Update.
 	* breakpoint.c (create_overlay_event_breakpoint,
 	create_longjmp_breakpoint): Update callers.
	* ppc-linux-tdep.c (ppc_linux_skip_trampoline_code): Update caller.
	* symtab.c (find_pc_sect_line): Ditto.
@
text
@a116 2
static struct symbol *find_active_alias (struct symbol *sym, CORE_ADDR addr);

a1668 23
	      /* If SYM has aliases, then use any alias that is active
	         at the current PC.  If no alias is active at the current
	         PC, then use the main symbol.

	         ?!? Is checking the current pc correct?  Is this routine
	         ever called to look up a symbol from another context?

	         FIXME: No, it's not correct.  If someone sets a
	         conditional breakpoint at an address, then the
	         breakpoint's `struct expression' should refer to the
	         `struct symbol' appropriate for the breakpoint's
	         address, which may not be the PC.

	         Even if it were never called from another context,
	         it's totally bizarre for lookup_symbol's behavior to
	         depend on the value of the inferior's current PC.  We
	         should pass in the appropriate PC as well as the
	         block.  The interface to lookup_symbol should change
	         to require the caller to provide a PC.  */

	      if (SYMBOL_ALIASES (sym))
		sym = find_active_alias (sym, read_pc ());

a1684 32

/* Given a main symbol SYM and ADDR, search through the alias
   list to determine if an alias is active at ADDR and return
   the active alias.

   If no alias is active, then return SYM.  */

static struct symbol *
find_active_alias (struct symbol *sym, CORE_ADDR addr)
{
  struct range_list *r;
  struct alias_list *aliases;

  /* If we have aliases, check them first.  */
  aliases = SYMBOL_ALIASES (sym);

  while (aliases)
    {
      if (!SYMBOL_RANGES (aliases->sym))
	return aliases->sym;
      for (r = SYMBOL_RANGES (aliases->sym); r; r = r->next)
	{
	  if (r->start <= addr && r->end > addr)
	    return aliases->sym;
	}
      aliases = aliases->next;
    }

  /* Nothing found, return the main symbol.  */
  return sym;
}

@


1.119
log
@2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* targets.c: Replace "struct sec" with "struct bfd_section"
	* syms.c, sparclynx.c, section.c, opncls.c: Ditto.
	* libcoff-in.h, libbfd-in.h, elfxx-target.h: Ditto.
	* elf.c, coffgen.c, bfd.c, bfd-in.h, aoutf1.h: Ditto.
	* aout-tic30.c, aout-target.h:
	* bfd-in2.h, libcoff.h, libbfd.h: Regenerate.

Index: binutils/ChangeLog
2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* coffgrok.h (coff_section): Replace 'struct sec" with "struct
	bfd_section".

Index: gdb/ChangeLog
2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* symtab.c: Replace "struct sec" with "struct bfd_section".
	* objfiles.c, linespec.c, blockframe.c, block.c: Ditto.

Index: ld/ChangeLog
2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* pe-dll.c: Replace "struct sec" with "struct bfd_section".

Index: sim/common/ChangeLog
2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* sim-base.h: Replace "struct sec" with "struct bfd_section".
@
text
@d1972 1
a1972 1
					      NULL, NULL);
@


1.118
log
@revert accidental checkin
@
text
@d1875 1
a1875 1
find_pc_sect_line (CORE_ADDR pc, struct sec *section, int notcurrent)
@


1.117
log
@* win32-nat.c (mappings): Remove HAVE_SSE conditional.
@
text
@a436 4
#ifndef LINKER_SYMBOLS_HAVE_WIN32_STDCALL_ARG_SIZES
#define LINKER_SYMBOLS_HAVE_WIN32_STDCALL_ARG_SIZES (0)
#endif

a447 33

  /* On Windows, some functions use the `stdcall' calling convention,
     in which the callee is expected to pop the arguments off the
     stack.  Normally, the caller takes care of this, because only the
     caller knows how many arguments it really passed.  To avoid
     confusion, the linker symbols for `stdcall' functions have names
     with a suffix "@@N" attached to them, where "N" is the number of
     bytes they'll pop.  That way, if a caller thinks some `stdcall'
     function `foo' expects M argument bytes, but the definition of
     `foo' expects N argument bytes, N != M, then the call will be a
     reference to `foo@@M', but the definition will have a linker
     symbol `foo@@N', and you'll get a link-time `symbol not found'
     error, instead of a crash at run-time.

     (Note how this fails to address calls through function pointers,
     since the byte count isn't part of the function pointer's type.
     Go, Microsoft!)

     Whatever.  But our demangler doesn't like that '@@N' suffix, so we
     need to strip it off.  */
  if (LINKER_SYMBOLS_HAVE_WIN32_STDCALL_ARG_SIZES)
    {
      char *arg_byte_suffix = strchr (mangled, '@@');
      if (arg_byte_suffix)
        {
          int prefix_len = arg_byte_suffix - mangled;
          char *mangled_sans_suffix = alloca (prefix_len + 1);
          memcpy (mangled_sans_suffix, mangled, prefix_len);
          mangled_sans_suffix[prefix_len] = '\0';

          mangled = mangled_sans_suffix;
        }
    }
@


1.116
log
@2003-09-16  Andrew Cagney  <cagney@@redhat.com>

	* buildsym.c: Remove more occurances of "register".
	* coffread.c, dbxread.c, dcache.c, dwarf2read.c: Ditto.
	* environ.c, eval.c, f-valprint.c, findvar.c: Ditto.
	* gdbtypes.c, gnu-v2-abi.c, h8300-tdep.c, hppa-tdep.c: Ditto.
	* infcmd.c, mdebugread.c, minsyms.c, mips-tdep.c: Ditto.
	* printcmd.c, remote-vx.c, sh-stub.c, sh-tdep.c: Ditto.
	* sh64-tdep.c, source.c, stabsread.c, stack.c: Ditto.
	* standalone.c, symfile.c, symmisc.c, symtab.c: Ditto.
	* utils.c, valops.c, values.c, xcoffread.c: Ditto.
@
text
@d437 4
d452 33
@


1.115
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@d1633 1
a1633 1
lookup_block_symbol (register const struct block *block, const char *name,
d2291 1
a2291 1
find_line_common (register struct linetable *l, register int lineno,
d2312 1
a2312 1
      register struct linetable_entry *item = &(l->item[i]);
d2420 1
a2420 1
      register char *q = p + 1;
@


1.114
log
@2003-08-08  Elena Zannoni  <ezannoni@@redhat.com>

	* symtab.c (lookup_symbol_aux): Make sure that is_a_field_of_this
	contains something meaningful at all times.
@
text
@d154 3
a156 3
  register struct symtab *s;
  register struct partial_symtab *ps;
  register struct objfile *objfile;
d247 2
a248 2
  register struct partial_symtab *pst;
  register struct objfile *objfile;
d682 2
a683 2
  register struct partial_symtab *pst;
  register struct objfile *objfile;
d1495 3
a1497 3
  register struct symbol *sym;
  register struct symtab *s = NULL;
  register struct partial_symtab *ps;
d1499 2
a1500 2
  register struct objfile *objfile;
  register struct block *block;
d1604 2
a1605 2
  register struct partial_symtab *pst;
  register struct objfile *objfile;
d1749 1
a1749 1
  register struct block *b;
d1751 4
a1754 4
  register struct symtab *s = NULL;
  register struct symtab *best_s = NULL;
  register struct partial_symtab *ps;
  register struct objfile *objfile;
d1878 4
a1881 4
  register struct linetable *l;
  register int len;
  register int i;
  register struct linetable_entry *item;
d2294 2
a2295 2
  register int i;
  register int len;
d2610 3
a2612 3
  register struct symtab *s;
  register struct partial_symtab *ps;
  register struct objfile *objfile;
d2752 3
a2754 3
  register struct symtab *s;
  register struct partial_symtab *ps;
  register struct blockvector *bv;
d2756 2
a2757 2
  register struct block *b;
  register int i = 0;
d2759 1
a2759 1
  register struct symbol *sym;
d3588 3
a3590 3
  register struct symbol *sym;
  register struct symtab *s;
  register struct block *b;
d3751 3
a3753 3
  register struct symtab *s;
  register struct partial_symtab *ps;
  register struct objfile *objfile;
@


1.113
log
@2003-06-12  David Carlton  <carlton@@kealia.com>

	* symtab.c (lookup_symbol_aux_minsyms): Replace
	DEPRECATED_SYMBOL_NAME by SYMBOL_LINKAGE_NAME.
	(find_pc_sect_line, search_symbols, rbreak_command): Ditto.
	(COMPLETION_LIST_ADD_SYMBOL): Rewrite in terms of
	SYMBOL_NATURAL_NAME.
@
text
@d948 8
a971 1
      *is_a_field_of_this = 0;
@


1.113.4.1
log
@2003-08-08  Elena Zannoni  <ezannoni@@redhat.com>

	* symtab.c (lookup_symbol_aux): Make sure that is_a_field_of_this
	contains something meaningful at all times.
@
text
@a947 8
  /* Make sure we do something sensible with is_a_field_of_this, since
     the callers that set this parameter to some non-null value will
     certainly use it later and expect it to be either 0 or 1.
     If we don't set it, the contents of is_a_field_of_this are
     undefined.  */
  if (is_a_field_of_this != NULL)
    *is_a_field_of_this = 0;

d964 1
@


1.112
log
@2003-06-12  David Carlton  <carlton@@bactrian.org>

	* symtab.h: Delete declaration of make_symbol_overload_list.
	Add declaration of lookup_partial_symbol.
	* symtab.c (remove_params): Move to cp-support.c.
	(overload_list_add_symbol, make_symbol_overload_list)
	(sym_return_val_size, sym_return_val_index): Ditto.
	(lookup_partial_symbol): Make extern.
	* cp-support.h: Add declaration of make_symbol_overload_list.
	* cp-support.c: Include dictionary.h, objfiles.h, frame.h,
	symtab.h, and block.h.
	(remove_params): Move here from symtab.c.
	(overload_list_add_symbol, make_symbol_overload_list)
	(sym_return_val_size, sym_return_val_index): Ditto.
	* valops.c: Include cp-support.h.
	* Makefile.in (cp-support.o): Depend on dictionary_h, objfiles_h,
	frame_h, and block_h.
	(valops.o): Depend on cp_support_h.
@
text
@d1230 1
a1230 1
	      /* This call used to pass `DEPRECATED_SYMBOL_NAME (msymbol)' as the
d1964 2
a1965 1
	mfunsym = lookup_minimal_symbol_text (DEPRECATED_SYMBOL_NAME (msymbol), NULL, NULL);
d1976 1
a1976 1
	  /* warning ("In stub for %s; unable to find real function/line info", DEPRECATED_SYMBOL_NAME (msymbol)) */ ;
d1981 1
a1981 1
	  /* warning ("In stub for %s; unable to find real function/line info", DEPRECATED_SYMBOL_NAME (msymbol)) */ ;
d2915 1
a2915 1
			|| lookup_symbol (DEPRECATED_SYMBOL_NAME (msymbol),
d3007 1
a3007 1
		    if (lookup_symbol (DEPRECATED_SYMBOL_NAME (msymbol),
d3187 3
a3189 3
	  char *string = (char *) alloca (strlen (p->symtab->filename)
					  + strlen (DEPRECATED_SYMBOL_NAME (p->symbol))
					  + 4);
d3192 1
a3192 1
	  strcat (string, DEPRECATED_SYMBOL_NAME (p->symbol));
d3203 1
a3203 1
	  break_command (DEPRECATED_SYMBOL_NAME (p->msymbol), from_tty);
a3219 5
  do { \
    if (SYMBOL_DEMANGLED_NAME (symbol) != NULL) \
      /* Put only the mangled name on the list.  */ \
      /* Advantage:  "b foo<TAB>" completes to "b foo(int, int)" */ \
      /* Disadvantage:  "b foo__i<TAB>" doesn't complete.  */ \
d3221 1
a3221 5
	(SYMBOL_DEMANGLED_NAME (symbol), (sym_text), (len), (text), (word)); \
    else \
      completion_list_add_name \
	(DEPRECATED_SYMBOL_NAME (symbol), (sym_text), (len), (text), (word)); \
  } while (0)
@


1.111
log
@2003-06-11  David Carlton  <carlton@@bactrian.org>

	* dictionary.h: New.
	* dictionary.c: New.
	* block.h: Add opaque declaration for struct dictionary.
	(struct block): Add 'dict' member; delete 'hashtable', 'nsyms',
	'sym' members.
	(BLOCK_DICT): New macro.
	Delete macros BLOCK_HASHTABLE, BLOCK_NSYMS, BLOCK_SYM,
	BLOCK_BUCKETS, BLOCK_BUCKET, BLOCK_HASHTABLE_SIZE,
	BLOCK_SHOULD_SORT.
	(ALL_BLOCK_SYMBOLS): Update definition.
	* Makefile.in (SFILES): Add dictionary.c.
	(dictionary_h): New.
	(COMMON_OBS): Add dictionary.o.
	(dictionary.o): New.
	(ada-lang.o): Depend on dictionary_h.
	(buildsym.o, coffread.o, jv-lang.o, mdebugread.o, objfiles.o)
	(stack.o, symmisc.o, symtab.o, tracepoint.o, valops.o)
	(mi-cmd-stack.o): Ditto.
	(gdbtk-cmds.o): Update dependencies.
	(gdbtk-stack.o): Ditto.
	* ada-lang.c: Include dictionary.h.
	(symtab_for_sym): Update uses of ALL_BLOCK_SYMBOLS.
	(fill_in_ada_prototype, debug_print_block): Ditto.
	(ada_add_block_symbols): Update uses of ALL_BLOCK_SYMBOLS; replace
	explicit iteration by use of ALL_BLOCK_SYMBOLS.  Delete variable
	'is_sorted'.
	* mdebugread.c: Include dictionary.h.
	(struct parse_stack): Delete 'maxsyms' member.
	(parse_symbol): Update calls to new_block.  Delete calls to
	shrink_block.  Use dictionary methods.
	(psymtab_to_symtab_1): Delete calls to sort_symtab_syms.
	Update calls to new_symtab.  Don't maintain maxsyms data.
	(mylookup_symbol): Update use of ALL_BLOCK_SYMBOLS.
	(add_symbol): Just call dict_add_symbol.
	(new_symtab): Delete 'maxsyms' argument.
	(new_symtab): Update calls to new_block.
	(new_block): Delete 'maxsyms' argument; add 'function' argument.
	(shrink_block): Delete function.
	(fixup_sigtramp): Update call to new_block.  Add symbol via
	dict_add_symbol.
	* jv-lang.c: Include dictionary.h.
	(get_java_class_symtab): Set the BLOCK_DICT of the blocks
	appropriately.  Set class_symtab->free_func.  Make sure the
	blockvector is big enough to hold two blocks.
	(add_class_symtab_symbol): Use dictionary methods.
	(free_class_block): New function.
	(type_from_class): Replace explicit iteration by
	ALL_BLOCK_SYMBOLS.
	* symtab.h (struct symtab): Replace 'free_ptr' method by
	'free_func'.
	* dwarf2read.c (psymtab_to_symtab_1): Delete call to
	sort_symtab_syms.
	* dwarfread.c (psymtab_to_symtab_1): Delete call to
	sort_symtab_syms.
	* coffread.c (coff_symfile_read): Delete call to sort_symtab_syms.
	Include dictionary.h.
	(patch_opaque_types): Update use of ALL_BLOCK_SYMBOLS.
	* dbxread.c (dbx_psymtab_to_symtab_1): Delete call to
	sort_symtab_syms.
	* objfiles.c: Include dictionary.h.
	(objfile_relocate): Update use of ALL_BLOCK_SYMBOLS.
	* buildsym.c: Include dictionary.h.
	(finish_block): Use dictionary methods.
	(end_symtab): Set free_func to NULL, not free_ptr.
	* tracepoint.c: Include dictionary.h.
	(add_local_symbols): Update use of ALL_BLOCK_SYMBOLS.
	(scope_info): Ditto.
	* stack.c: Include dictionary.h.
	(print_block_frame_locals): Update use of ALL_BLOCK_SYMBOLS.
	(print_block_frame_labels, print_frame_arg_vars)
	(print_frame_args): Ditto.
	* symmisc.c (free_symtab_block): Use dictionary methods.
	(dump_symtab): Ditto.
	(free_symtab): Replace use of 'free_ptr' by 'free_func'.
	Include	dictionary.h.
	* symfile.h: Delete declarations of sort_block_syms,
	sort_symtab_syms.
	* symfile.c (sort_block_syms): Delete.
	(sort_symtab_syms): Delete.
	* symtab.c: Include dictionary.h.
	(lookup_block_symbol): Use dictionary iterators.
	(find_pc_sect_symtab): Update use of ALL_BLOCK_SYMBOLS.
	(search_symbols, make_symbol_completion_list): Ditto.
	(make_symbol_overload_list): Ditto.
	* valops.c (value_of_local): Use dict_empty.
	Include dictionary.h.

2003-06-11  David Carlton  <carlton@@bactrian.org>

	* generic/gdbtk-stack.c: Include dictionary.h.
	(gdb_block_vars): Update use of ALL_BLOCK_SYMBOLS.
	(gdb_get_blocks, gdb_get_vars_command): Ditto.
	* generic/gdbtk-cmds.c: Include dictionary.h.
	(gdb_listfuncs): Update use of ALL_BLOCK_SYMBOLS.

2003-06-11  David Carlton  <carlton@@bactrian.org>

	* mi-cmd-stack.c: Include dictionary.h.
	(list_args_or_locals): Update use of ALL_BLOCK_SYMBOLS.
@
text
@a79 5
static struct partial_symbol *lookup_partial_symbol (struct partial_symtab *,
						     const char *,
						     const char *, int,
						     domain_enum);

a133 2
static void overload_list_add_symbol (struct symbol *sym, char *oload_name);

d1388 1
a1388 1
static struct partial_symbol *
a3917 205

/* Begin overload resolution functions */

static char *
remove_params (const char *demangled_name)
{
  const char *argp;
  char *new_name;
  int depth;

  if (demangled_name == NULL)
    return NULL;

  /* First find the end of the arg list.  */
  argp = strrchr (demangled_name, ')');
  if (argp == NULL)
    return NULL;

  /* Back up to the beginning.  */
  depth = 1;

  while (argp-- > demangled_name)
    {
      if (*argp == ')')
	depth ++;
      else if (*argp == '(')
	{
	  depth --;

	  if (depth == 0)
	    break;
	}
    }
  if (depth != 0)
    internal_error (__FILE__, __LINE__,
		    "bad demangled name %s\n", demangled_name);
  while (argp[-1] == ' ' && argp > demangled_name)
    argp --;

  new_name = xmalloc (argp - demangled_name + 1);
  memcpy (new_name, demangled_name, argp - demangled_name);
  new_name[argp - demangled_name] = '\0';
  return new_name;
}

/* Helper routine for make_symbol_completion_list.  */

static int sym_return_val_size;
static int sym_return_val_index;
static struct symbol **sym_return_val;

/*  Test to see if the symbol specified by SYMNAME (which is already
   demangled for C++ symbols) matches SYM_TEXT in the first SYM_TEXT_LEN
   characters.  If so, add it to the current completion list. */

static void
overload_list_add_symbol (struct symbol *sym, char *oload_name)
{
  int newsize;
  int i;
  char *sym_name;

  /* If there is no type information, we can't do anything, so skip */
  if (SYMBOL_TYPE (sym) == NULL)
    return;

  /* skip any symbols that we've already considered. */
  for (i = 0; i < sym_return_val_index; ++i)
    if (!strcmp (DEPRECATED_SYMBOL_NAME (sym), DEPRECATED_SYMBOL_NAME (sym_return_val[i])))
      return;

  /* Get the demangled name without parameters */
  sym_name = remove_params (SYMBOL_DEMANGLED_NAME (sym));
  if (!sym_name)
    return;

  /* skip symbols that cannot match */
  if (strcmp (sym_name, oload_name) != 0)
    {
      xfree (sym_name);
      return;
    }

  xfree (sym_name);

  /* We have a match for an overload instance, so add SYM to the current list
   * of overload instances */
  if (sym_return_val_index + 3 > sym_return_val_size)
    {
      newsize = (sym_return_val_size *= 2) * sizeof (struct symbol *);
      sym_return_val = (struct symbol **) xrealloc ((char *) sym_return_val, newsize);
    }
  sym_return_val[sym_return_val_index++] = sym;
  sym_return_val[sym_return_val_index] = NULL;
}

/* Return a null-terminated list of pointers to function symbols that
 * match name of the supplied symbol FSYM.
 * This is used in finding all overloaded instances of a function name.
 * This has been modified from make_symbol_completion_list.  */


struct symbol **
make_symbol_overload_list (struct symbol *fsym)
{
  register struct symbol *sym;
  register struct symtab *s;
  register struct partial_symtab *ps;
  register struct objfile *objfile;
  register struct block *b, *surrounding_static_block = 0;
  struct dict_iterator iter;
  /* The name we are completing on. */
  char *oload_name = NULL;
  /* Length of name.  */
  int oload_name_len = 0;

  /* Look for the symbol we are supposed to complete on.  */

  oload_name = remove_params (SYMBOL_DEMANGLED_NAME (fsym));
  if (!oload_name)
    {
      sym_return_val_size = 1;
      sym_return_val = (struct symbol **) xmalloc (2 * sizeof (struct symbol *));
      sym_return_val[0] = fsym;
      sym_return_val[1] = NULL;

      return sym_return_val;
    }
  oload_name_len = strlen (oload_name);

  sym_return_val_size = 100;
  sym_return_val_index = 0;
  sym_return_val = (struct symbol **) xmalloc ((sym_return_val_size + 1) * sizeof (struct symbol *));
  sym_return_val[0] = NULL;

  /* Read in all partial symtabs containing a partial symbol named
     OLOAD_NAME.  */

  ALL_PSYMTABS (objfile, ps)
  {
    struct partial_symbol **psym;

    /* If the psymtab's been read in we'll get it when we search
       through the blockvector.  */
    if (ps->readin)
      continue;

    if ((lookup_partial_symbol (ps, oload_name, NULL, 1, VAR_DOMAIN)
	 != NULL)
	|| (lookup_partial_symbol (ps, oload_name, NULL, 0, VAR_DOMAIN)
	    != NULL))
      PSYMTAB_TO_SYMTAB (ps);
  }

  /* Search upwards from currently selected frame (so that we can
     complete on local vars.  */

  for (b = get_selected_block (0); b != NULL; b = BLOCK_SUPERBLOCK (b))
    {
      if (!BLOCK_SUPERBLOCK (b))
	{
	  surrounding_static_block = b;		/* For elimination of dups */
	}

      /* Also catch fields of types defined in this places which match our
         text string.  Only complete on types visible from current context. */

      ALL_BLOCK_SYMBOLS (b, iter, sym)
	{
	  overload_list_add_symbol (sym, oload_name);
	}
    }

  /* Go through the symtabs and check the externs and statics for
     symbols which match.  */

  ALL_SYMTABS (objfile, s)
  {
    QUIT;
    b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), GLOBAL_BLOCK);
    ALL_BLOCK_SYMBOLS (b, iter, sym)
      {
	overload_list_add_symbol (sym, oload_name);
      }
  }

  ALL_SYMTABS (objfile, s)
  {
    QUIT;
    b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), STATIC_BLOCK);
    /* Don't do this block twice.  */
    if (b == surrounding_static_block)
      continue;
    ALL_BLOCK_SYMBOLS (b, iter, sym)
      {
	overload_list_add_symbol (sym, oload_name);
      }
  }

  xfree (oload_name);

  return (sym_return_val);
}

/* End of overload resolution functions */
@


1.110
log
@2003-06-11  David Carlton  <carlton@@bactrian.org>

	* block.h (BLOCK_SHOULD_SORT): Delete.
	* symtab.c (lookup_block_symbol): Don't worry about sorted linear
	blocks.
	* ada-lang.c (ada_add_block_symbols): Ditto.
	* symfile.c (sort_block_syms): Delete.
	(sort_symtab_syms): Ditto.
	* symfile.h: Delete sort_symtabs_syms and sort_block_syms
	declarations.
	* coffread.c (coff_symfile_read): Don't call sort_symtab_syms.
	* dbxread.c (dbx_psymtab_to_symtab_1): Ditto.
	* dwarf2read.c (psymtab_to_symtab_1): Ditto.
	* dwarfread.c (psymtab_to_symtab_1): Ditto.
	* hpread.c (hpread_psymtab_to_symtab_1): Ditto.
	* mdebugread.c (psymtab_to_symtab_1): Ditto.
	* xcoffread.c (xcoff_psymtab_to_symtab_1): Ditto.
@
text
@d49 1
d1637 2
a1638 3
  register int bot, top, inc;
  register struct symbol *sym;
  register struct symbol *sym_found = NULL;
d1640 1
a1640 1
  if (BLOCK_HASHTABLE (block))
d1642 7
a1648 9
      unsigned int hash_index;
      hash_index = msymbol_hash_iw (name);
      hash_index = hash_index % BLOCK_BUCKETS (block);
      for (sym = BLOCK_BUCKET (block, hash_index); sym; sym = sym->hash_next)
	{
	  if (SYMBOL_DOMAIN (sym) == domain 
	      && (linkage_name
		  ? strcmp (DEPRECATED_SYMBOL_NAME (sym), linkage_name) == 0
		  : SYMBOL_MATCHES_NATURAL_NAME (sym, name)))
d1660 6
a1665 3
      top = BLOCK_NSYMS (block);
      bot = 0;
      while (bot < top)
a1666 1
	  sym = BLOCK_SYM (block, bot);
d1668 2
a1669 3
	      && (linkage_name
		  ? strcmp (DEPRECATED_SYMBOL_NAME (sym), linkage_name) == 0
		  : SYMBOL_MATCHES_NATURAL_NAME (sym, name)))
d1678 12
a1689 12
		 FIXME: No, it's not correct.  If someone sets a
		 conditional breakpoint at an address, then the
		 breakpoint's `struct expression' should refer to the
		 `struct symbol' appropriate for the breakpoint's
		 address, which may not be the PC.

		 Even if it were never called from another context,
		 it's totally bizarre for lookup_symbol's behavior to
		 depend on the value of the inferior's current PC.  We
		 should pass in the appropriate PC as well as the
		 block.  The interface to lookup_symbol should change
		 to require the caller to provide a PC.  */
a1705 1
	  bot++;
d1707 1
a1707 2

      return (sym_found);		/* Will be NULL if not found. */
d1811 1
a1811 1
	    int i;
d1814 1
a1814 1
	    ALL_BLOCK_SYMBOLS (b, i, sym)
d1820 1
a1820 1
	    if ((i >= BLOCK_BUCKETS (b)) && (sym == NULL))
d2757 1
a2757 1
  register int j;
d2946 1
a2946 1
	  ALL_BLOCK_SYMBOLS (b, j, sym)
d3407 8
a3414 7
  register struct symbol *sym;
  register struct symtab *s;
  register struct partial_symtab *ps;
  register struct minimal_symbol *msymbol;
  register struct objfile *objfile;
  register struct block *b, *surrounding_static_block = 0;
  register int i, j;
d3537 1
a3537 1
      ALL_BLOCK_SYMBOLS (b, i, sym)
d3568 1
a3568 1
    ALL_BLOCK_SYMBOLS (b, i, sym)
d3581 1
a3581 1
    ALL_BLOCK_SYMBOLS (b, i, sym)
d3599 1
a3599 1
  register int i;
d3678 1
a3678 1
  ALL_BLOCK_SYMBOLS (b, i, sym)
d3684 1
a3684 1
  ALL_BLOCK_SYMBOLS (b, i, sym)
d4035 1
a4035 1
  register int i;
d4092 1
a4092 1
      ALL_BLOCK_SYMBOLS (b, i, sym)
d4105 1
a4105 1
    ALL_BLOCK_SYMBOLS (b, i, sym)
d4118 1
a4118 1
    ALL_BLOCK_SYMBOLS (b, i, sym)
@


1.109
log
@2003-05-19  David Carlton  <carlton@@bactrian.org>

	* language.h (struct language_defn): Add 'la_value_of_this'
	and 'la_lookup_symbol_nonlocal' members.
	* symtab.h: Declare basic_lookup_symbol_nonlocal,
	lookup_symbol_static, lookup_symbol_global,
	lookup_symbol_aux_block.
	* symtab.c (lookup_symbol_aux): Call language hooks to determine
	if we should search fields of this and how to do static/global
	lookup.
	(lookup_symbol_aux_block): Make extern.
	(basic_lookup_symbol_nonlocal): New.
	(lookup_symbol_static, lookup_symbol_global): Ditto.
	* ada-lang.c (ada_language_defn): Set 'la_value_of_this' and
	'la_lookup_symbol_nonlocal' members.
	* c-lang.c (c_language_defn, cplus_language_defn)
	(asm_language_defn, minimal_language_defn): Ditto.
	* jv-lang.c (java_language_defn): Ditto.
	* language.c (unknown_language_defn, auto_language_defn)
	(local_language_defn): Ditto.
	* m2-lang.c (m2_language_defn): Ditto.
	* objc-lang.c (objc_language_defn): Ditto.
	* scm-lang.c (scm_language_defn): Ditto.
	* f-lang.c (f_language_defn): Ditto, and include value.h as well.
	* p-lang.c (pascal_language_defn): Ditto for both.
	* Makefile.in (f-lang.o): Depend on value_h.
	(p-lang.o): Ditto.
@
text
@a1638 1
  register int do_linear_search = 1;
d1655 1
a1655 91

  /* If the blocks's symbols were sorted, start with a binary search.  */

  if (BLOCK_SHOULD_SORT (block))
    {
      /* Reset the linear search flag so if the binary search fails, we
         won't do the linear search once unless we find some reason to
         do so */

      do_linear_search = 0;
      top = BLOCK_NSYMS (block);
      bot = 0;

      /* Advance BOT to not far before the first symbol whose name is NAME. */

      while (1)
	{
	  inc = (top - bot + 1);
	  /* No need to keep binary searching for the last few bits worth.  */
	  if (inc < 4)
	    {
	      break;
	    }
	  inc = (inc >> 1) + bot;
	  sym = BLOCK_SYM (block, inc);
	  if (!do_linear_search && (SYMBOL_LANGUAGE (sym) == language_java))
	    {
	      do_linear_search = 1;
	    }
	  if (SYMBOL_NATURAL_NAME (sym)[0] < name[0])
	    {
	      bot = inc;
	    }
	  else if (SYMBOL_NATURAL_NAME (sym)[0] > name[0])
	    {
	      top = inc;
	    }
	  else if (strcmp (SYMBOL_NATURAL_NAME (sym), name) < 0)
	    {
	      bot = inc;
	    }
	  else
	    {
	      top = inc;
	    }
	}

      /* Now scan forward until we run out of symbols, find one whose
         name is greater than NAME, or find one we want.  If there is
         more than one symbol with the right name and domain, we
         return the first one; I believe it is now impossible for us
         to encounter two symbols with the same name and domain
         here, because blocks containing argument symbols are no
         longer sorted.  The exception is for C++, where multiple functions
	 (cloned constructors / destructors, in particular) can have
	 the same demangled name.  So if we have a particular
	 mangled name to match, try to do so.  */

      top = BLOCK_NSYMS (block);
      while (bot < top)
	{
	  sym = BLOCK_SYM (block, bot);
	  if (SYMBOL_DOMAIN (sym) == domain
	      && (linkage_name
		  ? strcmp (DEPRECATED_SYMBOL_NAME (sym), linkage_name) == 0
		  : SYMBOL_MATCHES_NATURAL_NAME (sym, name)))
	    {
	      return sym;
	    }
          if (SYMBOL_PRINT_NAME (sym)[0] > name[0])
            {
              break;
            }
	  bot++;
	}
    }

  /* Here if block isn't sorted, or we fail to find a match during the
     binary search above.  If during the binary search above, we find a
     symbol which is a Java symbol, then we have re-enabled the linear
     search flag which was reset when starting the binary search.

     This loop is equivalent to the loop above, but hacked greatly for speed.

     Note that parameter symbols do not always show up last in the
     list; this loop makes sure to take anything else other than
     parameter symbols first; it only uses parameter symbols as a
     last resort.  Note that this only takes up extra computation
     time on a match.  */

  if (do_linear_search)
d1657 5
d1709 2
a1711 1
  return (sym_found);		/* Will be NULL if not found. */
@


1.108
log
@2003-05-19  David Carlton  <carlton@@bactrian.org>

	* block.h: Declare block_static_block.
	* block.c (block_static_block): New.
	* symtab.c (lookup_symbol_aux): Remove 'static_block' argument to
	lookup_symbol_aux_local, calling block_static_block instead.
	(lookup_symbol_aux_local): Delete 'static_block' argument.
@
text
@a98 7
struct symbol *lookup_symbol_aux_block (const char *name,
					const char *linkage_name,
					const struct block *block,
					const domain_enum domain,
					struct symtab **symtab);

static
a952 1
  const struct block *static_block;
d962 5
a966 3
  /* C++/Java/Objective-C: If requested to do so by the caller, 
     check to see if NAME is a field of `this'. */
  if (is_a_field_of_this)
d968 1
a968 1
      struct value *v = value_of_this (0);
d980 2
a981 37
  /* If there's a static block to search, search it next.  */

  /* NOTE: carlton/2002-12-05: There is a question as to whether or
     not it would be appropriate to search the current global block
     here as well.  (That's what this code used to do before the
     is_a_field_of_this check was moved up.)  On the one hand, it's
     redundant with the lookup_symbol_aux_symtabs search that happens
     next.  On the other hand, if decode_line_1 is passed an argument
     like filename:var, then the user presumably wants 'var' to be
     searched for in filename.  On the third hand, there shouldn't be
     multiple global variables all of which are named 'var', and it's
     not like decode_line_1 has ever restricted its search to only
     global variables in a single filename.  All in all, only
     searching the static block here seems best: it's correct and it's
     cleanest.  */

  /* NOTE: carlton/2002-12-05: There's also a possible performance
     issue here: if you usually search for global symbols in the
     current file, then it would be slightly better to search the
     current global block before searching all the symtabs.  But there
     are other factors that have a much greater effect on performance
     than that one, so I don't think we should worry about that for
     now.  */

  static_block = block_static_block (block);
  if (static_block != NULL)
    {
      sym = lookup_symbol_aux_block (name, linkage_name, static_block,
				     domain, symtab);
      if (sym != NULL)
	return sym;
    }

  /* Now search all global blocks.  Do the symtab's first, then
     check the psymtab's. If a psymtab indicates the existence
     of the desired name as a global, then do psymtab-to-symtab
     conversion on the fly and return the found symbol. */
d983 3
a985 7
  sym = lookup_symbol_aux_symtabs (GLOBAL_BLOCK, name, linkage_name,
				   domain, symtab);
  if (sym != NULL)
    return sym;

  sym = lookup_symbol_aux_psymtabs (GLOBAL_BLOCK, name, linkage_name,
				    domain, symtab);
d1044 1
a1044 1
static struct symbol *
d1301 87
@


1.107
log
@2003-05-19  David Carlton  <carlton@@bactrian.org>

	* symtab.c (lookup_symbol_aux): Delete #if 0 hunk.
@
text
@d96 1
a96 2
					struct symtab **symtab,
					const struct block **static_block);
d966 1
a966 1
				 symtab, &static_block);
d1010 1
d1056 1
a1056 2
   Don't search STATIC_BLOCK or GLOBAL_BLOCK.  If we don't find a
   match, store the address of STATIC_BLOCK in static_block.  */
d1062 1
a1062 2
			 struct symtab **symtab,
			 const struct block **static_block)
d1065 2
a1066 1
  
d1069 2
a1070 5
  if (block == NULL || BLOCK_SUPERBLOCK (block) == NULL)
    {
      *static_block = NULL;
      return NULL;
    }
d1072 1
a1072 1
  while (BLOCK_SUPERBLOCK (BLOCK_SUPERBLOCK (block)) != NULL)
d1081 1
a1081 1
  /* We've reached the static block.  */
a1082 1
  *static_block = block;
@


1.106
log
@* symtab.c (completion_list_objc_symbol): New function.
(make_symbol_completion_list): Use it to add ObjC symbols
when looking though the list.
(language_search_unquoted_string): New function.
(make_file_symbol_completion_list): Use it.
@
text
@a970 46
#if 0
  /* NOTE: carlton/2002-11-05: At the time that this code was
     #ifdeffed out, the value of 'block' was always NULL at this
     point, hence the bemused comments below.  */

  /* FIXME: this code is never executed--block is always NULL at this
     point.  What is it trying to do, anyway?  We already should have
     checked the STATIC_BLOCK above (it is the superblock of top-level
     blocks).  Why is VAR_DOMAIN special-cased?  */
  /* Don't need to mess with the psymtabs; if we have a block,
     that file is read in.  If we don't, then we deal later with
     all the psymtab stuff that needs checking.  */
  /* Note (RT): The following never-executed code looks unnecessary to me also.
   * If we change the code to use the original (passed-in)
   * value of 'block', we could cause it to execute, but then what
   * would it do? The STATIC_BLOCK of the symtab containing the passed-in
   * 'block' was already searched by the above code. And the STATIC_BLOCK's
   * of *other* symtabs (those files not containing 'block' lexically)
   * should not contain 'block' address-wise. So we wouldn't expect this
   * code to find any 'sym''s that were not found above. I vote for 
   * deleting the following paragraph of code.
   */
  if (domain == VAR_DOMAIN && block != NULL)
    {
      struct block *b;
      /* Find the right symtab.  */
      ALL_SYMTABS (objfile, s)
      {
	bv = BLOCKVECTOR (s);
	b = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
	if (BLOCK_START (b) <= BLOCK_START (block)
	    && BLOCK_END (b) > BLOCK_START (block))
	  {
	    sym = lookup_block_symbol (b, name, linkage_name, VAR_DOMAIN);
	    if (sym)
	      {
		block_found = b;
		if (symtab != NULL)
		  *symtab = s;
		return fixup_symbol_section (sym, objfile);
	      }
	  }
      }
    }
#endif /* 0 */

@


1.105
log
@2003-05-18  David Carlton  <carlton@@bactrian.org>

	* symtab.c (lookup_symbol_aux): Rename 'mangled_name' argument to
	'linkage_name'.  Add comment.
	(lookup_symbol_aux_local): Rename 'mangled_name' argument to
	'linkage_name'.
	(lookup_symbol_aux_block, lookup_symbol_aux_symtabs)
	(lookup_symbol_aux_psymtabs, lookup_symbol_aux_minsyms)
	(lookup_block_symbol): Ditto.
@
text
@d3388 106
d3616 2
d3635 1
d3741 2
a3742 10
	/* It is not a quoted string.  Break it based on the characters
	   which are in symbols.  */
	while (p > text)
	  {
	    if (isalnum (p[-1]) || p[-1] == '_' || p[-1] == '\0')
	      --p;
	    else
	      break;
	  }
	sym_text = p;
@


1.104
log
@2003-05-15  David Carlton  <carlton@@bactrian.org>

	Committed by Elena Zannoni <ezannoni@@redhat.com>
        * symtab.c (lookup_symbol_aux): Delete calls to
        lookup_symbol_aux_minsyms.
        (lookup_symbol_aux_minsyms): Comment out function and
        prototype. Delete lookup by mangled name.
@
text
@d85 1
a85 1
					 const char *mangled_name,
d93 1
a93 1
					const char *mangled_name,
d101 1
a101 1
					const char *mangled_name,
d109 1
a109 1
					  const char *mangled_name,
d116 1
a116 1
					   const char *mangled_name,
d123 1
a123 1
					  const char *mangled_name,
d950 5
d956 1
a956 1
lookup_symbol_aux (const char *name, const char *mangled_name,
d966 1
a966 1
  sym = lookup_symbol_aux_local (name, mangled_name, block, domain,
d1004 1
a1004 1
	    sym = lookup_block_symbol (b, name, mangled_name, VAR_DOMAIN);
d1059 1
a1059 1
      sym = lookup_symbol_aux_block (name, mangled_name, static_block,
d1070 1
a1070 1
  sym = lookup_symbol_aux_symtabs (GLOBAL_BLOCK, name, mangled_name,
d1075 1
a1075 1
  sym = lookup_symbol_aux_psymtabs (GLOBAL_BLOCK, name, mangled_name,
d1086 1
a1086 1
  sym = lookup_symbol_aux_symtabs (STATIC_BLOCK, name, mangled_name,
d1091 1
a1091 1
  sym = lookup_symbol_aux_psymtabs (STATIC_BLOCK, name, mangled_name,
d1106 1
a1106 1
lookup_symbol_aux_local (const char *name, const char *mangled_name,
d1124 1
a1124 1
      sym = lookup_symbol_aux_block (name, mangled_name, block, domain,
d1141 1
a1141 1
lookup_symbol_aux_block (const char *name, const char *mangled_name,
d1152 1
a1152 1
  sym = lookup_block_symbol (block, name, mangled_name, domain);
d1185 1
a1185 1
			   const char *name, const char *mangled_name,
d1199 1
a1199 1
    sym = lookup_block_symbol (block, name, mangled_name, domain);
d1219 1
a1219 1
			    const char *mangled_name,
d1234 1
a1234 1
	&& lookup_partial_symbol (ps, name, mangled_name,
d1240 1
a1240 1
	sym = lookup_block_symbol (block, name, mangled_name, domain);
d1257 1
a1257 1
	    sym = lookup_block_symbol (block, name, mangled_name, domain);
d1293 1
a1293 1
			   const char *mangled_name,
d1338 1
a1338 1
		lookup_block_symbol (block, name, mangled_name, domain);
d1345 1
a1345 1
					     mangled_name, domain);
d1636 1
a1636 1
   If MANGLED_NAME is non-NULL, verify that any symbol we find has this
d1642 1
a1642 1
		     const char *mangled_name,
d1658 2
a1659 2
	      && (mangled_name
		  ? strcmp (DEPRECATED_SYMBOL_NAME (sym), mangled_name) == 0
d1728 2
a1729 2
	      && (mangled_name
		  ? strcmp (DEPRECATED_SYMBOL_NAME (sym), mangled_name) == 0
d1763 2
a1764 2
	      && (mangled_name
		  ? strcmp (DEPRECATED_SYMBOL_NAME (sym), mangled_name) == 0
@


1.103
log
@2003-05-14  Elena Zannoni  <ezannoni@@redhat.com>

	* symtab.h (enum domain_enum): Rename from namespace_enum.
	(UNDEF_DOMAIN, VAR_DOMAIN, STRUCT_DOMAIN, LABEL_DOMAIN,
	VARIABLES_DOMAIN, FUNCTIONS_DOMAIN, TYPES_DOMAIN, METHODS_DOMAIN):
	Rename from UNDEF_NAMESPACE, VAR_NAMESPACE, STRUCT_NAMESPACE,
	LABEL_NAMESPACE, VARIABLES_NAMESPACE, FUNCTIONS_NAMESPACE,
	TYPES_NAMESPACE, METHODS_NAMESPACE.
	(SYMBOL_NAMESPACE): Rename to SYMBOL_DOMAIN.
	(struct symbol, struct partial_symbol): Rename field
	'namespace_enum namespace' to 'domain_enum domain'.
	(PSYMBOL_NAMESPACE): Rename to PSYMBOL_DOMAIN.
	Delete old define kludge for namespace.

	* ada-exp.y, ada-lang.c, ada-lang.h, alpha-tdep.c, arm-tdep.c,
	blockframe.c, c-exp.y, c-valprint.c, coffread.c, dbxread.c,
	dwarf2read.c, dwarfread.c, f-exp.y, gdbtypes.c, gdbtypes.h,
	gnu-v3-abi.c, hppa-tdep.c, hpread.c, jv-exp.y, jv-lang.c,
	language.c, linespec.c, m2-exp.y, m3-nat.c, mdebugread.c,
	mips-tdep.c, nlmread.c, objc-exp.y, objc-lang.c, objfiles.c,
	p-exp.y, p-valprint.c, parse.c, printcmd.c, scm-lang.c, source.c,
	stabsread.c, stack.c, symfile.c, symfile.h, symmisc.c, symtab.c,
	valops.c, values.c, xcoffread.c, xstormy16-tdep.c: Replace all
	occurrences of the above.

2003-05-12  Elena Zannoni  <ezannoni@@redhat.com>

	* mi-mi-cmd-stack.c (list_args_or_locals): Rename VAR_NAMESPACE to
	VAR_DOMAIN.
@
text
@d120 1
d127 1
a1069 15
#ifndef HPUXHPPA

  /* Check for the possibility of the symbol being a function or
     a mangled variable that is stored in one of the minimal symbol tables.
     Eventually, all global symbols might be resolved in this way.  */

  sym = lookup_symbol_aux_minsyms (name, mangled_name,
				   domain, is_a_field_of_this,
				   symtab);
  
  if (sym != NULL)
    return sym;

#endif

a1090 27
#ifdef HPUXHPPA

  /* Check for the possibility of the symbol being a function or
     a global variable that is stored in one of the minimal symbol tables.
     The "minimal symbol table" is built from linker-supplied info.

     RT: I moved this check to last, after the complete search of
     the global (p)symtab's and static (p)symtab's. For HP-generated
     symbol tables, this check was causing a premature exit from
     lookup_symbol with NULL return, and thus messing up symbol lookups
     of things like "c::f". It seems to me a check of the minimal
     symbol table ought to be a last resort in any case. I'm vaguely
     worried about the comment below which talks about FORTRAN routines "foo_"
     though... is it saying we need to do the "minsym" check before
     the static check in this case? 
   */


  sym = lookup_symbol_aux_minsyms (name, mangled_name,
				   domain, is_a_field_of_this,
				   symtab);
  
  if (sym != NULL)
    return sym;

#endif

d1267 1
d1281 5
a1385 10
	  else if (MSYMBOL_TYPE (msymbol) != mst_text
		   && MSYMBOL_TYPE (msymbol) != mst_file_text
		   && !STREQ (name, DEPRECATED_SYMBOL_NAME (msymbol)))
	    {
	      /* This is a mangled variable, look it up by its
	         mangled name.  */
	      return lookup_symbol_aux (DEPRECATED_SYMBOL_NAME (msymbol), mangled_name,
					NULL, domain, is_a_field_of_this,
					symtab);
	    }
d1391 1
@


1.102
log
@* symtab.c (symbol_find_demangled_name): Check for and demangle
ObjC symbols.
(symbol_init_demangled_name): Init for language_objc as well.
@
text
@d82 1
a82 1
						     namespace_enum);
d87 1
a87 1
					 const namespace_enum namespace,
d95 1
a95 1
					const namespace_enum namespace,
d103 1
a103 1
					const namespace_enum namespace,
d110 1
a110 1
					  const namespace_enum namespace,
d117 1
a117 1
					   const namespace_enum namespace,
d123 1
a123 1
					  const namespace_enum namespace,
d137 1
a137 1
static void print_symbol_info (namespace_enum,
d142 1
a142 1
static void symtab_symbol_info (char *, namespace_enum, int);
d782 1
a782 1
      if (SYMBOL_NAMESPACE (p) == VAR_NAMESPACE
d806 1
a806 1
      if (SYMBOL_NAMESPACE (p) == VAR_NAMESPACE
d881 1
a881 1
   in namespace NAMESPACE, visible from lexical block BLOCK.
d903 1
a903 1
	       const namespace_enum namespace, int *is_a_field_of_this,
d941 1
a941 1
				 namespace, is_a_field_of_this, symtab);
d950 1
a950 1
		   const struct block *block, const namespace_enum namespace,
d959 1
a959 1
  sym = lookup_symbol_aux_local (name, mangled_name, block, namespace,
d972 1
a972 1
     blocks).  Why is VAR_NAMESPACE special-cased?  */
d986 1
a986 1
  if (namespace == VAR_NAMESPACE && block != NULL)
d997 1
a997 1
	    sym = lookup_block_symbol (b, name, mangled_name, VAR_NAMESPACE);
d1053 1
a1053 1
				     namespace, symtab);
d1064 1
a1064 1
				   namespace, symtab);
d1075 1
a1075 1
				   namespace, is_a_field_of_this,
d1084 1
a1084 1
				    namespace, symtab);
d1095 1
a1095 1
				   namespace, symtab);
d1100 1
a1100 1
				    namespace, symtab);
d1123 1
a1123 1
				   namespace, is_a_field_of_this,
d1143 1
a1143 1
			 const namespace_enum namespace,
d1159 1
a1159 1
      sym = lookup_symbol_aux_block (name, mangled_name, block, namespace,
d1178 1
a1178 1
			 const namespace_enum namespace,
d1187 1
a1187 1
  sym = lookup_block_symbol (block, name, mangled_name, namespace);
d1221 1
a1221 1
			   const namespace_enum namespace,
d1234 1
a1234 1
    sym = lookup_block_symbol (block, name, mangled_name, namespace);
d1255 1
a1255 1
			    const namespace_enum namespace,
d1270 1
a1270 1
				  psymtab_index, namespace))
d1275 1
a1275 1
	sym = lookup_block_symbol (block, name, mangled_name, namespace);
d1292 1
a1292 1
	    sym = lookup_block_symbol (block, name, mangled_name, namespace);
d1323 1
a1323 1
			   const namespace_enum namespace,
d1333 1
a1333 1
  if (namespace == VAR_NAMESPACE)
d1367 1
a1367 1
		lookup_block_symbol (block, name, mangled_name, namespace);
d1374 1
a1374 1
					     mangled_name, namespace);
d1427 1
a1427 1
					NULL, namespace, is_a_field_of_this,
d1444 1
a1444 1
		       namespace_enum namespace)
d1468 1
a1468 1
         namespace.  */
d1500 1
a1500 1
	  if (SYMBOL_NAMESPACE (*top) == namespace)
d1515 1
a1515 1
	  if (namespace == SYMBOL_NAMESPACE (*psym))
d1530 1
a1530 1
/* Look up a type named NAME in the struct_namespace.  The type returned
d1535 1
a1535 1
   are available in struct_namespace and only at file-static or global blocks. */
d1557 1
a1557 1
    sym = lookup_block_symbol (block, name, NULL, STRUCT_NAMESPACE);
d1567 1
a1567 1
					      1, STRUCT_NAMESPACE))
d1572 1
a1572 1
	sym = lookup_block_symbol (block, name, NULL, STRUCT_NAMESPACE);
d1581 1
a1581 1
	    sym = lookup_block_symbol (block, name, NULL, STRUCT_NAMESPACE);
d1605 1
a1605 1
    sym = lookup_block_symbol (block, name, NULL, STRUCT_NAMESPACE);
d1614 1
a1614 1
    if (!ps->readin && lookup_partial_symbol (ps, name, NULL, 0, STRUCT_NAMESPACE))
d1619 1
a1619 1
	sym = lookup_block_symbol (block, name, NULL, STRUCT_NAMESPACE);
d1628 1
a1628 1
	    sym = lookup_block_symbol (block, name, NULL, STRUCT_NAMESPACE);
d1655 1
a1655 1
    if (lookup_partial_symbol (pst, main_name (), NULL, 1, VAR_NAMESPACE))
d1663 1
a1663 1
/* Search BLOCK for symbol NAME in NAMESPACE.
d1681 1
a1681 1
		     const namespace_enum namespace)
d1695 1
a1695 1
	  if (SYMBOL_NAMESPACE (sym) == namespace 
d1752 1
a1752 1
         more than one symbol with the right name and namespace, we
d1754 1
a1754 1
         to encounter two symbols with the same name and namespace
d1765 1
a1765 1
	  if (SYMBOL_NAMESPACE (sym) == namespace
d1800 1
a1800 1
	  if (SYMBOL_NAMESPACE (sym) == namespace
d2871 4
a2874 4
   FUNCTIONS_NAMESPACE - search all functions
   TYPES_NAMESPACE     - search all type names
   METHODS_NAMESPACE   - search all methods NOT IMPLEMENTED
   VARIABLES_NAMESPACE - search all symbols, excluding functions, type names,
d2883 1
a2883 1
search_symbols (char *regexp, namespace_enum kind, int nfiles, char *files[],
d2920 2
a2921 2
  if (kind < VARIABLES_NAMESPACE)
    error ("must search on specific namespace");
d2923 4
a2926 4
  ourtype = types[(int) (kind - VARIABLES_NAMESPACE)];
  ourtype2 = types2[(int) (kind - VARIABLES_NAMESPACE)];
  ourtype3 = types3[(int) (kind - VARIABLES_NAMESPACE)];
  ourtype4 = types4[(int) (kind - VARIABLES_NAMESPACE)];
d3008 1
a3008 1
		    && ((kind == VARIABLES_NAMESPACE && SYMBOL_CLASS (*psym) != LOC_TYPEDEF
d3010 3
a3012 3
			|| (kind == FUNCTIONS_NAMESPACE && SYMBOL_CLASS (*psym) == LOC_BLOCK)
			|| (kind == TYPES_NAMESPACE && SYMBOL_CLASS (*psym) == LOC_TYPEDEF)
			|| (kind == METHODS_NAMESPACE && SYMBOL_CLASS (*psym) == LOC_BLOCK))))
d3035 1
a3035 1
  if (nfiles == 0 && (kind == VARIABLES_NAMESPACE || kind == FUNCTIONS_NAMESPACE))
d3055 1
a3055 1
		    if (kind == FUNCTIONS_NAMESPACE
d3058 1
a3058 1
					  VAR_NAMESPACE,
d3087 1
a3087 1
		      && ((kind == VARIABLES_NAMESPACE && SYMBOL_CLASS (sym) != LOC_TYPEDEF
d3090 3
a3092 3
			  || (kind == FUNCTIONS_NAMESPACE && SYMBOL_CLASS (sym) == LOC_BLOCK)
			  || (kind == TYPES_NAMESPACE && SYMBOL_CLASS (sym) == LOC_TYPEDEF)
			  || (kind == METHODS_NAMESPACE && SYMBOL_CLASS (sym) == LOC_BLOCK))))
d3131 1
a3131 1
  if (found_misc || kind != FUNCTIONS_NAMESPACE)
d3144 1
a3144 1
		if (kind != FUNCTIONS_NAMESPACE ||
d3149 1
a3149 1
				       (struct block *) NULL, VAR_NAMESPACE,
d3184 1
a3184 1
print_symbol_info (namespace_enum kind, struct symtab *s, struct symbol *sym,
d3194 1
a3194 1
  if (kind != TYPES_NAMESPACE && block == STATIC_BLOCK)
d3198 2
a3199 2
  if (kind == TYPES_NAMESPACE
      && SYMBOL_NAMESPACE (sym) != STRUCT_NAMESPACE)
d3202 3
a3204 3
  else if (kind < TYPES_NAMESPACE ||
	   (kind == TYPES_NAMESPACE &&
	    SYMBOL_NAMESPACE (sym) == STRUCT_NAMESPACE))
d3240 1
a3240 1
symtab_symbol_info (char *regexp, namespace_enum kind, int from_tty)
d3258 1
a3258 1
		   classnames[(int) (kind - VARIABLES_NAMESPACE)], regexp);
d3290 1
a3290 1
  symtab_symbol_info (regexp, VARIABLES_NAMESPACE, from_tty);
d3296 1
a3296 1
  symtab_symbol_info (regexp, FUNCTIONS_NAMESPACE, from_tty);
d3303 1
a3303 1
  symtab_symbol_info (regexp, TYPES_NAMESPACE, from_tty);
d3321 1
a3321 1
  search_symbols (regexp, FUNCTIONS_NAMESPACE, 0, (char **) NULL, &ss);
d3336 1
a3336 1
	  print_symbol_info (FUNCTIONS_NAMESPACE,
d4105 1
a4105 1
    if ((lookup_partial_symbol (ps, oload_name, NULL, 1, VAR_NAMESPACE)
d4107 1
a4107 1
	|| (lookup_partial_symbol (ps, oload_name, NULL, 0, VAR_NAMESPACE)
@


1.102.4.1
log
@Snap const char * mess.
@
text
@d61 1
a61 1
static void rbreak_command (const char *, int);
d63 1
a63 1
static void types_info (const char *, int);
d65 1
a65 1
static void functions_info (const char *, int);
d67 1
a67 1
static void variables_info (const char *, int);
d69 1
a69 1
static void sources_info (const char *, int);
d77 1
a77 1
const char *operator_chars (const char *p, const char **end);
d142 1
a142 1
static void symtab_symbol_info (const char *, namespace_enum, int);
d2533 2
a2534 2
const char *
operator_chars (const char *p, const char **end)
d2554 1
a2554 1
      const char *q = p + 1;
d2742 1
a2742 1
sources_info (const char *ignore, int from_tty)
d2883 2
a2884 2
search_symbols (const char *regexp, namespace_enum kind, int nfiles,
		char *files[], struct symbol_search **matches)
d2937 2
a2938 2
      const char *opend;
      const char *opname = operator_chars (regexp, &opend);
d3240 1
a3240 1
symtab_symbol_info (const char *regexp, namespace_enum kind, int from_tty)
d3288 1
a3288 1
variables_info (const char *regexp, int from_tty)
d3294 1
a3294 1
functions_info (const char *regexp, int from_tty)
d3301 1
a3301 1
types_info (const char *regexp, int from_tty)
d3309 1
a3309 1
rbreak_command_wrapper (const char *regexp, int from_tty)
d3315 1
a3315 1
rbreak_command (const char *regexp, int from_tty)
d4165 1
a4165 1
decode_line_spec (const char *string, int funfirstline)
@


1.101
log
@2003-04-14  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (symbol_set_names): Add prefix when storing Java names
	in hash table.  Fix for PR java/1039.
@
text
@d43 1
d463 12
d623 2
a624 1
      || gsymbol->language == language_java)
d1010 1
a1010 1
  /* C++: If requested to do so by the caller, 
d1670 3
a1672 3
   search on the symbols.  Each symbol which is marked as being a C++
   symbol (language_cplus set) has both the encoded and non-encoded names
   tested for a match.
@


1.101.2.1
log
@Merge from mainline.
@
text
@a42 1
#include "objc-lang.h"
a461 12

  if (gsymbol->language == language_objc
      || gsymbol->language == language_auto)
    {
      demangled =
	objc_demangle (mangled, 0);
      if (demangled != NULL)
	{
	  gsymbol->language = language_objc;
	  return demangled;
	}
    }
d610 1
a610 2
      || gsymbol->language == language_java
      || gsymbol->language == language_objc)
d996 1
a996 1
  /* C++/Java/Objective-C: If requested to do so by the caller, 
d1656 3
a1658 3
   search on the symbols.  Each symbol which is marked as being a ObjC/C++
   symbol (language_cplus or language_objc set) has both the encoded and 
   non-encoded names tested for a match.
@


1.101.2.2
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d82 1
a82 1
						     domain_enum);
d87 1
a87 1
					 const domain_enum domain,
d95 1
a95 1
					const domain_enum domain,
d103 1
a103 1
					const domain_enum domain,
d110 1
a110 1
					  const domain_enum domain,
d117 1
a117 1
					   const domain_enum domain,
a119 1
#if 0
d123 1
a123 1
					  const domain_enum domain,
a125 1
#endif
d137 1
a137 1
static void print_symbol_info (domain_enum,
d142 1
a142 1
static void symtab_symbol_info (char *, domain_enum, int);
d782 1
a782 1
      if (SYMBOL_DOMAIN (p) == VAR_DOMAIN
d806 1
a806 1
      if (SYMBOL_DOMAIN (p) == VAR_DOMAIN
d881 1
a881 1
   in domain DOMAIN, visible from lexical block BLOCK.
d903 1
a903 1
	       const domain_enum domain, int *is_a_field_of_this,
d941 1
a941 1
				 domain, is_a_field_of_this, symtab);
d950 1
a950 1
		   const struct block *block, const domain_enum domain,
d959 1
a959 1
  sym = lookup_symbol_aux_local (name, mangled_name, block, domain,
d972 1
a972 1
     blocks).  Why is VAR_DOMAIN special-cased?  */
d986 1
a986 1
  if (domain == VAR_DOMAIN && block != NULL)
d997 1
a997 1
	    sym = lookup_block_symbol (b, name, mangled_name, VAR_DOMAIN);
d1053 1
a1053 1
				     domain, symtab);
d1064 14
a1077 1
				   domain, symtab);
d1081 2
d1084 1
a1084 1
				    domain, symtab);
d1095 1
a1095 1
				   domain, symtab);
d1100 1
a1100 1
				    domain, symtab);
d1104 27
d1143 1
a1143 1
			 const domain_enum domain,
d1159 1
a1159 1
      sym = lookup_symbol_aux_block (name, mangled_name, block, domain,
d1178 1
a1178 1
			 const domain_enum domain,
d1187 1
a1187 1
  sym = lookup_block_symbol (block, name, mangled_name, domain);
d1221 1
a1221 1
			   const domain_enum domain,
d1234 1
a1234 1
    sym = lookup_block_symbol (block, name, mangled_name, domain);
d1255 1
a1255 1
			    const domain_enum domain,
d1270 1
a1270 1
				  psymtab_index, domain))
d1275 1
a1275 1
	sym = lookup_block_symbol (block, name, mangled_name, domain);
d1292 1
a1292 1
	    sym = lookup_block_symbol (block, name, mangled_name, domain);
a1306 1
#if 0
a1319 5
/* NOTE: carlton/2003-05-14: This function was once used as part of
   lookup_symbol.  It is currently unnecessary for correctness
   reasons, however, and using it doesn't seem to be any faster than
   using lookup_symbol_aux_psymtabs, so I'm commenting it out.  */

d1323 1
a1323 1
			   const domain_enum domain,
d1333 1
a1333 1
  if (domain == VAR_DOMAIN)
d1367 1
a1367 1
		lookup_block_symbol (block, name, mangled_name, domain);
d1374 1
a1374 1
					     mangled_name, domain);
d1420 10
a1434 1
#endif /* 0 */
d1444 1
a1444 1
		       domain_enum domain)
d1468 1
a1468 1
         domain.  */
d1500 1
a1500 1
	  if (SYMBOL_DOMAIN (*top) == domain)
d1515 1
a1515 1
	  if (domain == SYMBOL_DOMAIN (*psym))
d1530 1
a1530 1
/* Look up a type named NAME in the struct_domain.  The type returned
d1535 1
a1535 1
   are available in struct_domain and only at file-static or global blocks. */
d1557 1
a1557 1
    sym = lookup_block_symbol (block, name, NULL, STRUCT_DOMAIN);
d1567 1
a1567 1
					      1, STRUCT_DOMAIN))
d1572 1
a1572 1
	sym = lookup_block_symbol (block, name, NULL, STRUCT_DOMAIN);
d1581 1
a1581 1
	    sym = lookup_block_symbol (block, name, NULL, STRUCT_DOMAIN);
d1605 1
a1605 1
    sym = lookup_block_symbol (block, name, NULL, STRUCT_DOMAIN);
d1614 1
a1614 1
    if (!ps->readin && lookup_partial_symbol (ps, name, NULL, 0, STRUCT_DOMAIN))
d1619 1
a1619 1
	sym = lookup_block_symbol (block, name, NULL, STRUCT_DOMAIN);
d1628 1
a1628 1
	    sym = lookup_block_symbol (block, name, NULL, STRUCT_DOMAIN);
d1655 1
a1655 1
    if (lookup_partial_symbol (pst, main_name (), NULL, 1, VAR_DOMAIN))
d1663 1
a1663 1
/* Search BLOCK for symbol NAME in DOMAIN.
d1681 1
a1681 1
		     const domain_enum domain)
d1695 1
a1695 1
	  if (SYMBOL_DOMAIN (sym) == domain 
d1752 1
a1752 1
         more than one symbol with the right name and domain, we
d1754 1
a1754 1
         to encounter two symbols with the same name and domain
d1765 1
a1765 1
	  if (SYMBOL_DOMAIN (sym) == domain
d1800 1
a1800 1
	  if (SYMBOL_DOMAIN (sym) == domain
d2871 4
a2874 4
   FUNCTIONS_DOMAIN - search all functions
   TYPES_DOMAIN     - search all type names
   METHODS_DOMAIN   - search all methods NOT IMPLEMENTED
   VARIABLES_DOMAIN - search all symbols, excluding functions, type names,
d2883 1
a2883 1
search_symbols (char *regexp, domain_enum kind, int nfiles, char *files[],
d2920 2
a2921 2
  if (kind < VARIABLES_DOMAIN)
    error ("must search on specific domain");
d2923 4
a2926 4
  ourtype = types[(int) (kind - VARIABLES_DOMAIN)];
  ourtype2 = types2[(int) (kind - VARIABLES_DOMAIN)];
  ourtype3 = types3[(int) (kind - VARIABLES_DOMAIN)];
  ourtype4 = types4[(int) (kind - VARIABLES_DOMAIN)];
d3008 1
a3008 1
		    && ((kind == VARIABLES_DOMAIN && SYMBOL_CLASS (*psym) != LOC_TYPEDEF
d3010 3
a3012 3
			|| (kind == FUNCTIONS_DOMAIN && SYMBOL_CLASS (*psym) == LOC_BLOCK)
			|| (kind == TYPES_DOMAIN && SYMBOL_CLASS (*psym) == LOC_TYPEDEF)
			|| (kind == METHODS_DOMAIN && SYMBOL_CLASS (*psym) == LOC_BLOCK))))
d3035 1
a3035 1
  if (nfiles == 0 && (kind == VARIABLES_DOMAIN || kind == FUNCTIONS_DOMAIN))
d3055 1
a3055 1
		    if (kind == FUNCTIONS_DOMAIN
d3058 1
a3058 1
					  VAR_DOMAIN,
d3087 1
a3087 1
		      && ((kind == VARIABLES_DOMAIN && SYMBOL_CLASS (sym) != LOC_TYPEDEF
d3090 3
a3092 3
			  || (kind == FUNCTIONS_DOMAIN && SYMBOL_CLASS (sym) == LOC_BLOCK)
			  || (kind == TYPES_DOMAIN && SYMBOL_CLASS (sym) == LOC_TYPEDEF)
			  || (kind == METHODS_DOMAIN && SYMBOL_CLASS (sym) == LOC_BLOCK))))
d3131 1
a3131 1
  if (found_misc || kind != FUNCTIONS_DOMAIN)
d3144 1
a3144 1
		if (kind != FUNCTIONS_DOMAIN ||
d3149 1
a3149 1
				       (struct block *) NULL, VAR_DOMAIN,
d3184 1
a3184 1
print_symbol_info (domain_enum kind, struct symtab *s, struct symbol *sym,
d3194 1
a3194 1
  if (kind != TYPES_DOMAIN && block == STATIC_BLOCK)
d3198 2
a3199 2
  if (kind == TYPES_DOMAIN
      && SYMBOL_DOMAIN (sym) != STRUCT_DOMAIN)
d3202 3
a3204 3
  else if (kind < TYPES_DOMAIN ||
	   (kind == TYPES_DOMAIN &&
	    SYMBOL_DOMAIN (sym) == STRUCT_DOMAIN))
d3240 1
a3240 1
symtab_symbol_info (char *regexp, domain_enum kind, int from_tty)
d3258 1
a3258 1
		   classnames[(int) (kind - VARIABLES_DOMAIN)], regexp);
d3290 1
a3290 1
  symtab_symbol_info (regexp, VARIABLES_DOMAIN, from_tty);
d3296 1
a3296 1
  symtab_symbol_info (regexp, FUNCTIONS_DOMAIN, from_tty);
d3303 1
a3303 1
  symtab_symbol_info (regexp, TYPES_DOMAIN, from_tty);
d3321 1
a3321 1
  search_symbols (regexp, FUNCTIONS_DOMAIN, 0, (char **) NULL, &ss);
d3336 1
a3336 1
	  print_symbol_info (FUNCTIONS_DOMAIN,
d4105 1
a4105 1
    if ((lookup_partial_symbol (ps, oload_name, NULL, 1, VAR_DOMAIN)
d4107 1
a4107 1
	|| (lookup_partial_symbol (ps, oload_name, NULL, 0, VAR_DOMAIN)
@


1.100
log
@2003-04-14  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (symbol_set_names): Rename 'name' arg to
	'linkage_name', and 'tmpname' variable to 'linkage_name_copy'.
	* symtab.h: Change 'name' argument in declaration of
	symbol_set_names to 'linkage_name'.
	(SYMBOL_SET_NAMES): Change 'name' argument to 'linkage_name'.
@
text
@d493 19
d519 5
d530 15
a544 2
     can just use the given copy.  */
  if (linkage_name[len] != '\0')
d547 1
d549 1
a549 1
      alloc_name = alloca (len + 1);
d551 1
a551 1
      alloc_name[len] = '\0';
d553 1
d558 2
d564 1
a564 1
				   linkage_name_copy, INSERT);
d577 2
a578 2
			     len + demangled_len + 2);
      memcpy (*slot, linkage_name_copy, len + 1);
d581 1
a581 1
	  memcpy (*slot + len + 1, demangled_name, demangled_len + 1);
d585 1
a585 1
	(*slot)[len + 1] = '\0';
d588 2
a589 2
  gsymbol->name = *slot;
  if ((*slot)[len + 1] != '\0')
d591 1
a591 1
      = &(*slot)[len + 1];
@


1.99
log
@2003-03-04  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_partial_symbol): Add linkage_name argument.
	(lookup_symbol_aux_psymtabs): Update call to
	lookup_partial_symbol.
	(lookup_transparent_type, find_main_psymtab)
	(make_symbol_overload_list): Ditto.
@
text
@d487 5
a491 4
/* Set both the mangled and demangled (if any) names for GSYMBOL based on
   NAME and LEN.  The hash table corresponding to OBJFILE is used, and the
   memory comes from that objfile's symbol_obstack.  NAME is copied, so the
   pointer can be discarded after calling this function.  */
d495 1
a495 1
		  const char *name, int len, struct objfile *objfile)
d498 2
a499 1
  const char *tmpname;
d504 4
a507 4
  /* The stabs reader generally provides names that are not NULL-terminated;
     most of the other readers don't do this, so we can just use the given
     copy.  */
  if (name[len] != 0)
d509 7
a515 4
      char *alloc_name = alloca (len + 1);
      memcpy (alloc_name, name, len);
      alloc_name[len] = 0;
      tmpname = alloc_name;
d518 3
a520 1
    tmpname = name;
d522 2
a523 1
  slot = (char **) htab_find_slot (objfile->demangled_names_hash, tmpname, INSERT);
d528 2
a529 1
      char *demangled_name = symbol_find_demangled_name (gsymbol, tmpname);
d537 2
a538 2
      memcpy (*slot, tmpname, len + 1);
      if (demangled_name)
d544 1
a544 1
	(*slot)[len + 1] = 0;
d548 1
a548 1
  if ((*slot)[len + 1])
@


1.98
log
@2003-03-03  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (DEPRECATED_SYMBOL_MATCHES_NAME): Rename from
	SYMBOL_MATCHES_NAME, add comment.
	(SYMBOL_MATCHES_NATURAL_NAME): New.
	* minsyms.c (lookup_minimal_symbol_solib_trampoline): Replace
	SYMBOL_MATCHES_NAME with DEPRECATED_SYMBOL_MATCHES_NAME.
	(lookup_minimal_symbol, lookup_minimal_symbol_text): Ditto.
	* symtab.c (lookup_partial_symbol): Use
	SYMBOL_MATCHES_NATURAL_NAME, not SYMBOL_MATCHES_NAME.  Delete
	unhelpful comment.
	(lookup_block_symbol): Use SYMBOL_MATCHES_NATURAL_NAME, not
	SYMBOL_MATCHES_NAME.
	Fix for PR c++/33.
@
text
@d79 1
d1205 2
a1206 1
	&& lookup_partial_symbol (ps, name, psymtab_index, namespace))
d1372 4
a1375 2
/* Look, in partial_symtab PST, for symbol NAME.  Check the global
   symbols if GLOBAL, the static symbols if not */
d1378 2
a1379 1
lookup_partial_symbol (struct partial_symtab *pst, const char *name, int global,
d1431 4
a1434 1
      while (top <= real_top && SYMBOL_MATCHES_NATURAL_NAME (*top,name))
d1453 3
a1455 1
	      if (SYMBOL_MATCHES_NATURAL_NAME (*psym, name))
d1502 2
a1503 1
    if (!ps->readin && lookup_partial_symbol (ps, name, 1, STRUCT_NAMESPACE))
d1550 1
a1550 1
    if (!ps->readin && lookup_partial_symbol (ps, name, 0, STRUCT_NAMESPACE))
d1591 1
a1591 1
    if (lookup_partial_symbol (pst, main_name (), 1, VAR_NAMESPACE))
d4041 4
a4044 2
    if ((lookup_partial_symbol (ps, oload_name, 1, VAR_NAMESPACE) != NULL)
	|| (lookup_partial_symbol (ps, oload_name, 0, VAR_NAMESPACE) != NULL))
@


1.97
log
@2003-03-03  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_MATCHES_REGEXP): Delete.
	* symtab.c (search_symbols): Replace uses of SYMBOL_MATCHES_REGEXP
	by regexp matching against SYMBOL_NATURAL_NAME.
@
text
@d1426 1
a1426 4
      /* djb - 2000-06-03 - Use SYMBOL_MATCHES_NAME, not a strcmp, so
	 we don't have to force a linear search on C++. Probably holds true
	 for JAVA as well, no way to check.*/
      while (top <= real_top && SYMBOL_MATCHES_NAME (*top,name))
d1445 1
a1445 1
	      if (SYMBOL_MATCHES_NAME (*psym, name))
d1623 1
a1623 1
		  : SYMBOL_MATCHES_NAME (sym, name)))
d1693 1
a1693 1
		  : SYMBOL_MATCHES_NAME (sym, name)))
d1728 1
a1728 1
		  : SYMBOL_MATCHES_NAME (sym, name)))
@


1.96
log
@2003-02-27  David Carlton  <carlton@@math.stanford.edu>

	* symfile.c (compare_symbols): Use SYMBOL_NATURAL_NAME, not
	SYMBOL_PRINT_NAME.
	(compare_psymbols): Ditto.
	* symtab.c (lookup_partial_symbol, lookup_block_symbol): Ditto.
@
text
@d2934 2
a2935 1
		&& ((regexp == NULL || SYMBOL_MATCHES_REGEXP (*psym))
d2972 2
a2973 1
	    if (regexp == NULL || SYMBOL_MATCHES_REGEXP (msymbol))
d3013 2
a3014 1
		  && ((regexp == NULL || SYMBOL_MATCHES_REGEXP (sym))
d3068 2
a3069 1
	    if (regexp == NULL || SYMBOL_MATCHES_REGEXP (msymbol))
@


1.95
log
@2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_NATURAL_NAME): New macro.
	(SYMBOL_LINKAGE_NAME): Ditto.
	(SYMBOL_PRINT_NAME): Use SYMBOL_NATURAL_NAME and
	SYMBOL_LINKAGE_NAME.
	(struct general_symbol_info): Expand comment.
	(DEPRECATED_SYMBOL_NAME): Rename from SYMBOL_NAME.
	(SYMBOL_MATCHES_NAME): Use DEPRECATED_SYMBOL_NAME.
	(SYMBOL_MATCHES_REGEXP): Ditto.
	* symtab.c (symbol_natural_name): New function.
	* objfiles.h: Replace all uses of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* xcoffread.c, valops.c, typeprint.c, tracepoint.c: Ditto.
	* symtab.c, symmisc.c, symfile.c, stack.c, stabsread.c: Ditto.
	* somsolib.c, sol-thread.c, rs6000-tdep.c, p-valprint.c: Ditto.
	* printcmd.c, objfiles.c, objc-lang.c, mipsread.c: Ditto.
	* minsyms.c, mdebugread.c, linespec.c, jv-lang.c: Ditto.
	* i386-tdep.c, i386-linux-tdep.c, hpread.c, hppa-tdep.c: Ditto.
	* gnu-v2-abi.c, f-valprint.c, findvar.c, expprint.c: Ditto.
	* dwarfread.c, dwarf2read.c, dbxread.c, c-valprint.c: Ditto.
	* cp-valprint.c, coffread.c, buildsym.c, breakpoint.c: Ditto.
	* blockframe.c, ax-gdb.c, arm-linux-tdep.c, ada-lang.c: Ditto.
	* ada-exp.y: Ditto.
	* ada-exp.y: Update copyright.
	* sol-thread.c, mipsread.c, jv-lang.c, f-valprint.c: Ditto.
	* cp-valprint.c: Ditto.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* generic/gdbtk.h: Replace all instances of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Ditto.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Update copyright.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: Replace all instances of SYMBOL_NAME with
	DEPRECATED_SYMBOL_NAME.  Update copyright.
@
text
@d1414 1
a1414 1
	  if (strcmp_iw_ordered (SYMBOL_PRINT_NAME (*center), name) >= 0)
d1660 1
a1660 1
	  if (SYMBOL_PRINT_NAME (sym)[0] < name[0])
d1664 1
a1664 1
	  else if (SYMBOL_PRINT_NAME (sym)[0] > name[0])
d1668 1
a1668 1
	  else if (strcmp (SYMBOL_PRINT_NAME (sym), name) < 0)
@


1.94
log
@2003-02-24  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (make_symbol_overload_list): Only read in partial
	symtabs containing a matching partial symbol.
@
text
@d578 19
d1295 1
a1295 1
	      /* This call used to pass `SYMBOL_NAME (msymbol)' as the
d1356 1
a1356 1
		   && !STREQ (name, SYMBOL_NAME (msymbol)))
d1360 1
a1360 1
	      return lookup_symbol_aux (SYMBOL_NAME (msymbol), mangled_name,
d1625 1
a1625 1
		  ? strcmp (SYMBOL_NAME (sym), mangled_name) == 0
d1695 1
a1695 1
		  ? strcmp (SYMBOL_NAME (sym), mangled_name) == 0
d1730 1
a1730 1
		  ? strcmp (SYMBOL_NAME (sym), mangled_name) == 0
d2034 1
a2034 1
	mfunsym = lookup_minimal_symbol_text (SYMBOL_NAME (msymbol), NULL, NULL);
d2045 1
a2045 1
	  /* warning ("In stub for %s; unable to find real function/line info", SYMBOL_NAME(msymbol)) */ ;
d2050 1
a2050 1
	  /* warning ("In stub for %s; unable to find real function/line info", SYMBOL_NAME(msymbol)) */ ;
d2982 1
a2982 1
			|| lookup_symbol (SYMBOL_NAME (msymbol),
d3072 1
a3072 1
		    if (lookup_symbol (SYMBOL_NAME (msymbol),
d3253 1
a3253 1
					  + strlen (SYMBOL_NAME (p->symbol))
d3257 1
a3257 1
	  strcat (string, SYMBOL_NAME (p->symbol));
d3268 1
a3268 1
	  break_command (SYMBOL_NAME (p->msymbol), from_tty);
d3294 1
a3294 1
	(SYMBOL_NAME (symbol), (sym_text), (len), (text), (word)); \
d3950 1
a3950 1
    if (!strcmp (SYMBOL_NAME (sym), SYMBOL_NAME (sym_return_val[i])))
@


1.93
log
@2003-02-24  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_partial_symbol): Use strcmp_iw_ordered to
	do the comparison, not strcmp.
	* symfile.c (compare_psymbols): Ditto.
	* defs.h: Declare strcmp_iw_ordered.
	* utils.c (strcmp_iw_ordered): New function.
@
text
@d3998 2
a3999 2
  /* Look through the partial symtabs for all symbols which begin
     by matching OLOAD_NAME.  Make sure we read that symbol table in. */
d4010 3
a4012 20
    for (psym = objfile->global_psymbols.list + ps->globals_offset;
	 psym < (objfile->global_psymbols.list + ps->globals_offset
		 + ps->n_global_syms);
	 psym++)
      {
	/* If interrupted, then quit. */
	QUIT;
        /* This will cause the symbol table to be read if it has not yet been */
        s = PSYMTAB_TO_SYMTAB (ps);
      }

    for (psym = objfile->static_psymbols.list + ps->statics_offset;
	 psym < (objfile->static_psymbols.list + ps->statics_offset
		 + ps->n_static_syms);
	 psym++)
      {
	QUIT;
        /* This will cause the symbol table to be read if it has not yet been */
        s = PSYMTAB_TO_SYMTAB (ps);
      }
@


1.92
log
@	Based on a patch from Daniel Berlin (dberlin@@dberlin.org).
	* symtab.h: Add opaque declarations of struct axs_value and
	struct agent_expr.
	(enum address_class): Add LOC_COMPUTED and LOC_COMPUTED_ARG.
	(struct location_funcs): New type.
	(struct symbol): Add "loc" to aux_value.
	(SYMBOL_LOCATION_BATON, SYMBOL_LOCATION_FUNCS): New macros.
	* dwarf2read.c: Include "dwarf2expr.h".
	(dwarf2_symbol_mark_computed): New function.
	(read_func_scope): Use it.
	(var_decode_location): New function.
	(new_symbol): Use it.
	* dwarf2expr.c, dwarf2expr.h, dwarf2loc.c, dwarf2loc.h: New files.

	* Makefile.in (SFILES): Add dwarf2loc.c and dwarf2expr.c.
	(dwarf2expr_h, dwarf2loc_h): New variables.
	(COMMON_OBS): Add dwarf2expr.o and dwarf2loc.o.
	(dwarf2expr.o, dwarf2loc.o): New rules.
	(dwarf2read.o): Add $(dwarf2expr_h) and $(dwarf2loc_h).
	* buildsym.c (finish_block): Handle LOC_COMPUTED and
	LOC_COMPUTED_ARG.
	* findvar.c (symbol_read_needs_frame, read_var_value): Likewise.
	* m2-exp.y (yylex): Likewise.
	* printcmd.c (address_info, print_frame_args): Likewise.
	* stack.c (print_block_frame_locals, print_frame_arg_vars): Likewise.
	* symmisc.c (print_symbol, print_partial_symbols): Likewise.
	* ada-lang.c (ada_resolve_subexp, symtab_for_sym)
	(ada_add_block_symbols, fill_in_ada_prototype): Likewise.
	* symtab.c (lookup_block_symbol): Likewise.
@
text
@d1377 4
a1380 3
         pointing at the earliest partial symbol with the correct
         name.  At that point *all* partial symbols with that name
         will be checked against the correct namespace. */
d1395 1
a1395 1
	  if (strcmp (SYMBOL_PRINT_NAME (*center), name) >= 0)
@


1.91
log
@* symtab.h: Remove objc_specific struct
(SYMBOL_OBJC_DEMANGLED_NAME): Remove.
* symtab.c (symbol_init_language_specific, symbol_demangled_name):
Have language_objc use cplus_specific struct.
@
text
@d1742 2
a1743 1
		  SYMBOL_CLASS (sym) != LOC_BASEREG_ARG)
@


1.90
log
@2003-02-20  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (search_symbols): Revert the search_symbols part of my
	2002-12-23 patch.  Add comment.
@
text
@d416 2
a417 1
      || gsymbol->language == language_java)
a420 4
  else if (gsymbol->language == language_objc)
    {
      gsymbol->language_specific.objc_specific.demangled_name = NULL;
    }
d584 2
a585 1
      || gsymbol->language == language_java)
a586 3

  else if (gsymbol->language == language_objc)
    return gsymbol->language_specific.objc_specific.demangled_name;
@


1.89
log
@2003-02-20  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_PRINT_NAME): Rename from SYMBOL_SOURCE_NAME;
	expand comment.
	* ada-lang.c (user_select_syms, ada_finish_decode_line_1): Replace
	SYMBOL_PRINT_NAME with SYMBOL_SOURCE_NAME.
	* ada-typeprint.c (ada_typedef_print): Ditto.
	* ax-gdb.c (gen_var_ref): Ditto.
	* breakpoint.c (print_one_breakpoint): Ditto.
	* buildsym.c (finish_block): Ditto.
	* c-valprint.c (c_val_print): Ditto.
	* expprint.c (print_subexp): Ditto.
	* findvar.c (locate_var_value): Ditto.
	* infcmd.c (jump_command): Ditto.
	* linespec.c (decode_line_2, decode_compound): Ditto.
	* maint.c (maintenance_translate_address): Ditto.
	* objc-lang.c (compare_selectors, compare_classes): Ditto.
	* printcmd.c (build_address_symbolic, sym_info, print_frame_args):
	Ditto.
	* p-valprint.c (pascal_val_print): Ditto.
	* stabsread.c (define_symbol): Ditto.
	* stack.c (print_frame, frame_info, print_block_frame_locals)
	(print_frame_arg_vars, return_command): Ditto.
	* symfile.c (compare_symbols, compare_psymbols): Ditto.
	* symmisc.c (print_symbol): Ditto.
	* symtab.c (lookup_partial_symbol, lookup_block_symbol)
	(compare_search_syms, print_symbol_info, print_msymbol_info)
	(rbreak_command): Ditto.
	* tracepoint.c (tracepoints_info): Ditto.
	* typeprint.c (typedef_print): Ditto.
	* valops.c (value_of_variable, hand_function_call): Ditto.
	* cli/cli-cmds.c (edit_command, list_command): Ditto.
	* ada-typeprint.c: Update Copyright.
	* infcmd.c, objc-lang.c, p-valprint.c, symmisc.c: Ditto.
	* tracepoint.c, cli/cli-cmds.c: Ditto.
@
text
@d2959 12
a2970 25
		    if (kind == FUNCTIONS_NAMESPACE)
		      {
			found_misc = 1;
		      }
		    else
		      {
			struct symbol *sym;

			if (SYMBOL_DEMANGLED_NAME (msymbol) != NULL)
			  sym
			    = lookup_symbol_aux_minsyms (SYMBOL_DEMANGLED_NAME
							 (msymbol),
							 SYMBOL_NAME (msymbol),
							 VAR_NAMESPACE,
							 NULL, NULL);
			else
			  sym
			    = lookup_symbol_aux_minsyms (SYMBOL_NAME (msymbol),
							 NULL,
							 VAR_NAMESPACE,
							 NULL, NULL);

			if (sym == NULL)
			  found_misc = 1;
		      }
@


1.88
log
@2003-02-19  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (SFILES): Add block.c.
	(block_h): New.
	(COMMON_OBS): Add block.o.
	(block.o): New.
	(x86-64-tdep.o): Add $(block_h).
	(values.o, valops.o, tracepoint.o, symtab.o, symmisc.o, symfile.o)
	(stack.o, printcmd.o, p-exp.tab.o, parse.o, objfiles.o)
	(objc-exp.tab.o, objc-lang.o, nlmread.o, mips-tdep.o, mdebugread.o)
	(m2-exp.tab.o, linespec.o, jv-lang.o, jv-exp.tab.o, infcmd.o)
	(f-valprint.o, findvar.o, f-exp.tab.o, expprint.o, coffread.o)
	(c-exp.tab.o, buildsym.o, breakpoint.o, blockframe.o, ax-gdb.o)
	(alpha-tdep.o, ada-lang.o, ada-exp.tab.o, mi-cmd-stack.o): Ditto.
	* value.h: Add opaque declaration for struct block.
	* parser-defs.h, objc-lang.h, buildsym.h, breakpoint.h: Ditto.
	* ada-lang.h: Ditto.
	* x86-64-tdep.c: #include "block.h"
	* values.c, valops.c, tracepoint.c, symtab.c, symmisc.c: Ditto.
	* symfile.c, stack.c, printcmd.c, p-exp.y, parse.c: Ditto.
	* objfiles.c, objc-exp.y, objc-lang.c, nlmread.c: Ditto.
	* mips-tdep.c, mdebugread.c, m2-exp.y, linespec.c: Ditto.
	* jv-lang.c, jv-exp.y, infcmd.c, f-valprint.c: Ditto.
	* findvar.c, f-exp.y, expprint.c, coffread.c, c-exp.y: Ditto.
	* buildsym.c, breakpoint.c, blockframe.c, ax-gdb.c: Ditto.
	* alpha-tdep.c, ada-lang.c, ada-exp.y: Ditto.
	* blockframe.c (blockvector_for_pc_sect): Move to "block.c".
	(blockvector_for_pc, block_for_pc_sect, block_for_pc): Ditto.
	* symtab.c (block_function): Ditto.
	(contained_in): Ditto.
	* frame.h: Move block_for_pc and block_for_pc_sect declarations to
	block.h.  Add opaque declaration for struct block.
	* symtab.h: Move block_function and contained_in declarations to
	block.h.  Add opaque declarations for struct block, struct
	blockvector.
	(struct block): Move to block.h.
	(struct blockvector): Ditto.
	(BLOCK_START, BLOCK_END, BLOCK_FUNCTION, BLOCK_SUPERBLOCK)
	(BLOCK_GCC_COMPILED, BLOCK_HASHTABLE, BLOCK_NSYMS, BLOCK_SYM)
	(BLOCK_BUCKETS, BLOCK_BUCKET, BLOCK_HASHTABLE_SIZE)
	(ALL_BLOCK_SYMBOLS, BLOCK_SHOULD_SORT, BLOCKVECTOR_NBLOCKS)
	(BLOCKVECTOR_BLOCK, GLOBAL_BLOCK, STATIC_BLOCK, FIRST_LOCAL_BLOCK):
	Ditto.
	* block.c: New file.
	* block.h: New file.

2003-02-19  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: #include "block.h"
@
text
@d1399 1
a1399 1
	  if (strcmp (SYMBOL_SOURCE_NAME (*center), name) >= 0)
d1645 1
a1645 1
	  if (SYMBOL_SOURCE_NAME (sym)[0] < name[0])
d1649 1
a1649 1
	  else if (SYMBOL_SOURCE_NAME (sym)[0] > name[0])
d1653 1
a1653 1
	  else if (strcmp (SYMBOL_SOURCE_NAME (sym), name) < 0)
d1685 1
a1685 1
          if (SYMBOL_SOURCE_NAME (sym)[0] > name[0])
d2740 2
a2741 2
  return strcmp (SYMBOL_SOURCE_NAME ((*sym_a)->symbol),
		 SYMBOL_SOURCE_NAME ((*sym_b)->symbol));
d3129 1
a3129 1
		   ? "" : SYMBOL_SOURCE_NAME (sym)),
d3152 1
a3152 1
		   tmp, SYMBOL_SOURCE_NAME (msymbol));
d3267 1
a3267 1
			   SYMBOL_SOURCE_NAME (p->msymbol));
@


1.87
log
@	* defs.h (streq): Add prototype.
	* utils.c (streq): New function.

	* dwarf2read.c (new_symbol): Use SYMBOL_SET_NAMES instead of
	SYMBOL_NAME and SYMBOL_INIT_DEMANGLED_NAME.
	* mdebugread.c (new_symbol): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* coffread.c (process_coff_symbol): Likewise.
	* dwarfread.c (new_symbol): Likewise.

	* minsyms.c (prim_record_minimal_symbol_and_info): Use
	SYMBOL_SET_NAMES instead of setting SYMBOL_NAME.  Set the language
	here.
	(install_minimal_symbols): Don't set SYMBOL_LANGUAGE or call
	SYMBOL_INIT_DEMANGLED_NAME.
	* objfiles.c: Include "hashtab.h".
	(allocate_objfile): Call htab_set_functions_ex for the
	demangled_names_hash.
	(free_objfile): Call htab_delete for the demangled_names_hash.
	* objfiles.h (struct htab): Add declaration.
	(struct objfile): Add demangled_names_hash.
	* symfile.c: Include "hashtab.h".
	(reread_symbols): Call htab_delete for the demangled_names_hash.
	(add_psymbol_to_list): Use SYMBOL_SET_NAMES instead of putting
	SYMBOL_NAME in the bcache.
	* symtab.c: Include "hashtab.h".  Update comments.
	(create_demangled_names_hash, symbol_set_names): New functions.
	(symbol_find_demangled_name): New function, broken out from
	symbol_init_demangled_names.
	(symbol_init_demangled_names): Use it.
	* symtab.h (SYMBOL_INIT_DEMANGLED_NAME): Add missing parentheses.
	(SYMBOL_SET_NAMES): New macro.
	(symbol_set_names): Add prototype.
@
text
@d47 1
a1789 12
/* Return the symbol for the function which contains a specified
   lexical block, described by a struct block BL.  */

struct symbol *
block_function (struct block *bl)
{
  while (BLOCK_FUNCTION (bl) == 0 && BLOCK_SUPERBLOCK (bl) != 0)
    bl = BLOCK_SUPERBLOCK (bl);

  return BLOCK_FUNCTION (bl);
}

a3271 13
}


/* Return Nonzero if block a is lexically nested within block b,
   or if a and b have the same pc range.
   Return zero otherwise. */
int
contained_in (struct block *a, struct block *b)
{
  if (!a || !b)
    return 0;
  return BLOCK_START (a) >= BLOCK_START (b)
    && BLOCK_END (a) <= BLOCK_END (b);
@


1.86
log
@2003-02-01  Andrew Cagney  <ac131313@@redhat.com>

	* main.c (captured_main): Delete #ifdef ADDITIONAL_OPTIONS,
	ADDITIONAL_OPTION_CASES, and ADDITIONAL_OPTION_HANDLER code.
	(print_gdb_help): Delete #ifdef ADDITIONAL_OPTION_HELP code.
	* stabsread.c (DBX_PARM_SYMBOL_CLASS): Delete macro.
	(define_symbol): Update.
	* symfile.c (generic_load): Remove references to nindy.
	* symtab.c: Remove references to nindy.

Index: doc/ChangeLog
2003-02-01  Andrew Cagney  <ac131313@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	description of ADDITIONAL_OPTIONS, ADDITIONAL_OPTION_CASES,
	ADDITIONAL_OPTION_HANDLER, and ADDITIONAL_OPTION_HELP, and
	BEFORE_MAIN_LOOP_HOOK, and DBX_PARM_SYMBOL_CLASS along with
	references to nindy and i960.
	* gdb.texinfo (i960): Delete all references to i960 and nindy.
@
text
@d44 2
d430 18
a447 1
/* Initialize a symbol's mangled name.  */
d449 1
a449 1
/* Try to initialize the demangled name for a symbol, based on the
d452 2
a453 5
   then set the language appropriately.  If no demangling of any kind
   is found, the language is set back to language_unknown, so we can
   avoid doing this work again the next time we encounter the symbol.
   Any required space to store the name is obtained from the specified
   obstack. */
d455 3
a457 3
void
symbol_init_demangled_name (struct general_symbol_info *gsymbol,
                            struct obstack *obstack)
a458 1
  char *mangled = gsymbol->name;
d467 1
a467 1
        cplus_demangle (gsymbol->name, DMGL_PARAMS | DMGL_ANSI);
d469 4
a472 10
        {
          gsymbol->language = language_cplus;
          gsymbol->language_specific.cplus_specific.demangled_name =
            obsavestring (demangled, strlen (demangled), obstack);
          xfree (demangled);
        }
      else
        {
          gsymbol->language_specific.cplus_specific.demangled_name = NULL;
        }
d477 1
a477 1
        cplus_demangle (gsymbol->name,
d480 55
a534 6
        {
          gsymbol->language = language_java;
          gsymbol->language_specific.cplus_specific.demangled_name =
            obsavestring (demangled, strlen (demangled), obstack);
          xfree (demangled);
        }
d536 41
a576 3
        {
          gsymbol->language_specific.cplus_specific.demangled_name = NULL;
        }
@


1.85
log
@	* symtab.c (find_pc_sect_line): Don't consider end-of-function
	lines.
@
text
@d719 5
a723 5
   out of here: find_proc_desc in alpha-tdep.c and mips-tdep.c, and
   nindy_frame_chain_valid in nindy-tdep.c.  (Note that there is C++
   code below which can error(), but that probably doesn't affect
   these calls since they are looking for a known variable and thus
   can probably assume it will never hit the C++ code).  */
@


1.84
log
@2003-01-02  Andrew Cagney  <ac131313@@redhat.com>

	* valarith.c (value_binop): Delete obsolete code and comments.
	* configure.host: Ditto.
	* buildsym.h (make_blockvector): Ditto.
	* buildsym.c (make_blockvector): Ditto.
	* defs.h (enum language): Ditto.
	(chill_demangle): Ditto.
	* elfread.c (elf_symtab_read): Ditto.
	* dwarfread.c (CHILL_PRODUCER): Ditto.
	(set_cu_language): Ditto.
	(handle_producer): Ditto.
	* expprint.c (print_subexp): Ditto.
	* gdbtypes.c (chill_varying_type): Ditto.
	* gdbtypes.h (builtin_type_chill_bool): Ditto.
	(builtin_type_chill_char, builtin_type_chill_long): Ditto.
	(builtin_type_chill_ulong, builtin_type_chill_real): Ditto.
	(chill_varying_type): Ditto.
	* language.h (_LANG_chill): Ditto.
	* language.c (binop_result_type, integral_type): Ditto.
	(character_type, string_type, structured_type): Ditto.
	(lang_bool_type, binop_type_check): Ditto.
	* stabsread.h (os9k_stabs): Ditto.
	* stabsread.c (os9k_type_vector, dbx_lookup_type): Ditto.
	(define_symbol, read_type, read_struct_fields): Ditto.
	(read_array_type, read_enum_type, read_huge_number): Ditto.
	(read_range_type, start_stabs): Ditto.
	* symfile.c (init_filename_language_table): Ditto.
	(add_psymbol_with_dem_name_to_list): Ditto.
	* symtab.c (symbol_init_language_specific): Ditto.
	(symbol_init_demangled_name, symbol_demangled_name): Ditto.
	* symtab.h (struct general_symbol_info): Ditto.
	(SYMBOL_CHILL_DEMANGLED_NAME): Ditto.
	* typeprint.c (typedef_print): Ditto.
	* utils.c (fprintf_symbol_filtered): Ditto.
	* valops.c (value_cast, search_struct_field, value_slice): Delete
	obsolete code.
	(varying_to_slice): Delete function.
	* value.h (COERCE_VARYING_ARRAY): Delete obsolete macro contents.
	(varying_to_slice): Delete declaration.
	* MAINTAINERS: Update.
@
text
@d4 2
a5 2
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002 Free Software
   Foundation, Inc.
d2015 3
a2017 1
         If so, record this file, and its best line, as best so far.  */
d2019 1
a2019 1
      if (prev && (!best || prev->pc > best->pc))
@


1.83
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux): Delete 'force_return' variable.
	(lookup_symbol_aux_minsyms): Delete 'force_return' argument.
	(search_symbols): Call lookup_symbol_aux_minsyms to find debugging
	information associated to a minsym, not lookup_symbol.
@
text
@a420 4
  /* OBSOLETE else if (SYMBOL_LANGUAGE (symbol) == language_chill) */
  /* OBSOLETE   { */
  /* OBSOLETE     SYMBOL_CHILL_DEMANGLED_NAME (symbol) = NULL; */
  /* OBSOLETE   } */
a481 20
#if 0
  /* OBSOLETE if (demangled == NULL */
  /* OBSOLETE     && (gsymbol->language == language_chill */
  /* OBSOLETE         || gsymbol->language == language_auto)) */
  /* OBSOLETE   { */
  /* OBSOLETE     demangled = */
  /* OBSOLETE       chill_demangle (gsymbol->name); */
  /* OBSOLETE     if (demangled != NULL) */
  /* OBSOLETE       { */
  /* OBSOLETE         gsymbol->language = language_chill; */
  /* OBSOLETE         gsymbol->language_specific.chill_specific.demangled_name = */
  /* OBSOLETE           obsavestring (demangled, strlen (demangled), obstack); */
  /* OBSOLETE         xfree (demangled); */
  /* OBSOLETE       } */
  /* OBSOLETE     else */
  /* OBSOLETE       { */
  /* OBSOLETE         gsymbol->language_specific.chill_specific.demangled_name = NULL; */
  /* OBSOLETE       } */
  /* OBSOLETE   } */
#endif
a497 3

  /* OBSOLETE (SYMBOL_LANGUAGE (symbol) == language_chill */
  /* OBSOLETE ? SYMBOL_CHILL_DEMANGLED_NAME (symbol) */
@


1.82
log
@2002-12-17  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_partial_symbol): Don't search past the end of
	the partial symbols.
@
text
@d120 1
a120 2
					  struct symtab **symtab,
					  int *force_return);
a806 8
  /* FIXME: carlton/2002-11-05: This variable is here so that
     lookup_symbol_aux will sometimes return NULL after receiving a
     NULL return value from lookup_symbol_aux_minsyms, without
     proceeding on to the partial symtab and static variable tests.  I
     suspect that that's a bad idea.  */
  
  int force_return;

a924 2
  force_return = 0;

d927 1
a927 1
				   symtab, &force_return);
d929 1
a929 1
  if (sym != NULL || force_return == 1)
a972 2
  force_return = 0;

d975 1
a975 1
				   symtab, &force_return);
d977 1
a977 1
  if (sym != NULL || force_return == 1)
d1162 8
d1175 1
a1175 2
			   struct symtab **symtab,
			   int *force_return)
a1267 1
	      *force_return = 1;
a1275 1
	      *force_return = 1;
d2899 25
a2923 6
		    if (kind == FUNCTIONS_NAMESPACE
			|| lookup_symbol (SYMBOL_NAME (msymbol),
					  (struct block *) NULL,
					  VAR_NAMESPACE,
					0, (struct symtab **) NULL) == NULL)
		      found_misc = 1;
@


1.81
log
@2002-12-05  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_local): Add 'static_block'
	argument.
	(lookup_symbol_aux): Do the 'field_of_this' check before checking
	the static block.  See PR gdb/804.
@
text
@d1303 1
a1303 1
  struct partial_symbol **top, **bottom, **center;
d1326 1
d1352 1
a1352 1
      while (SYMBOL_MATCHES_NAME (*top,name))
@


1.80
log
@2002-12-05  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Move code into lookup_symbol_aux_block.
@
text
@d86 7
a92 5
static struct symbol *lookup_symbol_aux_local (const char *name,
					       const char *mangled_name,
					       const struct block *block,
					       const namespace_enum namespace,
					       struct symtab **symtab);
d806 1
d816 2
a817 1
  /* Search specified block and its superiors.  */
d820 1
a820 1
				 symtab);
d886 32
d1000 3
a1002 2
/* Check to see if the symbol is defined in BLOCK or its
   superiors.  */
d1008 2
a1009 1
			 struct symtab **symtab)
d1013 9
a1021 1
  while (block != 0)
d1030 3
@


1.79
log
@2002-12-04  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux): Move minsym code into a separate
	function.
	(lookup_symbol_aux_minsyms): New function.
@
text
@d93 7
d974 23
d1001 3
a1003 2
  
  while (block != 0)
d1005 2
a1006 2
      sym = lookup_block_symbol (block, name, mangled_name, namespace);
      if (sym)
d1008 3
a1010 2
	  block_found = block;
	  if (symtab != NULL)
d1012 5
a1016 12
	      /* Search the list of symtabs for one which contains the
	         address of the start of this block.  */
	      ALL_SYMTABS (objfile, s)
	      {
		bv = BLOCKVECTOR (s);
		b = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
		if (BLOCK_START (b) <= BLOCK_START (block)
		    && BLOCK_END (b) > BLOCK_START (block))
		  goto found;
	      }
	    found:
	      *symtab = s;
d1018 2
a1019 2

	  return fixup_symbol_section (sym, objfile);
d1021 2
a1022 1
      block = BLOCK_SUPERBLOCK (block);
@


1.78
log
@2002-11-06  Elena Zannoni  <ezannoni@@redhat.com>

	* symtab.c (methods_info): Delete. It has been ifdeffed out for
	ages.
	(symtab_symbol_info): Remove eons old ifdeffed out code.
	(_initialize_symtab): Remove prehistoric disabled 'info methods'
	command.
@
text
@d106 8
d797 8
a804 3
  struct symtab *s = NULL;
  struct blockvector *bv;
  struct minimal_symbol *msymbol;
d891 1
a891 12
  if (namespace == VAR_NAMESPACE)
    {
      msymbol = lookup_minimal_symbol (name, NULL, NULL);
      if (msymbol != NULL)
	{
	  s = find_pc_sect_symtab (SYMBOL_VALUE_ADDRESS (msymbol),
				   SYMBOL_BFD_SECTION (msymbol));
	  if (s != NULL)
	    {
	      /* This is a function which has a symtab for its address.  */
	      bv = BLOCKVECTOR (s);
	      block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
d893 6
a898 46
              /* This call used to pass `SYMBOL_NAME (msymbol)' as the
                 `name' argument to lookup_block_symbol.  But the name
                 of a minimal symbol is always mangled, so that seems
                 to be clearly the wrong thing to pass as the
                 unmangled name.  */
	      sym = lookup_block_symbol (block, name, mangled_name, namespace);
	      /* We kept static functions in minimal symbol table as well as
	         in static scope. We want to find them in the symbol table. */
	      if (!sym)
		{
		  block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
		  sym = lookup_block_symbol (block, name,
                                             mangled_name, namespace);
		}

	      /* sym == 0 if symbol was found in the minimal symbol table
	         but not in the symtab.
	         Return 0 to use the msymbol definition of "foo_".

	         This happens for Fortran  "foo_" symbols,
	         which are "foo" in the symtab.

	         This can also happen if "asm" is used to make a
	         regular symbol but not a debugging symbol, e.g.
	         asm(".globl _main");
	         asm("_main:");
	       */

	      if (symtab != NULL)
		*symtab = s;
	      return fixup_symbol_section (sym, s->objfile);
	    }
	  else if (MSYMBOL_TYPE (msymbol) != mst_text
		   && MSYMBOL_TYPE (msymbol) != mst_file_text
		   && !STREQ (name, SYMBOL_NAME (msymbol)))
	    {
	      /* This is a mangled variable, look it up by its
	         mangled name.  */
	      return lookup_symbol_aux (SYMBOL_NAME (msymbol), mangled_name, NULL,
					namespace, is_a_field_of_this, symtab);
	    }
	  /* There are no debug symbols for this file, or we are looking
	     for an unmangled variable.
	     Try to find a matching static symbol below. */
	}
    }
a939 47
  if (namespace == VAR_NAMESPACE)
    {
      msymbol = lookup_minimal_symbol (name, NULL, NULL);
      if (msymbol != NULL)
	{
	  /* OK, we found a minimal symbol in spite of not
	   * finding any symbol. There are various possible
	   * explanations for this. One possibility is the symbol
	   * exists in code not compiled -g. Another possibility
	   * is that the 'psymtab' isn't doing its job.
	   * A third possibility, related to #2, is that we were confused 
	   * by name-mangling. For instance, maybe the psymtab isn't
	   * doing its job because it only know about demangled
	   * names, but we were given a mangled name...
	   */

	  /* We first use the address in the msymbol to try to
	   * locate the appropriate symtab. Note that find_pc_symtab()
	   * has a side-effect of doing psymtab-to-symtab expansion,
	   * for the found symtab.
	   */
	  s = find_pc_symtab (SYMBOL_VALUE_ADDRESS (msymbol));
	  if (s != NULL)
	    {
	      bv = BLOCKVECTOR (s);
	      block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
              /* This call used to pass `SYMBOL_NAME (msymbol)' as the
                 `name' argument to lookup_block_symbol.  But the name
                 of a minimal symbol is always mangled, so that seems
                 to be clearly the wrong thing to pass as the
                 unmangled name.  */
	      sym = lookup_block_symbol (block, name, mangled_name, namespace);
	      /* We kept static functions in minimal symbol table as well as
	         in static scope. We want to find them in the symbol table. */
	      if (!sym)
		{
		  block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
		  sym = lookup_block_symbol (block, name,
                                             mangled_name, namespace);
		}
	      /* If we found one, return it */
	      if (sym)
		{
		  if (symtab != NULL)
		    *symtab = s;
		  return sym;
		}
d941 1
a941 8
	      /* If we get here with sym == 0, the symbol was 
	         found in the minimal symbol table
	         but not in the symtab.
	         Fall through and return 0 to use the msymbol 
	         definition of "foo_".
	         (Note that outer code generally follows up a call
	         to this routine with a call to lookup_minimal_symbol(),
	         so a 0 return means we'll just flow into that other routine).
d943 6
a948 24
	         This happens for Fortran  "foo_" symbols,
	         which are "foo" in the symtab.

	         This can also happen if "asm" is used to make a
	         regular symbol but not a debugging symbol, e.g.
	         asm(".globl _main");
	         asm("_main:");
	       */
	    }

	  /* If the lookup-by-address fails, try repeating the
	   * entire lookup process with the symbol name from
	   * the msymbol (if different from the original symbol name).
	   */
	  else if (MSYMBOL_TYPE (msymbol) != mst_text
		   && MSYMBOL_TYPE (msymbol) != mst_file_text
		   && !STREQ (name, SYMBOL_NAME (msymbol)))
	    {
	      return lookup_symbol_aux (SYMBOL_NAME (msymbol), mangled_name,
					NULL, namespace, is_a_field_of_this,
					symtab);
	    }
	}
    }
d1091 124
@


1.77
log
@2002-11-05  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux): Move chunks of code into separate
	functions.
	(lookup_symbol_aux_local): New function.
	(lookup_symbol_aux_symtabs): New function.
	(lookup_symbol_aux_psymtabs): New function.
@
text
@a2972 24
  else
    {
#if 0
      /* Tiemann says: "info methods was never implemented."  */
      char *demangled_name;
      c_type_print_base (TYPE_FN_FIELD_TYPE (t, block),
			 gdb_stdout, 0, 0);
      c_type_print_varspec_prefix (TYPE_FN_FIELD_TYPE (t, block),
				   gdb_stdout, 0);
      if (TYPE_FN_FIELD_STUB (t, block))
	check_stub_method (TYPE_DOMAIN_TYPE (type), j, block);
      demangled_name =
	cplus_demangle (TYPE_FN_FIELD_PHYSNAME (t, block),
			DMGL_ANSI | DMGL_PARAMS);
      if (demangled_name == NULL)
	fprintf_filtered (stream, "<badly mangled name %s>",
			  TYPE_FN_FIELD_PHYSNAME (t, block));
      else
	{
	  fputs_filtered (demangled_name, stream);
	  xfree (demangled_name);
	}
#endif
    }
a3065 9
#if 0
/* Tiemann says: "info methods was never implemented."  */
static void
methods_info (char *regexp)
{
  symtab_symbol_info (regexp, METHODS_NAMESPACE, 0, from_tty);
}
#endif /* 0 */

a4024 7
#if 0
  add_info ("methods", methods_info,
	    "All method names, or those matching REGEXP::REGEXP.\n\
If the class qualifier is omitted, it is assumed to be the current scope.\n\
If the first REGEXP is omitted, then all methods matching the second REGEXP\n\
are listed.");
#endif
@


1.76
log
@2002-11-05  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux): In minsym sections, don't use the
	previous values of 'objfile' and 'block'.
@
text
@d86 19
d788 4
a791 8
  register struct symbol *sym;
  register struct symtab *s = NULL;
  register struct partial_symtab *ps;
  register struct blockvector *bv;
  register struct objfile *objfile = NULL;
  register struct block *b;
  register struct minimal_symbol *msymbol;

d795 4
a798 21
  while (block != 0)
    {
      sym = lookup_block_symbol (block, name, mangled_name, namespace);
      if (sym)
	{
	  block_found = block;
	  if (symtab != NULL)
	    {
	      /* Search the list of symtabs for one which contains the
	         address of the start of this block.  */
	      ALL_SYMTABS (objfile, s)
	      {
		bv = BLOCKVECTOR (s);
		b = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
		if (BLOCK_START (b) <= BLOCK_START (block)
		    && BLOCK_END (b) > BLOCK_START (block))
		  goto found;
	      }
	    found:
	      *symtab = s;
	    }
d800 4
a803 4
	  return fixup_symbol_section (sym, objfile);
	}
      block = BLOCK_SUPERBLOCK (block);
    }
d844 1
a844 1

d867 4
a870 13
  ALL_SYMTABS (objfile, s)
  {
    bv = BLOCKVECTOR (s);
    block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
    sym = lookup_block_symbol (block, name, mangled_name, namespace);
    if (sym)
      {
	block_found = block;
	if (symtab != NULL)
	  *symtab = s;
	return fixup_symbol_section (sym, objfile);
      }
  }
d940 4
a943 28
  ALL_PSYMTABS (objfile, ps)
  {
    if (!ps->readin && lookup_partial_symbol (ps, name, 1, namespace))
      {
	s = PSYMTAB_TO_SYMTAB (ps);
	bv = BLOCKVECTOR (s);
	block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
	sym = lookup_block_symbol (block, name, mangled_name, namespace);
	if (!sym)
	  {
	    /* This shouldn't be necessary, but as a last resort
	     * try looking in the statics even though the psymtab
	     * claimed the symbol was global. It's possible that
	     * the psymtab gets it wrong in some cases.
	     */
	    block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
	    sym = lookup_block_symbol (block, name, mangled_name, namespace);
	    if (!sym)
	      error ("Internal: global symbol `%s' found in %s psymtab but not in symtab.\n\
%s may be an inlined function, or may be a template function\n\
(if a template, try specifying an instantiation: %s<type>).",
		     name, ps->filename, name, name);
	  }
	if (symtab != NULL)
	  *symtab = s;
	return fixup_symbol_section (sym, objfile);
      }
  }
d945 4
a948 5
  /* Now search all static file-level symbols.
     Not strictly correct, but more useful than an error.
     Do the symtabs first, then check the psymtabs.
     If a psymtab indicates the existence
     of the desired name as a file-level static, then do psymtab-to-symtab
d951 9
a959 42
  ALL_SYMTABS (objfile, s)
  {
    bv = BLOCKVECTOR (s);
    block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
    sym = lookup_block_symbol (block, name, mangled_name, namespace);
    if (sym)
      {
	block_found = block;
	if (symtab != NULL)
	  *symtab = s;
	return fixup_symbol_section (sym, objfile);
      }
  }

  ALL_PSYMTABS (objfile, ps)
  {
    if (!ps->readin && lookup_partial_symbol (ps, name, 0, namespace))
      {
	s = PSYMTAB_TO_SYMTAB (ps);
	bv = BLOCKVECTOR (s);
	block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
	sym = lookup_block_symbol (block, name, mangled_name, namespace);
	if (!sym)
	  {
	    /* This shouldn't be necessary, but as a last resort
	     * try looking in the globals even though the psymtab
	     * claimed the symbol was static. It's possible that
	     * the psymtab gets it wrong in some cases.
	     */
	    block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
	    sym = lookup_block_symbol (block, name, mangled_name, namespace);
	    if (!sym)
	      error ("Internal: static symbol `%s' found in %s psymtab but not in symtab.\n\
%s may be an inlined function, or may be a template function\n\
(if a template, try specifying an instantiation: %s<type>).",
		     name, ps->filename, name, name);
	  }
	if (symtab != NULL)
	  *symtab = s;
	return fixup_symbol_section (sym, objfile);
      }
  }
d1064 1
a1064 1
  return 0;
d1066 139
a1204 1
								
@


1.75
log
@2002-10-28  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (find_addr_symbol): Delete.  (It was already commented
	out.)
	* symtab.h: Delete prototype for find_addr_symbol.
@
text
@d932 1
a932 1
	      return fixup_symbol_section (sym, objfile);
d940 1
a940 1
	      return lookup_symbol_aux (SYMBOL_NAME (msymbol), mangled_name, block,
d1123 1
a1123 1
					block, namespace, is_a_field_of_this,
@


1.74
log
@2002-10-24  Elena Zannoni  <ezannoni@@redhat.com>

	* symtab.h (INIT_SAL): Delete macro.
	(init_sal): Export.
	* symtab.c (init_sal): New function.

	* ada-lang.c (ada_finish_decode_line_1): Change INIT_SAL macro
	to init_sal function call.
	(find_sal_from_funcs_and_line): Ditto.
	(all_sals_for_line): Ditto.
	* breakpoint.c (create_internal_breakpoint): Ditto.
	(create_fork_vfork_event_catchpoint): Ditto.
	(create_exec_event_catchpoint): Ditto.
	(parse_breakpoint_sals): Ditto.
	(watch_command_1): Ditto.
	(handle_gnu_4_16_catch_command): Ditto.
	(clear_command): Ditto.
	* hppa-tdep.c (child_enable_exception_callback): Ditto.
	* infcmd.c (run_stack_dummy): Ditto.
	* infrun.c (process_event_stop_test): Ditto.
	(check_sigtramp2): Ditto.
	(step_over_function): Ditto.
	* linespec.c (decode_line_2): Ditto.
	(decode_line_1): Ditto.
	* source.c (line_info): Ditto.
	* symtab.c (find_pc_sect_line): Ditto.
@
text
@a1694 88
#if 0

/* Find the closest symbol value (of any sort -- function or variable)
   for a given address value.  Slow but complete.  (currently unused,
   mainly because it is too slow.  We could fix it if each symtab and
   psymtab had contained in it the addresses ranges of each of its
   sections, which also would be required to make things like "info
   line *0x2345" cause psymtabs to be converted to symtabs).  */

struct symbol *
find_addr_symbol (CORE_ADDR addr, struct symtab **symtabp, CORE_ADDR *symaddrp)
{
  struct symtab *symtab, *best_symtab;
  struct objfile *objfile;
  register int bot, top;
  register struct symbol *sym;
  register CORE_ADDR sym_addr;
  struct block *block;
  int blocknum;

  /* Info on best symbol seen so far */

  register CORE_ADDR best_sym_addr = 0;
  struct symbol *best_sym = 0;

  /* FIXME -- we should pull in all the psymtabs, too!  */
  ALL_SYMTABS (objfile, symtab)
  {
    /* Search the global and static blocks in this symtab for
       the closest symbol-address to the desired address.  */

    for (blocknum = GLOBAL_BLOCK; blocknum <= STATIC_BLOCK; blocknum++)
      {
	QUIT;
	block = BLOCKVECTOR_BLOCK (BLOCKVECTOR (symtab), blocknum);
	ALL_BLOCK_SYMBOLS (block, bot, sym)
	  {
	    switch (SYMBOL_CLASS (sym))
	      {
	      case LOC_STATIC:
	      case LOC_LABEL:
		sym_addr = SYMBOL_VALUE_ADDRESS (sym);
		break;

	      case LOC_INDIRECT:
		sym_addr = SYMBOL_VALUE_ADDRESS (sym);
		/* An indirect symbol really lives at *sym_addr,
		 * so an indirection needs to be done.
		 * However, I am leaving this commented out because it's
		 * expensive, and it's possible that symbolization
		 * could be done without an active process (in
		 * case this read_memory will fail). RT
		 sym_addr = read_memory_unsigned_integer
		 (sym_addr, TARGET_PTR_BIT / TARGET_CHAR_BIT);
		 */
		break;

	      case LOC_BLOCK:
		sym_addr = BLOCK_START (SYMBOL_BLOCK_VALUE (sym));
		break;

	      default:
		continue;
	      }

	    if (sym_addr <= addr)
	      if (sym_addr > best_sym_addr)
		{
		  /* Quit if we found an exact match.  */
		  best_sym = sym;
		  best_sym_addr = sym_addr;
		  best_symtab = symtab;
		  if (sym_addr == addr)
		    goto done;
		}
	  }
      }
  }

done:
  if (symtabp)
    *symtabp = best_symtab;
  if (symaddrp)
    *symaddrp = best_sym_addr;
  return best_sym;
}
#endif /* 0 */

@


1.73
log
@2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
@
text
@d491 11
d1837 1
a1837 1
  INIT_SAL (&val);		/* initialize to zeroes */
@


1.72
log
@2002-10-23  Elena Zannoni  <ezannoni@@redhat.com>

	* symtab.c (symbol_demangled_name): New function.
	* symtab.h (SYMBOL_DEMANGLED_NAME): Simplify macro, by
	turning most of it into a function.
	(symbol_demangled_name): Export.
@
text
@a52 5
/* Prototype for one function in parser-defs.h,
   instead of including that entire file. */

extern char *find_template_name_end (char *);

a117 13

/* While the C++ support is still in flux, issue a possibly helpful hint on
   using the new command completion feature on single quoted demangled C++
   symbols.  Remove when loose ends are cleaned up.   FIXME -fnf */

static void
cplusplus_hint (char *name)
{
  while (*name == '\'')
    name++;
  printf_filtered ("Hint: try '%s<TAB> or '%s<ESC-?>\n", name, name);
  printf_filtered ("(Note leading single quote.)\n");
}
@


1.71
log
@2002-10-23  Elena Zannoni  <ezannoni@@redhat.com>

	* symtab.c (symbol_init_language_specific): New function.
	* symtab.h (SYMBOL_INIT_LANGUAGE_SPECIFIC): Simplify macro, by
	turning most of it into a function.
	(symbol_init_language_specific): Export.
@
text
@d491 8
d500 9
@


1.70
log
@        * source.c: Make global variables current_source_symtab and
        current_source_line static.
        (list_command): Moved to cli/cli-cmds.c.
        (ambiguous_line_spec): Moved to cli/cli-cmds.c.
        (get_first_line_listed): New accessor function.
        (get_lines_to_list): New accessor function.
        (get_current_source_symtab_and_line): New function. Retrieves the
        position in the source code that we consider current.
        (get_current_or_default_source_symtab_and_line): New function.
        Like the above but attempts to determine a default position if one
        is not currently defined.
        (set_current_source_symtab_and_line): New function. Sets the source
        code position considered current and returns the previously set one.
        (clear_current_source_symtab_and_line): Reset stored information about
        a current source line.
        (_initialize_source): Remove registration for the "list" command and
        its alias.
        * source.h: Add declarations for the new functions above.
        * symtab.h: Remove declarations for the global variables mentioned
        above.
        * breakpoint.c (parse_breakpoint_sals): Use accessor functions to
        obtain current source line.
        * linespec.c (decode_line_1): Ditto.
        * macroscope.c (default_macro_scope): Ditto.
        * scm-lang.c (scm_unpac): Ditto.
        * stack.c (print_frame_info_base): Ditto.
        * symfile.c (clear_symtab_users): Ditto.
        * symtab.c (decode_line_spec): Ditto.
        * cli/cli-cmds.c (list_command): Moved here from source.c.
        (ambiguous_line_spec): Moved here from source.c.
        (_init_cli_cmds): Add definition for "list" and its alias.
        * Makefile.in: Update dependencies.
@
text
@d388 27
@


1.70.4.1
log
@2002-10-11  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux): Move chunks of code into separate
	functions.
	(lookup_symbol_aux_local): New function.
	(lookup_symbol_aux_symtabs): New function.
	(lookup_symbol_aux_psymtabs): New function.
	(lookup_symbol_aux_minsyms): New function.
@
text
@a90 26
static struct symbol *lookup_symbol_aux_local (const char *name,
					       const char *mangled_name,
					       const struct block *block,
					       const namespace_enum namespace,
					       struct symtab **symtab);

static
struct symbol *lookup_symbol_aux_symtabs (int block_index,
					  const char *name,
					  const char *mangled_name,
					  const namespace_enum namespace,
					  struct symtab **symtab);

static
struct symbol *lookup_symbol_aux_psymtabs (int block_index,
					   const char *name,
					   const char *mangled_name,
					   const namespace_enum namespace,
					   struct symtab **symtab);
static
struct symbol *lookup_symbol_aux_minsyms (const char *name,
					  const char *mangled_name,
					  const namespace_enum namespace,
					  int *is_a_field_of_this,
					  struct symtab **symtab);

d732 8
a739 1
  struct symbol *sym;
d743 67
a809 4
  sym = lookup_symbol_aux_local (name, mangled_name, block, namespace,
				 symtab);
  if (sym != NULL)
    return sym;
d832 13
a844 9
  sym = lookup_symbol_aux_symtabs (GLOBAL_BLOCK, name, mangled_name,
				   namespace, symtab);
  if (sym != NULL)
    return sym;

  sym = lookup_symbol_aux_psymtabs (GLOBAL_BLOCK, name, mangled_name,
				    namespace, symtab);
  if (sym != NULL)
    return sym;
d848 3
a850 10
  /* Check for the possibility of the symbol being a function or a
     mangled variable that is stored in one of the minimal symbol
     tables.  Eventually, all global symbols might be resolved in this
     way.  */

  sym = lookup_symbol_aux_minsyms (name, mangled_name,
				   namespace, is_a_field_of_this,
				   symtab);
  if (sym != NULL)
    return sym;
d852 12
a863 1
#endif
d865 14
a878 5
  /* Now search all static file-level symbols.  Not strictly correct,
     but more useful than an error.  Do the symtabs first, then check
     the psymtabs.  If a psymtab indicates the existence of the
     desired name as a file-level static, then do psymtab-to-symtab
     conversion on the fly and return the found symbol. */
d880 3
a882 9
  sym = lookup_symbol_aux_symtabs (STATIC_BLOCK, name, mangled_name,
				   namespace, symtab);
  if (sym != NULL)
    return sym;
  
  sym = lookup_symbol_aux_psymtabs (STATIC_BLOCK, name, mangled_name,
				    namespace, symtab);
  if (sym != NULL)
    return sym;
d884 2
d887 5
a891 1
#ifdef HPUXHPPA
d893 7
a899 51
  /* Check for the possibility of the symbol being a function or a
     global variable that is stored in one of the minimal symbol
     tables.  The "minimal symbol table" is built from linker-supplied
     info.

     RT: I moved this check to last, after the complete search of the
     global (p)symtab's and static (p)symtab's. For HP-generated
     symbol tables, this check was causing a premature exit from
     lookup_symbol with NULL return, and thus messing up symbol
     lookups of things like "c::f". It seems to me a check of the
     minimal symbol table ought to be a last resort in any case. I'm
     vaguely worried about the comment within
     lookup_symbol_aux_minsyms which talks about FORTRAN routines
     "foo_" though... is it saying we need to do the "minsym" check
     before the static check in this case?  */

  sym = lookup_symbol_aux_minsyms (name, mangled_name,
				   namespace, is_a_field_of_this,
				   symtab);
  if (sym != NULL)
    return sym;

#endif

  if (symtab != NULL)
    *symtab = NULL;
  return NULL;
}

/* Check to see if the symbol is defined in BLOCK or its
   superiors.  */

static struct symbol *
lookup_symbol_aux_local (const char *name, const char *mangled_name,
			 const struct block *block,
			 const namespace_enum namespace,
			 struct symtab **symtab)
{
  struct symbol *sym;
  struct objfile *objfile = NULL;
  struct blockvector *bv;
  struct block *b;
  struct symtab *s = NULL;
  
  while (block != 0)
    {
      sym = lookup_block_symbol (block, name, mangled_name, namespace);
      if (sym)
	{
	  block_found = block;
	  if (symtab != NULL)
d901 4
a904 12
	      /* Search the list of symtabs for one which contains the
	         address of the start of this block.  */
	      ALL_SYMTABS (objfile, s)
	      {
		bv = BLOCKVECTOR (s);
		b = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
		if (BLOCK_START (b) <= BLOCK_START (block)
		    && BLOCK_END (b) > BLOCK_START (block))
		  goto found;
	      }
	    found:
	      *symtab = s;
d906 3
a908 2

	  return fixup_symbol_section (sym, objfile);
a909 1
      block = BLOCK_SUPERBLOCK (block);
d912 1
a912 2
  return NULL;
}
d914 28
a941 4
/* Check to see if the symbol is defined in one of the symtabs.
   BLOCK_INDEX should be either GLOBAL_BLOCK or STATIC_BLOCK,
   depending on whether or not we want to search global symbols or
   static symbols.  */
d943 6
a948 11
static struct symbol *
lookup_symbol_aux_symtabs (int block_index,
			   const char *name, const char *mangled_name,
			   const namespace_enum namespace,
			   struct symtab **symtab)
{
  struct symbol *sym;
  struct objfile *objfile;
  struct blockvector *bv;
  const struct block *block;
  struct symtab *s;
d953 1
a953 1
    block = BLOCKVECTOR_BLOCK (bv, block_index);
a963 22
  return NULL;
}

/* Check to see if the symbol is defined in one of the partial
   symtabs.  BLOCK_INDEX should be either GLOBAL_BLOCK or
   STATIC_BLOCK, depending on whether or not we want to search global
   symbols or static symbols.  */

static struct symbol *
lookup_symbol_aux_psymtabs (int block_index, const char *name,
			    const char *mangled_name,
			    const namespace_enum namespace,
			    struct symtab **symtab)
{
  struct symbol *sym;
  struct objfile *objfile;
  struct blockvector *bv;
  const struct block *block;
  struct partial_symtab *ps;
  struct symtab *s;
  const int psymtab_index = (block_index == GLOBAL_BLOCK ? 1 : 0);

d966 1
a966 2
    if (!ps->readin
	&& lookup_partial_symbol (ps, name, psymtab_index, namespace))
d970 1
a970 1
	block = BLOCKVECTOR_BLOCK (bv, block_index);
d974 6
a979 14
	    /* This shouldn't be necessary, but as a last resort try
	       looking in the statics even though the psymtab claimed
	       the symbol was global, or vice-versa. It's possible
	       that the psymtab gets it wrong in some cases.  */

	    /* FIXME: carlton/2002-09-30: Should we really do that?
	       If that happens, isn't it likely to be a GDB error, in
	       which case we should fix the GDB error rather than
	       silently dealing with it here?  So I'd vote for
	       removing the check for the symbol in the other
	       block.  */
	    block = BLOCKVECTOR_BLOCK (bv,
				       block_index == GLOBAL_BLOCK ?
				       STATIC_BLOCK : GLOBAL_BLOCK);
d982 3
a984 2
	      error ("Internal: %s symbol `%s' found in %s psymtab but not in symtab.\n%s may be an inlined function, or may be a template function\n(if a template, try specifying an instantiation: %s<type>).",
		     block_index == GLOBAL_BLOCK ? "global" : "static",
d993 1
a993 2
  return NULL;
}
d995 3
a997 4
/* Check for the possibility of the symbol being a function or a
   mangled variable that is stored in one of the minimal symbol
   tables.  Eventually, all global symbols might be resolved in this
   way.  */
d999 10
a1008 12
static struct symbol *
lookup_symbol_aux_minsyms (const char *name,
			   const char *mangled_name,
			   const namespace_enum namespace,
			   int *is_a_field_of_this,
			   struct symtab **symtab)
{
  struct symbol *sym;
  struct blockvector *bv;
  const struct block *block;
  struct minimal_symbol *msymbol;
  struct symtab *s;
d1015 17
a1031 16
	  /* OK, we found a minimal symbol in spite of not finding any
	     symbol. There are various possible explanations for
	     this. One possibility is the symbol exists in code not
	     compiled -g. Another possibility is that the 'psymtab'
	     isn't doing its job.  A third possibility, related to #2,
	     is that we were confused by name-mangling. For instance,
	     maybe the psymtab isn't doing its job because it only
	     know about demangled names, but we were given a mangled
	     name...  */

	  /* We first use the address in the msymbol to try to locate
	     the appropriate symtab. Note that find_pc_sect_symtab()
	     has a side-effect of doing psymtab-to-symtab expansion,
	     for the found symtab.  */
	  s = find_pc_sect_symtab (SYMBOL_VALUE_ADDRESS (msymbol),
				   SYMBOL_BFD_SECTION (msymbol));
a1033 1
	      /* This is a function which has a symtab for its address.  */
d1036 6
a1041 8

	      /* This call used to pass `SYMBOL_NAME (msymbol)' as the
	         `name' argument to lookup_block_symbol.  But the name
	         of a minimal symbol is always mangled, so that seems
	         to be clearly the wrong thing to pass as the
	         unmangled name.  */
	      sym =
		lookup_block_symbol (block, name, mangled_name, namespace);
d1048 8
a1055 1
					     mangled_name, namespace);
d1058 2
a1059 1
	      /* sym == 0 if symbol was found in the minimal symbol table
d1061 5
a1065 1
	         Return 0 to use the msymbol definition of "foo_".
d1075 1
d1077 4
a1080 4
	      if (symtab != NULL)
		*symtab = s;
	      return fixup_symbol_section (sym, s->objfile);
	    }
a1084 2
	      /* This is a mangled variable, look it up by its
	         mangled name.  */
d1086 1
a1086 1
					NULL, namespace, is_a_field_of_this,
d1092 5
a1096 1
  return NULL;
d1338 1
a1338 1
  register int bot, top;
d1341 1
d1358 91
a1448 1
  else
a1449 5
      /* Note that parameter symbols do not always show up last in the
	 list.  This loop makes sure to take anything else other than
	 parameter symbols first; it only uses parameter symbols as a
	 last resort.  Note that this only takes up extra computation
	 time on a match.  */
a1454 9
	  /* If there is more than one symbol with the right name and
	     namespace, we return the first one; I believe it is now
	     impossible for us to encounter two symbols with the same
	     name and namespace here, because blocks containing
	     argument symbols are no longer sorted.  The exception is
	     for C++, where multiple functions (cloned constructors /
	     destructors, in particular) can have the same demangled
	     name.  So if we have a particular mangled name to match,
	     try to do so.  */
a1495 1
      return (sym_found);		/* Will be NULL if not found. */
d1497 1
@


1.70.4.2
log
@2002-10-22  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (buildsym.o): Depend on $(gdb_assert_h) and
	$(cp_support_h).
	(cp-support.o): Fix dependencies and add $(gdb_obstack_h) and
	$(gdb_assert_h).
	(symtab.o): Depend on $(cp_support_h).
	* symtab.h: Add opaque declaration for struct using_direct_node.
	(struct block): Add member 'language_specific'.
	(BLOCK_USING): New macro.
	* symtab.c: #include "cp-support.h"
	(lookup_symbol_aux): Call lookup_symbol_aux_nonlocal and
	lookup_symbol_aux_using when appropriate.
	(lookup_symbol_aux_nonlocal): New function.
	(lookup_symbol_aux_using): New function.
	(lookup_symbol_aux_using_loop): New function.
	* symfile.h: Add opaque declaration for struct obstack.
	Declare obsavestring to take a const char *.
	* symfile.c (obsavestring): Make first argument a const char *.
	* jv-lang.c (get_java_class_symtab): Initialize BLOCK_USING.
	* dwarf2read.c: New variable current_namespace.
	(scan_partial_symbols): Handle DW_TAG_namespace.
	(psymtab_to_symtab_1): Initialize current_namespace.
	(process_die): Handle DW_TAG_namespace,
	DW_TAG_imported_declaration, DW_TAG_imported_module.
	(read_namespace): New function.
	(dwarf2_name): New function.
	(dwarf2_extension): New function.
	(dwarf_tag_name): Add DWARF 3 names.
	(dwarf_attr_name): Ditto.
	(dwarf_type_encoding_name): Ditto.
	* cp-support.h: Opaque declaration for struct obstack.
	(struct using_direct): New struct.
	(struct using_direct_node): New struct.
	Add declarations for cp_add_using_obstack, cp_add_using_xmalloc,
	cp_copy_usings, cp_free_usings,	cp_find_first_component.
	* cp-support.c: #include "gdb_obstack.h", "gdb_assert.h".
	Comment on demangled name pitfalls.
	(cp_add_using_obstack): New function.
	(cp_add_using_xmalloc): New function.
	(cp_copy_usings): New function.
	(cp_free_usings): New function.
	(cp_find_first_component): New function.
	* buildsym.h: Declare processing_has_namespace_info.
	Declare add_using_directive.
	* buildsym.c: #include "gdb_assert.h", "cp-support.h".
	Change comment after #include "symfile.h".
	New variable using_list.
	(add_symbol_to_list): Scan for anonymous namespaces when
	appropriate.
	(scan_for_anonymous_namespaces): New function.
	(add_using_directive): New function.
	(start_symtab): Initialize processing_has_namespace_info,
	using_list.
	(end_symtab): Copy using_list into block.
	(copy_usings_to_obstack): New function.
	(finish_block): Set BLOCK_USING in general case and in C++
	function case.

2002-10-22  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Add tests involving namespaces
	  starting from C.
	* gdb.c++/namespace.cc: Add namespaces with names starting
	  from C and their contents.
@
text
@a51 1
#include "cp-support.h"
a97 7
struct symbol *lookup_symbol_aux_nonlocal (int block_index,
					   const char *name,
					   const char *mangled_name,
					   const namespace_enum namespace,
					   struct symtab **symtab);

static
a109 17

static
struct symbol *lookup_symbol_aux_using (const char *name,
					const char *mangled_name,
					const struct block *block,
					const namespace_enum namespace,
					struct symtab **symtab);

static
struct symbol *lookup_symbol_aux_using_loop (const char *prefix,
					     int prefix_len,
					     const char *rest,
					     struct using_direct_node *using,
					     const char *mangled_name,
					     namespace_enum namespace,
					     struct symtab **symtab);

d788 6
a793 1
  sym = lookup_symbol_aux_nonlocal (GLOBAL_BLOCK, name, mangled_name,
a797 16
  /* If we're in the C++ case, check to see if the symbol is defined
     in a namespace accessible via a "using" declaration.  */

  /* FIXME: carlton/2002-10-10: is "is_a_field_of_this" always
     non-NULL if we're in the C++ case?  Maybe we should always do
     this, and delete the two previous searches: this will always
     search the global namespace, after all.  */

  if (is_a_field_of_this)
    {
      sym = lookup_symbol_aux_using (name, mangled_name, block, namespace,
				     symtab);
      if (sym != NULL)
	return sym;
    }

d819 6
a824 1
  sym = lookup_symbol_aux_nonlocal (STATIC_BLOCK, name, mangled_name,
d829 1
a905 26
/* Check to see if the symbol is defined in one of the symtabs or
   psymtabs.  BLOCK_INDEX should be either GLOBAL_BLOCK or
   STATIC_BLOCK, depending on whether or not we want to search global
   symbols or static symbols.  */

/* FIXME: carlton/2002-10-11: Should this also do some minsym
   lookup?  */

static struct symbol *
lookup_symbol_aux_nonlocal (int block_index,
			    const char *name,
			    const char *mangled_name,
			    const namespace_enum namespace,
			    struct symtab **symtab)
{
  struct symbol *sym;

  sym = lookup_symbol_aux_symtabs (block_index, name, mangled_name,
				   namespace, symtab);
  if (sym != NULL)
    return sym;

  return lookup_symbol_aux_psymtabs (block_index, name, mangled_name,
				     namespace, symtab);
}

a996 128
}

/* This function gathers using directives from BLOCK and its
   superblocks, and then searches for symbols in the global namespace
   by trying to apply those various using directives.  */
static struct symbol *lookup_symbol_aux_using (const char *name,
					       const char *mangled_name,
					       const struct block *block,
					       const namespace_enum namespace,
					       struct symtab **symtab)
{
  struct using_direct_node *using = NULL;
  struct symbol *sym;

  while (block != NULL)
    {
      using = cp_copy_usings (BLOCK_USING (block), using);
      block = BLOCK_SUPERBLOCK (block);
    }

  sym = lookup_symbol_aux_using_loop ("", 0, name, using, mangled_name,
				      namespace, symtab);
  cp_free_usings (using);
  
  return sym;
}

/* This tries to look up REST in the namespace given by the initial
   substring of PREFIX of length PREFIX_LEN.

   Basically, assume that we have using directives adding A to the
   global namespace, adding A::inner to namespace A, and adding B to
   the global namespace.  Then, when looking up a symbol "foo", we
   want to recurse by looking up stuff in A::foo and seeing which
   using directives still apply.  The only one that still applies
   converts that to A::inner::foo: we _don't_ want to then look at
   B::A::foo (let alone A::A::foo!).  So we end up just looking at
   A::foo, A::inner::foo, and B::foo.  (Though if the original caller
   to lookup_symbol had specified A::foo, we would want to look up
   stuff in A::A::foo, A::inner::A::foo, A::inner::foo, and
   B::A::foo).  */

/* FIXME: carlton/2002-10-11: There are still some places where this
   will return false positives.  For example, if you have namespaces
   C, C::D, C::E, and C::D::E, then, from a function defined in C::D,
   all references to variables E::var _should_ be treated as
   C::D::E::var, but this function will also see variables in
   C::E::var.  I don't think this can be fixed without making
   namespaces first-class objects.  (Which is certainly a good idea
   for other reasons, but it will take a little while.)  */

static struct symbol *
lookup_symbol_aux_using_loop (const char *prefix,
			      int prefix_len,
			      const char *rest,
			      struct using_direct_node *using,
			      const char *mangled_name,
			      namespace_enum namespace,
			      struct symtab **symtab)
{
  struct using_direct_node *current;
  struct symbol *sym;

  for (current = using; current; current = current->next)
    {
      /* First, see if the prefix matches the start of this using
	 directive.  */
      if (prefix_len <= current->current->outer_length
	  && strncmp (prefix, current->current->name, prefix_len) == 0)
	{
	  /* Great, it matches: now does the rest of the using
	     directive match the rest of the name?  */
	  
	  const char *rest_of_outer = current->current->name + prefix_len;
	  int rest_of_outer_len
	    = current->current->outer_length - prefix_len;
	  /* Should we skip some colons?  Should be true unless
	     PREFIX_LEN is zero (and hence we're in the global
	     namespace) or we've finished all of outer.  */
	  if (rest_of_outer_len != 0 && *rest_of_outer == ':')
	    {
	      rest_of_outer += 2;
	      rest_of_outer_len -= 2;
	    }
	  if (strncmp (rest_of_outer, rest, rest_of_outer_len) == 0)
	    {
	      /* Everything matches!  Yippee!  So apply the using
		 directive and recurse.  */
	      const char *new_rest = rest + rest_of_outer_len;
	      if (*new_rest == ':')
		new_rest += 2;

	      sym = lookup_symbol_aux_using_loop
		(current->current->name,
		 current->current->inner_length,
		 new_rest,
		 using,
		 mangled_name,
		 namespace,
		 symtab);
	      if (sym != NULL)
		return sym;
	    }
	}
    }

  /* We didn't find anything by applying any of the using directives
     that are still applicable; so let's see if we've got a match
     using the current name.  */
  
  if (prefix_len == 0)
    {
      return lookup_symbol_aux_nonlocal (GLOBAL_BLOCK, rest, mangled_name,
					 namespace, symtab);
    }
  else
    {
      char *concatenated_name
	= xmalloc (prefix_len + 2 + strlen (rest) + 1);
      strncpy (concatenated_name, prefix, prefix_len);
      strcpy (concatenated_name + prefix_len, "::");
      strcpy (concatenated_name + prefix_len + 2, rest);
      sym = lookup_symbol_aux_nonlocal (GLOBAL_BLOCK, concatenated_name,
					mangled_name, namespace, symtab);

      xfree (concatenated_name);
      return sym;
    }
@


1.70.4.3
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@d54 5
d175 13
a438 27
/* Initialize the language dependent portion of a symbol
   depending upon the language for the symbol. */
void
symbol_init_language_specific (struct general_symbol_info *gsymbol,
			       enum language language)
{
  gsymbol->language = language;
  if (gsymbol->language == language_cplus
      || gsymbol->language == language_java)
    {
      gsymbol->language_specific.cplus_specific.demangled_name = NULL;
    }
  else if (gsymbol->language == language_objc)
    {
      gsymbol->language_specific.objc_specific.demangled_name = NULL;
    }
  /* OBSOLETE else if (SYMBOL_LANGUAGE (symbol) == language_chill) */
  /* OBSOLETE   { */
  /* OBSOLETE     SYMBOL_CHILL_DEMANGLED_NAME (symbol) = NULL; */
  /* OBSOLETE   } */
  else
    {
      memset (&gsymbol->language_specific, 0,
	      sizeof (gsymbol->language_specific));
    }
}

a514 18
/* Return the demangled name for a symbol based on the language for
   that symbol.  If no demangled name exists, return NULL. */
char *
symbol_demangled_name (struct general_symbol_info *gsymbol)
{
  if (gsymbol->language == language_cplus
      || gsymbol->language == language_java)
    return gsymbol->language_specific.cplus_specific.demangled_name;

  else if (gsymbol->language == language_objc)
    return gsymbol->language_specific.objc_specific.demangled_name;

  else 
    return NULL;

  /* OBSOLETE (SYMBOL_LANGUAGE (symbol) == language_chill */
  /* OBSOLETE ? SYMBOL_CHILL_DEMANGLED_NAME (symbol) */
}
a515 10
/* Initialize the structure fields to zero values.  */
void
init_sal (struct symtab_and_line *sal)
{
  sal->symtab = 0;
  sal->section = 0;
  sal->line = 0;
  sal->pc = 0;
  sal->end = 0;
}
d1901 1
a1901 1
  init_sal (&val);		/* initialize to zeroes */
@


1.70.4.4
log
@2002-11-22  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h: Add opaque declarations for struct namespace_info and
	struct obstack.
	(struct block): The language_specific stuff is now a struct
	namespace_info rather than a struct using_direct_node.
	(BLOCK_NAMESPACE): New macro.
	Delete macro BLOCK_USING.
	Add declarations for block_using, block_all_usings,
	block_set_using, block_scope, block_set_scope.
	* symtab.c: #include "gdb_assert.h"
	(lookup_symbol_aux): Move minsym stuff inside
	lookup_symbol_aux_nonlocal, and always do global search via
	lookup_symbol_aux_using.
	(lookup_symbol_aux_nonlocal): Do minsym search.
	(lookup_symbol_aux_using): Calculate usings via block_all_usings;
	handle namespace scope.
	(lookup_symbol_aux_using_loop): New function, not to be confused
	with the previous function of the same name.  (Sorry about that.)
	(lookup_symbol_namespace): Renamed from
	lookup_symbol_aux_using_loop.
	(lookup_symbol_aux_minsyms): Add block_index argument, delete
	is_a_field_of_this argument, and only check either global or
	static symbols rather than both of them.
	(block_using): New function.
	(block_all_usings): New function.
	(block_set_using): New function.
	(block_scope): New function.
	(block_set_scope): New function.
	(block_initialize_namespace): New function.
	* jv-lang.c (get_java_class_symtab): BLOCK_NAMESPACE instead of
	BLOCK_USING.
	* dwarf2read.c: Delete variable current_namespace, and replace its
	uses by processing_current_namespace (from buildsym.h).
	(scan_partial_symbols): Allow empty pdi.name if we're
	reading a namespace.
	* cp-support.h (struct namespace_info): New struct.
	* cp-support.c: Add comment.
	* buildsym.h: New variable processing_current_namespace.
	* buildsym.c (add_symbol_to_list): Do fast search for
	"(anonymous namespace)".
	(scan_for_anonymous_namespaces): Delete FIXME.  Convert for loop
	into a clearer while loop.
	(finish_block): Replace BLOCK_USING by BLOCK_NAMESPACE.
	(finish_block): Set block_scope of function blocks rather than
	generating using directives that would have a similar effect.
	(end_symtab): Set using via block_set_using rather than
	BLOCK_USING.
	* Makefile.in (symtab.o): Depend on gdb_assert_h.
@
text
@a52 1
#include "gdb_assert.h"
d122 4
a125 1
struct symbol *lookup_symbol_aux_using_loop (const char *name,
d128 1
a128 4
					     struct symtab **symtab,
					     const char *scope,
					     int scope_len,
					     struct using_direct_node *using);
d131 1
a131 11
struct symbol *lookup_symbol_namespace (const char *prefix,
					int prefix_len,
					const char *rest,
					struct using_direct_node *using,
					const char *mangled_name,
					namespace_enum namespace,
					struct symtab **symtab);

static
struct symbol *lookup_symbol_aux_minsyms (int block_index,
					  const char *name,
d134 1
d137 1
a156 3
static void block_initialize_namespace (struct block *block,
					struct obstack *obstack);

d845 27
a871 15
  /* Now search all global blocks.  Do the symtab's first, then the
     minsyms, then check the psymtab's. If minsyms or psymtabs
     indicate the existence of the desired name as a global, then
     generate the appropriate symtab on the fly and return the found
     symbol.

     We do this from within lookup_symbol_aux_using: that will apply
     appropriate using directives in the C++ case.  But it works fine
     in the non-C++ case, too.  */

  /* NOTE: carlton/2002-10-22: Is it worthwhile to try to figure out
     whether or not we're in the C++ case?  Doing
     lookup_symbol_aux_using won't slow things down significantly in
     the general case, though: other parts of this function are much,
     much more expensive.  */
d873 8
a880 2
  sym = lookup_symbol_aux_using (name, mangled_name, block, namespace,
				 symtab);
d884 2
d887 4
a890 1
     but more useful than an error.  */
d897 26
d978 3
d995 2
a996 57
#ifndef HPUXHPPA
  sym = lookup_symbol_aux_minsyms (block_index, name, mangled_name,
				   namespace, symtab);
  if (sym != NULL)
    return sym;
#endif

  sym = lookup_symbol_aux_psymtabs (block_index, name, mangled_name,
				    namespace, symtab);
  if (sym != NULL)
    return sym;

#ifdef HPUXHPPA

  /* FIXME: carlton/2002-10-28: The following comment was present in
     lookup_symbol_aux before I broke it up: at that time, the HP
     search order for nonlocal stuff was global symtab, global
     psymtab, static symtab, static psymtab, global and static
     minsyms.  (The minsyms are stored so that it's just as easy to do
     global and static searches of them at the same time.)  Now it's
     global symtab, global psymtab, global minsyms, static symtab,
     static psymtab, static minsyms.  Also, it's now impossible for a
     global minsym search to cause a NULL return by itself: if a
     minsym search returns NULL, then the next search after that is
     still performed.

     Given that that's the case, I'm pretty sure that my search order
     is safe; indeed, given that the comment below warns against
     premature NULL returns, it even seems plausible to me that we can
     treat HP symbol tables the same as non-HP symbol tables.  It
     would be great if somebody who has access to HP machines (or,
     even better, who understands the reason behind the HP special
     case in the first place) could check on this.

     But there's still the comment about "foo_" symbols in
     lookup_symbol_aux_minsyms which I really don't understand, sigh.
     _Should_ a minsym lookup sometimes be able to force a NULL return
     from lookup_symbol?  */

  /* RT: I moved this check to last, after the complete search of the
     global (p)symtab's and static (p)symtab's. For HP-generated
     symbol tables, this check was causing a premature exit from
     lookup_symbol with NULL return, and thus messing up symbol
     lookups of things like "c::f". It seems to me a check of the
     minimal symbol table ought to be a last resort in any case. I'm
     vaguely worried about the comment within
     lookup_symbol_aux_minsyms which talks about FORTRAN routines
     "foo_" though... is it saying we need to do the "minsym" check
     before the static check in this case?  */

  sym = lookup_symbol_aux_minsyms (block_index, name, mangled_name,
				   namespace, symtab);
  if (sym != NULL)
    return sym;
#endif

  return NULL;
a1094 1

d1101 1
a1101 2
  struct using_direct_node *using;
  const char *scope;
d1104 8
a1111 5
  using = block_all_usings (block);
  scope = block_scope (block);
  
  sym = lookup_symbol_aux_using_loop (name, mangled_name, namespace, symtab,
				      scope, 0, using);
a1116 38
/* Look up NAME in the namespaces given by SCOPE and its initial
   prefixes, applying using directives given by USING; only consider
   prefixes that are at least as long as SCOPE_LEN, however.  Look up
   longest prefixes first.  */

static struct
symbol *lookup_symbol_aux_using_loop (const char *name,
				      const char *mangled_name,
				      namespace_enum namespace,
				      struct symtab **symtab,
				      const char *scope,
				      int scope_len,
				      struct using_direct_node *using)
{
  if (scope[scope_len] != '\0')
    {
      struct symbol *sym;
      int next_component;
      int new_scope_len = scope_len;

      /* If the current scope is followed by "::", skip past that.  */
      if (new_scope_len != 0)
	{
	  gdb_assert (scope[new_scope_len] == ':');
	  new_scope_len += 2;
	}
      next_component = cp_find_first_component (scope + new_scope_len) - scope;
      sym = lookup_symbol_aux_using_loop (name, mangled_name, namespace,
					  symtab, scope, next_component,
					  using);
      if (sym != NULL)
	return sym;
    }

  return lookup_symbol_namespace (scope, scope_len, name, using,
				  mangled_name, namespace, symtab);
}

d1120 1
a1120 1
   For example, assume that we have using directives adding A to the
a1140 5
/* NOTE: carlton/2002-11-19: This is optimistically called
   lookup_symbol_namespace instead of lookup_symbol_aux_namespace in
   hopes that it or something like it might eventually be useful
   outside of lookup_symbol.  */

d1142 7
a1148 7
lookup_symbol_namespace (const char *prefix,
			 int prefix_len,
			 const char *rest,
			 struct using_direct_node *using,
			 const char *mangled_name,
			 namespace_enum namespace,
			 struct symtab **symtab)
d1182 8
a1189 7
	      sym = lookup_symbol_namespace (current->current->name,
					     current->current->inner_length,
					     new_rest,
					     using,
					     mangled_name,
					     namespace,
					     symtab);
d1226 1
a1226 1
lookup_symbol_aux_minsyms (int block_index, const char *name,
d1229 1
d1253 1
a1253 24
	  /* First, check to see that the symbol looks like it's
	     global or static (depending on what we were asked to look
	     for).  */

	  /* NOTE: carlton/2002-10-28: lookup_minimal_symbol gives
	     preference to global symbols over static symbols, so if
	     block_index is STATIC_BLOCK then this might well miss
	     static symbols that are shadowed by global symbols.  But
	     that's okay: this is only called with block_index equal
	     to STATIC_BLOCK if a global search has failed.  */

	  switch (MSYMBOL_TYPE (msymbol))
	    {
	    case mst_file_text:
	    case mst_file_data:
	    case mst_file_bss:
	      if (block_index == GLOBAL_BLOCK)
		return NULL;
	    default:
	      if (block_index == STATIC_BLOCK)
		return NULL;
	    }
	  
	  /* We next use the address in the msymbol to try to locate
d1263 1
a1263 1
	      block = BLOCKVECTOR_BLOCK (bv, block_index);
d1272 8
a1279 10

	      /* FIXME: carlton/2002-10-28: this next comment dates
		 from when this code was part of lookup_symbol_aux, so
		 this return could return NULL from lookup_symbol_aux.
		 Are there really situations where we want a minimal
		 symbol lookup to be able to force a NULL return from
		 lookup_symbol?  If so, maybe the thing to do would be
		 to have lookup_symbol_aux_minsym to set a
		 minsym_found flag, and to have lookup_symbol_aux only
		 do the psymtab search if that flag is zero.  */
d1300 1
a1300 1
		   && strcmp (name, SYMBOL_NAME (msymbol)) != 0)
d1304 3
a1306 5
	      return lookup_symbol_aux_nonlocal (block_index,
						 SYMBOL_NAME (msymbol),
						 mangled_name,
						 namespace,
						 symtab);
a3277 90

/* Now come some functions designed to deal with C++ namespace issues.
   The accessors are safe to use even in the non-C++ case.  */

/* This returns the using directives associated to BLOCK (but _not_
   its parents), if any.  */

struct using_direct_node *
block_using (const struct block *block)
{
  if (BLOCK_NAMESPACE (block) == NULL)
    return NULL;
  else
    return BLOCK_NAMESPACE (block)->using;
}

/* This returns the using directives associated to BLOCK and its
   parents, if any.  The resulting structure must be freed by calling
   cp_free_usings on it.  */

struct using_direct_node *
block_all_usings (const struct block *block)
{
  struct using_direct_node *using = NULL;

  while (block != NULL)
    {
      using = cp_copy_usings (block_using (block), using);
      block = BLOCK_SUPERBLOCK (block);
    }

  return using;
}

/* Set block_using (BLOCK) to USING; if needed, allocate memory via
   OBSTACK.  */

void
block_set_using (struct block *block, struct using_direct_node *using,
		 struct obstack *obstack)
{
  block_initialize_namespace (block, obstack);

  BLOCK_NAMESPACE (block)->using = using;
}

/* This returns the namespace that BLOCK is enclosed in, or "" if it
   isn't enclosed in a namespace at all.  This travels the chain of
   superblocks looking for a scope, if necessary.  */

const char *
block_scope (const struct block *block)
{
  for (; block != NULL; block = BLOCK_SUPERBLOCK (block))
    {
      if (BLOCK_NAMESPACE (block) != NULL
	  && BLOCK_NAMESPACE (block)->scope != NULL)
	return BLOCK_NAMESPACE (block)->scope;
    }

  return "";
}

/* Set block_scope (BLOCK) to SCOPE; if needed, allocate memory via
   OBSTACK.  (It won't make a copy of SCOPE, however, so that already
   has to be allocated correctly.)  */

void
block_set_scope (struct block *block, const char *scope,
		 struct obstack *obstack)
{
  block_initialize_namespace (block, obstack);

  BLOCK_NAMESPACE (block)->scope = scope;
}

/* If BLOCK_NAMESPACE (block) is NULL, allocate it via OBSTACK and
   ititialize its members to zero.  */

static void
block_initialize_namespace (struct block *block, struct obstack *obstack)
{
  if (BLOCK_NAMESPACE (block) == NULL)
    {
      BLOCK_NAMESPACE (block)
	= obstack_alloc (obstack, sizeof (struct namespace_info));
      BLOCK_NAMESPACE (block)->using = NULL;
    }
}

@


1.70.4.5
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d4 2
a5 2
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
a42 3
#include "objc-lang.h"

#include "hashtab.h"
a44 2
#include "block.h"
#include "dictionary.h"
d52 2
d77 4
d82 1
a82 1
					 const char *linkage_name,
d84 1
a84 1
					 const domain_enum domain,
d88 6
d95 5
a99 5
struct symbol *lookup_symbol_aux_local (const char *name,
					const char *linkage_name,
					const struct block *block,
					const domain_enum domain,
					struct symtab **symtab);
d104 2
a105 2
					  const char *linkage_name,
					  const domain_enum domain,
d111 2
a112 2
					   const char *linkage_name,
					   const domain_enum domain,
a114 1
#if 0
d116 29
a144 4
struct symbol *lookup_symbol_aux_minsyms (const char *name,
					  const char *linkage_name,
					  const domain_enum domain,
					  int *is_a_field_of_this,
d146 2
a147 1
#endif
d157 1
a157 1
static void print_symbol_info (domain_enum,
d162 6
a167 1
static void symtab_symbol_info (char *, domain_enum, int);
d189 3
a191 3
  struct symtab *s;
  struct partial_symtab *ps;
  struct objfile *objfile;
d282 2
a283 2
  struct partial_symtab *pst;
  struct objfile *objfile;
d383 1
a383 1
    is_full_physname_constructor || (newname && strcmp (field_name, newname) == 0);
d441 1
a441 2
      || gsymbol->language == language_java
      || gsymbol->language == language_objc)
d445 8
d460 1
a460 13
/* Functions to initialize a symbol's mangled name.  */

/* Create the hash table used for demangled names.  Each hash entry is
   a pair of strings; one for the mangled name and one for the demangled
   name.  The entry is hashed via just the mangled name.  */

static void
create_demangled_names_hash (struct objfile *objfile)
{
  /* Choose 256 as the starting size of the hash table, somewhat arbitrarily.
     The hash table code will round this up to the next prime number. 
     Choosing a much larger table size wastes memory, and saves only about
     1% in symbol reading.  */
d462 1
a462 6
  objfile->demangled_names_hash = htab_create_alloc_ex
    (256, htab_hash_string, (int (*) (const void *, const void *)) streq,
     NULL, objfile->md, xmcalloc, xmfree);
}

/* Try to determine the demangled name for a symbol, based on the
d465 5
a469 2
   then set the language appropriately.  The returned name is allocated
   by the demangler and should be xfree'd.  */
d471 3
a473 3
static char *
symbol_find_demangled_name (struct general_symbol_info *gsymbol,
			    const char *mangled)
d475 1
a479 12

  if (gsymbol->language == language_objc
      || gsymbol->language == language_auto)
    {
      demangled =
	objc_demangle (mangled, 0);
      if (demangled != NULL)
	{
	  gsymbol->language = language_objc;
	  return demangled;
	}
    }
d484 1
a484 1
        cplus_demangle (mangled, DMGL_PARAMS | DMGL_ANSI);
d486 10
a495 4
	{
	  gsymbol->language = language_cplus;
	  return demangled;
	}
d500 1
a500 1
        cplus_demangle (mangled,
d503 6
a508 105
	{
	  gsymbol->language = language_java;
	  return demangled;
	}
    }
  return NULL;
}

/* Set both the mangled and demangled (if any) names for GSYMBOL based
   on LINKAGE_NAME and LEN.  The hash table corresponding to OBJFILE
   is used, and the memory comes from that objfile's symbol_obstack.
   LINKAGE_NAME is copied, so the pointer can be discarded after
   calling this function.  */

/* We have to be careful when dealing with Java names: when we run
   into a Java minimal symbol, we don't know it's a Java symbol, so it
   gets demangled as a C++ name.  This is unfortunate, but there's not
   much we can do about it: but when demangling partial symbols and
   regular symbols, we'd better not reuse the wrong demangled name.
   (See PR gdb/1039.)  We solve this by putting a distinctive prefix
   on Java names when storing them in the hash table.  */

/* FIXME: carlton/2003-03-13: This is an unfortunate situation.  I
   don't mind the Java prefix so much: different languages have
   different demangling requirements, so it's only natural that we
   need to keep language data around in our demangling cache.  But
   it's not good that the minimal symbol has the wrong demangled name.
   Unfortunately, I can't think of any easy solution to that
   problem.  */

#define JAVA_PREFIX "##JAVA$$"
#define JAVA_PREFIX_LEN 8

void
symbol_set_names (struct general_symbol_info *gsymbol,
		  const char *linkage_name, int len, struct objfile *objfile)
{
  char **slot;
  /* A 0-terminated copy of the linkage name.  */
  const char *linkage_name_copy;
  /* A copy of the linkage name that might have a special Java prefix
     added to it, for use when looking names up in the hash table.  */
  const char *lookup_name;
  /* The length of lookup_name.  */
  int lookup_len;

  if (objfile->demangled_names_hash == NULL)
    create_demangled_names_hash (objfile);

  /* The stabs reader generally provides names that are not
     NUL-terminated; most of the other readers don't do this, so we
     can just use the given copy, unless we're in the Java case.  */
  if (gsymbol->language == language_java)
    {
      char *alloc_name;
      lookup_len = len + JAVA_PREFIX_LEN;

      alloc_name = alloca (lookup_len + 1);
      memcpy (alloc_name, JAVA_PREFIX, JAVA_PREFIX_LEN);
      memcpy (alloc_name + JAVA_PREFIX_LEN, linkage_name, len);
      alloc_name[lookup_len] = '\0';

      lookup_name = alloc_name;
      linkage_name_copy = alloc_name + JAVA_PREFIX_LEN;
    }
  else if (linkage_name[len] != '\0')
    {
      char *alloc_name;
      lookup_len = len;

      alloc_name = alloca (lookup_len + 1);
      memcpy (alloc_name, linkage_name, len);
      alloc_name[lookup_len] = '\0';

      lookup_name = alloc_name;
      linkage_name_copy = alloc_name;
    }
  else
    {
      lookup_len = len;
      lookup_name = linkage_name;
      linkage_name_copy = linkage_name;
    }

  slot = (char **) htab_find_slot (objfile->demangled_names_hash,
				   lookup_name, INSERT);

  /* If this name is not in the hash table, add it.  */
  if (*slot == NULL)
    {
      char *demangled_name = symbol_find_demangled_name (gsymbol,
							 linkage_name_copy);
      int demangled_len = demangled_name ? strlen (demangled_name) : 0;

      /* If there is a demangled name, place it right after the mangled name.
	 Otherwise, just place a second zero byte after the end of the mangled
	 name.  */
      *slot = obstack_alloc (&objfile->symbol_obstack,
			     lookup_len + demangled_len + 2);
      memcpy (*slot, lookup_name, lookup_len + 1);
      if (demangled_name != NULL)
	{
	  memcpy (*slot + lookup_len + 1, demangled_name, demangled_len + 1);
	  xfree (demangled_name);
	}
d510 3
a512 61
	(*slot)[lookup_len + 1] = '\0';
    }

  gsymbol->name = *slot + lookup_len - len;
  if ((*slot)[lookup_len + 1] != '\0')
    gsymbol->language_specific.cplus_specific.demangled_name
      = &(*slot)[lookup_len + 1];
  else
    gsymbol->language_specific.cplus_specific.demangled_name = NULL;
}

/* Initialize the demangled name of GSYMBOL if possible.  Any required space
   to store the name is obtained from the specified obstack.  The function
   symbol_set_names, above, should be used instead where possible for more
   efficient memory usage.  */

void
symbol_init_demangled_name (struct general_symbol_info *gsymbol,
                            struct obstack *obstack)
{
  char *mangled = gsymbol->name;
  char *demangled = NULL;

  demangled = symbol_find_demangled_name (gsymbol, mangled);
  if (gsymbol->language == language_cplus
      || gsymbol->language == language_java
      || gsymbol->language == language_objc)
    {
      if (demangled)
	{
	  gsymbol->language_specific.cplus_specific.demangled_name
	    = obsavestring (demangled, strlen (demangled), obstack);
	  xfree (demangled);
	}
      else
	gsymbol->language_specific.cplus_specific.demangled_name = NULL;
    }
  else
    {
      /* Unknown language; just clean up quietly.  */
      if (demangled)
	xfree (demangled);
    }
}

/* Return the source code name of a symbol.  In languages where
   demangling is necessary, this is the demangled name.  */

char *
symbol_natural_name (const struct general_symbol_info *gsymbol)
{
  if ((gsymbol->language == language_cplus
       || gsymbol->language == language_java
       || gsymbol->language == language_objc)
      && (gsymbol->language_specific.cplus_specific.demangled_name != NULL))
    {
      return gsymbol->language_specific.cplus_specific.demangled_name;
    }
  else
    {
      return gsymbol->name;
d514 20
d542 1
a542 2
      || gsymbol->language == language_java
      || gsymbol->language == language_objc)
d545 3
d550 3
d573 2
a574 2
  struct partial_symtab *pst;
  struct objfile *objfile;
d661 1
a661 1
      if (SYMBOL_DOMAIN (p) == VAR_DOMAIN
d685 1
a685 1
      if (SYMBOL_DOMAIN (p) == VAR_DOMAIN
d760 1
a760 1
   in domain DOMAIN, visible from lexical block BLOCK.
d774 5
a778 5
   out of here: find_proc_desc in alpha-tdep.c and mips-tdep.c.  (Note
   that there is C++ code below which can error(), but that probably
   doesn't affect these calls since they are looking for a known
   variable and thus can probably assume it will never hit the C++
   code).  */
d782 1
a782 1
	       const domain_enum domain, int *is_a_field_of_this,
d820 1
a820 1
				 domain, is_a_field_of_this, symtab);
a826 5
/* Behave like lookup_symbol_aux except that NAME is the natural name
   of the symbol that we're looking for and, if LINKAGE_NAME is
   non-NULL, ensure that the symbol's linkage name matches as
   well.  */

d828 2
a829 2
lookup_symbol_aux (const char *name, const char *linkage_name,
		   const struct block *block, const domain_enum domain,
d834 1
a834 10
  /* Make sure we do something sensible with is_a_field_of_this, since
     the callers that set this parameter to some non-null value will
     certainly use it later and expect it to be either 0 or 1.
     If we don't set it, the contents of is_a_field_of_this are
     undefined.  */
  if (is_a_field_of_this != NULL)
    *is_a_field_of_this = 0;

  /* Search specified block and its superiors.  Don't search
     STATIC_BLOCK or GLOBAL_BLOCK.  */
d836 1
a836 1
  sym = lookup_symbol_aux_local (name, linkage_name, block, domain,
d841 3
a843 5
  /* If requested to do so by the caller and if appropriate for the
     current language, check to see if NAME is a field of `this'. */

  if (current_language->la_value_of_this != NULL
      && is_a_field_of_this != NULL)
d845 1
a845 1
      struct value *v = current_language->la_value_of_this (0);
d847 1
d857 15
a871 2
  /* Now do whatever is appropriate for the current language to look
     up static and global variables.  */
d873 2
a874 3
  sym = current_language->la_lookup_symbol_nonlocal (name, linkage_name,
						     block, domain,
						     symtab);
d879 1
a879 4
     but more useful than an error.  Do the symtabs first, then check
     the psymtabs.  If a psymtab indicates the existence of the
     desired name as a file-level static, then do psymtab-to-symtab
     conversion on the fly and return the found symbol. */
d881 2
a882 7
  sym = lookup_symbol_aux_symtabs (STATIC_BLOCK, name, linkage_name,
				   domain, symtab);
  if (sym != NULL)
    return sym;
  
  sym = lookup_symbol_aux_psymtabs (STATIC_BLOCK, name, linkage_name,
				    domain, symtab);
d891 2
a892 2
/* Check to see if the symbol is defined in BLOCK or its superiors.
   Don't search STATIC_BLOCK or GLOBAL_BLOCK.  */
d895 1
a895 1
lookup_symbol_aux_local (const char *name, const char *linkage_name,
d897 1
a897 1
			 const domain_enum domain,
d901 26
a926 1
  const struct block *static_block = block_static_block (block);
d928 2
a929 11
  /* Check if either no block is specified or it's a global block.  */

  if (static_block == NULL)
    return NULL;

  while (block != static_block)
    {
      sym = lookup_symbol_aux_block (name, linkage_name, block, domain,
				     symtab);
      if (sym != NULL)
	return sym;
a932 2
  /* We've reached the static block without finding a result.  */

d936 4
a939 2
/* Look up a symbol in a block; if found, locate its symtab, fixup the
   symbol, and set block_found appropriately.  */
d941 6
a946 5
struct symbol *
lookup_symbol_aux_block (const char *name, const char *linkage_name,
			 const struct block *block,
			 const domain_enum domain,
			 struct symtab **symtab)
a948 4
  struct objfile *objfile = NULL;
  struct blockvector *bv;
  struct block *b;
  struct symtab *s = NULL;
d950 60
a1009 22
  sym = lookup_block_symbol (block, name, linkage_name, domain);
  if (sym)
    {
      block_found = block;
      if (symtab != NULL)
	{
	  /* Search the list of symtabs for one which contains the
	     address of the start of this block.  */
	  ALL_SYMTABS (objfile, s)
	    {
	      bv = BLOCKVECTOR (s);
	      b = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
	      if (BLOCK_START (b) <= BLOCK_START (block)
		  && BLOCK_END (b) > BLOCK_START (block))
		goto found;
	    }
	found:
	  *symtab = s;
	}
      
      return fixup_symbol_section (sym, objfile);
    }
d1021 2
a1022 2
			   const char *name, const char *linkage_name,
			   const domain_enum domain,
d1035 1
a1035 1
    sym = lookup_block_symbol (block, name, linkage_name, domain);
d1055 2
a1056 2
			    const char *linkage_name,
			    const domain_enum domain,
d1070 1
a1070 2
	&& lookup_partial_symbol (ps, name, linkage_name,
				  psymtab_index, domain))
d1075 1
a1075 1
	sym = lookup_block_symbol (block, name, linkage_name, domain);
d1092 1
a1092 1
	    sym = lookup_block_symbol (block, name, linkage_name, domain);
d1107 169
a1275 1
#if 0
a1280 13
/* NOTE: carlton/2002-12-05: At one point, this function was part of
   lookup_symbol_aux, and what are now 'return' statements within
   lookup_symbol_aux_minsyms returned from lookup_symbol_aux, even if
   sym was NULL.  As far as I can tell, this was basically accidental;
   it didn't happen every time that msymbol was non-NULL, but only if
   some additional conditions held as well, and it caused problems
   with HP-generated symbol tables.  */

/* NOTE: carlton/2003-05-14: This function was once used as part of
   lookup_symbol.  It is currently unnecessary for correctness
   reasons, however, and using it doesn't seem to be any faster than
   using lookup_symbol_aux_psymtabs, so I'm commenting it out.  */

d1282 3
a1284 4
lookup_symbol_aux_minsyms (const char *name,
			   const char *linkage_name,
			   const domain_enum domain,
			   int *is_a_field_of_this,
d1293 1
a1293 1
  if (domain == VAR_DOMAIN)
a1295 1

d1308 24
a1331 1
	  /* We first use the address in the msymbol to try to locate
d1341 1
a1341 1
	      block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
d1343 1
a1343 1
	      /* This call used to pass `SYMBOL_LINKAGE_NAME (msymbol)' as the
d1349 1
a1349 9
		lookup_block_symbol (block, name, linkage_name, domain);
	      /* We kept static functions in minimal symbol table as well as
	         in static scope. We want to find them in the symbol table. */
	      if (!sym)
		{
		  block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
		  sym = lookup_block_symbol (block, name,
					     linkage_name, domain);
		}
d1351 9
a1359 20
	      /* NOTE: carlton/2002-12-04: The following comment was
		 taken from a time when two versions of this function
		 were part of the body of lookup_symbol_aux: this
		 comment was taken from the version of the function
		 that was #ifdef HPUXHPPA, and the comment was right
		 before the 'return NULL' part of lookup_symbol_aux.
		 (Hence the "Fall through and return 0" comment.)
		 Elena did some digging into the situation for
		 Fortran, and she reports:

		 "I asked around (thanks to Jeff Knaggs), and I think
		 the story for Fortran goes like this:

		 "Apparently, in older Fortrans, '_' was not part of
		 the user namespace.  g77 attached a final '_' to
		 procedure names as the exported symbols for linkage
		 (foo_) , but the symbols went in the debug info just
		 like 'foo'. The rationale behind this is not
		 completely clear, and maybe it was done to other
		 symbols as well, not just procedures."  */
d1361 1
a1361 2
	      /* If we get here with sym == 0, the symbol was 
	         found in the minimal symbol table
d1363 1
a1363 5
	         Fall through and return 0 to use the msymbol 
	         definition of "foo_".
	         (Note that outer code generally follows up a call
	         to this routine with a call to lookup_minimal_symbol(),
	         so a 0 return means we'll just flow into that other routine).
d1374 1
a1374 1
	      if (symtab != NULL && sym != NULL)
d1378 12
d1395 7
a1401 98
#endif /* 0 */

/* A default version of lookup_symbol_nonlocal for use by languages
   that can't think of anything better to do.  This implements the C
   lookup rules.  */

struct symbol *
basic_lookup_symbol_nonlocal (const char *name,
			      const char *linkage_name,
			      const struct block *block,
			      const domain_enum domain,
			      struct symtab **symtab)
{
  struct symbol *sym;

  /* NOTE: carlton/2003-05-19: The comments below were written when
     this (or what turned into this) was part of lookup_symbol_aux;
     I'm much less worried about these questions now, since these
     decisions have turned out well, but I leave these comments here
     for posterity.  */

  /* NOTE: carlton/2002-12-05: There is a question as to whether or
     not it would be appropriate to search the current global block
     here as well.  (That's what this code used to do before the
     is_a_field_of_this check was moved up.)  On the one hand, it's
     redundant with the lookup_symbol_aux_symtabs search that happens
     next.  On the other hand, if decode_line_1 is passed an argument
     like filename:var, then the user presumably wants 'var' to be
     searched for in filename.  On the third hand, there shouldn't be
     multiple global variables all of which are named 'var', and it's
     not like decode_line_1 has ever restricted its search to only
     global variables in a single filename.  All in all, only
     searching the static block here seems best: it's correct and it's
     cleanest.  */

  /* NOTE: carlton/2002-12-05: There's also a possible performance
     issue here: if you usually search for global symbols in the
     current file, then it would be slightly better to search the
     current global block before searching all the symtabs.  But there
     are other factors that have a much greater effect on performance
     than that one, so I don't think we should worry about that for
     now.  */

  sym = lookup_symbol_static (name, linkage_name, block, domain, symtab);
  if (sym != NULL)
    return sym;

  return lookup_symbol_global (name, linkage_name, domain, symtab);
}

/* Lookup a symbol in the static block associated to BLOCK, if there
   is one; do nothing if BLOCK is NULL or a global block.  */

struct symbol *
lookup_symbol_static (const char *name,
		      const char *linkage_name,
		      const struct block *block,
		      const domain_enum domain,
		      struct symtab **symtab)
{
  const struct block *static_block = block_static_block (block);

  if (static_block != NULL)
    return lookup_symbol_aux_block (name, linkage_name, static_block,
				    domain, symtab);
  else
    return NULL;
}

/* Lookup a symbol in all files' global blocks (searching psymtabs if
   necessary).  */

struct symbol *
lookup_symbol_global (const char *name,
		      const char *linkage_name,
		      const domain_enum domain,
		      struct symtab **symtab)
{
  struct symbol *sym;

  sym = lookup_symbol_aux_symtabs (GLOBAL_BLOCK, name, linkage_name,
				   domain, symtab);
  if (sym != NULL)
    return sym;

  return lookup_symbol_aux_psymtabs (GLOBAL_BLOCK, name, linkage_name,
				     domain, symtab);
}

/* Look, in partial_symtab PST, for symbol whose natural name is NAME.
   If LINKAGE_NAME is non-NULL, check in addition that the symbol's
   linkage name matches it.  Check the global symbols if GLOBAL, the
   static symbols if not */

struct partial_symbol *
lookup_partial_symbol (struct partial_symtab *pst, const char *name,
		       const char *linkage_name, int global,
		       domain_enum domain)
d1405 1
a1405 1
  struct partial_symbol **top, **real_top, **bottom, **center;
d1422 3
a1424 4
         pointing at the earliest partial symbol whose name might be
         correct.  At that point *all* partial symbols with an
         appropriate name will be checked against the correct
         domain.  */
a1427 1
      real_top = top;
d1438 1
a1438 1
	  if (strcmp_iw_ordered (SYMBOL_NATURAL_NAME (*center), name) >= 0)
d1450 4
a1453 4
      while (top <= real_top
	     && (linkage_name != NULL
		 ? strcmp (SYMBOL_LINKAGE_NAME (*top), linkage_name) == 0
		 : SYMBOL_MATCHES_NATURAL_NAME (*top,name)))
d1455 1
a1455 1
	  if (SYMBOL_DOMAIN (*top) == domain)
d1470 1
a1470 1
	  if (domain == SYMBOL_DOMAIN (*psym))
d1472 1
a1472 3
	      if (linkage_name != NULL
		  ? strcmp (SYMBOL_LINKAGE_NAME (*psym), linkage_name) == 0
		  : SYMBOL_MATCHES_NATURAL_NAME (*psym, name))
d1483 1
a1483 1
/* Look up a type named NAME in the struct_domain.  The type returned
d1488 1
a1488 1
   are available in struct_domain and only at file-static or global blocks. */
d1494 3
a1496 3
  struct symbol *sym;
  struct symtab *s = NULL;
  struct partial_symtab *ps;
d1498 2
a1499 2
  struct objfile *objfile;
  struct block *block;
d1510 1
a1510 1
    sym = lookup_block_symbol (block, name, NULL, STRUCT_DOMAIN);
d1519 1
a1519 2
    if (!ps->readin && lookup_partial_symbol (ps, name, NULL,
					      1, STRUCT_DOMAIN))
d1524 1
a1524 1
	sym = lookup_block_symbol (block, name, NULL, STRUCT_DOMAIN);
d1533 1
a1533 1
	    sym = lookup_block_symbol (block, name, NULL, STRUCT_DOMAIN);
d1557 1
a1557 1
    sym = lookup_block_symbol (block, name, NULL, STRUCT_DOMAIN);
d1566 1
a1566 1
    if (!ps->readin && lookup_partial_symbol (ps, name, NULL, 0, STRUCT_DOMAIN))
d1571 1
a1571 1
	sym = lookup_block_symbol (block, name, NULL, STRUCT_DOMAIN);
d1580 1
a1580 1
	    sym = lookup_block_symbol (block, name, NULL, STRUCT_DOMAIN);
d1602 2
a1603 2
  struct partial_symtab *pst;
  struct objfile *objfile;
d1607 1
a1607 1
    if (lookup_partial_symbol (pst, main_name (), NULL, 1, VAR_DOMAIN))
d1615 1
a1615 1
/* Search BLOCK for symbol NAME in DOMAIN.
d1622 3
a1624 3
   search on the symbols.  Each symbol which is marked as being a ObjC/C++
   symbol (language_cplus or language_objc set) has both the encoded and 
   non-encoded names tested for a match.
d1626 1
a1626 1
   If LINKAGE_NAME is non-NULL, verify that any symbol we find has this
d1631 19
a1649 16
lookup_block_symbol (const struct block *block, const char *name,
		     const char *linkage_name,
		     const domain_enum domain)
{
  struct dict_iterator iter;
  struct symbol *sym;

  if (!BLOCK_FUNCTION (block))
    {
      for (sym = dict_iter_name_first (BLOCK_DICT (block), name, &iter);
	   sym != NULL;
	   sym = dict_iter_name_next (name, &iter))
	{
	  if (SYMBOL_DOMAIN (sym) == domain
	      && (linkage_name != NULL
		  ? strcmp (SYMBOL_LINKAGE_NAME (sym), linkage_name) == 0 : 1))
d1657 1
a1657 1
	 list; this loop makes sure to take anything else other than
d1661 38
d1700 2
a1701 1
      struct symbol *sym_found = NULL;
a1702 8
      for (sym = dict_iter_name_first (BLOCK_DICT (block), name, &iter);
	   sym != NULL;
	   sym = dict_iter_name_next (name, &iter))
	{
	  if (SYMBOL_DOMAIN (sym) == domain
	      && (linkage_name != NULL
		  ? strcmp (SYMBOL_LINKAGE_NAME (sym), linkage_name) == 0 : 1))
	    {
d1709 1
a1709 2
		  SYMBOL_CLASS (sym) != LOC_BASEREG_ARG &&
		  SYMBOL_CLASS (sym) != LOC_COMPUTED_ARG)
d1714 29
d1744 1
a1744 1
      return (sym_found);	/* Will be NULL if not found. */
d1746 16
d1770 1
a1770 1
  struct block *b;
d1772 4
a1775 4
  struct symtab *s = NULL;
  struct symtab *best_s = NULL;
  struct partial_symtab *ps;
  struct objfile *objfile;
d1832 1
a1832 1
	    struct dict_iterator iter;
d1835 1
a1835 1
	    ALL_BLOCK_SYMBOLS (b, iter, sym)
d1841 1
a1841 1
	    if (sym == NULL)
d1878 88
d1984 1
a1984 1
find_pc_sect_line (CORE_ADDR pc, struct bfd_section *section, int notcurrent)
d1987 4
a1990 4
  struct linetable *l;
  int len;
  int i;
  struct linetable_entry *item;
d2080 1
a2080 2
	mfunsym = lookup_minimal_symbol_text (SYMBOL_LINKAGE_NAME (msymbol),
					      NULL);
d2091 1
a2091 1
	  /* warning ("In stub for %s; unable to find real function/line info", SYMBOL_LINKAGE_NAME (msymbol)) */ ;
d2096 1
a2096 1
	  /* warning ("In stub for %s; unable to find real function/line info", SYMBOL_LINKAGE_NAME (msymbol)) */ ;
d2162 1
a2162 3
         If so, record this file, and its best line, as best so far.  Don't
         save prev if it represents the end of a function (i.e. line number
         0) instead of a real line.  */
d2164 1
a2164 1
      if (prev && prev->line && (!best || prev->pc > best->pc))
d2291 1
a2291 1
	if (strcmp (symtab->filename, s->filename) != 0)
d2397 1
a2397 1
find_line_common (struct linetable *l, int lineno,
d2400 2
a2401 2
  int i;
  int len;
d2418 1
a2418 1
      struct linetable_entry *item = &(l->item[i]);
d2480 4
d2496 1
d2526 1
a2526 1
      char *q = p + 1;
d2716 3
a2718 3
  struct symtab *s;
  struct partial_symtab *ps;
  struct objfile *objfile;
d2800 2
a2801 2
  return strcmp (SYMBOL_PRINT_NAME ((*sym_a)->symbol),
		 SYMBOL_PRINT_NAME ((*sym_b)->symbol));
d2843 4
a2846 4
   FUNCTIONS_DOMAIN - search all functions
   TYPES_DOMAIN     - search all type names
   METHODS_DOMAIN   - search all methods NOT IMPLEMENTED
   VARIABLES_DOMAIN - search all symbols, excluding functions, type names,
d2855 1
a2855 1
search_symbols (char *regexp, domain_enum kind, int nfiles, char *files[],
d2858 3
a2860 3
  struct symtab *s;
  struct partial_symtab *ps;
  struct blockvector *bv;
d2862 4
a2865 4
  struct block *b;
  int i = 0;
  struct dict_iterator iter;
  struct symbol *sym;
d2892 2
a2893 2
  if (kind < VARIABLES_DOMAIN)
    error ("must search on specific domain");
d2895 4
a2898 4
  ourtype = types[(int) (kind - VARIABLES_DOMAIN)];
  ourtype2 = types2[(int) (kind - VARIABLES_DOMAIN)];
  ourtype3 = types3[(int) (kind - VARIABLES_DOMAIN)];
  ourtype4 = types4[(int) (kind - VARIABLES_DOMAIN)];
d2978 2
a2979 3
		&& ((regexp == NULL
		     || re_exec (SYMBOL_NATURAL_NAME (*psym)) != 0)
		    && ((kind == VARIABLES_DOMAIN && SYMBOL_CLASS (*psym) != LOC_TYPEDEF
d2981 3
a2983 3
			|| (kind == FUNCTIONS_DOMAIN && SYMBOL_CLASS (*psym) == LOC_BLOCK)
			|| (kind == TYPES_DOMAIN && SYMBOL_CLASS (*psym) == LOC_TYPEDEF)
			|| (kind == METHODS_DOMAIN && SYMBOL_CLASS (*psym) == LOC_BLOCK))))
d3006 1
a3006 1
  if (nfiles == 0 && (kind == VARIABLES_DOMAIN || kind == FUNCTIONS_DOMAIN))
d3015 1
a3015 2
	    if (regexp == NULL
		|| re_exec (SYMBOL_NATURAL_NAME (msymbol)) != 0)
d3019 2
a3020 8
		    /* FIXME: carlton/2003-02-04: Given that the
		       semantics of lookup_symbol keeps on changing
		       slightly, it would be a nice idea if we had a
		       function lookup_symbol_minsym that found the
		       symbol associated to a given minimal symbol (if
		       any).  */
		    if (kind == FUNCTIONS_DOMAIN
			|| lookup_symbol (SYMBOL_LINKAGE_NAME (msymbol),
d3022 1
a3022 1
					  VAR_DOMAIN,
d3045 1
a3045 1
	  ALL_BLOCK_SYMBOLS (b, iter, sym)
d3049 2
a3050 3
		  && ((regexp == NULL
		       || re_exec (SYMBOL_NATURAL_NAME (sym)) != 0)
		      && ((kind == VARIABLES_DOMAIN && SYMBOL_CLASS (sym) != LOC_TYPEDEF
d3053 3
a3055 3
			  || (kind == FUNCTIONS_DOMAIN && SYMBOL_CLASS (sym) == LOC_BLOCK)
			  || (kind == TYPES_DOMAIN && SYMBOL_CLASS (sym) == LOC_TYPEDEF)
			  || (kind == METHODS_DOMAIN && SYMBOL_CLASS (sym) == LOC_BLOCK))))
d3094 1
a3094 1
  if (found_misc || kind != FUNCTIONS_DOMAIN)
d3103 1
a3103 2
	    if (regexp == NULL
		|| re_exec (SYMBOL_NATURAL_NAME (msymbol)) != 0)
d3106 1
a3106 1
		if (kind != FUNCTIONS_DOMAIN ||
d3110 2
a3111 2
		    if (lookup_symbol (SYMBOL_LINKAGE_NAME (msymbol),
				       (struct block *) NULL, VAR_DOMAIN,
d3146 1
a3146 1
print_symbol_info (domain_enum kind, struct symtab *s, struct symbol *sym,
d3156 1
a3156 1
  if (kind != TYPES_DOMAIN && block == STATIC_BLOCK)
d3160 2
a3161 2
  if (kind == TYPES_DOMAIN
      && SYMBOL_DOMAIN (sym) != STRUCT_DOMAIN)
d3164 3
a3166 3
  else if (kind < TYPES_DOMAIN ||
	   (kind == TYPES_DOMAIN &&
	    SYMBOL_DOMAIN (sym) == STRUCT_DOMAIN))
d3170 1
a3170 1
		   ? "" : SYMBOL_PRINT_NAME (sym)),
d3175 24
d3217 1
a3217 1
		   tmp, SYMBOL_PRINT_NAME (msymbol));
d3226 1
a3226 1
symtab_symbol_info (char *regexp, domain_enum kind, int from_tty)
d3244 1
a3244 1
		   classnames[(int) (kind - VARIABLES_DOMAIN)], regexp);
d3276 1
a3276 1
  symtab_symbol_info (regexp, VARIABLES_DOMAIN, from_tty);
d3282 1
a3282 1
  symtab_symbol_info (regexp, FUNCTIONS_DOMAIN, from_tty);
d3289 9
a3297 1
  symtab_symbol_info (regexp, TYPES_DOMAIN, from_tty);
d3299 1
d3316 1
a3316 1
  search_symbols (regexp, FUNCTIONS_DOMAIN, 0, (char **) NULL, &ss);
d3323 3
a3325 3
	  char *string = alloca (strlen (p->symtab->filename)
				 + strlen (SYMBOL_LINKAGE_NAME (p->symbol))
				 + 4);
d3328 1
a3328 1
	  strcat (string, SYMBOL_LINKAGE_NAME (p->symbol));
d3331 1
a3331 1
	  print_symbol_info (FUNCTIONS_DOMAIN,
d3339 1
a3339 1
	  break_command (SYMBOL_LINKAGE_NAME (p->msymbol), from_tty);
d3341 1
a3341 1
			   SYMBOL_PRINT_NAME (p->msymbol));
d3349 103
d3459 5
d3465 5
a3469 1
	(SYMBOL_NATURAL_NAME (symbol), (sym_text), (len), (text), (word))
a3523 106
/* ObjC: In case we are completing on a selector, look as the msymbol
   again and feed all the selectors into the mill.  */

static void
completion_list_objc_symbol (struct minimal_symbol *msymbol, char *sym_text,
			     int sym_text_len, char *text, char *word)
{
  static char *tmp = NULL;
  static unsigned int tmplen = 0;
    
  char *method, *category, *selector;
  char *tmp2 = NULL;
    
  method = SYMBOL_NATURAL_NAME (msymbol);

  /* Is it a method?  */
  if ((method[0] != '-') && (method[0] != '+'))
    return;

  if (sym_text[0] == '[')
    /* Complete on shortened method method.  */
    completion_list_add_name (method + 1, sym_text, sym_text_len, text, word);
    
  while ((strlen (method) + 1) >= tmplen)
    {
      if (tmplen == 0)
	tmplen = 1024;
      else
	tmplen *= 2;
      tmp = xrealloc (tmp, tmplen);
    }
  selector = strchr (method, ' ');
  if (selector != NULL)
    selector++;
    
  category = strchr (method, '(');
    
  if ((category != NULL) && (selector != NULL))
    {
      memcpy (tmp, method, (category - method));
      tmp[category - method] = ' ';
      memcpy (tmp + (category - method) + 1, selector, strlen (selector) + 1);
      completion_list_add_name (tmp, sym_text, sym_text_len, text, word);
      if (sym_text[0] == '[')
	completion_list_add_name (tmp + 1, sym_text, sym_text_len, text, word);
    }
    
  if (selector != NULL)
    {
      /* Complete on selector only.  */
      strcpy (tmp, selector);
      tmp2 = strchr (tmp, ']');
      if (tmp2 != NULL)
	*tmp2 = '\0';
	
      completion_list_add_name (tmp, sym_text, sym_text_len, text, word);
    }
}

/* Break the non-quoted text based on the characters which are in
   symbols. FIXME: This should probably be language-specific. */

static char *
language_search_unquoted_string (char *text, char *p)
{
  for (; p > text; --p)
    {
      if (isalnum (p[-1]) || p[-1] == '_' || p[-1] == '\0')
	continue;
      else
	{
	  if ((current_language->la_language == language_objc))
	    {
	      if (p[-1] == ':')     /* might be part of a method name */
		continue;
	      else if (p[-1] == '[' && (p[-2] == '-' || p[-2] == '+'))
		p -= 2;             /* beginning of a method name */
	      else if (p[-1] == ' ' || p[-1] == '(' || p[-1] == ')')
		{                   /* might be part of a method name */
		  char *t = p;

		  /* Seeing a ' ' or a '(' is not conclusive evidence
		     that we are in the middle of a method name.  However,
		     finding "-[" or "+[" should be pretty un-ambiguous.
		     Unfortunately we have to find it now to decide.  */

		  while (t > text)
		    if (isalnum (t[-1]) || t[-1] == '_' ||
			t[-1] == ' '    || t[-1] == ':' ||
			t[-1] == '('    || t[-1] == ')')
		      --t;
		    else
		      break;

		  if (t[-1] == '[' && (t[-2] == '-' || t[-2] == '+'))
		    p = t - 2;      /* method name detected */
		  /* else we leave with p unchanged */
		}
	    }
	  break;
	}
    }
  return p;
}


d3534 7
a3540 8
  struct symbol *sym;
  struct symtab *s;
  struct partial_symtab *ps;
  struct minimal_symbol *msymbol;
  struct objfile *objfile;
  struct block *b, *surrounding_static_block = 0;
  struct dict_iterator iter;
  int j;
a3645 2
    
    completion_list_objc_symbol (msymbol, sym_text, sym_text_len, text, word);
d3661 1
a3661 1
      ALL_BLOCK_SYMBOLS (b, iter, sym)
a3662 1
	  QUIT;
d3691 1
a3691 1
    ALL_BLOCK_SYMBOLS (b, iter, sym)
d3704 1
a3704 1
    ALL_BLOCK_SYMBOLS (b, iter, sym)
d3719 4
a3722 4
  struct symbol *sym;
  struct symtab *s;
  struct block *b;
  struct dict_iterator iter;
d3768 10
a3777 2
	/* Not a quoted string.  */
	sym_text = language_search_unquoted_string (text, p);
d3809 1
a3809 1
  ALL_BLOCK_SYMBOLS (b, iter, sym)
d3815 1
a3815 1
  ALL_BLOCK_SYMBOLS (b, iter, sym)
d3890 3
a3892 3
  struct symtab *s;
  struct partial_symtab *ps;
  struct objfile *objfile;
d4056 220
d4350 7
@


1.70.4.6
log
@Merge from mainline.
@
text
@d3871 1
a3871 1
			(char ***) NULL, NULL);
@


1.70.4.7
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d4 1
a4 1
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d488 1
a488 1
   is used, and the memory comes from that objfile's objfile_obstack.
d575 1
a575 1
      *slot = obstack_alloc (&objfile->objfile_obstack,
d1483 1
a1483 2
   must not be opaque -- i.e., must have at least one field
   defined.  */
d1485 3
a1487 5
struct type *
lookup_transparent_type (const char *name)
{
  return current_language->la_lookup_transparent_type (name);
}
a1488 5
/* The standard implementation of lookup_transparent_type.  This code
   was modeled on lookup_symbol -- the parts not relevant to looking
   up types were just left out.  In particular it's assumed here that
   types are available in struct_domain and only at file-static or
   global blocks.  */
d1491 1
a1491 1
basic_lookup_transparent_type (const char *name)
@


1.70.2.1
log
@2002-09-18  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h: Delete BLOCK_SHOULD_SORT.
	* symtab.c (lookup_block_symbol): Assume non-hashed blocks aren't
	sorted.
	* ada-lang.c (ada_add_block_symbols): Ditto.
	* symfile.h: Delete prototypes for sort_block_syms and
	sort_symtab_syms.
	* symfile.c: Delete functions sort_block_syms and
	sort_symtab_syms.
	* coffread.c (coff_symfile_read): Remove call to
	sort_symtab_syms.
	* xcoffread.c (xcoff_psymtab_to_symtab_1): Ditto.
	* mdebugread.c (psymtab_to_symtab_1): Ditto.
	* hpread.c (hpread_psymtab_to_symtab_1): Ditto.
	* dwarfread.c (psymtab_to_symtab_1): Ditto.
	* dwarf2read.c (psymtab_to_symtab_1): Ditto.
	* dbxread.c (dbx_psymtab_to_symtab_1): Ditto.

2002-09-20  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (c-lang.o): Correct dependencies.
	(utils.o): Gather dependencies.
	(charset.o): Move.
@
text
@d1338 1
a1338 1
  register int bot, top;
d1341 1
d1358 91
a1448 1
  else
a1449 5
      /* Note that parameter symbols do not always show up last in the
	 list.  This loop makes sure to take anything else other than
	 parameter symbols first; it only uses parameter symbols as a
	 last resort.  Note that this only takes up extra computation
	 time on a match.  */
a1454 9
	  /* If there is more than one symbol with the right name and
	     namespace, we return the first one; I believe it is now
	     impossible for us to encounter two symbols with the same
	     name and namespace here, because blocks containing
	     argument symbols are no longer sorted.  The exception is
	     for C++, where multiple functions (cloned constructors /
	     destructors, in particular) can have the same demangled
	     name.  So if we have a particular mangled name to match,
	     try to do so.  */
a1495 1
      return (sym_found);		/* Will be NULL if not found. */
d1497 1
@


1.70.2.2
log
@2002-09-23  David Carlton  <carlton@@math.stanford.edu>

	* dictionary.c (struct dict_vtbl): 'add_symbol' field.
	(add_symbol_generic): New function.
	(free_obstack): New function.
	(dict_create_hashed): New function.
	(lookup_hashed): New function.
	(iterator_first_hashed): New function.
	(iterator_hashed_advance): New function.
	(iterator_next_hashed): New function.
	* dictionary.h: A few more declarations.
	* mdebugread.c (parse_symbol): Use dict_iterator when finding
	parameters.
	* Makefile.in (valops.o): Depend on dictionary_h.
	* valops.c (value_of_this): Check empty block via dict_empty.
	#include "dictionary.h"
	* symfile.c (free_named_symtabs): Check empty block via dict_empty.
	* dictionary.h: Declare dict_empty.
	* symmisc.c (dump_symtab): Don't print out number of
	symbols/buckets.
	* printcmd.c (print_frame_args): Delete assertion that block isn't
	a hashtable.
	* symmisc.c (free_symtab_block): Update to use dictionary
	methods.
	* symtab.h (struct symtab): Comment on free_contents.
	* jv-lang.c (get_java_class_symtab): Set class_symtab->free_code.
	* mdebugread.c (add_symbol): Delete 'nsyms' variable.
	(fixup_sigtramp): Add symbol via dict_add_symbol_block.
	* Makefile.in (mi-cmd-stack.o): Depend on dictionary_h.
	* ada-lang.c (symtab_for_sym): Update uses of ALL_BLOCK_SYMBOLS.
	(ada_add_block_symbols): Ditto.
	(debug_print_block): Ditto.
	(fill_in_ada_prototype): Ditto.
	* breakpoint.c (get_catch_sals): Ditto.
	* coffread.c (patch_opaque_types): Ditto.
	* tracepoint.c (add_local_symbols): Ditto.
	(scope_info): Ditto.
	* symtab.c (find_pc_sect_symtab): Ditto.
	(search_symbols): Ditto.
	(make_symbol_completion_list): Ditto.
	(find_addr_symbol): Ditto.
	(make_file_symbol_completion_list): Ditto.
	(make_symbol_overload_list): Ditto.
	* symmisc.c (dump_symtab): Ditto.
	* stack.c (print_block_frame_locals): Ditto.
	(print_block_frame_labels): Ditto.
	(print_frame_arg_vars): Ditto.
	* printcmd.c (print_frame_args): Ditto.
	* objfiles.c (objfile_relocate): Ditto.
	* mdebugread.c (mylookup_symbol): Ditto.
	* Makefile.in (ada-lang.o): Depend on dictionary_h.
	* Makefile.in (tracepoint.o): Ditto.
	* Makefile.in (symmisc.o): Ditto.
	* Makefile.in (stack.o): Ditto.
	* Makefile.in (printcmd.o): Ditto.
	* Makefile.in (objfiles.o): Ditto.
	* Makefile.in (coffread.o): Ditto.
	* Makefile.in (breakpoint.o): Ditto.
	* ada-lang.c: #include "dictionary.h"
	* tracepoint.c: Ditto.
	* symmisc.c: Ditto.
	* stack.c: Ditto.
	* printcmd.c: Ditto.
	* objfiles.c: Ditto.
	* coffread.c: Ditto.
	* breakpoint.c: Ditto.
	* symtab.h: Comment out ALL_BLOCK_SYMBOLS.  (Moved to
	dictionary.h.)
	* dictionary.c: Dict_iterator accessor macros.
	(struct dict_vtbl): Add iterator_first, iterator_next.
	(dict_iterator_first): New function.
	(dict_iterator_next): New function.
	(iterator_first_block): New function.
	(iterator_next_block): New function.
	(iterator_block_hashed_advance): New function.
	* dictionary.h: Add dict_iterator stuff.
	* Makefile.in (symtab.o): Depend on dictionary_h.
	* symtab.c: #include "dictionary.h"
	* dictionary.c: Move down #include "dictionary.h", for now...
	(free_block): Rename from dict_free_block.
	(struct dict_vtbl): Add LOOKUP member.
	(dict_lookup): New function.
	(lookup_block): New function.
	* dictionary.h: Declare dict_lookup.
	* symtab.c (lookup_block_symbol): Use dict_lookup.

2002-09-23  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c (list_args_or_locals): Update use of
	ALL_BLOCK_SYMBOLS.
	#include "dictionary.h"
@
text
@a42 1
#include "dictionary.h"
d1338 83
a1420 1
  dict_lookup (BLOCK_DICT (block), name, mangled_name, namespace);
d1535 1
a1535 1
	    struct dict_iterator iter;
d1538 1
a1538 1
	    ALL_BLOCK_SYMBOLS (b, iter, sym)
d1544 1
a1544 1
	    if ((sym == NULL))
d1595 1
a1595 1
  struct dict_iterator iter;
d1616 1
a1616 1
	ALL_BLOCK_SYMBOLS (block, iter, sym)
d2567 1
a2567 1
  struct dict_iterator iter;
d2748 1
a2748 1
	  ALL_BLOCK_SYMBOLS (b, iter, sym)
d3153 1
a3153 2
  struct dict_iterator iter;
  register int j;
d3274 1
a3274 1
      ALL_BLOCK_SYMBOLS (b, iter, sym)
d3304 1
a3304 1
    ALL_BLOCK_SYMBOLS (b, iter, sym)
d3317 1
a3317 1
    ALL_BLOCK_SYMBOLS (b, iter, sym)
d3335 1
a3335 1
  struct dict_iterator iter;
d3422 1
a3422 1
  ALL_BLOCK_SYMBOLS (b, iter, sym)
d3428 1
a3428 1
  ALL_BLOCK_SYMBOLS (b, iter, sym)
d3779 1
a3779 1
  struct dict_iterator iter;
d3851 1
a3851 1
      ALL_BLOCK_SYMBOLS (b, iter, sym)
d3864 1
a3864 1
    ALL_BLOCK_SYMBOLS (b, iter, sym)
d3877 1
a3877 1
    ALL_BLOCK_SYMBOLS (b, iter, sym)
@


1.70.2.3
log
@2002-09-26  David Carlton  <carlton@@math.stanford.edu>

	* dictionary.c (dict_iter_name_first): New function.
	(dict_iter_name_next): New function.
	Initialize new members of dict_hashed_vtbl, dict_linear_vtbl, and
	dict_linear_expandable_vtbl.
	(iter_name_first_hashed): New function.
	(iter_name_next_hashed): New function.
	(iter_name_first_linear): New function.
	(iter_name_next_linear): New function.
	(lookup_hashed): Rewrite following new declaration/semantics.
	(lookup_linear): Ditto.
	(dict_lookup): Ditto.
	* symtab.c (lookup_block_symbol): Rewrite to use
	dict_iter_name_first and dict_iter_name_next instead of
	dict_lookup.
	* dictionary.c (struct dict_vtbl): Change member 'lookup'; new
	members 'iter_name_first' and 'iter_name_next'.
	* dictionary.h: Delete all traces of block stuff.
	Change declaration for dict_lookup; new declarations
	dict_iter_name_first and dict_iter_name_next.
	* dictionary.c: Delete all traces of block stuff.
	* symtab.h (SYMBOL_BEST_NAME): New macro.
	(SYMBOL_SOURCE_NAME): Rewrite in terms of SYMBOL_BEST_NAME.
	(SYMBOL_LINKAGE_NAME): Ditto.
	Comment questioning SYMBOL_MATCHES_NAME and
	SYMBOL_MATCHES_REGEXP.
	* Makefile.in (ns32knbsd-tdep.o): Depend on gdb_string_h.
	* ns32knbsd-tdep.c: #include "gdb_string.h"
@
text
@a1333 11
/* FIXME: carlton/2002-09-26: I've slightly changed the semantics: I
   replaced a call to SYMBOL_MATCHES_NAME (sym, name) with a call to
   strcmp_iw (SYMBOL_BEST_NAME (sym), name) (inside the dict_iter_name
   functions).  I think this is okay: the only situations where the
   new behavior should differ from the old behavior are where NAME is
   mangled (which shouldn't happen, right??? lookup_symbol always
   tries to demangle appropriately) or where the symbol we find
   doesn't have a demangled name and where the symbol's name is such
   that strcmp and strcmp_iw don't match on it (which seems unlikely
   to me).  */

d1339 1
a1339 73
  struct dict_iterator iter;
  struct symbol *sym;

  if (!BLOCK_FUNCTION (block))
    {
      for (sym = dict_iter_name_first (BLOCK_DICT (block), name, &iter);
	   sym;
	   sym = dict_iter_name_next (name, &iter))
	{
	  if (SYMBOL_NAMESPACE (sym) == namespace 
	      && (mangled_name
		  ? strcmp (SYMBOL_NAME (sym), mangled_name) == 0
		  : 1))
	    return sym;
	}
      return NULL;
    }
  else
    {
      /* Note that parameter symbols do not always show up last in the
	 list.  This loop makes sure to take anything else other than
	 parameter symbols first; it only uses parameter symbols as a
	 last resort.  Note that this only takes up extra computation
	 time on a match.  */
      
      struct symbol *sym_found = NULL;

      for (sym = dict_iter_name_first (BLOCK_DICT (block), name, &iter);
	   sym;
	   sym = dict_iter_name_next (name, &iter))
	{
	  if (SYMBOL_NAMESPACE (sym) == namespace
	      && (mangled_name
		  ? strcmp (SYMBOL_NAME (sym), mangled_name) == 0
		  : 1))
	    {
	      /* If SYM has aliases, then use any alias that is active
	         at the current PC.  If no alias is active at the current
	         PC, then use the main symbol.

	         ?!? Is checking the current pc correct?  Is this routine
	         ever called to look up a symbol from another context?

		 FIXME: No, it's not correct.  If someone sets a
		 conditional breakpoint at an address, then the
		 breakpoint's `struct expression' should refer to the
		 `struct symbol' appropriate for the breakpoint's
		 address, which may not be the PC.

		 Even if it were never called from another context,
		 it's totally bizarre for lookup_symbol's behavior to
		 depend on the value of the inferior's current PC.  We
		 should pass in the appropriate PC as well as the
		 block.  The interface to lookup_symbol should change
		 to require the caller to provide a PC.  */

	      if (SYMBOL_ALIASES (sym))
		sym = find_active_alias (sym, read_pc ());

	      sym_found = sym;
	      if (SYMBOL_CLASS (sym) != LOC_ARG &&
		  SYMBOL_CLASS (sym) != LOC_LOCAL_ARG &&
		  SYMBOL_CLASS (sym) != LOC_REF_ARG &&
		  SYMBOL_CLASS (sym) != LOC_REGPARM &&
		  SYMBOL_CLASS (sym) != LOC_REGPARM_ADDR &&
		  SYMBOL_CLASS (sym) != LOC_BASEREG_ARG)
		{
		  break;
		}
	    }
	}
      return (sym_found);		/* Will be NULL if not found. */
    }
@


1.70.2.4
log
@2002-09-30  David Carlton  <carlton@@math.stanford.edu>

	* dictionary.h: Augment comment above dict_lookup.
	* dictionary.c (struct dict_vtbl): Delete 'lookup' member, and
	move add_symbol to precede the iterators.
	Make corresponding changes to dict_hashed_vtbl, dict_linear_vtbl,
	dict_linear_expandable_vtbl.
	(dict_lookup): Implement by means of dict_iterator_name_first.
	(iter_name_first_hashed): Don't use lookup_hashed to implement.
	(lookup_hashed): Delete.
	(lookup_linear): Delete.
	* symtab.c (lookup_symbol_aux_global_symtabs): Delete 'block'
	argument, rename local variable 'b' to 'block', and make it point
	to a const struct block.
	(lookup_symbol_aux_minsym_non_hpuxhppa): Ditto.
	(lookup_symbol_aux_global_psymtabs): Ditto.
	(lookup_symbol_aux_static_symtabs): Ditto.
	(lookup_symbol_aux_static_psymtabs): Ditto.
	(lookup_symbol_aux_minsym_hpuxhppa): Ditto.
	(lookup_symbol_aux): Correct calls to above functions.
	(lookup_symbol_aux_minsym_non_hpuxhppa): When recursively calling
	lookup_symbol_aux, pass 'NULL' as block argument.
	(lookup_symbol_aux_minsym_hpuxhppa): Ditto.
	(lookup_symbol_aux_global_symtabs): Don't initialize objfile and
	s.
	(lookup_symbol_aux_minsym_non_hpuxhppa): Don't initialize s.
	(lookup_symbol_aux_global_psymtabs): Ditto.
	(lookup_symbol_aux_static_symtabs): Ditto.
	(lookup_symbol_aux_static_psymtabs): Ditto.
	(lookup_symbol_aux_minsym_hpuxhppa): Ditto.
	(lookup_symbol_aux_global_psymtabs): Don't initialize objfile.
	(lookup_symbol_aux_static_symtabs): Ditto.
	(lookup_symbol_aux_static_psymtabs): Ditto.
	(lookup_symbol_aux_minsym_hpuxhppa): Delete local variable
	objfile.
	(lookup_symbol_aux_static_symtabs): Delete, to be replaced by
	lookup_symbol_aux_symtabs.
	(lookup_symbol_aux_global_symtabs): Ditto.
	(lookup_symbol_aux_symtabs): New function.
	(lookup_symbol_aux_psymtabs): New function.
	(lookup_symbol_aux_global_psymtabs): Delete, to be replaced by
	lookup_symbol_aux_psymtabs.
	(lookup_symbol_aux_static_psymtabs): Ditto.
	(lookup_symbol_aux_minsym_hpuxhppa): Delete, to be replaced by
	lookup_symbol_aux_minsyms.
	(lookup_symbol_aux_minsym_non_hpuxhppa): Ditto.
	(lookup_symbol_aux_minsyms): New function.
	(lookup_symbol_aux): Replace function calls by calls to functions
	with new names.
	(lookup_symbol_aux): Search global psymtabs before minimal
	symbols.
	* Makefile.in (ppc-sysv-tdep.o): Depend on gdb_string_h.
	* ppc-sysv-tdep.c: #include "gdb_string.h".

2002-09-27  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Run through gdb_indent.sh.
	(lookup_symbol_aux): Delete code that isn't called.
	(lookup_symbol_aux): Don't declare variables 'register'.
	(lookup_symbol_aux): Move each chunk of code into its own
	function.
	(lookup_symbol_aux_local): New function.
	(lookup_symbol_aux_global_symtabs): New function.
	(lookup_symbol_aux_minsym_non_hpuxhppa): New function.
	(lookup_symbol_aux_global_psymtabs): New function.
	(lookup_symbol_aux_static_symtabs): New function.
	(lookup_symbol_aux_static_psymtabs): New function.
	(lookup_symbol_aux_minsym_hpuxhppa): New function.
	(lookup_symbol_aux_global_psymtabs): Remove embedded newlines from
	strings because CC mode can't deal with them.
	(lookup_symbol_aux_static_psymtabs): Ditto.
	(lookup_symbol_aux): Delete local variables that are now
	obsolete.
	* remote-sds.c (getmessage): Add semicolon after 'retry' label to
	pacify GCC.

2002-09-27  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (cris-tdep.o): Depend on gdb_string_h.
	(mcore-tdep.o): Ditto.
	(ns32k-tdep.o): Ditto.
	(ns32knbsd-tdep.o): Ditto.
	(sh3-rom.o): Ditto.
	(vax-tdep.o): Ditto.
	* cris-tdep.c: #include "gdb_string.h"
	* mcore-tdep.c: Ditto.
	* ns32k-tdep.c: Ditto.
	* ns32knbsd-tdep.c: Ditto.
	* sh3-rom.c: Ditto.
	* vax-tdep.c: Ditto.
@
text
@a91 26
static struct symbol *lookup_symbol_aux_local (const char *name,
					       const char *mangled_name,
					       const struct block *block,
					       const namespace_enum namespace,
					       struct symtab **symtab);

static
struct symbol *lookup_symbol_aux_symtabs (int block_index,
					  const char *name,
					  const char *mangled_name,
					  const namespace_enum namespace,
					  struct symtab **symtab);

static
struct symbol *lookup_symbol_aux_minsyms (const char *name,
					  const char *mangled_name,
					  const namespace_enum namespace,
					  int *is_a_field_of_this,
					  struct symtab **symtab);

static
struct symbol *lookup_symbol_aux_psymtabs (int block_index,
					   const char *name,
					   const char *mangled_name,
					   const namespace_enum namespace,
					   struct symtab **symtab);
d171 1
a171 1

d174 1
a174 1

d187 1
a187 1
	make_cleanup (xfree, rp);
d275 1
a275 1
	char *rp = NULL;
d278 5
a282 5
	if (pst->fullname != NULL)
	  {
	    rp = gdb_realpath (pst->fullname);
	    make_cleanup (xfree, rp);
	  }
d370 7
a376 7
  {
    mangled_name = (char *) xmalloc (mangled_name_len);
    if (is_constructor)
      mangled_name[0] = '\0';
    else
      strcpy (mangled_name, field_name);
  }
d387 1
a388 1

d402 1
a402 1
			    struct obstack *obstack)
d412 2
a413 1
      demangled = cplus_demangle (gsymbol->name, DMGL_PARAMS | DMGL_ANSI);
d415 6
a420 6
	{
	  gsymbol->language = language_cplus;
	  gsymbol->language_specific.cplus_specific.demangled_name =
	    obsavestring (demangled, strlen (demangled), obstack);
	  xfree (demangled);
	}
d422 3
a424 3
	{
	  gsymbol->language_specific.cplus_specific.demangled_name = NULL;
	}
d429 2
a430 1
	cplus_demangle (gsymbol->name, DMGL_PARAMS | DMGL_ANSI | DMGL_JAVA);
d432 6
a437 6
	{
	  gsymbol->language = language_java;
	  gsymbol->language_specific.cplus_specific.demangled_name =
	    obsavestring (demangled, strlen (demangled), obstack);
	  xfree (demangled);
	}
d439 3
a441 3
	{
	  gsymbol->language_specific.cplus_specific.demangled_name = NULL;
	}
a463 1

d466 1
d472 1
a472 1
find_pc_sect_psymtab (CORE_ADDR pc, asection * section)
d486 2
a487 1
	  || msymbol->type == mst_file_data || msymbol->type == mst_file_bss))
d500 2
a501 1
	if (!(objfile->flags & OBJF_REORDERED) && section == 0)	/* can't validate section this way */
d540 1
a540 1
		      asection * section)
d557 3
a559 3
       (pp -
	(psymtab->objfile->global_psymbols.list + psymtab->globals_offset) <
	psymtab->n_global_syms); pp++)
d581 3
a583 3
       (pp -
	(psymtab->objfile->static_psymbols.list + psymtab->statics_offset) <
	psymtab->n_static_syms); pp++)
d714 2
a715 2
      for (i = 0; i < len; i++)
	copy[i] = tolower (name[i]);
d725 1
a725 1
  return returnval;
d733 8
a740 1
  struct symbol *sym;
d744 67
a810 4
  sym = lookup_symbol_aux_local (name, mangled_name, block, namespace,
				 symtab);
  if (sym != NULL)
    return sym;
d833 13
a845 9
  sym = lookup_symbol_aux_symtabs (GLOBAL_BLOCK, name, mangled_name,
				   namespace, symtab);
  if (sym != NULL)
    return sym;

  sym = lookup_symbol_aux_psymtabs (GLOBAL_BLOCK, name, mangled_name,
				    namespace, symtab);
  if (sym != NULL)
    return sym;
d849 3
a851 10
  /* Check for the possibility of the symbol being a function or a
     mangled variable that is stored in one of the minimal symbol
     tables.  Eventually, all global symbols might be resolved in this
     way.  */

  sym = lookup_symbol_aux_minsyms (name, mangled_name,
				  namespace, is_a_field_of_this,
				  symtab);
  if (sym != NULL)
    return sym;
d853 12
a864 1
#endif
d866 14
a879 5
  /* Now search all static file-level symbols.  Not strictly correct,
     but more useful than an error.  Do the symtabs first, then check
     the psymtabs.  If a psymtab indicates the existence of the
     desired name as a file-level static, then do psymtab-to-symtab
     conversion on the fly and return the found symbol. */
d881 3
a883 9
  sym = lookup_symbol_aux_symtabs (STATIC_BLOCK, name, mangled_name,
				   namespace, symtab);
  if (sym != NULL)
    return sym;
  
  sym = lookup_symbol_aux_psymtabs (STATIC_BLOCK, name, mangled_name,
				    namespace, symtab);
  if (sym != NULL)
    return sym;
d885 2
d888 5
a892 1
#ifdef HPUXHPPA
d894 7
a900 51
  /* Check for the possibility of the symbol being a function or a
     global variable that is stored in one of the minimal symbol
     tables.  The "minimal symbol table" is built from linker-supplied
     info.

     RT: I moved this check to last, after the complete search of the
     global (p)symtab's and static (p)symtab's. For HP-generated
     symbol tables, this check was causing a premature exit from
     lookup_symbol with NULL return, and thus messing up symbol
     lookups of things like "c::f". It seems to me a check of the
     minimal symbol table ought to be a last resort in any case. I'm
     vaguely worried about the comment within
     lookup_symbol_aux_minsyms which talks about FORTRAN routines
     "foo_" though... is it saying we need to do the "minsym" check
     before the static check in this case?  */

  sym = lookup_symbol_aux_minsyms (name, mangled_name,
				  namespace, is_a_field_of_this,
				  symtab);
  if (sym != NULL)
    return sym;

#endif

  if (symtab != NULL)
    *symtab = NULL;
  return NULL;
}

/* Check to see if the symbol is defined in BLOCK or its
   superiors.  */

static struct symbol *
lookup_symbol_aux_local (const char *name, const char *mangled_name,
			 const struct block *block,
			 const namespace_enum namespace,
			 struct symtab **symtab)
{
  struct symbol *sym;
  struct objfile *objfile = NULL;
  struct blockvector *bv;
  struct block *b;
  struct symtab *s = NULL;
  
  while (block != 0)
    {
      sym = lookup_block_symbol (block, name, mangled_name, namespace);
      if (sym)
	{
	  block_found = block;
	  if (symtab != NULL)
d902 4
a905 12
	      /* Search the list of symtabs for one which contains the
	         address of the start of this block.  */
	      ALL_SYMTABS (objfile, s)
	      {
		bv = BLOCKVECTOR (s);
		b = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
		if (BLOCK_START (b) <= BLOCK_START (block)
		    && BLOCK_END (b) > BLOCK_START (block))
		  goto found;
	      }
	    found:
	      *symtab = s;
d907 3
a909 2

	  return fixup_symbol_section (sym, objfile);
a910 1
      block = BLOCK_SUPERBLOCK (block);
d913 1
a913 2
  return NULL;
}
d915 28
a942 4
/* Check to see if the symbol is defined in one of the symtabs.
   BLOCK_INDEX should be either GLOBAL_BLOCK or STATIC_BLOCK,
   depending on whether or not we want to search global symbols or
   local symbols.  */
d944 6
a949 11
static struct symbol *
lookup_symbol_aux_symtabs (int block_index,
			   const char *name, const char *mangled_name,
			   const namespace_enum namespace,
			   struct symtab **symtab)
{
  struct symbol *sym;
  struct objfile *objfile;
  struct blockvector *bv;
  const struct block *block;
  struct symtab *s;
d954 1
a954 1
    block = BLOCKVECTOR_BLOCK (bv, block_index);
a964 22
  return NULL;
}

/* Check to see if the symbol is defined in one of the partial
   symtabs.  BLOCK_INDEX should be either GLOBAL_BLOCK or
   STATIC_BLOCK, depending on whether or not we want to search global
   symbols or local symbols.  */

static struct symbol *
lookup_symbol_aux_psymtabs (int block_index, const char *name,
			    const char *mangled_name,
			    const namespace_enum namespace,
			    struct symtab **symtab)
{
  struct symbol *sym;
  struct objfile *objfile;
  struct blockvector *bv;
  const struct block *block;
  struct partial_symtab *ps;
  struct symtab *s;
  const int psymtab_index = (block_index == GLOBAL_BLOCK ? 1 : 0);

d967 1
a967 2
    if (!ps->readin
	&& lookup_partial_symbol (ps, name, psymtab_index, namespace))
d971 1
a971 1
	block = BLOCKVECTOR_BLOCK (bv, block_index);
d975 6
a980 14
	    /* This shouldn't be necessary, but as a last resort try
	       looking in the statics even though the psymtab claimed
	       the symbol was global, or vice-versa. It's possible
	       that the psymtab gets it wrong in some cases.  */

	    /* FIXME: carlton/2002-09-30: Should we really do that?
	       If that happens, isn't it likely to be a GDB error, in
	       which case we should fix the GDB error rather than
	       silently dealing with it here.  So I'd vote for
	       removing the check for the symbol in the other
	       block.  */
	    block = BLOCKVECTOR_BLOCK (bv,
				       block_index == GLOBAL_BLOCK ?
				       STATIC_BLOCK : GLOBAL_BLOCK);
d983 3
a985 2
	      error ("Internal: %s symbol `%s' found in %s psymtab but not in symtab.\n%s may be an inlined function, or may be a template function\n(if a template, try specifying an instantiation: %s<type>).",
		     block_index == GLOBAL_BLOCK ? "global" : "static",
d994 1
a994 2
  return NULL;
}
d996 3
a998 4
/* Check for the possibility of the symbol being a function or a
   mangled variable that is stored in one of the minimal symbol
   tables.  Eventually, all global symbols might be resolved in this
   way.  */
d1000 10
a1009 12
static struct symbol *
lookup_symbol_aux_minsyms (const char *name,
			   const char *mangled_name,
			   const namespace_enum namespace,
			   int *is_a_field_of_this,
			   struct symtab **symtab)
{
  struct symbol *sym;
  struct blockvector *bv;
  const struct block *block;
  struct minimal_symbol *msymbol;
  struct symtab *s;
d1016 17
a1032 16
	  /* OK, we found a minimal symbol in spite of not finding any
	     symbol. There are various possible explanations for
	     this. One possibility is the symbol exists in code not
	     compiled -g. Another possibility is that the 'psymtab'
	     isn't doing its job.  A third possibility, related to #2,
	     is that we were confused by name-mangling. For instance,
	     maybe the psymtab isn't doing its job because it only
	     know about demangled names, but we were given a mangled
	     name...  */

	  /* We first use the address in the msymbol to try to locate
	     the appropriate symtab. Note that find_pc_sect_symtab()
	     has a side-effect of doing psymtab-to-symtab expansion,
	     for the found symtab.  */
	  s = find_pc_sect_symtab (SYMBOL_VALUE_ADDRESS (msymbol),
				   SYMBOL_BFD_SECTION (msymbol));
a1034 1
	      /* This is a function which has a symtab for its address.  */
d1037 6
a1042 8

	      /* This call used to pass `SYMBOL_NAME (msymbol)' as the
	         `name' argument to lookup_block_symbol.  But the name
	         of a minimal symbol is always mangled, so that seems
	         to be clearly the wrong thing to pass as the
	         unmangled name.  */
	      sym =
		lookup_block_symbol (block, name, mangled_name, namespace);
d1049 8
a1056 1
					     mangled_name, namespace);
d1059 2
a1060 1
	      /* sym == 0 if symbol was found in the minimal symbol table
d1062 5
a1066 1
	         Return 0 to use the msymbol definition of "foo_".
d1076 1
d1078 4
a1081 4
	      if (symtab != NULL)
		*symtab = s;
	      return fixup_symbol_section (sym, s->objfile);
	    }
a1085 2
	      /* This is a mangled variable, look it up by its
	         mangled name.  */
d1087 1
a1087 1
					NULL, namespace, is_a_field_of_this,
d1093 5
a1097 1
  return NULL;
d1099 1
a1099 1

d1104 2
a1105 2
lookup_partial_symbol (struct partial_symtab *pst, const char *name,
		       int global, namespace_enum namespace)
d1112 1
a1112 1

d1120 1
a1120 1

d1136 1
a1136 2
	    internal_error (__FILE__, __LINE__,
			    "failed internal consistency check");
d1152 1
a1152 2
	internal_error (__FILE__, __LINE__,
			"failed internal consistency check");
d1155 3
a1157 3
         we don't have to force a linear search on C++. Probably holds true
         for JAVA as well, no way to check. */
      while (SYMBOL_MATCHES_NAME (*top, name))
d1161 1
a1161 1
	      return (*top);
d1171 1
a1171 1
    {
d1347 2
a1348 1
		     const char *mangled_name, const namespace_enum namespace)
d1356 2
a1357 1
	   sym; sym = dict_iter_name_next (name, &iter))
d1359 1
a1359 1
	  if (SYMBOL_NAMESPACE (sym) == namespace
d1361 2
a1362 1
		  ? strcmp (SYMBOL_NAME (sym), mangled_name) == 0 : 1))
d1370 5
a1374 5
         list.  This loop makes sure to take anything else other than
         parameter symbols first; it only uses parameter symbols as a
         last resort.  Note that this only takes up extra computation
         time on a match.  */

d1378 2
a1379 1
	   sym; sym = dict_iter_name_next (name, &iter))
d1383 2
a1384 1
		  ? strcmp (SYMBOL_NAME (sym), mangled_name) == 0 : 1))
d1393 12
a1404 12
	         FIXME: No, it's not correct.  If someone sets a
	         conditional breakpoint at an address, then the
	         breakpoint's `struct expression' should refer to the
	         `struct symbol' appropriate for the breakpoint's
	         address, which may not be the PC.

	         Even if it were never called from another context,
	         it's totally bizarre for lookup_symbol's behavior to
	         depend on the value of the inferior's current PC.  We
	         should pass in the appropriate PC as well as the
	         block.  The interface to lookup_symbol should change
	         to require the caller to provide a PC.  */
d1421 1
a1421 1
      return (sym_found);	/* Will be NULL if not found. */
d1473 1
a1473 1
find_pc_sect_symtab (CORE_ADDR pc, asection * section)
d1494 2
a1495 1
	  || msymbol->type == mst_file_data || msymbol->type == mst_file_bss))
d1520 2
a1521 1
	&& (distance == 0 || BLOCK_END (b) - BLOCK_START (b) < distance))
d1541 5
a1545 5
	    {
	      fixup_symbol_section (sym, objfile);
	      if (section == SYMBOL_BFD_SECTION (sym))
		break;
	    }
d1566 2
a1567 1
(Internal error: pc 0x%s in read in psymtab, but not in symtab.)\n", paddr_nz (pc));
d1593 1
a1593 2
find_addr_symbol (CORE_ADDR addr, struct symtab **symtabp,
		  CORE_ADDR *symaddrp)
d1619 7
a1625 7
	{
	  switch (SYMBOL_CLASS (sym))
	    {
	    case LOC_STATIC:
	    case LOC_LABEL:
	      sym_addr = SYMBOL_VALUE_ADDRESS (sym);
	      break;
d1627 12
a1638 12
	    case LOC_INDIRECT:
	      sym_addr = SYMBOL_VALUE_ADDRESS (sym);
	      /* An indirect symbol really lives at *sym_addr,
	       * so an indirection needs to be done.
	       * However, I am leaving this commented out because it's
	       * expensive, and it's possible that symbolization
	       * could be done without an active process (in
	       * case this read_memory will fail). RT
	       sym_addr = read_memory_unsigned_integer
	       (sym_addr, TARGET_PTR_BIT / TARGET_CHAR_BIT);
	       */
	      break;
d1640 3
a1642 3
	    case LOC_BLOCK:
	      sym_addr = BLOCK_START (SYMBOL_BLOCK_VALUE (sym));
	      break;
d1644 3
a1646 3
	    default:
	      continue;
	    }
d1648 11
a1658 11
	  if (sym_addr <= addr)
	    if (sym_addr > best_sym_addr)
	      {
		/* Quit if we found an exact match.  */
		best_sym = sym;
		best_sym_addr = sym_addr;
		best_symtab = symtab;
		if (sym_addr == addr)
		  goto done;
	      }
	}
d1785 1
a1785 2
	mfunsym =
	  lookup_minimal_symbol_text (SYMBOL_NAME (msymbol), NULL, NULL);
d1796 1
a1796 2
	  /* warning ("In stub for %s; unable to find real function/line info", SYMBOL_NAME(msymbol)) */
	    ;
d1801 1
a1801 2
	  /* warning ("In stub for %s; unable to find real function/line info", SYMBOL_NAME(msymbol)) */
	    ;
d1881 1
a1881 1
         use ITEM's PC as the new best_end.  */
d1883 1
a1883 1
	  && (best_end == 0 || best_end > item->pc))
d1910 2
a1911 2
         number info is available (line number is zero) then we didn't
         find any valid line information. */
d1954 1
a1954 2
find_line_symtab (struct symtab *symtab, int line, int *index,
		  int *exact_match)
d2173 2
a2174 1
      if (section_is_overlay (section) && !section_is_mapped (section))
d2241 1
a2241 1
      case '\\':		/* regexp quoting */
d2246 1
a2246 1
	    else		/* 'operator\*'  */
d2262 1
a2262 1
	else
d2316 1
a2316 2
	  error
	    ("`operator ()' must be specified without whitespace in `()'");
d2321 1
a2321 2
	  error
	    ("`operator ?:' must be specified without whitespace in `?:'");
d2326 1
a2326 2
	  error
	    ("`operator []' must be specified without whitespace in `[]'");
d2440 1
a2440 2
  printf_filtered
    ("Source files for which symbols will be read in on demand:\n\n");
d2576 12
a2587 8
  static enum minimal_symbol_type types[] =
  { mst_data, mst_text, mst_abs, mst_unknown };
  static enum minimal_symbol_type types2[] =
  { mst_bss, mst_file_text, mst_abs, mst_unknown };
  static enum minimal_symbol_type types3[] =
  { mst_file_data, mst_solib_trampoline, mst_abs, mst_unknown };
  static enum minimal_symbol_type types4[] =
  { mst_file_bss, mst_text, mst_abs, mst_unknown };
d2656 2
a2657 4
    gbound =
      objfile->global_psymbols.list + ps->globals_offset + ps->n_global_syms;
    sbound =
      objfile->static_psymbols.list + ps->statics_offset + ps->n_static_syms;
d2684 5
a2688 10
		    &&
		    ((kind == VARIABLES_NAMESPACE
		      && SYMBOL_CLASS (*psym) != LOC_TYPEDEF
		      && SYMBOL_CLASS (*psym) != LOC_BLOCK)
		     || (kind == FUNCTIONS_NAMESPACE
			 && SYMBOL_CLASS (*psym) == LOC_BLOCK)
		     || (kind == TYPES_NAMESPACE
			 && SYMBOL_CLASS (*psym) == LOC_TYPEDEF)
		     || (kind == METHODS_NAMESPACE
			 && SYMBOL_CLASS (*psym) == LOC_BLOCK))))
d2711 1
a2711 2
  if (nfiles == 0
      && (kind == VARIABLES_NAMESPACE || kind == FUNCTIONS_NAMESPACE))
d2728 1
a2728 1
					  0, (struct symtab **) NULL) == NULL)
d2751 26
a2776 33
	  {
	    QUIT;
	    if (file_matches (s->filename, files, nfiles)
		&& ((regexp == NULL || SYMBOL_MATCHES_REGEXP (sym))
		    &&
		    ((kind == VARIABLES_NAMESPACE
		      && SYMBOL_CLASS (sym) != LOC_TYPEDEF
		      && SYMBOL_CLASS (sym) != LOC_BLOCK
		      && SYMBOL_CLASS (sym) != LOC_CONST)
		     || (kind == FUNCTIONS_NAMESPACE
			 && SYMBOL_CLASS (sym) == LOC_BLOCK)
		     || (kind == TYPES_NAMESPACE
			 && SYMBOL_CLASS (sym) == LOC_TYPEDEF)
		     || (kind == METHODS_NAMESPACE
			 && SYMBOL_CLASS (sym) == LOC_BLOCK))))
	      {
		/* match */
		psr =
		  (struct symbol_search *)
		  xmalloc (sizeof (struct symbol_search));
		psr->block = i;
		psr->symtab = s;
		psr->symbol = sym;
		psr->msymbol = NULL;
		psr->next = NULL;
		if (tail == NULL)
		  sr = psr;
		else
		  tail->next = psr;
		tail = psr;
		nfound++;
	      }
	  }
d2820 1
a2820 3
			psr =
			  (struct symbol_search *)
			  xmalloc (sizeof (struct symbol_search));
d2865 2
a2866 1
  if (kind == TYPES_NAMESPACE && SYMBOL_NAMESPACE (sym) != STRUCT_NAMESPACE)
d2875 2
a2876 1
		   ? "" : SYMBOL_SOURCE_NAME (sym)), gdb_stdout, 0);
d2885 2
a2886 1
      c_type_print_base (TYPE_FN_FIELD_TYPE (t, block), gdb_stdout, 0, 0);
d2916 2
a2917 1
				   & (CORE_ADDR) 0xffffffff, "08l");
d2919 4
a2922 2
    tmp = local_hex_string_custom (SYMBOL_VALUE_ADDRESS (msymbol), "016l");
  printf_filtered ("%s  %s\n", tmp, SYMBOL_SOURCE_NAME (msymbol));
d2933 3
a2935 1
  static char *classnames[] = { "variable", "function", "type", "method" };
d2967 4
a2970 1
			     p->symtab, p->symbol, p->block, last_filename);
d3038 3
a3040 1
			     p->symbol, p->block, p->symtab->filename);
d3062 2
a3063 1
  return BLOCK_START (a) >= BLOCK_START (b) && BLOCK_END (a) <= BLOCK_END (b);
d3235 2
a3236 1
		 + ps->n_global_syms); psym++)
d3240 1
a3240 2
	COMPLETION_LIST_ADD_SYMBOL (*psym, sym_text, sym_text_len, text,
				    word);
d3245 2
a3246 1
		 + ps->n_static_syms); psym++)
d3249 1
a3249 2
	COMPLETION_LIST_ADD_SYMBOL (*psym, sym_text, sym_text_len, text,
				    word);
d3271 1
a3271 1
	  surrounding_static_block = b;	/* For elmin of dups */
d3278 6
a3283 6
      {
	COMPLETION_LIST_ADD_SYMBOL (sym, sym_text, sym_text_len, text, word);
	if (SYMBOL_CLASS (sym) == LOC_TYPEDEF)
	  {
	    struct type *t = SYMBOL_TYPE (sym);
	    enum type_code c = TYPE_CODE (t);
d3285 13
a3297 14
	    if (c == TYPE_CODE_UNION || c == TYPE_CODE_STRUCT)
	      {
		for (j = TYPE_N_BASECLASSES (t); j < TYPE_NFIELDS (t); j++)
		  {
		    if (TYPE_FIELD_NAME (t, j))
		      {
			completion_list_add_name (TYPE_FIELD_NAME (t, j),
						  sym_text, sym_text_len,
						  text, word);
		      }
		  }
	      }
	  }
      }
d3308 3
a3310 3
    {
      COMPLETION_LIST_ADD_SYMBOL (sym, sym_text, sym_text_len, text, word);
    }
d3321 3
a3323 3
    {
      COMPLETION_LIST_ADD_SYMBOL (sym, sym_text, sym_text_len, text, word);
    }
d3410 1
a3410 1
         symbol tables record only its basename.  */
d3426 3
a3428 3
  {
    COMPLETION_LIST_ADD_SYMBOL (sym, sym_text, sym_text_len, text, word);
  }
d3432 3
a3434 3
  {
    COMPLETION_LIST_ADD_SYMBOL (sym, sym_text, sym_text_len, text, word);
  }
d3485 1
a3485 1
    "_globals_",		/* inserted by coff_symtab_read */
d3522 4
a3525 4
  {
    if (not_interesting_fname (s->filename))
      continue;
    if (!filename_seen (s->filename, 1, &first)
d3527 1
a3527 1
	&& strncasecmp (s->filename, text, text_len) == 0
d3529 1
a3529 1
	&& strncmp (s->filename, text, text_len) == 0
d3531 16
a3546 15
      )
      {
	/* This file matches for a completion; add it to the current
	   list of matches.  */
	add_filename_to_list (s->filename, text, word,
			      &list, &list_used, &list_alloced);
      }
    else
      {
	/* NOTE: We allow the user to type a base name when the
	   debug info records leading directories, but not the other
	   way around.  This is what subroutines of breakpoint
	   command do when they parse file names.  */
	base_name = lbasename (s->filename);
	if (base_name != s->filename && !filename_seen (base_name, 1, &first)
d3548 1
a3548 1
	    && strncasecmp (base_name, text, text_len) == 0
d3550 1
a3550 1
	    && strncmp (base_name, text, text_len) == 0
d3552 5
a3556 5
	  )
	  add_filename_to_list (base_name, text, word,
				&list, &list_used, &list_alloced);
      }
  }
d3559 6
a3564 6
  {
    if (not_interesting_fname (ps->filename))
      continue;
    if (!ps->readin)
      {
	if (!filename_seen (ps->filename, 1, &first)
d3566 1
a3566 1
	    && strncasecmp (ps->filename, text, text_len) == 0
d3568 1
a3568 1
	    && strncmp (ps->filename, text, text_len) == 0
d3570 6
a3575 6
	  )
	  {
	    /* This file matches for a completion; add it to the
	       current list of matches.  */
	    add_filename_to_list (ps->filename, text, word,
				  &list, &list_used, &list_alloced);
d3577 6
a3582 6
	  }
	else
	  {
	    base_name = lbasename (ps->filename);
	    if (base_name != ps->filename
		&& !filename_seen (base_name, 1, &first)
d3584 1
a3584 1
		&& strncasecmp (base_name, text, text_len) == 0
d3586 1
a3586 1
		&& strncmp (base_name, text, text_len) == 0
d3588 6
a3593 6
	      )
	      add_filename_to_list (base_name, text, word,
				    &list, &list_used, &list_alloced);
	  }
      }
  }
d3615 3
a3617 3
     as its own "source line".  So the ending address of that "line"
     is the end of the prologue.  If available, this is the most
     reliable method.
d3619 1
a3619 1
     us the starting and ending addresses of a function.
d3621 2
a3622 2
     architecture-defined SKIP_PROLOGUE function to analyze the
     instruction stream and guess where the prologue ends.
d3624 3
a3626 3
     best guess as to the function's entry point.  At the time of
     this writing, handle_inferior_event doesn't get this right, so
     it should be our last resort.  */
d3630 1
a3630 1
  if (!find_pc_partial_function (pc, NULL, &func_addr, &func_end))
d3636 1
a3636 1
      if (!func_start)
d3656 3
a3658 1
  if (sal.line == 0 || sal.end <= func_addr || func_end <= sal.end)
d3661 2
a3662 2
         information, together with the architecture-specific prologue
         scanning code.  */
d3696 1
a3696 1
	depth++;
d3699 1
a3699 1
	  depth--;
d3709 1
a3709 1
    argp--;
d3762 1
a3762 2
      sym_return_val =
	(struct symbol **) xrealloc ((char *) sym_return_val, newsize);
d3794 1
a3794 2
      sym_return_val =
	(struct symbol **) xmalloc (2 * sizeof (struct symbol *));
d3804 1
a3804 3
  sym_return_val =
    (struct symbol **) xmalloc ((sym_return_val_size + 1) *
				sizeof (struct symbol *));
d3821 2
a3822 1
		 + ps->n_global_syms); psym++)
d3826 2
a3827 2
	/* This will cause the symbol table to be read if it has not yet been */
	s = PSYMTAB_TO_SYMTAB (ps);
d3832 2
a3833 1
		 + ps->n_static_syms); psym++)
d3836 2
a3837 2
	/* This will cause the symbol table to be read if it has not yet been */
	s = PSYMTAB_TO_SYMTAB (ps);
d3848 1
a3848 1
	  surrounding_static_block = b;	/* For elimination of dups */
d3855 3
a3857 3
      {
	overload_list_add_symbol (sym, oload_name);
      }
d3868 3
a3870 3
    {
      overload_list_add_symbol (sym, oload_name);
    }
d3881 3
a3883 3
    {
      overload_list_add_symbol (sym, oload_name);
    }
d3898 1
a3898 1

d3901 1
a3901 1

d3903 1
a3903 1
     and get a default  or it will recursively call us! */
d3905 1
a3905 1

d3907 2
a3908 1
			cursal.symtab, cursal.line, (char ***) NULL);
d3946 1
a3946 1
	    "All global and static variable names, or those matching REGEXP.");
d3949 1
a3949 1
	     "All global and static variable names, or those matching REGEXP.");
d3954 1
a3954 1

d3963 2
a3964 1
  add_info ("types", types_info, "All type names, or those matching REGEXP.");
d3973 2
a3974 1
  add_info ("sources", sources_info, "Source files in the program.");
d3983 1
a3983 1
	       "All global and static variable names, or those matching REGEXP.");
@


1.70.2.5
log
@2002-10-07  David Carlton  <carlton@@math.stanford.edu>

	* buildsym.c (finish_block): Initialize BLOCK_USING to NULL.
	* symtab.h (struct block): Delete last remnants of non-dictionary
	symbol lists.
	(struct block): Add field 'language_specific' and accessor macro
	BLOCK_USING.
	* cp-support.h (struct using_data): New struct.
	(struct using_data_node): New struct.
@
text
@a105 6
struct symbol *lookup_symbol_aux_psymtabs (int block_index,
					   const char *name,
					   const char *mangled_name,
					   const namespace_enum namespace,
					   struct symtab **symtab);
static
d112 6
d803 2
a804 2
				   namespace, is_a_field_of_this,
				   symtab);
d846 2
a847 2
				   namespace, is_a_field_of_this,
				   symtab);
d906 1
a906 1
   static symbols.  */
d940 1
a940 1
   symbols or static symbols.  */
d975 1
a975 1
	       silently dealing with it here?  So I'd vote for
@


1.70.2.6
log
@2002-10-11  David Carlton  <carlton@@math.stanford.edu>

	* jv-lang.c (get_java_class_symtab): Initialize BLOCK_USING (bl)
	to NULL.
	* cp-support.c: Change all uses of 'struct using_data' and 'struct
	using_data_node' to 'struct using_direct' and 'struct
	using_direct_node'.
	(cp_free_usings): Fix loop.
	* symtab.c: Ditto.
	* symtab.h: Ditto
	* cp-support.h: Delete declarations for commented-out functions.
	Rename 'struct using_data' and 'struct using_data_node' to 'struct
	using_direct' and 'struct using_direct_node'.
	* cp-support.c: Delete commented-out functions.

2002-10-10  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_using_loop): New function.
	(lookup_symbol_aux_nonlocal): New function.
	(lookup_symbol_aux): Call lookup_symbol_aux_nonlocal instead of
	lookup_symbol_aux_symtabs and lookup_symbol_aux_psymtabs.

	* Makefile.in (symtab.o): Depend on $(cp_support_h).

	* symtab.c: #include "cp-support.h"

	* cp-support.h: Declare cp_copy_usings, cp_free_usings.

	* cp-support.c (cp_free_usings): New function.
	(cp_copy_usings): New function.

	* symtab.c (lookup_symbol_aux): Call lookup_symbol_aux_using to
	apply using directives.
	(lookup_symbol_aux_using): New function.

2002-10-11  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Add tests from within C::D::marker2.
	* gdb.c++/namespace.cc: Add namespace C and its contents.
@
text
@a52 1
#include "cp-support.h"
a98 7
struct symbol *lookup_symbol_aux_nonlocal (int block_index,
					   const char *name,
					   const char *mangled_name,
					   const namespace_enum namespace,
					   struct symtab **symtab);

static
a110 16

static
struct symbol *lookup_symbol_aux_using (const char *name,
					const char *mangled_name,
					const struct block *block,
					const namespace_enum namespace,
					struct symtab **symtab);

static
struct symbol *lookup_symbol_aux_using_loop (const char *prefix,
					     const char *rest,
					     struct using_direct_node *using,
					     const char *mangled_name,
					     namespace_enum namespace,
					     struct symtab **symtab);

d785 6
a790 1
  sym = lookup_symbol_aux_nonlocal (GLOBAL_BLOCK, name, mangled_name,
a794 16
  /* If we're in the C++ case, check to see if the symbol is defined
     in a namespace accessible via a "using" declaration.  */

  /* FIXME: carlton/2002-10-10: is "is_a_field_of_this" always
     non-NULL if we're in the C++ case?  Maybe we should always do
     this, and delete the two previous searches: this will always
     search the global namespace, after all.  */

  if (is_a_field_of_this)
    {
      sym = lookup_symbol_aux_using (name, mangled_name, block, namespace,
				     symtab);
      if (sym != NULL)
	return sym;
    }

d816 6
a821 1
  sym = lookup_symbol_aux_nonlocal (STATIC_BLOCK, name, mangled_name,
d826 1
a902 26
/* Check to see if the symbol is defined in one of the symtabs or
   psymtabs.  BLOCK_INDEX should be either GLOBAL_BLOCK or
   STATIC_BLOCK, depending on whether or not we want to search global
   symbols or static symbols.  */

/* FIXME: carlton/2002-10-11: Should this also do some minsym
   lookup?  */

static struct symbol *
lookup_symbol_aux_nonlocal (int block_index,
			    const char *name,
			    const char *mangled_name,
			    const namespace_enum namespace,
			    struct symtab **symtab)
{
  struct symbol *sym;

  sym = lookup_symbol_aux_symtabs (block_index, name, mangled_name,
				   namespace, symtab);
  if (sym != NULL)
    return sym;

  return lookup_symbol_aux_psymtabs (block_index, name, mangled_name,
				     namespace, symtab);
}

a993 125
}

/* This function gathers using directives from BLOCK and its
   superblocks, and then searches for symbols in the global namespace
   by trying to apply those various using directives.  */
static struct symbol *lookup_symbol_aux_using (const char *name,
					       const char *mangled_name,
					       const struct block *block,
					       const namespace_enum namespace,
					       struct symtab **symtab)
{
  struct using_direct_node *using = NULL;
  struct symbol *sym;

  while (block != NULL)
    {
      using = cp_copy_usings (BLOCK_USING (block), using);
      block = BLOCK_SUPERBLOCK (block);
    }

  sym = lookup_symbol_aux_using_loop ("", name, using, mangled_name,
				      namespace, symtab);
  cp_free_usings (using);
  
  return sym;
}

/* This tries to look up a symbol whose name is the concatenation of
   PREFIX, "::", and REST, where "::" is ommitted if PREFIX is the
   empty string, applying the various using directives given in USING.
   When applying the using directives, however, it assumes that the
   part of the name given by PREFIX is immutable, so it only adds
   symbols to namespaces whose names contain PREFIX.

   Basically, assume that we have using directives adding A to the
   global namespace, adding A::inner to namespace A, and adding B to
   the global namespace.  Then, when looking up a symbol "foo", we
   want to recurse by looking up stuff in A::foo and seeing which
   using directives still apply.  The only one that still applies
   converts that to A::inner::foo: we _don't_ want to then look at
   B::A::foo (let alone A::A::foo!).  So we end up just looking at
   A::foo, A::inner::foo, and B::foo.  (Though if the original caller
   to lookup_symbol had specified A::foo, we would want to look up
   stuff in A::A::foo, A::inner::A::foo, A::inner::foo, and
   B::A::foo).

   The reason why this treates the case of PREFIX = "" specially is to
   avoid having to create temporary strings with "::" stuck on the end
   of them.  */

/* FIXME: carlton/2002-10-11: There are still some places where this
   will return false positives.  For example, if you have namespaces
   C, C::D, C::E, and C::D::E, then, from a function defined in C::D,
   all references to variables E::var _should_ be treated as
   C::D::E::var, but this function will also see variables in
   C::E::var.  I don't think this can be fixed without making
   namespaces first-class objects.  (Which is certainly a good idea
   for other reasons, but it will take a little while.)  */

static struct symbol *
lookup_symbol_aux_using_loop (const char *prefix, const char *rest,
			      struct using_direct_node *using,
			      const char *mangled_name,
			      namespace_enum namespace,
			      struct symtab **symtab)
{
  struct using_direct_node *current;
  struct symbol *sym;
  int prefix_len = strlen (prefix);

  for (current = using; current; current = current->next)
    {
      /* First, see if the prefix matches the start of this using
	 directive.  */
      if (strncmp (prefix, current->current->outer, prefix_len) == 0)
	{
	  /* Great, it matches: now does the rest of the using
	     directive match the rest of the name?  */
	  
	  const char *rest_of_outer = current->current->outer + prefix_len;
	  /* Should we skip some colons?  */
	  if (*rest_of_outer == ':')
	    rest_of_outer += 2;
	  int rest_of_outer_len = strlen (rest_of_outer);
	  if (strncmp (rest_of_outer, rest, rest_of_outer_len) == 0)
	    {
	      /* Everything matches!  Yippee!  So apply the using
		 directive and recurse.  */
	      const char *new_rest = rest + rest_of_outer_len;
	      if (*new_rest == ':')
		new_rest += 2;

	      sym = lookup_symbol_aux_using_loop (current->current->inner,
						  new_rest,
						  using,
						  mangled_name,
						  namespace,
						  symtab);
	      if (sym != NULL)
		return sym;
	    }
	}
    }

  /* We didn't find anything by applying any of the using directives
     that are still applicable; so let's see if we've got a match
     using the current name.  */
  if (prefix_len == 0)
    {
      return lookup_symbol_aux_nonlocal (GLOBAL_BLOCK, rest, mangled_name,
					 namespace, symtab);
    }
  else
    {
      char *concatenated_name
	= xmalloc (prefix_len + 2 + strlen (rest) + 1);
      strcpy (concatenated_name, prefix);
      strcpy (concatenated_name + prefix_len, "::");
      strcpy (concatenated_name + prefix_len + 2, rest);
      sym = lookup_symbol_aux_nonlocal (GLOBAL_BLOCK, concatenated_name,
					mangled_name, namespace, symtab);

      xfree (concatenated_name);
      return sym;
    }
@


1.70.2.7
log
@2002-10-14  David Carlton  <carlton@@math.stanford.edu>

	* buildsym.c (add_using_directive): Rewrite to match new version
	of struct using_direct.
	(finish_block): Ditto.

	* symtab.c (lookup_symbol_aux_using_loop): Add 'prefix_len'
	argument; rewrite to match new version of struct using_direct.

	* cp-support.h: Update declaration for cp_add_using.

	* cp-support.c (cp_add_using): Rewrite to match new version of
	struct using_direct.

	* cp-support.h (struct using_direct): Rewrite struct.

	* buildsym.h: Declaration for add_using_directive.

	* buildsym.c: New variable 'using_list'.
	(start_symtab): Initialize using_list.
	(end_symtab): Initialize BLOCK_USING of STATIC_BLOCK.
	(scan_for_anonymous_namespaces): New function.
	(add_symbol_to_list): In C++ case, look for anonymous namespaces.
	(add_using_directive): New function.
@
text
@a128 1
					     int prefix_len,
d1069 1
a1069 1
  sym = lookup_symbol_aux_using_loop ("", 0, name, using, mangled_name,
d1076 6
a1081 2
/* This tries to look up REST in the namespace given by the initial
   substring of PREFIX of length PREFIX_LEN.
d1093 5
a1097 1
   B::A::foo).  */
d1109 1
a1109 3
lookup_symbol_aux_using_loop (const char *prefix,
			      int prefix_len,
			      const char *rest,
d1117 1
d1123 1
a1123 2
      if (prefix_len >= current->current->outer_length
	  && strncmp (prefix, current->current->name, prefix_len) == 0)
d1128 2
a1129 6
	  const char *rest_of_outer = current->current->name + prefix_len;
	  int rest_of_outer_len
	    = current->current->outer_length - prefix_len;
	  /* Should we skip some colons?  (Should always be true
	     unless PREFIX_LEN is zero (and hence we're in the global
	     namespace.)  */
d1131 2
a1132 4
	    {
	      rest_of_outer += 2;
	      rest_of_outer_len -= 2;
	    }
d1141 6
a1146 8
	      sym = lookup_symbol_aux_using_loop
		(current->current->name,
		 current->current->inner_length,
		 new_rest,
		 using,
		 mangled_name,
		 namespace,
		 symtab);
a1155 1
  
d1165 1
a1165 1
      strncpy (concatenated_name, prefix, prefix_len);
@


1.70.2.8
log
@2002-10-15  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_using_loop): prefix_len should be <=
	outer_length.
	(lookup_symbol_aux_using_loop): Don't skip colons in rest_of_outer
	if we've used all of outer.
	* cp-support.h: Rename declaration of cp_add_using to
	cp_add_using_obstack.
	* cp-support.c (cp_add_using_obstack): Rename from cp_add_using.
	* buildsym.h: Rename arguments in declaration of
	add_using_directive.
	* buildsym.c (add_using_directive): Finish definition, rename
	arguments.
	* cp-support.h: Add declaration for cp_add_using_xmalloc.
	* cp-support.c (cp_add_using_xmalloc): New function.
	* buildsym.c (copy_usings_to_obstack): New function.
	(end_symtab): Set STATIC_BLOCK's BLOCK_USING using
	copy_usings_to_obstack.

2002-10-15  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Add anonymous namespace tests.
	* gdb.c++/namespace.cc: Add anonymous namespaces.
@
text
@d1117 1
a1117 1
      if (prefix_len <= current->current->outer_length
d1126 4
a1129 4
	  /* Should we skip some colons?  Should be true unless
	     PREFIX_LEN is zero (and hence we're in the global
	     namespace) or we've finished all of outer.  */
	  if (rest_of_outer_len != 0 && *rest_of_outer == ':')
@


1.70.2.9
log
@2002-10-18  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (block_h): New variable.
	Updated dependencies to reflect it.
	* parse.c (parse_exp_1): Use BLOCK_START.
	#include "block.h"
	* p-exp.tab.c: Regenerated.
	* m2-exp.tab.c: Ditto.
	* jv-exp.tab.c: Ditto.
	* f-exp.tab.c: Ditto.
	* c-exp.tab.c: Ditto.
	* ada-exp.tab.c: Ditto.
	* ada-lang.c: #include "block.h"
	* p-exp.y: Ditto.
	* objc-exp.y: Ditto.
	* m2-exp.y: Ditto.
	* jv-exp.y: Ditto.
	* f-exp.y: Ditto.
	* c-exp.y: Ditto.
	* ada-exp.y: Ditto.
	* values.c: Ditto.
	* valops.c: Ditto.
	* tracepoint.c: Ditto.
	* symtab.c: Ditto.
	* symmisc.c: Ditto.
	* symfile.c: Ditto.
	* stack.c: Ditto.
	* printcmd.c: Ditto.
	* objfiles.c: Ditto.
	* objc-lang.c: Ditto.
	* nlmread.c: Ditto.
	* mips-tdep.c: Ditto.
	* mdebugread.c: Ditto.
	* linespec.c: Ditto.
	* jv-lang.c: Ditto.
	* infcmd.c: Ditto.
	* f-valprint.c: Ditto.
	* findvar.c: Ditto.
	* expprint.c: Ditto.
	* coffread.c: Ditto.
	* buildsym.c: Ditto.
	* breakpoint.c: Ditto.
	* blockframe.c: Ditto.
	* ax-gdb.c: Ditto.
	* alpha-tdep.c: Ditto.
	* block.h: New file.
	* symtab.h: Moved struct block, struct blockvector, and related
	macros and function declarations to block.h.
	* dwarf2read.c (process_die): Set processing_has_namespace_info if
	we run into DW_TAG_namespace, DW_TAG_imported_declaration, or
	DW_TAG_imported_module.
	New variable current_namespace.
	(psymtab_to_symtab_1): Set current_namespace to "".
	(dwarf2_name): New function.
	(dwarf2_add_member_fn): Get name via dwarf2_name.
	(read_typedef): Ditto.
	(read_file_scope): Ditto.
	(dwarf2_add_field): Ditto.
	(read_structure_scope): Ditto.
	(read_enumeration): Ditto.
	(dwarf2_extension): New function.
	(read_namespace): Set current_namespace correctly; also, if we're
	entering an anonymous namespace, add an appropriate using
	directive.
	* buildsym.c (start_symtab): Reset processing_has_namespace_info
	to 0.
	(add_symbol_to_list): Only scan for anonymous namespaces if
	!processing_has_namespace_info.
	* buildsym.h: Add new flag processing_has_namespace_info.

2002-10-18  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: #include "block.h"
@
text
@a25 1
#include "block.h"
@


1.70.2.10
log
@2002-10-22  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (scan_partial_symbols): Clarify some comments.
	* symtab.c (lookup_symbol_aux): Always call
	lookup_symbol_aux_using to search global symtabs/psymtabs.
	(lookup_symbol_aux_local): Add static_block argument.
	* buildsym.c (add_symbol_to_list): Do a quick scan for "(anonymous
	namespace)" before calling scan_for_anonymous_namespaces.
	(scan_for_anonymous_namespaces): Delete FIXME comment.
@
text
@d94 5
a98 7
static
struct symbol *lookup_symbol_aux_local (const char *name,
					const char *mangled_name,
					const struct block *block,
					const namespace_enum namespace,
					struct symtab **symtab,
					const struct block **static_block);
a781 1
  const struct block *static_block;
d783 1
a783 2
  /* Search specified block and its superiors.  Don't search
     STATIC_BLOCK or GLOBAL_BLOCK.  */
d786 1
a786 1
				 symtab, &static_block);
a805 9
  /* If there's a static block to search, search it next.  */

  if (static_block != NULL)
    {
      sym = lookup_block_symbol (static_block, name, mangled_name, namespace);
      if (sym != NULL)
	return sym;
    }

d809 1
a809 1
     conversion on the fly and return the found symbol.
d811 2
a812 12
     We do this from within lookup_symbol_aux_using: that will apply
     appropriate using directives in the C++ case.  But it works fine
     in the non-C++ case, too.  */

  /* NOTE: carlton/2002-10-22: Is it worthwhile to try to figure out
     whether or not we're in the C++ case?  Doing
     lookup_symbol_aux_using won't slow things down much at all in the
     general case, though: other parts of this function are much, much
     more expensive.  */

  sym = lookup_symbol_aux_using (name, mangled_name, block, namespace,
				 symtab);
d816 16
d889 2
a890 3
/* Check to see if the symbol is defined in BLOCK or its superiors.
   Don't search STATIC_BLOCK or GLOBAL_BLOCK.  If we don't find a
   match, store the address of STATIC_BLOCK in static_block.  */
d896 1
a896 2
			 struct symtab **symtab,
			 const struct block **static_block)
d903 2
a904 10

  /* Either no block is specified or it's a global block.  */

  if (block == NULL || BLOCK_SUPERBLOCK (block) == NULL)
    {
      *static_block = NULL;
      return NULL;
    }

  while (BLOCK_SUPERBLOCK (BLOCK_SUPERBLOCK (block)) != NULL)
a930 3
  /* We've reached the static block.  */

  *static_block = block;
@


1.70.2.11
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@d56 5
a102 7
struct symbol *lookup_symbol_aux_block (const char *name,
					const char *mangled_name,
					const struct block *block,
					const namespace_enum namespace,
					struct symtab **symtab);

static
d179 13
a440 1

a441 26
/* Initialize the language dependent portion of a symbol
   depending upon the language for the symbol. */
void
symbol_init_language_specific (struct general_symbol_info *gsymbol,
			       enum language language)
{
  gsymbol->language = language;
  if (gsymbol->language == language_cplus
      || gsymbol->language == language_java)
    {
      gsymbol->language_specific.cplus_specific.demangled_name = NULL;
    }
  else if (gsymbol->language == language_objc)
    {
      gsymbol->language_specific.objc_specific.demangled_name = NULL;
    }
  /* OBSOLETE else if (SYMBOL_LANGUAGE (symbol) == language_chill) */
  /* OBSOLETE   { */
  /* OBSOLETE     SYMBOL_CHILL_DEMANGLED_NAME (symbol) = NULL; */
  /* OBSOLETE   } */
  else
    {
      memset (&gsymbol->language_specific, 0,
	      sizeof (gsymbol->language_specific));
    }
}
a517 8
/* Return the demangled name for a symbol based on the language for
   that symbol.  If no demangled name exists, return NULL. */
char *
symbol_demangled_name (struct general_symbol_info *gsymbol)
{
  if (gsymbol->language == language_cplus
      || gsymbol->language == language_java)
    return gsymbol->language_specific.cplus_specific.demangled_name;
a518 21
  else if (gsymbol->language == language_objc)
    return gsymbol->language_specific.objc_specific.demangled_name;

  else 
    return NULL;

  /* OBSOLETE (SYMBOL_LANGUAGE (symbol) == language_chill */
  /* OBSOLETE ? SYMBOL_CHILL_DEMANGLED_NAME (symbol) */
}

/* Initialize the structure fields to zero values.  */
void
init_sal (struct symtab_and_line *sal)
{
  sal->symtab = 0;
  sal->section = 0;
  sal->line = 0;
  sal->pc = 0;
  sal->end = 0;
}

d814 1
a814 2
      sym = lookup_symbol_aux_block (name, mangled_name, static_block,
				     namespace, symtab);
d908 4
d923 22
a944 4
      sym = lookup_symbol_aux_block (name, mangled_name, block, namespace,
				     symtab);
      if (sym != NULL)
	return sym;
a953 42
/* Look up a symbol in a block; if found, locate its symtab, fixup the
   symbol, and set block_found appropriately.  */

static struct symbol *
lookup_symbol_aux_block (const char *name, const char *mangled_name,
			 const struct block *block,
			 const namespace_enum namespace,
			 struct symtab **symtab)
{
  struct symbol *sym;
  struct objfile *objfile = NULL;
  struct blockvector *bv;
  struct block *b;
  struct symtab *s = NULL;

  sym = lookup_block_symbol (block, name, mangled_name, namespace);
  if (sym)
    {
      block_found = block;
      if (symtab != NULL)
	{
	  /* Search the list of symtabs for one which contains the
	     address of the start of this block.  */
	  ALL_SYMTABS (objfile, s)
	    {
	      bv = BLOCKVECTOR (s);
	      b = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
	      if (BLOCK_START (b) <= BLOCK_START (block)
		  && BLOCK_END (b) > BLOCK_START (block))
		goto found;
	    }
	found:
	  *symtab = s;
	}
      
      return fixup_symbol_section (sym, objfile);
    }

  return NULL;
}


a1390 4
/* FIXME: carlton/2002-10-25: This function duplicates too much of
   lookup_symbol_aux's code: it's a maintenance burden.  That should
   be taken care of.  Or perhaps this function should eventually get
   removed: it's only called in one place, I believe.  */
d1915 1
a1915 1
  init_sal (&val);		/* initialize to zeroes */
@


1.70.2.12
log
@2002-10-28  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (dl1_initialize_defaults): New function.
	(dl1_indirect): Ditto.
	(dl1_set_flags): Ditto.
	(dl1_locate_first_half): Ditto.
	(decode_line_1): Call the above functions.
	* symtab.c (lookup_symbol_aux_minsyms): Add block_index argument,
	and delete is_a_field_of_this argument.
	(lookup_symbol_aux_nonlocal): Add call to
	lookup_symbol_aux_minsyms, and expand HP comment.
	(lookup_symbol_aux): Delete calls to lookup_symbol_aux_minsyms.
	Expand on comment before lookup_transparent_type.
@
text
@d142 1
a142 2
struct symbol *lookup_symbol_aux_minsyms (int block_index,
					  const char *name,
d145 1
d865 4
a868 5
  /* Now search all global blocks.  Do the symtab's first, then the
     minsyms, then check the psymtab's. If minsyms or psymtabs
     indicate the existence of the desired name as a global, then
     generate the appropriate symtab on the fly and return the found
     symbol.
d876 3
a878 3
     lookup_symbol_aux_using won't slow things down significantly in
     the general case, though: other parts of this function are much,
     much more expensive.  */
d885 15
d901 4
a904 6
     but more useful than an error.  */

  /* FIXME: carlton/2002-10-28: See my FIXME comment in
     lookup_symbol_aux_minsyms about the possible desirability of
     having a msymbol_found flag that could cause us to skip the
     STATIC_BLOCK search.  */
d911 26
d1042 2
a1043 57
#ifndef HPUXHPPA
  sym = lookup_symbol_aux_minsyms (block_index, name, mangled_name,
				   namespace, symtab);
  if (sym != NULL)
    return sym;
#endif

  sym = lookup_symbol_aux_psymtabs (block_index, name, mangled_name,
				    namespace, symtab);
  if (sym != NULL)
    return sym;

#ifdef HPUXHPPA

  /* FIXME: carlton/2002-10-28: The following comment was present in
     lookup_symbol_aux before I broke it up: at that time, the HP
     search order for nonlocal stuff was global symtab, global
     psymtab, static symtab, static psymtab, global and static
     minsyms.  (The minsyms are stored so that it's just as easy to do
     global and static searches of them at the same time.)  Now it's
     global symtab, global psymtab, global minsyms, static symtab,
     static psymtab, static minsyms.  Also, it's now impossible for a
     global minsym search to cause a NULL return by itself: if a
     minsym search returns NULL, then the next search after that is
     still performed.

     Given that that's the case, I'm pretty sure that my search order
     is safe; indeed, given that the comment below warns against
     premature NULL returns, it even seems plausible to me that we can
     treat HP symbol tables the same as non-HP symbol tables.  It
     would be great if somebody who has access to HP machines (or,
     even better, who understands the reason behind the HP special
     case in the first place) could check on this.

     But there's still the comment about "foo_" symbols in
     lookup_symbol_aux_minsyms which I really don't understand, sigh.
     _Should_ a minsym lookup sometimes be able to force a NULL return
     from lookup_symbol?  */

  /* RT: I moved this check to last, after the complete search of the
     global (p)symtab's and static (p)symtab's. For HP-generated
     symbol tables, this check was causing a premature exit from
     lookup_symbol with NULL return, and thus messing up symbol
     lookups of things like "c::f". It seems to me a check of the
     minimal symbol table ought to be a last resort in any case. I'm
     vaguely worried about the comment within
     lookup_symbol_aux_minsyms which talks about FORTRAN routines
     "foo_" though... is it saying we need to do the "minsym" check
     before the static check in this case?  */

  sym = lookup_symbol_aux_minsyms (block_index, name, mangled_name,
				   namespace, symtab);
  if (sym != NULL)
    return sym;
#endif

  return NULL;
d1273 1
a1273 1
lookup_symbol_aux_minsyms (int block_index, const char *name,
d1276 1
d1300 1
a1300 24
	  /* First, check to see that the symbol looks like it's
	     global or static (depending on what we were asked to look
	     for).  */

	  /* NOTE: carlton/2002-10-28: lookup_minimal_symbol gives
	     preference to global symbols over static symbols, so if
	     block_index is STATIC_BLOCK then this might well miss
	     static symbols that are shadowed by global symbols.  But
	     that's okay: this is only called with block_index equal
	     to STATIC_BLOCK if a global search has failed.  */

	  switch (MSYMBOL_TYPE (msymbol))
	    {
	    case mst_file_text:
	    case mst_file_data:
	    case mst_file_bss:
	      if (block_index == GLOBAL_BLOCK)
		return NULL;
	    default:
	      if (block_index == STATIC_BLOCK)
		return NULL;
	    }
	  
	  /* We next use the address in the msymbol to try to locate
d1310 1
a1310 1
	      block = BLOCKVECTOR_BLOCK (bv, block_index);
d1319 8
a1326 10

	      /* FIXME: carlton/2002-10-28: this next comment dates
		 from when this code was part of lookup_symbol_aux, so
		 this return could return NULL from lookup_symbol_aux.
		 Are there really situations where we want a minimal
		 symbol lookup to be able to force a NULL return from
		 lookup_symbol?  If so, maybe the thing to do would be
		 to have lookup_symbol_aux_minsym to set a
		 minsym_found flag, and to have lookup_symbol_aux only
		 do the psymtab search if that flag is zero.  */
d1347 1
a1347 1
		   && strcmp (name, SYMBOL_NAME (msymbol)) != 0)
d1351 3
a1353 5
	      return lookup_symbol_aux_nonlocal (block_index,
						 SYMBOL_NAME (msymbol),
						 mangled_name,
						 namespace,
						 symtab);
d1459 2
a1460 7
   be taken care of.  Unfortunately, right now there's no clean fix
   for that.  The obvious thing to do is to put in calls to
   lookup_symbol_aux_nonlocal; but, if I'm reading its caller, it
   seems like this is used when there are perhaps multiple definitions
   for NAME, in which case lookup_symbol_aux_nonlocal might find the
   wrong one.  Something to keep in mind when we have iterators,
   though.  */
@


1.70.2.13
log
@2002-11-06  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c: Delete declaration of operator_chars.

	* symtab.c (lookup_symbol_aux): Add comment.

	* linespec.c: Update copyright notice.
	(examine_compound_token): Rename from dl1_examine_compound_token.
	Misc. cleanups.
	(locate_class_sym): Rename from dl1_locate_class_sym.
	(decode_compound): Misc. cleanup.
	(symbol_found): Rename from dl1_symbol_found; misc. cleanup.
	(find_next_token): Rename from dl1_find_next_token; misc. cleanup.
	(find_method): Rename from dl1_find_method.  Delete sym_arr
	argument.  Misc. cleanup.
	(count_methods): Rename from dl1_find_method.  Reorder arguments
	to match find_methods.  Misc. cleanup.
	(find_method_name): New function.
	(add_matching_methods): New function.
	(add_constructors): New fnuction.
	(find_methods): Separate out some of code into find_method_name,
	add_matching_methods, and add_constructors; misc. cleanup.
	(is_all_digits): Rename from dl1_is_all_digits.
	(decode_all_digits): Rename from dl1_all_digits.  Don't set
	defaults: we already did that in initialize_defaults.
	(skip_digits): Rename from dl1_skip_digits.
	(handle_filename): Rename from dl1_handle_filename;
	misc. cleanup.
	(minsym_found): Rename from dl1_minsym_found; misc. cleanup.
	(decode_dollar): Rename from dl1_decode_dollar; misc. cleanup.
	(build_canonical_line_spec): Misc. cleanup.
	(find_toplevel_char): Move; change 0 to NULL.
	(decode_variable): Rename from dl1_variable; misc. cleanup.
	(select_symbols): Rename from decode_line_2; misc. cleanup; fork
	out some code into select_symbols_args.
	(select_symbols_args): New function.
	(decode_line_1): Misc. cleanup.
@
text
@a856 13
  /* NOTE: carlton/2002-11-06: There is a question as to whether or
     not it would be appropriate to search the current global block
     here as well.  On the one hand, it's redundant with the
     lookup_symbol_aux_symtabs search that happens next.  On the other
     hand, if decode_line_1 is passed an argument like filename:var,
     then the user presumably wants 'var' to be searched for in
     filename.  On the third hand, there shouldn't be multiple global
     variables all of which are named 'var', and it's not like the
     code has ever restricted its search to only global variables in a
     single filename.  All in all, only searching the static block
     seems best: it's cleanest, it's correct, and it might be useful
     for handling namespace scope issues completely correctly.  */

@


1.70.2.14
log
@2002-11-13  David Carlton  <carlton@@math.stanford.edu>

	* buildsym.c (finish_block): Initialize block_scope (block) in
	C++ function blocks.
	* dwarf2read.c: Delete variable current_namespace.
	(psymtab_to_symtab_1): Rename current_namespace to
	processing_current_namespace.
	(read_namespace): Ditto.
	* buildsym.h: New variable processing_current_namespace.
	* block.h: Declarations for block_scope and block_set_scope.
	* block.c (block_scope): New function.
	(block_set_scope): New function.
	* cp-support.h (struct namespace_info): Add 'scope' member.
	* buildsym.c (finish_block): Replace BLOCK_USING by
	block_set_using.
	(end_symtab): Ditto.
	* block.h: Declaration for block_set_using.
	* block.c (block_set_using): New function.
	(block_initialize_namespace): New function.
	* symtab.c (lookup_symbol_aux_using): Replace BLOCK_USING by
	block_using.
	* buildsym.c (finish_block): Set BLOCK_NAMESPACE to NULL, not
	BLOCK_USING.
	* jv-lang.c (get_java_class_symtab): Ditto.
	* block.h: Declaration for block_using.
	* block.c (block_using): New function.
	* Makefile.in (block.o): New rule; also add block.c to SFILES and
	block.o to COMMON_OBS.
	* block.c: New file.
	* symtab.c (contained_in): Move to block.c.
	(block_function): Ditto.
	* block.h (struct block): Have the language-specific stuff contain
	a struct namespace_info.
	(BLOCK_NAMESPACE): New macro.
	(BLOCK_USING): Delete.
	* linespec.c (decode_variable): Add comment before
	decode_variable.
	* cp-support.h (struct namespace_info): New struct.
@
text
@d1183 1
a1183 1
      using = cp_copy_usings (block_using (block), using);
d1780 12
d3379 12
@


1.70.2.15
log
@2002-11-14  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (symtab.o): Depend on gdb_assert_h.
	* symtab.c: #include "gdb_assert.h"
	* Makefile.in (namespace): Add 'namespace' target.
	* buildsym.c (finish_block): Comment out the using declarations
	generation.
	* block.h: Make argument to block_scope const.
	* block.c (block_scope): Make argument const.
	* symtab.c (lookup_symbol_aux_using): Gather usings via
	block_all_usings.
	(lookup_symbol_namespace): Rename from
	lookup_symbol_aux_using_loop.
	(lookup_symbol_aux_using_loop): New function.
	* block.h: Declare block_all_usings.
	* block.c (block_all_usings): New function.
	* symtab.c (lookup_symbol_aux_nonlocal): Delete FIXME comment.
	* buildsym.c (finish_block): Add FIXME comment.

2002-11-14  David Carlton  <carlton@@math.stanford.edu>

	* carlton_runnamespace: New file.
@
text
@a54 1
#include "gdb_assert.h"
d133 4
a136 1
struct symbol *lookup_symbol_aux_using_loop (const char *name,
d139 1
a139 12
					     struct symtab **symtab,
					     const char *scope,
					     int scope_len,
					     struct using_direct_node *using);
static
struct symbol *lookup_symbol_namespace (const char *prefix,
					int prefix_len,
					const char *rest,
					struct using_direct_node *using,
					const char *mangled_name,
					namespace_enum namespace,
					struct symtab **symtab);
d1000 3
a1171 1

d1178 1
a1178 2
  struct using_direct_node *using;
  const char *scope;
d1181 8
a1188 5
  using = block_all_usings (block);
  scope = block_scope (block);
  
  sym = lookup_symbol_aux_using_loop (name, mangled_name, namespace, symtab,
				      scope, 0, using);
a1193 38
/* Look up NAME in the namespaces given by SCOPE and its initial
   prefixes, applying using directives given by USING; only consider
   prefixes that are at least as long as SCOPE_LEN, however.  Look up
   longest prefixes first.  */

static struct
symbol *lookup_symbol_aux_using_loop (const char *name,
				      const char *mangled_name,
				      namespace_enum namespace,
				      struct symtab **symtab,
				      const char *scope,
				      int scope_len,
				      struct using_direct_node *using)
{
  if (scope[scope_len] != '\0')
    {
      struct symbol *sym;
      int next_component;
      int new_scope_len = scope_len;

      /* If the current scope is followed by "::", skip past that.  */
      if (new_scope_len != 0)
	{
	  gdb_assert (scope[new_scope_len] == ':');
	  new_scope_len += 2;
	}
      next_component = cp_find_first_component (scope + new_scope_len) - scope;
      sym = lookup_symbol_aux_using_loop (name, mangled_name, namespace,
					  symtab, scope, next_component,
					  using);
      if (sym != NULL)
	return sym;
    }

  return lookup_symbol_namespace (scope, scope_len, name, using,
				  mangled_name, namespace, symtab);
}

d1197 1
a1197 1
   For example, assume that we have using directives adding A to the
d1219 7
a1225 7
lookup_symbol_namespace (const char *prefix,
			 int prefix_len,
			 const char *rest,
			 struct using_direct_node *using,
			 const char *mangled_name,
			 namespace_enum namespace,
			 struct symtab **symtab)
d1259 8
a1266 7
	      sym = lookup_symbol_namespace (current->current->name,
					     current->current->inner_length,
					     new_rest,
					     using,
					     mangled_name,
					     namespace,
					     symtab);
@


1.70.2.16
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d157 1
a847 46
#if 0
  /* NOTE: carlton/2002-11-05: At the time that this code was
     #ifdeffed out, the value of 'block' was always NULL at this
     point, hence the bemused comments below.  */

  /* FIXME: this code is never executed--block is always NULL at this
     point.  What is it trying to do, anyway?  We already should have
     checked the STATIC_BLOCK above (it is the superblock of top-level
     blocks).  Why is VAR_NAMESPACE special-cased?  */
  /* Don't need to mess with the psymtabs; if we have a block,
     that file is read in.  If we don't, then we deal later with
     all the psymtab stuff that needs checking.  */
  /* Note (RT): The following never-executed code looks unnecessary to me also.
   * If we change the code to use the original (passed-in)
   * value of 'block', we could cause it to execute, but then what
   * would it do? The STATIC_BLOCK of the symtab containing the passed-in
   * 'block' was already searched by the above code. And the STATIC_BLOCK's
   * of *other* symtabs (those files not containing 'block' lexically)
   * should not contain 'block' address-wise. So we wouldn't expect this
   * code to find any 'sym''s that were not found above. I vote for 
   * deleting the following paragraph of code.
   */
  if (namespace == VAR_NAMESPACE && block != NULL)
    {
      struct block *b;
      /* Find the right symtab.  */
      ALL_SYMTABS (objfile, s)
      {
	bv = BLOCKVECTOR (s);
	b = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
	if (BLOCK_START (b) <= BLOCK_START (block)
	    && BLOCK_END (b) > BLOCK_START (block))
	  {
	    sym = lookup_block_symbol (b, name, mangled_name, VAR_NAMESPACE);
	    if (sym)
	      {
		block_found = b;
		if (symtab != NULL)
		  *symtab = s;
		return fixup_symbol_section (sym, objfile);
	      }
	  }
      }
    }
#endif /* 0 */

d1933 89
d3249 23
d3357 9
d4309 8
a4316 2
  add_info ("sources", sources_info,
	    "Source files in the program.");
@


1.70.2.17
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux): Get at static block via
	block_static_block.
	(lookup_symbol_aux_local): Delete static_block argument, and use
	block_static_block.
	* block.h: Declare block_static_block.
	* block.c (block_static_block): New function.
	* linespec.c (decode_all_digits): Move up definition of
	need_canonical.
@
text
@d95 2
a96 1
					struct symtab **symtab);
d843 1
a843 1
				 symtab);
a923 2
  static_block = block_static_block (block);

d979 2
a980 1
			 struct symtab **symtab)
a982 1
  const struct block *static_block = block_static_block (block);
d986 5
a990 2
  if (static_block == NULL)
    return NULL;
d992 1
a992 1
  while (block != static_block)
d1001 1
a1001 1
  /* We've reached the static block without finding a result.  */
d1003 1
@


1.70.2.18
log
@2002-11-19  David Carlton  <carlton@@math.stanford.edu>

	* block.c: Whitespace cleanup.
	* buildsym.c (finish_block): Delete #if'd out code.
	* symtab.c (lookup_symbol_namespace): Add comment.
	* dwarf2read.c (scan_partial_symbols): Fix typo.

2002-11-19  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Delete FIXME comment.
	Fill in PR's for setup_kfail's.
	Fiddle with comments at top of file.
@
text
@a139 1

a1301 5

/* NOTE: carlton/2002-11-19: This is optimistically called
   lookup_symbol_namespace instead of lookup_symbol_aux_namespace in
   hopes that it or something like it might eventually be useful
   outside of lookup_symbol.  */
@


1.70.2.19
log
@2002-11-22  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (examine_compound_token): Rewrite as switch
	statement, and add FIXME comment.
	* frame.h: Make arg of block_innermost_frame const.
	* blockframe.c (block_innermost_frame): Make arg const.
	* block.h: Make args to block_function, contained_in const.
	* block.c (block_function): Make arg const.
	(contained_in): Ditto.
	* value.h: Make arg of symbol_read_needs_frame const.
	* findvar.c (symbol_read_needs_frame): Make arg const.
	* symtab.h: Make first arg of symbol_demangled_name const.
	* symtab.c (symbol_demangled_name): Make arg const.
	* value.h: Make first arg of read_var_value const.
	* findvar.c (read_var_value): Make first arg const.
	* Makefile.in (valops.o): Depend on cp_support_h.
	* valops.c: #include "cp-support.h"
	* symtab.h: Add FIXME about name of namespace_enum.
	Add opaque declaration of struct using_direct_node.
	* symtab.c (lookup_symbol_namespace): Make extern; rename args.
	* symtab.h: Declare lookup_symbol_namespace.
	* valops.c (value_struct_elt_for_reference): Make 'name' a const
	char *.
	(value_namespace_elt): New function.
	* expprint.c (print_subexp): Ditto.
	(dump_subexp): Ditto.
	* parse.c (length_of_subexp): Ditto.
	(prefixify_subexp): Ditto.
	* expression.h: Update comment to reflect the block in OP_SCOPE.
	* c-exp.y: Set block in OP_SCOPE expression.
	* jv-exp.y (push_qualified_expression_name): Put a NULL block in
	OP_SCOPE expression.
	* objc-exp.y: Ditto.
	* p-exp.y: Ditto.
	* eval.c (evaluate_subexp_standard): Handle OP_SCOPE via
	value_aggregate_elt.
	* value.h: Add declaration for value_aggregate_elt; delete
	declaration for value_struct_elt_for_reference.
	* valops.c (value_aggregate_elt): New function.
	(value_struct_elt_for_reference): Make static.  Don't check type
	of curtype.
	* c-exp.y: Accept TYPE_CODE_NAMESPACE in qualified_name.
	* cp-support.c (cp_check_namespace_symbol): Set TYPE_NAME (type).

2002-11-22  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change a couple of tests to not use
	single quotes.
@
text
@d142 9
d545 1
a545 1
symbol_demangled_name (const struct general_symbol_info *gsymbol)
d1280 2
a1281 2
/* This tries to look up NAME in the namespace given by the initial
   substring of NAMESPACE of length NAMESPACE_LEN.
d1309 4
a1312 4
struct symbol *
lookup_symbol_namespace (const char *namespace,
			 int namespace_len,
			 const char *name,
d1315 1
a1315 1
			 namespace_enum name_space,
d1323 1
a1323 1
      /* First, see if the namespace matches the start of this using
d1325 2
a1326 2
      if (namespace_len <= current->current->outer_length
	  && strncmp (namespace, current->current->name, namespace_len) == 0)
d1331 1
a1331 1
	  const char *rest_of_outer = current->current->name + namespace_len;
d1333 1
a1333 1
	    = current->current->outer_length - namespace_len;
d1335 1
a1335 1
	     NAMESPACE_LEN is zero (and hence we're in the global
d1342 1
a1342 1
	  if (strncmp (rest_of_outer, name, rest_of_outer_len) == 0)
d1346 3
a1348 3
	      const char *new_name = name + rest_of_outer_len;
	      if (*new_name == ':')
		new_name += 2;
d1352 1
a1352 1
					     new_name,
d1355 1
a1355 1
					     name_space,
d1367 1
a1367 1
  if (namespace_len == 0)
d1369 2
a1370 2
      return lookup_symbol_aux_nonlocal (GLOBAL_BLOCK, name, mangled_name,
					 name_space, symtab);
d1375 4
a1378 4
	= xmalloc (namespace_len + 2 + strlen (name) + 1);
      strncpy (concatenated_name, namespace, namespace_len);
      strcpy (concatenated_name + namespace_len, "::");
      strcpy (concatenated_name + namespace_len + 2, name);
d1380 1
a1380 1
					mangled_name, name_space, symtab);
@


1.70.2.20
log
@2002-11-27  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (add_partial_enumeration): New function.
	(scan_partial_symbols): Call add_partial_enumeration.
	(locate_pdi_sibling): New function.
	(scan_partial_symbols): Call locate_pdi_sibling.  Get rid of
	nesting_level.
	(pdi_needs_namespace): New function.
	(add_partial_symbol): Add 'namespace' arg; calculate full name
	when appropriate.
	(scan_partial_symbols): Update calls to add_partial_symbol.
	(add_partial_enumeration): Ditto.
	(read_enumeration): Add processing_current_prefix to name when
	appropriate.
	(new_symbol): Set names of enumerators and typedefs appropriately
	if processing_has_namespace_info.
	* symtab.c (lookup_symbol_namespace): Rename 'namespace' argument
	to 'namespace_name'.
	* symtab.h: Ditto.
	* symtab.c (lookup_symbol_namespace): Delete FIXME comments; add a
	new one.
	(lookup_symbol_aux_file): New function.
	(lookup_symbol_aux): Delete FIXME comment.
	(lookup_symbol_aux): Don't search static block explicitly; delete
	FIXME comments.
	* valops.c (value_namespace_elt): Update call to
	lookup_symbol_namespace.
	* symtab.h: Update declaration for lookup_symbol_namespace.
	* symtab.c (lookup_symbol_namespace): Delete 'using' argument and
	add 'block' argument; get using directives via iterators.
	(lookup_symbol_aux_using_loop): Delete 'using' argument and add
	'block' argument.
	(lookup_symbol_aux_using): Don't calculate using directives.
	* block.c (block_using_iterator_first): New function.
	(block_using_iterator_next): Ditto.
	* block.h: Add comment.
	(struct block_using_iterator): New struct.
	Declare block_using_iterator_first, block_using_iterator_next.

2002-11-26  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (read_structure_scope): Set type name and
	processing_current_prefix appropriately.
	(new_symbol): Make sure that, in symbols associated to class
	types, the name includes appropriate namespaces.
	* buildsym.h: Rename processing_current_namespace to
	processing_current_prefix.
	* buildsym.c (finish_block): Ditto.
	* dwarf2read.c (psymtab_to_symtab_1): Ditto.
	(read_namespace): Ditto.  Also rename previous_namespace to
	previous_prefix.

	Now come a thousand and one const correctness fixes:
	* p-typeprint.c (pascal_print_type): Const.
	(pascal_type_print_method_args): Const.
	* p-lang.h: Const.
	* m2-typeprint.c (m2_print_type): Const.
	* valops.c (hand_function_call): Const.
	* jv-lang.c (java_primitive_type_from_name): Const.
	* jv-lang.h: Const.
	* jv-typeprint.c (java_print_type): Const.
	* language.c: (unk_lang_print_type): Const.
	* stack.c (frame_info): Const.
	* linespec.c (find_methods): Const.
	(find_method_name): Const
	* f-lang.h: Const.
	* f-typeprint.c (f_print_type): Const.
	* c-typeprint.c (c_print_type): Const.
	* c-lang.h: Const.
	* gdbtypes.h: Const.
	* gdbtypes.c (lookup_primitive_typename): Const.
	* stack.c (print_frame): Const.
	(func_command): Delete pointless cast.
	* linespec.c (find_method_name): Const.
	* language.h: Const.
	* symfile.c (compare_psymbols): Const.
	* symtab.c (completion_list_add_name): Const.
	* breakpoint.c (break_at_finish_at_depth_command_1): Remove
	useless cast.
	(break_at_finish_command_1): Ditto.
	* typeprint.c (type_print): Const.
	* symtab.h: Const.
	* symtab.c (gdb_mangle_name): Const.
	(symbol_init_demangled_name): Const.
	(symbol_demangled_name): Const.
	* defs.h: Const.
	* printcmd.c (build_address_symbolic): Const.
	* valops.c (search_struct_method): Const.
	* cp-valprint.c (cp_is_vtbl_ptr_type): Const.
	(cp_print_value): Const.
	(cp_print_class_member): Const.
	* c-typeprint.c (cp_type_print_derivation_info): Const.
	(c_type_print_varspec_prefix): Const.
	(c_type_print_base): Const.
	* p-valprint.c (pascal_object_is_vtbl_ptr_type): Const.
	(pascal_object_print_value): Const.
	(pascal_object_print_class_member): Const.
	* p-typeprint.c (pascal_type_print_derivation_info): Const.
	(pascal_type_print_varspec_prefix): Const.
	(pascal_type_print_base): Const.
	* jv-typeprint.c (java_type_print_base): Const.
	* jv-lang.h (java_demangle_type_signature): Const.
	* jv-lang.c (java_demangle_type_signature): Const.
	(java_demangled_signature_length): Const.
	(java_demangled_signature_copy): Const.
	* jv-typeprint.c (java_type_print_derivation_info): Const.
	* jv-valprint.c (java_value_print): Const.
	(java_print_value_fields): Const.
	* jv-lang.c (is_object_type): Const.
	(evaluate_subexp_java): Const.
	* stabsread.c (read_cpp_abbrev): Const.
	(complain_about_struct_wipeout): Const.
	(cleanup_undefined_types): Const.
	* gdbtypes.h: Const.
	* gdbtypes.c (add_name): Second arg const.
	(lookup_typename): Const.
	(lookup_unsigned_typename): Const.
	(lookup_signed_typename): Const.
	* linespec.c (find_methods): const char *class_name.
	* symtab.c (gdb_mangle_name): const char *newname.
	* valops.c (destructor_name_p): const char *dname.
	(search_struct_field): First arg const.
	* gdbtypes.c (check_typedef): const char *name (multiple places).
	(cfront_mangle_name): const char *newname.
	* gdbtypes.c (add_mangled_type): const char *tname.
	* valops.c (find_overload_match): const char *obj_type_name.
	* utils.c (gdb_print_host_address): Make first arg const.
	* defs.h: Declare first arg of gdb_print_host_address to be
	const.
	* valarith.c (find_size_for_pointer_math): const char *name.

2002-11-27  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/m-data.cc (main): Add marker comment.
	* gdb.c++/m-data.exp: Use marker comment instead of line numbers.
	* gdb.c++/m-data.cc: Delete superfluous namespace.
	* gdb.c++/m-static.cc: Ditto.
	* gdb.c++/m-static1.cc: Ditto.
	* carlton_runtest: Compare based on gdb.sum, not based on output.
	* carlton_runnamespace: Ditto.

2002-11-26  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Put tests for CClass.
	* gdb.c++/namespace.cc (C): Add CClass.
@
text
@d59 1
a59 2
static void completion_list_add_name (const char *, char *, int, char *,
				      char *);
a111 7
struct symbol *lookup_symbol_aux_file (const char *name,
				       const char *mangled_name,
				       const struct block *block,
				       const namespace_enum namespace,
				       struct symtab **symtab);

static
a134 1
					     const struct block *block,
d138 2
a139 1
					     int scope_len);
d356 3
a358 3
  const char *field_name = TYPE_FN_FIELDLIST_NAME (type, method_id);
  const char *physname = TYPE_FN_FIELD_PHYSNAME (f, signature_id);
  const char *newname = type_name_no_tag (type);
d473 1
a473 1
  const char *mangled = gsymbol->name;
d535 1
a535 1
const char *
d900 31
a930 1
  /* Now search this block's static block, and all the global blocks.
d935 6
d949 5
a1115 25
/* Look up NAME in BLOCK's static block and in global blocks.  */

static struct symbol *
lookup_symbol_aux_file (const char *name,
			const char *mangled_name,
			const struct block *block,
			const namespace_enum namespace,
			struct symtab **symtab)
{
  struct symbol *sym;
  const struct block *static_block = block_static_block (block);

  if (static_block != NULL)
    {
      sym = lookup_symbol_aux_block (name, mangled_name, static_block,
				     namespace, symtab);
      if (sym != NULL)
	return sym;
    }

  return lookup_symbol_aux_nonlocal (GLOBAL_BLOCK, name, mangled_name,
				     namespace, symtab);
}


d1209 3
a1211 3
/* This function and lookup_symbol_aux_using_loop calculates the
   appropriate namespaces scope for BLOCK, and searches for NAME in
   each of the namespaces that are in scope.  */
d1219 3
a1221 1
  const char *scope = block_scope (block);
d1223 8
a1230 3
  return lookup_symbol_aux_using_loop (name, mangled_name, block,
				       namespace, symtab,
				       scope, 0);
d1233 5
a1240 1
				      const struct block *block,
d1244 2
a1245 1
				      int scope_len)
d1260 3
a1262 2
      sym = lookup_symbol_aux_using_loop (name, mangled_name, block, namespace,
					  symtab, scope, next_component);
d1267 2
a1268 2
  return lookup_symbol_namespace (scope, scope_len, name, mangled_name,
				  block, namespace, symtab);
d1272 1
a1272 2
   substring of NAMESPACE_NAME of length NAMESPACE_LEN.  It applies
   the using directives that are active in BLOCK.
d1286 13
a1298 7
/* FIXME: carlton/2002-11-27: Currently, there's no way to specify
   that additional using directives are active.  When we get around to
   implementing Koenig lookup, that will have to change.  */

/* NOTE: carlton/2002-11-27: I'm calling the namespace_enum argument
   NAME_SPACE instead of NAMESPACE because I'm being driven crazy by
   the two different meanings of "namespace" in this function.  */
d1301 1
a1301 1
lookup_symbol_namespace (const char *namespace_name,
d1304 1
a1305 1
			 const struct block *block,
d1309 1
a1309 2
  struct block_using_iterator iter;
  const struct using_direct *current;
d1312 1
a1312 3
  for (current = block_using_iterator_first (block, &iter);
       current != NULL;
       current = block_using_iterator_next (&iter))
d1316 2
a1317 2
      if (namespace_len <= current->outer_length
	  && strncmp (namespace_name, current->name, namespace_len) == 0)
d1322 1
a1322 1
	  const char *rest_of_outer = current->name + namespace_len;
d1324 1
a1324 1
	    = current->outer_length - namespace_len;
d1341 2
a1342 2
	      sym = lookup_symbol_namespace (current->name,
					     current->inner_length,
d1344 1
a1345 1
					     block,
d1360 2
a1361 2
      return lookup_symbol_aux_file (name, mangled_name, block,
				     name_space, symtab);
d1367 1
a1367 1
      strncpy (concatenated_name, namespace_name, namespace_len);
d1370 2
a1371 2
      sym = lookup_symbol_aux_file (concatenated_name, mangled_name,
				    block, name_space, symtab);
d3354 1
a3354 2
completion_list_add_name (const char *symname, char *sym_text,
			  int sym_text_len,
@


1.70.2.21
log
@2002-12-17  David Carlton  <carlton@@math.stanford.edu>

	* c-exp.y (yylex): Modify the #if 1 block to handle nested types
	in a more honest manner.
	* symtab.c (lookup_nested_type): New function.
	* symtab.h: Declare lookup_nested_type.

2002-12-16  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_partial_symbol): Don't search past the end of
	the partial symbols.
	* Makefile.in (f-exp.tab.c): Don't depend on c-exp.tab.c.
	* dwarf2read.c (new_symbol): Only make global symbols associated
	to structures, etc. if the current language is C++.
	(add_partial_symbol): Ditto (for partial symbols).

2002-12-17  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/m-data.cc: Whitespace cleanup, to match mainline patch.
	* gdb.c++/m-static.cc: Ditto.
	* gdb.c++/namespace.exp: Fix comment.  Delete third argument to
	all the gdb_tests.

2002-12-16  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change KFAIL messages to point to c++/XXX
	instead of gdb/XXX.
@
text
@a1474 46
/* Look up a type named NESTED_NAME that is nested inside the C++
   class or namespace given by PARENT_TYPE, from within the context
   given by BLOCK.  */

struct type *
lookup_nested_type (struct type *parent_type,
		    const char *nested_name,
		    const struct block *block)
{
  switch (TYPE_CODE (parent_type))
    {
    case TYPE_CODE_STRUCT:
    case TYPE_CODE_NAMESPACE:
      {
	/* NOTE: carlton/2002-12-17: As of this writing, C++ class
	   members of classes aren't treated like, say, data or
	   function members.  Instead, they're just represented by
	   symbols whose names are qualified by the name of the
	   surrounding class.  This is just like members of
	   namespaces; in particular, lookup_symbol_namespace works
	   when looking them up.  */

	/* NOTE: carlton/2002-12-17: The above is, actually, lying:
	   there are still situations where nested types are
	   represented by symbols that include only the member name,
	   not the parent name.  Sigh.  Blame it on stabs, or
	   something.  */
	const char *parent_name = TYPE_TAG_NAME (parent_type);
	struct symbol *sym = lookup_symbol_namespace (parent_name,
						      strlen (parent_name),
						      nested_name,
						      NULL,
						      block,
						      VAR_NAMESPACE,
						      NULL);
	if (sym == NULL || SYMBOL_CLASS (sym) != LOC_TYPEDEF)
	  return NULL;
	else
	  return SYMBOL_TYPE (sym);
      }
    default:
      error ("\"%s\" is not defined as a compound type.",
	     TYPE_NAME (parent_type));
    }
}

d1484 1
a1484 1
  struct partial_symbol **top, **real_top, **bottom, **center;
a1506 1
      real_top = top;
d1534 1
a1534 1
      while (top <= real_top && SYMBOL_MATCHES_NAME (*top, name))
@


1.70.2.22
log
@2002-12-18  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_file): Call
	cp_lookup_possible_namespace_symbol.
	* dwarf2read.c (add_partial_symbol): Sometimes check for possible
	namespace symbols.
	* cp-support.c (maintenance_print_namespace): Handle
	possible_namespace_block, too.
	(cp_lookup_possible_namespace_symbol): New function.
	* cp-support.h: Declare cp_check_possible_namespace_symbols,
	cp_lookup_possible_namespace_symbol.
	* cp-support.c (check_one_possible_namespace_symbol): New
	function.
	(cp_check_possible_namespace_symbols): New function.
	(check_possible_namespace_symbols_loop): New function.
	* symfile.h: Update declaration for add_psymbol_to_list.
	* symfile.c (psymbol_init_demangled_name): New function.
	(add_psymbol_to_list): Change SYMBOL_INIT_LANGUAGE_SPECIFIC to
	psymbol_init_demangled_name.
	(add_psymbol_to_list): Return a const struct psymbol *.
	* Makefile.in (dwarf2read.o): Don't depend on bcache_h.
	* dwarf2read.c: Don't #include "bcache.h"
	* cp-support.c (get_namespace_block): Allocate blocks via
	allocate_block.
	(initialize_namespace_blocks): New function.
	New variable possible_namespace_block.
	(get_namespace_block): Call initialize_namespace_blocks.
	(free_namespace_blocks): Rename from free_namespace_block; handle
	possible_namespace_block, too.
	(get_possible_namespace_block): New function.
	* jv-lang.c (get_java_class_symtab): Ditto.
	* block.c (allocate_block): New function.
	* block.h: Declare allocate_block.
@
text
@d1103 2
a1104 28
  sym = lookup_symbol_aux_nonlocal (GLOBAL_BLOCK, name, mangled_name,
				    namespace, symtab);

  if (sym != NULL)
    return sym;

  /* Now call "cp_lookup_possible_namespace_symbol".  Symbols in here
     claim to be associated to namespaces, whereas the names in
     question might actually correspond to either namespaces or to
     classes.  But if they correspond to classes, then we should have
     found a match to them above.  So if we find them now, they should
     be genuine.  */

  /* FIXME: carlton/2002-12-18: This is a hack and should eventually
     be deleted: see cp-support.c.  */

  if (namespace == VAR_NAMESPACE)
    {
      sym = cp_lookup_possible_namespace_symbol (name);
      if (sym != NULL)
	{
	  if (symtab != NULL)
	    *symtab = NULL;
	  return sym;
	}
    }

  return NULL;
@


1.70.2.23
log
@2002-12-20  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_minsyms): Don't call
	lookup_symbol_aux from within this.
	* values.c (value_static_field): lookup_symbol_linkage.
	(value_fn_field): lookup_symbol_linkage.
	* valops.c (value_struct_elt_for_reference): lookup_symbol_linkage.
	* blockframe.c (inside_main_func): lookup_symbol_linkage.
	* source.c (select_source_symtab): lookup_symbol_linkage.
	* nlmread.c (nlm_symfile_read): Call lookup_symbol_linkage.
	* nindy-tdep.c (nindy_frame_chain_valid): Call
	lookup_symbol_linkage.
	* linespec.c (count_methods): Call lookup_symbol_linkage.
	(add_matching_methods): Ditto.
	(add_constructors): Ditto.
	* hppa-tdep.c (find_stub_with_shl_get): Call
	lookup_symbol_linkage.  Delete symbol2.
	(initialize_hp_cxx_exception_support): Call lookup_symbol_linkage.
	* cli/cli-cmds.c (edit_command): SYMBOL_PRINT_NAME.
	(list_command): SYMBOL_PRINT_NAME.
	* valops.c (value_of_variable): SYMBOL_PRINT_NAME
	(hand_function_call): SYMBOL_PRINT_NAME.
	* typeprint.c (typedef_print): SYMBOL_PRINT_NAME.
	* tracepoint.c (tracepoints_info): SYMBOL_PRINT_NAME.
	* symtab.c (lookup_partial_symbol): SYMBOL_BEST_NAME.
	(compare_search_syms): SYMBOL_BEST_NAME.
	(print_symbol_info): SYMBOL_PRINT_NAME.
	(print_msymbol_info): SYMBOL_PRINT_NAME.
	(rbreak_command): SYMBOL_PRINT_NAME.
	* symmisc.c (print_symbol): SYMBOL_PRINT_NAME.
	* stack.c (print_frame): SYMBOL_PRINT_NAME.
	(frame_info): SYMBOL_PRINT_NAME.
	(print_block_frame_locals): SYMBOL_PRINT_NAME.
	(print_block_frame_labels): SYMBOL_PRINT_NAME.
	(print_frame_arg_vars): SYMBOL_PRINT_NAME.
	(return_command): SYMBOL_PRINT_NAME.
	* stabsread.c (define_symbol): SYMBOL_PRINT_NAME.
	* p-valprint.c (pascal_val_print): SYMBOL_PRINT_NAME.
	* printcmd.c (build_address_symbolic): SYMBOL_PRINT_NAME.
	(sym_info): SYMBOL_PRINT_NAME.
	(print_frame_args): SYMBOL_PRINT_NAME.
	* objc-lang.c (compare_selectors): SYMBOL_BEST_NAME.
	(compare_classes): SYMBOL_BEST_NAME.
	* maint.c (maintenance_translate_address): SYMBOL_PRINT_NAME.
	* linespec.c (find_method): SYMBOL_PRINT_NAME.
	(select_symbols): SYMBOL_PRINT_NAME.
	* infcmd.c (jump_command): SYMBOL_PRINT_NAME.
	* findvar.c (locate_var_value): SYMBOL_PRINT_NAME.
	* expprint.c (print_subexp): SYMBOL_PRINT_NAME.
	* c-valprint.c (c_val_print): SYMBOL_PRINT_NAME.
	* buildsym.c (finish_block): SYMBOL_PRINT_NAME.
	* breakpoint.c (print_one_breakpoint): SYMBOL_PRINT_NAME.
	* ax-gdb.c (gen_var_ref): SYMBOL_PRINT_NAME.
	* ada-typeprint.c (ada_typedef_print): SYMBOL_PRINT_NAME.
	* ada-lang.c (user_select_syms): Use SYMBOL_PRINT_NAME instead of
	SYMBOL_SOURCE_NAME.
	(user_select_syms):
	(ada_finish_decode_line_1): Use SYMBOL_BEST_NAME instead of
	SYMBOL_SOURCE_NAME.
	* symtab.h (SYMBOL_PRINT_NAME): Rename from SYMBOL_SOURCE_NAME.
	* symfile.c (compare_symbols): Use SYMBOL_BEST_NAME, not
	SYMBOL_SOURCE_NAME.
	(compare_psymbols): Ditto.
	* symtab.c (lookup_symbol_linkage): New function.
	* symtab.h: Declare lookup_symbol_linkage.
	* c-valprint.c (c_val_print): Call lookup_symbol_minsym.
	* symtab.c (lookup_symbol_aux_minsyms): Call minsym_static.
	* minsyms.c (minsym_static): New function.
	* symtab.h: Declare minsym_static.
	* symtab.c (lookup_symbol_minsym): New function.
	(search_symbols): Call lookup_symbol_minsym instead of
	lookup_symbol.
	(lookup_symbol_namespace): Don't take apart NAME.
	* symtab.h: Declare lookup_symbol_minsym.
	* printcmd.c (build_address_symbolic): Don't use old version of
	SYMBOL_LINKAGE_NAME.
	* symtab.c (lookup_block_symbol): Change mangled names to linkage
	name, and use SYMBOL_LINKAGE_NAME as appropriate.
	* symtab.h (SYMBOL_LINKAGE_NAME): New macro, with a different
	meaning from the old macro of the same name.  Also, add comments
	about proper uses of names.
@
text
@d1278 13
a1290 3
   the using directives that are active in BLOCK.  It doesn't look
   into NAME at all, so if NAME happens to contain some namespaces, it
   won't apply using directives to those namespaces.  */
a1312 4
  /* First, go through the using directives.  If any of them add new
     names to the namespace we're searching in, see if we can find a
     match by applying them.  */

d1317 3
a1319 1
      if (namespace_len == current->outer_length
d1322 32
a1353 9
	  sym = lookup_symbol_namespace (current->name,
					 current->inner_length,
					 name,
					 mangled_name,
					 block,
					 name_space,
					 symtab);
	  if (sym != NULL)
	    return sym;
d1359 1
a1359 1
     using the current namespace.  */
d1381 4
a1384 2
/* Check for the possibility of the symbol being a function that is
   stored in one of the minimal symbol tables.  */
d1424 1
a1424 1
	  if (minsym_static (msymbol))
d1426 3
d1431 1
a1431 3
	    }
	  else
	    {
d1456 10
d1483 12
a1500 64
/* Lookup the symbol associated to a minimal symbol, if there is one.  */

/* FIXME: carlton/2002-12-20: This is now implemented in a way that
   doesn't work very well and that may, in fact return the wrong
   symbol.  For now, we're in a transition period where I want to
   replace some calls to lookup_symbol by calls to
   lookup_symbol_minsym, so it's okay for lookup_symbol_minsym to get
   the answer wrong in circumstances where lookup_symbol would have
   screwed it up, too; later, I'll fix lookup_symbol_minsym to get it
   right as quickly and easily as possible.  */

struct symbol *
lookup_symbol_minsym (const struct minimal_symbol *minsym)
{
  int block_index = minsym_static (minsym) ? STATIC_BLOCK : GLOBAL_BLOCK;

  return lookup_symbol_aux_nonlocal (block_index,
				     SYMBOL_BEST_NAME (minsym),
				     SYMBOL_LINKAGE_NAME (minsym),
				     VAR_NAMESPACE,
				     NULL);
}

/* Lookup the symbol with a given linkage name.  */

struct symbol *
lookup_symbol_linkage (const char *linkage_name)
{
  const char *name;
  char *demangled_name = NULL;
  struct symbol *sym;

  name = linkage_name;

  /* If we are using C++, then the linkage name might be a mangled C++
     name; lookup_symbol_aux_nonlocal expects the name to be
     demangled.  */

  if (current_language->la_language == language_cplus)
    {
      demangled_name = cplus_demangle (name, DMGL_ANSI | DMGL_PARAMS);
      if (demangled_name != NULL)
	{
	  name = demangled_name;
	}
    }

  sym = lookup_symbol_aux_nonlocal (GLOBAL_BLOCK, name, linkage_name,
				    VAR_NAMESPACE, NULL);

  if (sym != NULL)
    {
      xfree (demangled_name);
      return sym;
    }

  sym = lookup_symbol_aux_nonlocal (STATIC_BLOCK, name, linkage_name,
				    VAR_NAMESPACE, NULL);

  xfree (demangled_name);
  return sym;
}


d1591 1
a1591 1
	  if (strcmp (SYMBOL_BEST_NAME (*center), name) >= 0)
d1789 2
a1790 2
   If LINKAGE_NAME is non-NULL, verify that any symbol we find has
   this particular linkage name.
d1806 1
a1806 1
		     const char *linkage_name, const namespace_enum namespace)
d1817 2
a1818 2
	      && (linkage_name
		  ? strcmp (SYMBOL_LINKAGE_NAME (sym), linkage_name) == 0 : 1))
d1837 2
a1838 2
	      && (linkage_name
		  ? strcmp (SYMBOL_LINKAGE_NAME (sym), linkage_name) == 0 : 1))
d2863 2
a2864 2
  return strcmp (SYMBOL_BEST_NAME ((*sym_a)->symbol),
		 SYMBOL_BEST_NAME ((*sym_b)->symbol));
d3066 1
a3066 1
     for the function, for variables we have to call lookup_symbol_minsym
d3087 4
a3090 1
			|| lookup_symbol_minsym (msymbol) == NULL)
d3184 3
a3186 1
		    if (lookup_symbol_minsym (msymbol) == NULL)
d3245 1
a3245 1
		   ? "" : SYMBOL_PRINT_NAME (sym)), gdb_stdout, 0);
d3264 1
a3264 1
  printf_filtered ("%s  %s\n", tmp, SYMBOL_PRINT_NAME (msymbol));
d3372 1
a3372 1
			   SYMBOL_PRINT_NAME (p->msymbol));
@


1.70.2.24
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (search_symbols): Update comment.
	(lookup_symbol): Don't demangle names.
	(lookup_symbol_minsym): Delete FIXME comment.
	(lookup_symbol_linkage): Add comment.
	(lookup_symbol_aux): Rename 'mangled_name' argument to
	'linkage_name'.
	(lookup_symbol_aux_local): Ditto.
	(lookup_symbol_aux_block): Ditto.
	(lookup_symbol_aux_nonlocal): Ditto.
	(lookup_symbol_aux_file): Ditto.
	(lookup_symbol_aux_symtabs): Ditto.
	(lookup_symbol_aux_psymtabs): Ditto.
	(lookup_symbol_aux_using): Ditto.
	(lookup_symbol_aux_using_loop): Ditto.
	(lookup_symbol_namespace): Ditto.
	(lookup_symbol_aux_minsyms): Ditto.
	* symfile.c (psymbol_init_demangled_name): Delete unnecessary
	variable, initialization.
@
text
@d85 1
a85 1
					 const char *linkage_name,
d93 1
a93 1
					const char *linkage_name,
d100 1
a100 1
					const char *linkage_name,
d108 1
a108 1
					   const char *linkage_name,
d114 1
a114 1
				       const char *linkage_name,
d122 1
a122 1
					  const char *linkage_name,
d129 1
a129 1
					   const char *linkage_name,
d135 1
a135 1
					const char *linkage_name,
d142 1
a142 1
					     const char *linkage_name,
d152 1
a152 1
					  const char *linkage_name,
d762 5
a766 6
/* Find the definition for a specified symbol name NAME in namespace
   NAMESPACE, visible from lexical block BLOCK.  Returns the struct
   symbol pointer, or zero if no symbol is found.  If SYMTAB is
   non-NULL, store the symbol table in which the symbol was found
   there.

d769 3
a771 5
   *IS_A_FIELD_OF_THIS to 1, otherwise set it to zero.

   BLOCK_FOUND is set to the block in which NAME is found (in the case
   of a field of `this', value_of_this sets BLOCK_FOUND to the proper
   value.) */
a782 4
/* NOTE: carlton/2002-12-23: I'm updating this to no longer demangle
   names on demand.  I hope that I've tracked down everywhere in GDB
   that might pass this a mangled name.  */

d788 20
a807 1
  const char *modified_name = name;
d822 6
a827 2
  return lookup_symbol_aux (modified_name, NULL, block,
			    namespace, is_a_field_of_this, symtab);
d831 1
a831 1
lookup_symbol_aux (const char *name, const char *linkage_name,
d841 1
a841 1
  sym = lookup_symbol_aux_local (name, linkage_name, block, namespace,
d879 1
a879 1
	    sym = lookup_block_symbol (b, name, linkage_name, VAR_NAMESPACE);
d913 1
a913 1
  sym = lookup_symbol_aux_using (name, linkage_name, block, namespace,
d921 1
a921 1
  sym = lookup_symbol_aux_nonlocal (STATIC_BLOCK, name, linkage_name,
d936 1
a936 1
lookup_symbol_aux_local (const char *name, const char *linkage_name,
d951 1
a951 1
      sym = lookup_symbol_aux_block (name, linkage_name, block, namespace,
d967 1
a967 1
lookup_symbol_aux_block (const char *name, const char *linkage_name,
d978 1
a978 1
  sym = lookup_block_symbol (block, name, linkage_name, namespace);
d1013 1
a1013 1
			    const char *linkage_name,
d1019 1
a1019 1
  sym = lookup_symbol_aux_symtabs (block_index, name, linkage_name,
d1025 1
a1025 1
  sym = lookup_symbol_aux_minsyms (block_index, name, linkage_name,
d1031 1
a1031 1
  sym = lookup_symbol_aux_psymtabs (block_index, name, linkage_name,
d1074 1
a1074 1
  sym = lookup_symbol_aux_minsyms (block_index, name, linkage_name,
d1087 1
a1087 1
			const char *linkage_name,
d1097 1
a1097 1
      sym = lookup_symbol_aux_block (name, linkage_name, static_block,
d1103 1
a1103 1
  sym = lookup_symbol_aux_nonlocal (GLOBAL_BLOCK, name, linkage_name,
d1141 1
a1141 1
			   const char *name, const char *linkage_name,
d1155 1
a1155 1
    sym = lookup_block_symbol (block, name, linkage_name, namespace);
d1175 1
a1175 1
			    const char *linkage_name,
d1195 1
a1195 1
	sym = lookup_block_symbol (block, name, linkage_name, namespace);
d1212 1
a1212 1
	    sym = lookup_block_symbol (block, name, linkage_name, namespace);
d1232 1
a1232 1
					       const char *linkage_name,
d1239 1
a1239 1
  return lookup_symbol_aux_using_loop (name, linkage_name, block,
d1246 1
a1246 1
				      const char *linkage_name,
d1266 1
a1266 1
      sym = lookup_symbol_aux_using_loop (name, linkage_name, block, namespace,
d1272 1
a1272 1
  return lookup_symbol_namespace (scope, scope_len, name, linkage_name,
d1294 1
a1294 1
			 const char *linkage_name,
d1317 1
a1317 1
					 linkage_name,
d1332 1
a1332 1
      return lookup_symbol_aux_file (name, linkage_name, block,
d1342 1
a1342 1
      sym = lookup_symbol_aux_file (concatenated_name, linkage_name,
d1355 1
a1355 1
			   const char *linkage_name,
d1420 1
a1420 1
		lookup_block_symbol (block, name, linkage_name, namespace);
d1447 9
a1491 4
  /* NOTE: carlton/2002-12-23: We don't just call lookup_symbol_aux
     because that might apply namespace stuff, defeating the purpose
     of searching on a specific linkage name.  */

d3069 2
@


1.70.2.25
log
@2003-01-06  David Carlton  <carlton@@math.stanford.edu>

	* config/djgpp/fnchange.lst: Mention
	testsuite/gdb.c++/namespace1.cc.
	* cp-support.h: Declare cp_lookup_namespace_symbol.
	* cp-support.c (cp_lookup_namespace_symbol): New function.
	(cp_check_namespace_symbol): Call cp_lookup_namespace_symbol.
	(cp_lookup_possible_namespace_symbol): Update comment.
	* symtab.c (lookup_symbol_aux_file): Add 'anonymous_namespace'
	argument.
	(lookup_symbol_namespace): Call lookup_symbol_aux_file with new
	argument.
	* cp-support.h: Declare cp_is_anonymous.
	* cp-support.c (cp_is_anonymous): New function.
	* buildsym.c (add_symbol_to_list): Don't test for anonymous
	namespace mention here.
	(scan_for_anonymous_namespaces): Test for it here, instead.
	* symtab.c (lookup_symbol_aux_minsyms): Delete.
	(lookup_symbol_aux_nonlocal): Don't call
	lookup_symbol_aux_minsyms.

2003-01-06  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Test anonymous namespaces and multiple
	files.
	* gdb.c++/namespace1.cc: Add anonymous namespaces.
@
text
@d117 1
a117 2
				       struct symtab **symtab,
				       int anonymous_namespace);
d149 7
d1008 7
d1020 44
d1067 1
a1067 3
/* Look up NAME in BLOCK's static block and in global blocks.  If
   ANONYMOUS_NAMESPACE is nonzero, don't look in other files' global
   blocks, just in the one belonging to this file.  */
d1074 1
a1074 2
			struct symtab **symtab,
			int anonymous_namespace)
d1076 1
a1076 1
  struct symbol *sym = NULL;
d1087 2
a1088 20
  if (anonymous_namespace)
    {
      const struct block *global_block = NULL;
      if (static_block != NULL)
	global_block = BLOCK_SUPERBLOCK (static_block);
      else if (block != NULL)
	global_block = block;
      
      if (global_block != NULL)
	sym = lookup_symbol_aux_block (name, linkage_name, global_block,
				       namespace, symtab);

      if (sym == NULL || global_block == NULL)
	sym = cp_lookup_namespace_symbol (name);
    }
  else
    {
      sym = lookup_symbol_aux_nonlocal (GLOBAL_BLOCK, name, linkage_name,
					namespace, symtab);
    }
a1102 7
  /* FIXME: carlton/2003-01-06: Searching this seems a bit fishy if
     anonymous_namespace is nonzero, since we might return a namespace
     that's really a class that doesn't happen to be mentioned in the
     current file.  Sigh.  Still, I don't think anything catastrophic
     should happen in that case.  Probably the right thing to do is to
     move anonymous namespace symbols to files' static blocks.  */

d1317 1
a1317 2
				     name_space, symtab,
				     0);
d1327 1
a1327 3
				    block, name_space, symtab,
				    cp_is_anonymous (namespace_name,
						     namespace_len));
d1332 95
@


1.70.2.26
log
@2003-01-20  David Carlton  <carlton@@math.stanford.edu>

	* p-exp.y: Add block to OP_FUNCALL.
	* objc-exp.y: Add block to OP_FUNCALL.
	* m2-exp.y: Add block to OP_FUNCALL.
	* c-exp.y: Add block to OP_FUNCALL.
	* ada-exp.y: Add block to OP_FUNCALL.
	(write_object_renaming): Ditto.
	* parse.c (length_of_subexp): Split off OP_FUNCALL.
	(prefixify_subexp): Ditto.
	* expprint.c (print_subexp): Change offset for OP_FUNCALL.
	(dump_subexp): Ditto.
	* eval.c (evaluate_subexp_standard): Change offset for
	OP_FUNCALL.
	* ada-lang.c (ada_resolve_subexp): Add comment on OP_FUNCALL.
	(replace_operator_with_call): Add block to OP_FUNCALL.
	(ada_evaluate_subexp): Change offset for OP_FUNCALL.
	* expression.h (exp_opcode): Change comments before OP_FUNCALL and
	OP_F77_UNDETERMINED_ARGLIST.

2003-01-14  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (search_symbols): Add comment.
	(lookup_symbol_aux_using): Function name should start line.
	(lookup_symbol_aux_using_loop): Ditto.
	(lookup_block_symbol): Add comment.

2003-01-13  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (read_structure_scope): Add comment.
	(add_partial_structure): Ditto.
	* symtab.c (lookup_transparent_type): Add comment.
@
text
@d1186 5
a1190 6
static struct symbol *
lookup_symbol_aux_using (const char *name,
			 const char *linkage_name,
			 const struct block *block,
			 const namespace_enum namespace,
			 struct symtab **symtab)
d1199 8
a1206 8
static struct symbol *
lookup_symbol_aux_using_loop (const char *name,
			      const char *linkage_name,
			      const struct block *block,
			      namespace_enum namespace,
			      struct symtab **symtab,
			      const char *scope,
			      int scope_len)
a1519 4
/* NOTE: carlton/2003-01-13: Callers for this should have the full
   name of the type in question, so this doesn't have to get any
   smarter about namespace stuff.  */

a1669 5
/* NOTE: carlton/2003-01-14: No, there are situations where this is
   more generous: it ignores whitespace on demangled names, too.  This
   is good: e.g. it makes recognizing templated types more generous.
   See PR gdb/33.  */

a2782 4

/* NOTE: carlton/2003-01-14: I don't think this needs any namespace
   tweaking.  */

@


1.70.2.27
log
@2003-01-28  David Carlton  <carlton@@math.stanford.edu>

	* valops.c (find_overload_match): Calculate func_name via
	SYMBOL_CPLUS_DEMANGLED_NAME + remove_params.
	* symtab.c (remove_params): Make extern.
	* symtab.h: Add declaration for remove_params.
	* symtab.c (overload_list_add_symbol): Change second arg to const
	char *.
	* valops.c (find_overload_match) Update call to
	make_symbol_overload_list.
	* symtab.h: Update declaration for make_symbol_overload_list.
	* symtab.c (make_symbol_overload_list): Change arguments.
	* valops.c (find_overload_match): Rename cleanups to old_cleanups;
	handle freeing func_name via cleanups.
@
text
@d167 1
a167 2
static void overload_list_add_symbol (struct symbol *sym,
				      const char *oload_name);
d3860 1
a3860 1
char *
d3913 1
a3913 1
overload_list_add_symbol (struct symbol *sym, const char *oload_name)
d3955 4
a3958 5
   match name of the supplied symbol FSYM and that occur within the
   namespace given by the initial substring of NAMESPACE_NAME of
   length NAMESPACE_LEN.  Apply using directives from BLOCK.  This is
   used in finding all overloaded instances of a function name.  This
   has been modified from make_symbol_completion_list.  */
d3961 1
a3961 3
make_symbol_overload_list (const char *func_name,
			   const char *namespace_name,
			   int namespace_len, const struct block *block)
d3970 18
a3987 1
  const char *oload_name = func_name;
d4072 2
@


1.70.2.28
log
@2003-01-31  David Carlton  <carlton@@math.stanford.edu>

	From Jim Blandy  <jimb@@redhat.com>:

	Use a single, consistent representation for an empty minimal
	symbol table in an objfile.
	* objfiles.c (terminate_minimal_symbol_table): New function.
	(allocate_objfile): Call it.
	* objfiles.h (terminate_minimal_symbol_table): New declaration.
	(ALL_MSYMBOLS): No need to test whether (objfile)->msymbols is
	non-NULL.
	* minsyms.c (lookup_minimal_symbol_by_pc_section): To see whether
	objfile has minimal symbols, compare minimal_symbol_count to zero,
	instead of comparing msymbols with NULL.
	* objfiles.c (have_minimal_symbols): Same.
	* solib-sunos.c (solib_add_common_symbols): Call
	terminate_minimal_symbol_table.
	* symfile.c (reread_symbols): Same.

	* objfiles.h: Revert patch from 2003-01-27, to be replaced by
	similar patch from Jim Blandy.
	* objfiles.c (objfile_relocate): Ditto.
	* i386-linux-tdep.c (find_minsym_and_objfile): Ditto.
	* arm-linux-tdep.c (find_minsym_and_objfile): Ditto.
	* gdbtypes.h: Delete INTEGER_COERCION_BADNESS,
	FLOAT_COERCION_BADNESS.
	* gdbtypes.c (rank_one_type): Replace all uses of
	INTEGER_COERCION_BADNESS by INTEGER_CONVERSION_BADNESS.
	* valops.c (find_overload_match): Call cp_func_name.
	* cp-support.h: Declare cp_func_name.
	* cp-support.c (cp_func_name): New function.

2003-01-30  David Carlton  <carlton@@math.stanford.edu>

	* valops.c (find_overload_match): Move code into
	find_oload_champ_namespace.
	(find_oload_champ_namespace): New function, which immediately gets
	eviscerated and turned into a call to
	find_oload_champ_namespace_loop.
	(find_oload_champ_namespace_loop): New function.
	* symtab.c (make_symbol_overload_list): Move entire body into
	make_symbol_overload_list_qualified.
	(make_symbol_overload_list_qualified): New.
	(read_in_psymtabs): New.
	(make_symbol_overload_list_qualified): Rewrite.
	(make_symbol_overload_list_using): New.
	(lookup_symbol_namespace): Use alloca, not xmalloc.
	(make_symbol_overload_list): Put some memory management stuff back
	in.
@
text
@a169 9
static void make_symbol_overload_list_using (const char *func_name,
					     const char *namespace_name,
					     int namespace_len,
					     const struct block *block);

static void make_symbol_overload_list_qualified (const char *func_name);

static void read_in_psymtabs (const char *oload_name);

d1296 1
a1296 1
	= alloca (namespace_len + 2 + strlen (name) + 1);
d1305 1
a3961 3
/* FIXME: carlton/2003-01-30: Should BLOCK be here?  Maybe it's better
   to use get_selected_block (0).  */

d3967 8
a3974 1
  struct cleanup *old_cleanups;
d3978 3
a3980 2
  sym_return_val = xmalloc ((sym_return_val_size + 1) *
			    sizeof (struct symbol *));
d3983 2
a3984 1
  old_cleanups = make_cleanup (xfree, sym_return_val);
d3986 3
a3988 2
  make_symbol_overload_list_using (func_name, namespace_name,
				   namespace_len, block);
d3990 4
a3993 1
  discard_cleanups (old_cleanups);
d3995 9
a4003 2
  return sym_return_val;
}
d4005 9
a4013 69
/* This applies the using directives to add namespaces to search in,
   and then searches for overloads in all of those namespaces.  It
   adds the symbols found to sym_return_val.  Arguments are as in
   make_symbol_overload_list.  */

static void
make_symbol_overload_list_using (const char *func_name,
				 const char *namespace_name,
				 int namespace_len,
				 const struct block *block)
{
  struct block_using_iterator iter;
  const struct using_direct *current;

  /* First, go through the using directives.  If any of them apply,
     look in the appropriate namespaces for new functions to match
     on.  */

  for (current = block_using_iterator_first (block, &iter);
       current != NULL;
       current = block_using_iterator_next (&iter))
    {
      if (namespace_len == current->outer_length
	  && strncmp (namespace_name, current->name, namespace_len) == 0)
	{
	  make_symbol_overload_list_using (func_name,
					   current->name,
					   current->inner_length,
					   block);
	}
    }

  /* Now, add names for this namespace.  */
  
  if (namespace_len == 0)
    {
      make_symbol_overload_list_qualified (func_name);
    }
  else
    {
      char *concatenated_name
	= alloca (namespace_len + 2 + strlen (func_name) + 1);
      strncpy (concatenated_name, namespace_name, namespace_len);
      strcpy (concatenated_name + namespace_len, "::");
      strcpy (concatenated_name + namespace_len + 2, func_name);
      make_symbol_overload_list_qualified (concatenated_name);
    }
}

/* This does the bulk of the work of finding overloaded symbols.
   FUNC_NAME is the name of the overloaded function we're looking for
   (possibly including namespace info); NEW_LIST is 1 if we should
   allocate a new list of overloads and 0 if we should continue using
   the same old list.  */

static void
make_symbol_overload_list_qualified (const char *func_name)
{
  struct symbol *sym;
  struct symtab *s;
  struct objfile *objfile;
  const struct block *b, *surrounding_static_block = 0;
  struct dict_iterator iter;
  const struct dictionary *dict;

  /* Look through the partial symtabs for all symbols which begin
     by matching FUNC_NAME.  Make sure we read that symbol table in. */

  read_in_psymtabs (func_name);
d4020 1
a4020 5
      dict = BLOCK_DICT (b);

      for (sym = dict_iter_name_first (dict, func_name, &iter);
	   sym;
	   sym = dict_iter_name_next (func_name, &iter))
d4022 1
a4022 1
	  overload_list_add_symbol (sym, func_name);
d4024 8
a4033 2
  surrounding_static_block = block_static_block (get_selected_block (0));

a4036 4
  /* FIXME: carlton/2003-01-30: Why are we checking all the statics?
     Also, this shouldn't check all the globals if there's an
     anonymous namespace involved somewhere.  */

d4041 1
a4041 5
    dict = BLOCK_DICT (b);

    for (sym = dict_iter_name_first (dict, func_name, &iter);
	 sym;
	 sym = dict_iter_name_next (func_name, &iter))
d4043 1
a4043 1
      overload_list_add_symbol (sym, func_name);
d4054 1
a4054 5
    dict = BLOCK_DICT (b);

    for (sym = dict_iter_name_first (dict, func_name, &iter);
	 sym;
	 sym = dict_iter_name_next (func_name, &iter))
d4056 1
a4056 1
      overload_list_add_symbol (sym, func_name);
a4058 15
}

/* Look through the partial symtabs for all symbols which begin
   by matching FUNC_NAME.  Make sure we read that symbol table in. */

/* FIXME: carlton/2003-01-30.  Lies, all lies.  The function does
   nothing of the kind: it just reads in every single partial symtab.
   (It used to do it in a particularly amusing way, but I've fixed
   that.)  */

static void
read_in_psymtabs (const char *func_name)
{
  struct partial_symtab *ps;
  struct objfile *objfile;
d4060 1
a4060 5
  ALL_PSYMTABS (objfile, ps)
  {
    if (!ps->readin)
      psymtab_to_symtab (ps);
  }
@


1.70.2.29
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d4 2
a5 2
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
a45 2
#include "hashtab.h"

d459 4
d470 1
a470 18
/* Functions to initialize a symbol's mangled name.  */

/* Create the hash table used for demangled names.  Each hash entry is
   a pair of strings; one for the mangled name and one for the demangled
   name.  The entry is hashed via just the mangled name.  */

static void
create_demangled_names_hash (struct objfile *objfile)
{
  /* Choose 256 as the starting size of the hash table, somewhat arbitrarily.
     The hash table code will round this up to the next prime number. 
     Choosing a much larger table size wastes memory, and saves only about
     1% in symbol reading.  */

  objfile->demangled_names_hash = htab_create_alloc_ex
    (256, htab_hash_string, (int (*) (const void *, const void *)) streq,
     NULL, objfile->md, xmcalloc, xmfree);
}
d472 1
a472 1
/* Try to determine the demangled name for a symbol, based on the
d475 5
a479 2
   then set the language appropriately.  The returned name is allocated
   by the demangler and should be xfree'd.  */
d481 3
a483 3
static char *
symbol_find_demangled_name (struct general_symbol_info *gsymbol,
			    const char *mangled)
d485 1
d493 1
a493 2
      demangled =
        cplus_demangle (mangled, DMGL_PARAMS | DMGL_ANSI);
d497 7
a503 1
	  return demangled;
d509 1
a509 2
        cplus_demangle (mangled,
                        DMGL_PARAMS | DMGL_ANSI | DMGL_JAVA);
d513 3
a515 52
	  return demangled;
	}
    }
  return NULL;
}

/* Set both the mangled and demangled (if any) names for GSYMBOL based on
   NAME and LEN.  The hash table corresponding to OBJFILE is used, and the
   memory comes from that objfile's symbol_obstack.  NAME is copied, so the
   pointer can be discarded after calling this function.  */

void
symbol_set_names (struct general_symbol_info *gsymbol,
		  const char *name, int len, struct objfile *objfile)
{
  char **slot;
  const char *tmpname;

  if (objfile->demangled_names_hash == NULL)
    create_demangled_names_hash (objfile);

  /* The stabs reader generally provides names that are not NULL-terminated;
     most of the other readers don't do this, so we can just use the given
     copy.  */
  if (name[len] != 0)
    {
      char *alloc_name = alloca (len + 1);
      memcpy (alloc_name, name, len);
      alloc_name[len] = 0;
      tmpname = alloc_name;
    }
  else
    tmpname = name;

  slot = (char **) htab_find_slot (objfile->demangled_names_hash, tmpname, INSERT);

  /* If this name is not in the hash table, add it.  */
  if (*slot == NULL)
    {
      char *demangled_name = symbol_find_demangled_name (gsymbol, tmpname);
      int demangled_len = demangled_name ? strlen (demangled_name) : 0;

      /* If there is a demangled name, place it right after the mangled name.
	 Otherwise, just place a second zero byte after the end of the mangled
	 name.  */
      *slot = obstack_alloc (&objfile->symbol_obstack,
			     len + demangled_len + 2);
      memcpy (*slot, tmpname, len + 1);
      if (demangled_name)
	{
	  memcpy (*slot + len + 1, demangled_name, demangled_len + 1);
	  xfree (demangled_name);
a517 28
	(*slot)[len + 1] = 0;
    }

  gsymbol->name = *slot;
  if ((*slot)[len + 1])
    gsymbol->language_specific.cplus_specific.demangled_name
      = &(*slot)[len + 1];
  else
    gsymbol->language_specific.cplus_specific.demangled_name = NULL;
}

/* Initialize the demangled name of GSYMBOL if possible.  Any required space
   to store the name is obtained from the specified obstack.  The function
   symbol_set_names, above, should be used instead where possible for more
   efficient memory usage.  */

void
symbol_init_demangled_name (struct general_symbol_info *gsymbol,
                            struct obstack *obstack)
{
  char *mangled = gsymbol->name;
  char *demangled = NULL;

  demangled = symbol_find_demangled_name (gsymbol, mangled);
  if (gsymbol->language == language_cplus
      || gsymbol->language == language_java)
    {
      if (demangled)
d519 1
a519 3
	  gsymbol->language_specific.cplus_specific.demangled_name
	    = obsavestring (demangled, strlen (demangled), obstack);
	  xfree (demangled);
a520 8
      else
	gsymbol->language_specific.cplus_specific.demangled_name = NULL;
    }
  else
    {
      /* Unknown language; just clean up quietly.  */
      if (demangled)
	xfree (demangled);
d522 20
d559 3
d784 5
a788 5
   out of here: find_proc_desc in alpha-tdep.c and mips-tdep.c.  (Note
   that there is C++ code below which can error(), but that probably
   doesn't affect these calls since they are looking for a known
   variable and thus can probably assume it will never hit the C++
   code).  */
d2106 1
a2106 3
         If so, record this file, and its best line, as best so far.  Don't
         save prev if it represents the end of a function (i.e. line number
         0) instead of a real line.  */
d2108 1
a2108 1
      if (prev && prev->line && (!best || prev->pc > best->pc))
@


1.70.2.30
log
@2003-02-11  David Carlton  <carlton@@math.stanford.edu>

	* valops.c (find_oload_champ): Add comment.
	(find_oload_champ_namespace_loop): Fix memory management.
	(find_oload_champ_namespace): Add comment.
	(find_overload_match): Free oload_syms, oload_champ_bv.
	* gdbtypes.c (rank_function): Add comment.
	* valops.c (find_oload_champ_namespace_loop): Allow num_fns to be
	zero.
	* symtab.c (lookup_partial_symbol): Use strcmp_iw_ordered.
	(lookup_block_symbol): Delete comment.
	* symfile.c (compare_psymbols): Use strcmp_iw_ordered.
	* defs.h: Declare strcmp_iw_ordered.
	* utils.c (strcmp_iw_ordered): New function.
@
text
@d1520 2
a1521 2
         pointing at the earliest partial symbol whose name might be
         correct.  At that point *all* partial symbols with that name
d1538 1
a1538 1
	  if (strcmp_iw_ordered (SYMBOL_BEST_NAME (*center), name) >= 0)
d1744 16
d4198 5
d4211 1
a4211 5
    if (ps->readin)
      continue;

    if ((lookup_partial_symbol (ps, func_name, 1, VAR_NAMESPACE) != NULL)
	|| (lookup_partial_symbol (ps, func_name, 0, VAR_NAMESPACE) != NULL))
@


1.70.2.31
log
@2003-02-12  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (examine_compound_token): Call decode_namespace.
	(decode_namespace): New function.
	* cp-support.c (cp_find_first_component): Return the offset, not a
	pointer.
	(check_possible_namespace_symbols_loop): Update call to
	cp_find_first_component.
	(cp_check_possible_namespace_symbols): Ditto.
	(cp_func_name): Ditto.
	* buildsym.c (scan_for_anonymous_namespaces): Ditto.
	(finish_block): Ditto.
	* linespec.c (examine_compound_token): Ditto.
	* symtab.c (lookup_symbol_aux_using_loop): Ditto.
	* valops.c (find_oload_champ_namespace_loop): Ditto.
	* cp-support.h: Declare cp_find_first_component to return an int.
	* Makefile.in (linespec.o): cp_support_h.
	* linespec.c (symtab_from_filename): Rename from handle_filename.
	(decode_line_1): Call symtab_from_filename instead of
	handle_filename.
	(locate_compound_sym): Rename from locate_class_sym.  Search in
	such a way that we find namespace symbols, too.
	(examine_compound_token): Call locate_class_sym instead of
	locate_compound_sym.
	(locate_compound_sym): Add NAMESPACE arg.
	(examine_compound_token): New arg to locate_compound_sym.
	Handle TYPE_CODE_NAMESPACE.
	#include "cp-support.hp"
@
text
@d1293 1
d1302 1
a1302 1
      new_scope_len += cp_find_first_component (scope + new_scope_len);
d1304 1
a1304 1
					  symtab, scope, new_scope_len);
@


1.70.2.32
log
@2003-02-21  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (locate_compound_sym): Update call to
	lookup_symbol_namespace.
	* symtab.c (make_symbol_overload_list): Delete namespace_len
	argument.
	* symtab.h: Update declaration for make_symbol_overload_list.
	* valops.c (find_oload_champ_namespace_loop): New format for
	make_symbol_overload_list.
	* symtab.c (lookup_symbol_namespace): Delete namespace_len
	argument.
	(lookup_symbol_aux_using_loop): Update call to
	lookup_symbol_namespace.
	(make_symbol_overload_list_using): Delete namespace_len argument.
	* linespec.c (decode_namespace): Update call to
	lookup_symbol_namespace.
	* valops.c (value_namespace_elt): Ditto.
	* symtab.c (lookup_nested_type): Ditto.
	* symtab.h: Update declaration for lookup_symbol_namespace.
	* block.c (block_all_usings): Delete.
	(block_using): Make static.
	(block_using_iterator_next): New using_direct format.
	(block_using_iterator_first): Ditto.
	* buildsym.c (scan_for_anonymous_namespaces): Rename variables.
	(add_using_directive): New using functions.
	(end_symtab): Use cp_copy_usings.
	(copy_usings_to_obstack): Delete.
	* block.c: Tweak initial comment.
	(struct namespace_info): Move here.
	(block_initialize_namespace): Set scope to NULL!
	* block.h: Add compilation guards.
	Reorder and update declarations.
	* cp-support.c (cp_find_first_component): Return unsigned int.
	(cp_entire_prefix_len): New.
	(cp_add_using_obstack): Delete.
	(cp_add_using_xmalloc): Delete.
	(cp_copy_usings): Rewrite.
	(cp_free_usings): Delete.
	(cp_add_using): New.
	(cp_is_anonymous): Delete second argument.
	(xstrndup): New.
	* cp-support.h: Add compilation guards.
	Update declarations.
	* coffread.c: New variable coff_source_file.
	(coff_start_symtab): Use coff_source_file.
	(complete_symtab): Ditto.
	(coff_end_symtab): Ditto.
	(coff_symtab_read): Ditto.
	* dbxread.c (find_stab_function_addr): Const fix.
	* buildsym.h: Const fix.
	* buildsym.c (start_symtab): Const fix.
	(start_subfile): Ditto.
	* cp-support.c (cp_add_using_xmalloc): Copy name.
	* dwarf2read.c (read_namespace): Loop through extensions
	correctly.
	(read_file_scope): Const fix.
	(dwarf2_add_field): Ditto.
	(read_structure_scope): Ditto.
	(read_enumeration): Ditto.
	(read_typedef): Ditto.
	* buildsym.c (finish_block): Update comments and simplify code
	when setting scope.
	* buildsym.h: Add opaque declaration of 'struct block'.
	Change comment before processing_current_prefix.
	* arm-tdep.c (arm_gdbarch_init): Add break; after default:.
@
text
@d173 2
a174 1
					     const char *namespace,
a1289 2
  char *cp_namespace;

d1308 1
a1308 4
  cp_namespace = alloca (scope_len + 1);
  strncpy (cp_namespace, scope, scope_len);
  cp_namespace[scope_len] = '\0';
  return lookup_symbol_namespace (cp_namespace, name, linkage_name,
d1312 13
a1324 3
/* This tries to look up NAME in the C++ namespace CP_NAMESPACE.  It
   applies the using directives that are active in BLOCK.  Otherwise,
   arguments are as in lookup_symbol_aux.  */
d1327 2
a1328 1
lookup_symbol_namespace (const char *cp_namespace,
d1332 1
a1332 1
			 namespace_enum gdb_namespace,
d1347 2
a1348 1
      if (strcmp (cp_namespace, current->outer) == 0)
d1350 2
a1351 1
	  sym = lookup_symbol_namespace (current->inner,
d1355 1
a1355 1
					 gdb_namespace,
d1366 1
a1366 1
  if (cp_namespace[0] == '\0')
d1369 1
a1369 1
				     gdb_namespace, symtab,
d1375 4
a1378 4
	= alloca (strlen (cp_namespace) + 2 + strlen (name) + 1);
      strcpy (concatenated_name, cp_namespace);
      strcat (concatenated_name, "::");
      strcat (concatenated_name, name);
d1380 4
a1383 2
				    block, gdb_namespace, symtab,
				    cp_is_anonymous (cp_namespace));
d1476 1
d4031 2
a4032 2
			   const char *namespace,
			   const struct block *block)
d4044 2
a4045 2
  make_symbol_overload_list_using (func_name, namespace,
				   block);
d4059 2
a4060 1
				 const char *namespace,
d4074 2
a4075 1
      if (strcmp (namespace, current->outer) == 0)
d4078 2
a4079 1
					   current->inner,
d4086 1
a4086 1
  if (namespace[0] == '\0')
d4093 4
a4096 4
	= alloca (strlen (namespace) + 2 + strlen (func_name) + 1);
      strcpy (concatenated_name, namespace);
      strcat (concatenated_name, "::");
      strcat (concatenated_name, func_name);
@


1.70.2.33
log
@2003-02-27  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_namespace_scope): Rename from
	lookup_symbol_aux_using_loop.
	(lookup_symbol_aux_using): Delete.
	(lookup_symbol_aux): Call lookup_symbol_aux_namespace_scope
	instead of lookup_symbol_aux_using.
@
text
@d137 14
a150 7
struct symbol *lookup_symbol_aux_namespace_scope (const char *name,
						  const char *linkage_name,
						  const struct block *block,
						  namespace_enum namespace,
						  struct symtab **symtab,
						  const char *scope,
						  int scope_len);
d967 3
a969 1
     In the C++ case, do lookup in namespace scope.  */
d971 2
a972 3
  sym = lookup_symbol_aux_namespace_scope (name, linkage_name, block,
					   namespace, symtab,
					   block_scope (block), 0);
d1262 17
a1278 4
/* Lookup NAME at namespace scope (or, in C terms, in static and
   global variables).  SCOPE is the namespace that the current
   function is defined within; only consider namespaces whose length
   is at least SCOPE_LEN.  (This is to make the recursion easier.)  */
d1281 7
a1287 7
lookup_symbol_aux_namespace_scope (const char *name,
				   const char *linkage_name,
				   const struct block *block,
				   namespace_enum namespace,
				   struct symtab **symtab,
				   const char *scope,
				   int scope_len)
d1303 2
a1304 3
      sym = lookup_symbol_aux_namespace_scope (name, linkage_name, block,
					       namespace, symtab,
					       scope, new_scope_len);
@


1.70.2.34
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d26 1
a48 1
#include "block.h"
a82 1
						     const char *,
d445 1
a445 2
      || gsymbol->language == language_java
      || gsymbol->language == language_objc)
d449 4
a610 19
/* Return the source code name of a symbol.  In languages where
   demangling is necessary, this is the demangled name.  */

char *
symbol_natural_name (const struct general_symbol_info *gsymbol)
{
  if ((gsymbol->language == language_cplus
       || gsymbol->language == language_java
       || gsymbol->language == language_objc)
      && (gsymbol->language_specific.cplus_specific.demangled_name != NULL))
    {
      return gsymbol->language_specific.cplus_specific.demangled_name;
    }
  else
    {
      return gsymbol->name;
    }
}

d617 1
a617 2
      || gsymbol->language == language_java
      || gsymbol->language == language_objc)
d620 3
d1217 1
a1217 2
	&& lookup_partial_symbol (ps, name, linkage_name,
				  psymtab_index, namespace))
d1365 1
a1365 1
				     SYMBOL_NATURAL_NAME (minsym),
d1461 2
a1462 4
/* Look, in partial_symtab PST, for symbol whose natural name is NAME.
   If LINKAGE_NAME is non-NULL, check in addition that the symbol's
   linkage name matches it.  Check the global symbols if GLOBAL, the
   static symbols if not */
d1466 1
a1466 2
		       const char *linkage_name, int global,
		       namespace_enum namespace)
d1488 2
a1489 3
         correct.  At that point *all* partial symbols with an
         appropriate name will be checked against the correct
         namespace.  */
d1505 1
a1505 1
	  if (strcmp_iw_ordered (SYMBOL_NATURAL_NAME (*center), name) >= 0)
d1518 4
a1521 4
      while (top <= real_top
	     && (linkage_name != NULL
		 ? strcmp (SYMBOL_LINKAGE_NAME (*top), linkage_name) == 0
		 : SYMBOL_MATCHES_NATURAL_NAME (*top,name)))
d1540 1
a1540 3
	      if (linkage_name != NULL
		  ? strcmp (SYMBOL_LINKAGE_NAME (*psym), linkage_name) == 0
		  : SYMBOL_MATCHES_NATURAL_NAME (*psym, name))
d1600 1
a1600 2
    if (!ps->readin && lookup_partial_symbol (ps, name, NULL,
					      1, STRUCT_NAMESPACE))
d1647 1
a1647 1
    if (!ps->readin && lookup_partial_symbol (ps, name, NULL, 0, STRUCT_NAMESPACE))
d1688 1
a1688 1
    if (lookup_partial_symbol (pst, main_name (), NULL, 1, VAR_NAMESPACE))
a1745 1

d1776 1
a1776 2
		  SYMBOL_CLASS (sym) != LOC_BASEREG_ARG &&
		  SYMBOL_CLASS (sym) != LOC_COMPUTED_ARG)
d2043 2
a2044 1
	mfunsym = lookup_minimal_symbol_text (DEPRECATED_SYMBOL_NAME (msymbol), NULL, NULL);
d2055 2
a2056 1
	  /* warning ("In stub for %s; unable to find real function/line info", DEPRECATED_SYMBOL_NAME (msymbol)) */ ;
d2061 2
a2062 1
	  /* warning ("In stub for %s; unable to find real function/line info", DEPRECATED_SYMBOL_NAME (msymbol)) */ ;
d2772 2
a2773 2
  return strcmp (SYMBOL_PRINT_NAME ((*sym_a)->symbol),
		 SYMBOL_PRINT_NAME ((*sym_b)->symbol));
d2952 11
a2962 7
		&& ((regexp == NULL
		     || re_exec (SYMBOL_NATURAL_NAME (*psym)) != 0)
		    && ((kind == VARIABLES_NAMESPACE && SYMBOL_CLASS (*psym) != LOC_TYPEDEF
			 && SYMBOL_CLASS (*psym) != LOC_BLOCK)
			|| (kind == FUNCTIONS_NAMESPACE && SYMBOL_CLASS (*psym) == LOC_BLOCK)
			|| (kind == TYPES_NAMESPACE && SYMBOL_CLASS (*psym) == LOC_TYPEDEF)
			|| (kind == METHODS_NAMESPACE && SYMBOL_CLASS (*psym) == LOC_BLOCK))))
d2993 1
a2993 2
	    if (regexp == NULL
		|| re_exec (SYMBOL_NATURAL_NAME (msymbol)) != 0)
d3021 33
a3053 27
	    {
	      QUIT;
	      if (file_matches (s->filename, files, nfiles)
		  && ((regexp == NULL
		       || re_exec (SYMBOL_NATURAL_NAME (sym)) != 0)
		      && ((kind == VARIABLES_NAMESPACE && SYMBOL_CLASS (sym) != LOC_TYPEDEF
			   && SYMBOL_CLASS (sym) != LOC_BLOCK
			   && SYMBOL_CLASS (sym) != LOC_CONST)
			  || (kind == FUNCTIONS_NAMESPACE && SYMBOL_CLASS (sym) == LOC_BLOCK)
			  || (kind == TYPES_NAMESPACE && SYMBOL_CLASS (sym) == LOC_TYPEDEF)
			  || (kind == METHODS_NAMESPACE && SYMBOL_CLASS (sym) == LOC_BLOCK))))
		{
		  /* match */
		  psr = (struct symbol_search *) xmalloc (sizeof (struct symbol_search));
		  psr->block = i;
		  psr->symtab = s;
		  psr->symbol = sym;
		  psr->msymbol = NULL;
		  psr->next = NULL;
		  if (tail == NULL)
		    sr = psr;
		  else
		    tail->next = psr;
		  tail = psr;
		  nfound ++;
		}
	    }
d3085 1
a3085 2
	    if (regexp == NULL
		|| re_exec (SYMBOL_NATURAL_NAME (msymbol)) != 0)
d3151 1
a3151 2
		   ? "" : SYMBOL_PRINT_NAME (sym)),
		  gdb_stdout, 0);
d3169 2
a3170 4
    tmp = local_hex_string_custom (SYMBOL_VALUE_ADDRESS (msymbol),
				   "016l");
  printf_filtered ("%s  %s\n",
		   tmp, SYMBOL_PRINT_NAME (msymbol));
d3263 1
a3263 1
					  + strlen (DEPRECATED_SYMBOL_NAME (p->symbol))
d3267 1
a3267 1
	  strcat (string, DEPRECATED_SYMBOL_NAME (p->symbol));
d3276 1
a3276 1
	  break_command (DEPRECATED_SYMBOL_NAME (p->msymbol), from_tty);
d3302 1
a3302 1
	(DEPRECATED_SYMBOL_NAME (symbol), (sym_text), (len), (text), (word)); \
d3958 1
a3958 1
    if (!strcmp (DEPRECATED_SYMBOL_NAME (sym), DEPRECATED_SYMBOL_NAME (sym_return_val[i])))
d4157 2
a4158 4
    if ((lookup_partial_symbol (ps, func_name, NULL, 1, VAR_NAMESPACE)
	 != NULL)
	|| (lookup_partial_symbol (ps, func_name, NULL, 0, VAR_NAMESPACE)
	    != NULL))
@


1.70.2.35
log
@2003-03-07  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_partial_symbol): Replace uses of
	SYMBOL_MATCHES_NATURAL_NAME by equivalent uses of
	SYMBOL_NATURAL_NAME, strcmp_iw.
	* symtab.h (SYMBOL_MATCHES_NATURAL_NAME): Delete.
	* minsyms.c (lookup_minimal_symbol_linkage): Make static.
	(lookup_minimal_symbol_natural): Ditto.
	(lookup_minimal_symbol): Only search on linkage names; rename
	first argument to 'linkage_name'.
	(lookup_minimal_symbol_linkage): Delete.
	(lookup_minimal_symbol_natural): Delete.
	(add_minsym_to_demangled_hash_table): Go back to using
	SYMBOL_DEMANGLED_NAME instead of SYMBOL_NATURAL_NAME.
	(lookup_minimal_symbol_aux): Don't use
	SYMBOL_MATCHES_NATURAL_NAME: do a strcmp_iw on
	SYMBOL_DEMANGLED_NAME instead.  Add comment.
	(build_minimal_symbol_hash_tables): Go back to only adding to
	demangled has table if SYMBOL_DEMANGLED_NAME is non-NULL.
	* symtab.h: Delete declarations for lookup_minimal_symbol_linkage
	and lookup_minimal_symbol_natural.
	* valops.c (find_function_in_inferior): Use lookup_symbol_linkage
	instead of lookup_symbol.  Change comment.
	* remote.c (remote_check_symbols): Use
	lookup_minimal_symbol_linkage_or_natural instead of
	lookup_minimal_symbol, but add FIXME comment as well.
	* objc-lang.c: Ditto.
	* c-exp.y: Use lookup_minimal_symbol_linkage_or_natural instead of
	lookup_minimal_symbol.
	* p-exp.y: Ditto.
	* objc-exp.y: Ditto.
	* m2-exp.y: Ditto.
	* jv-exp.y (push_expression_name): Ditto.
	* f-exp.y: Ditto.
	* printcmd.c (address_info): Ditto.
	* symtab.h: Declare lookup_minimal_symbol_linkage_or_natural.
	* minsyms.c (lookup_minimal_symbol_linkage_or_natural): New.
	* ax-gdb.c (gen_var_ref): Use SYMBOL_LINKAGE_NAME instead of
	DEPRECATED_SYMBOL_NAME.
	* tracepoint.c (scope_info): Ditto.
	* symtab.c (find_pc_sect_line): Ditto.
	* stabsread.c (define_symbol): Ditto.
	* sol-thread.c (info_cb): Ditto.
	* printcmd.c (address_info): Ditto.
	* hppa-tdep.c (hppa_fix_call_dummy): Ditto.
	(hppa_in_solib_call_trampoline): Ditto.
	* findvar.c (read_var_value): Ditto.
@
text
@d1541 1
a1541 1
		 : strcmp_iw (SYMBOL_NATURAL_NAME (*top), name) == 0))
d1562 1
a1562 1
		  : strcmp_iw (SYMBOL_NATURAL_NAME (*psym), name) == 0)
d2068 1
a2068 1
	mfunsym = lookup_minimal_symbol_text (SYMBOL_LINKAGE_NAME (msymbol), NULL, NULL);
@


1.70.2.36
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d516 4
a519 24
/* Set both the mangled and demangled (if any) names for GSYMBOL based
   on LINKAGE_NAME and LEN.  The hash table corresponding to OBJFILE
   is used, and the memory comes from that objfile's symbol_obstack.
   LINKAGE_NAME is copied, so the pointer can be discarded after
   calling this function.  */

/* We have to be careful when dealing with Java names: when we run
   into a Java minimal symbol, we don't know it's a Java symbol, so it
   gets demangled as a C++ name.  This is unfortunate, but there's not
   much we can do about it: but when demangling partial symbols and
   regular symbols, we'd better not reuse the wrong demangled name.
   (See PR gdb/1039.)  We solve this by putting a distinctive prefix
   on Java names when storing them in the hash table.  */

/* FIXME: carlton/2003-03-13: This is an unfortunate situation.  I
   don't mind the Java prefix so much: different languages have
   different demangling requirements, so it's only natural that we
   need to keep language data around in our demangling cache.  But
   it's not good that the minimal symbol has the wrong demangled name.
   Unfortunately, I can't think of any easy solution to that
   problem.  */

#define JAVA_PREFIX "##JAVA$$"
#define JAVA_PREFIX_LEN 8
d523 1
a523 1
		  const char *linkage_name, int len, struct objfile *objfile)
d526 1
a526 7
  /* A 0-terminated copy of the linkage name.  */
  const char *linkage_name_copy;
  /* A copy of the linkage name that might have a special Java prefix
     added to it, for use when looking names up in the hash table.  */
  const char *lookup_name;
  /* The length of lookup_name.  */
  int lookup_len;
d531 4
a534 4
  /* The stabs reader generally provides names that are not
     NUL-terminated; most of the other readers don't do this, so we
     can just use the given copy, unless we're in the Java case.  */
  if (gsymbol->language == language_java)
d536 4
a539 22
      char *alloc_name;
      lookup_len = len + JAVA_PREFIX_LEN;

      alloc_name = alloca (lookup_len + 1);
      memcpy (alloc_name, JAVA_PREFIX, JAVA_PREFIX_LEN);
      memcpy (alloc_name + JAVA_PREFIX_LEN, linkage_name, len);
      alloc_name[lookup_len] = '\0';

      lookup_name = alloc_name;
      linkage_name_copy = alloc_name + JAVA_PREFIX_LEN;
    }
  else if (linkage_name[len] != '\0')
    {
      char *alloc_name;
      lookup_len = len;

      alloc_name = alloca (lookup_len + 1);
      memcpy (alloc_name, linkage_name, len);
      alloc_name[lookup_len] = '\0';

      lookup_name = alloc_name;
      linkage_name_copy = alloc_name;
d542 1
a542 5
    {
      lookup_len = len;
      lookup_name = linkage_name;
      linkage_name_copy = linkage_name;
    }
d544 1
a544 2
  slot = (char **) htab_find_slot (objfile->demangled_names_hash,
				   lookup_name, INSERT);
d549 1
a549 2
      char *demangled_name = symbol_find_demangled_name (gsymbol,
							 linkage_name_copy);
d556 3
a558 3
			     lookup_len + demangled_len + 2);
      memcpy (*slot, lookup_name, lookup_len + 1);
      if (demangled_name != NULL)
d560 1
a560 1
	  memcpy (*slot + lookup_len + 1, demangled_name, demangled_len + 1);
d564 1
a564 1
	(*slot)[lookup_len + 1] = '\0';
d567 2
a568 2
  gsymbol->name = *slot + lookup_len - len;
  if ((*slot)[lookup_len + 1] != '\0')
d570 1
a570 1
      = &(*slot)[lookup_len + 1];
@


1.70.2.37
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@a42 1
#include "objc-lang.h"
a490 12

  if (gsymbol->language == language_objc
      || gsymbol->language == language_auto)
    {
      demangled =
	objc_demangle (mangled, 0);
      if (demangled != NULL)
	{
	  gsymbol->language = language_objc;
	  return demangled;
	}
    }
d639 1
a639 2
      || gsymbol->language == language_java
      || gsymbol->language == language_objc)
d1008 1
a1008 1
  /* C++/Java/Objective-C: If requested to do so by the caller, 
d1776 3
a1778 3
   search on the symbols.  Each symbol which is marked as being a ObjC/C++
   symbol (language_cplus or language_objc set) has both the encoded and 
   non-encoded names tested for a match.
@


1.70.2.38
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d58 1
d86 1
a86 1
						     domain_enum);
d91 1
a91 1
					 const domain_enum domain,
d99 1
a99 1
					const domain_enum domain,
d103 22
d128 1
a128 1
					  const domain_enum domain,
d135 1
a135 1
					   const domain_enum domain,
a137 1
#if 0
d139 7
a145 6
struct symbol *lookup_symbol_aux_minsyms (const char *name,
					  const char *linkage_name,
					  const domain_enum domain,
					  int *is_a_field_of_this,
					  struct symtab **symtab);
#endif
d157 1
a157 1
static void print_symbol_info (domain_enum,
d162 1
a162 1
static void symtab_symbol_info (char *, domain_enum, int);
d221 1
a221 1
      
d224 1
a224 1
    
d237 1
a237 1
        make_cleanup (xfree, rp);
d325 1
a325 1
        char *rp = NULL;
d328 5
a332 5
        if (pst->fullname != NULL)
          {
            rp = gdb_realpath (pst->fullname);
            make_cleanup (xfree, rp);
          }
d420 7
a426 7
    {
      mangled_name = (char *) xmalloc (mangled_name_len);
      if (is_constructor)
	mangled_name[0] = '\0';
      else
	strcpy (mangled_name, field_name);
    }
d671 1
d722 1
a722 1
find_pc_sect_psymtab (CORE_ADDR pc, asection *section)
d736 1
a736 2
	  || msymbol->type == mst_file_data
	  || msymbol->type == mst_file_bss))
d749 1
a749 2
	if (!(objfile->flags & OBJF_REORDERED) &&
	    section == 0)	/* can't validate section this way */
d788 1
a788 1
		      asection *section)
d805 3
a807 3
    (pp - (psymtab->objfile->global_psymbols.list + psymtab->globals_offset)
     < psymtab->n_global_syms);
       pp++)
d810 1
a810 1
      if (SYMBOL_DOMAIN (p) == VAR_DOMAIN
d829 3
a831 3
    (pp - (psymtab->objfile->static_psymbols.list + psymtab->statics_offset)
     < psymtab->n_static_syms);
       pp++)
d834 1
a834 1
      if (SYMBOL_DOMAIN (p) == VAR_DOMAIN
d908 6
a913 5
/* Find the definition for a specified symbol name NAME
   in domain DOMAIN, visible from lexical block BLOCK.
   Returns the struct symbol pointer, or zero if no symbol is found.
   If SYMTAB is non-NULL, store the symbol table in which the
   symbol was found there, or NULL if not found.
d916 5
a920 3
   *IS_A_FIELD_OF_THIS to 1, otherwise set it to zero. 
   BLOCK_FOUND is set to the block in which NAME is found (in the case of
   a field of `this', value_of_this sets BLOCK_FOUND to the proper value.) */
d938 1
a938 1
	       const domain_enum domain, int *is_a_field_of_this,
d957 1
a957 1
			    domain, is_a_field_of_this, symtab);
a959 5
/* Behave like lookup_symbol_aux except that NAME is the natural name
   of the symbol that we're looking for and, if LINKAGE_NAME is
   non-NULL, ensure that the symbol's linkage name matches as
   well.  */

d962 1
a962 1
		   const struct block *block, const domain_enum domain,
d966 1
d971 1
a971 1
  sym = lookup_symbol_aux_local (name, linkage_name, block, domain,
d976 45
a1020 2
  /* If requested to do so by the caller and if appropriate for the
     current language, check to see if NAME is a field of `this'. */
d1022 3
a1024 2
  if (current_language->la_value_of_this != NULL
      && is_a_field_of_this != NULL)
d1026 1
a1026 1
      struct value *v = current_language->la_value_of_this (0);
d1038 2
a1039 2
  /* Now do whatever is appropriate for the current language to look
     up static and global variables.  */
d1041 3
a1043 3
  sym = current_language->la_lookup_symbol_nonlocal (name, linkage_name,
						     block, domain,
						     symtab);
d1048 1
a1048 4
     but more useful than an error.  Do the symtabs first, then check
     the psymtabs.  If a psymtab indicates the existence of the
     desired name as a file-level static, then do psymtab-to-symtab
     conversion on the fly and return the found symbol. */
d1050 2
a1051 7
  sym = lookup_symbol_aux_symtabs (STATIC_BLOCK, name, linkage_name,
				   domain, symtab);
  if (sym != NULL)
    return sym;
  
  sym = lookup_symbol_aux_psymtabs (STATIC_BLOCK, name, linkage_name,
				    domain, symtab);
d1061 2
a1062 1
   Don't search STATIC_BLOCK or GLOBAL_BLOCK.  */
d1067 1
a1067 1
			 const domain_enum domain,
d1073 1
a1073 1
  /* Check if either no block is specified or it's a global block.  */
d1080 1
a1080 1
      sym = lookup_symbol_aux_block (name, linkage_name, block, domain,
d1095 1
a1095 1
struct symbol *
d1098 1
a1098 1
			 const domain_enum domain,
d1107 1
a1107 1
  sym = lookup_block_symbol (block, name, linkage_name, domain);
d1133 107
d1248 1
a1248 1
			   const domain_enum domain,
d1261 1
a1261 1
    sym = lookup_block_symbol (block, name, linkage_name, domain);
d1282 1
a1282 1
			    const domain_enum domain,
d1297 1
a1297 1
				  psymtab_index, domain))
d1302 1
a1302 1
	sym = lookup_block_symbol (block, name, linkage_name, domain);
d1319 1
a1319 1
	    sym = lookup_block_symbol (block, name, linkage_name, domain);
d1334 4
a1337 18
#if 0
/* Check for the possibility of the symbol being a function or a
   mangled variable that is stored in one of the minimal symbol
   tables.  Eventually, all global symbols might be resolved in this
   way.  */

/* NOTE: carlton/2002-12-05: At one point, this function was part of
   lookup_symbol_aux, and what are now 'return' statements within
   lookup_symbol_aux_minsyms returned from lookup_symbol_aux, even if
   sym was NULL.  As far as I can tell, this was basically accidental;
   it didn't happen every time that msymbol was non-NULL, but only if
   some additional conditions held as well, and it caused problems
   with HP-generated symbol tables.  */

/* NOTE: carlton/2003-05-14: This function was once used as part of
   lookup_symbol.  It is currently unnecessary for correctness
   reasons, however, and using it doesn't seem to be any faster than
   using lookup_symbol_aux_psymtabs, so I'm commenting it out.  */
d1340 9
a1348 11
lookup_symbol_aux_minsyms (const char *name,
			   const char *linkage_name,
			   const domain_enum domain,
			   int *is_a_field_of_this,
			   struct symtab **symtab)
{
  struct symbol *sym;
  struct blockvector *bv;
  const struct block *block;
  struct minimal_symbol *msymbol;
  struct symtab *s;
d1350 1
a1350 1
  if (domain == VAR_DOMAIN)
d1352 2
a1353 1
      msymbol = lookup_minimal_symbol (name, NULL, NULL);
d1355 2
a1356 1
      if (msymbol != NULL)
d1358 33
a1390 21
	  /* OK, we found a minimal symbol in spite of not finding any
	     symbol. There are various possible explanations for
	     this. One possibility is the symbol exists in code not
	     compiled -g. Another possibility is that the 'psymtab'
	     isn't doing its job.  A third possibility, related to #2,
	     is that we were confused by name-mangling. For instance,
	     maybe the psymtab isn't doing its job because it only
	     know about demangled names, but we were given a mangled
	     name...  */

	  /* We first use the address in the msymbol to try to locate
	     the appropriate symtab. Note that find_pc_sect_symtab()
	     has a side-effect of doing psymtab-to-symtab expansion,
	     for the found symtab.  */
	  s = find_pc_sect_symtab (SYMBOL_VALUE_ADDRESS (msymbol),
				   SYMBOL_BFD_SECTION (msymbol));
	  if (s != NULL)
	    {
	      /* This is a function which has a symtab for its address.  */
	      bv = BLOCKVECTOR (s);
	      block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
d1392 3
a1394 15
	      /* This call used to pass `DEPRECATED_SYMBOL_NAME (msymbol)' as the
	         `name' argument to lookup_block_symbol.  But the name
	         of a minimal symbol is always mangled, so that seems
	         to be clearly the wrong thing to pass as the
	         unmangled name.  */
	      sym =
		lookup_block_symbol (block, name, linkage_name, domain);
	      /* We kept static functions in minimal symbol table as well as
	         in static scope. We want to find them in the symbol table. */
	      if (!sym)
		{
		  block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
		  sym = lookup_block_symbol (block, name,
					     linkage_name, domain);
		}
d1396 14
a1409 43
	      /* NOTE: carlton/2002-12-04: The following comment was
		 taken from a time when two versions of this function
		 were part of the body of lookup_symbol_aux: this
		 comment was taken from the version of the function
		 that was #ifdef HPUXHPPA, and the comment was right
		 before the 'return NULL' part of lookup_symbol_aux.
		 (Hence the "Fall through and return 0" comment.)
		 Elena did some digging into the situation for
		 Fortran, and she reports:

		 "I asked around (thanks to Jeff Knaggs), and I think
		 the story for Fortran goes like this:

		 "Apparently, in older Fortrans, '_' was not part of
		 the user namespace.  g77 attached a final '_' to
		 procedure names as the exported symbols for linkage
		 (foo_) , but the symbols went in the debug info just
		 like 'foo'. The rationale behind this is not
		 completely clear, and maybe it was done to other
		 symbols as well, not just procedures."  */

	      /* If we get here with sym == 0, the symbol was 
	         found in the minimal symbol table
	         but not in the symtab.
	         Fall through and return 0 to use the msymbol 
	         definition of "foo_".
	         (Note that outer code generally follows up a call
	         to this routine with a call to lookup_minimal_symbol(),
	         so a 0 return means we'll just flow into that other routine).

	         This happens for Fortran  "foo_" symbols,
	         which are "foo" in the symtab.

	         This can also happen if "asm" is used to make a
	         regular symbol but not a debugging symbol, e.g.
	         asm(".globl _main");
	         asm("_main:");
	       */

	      if (symtab != NULL && sym != NULL)
		*symtab = s;
	      return fixup_symbol_section (sym, s->objfile);
	    }
d1413 22
a1434 1
  return NULL;
a1435 1
#endif /* 0 */
a1438 3
/* FIXME: carlton/2003-05-23: Delete: I don't really believe in this
   any more.  Just use lookup_symbol_linkage.  */

d1442 7
a1448 1
  return lookup_symbol_linkage (SYMBOL_LINKAGE_NAME (minsym));
d1479 2
a1480 10
  sym = lookup_symbol_global (name, linkage_name, VAR_DOMAIN, NULL);

  if (sym != NULL)
    {
      xfree (demangled_name);
      return sym;
    }

  sym = lookup_symbol_aux_symtabs (STATIC_BLOCK, name, linkage_name,
				   VAR_DOMAIN, NULL);
d1488 2
a1489 2
  sym = lookup_symbol_aux_psymtabs (STATIC_BLOCK, name, linkage_name,
				    VAR_DOMAIN, NULL);
d1495 1
a1499 2
/* FIXME: Move to cp-namespace.c.  */

d1524 6
a1529 6
	struct symbol *sym = cp_lookup_symbol_namespace (parent_name,
							 nested_name,
							 NULL,
							 block,
							 VAR_DOMAIN,
							 NULL);
a1540 87
/* A default version of lookup_symbol_nonlocal for use by languages
   that can't think of anything better to do.  This implements the C
   lookup rules.  */

struct symbol *
basic_lookup_symbol_nonlocal (const char *name,
			      const char *linkage_name,
			      const struct block *block,
			      const domain_enum domain,
			      struct symtab **symtab)
{
  struct symbol *sym;

  /* NOTE: carlton/2003-05-19: The comments below were written when
     this (or what turned into this) was part of lookup_symbol_aux;
     I'm much less worried about these questions now, since these
     decisions have turned out well, but I leave these comments here
     for posterity.  */

  /* NOTE: carlton/2002-12-05: There is a question as to whether or
     not it would be appropriate to search the current global block
     here as well.  (That's what this code used to do before the
     is_a_field_of_this check was moved up.)  On the one hand, it's
     redundant with the lookup_symbol_aux_symtabs search that happens
     next.  On the other hand, if decode_line_1 is passed an argument
     like filename:var, then the user presumably wants 'var' to be
     searched for in filename.  On the third hand, there shouldn't be
     multiple global variables all of which are named 'var', and it's
     not like decode_line_1 has ever restricted its search to only
     global variables in a single filename.  All in all, only
     searching the static block here seems best: it's correct and it's
     cleanest.  */

  /* NOTE: carlton/2002-12-05: There's also a possible performance
     issue here: if you usually search for global symbols in the
     current file, then it would be slightly better to search the
     current global block before searching all the symtabs.  But there
     are other factors that have a much greater effect on performance
     than that one, so I don't think we should worry about that for
     now.  */

  sym = lookup_symbol_static (name, linkage_name, block, domain, symtab);
  if (sym != NULL)
    return sym;

  return lookup_symbol_global (name, linkage_name, domain, symtab);
}

/* Lookup a symbol in the static block associated to BLOCK, if there
   is one; do nothing if BLOCK is NULL or a global block.  */

struct symbol *
lookup_symbol_static (const char *name,
		      const char *linkage_name,
		      const struct block *block,
		      const domain_enum domain,
		      struct symtab **symtab)
{
  const struct block *static_block = block_static_block (block);

  if (static_block != NULL)
    return lookup_symbol_aux_block (name, linkage_name, static_block,
				    domain, symtab);
  else
    return NULL;
}

/* Lookup a symbol in all files' global blocks (searching psymtabs if
   necessary).  */

struct symbol *
lookup_symbol_global (const char *name,
		      const char *linkage_name,
		      const domain_enum domain,
		      struct symtab **symtab)
{
  struct symbol *sym;

  sym = lookup_symbol_aux_symtabs (GLOBAL_BLOCK, name, linkage_name,
				   domain, symtab);
  if (sym != NULL)
    return sym;

  return lookup_symbol_aux_psymtabs (GLOBAL_BLOCK, name, linkage_name,
				     domain, symtab);
}

d1549 1
a1549 1
		       domain_enum domain)
d1556 1
a1556 1
  
d1564 1
a1564 1
  
d1573 1
a1573 1
         domain.  */
d1582 2
a1583 1
	    internal_error (__FILE__, __LINE__, "failed internal consistency check");
d1599 2
a1600 1
	internal_error (__FILE__, __LINE__, "failed internal consistency check");
d1605 1
a1605 1
		 : SYMBOL_MATCHES_NATURAL_NAME (*top,name)))
d1607 1
a1607 1
	  if (SYMBOL_DOMAIN (*top) == domain)
d1609 1
a1609 1
		  return (*top);
d1619 1
a1619 1
    {			
d1622 1
a1622 1
	  if (domain == SYMBOL_DOMAIN (*psym))
d1626 1
a1626 1
		  : SYMBOL_MATCHES_NATURAL_NAME (*psym, name))
d1637 1
a1637 1
/* Look up a type named NAME in the struct_domain.  The type returned
d1642 1
a1642 1
   are available in struct_domain and only at file-static or global blocks. */
d1677 1
a1677 1
    sym = lookup_block_symbol (block, name, NULL, STRUCT_DOMAIN);
d1687 1
a1687 1
					      1, STRUCT_DOMAIN))
d1692 1
a1692 1
	sym = lookup_block_symbol (block, name, NULL, STRUCT_DOMAIN);
d1701 1
a1701 1
	    sym = lookup_block_symbol (block, name, NULL, STRUCT_DOMAIN);
d1725 1
a1725 1
    sym = lookup_block_symbol (block, name, NULL, STRUCT_DOMAIN);
d1734 1
a1734 1
    if (!ps->readin && lookup_partial_symbol (ps, name, NULL, 0, STRUCT_DOMAIN))
d1739 1
a1739 1
	sym = lookup_block_symbol (block, name, NULL, STRUCT_DOMAIN);
d1748 1
a1748 1
	    sym = lookup_block_symbol (block, name, NULL, STRUCT_DOMAIN);
d1775 1
a1775 1
    if (lookup_partial_symbol (pst, main_name (), NULL, 1, VAR_DOMAIN))
d1783 1
a1783 1
/* Search BLOCK for symbol NAME in DOMAIN.
d1794 2
a1795 2
   If LINKAGE_NAME is non-NULL, verify that any symbol we find has this
   particular mangled name.
d1800 1
a1800 2
		     const char *linkage_name,
		     const domain_enum domain)
d1810 1
a1810 1
	  if (SYMBOL_DOMAIN (sym) == domain
d1830 1
a1830 1
	  if (SYMBOL_DOMAIN (sym) == domain
d1911 1
a1911 1
find_pc_sect_symtab (CORE_ADDR pc, asection *section)
d1932 1
a1932 2
	  || msymbol->type == mst_file_data
	  || msymbol->type == mst_file_bss))
d1957 1
a1957 2
	&& (distance == 0
	    || BLOCK_END (b) - BLOCK_START (b) < distance))
d2002 1
a2002 2
(Internal error: pc 0x%s in read in psymtab, but not in symtab.)\n",
		 paddr_nz (pc));
d2230 1
a2230 1
	 use ITEM's PC as the new best_end.  */
d2232 1
a2232 1
          && (best_end == 0 || best_end > item->pc))
d2259 2
a2260 2
	 number info is available (line number is zero) then we didn't
	 find any valid line information. */
d2303 2
a2304 1
find_line_symtab (struct symtab *symtab, int line, int *index, int *exact_match)
d2523 1
a2523 2
      if (section_is_overlay (section) &&
	  !section_is_mapped (section))
d2590 1
a2590 1
      case '\\':			/* regexp quoting */
d2595 1
a2595 1
	    else			/* 'operator\*'  */
d2611 1
a2611 1
	else 
d2665 2
a2666 1
	  error ("`operator ()' must be specified without whitespace in `()'");
d2671 2
a2672 1
	  error ("`operator ?:' must be specified without whitespace in `?:'");
d2677 2
a2678 1
	  error ("`operator []' must be specified without whitespace in `[]'");
d2792 2
a2793 1
  printf_filtered ("Source files for which symbols will be read in on demand:\n\n");
d2901 4
a2904 4
   FUNCTIONS_DOMAIN - search all functions
   TYPES_DOMAIN     - search all type names
   METHODS_DOMAIN   - search all methods NOT IMPLEMENTED
   VARIABLES_DOMAIN - search all symbols, excluding functions, type names,
d2917 1
a2917 1
search_symbols (char *regexp, domain_enum kind, int nfiles, char *files[],
d2950 2
a2951 2
  if (kind < VARIABLES_DOMAIN)
    error ("must search on specific domain");
d2953 4
a2956 4
  ourtype = types[(int) (kind - VARIABLES_DOMAIN)];
  ourtype2 = types2[(int) (kind - VARIABLES_DOMAIN)];
  ourtype3 = types3[(int) (kind - VARIABLES_DOMAIN)];
  ourtype4 = types4[(int) (kind - VARIABLES_DOMAIN)];
d3040 1
a3040 1
		    && ((kind == VARIABLES_DOMAIN && SYMBOL_CLASS (*psym) != LOC_TYPEDEF
d3042 3
a3044 3
			|| (kind == FUNCTIONS_DOMAIN && SYMBOL_CLASS (*psym) == LOC_BLOCK)
			|| (kind == TYPES_DOMAIN && SYMBOL_CLASS (*psym) == LOC_TYPEDEF)
			|| (kind == METHODS_DOMAIN && SYMBOL_CLASS (*psym) == LOC_BLOCK))))
d3065 2
a3066 1
  if (nfiles == 0 && (kind == VARIABLES_DOMAIN || kind == FUNCTIONS_DOMAIN))
d3080 1
a3080 1
		    if (kind == FUNCTIONS_DOMAIN
d3109 1
a3109 1
		      && ((kind == VARIABLES_DOMAIN && SYMBOL_CLASS (sym) != LOC_TYPEDEF
d3112 3
a3114 3
			  || (kind == FUNCTIONS_DOMAIN && SYMBOL_CLASS (sym) == LOC_BLOCK)
			  || (kind == TYPES_DOMAIN && SYMBOL_CLASS (sym) == LOC_TYPEDEF)
			  || (kind == METHODS_DOMAIN && SYMBOL_CLASS (sym) == LOC_BLOCK))))
d3153 1
a3153 1
  if (found_misc || kind != FUNCTIONS_DOMAIN)
d3166 1
a3166 1
		if (kind != FUNCTIONS_DOMAIN ||
d3206 1
a3206 1
print_symbol_info (domain_enum kind, struct symtab *s, struct symbol *sym,
d3216 1
a3216 1
  if (kind != TYPES_DOMAIN && block == STATIC_BLOCK)
d3220 1
a3220 2
  if (kind == TYPES_DOMAIN
      && SYMBOL_DOMAIN (sym) != STRUCT_DOMAIN)
d3223 3
a3225 3
  else if (kind < TYPES_DOMAIN ||
	   (kind == TYPES_DOMAIN &&
	    SYMBOL_DOMAIN (sym) == STRUCT_DOMAIN))
d3246 1
a3246 2
				   & (CORE_ADDR) 0xffffffff,
				   "08l");
d3260 1
a3260 1
symtab_symbol_info (char *regexp, domain_enum kind, int from_tty)
d3262 1
a3262 3
  static char *classnames[]
  =
  {"variable", "function", "type", "method"};
d3276 1
a3276 1
		   classnames[(int) (kind - VARIABLES_DOMAIN)], regexp);
d3294 1
a3294 4
			     p->symtab,
			     p->symbol,
			     p->block,
			     last_filename);
d3305 1
a3305 1
  symtab_symbol_info (regexp, VARIABLES_DOMAIN, from_tty);
d3311 1
a3311 1
  symtab_symbol_info (regexp, FUNCTIONS_DOMAIN, from_tty);
d3318 1
a3318 1
  symtab_symbol_info (regexp, TYPES_DOMAIN, from_tty);
d3336 1
a3336 1
  search_symbols (regexp, FUNCTIONS_DOMAIN, 0, (char **) NULL, &ss);
d3351 1
a3351 1
	  print_symbol_info (FUNCTIONS_DOMAIN,
d3353 1
a3353 3
			     p->symbol,
			     p->block,
			     p->symtab->filename);
d3391 2
a3392 1
completion_list_add_name (const char *symname, char *sym_text, int sym_text_len,
a3439 106
/* ObjC: In case we are completing on a selector, look as the msymbol
   again and feed all the selectors into the mill.  */

static void
completion_list_objc_symbol (struct minimal_symbol *msymbol, char *sym_text,
			     int sym_text_len, char *text, char *word)
{
  static char *tmp = NULL;
  static unsigned int tmplen = 0;
    
  char *method, *category, *selector;
  char *tmp2 = NULL;
    
  method = SYMBOL_NATURAL_NAME (msymbol);

  /* Is it a method?  */
  if ((method[0] != '-') && (method[0] != '+'))
    return;

  if (sym_text[0] == '[')
    /* Complete on shortened method method.  */
    completion_list_add_name (method + 1, sym_text, sym_text_len, text, word);
    
  while ((strlen (method) + 1) >= tmplen)
    {
      if (tmplen == 0)
	tmplen = 1024;
      else
	tmplen *= 2;
      tmp = xrealloc (tmp, tmplen);
    }
  selector = strchr (method, ' ');
  if (selector != NULL)
    selector++;
    
  category = strchr (method, '(');
    
  if ((category != NULL) && (selector != NULL))
    {
      memcpy (tmp, method, (category - method));
      tmp[category - method] = ' ';
      memcpy (tmp + (category - method) + 1, selector, strlen (selector) + 1);
      completion_list_add_name (tmp, sym_text, sym_text_len, text, word);
      if (sym_text[0] == '[')
	completion_list_add_name (tmp + 1, sym_text, sym_text_len, text, word);
    }
    
  if (selector != NULL)
    {
      /* Complete on selector only.  */
      strcpy (tmp, selector);
      tmp2 = strchr (tmp, ']');
      if (tmp2 != NULL)
	*tmp2 = '\0';
	
      completion_list_add_name (tmp, sym_text, sym_text_len, text, word);
    }
}

/* Break the non-quoted text based on the characters which are in
   symbols. FIXME: This should probably be language-specific. */

static char *
language_search_unquoted_string (char *text, char *p)
{
  for (; p > text; --p)
    {
      if (isalnum (p[-1]) || p[-1] == '_' || p[-1] == '\0')
	continue;
      else
	{
	  if ((current_language->la_language == language_objc))
	    {
	      if (p[-1] == ':')     /* might be part of a method name */
		continue;
	      else if (p[-1] == '[' && (p[-2] == '-' || p[-2] == '+'))
		p -= 2;             /* beginning of a method name */
	      else if (p[-1] == ' ' || p[-1] == '(' || p[-1] == ')')
		{                   /* might be part of a method name */
		  char *t = p;

		  /* Seeing a ' ' or a '(' is not conclusive evidence
		     that we are in the middle of a method name.  However,
		     finding "-[" or "+[" should be pretty un-ambiguous.
		     Unfortunately we have to find it now to decide.  */

		  while (t > text)
		    if (isalnum (t[-1]) || t[-1] == '_' ||
			t[-1] == ' '    || t[-1] == ':' ||
			t[-1] == '('    || t[-1] == ')')
		      --t;
		    else
		      break;

		  if (t[-1] == '[' && (t[-2] == '-' || t[-2] == '+'))
		    p = t - 2;      /* method name detected */
		  /* else we leave with p unchanged */
		}
	    }
	  break;
	}
    }
  return p;
}


d3536 1
a3536 2
		 + ps->n_global_syms);
	 psym++)
d3540 2
a3541 1
	COMPLETION_LIST_ADD_SYMBOL (*psym, sym_text, sym_text_len, text, word);
d3546 1
a3546 2
		 + ps->n_static_syms);
	 psym++)
d3549 2
a3550 1
	COMPLETION_LIST_ADD_SYMBOL (*psym, sym_text, sym_text_len, text, word);
a3562 2
    
    completion_list_objc_symbol (msymbol, sym_text, sym_text_len, text, word);
d3572 1
a3572 1
	  surrounding_static_block = b;		/* For elmin of dups */
d3686 10
a3695 2
	/* Not a quoted string.  */
	sym_text = language_search_unquoted_string (text, p);
d3712 1
a3712 1
	 symbol tables record only its basename.  */
d3787 1
a3787 1
    "_globals_",	/* inserted by coff_symtab_read */
d3824 24
a3847 4
    {
      if (not_interesting_fname (s->filename))
	continue;
      if (!filename_seen (s->filename, 1, &first)
d3849 1
a3849 1
	  && strncasecmp (s->filename, text, text_len) == 0
d3851 1
a3851 1
	  && strncmp (s->filename, text, text_len) == 0
d3854 1
a3854 4
	{
	  /* This file matches for a completion; add it to the current
	     list of matches.  */
	  add_filename_to_list (s->filename, text, word,
d3856 10
a3865 10
	}
      else
	{
	  /* NOTE: We allow the user to type a base name when the
	     debug info records leading directories, but not the other
	     way around.  This is what subroutines of breakpoint
	     command do when they parse file names.  */
	  base_name = lbasename (s->filename);
	  if (base_name != s->filename
	      && !filename_seen (base_name, 1, &first)
d3867 1
a3867 1
	      && strncasecmp (base_name, text, text_len) == 0
d3869 1
a3869 1
	      && strncmp (base_name, text, text_len) == 0
d3871 5
a3875 2
	      )
	    add_filename_to_list (base_name, text, word,
a3876 2
	}
    }
d3878 6
a3883 7
  ALL_PSYMTABS (objfile, ps)
    {
      if (not_interesting_fname (ps->filename))
	continue;
      if (!ps->readin)
	{
	  if (!filename_seen (ps->filename, 1, &first)
d3885 1
a3885 1
	      && strncasecmp (ps->filename, text, text_len) == 0
d3887 1
a3887 1
	      && strncmp (ps->filename, text, text_len) == 0
d3890 1
a3890 4
	    {
	      /* This file matches for a completion; add it to the
		 current list of matches.  */
	      add_filename_to_list (ps->filename, text, word,
d3892 3
a3894 18

	    }
	  else
	    {
	      base_name = lbasename (ps->filename);
	      if (base_name != ps->filename
		  && !filename_seen (base_name, 1, &first)
#if HAVE_DOS_BASED_FILE_SYSTEM
		  && strncasecmp (base_name, text, text_len) == 0
#else
		  && strncmp (base_name, text, text_len) == 0
#endif
		  )
		add_filename_to_list (base_name, text, word,
				      &list, &list_used, &list_alloced);
	    }
	}
    }
d3916 3
a3918 3
       as its own "source line".  So the ending address of that "line"
       is the end of the prologue.  If available, this is the most
       reliable method.
d3920 1
a3920 1
       us the starting and ending addresses of a function.
d3922 2
a3923 2
       architecture-defined SKIP_PROLOGUE function to analyze the
       instruction stream and guess where the prologue ends.
d3925 3
a3927 3
       best guess as to the function's entry point.  At the time of
       this writing, handle_inferior_event doesn't get this right, so
       it should be our last resort.  */
d3931 1
a3931 1
  if (! find_pc_partial_function (pc, NULL, &func_addr, &func_end))
d3937 1
a3937 1
      if (! func_start)
d3957 1
a3957 3
  if (sal.line == 0
      || sal.end <= func_addr
      || func_end <= sal.end)
d3960 2
a3961 2
	 information, together with the architecture-specific prologue
	 scanning code.  */
d3995 1
a3995 1
	depth ++;
d3998 1
a3998 1
	  depth --;
d4008 1
a4008 1
    argp --;
d4061 2
a4062 1
      sym_return_val = (struct symbol **) xrealloc ((char *) sym_return_val, newsize);
d4111 1
d4118 1
a4118 1
  for (current = block_using (block);
d4120 1
a4120 1
       current = current->next)
d4238 1
a4238 1
    if ((lookup_partial_symbol (ps, func_name, NULL, 1, VAR_DOMAIN)
d4240 1
a4240 1
	|| (lookup_partial_symbol (ps, func_name, NULL, 0, VAR_DOMAIN)
d4253 1
a4253 1
  
d4256 1
a4256 1
    
d4258 1
a4258 1
     and get a default  or it will recursively call us! */  
d4260 1
a4260 1
  
d4262 1
a4262 2
			cursal.symtab, cursal.line,
			(char ***) NULL);
d4300 1
a4300 1
	 "All global and static variable names, or those matching REGEXP.");
d4303 1
a4303 1
	 "All global and static variable names, or those matching REGEXP.");
d4308 1
a4308 1
  
d4317 1
a4317 2
  add_info ("types", types_info,
	    "All type names, or those matching REGEXP.");
d4329 1
a4329 1
	 "All global and static variable names, or those matching REGEXP.");
@


1.70.2.39
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Makefile.in (cp-namespace.o): Depend on frame_h.
	* cp-support.h: Declare lookup_transparent_type_namespace,
	lookup_transparent_type_namespace_loop.
	* cp-namespace.c: Include frame.h.
	(lookup_transparent_type_namespace): New.
	(lookup_transparent_type_namespace_loop): New.
	* symtab.h: Declare lookup_transparent_type_aux.
	* symtab.c (lookup_transparent_type): Add FIXME, fork off code
	into lookup_transparent_type_aux, do backup strategy of trying to
	look in namespaces.
	(lookup_transparent_type_aux): New.
@
text
@a1606 7
/* FIXME: carlton/2003-05-23: No, sometimes, unfortunately, the name
   is wrong.  This function gets called when the the type in question
   is a declaration; in that situation, our type name deduction
   machinery doesn't work, so if the type is declared in a namespace
   and GCC isn't giving us namespace debug info, we're screwed.  Sigh.
   There's nothing we can do to fix this in general, I think.  */

a1609 13
  struct type *retval = lookup_transparent_type_aux (name);

  if (retval != NULL)
    return retval;
  else
    /* See above FIXME comment: with proper debug info, this should
       never be necessary (or even desirable).  */
    return lookup_transparent_type_namespace (name);
}

struct type *
lookup_transparent_type_aux (const char *name)
{
d1652 3
a1654 1
	      error ("Internal: global symbol `%s' found in %s psymtab but not in symtab.\n%s may be an inlined function, or may be a template function\n(if a template, try specifying an instantiation: %s<type>).",
d1699 3
a1701 1
	      error ("Internal: static symbol `%s' found in %s psymtab but not in symtab.\n%s may be an inlined function, or may be a template function\n(if a template, try specifying an instantiation: %s<type>).",
d1710 1
@


1.70.2.40
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@a49 1
#include "dictionary.h"
d82 5
d141 11
d1229 1
a1229 1
	      /* This call used to pass `SYMBOL_LINKAGE_NAME (msymbol)' as the
d1497 1
a1497 1
struct partial_symbol *
d1773 1
a1773 2
	   sym != NULL;
	   sym = dict_iter_name_next (name, &iter))
d1776 1
a1776 1
	      && (linkage_name != NULL
d1785 4
a1788 4
	 list; this loop makes sure to take anything else other than
	 parameter symbols first; it only uses parameter symbols as a
	 last resort.  Note that this only takes up extra computation
	 time on a match.  */
d1793 1
a1793 2
	   sym != NULL;
	   sym = dict_iter_name_next (name, &iter))
d1796 1
a1796 1
	      && (linkage_name != NULL
d1798 1
d1944 6
a1949 6
	      {
		fixup_symbol_section (sym, objfile);
		if (section == SYMBOL_BFD_SECTION (sym))
		  break;
	      }
	    if (sym == NULL)
d2100 1
a2100 2
	mfunsym = lookup_minimal_symbol_text (SYMBOL_LINKAGE_NAME (msymbol),
					      NULL, NULL);
d2111 1
a2111 1
	  /* warning ("In stub for %s; unable to find real function/line info", SYMBOL_LINKAGE_NAME (msymbol)) */ ;
d2116 1
a2116 1
	  /* warning ("In stub for %s; unable to find real function/line info", SYMBOL_LINKAGE_NAME (msymbol)) */ ;
d3313 3
a3315 3
	  char *string = alloca (strlen (p->symtab->filename)
				 + strlen (SYMBOL_LINKAGE_NAME (p->symbol))
				 + 4);
d3318 1
a3318 1
	  strcat (string, SYMBOL_LINKAGE_NAME (p->symbol));
d3329 1
a3329 1
	  break_command (SYMBOL_LINKAGE_NAME (p->msymbol), from_tty);
d3346 5
d3352 5
a3356 1
	(SYMBOL_NATURAL_NAME (symbol), (sym_text), (len), (text), (word))
d3527 6
a3532 6
  struct symbol *sym;
  struct symtab *s;
  struct partial_symtab *ps;
  struct minimal_symbol *msymbol;
  struct objfile *objfile;
  struct block *b, *surrounding_static_block = 0;
d3534 1
a3534 1
  int j;
d3658 6
a3663 7
	{
	  QUIT;
	  COMPLETION_LIST_ADD_SYMBOL (sym, sym_text, sym_text_len, text, word);
	  if (SYMBOL_CLASS (sym) == LOC_TYPEDEF)
	    {
	      struct type *t = SYMBOL_TYPE (sym);
	      enum type_code c = TYPE_CODE (t);
d3689 3
a3691 3
      {
	COMPLETION_LIST_ADD_SYMBOL (sym, sym_text, sym_text_len, text, word);
      }
d3702 3
a3704 3
      {
	COMPLETION_LIST_ADD_SYMBOL (sym, sym_text, sym_text_len, text, word);
      }
d3799 3
a3801 3
    {
      COMPLETION_LIST_ADD_SYMBOL (sym, sym_text, sym_text_len, text, word);
    }
d3805 3
a3807 3
    {
      COMPLETION_LIST_ADD_SYMBOL (sym, sym_text, sym_text_len, text, word);
    }
d4045 274
@


1.70.2.41
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d157 3
a159 3
  struct symtab *s;
  struct partial_symtab *ps;
  struct objfile *objfile;
d250 2
a251 2
  struct partial_symtab *pst;
  struct objfile *objfile;
d685 2
a686 2
  struct partial_symtab *pst;
  struct objfile *objfile;
a931 8
  /* Make sure we do something sensible with is_a_field_of_this, since
     the callers that set this parameter to some non-null value will
     certainly use it later and expect it to be either 0 or 1.
     If we don't set it, the contents of is_a_field_of_this are
     undefined.  */
  if (is_a_field_of_this != NULL)
    *is_a_field_of_this = 0;

d948 1
d1615 3
a1617 3
  struct symbol *sym;
  struct symtab *s = NULL;
  struct partial_symtab *ps;
d1619 2
a1620 2
  struct objfile *objfile;
  struct block *block;
d1719 2
a1720 2
  struct partial_symtab *pst;
  struct objfile *objfile;
d1748 1
a1748 1
lookup_block_symbol (const struct block *block, const char *name,
d1864 1
a1864 1
  struct block *b;
d1866 4
a1869 4
  struct symtab *s = NULL;
  struct symtab *best_s = NULL;
  struct partial_symtab *ps;
  struct objfile *objfile;
d1993 4
a1996 4
  struct linetable *l;
  int len;
  int i;
  struct linetable_entry *item;
d2406 1
a2406 1
find_line_common (struct linetable *l, int lineno,
d2409 2
a2410 2
  int i;
  int len;
d2427 1
a2427 1
      struct linetable_entry *item = &(l->item[i]);
d2535 1
a2535 1
      char *q = p + 1;
d2725 3
a2727 3
  struct symtab *s;
  struct partial_symtab *ps;
  struct objfile *objfile;
d2871 3
a2873 3
  struct symtab *s;
  struct partial_symtab *ps;
  struct blockvector *bv;
d2875 2
a2876 2
  struct block *b;
  int i = 0;
d2878 1
a2878 1
  struct symbol *sym;
d3695 3
a3697 3
  struct symbol *sym;
  struct symtab *s;
  struct block *b;
d3858 3
a3860 3
  struct symtab *s;
  struct partial_symtab *ps;
  struct objfile *objfile;
@


1.70.2.42
log
@2003-09-30  David Carlton  <carlton@@kealia.com>

	* Makefile.in (c-exp.tab.o): Depend on cp_support_h.
	* c-exp.y: Include c-exp.y.  Update comments, replace
	lookup_nested_type by cp_lookup_nested_type.
	(yylex): Update comments, remove #if 0 block.
	* cp-namespace.c (cp_lookup_nested_type): Move here from symtab.c;
	rename from lookup_nested_type.
	* cp-support.h: Add cp_lookup_nested_type declaration.
	* dwarf2read.c (read_die_and_children): Update comment.
	(read_die_and_siblings): Update comment, move declaration of
	'die'.
	(read_full_die): Update comment, tweak formatting.
	* symtab.c (lookup_nested_type): Move to cp-namespace.c, rename to
	cp_lookup_nested_type.
	* symtab.h: Delete declaration of lookup_nested_type.
@
text
@d1350 47
@


1.70.2.43
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d120 2
d351 1
a351 1
    is_full_physname_constructor || (newname && strcmp (field_name, newname) == 0);
d1746 23
d1786 32
d1950 1
a1950 1
find_pc_sect_line (CORE_ADDR pc, struct bfd_section *section, int notcurrent)
d2047 1
a2047 1
					      NULL);
d2260 1
a2260 1
	if (strcmp (symtab->filename, s->filename) != 0)
@


1.70.2.44
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d2392 4
d2408 1
@


1.70.2.45
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d4 1
a4 1
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d44 1
d1530 26
a1555 2
   must not be opaque -- i.e., must have at least one field
   defined.  */
d1560 8
a1567 1
  return current_language->la_lookup_transparent_type (name);
a1569 6
/* The standard implementation of lookup_transparent_type.  This code
   was modeled on lookup_symbol -- the parts not relevant to looking
   up types were just left out.  In particular it's assumed here that
   types are available in struct_domain and only at file-static or
   global blocks.  */

d1571 1
a1571 1
basic_lookup_transparent_type (const char *name)
d1615 1
a1615 3
	      error ("Internal: global symbol `%s' found in %s psymtab but not in symtab.\n\
%s may be an inlined function, or may be a template function\n\
(if a template, try specifying an instantiation: %s<type>).",
d1660 1
a1660 3
	      error ("Internal: static symbol `%s' found in %s psymtab but not in symtab.\n\
%s may be an inlined function, or may be a template function\n\
(if a template, try specifying an instantiation: %s<type>).",
a1669 1

d3938 1
a3938 1
			(char ***) NULL, NULL);
@


1.69
log
@* symtab.c (lookup_symbol_aux): In the cases where we find a
minimal symbol of an appropriate name and use its address to
select a symtab to read and search, use `name' (as passed to us)
as the demangled name when searching the symtab's global and
static blocks, not the minsym's name.
@
text
@d41 1
d3971 2
d3975 5
d3981 1
a3981 1
			current_source_symtab, current_source_line,
d3983 1
@


1.68
log
@2002-08-01  Andrew Cagney  <cagney@@redhat.com>

* NEWS: Menion that CHILL has been made obsolete.

* gdbtypes.c (chill_varying_type): Make chill references obsolete.
* gdbserver/Makefile.in: Ditto.
* stabsread.c (read_range_type): Ditto.
* gdbtypes.h: Ditto.
* language.c (binop_type_check): Ditto.
(binop_result_type): Ditto.
(integral_type): Ditto.
(character_type): Ditto.
(string_type): Ditto.
(boolean_type): Ditto.
(structured_type): Ditto.
(lang_bool_type): Ditto.
(binop_type_check): Ditto.
* language.h (_LANG_chill): Ditto.
* dwarfread.c (set_cu_language): Ditto.
* dwarfread.c (CHILL_PRODUCER): Ditto.
* dwarfread.c (handle_producer): Ditto.
* expression.h (enum exp_opcode): Ditto.
* eval.c: Ditto for comments.
* typeprint.c (typedef_print) [_LANG_chill]: Ditto.
* expprint.c (print_subexp): Ditto.
(print_subexp): Ditto.
* valops.c (value_cast): Ditto.
(search_struct_field): Ditto.
* value.h (COERCE_VARYING_ARRAY): Ditto.
* symfile.c (init_filename_language_table): Ditto.
(add_psymbol_with_dem_name_to_list): Ditto.
* valarith.c (value_binop): Ditto.
(value_neg): Ditto.
* valops.c (value_slice): Ditto.
* symtab.h (union language_specific): Ditto.
(SYMBOL_INIT_LANGUAGE_SPECIFIC): Ditto.
(SYMBOL_DEMANGLED_NAME): Ditto.
(SYMBOL_CHILL_DEMANGLED_NAME): Ditto.
* defs.h (enum language): Ditto.
* symtab.c (got_symtab): Ditto.
* utils.c (fprintf_symbol_filtered): Ditto.

* ch-typeprint.c: Make file obsolete.
* ch-valprint.c: Make file obsolete.
* ch-lang.h: Make file obsolete.
* ch-exp.c: Make file obsolete.
* ch-lang.c: Make file obsolete.

* Makefile.in (FLAGS_TO_PASS): Do not pass CHILL or CHILLFLAGS or
CHILL_LIB.
(TARGET_FLAGS_TO_PASS): Ditto.
(CHILLFLAGS): Obsolete.
(CHILL): Obsolete.
(CHILL_FOR_TARGET): Obsolete.
(CHILL_LIB): Obsolete.
(SFILES): Remove ch-exp.c, ch-lang.c, ch-typeprint.c and
ch-valprint.c.
(HFILES_NO_SRCDIR): Remove ch-lang.h.
(COMMON_OBS): Remove ch-valprint.o, ch-typeprint.o, ch-exp.o and
ch-lang.o.
(ch-exp.o, ch-lang.o, ch-typeprint.o, ch-valprint.o): Delete
targets.

2002-08-01  Andrew Cagney  <cagney@@redhat.com>

* stabs.texinfo, gdb.texinfo, gdbint.texinfo: Obsolete references
to CHILL.

2002-08-01  Andrew Cagney  <cagney@@redhat.com>

* Makefile.in (TARGET_FLAGS_TO_PASS): Remove CHILLFLAGS, CHILL,
CHILL_FOR_TARGET and CHILL_LIB.
* configure.in (configdirs): Remove gdb.chill.
* configure: Regenerate.
* lib/gdb.exp: Obsolete references to chill.
* gdb.fortran/types.exp: Ditto.
* gdb.fortran/exprs.exp: Ditto.
@
text
@d863 7
a869 2
	      sym = lookup_block_symbol (block, SYMBOL_NAME (msymbol),
					 mangled_name, namespace);
d875 2
a876 2
		  sym = lookup_block_symbol (block, SYMBOL_NAME (msymbol),
					     mangled_name, namespace);
d1035 6
a1040 2
	      sym = lookup_block_symbol (block, SYMBOL_NAME (msymbol),
					 mangled_name, namespace);
d1046 2
a1047 2
		  sym = lookup_block_symbol (block, SYMBOL_NAME (msymbol),
					     mangled_name, namespace);
@


1.67
log
@	* symtab.c (lookup_symbol): Demangle before lowercasing.
@
text
@d441 20
a460 18
  if (demangled == NULL
      && (gsymbol->language == language_chill
          || gsymbol->language == language_auto))
    {
      demangled =
        chill_demangle (gsymbol->name);
      if (demangled != NULL)
        {
          gsymbol->language = language_chill;
          gsymbol->language_specific.chill_specific.demangled_name =
            obsavestring (demangled, strlen (demangled), obstack);
          xfree (demangled);
        }
      else
        {
          gsymbol->language_specific.chill_specific.demangled_name = NULL;
        }
    }
@


1.66
log
@2002-07-29  Andrew Cagney  <ac131313@@redhat.com>

* gdb_obstack.h: New file.
* symtab.h: Include "gdb_obstack.h" instead of "obstack.h".
(obstack_chunk_alloc, obstack_chunk_free): Delete macros.
* objfiles.h: Include "gdb_obstack.h".
* Makefile.in (gdb_obstack_h): Define.
(symtab_h): Add $(gdb_obstack_h).
(objfiles_h): Add $(gdb_obstack_h).

* objfiles.c: Include "gdb_obstack.h" instead of "obstack.h".
* macrotab.c, cp-valprint.c, dbxread.c: Ditto.
* ch-typeprint.c, ch-valprint.c, dstread.c: Ditto.
* macroexp.c, p-typeprint.c, stabsread.c: Ditto.
* symtab.c, f-typeprint.c, mdebugread.c: Ditto.
* p-valprint.c, symmisc.c, typeprint.c: Ditto.
* symfile.c, coffread.c, c-typeprint.c: Ditto.
* buildsym.c, bcache.c, ada-typeprint.c: Ditto.

* Makefile.in (bcache.o): Update dependencies.
(buildsym.o, c-typeprint.o, ch-typeprint.o): Ditto.
(ch-valprint.o, coffread.o, cp-valprint.o): Ditto.
(dbxread.o, dstread.o, f-typeprint.o): Ditto.
(objfiles.o, p-typeprint.o, p-valprint.o): Ditto.
(stabsread.o, symfile.o, symmisc.o): Ditto.
(symtab.o, typeprint.o, macroexp.o): Ditto.
(macrotab.o, mdebugread.o): Ditto.
(f_lang_h, coff_sym_h, coff_symconst_h): Define.
(coff_ecoff_h, aout_aout64_h): Define.
(aout_stabs_gnu_h, libaout_h): Define.
@
text
@d682 2
a683 2
  char *modified_name = NULL;
  char *modified_name2 = NULL;
d688 15
a714 15
  else 
      modified_name = (char *) name;

  /* If we are using C++ language, demangle the name before doing a lookup, so
     we can always binary search. */
  if (current_language->la_language == language_cplus)
    {
      modified_name2 = cplus_demangle (modified_name, DMGL_ANSI | DMGL_PARAMS);
      if (modified_name2)
	{
	  mangled_name = name;
	  modified_name = modified_name2;
	  needtofreename = 1;
	}
    }
d719 1
a719 1
    xfree (modified_name2);
@


1.65
log
@2002-07-11  Daniel Jacobowitz  <drow@@mvista.com>

	Based on patch from Daniel Berlin <dberlin@@dberlin.org>.
	* buildsym.c: Include "demangle.h" for SYMBOL_INIT_DEMANGLED_NAME.
	(finish_block) For non-function blocks, hash the symbol table.  For
	function blocks, mark the symbol table as unhashed.
	* minsyms.c (msymbol_hash): Return hash value without taking modulus.
	(msymbol_hash_iw): Likewise.
	(add_minsym_to_hash_table): Take modulus of msymbol_hash's return
	value.
	(add_minsym_to_demangled_hash_table): Likewise for msymbol_hash_iw.
	(lookup_minimal_symbol): Likewise for both.
	* symtab.h (struct block): Add `hashtable' flag.  Comment the
	hashtable.
	(BLOCK_HASHTABLE, BLOCK_BUCKETS, BLOCK_BUCKET): New macro.
	(ALL_BLOCK_SYMBOLS): Update.
	(BLOCK_SHOULD_SORT): Do not sort hashed blocks.
	(struct symbol): Add `hash_next' pointer.
	* symtab.c (lookup_block_symbol): Search using the hash table when
	possible.
	(find_pc_sect_symtab): Use ALL_BLOCK_SYMBOLS.
	(search_symbols, find_addr_symbol): Likewise.

	* dstread.c (process_dst_block): Clear hashtable bit for new block.
	(read_dst_symtab): Likewise.
	* jv-lang.c (get_java_class_symtab): Likewise.
	* mdebugread.c: Include "gdb_assert.h".
	(shrink_block): Assert that the block being modified is not hashed.
	* coffread.c (patch_opaque_types): Use ALL_BLOCK_SYMBOLS.
	* symmisc.c (free_symtab_block): Walk the hash table when freeing
	symbols.
	(dump_symtab): Recognize hashed blocks.
	* printcmd.c (print_frame_args):  Assert that function blocks do not
	have hashed symbol tables.
	* ada-lang.c (symtab_for_sym): Use ALL_BLOCK_SYMBOLS.
	(fill_in_ada_prototype, debug_print_block): Likewise.
	(ada_add_block_symbols): Use ALL_BLOCK_SYMBOLS.  Handle hash tables.
@
text
@d43 1
a43 1
#include "obstack.h"
@


1.64
log
@2002-07-04  Daniel Jacobowitz  <drow@@mvista.com>

        * symtab.c (remove_params): New function.
        (make_symbol_overload_list): Use it instead of cplus_demangle.
        (overload_list_add_symbol): Likewise.  Reorder.  Fix memory leak.
@
text
@d1331 16
d1601 1
d1603 1
a1603 1
	    for (i = 0; i < b->nsyms; i++)
d1605 2
a1606 2
		fixup_symbol_section (b->sym[i], objfile);
		if (section == SYMBOL_BFD_SECTION (b->sym[i]))
d1609 1
a1609 1
	    if (i >= b->nsyms)
d1681 1
a1681 2
	top = BLOCK_NSYMS (block);
	for (bot = 0; bot < top; bot++)
a1682 1
	    sym = BLOCK_SYM (block, bot);
d2813 1
a2813 1
	  for (j = 0; j < BLOCK_NSYMS (b); j++)
a2815 1
	      sym = BLOCK_SYM (b, j);
@


1.63
log
@* language.c (local_hex_string_custom): Simplify.  Do not depend
on PRINTF_HAS_LONG_LONG or CC_HAS_LONG_LONG.

* memattr.c (mem_info_command): Replace calls to
longest_local_hex_string and longest_local_hex_string_custom.
* buildsym.c (make_blockvector): Ditto.
* solib.c (info_sharedlibrary_command): Ditto.
* tracepoint.c (tracepoints_info): Ditto.
* symtab.c (print_msymbol_info): Ditto.

* language.c (local_hex_string): Delete.
(local_hex_string_custom): Delete.
(longest_local_hex_string): Rename to local_hex_string.
(longest_local_hex_string_custom): Rename to
local_hex_string_custom.
* language.h (local_hex_string): Change parameter type to LONGEST.
(local_hex_string_custom): Ditto.
(longest_local_hex_string): Delete declaration.
(longest_local_hex_string_custom): Ditto.

* solib.c: Update copyright.
* memattr.c: Update copyright.
@
text
@d3722 43
d3780 10
d3792 1
a3792 1
  char *sym_name = cplus_demangle (SYMBOL_NAME (sym), DMGL_ARM | DMGL_ANSI);
d3794 1
a3794 4
    {
      sym_name = (char *) xmalloc (strlen (SYMBOL_NAME (sym)) + 1);
      strcpy (sym_name, SYMBOL_NAME (sym));
    }
d3803 1
a3803 8
  /* If there is no type information, we can't do anything, so skip */
  if (SYMBOL_TYPE (sym) == NULL)
    return;

  /* skip any symbols that we've already considered. */
  for (i = 0; i < sym_return_val_index; ++i)
    if (!strcmp (SYMBOL_NAME (sym), SYMBOL_NAME (sym_return_val[i])))
      return;
a3813 2

  xfree (sym_name);
d3836 1
a3836 2
  /* Look for the symbol we are supposed to complete on.
   * FIXME: This should be language-specific.  */
d3838 1
a3838 1
  oload_name = cplus_demangle (SYMBOL_NAME (fsym), DMGL_ARM | DMGL_ANSI);
d3841 6
a3846 2
      oload_name = (char *) xmalloc (strlen (SYMBOL_NAME (fsym)) + 1);
      strcpy (oload_name, SYMBOL_NAME (fsym));
@


1.63.4.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@a1330 16
  if (BLOCK_HASHTABLE (block))
    {
      unsigned int hash_index;
      hash_index = msymbol_hash_iw (name);
      hash_index = hash_index % BLOCK_BUCKETS (block);
      for (sym = BLOCK_BUCKET (block, hash_index); sym; sym = sym->hash_next)
	{
	  if (SYMBOL_NAMESPACE (sym) == namespace 
	      && (mangled_name
		  ? strcmp (SYMBOL_NAME (sym), mangled_name) == 0
		  : SYMBOL_MATCHES_NAME (sym, name)))
	    return sym;
	}
      return NULL;
    }

a1584 1
	    struct symbol *sym = NULL;
d1586 1
a1586 1
	    ALL_BLOCK_SYMBOLS (b, i, sym)
d1588 2
a1589 2
		fixup_symbol_section (sym, objfile);
		if (section == SYMBOL_BFD_SECTION (sym))
d1592 1
a1592 1
	    if ((i >= BLOCK_BUCKETS (b)) && (sym == NULL))
d1664 2
a1665 1
	ALL_BLOCK_SYMBOLS (block, bot, sym)
d1667 1
d2798 1
a2798 1
	  ALL_BLOCK_SYMBOLS (b, j, sym)
d2801 1
a3721 43

static char *
remove_params (const char *demangled_name)
{
  const char *argp;
  char *new_name;
  int depth;

  if (demangled_name == NULL)
    return NULL;

  /* First find the end of the arg list.  */
  argp = strrchr (demangled_name, ')');
  if (argp == NULL)
    return NULL;

  /* Back up to the beginning.  */
  depth = 1;

  while (argp-- > demangled_name)
    {
      if (*argp == ')')
	depth ++;
      else if (*argp == '(')
	{
	  depth --;

	  if (depth == 0)
	    break;
	}
    }
  if (depth != 0)
    internal_error (__FILE__, __LINE__,
		    "bad demangled name %s\n", demangled_name);
  while (argp[-1] == ' ' && argp > demangled_name)
    argp --;

  new_name = xmalloc (argp - demangled_name + 1);
  memcpy (new_name, demangled_name, argp - demangled_name);
  new_name[argp - demangled_name] = '\0';
  return new_name;
}

a3736 10
  char *sym_name;

  /* If there is no type information, we can't do anything, so skip */
  if (SYMBOL_TYPE (sym) == NULL)
    return;

  /* skip any symbols that we've already considered. */
  for (i = 0; i < sym_return_val_index; ++i)
    if (!strcmp (SYMBOL_NAME (sym), SYMBOL_NAME (sym_return_val[i])))
      return;
d3739 1
a3739 1
  sym_name = remove_params (SYMBOL_DEMANGLED_NAME (sym));
d3741 4
a3744 1
    return;
d3753 8
a3760 1
  xfree (sym_name);
d3771 2
d3795 2
a3796 1
  /* Look for the symbol we are supposed to complete on.  */
d3798 1
a3798 1
  oload_name = remove_params (SYMBOL_DEMANGLED_NAME (fsym));
d3801 2
a3802 6
      sym_return_val_size = 1;
      sym_return_val = (struct symbol **) xmalloc (2 * sizeof (struct symbol *));
      sym_return_val[0] = fsym;
      sym_return_val[1] = NULL;

      return sym_return_val;
@


1.63.4.2
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d43 1
a43 1
#include "gdb_obstack.h"
d441 18
a458 20
#if 0
  /* OBSOLETE if (demangled == NULL */
  /* OBSOLETE     && (gsymbol->language == language_chill */
  /* OBSOLETE         || gsymbol->language == language_auto)) */
  /* OBSOLETE   { */
  /* OBSOLETE     demangled = */
  /* OBSOLETE       chill_demangle (gsymbol->name); */
  /* OBSOLETE     if (demangled != NULL) */
  /* OBSOLETE       { */
  /* OBSOLETE         gsymbol->language = language_chill; */
  /* OBSOLETE         gsymbol->language_specific.chill_specific.demangled_name = */
  /* OBSOLETE           obsavestring (demangled, strlen (demangled), obstack); */
  /* OBSOLETE         xfree (demangled); */
  /* OBSOLETE       } */
  /* OBSOLETE     else */
  /* OBSOLETE       { */
  /* OBSOLETE         gsymbol->language_specific.chill_specific.demangled_name = NULL; */
  /* OBSOLETE       } */
  /* OBSOLETE   } */
#endif
d682 2
a683 2
  char *demangled_name = NULL;
  const char *modified_name = NULL;
a687 15
  modified_name = name;

  /* If we are using C++ language, demangle the name before doing a lookup, so
     we can always binary search. */
  if (current_language->la_language == language_cplus)
    {
      demangled_name = cplus_demangle (name, DMGL_ANSI | DMGL_PARAMS);
      if (demangled_name)
	{
	  mangled_name = name;
	  modified_name = demangled_name;
	  needtofreename = 1;
	}
    }

d700 15
d719 1
a719 1
    xfree (demangled_name);
@


1.63.4.3
log
@Merge with kseitz_interps-20020930-merge.
@
text
@a40 1
#include "source.h"
d863 2
a864 7

              /* This call used to pass `SYMBOL_NAME (msymbol)' as the
                 `name' argument to lookup_block_symbol.  But the name
                 of a minimal symbol is always mangled, so that seems
                 to be clearly the wrong thing to pass as the
                 unmangled name.  */
	      sym = lookup_block_symbol (block, name, mangled_name, namespace);
d870 2
a871 2
		  sym = lookup_block_symbol (block, name,
                                             mangled_name, namespace);
d1030 2
a1031 6
              /* This call used to pass `SYMBOL_NAME (msymbol)' as the
                 `name' argument to lookup_block_symbol.  But the name
                 of a minimal symbol is always mangled, so that seems
                 to be clearly the wrong thing to pass as the
                 unmangled name.  */
	      sym = lookup_block_symbol (block, name, mangled_name, namespace);
d1037 2
a1038 2
		  sym = lookup_block_symbol (block, name,
                                             mangled_name, namespace);
a3960 2
  struct symtab_and_line cursal;
  
a3962 5
    
  /* We use whatever is set as the current source line. We do not try
     and get a default  or it will recursively call us! */  
  cursal = get_current_source_symtab_and_line ();
  
d3964 1
a3964 1
			cursal.symtab, cursal.line,
a3965 1

@


1.63.4.4
log
@merge from mainline
@
text
@d53 5
d124 13
a387 27
/* Initialize the language dependent portion of a symbol
   depending upon the language for the symbol. */
void
symbol_init_language_specific (struct general_symbol_info *gsymbol,
			       enum language language)
{
  gsymbol->language = language;
  if (gsymbol->language == language_cplus
      || gsymbol->language == language_java)
    {
      gsymbol->language_specific.cplus_specific.demangled_name = NULL;
    }
  else if (gsymbol->language == language_objc)
    {
      gsymbol->language_specific.objc_specific.demangled_name = NULL;
    }
  /* OBSOLETE else if (SYMBOL_LANGUAGE (symbol) == language_chill) */
  /* OBSOLETE   { */
  /* OBSOLETE     SYMBOL_CHILL_DEMANGLED_NAME (symbol) = NULL; */
  /* OBSOLETE   } */
  else
    {
      memset (&gsymbol->language_specific, 0,
	      sizeof (gsymbol->language_specific));
    }
}

a463 18
/* Return the demangled name for a symbol based on the language for
   that symbol.  If no demangled name exists, return NULL. */
char *
symbol_demangled_name (struct general_symbol_info *gsymbol)
{
  if (gsymbol->language == language_cplus
      || gsymbol->language == language_java)
    return gsymbol->language_specific.cplus_specific.demangled_name;

  else if (gsymbol->language == language_objc)
    return gsymbol->language_specific.objc_specific.demangled_name;

  else 
    return NULL;

  /* OBSOLETE (SYMBOL_LANGUAGE (symbol) == language_chill */
  /* OBSOLETE ? SYMBOL_CHILL_DEMANGLED_NAME (symbol) */
}
a464 10
/* Initialize the structure fields to zero values.  */
void
init_sal (struct symtab_and_line *sal)
{
  sal->symtab = 0;
  sal->section = 0;
  sal->line = 0;
  sal->pc = 0;
  sal->end = 0;
}
d1658 88
d1800 1
a1800 1
  init_sal (&val);		/* initialize to zeroes */
@


1.63.4.5
log
@merge from mainline
@
text
@d932 1
a932 1
	      return fixup_symbol_section (sym, s->objfile);
d940 1
a940 1
	      return lookup_symbol_aux (SYMBOL_NAME (msymbol), mangled_name, NULL,
d1123 1
a1123 1
					NULL, namespace, is_a_field_of_this,
@


1.62
log
@* symtab.c (lookup_symtab): Remove ``const'' from ``rp''
declaration.  Fix -Werror.
@
text
@d2964 3
a2966 3
    tmp = longest_local_hex_string_custom (SYMBOL_VALUE_ADDRESS (msymbol)
					   & (CORE_ADDR) 0xffffffff,
					   "08l");
d2968 2
a2969 2
    tmp = longest_local_hex_string_custom (SYMBOL_VALUE_ADDRESS (msymbol),
					   "016l");
@


1.61
log
@gdb/ChangeLog:
* stack.c (get_selected_block): Add new argument `addr_in_block',
used to return the exact code address we used to select the block,
not just the block.
* blockframe.c (get_frame_block, get_current_block): Same.
* frame.h (get_frame_block, get_current_block,
get_selected_block): Update declarations.
* linespec.c, stack.c, blockframe.c, breakpoint.c, findvar.c,
linespec.c, varobj.c, printcmd.c, symtab.c: Callers changed.

gdb/mi/ChangeLog:
* mi-cmd-stack.c (list_args_or_locals): Pass new arg to
get_frame_block.  (See entry in gdb/ChangeLog.)
@
text
@d184 1
a184 1
        const char *rp = gdb_realpath (symtab_to_filename (s));
@


1.60
log
@(lookup_symtab): Use the new xfullpath function, in order to be able to
match a filename with either the real filename, or the name of any
symbolic link to this file.
(lookup_partial_symtab): Ditto.
@
text
@d3315 1
a3315 1
  for (b = get_selected_block (); b != NULL; b = BLOCK_SUPERBLOCK (b))
d3848 1
a3848 1
  for (b = get_selected_block (); b != NULL; b = BLOCK_SUPERBLOCK (b))
@


1.59
log
@* symtab.h (SYMBOL_INIT_MANGLED_NAME): Turn this macro's body into
a function; leave this macro here to invoke that function.
(symbol_init_mangled_name): Declaration for that function.
* symtab.c (symbol_init_mangled_name): New function.
@
text
@d147 1
d152 6
a157 1
    real_path = gdb_realpath (name);
a166 1
	xfree (real_path);
d169 1
d172 10
d184 2
a185 1
	char *rp = symtab_to_filename (s);
a187 1
	    xfree (real_path);
a192 2
  xfree (real_path);

d238 1
d244 6
a249 1
    real_path = gdb_realpath (name);
a254 1
	xfree (real_path);
d257 1
d260 11
d273 1
d276 6
a281 2
	if (pst->fullname != NULL
	    && FILENAME_CMP (real_path, pst->fullname) == 0)
a282 1
	    xfree (real_path);
a286 2

  xfree (real_path);
@


1.58
log
@2002-03-22  Daniel Jacobowitz  <drow@@mvista.com>

        * symtab.h (lookup_block_symbol): Add mangled_name argument
        to prototype.

        * symmisc.c (maintenance_check_symtabs): Call lookup_block_symbol
        with new mangled_name argument.
        * linespec.c (decode_line_1): Likewise.
        * valops (value_of_this): Likewise.
        * symtab.c (lookup_transparent_type): Likewise.
        (lookup_symbol_aux): Likewise.  Accept new mangled_name argument.
        (lookup_symbol): If we are given a mangled name, pass it down
        to lookup_symbol_aux.
        (lookup_block_symbol): If we are given a mangled name to check
        against, only return symbols which match it.
@
text
@d352 77
@


1.57
log
@	* symtab.c (gdb_mangle_name): Handle fully mangled v3 abi physnames.
@
text
@d83 6
a88 5
static struct symbol *lookup_symbol_aux (const char *name, const
					 struct block *block, const
					 namespace_enum namespace, int
					 *is_a_field_of_this, struct
					 symtab **symtab);
d574 1
d600 1
d606 2
a607 2
  returnval = lookup_symbol_aux (modified_name, block, namespace,
				 is_a_field_of_this, symtab);
d615 3
a617 3
lookup_symbol_aux (const char *name, const struct block *block,
	       const namespace_enum namespace, int *is_a_field_of_this,
	       struct symtab **symtab)
d632 1
a632 1
      sym = lookup_block_symbol (block, name, namespace);
d685 1
a685 1
	    sym = lookup_block_symbol (b, name, VAR_NAMESPACE);
d723 1
a723 1
    sym = lookup_block_symbol (block, name, namespace);
d752 1
a752 1
					 namespace);
d759 1
a759 1
					     namespace);
d785 1
a785 1
	      return lookup_symbol_aux (SYMBOL_NAME (msymbol), block,
d803 1
a803 1
	sym = lookup_block_symbol (block, name, namespace);
d812 1
a812 1
	    sym = lookup_block_symbol (block, name, namespace);
d836 1
a836 1
    sym = lookup_block_symbol (block, name, namespace);
d853 1
a853 1
	sym = lookup_block_symbol (block, name, namespace);
d862 1
a862 1
	    sym = lookup_block_symbol (block, name, namespace);
d919 1
a919 1
					 namespace);
d926 1
a926 1
					     namespace);
d963 3
a965 2
	      return lookup_symbol_aux (SYMBOL_NAME (msymbol), block,
					namespace, is_a_field_of_this, symtab);
d1091 1
a1091 1
    sym = lookup_block_symbol (block, name, STRUCT_NAMESPACE);
d1105 1
a1105 1
	sym = lookup_block_symbol (block, name, STRUCT_NAMESPACE);
d1114 1
a1114 1
	    sym = lookup_block_symbol (block, name, STRUCT_NAMESPACE);
d1138 1
a1138 1
    sym = lookup_block_symbol (block, name, STRUCT_NAMESPACE);
d1152 1
a1152 1
	sym = lookup_block_symbol (block, name, STRUCT_NAMESPACE);
d1161 1
a1161 1
	    sym = lookup_block_symbol (block, name, STRUCT_NAMESPACE);
d1205 5
a1209 1
   tested for a match. */
d1213 1
d1273 4
a1276 1
         longer sorted.  */
d1282 4
a1285 2
	  if (SYMBOL_NAMESPACE (sym) == namespace &&
	      SYMBOL_MATCHES_NAME (sym, name))
d1317 4
a1320 2
	  if (SYMBOL_NAMESPACE (sym) == namespace &&
	      SYMBOL_MATCHES_NAME (sym, name))
@


1.56
log
@s/free/xfree/
@
text
@d294 4
a297 1
  if (is_operator_name (field_name))
@


1.55
log
@Approved by Jim Blandy (jimb@@redhat.com).

	2002-02-21  Fred Fish  <fnf@@redhat.com>
	* dbxread.c (process_one_symbol): When finding an N_FUN symbol
	that marks the end of the range of a function, enter a line number
	entry that has a line number of zero and a PC offset that matches
	the end of the function.  This starts a range of PC's for which no
	line number information is known.
	* symtab.c (find_pc_sect_line): If our best fit is in a range of
	PC's for which no line number info is found (line number is zero)
	then we didn't find any valid line information.
	* symtab.h: Document use of zero line number entry.
@
text
@d2459 1
a2459 1
  free (symbols);
@


1.54
log
@2002-02-10  Daniel Jacobowitz  <drow@@mvista.com>

        * symtab.c (compare_search_syms): New function.
        (sort_search_symbols): New function.
        (search_symbols): Sort symbols after searching rather than
        before.

2002-02-10  Daniel Jacobowitz  <drow@@mvista.com>

        * generic/gdbtk-cmds.c (gdb_listfuncs): Don't call
        BLOCK_SHOULD_SORT.
        * library/browserwin.itb (BrowserWin::_fill_funcs_combo): Sort
        the output of gdb_listfuncs.
@
text
@d1826 7
@


1.53
log
@2002-01-30  Daniel Jacobowitz  <drow@@mvista.com>

        * symtab.c (find_pc_sect_psymtab): Do not search psymtabs for
        data symbols, since we search based on textlow and texthigh.
        (find_pc_sect_symtab): Likewise.
@
text
@d2409 46
d2467 3
d2659 2
a2661 3
	  /* Skip the sort if this block is always sorted.  */
	  if (!BLOCK_SHOULD_SORT (b))
	    sort_block_syms (b);
d2683 1
a2683 4
		    {
		      sr = psr;
		      old_chain = make_cleanup_free_search_symbols (sr);
		    }
d2687 14
d2702 2
@


1.52
log
@Remove else clause to #if UI_OUT.
@
text
@d358 13
a375 1
	struct minimal_symbol *msymbol;
a385 1
	msymbol = lookup_minimal_symbol_by_pc_section (pc, section);
d1400 15
@


1.51
log
@	* configure, config.in: Rebuilt.
	* configure.in: Check for realpath.
	* defs.h (gdb_realpath): Declare.
	* symtab.h (partial_symtab): Added fullname field.
	* source.c (openp): Use gdb_realpath.
	(forget_cached_source_info): Clear full name of each partial
	symtab.
	* utils.c (gdb_realpath): New function.
	* symtab.c (lookup_symtab): Removed.
	(lookup_symtab_1): Renamed to lookup_symtab.
	(lookup_symtab): Look for real path.
	(lookup_partial_symtab): Likewise.
@
text
@d2 4
a5 3
   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d2833 1
a2833 1
#ifdef UI_OUT
d2839 1
a2839 1
#endif
@


1.50
log
@2001-12-03  Michael Snyder  <msnyder@@redhat.com>

	* symtab.c (search_symbols): Make sure alloca size is big enough.
@
text
@d144 6
d156 1
d158 18
a175 1
      return s;
d222 6
d233 1
d236 13
d250 2
@


1.49
log
@* symtab.c (find_pc_sect_line): Revert change of 2001-11-13; add
comment explaining that hand-written assembly code can have line
number info but no debug info for an enclosing function.
@
text
@d2424 1
a2424 1
	      char *tmp = (char *) alloca (strlen (regexp) + fix);
@


1.48
log
@Patch from Peter Schauer:

* symtab.c (find_pc_sect_line): If we can't find the function
containing PC, we certainly won't have line number information for
that location, so return zero immediately.
@
text
@d1573 6
a1578 7
  /* Don't even think about line numbers if we can't find a function
     symbol for PC.  */
  if (find_pc_function (pc) == NULL)
    {
      val.pc = pc;
      return val;
    }
@


1.47
log
@2001-11-01  Michael Snyder  <msnyder@@redhat.com>

	* symtab.c (operator_chars): Allow '*' and '[' to be quoted in
	operator names, to avoid regexp expansion.
	(search_symbols): Alloca buffer is too small, may get clobbered.
@
text
@d1573 8
@


1.46
log
@	* symtab.c (lookup_block_symbol):  Break out of linear search
        if we're past the range of possible matches.

Original patch submission, with links to history/background behind it,
here:
	http://sources.redhat.com/ml/gdb-patches/2001-09/msg00120.html
@
text
@d2070 84
a2153 9
  switch (*p)
    {
    case '!':
    case '=':
    case '*':
    case '/':
    case '%':
    case '^':
      if (p[1] == '=')
d2155 4
a2158 10
      else
	*end = p + 1;
      return p;
    case '<':
    case '>':
    case '+':
    case '-':
    case '&':
    case '|':
      if (p[1] == '=' || p[1] == p[0])
d2160 6
a2165 26
      else
	*end = p + 1;
      return p;
    case '~':
    case ',':
      *end = p + 1;
      return p;
    case '(':
      if (p[1] != ')')
	error ("`operator ()' must be specified without whitespace in `()'");
      *end = p + 2;
      return p;
    case '?':
      if (p[1] != ':')
	error ("`operator ?:' must be specified without whitespace in `?:'");
      *end = p + 2;
      return p;
    case '[':
      if (p[1] != ']')
	error ("`operator []' must be specified without whitespace in `[]'");
      *end = p + 2;
      return p;
    default:
      error ("`operator %s' not supported", p);
      break;
    }
d2417 1
a2417 1
	      char *tmp = (char *) alloca (opend - opname + 10);
@


1.45
log
@2001-10-15  Elena Zannoni  <ezannoni@@redhat.com>

        * symtab.c (lookup_block_symbol): Update comment.
@
text
@d1214 4
@


1.44
log
@2001-10-12  Daniel Jacobowitz  <drow@@mvista.com>

        * symtab.h (struct block): (ALL_BLOCK_SYMBOLS): New macro.

        * symtab.c (find_pc_sect_symtab): Use ALL_BLOCK_SYMBOLS.
        (make_symbol_completion_list): Likewise.
        (make_symbol_overload_list): Likewise.
        * buildsym.c (finish_block): Likewise.
        * breakpoint.c (get_catch_sals):  Likewise.
        * mdebugread.c (mylookup_symbol): Likewise.
        * objfiles.c (objfile_relocate): Likewise.
        * printcmd.c (print_frame_args): Likewise.
        * stack.c (print_block_frame_locals): Likewise.
        (print_block_frame_labels): Likewise.
        (print_frame_arg_vars): Likewise.
        * symmisc.c (dump_symtab): Likewise.
        * tracepoint.c (add_local_symbols): Likewise.
        (scope_info): Likewise.

2001-10-12  Daniel Jacobowitz  <drow@@mvista.com>

        * mi-cmd-stack.c (list_args_or_locals): Use ALL_BLOCK_SYMBOLS.

2001-10-12  Daniel Jacobowitz  <drow@@mvista.com>

        * generic/gdbtk-cmds.c (gdb_listfuncs): Use ALL_BLOCK_SYMBOLS.
        * generic/gdbtk-stack.c (gdb_block_vars): Likewise.
        (gdb_get_blocks): Likewise.
        (gdb_get_vars_command): Likewise.
5~
@
text
@d1220 1
a1220 1
     symbol which is a C++ symbol, then we have re-enabled the linear
@


1.43
log
@	* symtab.c (lookup_symtab): Removed.
	(lookup_symtab_1): Renamed to lookup_symtab.
@
text
@d2995 1
a2995 1
      for (i = 0; i < BLOCK_NSYMS (b); i++)
a2996 1
	  sym = BLOCK_SYM (b, i);
d3025 1
a3025 1
    for (i = 0; i < BLOCK_NSYMS (b); i++)
a3026 1
	sym = BLOCK_SYM (b, i);
d3038 1
a3038 1
    for (i = 0; i < BLOCK_NSYMS (b); i++)
a3039 1
	sym = BLOCK_SYM (b, i);
d3143 1
a3143 1
  for (i = 0; i < BLOCK_NSYMS (b); i++)
a3144 1
      sym = BLOCK_SYM (b, i);
d3149 1
a3149 1
  for (i = 0; i < BLOCK_NSYMS (b); i++)
a3150 1
      sym = BLOCK_SYM (b, i);
d3528 1
a3528 1
      for (i = 0; i < BLOCK_NSYMS (b); i++)
a3529 1
	  sym = BLOCK_SYM (b, i);
d3541 1
a3541 1
    for (i = 0; i < BLOCK_NSYMS (b); i++)
a3542 1
	sym = BLOCK_SYM (b, i);
d3554 1
a3554 1
    for (i = 0; i < BLOCK_NSYMS (b); i++)
a3555 1
	sym = BLOCK_SYM (b, i);
@


1.42
log
@* symtab.c (main_name): New function.
(set_main_name): New function.
* symtab.h: Declare.
* TODO: Update

From 2000-03-05 Anthony Green <green@@redhat.com>:
* dbxread.c (process_one_symbol): Handle the N_MAIN stab by
setting main_name.
* blockframe.c (inside_main_func): Use main_name instead of
"main".
* symtab.c (find_main_psymtab): Ditto.
* source.c (select_source_symtab): Ditto.
* nlmread.c (nlm_symfile_read): Ditto.
* rs6000-tdep.c (skip_prologue): Ditto.
@
text
@a81 2
static struct symtab *lookup_symtab_1 (const char *);

d138 2
a139 2
static struct symtab *
lookup_symtab_1 (const char *name)
a186 36
}

/* Lookup the symbol table of a source file named NAME.  Try a couple
   of variations if the first lookup doesn't work.  */

struct symtab *
lookup_symtab (const char *name)
{
  register struct symtab *s;
#if 0
  register char *copy;
#endif

  s = lookup_symtab_1 (name);
  if (s)
    return s;

#if 0
  /* This screws c-exp.y:yylex if there is both a type "tree" and a symtab
     "tree.c".  */

  /* If name not found as specified, see if adding ".c" helps.  */
  /* Why is this?  Is it just a user convenience?  (If so, it's pretty
     questionable in the presence of C++, FORTRAN, etc.).  It's not in
     the GDB manual.  */

  copy = (char *) alloca (strlen (name) + 3);
  strcpy (copy, name);
  strcat (copy, ".c");
  s = lookup_symtab_1 (copy);
  if (s)
    return s;
#endif /* 0 */

  /* We didn't find anything; die.  */
  return 0;
@


1.41
log
@s/basename/lbasename/ clean up consequences of assuming lbasename()
returns const char *.
@
text
@d1161 1
a1161 1
    if (lookup_partial_symbol (pst, "main", 1, VAR_NAMESPACE))
d3626 27
@


1.41.2.1
log
@Typesystem work initial import.
Note that this currently isn't building, i'm in the middle of converting make_function_type/lookup_function_type
@
text
@a49 1
#include "splay-tree.h"
d198 3
d206 16
d271 1
a271 1
  const char *newname = type_name_no_tag (type);
d587 1
a587 1
extern splay_tree symbolsplay;
a599 8
  register splay_tree_node result;
  int skipblocksearches=0;
  struct block_splay_data *splaydata=NULL;
  result = splay_tree_lookup (symbolsplay, (splay_tree_key) name);
  if (result == NULL)
    skipblocksearches = 1;
  else
    splaydata = (struct block_splay_data *)result->value;
d601 4
a604 1
  if (!skipblocksearches)
d606 2
a607 3
      /* Search specified block and its superiors.  */
      
      while (block != 0)
d609 2
a610 1
	  if (bitmap_bit_p (splaydata->blocks, BLOCK_ID (block)))
d612 12
a623 22
	      sym = lookup_block_symbol (block, name, namespace);
	      if (sym)
		{
		  block_found = block;
		  if (symtab != NULL)
		    {
		      /* Search the list of symtabs for one which contains the
			 address of the start of this block.  */
		      ALL_SYMTABS (objfile, s)
			{
			  bv = BLOCKVECTOR (s);
			  b = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
			  if (BLOCK_START (b) <= BLOCK_START (block)
			      && BLOCK_END (b) > BLOCK_START (block))
			    goto found;
			}
		    found:
		      *symtab = s;
		    }
		  
		  return fixup_symbol_section (sym, objfile);
		}
d625 2
a626 1
	  block = BLOCK_SUPERBLOCK (block);
d628 1
d630 42
d692 22
a713 1
  if (!skipblocksearches)
d715 2
a716 1
      ALL_SYMTABS (objfile, s)
d718 3
a720 3
	  bv = BLOCKVECTOR (s);
	  block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
	  if (bitmap_bit_p (splaydata->blocks, BLOCK_ID (block)))
d722 8
a729 2
	      sym = lookup_block_symbol (block, name, namespace);
	      if (sym)
d731 3
a733 4
		  block_found = block;
		  if (symtab != NULL)
		    *symtab = s;
		  return fixup_symbol_section (sym, objfile);
d735 17
d753 12
d767 3
a769 1
  
d805 15
a819 20
  if (!skipblocksearches)
    {
      ALL_SYMTABS (objfile, s)
	{
	  bv = BLOCKVECTOR (s);
	  block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
	  if (bitmap_bit_p (splaydata->blocks, BLOCK_ID (block)))
	    {
	      sym = lookup_block_symbol (block, name, namespace);
	      if (sym)
		{
		  block_found = block;
		  if (symtab != NULL)
		    *symtab = s;
		  return fixup_symbol_section (sym, objfile);
		}
	    }
	}
    }
  
d849 1
d943 1
d987 5
d1171 8
a1178 4
   If we couldn't use a hashtable for the block, we just do a linear search.
   Otherwise, we hash the name, and walk the bucket's symbol chain to see if we find
   the symbol we want. 
*/
d1184 6
a1189 3
  register unsigned int top,bot;
  register struct symbol *sym, *sym_found=NULL;
 
d1191 79
a1269 1
  if (BLOCK_FUNCTION (block) != NULL)
d1301 1
a1301 1
	      
d1316 1
a1316 13
  else
    {
      top = msymbol_hash_iw (name) % BLOCK_NBUCKETS (block);
      sym_found = BLOCK_BUCKET (block, top);
      while (sym_found != NULL)
	{
	  if (SYMBOL_NAMESPACE (sym_found) == namespace 
	      && SYMBOL_MATCHES_NAME (sym_found, name))
	    break;
	  sym_found = sym_found->hash_next;
	}
    }
  return sym_found;
d1376 1
a1376 2
  if (pc == 0)
	  return NULL;
d1418 1
a1418 1
	    for (i = 0; i < BLOCK_NBUCKETS(b); i++)
d1420 3
a1422 7
		register struct symbol *tempsym;
		for (tempsym = BLOCK_BUCKET (b,i); tempsym; tempsym = tempsym->hash_next)
		  {
		    fixup_symbol_section (tempsym, objfile);
		    if (section == SYMBOL_BFD_SECTION (tempsym))
		      break;
		  }
d1424 1
a1424 1
	    if (i >= BLOCK_NBUCKETS(b))
d2516 4
a2519 1
	  for (j = 0; j < BLOCK_NBUCKETS (b); j++)
d2522 3
a2524 4
	      for (sym = BLOCK_BUCKET (b, j); sym; sym = sym->hash_next)
		{
		  if (file_matches (s->filename, files, nfiles)
		      && ((regexp == NULL || SYMBOL_MATCHES_REGEXP (sym))
d2531 9
d2541 2
a2542 15
		      /* match */
		      psr = (struct symbol_search *) xmalloc (sizeof (struct symbol_search));
		      psr->block = i;
		      psr->symtab = s;
		      psr->symbol = sym;
		      psr->msymbol = NULL;
		      psr->next = NULL;
		      if (tail == NULL)
			{
			  sr = psr;
			  old_chain = make_cleanup_free_search_symbols (sr);
			}
		      else
			tail->next = psr;
		      tail = psr;
d2544 3
d2552 1
a2552 1
  
d3033 1
a3033 1
      for (i = 0; i < BLOCK_NBUCKETS (b); i++)
d3035 3
a3037 1
	  for (sym = BLOCK_BUCKET (b, i); sym; sym=sym->hash_next)
d3039 4
a3042 3
	      
	      COMPLETION_LIST_ADD_SYMBOL (sym, sym_text, sym_text_len, text, word);
	      if (SYMBOL_CLASS (sym) == LOC_TYPEDEF)
d3044 1
a3044 4
		  struct type *t = SYMBOL_TYPE (sym);
		  enum type_code c = TYPE_CODE (t);
		  
		  if (c == TYPE_CODE_UNION || c == TYPE_CODE_STRUCT)
d3046 1
a3046 1
		      for (j = TYPE_N_BASECLASSES (t); j < TYPE_NFIELDS (t); j++)
d3048 2
a3049 5
			  if (TYPE_FIELD_NAME (t, j))
			    {
			      completion_list_add_name (TYPE_FIELD_NAME (t, j),
							sym_text, sym_text_len, text, word);
			    }
d3064 1
a3064 1
    for (i = 0; i < BLOCK_NBUCKETS (b); i++)
d3066 2
a3067 2
	for (sym = BLOCK_BUCKET (b, i); sym; sym = sym->hash_next)
	  COMPLETION_LIST_ADD_SYMBOL (sym, sym_text, sym_text_len, text, word);
d3078 1
a3078 1
    for (i = 0; i < BLOCK_NBUCKETS (b); i++)
d3080 2
a3081 2
	for (sym = BLOCK_BUCKET (b, i); sym; sym = sym->hash_next)
	  COMPLETION_LIST_ADD_SYMBOL (sym, sym_text, sym_text_len, text, word);
d3571 1
a3571 1
      for (i = 0; i < BLOCK_NBUCKETS (b); i++)
d3573 2
a3574 2
	  for (sym = BLOCK_BUCKET (b, i); sym; sym=sym->hash_next)
	    overload_list_add_symbol (sym, oload_name);
d3585 1
a3585 1
    for (i = 0; i < BLOCK_NBUCKETS (b); i++)
d3587 2
a3588 2
	for (sym = BLOCK_BUCKET (b, i); sym; sym=sym->hash_next)
	  overload_list_add_symbol (sym, oload_name);
d3599 1
a3599 1
    for (i = 0; i < BLOCK_NBUCKETS (b); i++)
d3601 2
a3602 2
	for (sym = BLOCK_BUCKET (b, i); sym; sym=sym->hash_next)
	  overload_list_add_symbol (sym, oload_name);
@


1.40
log
@s/char */const char */
@
text
@d160 1
a160 1
      if (FILENAME_CMP (basename (s->filename), name) == 0)
d250 1
a250 1
      if (FILENAME_CMP (basename (pst->filename), name) == 0)
d2279 1
a2279 1
	  if (strcmp (files[i], basename (file)) == 0)
d3170 1
a3170 1
      char *tail = basename (srcfile);
d3275 1
a3275 1
  char *base_name;
d3305 1
a3305 1
	  base_name = basename (s->filename);
d3341 1
a3341 1
	      base_name = basename (ps->filename);
@


1.39
log
@	* completer.c (gdb_completer_loc_break_characters): New variable.
	(line_completion_function): If we are completing on locations,
	back up the start of word pointer past all characters which can
	appear in a location spec.
	(location_completer): New function.

	* completer.h: Add prototype for location_completer.

	* symtab.c (make_source_files_completion_list)
	(add_filename_to_list, not_interesting_fname): New functions.
	(filename_seen): New function, body extracted from
	output_source_filename.
	(output_source_filename): Call filename_seen to check if the file
	was already printed.
	(make_symbol_completion_list): If TEXT includes a
	double-quoted string, return an empty list, not NULL.
	(make_file_symbol_completion_list): New function, similar to
	make_symbol_completion_list but with an additional argument
	SRCFILE.

	* symtab.h (make_file_symbol_completion_list)
	(make_source_files_completion_list): Add prototypes.

	* breakpoint.c (_initialize_breakpoint): Make location_completer
	be the completion function for all commands which set breakpoints
	and watchpoints.
	(top-level): #include "completer.h".

	* tracepoint.c (_initialize_tracepoint): Make location_completer
	be the completion function for the "trace" command.
	(top-level): #include "completer.h".

	* printcmd.c (_initialize_printcmd): Make location_completer be
	the completion function for the "print", "inspect", "call", and
	"disassemble" commands.
	(top-level): #include "completer.h".

	* infcmd.c (_initialize_infcmd): Make location_completer be the
	completion function for the "go", "jump", and "until" commands.
	(top-level): #include "completer.h".
@
text
@d82 1
a82 1
static struct symtab *lookup_symtab_1 (char *);
d141 1
a141 1
lookup_symtab_1 (char *name)
d195 1
a195 1
lookup_symtab (char *name)
d232 1
a232 1
lookup_partial_symtab (char *name)
@


1.38
log
@* symtab.c (lookup_symtab_1): Use lbasename (NAME) instead of
basename (NAME).  The FreeBSD basename returns a pointer to a
static buffer, even if it's simply returning a string identical to
its argument.
(lookup_partial_symtab): Likewise.
@
text
@d2156 6
a2161 5
/* Slave routine for sources_info.  Force line breaks at ,'s.
   NAME is the name to print and *FIRST is nonzero if this is the first
   name printed.  Set *FIRST to zero.  */
static void
output_source_filename (char *name, int *first)
d2163 2
a2164 9
  /* Table of files printed so far.  Since a single source file can
     result in several partial symbol tables, we need to avoid printing
     it more than once.  Note: if some of the psymtabs are read in and
     some are not, it gets printed both under "Source files for which
     symbols have been read" and "Source files for which symbols will
     be read in on demand".  I consider this a reasonable way to deal
     with the situation.  I'm not sure whether this can also happen for
     symtabs; it doesn't hurt to check.  */
  static char **tab = NULL;
d2171 1
a2171 2

  char **p;
d2176 1
a2176 1
	tab = (char **) xmalloc (tab_alloc_size * sizeof (*tab));
d2180 1
a2180 1
  /* Is NAME in tab?  */
d2182 36
a2217 1
    if (STREQ (*p, name))
a2219 5
  /* No; add it to tab.  */
  if (tab_cur_size == tab_alloc_size)
    {
      tab_alloc_size *= 2;
      tab = (char **) xrealloc ((char *) tab, tab_alloc_size * sizeof (*tab));
d2221 1
a2221 2
  tab[tab_cur_size++] = name;

d2896 3
a2898 3
/* Return a NULL terminated array of all symbols (regardless of class) which
   begin by matching TEXT.  If the answer is no symbols, then the return value
   is an array which contains only a NULL pointer.
d2952 5
a2956 1
      return NULL;
d3086 271
@


1.37
log
@2001-02-28  Michael Snyder  <msnyder@@mvstp600e.cygnus.com>

	* symtab.c (print_msymbol_info): Print addresses by portable method
	longest_local_hex_string_custom.  Allow for 64-bit addresses.
@
text
@d157 1
a157 1
  if (basename (name) == name)
d247 1
a247 1
  if (basename (name) == name)
@


1.36
log
@	* symtab.c (lookup_symtab_1, lookup_partial_symtab): Use basename
	instead of non-portable search for `/'.  Use FILENAME_CMP instead
	of STREQ, to account for case-insensitive filesystems.
	(top-level): #include "filenames.h".
@
text
@d2647 11
a2657 3
  printf_filtered ("	%08lx  %s\n",
		   (unsigned long) SYMBOL_VALUE_ADDRESS (msymbol),
		   SYMBOL_SOURCE_NAME (msymbol));
@


1.35
log
@(Changes from Daniel Berlin, with revisions by Jim Blandy.)

Abstract out operations specific to particular C++ ABI's, and
invoke them through a function table.  This removes the C++ ABI
dependencies scattered throughout the code, and allows us to
cleanly add support for new C++ ABI's.
* cp-abi.h, cp-abi.h, gnu-v2-abi.c, hpacc-abi.c: New files.
* c-typeprint.c, c-valprint.c, dbxread.c, eval.c, gdbtypes.c,
jv-typeprint.c, linespec.c, symtab.c, typeprint.c, valops.c:
#include "cp-abi.h".  These files all use functions now declared
there.
* symtab.h (OPNAME_PREFIX_P, VTBL_PREFIX_P, DESTRUCTOR_PREFIX_P):
Deleted.  These services are now provided by functions declared in
cp-abi.h.
* value.h (value_rtti_type, value_virtual_fn_field): Same.
* values.c (value_virtual_fn_field): Same, for this definition.
* valops.c (value_rtti_type): Same.
* c-typeprint.c (c_type_print_base): Use the functions from
"cp-abi.h", instead of the old macros, or hard-coded ABI-specific
tests.
* dbxread.c (record_minimal_symbol): Same.
* gdbtypes.c (get_destructor_fn_field, virtual_base_index,
virtual_base_index_skip_primaries): Same.
* jv-typeprint.c (java_type_print_base): Same.
* linespec.c (find_methods, decode_line_1): Same.
* symtab.c (gdb_mangle_name): Same.
* Makefile.in (SFILES): Add the new .c files mentioned above.
(cp_abi_h): New variable.
(COMMON_OBS): Add gnu-v2-abi.o, hpacc-abi.o, and cp-abi.o.
(cp-abi.o, gnu-v2-abi.o, hpacc-abi.o): New targets.
(c-typeprint.o, c-valprint.o, dbxread.o, eval.o, gdbtypes.o,
jv-typeprint.o, symtab.o, linespec.o, typeprint.o, valops.o): Add
dependency on $(cp_abi_h).
@
text
@d40 1
a144 1
  register char *slash;
d152 2
a153 4
    if (STREQ (name, s->filename))
    return s;

  slash = strchr (name, '/');
d157 1
a157 1
  if (!slash)
d160 1
a160 7
      char *p = s->filename;
      char *tail = strrchr (p, '/');

      if (tail)
	p = tail + 1;

      if (STREQ (p, name))
d239 1
a239 1
    if (STREQ (name, pst->filename))
d247 1
a247 1
  if (!strchr (name, '/'))
d250 1
a250 7
      char *p = pst->filename;
      char *tail = strrchr (p, '/');

      if (tail)
	p = tail + 1;

      if (STREQ (p, name))
@


1.34
log
@2001-03-20  Daniel Berlin  <dberlin@@redhat.com>

	* symtab.c (completion_list_add_name): Remove duplicate string checks,
	readline already does this, and it's much faster at it, too.
@
text
@d48 1
d292 1
a292 1
  int is_destructor = DESTRUCTOR_PREFIX_P (physname);
d299 1
a299 1
  if (OPNAME_PREFIX_P (field_name))
d302 1
a302 4
  is_full_physname_constructor =
    ((physname[0] == '_' && physname[1] == '_' &&
      (isdigit (physname[2]) || physname[2] == 'Q' || physname[2] == 't'))
     || (strncmp (physname, "__ct", 4) == 0));
@


1.33
log
@	* symtab.c (find_pc_sect_line): Revise method used for finding
	the ending pc.
@
text
@a2846 11
  /* Clip any symbol names that we've already considered.  (This is a
     time optimization)  */

  for (i = 0; i < return_val_index; ++i)
    {
      if (STREQ (symname, return_val[i]))
	{
	  return;
	}
    }

a2869 13
      }

    /* Recheck for duplicates if we intend to add a modified symbol.  */
    if (word != sym_text)
      {
	for (i = 0; i < return_val_index; ++i)
	  {
	    if (STREQ (new, return_val[i]))
	      {
		xfree (new);
		return;
	      }
	  }
@


1.32
log
@Update/correct copyright notices.
@
text
@d1762 4
a1765 4
	  /* If another line is in the linetable, and its PC is closer
	     than the best_end we currently have, take it as best_end.  */
	  if (i < len && (best_end == 0 || best_end > item->pc))
	    best_end = item->pc;
d1767 7
@


1.31
log
@fix off by one error in test for error.
@
text
@d2 2
a3 1
   Copyright 1986, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 1998
@


1.30
log
@Replace calls to abort() with calls to internal_error().
@
text
@d2351 1
a2351 1
  if (kind < LABEL_NAMESPACE)
@


1.29
log
@2001-02-19  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	From Peter Schauer <Peter.Schauer@@regent.e-technik.tu-muenchen.de>
 	* symtab.c (lookup_symbol_aux): Call lookup_symbol_aux, not
 	lookup_symbol, when trying to find a symbol with a mangled name,
 	to avoid infinite recursion.
@
text
@d1001 1
a1001 1
	    abort ();
d1017 1
a1017 1
	abort ();
@


1.28
log
@2001-01-29  Michael Chastain  <chastain@@redhat.com>

	* symtab.c (block_lookup_symbol): Use 'namespace' parameter in
	symbol comparisons in binary search.
@
text
@d952 2
a953 2
	      return lookup_symbol (SYMBOL_NAME (msymbol), block,
				    namespace, is_a_field_of_this, symtab);
@


1.27
log
@Replace STRCMP with strcmp()
@
text
@d1262 5
a1266 2
	  if (SYMBOL_MATCHES_NAME (sym, name))
	    return sym;
@


1.26
log
@* symtab.c (lookup_symbol_aux): Call lookup_symbol_aux to lookup
a mangled symbol rather than recursing into lookup_symbol, since
this will just re-unmangle the name & call lookup_symbol_aux -
leading to an infinite recursion.
@
text
@d1007 1
a1007 1
	  if (STRCMP (SYMBOL_SOURCE_NAME (*center), name) >= 0)
d1240 1
a1240 1
	  else if (STRCMP (SYMBOL_SOURCE_NAME (sym), name) < 0)
@


1.25
log
@Replace free() with xfree().
@
text
@d774 2
a775 2
	      return lookup_symbol (SYMBOL_NAME (msymbol), block,
				    namespace, is_a_field_of_this, symtab);
@


1.24
log
@2000-11-30  Fernando Nasser  <fnasser@@redhat.com>

        * linespec.h: New file. Declarations for linespec.c.
        * linespec.c, alpha-tdep.c, breakpoint.c, parse.c, source.c,
        symtab.c, tracepoint.c: Include the above.
        * completer.c: New file. Line completion stuff for GDB.
        (get_gdb_completer_word_break_characters,
        get_gdb_completer_quote_characters): New functions. Accessors for
        useful completer internal data.
        (filename_completer, line_completion_function, skip_quoted): Moved
        here from top.c.
        * completer.h: New file. Declarations for the above.
        * linespec.c (decode_line_1): Use
        get_gdb_completer_word_break_characters and
        get_gdb_completer_quote_characters.
        * top.c: Include completer.h.
        (filename_completer, line_completion_function, skip_quoted):
        Moved to completer.c.
        * corefile.c, exec.c, source.c, symfile.c, linespec.c: Include
        completer.h.
        * Makefile.in (SFILES): Add completer.c.
        (COMMON_OBS): Add completer.o.
        (completer.o): New target.
        (linespec.o, alpha-tdep.o, breakpoint.o, parse.o, source.o,
        symtab.o, tracepoint.o): Add linespec.h to dependencies list.
        (corefile.o, exec.o, source.o, symfile.o, linespec.o): Add completer.h
        to dependencies list.
@
text
@d598 1
a598 1
    free (modified_name2);
d2281 1
a2281 1
      free (p);
d2640 1
a2640 1
	  free (demangled_name);
d2879 1
a2879 1
		free (new);
d3186 1
a3186 1
      free (sym_name);
d3209 1
a3209 1
  free (sym_name);
d3330 1
a3330 1
  free (oload_name);
@


1.23
log
@* symtab.c (no_symtab_msg): Remove definition.
(sources_info): Replace use of no_symtab_msg with the string
itself.
* linespec.c (no_symtab_msg): Remove declaration.
(decode_line_1): Replace uses of no_symtab_msg with the string
itself.
@
text
@d38 1
@


1.22
log
@2000-11-10  Fernando Nasser  <fnasser@@totem.toronto.redhat.com>

	* symtab.c (decode_line_1, total_number_of_methods, find_methods,
	build_command_line_spec, find_toplevel_char, decode_line_2):
	Move to linespec.c.
	* linespec.c: New file. Routines that handle linespecs, formerly
	in symtab.c.
	* symtab.h: Export find_line_symtab and find_function_start_sal,
	* Makefile.in: Add linespec.c.
@
text
@a118 2
char no_symtab_msg[] = "No symbol table is loaded.  Use the \"file\" command.";

d2227 1
a2227 1
      error (no_symtab_msg);
@


1.21
log
@Protoization.
@
text
@a53 2
static int find_methods (struct type *, char *, struct symbol **);

a55 6
static void build_canonical_line_spec (struct symtab_and_line *,
				       char *, char ***);

static struct symtabs_and_lines decode_line_2 (struct symbol *[],
					       int, int, char ***);

d68 3
a70 1
char *operator_chars (char *, char **);
d72 1
a72 1
static int find_line_common (struct linetable *, int, int *);
a86 2
static void cplusplus_hint (char *);

a1814 3

static struct symtab *find_line_symtab (struct symtab *, int, int *, int *);

d1825 1
a1825 1
static struct symtab *
d2032 1
a2032 4
static struct symtab_and_line
find_function_start_sal (struct symbol *sym, int);

static struct symtab_and_line
d2077 1
a2077 1

a2159 1210

/* Return the number of methods described for TYPE, including the
   methods from types it derives from. This can't be done in the symbol
   reader because the type of the baseclass might still be stubbed
   when the definition of the derived class is parsed.  */

static int total_number_of_methods (struct type *type);

static int
total_number_of_methods (struct type *type)
{
  int n;
  int count;

  CHECK_TYPEDEF (type);
  if (TYPE_CPLUS_SPECIFIC (type) == NULL)
    return 0;
  count = TYPE_NFN_FIELDS_TOTAL (type);

  for (n = 0; n < TYPE_N_BASECLASSES (type); n++)
    count += total_number_of_methods (TYPE_BASECLASS (type, n));

  return count;
}

/* Recursive helper function for decode_line_1.
   Look for methods named NAME in type T.
   Return number of matches.
   Put matches in SYM_ARR, which should have been allocated with
   a size of total_number_of_methods (T) * sizeof (struct symbol *).
   Note that this function is g++ specific.  */

static int
find_methods (struct type *t, char *name, struct symbol **sym_arr)
{
  int i1 = 0;
  int ibase;
  struct symbol *sym_class;
  char *class_name = type_name_no_tag (t);

  /* Ignore this class if it doesn't have a name.  This is ugly, but
     unless we figure out how to get the physname without the name of
     the class, then the loop can't do any good.  */
  if (class_name
      && (sym_class = lookup_symbol (class_name,
				     (struct block *) NULL,
				     STRUCT_NAMESPACE,
				     (int *) NULL,
				     (struct symtab **) NULL)))
    {
      int method_counter;

      /* FIXME: Shouldn't this just be CHECK_TYPEDEF (t)?  */
      t = SYMBOL_TYPE (sym_class);

      /* Loop over each method name.  At this level, all overloads of a name
         are counted as a single name.  There is an inner loop which loops over
         each overload.  */

      for (method_counter = TYPE_NFN_FIELDS (t) - 1;
	   method_counter >= 0;
	   --method_counter)
	{
	  int field_counter;
	  char *method_name = TYPE_FN_FIELDLIST_NAME (t, method_counter);
	  char dem_opname[64];

	  if (strncmp (method_name, "__", 2) == 0 ||
	      strncmp (method_name, "op", 2) == 0 ||
	      strncmp (method_name, "type", 4) == 0)
	    {
	      if (cplus_demangle_opname (method_name, dem_opname, DMGL_ANSI))
		method_name = dem_opname;
	      else if (cplus_demangle_opname (method_name, dem_opname, 0))
		method_name = dem_opname;
	    }

	  if (STREQ (name, method_name))
	    /* Find all the overloaded methods with that name.  */
	    for (field_counter = TYPE_FN_FIELDLIST_LENGTH (t, method_counter) - 1;
		 field_counter >= 0;
		 --field_counter)
	      {
		struct fn_field *f;
		char *phys_name;

		f = TYPE_FN_FIELDLIST1 (t, method_counter);

		if (TYPE_FN_FIELD_STUB (f, field_counter))
		  {
		    char *tmp_name;

		    tmp_name = gdb_mangle_name (t,
						method_counter,
						field_counter);
		    phys_name = alloca (strlen (tmp_name) + 1);
		    strcpy (phys_name, tmp_name);
		    free (tmp_name);
		  }
		else
		  phys_name = TYPE_FN_FIELD_PHYSNAME (f, field_counter);

		/* Destructor is handled by caller, dont add it to the list */
		if (DESTRUCTOR_PREFIX_P (phys_name))
		  continue;

		sym_arr[i1] = lookup_symbol (phys_name,
					     NULL, VAR_NAMESPACE,
					     (int *) NULL,
					     (struct symtab **) NULL);
		if (sym_arr[i1])
		  i1++;
		else
		  {
		    /* This error message gets printed, but the method
		       still seems to be found
		       fputs_filtered("(Cannot find method ", gdb_stdout);
		       fprintf_symbol_filtered (gdb_stdout, phys_name,
		       language_cplus,
		       DMGL_PARAMS | DMGL_ANSI);
		       fputs_filtered(" - possibly inlined.)\n", gdb_stdout);
		     */
		  }
	      }
	}
    }

  /* Only search baseclasses if there is no match yet, since names in
     derived classes override those in baseclasses.

     FIXME: The above is not true; it is only true of member functions
     if they have the same number of arguments (??? - section 13.1 of the
     ARM says the function members are not in the same scope but doesn't
     really spell out the rules in a way I understand.  In any case, if
     the number of arguments differ this is a case in which we can overload
     rather than hiding without any problem, and gcc 2.4.5 does overload
     rather than hiding in this case).  */

  if (i1 == 0)
    for (ibase = 0; ibase < TYPE_N_BASECLASSES (t); ibase++)
      i1 += find_methods (TYPE_BASECLASS (t, ibase), name, sym_arr + i1);

  return i1;
}

/* Helper function for decode_line_1.
   Build a canonical line spec in CANONICAL if it is non-NULL and if
   the SAL has a symtab.
   If SYMNAME is non-NULL the canonical line spec is `filename:symname'.
   If SYMNAME is NULL the line number from SAL is used and the canonical
   line spec is `filename:linenum'.  */

static void
build_canonical_line_spec (struct symtab_and_line *sal, char *symname,
			   char ***canonical)
{
  char **canonical_arr;
  char *canonical_name;
  char *filename;
  struct symtab *s = sal->symtab;

  if (s == (struct symtab *) NULL
      || s->filename == (char *) NULL
      || canonical == (char ***) NULL)
    return;

  canonical_arr = (char **) xmalloc (sizeof (char *));
  *canonical = canonical_arr;

  filename = s->filename;
  if (symname != NULL)
    {
      canonical_name = xmalloc (strlen (filename) + strlen (symname) + 2);
      sprintf (canonical_name, "%s:%s", filename, symname);
    }
  else
    {
      canonical_name = xmalloc (strlen (filename) + 30);
      sprintf (canonical_name, "%s:%d", filename, sal->line);
    }
  canonical_arr[0] = canonical_name;
}



/* Find an instance of the character C in the string S that is outside
   of all parenthesis pairs, single-quoted strings, and double-quoted
   strings.  */
static char *
find_toplevel_char (char *s, char c)
{
  int quoted = 0;		/* zero if we're not in quotes;
				   '"' if we're in a double-quoted string;
				   '\'' if we're in a single-quoted string.  */
  int depth = 0;		/* number of unclosed parens we've seen */
  char *scan;

  for (scan = s; *scan; scan++)
    {
      if (quoted)
	{
	  if (*scan == quoted)
	    quoted = 0;
	  else if (*scan == '\\' && *(scan + 1))
	    scan++;
	}
      else if (*scan == c && ! quoted && depth == 0)
	return scan;
      else if (*scan == '"' || *scan == '\'')
	quoted = *scan;
      else if (*scan == '(')
	depth++;
      else if (*scan == ')' && depth > 0)
	depth--;
    }

  return 0;
}


/* Parse a string that specifies a line number.
   Pass the address of a char * variable; that variable will be
   advanced over the characters actually parsed.

   The string can be:

   LINENUM -- that line number in current file.  PC returned is 0.
   FILE:LINENUM -- that line in that file.  PC returned is 0.
   FUNCTION -- line number of openbrace of that function.
   PC returned is the start of the function.
   VARIABLE -- line number of definition of that variable.
   PC returned is 0.
   FILE:FUNCTION -- likewise, but prefer functions in that file.
   *EXPR -- line in which address EXPR appears.

   This may all be followed by an "if EXPR", which we ignore.

   FUNCTION may be an undebuggable function found in minimal symbol table.

   If the argument FUNFIRSTLINE is nonzero, we want the first line
   of real code inside a function when a function is specified, and it is
   not OK to specify a variable or type to get its line number.

   DEFAULT_SYMTAB specifies the file to use if none is specified.
   It defaults to current_source_symtab.
   DEFAULT_LINE specifies the line number to use for relative
   line numbers (that start with signs).  Defaults to current_source_line.
   If CANONICAL is non-NULL, store an array of strings containing the canonical
   line specs there if necessary. Currently overloaded member functions and
   line numbers or static functions without a filename yield a canonical
   line spec. The array and the line spec strings are allocated on the heap,
   it is the callers responsibility to free them.

   Note that it is possible to return zero for the symtab
   if no file is validly specified.  Callers must check that.
   Also, the line number returned may be invalid.  */

/* We allow single quotes in various places.  This is a hideous
   kludge, which exists because the completer can't yet deal with the
   lack of single quotes.  FIXME: write a linespec_completer which we
   can use as appropriate instead of make_symbol_completion_list.  */

struct symtabs_and_lines
decode_line_1 (char **argptr, int funfirstline, struct symtab *default_symtab,
	       int default_line, char ***canonical)
{
  struct symtabs_and_lines values;
#ifdef HPPA_COMPILER_BUG
  /* FIXME: The native HP 9000/700 compiler has a bug which appears
     when optimizing this file with target i960-vxworks.  I haven't
     been able to construct a simple test case.  The problem is that
     in the second call to SKIP_PROLOGUE below, the compiler somehow
     does not realize that the statement val = find_pc_line (...) will
     change the values of the fields of val.  It extracts the elements
     into registers at the top of the block, and does not update the
     registers after the call to find_pc_line.  You can check this by
     inserting a printf at the end of find_pc_line to show what values
     it is returning for val.pc and val.end and another printf after
     the call to see what values the function actually got (remember,
     this is compiling with cc -O, with this patch removed).  You can
     also examine the assembly listing: search for the second call to
     skip_prologue; the LDO statement before the next call to
     find_pc_line loads the address of the structure which
     find_pc_line will return; if there is a LDW just before the LDO,
     which fetches an element of the structure, then the compiler
     still has the bug.

     Setting val to volatile avoids the problem.  We must undef
     volatile, because the HPPA native compiler does not define
     __STDC__, although it does understand volatile, and so volatile
     will have been defined away in defs.h.  */
#undef volatile
  volatile struct symtab_and_line val;
#define volatile		/*nothing */
#else
  struct symtab_and_line val;
#endif
  register char *p, *p1;
  char *q, *pp, *ii, *p2;
#if 0
  char *q1;
#endif
  register struct symtab *s;

  register struct symbol *sym;
  /* The symtab that SYM was found in.  */
  struct symtab *sym_symtab;

  register CORE_ADDR pc;
  register struct minimal_symbol *msymbol;
  char *copy;
  struct symbol *sym_class;
  int i1;
  int is_quoted;
  int is_quote_enclosed;
  int has_parens;
  int has_if = 0;
  int has_comma = 0;
  struct symbol **sym_arr;
  struct type *t;
  char *saved_arg = *argptr;
  extern char *gdb_completer_quote_characters;

  INIT_SAL (&val);		/* initialize to zeroes */

  /* Defaults have defaults.  */

  if (default_symtab == 0)
    {
      default_symtab = current_source_symtab;
      default_line = current_source_line;
    }

  /* See if arg is *PC */

  if (**argptr == '*')
    {
      (*argptr)++;
      pc = parse_and_eval_address_1 (argptr);

      values.sals = (struct symtab_and_line *)
	xmalloc (sizeof (struct symtab_and_line));

      values.nelts = 1;
      values.sals[0] = find_pc_line (pc, 0);
      values.sals[0].pc = pc;
      values.sals[0].section = find_pc_overlay (pc);

      return values;
    }

  /* 'has_if' is for the syntax:
   *     (gdb) break foo if (a==b)
   */
  if ((ii = strstr (*argptr, " if ")) != NULL ||
      (ii = strstr (*argptr, "\tif ")) != NULL ||
      (ii = strstr (*argptr, " if\t")) != NULL ||
      (ii = strstr (*argptr, "\tif\t")) != NULL ||
      (ii = strstr (*argptr, " if(")) != NULL ||
      (ii = strstr (*argptr, "\tif( ")) != NULL)
    has_if = 1;
  /* Temporarily zap out "if (condition)" to not
   * confuse the parenthesis-checking code below.
   * This is undone below. Do not change ii!!
   */
  if (has_if)
    {
      *ii = '\0';
    }

  /* Set various flags.
   * 'has_parens' is important for overload checking, where
   * we allow things like: 
   *     (gdb) break c::f(int)
   */

  /* Maybe arg is FILE : LINENUM or FILE : FUNCTION */

  is_quoted = (**argptr
	       && strchr (gdb_completer_quote_characters, **argptr) != NULL);

  has_parens = ((pp = strchr (*argptr, '(')) != NULL
		&& (pp = strrchr (pp, ')')) != NULL);

  /* Now that we're safely past the has_parens check,
   * put back " if (condition)" so outer layers can see it 
   */
  if (has_if)
    *ii = ' ';

  /* Maybe we were called with a line range FILENAME:LINENUM,FILENAME:LINENUM
     and we must isolate the first half.  Outer layers will call again later
     for the second half.

     Don't count commas that appear in argument lists of overloaded
     functions, or in quoted strings.  It's stupid to go to this much
     trouble when the rest of the function is such an obvious roach hotel.  */
  ii = find_toplevel_char (*argptr, ',');
  has_comma = (ii != 0);

  /* Temporarily zap out second half to not
   * confuse the code below.
   * This is undone below. Do not change ii!!
   */
  if (has_comma)
    {
      *ii = '\0';
    }

  /* Maybe arg is FILE : LINENUM or FILE : FUNCTION */
  /* May also be CLASS::MEMBER, or NAMESPACE::NAME */
  /* Look for ':', but ignore inside of <> */

  s = NULL;
  p = *argptr;
  if (p[0] == '"')
    {
      is_quote_enclosed = 1;
      p++;
    }
  else
    is_quote_enclosed = 0;
  for (; *p; p++)
    {
      if (p[0] == '<')
	{
	  char *temp_end = find_template_name_end (p);
	  if (!temp_end)
	    error ("malformed template specification in command");
	  p = temp_end;
	}
      /* Check for the end of the first half of the linespec.  End of line,
         a tab, a double colon or the last single colon, or a space.  But
         if enclosed in double quotes we do not break on enclosed spaces */
      if (!*p
	  || p[0] == '\t'
	  || ((p[0] == ':')
	      && ((p[1] == ':') || (strchr (p + 1, ':') == NULL)))
	  || ((p[0] == ' ') && !is_quote_enclosed))
	break;
      if (p[0] == '.' && strchr (p, ':') == NULL)	/* Java qualified method. */
	{
	  /* Find the *last* '.', since the others are package qualifiers. */
	  for (p1 = p; *p1; p1++)
	    {
	      if (*p1 == '.')
		p = p1;
	    }
	  break;
	}
    }
  while (p[0] == ' ' || p[0] == '\t')
    p++;

  /* if the closing double quote was left at the end, remove it */
  if (is_quote_enclosed)
    {
      char *closing_quote = strchr (p, '"');
      if (closing_quote && closing_quote[1] == '\0')
	*closing_quote = '\0';
    }

  /* Now that we've safely parsed the first half,
   * put back ',' so outer layers can see it 
   */
  if (has_comma)
    *ii = ',';

  if ((p[0] == ':' || p[0] == '.') && !has_parens)
    {
      /*  C++ */
      /*  ... or Java */
      if (is_quoted)
	*argptr = *argptr + 1;
      if (p[0] == '.' || p[1] == ':')
	{
	  char *saved_arg2 = *argptr;
	  char *temp_end;
	  /* First check for "global" namespace specification,
	     of the form "::foo". If found, skip over the colons
	     and jump to normal symbol processing */
	  if (p[0] == ':' 
	      && ((*argptr == p) || (p[-1] == ' ') || (p[-1] == '\t')))
	    saved_arg2 += 2;

	  /* We have what looks like a class or namespace
	     scope specification (A::B), possibly with many
	     levels of namespaces or classes (A::B::C::D).

	     Some versions of the HP ANSI C++ compiler (as also possibly
	     other compilers) generate class/function/member names with
	     embedded double-colons if they are inside namespaces. To
	     handle this, we loop a few times, considering larger and
	     larger prefixes of the string as though they were single
	     symbols.  So, if the initially supplied string is
	     A::B::C::D::foo, we have to look up "A", then "A::B",
	     then "A::B::C", then "A::B::C::D", and finally
	     "A::B::C::D::foo" as single, monolithic symbols, because
	     A, B, C or D may be namespaces.

	     Note that namespaces can nest only inside other
	     namespaces, and not inside classes.  So we need only
	     consider *prefixes* of the string; there is no need to look up
	     "B::C" separately as a symbol in the previous example. */

	  p2 = p;		/* save for restart */
	  while (1)
	    {
	      /* Extract the class name.  */
	      p1 = p;
	      while (p != *argptr && p[-1] == ' ')
		--p;
	      copy = (char *) alloca (p - *argptr + 1);
	      memcpy (copy, *argptr, p - *argptr);
	      copy[p - *argptr] = 0;

	      /* Discard the class name from the arg.  */
	      p = p1 + (p1[0] == ':' ? 2 : 1);
	      while (*p == ' ' || *p == '\t')
		p++;
	      *argptr = p;

	      sym_class = lookup_symbol (copy, 0, STRUCT_NAMESPACE, 0,
					 (struct symtab **) NULL);

	      if (sym_class &&
		  (t = check_typedef (SYMBOL_TYPE (sym_class)),
		   (TYPE_CODE (t) == TYPE_CODE_STRUCT
		    || TYPE_CODE (t) == TYPE_CODE_UNION)))
		{
		  /* Arg token is not digits => try it as a function name
		     Find the next token(everything up to end or next blank). */
		  if (**argptr
		      && strchr (gdb_completer_quote_characters, **argptr) != NULL)
		    {
		      p = skip_quoted (*argptr);
		      *argptr = *argptr + 1;
		    }
		  else
		    {
		      p = *argptr;
		      while (*p && *p != ' ' && *p != '\t' && *p != ',' && *p != ':')
			p++;
		    }
/*
   q = operator_chars (*argptr, &q1);
   if (q1 - q)
   {
   char *opname;
   char *tmp = alloca (q1 - q + 1);
   memcpy (tmp, q, q1 - q);
   tmp[q1 - q] = '\0';
   opname = cplus_mangle_opname (tmp, DMGL_ANSI);
   if (opname == NULL)
   {
   error_begin ();
   printf_filtered ("no mangling for \"%s\"\n", tmp);
   cplusplus_hint (saved_arg);
   return_to_top_level (RETURN_ERROR);
   }
   copy = (char*) alloca (3 + strlen(opname));
   sprintf (copy, "__%s", opname);
   p = q1;
   }
   else
 */
		  {
		    copy = (char *) alloca (p - *argptr + 1);
		    memcpy (copy, *argptr, p - *argptr);
		    copy[p - *argptr] = '\0';
		    if (p != *argptr
			&& copy[p - *argptr - 1]
			&& strchr (gdb_completer_quote_characters,
				   copy[p - *argptr - 1]) != NULL)
		      copy[p - *argptr - 1] = '\0';
		  }

		  /* no line number may be specified */
		  while (*p == ' ' || *p == '\t')
		    p++;
		  *argptr = p;

		  sym = 0;
		  i1 = 0;	/*  counter for the symbol array */
		  sym_arr = (struct symbol **) alloca (total_number_of_methods (t)
						* sizeof (struct symbol *));

		  if (destructor_name_p (copy, t))
		    {
		      /* Destructors are a special case.  */
		      int m_index, f_index;

		      if (get_destructor_fn_field (t, &m_index, &f_index))
			{
			  struct fn_field *f = TYPE_FN_FIELDLIST1 (t, m_index);

			  sym_arr[i1] =
			    lookup_symbol (TYPE_FN_FIELD_PHYSNAME (f, f_index),
					   NULL, VAR_NAMESPACE, (int *) NULL,
					   (struct symtab **) NULL);
			  if (sym_arr[i1])
			    i1++;
			}
		    }
		  else
		    i1 = find_methods (t, copy, sym_arr);
		  if (i1 == 1)
		    {
		      /* There is exactly one field with that name.  */
		      sym = sym_arr[0];

		      if (sym && SYMBOL_CLASS (sym) == LOC_BLOCK)
			{
			  values.sals = (struct symtab_and_line *)
			    xmalloc (sizeof (struct symtab_and_line));
			  values.nelts = 1;
			  values.sals[0] = find_function_start_sal (sym,
							      funfirstline);
			}
		      else
			{
			  values.nelts = 0;
			}
		      return values;
		    }
		  if (i1 > 0)
		    {
		      /* There is more than one field with that name
		         (overloaded).  Ask the user which one to use.  */
		      return decode_line_2 (sym_arr, i1, funfirstline, canonical);
		    }
		  else
		    {
		      char *tmp;

		      if (OPNAME_PREFIX_P (copy))
			{
			  tmp = (char *) alloca (strlen (copy + 3) + 9);
			  strcpy (tmp, "operator ");
			  strcat (tmp, copy + 3);
			}
		      else
			tmp = copy;
		      error_begin ();
		      if (tmp[0] == '~')
			printf_filtered
			  ("the class `%s' does not have destructor defined\n",
			   SYMBOL_SOURCE_NAME (sym_class));
		      else
			printf_filtered
			  ("the class %s does not have any method named %s\n",
			   SYMBOL_SOURCE_NAME (sym_class), tmp);
		      cplusplus_hint (saved_arg);
		      return_to_top_level (RETURN_ERROR);
		    }
		}

	      /* Move pointer up to next possible class/namespace token */
	      p = p2 + 1;	/* restart with old value +1 */
	      /* Move pointer ahead to next double-colon */
	      while (*p && (p[0] != ' ') && (p[0] != '\t') && (p[0] != '\''))
		{
		  if (p[0] == '<')
		    {
		      temp_end = find_template_name_end (p);
		      if (!temp_end)
			error ("malformed template specification in command");
		      p = temp_end;
		    }
		  else if ((p[0] == ':') && (p[1] == ':'))
		    break;	/* found double-colon */
		  else
		    p++;
		}

	      if (*p != ':')
		break;		/* out of the while (1) */

	      p2 = p;		/* save restart for next time around */
	      *argptr = saved_arg2;	/* restore argptr */
	    }			/* while (1) */

	  /* Last chance attempt -- check entire name as a symbol */
	  /* Use "copy" in preparation for jumping out of this block,
	     to be consistent with usage following the jump target */
	  copy = (char *) alloca (p - saved_arg2 + 1);
	  memcpy (copy, saved_arg2, p - saved_arg2);
	  /* Note: if is_quoted should be true, we snuff out quote here anyway */
	  copy[p - saved_arg2] = '\000';
	  /* Set argptr to skip over the name */
	  *argptr = (*p == '\'') ? p + 1 : p;
	  /* Look up entire name */
	  sym = lookup_symbol (copy, 0, VAR_NAMESPACE, 0, &sym_symtab);
	  s = (struct symtab *) 0;
	  /* Prepare to jump: restore the " if (condition)" so outer layers see it */
	  /* Symbol was found --> jump to normal symbol processing.
	     Code following "symbol_found" expects "copy" to have the
	     symbol name, "sym" to have the symbol pointer, "s" to be
	     a specified file's symtab, and sym_symtab to be the symbol's
	     symtab. */
	  /* By jumping there we avoid falling through the FILE:LINE and
	     FILE:FUNC processing stuff below */
	  if (sym)
	    goto symbol_found;

	  /* Couldn't find any interpretation as classes/namespaces, so give up */
	  error_begin ();
	  /* The quotes are important if copy is empty.  */
	  printf_filtered
	    ("Can't find member of namespace, class, struct, or union named \"%s\"\n", copy);
	  cplusplus_hint (saved_arg);
	  return_to_top_level (RETURN_ERROR);
	}
      /*  end of C++  */


      /* Extract the file name.  */
      p1 = p;
      while (p != *argptr && p[-1] == ' ')
	--p;
      if ((*p == '"') && is_quote_enclosed)
	--p;
      copy = (char *) alloca (p - *argptr + 1);
      if ((**argptr == '"') && is_quote_enclosed)
	{
	  memcpy (copy, *argptr + 1, p - *argptr - 1);
	  /* It may have the ending quote right after the file name */
	  if (copy[p - *argptr - 2] == '"')
	    copy[p - *argptr - 2] = 0;
	  else
	    copy[p - *argptr - 1] = 0;
	}
      else
	{
	  memcpy (copy, *argptr, p - *argptr);
	  copy[p - *argptr] = 0;
	}

      /* Find that file's data.  */
      s = lookup_symtab (copy);
      if (s == 0)
	{
	  if (!have_full_symbols () && !have_partial_symbols ())
	    error (no_symtab_msg);
	  error ("No source file named %s.", copy);
	}

      /* Discard the file name from the arg.  */
      p = p1 + 1;
      while (*p == ' ' || *p == '\t')
	p++;
      *argptr = p;
    }
#if 0
  /* No one really seems to know why this was added. It certainly
     breaks the command line, though, whenever the passed
     name is of the form ClassName::Method. This bit of code
     singles out the class name, and if funfirstline is set (for
     example, you are setting a breakpoint at this function),
     you get an error. This did not occur with earlier
     verions, so I am ifdef'ing this out. 3/29/99 */
  else
    {
      /* Check if what we have till now is a symbol name */

      /* We may be looking at a template instantiation such
         as "foo<int>".  Check here whether we know about it,
         instead of falling through to the code below which
         handles ordinary function names, because that code
         doesn't like seeing '<' and '>' in a name -- the
         skip_quoted call doesn't go past them.  So see if we
         can figure it out right now. */

      copy = (char *) alloca (p - *argptr + 1);
      memcpy (copy, *argptr, p - *argptr);
      copy[p - *argptr] = '\000';
      sym = lookup_symbol (copy, 0, VAR_NAMESPACE, 0, &sym_symtab);
      if (sym)
	{
	  /* Yes, we have a symbol; jump to symbol processing */
	  /* Code after symbol_found expects S, SYM_SYMTAB, SYM, 
	     and COPY to be set correctly */
	  *argptr = (*p == '\'') ? p + 1 : p;
	  s = (struct symtab *) 0;
	  goto symbol_found;
	}
      /* Otherwise fall out from here and go to file/line spec
         processing, etc. */
    }
#endif

  /* S is specified file's symtab, or 0 if no file specified.
     arg no longer contains the file name.  */

  /* Check whether arg is all digits (and sign) */

  q = *argptr;
  if (*q == '-' || *q == '+')
    q++;
  while (*q >= '0' && *q <= '9')
    q++;

  if (q != *argptr && (*q == 0 || *q == ' ' || *q == '\t' || *q == ','))
    {
      /* We found a token consisting of all digits -- at least one digit.  */
      enum sign
	{
	  none, plus, minus
	}
      sign = none;

      /* We might need a canonical line spec if no file was specified.  */
      int need_canonical = (s == 0) ? 1 : 0;

      /* This is where we need to make sure that we have good defaults.
         We must guarantee that this section of code is never executed
         when we are called with just a function name, since
         select_source_symtab calls us with such an argument  */

      if (s == 0 && default_symtab == 0)
	{
	  select_source_symtab (0);
	  default_symtab = current_source_symtab;
	  default_line = current_source_line;
	}

      if (**argptr == '+')
	sign = plus, (*argptr)++;
      else if (**argptr == '-')
	sign = minus, (*argptr)++;
      val.line = atoi (*argptr);
      switch (sign)
	{
	case plus:
	  if (q == *argptr)
	    val.line = 5;
	  if (s == 0)
	    val.line = default_line + val.line;
	  break;
	case minus:
	  if (q == *argptr)
	    val.line = 15;
	  if (s == 0)
	    val.line = default_line - val.line;
	  else
	    val.line = 1;
	  break;
	case none:
	  break;		/* No need to adjust val.line.  */
	}

      while (*q == ' ' || *q == '\t')
	q++;
      *argptr = q;
      if (s == 0)
	s = default_symtab;

      /* It is possible that this source file has more than one symtab, 
         and that the new line number specification has moved us from the
         default (in s) to a new one.  */
      val.symtab = find_line_symtab (s, val.line, NULL, NULL);
      if (val.symtab == 0)
	val.symtab = s;

      val.pc = 0;
      values.sals = (struct symtab_and_line *)
	xmalloc (sizeof (struct symtab_and_line));
      values.sals[0] = val;
      values.nelts = 1;
      if (need_canonical)
	build_canonical_line_spec (values.sals, NULL, canonical);
      return values;
    }

  /* Arg token is not digits => try it as a variable name
     Find the next token (everything up to end or next whitespace).  */

  if (**argptr == '$')		/* May be a convenience variable */
    p = skip_quoted (*argptr + (((*argptr)[1] == '$') ? 2 : 1));	/* One or two $ chars possible */
  else if (is_quoted)
    {
      p = skip_quoted (*argptr);
      if (p[-1] != '\'')
	error ("Unmatched single quote.");
    }
  else if (has_parens)
    {
      p = pp + 1;
    }
  else
    {
      p = skip_quoted (*argptr);
    }

  if (is_quote_enclosed && **argptr == '"')
    (*argptr)++;

  copy = (char *) alloca (p - *argptr + 1);
  memcpy (copy, *argptr, p - *argptr);
  copy[p - *argptr] = '\0';
  if (p != *argptr
      && copy[0]
      && copy[0] == copy[p - *argptr - 1]
      && strchr (gdb_completer_quote_characters, copy[0]) != NULL)
    {
      copy[p - *argptr - 1] = '\0';
      copy++;
    }
  while (*p == ' ' || *p == '\t')
    p++;
  *argptr = p;

  /* If it starts with $: may be a legitimate variable or routine name
     (e.g. HP-UX millicode routines such as $$dyncall), or it may
     be history value, or it may be a convenience variable */

  if (*copy == '$')
    {
      value_ptr valx;
      int index = 0;
      int need_canonical = 0;

      p = (copy[1] == '$') ? copy + 2 : copy + 1;
      while (*p >= '0' && *p <= '9')
	p++;
      if (!*p)			/* reached end of token without hitting non-digit */
	{
	  /* We have a value history reference */
	  sscanf ((copy[1] == '$') ? copy + 2 : copy + 1, "%d", &index);
	  valx = access_value_history ((copy[1] == '$') ? -index : index);
	  if (TYPE_CODE (VALUE_TYPE (valx)) != TYPE_CODE_INT)
	    error ("History values used in line specs must have integer values.");
	}
      else
	{
	  /* Not all digits -- may be user variable/function or a
	     convenience variable */

	  /* Look up entire name as a symbol first */
	  sym = lookup_symbol (copy, 0, VAR_NAMESPACE, 0, &sym_symtab);
	  s = (struct symtab *) 0;
	  need_canonical = 1;
	  /* Symbol was found --> jump to normal symbol processing.
	     Code following "symbol_found" expects "copy" to have the
	     symbol name, "sym" to have the symbol pointer, "s" to be
	     a specified file's symtab, and sym_symtab to be the symbol's
	     symtab. */
	  if (sym)
	    goto symbol_found;

	  /* If symbol was not found, look in minimal symbol tables */
	  msymbol = lookup_minimal_symbol (copy, 0, 0);
	  /* Min symbol was found --> jump to minsym processing. */
	  if (msymbol)
	    goto minimal_symbol_found;

	  /* Not a user variable or function -- must be convenience variable */
	  need_canonical = (s == 0) ? 1 : 0;
	  valx = value_of_internalvar (lookup_internalvar (copy + 1));
	  if (TYPE_CODE (VALUE_TYPE (valx)) != TYPE_CODE_INT)
	    error ("Convenience variables used in line specs must have integer values.");
	}

      /* Either history value or convenience value from above, in valx */
      val.symtab = s ? s : default_symtab;
      val.line = value_as_long (valx);
      val.pc = 0;

      values.sals = (struct symtab_and_line *) xmalloc (sizeof val);
      values.sals[0] = val;
      values.nelts = 1;

      if (need_canonical)
	build_canonical_line_spec (values.sals, NULL, canonical);

      return values;
    }


  /* Look up that token as a variable.
     If file specified, use that file's per-file block to start with.  */

  sym = lookup_symbol (copy,
		       (s ? BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), STATIC_BLOCK)
			: get_selected_block ()),
		       VAR_NAMESPACE, 0, &sym_symtab);

symbol_found:			/* We also jump here from inside the C++ class/namespace 
				   code on finding a symbol of the form "A::B::C" */

  if (sym != NULL)
    {
      if (SYMBOL_CLASS (sym) == LOC_BLOCK)
	{
	  /* Arg is the name of a function */
	  values.sals = (struct symtab_and_line *)
	    xmalloc (sizeof (struct symtab_and_line));
	  values.sals[0] = find_function_start_sal (sym, funfirstline);
	  values.nelts = 1;

	  /* Don't use the SYMBOL_LINE; if used at all it points to
	     the line containing the parameters or thereabouts, not
	     the first line of code.  */

	  /* We might need a canonical line spec if it is a static
	     function.  */
	  if (s == 0)
	    {
	      struct blockvector *bv = BLOCKVECTOR (sym_symtab);
	      struct block *b = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
	      if (lookup_block_symbol (b, copy, VAR_NAMESPACE) != NULL)
		build_canonical_line_spec (values.sals, copy, canonical);
	    }
	  return values;
	}
      else
	{
	  if (funfirstline)
	    error ("\"%s\" is not a function", copy);
	  else if (SYMBOL_LINE (sym) != 0)
	    {
	      /* We know its line number.  */
	      values.sals = (struct symtab_and_line *)
		xmalloc (sizeof (struct symtab_and_line));
	      values.nelts = 1;
	      memset (&values.sals[0], 0, sizeof (values.sals[0]));
	      values.sals[0].symtab = sym_symtab;
	      values.sals[0].line = SYMBOL_LINE (sym);
	      return values;
	    }
	  else
	    /* This can happen if it is compiled with a compiler which doesn't
	       put out line numbers for variables.  */
	    /* FIXME: Shouldn't we just set .line and .symtab to zero
	       and return?  For example, "info line foo" could print
	       the address.  */
	    error ("Line number not known for symbol \"%s\"", copy);
	}
    }

  msymbol = lookup_minimal_symbol (copy, NULL, NULL);

minimal_symbol_found:		/* We also jump here from the case for variables
				   that begin with '$' */

  if (msymbol != NULL)
    {
      values.sals = (struct symtab_and_line *)
	xmalloc (sizeof (struct symtab_and_line));
      values.sals[0] = find_pc_sect_line (SYMBOL_VALUE_ADDRESS (msymbol),
					  (struct sec *) 0, 0);
      values.sals[0].section = SYMBOL_BFD_SECTION (msymbol);
      if (funfirstline)
	{
	  values.sals[0].pc += FUNCTION_START_OFFSET;
	  values.sals[0].pc = SKIP_PROLOGUE (values.sals[0].pc);
	}
      values.nelts = 1;
      return values;
    }

  if (!have_full_symbols () &&
      !have_partial_symbols () && !have_minimal_symbols ())
    error (no_symtab_msg);

  error ("Function \"%s\" not defined.", copy);
  return values;		/* for lint */
}

struct symtabs_and_lines
decode_line_spec (char *string, int funfirstline)
{
  struct symtabs_and_lines sals;
  if (string == 0)
    error ("Empty line specification.");
  sals = decode_line_1 (&string, funfirstline,
			current_source_symtab, current_source_line,
			(char ***) NULL);
  if (*string)
    error ("Junk at end of line specification: %s", string);
  return sals;
}

/* Given a list of NELTS symbols in SYM_ARR, return a list of lines to
   operate on (ask user if necessary).
   If CANONICAL is non-NULL return a corresponding array of mangled names
   as canonical line specs there.  */

static struct symtabs_and_lines
decode_line_2 (struct symbol *sym_arr[], int nelts, int funfirstline,
	       char ***canonical)
{
  struct symtabs_and_lines values, return_values;
  char *args, *arg1;
  int i;
  char *prompt;
  char *symname;
  struct cleanup *old_chain;
  char **canonical_arr = (char **) NULL;

  values.sals = (struct symtab_and_line *)
    alloca (nelts * sizeof (struct symtab_and_line));
  return_values.sals = (struct symtab_and_line *)
    xmalloc (nelts * sizeof (struct symtab_and_line));
  old_chain = make_cleanup (free, return_values.sals);

  if (canonical)
    {
      canonical_arr = (char **) xmalloc (nelts * sizeof (char *));
      make_cleanup (free, canonical_arr);
      memset (canonical_arr, 0, nelts * sizeof (char *));
      *canonical = canonical_arr;
    }

  i = 0;
  printf_unfiltered ("[0] cancel\n[1] all\n");
  while (i < nelts)
    {
      INIT_SAL (&return_values.sals[i]);	/* initialize to zeroes */
      INIT_SAL (&values.sals[i]);
      if (sym_arr[i] && SYMBOL_CLASS (sym_arr[i]) == LOC_BLOCK)
	{
	  values.sals[i] = find_function_start_sal (sym_arr[i], funfirstline);
	  printf_unfiltered ("[%d] %s at %s:%d\n",
			     (i + 2),
			     SYMBOL_SOURCE_NAME (sym_arr[i]),
			     values.sals[i].symtab->filename,
			     values.sals[i].line);
	}
      else
	printf_unfiltered ("?HERE\n");
      i++;
    }

  if ((prompt = getenv ("PS2")) == NULL)
    {
      prompt = "> ";
    }
  args = command_line_input (prompt, 0, "overload-choice");

  if (args == 0 || *args == 0)
    error_no_arg ("one or more choice numbers");

  i = 0;
  while (*args)
    {
      int num;

      arg1 = args;
      while (*arg1 >= '0' && *arg1 <= '9')
	arg1++;
      if (*arg1 && *arg1 != ' ' && *arg1 != '\t')
	error ("Arguments must be choice numbers.");

      num = atoi (args);

      if (num == 0)
	error ("canceled");
      else if (num == 1)
	{
	  if (canonical_arr)
	    {
	      for (i = 0; i < nelts; i++)
		{
		  if (canonical_arr[i] == NULL)
		    {
		      symname = SYMBOL_NAME (sym_arr[i]);
		      canonical_arr[i] = savestring (symname, strlen (symname));
		    }
		}
	    }
	  memcpy (return_values.sals, values.sals,
		  (nelts * sizeof (struct symtab_and_line)));
	  return_values.nelts = nelts;
	  discard_cleanups (old_chain);
	  return return_values;
	}

      if (num >= nelts + 2)
	{
	  printf_unfiltered ("No choice number %d.\n", num);
	}
      else
	{
	  num -= 2;
	  if (values.sals[num].pc)
	    {
	      if (canonical_arr)
		{
		  symname = SYMBOL_NAME (sym_arr[num]);
		  make_cleanup (free, symname);
		  canonical_arr[i] = savestring (symname, strlen (symname));
		}
	      return_values.sals[i++] = values.sals[num];
	      values.sals[num].pc = 0;
	    }
	  else
	    {
	      printf_unfiltered ("duplicate request for %d ignored.\n", num);
	    }
	}

      args = arg1;
      while (*args == ' ' || *args == '\t')
	args++;
    }
  return_values.nelts = i;
  discard_cleanups (old_chain);
  return return_values;
}
d3338 13
@


1.20
log
@* gdbarch.sh, hp-psymtab-read.c, hpread.c, m3-nat.c, mcore-tdep.c,
mips-tdep.c, monitor.c, regcache.c, remote-es.c, ser-unix.c,
somread.c, tracepoint.c: Fix spelling errors in comments.
* gdbarch.c: Regenerate.

* gnu-nat.c (S_exception_raise_request): Fix typos and spelling
errors in strings.
* m3-nat.c (intercept_exec_calls, mach_thread_parse_id): Likewise.
* mcore-tdep.c (mcore_analyze_prologue): Likewise.
* mips-tdep.c (mips16_next_pc, _initialize_mips_tdep): Likewise.
* remote-e7000.c (e7000_start_remote): Likewise.
* remote-rdp.c (handle_swi): Likewise.
* remote-vx.c (vx_load_command): Likewise.
* sh-tdep.c (sh_do_pseudo_register): Likewise.
* sol-thread.c (td_err_string): Likewise.
* symtab.c (decode_line_2): Likewise.
-------------------------------------------------------------------
@
text
@a3537 1

@


1.19
log
@Protoization.
@
text
@d3331 1
a3331 1
	error ("cancelled");
@


1.18
log
@
Corrected spelling errors in comments.
gdbarch.{c,sh} removed a word from a comment.
@
text
@d3263 2
a3264 5
decode_line_2 (sym_arr, nelts, funfirstline, canonical)
     struct symbol *sym_arr[];
     int nelts;
     int funfirstline;
     char ***canonical;
d3479 1
a3479 4
file_matches (file, files, nfiles)
     char *file;
     char *files[];
     int nfiles;
d3536 2
a3537 6
search_symbols (regexp, kind, nfiles, files, matches)
     char *regexp;
     namespace_enum kind;
     int nfiles;
     char *files[];
     struct symbol_search **matches;
@


1.17
log
@2000-10-12  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	From Daniel Berlin <dberlin@@redhat.com> :

	* symtab.h (SYMBOL_INIT_DEMANGLED_NAME): Initialize the symbol
 	language to auto instead of unknown, so it will try to demangle
 	the symbol.
	* symtab.h (OPNAME_PREFIX_P): Change operator prefix to correct value.
	* symtab.c (gdb_mangle_name): Properly handle C++ operators.
@
text
@d1572 1
a1572 1
/* Find the source file and line number for a given PC value and section.
@


1.16
log
@2000-10-12  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	From Daniel Berlin <dberlin@@redhat.com> :

	* symtab.c (lookup_symbol_aux): New function. Renamed from
 	lookup_symbol. Move code to do demangling/case sensitivity to
 	lookup_symbol().
  	(lookup_symbol): Now wrapper for lookup_symbol_aux, so we can
 	perform case sensitivity/demangling without leaking memory.  Move
 	code to do demangling/case sensitivity from old_lookup_symbol to
 	here.
	(lookup_partial_symbol): Use SYMBOL_SOURCE_NAME instead of
 	SYMBOL_NAME.
	(lookup_block_symbol): Use SYMBOL_SOURCE_NAME instead of
 	SYMBOL_NAME. Don't do linear search in case of C++.

  	* symfile.c (compare_symbols): Use SYMBOL_SOURCE_NAME instead of
 	SYMBOL_NAME.
  	(compare_psymbols): Same here.
@
text
@d306 3
d344 1
a344 3
		      + strlen (buf) + len
		      + strlen (physname)
		      + 1);
a345 15
  /* Only needed for GNU-mangled names.  ANSI-mangled names
     work with the normal mechanisms.  */
  if (OPNAME_PREFIX_P (field_name))
    {
      const char *opname = cplus_mangle_opname (field_name + 3, 0);
      if (opname == NULL)
	error ("No mangling for \"%s\"", field_name);
      mangled_name_len += strlen (opname);
      mangled_name = (char *) xmalloc (mangled_name_len);

      strncpy (mangled_name, field_name, 3);
      mangled_name[3] = '\0';
      strcat (mangled_name, opname);
    }
  else
@


1.15
log
@
2000-09-04 Pierre Muller <muller@@ics.u-strasbg.fr>
	* c-typeprint.c (c_typedef_print): remove (replaced by typedef_print in
	typeprint.c).
	* typeprint.c (typedef_print): new function. (old c_typedef_print
	function with pascal language support added).
	* value.h (c_printdef_print): removed.
	(typedef_print): declare.
	* symtab.c (print_symbol_info): call to c_typedef_print replaced by
	call to typedef_print.
@
text
@d86 7
d582 1
a582 1
lookup_symbol (const char *name, register const struct block *block,
d586 4
a589 7
  register struct symbol *sym;
  register struct symtab *s = NULL;
  register struct partial_symtab *ps;
  struct blockvector *bv;
  register struct objfile *objfile = NULL;
  register struct block *b;
  register struct minimal_symbol *msymbol;
d601 1
a601 1
      name = copy;
d603 36
d1030 1
a1030 1
	  if (STRCMP (SYMBOL_NAME (*center), name) >= 0)
d1233 1
a1233 3
         do so, such as finding a C++ symbol during the binary search.
         Note that for C++ modules, ALL the symbols in a block should
         end up marked as C++ symbols. */
d1251 1
a1251 4
	  if (!do_linear_search
	      && (SYMBOL_LANGUAGE (sym) == language_cplus
		  || SYMBOL_LANGUAGE (sym) == language_java
	      ))
d1255 1
a1255 1
	  if (SYMBOL_NAME (sym)[0] < name[0])
d1259 1
a1259 1
	  else if (SYMBOL_NAME (sym)[0] > name[0])
d1263 1
a1263 1
	  else if (STRCMP (SYMBOL_NAME (sym), name) < 0)
d1285 2
a1286 13
	  inc = SYMBOL_NAME (sym)[0] - name[0];
	  if (inc == 0)
	    {
	      inc = STRCMP (SYMBOL_NAME (sym), name);
	    }
	  if (inc == 0 && SYMBOL_NAMESPACE (sym) == namespace)
	    {
	      return (sym);
	    }
	  if (inc > 0)
	    {
	      break;
	    }
@


1.14
log
@Fix core dump when executing ``b .'' command.
@
text
@d3833 1
a3833 1
    c_typedef_print (SYMBOL_TYPE (sym), sym, gdb_stdout);
@


1.13
log
@Fri Aug 25 12:11:21 2000  David Taylor  <taylor@@texas.cygnus.com>

	* symtab.c (search_symbols): Fix off by one error in index for
 	initializing variables ourtype, ourtype2, ourtype3, and ourtype4.
	(symtab_symbol_info): fix similar off by one error.

Fri Aug 25 12:03:15 2000  David Taylor  <taylor@@texas.cygnus.com>

	* gdbarch.sh (TARGET_ADDR_BIT): New macro for the number
	of bits in gdb's representation of a target address.
	* gdbarch.c, gdbarch.h: Regenerated.
	* gdbtypes.c (build_gdbtypes): Use TARGET_ADDR_BIT instead of
 	TARGET_PTR_BIT when initializing builtin_type_CORE_ADDR.
	* printcmd.c (print_address_numeric): Use TARGET_ADDR_BIT instead
 	of TARGET_PTR_BIT, because we're printing an address, not a pointer.
@
text
@d2645 2
a2646 1
	  if ((*argptr == p) || (p[-1] == ' ') || (p[-1] == '\t'))
@


1.12
log
@2000-08-10	Jimmy Guo	<guo@@cup.hp.com>

	* c-lang.c: Set case sensitivity on for c_language_defn,
	cplus_language_defn, and asm_language_defn.
	* ch-lang.c: Set case sensitivity on for chill_language_defn.
	* f-lang.c: Set case sensivitity off for f_language_defn.
	* jv-lang.c: Set case sensitivity on for java_language_defn.
	* language.h: Add enum case_mode, case_sensitivity.
	* language.c: Define case_mode, case_sensitivity.  Set case
	sensitivity on for unknown_language_defn, auto_language_defn,
	and local_language_defn.
	(show_case_command,set_case_command,set_case_str): New static func.
	(set_type_range_case): New static func, replaces set_type_range ().
	(set_language_command,set_type_command,set_range_command,set_language):
	Call set_type_range_case ().
	(language_info): Print case sensitivity setting.
	(_initialize_language): Add set/show commands for 'case-sensitive'.
	Set default case mode 'auto'.  Set default language 'auto'.
	* m2-lang.c: Set case sensitivity on for m2_language_defn.
	* p-lang.c: Set case sensitivity on for pascal_language_defn.
	* scm-lang.c: Set case sensitivity off for scm_language_defn.
	* symtab.c (lookup_symbol): Downcase symbol name if case sensivitity
	is off.
@
text
@d3576 4
a3579 4
  ourtype = types[(int) (kind - LABEL_NAMESPACE)];
  ourtype2 = types2[(int) (kind - LABEL_NAMESPACE)];
  ourtype3 = types3[(int) (kind - LABEL_NAMESPACE)];
  ourtype4 = types4[(int) (kind - LABEL_NAMESPACE)];
d3906 1
a3906 1
		   classnames[(int) (kind - LABEL_NAMESPACE - 1)], regexp);
@


1.11
log
@Fixup SYMBOL_SECTION for objfiles_relocate().
@
text
@d587 13
@


1.10
log
@Protoization.
@
text
@a83 4
static struct partial_symbol *fixup_psymbol_section (struct
						     partial_symbol *,
						     struct objfile *);

d519 4
a522 1
    ginfo->bfd_section = SYMBOL_BFD_SECTION (msym);
d539 1
a539 1
static struct partial_symbol *
@


1.9
log
@* symtab.c: Use paddr_nz() to print addresses.
@
text
@d131 1
a131 2
cplusplus_hint (name)
     char *name;
d144 1
a144 2
lookup_symtab_1 (name)
     char *name;
d207 1
a207 2
lookup_symtab (name)
     char *name;
d244 1
a244 2
lookup_partial_symtab (name)
     char *name;
d281 1
a281 3
gdb_mangle_name (type, method_id, signature_id)
     struct type *type;
     int method_id, signature_id;
d380 1
a380 3
find_pc_sect_psymtab (pc, section)
     CORE_ADDR pc;
     asection *section;
d427 1
a427 2
find_pc_psymtab (pc)
     CORE_ADDR pc;
d436 2
a437 4
find_pc_sect_psymbol (psymtab, pc, section)
     struct partial_symtab *psymtab;
     CORE_ADDR pc;
     asection *section;
d508 1
a508 3
find_pc_psymbol (psymtab, pc)
     struct partial_symtab *psymtab;
     CORE_ADDR pc;
d517 1
a517 3
fixup_section (ginfo, objfile)
     struct general_symbol_info *ginfo;
     struct objfile *objfile;
d527 1
a527 3
fixup_symbol_section (sym, objfile)
     struct symbol *sym;
     struct objfile *objfile;
d541 1
a541 3
fixup_psymbol_section (psym, objfile)
     struct partial_symbol *psym;
     struct objfile *objfile;
d576 3
a578 6
lookup_symbol (name, block, namespace, is_a_field_of_this, symtab)
     const char *name;
     register const struct block *block;
     const namespace_enum namespace;
     int *is_a_field_of_this;
     struct symtab **symtab;
d940 2
a941 5
lookup_partial_symbol (pst, name, global, namespace)
     struct partial_symtab *pst;
     const char *name;
     int global;
     namespace_enum namespace;
d1032 1
a1032 2
lookup_transparent_type (name)
     const char *name;
d1140 1
a1140 1
find_main_psymtab ()
d1167 2
a1168 4
lookup_block_symbol (block, name, namespace)
     register const struct block *block;
     const char *name;
     const namespace_enum namespace;
d1325 1
a1325 3
find_active_alias (sym, addr)
     struct symbol *sym;
     CORE_ADDR addr;
d1354 1
a1354 2
block_function (bl)
     struct block *bl;
d1366 1
a1366 3
find_pc_sect_symtab (pc, section)
     CORE_ADDR pc;
     asection *section;
d1454 1
a1454 2
find_pc_symtab (pc)
     CORE_ADDR pc;
d1470 1
a1470 4
find_addr_symbol (addr, symtabp, symaddrp)
     CORE_ADDR addr;
     struct symtab **symtabp;
     CORE_ADDR *symaddrp;
d1568 1
a1568 4
find_pc_sect_line (pc, section, notcurrent)
     CORE_ADDR pc;
     struct sec *section;
     int notcurrent;
d1791 1
a1791 3
find_pc_line (pc, notcurrent)
     CORE_ADDR pc;
     int notcurrent;
d1815 1
a1815 5
find_line_symtab (symtab, line, index, exact_match)
     struct symtab *symtab;
     int line;
     int *index;
     int *exact_match;
d1897 1
a1897 4
find_line_pc (symtab, line, pc)
     struct symtab *symtab;
     int line;
     CORE_ADDR *pc;
d1924 2
a1925 3
find_line_pc_range (sal, startptr, endptr)
     struct symtab_and_line sal;
     CORE_ADDR *startptr, *endptr;
d1963 2
a1964 4
find_line_common (l, lineno, exact_match)
     register struct linetable *l;
     register int lineno;
     int *exact_match;
d2007 1
a2007 3
find_pc_line_pc_range (pc, startptr, endptr)
     CORE_ADDR pc;
     CORE_ADDR *startptr, *endptr;
d2025 1
a2025 3
find_function_start_sal (sym, funfirstline)
     struct symbol *sym;
     int funfirstline;
d2075 1
a2075 3
operator_chars (p, end)
     char *p;
     char **end;
d2161 1
a2161 2
total_number_of_methods (type)
     struct type *type;
d2185 1
a2185 4
find_methods (t, name, sym_arr)
     struct type *t;
     char *name;
     struct symbol **sym_arr;
d2305 2
a2306 4
build_canonical_line_spec (sal, symname, canonical)
     struct symtab_and_line *sal;
     char *symname;
     char ***canonical;
d2415 2
a2416 6
decode_line_1 (argptr, funfirstline, default_symtab, default_line, canonical)
     char **argptr;
     int funfirstline;
     struct symtab *default_symtab;
     int default_line;
     char ***canonical;
d3221 1
a3221 3
decode_line_spec (string, funfirstline)
     char *string;
     int funfirstline;
d3370 1
a3370 3
output_source_filename (name, first)
     char *name;
     int *first;
d3424 1
a3424 3
sources_info (ignore, from_tty)
     char *ignore;
     int from_tty;
d3481 1
a3481 2
free_search_symbols (symbols)
     struct symbol_search *symbols;
d3804 2
a3805 6
print_symbol_info (kind, s, sym, block, last)
     namespace_enum kind;
     struct symtab *s;
     struct symbol *sym;
     int block;
     char *last;
d3863 1
a3863 2
print_msymbol_info (msymbol)
     struct minimal_symbol *msymbol;
d3876 1
a3876 4
symtab_symbol_info (regexp, kind, from_tty)
     char *regexp;
     namespace_enum kind;
     int from_tty;
d3924 1
a3924 3
variables_info (regexp, from_tty)
     char *regexp;
     int from_tty;
d3930 1
a3930 3
functions_info (regexp, from_tty)
     char *regexp;
     int from_tty;
d3937 1
a3937 3
types_info (regexp, from_tty)
     char *regexp;
     int from_tty;
d3945 1
a3945 2
methods_info (regexp)
     char *regexp;
d3954 1
a3954 3
rbreak_command_wrapper (regexp, from_tty)
     char *regexp;
     int from_tty;
d3960 1
a3960 3
rbreak_command (regexp, from_tty)
     char *regexp;
     int from_tty;
d4003 1
a4003 2
contained_in (a, b)
     struct block *a, *b;
d4036 2
a4037 6
completion_list_add_name (symname, sym_text, sym_text_len, text, word)
     char *symname;
     char *sym_text;
     int sym_text_len;
     char *text;
     char *word;
d4116 1
a4116 3
make_symbol_completion_list (text, word)
     char *text;
     char *word;
d4305 1
a4305 3
in_prologue (pc, func_start)
     CORE_ADDR pc;
     CORE_ADDR func_start;
d4383 1
a4383 3
overload_list_add_symbol (sym, oload_name)
     struct symbol *sym;
     char *oload_name;
d4432 1
a4432 2
make_symbol_overload_list (fsym)
     struct symbol *fsym;
d4552 1
a4552 1
_initialize_symtab ()
@


1.8
log
@PARAMS elimination.
@
text
@a1474 1
	/* FIXME-32x64: assumes pc fits in a long */
d1476 2
a1477 2
(Internal error: pc 0x%lx in read in psymtab, but not in symtab.)\n",
		 (unsigned long) pc);
@


1.7
log
@C++ improvements
@
text
@d80 3
a82 3
static struct partial_symbol *lookup_partial_symbol PARAMS
  ((struct partial_symtab *, const char *,
    int, namespace_enum));
@


1.6
log
@Purge symtab of make_cleanup_func.
Pass correct arg to make_cleanup_free_search_symbols.
@
text
@d957 1
a957 1

d968 1
d973 1
a973 1

a977 1

d981 1
a981 1

d999 1
a999 3
	      && (SYMBOL_LANGUAGE (*center) == language_cplus
		  || SYMBOL_LANGUAGE (*center) == language_java
	      ))
d1014 5
a1018 1
      while (STREQ (SYMBOL_NAME (*top), name))
d1022 1
a1022 1
	      return (*top);
d1032 1
a1032 1
    {
d4023 1
d4670 1
@


1.5
log
@PARAMS removal.
@
text
@d3567 13
d3812 1
a3812 2
		      old_chain = make_cleanup ((make_cleanup_func)
						free_search_symbols, sr);
d3856 1
a3856 2
			    old_chain = make_cleanup ((make_cleanup_func)
						  free_search_symbols, &sr);
d3971 1
a3971 1
  old_chain = make_cleanup ((make_cleanup_func) free_search_symbols, symbols);
d4059 1
a4059 1
  old_chain = make_cleanup ((make_cleanup_func) free_search_symbols, ss);
@


1.4
log
@Tue May  2 13:17:21 2000  Elena Zannoni  (ezannoni@@makita.cygnus.com)

        * symtab.c (in_prologue): From Jim Blandy. Rewrite, more
        intelligently, making sure we use the information from the
        symbol tables fully.
@
text
@d50 1
a50 1
extern char *find_template_name_end PARAMS ((char *));
d54 1
a54 1
static int find_methods PARAMS ((struct type *, char *, struct symbol **));
d56 1
a56 2
static void completion_list_add_name PARAMS ((char *, char *, int, char *,
					      char *));
d58 2
a59 2
static void build_canonical_line_spec PARAMS ((struct symtab_and_line *,
					       char *, char ***));
d61 2
a62 2
static struct symtabs_and_lines decode_line_2 PARAMS ((struct symbol *[],
						       int, int, char ***));
d64 1
a64 1
static void rbreak_command PARAMS ((char *, int));
d66 1
a66 1
static void types_info PARAMS ((char *, int));
d68 1
a68 1
static void functions_info PARAMS ((char *, int));
d70 1
a70 1
static void variables_info PARAMS ((char *, int));
d72 1
a72 1
static void sources_info PARAMS ((char *, int));
d74 1
a74 1
static void output_source_filename PARAMS ((char *, int *));
d76 1
a76 1
char *operator_chars PARAMS ((char *, char **));
d78 1
a78 1
static int find_line_common PARAMS ((struct linetable *, int, int *));
d84 3
a86 2
static struct partial_symbol *fixup_psymbol_section PARAMS ((struct
				       partial_symbol *, struct objfile *));
d88 1
a88 1
static struct symtab *lookup_symtab_1 PARAMS ((char *));
d90 1
a90 1
static void cplusplus_hint PARAMS ((char *));
d92 1
a92 2
static struct symbol *find_active_alias PARAMS ((struct symbol * sym,
						 CORE_ADDR addr));
d98 1
a98 2
static void fixup_section PARAMS ((struct general_symbol_info *,
				   struct objfile *));
d100 1
a100 1
static int file_matches PARAMS ((char *, char **, int));
d102 2
a103 3
static void print_symbol_info PARAMS ((namespace_enum,
				       struct symtab *, struct symbol *,
				       int, char *));
d105 1
a105 1
static void print_msymbol_info PARAMS ((struct minimal_symbol *));
d107 1
a107 1
static void symtab_symbol_info PARAMS ((char *, namespace_enum, int));
d109 1
a109 2
static void overload_list_add_symbol PARAMS ((struct symbol * sym,
					      char *oload_name));
d111 1
a111 1
void _initialize_symtab PARAMS ((void));
d1843 1
a1843 2
static struct symtab *find_line_symtab PARAMS ((struct symtab *, int,
						int *, int *));
d2075 1
a2075 1
find_function_start_sal PARAMS ((struct symbol * sym, int));
d2215 1
a2215 1
static int total_number_of_methods PARAMS ((struct type * type));
@


1.3
log
@2000-04-03  H.J. Lu  <hjl@@gnu.org>

	* gdb_regex.h: New. Include "regex.h" if USE_INCLUDED_REGEX
	is defined and <regex.h> otherwise.

        * irix5-nat.c: Include "gdb_regex.h" instead of "gnu-regex.h".
	* monitor.c: Likewise.
	* osfsolib.c: Likewise.
	* solib.c: Likewise.
	* source.c: Likewise.
	* symtab.c: Likewise.

	* Makefile.in (REGEX): Changed to @@REGEX@@.
	(REGEX_CFLAGS): New.
	(REGEX1): Removed.
	(ADD_DEPS): Use $(REGEX) instead of $(REGEX1).
	(INTERNAL_WARN_CFLAGS): Add $(REGEX_CFLAGS).

	* configure.in (--with-included-regex): New switch.
	(REGEX): New. Subsstitue @@REGEX@@ in Makefile.in.
	(REGEX_CFLAGS): New. Subsstitue @@REGEX_CFLAGS@@ in Makefile.in.
	* configure: Regenerated.
@
text
@d4405 26
a4430 2
  if (!find_pc_partial_function (pc, NULL, &func_addr, &func_end))
    goto nosyms;		/* Might be in prologue */
d4432 1
a4432 1
  sal = find_pc_line (func_addr, 0);
d4434 2
a4435 2
  if (sal.line == 0)
    goto nosyms;
d4437 3
a4439 21
  /* sal.end is the address of the first instruction past sal.line. */
  if (sal.end > func_addr
      && sal.end <= func_end)	/* Is prologue in function? */
    return pc < sal.end;	/* Yes, is pc in prologue? */

  /* The line after the prologue seems to be outside the function.  In this
     case, tell the caller to find the prologue the hard way.  */

  return 1;

/* Come here when symtabs don't contain line # info.  In this case, it is
   likely that the user has stepped into a library function w/o symbols, or
   is doing a stepi/nexti through code without symbols.  */

nosyms:

/* If func_start is zero (meaning unknown) then we don't know whether pc is
   in the prologue or not.  I.E. it might be. */

  if (!func_start)
    return 1;
d4441 16
a4456 3
/* We need to call the target-specific prologue skipping functions with the
   function's start address because PC may be pointing at an instruction that
   could be mistakenly considered part of the prologue.  */
d4458 2
a4459 1
  func_start = SKIP_PROLOGUE (func_start);
d4461 2
a4462 1
  return pc < func_start;
@


1.2
log
@	Clean up compiler warnings:
	* bcache.h, bcache.c, c-valprint.c, coffread.c, stabsread.c,
	stack.c, valprint.c: Change variables to unsigned.
	* bcache.c: Rearrange to avoid warnings about variables not being set.
	* c-lang.c, ch-lang.c, f-lang.c, m2-lang.c: Include valprint.h
	rather than declaring print_max and repeat_count_threashold
	ourselves (incorrectly).
	* valprint.h: Do declare repeat_count_threashold.
	* ch-exp.c: Use default case for internal error.
	* findvar.c: Don't omit argument type.
	* symtab.c: Remove unused variable.
@
text
@d33 1
a33 1
#include "gnu-regex.h"
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
             Free Software Foundation, Inc.
d5 1
a5 1
This file is part of GDB.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d50 1
a50 1
extern char * find_template_name_end PARAMS ((char *));
d56 2
a57 2
static void completion_list_add_name PARAMS ((char *, char *, int, char *, 
                                              char *));
d59 2
a60 2
static void build_canonical_line_spec PARAMS ((struct symtab_and_line *, 
                                               char *, char ***));
d62 2
a63 2
static struct symtabs_and_lines decode_line_2 PARAMS ((struct symbol *[], 
                                                       int, int, char ***));
d81 3
a83 3
static struct partial_symbol *lookup_partial_symbol PARAMS 
                                  ((struct partial_symtab *, const char *,
			            int, namespace_enum));
d85 2
a86 2
static struct partial_symbol *fixup_psymbol_section PARAMS ((struct 
                                        partial_symbol *, struct objfile *));
d92 2
a93 2
static struct symbol *find_active_alias PARAMS ((struct symbol *sym, 
                                                 CORE_ADDR addr));
d99 2
a100 2
static void fixup_section PARAMS ((struct general_symbol_info *, 
                                   struct objfile *));
d104 3
a106 3
static void print_symbol_info PARAMS ((namespace_enum, 
                                       struct symtab *, struct symbol *, 
                                       int, char *));
d112 3
d157 1
a157 1
 got_symtab:
d163 1
a163 1
      return s;
d171 3
a173 3
      {
	char *p = s -> filename;
	char *tail = strrchr (p, '/');
d175 2
a176 2
	if (tail)
	  p = tail + 1;
d178 3
a180 3
	if (STREQ (p, name))
	  return s;
      }
d189 1
a189 1
  if (ps -> readin)
d191 1
a191 1
	   ps -> filename, name);
d222 2
a223 1
  if (s) return s;
d238 2
a239 1
  if (s) return s;
d252 1
a252 1
char *name;
d256 1
a256 1
  
d258 6
a263 6
    {
      if (STREQ (name, pst -> filename))
	{
	  return (pst);
	}
    }
d269 3
a271 3
      {
	char *p = pst -> filename;
	char *tail = strrchr (p, '/');
d273 2
a274 2
	if (tail)
	  p = tail + 1;
d276 3
a278 3
	if (STREQ (p, name))
	  return (pst);
      }
d313 4
a316 4
  is_full_physname_constructor = 
    ((physname[0]=='_' && physname[1]=='_' && 
      (isdigit(physname[2]) || physname[2]=='Q' || physname[2]=='t'))
     || (strncmp(physname, "__ct", 4) == 0));
d319 1
a319 1
    is_full_physname_constructor || (newname && STREQ(field_name, newname));
d322 1
a322 1
    is_destructor = (strncmp(physname, "__dt", 4) == 0); 
d326 2
a327 2
      mangled_name = (char*) xmalloc(strlen(physname)+1);
      strcpy(mangled_name, physname);
d338 1
a338 1
	 the class name.  */
d348 3
a350 3
			  + strlen (buf) + len
			  + strlen (physname)
			  + 1);
d360 1
a360 1
      mangled_name = (char *)xmalloc (mangled_name_len);
d368 1
a368 1
      mangled_name = (char *)xmalloc (mangled_name_len);
d377 1
a377 1
     as something starting with `::' rather than `classname::'. */ 
d384 1
a385 1

d398 13
a410 9
    {
#if defined(HPUXHPPA)
      if (pc >= pst->textlow && pc <= pst->texthigh)
#else
      if (pc >= pst->textlow && pc < pst->texthigh)
#endif
	{
	  struct minimal_symbol *msymbol;
	  struct partial_symtab *tpst;
d412 3
a414 11
	  /* An objfile that has its functions reordered might have
	     many partial symbol tables containing the PC, but
	     we want the partial symbol table that contains the
	     function containing the PC.  */
	  if (!(objfile->flags & OBJF_REORDERED) &&
	      section == 0)	/* can't validate section this way */
	    return (pst);

	  msymbol = lookup_minimal_symbol_by_pc_section (pc, section);
	  if (msymbol == NULL)
	    return (pst);
d416 5
a420 9
	  for (tpst = pst; tpst != NULL; tpst = tpst->next)
	    {
#if defined(HPUXHPPA)
	      if (pc >= tpst->textlow && pc <= tpst->texthigh)
#else
	      if (pc >= tpst->textlow && pc < tpst->texthigh)
#endif
		{
		  struct partial_symbol *p;
d422 10
a431 10
		  p = find_pc_sect_psymbol (tpst, pc, section);
		  if (p != NULL
		      && SYMBOL_VALUE_ADDRESS(p)
			 == SYMBOL_VALUE_ADDRESS (msymbol))
		    return (tpst);
		}
	    }
	  return (pst);
	}
    }
d456 1
a456 1
  
d469 2
a470 2
       (pp - (psymtab->objfile->global_psymbols.list + psymtab->globals_offset)
	< psymtab->n_global_syms);
d481 1
a481 1
	  if (section)	/* match on a specific section */
d493 2
a494 2
       (pp - (psymtab->objfile->static_psymbols.list + psymtab->statics_offset)
	< psymtab->n_static_syms);
d502 1
a502 1
	      || (psymtab->textlow == 0 
d505 1
a505 1
	  if (section)	/* match on a specific section */
d619 1
a619 1
      if (sym) 
d625 1
a625 1
		 address of the start of this block.  */
d627 8
a634 8
		{
		  bv = BLOCKVECTOR (s);
		  b = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
		  if (BLOCK_START (b) <= BLOCK_START (block)
		      && BLOCK_END (b) > BLOCK_START (block))
		    goto found;
		}
found:
d665 16
a680 16
	{
	  bv = BLOCKVECTOR (s);
	  b = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
	  if (BLOCK_START (b) <= BLOCK_START (block)
	      && BLOCK_END (b) > BLOCK_START (block))
	    {
	      sym = lookup_block_symbol (b, name, VAR_NAMESPACE);
	      if (sym)
		{
		  block_found = b;
		  if (symtab != NULL)
		    *symtab = s;
		  return fixup_symbol_section (sym, objfile);
		}
	    }
	}
d689 1
a689 1
      
d704 1
a704 1
  
d706 12
a717 12
    {
      bv = BLOCKVECTOR (s);
      block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
      sym = lookup_block_symbol (block, name, namespace);
      if (sym) 
	{
	  block_found = block;
	  if (symtab != NULL)
	    *symtab = s;
	  return fixup_symbol_section (sym, objfile);
	}
    }
d724 1
a724 1
  
d731 1
a731 1
				  SYMBOL_BFD_SECTION (msymbol));
d739 4
a742 3
              /* We kept static functions in minimal symbol table as well as
		 in static scope. We want to find them in the symbol table. */
		if (!sym) {
d749 2
a750 2
		 but not in the symtab.
		 Return 0 to use the msymbol definition of "foo_".
d752 2
a753 2
		 This happens for Fortran  "foo_" symbols,
		 which are "foo" in the symtab.
d755 5
a759 5
		 This can also happen if "asm" is used to make a
		 regular symbol but not a debugging symbol, e.g.
		 asm(".globl _main");
		 asm("_main:");
		 */
d770 2
a771 2
		 mangled name.  */
	      return lookup_symbol (SYMBOL_NAME (msymbol), block, 
d779 1
a779 1
      
d783 18
a800 18
    {
      if (!ps->readin && lookup_partial_symbol (ps, name, 1, namespace))
	{
	  s = PSYMTAB_TO_SYMTAB(ps);
	  bv = BLOCKVECTOR (s);
	  block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
	  sym = lookup_block_symbol (block, name, namespace);
	  if (!sym)
            {
              /* This shouldn't be necessary, but as a last resort
               * try looking in the statics even though the psymtab
               * claimed the symbol was global. It's possible that
               * the psymtab gets it wrong in some cases.
               */
	      block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
	      sym = lookup_block_symbol (block, name, namespace);
              if (!sym)
	        error ("Internal: global symbol `%s' found in %s psymtab but not in symtab.\n\
d803 7
a809 7
                       name, ps->filename, name, name);
            }
	  if (symtab != NULL)
	    *symtab = s;
	  return fixup_symbol_section (sym, objfile);
	}
    }
d819 12
a830 12
    {
      bv = BLOCKVECTOR (s);
      block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
      sym = lookup_block_symbol (block, name, namespace);
      if (sym) 
	{
	  block_found = block;
	  if (symtab != NULL)
	    *symtab = s;
	  return fixup_symbol_section (sym, objfile);
	}
    }
d833 18
a850 18
    {
      if (!ps->readin && lookup_partial_symbol (ps, name, 0, namespace))
	{
	  s = PSYMTAB_TO_SYMTAB(ps);
	  bv = BLOCKVECTOR (s);
	  block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
	  sym = lookup_block_symbol (block, name, namespace);
	  if (!sym)
            {
              /* This shouldn't be necessary, but as a last resort
               * try looking in the globals even though the psymtab
               * claimed the symbol was static. It's possible that
               * the psymtab gets it wrong in some cases.
               */
	      block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
	      sym = lookup_block_symbol (block, name, namespace);
              if (!sym)
                error ("Internal: static symbol `%s' found in %s psymtab but not in symtab.\n\
d853 7
a859 7
                       name, ps->filename, name, name);
            }
	  if (symtab != NULL)
	    *symtab = s;
	  return fixup_symbol_section (sym, objfile);
	}
    }
d877 1
a877 1
  
d883 16
a898 16
          /* OK, we found a minimal symbol in spite of not
           * finding any symbol. There are various possible
           * explanations for this. One possibility is the symbol
           * exists in code not compiled -g. Another possibility
           * is that the 'psymtab' isn't doing its job.
           * A third possibility, related to #2, is that we were confused 
           * by name-mangling. For instance, maybe the psymtab isn't
           * doing its job because it only know about demangled
           * names, but we were given a mangled name...
           */

          /* We first use the address in the msymbol to try to
           * locate the appropriate symtab. Note that find_pc_symtab()
           * has a side-effect of doing psymtab-to-symtab expansion,
           * for the found symtab.
           */
d906 4
a909 4
              /* We kept static functions in minimal symbol table as well as
		 in static scope. We want to find them in the symbol table. */
 	      if (!sym) 
                {
d914 7
a920 6
              /* If we found one, return it */
              if (sym) {
	        if (symtab != NULL)
	          *symtab = s;
	        return sym;
              }
d923 16
a938 16
                 found in the minimal symbol table
		 but not in the symtab.
		 Fall through and return 0 to use the msymbol 
                 definition of "foo_".
                 (Note that outer code generally follows up a call
                  to this routine with a call to lookup_minimal_symbol(),
                  so a 0 return means we'll just flow into that other routine).

		 This happens for Fortran  "foo_" symbols,
		 which are "foo" in the symtab.

		 This can also happen if "asm" is used to make a
		 regular symbol but not a debugging symbol, e.g.
		 asm(".globl _main");
		 asm("_main:");
		 */
d941 4
a944 4
          /* If the lookup-by-address fails, try repeating the
           * entire lookup process with the symbol name from
           * the msymbol (if different from the original symbol name).
           */
d981 1
a981 1
  
d984 1
a984 1
	   pst->objfile->static_psymbols.list + pst->statics_offset  );
d986 1
a986 1
  if (global)		/* This means we can use a binary search. */
d992 2
a993 2
	 name.  At that point *all* partial symbols with that name
	 will be checked against the correct namespace. */
d1005 1
a1005 1
		  ))
d1026 1
a1026 1
	  top ++;
a1067 1
  register struct minimal_symbol *msymbol;
d1073 1
a1073 1
  
d1075 9
a1083 9
    {
      bv = BLOCKVECTOR (s);
      block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
      sym = lookup_block_symbol (block, name, STRUCT_NAMESPACE);
      if (sym && !TYPE_IS_OPAQUE (SYMBOL_TYPE (sym)))
	{
	  return SYMBOL_TYPE (sym);
	}
    }
d1086 18
a1103 18
    {
      if (!ps->readin && lookup_partial_symbol (ps, name, 1, STRUCT_NAMESPACE))
	{
	  s = PSYMTAB_TO_SYMTAB(ps);
	  bv = BLOCKVECTOR (s);
	  block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
	  sym = lookup_block_symbol (block, name, STRUCT_NAMESPACE);
	  if (!sym) 
            {
              /* This shouldn't be necessary, but as a last resort
               * try looking in the statics even though the psymtab
               * claimed the symbol was global. It's possible that
               * the psymtab gets it wrong in some cases.
               */
	      block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
	      sym = lookup_block_symbol (block, name, STRUCT_NAMESPACE);
              if (!sym)
                error ("Internal: global symbol `%s' found in %s psymtab but not in symtab.\n\
d1106 6
a1111 6
                       name, ps->filename, name, name);
            }
          if (!TYPE_IS_OPAQUE (SYMBOL_TYPE (sym)))
            return SYMBOL_TYPE (sym);
	}
    }
d1122 9
a1130 9
    {
      bv = BLOCKVECTOR (s);
      block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
      sym = lookup_block_symbol (block, name, STRUCT_NAMESPACE);
      if (sym && !TYPE_IS_OPAQUE (SYMBOL_TYPE (sym)))
	{
	  return SYMBOL_TYPE (sym);
	}
    }
d1133 18
a1150 18
    {
      if (!ps->readin && lookup_partial_symbol (ps, name, 0, STRUCT_NAMESPACE))
	{
	  s = PSYMTAB_TO_SYMTAB(ps);
	  bv = BLOCKVECTOR (s);
	  block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
	  sym = lookup_block_symbol (block, name, STRUCT_NAMESPACE);
	  if (!sym)
            {
              /* This shouldn't be necessary, but as a last resort
               * try looking in the globals even though the psymtab
               * claimed the symbol was static. It's possible that
               * the psymtab gets it wrong in some cases.
               */
	      block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
	      sym = lookup_block_symbol (block, name, STRUCT_NAMESPACE);
              if (!sym)
	        error ("Internal: static symbol `%s' found in %s psymtab but not in symtab.\n\
d1153 6
a1158 6
                       name, ps->filename, name, name);
            }
          if (!TYPE_IS_OPAQUE (SYMBOL_TYPE (sym)))
            return SYMBOL_TYPE (sym);
	}
    }
d1174 6
a1179 6
    {
      if (lookup_partial_symbol (pst, "main", 1, VAR_NAMESPACE))
	{
	  return (pst);
	}
    }
d1210 4
a1213 4
	 won't do the linear search once unless we find some reason to
	 do so, such as finding a C++ symbol during the binary search.
	 Note that for C++ modules, ALL the symbols in a block should
	 end up marked as C++ symbols. */
d1234 1
a1234 1
		  ))
d1257 6
a1262 6
	 name is greater than NAME, or find one we want.  If there is
	 more than one symbol with the right name and namespace, we
	 return the first one; I believe it is now impossible for us
	 to encounter two symbols with the same name and namespace
	 here, because blocks containing argument symbols are no
	 longer sorted.  */
d1309 18
a1326 2
		 at the current PC.  If no alias is active at the current
		 PC, then use the main symbol.
d1328 2
a1329 4
		 ?!? Is checking the current pc correct?  Is this routine
		 ever called to look up a symbol from another context?  */
              if (SYMBOL_ALIASES (sym))
                sym = find_active_alias (sym, read_pc ());
d1356 2
a1357 2
  struct symbol *sym;
  CORE_ADDR addr;
d1368 1
a1368 1
        return aliases->sym;
d1380 1
a1381 1

d1427 3
a1429 3
    {
      bv = BLOCKVECTOR (s);
      b = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
d1431 20
a1450 24
      if (BLOCK_START (b) <= pc
#if defined(HPUXHPPA)
	  && BLOCK_END (b) >= pc
#else
	  && BLOCK_END (b) > pc
#endif
	  && (distance == 0
	      || BLOCK_END (b) - BLOCK_START (b) < distance))
	{
	  /* For an objfile that has its functions reordered,
	     find_pc_psymtab will find the proper partial symbol table
	     and we simply return its corresponding symtab.  */
	  /* In order to better support objfiles that contain both
	     stabs and coff debugging info, we continue on if a psymtab
	     can't be found. */
	  if ((objfile->flags & OBJF_REORDERED) && objfile->psymtabs)
	    {
	      ps = find_pc_sect_psymtab (pc, section);
	      if (ps)
		return PSYMTAB_TO_SYMTAB (ps);
	    }
	  if (section != 0)
	    {
	      int i;
d1452 13
a1464 13
	      for (i = 0; i < b->nsyms; i++)
		{
		  fixup_symbol_section (b->sym[i], objfile);
		  if (section == SYMBOL_BFD_SECTION (b->sym[i]))
		    break;
		}
	      if (i >= b->nsyms)
		continue;	/* no symbol in this symtab matches section */
	    }
	  distance = BLOCK_END (b) - BLOCK_START (b);
	  best_s = s;
	}
    }
d1467 1
a1467 1
    return(best_s);
d1480 1
a1480 1
	         (unsigned long) pc);
d1495 1
a1496 1

d1527 3
a1529 3
    {
      /* Search the global and static blocks in this symtab for
	 the closest symbol-address to the desired address.  */
d1531 27
a1557 14
      for (blocknum = GLOBAL_BLOCK; blocknum <= STATIC_BLOCK; blocknum++)
	{
	  QUIT;
	  block = BLOCKVECTOR_BLOCK (BLOCKVECTOR (symtab), blocknum);
	  top = BLOCK_NSYMS (block);
	  for (bot = 0; bot < top; bot++)
	    {
	      sym = BLOCK_SYM (block, bot);
	      switch (SYMBOL_CLASS (sym))
		{
		case LOC_STATIC:	
		case LOC_LABEL:	
		  sym_addr = SYMBOL_VALUE_ADDRESS (sym);
		  break;
d1559 3
a1561 12
                case LOC_INDIRECT:
		  sym_addr = SYMBOL_VALUE_ADDRESS (sym);
                  /* An indirect symbol really lives at *sym_addr,
                   * so an indirection needs to be done.
                   * However, I am leaving this commented out because it's
                   * expensive, and it's possible that symbolization
                   * could be done without an active process (in
                   * case this read_memory will fail). RT
                  sym_addr = read_memory_unsigned_integer
                      (sym_addr, TARGET_PTR_BIT / TARGET_CHAR_BIT);
                   */
                  break;
d1563 3
a1565 3
		case LOC_BLOCK:
		  sym_addr = BLOCK_START (SYMBOL_BLOCK_VALUE (sym));
		  break;
d1567 9
a1575 2
		default:
		  continue;
d1577 3
d1581 1
a1581 15
		if (sym_addr <= addr)
		  if (sym_addr > best_sym_addr)
		    {
		      /* Quit if we found an exact match.  */
		      best_sym = sym;
		      best_sym_addr = sym_addr;
		      best_symtab = symtab;
		      if (sym_addr == addr)
			goto done;
		    }
	    }
	}
    }

 done:
d1647 1
a1647 1
  INIT_SAL (&val);	/* initialize to zeroes */
d1652 1
a1652 1
 /* elz: added this because this function returned the wrong
d1657 1
a1657 1
  */
d1659 1
a1659 1
   *
d1696 2
a1697 2
  msymbol = lookup_minimal_symbol_by_pc(pc);
  if (msymbol != NULL) 
d1699 22
a1720 22
    {
     mfunsym = lookup_minimal_symbol_text (SYMBOL_NAME (msymbol), NULL, NULL);
     if (mfunsym == NULL) 
        /* I eliminated this warning since it is coming out
         * in the following situation:
         * gdb shmain // test program with shared libraries
         * (gdb) break shr1  // function in shared lib
         * Warning: In stub for ...
         * In the above situation, the shared lib is not loaded yet, 
         * so of course we can't find the real func/line info,
         * but the "break" still works, and the warning is annoying.
         * So I commented out the warning. RT */
        /* warning ("In stub for %s; unable to find real function/line info", SYMBOL_NAME(msymbol)) */;
        /* fall through */
     else if (SYMBOL_VALUE(mfunsym) == SYMBOL_VALUE(msymbol))
        /* Avoid infinite recursion */
        /* See above comment about why warning is commented out */
        /* warning ("In stub for %s; unable to find real function/line info", SYMBOL_NAME(msymbol)) */;
        /* fall through */
     else
       return find_pc_line( SYMBOL_VALUE (mfunsym), 0);
    }
d1744 1
a1744 1
        continue;
d1759 1
a1759 1
	 If so, record this file, and its first line, as best alternate.  */
d1777 3
a1779 3
	 item points at the next line.  If we ran off the end of the linetable
	 (pc >= start of the last line), then prev == item.  If pc < start of
	 the first line, prev will not be set.  */
d1782 1
a1782 1
	 If so, record this file, and its best line, as best so far.  */
d1808 2
a1809 1
	  if (val.line == 0) ++val.line;
d1838 1
a1838 1
  asection     *section;
d1845 1
d1847 1
a1847 2

static struct symtab* find_line_symtab PARAMS ((struct symtab *, int,
d1860 1
a1860 1
static struct symtab*
d1883 5
a1887 5
	 another symtab with the same name.  In the case of xcoff,
	 multiple csects for one source file (produced by IBM's FORTRAN
	 compiler) produce multiple symtabs (this is unavoidable
	 assuming csects can be at arbitrary places in memory and that
	 the GLOBAL_BLOCK of a symtab has a begin and end address).  */
d1890 2
a1891 2
	 or 0 if none has been seen so far.
	 BEST_INDEX and BEST_LINETABLE identify the item for it.  */
d1903 3
a1905 3
	{
	  struct linetable *l;
	  int ind;
d1907 22
a1928 22
	  if (!STREQ (symtab->filename, s->filename))
	    continue;
	  l = LINETABLE (s);
	  ind = find_line_common (l, line, &exact);
	  if (ind >= 0)
	    {
	      if (exact)
		{
		  best_index = ind;
		  best_linetable = l;
		  best_symtab = s;
		  goto done;
		}
	      if (best == 0 || l->item[ind].line < best)
		{
		  best = l->item[ind].line;
		  best_index = ind;
		  best_linetable = l;
		  best_symtab = s;
		}
	    }
	}
d1930 1
a1930 1
 done:
d1985 1
a1985 1
  if (startaddr==0 && !find_line_pc (sal.symtab, sal.line, &startaddr))
d2080 1
a2080 1
find_function_start_sal PARAMS ((struct symbol *sym, int));
d2093 1
a2093 1
    { /* skip "first line" of function (which is actually its prologue) */
d2096 1
a2096 1
	 address, so that SKIP_PROLOGUE has something unique to work on */
d2102 1
a2102 1
      SKIP_PROLOGUE (pc);
d2146 1
a2146 1
  if (isalpha(*p) || *p == '_' || *p == '$' || *p == '\0')
d2155 1
a2155 1
  if (isalpha(*p) || *p == '_' || *p == '$')
d2157 2
a2158 2
      register char *q = p+1;
      while (isalnum(*q) || *q == '_' || *q == '$')
d2173 1
a2173 1
	*end = p+2;
d2175 1
a2175 1
	*end = p+1;
d2184 1
a2184 1
	*end = p+2;
d2186 1
a2186 1
	*end = p+1;
d2190 1
a2190 1
      *end = p+1;
d2195 1
a2195 1
      *end = p+2;
d2200 1
a2200 1
      *end = p+2;
d2205 1
a2205 1
      *end = p+2;
d2220 1
a2220 1
static int total_number_of_methods PARAMS ((struct type *type));
d2263 1
a2263 1
				     (struct block *)NULL,
d2265 2
a2266 2
				     (int *)NULL,
				     (struct symtab **)NULL)))
d2274 2
a2275 2
	 are counted as a single name.  There is an inner loop which loops over
	 each overload.  */
d2285 1
a2285 1
          if (strncmp (method_name, "__", 2) == 0 ||
d2288 1
a2288 1
            {
d2290 1
a2290 1
	        method_name = dem_opname;
d2292 2
a2293 2
	        method_name = dem_opname; 
            }
d2311 2
a2312 2
						 method_counter,
						 field_counter);
d2339 1
a2339 1
		       */
d2381 3
a2383 3
  if (s == (struct symtab *)NULL
      || s->filename == (char *)NULL
      || canonical == (char ***)NULL)
d2385 1
a2385 1
 
d2403 37
d2449 1
a2449 1
      PC returned is the start of the function.
d2451 1
a2451 1
      PC returned is 0.
d2455 2
d2517 1
a2517 1
#define volatile /*nothing*/
d2538 2
a2539 1
  int has_parens;  
d2541 1
d2546 2
a2547 2
  
  INIT_SAL (&val);	/* initialize to zeroes */
d2578 6
a2583 6
  if ((ii = strstr(*argptr, " if ")) != NULL ||
      (ii = strstr(*argptr, "\tif ")) != NULL ||
      (ii = strstr(*argptr, " if\t")) != NULL ||
      (ii = strstr(*argptr, "\tif\t")) != NULL ||
      (ii = strstr(*argptr, " if(")) != NULL ||
      (ii = strstr(*argptr, "\tif( ")) != NULL) 
d2589 4
a2592 3
  if (has_if) {
    *ii = '\0';
  }
d2606 1
a2606 1
		 && (pp = strchr (pp, ')')) != NULL);
d2614 19
d2638 2
a2639 1
  for (p = *argptr; *p; p++)
d2641 8
a2648 1
      if (p[0] == '<') 
d2650 13
a2662 6
          char * temp_end = find_template_name_end (p);
          if (!temp_end)
            error ("malformed template specification in command");
          p = temp_end;
	}
      if (p[0] == ':' || p[0] == ' ' || p[0] == '\t' || !*p)
d2664 1
a2664 1
      if (p[0] == '.' && strchr (p, ':') == NULL) /* Java qualified method. */
d2667 1
a2667 1
	  for (p1 = p;  *p1;  p1++)
d2675 16
a2690 1
  while (p[0] == ' ' || p[0] == '\t') p++;
d2696 71
a2766 68
      if (is_quoted) *argptr = *argptr+1;
      if (p[0] == '.' || p[1] ==':')
	{
          int ix;
          char * saved_arg2 = *argptr;
          char * temp_end;
          /* First check for "global" namespace specification,
             of the form "::foo". If found, skip over the colons
             and jump to normal symbol processing */
          if ((*argptr == p) || (p[-1] == ' ') || (p[-1] == '\t'))
            saved_arg2 += 2;

          /* We have what looks like a class or namespace
             scope specification (A::B), possibly with many
             levels of namespaces or classes (A::B::C::D).

             Some versions of the HP ANSI C++ compiler (as also possibly
             other compilers) generate class/function/member names with
             embedded double-colons if they are inside namespaces. To
             handle this, we loop a few times, considering larger and
             larger prefixes of the string as though they were single
             symbols.  So, if the initially supplied string is
             A::B::C::D::foo, we have to look up "A", then "A::B",
             then "A::B::C", then "A::B::C::D", and finally
             "A::B::C::D::foo" as single, monolithic symbols, because
             A, B, C or D may be namespaces.

             Note that namespaces can nest only inside other
             namespaces, and not inside classes.  So we need only
             consider *prefixes* of the string; there is no need to look up
             "B::C" separately as a symbol in the previous example. */
          
          p2 = p; /* save for restart */
          while (1)
            {
  	     /* Extract the class name.  */
	     p1 = p;
	     while (p != *argptr && p[-1] == ' ') --p;
	     copy = (char *) alloca (p - *argptr + 1);
	     memcpy (copy, *argptr, p - *argptr);
	     copy[p - *argptr] = 0;

	     /* Discard the class name from the arg.  */
	     p = p1 + (p1[0] == ':' ? 2 : 1);
	     while (*p == ' ' || *p == '\t') p++;
	     *argptr = p;

	     sym_class = lookup_symbol (copy, 0, STRUCT_NAMESPACE, 0, 
				        (struct symtab **)NULL);
       
	     if (sym_class &&
	         (t = check_typedef (SYMBOL_TYPE (sym_class)),
	          (TYPE_CODE (t) == TYPE_CODE_STRUCT
		   || TYPE_CODE (t) == TYPE_CODE_UNION)))
	       {
	         /* Arg token is not digits => try it as a function name
		    Find the next token(everything up to end or next blank). */
	         if (**argptr
		     && strchr (gdb_completer_quote_characters, **argptr) != NULL)
		   {
		     p = skip_quoted(*argptr);
		     *argptr = *argptr + 1;
		   }
	         else
		   {
	             p = *argptr;
	             while (*p && *p!=' ' && *p!='\t' && *p!=',' && *p!=':') p++;
		   }
d2768 87
a2854 9
	      q = operator_chars (*argptr, &q1);
	      if (q1 - q)
		{
		  char *opname;
		  char *tmp = alloca (q1 - q + 1);
		  memcpy (tmp, q, q1 - q);
		  tmp[q1 - q] = '\0';
		  opname = cplus_mangle_opname (tmp, DMGL_ANSI);
		  if (opname == NULL)
d2856 10
d2867 8
a2874 1
		      printf_filtered ("no mangling for \"%s\"\n", tmp);
a2877 3
		  copy = (char*) alloca (3 + strlen(opname));
		  sprintf (copy, "__%s", opname);
		  p = q1;
d2879 57
a2935 148
	      else
*/
		   {
		     copy = (char *) alloca (p - *argptr + 1 );
		     memcpy (copy, *argptr, p - *argptr);
		     copy[p - *argptr] = '\0';
		     if (p != *argptr
		         && copy[p - *argptr - 1]
		         && strchr (gdb_completer_quote_characters,
				    copy[p - *argptr - 1]) != NULL)
		       copy[p - *argptr - 1] = '\0';
		   }

	         /* no line number may be specified */
	         while (*p == ' ' || *p == '\t') p++;
	         *argptr = p;

	         sym = 0;
	         i1 = 0;		/*  counter for the symbol array */
	         sym_arr = (struct symbol **) alloca(total_number_of_methods (t)
						     * sizeof(struct symbol *));

	         if (destructor_name_p (copy, t))
		   {
		     /* Destructors are a special case.  */
		     int m_index, f_index;

		     if (get_destructor_fn_field (t, &m_index, &f_index))
		       {
		         struct fn_field *f = TYPE_FN_FIELDLIST1 (t, m_index);

		         sym_arr[i1] =
			   lookup_symbol (TYPE_FN_FIELD_PHYSNAME (f, f_index),
				          NULL, VAR_NAMESPACE, (int *) NULL,
				          (struct symtab **)NULL);
		         if (sym_arr[i1])
			   i1++;
		       }
		   }
	         else
		   i1 = find_methods (t, copy, sym_arr);
	         if (i1 == 1)
		   {
		     /* There is exactly one field with that name.  */
		     sym = sym_arr[0];

		     if (sym && SYMBOL_CLASS (sym) == LOC_BLOCK)
		       {
		         values.sals = (struct symtab_and_line *)
			   xmalloc (sizeof (struct symtab_and_line));
		         values.nelts = 1;
		         values.sals[0] = find_function_start_sal (sym,
				 				   funfirstline);
		       }
		     else
		       {
		         values.nelts = 0;
		       }
		     return values;
		   }
	         if (i1 > 0)
		   {
		     /* There is more than one field with that name
		        (overloaded).  Ask the user which one to use.  */
		     return decode_line_2 (sym_arr, i1, funfirstline, canonical);
		   }
	         else
		   {
		     char *tmp;

		     if (OPNAME_PREFIX_P (copy))
		       {
		         tmp = (char *)alloca (strlen (copy+3) + 9);
		         strcpy (tmp, "operator ");
		         strcat (tmp, copy+3);
		       }
		     else
		       tmp = copy;
		     error_begin ();
		     if (tmp[0] == '~')
		       printf_filtered
		         ("the class `%s' does not have destructor defined\n",
		          SYMBOL_SOURCE_NAME(sym_class));
		     else
		       printf_filtered
		         ("the class %s does not have any method named %s\n",
		          SYMBOL_SOURCE_NAME(sym_class), tmp);
		     cplusplus_hint (saved_arg);
		     return_to_top_level (RETURN_ERROR);
		   }
	       }

             /* Move pointer up to next possible class/namespace token */
              p = p2 + 1; /* restart with old value +1 */
              /* Move pointer ahead to next double-colon */
              while (*p && (p[0] != ' ') && (p[0] != '\t') && (p[0] != '\'')) {
                if (p[0] == '<') {
                  temp_end = find_template_name_end (p);
                  if (!temp_end)
                    error ("malformed template specification in command");
                  p = temp_end;
                }
                else if ((p[0] == ':') && (p[1] == ':'))
                  break; /* found double-colon */
                else
                  p++;
              }
              
              if (*p != ':')
                break; /* out of the while (1) */

              p2 = p; /* save restart for next time around */
              *argptr = saved_arg2; /* restore argptr */
            } /* while (1) */

          /* Last chance attempt -- check entire name as a symbol */
          /* Use "copy" in preparation for jumping out of this block,
             to be consistent with usage following the jump target */
          copy = (char *) alloca (p - saved_arg2 + 1);
          memcpy (copy, saved_arg2, p - saved_arg2);
          /* Note: if is_quoted should be true, we snuff out quote here anyway */
          copy[p-saved_arg2] = '\000'; 
          /* Set argptr to skip over the name */
          *argptr = (*p == '\'') ? p + 1 : p;
          /* Look up entire name */
          sym = lookup_symbol (copy, 0, VAR_NAMESPACE, 0, &sym_symtab);
          s = (struct symtab *) 0;
          /* Prepare to jump: restore the " if (condition)" so outer layers see it */
          if (has_if)
            *ii = ' ';
          /* Symbol was found --> jump to normal symbol processing.
             Code following "symbol_found" expects "copy" to have the
             symbol name, "sym" to have the symbol pointer, "s" to be
             a specified file's symtab, and sym_symtab to be the symbol's
             symtab. */
          /* By jumping there we avoid falling through the FILE:LINE and
             FILE:FUNC processing stuff below */
          if (sym)
            goto symbol_found;

          /* Couldn't find any interpretation as classes/namespaces, so give up */
          error_begin ();
          /* The quotes are important if copy is empty.  */
          printf_filtered
            ("Can't find member of namespace, class, struct, or union named \"%s\"\n", copy);
          cplusplus_hint (saved_arg);
          return_to_top_level (RETURN_ERROR);
        }
d2941 4
a2944 1
      while (p != *argptr && p[-1] == ' ') --p;
d2946 14
a2959 2
      memcpy (copy, *argptr, p - *argptr);
      copy[p - *argptr] = 0;
d2972 2
a2973 1
      while (*p == ' ' || *p == '\t') p++;
d2976 19
a2994 2
  else {
    /* Check if what we have till now is a symbol name */
d2996 15
a3010 21
    /* We may be looking at a template instantiation such
       as "foo<int>".  Check here whether we know about it,
       instead of falling through to the code below which
       handles ordinary function names, because that code
       doesn't like seeing '<' and '>' in a name -- the
       skip_quoted call doesn't go past them.  So see if we
       can figure it out right now. */ 

    copy = (char *) alloca (p - *argptr + 1);
    memcpy (copy, *argptr, p - *argptr);
    copy[p - *argptr] = '\000';
    sym = lookup_symbol (copy, 0, VAR_NAMESPACE, 0, &sym_symtab);
    if (sym) {
      /* Yes, we have a symbol; jump to symbol processing */
      /* Code after symbol_found expects S, SYM_SYMTAB, SYM, 
         and COPY to be set correctly */ 
      if (has_if)
        *ii = ' ';
      *argptr = (*p == '\'') ? p + 1 : p;
      s = (struct symtab *) 0;
      goto symbol_found;
d3012 1
a3012 3
    /* Otherwise fall out from here and go to file/line spec
       processing, etc. */ 
  }
d3020 2
a3021 1
  if (*q == '-' || *q == '+') q++;
d3028 5
a3032 1
      enum sign {none, plus, minus} sign = none;
d3038 3
a3040 3
	 We must guarantee that this section of code is never executed
	 when we are called with just a function name, since
	 select_source_symtab calls us with such an argument  */
d3071 1
a3071 1
	  break;	/* No need to adjust val.line.  */
d3074 2
a3075 1
      while (*q == ' ' || *q == '\t') q++;
d3081 2
a3082 2
	 and that the new line number specification has moved us from the
	 default (in s) to a new one.  */
d3086 1
a3086 1
     
d3101 1
a3101 1
    p = skip_quoted (*argptr + (((*argptr)[1] == '$') ? 2 : 1));  /* One or two $ chars possible */
d3106 1
a3106 1
        error ("Unmatched single quote.");
d3110 1
a3110 1
      p = pp+1;
d3112 1
a3112 1
  else 
d3114 1
a3114 1
      p = skip_quoted(*argptr);
d3117 3
d3125 1
a3125 1
      && copy[0] == copy [p - *argptr - 1]
d3128 1
a3128 1
      copy [p - *argptr - 1] = '\0';
d3131 2
a3132 1
  while (*p == ' ' || *p == '\t') p++;
d3137 1
a3137 1
     be history value, or it may be a convenience variable */ 
d3147 38
a3184 38
        p++;
      if (!*p) /* reached end of token without hitting non-digit */
        {
          /* We have a value history reference */
          sscanf ((copy[1] == '$') ? copy + 2 : copy + 1, "%d", &index);
          valx = access_value_history ((copy[1] == '$') ? -index : index);
          if (TYPE_CODE (VALUE_TYPE (valx)) != TYPE_CODE_INT)
            error ("History values used in line specs must have integer values.");
        }
      else 
        {
          /* Not all digits -- may be user variable/function or a
              convenience variable */
          
          /* Look up entire name as a symbol first */
          sym = lookup_symbol (copy, 0, VAR_NAMESPACE, 0, &sym_symtab); 
          s = (struct symtab *) 0;
          need_canonical = 1;
          /* Symbol was found --> jump to normal symbol processing.
             Code following "symbol_found" expects "copy" to have the
             symbol name, "sym" to have the symbol pointer, "s" to be
             a specified file's symtab, and sym_symtab to be the symbol's
             symtab. */
          if (sym)
            goto symbol_found;

          /* If symbol was not found, look in minimal symbol tables */ 
          msymbol = lookup_minimal_symbol (copy, 0, 0);
          /* Min symbol was found --> jump to minsym processing. */ 
          if (msymbol)
            goto minimal_symbol_found;
          
          /* Not a user variable or function -- must be convenience variable */
          need_canonical = (s == 0) ? 1 : 0;
          valx = value_of_internalvar (lookup_internalvar (copy + 1));
          if (TYPE_CODE (VALUE_TYPE (valx)) != TYPE_CODE_INT)
            error ("Convenience variables used in line specs must have integer values.");
        }
d3186 1
a3186 1
      /* Either history value or convenience value from above, in valx */ 
d3191 1
a3191 1
      values.sals = (struct symtab_and_line *)xmalloc (sizeof val);
d3209 3
a3211 3
  
symbol_found:   /* We also jump here from inside the C++ class/namespace 
                   code on finding a symbol of the form "A::B::C" */
d3265 3
a3267 3
minimal_symbol_found: /* We also jump here from the case for variables
                         that begin with '$' */
  
d3272 2
a3273 2
      values.sals[0] = find_pc_sect_line ( SYMBOL_VALUE_ADDRESS (msymbol), 
					   (struct sec *)0,0 );
d3278 1
a3278 1
	  SKIP_PROLOGUE (values.sals[0].pc);
d3289 1
a3289 1
  return values;	/* for lint */
d3302 1
a3302 1
			(char ***)NULL);
d3326 1
a3326 1
  char **canonical_arr = (char **)NULL;
d3328 4
a3331 4
  values.sals = (struct symtab_and_line *) 
    alloca (nelts * sizeof(struct symtab_and_line));
  return_values.sals = (struct symtab_and_line *) 
    xmalloc (nelts * sizeof(struct symtab_and_line));
d3343 1
a3343 1
  printf_unfiltered("[0] cancel\n[1] all\n");
d3352 1
a3352 1
			     (i+2),
d3361 1
a3361 1
  
d3367 1
a3367 1
  
d3377 2
a3378 1
      while (*arg1 >= '0' && *arg1 <= '9') arg1++;
d3392 1
a3392 1
	          if (canonical_arr[i] == NULL)
d3395 1
a3395 1
	              canonical_arr[i] = savestring (symname, strlen (symname));
d3400 1
a3400 1
		  (nelts * sizeof(struct symtab_and_line)));
d3431 2
a3432 1
      while (*args == ' ' || *args == '\t') args++;
d3438 1
a3439 1

d3497 1
a3497 1
}  
d3508 1
a3508 1
  
d3513 1
a3513 1
  
d3518 3
a3520 3
    {
      output_source_filename (s -> filename, &first);
    }
d3522 1
a3522 1
  
d3527 6
a3532 6
    {
      if (!ps->readin)
	{
	  output_source_filename (ps -> filename, &first);
	}
    }
d3547 4
a3550 4
        {
          if (strcmp (files[i], basename (file)) == 0)
            return 1;
        }
d3576 5
a3580 5
     FUNCTIONS_NAMESPACE - search all functions
     TYPES_NAMESPACE     - search all type names
     METHODS_NAMESPACE   - search all methods NOT IMPLEMENTED
     VARIABLES_NAMESPACE - search all symbols, excluding functions, type names,
                         and constants (enums)
d3583 1
a3583 1
*/
d3591 1
a3591 1
     
d3607 2
a3608 1
    = {mst_data, mst_text, mst_abs, mst_unknown};
d3610 2
a3611 1
    = {mst_bss,  mst_file_text, mst_abs, mst_unknown};
d3613 2
a3614 1
    = {mst_file_data,  mst_solib_trampoline, mst_abs, mst_unknown};
d3616 2
a3617 1
    = {mst_file_bss,   mst_text, mst_abs, mst_unknown};
d3647 23
a3669 23
        {
          int fix = -1; /* -1 means ok; otherwise number of spaces needed. */
          if (isalpha(*opname) || *opname == '_' || *opname == '$')
            {
              /* There should 1 space between 'operator' and 'TYPENAME'. */
              if (opname[-1] != ' ' || opname[-2] == ' ')
                fix = 1;
            }
          else
            {
              /* There should 0 spaces between 'operator' and 'OPERATOR'. */
              if (opname[-1] == ' ')
                fix = 0;
            }
          /* If wrong number of spaces, fix it. */
          if (fix >= 0)
            {
              char *tmp = (char*) alloca(opend-opname+10);
              sprintf(tmp, "operator%.*s%s", fix, " ", opname);
              regexp = tmp;
            }
        }
      
d3671 1
a3671 1
        error ("Invalid regexp (%s): %s", val, regexp);
d3679 3
a3681 3
    {
      struct partial_symbol **bound, **gbound, **sbound;
      int keep_going = 1;
d3683 2
a3684 1
      if (ps->readin) continue;
d3686 41
a3726 41
      gbound = objfile->global_psymbols.list + ps->globals_offset + ps->n_global_syms;
      sbound = objfile->static_psymbols.list + ps->statics_offset + ps->n_static_syms;
      bound = gbound;
      
      /* Go through all of the symbols stored in a partial
         symtab in one loop. */
      psym = objfile->global_psymbols.list + ps->globals_offset;
      while (keep_going)
        {
          if (psym >= bound)
            {
              if (bound == gbound && ps->n_static_syms != 0)
                {
                  psym = objfile->static_psymbols.list + ps->statics_offset;
                  bound = sbound;
                }
              else
                keep_going = 0;
              continue;
            }
          else
            {
              QUIT;

              /* If it would match (logic taken from loop below)
                 load the file and go on to the next one */
              if (file_matches (ps->filename, files, nfiles)
                  && ((regexp == NULL || SYMBOL_MATCHES_REGEXP (*psym))
                      && ((kind == VARIABLES_NAMESPACE && SYMBOL_CLASS (*psym) != LOC_TYPEDEF
                           && SYMBOL_CLASS (*psym) != LOC_BLOCK)
                          || (kind == FUNCTIONS_NAMESPACE && SYMBOL_CLASS (*psym) == LOC_BLOCK)
                          || (kind == TYPES_NAMESPACE && SYMBOL_CLASS (*psym) == LOC_TYPEDEF)
                          || (kind == METHODS_NAMESPACE && SYMBOL_CLASS (*psym) == LOC_BLOCK))))
                {
                  PSYMTAB_TO_SYMTAB(ps);
                  keep_going = 0;
                }
            }
          psym++;
        }
    }
d3739 1
a3739 1
  */
d3744 20
a3763 20
        {
          if (MSYMBOL_TYPE (msymbol) == ourtype ||
              MSYMBOL_TYPE (msymbol) == ourtype2 ||
              MSYMBOL_TYPE (msymbol) == ourtype3 ||
              MSYMBOL_TYPE (msymbol) == ourtype4)
            {
              if (regexp == NULL || SYMBOL_MATCHES_REGEXP (msymbol))
                {
                  if (0 == find_pc_symtab (SYMBOL_VALUE_ADDRESS (msymbol)))
                    {
                      if (kind == FUNCTIONS_NAMESPACE
                          || lookup_symbol (SYMBOL_NAME (msymbol), 
                                            (struct block *) NULL,
                                            VAR_NAMESPACE,
                                            0, (struct symtab **) NULL) == NULL)
                        found_misc = 1;
                    }
                }
            }
        }
d3767 48
a3814 48
    {
      bv = BLOCKVECTOR (s);
      /* Often many files share a blockvector.
         Scan each blockvector only once so that
         we don't get every symbol many times.
         It happens that the first symtab in the list
         for any given blockvector is the main file.  */
      if (bv != prev_bv)
        for (i = GLOBAL_BLOCK; i <= STATIC_BLOCK; i++)
          {
            b = BLOCKVECTOR_BLOCK (bv, i);
            /* Skip the sort if this block is always sorted.  */
            if (!BLOCK_SHOULD_SORT (b))
              sort_block_syms (b);
            for (j = 0; j < BLOCK_NSYMS (b); j++)
              {
                QUIT;
                sym = BLOCK_SYM (b, j);
                if (file_matches (s->filename, files, nfiles)
                    && ((regexp == NULL || SYMBOL_MATCHES_REGEXP (sym))
                        && ((kind == VARIABLES_NAMESPACE && SYMBOL_CLASS (sym) != LOC_TYPEDEF
                             && SYMBOL_CLASS (sym) != LOC_BLOCK
                             && SYMBOL_CLASS (sym) != LOC_CONST)
                            || (kind == FUNCTIONS_NAMESPACE && SYMBOL_CLASS (sym) == LOC_BLOCK)
                            || (kind == TYPES_NAMESPACE && SYMBOL_CLASS (sym) == LOC_TYPEDEF)
                            || (kind == METHODS_NAMESPACE && SYMBOL_CLASS (sym) == LOC_BLOCK))))
                  {
                    /* match */
                    psr = (struct symbol_search *) xmalloc (sizeof (struct symbol_search));
                    psr->block = i;
                    psr->symtab = s;
                    psr->symbol = sym;
                    psr->msymbol = NULL;
                    psr->next = NULL;
                    if (tail == NULL)
                      {
                        sr = psr;
                        old_chain = make_cleanup ((make_cleanup_func) 
                                                  free_search_symbols, sr);
                      }
                    else
                      tail->next = psr;
                    tail = psr;
                  }
              }
          }
      prev_bv = bv;
    }
d3822 38
a3859 38
        {
          if (MSYMBOL_TYPE (msymbol) == ourtype ||
              MSYMBOL_TYPE (msymbol) == ourtype2 ||
              MSYMBOL_TYPE (msymbol) == ourtype3 ||
              MSYMBOL_TYPE (msymbol) == ourtype4)
            {
              if (regexp == NULL || SYMBOL_MATCHES_REGEXP (msymbol))
                {
                  /* Functions:  Look up by address. */
                  if (kind != FUNCTIONS_NAMESPACE ||
                      (0 == find_pc_symtab (SYMBOL_VALUE_ADDRESS (msymbol))))
                    {
                      /* Variables/Absolutes:  Look up by name */
                      if (lookup_symbol (SYMBOL_NAME (msymbol), 
                                         (struct block *) NULL, VAR_NAMESPACE,
                                         0, (struct symtab **) NULL) == NULL)
                        {
                          /* match */
                          psr = (struct symbol_search *) xmalloc (sizeof (struct symbol_search));
                          psr->block = i;
                          psr->msymbol = msymbol;
                          psr->symtab  = NULL;
                          psr->symbol  = NULL;
                          psr->next = NULL;
                          if (tail == NULL)
                            {
                              sr = psr;
                              old_chain = make_cleanup ((make_cleanup_func) 
                                                      free_search_symbols, &sr);
                            }
                          else
                            tail->next = psr;
                          tail = psr;
                        }
                    }
                }
            }
        }
d3870 1
a3870 1
*/
d3888 1
a3888 1
	    
d3892 1
a3892 1
    c_typedef_print (SYMBOL_TYPE(sym), sym, gdb_stdout);
d3894 3
a3896 3
  else if (kind < TYPES_NAMESPACE || 
           (kind == TYPES_NAMESPACE && 
            SYMBOL_NAMESPACE(sym) == STRUCT_NAMESPACE))
d3899 3
a3901 3
                  (SYMBOL_CLASS (sym) == LOC_TYPEDEF
                   ? "" : SYMBOL_SOURCE_NAME (sym)),
                  gdb_stdout, 0);
d3907 1
a3907 1
# if 0
d3910 4
a3913 4
      c_type_print_base (TYPE_FN_FIELD_TYPE(t, block),
                         gdb_stdout, 0, 0); 
      c_type_print_varspec_prefix (TYPE_FN_FIELD_TYPE(t, block),
                                   gdb_stdout, 0); 
d3915 1
a3915 1
        check_stub_method (TYPE_DOMAIN_TYPE (type), j, block);
d3917 2
a3918 2
        cplus_demangle (TYPE_FN_FIELD_PHYSNAME (t, block),
                        DMGL_ANSI | DMGL_PARAMS);
d3920 2
a3921 2
        fprintf_filtered (stream, "<badly mangled name %s>",
                          TYPE_FN_FIELD_PHYSNAME (t, block));
d3923 5
a3927 5
        {
          fputs_filtered (demangled_name, stream);
          free (demangled_name);
        }
# endif
d3933 1
a3933 1
*/
d3939 2
a3940 2
                   (unsigned long) SYMBOL_VALUE_ADDRESS (msymbol),
                   SYMBOL_SOURCE_NAME (msymbol));
d3947 1
a3947 1
*/
d3952 1
a3952 1
     int   from_tty;
d3955 2
a3956 1
    = {"variable", "function", "type", "method"};
d3968 3
a3970 3
                   ? "All %ss matching regular expression \"%s\":\n"
                   : "All defined %ss:\n",
                   classnames[(int) (kind - LABEL_NAMESPACE - 1)], regexp);
d3977 8
a3984 8
        {
          if (first)
            {
              printf_filtered ("\nNon-debugging symbols:\n");
              first = 0;
            }
          print_msymbol_info (p->msymbol);
        }
d3986 8
a3993 8
        {
          print_symbol_info (kind,
                             p->symtab,
                             p->symbol,
                             p->block,
                             last_filename);
          last_filename = p->symtab->filename;
        }
d4034 9
d4058 15
a4072 15
        {
          char *string = (char *) alloca (strlen (p->symtab->filename)
                                          + strlen (SYMBOL_NAME (p->symbol))
                                          + 4);
          strcpy (string, p->symtab->filename);
          strcat (string, ":'");
          strcat (string, SYMBOL_NAME (p->symbol));
          strcat (string, "'");
          break_command (string, from_tty);
          print_symbol_info (FUNCTIONS_NAMESPACE,
                             p->symtab,
                             p->symbol,
                             p->block,
                             p->symtab->filename);
        }
d4074 5
a4078 5
        {
          break_command (SYMBOL_NAME (p->msymbol), from_tty);
          printf_filtered ("<function, no debug info> %s;\n",
                           SYMBOL_SOURCE_NAME (p->msymbol));
        }
d4083 1
a4084 1

d4095 1
a4095 1
      && BLOCK_END (a)   <= BLOCK_END (b);
d4097 1
a4098 1

d4119 2
a4120 2
    demangled for C++ symbols) matches SYM_TEXT in the first SYM_TEXT_LEN
    characters.  If so, add it to the current completion list. */
d4150 1
a4150 1
  
d4242 1
a4242 1
		 doesn't end the string.  */
d4256 1
a4256 1
	 to complete it any other way.  */
d4284 25
a4308 24
    {
      /* If the psymtab's been read in we'll get it when we search
	 through the blockvector.  */
      if (ps->readin) continue;
      
      for (psym = objfile->global_psymbols.list + ps->globals_offset;
	   psym < (objfile->global_psymbols.list + ps->globals_offset
		   + ps->n_global_syms);
	   psym++)
	{
	  /* If interrupted, then quit. */
	  QUIT;
	  COMPLETION_LIST_ADD_SYMBOL (*psym, sym_text, sym_text_len, text, word);
	}
      
      for (psym = objfile->static_psymbols.list + ps->statics_offset;
	   psym < (objfile->static_psymbols.list + ps->statics_offset
		   + ps->n_static_syms);
	   psym++)
	{
	  QUIT;
	  COMPLETION_LIST_ADD_SYMBOL (*psym, sym_text, sym_text_len, text, word);
	}
    }
d4316 4
a4319 4
    {
      QUIT;
      COMPLETION_LIST_ADD_SYMBOL (msymbol, sym_text, sym_text_len, text, word);
    }
d4328 1
a4328 1
	  surrounding_static_block = b; 	/* For elmin of dups */
d4330 1
a4330 1
      
d4332 1
a4332 1
	 text string.  Only complete on types visible from current context. */
d4350 1
a4350 1
						      sym_text, sym_text_len, text, word);
d4362 9
a4370 9
    {
      QUIT;
      b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), GLOBAL_BLOCK);
      for (i = 0; i < BLOCK_NSYMS (b); i++)
	{
	  sym = BLOCK_SYM (b, i);
	  COMPLETION_LIST_ADD_SYMBOL (sym, sym_text, sym_text_len, text, word);
	}
    }
d4373 12
a4384 11
    {
      QUIT;
      b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), STATIC_BLOCK);
      /* Don't do this block twice.  */
      if (b == surrounding_static_block) continue;
      for (i = 0; i < BLOCK_NSYMS (b); i++)
	{
	  sym = BLOCK_SYM (b, i);
	  COMPLETION_LIST_ADD_SYMBOL (sym, sym_text, sym_text_len, text, word);
	}
    }
d4427 1
a4427 1
 nosyms:
d4432 2
a4433 1
  if (!func_start) return 1;
d4439 1
a4439 1
  SKIP_PROLOGUE (func_start);
d4453 2
a4454 2
    demangled for C++ symbols) matches SYM_TEXT in the first SYM_TEXT_LEN
    characters.  If so, add it to the current completion list. */
d4458 2
a4459 2
  struct symbol * sym;
  char * oload_name;
d4465 1
a4465 1
  char * sym_name = cplus_demangle (SYMBOL_NAME (sym), DMGL_ARM | DMGL_ANSI);
d4474 4
a4477 1
    return;
d4497 1
a4497 1
  
d4509 1
a4509 1
  struct symbol * fsym;
a4513 1
  register struct minimal_symbol *msymbol;
d4516 1
a4516 2
  register int i, j;
  struct partial_symbol **psym;
d4539 1
a4539 1
     by matching OLOAD_NAME.  Add each one that you find to the list.  */
d4542 2
a4543 24
    {
      /* If the psymtab's been read in we'll get it when we search
	 through the blockvector.  */
      if (ps->readin) continue;
      
      for (psym = objfile->global_psymbols.list + ps->globals_offset;
	   psym < (objfile->global_psymbols.list + ps->globals_offset
		   + ps->n_global_syms);
	   psym++)
	{
	  /* If interrupted, then quit. */
	  QUIT;
	  overload_list_add_symbol (*psym, oload_name);
	}
      
      for (psym = objfile->static_psymbols.list + ps->statics_offset;
	   psym < (objfile->static_psymbols.list + ps->statics_offset
		   + ps->n_static_syms);
	   psym++)
	{
	  QUIT;
	  overload_list_add_symbol (*psym, oload_name);
	}
    }
d4545 15
a4559 4
  /* At this point scan through the misc symbol vectors and add each
     symbol you find to the list.  Eventually we want to ignore
     anything that isn't a text symbol (everything else will be
     handled by the psymtab code above).  */
d4561 10
a4570 5
  ALL_MSYMBOLS (objfile, msymbol)
    {
      QUIT;
      overload_list_add_symbol (msymbol, oload_name);
    }
d4579 1
a4579 1
	  surrounding_static_block = b; 	/* For elimination of dups */
d4581 1
a4581 1
      
d4583 1
a4583 1
	 text string.  Only complete on types visible from current context. */
d4596 9
a4604 9
    {
      QUIT;
      b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), GLOBAL_BLOCK);
      for (i = 0; i < BLOCK_NSYMS (b); i++)
	{
	  sym = BLOCK_SYM (b, i);
	  overload_list_add_symbol (sym, oload_name);
	}
    }
d4607 12
a4618 11
    {
      QUIT;
      b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), STATIC_BLOCK);
      /* Don't do this block twice.  */
      if (b == surrounding_static_block) continue;
      for (i = 0; i < BLOCK_NSYMS (b); i++)
	{
	  sym = BLOCK_SYM (b, i);
	  overload_list_add_symbol (sym, oload_name);
	}
    }
d4626 1
a4627 1

d4632 1
a4632 1
	    "All global and static variable names, or those matching REGEXP.");
d4634 2
a4635 2
    add_com("whereis", class_info, variables_info, 
	    "All global and static variable names, or those matching REGEXP.");
d4643 3
a4645 3
         typedef struct foo *FOO
	 type_print prints "FOO" when we want to make it (in this situation)
	 print "struct foo *".
d4662 1
a4662 1
	    "Set a breakpoint for all functions matching REGEXP.");
d4668 1
a4668 1
	    "All global and static variable names, or those matching REGEXP.");
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@a2854 8
#if 0
  /* No one really seems to know why this was added. It certainly
     breaks the command line, though, whenever the passed
     name is of the form ClassName::Method. This bit of code
     singles out the class name, and if funfirstline is set (for
     example, you are setting a breakpoint at this function),
     you get an error. This did not occur with earlier
     verions, so I am ifdef'ing this out. 3/29/99 */
a2882 1
#endif
a4376 10
  /* Comment and #if 0 from Rajiv Mirani <mirani@@cup.hp.com>.
     However, leaving #if 0's around is uncool.  We need to figure out
     what this is really trying to do, decide whether we want that,
     and either fix it or delete it.  --- Jim Blandy, Mar 1999 */

  /* ??? RM: What in hell is this? overload_list_add_symbol expects a symbol,
   * not a partial_symbol or a minimal_symbol. And it looks at the type field
   * of the symbol, and we don't know the type of minimal and partial symbols
   */
#if 0
a4415 1
#endif
@


1.1.1.3
log
@import gdb-19990504 snapshot
@
text
@d2092 1
a2092 1
      pc = SKIP_PROLOGUE (pc);
d3147 1
a3147 1
	  values.sals[0].pc = SKIP_PROLOGUE (values.sals[0].pc);
d4288 1
a4288 1
  func_start = SKIP_PROLOGUE (func_start);
@


1.1.1.4
log
@import gdb-1999-05-25 snapshot
@
text
@a110 3
static void overload_list_add_symbol PARAMS ((struct symbol *sym,
					      char *oload_name));

@


1.1.1.5
log
@import gdb-1999-06-07 snapshot
@
text
@a2491 1
  int is_quote_enclosed;
a2493 1
  int has_comma = 0;
a2564 13
  /* Maybe we were called with a line range FILENAME:LINENUM,FILENAME:LINENUM
     and we must isolate the first half.  Outer layers will call again later
     for the second half */
  if ((ii = strchr(*argptr, ',')) != NULL)
    has_comma = 1;
  /* Temporarily zap out second half to not
   * confuse the code below.
   * This is undone below. Do not change ii!!
   */
  if (has_comma) {
    *ii = '\0';
  }

d2570 1
a2570 9
  p = *argptr;
  if (p[0] == '"')
    {
      is_quote_enclosed = 1;
      p++;
    }
  else
      is_quote_enclosed = 0;
  for ( ; *p; p++)
d2579 2
a2580 9
      /* Check for the end of the first half of the linespec.  End of line,
         a tab, a double colon or the last single colon, or a space.  But
         if enclosed in double quotes we do not break on enclosed spaces */
      if (!*p
          || p[0] == '\t'
          || ((p[0] == ':')
              && ((p[1] == ':') || (strchr (p + 1, ':') == NULL)))
          || ((p[0] == ' ') && ! is_quote_enclosed))
        break;
a2592 10
  /* if the closing double quote was left at the end, remove it */
  if (is_quote_enclosed && ((pp = strchr (p, '"')) != NULL))
    if (!*(pp+1))
      *pp = '\0';

  /* Now that we've safely parsed the first half,
   * put back ',' so outer layers can see it 
   */
  if (has_comma)
    *ii = ',';
d2814 2
a2839 1
      if ((*p == '"') && is_quote_enclosed) --p;
d2841 2
a2842 14
      if ((**argptr == '"') && is_quote_enclosed)
        {
          memcpy (copy, *argptr + 1, p - *argptr - 1);
          /* It may have the ending quote right after the file name */
          if (copy[p - *argptr - 2] == '"')
            copy[p - *argptr - 2] = 0;
          else
            copy[p - *argptr - 1] = 0;
        }
      else
        {
          memcpy (copy, *argptr, p - *argptr);
          copy[p - *argptr] = 0;
        }
d2885 2
@


1.1.1.6
log
@import gdb-1999-06-28 snapshot
@
text
@a2410 2
   This may all be followed by an "if EXPR", which we ignore.

@


1.1.1.7
log
@import gdb-1999-07-07 post reformat
@
text
@d3 1
a3 1
   Free Software Foundation, Inc.
d5 1
a5 1
   This file is part of GDB.
d7 13
a19 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d49 1
a49 1
extern char *find_template_name_end PARAMS ((char *));
d55 2
a56 2
static void completion_list_add_name PARAMS ((char *, char *, int, char *,
					      char *));
d58 2
a59 2
static void build_canonical_line_spec PARAMS ((struct symtab_and_line *,
					       char *, char ***));
d61 2
a62 2
static struct symtabs_and_lines decode_line_2 PARAMS ((struct symbol *[],
						       int, int, char ***));
d80 3
a82 3
static struct partial_symbol *lookup_partial_symbol PARAMS
  ((struct partial_symtab *, const char *,
    int, namespace_enum));
d84 2
a85 2
static struct partial_symbol *fixup_psymbol_section PARAMS ((struct
				       partial_symbol *, struct objfile *));
d91 2
a92 2
static struct symbol *find_active_alias PARAMS ((struct symbol * sym,
						 CORE_ADDR addr));
d98 2
a99 2
static void fixup_section PARAMS ((struct general_symbol_info *,
				   struct objfile *));
d103 3
a105 3
static void print_symbol_info PARAMS ((namespace_enum,
				       struct symtab *, struct symbol *,
				       int, char *));
d111 1
a111 1
static void overload_list_add_symbol PARAMS ((struct symbol * sym,
d156 1
a156 1
got_symtab:
d162 1
a162 1
    return s;
d170 3
a172 3
    {
      char *p = s->filename;
      char *tail = strrchr (p, '/');
d174 2
a175 2
      if (tail)
	p = tail + 1;
d177 3
a179 3
      if (STREQ (p, name))
	return s;
    }
d188 1
a188 1
  if (ps->readin)
d190 1
a190 1
	   ps->filename, name);
d221 1
a221 2
  if (s)
    return s;
d236 1
a236 2
  if (s)
    return s;
d249 1
a249 1
     char *name;
d253 1
a253 1

d255 6
a260 6
  {
    if (STREQ (name, pst->filename))
      {
	return (pst);
      }
  }
d266 3
a268 3
    {
      char *p = pst->filename;
      char *tail = strrchr (p, '/');
d270 2
a271 2
      if (tail)
	p = tail + 1;
d273 3
a275 3
      if (STREQ (p, name))
	return (pst);
    }
d310 4
a313 4
  is_full_physname_constructor =
    ((physname[0] == '_' && physname[1] == '_' &&
      (isdigit (physname[2]) || physname[2] == 'Q' || physname[2] == 't'))
     || (strncmp (physname, "__ct", 4) == 0));
d316 1
a316 1
    is_full_physname_constructor || (newname && STREQ (field_name, newname));
d319 1
a319 1
    is_destructor = (strncmp (physname, "__dt", 4) == 0);
d323 2
a324 2
      mangled_name = (char *) xmalloc (strlen (physname) + 1);
      strcpy (mangled_name, physname);
d335 1
a335 1
         the class name.  */
d345 3
a347 3
		      + strlen (buf) + len
		      + strlen (physname)
		      + 1);
d357 1
a357 1
      mangled_name = (char *) xmalloc (mangled_name_len);
d365 1
a365 1
      mangled_name = (char *) xmalloc (mangled_name_len);
d374 1
a374 1
     as something starting with `::' rather than `classname::'. */
d381 1
a383 1

d395 1
a395 1
  {
d397 1
a397 1
    if (pc >= pst->textlow && pc <= pst->texthigh)
d399 1
a399 1
    if (pc >= pst->textlow && pc < pst->texthigh)
d401 3
a403 11
      {
	struct minimal_symbol *msymbol;
	struct partial_symtab *tpst;

	/* An objfile that has its functions reordered might have
	   many partial symbol tables containing the PC, but
	   we want the partial symbol table that contains the
	   function containing the PC.  */
	if (!(objfile->flags & OBJF_REORDERED) &&
	    section == 0)	/* can't validate section this way */
	  return (pst);
d405 11
a415 3
	msymbol = lookup_minimal_symbol_by_pc_section (pc, section);
	if (msymbol == NULL)
	  return (pst);
d417 2
a418 2
	for (tpst = pst; tpst != NULL; tpst = tpst->next)
	  {
d420 1
a420 1
	    if (pc >= tpst->textlow && pc <= tpst->texthigh)
d422 1
a422 1
	    if (pc >= tpst->textlow && pc < tpst->texthigh)
d424 2
a425 2
	      {
		struct partial_symbol *p;
d427 10
a436 10
		p = find_pc_sect_psymbol (tpst, pc, section);
		if (p != NULL
		    && SYMBOL_VALUE_ADDRESS (p)
		    == SYMBOL_VALUE_ADDRESS (msymbol))
		  return (tpst);
	      }
	  }
	return (pst);
      }
  }
d461 1
a461 1

d474 2
a475 2
    (pp - (psymtab->objfile->global_psymbols.list + psymtab->globals_offset)
     < psymtab->n_global_syms);
d486 1
a486 1
	  if (section)		/* match on a specific section */
d498 2
a499 2
    (pp - (psymtab->objfile->static_psymbols.list + psymtab->statics_offset)
     < psymtab->n_static_syms);
d507 1
a507 1
	      || (psymtab->textlow == 0
d510 1
a510 1
	  if (section)		/* match on a specific section */
d624 1
a624 1
      if (sym)
d630 1
a630 1
	         address of the start of this block.  */
d632 8
a639 8
	      {
		bv = BLOCKVECTOR (s);
		b = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
		if (BLOCK_START (b) <= BLOCK_START (block)
		    && BLOCK_END (b) > BLOCK_START (block))
		  goto found;
	      }
	    found:
d670 16
a685 16
      {
	bv = BLOCKVECTOR (s);
	b = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
	if (BLOCK_START (b) <= BLOCK_START (block)
	    && BLOCK_END (b) > BLOCK_START (block))
	  {
	    sym = lookup_block_symbol (b, name, VAR_NAMESPACE);
	    if (sym)
	      {
		block_found = b;
		if (symtab != NULL)
		  *symtab = s;
		return fixup_symbol_section (sym, objfile);
	      }
	  }
      }
d694 1
a694 1

d709 1
a709 1

d711 12
a722 12
  {
    bv = BLOCKVECTOR (s);
    block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
    sym = lookup_block_symbol (block, name, namespace);
    if (sym)
      {
	block_found = block;
	if (symtab != NULL)
	  *symtab = s;
	return fixup_symbol_section (sym, objfile);
      }
  }
d729 1
a729 1

d736 1
a736 1
				   SYMBOL_BFD_SECTION (msymbol));
d744 3
a746 4
	      /* We kept static functions in minimal symbol table as well as
	         in static scope. We want to find them in the symbol table. */
	      if (!sym)
		{
d753 2
a754 2
	         but not in the symtab.
	         Return 0 to use the msymbol definition of "foo_".
d756 2
a757 2
	         This happens for Fortran  "foo_" symbols,
	         which are "foo" in the symtab.
d759 5
a763 5
	         This can also happen if "asm" is used to make a
	         regular symbol but not a debugging symbol, e.g.
	         asm(".globl _main");
	         asm("_main:");
	       */
d774 2
a775 2
	         mangled name.  */
	      return lookup_symbol (SYMBOL_NAME (msymbol), block,
d783 1
a783 1

d787 18
a804 18
  {
    if (!ps->readin && lookup_partial_symbol (ps, name, 1, namespace))
      {
	s = PSYMTAB_TO_SYMTAB (ps);
	bv = BLOCKVECTOR (s);
	block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
	sym = lookup_block_symbol (block, name, namespace);
	if (!sym)
	  {
	    /* This shouldn't be necessary, but as a last resort
	     * try looking in the statics even though the psymtab
	     * claimed the symbol was global. It's possible that
	     * the psymtab gets it wrong in some cases.
	     */
	    block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
	    sym = lookup_block_symbol (block, name, namespace);
	    if (!sym)
	      error ("Internal: global symbol `%s' found in %s psymtab but not in symtab.\n\
d807 7
a813 7
		     name, ps->filename, name, name);
	  }
	if (symtab != NULL)
	  *symtab = s;
	return fixup_symbol_section (sym, objfile);
      }
  }
d823 12
a834 12
  {
    bv = BLOCKVECTOR (s);
    block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
    sym = lookup_block_symbol (block, name, namespace);
    if (sym)
      {
	block_found = block;
	if (symtab != NULL)
	  *symtab = s;
	return fixup_symbol_section (sym, objfile);
      }
  }
d837 18
a854 18
  {
    if (!ps->readin && lookup_partial_symbol (ps, name, 0, namespace))
      {
	s = PSYMTAB_TO_SYMTAB (ps);
	bv = BLOCKVECTOR (s);
	block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
	sym = lookup_block_symbol (block, name, namespace);
	if (!sym)
	  {
	    /* This shouldn't be necessary, but as a last resort
	     * try looking in the globals even though the psymtab
	     * claimed the symbol was static. It's possible that
	     * the psymtab gets it wrong in some cases.
	     */
	    block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
	    sym = lookup_block_symbol (block, name, namespace);
	    if (!sym)
	      error ("Internal: static symbol `%s' found in %s psymtab but not in symtab.\n\
d857 7
a863 7
		     name, ps->filename, name, name);
	  }
	if (symtab != NULL)
	  *symtab = s;
	return fixup_symbol_section (sym, objfile);
      }
  }
d881 1
a881 1

d887 16
a902 16
	  /* OK, we found a minimal symbol in spite of not
	   * finding any symbol. There are various possible
	   * explanations for this. One possibility is the symbol
	   * exists in code not compiled -g. Another possibility
	   * is that the 'psymtab' isn't doing its job.
	   * A third possibility, related to #2, is that we were confused 
	   * by name-mangling. For instance, maybe the psymtab isn't
	   * doing its job because it only know about demangled
	   * names, but we were given a mangled name...
	   */

	  /* We first use the address in the msymbol to try to
	   * locate the appropriate symtab. Note that find_pc_symtab()
	   * has a side-effect of doing psymtab-to-symtab expansion,
	   * for the found symtab.
	   */
d910 4
a913 4
	      /* We kept static functions in minimal symbol table as well as
	         in static scope. We want to find them in the symbol table. */
	      if (!sym)
		{
d918 6
a923 7
	      /* If we found one, return it */
	      if (sym)
		{
		  if (symtab != NULL)
		    *symtab = s;
		  return sym;
		}
d926 16
a941 16
	         found in the minimal symbol table
	         but not in the symtab.
	         Fall through and return 0 to use the msymbol 
	         definition of "foo_".
	         (Note that outer code generally follows up a call
	         to this routine with a call to lookup_minimal_symbol(),
	         so a 0 return means we'll just flow into that other routine).

	         This happens for Fortran  "foo_" symbols,
	         which are "foo" in the symtab.

	         This can also happen if "asm" is used to make a
	         regular symbol but not a debugging symbol, e.g.
	         asm(".globl _main");
	         asm("_main:");
	       */
d944 4
a947 4
	  /* If the lookup-by-address fails, try repeating the
	   * entire lookup process with the symbol name from
	   * the msymbol (if different from the original symbol name).
	   */
d984 1
a984 1

d987 1
a987 1
	   pst->objfile->static_psymbols.list + pst->statics_offset);
d989 1
a989 1
  if (global)			/* This means we can use a binary search. */
d995 2
a996 2
         name.  At that point *all* partial symbols with that name
         will be checked against the correct namespace. */
d1008 1
a1008 1
	      ))
d1029 1
a1029 1
	  top++;
d1077 1
a1077 1

d1079 9
a1087 9
  {
    bv = BLOCKVECTOR (s);
    block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
    sym = lookup_block_symbol (block, name, STRUCT_NAMESPACE);
    if (sym && !TYPE_IS_OPAQUE (SYMBOL_TYPE (sym)))
      {
	return SYMBOL_TYPE (sym);
      }
  }
d1090 18
a1107 18
  {
    if (!ps->readin && lookup_partial_symbol (ps, name, 1, STRUCT_NAMESPACE))
      {
	s = PSYMTAB_TO_SYMTAB (ps);
	bv = BLOCKVECTOR (s);
	block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
	sym = lookup_block_symbol (block, name, STRUCT_NAMESPACE);
	if (!sym)
	  {
	    /* This shouldn't be necessary, but as a last resort
	     * try looking in the statics even though the psymtab
	     * claimed the symbol was global. It's possible that
	     * the psymtab gets it wrong in some cases.
	     */
	    block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
	    sym = lookup_block_symbol (block, name, STRUCT_NAMESPACE);
	    if (!sym)
	      error ("Internal: global symbol `%s' found in %s psymtab but not in symtab.\n\
d1110 6
a1115 6
		     name, ps->filename, name, name);
	  }
	if (!TYPE_IS_OPAQUE (SYMBOL_TYPE (sym)))
	  return SYMBOL_TYPE (sym);
      }
  }
d1126 9
a1134 9
  {
    bv = BLOCKVECTOR (s);
    block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
    sym = lookup_block_symbol (block, name, STRUCT_NAMESPACE);
    if (sym && !TYPE_IS_OPAQUE (SYMBOL_TYPE (sym)))
      {
	return SYMBOL_TYPE (sym);
      }
  }
d1137 18
a1154 18
  {
    if (!ps->readin && lookup_partial_symbol (ps, name, 0, STRUCT_NAMESPACE))
      {
	s = PSYMTAB_TO_SYMTAB (ps);
	bv = BLOCKVECTOR (s);
	block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
	sym = lookup_block_symbol (block, name, STRUCT_NAMESPACE);
	if (!sym)
	  {
	    /* This shouldn't be necessary, but as a last resort
	     * try looking in the globals even though the psymtab
	     * claimed the symbol was static. It's possible that
	     * the psymtab gets it wrong in some cases.
	     */
	    block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
	    sym = lookup_block_symbol (block, name, STRUCT_NAMESPACE);
	    if (!sym)
	      error ("Internal: static symbol `%s' found in %s psymtab but not in symtab.\n\
d1157 6
a1162 6
		     name, ps->filename, name, name);
	  }
	if (!TYPE_IS_OPAQUE (SYMBOL_TYPE (sym)))
	  return SYMBOL_TYPE (sym);
      }
  }
d1178 6
a1183 6
  {
    if (lookup_partial_symbol (pst, "main", 1, VAR_NAMESPACE))
      {
	return (pst);
      }
  }
d1214 4
a1217 4
         won't do the linear search once unless we find some reason to
         do so, such as finding a C++ symbol during the binary search.
         Note that for C++ modules, ALL the symbols in a block should
         end up marked as C++ symbols. */
d1238 1
a1238 1
	      ))
d1261 6
a1266 6
         name is greater than NAME, or find one we want.  If there is
         more than one symbol with the right name and namespace, we
         return the first one; I believe it is now impossible for us
         to encounter two symbols with the same name and namespace
         here, because blocks containing argument symbols are no
         longer sorted.  */
d1313 2
a1314 2
	         at the current PC.  If no alias is active at the current
	         PC, then use the main symbol.
d1316 4
a1319 4
	         ?!? Is checking the current pc correct?  Is this routine
	         ever called to look up a symbol from another context?  */
	      if (SYMBOL_ALIASES (sym))
		sym = find_active_alias (sym, read_pc ());
d1346 2
a1347 2
     struct symbol *sym;
     CORE_ADDR addr;
d1358 1
a1358 1
	return aliases->sym;
d1370 1
a1371 1

d1417 3
a1419 3
  {
    bv = BLOCKVECTOR (s);
    b = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
d1421 1
a1421 1
    if (BLOCK_START (b) <= pc
d1423 1
a1423 1
	&& BLOCK_END (b) >= pc
d1425 1
a1425 1
	&& BLOCK_END (b) > pc
d1427 18
a1444 18
	&& (distance == 0
	    || BLOCK_END (b) - BLOCK_START (b) < distance))
      {
	/* For an objfile that has its functions reordered,
	   find_pc_psymtab will find the proper partial symbol table
	   and we simply return its corresponding symtab.  */
	/* In order to better support objfiles that contain both
	   stabs and coff debugging info, we continue on if a psymtab
	   can't be found. */
	if ((objfile->flags & OBJF_REORDERED) && objfile->psymtabs)
	  {
	    ps = find_pc_sect_psymtab (pc, section);
	    if (ps)
	      return PSYMTAB_TO_SYMTAB (ps);
	  }
	if (section != 0)
	  {
	    int i;
d1446 13
a1458 13
	    for (i = 0; i < b->nsyms; i++)
	      {
		fixup_symbol_section (b->sym[i], objfile);
		if (section == SYMBOL_BFD_SECTION (b->sym[i]))
		  break;
	      }
	    if (i >= b->nsyms)
	      continue;		/* no symbol in this symtab matches section */
	  }
	distance = BLOCK_END (b) - BLOCK_START (b);
	best_s = s;
      }
  }
d1461 1
a1461 1
    return (best_s);
d1474 1
a1474 1
		 (unsigned long) pc);
d1489 1
a1490 1

d1521 3
a1523 3
  {
    /* Search the global and static blocks in this symtab for
       the closest symbol-address to the desired address.  */
d1525 14
a1538 27
    for (blocknum = GLOBAL_BLOCK; blocknum <= STATIC_BLOCK; blocknum++)
      {
	QUIT;
	block = BLOCKVECTOR_BLOCK (BLOCKVECTOR (symtab), blocknum);
	top = BLOCK_NSYMS (block);
	for (bot = 0; bot < top; bot++)
	  {
	    sym = BLOCK_SYM (block, bot);
	    switch (SYMBOL_CLASS (sym))
	      {
	      case LOC_STATIC:
	      case LOC_LABEL:
		sym_addr = SYMBOL_VALUE_ADDRESS (sym);
		break;

	      case LOC_INDIRECT:
		sym_addr = SYMBOL_VALUE_ADDRESS (sym);
		/* An indirect symbol really lives at *sym_addr,
		 * so an indirection needs to be done.
		 * However, I am leaving this commented out because it's
		 * expensive, and it's possible that symbolization
		 * could be done without an active process (in
		 * case this read_memory will fail). RT
		 sym_addr = read_memory_unsigned_integer
		 (sym_addr, TARGET_PTR_BIT / TARGET_CHAR_BIT);
		 */
		break;
d1540 12
a1551 3
	      case LOC_BLOCK:
		sym_addr = BLOCK_START (SYMBOL_BLOCK_VALUE (sym));
		break;
d1553 3
a1555 3
	      default:
		continue;
	      }
d1557 2
a1558 9
	    if (sym_addr <= addr)
	      if (sym_addr > best_sym_addr)
		{
		  /* Quit if we found an exact match.  */
		  best_sym = sym;
		  best_sym_addr = sym_addr;
		  best_symtab = symtab;
		  if (sym_addr == addr)
		    goto done;
a1559 3
	  }
      }
  }
d1561 15
a1575 1
done:
d1641 1
a1641 1
  INIT_SAL (&val);		/* initialize to zeroes */
d1646 1
a1646 1
  /* elz: added this because this function returned the wrong
d1651 1
a1651 1
   */
d1653 1
a1653 1

d1690 2
a1691 2
  msymbol = lookup_minimal_symbol_by_pc (pc);
  if (msymbol != NULL)
d1693 22
a1714 22
      {
	mfunsym = lookup_minimal_symbol_text (SYMBOL_NAME (msymbol), NULL, NULL);
	if (mfunsym == NULL)
	  /* I eliminated this warning since it is coming out
	   * in the following situation:
	   * gdb shmain // test program with shared libraries
	   * (gdb) break shr1  // function in shared lib
	   * Warning: In stub for ...
	   * In the above situation, the shared lib is not loaded yet, 
	   * so of course we can't find the real func/line info,
	   * but the "break" still works, and the warning is annoying.
	   * So I commented out the warning. RT */
	  /* warning ("In stub for %s; unable to find real function/line info", SYMBOL_NAME(msymbol)) */ ;
	/* fall through */
	else if (SYMBOL_VALUE (mfunsym) == SYMBOL_VALUE (msymbol))
	  /* Avoid infinite recursion */
	  /* See above comment about why warning is commented out */
	  /* warning ("In stub for %s; unable to find real function/line info", SYMBOL_NAME(msymbol)) */ ;
	/* fall through */
	else
	  return find_pc_line (SYMBOL_VALUE (mfunsym), 0);
      }
d1738 1
a1738 1
	continue;
d1753 1
a1753 1
         If so, record this file, and its first line, as best alternate.  */
d1771 3
a1773 3
         item points at the next line.  If we ran off the end of the linetable
         (pc >= start of the last line), then prev == item.  If pc < start of
         the first line, prev will not be set.  */
d1776 1
a1776 1
         If so, record this file, and its best line, as best so far.  */
d1802 1
a1802 2
	  if (val.line == 0)
	    ++val.line;
d1831 1
a1831 1
  asection *section;
d1838 1
d1840 1
a1840 2

static struct symtab *find_line_symtab PARAMS ((struct symtab *, int,
d1853 1
a1853 1
static struct symtab *
d1876 5
a1880 5
         another symtab with the same name.  In the case of xcoff,
         multiple csects for one source file (produced by IBM's FORTRAN
         compiler) produce multiple symtabs (this is unavoidable
         assuming csects can be at arbitrary places in memory and that
         the GLOBAL_BLOCK of a symtab has a begin and end address).  */
d1883 2
a1884 2
         or 0 if none has been seen so far.
         BEST_INDEX and BEST_LINETABLE identify the item for it.  */
d1896 3
a1898 3
      {
	struct linetable *l;
	int ind;
d1900 22
a1921 22
	if (!STREQ (symtab->filename, s->filename))
	  continue;
	l = LINETABLE (s);
	ind = find_line_common (l, line, &exact);
	if (ind >= 0)
	  {
	    if (exact)
	      {
		best_index = ind;
		best_linetable = l;
		best_symtab = s;
		goto done;
	      }
	    if (best == 0 || l->item[ind].line < best)
	      {
		best = l->item[ind].line;
		best_index = ind;
		best_linetable = l;
		best_symtab = s;
	      }
	  }
      }
d1923 1
a1923 1
done:
d1978 1
a1978 1
  if (startaddr == 0 && !find_line_pc (sal.symtab, sal.line, &startaddr))
d2073 1
a2073 1
find_function_start_sal PARAMS ((struct symbol * sym, int));
d2086 1
a2086 1
    {				/* skip "first line" of function (which is actually its prologue) */
d2089 1
a2089 1
         address, so that SKIP_PROLOGUE has something unique to work on */
d2139 1
a2139 1
  if (isalpha (*p) || *p == '_' || *p == '$' || *p == '\0')
d2148 1
a2148 1
  if (isalpha (*p) || *p == '_' || *p == '$')
d2150 2
a2151 2
      register char *q = p + 1;
      while (isalnum (*q) || *q == '_' || *q == '$')
d2166 1
a2166 1
	*end = p + 2;
d2168 1
a2168 1
	*end = p + 1;
d2177 1
a2177 1
	*end = p + 2;
d2179 1
a2179 1
	*end = p + 1;
d2183 1
a2183 1
      *end = p + 1;
d2188 1
a2188 1
      *end = p + 2;
d2193 1
a2193 1
      *end = p + 2;
d2198 1
a2198 1
      *end = p + 2;
d2213 1
a2213 1
static int total_number_of_methods PARAMS ((struct type * type));
d2256 1
a2256 1
				     (struct block *) NULL,
d2258 2
a2259 2
				     (int *) NULL,
				     (struct symtab **) NULL)))
d2267 2
a2268 2
         are counted as a single name.  There is an inner loop which loops over
         each overload.  */
d2278 1
a2278 1
	  if (strncmp (method_name, "__", 2) == 0 ||
d2281 1
a2281 1
	    {
d2283 1
a2283 1
		method_name = dem_opname;
d2285 2
a2286 2
		method_name = dem_opname;
	    }
d2304 2
a2305 2
						method_counter,
						field_counter);
d2332 1
a2332 1
		     */
d2374 3
a2376 3
  if (s == (struct symtab *) NULL
      || s->filename == (char *) NULL
      || canonical == (char ***) NULL)
d2378 1
a2378 1

d2405 1
a2405 1
   PC returned is the start of the function.
d2407 1
a2407 1
   PC returned is 0.
d2473 1
a2473 1
#define volatile		/*nothing */
d2495 1
a2495 1
  int has_parens;
d2502 2
a2503 2

  INIT_SAL (&val);		/* initialize to zeroes */
d2534 6
a2539 6
  if ((ii = strstr (*argptr, " if ")) != NULL ||
      (ii = strstr (*argptr, "\tif ")) != NULL ||
      (ii = strstr (*argptr, " if\t")) != NULL ||
      (ii = strstr (*argptr, "\tif\t")) != NULL ||
      (ii = strstr (*argptr, " if(")) != NULL ||
      (ii = strstr (*argptr, "\tif( ")) != NULL)
d2545 3
a2547 4
  if (has_if)
    {
      *ii = '\0';
    }
d2561 1
a2561 1
		&& (pp = strchr (pp, ')')) != NULL);
d2572 1
a2572 1
  if ((ii = strchr (*argptr, ',')) != NULL)
d2578 3
a2580 4
  if (has_comma)
    {
      *ii = '\0';
    }
d2594 2
a2595 2
    is_quote_enclosed = 0;
  for (; *p; p++)
d2597 1
a2597 1
      if (p[0] == '<')
d2599 4
a2602 4
	  char *temp_end = find_template_name_end (p);
	  if (!temp_end)
	    error ("malformed template specification in command");
	  p = temp_end;
d2608 6
a2613 6
	  || p[0] == '\t'
	  || ((p[0] == ':')
	      && ((p[1] == ':') || (strchr (p + 1, ':') == NULL)))
	  || ((p[0] == ' ') && !is_quote_enclosed))
	break;
      if (p[0] == '.' && strchr (p, ':') == NULL)	/* Java qualified method. */
d2616 1
a2616 1
	  for (p1 = p; *p1; p1++)
d2624 1
a2624 2
  while (p[0] == ' ' || p[0] == '\t')
    p++;
d2627 1
a2627 1
    if (!*(pp + 1))
d2640 71
a2710 57
      if (is_quoted)
	*argptr = *argptr + 1;
      if (p[0] == '.' || p[1] == ':')
	{
	  int ix;
	  char *saved_arg2 = *argptr;
	  char *temp_end;
	  /* First check for "global" namespace specification,
	     of the form "::foo". If found, skip over the colons
	     and jump to normal symbol processing */
	  if ((*argptr == p) || (p[-1] == ' ') || (p[-1] == '\t'))
	    saved_arg2 += 2;

	  /* We have what looks like a class or namespace
	     scope specification (A::B), possibly with many
	     levels of namespaces or classes (A::B::C::D).

	     Some versions of the HP ANSI C++ compiler (as also possibly
	     other compilers) generate class/function/member names with
	     embedded double-colons if they are inside namespaces. To
	     handle this, we loop a few times, considering larger and
	     larger prefixes of the string as though they were single
	     symbols.  So, if the initially supplied string is
	     A::B::C::D::foo, we have to look up "A", then "A::B",
	     then "A::B::C", then "A::B::C::D", and finally
	     "A::B::C::D::foo" as single, monolithic symbols, because
	     A, B, C or D may be namespaces.

	     Note that namespaces can nest only inside other
	     namespaces, and not inside classes.  So we need only
	     consider *prefixes* of the string; there is no need to look up
	     "B::C" separately as a symbol in the previous example. */

	  p2 = p;		/* save for restart */
	  while (1)
	    {
	      /* Extract the class name.  */
	      p1 = p;
	      while (p != *argptr && p[-1] == ' ')
		--p;
	      copy = (char *) alloca (p - *argptr + 1);
	      memcpy (copy, *argptr, p - *argptr);
	      copy[p - *argptr] = 0;

	      /* Discard the class name from the arg.  */
	      p = p1 + (p1[0] == ':' ? 2 : 1);
	      while (*p == ' ' || *p == '\t')
		p++;
	      *argptr = p;

	      sym_class = lookup_symbol (copy, 0, STRUCT_NAMESPACE, 0,
					 (struct symtab **) NULL);

	      if (sym_class &&
		  (t = check_typedef (SYMBOL_TYPE (sym_class)),
		   (TYPE_CODE (t) == TYPE_CODE_STRUCT
		    || TYPE_CODE (t) == TYPE_CODE_UNION)))
d2712 6
a2717 58
		  /* Arg token is not digits => try it as a function name
		     Find the next token(everything up to end or next blank). */
		  if (**argptr
		      && strchr (gdb_completer_quote_characters, **argptr) != NULL)
		    {
		      p = skip_quoted (*argptr);
		      *argptr = *argptr + 1;
		    }
		  else
		    {
		      p = *argptr;
		      while (*p && *p != ' ' && *p != '\t' && *p != ',' && *p != ':')
			p++;
		    }
/*
   q = operator_chars (*argptr, &q1);
   if (q1 - q)
   {
   char *opname;
   char *tmp = alloca (q1 - q + 1);
   memcpy (tmp, q, q1 - q);
   tmp[q1 - q] = '\0';
   opname = cplus_mangle_opname (tmp, DMGL_ANSI);
   if (opname == NULL)
   {
   error_begin ();
   printf_filtered ("no mangling for \"%s\"\n", tmp);
   cplusplus_hint (saved_arg);
   return_to_top_level (RETURN_ERROR);
   }
   copy = (char*) alloca (3 + strlen(opname));
   sprintf (copy, "__%s", opname);
   p = q1;
   }
   else
 */
		  {
		    copy = (char *) alloca (p - *argptr + 1);
		    memcpy (copy, *argptr, p - *argptr);
		    copy[p - *argptr] = '\0';
		    if (p != *argptr
			&& copy[p - *argptr - 1]
			&& strchr (gdb_completer_quote_characters,
				   copy[p - *argptr - 1]) != NULL)
		      copy[p - *argptr - 1] = '\0';
		  }

		  /* no line number may be specified */
		  while (*p == ' ' || *p == '\t')
		    p++;
		  *argptr = p;

		  sym = 0;
		  i1 = 0;	/*  counter for the symbol array */
		  sym_arr = (struct symbol **) alloca (total_number_of_methods (t)
						* sizeof (struct symbol *));

		  if (destructor_name_p (copy, t))
a2718 54
		      /* Destructors are a special case.  */
		      int m_index, f_index;

		      if (get_destructor_fn_field (t, &m_index, &f_index))
			{
			  struct fn_field *f = TYPE_FN_FIELDLIST1 (t, m_index);

			  sym_arr[i1] =
			    lookup_symbol (TYPE_FN_FIELD_PHYSNAME (f, f_index),
					   NULL, VAR_NAMESPACE, (int *) NULL,
					   (struct symtab **) NULL);
			  if (sym_arr[i1])
			    i1++;
			}
		    }
		  else
		    i1 = find_methods (t, copy, sym_arr);
		  if (i1 == 1)
		    {
		      /* There is exactly one field with that name.  */
		      sym = sym_arr[0];

		      if (sym && SYMBOL_CLASS (sym) == LOC_BLOCK)
			{
			  values.sals = (struct symtab_and_line *)
			    xmalloc (sizeof (struct symtab_and_line));
			  values.nelts = 1;
			  values.sals[0] = find_function_start_sal (sym,
							      funfirstline);
			}
		      else
			{
			  values.nelts = 0;
			}
		      return values;
		    }
		  if (i1 > 0)
		    {
		      /* There is more than one field with that name
		         (overloaded).  Ask the user which one to use.  */
		      return decode_line_2 (sym_arr, i1, funfirstline, canonical);
		    }
		  else
		    {
		      char *tmp;

		      if (OPNAME_PREFIX_P (copy))
			{
			  tmp = (char *) alloca (strlen (copy + 3) + 9);
			  strcpy (tmp, "operator ");
			  strcat (tmp, copy + 3);
			}
		      else
			tmp = copy;
d2720 1
a2720 8
		      if (tmp[0] == '~')
			printf_filtered
			  ("the class `%s' does not have destructor defined\n",
			   SYMBOL_SOURCE_NAME (sym_class));
		      else
			printf_filtered
			  ("the class %s does not have any method named %s\n",
			   SYMBOL_SOURCE_NAME (sym_class), tmp);
d2724 3
d2728 146
a2873 57

	      /* Move pointer up to next possible class/namespace token */
	      p = p2 + 1;	/* restart with old value +1 */
	      /* Move pointer ahead to next double-colon */
	      while (*p && (p[0] != ' ') && (p[0] != '\t') && (p[0] != '\''))
		{
		  if (p[0] == '<')
		    {
		      temp_end = find_template_name_end (p);
		      if (!temp_end)
			error ("malformed template specification in command");
		      p = temp_end;
		    }
		  else if ((p[0] == ':') && (p[1] == ':'))
		    break;	/* found double-colon */
		  else
		    p++;
		}

	      if (*p != ':')
		break;		/* out of the while (1) */

	      p2 = p;		/* save restart for next time around */
	      *argptr = saved_arg2;	/* restore argptr */
	    }			/* while (1) */

	  /* Last chance attempt -- check entire name as a symbol */
	  /* Use "copy" in preparation for jumping out of this block,
	     to be consistent with usage following the jump target */
	  copy = (char *) alloca (p - saved_arg2 + 1);
	  memcpy (copy, saved_arg2, p - saved_arg2);
	  /* Note: if is_quoted should be true, we snuff out quote here anyway */
	  copy[p - saved_arg2] = '\000';
	  /* Set argptr to skip over the name */
	  *argptr = (*p == '\'') ? p + 1 : p;
	  /* Look up entire name */
	  sym = lookup_symbol (copy, 0, VAR_NAMESPACE, 0, &sym_symtab);
	  s = (struct symtab *) 0;
	  /* Prepare to jump: restore the " if (condition)" so outer layers see it */
	  /* Symbol was found --> jump to normal symbol processing.
	     Code following "symbol_found" expects "copy" to have the
	     symbol name, "sym" to have the symbol pointer, "s" to be
	     a specified file's symtab, and sym_symtab to be the symbol's
	     symtab. */
	  /* By jumping there we avoid falling through the FILE:LINE and
	     FILE:FUNC processing stuff below */
	  if (sym)
	    goto symbol_found;

	  /* Couldn't find any interpretation as classes/namespaces, so give up */
	  error_begin ();
	  /* The quotes are important if copy is empty.  */
	  printf_filtered
	    ("Can't find member of namespace, class, struct, or union named \"%s\"\n", copy);
	  cplusplus_hint (saved_arg);
	  return_to_top_level (RETURN_ERROR);
	}
d2879 2
a2880 4
      while (p != *argptr && p[-1] == ' ')
	--p;
      if ((*p == '"') && is_quote_enclosed)
	--p;
d2883 8
a2890 8
	{
	  memcpy (copy, *argptr + 1, p - *argptr - 1);
	  /* It may have the ending quote right after the file name */
	  if (copy[p - *argptr - 2] == '"')
	    copy[p - *argptr - 2] = 0;
	  else
	    copy[p - *argptr - 1] = 0;
	}
d2892 4
a2895 4
	{
	  memcpy (copy, *argptr, p - *argptr);
	  copy[p - *argptr] = 0;
	}
d2908 1
a2908 2
      while (*p == ' ' || *p == '\t')
	p++;
d2919 2
a2920 3
  else
    {
      /* Check if what we have till now is a symbol name */
d2922 19
a2940 23
      /* We may be looking at a template instantiation such
         as "foo<int>".  Check here whether we know about it,
         instead of falling through to the code below which
         handles ordinary function names, because that code
         doesn't like seeing '<' and '>' in a name -- the
         skip_quoted call doesn't go past them.  So see if we
         can figure it out right now. */

      copy = (char *) alloca (p - *argptr + 1);
      memcpy (copy, *argptr, p - *argptr);
      copy[p - *argptr] = '\000';
      sym = lookup_symbol (copy, 0, VAR_NAMESPACE, 0, &sym_symtab);
      if (sym)
	{
	  /* Yes, we have a symbol; jump to symbol processing */
	  /* Code after symbol_found expects S, SYM_SYMTAB, SYM, 
	     and COPY to be set correctly */
	  *argptr = (*p == '\'') ? p + 1 : p;
	  s = (struct symtab *) 0;
	  goto symbol_found;
	}
      /* Otherwise fall out from here and go to file/line spec
         processing, etc. */
d2942 3
d2953 1
a2953 2
  if (*q == '-' || *q == '+')
    q++;
d2960 1
a2960 5
      enum sign
	{
	  none, plus, minus
	}
      sign = none;
d2966 3
a2968 3
         We must guarantee that this section of code is never executed
         when we are called with just a function name, since
         select_source_symtab calls us with such an argument  */
d2999 1
a2999 1
	  break;		/* No need to adjust val.line.  */
d3002 1
a3002 2
      while (*q == ' ' || *q == '\t')
	q++;
d3008 2
a3009 2
         and that the new line number specification has moved us from the
         default (in s) to a new one.  */
d3013 1
a3013 1

d3028 1
a3028 1
    p = skip_quoted (*argptr + (((*argptr)[1] == '$') ? 2 : 1));	/* One or two $ chars possible */
d3033 1
a3033 1
	error ("Unmatched single quote.");
d3037 1
a3037 1
      p = pp + 1;
d3039 1
a3039 1
  else
d3041 1
a3041 1
      p = skip_quoted (*argptr);
d3049 1
a3049 1
      && copy[0] == copy[p - *argptr - 1]
d3052 1
a3052 1
      copy[p - *argptr - 1] = '\0';
d3055 1
a3055 2
  while (*p == ' ' || *p == '\t')
    p++;
d3060 1
a3060 1
     be history value, or it may be a convenience variable */
d3070 38
a3107 38
	p++;
      if (!*p)			/* reached end of token without hitting non-digit */
	{
	  /* We have a value history reference */
	  sscanf ((copy[1] == '$') ? copy + 2 : copy + 1, "%d", &index);
	  valx = access_value_history ((copy[1] == '$') ? -index : index);
	  if (TYPE_CODE (VALUE_TYPE (valx)) != TYPE_CODE_INT)
	    error ("History values used in line specs must have integer values.");
	}
      else
	{
	  /* Not all digits -- may be user variable/function or a
	     convenience variable */

	  /* Look up entire name as a symbol first */
	  sym = lookup_symbol (copy, 0, VAR_NAMESPACE, 0, &sym_symtab);
	  s = (struct symtab *) 0;
	  need_canonical = 1;
	  /* Symbol was found --> jump to normal symbol processing.
	     Code following "symbol_found" expects "copy" to have the
	     symbol name, "sym" to have the symbol pointer, "s" to be
	     a specified file's symtab, and sym_symtab to be the symbol's
	     symtab. */
	  if (sym)
	    goto symbol_found;

	  /* If symbol was not found, look in minimal symbol tables */
	  msymbol = lookup_minimal_symbol (copy, 0, 0);
	  /* Min symbol was found --> jump to minsym processing. */
	  if (msymbol)
	    goto minimal_symbol_found;

	  /* Not a user variable or function -- must be convenience variable */
	  need_canonical = (s == 0) ? 1 : 0;
	  valx = value_of_internalvar (lookup_internalvar (copy + 1));
	  if (TYPE_CODE (VALUE_TYPE (valx)) != TYPE_CODE_INT)
	    error ("Convenience variables used in line specs must have integer values.");
	}
d3109 1
a3109 1
      /* Either history value or convenience value from above, in valx */
d3114 1
a3114 1
      values.sals = (struct symtab_and_line *) xmalloc (sizeof val);
d3132 3
a3134 3

symbol_found:			/* We also jump here from inside the C++ class/namespace 
				   code on finding a symbol of the form "A::B::C" */
d3188 3
a3190 3
minimal_symbol_found:		/* We also jump here from the case for variables
				   that begin with '$' */

d3195 2
a3196 2
      values.sals[0] = find_pc_sect_line (SYMBOL_VALUE_ADDRESS (msymbol),
					  (struct sec *) 0, 0);
d3212 1
a3212 1
  return values;		/* for lint */
d3225 1
a3225 1
			(char ***) NULL);
d3249 1
a3249 1
  char **canonical_arr = (char **) NULL;
d3251 4
a3254 4
  values.sals = (struct symtab_and_line *)
    alloca (nelts * sizeof (struct symtab_and_line));
  return_values.sals = (struct symtab_and_line *)
    xmalloc (nelts * sizeof (struct symtab_and_line));
d3266 1
a3266 1
  printf_unfiltered ("[0] cancel\n[1] all\n");
d3275 1
a3275 1
			     (i + 2),
d3284 1
a3284 1

d3290 1
a3290 1

d3300 1
a3300 2
      while (*arg1 >= '0' && *arg1 <= '9')
	arg1++;
d3314 1
a3314 1
		  if (canonical_arr[i] == NULL)
d3317 1
a3317 1
		      canonical_arr[i] = savestring (symname, strlen (symname));
d3322 1
a3322 1
		  (nelts * sizeof (struct symtab_and_line)));
d3353 1
a3353 2
      while (*args == ' ' || *args == '\t')
	args++;
d3359 1
a3360 1

d3418 1
a3418 1
}
d3429 1
a3429 1

d3434 1
a3434 1

d3439 3
a3441 3
  {
    output_source_filename (s->filename, &first);
  }
d3443 1
a3443 1

d3448 6
a3453 6
  {
    if (!ps->readin)
      {
	output_source_filename (ps->filename, &first);
      }
  }
d3468 4
a3471 4
	{
	  if (strcmp (files[i], basename (file)) == 0)
	    return 1;
	}
d3497 5
a3501 5
   FUNCTIONS_NAMESPACE - search all functions
   TYPES_NAMESPACE     - search all type names
   METHODS_NAMESPACE   - search all methods NOT IMPLEMENTED
   VARIABLES_NAMESPACE - search all symbols, excluding functions, type names,
   and constants (enums)
d3504 1
a3504 1
 */
d3512 1
a3512 1

d3528 1
a3528 2
  =
  {mst_data, mst_text, mst_abs, mst_unknown};
d3530 1
a3530 2
  =
  {mst_bss, mst_file_text, mst_abs, mst_unknown};
d3532 1
a3532 2
  =
  {mst_file_data, mst_solib_trampoline, mst_abs, mst_unknown};
d3534 1
a3534 2
  =
  {mst_file_bss, mst_text, mst_abs, mst_unknown};
d3564 23
a3586 23
	{
	  int fix = -1;		/* -1 means ok; otherwise number of spaces needed. */
	  if (isalpha (*opname) || *opname == '_' || *opname == '$')
	    {
	      /* There should 1 space between 'operator' and 'TYPENAME'. */
	      if (opname[-1] != ' ' || opname[-2] == ' ')
		fix = 1;
	    }
	  else
	    {
	      /* There should 0 spaces between 'operator' and 'OPERATOR'. */
	      if (opname[-1] == ' ')
		fix = 0;
	    }
	  /* If wrong number of spaces, fix it. */
	  if (fix >= 0)
	    {
	      char *tmp = (char *) alloca (opend - opname + 10);
	      sprintf (tmp, "operator%.*s%s", fix, " ", opname);
	      regexp = tmp;
	    }
	}

d3588 1
a3588 1
	error ("Invalid regexp (%s): %s", val, regexp);
d3596 3
a3598 3
  {
    struct partial_symbol **bound, **gbound, **sbound;
    int keep_going = 1;
d3600 1
a3600 2
    if (ps->readin)
      continue;
d3602 41
a3642 41
    gbound = objfile->global_psymbols.list + ps->globals_offset + ps->n_global_syms;
    sbound = objfile->static_psymbols.list + ps->statics_offset + ps->n_static_syms;
    bound = gbound;

    /* Go through all of the symbols stored in a partial
       symtab in one loop. */
    psym = objfile->global_psymbols.list + ps->globals_offset;
    while (keep_going)
      {
	if (psym >= bound)
	  {
	    if (bound == gbound && ps->n_static_syms != 0)
	      {
		psym = objfile->static_psymbols.list + ps->statics_offset;
		bound = sbound;
	      }
	    else
	      keep_going = 0;
	    continue;
	  }
	else
	  {
	    QUIT;

	    /* If it would match (logic taken from loop below)
	       load the file and go on to the next one */
	    if (file_matches (ps->filename, files, nfiles)
		&& ((regexp == NULL || SYMBOL_MATCHES_REGEXP (*psym))
		    && ((kind == VARIABLES_NAMESPACE && SYMBOL_CLASS (*psym) != LOC_TYPEDEF
			 && SYMBOL_CLASS (*psym) != LOC_BLOCK)
			|| (kind == FUNCTIONS_NAMESPACE && SYMBOL_CLASS (*psym) == LOC_BLOCK)
			|| (kind == TYPES_NAMESPACE && SYMBOL_CLASS (*psym) == LOC_TYPEDEF)
			|| (kind == METHODS_NAMESPACE && SYMBOL_CLASS (*psym) == LOC_BLOCK))))
	      {
		PSYMTAB_TO_SYMTAB (ps);
		keep_going = 0;
	      }
	  }
	psym++;
      }
  }
d3655 1
a3655 1
   */
d3660 20
a3679 20
      {
	if (MSYMBOL_TYPE (msymbol) == ourtype ||
	    MSYMBOL_TYPE (msymbol) == ourtype2 ||
	    MSYMBOL_TYPE (msymbol) == ourtype3 ||
	    MSYMBOL_TYPE (msymbol) == ourtype4)
	  {
	    if (regexp == NULL || SYMBOL_MATCHES_REGEXP (msymbol))
	      {
		if (0 == find_pc_symtab (SYMBOL_VALUE_ADDRESS (msymbol)))
		  {
		    if (kind == FUNCTIONS_NAMESPACE
			|| lookup_symbol (SYMBOL_NAME (msymbol),
					  (struct block *) NULL,
					  VAR_NAMESPACE,
					0, (struct symtab **) NULL) == NULL)
		      found_misc = 1;
		  }
	      }
	  }
      }
d3683 48
a3730 48
  {
    bv = BLOCKVECTOR (s);
    /* Often many files share a blockvector.
       Scan each blockvector only once so that
       we don't get every symbol many times.
       It happens that the first symtab in the list
       for any given blockvector is the main file.  */
    if (bv != prev_bv)
      for (i = GLOBAL_BLOCK; i <= STATIC_BLOCK; i++)
	{
	  b = BLOCKVECTOR_BLOCK (bv, i);
	  /* Skip the sort if this block is always sorted.  */
	  if (!BLOCK_SHOULD_SORT (b))
	    sort_block_syms (b);
	  for (j = 0; j < BLOCK_NSYMS (b); j++)
	    {
	      QUIT;
	      sym = BLOCK_SYM (b, j);
	      if (file_matches (s->filename, files, nfiles)
		  && ((regexp == NULL || SYMBOL_MATCHES_REGEXP (sym))
		      && ((kind == VARIABLES_NAMESPACE && SYMBOL_CLASS (sym) != LOC_TYPEDEF
			   && SYMBOL_CLASS (sym) != LOC_BLOCK
			   && SYMBOL_CLASS (sym) != LOC_CONST)
			  || (kind == FUNCTIONS_NAMESPACE && SYMBOL_CLASS (sym) == LOC_BLOCK)
			  || (kind == TYPES_NAMESPACE && SYMBOL_CLASS (sym) == LOC_TYPEDEF)
			  || (kind == METHODS_NAMESPACE && SYMBOL_CLASS (sym) == LOC_BLOCK))))
		{
		  /* match */
		  psr = (struct symbol_search *) xmalloc (sizeof (struct symbol_search));
		  psr->block = i;
		  psr->symtab = s;
		  psr->symbol = sym;
		  psr->msymbol = NULL;
		  psr->next = NULL;
		  if (tail == NULL)
		    {
		      sr = psr;
		      old_chain = make_cleanup ((make_cleanup_func)
						free_search_symbols, sr);
		    }
		  else
		    tail->next = psr;
		  tail = psr;
		}
	    }
	}
    prev_bv = bv;
  }
d3738 38
a3775 38
      {
	if (MSYMBOL_TYPE (msymbol) == ourtype ||
	    MSYMBOL_TYPE (msymbol) == ourtype2 ||
	    MSYMBOL_TYPE (msymbol) == ourtype3 ||
	    MSYMBOL_TYPE (msymbol) == ourtype4)
	  {
	    if (regexp == NULL || SYMBOL_MATCHES_REGEXP (msymbol))
	      {
		/* Functions:  Look up by address. */
		if (kind != FUNCTIONS_NAMESPACE ||
		    (0 == find_pc_symtab (SYMBOL_VALUE_ADDRESS (msymbol))))
		  {
		    /* Variables/Absolutes:  Look up by name */
		    if (lookup_symbol (SYMBOL_NAME (msymbol),
				       (struct block *) NULL, VAR_NAMESPACE,
				       0, (struct symtab **) NULL) == NULL)
		      {
			/* match */
			psr = (struct symbol_search *) xmalloc (sizeof (struct symbol_search));
			psr->block = i;
			psr->msymbol = msymbol;
			psr->symtab = NULL;
			psr->symbol = NULL;
			psr->next = NULL;
			if (tail == NULL)
			  {
			    sr = psr;
			    old_chain = make_cleanup ((make_cleanup_func)
						  free_search_symbols, &sr);
			  }
			else
			  tail->next = psr;
			tail = psr;
		      }
		  }
	      }
	  }
      }
d3786 1
a3786 1
 */
d3804 1
a3804 1

d3808 1
a3808 1
    c_typedef_print (SYMBOL_TYPE (sym), sym, gdb_stdout);
d3810 3
a3812 3
  else if (kind < TYPES_NAMESPACE ||
	   (kind == TYPES_NAMESPACE &&
	    SYMBOL_NAMESPACE (sym) == STRUCT_NAMESPACE))
d3815 3
a3817 3
		  (SYMBOL_CLASS (sym) == LOC_TYPEDEF
		   ? "" : SYMBOL_SOURCE_NAME (sym)),
		  gdb_stdout, 0);
d3823 1
a3823 1
#if 0
d3826 4
a3829 4
      c_type_print_base (TYPE_FN_FIELD_TYPE (t, block),
			 gdb_stdout, 0, 0);
      c_type_print_varspec_prefix (TYPE_FN_FIELD_TYPE (t, block),
				   gdb_stdout, 0);
d3831 1
a3831 1
	check_stub_method (TYPE_DOMAIN_TYPE (type), j, block);
d3833 2
a3834 2
	cplus_demangle (TYPE_FN_FIELD_PHYSNAME (t, block),
			DMGL_ANSI | DMGL_PARAMS);
d3836 2
a3837 2
	fprintf_filtered (stream, "<badly mangled name %s>",
			  TYPE_FN_FIELD_PHYSNAME (t, block));
d3839 5
a3843 5
	{
	  fputs_filtered (demangled_name, stream);
	  free (demangled_name);
	}
#endif
d3849 1
a3849 1
 */
d3855 2
a3856 2
		   (unsigned long) SYMBOL_VALUE_ADDRESS (msymbol),
		   SYMBOL_SOURCE_NAME (msymbol));
d3863 1
a3863 1
 */
d3868 1
a3868 1
     int from_tty;
d3871 1
a3871 2
  =
  {"variable", "function", "type", "method"};
d3883 3
a3885 3
		   ? "All %ss matching regular expression \"%s\":\n"
		   : "All defined %ss:\n",
		   classnames[(int) (kind - LABEL_NAMESPACE - 1)], regexp);
d3892 8
a3899 8
	{
	  if (first)
	    {
	      printf_filtered ("\nNon-debugging symbols:\n");
	      first = 0;
	    }
	  print_msymbol_info (p->msymbol);
	}
d3901 8
a3908 8
	{
	  print_symbol_info (kind,
			     p->symtab,
			     p->symbol,
			     p->block,
			     last_filename);
	  last_filename = p->symtab->filename;
	}
d3964 15
a3978 15
	{
	  char *string = (char *) alloca (strlen (p->symtab->filename)
					  + strlen (SYMBOL_NAME (p->symbol))
					  + 4);
	  strcpy (string, p->symtab->filename);
	  strcat (string, ":'");
	  strcat (string, SYMBOL_NAME (p->symbol));
	  strcat (string, "'");
	  break_command (string, from_tty);
	  print_symbol_info (FUNCTIONS_NAMESPACE,
			     p->symtab,
			     p->symbol,
			     p->block,
			     p->symtab->filename);
	}
d3980 5
a3984 5
	{
	  break_command (SYMBOL_NAME (p->msymbol), from_tty);
	  printf_filtered ("<function, no debug info> %s;\n",
			   SYMBOL_SOURCE_NAME (p->msymbol));
	}
d3989 1
a3990 1

d4001 1
a4001 1
    && BLOCK_END (a) <= BLOCK_END (b);
d4003 1
a4004 1

d4025 2
a4026 2
   demangled for C++ symbols) matches SYM_TEXT in the first SYM_TEXT_LEN
   characters.  If so, add it to the current completion list. */
d4056 1
a4056 1

d4148 1
a4148 1
	         doesn't end the string.  */
d4162 1
a4162 1
         to complete it any other way.  */
d4190 24
a4213 25
  {
    /* If the psymtab's been read in we'll get it when we search
       through the blockvector.  */
    if (ps->readin)
      continue;

    for (psym = objfile->global_psymbols.list + ps->globals_offset;
	 psym < (objfile->global_psymbols.list + ps->globals_offset
		 + ps->n_global_syms);
	 psym++)
      {
	/* If interrupted, then quit. */
	QUIT;
	COMPLETION_LIST_ADD_SYMBOL (*psym, sym_text, sym_text_len, text, word);
      }

    for (psym = objfile->static_psymbols.list + ps->statics_offset;
	 psym < (objfile->static_psymbols.list + ps->statics_offset
		 + ps->n_static_syms);
	 psym++)
      {
	QUIT;
	COMPLETION_LIST_ADD_SYMBOL (*psym, sym_text, sym_text_len, text, word);
      }
  }
d4221 4
a4224 4
  {
    QUIT;
    COMPLETION_LIST_ADD_SYMBOL (msymbol, sym_text, sym_text_len, text, word);
  }
d4233 1
a4233 1
	  surrounding_static_block = b;		/* For elmin of dups */
d4235 1
a4235 1

d4237 1
a4237 1
         text string.  Only complete on types visible from current context. */
d4255 1
a4255 1
					sym_text, sym_text_len, text, word);
d4267 9
a4275 9
  {
    QUIT;
    b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), GLOBAL_BLOCK);
    for (i = 0; i < BLOCK_NSYMS (b); i++)
      {
	sym = BLOCK_SYM (b, i);
	COMPLETION_LIST_ADD_SYMBOL (sym, sym_text, sym_text_len, text, word);
      }
  }
d4278 11
a4288 12
  {
    QUIT;
    b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), STATIC_BLOCK);
    /* Don't do this block twice.  */
    if (b == surrounding_static_block)
      continue;
    for (i = 0; i < BLOCK_NSYMS (b); i++)
      {
	sym = BLOCK_SYM (b, i);
	COMPLETION_LIST_ADD_SYMBOL (sym, sym_text, sym_text_len, text, word);
      }
  }
d4331 1
a4331 1
nosyms:
d4336 1
a4336 2
  if (!func_start)
    return 1;
d4356 2
a4357 2
   demangled for C++ symbols) matches SYM_TEXT in the first SYM_TEXT_LEN
   characters.  If so, add it to the current completion list. */
d4361 2
a4362 2
     struct symbol *sym;
     char *oload_name;
d4368 1
a4368 1
  char *sym_name = cplus_demangle (SYMBOL_NAME (sym), DMGL_ARM | DMGL_ANSI);
d4397 1
a4397 1

d4409 1
a4409 1
     struct symbol *fsym;
d4454 24
a4477 25
  {
    /* If the psymtab's been read in we'll get it when we search
       through the blockvector.  */
    if (ps->readin)
      continue;

    for (psym = objfile->global_psymbols.list + ps->globals_offset;
	 psym < (objfile->global_psymbols.list + ps->globals_offset
		 + ps->n_global_syms);
	 psym++)
      {
	/* If interrupted, then quit. */
	QUIT;
	overload_list_add_symbol (*psym, oload_name);
      }

    for (psym = objfile->static_psymbols.list + ps->statics_offset;
	 psym < (objfile->static_psymbols.list + ps->statics_offset
		 + ps->n_static_syms);
	 psym++)
      {
	QUIT;
	overload_list_add_symbol (*psym, oload_name);
      }
  }
d4485 4
a4488 4
  {
    QUIT;
    overload_list_add_symbol (msymbol, oload_name);
  }
d4498 1
a4498 1
	  surrounding_static_block = b;		/* For elimination of dups */
d4500 1
a4500 1

d4502 1
a4502 1
         text string.  Only complete on types visible from current context. */
d4515 9
a4523 9
  {
    QUIT;
    b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), GLOBAL_BLOCK);
    for (i = 0; i < BLOCK_NSYMS (b); i++)
      {
	sym = BLOCK_SYM (b, i);
	overload_list_add_symbol (sym, oload_name);
      }
  }
d4526 11
a4536 12
  {
    QUIT;
    b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), STATIC_BLOCK);
    /* Don't do this block twice.  */
    if (b == surrounding_static_block)
      continue;
    for (i = 0; i < BLOCK_NSYMS (b); i++)
      {
	sym = BLOCK_SYM (b, i);
	overload_list_add_symbol (sym, oload_name);
      }
  }
d4544 1
a4545 1

d4550 1
a4550 1
	 "All global and static variable names, or those matching REGEXP.");
d4552 2
a4553 2
    add_com ("whereis", class_info, variables_info,
	 "All global and static variable names, or those matching REGEXP.");
d4561 3
a4563 3
     typedef struct foo *FOO
     type_print prints "FOO" when we want to make it (in this situation)
     print "struct foo *".
d4580 1
a4580 1
	   "Set a breakpoint for all functions matching REGEXP.");
d4586 1
a4586 1
	 "All global and static variable names, or those matching REGEXP.");
@


1.1.1.8
log
@import gdb-1999-08-02 snapshot
@
text
@d1322 1
a1322 15
	         ever called to look up a symbol from another context?

		 FIXME: No, it's not correct.  If someone sets a
		 conditional breakpoint at an address, then the
		 breakpoint's `struct expression' should refer to the
		 `struct symbol' appropriate for the breakpoint's
		 address, which may not be the PC.

		 Even if it were never called from another context,
		 it's totally bizarre for lookup_symbol's behavior to
		 depend on the value of the inferior's current PC.  We
		 should pass in the appropriate PC as well as the
		 block.  The interface to lookup_symbol should change
		 to require the caller to provide a PC.  */

@


1.1.1.9
log
@import gdb-1999-09-08 snapshot
@
text
@d1076 1
d2667 1
d4467 1
a4468 1
  register struct minimal_symbol *msymbol;
d4470 2
a4471 1
  register int i;
a4507 2
    struct partial_symbol **psym;

@


1.1.1.10
log
@import gdb-1999-09-21
@
text
@d399 3
d403 1
d422 3
d426 1
d1440 3
d1444 1
d2581 1
a2581 1
		&& (pp = strrchr (pp, ')')) != NULL);
@


1.1.1.11
log
@import gdb-1999-10-18 snapshot
@
text
@d4416 1
a4416 4
    {
      free (sym_name);
      return;
    }
d4478 10
d4489 1
a4489 1
     by matching OLOAD_NAME.  Make sure we read that symbol table in. */
d4507 1
a4507 2
        /* This will cause the symbol table to be read if it has not yet been */
        s = PSYMTAB_TO_SYMTAB (ps);
d4516 1
a4516 2
        /* This will cause the symbol table to be read if it has not yet been */
        s = PSYMTAB_TO_SYMTAB (ps);
d4519 12
@


1.1.1.12
log
@import gdb-2000-01-31 snapshot
@
text
@a2402 37


/* Find an instance of the character C in the string S that is outside
   of all parenthesis pairs, single-quoted strings, and double-quoted
   strings.  */
static char *
find_toplevel_char (char *s, char c)
{
  int quoted = 0;		/* zero if we're not in quotes;
				   '"' if we're in a double-quoted string;
				   '\'' if we're in a single-quoted string.  */
  int depth = 0;		/* number of unclosed parens we've seen */
  char *scan;

  for (scan = s; *scan; scan++)
    {
      if (quoted)
	{
	  if (*scan == quoted)
	    quoted = 0;
	  else if (*scan == '\\' && *(scan + 1))
	    scan++;
	}
      else if (*scan == c && ! quoted && depth == 0)
	return scan;
      else if (*scan == '"' || *scan == '\'')
	quoted = *scan;
      else if (*scan == '(')
	depth++;
      else if (*scan == ')' && depth > 0)
	depth--;
    }

  return 0;
}


d2579 3
a2581 8
     for the second half.

     Don't count commas that appear in argument lists of overloaded
     functions, or in quoted strings.  It's stupid to go to this much
     trouble when the rest of the function is such an obvious roach hotel.  */
  ii = find_toplevel_char (*argptr, ',');
  has_comma = (ii != 0);

a2634 1

d2636 3
a2638 6
  if (is_quote_enclosed)
    {
      char *closing_quote = strchr (p, '"');
      if (closing_quote && closing_quote[1] == '\0')
	*closing_quote = '\0';
    }
a3069 3

  if (is_quote_enclosed && **argptr == '"')
    (*argptr)++;
@


1.1.1.13
log
@import gdb-2000-02-02 snapshot
@
text
@a4033 9
#ifdef UI_OUT
void
rbreak_command_wrapper (regexp, from_tty)
     char *regexp;
     int from_tty;
{
  rbreak_command (regexp, from_tty);
}
#endif
@


