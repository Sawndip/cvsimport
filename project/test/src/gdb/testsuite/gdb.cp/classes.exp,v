head	1.36;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.36
	gdb_7_6-2013-04-26-release:1.36
	gdb_7_6-branch:1.36.0.2
	gdb_7_6-2013-03-12-branchpoint:1.36
	gdb_7_5_1-2012-11-29-release:1.34
	gdb_7_5-2012-08-17-release:1.34
	gdb_7_5-branch:1.34.0.2
	gdb_7_5-2012-07-18-branchpoint:1.34
	gdb_7_4_1-2012-04-26-release:1.30.4.1
	gdb_7_4-2012-01-24-release:1.30.4.1
	gdb_7_4-branch:1.30.0.4
	gdb_7_4-2011-12-13-branchpoint:1.30
	gdb_7_3_1-2011-09-04-release:1.30
	gdb_7_3-2011-07-26-release:1.30
	gdb_7_3-branch:1.30.0.2
	gdb_7_3-2011-04-01-branchpoint:1.30
	gdb_7_2-2010-09-02-release:1.29
	gdb_7_2-branch:1.29.0.2
	gdb_7_2-2010-07-07-branchpoint:1.29
	gdb_7_1-2010-03-18-release:1.24
	gdb_7_1-branch:1.24.0.2
	gdb_7_1-2010-02-18-branchpoint:1.24
	gdb_7_0_1-2009-12-22-release:1.21
	gdb_7_0-2009-10-06-release:1.21
	gdb_7_0-branch:1.21.0.4
	gdb_7_0-2009-09-16-branchpoint:1.21
	arc-sim-20090309:1.19
	msnyder-checkpoint-072509-branch:1.21.0.2
	msnyder-checkpoint-072509-branchpoint:1.21
	arc-insight_6_8-branch:1.19.0.10
	arc-insight_6_8-branchpoint:1.19
	insight_6_8-branch:1.19.0.8
	insight_6_8-branchpoint:1.19
	reverse-20081226-branch:1.20.0.6
	reverse-20081226-branchpoint:1.20
	multiprocess-20081120-branch:1.20.0.4
	multiprocess-20081120-branchpoint:1.20
	reverse-20080930-branch:1.20.0.2
	reverse-20080930-branchpoint:1.20
	reverse-20080717-branch:1.19.0.6
	reverse-20080717-branchpoint:1.19
	msnyder-reverse-20080609-branch:1.19.0.4
	msnyder-reverse-20080609-branchpoint:1.19
	drow-reverse-20070409-branch:1.16.0.2
	drow-reverse-20070409-branchpoint:1.16
	gdb_6_8-2008-03-27-release:1.19
	gdb_6_8-branch:1.19.0.2
	gdb_6_8-2008-02-26-branchpoint:1.19
	gdb_6_7_1-2007-10-29-release:1.17
	gdb_6_7-2007-10-10-release:1.17
	gdb_6_7-branch:1.17.0.2
	gdb_6_7-2007-09-07-branchpoint:1.17
	insight_6_6-20070208-release:1.14
	gdb_6_6-2006-12-18-release:1.14
	gdb_6_6-branch:1.14.0.2
	gdb_6_6-2006-11-15-branchpoint:1.14
	insight_6_5-20061003-release:1.13
	gdb-csl-symbian-6_4_50_20060226-12:1.13
	gdb-csl-sourcerygxx-3_4_4-25:1.13
	nickrob-async-20060828-mergepoint:1.14
	gdb-csl-symbian-6_4_50_20060226-11:1.13
	gdb-csl-sourcerygxx-4_1-17:1.13
	gdb-csl-20060226-branch-local-2:1.13
	gdb-csl-sourcerygxx-4_1-14:1.13
	gdb-csl-sourcerygxx-4_1-13:1.13
	gdb-csl-sourcerygxx-4_1-12:1.13
	gdb-csl-sourcerygxx-3_4_4-21:1.13
	gdb_6_5-20060621-release:1.13
	gdb-csl-sourcerygxx-4_1-9:1.13
	gdb-csl-sourcerygxx-4_1-8:1.13
	gdb-csl-sourcerygxx-4_1-7:1.13
	gdb-csl-arm-2006q1-6:1.13
	gdb-csl-sourcerygxx-4_1-6:1.13
	gdb-csl-symbian-6_4_50_20060226-10:1.13
	gdb-csl-symbian-6_4_50_20060226-9:1.13
	gdb-csl-symbian-6_4_50_20060226-8:1.13
	gdb-csl-coldfire-4_1-11:1.13
	gdb-csl-sourcerygxx-3_4_4-19:1.13
	gdb-csl-coldfire-4_1-10:1.13
	gdb_6_5-branch:1.13.0.28
	gdb_6_5-2006-05-14-branchpoint:1.13
	gdb-csl-sourcerygxx-4_1-5:1.13
	nickrob-async-20060513-branch:1.13.0.26
	nickrob-async-20060513-branchpoint:1.13
	gdb-csl-sourcerygxx-4_1-4:1.13
	msnyder-reverse-20060502-branch:1.13.0.24
	msnyder-reverse-20060502-branchpoint:1.13
	gdb-csl-morpho-4_1-4:1.13
	gdb-csl-sourcerygxx-3_4_4-17:1.13
	readline_5_1-import-branch:1.13.0.22
	readline_5_1-import-branchpoint:1.13
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.13
	gdb-csl-symbian-20060226-branch:1.13.0.20
	gdb-csl-symbian-20060226-branchpoint:1.13
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.13
	msnyder-reverse-20060331-branch:1.13.0.18
	msnyder-reverse-20060331-branchpoint:1.13
	gdb-csl-available-20060303-branch:1.13.0.16
	gdb-csl-available-20060303-branchpoint:1.13
	gdb-csl-20060226-branch:1.13.0.14
	gdb-csl-20060226-branchpoint:1.13
	gdb_6_4-20051202-release:1.13
	msnyder-fork-checkpoint-branch:1.13.0.12
	msnyder-fork-checkpoint-branchpoint:1.13
	gdb-csl-gxxpro-6_3-branch:1.13.0.10
	gdb-csl-gxxpro-6_3-branchpoint:1.13
	gdb_6_4-branch:1.13.0.8
	gdb_6_4-2005-11-01-branchpoint:1.13
	gdb-csl-arm-20051020-branch:1.13.0.6
	gdb-csl-arm-20051020-branchpoint:1.13
	gdb-csl-arm-20050325-2005-q1b:1.13
	gdb-csl-arm-20050325-2005-q1a:1.13
	csl-arm-20050325-branch:1.13.0.4
	csl-arm-20050325-branchpoint:1.13
	gdb-post-i18n-errorwarning-20050211:1.13
	gdb-pre-i18n-errorwarning-20050211:1.13
	gdb_6_3-20041109-release:1.13
	gdb_6_3-branch:1.13.0.2
	gdb_6_3-20041019-branchpoint:1.13
	drow_intercu-merge-20040921:1.13
	drow_intercu-merge-20040915:1.13
	jimb-gdb_6_2-e500-branch:1.10.0.8
	jimb-gdb_6_2-e500-branchpoint:1.10
	gdb_6_2-20040730-release:1.10
	gdb_6_2-branch:1.10.0.4
	gdb_6_2-2004-07-10-gmt-branchpoint:1.10
	gdb_6_1_1-20040616-release:1.7.6.1
	gdb_6_1-2004-04-05-release:1.7.6.1
	drow_intercu-merge-20040402:1.10
	drow_intercu-merge-20040327:1.10
	ezannoni_pie-20040323-branch:1.10.0.2
	ezannoni_pie-20040323-branchpoint:1.10
	cagney_tramp-20040321-mergepoint:1.10
	cagney_tramp-20040309-branch:1.9.0.2
	cagney_tramp-20040309-branchpoint:1.9
	gdb_6_1-branch:1.7.0.6
	gdb_6_1-2004-03-01-gmt-branchpoint:1.7
	drow_intercu-20040221-branch:1.7.0.4
	drow_intercu-20040221-branchpoint:1.7
	cagney_bfdfile-20040213-branch:1.7.0.2
	cagney_bfdfile-20040213-branchpoint:1.7
	drow-cplus-merge-20040208:1.6
	carlton_dictionary-20040126-merge:1.6
	cagney_bigcore-20040122-branch:1.6.0.2
	cagney_bigcore-20040122-branchpoint:1.6
	drow-cplus-merge-20040113:1.6
	drow-cplus-merge-20031224:1.2
	drow-cplus-merge-20031220:1.2
	carlton_dictionary-20031215-merge:1.2
	drow-cplus-branch:1.2.0.6
	drow-cplus-merge-20031214:1.2
	carlton-dictionary-20031111-merge:1.2
	gdb_6_0-2003-10-04-release:1.1.2.1
	kettenis_sparc-20030918-branch:1.2.0.4
	kettenis_sparc-20030918-branchpoint:1.2
	carlton_dictionary-20030917-merge:1.2
	ezannoni_pie-20030916-branchpoint:1.2
	ezannoni_pie-20030916-branch:1.2.0.2
	carlton_dictionary-branch:1.1.0.4
	gdb_6_0-branch:1.1.0.2;
locks; strict;
comment	@# @;


1.36
date	2013.01.01.06.33.27;	author brobecke;	state Exp;
branches;
next	1.35;

1.35
date	2012.11.12.17.08.08;	author tromey;	state Exp;
branches;
next	1.34;

1.34
date	2012.07.10.15.18.17;	author tromey;	state Exp;
branches;
next	1.33;

1.33
date	2012.05.18.15.31.41;	author tromey;	state Exp;
branches;
next	1.32;

1.32
date	2012.01.16.16.21.45;	author palves;	state Exp;
branches;
next	1.31;

1.31
date	2012.01.04.08.17.46;	author brobecke;	state Exp;
branches;
next	1.30;

1.30
date	2011.01.01.15.33.43;	author brobecke;	state Exp;
branches
	1.30.4.1;
next	1.29;

1.29
date	2010.06.10.19.48.19;	author msnyder;	state Exp;
branches;
next	1.28;

1.28
date	2010.06.08.22.58.03;	author msnyder;	state Exp;
branches;
next	1.27;

1.27
date	2010.06.03.23.54.18;	author msnyder;	state Exp;
branches;
next	1.26;

1.26
date	2010.06.02.20.03.16;	author msnyder;	state Exp;
branches;
next	1.25;

1.25
date	2010.05.05.18.06.58;	author brobecke;	state Exp;
branches;
next	1.24;

1.24
date	2010.01.01.07.32.01;	author brobecke;	state Exp;
branches;
next	1.23;

1.23
date	2009.11.11.23.33.51;	author kseitz;	state Exp;
branches;
next	1.22;

1.22
date	2009.09.21.19.23.22;	author kseitz;	state Exp;
branches;
next	1.21;

1.21
date	2009.01.03.05.58.04;	author brobecke;	state Exp;
branches;
next	1.20;

1.20
date	2008.08.21.18.57.34;	author drow;	state Exp;
branches;
next	1.19;

1.19
date	2008.01.01.22.53.19;	author drow;	state Exp;
branches;
next	1.18;

1.18
date	2007.10.02.14.57.46;	author drow;	state Exp;
branches;
next	1.17;

1.17
date	2007.08.23.18.14.17;	author brobecke;	state Exp;
branches;
next	1.16;

1.16
date	2007.01.09.17.59.11;	author drow;	state Exp;
branches;
next	1.15;

1.15
date	2007.01.03.18.05.45;	author drow;	state Exp;
branches;
next	1.14;

1.14
date	2006.08.10.05.27.20;	author brobecke;	state Exp;
branches;
next	1.13;

1.13
date	2004.08.13.08.48.46;	author chastain;	state Exp;
branches
	1.13.26.1;
next	1.12;

1.12
date	2004.08.12.18.51.41;	author chastain;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.31.07.45.35;	author chastain;	state Exp;
branches;
next	1.10;

1.10
date	2004.03.17.20.11.22;	author carlton;	state Exp;
branches;
next	1.9;

1.9
date	2004.03.09.17.34.39;	author chastain;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2004.03.09.17.11.55;	author chastain;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.11.14.01.25;	author chastain;	state Exp;
branches
	1.7.4.1
	1.7.6.1;
next	1.6;

1.6
date	2004.01.11.09.40.37;	author chastain;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.09.04.57.09;	author chastain;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.02.04.46.45;	author chastain;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.31.20.59.11;	author chastain;	state Exp;
branches;
next	1.2;

1.2
date	2003.09.08.02.00.11;	author chastain;	state Exp;
branches
	1.2.2.1
	1.2.6.1;
next	1.1;

1.1
date	2003.08.23.03.55.59;	author chastain;	state Exp;
branches
	1.1.2.1
	1.1.4.1;
next	;

1.30.4.1
date	2012.01.06.04.44.02;	author brobecke;	state Exp;
branches;
next	;

1.13.26.1
date	2006.08.28.07.48.42;	author nickrob;	state Exp;
branches;
next	;

1.9.2.1
date	2004.03.21.23.57.41;	author cagney;	state Exp;
branches;
next	;

1.7.4.1
date	2004.03.27.17.38.04;	author drow;	state Exp;
branches;
next	1.7.4.2;

1.7.4.2
date	2004.09.16.17.01.42;	author drow;	state Exp;
branches;
next	;

1.7.6.1
date	2004.03.10.20.41.31;	author chastain;	state Exp;
branches;
next	;

1.2.2.1
date	2004.03.23.20.12.33;	author ezannoni;	state Exp;
branches;
next	;

1.2.6.1
date	2003.12.14.20.27.53;	author drow;	state Exp;
branches;
next	1.2.6.2;

1.2.6.2
date	2004.01.13.16.12.12;	author drow;	state Exp;
branches;
next	;

1.1.2.1
date	2003.08.25.03.53.48;	author chastain;	state Exp;
branches;
next	;

1.1.4.1
date	2003.08.30.03.40.34;	author chastain;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2003.09.17.21.28.50;	author carlton;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2004.01.26.19.11.41;	author carlton;	state Exp;
branches;
next	;


desc
@@


1.36
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@# Copyright 1992-2013 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# This file was written by Fred Fish. (fnf@@cygnus.com)
# And rewritten by Michael Chastain <mec.gnu@@mindspring.com>.

set nl "\[\r\n\]+"

if { [skip_cplus_tests] } { continue }

load_lib "cp-support.exp"

standard_testfile .cc

if {[prepare_for_testing $testfile.exp $testfile $srcfile {debug c++}]} {
    return -1
}

# Test ptype of class objects.

proc test_ptype_class_objects {} {

    # Simple type.

    cp_test_ptype_class \
	"struct default_public_struct" "" "struct" "default_public_struct" \
	{
	    { field public "int a;" }
	    { field public "int b;" }
	}

    # Another simple type.

    cp_test_ptype_class \
	"struct explicit_public_struct" "" "struct" "explicit_public_struct" \
	{
	    { field public "int a;" }
	    { field public "int b;" }
	}

    # Another simple type.

    cp_test_ptype_class \
	"struct protected_struct" "" "struct" "protected_struct" \
	{
	    { field protected "int a;" }
	    { field protected "int b;" }
	}

    # Another simple type.

    cp_test_ptype_class \
	"struct private_struct" "" "struct" "private_struct" \
	{
	    { field private "int a;" }
	    { field private "int b;" }
	}

    # A bigger type.

    cp_test_ptype_class \
	"struct mixed_protection_struct" "" "struct" "mixed_protection_struct" \
	{
	    { field public    "int a;" }
	    { field public    "int b;" }
	    { field private   "int c;" }
	    { field private   "int d;" }
	    { field protected "int e;" }
	    { field protected "int f;" }
	    { field public    "int g;" }
	    { field private   "int h;" }
	    { field protected "int i;" }
	}

    # All that again with "class" instead of "struct".
    # gdb does not care about the difference anyways.

    cp_test_ptype_class \
	"class public_class" "" "class" "public_class" \
	{
	    { field public "int a;" }
	    { field public "int b;" }
	}

    # Another simple type.

    cp_test_ptype_class \
	"class protected_class" "" "class" "protected_class" \
	{
	    { field protected "int a;" }
	    { field protected "int b;" }
	}

    # Another simple type.

    cp_test_ptype_class \
	"class default_private_class" "" "class" "default_private_class" \
	{
	    { field private "int a;" }
	    { field private "int b;" }
	}

    # Another simple type.

    cp_test_ptype_class \
	"class explicit_private_class" "" "class" "explicit_private_class" \
	{
	    { field private "int a;" }
	    { field private "int b;" }
	}

    # A bigger type.

    cp_test_ptype_class \
	"class mixed_protection_class" "" "class" "mixed_protection_class" \
	{

	    { field public    "int a;" }
	    { field public    "int b;" }
	    { field private   "int c;" }
	    { field private   "int d;" }
	    { field protected "int e;" }
	    { field protected "int f;" }
	    { field public    "int g;" }
	    { field private   "int h;" }
	    { field protected "int i;" }
	}

    # Here are some classes with inheritance.

    # Base class.

    cp_test_ptype_class \
	"class A" "" "class" "A" \
	{
	    { field public "int a;" }
	    { field public "int x;" }
	}

    # Derived class.

    cp_test_ptype_class \
	"class B" "" "class" "B" \
	{
	    { base         "public A" }
	    { field public "int b;" }
	    { field public "int x;" }
	}

    # Derived class.

    cp_test_ptype_class \
	"class C" "" "class" "C" \
	{
	    { base         "public A" }
	    { field public "int c;" }
	    { field public "int x;" }
	}

    # Derived class, multiple inheritance.

    cp_test_ptype_class \
	"class D" "" "class" "D" \
	{
	    { base         "public B" }
	    { base         "public C" }
	    { field public "int d;" }
	    { field public "int x;" }
	}

    # Derived class.

    cp_test_ptype_class \
	"class E" "" "class" "E" \
	{
	    { base         "public D" }
	    { field public "int e;" }
	    { field public "int x;" }
	}

    # This is a break from inheritance tests.
    #
    # gcc 2.X with stabs (stabs or stabs+?) used to have a problem with
    # static methods whose name is the same as their argument mangling.
 
    cp_test_ptype_class \
	"class Static" "" "class" "Static" \
	{
	    { method public "static void ii(int, int);" }
	}

    # Here are some virtual inheritance tests.

    # A virtual base class.

    cp_test_ptype_class \
	"class vA" "" "class" "vA" \
	{
	    { field public "int va;" }
	    { field public "int vx;" }
	}

    # A derived class with a virtual base.

    cp_test_ptype_class \
	"class vB" "" "class" "vB" \
	{
	    { base         "public virtual vA" }
	    { vbase        "vA" }
	    { field public "int vb;" }
	    { field public "int vx;" }
	}

    # Another derived class with a virtual base.

    cp_test_ptype_class \
	"class vC" "" "class" "vC" \
	{
	    { base         "public virtual vA" }
	    { vbase        "vA" }
	    { field public "int vc;" }
	    { field public "int vx;" }
	}

    # A classic diamond class.

    cp_test_ptype_class \
	"class vD" "" "class" "vD" \
	{
	    { base         "public virtual vB" }
	    { base         "public virtual vC" }
	    { vbase        "vC" }
	    { vbase        "vB" }
	    { field public "int vd;" }
	    { field public "int vx;" }
	}

    # A class derived from a diamond class.

    cp_test_ptype_class \
	"class vE" "" "class" "vE" \
	{
	    { base         "public virtual vD" }
	    { vbase        "vD" }
	    { field public "int ve;" }
	    { field public "int vx;" }
	}

    # Another inheritance series.

    # A base class.

    cp_test_ptype_class \
	"class Base1" "" "class" "Base1" \
	{
	    { field  public "int x;" }
	    { method public "Base1(int);" }
	}

    # Another base class.

    cp_test_ptype_class \
	"class Foo" "" "class" "Foo" \
	{
	    { field public "int x;" }
	    { field public "int y;" }
	    { field public "static int st;" }
	    { method public "Foo(int, int);" }
	    { method public "int operator!();" }
	    { method public "operator int();" }
	    { method public "int times(int);" }
	} \
	"" \
	{
	    {
		"operator int();"
		"int operator int();"
		{ setup_kfail "gdb/1497" "*-*-*" }
	    }
	    {
		"operator int();"
		"int operator int(void);"
		{ setup_kfail "gdb/1497" "*-*-*" }
	    }
	}

    # A multiple inheritance derived class.

    cp_test_ptype_class \
	"class Bar" "" "class" "Bar" \
	{
	    { base          "public Base1" }
	    { base          "public Foo" }
	    { field  public "int z;" }
	    { method public "Bar(int, int, int);" }
	}

}

# Test simple access to class members.

proc test_non_inherited_member_access {} {
    
    # Print non-inherited members of g_A.
    gdb_test "print g_A.a" ".* = 1"
    gdb_test "print g_A.x" ".* = 2"

    # Print non-inherited members of g_B.
    gdb_test "print g_B.b" ".* = 5"
    gdb_test "print g_B.x" ".* = 6"

    # Print non-inherited members of g_C.
    gdb_test "print g_C.c" ".* = 9"
    gdb_test "print g_C.x" ".* = 10"

    # Print non-inherited members of g_D.
    gdb_test "print g_D.d" ".* = 19"
    gdb_test "print g_D.x" ".* = 20"

    # Print non-inherited members of g_E.
    gdb_test "print g_E.e" ".* = 31"
    gdb_test "print g_E.x" ".* = 32"
}

# Test access to members of other classes.
# gdb should refuse to print them.
# (I feel old -- I remember when this was legal in C -- chastain).

proc test_wrong_class_members {} {
    gdb_test "print g_A.b" "There is no member( or method|) named b."
    gdb_test "print g_B.c" "There is no member( or method|) named c."
    gdb_test "print g_B.d" "There is no member( or method|) named d."
    gdb_test "print g_C.b" "There is no member( or method|) named b."
    gdb_test "print g_C.d" "There is no member( or method|) named d."
    gdb_test "print g_D.e" "There is no member( or method|) named e."
}

# Test access to names that are not members of any class.

proc test_nonexistent_members {} {
    gdb_test "print g_A.y" "There is no member( or method|) named y."
    gdb_test "print g_B.z" "There is no member( or method|) named z."
    gdb_test "print g_C.q" "There is no member( or method|) named q."
    gdb_test "print g_D.p" "There is no member( or method|) named p."
}

# Call a method that expects a base class parameter with base, inherited,
# and unrelated class arguments.

proc test_method_param_class {} {
    gdb_test "call class_param.Aptr_a (&g_A)" ".* = 1"
    gdb_test "call class_param.Aptr_x (&g_A)" ".* = 2"
    gdb_test "call class_param.Aptr_a (&g_B)" ".* = 3"
    gdb_test "call class_param.Aptr_x (&g_B)" ".* = 4"
    gdb_test "call class_param.Aref_a (g_A)" ".* = 1"
    gdb_test "call class_param.Aref_x (g_A)" ".* = 2"
    gdb_test "call class_param.Aref_a (g_B)" ".* = 3"
    gdb_test "call class_param.Aref_x (g_B)" ".* = 4"
    gdb_test "call class_param.Aval_a (g_A)" ".* = 1"
    gdb_test "call class_param.Aval_x (g_A)" ".* = 2"
    gdb_test "call class_param.Aval_a (g_B)" ".* = 3"
    gdb_test "call class_param.Aval_x (g_B)" ".* = 4"

    gdb_test "call class_param.Aptr_a (&foo)" "Cannot resolve .*" "unrelated class *param"
    gdb_test "call class_param.Aref_a (foo)" "Cannot resolve .*" "unrelated class &param"
    gdb_test "call class_param.Aval_a (foo)" "Cannot resolve .*" "unrelated class param"
}

# Examine a class with an enum field.

proc test_enums {} {
    global gdb_prompt
    global nl

    # print the object

    # We match the enum values with and without qualifiers.  As of
    # 2008-08-21 we can output the qualifiers for DWARF-2.

    gdb_test "print obj_with_enum" \
	"\\$\[0-9\]+ = \{priv_enum = (ClassWithEnum::)?red, x = 0\}" \
	"print obj_with_enum (1)"

    # advance one line

    gdb_test "next" ".*"

    # print the object again

    gdb_test "print obj_with_enum" \
	"\\$\[0-9\]+ = \{priv_enum = (ClassWithEnum::)?green, x = 0\}" \
	"print obj_with_enum (2)"

    # print the enum member

    gdb_test "print obj_with_enum.priv_enum" "\\$\[0-9\]+ = (ClassWithEnum::)?green"

    # ptype on the enum member

    gdb_test_multiple "ptype obj_with_enum.priv_enum" "ptype obj_with_enum.priv_enum" {
        -re "type = enum ClassWithEnum::PrivEnum \{ ?(ClassWithEnum::)?red, (ClassWithEnum::)?green, (ClassWithEnum::)?blue, (ClassWithEnum::)?yellow = 42 ?\}$nl$gdb_prompt $" {
	    pass "ptype obj_with_enum.priv_enum"
        }
	-re "type = enum PrivEnum \{ ?(ClassWithEnum::)?red, (ClassWithEnum::)?green, (ClassWithEnum::)?blue, (ClassWithEnum::)?yellow = 42 ?\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    pass "ptype obj_with_enum.priv_enum"
	}
	-re "type = enum \{ ?red, green, blue, yellow = 42 ?\}$nl$gdb_prompt $" {
	    # This case case is a little dubious, but it's not clear what
	    # ought to be required of a ptype on a private enum...
	    # -sts 19990324
	    #
	    # It bugs me that this happens with gcc 3.
	    # -- chastain 2003-12-30
	    #
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype obj_with_enum.priv_enum"
	}
    }

    # ptype on the object

    # NOTE: carlton/2003-02-28: One could certainly argue that plain
    # "PrivEnum"
    # is acceptable: PrivEnum is a member of ClassWithEnum, so
    # there's no need to explicitly qualify its name with
    # "ClassWithEnum::".  The truth, though, is that GDB is simply
    # forgetting that PrivEnum is a member of ClassWithEnum, so we do
    # that output for a bad reason instead of a good reason.  Under
    # stabs, we probably can't get this right; under DWARF-2, we can.

    cp_test_ptype_class \
	"obj_with_enum" "" "class" "ClassWithEnum" \
	{
	    { field public "ClassWithEnum::PrivEnum priv_enum;" }
	    { field public "int x;" }
	} \
	"" \
	{
	    {
		"ClassWithEnum::PrivEnum priv_enum;"
		"PrivEnum priv_enum;"
		{ setup_kfail "gdb/57" "*-*-*" }
	    }
	}

    # I'll do this test two different ways, because of a parser bug.
    # See PR gdb/1588.

    gdb_test_multiple "print (ClassWithEnum::PrivEnum) 42" "print (ClassWithEnum::PrivEnum) 42" {
	-re "\\$\[0-9\]+ = (ClassWithEnum::)?yellow$nl$gdb_prompt $" {
	    pass "print (ClassWithEnum::PrivEnum) 42"
	}
	-re "A (parse|syntax) error in expression, near `42'.$nl$gdb_prompt $" {
	    # "parse error" is bison 1.35.
	    # "syntax error" is bison 1.875.
	    kfail "gdb/1588" "print (ClassWithEnum::PrivEnum) 42"
	}
    }

    gdb_test_multiple "print ('ClassWithEnum::PrivEnum') 42" "print ('ClassWithEnum::PrivEnum') 42" {
	-re "\\$\[0-9\]+ = (ClassWithEnum::)?yellow$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "print ('ClassWithEnum::PrivEnum') 42"
	}
	-re "No symbol \"ClassWithEnum::PrivEnum\" in current context.$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
	    # gcc 2.95.3 -gstabs+
	    kfail "gdb/57" "print ('ClassWithEnum::PrivEnum') 42"
	}
    }
}

# Pointers to class members

proc test_pointers_to_class_members {} {
    gdb_test "print Bar::z" "Cannot reference non-static field \"z\""
    gdb_test "print &Foo::x" "\\$\[0-9\]+ = &Foo::x"
    gdb_test "print (int)&Foo::x" "\\$\[0-9\]+ = 0"
    gdb_test "print (int)&Bar::y == 2*sizeof(int)" "\\$\[0-9\]+ = true"

    gdb_test "ptype Bar::z" "type = int"
    gdb_test "ptype &Bar::z" "type = int Bar::\\*"

    # TODO: this is a bogus test.  It's looking at a variable that
    # has not even been declared yet, so it's accessing random junk
    # on the stack and comparing that it's NOT equal to a specific
    # value.  It's been like this since gdb 4.10 in 1993!
    # -- chastain 2004-01-01
    gdb_test "print (int)pmi == sizeof(int)" ".* = false"
}

# Test static members.

proc test_static_members {} {
    global hex

    gdb_test "print Foo::st" "\\$\[0-9\]+ = 100"
    gdb_test_no_output "set foo.st = 200" ""
    gdb_test "print bar.st" "\\$\[0-9\]+ = 200"
    gdb_test "print &foo.st" "\\$\[0-9\]+ = \\(int ?\\*\\) $hex <Foo::st>"
    gdb_test "print &Bar::st" "\\$\[0-9\]+ = \\(int ?\\*\\) $hex <Foo::st>"
    gdb_test "print *\$" "\\$\[0-9\]+ = 200"

    gdb_test_no_output "set print static-members off"
    gdb_test "print csi" \
	"{x = 10, y = 20}" \
	"print csi without static members"
    gdb_test "print cnsi" \
	"{x = 30, y = 40}" \
	"print cnsi without static members"

    gdb_test_no_output "set print static-members on"
    gdb_test "print csi" \
	"{x = 10, y = 20, static null = {x = 0, y = 0, static null = <same as static member of an already seen type>}}" \
	"print csi with static members"
    gdb_test "print cnsi" \
	"{x = 30, y = 40, static null = {x = 0, y = 0, static null = <same as static member of an already seen type>, static yy = {z = 5, static xx = {x = 1, y = 2, static null = <same as static member of an already seen type>, static yy = <same as static member of an already seen type>}}}, static yy = <same as static member of an already seen type>}" \
	"print cnsi with static members"
}

proc do_tests {} {
    global gdb_prompt
    global nl


    gdb_test_no_output "set language c++" ""
    gdb_test_no_output "set width 0" ""

    if ![runto_main ] then {
	perror "couldn't run to breakpoint"
	return
    }

    gdb_breakpoint inheritance2
    gdb_test "continue" ".*Breakpoint .* inheritance2.*" ""

    test_ptype_class_objects
    test_non_inherited_member_access
    test_wrong_class_members
    test_nonexistent_members
    test_method_param_class

    gdb_breakpoint enums2
    gdb_test "continue" ".*Breakpoint .* enums2.*" "continue to enums2(\\(\\)|)"
    # Leave enums2.  Make sure we reach the next line, in case there
    # are any more instructions to finish the function call.
    gdb_test_multiple "finish" "" {
	-re "enums2 \\(\\);.*$gdb_prompt $" {
	    gdb_test "next" ".*" ""
	}
	-re "$gdb_prompt $" { }
    }
    test_enums

    gdb_test "finish" ".*" ""
    test_pointers_to_class_members
    test_static_members

    # Now some random tests that were just thrown in here.

    gdb_breakpoint marker_reg1
    gdb_test "continue" ".*Breakpoint .* marker_reg1.*" ""
    gdb_test "finish" "Run till exit from.*" "finish from marker_reg1"

    # This class is so small that an instance of it can fit in a register.
    # When gdb tries to call a method, it gets embarrassed about taking
    # the address of a register.
    #
    # TODO: I think that message should be a PASS, not an XFAIL.
    # gdb prints an informative message and declines to do something
    # impossible.
    #
    # The method call actually succeeds if the compiler allocates very
    # small classes in memory instead of registers.  So this test does
    # not tell us anything interesting if the call succeeds.
    #
    # -- chastain 2003-12-31
    gdb_test_multiple "print v.method ()" "calling method for small class" {
	-re "\\$\[0-9\]+ = 82$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "calling method for small class"
	}
	-re "Address requested for identifier \"v\" which is in register .*$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 2.95.3 -gstabs+
	    setup_xfail "*-*-*" 2972
	    fail "calling method for small class"
	}
    }

    gdb_test "print base1::Base1" "<.*Base1.*>" "print ctor of typedef class"
    gdb_test "print base1::~Base1" "<.*~Base1(\\(\\))?>" \
	"print dtor of typedef class"

    gdb_test "list ByAnyOtherName::times" ".*int Foo::times.*"
}

do_tests
@


1.35
log
@	* gdb.cp/classes.exp (test_ptype_class_objects): Remove
	"ptype" from calls to cp_test_ptype_class.
	(test_enums): Likewise.
	* gdb.cp/derivation.exp: Remove "ptype" from calls to
	cp_test_ptype_class.
	* gdb.cp/inherit.exp (test_ptype_si): Remove "ptype" from
	calls to cp_test_ptype_class.
	(test_ptype_mi, test_ptype_vi, test_ptype_mvi): Likewise.
	* gdb.cp/virtfunc.exp (test_ptype_of_classes): Remove "ptype"
	from calls to cp_test_ptype_class.
	* lib/cp-support.exp (cp_test_ptype_class): Supply "ptype"
	command here.  Change "in_command" argument to "in_exp".
@
text
@d1 1
a1 1
# Copyright 1992, 1994-2004, 2006-2012 Free Software Foundation, Inc.
@


1.34
log
@	* gdb.cp/abstract-origin.exp: Use standard_testfile.
	* gdb.cp/ambiguous.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/annota2.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/annota3.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/anon-ns.exp: Use standard_testfile.
	* gdb.cp/anon-struct.exp: Use standard_testfile.
	* gdb.cp/anon-union.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/arg-reference.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/bool.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/breakpoint.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/bs15503.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/call-c.exp: Use standard_testfile, clean_restart,
	standard_output_file.
	* gdb.cp/casts.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/class2.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/classes.exp: Use standard_testfile, prepare_for_testing.
	(test_static_members): Update.
	* gdb.cp/cmpd-minsyms.exp: Use standard_testfile.
	* gdb.cp/converts.exp: Use standard_testfile.
	* gdb.cp/cp-relocate.exp: Use standard_testfile.
	* gdb.cp/cpcompletion.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/cpexprs.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/cplabel.exp: Use standard_testfile.
	* gdb.cp/cplusfuncs.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/ctti.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/derivation.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/destrprint.exp: Use standard_testfile.
	* gdb.cp/dispcxx.exp: Use standard_testfile.
	* gdb.cp/exception.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/expand-psymtabs-cxx.exp: Use standard_testfile.
	* gdb.cp/extern-c.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/formatted-ref.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/fpointer.exp: Use standard_testfile.
	* gdb.cp/gdb1355.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/gdb2384.exp: Use standard_testfile, clean_restart,
	standard_output_file.
	* gdb.cp/gdb2495.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/hang.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/infcall-dlopen.exp: Use standard_testfile,
	standard_output_file.
	* gdb.cp/inherit.exp: Use standard_testfile, prepare_for_testing.
	(do_tests): Update.
	* gdb.cp/koenig.exp: Use standard_testfile.
	* gdb.cp/local.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/m-data.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/m-static.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/mb-ctor.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/mb-inline.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/mb-templates.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/member-ptr.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/meth-typedefs.exp: Use standard_testfile.
	* gdb.cp/method.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/method2.exp: Use standard_testfile.
	* gdb.cp/minsym-fallback.exp: Use standard_testfile,
	standard_output_file.
	* gdb.cp/misc.exp: Use standard_testfile, prepare_for_testing.
	(do_tests): Update.
	* gdb.cp/namespace-enum.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/namespace-nested-import.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/namespace.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/nextoverthrow.exp: Use standard_testfile.
	* gdb.cp/no-dmgl-verbose.exp: Use standard_testfile.
	* gdb.cp/nsdecl.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/nsimport.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/nsnested.exp: Use standard_testfile.
	* gdb.cp/nsnoimports.exp: Use standard_testfile.
	* gdb.cp/nsrecurs.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/nsstress.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/nsusing.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/operator.exp: Use standard_testfile.
	* gdb.cp/oranking.exp: Use standard_testfile.
	* gdb.cp/overload-const.exp: Use standard_testfile.
	* gdb.cp/overload.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/ovldbreak.exp: Use standard_testfile.
	* gdb.cp/ovsrch.exp: Use standard_testfile.
	* gdb.cp/paren-type.exp: Use standard_testfile.
	* gdb.cp/pass-by-ref.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/pr-1023.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/pr-1210.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/pr-574.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/pr10687.exp: Use standard_testfile, clean_restart.
	* gdb.cp/pr10728.exp: Use standard_testfile,
	standard_output_file.
	* gdb.cp/pr12028.exp: Use standard_testfile.
	* gdb.cp/pr9067.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/pr9167.exp: Use standard_testfile.
	* gdb.cp/pr9631.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/printmethod.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/psmang.exp: Use standard_testfile, clean_restart.
	* gdb.cp/psymtab-parameter.exp: Use standard_testfile.
	* gdb.cp/ptype-cv-cp.exp: Use standard_testfile.
	* gdb.cp/re-set-overloaded.exp: Use standard_testfile,
	standard_output_file.
	* gdb.cp/readnow-language.exp: Use standard_testfile.
	* gdb.cp/ref-params.exp: Use standard_testfile, build_executable.
	(gdb_start_again): Use clean_restart.
	* gdb.cp/ref-types.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/rtti.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/shadow.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/smartp.exp: Use standard_testfile.
	* gdb.cp/static-method.exp: Use standard_testfile.
	* gdb.cp/static-print-quit.exp: Use standard_testfile.
	* gdb.cp/temargs.exp: Use standard_testfile.
	* gdb.cp/templates.exp: Use standard_testfile,
	prepare_for_testing.
	(do_tests): Update.
	* gdb.cp/try_catch.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/typedef-operator.exp: Use standard_testfile.
	* gdb.cp/userdef.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/virtbase.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/virtfunc.exp: Use standard_testfile,
	prepare_for_testing.
	(do_tests): Update.
	* gdb.cp/virtfunc2.exp: Use standard_testfile,
	prepare_for_testing.
@
text
@d38 1
a38 1
	"ptype struct default_public_struct" "" "struct" "default_public_struct" \
d47 1
a47 1
	"ptype struct explicit_public_struct" "" "struct" "explicit_public_struct" \
d56 1
a56 1
	"ptype struct protected_struct" "" "struct" "protected_struct" \
d65 1
a65 1
	"ptype struct private_struct" "" "struct" "private_struct" \
d74 1
a74 1
	"ptype struct mixed_protection_struct" "" "struct" "mixed_protection_struct" \
d91 1
a91 1
	"ptype class public_class" "" "class" "public_class" \
d100 1
a100 1
	"ptype class protected_class" "" "class" "protected_class" \
d109 1
a109 1
	"ptype class default_private_class" "" "class" "default_private_class" \
d118 1
a118 1
	"ptype class explicit_private_class" "" "class" "explicit_private_class" \
d127 1
a127 1
	"ptype class mixed_protection_class" "" "class" "mixed_protection_class" \
d146 1
a146 1
	"ptype class A" "" "class" "A" \
d155 1
a155 1
	"ptype class B" "" "class" "B" \
d165 1
a165 1
	"ptype class C" "" "class" "C" \
d175 1
a175 1
	"ptype class D" "" "class" "D" \
d186 1
a186 1
	"ptype class E" "" "class" "E" \
d199 1
a199 1
	"ptype class Static" "" "class" "Static" \
d209 1
a209 1
	"ptype class vA" "" "class" "vA" \
d218 1
a218 1
	"ptype class vB" "" "class" "vB" \
d229 1
a229 1
	"ptype class vC" "" "class" "vC" \
d240 1
a240 1
	"ptype class vD" "" "class" "vD" \
d253 1
a253 1
	"ptype class vE" "" "class" "vE" \
d266 1
a266 1
	"ptype class Base1" "" "class" "Base1" \
d275 1
a275 1
	"ptype class Foo" "" "class" "Foo" \
d302 1
a302 1
	"ptype class Bar" "" "class" "Bar" \
d448 1
a448 1
	"ptype obj_with_enum" "" "class" "ClassWithEnum" \
@


1.33
log
@	PR exp/13907:
	* valprint.h (struct value_print_options) <symbol_print>: New
	field.
	* valprint.c (user_print_options): Add default for symbol_print.
	(show_symbol_print): New function.
	(generic_val_print): Respect symbol_print.
	(_initialize_valprint): Add "print symbol" setting.
	* f-valprint.c (f_val_print): Respect symbol_print.
	* c-valprint.c (c_val_print): Respect symbol_print.
	* NEWS: Update.
	* printcmd.c (print_address_symbolic): Return int.  Ignore some
	zero-size symbols.
	(print_address_demangle): Return int.
	* defs.h: (print_address_symbolic): Return int.
	* value.h (print_address_demangle): Return int.
doc
	* gdb.texinfo (Print Settings): Document 'set print symbol'.
testsuite
	* gdb.mi/mi-var-cmd.exp: Update.
	* gdb.objc/basicclass.exp (do_objc_tests): Update.
	* gdb.cp/virtbase.exp: Update.
	* gdb.cp/classes.exp (test_static_members): Update.
	* gdb.cp/casts.exp: Update.
	* gdb.base/pointers.exp: Update.
	* gdb.base/funcargs.exp (pointer_args): Update.
	(structs_by_reference): Update.
	* gdb.base/find.exp: Update.
	* gdb.base/call-strs.exp: Send "set print symbol off".
	* gdb.base/call-ar-st.exp: Update.
	* gdb.ada/fun_addr.exp: Update.
	* gdb.base/printcmds.exp (test_print_symbol): New proc.
	Call it.
	(test_print_repeats_10, test_print_strings)
	(test_print_char_arrays): Update.
@
text
@d25 4
a28 7
set testfile "classes"
set srcfile ${testfile}.cc
set binfile ${objdir}/${subdir}/${testfile}

if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug c++}] != "" } {
     untested classes.exp
     return -1
a540 4
    global subdir
    global objdir
    global srcdir
    global binfile
a544 7
    # Start with a fresh gdb.

    gdb_exit
    gdb_start
    gdb_reinitialize_dir $srcdir/$subdir
    gdb_load $binfile

@


1.32
log
@2012-01-16  Pedro Alves  <palves@@redhat.com>

	Remove all calls to strace.
@
text
@d522 2
a523 2
    gdb_test "print &foo.st" "\\$\[0-9\]+ = \\(int ?\\*\\) $hex"
    gdb_test "print &Bar::st" "\\$\[0-9\]+ = \\(int ?\\*\\) $hex"
@


1.31
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@a20 4
if $tracelevel then {
    strace $tracelevel
}

@


1.30
log
@run copyright.sh for 2011.
@
text
@d1 1
a1 2
# Copyright 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
# 2004, 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.30.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d1 2
a2 1
# Copyright 1992, 1994-2004, 2006-2012 Free Software Foundation, Inc.
@


1.29
log
@2010-06-08  Michael Snyder  <msnyder@@vmware.com>

	* gdb.ada/assign_1.exp: Use ".*" instead of "" as wildcard regexp.
	* gdb.ada/boolean_expr.exp:
	* gdb.ada/frame_args.exp: Ditto.
	* gdb.ada/lang_switch.exp: Ditto.
	* gdb.ada/ptype_arith_binop.exp: Ditto.
	* gdb.ada/ref_param.exp: Ditto.
	* gdb.ada/type_coercion.exp:Ditto.

	* gdb.asm/asm-source.exp: Ditto.

	* gdb.base/attach.exp: Ditto.
	* gdb.base/bitfields2.exp: Ditto.
	* gdb.base/call-signal-resume.exp: Ditto.
	* gdb.base/callfuncs.exp: Ditto.
	* gdb.base/commands.exp: Ditto.
	* gdb.base/dbx.exp: Ditto.
	* gdb.base/default.exp: Ditto.
	* gdb.base/dump.exp: Ditto.
	* gdb.base/exprs.exp: Ditto.
	* gdb.base/freebpcmd.exp: Ditto.
	* gdb.base/interrupt.exp: Ditto.
	* gdb.base/list.exp: Ditto.
	* gdb.base/long_long.exp: Ditto.
	* gdb.base/maint.exp: Ditto.
	* gdb.base/ptype.exp: Ditto.
	* gdb.base/return.exp: Ditto.
	* gdb.base/setshow.exp: Ditto.
	* gdb.base/sigbpt.exp: Ditto.
	* gdb.base/sigrepeat.exp: Ditto.

	* gdb.cp/classes.exp: Ditto.

	* gdb.dwarf2/dw2-restore.exp: Ditto.

	* gdb.gdb/selftest.exp: Ditto.

	* gdb.multi/base.exp: Ditto.
	* gdb.multi/bkpt-multi-exec.exp: Ditto.

	* gdb.python/py-block.exp: Ditto.
	* gdb.python/py-prettyprint.exp: Ditto.
	* gdb.python/py-template.exp: Ditto.

	* gdb.server/ext-attach.exp: Ditto.
	* gdb.server/ext-run.exp: Ditto.
	* gdb.server/server-mon.exp: Ditto.

	* gdb.threads/fork-thread-pending.exp: Ditto.
	* gdb.threads/hand-call-in-threads.exp: Ditto.
	* gdb.threads/interrupted-hand-call.exp: Ditto.
	* gdb.threads/linux-dp.exp: Ditto.
	* gdb.threads/manythreads.exp: Ditto.
	* gdb.threads/print-threads.exp: Ditto.
	* gdb.threads/pthreads.exp: Ditto.
	* gdb.threads/schedlock.exp: Ditto.
	* gdb.threads/thread-unwindonsignal.exp: Ditto.
	* gdb.threads/threadapply.exp: Ditto.
@
text
@d2 1
a2 1
# 2004, 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.28
log
@2010-06-08  Michael Snyder  <msnyder@@vmware.com>

	* gdb.ada/exec_changed.exp:
	Use ".*" instead of "" as wildcard regexp.

	* gdb.base/async.exp: Use ".*" instead of "" as wildcard regexp.
	* gdb.base/call-ar-st.exp: Ditto.
	* gdb.base/checkpoint.exp: Ditto.
	* gdb.base/default.exp: Ditto.
	* gdb.base/dump.exp: Ditto.
	* gdb.base/ending-run.exp: Ditto.
	* gdb.base/fileio.exp: Ditto.
	* gdb.base/miscexprs.exp: Ditto.
	* gdb.base/pointers.exp: Ditto.
	* gdb.base/readline.exp: Ditto.
	* gdb.base/reread.exp: Ditto.
	* gdb.base/restore.exp: Ditto.
	* gdb.base/shlib-call.exp: Ditto.
	* gdb.base/valgrind-db-attach.exp: Ditto.
	* gdb.base/volatile.exp: Ditto.
	* gdb.base/watchpoints.exp: Ditto.

	* gdb.cp/classes.exp: Use ".*" instead of "" as wildcard regexp.

	* gdb.python/py-frame.exp: Use ".*" instead of "" as wildcard regexp.
	* gdb.python/py-value.exp: Ditto.

	* gdb.trace/backtrace.exp: Use ".*" instead of "" as wildcard regexp.
	* gdb.trace/circ.exp: Ditto.
	* gdb.trace/collection.exp: Ditto.
	* gdb.trace/packetlen.exp: Ditto.
	* gdb.trace/passc-dyn.exp: Ditto.
	* gdb.trace/report.exp: Ditto.
	* gdb.trace/tfile.exp: Ditto.
	* gdb.trace/tfind.exp: Ditto.
	* gdb.trace/while-dyn.exp: Ditto.
@
text
@d406 1
a406 1
    gdb_test "next" ""
@


1.27
log
@2010-06-03  Michael Snyder  <msnyder@@vmware.com>

	* gdb.base/commands.exp: Replace gdb_test with gdb_test_no_output.
	* gdb.base/display.exp: Ditto.
	* gdb.base/find.exp: Ditto.
	* gdb.base/ifelse.exp: Ditto.
	* gdb.base/multi-forks.exp: Ditto.
	* gdb.base/recurse.exp: Ditto.
	* gdb.base/setshow.exp: Ditto.
	* gdb.base/value-double-free.exp: Ditto.
	* gdb.base/watch-vfork.exp: Ditto.
	* gdb.base/watch_thread_num.exp: Ditto.
	* gdb.base/watchpoint-solib.exp: Ditto.
	* gdb.base/watchpoint.exp: Ditto.
	* gdb.base/watchpoints.exp: Ditto.

	* gdb.cp/classes.exp: Replace gdb_test with gdb_test_no_output.
	* gdb.cp/overload.exp: Ditto.
	* gdb.cp/virtfunc.exp: Ditto.

	* gdb.python/py-value.exp: Replace gdb_test with gdb_test_no_output.

	* gdb.reverse/watch-precsave.exp:
	Replace gdb_test with gdb_test_no_output.

	* gdb.threads/attach-into-signal.exp:
	Replace gdb_test with gdb_test_no_output.
	* gdb.threads/local-watch-wrong-thread.exp: Ditto.
	* gdb.threads/watchthreads.exp: Ditto.
	* gdb.threads/watchthreads2.exp: Ditto.

	* gdb.trace/deltrace.exp: Replace gdb_test with gdb_test_no_output.
	* gdb.trace/tfind.exp: Ditto.
@
text
@d587 1
a587 1
	    gdb_test "next" "" ""
d593 1
a593 1
    gdb_test "finish" "" ""
@


1.26
log
@2010-06-02  Michael Snyder  <msnyder@@msnyder-server.eng.vmware.com>

	* gdb.cp/class2.exp: Use gdb_test_no_output.
	* gdb.cp/classes.exp: Ditto.
	* gdb.cp/extern-c.exp: Ditto.
	* gdb.cp/inherit.exp: Ditto.
	* gdb.cp/maint.exp: Ditto.
	* gdb.cp/mb-inline.exp: Ditto.
	* gdb.cp/mb-templates.exp: Ditto.
	* gdb.cp/method2.exp: Ditto.
	* gdb.cp/misc.exp: Ditto.
	* gdb.cp/ovldbreak.exp: Ditto.
	* gdb.cp/punctuator.exp: Ditto.
	* gdb.cp/templates.exp: Ditto.
	* gdb.cp/virtbase.exp: Ditto.
@
text
@d525 1
a525 1
    gdb_test "set foo.st = 200" "" ""
d564 2
a565 2
    gdb_test "set language c++" "" ""
    gdb_test "set width 0" "" ""
@


1.25
log
@Do not set prms_id/bug_id anymore.

2010-05-05  Joel Brobecker  <brobecker@@adacore.com>

	Remove the use of prms_id and bug_id throughout the testsuite.
@
text
@d531 1
a531 1
    gdb_test "set print static-members off" ""
d539 1
a539 1
    gdb_test "set print static-members on" ""
@


1.24
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@a548 2
    global prms_id
    global bug_id
a555 2
    set prms_id 0
    set bug_id 0
@


1.23
log
@	* gdb.cp/classes.cc (ByAnyOtherName): Add typedef and
	use it instead of "Foo".
	* gdb.cp/classes.exp (do_tests): Add a test to access
	a method through a typedef'd class name.
@
text
@d2 1
a2 1
# 2004, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.22
log
@	* gdb.cp/classes.exp (do_tests): Add tests to print a constructor
	and destructor using typedef name of class.
	* gdb.cp/classes.cc (class Base1): Add a destructor.
	(base1): New typedef.
	(use_methods): Instanitate an object of type base1.
	* gdb.cp/templates.exp (test_template_typedef): New procedure.
	(do_tests): Call test_template_typedef.
	* gdb.cp/templates.cc (Baz::~Baz): New method.
	(intBazOne): New typedef.
	(main): Instantiate intBazOne.
@
text
@d639 2
@


1.21
log
@        Updated copyright notices for most files.
@
text
@d635 4
@


1.20
log
@	* dwarf2read.c (processing_current_prefix): Delete static
	variable.
	(process_full_comp_unit): Do not set processing_current_prefix.
	(dwarf2_full_name): New function.
	(read_func_scope): Do not set processing_current_prefix.  Use
	determine_prefix.
	(read_structure_type): Do not set processing_current_prefix.  Remove
	unused inner cleanup.
	(process_structure_scope): Do not set processing_current_prefix.
	(read_enumeration_type): Use dwarf2_full_name.
	(determine_class_name): Return a const char *.  Put the result
	on the objfile obstack.  Use dwarf2_full_name.
	(read_namespace_type): New function.
	(read_namespace): Do not create the type here.  Use
	determine_prefix.
	(read_typedef): Use dwarf2_full_name.  Do not pass the name
	to init_type.
	(read_base_type): Do not pass the name to init_type.  Handle
	TYPE_FLAG_NOSIGN.
	(read_unspecified_type): Do not pass the name to init_type.
	(new_symbol): Use dwarf2_full_name instead of
	processing_current_prefix.
	(read_type_die): Do not set processing_current_prefix.  Handle
	DW_TAG_namespace.
	(determine_prefix): Handle specifications.  Return the result
	on the objfile obstack.  Handle unions correctly.
@
text
@d2 1
a2 1
# 2004, 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.19
log
@	Updated copyright notices for most files.
@
text
@d397 3
d401 1
a401 1
	"\\$\[0-9\]+ = \{priv_enum = red, x = 0\}" \
d411 1
a411 1
	"\\$\[0-9\]+ = \{priv_enum = green, x = 0\}" \
d416 1
a416 1
    gdb_test "print obj_with_enum.priv_enum" "\\$\[0-9\]+ = green"
d421 1
a421 1
        -re "type = enum ClassWithEnum::PrivEnum \{ ?red, green, blue, yellow = 42 ?\}$nl$gdb_prompt $" {
d424 1
a424 1
	-re "type = enum PrivEnum \{ ?red, green, blue, yellow = 42 ?\}$nl$gdb_prompt $" {
d474 1
a474 1
	-re "\\$\[0-9\]+ = yellow$nl$gdb_prompt $" {
d485 1
a485 1
	-re "\\$\[0-9\]+ = yellow$nl$gdb_prompt $" {
@


1.18
log
@	* gdb.cp/classes.exp (do_tests): Always step to the line after the
	call.
	* gdb.mi/mi-simplerun.exp (test_controlled_execution): Allow finish
	to return to the call.
	* gdb.mi/mi2-simplerun.exp (test_controlled_execution): Likewise.
	* gdb.mi/mi-return.exp (test_return_simple): Likewise.
	* gdb.mi/mi2-return.exp (test_return_simple): Likewise.
	* gdb.mi/mi-until.exp (test_until): Likewise.
	* gdb.mi/mi2-until.exp (test_until): Likewise.
@
text
@d2 1
a2 1
# 2004, 2006, 2007 Free Software Foundation, Inc.
@


1.17
log
@        Switch the license of all .exp files to GPLv3.
        Switch the license of all .f and .f90 files to GPLv3.
        Switch the license of all .s and .S files to GPLv3.
@
text
@d584 8
a591 1
    gdb_test "finish" "" ""
@


1.16
log
@Copyright updates for 2007.
@
text
@d6 1
a6 1
# the Free Software Foundation; either version 2 of the License, or
d8 1
a8 1
# 
d13 1
a13 1
# 
d15 1
a15 2
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
@


1.15
log
@	* NEWS: Mention pointer to member improvements.
	* Makefile.in (gnu-v3-abi.o): Delete special rule.
	(eval.o, gnu-v3-abi.o, ia64-tdep.o): Update.
	* ada-valprint.c (ada_print_scalar): Update for new type codes.
	* c-typeprint.c (c_print_type): Update for new type codes.
	(c_type_print_varspec_prefix, c_type_print_varspec_suffix)
	(c_type_print_base): Likewise.
	(c_type_print_args): Rewrite.
	* c-valprint.c (c_val_print): Update for new type codes.  Remove
	support for references to members.  Treat methods like functions.
	* cp-abi.c (cplus_print_method_ptr, cplus_method_ptr_size)
	(cplus_make_method_ptr, cplus_method_ptr_to_value): New.
	* cp-abi.h (cplus_print_method_ptr, cplus_method_ptr_size)
	(cplus_make_method_ptr, cplus_method_ptr_to_value): New prototypes.
	(struct cp_abi_ops): Add corresponding members.
	* cp-valprint.c (cp_print_class_method): Delete.
	(cp_find_class_member): New function.
	(cp_print_class_member): Use it.  Simplify support for bogus
	member pointers.
	* dwarf2read.c (quirk_gcc_member_function_pointer): Use
	lookup_methodptr_type.
	(read_tag_ptr_to_member_type): Likewise, and lookup_memberptr_type.
	* eval.c (evaluate_subexp_standard): Implement EVAL_SKIP for
	OP_SCOPE.  Update call to value_aggregate_elt.  Rewrite member
	pointer support.
	(evaluate_subexp_for_address): Handle OP_SCOPE explicitly.  Handle
	references returned by user defined operators.
	* f-typeprint.c (f_print_type, f_type_print_varspec_prefix)
	(f_type_print_varspec_suffix): Remove support for member pointers.
	* gdbtypes.c (lookup_memberptr_type): Renamed from lookup_member_type
	and adjusted.
	(smash_to_memberptr_type): Likewise, from smash_to_member_type.
	(lookup_methodptr_type): New.
	(rank_one_type): Adjust for TYPE_CODE_MEMBERPTR.
	(recursive_dump_type): Update for new types.
	* gdbtypes.h (enum type_code): Replace TYPE_CODE_MEMBER with
	TYPE_CODE_MEMBERPTR and TYPE_CODE_METHODPTR.
	(lookup_memberptr_type, lookup_methodptr_type)
	(smash_to_memberptr_type): New prototypes.
	(smash_to_method_type): Formatting fix.
	(lookup_member_type, smash_to_member_type): Delete prototypes.
	* gnu-v3-abi.c (gnuv3_get_vtable, gnuv3_get_virtual_fn): New.
	Do not rely on debug information for the vptr or the method's
	enclosing type.  Handle function descriptors for IA64.
	(gnuv3_virtual_fn_field): Rewrite using the new functions.
	(gnuv3_find_method_in, gnuv3_print_method_ptr)
	(gnuv3_method_ptr_size, gnuv3_make_method_ptr)
	(gnuv3_method_ptr_to_value): New.
	(init_gnuv3_ops): Set new members of gnu_v3_abi_ops.
	* hpread.c (hpread_type_lookup): Update for new types.
	* infcall.c (value_arg_coerce): Likewise.
	* m2-typeprint.c (m2_print_type): Remove explicit support
	for member pointers.
	* m2-valprint.c (m2_val_print): Likewise.
	* p-typeprint.c (pascal_type_print_varspec_prefix)
	(pascal_type_print_varspec_suffix, pascal_type_print_base): Likewise.
	* p-valprint.c (pascal_val_print): Likewise.
	(pascal_object_print_class_method, pascal_object_print_class_member):
	Delete.
	* p-lang.h (pascal_object_print_class_method)
	(pascal_object_print_class_member): Delete prototypes.
	* stabsread.c (read_type): Update for new types.
	* typeprint.c (print_type_scalar): Likewise.
	* valops.c (value_struct_elt_for_reference, value_namespace_elt)
	(value_maybe_namespace_elt, value_aggregate_elt): Add want_address
	argument.  Construct a pointer to member if the address of a
	function or data member is requested.
	(value_cast_pointers): Don't modify the input value.
	(value_cast): Adjust pointer to member handling for new types.
	Allow null pointer to member constants.  Don't modify the input
	value.
	(value_ind): Remove pointer to member check.  Handle function
	descriptors for function pointers.
	(value_struct_elt, value_find_oload_method_list, check_field):
	Remove pointer to member checks.
	* value.c (unpack_long): Allow pointers to data members.
	(value_from_longest): Allow member pointers.
	* value.h (value_aggregate_elt): Add want_address.
	* varobj.c (c_variable_editable): Remove check for members.
	* gdbarch.sh: Add vtable_function_descriptors and vbit_in_delta.
	* ia64-tdep.c (ia64_convert_from_func_ptr_addr): Handle descriptors
	in virtual tables.
	(ia64_gdbarch_init): Call set_gdbarch_vtable_function_descriptors.
	* c-lang.h (cp_print_class_method): Delete prototype.
	* arm-tdep.c (arm_gdbarch_init): Call set_gdbarch_vbit_in_delta.
	* mips-tdep.c (mips_gdbarch_init): Likewise.
	* gdbarch.c, gdbarch.h: Regenerated.

	* gdb.cp/classes.exp (test_pointers_to_class_members): Update expected
	output.  Test the types of members and member pointers.
	* gdb.cp/inherit.exp (test_print_mi_member_types): Remove KFAILs for
	gdb/2092.
	* gdb.cp/member-ptr.exp: Search for a comment instead of a
	statement.  Enable for GCC.  Update expected output for some tests
	and add new tests.  Remove obsolete GCC KFAILs.  Allow GCC's class
	layout.
	* gdb.cp/member-ptr.cc (Padding, Padding::vspacer, Base, Base::get_x)
	(Base::vget_base, Left, Left::vget, Right, Right::vget, Diamond)
	(Diamond::vget_base): New.
	(main): Add new tests.
	* gdb.cp/printmethod.exp: Update expected output for member functions.
	* gdb.cp/virtfunc.exp (test_virtual_calls): Add a KFAIL for
	print pEe->D::vg().
@
text
@d1 2
a2 2
# Copyright 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
# 2003, 2004, 2006 Free Software Foundation, Inc.
@


1.14
log
@	* gdb.arch/altivec-abi.exp: Replace gdb_suppress_entire_file with
	untested followed by return combination.
	* gdb.arch/altivec-regs.exp: Likewise.
	* gdb.arch/e500-abi.exp: Likewise.
	* gdb.arch/e500-regs.exp: Likewise.
	* gdb.arch/gdb1291.exp: Likewise.
	* gdb.arch/gdb1431.exp: Likewise.
	* gdb.arch/gdb1558.exp: Likewise.
	* gdb.arch/i386-prologue.exp: Likewise.
	* gdb.arch/i386-unwind.exp: Likewise.
	* gdb.asm/asm-source.exp: Likewise.
	* gdb.base/a2-run.exp: Likewise.
	* gdb.base/advance.exp: Likewise.
	* gdb.base/all-bin.exp: Likewise.
	* gdb.base/annota1.exp: Likewise.
	* gdb.base/annota3.exp: Likewise.
	* gdb.base/args.exp: Likewise.
	* gdb.base/arithmet.exp: Likewise.
	* gdb.base/assign.exp: Likewise.
	* gdb.base/async.exp: Likewise.
	* gdb.base/attach.exp: Likewise.
	* gdb.base/bang.exp: Likewise.
	* gdb.base/bigcore.exp: Likewise.
	* gdb.base/bitfields.exp: Likewise.
	* gdb.base/bitfields2.exp: Likewise.
	* gdb.base/break.exp: Likewise.
	* gdb.base/call-sc.exp: Likewise.
	* gdb.base/call-strs.exp: Likewise.
	* gdb.base/callfuncs.exp: Likewise.
	* gdb.base/checkpoint.exp: Likewise.
	* gdb.base/chng-syms.exp: Likewise.
	* gdb.base/code-expr.exp: Likewise.
	* gdb.base/commands.exp: Likewise.
	* gdb.base/completion.exp: Likewise.
	* gdb.base/cond-expr.exp: Likewise.
	* gdb.base/condbreak.exp: Likewise.
	* gdb.base/consecutive.exp: Likewise.
	* gdb.base/constvars.exp: Likewise.
	* gdb.base/corefile.exp: Likewise.
	* gdb.base/cvexpr.exp: Likewise.
	* gdb.base/dbx.exp: Likewise.
	* gdb.base/define.exp: Likewise.
	* gdb.base/detach.exp: Likewise.
	* gdb.base/display.exp: Likewise.
	* gdb.base/dump.exp: Likewise.
	* gdb.base/ena-dis-br.exp: Likewise.
	* gdb.base/ending-run.exp: Likewise.
	* gdb.base/environ.exp: Likewise.
	* gdb.base/eval-skip.exp: Likewise.
	* gdb.base/exprs.exp: Likewise.
	* gdb.base/fileio.exp: Likewise.
	* gdb.base/finish.exp: Likewise.
	* gdb.base/float.exp: Likewise.
	* gdb.base/foll-exec.exp: Likewise.
	* gdb.base/foll-fork.exp: Likewise.
	* gdb.base/foll-vfork.exp: Likewise.
	* gdb.base/freebpcmd.exp: Likewise.
	* gdb.base/funcargs.exp: Likewise.
	* gdb.base/gcore.exp: Likewise.
	* gdb.base/gdb1090.exp: Likewise.
	* gdb.base/gdb1250.exp: Likewise.
	* gdb.base/huge.exp: Likewise.
	* gdb.base/info-proc.exp: Likewise.
	* gdb.base/interrupt.exp: Likewise.
	* gdb.base/jump.exp: Likewise.
	* gdb.base/langs.exp: Likewise.
	* gdb.base/lineinc.exp: Likewise.
	* gdb.base/list.exp: Likewise.
	* gdb.base/logical.exp: Likewise.
	* gdb.base/long_long.exp: Likewise.
	* gdb.base/macscp.exp: Likewise.
	* gdb.base/maint.exp: Likewise.
	* gdb.base/mips_pro.exp: Likewise.
	* gdb.base/miscexprs.exp: Likewise.
	* gdb.base/multi-forks.exp: Likewise.
	* gdb.base/opaque.exp: Likewise.
	* gdb.base/overlays.exp: Likewise.
	* gdb.base/pc-fp.exp: Likewise.
	* gdb.base/pointers.exp: Likewise.
	* gdb.base/printcmds.exp: Likewise.
	* gdb.base/psymtab.exp: Likewise.
	* gdb.base/ptype.exp: Likewise.
	* gdb.base/recurse.exp: Likewise.
	* gdb.base/relational.exp: Likewise.
	* gdb.base/relocate.exp: Likewise.
	* gdb.base/remote.exp: Likewise.
	* gdb.base/reread.exp: Likewise.
	* gdb.base/restore.exp: Likewise.
	* gdb.base/return.exp: Likewise.
	* gdb.base/return2.exp: Likewise.
	* gdb.base/scope.exp: Likewise.
	* gdb.base/sect-cmd.exp: Likewise.
	* gdb.base/sep.exp: Likewise.
	* gdb.base/sepdebug.exp: Likewise.
	* gdb.base/setshow.exp: Likewise.
	* gdb.base/setvar.exp: Likewise.
	* gdb.base/sigall.exp: Likewise.
	* gdb.base/sigbpt.exp: Likewise.
	* gdb.base/signals.exp: Likewise.
	* gdb.base/signull.exp: Likewise.
	* gdb.base/sizeof.exp: Likewise.
	* gdb.base/solib.exp: Likewise.
	* gdb.base/step-line.exp: Likewise.
	* gdb.base/step-test.exp: Likewise.
	* gdb.base/structs.exp: Likewise.
	* gdb.base/structs2.exp: Likewise.
	* gdb.base/term.exp: Likewise.
	* gdb.base/twice.exp: Likewise.
	* gdb.base/until.exp: Likewise.
	* gdb.base/varargs.exp: Likewise.
	* gdb.base/volatile.exp: Likewise.
	* gdb.base/watchpoint.exp: Likewise.
	* gdb.base/whatis-exp.exp: Likewise.
	* gdb.base/whatis.exp: Likewise.
	* gdb.cp/ambiguous.exp: Likewise.
	* gdb.cp/annota2.exp: Likewise.
	* gdb.cp/annota3.exp: Likewise.
	* gdb.cp/bool.exp: Likewise.
	* gdb.cp/breakpoint.exp: Likewise.
	* gdb.cp/casts.exp: Likewise.
	* gdb.cp/class2.exp: Likewise.
	* gdb.cp/classes.exp: Likewise.
	* gdb.cp/cplusfuncs.exp: Likewise.
	* gdb.cp/ctti.exp: Likewise.
	* gdb.cp/derivation.exp: Likewise.
	* gdb.cp/exception.exp: Likewise.
	* gdb.cp/gdb1355.exp: Likewise.
	* gdb.cp/hang.exp: Likewise.
	* gdb.cp/inherit.exp: Likewise.
	* gdb.cp/local.exp: Likewise.
	* gdb.cp/m-data.exp: Likewise.
	* gdb.cp/m-static.exp: Likewise.
	* gdb.cp/member-ptr.exp: Likewise.
	* gdb.cp/method.exp: Likewise.
	* gdb.cp/misc.exp: Likewise.
	* gdb.cp/namespace.exp: Likewise.
	* gdb.cp/overload.exp: Likewise.
	* gdb.cp/ovldbreak.exp: Likewise.
	* gdb.cp/pr-1023.exp: Likewise.
	* gdb.cp/pr-1210.exp: Likewise.
	* gdb.cp/pr-574.exp: Likewise.
	* gdb.cp/printmethod.exp: Likewise.
	* gdb.cp/psmang.exp: Likewise.
	* gdb.cp/ref-params.exp: Likewise.
	* gdb.cp/ref-types.exp: Likewise.
	* gdb.cp/rtti.exp: Likewise.
	* gdb.cp/templates.exp: Likewise.
	* gdb.cp/try_catch.exp: Likewise.
	* gdb.cp/userdef.exp: Likewise.
	* gdb.cp/virtfunc.exp: Likewise.
	* gdb.disasm/am33.exp: Likewise.
	* gdb.disasm/h8300s.exp: Likewise.
	* gdb.disasm/mn10300.exp: Likewise.
	* gdb.disasm/sh3.exp: Likewise.
	* gdb.disasm/t01_mov.exp: Likewise.
	* gdb.disasm/t02_mova.exp: Likewise.
	* gdb.disasm/t03_add.exp: Likewise.
	* gdb.disasm/t04_sub.exp: Likewise.
	* gdb.disasm/t05_cmp.exp: Likewise.
	* gdb.disasm/t06_ari2.exp: Likewise.
	* gdb.disasm/t07_ari3.exp: Likewise.
	* gdb.disasm/t08_or.exp: Likewise.
	* gdb.disasm/t09_xor.exp: Likewise.
	* gdb.disasm/t10_and.exp: Likewise.
	* gdb.disasm/t11_logs.exp: Likewise.
	* gdb.disasm/t12_bit.exp: Likewise.
	* gdb.disasm/t13_otr.exp: Likewise.
	* gdb.hp/gdb.aCC/optimize.exp: Likewise.
	* gdb.hp/gdb.aCC/watch-cmd.exp: Likewise.
	* gdb.hp/gdb.base-hp/callfwmall.exp: Likewise.
	* gdb.hp/gdb.base-hp/dollar.exp: Likewise.
	* gdb.hp/gdb.base-hp/hwwatchbus.exp: Likewise.
	* gdb.hp/gdb.base-hp/pxdb.exp: Likewise.
	* gdb.hp/gdb.base-hp/reg-pa64.exp: Likewise.
	* gdb.hp/gdb.base-hp/reg.exp: Likewise.
	* gdb.hp/gdb.base-hp/sized-enum.exp: Likewise.
	* gdb.hp/gdb.compat/xdb1.exp: Likewise.
	* gdb.hp/gdb.compat/xdb3.exp: Likewise.
	* gdb.hp/gdb.objdbg/objdbg01.exp: Likewise.
	* gdb.hp/gdb.objdbg/objdbg02.exp: Likewise.
	* gdb.hp/gdb.objdbg/objdbg03.exp: Likewise.
	* gdb.hp/gdb.objdbg/objdbg04.exp: Likewise.
	* gdb.mi/gdb701.exp: Likewise.
	* gdb.mi/gdb792.exp: Likewise.
	* gdb.mi/mi-basics.exp: Likewise.
	* gdb.mi/mi-break.exp: Likewise.
	* gdb.mi/mi-cli.exp: Likewise.
	* gdb.mi/mi-console.exp: Likewise.
	* gdb.mi/mi-disassemble.exp: Likewise.
	* gdb.mi/mi-eval.exp: Likewise.
	* gdb.mi/mi-file.exp: Likewise.
	* gdb.mi/mi-read-memory.exp: Likewise.
	* gdb.mi/mi-regs.exp: Likewise.
	* gdb.mi/mi-return.exp: Likewise.
	* gdb.mi/mi-simplerun.exp: Likewise.
	* gdb.mi/mi-stack.exp: Likewise.
	* gdb.mi/mi-stepi.exp: Likewise.
	* gdb.mi/mi-syn-frame.exp: Likewise.
	* gdb.mi/mi-until.exp: Likewise.
	* gdb.mi/mi-var-block.exp: Likewise.
	* gdb.mi/mi-var-child.exp: Likewise.
	* gdb.mi/mi-var-cmd.exp: Likewise.
	* gdb.mi/mi-var-display.exp: Likewise.
	* gdb.mi/mi-watch.exp: Likewise.
	* gdb.mi/mi2-basics.exp: Likewise.
	* gdb.mi/mi2-break.exp: Likewise.
	* gdb.mi/mi2-cli.exp: Likewise.
	* gdb.mi/mi2-console.exp: Likewise.
	* gdb.mi/mi2-disassemble.exp: Likewise.
	* gdb.mi/mi2-eval.exp: Likewise.
	* gdb.mi/mi2-file.exp: Likewise.
	* gdb.mi/mi2-read-memory.exp: Likewise.
	* gdb.mi/mi2-regs.exp: Likewise.
	* gdb.mi/mi2-return.exp: Likewise.
	* gdb.mi/mi2-simplerun.exp: Likewise.
	* gdb.mi/mi2-stack.exp: Likewise.
	* gdb.mi/mi2-stepi.exp: Likewise.
	* gdb.mi/mi2-syn-frame.exp: Likewise.
	* gdb.mi/mi2-until.exp: Likewise.
	* gdb.mi/mi2-var-block.exp: Likewise.
	* gdb.mi/mi2-var-child.exp: Likewise.
	* gdb.mi/mi2-var-cmd.exp: Likewise.
	* gdb.mi/mi2-var-display.exp: Likewise.
	* gdb.mi/mi2-watch.exp: Likewise.
	* gdb.stabs/exclfwd.exp: Likewise.
	* gdb.stabs/weird.exp: Likewise.
	* gdb.threads/gcore-thread.exp: Likewise.
	* gdb.trace/actions.exp: Likewise.
	* gdb.trace/backtrace.exp: Likewise.
	* gdb.trace/circ.exp: Likewise.
	* gdb.trace/collection.exp: Likewise.
	* gdb.trace/deltrace.exp: Likewise.
	* gdb.trace/infotrace.exp: Likewise.
	* gdb.trace/limits.exp: Likewise.
	* gdb.trace/packetlen.exp: Likewise.
	* gdb.trace/passc-dyn.exp: Likewise.
	* gdb.trace/passcount.exp: Likewise.
	* gdb.trace/report.exp: Likewise.
	* gdb.trace/save-trace.exp: Likewise.
	* gdb.trace/tfind.exp: Likewise.
	* gdb.trace/tracecmd.exp: Likewise.
	* gdb.trace/while-dyn.exp: Likewise.
	* gdb.trace/while-stepping.exp: Likewise.
@
text
@d2 1
a2 1
# 2003, 2004 Free Software Foundation, Inc.
d501 2
a502 2
    gdb_test "print Bar::z" "\\$\[0-9\]+ = \\(int ?\\( ?Bar::& ?\\) ?\\) ?Bar::z"
    gdb_test "print &Foo::x" "\\$\[0-9\]+ = \\(int ?\\( ?Foo::\\* ?\\) ?\\) ?&Foo::x"
d506 3
@


1.13
log
@2004-08-13  Michael Chastain  <mec.gnu@@mindspring.com>

	* gdb.cp/classes.exp: Remove unused declarations.  Just let
	test names default instead of providing special names.  Remove
	extraneous demangler test.
@
text
@d36 2
a37 1
     gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
@


1.13.26.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@d36 1
a36 2
     untested classes.exp
     return -1
@


1.12
log
@2004-08-12  Michael Chastain  <mec.gnu@@mindspring.com>

	* gdb.cp/classes.exp (test_ptype_class_objects): Call
	cp_test_ptype_class.
	(test_enums): Likewise.
@
text
@a20 1
set ws "\[\r\n\t \]+"
a41 1
    global gdb_prompt
a320 2
# TODO: these test names are gross!
# Just let the test name default.
a322 1
    global gdb_prompt
d325 2
a326 2
    gdb_test "print g_A.a" ".* = 1" "g_A.a incorrect"
    gdb_test "print g_A.x" ".* = 2" "g_A.x incorrect"
d329 2
a330 2
    gdb_test "print g_B.b" ".* = 5" "g_B.b incorrect"
    gdb_test "print g_B.x" ".* = 6" "g_B.x incorrect"
d333 2
a334 2
    gdb_test "print g_C.c" ".* = 9" "g_C.c incorrect"
    gdb_test "print g_C.x" ".* = 10" "g_C.x incorrect"
d337 2
a338 2
    gdb_test "print g_D.d" ".* = 19" "g_D.d incorrect"
    gdb_test "print g_D.x" ".* = 20" "g_D.x incorrect"
d341 2
a342 2
    gdb_test "print g_E.e" ".* = 31" "g_E.e incorrect"
    gdb_test "print g_E.x" ".* = 32" "g_E.x incorrect"
a347 1
# TODO: Again, change the silly test names.
d350 6
a355 8
    global gdb_prompt

    gdb_test "print g_A.b" "There is no member( or method|) named b." "print g_A.b should be error"
    gdb_test "print g_B.c" "There is no member( or method|) named c." "print g_B.c should be error"
    gdb_test "print g_B.d" "There is no member( or method|) named d." "print g_B.d should be error"
    gdb_test "print g_C.b" "There is no member( or method|) named b." "print g_C.b should be error"
    gdb_test "print g_C.d" "There is no member( or method|) named d." "print g_C.d should be error"
    gdb_test "print g_D.e" "There is no member( or method|) named e." "print g_D.e should be error"
a358 1
# TODO: test names again.
d361 4
a364 6
    global gdb_prompt

    gdb_test "print g_A.y" "There is no member( or method|) named y." "print g_A.y should be error"
    gdb_test "print g_B.z" "There is no member( or method|) named z." "print g_B.z should be error"
    gdb_test "print g_C.q" "There is no member( or method|) named q." "print g_C.q should be error"
    gdb_test "print g_D.p" "There is no member( or method|) named p." "print g_D.p should be error"
d371 12
a382 12
    gdb_test "call class_param.Aptr_a (&g_A)" ".* = 1" "base class param->a"
    gdb_test "call class_param.Aptr_x (&g_A)" ".* = 2" "base class param->x"
    gdb_test "call class_param.Aptr_a (&g_B)" ".* = 3" "inherited class param->a"
    gdb_test "call class_param.Aptr_x (&g_B)" ".* = 4" "inherited class param->x"
    gdb_test "call class_param.Aref_a (g_A)" ".* = 1" "base class (&param)->a"
    gdb_test "call class_param.Aref_x (g_A)" ".* = 2" "base class (&param)->x"
    gdb_test "call class_param.Aref_a (g_B)" ".* = 3" "inherited class (&param)->a"
    gdb_test "call class_param.Aref_x (g_B)" ".* = 4" "inherited class (&param)->x"
    gdb_test "call class_param.Aval_a (g_A)" ".* = 1" "base class param.a"
    gdb_test "call class_param.Aval_x (g_A)" ".* = 2" "base class param.x"
    gdb_test "call class_param.Aval_a (g_B)" ".* = 3" "inherited class param.a"
    gdb_test "call class_param.Aval_x (g_B)" ".* = 4" "inherited class param.x"
a393 1
    global ws
a499 2
    global gdb_prompt

a515 1
    global gdb_prompt
a621 5

    # This is a random v2 demangling test.
    # This is redundant with existing tests in demangle.exp.
    # TODO: Just remove this.
    gdb_test "maint demangle inheritance1__Fv" "inheritance1\\(void\\)" "demangle"
@


1.11
log
@2004-07-30  Michael Chastain  <mec.gnu@@mindspring.com>

	* gdb.cp/classes.exp: Accept more varieties of ptype output.
@
text
@d30 2
a40 26
#
# This code accepts the output of gcc v2 and v3, dwarf-2 and stabs+.
# It could use some expansion with other compilers such as hp-ux ac++.
#
# There are lots of variations in the output:
#
# . older gcc -gstabs+ emits debug info for implicit member functions:
#   operator=, copy ctor, ctor.  newer gcc -gstabs+ sometimes emits
#   this debug info.  gcc -gdwarf-2 also emits this debug info,
#   but gdb does not print implicit members in ptype output.
#
# . gcc with abi version 1 puts the implicit member functions
#   at the beginning of the member function list; with abi version 2,
#   the implicit member functions are at the end of the member function
#   list.  This appears as an output difference with -gstabs+.
#   gcc 3.3.X defaults to abi version 1, and gcc 3.4 will default
#   to abi version 2.
#
# . gcc v2 shows data members for virtual base pointers.
#   gcc v3 does not.
#
# . ptype can print either "class ... { public:" or "struct ... {".
#   this depends on the debug info format; on whether the struct/class
#   has any c++ features such as non-public data members, base classes,
#   or member functions; and on other factors.  I accept any form that
#   is semantically the same as the original.
a43 2
    global ws
    global nl
d47 48
a94 31
    set re_class "((struct|class) default_public_struct \{${ws}public:|struct default_public_struct \{)"

    gdb_test_multiple "ptype struct default_public_struct" "ptype struct default_public_struct" {
	-re "type = ${re_class}${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc 3.4.1 -gdwarf-2
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gdwarf-2
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gstabs+
	    pass "ptype struct default_public_struct"
	}
	-re "type = ${re_class}${ws}int a;${ws}int b;${ws}default_public_struct ?& ?operator ?=\\(default_public_struct const ?&\\);${ws}default_public_struct\\(default_public_struct const ?&\\);${ws}default_public_struct\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc 3.4.1 -gstabs+
	    pass "ptype struct default_public_struct"
	}
    }

    # Same test, slightly different type.

    set re_class "((struct|class) explicit_public_struct \{${ws}public:|struct explicit_public_struct \{)"

    gdb_test_multiple "ptype struct explicit_public_struct" "ptype struct explicit_public_struct" {
	-re "type = ${re_class}${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc 3.4.1 -gdwarf-2
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gdwarf-2
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gstabs+
	    pass "ptype struct explicit_public_struct"
a95 70
	-re "type = ${re_class}${ws}int a;${ws}int b;${ws}explicit_public_struct ?& ?operator ?=\\(explicit_public_struct const ?&\\);${ws}explicit_public_struct\\(explicit_public_struct const ?&\\);${ws}explicit_public_struct\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc 3.4.1 -gstabs+
	    pass "ptype struct explicit_public_struct"
	}
    }

    # Same test, slightly different type.

    set re_class "((struct|class) protected_struct \{${ws}protected:)"

    gdb_test_multiple "ptype struct protected_struct" "ptype struct protected_struct" {
	-re "type = ${re_class}${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc 3.4.1 -gdwarf-2
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gdwarf-2
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gstabs+
	    pass "ptype struct protected_struct"
	}
	-re "type = ${re_class}${ws}int a;${ws}int b;${ws}public:${ws}protected_struct ?& ?operator ?=\\(protected_struct const ?&\\);${ws}protected_struct\\(protected_struct const ?&\\);${ws}protected_struct\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc 3.4.1 -gstabs+
	    pass "ptype struct protected_struct"
	}
    }

    # Same test, slightly different type.

    set re_class "((struct|class) private_struct \{${ws}private:|class private_struct \{)"

    gdb_test_multiple "ptype struct private_struct" "ptype struct private_struct" {
	-re "type = ${re_class}${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc 3.4.1 -gdwarf-2
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gdwarf-2
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gstabs+
	    pass "ptype struct private_struct"
	}
	-re "type = ${re_class}${ws}int a;${ws}int b;${ws}public:${ws}private_struct ?& ?operator ?=\\(private_struct const ?&\\);${ws}private_struct\\(private_struct const ?&\\);${ws}private_struct\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc 3.4.1 -gstabs+
	    pass "ptype struct private_struct"
	}
    }

    # Similar test, bigger type.

    set re_class "((struct|class) mixed_protection_struct \{${ws}public:|struct mixed_protection_struct \{)"

    gdb_test_multiple "ptype struct mixed_protection_struct" "ptype struct mixed_protection_struct" {
	-re "type = ${re_class}${ws}int a;${ws}int b;${ws}private:${ws}int c;${ws}int d;${ws}protected:${ws}int e;${ws}int f;${ws}public:${ws}int g;${ws}private:${ws}int h;${ws}protected:${ws}int i;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc 3.4.1 -gdwarf-2
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gdwarf-2
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gstabs+
	    pass "ptype struct mixed_protection_struct"
	}
	-re "type = ${re_class}${ws}int a;${ws}int b;${ws}private:${ws}int c;${ws}int d;${ws}protected:${ws}int e;${ws}int f;${ws}public:${ws}int g;${ws}private:${ws}int h;${ws}protected:${ws}int i;${ws}public:${ws}mixed_protection_struct ?& ?operator ?=\\(mixed_protection_struct const ?&\\);${ws}mixed_protection_struct\\(mixed_protection_struct const ?&\\);${ws}mixed_protection_struct\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc 3.4.1 -gstabs+
	    pass "ptype struct mixed_protection_struct"
	}
    }
d100 5
a104 16
    set re_class "((struct|class) public_class \{${ws}public:|struct public_class \{)"

    gdb_test_multiple "ptype class public_class" "ptype class public_class" {
	-re "type = ${re_class}${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc 3.4.1 -gdwarf-2
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gdwarf-2
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gstabs+
	    pass "ptype class public_class"
	}
	-re "type = ${re_class}${ws}int a;${ws}int b;${ws}public_class ?& ?operator ?=\\(public_class const ?&\\);${ws}public_class\\(public_class const ?&\\);${ws}public_class\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc 3.4.1 -gstabs+
	    pass "ptype class public_class"
a105 1
    }
d107 1
a107 1
    # Same test, slightly different type.
d109 5
a113 16
    set re_class "((struct|class) protected_class \{${ws}protected:)"

    gdb_test_multiple "ptype class protected_class" "ptype class protected_class" {
	-re "type = ${re_class}${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc 3.4.1 -gdwarf-2
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gdwarf-2
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gstabs+
	    pass "ptype class protected_class"
	}
	-re "type = ${re_class}${ws}int a;${ws}int b;${ws}public:${ws}protected_class ?& ?operator ?=\\(protected_class const ?&\\);${ws}protected_class\\(protected_class const ?&\\);${ws}protected_class\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc 3.4.1 -gstabs+
	    pass "ptype class protected_class"
a114 1
    }
d116 1
a116 1
    # Same test, slightly different type.
d118 5
a122 16
    set re_class "((struct|class) default_private_class \{${ws}private:|class default_private_class \{)"

    gdb_test_multiple "ptype class default_private_class" "ptype class default_private_class" {
	-re "type = ${re_class}${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc 3.4.1 -gdwarf-2
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gdwarf-2
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gstabs+
	    pass "ptype class default_private_class"
	}
	-re "type = ${re_class}${ws}int a;${ws}int b;${ws}public:${ws}default_private_class ?& ?operator ?=\\(default_private_class const ?&\\);${ws}default_private_class\\(default_private_class const ?&\\);${ws}default_private_class\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc 3.4.1 -gstabs+
	    pass "ptype class default_private_class"
a123 1
    }
d125 1
a125 1
    # Same test, slightly different type.
d127 5
a131 16
    set re_class "((struct|class) explicit_private_class \{${ws}private:|class explicit_private_class \{)"

    gdb_test_multiple "ptype class explicit_private_class" "ptype class explicit_private_class" {
	-re "type = ${re_class}${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc 3.4.1 -gdwarf-2
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gdwarf-2
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gstabs+
	    pass "ptype class explicit_private_class"
	}
	-re "type = ${re_class}${ws}int a;${ws}int b;${ws}public:${ws}explicit_private_class ?& ?operator ?=\\(explicit_private_class const ?&\\);${ws}explicit_private_class\\(explicit_private_class const ?&\\);${ws}explicit_private_class\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc 3.4.1 -gstabs+
	    pass "ptype class explicit_private_class"
a132 1
    }
d134 1
a134 1
    # Similar test, bigger type.
d136 3
a138 1
    set re_class "((struct|class) mixed_protection_class \{${ws}public:|struct mixed_protection_class \{)"
d140 9
a148 14
    gdb_test_multiple "ptype class mixed_protection_class" "ptype struct mixed_protection_class" {
	-re "type = ${re_class}${ws}int a;${ws}int b;${ws}private:${ws}int c;${ws}int d;${ws}protected:${ws}int e;${ws}int f;${ws}public:${ws}int g;${ws}private:${ws}int h;${ws}protected:${ws}int i;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc 3.4.1 -gdwarf-2
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gdwarf-2
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gstabs+
	    pass "ptype class mixed_protection_class"
	}
	-re "type = ${re_class}${ws}int a;${ws}int b;${ws}private:${ws}int c;${ws}int d;${ws}protected:${ws}int e;${ws}int f;${ws}public:${ws}int g;${ws}private:${ws}int h;${ws}protected:${ws}int i;${ws}public:${ws}mixed_protection_class ?& ?operator ?=\\(mixed_protection_class const ?&\\);${ws}mixed_protection_class\\(mixed_protection_class const ?&\\);${ws}mixed_protection_class\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc 3.4.1 -gstabs+
	    pass "ptype class mixed_protection_class"
a149 1
    }
d155 5
a159 16
    set re_class "((struct|class) A \{${ws}public:|struct A \{)"

    gdb_test_multiple "ptype class A" "ptype class A" {
	-re "type = ${re_class}${ws}int a;${ws}int x;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc 3.4.1 -gdwarf-2
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gdwarf-2
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gstabs+
	    pass "ptype class A"
	}
	-re "type = ${re_class}${ws}int a;${ws}int x;${ws}A ?& ?operator ?=\\(A const ?&\\);${ws}A\\(A const ?&\\);${ws}A\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc 3.4.1 -gstabs+
	    pass "ptype class A"
a160 1
    }
d164 6
a169 16
    set re_class "((struct|class) B : public A \{${ws}public:|struct B : public A \{)"

    gdb_test_multiple "ptype class B" "ptype class B" {
	-re "type = ${re_class}${ws}int b;${ws}int x;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc 3.4.1 -gdwarf-2
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gdwarf-2
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gstabs+
	    pass "ptype class B"
	}
	-re "type = ${re_class}${ws}int b;${ws}int x;${ws}B ?& ?operator ?=\\(B const ?&\\);${ws}B\\(B const ?&\\);${ws}B\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc 3.4.1 -gstabs+
	    pass "ptype class B"
a170 1
    }
d174 6
a179 16
    set re_class "((struct|class) C : public A \{${ws}public:|struct C : public A \{)"

    gdb_test_multiple "ptype class C" "ptype class C" {
	-re "${re_class}${ws}int c;${ws}int x;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc 3.4.1 -gdwarf-2
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gdwarf-2
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gstabs+
	    pass "ptype class C"
	}
	-re "${re_class}${ws}int c;${ws}int x;${ws}C ?& ?operator ?=\\(C const ?&\\);${ws}C\\(C const ?&\\);${ws}C\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc 3.4.1 -gstabs+
	    pass "ptype class C"
a180 1
    }
d184 7
a190 16
    set re_class "((struct|class) D : public B, public C \{${ws}public:|struct D : public B, public C \{)"

    gdb_test_multiple "ptype class D" "ptype class D" {
	-re "type = ${re_class}${ws}int d;${ws}int x;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc 3.4.1 -gdwarf-2
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gdwarf-2
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gstabs+
	    pass "ptype class D"
	}
	-re "type = ${re_class}${ws}int d;${ws}int x;${ws}D ?& ?operator ?=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc 3.4.1 -gstabs+
	    pass "ptype class D"
a191 1
    }
d195 6
a200 16
    set re_class "((struct|class) E : public D \{${ws}public:|struct E : public D \{)"

    gdb_test_multiple "ptype class E" "ptype class E" {
	-re "type = ${re_class}${ws}int e;${ws}int x;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc 3.4.1 -gdwarf-2
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gdwarf-2
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gstabs+
	    pass "ptype class E"
	}
	-re "type = ${re_class}${ws}int e;${ws}int x;${ws}E ?& ?operator ?=\\(E const ?&\\);${ws}E\\(E const ?&\\);${ws}E\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc 3.4.1 -gstabs+
	    pass "ptype class E"
a201 1
    }
d208 4
a211 19
    set re_class "((struct|class) Static \{${ws}public:|struct Static \{)"

    gdb_test_multiple "ptype class Static" "ptype class Static" {
	-re "type = ${re_class}${ws}static void ii\\(int, int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc 3.4.1 -gdwarf-2
	      # gcc HEAD 2004-07-31 00:45:52 UTC -gdwarf-2
	      # gcc HEAD 2004-07-31 00:45:52 UTC -gstabs+
	    pass "ptype class Static"
	}
	-re "type = ${re_class}${ws}Static ?& ?operator ?=\\(Static const ?&\\);${ws}Static\\(Static const ?&\\);${ws}Static\\((void|)\\);${ws}static void ii\\(int, int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    pass "ptype class Static"
	}
	-re "type = ${re_class}${ws}static void ii\\(int, int\\);${ws}Static ?& ?operator ?=\\(Static const ?&\\);${ws}Static\\(Static const ?&\\);${ws}Static\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 3.4.1 -gstabs+
	    pass "ptype class Static"
a212 1
    }
d216 1
a216 127
    set re_class "((struct|class) vA \{${ws}public:|struct vA \{)"

    gdb_test_multiple "ptype class vA" "ptype class vA" {
	-re "type = ${re_class}${ws}int va;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc 3.4.1 -gdwarf-2
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gdwarf-2
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gstabs+
	    pass "ptype class vA"
	}
	-re "type = ${re_class}${ws}int va;${ws}int vx;${ws}vA ?& ?operator ?=\\(vA const ?&\\);${ws}vA\\(vA const ?&\\);${ws}vA\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc 3.4.1 -gstabs+
	    pass "ptype class vA"
	}
    }

    # With gcc 2, gdb prints the virtual base pointer.
    # With gcc 3, gdb does not print the virtual base pointer.
    # drow considers it a gdb bug if gdb prints the vbptr.

    set re_class_private "((struct|class) vB : public virtual vA \{${ws}private:|class vB : public virtual vA \{)"
    set re_class_public "((struct|class) vB : public virtual vA \{${ws}public:|struct vB : public virtual vA \{)"

    gdb_test_multiple "ptype class vB" "ptype class vB" {
	-re "type = ${re_class_private}${ws}private:${ws}vA ?\\* ?_vb.2vA;${ws}public:${ws}int vb;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # TODO: kfail this
	    fail "ptype class vB"
	}
	-re "type = ${re_class_public}${ws}int vb;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.4 -gdwarf-2
	    # gcc 3.4.1 -gdwarf-2
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gdwarf-2
	    pass "ptype class vB"
	}
	-re "type = ${re_class_private}${ws}vA ?\\* ?_vb.vA;${ws}public:${ws}int vb;${ws}int vx;${ws}vB ?& ?operator ?=\\(vB const ?&\\);${ws}vB\\(int, ?vB const ?&\\);${ws}vB\\(int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # See the hidden "in-charge" ctor parameter!
	    # TODO: kfail this
	    setup_xfail "*-*-*"
	    fail "ptype class vB (FIXME: non-portable virtual table constructs)"
	}
	-re "type = ${re_class_public}${ws}int vb;${ws}int vx;${ws}vB ?& ?operator ?=\\(vB const ?&\\);${ws}vB\\(vB const ?&\\);${ws}vB\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.4 -gstabs+
	    # gcc 3.4.1 -gstabs+
	    pass "ptype class vB"
	}
	-re "type = ${re_class_public}${ws}int vb;${ws}int vx;${ws}vB\\(vB const ?&\\);${ws}vB\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gstabs+
	    pass "ptype class vB"
	}
    }

    # Another class with a virtual base.

    set re_class_private "((struct|class) vC : public virtual vA \{${ws}private:|class vC : public virtual vA \{)"
    set re_class_public "((struct|class) vC : public virtual vA \{${ws}public:|struct vC : public virtual vA \{)"

    gdb_test_multiple "ptype class vC" "ptype class vC" {
	-re "type = ${re_class_private}${ws}private:${ws}vA ?\\* ?_vb.2vA;${ws}public:${ws}int vc;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # TODO: kfail this
	    fail "ptype class vC"
	}
	-re "type = ${re_class_public}${ws}int vc;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.4 -gdwarf-2
	    # gcc 3.4.1 -gdwarf-2
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gdwarf-2
	    pass "ptype class vC"
	}
	-re "type = ${re_class_private}${ws}vA ?\\* ?_vb.vA;${ws}public:${ws}int vc;${ws}int vx;${ws}vC ?& ?operator ?=\\(vC const ?&\\);${ws}vC\\(int, ?vC const ?&\\);${ws}vC\\(int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # See the hidden "in-charge" ctor parameter!
	    # TODO: kfail this
	    setup_xfail "*-*-*"
	    fail "ptype class vC (FIXME: non-portable virtual table constructs)"
	}
	-re "type = ${re_class_public}${ws}int vc;${ws}int vx;${ws}vC ?& ?operator ?=\\(vC const ?&\\);${ws}vC\\(vC const ?&\\);${ws}vC\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.4 -gstabs+
	    # gcc 3.4.1 -gstabs+
	    pass "ptype class vC"
	}
	-re "type = ${re_class_public}${ws}int vc;${ws}int vx;${ws}vC\\(vC const ?&\\);${ws}vC\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gstabs+
	    pass "ptype class vC"
	}
    }

    # The classic diamond inheritance.

    set re_class_private "((struct|class) vD : public virtual vB, public virtual vC \{${ws}private:|class vD : public virtual vB, public virtual vC \{)"
    set re_class_public "((struct|class) vD : public virtual vB, public virtual vC \{${ws}public:|struct vD : public virtual vB, public virtual vC \{)"

    gdb_test_multiple "ptype class vD" "ptype class vD" {
	-re "type = ${re_class_private}${ws}vC ?\\* ?_vb.2vC;${ws}vB ?\\* ?_vb.2vB;${ws}public:${ws}int vd;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # TODO: kfail
	    fail "ptype class vD"
	}
	-re "type = ${re_class_public}${ws}int vd;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gdwarf-2
	    # gcc 3.4.1 -gdwarf-2
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gdwarf-2
	    pass "ptype class vD"
	}
	-re "type = ${re_class_private}${ws}vC ?\\* ?_vb.vC;${ws}vB ?\\* ?_vb.vB;${ws}public:${ws}int vd;${ws}int vx;${ws}vD ?& ?operator ?=\\(vD const ?&\\);${ws}vD\\(int, ?vD const ?&\\);${ws}vD\\(int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # See the hidden "in-charge" ctor parameter!
	    # TODO: kfail
	    setup_xfail "*-*-*"
	    fail "ptype class vD (FIXME: non-portable virtual table constructs)"
	}
	-re "type = ${re_class_public}${ws}int vd;${ws}int vx;${ws}vD ?& ?operator ?=\\(vD const ?&\\);${ws}vD\\(vD const ?&\\);${ws}vD\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gstabs+
	    # gcc 3.4.1 -gstabs+
	    pass "ptype class vD"
	}
	-re "type = ${re_class_public}${ws}int vd;${ws}int vx;${ws}vD\\(vD const ?&\\);${ws}vD\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gdwarf-2
	    pass "ptype class vD"
	}
    }

    # One more case of virtual derivation.
d218 51
a268 30
    set re_class_private "((struct|class) vE : public virtual vD \{${ws}private:|class vE : public virtual vD \{)"
    set re_class_public "((struct|class) vE : public virtual vD \{${ws}public:|struct vE : public virtual vD \{)"

    gdb_test_multiple "ptype class vE" "ptype class vE" {
	-re "type = ${re_class_private}${ws}vD ?\\* ?_vb.2vD;${ws}public:${ws}int ve;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # TODO: kfail
	    fail "ptype class vE"
	}
	-re "type = ${re_class_public}${ws}int ve;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gdwarf-2
	    # gcc 3.4.1 -gdwarf-2
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gdwarf-2
	    pass "ptype class vE"
	}
	-re "type = ${re_class_private}${ws}vD ?\\* ?_vb.vD;${ws}public:${ws}int ve;${ws}int vx;${ws}vE ?& ?operator ?=\\(vE const ?&\\);${ws}vE\\(int, ?vE const ?&\\);${ws}vE\\(int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # See the hidden "in-charge" ctor parameter!
	    # TODO: kfail
	    setup_xfail "*-*-*"
	    fail "ptype class vE (FIXME: non-portable virtual table constructs)"
	}
	-re "type = ${re_class_public}${ws}int ve;${ws}int vx;${ws}vE ?& ?operator ?=\\(vE const ?&\\);${ws}vE\\(vE const ?&\\);${ws}vE\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gstabs+
	    # gcc 3.4.1 -gstabs+
	    pass "ptype class vE"
	}
	-re "type = ${re_class_public}${ws}int ve;${ws}int vx;${ws}vE\\(vE const ?&\\);${ws}vE\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc HEAD 2004-07-31 00:45:52 UTC -gstabs+
	    pass "ptype class vE"
a269 1
    }
d273 1
a273 19
    gdb_test_multiple "ptype class Base1" "ptype class Base1" {
	-re "type = class Base1 \{${ws}public:${ws}int x;${ws}Base1\\(int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
	    pass "ptype class Base1"
	}
	-re "type = class Base1 \{${ws}public:${ws}int x;${ws}Base1 ?& ?operator ?=\\(Base1 const ?&\\);${ws}Base1\\(Base1 const ?&\\);${ws}Base1\\(int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    pass "ptype class Base1"
	}
	-re "type = class Base1 \{${ws}public:${ws}int x;${ws}Base1\\(int\\);${ws}Base1 ?& ?operator ?=\\(Base1 const ?&\\);${ws}Base1\\(Base1 const ?&\\);$nl\}$nl$gdb_prompt $" {
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class Base1"
	}
    }

    # The second base class.
d275 32
a306 12
    gdb_test_multiple "ptype class Foo" "ptype class Foo" {
	-re "type = class Foo \{${ws}public:${ws}int x;${ws}int y;${ws}static int st;${ws}Foo\\(int, int\\);${ws}int operator ?!\\((void|)\\);${ws}operator int\\((void|)\\);${ws}int times\\(int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
	    pass "ptype class Foo"
	}
	-re "type = class Foo \{${ws}public:${ws}int x;${ws}int y;${ws}static int st;${ws}Foo ?& ?operator ?=\\(Foo const ?&\\);${ws}Foo\\(Foo const ?&\\);${ws}Foo\\(int, int\\);${ws}int operator ?!\\((void|)\\);${ws}int operator int\\((void|)\\);${ws}int times\\(int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # TODO: "int operator int()" is a bug
	    # kfail "gdb/1497" "ptype class Foo"
	    pass "ptype class Foo"
a307 9
	-re "type = class Foo \{${ws}public:${ws}int x;${ws}int y;${ws}static int st;${ws}Foo ?& ?operator ?=\\(Foo const ?&\\);${ws}Foo\\(Foo const ?&\\);${ws}Foo\\(int, int\\);${ws}int operator ?!\\((void|)\\);${ws}operator int\\((void|)\\);${ws}int times\\(int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gstabs+
	    pass "ptype class Foo"
	}
	-re "type = class Foo \{${ws}public:${ws}int x;${ws}int y;${ws}static int st;${ws}Foo\\(int, int\\);${ws}int operator ?!\\((void|)\\);${ws}operator int\\((void|)\\);${ws}int times\\(int\\);${ws}Foo ?& ?operator ?=\\(Foo const ?&\\);${ws}Foo\\(Foo const ?&\\);$nl\}$nl$gdb_prompt $" {
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class Foo"
	}
    }
d311 7
a317 6
    gdb_test_multiple "ptype class Bar" "ptype class Bar" {
	-re "type = class Bar : public Base1, public Foo \{${ws}public:${ws}int z;${ws}Bar\\(int, int, int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
	    pass "ptype class Bar"
d319 1
a319 10
	-re "type = class Bar : public Base1, public Foo \{${ws}public:${ws}int z;${ws}Bar ?& ?operator ?=\\(Bar const ?&\\);${ws}Bar\\(Bar const ?&\\);${ws}Bar\\(int, int, int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    pass "ptype class Bar"
	}
	-re "type = class Bar : public Base1, public Foo \{${ws}public:${ws}int z;${ws}Bar\\(int, int, int\\);${ws}Bar ?& ?operator ?=\\(Bar const ?&\\);${ws}Bar\\(Bar const ?&\\);$nl\}$nl$gdb_prompt $" {
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class Bar"
	}
    }
d455 22
a476 23
    set re_class "((struct|class) ClassWithEnum \{${ws}public:|struct ClassWithEnum \{)"

    gdb_test_multiple "ptype obj_with_enum" "ptype obj_with_enum" {
	-re "type = ${re_class}${ws}(enum |)ClassWithEnum::PrivEnum priv_enum;${ws}int x;$nl\}$nl$gdb_prompt $" {
	    pass "ptype obj_with_enum"
	}
	-re "type = ${re_class}${ws}(enum |)PrivEnum priv_enum;${ws}int x;$nl\}$nl$gdb_prompt $" {
	    # NOTE: carlton/2003-02-28: One could certainly argue that
	    # this output is acceptable: PrivEnum is a member of
	    # ClassWithEnum, so there's no need to explicitly qualify
	    # its name with "ClassWithEnum::".  The truth, though, is
	    # that GDB is simply forgetting that PrivEnum is a member
	    # of ClassWithEnum, so we do that output for a bad reason
	    # instead of a good reason.  Under stabs, we probably
	    # can't get this right; under DWARF-2, we can.
	    #
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    kfail "gdb/57" "ptype obj_with_enum"
	}
	-re "type = ${re_class}${ws}(enum |)PrivEnum priv_enum;${ws}int x;${ws}ClassWithEnum ?& ?operator ?=\\(ClassWithEnum const ?&\\);${ws}ClassWithEnum\\(ClassWithEnum const ?&\\);${ws}ClassWithEnum\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    kfail "gdb/57" "ptype obj_with_enum"
a477 9
	-re "type = ${re_class}${ws}(enum |)ClassWithEnum::PrivEnum priv_enum;${ws}int x;${ws}ClassWithEnum ?& ?operator ?=\\(ClassWithEnum const ?&\\);${ws}ClassWithEnum\\(ClassWithEnum const ?&\\);${ws}ClassWithEnum\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # I think this is a PASS, but only carlton knows for sure.
	    # -- chastain 2003-12-30
	    #
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    fail "ptype obj_with_enum"
	}
    }
@


1.10
log
@2004-03-17  David Carlton  <carlton@@kealia.com>

	* gdb.cp/classes.exp (test_enums): Refer to PR c++/1588 instead of
	PR c++/826.
@
text
@d45 4
a48 2
# . gcc -stabs+ emits debug info for implicit member functions:
#   operator=, copy ctor, ctor.  gcc -gdwarf-2 does not.
d60 5
a64 2
# . gdb always prints "class" for both "class" and "struct".
#   In the future, I should accept "struct" in case gdb improves.
d73 2
d76 1
a76 1
	-re "type = class default_public_struct \{${ws}public:${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
d79 3
a81 1
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d84 1
a84 1
	-re "type = class default_public_struct \{${ws}public:${ws}int a;${ws}int b;${ws}default_public_struct ?& ?operator ?=\\(default_public_struct const ?&\\);${ws}default_public_struct\\(default_public_struct const ?&\\);${ws}default_public_struct\\((void|)\\);$nl\}$nl$gdb_prompt $" {
d87 1
a87 1
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d94 2
d97 1
a97 1
	-re "type = class explicit_public_struct \{${ws}public:${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
d100 3
a102 1
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d105 1
a105 1
	-re "type = class explicit_public_struct \{${ws}public:${ws}int a;${ws}int b;${ws}explicit_public_struct ?& ?operator ?=\\(explicit_public_struct const ?&\\);${ws}explicit_public_struct\\(explicit_public_struct const ?&\\);${ws}explicit_public_struct\\((void|)\\);$nl\}$nl$gdb_prompt $" {
d108 1
a108 1
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d115 2
d118 1
a118 1
	-re "type = class protected_struct \{${ws}protected:${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
d121 3
a123 1
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d126 1
a126 1
	-re "type = class protected_struct \{${ws}protected:${ws}int a;${ws}int b;${ws}public:${ws}protected_struct ?& ?operator ?=\\(protected_struct const ?&\\);${ws}protected_struct\\(protected_struct const ?&\\);${ws}protected_struct\\((void|)\\);$nl\}$nl$gdb_prompt $" {
d129 1
a129 1
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d136 2
d139 1
a139 1
	-re "type = class private_struct \{${ws}private:${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
d142 3
a144 1
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d147 1
a147 1
	-re "type = class private_struct \{${ws}private:${ws}int a;${ws}int b;${ws}public:${ws}private_struct ?& ?operator ?=\\(private_struct const ?&\\);${ws}private_struct\\(private_struct const ?&\\);${ws}private_struct\\((void|)\\);$nl\}$nl$gdb_prompt $" {
d150 1
a150 1
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d157 2
d160 1
a160 1
	-re "type = class mixed_protection_struct \{${ws}public:${ws}int a;${ws}int b;${ws}private:${ws}int c;${ws}int d;${ws}protected:${ws}int e;${ws}int f;${ws}public:${ws}int g;${ws}private:${ws}int h;${ws}protected:${ws}int i;$nl\}$nl$gdb_prompt $" {
d163 3
a165 1
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d168 1
a168 1
	-re "type = class mixed_protection_struct \{${ws}public:${ws}int a;${ws}int b;${ws}private:${ws}int c;${ws}int d;${ws}protected:${ws}int e;${ws}int f;${ws}public:${ws}int g;${ws}private:${ws}int h;${ws}protected:${ws}int i;${ws}public:${ws}mixed_protection_struct ?& ?operator ?=\\(mixed_protection_struct const ?&\\);${ws}mixed_protection_struct\\(mixed_protection_struct const ?&\\);${ws}mixed_protection_struct\\((void|)\\);$nl\}$nl$gdb_prompt $" {
d171 1
a171 1
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d179 2
d182 1
a182 1
	-re "type = class public_class \{${ws}public:${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
d185 3
a187 1
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d190 1
a190 1
	-re "type = class public_class \{${ws}public:${ws}int a;${ws}int b;${ws}public_class ?& ?operator ?=\\(public_class const ?&\\);${ws}public_class\\(public_class const ?&\\);${ws}public_class\\((void|)\\);$nl\}$nl$gdb_prompt $" {
d193 1
a193 1
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d200 2
d203 1
a203 1
	-re "type = class protected_class \{${ws}protected:${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
d206 3
a208 1
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d211 1
a211 1
	-re "type = class protected_class \{${ws}protected:${ws}int a;${ws}int b;${ws}public:${ws}protected_class ?& ?operator ?=\\(protected_class const ?&\\);${ws}protected_class\\(protected_class const ?&\\);${ws}protected_class\\((void|)\\);$nl\}$nl$gdb_prompt $" {
d214 1
a214 1
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d220 2
a221 1
    # The 'private' is optional but gdb always prints it.
d224 1
a224 1
	-re "type = class default_private_class \{${ws}(private:${ws}|)int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
d227 3
a229 1
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d232 1
a232 1
	-re "type = class default_private_class \{${ws}(private:${ws}|)int a;${ws}int b;${ws}public:${ws}default_private_class ?& ?operator ?=\\(default_private_class const ?&\\);${ws}default_private_class\\(default_private_class const ?&\\);${ws}default_private_class\\((void|)\\);$nl\}$nl$gdb_prompt $" {
d235 1
a235 1
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d242 2
d245 1
a245 1
	-re "type = class explicit_private_class \{${ws}(private:${ws}|)int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
d248 3
a250 1
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d253 1
a253 1
	-re "type = class explicit_private_class \{${ws}(private:${ws}|)int a;${ws}int b;${ws}public:${ws}explicit_private_class ?& ?operator ?=\\(explicit_private_class const ?&\\);${ws}explicit_private_class\\(explicit_private_class const ?&\\);${ws}explicit_private_class\\((void|)\\);$nl\}$nl$gdb_prompt $" {
d256 1
a256 1
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d263 2
d266 1
a266 1
	-re "type = class mixed_protection_class \{${ws}public:${ws}int a;${ws}int b;${ws}private:${ws}int c;${ws}int d;${ws}protected:${ws}int e;${ws}int f;${ws}public:${ws}int g;${ws}private:${ws}int h;${ws}protected:${ws}int i;$nl\}$nl$gdb_prompt $" {
d269 3
a271 1
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d274 1
a274 1
	-re "type = class mixed_protection_class \{${ws}public:${ws}int a;${ws}int b;${ws}private:${ws}int c;${ws}int d;${ws}protected:${ws}int e;${ws}int f;${ws}public:${ws}int g;${ws}private:${ws}int h;${ws}protected:${ws}int i;${ws}public:${ws}mixed_protection_class ?& ?operator ?=\\(mixed_protection_class const ?&\\);${ws}mixed_protection_class\\(mixed_protection_class const ?&\\);${ws}mixed_protection_class\\((void|)\\);$nl\}$nl$gdb_prompt $" {
d277 1
a277 1
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d286 2
d289 1
a289 1
	-re "type = class A \{${ws}public:${ws}int a;${ws}int x;$nl\}$nl$gdb_prompt $" {
d292 3
a294 1
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d297 1
a297 1
	-re "type = class A \{${ws}public:${ws}int a;${ws}int x;${ws}A ?& ?operator ?=\\(A const ?&\\);${ws}A\\(A const ?&\\);${ws}A\\((void|)\\);$nl\}$nl$gdb_prompt $" {
d300 1
a300 1
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d307 2
d310 1
a310 1
	-re "type = class B : public A \{${ws}public:${ws}int b;${ws}int x;$nl\}$nl$gdb_prompt $" {
d313 3
a315 1
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d318 1
a318 1
	-re "type = class B : public A \{${ws}public:${ws}int b;${ws}int x;${ws}B ?& ?operator ?=\\(B const ?&\\);${ws}B\\(B const ?&\\);${ws}B\\((void|)\\);$nl\}$nl$gdb_prompt $" {
d321 1
a321 1
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d328 2
d331 1
a331 1
	-re "type = class C : public A \{${ws}public:${ws}int c;${ws}int x;$nl\}$nl$gdb_prompt $" {
d334 3
a336 1
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d339 1
a339 1
	-re "type = class C : public A \{${ws}public:${ws}int c;${ws}int x;${ws}C ?& ?operator ?=\\(C const ?&\\);${ws}C\\(C const ?&\\);${ws}C\\((void|)\\);$nl\}$nl$gdb_prompt $" {
d342 1
a342 1
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d349 2
d352 1
a352 1
	-re "type = class D : public B, public C \{${ws}public:${ws}int d;${ws}int x;$nl\}$nl$gdb_prompt $" {
d355 3
a357 1
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d360 1
a360 1
	-re "type = class D : public B, public C \{${ws}public:${ws}int d;${ws}int x;${ws}D ?& ?operator ?=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\((void|)\\);$nl\}$nl$gdb_prompt $" {
d363 1
a363 1
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d370 2
d373 1
a373 1
	-re "type = class E : public D \{${ws}public:${ws}int e;${ws}int x;$nl\}$nl$gdb_prompt $" {
d376 3
a378 1
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d381 1
a381 1
	-re "type = class E : public D \{${ws}public:${ws}int e;${ws}int x;${ws}E ?& ?operator ?=\\(E const ?&\\);${ws}E\\(E const ?&\\);${ws}E\\((void|)\\);$nl\}$nl$gdb_prompt $" {
d384 1
a384 1
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d394 2
d397 1
a397 1
	-re "type = class Static \{${ws}public:${ws}static void ii\\(int, int\\);$nl\}$nl$gdb_prompt $" {
d400 3
a402 1
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d405 1
a405 1
	-re "type = class Static \{${ws}public:${ws}Static ?& ?operator ?=\\(Static const ?&\\);${ws}Static\\(Static const ?&\\);${ws}Static\\((void|)\\);${ws}static void ii\\(int, int\\);$nl\}$nl$gdb_prompt $" {
d410 2
a411 2
	-re "type = class Static \{${ws}public:${ws}static void ii\\(int, int\\);${ws}Static ?& ?operator ?=\\(Static const ?&\\);${ws}Static\\(Static const ?&\\);${ws}Static\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d418 2
d421 1
a421 1
	-re "type = class vA \{${ws}public:${ws}int va;${ws}int vx;$nl\}$nl$gdb_prompt $" {
d424 3
a426 1
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d429 1
a429 1
	-re "type = class vA \{${ws}public:${ws}int va;${ws}int vx;${ws}vA ?& ?operator ?=\\(vA const ?&\\);${ws}vA\\(vA const ?&\\);${ws}vA\\((void|)\\);$nl\}$nl$gdb_prompt $" {
d432 1
a432 1
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d441 3
d445 1
a445 1
	-re "type = class vB : public virtual vA \{${ws}private:${ws}vA ?\\* ?_vb.2vA;${ws}public:${ws}int vb;${ws}int vx;$nl\}$nl$gdb_prompt $" {
d450 4
a453 3
	-re "type = class vB : public virtual vA \{${ws}public:${ws}int vb;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d456 1
a456 1
	-re "type = class vB : public virtual vA \{${ws}private:${ws}vA ?\\* ?_vb.vA;${ws}public:${ws}int vb;${ws}int vx;${ws}vB ?& ?operator ?=\\(vB const ?&\\);${ws}vB\\(int, ?vB const ?&\\);${ws}vB\\(int\\);$nl\}$nl$gdb_prompt $" {
d463 7
a469 3
	-re "type = class vB : public virtual vA \{${ws}public:${ws}int vb;${ws}int vx;${ws}vB ?& ?operator ?=\\(vB const ?&\\);${ws}vB\\(vB const ?&\\);${ws}vB\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d476 3
d480 1
a480 1
	-re "type = class vC : public virtual vA \{${ws}private:${ws}vA ?\\* ?_vb.2vA;${ws}public:${ws}int vc;${ws}int vx;$nl\}$nl$gdb_prompt $" {
d482 1
a482 1
	    # TODO: kfail
d485 4
a488 3
	-re "type = class vC : public virtual vA \{${ws}public:${ws}int vc;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d491 1
a491 1
	-re "type = class vC : public virtual vA \{${ws}private:${ws}vA ?\\* ?_vb.vA;${ws}public:${ws}int vc;${ws}int vx;${ws}vC ?& ?operator ?=\\(vC const ?&\\);${ws}vC\\(int, ?vC const ?&\\);${ws}vC\\(int\\);$nl\}$nl$gdb_prompt $" {
d494 1
a494 1
	    # TODO: kfail
d498 7
a504 3
	-re "type = class vC : public virtual vA \{${ws}public:${ws}int vc;${ws}int vx;${ws}vC ?& ?operator ?=\\(vC const ?&\\);${ws}vC\\(vC const ?&\\);${ws}vC\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d511 3
d515 1
a515 1
	-re "type = class vD : public virtual vB, public virtual vC \{${ws}private:${ws}vC ?\\* ?_vb.2vC;${ws}vB ?\\* ?_vb.2vB;${ws}public:${ws}int vd;${ws}int vx;$nl\}$nl$gdb_prompt $" {
d520 1
a520 1
	-re "type = class vD : public virtual vB, public virtual vC \{${ws}public:${ws}int vd;${ws}int vx;$nl\}$nl$gdb_prompt $" {
d522 2
a523 1
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d526 1
a526 1
	-re "type = class vD : public virtual vB, public virtual vC \{${ws}private:${ws}vC ?\\* ?_vb.vC;${ws}vB ?\\* ?_vb.vB;${ws}public:${ws}int vd;${ws}int vx;${ws}vD ?& ?operator ?=\\(vD const ?&\\);${ws}vD\\(int, ?vD const ?&\\);${ws}vD\\(int\\);$nl\}$nl$gdb_prompt $" {
d533 1
a533 1
	-re "type = class vD : public virtual vB, public virtual vC \{${ws}public:${ws}int vd;${ws}int vx;${ws}vD ?& ?operator ?=\\(vD const ?&\\);${ws}vD\\(vD const ?&\\);${ws}vD\\((void|)\\);$nl\}$nl$gdb_prompt $" {
d535 5
a539 1
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d546 3
d550 1
a550 1
	-re "type = class vE : public virtual vD \{${ws}private:${ws}vD ?\\* ?_vb.2vD;${ws}public:${ws}int ve;${ws}int vx;$nl\}$nl$gdb_prompt $" {
d555 1
a555 1
	-re "type = class vE : public virtual vD \{${ws}public:${ws}int ve;${ws}int vx;$nl\}$nl$gdb_prompt $" {
d557 2
a558 1
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d561 1
a561 1
	-re "type = class vE : public virtual vD \{${ws}private:${ws}vD ?\\* ?_vb.vD;${ws}public:${ws}int ve;${ws}int vx;${ws}vE ?& ?operator ?=\\(vE const ?&\\);${ws}vE\\(int, ?vE const ?&\\);${ws}vE\\(int\\);$nl\}$nl$gdb_prompt $" {
d568 1
a568 1
	-re "type = class vE : public virtual vD \{${ws}public:${ws}int ve;${ws}int vx;${ws}vE ?& ?operator ?=\\(vE const ?&\\);${ws}vE\\(vE const ?&\\);${ws}vE\\((void|)\\);$nl\}$nl$gdb_prompt $" {
d570 5
a574 1
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d777 3
d781 1
a781 1
	-re "type = class ClassWithEnum \{${ws}public:${ws}(enum |)ClassWithEnum::PrivEnum priv_enum;${ws}int x;$nl\}$nl$gdb_prompt $" {
d784 1
a784 1
	-re "type = class ClassWithEnum \{${ws}public:${ws}(enum |)PrivEnum priv_enum;${ws}int x;$nl\}$nl$gdb_prompt $" {
d798 1
a798 1
	-re "type = class ClassWithEnum \{${ws}public:${ws}(enum |)PrivEnum priv_enum;${ws}int x;${ws}ClassWithEnum ?& ?operator ?=\\(ClassWithEnum const ?&\\);${ws}ClassWithEnum\\(ClassWithEnum const ?&\\);${ws}ClassWithEnum\\((void|)\\);$nl\}$nl$gdb_prompt $" {
d802 1
a802 1
	-re "type = class ClassWithEnum \{${ws}public:${ws}(enum |)ClassWithEnum::PrivEnum priv_enum;${ws}int x;${ws}ClassWithEnum ?& ?operator ?=\\(ClassWithEnum const ?&\\);${ws}ClassWithEnum\\(ClassWithEnum const ?&\\);${ws}ClassWithEnum\\((void|)\\);$nl\}$nl$gdb_prompt $" {
@


1.9
log
@2004-03-09  Michael Chastain  <mec.gnu@@mindspring.com>

	From Corinna Vinschen with modifications.
	* gdb.cp/classes.cc (enums1): Add a line to extend scope of
	local variable obj_with_enum.
	* gdb.cp/classes.exp (test_enums): Remove TODO note about FAIL
	results with obj_with_enum.
@
text
@d706 1
a706 1
    # See PR gdb/826.
d715 1
a715 1
	    kfail "gdb/826" "print (ClassWithEnum::PrivEnum) 42"
@


1.9.2.1
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@d706 1
a706 1
    # See PR gdb/1588.
d715 1
a715 1
	    kfail "gdb/1588" "print (ClassWithEnum::PrivEnum) 42"
@


1.8
log
@2004-03-09  Michael Chastain  <mec.gnu@@mindspring.com>

	* gdb.cp/classes.cc: New file, copied from misc.cc.
	* gdb.cp/classes.exp: Use classes.cc rather than misc.cc.
@
text
@a635 5
    # TODO: with gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2,
    # gdb says that obj_with_enum is out of scope here and the
    # tests after this FAIL.  This needs investigation.
    # -- chastain 2003-12-30

@


1.7
log
@2004-02-11  Michael Chastain  <mec.gnu@@mindspring.com>

	Partial fix for PR gdb/1543.
	* gdb.cp/ambiguous.exp, gdb.cp/annota2.exp, gdb.cp/annota3.exp,
	gdb.cp/anon-union.exp, gdb.cp/casts.exp, gdb.cp/classes.exp,
	gdb.cp/cplusfuncs.exp, gdb.cp/ctti.exp, gdb.exp/demangle.exp,
	gdb.cp/derivation.exp, gdb.cp/exception.exp, gdb.cp/hang.exp,
	gdb.cp/inherit.exp, gdb.cp/local.exp, gdb.cp/maint.exp,
	gdb.cp/member-ptr.exp, gdb.cp/method.exp, gdb.cp/misc.exp,
	gdb.cp/namespace.exp, gdb.cp/overload.exp, gdb.cp/ovldbreak.exp,
	gdb.cp/psmang.exp, gdb.cp/ref-types.exp, gdb.cp/templates.exp,
	gdb.cp/userdef.exp, gdb.cp/virtfunc.exp: Remove reference
	to bug-gdb@@prep.ai.mit.edu .
	* gdb.cp/bs15503.cc, gdb.cp/class2.cc, gdb.cp/cttiadd.cc,
	gdb.cp/cttiadd1.cc, gdb.cp/cttiadd2.cc, gdb.cp/cttiadd3.cc,
	gdb.cp/exception.cc, gdb.cp/member-ptr.cc, gdb.cp/namespace1.cc:
	Likewise.
@
text
@d30 1
a30 1
set testfile "misc"
@


1.7.4.1
log
@Merge mainline to intercu branch.
@
text
@d30 1
a30 1
set testfile "classes"
d636 5
d711 1
a711 1
    # See PR gdb/1588.
d720 1
a720 1
	    kfail "gdb/1588" "print (ClassWithEnum::PrivEnum) 42"
@


1.7.4.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d21 1
a29 2
load_lib "cp-support.exp"

d39 21
d62 3
d68 80
a147 48
    cp_test_ptype_class \
	"ptype struct default_public_struct" "" "struct" "default_public_struct" \
	{
	    { field public "int a;" }
	    { field public "int b;" }
	}

    # Another simple type.

    cp_test_ptype_class \
	"ptype struct explicit_public_struct" "" "struct" "explicit_public_struct" \
	{
	    { field public "int a;" }
	    { field public "int b;" }
	}

    # Another simple type.

    cp_test_ptype_class \
	"ptype struct protected_struct" "" "struct" "protected_struct" \
	{
	    { field protected "int a;" }
	    { field protected "int b;" }
	}

    # Another simple type.

    cp_test_ptype_class \
	"ptype struct private_struct" "" "struct" "private_struct" \
	{
	    { field private "int a;" }
	    { field private "int b;" }
	}

    # A bigger type.

    cp_test_ptype_class \
	"ptype struct mixed_protection_struct" "" "struct" "mixed_protection_struct" \
	{
	    { field public    "int a;" }
	    { field public    "int b;" }
	    { field private   "int c;" }
	    { field private   "int d;" }
	    { field protected "int e;" }
	    { field protected "int f;" }
	    { field public    "int g;" }
	    { field private   "int h;" }
	    { field protected "int i;" }
d149 1
d154 12
a165 5
    cp_test_ptype_class \
	"ptype class public_class" "" "class" "public_class" \
	{
	    { field public "int a;" }
	    { field public "int b;" }
d167 1
d169 1
a169 1
    # Another simple type.
d171 12
a182 5
    cp_test_ptype_class \
	"ptype class protected_class" "" "class" "protected_class" \
	{
	    { field protected "int a;" }
	    { field protected "int b;" }
d184 1
d186 2
a187 1
    # Another simple type.
d189 12
a200 5
    cp_test_ptype_class \
	"ptype class default_private_class" "" "class" "default_private_class" \
	{
	    { field private "int a;" }
	    { field private "int b;" }
d202 1
d204 1
a204 1
    # Another simple type.
d206 12
a217 5
    cp_test_ptype_class \
	"ptype class explicit_private_class" "" "class" "explicit_private_class" \
	{
	    { field private "int a;" }
	    { field private "int b;" }
d219 1
d221 1
a221 1
    # A bigger type.
d223 12
a234 13
    cp_test_ptype_class \
	"ptype class mixed_protection_class" "" "class" "mixed_protection_class" \
	{

	    { field public    "int a;" }
	    { field public    "int b;" }
	    { field private   "int c;" }
	    { field private   "int d;" }
	    { field protected "int e;" }
	    { field protected "int f;" }
	    { field public    "int g;" }
	    { field private   "int h;" }
	    { field protected "int i;" }
d236 1
d242 12
a253 5
    cp_test_ptype_class \
	"ptype class A" "" "class" "A" \
	{
	    { field public "int a;" }
	    { field public "int x;" }
d255 1
d259 12
a270 6
    cp_test_ptype_class \
	"ptype class B" "" "class" "B" \
	{
	    { base         "public A" }
	    { field public "int b;" }
	    { field public "int x;" }
d272 1
d276 12
a287 6
    cp_test_ptype_class \
	"ptype class C" "" "class" "C" \
	{
	    { base         "public A" }
	    { field public "int c;" }
	    { field public "int x;" }
d289 1
d293 12
a304 7
    cp_test_ptype_class \
	"ptype class D" "" "class" "D" \
	{
	    { base         "public B" }
	    { base         "public C" }
	    { field public "int d;" }
	    { field public "int x;" }
d306 1
d310 12
a321 6
    cp_test_ptype_class \
	"ptype class E" "" "class" "E" \
	{
	    { base         "public D" }
	    { field public "int e;" }
	    { field public "int x;" }
d323 1
d330 15
a344 4
    cp_test_ptype_class \
	"ptype class Static" "" "class" "Static" \
	{
	    { method public "static void ii(int, int);" }
d346 1
d350 99
a448 1
    # A virtual base class.
d450 17
a466 51
    cp_test_ptype_class \
	"ptype class vA" "" "class" "vA" \
	{
	    { field public "int va;" }
	    { field public "int vx;" }
	}

    # A derived class with a virtual base.

    cp_test_ptype_class \
	"ptype class vB" "" "class" "vB" \
	{
	    { base         "public virtual vA" }
	    { vbase        "vA" }
	    { field public "int vb;" }
	    { field public "int vx;" }
	}

    # Another derived class with a virtual base.

    cp_test_ptype_class \
	"ptype class vC" "" "class" "vC" \
	{
	    { base         "public virtual vA" }
	    { vbase        "vA" }
	    { field public "int vc;" }
	    { field public "int vx;" }
	}

    # A classic diamond class.

    cp_test_ptype_class \
	"ptype class vD" "" "class" "vD" \
	{
	    { base         "public virtual vB" }
	    { base         "public virtual vC" }
	    { vbase        "vC" }
	    { vbase        "vB" }
	    { field public "int vd;" }
	    { field public "int vx;" }
	}

    # A class derived from a diamond class.

    cp_test_ptype_class \
	"ptype class vE" "" "class" "vE" \
	{
	    { base         "public virtual vD" }
	    { vbase        "vD" }
	    { field public "int ve;" }
	    { field public "int vx;" }
d468 6
d477 19
a495 1
    # A base class.
d497 20
a516 32
    cp_test_ptype_class \
	"ptype class Base1" "" "class" "Base1" \
	{
	    { field  public "int x;" }
	    { method public "Base1(int);" }
	}

    # Another base class.

    cp_test_ptype_class \
	"ptype class Foo" "" "class" "Foo" \
	{
	    { field public "int x;" }
	    { field public "int y;" }
	    { field public "static int st;" }
	    { method public "Foo(int, int);" }
	    { method public "int operator!();" }
	    { method public "operator int();" }
	    { method public "int times(int);" }
	} \
	"" \
	{
	    {
		"operator int();"
		"int operator int();"
		{ setup_kfail "gdb/1497" "*-*-*" }
	    }
	    {
		"operator int();"
		"int operator int(void);"
		{ setup_kfail "gdb/1497" "*-*-*" }
	    }
d518 1
d522 15
a536 7
    cp_test_ptype_class \
	"ptype class Bar" "" "class" "Bar" \
	{
	    { base          "public Base1" }
	    { base          "public Foo" }
	    { field  public "int z;" }
	    { method public "Bar(int, int, int);" }
d538 1
a538 1

d542 2
d546 1
d549 2
a550 2
    gdb_test "print g_A.a" ".* = 1"
    gdb_test "print g_A.x" ".* = 2"
d553 2
a554 2
    gdb_test "print g_B.b" ".* = 5"
    gdb_test "print g_B.x" ".* = 6"
d557 2
a558 2
    gdb_test "print g_C.c" ".* = 9"
    gdb_test "print g_C.x" ".* = 10"
d561 2
a562 2
    gdb_test "print g_D.d" ".* = 19"
    gdb_test "print g_D.x" ".* = 20"
d565 2
a566 2
    gdb_test "print g_E.e" ".* = 31"
    gdb_test "print g_E.x" ".* = 32"
d572 1
d575 8
a582 6
    gdb_test "print g_A.b" "There is no member( or method|) named b."
    gdb_test "print g_B.c" "There is no member( or method|) named c."
    gdb_test "print g_B.d" "There is no member( or method|) named d."
    gdb_test "print g_C.b" "There is no member( or method|) named b."
    gdb_test "print g_C.d" "There is no member( or method|) named d."
    gdb_test "print g_D.e" "There is no member( or method|) named e."
d586 1
d589 6
a594 4
    gdb_test "print g_A.y" "There is no member( or method|) named y."
    gdb_test "print g_B.z" "There is no member( or method|) named z."
    gdb_test "print g_C.q" "There is no member( or method|) named q."
    gdb_test "print g_D.p" "There is no member( or method|) named p."
d601 12
a612 12
    gdb_test "call class_param.Aptr_a (&g_A)" ".* = 1"
    gdb_test "call class_param.Aptr_x (&g_A)" ".* = 2"
    gdb_test "call class_param.Aptr_a (&g_B)" ".* = 3"
    gdb_test "call class_param.Aptr_x (&g_B)" ".* = 4"
    gdb_test "call class_param.Aref_a (g_A)" ".* = 1"
    gdb_test "call class_param.Aref_x (g_A)" ".* = 2"
    gdb_test "call class_param.Aref_a (g_B)" ".* = 3"
    gdb_test "call class_param.Aref_x (g_B)" ".* = 4"
    gdb_test "call class_param.Aval_a (g_A)" ".* = 1"
    gdb_test "call class_param.Aval_x (g_A)" ".* = 2"
    gdb_test "call class_param.Aval_a (g_B)" ".* = 3"
    gdb_test "call class_param.Aval_x (g_B)" ".* = 4"
d624 1
d673 29
a701 23

    # NOTE: carlton/2003-02-28: One could certainly argue that plain
    # "PrivEnum"
    # is acceptable: PrivEnum is a member of ClassWithEnum, so
    # there's no need to explicitly qualify its name with
    # "ClassWithEnum::".  The truth, though, is that GDB is simply
    # forgetting that PrivEnum is a member of ClassWithEnum, so we do
    # that output for a bad reason instead of a good reason.  Under
    # stabs, we probably can't get this right; under DWARF-2, we can.

    cp_test_ptype_class \
	"ptype obj_with_enum" "" "class" "ClassWithEnum" \
	{
	    { field public "ClassWithEnum::PrivEnum priv_enum;" }
	    { field public "int x;" }
	} \
	"" \
	{
	    {
		"ClassWithEnum::PrivEnum priv_enum;"
		"PrivEnum priv_enum;"
		{ setup_kfail "gdb/57" "*-*-*" }
	    }
d703 1
d738 2
d756 1
d863 5
@


1.7.6.1
log
@2004-03-09  Michael Chastain  <mec.gnu@@mindspring.com>

	From Corinna Vinschen with modifications.
	* gdb.cp/classes.cc (enums1): Add a line to extend scope of
	local variable obj_with_enum.
	* gdb.cp/classes.exp (test_enums): Remove TODO note about FAIL
	results with obj_with_enum.

2004-03-09  Michael Chastain  <mec.gnu@@mindspring.com>

	* gdb.cp/classes.cc: New file, copied from misc.cc.
	* gdb.cp/classes.exp: Use classes.cc rather than misc.cc.

2004-03-09  Michael Chastain  <mec.gnu@@mindspring.com>

	* gdb.cp/misc.cc: Add copyright notice.
@
text
@d30 1
a30 1
set testfile "classes"
d635 5
@


1.6
log
@2004-01-10  Michael Chastain  <mec.gnu@@mindspring.com>

	* gdb.cp/classes.exp: Remove old "(obsolescent gcc or gdb)"
	decorations.
@
text
@a17 3
# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@@prep.ai.mit.edu

@


1.5
log
@2004-01-08  Michael Chastain  <mec.gnu@@mindspring.com>

	* gdb.cp/classes.exp: Accept gnu abi 2.
	* gdb.cp/derivation.exp: Likewise.
	* gdb.cp/overload.exp: Likewise.
	* gdb.cp/virtfunc.exp: Likewise.
@
text
@d267 1
a267 2
	    # TODO: this is not obsolescent!
	    pass "ptype class B (obsolescent gcc or gdb)"
d284 1
a284 2
	    # TODO: this is not obsolescent!
	    pass "ptype class C (obsolescent gcc or gdb)"
d301 1
a301 2
	    # TODO: this is not obsolescent!
	    pass "ptype class D (obsolescent gcc or gdb)"
a509 1
	    # TODO: this is not obsolescent!
d511 1
a511 1
	    pass "ptype class Foo (obsolescent gcc or gdb)"
d530 1
a530 2
	    # TODO: this is not obsolescent!
	    pass "ptype class Bar (obsolescent gcc or gdb)"
@


1.4
log
@2004-01-01  Michael Chastain  <mec.gnu@@mindspring.com>

	* gdb.cp/classes.exp: Generate identical results as old version.
	* gdb.cp/derivation.exp: Likewise.
	* gdb.cp/overload.exp: Likewise.
	* gdb.cp/virtfunc.exp: Likewise.
@
text
@d350 1
a350 2
	    # TODO: this is okay.  It is just ABI 2.
	    fail "ptype class Static"
d497 1
a497 2
	    # TODO: this is not obsolescent!
	    pass "ptype class Base1 (obsolescent gcc or gdb)"
d523 1
a523 2
	    # TODO: this is okay, just the new ABI
	    fail "ptype class Foo"
d544 1
a544 2
	    # TODO: this is not obsolescent!
	    pass "ptype class Bar (obsolescent gcc or gdb)"
@


1.3
log
@2003-12-31  Michael Chastain  <mec.gnu@@mindspring.com>

	* gdb.cp/classes.exp: Rewrite.  Clean up patterns to match
	current versions of gcc, including gcc abi 2.  Use "breakpoint"
	and "continue" instead of restarting the target program several
	times.  Use gdb_test_multiple and gdb_test for all tests.
@
text
@d2 1
a2 1
# 2003 Free Software Foundation, Inc.
d267 2
a268 1
	    pass "ptype class B"
d285 2
a286 1
	    pass "ptype class C"
d303 2
a304 1
	    pass "ptype class D"
d350 2
a351 1
	    pass "ptype class Static"
d372 1
a372 2
    # Accept the virtual base pointer if gdb wants to print it.
    # Those cases will go away when gcc 2 dies.
d374 1
d379 2
a380 1
	    pass "ptype class vB"
d390 3
a392 1
	    pass "ptype class vB"
d406 2
a407 1
	    pass "ptype class vC"
d417 3
a419 1
	    pass "ptype class vC"
d433 2
a434 1
	    pass "ptype class vD"
d444 3
a446 1
	    pass "ptype class vD"
d460 2
a461 1
	    pass "ptype class vE"
d471 3
a473 1
	    pass "ptype class vE"
d498 2
a499 1
	    pass "ptype class Base1"
d514 4
a517 2
	    # "int operator int()" is a bug
	    kfail "gdb/1497" "ptype class Foo"
d525 2
a526 1
	    pass "ptype class Foo"
d537 2
a538 1
	    pass "ptype class Bar"
d547 2
a548 1
	    pass "ptype class Bar"
d718 1
a718 1
	    pass "ptype obj_with_enum"
d761 7
d777 1
a777 1
    gdb_test "set foo.st = 200" ""
a827 3
    test_pointers_to_class_members
    test_static_members

d838 1
a838 1
    gdb_test "continue" ".*Breakpoint .* enums2.*" ""
d842 4
d880 5
@


1.2
log
@2003-09-07  Michael Chastain  <mec@@shout.net>

	* gdb.cp/classes.exp: Accommodate both 'syntax error' and
	'parse error'.
@
text
@d22 1
d28 1
a28 1
	strace $tracelevel
a36 7
# Create and source the file that provides information about the compiler
# used to compile the test case.

if [get_compiler_info ${binfile} "c++"] {
    return -1
}

d41 6
d48 12
a59 1
# Test ptype of class objects.
d61 2
d69 7
a75 8
    # Note that struct members are public by default, so we don't print
    # "public:" for the public members of structs.
    # Accept it if gdb just fails to distinguish between
    # class and struct, and everything else is OK.

    send_gdb "ptype struct default_public_struct\n"
    gdb_expect {
	-re "type = struct default_public_struct \{${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
d78 4
a81 1
	-re "type = class default_public_struct \{$nl.*int a;${ws}int b;$nl.*\}$nl$gdb_prompt $" {
a83 2
	-re ".*$gdb_prompt $" { fail "ptype struct default_public_struct" }
	timeout { fail "ptype struct default_public_struct (timeout)" ; return }
d86 7
a92 8
    # Note that struct members are public by default, so we don't print
    # "public:" for the public members of structs.
    # Accept it if gdb just fails to distinguish between
    # class and struct, and everything else is OK.

    send_gdb "ptype struct explicit_public_struct\n"
    gdb_expect {
	-re "type = struct explicit_public_struct \{${ws}int a;${ws}int b;$nl.*\}$nl$gdb_prompt $" {
d95 4
a98 1
	-re "type = class explicit_public_struct \{$nl.*int a;${ws}int b;$nl.*\}$nl$gdb_prompt $" {
a100 2
	-re ".*$gdb_prompt $" { fail "ptype struct explicit_public_struct" }
	timeout { fail "ptype struct explicit_public_struct (timeout)" ; return }
d103 1
a103 2
    # Accept it if gdb just fails to distinguish between
    # class and struct, and everything else is OK.
d105 5
a109 3
    send_gdb "ptype struct protected_struct\n"
    gdb_expect {
	-re "type = struct protected_struct \{${ws}protected:${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
d112 4
a115 1
	-re "type = class protected_struct \{${ws}protected:${ws}int a;${ws}int b;$nl.*\}$nl$gdb_prompt $" {
a117 2
	-re ".*$gdb_prompt $" { fail "ptype struct protected_struct" }
	timeout { fail "ptype struct protected_struct (timeout)" ; return }
d120 1
a120 2
    # Accept it if gdb just fails to distinguish between
    # class and struct, and everything else is OK.
d122 5
a126 3
    send_gdb "ptype struct private_struct\n"
    gdb_expect {
	-re "type = struct private_struct \{${ws}private:${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
d129 4
a132 1
	-re "type = class private_struct \{${ws}private:${ws}int a;${ws}int b;$nl.*\}$nl$gdb_prompt $" { 
a134 2
	-re ".*$gdb_prompt $" { fail "ptype struct private_struct" }
	timeout { fail "ptype struct private_struct (timeout)" ; return }
d137 1
a137 2
    # Accept it if gdb just fails to distinguish between
    # class and struct, and everything else is OK.
d139 5
a143 3
    send_gdb "ptype struct mixed_protection_struct\n"
    gdb_expect {
	-re "type = struct mixed_protection_struct \{${ws}int a;${ws}int b;${ws}private:${ws}int c;${ws}int d;${ws}protected:${ws}int e;${ws}int f;${ws}public:${ws}int g;${ws}private:${ws}int h;${ws}protected:${ws}int i;$nl\}$nl$gdb_prompt $" {
d146 4
a149 4
        -re "type = struct mixed_protection_struct \{${ws}public:${ws}int a;${ws}int b;${ws}private:${ws}int c;${ws}int d;${ws}protected:${ws}int e;${ws}int f;${ws}public:${ws}int g;${ws}private:${ws}int h;${ws}protected:${ws}int i;$nl.*\}$nl$gdb_prompt $" {
            pass "ptype struct mixed_protection_struct (extra public)"
        }
	-re "type = class mixed_protection_struct \{${ws}public:${ws}int a;${ws}int b;${ws}private:${ws}int c;${ws}int d;${ws}protected:${ws}int e;${ws}int f;${ws}public:${ws}int g;${ws}private:${ws}int h;${ws}protected:${ws}int i;$nl.*\}$nl$gdb_prompt $" {
a151 2
	-re ".*$gdb_prompt $" { fail "ptype struct mixed_protection_struct" }
	timeout { fail "ptype struct mixed_protection_struct (timeout)" ; return }
d154 2
a155 2
    # Accept it if gdb just fails to distinguish between
    # class and struct, and everything else is OK.
d157 5
a161 3
    send_gdb "ptype class public_class\n"
    gdb_expect {
	-re "type = class public_class \{${ws}public:${ws}int a;${ws}int b;$nl.*\}$nl$gdb_prompt $" {
d164 4
a167 1
	-re "type = struct public_class \{${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
a169 2
	-re ".*$gdb_prompt $" { fail "ptype class public_class" }
	timeout { fail "ptype class public_class (timeout)" ; return }
d172 7
a178 3
    send_gdb "ptype class protected_class\n"
    gdb_expect {
	-re "type = class protected_class \{${ws}protected:${ws}int a;${ws}int b;$nl.*\}$nl$gdb_prompt $" {
d181 5
a185 2
	-re "type = struct protected_class \{${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    fail "ptype class protected_class"
a186 2
	-re ".*$gdb_prompt $" { fail "ptype class protected_class" }
	timeout { fail "ptype class protected_class (timeout)" ; return }
d189 2
a190 4
    # Accept it if gdb just emits a superflous "private:"
    # attribute, since classes default to private and for consistency with
    # structs (where we don't print the "public:" attribute) we don't print
    # the "private:" attribute.
d192 5
a196 3
    send_gdb "ptype class default_private_class\n"
    gdb_expect {
	-re "type = class default_private_class \{${ws}int a;${ws}int b;$nl.*\}$nl$gdb_prompt $" {
d199 4
a202 1
	-re "type = class default_private_class \{${ws}private:${ws}int a;${ws}int b;$nl.*\}$nl$gdb_prompt $" {
a204 2
	-re ".*$gdb_prompt $" { fail "ptype class default_private_class" }
	timeout { fail "ptype class default_private_class (timeout)" ; return }
d207 7
a213 3
    send_gdb "ptype class explicit_private_class\n"
    gdb_expect {
	-re "type = class explicit_private_class \{${ws}private:${ws}int a;${ws}int b;$nl.*\}$nl$gdb_prompt $" {
d216 5
a220 5
        -re "type = class explicit_private_class \{${ws}int a;${ws}int b;$nl.*\}$nl$gdb_prompt $" {
            pass "ptype class explicit_private_class"
        }
	-re "type = struct explicit_private_class \{${ws}int a;${ws}int b;$nl.*\}$nl$gdb_prompt $" {
	    fail "ptype class explicit_private_class"
a221 2
	-re ".*$gdb_prompt $" { fail "ptype class explicit_private_class" }
	timeout { fail "ptype class explicit_private_class (timeout)" ; return }
d224 7
a230 3
    send_gdb "ptype class mixed_protection_class\n"
    gdb_expect {
	-re "type = class mixed_protection_class \{${ws}public:${ws}int a;${ws}int b;${ws}private:${ws}int c;${ws}int d;${ws}protected:${ws}int e;${ws}int f;${ws}public:${ws}int g;${ws}private:${ws}int h;${ws}protected:${ws}int i;$nl.*\}$nl$gdb_prompt $" {
d233 5
a237 2
	-re "type = struct mixed_protection_class \{${ws}int a;${ws}int b;${ws}int c;${ws}int d;${ws}int e;${ws}int f;${ws}int g;${ws}int h;${ws}int i;$nl.*\}$nl$gdb_prompt $" {
	    fail "ptype class mixed_protection_class"
a238 2
	-re ".*$gdb_prompt $" { fail "ptype class mixed_protection_class" }
	timeout { fail "ptype class mixed_protection_class (timeout)" ; return }
d241 9
a249 5
    # This class does not use any C++-specific features, so it's fine for
    # it to print as "struct".
    send_gdb "ptype class A\n"
    gdb_expect {
	-re "type = (class|struct) A \{(${ws}public:|)${ws}int a;${ws}int x;((${ws}A & operator=\\(A const ?&\\);)|(${ws}A\\((A const|const A) ?&\\);)|(${ws}A\\((void|)\\);))*${ws}\}$nl$gdb_prompt $" {
d252 5
a256 6
	-re ".*$gdb_prompt $" {
	    fail "ptype class A"
	}
	timeout {
	    fail "ptype class A (timeout)"
	    return
d260 7
a266 3
    send_gdb "ptype class B\n"
    gdb_expect {
	-re "type = class B : public A \{${ws}public:${ws}int b;${ws}int x;${ws}B & operator=\\(B const ?&\\);${ws}B\\((B const|const B) ?&\\);${ws}B\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
d269 5
a273 9
	-re "type = class B : public A \{${ws}public:${ws}int b;${ws}int x;((${ws}B & operator=\\(B const ?&\\);)|(${ws}B\\(B const ?&\\);)|(${ws}B\\((void|)\\);))*${ws}\}$nl$gdb_prompt $" {
	    pass "ptype class B (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype class B"
	}
	timeout {
	    fail "ptype class B (timeout)"
	    return
d277 7
a283 3
    send_gdb "ptype class C\n"
    gdb_expect {
	-re "type = class C : public A \{${ws}public:${ws}int c;${ws}int x;${ws}C & operator=\\(C const ?&\\);${ws}C\\((C const|const C) ?&\\);${ws}C\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
d286 5
a290 9
	-re "type = class C : public A \{${ws}public:${ws}int c;${ws}int x;((${ws}C & operator=\\(C const ?&\\);)|(${ws}C\\(C const ?&\\);)|(${ws}C\\((void|)\\);))*${ws}\}$nl$gdb_prompt $" {
	    pass "ptype class C (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype class C"
	}
	timeout {
	    fail "ptype class C (timeout)"
	    return
d294 7
a300 3
    send_gdb "ptype class D\n"
    gdb_expect {
	-re "type = class D : public B, public C \{${ws}public:${ws}int d;${ws}int x;${ws}D & operator=\\(D const ?&\\);${ws}D\\((D const|const D) ?&\\);${ws}D\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
d303 5
a307 9
	-re "type = class D : public B, public C \{${ws}public:${ws}int d;${ws}int x;((${ws}D & operator=\\(D const ?&\\);)|(${ws}D\\(D const ?&\\);)|(${ws}D\\((void|)\\);))*${ws}\}$nl$gdb_prompt $" {
	    pass "ptype class D (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype class D"
	}
	timeout {
	    fail "ptype class D (timeout)"
	    return
d311 7
a317 3
    send_gdb "ptype class E\n"
    gdb_expect {
	-re "type = class E : public D \{${ws}public:${ws}int e;${ws}int x;${ws}E & operator=\\(E const ?&\\);${ws}E\\((E const|const E) ?&\\);${ws}E\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
d320 4
a323 1
	-re "type = class E : public D \{${ws}public:${ws}int e;${ws}int x;((${ws}E & operator=\\(E const ?&\\);)|(${ws}E\\((E const|const E) ?&\\);)|(${ws}E\\((void|)\\);))*${ws}\}$nl$gdb_prompt $" {
a325 7
	-re ".*$gdb_prompt $" {
	    fail "ptype class E"
	}
	timeout {
	    fail "ptype class E (timeout)"
	    return
	}
d328 10
a337 5
    # With g++ 2.x and stabs debug info, we misinterpret static methods
    # whose name matches their argument mangling.
    send_gdb "ptype class Static\n"
    gdb_expect {
	-re "type = (class|struct) Static \{(${ws}public:|)${ws}Static & operator=\\(Static const ?&\\);${ws}Static\\((Static const|const Static) ?&\\);${ws}Static\\((void|)\\);${ws}static void ii\\(int, int\\);${ws}\}$nl$gdb_prompt $" {
d340 3
a342 1
	-re "type = (class|struct) Static \{(${ws}public:|)${ws}static void ii\\(int, int\\);${ws}\}$nl$gdb_prompt $" {
d345 3
a347 6
	-re ".*$gdb_prompt $" {
	    fail "ptype class Static"
	}
	timeout {
	    fail "ptype class Static (timeout)"
	    return
d351 7
a357 3
    send_gdb "ptype class vA\n"
    gdb_expect {
	-re "type = (class|struct) vA \{(${ws}public:|)${ws}int va;${ws}int vx;${ws}\}$nl$gdb_prompt $" {
d360 4
a363 1
	-re "type = (class|struct) vA \{(${ws}public:|)${ws}int va;${ws}int vx;${ws}vA & operator=\\(vA const ?&\\);${ws}vA\\((vA const|const vA) ?&\\);${ws}vA\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
a365 10
	-re "type = (class|struct) vA \{(${ws}public:|)${ws}int va;${ws}int vx;((${ws}vA & operator=\\(vA const ?&\\);)|(${ws}vA\\(vA const ?&\\);)|(${ws}vA\\((void|)\\);))*${ws}\}$nl$gdb_prompt $" {
	    pass "ptype class vA (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype class vA"
	}
	timeout {
	    fail "ptype class vA (timeout)"
	    return
	}
d368 7
a374 10
    # Accept the form with embedded GNU style mangled virtual table constructs
    # for now, but with a FIXME.  At some future point, gdb should use a
    # portable representation for the virtual table constructs.

    # The format of a g++ virtual base pointer.
    set vbptr "(_vb\[$.\]|__vb_)\[0-9\]?"

    send_gdb "ptype class vB\n"
    gdb_expect {
	-re "type = class vB : public virtual vA \{${ws}public:${ws}int vb;${ws}int vx;${ws}vB & operator=\\(vB const ?&\\);${ws}vB\\((vB const|const vB) ?&\\);${ws}vB\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
d377 4
a380 3
	-re "type = class vB : public virtual vA \{${ws}private:${ws}vA \\*${vbptr}vA;${ws}public:${ws}int vb;${ws}int vx;${ws}vB & operator=\\(vB const ?&\\);${ws}vB\\(int, vB const ?&\\);${ws}vB\\(int\\);${ws}\}$nl$gdb_prompt $" {
	    setup_xfail "*-*-*"
	    fail "ptype class vB (FIXME: non-portable virtual table constructs)"
d382 4
a385 6
        -re "type = class vB : public virtual vA \{${ws}public:${ws}int vb;${ws}int vx;${ws}\}$nl$gdb_prompt $" {
            pass "ptype class vB"
        }
	-re "type = class vB : public virtual vA \{${ws}private:${ws}vA \\*_vb.vA;${ws}public:${ws}int vb;${ws}int vx;((${ws}vB & operator=\\(vB const ?&\\);)|(${ws}vB\\(int, vB const ?&\\);)|(${ws}vB\\(int\\);))*${ws}\}$nl$gdb_prompt $" {
	    setup_xfail "*-*-*"
	    fail "ptype class vB (FIXME) (obsolescent gcc or gdb)"
d387 4
a390 6
	-re ".*$gdb_prompt $" {
	    fail "ptype class vB"
	}
	timeout {
	    fail "ptype class vB (timeout)"
	    return
d394 1
a394 3
    # Accept the form with embedded GNU style mangled virtual table constructs
    # for now, but with a FIXME.  At some future point, gdb should use a
    # portable representation for the virtual table constructs.
d396 3
a398 3
    send_gdb "ptype class vC\n"
    gdb_expect {
	-re "type = class vC : public virtual vA \{${ws}public:${ws}int vc;${ws}int vx;${ws}vC & operator=\\(vC const ?&\\);${ws}vC\\((vC const|const vC) ?&\\);${ws}vC\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
d401 4
a404 3
	-re "type = class vC : public virtual vA \{${ws}private:${ws}vA \\*${vbptr}vA;${ws}public:${ws}int vc;${ws}int vx;${ws}vC & operator=\\(vC const ?&\\);${ws}vC\\(int, vC const ?&\\);${ws}vC\\(int\\);${ws}\}$nl$gdb_prompt $" {
	    setup_xfail "*-*-*"
	    fail "ptype class vC (FIXME: non-portable virtual table constructs)"
d406 4
a409 6
        -re "type = class vC : public virtual vA \{${ws}public:${ws}int vc;${ws}int vx;${ws}\}$nl$gdb_prompt $" {
            pass "ptype class vC"
        }
	-re "type = class vC : public virtual vA \{${ws}private:${ws}vA \\*_vb.vA;${ws}public:${ws}int vc;${ws}int vx;((${ws}vC & operator=\\(vC const ?&\\);)|(${ws}vC\\(int, vC const ?&\\);)|(${ws}vC\\(int\\);))*${ws}\}$nl$gdb_prompt $" {
	    setup_xfail "*-*-*"
	    fail "ptype class vC (FIXME) (obsolescent gcc or gdb)"
d411 4
a414 6
	-re ".*$gdb_prompt $" {
	    fail "ptype class vC"
	}
	timeout {
	    fail "ptype class vC (timeout)"
	    return
d418 1
a418 3
    # Accept the form with embedded GNU style mangled virtual table constructs
    # for now, but with a FIXME.  At some future point, gdb should use a
    # portable representation for the virtual table constructs.
d420 3
a422 3
    send_gdb "ptype class vD\n"
    gdb_expect {
	-re "type = class vD : public virtual vB, public virtual vC \{${ws}public:${ws}int vd;${ws}int vx;${ws}vD & operator=\\(vD const ?&\\);${ws}vD\\((vD const|const vD) ?&\\);${ws}vD\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
d425 4
a428 3
	-re "type = class vD : public virtual vB, public virtual vC \{${ws}private:${ws}vC \\*${vbptr}vC;${ws}vB \\*${vbptr}vB;${ws}public:${ws}int vd;${ws}int vx;${ws}vD & operator=\\(vD const ?&\\);${ws}vD\\(int, vD const ?&\\);${ws}vD\\(int\\);${ws}\}$nl$gdb_prompt $" {
	    setup_xfail "*-*-*"
	    fail "ptype class vD (FIXME: non-portable virtual table constructs)"
d430 4
a433 6
        -re "type = class vD : public virtual vB, public virtual vC \{${ws}public:${ws}int vd;${ws}int vx;${ws}\}$nl$gdb_prompt $" {
            pass "ptype class vD"
        }
	-re "type = class vD : public virtual vB, public virtual vC \{${ws}private:${ws}vC \\*_vb.vC;${ws}vB \\*_vb.vB;${ws}public:${ws}int vd;${ws}int vx;((${ws}vD & operator=\\(vD const ?&\\);)|(${ws}vD\\(int, vD const ?&\\);)|(${ws}vD\\(int\\);))*${ws}\}$nl$gdb_prompt $" {
	    setup_xfail "*-*-*"
	    fail "ptype class vD (FIXME) (obsolescent gcc or gdb)"
d435 4
a438 6
	-re ".*$gdb_prompt $" {
	    fail "ptype class vD"
	}
	timeout {
	    fail "ptype class vD (timeout)"
	    return
d442 1
a442 3
    # Accept the form with embedded GNU style mangled virtual table constructs
    # for now, but with a FIXME.  At some future point, gdb should use a
    # portable representation for the virtual table constructs.
d444 3
a446 3
    send_gdb "ptype class vE\n"
    gdb_expect {
	-re "type = class vE : public virtual vD \{${ws}public:${ws}int ve;${ws}int vx;${ws}vE & operator=\\(vE const ?&\\);${ws}vE\\((vE const|const vE) ?&\\);${ws}vE\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
d449 4
a452 3
	-re "type = class vE : public virtual vD \{${ws}private:${ws}vD \\*${vbptr}vD;${ws}public:${ws}int ve;${ws}int vx;${ws}vE & operator=\\(vE const ?&\\);${ws}vE\\(int, vE const ?&\\);${ws}vE\\(int\\);${ws}\}$nl$gdb_prompt $" {
	    setup_xfail "*-*-*"
	    fail "ptype class vE (FIXME: non-portable virtual table constructs)"
d454 4
a457 6
        -re "type = class vE : public virtual vD \{${ws}public:${ws}int ve;${ws}int vx;${ws}\}$nl$gdb_prompt $" {
            pass "ptype class vE"
        }
	-re "type = class vE : public virtual vD \{${ws}private:${ws}vD \\*_vb.vD;${ws}public:${ws}int ve;${ws}int vx;((${ws}vE & operator=\\(vE const ?&\\);)|(${ws}vE\\(int, vE const ?&\\);)|(${ws}vE\\(int\\);))*${ws}\}$nl$gdb_prompt $" {
	    setup_xfail "*-*-*"
	    fail "ptype class vE (FIXME) (obsolescent gcc or gdb)"
d459 4
a462 6
	-re ".*$gdb_prompt $" {
	    fail "ptype class vE"
	}
	timeout {
	    fail "ptype class vE (timeout)"
	    return
d466 7
a472 3
    send_gdb "ptype class Base1\n"
    gdb_expect {
	-re "type = class Base1 \{${ws}public:${ws}int x;${ws}Base1 & operator=\\(Base1 const ?&\\);${ws}Base1\\(((Base1 const)|(const Base1)) ?&\\);${ws}Base1\\(int\\);${ws}\}$nl$gdb_prompt $" {
d475 3
a477 1
	-re "type = class Base1 \{${ws}public:${ws}int x;${ws}Base1\\(int\\);${ws}\}$nl$gdb_prompt $" {
d480 3
a482 9
	-re "type = class Base1 \{${ws}public:${ws}int x;((${ws}Base1 & operator=\\(Base1 const ?&\\);)|(${ws}Base1\\(Base1 const ?&\\);)|(${ws}Base1\\(int\\);))*${ws}\}$nl$gdb_prompt $" {
	    pass "ptype class Base1 (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype class Base1"
	}
	timeout {
	    fail "ptype class Base1 (timeout)"
	    return
d486 7
a492 6
    send_gdb "ptype class Foo\n"
    gdb_expect {
        -re "type = class Foo \{${ws}public:${ws}int x;${ws}int y;${ws}static int st;\r\n${ws}Foo\\(int, int\\);${ws}int operator!\\((void|)\\);${ws}operator int\\((void|)\\);${ws}int times\\(int\\);$nl\}$nl$gdb_prompt $" {
            pass "ptype class Foo"
        }
	-re "type = class Foo \{${ws}public:${ws}int x;${ws}int y;${ws}static int st;${ws}Foo & operator=\\(Foo const ?&\\);${ws}Foo\\((Foo const|const Foo) ?&\\);${ws}Foo\\(int, int\\);${ws}int operator!\\((void|)\\);${ws}operator int\\((void|)\\);${ws}int times\\(int\\);${ws}\}$nl$gdb_prompt $" {
d495 4
a498 2
	-re "type = class Foo \{${ws}public:${ws}int x;${ws}int y;${ws}static int st;((${ws}Foo & operator=\\(Foo const ?&\\);)|(${ws}Foo\\(Foo const ?&\\);)|(${ws}Foo\\(int, int\\);)|(${ws}int operator!\\((void|)\\);)|(${ws}int operator int\\((void|)\\);)|(${ws}int times\\(int\\);))*${ws}\}$nl$gdb_prompt $" {
	    pass "ptype class Foo (obsolescent gcc or gdb)"
d500 3
a502 2
	-re ".*$gdb_prompt $" {
	    fail "ptype class Foo"
d504 3
a506 3
	timeout {
	    fail "ptype class Foo (timeout)"
	    return
d510 7
a516 3
    send_gdb "ptype class Bar\n"
    gdb_expect {
	-re "type = class Bar : public Base1, public Foo \{${ws}public:${ws}int z;${ws}Bar & operator=\\(Bar const ?&\\);${ws}Bar\\((Bar const|const Bar) ?&\\);${ws}Bar\\(int, int, int\\);${ws}\}$nl$gdb_prompt $" {
d519 4
a522 2
	-re "type = class Bar : public Base1, public Foo \{${ws}public:${ws}int z;((${ws}Bar & operator=\\(Bar const ?&\\);)|(${ws}Bar\\(Bar const ?&\\);)|(${ws}Bar\\(int, int, int\\);))*${ws}\}$nl$gdb_prompt $" {
	    pass "ptype class Bar (obsolescent gcc or gdb)"
d524 3
a526 6
	-re ".*$gdb_prompt $" {
	    fail "ptype class Bar"
	}
	timeout {
	    fail "ptype class Bar (timeout)"
	    return
a530 1
#
d532 2
a533 1
#
a538 1

a539 1

a542 1

a543 1

a546 1

a547 1

a550 1

a551 1

a554 1

a555 1

d559 4
a562 4
#
# Try access to non-members that are members of another class.
# Should give errors.
#
a567 1

a568 1

a569 1

a570 1

a571 1

d575 2
a576 4
#
# Try access to non-members that are not members of any class.
# Should give errors.
#
a581 1

a582 1

a583 1

a586 1
#
a588 1
#
a608 1
#
a609 1
#
d613 2
a614 1
    global hp_aCC_compiler
a616 6
    send_gdb "print obj_with_enum\n"
    gdb_expect {
	-re "\\$\[0-9\]* = \\{priv_enum = red, x = 0\\}.*$gdb_prompt $" { pass "print obj_with_enum (1)" }
	-re "$gdb_prompt $"                     { fail "print obj_with_enum (1)" }
	timeout                             { fail "(timeout) print obj_with_enum (1)" }
    }
d618 12
a629 5
    send_gdb "next\n"
    gdb_expect {
	-re "$gdb_prompt $"                     { pass "next" }
	timeout                             { fail "(timeout) next" }
    }
a631 6
    send_gdb "print obj_with_enum\n"
    gdb_expect {
	-re "\\$\[0-9\]* = \\{priv_enum = green, x = 0\\}.*$gdb_prompt $" { pass "print obj_with_enum (2)" }
	-re "$gdb_prompt $"                     { fail "print obj_with_enum (2)" }
	timeout                             { fail "(timeout) print obj_with_enum (2)" }
    }
d633 7
a639 7
    # print out the enum member
    send_gdb "print obj_with_enum.priv_enum\n"
    gdb_expect {
	-re "\\$\[0-9\]* = green.*$gdb_prompt $" { pass "print obj_with_enum.priv_enum" }
	-re "$gdb_prompt $"                     { fail "print obj_with_enum.priv_enum" }
	timeout                             { fail "(timeout) print obj_with_enum.priv_enum" }
    }
d642 23
a664 9
    # The third success case is a little dubious, but it's not clear what
    # ought to be required of a ptype on a private enum... -sts 19990324
    send_gdb "ptype obj_with_enum.priv_enum\n"
    gdb_expect {
	-re "type = enum ClassWithEnum::PrivEnum \\{red, green, blue, yellow = 42\\}.*$gdb_prompt $" { pass "ptype obj_with_enum.priv_enum" }
	-re "type = enum PrivEnum \\{red, green, blue, yellow = 42\\}.*$gdb_prompt $" { pass "ptype obj_with_enum.priv_enum" }
	-re "type = enum \\{red, green, blue, yellow = 42\\}.*$gdb_prompt $" { pass "ptype obj_with_enum.priv_enum" }
	-re "$gdb_prompt $"                     { fail "ptype obj_with_enum.priv_enum" }
	timeout                             { fail "(timeout) ptype obj_with_enum.priv_enum" }
d668 5
a672 5
    send_gdb "ptype obj_with_enum\n"
    gdb_expect {
	-re "type = class ClassWithEnum \\{\r\n\[ \t\]*public:\r\n\[ \t\]*(enum |)ClassWithEnum::PrivEnum priv_enum;\r\n\[ \t\]*int x;\r\n\\}\r\n$gdb_prompt $" { pass "ptype obj_with_enum" }
	-re "type = class ClassWithEnum \\{\r\n\[ \t\]*public:\r\n\[ \t\]*(enum |)PrivEnum priv_enum;\r\n\[ \t\]*int x;.*\\}\r\n$gdb_prompt $"
	{
d681 7
d690 8
a697 2
	-re "$gdb_prompt $"                     { fail "ptype obj_with_enum" }
	timeout                             { fail "(timeout) ptype obj_with_enum" }
d700 10
a709 8
    # We'll do this test twice, because of a parser bug: see
    # PR gdb/826.

    send_gdb "print (ClassWithEnum::PrivEnum) 42\n"
    gdb_expect {
	-re "\\$\[0-9\]* = yellow.*$gdb_prompt $" { pass "print (ClassWithEnum::PrivEnum) 42" }
	-re "A parse error in expression, near `42'.\r\n$gdb_prompt $" {
	    # bison 1.35
a711 6
	-re "A syntax error in expression, near `42'.\r\n$gdb_prompt $" {
	    # bison 1.875
	    kfail "gdb/826" "print (ClassWithEnum::PrivEnum) 42"
	}
	-re "$gdb_prompt $"                     { fail "print (ClassWithEnum::PrivEnum) 42" }
	timeout                             { fail "(timeout) print (ClassWithEnum::PrivEnum) 42" }
d714 13
a726 7
    send_gdb "print ('ClassWithEnum::PrivEnum') 42\n"
    gdb_expect {
	-re "\\$\[0-9\]* = yellow.*$gdb_prompt $" { pass "print ('ClassWithEnum::PrivEnum') 42" }
	-re "No symbol \"ClassWithEnum::PrivEnum\" in current context.\r\n$gdb_prompt $"
	{ kfail "gdb/57" "print ('ClassWithEnum::PrivEnum') 42" }
	-re "$gdb_prompt $"                     { fail "print ('ClassWithEnum::PrivEnum') 42" }
	timeout                             { fail "(timeout) print ('ClassWithEnum::PrivEnum') 42" }
a729 1
#
a730 1
#
a733 6
    global decimal
    global nl

    gdb_test "print Bar::z" ".* = .int\[ \]*\[( \]*Bar::&\[)\]+\[ \]*Bar::z" "print Bar::z"

    gdb_test "print &Foo::x" ".* = .int\[ \]*\[( \]*Foo::\[*)\]+\[ \]*&Foo::x" "print &Foo::x"
d735 4
a738 24
    gdb_test "print (int)&Foo::x" ".* = 0" "print (int)&Foo::x"

    send_gdb "print (int)&Bar::y == 2*sizeof(int)\n"
    gdb_expect {
	-re ".* = true$nl$gdb_prompt $" {
	    pass "print (int)&Bar::y == 2*sizeof(int)"
	}
	-re "There is no field named y.*$gdb_prompt $" {
	    setup_xfail "*-*-*"
	    fail "print (int)&Bar::y == 2*sizeof(int)"
	}
	-re ".*$gdb_prompt $" { fail "print (int)&Bar::y == 2*sizeof(int)" }
	timeout { fail "print (int)&Bar::y == 2*sizeof(int) (timeout)" ; return }
    }

    send_gdb "next 2\n"
    setup_xfail "*-*-*"
    gdb_expect {
	-re "$decimal\[ \t\]+inheritance3 \[)(\]+;$nl$gdb_prompt $" {}
	-re ".*$gdb_prompt $" { fail "next to inheritance3" ; return }
    }
    clear_xfail "*-*-*"

    gdb_test "print (int)pmi == sizeof(int)" ".* = false" "print (int)pmi == sizeof(int)"
a740 1
#
a741 1
#
a745 45
    global nl

    send_gdb "print Foo::st\n"
    gdb_expect {
	-re ".* = 100$nl$gdb_prompt $" {
	    pass "print Foo::st"
	}
	-re "There is no field named st.*$gdb_prompt $" {
	    setup_xfail "*-*-*"
	    fail "print Foo::st"
	}
	-re ".*$gdb_prompt $" { fail "print Foo::st" }
       timeout { fail "print Foo::st (timeout)" ; return }
    }

    send_gdb "set foo.st = 200\n"
    gdb_expect {
	-re ".*$gdb_prompt $" {}
    }

    send_gdb "print bar.st\n"
    gdb_expect {
	-re ".* = 200$nl$gdb_prompt $" {
	    pass "print bar.st"
	}
	-re "There is no member( or method|) named st.*$gdb_prompt $" {
	    setup_xfail "*-*-*"
	    fail "print bar.st"
	}
	-re ".*$gdb_prompt $" { fail "print bar.st" }
       timeout { fail "print bar.st (timeout)" ; return }
    }

    send_gdb "print &foo.st\n"
    gdb_expect {
	-re ".* = .int \[*)\]+ $hex$nl$gdb_prompt $" {
	    pass "print &foo.st"
	}
	-re "There is no member( or method|) named st.*$gdb_prompt $" {
	    setup_xfail "*-*-*"
	    fail "print &foo.st"
	}
	-re ".*$gdb_prompt $" { fail "print &foo.st" }
       timeout { fail "print &foo.st (timeout)" ; return }
    }
d747 6
a752 18
    set got_bar_st 0
    send_gdb "print &Bar::st\n"
    gdb_expect {
	-re ".* = .int \[*)\]+ $hex$nl$gdb_prompt $" {
	    pass "print &Bar::st"
	    set got_bar_st 1
	}
	-re "There is no field named st.*$gdb_prompt $" {
	    setup_xfail "*-*-*"
	    fail "print &Bar::st"
	}
	-re ".*$gdb_prompt $" { fail "print &Bar::st" }
       timeout { fail "print &Bar::st (timeout)" ; return }
    }

    if $got_bar_st then {
	gdb_test "print *\$" ".* = 200" "print *\$"
    }
d779 1
d791 13
a803 4
    send_gdb "set language c++\n"
    gdb_expect -re "$gdb_prompt $"
    send_gdb "set width 0\n"
    gdb_expect -re "$gdb_prompt $"
a804 1
    runto_main
d806 4
a809 7

    if [ runto 'inheritance2' ] then {
	test_non_inherited_member_access
	test_wrong_class_members
	test_nonexistent_members
	test_method_param_class
    }
d812 36
a847 42
    if [ gdb_continue "enums2(\\(\\)|)" ]==0 then {
	gdb_test "finish" "" ""
	test_enums
    }

    if [istarget "mips-idt-*"] then {
	# Restart because IDT/SIM runs out of file descriptors.
	gdb_exit
	gdb_start
	gdb_reinitialize_dir $srcdir/$subdir
	gdb_load $binfile
    }

    if [ runto_main ] then {
	test_pointers_to_class_members
	test_static_members
    }

    if [istarget "mips-idt-*"] then {
	# Restart because IDT/SIM runs out of file descriptors.
	gdb_exit
	gdb_start
	gdb_reinitialize_dir $srcdir/$subdir
	gdb_load $binfile
    }

    if [ runto marker_reg1 ] then {

	gdb_test "finish" "Run till exit from.*" "finish from marker_reg1"

	send_gdb "print v.method ()\n"
	gdb_expect {
	    -re "= 82.*$gdb_prompt $" {
		pass "calling method for small class"
	    }
	    -re "Address requested for identifier .v. which is in register.*$gdb_prompt $" {
		setup_xfail "*-*-*" 2972
		fail "calling method for small class"
	    }
	    -re ".*$gdb_prompt $" { fail "calling method for small class" }
	    timeout { fail "calling method for small class (timeout)" }
	    eof { fail "calling method for small class (eof)" }
a849 1

a852 7

send_gdb "maint demangle inheritance1__Fv\n"
gdb_expect {
   -re "inheritance1\\(void\\).*$gdb_prompt $" { pass "demangle" }
   -re ".*$gdb_prompt $"   { fail "demangle" }
   timeout           { fail "(timeout) demangle" }
}
@


1.2.2.1
log
@merge mainline changes into branch
@
text
@d2 1
a2 1
# 2003, 2004 Free Software Foundation, Inc.
d18 3
a21 1
# And rewritten by Michael Chastain <mec.gnu@@mindspring.com>.
d27 1
a27 1
    strace $tracelevel
d32 1
a32 1
set testfile "classes"
d36 7
d47 1
a49 20
# This code accepts the output of gcc v2 and v3, dwarf-2 and stabs+.
# It could use some expansion with other compilers such as hp-ux ac++.
#
# There are lots of variations in the output:
#
# . gcc -stabs+ emits debug info for implicit member functions:
#   operator=, copy ctor, ctor.  gcc -gdwarf-2 does not.
#
# . gcc with abi version 1 puts the implicit member functions
#   at the beginning of the member function list; with abi version 2,
#   the implicit member functions are at the end of the member function
#   list.  This appears as an output difference with -gstabs+.
#   gcc 3.3.X defaults to abi version 1, and gcc 3.4 will default
#   to abi version 2.
#
# . gcc v2 shows data members for virtual base pointers.
#   gcc v3 does not.
#
# . gdb always prints "class" for both "class" and "struct".
#   In the future, I should accept "struct" in case gdb improves.
d56 8
a63 7
    # Simple type.

    gdb_test_multiple "ptype struct default_public_struct" "ptype struct default_public_struct" {
	-re "type = class default_public_struct \{${ws}public:${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d66 1
a66 4
	-re "type = class default_public_struct \{${ws}public:${ws}int a;${ws}int b;${ws}default_public_struct ?& ?operator ?=\\(default_public_struct const ?&\\);${ws}default_public_struct\\(default_public_struct const ?&\\);${ws}default_public_struct\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d69 2
d73 8
a80 7
    # Same test, slightly different type.

    gdb_test_multiple "ptype struct explicit_public_struct" "ptype struct explicit_public_struct" {
	-re "type = class explicit_public_struct \{${ws}public:${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d83 1
a83 4
	-re "type = class explicit_public_struct \{${ws}public:${ws}int a;${ws}int b;${ws}explicit_public_struct ?& ?operator ?=\\(explicit_public_struct const ?&\\);${ws}explicit_public_struct\\(explicit_public_struct const ?&\\);${ws}explicit_public_struct\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d86 2
d90 2
a91 1
    # Same test, slightly different type.
d93 3
a95 5
    gdb_test_multiple "ptype struct protected_struct" "ptype struct protected_struct" {
	-re "type = class protected_struct \{${ws}protected:${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d98 1
a98 4
	-re "type = class protected_struct \{${ws}protected:${ws}int a;${ws}int b;${ws}public:${ws}protected_struct ?& ?operator ?=\\(protected_struct const ?&\\);${ws}protected_struct\\(protected_struct const ?&\\);${ws}protected_struct\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d101 2
d105 2
a106 1
    # Same test, slightly different type.
d108 3
a110 5
    gdb_test_multiple "ptype struct private_struct" "ptype struct private_struct" {
	-re "type = class private_struct \{${ws}private:${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d113 1
a113 4
	-re "type = class private_struct \{${ws}private:${ws}int a;${ws}int b;${ws}public:${ws}private_struct ?& ?operator ?=\\(private_struct const ?&\\);${ws}private_struct\\(private_struct const ?&\\);${ws}private_struct\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d116 2
d120 2
a121 1
    # Similar test, bigger type.
d123 3
a125 5
    gdb_test_multiple "ptype struct mixed_protection_struct" "ptype struct mixed_protection_struct" {
	-re "type = class mixed_protection_struct \{${ws}public:${ws}int a;${ws}int b;${ws}private:${ws}int c;${ws}int d;${ws}protected:${ws}int e;${ws}int f;${ws}public:${ws}int g;${ws}private:${ws}int h;${ws}protected:${ws}int i;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d128 4
a131 4
	-re "type = class mixed_protection_struct \{${ws}public:${ws}int a;${ws}int b;${ws}private:${ws}int c;${ws}int d;${ws}protected:${ws}int e;${ws}int f;${ws}public:${ws}int g;${ws}private:${ws}int h;${ws}protected:${ws}int i;${ws}public:${ws}mixed_protection_struct ?& ?operator ?=\\(mixed_protection_struct const ?&\\);${ws}mixed_protection_struct\\(mixed_protection_struct const ?&\\);${ws}mixed_protection_struct\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d134 2
d138 2
a139 2
    # All that again with "class" instead of "struct".
    # gdb does not care about the difference anyways.
d141 3
a143 5
    gdb_test_multiple "ptype class public_class" "ptype class public_class" {
	-re "type = class public_class \{${ws}public:${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d146 1
a146 4
	-re "type = class public_class \{${ws}public:${ws}int a;${ws}int b;${ws}public_class ?& ?operator ?=\\(public_class const ?&\\);${ws}public_class\\(public_class const ?&\\);${ws}public_class\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d149 2
d153 3
a155 7
    # Same test, slightly different type.

    gdb_test_multiple "ptype class protected_class" "ptype class protected_class" {
	-re "type = class protected_class \{${ws}protected:${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d158 2
a159 5
	-re "type = class protected_class \{${ws}protected:${ws}int a;${ws}int b;${ws}public:${ws}protected_class ?& ?operator ?=\\(protected_class const ?&\\);${ws}protected_class\\(protected_class const ?&\\);${ws}protected_class\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class protected_class"
d161 2
d165 4
a168 2
    # Same test, slightly different type.
    # The 'private' is optional but gdb always prints it.
d170 3
a172 5
    gdb_test_multiple "ptype class default_private_class" "ptype class default_private_class" {
	-re "type = class default_private_class \{${ws}(private:${ws}|)int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d175 1
a175 4
	-re "type = class default_private_class \{${ws}(private:${ws}|)int a;${ws}int b;${ws}public:${ws}default_private_class ?& ?operator ?=\\(default_private_class const ?&\\);${ws}default_private_class\\(default_private_class const ?&\\);${ws}default_private_class\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d178 2
d182 3
a184 7
    # Same test, slightly different type.

    gdb_test_multiple "ptype class explicit_private_class" "ptype class explicit_private_class" {
	-re "type = class explicit_private_class \{${ws}(private:${ws}|)int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d187 5
a191 5
	-re "type = class explicit_private_class \{${ws}(private:${ws}|)int a;${ws}int b;${ws}public:${ws}explicit_private_class ?& ?operator ?=\\(explicit_private_class const ?&\\);${ws}explicit_private_class\\(explicit_private_class const ?&\\);${ws}explicit_private_class\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class explicit_private_class"
d193 2
d197 3
a199 7
    # Similar test, bigger type.

    gdb_test_multiple "ptype class mixed_protection_class" "ptype struct mixed_protection_class" {
	-re "type = class mixed_protection_class \{${ws}public:${ws}int a;${ws}int b;${ws}private:${ws}int c;${ws}int d;${ws}protected:${ws}int e;${ws}int f;${ws}public:${ws}int g;${ws}private:${ws}int h;${ws}protected:${ws}int i;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d202 2
a203 5
	-re "type = class mixed_protection_class \{${ws}public:${ws}int a;${ws}int b;${ws}private:${ws}int c;${ws}int d;${ws}protected:${ws}int e;${ws}int f;${ws}public:${ws}int g;${ws}private:${ws}int h;${ws}protected:${ws}int i;${ws}public:${ws}mixed_protection_class ?& ?operator ?=\\(mixed_protection_class const ?&\\);${ws}mixed_protection_class\\(mixed_protection_class const ?&\\);${ws}mixed_protection_class\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class mixed_protection_class"
d205 2
d209 5
a213 9
    # Here are some classes with inheritance.

    # Base class.

    gdb_test_multiple "ptype class A" "ptype class A" {
	-re "type = class A \{${ws}public:${ws}int a;${ws}int x;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d216 6
a221 5
	-re "type = class A \{${ws}public:${ws}int a;${ws}int x;${ws}A ?& ?operator ?=\\(A const ?&\\);${ws}A\\(A const ?&\\);${ws}A\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class A"
d225 3
a227 7
    # Derived class.

    gdb_test_multiple "ptype class B" "ptype class B" {
	-re "type = class B : public A \{${ws}public:${ws}int b;${ws}int x;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d230 9
a238 5
	-re "type = class B : public A \{${ws}public:${ws}int b;${ws}int x;${ws}B ?& ?operator ?=\\(B const ?&\\);${ws}B\\(B const ?&\\);${ws}B\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class B"
d242 3
a244 7
    # Derived class.

    gdb_test_multiple "ptype class C" "ptype class C" {
	-re "type = class C : public A \{${ws}public:${ws}int c;${ws}int x;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d247 9
a255 5
	-re "type = class C : public A \{${ws}public:${ws}int c;${ws}int x;${ws}C ?& ?operator ?=\\(C const ?&\\);${ws}C\\(C const ?&\\);${ws}C\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class C"
d259 3
a261 7
    # Derived class, multiple inheritance.

    gdb_test_multiple "ptype class D" "ptype class D" {
	-re "type = class D : public B, public C \{${ws}public:${ws}int d;${ws}int x;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d264 9
a272 5
	-re "type = class D : public B, public C \{${ws}public:${ws}int d;${ws}int x;${ws}D ?& ?operator ?=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class D"
d276 3
a278 7
    # Derived class.

    gdb_test_multiple "ptype class E" "ptype class E" {
	-re "type = class E : public D \{${ws}public:${ws}int e;${ws}int x;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d281 1
a281 4
	-re "type = class E : public D \{${ws}public:${ws}int e;${ws}int x;${ws}E ?& ?operator ?=\\(E const ?&\\);${ws}E\\(E const ?&\\);${ws}E\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d284 7
d293 5
a297 10
    # This is a break from inheritance tests.
    #
    # gcc 2.X with stabs (stabs or stabs+?) used to have a problem with
    # static methods whose name is the same as their argument mangling.
 
    gdb_test_multiple "ptype class Static" "ptype class Static" {
	-re "type = class Static \{${ws}public:${ws}static void ii\\(int, int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d300 1
a300 3
	-re "type = class Static \{${ws}public:${ws}Static ?& ?operator ?=\\(Static const ?&\\);${ws}Static\\(Static const ?&\\);${ws}Static\\((void|)\\);${ws}static void ii\\(int, int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
d303 6
a308 3
	-re "type = class Static \{${ws}public:${ws}static void ii\\(int, int\\);${ws}Static ?& ?operator ?=\\(Static const ?&\\);${ws}Static\\(Static const ?&\\);${ws}Static\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class Static"
d312 3
a314 7
    # Here are some virtual inheritance tests.

    gdb_test_multiple "ptype class vA" "ptype class vA" {
	-re "type = class vA \{${ws}public:${ws}int va;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d317 1
a317 4
	-re "type = class vA \{${ws}public:${ws}int va;${ws}int vx;${ws}vA ?& ?operator ?=\\(vA const ?&\\);${ws}vA\\(vA const ?&\\);${ws}vA\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d320 10
d332 10
a341 13
    # With gcc 2, gdb prints the virtual base pointer.
    # With gcc 3, gdb does not print the virtual base pointer.
    # drow considers it a gdb bug if gdb prints the vbptr.

    gdb_test_multiple "ptype class vB" "ptype class vB" {
	-re "type = class vB : public virtual vA \{${ws}private:${ws}vA ?\\* ?_vb.2vA;${ws}public:${ws}int vb;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # TODO: kfail this
	    fail "ptype class vB"
	}
	-re "type = class vB : public virtual vA \{${ws}public:${ws}int vb;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d344 1
a344 4
	-re "type = class vB : public virtual vA \{${ws}private:${ws}vA ?\\* ?_vb.vA;${ws}public:${ws}int vb;${ws}int vx;${ws}vB ?& ?operator ?=\\(vB const ?&\\);${ws}vB\\(int, ?vB const ?&\\);${ws}vB\\(int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # See the hidden "in-charge" ctor parameter!
	    # TODO: kfail this
d348 13
a360 4
	-re "type = class vB : public virtual vA \{${ws}public:${ws}int vb;${ws}int vx;${ws}vB ?& ?operator ?=\\(vB const ?&\\);${ws}vB\\(vB const ?&\\);${ws}vB\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class vB"
d364 3
a366 1
    # Another class with a virtual base.
d368 3
a370 9
    gdb_test_multiple "ptype class vC" "ptype class vC" {
	-re "type = class vC : public virtual vA \{${ws}private:${ws}vA ?\\* ?_vb.2vA;${ws}public:${ws}int vc;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # TODO: kfail
	    fail "ptype class vC"
	}
	-re "type = class vC : public virtual vA \{${ws}public:${ws}int vc;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d373 1
a373 4
	-re "type = class vC : public virtual vA \{${ws}private:${ws}vA ?\\* ?_vb.vA;${ws}public:${ws}int vc;${ws}int vx;${ws}vC ?& ?operator ?=\\(vC const ?&\\);${ws}vC\\(int, ?vC const ?&\\);${ws}vC\\(int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # See the hidden "in-charge" ctor parameter!
	    # TODO: kfail
d377 13
a389 4
	-re "type = class vC : public virtual vA \{${ws}public:${ws}int vc;${ws}int vx;${ws}vC ?& ?operator ?=\\(vC const ?&\\);${ws}vC\\(vC const ?&\\);${ws}vC\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class vC"
d393 3
a395 1
    # The classic diamond inheritance.
d397 3
a399 9
    gdb_test_multiple "ptype class vD" "ptype class vD" {
	-re "type = class vD : public virtual vB, public virtual vC \{${ws}private:${ws}vC ?\\* ?_vb.2vC;${ws}vB ?\\* ?_vb.2vB;${ws}public:${ws}int vd;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # TODO: kfail
	    fail "ptype class vD"
	}
	-re "type = class vD : public virtual vB, public virtual vC \{${ws}public:${ws}int vd;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d402 1
a402 4
	-re "type = class vD : public virtual vB, public virtual vC \{${ws}private:${ws}vC ?\\* ?_vb.vC;${ws}vB ?\\* ?_vb.vB;${ws}public:${ws}int vd;${ws}int vx;${ws}vD ?& ?operator ?=\\(vD const ?&\\);${ws}vD\\(int, ?vD const ?&\\);${ws}vD\\(int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # See the hidden "in-charge" ctor parameter!
	    # TODO: kfail
d406 13
a418 4
	-re "type = class vD : public virtual vB, public virtual vC \{${ws}public:${ws}int vd;${ws}int vx;${ws}vD ?& ?operator ?=\\(vD const ?&\\);${ws}vD\\(vD const ?&\\);${ws}vD\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class vD"
d422 3
a424 1
    # One more case of virtual derivation.
d426 3
a428 9
    gdb_test_multiple "ptype class vE" "ptype class vE" {
	-re "type = class vE : public virtual vD \{${ws}private:${ws}vD ?\\* ?_vb.2vD;${ws}public:${ws}int ve;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # TODO: kfail
	    fail "ptype class vE"
	}
	-re "type = class vE : public virtual vD \{${ws}public:${ws}int ve;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d431 1
a431 4
	-re "type = class vE : public virtual vD \{${ws}private:${ws}vD ?\\* ?_vb.vD;${ws}public:${ws}int ve;${ws}int vx;${ws}vE ?& ?operator ?=\\(vE const ?&\\);${ws}vE\\(int, ?vE const ?&\\);${ws}vE\\(int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # See the hidden "in-charge" ctor parameter!
	    # TODO: kfail
d435 13
a447 4
	-re "type = class vE : public virtual vD \{${ws}public:${ws}int ve;${ws}int vx;${ws}vE ?& ?operator ?=\\(vE const ?&\\);${ws}vE\\(vE const ?&\\);${ws}vE\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class vE"
d451 3
a453 7
    # Another inheritance series.

    gdb_test_multiple "ptype class Base1" "ptype class Base1" {
	-re "type = class Base1 \{${ws}public:${ws}int x;${ws}Base1\\(int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d456 1
a456 3
	-re "type = class Base1 \{${ws}public:${ws}int x;${ws}Base1 ?& ?operator ?=\\(Base1 const ?&\\);${ws}Base1\\(Base1 const ?&\\);${ws}Base1\\(int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
d459 9
a467 3
	-re "type = class Base1 \{${ws}public:${ws}int x;${ws}Base1\\(int\\);${ws}Base1 ?& ?operator ?=\\(Base1 const ?&\\);${ws}Base1\\(Base1 const ?&\\);$nl\}$nl$gdb_prompt $" {
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class Base1"
d471 6
a476 7
    # The second base class.

    gdb_test_multiple "ptype class Foo" "ptype class Foo" {
	-re "type = class Foo \{${ws}public:${ws}int x;${ws}int y;${ws}static int st;${ws}Foo\\(int, int\\);${ws}int operator ?!\\((void|)\\);${ws}operator int\\((void|)\\);${ws}int times\\(int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d479 2
a480 5
	-re "type = class Foo \{${ws}public:${ws}int x;${ws}int y;${ws}static int st;${ws}Foo ?& ?operator ?=\\(Foo const ?&\\);${ws}Foo\\(Foo const ?&\\);${ws}Foo\\(int, int\\);${ws}int operator ?!\\((void|)\\);${ws}int operator int\\((void|)\\);${ws}int times\\(int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # TODO: "int operator int()" is a bug
	    # kfail "gdb/1497" "ptype class Foo"
	    pass "ptype class Foo"
d482 2
a483 3
	-re "type = class Foo \{${ws}public:${ws}int x;${ws}int y;${ws}static int st;${ws}Foo ?& ?operator ?=\\(Foo const ?&\\);${ws}Foo\\(Foo const ?&\\);${ws}Foo\\(int, int\\);${ws}int operator ?!\\((void|)\\);${ws}operator int\\((void|)\\);${ws}int times\\(int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gstabs+
	    pass "ptype class Foo"
d485 3
a487 3
	-re "type = class Foo \{${ws}public:${ws}int x;${ws}int y;${ws}static int st;${ws}Foo\\(int, int\\);${ws}int operator ?!\\((void|)\\);${ws}operator int\\((void|)\\);${ws}int times\\(int\\);${ws}Foo ?& ?operator ?=\\(Foo const ?&\\);${ws}Foo\\(Foo const ?&\\);$nl\}$nl$gdb_prompt $" {
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class Foo"
d491 3
a493 7
    # A multiple inheritance derived class.

    gdb_test_multiple "ptype class Bar" "ptype class Bar" {
	-re "type = class Bar : public Base1, public Foo \{${ws}public:${ws}int z;${ws}Bar\\(int, int, int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d496 5
a500 4
	-re "type = class Bar : public Base1, public Foo \{${ws}public:${ws}int z;${ws}Bar ?& ?operator ?=\\(Bar const ?&\\);${ws}Bar\\(Bar const ?&\\);${ws}Bar\\(int, int, int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    pass "ptype class Bar"
d502 3
a504 3
	-re "type = class Bar : public Base1, public Foo \{${ws}public:${ws}int z;${ws}Bar\\(int, int, int\\);${ws}Bar ?& ?operator ?=\\(Bar const ?&\\);${ws}Bar\\(Bar const ?&\\);$nl\}$nl$gdb_prompt $" {
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class Bar"
d509 1
d511 1
a511 2
# TODO: these test names are gross!
# Just let the test name default.
d517 1
d519 1
d523 1
d525 1
d529 1
d531 1
d535 1
d537 1
d541 1
d543 1
d547 4
a550 4
# Test access to members of other classes.
# gdb should refuse to print them.
# (I feel old -- I remember when this was legal in C -- chastain).
# TODO: Again, change the silly test names.
d556 1
d558 1
d560 1
d562 1
d564 1
d568 4
a571 2
# Test access to names that are not members of any class.
# TODO: test names again.
d577 1
d579 1
d581 1
d585 1
d588 1
d609 1
d611 1
d615 1
a615 2
    global nl
    global ws
d618 6
d625 5
a629 7
    gdb_test "print obj_with_enum" \
	"\\$\[0-9\]+ = \{priv_enum = red, x = 0\}" \
	"print obj_with_enum (1)"

    # advance one line

    gdb_test "next" ""
d632 6
d639 7
a645 7
    gdb_test "print obj_with_enum" \
	"\\$\[0-9\]+ = \{priv_enum = green, x = 0\}" \
	"print obj_with_enum (2)"

    # print the enum member

    gdb_test "print obj_with_enum.priv_enum" "\\$\[0-9\]+ = green"
d648 9
a656 23

    gdb_test_multiple "ptype obj_with_enum.priv_enum" "ptype obj_with_enum.priv_enum" {
        -re "type = enum ClassWithEnum::PrivEnum \{ ?red, green, blue, yellow = 42 ?\}$nl$gdb_prompt $" {
	    pass "ptype obj_with_enum.priv_enum"
        }
	-re "type = enum PrivEnum \{ ?red, green, blue, yellow = 42 ?\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    pass "ptype obj_with_enum.priv_enum"
	}
	-re "type = enum \{ ?red, green, blue, yellow = 42 ?\}$nl$gdb_prompt $" {
	    # This case case is a little dubious, but it's not clear what
	    # ought to be required of a ptype on a private enum...
	    # -sts 19990324
	    #
	    # It bugs me that this happens with gcc 3.
	    # -- chastain 2003-12-30
	    #
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype obj_with_enum.priv_enum"
	}
d660 5
a664 5
    gdb_test_multiple "ptype obj_with_enum" "ptype obj_with_enum" {
	-re "type = class ClassWithEnum \{${ws}public:${ws}(enum |)ClassWithEnum::PrivEnum priv_enum;${ws}int x;$nl\}$nl$gdb_prompt $" {
	    pass "ptype obj_with_enum"
	}
	-re "type = class ClassWithEnum \{${ws}public:${ws}(enum |)PrivEnum priv_enum;${ws}int x;$nl\}$nl$gdb_prompt $" {
a672 7
	    #
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    kfail "gdb/57" "ptype obj_with_enum"
	}
	-re "type = class ClassWithEnum \{${ws}public:${ws}(enum |)PrivEnum priv_enum;${ws}int x;${ws}ClassWithEnum ?& ?operator ?=\\(ClassWithEnum const ?&\\);${ws}ClassWithEnum\\(ClassWithEnum const ?&\\);${ws}ClassWithEnum\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
d675 2
a676 8
	-re "type = class ClassWithEnum \{${ws}public:${ws}(enum |)ClassWithEnum::PrivEnum priv_enum;${ws}int x;${ws}ClassWithEnum ?& ?operator ?=\\(ClassWithEnum const ?&\\);${ws}ClassWithEnum\\(ClassWithEnum const ?&\\);${ws}ClassWithEnum\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # I think this is a PASS, but only carlton knows for sure.
	    # -- chastain 2003-12-30
	    #
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    fail "ptype obj_with_enum"
	}
d679 2
a680 13
    # I'll do this test two different ways, because of a parser bug.
    # See PR gdb/1588.

    gdb_test_multiple "print (ClassWithEnum::PrivEnum) 42" "print (ClassWithEnum::PrivEnum) 42" {
	-re "\\$\[0-9\]+ = yellow$nl$gdb_prompt $" {
	    pass "print (ClassWithEnum::PrivEnum) 42"
	}
	-re "A (parse|syntax) error in expression, near `42'.$nl$gdb_prompt $" {
	    # "parse error" is bison 1.35.
	    # "syntax error" is bison 1.875.
	    kfail "gdb/1588" "print (ClassWithEnum::PrivEnum) 42"
	}
    }
d682 22
a703 13
    gdb_test_multiple "print ('ClassWithEnum::PrivEnum') 42" "print ('ClassWithEnum::PrivEnum') 42" {
	-re "\\$\[0-9\]+ = yellow$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "print ('ClassWithEnum::PrivEnum') 42"
	}
	-re "No symbol \"ClassWithEnum::PrivEnum\" in current context.$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
	    # gcc 2.95.3 -gstabs+
	    kfail "gdb/57" "print ('ClassWithEnum::PrivEnum') 42"
	}
d707 1
d709 1
d713 29
d743 1
a743 11
    gdb_test "print Bar::z" "\\$\[0-9\]+ = \\(int ?\\( ?Bar::& ?\\) ?\\) ?Bar::z"
    gdb_test "print &Foo::x" "\\$\[0-9\]+ = \\(int ?\\( ?Foo::\\* ?\\) ?\\) ?&Foo::x"
    gdb_test "print (int)&Foo::x" "\\$\[0-9\]+ = 0"
    gdb_test "print (int)&Bar::y == 2*sizeof(int)" "\\$\[0-9\]+ = true"

    # TODO: this is a bogus test.  It's looking at a variable that
    # has not even been declared yet, so it's accessing random junk
    # on the stack and comparing that it's NOT equal to a specific
    # value.  It's been like this since gdb 4.10 in 1993!
    # -- chastain 2004-01-01
    gdb_test "print (int)pmi == sizeof(int)" ".* = false"
d746 1
d748 1
d753 32
d786 31
a816 6
    gdb_test "print Foo::st" "\\$\[0-9\]+ = 100"
    gdb_test "set foo.st = 200" "" ""
    gdb_test "print bar.st" "\\$\[0-9\]+ = 200"
    gdb_test "print &foo.st" "\\$\[0-9\]+ = \\(int ?\\*\\) $hex"
    gdb_test "print &Bar::st" "\\$\[0-9\]+ = \\(int ?\\*\\) $hex"
    gdb_test "print *\$" "\\$\[0-9\]+ = 200"
a842 1
    global nl
d854 7
a860 2
    gdb_test "set language c++" "" ""
    gdb_test "set width 0" "" ""
d862 5
a866 3
    if ![runto_main ] then {
	perror "couldn't run to breakpoint"
	return
a868 9
    gdb_breakpoint inheritance2
    gdb_test "continue" ".*Breakpoint .* inheritance2.*" ""

    test_ptype_class_objects
    test_non_inherited_member_access
    test_wrong_class_members
    test_nonexistent_members
    test_method_param_class

d870 42
a911 40
    gdb_test "continue" ".*Breakpoint .* enums2.*" "continue to enums2(\\(\\)|)"
    gdb_test "finish" "" ""
    test_enums

    gdb_test "finish" "" ""
    test_pointers_to_class_members
    test_static_members

    # Now some random tests that were just thrown in here.

    gdb_breakpoint marker_reg1
    gdb_test "continue" ".*Breakpoint .* marker_reg1.*" ""
    gdb_test "finish" "Run till exit from.*" "finish from marker_reg1"

    # This class is so small that an instance of it can fit in a register.
    # When gdb tries to call a method, it gets embarrassed about taking
    # the address of a register.
    #
    # TODO: I think that message should be a PASS, not an XFAIL.
    # gdb prints an informative message and declines to do something
    # impossible.
    #
    # The method call actually succeeds if the compiler allocates very
    # small classes in memory instead of registers.  So this test does
    # not tell us anything interesting if the call succeeds.
    #
    # -- chastain 2003-12-31
    gdb_test_multiple "print v.method ()" "calling method for small class" {
	-re "\\$\[0-9\]+ = 82$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "calling method for small class"
	}
	-re "Address requested for identifier \"v\" which is in register .*$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 2.95.3 -gstabs+
	    setup_xfail "*-*-*" 2972
	    fail "calling method for small class"
a914 4
    # This is a random v2 demangling test.
    # This is redundant with existing tests in demangle.exp.
    # TODO: Just remove this.
    gdb_test "maint demangle inheritance1__Fv" "inheritance1\\(void\\)" "demangle"
d918 7
@


1.2.6.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.2.6.2
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d2 1
a2 1
# 2003, 2004 Free Software Foundation, Inc.
a21 1
# And rewritten by Michael Chastain <mec.gnu@@mindspring.com>.
d27 1
a27 1
    strace $tracelevel
d36 7
d47 1
a49 20
# This code accepts the output of gcc v2 and v3, dwarf-2 and stabs+.
# It could use some expansion with other compilers such as hp-ux ac++.
#
# There are lots of variations in the output:
#
# . gcc -stabs+ emits debug info for implicit member functions:
#   operator=, copy ctor, ctor.  gcc -gdwarf-2 does not.
#
# . gcc with abi version 1 puts the implicit member functions
#   at the beginning of the member function list; with abi version 2,
#   the implicit member functions are at the end of the member function
#   list.  This appears as an output difference with -gstabs+.
#   gcc 3.3.X defaults to abi version 1, and gcc 3.4 will default
#   to abi version 2.
#
# . gcc v2 shows data members for virtual base pointers.
#   gcc v3 does not.
#
# . gdb always prints "class" for both "class" and "struct".
#   In the future, I should accept "struct" in case gdb improves.
d56 8
a63 7
    # Simple type.

    gdb_test_multiple "ptype struct default_public_struct" "ptype struct default_public_struct" {
	-re "type = class default_public_struct \{${ws}public:${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d66 1
a66 4
	-re "type = class default_public_struct \{${ws}public:${ws}int a;${ws}int b;${ws}default_public_struct ?& ?operator ?=\\(default_public_struct const ?&\\);${ws}default_public_struct\\(default_public_struct const ?&\\);${ws}default_public_struct\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d69 2
d73 8
a80 7
    # Same test, slightly different type.

    gdb_test_multiple "ptype struct explicit_public_struct" "ptype struct explicit_public_struct" {
	-re "type = class explicit_public_struct \{${ws}public:${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d83 1
a83 4
	-re "type = class explicit_public_struct \{${ws}public:${ws}int a;${ws}int b;${ws}explicit_public_struct ?& ?operator ?=\\(explicit_public_struct const ?&\\);${ws}explicit_public_struct\\(explicit_public_struct const ?&\\);${ws}explicit_public_struct\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d86 2
d90 2
a91 1
    # Same test, slightly different type.
d93 3
a95 5
    gdb_test_multiple "ptype struct protected_struct" "ptype struct protected_struct" {
	-re "type = class protected_struct \{${ws}protected:${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d98 1
a98 4
	-re "type = class protected_struct \{${ws}protected:${ws}int a;${ws}int b;${ws}public:${ws}protected_struct ?& ?operator ?=\\(protected_struct const ?&\\);${ws}protected_struct\\(protected_struct const ?&\\);${ws}protected_struct\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d101 2
d105 2
a106 1
    # Same test, slightly different type.
d108 3
a110 5
    gdb_test_multiple "ptype struct private_struct" "ptype struct private_struct" {
	-re "type = class private_struct \{${ws}private:${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d113 1
a113 4
	-re "type = class private_struct \{${ws}private:${ws}int a;${ws}int b;${ws}public:${ws}private_struct ?& ?operator ?=\\(private_struct const ?&\\);${ws}private_struct\\(private_struct const ?&\\);${ws}private_struct\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d116 2
d120 2
a121 1
    # Similar test, bigger type.
d123 3
a125 5
    gdb_test_multiple "ptype struct mixed_protection_struct" "ptype struct mixed_protection_struct" {
	-re "type = class mixed_protection_struct \{${ws}public:${ws}int a;${ws}int b;${ws}private:${ws}int c;${ws}int d;${ws}protected:${ws}int e;${ws}int f;${ws}public:${ws}int g;${ws}private:${ws}int h;${ws}protected:${ws}int i;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d128 4
a131 4
	-re "type = class mixed_protection_struct \{${ws}public:${ws}int a;${ws}int b;${ws}private:${ws}int c;${ws}int d;${ws}protected:${ws}int e;${ws}int f;${ws}public:${ws}int g;${ws}private:${ws}int h;${ws}protected:${ws}int i;${ws}public:${ws}mixed_protection_struct ?& ?operator ?=\\(mixed_protection_struct const ?&\\);${ws}mixed_protection_struct\\(mixed_protection_struct const ?&\\);${ws}mixed_protection_struct\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d134 2
d138 2
a139 2
    # All that again with "class" instead of "struct".
    # gdb does not care about the difference anyways.
d141 3
a143 5
    gdb_test_multiple "ptype class public_class" "ptype class public_class" {
	-re "type = class public_class \{${ws}public:${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d146 1
a146 4
	-re "type = class public_class \{${ws}public:${ws}int a;${ws}int b;${ws}public_class ?& ?operator ?=\\(public_class const ?&\\);${ws}public_class\\(public_class const ?&\\);${ws}public_class\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d149 2
d153 3
a155 7
    # Same test, slightly different type.

    gdb_test_multiple "ptype class protected_class" "ptype class protected_class" {
	-re "type = class protected_class \{${ws}protected:${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d158 2
a159 5
	-re "type = class protected_class \{${ws}protected:${ws}int a;${ws}int b;${ws}public:${ws}protected_class ?& ?operator ?=\\(protected_class const ?&\\);${ws}protected_class\\(protected_class const ?&\\);${ws}protected_class\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class protected_class"
d161 2
d165 4
a168 2
    # Same test, slightly different type.
    # The 'private' is optional but gdb always prints it.
d170 3
a172 5
    gdb_test_multiple "ptype class default_private_class" "ptype class default_private_class" {
	-re "type = class default_private_class \{${ws}(private:${ws}|)int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d175 1
a175 4
	-re "type = class default_private_class \{${ws}(private:${ws}|)int a;${ws}int b;${ws}public:${ws}default_private_class ?& ?operator ?=\\(default_private_class const ?&\\);${ws}default_private_class\\(default_private_class const ?&\\);${ws}default_private_class\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d178 2
d182 3
a184 7
    # Same test, slightly different type.

    gdb_test_multiple "ptype class explicit_private_class" "ptype class explicit_private_class" {
	-re "type = class explicit_private_class \{${ws}(private:${ws}|)int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d187 5
a191 5
	-re "type = class explicit_private_class \{${ws}(private:${ws}|)int a;${ws}int b;${ws}public:${ws}explicit_private_class ?& ?operator ?=\\(explicit_private_class const ?&\\);${ws}explicit_private_class\\(explicit_private_class const ?&\\);${ws}explicit_private_class\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class explicit_private_class"
d193 2
d197 3
a199 7
    # Similar test, bigger type.

    gdb_test_multiple "ptype class mixed_protection_class" "ptype struct mixed_protection_class" {
	-re "type = class mixed_protection_class \{${ws}public:${ws}int a;${ws}int b;${ws}private:${ws}int c;${ws}int d;${ws}protected:${ws}int e;${ws}int f;${ws}public:${ws}int g;${ws}private:${ws}int h;${ws}protected:${ws}int i;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d202 2
a203 5
	-re "type = class mixed_protection_class \{${ws}public:${ws}int a;${ws}int b;${ws}private:${ws}int c;${ws}int d;${ws}protected:${ws}int e;${ws}int f;${ws}public:${ws}int g;${ws}private:${ws}int h;${ws}protected:${ws}int i;${ws}public:${ws}mixed_protection_class ?& ?operator ?=\\(mixed_protection_class const ?&\\);${ws}mixed_protection_class\\(mixed_protection_class const ?&\\);${ws}mixed_protection_class\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class mixed_protection_class"
d205 2
d209 5
a213 9
    # Here are some classes with inheritance.

    # Base class.

    gdb_test_multiple "ptype class A" "ptype class A" {
	-re "type = class A \{${ws}public:${ws}int a;${ws}int x;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d216 6
a221 5
	-re "type = class A \{${ws}public:${ws}int a;${ws}int x;${ws}A ?& ?operator ?=\\(A const ?&\\);${ws}A\\(A const ?&\\);${ws}A\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class A"
d225 3
a227 7
    # Derived class.

    gdb_test_multiple "ptype class B" "ptype class B" {
	-re "type = class B : public A \{${ws}public:${ws}int b;${ws}int x;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d230 9
a238 5
	-re "type = class B : public A \{${ws}public:${ws}int b;${ws}int x;${ws}B ?& ?operator ?=\\(B const ?&\\);${ws}B\\(B const ?&\\);${ws}B\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class B"
d242 3
a244 7
    # Derived class.

    gdb_test_multiple "ptype class C" "ptype class C" {
	-re "type = class C : public A \{${ws}public:${ws}int c;${ws}int x;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d247 9
a255 5
	-re "type = class C : public A \{${ws}public:${ws}int c;${ws}int x;${ws}C ?& ?operator ?=\\(C const ?&\\);${ws}C\\(C const ?&\\);${ws}C\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class C"
d259 3
a261 7
    # Derived class, multiple inheritance.

    gdb_test_multiple "ptype class D" "ptype class D" {
	-re "type = class D : public B, public C \{${ws}public:${ws}int d;${ws}int x;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d264 9
a272 5
	-re "type = class D : public B, public C \{${ws}public:${ws}int d;${ws}int x;${ws}D ?& ?operator ?=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class D"
d276 3
a278 7
    # Derived class.

    gdb_test_multiple "ptype class E" "ptype class E" {
	-re "type = class E : public D \{${ws}public:${ws}int e;${ws}int x;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d281 1
a281 4
	-re "type = class E : public D \{${ws}public:${ws}int e;${ws}int x;${ws}E ?& ?operator ?=\\(E const ?&\\);${ws}E\\(E const ?&\\);${ws}E\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d284 7
d293 5
a297 10
    # This is a break from inheritance tests.
    #
    # gcc 2.X with stabs (stabs or stabs+?) used to have a problem with
    # static methods whose name is the same as their argument mangling.
 
    gdb_test_multiple "ptype class Static" "ptype class Static" {
	-re "type = class Static \{${ws}public:${ws}static void ii\\(int, int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d300 1
a300 3
	-re "type = class Static \{${ws}public:${ws}Static ?& ?operator ?=\\(Static const ?&\\);${ws}Static\\(Static const ?&\\);${ws}Static\\((void|)\\);${ws}static void ii\\(int, int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
d303 6
a308 3
	-re "type = class Static \{${ws}public:${ws}static void ii\\(int, int\\);${ws}Static ?& ?operator ?=\\(Static const ?&\\);${ws}Static\\(Static const ?&\\);${ws}Static\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class Static"
d312 3
a314 7
    # Here are some virtual inheritance tests.

    gdb_test_multiple "ptype class vA" "ptype class vA" {
	-re "type = class vA \{${ws}public:${ws}int va;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d317 1
a317 4
	-re "type = class vA \{${ws}public:${ws}int va;${ws}int vx;${ws}vA ?& ?operator ?=\\(vA const ?&\\);${ws}vA\\(vA const ?&\\);${ws}vA\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d320 10
d332 10
a341 13
    # With gcc 2, gdb prints the virtual base pointer.
    # With gcc 3, gdb does not print the virtual base pointer.
    # drow considers it a gdb bug if gdb prints the vbptr.

    gdb_test_multiple "ptype class vB" "ptype class vB" {
	-re "type = class vB : public virtual vA \{${ws}private:${ws}vA ?\\* ?_vb.2vA;${ws}public:${ws}int vb;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # TODO: kfail this
	    fail "ptype class vB"
	}
	-re "type = class vB : public virtual vA \{${ws}public:${ws}int vb;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d344 1
a344 4
	-re "type = class vB : public virtual vA \{${ws}private:${ws}vA ?\\* ?_vb.vA;${ws}public:${ws}int vb;${ws}int vx;${ws}vB ?& ?operator ?=\\(vB const ?&\\);${ws}vB\\(int, ?vB const ?&\\);${ws}vB\\(int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # See the hidden "in-charge" ctor parameter!
	    # TODO: kfail this
d348 13
a360 4
	-re "type = class vB : public virtual vA \{${ws}public:${ws}int vb;${ws}int vx;${ws}vB ?& ?operator ?=\\(vB const ?&\\);${ws}vB\\(vB const ?&\\);${ws}vB\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class vB"
d364 3
a366 1
    # Another class with a virtual base.
d368 3
a370 9
    gdb_test_multiple "ptype class vC" "ptype class vC" {
	-re "type = class vC : public virtual vA \{${ws}private:${ws}vA ?\\* ?_vb.2vA;${ws}public:${ws}int vc;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # TODO: kfail
	    fail "ptype class vC"
	}
	-re "type = class vC : public virtual vA \{${ws}public:${ws}int vc;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d373 1
a373 4
	-re "type = class vC : public virtual vA \{${ws}private:${ws}vA ?\\* ?_vb.vA;${ws}public:${ws}int vc;${ws}int vx;${ws}vC ?& ?operator ?=\\(vC const ?&\\);${ws}vC\\(int, ?vC const ?&\\);${ws}vC\\(int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # See the hidden "in-charge" ctor parameter!
	    # TODO: kfail
d377 13
a389 4
	-re "type = class vC : public virtual vA \{${ws}public:${ws}int vc;${ws}int vx;${ws}vC ?& ?operator ?=\\(vC const ?&\\);${ws}vC\\(vC const ?&\\);${ws}vC\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class vC"
d393 3
a395 1
    # The classic diamond inheritance.
d397 3
a399 9
    gdb_test_multiple "ptype class vD" "ptype class vD" {
	-re "type = class vD : public virtual vB, public virtual vC \{${ws}private:${ws}vC ?\\* ?_vb.2vC;${ws}vB ?\\* ?_vb.2vB;${ws}public:${ws}int vd;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # TODO: kfail
	    fail "ptype class vD"
	}
	-re "type = class vD : public virtual vB, public virtual vC \{${ws}public:${ws}int vd;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d402 1
a402 4
	-re "type = class vD : public virtual vB, public virtual vC \{${ws}private:${ws}vC ?\\* ?_vb.vC;${ws}vB ?\\* ?_vb.vB;${ws}public:${ws}int vd;${ws}int vx;${ws}vD ?& ?operator ?=\\(vD const ?&\\);${ws}vD\\(int, ?vD const ?&\\);${ws}vD\\(int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # See the hidden "in-charge" ctor parameter!
	    # TODO: kfail
d406 13
a418 4
	-re "type = class vD : public virtual vB, public virtual vC \{${ws}public:${ws}int vd;${ws}int vx;${ws}vD ?& ?operator ?=\\(vD const ?&\\);${ws}vD\\(vD const ?&\\);${ws}vD\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class vD"
d422 3
a424 1
    # One more case of virtual derivation.
d426 3
a428 9
    gdb_test_multiple "ptype class vE" "ptype class vE" {
	-re "type = class vE : public virtual vD \{${ws}private:${ws}vD ?\\* ?_vb.2vD;${ws}public:${ws}int ve;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # TODO: kfail
	    fail "ptype class vE"
	}
	-re "type = class vE : public virtual vD \{${ws}public:${ws}int ve;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d431 1
a431 4
	-re "type = class vE : public virtual vD \{${ws}private:${ws}vD ?\\* ?_vb.vD;${ws}public:${ws}int ve;${ws}int vx;${ws}vE ?& ?operator ?=\\(vE const ?&\\);${ws}vE\\(int, ?vE const ?&\\);${ws}vE\\(int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # See the hidden "in-charge" ctor parameter!
	    # TODO: kfail
d435 13
a447 4
	-re "type = class vE : public virtual vD \{${ws}public:${ws}int ve;${ws}int vx;${ws}vE ?& ?operator ?=\\(vE const ?&\\);${ws}vE\\(vE const ?&\\);${ws}vE\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class vE"
d451 3
a453 7
    # Another inheritance series.

    gdb_test_multiple "ptype class Base1" "ptype class Base1" {
	-re "type = class Base1 \{${ws}public:${ws}int x;${ws}Base1\\(int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d456 1
a456 3
	-re "type = class Base1 \{${ws}public:${ws}int x;${ws}Base1 ?& ?operator ?=\\(Base1 const ?&\\);${ws}Base1\\(Base1 const ?&\\);${ws}Base1\\(int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
d459 9
a467 3
	-re "type = class Base1 \{${ws}public:${ws}int x;${ws}Base1\\(int\\);${ws}Base1 ?& ?operator ?=\\(Base1 const ?&\\);${ws}Base1\\(Base1 const ?&\\);$nl\}$nl$gdb_prompt $" {
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class Base1"
d471 6
a476 7
    # The second base class.

    gdb_test_multiple "ptype class Foo" "ptype class Foo" {
	-re "type = class Foo \{${ws}public:${ws}int x;${ws}int y;${ws}static int st;${ws}Foo\\(int, int\\);${ws}int operator ?!\\((void|)\\);${ws}operator int\\((void|)\\);${ws}int times\\(int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d479 2
a480 5
	-re "type = class Foo \{${ws}public:${ws}int x;${ws}int y;${ws}static int st;${ws}Foo ?& ?operator ?=\\(Foo const ?&\\);${ws}Foo\\(Foo const ?&\\);${ws}Foo\\(int, int\\);${ws}int operator ?!\\((void|)\\);${ws}int operator int\\((void|)\\);${ws}int times\\(int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # TODO: "int operator int()" is a bug
	    # kfail "gdb/1497" "ptype class Foo"
	    pass "ptype class Foo"
d482 2
a483 3
	-re "type = class Foo \{${ws}public:${ws}int x;${ws}int y;${ws}static int st;${ws}Foo ?& ?operator ?=\\(Foo const ?&\\);${ws}Foo\\(Foo const ?&\\);${ws}Foo\\(int, int\\);${ws}int operator ?!\\((void|)\\);${ws}operator int\\((void|)\\);${ws}int times\\(int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gstabs+
	    pass "ptype class Foo"
d485 3
a487 3
	-re "type = class Foo \{${ws}public:${ws}int x;${ws}int y;${ws}static int st;${ws}Foo\\(int, int\\);${ws}int operator ?!\\((void|)\\);${ws}operator int\\((void|)\\);${ws}int times\\(int\\);${ws}Foo ?& ?operator ?=\\(Foo const ?&\\);${ws}Foo\\(Foo const ?&\\);$nl\}$nl$gdb_prompt $" {
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class Foo"
d491 3
a493 7
    # A multiple inheritance derived class.

    gdb_test_multiple "ptype class Bar" "ptype class Bar" {
	-re "type = class Bar : public Base1, public Foo \{${ws}public:${ws}int z;${ws}Bar\\(int, int, int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d496 5
a500 4
	-re "type = class Bar : public Base1, public Foo \{${ws}public:${ws}int z;${ws}Bar ?& ?operator ?=\\(Bar const ?&\\);${ws}Bar\\(Bar const ?&\\);${ws}Bar\\(int, int, int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    pass "ptype class Bar"
d502 3
a504 3
	-re "type = class Bar : public Base1, public Foo \{${ws}public:${ws}int z;${ws}Bar\\(int, int, int\\);${ws}Bar ?& ?operator ?=\\(Bar const ?&\\);${ws}Bar\\(Bar const ?&\\);$nl\}$nl$gdb_prompt $" {
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class Bar"
d509 1
d511 1
a511 2
# TODO: these test names are gross!
# Just let the test name default.
d517 1
d519 1
d523 1
d525 1
d529 1
d531 1
d535 1
d537 1
d541 1
d543 1
d547 4
a550 4
# Test access to members of other classes.
# gdb should refuse to print them.
# (I feel old -- I remember when this was legal in C -- chastain).
# TODO: Again, change the silly test names.
d556 1
d558 1
d560 1
d562 1
d564 1
d568 4
a571 2
# Test access to names that are not members of any class.
# TODO: test names again.
d577 1
d579 1
d581 1
d585 1
d588 1
d609 1
d611 1
d615 1
a615 2
    global nl
    global ws
d618 6
d625 5
a629 12
    gdb_test "print obj_with_enum" \
	"\\$\[0-9\]+ = \{priv_enum = red, x = 0\}" \
	"print obj_with_enum (1)"

    # advance one line

    gdb_test "next" ""

    # TODO: with gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2,
    # gdb says that obj_with_enum is out of scope here and the
    # tests after this FAIL.  This needs investigation.
    # -- chastain 2003-12-30
d632 6
d639 7
a645 7
    gdb_test "print obj_with_enum" \
	"\\$\[0-9\]+ = \{priv_enum = green, x = 0\}" \
	"print obj_with_enum (2)"

    # print the enum member

    gdb_test "print obj_with_enum.priv_enum" "\\$\[0-9\]+ = green"
d648 9
a656 23

    gdb_test_multiple "ptype obj_with_enum.priv_enum" "ptype obj_with_enum.priv_enum" {
        -re "type = enum ClassWithEnum::PrivEnum \{ ?red, green, blue, yellow = 42 ?\}$nl$gdb_prompt $" {
	    pass "ptype obj_with_enum.priv_enum"
        }
	-re "type = enum PrivEnum \{ ?red, green, blue, yellow = 42 ?\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    pass "ptype obj_with_enum.priv_enum"
	}
	-re "type = enum \{ ?red, green, blue, yellow = 42 ?\}$nl$gdb_prompt $" {
	    # This case case is a little dubious, but it's not clear what
	    # ought to be required of a ptype on a private enum...
	    # -sts 19990324
	    #
	    # It bugs me that this happens with gcc 3.
	    # -- chastain 2003-12-30
	    #
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype obj_with_enum.priv_enum"
	}
d660 5
a664 5
    gdb_test_multiple "ptype obj_with_enum" "ptype obj_with_enum" {
	-re "type = class ClassWithEnum \{${ws}public:${ws}(enum |)ClassWithEnum::PrivEnum priv_enum;${ws}int x;$nl\}$nl$gdb_prompt $" {
	    pass "ptype obj_with_enum"
	}
	-re "type = class ClassWithEnum \{${ws}public:${ws}(enum |)PrivEnum priv_enum;${ws}int x;$nl\}$nl$gdb_prompt $" {
a672 3
	    #
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
d675 2
a676 12
	-re "type = class ClassWithEnum \{${ws}public:${ws}(enum |)PrivEnum priv_enum;${ws}int x;${ws}ClassWithEnum ?& ?operator ?=\\(ClassWithEnum const ?&\\);${ws}ClassWithEnum\\(ClassWithEnum const ?&\\);${ws}ClassWithEnum\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    kfail "gdb/57" "ptype obj_with_enum"
	}
	-re "type = class ClassWithEnum \{${ws}public:${ws}(enum |)ClassWithEnum::PrivEnum priv_enum;${ws}int x;${ws}ClassWithEnum ?& ?operator ?=\\(ClassWithEnum const ?&\\);${ws}ClassWithEnum\\(ClassWithEnum const ?&\\);${ws}ClassWithEnum\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # I think this is a PASS, but only carlton knows for sure.
	    # -- chastain 2003-12-30
	    #
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    fail "ptype obj_with_enum"
	}
d679 12
a690 10
    # I'll do this test two different ways, because of a parser bug.
    # See PR gdb/826.

    gdb_test_multiple "print (ClassWithEnum::PrivEnum) 42" "print (ClassWithEnum::PrivEnum) 42" {
	-re "\\$\[0-9\]+ = yellow$nl$gdb_prompt $" {
	    pass "print (ClassWithEnum::PrivEnum) 42"
	}
	-re "A (parse|syntax) error in expression, near `42'.$nl$gdb_prompt $" {
	    # "parse error" is bison 1.35.
	    # "syntax error" is bison 1.875.
d693 2
d697 7
a703 13
    gdb_test_multiple "print ('ClassWithEnum::PrivEnum') 42" "print ('ClassWithEnum::PrivEnum') 42" {
	-re "\\$\[0-9\]+ = yellow$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "print ('ClassWithEnum::PrivEnum') 42"
	}
	-re "No symbol \"ClassWithEnum::PrivEnum\" in current context.$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
	    # gcc 2.95.3 -gstabs+
	    kfail "gdb/57" "print ('ClassWithEnum::PrivEnum') 42"
	}
d707 1
d709 1
d713 29
d743 1
a743 11
    gdb_test "print Bar::z" "\\$\[0-9\]+ = \\(int ?\\( ?Bar::& ?\\) ?\\) ?Bar::z"
    gdb_test "print &Foo::x" "\\$\[0-9\]+ = \\(int ?\\( ?Foo::\\* ?\\) ?\\) ?&Foo::x"
    gdb_test "print (int)&Foo::x" "\\$\[0-9\]+ = 0"
    gdb_test "print (int)&Bar::y == 2*sizeof(int)" "\\$\[0-9\]+ = true"

    # TODO: this is a bogus test.  It's looking at a variable that
    # has not even been declared yet, so it's accessing random junk
    # on the stack and comparing that it's NOT equal to a specific
    # value.  It's been like this since gdb 4.10 in 1993!
    # -- chastain 2004-01-01
    gdb_test "print (int)pmi == sizeof(int)" ".* = false"
d746 1
d748 1
d753 32
d786 31
a816 6
    gdb_test "print Foo::st" "\\$\[0-9\]+ = 100"
    gdb_test "set foo.st = 200" "" ""
    gdb_test "print bar.st" "\\$\[0-9\]+ = 200"
    gdb_test "print &foo.st" "\\$\[0-9\]+ = \\(int ?\\*\\) $hex"
    gdb_test "print &Bar::st" "\\$\[0-9\]+ = \\(int ?\\*\\) $hex"
    gdb_test "print *\$" "\\$\[0-9\]+ = 200"
a842 1
    global nl
d854 7
a860 2
    gdb_test "set language c++" "" ""
    gdb_test "set width 0" "" ""
d862 5
a866 3
    if ![runto_main ] then {
	perror "couldn't run to breakpoint"
	return
a868 9
    gdb_breakpoint inheritance2
    gdb_test "continue" ".*Breakpoint .* inheritance2.*" ""

    test_ptype_class_objects
    test_non_inherited_member_access
    test_wrong_class_members
    test_nonexistent_members
    test_method_param_class

d870 42
a911 40
    gdb_test "continue" ".*Breakpoint .* enums2.*" "continue to enums2(\\(\\)|)"
    gdb_test "finish" "" ""
    test_enums

    gdb_test "finish" "" ""
    test_pointers_to_class_members
    test_static_members

    # Now some random tests that were just thrown in here.

    gdb_breakpoint marker_reg1
    gdb_test "continue" ".*Breakpoint .* marker_reg1.*" ""
    gdb_test "finish" "Run till exit from.*" "finish from marker_reg1"

    # This class is so small that an instance of it can fit in a register.
    # When gdb tries to call a method, it gets embarrassed about taking
    # the address of a register.
    #
    # TODO: I think that message should be a PASS, not an XFAIL.
    # gdb prints an informative message and declines to do something
    # impossible.
    #
    # The method call actually succeeds if the compiler allocates very
    # small classes in memory instead of registers.  So this test does
    # not tell us anything interesting if the call succeeds.
    #
    # -- chastain 2003-12-31
    gdb_test_multiple "print v.method ()" "calling method for small class" {
	-re "\\$\[0-9\]+ = 82$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "calling method for small class"
	}
	-re "Address requested for identifier \"v\" which is in register .*$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 2.95.3 -gstabs+
	    setup_xfail "*-*-*" 2972
	    fail "calling method for small class"
a914 4
    # This is a random v2 demangling test.
    # This is redundant with existing tests in demangle.exp.
    # TODO: Just remove this.
    gdb_test "maint demangle inheritance1__Fv" "inheritance1\\(void\\)" "demangle"
d918 7
@


1.1
log
@2003-08-22  Michael Chastain  <mec@@shout.net>

	* gdb.cp: New directory.
	* gdb.cp/*: Copy from gdb.c++/*.
	* gdb.c++/*: Remove.
	* Makefile.in: Change gdb.c++ to gdb.cp.
	* configure.in:  Ditto.
	* configure: Regnerate.
@
text
@d685 8
a692 2
	-re "A parse error in expression, near `42'.\r\n$gdb_prompt $"
	{ kfail "gdb/826" "print (ClassWithEnum::PrivEnum) 42" }
@


1.1.4.1
log
@2003-08-22  Michael Chastain  <mec@@shout.net>

	* gdb.cp: New directory.
	* gdb.cp/*: Copy from gdb.c++/*.
	* gdb.c++/*: Remove.
	* Makefile.in: Change gdb.c++ to gdb.cp.
	* configure.in:  Ditto.
	* carlton_runnamespace: Ditto.
	* carlton_runtest: Ditto.
	* configure: Regnerate.
@
text
@@


1.1.4.2
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d685 2
a686 8
	-re "A parse error in expression, near `42'.\r\n$gdb_prompt $" {
	    # bison 1.35
	    kfail "gdb/826" "print (ClassWithEnum::PrivEnum) 42"
	}
	-re "A syntax error in expression, near `42'.\r\n$gdb_prompt $" {
	    # bison 1.875
	    kfail "gdb/826" "print (ClassWithEnum::PrivEnum) 42"
	}
@


1.1.4.3
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d2 1
a2 1
# 2003, 2004 Free Software Foundation, Inc.
a21 1
# And rewritten by Michael Chastain <mec.gnu@@mindspring.com>.
d27 1
a27 1
    strace $tracelevel
d36 7
d47 1
a49 20
# This code accepts the output of gcc v2 and v3, dwarf-2 and stabs+.
# It could use some expansion with other compilers such as hp-ux ac++.
#
# There are lots of variations in the output:
#
# . gcc -stabs+ emits debug info for implicit member functions:
#   operator=, copy ctor, ctor.  gcc -gdwarf-2 does not.
#
# . gcc with abi version 1 puts the implicit member functions
#   at the beginning of the member function list; with abi version 2,
#   the implicit member functions are at the end of the member function
#   list.  This appears as an output difference with -gstabs+.
#   gcc 3.3.X defaults to abi version 1, and gcc 3.4 will default
#   to abi version 2.
#
# . gcc v2 shows data members for virtual base pointers.
#   gcc v3 does not.
#
# . gdb always prints "class" for both "class" and "struct".
#   In the future, I should accept "struct" in case gdb improves.
d56 8
a63 7
    # Simple type.

    gdb_test_multiple "ptype struct default_public_struct" "ptype struct default_public_struct" {
	-re "type = class default_public_struct \{${ws}public:${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d66 1
a66 4
	-re "type = class default_public_struct \{${ws}public:${ws}int a;${ws}int b;${ws}default_public_struct ?& ?operator ?=\\(default_public_struct const ?&\\);${ws}default_public_struct\\(default_public_struct const ?&\\);${ws}default_public_struct\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d69 2
d73 8
a80 7
    # Same test, slightly different type.

    gdb_test_multiple "ptype struct explicit_public_struct" "ptype struct explicit_public_struct" {
	-re "type = class explicit_public_struct \{${ws}public:${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d83 1
a83 4
	-re "type = class explicit_public_struct \{${ws}public:${ws}int a;${ws}int b;${ws}explicit_public_struct ?& ?operator ?=\\(explicit_public_struct const ?&\\);${ws}explicit_public_struct\\(explicit_public_struct const ?&\\);${ws}explicit_public_struct\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d86 2
d90 2
a91 1
    # Same test, slightly different type.
d93 3
a95 5
    gdb_test_multiple "ptype struct protected_struct" "ptype struct protected_struct" {
	-re "type = class protected_struct \{${ws}protected:${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d98 1
a98 4
	-re "type = class protected_struct \{${ws}protected:${ws}int a;${ws}int b;${ws}public:${ws}protected_struct ?& ?operator ?=\\(protected_struct const ?&\\);${ws}protected_struct\\(protected_struct const ?&\\);${ws}protected_struct\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d101 2
d105 2
a106 1
    # Same test, slightly different type.
d108 3
a110 5
    gdb_test_multiple "ptype struct private_struct" "ptype struct private_struct" {
	-re "type = class private_struct \{${ws}private:${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d113 1
a113 4
	-re "type = class private_struct \{${ws}private:${ws}int a;${ws}int b;${ws}public:${ws}private_struct ?& ?operator ?=\\(private_struct const ?&\\);${ws}private_struct\\(private_struct const ?&\\);${ws}private_struct\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d116 2
d120 2
a121 1
    # Similar test, bigger type.
d123 3
a125 5
    gdb_test_multiple "ptype struct mixed_protection_struct" "ptype struct mixed_protection_struct" {
	-re "type = class mixed_protection_struct \{${ws}public:${ws}int a;${ws}int b;${ws}private:${ws}int c;${ws}int d;${ws}protected:${ws}int e;${ws}int f;${ws}public:${ws}int g;${ws}private:${ws}int h;${ws}protected:${ws}int i;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d128 4
a131 4
	-re "type = class mixed_protection_struct \{${ws}public:${ws}int a;${ws}int b;${ws}private:${ws}int c;${ws}int d;${ws}protected:${ws}int e;${ws}int f;${ws}public:${ws}int g;${ws}private:${ws}int h;${ws}protected:${ws}int i;${ws}public:${ws}mixed_protection_struct ?& ?operator ?=\\(mixed_protection_struct const ?&\\);${ws}mixed_protection_struct\\(mixed_protection_struct const ?&\\);${ws}mixed_protection_struct\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d134 2
d138 2
a139 2
    # All that again with "class" instead of "struct".
    # gdb does not care about the difference anyways.
d141 3
a143 5
    gdb_test_multiple "ptype class public_class" "ptype class public_class" {
	-re "type = class public_class \{${ws}public:${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d146 1
a146 4
	-re "type = class public_class \{${ws}public:${ws}int a;${ws}int b;${ws}public_class ?& ?operator ?=\\(public_class const ?&\\);${ws}public_class\\(public_class const ?&\\);${ws}public_class\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d149 2
d153 3
a155 7
    # Same test, slightly different type.

    gdb_test_multiple "ptype class protected_class" "ptype class protected_class" {
	-re "type = class protected_class \{${ws}protected:${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d158 2
a159 5
	-re "type = class protected_class \{${ws}protected:${ws}int a;${ws}int b;${ws}public:${ws}protected_class ?& ?operator ?=\\(protected_class const ?&\\);${ws}protected_class\\(protected_class const ?&\\);${ws}protected_class\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class protected_class"
d161 2
d165 4
a168 2
    # Same test, slightly different type.
    # The 'private' is optional but gdb always prints it.
d170 3
a172 5
    gdb_test_multiple "ptype class default_private_class" "ptype class default_private_class" {
	-re "type = class default_private_class \{${ws}(private:${ws}|)int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d175 1
a175 4
	-re "type = class default_private_class \{${ws}(private:${ws}|)int a;${ws}int b;${ws}public:${ws}default_private_class ?& ?operator ?=\\(default_private_class const ?&\\);${ws}default_private_class\\(default_private_class const ?&\\);${ws}default_private_class\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d178 2
d182 3
a184 7
    # Same test, slightly different type.

    gdb_test_multiple "ptype class explicit_private_class" "ptype class explicit_private_class" {
	-re "type = class explicit_private_class \{${ws}(private:${ws}|)int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d187 5
a191 5
	-re "type = class explicit_private_class \{${ws}(private:${ws}|)int a;${ws}int b;${ws}public:${ws}explicit_private_class ?& ?operator ?=\\(explicit_private_class const ?&\\);${ws}explicit_private_class\\(explicit_private_class const ?&\\);${ws}explicit_private_class\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class explicit_private_class"
d193 2
d197 3
a199 7
    # Similar test, bigger type.

    gdb_test_multiple "ptype class mixed_protection_class" "ptype struct mixed_protection_class" {
	-re "type = class mixed_protection_class \{${ws}public:${ws}int a;${ws}int b;${ws}private:${ws}int c;${ws}int d;${ws}protected:${ws}int e;${ws}int f;${ws}public:${ws}int g;${ws}private:${ws}int h;${ws}protected:${ws}int i;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d202 2
a203 5
	-re "type = class mixed_protection_class \{${ws}public:${ws}int a;${ws}int b;${ws}private:${ws}int c;${ws}int d;${ws}protected:${ws}int e;${ws}int f;${ws}public:${ws}int g;${ws}private:${ws}int h;${ws}protected:${ws}int i;${ws}public:${ws}mixed_protection_class ?& ?operator ?=\\(mixed_protection_class const ?&\\);${ws}mixed_protection_class\\(mixed_protection_class const ?&\\);${ws}mixed_protection_class\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class mixed_protection_class"
d205 2
d209 5
a213 9
    # Here are some classes with inheritance.

    # Base class.

    gdb_test_multiple "ptype class A" "ptype class A" {
	-re "type = class A \{${ws}public:${ws}int a;${ws}int x;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d216 6
a221 5
	-re "type = class A \{${ws}public:${ws}int a;${ws}int x;${ws}A ?& ?operator ?=\\(A const ?&\\);${ws}A\\(A const ?&\\);${ws}A\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class A"
d225 3
a227 7
    # Derived class.

    gdb_test_multiple "ptype class B" "ptype class B" {
	-re "type = class B : public A \{${ws}public:${ws}int b;${ws}int x;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d230 9
a238 5
	-re "type = class B : public A \{${ws}public:${ws}int b;${ws}int x;${ws}B ?& ?operator ?=\\(B const ?&\\);${ws}B\\(B const ?&\\);${ws}B\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class B"
d242 3
a244 7
    # Derived class.

    gdb_test_multiple "ptype class C" "ptype class C" {
	-re "type = class C : public A \{${ws}public:${ws}int c;${ws}int x;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d247 9
a255 5
	-re "type = class C : public A \{${ws}public:${ws}int c;${ws}int x;${ws}C ?& ?operator ?=\\(C const ?&\\);${ws}C\\(C const ?&\\);${ws}C\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class C"
d259 3
a261 7
    # Derived class, multiple inheritance.

    gdb_test_multiple "ptype class D" "ptype class D" {
	-re "type = class D : public B, public C \{${ws}public:${ws}int d;${ws}int x;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d264 9
a272 5
	-re "type = class D : public B, public C \{${ws}public:${ws}int d;${ws}int x;${ws}D ?& ?operator ?=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class D"
d276 3
a278 7
    # Derived class.

    gdb_test_multiple "ptype class E" "ptype class E" {
	-re "type = class E : public D \{${ws}public:${ws}int e;${ws}int x;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d281 1
a281 4
	-re "type = class E : public D \{${ws}public:${ws}int e;${ws}int x;${ws}E ?& ?operator ?=\\(E const ?&\\);${ws}E\\(E const ?&\\);${ws}E\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d284 7
d293 5
a297 10
    # This is a break from inheritance tests.
    #
    # gcc 2.X with stabs (stabs or stabs+?) used to have a problem with
    # static methods whose name is the same as their argument mangling.
 
    gdb_test_multiple "ptype class Static" "ptype class Static" {
	-re "type = class Static \{${ws}public:${ws}static void ii\\(int, int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d300 1
a300 3
	-re "type = class Static \{${ws}public:${ws}Static ?& ?operator ?=\\(Static const ?&\\);${ws}Static\\(Static const ?&\\);${ws}Static\\((void|)\\);${ws}static void ii\\(int, int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
d303 6
a308 3
	-re "type = class Static \{${ws}public:${ws}static void ii\\(int, int\\);${ws}Static ?& ?operator ?=\\(Static const ?&\\);${ws}Static\\(Static const ?&\\);${ws}Static\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class Static"
d312 3
a314 7
    # Here are some virtual inheritance tests.

    gdb_test_multiple "ptype class vA" "ptype class vA" {
	-re "type = class vA \{${ws}public:${ws}int va;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d317 1
a317 4
	-re "type = class vA \{${ws}public:${ws}int va;${ws}int vx;${ws}vA ?& ?operator ?=\\(vA const ?&\\);${ws}vA\\(vA const ?&\\);${ws}vA\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
d320 10
d332 10
a341 13
    # With gcc 2, gdb prints the virtual base pointer.
    # With gcc 3, gdb does not print the virtual base pointer.
    # drow considers it a gdb bug if gdb prints the vbptr.

    gdb_test_multiple "ptype class vB" "ptype class vB" {
	-re "type = class vB : public virtual vA \{${ws}private:${ws}vA ?\\* ?_vb.2vA;${ws}public:${ws}int vb;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # TODO: kfail this
	    fail "ptype class vB"
	}
	-re "type = class vB : public virtual vA \{${ws}public:${ws}int vb;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d344 1
a344 4
	-re "type = class vB : public virtual vA \{${ws}private:${ws}vA ?\\* ?_vb.vA;${ws}public:${ws}int vb;${ws}int vx;${ws}vB ?& ?operator ?=\\(vB const ?&\\);${ws}vB\\(int, ?vB const ?&\\);${ws}vB\\(int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # See the hidden "in-charge" ctor parameter!
	    # TODO: kfail this
d348 13
a360 4
	-re "type = class vB : public virtual vA \{${ws}public:${ws}int vb;${ws}int vx;${ws}vB ?& ?operator ?=\\(vB const ?&\\);${ws}vB\\(vB const ?&\\);${ws}vB\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class vB"
d364 3
a366 1
    # Another class with a virtual base.
d368 3
a370 9
    gdb_test_multiple "ptype class vC" "ptype class vC" {
	-re "type = class vC : public virtual vA \{${ws}private:${ws}vA ?\\* ?_vb.2vA;${ws}public:${ws}int vc;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # TODO: kfail
	    fail "ptype class vC"
	}
	-re "type = class vC : public virtual vA \{${ws}public:${ws}int vc;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d373 1
a373 4
	-re "type = class vC : public virtual vA \{${ws}private:${ws}vA ?\\* ?_vb.vA;${ws}public:${ws}int vc;${ws}int vx;${ws}vC ?& ?operator ?=\\(vC const ?&\\);${ws}vC\\(int, ?vC const ?&\\);${ws}vC\\(int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # See the hidden "in-charge" ctor parameter!
	    # TODO: kfail
d377 13
a389 4
	-re "type = class vC : public virtual vA \{${ws}public:${ws}int vc;${ws}int vx;${ws}vC ?& ?operator ?=\\(vC const ?&\\);${ws}vC\\(vC const ?&\\);${ws}vC\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class vC"
d393 3
a395 1
    # The classic diamond inheritance.
d397 3
a399 9
    gdb_test_multiple "ptype class vD" "ptype class vD" {
	-re "type = class vD : public virtual vB, public virtual vC \{${ws}private:${ws}vC ?\\* ?_vb.2vC;${ws}vB ?\\* ?_vb.2vB;${ws}public:${ws}int vd;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # TODO: kfail
	    fail "ptype class vD"
	}
	-re "type = class vD : public virtual vB, public virtual vC \{${ws}public:${ws}int vd;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d402 1
a402 4
	-re "type = class vD : public virtual vB, public virtual vC \{${ws}private:${ws}vC ?\\* ?_vb.vC;${ws}vB ?\\* ?_vb.vB;${ws}public:${ws}int vd;${ws}int vx;${ws}vD ?& ?operator ?=\\(vD const ?&\\);${ws}vD\\(int, ?vD const ?&\\);${ws}vD\\(int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # See the hidden "in-charge" ctor parameter!
	    # TODO: kfail
d406 13
a418 4
	-re "type = class vD : public virtual vB, public virtual vC \{${ws}public:${ws}int vd;${ws}int vx;${ws}vD ?& ?operator ?=\\(vD const ?&\\);${ws}vD\\(vD const ?&\\);${ws}vD\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class vD"
d422 3
a424 1
    # One more case of virtual derivation.
d426 3
a428 9
    gdb_test_multiple "ptype class vE" "ptype class vE" {
	-re "type = class vE : public virtual vD \{${ws}private:${ws}vD ?\\* ?_vb.2vD;${ws}public:${ws}int ve;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # TODO: kfail
	    fail "ptype class vE"
	}
	-re "type = class vE : public virtual vD \{${ws}public:${ws}int ve;${ws}int vx;$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d431 1
a431 4
	-re "type = class vE : public virtual vD \{${ws}private:${ws}vD ?\\* ?_vb.vD;${ws}public:${ws}int ve;${ws}int vx;${ws}vE ?& ?operator ?=\\(vE const ?&\\);${ws}vE\\(int, ?vE const ?&\\);${ws}vE\\(int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # See the hidden "in-charge" ctor parameter!
	    # TODO: kfail
d435 13
a447 4
	-re "type = class vE : public virtual vD \{${ws}public:${ws}int ve;${ws}int vx;${ws}vE ?& ?operator ?=\\(vE const ?&\\);${ws}vE\\(vE const ?&\\);${ws}vE\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class vE"
d451 3
a453 7
    # Another inheritance series.

    gdb_test_multiple "ptype class Base1" "ptype class Base1" {
	-re "type = class Base1 \{${ws}public:${ws}int x;${ws}Base1\\(int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d456 1
a456 3
	-re "type = class Base1 \{${ws}public:${ws}int x;${ws}Base1 ?& ?operator ?=\\(Base1 const ?&\\);${ws}Base1\\(Base1 const ?&\\);${ws}Base1\\(int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
d459 9
a467 3
	-re "type = class Base1 \{${ws}public:${ws}int x;${ws}Base1\\(int\\);${ws}Base1 ?& ?operator ?=\\(Base1 const ?&\\);${ws}Base1\\(Base1 const ?&\\);$nl\}$nl$gdb_prompt $" {
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class Base1"
d471 6
a476 7
    # The second base class.

    gdb_test_multiple "ptype class Foo" "ptype class Foo" {
	-re "type = class Foo \{${ws}public:${ws}int x;${ws}int y;${ws}static int st;${ws}Foo\\(int, int\\);${ws}int operator ?!\\((void|)\\);${ws}operator int\\((void|)\\);${ws}int times\\(int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d479 2
a480 5
	-re "type = class Foo \{${ws}public:${ws}int x;${ws}int y;${ws}static int st;${ws}Foo ?& ?operator ?=\\(Foo const ?&\\);${ws}Foo\\(Foo const ?&\\);${ws}Foo\\(int, int\\);${ws}int operator ?!\\((void|)\\);${ws}int operator int\\((void|)\\);${ws}int times\\(int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # TODO: "int operator int()" is a bug
	    # kfail "gdb/1497" "ptype class Foo"
	    pass "ptype class Foo"
d482 2
a483 3
	-re "type = class Foo \{${ws}public:${ws}int x;${ws}int y;${ws}static int st;${ws}Foo ?& ?operator ?=\\(Foo const ?&\\);${ws}Foo\\(Foo const ?&\\);${ws}Foo\\(int, int\\);${ws}int operator ?!\\((void|)\\);${ws}operator int\\((void|)\\);${ws}int times\\(int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gstabs+
	    pass "ptype class Foo"
d485 3
a487 3
	-re "type = class Foo \{${ws}public:${ws}int x;${ws}int y;${ws}static int st;${ws}Foo\\(int, int\\);${ws}int operator ?!\\((void|)\\);${ws}operator int\\((void|)\\);${ws}int times\\(int\\);${ws}Foo ?& ?operator ?=\\(Foo const ?&\\);${ws}Foo\\(Foo const ?&\\);$nl\}$nl$gdb_prompt $" {
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class Foo"
d491 3
a493 7
    # A multiple inheritance derived class.

    gdb_test_multiple "ptype class Bar" "ptype class Bar" {
	-re "type = class Bar : public Base1, public Foo \{${ws}public:${ws}int z;${ws}Bar\\(int, int, int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
d496 5
a500 4
	-re "type = class Bar : public Base1, public Foo \{${ws}public:${ws}int z;${ws}Bar ?& ?operator ?=\\(Bar const ?&\\);${ws}Bar\\(Bar const ?&\\);${ws}Bar\\(int, int, int\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    pass "ptype class Bar"
d502 3
a504 3
	-re "type = class Bar : public Base1, public Foo \{${ws}public:${ws}int z;${ws}Bar\\(int, int, int\\);${ws}Bar ?& ?operator ?=\\(Bar const ?&\\);${ws}Bar\\(Bar const ?&\\);$nl\}$nl$gdb_prompt $" {
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype class Bar"
d509 1
d511 1
a511 2
# TODO: these test names are gross!
# Just let the test name default.
d517 1
d519 1
d523 1
d525 1
d529 1
d531 1
d535 1
d537 1
d541 1
d543 1
d547 4
a550 4
# Test access to members of other classes.
# gdb should refuse to print them.
# (I feel old -- I remember when this was legal in C -- chastain).
# TODO: Again, change the silly test names.
d556 1
d558 1
d560 1
d562 1
d564 1
d568 4
a571 2
# Test access to names that are not members of any class.
# TODO: test names again.
d577 1
d579 1
d581 1
d585 1
d588 1
d609 1
d611 1
d615 1
a615 2
    global nl
    global ws
d618 6
d625 5
a629 12
    gdb_test "print obj_with_enum" \
	"\\$\[0-9\]+ = \{priv_enum = red, x = 0\}" \
	"print obj_with_enum (1)"

    # advance one line

    gdb_test "next" ""

    # TODO: with gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2,
    # gdb says that obj_with_enum is out of scope here and the
    # tests after this FAIL.  This needs investigation.
    # -- chastain 2003-12-30
d632 6
d639 7
a645 7
    gdb_test "print obj_with_enum" \
	"\\$\[0-9\]+ = \{priv_enum = green, x = 0\}" \
	"print obj_with_enum (2)"

    # print the enum member

    gdb_test "print obj_with_enum.priv_enum" "\\$\[0-9\]+ = green"
d648 9
a656 23

    gdb_test_multiple "ptype obj_with_enum.priv_enum" "ptype obj_with_enum.priv_enum" {
        -re "type = enum ClassWithEnum::PrivEnum \{ ?red, green, blue, yellow = 42 ?\}$nl$gdb_prompt $" {
	    pass "ptype obj_with_enum.priv_enum"
        }
	-re "type = enum PrivEnum \{ ?red, green, blue, yellow = 42 ?\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    pass "ptype obj_with_enum.priv_enum"
	}
	-re "type = enum \{ ?red, green, blue, yellow = 42 ?\}$nl$gdb_prompt $" {
	    # This case case is a little dubious, but it's not clear what
	    # ought to be required of a ptype on a private enum...
	    # -sts 19990324
	    #
	    # It bugs me that this happens with gcc 3.
	    # -- chastain 2003-12-30
	    #
	    # gcc 2.95.3 -gstabs+
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "ptype obj_with_enum.priv_enum"
	}
d660 5
a664 5
    gdb_test_multiple "ptype obj_with_enum" "ptype obj_with_enum" {
	-re "type = class ClassWithEnum \{${ws}public:${ws}(enum |)ClassWithEnum::PrivEnum priv_enum;${ws}int x;$nl\}$nl$gdb_prompt $" {
	    pass "ptype obj_with_enum"
	}
	-re "type = class ClassWithEnum \{${ws}public:${ws}(enum |)PrivEnum priv_enum;${ws}int x;$nl\}$nl$gdb_prompt $" {
a672 3
	    #
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
d675 2
a676 12
	-re "type = class ClassWithEnum \{${ws}public:${ws}(enum |)PrivEnum priv_enum;${ws}int x;${ws}ClassWithEnum ?& ?operator ?=\\(ClassWithEnum const ?&\\);${ws}ClassWithEnum\\(ClassWithEnum const ?&\\);${ws}ClassWithEnum\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gstabs+
	    kfail "gdb/57" "ptype obj_with_enum"
	}
	-re "type = class ClassWithEnum \{${ws}public:${ws}(enum |)ClassWithEnum::PrivEnum priv_enum;${ws}int x;${ws}ClassWithEnum ?& ?operator ?=\\(ClassWithEnum const ?&\\);${ws}ClassWithEnum\\(ClassWithEnum const ?&\\);${ws}ClassWithEnum\\((void|)\\);$nl\}$nl$gdb_prompt $" {
	    # I think this is a PASS, but only carlton knows for sure.
	    # -- chastain 2003-12-30
	    #
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    fail "ptype obj_with_enum"
	}
d679 12
a690 10
    # I'll do this test two different ways, because of a parser bug.
    # See PR gdb/826.

    gdb_test_multiple "print (ClassWithEnum::PrivEnum) 42" "print (ClassWithEnum::PrivEnum) 42" {
	-re "\\$\[0-9\]+ = yellow$nl$gdb_prompt $" {
	    pass "print (ClassWithEnum::PrivEnum) 42"
	}
	-re "A (parse|syntax) error in expression, near `42'.$nl$gdb_prompt $" {
	    # "parse error" is bison 1.35.
	    # "syntax error" is bison 1.875.
d693 2
d697 7
a703 13
    gdb_test_multiple "print ('ClassWithEnum::PrivEnum') 42" "print ('ClassWithEnum::PrivEnum') 42" {
	-re "\\$\[0-9\]+ = yellow$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "print ('ClassWithEnum::PrivEnum') 42"
	}
	-re "No symbol \"ClassWithEnum::PrivEnum\" in current context.$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
	    # gcc 2.95.3 -gstabs+
	    kfail "gdb/57" "print ('ClassWithEnum::PrivEnum') 42"
	}
d707 1
d709 1
d713 29
d743 1
a743 11
    gdb_test "print Bar::z" "\\$\[0-9\]+ = \\(int ?\\( ?Bar::& ?\\) ?\\) ?Bar::z"
    gdb_test "print &Foo::x" "\\$\[0-9\]+ = \\(int ?\\( ?Foo::\\* ?\\) ?\\) ?&Foo::x"
    gdb_test "print (int)&Foo::x" "\\$\[0-9\]+ = 0"
    gdb_test "print (int)&Bar::y == 2*sizeof(int)" "\\$\[0-9\]+ = true"

    # TODO: this is a bogus test.  It's looking at a variable that
    # has not even been declared yet, so it's accessing random junk
    # on the stack and comparing that it's NOT equal to a specific
    # value.  It's been like this since gdb 4.10 in 1993!
    # -- chastain 2004-01-01
    gdb_test "print (int)pmi == sizeof(int)" ".* = false"
d746 1
d748 1
d753 32
d786 31
a816 6
    gdb_test "print Foo::st" "\\$\[0-9\]+ = 100"
    gdb_test "set foo.st = 200" "" ""
    gdb_test "print bar.st" "\\$\[0-9\]+ = 200"
    gdb_test "print &foo.st" "\\$\[0-9\]+ = \\(int ?\\*\\) $hex"
    gdb_test "print &Bar::st" "\\$\[0-9\]+ = \\(int ?\\*\\) $hex"
    gdb_test "print *\$" "\\$\[0-9\]+ = 200"
a842 1
    global nl
d854 7
a860 2
    gdb_test "set language c++" "" ""
    gdb_test "set width 0" "" ""
d862 5
a866 3
    if ![runto_main ] then {
	perror "couldn't run to breakpoint"
	return
a868 9
    gdb_breakpoint inheritance2
    gdb_test "continue" ".*Breakpoint .* inheritance2.*" ""

    test_ptype_class_objects
    test_non_inherited_member_access
    test_wrong_class_members
    test_nonexistent_members
    test_method_param_class

d870 42
a911 40
    gdb_test "continue" ".*Breakpoint .* enums2.*" "continue to enums2(\\(\\)|)"
    gdb_test "finish" "" ""
    test_enums

    gdb_test "finish" "" ""
    test_pointers_to_class_members
    test_static_members

    # Now some random tests that were just thrown in here.

    gdb_breakpoint marker_reg1
    gdb_test "continue" ".*Breakpoint .* marker_reg1.*" ""
    gdb_test "finish" "Run till exit from.*" "finish from marker_reg1"

    # This class is so small that an instance of it can fit in a register.
    # When gdb tries to call a method, it gets embarrassed about taking
    # the address of a register.
    #
    # TODO: I think that message should be a PASS, not an XFAIL.
    # gdb prints an informative message and declines to do something
    # impossible.
    #
    # The method call actually succeeds if the compiler allocates very
    # small classes in memory instead of registers.  So this test does
    # not tell us anything interesting if the call succeeds.
    #
    # -- chastain 2003-12-31
    gdb_test_multiple "print v.method ()" "calling method for small class" {
	-re "\\$\[0-9\]+ = 82$nl$gdb_prompt $" {
	    # gcc 3.3.2 -gdwarf-2
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gdwarf-2
	    # gcc 3.3.2 -gstabs+
	    # gcc HEAD 2003-12-28 21:08:30 UTC -gstabs+
	    pass "calling method for small class"
	}
	-re "Address requested for identifier \"v\" which is in register .*$nl$gdb_prompt $" {
	    # gcc 2.95.3 -gdwarf-2
	    # gcc 2.95.3 -gstabs+
	    setup_xfail "*-*-*" 2972
	    fail "calling method for small class"
a914 4
    # This is a random v2 demangling test.
    # This is redundant with existing tests in demangle.exp.
    # TODO: Just remove this.
    gdb_test "maint demangle inheritance1__Fv" "inheritance1\\(void\\)" "demangle"
d918 7
@


1.1.2.1
log
@2003-08-22  Michael Chastain  <mec@@shout.net>

	* gdb.cp: New directory.
	* gdb.cp/*: Copy from gdb.c++/*.
	* gdb.c++/*: Remove.
	* Makefile.in: Change gdb.c++ to gdb.cp.
	* configure.in:  Ditto.
	* configure: Regnerate.
@
text
@@

