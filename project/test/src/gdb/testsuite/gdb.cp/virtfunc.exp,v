head	1.30;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.29
	gdb_7_6-2013-04-26-release:1.29
	gdb_7_6-branch:1.29.0.2
	gdb_7_6-2013-03-12-branchpoint:1.29
	gdb_7_5_1-2012-11-29-release:1.27
	gdb_7_5-2012-08-17-release:1.27
	gdb_7_5-branch:1.27.0.2
	gdb_7_5-2012-07-18-branchpoint:1.27
	gdb_7_4_1-2012-04-26-release:1.23.4.1
	gdb_7_4-2012-01-24-release:1.23.4.1
	gdb_7_4-branch:1.23.0.4
	gdb_7_4-2011-12-13-branchpoint:1.23
	gdb_7_3_1-2011-09-04-release:1.23
	gdb_7_3-2011-07-26-release:1.23
	gdb_7_3-branch:1.23.0.2
	gdb_7_3-2011-04-01-branchpoint:1.23
	gdb_7_2-2010-09-02-release:1.22
	gdb_7_2-branch:1.22.0.2
	gdb_7_2-2010-07-07-branchpoint:1.22
	gdb_7_1-2010-03-18-release:1.20
	gdb_7_1-branch:1.20.0.2
	gdb_7_1-2010-02-18-branchpoint:1.20
	gdb_7_0_1-2009-12-22-release:1.18
	gdb_7_0-2009-10-06-release:1.18
	gdb_7_0-branch:1.18.0.4
	gdb_7_0-2009-09-16-branchpoint:1.18
	arc-sim-20090309:1.17
	msnyder-checkpoint-072509-branch:1.18.0.2
	msnyder-checkpoint-072509-branchpoint:1.18
	arc-insight_6_8-branch:1.17.0.16
	arc-insight_6_8-branchpoint:1.17
	insight_6_8-branch:1.17.0.14
	insight_6_8-branchpoint:1.17
	reverse-20081226-branch:1.17.0.12
	reverse-20081226-branchpoint:1.17
	multiprocess-20081120-branch:1.17.0.10
	multiprocess-20081120-branchpoint:1.17
	reverse-20080930-branch:1.17.0.8
	reverse-20080930-branchpoint:1.17
	reverse-20080717-branch:1.17.0.6
	reverse-20080717-branchpoint:1.17
	msnyder-reverse-20080609-branch:1.17.0.4
	msnyder-reverse-20080609-branchpoint:1.17
	drow-reverse-20070409-branch:1.14.0.2
	drow-reverse-20070409-branchpoint:1.14
	gdb_6_8-2008-03-27-release:1.17
	gdb_6_8-branch:1.17.0.2
	gdb_6_8-2008-02-26-branchpoint:1.17
	gdb_6_7_1-2007-10-29-release:1.16
	gdb_6_7-2007-10-10-release:1.16
	gdb_6_7-branch:1.16.0.2
	gdb_6_7-2007-09-07-branchpoint:1.16
	insight_6_6-20070208-release:1.12
	gdb_6_6-2006-12-18-release:1.12
	gdb_6_6-branch:1.12.0.2
	gdb_6_6-2006-11-15-branchpoint:1.12
	insight_6_5-20061003-release:1.11
	gdb-csl-symbian-6_4_50_20060226-12:1.11
	gdb-csl-sourcerygxx-3_4_4-25:1.11
	nickrob-async-20060828-mergepoint:1.12
	gdb-csl-symbian-6_4_50_20060226-11:1.11
	gdb-csl-sourcerygxx-4_1-17:1.11
	gdb-csl-20060226-branch-local-2:1.11
	gdb-csl-sourcerygxx-4_1-14:1.11
	gdb-csl-sourcerygxx-4_1-13:1.11
	gdb-csl-sourcerygxx-4_1-12:1.11
	gdb-csl-sourcerygxx-3_4_4-21:1.11
	gdb_6_5-20060621-release:1.11
	gdb-csl-sourcerygxx-4_1-9:1.11
	gdb-csl-sourcerygxx-4_1-8:1.11
	gdb-csl-sourcerygxx-4_1-7:1.11
	gdb-csl-arm-2006q1-6:1.11
	gdb-csl-sourcerygxx-4_1-6:1.11
	gdb-csl-symbian-6_4_50_20060226-10:1.11
	gdb-csl-symbian-6_4_50_20060226-9:1.11
	gdb-csl-symbian-6_4_50_20060226-8:1.11
	gdb-csl-coldfire-4_1-11:1.11
	gdb-csl-sourcerygxx-3_4_4-19:1.11
	gdb-csl-coldfire-4_1-10:1.11
	gdb_6_5-branch:1.11.0.28
	gdb_6_5-2006-05-14-branchpoint:1.11
	gdb-csl-sourcerygxx-4_1-5:1.11
	nickrob-async-20060513-branch:1.11.0.26
	nickrob-async-20060513-branchpoint:1.11
	gdb-csl-sourcerygxx-4_1-4:1.11
	msnyder-reverse-20060502-branch:1.11.0.24
	msnyder-reverse-20060502-branchpoint:1.11
	gdb-csl-morpho-4_1-4:1.11
	gdb-csl-sourcerygxx-3_4_4-17:1.11
	readline_5_1-import-branch:1.11.0.22
	readline_5_1-import-branchpoint:1.11
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.11
	gdb-csl-symbian-20060226-branch:1.11.0.20
	gdb-csl-symbian-20060226-branchpoint:1.11
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.11
	msnyder-reverse-20060331-branch:1.11.0.18
	msnyder-reverse-20060331-branchpoint:1.11
	gdb-csl-available-20060303-branch:1.11.0.16
	gdb-csl-available-20060303-branchpoint:1.11
	gdb-csl-20060226-branch:1.11.0.14
	gdb-csl-20060226-branchpoint:1.11
	gdb_6_4-20051202-release:1.11
	msnyder-fork-checkpoint-branch:1.11.0.12
	msnyder-fork-checkpoint-branchpoint:1.11
	gdb-csl-gxxpro-6_3-branch:1.11.0.10
	gdb-csl-gxxpro-6_3-branchpoint:1.11
	gdb_6_4-branch:1.11.0.8
	gdb_6_4-2005-11-01-branchpoint:1.11
	gdb-csl-arm-20051020-branch:1.11.0.6
	gdb-csl-arm-20051020-branchpoint:1.11
	gdb-csl-arm-20050325-2005-q1b:1.11
	gdb-csl-arm-20050325-2005-q1a:1.11
	csl-arm-20050325-branch:1.11.0.4
	csl-arm-20050325-branchpoint:1.11
	gdb-post-i18n-errorwarning-20050211:1.11
	gdb-pre-i18n-errorwarning-20050211:1.11
	gdb_6_3-20041109-release:1.11
	gdb_6_3-branch:1.11.0.2
	gdb_6_3-20041019-branchpoint:1.11
	drow_intercu-merge-20040921:1.11
	drow_intercu-merge-20040915:1.11
	jimb-gdb_6_2-e500-branch:1.9.0.16
	jimb-gdb_6_2-e500-branchpoint:1.9
	gdb_6_2-20040730-release:1.9
	gdb_6_2-branch:1.9.0.12
	gdb_6_2-2004-07-10-gmt-branchpoint:1.9
	gdb_6_1_1-20040616-release:1.9
	gdb_6_1-2004-04-05-release:1.9
	drow_intercu-merge-20040402:1.9
	drow_intercu-merge-20040327:1.9
	ezannoni_pie-20040323-branch:1.9.0.10
	ezannoni_pie-20040323-branchpoint:1.9
	cagney_tramp-20040321-mergepoint:1.9
	cagney_tramp-20040309-branch:1.9.0.8
	cagney_tramp-20040309-branchpoint:1.9
	gdb_6_1-branch:1.9.0.6
	gdb_6_1-2004-03-01-gmt-branchpoint:1.9
	drow_intercu-20040221-branch:1.9.0.4
	drow_intercu-20040221-branchpoint:1.9
	cagney_bfdfile-20040213-branch:1.9.0.2
	cagney_bfdfile-20040213-branchpoint:1.9
	drow-cplus-merge-20040208:1.8
	carlton_dictionary-20040126-merge:1.7
	cagney_bigcore-20040122-branch:1.7.0.2
	cagney_bigcore-20040122-branchpoint:1.7
	drow-cplus-merge-20040113:1.7
	drow-cplus-merge-20031224:1.2
	drow-cplus-merge-20031220:1.2
	carlton_dictionary-20031215-merge:1.2
	drow-cplus-branch:1.2.0.2
	drow-cplus-merge-20031214:1.2
	carlton-dictionary-20031111-merge:1.1
	gdb_6_0-2003-10-04-release:1.1.2.1
	kettenis_sparc-20030918-branch:1.1.0.8
	kettenis_sparc-20030918-branchpoint:1.1
	carlton_dictionary-20030917-merge:1.1
	ezannoni_pie-20030916-branchpoint:1.1
	ezannoni_pie-20030916-branch:1.1.0.6
	carlton_dictionary-branch:1.1.0.4
	gdb_6_0-branch:1.1.0.2;
locks; strict;
comment	@# @;


1.30
date	2013.06.05.20.38.37;	author luisgpm;	state Exp;
branches;
next	1.29;

1.29
date	2013.01.01.06.33.27;	author brobecke;	state Exp;
branches;
next	1.28;

1.28
date	2012.11.12.17.08.09;	author tromey;	state Exp;
branches;
next	1.27;

1.27
date	2012.07.10.15.18.18;	author tromey;	state Exp;
branches;
next	1.26;

1.26
date	2012.03.15.15.43.18;	author tromey;	state Exp;
branches;
next	1.25;

1.25
date	2012.01.16.16.21.45;	author palves;	state Exp;
branches;
next	1.24;

1.24
date	2012.01.04.08.17.47;	author brobecke;	state Exp;
branches;
next	1.23;

1.23
date	2011.01.01.15.33.44;	author brobecke;	state Exp;
branches
	1.23.4.1;
next	1.22;

1.22
date	2010.06.03.23.54.18;	author msnyder;	state Exp;
branches;
next	1.21;

1.21
date	2010.05.05.18.06.58;	author brobecke;	state Exp;
branches;
next	1.20;

1.20
date	2010.01.01.07.32.02;	author brobecke;	state Exp;
branches;
next	1.19;

1.19
date	2009.11.13.22.28.54;	author drow;	state Exp;
branches;
next	1.18;

1.18
date	2009.01.03.05.58.04;	author brobecke;	state Exp;
branches;
next	1.17;

1.17
date	2008.01.01.22.53.19;	author drow;	state Exp;
branches;
next	1.16;

1.16
date	2007.08.23.18.14.17;	author brobecke;	state Exp;
branches;
next	1.15;

1.15
date	2007.05.07.11.49.05;	author drow;	state Exp;
branches;
next	1.14;

1.14
date	2007.01.09.17.59.12;	author drow;	state Exp;
branches;
next	1.13;

1.13
date	2007.01.03.18.05.45;	author drow;	state Exp;
branches;
next	1.12;

1.12
date	2006.08.10.05.27.20;	author brobecke;	state Exp;
branches;
next	1.11;

1.11
date	2004.08.09.22.47.49;	author chastain;	state Exp;
branches
	1.11.26.1;
next	1.10;

1.10
date	2004.07.31.10.48.01;	author chastain;	state Exp;
branches;
next	1.9;

1.9
date	2004.02.11.14.01.25;	author chastain;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	2004.02.04.04.18.45;	author chastain;	state Exp;
branches;
next	1.7;

1.7
date	2004.01.11.08.14.49;	author chastain;	state Exp;
branches;
next	1.6;

1.6
date	2004.01.09.04.57.09;	author chastain;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.02.04.46.45;	author chastain;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.01.23.05.12;	author chastain;	state Exp;
branches;
next	1.3;

1.3
date	2004.01.01.02.30.59;	author chastain;	state Exp;
branches;
next	1.2;

1.2
date	2003.11.23.18.24.46;	author chastain;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2003.08.23.03.55.59;	author chastain;	state Exp;
branches
	1.1.2.1
	1.1.4.1
	1.1.6.1;
next	;

1.23.4.1
date	2012.01.06.04.44.05;	author brobecke;	state Exp;
branches;
next	;

1.11.26.1
date	2006.08.28.07.48.42;	author nickrob;	state Exp;
branches;
next	;

1.9.4.1
date	2004.09.16.17.01.43;	author drow;	state Exp;
branches;
next	;

1.2.2.1
date	2003.12.14.20.27.54;	author drow;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2004.01.13.16.12.12;	author drow;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2004.02.09.19.43.55;	author drow;	state Exp;
branches;
next	;

1.1.2.1
date	2003.08.25.03.53.48;	author chastain;	state Exp;
branches;
next	;

1.1.4.1
date	2003.08.30.03.40.35;	author chastain;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2003.12.16.00.01.03;	author carlton;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2004.01.26.19.11.43;	author carlton;	state Exp;
branches;
next	;

1.1.6.1
date	2004.03.23.20.12.33;	author ezannoni;	state Exp;
branches;
next	;


desc
@@


1.30
log
@	* gdb.cp/virtfunc.exp (make_one_vtable_result): Handle extra output
	from targets that use function descriptors in the virtual tables.
	Handle presence of dot symbols.
@
text
@# Copyright 1992-2013 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# This file was written by Fred Fish. (fnf@@cygnus.com)
# And rewritten by Michael Chastain <mec.gnu@@mindspring.com>.

set nl		"\[\r\n\]+"

if { [skip_cplus_tests] } { continue }

load_lib "cp-support.exp"

standard_testfile .cc

if {[prepare_for_testing $testfile.exp $testfile $srcfile {debug c++}]} {
    return -1
}

proc test_ptype_of_classes {} {

    # class VA

    cp_test_ptype_class \
	"VA" "" "class" "VA" \
	{
	    { field public "int va;" }
	}

    # class VB

    cp_test_ptype_class \
	"VB" "" "class" "VB" \
	{
	    { field  public "int vb;" }
	    { method public "int fvb();" }
	    { method public "virtual int vvb();" }
	}

    # class V

    cp_test_ptype_class \
	"V" "" "class" "V" \
	{
	    { base          "public VA" }
	    { base          "public VB" }
	    { field  public "int w;" }
	    { method public "int f();" }
	    { method public "virtual int vv();" }
	}

    # class A

    cp_test_ptype_class \
	"A" "" "class" "A" \
	{
	    { base           "public virtual V" }
	    { vbase          "V" }
	    { field  private "int a;" }
	    { method public  "virtual int f();" }
	}

    # class B

    cp_test_ptype_class \
	"B" "" "class" "B" \
	{
	    { base           "public A" }
	    { field  private "int b;" }
	    { method public  "virtual int f();" }
	}

    # class C

    cp_test_ptype_class \
	"C" "" "class" "C" \
	{
	    { base         "public virtual V" }
	    { vbase        "V" }
	    { field public "int c;" }
	}

    # class AD

    cp_test_ptype_class \
	"AD" "" "class" "AD" \
	{
	    { method public "virtual int vg();" }
	}

    # class D

    cp_test_ptype_class \
	"D" "" "class" "D" \
	{
	    { base          "public AD" }
	    { base          "public virtual V" }
	    { vbase         "V" }
	    { method public "static void s();" }
	    { method public "virtual int vg();" }
	    { method public "virtual int vd();" }
	    { method public "int fd();" }
	    { field  public "int d;" }
	}

    # class E

    cp_test_ptype_class \
	"E" "" "class" "E" \
	{
	    { base          "public B" }
	    { base          "public virtual V" }
	    { base          "public D" }
	    { base          "public C" }
	    { vbase         "V" }
	    { method public "virtual int f();" }
	    { method public "virtual int vg();" }
	    { method public "virtual int vv();" }
	    { field  public "int e;" }
	}

    # An instance of D

    cp_test_ptype_class "dd" "" "class" "D" ibid

    # An instance of D *

    cp_test_ptype_class "ppd" "" "class" "D" ibid "*"

    # An instance of AD *
    # TODO: this should be named pADd, not pAd.

    cp_test_ptype_class "pAd" "" "class" "AD" ibid "*"

    # Instances of these classes.

    cp_test_ptype_class "a" "" "class" "A" ibid
    cp_test_ptype_class "b" "" "class" "B" ibid
    cp_test_ptype_class "c" "" "class" "C" ibid
    cp_test_ptype_class "d" "" "class" "D" ibid
    cp_test_ptype_class "e" "" "class" "E" ibid
    cp_test_ptype_class "v" "" "class" "V" ibid
    cp_test_ptype_class "vb" "" "class" "VB" ibid

    # Instances of pointers to these classes.

    cp_test_ptype_class "pAa" "" "class" "A" ibid "*"
    cp_test_ptype_class "pAe" "" "class" "A" ibid "*"
    cp_test_ptype_class "pBe" "" "class" "B" ibid "*"
    cp_test_ptype_class "pDd" "" "class" "D" ibid "*"
    cp_test_ptype_class "pDe" "" "class" "D" ibid "*"
    cp_test_ptype_class "pVa" "" "class" "V" ibid "*"
    cp_test_ptype_class "pVv" "" "class" "V" ibid "*"
    cp_test_ptype_class "pVe" "" "class" "V" ibid "*"
    cp_test_ptype_class "pVd" "" "class" "V" ibid "*"
    cp_test_ptype_class "pADe" "" "class" "AD" ibid "*"
    cp_test_ptype_class "pEe" "" "class" "E" ibid "*"
    cp_test_ptype_class "pVB" "" "class" "VB" ibid "*"

}

# Call virtual functions.

proc test_virtual_calls {} {
    global gdb_prompt
    global nl

    if [target_info exists gdb,cannot_call_functions] {
	setup_xfail "*-*-*" 2416
	fail "This target can not call functions"
	return 0
    }

    gdb_test "print pAe->f()"   "\\$\[0-9\]+ = 20"
    gdb_test "print pAa->f()"   "\\$\[0-9\]+ = 1"
    gdb_test "print pDe->vg()"  "\\$\[0-9\]+ = 202"
    gdb_test "print pADe->vg()" "\\$\[0-9\]+ = 202"
    gdb_test "print pDd->vg()"  "\\$\[0-9\]+ = 101"
    gdb_test "print pEe->vvb()" "\\$\[0-9\]+ = 411"
    gdb_test "print pVB->vvb()" "\\$\[0-9\]+ = 407"
    gdb_test "print pBe->vvb()" "\\$\[0-9\]+ = 411"
    gdb_test "print pDe->vvb()" "\\$\[0-9\]+ = 411"
    gdb_test "print pEe->vd()"  "\\$\[0-9\]+ = 282"
    gdb_test "print pEe->fvb()" "\\$\[0-9\]+ = 311"

    # more recent results:
    # wrong value "202"
    #   gcc 2.95.3 -gdwarf-2
    #   gcc 2.95.3 -gstabs+
    # attempt to take addres of value not located in memory
    #   gcc 3.3.2 -gdwarf-2
    #   gcc 3.3.2 -gstabs+
    #
    # -- chastain 2003-12-31

    gdb_test_multiple "print pEe->D::vg()" "print pEe->D::vg()" {
	-re "\\$\[0-9]+ = 102$nl$gdb_prompt $" {
	    pass "print pEe->D::vg()"
	}
	-re "\\$\[0-9]+ = 202$nl$gdb_prompt $" {
	    # To get this result, we have called pEe->*(&D::vg) ().
	    # That's how GDB interprets this, but it's wrong; in fact
	    # the explicit D:: means to bypass virtual function lookup,
	    # and call D::vg as if it were non-virtual.  We still have
	    # to e.g. adjust "this", though.
	    kfail "gdb/1064" "print pEe->D::vg()"
	}
	-re "Attempt to take address of value not located in memory.$nl$gdb_prompt $" {
	    kfail "gdb/1064" "print pEe->D::vg()"
	}
    }
}

# A helper proc that creates a regular expression matching a
# particular vtable.  NAME is the type name.  Each element of ARGS is
# the name of a function in the vtable.

proc make_one_vtable_result {name args} {
    global hex

    set nls "\[\r\n\]+"

    set result "vtable for '${name}' @@ $hex .subobject @@ $hex.:$nls"
    set count 0
    foreach func $args {
	append result ".${count}.:( @@$hex:)? $hex <(\.)?$func..>${nls}"
	incr count
    }

    return $result
}

# Test "info vtbl".

proc test_info_vtbl {} {
    global hex

    set nls "\[\r\n\]+"

    set vt_A [make_one_vtable_result A A::f]
    set vt_B [make_one_vtable_result B B::f]
    set vt_V [make_one_vtable_result V VB::vvb V::vv]
    set vt_V2 [make_one_vtable_result V VB::vvb "virtual thunk to E::vv"]
    set vt_D [make_one_vtable_result D D::vg D::vd]
    set vt_D2 [make_one_vtable_result D "non-virtual thunk to E::vg" D::vd]
    set vt_E [make_one_vtable_result E E::f E::vg E::vv]

    gdb_test "info vtbl a" "${vt_A}${vt_V}"
    gdb_test "info vtbl b" "${vt_B}${vt_V}"
    gdb_test "info vtbl c" "${vt_V}"
    gdb_test "info vtbl d" "${vt_D}${vt_V}"
    gdb_test "info vtbl e" "${vt_E}${vt_D2}${vt_V2}"
    gdb_test "info vtbl pEe" "${vt_E}${vt_D2}${vt_V2}"

    gdb_test "info vtbl" "Argument required.*"
    gdb_test "info vtbl va" \
	"This object does not have a virtual function table.*"
    gdb_test "info vtbl all_count" \
	"This object does not have a virtual function table.*"
}

proc do_tests {} {
    gdb_test_no_output "set language c++" ""
    gdb_test_no_output "set width 0" ""

    if ![runto_main] then {
	perror "couldn't run to breakpoint"
	return
    }
    test_ptype_of_classes
    test_info_vtbl

    gdb_breakpoint test_calls
    gdb_test "continue" ".*Breakpoint .* test_calls.*" ""
    test_virtual_calls

    gdb_test "next" ".*pAa->f.*" "next to pAa->f call"
    gdb_test "next" ".*pDe->vg.*" "next to pDe->vg call"
    gdb_test "step" ".*E::vg.*" "step through thunk into E::vg"
}

do_tests
@


1.29
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d237 1
a237 1
	append result ".${count}.: $hex <$func..>${nls}"
@


1.28
log
@	* gdb.cp/classes.exp (test_ptype_class_objects): Remove
	"ptype" from calls to cp_test_ptype_class.
	(test_enums): Likewise.
	* gdb.cp/derivation.exp: Remove "ptype" from calls to
	cp_test_ptype_class.
	* gdb.cp/inherit.exp (test_ptype_si): Remove "ptype" from
	calls to cp_test_ptype_class.
	(test_ptype_mi, test_ptype_vi, test_ptype_mvi): Likewise.
	* gdb.cp/virtfunc.exp (test_ptype_of_classes): Remove "ptype"
	from calls to cp_test_ptype_class.
	* lib/cp-support.exp (cp_test_ptype_class): Supply "ptype"
	command here.  Change "in_command" argument to "in_exp".
@
text
@d1 1
a1 2
# Copyright 1992, 1994-1999, 2001-2004, 2006-2012 Free Software
# Foundation, Inc.
@


1.27
log
@	* gdb.cp/abstract-origin.exp: Use standard_testfile.
	* gdb.cp/ambiguous.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/annota2.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/annota3.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/anon-ns.exp: Use standard_testfile.
	* gdb.cp/anon-struct.exp: Use standard_testfile.
	* gdb.cp/anon-union.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/arg-reference.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/bool.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/breakpoint.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/bs15503.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/call-c.exp: Use standard_testfile, clean_restart,
	standard_output_file.
	* gdb.cp/casts.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/class2.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/classes.exp: Use standard_testfile, prepare_for_testing.
	(test_static_members): Update.
	* gdb.cp/cmpd-minsyms.exp: Use standard_testfile.
	* gdb.cp/converts.exp: Use standard_testfile.
	* gdb.cp/cp-relocate.exp: Use standard_testfile.
	* gdb.cp/cpcompletion.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/cpexprs.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/cplabel.exp: Use standard_testfile.
	* gdb.cp/cplusfuncs.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/ctti.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/derivation.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/destrprint.exp: Use standard_testfile.
	* gdb.cp/dispcxx.exp: Use standard_testfile.
	* gdb.cp/exception.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/expand-psymtabs-cxx.exp: Use standard_testfile.
	* gdb.cp/extern-c.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/formatted-ref.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/fpointer.exp: Use standard_testfile.
	* gdb.cp/gdb1355.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/gdb2384.exp: Use standard_testfile, clean_restart,
	standard_output_file.
	* gdb.cp/gdb2495.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/hang.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/infcall-dlopen.exp: Use standard_testfile,
	standard_output_file.
	* gdb.cp/inherit.exp: Use standard_testfile, prepare_for_testing.
	(do_tests): Update.
	* gdb.cp/koenig.exp: Use standard_testfile.
	* gdb.cp/local.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/m-data.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/m-static.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/mb-ctor.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/mb-inline.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/mb-templates.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/member-ptr.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/meth-typedefs.exp: Use standard_testfile.
	* gdb.cp/method.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/method2.exp: Use standard_testfile.
	* gdb.cp/minsym-fallback.exp: Use standard_testfile,
	standard_output_file.
	* gdb.cp/misc.exp: Use standard_testfile, prepare_for_testing.
	(do_tests): Update.
	* gdb.cp/namespace-enum.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/namespace-nested-import.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/namespace.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/nextoverthrow.exp: Use standard_testfile.
	* gdb.cp/no-dmgl-verbose.exp: Use standard_testfile.
	* gdb.cp/nsdecl.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/nsimport.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/nsnested.exp: Use standard_testfile.
	* gdb.cp/nsnoimports.exp: Use standard_testfile.
	* gdb.cp/nsrecurs.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/nsstress.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/nsusing.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/operator.exp: Use standard_testfile.
	* gdb.cp/oranking.exp: Use standard_testfile.
	* gdb.cp/overload-const.exp: Use standard_testfile.
	* gdb.cp/overload.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/ovldbreak.exp: Use standard_testfile.
	* gdb.cp/ovsrch.exp: Use standard_testfile.
	* gdb.cp/paren-type.exp: Use standard_testfile.
	* gdb.cp/pass-by-ref.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/pr-1023.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/pr-1210.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/pr-574.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/pr10687.exp: Use standard_testfile, clean_restart.
	* gdb.cp/pr10728.exp: Use standard_testfile,
	standard_output_file.
	* gdb.cp/pr12028.exp: Use standard_testfile.
	* gdb.cp/pr9067.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/pr9167.exp: Use standard_testfile.
	* gdb.cp/pr9631.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/printmethod.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/psmang.exp: Use standard_testfile, clean_restart.
	* gdb.cp/psymtab-parameter.exp: Use standard_testfile.
	* gdb.cp/ptype-cv-cp.exp: Use standard_testfile.
	* gdb.cp/re-set-overloaded.exp: Use standard_testfile,
	standard_output_file.
	* gdb.cp/readnow-language.exp: Use standard_testfile.
	* gdb.cp/ref-params.exp: Use standard_testfile, build_executable.
	(gdb_start_again): Use clean_restart.
	* gdb.cp/ref-types.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/rtti.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/shadow.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/smartp.exp: Use standard_testfile.
	* gdb.cp/static-method.exp: Use standard_testfile.
	* gdb.cp/static-print-quit.exp: Use standard_testfile.
	* gdb.cp/temargs.exp: Use standard_testfile.
	* gdb.cp/templates.exp: Use standard_testfile,
	prepare_for_testing.
	(do_tests): Update.
	* gdb.cp/try_catch.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/typedef-operator.exp: Use standard_testfile.
	* gdb.cp/userdef.exp: Use standard_testfile, prepare_for_testing.
	* gdb.cp/virtbase.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.cp/virtfunc.exp: Use standard_testfile,
	prepare_for_testing.
	(do_tests): Update.
	* gdb.cp/virtfunc2.exp: Use standard_testfile,
	prepare_for_testing.
@
text
@d37 1
a37 1
	"ptype VA" "" "class" "VA" \
d45 1
a45 1
	"ptype VB" "" "class" "VB" \
d55 1
a55 1
	"ptype V" "" "class" "V" \
d67 1
a67 1
	"ptype A" "" "class" "A" \
d78 1
a78 1
	"ptype B" "" "class" "B" \
d88 1
a88 1
	"ptype C" "" "class" "C" \
d98 1
a98 1
	"ptype AD" "" "class" "AD" \
d106 1
a106 1
	"ptype D" "" "class" "D" \
d121 1
a121 1
	"ptype E" "" "class" "E" \
d136 1
a136 1
    cp_test_ptype_class "ptype dd" "" "class" "D" ibid
d140 1
a140 1
    cp_test_ptype_class "ptype ppd" "" "class" "D" ibid "*"
d145 1
a145 1
    cp_test_ptype_class "ptype pAd" "" "class" "AD" ibid "*"
d149 7
a155 7
    cp_test_ptype_class "ptype a" "" "class" "A" ibid
    cp_test_ptype_class "ptype b" "" "class" "B" ibid
    cp_test_ptype_class "ptype c" "" "class" "C" ibid
    cp_test_ptype_class "ptype d" "" "class" "D" ibid
    cp_test_ptype_class "ptype e" "" "class" "E" ibid
    cp_test_ptype_class "ptype v" "" "class" "V" ibid
    cp_test_ptype_class "ptype vb" "" "class" "VB" ibid
d159 12
a170 12
    cp_test_ptype_class "ptype pAa" "" "class" "A" ibid "*"
    cp_test_ptype_class "ptype pAe" "" "class" "A" ibid "*"
    cp_test_ptype_class "ptype pBe" "" "class" "B" ibid "*"
    cp_test_ptype_class "ptype pDd" "" "class" "D" ibid "*"
    cp_test_ptype_class "ptype pDe" "" "class" "D" ibid "*"
    cp_test_ptype_class "ptype pVa" "" "class" "V" ibid "*"
    cp_test_ptype_class "ptype pVv" "" "class" "V" ibid "*"
    cp_test_ptype_class "ptype pVe" "" "class" "V" ibid "*"
    cp_test_ptype_class "ptype pVd" "" "class" "V" ibid "*"
    cp_test_ptype_class "ptype pADe" "" "class" "AD" ibid "*"
    cp_test_ptype_class "ptype pEe" "" "class" "E" ibid "*"
    cp_test_ptype_class "ptype pVB" "" "class" "VB" ibid "*"
@


1.26
log
@	* gnu-v3-abi.c (struct value_and_voffset): New.
	(hash_value_and_voffset, eq_value_and_voffset)
	(compare_value_and_voffset, compute_vtable_size)
	(print_one_vtable, gnuv3_print_vtable): New functions.
	(init_gnuv3_ops): Initialize 'print_vtable' field.
	* cp-support.c (info_vtbl_command): New function.
	(_initialize_cp_support): Add "info vtbl".
	* cp-abi.h (cplus_print_vtable): Declare.
	(struct cp_abi_ops) <print_vtable>: New field.
	* cp-abi.c (cplus_print_vtable): New function.
	* NEWS: Update.
gdb/testsuite
	* gdb.cp/virtfunc.exp (make_one_vtable_result): New proc.
	(test_info_vtbl): Likewise.
	(do_tests): Call test_info_vtbl.
	* gdb.cp/virtfunc.cc (va): New global.
gdb/doc
	* gdb.texinfo (Debugging C Plus Plus): Document "info vtbl".
@
text
@d26 4
a29 7
set testfile "virtfunc"
set srcfile ${testfile}.cc
set binfile ${objdir}/${subdir}/${testfile}

if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {c++ debug}] != "" } {
     untested virtfunc.exp
     return -1
a274 9
    global srcdir subdir binfile
    global gdb_prompt


    gdb_exit
    gdb_start
    gdb_reinitialize_dir $srcdir/$subdir
    gdb_load $binfile

@


1.25
log
@2012-01-16  Pedro Alves  <palves@@redhat.com>

	Remove all calls to strace.
@
text
@d229 48
d295 1
@


1.24
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@a21 4
if $tracelevel then {
    strace $tracelevel
}

@


1.23
log
@run copyright.sh for 2011.
@
text
@d1 2
a2 2
# Copyright 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2001, 2002, 2003, 2004,
# 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.23.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d1 2
a2 2
# Copyright 1992, 1994-1999, 2001-2004, 2006-2012 Free Software
# Foundation, Inc.
@


1.22
log
@2010-06-03  Michael Snyder  <msnyder@@vmware.com>

	* gdb.base/commands.exp: Replace gdb_test with gdb_test_no_output.
	* gdb.base/display.exp: Ditto.
	* gdb.base/find.exp: Ditto.
	* gdb.base/ifelse.exp: Ditto.
	* gdb.base/multi-forks.exp: Ditto.
	* gdb.base/recurse.exp: Ditto.
	* gdb.base/setshow.exp: Ditto.
	* gdb.base/value-double-free.exp: Ditto.
	* gdb.base/watch-vfork.exp: Ditto.
	* gdb.base/watch_thread_num.exp: Ditto.
	* gdb.base/watchpoint-solib.exp: Ditto.
	* gdb.base/watchpoint.exp: Ditto.
	* gdb.base/watchpoints.exp: Ditto.

	* gdb.cp/classes.exp: Replace gdb_test with gdb_test_no_output.
	* gdb.cp/overload.exp: Ditto.
	* gdb.cp/virtfunc.exp: Ditto.

	* gdb.python/py-value.exp: Replace gdb_test with gdb_test_no_output.

	* gdb.reverse/watch-precsave.exp:
	Replace gdb_test with gdb_test_no_output.

	* gdb.threads/attach-into-signal.exp:
	Replace gdb_test with gdb_test_no_output.
	* gdb.threads/local-watch-wrong-thread.exp: Ditto.
	* gdb.threads/watchthreads.exp: Ditto.
	* gdb.threads/watchthreads2.exp: Ditto.

	* gdb.trace/deltrace.exp: Replace gdb_test with gdb_test_no_output.
	* gdb.trace/tfind.exp: Ditto.
@
text
@d2 1
a2 1
# 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.21
log
@Do not set prms_id/bug_id anymore.

2010-05-05  Joel Brobecker  <brobecker@@adacore.com>

	Remove the use of prms_id and bug_id throughout the testsuite.
@
text
@d243 2
a244 2
    gdb_test "set language c++" "" ""
    gdb_test "set width 0" "" ""
@


1.20
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@a233 2
    global prms_id
    global bug_id
a236 2
    set prms_id 0
    set bug_id 0
@


1.19
log
@	gdb/testsuite/
	* gdb.cp/virtfunc.exp (do_tests): If runto_main fails, give up.
@
text
@d2 1
a2 1
# 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.18
log
@        Updated copyright notices for most files.
@
text
@d250 4
a253 1
    runto_main
@


1.17
log
@	Updated copyright notices for most files.
@
text
@d2 1
a2 1
# 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.16
log
@        Switch the license of all .exp files to GPLv3.
        Switch the license of all .f and .f90 files to GPLv3.
        Switch the license of all .s and .S files to GPLv3.
@
text
@d2 1
a2 1
# 2006, 2007 Free Software Foundation, Inc.
@


1.15
log
@	* Makefile.in (c-lang.o, gnu-v3-abi.o): Update.
	* NEWS: Mention improved C++ thunk support.
	* c-lang.c (cplus_language_defn): Mention cplus_skip_trampoline.
	* cp-abi.c (cplus_skip_trampoline): New.
	* cp-abi.h (cplus_skip_trampoline): New prototype.
	(struct cp_abi_ops): Add skip_trampoline member.
	* gnu-v3-abi.c (gnuv3_skip_trampoline): New.
	(init_gnuv3_ops): Set skip_trampoline.

	* gdb.cp/virtfunc.exp (proc do_tests): Test stepping through a thunk.
@
text
@d6 1
a6 1
# the Free Software Foundation; either version 2 of the License, or
d8 1
a8 1
# 
d13 1
a13 1
# 
d15 1
a15 2
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
@


1.14
log
@Copyright updates for 2007.
@
text
@d257 4
@


1.13
log
@	* NEWS: Mention pointer to member improvements.
	* Makefile.in (gnu-v3-abi.o): Delete special rule.
	(eval.o, gnu-v3-abi.o, ia64-tdep.o): Update.
	* ada-valprint.c (ada_print_scalar): Update for new type codes.
	* c-typeprint.c (c_print_type): Update for new type codes.
	(c_type_print_varspec_prefix, c_type_print_varspec_suffix)
	(c_type_print_base): Likewise.
	(c_type_print_args): Rewrite.
	* c-valprint.c (c_val_print): Update for new type codes.  Remove
	support for references to members.  Treat methods like functions.
	* cp-abi.c (cplus_print_method_ptr, cplus_method_ptr_size)
	(cplus_make_method_ptr, cplus_method_ptr_to_value): New.
	* cp-abi.h (cplus_print_method_ptr, cplus_method_ptr_size)
	(cplus_make_method_ptr, cplus_method_ptr_to_value): New prototypes.
	(struct cp_abi_ops): Add corresponding members.
	* cp-valprint.c (cp_print_class_method): Delete.
	(cp_find_class_member): New function.
	(cp_print_class_member): Use it.  Simplify support for bogus
	member pointers.
	* dwarf2read.c (quirk_gcc_member_function_pointer): Use
	lookup_methodptr_type.
	(read_tag_ptr_to_member_type): Likewise, and lookup_memberptr_type.
	* eval.c (evaluate_subexp_standard): Implement EVAL_SKIP for
	OP_SCOPE.  Update call to value_aggregate_elt.  Rewrite member
	pointer support.
	(evaluate_subexp_for_address): Handle OP_SCOPE explicitly.  Handle
	references returned by user defined operators.
	* f-typeprint.c (f_print_type, f_type_print_varspec_prefix)
	(f_type_print_varspec_suffix): Remove support for member pointers.
	* gdbtypes.c (lookup_memberptr_type): Renamed from lookup_member_type
	and adjusted.
	(smash_to_memberptr_type): Likewise, from smash_to_member_type.
	(lookup_methodptr_type): New.
	(rank_one_type): Adjust for TYPE_CODE_MEMBERPTR.
	(recursive_dump_type): Update for new types.
	* gdbtypes.h (enum type_code): Replace TYPE_CODE_MEMBER with
	TYPE_CODE_MEMBERPTR and TYPE_CODE_METHODPTR.
	(lookup_memberptr_type, lookup_methodptr_type)
	(smash_to_memberptr_type): New prototypes.
	(smash_to_method_type): Formatting fix.
	(lookup_member_type, smash_to_member_type): Delete prototypes.
	* gnu-v3-abi.c (gnuv3_get_vtable, gnuv3_get_virtual_fn): New.
	Do not rely on debug information for the vptr or the method's
	enclosing type.  Handle function descriptors for IA64.
	(gnuv3_virtual_fn_field): Rewrite using the new functions.
	(gnuv3_find_method_in, gnuv3_print_method_ptr)
	(gnuv3_method_ptr_size, gnuv3_make_method_ptr)
	(gnuv3_method_ptr_to_value): New.
	(init_gnuv3_ops): Set new members of gnu_v3_abi_ops.
	* hpread.c (hpread_type_lookup): Update for new types.
	* infcall.c (value_arg_coerce): Likewise.
	* m2-typeprint.c (m2_print_type): Remove explicit support
	for member pointers.
	* m2-valprint.c (m2_val_print): Likewise.
	* p-typeprint.c (pascal_type_print_varspec_prefix)
	(pascal_type_print_varspec_suffix, pascal_type_print_base): Likewise.
	* p-valprint.c (pascal_val_print): Likewise.
	(pascal_object_print_class_method, pascal_object_print_class_member):
	Delete.
	* p-lang.h (pascal_object_print_class_method)
	(pascal_object_print_class_member): Delete prototypes.
	* stabsread.c (read_type): Update for new types.
	* typeprint.c (print_type_scalar): Likewise.
	* valops.c (value_struct_elt_for_reference, value_namespace_elt)
	(value_maybe_namespace_elt, value_aggregate_elt): Add want_address
	argument.  Construct a pointer to member if the address of a
	function or data member is requested.
	(value_cast_pointers): Don't modify the input value.
	(value_cast): Adjust pointer to member handling for new types.
	Allow null pointer to member constants.  Don't modify the input
	value.
	(value_ind): Remove pointer to member check.  Handle function
	descriptors for function pointers.
	(value_struct_elt, value_find_oload_method_list, check_field):
	Remove pointer to member checks.
	* value.c (unpack_long): Allow pointers to data members.
	(value_from_longest): Allow member pointers.
	* value.h (value_aggregate_elt): Add want_address.
	* varobj.c (c_variable_editable): Remove check for members.
	* gdbarch.sh: Add vtable_function_descriptors and vbit_in_delta.
	* ia64-tdep.c (ia64_convert_from_func_ptr_addr): Handle descriptors
	in virtual tables.
	(ia64_gdbarch_init): Call set_gdbarch_vtable_function_descriptors.
	* c-lang.h (cp_print_class_method): Delete prototype.
	* arm-tdep.c (arm_gdbarch_init): Call set_gdbarch_vbit_in_delta.
	* mips-tdep.c (mips_gdbarch_init): Likewise.
	* gdbarch.c, gdbarch.h: Regenerated.

	* gdb.cp/classes.exp (test_pointers_to_class_members): Update expected
	output.  Test the types of members and member pointers.
	* gdb.cp/inherit.exp (test_print_mi_member_types): Remove KFAILs for
	gdb/2092.
	* gdb.cp/member-ptr.exp: Search for a comment instead of a
	statement.  Enable for GCC.  Update expected output for some tests
	and add new tests.  Remove obsolete GCC KFAILs.  Allow GCC's class
	layout.
	* gdb.cp/member-ptr.cc (Padding, Padding::vspacer, Base, Base::get_x)
	(Base::vget_base, Left, Left::vget, Right, Right::vget, Diamond)
	(Diamond::vget_base): New.
	(main): Add new tests.
	* gdb.cp/printmethod.exp: Update expected output for member functions.
	* gdb.cp/virtfunc.exp (test_virtual_calls): Add a KFAIL for
	print pEe->D::vg().
@
text
@d2 1
a2 2
# 2006
# Free Software Foundation, Inc.
@


1.12
log
@	* gdb.arch/altivec-abi.exp: Replace gdb_suppress_entire_file with
	untested followed by return combination.
	* gdb.arch/altivec-regs.exp: Likewise.
	* gdb.arch/e500-abi.exp: Likewise.
	* gdb.arch/e500-regs.exp: Likewise.
	* gdb.arch/gdb1291.exp: Likewise.
	* gdb.arch/gdb1431.exp: Likewise.
	* gdb.arch/gdb1558.exp: Likewise.
	* gdb.arch/i386-prologue.exp: Likewise.
	* gdb.arch/i386-unwind.exp: Likewise.
	* gdb.asm/asm-source.exp: Likewise.
	* gdb.base/a2-run.exp: Likewise.
	* gdb.base/advance.exp: Likewise.
	* gdb.base/all-bin.exp: Likewise.
	* gdb.base/annota1.exp: Likewise.
	* gdb.base/annota3.exp: Likewise.
	* gdb.base/args.exp: Likewise.
	* gdb.base/arithmet.exp: Likewise.
	* gdb.base/assign.exp: Likewise.
	* gdb.base/async.exp: Likewise.
	* gdb.base/attach.exp: Likewise.
	* gdb.base/bang.exp: Likewise.
	* gdb.base/bigcore.exp: Likewise.
	* gdb.base/bitfields.exp: Likewise.
	* gdb.base/bitfields2.exp: Likewise.
	* gdb.base/break.exp: Likewise.
	* gdb.base/call-sc.exp: Likewise.
	* gdb.base/call-strs.exp: Likewise.
	* gdb.base/callfuncs.exp: Likewise.
	* gdb.base/checkpoint.exp: Likewise.
	* gdb.base/chng-syms.exp: Likewise.
	* gdb.base/code-expr.exp: Likewise.
	* gdb.base/commands.exp: Likewise.
	* gdb.base/completion.exp: Likewise.
	* gdb.base/cond-expr.exp: Likewise.
	* gdb.base/condbreak.exp: Likewise.
	* gdb.base/consecutive.exp: Likewise.
	* gdb.base/constvars.exp: Likewise.
	* gdb.base/corefile.exp: Likewise.
	* gdb.base/cvexpr.exp: Likewise.
	* gdb.base/dbx.exp: Likewise.
	* gdb.base/define.exp: Likewise.
	* gdb.base/detach.exp: Likewise.
	* gdb.base/display.exp: Likewise.
	* gdb.base/dump.exp: Likewise.
	* gdb.base/ena-dis-br.exp: Likewise.
	* gdb.base/ending-run.exp: Likewise.
	* gdb.base/environ.exp: Likewise.
	* gdb.base/eval-skip.exp: Likewise.
	* gdb.base/exprs.exp: Likewise.
	* gdb.base/fileio.exp: Likewise.
	* gdb.base/finish.exp: Likewise.
	* gdb.base/float.exp: Likewise.
	* gdb.base/foll-exec.exp: Likewise.
	* gdb.base/foll-fork.exp: Likewise.
	* gdb.base/foll-vfork.exp: Likewise.
	* gdb.base/freebpcmd.exp: Likewise.
	* gdb.base/funcargs.exp: Likewise.
	* gdb.base/gcore.exp: Likewise.
	* gdb.base/gdb1090.exp: Likewise.
	* gdb.base/gdb1250.exp: Likewise.
	* gdb.base/huge.exp: Likewise.
	* gdb.base/info-proc.exp: Likewise.
	* gdb.base/interrupt.exp: Likewise.
	* gdb.base/jump.exp: Likewise.
	* gdb.base/langs.exp: Likewise.
	* gdb.base/lineinc.exp: Likewise.
	* gdb.base/list.exp: Likewise.
	* gdb.base/logical.exp: Likewise.
	* gdb.base/long_long.exp: Likewise.
	* gdb.base/macscp.exp: Likewise.
	* gdb.base/maint.exp: Likewise.
	* gdb.base/mips_pro.exp: Likewise.
	* gdb.base/miscexprs.exp: Likewise.
	* gdb.base/multi-forks.exp: Likewise.
	* gdb.base/opaque.exp: Likewise.
	* gdb.base/overlays.exp: Likewise.
	* gdb.base/pc-fp.exp: Likewise.
	* gdb.base/pointers.exp: Likewise.
	* gdb.base/printcmds.exp: Likewise.
	* gdb.base/psymtab.exp: Likewise.
	* gdb.base/ptype.exp: Likewise.
	* gdb.base/recurse.exp: Likewise.
	* gdb.base/relational.exp: Likewise.
	* gdb.base/relocate.exp: Likewise.
	* gdb.base/remote.exp: Likewise.
	* gdb.base/reread.exp: Likewise.
	* gdb.base/restore.exp: Likewise.
	* gdb.base/return.exp: Likewise.
	* gdb.base/return2.exp: Likewise.
	* gdb.base/scope.exp: Likewise.
	* gdb.base/sect-cmd.exp: Likewise.
	* gdb.base/sep.exp: Likewise.
	* gdb.base/sepdebug.exp: Likewise.
	* gdb.base/setshow.exp: Likewise.
	* gdb.base/setvar.exp: Likewise.
	* gdb.base/sigall.exp: Likewise.
	* gdb.base/sigbpt.exp: Likewise.
	* gdb.base/signals.exp: Likewise.
	* gdb.base/signull.exp: Likewise.
	* gdb.base/sizeof.exp: Likewise.
	* gdb.base/solib.exp: Likewise.
	* gdb.base/step-line.exp: Likewise.
	* gdb.base/step-test.exp: Likewise.
	* gdb.base/structs.exp: Likewise.
	* gdb.base/structs2.exp: Likewise.
	* gdb.base/term.exp: Likewise.
	* gdb.base/twice.exp: Likewise.
	* gdb.base/until.exp: Likewise.
	* gdb.base/varargs.exp: Likewise.
	* gdb.base/volatile.exp: Likewise.
	* gdb.base/watchpoint.exp: Likewise.
	* gdb.base/whatis-exp.exp: Likewise.
	* gdb.base/whatis.exp: Likewise.
	* gdb.cp/ambiguous.exp: Likewise.
	* gdb.cp/annota2.exp: Likewise.
	* gdb.cp/annota3.exp: Likewise.
	* gdb.cp/bool.exp: Likewise.
	* gdb.cp/breakpoint.exp: Likewise.
	* gdb.cp/casts.exp: Likewise.
	* gdb.cp/class2.exp: Likewise.
	* gdb.cp/classes.exp: Likewise.
	* gdb.cp/cplusfuncs.exp: Likewise.
	* gdb.cp/ctti.exp: Likewise.
	* gdb.cp/derivation.exp: Likewise.
	* gdb.cp/exception.exp: Likewise.
	* gdb.cp/gdb1355.exp: Likewise.
	* gdb.cp/hang.exp: Likewise.
	* gdb.cp/inherit.exp: Likewise.
	* gdb.cp/local.exp: Likewise.
	* gdb.cp/m-data.exp: Likewise.
	* gdb.cp/m-static.exp: Likewise.
	* gdb.cp/member-ptr.exp: Likewise.
	* gdb.cp/method.exp: Likewise.
	* gdb.cp/misc.exp: Likewise.
	* gdb.cp/namespace.exp: Likewise.
	* gdb.cp/overload.exp: Likewise.
	* gdb.cp/ovldbreak.exp: Likewise.
	* gdb.cp/pr-1023.exp: Likewise.
	* gdb.cp/pr-1210.exp: Likewise.
	* gdb.cp/pr-574.exp: Likewise.
	* gdb.cp/printmethod.exp: Likewise.
	* gdb.cp/psmang.exp: Likewise.
	* gdb.cp/ref-params.exp: Likewise.
	* gdb.cp/ref-types.exp: Likewise.
	* gdb.cp/rtti.exp: Likewise.
	* gdb.cp/templates.exp: Likewise.
	* gdb.cp/try_catch.exp: Likewise.
	* gdb.cp/userdef.exp: Likewise.
	* gdb.cp/virtfunc.exp: Likewise.
	* gdb.disasm/am33.exp: Likewise.
	* gdb.disasm/h8300s.exp: Likewise.
	* gdb.disasm/mn10300.exp: Likewise.
	* gdb.disasm/sh3.exp: Likewise.
	* gdb.disasm/t01_mov.exp: Likewise.
	* gdb.disasm/t02_mova.exp: Likewise.
	* gdb.disasm/t03_add.exp: Likewise.
	* gdb.disasm/t04_sub.exp: Likewise.
	* gdb.disasm/t05_cmp.exp: Likewise.
	* gdb.disasm/t06_ari2.exp: Likewise.
	* gdb.disasm/t07_ari3.exp: Likewise.
	* gdb.disasm/t08_or.exp: Likewise.
	* gdb.disasm/t09_xor.exp: Likewise.
	* gdb.disasm/t10_and.exp: Likewise.
	* gdb.disasm/t11_logs.exp: Likewise.
	* gdb.disasm/t12_bit.exp: Likewise.
	* gdb.disasm/t13_otr.exp: Likewise.
	* gdb.hp/gdb.aCC/optimize.exp: Likewise.
	* gdb.hp/gdb.aCC/watch-cmd.exp: Likewise.
	* gdb.hp/gdb.base-hp/callfwmall.exp: Likewise.
	* gdb.hp/gdb.base-hp/dollar.exp: Likewise.
	* gdb.hp/gdb.base-hp/hwwatchbus.exp: Likewise.
	* gdb.hp/gdb.base-hp/pxdb.exp: Likewise.
	* gdb.hp/gdb.base-hp/reg-pa64.exp: Likewise.
	* gdb.hp/gdb.base-hp/reg.exp: Likewise.
	* gdb.hp/gdb.base-hp/sized-enum.exp: Likewise.
	* gdb.hp/gdb.compat/xdb1.exp: Likewise.
	* gdb.hp/gdb.compat/xdb3.exp: Likewise.
	* gdb.hp/gdb.objdbg/objdbg01.exp: Likewise.
	* gdb.hp/gdb.objdbg/objdbg02.exp: Likewise.
	* gdb.hp/gdb.objdbg/objdbg03.exp: Likewise.
	* gdb.hp/gdb.objdbg/objdbg04.exp: Likewise.
	* gdb.mi/gdb701.exp: Likewise.
	* gdb.mi/gdb792.exp: Likewise.
	* gdb.mi/mi-basics.exp: Likewise.
	* gdb.mi/mi-break.exp: Likewise.
	* gdb.mi/mi-cli.exp: Likewise.
	* gdb.mi/mi-console.exp: Likewise.
	* gdb.mi/mi-disassemble.exp: Likewise.
	* gdb.mi/mi-eval.exp: Likewise.
	* gdb.mi/mi-file.exp: Likewise.
	* gdb.mi/mi-read-memory.exp: Likewise.
	* gdb.mi/mi-regs.exp: Likewise.
	* gdb.mi/mi-return.exp: Likewise.
	* gdb.mi/mi-simplerun.exp: Likewise.
	* gdb.mi/mi-stack.exp: Likewise.
	* gdb.mi/mi-stepi.exp: Likewise.
	* gdb.mi/mi-syn-frame.exp: Likewise.
	* gdb.mi/mi-until.exp: Likewise.
	* gdb.mi/mi-var-block.exp: Likewise.
	* gdb.mi/mi-var-child.exp: Likewise.
	* gdb.mi/mi-var-cmd.exp: Likewise.
	* gdb.mi/mi-var-display.exp: Likewise.
	* gdb.mi/mi-watch.exp: Likewise.
	* gdb.mi/mi2-basics.exp: Likewise.
	* gdb.mi/mi2-break.exp: Likewise.
	* gdb.mi/mi2-cli.exp: Likewise.
	* gdb.mi/mi2-console.exp: Likewise.
	* gdb.mi/mi2-disassemble.exp: Likewise.
	* gdb.mi/mi2-eval.exp: Likewise.
	* gdb.mi/mi2-file.exp: Likewise.
	* gdb.mi/mi2-read-memory.exp: Likewise.
	* gdb.mi/mi2-regs.exp: Likewise.
	* gdb.mi/mi2-return.exp: Likewise.
	* gdb.mi/mi2-simplerun.exp: Likewise.
	* gdb.mi/mi2-stack.exp: Likewise.
	* gdb.mi/mi2-stepi.exp: Likewise.
	* gdb.mi/mi2-syn-frame.exp: Likewise.
	* gdb.mi/mi2-until.exp: Likewise.
	* gdb.mi/mi2-var-block.exp: Likewise.
	* gdb.mi/mi2-var-child.exp: Likewise.
	* gdb.mi/mi2-var-cmd.exp: Likewise.
	* gdb.mi/mi2-var-display.exp: Likewise.
	* gdb.mi/mi2-watch.exp: Likewise.
	* gdb.stabs/exclfwd.exp: Likewise.
	* gdb.stabs/weird.exp: Likewise.
	* gdb.threads/gcore-thread.exp: Likewise.
	* gdb.trace/actions.exp: Likewise.
	* gdb.trace/backtrace.exp: Likewise.
	* gdb.trace/circ.exp: Likewise.
	* gdb.trace/collection.exp: Likewise.
	* gdb.trace/deltrace.exp: Likewise.
	* gdb.trace/infotrace.exp: Likewise.
	* gdb.trace/limits.exp: Likewise.
	* gdb.trace/packetlen.exp: Likewise.
	* gdb.trace/passc-dyn.exp: Likewise.
	* gdb.trace/passcount.exp: Likewise.
	* gdb.trace/report.exp: Likewise.
	* gdb.trace/save-trace.exp: Likewise.
	* gdb.trace/tfind.exp: Likewise.
	* gdb.trace/tracecmd.exp: Likewise.
	* gdb.trace/while-dyn.exp: Likewise.
	* gdb.trace/while-stepping.exp: Likewise.
@
text
@d1 2
a2 1
# Copyright 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2001, 2002, 2003, 2004
d221 8
@


1.11
log
@2004-08-09  Michael Chastain  <mec.gnu@@mindspring.com>

	* lib/cp-support.exp: New file.
	* lib/cp-support.exp (cp_test_type_class): New function.
	* gdb.cp/derivation.exp: Use cp_test_ptype_class.
	* gdb.cp/virtfunc.exp (test_one_ptype): Removed.
	* gdb.cp/virtfunc.exp (test_ptype_of_classes): Use
	cp_test_ptype_class.
@
text
@d36 2
a37 1
     gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
@


1.11.26.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@d36 1
a36 2
     untested virtfunc.exp
     return -1
@


1.10
log
@2004-07-31  Michael Chastain  <mec.gnu@@mindspring.com>

	* gdb.cp/virtfunc.exp: Accept more varieties of ptype output.
@
text
@a20 2
set wsopt	"\[\r\n\t \]*"
set ws		"\[\r\n\t \]+"
d29 2
a38 91
# Test ptype of a class.
#
# Different C++ compilers produce different output.  I build up regular
# expressions piece by piece to accommodate all the compilers that I
# have seen: gcc 2.95.3, gcc 3.3.2 (ABI 1), gcc 3.4 prerelease (ABI 2);
# and all the debug formats I have seen: dwarf-2 and stabs+.
#
# A complicated class declaration looks like this:
#
#   class A : public virtual V {	// re_class
#     private:
#       V * _vb$V;			// re_vbptr
#       int a;				// re_fields
#
#     public:				// re_access_methods
#       A & operator=(A const &);	// re_synth_gcc_2
#       A(int, A const &);		// ...
#       A(int);				// ...
#       virtual int f(void);		// re_methods
#   }
#
# RE_CLASS matches the class declaration.  C++ allows multiple ways of
# expressing this.
#
#   struct ... { private: ... };
#   class ... { private: ... };
#   class ... { ... };
#
# RE_VBPTR matches the virtual base declarations.  gcc 2.95.3 sometimes
# emits these, but gcc 3.X.Y never emits these.  The name depends on the
# debug format.
#
# RE_FIELDS matches the data fields of the class.
# RE_METHODS matches the methods explicitly declared for the class.
#
# RE_SYNTH_GCC_2 and RE_SYNTH_GCC_3 match the optional synthetic methods
# of the class.  gcc -gstabs+ emits these methods, and gcc -gdwarf-2
# does not.
#
# RE_ACCESS_METHODS is an access specifier after RE_FIELDS and before
# the methods (explicit methods and/or synthetic methods).
# There is also an RE_ACCESS_FIELDS.
#
# When I get HP-UX aCC, I hope that I can just add RE_SYNTH_ACC_NNN.
#
# Yet another twist: with gcc v2, ctor and dtor methods have a hidden
# argument in front, the "in-charge" flag.  With gcc v3, there is no
# hidden argument; instead, there are multiple object functions for
# each ctor and dtor.
#
# -- chastain 2004-01-01

proc test_one_ptype { command testname re_class re_vbptr re_access_fields re_fields re_access_methods re_methods re_synth_gcc_2 re_synth_gcc_3 re_star } {
    global gdb_prompt
    global wsopt
    global ws
    global nl

    gdb_test_multiple "$command" "$testname" {
	-re "type = $re_class${wsopt}$re_access_fields${wsopt}$re_fields${wsopt}$re_access_methods${wsopt}$re_methods$nl\}$re_star$nl$gdb_prompt $" {
	    # gcc 2.95.3, dwarf-2, no vbptr
	    # gcc 3.X, abi 1, dwarf-2
	    # gcc 3.X, abi 2, dwarf-2
	    pass "$testname"
	}
	-re "type = $re_class${wsopt}$re_vbptr${wsopt}$re_access_fields${wsopt}$re_fields${wsopt}$re_access_methods${wsopt}$re_methods$nl\}$re_star$nl$gdb_prompt $" {
	    # gcc 2.95.3, dwarf-2, vbptr
	    # TODO: drow says the vbptr is a bug
	    pass "$testname"
	}
	-re "type = $re_class${wsopt}$re_access_fields${wsopt}$re_fields${wsopt}$re_access_methods${wsopt}$re_synth_gcc_2${wsopt}$re_methods$nl\}$re_star$nl$gdb_prompt $" {
	    # gcc 2.95.3, stabs+, no vbptr
	    pass "$testname"
	}
	-re "type = $re_class${wsopt}$re_vbptr${wsopt}$re_access_fields${wsopt}$re_fields${wsopt}$re_access_methods${wsopt}$re_synth_gcc_2${wsopt}$re_methods$nl\}$re_star$nl$gdb_prompt $" {
	    # gcc 2.95.3, stabs+, vbptr
	    # TODO: drow says the vbptr is a bug
	    pass "$testname"
	}
	-re "type = $re_class${wsopt}$re_access_fields${wsopt}$re_fields${wsopt}$re_access_methods${wsopt}$re_synth_gcc_3${wsopt}$re_methods$nl\}$re_star$nl$gdb_prompt $" {
	    # gcc 3.X, abi 1, stabs+
	    pass "$testname"
	}
	-re "type = $re_class${wsopt}$re_access_fields${wsopt}$re_fields${wsopt}$re_access_methods${wsopt}$re_methods${wsopt}$re_synth_gcc_3$nl\}$re_star$nl$gdb_prompt $" {
	    # gcc 3.X, abi 2, stabs+
	    pass "$testname"
	}
    }

}

a39 3
    global gdb_prompt
    global ws
    global nl
d43 5
a47 8
    test_one_ptype "ptype VA" "ptype VA" \
	"((struct|class) VA \{${ws}public:|struct VA \{)" \
	"" \
	"" "int va;" \
	"" "" \
	"VA & operator=\\(VA const ?&\\);${ws}VA\\(VA const ?&\\);${ws}VA\\((void|)\\);" \
	"(VA & operator=\\(VA const ?&\\);${ws}|)VA\\(VA const ?&\\);${ws}VA\\((void|)\\);" \
	""
d51 7
a57 8
    test_one_ptype "ptype VB" "ptype VB" \
	"((struct|class) VB \{${ws}public:|struct VB \{)" \
	"" \
	"" "int vb;" \
	"" "int fvb\\((void|)\\);${ws}virtual int vvb\\((void|)\\);" \
	"VB & operator=\\(VB const ?&\\);${ws}VB\\(VB const ?&\\);${ws}VB\\((void|)\\);" \
	"(VB & operator=\\(VB const ?&\\);${ws}|)VB\\(VB const ?&\\);${ws}VB\\((void|)\\);" \
	""
d61 9
a69 8
    test_one_ptype "ptype V" "ptype V" \
	"class V : public VA, public VB \{${ws}public:" \
	"" \
	"" "int w;" \
	"" "int f\\((void|)\\);${ws}virtual int vv\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	"(V & operator=\\(V const ?&\\);${ws}|)V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	""
d73 8
a80 8
    test_one_ptype "ptype A" "ptype A" \
	"class A : public virtual V \{(${ws}private:|)" \
	"V \\*(_vb.1V|_vb.V);" \
	"" "int a;" \
	"public:" "virtual int f\\((void|)\\);" \
	"A & operator=\\(A const ?&\\);${ws}A\\(int, A const ?&\\);${ws}A\\(int\\);" \
	"(A & operator=\\(A const ?&\\);${ws}|)A\\(A const ?&\\);${ws}A\\((void|)\\);" \
	""
d84 7
a90 8
    test_one_ptype "ptype B" "ptype B" \
	"class B : public A \{(${ws}private:|)" \
	"V \\*(_vb.1V|_vb.V);" \
	"" "int b;" \
	"public:" "virtual int f\\((void|)\\);" \
	"B & operator=\\(B const ?&\\);${ws}B\\(int, B const ?&\\);${ws}B\\(int\\);" \
	"(B & operator=\\(B const ?&\\);${ws}|)B\\(B const ?&\\);${ws}B\\((void|)\\);" \
	""
d94 7
a100 8
    test_one_ptype "ptype C" "ptype C" \
	"class C : public virtual V \{(${ws}private:|)" \
	"V \\*(_vb.1V|_vb.V);" \
	"public:" "int c;" \
	"" "" \
	"C & operator=\\(C const ?&\\);${ws}C\\(int, C const ?&\\);${ws}C\\(int\\);" \
	"(C & operator=\\(C const ?&\\);${ws}|)C\\(C const ?&\\);${ws}C\\((void|)\\);" \
	""
d104 5
a108 8
    test_one_ptype "ptype AD" "ptype AD" \
	"((struct|class) AD \{${ws}public:|struct AD \{)" \
	"" \
	"" "" \
    	"" "virtual int vg\\((void|)\\);" \
	"AD & operator=\\(AD const ?&\\);${ws}AD\\(AD const ?&\\);${ws}AD\\((void|)\\);" \
	"(AD & operator=\\(AD const ?&\\);${ws}|)AD\\(AD const ?&\\);${ws}AD\\((void|)\\);" \
	""
d112 12
a123 8
    test_one_ptype "ptype D" "ptype D" \
	"class D : public AD, public virtual V \{(${ws}private:|)" \
    	"V \\*(_vb.1V|_vb.V);" \
    	"public:" "int d;" \
	"" "static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(int, D const ?&\\);${ws}D\\(int\\);" \
	"(D & operator=\\(D const ?&\\);${ws}|)D\\(D const ?&\\);${ws}D\\((void|)\\);" \
	""
a125 1
    # TODO: E does not show a vbptr for V.  That seems strange.
d127 13
a139 8
    test_one_ptype "ptype E" "ptype E" \
	"class E : public B, public virtual V, public D, public C \{(${ws}private:|)" \
	"" \
	"public:" "int e;" \
	"" "virtual int f\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vv\\((void|)\\);" \
	"E & operator=\\(E const ?&\\);${ws}E\\(int, E const ?&\\);${ws}E\\(int\\);" \
	"(E & operator=\\(E const ?&\\);${ws}|)E\\(E const ?&\\);${ws}E\\((void|)\\);" \
	""
d143 1
a143 8
    test_one_ptype "ptype dd" "ptype dd" \
	"class D : public AD, public virtual V \{(${ws}private:|)" \
    	"V \\*(_vb.1V|_vb.V);" \
    	"public:" "int d;" \
	"" "static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(int, D const ?&\\);${ws}D\\(int\\);" \
	"(D & operator=\\(D const ?&\\);${ws}|)D\\(D const ?&\\);${ws}D\\((void|)\\);" \
	""
d147 1
a147 8
    test_one_ptype "ptype ppd" "ptype ppd" \
	"class D : public AD, public virtual V \{(${ws}private:|)" \
    	"V \\*(_vb.1V|_vb.V);" \
    	"public:" "int d;" \
	"" "static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(int, D const ?&\\);${ws}D\\(int\\);" \
	"(D & operator=\\(D const ?&\\);${ws}|)D\\(D const ?&\\);${ws}D\\((void|)\\);" \
	" ?\\*"
d152 1
a152 43
    test_one_ptype "ptype pAd" "ptype pAd" \
	"((struct|class) AD \{${ws}public:|struct AD \{)" \
	"" \
	"" "" \
    	"" "virtual int vg\\((void|)\\);" \
	"AD & operator=\\(AD const ?&\\);${ws}AD\\(AD const ?&\\);${ws}AD\\((void|)\\);" \
	"(AD & operator=\\(AD const ?&\\);${ws}|)AD\\(AD const ?&\\);${ws}AD\\((void|)\\);" \
	" ?\\*"

    # An instance of A

    test_one_ptype "ptype a" "ptype a" \
	"class A : public virtual V \{(${ws}private:|)" \
	"V \\*(_vb.1V|_vb.V);" \
	"" "int a;" \
	"public:" "virtual int f\\((void|)\\);" \
	"A & operator=\\(A const ?&\\);${ws}A\\(int, A const ?&\\);${ws}A\\(int\\);" \
	"(A & operator=\\(A const ?&\\);${ws}|)A\\(A const ?&\\);${ws}A\\((void|)\\);" \
	""

    # An instance of B

    test_one_ptype "ptype b" "ptype b" \
	"class B : public A \{(${ws}private:|)" \
	"V \\*(_vb.1V|_vb.V);" \
	"" "int b;" \
	"public:" "virtual int f\\((void|)\\);" \
	"B & operator=\\(B const ?&\\);${ws}B\\(int, B const ?&\\);${ws}B\\(int\\);" \
	"(B & operator=\\(B const ?&\\);${ws}|)B\\(B const ?&\\);${ws}B\\((void|)\\);" \
	""

    # An instance of C

    test_one_ptype "ptype c" "ptype c" \
	"class C : public virtual V \{(${ws}private:|)" \
	"V \\*(_vb.1V|_vb.V);" \
	"public:" "int c;" \
	"" "" \
	"C & operator=\\(C const ?&\\);${ws}C\\(int, C const ?&\\);${ws}C\\(int\\);" \
	"(C & operator=\\(C const ?&\\);${ws}|)C\\(C const ?&\\);${ws}C\\((void|)\\);" \
	""

    # An instance of D
d154 1
a154 74
    test_one_ptype "ptype d" "ptype d" \
	"class D : public AD, public virtual V \{(${ws}private:|)" \
    	"V \\*(_vb.1V|_vb.V);" \
    	"public:" "int d;" \
	"" "static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(int, D const ?&\\);${ws}D\\(int\\);" \
	"(D & operator=\\(D const ?&\\);${ws}|)D\\(D const ?&\\);${ws}D\\((void|)\\);" \
	""

    # An instance of E

    test_one_ptype "ptype e" "ptype e" \
	"class E : public B, public virtual V, public D, public C \{(${ws}private:|)" \
	"" \
	"public:" "int e;" \
	"" "virtual int f\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vv\\((void|)\\);" \
	"E & operator=\\(E const ?&\\);${ws}E\\(int, E const ?&\\);${ws}E\\(int\\);" \
	"(E & operator=\\(E const ?&\\);${ws}|)E\\(E const ?&\\);${ws}E\\((void|)\\);" \
	""

    # An instance of V

    test_one_ptype "ptype v" "ptype v" \
	"class V : public VA, public VB \{${ws}public:" \
	"" \
	"" "int w;" \
	"" "int f\\((void|)\\);${ws}virtual int vv\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	"(V & operator=\\(V const ?&\\);${ws}|)V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	""

    # An instance of VB

    test_one_ptype "ptype vb" "ptype vb" \
	"((struct|class) VB \{${ws}public:|struct VB \{)" \
	"" \
	"" "int vb;" \
	"" "int fvb\\((void|)\\);${ws}virtual int vvb\\((void|)\\);" \
	"VB & operator=\\(VB const ?&\\);${ws}VB\\(VB const ?&\\);${ws}VB\\((void|)\\);" \
	"(VB & operator=\\(VB const ?&\\);${ws}|)VB\\(VB const ?&\\);${ws}VB\\((void|)\\);" \
	""

    # An instance of A *

    test_one_ptype "ptype pAa" "ptype pAa" \
	"class A : public virtual V \{(${ws}private:|)" \
	"V \\*(_vb.1V|_vb.V);" \
	"" "int a;" \
	"public:" "virtual int f\\((void|)\\);" \
	"A & operator=\\(A const ?&\\);${ws}A\\(int, A const ?&\\);${ws}A\\(int\\);" \
	"(A & operator=\\(A const ?&\\);${ws}|)A\\(A const ?&\\);${ws}A\\((void|)\\);" \
	" ?\\*"

    # An instance of A *

    test_one_ptype "ptype pAe" "ptype pAe" \
	"class A : public virtual V \{(${ws}private:|)" \
	"V \\*(_vb.1V|_vb.V);" \
	"" "int a;" \
	"public:" "virtual int f\\((void|)\\);" \
	"A & operator=\\(A const ?&\\);${ws}A\\(int, A const ?&\\);${ws}A\\(int\\);" \
	"(A & operator=\\(A const ?&\\);${ws}|)A\\(A const ?&\\);${ws}A\\((void|)\\);" \
	" ?\\*"

    # An instance of B *

    test_one_ptype "ptype pBe" "ptype pBe" \
	"class B : public A \{(${ws}private:|)" \
	"V \\*(_vb.1V|_vb.V);" \
	"" "int b;" \
	"public:" "virtual int f\\((void|)\\);" \
	"B & operator=\\(B const ?&\\);${ws}B\\(int, B const ?&\\);${ws}B\\(int\\);" \
	"(B & operator=\\(B const ?&\\);${ws}|)B\\(B const ?&\\);${ws}B\\((void|)\\);" \
	" ?\\*"
d156 22
a177 67
    # An instance of D *

    test_one_ptype "ptype pDd" "ptype pDd" \
	"class D : public AD, public virtual V \{(${ws}private:|)" \
    	"V \\*(_vb.1V|_vb.V);" \
    	"public:" "int d;" \
	"" "static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(int, D const ?&\\);${ws}D\\(int\\);" \
	"(D & operator=\\(D const ?&\\);${ws}|)D\\(D const ?&\\);${ws}D\\((void|)\\);" \
	" ?\\*"

    # An instance of D *

    test_one_ptype "ptype pDe" "ptype pDe" \
	"class D : public AD, public virtual V \{(${ws}private:|)" \
    	"V \\*(_vb.1V|_vb.V);" \
    	"public:" "int d;" \
	"" "static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(int, D const ?&\\);${ws}D\\(int\\);" \
	"(D & operator=\\(D const ?&\\);${ws}|)D\\(D const ?&\\);${ws}D\\((void|)\\);" \
	" ?\\*"

    # An instance of V *

    test_one_ptype "ptype pVa" "ptype pVa" \
	"class V : public VA, public VB \{${ws}public:" \
	"" \
	"" "int w;" \
	"" "int f\\((void|)\\);${ws}virtual int vv\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	"(V & operator=\\(V const ?&\\);${ws}|)V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	" ?\\*"

    # An instance of V *

    test_one_ptype "ptype pVv" "ptype pVv" \
	"class V : public VA, public VB \{${ws}public:" \
	"" \
	"" "int w;" \
	"" "int f\\((void|)\\);${ws}virtual int vv\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	"(V & operator=\\(V const ?&\\);${ws}|)V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	" ?\\*"

    # An instance of V *

    test_one_ptype "ptype pVe" "ptype pVe" \
	"class V : public VA, public VB \{${ws}public:" \
	"" \
	"" "int w;" \
	"" "int f\\((void|)\\);${ws}virtual int vv\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	"(V & operator=\\(V const ?&\\);${ws}|)V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	" ?\\*"

    # An instance of V *

    test_one_ptype "ptype pVd" "ptype pVd" \
	"class V : public VA, public VB \{${ws}public:" \
	"" \
	"" "int w;" \
	"" "int f\\((void|)\\);${ws}virtual int vv\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	"(V & operator=\\(V const ?&\\);${ws}|)V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	" ?\\*"

    # An instance of AD *
a178 30
    test_one_ptype "ptype pADe" "ptype pADe" \
	"((struct|class) AD \{${ws}public:|struct AD \{)" \
	"" \
	"" "" \
    	"" "virtual int vg\\((void|)\\);" \
	"AD & operator=\\(AD const ?&\\);${ws}AD\\(AD const ?&\\);${ws}AD\\((void|)\\);" \
	"(AD & operator=\\(AD const ?&\\);${ws}|)AD\\(AD const ?&\\);${ws}AD\\((void|)\\);" \
	" ?\\*"

    # An instance of E *

    test_one_ptype "ptype pEe" "ptype pEe" \
	"class E : public B, public virtual V, public D, public C \{(${ws}private:|)" \
	"" \
	"public:" "int e;" \
	"" "virtual int f\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vv\\((void|)\\);" \
	"E & operator=\\(E const ?&\\);${ws}E\\(int, E const ?&\\);${ws}E\\(int\\);" \
	"(E & operator=\\(E const ?&\\);${ws}|)E\\(E const ?&\\);${ws}E\\((void|)\\);" \
	" ?\\*"

    # An instance of VB *

    test_one_ptype "ptype pVB" "ptype pVB" \
	"((struct|class) VB \{${ws}public:|struct VB \{)" \
	"" \
	"" "int vb;" \
	"" "int fvb\\((void|)\\);${ws}virtual int vvb\\((void|)\\);" \
	"VB & operator=\\(VB const ?&\\);${ws}VB\\(VB const ?&\\);${ws}VB\\((void|)\\);" \
	"(VB & operator=\\(VB const ?&\\);${ws}|)VB\\(VB const ?&\\);${ws}VB\\((void|)\\);" \
	" ?\\*"
@


1.9
log
@2004-02-11  Michael Chastain  <mec.gnu@@mindspring.com>

	Partial fix for PR gdb/1543.
	* gdb.cp/ambiguous.exp, gdb.cp/annota2.exp, gdb.cp/annota3.exp,
	gdb.cp/anon-union.exp, gdb.cp/casts.exp, gdb.cp/classes.exp,
	gdb.cp/cplusfuncs.exp, gdb.cp/ctti.exp, gdb.exp/demangle.exp,
	gdb.cp/derivation.exp, gdb.cp/exception.exp, gdb.cp/hang.exp,
	gdb.cp/inherit.exp, gdb.cp/local.exp, gdb.cp/maint.exp,
	gdb.cp/member-ptr.exp, gdb.cp/method.exp, gdb.cp/misc.exp,
	gdb.cp/namespace.exp, gdb.cp/overload.exp, gdb.cp/ovldbreak.exp,
	gdb.cp/psmang.exp, gdb.cp/ref-types.exp, gdb.cp/templates.exp,
	gdb.cp/userdef.exp, gdb.cp/virtfunc.exp: Remove reference
	to bug-gdb@@prep.ai.mit.edu .
	* gdb.cp/bs15503.cc, gdb.cp/class2.cc, gdb.cp/cttiadd.cc,
	gdb.cp/cttiadd1.cc, gdb.cp/cttiadd2.cc, gdb.cp/cttiadd3.cc,
	gdb.cp/exception.cc, gdb.cp/member-ptr.cc, gdb.cp/namespace1.cc:
	Likewise.
@
text
@d143 1
a143 1
	"VA & operator=\\(VA const ?&\\);${ws}VA\\(VA const ?&\\);${ws}VA\\((void|)\\);" \
d154 1
a154 1
	"VB & operator=\\(VB const ?&\\);${ws}VB\\(VB const ?&\\);${ws}VB\\((void|)\\);" \
d165 1
a165 1
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
d176 1
a176 1
	"A & operator=\\(A const ?&\\);${ws}A\\(A const ?&\\);${ws}A\\((void|)\\);" \
d187 1
a187 1
	"B & operator=\\(B const ?&\\);${ws}B\\(B const ?&\\);${ws}B\\((void|)\\);" \
d198 1
a198 1
	"C & operator=\\(C const ?&\\);${ws}C\\(C const ?&\\);${ws}C\\((void|)\\);" \
d209 1
a209 1
	"AD & operator=\\(AD const ?&\\);${ws}AD\\(AD const ?&\\);${ws}AD\\((void|)\\);" \
d220 1
a220 1
	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\((void|)\\);" \
d232 1
a232 1
	"E & operator=\\(E const ?&\\);${ws}E\\(E const ?&\\);${ws}E\\((void|)\\);" \
d243 1
a243 1
	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\((void|)\\);" \
d254 1
a254 1
	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\((void|)\\);" \
d266 1
a266 1
	"AD & operator=\\(AD const ?&\\);${ws}AD\\(AD const ?&\\);${ws}AD\\((void|)\\);" \
d277 1
a277 1
	"A & operator=\\(A const ?&\\);${ws}A\\(A const ?&\\);${ws}A\\((void|)\\);" \
d288 1
a288 1
	"B & operator=\\(B const ?&\\);${ws}B\\(B const ?&\\);${ws}B\\((void|)\\);" \
d299 1
a299 1
	"C & operator=\\(C const ?&\\);${ws}C\\(C const ?&\\);${ws}C\\((void|)\\);" \
d310 1
a310 1
	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\((void|)\\);" \
d321 1
a321 1
	"E & operator=\\(E const ?&\\);${ws}E\\(E const ?&\\);${ws}E\\((void|)\\);" \
d332 1
a332 1
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
d343 1
a343 1
	"VB & operator=\\(VB const ?&\\);${ws}VB\\(VB const ?&\\);${ws}VB\\((void|)\\);" \
d354 1
a354 1
	"A & operator=\\(A const ?&\\);${ws}A\\(A const ?&\\);${ws}A\\((void|)\\);" \
d365 1
a365 1
	"A & operator=\\(A const ?&\\);${ws}A\\(A const ?&\\);${ws}A\\((void|)\\);" \
d376 1
a376 1
	"B & operator=\\(B const ?&\\);${ws}B\\(B const ?&\\);${ws}B\\((void|)\\);" \
d387 1
a387 1
	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\((void|)\\);" \
d398 1
a398 1
	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\((void|)\\);" \
d409 1
a409 1
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
d420 1
a420 1
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
d431 1
a431 1
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
d442 1
a442 1
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
d453 1
a453 1
	"AD & operator=\\(AD const ?&\\);${ws}AD\\(AD const ?&\\);${ws}AD\\((void|)\\);" \
d464 1
a464 1
	"E & operator=\\(E const ?&\\);${ws}E\\(E const ?&\\);${ws}E\\((void|)\\);" \
d475 1
a475 1
	"VB & operator=\\(VB const ?&\\);${ws}VB\\(VB const ?&\\);${ws}VB\\((void|)\\);" \
@


1.9.4.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d21 2
a30 2
load_lib "cp-support.exp"

d39 91
d131 3
d137 8
a144 5
    cp_test_ptype_class \
	"ptype VA" "" "class" "VA" \
	{
	    { field public "int va;" }
	}
d148 8
a155 7
    cp_test_ptype_class \
	"ptype VB" "" "class" "VB" \
	{
	    { field  public "int vb;" }
	    { method public "int fvb();" }
	    { method public "virtual int vvb();" }
	}
d159 8
a166 9
    cp_test_ptype_class \
	"ptype V" "" "class" "V" \
	{
	    { base          "public VA" }
	    { base          "public VB" }
	    { field  public "int w;" }
	    { method public "int f();" }
	    { method public "virtual int vv();" }
	}
d170 8
a177 8
    cp_test_ptype_class \
	"ptype A" "" "class" "A" \
	{
	    { base           "public virtual V" }
	    { vbase          "V" }
	    { field  private "int a;" }
	    { method public  "virtual int f();" }
	}
d181 8
a188 7
    cp_test_ptype_class \
	"ptype B" "" "class" "B" \
	{
	    { base           "public A" }
	    { field  private "int b;" }
	    { method public  "virtual int f();" }
	}
d192 8
a199 7
    cp_test_ptype_class \
	"ptype C" "" "class" "C" \
	{
	    { base         "public virtual V" }
	    { vbase        "V" }
	    { field public "int c;" }
	}
d203 8
a210 5
    cp_test_ptype_class \
	"ptype AD" "" "class" "AD" \
	{
	    { method public "virtual int vg();" }
	}
d214 8
a221 12
    cp_test_ptype_class \
	"ptype D" "" "class" "D" \
	{
	    { base          "public AD" }
	    { base          "public virtual V" }
	    { vbase         "V" }
	    { method public "static void s();" }
	    { method public "virtual int vg();" }
	    { method public "virtual int vd();" }
	    { method public "int fd();" }
	    { field  public "int d;" }
	}
d224 1
d226 8
a233 13
    cp_test_ptype_class \
	"ptype E" "" "class" "E" \
	{
	    { base          "public B" }
	    { base          "public virtual V" }
	    { base          "public D" }
	    { base          "public C" }
	    { vbase         "V" }
	    { method public "virtual int f();" }
	    { method public "virtual int vg();" }
	    { method public "virtual int vv();" }
	    { field  public "int e;" }
	}
d237 8
a244 1
    cp_test_ptype_class "ptype dd" "" "class" "D" ibid
d248 8
a255 1
    cp_test_ptype_class "ptype ppd" "" "class" "D" ibid "*"
d260 43
a302 1
    cp_test_ptype_class "ptype pAd" "" "class" "AD" ibid "*"
d304 74
a377 1
    # Instances of these classes.
d379 67
a445 22
    cp_test_ptype_class "ptype a" "" "class" "A" ibid
    cp_test_ptype_class "ptype b" "" "class" "B" ibid
    cp_test_ptype_class "ptype c" "" "class" "C" ibid
    cp_test_ptype_class "ptype d" "" "class" "D" ibid
    cp_test_ptype_class "ptype e" "" "class" "E" ibid
    cp_test_ptype_class "ptype v" "" "class" "V" ibid
    cp_test_ptype_class "ptype vb" "" "class" "VB" ibid

    # Instances of pointers to these classes.

    cp_test_ptype_class "ptype pAa" "" "class" "A" ibid "*"
    cp_test_ptype_class "ptype pAe" "" "class" "A" ibid "*"
    cp_test_ptype_class "ptype pBe" "" "class" "B" ibid "*"
    cp_test_ptype_class "ptype pDd" "" "class" "D" ibid "*"
    cp_test_ptype_class "ptype pDe" "" "class" "D" ibid "*"
    cp_test_ptype_class "ptype pVa" "" "class" "V" ibid "*"
    cp_test_ptype_class "ptype pVv" "" "class" "V" ibid "*"
    cp_test_ptype_class "ptype pVe" "" "class" "V" ibid "*"
    cp_test_ptype_class "ptype pVd" "" "class" "V" ibid "*"
    cp_test_ptype_class "ptype pADe" "" "class" "AD" ibid "*"
    cp_test_ptype_class "ptype pEe" "" "class" "E" ibid "*"
    cp_test_ptype_class "ptype pVB" "" "class" "VB" ibid "*"
d447 30
@


1.8
log
@2004-02-03  Michael Chastain  <mec.gnu@@mindspring.com>

	* gdb.cp/virtfunc.exp: Accept both "ctor()" and "ctor(void)".
@
text
@a17 3
# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@@prep.ai.mit.edu

@


1.7
log
@2004-01-10  Michael Chastain  <mec.gnu@@mindspring.com>

	* gdb.cp/virtfunc.exp: Remove old "(obsolescent gcc or gdb)"
	and "(aCC)" decorations.  Remove obsolete doco about old
	test results.
@
text
@d179 1
a179 1
	"A & operator=\\(A const ?&\\);${ws}A\\(A const ?&\\);${ws}A\\(\\);" \
d190 1
a190 1
	"B & operator=\\(B const ?&\\);${ws}B\\(B const ?&\\);${ws}B\\(\\);" \
d201 1
a201 1
	"C & operator=\\(C const ?&\\);${ws}C\\(C const ?&\\);${ws}C\\(\\);" \
d223 1
a223 1
	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\(\\);" \
d235 1
a235 1
	"E & operator=\\(E const ?&\\);${ws}E\\(E const ?&\\);${ws}E\\(\\);" \
d246 1
a246 1
	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\(\\);" \
d257 1
a257 1
	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\(\\);" \
d280 1
a280 1
	"A & operator=\\(A const ?&\\);${ws}A\\(A const ?&\\);${ws}A\\(\\);" \
d291 1
a291 1
	"B & operator=\\(B const ?&\\);${ws}B\\(B const ?&\\);${ws}B\\(\\);" \
d302 1
a302 1
	"C & operator=\\(C const ?&\\);${ws}C\\(C const ?&\\);${ws}C\\(\\);" \
d313 1
a313 1
	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\(\\);" \
d324 1
a324 1
	"E & operator=\\(E const ?&\\);${ws}E\\(E const ?&\\);${ws}E\\(\\);" \
d357 1
a357 1
	"A & operator=\\(A const ?&\\);${ws}A\\(A const ?&\\);${ws}A\\(\\);" \
d368 1
a368 1
	"A & operator=\\(A const ?&\\);${ws}A\\(A const ?&\\);${ws}A\\(\\);" \
d379 1
a379 1
	"B & operator=\\(B const ?&\\);${ws}B\\(B const ?&\\);${ws}B\\(\\);" \
d390 1
a390 1
	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\(\\);" \
d401 1
a401 1
	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\(\\);" \
d467 1
a467 1
	"E & operator=\\(E const ?&\\);${ws}E\\(E const ?&\\);${ws}E\\(\\);" \
@


1.6
log
@2004-01-08  Michael Chastain  <mec.gnu@@mindspring.com>

	* gdb.cp/classes.exp: Accept gnu abi 2.
	* gdb.cp/derivation.exp: Likewise.
	* gdb.cp/overload.exp: Likewise.
	* gdb.cp/virtfunc.exp: Likewise.
@
text
@a93 23
# compatibility kludges
set kk0 ""
set kk1 ""
set kk2 ""
set kk3 ""
set kk4 ""
set kk5 ""

proc kk_debug { } {
    global kk0
    global kk1
    global kk2
    global kk3
    global kk4
    global kk5
    set kk0 " (0)"
    set kk1 " (1)"
    set kk2 " (2)"
    set kk3 " (3)"
    set kk4 " (4)"
    set kk5 " (5)"
}

a99 7
    global kk0
    global kk1
    global kk2
    global kk3
    global kk4
    global kk5

d105 1
a105 1
	    pass "$testname$kk0"
d110 1
a110 1
	    pass "$testname$kk1"
d114 1
a114 1
	    pass "$testname$kk2"
d119 1
a119 1
	    pass "$testname$kk3"
d123 1
a123 1
	    pass "$testname$kk4"
d127 1
a127 1
	    pass "$testname$kk5"
a130 6
    set kk0 ""
    set kk1 ""
    set kk2 ""
    set kk3 ""
    set kk4 ""
    set kk5 ""
a137 7
    global kk0
    global kk1
    global kk2
    global kk3
    global kk4
    global kk5

a139 1
    set kk0 " (obsolescent gcc or gdb)"
a150 1
    set kk0 " (obsolescent gcc or gdb)"
a161 1
    set kk0 " (obsolescent gcc or gdb)"
a172 2
    set kk0 " (aCC)"
    set kk1 " (obsolescent gcc or gdb)"
a183 1
    set kk0 " (obsolescent gcc or gdb)"
a194 2
    set kk0 " (aCC)"
    set kk1 " (obsolescent gcc or gdb)"
a205 1
    set kk0 " (obsolescent gcc or gdb)"
a216 2
    set kk0 " (aCC)"
    set kk1 " (obsolescent gcc or gdb)"
a228 1
    set kk0 " (obsolescent gcc or gdb)"
a239 2
    set kk0 " (aCC)"
    set kk1 " (obsolescent gcc or gdb)"
a250 2
    set kk0 " (aCC)"
    set kk1 " (obsolescent gcc or gdb)"
a262 1
    set kk0 " (obsolescent gcc or gdb)"
a273 2
    set kk0 " (aCC)"
    set kk1 " (obsolescent gcc or gdb)"
a284 1
    set kk0 " (obsolescent gcc or gdb)"
a295 2
    set kk0 " (aCC)"
    set kk1 " (obsolescent gcc or gdb)"
a306 2
    set kk0 " (aCC)"
    set kk1 " (obsolescent gcc or gdb)"
a317 1
    set kk0 " (obsolescent gcc or gdb)"
a328 1
    set kk0 " (obsolescent gcc or gdb)"
a339 1
    set kk0 " (obsolescent gcc or gdb)"
a350 2
    set kk0 " (aCC)"
    set kk1 " (obsolescent gcc or gdb)"
a361 2
    set kk0 " (aCC)"
    set kk1 " (obsolescent gcc or gdb)"
a372 1
    set kk0 " (obsolescent gcc or gdb)"
a383 2
    set kk0 " (aCC)"
    set kk1 " (obsolescent gcc or gdb)"
a394 2
    set kk0 " (aCC)"
    set kk1 " (obsolescent gcc or gdb)"
a405 1
    set kk0 " (obsolescent gcc or gdb)"
a416 1
    set kk0 " (obsolescent gcc or gdb)"
a427 1
    set kk0 " (obsolescent gcc or gdb)"
a438 1
    set kk0 " (obsolescent gcc or gdb)"
a449 1
    set kk0 " (obsolescent gcc or gdb)"
a460 1
    set kk0 " (obsolescent gcc or gdb)"
a471 1
    set kk0 " (obsolescent gcc or gdb)"
a504 32

    # fails on target=native, host=i686-pc-linux-gnu%rh-7.2,
    # gdb=HEAD%2002-02-16, gcc=2.95.3, goption=-gdwarf-2.
    #
    # fails on target=native, host=i686-pc-linux-gnu%rh-7.2,
    # gdb=HEAD%2002-02-16, gcc=2.95.3, goption=-gstabs+.
    #
    # fails on target=native, host=i686-pc-linux-gnu%rh-7.2,
    # gdb=HEAD%2002-02-16, gcc=3.0.3, goption=-gdwarf-2.
    #
    # fails on target=native, host=i686-pc-linux-gnu%rh-7.2,
    # gdb=HEAD%2002-02-16, gcc=3.0.3, goption=-gstabs+.
    #
    # fails on target=native, host=i686-pc-linux-gnu%rh-7.2,
    # gdb=HEAD%2002-02-16, gcc=3.0.4-20020215, goption=-gdwarf-2.
    #
    # fails on target=native, host=i686-pc-linux-gnu%rh-7.2,
    # gdb=HEAD%2002-02-16, gcc=3.0.4-20020215, goption=-gstabs+.
    #
    # fails on target=native, host=i686-pc-linux-gnu%rh-7.2,
    # gdb=HEAD%2002-02-16, gcc=gcc-3_0-branch%2002-02-16, goption=-gdwarf-2.
    #
    # fails on target=native, host=i686-pc-linux-gnu%rh-7.2,
    # gdb=HEAD%2002-02-16, gcc=gcc-3_0-branch%2002-02-16, goption=-gstabs+.
    #
    # fails on target=native, host=i686-pc-linux-gnu%rh-7.2,
    # gdb=HEAD%2002-02-16, gcc=HEAD%2002-02-16, goption=-gdwarf-2.
    #
    # fails on target=native, host=i686-pc-linux-gnu%rh-7.2,
    # gdb=HEAD%2002-02-16, gcc=HEAD%2002-02-16, goption=-gstabs+.
    #
    # -- chastain 2002-02-20
@


1.5
log
@2004-01-01  Michael Chastain  <mec.gnu@@mindspring.com>

	* gdb.cp/classes.exp: Generate identical results as old version.
	* gdb.cp/derivation.exp: Likewise.
	* gdb.cp/overload.exp: Likewise.
	* gdb.cp/virtfunc.exp: Likewise.
@
text
@a100 1
set fk5 ""
a108 1
    global fk5
a114 1
    set fk5 ""
a128 1
    global fk5
d157 1
a157 5
	    if { "$fk5" == "fail" } {
		fail "$testname$kk5"
	    } else {
		pass "$testname$kk5"
	    }
a166 1
    set fk5 ""
a179 1
    global fk5
a195 1
    set kk5 " (obsolescent gcc or gdb)"
a207 1
    set kk5 " (obsolescent gcc or gdb)"
a220 1
    set fk5 "fail"
a232 1
    set fk5 "fail"
a257 1
    set kk5 " (obsolescent gcc or gdb)"
a270 1
    set fk5 "fail"
a283 1
    set fk5 "fail"
a296 1
    set fk5 "fail"
a309 1
    set fk5 "fail"
a322 1
    set kk5 " (obsolescent gcc or gdb)"
a335 1
    set fk5 "fail"
a347 1
    set fk5 "fail"
a373 1
    set fk5 "fail"
a385 1
    set fk5 "fail"
a397 1
    set kk5 " (obsolescent gcc or gdb)"
a409 1
    set kk5 " (obsolescent gcc or gdb)"
a422 1
    set fk5 "fail"
a435 1
    set fk5 "fail"
a447 1
    set fk5 "fail"
a460 1
    set fk5 "fail"
a473 1
    set fk5 "fail"
a485 1
    set kk5 " (obsolescent gcc or gdb)"
a497 1
    set kk5 " (obsolescent gcc or gdb)"
a509 1
    set kk5 " (obsolescent gcc or gdb)"
a521 1
    set kk5 " (obsolescent gcc or gdb)"
a533 1
    set kk5 " (obsolescent gcc or gdb)"
a545 1
    set fk5 "fail"
a557 1
    set kk5 " (obsolescent gcc or gdb)"
@


1.4
log
@2004-01-01  Michael Chastain  <mec.gnu@@mindspring.com>

	* gdb.cp/virtfunc.exp: Modify some patterns to avoid a
	mysterious bug with sourceware version of expect.
@
text
@d24 3
a26 2
set ws "\[\r\n\t \]+"
set nl "\[\r\n\]+"
d42 1
a42 1
# Test ptype of class objects.
d56 1
a56 1
#     public:
d70 3
a72 2
# RE_VBPTR matches the virtual base declarations.  gcc 2.95.3 emits
# these, but gcc 3.X.Y does not.  The name depends on the debug format.
d81 3
a83 11
# RE_ALL_METHODS combines RE_METHODS and the optional synthetic methods.
# Up to gcc 3.3.X, gcc defaults to gcc ABI 1, with synthetic methods at
# the beginning.  Starting with gcc 3.4.X, gcc defaults to gcc ABI 2,
# with synthetic methods at the end.
#
# So the possible choices for RE_ALL_METHODS are:
#
#   RE_METHODS			// any gcc with dwarf-2
#   RE_SYNTH_GCC_2|RE_METHODS	// gcc 2.95.3, stabs+
#   RE_SYNTH_GCC_3|RE_METHODS	// gcc 3.3.2, stabs+
#   RE_METHODS|RE_SYNTH_GCC_3	// gcc 3.4.0, stabs+
d85 1
a85 2
# When I get HP-UX aCC, I hope that I can just add RE_SYNTH_ACC_FOO
# and enlarge RE_ALL_METHODS.
d92 27
a118 4
# I use gdb_test_multiple with only one arm.  I could use gdb_test,
# but gdb_test_multiple makes it easier to add KFAIL arms as needed.
#
# -- chastain 2003-12-31
d120 1
a120 1
proc test_ptype_of_classes {} {
d122 1
d126 40
a165 10
    # class VA

    set re_class	"((struct|class) VA \{${ws}public:|struct VA \{)"
    set re_fields	"int va;"
    set re_synth_gcc_23	"VA & operator=\\(VA const ?&\\);${ws}VA\\(VA const ?&\\);${ws}VA\\((void|)\\);"
    set re_all_methods	"(|$re_synth_gcc_23)"

    gdb_test_multiple "ptype VA" "ptype VA" {
	-re "type = $re_class${ws}$re_fields${ws}(public:${ws}|)$re_all_methods$nl\}$nl$gdb_prompt $" {
	    pass "ptype VA"
d169 13
a181 1
    # class VB
d183 7
a189 11
    set re_class	"((struct|class) VB \{${ws}public:|struct VB \{)"
    set re_fields	"int vb;"
    set re_methods	"int fvb\\((void|)\\);${ws}virtual int vvb\\((void|)\\);"
    set re_synth_gcc_23	"VB & operator=\\(VB const ?&\\);${ws}VB\\(VB const ?&\\);${ws}VB\\((void|)\\);"
    set re_all_methods	"($re_methods|$re_methods${ws}$re_synth_gcc_23|$re_synth_gcc_23${ws}$re_methods)"

    gdb_test_multiple "ptype VB" "ptype VB" {
	-re "type = $re_class${ws}$re_fields${ws}(public:${ws}|)$re_all_methods$nl\}$nl$gdb_prompt $" {
	    pass "ptype VB"
	}
    }
d191 1
a191 1
    # An instance of VB
d193 9
a201 5
    gdb_test_multiple "ptype vb" "ptype vb" {
	-re "type = $re_class${ws}$re_fields${ws}(public:${ws}|)$re_all_methods$nl\}$nl$gdb_prompt $" {
	    pass "ptype vb"
	}
    }
d203 1
a203 1
    # An instance of VB *
d205 10
a214 5
    gdb_test_multiple "ptype pVB" "ptype pVB" {
	-re "type = $re_class${ws}$re_fields${ws}(public:${ws}|)$re_all_methods$nl\} \\*$nl$gdb_prompt $" {
	    pass "ptype pVB"
	}
    }
d218 10
a227 11
    set re_class	"class V : public VA, public VB \{${ws}public:"
    set re_fields	"int w;"
    set re_methods	"int f\\((void|)\\);${ws}virtual int vv\\((void|)\\);"
    set re_synth_gcc_23	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);"
    set re_all_methods	"($re_methods|$re_methods${ws}$re_synth_gcc_23|$re_synth_gcc_23${ws}$re_methods)"

    gdb_test_multiple "ptype V" "ptype V" {
	-re "type = $re_class${ws}$re_fields${ws}(public:${ws}|)$re_all_methods$nl\}$nl$gdb_prompt $" {
	    pass "ptype V"
	}
    }
d229 1
a229 1
    # An instance of V
d231 11
a241 5
    gdb_test_multiple "ptype v" "ptype v" {
	-re "type = $re_class${ws}$re_fields${ws}(public:${ws}|)$re_all_methods$nl\}$nl$gdb_prompt $" {
	    pass "ptype v"
	}
    }
d243 1
a243 1
    # An instance of V *
d245 10
a254 5
    gdb_test_multiple "ptype pVa" "ptype pVa" {
	-re "type = $re_class${ws}$re_fields${ws}(public:${ws}|)$re_all_methods$nl\} \\*$nl$gdb_prompt $" {
	    pass "ptype pVa"
	}
    }
d256 1
a256 1
    # An instance of V *
d258 10
a267 5
    gdb_test_multiple "ptype pVv" "ptype pVv" {
	-re "type = $re_class${ws}$re_fields${ws}(public:${ws}|)$re_all_methods$nl\} \\*$nl$gdb_prompt $" {
	    pass "ptype pVv"
	}
    }
d269 1
a269 1
    # An instance of V *
d271 10
a280 5
    gdb_test_multiple "ptype pVe" "ptype pVe" {
	-re "type = $re_class${ws}$re_fields${ws}(public:${ws}|)$re_all_methods$nl\} \\*$nl$gdb_prompt $" {
	    pass "ptype pVe"
	}
    }
d282 1
a282 1
    # An instance of V *
d284 11
a294 5
    gdb_test_multiple "ptype pVd" "ptype pVd" {
	-re "type = $re_class${ws}$re_fields${ws}(public:${ws}|)$re_all_methods$nl\} \\*$nl$gdb_prompt $" {
	    pass "ptype pVd"
	}
    }
d296 2
a297 1
    # class A
d299 10
a308 14
    set re_class	"class A : public virtual V \{(${ws}private:|)"
    set re_vbptr 	"V \\*(_vb.1V|_vb.V);"
    set re_fields	"int a;"
    set re_methods	"virtual int f\\((void|)\\);"
    # gcc 2 adds an "in-charge" arg to the ctor.
    set re_synth_gcc_2	"A & operator=\\(A const ?&\\);${ws}A\\(int, A const ?&\\);${ws}A\\(int\\);"
    set re_synth_gcc_3	"A & operator=\\(A const ?&\\);${ws}A\\(A const ?&\\);${ws}A\\(\\);"
    set re_all_methods	"($re_methods|$re_synth_gcc_2${ws}$re_methods|$re_synth_gcc_3${ws}$re_methods|$re_methods${ws}$re_synth_gcc_3)"

    gdb_test_multiple "ptype A" "ptype A" {
	-re "type = ${re_class}${ws}(${re_vbptr}${ws}|)${re_fields}${ws}public:${ws}${re_all_methods}$nl\}$nl$gdb_prompt $" {
	    pass "ptype A"
	}
    }
d310 1
a310 1
    # An instance of A
d312 11
a322 5
    gdb_test_multiple "ptype a" "ptype a" {
	-re "type = ${re_class}${ws}(${re_vbptr}${ws}|)${re_fields}${ws}public:${ws}${re_all_methods}$nl\}$nl$gdb_prompt $" {
	    pass "ptype a"
	}
    }
d324 1
a324 1
    # An instance of A *
d326 11
a336 5
    gdb_test_multiple "ptype pAa" "ptype pAa" {
	-re "type = ${re_class}${ws}(${re_vbptr}${ws}|)${re_fields}${ws}public:${ws}${re_all_methods}$nl\} \\*$nl$gdb_prompt $" {
	    pass "ptype pAa"
	}
    }
d338 2
a339 1
    # An instance of A *
d341 10
a350 5
    gdb_test_multiple "ptype pAe" "ptype pAe" {
	-re "type = ${re_class}${ws}(${re_vbptr}${ws}|)${re_fields}${ws}public:${ws}${re_all_methods}$nl\} \\*$nl$gdb_prompt $" {
	    pass "ptype pAe"
	}
    }
d352 1
a352 1
    # class B
d354 11
a364 13
    set re_class	"class B : public A \{(${ws}private:|)"
    set re_vbptr	"V \\*(_vb.1V|_vb.V);"
    set re_fields	"int b;"
    set re_methods	"virtual int f\\((void|)\\);"
    set re_synth_gcc_2	"B & operator=\\(B const ?&\\);${ws}B\\(int, B const ?&\\);${ws}B\\(int\\);"
    set re_synth_gcc_3	"B & operator=\\(B const ?&\\);${ws}B\\(B const ?&\\);${ws}B\\(\\);"
    set re_all_methods	"($re_methods|$re_synth_gcc_2${ws}$re_methods|$re_synth_gcc_3${ws}$re_methods|$re_methods${ws}$re_synth_gcc_3)"

    gdb_test_multiple "ptype B" "ptype B" {
	-re "type = ${re_class}${ws}(${re_vbptr}${ws}|)${re_fields}${ws}public:${ws}${re_all_methods}$nl\}$nl$gdb_prompt $" {
	    pass "ptype B"
	}
    }
d368 12
a379 5
    gdb_test_multiple "ptype b" "ptype b" {
	-re "type = ${re_class}${ws}(${re_vbptr}${ws}|)${re_fields}${ws}public:${ws}${re_all_methods}$nl\}$nl$gdb_prompt $" {
	    pass "ptype b"
	}
    }
d381 10
a390 1
    # An instance of B *
d392 1
a392 5
    gdb_test_multiple "ptype pBe" "ptype pBe" {
	-re "type = ${re_class}${ws}(${re_vbptr}${ws}|)${re_fields}${ws}public:${ws}${re_all_methods}$nl\} \\*$nl$gdb_prompt $" {
	    pass "ptype pBe"
	}
    }
d394 11
a404 1
    # class C
d406 1
a406 12
    set re_class	"class C : public virtual V \{(${ws}private:|)"
    set re_vbptr	"V \\*(_vb.1V|_vb.V);"
    set re_fields	"int c;"
    set re_synth_gcc_2	"C & operator=\\(C const ?&\\);${ws}C\\(int, C const ?&\\);${ws}C\\(int\\);"
    set re_synth_gcc_3	"C & operator=\\(C const ?&\\);${ws}C\\(C const ?&\\);${ws}C\\(\\);"
    set re_all_methods	"(|$re_synth_gcc_2|$re_synth_gcc_3)"

    gdb_test_multiple "ptype C" "ptype C" {
	-re "type = ${re_class}${ws}(${re_vbptr}${ws}|)public:${ws}${re_fields}${ws}(public:${ws}|)${re_all_methods}$nl\}$nl$gdb_prompt $" {
	    pass "ptype C"
	}
    }
d408 10
a417 1
    # An instance of C
d419 1
a419 5
    gdb_test_multiple "ptype c" "ptype c" {
	-re "type = ${re_class}${ws}(${re_vbptr}${ws}|)public:${ws}${re_fields}${ws}(public:${ws}|)${re_all_methods}$nl\}$nl$gdb_prompt $" {
	    pass "ptype c"
	}
    }
d421 10
a430 1
    # class AD
d432 1
a432 10
    set re_class	"((struct|class) AD \{${ws}public:|struct AD \{)"
    set re_methods	"virtual int vg\\((void|)\\);"
    set re_synth_gcc_23	"AD & operator=\\(AD const ?&\\);${ws}AD\\(AD const ?&\\);${ws}AD\\((void|)\\);"
    set re_all_methods	"($re_methods|$re_methods${ws}$re_synth_gcc_23|$re_synth_gcc_23${ws}$re_methods)"

    gdb_test_multiple "ptype AD" "ptype AD" {
	-re "type = $re_class${ws}$re_all_methods$nl\}$nl$gdb_prompt $" {
	    pass "ptype AD"
	}
    }
d434 10
a443 2
    # An instance of AD *
    # TODO: this should be named pADd, not pAd.
d445 1
a445 5
    gdb_test_multiple "ptype pAd" "ptype pAd" {
	-re "type = $re_class${ws}$re_all_methods$nl\} \\*$nl$gdb_prompt $" {
	    pass "ptype pAd"
	}
    }
d447 11
a457 1
    # An instance of a AD *
d459 1
a459 5
    gdb_test_multiple "ptype pADe" "ptype pADe" {
	-re "type = $re_class${ws}$re_all_methods$nl\} \\*$nl$gdb_prompt $" {
	    pass "ptype pADe"
	}
    }
d461 11
a471 23
    # class D
    #
    # I wrote this differently from the others to avoid a problem with
    # the sourceware version of expect, which dates from 1998.
    # The bug manifests as ERROR/UNRESOLVED results after an "eof"
    # in gdb_test_multiple.
    #
    # -- chastain 2004-01-01

    set re_class	"class D : public AD, public virtual V \{(${ws}private:|)"
    set re_vbptr	"V \\*(_vb.1V|_vb.V);"
    set re_fields	"int d;"
    set re_methods_2	"static void s\\(void\\);${ws}virtual int vg\\(void\\);${ws}virtual int vd\\(void\\);${ws}int fd\\(void\\);"
    set re_methods_3	"static void s\\(\\);${ws}virtual int vg\\(\\);${ws}virtual int vd\\(\\);${ws}int fd\\(\\);"
    set re_synth_gcc_2	"D & operator=\\(D const ?&\\);${ws}D\\(int, D const ?&\\);${ws}D\\(int\\);"
    set re_synth_gcc_3	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\(\\);"
    set re_all_methods	"($re_methods_2|$re_methods_3|$re_synth_gcc_2${ws}$re_methods_2|$re_synth_gcc_3${ws}$re_methods_3|$re_methods${ws}$re_synth_gcc_3)"

    gdb_test_multiple "ptype D" "ptype D" {
	-re "type = ${re_class}${ws}(${re_vbptr}${ws}|)public:${ws}${re_fields}${ws}${re_all_methods}$nl\}$nl$gdb_prompt $" {
	    pass "ptype D"
	}
    }
d473 1
a473 1
    # An instance of D
d475 10
a484 5
    gdb_test_multiple "ptype d" "ptype d" {
	-re "type = ${re_class}${ws}(${re_vbptr}${ws}|)public:${ws}${re_fields}${ws}${re_all_methods}$nl\}$nl$gdb_prompt $" {
	    pass "ptype d"
	}
    }
d486 1
a486 1
    # An instance of D
d488 11
a498 5
    gdb_test_multiple "ptype dd" "ptype dd" {
	-re "type = ${re_class}${ws}(${re_vbptr}${ws}|)public:${ws}${re_fields}${ws}${re_all_methods}$nl\}$nl$gdb_prompt $" {
	    pass "ptype dd"
	}
    }
d502 24
a525 5
    gdb_test_multiple "ptype ppd" "ptype ppd" {
	-re "type = ${re_class}${ws}(${re_vbptr}${ws}|)public:${ws}${re_fields}${ws}${re_all_methods}$nl\} \\*$nl$gdb_prompt $" {
	    pass "ptype ppd"
	}
    }
d527 1
a527 1
    # An instance of D *
d529 10
a538 5
    gdb_test_multiple "ptype pDd" "ptype pDd" {
	-re "type = ${re_class}${ws}(${re_vbptr}${ws}|)public:${ws}${re_fields}${ws}${re_all_methods}$nl\} \\*$nl$gdb_prompt $" {
	    pass "ptype pDd"
	}
    }
d540 1
a540 1
    # An instance of D *
d542 10
a551 5
    gdb_test_multiple "ptype pDe" "ptype pDe" {
	-re "type = ${re_class}${ws}(${re_vbptr}${ws}|)public:${ws}${re_fields}${ws}${re_all_methods}$nl\} \\*$nl$gdb_prompt $" {
	    pass "ptype pDe"
	}
    }
d553 1
a553 2
    # class E
    # TODO: E does not show a vbptr for V.  That seems strange.
d555 10
a564 12
    set re_class	"class E : public B, public virtual V, public D, public C \{(${ws}private:|)"
    set re_fields	"int e;"
    set re_methods	"virtual int f\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vv\\((void|)\\);"
    set re_synth_gcc_2	"E & operator=\\(E const ?&\\);${ws}E\\(int, E const ?&\\);${ws}E\\(int\\);"
    set re_synth_gcc_3	"E & operator=\\(E const ?&\\);${ws}E\\(E const ?&\\);${ws}E\\(\\);"
    set re_all_methods	"($re_methods|$re_synth_gcc_2${ws}$re_methods|$re_synth_gcc_3${ws}$re_methods|$re_methods${ws}$re_synth_gcc_3)"

    gdb_test_multiple "ptype E" "ptype E" {
	-re "type = ${re_class}${ws}public:${ws}${re_fields}${ws}${re_all_methods}$nl\}$nl$gdb_prompt $" {
	    pass "ptype E"
	}
    }
d566 1
a566 1
    # An instance of E
d568 10
a577 5
    gdb_test_multiple "ptype e" "ptype e" {
	-re "type = ${re_class}${ws}public:${ws}${re_fields}${ws}${re_all_methods}$nl\}$nl$gdb_prompt $" {
	    pass "ptype e"
	}
    }
d581 23
a603 5
    gdb_test_multiple "ptype pEe" "ptype pEe" {
	-re "type = ${re_class}${ws}public:${ws}${re_fields}${ws}${re_all_methods}$nl\} \\*$nl$gdb_prompt $" {
	    pass "ptype pEe"
	}
    }
@


1.3
log
@2003-12-31  Michael Chastain  <mec.gnu@@mindspring.com>

	* gdb.cp/virtfunc.exp: Rewrite.  Clean up patterns to match
	current versions of gcc, including gcc abi 2.  Use "breakpoint"
	and "continue" instead of restarting the target program.  Use
	gdb_test_multiple and gdb_test for all tests.
@
text
@d1 1
a1 1
# Copyright 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2001, 2002, 2003
d333 7
d344 2
a345 1
    set re_methods	"static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);"
d348 1
a348 1
    set re_all_methods	"($re_methods|$re_synth_gcc_2${ws}$re_methods|$re_synth_gcc_3${ws}$re_methods|$re_methods${ws}$re_synth_gcc_3)"
@


1.2
log
@2003-11-23  Michael Chastain  <mec.gnu@@mindspring.com>

	Partial fix for PR testsuite/1456.
	* gdb.cp/ambiguous.exp: Replace reference to gcc_compiled with
	call to test_compiler_info.
	* gdb.cp/ctti.exp: Likewise.
	* gdb.cp/derivation.exp: Likewise.
	* gdb.cp/member-ptr.exp: Likewise.
	* gdb.cp/virtfunc.exp (test_virtual_calls): Remove unused
	reference to gcc_compiled.
@
text
@d22 1
d28 1
a28 1
	strace $tracelevel
a36 6
if [get_compiler_info ${binfile} "c++"] {
    return -1
}

source ${binfile}.ci

d41 57
a97 20
proc gdb_virtfunc_init {} {
    global srcdir subdir binfile
    global gdb_prompt

    gdb_reinitialize_dir $srcdir/$subdir
    gdb_load $binfile

    send_gdb "set language c++\n"
    gdb_expect -re "$gdb_prompt $"
    send_gdb "set width 0\n"
    gdb_expect -re "$gdb_prompt $"
}

proc gdb_virtfunc_restart {} {
    gdb_exit;
    gdb_start;
    gdb_virtfunc_init;
    runto 'test_calls';
}

d99 2
a100 1
#  Test printing of the types of various classes.
d102 1
d109 9
a117 6
    # This used to be a fail if it printed "struct" not "class".  But
    # since this struct doesn't use any special C++ features, it is
    # considered right for GDB to print it as "struct".
    send_gdb "ptype VA\n"
    gdb_expect {
	-re "type = (struct|class) VA \{(${ws}public:|)${ws}int va;${ws}VA & operator=\\(VA const ?&\\);${ws}VA\\((VA const|const VA) ?&\\);${ws}VA\\((void|)\\);${ws}\}.*$gdb_prompt $" {
a119 9
	-re "type = (struct|class) VA \{(${ws}public:|)${ws}int va;((${ws}VA & operator=\\(VA const ?&\\);)|(${ws}VA\\(VA const ?&\\);)|(${ws}VA\\((void|)\\);))*${ws}\}.*$gdb_prompt $" {
	    pass "ptype VA (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype VA"
	}
	timeout {
	    fail "ptype VA (timeout)"
	}
d122 10
a131 3
    send_gdb "ptype VB\n"
    gdb_expect {
	-re "type = class VB \{${ws}public:${ws}int vb;${ws}VB & operator=\\(VB const ?&\\);${ws}VB\\((VB const|const VB) ?&\\);${ws}VB\\((void|)\\);${ws}int fvb\\((void|)\\);${ws}virtual int vvb\\((void|)\\);${ws}\}.*$gdb_prompt $" {
d134 7
a140 2
	-re "type = class VB \{${ws}public:${ws}int vb;${ws}int fvb \\((void|)\\);${ws}virtual int vvb \\((void|)\\);${ws}\}.*$gdb_prompt $" {
	    pass "ptype VB (aCC)"
d142 7
a148 8
	-re "type = class VB \{${ws}public:${ws}int vb;((${ws}VB & operator=\\(VB const ?&\\);)|(${ws}VB\\(VB const ?&\\);)|(${ws}VB\\((void|)\\);)|(${ws}int fvb\\((void|)\\);)|(${ws}virtual int vvb\\((void|)\\);))*${ws}\}.*$gdb_prompt $" {
	    pass "ptype VB (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype VB"
	}
	timeout {
	    fail "ptype VB (timeout)"
d152 10
a161 3
    send_gdb "ptype V\n"
    gdb_expect {
	-re "type = class V : public VA, public VB \{${ws}public:${ws}int w;${ws}V & operator=\\(V const ?&\\);${ws}V\\((V const|const V) ?&\\);${ws}V\\((void|)\\);${ws}int f\\((void|)\\);${ws}virtual int vv\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
a163 12
	-re "type = class V : public VA, public VB \{${ws}public:${ws}int w;${ws}int f \\((void|)\\);${ws}virtual int vv \\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype V (aCC)"
	}
	-re "type = class V : public VA, public VB \{${ws}public:${ws}int w;((${ws}V & operator=\\(V const ?&\\);)|(${ws}V\\(V const ?&\\);)|(${ws}V\\((void|)\\);)|(${ws}int f\\((void|)\\);)|(${ws}virtual int vv\\((void|)\\);))*${ws}\}$nl$gdb_prompt $" {
	    pass "ptype V (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype V"
	}
	timeout {
	    fail "ptype V (timeout)"
	}
d166 1
a166 2
    # The format of a g++ virtual base pointer.
    set vbptr "(_vb\[$.\]|__vb_)\[0-9\]?"
d168 3
a170 26
    send_gdb "ptype A\n"
    gdb_expect {
	-re "type = class A : public virtual V \{${ws}private:${ws}V \\*${vbptr}V;${ws}int a;${ws}public:${ws}A & operator=\\(A const ?&\\);${ws}A\\(int, A const ?&\\);${ws}A\\(int\\);${ws}virtual int f\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype A"
	}
	-re "type = class A : public virtual V \{${ws}private:${ws}int a;${ws}public:${ws}A & operator=\\(A const ?&\\);${ws}A\\((A const|const A) ?&\\);${ws}A\\((void|)\\);${ws}virtual int f\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype A"
	}
        -re "type = class A : public virtual V \{${ws}private:${ws}int a;${ws}public:${ws}virtual int f\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
            pass "ptype A (aCC)"
        }
	-re "type = class A : public virtual V \{${ws}private:${ws}V \\*${vbptr}V;${ws}int a;${ws}public:((${ws}A & operator=\\(A const ?&\\);)|(${ws}A\\(int, A const ?&\\);)|(${ws}A\\(int\\);)|(${ws}virtual int f\\((void|)\\);))*${ws}\}$nl$gdb_prompt $" {
	    pass "ptype A (obsolescent gcc or gdb)"
	}
	-re "type = class A : public virtual V \{${ws}private:${ws}V \\*${vbptr}FOO;${ws}int a;${ws}public:${ws}virtual int f.void.;${ws}\}$nl$gdb_prompt $" {
	    # This happens because the type is defined only after it is
	    # too late.
	    fail "ptype A (known failure with gcc cygnus-2.4.5-930417)"
	    # Many of the rest of these tests have the same problem.
	    return 0
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype A"
	}
	timeout {
	    fail "ptype A (timeout)"
d174 5
a178 19
    send_gdb "ptype B\n"
    gdb_expect {
	-re "type = class B : public A \{${ws}private:${ws}int b;${ws}public:${ws}B & operator=\\(B const ?&\\);${ws}B\\(int, B const ?&\\);${ws}B\\(int\\);${ws}virtual int f\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype B"
	}
	-re "type = class B : public A \{${ws}private:${ws}int b;${ws}public:${ws}B & operator=\\(B const ?&\\);${ws}B\\((B const|const B) ?&\\);${ws}B\\((void|)\\);${ws}virtual int f\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype B"
	}
	-re "type = class B : public A \{${ws}private:${ws}int b;${ws}public:${ws}virtual int f \\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype B (aCC)"
	}
	-re "type = class B : public A \{${ws}private:${ws}int b;${ws}public:((${ws}B & operator=\\(B const ?&\\);)|(${ws}B\\(int, B const ?&\\);)|(${ws}B\\(int\\);)|(${ws}virtual int f\\((void|)\\);))*${ws}\}$nl$gdb_prompt $" {
	    pass "ptype B (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype B"
	}
	timeout {
	    fail "ptype B (timeout)"
d182 5
a186 19
    send_gdb "ptype C\n"
    gdb_expect {
	-re "type = class C : public virtual V \{${ws}private:${ws}V \\*${vbptr}V;${ws}public:${ws}int c;${ws}C & operator=\\(C const ?&\\);${ws}C\\(int, C const ?&\\);${ws}C\\(int\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype C"
	}
	-re "type = class C : public virtual V \{${ws}public:${ws}int c;${ws}C & operator=\\(C const ?&\\);${ws}C\\((C const|const C) ?&\\);${ws}C\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype C"
	}
        -re "type = class C : public virtual V \{${ws}public:${ws}int c;${ws}\}$nl$gdb_prompt $" {
            pass "ptype C (aCC)"
        }
	-re "type = class C : public virtual V \{${ws}private:${ws}V \\*${vbptr}V;${ws}public:${ws}int c;((${ws}C & operator=\\(C const ?&\\);)|(${ws}C\\(int, C const ?&\\);)|(${ws}C\\(int\\);))*${ws}\}$nl$gdb_prompt $" {
	    pass "ptype C (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype C"
	}
	timeout {
	    fail "ptype C (timeout)"
d190 5
a194 16
    send_gdb "ptype AD\n"
    gdb_expect {
	-re "type = class AD \{${ws}public:${ws}AD & operator=\\(AD const ?&\\);${ws}AD\\((AD const|const AD) ?&\\);${ws}AD\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype AD"
	}
	-re "type = class AD \{${ws}public:${ws}virtual int vg \\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype AD (aCC)"
	}
	-re "type = class AD \{${ws}public:((${ws}AD & operator=\\(AD const ?&\\);)|(${ws}AD\\(AD const ?&\\);)|(${ws}AD\\((void|)\\);)|(${ws}virtual int vg\\((void|)\\);))*${ws}\}$nl$gdb_prompt $" {
	    pass "ptype AD (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype AD"
	}
	timeout {
	    fail "ptype AD (timeout)"
d198 5
a202 19
    send_gdb "ptype D\n"
    gdb_expect {
	-re "type = class D : public AD, public virtual V \{${ws}private:${ws}V \\*${vbptr}V;${ws}public:${ws}int d;${ws}D & operator=\\(D const ?&\\);${ws}D\\(int, D const ?&\\);${ws}D\\(int\\);${ws}static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype D"
	}
	-re "type = class D : public AD, public virtual V \{${ws}public:${ws}int d;${ws}D & operator=\\(D const ?&\\);${ws}D\\((D const|const D) ?&\\);${ws}D\\((void|)\\);${ws}static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype D"
	}
        -re "type = class D : public AD, public virtual V \{${ws}public:${ws}int d;${ws}static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
            pass "ptype D (aCC)"
        }
	-re "type = class D : public AD, public virtual V \{${ws}private:${ws}V \\*${vbptr}V;${ws}public:${ws}int d;((${ws}D & operator=\\(D const ?&\\);)|(${ws}D\\(int, D const ?&\\);)|(${ws}D\\(int\\);)|(${ws}static void s\\((void|)\\);)|(${ws}virtual int vg\\((void|)\\);)|(${ws}virtual int vd\\((void|)\\);)|(${ws}int fd\\((void|)\\);))*${ws}\}$nl$gdb_prompt $" {
	    pass "ptype D (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype D"
	}
	timeout {
	    fail "ptype D (timeout)"
d206 14
a219 19
    send_gdb "ptype E\n"
    gdb_expect {
	-re "type = class E : public B, public virtual V, public D, public C \{${ws}public:${ws}int e;${ws}E & operator=\\(E const ?&\\);${ws}E\\(int, E const ?&\\);${ws}E\\(int\\);${ws}virtual int f\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vv\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype E"
	}
	-re "type = class E : public B, public virtual V, public D, public C \{${ws}public:${ws}int e;${ws}E & operator=\\(E const ?&\\);${ws}E\\((E const|const E) ?&\\);${ws}E\\((void|)\\);${ws}virtual int f\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vv\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype E"
	}
	-re "type = class E : public B, public virtual V, public D, public C \{${ws}public:${ws}int e;${ws}virtual int f \\((void|)\\);${ws}virtual int vg \\((void|)\\);${ws}virtual int vv \\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype E (aCC)"
	}
	-re "type = class E : public B, public virtual V, public D, public C \{${ws}public:${ws}int e;((${ws}E & operator=\\(E const ?&\\);)|(${ws}E\\(int, E const ?&\\);)|(${ws}E\\(int\\);)|(${ws}virtual int f\\((void|)\\);)|(${ws}virtual int vg\\((void|)\\);)|(${ws}virtual int vv\\((void|)\\);))*${ws}\}$nl$gdb_prompt $" {
	    pass "ptype E (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype E"
	}
	timeout {
	    fail "ptype E (timeout)"
d223 5
a227 19
    send_gdb "ptype dd\n"
    gdb_expect {
	-re "type = class D : public AD, public virtual V \{${ws}private:${ws}V \\*${vbptr}V;${ws}public:${ws}int d;${ws}D & operator=\\(D const ?&\\);${ws}D\\(int, D const ?&\\);${ws}D\\(int\\);${ws}static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype dd"
	}
	-re "type = class D : public AD, public virtual V \{${ws}public:${ws}int d;${ws}D & operator=\\(D const ?&\\);${ws}D\\((D const|const D) ?&\\);${ws}D\\((void|)\\);${ws}static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype dd"
	}
        -re "type = class D : public AD, public virtual V \{${ws}public:${ws}int d;${ws}static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
            pass "ptype dd (aCC)"
        }
	-re "type = class D : public AD, public virtual V \{${ws}private:${ws}V \\*${vbptr}V;${ws}public:${ws}int d;((${ws}D & operator=\\(D const ?&\\);)|(${ws}D\\(int, D const ?&\\);)|(${ws}D\\(int\\);)|(${ws}static void s\\((void|)\\);)|(${ws}virtual int vg\\((void|)\\);)|(${ws}virtual int vd\\((void|)\\);)|(${ws}int fd\\((void|)\\);))*${ws}\}$nl$gdb_prompt $" {
	    pass "ptype dd (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype dd"
	}
	timeout {
	    fail "ptype dd (timeout)"
d231 5
a235 19
    send_gdb "ptype ppd\n"
    gdb_expect {
	-re "type = class D : public AD, public virtual V \{${ws}private:${ws}V \\*${vbptr}V;${ws}public:${ws}int d;${ws}D & operator=\\(D const ?&\\);${ws}D\\(int, D const ?&\\);${ws}D\\(int\\);${ws}static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype ppd"
	}
	-re "type = class D : public AD, public virtual V \{${ws}public:${ws}int d;${ws}D & operator=\\(D const ?&\\);${ws}D\\((D const|const D) ?&\\);${ws}D\\((void|)\\);${ws}static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype ppd"
	}
        -re "type = class D : public AD, public virtual V \{${ws}public:${ws}int d;${ws}static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);${ws}\} \[*\]+$nl$gdb_prompt $" {
            pass "ptype ppd (aCC)"
        }
	-re "type = class D : public AD, public virtual V \{${ws}private:${ws}V \\*${vbptr}V;${ws}public:${ws}int d;((${ws}D & operator=\\(D const ?&\\);)|(${ws}D\\(int, D const ?&\\);)|(${ws}D\\(int\\);)|(${ws}static void s\\((void|)\\);)|(${ws}virtual int vg\\((void|)\\);)|(${ws}virtual int vd\\((void|)\\);)|(${ws}int fd\\((void|)\\);))*${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype ppd (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype ppd"
	}
	timeout {
	    fail "ptype ppd (timeout)"
d239 5
a243 16
    send_gdb "ptype pAd\n"
    gdb_expect {
	-re "type = class AD \{${ws}public:${ws}AD & operator=\\(AD const ?&\\);${ws}AD\\((AD const|const AD) ?&\\);${ws}AD\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pAd"
	}
	-re "type = class AD \{${ws}public:${ws}virtual int vg \\((void|)\\);${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pAd (aCC)"
	}
	-re "type = class AD \{${ws}public:((${ws}AD & operator=\\(AD const ?&\\);)|(${ws}AD\\(AD const ?&\\);)|(${ws}AD\\((void|)\\);)|(${ws}virtual int vg\\((void|)\\);))*${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pAd (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype pAd"
	}
	timeout {
	    fail "ptype pAd (timeout)"
d247 13
a259 19
    send_gdb "ptype a\n"
    gdb_expect {
	-re "type = class A : public virtual V \{${ws}private:${ws}V \\*${vbptr}V;${ws}int a;${ws}public:${ws}A & operator=\\(A const ?&\\);${ws}A\\(int, A const ?&\\);${ws}A\\(int\\);${ws}virtual int f\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype a"
	}
	-re "type = class A : public virtual V \{${ws}private:${ws}int a;${ws}public:${ws}A & operator=\\(A const ?&\\);${ws}A\\((A const|const A) ?&\\);${ws}A\\((void|)\\);${ws}virtual int f\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype a"
	}
        -re "type = class A : public virtual V \{${ws}private:${ws}int a;${ws}public:${ws}virtual int f\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
            pass "ptype a (aCC)"
        }
	-re "type = class A : public virtual V \{${ws}private:${ws}V \\*${vbptr}V;${ws}int a;${ws}public:((${ws}A & operator=\\(A const ?&\\);)|(${ws}A\\(int, A const ?&\\);)|(${ws}A\\(int\\);)|(${ws}virtual int f\\((void|)\\);))*${ws}\}$nl$gdb_prompt $" {
	    pass "ptype a (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype a"
	}
	timeout {
	    fail "ptype a (timeout)"
d263 4
a266 3
    send_gdb "ptype b\n"
    gdb_expect {
	-re "type = class B : public A \{${ws}private:${ws}int b;${ws}public:${ws}B & operator=\\(B const ?&\\);${ws}B\\(int, B const ?&\\);${ws}B\\(int\\);${ws}virtual int f\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
d269 7
a275 2
	-re "type = class B : public A \{${ws}private:${ws}int b;${ws}public:${ws}B & operator=\\(B const ?&\\);${ws}B\\((B const|const B) ?&\\);${ws}B\\((void|)\\);${ws}virtual int f\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype b"
d277 14
a290 11
	-re "type = class B : public A \{${ws}private:${ws}int b;${ws}public:${ws}virtual int f \\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype b (aCC)"
	}
	-re "type = class B : public A \{${ws}private:${ws}int b;${ws}public:((${ws}B & operator=\\(B const ?&\\);)|(${ws}B\\(int, B const ?&\\);)|(${ws}B\\(int\\);)|(${ws}virtual int f\\((void|)\\);))*${ws}\}$nl$gdb_prompt $" {
	    pass "ptype b (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype b"
	}
	timeout {
	    fail "ptype b (timeout)"
d294 4
a297 6
    send_gdb "ptype c\n"
    gdb_expect {
	-re "type = class C : public virtual V \{${ws}private:${ws}V \\*${vbptr}V;${ws}public:${ws}int c;${ws}C & operator=\\(C const ?&\\);${ws}C\\(int, C const ?&\\);${ws}C\\(int\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype c"
	}
	-re "type = class C : public virtual V \{${ws}public:${ws}int c;${ws}C & operator=\\(C const ?&\\);${ws}C\\((C const|const C) ?&\\);${ws}C\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
a299 12
        -re "type = class C : public virtual V \{${ws}public:${ws}int c;${ws}\}$nl$gdb_prompt $" {
            pass "ptype c (aCC)"
        }
	-re "type = class C : public virtual V \{${ws}private:${ws}V \\*${vbptr}V;${ws}public:${ws}int c;((${ws}C & operator=\\(C const ?&\\);)|(${ws}C\\(int, C const ?&\\);)|(${ws}C\\(int\\);))*${ws}\}$nl$gdb_prompt $" {
	    pass "ptype c (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype c"
	}
	timeout {
	    fail "ptype c (timeout)"
	}
d302 10
a311 19
    send_gdb "ptype d\n"
    gdb_expect {
	-re "type = class D : public AD, public virtual V \{${ws}private:${ws}V \\*${vbptr}V;${ws}public:${ws}int d;${ws}D & operator=\\(D const ?&\\);${ws}D\\(int, D const ?&\\);${ws}D\\(int\\);${ws}static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype d"
	}
	-re "type = class D : public AD, public virtual V \{${ws}public:${ws}int d;${ws}D & operator=\\(D const ?&\\);${ws}D\\((D const|const D) ?&\\);${ws}D\\((void|)\\);${ws}static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype d"
	}
        -re "type = class D : public AD, public virtual V \{${ws}public:${ws}int d;${ws}static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
            pass "ptype d (aCC)"
        }
	-re "type = class D : public AD, public virtual V \{${ws}private:${ws}V \\*${vbptr}V;${ws}public:${ws}int d;((${ws}D & operator=\\(D const ?&\\);)|(${ws}D\\(int, D const ?&\\);)|(${ws}D\\(int\\);)|(${ws}static void s\\((void|)\\);)|(${ws}virtual int vg\\((void|)\\);)|(${ws}virtual int vd\\((void|)\\);)|(${ws}int fd\\((void|)\\);))*${ws}\}$nl$gdb_prompt $" {
	    pass "ptype d (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype d"
	}
	timeout {
	    fail "ptype d (timeout)"
d315 6
a320 19
    send_gdb "ptype e\n"
    gdb_expect {
	-re "type = class E : public B, public virtual V, public D, public C \{${ws}public:${ws}int e;${ws}E & operator=\\(E const ?&\\);${ws}E\\(int, E const ?&\\);${ws}E\\(int\\);${ws}virtual int f\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vv\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype e"
	}
	-re "type = class E : public B, public virtual V, public D, public C \{${ws}public:${ws}int e;${ws}E & operator=\\(E const ?&\\);${ws}E\\((E const|const E) ?&\\);${ws}E\\((void|)\\);${ws}virtual int f\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vv\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype e"
	}
	-re "type = class E : public B, public virtual V, public D, public C \{${ws}public:${ws}int e;${ws}virtual int f \\((void|)\\);${ws}virtual int vg \\((void|)\\);${ws}virtual int vv \\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype e (aCC)"
	}
	-re "type = class E : public B, public virtual V, public D, public C \{${ws}public:${ws}int e;((${ws}E & operator=\\(E const ?&\\);)|(${ws}E\\(int, E const ?&\\);)|(${ws}E\\(int\\);)|(${ws}virtual int f\\((void|)\\);)|(${ws}virtual int vg\\((void|)\\);)|(${ws}virtual int vv\\((void|)\\);))*${ws}\}$nl$gdb_prompt $" {
	    pass "ptype e (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype e"
	}
	timeout {
	    fail "ptype e (timeout)"
d324 5
a328 16
    send_gdb "ptype v\n"
    gdb_expect {
	-re "type = class V : public VA, public VB \{${ws}public:${ws}int w;${ws}V & operator=\\(V const ?&\\);${ws}V\\((V const|const V) ?&\\);${ws}V\\((void|)\\);${ws}int f\\((void|)\\);${ws}virtual int vv\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype v"
	}
	-re "type = class V : public VA, public VB \{${ws}public:${ws}int w;${ws}int f \\((void|)\\);${ws}virtual int vv \\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype v (aCC)"
	}
	-re "type = class V : public VA, public VB \{${ws}public:${ws}int w;((${ws}V & operator=\\(V const ?&\\);)|(${ws}V\\(V const ?&\\);)|(${ws}V\\((void|)\\);)|(${ws}int f\\((void|)\\);)|(${ws}virtual int vv\\((void|)\\);))*${ws}\}$nl$gdb_prompt $" {
	    pass "ptype v (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype v"
	}
	timeout {
	    fail "ptype v (timeout)"
d332 13
a344 16
    send_gdb "ptype vb\n"
    gdb_expect {
	-re "type = class VB \{${ws}public:${ws}int vb;${ws}VB & operator=\\(VB const ?&\\);${ws}VB\\((VB const|const VB) ?&\\);${ws}VB\\((void|)\\);${ws}int fvb\\((void|)\\);${ws}virtual int vvb\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype vb"
	}
	-re "type = class VB \{${ws}public:${ws}int vb;${ws}int fvb \\((void|)\\);${ws}virtual int vvb \\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype vb (aCC)"
	}
	-re "type = class VB \{${ws}public:${ws}int vb;((${ws}VB & operator=\\(VB const ?&\\);)|(${ws}VB\\(VB const ?&\\);)|(${ws}VB\\((void|)\\);)|(${ws}int fvb\\((void|)\\);)|(${ws}virtual int vvb\\((void|)\\);))*${ws}\}$nl$gdb_prompt $" {
	    pass "ptype vb (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype vb"
	}
	timeout {
	    fail "ptype vb (timeout)"
d348 5
a352 19
    send_gdb "ptype pAa\n"
    gdb_expect {
	-re "type = class A : public virtual V \{${ws}private:${ws}V \\*${vbptr}V;${ws}int a;${ws}public:${ws}A & operator=\\(A const ?&\\);${ws}A\\(int, A const ?&\\);${ws}A\\(int\\);${ws}virtual int f\\((void|)\\);${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pAa"
	}
	-re "type = class A : public virtual V \{${ws}private:${ws}int a;${ws}public:${ws}A & operator=\\(A const ?&\\);${ws}A\\((A const|const A) ?&\\);${ws}A\\((void|)\\);${ws}virtual int f\\((void|)\\);${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pAa"
	}
        -re "type = class A : public virtual V \{${ws}private:${ws}int a;${ws}public:${ws}virtual int f\\((void|)\\);${ws}\} \[*\]+$nl$gdb_prompt $" {
            pass "ptype pAa (aCC)"
        }
	-re "type = class A : public virtual V \{${ws}private:${ws}V \\*${vbptr}V;${ws}int a;${ws}public:((${ws}A & operator=\\(A const ?&\\);)|(${ws}A\\(int, A const ?&\\);)|(${ws}A\\(int\\);)|(${ws}virtual int f\\((void|)\\);))*${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pAa (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype pAa"
	}
	timeout {
	    fail "ptype pAa (timeout)"
d356 5
a360 19
    send_gdb "ptype pAe\n"
    gdb_expect {
	-re "type = class A : public virtual V \{${ws}private:${ws}V \\*${vbptr}V;${ws}int a;${ws}public:${ws}A & operator=\\(A const ?&\\);${ws}A\\(int, A const ?&\\);${ws}A\\(int\\);${ws}virtual int f\\((void|)\\);${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pAe"
	}
	-re "type = class A : public virtual V \{${ws}private:${ws}int a;${ws}public:${ws}A & operator=\\(A const ?&\\);${ws}A\\((A const|const A) ?&\\);${ws}A\\((void|)\\);${ws}virtual int f\\((void|)\\);${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pAe"
	}
        -re "type = class A : public virtual V \{${ws}private:${ws}int a;${ws}public:${ws}virtual int f\\((void|)\\);${ws}\} \[*\]+$nl$gdb_prompt $" {
            pass "ptype pAe (aCC)"
	}
	-re "type = class A : public virtual V \{${ws}private:${ws}V \\*${vbptr}V;${ws}int a;${ws}public:((${ws}A & operator=\\(A const ?&\\);)|(${ws}A\\(int, A const ?&\\);)|(${ws}A\\(int\\);)|(${ws}virtual int f\\((void|)\\);))*${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pAe (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype pAe"
	}
	timeout {
	    fail "ptype pAe (timeout)"
d364 5
a368 19
    send_gdb "ptype pBe\n"
    gdb_expect {
	-re "type = class B : public A \{${ws}private:${ws}int b;${ws}public:${ws}B & operator=\\(B const ?&\\);${ws}B\\(int, B const ?&\\);${ws}B\\(int\\);${ws}virtual int f\\((void|)\\);${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pBe"
	}
	-re "type = class B : public A \{${ws}private:${ws}int b;${ws}public:${ws}B & operator=\\(B const ?&\\);${ws}B\\((B const|const B) ?&\\);${ws}B\\((void|)\\);${ws}virtual int f\\((void|)\\);${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pBe"
	}
	-re "type = class B : public A \{${ws}private:${ws}int b;${ws}public:${ws}virtual int f \\((void|)\\);${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pBe (aCC)"
	}
	-re "type = class B : public A \{${ws}private:${ws}int b;${ws}public:((${ws}B & operator=\\(B const ?&\\);)|(${ws}B\\(int, B const ?&\\);)|(${ws}B\\(int\\);)|(${ws}virtual int f\\((void|)\\);))*${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pBe (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype pBe"
	}
	timeout {
	    fail "ptype pBe (timeout)"
d372 4
a375 6
    send_gdb "ptype pDd\n"
    gdb_expect {
	-re "type = class D : public AD, public virtual V \{${ws}private:${ws}V \\*${vbptr}V;${ws}public:${ws}int d;${ws}D & operator=\\(D const ?&\\);${ws}D\\(int, D const ?&\\);${ws}D\\(int\\);${ws}static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pDd"
	}
	-re "type = class D : public AD, public virtual V \{${ws}public:${ws}int d;${ws}D & operator=\\(D const ?&\\);${ws}D\\((D const|const D) ?&\\);${ws}D\\((void|)\\);${ws}static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);${ws}\} \[*\]+$nl$gdb_prompt $" {
a377 12
        -re "type = class D : public AD, public virtual V \{${ws}public:${ws}int d;${ws}static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);${ws}\} \[*\]+$nl$gdb_prompt $" {
            pass "ptype pDd (aCC)"
        }
	-re "type = class D : public AD, public virtual V \{${ws}private:${ws}V \\*${vbptr}V;${ws}public:${ws}int d;((${ws}D & operator=\\(D const ?&\\);)|(${ws}D\\(int, D const ?&\\);)|(${ws}D\\(int\\);)|(${ws}static void s\\((void|)\\);)|(${ws}virtual int vg\\((void|)\\);)|(${ws}virtual int vd\\((void|)\\);)|(${ws}int fd\\((void|)\\);))*${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pDd (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype pDd"
	}
	timeout {
	    fail "ptype pDd (timeout)"
	}
d380 4
a383 6
    send_gdb "ptype pDe\n"
    gdb_expect {
	-re "type = class D : public AD, public virtual V \{${ws}private:${ws}V \\*${vbptr}V;${ws}public:${ws}int d;${ws}D & operator=\\(D const ?&\\);${ws}D\\(int, D const ?&\\);${ws}D\\(int\\);${ws}static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pDe"
	}
	-re "type = class D : public AD, public virtual V \{${ws}public:${ws}int d;${ws}D & operator=\\(D const ?&\\);${ws}D\\((D const|const D) ?&\\);${ws}D\\((void|)\\);${ws}static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);${ws}\} \[*\]+$nl$gdb_prompt $" {
a385 12
        -re "type = class D : public AD, public virtual V \{${ws}public:${ws}int d;${ws}static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);${ws}\} \[*\]+$nl$gdb_prompt $" {
            pass "ptype pDe (aCC)"
        }
	-re "type = class D : public AD, public virtual V \{${ws}private:${ws}V \\*${vbptr}V;${ws}public:${ws}int d;((${ws}D & operator=\\(D const ?&\\);)|(${ws}D\\(int, D const ?&\\);)|(${ws}D\\(int\\);)|(${ws}static void s\\((void|)\\);)|(${ws}virtual int vg\\((void|)\\);)|(${ws}virtual int vd\\((void|)\\);)|(${ws}int fd\\((void|)\\);))*${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pDe (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype pDe"
	}
	timeout {
	    fail "ptype pDe (timeout)"
	}
d388 9
a396 18
    send_gdb "ptype pVa\n"
    gdb_expect {
	-re "type = class V : public VA, public VB \{${ws}public:${ws}int w;${ws}V & operator=\\(V const ?&\\);${ws}V\\((V const|const V) ?&\\);${ws}V\\((void|)\\);${ws}int f\\((void|)\\);${ws}virtual int vv\\((void|)\\);${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pVa"
	}
	-re "type = class V : public VA, public VB \{${ws}public:${ws}int w;${ws}int f \\((void|)\\);${ws}virtual int vv \\((void|)\\);${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pVa (aCC)"
	}
	-re "type = class V : public VA, public VB \{${ws}public:${ws}int w;((${ws}V & operator=\\(V const ?&\\);)|(${ws}V\\(V const ?&\\);)|(${ws}V\\((void|)\\);)|(${ws}int f\\((void|)\\);)|(${ws}virtual int vv\\((void|)\\);))*${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pVa (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype pVa"
	}
	timeout {
	    fail "ptype pVa (timeout)"
	}
    }
d398 3
a400 16
    send_gdb "ptype pVv\n"
    gdb_expect {
	-re "type = class V : public VA, public VB \{${ws}public:${ws}int w;${ws}V & operator=\\(V const ?&\\);${ws}V\\((V const|const V) ?&\\);${ws}V\\((void|)\\);${ws}int f\\((void|)\\);${ws}virtual int vv\\((void|)\\);${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pVv"
	}
	-re "type = class V : public VA, public VB \{${ws}public:${ws}int w;${ws}int f \\((void|)\\);${ws}virtual int vv \\((void|)\\);${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pVv (aCC)"
	}
	-re "type = class V : public VA, public VB \{${ws}public:${ws}int w;((${ws}V & operator=\\(V const ?&\\);)|(${ws}V\\(V const ?&\\);)|(${ws}V\\((void|)\\);)|(${ws}int f\\((void|)\\);)|(${ws}virtual int vv\\((void|)\\);))*${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pVv (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype pVv"
	}
	timeout {
	    fail "ptype pVv (timeout)"
d404 1
a404 18
    send_gdb "ptype pVe\n"
    gdb_expect {
	-re "type = class V : public VA, public VB \{${ws}public:${ws}int w;${ws}V & operator=\\(V const ?&\\);${ws}V\\((V const|const V) ?&\\);${ws}V\\((void|)\\);${ws}int f\\((void|)\\);${ws}virtual int vv\\((void|)\\);${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pVe"
	}
	-re "type = class V : public VA, public VB \{${ws}public:${ws}int w;${ws}int f \\((void|)\\);${ws}virtual int vv \\((void|)\\);${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pVe (aCC)"
	}
	-re "type = class V : public VA, public VB \{${ws}public:${ws}int w;((${ws}V & operator=\\(V const ?&\\);)|(${ws}V\\(V const ?&\\);)|(${ws}V\\((void|)\\);)|(${ws}int f\\((void|)\\);)|(${ws}virtual int vv\\((void|)\\);))*${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pVe (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype pVe"
	}
	timeout {
	    fail "ptype pVe (timeout)"
	}
    }
d406 3
a408 16
    send_gdb "ptype pVd\n"
    gdb_expect {
	-re "type = class V : public VA, public VB \{${ws}public:${ws}int w;${ws}V & operator=\\(V const ?&\\);${ws}V\\((V const|const V) ?&\\);${ws}V\\((void|)\\);${ws}int f\\((void|)\\);${ws}virtual int vv\\((void|)\\);${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pVd"
	}
	-re "type = class V : public VA, public VB \{${ws}public:${ws}int w;${ws}int f \\((void|)\\);${ws}virtual int vv \\((void|)\\);${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pVd (aCC)"
	}
	-re "type = class V : public VA, public VB \{${ws}public:${ws}int w;((${ws}V & operator=\\(V const ?&\\);)|(${ws}V\\(V const ?&\\);)|(${ws}V\\((void|)\\);)|(${ws}int f\\((void|)\\);)|(${ws}virtual int vv\\((void|)\\);))*${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pVd (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype pVd"
	}
	timeout {
	    fail "ptype pVd (timeout)"
d412 1
a412 18
    send_gdb "ptype pADe\n"
    gdb_expect {
	-re "type = class AD \{${ws}public:${ws}AD & operator=\\(AD const ?&\\);${ws}AD\\((AD const|const AD) ?&\\);${ws}AD\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pADe"
	}
	-re "type = class AD \{${ws}public:${ws}virtual int vg \\((void|)\\);${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pADe (aCC)"
	}
	-re "type = class AD \{${ws}public:((${ws}AD & operator=\\(AD const ?&\\);)|(${ws}AD\\(AD const ?&\\);)|(${ws}AD\\((void|)\\);)|(${ws}virtual int vg\\((void|)\\);))*${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pADe (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype pADe"
	}
	timeout {
	    fail "ptype pADe (timeout)"
	}
    }
d414 2
a415 6
    send_gdb "ptype pEe\n"
    gdb_expect {
	-re "type = class E : public B, public virtual V, public D, public C \{${ws}public:${ws}int e;${ws}E & operator=\\(E const ?&\\);${ws}E\\(int, E const ?&\\);${ws}E\\(int\\);${ws}virtual int f\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vv\\((void|)\\);${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pEe"
	}
	-re "type = class E : public B, public virtual V, public D, public C \{${ws}public:${ws}int e;${ws}E & operator=\\(E const ?&\\);${ws}E\\((E const|const E) ?&\\);${ws}E\\((void|)\\);${ws}virtual int f\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vv\\((void|)\\);${ws}\} \[*\]+$nl$gdb_prompt $" {
a417 31
	-re "type = class E : public B, public virtual V, public D, public C \{${ws}public:${ws}int e;${ws}virtual int f \\((void|)\\);${ws}virtual int vg \\((void|)\\);${ws}virtual int vv \\((void|)\\);${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pEe (aCC)"
	}
	-re "type = class E : public B, public virtual V, public D, public C \{${ws}public:${ws}int e;((${ws}E & operator=\\(E const ?&\\);)|(${ws}E\\(int, E const ?&\\);)|(${ws}E\\(int\\);)|(${ws}virtual int f\\((void|)\\);)|(${ws}virtual int vg\\((void|)\\);)|(${ws}virtual int vv\\((void|)\\);))*${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pEe (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype pEe"
	}
	timeout {
	    fail "ptype pEe (timeout)"
	}
    }

    send_gdb "ptype pVB\n"
    gdb_expect {
	-re "type = class VB \{${ws}public:${ws}int vb;${ws}VB & operator=\\(VB const ?&\\);${ws}VB\\((VB const|const VB) ?&\\);${ws}VB\\((void|)\\);${ws}int fvb\\((void|)\\);${ws}virtual int vvb\\((void|)\\);${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pVB"
	}
	-re "type = class VB \{${ws}public:${ws}int vb;${ws}int fvb \\((void|)\\);${ws}virtual int vvb \\((void|)\\);${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pVB (aCC)"
	}
	-re "type = class VB \{${ws}public:${ws}int vb;((${ws}VB & operator=\\(VB const ?&\\);)|(${ws}VB\\(VB const ?&\\);)|(${ws}VB\\((void|)\\);)|(${ws}int fvb\\((void|)\\);)|(${ws}virtual int vvb\\((void|)\\);))*${ws}\} \[*\]+$nl$gdb_prompt $" {
	    pass "ptype pVB (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype pVB"
	}
	timeout {
	    fail "ptype pVB (timeout)"
	}
d421 1
a421 3
#
#  Test calling of virtual functions.
#
a424 1
    global GDB
d433 11
a443 140
    send_gdb "print pAe->f()\n"
    gdb_expect {
	-re ".* = 20$nl$gdb_prompt $" { pass "print pAe->f()" }
	-re "Cannot invoke functions on this machine.*$gdb_prompt $" {
	    fail "print pAe->f() (cannot invoke functions, skipping virtual calls)"
	    return 0
	}
	-re ".*Cannot access memory at address 0x8.*$gdb_prompt $" {
	    fail "print pAe->f() \
(known failure with gcc cygnus-2.4.5-930417, skipping virtual calls)"
	    return 0
	}
        -re "Cannot resolve .* to any overloaded instance.*$gdb_prompt $" {
	    setup_xfail hppa*-*-* CLLbs16899
            fail "print pAe->f()"
	}
	-re ".*$gdb_prompt $" { fail "print pAe->f()" }
	timeout { fail "print pAe->f() (timeout)" }
	eof { fail "print pAe->f() ($GDB dumped core) (FIXME)" ; gdb_virtfunc_restart; return }
    }

    send_gdb "print pAa->f()\n"
    gdb_expect {
	-re ".* = 1$nl$gdb_prompt $" { pass "print pAa->f()" }
        -re "Cannot resolve .* to any overloaded instance.*$gdb_prompt $" {
	    setup_xfail hppa*-*-*  CLLbs16899
	    fail "print pAa->f()"
	}
	-re ".*$gdb_prompt $" { fail "print pAa->f()" }
	timeout { fail "print pAa->f() (timeout)" }
	eof { fail "print pAa->f() ($GDB dumped core) (FIXME)" ; gdb_virtfunc_restart; return }
    }

    send_gdb "print pDe->vg()\n"
    gdb_expect {
	-re ".* = 202$nl$gdb_prompt $" { pass "print pDe->vg()" }
        -re "Cannot resolve .* to any overloaded instance.*$gdb_prompt $" {
	    setup_xfail hppa*-*-*  CLLbs16899
	    fail "print pDe->vg()"
	}
	-re ".*$gdb_prompt $" { fail "print pDe->vg()" }
	timeout { fail "print pDe->vg() (timeout)" }
	eof { fail "print pDe->vg() ($GDB dumped core) (FIXME)" ; gdb_virtfunc_restart; return }
    }

    send_gdb "print pADe->vg()\n"
    gdb_expect {
	-re ".* = 202$nl$gdb_prompt $" { pass "print pADe->vg()" }
        -re "Cannot resolve .* to any overloaded instance.*$gdb_prompt $" {
	    setup_xfail hppa*-*-*  CLLbs16899
	    fail "print pADe->vg()"
	}
	-re ".*$gdb_prompt $" { fail "print pADe->vg()" }
	timeout { fail "print pADe->vg() (timeout)" }
	eof { fail "print pADe->vg() ($GDB dumped core) (FIXME)" ; gdb_virtfunc_restart; return }
    }

    send_gdb "print pDd->vg()\n"
    gdb_expect {
	-re ".* = 101$nl$gdb_prompt $" { pass "print pDd->vg()" }
        -re "Cannot resolve .* to any overloaded instance.*$gdb_prompt $" {
	    setup_xfail hppa*-*-*  CLLbs16899
	    fail "print pDd->vg()"
	}
	-re ".*$gdb_prompt $" { fail "print pDd->vg()" }
	timeout { fail "print pDd->vg() (timeout)" }
	eof { fail "print pDd->vg() ($GDB dumped core) (FIXME)" ; gdb_virtfunc_restart; return }
    }

    send_gdb "print pEe->vvb()\n"
    gdb_expect {
	-re ".* = 411$nl$gdb_prompt $" { pass "print pEe->vvb()" }
        -re "Cannot resolve .* to any overloaded instance.*$gdb_prompt $" {
	    setup_xfail hppa*-*-*  CLLbs16899
	    fail "print pEe->vvb()"
	}
	-re ".*$gdb_prompt $" { fail "print pEe->vvb()" }
	timeout { fail "print pEe->vvb() (timeout)" }
	eof { fail "print pEe->vvb() ($GDB dumped core) (FIXME)" ; gdb_virtfunc_restart; return }
    }

    send_gdb "print pVB->vvb()\n"
    gdb_expect {
	-re ".* = 407$nl$gdb_prompt $" { pass "print pVB->vvb()" }
        -re "Cannot resolve .* to any overloaded instance.*$gdb_prompt $" {
	    setup_xfail hppa*-*-*  CLLbs16899
	    fail "print pVB->vvb()"
	}
	-re ".*$gdb_prompt $" { fail "print pVB->vvb()" }
	timeout { fail "print pVB->vvb() (timeout)" }
	eof { fail "print pVB->vvb() ($GDB dumped core) (FIXME)" ; gdb_virtfunc_restart; return }
    }

    send_gdb "print pBe->vvb()\n"
    gdb_expect {
	-re ".* = 411$nl$gdb_prompt $" { pass "print pBe->vvb()" }
        -re "Cannot resolve .* to any overloaded instance.*$gdb_prompt $" {
	    setup_xfail hppa*-*-*  CLLbs16899
	    fail "print pBe->vvb()"
	}
	-re ".*$gdb_prompt $" { fail "print pBe->vvb()" }
	timeout { fail "print pBe->vvb() (timeout)" }
	eof { fail "print pBe->vvb() ($GDB dumped core) (FIXME)" ; gdb_virtfunc_restart; return }
    }

    send_gdb "print pDe->vvb()\n"
    gdb_expect {
	-re ".* = 411$nl$gdb_prompt $" { pass "print pDe->vvb()" }
        -re "Cannot resolve .* to any overloaded instance.*$gdb_prompt $" {
	    setup_xfail hppa*-*-*  CLLbs16899
	    fail "print pDe->vvb()"
	}
	-re ".*$gdb_prompt $" { fail "print pDe->vvb()" }
	timeout { fail "print pDe->vvb() (timeout)" }
	eof { fail "print pDe->vvb() ($GDB dumped core) (FIXME)" ; gdb_virtfunc_restart; return }
    }

    send_gdb "print pEe->vd()\n"
    gdb_expect {
	-re ".* = 282$nl$gdb_prompt $" { pass "print pEe->vd()" }
        -re "Cannot resolve .* to any overloaded instance.*$gdb_prompt $" {
	    setup_xfail hppa*-*-*  CLLbs16899
	    fail "print pEe->vd()"
	}
	-re ".*$gdb_prompt $" { fail "print pEe->vd()" }
	timeout { fail "print pEe->vd() (timeout)" }
	eof { fail "print pEe->vd() ($GDB dumped core) (FIXME)" ; gdb_virtfunc_restart; return }
    }

    send_gdb "print pEe->fvb()\n"
    gdb_expect {
	-re ".* = 311$nl$gdb_prompt $" { pass "print pEe->fvb()" }
        -re "Cannot resolve .* to any overloaded instance.*$gdb_prompt $" {
	    setup_xfail hppa*-*-*  CLLbs16899
	    fail "print pEe->fvb()"
	}
	-re ".*$gdb_prompt $" { fail "print pEe->fvb()" }
	timeout { fail "print pEe->fvb() (timeout)" }
	eof { fail "print pEe->fvb() ($GDB dumped core) (FIXME)" ; gdb_virtfunc_restart; return }
    }
d477 17
a493 8
    send_gdb "print pEe->D::vg()\n"
    gdb_expect {
	-re ".* = 102$nl$gdb_prompt $" { pass "print pEe->D::vg()" }
	-re "Attempt to take address of value not located in memory.\r\n$gdb_prompt $"
	{ kfail "gdb/1064" "print pEe->D::vg()" }
	-re ".*$gdb_prompt $" { fail "print pEe->D::vg()" }
	timeout { fail "print pEe->D::vg() (timeout)" }
	eof { fail "print pEe->D::vg() ($GDB dumped core) (FIXME)" ; gdb_virtfunc_restart; return }
d500 2
d506 7
a512 2
    gdb_start;
    gdb_virtfunc_init;
a514 1

d517 3
a519 3
    if [ runto 'test_calls' ] then {
	test_virtual_calls
    }
@


1.2.2.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.2.2.2
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d1 1
a1 1
# Copyright 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2001, 2002, 2003, 2004
a21 1
# And rewritten by Michael Chastain <mec.gnu@@mindspring.com>.
d23 2
a24 3
set wsopt	"\[\r\n\t \]*"
set ws		"\[\r\n\t \]+"
set nl		"\[\r\n\]+"
d27 1
a27 1
    strace $tracelevel
d36 6
d46 20
a65 27
# Test ptype of a class.
#
# Different C++ compilers produce different output.  I build up regular
# expressions piece by piece to accommodate all the compilers that I
# have seen: gcc 2.95.3, gcc 3.3.2 (ABI 1), gcc 3.4 prerelease (ABI 2);
# and all the debug formats I have seen: dwarf-2 and stabs+.
#
# A complicated class declaration looks like this:
#
#   class A : public virtual V {	// re_class
#     private:
#       V * _vb$V;			// re_vbptr
#       int a;				// re_fields
#
#     public:				// re_access_methods
#       A & operator=(A const &);	// re_synth_gcc_2
#       A(int, A const &);		// ...
#       A(int);				// ...
#       virtual int f(void);		// re_methods
#   }
#
# RE_CLASS matches the class declaration.  C++ allows multiple ways of
# expressing this.
#
#   struct ... { private: ... };
#   class ... { private: ... };
#   class ... { ... };
d67 1
a67 3
# RE_VBPTR matches the virtual base declarations.  gcc 2.95.3 sometimes
# emits these, but gcc 3.X.Y never emits these.  The name depends on the
# debug format.
a68 19
# RE_FIELDS matches the data fields of the class.
# RE_METHODS matches the methods explicitly declared for the class.
#
# RE_SYNTH_GCC_2 and RE_SYNTH_GCC_3 match the optional synthetic methods
# of the class.  gcc -gstabs+ emits these methods, and gcc -gdwarf-2
# does not.
#
# RE_ACCESS_METHODS is an access specifier after RE_FIELDS and before
# the methods (explicit methods and/or synthetic methods).
# There is also an RE_ACCESS_FIELDS.
#
# When I get HP-UX aCC, I hope that I can just add RE_SYNTH_ACC_NNN.
#
# Yet another twist: with gcc v2, ctor and dtor methods have a hidden
# argument in front, the "in-charge" flag.  With gcc v3, there is no
# hidden argument; instead, there are multiple object functions for
# each ctor and dtor.
#
# -- chastain 2004-01-01
d70 1
a70 1
proc test_one_ptype { command testname re_class re_vbptr re_access_fields re_fields re_access_methods re_methods re_synth_gcc_2 re_synth_gcc_3 re_star } {
a71 1
    global wsopt
d75 130
a204 28
    gdb_test_multiple "$command" "$testname" {
	-re "type = $re_class${wsopt}$re_access_fields${wsopt}$re_fields${wsopt}$re_access_methods${wsopt}$re_methods$nl\}$re_star$nl$gdb_prompt $" {
	    # gcc 2.95.3, dwarf-2, no vbptr
	    # gcc 3.X, abi 1, dwarf-2
	    # gcc 3.X, abi 2, dwarf-2
	    pass "$testname"
	}
	-re "type = $re_class${wsopt}$re_vbptr${wsopt}$re_access_fields${wsopt}$re_fields${wsopt}$re_access_methods${wsopt}$re_methods$nl\}$re_star$nl$gdb_prompt $" {
	    # gcc 2.95.3, dwarf-2, vbptr
	    # TODO: drow says the vbptr is a bug
	    pass "$testname"
	}
	-re "type = $re_class${wsopt}$re_access_fields${wsopt}$re_fields${wsopt}$re_access_methods${wsopt}$re_synth_gcc_2${wsopt}$re_methods$nl\}$re_star$nl$gdb_prompt $" {
	    # gcc 2.95.3, stabs+, no vbptr
	    pass "$testname"
	}
	-re "type = $re_class${wsopt}$re_vbptr${wsopt}$re_access_fields${wsopt}$re_fields${wsopt}$re_access_methods${wsopt}$re_synth_gcc_2${wsopt}$re_methods$nl\}$re_star$nl$gdb_prompt $" {
	    # gcc 2.95.3, stabs+, vbptr
	    # TODO: drow says the vbptr is a bug
	    pass "$testname"
	}
	-re "type = $re_class${wsopt}$re_access_fields${wsopt}$re_fields${wsopt}$re_access_methods${wsopt}$re_synth_gcc_3${wsopt}$re_methods$nl\}$re_star$nl$gdb_prompt $" {
	    # gcc 3.X, abi 1, stabs+
	    pass "$testname"
	}
	-re "type = $re_class${wsopt}$re_access_fields${wsopt}$re_fields${wsopt}$re_access_methods${wsopt}$re_methods${wsopt}$re_synth_gcc_3$nl\}$re_star$nl$gdb_prompt $" {
	    # gcc 3.X, abi 2, stabs+
	    pass "$testname"
d208 459
a666 1
}
d668 18
a685 4
proc test_ptype_of_classes {} {
    global gdb_prompt
    global ws
    global nl
d687 21
a707 1
    # class VA
d709 18
a726 340
    test_one_ptype "ptype VA" "ptype VA" \
	"((struct|class) VA \{${ws}public:|struct VA \{)" \
	"" \
	"" "int va;" \
	"" "" \
	"VA & operator=\\(VA const ?&\\);${ws}VA\\(VA const ?&\\);${ws}VA\\((void|)\\);" \
	"VA & operator=\\(VA const ?&\\);${ws}VA\\(VA const ?&\\);${ws}VA\\((void|)\\);" \
	""

    # class VB

    test_one_ptype "ptype VB" "ptype VB" \
	"((struct|class) VB \{${ws}public:|struct VB \{)" \
	"" \
	"" "int vb;" \
	"" "int fvb\\((void|)\\);${ws}virtual int vvb\\((void|)\\);" \
	"VB & operator=\\(VB const ?&\\);${ws}VB\\(VB const ?&\\);${ws}VB\\((void|)\\);" \
	"VB & operator=\\(VB const ?&\\);${ws}VB\\(VB const ?&\\);${ws}VB\\((void|)\\);" \
	""

    # class V

    test_one_ptype "ptype V" "ptype V" \
	"class V : public VA, public VB \{${ws}public:" \
	"" \
	"" "int w;" \
	"" "int f\\((void|)\\);${ws}virtual int vv\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	""

    # class A

    test_one_ptype "ptype A" "ptype A" \
	"class A : public virtual V \{(${ws}private:|)" \
	"V \\*(_vb.1V|_vb.V);" \
	"" "int a;" \
	"public:" "virtual int f\\((void|)\\);" \
	"A & operator=\\(A const ?&\\);${ws}A\\(int, A const ?&\\);${ws}A\\(int\\);" \
	"A & operator=\\(A const ?&\\);${ws}A\\(A const ?&\\);${ws}A\\(\\);" \
	""

    # class B

    test_one_ptype "ptype B" "ptype B" \
	"class B : public A \{(${ws}private:|)" \
	"V \\*(_vb.1V|_vb.V);" \
	"" "int b;" \
	"public:" "virtual int f\\((void|)\\);" \
	"B & operator=\\(B const ?&\\);${ws}B\\(int, B const ?&\\);${ws}B\\(int\\);" \
	"B & operator=\\(B const ?&\\);${ws}B\\(B const ?&\\);${ws}B\\(\\);" \
	""

    # class C

    test_one_ptype "ptype C" "ptype C" \
	"class C : public virtual V \{(${ws}private:|)" \
	"V \\*(_vb.1V|_vb.V);" \
	"public:" "int c;" \
	"" "" \
	"C & operator=\\(C const ?&\\);${ws}C\\(int, C const ?&\\);${ws}C\\(int\\);" \
	"C & operator=\\(C const ?&\\);${ws}C\\(C const ?&\\);${ws}C\\(\\);" \
	""

    # class AD

    test_one_ptype "ptype AD" "ptype AD" \
	"((struct|class) AD \{${ws}public:|struct AD \{)" \
	"" \
	"" "" \
    	"" "virtual int vg\\((void|)\\);" \
	"AD & operator=\\(AD const ?&\\);${ws}AD\\(AD const ?&\\);${ws}AD\\((void|)\\);" \
	"AD & operator=\\(AD const ?&\\);${ws}AD\\(AD const ?&\\);${ws}AD\\((void|)\\);" \
	""

    # class D

    test_one_ptype "ptype D" "ptype D" \
	"class D : public AD, public virtual V \{(${ws}private:|)" \
    	"V \\*(_vb.1V|_vb.V);" \
    	"public:" "int d;" \
	"" "static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(int, D const ?&\\);${ws}D\\(int\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\(\\);" \
	""

    # class E
    # TODO: E does not show a vbptr for V.  That seems strange.

    test_one_ptype "ptype E" "ptype E" \
	"class E : public B, public virtual V, public D, public C \{(${ws}private:|)" \
	"" \
	"public:" "int e;" \
	"" "virtual int f\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vv\\((void|)\\);" \
	"E & operator=\\(E const ?&\\);${ws}E\\(int, E const ?&\\);${ws}E\\(int\\);" \
	"E & operator=\\(E const ?&\\);${ws}E\\(E const ?&\\);${ws}E\\(\\);" \
	""

    # An instance of D

    test_one_ptype "ptype dd" "ptype dd" \
	"class D : public AD, public virtual V \{(${ws}private:|)" \
    	"V \\*(_vb.1V|_vb.V);" \
    	"public:" "int d;" \
	"" "static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(int, D const ?&\\);${ws}D\\(int\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\(\\);" \
	""

    # An instance of D *

    test_one_ptype "ptype ppd" "ptype ppd" \
	"class D : public AD, public virtual V \{(${ws}private:|)" \
    	"V \\*(_vb.1V|_vb.V);" \
    	"public:" "int d;" \
	"" "static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(int, D const ?&\\);${ws}D\\(int\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\(\\);" \
	" ?\\*"

    # An instance of AD *
    # TODO: this should be named pADd, not pAd.

    test_one_ptype "ptype pAd" "ptype pAd" \
	"((struct|class) AD \{${ws}public:|struct AD \{)" \
	"" \
	"" "" \
    	"" "virtual int vg\\((void|)\\);" \
	"AD & operator=\\(AD const ?&\\);${ws}AD\\(AD const ?&\\);${ws}AD\\((void|)\\);" \
	"AD & operator=\\(AD const ?&\\);${ws}AD\\(AD const ?&\\);${ws}AD\\((void|)\\);" \
	" ?\\*"

    # An instance of A

    test_one_ptype "ptype a" "ptype a" \
	"class A : public virtual V \{(${ws}private:|)" \
	"V \\*(_vb.1V|_vb.V);" \
	"" "int a;" \
	"public:" "virtual int f\\((void|)\\);" \
	"A & operator=\\(A const ?&\\);${ws}A\\(int, A const ?&\\);${ws}A\\(int\\);" \
	"A & operator=\\(A const ?&\\);${ws}A\\(A const ?&\\);${ws}A\\(\\);" \
	""

    # An instance of B

    test_one_ptype "ptype b" "ptype b" \
	"class B : public A \{(${ws}private:|)" \
	"V \\*(_vb.1V|_vb.V);" \
	"" "int b;" \
	"public:" "virtual int f\\((void|)\\);" \
	"B & operator=\\(B const ?&\\);${ws}B\\(int, B const ?&\\);${ws}B\\(int\\);" \
	"B & operator=\\(B const ?&\\);${ws}B\\(B const ?&\\);${ws}B\\(\\);" \
	""

    # An instance of C

    test_one_ptype "ptype c" "ptype c" \
	"class C : public virtual V \{(${ws}private:|)" \
	"V \\*(_vb.1V|_vb.V);" \
	"public:" "int c;" \
	"" "" \
	"C & operator=\\(C const ?&\\);${ws}C\\(int, C const ?&\\);${ws}C\\(int\\);" \
	"C & operator=\\(C const ?&\\);${ws}C\\(C const ?&\\);${ws}C\\(\\);" \
	""

    # An instance of D

    test_one_ptype "ptype d" "ptype d" \
	"class D : public AD, public virtual V \{(${ws}private:|)" \
    	"V \\*(_vb.1V|_vb.V);" \
    	"public:" "int d;" \
	"" "static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(int, D const ?&\\);${ws}D\\(int\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\(\\);" \
	""

    # An instance of E

    test_one_ptype "ptype e" "ptype e" \
	"class E : public B, public virtual V, public D, public C \{(${ws}private:|)" \
	"" \
	"public:" "int e;" \
	"" "virtual int f\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vv\\((void|)\\);" \
	"E & operator=\\(E const ?&\\);${ws}E\\(int, E const ?&\\);${ws}E\\(int\\);" \
	"E & operator=\\(E const ?&\\);${ws}E\\(E const ?&\\);${ws}E\\(\\);" \
	""

    # An instance of V

    test_one_ptype "ptype v" "ptype v" \
	"class V : public VA, public VB \{${ws}public:" \
	"" \
	"" "int w;" \
	"" "int f\\((void|)\\);${ws}virtual int vv\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	""

    # An instance of VB

    test_one_ptype "ptype vb" "ptype vb" \
	"((struct|class) VB \{${ws}public:|struct VB \{)" \
	"" \
	"" "int vb;" \
	"" "int fvb\\((void|)\\);${ws}virtual int vvb\\((void|)\\);" \
	"VB & operator=\\(VB const ?&\\);${ws}VB\\(VB const ?&\\);${ws}VB\\((void|)\\);" \
	"VB & operator=\\(VB const ?&\\);${ws}VB\\(VB const ?&\\);${ws}VB\\((void|)\\);" \
	""

    # An instance of A *

    test_one_ptype "ptype pAa" "ptype pAa" \
	"class A : public virtual V \{(${ws}private:|)" \
	"V \\*(_vb.1V|_vb.V);" \
	"" "int a;" \
	"public:" "virtual int f\\((void|)\\);" \
	"A & operator=\\(A const ?&\\);${ws}A\\(int, A const ?&\\);${ws}A\\(int\\);" \
	"A & operator=\\(A const ?&\\);${ws}A\\(A const ?&\\);${ws}A\\(\\);" \
	" ?\\*"

    # An instance of A *

    test_one_ptype "ptype pAe" "ptype pAe" \
	"class A : public virtual V \{(${ws}private:|)" \
	"V \\*(_vb.1V|_vb.V);" \
	"" "int a;" \
	"public:" "virtual int f\\((void|)\\);" \
	"A & operator=\\(A const ?&\\);${ws}A\\(int, A const ?&\\);${ws}A\\(int\\);" \
	"A & operator=\\(A const ?&\\);${ws}A\\(A const ?&\\);${ws}A\\(\\);" \
	" ?\\*"

    # An instance of B *

    test_one_ptype "ptype pBe" "ptype pBe" \
	"class B : public A \{(${ws}private:|)" \
	"V \\*(_vb.1V|_vb.V);" \
	"" "int b;" \
	"public:" "virtual int f\\((void|)\\);" \
	"B & operator=\\(B const ?&\\);${ws}B\\(int, B const ?&\\);${ws}B\\(int\\);" \
	"B & operator=\\(B const ?&\\);${ws}B\\(B const ?&\\);${ws}B\\(\\);" \
	" ?\\*"

    # An instance of D *

    test_one_ptype "ptype pDd" "ptype pDd" \
	"class D : public AD, public virtual V \{(${ws}private:|)" \
    	"V \\*(_vb.1V|_vb.V);" \
    	"public:" "int d;" \
	"" "static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(int, D const ?&\\);${ws}D\\(int\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\(\\);" \
	" ?\\*"

    # An instance of D *

    test_one_ptype "ptype pDe" "ptype pDe" \
	"class D : public AD, public virtual V \{(${ws}private:|)" \
    	"V \\*(_vb.1V|_vb.V);" \
    	"public:" "int d;" \
	"" "static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(int, D const ?&\\);${ws}D\\(int\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\(\\);" \
	" ?\\*"

    # An instance of V *

    test_one_ptype "ptype pVa" "ptype pVa" \
	"class V : public VA, public VB \{${ws}public:" \
	"" \
	"" "int w;" \
	"" "int f\\((void|)\\);${ws}virtual int vv\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	" ?\\*"

    # An instance of V *

    test_one_ptype "ptype pVv" "ptype pVv" \
	"class V : public VA, public VB \{${ws}public:" \
	"" \
	"" "int w;" \
	"" "int f\\((void|)\\);${ws}virtual int vv\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	" ?\\*"

    # An instance of V *

    test_one_ptype "ptype pVe" "ptype pVe" \
	"class V : public VA, public VB \{${ws}public:" \
	"" \
	"" "int w;" \
	"" "int f\\((void|)\\);${ws}virtual int vv\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	" ?\\*"

    # An instance of V *

    test_one_ptype "ptype pVd" "ptype pVd" \
	"class V : public VA, public VB \{${ws}public:" \
	"" \
	"" "int w;" \
	"" "int f\\((void|)\\);${ws}virtual int vv\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	" ?\\*"

    # An instance of AD *

    test_one_ptype "ptype pADe" "ptype pADe" \
	"((struct|class) AD \{${ws}public:|struct AD \{)" \
	"" \
	"" "" \
    	"" "virtual int vg\\((void|)\\);" \
	"AD & operator=\\(AD const ?&\\);${ws}AD\\(AD const ?&\\);${ws}AD\\((void|)\\);" \
	"AD & operator=\\(AD const ?&\\);${ws}AD\\(AD const ?&\\);${ws}AD\\((void|)\\);" \
	" ?\\*"

    # An instance of E *

    test_one_ptype "ptype pEe" "ptype pEe" \
	"class E : public B, public virtual V, public D, public C \{(${ws}private:|)" \
	"" \
	"public:" "int e;" \
	"" "virtual int f\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vv\\((void|)\\);" \
	"E & operator=\\(E const ?&\\);${ws}E\\(int, E const ?&\\);${ws}E\\(int\\);" \
	"E & operator=\\(E const ?&\\);${ws}E\\(E const ?&\\);${ws}E\\(\\);" \
	" ?\\*"

    # An instance of VB *

    test_one_ptype "ptype pVB" "ptype pVB" \
	"((struct|class) VB \{${ws}public:|struct VB \{)" \
	"" \
	"" "int vb;" \
	"" "int fvb\\((void|)\\);${ws}virtual int vvb\\((void|)\\);" \
	"VB & operator=\\(VB const ?&\\);${ws}VB\\(VB const ?&\\);${ws}VB\\((void|)\\);" \
	"VB & operator=\\(VB const ?&\\);${ws}VB\\(VB const ?&\\);${ws}VB\\((void|)\\);" \
	" ?\\*"
d729 3
a731 1
# Call virtual functions.
d735 1
d744 104
a847 21
    gdb_test "print pAe->f()"   "\\$\[0-9\]+ = 20"
    gdb_test "print pAa->f()"   "\\$\[0-9\]+ = 1"
    gdb_test "print pDe->vg()"  "\\$\[0-9\]+ = 202"
    gdb_test "print pADe->vg()" "\\$\[0-9\]+ = 202"
    gdb_test "print pDd->vg()"  "\\$\[0-9\]+ = 101"
    gdb_test "print pEe->vvb()" "\\$\[0-9\]+ = 411"
    gdb_test "print pVB->vvb()" "\\$\[0-9\]+ = 407"
    gdb_test "print pBe->vvb()" "\\$\[0-9\]+ = 411"
    gdb_test "print pDe->vvb()" "\\$\[0-9\]+ = 411"
    gdb_test "print pEe->vd()"  "\\$\[0-9\]+ = 282"
    gdb_test "print pEe->fvb()" "\\$\[0-9\]+ = 311"

    # more recent results:
    # wrong value "202"
    #   gcc 2.95.3 -gdwarf-2
    #   gcc 2.95.3 -gstabs+
    # attempt to take addres of value not located in memory
    #   gcc 3.3.2 -gdwarf-2
    #   gcc 3.3.2 -gstabs+
    #
    # -- chastain 2003-12-31
d849 6
a854 3
    gdb_test_multiple "print pEe->D::vg()" "print pEe->D::vg()" {
	-re "\\$\[0-9]+ = 102$nl$gdb_prompt $" {
	    pass "print pEe->D::vg()"
d856 11
a866 2
	-re "Attempt to take address of value not located in memory.$nl$gdb_prompt $" {
	    kfail "gdb/1064" "print pEe->D::vg()"
d868 57
a930 2
    global srcdir subdir binfile
    global gdb_prompt
d935 2
a936 4
    gdb_exit
    gdb_start
    gdb_reinitialize_dir $srcdir/$subdir
    gdb_load $binfile
d938 1
a938 2
    gdb_test "set language c++" "" ""
    gdb_test "set width 0" "" ""
a939 1
    runto_main
d942 3
a944 3
    gdb_breakpoint test_calls
    gdb_test "continue" ".*Breakpoint .* test_calls.*" ""
    test_virtual_calls
@


1.2.2.3
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d179 1
a179 1
	"A & operator=\\(A const ?&\\);${ws}A\\(A const ?&\\);${ws}A\\((void|)\\);" \
d190 1
a190 1
	"B & operator=\\(B const ?&\\);${ws}B\\(B const ?&\\);${ws}B\\((void|)\\);" \
d201 1
a201 1
	"C & operator=\\(C const ?&\\);${ws}C\\(C const ?&\\);${ws}C\\((void|)\\);" \
d223 1
a223 1
	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\((void|)\\);" \
d235 1
a235 1
	"E & operator=\\(E const ?&\\);${ws}E\\(E const ?&\\);${ws}E\\((void|)\\);" \
d246 1
a246 1
	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\((void|)\\);" \
d257 1
a257 1
	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\((void|)\\);" \
d280 1
a280 1
	"A & operator=\\(A const ?&\\);${ws}A\\(A const ?&\\);${ws}A\\((void|)\\);" \
d291 1
a291 1
	"B & operator=\\(B const ?&\\);${ws}B\\(B const ?&\\);${ws}B\\((void|)\\);" \
d302 1
a302 1
	"C & operator=\\(C const ?&\\);${ws}C\\(C const ?&\\);${ws}C\\((void|)\\);" \
d313 1
a313 1
	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\((void|)\\);" \
d324 1
a324 1
	"E & operator=\\(E const ?&\\);${ws}E\\(E const ?&\\);${ws}E\\((void|)\\);" \
d357 1
a357 1
	"A & operator=\\(A const ?&\\);${ws}A\\(A const ?&\\);${ws}A\\((void|)\\);" \
d368 1
a368 1
	"A & operator=\\(A const ?&\\);${ws}A\\(A const ?&\\);${ws}A\\((void|)\\);" \
d379 1
a379 1
	"B & operator=\\(B const ?&\\);${ws}B\\(B const ?&\\);${ws}B\\((void|)\\);" \
d390 1
a390 1
	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\((void|)\\);" \
d401 1
a401 1
	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\((void|)\\);" \
d467 1
a467 1
	"E & operator=\\(E const ?&\\);${ws}E\\(E const ?&\\);${ws}E\\((void|)\\);" \
@


1.1
log
@2003-08-22  Michael Chastain  <mec@@shout.net>

	* gdb.cp: New directory.
	* gdb.cp/*: Copy from gdb.c++/*.
	* gdb.c++/*: Remove.
	* Makefile.in: Change gdb.c++ to gdb.cp.
	* configure.in:  Ditto.
	* configure: Regnerate.
@
text
@a736 1
    global gcc_compiled
@


1.1.6.1
log
@merge mainline changes into branch
@
text
@d1 1
a1 1
# Copyright 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2001, 2002, 2003, 2004
d18 3
a21 1
# And rewritten by Michael Chastain <mec.gnu@@mindspring.com>.
d23 2
a24 3
set wsopt	"\[\r\n\t \]*"
set ws		"\[\r\n\t \]+"
set nl		"\[\r\n\]+"
d27 1
a27 1
    strace $tracelevel
d36 6
d46 20
a65 23
# Test ptype of a class.
#
# Different C++ compilers produce different output.  I build up regular
# expressions piece by piece to accommodate all the compilers that I
# have seen: gcc 2.95.3, gcc 3.3.2 (ABI 1), gcc 3.4 prerelease (ABI 2);
# and all the debug formats I have seen: dwarf-2 and stabs+.
#
# A complicated class declaration looks like this:
#
#   class A : public virtual V {	// re_class
#     private:
#       V * _vb$V;			// re_vbptr
#       int a;				// re_fields
#
#     public:				// re_access_methods
#       A & operator=(A const &);	// re_synth_gcc_2
#       A(int, A const &);		// ...
#       A(int);				// ...
#       virtual int f(void);		// re_methods
#   }
#
# RE_CLASS matches the class declaration.  C++ allows multiple ways of
# expressing this.
d67 1
a67 3
#   struct ... { private: ... };
#   class ... { private: ... };
#   class ... { ... };
a68 23
# RE_VBPTR matches the virtual base declarations.  gcc 2.95.3 sometimes
# emits these, but gcc 3.X.Y never emits these.  The name depends on the
# debug format.
#
# RE_FIELDS matches the data fields of the class.
# RE_METHODS matches the methods explicitly declared for the class.
#
# RE_SYNTH_GCC_2 and RE_SYNTH_GCC_3 match the optional synthetic methods
# of the class.  gcc -gstabs+ emits these methods, and gcc -gdwarf-2
# does not.
#
# RE_ACCESS_METHODS is an access specifier after RE_FIELDS and before
# the methods (explicit methods and/or synthetic methods).
# There is also an RE_ACCESS_FIELDS.
#
# When I get HP-UX aCC, I hope that I can just add RE_SYNTH_ACC_NNN.
#
# Yet another twist: with gcc v2, ctor and dtor methods have a hidden
# argument in front, the "in-charge" flag.  With gcc v3, there is no
# hidden argument; instead, there are multiple object functions for
# each ctor and dtor.
#
# -- chastain 2004-01-01
d70 1
a70 1
proc test_one_ptype { command testname re_class re_vbptr re_access_fields re_fields re_access_methods re_methods re_synth_gcc_2 re_synth_gcc_3 re_star } {
a71 1
    global wsopt
d75 552
a626 28
    gdb_test_multiple "$command" "$testname" {
	-re "type = $re_class${wsopt}$re_access_fields${wsopt}$re_fields${wsopt}$re_access_methods${wsopt}$re_methods$nl\}$re_star$nl$gdb_prompt $" {
	    # gcc 2.95.3, dwarf-2, no vbptr
	    # gcc 3.X, abi 1, dwarf-2
	    # gcc 3.X, abi 2, dwarf-2
	    pass "$testname"
	}
	-re "type = $re_class${wsopt}$re_vbptr${wsopt}$re_access_fields${wsopt}$re_fields${wsopt}$re_access_methods${wsopt}$re_methods$nl\}$re_star$nl$gdb_prompt $" {
	    # gcc 2.95.3, dwarf-2, vbptr
	    # TODO: drow says the vbptr is a bug
	    pass "$testname"
	}
	-re "type = $re_class${wsopt}$re_access_fields${wsopt}$re_fields${wsopt}$re_access_methods${wsopt}$re_synth_gcc_2${wsopt}$re_methods$nl\}$re_star$nl$gdb_prompt $" {
	    # gcc 2.95.3, stabs+, no vbptr
	    pass "$testname"
	}
	-re "type = $re_class${wsopt}$re_vbptr${wsopt}$re_access_fields${wsopt}$re_fields${wsopt}$re_access_methods${wsopt}$re_synth_gcc_2${wsopt}$re_methods$nl\}$re_star$nl$gdb_prompt $" {
	    # gcc 2.95.3, stabs+, vbptr
	    # TODO: drow says the vbptr is a bug
	    pass "$testname"
	}
	-re "type = $re_class${wsopt}$re_access_fields${wsopt}$re_fields${wsopt}$re_access_methods${wsopt}$re_synth_gcc_3${wsopt}$re_methods$nl\}$re_star$nl$gdb_prompt $" {
	    # gcc 3.X, abi 1, stabs+
	    pass "$testname"
	}
	-re "type = $re_class${wsopt}$re_access_fields${wsopt}$re_fields${wsopt}$re_access_methods${wsopt}$re_methods${wsopt}$re_synth_gcc_3$nl\}$re_star$nl$gdb_prompt $" {
	    # gcc 3.X, abi 2, stabs+
	    pass "$testname"
d630 37
a666 1
}
d668 18
a685 4
proc test_ptype_of_classes {} {
    global gdb_prompt
    global ws
    global nl
d687 21
a707 1
    # class VA
d709 18
a726 340
    test_one_ptype "ptype VA" "ptype VA" \
	"((struct|class) VA \{${ws}public:|struct VA \{)" \
	"" \
	"" "int va;" \
	"" "" \
	"VA & operator=\\(VA const ?&\\);${ws}VA\\(VA const ?&\\);${ws}VA\\((void|)\\);" \
	"VA & operator=\\(VA const ?&\\);${ws}VA\\(VA const ?&\\);${ws}VA\\((void|)\\);" \
	""

    # class VB

    test_one_ptype "ptype VB" "ptype VB" \
	"((struct|class) VB \{${ws}public:|struct VB \{)" \
	"" \
	"" "int vb;" \
	"" "int fvb\\((void|)\\);${ws}virtual int vvb\\((void|)\\);" \
	"VB & operator=\\(VB const ?&\\);${ws}VB\\(VB const ?&\\);${ws}VB\\((void|)\\);" \
	"VB & operator=\\(VB const ?&\\);${ws}VB\\(VB const ?&\\);${ws}VB\\((void|)\\);" \
	""

    # class V

    test_one_ptype "ptype V" "ptype V" \
	"class V : public VA, public VB \{${ws}public:" \
	"" \
	"" "int w;" \
	"" "int f\\((void|)\\);${ws}virtual int vv\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	""

    # class A

    test_one_ptype "ptype A" "ptype A" \
	"class A : public virtual V \{(${ws}private:|)" \
	"V \\*(_vb.1V|_vb.V);" \
	"" "int a;" \
	"public:" "virtual int f\\((void|)\\);" \
	"A & operator=\\(A const ?&\\);${ws}A\\(int, A const ?&\\);${ws}A\\(int\\);" \
	"A & operator=\\(A const ?&\\);${ws}A\\(A const ?&\\);${ws}A\\((void|)\\);" \
	""

    # class B

    test_one_ptype "ptype B" "ptype B" \
	"class B : public A \{(${ws}private:|)" \
	"V \\*(_vb.1V|_vb.V);" \
	"" "int b;" \
	"public:" "virtual int f\\((void|)\\);" \
	"B & operator=\\(B const ?&\\);${ws}B\\(int, B const ?&\\);${ws}B\\(int\\);" \
	"B & operator=\\(B const ?&\\);${ws}B\\(B const ?&\\);${ws}B\\((void|)\\);" \
	""

    # class C

    test_one_ptype "ptype C" "ptype C" \
	"class C : public virtual V \{(${ws}private:|)" \
	"V \\*(_vb.1V|_vb.V);" \
	"public:" "int c;" \
	"" "" \
	"C & operator=\\(C const ?&\\);${ws}C\\(int, C const ?&\\);${ws}C\\(int\\);" \
	"C & operator=\\(C const ?&\\);${ws}C\\(C const ?&\\);${ws}C\\((void|)\\);" \
	""

    # class AD

    test_one_ptype "ptype AD" "ptype AD" \
	"((struct|class) AD \{${ws}public:|struct AD \{)" \
	"" \
	"" "" \
    	"" "virtual int vg\\((void|)\\);" \
	"AD & operator=\\(AD const ?&\\);${ws}AD\\(AD const ?&\\);${ws}AD\\((void|)\\);" \
	"AD & operator=\\(AD const ?&\\);${ws}AD\\(AD const ?&\\);${ws}AD\\((void|)\\);" \
	""

    # class D

    test_one_ptype "ptype D" "ptype D" \
	"class D : public AD, public virtual V \{(${ws}private:|)" \
    	"V \\*(_vb.1V|_vb.V);" \
    	"public:" "int d;" \
	"" "static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(int, D const ?&\\);${ws}D\\(int\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\((void|)\\);" \
	""

    # class E
    # TODO: E does not show a vbptr for V.  That seems strange.

    test_one_ptype "ptype E" "ptype E" \
	"class E : public B, public virtual V, public D, public C \{(${ws}private:|)" \
	"" \
	"public:" "int e;" \
	"" "virtual int f\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vv\\((void|)\\);" \
	"E & operator=\\(E const ?&\\);${ws}E\\(int, E const ?&\\);${ws}E\\(int\\);" \
	"E & operator=\\(E const ?&\\);${ws}E\\(E const ?&\\);${ws}E\\((void|)\\);" \
	""

    # An instance of D

    test_one_ptype "ptype dd" "ptype dd" \
	"class D : public AD, public virtual V \{(${ws}private:|)" \
    	"V \\*(_vb.1V|_vb.V);" \
    	"public:" "int d;" \
	"" "static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(int, D const ?&\\);${ws}D\\(int\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\((void|)\\);" \
	""

    # An instance of D *

    test_one_ptype "ptype ppd" "ptype ppd" \
	"class D : public AD, public virtual V \{(${ws}private:|)" \
    	"V \\*(_vb.1V|_vb.V);" \
    	"public:" "int d;" \
	"" "static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(int, D const ?&\\);${ws}D\\(int\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\((void|)\\);" \
	" ?\\*"

    # An instance of AD *
    # TODO: this should be named pADd, not pAd.

    test_one_ptype "ptype pAd" "ptype pAd" \
	"((struct|class) AD \{${ws}public:|struct AD \{)" \
	"" \
	"" "" \
    	"" "virtual int vg\\((void|)\\);" \
	"AD & operator=\\(AD const ?&\\);${ws}AD\\(AD const ?&\\);${ws}AD\\((void|)\\);" \
	"AD & operator=\\(AD const ?&\\);${ws}AD\\(AD const ?&\\);${ws}AD\\((void|)\\);" \
	" ?\\*"

    # An instance of A

    test_one_ptype "ptype a" "ptype a" \
	"class A : public virtual V \{(${ws}private:|)" \
	"V \\*(_vb.1V|_vb.V);" \
	"" "int a;" \
	"public:" "virtual int f\\((void|)\\);" \
	"A & operator=\\(A const ?&\\);${ws}A\\(int, A const ?&\\);${ws}A\\(int\\);" \
	"A & operator=\\(A const ?&\\);${ws}A\\(A const ?&\\);${ws}A\\((void|)\\);" \
	""

    # An instance of B

    test_one_ptype "ptype b" "ptype b" \
	"class B : public A \{(${ws}private:|)" \
	"V \\*(_vb.1V|_vb.V);" \
	"" "int b;" \
	"public:" "virtual int f\\((void|)\\);" \
	"B & operator=\\(B const ?&\\);${ws}B\\(int, B const ?&\\);${ws}B\\(int\\);" \
	"B & operator=\\(B const ?&\\);${ws}B\\(B const ?&\\);${ws}B\\((void|)\\);" \
	""

    # An instance of C

    test_one_ptype "ptype c" "ptype c" \
	"class C : public virtual V \{(${ws}private:|)" \
	"V \\*(_vb.1V|_vb.V);" \
	"public:" "int c;" \
	"" "" \
	"C & operator=\\(C const ?&\\);${ws}C\\(int, C const ?&\\);${ws}C\\(int\\);" \
	"C & operator=\\(C const ?&\\);${ws}C\\(C const ?&\\);${ws}C\\((void|)\\);" \
	""

    # An instance of D

    test_one_ptype "ptype d" "ptype d" \
	"class D : public AD, public virtual V \{(${ws}private:|)" \
    	"V \\*(_vb.1V|_vb.V);" \
    	"public:" "int d;" \
	"" "static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(int, D const ?&\\);${ws}D\\(int\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\((void|)\\);" \
	""

    # An instance of E

    test_one_ptype "ptype e" "ptype e" \
	"class E : public B, public virtual V, public D, public C \{(${ws}private:|)" \
	"" \
	"public:" "int e;" \
	"" "virtual int f\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vv\\((void|)\\);" \
	"E & operator=\\(E const ?&\\);${ws}E\\(int, E const ?&\\);${ws}E\\(int\\);" \
	"E & operator=\\(E const ?&\\);${ws}E\\(E const ?&\\);${ws}E\\((void|)\\);" \
	""

    # An instance of V

    test_one_ptype "ptype v" "ptype v" \
	"class V : public VA, public VB \{${ws}public:" \
	"" \
	"" "int w;" \
	"" "int f\\((void|)\\);${ws}virtual int vv\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	""

    # An instance of VB

    test_one_ptype "ptype vb" "ptype vb" \
	"((struct|class) VB \{${ws}public:|struct VB \{)" \
	"" \
	"" "int vb;" \
	"" "int fvb\\((void|)\\);${ws}virtual int vvb\\((void|)\\);" \
	"VB & operator=\\(VB const ?&\\);${ws}VB\\(VB const ?&\\);${ws}VB\\((void|)\\);" \
	"VB & operator=\\(VB const ?&\\);${ws}VB\\(VB const ?&\\);${ws}VB\\((void|)\\);" \
	""

    # An instance of A *

    test_one_ptype "ptype pAa" "ptype pAa" \
	"class A : public virtual V \{(${ws}private:|)" \
	"V \\*(_vb.1V|_vb.V);" \
	"" "int a;" \
	"public:" "virtual int f\\((void|)\\);" \
	"A & operator=\\(A const ?&\\);${ws}A\\(int, A const ?&\\);${ws}A\\(int\\);" \
	"A & operator=\\(A const ?&\\);${ws}A\\(A const ?&\\);${ws}A\\((void|)\\);" \
	" ?\\*"

    # An instance of A *

    test_one_ptype "ptype pAe" "ptype pAe" \
	"class A : public virtual V \{(${ws}private:|)" \
	"V \\*(_vb.1V|_vb.V);" \
	"" "int a;" \
	"public:" "virtual int f\\((void|)\\);" \
	"A & operator=\\(A const ?&\\);${ws}A\\(int, A const ?&\\);${ws}A\\(int\\);" \
	"A & operator=\\(A const ?&\\);${ws}A\\(A const ?&\\);${ws}A\\((void|)\\);" \
	" ?\\*"

    # An instance of B *

    test_one_ptype "ptype pBe" "ptype pBe" \
	"class B : public A \{(${ws}private:|)" \
	"V \\*(_vb.1V|_vb.V);" \
	"" "int b;" \
	"public:" "virtual int f\\((void|)\\);" \
	"B & operator=\\(B const ?&\\);${ws}B\\(int, B const ?&\\);${ws}B\\(int\\);" \
	"B & operator=\\(B const ?&\\);${ws}B\\(B const ?&\\);${ws}B\\((void|)\\);" \
	" ?\\*"

    # An instance of D *

    test_one_ptype "ptype pDd" "ptype pDd" \
	"class D : public AD, public virtual V \{(${ws}private:|)" \
    	"V \\*(_vb.1V|_vb.V);" \
    	"public:" "int d;" \
	"" "static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(int, D const ?&\\);${ws}D\\(int\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\((void|)\\);" \
	" ?\\*"

    # An instance of D *

    test_one_ptype "ptype pDe" "ptype pDe" \
	"class D : public AD, public virtual V \{(${ws}private:|)" \
    	"V \\*(_vb.1V|_vb.V);" \
    	"public:" "int d;" \
	"" "static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(int, D const ?&\\);${ws}D\\(int\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\((void|)\\);" \
	" ?\\*"

    # An instance of V *

    test_one_ptype "ptype pVa" "ptype pVa" \
	"class V : public VA, public VB \{${ws}public:" \
	"" \
	"" "int w;" \
	"" "int f\\((void|)\\);${ws}virtual int vv\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	" ?\\*"

    # An instance of V *

    test_one_ptype "ptype pVv" "ptype pVv" \
	"class V : public VA, public VB \{${ws}public:" \
	"" \
	"" "int w;" \
	"" "int f\\((void|)\\);${ws}virtual int vv\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	" ?\\*"

    # An instance of V *

    test_one_ptype "ptype pVe" "ptype pVe" \
	"class V : public VA, public VB \{${ws}public:" \
	"" \
	"" "int w;" \
	"" "int f\\((void|)\\);${ws}virtual int vv\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	" ?\\*"

    # An instance of V *

    test_one_ptype "ptype pVd" "ptype pVd" \
	"class V : public VA, public VB \{${ws}public:" \
	"" \
	"" "int w;" \
	"" "int f\\((void|)\\);${ws}virtual int vv\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	" ?\\*"

    # An instance of AD *

    test_one_ptype "ptype pADe" "ptype pADe" \
	"((struct|class) AD \{${ws}public:|struct AD \{)" \
	"" \
	"" "" \
    	"" "virtual int vg\\((void|)\\);" \
	"AD & operator=\\(AD const ?&\\);${ws}AD\\(AD const ?&\\);${ws}AD\\((void|)\\);" \
	"AD & operator=\\(AD const ?&\\);${ws}AD\\(AD const ?&\\);${ws}AD\\((void|)\\);" \
	" ?\\*"

    # An instance of E *

    test_one_ptype "ptype pEe" "ptype pEe" \
	"class E : public B, public virtual V, public D, public C \{(${ws}private:|)" \
	"" \
	"public:" "int e;" \
	"" "virtual int f\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vv\\((void|)\\);" \
	"E & operator=\\(E const ?&\\);${ws}E\\(int, E const ?&\\);${ws}E\\(int\\);" \
	"E & operator=\\(E const ?&\\);${ws}E\\(E const ?&\\);${ws}E\\((void|)\\);" \
	" ?\\*"

    # An instance of VB *

    test_one_ptype "ptype pVB" "ptype pVB" \
	"((struct|class) VB \{${ws}public:|struct VB \{)" \
	"" \
	"" "int vb;" \
	"" "int fvb\\((void|)\\);${ws}virtual int vvb\\((void|)\\);" \
	"VB & operator=\\(VB const ?&\\);${ws}VB\\(VB const ?&\\);${ws}VB\\((void|)\\);" \
	"VB & operator=\\(VB const ?&\\);${ws}VB\\(VB const ?&\\);${ws}VB\\((void|)\\);" \
	" ?\\*"
d729 3
a731 1
# Call virtual functions.
d735 1
d737 1
d745 104
a848 21
    gdb_test "print pAe->f()"   "\\$\[0-9\]+ = 20"
    gdb_test "print pAa->f()"   "\\$\[0-9\]+ = 1"
    gdb_test "print pDe->vg()"  "\\$\[0-9\]+ = 202"
    gdb_test "print pADe->vg()" "\\$\[0-9\]+ = 202"
    gdb_test "print pDd->vg()"  "\\$\[0-9\]+ = 101"
    gdb_test "print pEe->vvb()" "\\$\[0-9\]+ = 411"
    gdb_test "print pVB->vvb()" "\\$\[0-9\]+ = 407"
    gdb_test "print pBe->vvb()" "\\$\[0-9\]+ = 411"
    gdb_test "print pDe->vvb()" "\\$\[0-9\]+ = 411"
    gdb_test "print pEe->vd()"  "\\$\[0-9\]+ = 282"
    gdb_test "print pEe->fvb()" "\\$\[0-9\]+ = 311"

    # more recent results:
    # wrong value "202"
    #   gcc 2.95.3 -gdwarf-2
    #   gcc 2.95.3 -gstabs+
    # attempt to take addres of value not located in memory
    #   gcc 3.3.2 -gdwarf-2
    #   gcc 3.3.2 -gstabs+
    #
    # -- chastain 2003-12-31
d850 6
a855 3
    gdb_test_multiple "print pEe->D::vg()" "print pEe->D::vg()" {
	-re "\\$\[0-9]+ = 102$nl$gdb_prompt $" {
	    pass "print pEe->D::vg()"
d857 11
a867 2
	-re "Attempt to take address of value not located in memory.$nl$gdb_prompt $" {
	    kfail "gdb/1064" "print pEe->D::vg()"
d869 57
a931 2
    global srcdir subdir binfile
    global gdb_prompt
d936 2
a937 4
    gdb_exit
    gdb_start
    gdb_reinitialize_dir $srcdir/$subdir
    gdb_load $binfile
d939 1
a939 2
    gdb_test "set language c++" "" ""
    gdb_test "set width 0" "" ""
a940 1
    runto_main
d943 3
a945 3
    gdb_breakpoint test_calls
    gdb_test "continue" ".*Breakpoint .* test_calls.*" ""
    test_virtual_calls
@


1.1.4.1
log
@2003-08-22  Michael Chastain  <mec@@shout.net>

	* gdb.cp: New directory.
	* gdb.cp/*: Copy from gdb.c++/*.
	* gdb.c++/*: Remove.
	* Makefile.in: Change gdb.c++ to gdb.cp.
	* configure.in:  Ditto.
	* carlton_runnamespace: Ditto.
	* carlton_runtest: Ditto.
	* configure: Regnerate.
@
text
@@


1.1.4.2
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d737 1
@


1.1.4.3
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d1 1
a1 1
# Copyright 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2001, 2002, 2003, 2004
a21 1
# And rewritten by Michael Chastain <mec.gnu@@mindspring.com>.
d23 2
a24 3
set wsopt	"\[\r\n\t \]*"
set ws		"\[\r\n\t \]+"
set nl		"\[\r\n\]+"
d27 1
a27 1
    strace $tracelevel
d36 6
d46 20
a65 27
# Test ptype of a class.
#
# Different C++ compilers produce different output.  I build up regular
# expressions piece by piece to accommodate all the compilers that I
# have seen: gcc 2.95.3, gcc 3.3.2 (ABI 1), gcc 3.4 prerelease (ABI 2);
# and all the debug formats I have seen: dwarf-2 and stabs+.
#
# A complicated class declaration looks like this:
#
#   class A : public virtual V {	// re_class
#     private:
#       V * _vb$V;			// re_vbptr
#       int a;				// re_fields
#
#     public:				// re_access_methods
#       A & operator=(A const &);	// re_synth_gcc_2
#       A(int, A const &);		// ...
#       A(int);				// ...
#       virtual int f(void);		// re_methods
#   }
#
# RE_CLASS matches the class declaration.  C++ allows multiple ways of
# expressing this.
#
#   struct ... { private: ... };
#   class ... { private: ... };
#   class ... { ... };
d67 1
a67 3
# RE_VBPTR matches the virtual base declarations.  gcc 2.95.3 sometimes
# emits these, but gcc 3.X.Y never emits these.  The name depends on the
# debug format.
a68 19
# RE_FIELDS matches the data fields of the class.
# RE_METHODS matches the methods explicitly declared for the class.
#
# RE_SYNTH_GCC_2 and RE_SYNTH_GCC_3 match the optional synthetic methods
# of the class.  gcc -gstabs+ emits these methods, and gcc -gdwarf-2
# does not.
#
# RE_ACCESS_METHODS is an access specifier after RE_FIELDS and before
# the methods (explicit methods and/or synthetic methods).
# There is also an RE_ACCESS_FIELDS.
#
# When I get HP-UX aCC, I hope that I can just add RE_SYNTH_ACC_NNN.
#
# Yet another twist: with gcc v2, ctor and dtor methods have a hidden
# argument in front, the "in-charge" flag.  With gcc v3, there is no
# hidden argument; instead, there are multiple object functions for
# each ctor and dtor.
#
# -- chastain 2004-01-01
d70 1
a70 1
proc test_one_ptype { command testname re_class re_vbptr re_access_fields re_fields re_access_methods re_methods re_synth_gcc_2 re_synth_gcc_3 re_star } {
a71 1
    global wsopt
d75 130
a204 28
    gdb_test_multiple "$command" "$testname" {
	-re "type = $re_class${wsopt}$re_access_fields${wsopt}$re_fields${wsopt}$re_access_methods${wsopt}$re_methods$nl\}$re_star$nl$gdb_prompt $" {
	    # gcc 2.95.3, dwarf-2, no vbptr
	    # gcc 3.X, abi 1, dwarf-2
	    # gcc 3.X, abi 2, dwarf-2
	    pass "$testname"
	}
	-re "type = $re_class${wsopt}$re_vbptr${wsopt}$re_access_fields${wsopt}$re_fields${wsopt}$re_access_methods${wsopt}$re_methods$nl\}$re_star$nl$gdb_prompt $" {
	    # gcc 2.95.3, dwarf-2, vbptr
	    # TODO: drow says the vbptr is a bug
	    pass "$testname"
	}
	-re "type = $re_class${wsopt}$re_access_fields${wsopt}$re_fields${wsopt}$re_access_methods${wsopt}$re_synth_gcc_2${wsopt}$re_methods$nl\}$re_star$nl$gdb_prompt $" {
	    # gcc 2.95.3, stabs+, no vbptr
	    pass "$testname"
	}
	-re "type = $re_class${wsopt}$re_vbptr${wsopt}$re_access_fields${wsopt}$re_fields${wsopt}$re_access_methods${wsopt}$re_synth_gcc_2${wsopt}$re_methods$nl\}$re_star$nl$gdb_prompt $" {
	    # gcc 2.95.3, stabs+, vbptr
	    # TODO: drow says the vbptr is a bug
	    pass "$testname"
	}
	-re "type = $re_class${wsopt}$re_access_fields${wsopt}$re_fields${wsopt}$re_access_methods${wsopt}$re_synth_gcc_3${wsopt}$re_methods$nl\}$re_star$nl$gdb_prompt $" {
	    # gcc 3.X, abi 1, stabs+
	    pass "$testname"
	}
	-re "type = $re_class${wsopt}$re_access_fields${wsopt}$re_fields${wsopt}$re_access_methods${wsopt}$re_methods${wsopt}$re_synth_gcc_3$nl\}$re_star$nl$gdb_prompt $" {
	    # gcc 3.X, abi 2, stabs+
	    pass "$testname"
d208 459
a666 1
}
d668 18
a685 4
proc test_ptype_of_classes {} {
    global gdb_prompt
    global ws
    global nl
d687 21
a707 1
    # class VA
d709 18
a726 340
    test_one_ptype "ptype VA" "ptype VA" \
	"((struct|class) VA \{${ws}public:|struct VA \{)" \
	"" \
	"" "int va;" \
	"" "" \
	"VA & operator=\\(VA const ?&\\);${ws}VA\\(VA const ?&\\);${ws}VA\\((void|)\\);" \
	"VA & operator=\\(VA const ?&\\);${ws}VA\\(VA const ?&\\);${ws}VA\\((void|)\\);" \
	""

    # class VB

    test_one_ptype "ptype VB" "ptype VB" \
	"((struct|class) VB \{${ws}public:|struct VB \{)" \
	"" \
	"" "int vb;" \
	"" "int fvb\\((void|)\\);${ws}virtual int vvb\\((void|)\\);" \
	"VB & operator=\\(VB const ?&\\);${ws}VB\\(VB const ?&\\);${ws}VB\\((void|)\\);" \
	"VB & operator=\\(VB const ?&\\);${ws}VB\\(VB const ?&\\);${ws}VB\\((void|)\\);" \
	""

    # class V

    test_one_ptype "ptype V" "ptype V" \
	"class V : public VA, public VB \{${ws}public:" \
	"" \
	"" "int w;" \
	"" "int f\\((void|)\\);${ws}virtual int vv\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	""

    # class A

    test_one_ptype "ptype A" "ptype A" \
	"class A : public virtual V \{(${ws}private:|)" \
	"V \\*(_vb.1V|_vb.V);" \
	"" "int a;" \
	"public:" "virtual int f\\((void|)\\);" \
	"A & operator=\\(A const ?&\\);${ws}A\\(int, A const ?&\\);${ws}A\\(int\\);" \
	"A & operator=\\(A const ?&\\);${ws}A\\(A const ?&\\);${ws}A\\(\\);" \
	""

    # class B

    test_one_ptype "ptype B" "ptype B" \
	"class B : public A \{(${ws}private:|)" \
	"V \\*(_vb.1V|_vb.V);" \
	"" "int b;" \
	"public:" "virtual int f\\((void|)\\);" \
	"B & operator=\\(B const ?&\\);${ws}B\\(int, B const ?&\\);${ws}B\\(int\\);" \
	"B & operator=\\(B const ?&\\);${ws}B\\(B const ?&\\);${ws}B\\(\\);" \
	""

    # class C

    test_one_ptype "ptype C" "ptype C" \
	"class C : public virtual V \{(${ws}private:|)" \
	"V \\*(_vb.1V|_vb.V);" \
	"public:" "int c;" \
	"" "" \
	"C & operator=\\(C const ?&\\);${ws}C\\(int, C const ?&\\);${ws}C\\(int\\);" \
	"C & operator=\\(C const ?&\\);${ws}C\\(C const ?&\\);${ws}C\\(\\);" \
	""

    # class AD

    test_one_ptype "ptype AD" "ptype AD" \
	"((struct|class) AD \{${ws}public:|struct AD \{)" \
	"" \
	"" "" \
    	"" "virtual int vg\\((void|)\\);" \
	"AD & operator=\\(AD const ?&\\);${ws}AD\\(AD const ?&\\);${ws}AD\\((void|)\\);" \
	"AD & operator=\\(AD const ?&\\);${ws}AD\\(AD const ?&\\);${ws}AD\\((void|)\\);" \
	""

    # class D

    test_one_ptype "ptype D" "ptype D" \
	"class D : public AD, public virtual V \{(${ws}private:|)" \
    	"V \\*(_vb.1V|_vb.V);" \
    	"public:" "int d;" \
	"" "static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(int, D const ?&\\);${ws}D\\(int\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\(\\);" \
	""

    # class E
    # TODO: E does not show a vbptr for V.  That seems strange.

    test_one_ptype "ptype E" "ptype E" \
	"class E : public B, public virtual V, public D, public C \{(${ws}private:|)" \
	"" \
	"public:" "int e;" \
	"" "virtual int f\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vv\\((void|)\\);" \
	"E & operator=\\(E const ?&\\);${ws}E\\(int, E const ?&\\);${ws}E\\(int\\);" \
	"E & operator=\\(E const ?&\\);${ws}E\\(E const ?&\\);${ws}E\\(\\);" \
	""

    # An instance of D

    test_one_ptype "ptype dd" "ptype dd" \
	"class D : public AD, public virtual V \{(${ws}private:|)" \
    	"V \\*(_vb.1V|_vb.V);" \
    	"public:" "int d;" \
	"" "static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(int, D const ?&\\);${ws}D\\(int\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\(\\);" \
	""

    # An instance of D *

    test_one_ptype "ptype ppd" "ptype ppd" \
	"class D : public AD, public virtual V \{(${ws}private:|)" \
    	"V \\*(_vb.1V|_vb.V);" \
    	"public:" "int d;" \
	"" "static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(int, D const ?&\\);${ws}D\\(int\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\(\\);" \
	" ?\\*"

    # An instance of AD *
    # TODO: this should be named pADd, not pAd.

    test_one_ptype "ptype pAd" "ptype pAd" \
	"((struct|class) AD \{${ws}public:|struct AD \{)" \
	"" \
	"" "" \
    	"" "virtual int vg\\((void|)\\);" \
	"AD & operator=\\(AD const ?&\\);${ws}AD\\(AD const ?&\\);${ws}AD\\((void|)\\);" \
	"AD & operator=\\(AD const ?&\\);${ws}AD\\(AD const ?&\\);${ws}AD\\((void|)\\);" \
	" ?\\*"

    # An instance of A

    test_one_ptype "ptype a" "ptype a" \
	"class A : public virtual V \{(${ws}private:|)" \
	"V \\*(_vb.1V|_vb.V);" \
	"" "int a;" \
	"public:" "virtual int f\\((void|)\\);" \
	"A & operator=\\(A const ?&\\);${ws}A\\(int, A const ?&\\);${ws}A\\(int\\);" \
	"A & operator=\\(A const ?&\\);${ws}A\\(A const ?&\\);${ws}A\\(\\);" \
	""

    # An instance of B

    test_one_ptype "ptype b" "ptype b" \
	"class B : public A \{(${ws}private:|)" \
	"V \\*(_vb.1V|_vb.V);" \
	"" "int b;" \
	"public:" "virtual int f\\((void|)\\);" \
	"B & operator=\\(B const ?&\\);${ws}B\\(int, B const ?&\\);${ws}B\\(int\\);" \
	"B & operator=\\(B const ?&\\);${ws}B\\(B const ?&\\);${ws}B\\(\\);" \
	""

    # An instance of C

    test_one_ptype "ptype c" "ptype c" \
	"class C : public virtual V \{(${ws}private:|)" \
	"V \\*(_vb.1V|_vb.V);" \
	"public:" "int c;" \
	"" "" \
	"C & operator=\\(C const ?&\\);${ws}C\\(int, C const ?&\\);${ws}C\\(int\\);" \
	"C & operator=\\(C const ?&\\);${ws}C\\(C const ?&\\);${ws}C\\(\\);" \
	""

    # An instance of D

    test_one_ptype "ptype d" "ptype d" \
	"class D : public AD, public virtual V \{(${ws}private:|)" \
    	"V \\*(_vb.1V|_vb.V);" \
    	"public:" "int d;" \
	"" "static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(int, D const ?&\\);${ws}D\\(int\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\(\\);" \
	""

    # An instance of E

    test_one_ptype "ptype e" "ptype e" \
	"class E : public B, public virtual V, public D, public C \{(${ws}private:|)" \
	"" \
	"public:" "int e;" \
	"" "virtual int f\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vv\\((void|)\\);" \
	"E & operator=\\(E const ?&\\);${ws}E\\(int, E const ?&\\);${ws}E\\(int\\);" \
	"E & operator=\\(E const ?&\\);${ws}E\\(E const ?&\\);${ws}E\\(\\);" \
	""

    # An instance of V

    test_one_ptype "ptype v" "ptype v" \
	"class V : public VA, public VB \{${ws}public:" \
	"" \
	"" "int w;" \
	"" "int f\\((void|)\\);${ws}virtual int vv\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	""

    # An instance of VB

    test_one_ptype "ptype vb" "ptype vb" \
	"((struct|class) VB \{${ws}public:|struct VB \{)" \
	"" \
	"" "int vb;" \
	"" "int fvb\\((void|)\\);${ws}virtual int vvb\\((void|)\\);" \
	"VB & operator=\\(VB const ?&\\);${ws}VB\\(VB const ?&\\);${ws}VB\\((void|)\\);" \
	"VB & operator=\\(VB const ?&\\);${ws}VB\\(VB const ?&\\);${ws}VB\\((void|)\\);" \
	""

    # An instance of A *

    test_one_ptype "ptype pAa" "ptype pAa" \
	"class A : public virtual V \{(${ws}private:|)" \
	"V \\*(_vb.1V|_vb.V);" \
	"" "int a;" \
	"public:" "virtual int f\\((void|)\\);" \
	"A & operator=\\(A const ?&\\);${ws}A\\(int, A const ?&\\);${ws}A\\(int\\);" \
	"A & operator=\\(A const ?&\\);${ws}A\\(A const ?&\\);${ws}A\\(\\);" \
	" ?\\*"

    # An instance of A *

    test_one_ptype "ptype pAe" "ptype pAe" \
	"class A : public virtual V \{(${ws}private:|)" \
	"V \\*(_vb.1V|_vb.V);" \
	"" "int a;" \
	"public:" "virtual int f\\((void|)\\);" \
	"A & operator=\\(A const ?&\\);${ws}A\\(int, A const ?&\\);${ws}A\\(int\\);" \
	"A & operator=\\(A const ?&\\);${ws}A\\(A const ?&\\);${ws}A\\(\\);" \
	" ?\\*"

    # An instance of B *

    test_one_ptype "ptype pBe" "ptype pBe" \
	"class B : public A \{(${ws}private:|)" \
	"V \\*(_vb.1V|_vb.V);" \
	"" "int b;" \
	"public:" "virtual int f\\((void|)\\);" \
	"B & operator=\\(B const ?&\\);${ws}B\\(int, B const ?&\\);${ws}B\\(int\\);" \
	"B & operator=\\(B const ?&\\);${ws}B\\(B const ?&\\);${ws}B\\(\\);" \
	" ?\\*"

    # An instance of D *

    test_one_ptype "ptype pDd" "ptype pDd" \
	"class D : public AD, public virtual V \{(${ws}private:|)" \
    	"V \\*(_vb.1V|_vb.V);" \
    	"public:" "int d;" \
	"" "static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(int, D const ?&\\);${ws}D\\(int\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\(\\);" \
	" ?\\*"

    # An instance of D *

    test_one_ptype "ptype pDe" "ptype pDe" \
	"class D : public AD, public virtual V \{(${ws}private:|)" \
    	"V \\*(_vb.1V|_vb.V);" \
    	"public:" "int d;" \
	"" "static void s\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vd\\((void|)\\);${ws}int fd\\((void|)\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(int, D const ?&\\);${ws}D\\(int\\);" \
	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\(\\);" \
	" ?\\*"

    # An instance of V *

    test_one_ptype "ptype pVa" "ptype pVa" \
	"class V : public VA, public VB \{${ws}public:" \
	"" \
	"" "int w;" \
	"" "int f\\((void|)\\);${ws}virtual int vv\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	" ?\\*"

    # An instance of V *

    test_one_ptype "ptype pVv" "ptype pVv" \
	"class V : public VA, public VB \{${ws}public:" \
	"" \
	"" "int w;" \
	"" "int f\\((void|)\\);${ws}virtual int vv\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	" ?\\*"

    # An instance of V *

    test_one_ptype "ptype pVe" "ptype pVe" \
	"class V : public VA, public VB \{${ws}public:" \
	"" \
	"" "int w;" \
	"" "int f\\((void|)\\);${ws}virtual int vv\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	" ?\\*"

    # An instance of V *

    test_one_ptype "ptype pVd" "ptype pVd" \
	"class V : public VA, public VB \{${ws}public:" \
	"" \
	"" "int w;" \
	"" "int f\\((void|)\\);${ws}virtual int vv\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);" \
	" ?\\*"

    # An instance of AD *

    test_one_ptype "ptype pADe" "ptype pADe" \
	"((struct|class) AD \{${ws}public:|struct AD \{)" \
	"" \
	"" "" \
    	"" "virtual int vg\\((void|)\\);" \
	"AD & operator=\\(AD const ?&\\);${ws}AD\\(AD const ?&\\);${ws}AD\\((void|)\\);" \
	"AD & operator=\\(AD const ?&\\);${ws}AD\\(AD const ?&\\);${ws}AD\\((void|)\\);" \
	" ?\\*"

    # An instance of E *

    test_one_ptype "ptype pEe" "ptype pEe" \
	"class E : public B, public virtual V, public D, public C \{(${ws}private:|)" \
	"" \
	"public:" "int e;" \
	"" "virtual int f\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vv\\((void|)\\);" \
	"E & operator=\\(E const ?&\\);${ws}E\\(int, E const ?&\\);${ws}E\\(int\\);" \
	"E & operator=\\(E const ?&\\);${ws}E\\(E const ?&\\);${ws}E\\(\\);" \
	" ?\\*"

    # An instance of VB *

    test_one_ptype "ptype pVB" "ptype pVB" \
	"((struct|class) VB \{${ws}public:|struct VB \{)" \
	"" \
	"" "int vb;" \
	"" "int fvb\\((void|)\\);${ws}virtual int vvb\\((void|)\\);" \
	"VB & operator=\\(VB const ?&\\);${ws}VB\\(VB const ?&\\);${ws}VB\\((void|)\\);" \
	"VB & operator=\\(VB const ?&\\);${ws}VB\\(VB const ?&\\);${ws}VB\\((void|)\\);" \
	" ?\\*"
d729 3
a731 1
# Call virtual functions.
d735 1
d744 104
a847 21
    gdb_test "print pAe->f()"   "\\$\[0-9\]+ = 20"
    gdb_test "print pAa->f()"   "\\$\[0-9\]+ = 1"
    gdb_test "print pDe->vg()"  "\\$\[0-9\]+ = 202"
    gdb_test "print pADe->vg()" "\\$\[0-9\]+ = 202"
    gdb_test "print pDd->vg()"  "\\$\[0-9\]+ = 101"
    gdb_test "print pEe->vvb()" "\\$\[0-9\]+ = 411"
    gdb_test "print pVB->vvb()" "\\$\[0-9\]+ = 407"
    gdb_test "print pBe->vvb()" "\\$\[0-9\]+ = 411"
    gdb_test "print pDe->vvb()" "\\$\[0-9\]+ = 411"
    gdb_test "print pEe->vd()"  "\\$\[0-9\]+ = 282"
    gdb_test "print pEe->fvb()" "\\$\[0-9\]+ = 311"

    # more recent results:
    # wrong value "202"
    #   gcc 2.95.3 -gdwarf-2
    #   gcc 2.95.3 -gstabs+
    # attempt to take addres of value not located in memory
    #   gcc 3.3.2 -gdwarf-2
    #   gcc 3.3.2 -gstabs+
    #
    # -- chastain 2003-12-31
d849 6
a854 3
    gdb_test_multiple "print pEe->D::vg()" "print pEe->D::vg()" {
	-re "\\$\[0-9]+ = 102$nl$gdb_prompt $" {
	    pass "print pEe->D::vg()"
d856 11
a866 2
	-re "Attempt to take address of value not located in memory.$nl$gdb_prompt $" {
	    kfail "gdb/1064" "print pEe->D::vg()"
d868 57
a930 2
    global srcdir subdir binfile
    global gdb_prompt
d935 2
a936 4
    gdb_exit
    gdb_start
    gdb_reinitialize_dir $srcdir/$subdir
    gdb_load $binfile
d938 1
a938 2
    gdb_test "set language c++" "" ""
    gdb_test "set width 0" "" ""
a939 1
    runto_main
d942 3
a944 3
    gdb_breakpoint test_calls
    gdb_test "continue" ".*Breakpoint .* test_calls.*" ""
    test_virtual_calls
@


1.1.2.1
log
@2003-08-22  Michael Chastain  <mec@@shout.net>

	* gdb.cp: New directory.
	* gdb.cp/*: Copy from gdb.c++/*.
	* gdb.c++/*: Remove.
	* Makefile.in: Change gdb.c++ to gdb.cp.
	* configure.in:  Ditto.
	* configure: Regnerate.
@
text
@@

