head	1.6;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.6
	gdb_7_6-2013-04-26-release:1.6
	gdb_7_6-branch:1.6.0.4
	gdb_7_6-2013-03-12-branchpoint:1.6
	gdb_7_5_1-2012-11-29-release:1.6
	gdb_7_5-2012-08-17-release:1.6
	gdb_7_5-branch:1.6.0.2
	gdb_7_5-2012-07-18-branchpoint:1.6
	gdb_7_4_1-2012-04-26-release:1.5
	gdb_7_4-2012-01-24-release:1.5
	gdb_7_4-branch:1.5.0.4
	gdb_7_4-2011-12-13-branchpoint:1.5
	gdb_7_3_1-2011-09-04-release:1.5
	gdb_7_3-2011-07-26-release:1.5
	gdb_7_3-branch:1.5.0.2
	gdb_7_3-2011-04-01-branchpoint:1.5
	gdb_7_2-2010-09-02-release:1.4
	gdb_7_2-branch:1.4.0.4
	gdb_7_2-2010-07-07-branchpoint:1.4
	gdb_7_1-2010-03-18-release:1.4
	gdb_7_1-branch:1.4.0.2
	gdb_7_1-2010-02-18-branchpoint:1.4
	gdb_7_0_1-2009-12-22-release:1.2
	gdb_7_0-2009-10-06-release:1.2
	gdb_7_0-branch:1.2.0.4
	gdb_7_0-2009-09-16-branchpoint:1.2
	arc-sim-20090309:1.1
	msnyder-checkpoint-072509-branch:1.2.0.2
	msnyder-checkpoint-072509-branchpoint:1.2
	arc-insight_6_8-branch:1.1.0.76
	arc-insight_6_8-branchpoint:1.1
	insight_6_8-branch:1.1.0.74
	insight_6_8-branchpoint:1.1
	reverse-20081226-branch:1.1.0.72
	reverse-20081226-branchpoint:1.1
	multiprocess-20081120-branch:1.1.0.70
	multiprocess-20081120-branchpoint:1.1
	reverse-20080930-branch:1.1.0.68
	reverse-20080930-branchpoint:1.1
	reverse-20080717-branch:1.1.0.66
	reverse-20080717-branchpoint:1.1
	msnyder-reverse-20080609-branch:1.1.0.64
	msnyder-reverse-20080609-branchpoint:1.1
	drow-reverse-20070409-branch:1.1.0.62
	drow-reverse-20070409-branchpoint:1.1
	gdb_6_8-2008-03-27-release:1.1
	gdb_6_8-branch:1.1.0.60
	gdb_6_8-2008-02-26-branchpoint:1.1
	gdb_6_7_1-2007-10-29-release:1.1
	gdb_6_7-2007-10-10-release:1.1
	gdb_6_7-branch:1.1.0.58
	gdb_6_7-2007-09-07-branchpoint:1.1
	insight_6_6-20070208-release:1.1
	gdb_6_6-2006-12-18-release:1.1
	gdb_6_6-branch:1.1.0.56
	gdb_6_6-2006-11-15-branchpoint:1.1
	insight_6_5-20061003-release:1.1
	gdb-csl-symbian-6_4_50_20060226-12:1.1
	gdb-csl-sourcerygxx-3_4_4-25:1.1
	nickrob-async-20060828-mergepoint:1.1
	gdb-csl-symbian-6_4_50_20060226-11:1.1
	gdb-csl-sourcerygxx-4_1-17:1.1
	gdb-csl-20060226-branch-local-2:1.1
	gdb-csl-sourcerygxx-4_1-14:1.1
	gdb-csl-sourcerygxx-4_1-13:1.1
	gdb-csl-sourcerygxx-4_1-12:1.1
	gdb-csl-sourcerygxx-3_4_4-21:1.1
	gdb_6_5-20060621-release:1.1
	gdb-csl-sourcerygxx-4_1-9:1.1
	gdb-csl-sourcerygxx-4_1-8:1.1
	gdb-csl-sourcerygxx-4_1-7:1.1
	gdb-csl-arm-2006q1-6:1.1
	gdb-csl-sourcerygxx-4_1-6:1.1
	gdb-csl-symbian-6_4_50_20060226-10:1.1
	gdb-csl-symbian-6_4_50_20060226-9:1.1
	gdb-csl-symbian-6_4_50_20060226-8:1.1
	gdb-csl-coldfire-4_1-11:1.1
	gdb-csl-sourcerygxx-3_4_4-19:1.1
	gdb-csl-coldfire-4_1-10:1.1
	gdb_6_5-branch:1.1.0.54
	gdb_6_5-2006-05-14-branchpoint:1.1
	gdb-csl-sourcerygxx-4_1-5:1.1
	nickrob-async-20060513-branch:1.1.0.52
	nickrob-async-20060513-branchpoint:1.1
	gdb-csl-sourcerygxx-4_1-4:1.1
	msnyder-reverse-20060502-branch:1.1.0.50
	msnyder-reverse-20060502-branchpoint:1.1
	gdb-csl-morpho-4_1-4:1.1
	gdb-csl-sourcerygxx-3_4_4-17:1.1
	readline_5_1-import-branch:1.1.0.48
	readline_5_1-import-branchpoint:1.1
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.1
	gdb-csl-symbian-20060226-branch:1.1.0.46
	gdb-csl-symbian-20060226-branchpoint:1.1
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.1
	msnyder-reverse-20060331-branch:1.1.0.44
	msnyder-reverse-20060331-branchpoint:1.1
	gdb-csl-available-20060303-branch:1.1.0.42
	gdb-csl-available-20060303-branchpoint:1.1
	gdb-csl-20060226-branch:1.1.0.40
	gdb-csl-20060226-branchpoint:1.1
	gdb_6_4-20051202-release:1.1
	msnyder-fork-checkpoint-branch:1.1.0.38
	msnyder-fork-checkpoint-branchpoint:1.1
	gdb-csl-gxxpro-6_3-branch:1.1.0.36
	gdb-csl-gxxpro-6_3-branchpoint:1.1
	gdb_6_4-branch:1.1.0.34
	gdb_6_4-2005-11-01-branchpoint:1.1
	gdb-csl-arm-20051020-branch:1.1.0.32
	gdb-csl-arm-20051020-branchpoint:1.1
	gdb-csl-arm-20050325-2005-q1b:1.1
	gdb-csl-arm-20050325-2005-q1a:1.1
	csl-arm-20050325-branch:1.1.0.30
	csl-arm-20050325-branchpoint:1.1
	gdb-post-i18n-errorwarning-20050211:1.1
	gdb-pre-i18n-errorwarning-20050211:1.1
	gdb_6_3-20041109-release:1.1
	gdb_6_3-branch:1.1.0.26
	gdb_6_3-20041019-branchpoint:1.1
	drow_intercu-merge-20040921:1.1
	drow_intercu-merge-20040915:1.1
	jimb-gdb_6_2-e500-branch:1.1.0.28
	jimb-gdb_6_2-e500-branchpoint:1.1
	gdb_6_2-20040730-release:1.1
	gdb_6_2-branch:1.1.0.24
	gdb_6_2-2004-07-10-gmt-branchpoint:1.1
	gdb_6_1_1-20040616-release:1.1
	gdb_6_1-2004-04-05-release:1.1
	drow_intercu-merge-20040402:1.1
	drow_intercu-merge-20040327:1.1
	ezannoni_pie-20040323-branch:1.1.0.22
	ezannoni_pie-20040323-branchpoint:1.1
	cagney_tramp-20040321-mergepoint:1.1
	cagney_tramp-20040309-branch:1.1.0.20
	cagney_tramp-20040309-branchpoint:1.1
	gdb_6_1-branch:1.1.0.18
	gdb_6_1-2004-03-01-gmt-branchpoint:1.1
	drow_intercu-20040221-branch:1.1.0.16
	drow_intercu-20040221-branchpoint:1.1
	cagney_bfdfile-20040213-branch:1.1.0.14
	cagney_bfdfile-20040213-branchpoint:1.1
	drow-cplus-merge-20040208:1.1
	carlton_dictionary-20040126-merge:1.1
	cagney_bigcore-20040122-branch:1.1.0.12
	cagney_bigcore-20040122-branchpoint:1.1
	drow-cplus-merge-20040113:1.1
	drow-cplus-merge-20031224:1.1
	drow-cplus-merge-20031220:1.1
	carlton_dictionary-20031215-merge:1.1
	drow-cplus-branch:1.1.0.10
	drow-cplus-merge-20031214:1.1
	carlton-dictionary-20031111-merge:1.1
	gdb_6_0-2003-10-04-release:1.1.2.1
	kettenis_sparc-20030918-branch:1.1.0.8
	kettenis_sparc-20030918-branchpoint:1.1
	carlton_dictionary-20030917-merge:1.1
	ezannoni_pie-20030916-branchpoint:1.1
	ezannoni_pie-20030916-branch:1.1.0.6
	carlton_dictionary-branch:1.1.0.4
	gdb_6_0-branch:1.1.0.2;
locks; strict;
comment	@// @;


1.6
date	2011.12.13.17.22.08;	author palves;	state Exp;
branches;
next	1.5;

1.5
date	2010.09.08.19.09.43;	author drow;	state Exp;
branches;
next	1.4;

1.4
date	2009.12.28.21.45.24;	author drow;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.21.19.23.22;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2009.04.27.12.14.09;	author guitton;	state Exp;
branches;
next	1.1;

1.1
date	2003.08.23.03.55.59;	author chastain;	state Exp;
branches
	1.1.2.1
	1.1.4.1
	1.1.10.1;
next	;

1.1.2.1
date	2003.08.25.03.53.48;	author chastain;	state Exp;
branches;
next	;

1.1.4.1
date	2003.08.30.03.40.35;	author chastain;	state Exp;
branches;
next	;

1.1.10.1
date	2003.12.14.20.27.54;	author drow;	state Exp;
branches;
next	;


desc
@@


1.6
log
@gdb/doc/
2011-12-13  Pedro Alves  <pedro@@codesourcery.com>

	* gdb.texinfo (Implementing a Remote Stub): Explain that you
	should transfer control to the stub in the startup code instead of
	in main.  Mention the need to get past the initial breakpoint.

gdb/testsuite/
2011-12-13  Pedro Alves  <pedro@@codesourcery.com>
	    Doug Evans  <dje@@google.com>

	* lib/gdb.exp (gdb_run_cmd, runto_main, gdb_compile)
	(clean_restart): Remove references to the gdb_stub target board
	variable.
	(gdb_step_for_stub): Delete.

	* gdb.base/annota1.exp: Remove all references to [target_info
	exists gdb_stub], gdb_step_for_stub and usestubs.
	* gdb.base/annota3.exp: Ditto.
	* gdb.base/async.exp: Ditto.
	* gdb.base/break.exp: Ditto.
	* gdb.base/code-expr.exp: Ditto.
	* gdb.base/commands.exp: Ditto.
	* gdb.base/completion.exp: Ditto.
	* gdb.base/condbreak.exp: Ditto.
	* gdb.base/consecutive.exp: Ditto.
	* gdb.base/cvexpr.exp: Ditto.
	* gdb.base/define.exp: Ditto.
	* gdb.base/display.exp: Ditto.
	* gdb.base/ena-dis-br.exp: Ditto.
	* gdb.base/environ.exp: Ditto.
	* gdb.base/gnu-ifunc.exp: Ditto.
	* gdb.base/maint.exp: Ditto.
	* gdb.base/pending.exp: Ditto.
	* gdb.base/sect-cmd.exp: Ditto.
	* gdb.base/sepdebug.exp: Ditto.
	* gdb.base/unload.exp: Ditto.
	* gdb.base/watchpoint-solib.exp: Ditto.
	* gdb.cp/annota2.exp: Ditto.
	* gdb.cp/annota3.exp: Ditto.
	* gdb.dwarf2/dw2-inline-param.exp: Ditto.
	* gdb.hp/gdb.compat/xdb1.exp: Ditto.
	* gdb.mi/mi-pending.exp: Ditto.
	* gdb.trace/circ.exp: Ditto.
	* gdb.cp/ovldbreak.exp: Ditto.  Adjust expected line numbers.
	* gdb.base/list.exp: Ditto.

	* gdb.base/all-types.c: Remove all calls to set_debug_traps and
	breakpoint function and all references to the usestubs macro.
	* gdb.base/exprs.c: Ditto.
	* gdb.base/freebpcmd.c: Ditto.
	* gdb.base/bitfields.c: Ditto.
	* gdb.base/bitfields2.c: Ditto.
	* gdb.base/break.c: Ditto.
	* gdb.base/call-sc.c: Ditto.
	* gdb.base/call-signals.c: Ditto.
	* gdb.base/callfuncs.c: Ditto.
	* gdb.base/charset.c: Ditto.
	* gdb.base/consecutive.c: Ditto.
	* gdb.base/constvars.c: Ditto.
	* gdb.base/funcargs.c: Ditto.
	* gdb.base/int-type.c: Ditto.
	* gdb.base/interrupt.c: Ditto.
	* gdb.base/langs0.c: Ditto.
	* gdb.base/list0.c: Ditto.
	* gdb.base/mips_pro.c: Ditto.
	* gdb.base/miscexprs.c: Ditto.
	* gdb.base/nodebug.c: Ditto.
	* gdb.base/opaque0.c: Ditto.
	* gdb.base/pointers.c: Ditto.
	* gdb.base/printcmds.c: Ditto.
	* gdb.base/ptype.c: Ditto.
	* gdb.base/recurse.c: Ditto.
	* gdb.base/reread1.c: Ditto.
	* gdb.base/reread2.c: Ditto.
	* gdb.base/restore.c: Ditto.
	* gdb.base/return.c: Ditto.
	* gdb.base/run.c: Ditto.
	* gdb.base/scope0.c: Ditto.
	* gdb.base/sepdebug.c: Ditto.
	* gdb.base/setshow.c: Ditto.
	* gdb.base/setvar.c: Ditto.
	* gdb.base/sigall.c: Ditto.
	* gdb.base/signals.c: Ditto.
	* gdb.base/structs.c: Ditto.
	* gdb.base/structs2.c: Ditto.
	* gdb.base/testenv.c: Ditto.
	* gdb.base/twice.c: Ditto.
	* gdb.base/unwindonsignal.c: Ditto.
	* gdb.base/watchpoint.c: Ditto.
	* gdb.base/watchpoints.c: Ditto.
	* gdb.base/whatis.c: Ditto.
	* gdb.cp/classes.cc: Ditto.
	* gdb.cp/cplusfuncs.cc: Ditto.
	* gdb.cp/derivation.cc: Ditto.
	* gdb.cp/formatted-ref.cc: Ditto.
	* gdb.cp/misc.cc: Ditto.
	* gdb.cp/overload.cc: Ditto.
	* gdb.cp/ovldbreak.cc: Ditto.
	* gdb.cp/ref-params.cc: Ditto.
	* gdb.cp/ref-types.cc: Ditto.
	* gdb.cp/templates.cc: Ditto.
	* gdb.cp/virtfunc.cc: Ditto.
	* gdb.hp/gdb.aCC/run.c: Ditto.
	* gdb.hp/gdb.base-hp/callfwmall.c: Ditto.
	* gdb.hp/gdb.compat/xdb0.c: Ditto.
	* gdb.reverse/consecutive-reverse.c: Ditto.
	* gdb.reverse/sigall-reverse.c: Ditto.
	* gdb.reverse/until-reverse.c: Ditto.
	* gdb.reverse/watch-reverse.c: Ditto.
	* gdb.trace/actions.c: Ditto.
	* gdb.trace/circ.c: Ditto.
	* gdb.trace/collection.c: Ditto.
@
text
@/* This test code is from Wendell Baker (wbaker@@comet.berkeley.edu) */

#include <stddef.h>

int a_i;
char a_c;
double a_d;

typedef void *Pix;

int
f(int i)
{ return 0; }

int
f(int i, char c)
{ return 0; }

int
f(int i, char c, double d)
{ return 0; }

int
f(int i, char c, double d, char *cs)
{ return 0; }

int
f(int i, char c, double d, char *cs, void (*fig)(int, char))
{ return 0; }

int
f(int i, char c, double d, char *cs, void (*fig)(char, int))
{ return 0; }

class R {
public:
    int i;
};
class S {
public:
    int i;
};
class T {
public:
    int i;
};

char g(char, const char, volatile char)
{ return 'c'; }
char g(R, char&, const char&, volatile char&)
{ return 'c'; }
char g(char*, const char*, volatile char*)
{ return 'c'; }
char g(S, char*&, const char*&, volatile char*&)
{ return 'c'; }

signed char g(T,signed char, const signed char, volatile signed char)
{ return 'c'; }
signed char g(T, R, signed char&, const signed char&, volatile signed char&)
{ return 'c'; }
signed char g(T, signed char*, const signed char*, volatile signed char*)
{ return 'c'; }
signed char g(T, S, signed char*&, const signed char*&, volatile signed char*&)
{ return 'c'; }

unsigned char g(unsigned char, const unsigned char, volatile unsigned char)
{ return 'c'; }
unsigned char g(R, unsigned char&, const unsigned char&, volatile unsigned char&)
{ return 'c'; }
unsigned char g(unsigned char*, const unsigned char*, volatile unsigned char*)
{ return 'c'; }
unsigned char g(S, unsigned char*&, const unsigned char*&, volatile unsigned char*&)
{ return 'c'; }

short g(short, const short, volatile short)
{ return 0; }
short g(R, short&, const short&, volatile short&)
{ return 0; }
short g(short*, const short*, volatile short*)
{ return 0; }
short g(S, short*&, const short*&, volatile short*&)
{ return 0; }

signed short g(T, signed short, const signed short, volatile signed short)
{ return 0; }
signed short g(T, R, signed short&, const signed short&, volatile signed short&)
{ return 0; }
signed short g(T, signed short*, const signed short*, volatile signed short*)
{ return 0; }
signed short g(T, S, double, signed short*&, const signed short*&, volatile signed short*&)
{ return 0; }

unsigned short g(unsigned short, const unsigned short, volatile unsigned short)
{ return 0; }
unsigned short g(R, unsigned short&, const unsigned short&, volatile unsigned short&)
{ return 0; }
unsigned short g(unsigned short*, const unsigned short*, volatile unsigned short*)
{ return 0; }
unsigned short g(S, unsigned short*&, const unsigned short*&, volatile unsigned short*&)
{ return 0; }

int g(int, const int, volatile int)
{ return 0; }
int g(R, int&, const int&, volatile int&)
{ return 0; }
int g(int*, const int*, volatile int*)
{ return 0; }
int g(S, int*&, const int*&, volatile int*&)
{ return 0; }

signed int g(T, signed int, const signed int, volatile signed int)
{ return 0; }
signed int g(T, R, signed int&, const signed int&, volatile signed int&)
{ return 0; }
signed int g(T, signed int*, const signed int*, volatile signed int*)
{ return 0; }
signed int g(T, S, signed int*&, const signed int*&, volatile signed int*&)
{ return 0; }

unsigned int g(unsigned int, const unsigned int, volatile unsigned int)
{ return 0; }
unsigned int g(R, unsigned int&, const unsigned int&, volatile unsigned int&)
{ return 0; }
unsigned int g(unsigned int*, const unsigned int*, volatile unsigned int*)
{ return 0; }
unsigned int g(S, unsigned int*&, const unsigned int*&, volatile unsigned int*&)
{ return 0; }

long g(long, const long, volatile long)
{ return 0; }
long g(R, long&, const long&, volatile long&)
{ return 0; }
long g(long*, const long*, volatile long*)
{ return 0; }
long g(S, long*&, const long*&, volatile long*&)
{ return 0; }

signed long g(T, signed long, const signed long, volatile signed long)
{ return 0; }
signed long g(T, R, signed long&, const signed long&, volatile signed long&)
{ return 0; }
signed long g(T, signed long*, const signed long*, volatile signed long*)
{ return 0; }
signed long g(T, S, signed long*&, const signed long*&, volatile signed long*&)
{ return 0; }

unsigned long g(unsigned long, const unsigned long, volatile unsigned long)
{ return 0; }
unsigned long g(S, unsigned long&, const unsigned long&, volatile unsigned long&)
{ return 0; }
unsigned long g(unsigned long*, const unsigned long*, volatile unsigned long*)
{ return 0; }
unsigned long g(S, unsigned long*&, const unsigned long*&, volatile unsigned long*&)
{ return 0; }

#ifdef __GNUC__
long long g(long long, const long long, volatile long long)
{ return 0; }
long long g(S, long long&, const long long&, volatile long long&)
{ return 0; }
long long g(long long*, const long long*, volatile long long*)
{ return 0; }
long long g(R, long long*&, const long long*&, volatile long long*&)
{ return 0; }

signed long long g(T, signed long long, const signed long long, volatile signed long long)
{ return 0; }
signed long long g(T, R, signed long long&, const signed long long&, volatile signed long long&)
{ return 0; }
signed long long g(T, signed long long*, const signed long long*, volatile signed long long*)
{ return 0; }
signed long long g(T, S, signed long long*&, const signed long long*&, volatile signed long long*&)
{ return 0; }

unsigned long long g(unsigned long long, const unsigned long long, volatile unsigned long long)
{ return 0; }
unsigned long long g(R, unsigned long long*, const unsigned long long*, volatile unsigned long long*)
{ return 0; }
unsigned long long g(unsigned long long&, const unsigned long long&, volatile unsigned long long&)
{ return 0; }
unsigned long long g(S, unsigned long long*&, const unsigned long long*&, volatile unsigned long long*&)
{ return 0; }
#endif

float g(float, const float, volatile float)
{ return 0; }
float g(char, float&, const float&, volatile float&)
{ return 0; }
float g(float*, const float*, volatile float*)
{ return 0; }
float g(char, float*&, const float*&, volatile float*&)
{ return 0; }

double g(double, const double, volatile double)
{ return 0; }
double g(char, double&, const double&, volatile double&)
{ return 0; }
double g(double*, const double*, volatile double*)
{ return 0; }
double g(char, double*&, const double*&, volatile double*&)
{ return 0; }

#ifdef __GNUC__
long double g(long double, const long double, volatile long double)
{ return 0; }
long double g(char, long double&, const long double&, volatile long double&)
{ return 0; }
long double g(long double*, const long double*, volatile long double*)
{ return 0; }
long double g(char, long double*&, const long double*&, volatile long double*&)
{ return 0; }
#endif

class c {
public:
    c(int) {};
    int i;
};

class c g(c, const c, volatile c)
{ return 0; }
c g(char, c&, const c&, volatile c&)
{ return 0; }
c g(c*, const c*, volatile c*)
{ return 0; }
c g(char, c*&, const c*&, volatile c*&)
{ return 0; }

/*
void h(char = 'a')
{ }
void h(char, signed char = 'a')
{ }
void h(unsigned char = 'a')
{ }
*/
/*
void h(char = (char)'a')
{ }
void h(char, signed char = (signed char)'a')
{ }
void h(unsigned char = (unsigned char)'a')
{ }


void h(short = (short)43)
{ }
void h(char, signed short = (signed short)43)
{ }
void h(unsigned short = (unsigned short)43)
{ }

void h(int = (int)43)
{ }
void h(char, signed int = (signed int)43)
{ }
void h(unsigned int = (unsigned int)43)
{ }


void h(long = (long)43)
{ }
void h(char, signed long = (signed long)43)
{ }
void h(unsigned long = (unsigned long)43)
{ }

#ifdef __GNUC__
void h(long long = 43)
{ }
void h(char, signed long long = 43)
{ }
void h(unsigned long long = 43)
{ }
#endif

void h(float = 4.3e-10)
{ }
void h(double = 4.3)
{ }
#ifdef __GNUC__
void h(long double = 4.33e33)
{ }
#endif
*/

/* An unneeded printf() definition - actually, just a stub - used to occupy
   this space.  It has been removed and replaced with this comment which
   exists to occupy some lines so that templates.exp won't need adjustment.  */

class T1 {
public:
    static void* operator new(size_t) throw ();
    static void operator delete(void *pointer);

    void operator=(const T1&);
    T1& operator=(int);

    int operator==(int) const;
    int operator==(const T1&) const;
    int operator!=(int) const;
    int operator!=(const T1&) const;

    int operator<=(int) const;
    int operator<=(const T1&) const;
    int operator<(int) const;
    int operator<(const T1&) const;
    int operator>=(int) const;
    int operator>=(const T1&) const;
    int operator>(int) const;
    int operator>(const T1&) const;

    void operator+(int) const;
    T1& operator+(const T1&) const;
    void operator+=(int) const;
    T1& operator+=(const T1&) const;

    T1& operator++() const;

    void operator-(int) const;
    T1& operator-(const T1&) const;
    void operator-=(int) const;
    T1& operator-=(const T1&) const;

    T1& operator--() const;

    void operator*(int) const;
    T1& operator*(const T1&) const;
    void operator*=(int) const;
    T1& operator*=(const T1&) const;

    void operator/(int) const;
    T1& operator/(const T1&) const;
    void operator/=(int) const;
    T1& operator/=(const T1&) const;

    void operator%(int) const;
    T1& operator%(const T1&) const;
    void operator%=(int) const;
    T1& operator%=(const T1&) const;

    void operator&&(int) const;
    T1& operator&&(const T1&) const;

    void operator||(int) const;
    T1& operator||(const T1&) const;

    void operator&(int) const;
    T1& operator&(const T1&) const;
    void operator&=(int) const;
    T1& operator&=(const T1&) const;

    void operator|(int) const;
    T1& operator|(const T1&) const;
    void operator|=(int) const;
    T1& operator|=(const T1&) const;

    void operator^(int) const;
    T1& operator^(const T1&) const;
    void operator^=(int) const;
    T1& operator^=(const T1&) const;

    T1& operator!() const;
    T1& operator~() const;
};

void* 
T1::operator new(size_t) throw ()
{ return 0; }

void
T1::operator delete(void *pointer)
{ }

class T2 {
public:
    T2(int i): integer(i)
	{ }
    int integer;
};

int operator==(const T2&, const T2&)
{ return 0; }
int operator==(const T2&, char)
{ return 0; }
int operator!=(const T2&, const T2&)
{ return 0; }
int operator!=(const T2&, char)
{ return 0; }

int operator<=(const T2&, const T2&)
{ return 0; }
int operator<=(const T2&, char)
{ return 0; }
int operator<(const T2&, const T2&)
{ return 0; }
int operator<(const T2&, char)
{ return 0; }
int operator>=(const T2&, const T2&)
{ return 0; }
int operator>=(const T2&, char)
{ return 0; }
int operator>(const T2&, const T2&)
{ return 0; }
int operator>(const T2&, char)
{ return 0; }

T2 operator+(const T2 t, int i)
{ return t.integer + i; }
T2 operator+(const T2 a, const T2& b)
{ return a.integer + b.integer; }
T2& operator+=(T2& t, int i)
{ t.integer += i; return t; }
T2& operator+=(T2& a, const T2& b)
{ a.integer += b.integer; return a; }

T2 operator-(const T2 t, int i)
{ return t.integer - i; }
T2 operator-(const T2 a, const T2& b)
{ return a.integer - b.integer; }
T2& operator-=(T2& t, int i)
{ t.integer -= i; return t; }
T2& operator-=(T2& a, const T2& b)
{ a.integer -= b.integer; return a; }

T2 operator*(const T2 t, int i)
{ return t.integer * i; }
T2 operator*(const T2 a, const T2& b)
{ return a.integer * b.integer; }
T2& operator*=(T2& t, int i)
{ t.integer *= i; return t; }
T2& operator*=(T2& a, const T2& b)
{ a.integer *= b.integer; return a; }

T2 operator/(const T2 t, int i)
{ return t.integer / i; }
T2 operator/(const T2 a, const T2& b)
{ return a.integer / b.integer; }
T2& operator/=(T2& t, int i)
{ t.integer /= i; return t; }
T2& operator/=(T2& a, const T2& b)
{ a.integer /= b.integer; return a; }

T2 operator%(const T2 t, int i)
{ return t.integer % i; }
T2 operator%(const T2 a, const T2& b)
{ return a.integer % b.integer; }
T2& operator%=(T2& t, int i)
{ t.integer %= i; return t; }
T2& operator%=(T2& a, const T2& b)
{ a.integer %= b.integer; return a; }

template<class T>
class T5 {
public:
    T5(int);
    T5(const T5<T>&);
    ~T5();
    static void* operator new(size_t) throw ();
    static void operator delete(void *pointer);
    int value();
    
    static T X;
    T x;
    int val;
};

template<class T>
T5<T>::T5(int v)
{ val = v; }

template<class T>
T5<T>::T5(const T5<T>&)
{}

template<class T>
T5<T>::~T5()
{}

template<class T>
void*
T5<T>::operator new(size_t) throw ()
{ return 0; }

template<class T>
void
T5<T>::operator delete(void *pointer)
{ }

template<class T>
int
T5<T>::value()
{ return val; }

template <class T>
T GetMax (T a, T b) {
  T result;
  result = (a>b)? a : b;
  // set breakpoint on a line with no real code
  return (result);
}

#if ! defined(__GNUC__) || defined(GCC_BUG)
template<class T>
T T5<T>::X;
#endif




T5<char> t5c(1);
T5<int> t5i(2);
T5<int (*)(char, void *)> t5fi1(3);
T5<int (*)(int, double **, void *)> t5fi2(4);

 




class x {
public:
    int (*manage[5])(double,
		     void *(*malloc)(unsigned size),
		     void (*free)(void *pointer));
    int (*device[5])(int open(const char *, unsigned mode, unsigned perms, int extra), 
		     int *(*read)(int fd, void *place, unsigned size),
		     int *(*write)(int fd, void *place, unsigned size),
		     void (*close)(int fd));
};
T5<x> t5x(5);

#if !defined(__GNUC__) || (__GNUC__ > 2) || (__GNUC__ == 2 && __GNUC_MINOR__ >= 6)
template class T5<char>;
template class T5<int>;
template class T5<int (*)(char, void *)>;
template class T5<int (*)(int, double **, void *)>;
template class T5<x>;
#endif

class T7 {
public:
    static int get();
    static void put(int);
};

int
T7::get()
{ return 1; }

void
T7::put(int i)
{
    // nothing
}

// More template kinds.  GDB 4.16 didn't handle these, but
// Wildebeest does.  Note: Assuming HP aCC is used to compile
// this file; with g++ or HP cfront or other compilers the
// demangling may not get done correctly.

// Ordinary template, to be instantiated with different types
template<class T>
class Foo {
public:
  int x;
  T t;
  T foo (int, T);
};


template<class T> T Foo<T>::foo (int i, T tt)
{
  return tt;
}

// Template with int parameter

template<class T, int sz>
class Bar {
public:
  int x;
  T t;
  T bar (int, T);
};


template<class T, int sz> T Bar<T, sz>::bar (int i, T tt)
{
  if (i < sz)
    return tt;
  else
    return 0;
}

// function template with int parameter
template<class T> int dummy (T tt, int i)
{
  return tt;
}

// Template with partial specializations
template<class T1, class T2>
class Spec {
public:
  int x;
  T1 spec (T2);
};

template<class T1, class T2>
T1 Spec<T1, T2>::spec (T2 t2)
{
  return 0;
}

template<class T>
class Spec<T, T*> {
public:
  int x;
  T spec (T*);
};

template<class T>
T Spec<T, T*>::spec (T * tp)
{
  return *tp;
}

// Template with char parameter
template<class T, char sz>
class Baz {
public:
  ~Baz () { };
  int x;
  T t;
  T baz (int, T);
};

template<class T, char sz> T Baz<T, sz>::baz (int i, T tt)
{
  if (i < sz)
    return tt;
  else
    return 0;
}

typedef Baz<int, 1> intBazOne;

// Template with char * parameter
template<class T, char * sz>
class Qux {
public:
  int x;
  T t;
  T qux (int, T);
};

template<class T, char * sz> T Qux<T, sz>::qux (int i, T tt)
{
  if (sz[0] == 'q')
    return tt;
  else
    return 0;
}

// Template with a function pointer parameter
template<class T, int (*f)(int) >
class Qux1 {
public:
  int x;
  T t;
  T qux (int, T);
};

template<class T, int (*f)(int)> T Qux1<T, f>::qux (int i, T tt)
{
  if (f != 0)
    return tt;
  else
    return 0;
}

// Some functions to provide as arguments to template
int gf1 (int a) {
  return a * 2 + 13;
}
int gf2 (int a) {
  return a * 2 + 26;
}

char string[3];


// Template for nested instantiations

template<class T>
class Garply {
public:
  int x;
  T t;
  T garply (int, T);
};

template<class T> T Garply<T>::garply (int i, T tt)
{
  if (i > x)
    return tt;
  else
    {
      x += i;
      return tt;
    }
}

template<class C> class Empty
{
};

template<class C> class FunctionArg
{
public:
  int method(Empty<void (FunctionArg<C>)> &);
};

template<class C> int FunctionArg<C>::method(Empty<void (FunctionArg<C>)> &arg)
{
  return 75;
}

Empty<void(FunctionArg<int>)> empty;
FunctionArg<int> arg;

int main()
{
    int i;
    long l, m, n;

    i = i + 1;

    // New tests added here

  Foo<int> fint={0,0};
  Foo<char> fchar={0,0};
  Foo<volatile char *> fvpchar = {0, 0};

  Bar<int, 33> bint;
  Bar<int, (4 > 3)> bint2;

  Baz<int, 's'> bazint;
  Baz<char, 'a'> bazint2;

  Qux<char, string> quxint2;
  Qux<int, string> quxint;

  Qux1<int, gf1> qux11;

  int x = fint.foo(33, 47);
  char c = fchar.foo(33, 'x');
  volatile char * cp = fvpchar.foo(33, 0);
  
  int y = dummy<int> (400, 600);

  int z = bint.bar(55, 66);
  z += bint2.bar(55, 66);

  c = bazint2.baz(4, 'y');
  c = quxint2.qux(4, 'z');
  
  y = bazint.baz(4,3);
  y = quxint.qux(4, 22);
  y += qux11.qux(4, 22);

  y *= gf1(y) - gf2(y);
  
  Spec<int, char> sic;
  Spec<int, int *> siip;

  sic.spec ('c');
  siip.spec (&x);

  Garply<int> f;
  Garply<char> fc;
  f.x = 13;

  Garply<Garply<char> > nf;
  nf.x = 31;
  
  x = f.garply (3, 4);
  
  fc = nf.garply (3, fc);

  y = x + fc.x;
  
  i=GetMax<int>(x,y);
  n=GetMax<long>(l,m);

  intBazOne ibo;
  z = ibo.baz (2, 21);

  t5i.value();

  arg.method(empty);

  return 0;
}
@


1.5
log
@	gdb/
	* dwarf2read.c (read_structure_type): Move processing of
	fields and member functions from here...
	(process_structure_scope): ... to here.

	gdb/testsuite/
	* gdb.cp/templates.cc (Empty, FunctionArg): New classes.
	(FunctionArg::method): New function.
	(empty, arg): New variables.
	(main): Call arg.method.
	* gdb.cp/templates.exp (test_template_args): New function.
	(do_tests): Call it.
@
text
@d737 1
a737 4
#ifdef usestubs
    set_debug_traps();
    breakpoint();
#endif
@


1.4
log
@	* gdb.base/find.c (main): Reference search buffers.
	* gdb.base/included.c (main): Reference integer.
	* gdb.base/ptype.c (charfoo): Declare.
	(intfoo): Call charfoo.
	* gdb.base/scope0.c (useitp): New function.
	(usestatics): Use useitp.
	(useit): Add a type for val.
	* gdb.base/scope1.c (useit1): Take a pointer argument.
	(usestatics1): Update calls to useit1.
	* gdb.cp/call-c.cc: Declare foo.
	(main): Call foo.
	* gdb.cp/m-static.cc (main): Reference test4.elsewhere.
	* gdb.cp/namespace.cc (ensureOtherRefs): Declare.
	(main): Call C::ensureRefs and ensureOtherRefs.
	* gdb.cp/namespace1.cc (C::ensureOtherRefs): Also reference int
	variables.
	(ensureOtherRefs): New function.
	* gdb.cp/overload.cc (main): Call all overloadNamespace variants.
	* gdb.cp/templates.cc (main): Call t5i.value.
@
text
@d715 17
d805 2
a808 13













@


1.3
log
@	* gdb.cp/classes.exp (do_tests): Add tests to print a constructor
	and destructor using typedef name of class.
	* gdb.cp/classes.cc (class Base1): Add a destructor.
	(base1): New typedef.
	(use_methods): Instanitate an object of type base1.
	* gdb.cp/templates.exp (test_template_typedef): New procedure.
	(do_tests): Call test_template_typedef.
	* gdb.cp/templates.cc (Baz::~Baz): New method.
	(intBazOne): New typedef.
	(main): Instantiate intBazOne.
@
text
@d785 3
a788 1
    
@


1.2
log
@	* gdb.cp/templates.cc (GetMax): New template.
	(main): Declare two instances of GetMax.
	* gdb.cp/templates.exp: Add new test.
@
text
@d633 1
d647 2
d783 2
@


1.1
log
@2003-08-22  Michael Chastain  <mec@@shout.net>

	* gdb.cp: New directory.
	* gdb.cp/*: Copy from gdb.c++/*.
	* gdb.c++/*: Remove.
	* Makefile.in: Change gdb.c++ to gdb.cp.
	* configure.in:  Ditto.
	* configure: Regnerate.
@
text
@d495 7
d716 1
d777 2
@


1.1.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.1.4.1
log
@2003-08-22  Michael Chastain  <mec@@shout.net>

	* gdb.cp: New directory.
	* gdb.cp/*: Copy from gdb.c++/*.
	* gdb.c++/*: Remove.
	* Makefile.in: Change gdb.c++ to gdb.cp.
	* configure.in:  Ditto.
	* carlton_runnamespace: Ditto.
	* carlton_runtest: Ditto.
	* configure: Regnerate.
@
text
@@


1.1.2.1
log
@2003-08-22  Michael Chastain  <mec@@shout.net>

	* gdb.cp: New directory.
	* gdb.cp/*: Copy from gdb.c++/*.
	* gdb.c++/*: Remove.
	* Makefile.in: Change gdb.c++ to gdb.cp.
	* configure.in:  Ditto.
	* configure: Regnerate.
@
text
@@

