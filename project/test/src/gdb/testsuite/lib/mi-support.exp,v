head	1.119;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.114
	gdb_7_6-2013-04-26-release:1.114
	gdb_7_6-branch:1.114.0.2
	gdb_7_6-2013-03-12-branchpoint:1.114
	gdb_7_5_1-2012-11-29-release:1.111.2.1
	gdb_7_5-2012-08-17-release:1.111.2.1
	gdb_7_5-branch:1.111.0.2
	gdb_7_5-2012-07-18-branchpoint:1.111
	gdb_7_4_1-2012-04-26-release:1.106.2.1
	gdb_7_4-2012-01-24-release:1.106.2.1
	gdb_7_4-branch:1.106.0.2
	gdb_7_4-2011-12-13-branchpoint:1.106
	gdb_7_3_1-2011-09-04-release:1.96
	gdb_7_3-2011-07-26-release:1.96
	gdb_7_3-branch:1.96.0.2
	gdb_7_3-2011-04-01-branchpoint:1.96
	gdb_7_2-2010-09-02-release:1.93
	gdb_7_2-branch:1.93.0.2
	gdb_7_2-2010-07-07-branchpoint:1.93
	gdb_7_1-2010-03-18-release:1.91
	gdb_7_1-branch:1.91.0.2
	gdb_7_1-2010-02-18-branchpoint:1.91
	gdb_7_0_1-2009-12-22-release:1.87
	gdb_7_0-2009-10-06-release:1.87
	gdb_7_0-branch:1.87.0.2
	gdb_7_0-2009-09-16-branchpoint:1.87
	arc-sim-20090309:1.51
	msnyder-checkpoint-072509-branch:1.85.0.2
	msnyder-checkpoint-072509-branchpoint:1.85
	arc-insight_6_8-branch:1.51.0.6
	arc-insight_6_8-branchpoint:1.51
	insight_6_8-branch:1.51.0.4
	insight_6_8-branchpoint:1.51
	reverse-20081226-branch:1.78.0.4
	reverse-20081226-branchpoint:1.78
	multiprocess-20081120-branch:1.78.0.2
	multiprocess-20081120-branchpoint:1.78
	reverse-20080930-branch:1.74.0.2
	reverse-20080930-branchpoint:1.74
	reverse-20080717-branch:1.66.0.2
	reverse-20080717-branchpoint:1.66
	msnyder-reverse-20080609-branch:1.60.0.2
	msnyder-reverse-20080609-branchpoint:1.60
	drow-reverse-20070409-branch:1.43.0.2
	drow-reverse-20070409-branchpoint:1.43
	gdb_6_8-2008-03-27-release:1.51
	gdb_6_8-branch:1.51.0.2
	gdb_6_8-2008-02-26-branchpoint:1.51
	gdb_6_7_1-2007-10-29-release:1.49
	gdb_6_7-2007-10-10-release:1.49
	gdb_6_7-branch:1.49.0.2
	gdb_6_7-2007-09-07-branchpoint:1.49
	insight_6_6-20070208-release:1.33
	gdb_6_6-2006-12-18-release:1.33
	gdb_6_6-branch:1.33.0.2
	gdb_6_6-2006-11-15-branchpoint:1.33
	insight_6_5-20061003-release:1.32
	gdb-csl-symbian-6_4_50_20060226-12:1.32.16.1
	gdb-csl-sourcerygxx-3_4_4-25:1.32
	nickrob-async-20060828-mergepoint:1.33
	gdb-csl-symbian-6_4_50_20060226-11:1.32
	gdb-csl-sourcerygxx-4_1-17:1.32
	gdb-csl-20060226-branch-local-2:1.32
	gdb-csl-sourcerygxx-4_1-14:1.32
	gdb-csl-sourcerygxx-4_1-13:1.32
	gdb-csl-sourcerygxx-4_1-12:1.32
	gdb-csl-sourcerygxx-3_4_4-21:1.32
	gdb_6_5-20060621-release:1.32
	gdb-csl-sourcerygxx-4_1-9:1.32
	gdb-csl-sourcerygxx-4_1-8:1.32
	gdb-csl-sourcerygxx-4_1-7:1.32
	gdb-csl-arm-2006q1-6:1.32
	gdb-csl-sourcerygxx-4_1-6:1.32
	gdb-csl-symbian-6_4_50_20060226-10:1.32
	gdb-csl-symbian-6_4_50_20060226-9:1.32
	gdb-csl-symbian-6_4_50_20060226-8:1.32
	gdb-csl-coldfire-4_1-11:1.32
	gdb-csl-sourcerygxx-3_4_4-19:1.32
	gdb-csl-coldfire-4_1-10:1.32
	gdb_6_5-branch:1.32.0.24
	gdb_6_5-2006-05-14-branchpoint:1.32
	gdb-csl-sourcerygxx-4_1-5:1.32
	nickrob-async-20060513-branch:1.32.0.22
	nickrob-async-20060513-branchpoint:1.32
	gdb-csl-sourcerygxx-4_1-4:1.32
	msnyder-reverse-20060502-branch:1.32.0.20
	msnyder-reverse-20060502-branchpoint:1.32
	gdb-csl-morpho-4_1-4:1.32
	gdb-csl-sourcerygxx-3_4_4-17:1.32
	readline_5_1-import-branch:1.32.0.18
	readline_5_1-import-branchpoint:1.32
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.32
	gdb-csl-symbian-20060226-branch:1.32.0.16
	gdb-csl-symbian-20060226-branchpoint:1.32
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.32
	msnyder-reverse-20060331-branch:1.32.0.14
	msnyder-reverse-20060331-branchpoint:1.32
	gdb-csl-available-20060303-branch:1.32.0.12
	gdb-csl-available-20060303-branchpoint:1.32
	gdb-csl-20060226-branch:1.32.0.10
	gdb-csl-20060226-branchpoint:1.32
	gdb_6_4-20051202-release:1.32
	msnyder-fork-checkpoint-branch:1.32.0.8
	msnyder-fork-checkpoint-branchpoint:1.32
	gdb-csl-gxxpro-6_3-branch:1.32.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.32
	gdb_6_4-branch:1.32.0.4
	gdb_6_4-2005-11-01-branchpoint:1.32
	gdb-csl-arm-20051020-branch:1.32.0.2
	gdb-csl-arm-20051020-branchpoint:1.32
	gdb-csl-arm-20050325-2005-q1b:1.25.2.1
	gdb-csl-arm-20050325-2005-q1a:1.25.2.1
	csl-arm-20050325-branch:1.25.0.2
	csl-arm-20050325-branchpoint:1.25
	gdb-post-i18n-errorwarning-20050211:1.24
	gdb-pre-i18n-errorwarning-20050211:1.24
	gdb_6_3-20041109-release:1.24
	gdb_6_3-branch:1.24.0.16
	gdb_6_3-20041019-branchpoint:1.24
	drow_intercu-merge-20040921:1.24
	drow_intercu-merge-20040915:1.24
	jimb-gdb_6_2-e500-branch:1.24.0.18
	jimb-gdb_6_2-e500-branchpoint:1.24
	gdb_6_2-20040730-release:1.24
	gdb_6_2-branch:1.24.0.14
	gdb_6_2-2004-07-10-gmt-branchpoint:1.24
	gdb_6_1_1-20040616-release:1.24
	gdb_6_1-2004-04-05-release:1.24
	drow_intercu-merge-20040402:1.24
	drow_intercu-merge-20040327:1.24
	ezannoni_pie-20040323-branch:1.24.0.12
	ezannoni_pie-20040323-branchpoint:1.24
	cagney_tramp-20040321-mergepoint:1.24
	cagney_tramp-20040309-branch:1.24.0.10
	cagney_tramp-20040309-branchpoint:1.24
	gdb_6_1-branch:1.24.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.24
	drow_intercu-20040221-branch:1.24.0.6
	drow_intercu-20040221-branchpoint:1.24
	cagney_bfdfile-20040213-branch:1.24.0.4
	cagney_bfdfile-20040213-branchpoint:1.24
	drow-cplus-merge-20040208:1.24
	carlton_dictionary-20040126-merge:1.24
	cagney_bigcore-20040122-branch:1.24.0.2
	cagney_bigcore-20040122-branchpoint:1.24
	drow-cplus-merge-20040113:1.23
	drow-cplus-merge-20031224:1.23
	drow-cplus-merge-20031220:1.23
	carlton_dictionary-20031215-merge:1.23
	drow-cplus-merge-20031214:1.23
	carlton-dictionary-20031111-merge:1.23
	gdb_6_0-2003-10-04-release:1.23
	kettenis_sparc-20030918-branch:1.23.0.8
	kettenis_sparc-20030918-branchpoint:1.23
	carlton_dictionary-20030917-merge:1.23
	ezannoni_pie-20030916-branchpoint:1.23
	ezannoni_pie-20030916-branch:1.23.0.6
	cagney_x86i386-20030821-branch:1.23.0.4
	cagney_x86i386-20030821-branchpoint:1.23
	carlton_dictionary-20030805-merge:1.23
	carlton_dictionary-20030627-merge:1.23
	gdb_6_0-branch:1.23.0.2
	gdb_6_0-2003-06-23-branchpoint:1.23
	jimb-ppc64-linux-20030613-branch:1.22.0.18
	jimb-ppc64-linux-20030613-branchpoint:1.22
	cagney_convert-20030606-branch:1.22.0.16
	cagney_convert-20030606-branchpoint:1.22
	cagney_writestrings-20030508-branch:1.22.0.14
	cagney_writestrings-20030508-branchpoint:1.22
	jimb-ppc64-linux-20030528-branch:1.22.0.12
	jimb-ppc64-linux-20030528-branchpoint:1.22
	carlton_dictionary-20030523-merge:1.22
	cagney_fileio-20030521-branch:1.22.0.10
	cagney_fileio-20030521-branchpoint:1.22
	kettenis_i386newframe-20030517-mergepoint:1.22
	jimb-ppc64-linux-20030509-branch:1.22.0.8
	jimb-ppc64-linux-20030509-branchpoint:1.22
	kettenis_i386newframe-20030504-mergepoint:1.22
	carlton_dictionary-20030430-merge:1.22
	kettenis_i386newframe-20030419-branch:1.22.0.6
	kettenis_i386newframe-20030419-branchpoint:1.22
	carlton_dictionary-20030416-merge:1.22
	cagney_frameaddr-20030409-mergepoint:1.22
	kettenis_i386newframe-20030406-branch:1.22.0.4
	kettenis_i386newframe-20030406-branchpoint:1.22
	cagney_frameaddr-20030403-branchpoint:1.22
	cagney_frameaddr-20030403-branch:1.22.0.2
	cagney_framebase-20030330-mergepoint:1.21
	cagney_framebase-20030326-branch:1.21.0.12
	cagney_framebase-20030326-branchpoint:1.21
	cagney_lazyid-20030317-branch:1.21.0.10
	cagney_lazyid-20030317-branchpoint:1.21
	kettenis-i386newframe-20030316-mergepoint:1.21
	offbyone-20030313-branch:1.21.0.8
	offbyone-20030313-branchpoint:1.21
	kettenis-i386newframe-20030308-branch:1.21.0.6
	kettenis-i386newframe-20030308-branchpoint:1.21
	carlton_dictionary-20030305-merge:1.21
	cagney_offbyone-20030303-branch:1.21.0.4
	cagney_offbyone-20030303-branchpoint:1.21
	carlton_dictionary-20030207-merge:1.21
	interps-20030203-mergepoint:1.21
	interps-20030202-branch:1.21.0.2
	interps-20030202-branchpoint:1.21
	cagney-unwind-20030108-branch:1.20.0.2
	cagney-unwind-20030108-branchpoint:1.20
	carlton_dictionary-20021223-merge:1.20
	gdb_5_3-2002-12-12-release:1.14
	carlton_dictionary-20021115-merge:1.18
	kseitz_interps-20021105-merge:1.17
	kseitz_interps-20021103-merge:1.17
	drow-cplus-merge-20021020:1.17
	drow-cplus-merge-20021025:1.17
	carlton_dictionary-20021025-merge:1.17
	carlton_dictionary-20021011-merge:1.17
	drow-cplus-branch:1.17.0.4
	drow-cplus-branchpoint:1.17
	kseitz_interps-20020930-merge:1.17
	carlton_dictionary-20020927-merge:1.17
	carlton_dictionary-branch:1.17.0.2
	carlton_dictionary-20020920-branchpoint:1.17
	gdb_5_3-branch:1.14.0.2
	gdb_5_3-2002-09-04-branchpoint:1.14
	kseitz_interps-20020829-merge:1.14
	cagney_sysregs-20020825-branch:1.13.0.12
	cagney_sysregs-20020825-branchpoint:1.13
	readline_4_3-import-branch:1.13.0.10
	readline_4_3-import-branchpoint:1.13
	gdb_5_2_1-2002-07-23-release:1.13
	kseitz_interps-20020528-branch:1.13.0.8
	kseitz_interps-20020528-branchpoint:1.13
	cagney_regbuf-20020515-branch:1.13.0.6
	cagney_regbuf-20020515-branchpoint:1.13
	jimb-macro-020506-branch:1.13.0.4
	jimb-macro-020506-branchpoint:1.13
	gdb_5_2-2002-04-29-release:1.13
	gdb_5_2-branch:1.13.0.2
	gdb_5_2-2002-03-03-branchpoint:1.13
	gdb_5_1_1-2002-01-24-release:1.8.4.3
	gdb_5_1_0_1-2002-01-03-release:1.8.4.3
	cygnus_cvs_20020108_pre:1.13
	gdb_5_1_0_1-2002-01-03-branch:1.8.4.3.0.2
	gdb_5_1_0_1-2002-01-03-branchpoint:1.8.4.3
	gdb_5_1-2001-11-21-release:1.8.4.3
	gdb_s390-2001-09-26-branch:1.8.0.6
	gdb_s390-2001-09-26-branchpoint:1.8
	gdb_5_1-2001-07-29-branch:1.8.0.4
	gdb_5_1-2001-07-29-branchpoint:1.8
	dberlin-typesystem-branch:1.8.0.2
	dberlin-typesystem-branchpoint:1.8
	gdb-post-ptid_t-2001-05-03:1.5
	gdb-pre-ptid_t-2001-05-03:1.5
	insight-precleanup-2001-01-01:1.3
	gdb-post-protoization-2000-07-29:1.2
	gdb-pre-protoization-2000-07-29:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb-post-params-removal-2000-06-04:1.2
	gdb-pre-params-removal-2000-06-04:1.2
	gdb-post-params-removal-2000-05-28:1.2
	gdb-pre-params-removal-2000-05-28:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2;
locks; strict;
comment	@# @;


1.119
date	2013.10.07.19.10.45;	author tromey;	state Exp;
branches;
next	1.118;

1.118
date	2013.09.23.18.11.49;	author tromey;	state Exp;
branches;
next	1.117;

1.117
date	2013.09.23.18.07.46;	author tromey;	state Exp;
branches;
next	1.116;

1.116
date	2013.06.07.17.31.09;	author palves;	state Exp;
branches;
next	1.115;

1.115
date	2013.03.14.13.34.06;	author qiyao;	state Exp;
branches;
next	1.114;

1.114
date	2013.01.21.23.57.59;	author marckhouzam;	state Exp;
branches;
next	1.113;

1.113
date	2013.01.01.06.41.28;	author brobecke;	state Exp;
branches;
next	1.112;

1.112
date	2012.07.25.20.19.56;	author jkratoch;	state Exp;
branches;
next	1.111;

1.111
date	2012.04.14.12.18.44;	author xgsa;	state Exp;
branches
	1.111.2.1;
next	1.110;

1.110
date	2012.03.16.16.47.34;	author gary;	state Exp;
branches;
next	1.109;

1.109
date	2012.01.24.21.39.18;	author tromey;	state Exp;
branches;
next	1.108;

1.108
date	2012.01.12.22.28.34;	author kseitz;	state Exp;
branches;
next	1.107;

1.107
date	2012.01.04.08.27.56;	author brobecke;	state Exp;
branches;
next	1.106;

1.106
date	2011.12.03.20.20.29;	author jkratoch;	state Exp;
branches
	1.106.2.1;
next	1.105;

1.105
date	2011.12.02.22.35.17;	author jkratoch;	state Exp;
branches;
next	1.104;

1.104
date	2011.11.23.21.02.55;	author kseitz;	state Exp;
branches;
next	1.103;

1.103
date	2011.11.22.21.25.19;	author tromey;	state Exp;
branches;
next	1.102;

1.102
date	2011.11.08.19.51.17;	author macro;	state Exp;
branches;
next	1.101;

1.101
date	2011.11.01.20.00.01;	author jkratoch;	state Exp;
branches;
next	1.100;

1.100
date	2011.10.28.08.32.35;	author jkratoch;	state Exp;
branches;
next	1.99;

1.99
date	2011.08.09.17.45.19;	author palves;	state Exp;
branches;
next	1.98;

1.98
date	2011.04.28.07.31.29;	author jkratoch;	state Exp;
branches;
next	1.97;

1.97
date	2011.04.27.10.17.38;	author vprus;	state Exp;
branches;
next	1.96;

1.96
date	2011.03.07.16.03.04;	author tromey;	state Exp;
branches;
next	1.95;

1.95
date	2011.01.01.15.33.52;	author brobecke;	state Exp;
branches;
next	1.94;

1.94
date	2010.10.02.17.48.23;	author macro;	state Exp;
branches;
next	1.93;

1.93
date	2010.03.15.03.43.13;	author jiez;	state Exp;
branches;
next	1.92;

1.92
date	2010.03.12.19.17.01;	author palves;	state Exp;
branches;
next	1.91;

1.91
date	2010.01.28.22.14.12;	author drow;	state Exp;
branches;
next	1.90;

1.90
date	2010.01.12.21.40.25;	author vprus;	state Exp;
branches;
next	1.89;

1.89
date	2010.01.01.07.57.56;	author jkratoch;	state Exp;
branches;
next	1.88;

1.88
date	2010.01.01.07.32.07;	author brobecke;	state Exp;
branches;
next	1.87;

1.87
date	2009.09.15.18.51.26;	author tromey;	state Exp;
branches;
next	1.86;

1.86
date	2009.08.03.12.39.01;	author vprus;	state Exp;
branches;
next	1.85;

1.85
date	2009.06.30.20.23.05;	author jkratoch;	state Exp;
branches;
next	1.84;

1.84
date	2009.05.28.01.09.20;	author tromey;	state Exp;
branches;
next	1.83;

1.83
date	2009.04.02.15.43.10;	author palves;	state Exp;
branches;
next	1.82;

1.82
date	2009.02.18.07.28.34;	author vprus;	state Exp;
branches;
next	1.81;

1.81
date	2009.02.14.15.24.44;	author vprus;	state Exp;
branches;
next	1.80;

1.80
date	2009.01.30.18.43.05;	author vprus;	state Exp;
branches;
next	1.79;

1.79
date	2009.01.03.05.58.08;	author brobecke;	state Exp;
branches;
next	1.78;

1.78
date	2008.11.17.16.43.34;	author vprus;	state Exp;
branches;
next	1.77;

1.77
date	2008.11.17.12.34.19;	author vprus;	state Exp;
branches;
next	1.76;

1.76
date	2008.11.11.01.23.34;	author devans;	state Exp;
branches;
next	1.75;

1.75
date	2008.10.23.23.11.21;	author palves;	state Exp;
branches;
next	1.74;

1.74
date	2008.09.22.11.00.41;	author palves;	state Exp;
branches;
next	1.73;

1.73
date	2008.09.13.17.54.06;	author drow;	state Exp;
branches;
next	1.72;

1.72
date	2008.08.19.14.13.29;	author vprus;	state Exp;
branches;
next	1.71;

1.71
date	2008.08.19.13.05.02;	author vprus;	state Exp;
branches;
next	1.70;

1.70
date	2008.08.06.12.52.08;	author jkratoch;	state Exp;
branches;
next	1.69;

1.69
date	2008.07.31.07.38.51;	author vprus;	state Exp;
branches;
next	1.68;

1.68
date	2008.07.30.17.08.45;	author vprus;	state Exp;
branches;
next	1.67;

1.67
date	2008.07.27.20.57.43;	author drow;	state Exp;
branches;
next	1.66;

1.66
date	2008.07.12.12.41.56;	author vprus;	state Exp;
branches;
next	1.65;

1.65
date	2008.06.28.11.31.02;	author vprus;	state Exp;
branches;
next	1.64;

1.64
date	2008.06.28.10.14.34;	author vprus;	state Exp;
branches;
next	1.63;

1.63
date	2008.06.25.14.32.34;	author vprus;	state Exp;
branches;
next	1.62;

1.62
date	2008.06.10.10.23.54;	author vprus;	state Exp;
branches;
next	1.61;

1.61
date	2008.06.10.09.35.09;	author vprus;	state Exp;
branches;
next	1.60;

1.60
date	2008.05.04.12.15.54;	author vprus;	state Exp;
branches;
next	1.59;

1.59
date	2008.04.30.18.25.53;	author drow;	state Exp;
branches;
next	1.58;

1.58
date	2008.04.24.12.09.49;	author vprus;	state Exp;
branches;
next	1.57;

1.57
date	2008.04.24.08.46.19;	author vprus;	state Exp;
branches;
next	1.56;

1.56
date	2008.04.15.14.33.55;	author aristovski;	state Exp;
branches;
next	1.55;

1.55
date	2008.04.13.09.33.49;	author vprus;	state Exp;
branches;
next	1.54;

1.54
date	2008.04.05.17.12.46;	author vprus;	state Exp;
branches;
next	1.53;

1.53
date	2008.03.28.16.32.11;	author aristovski;	state Exp;
branches;
next	1.52;

1.52
date	2008.03.26.13.24.22;	author vprus;	state Exp;
branches;
next	1.51;

1.51
date	2008.01.29.19.36.58;	author jimb;	state Exp;
branches
	1.51.6.1;
next	1.50;

1.50
date	2008.01.01.22.53.22;	author drow;	state Exp;
branches;
next	1.49;

1.49
date	2007.08.23.18.14.19;	author brobecke;	state Exp;
branches;
next	1.48;

1.48
date	2007.07.23.22.53.27;	author kevinb;	state Exp;
branches;
next	1.47;

1.47
date	2007.05.23.12.41.14;	author drow;	state Exp;
branches;
next	1.46;

1.46
date	2007.04.29.16.20.50;	author drow;	state Exp;
branches;
next	1.45;

1.45
date	2007.04.25.15.56.15;	author vprus;	state Exp;
branches;
next	1.44;

1.44
date	2007.04.14.09.51.30;	author vprus;	state Exp;
branches;
next	1.43;

1.43
date	2007.04.01.15.27.26;	author vprus;	state Exp;
branches;
next	1.42;

1.42
date	2007.03.27.17.59.38;	author drow;	state Exp;
branches;
next	1.41;

1.41
date	2007.02.08.20.35.08;	author nickrob;	state Exp;
branches;
next	1.40;

1.40
date	2007.01.24.10.49.31;	author vprus;	state Exp;
branches;
next	1.39;

1.39
date	2007.01.09.17.59.14;	author drow;	state Exp;
branches;
next	1.38;

1.38
date	2007.01.04.21.55.04;	author drow;	state Exp;
branches;
next	1.37;

1.37
date	2007.01.04.20.12.15;	author vprus;	state Exp;
branches;
next	1.36;

1.36
date	2007.01.04.18.58.03;	author vprus;	state Exp;
branches;
next	1.35;

1.35
date	2006.12.08.14.29.02;	author vprus;	state Exp;
branches;
next	1.34;

1.34
date	2006.12.08.12.44.11;	author vprus;	state Exp;
branches;
next	1.33;

1.33
date	2006.07.24.20.38.08;	author drow;	state Exp;
branches;
next	1.32;

1.32
date	2005.09.27.22.39.04;	author bobbybrasko;	state Exp;
branches
	1.32.16.1
	1.32.22.1;
next	1.31;

1.31
date	2005.09.11.20.24.54;	author bobbybrasko;	state Exp;
branches;
next	1.30;

1.30
date	2005.08.09.19.00.16;	author corinna;	state Exp;
branches;
next	1.29;

1.29
date	2005.08.04.01.52.31;	author bobbybrasko;	state Exp;
branches;
next	1.28;

1.28
date	2005.08.02.14.21.01;	author bobbybrasko;	state Exp;
branches;
next	1.27;

1.27
date	2005.05.18.03.41.59;	author drow;	state Exp;
branches;
next	1.26;

1.26
date	2005.03.25.20.38.55;	author drow;	state Exp;
branches;
next	1.25;

1.25
date	2005.03.14.15.42.52;	author pbrook;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2004.01.18.15.23.30;	author drow;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.22.00.04.27;	author drow;	state Exp;
branches
	1.23.6.1;
next	1.22;

1.22
date	2003.04.03.16.34.48;	author cagney;	state Exp;
branches;
next	1.21;

1.21
date	2003.01.31.13.11.26;	author msalter;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2002.12.16.20.03.17;	author jjohnstn;	state Exp;
branches;
next	1.19;

1.19
date	2002.11.25.19.54.09;	author jimb;	state Exp;
branches;
next	1.18;

1.18
date	2002.11.08.20.37.50;	author jjohnstn;	state Exp;
branches;
next	1.17;

1.17
date	2002.09.10.22.28.19;	author kseitz;	state Exp;
branches
	1.17.2.1
	1.17.4.1;
next	1.16;

1.16
date	2002.09.10.22.07.58;	author kseitz;	state Exp;
branches;
next	1.15;

1.15
date	2002.09.04.21.05.07;	author kseitz;	state Exp;
branches;
next	1.14;

1.14
date	2002.08.29.16.10.13;	author kseitz;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.12.19.44.28;	author drow;	state Exp;
branches
	1.13.8.1;
next	1.12;

1.12
date	2001.11.11.20.11.03;	author drow;	state Exp;
branches;
next	1.11;

1.11
date	2001.10.21.19.43.41;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.19.01.02.58;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.18.21.34.28;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.27.17.27.08;	author cagney;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	2001.06.26.04.48.49;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.23.21.47.09;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.06.08.22.01;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.21.15.07.05;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.20.21.24.28;	author fnasser;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.04.03.01.38;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.23.00.25.43;	author cagney;	state Exp;
branches;
next	;

1.111.2.1
date	2012.07.25.20.35.30;	author jkratoch;	state Exp;
branches;
next	;

1.106.2.1
date	2012.01.06.04.54.30;	author brobecke;	state Exp;
branches;
next	;

1.51.6.1
date	2009.09.11.04.45.51;	author amylaar;	state Exp;
branches;
next	;

1.32.16.1
date	2006.09.15.16.01.57;	author drow;	state Exp;
branches;
next	;

1.32.22.1
date	2006.08.28.07.48.41;	author nickrob;	state Exp;
branches;
next	;

1.25.2.1
date	2005.03.25.20.44.01;	author drow;	state Exp;
branches;
next	;

1.23.6.1
date	2004.03.23.20.12.35;	author ezannoni;	state Exp;
branches;
next	;

1.21.2.1
date	2003.02.03.06.02.47;	author cagney;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2003.02.03.21.13.29;	author cagney;	state Exp;
branches;
next	1.21.2.3;

1.21.2.3
date	2003.02.04.01.26.55;	author cagney;	state Exp;
branches;
next	;

1.17.2.1
date	2002.11.15.19.19.19;	author carlton;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2002.12.23.19.39.20;	author carlton;	state Exp;
branches;
next	1.17.2.3;

1.17.2.3
date	2003.02.07.19.18.00;	author carlton;	state Exp;
branches;
next	1.17.2.4;

1.17.2.4
date	2003.04.16.19.57.03;	author carlton;	state Exp;
branches;
next	1.17.2.5;

1.17.2.5
date	2003.06.27.21.50.21;	author carlton;	state Exp;
branches;
next	1.17.2.6;

1.17.2.6
date	2004.01.26.19.11.44;	author carlton;	state Exp;
branches;
next	;

1.17.4.1
date	2003.12.14.20.27.58;	author drow;	state Exp;
branches;
next	1.17.4.2;

1.17.4.2
date	2004.02.09.19.43.56;	author drow;	state Exp;
branches;
next	;

1.13.8.1
date	2002.06.19.18.50.30;	author kseitz;	state Exp;
branches;
next	1.13.8.2;

1.13.8.2
date	2002.06.25.00.01.29;	author kseitz;	state Exp;
branches;
next	1.13.8.3;

1.13.8.3
date	2002.07.22.22.01.56;	author kseitz;	state Exp;
branches;
next	1.13.8.4;

1.13.8.4
date	2002.08.29.16.11.08;	author kseitz;	state Exp;
branches;
next	1.13.8.5;

1.13.8.5
date	2002.09.04.20.17.13;	author kseitz;	state Exp;
branches;
next	1.13.8.6;

1.13.8.6
date	2002.09.05.13.24.38;	author kseitz;	state Exp;
branches;
next	1.13.8.7;

1.13.8.7
date	2002.09.11.20.25.36;	author kseitz;	state Exp;
branches;
next	1.13.8.8;

1.13.8.8
date	2002.10.01.00.46.33;	author kseitz;	state Exp;
branches;
next	;

1.8.4.1
date	2001.10.21.19.41.20;	author cagney;	state Exp;
branches;
next	1.8.4.2;

1.8.4.2
date	2001.11.11.20.07.10;	author drow;	state Exp;
branches;
next	1.8.4.3;

1.8.4.3
date	2001.11.12.19.48.31;	author drow;	state Exp;
branches;
next	;


desc
@@


1.119
log
@	* lib/mi-support.exp (varobj_tree::walk_tree): Set _root_idx
	to 0.
@
text
@# Copyright 1999-2013 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# This file was based on a file written by Fred Fish. (fnf@@cygnus.com)

# Test setup routines that work with the MI interpreter.

# The variable mi_gdb_prompt is a regexp which matches the gdb mi prompt.
# Set it if it is not already set.
global mi_gdb_prompt
if ![info exists mi_gdb_prompt] then {
    set mi_gdb_prompt "\[(\]gdb\[)\] \r\n"
}

global mi_inferior_spawn_id
global mi_inferior_tty_name

set MIFLAGS "-i=mi"

set thread_selected_re "=thread-selected,id=\"\[0-9\]+\"\r\n"
set gdbindex_warning_re "&\"warning: Skipping \[^\r\n\]+ \.gdb_index section in \[^\r\n\]+\"\r\n(?:&\"\\\\n\"\r\n)?"
set library_loaded_re "=library-loaded\[^\n\]+\"\r\n(?:$gdbindex_warning_re)?"
set breakpoint_re "=(?:breakpoint-created|breakpoint-deleted)\[^\n\]+\"\r\n"

#
# mi_gdb_exit -- exit the GDB, killing the target program if necessary
#
proc mi_gdb_exit {} {
    catch mi_uncatched_gdb_exit
}

proc mi_uncatched_gdb_exit {} {
    global GDB
    global INTERNAL_GDBFLAGS GDBFLAGS
    global verbose
    global gdb_spawn_id
    global gdb_prompt
    global mi_gdb_prompt
    global MIFLAGS

    gdb_stop_suppressing_tests

    if { [info procs sid_exit] != "" } {
	sid_exit
    }

    if ![info exists gdb_spawn_id] {
	return
    }

    verbose "Quitting $GDB $INTERNAL_GDBFLAGS $GDBFLAGS $MIFLAGS"

    if { [is_remote host] && [board_info host exists fileid] } {
	send_gdb "999-gdb-exit\n"
	gdb_expect 10 {
	    -re "y or n" {
		send_gdb "y\n"
		exp_continue
	    }
            -re "Undefined command.*$gdb_prompt $" {
                send_gdb "quit\n"
		exp_continue
            }
	    -re "DOSEXIT code" { }
	    default { }
	}
    }

    if ![is_remote host] {
	remote_close host
    }
    unset gdb_spawn_id
}

#
# default_mi_gdb_start [INFERIOR_PTY] -- start gdb running, default procedure
#
# INFERIOR_PTY should be set to separate-inferior-tty to have the inferior work 
# with it's own PTY. If set to same-inferior-tty, the inferior shares GDB's PTY. 
# The default value is same-inferior-tty.
#
# When running over NFS, particularly if running many simultaneous
# tests on different hosts all using the same server, things can
# get really slow.  Give gdb at least 3 minutes to start up.
#
proc default_mi_gdb_start { args } {
    global verbose use_gdb_stub
    global GDB
    global INTERNAL_GDBFLAGS GDBFLAGS
    global gdb_prompt
    global mi_gdb_prompt
    global timeout
    global gdb_spawn_id
    global MIFLAGS

    gdb_stop_suppressing_tests
    set inferior_pty no-tty

    # Set the default value, it may be overriden later by specific testfile.
    set use_gdb_stub [target_info exists use_gdb_stub]

    if { [llength $args] == 1} {
	set inferior_pty [lindex $args 0]
    }

    set separate_inferior_pty [string match $inferior_pty separate-inferior-tty]

    # Start SID.
    if { [info procs sid_start] != "" } {
	verbose "Spawning SID"
	sid_start
    }

    verbose "Spawning $GDB $INTERNAL_GDBFLAGS $GDBFLAGS $MIFLAGS"

    if [info exists gdb_spawn_id] {
	return 0
    }

    if ![is_remote host] {
	if { [which $GDB] == 0 } then {
	    perror "$GDB does not exist."
	    exit 1
	}
    }

    # Create the new PTY for the inferior process.
    if { $separate_inferior_pty } {
	spawn -pty
	global mi_inferior_spawn_id
	global mi_inferior_tty_name
	set mi_inferior_spawn_id $spawn_id
	set mi_inferior_tty_name $spawn_out(slave,name)
    }

    set res [remote_spawn host "$GDB $INTERNAL_GDBFLAGS $GDBFLAGS $MIFLAGS [host_info gdb_opts]"]
    if { $res < 0 || $res == "" } {
	perror "Spawning $GDB failed."
	return 1
    }
    gdb_expect {
	-re "~\"GNU.*\r\n~\".*$mi_gdb_prompt$" {
	    # We have a new format mi startup prompt.  If we are
	    # running mi1, then this is an error as we should be
	    # using the old-style prompt.
	    if { $MIFLAGS == "-i=mi1" } {
	        perror "(mi startup) Got unexpected new mi prompt."
	        remote_close host
	        return -1
	    }
	    verbose "GDB initialized."
	}
	-re "\[^~\].*$mi_gdb_prompt$" {
	    # We have an old format mi startup prompt.  If we are
	    # not running mi1, then this is an error as we should be
	    # using the new-style prompt.
	    if { $MIFLAGS != "-i=mi1" } {
	        perror "(mi startup) Got unexpected old mi prompt."
	        remote_close host
	        return -1
	    }
	    verbose "GDB initialized."
	}
	-re ".*unrecognized option.*for a complete list of options." {
	    untested "Skip mi tests (not compiled with mi support)."
	    remote_close host
	    return -1
	}
	-re ".*Interpreter `mi' unrecognized." {
	    untested "Skip mi tests (not compiled with mi support)."
	    remote_close host
	    return -1
	}
	timeout {
	    perror "(timeout) GDB never initialized after 10 seconds."
	    remote_close host
	    return -1
	}
    }
    set gdb_spawn_id -1

    # FIXME: mi output does not go through pagers, so these can be removed.
    # force the height to "unlimited", so no pagers get used
    send_gdb "100-gdb-set height 0\n"
    gdb_expect 10 {
	-re ".*100-gdb-set height 0\r\n100\\\^done\r\n$mi_gdb_prompt$" { 
	    verbose "Setting height to 0." 2
	}
	timeout {
	    warning "Couldn't set the height to 0"
	}
    }
    # force the width to "unlimited", so no wraparound occurs
    send_gdb "101-gdb-set width 0\n"
    gdb_expect 10 {
	-re ".*101-gdb-set width 0\r\n101\\\^done\r\n$mi_gdb_prompt$" {
	    verbose "Setting width to 0." 2
	}
	timeout {
	    warning "Couldn't set the width to 0."
	}
    }
    # If allowing the inferior to have its own PTY then assign the inferior
    # its own terminal device here.
    if { $separate_inferior_pty } {
	send_gdb "102-inferior-tty-set $mi_inferior_tty_name\n"
	gdb_expect 10 {
	    -re ".*102\\\^done\r\n$mi_gdb_prompt$" {
		verbose "redirect inferior output to new terminal device."
	    }
	    timeout {
	    	warning "Couldn't redirect inferior output." 2
	    }
    	}
    }

    mi_detect_async

    return 0
}

#
# Overridable function. You can override this function in your
# baseboard file.
# 
proc mi_gdb_start { args } {
  return [default_mi_gdb_start $args]
}

# Many of the tests depend on setting breakpoints at various places and
# running until that breakpoint is reached.  At times, we want to start
# with a clean-slate with respect to breakpoints, so this utility proc 
# lets us do this without duplicating this code everywhere.
#

proc mi_delete_breakpoints {} {
    global mi_gdb_prompt

# FIXME: The mi operation won't accept a prompt back and will use the 'all' arg
    send_gdb "102-break-delete\n"
    gdb_expect 30 {
	 -re "Delete all breakpoints.*y or n.*$" {
	    send_gdb "y\n"
	    exp_continue
         }
	 -re "102-break-delete\r\n102\\\^done\r\n$mi_gdb_prompt$" {
            # This happens if there were no breakpoints
	 }
	 timeout { perror "Delete all breakpoints in mi_delete_breakpoints (timeout)" ; return }
    }

# The correct output is not "No breakpoints or watchpoints." but an
# empty BreakpointTable. Also, a query is not acceptable with mi.
    send_gdb "103-break-list\n"
    gdb_expect 30 {
	 -re "103-break-list\r\n103\\\^done,BreakpointTable=\{\}\r\n$mi_gdb_prompt$" {}
	 -re "103-break-list\r\n103\\\^done,BreakpointTable=\{nr_rows=\".\",nr_cols=\".\",hdr=\\\[\{width=\".*\",alignment=\".*\",col_name=\"number\",colhdr=\"Num\"\}.*colhdr=\"Type\".*colhdr=\"Disp\".*colhdr=\"Enb\".*colhdr=\"Address\".*colhdr=\"What\".*\\\],body=\\\[\\\]\}\r\n$mi_gdb_prompt$" {}
	 -re "103-break-list\r\n103\\\^doneNo breakpoints or watchpoints.\r\n\r\n$mi_gdb_prompt$" {warning "Unexpected console text received"}
	 -re "$mi_gdb_prompt$" { perror "Breakpoints not deleted" ; return }
	 -re "Delete all breakpoints.*or n.*$" {
	    warning "Unexpected prompt for breakpoints deletion"
	    send_gdb "y\n"
	    exp_continue
	}
	 timeout { perror "-break-list (timeout)" ; return }
    }
}

proc mi_gdb_reinitialize_dir { subdir } {
    global mi_gdb_prompt
    global MIFLAGS

    global suppress_flag
    if { $suppress_flag } {
	return
    }

    if [is_remote host] {
	return ""
    }

    if { $MIFLAGS == "-i=mi1" } {
      send_gdb "104-environment-directory\n"
      gdb_expect 60 {
	-re ".*Reinitialize source path to empty.*y or n. " {
            warning "Got confirmation prompt for dir reinitialization."
	    send_gdb "y\n"
	    gdb_expect 60 {
		-re "$mi_gdb_prompt$" {}
                timeout {error "Dir reinitialization failed (timeout)"}
	    }
	}
	-re "$mi_gdb_prompt$" {}
        timeout {error "Dir reinitialization failed (timeout)"}
      }
    } else {
      send_gdb "104-environment-directory -r\n"
      gdb_expect 60 {
	-re "104\\\^done,source-path=.*\r\n$mi_gdb_prompt$" {}
	-re "$mi_gdb_prompt$" {}
        timeout {error "Dir reinitialization failed (timeout)"}
      }
    }

    send_gdb "105-environment-directory $subdir\n"
    gdb_expect 60 {
	-re "Source directories searched.*$mi_gdb_prompt$" {
	    verbose "Dir set to $subdir"
	}
	-re "105\\\^done.*\r\n$mi_gdb_prompt$" {
            # FIXME: We return just the prompt for now.
	    verbose "Dir set to $subdir"
	    # perror "Dir \"$subdir\" failed."
	}
    }
}

# Send GDB the "target" command.
# FIXME: Some of these patterns are not appropriate for MI.  Based on
# config/monitor.exp:gdb_target_command.
proc mi_gdb_target_cmd { targetname serialport } {
    global mi_gdb_prompt

    set serialport_re [string_to_regexp $serialport]
    for {set i 1} {$i <= 3} {incr i} {
	send_gdb "47-target-select $targetname $serialport\n"
	gdb_expect 60 {
	    -re "47\\^connected.*$mi_gdb_prompt" {
		verbose "Set target to $targetname"
		return 0
	    }
	    -re "unknown host.*$mi_gdb_prompt" {
	        verbose "Couldn't look up $serialport"
	    }
	    -re "Couldn't establish connection to remote.*$mi_gdb_prompt$" {
		verbose "Connection failed"
	    }
	    -re "Remote MIPS debugging.*$mi_gdb_prompt$" {
		verbose "Set target to $targetname"
		return 0
	    }
	    -re "Remote debugging using .*$serialport_re.*$mi_gdb_prompt$" {
		verbose "Set target to $targetname"
		return 0
	    }
	    -re "Remote target $targetname connected to.*$mi_gdb_prompt$" {
		verbose "Set target to $targetname"
		return 0
	    }
	    -re "Connected to.*$mi_gdb_prompt$" { 
		verbose "Set target to $targetname"
		return 0
	    }
	    -re "Ending remote.*$mi_gdb_prompt$" { }
	    -re "Connection refused.*$mi_gdb_prompt$" {
		verbose "Connection refused by remote target.  Pausing, and trying again."
		sleep 5
		continue
	    }
	    -re "Non-stop mode requested, but remote does not support non-stop.*$mi_gdb_prompt" {
		unsupported "Non-stop mode not supported"
		return 1
	    }
	    -re "Timeout reading from remote system.*$mi_gdb_prompt$" {
		verbose "Got timeout error from gdb."
	    }
	    timeout {
		send_gdb ""
		break
	    }
	}
    }
    return 1
}

#
# load a file into the debugger (file command only).
# return a -1 if anything goes wrong.
#
proc mi_gdb_file_cmd { arg } {
    global verbose
    global loadpath
    global loadfile
    global GDB
    global mi_gdb_prompt
    global last_loaded_file
    upvar timeout timeout

    set last_loaded_file $arg

    if [is_remote host] {
	set arg [remote_download host $arg]
	if { $arg == "" } {
	    error "download failed"
	    return -1
	}
    }

# FIXME: Several of these patterns are only acceptable for console
# output.  Queries are an error for mi.
    send_gdb "105-file-exec-and-symbols $arg\n"
    gdb_expect 120 {
        -re "Reading symbols from.*done.*$mi_gdb_prompt$" {
            verbose "\t\tLoaded $arg into the $GDB"
            return 0
        }
        -re "has no symbol-table.*$mi_gdb_prompt$" {
            perror "$arg wasn't compiled with \"-g\""
            return -1
        }
        -re "Load new symbol table from \".*\".*y or n. $" {
            send_gdb "y\n"
            gdb_expect 120 {
                -re "Reading symbols from.*done.*$mi_gdb_prompt$" {
                    verbose "\t\tLoaded $arg with new symbol table into $GDB"
                    # All OK
                }
                timeout {
                    perror "(timeout) Couldn't load $arg, other program already loaded."
                    return -1
                }
            }
	}
        -re "No such file or directory.*$mi_gdb_prompt$" {
            perror "($arg) No such file or directory\n"
            return -1
        }
        -re "105-file-exec-and-symbols .*\r\n105\\\^done\r\n$mi_gdb_prompt$" {
            # We (MI) are just giving the prompt back for now, instead of giving
	    # some acknowledgement.
	    return 0
	}
        timeout {
            perror "couldn't load $arg into $GDB (timed out)."
            return -1
        }
	eof {
            # This is an attempt to detect a core dump, but seems not to
            # work.  Perhaps we need to match .* followed by eof, in which
            # gdb_expect does not seem to have a way to do that.
            perror "couldn't load $arg into $GDB (end of file)."
            return -1
        }
    }
}

#
# connect to the target and download a file, if necessary.
# return a -1 if anything goes wrong.
#
proc mi_gdb_target_load { } {
    global verbose
    global loadpath
    global loadfile
    global GDB
    global mi_gdb_prompt

    if [target_info exists gdb_load_timeout] {
	set loadtimeout [target_info gdb_load_timeout]
    } else {
	set loadtimeout 1600
    }

    if { [info procs gdbserver_gdb_load] != "" } {
	mi_gdb_test "kill" ".*" ""
	set res [gdbserver_gdb_load]
	set protocol [lindex $res 0]
	set gdbport [lindex $res 1]

	if { [mi_gdb_target_cmd $protocol $gdbport] != 0 } {
	    return -1
	}
    } elseif { [info procs send_target_sid] != "" } {
	# For SID, things get complex
	send_gdb "kill\n"
	gdb_expect 10 {
	    -re ".*$mi_gdb_prompt$"
	}
	send_target_sid
	gdb_expect $loadtimeout {
	    -re "\\^done.*$mi_gdb_prompt$" {
	    }
	    timeout {
		perror "Unable to connect to SID target (timeout)"
		return -1
	    }
	}
	send_gdb "48-target-download\n"
	gdb_expect $loadtimeout {
	    -re "48\\^done.*$mi_gdb_prompt$" {
	    }
	    timeout {
		perror "Unable to download to SID target (timeout)"
		return -1
	    }
	}
    } elseif { [target_info protocol] == "sim" } {
	# For the simulator, just connect to it directly.
	send_gdb "47-target-select sim\n"
	gdb_expect $loadtimeout {
	    -re "47\\^connected.*$mi_gdb_prompt$" {
	    }
	    timeout {
		perror "Unable to select sim target (timeout)"
		return -1
	    }
	}
	send_gdb "48-target-download\n"
	gdb_expect $loadtimeout {
	    -re "48\\^done.*$mi_gdb_prompt$" {
	    }
	    timeout {
		perror "Unable to download to sim target (timeout)"
		return -1
	    }
	}
    } elseif { [target_info gdb_protocol] == "remote" } {
	# remote targets
	if { [mi_gdb_target_cmd "remote" [target_info netport]] != 0 } {
	    perror "Unable to connect to remote target"
	    return -1
	}
	send_gdb "48-target-download\n"
	gdb_expect $loadtimeout {
	    -re "48\\^done.*$mi_gdb_prompt$" {
	    }
	    timeout {
		perror "Unable to download to remote target (timeout)"
		return -1
	    }
	}
    }
    return 0
}

#
# load a file into the debugger.
# return a -1 if anything goes wrong.
#
proc mi_gdb_load { arg } {
    if { $arg != "" } {
	return [mi_gdb_file_cmd $arg]
    }
    return 0
}

# mi_gdb_test COMMAND PATTERN MESSAGE [IPATTERN] -- send a command to gdb; 
#   test the result.
#
# COMMAND is the command to execute, send to GDB with send_gdb.  If
#   this is the null string no command is sent.
# PATTERN is the pattern to match for a PASS, and must NOT include
#   the \r\n sequence immediately before the gdb prompt.
# MESSAGE is the message to be printed.  (If this is the empty string, 
#   then sometimes we don't call pass or fail at all; I don't 
#   understand this at all.)
# IPATTERN is the pattern to match for the inferior's output.  This parameter
#   is optional.  If present, it will produce a PASS if the match is 
#   successful, and a FAIL if unsuccessful.
#
# Returns:
#    1 if the test failed,
#    0 if the test passes,
#   -1 if there was an internal error.
#  
proc mi_gdb_test { args } {
    global verbose
    global mi_gdb_prompt
    global GDB expect_out
    global inferior_exited_re async
    upvar timeout timeout

    set command [lindex $args 0]
    set pattern [lindex $args 1]
    set message [lindex $args 2]

    if [llength $args]==4 {
	set ipattern [lindex $args 3]
    }

    if [llength $args]==5 {
	set question_string [lindex $args 3]
	set response_string [lindex $args 4]
    } else {
	set question_string "^FOOBAR$"
    }

    if $verbose>2 then {
	send_user "Sending \"$command\" to gdb\n"
	send_user "Looking to match \"$pattern\"\n"
	send_user "Message is \"$message\"\n"
    }

    set result -1
    set string "${command}\n"
    set string_regex [string_to_regexp $command]

    if { $command != "" } {
	while { "$string" != "" } {
	    set foo [string first "\n" "$string"]
	    set len [string length "$string"]
	    if { $foo < [expr $len - 1] } {
		set str [string range "$string" 0 $foo]
		if { [send_gdb "$str"] != "" } {
		    global suppress_flag

		    if { ! $suppress_flag } {
			perror "Couldn't send $command to GDB."
		    }
		    fail "$message"
		    return $result
		}
		gdb_expect 2 {
		    -re "\[\r\n\]" { }
		    timeout { }
		}
		set string [string range "$string" [expr $foo + 1] end]
	    } else {
		break
	    }
	}
	if { "$string" != "" } {
	    if { [send_gdb "$string"] != "" } {
		global suppress_flag

		if { ! $suppress_flag } {
		    perror "Couldn't send $command to GDB."
		}
		fail "$message"
		return $result
	    }
	}
    }

    if [info exists timeout] {
	set tmt $timeout
    } else {
	global timeout
	if [info exists timeout] {
	    set tmt $timeout
	} else {
	    set tmt 60
	}
    }
    if {$async} {
	# With $prompt_re "" there may come arbitrary asynchronous response
	# from the previous command, before or after $string_regex.
	set string_regex ".*"
    }
    verbose -log "Expecting: ^($string_regex\[\r\n\]+)?($pattern\[\r\n\]+$mi_gdb_prompt\[ \]*)"
    gdb_expect $tmt {
	 -re "\\*\\*\\* DOSEXIT code.*" {
	     if { $message != "" } {
		 fail "$message"
	     }
	     gdb_suppress_entire_file "GDB died"
	     return -1
	 }
	 -re "Ending remote debugging.*$mi_gdb_prompt\[ \]*$" {
	    if ![isnative] then {
		warning "Can`t communicate to remote target."
	    }
	    gdb_exit
	    gdb_start
	    set result -1
	}
	 -re "^($string_regex\[\r\n\]+)?($pattern\[\r\n\]+$mi_gdb_prompt\[ \]*)" {
	    # At this point, $expect_out(1,string) is the MI input command.
	    # and $expect_out(2,string) is the MI output command.
	    # If $expect_out(1,string) is "", then there was no MI input command here.

	    # NOTE, there is no trailing anchor because with GDB/MI, 
	    # asynchronous responses can happen at any point, causing more 
	    # data to be available.  Normally an anchor is used to make 
	    # sure the end of the output is matched, however, $mi_gdb_prompt 
	    # is just as good of an anchor since mi_gdb_test is meant to 
	    # match a single mi output command.  If a second GDB/MI output 
	    # response is sent, it will be in the buffer for the next 
	    # time mi_gdb_test is called.
	    if ![string match "" $message] then {
		pass "$message"
	    }
	    set result 0
	}
	 -re "(${question_string})$" {
	    send_gdb "$response_string\n"
	    exp_continue
	}
	 -re "Undefined.* command:.*$mi_gdb_prompt\[ \]*$" {
	    perror "Undefined command \"$command\"."
            fail "$message"
	    set result 1
	}
	 -re "Ambiguous command.*$mi_gdb_prompt\[ \]*$" {
	    perror "\"$command\" is not a unique command name."
            fail "$message"
	    set result 1
	}
	 -re "$inferior_exited_re with code \[0-9\]+.*$mi_gdb_prompt\[ \]*$" {
	    if ![string match "" $message] then {
		set errmsg "$message (the program exited)"
	    } else {
		set errmsg "$command (the program exited)"
	    }
	    fail "$errmsg"
	    return -1
	}
	 -re "The program is not being run.*$mi_gdb_prompt\[ \]*$" {
	    if ![string match "" $message] then {
		set errmsg "$message (the program is no longer running)"
	    } else {
		set errmsg "$command (the program is no longer running)"
	    }
	    fail "$errmsg"
	    return -1
	}
	 -re ".*$mi_gdb_prompt\[ \]*$" {
	    if ![string match "" $message] then {
		fail "$message"
	    }
	    set result 1
	}
	 "<return>" {
	    send_gdb "\n"
	    perror "Window too small."
            fail "$message"
	}
	 -re "\\(y or n\\) " {
	    send_gdb "n\n"
	    perror "Got interactive prompt."
            fail "$message"
	}
	 eof {
	     perror "Process no longer exists"
	     if { $message != "" } {
		 fail "$message"
	     }
	     return -1
	}
	 full_buffer {
	    perror "internal buffer is full."
            fail "$message"
	}
	timeout	{
	    if ![string match "" $message] then {
		fail "$message (timeout)"
	    }
	    set result 1
	}
    }

    # If the GDB output matched, compare the inferior output.
    if { $result == 0 } {
	if [ info exists ipattern ] {
	    if { ![target_info exists gdb,noinferiorio] } {
		global mi_inferior_spawn_id
		expect {
		    -i $mi_inferior_spawn_id -re "$ipattern" {
			pass "$message inferior output"
		    }
		    timeout {
			fail "$message inferior output (timeout)"
			set result 1
		    }
		}
	    } else {
		unsupported "$message inferior output"
	    }
        }
    }

    return $result
}

#
# MI run command.  (A modified version of gdb_run_cmd)
#

# In patterns, the newline sequence ``\r\n'' is matched explicitly as
# ``.*$'' could swallow up output that we attempt to match elsewhere.

proc mi_run_cmd_full {use_mi_command args} {
    global suppress_flag
    if { $suppress_flag } {
	return -1
    }
    global mi_gdb_prompt use_gdb_stub
    global thread_selected_re
    global library_loaded_re

    if {$use_mi_command} {
	set run_prefix "220-exec-"
	set run_match "220"
    } else {
	set run_prefix ""
	set run_match ""
    }

    if [target_info exists gdb_init_command] {
	send_gdb "[target_info gdb_init_command]\n"
	gdb_expect 30 {
	    -re "$mi_gdb_prompt$" { }
	    default {
		perror "gdb_init_command for target failed"
		return -1
	    }
	}
    }

    if { [mi_gdb_target_load] < 0 } {
	return -1
    }

    if $use_gdb_stub {
	if [target_info exists gdb,do_reload_on_run] {
	    send_gdb "${run_prefix}continue\n"
	    gdb_expect 60 {
		-re "${run_match}\\^running\[\r\n\]+\\*running,thread-id=\"\[^\"\]+\"\r\n$mi_gdb_prompt" {}
		default {}
	    }
	    return 0
	}

	if [target_info exists gdb,start_symbol] {
	    set start [target_info gdb,start_symbol]
	} else {
	    set start "start"
	}

	# HACK: Should either use 000-jump or fix the target code
	# to better handle RUN.
	send_gdb  "jump *$start\n"
	warning "Using CLI jump command, expect run-to-main FAIL"
	return 0
    }

    send_gdb "${run_prefix}run $args\n"
    gdb_expect {
	-re "${run_match}\\^running\r\n(\\*running,thread-id=\"\[^\"\]+\"\r\n|=thread-created,id=\"1\",group-id=\"\[0-9\]+\"\r\n)*(${library_loaded_re})*(${thread_selected_re})?${mi_gdb_prompt}" {
	}
	-re "\\^error,msg=\"The target does not support running in non-stop mode.\"" {
	    unsupported "Non-stop mode not supported"
	    return -1
	}
	timeout {
	    perror "Unable to start target"
	    return -1
	}
    }
    # NOTE: Shortly after this there will be a ``000*stopped,...(gdb)''

    return 0
}

# A wrapper for mi_run_cmd_full which uses -exec-run and
# -exec-continue, as appropriate.  ARGS are passed verbatim to
# mi_run_cmd_full.
proc mi_run_cmd {args} {
    return [eval mi_run_cmd_full 1 $args]
}

# A wrapper for mi_run_cmd_full which uses the CLI commands 'run' and
# 'continue', as appropriate.  ARGS are passed verbatim to
# mi_run_cmd_full.
proc mi_run_with_cli {args} {
    return [eval mi_run_cmd_full 0 $args]
}

#
# Just like run-to-main but works with the MI interface
#

proc mi_run_to_main { } {
    global suppress_flag
    if { $suppress_flag } {
	return -1
    }

    global srcdir
    global subdir
    global binfile
    global srcfile

    mi_delete_breakpoints
    mi_gdb_reinitialize_dir $srcdir/$subdir
    mi_gdb_load ${binfile}

    mi_runto main
}


# Just like gdb's "runto" proc, it will run the target to a given
# function.  The big difference here between mi_runto and mi_execute_to
# is that mi_execute_to must have the inferior running already.  This
# proc will (like gdb's runto) (re)start the inferior, too.
#
# FUNC is the linespec of the place to stop (it inserts a breakpoint here).
# It returns:
#   -1  if test suppressed, failed, timedout
#    0  if test passed

proc mi_runto_helper {func run_or_continue} {
  global suppress_flag
  if { $suppress_flag } {
    return -1
  }

  global mi_gdb_prompt expect_out
  global hex decimal fullname_syntax

  set test "mi runto $func"
  mi_gdb_test "200-break-insert -t $func" \
    "200\\^done,bkpt=\{number=\"\[0-9\]+\",type=\"breakpoint\",disp=\"del\",enabled=\"y\",addr=\"$hex\",func=\"$func\(\\\(.*\\\)\)?\",file=\".*\",line=\"\[0-9\]*\",thread-groups=\\\[\"i1\"\\\],times=\"0\",original-location=\".*\"\}" \
    "breakpoint at $func"

  if {![regexp {number="[0-9]+"} $expect_out(buffer) str]
      || ![scan $str {number="%d"} bkptno]} {
    set bkptno {[0-9]+}
  }

  if {$run_or_continue == "run"} {
      if { [mi_run_cmd] < 0 } {
	  return -1
      }
  } else {
      mi_send_resuming_command "exec-continue" "$test"
  }

  mi_expect_stop "breakpoint-hit" $func ".*" ".*" "\[0-9\]+" { "" "disp=\"del\"" } $test
}

proc mi_runto {func} {
    return [mi_runto_helper $func "run"]
}

# Next to the next statement
# For return values, see mi_execute_to_helper

proc mi_next { test } {
  return [mi_next_to {.*} {.*} {.*} {.*} $test]
}


# Step to the next statement
# For return values, see mi_execute_to_helper

proc mi_step { test } {
  return [mi_step_to {.*} {.*} {.*} {.*} $test]
}

set async "unknown"

proc mi_detect_async {} {
    global async
    global mi_gdb_prompt

    send_gdb "show target-async\n"
        
    gdb_expect {
        -re ".*Controlling the inferior in asynchronous mode is on...*$mi_gdb_prompt$" {
            set async 1
        }
        -re ".*$mi_gdb_prompt$" {
            set async 0
        }
        timeout {
            set async 0
        }
    }
    return $async
}

# Wait for MI *stopped notification to appear.
# The REASON, FUNC, ARGS, FILE and LINE are regular expressions
# to match against whatever is output in *stopped.  FILE may also match
# filename of a file without debug info.  ARGS should not include [] the
# list of argument is enclosed in, and other regular expressions should
# not include quotes.
# If EXTRA is a list of one element, it's the regular expression
# for output expected right after *stopped, and before GDB prompt.
# If EXTRA is a list of two elements, the first element is for
# output right after *stopped, and the second element is output
# right after reason field.  The regex after reason should not include
# the comma separating it from the following fields.
# 
# When we fail to match output at all, -1 is returned.  If FILE does
# match and the target system has no debug info for FILE return 0.
# Otherwise, the line at which we stop is returned.  This is useful when
# exact line is not possible to specify for some reason -- one can pass
# the .* or "\[0-9\]*" regexps for line, and then check the line
# programmatically.
#
# Do not pass .* for any argument if you are expecting more than one stop.
proc mi_expect_stop { reason func args file line extra test } {

    global mi_gdb_prompt
    global hex
    global decimal
    global fullname_syntax
    global async
    global thread_selected_re
    global breakpoint_re

    set after_stopped ""
    set after_reason ""
    if { [llength $extra] == 2 } {
        set after_stopped [lindex $extra 0]
        set after_reason [lindex $extra 1]
        set after_reason "${after_reason},"
    } elseif { [llength $extra] == 1 } {
        set after_stopped [lindex $extra 0]
    }

    if {$async} {
        set prompt_re ""
    } else {
        set prompt_re "$mi_gdb_prompt$"
    }

    if { $reason == "really-no-reason" } {
        gdb_expect {
          -re "\\*stopped\r\n$prompt_re" {
            pass "$test"
          }
          timeout {
              fail "$test (unknown output after running)"
          }
        }
        return
    }
    
    if { $reason == "exited-normally" } {

        gdb_expect {
          -re "\\*stopped,reason=\"exited-normally\"\r\n$prompt_re" {
            pass "$test"
          }
          -re ".*$mi_gdb_prompt$" {fail "continue to end (2)"}
          timeout {
              fail "$test (unknown output after running)"
          }
        }
        return
    }

    set args "\\\[$args\\\]"

    set bn ""
    if { $reason == "breakpoint-hit" } {
        set bn {bkptno="[0-9]+",}
    } elseif { $reason == "solib-event" } {
	set bn ".*"
    }

    set r ""
    if { $reason != "" } {
        set r "reason=\"$reason\","
    }


    set a $after_reason

    set any "\[^\n\]*"

    verbose -log "mi_expect_stop: expecting: \\*stopped,${r}${a}${bn}frame=\{addr=\"$hex\",func=\"$func\",args=$args,(?:file=\"$any$file\",fullname=\"${fullname_syntax}$file\",line=\"$line\"|from=\"$file\")\}$after_stopped,thread-id=\"$decimal\",stopped-threads=$any\r\n($thread_selected_re|$breakpoint_re)*$prompt_re"
    gdb_expect {
	-re "\\*stopped,${r}${a}${bn}frame=\{addr=\"$hex\",func=\"$func\",args=$args,(?:file=\"$any$file\",fullname=\"${fullname_syntax}$file\",line=\"($line)\"|from=\"$file\")\}$after_stopped,thread-id=\"$decimal\",stopped-threads=$any\r\n($thread_selected_re|$breakpoint_re)*$prompt_re" {
	    pass "$test"
	    if {[array names expect_out "2,string"] != ""} {
		return $expect_out(2,string)
	    }
	    # No debug info available but $file does match.
	    return 0
	}
	-re "\\*stopped,${r}${a}${bn}frame=\{addr=\"$hex\",func=\"$any\",args=\[\\\[\{\]$any\[\\\]\}\],file=\"$any\",fullname=\"${fullname_syntax}$any\",line=\"\[0-9\]*\"\}$after_stopped,thread-id=\"$decimal\",stopped-threads=$any\r\n($thread_selected_re|$breakpoint_re)*$prompt_re" {
            verbose -log "got $expect_out(buffer)"
	    fail "$test (stopped at wrong place)"
	    return -1
	}
	-re ".*\r\n$mi_gdb_prompt$" {
            verbose -log "got $expect_out(buffer)"
	    fail "$test (unknown output after running)"
	    return -1
	}
	timeout {
	    fail "$test (timeout)"
	    return -1
	}
    }    
}

# Wait for MI *stopped notification related to an interrupt request to
# appear.
proc mi_expect_interrupt { test } {
    global mi_gdb_prompt
    global decimal
    global async

    if {$async} {
	set prompt_re ""
    } else {
	set prompt_re "$mi_gdb_prompt$"
    }

    set r "reason=\"signal-received\",signal-name=\"0\",signal-meaning=\"Signal 0\""

    set any "\[^\n\]*"

    # A signal can land anywhere, just ignore the location
    verbose -log "mi_expect_interrupt: expecting: \\*stopped,${r}$any\r\n$prompt_re"
    gdb_expect {
	-re "\\*stopped,${r}$any\r\n$prompt_re" {
	    pass "$test"
	    return 0
	}
	-re ".*\r\n$mi_gdb_prompt$" {
	    verbose -log "got $expect_out(buffer)"
	    fail "$test (unknown output after running)"
	    return -1
	}
	timeout {
	    fail "$test (timeout)"
	    return -1
	}
    }
}

# cmd should not include the number or newline (i.e. "exec-step 3", not
# "220-exec-step 3\n"

# Can not match -re ".*\r\n${mi_gdb_prompt}", because of false positives
# after the first prompt is printed.

proc mi_execute_to { cmd reason func args file line extra test } {
    global suppress_flag
    if { $suppress_flag } {
	return -1
    }

    mi_send_resuming_command "$cmd" "$test"
    set r [mi_expect_stop $reason $func $args $file $line $extra $test]
    return $r
}

proc mi_next_to { func args file line test } {
    mi_execute_to "exec-next" "end-stepping-range" "$func" "$args" \
	"$file" "$line" "" "$test"
}

proc mi_step_to { func args file line test } {
    mi_execute_to "exec-step" "end-stepping-range" "$func" "$args" \
	"$file" "$line" "" "$test"
}

proc mi_finish_to { func args file line result ret test } {
    mi_execute_to "exec-finish" "function-finished" "$func" "$args" \
	"$file" "$line" \
	",gdb-result-var=\"$result\",return-value=\"$ret\"" \
	"$test"
}

proc mi_continue_to {func} {
    mi_runto_helper $func "continue"
}

proc mi0_execute_to { cmd reason func args file line extra test } {
    mi_execute_to_helper "$cmd" "$reason" "$func" "\{$args\}" \
	"$file" "$line" "$extra" "$test"
}

proc mi0_next_to { func args file line test } {
    mi0_execute_to "exec-next" "end-stepping-range" "$func" "$args" \
	"$file" "$line" "" "$test"
}

proc mi0_step_to { func args file line test } {
    mi0_execute_to "exec-step" "end-stepping-range" "$func" "$args" \
	"$file" "$line" "" "$test"
}

proc mi0_finish_to { func args file line result ret test } {
    mi0_execute_to "exec-finish" "function-finished" "$func" "$args" \
	"$file" "$line" \
	",gdb-result-var=\"$result\",return-value=\"$ret\"" \
	"$test"
}

proc mi0_continue_to { bkptno func args file line test } {
    mi0_execute_to "exec-continue" "breakpoint-hit\",bkptno=\"$bkptno" \
	"$func" "$args" "$file" "$line" "" "$test"
}

# Creates a breakpoint and checks the reported fields are as expected
proc mi_create_breakpoint { location number disp func file line address test } {
    verbose -log "Expecting: 222\\^done,bkpt=\{number=\"$number\",type=\"breakpoint\",disp=\"$disp\",enabled=\"y\",addr=\"$address\",func=\"$func\",file=\"$file\",fullname=\".*\",line=\"$line\",thread-groups=\\\[\".*\"\\\],times=\"0\",original-location=\".*\"\}"
    mi_gdb_test "222-break-insert $location" \
        "222\\^done,bkpt=\{number=\"$number\",type=\"breakpoint\",disp=\"$disp\",enabled=\"y\",addr=\"$address\",func=\"$func\",file=\"$file\",fullname=\".*\",line=\"$line\",thread-groups=\\\[\".*\"\\\],times=\"0\",original-location=\".*\"\}" \
        $test
}

proc mi_list_breakpoints { expected test } {
    set fullname ".*"

    set body ""
    set first 1

    foreach item $expected {
        if {$first == 0} {
            set body "$body,"
            set first 0
        }
        set number [lindex $item 0]
        set disp [lindex $item 1]
        set func [lindex $item 2]
        set file [lindex $item 3]
        set line [lindex $item 4]
        set address [lindex $item 5]
        set body "${body}bkpt=\{number=\"$number\",type=\"breakpoint\",disp=\"$disp\",enabled=\"y\",addr=\"$address\",func=\"$func\",file=\".*$file\",${fullname},line=\"$line\",thread-groups=\\\[\"i1\"\\\],times=\"0\",original-location=\".*\"\}"
        set first 0
    }

    verbose -log "Expecting: 666\\\^done,BreakpointTable=\{nr_rows=\".\",nr_cols=\".\",hdr=\\\[\{width=\".*\",alignment=\".*\",col_name=\"number\",colhdr=\"Num\"\}.*colhdr=\"Type\".*colhdr=\"Disp\".*colhdr=\"Enb\".*colhdr=\"Address\".*colhdr=\"What\".*\\\],body=\\\[$body\\\]\}"
    mi_gdb_test "666-break-list" \
        "666\\\^done,BreakpointTable=\{nr_rows=\".\",nr_cols=\".\",hdr=\\\[\{width=\".*\",alignment=\".*\",col_name=\"number\",colhdr=\"Num\"\}.*colhdr=\"Type\".*colhdr=\"Disp\".*colhdr=\"Enb\".*colhdr=\"Address\".*colhdr=\"What\".*\\\],body=\\\[$body\\\]\}" \
        $test
}

# Creates varobj named NAME for EXPRESSION.
# Name cannot be "-".
proc mi_create_varobj { name expression testname } {
    mi_gdb_test "-var-create $name * $expression" \
        "\\^done,name=\"$name\",numchild=\"\[0-9\]+\",value=\".*\",type=.*,has_more=\"0\"" \
        $testname
}

proc mi_create_floating_varobj { name expression testname } {
    mi_gdb_test "-var-create $name @@ $expression" \
        "\\^done,name=\"$name\",numchild=\"\(-1\|\[0-9\]+\)\",value=\".*\",type=.*" \
        $testname
}


# Same as mi_create_varobj, but also checks the reported type
# of the varobj.
proc mi_create_varobj_checked { name expression type testname } {
    mi_gdb_test "-var-create $name * $expression" \
        "\\^done,name=\"$name\",numchild=\"\[0-9\]+\",value=\".*\",type=\"$type\".*" \
        $testname
}

# Same as mi_create_floating_varobj, but assumes the test is creating
# a dynamic varobj that has children, so the value must be "{...}".
proc mi_create_dynamic_varobj {name expression testname} {
    mi_gdb_test "-var-create $name @@ $expression" \
        "\\^done,name=\"$name\",numchild=\"\(-1\|\[0-9\]+\)\",value=\"{\\.\\.\\.}\",type=.*" \
        $testname
}

# Deletes the specified NAME. 
proc mi_delete_varobj { name testname } {
    mi_gdb_test "-var-delete $name" \
        "\\^done,ndeleted=.*" \
        $testname
}

# Updates varobj named NAME and checks that all varobjs in EXPECTED
# are reported as updated, and no other varobj is updated.
# Assumes that no varobj is out of scope and that no varobj changes
# types.
proc mi_varobj_update { name expected testname } {
    set er "\\^done,changelist=\\\["
    set first 1
    foreach item $expected {
        set v "{name=\"$item\",in_scope=\"true\",type_changed=\"false\",has_more=\".\"}"
        if {$first == 1} {
            set er "$er$v"
            set first 0
        } else {
            set er "$er,$v"
        }
    }
    set er "$er\\\]"

    verbose -log "Expecting: $er" 2
    mi_gdb_test "-var-update $name" $er $testname
}

proc mi_varobj_update_with_child_type_change { name child_name new_type new_children testname } {
    set v "{name=\"$child_name\",in_scope=\"true\",type_changed=\"true\",new_type=\"$new_type\",new_num_children=\"$new_children\",has_more=\".\"}"
    set er "\\^done,changelist=\\\[$v\\\]"
    verbose -log "Expecting: $er"
    mi_gdb_test "-var-update $name" $er $testname
}

proc mi_varobj_update_with_type_change { name new_type new_children testname } {
    mi_varobj_update_with_child_type_change $name $name $new_type $new_children $testname
}

# A helper that turns a key/value list into a regular expression
# matching some MI output.
proc mi_varobj_update_kv_helper {list} {
    set first 1
    set rx ""
    foreach {key value} $list {
	if {!$first} {
	    append rx ,
	}
	set first 0
	if {$key == "new_children"} {
	    append rx "$key=\\\[$value\\\]"
	} else {
	    append rx "$key=\"$value\""
	}
    }
    return $rx
}

# A helper for mi_varobj_update_dynamic that computes a match
# expression given a child list.
proc mi_varobj_update_dynamic_helper {children} {
    set crx ""

    set first 1
    foreach child $children {
	if {!$first} {
	    append crx ,
	}
	set first 0
	append crx "{"
	append crx [mi_varobj_update_kv_helper $child]
	append crx "}"
    }

    return $crx
}

# Update a dynamic varobj named NAME.  CHILDREN is a list of children
# that have been updated; NEW_CHILDREN is a list of children that were
# added to the primary varobj.  Each child is a list of key/value
# pairs that are expected.  SELF is a key/value list holding
# information about the varobj itself.  TESTNAME is the name of the
# test.
proc mi_varobj_update_dynamic {name testname self children new_children} {
    if {[llength $new_children]} {
	set newrx [mi_varobj_update_dynamic_helper $new_children]
	lappend self new_children $newrx
    }
    set selfrx [mi_varobj_update_kv_helper $self]
    set crx [mi_varobj_update_dynamic_helper $children]

    set er "\\^done,changelist=\\\[\{name=\"$name\",in_scope=\"true\""
    append er ",$selfrx\}"
    if {"$crx" != ""} {
	append er ",$crx"
    }
    append er "\\\]"

    verbose -log "Expecting: $er"
    mi_gdb_test "-var-update $name" $er $testname
}

proc mi_check_varobj_value { name value testname } {

    mi_gdb_test "-var-evaluate-expression $name" \
	"\\^done,value=\"$value\"" \
	$testname
}

# Helper proc which constructs a child regexp for
# mi_list_varobj_children and mi_varobj_update_dynamic.
proc mi_child_regexp {children add_child} {
    set children_exp {}
    set whatever "\"\[^\"\]+\""

    if {$add_child} {
	set pre "child="
    } else {
	set pre ""
    }

    foreach item $children {

        set name [lindex $item 0]
        set exp [lindex $item  1]
        set numchild [lindex $item 2]
        if {[llength $item] == 5} {
            set type [lindex $item 3]
            set value [lindex $item 4]

            lappend children_exp\
                "$pre{name=\"$name\",exp=\"$exp\",numchild=\"$numchild\",value=\"$value\",type=\"$type\"\(,thread-id=\"\[0-9\]+\")?}"
        } elseif {[llength $item] == 4} {
            set type [lindex $item 3]

            lappend children_exp\
                "$pre{name=\"$name\",exp=\"$exp\",numchild=\"$numchild\",type=\"$type\"\(,thread-id=\"\[0-9\]+\")?}"
        } else {
            lappend children_exp\
                "$pre{name=\"$name\",exp=\"$exp\",numchild=\"$numchild\"(,thread-id=\"\[0-9\]+\")?}"
        }
    }
    return [join $children_exp ","]
}

# Check the results of the:
#
#   -var-list-children VARNAME
#
# command.  The CHILDREN parement should be a list of lists.
# Each inner list can have either 3 or 4 elements, describing
# fields that gdb is expected to report for child variable object,
# in the following order
#
#   - Name
#   - Expression
#   - Number of children
#   - Type
#
# If inner list has 3 elements, the gdb is expected to output no
# type for a child and no value.
#
# If the inner list has 4 elements, gdb output is expected to
# have no value.
#
proc mi_list_varobj_children { varname children testname } {
    mi_list_varobj_children_range $varname "" "" [llength $children] $children \
      $testname
}

# Like mi_list_varobj_children, but sets a subrange.  NUMCHILDREN is
# the total number of children.
proc mi_list_varobj_children_range {varname from to numchildren children testname} {
    set options ""
    if {[llength $varname] == 2} {
        set options [lindex $varname 1]
        set varname [lindex $varname 0]
    }

    set whatever "\"\[^\"\]+\""

    set children_exp_j [mi_child_regexp $children 1]
    if {$numchildren} {
        set expected "\\^done,numchild=\".*\",children=\\\[$children_exp_j.*\\\]"
    } {
        set expected "\\^done,numchild=\"0\""
    }

    if {"$to" == ""} {
        append expected ",has_more=\"0\""
    } elseif {$to >= 0 && $numchildren > $to} {
        append expected ",has_more=\"1\""
    } else {
        append expected ",has_more=\"0\""
    }

    verbose -log "Expecting: $expected"

    mi_gdb_test "-var-list-children $options $varname $from $to" \
      $expected $testname
}

# Verifies that variable object VARNAME has NUMBER children,
# where each one is named $VARNAME.<index-of-child> and has type TYPE.
proc mi_list_array_varobj_children { varname number type testname } {
    set t {}
    for {set i 0} {$i < $number} {incr i} {
        lappend t [list $varname.$i $i 0 $type]
    }
    mi_list_varobj_children $varname $t $testname
}

# A list of two-element lists.  First element of each list is
# a Tcl statement, and the second element is the line
# number of source C file where the statement originates.
set mi_autotest_data ""
# The name of the source file for autotesting.
set mi_autotest_source ""

proc count_newlines { string } {
    return [regexp -all "\n" $string]
}

# Prepares for running inline tests in FILENAME.
# See comments for mi_run_inline_test for detailed
# explanation of the idea and syntax.
proc mi_prepare_inline_tests { filename } {

    global srcdir
    global subdir
    global mi_autotest_source
    global mi_autotest_data

    set mi_autotest_data {}

    set mi_autotest_source $filename
    
    if { ! [regexp "^/" "$filename"] } then {
	set filename "$srcdir/$subdir/$filename"
    }

    set chan [open $filename]
    set content [read $chan]
    set line_number 1
    while {1} {
        set start [string first "/*:" $content]
        if {$start != -1} {
            set end [string first ":*/" $content]
            if {$end == -1} {
                error "Unterminated special comment in $filename"
            }
            
            set prefix [string range $content 0 $start]
            set prefix_newlines [count_newlines $prefix]
            
            set line_number [expr $line_number+$prefix_newlines]
            set comment_line $line_number

            set comment [string range $content [expr $start+3] [expr $end-1]]

            set comment_newlines [count_newlines $comment]
            set line_number [expr $line_number+$comment_newlines]
            
            set comment [string trim $comment]
            set content [string range $content [expr $end+3] \
                             [string length $content]]
            lappend mi_autotest_data [list $comment $comment_line]
        } else {        
           break
        }        
    }
    close $chan
}

# Helper to mi_run_inline_test below.
# Return the list of all (statement,line_number) lists
# that comprise TESTCASE.  The begin and end markers
# are not included.
proc mi_get_inline_test {testcase} {

    global mi_gdb_prompt
    global mi_autotest_data
    global mi_autotest_source

    set result {}

    set seen_begin 0
    set seen_end 0
    foreach l $mi_autotest_data {

        set comment [lindex $l 0]

        if {$comment == "BEGIN: $testcase"} {
            set seen_begin 1
        } elseif {$comment == "END: $testcase"} {
            set seen_end 1
            break
        } elseif {$seen_begin==1} {
            lappend result $l
        }
    }

    if {$seen_begin == 0} {
        error "Autotest $testcase not found" 
    }

    if {$seen_begin == 1 && $seen_end == 0} {
        error "Missing end marker for test $testcase"
    }

    return $result
}

# Sets temporary breakpoint at LOCATION.
proc mi_tbreak {location} {

    global mi_gdb_prompt

    mi_gdb_test "-break-insert -t $location" \
        {\^done,bkpt=.*} \
        "run to $location (set breakpoint)"    
}

# Send COMMAND that must be a command that resumes
# the inferior (run/continue/next/etc) and consumes
# the "^running" output from it.
proc mi_send_resuming_command_raw {command test} {

    global mi_gdb_prompt
    global thread_selected_re
    global library_loaded_re

    send_gdb "$command\n"
    gdb_expect {
        -re "\\^running\r\n\\*running,thread-id=\"\[^\"\]+\"\r\n($library_loaded_re)*($thread_selected_re)?${mi_gdb_prompt}" {
            # Note that lack of 'pass' call here -- this works around limitation
            # in DejaGNU xfail mechanism. mi-until.exp has this:
            #
            #     setup_kfail gdb/2104 "*-*-*"
            #     mi_execute_to ...
            # 
            # and mi_execute_to uses mi_send_resuming_command.  If we use 'pass' here,
            # it will reset kfail, so when the actual test fails, it will be flagged
            # as real failure.
	    return 0
        }
        -re "\\^error,msg=\"Displaced stepping is only supported in ARM mode\".*" {
            unsupported "$test (Thumb mode)"
            return -1
        }
        -re "\\^error,msg=.*" {
            fail "$test (MI error)"
            return -1
        }
        -re ".*${mi_gdb_prompt}" {
            fail "$test (failed to resume)"
	    return -1
        }
        timeout {
	    fail "$test"
	    return -1
        }
    }
}

proc mi_send_resuming_command {command test} {
    mi_send_resuming_command_raw -$command $test
}

# Helper to mi_run_inline_test below.
# Sets a temporary breakpoint at LOCATION and runs
# the program using COMMAND.  When the program is stopped
# returns the line at which it.  Returns -1 if line cannot
# be determined.
# Does not check that the line is the same as requested.
# The caller can check itself if required.
proc mi_continue_to_line {location test} {

    mi_tbreak $location   
    mi_send_resuming_command "exec-continue" "run to $location (exec-continue)"
    return [mi_get_stop_line $test]
}

# Wait until gdb prints the current line.
proc mi_get_stop_line {test} {

  global mi_gdb_prompt
  global async

  if {$async} {
      set prompt_re ""
  } else {
      set prompt_re "$mi_gdb_prompt$"
  }

  gdb_expect {
      -re ".*line=\"(\[0-9\]*)\".*\r\n$prompt_re" {
          return $expect_out(1,string)
      }
      -re ".*$mi_gdb_prompt" {
          fail "wait for stop ($test)"
      }
      timeout {
          fail "wait for stop ($test)"
      }
  }
}

# Run a MI test embedded in comments in a C file.
# The C file should contain special comments in the following
# three forms:
#
#    /*: BEGIN: testname :*/
#    /*:  <Tcl statements> :*/
#    /*: END: testname :*/
#
# This procedure find the begin and end marker for the requested
# test. Then, a temporary breakpoint is set at the begin
# marker and the program is run (from start).
#
# After that, for each special comment between the begin and end
# marker, the Tcl statements are executed.  It is assumed that
# for each comment, the immediately preceding line is executable
# C statement.  Then, gdb will be single-stepped until that
# preceding C statement is executed, and after that the
# Tcl statements in the comment will be executed.
#
# For example:
#
#     /*: BEGIN: assignment-test :*/
#     v = 10;
#     /*: <Tcl code to check that 'v' is indeed 10 :*/
#     /*: END: assignment-test :*/
#
# The mi_prepare_inline_tests function should be called before
# calling this function.  A given C file can contain several
# inline tests.  The names of the tests must be unique within one
# C file.
#
proc mi_run_inline_test { testcase } {

    global mi_gdb_prompt
    global hex
    global decimal
    global fullname_syntax
    global mi_autotest_source

    set commands [mi_get_inline_test $testcase]

    set first 1
    set line_now 1

    foreach c $commands {
        set statements [lindex $c 0]
        set line [lindex $c 1]
        set line [expr $line-1]

        # We want gdb to be stopped at the expression immediately
        # before the comment.  If this is the first comment, the
        # program is either not started yet or is in some random place,
        # so we run it.  For further comments, we might be already
        # standing at the right line. If not continue till the
        # right line.

        if {$first==1} {
            # Start the program afresh.
            mi_tbreak "$mi_autotest_source:$line"
            mi_run_cmd
            set line_now [mi_get_stop_line "$testcase: step to $line"]
            set first 0
        } elseif {$line_now!=$line} {
            set line_now [mi_continue_to_line "$mi_autotest_source:$line" "continue to $line"]
        }

        if {$line_now!=$line} {
            fail "$testcase: go to line $line"
        }

        # We're not at the statement right above the comment.
        # Execute that statement so that the comment can test
        # the state after the statement is executed.

        # Single-step past the line.
        if { [mi_send_resuming_command "exec-next" "$testcase: step over $line"] != 0 } {
	    return -1
	}
	set line_now [mi_get_stop_line "$testcase: step over $line"]

        # We probably want to use 'uplevel' so that statements
        # have direct access to global variables that the
        # main 'exp' file has set up.  But it's not yet clear,
        # will need more experience to be sure.
        eval $statements
    }
}

proc get_mi_thread_list {name} {
  global expect_out

  # MI will return a list of thread ids:
  #
  # -thread-list-ids
  # ^done,thread-ids=[thread-id="1",thread-id="2",...],number-of-threads="N"
  # (gdb)
  mi_gdb_test "-thread-list-ids" \
    {.*\^done,thread-ids={(thread-id="[0-9]+"(,)?)+},current-thread-id="[0-9]+",number-of-threads="[0-9]+"} \
    "-thread_list_ids ($name)"

  set output {}
  if {[info exists expect_out(buffer)]} {
    set output $expect_out(buffer)
  }

  set thread_list {}
  if {![regexp {thread-ids=\{(thread-id="[0-9]+"(,)?)*\}} $output threads]} {
    fail "finding threads in MI output ($name)"
  } else {
    pass "finding threads in MI output ($name)"

    # Make list of console threads
    set start [expr {[string first \{ $threads] + 1}]
    set end   [expr {[string first \} $threads] - 1}]
    set threads [string range $threads $start $end]
    foreach thread [split $threads ,] {
      if {[scan $thread {thread-id="%d"} num]} {
	lappend thread_list $num
      }
    }
  }

  return $thread_list
}

# Check that MI and the console know of the same threads.
# Appends NAME to all test names.
proc check_mi_and_console_threads {name} {
  global expect_out

  mi_gdb_test "-thread-list-ids" \
    {.*\^done,thread-ids={(thread-id="[0-9]+"(,)*)+},current-thread-id="[0-9]+",number-of-threads="[0-9]+"} \
    "-thread-list-ids ($name)"
  set mi_output {}
  if {[info exists expect_out(buffer)]} {
    set mi_output $expect_out(buffer)
  }

  # GDB will return a list of thread ids and some more info:
  #
  # (gdb) 
  # -interpreter-exec console "info threads"
  # ~"  4 Thread 2051 (LWP 7734)  0x401166b1 in __libc_nanosleep () at __libc_nanosleep:-1"
  # ~"  3 Thread 1026 (LWP 7733)   () at __libc_nanosleep:-1"
  # ~"  2 Thread 2049 (LWP 7732)  0x401411f8 in __poll (fds=0x804bb24, nfds=1, timeout=2000) at ../sysdeps/unix/sysv/linux/poll.c:63"
  # ~"* 1 Thread 1024 (LWP 7731)  main (argc=1, argv=0xbfffdd94) at ../../../src/gdb/testsuite/gdb.mi/pthreads.c:160"
  # FIXME: kseitz/2002-09-05: Don't use the hack-cli method.
  mi_gdb_test "info threads" \
    {.*(~".*"[\r\n]*)+.*} \
    "info threads ($name)"
  set console_output {}
  if {[info exists expect_out(buffer)]} {
    set console_output $expect_out(buffer)
  }

  # Make a list of all known threads to console (gdb's thread IDs)
  set console_thread_list {}
  foreach line [split $console_output \n] {
    if {[string index $line 0] == "~"} {
      # This is a line from the console; trim off "~", " ", "*", and "\""
      set line [string trim $line ~\ \"\*]
      if {[scan $line "%d" id] == 1} {
	lappend console_thread_list $id
      }
    }
  }

  # Now find the result string from MI
  set mi_result ""
  foreach line [split $mi_output \n] {
    if {[string range $line 0 4] == "^done"} {
      set mi_result $line
    }
  }
  if {$mi_result == ""} {
    fail "finding MI result string ($name)"
  } else {
    pass "finding MI result string ($name)"
  }

  # Finally, extract the thread ids and compare them to the console
  set num_mi_threads_str ""
  if {![regexp {number-of-threads="[0-9]+"} $mi_result num_mi_threads_str]} {
    fail "finding number of threads in MI output ($name)"
  } else {
    pass "finding number of threads in MI output ($name)"

    # Extract the number of threads from the MI result
    if {![scan $num_mi_threads_str {number-of-threads="%d"} num_mi_threads]} {
      fail "got number of threads from MI ($name)"
    } else {
      pass "got number of threads from MI ($name)"

      # Check if MI and console have same number of threads
      if {$num_mi_threads != [llength $console_thread_list]} {
	fail "console and MI have same number of threads ($name)"
      } else {
	pass "console and MI have same number of threads ($name)"

	# Get MI thread list
	set mi_thread_list [get_mi_thread_list $name]

	# Check if MI and console have the same threads
	set fails 0
	foreach ct [lsort $console_thread_list] mt [lsort $mi_thread_list] {
	  if {$ct != $mt} {
	    incr fails
	  }
	}
	if {$fails > 0} {
	  fail "MI and console have same threads ($name)"

	  # Send a list of failures to the log
	  send_log "Console has thread ids: $console_thread_list\n"
	  send_log "MI has thread ids: $mi_thread_list\n"
	} else {
	  pass "MI and console have same threads ($name)"
	}
      }
    }
  }
}

# Download shared libraries to the target.
proc mi_load_shlibs { args } {
    if {![is_remote target]} {
	return
    }

    foreach file $args {
	gdb_download [shlib_target_file $file]
    }

    # Even if the target supplies full paths for shared libraries,
    # they may not be paths for this system.
    mi_gdb_test "set solib-search-path [file dirname [lindex $args 0]]" "\^done" ""
}

proc mi_reverse_list { list } {
    if { [llength $list] <= 1 } {
	return $list
    }
    set tail [lrange $list 1 [llength $list]]
    set rtail [mi_reverse_list $tail]
    lappend rtail [lindex $list 0]
    return $rtail
}

proc mi_check_thread_states { xstates test } {
    global expect_out
    set states [mi_reverse_list $xstates]
    set pattern ".*\\^done,threads=\\\["
    foreach s $states {
	set pattern "${pattern}(.*)state=\"$s\""
    }
    set pattern "${pattern}(,core=\"\[0-9\]*\")?\\\}\\\].*"

    verbose -log "expecting: $pattern"
    mi_gdb_test "-thread-info" $pattern $test
}

# Return a list of MI features supported by this gdb.
proc mi_get_features {} {
    global expect_out mi_gdb_prompt

    send_gdb "-list-features\n"

    gdb_expect {
	-re "\\^done,features=\\\[(.*)\\\]\r\n$mi_gdb_prompt$" {
	    regsub -all -- \" $expect_out(1,string) "" features
	    return [split $features ,]
	}
	-re ".*\r\n$mi_gdb_prompt$" {
	    verbose -log "got $expect_out(buffer)"
	    return ""
	}
	timeout {
	    verbose -log "timeout in mi_gdb_prompt"
	    return ""
	}
    }
}

# Variable Object Trees
#
# Yet another way to check varobjs. Pass mi_walk_varobj_tree a "list" of
# variables (not unlike the actual source code definition), and it will
# automagically test the children for you (by default).
#
# Example:
#
# source code:
# struct bar {
#   union {
#     int integer;
#     void *ptr;
#   };
#   const int *iPtr;
# };
#
# class foo {
# public:
#   int a;
#   struct {
#     int b;
#     struct bar *c;
#   };
# };
#
# foo *f = new foo (); <-- break here
#
# We want to check all the children of "f".
#
# Translate the above structures into the following tree:
#
# set tree {
#   foo f {
#     {} public {
#       int a {}
#       anonymous struct {
#         {} public {
#           int b {}
#           {bar *} c {
#             {} public {
#               anonymous union {
#                 {} public {
#                   int integer {}
#                   {void *} ptr {}
#                 }
#               }
#               {const int *} iPtr {
#                 {const int} {*iPtr} {}
#               }
#             }
#           }
#         }
#       }
#     }
#   }
# }
#
# mi_walk_varobj_tree c++ $tree
#
# If you'd prefer to walk the tree using your own callback,
# simply pass the name of the callback to mi_walk_varobj_tree.
#
# This callback should take one argument, the name of the variable
# to process.  This name is the name of a global array holding the
# variable's properties (object name, type, etc).
#
# An example callback:
#
# proc my_callback {var} {
#   upvar #0 $var varobj
#
#   puts "my_callback: called on varobj $varobj(obj_name)"
# }
#
# The arrays created for each variable object contain the following
# members:
#
# obj_name     - the object name for accessing this variable via MI
# display_name - the display name for this variable (exp="display_name" in
#                the output of -var-list-children)
# type         - the type of this variable (type="type" in the output
#                of -var-list-children, or the special tag "anonymous"
# path_expr    - the "-var-info-path-expression" for this variable
#                NOTE: This member cannot be used reliably with typedefs.
#                Use with caution!
#                See notes inside get_path_expr for more.
# parent       - the variable name of the parent varobj
# children     - a list of children variable names (which are the
#                names Tcl arrays, not object names)
#
# For each variable object, an array containing the above fields will
# be created under the root node (conveniently called, "root").  For example,
# a variable object with handle "OBJ.public.0_anonymous.a" will have
# a corresponding global Tcl variable named "root.OBJ.public.0_anonymous.a".
#
# Note that right now, this mechanism cannot be used for recursive data
# structures like linked lists.

namespace eval ::varobj_tree {
  # An index which is appended to root varobjs to ensure uniqueness.
  variable _root_idx 0

  # A procedure to help with debuggging varobj trees.
  # VARIABLE_NAME is the name of the variable to dump.
  # CMD, if present, is the name of the callback to output the contstructed
  #   strings. By default, it uses expect's "send_log" command.
  # TERM, if present, is a terminating character. By default it is the newline.
  #
  # To output to the terminal (not the expect log), use
  # mi_varobj_tree_dump_variable my_variable puts ""

  proc mi_varobj_tree_dump_variable {variable_name {cmd send_log} {term "\n"}} {
    upvar #0 $variable_name varobj

    eval "$cmd \"VAR = $variable_name$term\""

    # Explicitly encode the array indices, since outputting them
    # in some logical order is better than what "array names" might
    # return.
    foreach idx {obj_name parent display_name type path_expr} {
      eval "$cmd \"\t$idx = $varobj($idx)$term\""
    }

    # Output children
    set num [llength $varobj(children)]
    eval "$cmd \"\tnum_children = $num$term\""
    if {$num > 0} {
      eval "$cmd \"\tchildren = $varobj(children)$term\""
    }
  }

  # The default callback used by mi_walk_varobj_tree.  This callback
  # simply checks all of VAR's children.  It specifically does not test
  # path expressions, since that is very problematic.
  #
  # This procedure may be used in custom callbacks.
  proc test_children_callback {variable_name} {
    upvar #0 $variable_name varobj

    if {[llength $varobj(children)] > 0} {
      # Construct the list of children the way mi_list_varobj_children
      # expects to get it:
      # { {obj_name display_name num_children type} ... }
      set children_list {}
      foreach child $varobj(children) {
	upvar #0 $child c
	set clist [list [string_to_regexp $c(obj_name)] \
		       [string_to_regexp $c(display_name)] \
		       [llength $c(children)]]
	if {[string length $c(type)] > 0} {
	  lappend clist [string_to_regexp $c(type)]
	}
	lappend children_list $clist
      }

      mi_list_varobj_children $varobj(obj_name) $children_list \
	  "VT: list children of $varobj(obj_name)"
    }
  }

  # Set the properties of the varobj represented by
  # PARENT_VARIABLE - the name of the parent's variable
  # OBJNAME         - the MI object name of this variable
  # DISP_NAME       - the display name of this variable
  # TYPE            - the type of this variable
  # PATH            - the path expression for this variable
  # CHILDREN        - a list of the variable's children
  proc create_varobj {parent_variable objname disp_name \
			  type path children} {
    upvar #0 $parent_variable parent

    set var_name "root.$objname"
    global $var_name
    array set $var_name [list obj_name $objname]
    array set $var_name [list display_name $disp_name]
    array set $var_name [list type $type]
    array set $var_name [list path_expr $path]
    array set $var_name [list parent "$parent_variable"]
    array set $var_name [list children \
			     [get_tree_children $var_name $children]]
    return $var_name
  }

  # Should VARIABLE be used in path expressions?  The CPLUS_FAKE_CHILD
  # varobjs and anonymous structs/unions are not used for path expressions.
  proc is_path_expr_parent {variable} {
    upvar #0 $variable varobj

    # If the varobj's type is "", it is a CPLUS_FAKE_CHILD.
    # If the tail of the varobj's object name is "%d_anonymous",
    # then it represents an anonymous struct or union.
    if {[string length $varobj(type)] == 0 \
	    || [regexp {[0-9]+_anonymous$} $varobj(obj_name)]} {
      return false
    }

    return true
  }

  # Return the path expression for the variable named NAME in
  # parent varobj whose variable name is given by PARENT_VARIABLE.
  proc get_path_expr {parent_variable name type} {
    upvar #0 $parent_variable parent
    upvar #0 $parent_variable path_parent

    # If TYPE is "", this is one of the CPLUS_FAKE_CHILD varobjs,
    # which has no path expression.  Likewsise for anonymous structs
    # and unions.
    if {[string length $type] == 0 \
	    || [string compare $type "anonymous"] == 0} {
      return ""
    }

    # Find the path parent variable.
    while {![is_path_expr_parent $parent_variable]} {
      set parent_variable $path_parent(parent)
      upvar #0 $parent_variable path_parent
    }

    # This is where things get difficult.  We do not actually know
    # the real type for variables defined via typedefs, so we don't actually
    # know whether the parent is a structure/union or not.
    #
    # So we assume everything that isn't a simple type is a compound type.
    set stars ""
    regexp {\*+} $parent(type) stars
    set is_compound 1
    if {[string index $name 0] == "*"} {
      set is_compound 0
    }

    if {[string index $parent(type) end] == "\]"} {
      # Parent is an array.
      return "($path_parent(path_expr))\[$name\]"
    } elseif {$is_compound} {
      # Parent is a structure or union or a pointer to one.
      if {[string length $stars]} {
	set join "->"
      } else {
	set join "."
      }

      global root

      # To make matters even more hideous, varobj.c has slightly different
      # path expressions for C and C++.
      set path_expr "($path_parent(path_expr))$join$name"
      if {[string compare -nocase $root(language) "c"] == 0} {
	return $path_expr
      } else {
	return "($path_expr)"
      }
    } else {
      # Parent is a pointer.
      return "*($path_parent(path_expr))"
    }
  }

  # Process the CHILDREN (a list of varobj_tree elements) of the variable
  # given by PARENT_VARIABLE.  Returns a list of children variables.
  proc get_tree_children {parent_variable children} {
    upvar #0 $parent_variable parent

    set field_idx 0
    set children_list {}
    foreach {type name children} $children {
      if {[string compare $parent_variable "root"] == 0} {
	# Root variable
	variable _root_idx
	incr _root_idx
	set objname "$name$_root_idx"
	set disp_name "$name"
	set path_expr "$name"
      } elseif {[string compare $type "anonymous"] == 0} {
	# Special case: anonymous types.  In this case, NAME will either be
	# "struct" or "union".
	set objname "$parent(obj_name).${field_idx}_anonymous"
	set disp_name "<anonymous $name>"
	set path_expr ""
	set type "$name {...}"
      } else {
	set objname "$parent(obj_name).$name"
	set disp_name $name
	set path_expr [get_path_expr $parent_variable $name $type]
      }

      lappend children_list [create_varobj $parent_variable $objname \
				 $disp_name $type $path_expr $children]
      incr field_idx
    }

    return $children_list
  }

  # The main procedure to call the given CALLBACK on the elements of the
  # given varobj TREE.  See detailed explanation above.
  proc walk_tree {language tree callback} {
    global root
    variable _root_idx

    if {[llength $tree] < 3} {
      error "tree does not contain enough elements"
    }

    set _root_idx 0

    # Create root node and process the tree.
    array set root [list language $language]
    array set root [list obj_name "root"]
    array set root [list display_name "root"]
    array set root [list type "root"]
    array set root [list path_expr "root"]
    array set root [list parent "root"]
    array set root [list children [get_tree_children root $tree]]

    # Walk the tree
    set all_nodes $root(children); # a stack of nodes
    while {[llength $all_nodes] > 0} {
      # "Pop" the name of the global variable containing this varobj's
      # information from the stack of nodes.
      set var_name [lindex $all_nodes 0]
      set all_nodes [lreplace $all_nodes 0 0]

      # Bring the global named in VAR_NAME into scope as the local variable
      # VAROBJ.
      upvar #0 $var_name varobj

      # Append any children of VAROBJ to the list of nodes to walk.
      if {[llength $varobj(children)] > 0} {
	set all_nodes [concat $all_nodes $varobj(children)]
      }

      # If this is a root variable, create the variable object for it.
      if {[string compare $varobj(parent) "root"] == 0} {
	mi_create_varobj $varobj(obj_name) $varobj(display_name) \
	    "VT: create root varobj for $varobj(display_name)"
      }

      # Now call the callback for VAROBJ.
      uplevel #0 $callback $var_name
    }
  }
}

# The default varobj tree callback, which simply tests -var-list-children.
proc mi_varobj_tree_test_children_callback {variable} {
  ::varobj_tree::test_children_callback $variable
}

# Walk the variable object tree given by TREE, calling the specified
# CALLBACK.  By default this uses mi_varobj_tree_test_children_callback.
proc mi_walk_varobj_tree {language tree \
			      {callback \
				   mi_varobj_tree_test_children_callback}} {
  ::varobj_tree::walk_tree $language $tree $callback
}
@


1.118
log
@revert erroneous checkin to mi-support.exp
@
text
@d2262 1
d2268 2
@


1.117
log
@(clh 9)
@
text
@a2266 3
variable _root_idx
      set _root_idx 0

@


1.116
log
@Remove superfluous semicolons from testsuite throughout.

A few months ago semicolons after "return" were removed throughout the
testsuite.  However, as I pointed out in review, they're unnecessary
not just after "return", but pretty much after any tcl command.  ';'
is the command separator, and you only need it if there's another
command on the same line afterwards.

This patch was written by running:

 $ find . -name "*.exp" | xargs grep -l ";\s*$" | xargs sed -i 's/\([^#][^\s*;]*\)\s*;\s*$/\1/'

and then undoing changes to comments, and lib/future.exp.

Tested on x86_64 Fedora 17.

gdb/testsuite/
2013-06-07  Pedro Alves  <palves@@redhat.com>

	* boards/native-extended-gdbserver.exp: Remove semicolon.
	* config/arm-ice.exp: Likewise.
	* config/bfin.exp: Likewise.
	* config/cygmon.exp: Likewise.
	* config/h8300.exp: Likewise.
	* config/monitor.exp: Likewise.
	* config/sid.exp: Likewise.
	* config/sim.exp: Likewise.
	* config/slite.exp: Likewise.
	* config/vx.exp: Likewise.
	* gdb.arch/i386-bp_permanent.exp: Likewise.
	* gdb.asm/asm-source.exp: Likewise.
	* gdb.base/args.exp: Likewise.
	* gdb.base/attach-pie-misread.exp: Likewise.
	* gdb.base/auxv.exp: Likewise.
	* gdb.base/bigcore.exp: Likewise.
	* gdb.base/bitfields2.exp: Likewise.
	* gdb.base/bitfields.exp: Likewise.
	* gdb.base/break.exp: Likewise.
	* gdb.base/break-interp.exp: Likewise.
	* gdb.base/callfuncs.exp: Likewise.
	* gdb.base/call-sc.exp: Likewise.
	* gdb.base/commands.exp: Likewise.
	* gdb.base/corefile.exp: Likewise.
	* gdb.base/dbx.exp: Likewise.
	* gdb.base/ending-run.exp: Likewise.
	* gdb.base/exprs.exp: Likewise.
	* gdb.base/funcargs.exp: Likewise.
	* gdb.base/hbreak2.exp: Likewise.
	* gdb.base/huge.exp: Likewise.
	* gdb.base/list.exp: Likewise.
	* gdb.base/memattr.exp: Likewise.
	* gdb.base/overlays.exp: Likewise.
	* gdb.base/printcmds.exp: Likewise.
	* gdb.base/recurse.exp: Likewise.
	* gdb.base/remotetimeout.exp: Likewise.
	* gdb.base/reread.exp: Likewise.
	* gdb.base/savedregs.exp: Likewise.
	* gdb.base/scope.exp: Likewise.
	* gdb.base/sepdebug.exp: Likewise.
	* gdb.base/setshow.exp: Likewise.
	* gdb.base/setvar.exp: Likewise.
	* gdb.base/sigaltstack.exp: Likewise.
	* gdb.base/siginfo-addr.exp: Likewise.
	* gdb.base/siginfo.exp: Likewise.
	* gdb.base/siginfo-obj.exp: Likewise.
	* gdb.base/sigrepeat.exp: Likewise.
	* gdb.base/sigstep.exp: Likewise.
	* gdb.base/structs.exp: Likewise.
	* gdb.base/testenv.exp: Likewise.
	* gdb.base/twice.exp: Likewise.
	* gdb.base/valgrind-db-attach.exp: Likewise.
	* gdb.base/valgrind-infcall.exp: Likewise.
	* gdb.base/varargs.exp: Likewise.
	* gdb.base/watchpoint.exp: Likewise.
	* gdb.cp/gdb1355.exp: Likewise.
	* gdb.cp/misc.exp: Likewise.
	* gdb.disasm/hppa.exp: Likewise.
	* gdb.disasm/t01_mov.exp: Likewise.
	* gdb.disasm/t02_mova.exp: Likewise.
	* gdb.disasm/t03_add.exp: Likewise.
	* gdb.disasm/t04_sub.exp: Likewise.
	* gdb.disasm/t05_cmp.exp: Likewise.
	* gdb.disasm/t06_ari2.exp: Likewise.
	* gdb.disasm/t07_ari3.exp: Likewise.
	* gdb.disasm/t08_or.exp: Likewise.
	* gdb.disasm/t09_xor.exp: Likewise.
	* gdb.disasm/t10_and.exp: Likewise.
	* gdb.disasm/t11_logs.exp: Likewise.
	* gdb.disasm/t12_bit.exp: Likewise.
	* gdb.disasm/t13_otr.exp: Likewise.
	* gdb.gdb/selftest.exp: Likewise.
	* gdb.hp/gdb.base-hp/callfwmall.exp: Likewise.
	* gdb.mi/mi-reverse.exp: Likewise.
	* gdb.pascal/floats.exp: Likewise.
	* gdb.python/py-inferior.exp: Likewise.
	* gdb.threads/attach-into-signal.exp: Likewise.
	* gdb.threads/pthreads.exp: Likewise.
	* gdb.threads/thread_events.exp: Likewise.
	* gdb.threads/watchthreads.exp: Likewise.
	* gdb.trace/actions-changed.exp: Likewise.
	* gdb.trace/actions.exp: Likewise.
	* gdb.trace/ax.exp: Likewise.
	* gdb.trace/backtrace.exp: Likewise.
	* gdb.trace/change-loc.exp: Likewise.
	* gdb.trace/deltrace.exp: Likewise.
	* gdb.trace/disconnected-tracing.exp: Likewise.
	* gdb.trace/ftrace.exp: Likewise.
	* gdb.trace/infotrace.exp: Likewise.
	* gdb.trace/passc-dyn.exp: Likewise.
	* gdb.trace/passcount.exp: Likewise.
	* gdb.trace/pending.exp: Likewise.
	* gdb.trace/qtro.exp: Likewise.
	* gdb.trace/range-stepping.exp: Likewise.
	* gdb.trace/report.exp: Likewise.
	* gdb.trace/save-trace.exp: Likewise.
	* gdb.trace/status-stop.exp: Likewise.
	* gdb.trace/strace.exp: Likewise.
	* gdb.trace/tfile.exp: Likewise.
	* gdb.trace/tfind.exp: Likewise.
	* gdb.trace/trace-break.exp: Likewise.
	* gdb.trace/tracecmd.exp: Likewise.
	* gdb.trace/trace-mt.exp: Likewise.
	* gdb.trace/tspeed.exp: Likewise.
	* gdb.trace/tsv.exp: Likewise.
	* gdb.trace/while-stepping.exp: Likewise.
	* lib/gdb.exp: Likewise.
	* lib/gdbserver-support.exp: Likewise.
	* lib/java.exp: Likewise.
	* lib/mi-support.exp: Likewise.
	* lib/pascal.exp: Likewise.
	* lib/prompt.exp: Likewise.
	* lib/trace-support.exp: Likewise.
@
text
@d2267 3
@


1.115
log
@gdb/testsuite/

	* config/monitor.exp (gdb_target_cmd): Remove semicolon after
	'return'.
	(gdb_target_monitor, gdb_load): Likewise.
	* config/sid.exp (gdb_load): Likewise.
	* config/slite.exp (gdb_load): Likewise.
	* config/vx.exp (gdb_start, spawn_vxgdb): Likewise.
	* gdb.ada/arrayidx.exp, gdb.ada/null_array.exp: Likewise.
	* gdb.arch/mips-octeon-bbit.exp (single_step): Likewise.
	(single_step_until): Likewise.
	* gdb.arch/powerpc-d128-regs.exp: Likewise.
	* gdb.arch/system-gcore.exp: Likewise.
	* gdb.base/bigcore.exp (extract_heap): Likewise.
	* gdb.base/break-on-linker-gcd-function.exp: Likewise.
	* gdb.base/call-ar-st.exp: Likewise.
	* gdb.base/call-rt-st.exp: Likewise.
	* gdb.base/call-sc.exp, gdb.base/call-strs.exp: Likewise.
	* gdb.base/callfuncs.exp, gdb.base/completion.exp: Likewise.
	* gdb.base/condbreak.exp, gdb.base/constvars.exp: Likewise.
	* gdb.base/corefile.exp: Likewise.
	* gdb.base/dbx.exp (gdb_file_cmd): Likewise.
	* gdb.base/exprs.exp, gdb.base/fileio.exp: Likewise.
	* gdb.base/fixsection.exp: Likewise.
	* gdb.base/funcargs.exp: Likewise.
	* gdb.base/gcore-buffer-overflow.exp: Likewise.
	* gdb.base/gcore-relro.exp: Likewise.
	* gdb.base/gcore.exp, gdb.base/gdb11530.exp: Likewise.
	* gdb.base/gdb11531.exp, gdb.base/gnu-ifunc.exp: Likewise.
	* gdb.base/info-os.exp, gdb.base/info-proc.exp: Likewise.
	* gdb.base/interp.exp, gdb.base/langs.exp:: Likewise.
	* gdb.base/list.exp: Likewise.
	(set_listsize): Likewise.
	* gdb.base/logical.exp, gdb.base/mips_pro.exp: Likewise.
	* gdb.base/miscexprs.exp, gdb.base/nodebug.exp: Likewise.
	* gdb.base/opaque.exp, gdb.base/pointers.exp: Likewise.
	* gdb.base/psymtab.exp, gdb.base/ptype.exp: Likewise.
	* gdb.base/relational.exp, gdb.base/scope.exp: Likewise.
	* gdb.base/setvar.exp: Likewise.
	(test_set): Likewise.
	* gdb.base/signals.exp, gdb.base/sizeof.exp: Likewise.
	* gdb.base/solib-overlap.exp: Likewise.
	* gdb.base/store.exp, gdb.base/structs.exp: Likewise.
	* gdb.base/structs2.exp, gdb.base/volatile.exp: Likewise.
	* gdb.base/watchpoint.exp (initialize): Likewise.
	(test_simple_watchpoint): Likewise.
	(test_disabling_watchpoints): Likewise.
	(test_watchpoint_triggered_in_syscall): Likewise.
	* gdb.base/whatis.exp, gdb.cp/ambiguous.exp: Likewise.
	* gdb.cp/casts.exp, gdb.cp/ctti.exp: Likewise.
	* gdb.cp/namespace.exp, gdb.cp/nsdecl.exp: Likewise.
	* gdb.cp/psmang.exp, gdb.dwarf2/dw2-ranges.exp: Likewise.
	* gdb.hp/gdb.aCC/optimize.exp: Likewise.
	* gdb.hp/gdb.aCC/watch-cmd.exp: Likewise.
	* gdb.hp/gdb.base-hp/callfwmall.exp: Likewise.
	* gdb.hp/gdb.base-hp/pxdb.exp: Likewise.
	* gdb.hp/gdb.compat/xdb1.exp: Likewise.
	* gdb.hp/gdb.compat/xdb2.exp: Likewise.
	* gdb.hp/gdb.compat/xdb3.exp: Likewise.
	* gdb.hp/gdb.defects/bs14602.exp: Likewise.
	* gdb.hp/gdb.defects/solib-d.exp: Likewise.
	* gdb.mi/gdb792.exp: Likewise.
	* gdb.mi/mi-inheritance-syntax-error.exp: Likewise.
	* gdb.mi/mi-logging.exp, gdb.mi/mi-var-cp.exp : Likewise.
	* gdb.mi/mi-var-rtti.exp, gdb.python/py-type.exp: Likewise.
	* gdb.threads/gcore-thread.exp: Likewise.
	(load_core): Likewise.
	* gdb.threads/pthreads.exp (all_threads_running): Likewise.
	(test_startup, check_control_c): Likewise.
	* gdb.threads/sigstep-threads.exp: Likewise.
	* gdb.threads/thread_check.exp: Likewise.
	* gdb.trace/backtrace.exp, gdb.trace/change-loc.exp: Likewise.
	* gdb.trace/circ.exp (run_trace_experiment): Likewise.
	(set_a_tracepoint, trace_buffer_normal): Likewise.
	(gdb_trace_circular_tests): Likewise.
	* gdb.trace/collection.exp: Likewise.
	* gdb.trace/disconnected-tracing.exp: Likewise.
	* gdb.trace/infotrace.exp: Likewise.
	* gdb.trace/mi-traceframe-changed.exp: Likewise.
	* gdb.trace/mi-tracepoint-changed.exp: Likewise.
	* gdb.trace/mi-tsv-changed.exp (test_create_delete_modify_tsv): Likewise.
	* gdb.trace/packetlen.exp, gdb.trace/passc-dyn.exp: Likewise.
	* gdb.trace/pending.exp, gdb.trace/report.exp: Likewise.
	* gdb.trace/stap-trace.exp: Likewise.
	* gdb.trace/status-stop.exp,gdb.trace/strace.exp: Likewise.
	* gdb.trace/tfind.exp, gdb.trace/trace-break.exp: Likewise.
	* gdb.trace/trace-buffer-size.exp: Likewise.
	* gdb.trace/tspeed.exp, gdb.trace/tsv.exp: Likewise.
	* gdb.trace/unavailable.exp: Likewise.
	* gdb.trace/while-dyn.exp: Likewise.
	* lib/fortran.exp (set_lang_fortran): Likewise.
	* lib/gdb.exp (default_gdb_version, gdb_start_cmd): Likewise.
	(gdb_breakpoint, gdb_reinitialize_dir): Likewise.
	(default_gdb_start, get_compiler_info): Likewise.
	(gdb_compile, gdb_compile_objc, gdb_reload, gdb_init): Likewise.
	(get_debug_format, setup_xfail_format): Likewise.
	(rerun_to_main, gdb_skip_float_test): Likewise.
	(build_id_debug_filename_get, get_remotetimeout): Likewise.
	* lib/java.exp (set_lang_java): Likewise.
	* lib/mi-support.exp (default_mi_gdb_start): Likewise.
	(mi_gdb_reinitialize_dir, mi_gdb_target_cmd): Likewise.
	(mi_gdb_file_cmd, mi_gdb_test): Likewise.
	(mi_run_cmd_full, mi_expect_interrupt): Likewise.
	* lib/objc.exp (set_lang_objc): Likewise.
	* lib/pascal.exp (set_lang_pascal): Likewise.
	* lib/prompt.exp (default_prompt_gdb_start): Likewise.
	* lib/trace-support.exp (gdb_trace_setactions, gdb_tfind_test): Likewise.
	(gdb_readexpr, gdb_gettpnum, gdb_find_recursion_test_baseline): Likewise.
@
text
@d48 1
a48 1
    global gdb_spawn_id;
d53 1
a53 1
    gdb_stop_suppressing_tests;
d60 1
a60 1
	return;
d66 1
a66 1
	send_gdb "999-gdb-exit\n";
d69 2
a70 2
		send_gdb "y\n";
		exp_continue;
d74 1
a74 1
		exp_continue;
d82 1
a82 1
	remote_close host;
d105 1
a105 1
    global gdb_spawn_id;
d108 1
a108 1
    gdb_stop_suppressing_tests;
d148 1
a148 1
    set res [remote_spawn host "$GDB $INTERNAL_GDBFLAGS $GDBFLAGS $MIFLAGS [host_info gdb_opts]"];
d160 1
a160 1
	        remote_close host;
d171 1
a171 1
	        remote_close host;
d178 1
a178 1
	    remote_close host;
d183 1
a183 1
	    remote_close host;
d188 1
a188 1
	    remote_close host;
d192 1
a192 1
    set gdb_spawn_id -1;
d255 1
a255 1
	    send_gdb "y\n";
d273 2
a274 2
	    warning "Unexpected prompt for breakpoints deletion";
	    send_gdb "y\n";
d341 1
a341 1
		verbose "Set target to $targetname";
d348 1
a348 1
		verbose "Connection failed";
d351 1
a351 1
		verbose "Set target to $targetname";
d355 1
a355 1
		verbose "Set target to $targetname";
d359 1
a359 1
		verbose "Set target to $targetname";
d363 1
a363 1
		verbose "Set target to $targetname";
d377 1
a377 1
		verbose "Got timeout error from gdb.";
d380 1
a380 1
		send_gdb "";
d404 1
a404 1
	set arg [remote_download host $arg];
d594 2
a595 2
	set question_string [lindex $args 3];
	set response_string [lindex $args 4];
d607 1
a607 1
    set string "${command}\n";
d612 2
a613 2
	    set foo [string first "\n" "$string"];
	    set len [string length "$string"];
d615 1
a615 1
		set str [string range "$string" 0 $foo];
d617 1
a617 1
		    global suppress_flag;
d620 1
a620 1
			perror "Couldn't send $command to GDB.";
d622 1
a622 1
		    fail "$message";
d629 1
a629 1
		set string [string range "$string" [expr $foo + 1] end];
d631 1
a631 1
		break;
d636 1
a636 1
		global suppress_flag;
d639 1
a639 1
		    perror "Couldn't send $command to GDB.";
d641 1
a641 1
		fail "$message";
d648 1
a648 1
	set tmt $timeout;
d650 1
a650 1
	global timeout;
d652 1
a652 1
	    set tmt $timeout;
d654 1
a654 1
	    set tmt 60;
d666 1
a666 1
		 fail "$message";
d668 1
a668 1
	     gdb_suppress_entire_file "GDB died";
d698 2
a699 2
	    send_gdb "$response_string\n";
	    exp_continue;
d812 1
a812 1
	send_gdb "[target_info gdb_init_command]\n";
d816 1
a816 1
		perror "gdb_init_command for target failed";
d828 1
a828 1
	    send_gdb "${run_prefix}continue\n";
d837 1
a837 1
	    set start [target_info gdb,start_symbol];
d839 1
a839 1
	    set start "start";
@


1.114
log
@2013-01-21  Marc Khouzam  <marc.khouzam@@ericsson.com>

        * breakpoint.c (print_one_breakpoint_location): Add MI
        field 'thread-groups' when printing a breakpoint.
        (output_thread_groups): New function.

2013-01-21  Marc Khouzam  <marc.khouzam@@ericsson.com>

        * gdb.texinfo (GDB/MI Breakpoint Commands): Document new
        'thread-groups' field when printing a breakpoint in MI.

2013-01-21  Marc Khouzam  <marc.khouzam@@ericsson.com>

        * gdb.mi/mi-break.exp: Expect new 'thread-groups' field.
        * gdb.mi/mi-nsmoribund.exp: Expect new 'thread-groups' field.
        Also handle 'thread' field.
        * gdb.mi/mi-simplerun.exp: Expect new 'thread-groups' field.
        * gdb.mi/mi-watch.exp: Ditto.
        * lib/mi-support.exp: Ditto.
@
text
@d129 1
a129 1
	return 0;
d151 1
a151 1
	return 1;
d161 1
a161 1
	        return -1;
d172 1
a172 1
	        return -1;
d179 1
a179 1
	    return -1;
d184 1
a184 1
	    return -1;
d231 1
a231 1
    return 0;
d291 1
a291 1
	return "";
d342 1
a342 1
		return 0;
d352 1
a352 1
		return 0;
d356 1
a356 1
		return 0;
d360 1
a360 1
		return 0;
d364 1
a364 1
		return 0;
d407 1
a407 1
	    return -1;
d623 1
a623 1
		    return $result;
d642 1
a642 1
		return $result;
d669 1
a669 1
	     return -1;
d817 1
a817 1
		return -1;
d833 1
a833 1
	    return 0;
d1126 1
a1126 1
	    return 0;
@


1.113
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d925 1
a925 1
    "200\\^done,bkpt=\{number=\"\[0-9\]+\",type=\"breakpoint\",disp=\"del\",enabled=\"y\",addr=\"$hex\",func=\"$func\(\\\(.*\\\)\)?\",file=\".*\",line=\"\[0-9\]*\",times=\"0\",original-location=\".*\"\}" \
d1207 1
a1207 1
    verbose -log "Expecting: 222\\^done,bkpt=\{number=\"$number\",type=\"breakpoint\",disp=\"$disp\",enabled=\"y\",addr=\"$address\",func=\"$func\",file=\"$file\",fullname=\".*\",line=\"$line\",times=\"0\",original-location=\".*\"\}"
d1209 1
a1209 1
        "222\\^done,bkpt=\{number=\"$number\",type=\"breakpoint\",disp=\"$disp\",enabled=\"y\",addr=\"$address\",func=\"$func\",file=\"$file\",fullname=\".*\",line=\"$line\",times=\"0\",original-location=\".*\"\}" \
d1230 1
a1230 1
        set body "${body}bkpt=\{number=\"$number\",type=\"breakpoint\",disp=\"$disp\",enabled=\"y\",addr=\"$address\",func=\"$func\",file=\".*$file\",${fullname},line=\"$line\",times=\"0\",original-location=\".*\"\}"
@


1.112
log
@gdb/testsuite/
	Fix testsuite regression after --use-deprecated-index-sections removal.
	* lib/mi-support.exp (gdbindex_warning_re): Update the expect string.
@
text
@d1 1
a1 2
# Copyright 1999-2000, 2002-2005, 2007-2012 Free Software Foundation,
# Inc.
@


1.111
log
@gdb/doc/ChangeLog:

2012-04-14  Anton Gorenkov <xgsa@@yandex.ru>

	PR mi/13393
	* gdb.texinfo (Print Settings): Extend the description for "set print
	object".
	(GDB/MI Variable Objects): Extend the description for -var-create and
	-var-list-children.


gdb/testsuite/ChangeLog:

2012-04-14  Anton Gorenkov <xgsa@@yandex.ru>

	PR mi/13393
	* gdb.mi/mi-var-rtti.cc: New file.
	* gdb.mi/mi-var-rtti.exp: New file.
	* lib/mi-support.exp (mi_varobj_update_with_child_type_change): New
	function.
	(mi_varobj_update_with_type_change): updated to avoid code duplication.


gdb/ChangeLog:

2012-04-14  Anton Gorenkov <xgsa@@yandex.ru>

	PR mi/13393
	* value.c (value_actual_type): New function.
	* value.h (value_actual_type): New declaration.
	* varobj.c (update_type_if_necessary): New function.
	(varobj_create): Call value_actual_type instead of
	value_type.
	(install_dynamic_child): distinct changed and type changed MI variable
	objects.
	(update_dynamic_varobj_children): Updated for install_dynamic_child
	change.  All callers updated.
	(varobj_update): Support for MI variable object type change if
	the value changed and RTTI is used to determine the type.
	(create_child_with_value): Call value_actual_type instead of
	value_type.
	(adjust_value_for_child_access): Extended with a new parameter which
	specify whether the given value should be casted to enclosing type.
	All callers updated.
@
text
@d34 1
a34 1
set gdbindex_warning_re "&\"warning: Skipping \[^\r\n\]+ \.gdb_index section in \[^\"\]+\"\r\n"
@


1.111.2.1
log
@gdb/testsuite/
	Fix testsuite regression after --use-deprecated-index-sections removal.
	* lib/mi-support.exp (gdbindex_warning_re): Update the expect string.
@
text
@d34 1
a34 1
set gdbindex_warning_re "&\"warning: Skipping \[^\r\n\]+ \.gdb_index section in \[^\r\n\]+\"\r\n(?:&\"\\\\n\"\r\n)?"
@


1.110
log
@gdb:
	PR breakpoints/10738
	* dwarf2read.c (use_deprecated_index_sections): New global.
	(struct partial_die_info): New member may_be_inlined.
	(read_partial_die): Set may_be_inlined where appropriate.
	(add_partial_subprogram): Add partial symbols for partial
	DIEs that may be inlined.
	(new_symbol_full): Add inlined subroutines to the current
	scope.
	(write_psymtabs_to_index): Bump version number.
	(dwarf2_read_index): Read only version 6 indices unless
	use_deprecated_index_sections is set.
	* linespec.c (symbol_and_data_callback): New structure.
	(iterate_inline_only): New function.
	(iterate_over_all_matching_symtabs): New argument
	"include_inline".  If nonzero, also call the callback for
	symbols representing inlined subroutines.
	(lookup_prefix_sym): Pass extra argument to the above.
	(find_function_symbols): Likewise.
	(add_matching_symbols_to_info): Likewise.
	* NEWS: Mention that GDB can now set breakpoints on inlined
	functions.

gdb/doc:
	PR breakpoints/10738
	* gdb.texinfo (Inline Functions): Remove the now-unnecessary @@item
	stating that GDB cannot set breakpoints on inlined functions.
	(Mode Options): Document --use-deprecated-index-sections.
	(Index Section Format): Document new index section version format.

gdb/testsuite:
	PR breakpoints/10738
	* gdb.opt/inline-break.exp: New file.
	* gdb.opt/inline-break.c: Likewise.
	* gdb.dwarf2/inline-break.exp: Likewise.
	* gdb.dwarf2/inline-break.S: Likewise.
	* gdb.base/annota1.exp: Cope with old .gdb_index warnings.
	* gdb.base/async-shell.exp: Likewise.
	* lib/mi-support.exp (library_loaded_re): Likewise.
@
text
@d1301 2
a1302 2
proc mi_varobj_update_with_type_change { name new_type new_children testname } {
    set v "{name=\"$name\",in_scope=\"true\",type_changed=\"true\",new_type=\"$new_type\",new_num_children=\"$new_children\",has_more=\".\"}"
d1308 4
@


1.109
log
@	PR symtab/12406:
	* solib.c (update_solib_list): Update the program space's
	added_solibs and deleted_solibs fields.
	* progspace.h (struct program_space) <added_solibs,
	deleted_solibs>: New fields.
	(clear_program_space_solib_cache): Declare.
	* progspace.c (release_program_space): Call
	clear_program_space_solib_cache.
	(clear_program_space_solib_cache): New function.
	* infrun.c (handle_inferior_event) <TARGET_WAITKIND_LOADED>: Call
	bpstat_stop_status.  Use handle_solib_event.
	* breakpoint.c: Include gdb_regex.h.
	(print_solib_event): New function.
	(bpstat_print): Use print_solib_event.
	(bpstat_stop_status): Add special case for bp_shlib_event.
	(handle_solib_event): New function.
	(bpstat_what): Use handle_solib_event.
	(struct solib_catchpoint): New.
	(dtor_catch_solib, insert_catch_solib, remove_catch_solib)
	(breakpoint_hit_catch_solib, check_status_catch_solib)
	(print_it_catch_solib, print_one_catch_solib)
	(print_mention_catch_solib, print_recreate_catch_solib): New
	functions.
	(catch_solib_breakpoint_ops): New global.
	(catch_load_or_unload, catch_load_command_1)
	(catch_unload_command_1): New functions.
	(internal_bkpt_check_status): Add special case for
	bp_shlib_event.
	(internal_bkpt_print_it): Use print_solib_event.
	(initialize_breakpoint_ops): Initialize
	catch_solib_breakpoint_ops.
	(_initialize_breakpoint): Register "catch load" and "catch
	unload".
	* breakpoint.h (handle_solib_event): Declare.
	* NEWS: Add entry for "catch load" and "catch unload".
gdb/doc
	* gdb.texinfo (Set Catchpoints): Document "catch load" and "catch
	unload".
	(Files): Mention new catch commands.
	(GDB/MI Async Records): Likewise.
gdb/testsuite
	* lib/mi-support.exp (mi_expect_stop): Add special case for
	solib-event.
	* gdb.base/catch-load-so.c: New file.
	* gdb.base/catch-load.exp: New file.
	* gdb.base/catch-load.c: New file.
	* gdb.base/break-interp.exp (reach_1): Update regexp.
@
text
@d34 2
a35 1
set library_loaded_re "=library-loaded\[^\n\]+\"\r\n"
@


1.108
log
@	* lib/mi-support.exp: Expand comments about PATH_EXPR.
	(varobj_tree::get_path_expr): Assume that all varobjs are
	compound unless they are known simple types.
	Adjust path expressions based on parent type, path parent type,
	and tree language.
	(varobj_tree::walk_tree): Add LANGUAGE parameter and save it into
	the root varobj.
	(mi_walk_varobj_tree): Add LANGUAGE parameter.
@
text
@d1063 2
@


1.107
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2015 1
a2015 1
# mi_walk_varobj_tree $tree
d2041 3
d2090 2
a2091 1
  # simply checks all of VAR's children.
d2161 1
d2164 4
a2167 2
    # which has no path expression
    if {[string length $type] == 0} {
d2173 2
a2174 2
      set parent_variable $parent(parent)
      upvar #0 $parent_variable parent
d2177 37
a2213 1
    return "(($parent(path_expr)).$name)"
d2254 1
a2254 1
  proc walk_tree {tree callback} {
d2262 1
d2306 4
a2309 3
proc mi_walk_varobj_tree {tree {callback \
				    mi_varobj_tree_test_children_callback}} {
  ::varobj_tree::walk_tree $tree $callback
@


1.106
log
@gdb/testsuite/
	* gdb.base/break-entry.exp: Move the target use_gdb_stub test before
	starting GDB.
	* gdb.base/default.exp: Replace target use_gdb_stub checks by global
	$use_gdb_stub.
	* gdb.base/display.exp: Likewise.
	* gdb.base/ending-run.exp: Likewise.
	* gdb.base/list.exp (test_listsize): Likewise.
	* gdb.base/setshow.exp: Likewise.
	* gdb.base/valgrind-db-attach.exp: Set global use_gdb_stub to 1.
	* lib/gdb.exp (gdb_run_cmd, gdb_start_cmd): Replace target use_gdb_stub
	check by global $use_gdb_stub.
	(gdb_test_multiple): Forbid run, start or attach for !$use_gdb_stub.
	(default_gdb_start): Set global use_gdb_stub from target use_gdb_stub.
	(default_gdb_init): Unset global $use_gdb_stub.
	(gdb_continue_to_end, rerun_to_main): Replace target use_gdb_stub check
	by global $use_gdb_stub.
	* lib/gdbserver-support.exp: Extend comments for set_board_info
	gdb_protocol and gdb,socketport.
	(gdbserver_start_extended): Set global gdbserver_protocol and
	gdbserver_gdbport.  Clear global use_gdb_stub.
	* lib/mi-support.exp (default_mi_gdb_start): Set global use_gdb_stub
	from target use_gdb_stub.
	(mi_run_cmd): Replace target use_gdb_stub check by global $use_gdb_stub.
@
text
@d1 2
a2 2
# Copyright 1999, 2000, 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010, 2011
# Free Software Foundation, Inc.
@


1.106.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d1 2
a2 2
# Copyright 1999-2000, 2002-2005, 2007-2012 Free Software Foundation,
# Inc.
@


1.105
log
@gdb/testsuite/
	Fix gdb.mi/mi-solib.exp without system debug info installed.
	* lib/mi-support.exp (mi_expect_stop): Accept FILE also for `from'
	expect attribute, return 0 for it.  Update comments.
@
text
@d99 1
a99 1
    global verbose
d111 3
d799 1
a799 1
    global mi_gdb_prompt
d826 1
a826 1
    if [target_info exists use_gdb_stub] {
@


1.104
log
@	* lib/mi-support.exp (varobj_tree): New namespace and procs.
	(mi_varobj_tree_test_children_callback): New proc.
	(mi_walk_varobj_tree): New proc.
@
text
@d984 4
a987 3
# to match against whatever is output in *stopped.  ARGS should
# not include [] the list of argument is enclosed in, and other
# regular expressions should not include quotes.
d995 4
a998 3
# When we fail to match output at all, -1 is returned.  Otherwise,
# the line at which we stop is returned.  This is useful when exact
# line is not possible to specify for some reason -- one can pass
d1072 1
a1072 1
    verbose -log "mi_expect_stop: expecting: \\*stopped,${r}${a}${bn}frame=\{addr=\"$hex\",func=\"$func\",args=$args,file=\"$any$file\",fullname=\"${fullname_syntax}$file\",line=\"$line\"\}$after_stopped,thread-id=\"$decimal\",stopped-threads=$any\r\n($thread_selected_re|$breakpoint_re)*$prompt_re"
d1074 1
a1074 1
	-re "\\*stopped,${r}${a}${bn}frame=\{addr=\"$hex\",func=\"$func\",args=$args,file=\"$any$file\",fullname=\"${fullname_syntax}$file\",line=\"($line)\"\}$after_stopped,thread-id=\"$decimal\",stopped-threads=$any\r\n($thread_selected_re|$breakpoint_re)*$prompt_re" {
d1076 5
a1080 1
            return $expect_out(2,string)
@


1.103
log
@gdb
	PR mi/8444:
	* mi/mi-common.h (EXEC_ASYNC_SOLIB_EVENT, EXEC_ASYNC_FORK)
	(EXEC_ASYNC_VFORK, EXEC_ASYNC_SYSCALL_ENTRY)
	(EXEC_ASYNC_SYSCALL_RETURN, EXEC_ASYNC_EXEC): New constants.
	* mi/mi-common.c (async_reason_string_lookup): Add new reasons.
	* breakpoint.c (print_it_catch_fork, print_it_catch_vfork)
	(print_it_catch_syscall, print_it_catch_exec)
	(internal_bkpt_print_it): Use ui_out.  Emit stop reason.
	(bpstat_print): Add 'kind' argument.  Handle
	TARGET_WAITKIND_LOADED.
	* infrun.c (normal_stop): Update for bpstat_print change.  Don't
	handle TARGET_WAITKIND_LOADED here.
	* breakpoint.h (bpstat_print): Update.
gdb/testsuite
	* lib/mi-support.exp (mi_run_cmd_full): Rename from mi_run_cmd.
	Add "use_mi_command" argument.
	(mi_run_cmd, mi_run_with_cli): New procs.
	* gdb.mi/solib-lib.c: New file.
	* gdb.mi/solib-main.c: New file.
	* gdb.mi/mi-solib.exp: New file.
gdb/doc
	* gdb.texinfo (GDB/MI Async Records): Document new *stopped
	reasons.
@
text
@d1947 310
@


1.102
log
@	* lib/mi-support.exp (mi_send_resuming_command_raw): Fix a typo.
@
text
@d791 1
a791 1
proc mi_run_cmd {args} {
d800 8
d825 1
a825 1
	    send_gdb "220-exec-continue\n";
d827 1
a827 1
		-re "220\\^running\[\r\n\]+\\*running,thread-id=\"\[^\"\]+\"\r\n$mi_gdb_prompt" {}
d846 1
a846 1
    send_gdb "220-exec-run $args\n"
d848 1
a848 1
	-re "220\\^running\r\n(\\*running,thread-id=\"\[^\"\]+\"\r\n|=thread-created,id=\"1\",group-id=\"\[0-9\]+\"\r\n)*(${library_loaded_re})*(${thread_selected_re})?${mi_gdb_prompt}" {
d864 14
@


1.101
log
@gdb/testsuite/
	Fix racy FAILs.
	* lib/mi-support.exp (mi_gdb_test): Replace thread_selected_re and
	breakpoint_re globals import by async.  Set string_regex to .* for
	async.  Remove the optional thread_selected_re and breakpoint_re
	globals expectations.
@
text
@d1559 1
a1559 1
# the inferiour (run/continue/next/etc) and consumes
@


1.100
log
@gdb/testsuite/
	* lib/mi-support.exp (breakpoint_re): Suppress match reporting.
	(mi_gdb_test): Import globals thread_selected_re
	and breakpoint_re.  Expect them optionally at the regex start.
@
text
@d579 1
a579 1
    global inferior_exited_re thread_selected_re breakpoint_re
d654 5
d676 1
a676 1
	 -re "^(?:$thread_selected_re|$breakpoint_re)*($string_regex\[\r\n\]+)?($pattern\[\r\n\]+$mi_gdb_prompt\[ \]*)" {
@


1.99
log
@2011-08-09  Pedro Alves  <pedro@@codesourcery.com>

	gdb/testsuite/
	* lib/mi-support.exp (detect_async): Rename to...
	(mi_detect_async): ... this.
	* gdb.mi/mi-nonstop-exit.exp: Adjust.
	* gdb.mi/mi-nonstop.exp: Adjust.
	* gdb.mi/mi-ns-stale-regcache.exp: Adjust.
	* gdb.mi/mi-nsintrall.exp: Adjust.
	* gdb.mi/mi-nsmoribund.exp: Adjust.
	* gdb.mi/mi-nsthrexec.exp: Adjust.
@
text
@d35 1
a35 1
set breakpoint_re "=(breakpoint-created|breakpoint-deleted)\[^\n\]+\"\r\n"
d579 1
a579 1
    global inferior_exited_re
d671 1
a671 1
	 -re "^($string_regex\[\r\n\]+)?($pattern\[\r\n\]+$mi_gdb_prompt\[ \]*)" {
@


1.98
log
@gdb/testsuite/
	* lib/mi-support.exp (mi_expect_stop) <stopped at wrong place>: Accept
	thread and breakpoint notifications.
@
text
@d226 1
a226 1
    detect_async
d935 1
a935 1
proc detect_async {} {
@


1.97
log
@	MI breakpoint notifications.

        * annotate.c (breakpoint_changed): Adjust parameter type.
        * breakpoint.c (set_breakpoint_condition): Adjust to change
        in breakpoint_modified type.
        (breakpoint_set_commands): Likewise.
        (do_map_commands_command): Likewise.
        (bpstat_check_breakpoint_conditions): Notify that breakpoint has
        changed after bumping hit count.
        (bpstat_stop_status): Likewise.
        (print_one_breakpoint_location): Don't wrap in tuple here.
        (print_one_breakpoint): Always print individual locations.
        For locations, use unnamed tuple.
        (disable_breakpoints_in_unloaded_shlib): Notify that breakpoint
        has changed.
        (create_catchpoint, create_syscall_event_catchpoint): Call
        breakpoint_created obsever.
        (mention): Don't call breakpoint_created observer.
        (create_breakpoint_sal): Call breakpoint_created observer.
        (create_breakpoint, watch_command_1): Likewise.
        (create_ada_exception_breakpoint): Likewise.
        (delete_breakpoint): Call breakpoint_deleted breakpoint.
        (locations_are_equal): New.
        (update_breakpoint_locations): If locations were changed, notify.
        (set_ignore_count, disable_breakpoint, do_enable_breakpoint):
        Call breakpoint_modified observer.

        * mi/mi-cmd-break.c (breakpoint_notify): Adjust.
        (mi_cmd_break_insert): Don't set observers for modify and delete.
        * mi/mi-interp.c (mi_suppress_breakpoint_notifications): New.
        (mi_breakpoint_created, mi_breakpoint_deleted)
        (mi_breakpoint_modified): New.
        (mi_interpreter_init): Hook the above.
        * mi/mi-main.c (mi_cmd_execute): Disable breakpoint notifications
        while -break-* commands are executing.
        * mi/mi-main.h (mi_suppress_breakpoint_notifications): New.
        * mi/mi-out.c (struct ui_out_data): New field original_buffer.
        (mi_redirect): New.
        (mi_ui_out_impl): Hook in mi_redirect.
        (mi_field_skip): True to the name, skip the field, don't output
        a field with an empty value.

        * python/py-breakpoint.c (gdbpy_breakpoint_created)
        (gdbpy_breakpoint_deleted): Adjust.
        * tui/tui-hooks.c (tui_event_create_breakpoint)
        (tui_event_delete_breakpoint, tui_event_modify_breakpoint): Adjust.
@
text
@d1049 1
a1049 1
	-re "\\*stopped,${r}${a}${bn}frame=\{addr=\"$hex\",func=\"$any\",args=\[\\\[\{\]$any\[\\\]\}\],file=\"$any\",fullname=\"${fullname_syntax}$any\",line=\"\[0-9\]*\"\}$after_stopped,thread-id=\"$decimal\",stopped-threads=$any\r\n$prompt_re" {
@


1.96
log
@gdb
	* infrun.c (print_exited_reason): Include inferior id and pid in
	message.
gdb/testsuite
	* lib/opencl.exp (skip_opencl_tests): Update for exit message
	change.
	* lib/mi-support.exp (mi_gdb_test): Update for exit message
	change.
	* lib/gdb.exp (gdb_test_multiple): Update comment.  Update for
	exit message change.
	(skip_altivec_tests): Update for exit message change.
	(skip_vsx_tests): Likewise.
	(gdb_continue_to_end): Likewise.  Add 'command' argument.
	* lib/cell.exp (skip_cell_tests): Update for exit message change.
	* gdb.threads/tls.exp: Update for exit message change.
	* gdb.threads/thread-unwindonsignal.exp: Use
	gdb_continue_to_end.
	* gdb.threads/step.exp (step_it): Update for exit message change.
	(continue_all): Likewise.
	* gdb.threads/print-threads.exp (test_all_threads): Update for
	exit message change.
	* gdb.threads/interrupted-hand-call.exp: Use
	gdb_continue_to_end.
	* gdb.threads/execl.exp: Use gdb_continue_to_end.
	* gdb.python/py-prettyprint.exp (run_lang_tests): Use
	gdb_continue_to_end.
	* gdb.hp/gdb.objdbg/objdbg02.exp: Use gdb_continue_to_end.
	* gdb.hp/gdb.objdbg/objdbg01.exp: Use gdb_continue_to_end.
	* gdb.hp/gdb.defects/solib-d.exp: Update for exit message change.
	* gdb.cp/method.exp: Update for exit message change.
	* gdb.cp/mb-templates.exp: Update for exit message change.
	* gdb.cp/mb-inline.exp: Use gdb_continue_to_end.
	* gdb.cp/annota3.exp: Update for exit message change.
	* gdb.cp/annota2.exp: Update for exit message change.
	* gdb.cell/fork.exp: Use gdb_continue_to_end.
	* gdb.base/term.exp: Update for exit message change.
	* gdb.base/step-test.exp (test_i): Update for exit message change.
	* gdb.base/sigstep.exp (advance): Update for exit message change.
	(advancei): Likewise.
	* gdb.base/siginfo.exp: Update for exit message change.
	* gdb.base/shlib-call.exp: Use gdb_continue_to_end.
	* gdb.base/reread.exp: Use gdb_continue_to_end.
	* gdb.base/langs.exp: Use gdb_continue_to_end.
	* gdb.base/interrupt.exp: Update for exit message change.
	* gdb.base/gdb1555.exp: Update for exit message change.
	* gdb.base/exe-lock.exp: Use gdb_continue_to_end.
	* gdb.base/ending-run.exp: Update for exit message change.
	* gdb.base/chng-syms.exp: Update for exit message change.
	* gdb.base/checkpoint.exp: Update for exit message change.
	* gdb.base/catch-syscall.exp (check_for_program_end): Use
	gdb_continue_to_end.
	(test_catch_syscall_with_wrong_args): Likewise.
	* gdb.base/call-signal-resume.exp: Use gdb_continue_to_end.
	* gdb.base/break-interp.exp (test_ld): Update for exit message
	change.
	* gdb.base/bang.exp: Update for exit message change.
	* gdb.base/attach.exp (do_attach_tests): Use gdb_continue_to_end.
	(do_call_attach_tests): Likewise.
	* gdb.base/a2-run.exp: Update for exit message change.
	* gdb.arch/ppc-dfp.exp: Update for exit message change.
	* gdb.ada/tasks.exp: Use gdb_continue_to_end.
	* gdb.ada/catch_ex.exp: Use gdb_continue_to_end.
@
text
@d35 1
d982 1
d1043 1
a1043 1
    verbose -log "mi_expect_stop: expecting: \\*stopped,${r}${a}${bn}frame=\{addr=\"$hex\",func=\"$func\",args=$args,file=\"$any$file\",fullname=\"${fullname_syntax}$file\",line=\"$line\"\}$after_stopped,thread-id=\"$decimal\",stopped-threads=$any\r\n($thread_selected_re)?$prompt_re"
d1045 1
a1045 1
	-re "\\*stopped,${r}${a}${bn}frame=\{addr=\"$hex\",func=\"$func\",args=$args,file=\"$any$file\",fullname=\"${fullname_syntax}$file\",line=\"($line)\"\}$after_stopped,thread-id=\"$decimal\",stopped-threads=$any\r\n($thread_selected_re)?$prompt_re" {
@


1.95
log
@run copyright.sh for 2011.
@
text
@d578 1
d702 1
a702 1
	 -re "Program exited with code \[0-9\]+.*$mi_gdb_prompt\[ \]*$" {
@


1.94
log
@	* lib/mi-support.exp (thread_selected_re): Correct pattern used
	to match a thread ID.
@
text
@d1 1
a1 1
# Copyright 1999, 2000, 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010
@


1.93
log
@	* lib/mi-support.exp (mi_gdb_target_load): Delete unused timeout var.
	Declare and use new loadtimeout variable.
@
text
@d33 1
a33 1
set thread_selected_re "=thread-selected,id=\"\[0-9+\]\"\r\n"
@


1.92
log
@	gdb/testsuite/
	* lib/gdb.exp (skip_stl_tests): New.
	(gdb_compile): Symbian needs -ldl.
	(shlib_target_file): New.
	(shlib_symbol_file): New.
	(gdb_load_shlibs): Use shlib_target_file.
	* lib/mi-support.exp (mi_load_shlibs): Use shlib_target_file.
	* gdb.cp/exception.exp: Use skip_stl_tests.
	* gdb.cp/bs15503.exp: Use skip_stl_tests.  Use untested.
	* gdb.cp/try_catch.exp: Use skip_stl_tests.
	* gdb.cp/mb-templates.exp: Ditto.
	* gdb.base/commands.exp: Relax regexes.
	* gdb.base/watchpoint-solib.exp: Don't skip on symbian.  Use
	shlib_target_file and shlib_symbol_file.
	* gdb.base/maint.exp: Allow lowercase t.  Allow .rodata in
	sections.
	* gdb.base/ending-run.exp: Accept E32Main for symbian.
	* gdb.base/solib-disc.exp: Use
	shlib_target_file and shlib_symbol_file.
	* gdb.base/unload.exp: Don't skip on symbian.  Use
	shlib_target_file and shlib_symbol_file.
	* gdb.base/list.exp: Check use_gdb_stub instead of is_remote.
@
text
@d465 6
a470 1
    upvar timeout timeout
d488 1
a488 1
	gdb_expect 60 {
d492 1
a492 1
		perror "Unable to connect to SID target"
d497 1
a497 1
	gdb_expect 10 {
d501 1
a501 1
		perror "Unable to download to SID target"
d508 1
a508 1
	gdb_expect 10 {
d512 1
a512 1
		perror "Unable to select sim target"
d517 1
a517 1
	gdb_expect 10 {
d521 1
a521 1
		perror "Unable to download to sim target"
d532 1
a532 1
	gdb_expect 10 {
d536 1
a536 1
		perror "Unable to download to remote target"
@


1.91
log
@	* gdb.mi/mi-nonstop.exp (mi_nonstop_resume): New function.
	(Top level): Use it to resume.
	* lib/mi-support.exp (mi_send_resuming_command_raw): Recognize
	the Thumb mode displaced stepping error as unsupported.
@
text
@d1853 1
d1860 1
a1860 1
	gdb_download $file
@


1.90
log
@	Implement core awareness.

	* bcache.c (compare_ints): Remove
	(print_percentage): Use compare_positive_ints.
	* defs.h (compare_positive_ints): Declare.
	* linux-nat.h (struct lin_lwp): New field core.
	(linux_nat_core_of_thread_1): Declare.
	* linux-nat.c (add_lwp): Init the 'core' field.
	(linux_nat_wait_1): Record the core.
	(linux_nat_core_of_thread_1, linux_nat_core_of_thread): New.
	(linux_nat_add_target): Register the above.
	* linux-thread-db.c (update_thread_core): New.
	(thread_db_find_new_threads): Update core information for
	every thread.
	* remote.c (struct private_thread_info): New.
	(free_private_thread_info, demand_private_info): New.
	(PACKET_qXfer_threads, use_osdata_threads): New.
	(struct thread_item, threads_parsing_context
	(start_thread, end_thread, thread_attributes)
	(thread_children, threads_children, threads_elements): New.
	(remote_threads_info): Try qXfer:threads before anything
	else.
	(remote_protocol_packets): Register qXfer:threads.
	(remote_open_1): Init use_osdata_threads.
	(struct stop_reply): New field 'core'.
	(remote_parse_stop_reply): Parse core number.
	(process_stop_reply): Record core number.
	(remote_xfer_partial): Handle qXfer:threads.
	(remote_core_of_thread): New.
	(init_remote_ops): Register remote_core_of_thread.
	(_initialize_remote): Register qXfer:read.
	* target.c (target_core_of_thread): New
	* target.h (enum target_object): New value TARGET_OBJECT_THREADS.
	(struct target_ops): New field to_core_of_threads.
	(target_core_of_thread): Declare.
	* gdbthread.h (struct thread_info): New field private_dtor.
	* thread.c (print_thread_info): Report the core.
	* ui-out.c (MAX_UI_OUT_LEVELS): Increase.
	* utils.c (compare_positive_ints): New.
	* features/threads.dtd: New.
	* mi/mi-interp.c (mi_on_normal_stop): Report the core.
	* mi/mi-main.c (struct collect_cores_data, collect_cores)
	(do_nothing, free_vector_of_osdata_items)
	(splay_tree_int_comparator, free_splay_tree): New.
	(print_one_inferior_data): Implemented printing of selected
	inferiors.  Collect and print cores.
	(output_cores): New.
	(mi_cmd_list_thread_groups): Support --recurse.  Permit specifying
	thread groups together with --available.
@
text
@d1568 3
a1570 3
        -re ".*${mi_gdb_prompt}" {
            fail "$test (failed to resume)"
	    return -1
d1576 4
@


1.89
log
@gdb/testsuite/
	* lib/mi-support.exp (mi_expect_stop <stopped at wrong place>): Insert
	missing $after_stopped and comma (,) expectation.
@
text
@d1880 1
a1880 1
    set pattern "$pattern\\\}\\\].*"
@


1.88
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d1041 1
a1041 1
	-re "\\*stopped,${r}${a}${bn}frame=\{addr=\"$hex\",func=\"$any\",args=\[\\\[\{\]$any\[\\\]\}\],file=\"$any\",fullname=\"${fullname_syntax}$any\",line=\"\[0-9\]*\"\}thread-id=\"$decimal\",stopped-threads=$any\r\n$prompt_re" {
@


1.87
log
@gdb
	* varobj.h (varobj_update_result_t) <new>: New field.
	(varobj_get_child_range, varobj_set_child_range): Declare.
	(varobj_list_children): Update.
	(varobj_enable_pretty_printing, varobj_has_more)
	(varobj_pretty_printed_p): Declare.
	* varobj.c (pretty_printing): New global.
	(varobj_enable_pretty_printing): New function.
	(struct varobj_root) <from, to, constructor, child_iter,
	saved_item>: New fields.
	(varobj_create): Don't call install_default_visualizer.
	(instantiate_pretty_printer): Don't use value_copy.
	(varobj_has_more): New function.
	(restrict_range): New function.
	(install_dynamic_child): Likewise.
	(dynamic_varobj_has_child_method): Likewise.
	(update_dynamic_varobj_children): Remove 'new_and_unchanged'
	argument; add 'new', 'unchanged', 'from', and 'to' arguments.
	Rewrite.
	(varobj_get_num_children): Call update_dynamic_varobj_children.
	(varobj_list_children): Add 'from' and 'to' arguments.  Ignore
	result of update_dynamic_varobj_children.  Don't call
	install_default_visualizer.  Restrict result range.
	(varobj_add_child): Don't call install_default_visualizer.
	(varobj_pretty_printed_p): New function.
	(install_visualizer): Rewrite.  Move earlier in file.
	(install_default_visualizer): Likewise.
	(construct_visualizer): New function.
	(install_new_value_visualizer): Likewise.
	(install_new_value): Don't call release_value.  Special case
	pretty-printed objects.  Use value_incref.  Rearrange "changed"
	logic.
	(varobj_get_child_range): New function.
	(varobj_set_child_range): Likewise.
	(varobj_set_visualizer): Rewrite.
	(varobj_update): Rewrite pretty-printing logic.
	(new_variable): Initialize new fields.
	(free_variable): Destroy new fields.
	(value_of_root): Copy 'from' and 'to'.
	(my_value_of_variable): Handle pretty-printers.
	(value_get_print_value): Rework pretty-printing logic.
	(cplus_describe_child): Don't use release_value.
	* mi/mi-cmds.h (mi_cmd_enable_pretty_printing)
	(mi_cmd_var_set_update_range): Declare.
	* mi/mi-cmds.c (mi_cmds): Add enable-pretty-printing and
	var-set-update-range.
	* mi/mi-cmd-var.c (print_varobj): Update.  Emit "dynamic"
	attribute.
	(mi_cmd_var_create): Emit "has_more" attribute.
	(mi_cmd_var_set_format): Plug memory leak.
	(mi_print_value_p): Replace 'type' argument with 'var'.  Handle
	pretty-printed varobjs.
	(mi_cmd_var_list_children): Accept 'from' and 'to' arguments.
	Emit "has_more" attribute.
	(mi_cmd_var_evaluate_expression): Plug memory leak.
	(mi_cmd_var_assign): Likewise.
	(varobj_update_one): Likewise.  Emit "dynamic", "has_more", and
	"new_children" attributes.
	(mi_cmd_enable_pretty_printing): New function.
	(mi_cmd_var_set_update_range): Likewise.
gdb/doc
	* gdb.texinfo (GDB/MI Variable Objects): Document
	-enable-pretty-printing, -var-set-update-range, dynamic varobjs.
	Expand -var-update documentation.
gdb/testsuite
	* lib/mi-support.exp (mi_create_varobj): Update.
	(mi_create_floating_varobj): Likewise.
	(mi_create_dynamic_varobj): New proc.
	(mi_varobj_update): Update.
	(mi_varobj_update_with_type_change): Likewise.
	(mi_varobj_update_kv_helper): New proc.
	(mi_varobj_update_dynamic_helper): Rewrite.
	(mi_varobj_update_dynamic): New proc.
	(mi_list_varobj_children): Update.
	(mi_list_varobj_children_range): Add 'from' and 'to' arguments.
	* gdb.python/python-prettyprint.py (pp_outer): New class.
	(pp_nullstr): Likewise.
	(lookup_function): Register new printers.
	* gdb.python/python-prettyprint.c (struct substruct): New type.
	(struct outerstruct): Likewise.
	(substruct_test): New function.
	(struct nullstr): New type.
	(string_1, string_2): New globals.
	(main): Add new tests.
	* gdb.python/python-mi.exp: Added regression tests.
	* gdb.mi/mi2-var-display.exp: Update.
	* gdb.mi/mi2-var-cmd.exp: Update.
	* gdb.mi/mi2-var-child.exp: Update.
	* gdb.mi/mi2-var-block.exp: Update.
	* gdb.mi/mi-var-invalidate.exp: Update.
	* gdb.mi/mi-var-display.exp: Update.
	* gdb.mi/mi-var-cmd.exp: Update.
	* gdb.mi/mi-var-child.exp: Update.
	* gdb.mi/mi-var-block.exp: Update.
	* gdb.mi/mi-break.exp: Update.
	* gdb.mi/gdb701.exp: Update.
@
text
@d1 1
a1 1
# Copyright 1999, 2000, 2002, 2003, 2004, 2005, 2007, 2008, 2009
@


1.86
log
@	Implement -break-commands

	* breakpoint.c (get_breakpoint, breakpoint_set_commands): New.
	(commands_command): Use breakpoint_set_commands.
	* breakpoint.h (get_breakpoint, breakpoint_set_commands): Declare.

	* mi/mi-cmds.h (mi_cmd_break_commands): New.
	* mi/mi-cmds.c: Register -break-commands.
	* mi/mi-cmd-break.c (mi_cmd_break_commands, mi_read_next_line)
	(mi_command_line_array, mi_command_line_array_cnt)
	(mi_command_line_array_ptr): New.
@
text
@d1198 1
a1198 1
        "\\^done,name=\"$name\",numchild=\"\[0-9\]+\",value=\".*\",type=.*" \
d1204 1
a1204 1
        "\\^done,name=\"$name\",numchild=\"\[0-9\]+\",value=\".*\",type=.*" \
d1217 8
d1240 1
a1240 1
        set v "{name=\"$item\",in_scope=\"true\",type_changed=\"false\"}"
d1255 1
a1255 1
    set v "{name=\"$name\",in_scope=\"true\",type_changed=\"true\",new_type=\"$new_type\",new_num_children=\"$new_children\"}"
d1261 18
a1278 5
# Update a dynamic varobj named NAME.  CHILDREN is a list of children,
# in the same form as mi_list_varobj_children.  TESTNAME is the name
# of the test.
proc mi_varobj_update_dynamic {name children testname} {
    set children_exp_j [mi_child_regexp $children 0]
d1280 4
a1283 1
    set er "\\^done,changelist=\\\["
d1285 34
a1318 2
    append er "{name=\"$name\",in_scope=\"true\",type_changed=\"false\""
    append er ",children=\\\[$children_exp_j.*\\\]}\\\]"
d1388 1
a1388 1
    mi_list_varobj_children_range $varname [llength $children] $children \
d1392 3
a1394 4
# Like mi_list_varobj_children, but assumes that a subrange has been
# selected with -var-set-child-range.  NUMCHILDREN is the total number
# of children.
proc mi_list_varobj_children_range {varname numchildren children testname} {
d1410 8
d1420 2
a1421 1
    mi_gdb_test "-var-list-children $options $varname" $expected $testname
@


1.85
log
@gdb/testsuite/
	* lib/mi-support.exp (mi_check_thread_states): Permit any output before
	the expected result record.
@
text
@d1173 1
a1173 1
    foreach item $children {
d1176 1
a1177 1
    set number disp func file line address
d1181 4
a1184 3
        set line [lindex $item 3]
        set address [lindex $item 4]
        set body "$body,bkpt=\{number=\"$number\",type=\"breakpoint\",disp=\"$disp\",enabled=\"y\",addr=\"$address\",func=\"$func\",file=\"$file\",${fullname},line=\"$line\",times=\"0\",original-location=\".*\"\}"
d1188 1
a1188 1
    verbose -log "Expecint: 666\\\^done,BreakpointTable=\{nr_rows=\".\",nr_cols=\".\",hdr=\\\[\{width=\".*\",alignment=\".*\",col_name=\"number\",colhdr=\"Num\"\}.*colhdr=\"Type\".*colhdr=\"Disp\".*colhdr=\"Enb\".*colhdr=\"Address\".*colhdr=\"What\".*\\\],body=\\\[$body\\\]\}" \
@


1.84
log
@gdb

2009-05-27  Vladimir Prus  <vladimir@@codesourcery.com>
	    Tom Tromey  <tromey@@redhat.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	* mi/mi-main.c (mi_cmd_list_features): List "python" feature.
	* varobj.h (varobj_set_visualizer): Declare.
	(varobj_get_display_hint): Likewise.
	(varobj_update_result_t) <children_changed, value_installed>: New
	fields.
	* mi/mi-cmds.c (mi_cmds): Add var-set-visualizer.
	* mi/mi-cmds.h (mi_cmd_var_set_visualizer,
	mi_cmd_var_set_child_range): Declare.
	* mi/mi-cmd-var.c (mi_cmd_var_set_visualizer): New function.
	(mi_cmd_var_list_children): Emit display hint.
	(varobj_update_one): Emit display hint.  Handle dynamic children.
	* python/python.c (GdbMethods): Add "default_visualizer".
	* python/python-internal.h (apply_varobj_pretty_printer,
	gdbpy_get_varobj_pretty_printer, gdbpy_get_display_hint):
	Declare.
	(gdbpy_default_visualizer): Likewise.
	* varobj.c: Include python.h, python-internal.h.
	(PyObject): New typedef.
	(struct varobj) <children_requested, pretty_printer>: New fields.
	(varobj_create): Call install_default_visualizer.
	(instantiate_pretty_printer): New function.
	(varobj_set_display_format): Update.
	(varobj_get_display_hint): New function.
	(update_dynamic_varobj_children): New function.
	(varobj_get_num_children): Handle dynamic children.
	(varobj_list_children): Likewise.
	(install_new_value): Likewise.
	(varobj_add_child): New function.
	(install_visualizer): Likewise.
	(install_default_visualizer): Likewise.
	(varobj_set_visualizer): Likewise.
	(varobj_update): Handle dynamic children.
	(create_child): Use create_child_with_value.
	(create_child_with_value): New function.
	(value_get_print_value): Call pretty printer.  Add value_formatter
	argument.
	(c_value_of_variable): Update.
	(varobj_invalidate): Always free all_rootvarobj.
	* python/python-prettyprint.c (apply_varobj_pretty_printer): New
	function.
	(gdbpy_get_varobj_pretty_printer): Likewise.
	(gdbpy_default_visualizer): Likewise.

gdb/doc

2009-05-27  Tom Tromey  <tromey@@redhat.com>

	* gdb.texinfo (GDB/MI Miscellaneous Commands): Document "python"
	feature.
	(GDB/MI Variable Objects): Document -var-set-visualizer.

gdb/testsuite

2009-05-27  Tom Tromey  <tromey@@redhat.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	* lib/mi-support.exp (mi_varobj_update_dynamic): New proc.
	(mi_child_regexp): Likewise.
	(mi_list_varobj_children_range): Likewise.
	(mi_get_features): Likewise.
	(mi_list_varobj_children): Rewrite.
	* gdb.python/python-mi.exp: New file.
@
text
@d1811 1
a1811 1
    set pattern "\\^done,threads=\\\["
@


1.83
log
@	* gdb.mi/mi-nonstop.exp: Don't check isnative.  Use
	mi_run_to_main.  Skip thread exit test on remote targets.
	* gdb.mi/mi-nsintrall.exp: Don't check isnative.  Use
	mi_run_to_main.
	* gdb.mi/mi-nsmoribund.exp: Don't check isnative.  Use
	mi_run_to_main.
	* lib/mi-support.exp (mi_gdb_target_cmd): Remove trailing anchor
	when expecting ^connected.  Detect when the target doesn't support
	non-stop mode.
	(mi_run_cmd): Detect if non-stop mode was requested by isn't
	supported.  Return -1 on error, 0 on success.
	(mi_runto_helper): Don't expect a stop if mi_run_cmd failed.
	(mi_runto): Return mi_runto_helper's result explicitly.
@
text
@d1252 15
d1274 36
d1331 3
d1335 4
a1344 2
    set numchildren [llength $children]
    set children_exp {}
d1347 1
a1347 22
    foreach item $children {

        set name [lindex $item 0]
        set exp [lindex $item  1]
        set numchild [lindex $item 2]
        if {[llength $item] == 5} {
            set type [lindex $item 3]
            set value [lindex $item 4]

            lappend children_exp\
                "child={name=\"$name\",exp=\"$exp\",numchild=\"$numchild\",value=\"$value\",type=\"$type\"\(,thread-id=\"\[0-9\]+\")?}"
        } elseif {[llength $item] == 4} {
            set type [lindex $item 3]

            lappend children_exp\
                "child={name=\"$name\",exp=\"$exp\",numchild=\"$numchild\",type=\"$type\"\(,thread-id=\"\[0-9\]+\")?}"
        } else {
            lappend children_exp\
                "child={name=\"$name\",exp=\"$exp\",numchild=\"$numchild\"(,thread-id=\"\[0-9\]+\")?}"
        }
    }
    set children_exp_j [join $children_exp ","]
d1820 22
@


1.82
log
@	* mi/mi-interp.c (mi_solib_loaded, mi_solib_unloaded): New.
	(mi_interpreter_init): Register the above.
	* solib.c (clear_solib): Notify solib unload.
	* breakpoint.c (disable_breakpoints_in_unloaded_shlib): Do not
	disable breakpoints on a.out targets.
@
text
@d336 1
a336 1
	    -re "47\\^connected.*$mi_gdb_prompt$" {
d368 4
d794 1
a794 1
		return;
d800 1
a800 1
	return
d810 1
a810 1
	    return;
d823 1
a823 1
	return
d830 4
d836 1
a836 1
	    return
d840 2
d897 3
a899 1
      mi_run_cmd
d908 1
a908 1
    mi_runto_helper $func "run"
@


1.81
log
@        Include frame information for *stopped due to CLI commands.

        * ada-tasks.c (ada_normal_stop_observer): Adjust prototype.
        * infcmd.c (finish_command_continuation): Pass '1' for
        'print_frame' parameter to the observer.
        * infrun.c (normal_stop): Don't print mi-specific information
        here. Pass 'stop_print_frame' to the 'print_frame' parameter
        of the observer.
        * mi/mi-interp.c (mi_on_normal_stop): Adjust prototype.
        If we need to print frame, and current uiout is not the MI one,
        print frame again.
@
text
@d34 1
d782 1
d824 1
a824 1
	-re "220\\^running\r\n(\\*running,thread-id=\"\[^\"\]+\"\r\n|=thread-created,id=\"1\",group-id=\"\[0-9\]+\"\r\n)*(${thread_selected_re})?${mi_gdb_prompt}" {
d1440 1
d1444 1
a1444 1
        -re "\\^running\r\n\\*running,thread-id=\"\[^\"\]+\"\r\n($thread_selected_re)?${mi_gdb_prompt}" {
@


1.80
log
@	PR 8145.
	* thread.c (do_captured_list_thread_ids): Report the current
	thread id.
@
text
@d1021 1
a1021 1
    verbose -log "mi_expect_stop: expecting: \\*stopped,${r}${a}${bn}thread-id=\"$decimal\",stopped-threads=$any,frame=\{addr=\"$hex\",func=\"$func\",args=$args,file=\"$any$file\",fullname=\"${fullname_syntax}$file\",line=\"$line\"\}$after_stopped\r\n($thread_selected_re)?$prompt_re"
d1023 1
a1023 1
	-re "\\*stopped,${r}${a}${bn}thread-id=\"$decimal\",stopped-threads=$any,frame=\{addr=\"$hex\",func=\"$func\",args=$args,file=\"$any$file\",fullname=\"${fullname_syntax}$file\",line=\"($line)\"\}$after_stopped\r\n($thread_selected_re)?$prompt_re" {
d1027 1
a1027 1
	-re "\\*stopped,${r}${a}${bn}thread-id=\"$decimal\",stopped-threads=$any,frame=\{addr=\"$hex\",func=\"$any\",args=\[\\\[\{\]$any\[\\\]\}\],file=\"$any\",fullname=\"${fullname_syntax}$any\",line=\"\[0-9\]*\"\}$any\r\n$prompt_re" {
d1062 1
a1062 1
    verbose -log "mi_expect_interrupt: expecting: \\*stopped,${r},thread-id=\"$decimal\",stopped-threads=$any\r\n$prompt_re"
d1064 1
a1064 1
	-re "\\*stopped,${r},thread-id=\"$decimal\",stopped-threads=$any\r\n$prompt_re" {
@


1.79
log
@        Updated copyright notices for most files.
@
text
@d1608 1
a1608 1
    {.*\^done,thread-ids={(thread-id="[0-9]+"(,)?)+},number-of-threads="[0-9]+"} \
d1642 1
a1642 1
    {.*\^done,thread-ids={(thread-id="[0-9]+"(,)*)+},number-of-threads="[0-9]+"} \
@


1.78
log
@	Implement =thread-selected notification.

        * mi/mi-common.h (struct mi_interp): New, moved from ...
        * mi/mi-interp.c: ...here.
        * mi/mi-main.c (mi_execute_command): If the thread changed
        as result of command, report that.
@
text
@d1 1
a1 1
# Copyright 1999, 2000, 2002, 2003, 2004, 2005, 2007, 2008
@


1.77
log
@	Include group-id in thread-created notification.

        * mi/mi-interp.c (mi_new_thread, mi_thread_exit): Include
        group id in the output.
@
text
@d33 2
d780 1
d822 1
a822 1
	-re "220\\^running\r\n(\\*running,thread-id=\"\[^\"\]+\"\r\n|=thread-created,id=\"1\",group-id=\"\[0-9\]+\"\r\n)*${mi_gdb_prompt}" {
d960 1
d1021 1
a1021 1
    verbose -log "mi_expect_stop: expecting: \\*stopped,${r}${a}${bn}thread-id=\"$decimal\",stopped-threads=$any,frame=\{addr=\"$hex\",func=\"$func\",args=$args,file=\"$any$file\",fullname=\"${fullname_syntax}$file\",line=\"$line\"\}\r\n$after_stopped$prompt_re"
d1023 1
a1023 1
	-re "\\*stopped,${r}${a}${bn}thread-id=\"$decimal\",stopped-threads=$any,frame=\{addr=\"$hex\",func=\"$func\",args=$args,file=\"$any$file\",fullname=\"${fullname_syntax}$file\",line=\"($line)\"\}$after_stopped\r\n$prompt_re" {
d1437 1
d1441 1
a1441 1
        -re "\\^running\r\n\\*running,thread-id=\"\[^\"\]+\"\r\n${mi_gdb_prompt}" {
@


1.76
log
@	* lib/gdb.exp (GDBFLAGS): Move -nx ...
	(INTERNAL_GDBFLAGS): ... to here.  Move -nw to here as well.
	(default_gdb_version): Add $INTERNAL_GDBFLAGS to gdb invocations.
	(default_gdb_start,default_gdb_exit): Ditto.
	* lib/mi-support.exp (default_mi_gdb_start): Ditto.
	(mi_uncatched_gdb_exit): Add $INTERNAL_GDBFLAGS to log message.
	* gdb.base/corefile.exp: Add $INTERNAL_GDBFLAGS to gdb invocations.
	* gdb.base/dbx.exp (dbx_gdb_start): Ditto.
	* gdb.base/args.exp (GDBFLAGS): Don't overwrite, append.
	* gdb.base/remotetimeout.exp (GDBFLAGS): Ditto.
@
text
@d819 1
a819 1
	-re "220\\^running\r\n(\\*running,thread-id=\"\[^\"\]+\"\r\n|=thread-created,id=\"1\"\r\n)*${mi_gdb_prompt}" {
@


1.75
log
@gdb/
2008-10-23  Pedro Alves  <pedro@@codesourcery.com>

	* defs.h: Mention ptid_is_pid.
	* inferior.h (ptid_is_pid): Declare.
	* gdbthread.h (struct thread_info) <stop_requested>: New field.
	(set_stop_requested): Declare.
	* infcmd.c (interrupt_target_1): Call set_stop_requested.
	* infrun.c (clear_proceed_status): Clear stop_requested.
	(infrun_thread_stop_requested_callback,
	infrun_thread_stop_requested): New.
	(handle_inferior_event): If a TARGET_SIGNAL_TRAP is reported on a
	thread that had an explicit stop request, pretend we got a
	TARGET_SIGNAL_0.  Always stop if the thread had an explicit stop
	request.
	(print_stop_reason): In the SIGNAL_RECEIVED case, if we're not
	outputting to MI, and we got a TARGET_SIGNAL_0, print "# Stopped",
	instead of mentioning signal 0.
	(ptid_is_pid): New.
	* thread.c (set_stop_requested): New.

	* linux-nat.c (queued_waitpid): Rename to ...
	(queued_waitpid_1): ... this.  Add `peek' argument.  Handle it.
	(queued_waitpid): New, as wrapper to queued_waitpid_1.
	(push_waitpid): Push the SIGTRAP to the local event queue, to the
	kernel's.
	(send_sigint_callback): Delete.
	(linux_nat_stop_lwp): New.
	(linux_nat_stop): Use it.

gdb/doc/
2008-10-23  Pedro Alves  <pedro@@codesourcery.com>

	* observer.texi (thread_stop_requested): New.

gdb/testsuite/
2008-10-23  Pedro Alves  <pedro@@codesourcery.com>

	* lib/mi-support.exp (mi_expect_interrupt): Expect signal 0
	instead of SIGINT.
@
text
@d42 1
a42 1
    global GDBFLAGS
d59 1
a59 1
    verbose "Quitting $GDB $GDBFLAGS $MIFLAGS"
d97 1
a97 1
    global GDBFLAGS
d119 1
a119 1
    verbose "Spawning $GDB -nw $GDBFLAGS $MIFLAGS"
d141 1
a141 1
    set res [remote_spawn host "$GDB -nw $GDBFLAGS $MIFLAGS [host_info gdb_opts]"];
@


1.74
log
@gdb/
	* linux-nat.c (linux_nat_wait): Only use set_ignore_sigint in
	all-stop mode.

gdb/testsuite/
	* lib/mi-support.exp (mi_expect_interrupt): New.
	(mi_reverse_list, mi_check_thread_states): New, moved and renamed
	from gdb.mi/mi-nonstop.exp.
	* gdb.mi/mi-nsintrall.exp, gdb.mi/nsintrall.c: New.
	* gdb.mi/mi-nonstop.exp (myreverse, check_thread_states): Moved to
	lib/mi-support.exp.
	Use mi_check_thread_states throughout.  Avoid ".*" and do not
	require an anchor after -exec-run.
@
text
@d1053 1
a1053 1
    set r "reason=\"signal-received\",signal-name=\"SIGINT\",signal-meaning=\"Interrupt\""
@


1.73
log
@	* gdb.mi/mi-nonstop.exp: Do not check thread state while a
	stop is pending.  Avoid ".*" when two stops are pending.
	* lib/gdb.exp (fullname_syntax_POSIX, fullname_syntax_UNC)
	(fullname_syntax_DOS_CASE, fullname_syntax_DOS): Do not match
	newlines in fullnames.
	* lib/mi-support.exp (mi_run_cmd): Do not require an anchor.
	(mi_expect_stop): Update comments.  Only anchor in sync mode.
	Do not match newlines.
	(mi_send_resuming_command_raw): Always return status.
	(mi_get_stop_line): Do not match more than one line by accident.
	Only anchor in sync mode.
	(mi_run_inline_test): If -exec-next fails, give up.
@
text
@d1040 36
d1743 22
@


1.72
log
@	* lib/mi-support.exp (mi_expect_stop): Produce
	more details on failures.
	* gdb.mi/mi-nonstop.exp: New.
	* gdb.mi/non-stop.c: New.
@
text
@d798 1
a798 1
		-re "220\\^running\[\r\n\]+\\*running,thread-id=\"\[^\"\]+\"\r\n$mi_gdb_prompt$" {}
d946 4
a949 1
# the .* regexp for line, and then check the line programmatically.
d971 1
a971 1
        set prompt_re "$mi_gdb_prompt"
d976 1
a976 1
          -re "\\*stopped\r\n$prompt_re$" {
d989 1
a989 1
          -re "\\*stopped,reason=\"exited-normally\"\r\n$prompt_re$" {
d1015 3
a1017 1
    verbose -log "mi_expect_stop: expecting: \\*stopped,${r}${a}${bn}thread-id=\"$decimal\",stopped-threads=.*,frame=\{addr=\"$hex\",func=\"$func\",args=$args,file=\".*$file\",fullname=\"${fullname_syntax}$file\",line=\"$line\"\}\r\n$after_stopped$prompt_re$"
d1019 1
a1019 1
	-re "\\*stopped,${r}${a}${bn}thread-id=\"$decimal\",stopped-threads=.*,frame=\{addr=\"$hex\",func=\"$func\",args=$args,file=\".*$file\",fullname=\"${fullname_syntax}$file\",line=\"($line)\"\}$after_stopped\r\n$prompt_re$" {
d1023 1
a1023 1
	-re "\\*stopped,${r}${a}${bn}thread-id=\"$decimal\",stopped-threads=.*,frame=\{addr=\"$hex\",func=\".*\",args=\[\\\[\{\].*\[\\\]\}\],file=\".*\",fullname=\"${fullname_syntax}.*\",line=\"\[0-9\]*\"\}.*\r\n$prompt_re$" {
d1410 1
d1414 1
d1454 1
a1454 1
      set prompt_re "$mi_gdb_prompt"
d1458 1
a1458 1
      -re ".*line=\"(.*)\".*\r\n$prompt_re$" {
d1461 1
a1461 1
      -re ".*$mi_gdb_prompt$" {
d1545 4
a1548 2
        mi_send_resuming_command "exec-next" "$testcase: step over $line"
        set line_now [mi_get_stop_line "$testcase: step over $line"]
@


1.71
log
@	* target.c (target_async_permitted, target_async_permitted_1)
        (set_maintenance_target_async_permitted)
        (show_maintenance_target_async_permitted): New.
        (initialize_targets): Register 'set target-async'.
        * target.h (target_async_permitted): Declare.
        * linux-nat.c (linux_nat_async_enabled)
        (linux_nat_async_permitted, set_maintenance_linux_async_permitted)
        (show_maintenance_linux_async_permitted): Remove.
        (sigchld_handler, linux_nat_is_async_p, linux_nat_can_async_p)
        (get_pending_events, linux_nat_async): Use target_async_permitted.
        (linux_nat_set_async_mode): Remove, moving the only used bits
        into...
        (linux_nat_setup_async): This.
        (_initialize_linux_nat): Do not register 'maint set linux-async'.
        Use linux_nat_setup_async.
        * remote.c (remote_async_permitted, remote_async_permitted_set)
        (set_maintenance_remote_async_permitted)
        (show_maintenance_remote_async_permitted): Remove.
        (remote_open_1, remote_terminal_inferior, remote_can_async_p)
        (remote_is_async_p): Use target_async_permitted.
        (_initialize_remote): Don't register 'main set remote-async'.
        * mi/mi-cmds.c (mi_cmds): Register -list-target-features.
        * mi/mi-cmds.h (mi_cmd_list_target_features): New.
        * mi/mi-main.c (mi_cmd_list_target_features): New.
@
text
@d1012 1
a1012 1
    verbose -log "mi_expect_stop: expecting: \\*stopped,${r}${a}${bn}thread-id=\"$decimal\",stopped-threads=.*,frame=\{addr=\"$hex\",func=\"$func\",args=$args,file=\".*$file\",fullname=\"${fullname_syntax}$file\",line=\"$line\"\}$after_stopped\r\n$prompt_re$"
d1019 1
d1024 1
@


1.70
log
@	Fix for PR gdb/1543.
	* gdb.base/sep.exp: `sep-proc.c' absolute line numbers replaced with
	$LOCATION.
	(location): New variable.
	* config/cfdbug.exp, config/d10v.exp, config/dve.exp, config/i960.exp,
	config/m32r.exp, config/mn10300-eval.exp, config/proelf.exp,
	config/rom68k.exp, config/sh.exp, config/unix.exp, config/vr4300.exp,
	config/vr5000.exp, config/vxworks.exp, gdb.arch/altivec-regs.exp,
	gdb.arch/e500-abi.exp, gdb.arch/e500-regs.exp, gdb.asm/asm-source.exp,
	gdb.base/a2-run.exp, gdb.base/advance.exp, gdb.base/all-bin.exp,
	gdb.base/args.exp, gdb.base/arithmet.exp, gdb.base/assign.exp,
	gdb.base/async.exp, gdb.base/auxv.exp, gdb.base/bigcore.c,
	gdb.base/bigcore.exp, gdb.base/bitfields.exp, gdb.base/bitops.exp,
	gdb.base/break.c, gdb.base/break.exp, gdb.base/break1.c,
	gdb.base/call-ar-st.exp, gdb.base/call-rt-st.exp,
	gdb.base/call-strs.exp, gdb.base/callfuncs.c, gdb.base/callfuncs.exp,
	gdb.base/checkpoint.exp, gdb.base/chng-syms.exp,
	gdb.base/code-expr.exp, gdb.base/commands.exp, gdb.base/completion.exp,
	gdb.base/complex.exp, gdb.base/cond-expr.exp, gdb.base/condbreak.exp,
	gdb.base/consecutive.exp, gdb.base/corefile.exp, gdb.base/cvexpr.c,
	gdb.base/cvexpr.exp, gdb.base/dbx.exp, gdb.base/default.exp,
	gdb.base/define.exp, gdb.base/del.c, gdb.base/detach.exp,
	gdb.base/display.exp, gdb.base/dump.exp, gdb.base/echo.exp,
	gdb.base/environ.exp, gdb.base/eval-skip.exp, gdb.base/exprs.exp,
	gdb.base/fileio.exp, gdb.base/find.exp, gdb.base/finish.exp,
	gdb.base/funcargs.exp, gdb.base/gcore-buffer-overflow.exp,
	gdb.base/gcore.exp, gdb.base/gdb1555.exp, gdb.base/gdbvars.exp,
	gdb.base/help.exp, gdb.base/huge.exp, gdb.base/info-proc.exp,
	gdb.base/interrupt.exp, gdb.base/jump.exp, gdb.base/langs.exp,
	gdb.base/lineinc.exp, gdb.base/list.exp, gdb.base/macscp.exp,
	gdb.base/maint.exp, gdb.base/mips_pro.exp, gdb.base/miscexprs.exp,
	gdb.base/nodebug.exp, gdb.base/nofield.c, gdb.base/opaque.exp,
	gdb.base/overlays.exp, gdb.base/page.exp, gdb.base/pc-fp.exp,
	gdb.base/pending.c, gdb.base/pendshr.c, gdb.base/pointers.exp,
	gdb.base/psymtab.exp, gdb.base/ptype.exp, gdb.base/randomize.c,
	gdb.base/readline.exp, gdb.base/recurse.exp, gdb.base/regs.exp,
	gdb.base/relational.exp, gdb.base/relocate.exp, gdb.base/remote.exp,
	gdb.base/reread.exp, gdb.base/return.exp, gdb.base/return2.exp,
	gdb.base/scope.exp, gdb.base/sect-cmd.exp, gdb.base/sep-proc.c,
	gdb.base/sep.c, gdb.base/sep.exp, gdb.base/sepdebug.c,
	gdb.base/sepdebug.exp, gdb.base/setshow.exp, gdb.base/shlib-call.exp,
	gdb.base/sigaltstack.c, gdb.base/so-indr-cl.exp, gdb.base/solib.exp,
	gdb.base/source.exp, gdb.base/start.c, gdb.base/step-bt.c,
	gdb.base/step-line.exp, gdb.base/structs.c, gdb.base/structs.exp,
	gdb.base/structs2.exp, gdb.base/term.exp, gdb.base/twice.exp,
	gdb.base/type-opaque.exp, gdb.base/until.exp,
	gdb.base/value-double-free.c, gdb.base/varargs.exp,
	gdb.base/watchpoint.exp, gdb.base/whatis-exp.exp, gdb.disasm/am33.exp,
	gdb.disasm/h8300s.exp, gdb.disasm/hppa.exp, gdb.disasm/mn10300.exp,
	gdb.disasm/sh3.exp, gdb.disasm/t01_mov.exp, gdb.disasm/t02_mova.exp,
	gdb.disasm/t03_add.exp, gdb.disasm/t04_sub.exp, gdb.disasm/t05_cmp.exp,
	gdb.disasm/t06_ari2.exp, gdb.disasm/t07_ari3.exp,
	gdb.disasm/t08_or.exp, gdb.disasm/t09_xor.exp, gdb.disasm/t10_and.exp,
	gdb.disasm/t11_logs.exp, gdb.disasm/t12_bit.exp,
	gdb.disasm/t13_otr.exp, gdb.fortran/exprs.exp, gdb.fortran/types.exp,
	gdb.hp/gdb.aCC/exception.exp, gdb.hp/gdb.aCC/optimize.exp,
	gdb.hp/gdb.aCC/watch-cmd.exp, gdb.hp/gdb.base-hp/callfwmall.exp,
	gdb.hp/gdb.base-hp/dollar.exp, gdb.hp/gdb.base-hp/hwwatchbus.exp,
	gdb.hp/gdb.base-hp/pxdb.exp, gdb.hp/gdb.base-hp/reg-pa64.exp,
	gdb.hp/gdb.base-hp/reg.exp, gdb.hp/gdb.base-hp/sized-enum.exp,
	gdb.hp/gdb.base-hp/so-thresh.exp, gdb.hp/gdb.compat/xdb1.exp,
	gdb.hp/gdb.compat/xdb2.exp, gdb.hp/gdb.compat/xdb3.exp,
	gdb.java/jmisc.exp, gdb.java/jv-exp.exp, gdb.java/jv-print.exp,
	gdb.mi/gdb669.exp, gdb.mi/gdb680.exp, gdb.mi/gdb701.exp,
	gdb.mi/gdb792.exp, gdb.mi/mi-basics.exp, gdb.mi/mi-console.exp,
	gdb.mi/mi-hack-cli.exp, gdb.mi/mi-pending.c, gdb.mi/mi-pendshr.c,
	gdb.mi/mi-pthreads.exp, gdb.mi/mi-read-memory.exp, gdb.mi/mi-regs.exp,
	gdb.mi/mi-syn-frame.exp, gdb.mi/mi-until.exp, gdb.mi/mi2-basics.exp,
	gdb.mi/mi2-console.exp, gdb.mi/mi2-hack-cli.exp,
	gdb.mi/mi2-pthreads.exp, gdb.mi/mi2-read-memory.exp,
	gdb.mi/mi2-regs.exp, gdb.mi/mi2-syn-frame.exp, gdb.mi/mi2-until.exp,
	gdb.pascal/types.exp, gdb.stabs/weird.exp,
	gdb.threads/gcore-thread.exp, gdb.threads/manythreads.exp,
	gdb.threads/print-threads.exp, gdb.threads/pthreads.exp,
	gdb.threads/schedlock.exp, gdb.threads/step.exp, gdb.threads/step2.exp,
	gdb.threads/switch-threads.exp, gdb.threads/thread-specific.exp,
	gdb.threads/thread_check.exp, gdb.threads/thread_events.exp,
	gdb.threads/tls-nodebug.exp, gdb.threads/tls-shared.exp,
	gdb.threads/tls.exp, gdb.trace/actions.exp, gdb.trace/backtrace.exp,
	gdb.trace/circ.exp, gdb.trace/collection.exp, gdb.trace/deltrace.exp,
	gdb.trace/infotrace.exp, gdb.trace/limits.exp, gdb.trace/packetlen.exp,
	gdb.trace/passc-dyn.exp, gdb.trace/passcount.exp, gdb.trace/report.exp,
	gdb.trace/save-trace.exp, gdb.trace/tfind.exp, gdb.trace/tracecmd.exp,
	gdb.trace/while-dyn.exp, gdb.trace/while-stepping.exp,
	lib/mi-support.exp, lib/trace-support.exp: Remove reference
	to bug-gdb@@prep.ai.mit.edu .
@
text
@d915 1
a915 1
    send_gdb "maint show linux-async\n"
d918 1
a918 1
        -re ".*Controlling the GNU/Linux inferior in asynchronous mode is on...*$mi_gdb_prompt$" {
@


1.69
log
@	* lib/mi-support.exp (mi_load_shlibs): New.
	* gdb.mi/mi-pending.exp: Use mi_load_shlibs, not gdb_load_shlibs.
@
text
@a16 3
# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@@prep.ai.mit.edu

@


1.68
log
@	* lib/mi-support.exp (get_mi_thread_list)
	(check_mi_and_console_threads): New, moved from ...
	* gdb.mi/mi-pthread.exp: ...here.
	* gdb.mi/gdb669.exp (get_mi_thread_list)
	(check_mi_and_console_threads): Delete.
	* gdb.mi/mi2-pthread.exp: Likewise.
@
text
@d1684 15
@


1.67
log
@	* lib/mi-support.exp (default_mi_gdb_start): Remove check for
	non-MI prompt.
@
text
@d643 1
d1549 135
@


1.66
log
@        * infrun.c (normal_stop): For MI, report which threads
	were stopped.
@
text
@a171 5
	-re ".*$gdb_prompt $" {
	    untested "Skip mi tests (got non-mi prompt)."
	    remote_close host;
	    return -1;
	}
@


1.65
log
@	* lib/mi-support.exp (mi_send_resuming_command_raw): Revert
	previous commit.  Add a comment.
@
text
@d1019 1
a1019 1
    verbose -log "mi_expect_stop: expecting: \\*stopped,${r}${a}${bn}thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\"$func\",args=$args,file=\".*$file\",fullname=\"${fullname_syntax}$file\",line=\"$line\"\}$after_stopped\r\n$prompt_re$"
d1021 1
a1021 1
	-re "\\*stopped,${r}${a}${bn}thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\"$func\",args=$args,file=\".*$file\",fullname=\"${fullname_syntax}$file\",line=\"($line)\"\}$after_stopped\r\n$prompt_re$" {
d1025 1
a1025 1
	-re "\\*stopped,${r}${a}${bn}thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\".*\",args=\[\\\[\{\].*\[\\\]\}\],file=\".*\",fullname=\"${fullname_syntax}.*\",line=\"\[0-9\]*\"\}.*\r\n$prompt_re$" {
@


1.64
log
@	* lib/mi-support.exp (mi_send_resuming_command_raw): Report pass.
@
text
@d1401 9
a1409 1
            pass "$test"
@


1.63
log
@	Emit ^running via observer.
	* mi/mi-interp.c (mi_cmd_interpreter_exec): Do no print
        ^running here.
        (mi_on_resume): Print ^running if not previously output.
        * mi/mi-main.c (running_result_record_printed): New.
        (captured_mi_execute_command): Reset
        running_result_record_printed.  Use running_result_record_printed
        to decide if we should skip ^done.
        (mi_execute_async_cli_command): Don't print ^running here.
        * mi/mi-main.h (current_token, running_result_record_printed):
        Declare.
@
text
@d1401 1
@


1.62
log
@	Implement *running.
        * Makefile.in: Update dependencies.
        * gdbthread.h (struct thread_info): New field
        running_.
        (set_running, is_running): New.
        * thread.c (set_running, is_running): New.
        * inferior.h (suppress_normal_stop_observer): Rename to...
        (suppress_run_stop_observers): ..this.
        * infcmd.c (suppress_normal_stop_observer): Rename to...
        (suppress_run_stop_observers): ..this.
        (finish_command_continuation, finish_command): Adjust.
        * infcall.c (call_function_by_hand): Adjust.
        * infrun.c (normal_stop): Call set_running.
        * target.c (target_resume): New.  Call set_running.
        * target.h (target_resume): Convert from macro to
        a function.

        * mi/mi-interp.c (mi_on_resume): New.
        (mi_interpreter_init): Register mi_on_resume.
@
text
@d805 1
a805 1
		-re "220\\^running\[\r\n\]+(\\*running,thread-id=\"\[^\"\]+\"\r\n)?$mi_gdb_prompt$" {}
d922 1
a922 2
    if { $async == "unknown" } {
        send_gdb "maint show linux-async\n"
d924 9
a932 10
	gdb_expect {
	    -re ".*Controlling the GNU/Linux inferior in asynchronous mode is on...*$mi_gdb_prompt$" {
                set async 1
	    }
	    -re ".*$mi_gdb_prompt$" {
                set async 0
	    }
            timeout {
                set async 0
            }
d1019 1
a1019 1
    verbose -log "mi_expect_stop: expecting: .*\\*stopped,${r}${a}${bn}thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\"$func\",args=$args,file=\".*$file\",fullname=\"${fullname_syntax}$file\",line=\"$line\"\}$after_stopped\r\n$prompt_re$"
d1021 1
a1021 1
	-re ".*\\*stopped,${r}${a}${bn}thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\"$func\",args=$args,file=\".*$file\",fullname=\"${fullname_syntax}$file\",line=\"($line)\"\}$after_stopped\r\n$prompt_re$" {
d1025 1
a1025 1
	-re ".*\\*stopped,${r}${a}${bn}thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\".*\",args=\[\\\[\{\].*\[\\\]\}\],file=\".*\",fullname=\"${fullname_syntax}.*\",line=\"\[0-9\]*\"\}.*\r\n$prompt_re$" {
d1394 1
a1394 1
proc mi_send_resuming_command {command test} {
d1398 1
a1398 1
    send_gdb "220-$command\n"
d1400 1
a1400 1
        -re "220\\^running\r\n(\\*running,thread-id=\"\[^\"\]+\"\r\n)?${mi_gdb_prompt}" {
d1405 1
a1405 1
        -re "220\\^error,msg=.*" {
d1416 4
@


1.61
log
@	Use observers to report stop events in MI.
        * mi/mi-interp.c (mi_on_normal_stop): New.
        (mi_interpreter_init): Register mi_on_normal_stop.
        (mi_interpreter_exec_continuation): Remove.
        (mi_cmd_interpreter_exec): Don't register the above.
        * mi/mi-main.c (captured_mi_execute_command): Don't care
        about sync_execution.
        (mi_execute_async_cli_command): Don't install continuation.  Don't
        print *stopped.
        (mi_exec_async_cli_cmd_continuation): Remove.
@
text
@d805 1
a805 1
		-re "220\\^running\[\r\n\]+$mi_gdb_prompt$" {}
d826 1
a826 1
	-re "220\\^running\r\n(=thread-created,id=\"1\"\r\n)?${mi_gdb_prompt}" {
d1402 1
a1402 1
        -re "220\\^running\r\n${mi_gdb_prompt}" {
@


1.60
log
@	* lib/mi-support.exp (mi_run_cmd): Allow for =thread-created
	notification to appear.
@
text
@d230 2
d916 24
d962 1
d974 18
d995 1
a995 1
          -re "\\*stopped,reason=\"exited-normally\"\r\n$mi_gdb_prompt$" {
d1021 1
a1021 1
    verbose -log "mi_expect_stop: expecting: .*\\*stopped,${r}${a}${bn}thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\"$func\",args=$args,file=\".*$file\",fullname=\"${fullname_syntax}$file\",line=\"$line\"\}$after_stopped\r\n$mi_gdb_prompt$"
d1023 1
a1023 1
	-re ".*\\*stopped,${r}${a}${bn}thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\"$func\",args=$args,file=\".*$file\",fullname=\"${fullname_syntax}$file\",line=\"($line)\"\}$after_stopped\r\n$mi_gdb_prompt$" {
d1027 1
a1027 1
	-re ".*\\*stopped,${r}${a}${bn}thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\".*\",args=\[\\\[\{\].*\[\\\]\}\],file=\".*\",fullname=\"${fullname_syntax}.*\",line=\"\[0-9\]*\"\}.*\r\n$mi_gdb_prompt$" {
d1031 1
a1031 1
	-re ".*\r\n${mi_gdb_prompt}$" {
d1436 7
d1445 1
a1445 1
      -re ".*line=\"(.*)\".*\r\n$mi_gdb_prompt$" {
@


1.59
log
@	* gdb.base/gdb1250.exp: Remove perror.
	* lib/mi-support.exp (mi_delete_breakpoints): Match the prompt.
@
text
@d824 1
a824 1
	-re "220\\^running\r\n${mi_gdb_prompt}" {
@


1.58
log
@        * mi/mi-main.c (last_async_command): Rename to current_token.
        (previous_async_command): Remove.
        (mi_cmd_gdb_exit): Adjust.
        (mi_cmd_exec_interrupt): Don't dance with previous_async_command.
        (mi_cmd_target_select): Adjust.
        (mi_cmd_execute): Don't set previous_async_command.  Free token
        here even in async mode.
        (mi_execute_async_cli_command): Adjust.
        (mi_exec_async_cli_cmd_continuation): Adjust.  Do not free the
        token.
        (mi_load_progress): Adjust.
@
text
@d268 1
a268 1
	 -re "103-break-list\r\n103\\\^done,BreakpointTable=\{nr_rows=\".\",nr_cols=\".\",hdr=\\\[\{width=\".*\",alignment=\".*\",col_name=\"number\",colhdr=\"Num\"\}.*colhdr=\"Type\".*colhdr=\"Disp\".*colhdr=\"Enb\".*colhdr=\"Address\".*colhdr=\"What\".*\\\],body=\\\[\\\]\}" {}
@


1.57
log
@	* breakpoint.c (print_one_breakpoint_location): In MI
	mode, report the location string the breakpoint was
	originally created with.
@
text
@d950 1
a950 1
          -re "220\\*stopped,reason=\"exited-normally\"\r\n$mi_gdb_prompt$" {
d976 1
a976 1
    verbose -log "mi_expect_stop: expecting: .*220\\*stopped,${r}${a}${bn}thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\"$func\",args=$args,file=\".*$file\",fullname=\"${fullname_syntax}$file\",line=\"$line\"\}$after_stopped\r\n$mi_gdb_prompt$"
d978 1
a978 1
	-re ".*220\\*stopped,${r}${a}${bn}thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\"$func\",args=$args,file=\".*$file\",fullname=\"${fullname_syntax}$file\",line=\"($line)\"\}$after_stopped\r\n$mi_gdb_prompt$" {
d982 1
a982 1
	-re ".*220\\*stopped,${r}${a}${bn}thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\".*\",args=\[\\\[\{\].*\[\\\]\}\],file=\".*\",fullname=\"${fullname_syntax}.*\",line=\"\[0-9\]*\"\}.*\r\n$mi_gdb_prompt$" {
@


1.56
log
@	* gdb.base/attach.exp (do_attach_tests): Matching pattern for
	temporary breakpoint to match "Temporary breakpoint".
	* gdb.base/break.exp (delete_breakpoints): Likewise.
	* gdb.base/call-ar-st.exp (get_debug_format): Likewise.
	* gdb.base/commands.exp (temporary_breakpoint_commands): Likewise.
	* gdb.base/display.exp: Likewise.
	* gdb.base/foll-exec.exp (do_exec_tests): Likewise.
	* gdb.base/foll-fork.exp (catch_fork_child_follow): Likewise.
	* gdb.base/restore.exp (restore_tests): Likewise.
	* gdb.base/sepdebug.exp: Likewise.
	* gdb.base/watchpoint.exp: Likewise.
	* gdb.mi/mi-cli.exp: Added argument for new "disp" field.
	* gdb.mi/mi-pending.exp: Likewise.
	* gdb.mi/mi-simplerun.exp (test_running_the_program): Likewise.
	* gdb.mi/mi-until.exp (test_runnint_to_foo): Likewise.
	* gdb.mi/mi-var-cmd.exp: Likewise.
	* gdb.mi/mi-var-display.exp: Likewise.
	* gdb.mi/mi2-cli.exp: Likewise.
	* gdb.mi/mi2-simplerun.exp (test_running_the_program): Likewise.
	* gdb.mi/mi2-until.exp (test_running_to_foo): Likewise.
	* gdb.mi/mi2-var-display.exp: Likewise.
	* lib/gdb.exp (gdb_breakpoint): Pattern for temporary breakpoint.
	* lib/mi-support.exp (mi_runto_helper): Use "after_reason" argument for
	new "disp" field.
	(mi_expect_stop): Move after_reason argument to be really after
	reason. This is to support fix for PR2424.
@
text
@d878 1
a878 1
    "200\\^done,bkpt=\{number=\"\[0-9\]+\",type=\"breakpoint\",disp=\"del\",enabled=\"y\",addr=\"$hex\",func=\"$func\(\\\(.*\\\)\)?\",file=\".*\",line=\"\[0-9\]*\",times=\"0\"\}" \
d1062 34
@


1.55
log
@	Fix @@-varobjs.
        * varobj.c (value_of_root): Update the expression for
        floating varobjs.
        * mi/mi-cmd-var.c (varobj_update_one): If type has changed,
        report that.
@
text
@d892 1
a892 1
  mi_expect_stop "" $func ".*" ".*" "\[0-9\]+" "" $test
d973 4
a976 1
    verbose -log "mi_expect_stop: expecting: .*220\\*stopped,${r}${bn}${after_reason}thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\"$func\",args=$args,file=\".*$file\",fullname=\"${fullname_syntax}$file\",line=\"$line\"\}$after_stopped\r\n$mi_gdb_prompt$"
d978 1
a978 1
	-re ".*220\\*stopped,${r}${bn}${after_reason}thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\"$func\",args=$args,file=\".*$file\",fullname=\"${fullname_syntax}$file\",line=\"($line)\"\}$after_stopped\r\n$mi_gdb_prompt$" {
d982 1
a982 1
	-re ".*220\\*stopped,${r}${bn}${after_reason}thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\".*\",args=\[\\\[\{\].*\[\\\]\}\],file=\".*\",fullname=\"${fullname_syntax}.*\",line=\"\[0-9\]*\"\}.*\r\n$mi_gdb_prompt$" {
@


1.54
log
@	* lib/mi-support.exp (mi_expect_stop): New.
	(mi_run_cmd): Change the
	token.  Use mi_send_resuming_command, use
	mi_expect_stop.
	(mi_execute_to_helper): Rename to mi_execute_to.
	(mi_send_resuming_command): Add more error patterns.
	(mi_wait_for_stop): Renamed to...
	(mi_get_stop_line): ...this.
	(mi_run_inline_test): Adjust.

	* gdb.mi/mi-cli.exp: Use mi_execute_to/mi_expect_stop.
	* gdb.mi/mi-console.exp: Likewise.
	* gdb.mi/mi-pending.exp: Likewise.
	* gdb.mi/mi-simplerun.exp: Likewise.
	* gdb.mi/mi-stack.exp: Likewise.
	* gdb.mi/mi-stepi.exp: Likewise.
	* gdb.mi/mi-syn-frame.exp: Add comment.
	* gdb.mi/mi-until.exp: Likewise.
	* gdb.mi/mi-var-display.exp: Likewise.
	* gdb.mi/mi-watch.exp: Likewise.
	* gdb.mi/mi2-cli.exp: Likewise.
	* gdb.mi/mi2-console.exp: Likewise.
	* gdb.mi/mi2-simplerun.exp: Likewise.
	* gdb.mi/mi2-stack.exp: Likewise.
	* gdb.mi/mi2-stepi.exp: Likewise.
	* gdb.mi/mi2-until.exp: Likewise.
	* gdb.mi/mi2-var-display.exp: Likewise.
	* gdb.mi/mi2-watch.exp: Likewise.
@
text
@d1067 7
d1111 7
@


1.53
log
@2008-03-28  Aleksandar Ristovski  <aristovski@@qnx.com>

	Bring mi-support in line with gdb.exp.
	* lib/mi-support.exp (default_mi_gdb_start): Rename from mi_gdb_start.
	(mi_gdb_start): New function.
@
text
@d801 1
a801 1
	    send_gdb "000-exec-continue\n";
d803 1
a803 1
		-re "000\\^running\[\r\n\]+$mi_gdb_prompt$" {}
d822 1
a822 1
    send_gdb "000-exec-run $args\n"
d824 1
a824 1
	-re "000\\^running\r\n${mi_gdb_prompt}" {
d889 1
a889 9
      send_gdb "000-exec-continue\n"
      gdb_expect {
	  -re "000\\^running\r\n${mi_gdb_prompt}" {
	  }
	  timeout {
	    fail "$test"
	    return -1
	  }
      }
d892 1
a892 13
  gdb_expect {
    -re ".*000\\*stopped,thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\"$func\",args=\(\\\[.*\\\]\|\{.*\}\),file=\".*\",fullname=\"${fullname_syntax}.*\",line=\"\[0-9\]*\"\}\r\n$mi_gdb_prompt$" {
      pass "$test"
      return 0
    }
    -re ".*$mi_gdb_prompt$" {
      fail "$test (2)"
    }
    timeout {
      fail "$test (timeout)"
      return -1
    }
  }
d914 17
a930 5
# cmd should not include the number or newline (i.e. "exec-step 3", not
# "220-exec-step 3\n"

# Can not match -re ".*\r\n${mi_gdb_prompt}", because of false positives
# after the first prompt is printed.
a931 5
proc mi_execute_to_helper { cmd reason func args file line extra test } {
    global suppress_flag
    if { $suppress_flag } {
	return -1
    }
d936 38
a973 1
    send_gdb "220-$cmd\n"
d975 1
a975 1
	-re "220\\^running\r\n${mi_gdb_prompt}.*220\\*stopped,reason=\"$reason\",thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\"$func\",args=$args,file=\".*$file\",fullname=\"${fullname_syntax}$file\",line=\"$line\"\}$extra\r\n$mi_gdb_prompt$" {
d977 1
a977 1
	    return 0
d979 1
a979 1
	-re "220\\^running\r\n${mi_gdb_prompt}.*220\\*stopped,reason=\"$reason\",thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\".*\",args=\[\\\[\{\].*\[\\\]\}\],file=\".*\",fullname=\"${fullname_syntax}.*\",line=\"\[0-9\]*\"\}.*\r\n$mi_gdb_prompt$" {
d983 1
a983 1
	-re "220\\^running\r\n${mi_gdb_prompt}.*\r\n${mi_gdb_prompt}$" {
d991 1
a991 1
    }
d994 6
d1001 8
a1008 2
    mi_execute_to_helper "$cmd" "$reason" "$func" "\\\[$args\\\]" \
	"$file" "$line" "$extra" "$test"
d1308 7
d1316 2
a1317 1
            fail $test
d1333 1
a1333 1
    return [mi_wait_for_stop $test]
d1337 1
a1337 1
proc mi_wait_for_stop {test} {
d1414 1
a1414 1
            set line_now [mi_wait_for_stop "$testcase: step to $line"]
d1430 1
a1430 1
        set line_now [mi_wait_for_stop "$testcase: step over $line"]
@


1.52
log
@	* lib/mi-support.exp (mi_create_varobj_checked): New.
	(mi_list_varobj_children): Allow to check for a
	value.
	(mi_list_array_varobj_children): New.

	* gdb.mi/mi-var-child.exp: Use mi_create_varobj
	and mi_list_varobj_children, as opposed to hardcoding
	expected strings.
	* gdb.mi/gdb701.exp: Likewise.
	* gdb.mi/gdb792.exp: Likewise.
	* gdb.mi/mi-var-block.exp: Likewise.
	* gdb.mi/mi-var-cmd.exp: Likewise.
	* gdb.mi/mi-var-invalidate.exp: Likewise.
	* gdb.mi/mi2-var-block.exp: Likewise.
	* gdb.mi/mi2-var-child.exp: Likewise.
	* gdb.mi/mi2-var-cmd.exp: Likewise.
	* gdb.mi/mi2-var-display.exp: Likewise.
@
text
@d87 1
a87 1
# mi_gdb_start [INFERIOR_PTY] -- start gdb running, default procedure
d97 1
a97 1
proc mi_gdb_start { args } {
d233 8
@


1.51
log
@* lib/gdbserver-support.exp (gdb_target_cmd): Recognize 'unknown
host' errors.
* lib/mi-support.exp (mi_gdb_target_cmd): Same.
@
text
@d1023 8
d1082 4
a1085 1
# type for a child.
d1089 6
d1104 1
a1104 1
        if {[llength $item] == 4} {
d1106 1
d1109 6
a1114 1
                "child={name=\"$name\",exp=\"$exp\",numchild=\"$numchild\",type=\"$type\"}"
d1117 1
a1117 1
                "child={name=\"$name\",exp=\"$exp\",numchild=\"$numchild\"}"
d1121 5
a1125 1
    set expected "\\^done,numchild=\"$numchildren\",children=\\\[$children_exp_j\\\]"
d1129 11
a1139 1
    mi_gdb_test "-var-list-children $varname" $expected $testname
@


1.51.6.1
log
@gdb/insight for ARCompact (from Richard Stuckey)
@
text
@a775 13
    send_gdb "target sim\n"
    gdb_expect 120 {
        -re "Connected to the simulator.*$gdb_prompt $" {
	    verbose "Connected to simulator." 2
        }
    }

    send_gdb "load\n"
    gdb_expect 120 {
        -re ".*$gdb_prompt $" {
         }
    }

@


1.50
log
@	Updated copyright notices for most files.
@
text
@d335 3
@


1.49
log
@        Switch the license of all .exp files to GPLv3.
        Switch the license of all .f and .f90 files to GPLv3.
        Switch the license of all .s and .S files to GPLv3.
@
text
@d1 1
a1 1
# Copyright 1999, 2000, 2002, 2003, 2004, 2005, 2007
@


1.48
log
@	* lib/mi-support.exp (mi_gdb_target_load): Do a "kill" prior
	to restarting SID.
@
text
@d6 1
a6 1
# the Free Software Foundation; either version 2 of the License, or
d8 1
a8 1
# 
d13 1
a13 1
# 
d15 1
a15 2
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
@


1.47
log
@	* lib/gdbserver-support.exp (gdbserver_spawn): Only match full_buffer.
	(gdbserver_run): Kill any running gdbserver.
	* lib/mi-support.exp (mi_gdb_target_load): Likewise.
@
text
@d467 4
@


1.46
log
@	* gdb.mi/mi-syn-frame.c (main, foo, bar)
	(have_a_very_merry_interrupt): Remove calls to puts.
	* gdb.mi/mi-syn-frame.exp, gdb.mi/mi2-syn-frame.exp: Do not expect
	inferior output.
	* lib/mi-support.exp (mi_gdb_test): Check gdb,noinferiorio.  Correct
	test names.
@
text
@d457 1
@


1.45
log
@	* gdb.base/sigaltstack.exp: Use 'srcfile' in error
	message, not the undefined 'module' variable.
	* gdb.base/siginfo.exp: Likewise.
	* gdb.base/sigstep.exp: Likewise.
	* lib/gdbserver-support.exp (gdb_target_cmd): Quote
	serialport.
	* lib/mi-support.exp (mi_gdb_target_cmd): Likewise.
@
text
@d735 10
a744 8
	    global mi_inferior_spawn_id
	    expect {
		-i $mi_inferior_spawn_id -re "$ipattern" {
		    pass "inferior_output:$message"
		}
		timeout {
		    fail "inferior output timeout"
		    set result 1
d746 2
@


1.44
log
@        * varobj.h (varobj_set_frozen): New
        (varobj_get_frozen): New.
        (varobj_update): New parameter explicit.
        * varobj.c (struct varobj): New fields frozen
        and not_fetched.
        (varobj_set_frozen, varobj_get_frozen): New.
        (install_new_value): Don't fetch values for
        frozen variable object, or children thereof.  Allow
        a frozen variable object to have non-fetched value.
        (varobj_update): Allow updating child variables.
        Don't traverse frozen children.
        (new_variable): Initialize the frozen field.
        (c_value_of_variable): Return NULL for frozen
        variable without any value yet.
        * mi/mi-cmd-var.c (varobj_update_one): New parameter
        'explicit'.
        (mi_cmd_var_create): Output the 'frozen' field,
        as soon as testsuite is adjusted to expect that field.
        (mi_cmd_var_set_frozen): New.
        (mi_cmd_var_update): Pass the 'explicit' parameter to
        varobj_update_one.
        * mi/mi-cmds.c (mi_cmds): Register '-var-set-frozen'.
        * mi/mi-cmds.h (mi_cmd_var_set_frozen): Declare.
@
text
@d328 1
d343 1
a343 1
	    -re "Remote debugging using .*$serialport.*$mi_gdb_prompt$" {
@


1.43
log
@        * gdb.mi/mi-var-child.c
        (do_children_tests): User char[2] instead of
        char so that automatic printing of pointers to char
        don't give unpredicable result.
        * gdb.mi/var-cmd.c (do_locals_test): Initialize
        local variables.
        * gdb.mi/mi-var-child.exp: Step to right line
        of do_children_tests.
        * gdb.mi/mi2-var-child.exp: Likewise.
        * gdb.mi/mi-var-cmd.exp: Step to right line of
        do_locals_tests.
        (do_children_tests): User char[2] instead of
        char so that automatic printing of pointers to char
        don't give unpredicable result.
        * gdb.mi/mi2-var-cmd.exp: Likewise.
        * lib/mi-support.exp (mi_continue_to_line):
        Pass test name to mi_wait_for_stop.
@
text
@d1027 1
a1027 1
        if {$first} {
d1029 1
d1316 1
a1316 1
            set line_now [mi_continue_to_line "$mi_autotest_source:$line"]
@


1.42
log
@	* config/gdbserver.exp (gdbserver_gdb_load): Update argument list.
	(gdb_load): Delete, replace with...
	(gdb_reload): ...this.
	* gdb.server/server-run.exp: Use gdb_load and gdbserver_run.
	* gdb.server/server-mon.exp: Likewise.
	* lib/gdb.exp (gdb_run_cmd): Use gdb_reload.
	(gdb_start_cmd): New.
	(gdb_file_cmd): Save the last loaded file.
	(gdb_reload): New.
	(gdb_gnu_strip_debug): Use transform.
	* lib/gdbserver-support.exp (gdbserver_spawn): Move file download
	support here.  Use new $last_loaded_file.  Check mtime.
	(gdb_target_cmd): Handle ObjC failure case.
	(infer_host_exec): Delete.
	(gdbserver_load): Rename to...
	(gdbserver_run): ...this.  Simplify.
	* lib/mi-support.exp (mi_gdb_file_cmd): Set last_loaded_file.
	(mi_gdb_load): Move most contents to a new function...
	(mi_gdb_target_load): ...here.  Simplify call to gdbserver_gdb_load.
	(mi_run_cmd): Use mi_gdb_target_load.
	* gdb.base/break.exp, gdb.base/ending-run.exp, gdb.base/pending.exp,
	gdb.base/sepdebug.exp, gdb.base/unload.exp, gdb.objc/objcdecode.exp:
	Use gdb_run_cmd.
	* gdb.base/charsign.exp: Remove incorrect comment.
	* gdb.base/dbx.exp (gdb_file_cmd): Set last_loaded_file.
	* gdb.ada/exec_changed.exp, gdb.ada/null_record.exp, gdb.ada/start.exp,
	gdb.base/start.exp: Use gdb_start_cmd.
@
text
@d1227 1
a1227 1
proc mi_continue_to_line {location command} {
d1231 1
a1231 1
    return [mi_wait_for_stop]
@


1.41
log
@Update tests to include value field in output of -var-create.

mi/mi-cmd-var.c (mi_cmd_var_create):  Add value field.
@
text
@d382 1
a382 2
    global last_mi_gdb_file
    global last_mi_remote_file
d385 1
a385 8
    if { $arg == "" } {
	set arg $last_mi_gdb_file;
    } else {
	set last_mi_gdb_file $arg
	if { [ info exists last_mi_remote_file ] } {
	    unset last_mi_remote_file
	}
    }
d444 1
a444 1
# load a file into the debugger.
d447 1
a447 1
proc mi_gdb_load { arg } {
a454 6
    # ``gdb_unload''
    if { $arg != "" } {
	mi_gdb_file_cmd $arg
    }

    # ``load''
d456 1
a456 12
	global last_mi_gdb_file
	global last_mi_remote_file

	if { ! [info exists last_mi_remote_file] } {
	    if [is_remote target] {
		set last_mi_remote_file [remote_download target $arg /tmp/[file tail $arg].[pid]]
	    } else {
		set last_mi_remote_file $last_mi_gdb_file
	    }
	}

	set res [gdbserver_gdb_load $last_mi_remote_file]
d522 11
d775 4
a780 5
	    # Specifying no file, defaults to the executable
	    # currently being debugged.
	    if { [mi_gdb_load ""] < 0 } {
		return;
	    }
@


1.40
log
@        Fix computation of the 'editable' attribute and
        value changeability for for references.
        * varobj.c (get_value_type): New function.
        (c_variable_editable): Use get_value_type.
        (varobj_value_is_changeable): Likewise.
@
text
@d1022 1
a1022 1
        "\\^done,name=\"$name\",numchild=\"\[0-9\]+\",type=.*" \
@


1.39
log
@Copyright updates for 2007.
@
text
@d1026 7
@


1.38
log
@	* varobj.c (varobj_list_children): Stop if the number of children is
	unknown.
	(c_number_of_children): Report no children for zero sized arrays.

	* lib/mi-support.exp (mi_runto_helper): Expect two prompts
	when continuing.
@
text
@d1 2
a2 1
# Copyright 1999, 2000, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
@


1.37
log
@	Implement specification of MI tests as comments
	in C and C++ sources.
	* lib/mi-support.exp (mi_autotest_data): New variable.
	(mi_autotest_source): New variable.
	(count_newlines, mi_prepare_inline_tests)
	(mi_get_inline_test, mi_continue_to_line)
	(mi_run_inline_test, mi_tbreak)
	(mi_send_resuming_command, mi_wait_for_stop): New functions.
	* gdb.mi/mi-var-cp.exp: Move most content to the C file.
	Run inline tests.
	* gdb.mi/mi-var-cp.cc: Define tests here.
@
text
@d883 9
a891 1
    send_gdb "000-exec-continue\n"
d893 1
@


1.36
log
@        Simplify usage of mi_continue_to.
        * lib/mi-support.exp (mi_runto_helper): Renamed
        from mi_runto, added new parameter 'run_or_continue'.
        (mi_runto): Use mi_runto_helper.
        (mi_continue_to): Accept just function name as parameter.
        Use mi_runto_helper.
        * gdb.mi/mi-var-cmd.exp: Adjust to changes.
        * gdb.mi/mi2-var-cmd.exp: Likewise.
@
text
@d825 1
a825 1
    # NOTE: Shortly after this there will be a ``000*stopping,...(gdb)''
d1089 246
@


1.35
log
@2006-12-08  Vladimir Prus  <vladimir@@codesourcery.com>

        Test for base in references.
        * gdb.mi/mi-var-cp.cc: Add test code.
        * gdb.mi/mi-var-cp.exp: Test for bases in references.
        * gdb.mi/mi-watch.exp: Adjust to mi_runto changes.
        * gdb.mi/mi2-watch.exp: Likewise.
        * lib/mi-support.exp (mi_runto): Use temporary breakpoint.
        (mi_list_varobj_children): New function.
@
text
@d861 1
a861 1
proc mi_runto {func} {
d880 5
a884 1
  mi_run_cmd
d900 3
d977 2
a978 3
proc mi_continue_to { bkptno func args file line test } {
    mi_execute_to "exec-continue" "breakpoint-hit\",bkptno=\"$bkptno" \
	"$func" "$args" "$file" "$line" "" "$test"
@


1.34
log
@2006-12-08  Vladimir Prus  <vladimir@@codesourcery.com>

        * varobj.c (varobj_create): Don't call release_value.
        (varobj_set_value): Likewise.
        (install_new_value): Call coerce_ref and release_value
        on the value. Add asserts.
@
text
@d871 2
a872 2
  mi_gdb_test "200-break-insert $func" \
    "200\\^done,bkpt=\{number=\"\[0-9\]+\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$hex\",func=\"$func\(\\\(.*\\\)\)?\",file=\".*\",line=\"\[0-9\]*\",times=\"0\"\}" \
d882 1
a882 1
    -re ".*000\\*stopped,reason=\"breakpoint-hit\",bkptno=\"$bkptno\",thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\"$func\",args=\(\\\[.*\\\]\|\{.*\}\),file=\".*\",fullname=\"${fullname_syntax}.*\",line=\"\[0-9\]*\"\}\r\n$mi_gdb_prompt$" {
d1037 46
@


1.33
log
@gdb/
	* corefile.c (reopen_exec_file): Only check for an open exec file.
	Use exec_file_attach.
	* exec.c (exec_open): Make static.
	(exec_file_command): Don't use target_preopen.  Query directly about
	changing the file.
	* gdbcore.h (exec_open): Remove prototype.
gdb/testsuite/
	* gdb.base/completion.exp: Update for change in "file" behavior.
	* gdb.stabs/weird.exp: Likewise.
	* lib/mi-support.exp (mi_gdb_file_cmd): Likewise.
	* lib/gdb.exp (gdb_file_cmd): Likewise.  Kill the program explicitly.
@
text
@d872 1
a872 1
    "200\\^done,bkpt=\{number=\"\[0-9\]+\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$hex\",func=\"$func\",file=\".*\",line=\"\[0-9\]*\",times=\"0\"\}" \
d1001 36
@


1.32
log
@2005-09-27  Bob Rossi  <bob@@brasko.net>

        * gdb.mi/mi-disassemble.exp, gdb.mi/mi2-disassemble.exp: Remove .*
        from test.  Escape the | in mi_gdb_test call.
        * gdb.mi/mi-basics.exp, gdb.mi/mi-cli.exp, gdb.mi/mi-disassemble.exp,
        gdb.mi/mi-pthreads.exp, gdb.mi/mi-stack.exp, gdb.mi/mi2-basics.exp,
        gdb.mi/mi2-cli.exp, gdb.mi/mi2-disassemble.exp,
        gdb.mi/mi2-pthreads.exp, gdb.mi/mi2-stack.exp: Add extra details to
        expected regex's in mi_gdb_test calls.
        * lib/mi-support.exp: Remove arbitrary .* from tests.
        (mi_gdb_test): Add string_regex variable. Add anchor to main -re.
        Fully anchor GDB/MI expected results in mi_gdb_test.
        * lib/gdb.exp (string_to_regexp): Escape the ] character.
        * gdb.base/sizeof.exp: Remove escape character. Correct test.
@
text
@a413 5
        -re "A program is being debugged already.*Kill it.*y or n. $" {
            send_gdb "y\n"
                verbose "\t\tKilling previous program being debugged"
            exp_continue
        }
@


1.32.16.1
log
@        gdb/testsuite/
        * config/symbian.exp (infer_host_exec): Cope with MI.
        (mi_target_gdb_load): New.
        * lib/mi-support.exp: Use mi_target_gdb_load.
@
text
@d473 1
a473 3
    if { [info procs mi_target_gdb_load] != "" } {
	return [mi_target_gdb_load $arg]
    } elseif { [info procs gdbserver_gdb_load] != "" } {
@


1.32.22.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@d414 5
@


1.31
log
@2005-09-11  Bob Rossi  <bob@@brasko.net>

	* lib/mi-support.exp (mi_gdb_test): Change -re to not be anchored.
	* gdb.mi/mi-syn-frame.exp: Call mi_gdb_test twice instead of once for
	  commands that return an MI output command and an asyncronous MI output
	  command.
	* gdb.mi/mi-console.exp: Ditto.
@
text
@d249 1
a249 1
	 -re ".*102-break-delete\r\n102\\\^done\r\n$mi_gdb_prompt$" {
d599 2
d664 5
a668 1
	 -re "\[\r\n\]*($pattern)\[\r\n\]+$mi_gdb_prompt\[ \]*" {
d934 1
a934 1
	-re ".*220\\^running\r\n${mi_gdb_prompt}.*220\\*stopped,reason=\"$reason\",thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\"$func\",args=$args,file=\".*$file\",fullname=\"${fullname_syntax}$file\",line=\"$line\"\}$extra\r\n$mi_gdb_prompt$" {
d938 1
a938 1
	-re ".*220\\^running\r\n${mi_gdb_prompt}.*220\\*stopped,reason=\"$reason\",thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\".*\",args=\[\\\[\{\].*\[\\\]\}\],file=\".*\",fullname=\"${fullname_syntax}.*\",line=\"\[0-9\]*\"\}.*\r\n$mi_gdb_prompt$" {
@


1.30
log
@	* lib/mi-support.exp (mi_gdb_load): Fix typo.
@
text
@d662 9
a670 1
	 -re "\[\r\n\]*($pattern)\[\r\n\]+$mi_gdb_prompt\[ \]*$" {
@


1.29
log
@2005-08-02  Bob Rossi  <bob@@brasko.net>

       * gdb.mi/mi-basics.exp: Tell mi_gdb_start to use a PTY for inferior.
       (test_setshow_inferior_tty): Add global mi_inferior_tty_name to scope.
       Change tests to inferior-tty-set/show.
       * gdb.mi/mi-console.exp: Tell mi_gdb_start to use a PTY for inferior.
       (47-exec-next): Use mi_gdb_test to get GDB and Inferior output.
       * gdb.mi/mi-syn-frame.exp: Tell mi_gdb_start to use a PTY for
       inferior.  Use mi_gdb_test to get GDB and Inferior output.
       * lib/mi-support.exp (mi_inferior_spawn_id): Add inferior PTY
       descriptor.
       (mi_inferior_tty_name): Add inferior PTY file name.
       (mi_gdb_start): Add INFERIOR_PTY parameter.
       (mi_gdb_test): Add IPATTERN parameter.
@
text
@d496 1
a496 1
	    -re "\\^done,.*$mi_gdb_prompt$" {
@


1.28
log
@2005-08-02   Bob Rossi  <bob@@brasko.net>

	* gdb.mi/mi-syn-frame.exp, gdb.mi/mi2-syn-frame.exp: Add MESSAGE
	parameter to mi_gdb_test.
	* lib/mi-support.exp (mi_gdb_test): Make MESSAGE parameter necessary.
@
text
@d31 3
d87 5
a91 1
# start gdb -- start gdb running, default procedure
d97 1
a97 1
proc mi_gdb_start { } {
d108 7
d134 10
d216 13
d551 2
a552 1
# mi_gdb_test COMMAND PATTERN MESSAGE -- send a command to gdb; test the result.
d561 3
d580 4
d734 17
@


1.27
log
@2005-05-17  Daniel Jacobowitz  <dan@@codesourcery.com>
	    Dennis Brueni  <dennis@@slickedit.com>

gdb/
	* stack.c (print_frame): In MI mode, output a fullname attribute
	with the stack frame.
gdb/doc/
	* gdb.texinfo (GDB/MI Breakpoint Table Commands)
	(GDB/MI Data Manipulation, GDB/MI Program Control)
	(GDB/MI Stack Manipulation): Update examples to include the fullname
	attribute in stack frames.
gdb/testsuite/
	* gdb.mi/mi-cli.exp, gdb.mi/mi-return.exp, gdb.mi/mi-stack.exp,
	gdb.mi/mi-stepi.exp, gdb.mi/mi-syn-frame.exp, gdb.mi/mi-until.exp,
	gdb.mi/mi-var-display.exp, gdb.mi/mi-watch.exp, gdb.mi/mi2-cli.exp,
	gdb.mi/mi2-return.exp, gdb.mi/mi2-stack.exp,
	gdb.mi/mi2-syn-frame.exp, gdb.mi/mi2-until.exp,
	gdb.mi/mi2-var-display.exp: Expect fullname field in stack frames.
	* lib/mi-support.exp (mi_runto, mi_execute_to_helper): Likewise.
@
text
@d520 3
a522 4
# MESSAGE is an optional message to be printed.  If this is
#   omitted, then the pass/fail messages use the command string as the
#   message.  (If this is the empty string, then sometimes we don't
#   call pass or fail at all; I don't understand this at all.)
a534 5
    if [llength $args]>2 then {
	set message [lindex $args 2]
    } else {
	set message [lindex $args 0]
    }
d537 1
@


1.26
log
@	* lib/mi-support.exp (mi_gdb_load): Use /tmp for gdbserver
	downloads.
	* config/gdbserver.exp (gdb_load): Likewise.
@
text
@d802 1
a802 1
  global hex decimal
d816 1
a816 1
    -re ".*000\\*stopped,reason=\"breakpoint-hit\",bkptno=\"$bkptno\",thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\"$func\",args=\(\\\[.*\\\]\|\{.*\}\),file=\".*\",line=\"\[0-9\]*\"\}\r\n$mi_gdb_prompt$" {
d860 1
d863 1
a863 1
	-re ".*220\\^running\r\n${mi_gdb_prompt}.*220\\*stopped,reason=\"$reason\",thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\"$func\",args=$args,file=\".*$file\",line=\"$line\"\}$extra\r\n$mi_gdb_prompt$" {
d867 1
a867 1
	-re ".*220\\^running\r\n${mi_gdb_prompt}.*220\\*stopped,reason=\"$reason\",thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\".*\",args=\[\\\[\{\].*\[\\\]\}\],file=\".*\",line=\"\[0-9\]*\"\}.*\r\n$mi_gdb_prompt$" {
@


1.25
log
@2005-03-14  Paul Brook  <paul@@codesourcery.com>

	* lib/mi-support.exp: Use mi_gdb_target_cmd to connect to remote
	targets.
@
text
@d1 1
a1 1
# Copyright 1999, 2000, 2002, 2003, 2004 Free Software Foundation, Inc.
d442 1
a442 1
		set last_mi_remote_file [remote_download target $arg]
@


1.25.2.1
log
@	* lib/mi-support.exp (mi_gdb_load): Use /tmp for gdbserver
	downloads.
	* config/gdbserver.exp (gdb_load): Likewise.
@
text
@d1 1
a1 1
# Copyright 1999, 2000, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
d442 1
a442 1
		set last_mi_remote_file [remote_download target $arg /tmp/[file tail $arg].[pid]]
@


1.24
log
@	* config/gdbserver.exp (gdbserver_gdb_load): Rename from gdb_load.
	Remove downloading, guessing the host executable, the calls to
	gdb_file_cmd and gdb_target_cmd, and "load" support.
	(infer_host_exec): New function broken out from gdb_load.
	(gdb_load): New wrapper for gdbserver_gdb_load.
	* lib/mi-support.exp (mi_gdb_target_cmd): New function, based on
	gdb_target_cmd.  Use -target-select.
	(mi_gdb_file_cmd): New function, broken out from mi_gdb_load.
	Download binaries to the host.  Clear last_mi_remote_file when
	we load a new binary.
	(mi_gdb_load): Call mi_gdb_file_cmd.  If gdbserver.exp is loaded,
	call gdbserver_gdb_load and mi_gdb_target_cmd.
@
text
@d497 3
a499 8
	send_gdb "target [target_info gdb_protocol] [target_info netport]\n"
	gdb_expect 60 {
	    -re "\\^done,.*$mi_gdb_prompt$" {
	    }
	    timeout {
		perror "Unable to connect to remote target"
		return -1
	    }
@


1.23
log
@	* lib/mi-support.exp (mi_run_cmd): Expect an MI response to
	000-exec-continue.
@
text
@d1 1
a1 1
# Copyright 1999, 2000, 2002 Free Software Foundation, Inc.
d284 50
d335 1
a335 1
# load a file into the debugger.
d338 1
a338 1
proc mi_gdb_load { arg } {
d345 1
d350 5
d357 7
a363 3
    set last_mi_gdb_file $arg;

    # ``gdb_unload''
a364 1
    # ``gdb_file_cmd''
d371 1
a371 1
            # All OK
d400 4
a403 3
            # We are just giving the prompt back for now
	    # All OK
            }
d408 1
a408 1
        eof {
d416 19
a434 1
    
d436 20
a455 1
    if { [info procs send_target_sid] != "" } {
@


1.23.6.1
log
@merge mainline changes into branch
@
text
@d1 1
a1 1
# Copyright 1999, 2000, 2002, 2003, 2004 Free Software Foundation, Inc.
a283 50
# Send GDB the "target" command.
# FIXME: Some of these patterns are not appropriate for MI.  Based on
# config/monitor.exp:gdb_target_command.
proc mi_gdb_target_cmd { targetname serialport } {
    global mi_gdb_prompt

    for {set i 1} {$i <= 3} {incr i} {
	send_gdb "47-target-select $targetname $serialport\n"
	gdb_expect 60 {
	    -re "47\\^connected.*$mi_gdb_prompt$" {
		verbose "Set target to $targetname";
		return 0;
	    }
	    -re "Couldn't establish connection to remote.*$mi_gdb_prompt$" {
		verbose "Connection failed";
	    }
	    -re "Remote MIPS debugging.*$mi_gdb_prompt$" {
		verbose "Set target to $targetname";
		return 0;
	    }
	    -re "Remote debugging using .*$serialport.*$mi_gdb_prompt$" {
		verbose "Set target to $targetname";
		return 0;
	    }
	    -re "Remote target $targetname connected to.*$mi_gdb_prompt$" {
		verbose "Set target to $targetname";
		return 0;
	    }
	    -re "Connected to.*$mi_gdb_prompt$" { 
		verbose "Set target to $targetname";
		return 0;
	    }
	    -re "Ending remote.*$mi_gdb_prompt$" { }
	    -re "Connection refused.*$mi_gdb_prompt$" {
		verbose "Connection refused by remote target.  Pausing, and trying again."
		sleep 5
		continue
	    }
	    -re "Timeout reading from remote system.*$mi_gdb_prompt$" {
		verbose "Got timeout error from gdb.";
	    }
	    timeout {
		send_gdb "";
		break
	    }
	}
    }
    return 1
}

d285 1
a285 1
# load a file into the debugger (file command only).
d288 1
a288 1
proc mi_gdb_file_cmd { arg } {
a294 1
    global last_mi_remote_file
a298 5
    } else {
	set last_mi_gdb_file $arg
	if { [ info exists last_mi_remote_file ] } {
	    unset last_mi_remote_file
	}
d301 3
a303 7
    if [is_remote host] {
	set arg [remote_download host $arg];
	if { $arg == "" } {
	    error "download failed"
	    return -1;
	}
    }
d305 1
d312 1
a312 1
            return 0
d341 3
a343 4
            # We (MI) are just giving the prompt back for now, instead of giving
	    # some acknowledgement.
	    return 0
	}
d348 1
a348 1
	eof {
d356 1
a356 19
}

#
# load a file into the debugger.
# return a -1 if anything goes wrong.
#
proc mi_gdb_load { arg } {
    global verbose
    global loadpath
    global loadfile
    global GDB
    global mi_gdb_prompt
    upvar timeout timeout

    # ``gdb_unload''
    if { $arg != "" } {
	mi_gdb_file_cmd $arg
    }

d358 1
a358 20
    if { [info procs gdbserver_gdb_load] != "" } {
	global last_mi_gdb_file
	global last_mi_remote_file

	if { ! [info exists last_mi_remote_file] } {
	    if [is_remote target] {
		set last_mi_remote_file [remote_download target $arg]
	    } else {
		set last_mi_remote_file $last_mi_gdb_file
	    }
	}

	set res [gdbserver_gdb_load $last_mi_remote_file]
	set protocol [lindex $res 0]
	set gdbport [lindex $res 1]

	if { [mi_gdb_target_cmd $protocol $gdbport] != 0 } {
	    return -1
	}
    } elseif { [info procs send_target_sid] != "" } {
@


1.22
log
@2003-04-02  Andrew Cagney  <cagney@@redhat.com>

	* gdb.base/callfuncs.exp: Make "print add" messages unique.
	* gdb.base/ending-run.exp: Put spaces around "breakpoint" to stop
	matching directories by the name breakpoint.
	* gdb.base/pointers.exp: Make "ptype pppC" message consistent.
	Make "continue to marker1" consistent.
	* gdb.base/call-rt-st.exp: Make "finish out from loop_count"
	message consistent.
	* lib/gdb.exp: Put "the program is no longer running", and "the
	program exited" in parenthesis.
	* lib/mi-support.exp: Ditto.
@
text
@d639 1
a639 1
		-re "Continu\[^\r\n\]*\[\r\n\]" {}
@


1.21
log
@Support remote targets.
@
text
@d552 1
a552 1
		set errmsg "$message: the program exited"
d554 1
a554 1
		set errmsg "$command: the program exited"
d561 1
a561 1
		set errmsg "$message: the program is no longer running"
d563 1
a563 1
		set errmsg "$command: the program is no longer running"
@


1.21.2.1
log
@Merge kseitz_interps-20020528-branch.
@
text
@d130 5
a134 5
#	    if { $MIFLAGS == "-i=mi1" } {
#	        perror "(mi startup) Got unexpected new mi prompt."
#	        remote_close host;
#	        return -1;
#	    }
d141 5
a145 5
#	    if { $MIFLAGS != "-i=mi1" } {
#	        perror "(mi startup) Got unexpected old mi prompt."
#	        remote_close host;
#	        return -1;
#	    }
d212 1
a212 1
	 -re ".*102-break-delete\r\n(=.*)*102\\\^done\r\n$mi_gdb_prompt$" {
d714 1
a714 1
    "\(=breakpoint-create,number=\"\[0-9\]+\")\r\n200\\^done" \
@


1.21.2.2
log
@2003-02-03  Andrew Cagney  <ac131313@@redhat.com>

	* top.c (gdb_init): Move interpreter init code from here ...
	* main.c (captured_main): ... to here.  Include "interps.h".
	(captured_main): Set interpreter_p to a default before parsing the
	options.
	* Makefile.in (main.o): Update dependencies.
@
text
@d130 5
a134 5
	    if { $MIFLAGS == "-i=mi1" } {
	        perror "(mi startup) Got unexpected new mi prompt."
	        remote_close host;
	        return -1;
	    }
d141 5
a145 5
	    if { $MIFLAGS != "-i=mi1" } {
	        perror "(mi startup) Got unexpected old mi prompt."
	        remote_close host;
	        return -1;
	    }
@


1.21.2.3
log
@Kill off anything not directly related to the CLI command.
@
text
@d212 1
a212 1
	 -re ".*102-break-delete\r\n102\\\^done\r\n$mi_gdb_prompt$" {
d714 1
a714 1
    "200\\^done,bkpt=\{number=\"\[0-9\]+\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$hex\",func=\"$func\",file=\".*\",line=\"\[0-9\]*\",times=\"0\"\}" \
@


1.20
log
@
2002-12-16  Jeff Johnston  <jjohnstn@@redhat.com>

        * lib/mi-support.exp (mi_reinitialize_dir): Check mi level
        to see whether we are using the new -environment-directory
        command which resets via -r or the old version of the command
        which may prompt the user.  Part of fix for gdb/741.
@
text
@d294 1
d297 6
d395 20
@


1.19
log
@* lib/mi-support.exp (mi_delete_breakpoints): Change name of
function appearing in error message.
@
text
@d237 1
d248 3
a250 2
    send_gdb "104-environment-directory\n"
    gdb_expect 60 {
d261 8
d276 1
a276 1
	-re "105\\\^done\r\n$mi_gdb_prompt$" {
@


1.18
log
@
2002-11-08  Jeff Johnston  <jjohnstn@@redhat.com>

        * lib/mi-support.exp (mi_gdb_start): Verify the startup message
        for mi1 and current mi is in correct format.  New mi startup message
        should be in mi console format.  This is part of fix for PR gdb/604.
@
text
@d215 1
a215 1
	 timeout { perror "Delete all breakpoints in delete_breakpoints (timeout)" ; return }
@


1.17
log
@        * lib/mi-support.exp (mi_runto): New proc. Does the same as gdb's
        runto proc.
        (mi_run_to_main): Use mi_runto.
        (mi_execute_to): Renamed from mi_run_to. Changed all callers.
@
text
@d126 20
a145 1
	-re ".*$mi_gdb_prompt$" {
@


1.17.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d126 1
a126 20
	-re "~\"GNU.*\r\n~\".*$mi_gdb_prompt$" {
	    # We have a new format mi startup prompt.  If we are
	    # running mi1, then this is an error as we should be
	    # using the old-style prompt.
	    if { $MIFLAGS == "-i=mi1" } {
	        perror "(mi startup) Got unexpected new mi prompt."
	        remote_close host;
	        return -1;
	    }
	    verbose "GDB initialized."
	}
	-re "\[^~\].*$mi_gdb_prompt$" {
	    # We have an old format mi startup prompt.  If we are
	    # not running mi1, then this is an error as we should be
	    # using the new-style prompt.
	    if { $MIFLAGS != "-i=mi1" } {
	        perror "(mi startup) Got unexpected old mi prompt."
	        remote_close host;
	        return -1;
	    }
d196 1
a196 1
	 timeout { perror "Delete all breakpoints in mi_delete_breakpoints (timeout)" ; return }
a217 1
    global MIFLAGS
d228 2
a229 3
    if { $MIFLAGS == "-i=mi1" } {
      send_gdb "104-environment-directory\n"
      gdb_expect 60 {
a239 8
      }
    } else {
      send_gdb "104-environment-directory -r\n"
      gdb_expect 60 {
	-re "104\\\^done,source-path=.*\r\n$mi_gdb_prompt$" {}
	-re "$mi_gdb_prompt$" {}
        timeout {error "Dir reinitialization failed (timeout)"}
      }
d247 1
a247 1
	-re "105\\\^done.*\r\n$mi_gdb_prompt$" {
a264 1
    global last_mi_gdb_file
a266 6
    if { $arg == "" } {
	set arg $last_mi_gdb_file;
    }

    set last_mi_gdb_file $arg;

a361 20
    } elseif { [target_info gdb_protocol] == "remote" } {
	# remote targets
	send_gdb "target [target_info gdb_protocol] [target_info netport]\n"
	gdb_expect 60 {
	    -re "\\^done,.*$mi_gdb_prompt$" {
	    }
	    timeout {
		perror "Unable to connect to remote target"
		return -1
	    }
	}
	send_gdb "48-target-download\n"
	gdb_expect 10 {
	    -re "48\\^done.*$mi_gdb_prompt$" {
	    }
	    timeout {
		perror "Unable to download to remote target"
		return -1
	    }
	}
d496 1
a496 1
		set errmsg "$message (the program exited)"
d498 1
a498 1
		set errmsg "$command (the program exited)"
d505 1
a505 1
		set errmsg "$message (the program is no longer running)"
d507 1
a507 1
		set errmsg "$command (the program is no longer running)"
d583 1
a583 1
		-re "000\\^running\[\r\n\]+$mi_gdb_prompt$" {}
@


1.17.4.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d1 1
a1 1
# Copyright 1999, 2000, 2002, 2003, 2004 Free Software Foundation, Inc.
a283 50
# Send GDB the "target" command.
# FIXME: Some of these patterns are not appropriate for MI.  Based on
# config/monitor.exp:gdb_target_command.
proc mi_gdb_target_cmd { targetname serialport } {
    global mi_gdb_prompt

    for {set i 1} {$i <= 3} {incr i} {
	send_gdb "47-target-select $targetname $serialport\n"
	gdb_expect 60 {
	    -re "47\\^connected.*$mi_gdb_prompt$" {
		verbose "Set target to $targetname";
		return 0;
	    }
	    -re "Couldn't establish connection to remote.*$mi_gdb_prompt$" {
		verbose "Connection failed";
	    }
	    -re "Remote MIPS debugging.*$mi_gdb_prompt$" {
		verbose "Set target to $targetname";
		return 0;
	    }
	    -re "Remote debugging using .*$serialport.*$mi_gdb_prompt$" {
		verbose "Set target to $targetname";
		return 0;
	    }
	    -re "Remote target $targetname connected to.*$mi_gdb_prompt$" {
		verbose "Set target to $targetname";
		return 0;
	    }
	    -re "Connected to.*$mi_gdb_prompt$" { 
		verbose "Set target to $targetname";
		return 0;
	    }
	    -re "Ending remote.*$mi_gdb_prompt$" { }
	    -re "Connection refused.*$mi_gdb_prompt$" {
		verbose "Connection refused by remote target.  Pausing, and trying again."
		sleep 5
		continue
	    }
	    -re "Timeout reading from remote system.*$mi_gdb_prompt$" {
		verbose "Got timeout error from gdb.";
	    }
	    timeout {
		send_gdb "";
		break
	    }
	}
    }
    return 1
}

d285 1
a285 1
# load a file into the debugger (file command only).
d288 1
a288 1
proc mi_gdb_file_cmd { arg } {
a294 1
    global last_mi_remote_file
a298 5
    } else {
	set last_mi_gdb_file $arg
	if { [ info exists last_mi_remote_file ] } {
	    unset last_mi_remote_file
	}
d301 3
a303 7
    if [is_remote host] {
	set arg [remote_download host $arg];
	if { $arg == "" } {
	    error "download failed"
	    return -1;
	}
    }
d305 1
d312 1
a312 1
            return 0
d341 3
a343 4
            # We (MI) are just giving the prompt back for now, instead of giving
	    # some acknowledgement.
	    return 0
	}
d348 1
a348 1
	eof {
d356 1
a356 19
}

#
# load a file into the debugger.
# return a -1 if anything goes wrong.
#
proc mi_gdb_load { arg } {
    global verbose
    global loadpath
    global loadfile
    global GDB
    global mi_gdb_prompt
    upvar timeout timeout

    # ``gdb_unload''
    if { $arg != "" } {
	mi_gdb_file_cmd $arg
    }

d358 1
a358 20
    if { [info procs gdbserver_gdb_load] != "" } {
	global last_mi_gdb_file
	global last_mi_remote_file

	if { ! [info exists last_mi_remote_file] } {
	    if [is_remote target] {
		set last_mi_remote_file [remote_download target $arg]
	    } else {
		set last_mi_remote_file $last_mi_gdb_file
	    }
	}

	set res [gdbserver_gdb_load $last_mi_remote_file]
	set protocol [lindex $res 0]
	set gdbport [lindex $res 1]

	if { [mi_gdb_target_cmd $protocol $gdbport] != 0 } {
	    return -1
	}
    } elseif { [info procs send_target_sid] != "" } {
@


1.17.2.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d126 1
a126 20
	-re "~\"GNU.*\r\n~\".*$mi_gdb_prompt$" {
	    # We have a new format mi startup prompt.  If we are
	    # running mi1, then this is an error as we should be
	    # using the old-style prompt.
	    if { $MIFLAGS == "-i=mi1" } {
	        perror "(mi startup) Got unexpected new mi prompt."
	        remote_close host;
	        return -1;
	    }
	    verbose "GDB initialized."
	}
	-re "\[^~\].*$mi_gdb_prompt$" {
	    # We have an old format mi startup prompt.  If we are
	    # not running mi1, then this is an error as we should be
	    # using the new-style prompt.
	    if { $MIFLAGS != "-i=mi1" } {
	        perror "(mi startup) Got unexpected old mi prompt."
	        remote_close host;
	        return -1;
	    }
@


1.17.2.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d215 1
a215 1
	 timeout { perror "Delete all breakpoints in mi_delete_breakpoints (timeout)" ; return }
a236 1
    global MIFLAGS
d247 2
a248 3
    if { $MIFLAGS == "-i=mi1" } {
      send_gdb "104-environment-directory\n"
      gdb_expect 60 {
a258 8
      }
    } else {
      send_gdb "104-environment-directory -r\n"
      gdb_expect 60 {
	-re "104\\\^done,source-path=.*\r\n$mi_gdb_prompt$" {}
	-re "$mi_gdb_prompt$" {}
        timeout {error "Dir reinitialization failed (timeout)"}
      }
d266 1
a266 1
	-re "105\\\^done.*\r\n$mi_gdb_prompt$" {
@


1.17.2.3
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@a293 1
    global last_mi_gdb_file
a295 6
    if { $arg == "" } {
	set arg $last_mi_gdb_file;
    }

    set last_mi_gdb_file $arg;

a387 20
		return -1
	    }
	}
    } elseif { [target_info gdb_protocol] == "remote" } {
	# remote targets
	send_gdb "target [target_info gdb_protocol] [target_info netport]\n"
	gdb_expect 60 {
	    -re "\\^done,.*$mi_gdb_prompt$" {
	    }
	    timeout {
		perror "Unable to connect to remote target"
		return -1
	    }
	}
	send_gdb "48-target-download\n"
	gdb_expect 10 {
	    -re "48\\^done.*$mi_gdb_prompt$" {
	    }
	    timeout {
		perror "Unable to download to remote target"
@


1.17.2.4
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d552 1
a552 1
		set errmsg "$message (the program exited)"
d554 1
a554 1
		set errmsg "$command (the program exited)"
d561 1
a561 1
		set errmsg "$message (the program is no longer running)"
d563 1
a563 1
		set errmsg "$command (the program is no longer running)"
@


1.17.2.5
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d639 1
a639 1
		-re "000\\^running\[\r\n\]+$mi_gdb_prompt$" {}
@


1.17.2.6
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d1 1
a1 1
# Copyright 1999, 2000, 2002, 2003, 2004 Free Software Foundation, Inc.
a283 50
# Send GDB the "target" command.
# FIXME: Some of these patterns are not appropriate for MI.  Based on
# config/monitor.exp:gdb_target_command.
proc mi_gdb_target_cmd { targetname serialport } {
    global mi_gdb_prompt

    for {set i 1} {$i <= 3} {incr i} {
	send_gdb "47-target-select $targetname $serialport\n"
	gdb_expect 60 {
	    -re "47\\^connected.*$mi_gdb_prompt$" {
		verbose "Set target to $targetname";
		return 0;
	    }
	    -re "Couldn't establish connection to remote.*$mi_gdb_prompt$" {
		verbose "Connection failed";
	    }
	    -re "Remote MIPS debugging.*$mi_gdb_prompt$" {
		verbose "Set target to $targetname";
		return 0;
	    }
	    -re "Remote debugging using .*$serialport.*$mi_gdb_prompt$" {
		verbose "Set target to $targetname";
		return 0;
	    }
	    -re "Remote target $targetname connected to.*$mi_gdb_prompt$" {
		verbose "Set target to $targetname";
		return 0;
	    }
	    -re "Connected to.*$mi_gdb_prompt$" { 
		verbose "Set target to $targetname";
		return 0;
	    }
	    -re "Ending remote.*$mi_gdb_prompt$" { }
	    -re "Connection refused.*$mi_gdb_prompt$" {
		verbose "Connection refused by remote target.  Pausing, and trying again."
		sleep 5
		continue
	    }
	    -re "Timeout reading from remote system.*$mi_gdb_prompt$" {
		verbose "Got timeout error from gdb.";
	    }
	    timeout {
		send_gdb "";
		break
	    }
	}
    }
    return 1
}

d285 1
a285 1
# load a file into the debugger (file command only).
d288 1
a288 1
proc mi_gdb_file_cmd { arg } {
a294 1
    global last_mi_remote_file
a298 5
    } else {
	set last_mi_gdb_file $arg
	if { [ info exists last_mi_remote_file ] } {
	    unset last_mi_remote_file
	}
d301 3
a303 7
    if [is_remote host] {
	set arg [remote_download host $arg];
	if { $arg == "" } {
	    error "download failed"
	    return -1;
	}
    }
d305 1
d312 1
a312 1
            return 0
d341 3
a343 4
            # We (MI) are just giving the prompt back for now, instead of giving
	    # some acknowledgement.
	    return 0
	}
d348 1
a348 1
	eof {
d356 1
a356 19
}

#
# load a file into the debugger.
# return a -1 if anything goes wrong.
#
proc mi_gdb_load { arg } {
    global verbose
    global loadpath
    global loadfile
    global GDB
    global mi_gdb_prompt
    upvar timeout timeout

    # ``gdb_unload''
    if { $arg != "" } {
	mi_gdb_file_cmd $arg
    }

d358 1
a358 20
    if { [info procs gdbserver_gdb_load] != "" } {
	global last_mi_gdb_file
	global last_mi_remote_file

	if { ! [info exists last_mi_remote_file] } {
	    if [is_remote target] {
		set last_mi_remote_file [remote_download target $arg]
	    } else {
		set last_mi_remote_file $last_mi_gdb_file
	    }
	}

	set res [gdbserver_gdb_load $last_mi_remote_file]
	set protocol [lindex $res 0]
	set gdbport [lindex $res 1]

	if { [mi_gdb_target_cmd $protocol $gdbport] != 0 } {
	    return -1
	}
    } elseif { [info procs send_target_sid] != "" } {
@


1.16
log
@        * lib/mi-support.exp: (mi_run_to_main): Allow anything to precede
        regexp for stopping at main. Could have multiple event notifications.
        Don't assume that main was declared with no parameters.
        (mi_next): Use mi_step_to.
        (mi_step): Use mi_next_to.
@
text
@a623 3
    global mi_gdb_prompt
    global hex
    global decimal
a628 1
    set test "mi run-to-main"
d633 3
a635 3
    mi_gdb_test "200-break-insert main" \
	    "200\\^done,bkpt=\{number=\"1\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$hex\",func=\"main\",file=\".*\",line=\"\[0-9\]*\",times=\"0\"\}" \
	    "breakpoint at main"
d637 41
a677 13
    mi_run_cmd
    gdb_expect {
	-re "000\\*stopped,reason=\"breakpoint-hit\",bkptno=\"1\",thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\"main\",args=\(\\\[\\\]\|\{\}\),file=\".*\",line=\"\[0-9\]*\"\}\r\n$mi_gdb_prompt$" {
	    pass "$test"
	    return 0
	}
	-re ".*$mi_gdb_prompt$" {
	    fail "$test (2)"
	}
	timeout {
	    fail "$test (timeout)"
	    return -1
	}
d679 1
d684 1
a684 1
# For return values, see mi_run_to_helper
d692 1
a692 1
# For return values, see mi_run_to_helper
d704 1
a704 1
proc mi_run_to_helper { cmd reason func args file line extra test } {
d733 2
a734 2
proc mi_run_to { cmd reason func args file line extra test } {
    mi_run_to_helper "$cmd" "$reason" "$func" "\\\[$args\\\]" \
d739 1
a739 1
    mi_run_to "exec-next" "end-stepping-range" "$func" "$args" \
d744 1
a744 1
    mi_run_to "exec-step" "end-stepping-range" "$func" "$args" \
d749 1
a749 1
    mi_run_to "exec-finish" "function-finished" "$func" "$args" \
d756 1
a756 1
    mi_run_to "exec-continue" "breakpoint-hit\",bkptno=\"$bkptno" \
d760 2
a761 2
proc mi0_run_to { cmd reason func args file line extra test } {
    mi_run_to_helper "$cmd" "$reason" "$func" "\{$args\}" \
d766 1
a766 1
    mi0_run_to "exec-next" "end-stepping-range" "$func" "$args" \
d771 1
a771 1
    mi0_run_to "exec-step" "end-stepping-range" "$func" "$args" \
d776 1
a776 1
    mi0_run_to "exec-finish" "function-finished" "$func" "$args" \
d783 1
a783 1
    mi0_run_to "exec-continue" "breakpoint-hit\",bkptno=\"$bkptno" \
@


1.15
log
@        * lib/mi-support.exp: Update copyright.
        (mi_gdb_test): Increase the priority of the expected pattern
        so that it matches gdb_test.
@
text
@d659 1
d662 1
a662 16
    global suppress_flag
    if { $suppress_flag } {
	return -1
    }
    global mi_gdb_prompt
    send_gdb "220-exec-next\n"
    gdb_expect {
	-re "220\\^running\r\n${mi_gdb_prompt}220\\*stopped,reason=\"end-stepping-range\",thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\".*\",args=\[\\\[\{].*[\\\]\}\],file=\".*\",line=\"\[0-9\]*\"\}\r\n$mi_gdb_prompt$" {
	    pass "$test"
	    return 0
	}
	timeout {
	    fail "$test"
	    return -1
	}
    }
d667 1
d670 1
a670 16
    global suppress_flag
    if { $suppress_flag } {
	return -1
    }
    global mi_gdb_prompt
    send_gdb "220-exec-step\n"
    gdb_expect {
	-re "220\\^running\r\n${mi_gdb_prompt}220\\*stopped,reason=\"end-stepping-range\",thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\".*\",args=\[\\\[\{\].*\[\\\]\}\],file=\".*\",line=\"\[0-9\]*\"\}\r\n$mi_gdb_prompt$" {
	    pass "$test"
	    return 0
	}
	timeout {
	    fail "$test"
	    return -1
	}
    }
d689 1
a689 1
	-re "220\\^running\r\n${mi_gdb_prompt}220\\*stopped,reason=\"$reason\",thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\"$func\",args=$args,file=\".*$file\",line=\"$line\"\}$extra\r\n$mi_gdb_prompt$" {
d693 1
a693 1
	-re "220\\^running\r\n${mi_gdb_prompt}220\\*stopped,reason=\"$reason\",thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\".*\",args=\[\\\[\{\].*\[\\\]\}\],file=\".*\",line=\"\[0-9\]*\"\}.*\r\n$mi_gdb_prompt$" {
@


1.14
log
@        * lib/mi-support.exp (mi_gdb_test): Add global declaration for
        expect_out so that callers can get at it.
@
text
@d1 1
a1 1
# Copyright 1999, 2000 Free Software Foundation, Inc.
d474 6
a492 6
	}
	 -re "\[\r\n\]*($pattern)\[\r\n\]+$mi_gdb_prompt\[ \]*$" {
	    if ![string match "" $message] then {
		pass "$message"
	    }
	    set result 0
@


1.13
log
@        * lib/mi-support.exp (mi_run_to_helper): Move comments
        outside of gdb_expect.
@
text
@d385 1
a385 1
    global GDB
@


1.13.8.1
log
@        * lib/mi-support.exp (mi_run_to_main): Use MIFLAGS to figure
        out what version of MI is running. Use this to determine the proper
        output of setting a breakpoint.
@
text
@a630 1
    global MIFLAGS
a636 9
    set version 2
    scan $MIFLAGS "\-i=mi%d" version
    if {$version < 2} {
      # MI0 or MI1
      set bp_result "200\\^done,bkpt=\{number=\"1\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$hex\",func=\"main\",file=\".*\",line=\"\[0-9\]*\",times=\"0\"\}"
    } else {
      # MI2+
      set bp_result "=breakpoint-create,number=\"1\"\r\n200\\^done"
    }
d638 1
a638 1
	$bp_result \
d717 1
a717 1
	-re ".*220\\^running\r\n${mi_gdb_prompt}.*220\\*stopped,reason=\"$reason\",thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\"$func\",args=$args,file=\".*$file\",line=\"$line\"\}$extra\r\n$mi_gdb_prompt$" {
d721 1
a721 1
	-re ".*220\\^running\r\n${mi_gdb_prompt}.*220\\*stopped,reason=\"$reason\",thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\".*\",args=\[\\\[\{\].*\[\\\]\}\],file=\".*\",line=\"\[0-9\]*\"\}.*\r\n$mi_gdb_prompt$" {
@


1.13.8.2
log
@        * lib/mi-support.exp (mi_gdb_test): Move expected pattern higher
        in the list of expect statements.
@
text
@a473 6
	 -re "\[\r\n\]*($pattern)\[\r\n\]+$mi_gdb_prompt\[ \]*$" {
	    if ![string match "" $message] then {
		pass "$message"
	    }
	    set result 0
	}
d487 6
@


1.13.8.3
log
@        * lib/mi-support.exp (mi_delete_breakpoints): Allow for breakpoint
        delete events in output of -break-delete.
        (mi_run_to_main): Don't assume that breakpoint at main is first
        breakpoint installed.
@
text
@d193 1
a193 1
	 -re ".*102-break-delete\r\n(=.*)*102\\\^done\r\n$mi_gdb_prompt$" {
d642 1
a642 1
	set bp_result "200\\^done,bkpt=\{number=\"\[0-9\]+\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$hex\",func=\"main\",file=\".*\",line=\"\[0-9\]*\",times=\"0\"\}"
d645 1
a645 1
	set bp_result "=breakpoint-create,number=\"\[0-9\]\"\r\n200\\^done"
d653 1
a653 1
	-re "000\\*stopped,reason=\"breakpoint-hit\",bkptno=\"\[0-9\]+\",thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\"main\",args=\(\\\[\\\]\|\{\}\),file=\".*\",line=\"\[0-9\]*\"\}\r\n$mi_gdb_prompt$" {
@


1.13.8.4
log
@        * lib/mi-support.exp (mi_gdb_test): Add global declaration for
        expect_out so that callers can get at it.
@
text
@d385 1
a385 1
    global GDB expect_out
@


1.13.8.5
log
@        * lib/mi-support.exp (mi_run_to_main): Allow anything to precede
        regexp for stopping at main. Could have multiple event notifications.
        Don't assume that main was declared with no parameters.
        (mi_step_next_helper): New procedure to do step/next.
        (mi_next): Use mi_step_next_helper.
        (mi_step): Ditto.
@
text
@d1 1
a1 1
# Copyright 1999, 2000, 2002 Free Software Foundation, Inc.
d653 1
a653 1
      -re ".*000\\*stopped,reason=\"breakpoint-hit\",bkptno=\"\[0-9\]+\",thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\"main\",args=\(\\\[.*\\\]\|\{.*\}\),file=\".*\",line=\"\[0-9\]*\"\}\r\n$mi_gdb_prompt$" {
a667 26
# Helper function for mi_next and mi_step
# CMD is either "step" or "next"
# TEST is the name of the test (passed to dejagnu's pass/fail)
# Returns:
#     0  if passed
#     1  if failed/timeout
proc mi_step_next_helper {cmd test} {
  global suppress_flag
  if { $suppress_flag } {
    return 1
  }

  global mi_gdb_prompt decimal hex
  send_gdb "220-exec-$cmd\n"
  gdb_expect {
    -re ".*220\\^running\r\n$mi_gdb_prompt.*220\\*stopped,reason=\"end-stepping-range\",thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\".*\",args=\(\\\[.*\\\]\|\{.*\}\),file=\".*\",line=\"$decimal\"\}\r\n$mi_gdb_prompt$" {
      pass "$test"
      return 0
    }
    timeout {
      fail "$test"
      return 1
    }
  }
}

a668 1
# For return values, see mi_step_next_helper
d671 16
a686 1
  return [mi_step_next_helper next $test]
a690 1
# For return values, see mi_step_next_helper
d693 16
a708 1
  return [mi_step_next_helper step $test]
@


1.13.8.6
log
@        * lib/mi-support.exp (mi_runto): New proc. Does the same as gdb's
        runto proc.
        (mi_run_to_main): Use mi_runto.
@
text
@d624 3
d631 1
d633 1
d638 8
a645 47
    mi_runto main
}

# Just like gdb's "runto" proc, it will run the target to a given
# function.
# FUNC is the linespec of the place to stop (it inserts a breakpoint here).
# It returns:
#   -1  if test suppressed, failed, timedout
#    0  if test passed

proc mi_runto {func} {
  global suppress_flag
  if { $suppress_flag } {
    return -1
  }

  global mi_gdb_prompt expect_out
  global hex decimal
  global MIFLAGS

  set test "mi runto $func"
  set version 2
  scan $MIFLAGS "\-i=mi%d" version
  if {$version < 2} {
    # MI0 or MI1
    set bp_result "200\\^done,bkpt=\{number=\"\[0-9\]+\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$hex\",func=\"$func\",file=\".*\",line=\"\[0-9\]*\",times=\"0\"\}"
  } else {
    # MI2+
    set bp_result "=breakpoint-create,number=\"\[0-9\]\"\r\n200\\^done"
  }
  mi_gdb_test "200-break-insert $func" \
    $bp_result \
    "breakpoint at $func"

  if {![regexp {number="[0-9]+"} $expect_out(buffer) str]
      || ![scan $str {number="%d"} bkptno]} {
    set bkptno {[0-9]+}
  }

  mi_run_cmd
  gdb_expect {
    -re ".*000\\*stopped,reason=\"breakpoint-hit\",bkptno=\"$bkptno\",thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\"$func\",args=\(\\\[.*\\\]\|\{.*\}\),file=\".*\",line=\"\[0-9\]*\"\}\r\n$mi_gdb_prompt$" {
      pass "$test"
      return 0
    }
    -re ".*$mi_gdb_prompt$" {
      fail "$test (2)"
d647 17
a663 3
    timeout {
      fail "$test (timeout)"
      return -1
a664 1
  }
@


1.13.8.7
log
@        * lib/mi-support.exp (mi_step_next_helper): Remove.
        (mi_next): Use mi_next_to.
        (mi_step): Use mi_step_to.
@
text
@d689 26
d716 1
a716 1
# For return values, see mi_run_to_helper
d719 1
a719 1
  return [mi_next_to {.*} {.*} {.*} {.*} $test]
d724 1
a724 1
# For return values, see mi_run_to_helper
d727 1
a727 1
  return [mi_step_to {.*} {.*} {.*} {.*} $test]
@


1.13.8.8
log
@Merge with kseitz_interps-20020930-merge.
@
text
@a635 1

d637 1
a637 4
# function.  The big difference here between mi_runto and mi_execute_to
# is that mi_execute_to must have the inferior running already.  This
# proc will (like gdb's runto) (re)start the inferior, too.
#
d651 1
d654 9
d664 1
a664 1
    "\(=breakpoint-create,number=\"\[0-9\]+\")\r\n200\\^done" \
d690 1
a690 1
# For return values, see mi_execute_to_helper
d698 1
a698 1
# For return values, see mi_execute_to_helper
d710 1
a710 1
proc mi_execute_to_helper { cmd reason func args file line extra test } {
d739 2
a740 2
proc mi_execute_to { cmd reason func args file line extra test } {
    mi_execute_to_helper "$cmd" "$reason" "$func" "\\\[$args\\\]" \
d745 1
a745 1
    mi_execute_to "exec-next" "end-stepping-range" "$func" "$args" \
d750 1
a750 1
    mi_execute_to "exec-step" "end-stepping-range" "$func" "$args" \
d755 1
a755 1
    mi_execute_to "exec-finish" "function-finished" "$func" "$args" \
d762 1
a762 1
    mi_execute_to "exec-continue" "breakpoint-hit\",bkptno=\"$bkptno" \
d766 2
a767 2
proc mi0_execute_to { cmd reason func args file line extra test } {
    mi_execute_to_helper "$cmd" "$reason" "$func" "\{$args\}" \
d772 1
a772 1
    mi0_execute_to "exec-next" "end-stepping-range" "$func" "$args" \
d777 1
a777 1
    mi0_execute_to "exec-step" "end-stepping-range" "$func" "$args" \
d782 1
a782 1
    mi0_execute_to "exec-finish" "function-finished" "$func" "$args" \
d789 1
a789 1
    mi0_execute_to "exec-continue" "breakpoint-hit\",bkptno=\"$bkptno" \
@


1.12
log
@        * lib/mi-support.exp: (mi_run_to_helper, mi_run_to,
        mi_step_to, mi_next_to, mi_continue_to, mi_finish_to,
        mi0_step_to, mi0_next_to, mi0_continue_to, mi0_finish_to,
        mi0_run_to): New functions.
        * gdb.mi/mi-simplerun.exp: Use them.
        * gdb.mi/mi0-simplerun.exp: Likewise.
        * gdb.mi/mi-var-cmd.exp: Likewise.
        * gdb.mi/mi0-var-cmd.exp: Likewise.
@
text
@d704 3
a728 6
# Can not check for this, because of false positives after half of a running
# prompt.
#	-re ".*\r\n${mi_gdb_prompt}" {
#	    fail "$test (unknown output)"
#	    return -1
#	}
@


1.11
log
@Don't print ``(MI_OUT)'' at startup.
@
text
@d668 1
a668 1
	-re "220\\^running\r\n${mi_gdb_prompt}220\\*stopped,reason=\"end-stepping-range\",thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\".*\",args=\[\\\[\{].*[\\\]\}\],,file=\".*\",line=\"\[0-9\]*\"\}\r\n$mi_gdb_prompt$" {
d690 1
a690 1
	-re "220\\^running\r\n${mi_gdb_prompt}220\\*stopped,reason=\"end-stepping-range\",thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\".*\",args=\[\\\[\{\].*\[\\\]\}\],,file=\".*\",line=\"\[0-9\]*\"\}\r\n$mi_gdb_prompt$" {
d699 92
@


1.10
log
@* lib/mi-support.exp (mi_gdb_start): If a remote target, use the
CLI jump command to start it.
(mi_run_to_main): Fail immediatly when unexpected output.
@
text
@d126 1
a126 1
	-re ".*MI_OUT.*$mi_gdb_prompt$" {
a127 5
	}
	-re ".*$mi_gdb_prompt$" {
	    untested "Skip mi tests (output not in headless format)."
	    remote_close host;
	    return -1;
@


1.9
log
@* lib/mi-support.exp (mi_gdb_start): Move call to sid_start to
beginning of function.  Fix PR gdb/191.
@
text
@d593 12
d651 3
@


1.8
log
@For MI>0, output full breakpoint table header information.  Output the
breakpoint table body as a list.
@
text
@d102 6
a176 6
    }

    # Finally start SID.
    if { [info procs sid_start] != "" } {
	verbose "Spawning SID"
	sid_start
@


1.8.4.1
log
@Don't print ``(MI_OUT)'' during startup.
@
text
@d120 3
d124 3
a126 1
	    verbose "GDB initialized."
@


1.8.4.2
log
@        * lib/mi-support.exp: (mi_run_to_helper, mi_run_to,
        mi_step_to, mi_next_to, mi_continue_to, mi_finish_to,
        mi0_step_to, mi0_next_to, mi0_continue_to, mi0_finish_to,
        mi0_run_to): New functions.
        * gdb.mi/mi-simplerun.exp: Use them.
        * gdb.mi/mi0-simplerun.exp: Likewise.
        * gdb.mi/mi-var-cmd.exp: Likewise.
        * gdb.mi/mi0-var-cmd.exp: Likewise.
@
text
@d653 1
a653 1
	-re "220\\^running\r\n${mi_gdb_prompt}220\\*stopped,reason=\"end-stepping-range\",thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\".*\",args=\[\\\[\{].*[\\\]\}\],file=\".*\",line=\"\[0-9\]*\"\}\r\n$mi_gdb_prompt$" {
d675 1
a675 1
	-re "220\\^running\r\n${mi_gdb_prompt}220\\*stopped,reason=\"end-stepping-range\",thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\".*\",args=\[\\\[\{\].*\[\\\]\}\],file=\".*\",line=\"\[0-9\]*\"\}\r\n$mi_gdb_prompt$" {
a683 92
}

# cmd should not include the number or newline (i.e. "exec-step 3", not
# "220-exec-step 3\n"

proc mi_run_to_helper { cmd reason func args file line extra test } {
    global suppress_flag
    if { $suppress_flag } {
	return -1
    }
    global mi_gdb_prompt
    global hex
    global decimal
    send_gdb "220-$cmd\n"
    gdb_expect {
	-re "220\\^running\r\n${mi_gdb_prompt}220\\*stopped,reason=\"$reason\",thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\"$func\",args=$args,file=\".*$file\",line=\"$line\"\}$extra\r\n$mi_gdb_prompt$" {
	    pass "$test"
	    return 0
	}
	-re "220\\^running\r\n${mi_gdb_prompt}220\\*stopped,reason=\"$reason\",thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\".*\",args=\[\\\[\{\].*\[\\\]\}\],file=\".*\",line=\"\[0-9\]*\"\}.*\r\n$mi_gdb_prompt$" {
	    fail "$test (stopped at wrong place)"
	    return -1
	}
	-re "220\\^running\r\n${mi_gdb_prompt}.*\r\n${mi_gdb_prompt}$" {
	    fail "$test (unknown output after running)"
	    return -1
	}
# Can not check for this, because of false positives after half of a running
# prompt.
#	-re ".*\r\n${mi_gdb_prompt}" {
#	    fail "$test (unknown output)"
#	    return -1
#	}
	timeout {
	    fail "$test (timeout)"
	    return -1
	}
    }
}

proc mi_run_to { cmd reason func args file line extra test } {
    mi_run_to_helper "$cmd" "$reason" "$func" "\\\[$args\\\]" \
	"$file" "$line" "$extra" "$test"
}

proc mi_next_to { func args file line test } {
    mi_run_to "exec-next" "end-stepping-range" "$func" "$args" \
	"$file" "$line" "" "$test"
}

proc mi_step_to { func args file line test } {
    mi_run_to "exec-step" "end-stepping-range" "$func" "$args" \
	"$file" "$line" "" "$test"
}

proc mi_finish_to { func args file line result ret test } {
    mi_run_to "exec-finish" "function-finished" "$func" "$args" \
	"$file" "$line" \
	",gdb-result-var=\"$result\",return-value=\"$ret\"" \
	"$test"
}

proc mi_continue_to { bkptno func args file line test } {
    mi_run_to "exec-continue" "breakpoint-hit\",bkptno=\"$bkptno" \
	"$func" "$args" "$file" "$line" "" "$test"
}

proc mi0_run_to { cmd reason func args file line extra test } {
    mi_run_to_helper "$cmd" "$reason" "$func" "\{$args\}" \
	"$file" "$line" "$extra" "$test"
}

proc mi0_next_to { func args file line test } {
    mi0_run_to "exec-next" "end-stepping-range" "$func" "$args" \
	"$file" "$line" "" "$test"
}

proc mi0_step_to { func args file line test } {
    mi0_run_to "exec-step" "end-stepping-range" "$func" "$args" \
	"$file" "$line" "" "$test"
}

proc mi0_finish_to { func args file line result ret test } {
    mi0_run_to "exec-finish" "function-finished" "$func" "$args" \
	"$file" "$line" \
	",gdb-result-var=\"$result\",return-value=\"$ret\"" \
	"$test"
}

proc mi0_continue_to { bkptno func args file line test } {
    mi0_run_to "exec-continue" "breakpoint-hit\",bkptno=\"$bkptno" \
	"$func" "$args" "$file" "$line" "" "$test"
@


1.8.4.3
log
@        * lib/mi-support.exp (mi_run_to_helper): Move comments
        outside of gdb_expect.
@
text
@a688 3
# Can not match -re ".*\r\n${mi_gdb_prompt}", because of false positives
# after the first prompt is printed.

d711 6
@


1.7
log
@* stack.c (print_frame): For ui_out, output a list of arguments.
Update all tests.  Update doco.
@
text
@d209 1
@


1.6
log
@Rename gdb.mi/ChangeLog-mi to gdb.mi/ChangeLog.  Update everything.
@
text
@d635 1
a635 1
	-re "000\\*stopped,reason=\"breakpoint-hit\",bkptno=\"1\",thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\"main\",args=\{\},file=\".*\",line=\"\[0-9\]*\"\}\r\n$mi_gdb_prompt$" {
d657 1
a657 1
	-re "220\\^running\r\n${mi_gdb_prompt}220\\*stopped,reason=\"end-stepping-range\",thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\".*\",args=\{.*\},,file=\".*\",line=\"\[0-9\]*\"\}\r\n$mi_gdb_prompt$" {
d679 1
a679 1
	-re "220\\^running\r\n${mi_gdb_prompt}220\\*stopped,reason=\"end-stepping-range\",thread-id=\"$decimal\",frame=\{addr=\"$hex\",func=\".*\",args=\{.*\},,file=\".*\",line=\"\[0-9\]*\"\}\r\n$mi_gdb_prompt$" {
@


1.5
log
@Update/correct copyright notices.
@
text
@a688 5


# Local variables: 
# change-log-default-name: "../gdb.mi/ChangeLog-mi"
# End: 
@


1.4
log
@* mi-support.exp (mi_gdb_start): Skip mi tests if -i flag is
recognized (i.e. if GDB was compiled with UI_OUT, but the mi
interpreter wasn't recognized (because it wasn't compiled in).
@
text
@d1 1
a1 1
# Copyright (C) 1999, 2000 Free Software Foundation, Inc.
@


1.3
log
@2000-12-20  Fernando Nasser  <fnasser@@redhat.com>

        * Makefile.in (UIOUT_CFLAGS): New macro. CFLAGS needed for uiout code
        to be compiled.  Defines UI_OUT.
        (SUBDIR_MI_CFLAGS): Defines MI_OUT, not UI_OUT.
        (INTERNAL_WARN_CFLAGS): Also include UIOUT_CFLAGS.
        * configure.in (UIOUT_CFLAGS): New configuration variable.
        (--with-uiout): New configuration option.  Causes uiout code to
        be compiled, instead of the old *printf one.
        * configure: Regenerate.
        * top.c (print_gdb_version): Test for and print MI_OUT, not UI_OUT.
        * testsuite/lib/mi-support.exp (mi_gdb_start): Test for MI_OUT,
        not UI_OUT.
@
text
@d138 5
@


1.2
log
@When GDB doesn't recognize the -i=mi option, assume there is no MI support.
@
text
@d120 1
a120 1
	-re ".*UI_OUT.*$mi_gdb_prompt$" {
@


1.1
log
@Add mi/ and testsuite/gdb.mi/ subdirectories.
Add --enable-gdbmi option to configury.
Add mi rules to Makefile.in
Add mi conditional output to event-top.c infrun.c main.c top.c.
Add -i=mi option.
@
text
@d133 5
@

