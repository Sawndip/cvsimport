head	1.23;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.21
	gdb_7_6-2013-04-26-release:1.21
	gdb_7_6-branch:1.21.0.2
	gdb_7_6-2013-03-12-branchpoint:1.21
	gdb_7_5_1-2012-11-29-release:1.20
	gdb_7_5-2012-08-17-release:1.20
	gdb_7_5-branch:1.20.0.2
	gdb_7_5-2012-07-18-branchpoint:1.20
	gdb_7_4_1-2012-04-26-release:1.11.2.1
	gdb_7_4-2012-01-24-release:1.11.2.1
	gdb_7_4-branch:1.11.0.2
	gdb_7_4-2011-12-13-branchpoint:1.11
	gdb_7_3_1-2011-09-04-release:1.8
	gdb_7_3-2011-07-26-release:1.8
	gdb_7_3-branch:1.8.0.2
	gdb_7_3-2011-04-01-branchpoint:1.8;
locks; strict;
comment	@# @;


1.23
date	2013.03.15.01.41.29;	author qiyao;	state Exp;
branches;
next	1.22;

1.22
date	2013.03.14.13.34.06;	author qiyao;	state Exp;
branches;
next	1.21;

1.21
date	2013.01.01.06.41.28;	author brobecke;	state Exp;
branches;
next	1.20;

1.20
date	2012.06.26.18.25.19;	author tromey;	state Exp;
branches;
next	1.19;

1.19
date	2012.05.25.21.54.16;	author macro;	state Exp;
branches;
next	1.18;

1.18
date	2012.04.03.14.39.55;	author jkratoch;	state Exp;
branches;
next	1.17;

1.17
date	2012.03.01.20.49.02;	author palves;	state Exp;
branches;
next	1.16;

1.16
date	2012.02.21.22.58.39;	author palves;	state Exp;
branches;
next	1.15;

1.15
date	2012.02.21.22.01.09;	author palves;	state Exp;
branches;
next	1.14;

1.14
date	2012.02.21.21.55.39;	author palves;	state Exp;
branches;
next	1.13;

1.13
date	2012.02.15.18.09.20;	author palves;	state Exp;
branches;
next	1.12;

1.12
date	2012.01.04.08.27.56;	author brobecke;	state Exp;
branches;
next	1.11;

1.11
date	2011.09.08.17.40.54;	author jkratoch;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2011.08.26.09.20.44;	author jkratoch;	state Exp;
branches;
next	1.9;

1.9
date	2011.08.05.15.17.59;	author palves;	state Exp;
branches;
next	1.8;

1.8
date	2011.03.18.18.51.08;	author palves;	state Exp;
branches;
next	1.7;

1.7
date	2011.03.18.18.41.36;	author palves;	state Exp;
branches;
next	1.6;

1.6
date	2011.02.14.11.35.45;	author palves;	state Exp;
branches;
next	1.5;

1.5
date	2011.02.14.11.34.31;	author palves;	state Exp;
branches;
next	1.4;

1.4
date	2011.02.14.11.33.24;	author palves;	state Exp;
branches;
next	1.3;

1.3
date	2011.02.14.11.32.17;	author palves;	state Exp;
branches;
next	1.2;

1.2
date	2011.02.14.11.30.37;	author palves;	state Exp;
branches;
next	1.1;

1.1
date	2011.02.14.11.29.04;	author palves;	state Exp;
branches;
next	;

1.11.2.1
date	2012.01.06.04.54.30;	author brobecke;	state Exp;
branches;
next	;


desc
@@


1.23
log
@gdb/testsuite/
	* gdb.threads/non-ldr-exc-1.exp (do_test): Fix the indent of
	using with_test_prefix.
	* gdb.threads/non-ldr-exc-2.exp (do_test): Likewise.
	* gdb.threads/non-ldr-exc-3.exp (do_test): Likewise.
	* gdb.threads/non-ldr-exc-4.exp (do_test): Likewise.
	* gdb.threads/watchpoint-fork.exp (test): Likewise.
	* gdb.base/break-interp.exp (test_core): Likewise.
	(test_attach_gdb): Likewise.
	* gdb.base/catch-load.exp (one_catch_load_test): Likewise.
	* gdb.base/disp-step-syscall.exp (disp_step_cross_syscall):
	Likewise.
	* gdb.base/jit-so.exp (one_jit_test): Likewise.
	* gdb.base/jit.exp (one_jit_test): Likewise.
	* gdb.base/sepdebug.exp (test_different_dir): Likewise.
	* gdb.dwarf2/dw2-dir-file-name.exp (test): Likewise.
	* gdb.dwarf2/dw2-noloc.exp (file_symbols): Likewise.
	* gdb.mi/mi-breakpoint-changed.exp (test_pending_resolved):
	Likewise.
	* gdb.mi/mi-cmd-param-changed.exp (test_command_param_changed):
	Likewise.
	* gdb.mi/mi-watch.exp test_watchpoint_all): Likewise.
	* gdb.mi/pr11022.exp (test_memory_changed_observer): Likewise.
	* gdb.trace/change-loc.exp (tracepoint_change_loc_1): Likewise.
	(tracepoint_change_loc_2): Likewise.
	* gdb.trace/disconnected-tracing.exp (disconnected_tracing):
	Likewise.
	(disconnected_tfind): Likewise.
	* gdb.trace/mi-traceframe-changed.exp (test_tfind_tfile):
	Likewise.
	(test_tfind_remote): Likewise.
	* gdb.trace/mi-tracepoint-changed.exp (test_reconnect):
	Likewise.
	(test_pending_resolved): Likewise.
	* gdb.trace/mi-tsv-changed.exp (test_create_delete_modify_tsv):
	Likewise.
	(test_upload_tsv): Likewise.
	* gdb.trace/pending.exp (pending_tracepoint_resolved):
	Likewise.
	(pending_tracepoint_works): Likewise.
	* gdb.trace/report.exp (use_collected_data): Likewise.
	* gdb.trace/status-stop.exp (test_tstart_tstop_tstart):
	Likewise.
	(test_tstart_tstart, test_buffer_full_tstart): Likewise.
	* gdb.trace/strace.exp (strace_info_marker): Likewise.
	(strace_trace_on_same_addr): Likewise.
	(strace_trace_on_diff_addr): Likewise.
	* gdb.trace/unavailable.exp (gdb_collect_args_test): Likewise.
	(gdb_collect_locals_test): Likewise.
	(gdb_unavailable_registers_test): Likewise.
	(gdb_collect_globals_test): Likewise.
@
text
@# Copyright 1998-2013 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

load_lib "trace-support.exp"

standard_testfile unavailable.cc
set executable $testfile

if {[prepare_for_testing $testfile.exp $testfile $srcfile \
	 {debug nowarnings c++}]} {
    return -1
}

set ws "\[\r\n\t \]+"
set cr "\[\r\n\]+"

if [is_amd64_regs_target] {
    set fpreg "rbp"
    set spreg "rsp"
    set pcreg "rip"
} elseif [is_x86_like_target] {
    set fpreg "ebp"
    set spreg "esp"
    set pcreg "eip"
} else {
    set fpreg "fp"
    set spreg "sp"
    set pcreg "pc"
}

#
# Utility procs
#

proc test_register { reg } {
    global gdb_prompt
    global hex
    global cr

    gdb_test_multiple "print /x $reg" "collected $reg" {
	-re "\\$\[0-9\]+ = \[x0\]+$cr$gdb_prompt $" {
	    fail "collected $reg (zero)"
	}
	-re "\\$\[0-9\]+ = $hex$cr$gdb_prompt $" {
	    pass "collected $reg"
	}
	-re "\[Ee\]rror.*$gdb_prompt $" {
	    fail "collected $reg (error)"
	}
    }
}

proc test_register_unavailable { reg } {
    gdb_test "print /x $reg" \
	"<unavailable>" \
	"correctly report $reg as unavailable"
}

proc prepare_for_trace_test {} {
    global executable

    clean_restart $executable

    runto_main

    gdb_test "break begin" ".*" ""
    gdb_test "break end" ".*" ""
}

proc run_trace_experiment { test_func } {
    global gdb_prompt

    gdb_test "continue" \
	".*Breakpoint \[0-9\]+, begin .*" \
	"advance to begin"

    gdb_test_no_output "tstart" "start trace experiment"

    gdb_test "continue" \
	    "Continuing.*Breakpoint \[0-9\]+, end.*" \
	    "run trace experiment"
    gdb_test "tstop" \
	    "\[\r\n\]+" \
	    "stop trace experiment"
    gdb_test "tfind start" \
	    "#0  $test_func .*" \
	    "tfind test frame"
}

# Test that "display VAR" works as expected, assuming VAR is wholly
# unavailable.

proc test_maybe_regvar_display { var } {
    global gdb_prompt

    # Evaluating VAR's location description may throw an internal
    # "unavailable" exception, if for example, the value of a register
    # necessary for computing VAR's location is unavailable.  Such an
    # exception is caught, and should not cause automatic disablement
    # of the current display being printed.  (GDB used to disable the
    # current display whenever any exception was thrown.)
    set test "display $var"
    gdb_test_multiple "$test" "$test" {
	-re "Disabling display ? to avoid infinite recursion.*$gdb_prompt $" {
	    fail "$test"
	}
	-re "display ${var}\r\n1: ${var} = <unavailable>\r\n$gdb_prompt $" {
	    pass "$test"
	}
    }
    gdb_test "info display" ".*1:\[ \t\]+y\[ \t\]+${var}" "display ${var} is enabled"

    gdb_test "undisp" \
	"" \
	"delete $var display" \
	".*Delete all auto-display expressions.*y or n. $" \
	"y"
}

#
# Test procs
#

proc gdb_collect_args_test {} {
    with_test_prefix "unavailable arguments" {
	global cr
	global gdb_prompt

	prepare_for_trace_test

	gdb_test "trace args_test_func" \
	    "Tracepoint \[0-9\]+ at .*" \
	    "set tracepoint"

	# Begin the test.
	run_trace_experiment args_test_func

	# Test printing the variables, and also their addresses.  We
	# haven't collected any stack, so there's no way GDB can figure
	# out the latter.

	gdb_test "print argc" " = <unavailable>"
	gdb_test "print &argc" \
	    "Can't take address of \"argc\" which isn't an lvalue\."

	gdb_test "print argi" " = <unavailable>"
	gdb_test "print &argi" \
	    "Can't take address of \"argi\" which isn't an lvalue\."

	gdb_test "print argf" " = <unavailable>"
	gdb_test "print &argf" \
	    "Can't take address of \"argf\" which isn't an lvalue\."

	gdb_test "print argd" " = <unavailable>"
	gdb_test "print &argd" \
	    "Can't take address of \"argd\" which isn't an lvalue\."

	# struct arg as one of several args (near end of list)

	gdb_test "print argstruct" \
	    " = \{memberc = <unavailable>, memberi = <unavailable>, memberf = <unavailable>, memberd = <unavailable>\}"

	gdb_test "print argstruct.memberc" " = <unavailable>"
	gdb_test "print argstruct.memberi" " = <unavailable>"
	gdb_test "print argstruct.memberf" " = <unavailable>"
	gdb_test "print argstruct.memberd" " = <unavailable>"

	gdb_test "print argarray" " = \\(int \\*\\) <unavailable>"

	gdb_test "print &argarray" \
	    "Can't take address of \"argarray\" which isn't an lvalue\."

	gdb_test "print argarray\[0\]" "value is not available"

	# Test "info args"
	set r ""
	set r "${r}argc = <unavailable>${cr}"
	set r "${r}argi = <unavailable>${cr}"
	set r "${r}argf = <unavailable>${cr}"
	set r "${r}argd = <unavailable>${cr}"
	set r "${r}argstruct = {memberc = <unavailable>, memberi = <unavailable>, memberf = <unavailable>, memberd = <unavailable>}${cr}"
	set r "${r}argarray = <unavailable>${cr}"
	gdb_test "info args" "$r" "info args"

	test_maybe_regvar_display "argc"

	gdb_test "tfind none" \
	    "#0  end .*" \
	    "cease trace debugging"
    }
}

proc gdb_collect_locals_test { func msg } {
    with_test_prefix "unavailable locals: $msg" {
	global cr
	global gdb_prompt

	prepare_for_trace_test

	set testline [gdb_get_line_number "set $func tracepoint here"]

	gdb_test "trace $testline" \
	    "Tracepoint \[0-9\]+ at .*" \
	    "set tracepoint"

	# Begin the test.
	run_trace_experiment $func

	gdb_test "print locc" " = <unavailable>"
	gdb_test "print loci" " = <unavailable>"
	gdb_test "print locf" " = <unavailable>"
	gdb_test "print locd" " = <unavailable>"

	gdb_test "print locst.memberc" " = <unavailable>"
	gdb_test "print locst.memberi" " = <unavailable>"
	gdb_test "print locst.memberf" " = <unavailable>"
	gdb_test "print locst.memberd" " = <unavailable>"

	gdb_test "print locar\[0\]" " = <unavailable>"
	gdb_test "print locar\[1\]" " = <unavailable>"
	gdb_test "print locar\[2\]" " = <unavailable>"
	gdb_test "print locar\[3\]" " = <unavailable>"

	# Test "info locals"
	set r ""
	set r "${r}locf = <unavailable>${cr}"
	set r "${r}locd = <unavailable>${cr}"
	set r "${r}locst = {memberc = <unavailable>, memberi = <unavailable>, memberf = <unavailable>, memberd = <unavailable>}${cr}"
	set r "${r}locar = {<unavailable>, <unavailable>, <unavailable>, <unavailable>}${cr}"
	set r "${r}i = <unavailable>${cr}"
	if { $func == "local_test_func" } {
	    set r "${r}locdefst = {<No data fields>}${cr}"
	}
	set r "${r}locc = <unavailable>${cr}"
	set r "${r}loci = <unavailable>${cr}"
	gdb_test "info locals" "$r" "info locals"

	test_maybe_regvar_display "loci"

	gdb_test "tfind none" \
	    "#0  end .*" \
	    "cease trace debugging"
    }
}

proc gdb_unavailable_registers_test { } {
    with_test_prefix "unavailable registers" {
	global gdb_prompt
	global spreg
	global pcreg

	prepare_for_trace_test

	# We'll simply re-use the globals_test_function for this test
	gdb_test "trace globals_test_func" \
	    "Tracepoint \[0-9\]+ at .*" \
	    "set tracepoint"

	# Collect nothing.

	# Begin the test.
	run_trace_experiment globals_test_func

	# On some archs, the $sp/$pc are a real raw registers.  On others,
	# like x86, they're user registers.  Test both variants.
	test_register_unavailable "\$$spreg"
	test_register_unavailable "\$sp"

	# Test reading uncollected pseudo-registers.  The set of which
	# depends on target.
	if [is_amd64_regs_target] {
	    # Check the raw register first.
	    test_register_unavailable "\$rax"
	    test_register_unavailable "\$eax"
	    test_register_unavailable "\$ax"
	} elseif [is_x86_like_target] {
	    # Check the raw register first.
	    test_register_unavailable "\$eax"
	    test_register_unavailable "\$ax"
	}

	# GDBserver always provides the PC value of regular tracepoint
	# hits, since it's the same as the tracepoint's address.
	test_register "\$$pcreg"
	test_register "\$pc"

	gdb_test "info registers" \
	    "\\*value not available\\*.*\\*value not available\\*" \
	    "info registers, multiple registers not available"

	gdb_test "info registers \$$spreg" \
	    "\\*value not available\\*" \
	    "info registers \$$spreg reports not available"

	gdb_test "tfind none" "#0  end .*" "cease trace debugging"
    }
}

proc gdb_unavailable_floats { } {
    global gdb_prompt

    with_test_prefix "unavailable floats" {
	prepare_for_trace_test

	# We'll simply re-use the globals_test_function for this test
	gdb_test "trace globals_test_func" \
	    "Tracepoint \[0-9\]+ at .*" \
	    "set tracepoint"

	# Collect nothing.

	# Begin the test.
	run_trace_experiment globals_test_func

	# Necessarily target specific.
	if {[istarget "x86_64-*-*"] || [istarget i?86-*]} {
	    send_gdb "info float\n"
	    gdb_expect_list "info float" ".*$gdb_prompt $" {
		"Status Word:         <unavailable>"
		"Control Word:        <unavailable>"
		"Tag Word:            <unavailable>"
		"Instruction Pointer: <unavailable>:<unavailable>"
		"Operand Pointer:     <unavailable>:<unavailable>"
		"Opcode:              <unavailable>"
	    }
	}

	gdb_test "tfind none" "#0  end .*" "cease trace debugging"
    }
}

proc gdb_collect_globals_test { } {
    with_test_prefix "collect globals" {
	global ws
	global cr
	global gdb_prompt
	global hex

	prepare_for_trace_test

	set testline [gdb_get_line_number "set globals_test_func tracepoint here"]

	gdb_test "trace $testline" \
	    "Tracepoint \[0-9\]+ at .*" \
	    "set tracepoint"

	# We collect the initial sizeof(pointer) bytes of derived_partial
	# in an attempt of collecting the vptr.  Not portable, but should
	# work everywhere we need to care.
	gdb_trace_setactions "define actions" \
	    "" \
	    "collect struct_b.struct_a.array\[2\]" "^$" \
	    "collect struct_b.struct_a.array\[100\]" "^$" \
	    \
	    "collect a" "^$" \
	    "collect c" "^$" \
	    \
	    "collect tarray\[0\].a" "^$" \
	    "collect tarray\[1\].a" "^$" \
	    "collect tarray\[3\].a" "^$" \
	    "collect tarray\[3\].b" "^$" \
	    "collect tarray\[4\].b" "^$" \
	    "collect tarray\[5\].b" "^$" \
	    \
	    "collect g_string_p" "^$" \
	    "collect g_string_partial\[1\]" "^$" \
	    "collect g_string_partial\[2\]" "^$" \
	    \
	    "collect g_structref_p" "^$" \
	    \
	    "collect *((char *)&derived_partial)@@sizeof\(void *\)" "^$" \
	    "collect derived_whole" "^$" \
	    \
	    "collect virtual_partial.z" "^$"

	# Begin the test.
	run_trace_experiment globals_test_func

	gdb_test "print globalc" " = <unavailable>"
	gdb_test "print globali" " = <unavailable>"
	gdb_test "print globalf" " = <unavailable>"
	gdb_test "print globald" " = <unavailable>"

	gdb_test "print globalstruct.memberc" " = <unavailable>"
	gdb_test "print globalstruct.memberi" " = <unavailable>"
	gdb_test "print globalstruct.memberf" " = <unavailable>"
	gdb_test "print globalstruct.memberd" " = <unavailable>"

	gdb_test "print globalstruct" \
	    " = {memberc = <unavailable>, memberi = <unavailable>, memberf = <unavailable>, memberd = <unavailable>}"

	gdb_test "print globalp == &globalstruct" \
	    "value is not available" \
	    "can't compare using non collected global pointer"

	gdb_test "print globalarr\[1\]" " = <unavailable>"
	gdb_test "print globalarr\[2\]" " = <unavailable>"
	gdb_test "print globalarr\[3\]" " = <unavailable>"

	gdb_test "print struct_b" \
	    " = {d = <unavailable>, ef = <unavailable>, struct_a = {a = <unavailable>, b = <unavailable>, array = {<unavailable>, <unavailable>, -1431655766, <unavailable> <repeats 97 times>, -1431655766, <unavailable> <repeats 9899 times>}, ptr = <unavailable>, bitfield = <unavailable>}, s = <unavailable>, static static_struct_a = {a = <unavailable>, b = <unavailable>, array = {<unavailable> <repeats 10000 times>}, ptr = <unavailable>, bitfield = <unavailable>}, string = <unavailable>}"

	gdb_test "print /x struct_b" \
	    " = {d = <unavailable>, ef = <unavailable>, struct_a = {a = <unavailable>, b = <unavailable>, array = {<unavailable>, <unavailable>, 0xaaaaaaaa, <unavailable> <repeats 97 times>, 0xaaaaaaaa, <unavailable> <repeats 9899 times>}, ptr = <unavailable>, bitfield = <unavailable>}, s = <unavailable>, static static_struct_a = {a = <unavailable>, b = <unavailable>, array = {<unavailable> <repeats 10000 times>}, ptr = <unavailable>, bitfield = <unavailable>}, string = <unavailable>}"

	gdb_test "print /x struct_b.struct_a" \
	    " = {a = <unavailable>, b = <unavailable>, array = {<unavailable>, <unavailable>, 0xaaaaaaaa, <unavailable> <repeats 97 times>, 0xaaaaaaaa, <unavailable> <repeats 9899 times>}, ptr = <unavailable>, bitfield = <unavailable>}"

	gdb_test "print /x struct_b.struct_a.array" \
	    " = {<unavailable>, <unavailable>, 0xaaaaaaaa, <unavailable> <repeats 97 times>, 0xaaaaaaaa, <unavailable> <repeats 9899 times>}"

	gdb_test "print /x struct_b.struct_a.array\[0\]" " = <unavailable>"

	gdb_test "print /x struct_b.struct_a.array\[2\]" " = 0xaaaaaaaa"

	# Check the target doesn't overcollect.  GDB used to merge memory
	# ranges to collect if they were close enough (collecting the hole
	# as well), but does not do that anymore.  It's plausible that a
	# target may do this on its end, but as of this writing, no known
	# target does it.
	gdb_test "print {a, b, c}" \
	    " = \\{1, <unavailable>, 3\\}" \
	    "No overcollect of almost but not quite adjacent memory ranges"

	# Check <unavailable> isn't confused with 0 in array element repetitions

	gdb_test_no_output "set print repeat 1"

	gdb_test "print /x tarray" \
	    " = \{\{a = 0x0, b = <unavailable>\} <repeats 2 times>, \{a = <unavailable>, b = <unavailable>\}, \{a = 0x0, b = 0x0\}, \{a = <unavailable>, b = 0x0\} <repeats 2 times>, \{a = <unavailable>, b = <unavailable>\} <repeats 2 times>\}" \
	    "<unavailable> is not the same as 0 in array element repetitions"

	gdb_test_no_output "set print repeat 10"

	# Check that value repeat handles unavailable-ness.
	gdb_test "print *tarray@@3" " = \\{\\{a = 0, b = <unavailable>\\}, \\{a = 0, b = <unavailable>\\}, \\{a = <unavailable>, b = <unavailable>\\}\\}"

	# Static fields

	gdb_test "print struct_b.static_struct_a" \
	    " = {a = <unavailable>, b = <unavailable>, array = {<unavailable> <repeats 10000 times>}, ptr = <unavailable>, bitfield = <unavailable>}"

	# Bitfields

	gdb_test "print struct_b.struct_a.bitfield" " = <unavailable>"

	# References

	gdb_test "print g_int" " = <unavailable>"

	gdb_test "print g_ref" \
	    "\\(int &\\) @@$hex: <unavailable>" \
	    "global reference shows address but not value"

	gdb_test "print *&g_ref" \
	    "\\$\[0-9\]+ = <unavailable>$cr" \
	    "referenced integer was not collected (taking address of reference)"

	gdb_test "print *g_structref_p" \
	    " = {d = <unavailable>, ref = <unavailable>}"

	# Strings

	# Const string is always available, even when not collected.
	gdb_test "print g_const_string" \
	    " = \"hello world\"$cr" \
	    "non collected const string is still printable"

	gdb_test "print g_string_p" \
	    " = $hex <g_const_string> \"hello world\"" \
	    "printing constant string through collected pointer"

	gdb_test "print g_string_unavail" \
	    " = \{<unavailable> <repeats 12 times>\}" \
	    "printing non collected string"

	# Incomplete strings print as an array.
	gdb_test "print g_string_partial" \
	    "\\$\[0-9\]+ = \{<unavailable>, 101 'e', 108 'l', <unavailable>, <unavailable>, <unavailable>, <unavailable>, <unavailable>, <unavailable>, <unavailable>, <unavailable>, <unavailable>\}" \
	    "printing partially collected string"

	# It is important for this test that the last examined value is
	# <unavailable>, to exercise the case of the $__ convenience
	# variable being set to <unavailable> without error.
	set msg "examining partially collected object"
	gdb_test_multiple "x /10x &struct_b" "$msg" {
	    -re "$hex <struct_b>:${ws}<unavailable>${ws}<unavailable>${ws}<unavailable>${ws}<unavailable>$cr$hex <struct_b\\+16>:${ws}<unavailable>${ws}<unavailable>${ws}0xaaaaaaaa${ws}<unavailable>$cr$hex <struct_b\\+32>:${ws}<unavailable>${ws}<unavailable>$cr$gdb_prompt $" {
		pass "$msg"
	    }
	    -re "value is not available" {
		fail "$msg"
	    }
	}

	gdb_test "p \$__" " = <unavailable>" "last examined value was <unavailable>"

	# This tests that building the array does not require accessing
	# g_int's contents.
	gdb_test "print { 1, g_int, 3 }" \
	    " = \\{1, <unavailable>, 3\\}" \
	    "build array from unavailable value"

	# Note, depends on previous test.
	gdb_test "print \$\[1\]" \
	    " = <unavailable>" \
	    "subscript a non-memory rvalue array, accessing an unvailable element"

	# Access a field of a non-lazy value, making sure the
	# unavailable-ness is propagated.  History values are easy
	# non-lazy values, so use those.  The first test just sets up for
	# the second.
	gdb_test "print g_smallstruct" " = \\{member = <unavailable>\\}"
	gdb_test "print \$.member" " = <unavailable>"

	# Cast to baseclass, checking the unavailable-ness is propagated.
	gdb_test "print (small_struct) g_smallstruct_b" " = \\{member = <unavailable>\\}"

	# Same cast, but starting from a non-lazy, value.
	gdb_test "print g_smallstruct_b" " = \\{<small_struct> = \\{member = <unavailable>\\}, <No data fields>\\}"
	gdb_test "print (small_struct) \$" " = \\{member = <unavailable>\\}"

	gdb_test_no_output "set print object on"

	with_test_prefix "print object on" {
	    # With print object on, printing a pointer may need to fetch
	    # the pointed-to object, to check its run-time type.  Make
	    # sure that fails gracefully and transparently when the
	    # pointer itself is unavailable.
	    gdb_test "print virtualp" " = \\(Virtual \\*\\) <unavailable>"

	    # no vtable pointer available
	    gdb_test "print derived_unavail" \
		" = {<Middle> = <unavailable>, _vptr.Derived = <unavailable>, z = <unavailable>}"

	    # vtable pointer available, but nothing else
	    gdb_test "print derived_partial" \
		" = \\(Derived\\) {<Middle> = {<Base> = <unavailable>, _vptr.Middle = <unavailable>, y = <unavailable>}, _vptr.Derived = $hex <vtable for Derived.*>, z = <unavailable>}"

	    # whole object available
	    gdb_test "print derived_whole" \
		" = \\(Derived\\) {<Middle> = {<Base> = {x = 2}, _vptr.Middle = $hex, y = 3}, _vptr.Derived = $hex <vtable for Derived.*>, z = 4}"
	}

	gdb_test_no_output "set print object off"

	with_test_prefix "print object off" {
	    gdb_test "print virtualp" " = \\(Virtual \\*\\) <unavailable>"

	    # no vtable pointer available
	    gdb_test "print derived_unavail" \
		" = {<Middle> = <unavailable>, _vptr.Derived = <unavailable>, z = <unavailable>}"

	    # vtable pointer available, but nothing else
	    gdb_test "print derived_partial" \
		" = {<Middle> = {<Base> = <unavailable>, _vptr.Middle = <unavailable>, y = <unavailable>}, _vptr.Derived = $hex <vtable for Derived.*>, z = <unavailable>}"

	    # whole object available
	    gdb_test "print derived_whole" \
		" = {<Middle> = {<Base> = {x = 2}, _vptr.Middle = $hex, y = 3}, _vptr.Derived = $hex <vtable for Derived.*>, z = 4}"
	}

	# An instance of a virtual class where we collected everything but
	# the vptr.
	gdb_test "print virtual_partial" \
	    " = {_vptr.Virtual = <unavailable>, z = 0}"

	gdb_test "tfind none" \
	    "#0  end .*" \
	    "cease trace debugging"
    }
}

proc gdb_trace_collection_test {} {
    gdb_collect_globals_test
    gdb_unavailable_registers_test
    gdb_unavailable_floats

    gdb_collect_args_test
    gdb_collect_locals_test local_test_func "auto locals"
    gdb_collect_locals_test reglocal_test_func "register locals"
    gdb_collect_locals_test statlocal_test_func "static locals"
}

runto_main

if { ![gdb_target_supports_trace] } then {
    unsupported "Current target does not support trace"
    return 1
}

# Body of test encased in a proc so we can return prematurely.
gdb_trace_collection_test

# Finished!
gdb_test "tfind none" ".*" ""
@


1.22
log
@gdb/testsuite/

	* config/monitor.exp (gdb_target_cmd): Remove semicolon after
	'return'.
	(gdb_target_monitor, gdb_load): Likewise.
	* config/sid.exp (gdb_load): Likewise.
	* config/slite.exp (gdb_load): Likewise.
	* config/vx.exp (gdb_start, spawn_vxgdb): Likewise.
	* gdb.ada/arrayidx.exp, gdb.ada/null_array.exp: Likewise.
	* gdb.arch/mips-octeon-bbit.exp (single_step): Likewise.
	(single_step_until): Likewise.
	* gdb.arch/powerpc-d128-regs.exp: Likewise.
	* gdb.arch/system-gcore.exp: Likewise.
	* gdb.base/bigcore.exp (extract_heap): Likewise.
	* gdb.base/break-on-linker-gcd-function.exp: Likewise.
	* gdb.base/call-ar-st.exp: Likewise.
	* gdb.base/call-rt-st.exp: Likewise.
	* gdb.base/call-sc.exp, gdb.base/call-strs.exp: Likewise.
	* gdb.base/callfuncs.exp, gdb.base/completion.exp: Likewise.
	* gdb.base/condbreak.exp, gdb.base/constvars.exp: Likewise.
	* gdb.base/corefile.exp: Likewise.
	* gdb.base/dbx.exp (gdb_file_cmd): Likewise.
	* gdb.base/exprs.exp, gdb.base/fileio.exp: Likewise.
	* gdb.base/fixsection.exp: Likewise.
	* gdb.base/funcargs.exp: Likewise.
	* gdb.base/gcore-buffer-overflow.exp: Likewise.
	* gdb.base/gcore-relro.exp: Likewise.
	* gdb.base/gcore.exp, gdb.base/gdb11530.exp: Likewise.
	* gdb.base/gdb11531.exp, gdb.base/gnu-ifunc.exp: Likewise.
	* gdb.base/info-os.exp, gdb.base/info-proc.exp: Likewise.
	* gdb.base/interp.exp, gdb.base/langs.exp:: Likewise.
	* gdb.base/list.exp: Likewise.
	(set_listsize): Likewise.
	* gdb.base/logical.exp, gdb.base/mips_pro.exp: Likewise.
	* gdb.base/miscexprs.exp, gdb.base/nodebug.exp: Likewise.
	* gdb.base/opaque.exp, gdb.base/pointers.exp: Likewise.
	* gdb.base/psymtab.exp, gdb.base/ptype.exp: Likewise.
	* gdb.base/relational.exp, gdb.base/scope.exp: Likewise.
	* gdb.base/setvar.exp: Likewise.
	(test_set): Likewise.
	* gdb.base/signals.exp, gdb.base/sizeof.exp: Likewise.
	* gdb.base/solib-overlap.exp: Likewise.
	* gdb.base/store.exp, gdb.base/structs.exp: Likewise.
	* gdb.base/structs2.exp, gdb.base/volatile.exp: Likewise.
	* gdb.base/watchpoint.exp (initialize): Likewise.
	(test_simple_watchpoint): Likewise.
	(test_disabling_watchpoints): Likewise.
	(test_watchpoint_triggered_in_syscall): Likewise.
	* gdb.base/whatis.exp, gdb.cp/ambiguous.exp: Likewise.
	* gdb.cp/casts.exp, gdb.cp/ctti.exp: Likewise.
	* gdb.cp/namespace.exp, gdb.cp/nsdecl.exp: Likewise.
	* gdb.cp/psmang.exp, gdb.dwarf2/dw2-ranges.exp: Likewise.
	* gdb.hp/gdb.aCC/optimize.exp: Likewise.
	* gdb.hp/gdb.aCC/watch-cmd.exp: Likewise.
	* gdb.hp/gdb.base-hp/callfwmall.exp: Likewise.
	* gdb.hp/gdb.base-hp/pxdb.exp: Likewise.
	* gdb.hp/gdb.compat/xdb1.exp: Likewise.
	* gdb.hp/gdb.compat/xdb2.exp: Likewise.
	* gdb.hp/gdb.compat/xdb3.exp: Likewise.
	* gdb.hp/gdb.defects/bs14602.exp: Likewise.
	* gdb.hp/gdb.defects/solib-d.exp: Likewise.
	* gdb.mi/gdb792.exp: Likewise.
	* gdb.mi/mi-inheritance-syntax-error.exp: Likewise.
	* gdb.mi/mi-logging.exp, gdb.mi/mi-var-cp.exp : Likewise.
	* gdb.mi/mi-var-rtti.exp, gdb.python/py-type.exp: Likewise.
	* gdb.threads/gcore-thread.exp: Likewise.
	(load_core): Likewise.
	* gdb.threads/pthreads.exp (all_threads_running): Likewise.
	(test_startup, check_control_c): Likewise.
	* gdb.threads/sigstep-threads.exp: Likewise.
	* gdb.threads/thread_check.exp: Likewise.
	* gdb.trace/backtrace.exp, gdb.trace/change-loc.exp: Likewise.
	* gdb.trace/circ.exp (run_trace_experiment): Likewise.
	(set_a_tracepoint, trace_buffer_normal): Likewise.
	(gdb_trace_circular_tests): Likewise.
	* gdb.trace/collection.exp: Likewise.
	* gdb.trace/disconnected-tracing.exp: Likewise.
	* gdb.trace/infotrace.exp: Likewise.
	* gdb.trace/mi-traceframe-changed.exp: Likewise.
	* gdb.trace/mi-tracepoint-changed.exp: Likewise.
	* gdb.trace/mi-tsv-changed.exp (test_create_delete_modify_tsv): Likewise.
	* gdb.trace/packetlen.exp, gdb.trace/passc-dyn.exp: Likewise.
	* gdb.trace/pending.exp, gdb.trace/report.exp: Likewise.
	* gdb.trace/stap-trace.exp: Likewise.
	* gdb.trace/status-stop.exp,gdb.trace/strace.exp: Likewise.
	* gdb.trace/tfind.exp, gdb.trace/trace-break.exp: Likewise.
	* gdb.trace/trace-buffer-size.exp: Likewise.
	* gdb.trace/tspeed.exp, gdb.trace/tsv.exp: Likewise.
	* gdb.trace/unavailable.exp: Likewise.
	* gdb.trace/while-dyn.exp: Likewise.
	* lib/fortran.exp (set_lang_fortran): Likewise.
	* lib/gdb.exp (default_gdb_version, gdb_start_cmd): Likewise.
	(gdb_breakpoint, gdb_reinitialize_dir): Likewise.
	(default_gdb_start, get_compiler_info): Likewise.
	(gdb_compile, gdb_compile_objc, gdb_reload, gdb_init): Likewise.
	(get_debug_format, setup_xfail_format): Likewise.
	(rerun_to_main, gdb_skip_float_test): Likewise.
	(build_id_debug_filename_get, get_remotetimeout): Likewise.
	* lib/java.exp (set_lang_java): Likewise.
	* lib/mi-support.exp (default_mi_gdb_start): Likewise.
	(mi_gdb_reinitialize_dir, mi_gdb_target_cmd): Likewise.
	(mi_gdb_file_cmd, mi_gdb_test): Likewise.
	(mi_run_cmd_full, mi_expect_interrupt): Likewise.
	* lib/objc.exp (set_lang_objc): Likewise.
	* lib/pascal.exp (set_lang_pascal): Likewise.
	* lib/prompt.exp (default_prompt_gdb_start): Likewise.
	* lib/trace-support.exp (gdb_trace_setactions, gdb_tfind_test): Likewise.
	(gdb_readexpr, gdb_gettpnum, gdb_find_recursion_test_baseline): Likewise.
@
text
@d136 4
a139 3
proc gdb_collect_args_test {} { with_test_prefix "unavailable arguments" {
    global cr
    global gdb_prompt
d141 1
a141 1
    prepare_for_trace_test
d143 3
a145 3
    gdb_test "trace args_test_func" \
	"Tracepoint \[0-9\]+ at .*" \
	"set tracepoint"
d147 2
a148 2
    # Begin the test.
    run_trace_experiment args_test_func
d150 3
a152 3
    # Test printing the variables, and also their addresses.  We
    # haven't collected any stack, so there's no way GDB can figure
    # out the latter.
d154 3
a156 3
    gdb_test "print argc" " = <unavailable>"
    gdb_test "print &argc" \
	"Can't take address of \"argc\" which isn't an lvalue\."
d158 3
a160 3
    gdb_test "print argi" " = <unavailable>"
    gdb_test "print &argi" \
	"Can't take address of \"argi\" which isn't an lvalue\."
d162 3
a164 3
    gdb_test "print argf" " = <unavailable>"
    gdb_test "print &argf" \
	"Can't take address of \"argf\" which isn't an lvalue\."
d166 3
a168 3
    gdb_test "print argd" " = <unavailable>"
    gdb_test "print &argd" \
	"Can't take address of \"argd\" which isn't an lvalue\."
d170 1
a170 1
    # struct arg as one of several args (near end of list)
d172 2
a173 2
    gdb_test "print argstruct" \
	" = \{memberc = <unavailable>, memberi = <unavailable>, memberf = <unavailable>, memberd = <unavailable>\}"
d175 4
a178 4
    gdb_test "print argstruct.memberc" " = <unavailable>"
    gdb_test "print argstruct.memberi" " = <unavailable>"
    gdb_test "print argstruct.memberf" " = <unavailable>"
    gdb_test "print argstruct.memberd" " = <unavailable>"
d180 1
a180 1
    gdb_test "print argarray" " = \\(int \\*\\) <unavailable>"
d182 2
a183 2
    gdb_test "print &argarray" \
	"Can't take address of \"argarray\" which isn't an lvalue\."
d185 1
a185 1
    gdb_test "print argarray\[0\]" "value is not available"
d187 9
a195 9
    # Test "info args"
    set r ""
    set r "${r}argc = <unavailable>${cr}"
    set r "${r}argi = <unavailable>${cr}"
    set r "${r}argf = <unavailable>${cr}"
    set r "${r}argd = <unavailable>${cr}"
    set r "${r}argstruct = {memberc = <unavailable>, memberi = <unavailable>, memberf = <unavailable>, memberd = <unavailable>}${cr}"
    set r "${r}argarray = <unavailable>${cr}"
    gdb_test "info args" "$r" "info args"
d197 1
a197 1
    test_maybe_regvar_display "argc"
d199 5
a203 4
    gdb_test "tfind none" \
	"#0  end .*" \
	"cease trace debugging"
}}
d205 4
a208 3
proc gdb_collect_locals_test { func msg } { with_test_prefix "unavailable locals: $msg" {
    global cr
    global gdb_prompt
d210 1
a210 1
    prepare_for_trace_test
d212 1
a212 1
    set testline [gdb_get_line_number "set $func tracepoint here"]
d214 1
a214 1
    gdb_test "trace $testline" \
d218 2
a219 2
    # Begin the test.
    run_trace_experiment $func
d221 34
a254 24
    gdb_test "print locc" " = <unavailable>"
    gdb_test "print loci" " = <unavailable>"
    gdb_test "print locf" " = <unavailable>"
    gdb_test "print locd" " = <unavailable>"

    gdb_test "print locst.memberc" " = <unavailable>"
    gdb_test "print locst.memberi" " = <unavailable>"
    gdb_test "print locst.memberf" " = <unavailable>"
    gdb_test "print locst.memberd" " = <unavailable>"

    gdb_test "print locar\[0\]" " = <unavailable>"
    gdb_test "print locar\[1\]" " = <unavailable>"
    gdb_test "print locar\[2\]" " = <unavailable>"
    gdb_test "print locar\[3\]" " = <unavailable>"

    # Test "info locals"
    set r ""
    set r "${r}locf = <unavailable>${cr}"
    set r "${r}locd = <unavailable>${cr}"
    set r "${r}locst = {memberc = <unavailable>, memberi = <unavailable>, memberf = <unavailable>, memberd = <unavailable>}${cr}"
    set r "${r}locar = {<unavailable>, <unavailable>, <unavailable>, <unavailable>}${cr}"
    set r "${r}i = <unavailable>${cr}"
    if { $func == "local_test_func" } {
	set r "${r}locdefst = {<No data fields>}${cr}"
d256 1
a256 10
    set r "${r}locc = <unavailable>${cr}"
    set r "${r}loci = <unavailable>${cr}"
    gdb_test "info locals" "$r" "info locals"

    test_maybe_regvar_display "loci"

    gdb_test "tfind none" \
	"#0  end .*" \
	"cease trace debugging"
}}
d258 5
a262 4
proc gdb_unavailable_registers_test { } { with_test_prefix "unavailable registers" {
    global gdb_prompt
    global spreg
    global pcreg
d264 1
a264 1
    prepare_for_trace_test
d266 2
a267 2
    # We'll simply re-use the globals_test_function for this test
    gdb_test "trace globals_test_func" \
d271 1
a271 1
    # Collect nothing.
d273 2
a274 2
    # Begin the test.
    run_trace_experiment globals_test_func
d276 17
a292 17
    # On some archs, the $sp/$pc are a real raw registers.  On others,
    # like x86, they're user registers.  Test both variants.
    test_register_unavailable "\$$spreg"
    test_register_unavailable "\$sp"

    # Test reading uncollected pseudo-registers.  The set of which
    # depends on target.
    if [is_amd64_regs_target] {
	# Check the raw register first.
	test_register_unavailable "\$rax"
	test_register_unavailable "\$eax"
	test_register_unavailable "\$ax"
    } elseif [is_x86_like_target] {
	# Check the raw register first.
	test_register_unavailable "\$eax"
	test_register_unavailable "\$ax"
    }
d294 12
a305 12
    # GDBserver always provides the PC value of regular tracepoint
    # hits, since it's the same as the tracepoint's address.
    test_register "\$$pcreg"
    test_register "\$pc"

    gdb_test "info registers" \
	"\\*value not available\\*.*\\*value not available\\*" \
	"info registers, multiple registers not available"

    gdb_test "info registers \$$spreg" \
	"\\*value not available\\*" \
	"info registers \$$spreg reports not available"
d307 3
a309 2
    gdb_test "tfind none" "#0  end .*" "cease trace debugging"
}}
d344 6
a349 5
proc gdb_collect_globals_test { } { with_test_prefix "collect globals" {
    global ws
    global cr
    global gdb_prompt
    global hex
d351 1
a351 1
    prepare_for_trace_test
d353 1
a353 1
    set testline [gdb_get_line_number "set globals_test_func tracepoint here"]
d355 1
a355 1
    gdb_test "trace $testline" \
d359 41
a399 41
    # We collect the initial sizeof(pointer) bytes of derived_partial
    # in an attempt of collecting the vptr.  Not portable, but should
    # work everywhere we need to care.
    gdb_trace_setactions "define actions" \
	"" \
	"collect struct_b.struct_a.array\[2\]" "^$" \
	"collect struct_b.struct_a.array\[100\]" "^$" \
	\
	"collect a" "^$" \
	"collect c" "^$" \
	\
	"collect tarray\[0\].a" "^$" \
	"collect tarray\[1\].a" "^$" \
	"collect tarray\[3\].a" "^$" \
	"collect tarray\[3\].b" "^$" \
	"collect tarray\[4\].b" "^$" \
	"collect tarray\[5\].b" "^$" \
	\
	"collect g_string_p" "^$" \
	"collect g_string_partial\[1\]" "^$" \
	"collect g_string_partial\[2\]" "^$" \
	\
	"collect g_structref_p" "^$" \
	\
	"collect *((char *)&derived_partial)@@sizeof\(void *\)" "^$" \
	"collect derived_whole" "^$" \
	\
	"collect virtual_partial.z" "^$"

    # Begin the test.
    run_trace_experiment globals_test_func

    gdb_test "print globalc" " = <unavailable>"
    gdb_test "print globali" " = <unavailable>"
    gdb_test "print globalf" " = <unavailable>"
    gdb_test "print globald" " = <unavailable>"

    gdb_test "print globalstruct.memberc" " = <unavailable>"
    gdb_test "print globalstruct.memberi" " = <unavailable>"
    gdb_test "print globalstruct.memberf" " = <unavailable>"
    gdb_test "print globalstruct.memberd" " = <unavailable>"
d401 1
a401 1
    gdb_test "print globalstruct" \
d404 1
a404 1
    gdb_test "print globalp == &globalstruct" \
d408 3
a410 3
    gdb_test "print globalarr\[1\]" " = <unavailable>"
    gdb_test "print globalarr\[2\]" " = <unavailable>"
    gdb_test "print globalarr\[3\]" " = <unavailable>"
d412 2
a413 2
    gdb_test "print struct_b" \
	" = {d = <unavailable>, ef = <unavailable>, struct_a = {a = <unavailable>, b = <unavailable>, array = {<unavailable>, <unavailable>, -1431655766, <unavailable> <repeats 97 times>, -1431655766, <unavailable> <repeats 9899 times>}, ptr = <unavailable>, bitfield = <unavailable>}, s = <unavailable>, static static_struct_a = {a = <unavailable>, b = <unavailable>, array = {<unavailable> <repeats 10000 times>}, ptr = <unavailable>, bitfield = <unavailable>}, string = <unavailable>}"
d415 2
a416 2
    gdb_test "print /x struct_b" \
	" = {d = <unavailable>, ef = <unavailable>, struct_a = {a = <unavailable>, b = <unavailable>, array = {<unavailable>, <unavailable>, 0xaaaaaaaa, <unavailable> <repeats 97 times>, 0xaaaaaaaa, <unavailable> <repeats 9899 times>}, ptr = <unavailable>, bitfield = <unavailable>}, s = <unavailable>, static static_struct_a = {a = <unavailable>, b = <unavailable>, array = {<unavailable> <repeats 10000 times>}, ptr = <unavailable>, bitfield = <unavailable>}, string = <unavailable>}"
d418 2
a419 2
    gdb_test "print /x struct_b.struct_a" \
	" = {a = <unavailable>, b = <unavailable>, array = {<unavailable>, <unavailable>, 0xaaaaaaaa, <unavailable> <repeats 97 times>, 0xaaaaaaaa, <unavailable> <repeats 9899 times>}, ptr = <unavailable>, bitfield = <unavailable>}"
d421 2
a422 2
    gdb_test "print /x struct_b.struct_a.array" \
	" = {<unavailable>, <unavailable>, 0xaaaaaaaa, <unavailable> <repeats 97 times>, 0xaaaaaaaa, <unavailable> <repeats 9899 times>}"
d424 1
a424 1
    gdb_test "print /x struct_b.struct_a.array\[0\]" " = <unavailable>"
d426 1
a426 1
    gdb_test "print /x struct_b.struct_a.array\[2\]" " = 0xaaaaaaaa"
d428 8
a435 8
    # Check the target doesn't overcollect.  GDB used to merge memory
    # ranges to collect if they were close enough (collecting the hole
    # as well), but does not do that anymore.  It's plausible that a
    # target may do this on its end, but as of this writing, no known
    # target does it.
    gdb_test "print {a, b, c}" \
	" = \\{1, <unavailable>, 3\\}" \
	"No overcollect of almost but not quite adjacent memory ranges"
d437 1
a437 1
    # Check <unavailable> isn't confused with 0 in array element repetitions
d439 1
a439 1
    gdb_test_no_output "set print repeat 1"
d441 3
a443 3
    gdb_test "print /x tarray" \
	" = \{\{a = 0x0, b = <unavailable>\} <repeats 2 times>, \{a = <unavailable>, b = <unavailable>\}, \{a = 0x0, b = 0x0\}, \{a = <unavailable>, b = 0x0\} <repeats 2 times>, \{a = <unavailable>, b = <unavailable>\} <repeats 2 times>\}" \
	"<unavailable> is not the same as 0 in array element repetitions"
d445 1
a445 1
    gdb_test_no_output "set print repeat 10"
d447 2
a448 2
    # Check that value repeat handles unavailable-ness.
    gdb_test "print *tarray@@3" " = \\{\\{a = 0, b = <unavailable>\\}, \\{a = 0, b = <unavailable>\\}, \\{a = <unavailable>, b = <unavailable>\\}\\}"
d450 1
a450 1
    # Static fields
d452 2
a453 2
    gdb_test "print struct_b.static_struct_a" \
	" = {a = <unavailable>, b = <unavailable>, array = {<unavailable> <repeats 10000 times>}, ptr = <unavailable>, bitfield = <unavailable>}"
d455 1
a455 1
    # Bitfields
d457 1
a457 1
    gdb_test "print struct_b.struct_a.bitfield" " = <unavailable>"
d459 1
a459 1
    # References
d461 1
a461 1
    gdb_test "print g_int" " = <unavailable>"
d463 3
a465 3
    gdb_test "print g_ref" \
	"\\(int &\\) @@$hex: <unavailable>" \
	"global reference shows address but not value"
d467 3
a469 3
    gdb_test "print *&g_ref" \
	"\\$\[0-9\]+ = <unavailable>$cr" \
	"referenced integer was not collected (taking address of reference)"
d471 2
a472 2
    gdb_test "print *g_structref_p" \
	" = {d = <unavailable>, ref = <unavailable>}"
d474 1
a474 1
    # Strings
d476 4
a479 4
    # Const string is always available, even when not collected.
    gdb_test "print g_const_string" \
	" = \"hello world\"$cr" \
	"non collected const string is still printable"
d481 3
a483 3
    gdb_test "print g_string_p" \
	" = $hex <g_const_string> \"hello world\"" \
	"printing constant string through collected pointer"
d485 3
a487 3
    gdb_test "print g_string_unavail" \
	" = \{<unavailable> <repeats 12 times>\}" \
	"printing non collected string"
d489 4
a492 4
    # Incomplete strings print as an array.
    gdb_test "print g_string_partial" \
	"\\$\[0-9\]+ = \{<unavailable>, 101 'e', 108 'l', <unavailable>, <unavailable>, <unavailable>, <unavailable>, <unavailable>, <unavailable>, <unavailable>, <unavailable>, <unavailable>\}" \
	"printing partially collected string"
d494 11
a504 7
    # It is important for this test that the last examined value is
    # <unavailable>, to exercise the case of the $__ convenience
    # variable being set to <unavailable> without error.
    set msg "examining partially collected object"
    gdb_test_multiple "x /10x &struct_b" "$msg" {
	-re "$hex <struct_b>:${ws}<unavailable>${ws}<unavailable>${ws}<unavailable>${ws}<unavailable>$cr$hex <struct_b\\+16>:${ws}<unavailable>${ws}<unavailable>${ws}0xaaaaaaaa${ws}<unavailable>$cr$hex <struct_b\\+32>:${ws}<unavailable>${ws}<unavailable>$cr$gdb_prompt $" {
	    pass "$msg"
d506 48
a553 2
	-re "value is not available" {
	    fail "$msg"
a554 1
    }
d556 1
a556 1
    gdb_test "p \$__" " = <unavailable>" "last examined value was <unavailable>"
d558 2
a559 46
    # This tests that building the array does not require accessing
    # g_int's contents.
    gdb_test "print { 1, g_int, 3 }" \
	" = \\{1, <unavailable>, 3\\}" \
	"build array from unavailable value"

    # Note, depends on previous test.
    gdb_test "print \$\[1\]" \
	" = <unavailable>" \
	"subscript a non-memory rvalue array, accessing an unvailable element"

    # Access a field of a non-lazy value, making sure the
    # unavailable-ness is propagated.  History values are easy
    # non-lazy values, so use those.  The first test just sets up for
    # the second.
    gdb_test "print g_smallstruct" " = \\{member = <unavailable>\\}"
    gdb_test "print \$.member" " = <unavailable>"

    # Cast to baseclass, checking the unavailable-ness is propagated.
    gdb_test "print (small_struct) g_smallstruct_b" " = \\{member = <unavailable>\\}"

    # Same cast, but starting from a non-lazy, value.
    gdb_test "print g_smallstruct_b" " = \\{<small_struct> = \\{member = <unavailable>\\}, <No data fields>\\}"
    gdb_test "print (small_struct) \$" " = \\{member = <unavailable>\\}"

    gdb_test_no_output "set print object on"

    with_test_prefix "print object on" {
	# With print object on, printing a pointer may need to fetch
	# the pointed-to object, to check its run-time type.  Make
	# sure that fails gracefully and transparently when the
	# pointer itself is unavailable.
	gdb_test "print virtualp" " = \\(Virtual \\*\\) <unavailable>"

	# no vtable pointer available
	gdb_test "print derived_unavail" \
	    " = {<Middle> = <unavailable>, _vptr.Derived = <unavailable>, z = <unavailable>}"

	# vtable pointer available, but nothing else
	gdb_test "print derived_partial" \
	    " = \\(Derived\\) {<Middle> = {<Base> = <unavailable>, _vptr.Middle = <unavailable>, y = <unavailable>}, _vptr.Derived = $hex <vtable for Derived.*>, z = <unavailable>}"

	# whole object available
	gdb_test "print derived_whole" \
	    " = \\(Derived\\) {<Middle> = {<Base> = {x = 2}, _vptr.Middle = $hex, y = 3}, _vptr.Derived = $hex <vtable for Derived.*>, z = 4}"
    }
d561 12
a572 4
    gdb_test_no_output "set print object off"

    with_test_prefix "print object off" {
	gdb_test "print virtualp" " = \\(Virtual \\*\\) <unavailable>"
d574 8
a581 11
	# no vtable pointer available
	gdb_test "print derived_unavail" \
	    " = {<Middle> = <unavailable>, _vptr.Derived = <unavailable>, z = <unavailable>}"

	# vtable pointer available, but nothing else
	gdb_test "print derived_partial" \
	    " = {<Middle> = {<Base> = <unavailable>, _vptr.Middle = <unavailable>, y = <unavailable>}, _vptr.Derived = $hex <vtable for Derived.*>, z = <unavailable>}"

	# whole object available
	gdb_test "print derived_whole" \
	    " = {<Middle> = {<Base> = {x = 2}, _vptr.Middle = $hex, y = 3}, _vptr.Derived = $hex <vtable for Derived.*>, z = 4}"
d583 1
a583 10

    # An instance of a virtual class where we collected everything but
    # the vptr.
    gdb_test "print virtual_partial" \
	" = {_vptr.Virtual = <unavailable>, z = 0}"

    gdb_test "tfind none" \
	"#0  end .*" \
	"cease trace debugging"
}}
@


1.21
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d592 1
a592 1
    return 1;
@


1.20
log
@	* gdb.trace/actions.exp: Use standard_testfile.
	* gdb.trace/ax.exp: Use standard_testfile.
	* gdb.trace/backtrace.exp: Use standard_testfile.
	* gdb.trace/change-loc.exp: Use standard_testfile.
	* gdb.trace/circ.exp: Use standard_testfile, prepare_for_testing.
	* gdb.trace/collection.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.trace/deltrace.exp: Use standard_testfile.
	* gdb.trace/disconnected-tracing.exp: Use standard_testfile.
	* gdb.trace/ftrace.exp: Use standard_testfile.
	* gdb.trace/infotrace.exp: Use standard_testfile.
	* gdb.trace/packetlen.exp: Use standard_testfile.
	* gdb.trace/passc-dyn.exp: Use standard_testfile.
	* gdb.trace/passcount.exp: Use standard_testfile.
	* gdb.trace/pending.exp: Use standard_testfile.
	* gdb.trace/report.exp: Use standard_testfile.
	* gdb.trace/save-trace.exp: Use standard_testfile.
	* gdb.trace/stap-trace.exp: Use standard_testfile.
	* gdb.trace/status-stop.exp: Use standard_testfile.
	* gdb.trace/strace.exp: Use standard_testfile.
	* gdb.trace/tfile.exp: Use standard_testfile.
	* gdb.trace/tfind.exp: Use standard_testfile.
	* gdb.trace/trace-break.exp: Use standard_testfile.
	* gdb.trace/trace-mt.exp: Use standard_testfile.
	* gdb.trace/tracecmd.exp: Use standard_testfile.
	* gdb.trace/tspeed.exp: Use standard_testfile.
	* gdb.trace/tstatus.exp: Use standard_testfile.
	* gdb.trace/tsv.exp: Use standard_testfile.
	* gdb.trace/unavailable.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.trace/while-dyn.exp: Use standard_testfile.
	* gdb.trace/while-stepping.exp: Use standard_testfile.
@
text
@d1 1
a1 1
# Copyright 1998, 2005, 2007-2012 Free Software Foundation, Inc.
@


1.19
log
@	* gdb.trace/unavailable.exp (gdb_collect_globals_test): Update
	for 'set print symbol' change.
@
text
@d18 1
a18 2
set testfile "unavailable"
set srcfile ${testfile}.cc
a19 1
set binfile $objdir/$subdir/$executable
d21 2
a22 3
if { [gdb_compile "$srcdir/$subdir/$srcfile" $binfile \
	executable {debug nowarnings c++}] != "" } {
    untested unavailable.exp
a587 1
clean_restart $executable
@


1.18
log
@gdb/
	* cp-valprint.c (cp_print_value_fields): Check valprint_check_validity
	for TYPE_VPTR_FIELDNO.
	* valprint.c (valprint_check_validity): Make it global, move the
	function comment ...
	* value.h (valprint_check_validity): ... to this new declaration.

gdb/testsuite/
	* gdb.trace/unavailable.exp
	(collect globals: print object on: print derived_partial)
	(collect globals: print object on: print derived_whole)
	(collect globals: print object off: print derived_partial)
	(collect globals: print object off: print derived_whole): Update
	expected output.
@
text
@d478 1
a478 1
	" = $hex \"hello world\"" \
@


1.17
log
@2012-03-01  Pedro Alves  <palves@@redhat.com>

	PR gdb/13767

	gdb/
	* frame.c (read_frame_register_unsigned): New.
	* frame.h (read_frame_register_unsigned): Declare.
	* i387-tdep.c (print_i387_status_word): New parameter `status_p'.
	Handle it.
	(print_i387_control_word): New parameter `control_p'.  Handle it.
	(i387_print_float_info): Handle unavailable float registers.

	gdb/testsuite/
	* gdb.trace/unavailable.exp (gdb_unavailable_floats): New.
	(gdb_collect_globals_test): Call it.
@
text
@d545 1
a545 1
	    " = \\(Derived\\) {<Middle> = {<Base> = <unavailable>, _vptr.Middle = <unavailable>, y = <unavailable>}, _vptr.Derived = $hex, z = <unavailable>}"
d549 1
a549 1
	    " = \\(Derived\\) {<Middle> = {<Base> = {x = 2}, _vptr.Middle = $hex, y = 3}, _vptr.Derived = $hex, z = 4}"
d563 1
a563 1
	    " = {<Middle> = {<Base> = <unavailable>, _vptr.Middle = <unavailable>, y = <unavailable>}, _vptr.Derived = $hex, z = <unavailable>}"
d567 1
a567 1
	    " = {<Middle> = {<Base> = {x = 2}, _vptr.Middle = $hex, y = 3}, _vptr.Derived = $hex, z = 4}"
@


1.16
log
@2012-02-21  Pedro Alves  <palves@@redhat.com>

	* gdb.trace/unavailable.exp (gdb_collect_globals_test): Use
	with_test_prefix.
@
text
@d308 33
d583 1
@


1.15
log
@2012-02-21  Pedro Alves  <palves@@redhat.com>

	* gdb.arch/altivec-abi.exp (altivec_abi_tests): Don't do
	with_test_prefix here.
	(top level): Do it here instead.  Remove `:' from the
	with_test_prefix string.
	* gdb.base/attach-pie-misread.exp: Remove the leading space the
	the suffix `:' from the with_test_prefix prefix string.
	* gdb.base/break-interp.exp: Ditto.
	* gdb.base/catch-load.exp: Ditto.
	* gdb.base/disp-step-syscall.exp: Ditto.
	* gdb.base/jit-so.exp: Ditto.
	* gdb.base/jit.exp: Ditto.
	* gdb.base/sepdebug.exp: Ditto.
	* gdb.base/solib-display.exp: Ditto.
	* gdb.base/solib-overlap.exp: Ditto.
	* gdb.base/watch-cond-infcall.exp: Ditto.
	* gdb.base/watchpoint.exp: Ditto.
	* gdb.dwarf2/dw2-noloc.exp: Ditto.
	* gdb.mi/mi-watch.exp: Ditto.
	* gdb.mi/mi2-watch.exp: Ditto.
	* gdb.threads/non-ldr-exc-1.exp: Ditto.
	* gdb.threads/non-ldr-exc-2.exp: Ditto.
	* gdb.threads/non-ldr-exc-3.exp: Ditto.
	* gdb.threads/non-ldr-exc-4.exp: Ditto.
	* gdb.threads/watchpoint-fork.exp: Ditto.
	* gdb.threads/watchthreads-reorder.exp: Ditto.
	* gdb.trace/change-loc.exp: Ditto.
	* gdb.trace/pending.exp: Ditto.
	* gdb.trace/status-stop.exp: Ditto.
	* gdb.trace/strace.exp: Ditto.
	* gdb.trace/trace-break.exp: Ditto.
	* gdb.trace/unavailable.exp: Ditto.
	* lib/gdb.exp (with_test_prefix): Always prefix with space and
	suffix with colon.  Adjust leading comments.
@
text
@d499 19
a517 23
    global pf_prefix
    set old_pf_prefix $pf_prefix
    append pf_prefix " print object on:"

    # With print object on, printing a pointer may need to fetch the
    # pointed-to object, to check its run-time type.  Make sure that
    # fails gracefully and transparently when the pointer itself is
    # unavailable.
    gdb_test "print virtualp" " = \\(Virtual \\*\\) <unavailable>"

    # no vtable pointer available
    gdb_test "print derived_unavail" \
	" = {<Middle> = <unavailable>, _vptr.Derived = <unavailable>, z = <unavailable>}"

    # vtable pointer available, but nothing else
    gdb_test "print derived_partial" \
	" = \\(Derived\\) {<Middle> = {<Base> = <unavailable>, _vptr.Middle = <unavailable>, y = <unavailable>}, _vptr.Derived = $hex, z = <unavailable>}"

    # whole object available
    gdb_test "print derived_whole" \
	" = \\(Derived\\) {<Middle> = {<Base> = {x = 2}, _vptr.Middle = $hex, y = 3}, _vptr.Derived = $hex, z = 4}"

    set pf_prefix $old_pf_prefix
d521 2
a522 15
    append pf_prefix " print object off:"

    gdb_test "print virtualp" " = \\(Virtual \\*\\) <unavailable>"

    # no vtable pointer available
    gdb_test "print derived_unavail" \
	" = {<Middle> = <unavailable>, _vptr.Derived = <unavailable>, z = <unavailable>}"

    # vtable pointer available, but nothing else
    gdb_test "print derived_partial" \
	" = {<Middle> = {<Base> = <unavailable>, _vptr.Middle = <unavailable>, y = <unavailable>}, _vptr.Derived = $hex, z = <unavailable>}"

    # whole object available
    gdb_test "print derived_whole" \
	" = {<Middle> = {<Base> = {x = 2}, _vptr.Middle = $hex, y = 3}, _vptr.Derived = $hex, z = 4}"
d524 12
a535 1
    set pf_prefix $old_pf_prefix
@


1.14
log
@2012-02-21  Pedro Alves  <palves@@redhat.com>
	    Tom Tromey  <tromey@@redhat.com>

	* lib/gdb.exp: Add description of test prefixes.
	(with_test_prefix): New procedure.
	* gdb.arch/altivec-abi.exp: Use with_test_prefix.
	* gdb.base/attach-pie-misread.exp: Use with_test_prefix.
	* gdb.base/break-interp.exp: Use with_test_prefix.  Use append
	instead of lappend to append to pf_prefix.
	* gdb.base/catch-load.exp: Use with_test_prefix.
	* gdb.base/disp-step-syscall.exp: Use with_test_prefix.
	* gdb.base/jit-so.exp: Use with_test_prefix.
	* gdb.base/jit.exp: Use with_test_prefix.
	* gdb.base/return-nodebug.exp (do_test): Use append instead of
	lappend to append to pf_prefix.
	* gdb.base/sepdebug.exp: Use with_test_prefix.
	* gdb.base/solib-display.exp: Use with_test_prefix.
	* gdb.base/solib-overlap.exp: Use with_test_prefix.
	* gdb.base/watch-cond-infcall.exp: Use with_test_prefix.
	* gdb.base/watchpoint.exp: Use with_test_prefix.
	* gdb.dwarf2/dw2-noloc.exp: Use with_test_prefix.
	* gdb.mi/mi-watch.exp: Use with_test_prefix.
	* gdb.mi/mi2-watch.exp: Use with_test_prefix.
	* gdb.threads/non-ldr-exc-1.exp: Use with_test_prefix.
	* gdb.threads/non-ldr-exc-2.exp: Use with_test_prefix.
	* gdb.threads/non-ldr-exc-3.exp: Use with_test_prefix.
	* gdb.threads/non-ldr-exc-4.exp: Use with_test_prefix.
	* gdb.threads/watchpoint-fork.exp: Use with_test_prefix.  Use
	append instead of lappend to append to pf_prefix.
	* gdb.threads/watchthreads-reorder.exp: Use with_test_prefix.
	* gdb.trace/change-loc.exp: Use with_test_prefix.
	* gdb.trace/pending.exp: Use with_test_prefix.
	* gdb.trace/status-stop.exp: Use with_test_prefix.
	* gdb.trace/strace.exp: Use with_test_prefix.
	* gdb.trace/trace-break.exp: Use with_test_prefix.
	* gdb.trace/unavailable.exp: Use with_test_prefix.  Use append
	instead of lappend to append to pf_prefix.
@
text
@d139 1
a139 1
proc gdb_collect_args_test {} { with_test_prefix " unavailable arguments:" {
d206 1
a206 1
proc gdb_collect_locals_test { func msg } { with_test_prefix " unavailable locals: $msg:" {
d257 1
a257 1
proc gdb_unavailable_registers_test { } { with_test_prefix " unavailable registers:" {
d308 1
a308 1
proc gdb_collect_globals_test { } { with_test_prefix " collect globals:" {
@


1.13
log
@2012-02-15  Pedro Alves  <palves@@redhat.com>

	* gdb.trace/backtrace.exp: Issue UNSUPPORTED instead of PASS when
	the target doesn't support tracepoints.
	* gdb.trace/circ.exp: Ditto.
	* gdb.trace/collection.exp: Ditto.
	* gdb.trace/packetlen.exp: Ditto.
	* gdb.trace/passc-dyn.exp: Ditto.
	* gdb.trace/report.exp: Ditto.
	* gdb.trace/tfind.exp: Ditto.
	* gdb.trace/tspeed.exp: Ditto.
	* gdb.trace/tsv.exp: Ditto.
	* gdb.trace/unavailable.exp: Ditto.
	* gdb.trace/while-dyn.exp: Ditto.
@
text
@d139 1
a139 1
proc gdb_collect_args_test {} {
a141 4
    global pf_prefix

    set old_pf_prefix $pf_prefix
    set pf_prefix "$pf_prefix unavailable arguments:"
d204 1
d206 1
a206 4
    set pf_prefix $old_pf_prefix
}

proc gdb_collect_locals_test { func msg } {
a208 4
    global pf_prefix

    set old_pf_prefix $pf_prefix
    set pf_prefix "$pf_prefix unavailable locals: $msg:"
d255 1
d257 1
a257 4
    set pf_prefix $old_pf_prefix
}

proc gdb_unavailable_registers_test { } {
a260 4
    global pf_prefix

    set old_pf_prefix $pf_prefix
    set pf_prefix "$pf_prefix unavailable registers:"
d306 1
d308 1
a308 4
    set pf_prefix $old_pf_prefix
}

proc gdb_collect_globals_test { } {
a312 4
    global pf_prefix

    set old_pf_prefix $pf_prefix
    set pf_prefix "$pf_prefix collect globals:"
d499 3
a501 2
    set old_pf_prefix_2 $pf_prefix
    set pf_prefix "$pf_prefix print object on:"
d521 1
a521 1
    set pf_prefix $old_pf_prefix_2
d525 1
a525 1
    set pf_prefix "$pf_prefix print object off:"
d541 1
a541 1
    set pf_prefix $old_pf_prefix_2
d551 1
a551 3

    set pf_prefix $old_pf_prefix
}
@


1.12
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@a588 2
# We generously give ourselves one "pass" if we successfully
# detect that this test cannot be run on this target!
d590 1
a590 1
    pass "Current target does not support trace"
@


1.11
log
@gdb/testsuite/
	Fix compatibility with x32 arch.
	* testsuite/gdb.dwarf2/typeddwarf.exp: Check also is_lp64_target.
	* testsuite/gdb.trace/backtrace.exp: Use is_amd64_regs_target and
	is_x86_like_target.
	* testsuite/gdb.trace/collection.exp: Likewise.
	* testsuite/gdb.trace/report.exp: Likewise.
	* testsuite/gdb.trace/unavailable.exp: Likewise.
	* testsuite/gdb.trace/while-dyn.exp: Likewise.
	* testsuite/lib/gdb.exp (is_amd64_regs_target): New function.
	(is_x86_like_target): Check also is_amd64_regs_target.
@
text
@d1 1
a1 2
# Copyright 1998, 2005, 2007, 2008, 2009, 2010, 2011
# Free Software Foundation, Inc.
@


1.11.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d1 2
a2 1
# Copyright 1998, 2005, 2007-2012 Free Software Foundation, Inc.
@


1.10
log
@gdb/testsuite/
	* gdb.trace/backtrace.exp: Use is_lp64_target to check 64bit target.
	* gdb.trace/collection.exp: Likewise.
	* gdb.trace/report.exp: Likewise.
	* gdb.trace/unavailable.exp: Likewise.
	* gdb.trace/while-dyn.exp: Likewise.
@
text
@d33 1
a33 1
if {([istarget "x86_64-*"] || [istarget "i?86-*"]) && [is_lp64_target]} then {
d37 1
a37 1
} elseif {[istarget "x86_64-*"] || [istarget "i?86-*"]} then {
d298 1
a298 1
    if {$pcreg == "rip"} then {
d303 1
a303 1
    } elseif {$pcreg == "eip"} then {
@


1.9
log
@	gdb/
	* exceptions.c (throw_exception): Don't disable the current
	display.
	* printcmd.c (disable_current_display_cleanup): New function.
	(do_one_display): Install a cleanup to disable the current display
	if doing the display throws.

	gdb/testsuite/
	* gdb.trace/unavailable.exp (test_maybe_regvar_display): New
	procedure.
	(gdb_collect_args_test, gdb_collect_locals_test): Use it.
@
text
@d33 1
a33 1
if [istarget "x86_64-*"] then {
d37 1
a37 1
} elseif [istarget "i?86-*"] then {
d298 1
a298 1
    if [istarget "x86_64-*"] then {
d303 1
a303 1
    } elseif [istarget "i?86-*"] then {
@


1.8
log
@	gdb/testsuite/
	* gdb.trace/unavailable.cc (args_test_func, local_test_func)
	(reglocal_test_func, statlocal_test_func): New functions.
	(globals_test_func): Call new functions.
	* gdb.trace/unavailable.exp (gdb_collect_args_test)
	(gdb_collect_locals_test): New procedure.
	(gdb_trace_collection_test): Call new procedures.
@
text
@d106 30
d204 2
d261 2
@


1.7
log
@	gdb/
	* findvar.c (value_of_register): Mark the value as unavailable, if
	the register is unavailable.
	* frame.h (frame_register_unwind): New `unavailablep' parameter.
	(frame_register): New `unavailablep' parameter.
	(frame_register_read): Update comment.
	* frame.c (frame_register_unwind): New `unavailablep' parameter.
	Set it if the register is unavailable.  If the register is
	unavailable, clear the output buffer.
	(frame_register): New `unavailablep' parameter.  Pass it down.
	(frame_unwind_register): Adjust.
	(put_frame_register): Adjust.
	(frame_register_read): Adjust.  Also return false if the register
	is not available.
	(frame_register_unwind_location): Adjust.
	* sentinel-frame.c (sentinel_frame_prev_register): If the register
	is unavailable, mark the value accordingly.
	* stack.c (frame_info): Handle unavailable registers.

	gdb/testsuite/
	* gdb.trace/unavailable.exp (fpreg, spreg, pcreg): Define.
	(test_register, test_register_unavailable): New procedures.
	(gdb_unavailable_registers_test): New procedure.
	(gdb_trace_collection_test): Call it.
@
text
@d110 126
d546 5
@


1.6
log
@	gdb/
	* exceptions.h (NOT_AVAILABLE_ERROR): New error.
	* value.c: Include "exceptions.h".
	(require_available): Throw NOT_AVAILABLE_ERROR instead of a
	generic error.
	* cp-abi.c: Include gdb_assert.h.
	(baseclass_offset): Add `embedded_offset' and `val' parameters.
	Assert the method is implemented.  Wrap NOT_AVAILABLE_ERROR
	errors.
	* cp-abi.h (baseclass_offset): Add `embedded_offset' and `val'
	parameters.  No longer returns -1 on error.
	(struct cp_abi_ops) <baseclass_offset>: Add `embedded_offset' and
	`val' parameters.
	* cp-valprint.c: Include exceptions.h.
	(cp_print_value): Handle NOT_AVAILABLE_ERROR errors when fetching
	the baseclass_offset.  Handle unavailable base classes.  Use
	val_print_invalid_address.
	* p-valprint.c: Include exceptions.h.
	(pascal_object_print_value): Handle NOT_AVAILABLE_ERROR errors
	when fetching the baseclass_offset.  No longer expect
	baseclass_offset returning -1.  Handle unavailable base classes.
	Use val_print_invalid_address.
	* valops.c (dynamic_cast_check_1): Rename `contents' parameter to
	`valaddr' parameter, and change its type to gdb_byte pointer.  Add
	`embedded_offset' and `val' parameters.  Adjust.
	(dynamic_cast_check_2): Rename `contents' parameter to `valaddr'
	parameter, and change its type to gdb_byte pointer.  Add
	`embedded_offset' and `val' parameters.  Adjust.  No longer expect
	baseclass_offset returning -1.
	(value_dynamic_cast): Use value_contents_for_printing rather than
	value_contents.  Adjust.
	(search_struct_field): No longer expect baseclass_offset returning
	-1.
	(search_struct_method): If reading memory from the target is
	necessary, wrap it in a new value to pass to baseclass_offset.  No
	longer expect baseclass_offset returning -1.
	(find_method_list): No longer expect baseclass_offset returning
	-1.  Use value_contents_for_printing rather than value_contents.
	* valprint.c (val_print_invalid_address): New function.
	* valprint.h (val_print_invalid_address): Declare.
	* gdbtypes.c (is_unique_ancestor_worker): New `embedded_offset'
	and `val' parameters.  No longer expect baseclass_offset returning
	-1.  Adjust.
	* gnu-v2-abi.c: Include "exceptions.h".
	(gnuv2_baseclass_offset): Add `embedded_offset' and `val'
	parameters.  Handle unavailable memory.  Recurse through
	gnuv2_baseclass_offset directly, rather than through
	baseclass_offset.  No longer returns -1 on not found, instead
	throw an error.
	* gnu-v3-abi.c (gnuv3_baseclass_offset): Add `embedded_offset' and
	`val' parameters.  Adjust.

	gdb/testsuite/
	* gdb.trace/unavailable.cc (class Base, class Middle, class
	Derived): New types.
	(derived_unavail, derived_partial, derived_whole): New globals.
	(virtual_partial): New global.
	(virtualp): Point at virtual_partial.
	* gdb.trace/unavailable.exp (gdb_collect_globals_test): Add tests
	related to unavailable vptr.
@
text
@d33 14
d51 24
d110 57
d419 1
@


1.5
log
@	gdb/testuite/
	* gdb.trace/unavailable.cc (a, b, c): New globals.
	(main): Set and clear them.
	* gdb.trace/unavailable.exp (gdb_collect_globals_test): Collect
	`a' and `c', and check that `b' isn't collected, although `a' and
	`c' are.

	gdb/
	* tracepoint.c (memrange_sortmerge): Don't merge ranges that are
	almost but not quite adjacent.
@
text
@d90 3
d112 6
a117 1
	"collect g_structref_p" "^$"
d267 3
d276 14
d292 23
@


1.4
log
@	gdb/testsuite/
	* gdb.trace/unavailable.cc (struct Virtual): New.
	(virtualp): New global pointer.
	* gdb.trace/unavailable.exp (gdb_collect_globals_test): Test
	printing a pointer to an object whose type has a vtable, with
	print object on.

	gdb/
	* value.h (value_entirely_available): Declare.
	* value.c (value_entirely_available): New function.
	* c-valprint.c (c_value_print): Don't try fetching the pointer's
	real type if the pointer is unavailable.
@
text
@d95 3
d151 9
@


1.3
log
@	gdb/
	* valops.c (value_repeat): Use read_value_memory instead of
	read_memory.

	gdb/testsuite/
	* gdb.trace/unavailable.exp (gdb_collect_globals_test): Test that
	value repeat handles unavailableness.
@
text
@d106 1
a106 1
	"collect g_structref_p" "^$" \
d245 10
@


1.2
log
@	gdb/
	* value.h (value_contents_copy, value_contents_copy_raw): Declare.
	* value.c (value_contents_copy_raw, value_contents_copy): New
	functions.
	(value_primitive_field): Use value_contents_copy_raw instead of
	memcpy.
	* valops.c (value_fetch_lazy): Use value_contents_copy instead of
	memcpy.
	(value_array, value_slice): Ditto.
	* valarith.c (value_subscripted_rvalue): Use
	value_contents_copy_raw instead of memcpy.

	gdb/testsuite/
	* gdb.trace/unavailable.exp (gdb_collect_globals_test): Add new
	tests for building arrays from unavailable values, subscripting
	non-memory rvalue unvailable arrays, and accessing fields or
	baseclasses of non-lazy unavailable values,
	* gdb.trace/unavailable.cc (small_struct, small_struct_b): New
	struct types.
	(g_smallstruct, g_smallstruct_b): New globals.
@
text
@d158 3
@


1.1
log
@	gdb/testsuite/
	* gdb.trace/unavailable.cc, gdb.trace/unavailable.exp: New files.
@
text
@d217 25
@

