head	1.3;
access;
symbols
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	gdb_5_1_0_1-2002-01-03-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.1.1.1
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.12
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.10
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.8
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	dberlin-typesystem-branch:1.1.1.1.0.6
	dberlin-typesystem-branchpoint:1.1.1.1
	gdb-post-ptid_t-2001-05-03:1.1.1.1
	gdb-pre-ptid_t-2001-05-03:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb-post-protoization-2000-07-29:1.1.1.1
	gdb-pre-protoization-2000-07-29:1.1.1.1
	gdb-premipsmulti-2000-06-06-branch:1.1.1.1.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.1
	gdb-post-params-removal-2000-06-04:1.1.1.1
	gdb-pre-params-removal-2000-06-04:1.1.1.1
	gdb-post-params-removal-2000-05-28:1.1.1.1
	gdb-pre-params-removal-2000-05-28:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	gdb-2000-02-04:1.1.1.1
	gdb-2000-02-02:1.1.1.1
	gdb-2000-02-01:1.1.1.1
	gdb-2000-01-31:1.1.1.1
	gdb-2000-01-26:1.1.1.1
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	gdb-2000-01-10:1.1.1.1
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	gdb-1999-11-16:1.1.1.1
	gdb-1999-11-08:1.1.1.1
	gdb-1999-11-01:1.1.1.1
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.3
date	2002.05.04.15.18.21;	author cagney;	state dead;
branches;
next	1.2;

1.2
date	2002.01.19.03.48.20;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.08.16.19.55.54;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.08.16.19.55.54;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.3
log
@* gdb.base/default.exp: Remove obsolete code.
* gdb.c++/misc.exp: Ditto.  Update copyright.
* gdb.c++/cplusfuncs.exp: Ditto.  Update copyright.
* gdb.base/whatis.exp: Ditto.  Update copyright.
* gdb.base/scope.exp: Ditto.  Update copyright.
* gdb.base/ptype.exp: Ditto.  Update copyright.
* gdb.base/printcmds.exp: Ditto.  Update copyright.
* gdb.base/opaque.exp: Ditto.  Update copyright.
* gdb.base/list.exp: Ditto.
* gdb.base/funcargs.exp: Ditto.  Update copyright.
* gdb.hp/gdb.threads-hp/usrthbasic.c: Delete.
* gdb.hp/gdb.threads-hp/usrthbasic.exp: Delete.
* gdb.hp/gdb.threads-hp/usrthcore.c: Delete.
* gdb.hp/gdb.threads-hp/usrthcore.exp: Delete.
* gdb.hp/gdb.threads-hp/usrthfork.c: Delete.
* gdb.hp/gdb.threads-hp/usrthfork.exp: Delete.
@
text
@/* OBSOLETE #include <stdio.h> */
/* OBSOLETE  */
/* OBSOLETE /* #include "config.h" */ */
/* OBSOLETE #define HAVE_PTHREAD_H */
/* OBSOLETE #define __hpux__ */
/* OBSOLETE #define __osf__ */
/* OBSOLETE  */
/* OBSOLETE #ifndef HAVE_PTHREAD_H */
/* OBSOLETE  */
/* OBSOLETE /* Don't even try to compile.  In fact, cause a syntax error that we can */
/* OBSOLETE    look for as a compiler error message and know that we have no pthread */
/* OBSOLETE    support.  In that case we can just suppress the test completely. */ */
/* OBSOLETE  */
/* OBSOLETE #error "no posix threads support" */
/* OBSOLETE  */
/* OBSOLETE #else */
/* OBSOLETE  */
/* OBSOLETE /* OK.  We have the right header.  If we try to compile this and fail, then */
/* OBSOLETE    there is something wrong and the user should know about it so the testsuite */
/* OBSOLETE    should issue an ERROR result.. */ */
/* OBSOLETE  */
/* OBSOLETE #ifdef __linux__ */
/* OBSOLETE #define  _MIT_POSIX_THREADS 1	/* Linux (or at least RedHat 4.0) needs this */ */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE #include <pthread.h> */
/* OBSOLETE  */
/* OBSOLETE /* Under OSF 2.0 & 3.0 and HPUX 10, the second arg of pthread_create */
/* OBSOLETE    is prototyped to be just a "pthread_attr_t", while under Solaris it */
/* OBSOLETE    is a "pthread_attr_t *".  Arg! */ */
/* OBSOLETE  */
/* OBSOLETE #if defined (__osf__) || defined (__hpux__) */
/* OBSOLETE #define PTHREAD_CREATE_ARG2(arg) arg */
/* OBSOLETE #define PTHREAD_CREATE_NULL_ARG2 null_attr */
/* OBSOLETE static pthread_attr_t null_attr; */
/* OBSOLETE #else */
/* OBSOLETE #define PTHREAD_CREATE_ARG2(arg) &arg */
/* OBSOLETE #define PTHREAD_CREATE_NULL_ARG2 NULL */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE static int verbose = 0; */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE common_routine (arg) */
/* OBSOLETE      int arg; */
/* OBSOLETE { */
/* OBSOLETE   static int from_thread1; */
/* OBSOLETE   static int from_thread2; */
/* OBSOLETE   static int from_main; */
/* OBSOLETE   static int hits; */
/* OBSOLETE   static int full_coverage; */
/* OBSOLETE  */
/* OBSOLETE   if (verbose) printf("common_routine (%d)\n", arg); */
/* OBSOLETE   hits++; */
/* OBSOLETE   switch (arg) */
/* OBSOLETE     { */
/* OBSOLETE     case 0: */
/* OBSOLETE       from_main++; */
/* OBSOLETE       break; */
/* OBSOLETE     case 1: */
/* OBSOLETE       from_thread1++; */
/* OBSOLETE       break; */
/* OBSOLETE     case 2: */
/* OBSOLETE       from_thread2++; */
/* OBSOLETE       break; */
/* OBSOLETE     } */
/* OBSOLETE   if (from_main && from_thread1 && from_thread2) */
/* OBSOLETE     full_coverage = 1; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static void * */
/* OBSOLETE thread1 (void *arg) */
/* OBSOLETE { */
/* OBSOLETE   int i; */
/* OBSOLETE   int z = 0; */
/* OBSOLETE  */
/* OBSOLETE   if (verbose) printf ("thread1 (%0x) ; pid = %d\n", arg, getpid ()); */
/* OBSOLETE   for (i=1; i <= 10000000; i++) */
/* OBSOLETE     { */
/* OBSOLETE       if (verbose) printf("thread1 %d\n", pthread_self ()); */
/* OBSOLETE       z += i; */
/* OBSOLETE       common_routine (1); */
/* OBSOLETE       sleep(1); */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static void * */
/* OBSOLETE thread2 (void * arg) */
/* OBSOLETE { */
/* OBSOLETE   int i; */
/* OBSOLETE   int k = 0; */
/* OBSOLETE  */
/* OBSOLETE   if (verbose) printf ("thread2 (%0x) ; pid = %d\n", arg, getpid ()); */
/* OBSOLETE   for (i=1; i <= 10000000; i++) */
/* OBSOLETE     { */
/* OBSOLETE       if (verbose) printf("thread2 %d\n", pthread_self ()); */
/* OBSOLETE       k += i; */
/* OBSOLETE       common_routine (2); */
/* OBSOLETE       sleep(1); */
/* OBSOLETE     } */
/* OBSOLETE   sleep(100); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE int */
/* OBSOLETE foo (a, b, c) */
/* OBSOLETE      int a, b, c; */
/* OBSOLETE { */
/* OBSOLETE   int d, e, f; */
/* OBSOLETE  */
/* OBSOLETE   if (verbose) printf("a=%d\n", a); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE main(argc, argv) */
/* OBSOLETE      int argc; */
/* OBSOLETE      char **argv; */
/* OBSOLETE { */
/* OBSOLETE   pthread_t tid1, tid2; */
/* OBSOLETE   int j; */
/* OBSOLETE   int t = 0; */
/* OBSOLETE   void (*xxx) (); */
/* OBSOLETE   pthread_attr_t attr; */
/* OBSOLETE  */
/* OBSOLETE   if (verbose) printf ("pid = %d\n", getpid()); */
/* OBSOLETE  */
/* OBSOLETE   foo (1, 2, 3); */
/* OBSOLETE  */
/* OBSOLETE #ifndef __osf__ */
/* OBSOLETE   if (pthread_attr_init (&attr)) */
/* OBSOLETE     { */
/* OBSOLETE       perror ("pthread_attr_init 1"); */
/* OBSOLETE       exit (1); */
/* OBSOLETE     } */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE #ifdef PTHREAD_SCOPE_SYSTEM */
/* OBSOLETE   if (pthread_attr_setscope (&attr, PTHREAD_SCOPE_SYSTEM)) */
/* OBSOLETE     { */
/* OBSOLETE       perror ("pthread_attr_setscope 1"); */
/* OBSOLETE       exit (1); */
/* OBSOLETE     } */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE   if (pthread_create (&tid1, pthread_attr_default, thread1, (void *) 0xfeedface)) */
/* OBSOLETE     { */
/* OBSOLETE       perror ("pthread_create 1"); */
/* OBSOLETE       exit (1); */
/* OBSOLETE     } */
/* OBSOLETE   if (verbose) printf ("Made thread %d\n", tid1); */
/* OBSOLETE   sleep (1); */
/* OBSOLETE  */
/* OBSOLETE   if (pthread_create (&tid2, null_attr, thread2, (void *) 0xdeadbeef)) */
/* OBSOLETE     { */
/* OBSOLETE       perror ("pthread_create 2"); */
/* OBSOLETE       exit (1); */
/* OBSOLETE     } */
/* OBSOLETE   if (verbose) printf("Made thread %d\n", tid2); */
/* OBSOLETE  */
/* OBSOLETE   sleep (1); */
/* OBSOLETE  */
/* OBSOLETE   for (j = 1; j <= 10000000; j++) */
/* OBSOLETE     { */
/* OBSOLETE       if (verbose) printf("top %d\n", pthread_self ()); */
/* OBSOLETE       common_routine (0); */
/* OBSOLETE       sleep(1); */
/* OBSOLETE       t += j; */
/* OBSOLETE     } */
/* OBSOLETE    */
/* OBSOLETE   exit(0); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE #endif	/* ifndef HAVE_PTHREAD_H */ */
@


1.2
log
@Mark testsuite/gdb.hp/gdb.threads-hp/ as obsolete.
@
text
@@


1.1
log
@Initial revision
@
text
@d1 171
a171 171
#include <stdio.h>

/* #include "config.h" */
#define HAVE_PTHREAD_H
#define __hpux__
#define __osf__

#ifndef HAVE_PTHREAD_H

/* Don't even try to compile.  In fact, cause a syntax error that we can
   look for as a compiler error message and know that we have no pthread
   support.  In that case we can just suppress the test completely. */

#error "no posix threads support"

#else

/* OK.  We have the right header.  If we try to compile this and fail, then
   there is something wrong and the user should know about it so the testsuite
   should issue an ERROR result.. */

#ifdef __linux__
#define  _MIT_POSIX_THREADS 1	/* Linux (or at least RedHat 4.0) needs this */
#endif

#include <pthread.h>

/* Under OSF 2.0 & 3.0 and HPUX 10, the second arg of pthread_create
   is prototyped to be just a "pthread_attr_t", while under Solaris it
   is a "pthread_attr_t *".  Arg! */

#if defined (__osf__) || defined (__hpux__)
#define PTHREAD_CREATE_ARG2(arg) arg
#define PTHREAD_CREATE_NULL_ARG2 null_attr
static pthread_attr_t null_attr;
#else
#define PTHREAD_CREATE_ARG2(arg) &arg
#define PTHREAD_CREATE_NULL_ARG2 NULL
#endif

static int verbose = 0;

static void
common_routine (arg)
     int arg;
{
  static int from_thread1;
  static int from_thread2;
  static int from_main;
  static int hits;
  static int full_coverage;

  if (verbose) printf("common_routine (%d)\n", arg);
  hits++;
  switch (arg)
    {
    case 0:
      from_main++;
      break;
    case 1:
      from_thread1++;
      break;
    case 2:
      from_thread2++;
      break;
    }
  if (from_main && from_thread1 && from_thread2)
    full_coverage = 1;
}

static void *
thread1 (void *arg)
{
  int i;
  int z = 0;

  if (verbose) printf ("thread1 (%0x) ; pid = %d\n", arg, getpid ());
  for (i=1; i <= 10000000; i++)
    {
      if (verbose) printf("thread1 %d\n", pthread_self ());
      z += i;
      common_routine (1);
      sleep(1);
    }
}

static void *
thread2 (void * arg)
{
  int i;
  int k = 0;

  if (verbose) printf ("thread2 (%0x) ; pid = %d\n", arg, getpid ());
  for (i=1; i <= 10000000; i++)
    {
      if (verbose) printf("thread2 %d\n", pthread_self ());
      k += i;
      common_routine (2);
      sleep(1);
    }
  sleep(100);
}

int
foo (a, b, c)
     int a, b, c;
{
  int d, e, f;

  if (verbose) printf("a=%d\n", a);
}

main(argc, argv)
     int argc;
     char **argv;
{
  pthread_t tid1, tid2;
  int j;
  int t = 0;
  void (*xxx) ();
  pthread_attr_t attr;

  if (verbose) printf ("pid = %d\n", getpid());

  foo (1, 2, 3);

#ifndef __osf__
  if (pthread_attr_init (&attr))
    {
      perror ("pthread_attr_init 1");
      exit (1);
    }
#endif

#ifdef PTHREAD_SCOPE_SYSTEM
  if (pthread_attr_setscope (&attr, PTHREAD_SCOPE_SYSTEM))
    {
      perror ("pthread_attr_setscope 1");
      exit (1);
    }
#endif

  if (pthread_create (&tid1, pthread_attr_default, thread1, (void *) 0xfeedface))
    {
      perror ("pthread_create 1");
      exit (1);
    }
  if (verbose) printf ("Made thread %d\n", tid1);
  sleep (1);

  if (pthread_create (&tid2, null_attr, thread2, (void *) 0xdeadbeef))
    {
      perror ("pthread_create 2");
      exit (1);
    }
  if (verbose) printf("Made thread %d\n", tid2);

  sleep (1);

  for (j = 1; j <= 10000000; j++)
    {
      if (verbose) printf("top %d\n", pthread_self ());
      common_routine (0);
      sleep(1);
      t += j;
    }
  
  exit(0);
}

#endif	/* ifndef HAVE_PTHREAD_H */
@


1.1.1.1
log
@import gdb-1999-08-16 snapshot
@
text
@@
