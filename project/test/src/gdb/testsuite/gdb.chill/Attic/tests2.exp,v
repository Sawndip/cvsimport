head	1.4;
access;
symbols
	gdb_5_3-2002-12-12-release:1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.10
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	carlton_dictionary-branch:1.3.0.8
	carlton_dictionary-20020920-branchpoint:1.3
	gdb_5_3-branch:1.3.0.6
	gdb_5_3-2002-09-04-branchpoint:1.3
	kseitz_interps-20020829-merge:1.3
	cagney_sysregs-20020825-branch:1.3.0.4
	cagney_sysregs-20020825-branchpoint:1.3
	readline_4_3-import-branch:1.3.0.2
	readline_4_3-import-branchpoint:1.3
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.16
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.14
	cagney_regbuf-20020515-branchpoint:1.2
	jimb-macro-020506-branch:1.2.0.12
	jimb-macro-020506-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.10
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.2
	gdb_5_1_0_1-2002-01-03-release:1.2
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.2.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.2
	gdb_5_1-2001-11-21-release:1.2
	gdb_s390-2001-09-26-branch:1.2.0.6
	gdb_s390-2001-09-26-branchpoint:1.2
	gdb_5_1-2001-07-29-branch:1.2.0.4
	gdb_5_1-2001-07-29-branchpoint:1.2
	dberlin-typesystem-branch:1.2.0.2
	dberlin-typesystem-branchpoint:1.2
	gdb-post-ptid_t-2001-05-03:1.2
	gdb-pre-ptid_t-2001-05-03:1.2
	insight-precleanup-2001-01-01:1.1.1.2
	gdb-post-protoization-2000-07-29:1.1.1.2
	gdb-pre-protoization-2000-07-29:1.1.1.2
	gdb-premipsmulti-2000-06-06-branch:1.1.1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.2
	gdb-post-params-removal-2000-06-04:1.1.1.2
	gdb-pre-params-removal-2000-06-04:1.1.1.2
	gdb-post-params-removal-2000-05-28:1.1.1.2
	gdb-pre-params-removal-2000-05-28:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	insight-2000-02-04:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.4
date	2002.12.16.19.33.52;	author cagney;	state dead;
branches;
next	1.3;

1.3
date	2002.08.02.00.25.23;	author cagney;	state Exp;
branches
	1.3.8.1
	1.3.10.1;
next	1.2;

1.2
date	2001.03.06.08.21.55;	author kevinb;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.04.16.01.34.33;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.33;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.27.33;	author shebs;	state Exp;
branches;
next	;

1.2.16.1
date	2002.08.09.18.34.34;	author kseitz;	state Exp;
branches;
next	;

1.3.8.1
date	2002.12.23.19.39.18;	author carlton;	state dead;
branches;
next	;

1.3.10.1
date	2003.12.14.20.27.52;	author drow;	state dead;
branches;
next	;


desc
@@


1.4
log
@Remove obsolete testsuite code.
@
text
@# OBSOLETE # Copyright 1992, 1995, 1996, 1997, 1999 Free Software Foundation, Inc.
# OBSOLETE 
# OBSOLETE # This program is free software; you can redistribute it and/or modify
# OBSOLETE # it under the terms of the GNU General Public License as published by
# OBSOLETE # the Free Software Foundation; either version 2 of the License, or
# OBSOLETE # (at your option) any later version.
# OBSOLETE # 
# OBSOLETE # This program is distributed in the hope that it will be useful,
# OBSOLETE # but WITHOUT ANY WARRANTY; without even the implied warranty of
# OBSOLETE # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# OBSOLETE # GNU General Public License for more details.
# OBSOLETE # 
# OBSOLETE # You should have received a copy of the GNU General Public License
# OBSOLETE # along with this program; if not, write to the Free Software
# OBSOLETE # Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
# OBSOLETE 
# OBSOLETE # Please email any bugs, comments, and/or additions to this file to:
# OBSOLETE # bug-gdb@@prep.ai.mit.edu
# OBSOLETE 
# OBSOLETE if $tracelevel then {
# OBSOLETE 	strace $tracelevel
# OBSOLETE }
# OBSOLETE 
# OBSOLETE if [skip_chill_tests] then { continue }
# OBSOLETE 
# OBSOLETE set prms_id 0
# OBSOLETE set bug_id 0
# OBSOLETE 
# OBSOLETE # Set the current language to chill.  This counts as a test.  If it
# OBSOLETE # fails, then we skip the other tests.
# OBSOLETE 
# OBSOLETE set testfile "tests2"
# OBSOLETE set srcfile ${srcdir}/$subdir/${testfile}.ch
# OBSOLETE set binfile ${objdir}/${subdir}/${testfile}.exe
# OBSOLETE if  { [compile "${srcfile} -g -w -o ${binfile} ${CHILL_RT0} ${CHILL_LIB}"] != "" } {
# OBSOLETE     perror "Couldn't compile ${srcfile}"
# OBSOLETE     return -1
# OBSOLETE }
# OBSOLETE 
# OBSOLETE global infinity
# OBSOLETE if [istarget "i*86-*-sysv4*"] then {
# OBSOLETE     set infinity "inf"
# OBSOLETE } else {
# OBSOLETE     set infinity "Infinity"
# OBSOLETE }
# OBSOLETE 
# OBSOLETE proc set_lang_chill {} {
# OBSOLETE     global gdb_prompt
# OBSOLETE     global binfile objdir subdir
# OBSOLETE 
# OBSOLETE     if ![file exists $objdir/$subdir/$binfile] then {
# OBSOLETE 	return 0
# OBSOLETE     }
# OBSOLETE     verbose "loading file '$objdir/$subdir/$binfile'"
# OBSOLETE     gdb_load $objdir/$subdir/$binfile
# OBSOLETE 
# OBSOLETE     send_gdb "set language chill\n"
# OBSOLETE     gdb_expect {
# OBSOLETE 	-re ".*$gdb_prompt $" {}
# OBSOLETE 	timeout { fail "set language chill (timeout)" ; return 0 }
# OBSOLETE     }
# OBSOLETE 
# OBSOLETE     send_gdb "show language\n"
# OBSOLETE     gdb_expect {
# OBSOLETE 	-re ".* source language is \"chill\".*$gdb_prompt $" {
# OBSOLETE 	    pass "set language to \"chill\""
# OBSOLETE 	    send_gdb "break dummyfunc\n"
# OBSOLETE 	    gdb_expect {
# OBSOLETE 		-re ".*$gdb_prompt $" {
# OBSOLETE 		    send_gdb "run\n"
# OBSOLETE 		    gdb_expect -re ".*$gdb_prompt $" {}
# OBSOLETE 		    return 1
# OBSOLETE 		}
# OBSOLETE 		timeout {
# OBSOLETE 		    fail "can't set breakpoint (timeout)"
# OBSOLETE 		    return 0
# OBSOLETE 		}
# OBSOLETE 	    }
# OBSOLETE 	}
# OBSOLETE 	-re ".*$gdb_prompt $" {
# OBSOLETE 	    fail "setting language to \"chill\""
# OBSOLETE 	    return 0
# OBSOLETE 	}
# OBSOLETE 	timeout {
# OBSOLETE 	    fail "can't show language (timeout)"
# OBSOLETE 	    return 0
# OBSOLETE 	}
# OBSOLETE     }
# OBSOLETE }
# OBSOLETE 
# OBSOLETE # checks if structure was accessed correctly
# OBSOLETE proc test_write { args } {
# OBSOLETE     global gdb_prompt
# OBSOLETE 
# OBSOLETE     if [llength $args]==5 then {
# OBSOLETE 	set message [lindex $args 4]
# OBSOLETE 	set extended [lindex $args 3]
# OBSOLETE 	set matchval [lindex $args 2]
# OBSOLETE     } elseif [llength $args]==4 then {
# OBSOLETE 	set message [lindex $args 3]
# OBSOLETE 	set matchval [lindex $args 2]
# OBSOLETE 	set extended ""
# OBSOLETE     } elseif [llength $args]==3 then {
# OBSOLETE 	set message [lindex $args 2]
# OBSOLETE 	set extended ""
# OBSOLETE     } else {
# OBSOLETE 	warning "test ($args) write called with wrong number of arguments"
# OBSOLETE 	return 
# OBSOLETE     }
# OBSOLETE 
# OBSOLETE     set location [lindex $args 0]
# OBSOLETE     set value [lindex $args 1]
# OBSOLETE     if ![info exists matchval] then {
# OBSOLETE 	set matchval $value
# OBSOLETE     }
# OBSOLETE     verbose "loc: $location, val: $value, msg: $message, ext: $extended, match: $matchval"
# OBSOLETE 
# OBSOLETE     verbose "setting var $value..."
# OBSOLETE     send_gdb "set var $location.m$extended := $value\n"
# OBSOLETE     gdb_expect -re ".*$gdb_prompt $" {}
# OBSOLETE     gdb_test "print $location" \
# OBSOLETE       ".*= \[\[\]\\.p1: 2863311530, \\.m: $matchval, \\.p2: 1431655765\[\]\]"\
# OBSOLETE       "$message"
# OBSOLETE }
# OBSOLETE 
# OBSOLETE # test write access from gdb (setvar x:=y) from gdb
# OBSOLETE proc write_access { } {
# OBSOLETE     global infinity
# OBSOLETE 
# OBSOLETE     verbose "testing write access to locations"
# OBSOLETE     
# OBSOLETE     # discrete modes
# OBSOLETE     test_write b1 127 "byte write 1"
# OBSOLETE     test_write b1 -128 "byte write 2"
# OBSOLETE     test_write b1 0 "byte write 3"
# OBSOLETE     test_write ub1 255 "ubyte write 1"
# OBSOLETE     test_write ub1 0 "ubyte write 2"
# OBSOLETE     test_write ub1 42 "ubyte write 3"
# OBSOLETE     test_write i1 32767 "int write 1"
# OBSOLETE     test_write i1 -32768 "int write 2"
# OBSOLETE     test_write i1 0 "int write 3"
# OBSOLETE     test_write ui1 65535 "uint write 1"
# OBSOLETE     test_write ui1 0 "uint write 2"
# OBSOLETE     test_write ui1 123 "uint write 3"
# OBSOLETE     test_write l1 2147483647 "long write 1"
# OBSOLETE     test_write l1 -2147483648 "long write 2"
# OBSOLETE     test_write l1 0 "long write 3"
# OBSOLETE     test_write ul1 4294967295 "ulong write 1"
# OBSOLETE     test_write ul1 0 "ulong write 2"
# OBSOLETE     test_write ul1 1000000 "ulong write 3"
# OBSOLETE     test_write bo1 FALSE "bool write 1"
# OBSOLETE     test_write bo1 TRUE "bool write 2"
# OBSOLETE     test_write c1 \"1234\" "char write 1"
# OBSOLETE     test_write c2 \"1234567\" "char write 2"
# OBSOLETE     test_write c3 \"654321\" "char write 3"
# OBSOLETE     test_write c4 C'65' 'e' "char write 4"
# OBSOLETE     test_write bi1 B'10100101' "bitstring write 1"
# OBSOLETE     test_write bi2 B'0101001010' "bitstring write 2"
# OBSOLETE     test_write se1 a "set write 1"
# OBSOLETE     test_write se1 h "set write 2"
# OBSOLETE     # The following two use numbered sets with too-large values.
# OBSOLETE     setup_xfail "*-*-*"
# OBSOLETE     test_write nse1 nb "numbered set write 1"
# OBSOLETE     setup_xfail "*-*-*"
# OBSOLETE     test_write nse1 nc "numbered set write 2"
# OBSOLETE     test_write r1 127 "range write 1"
# OBSOLETE     test_write r2 32767 "range write 2"
# OBSOLETE     test_write r3 2147483647 "range write 3"
# OBSOLETE 
# OBSOLETE     # powerset modes
# OBSOLETE     test_write p1 {[pa:ph]} {\[pa:ph\]} "powerset write 1"
# OBSOLETE     test_write p1 {[pa, pc:pf, ph]} {\[pa, pc:pf, ph\]} "powerset write 2"
# OBSOLETE     test_write p1 {[pa, pc, pe, pg]} {\[pa, pc, pe, pg\]} "powerset write 3"
# OBSOLETE     test_write p1 {[]} {\[\]} "powerset write 4"
# OBSOLETE     test_write p2 {[1:32]} {\[1:32\]} "powerset write 5"
# OBSOLETE     test_write p2 {[1, 3:30, 32]} {\[1, 3:30, 32\]} "powerset write 6"
# OBSOLETE     test_write p2 {[1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31]} {\[1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31\]} \
# OBSOLETE 	"powerset write 7"
# OBSOLETE     test_write p2 {[]} {\[\]} "powerset write 8"
# OBSOLETE 
# OBSOLETE # Fixme: this should be rejected by gnuchill
# OBSOLETE #    test_write p3 {[-2147483648:2147483647]} {\[-2147483648:2147483647\]} \
# OBSOLETE #	"powerset write 9"
# OBSOLETE #    test_write p3 {[-2147483648, -1000000:1000000, 2147483647]} \
# OBSOLETE #	{\[-2147483648, -1000000:1000000, 2147483647\]} \
# OBSOLETE #	"powerset write 10"
# OBSOLETE #    test_write p3 {[-99, -97, -95, 1001, 1003, 1005]} \
# OBSOLETE #	{\[-99, -97, -95, 1001, 1003, 1005\]} "powerset write 11"
# OBSOLETE #    test_write p3 {[]} {\[\]} "powerset write 12"
# OBSOLETE     
# OBSOLETE     # reference modes
# OBSOLETE     test_write ref1 ->ref1 {H'[0-9a-fA-F]+} "reference write 1"
# OBSOLETE     test_write ref2 ->b1 {H'[0-9a-fA-F]+} "reference write 2"
# OBSOLETE     test_write ref1 NULL "reference write 3"
# OBSOLETE     test_write ref2 NULL "reference write 4"
# OBSOLETE 
# OBSOLETE     # procedure modes
# OBSOLETE     test_write pr1 NULL "procefure write 1"
# OBSOLETE     # FIXME: remove when NULL is understood
# OBSOLETE     test_write pr1 0 NULL "procefure write 2"
# OBSOLETE     test_write pr1 dummyfunc {H'[0-9a-fA-F]+ <dummyfunc>} "procedure write 3"
# OBSOLETE 
# OBSOLETE     # timing modes, FIXME when callbacks to timefunctions are implemented
# OBSOLETE     #test_write ti1 abstime(1970, 3, 12, 10, 43, 0) {} "time write 1"
# OBSOLETE     #test_write ti2 <set somehow a duration>
# OBSOLETE     xfail "timing modes not implemented yet"
# OBSOLETE     
# OBSOLETE     # real modes
# OBSOLETE     # This ones 
# OBSOLETE     test_write re1 42.03 {42.0[0-9]*} "real write 1"
# OBSOLETE     test_write re1 0 "real write 2"
# OBSOLETE     test_write re1 "1e+38" {1e\+38|1\.0[0-9]*e\+38|9\.9[0-9]*e\+37} \
# OBSOLETE 	"real write 3"
# OBSOLETE     setup_xfail "i*86-pc-linux-gnu" "m68*-*-hpux*"
# OBSOLETE     test_write re1 "1e+39" $infinity "real write 4"
# OBSOLETE     test_write re2 42.03 {42.0[0-9]*} "real write 5"
# OBSOLETE     test_write re2 0 "real write 6"
# OBSOLETE     test_write re2 "1e+308" {1e\+308} "real write 7"
# OBSOLETE     setup_xfail "i*86-pc-linux-gnu" "m68*-*-hpux*"
# OBSOLETE     test_write re2 "1e+309" $infinity "real write 8"
# OBSOLETE     # array modes
# OBSOLETE     test_write arrl1 {[(1:3): [(1:2): -128]]} {\[\(1:3\): \[\(1:2\): -128\]\]}\
# OBSOLETE 	"array write 1"
# OBSOLETE     test_write arrl1 {[(1:3): [(1:2): 0]]} {\[\(1:3\): \[\(1:2\): 0\]\]}\
# OBSOLETE 	"array write 2"
# OBSOLETE     test_write arrl1 {[(1): [(1:2): 127], (2): [(1:2): -128], (3): [(1:2): 127]]} {\[\(1\): \[\(1:2\): 127\], \(2\): \[\(1:2\): -128\], \(3\): \[\(1:2\): 127\]\]}\
# OBSOLETE 	"array write 3"
# OBSOLETE      test_write arrl1 {[(1:3): [(1:2): 0]]} {\[\(1:3\): \[\(1:2\): 0\]\]}\
# OBSOLETE  	"array write 4"
# OBSOLETE      setup_xfail "*-*-*"
# OBSOLETE      # Bogus test case - type mismatch?
# OBSOLETE      test_write arrl1 {[(1): 127, (2): -128]} "array write 5"
# OBSOLETE      test_write arrl1 {[(1:3): [(1:2): 0]]} {\[\(1:3\): \[\(1:2\): 0\]\]}\
# OBSOLETE  	"array write 6"
# OBSOLETE 
# OBSOLETE     # structure modes
# OBSOLETE     test_write strul1 {[.a: -32768, .b: 32767, .ch: "ZZZZ"]} \
# OBSOLETE 	{\[\.a: -32768, \.b: 32767, \.ch: \"ZZZZ\"\]} \
# OBSOLETE 	"structure write 1"
# OBSOLETE     test_write strul1 {[.a: 0, .b: 0, .ch: "0000"]} \
# OBSOLETE 	{\[\.a: 0, \.b: 0, \.ch: \"0000\"\]} \
# OBSOLETE 	"structure write 2"
# OBSOLETE     test_write strul1 -32768 {\[\.a: -32768, \.b: 0, \.ch: \"0000\"\]} \
# OBSOLETE 	{.a} "structure write 3"
# OBSOLETE     test_write strul1 {[.a: 0, .b: 0, .ch: "0000"]} \
# OBSOLETE 	{\[\.a: 0, \.b: 0, \.ch: \"0000\"\]} \
# OBSOLETE 	"structure write 4"
# OBSOLETE     test_write strul1 -32768 {\[\.a: 0, \.b: -32768, \.ch: \"0000\"\]} \
# OBSOLETE 	{.b} "structure write 5"
# OBSOLETE     test_write strul1 {[.a: 0, .b: 0, .ch: "0000"]} \
# OBSOLETE 	{\[\.a: 0, \.b: 0, \.ch: \"0000\"\]} \
# OBSOLETE 	"structure write 6"
# OBSOLETE     test_write strul1 \"HUGO\" {\[\.a: 0, \.b: 0, \.ch: \"HUGO\"\]} \
# OBSOLETE 	{.ch} "structure write 7"
# OBSOLETE }
# OBSOLETE 
# OBSOLETE # Start with a fresh gdb.
# OBSOLETE 
# OBSOLETE set binfile "tests2.exe"
# OBSOLETE 
# OBSOLETE gdb_exit
# OBSOLETE gdb_start
# OBSOLETE gdb_reinitialize_dir $srcdir/$subdir
# OBSOLETE 
# OBSOLETE gdb_test "set print sevenbit-strings" ".*"
# OBSOLETE 
# OBSOLETE if [set_lang_chill] then {
# OBSOLETE     write_access
# OBSOLETE } else {
# OBSOLETE     warning "$test_name tests suppressed."
# OBSOLETE }
@


1.3
log
@More obsolete CHILL.
@
text
@@


1.3.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.3.8.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2
log
@Update/correct copyright notices.
@
text
@d1 271
a271 271
# Copyright 1992, 1995, 1996, 1997, 1999 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@@prep.ai.mit.edu

if $tracelevel then {
	strace $tracelevel
}

if [skip_chill_tests] then { continue }

set prms_id 0
set bug_id 0

# Set the current language to chill.  This counts as a test.  If it
# fails, then we skip the other tests.

set testfile "tests2"
set srcfile ${srcdir}/$subdir/${testfile}.ch
set binfile ${objdir}/${subdir}/${testfile}.exe
if  { [compile "${srcfile} -g -w -o ${binfile} ${CHILL_RT0} ${CHILL_LIB}"] != "" } {
    perror "Couldn't compile ${srcfile}"
    return -1
}

global infinity
if [istarget "i*86-*-sysv4*"] then {
    set infinity "inf"
} else {
    set infinity "Infinity"
}

proc set_lang_chill {} {
    global gdb_prompt
    global binfile objdir subdir

    if ![file exists $objdir/$subdir/$binfile] then {
	return 0
    }
    verbose "loading file '$objdir/$subdir/$binfile'"
    gdb_load $objdir/$subdir/$binfile

    send_gdb "set language chill\n"
    gdb_expect {
	-re ".*$gdb_prompt $" {}
	timeout { fail "set language chill (timeout)" ; return 0 }
    }

    send_gdb "show language\n"
    gdb_expect {
	-re ".* source language is \"chill\".*$gdb_prompt $" {
	    pass "set language to \"chill\""
	    send_gdb "break dummyfunc\n"
	    gdb_expect {
		-re ".*$gdb_prompt $" {
		    send_gdb "run\n"
		    gdb_expect -re ".*$gdb_prompt $" {}
		    return 1
		}
		timeout {
		    fail "can't set breakpoint (timeout)"
		    return 0
		}
	    }
	}
	-re ".*$gdb_prompt $" {
	    fail "setting language to \"chill\""
	    return 0
	}
	timeout {
	    fail "can't show language (timeout)"
	    return 0
	}
    }
}

# checks if structure was accessed correctly
proc test_write { args } {
    global gdb_prompt

    if [llength $args]==5 then {
	set message [lindex $args 4]
	set extended [lindex $args 3]
	set matchval [lindex $args 2]
    } elseif [llength $args]==4 then {
	set message [lindex $args 3]
	set matchval [lindex $args 2]
	set extended ""
    } elseif [llength $args]==3 then {
	set message [lindex $args 2]
	set extended ""
    } else {
	warning "test ($args) write called with wrong number of arguments"
	return 
    }

    set location [lindex $args 0]
    set value [lindex $args 1]
    if ![info exists matchval] then {
	set matchval $value
    }
    verbose "loc: $location, val: $value, msg: $message, ext: $extended, match: $matchval"

    verbose "setting var $value..."
    send_gdb "set var $location.m$extended := $value\n"
    gdb_expect -re ".*$gdb_prompt $" {}
    gdb_test "print $location" \
      ".*= \[\[\]\\.p1: 2863311530, \\.m: $matchval, \\.p2: 1431655765\[\]\]"\
      "$message"
}

# test write access from gdb (setvar x:=y) from gdb
proc write_access { } {
    global infinity

    verbose "testing write access to locations"
    
    # discrete modes
    test_write b1 127 "byte write 1"
    test_write b1 -128 "byte write 2"
    test_write b1 0 "byte write 3"
    test_write ub1 255 "ubyte write 1"
    test_write ub1 0 "ubyte write 2"
    test_write ub1 42 "ubyte write 3"
    test_write i1 32767 "int write 1"
    test_write i1 -32768 "int write 2"
    test_write i1 0 "int write 3"
    test_write ui1 65535 "uint write 1"
    test_write ui1 0 "uint write 2"
    test_write ui1 123 "uint write 3"
    test_write l1 2147483647 "long write 1"
    test_write l1 -2147483648 "long write 2"
    test_write l1 0 "long write 3"
    test_write ul1 4294967295 "ulong write 1"
    test_write ul1 0 "ulong write 2"
    test_write ul1 1000000 "ulong write 3"
    test_write bo1 FALSE "bool write 1"
    test_write bo1 TRUE "bool write 2"
    test_write c1 \"1234\" "char write 1"
    test_write c2 \"1234567\" "char write 2"
    test_write c3 \"654321\" "char write 3"
    test_write c4 C'65' 'e' "char write 4"
    test_write bi1 B'10100101' "bitstring write 1"
    test_write bi2 B'0101001010' "bitstring write 2"
    test_write se1 a "set write 1"
    test_write se1 h "set write 2"
    # The following two use numbered sets with too-large values.
    setup_xfail "*-*-*"
    test_write nse1 nb "numbered set write 1"
    setup_xfail "*-*-*"
    test_write nse1 nc "numbered set write 2"
    test_write r1 127 "range write 1"
    test_write r2 32767 "range write 2"
    test_write r3 2147483647 "range write 3"

    # powerset modes
    test_write p1 {[pa:ph]} {\[pa:ph\]} "powerset write 1"
    test_write p1 {[pa, pc:pf, ph]} {\[pa, pc:pf, ph\]} "powerset write 2"
    test_write p1 {[pa, pc, pe, pg]} {\[pa, pc, pe, pg\]} "powerset write 3"
    test_write p1 {[]} {\[\]} "powerset write 4"
    test_write p2 {[1:32]} {\[1:32\]} "powerset write 5"
    test_write p2 {[1, 3:30, 32]} {\[1, 3:30, 32\]} "powerset write 6"
    test_write p2 {[1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31]} {\[1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31\]} \
	"powerset write 7"
    test_write p2 {[]} {\[\]} "powerset write 8"

# Fixme: this should be rejected by gnuchill
#    test_write p3 {[-2147483648:2147483647]} {\[-2147483648:2147483647\]} \
#	"powerset write 9"
#    test_write p3 {[-2147483648, -1000000:1000000, 2147483647]} \
#	{\[-2147483648, -1000000:1000000, 2147483647\]} \
#	"powerset write 10"
#    test_write p3 {[-99, -97, -95, 1001, 1003, 1005]} \
#	{\[-99, -97, -95, 1001, 1003, 1005\]} "powerset write 11"
#    test_write p3 {[]} {\[\]} "powerset write 12"
    
    # reference modes
    test_write ref1 ->ref1 {H'[0-9a-fA-F]+} "reference write 1"
    test_write ref2 ->b1 {H'[0-9a-fA-F]+} "reference write 2"
    test_write ref1 NULL "reference write 3"
    test_write ref2 NULL "reference write 4"

    # procedure modes
    test_write pr1 NULL "procefure write 1"
    # FIXME: remove when NULL is understood
    test_write pr1 0 NULL "procefure write 2"
    test_write pr1 dummyfunc {H'[0-9a-fA-F]+ <dummyfunc>} "procedure write 3"

    # timing modes, FIXME when callbacks to timefunctions are implemented
    #test_write ti1 abstime(1970, 3, 12, 10, 43, 0) {} "time write 1"
    #test_write ti2 <set somehow a duration>
    xfail "timing modes not implemented yet"
    
    # real modes
    # This ones 
    test_write re1 42.03 {42.0[0-9]*} "real write 1"
    test_write re1 0 "real write 2"
    test_write re1 "1e+38" {1e\+38|1\.0[0-9]*e\+38|9\.9[0-9]*e\+37} \
	"real write 3"
    setup_xfail "i*86-pc-linux-gnu" "m68*-*-hpux*"
    test_write re1 "1e+39" $infinity "real write 4"
    test_write re2 42.03 {42.0[0-9]*} "real write 5"
    test_write re2 0 "real write 6"
    test_write re2 "1e+308" {1e\+308} "real write 7"
    setup_xfail "i*86-pc-linux-gnu" "m68*-*-hpux*"
    test_write re2 "1e+309" $infinity "real write 8"
    # array modes
    test_write arrl1 {[(1:3): [(1:2): -128]]} {\[\(1:3\): \[\(1:2\): -128\]\]}\
	"array write 1"
    test_write arrl1 {[(1:3): [(1:2): 0]]} {\[\(1:3\): \[\(1:2\): 0\]\]}\
	"array write 2"
    test_write arrl1 {[(1): [(1:2): 127], (2): [(1:2): -128], (3): [(1:2): 127]]} {\[\(1\): \[\(1:2\): 127\], \(2\): \[\(1:2\): -128\], \(3\): \[\(1:2\): 127\]\]}\
	"array write 3"
     test_write arrl1 {[(1:3): [(1:2): 0]]} {\[\(1:3\): \[\(1:2\): 0\]\]}\
 	"array write 4"
     setup_xfail "*-*-*"
     # Bogus test case - type mismatch?
     test_write arrl1 {[(1): 127, (2): -128]} "array write 5"
     test_write arrl1 {[(1:3): [(1:2): 0]]} {\[\(1:3\): \[\(1:2\): 0\]\]}\
 	"array write 6"

    # structure modes
    test_write strul1 {[.a: -32768, .b: 32767, .ch: "ZZZZ"]} \
	{\[\.a: -32768, \.b: 32767, \.ch: \"ZZZZ\"\]} \
	"structure write 1"
    test_write strul1 {[.a: 0, .b: 0, .ch: "0000"]} \
	{\[\.a: 0, \.b: 0, \.ch: \"0000\"\]} \
	"structure write 2"
    test_write strul1 -32768 {\[\.a: -32768, \.b: 0, \.ch: \"0000\"\]} \
	{.a} "structure write 3"
    test_write strul1 {[.a: 0, .b: 0, .ch: "0000"]} \
	{\[\.a: 0, \.b: 0, \.ch: \"0000\"\]} \
	"structure write 4"
    test_write strul1 -32768 {\[\.a: 0, \.b: -32768, \.ch: \"0000\"\]} \
	{.b} "structure write 5"
    test_write strul1 {[.a: 0, .b: 0, .ch: "0000"]} \
	{\[\.a: 0, \.b: 0, \.ch: \"0000\"\]} \
	"structure write 6"
    test_write strul1 \"HUGO\" {\[\.a: 0, \.b: 0, \.ch: \"HUGO\"\]} \
	{.ch} "structure write 7"
}

# Start with a fresh gdb.

set binfile "tests2.exe"

gdb_exit
gdb_start
gdb_reinitialize_dir $srcdir/$subdir

gdb_test "set print sevenbit-strings" ".*"

if [set_lang_chill] then {
    write_access
} else {
    warning "$test_name tests suppressed."
}
@


1.2.16.1
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d1 271
a271 271
# OBSOLETE # Copyright 1992, 1995, 1996, 1997, 1999 Free Software Foundation, Inc.
# OBSOLETE 
# OBSOLETE # This program is free software; you can redistribute it and/or modify
# OBSOLETE # it under the terms of the GNU General Public License as published by
# OBSOLETE # the Free Software Foundation; either version 2 of the License, or
# OBSOLETE # (at your option) any later version.
# OBSOLETE # 
# OBSOLETE # This program is distributed in the hope that it will be useful,
# OBSOLETE # but WITHOUT ANY WARRANTY; without even the implied warranty of
# OBSOLETE # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# OBSOLETE # GNU General Public License for more details.
# OBSOLETE # 
# OBSOLETE # You should have received a copy of the GNU General Public License
# OBSOLETE # along with this program; if not, write to the Free Software
# OBSOLETE # Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
# OBSOLETE 
# OBSOLETE # Please email any bugs, comments, and/or additions to this file to:
# OBSOLETE # bug-gdb@@prep.ai.mit.edu
# OBSOLETE 
# OBSOLETE if $tracelevel then {
# OBSOLETE 	strace $tracelevel
# OBSOLETE }
# OBSOLETE 
# OBSOLETE if [skip_chill_tests] then { continue }
# OBSOLETE 
# OBSOLETE set prms_id 0
# OBSOLETE set bug_id 0
# OBSOLETE 
# OBSOLETE # Set the current language to chill.  This counts as a test.  If it
# OBSOLETE # fails, then we skip the other tests.
# OBSOLETE 
# OBSOLETE set testfile "tests2"
# OBSOLETE set srcfile ${srcdir}/$subdir/${testfile}.ch
# OBSOLETE set binfile ${objdir}/${subdir}/${testfile}.exe
# OBSOLETE if  { [compile "${srcfile} -g -w -o ${binfile} ${CHILL_RT0} ${CHILL_LIB}"] != "" } {
# OBSOLETE     perror "Couldn't compile ${srcfile}"
# OBSOLETE     return -1
# OBSOLETE }
# OBSOLETE 
# OBSOLETE global infinity
# OBSOLETE if [istarget "i*86-*-sysv4*"] then {
# OBSOLETE     set infinity "inf"
# OBSOLETE } else {
# OBSOLETE     set infinity "Infinity"
# OBSOLETE }
# OBSOLETE 
# OBSOLETE proc set_lang_chill {} {
# OBSOLETE     global gdb_prompt
# OBSOLETE     global binfile objdir subdir
# OBSOLETE 
# OBSOLETE     if ![file exists $objdir/$subdir/$binfile] then {
# OBSOLETE 	return 0
# OBSOLETE     }
# OBSOLETE     verbose "loading file '$objdir/$subdir/$binfile'"
# OBSOLETE     gdb_load $objdir/$subdir/$binfile
# OBSOLETE 
# OBSOLETE     send_gdb "set language chill\n"
# OBSOLETE     gdb_expect {
# OBSOLETE 	-re ".*$gdb_prompt $" {}
# OBSOLETE 	timeout { fail "set language chill (timeout)" ; return 0 }
# OBSOLETE     }
# OBSOLETE 
# OBSOLETE     send_gdb "show language\n"
# OBSOLETE     gdb_expect {
# OBSOLETE 	-re ".* source language is \"chill\".*$gdb_prompt $" {
# OBSOLETE 	    pass "set language to \"chill\""
# OBSOLETE 	    send_gdb "break dummyfunc\n"
# OBSOLETE 	    gdb_expect {
# OBSOLETE 		-re ".*$gdb_prompt $" {
# OBSOLETE 		    send_gdb "run\n"
# OBSOLETE 		    gdb_expect -re ".*$gdb_prompt $" {}
# OBSOLETE 		    return 1
# OBSOLETE 		}
# OBSOLETE 		timeout {
# OBSOLETE 		    fail "can't set breakpoint (timeout)"
# OBSOLETE 		    return 0
# OBSOLETE 		}
# OBSOLETE 	    }
# OBSOLETE 	}
# OBSOLETE 	-re ".*$gdb_prompt $" {
# OBSOLETE 	    fail "setting language to \"chill\""
# OBSOLETE 	    return 0
# OBSOLETE 	}
# OBSOLETE 	timeout {
# OBSOLETE 	    fail "can't show language (timeout)"
# OBSOLETE 	    return 0
# OBSOLETE 	}
# OBSOLETE     }
# OBSOLETE }
# OBSOLETE 
# OBSOLETE # checks if structure was accessed correctly
# OBSOLETE proc test_write { args } {
# OBSOLETE     global gdb_prompt
# OBSOLETE 
# OBSOLETE     if [llength $args]==5 then {
# OBSOLETE 	set message [lindex $args 4]
# OBSOLETE 	set extended [lindex $args 3]
# OBSOLETE 	set matchval [lindex $args 2]
# OBSOLETE     } elseif [llength $args]==4 then {
# OBSOLETE 	set message [lindex $args 3]
# OBSOLETE 	set matchval [lindex $args 2]
# OBSOLETE 	set extended ""
# OBSOLETE     } elseif [llength $args]==3 then {
# OBSOLETE 	set message [lindex $args 2]
# OBSOLETE 	set extended ""
# OBSOLETE     } else {
# OBSOLETE 	warning "test ($args) write called with wrong number of arguments"
# OBSOLETE 	return 
# OBSOLETE     }
# OBSOLETE 
# OBSOLETE     set location [lindex $args 0]
# OBSOLETE     set value [lindex $args 1]
# OBSOLETE     if ![info exists matchval] then {
# OBSOLETE 	set matchval $value
# OBSOLETE     }
# OBSOLETE     verbose "loc: $location, val: $value, msg: $message, ext: $extended, match: $matchval"
# OBSOLETE 
# OBSOLETE     verbose "setting var $value..."
# OBSOLETE     send_gdb "set var $location.m$extended := $value\n"
# OBSOLETE     gdb_expect -re ".*$gdb_prompt $" {}
# OBSOLETE     gdb_test "print $location" \
# OBSOLETE       ".*= \[\[\]\\.p1: 2863311530, \\.m: $matchval, \\.p2: 1431655765\[\]\]"\
# OBSOLETE       "$message"
# OBSOLETE }
# OBSOLETE 
# OBSOLETE # test write access from gdb (setvar x:=y) from gdb
# OBSOLETE proc write_access { } {
# OBSOLETE     global infinity
# OBSOLETE 
# OBSOLETE     verbose "testing write access to locations"
# OBSOLETE     
# OBSOLETE     # discrete modes
# OBSOLETE     test_write b1 127 "byte write 1"
# OBSOLETE     test_write b1 -128 "byte write 2"
# OBSOLETE     test_write b1 0 "byte write 3"
# OBSOLETE     test_write ub1 255 "ubyte write 1"
# OBSOLETE     test_write ub1 0 "ubyte write 2"
# OBSOLETE     test_write ub1 42 "ubyte write 3"
# OBSOLETE     test_write i1 32767 "int write 1"
# OBSOLETE     test_write i1 -32768 "int write 2"
# OBSOLETE     test_write i1 0 "int write 3"
# OBSOLETE     test_write ui1 65535 "uint write 1"
# OBSOLETE     test_write ui1 0 "uint write 2"
# OBSOLETE     test_write ui1 123 "uint write 3"
# OBSOLETE     test_write l1 2147483647 "long write 1"
# OBSOLETE     test_write l1 -2147483648 "long write 2"
# OBSOLETE     test_write l1 0 "long write 3"
# OBSOLETE     test_write ul1 4294967295 "ulong write 1"
# OBSOLETE     test_write ul1 0 "ulong write 2"
# OBSOLETE     test_write ul1 1000000 "ulong write 3"
# OBSOLETE     test_write bo1 FALSE "bool write 1"
# OBSOLETE     test_write bo1 TRUE "bool write 2"
# OBSOLETE     test_write c1 \"1234\" "char write 1"
# OBSOLETE     test_write c2 \"1234567\" "char write 2"
# OBSOLETE     test_write c3 \"654321\" "char write 3"
# OBSOLETE     test_write c4 C'65' 'e' "char write 4"
# OBSOLETE     test_write bi1 B'10100101' "bitstring write 1"
# OBSOLETE     test_write bi2 B'0101001010' "bitstring write 2"
# OBSOLETE     test_write se1 a "set write 1"
# OBSOLETE     test_write se1 h "set write 2"
# OBSOLETE     # The following two use numbered sets with too-large values.
# OBSOLETE     setup_xfail "*-*-*"
# OBSOLETE     test_write nse1 nb "numbered set write 1"
# OBSOLETE     setup_xfail "*-*-*"
# OBSOLETE     test_write nse1 nc "numbered set write 2"
# OBSOLETE     test_write r1 127 "range write 1"
# OBSOLETE     test_write r2 32767 "range write 2"
# OBSOLETE     test_write r3 2147483647 "range write 3"
# OBSOLETE 
# OBSOLETE     # powerset modes
# OBSOLETE     test_write p1 {[pa:ph]} {\[pa:ph\]} "powerset write 1"
# OBSOLETE     test_write p1 {[pa, pc:pf, ph]} {\[pa, pc:pf, ph\]} "powerset write 2"
# OBSOLETE     test_write p1 {[pa, pc, pe, pg]} {\[pa, pc, pe, pg\]} "powerset write 3"
# OBSOLETE     test_write p1 {[]} {\[\]} "powerset write 4"
# OBSOLETE     test_write p2 {[1:32]} {\[1:32\]} "powerset write 5"
# OBSOLETE     test_write p2 {[1, 3:30, 32]} {\[1, 3:30, 32\]} "powerset write 6"
# OBSOLETE     test_write p2 {[1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31]} {\[1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31\]} \
# OBSOLETE 	"powerset write 7"
# OBSOLETE     test_write p2 {[]} {\[\]} "powerset write 8"
# OBSOLETE 
# OBSOLETE # Fixme: this should be rejected by gnuchill
# OBSOLETE #    test_write p3 {[-2147483648:2147483647]} {\[-2147483648:2147483647\]} \
# OBSOLETE #	"powerset write 9"
# OBSOLETE #    test_write p3 {[-2147483648, -1000000:1000000, 2147483647]} \
# OBSOLETE #	{\[-2147483648, -1000000:1000000, 2147483647\]} \
# OBSOLETE #	"powerset write 10"
# OBSOLETE #    test_write p3 {[-99, -97, -95, 1001, 1003, 1005]} \
# OBSOLETE #	{\[-99, -97, -95, 1001, 1003, 1005\]} "powerset write 11"
# OBSOLETE #    test_write p3 {[]} {\[\]} "powerset write 12"
# OBSOLETE     
# OBSOLETE     # reference modes
# OBSOLETE     test_write ref1 ->ref1 {H'[0-9a-fA-F]+} "reference write 1"
# OBSOLETE     test_write ref2 ->b1 {H'[0-9a-fA-F]+} "reference write 2"
# OBSOLETE     test_write ref1 NULL "reference write 3"
# OBSOLETE     test_write ref2 NULL "reference write 4"
# OBSOLETE 
# OBSOLETE     # procedure modes
# OBSOLETE     test_write pr1 NULL "procefure write 1"
# OBSOLETE     # FIXME: remove when NULL is understood
# OBSOLETE     test_write pr1 0 NULL "procefure write 2"
# OBSOLETE     test_write pr1 dummyfunc {H'[0-9a-fA-F]+ <dummyfunc>} "procedure write 3"
# OBSOLETE 
# OBSOLETE     # timing modes, FIXME when callbacks to timefunctions are implemented
# OBSOLETE     #test_write ti1 abstime(1970, 3, 12, 10, 43, 0) {} "time write 1"
# OBSOLETE     #test_write ti2 <set somehow a duration>
# OBSOLETE     xfail "timing modes not implemented yet"
# OBSOLETE     
# OBSOLETE     # real modes
# OBSOLETE     # This ones 
# OBSOLETE     test_write re1 42.03 {42.0[0-9]*} "real write 1"
# OBSOLETE     test_write re1 0 "real write 2"
# OBSOLETE     test_write re1 "1e+38" {1e\+38|1\.0[0-9]*e\+38|9\.9[0-9]*e\+37} \
# OBSOLETE 	"real write 3"
# OBSOLETE     setup_xfail "i*86-pc-linux-gnu" "m68*-*-hpux*"
# OBSOLETE     test_write re1 "1e+39" $infinity "real write 4"
# OBSOLETE     test_write re2 42.03 {42.0[0-9]*} "real write 5"
# OBSOLETE     test_write re2 0 "real write 6"
# OBSOLETE     test_write re2 "1e+308" {1e\+308} "real write 7"
# OBSOLETE     setup_xfail "i*86-pc-linux-gnu" "m68*-*-hpux*"
# OBSOLETE     test_write re2 "1e+309" $infinity "real write 8"
# OBSOLETE     # array modes
# OBSOLETE     test_write arrl1 {[(1:3): [(1:2): -128]]} {\[\(1:3\): \[\(1:2\): -128\]\]}\
# OBSOLETE 	"array write 1"
# OBSOLETE     test_write arrl1 {[(1:3): [(1:2): 0]]} {\[\(1:3\): \[\(1:2\): 0\]\]}\
# OBSOLETE 	"array write 2"
# OBSOLETE     test_write arrl1 {[(1): [(1:2): 127], (2): [(1:2): -128], (3): [(1:2): 127]]} {\[\(1\): \[\(1:2\): 127\], \(2\): \[\(1:2\): -128\], \(3\): \[\(1:2\): 127\]\]}\
# OBSOLETE 	"array write 3"
# OBSOLETE      test_write arrl1 {[(1:3): [(1:2): 0]]} {\[\(1:3\): \[\(1:2\): 0\]\]}\
# OBSOLETE  	"array write 4"
# OBSOLETE      setup_xfail "*-*-*"
# OBSOLETE      # Bogus test case - type mismatch?
# OBSOLETE      test_write arrl1 {[(1): 127, (2): -128]} "array write 5"
# OBSOLETE      test_write arrl1 {[(1:3): [(1:2): 0]]} {\[\(1:3\): \[\(1:2\): 0\]\]}\
# OBSOLETE  	"array write 6"
# OBSOLETE 
# OBSOLETE     # structure modes
# OBSOLETE     test_write strul1 {[.a: -32768, .b: 32767, .ch: "ZZZZ"]} \
# OBSOLETE 	{\[\.a: -32768, \.b: 32767, \.ch: \"ZZZZ\"\]} \
# OBSOLETE 	"structure write 1"
# OBSOLETE     test_write strul1 {[.a: 0, .b: 0, .ch: "0000"]} \
# OBSOLETE 	{\[\.a: 0, \.b: 0, \.ch: \"0000\"\]} \
# OBSOLETE 	"structure write 2"
# OBSOLETE     test_write strul1 -32768 {\[\.a: -32768, \.b: 0, \.ch: \"0000\"\]} \
# OBSOLETE 	{.a} "structure write 3"
# OBSOLETE     test_write strul1 {[.a: 0, .b: 0, .ch: "0000"]} \
# OBSOLETE 	{\[\.a: 0, \.b: 0, \.ch: \"0000\"\]} \
# OBSOLETE 	"structure write 4"
# OBSOLETE     test_write strul1 -32768 {\[\.a: 0, \.b: -32768, \.ch: \"0000\"\]} \
# OBSOLETE 	{.b} "structure write 5"
# OBSOLETE     test_write strul1 {[.a: 0, .b: 0, .ch: "0000"]} \
# OBSOLETE 	{\[\.a: 0, \.b: 0, \.ch: \"0000\"\]} \
# OBSOLETE 	"structure write 6"
# OBSOLETE     test_write strul1 \"HUGO\" {\[\.a: 0, \.b: 0, \.ch: \"HUGO\"\]} \
# OBSOLETE 	{.ch} "structure write 7"
# OBSOLETE }
# OBSOLETE 
# OBSOLETE # Start with a fresh gdb.
# OBSOLETE 
# OBSOLETE set binfile "tests2.exe"
# OBSOLETE 
# OBSOLETE gdb_exit
# OBSOLETE gdb_start
# OBSOLETE gdb_reinitialize_dir $srcdir/$subdir
# OBSOLETE 
# OBSOLETE gdb_test "set print sevenbit-strings" ".*"
# OBSOLETE 
# OBSOLETE if [set_lang_chill] then {
# OBSOLETE     write_access
# OBSOLETE } else {
# OBSOLETE     warning "$test_name tests suppressed."
# OBSOLETE }
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
# Copyright (C) 1992, 1995, 1997 Free Software Foundation, Inc.
d15 1
a15 1
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d15 1
a15 1
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
@

