head	1.8;
access;
symbols
	cagney_x86i386-20030821-branch:1.7.0.30
	cagney_x86i386-20030821-branchpoint:1.7
	carlton_dictionary-20030805-merge:1.7
	carlton_dictionary-20030627-merge:1.7
	gdb_6_0-branch:1.7.0.28
	gdb_6_0-2003-06-23-branchpoint:1.7
	jimb-ppc64-linux-20030613-branch:1.7.0.26
	jimb-ppc64-linux-20030613-branchpoint:1.7
	cagney_writestrings-20030508-branch:1.7.0.24
	cagney_writestrings-20030508-branchpoint:1.7
	jimb-ppc64-linux-20030528-branch:1.7.0.22
	jimb-ppc64-linux-20030528-branchpoint:1.7
	carlton_dictionary-20030523-merge:1.7
	cagney_fileio-20030521-branch:1.7.0.20
	cagney_fileio-20030521-branchpoint:1.7
	kettenis_i386newframe-20030517-mergepoint:1.7
	jimb-ppc64-linux-20030509-branch:1.7.0.18
	jimb-ppc64-linux-20030509-branchpoint:1.7
	kettenis_i386newframe-20030504-mergepoint:1.7
	carlton_dictionary-20030430-merge:1.7
	kettenis_i386newframe-20030419-branch:1.7.0.16
	kettenis_i386newframe-20030419-branchpoint:1.7
	carlton_dictionary-20030416-merge:1.7
	cagney_frameaddr-20030409-mergepoint:1.7
	kettenis_i386newframe-20030406-branch:1.7.0.14
	kettenis_i386newframe-20030406-branchpoint:1.7
	cagney_frameaddr-20030403-branchpoint:1.7
	cagney_frameaddr-20030403-branch:1.7.0.12
	cagney_framebase-20030330-mergepoint:1.7
	cagney_framebase-20030326-branch:1.7.0.10
	cagney_framebase-20030326-branchpoint:1.7
	cagney_lazyid-20030317-branch:1.7.0.8
	cagney_lazyid-20030317-branchpoint:1.7
	kettenis-i386newframe-20030316-mergepoint:1.7
	offbyone-20030313-branch:1.7.0.6
	offbyone-20030313-branchpoint:1.7
	kettenis-i386newframe-20030308-branch:1.7.0.4
	kettenis-i386newframe-20030308-branchpoint:1.7
	carlton_dictionary-20030305-merge:1.7
	cagney_offbyone-20030303-branch:1.7.0.2
	cagney_offbyone-20030303-branchpoint:1.7
	carlton_dictionary-20030207-merge:1.6
	interps-20030203-mergepoint:1.6
	interps-20030202-branch:1.6.0.2
	interps-20030202-branchpoint:1.6
	cagney-unwind-20030108-branch:1.5.0.18
	cagney-unwind-20030108-branchpoint:1.5
	carlton_dictionary-20021223-merge:1.5
	gdb_5_3-2002-12-12-release:1.5
	carlton_dictionary-20021115-merge:1.5
	kseitz_interps-20021105-merge:1.5
	kseitz_interps-20021103-merge:1.5
	drow-cplus-merge-20021020:1.5
	drow-cplus-merge-20021025:1.5
	carlton_dictionary-20021025-merge:1.5
	carlton_dictionary-20021011-merge:1.5
	drow-cplus-branch:1.5.0.16
	drow-cplus-branchpoint:1.5
	kseitz_interps-20020930-merge:1.5
	carlton_dictionary-20020927-merge:1.5
	carlton_dictionary-branch:1.5.0.14
	carlton_dictionary-20020920-branchpoint:1.5
	gdb_5_3-branch:1.5.0.12
	gdb_5_3-2002-09-04-branchpoint:1.5
	kseitz_interps-20020829-merge:1.5
	cagney_sysregs-20020825-branch:1.5.0.10
	cagney_sysregs-20020825-branchpoint:1.5
	readline_4_3-import-branch:1.5.0.8
	readline_4_3-import-branchpoint:1.5
	gdb_5_2_1-2002-07-23-release:1.4
	kseitz_interps-20020528-branch:1.5.0.6
	kseitz_interps-20020528-branchpoint:1.5
	cagney_regbuf-20020515-branch:1.5.0.4
	cagney_regbuf-20020515-branchpoint:1.5
	jimb-macro-020506-branch:1.5.0.2
	jimb-macro-020506-branchpoint:1.5
	gdb_5_2-2002-04-29-release:1.4
	gdb_5_2-branch:1.4.0.2
	gdb_5_2-2002-03-03-branchpoint:1.4
	gdb_5_1_1-2002-01-24-release:1.2
	gdb_5_1_0_1-2002-01-03-release:1.2
	cygnus_cvs_20020108_pre:1.4
	gdb_5_1_0_1-2002-01-03-branch:1.2.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.2
	gdb_5_1-2001-11-21-release:1.2
	gdb_s390-2001-09-26-branch:1.2.0.6
	gdb_s390-2001-09-26-branchpoint:1.2
	gdb_5_1-2001-07-29-branch:1.2.0.4
	gdb_5_1-2001-07-29-branchpoint:1.2
	dberlin-typesystem-branch:1.2.0.2
	dberlin-typesystem-branchpoint:1.2
	gdb-post-ptid_t-2001-05-03:1.2
	gdb-pre-ptid_t-2001-05-03:1.2
	insight-precleanup-2001-01-01:1.1.1.3
	gdb-post-protoization-2000-07-29:1.1.1.3
	gdb-pre-protoization-2000-07-29:1.1.1.3
	gdb-premipsmulti-2000-06-06-branch:1.1.1.3.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.3
	gdb-post-params-removal-2000-06-04:1.1.1.3
	gdb-pre-params-removal-2000-06-04:1.1.1.3
	gdb-post-params-removal-2000-05-28:1.1.1.3
	gdb-pre-params-removal-2000-05-28:1.1.1.3
	gdb_5_0-2000-05-19-release:1.1.1.3
	gdb_4_18_2-2000-05-18-release:1.1.1.3
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.3
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.3
	gdb_5_0-2000-04-10-branch:1.1.1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.3
	repo-unification-2000-02-06:1.1.1.3
	insight-2000-02-04:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.3
	gdb-1999-12-06:1.1.1.3
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.3
	gdb-1999-10-18:1.1.1.3
	gdb-1999-10-11:1.1.1.3
	gdb-1999-10-04:1.1.1.3
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.3
	gdb-1999-09-08:1.1.1.3
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.8
date	2003.08.23.03.55.59;	author chastain;	state dead;
branches;
next	1.7;

1.7
date	2003.02.13.21.33.20;	author chastain;	state Exp;
branches
	1.7.28.1;
next	1.6;

1.6
date	2003.01.17.19.22.27;	author carlton;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.04.15.18.21;	author cagney;	state Exp;
branches
	1.5.14.1
	1.5.16.1;
next	1.4;

1.4
date	2002.01.06.14.42.39;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.05.23.31.26;	author msnyder;	state Exp;
branches;
next	1.2;

1.2
date	2001.02.14.19.54.04;	author chastain;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.32;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.32;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.08.02.23.46.53;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.09.09.00.00.27;	author shebs;	state Exp;
branches;
next	;

1.5.14.1
date	2003.02.07.19.17.59;	author carlton;	state Exp;
branches;
next	1.5.14.2;

1.5.14.2
date	2003.03.06.00.56.36;	author carlton;	state Exp;
branches;
next	1.5.14.3;

1.5.14.3
date	2003.08.30.03.40.34;	author chastain;	state dead;
branches;
next	;

1.5.16.1
date	2003.12.14.20.27.51;	author drow;	state dead;
branches;
next	;

1.7.28.1
date	2003.08.25.03.53.47;	author chastain;	state dead;
branches;
next	;


desc
@@


1.8
log
@2003-08-22  Michael Chastain  <mec@@shout.net>

	* gdb.cp: New directory.
	* gdb.cp/*: Copy from gdb.c++/*.
	* gdb.c++/*: Remove.
	* Makefile.in: Change gdb.c++ to gdb.cp.
	* configure.in:  Ditto.
	* configure: Regnerate.
@
text
@# Copyright 1992, 1997, 1999, 2001, 2002, 2003 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@@prep.ai.mit.edu

# This file was written by Fred Fish. (fnf@@cygnus.com)
# Adapted for g++ 3.0 ABI by Michael Chastain. (chastain@@redhat.com)

if $tracelevel then {
	strace $tracelevel
}

if { [skip_cplus_tests] } { continue }

set testfile "cplusfuncs"
set srcfile ${testfile}.cc
set binfile ${objdir}/${subdir}/${testfile}

if { [get_compiler_info $binfile "c++"] } {
    return -1
}

if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug c++}] != "" } {
     gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
}

#
# g++ changed its ABI between 2.95 and 3.0.  gdb has two demanglers
# for the two different styles.  The two demanglers have some subtle
# discrepancies in their output.
#
#   old demangler         new demangler
#   --- ---------         --- ---------
#   "operator, "          "operator,"
#   "char *"              "char*"
#   "int *"               "int*"
#   "long *"              "long*"
#   "void *"              "void*"
#   "foo &"               "foo&"
#   "unsigned int"        "unsigned"
#   "void"                ""
#
# I probe for the forms in use.
# The defaults are for the v3 demangler (as of 2001-02-13).
#

set dm_operator_comma		","
set dm_type_char_star		"char*"
set dm_type_char_star_quoted    "char\\*"
set dm_type_foo_ref 		"foo&"
set dm_type_int_star		"int*"
set dm_type_long_star		"long*"
set dm_type_unsigned_int	"unsigned"
set dm_type_void		""
set dm_type_void_star		"void*"

proc probe_demangler { } {
    global gdb_prompt
    global dm_operator_comma
    global dm_type_char_star
    global dm_type_char_star_quoted
    global dm_type_foo_ref
    global dm_type_int_star
    global dm_type_long_star
    global dm_type_unsigned_int
    global dm_type_void
    global dm_type_void_star

    send_gdb "print &'foo::operator,(foo&)'\n"
    gdb_expect {
	-re ".*foo::operator, \\(.*foo.*&.*\\).*\r\n$gdb_prompt $" {
	    # v2 demangler
	    set dm_operator_comma ", "
	    pass "detect dm_operator_comma"
	}
	-re ".*foo::operator,\\(.*foo.*&.*\\).*\r\n$gdb_prompt $" {
	    # v3 demangler
	    pass "detect dm_operator_comma"
	}
	-re ".*$gdb_prompt $" {
	    fail "detect dm_operator_comma"
	}
	timeout {
	    fail "detect dm_operator_comma"
	}
    }

    send_gdb "print &'dm_type_char_star'\n"
    gdb_expect {
	-re ".*dm_type_char_star\\(char \\*\\).*\r\n$gdb_prompt $" {
	    # v2 demangler
	    set dm_type_char_star "char *"
	    set dm_type_char_star_quoted "char \\*"
	    pass "detect dm_type_char_star"
	}
	-re ".*dm_type_char_star\\(char\\*\\).*\r\n$gdb_prompt $" {
	    # v3 demangler
	    pass "detect dm_type_char_star"
	}
	-re ".*$gdb_prompt $" {
	    fail "detect dm_type_char_star"
	}
	timeout {
	    fail "detect dm_type_char_star (timeout)"
	}
    }

    send_gdb "print &'dm_type_foo_ref'\n"
    gdb_expect {
	-re ".*dm_type_foo_ref\\(foo &\\).*\r\n$gdb_prompt $" {
	    # v2 demangler
	    set dm_type_foo_ref "foo &"
	    pass "detect dm_type_foo_ref"
	}
	-re ".*dm_type_foo_ref\\(foo&\\).*\r\n$gdb_prompt $" {
	    # v3 demangler
	    pass "detect dm_type_foo_ref"
	}
	-re ".*$gdb_prompt $" {
	    fail "detect dm_type_foo_ref"
	}
	timeout {
	    fail "detect dm_type_foo_ref (timeout)"
	}
    }

    send_gdb "print &'dm_type_int_star'\n"
    gdb_expect {
	-re ".*dm_type_int_star\\(int \\*\\).*\r\n$gdb_prompt $" {
	    # v2 demangler
	    set dm_type_int_star "int *"
	    pass "detect dm_type_int_star"
	}
	-re ".*dm_type_int_star\\(int\\*\\).*\r\n$gdb_prompt $" {
	    # v3 demangler
	    pass "detect dm_type_int_star"
	}
	-re ".*$gdb_prompt $" {
	    fail "detect dm_type_int_star"
	}
	timeout {
	    fail "detect dm_type_int_star (timeout)"
	}
    }

    send_gdb "print &'dm_type_long_star'\n"
    gdb_expect {
	-re ".*dm_type_long_star\\(long \\*\\).*\r\n$gdb_prompt $" {
	    # v2 demangler
	    set dm_type_long_star "long *"
	    pass "detect dm_type_long_star"
	}
	-re ".*dm_type_long_star\\(long\\*\\).*\r\n$gdb_prompt $" {
	    # v3 demangler
	    pass "detect dm_type_long_star"
	}
	-re ".*$gdb_prompt $" {
	    fail "detect dm_type_long_star"
	}
	timeout {
	    fail "detect dm_type_long_star (timeout)"
	}
    }

    send_gdb "print &'dm_type_unsigned_int'\n"
    gdb_expect {
	-re ".*dm_type_unsigned_int\\(unsigned int\\).*\r\n$gdb_prompt $" {
	    # v2 demangler
	    set dm_type_unsigned_int "unsigned int"
	    pass "detect dm_type_unsigned_int"
	}
	-re ".*dm_type_unsigned_int\\(unsigned\\).*\r\n$gdb_prompt $" {
	    # v3 demangler
	    pass "detect dm_type_unsigned_int"
	}
	-re ".*$gdb_prompt $" {
	    fail "detect dm_type_unsigned_int"
	}
	timeout {
	    fail "detect dm_unsigned int (timeout)"
	}
    }

    send_gdb "print &'dm_type_void'\n"
    gdb_expect {
	-re ".*dm_type_void\\(void\\).*\r\n$gdb_prompt $" {
	    # v2 demangler
	    set dm_type_void "void"
	    pass "detect dm_type_void"
	}
	-re ".*dm_type_void\\(\\).*\r\n$gdb_prompt $" {
	    # v3 demangler
	    pass "detect dm_type_void"
	}
	-re ".*$gdb_prompt $" {
	    fail "detect dm_type_void"
	}
	timeout {
	    fail "detect dm_type_void (timeout)"
	}
    }

    send_gdb "print &'dm_type_void_star'\n"
    gdb_expect {
	-re ".*dm_type_void_star\\(void \\*\\).*\r\n$gdb_prompt $" {
	    # v2 demangler
	    set dm_type_void_star "void *"
	    pass "detect dm_type_void_star"
	}
	-re ".*dm_type_void_star\\(void\\*\\).*\r\n$gdb_prompt $" {
	    # v3 demangler
	    pass "detect dm_type_void_star"
	}
	-re ".*$gdb_prompt $" {
	    fail "detect dm_type_void_star"
	}
	timeout {
	    fail "detect dm_type_void_star (timeout)"
	}
    }
}

#
#  Lookup a specific C++ function and print the demangled type.
#  This form accepts the demangled type as a regexp.
#

proc info_func_regexp { name demangled } {
    global gdb_prompt

    send_gdb "info function $name\n"
    gdb_expect {
	-re ".*File .*:\r\n(class |)$demangled\r\n.*$gdb_prompt $" {
	    pass "info function for \"$name\""
	}
	-re ".*$gdb_prompt $" {
	    fail "info function for \"$name\""
	}
	timeout {
	    fail "info function for \"$name\" (timeout)"
	}
    }
}

#
#  Lookup a specific C++ function and print the demangled type.
#  This form accepts the demangled type as a literal string.
#

proc info_func { name demangled } {
    info_func_regexp "$name" [string_to_regexp "$demangled"]
}

#
# Print the address of a function.
# This checks that I can lookup a fully qualified C++ function.
# This also checks the argument types on the return string.

# Note: carlton/2003-01-16: If you modify this, make a corresponding
# modification to print_addr_2_kfail.

proc print_addr_2 { name good } {
    global gdb_prompt
    global hex

    set good_pattern [string_to_regexp $good]

    send_gdb "print &'$name'\n"
    gdb_expect {
	-re ".* = .* $hex <$good_pattern>\r\n$gdb_prompt $" {
	    pass "print &'$name'"
	}
	-re ".*$gdb_prompt $" {
	    fail "print &'$name'"
	}
	timeout {
	    fail "print &'$name' (timeout)"
	}
    }
}

# NOTE: carlton/2003-01-16: hairyfunc5-6 fail on GCC 3.x (for at least
# x=1 and x=2.1).  So I'm modifying print_addr_2 to accept a failure
# condition.  FIXME: It would be nice if the failure condition were
# conditional on the compiler version, but I'm not sufficiently
# motivated.  I did hardwire in the versions of char * and int *,
# which will give some compiler-specificity to the failure.

proc print_addr_2_kfail { name good bad bugid } {
    global gdb_prompt
    global hex

    set good_pattern [string_to_regexp $good]
    set bad_pattern [string_to_regexp $bad]

    send_gdb "print &'$name'\n"
    gdb_expect {
	-re ".* = .* $hex <$good_pattern>\r\n$gdb_prompt $" {
	    pass "print &'$name'"
	}
	-re ".* = .* $hex <$bad_pattern>\r\n$gdb_prompt $" {
	    kfail $bugid "print &'$name'"
	}
	-re ".*$gdb_prompt $" {
	    fail "print &'$name'"
	}
	timeout {
	    fail "print &'$name' (timeout)"
	}
    }
}

#
#  Simple interfaces to print_addr_2.
#

proc print_addr { name } {
    print_addr_2 "$name" "$name"
}

#
# Test name demangling for operators.
#
# The '(' at the end of each regex input pattern is so that we match only
# the one we are looking for.  I.E. "operator&" would match both
# "operator&(foo &)" and "operator&&(foo &)".
#
# gdb-gnats bug gdb/18:
#  "gdb can't parse "info func operator*" or "info func operator\*".
#  The star in "operator*" is interpreted as a regexp, but the "\*"
#  in  "operator\*" is not a legal operator.
#

proc test_lookup_operator_functions {} {
    global dm_operator_comma
    global dm_type_char_star
    global dm_type_char_star_quoted
    global dm_type_foo_ref
    global dm_type_void
    global dm_type_void_star

    # operator* requires quoting so that GDB does not treat it as a regexp.
    info_func "operator\\*("	"void foo::operator*($dm_type_foo_ref);"
    info_func "operator%("	"void foo::operator%($dm_type_foo_ref);"
    info_func "operator-("	"void foo::operator-($dm_type_foo_ref);"
    info_func "operator>>("	"void foo::operator>>($dm_type_foo_ref);"
    info_func "operator!=("	"void foo::operator!=($dm_type_foo_ref);"
    info_func "operator>("	"void foo::operator>($dm_type_foo_ref);"
    info_func "operator>=("	"void foo::operator>=($dm_type_foo_ref);"
    info_func "operator|("	"void foo::operator|($dm_type_foo_ref);"
    info_func "operator&&("	"void foo::operator&&($dm_type_foo_ref);"
    info_func "operator!("	"void foo::operator!($dm_type_void);"
    info_func "operator++("	"void foo::operator++(int);"
    info_func "operator=("	"void foo::operator=($dm_type_foo_ref);"
    info_func "operator+=("	"void foo::operator+=($dm_type_foo_ref);"
    # operator*= requires quoting so that GDB does not treat it as a regexp.
    info_func "operator\\*=("	"void foo::operator*=($dm_type_foo_ref);"
    info_func "operator%=("	"void foo::operator%=($dm_type_foo_ref);"
    info_func "operator>>=("	"void foo::operator>>=($dm_type_foo_ref);"
    info_func "operator|=("	"void foo::operator|=($dm_type_foo_ref);"
    info_func "operator$dm_operator_comma\("	\
    				"void foo::operator$dm_operator_comma\($dm_type_foo_ref);"
    info_func "operator/("	"void foo::operator/($dm_type_foo_ref);"
    info_func "operator+("	"void foo::operator+($dm_type_foo_ref);"
    info_func "operator<<("	"void foo::operator<<($dm_type_foo_ref);"
    info_func "operator==("	"void foo::operator==($dm_type_foo_ref);"
    info_func "operator<("	"void foo::operator<($dm_type_foo_ref);"
    info_func "operator<=("	"void foo::operator<=($dm_type_foo_ref);"
    info_func "operator&("	"void foo::operator&($dm_type_foo_ref);"
    info_func "operator^("	"void foo::operator^($dm_type_foo_ref);"
    info_func "operator||("	"void foo::operator||($dm_type_foo_ref);"
    info_func "operator~("	"void foo::operator~($dm_type_void);"
    info_func "operator--("	"void foo::operator--(int);"
    info_func "operator->("	"foo *foo::operator->($dm_type_void);"
    info_func "operator-=("	"void foo::operator-=($dm_type_foo_ref);"
    info_func "operator/=("	"void foo::operator/=($dm_type_foo_ref);"
    info_func "operator<<=("	"void foo::operator<<=($dm_type_foo_ref);"
    info_func "operator&=("	"void foo::operator&=($dm_type_foo_ref);"
    info_func "operator^=("	"void foo::operator^=($dm_type_foo_ref);"
    # operator->* requires quoting so that GDB does not treat it as a regexp.
    info_func "operator->\\*("	"void foo::operator->*($dm_type_foo_ref);"

    # operator[] needs double backslashes, so that a single backslash
    # will be sent to GDB, preventing the square brackets from being
    # evaluated as a regular expression. 
    info_func "operator\\\[\\\](" "void foo::operator\[\]($dm_type_foo_ref);"

    # These are gnarly because they might end with 'static'.
    set dm_type_void_star_regexp [string_to_regexp $dm_type_void_star]
    info_func_regexp "operator new("     "void \\*foo::operator new\\(.*\\)(| static);"
    info_func_regexp "operator delete("  "void foo::operator delete\\($dm_type_void_star_regexp\\)(| static);"

    info_func "operator int("	"int foo::operator int($dm_type_void);"
    info_func "operator()("	"void foo::operator()($dm_type_foo_ref);"
    info_func "operator $dm_type_char_star_quoted\(" \
				"char *foo::operator $dm_type_char_star\($dm_type_void);"

}


proc test_paddr_operator_functions {} {
    global hex
    global hp_aCC_compiler
    global dm_operator_comma
    global dm_type_char_star
    global dm_type_foo_ref
    global dm_type_long_star
    global dm_type_unsigned_int
    global dm_type_void
    global dm_type_void_star

    print_addr "foo::operator*($dm_type_foo_ref)"
    print_addr "foo::operator%($dm_type_foo_ref)"
    print_addr "foo::operator-($dm_type_foo_ref)"
    print_addr "foo::operator>>($dm_type_foo_ref)"
    print_addr "foo::operator!=($dm_type_foo_ref)"
    print_addr "foo::operator>($dm_type_foo_ref)"
    print_addr "foo::operator>=($dm_type_foo_ref)"
    print_addr "foo::operator|($dm_type_foo_ref)"
    print_addr "foo::operator&&($dm_type_foo_ref)"
    print_addr "foo::operator!($dm_type_void)"
    print_addr "foo::operator++(int)"
    print_addr "foo::operator=($dm_type_foo_ref)"
    print_addr "foo::operator+=($dm_type_foo_ref)"
    print_addr "foo::operator*=($dm_type_foo_ref)"
    print_addr "foo::operator%=($dm_type_foo_ref)"
    print_addr "foo::operator>>=($dm_type_foo_ref)"
    print_addr "foo::operator|=($dm_type_foo_ref)"
    print_addr "foo::operator$dm_operator_comma\($dm_type_foo_ref)"
    print_addr "foo::operator/($dm_type_foo_ref)"
    print_addr "foo::operator+($dm_type_foo_ref)"
    print_addr "foo::operator<<($dm_type_foo_ref)"
    print_addr "foo::operator==($dm_type_foo_ref)"
    print_addr "foo::operator<($dm_type_foo_ref)"
    print_addr "foo::operator<=($dm_type_foo_ref)"
    print_addr "foo::operator&($dm_type_foo_ref)"
    print_addr "foo::operator^($dm_type_foo_ref)"
    print_addr "foo::operator||($dm_type_foo_ref)"
    print_addr "foo::operator~($dm_type_void)"
    print_addr "foo::operator--(int)"
    print_addr "foo::operator->($dm_type_void)"
    print_addr "foo::operator-=($dm_type_foo_ref)"
    print_addr "foo::operator/=($dm_type_foo_ref)"
    print_addr "foo::operator<<=($dm_type_foo_ref)"
    print_addr "foo::operator&=($dm_type_foo_ref)"
    print_addr "foo::operator^=($dm_type_foo_ref)"
    print_addr "foo::operator->*($dm_type_foo_ref)"
    print_addr "foo::operator\[\]($dm_type_foo_ref)"
    print_addr "foo::operator()($dm_type_foo_ref)"

    gdb_test "print &'foo::operator new'" \
	" = .* $hex <foo::operator new\\(.*\\)(| static)>"
    if { !$hp_aCC_compiler } {
	print_addr "foo::operator delete($dm_type_void_star)"
    } else {
	gdb_test "print &'foo::operator delete($dm_type_void_star) static'" \
	    " = .*(0x\[0-9a-f\]+|) <foo::operator delete.*>"
    }

    print_addr "foo::operator int($dm_type_void)"
    print_addr "foo::operator $dm_type_char_star\($dm_type_void)"
}

#
# Test overloaded functions (1 arg).
#

proc test_paddr_overloaded_functions {} {
    global dm_type_unsigned_int
    global dm_type_void

    print_addr "overload1arg($dm_type_void)"
    print_addr "overload1arg(char)"
    print_addr "overload1arg(signed char)"
    print_addr "overload1arg(unsigned char)"
    print_addr "overload1arg(short)"
    print_addr "overload1arg(unsigned short)"
    print_addr "overload1arg(int)"
    print_addr "overload1arg($dm_type_unsigned_int)"
    print_addr "overload1arg(long)"
    print_addr "overload1arg(unsigned long)"
    print_addr "overload1arg(float)"
    print_addr "overload1arg(double)"

    print_addr "overloadargs(int)"
    print_addr "overloadargs(int, int)"
    print_addr "overloadargs(int, int, int)"
    print_addr "overloadargs(int, int, int, int)"
    print_addr "overloadargs(int, int, int, int, int)"
    print_addr "overloadargs(int, int, int, int, int, int)"
    print_addr "overloadargs(int, int, int, int, int, int, int)"
    print_addr "overloadargs(int, int, int, int, int, int, int, int)"
    print_addr "overloadargs(int, int, int, int, int, int, int, int, int)"
    print_addr "overloadargs(int, int, int, int, int, int, int, int, int, int)"
    print_addr "overloadargs(int, int, int, int, int, int, int, int, int, int, int)"
}

proc test_paddr_hairy_functions {} {
    global gdb_prompt
    global hex
    global dm_type_char_star
    global dm_type_int_star
    global dm_type_long_star

    print_addr_2 "hairyfunc1" "hairyfunc1(int)"
    print_addr_2 "hairyfunc2" "hairyfunc2(int (*)($dm_type_char_star))"
    print_addr_2 "hairyfunc3" "hairyfunc3(int (*)(short (*)($dm_type_long_star)))"
    print_addr_2 "hairyfunc4" "hairyfunc4(int (*)(short (*)($dm_type_char_star)))"

    # gdb-gnats bug gdb/19:
    # "gdb v3 demangler fails on hairyfunc5 hairyfunc6 hairyfunc7"
    print_addr_2_kfail "hairyfunc5" "hairyfunc5(int (*(*)($dm_type_char_star))(long))" "hairyfunc5(int (*)(long) (*)(char*))" "gdb/19"
    print_addr_2_kfail "hairyfunc6" "hairyfunc6(int (*(*)($dm_type_int_star))(long))" "hairyfunc6(int (*)(long) (*)(int*))" "gdb/19"
    print_addr_2_kfail "hairyfunc7" "hairyfunc7(int (*(*)(int (*)($dm_type_char_star)))(long))" "hairyfunc7(int (*)(long) (*)(int (*)(char*)))" "gdb/19"
}

proc do_tests {} {
    global prms_id
    global bug_id
    global subdir
    global objdir
    global srcdir
    global binfile
    global gdb_prompt

    set prms_id 0
    set bug_id 0

    # Start with a fresh gdb.

    gdb_exit
    gdb_start
    gdb_reinitialize_dir $srcdir/$subdir
    gdb_load $binfile

    send_gdb "set language c++\n"
    gdb_expect -re "$gdb_prompt $"
    send_gdb "set width 0\n"
    gdb_expect -re "$gdb_prompt $"

    runto_main

    probe_demangler
    test_paddr_overloaded_functions
    test_paddr_operator_functions
    test_paddr_hairy_functions
    test_lookup_operator_functions
}

do_tests
@


1.7
log
@2003-02-12  Michael Chastain  <mec@@shout.net>

	* gdb.c++/classes.exp: Remove setup_xfail_format for DWARF 1.
	* gdb.c++/inherit.exp: Likewise.
	* gdb.c++/cplusfuncs.exp: Remove suppression logic for DWARF 1.
	* gdb.c++/templates.exp: Likewise.
	* gdb.c++/virtfunc.exp: Likewise.
@
text
@@


1.7.28.1
log
@2003-08-22  Michael Chastain  <mec@@shout.net>

	* gdb.cp: New directory.
	* gdb.cp/*: Copy from gdb.c++/*.
	* gdb.c++/*: Remove.
	* Makefile.in: Change gdb.c++ to gdb.cp.
	* configure.in:  Ditto.
	* configure: Regnerate.
@
text
@@


1.6
log
@2003-01-16  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/cplusfuncs.exp (print_addr_2_kfail): New procedure.
	(test_paddr_hairy_functions): Call print_addr_2_kfail for
	hairyfunc5 through hairyfunc7.  KFAIL for PR c++/19.
@
text
@d555 1
a555 12
    # Get the debug format for the compiled test case.  If that
    # format is DWARF 1 then just skip all the tests since none of
    # them will pass.

    if [ runto_main] then {
	get_debug_format
	if [ setup_xfail_format "DWARF 1" ] then {
	    fail "C++ tests skipped due to limited C++ support in DWARF 1 debug format"
	    return
	}
	clear_xfail "*-*-*"
    }
@


1.5
log
@* gdb.base/default.exp: Remove obsolete code.
* gdb.c++/misc.exp: Ditto.  Update copyright.
* gdb.c++/cplusfuncs.exp: Ditto.  Update copyright.
* gdb.base/whatis.exp: Ditto.  Update copyright.
* gdb.base/scope.exp: Ditto.  Update copyright.
* gdb.base/ptype.exp: Ditto.  Update copyright.
* gdb.base/printcmds.exp: Ditto.  Update copyright.
* gdb.base/opaque.exp: Ditto.  Update copyright.
* gdb.base/list.exp: Ditto.
* gdb.base/funcargs.exp: Ditto.  Update copyright.
* gdb.hp/gdb.threads-hp/usrthbasic.c: Delete.
* gdb.hp/gdb.threads-hp/usrthbasic.exp: Delete.
* gdb.hp/gdb.threads-hp/usrthcore.c: Delete.
* gdb.hp/gdb.threads-hp/usrthcore.exp: Delete.
* gdb.hp/gdb.threads-hp/usrthfork.c: Delete.
* gdb.hp/gdb.threads-hp/usrthfork.exp: Delete.
@
text
@d1 1
a1 1
# Copyright 1992, 1997, 1999, 2001, 2002 Free Software Foundation, Inc.
d272 3
a274 1
#
d296 31
d526 3
a528 3
    print_addr_2 "hairyfunc5" "hairyfunc5(int (*(*)($dm_type_char_star))(long))"
    print_addr_2 "hairyfunc6" "hairyfunc6(int (*(*)($dm_type_int_star))(long))"
    print_addr_2 "hairyfunc7" "hairyfunc7(int (*(*)(int (*)($dm_type_char_star)))(long))"
@


1.5.16.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.5.14.1
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d1 1
a1 1
# Copyright 1992, 1997, 1999, 2001, 2002, 2003 Free Software Foundation, Inc.
d272 1
a272 3

# Note: carlton/2003-01-16: If you modify this, make a corresponding
# modification to print_addr_2_kfail.
a293 31
# NOTE: carlton/2003-01-16: hairyfunc5-6 fail on GCC 3.x (for at least
# x=1 and x=2.1).  So I'm modifying print_addr_2 to accept a failure
# condition.  FIXME: It would be nice if the failure condition were
# conditional on the compiler version, but I'm not sufficiently
# motivated.  I did hardwire in the versions of char * and int *,
# which will give some compiler-specificity to the failure.

proc print_addr_2_kfail { name good bad bugid } {
    global gdb_prompt
    global hex

    set good_pattern [string_to_regexp $good]
    set bad_pattern [string_to_regexp $bad]

    send_gdb "print &'$name'\n"
    gdb_expect {
	-re ".* = .* $hex <$good_pattern>\r\n$gdb_prompt $" {
	    pass "print &'$name'"
	}
	-re ".* = .* $hex <$bad_pattern>\r\n$gdb_prompt $" {
	    kfail $bugid "print &'$name'"
	}
	-re ".*$gdb_prompt $" {
	    fail "print &'$name'"
	}
	timeout {
	    fail "print &'$name' (timeout)"
	}
    }
}

d493 3
a495 3
    print_addr_2_kfail "hairyfunc5" "hairyfunc5(int (*(*)($dm_type_char_star))(long))" "hairyfunc5(int (*)(long) (*)(char*))" "gdb/19"
    print_addr_2_kfail "hairyfunc6" "hairyfunc6(int (*(*)($dm_type_int_star))(long))" "hairyfunc6(int (*)(long) (*)(int*))" "gdb/19"
    print_addr_2_kfail "hairyfunc7" "hairyfunc7(int (*(*)(int (*)($dm_type_char_star)))(long))" "hairyfunc7(int (*)(long) (*)(int (*)(char*)))" "gdb/19"
@


1.5.14.2
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d555 12
a566 1
    runto_main
@


1.5.14.3
log
@2003-08-22  Michael Chastain  <mec@@shout.net>

	* gdb.cp: New directory.
	* gdb.cp/*: Copy from gdb.c++/*.
	* gdb.c++/*: Remove.
	* Makefile.in: Change gdb.c++ to gdb.cp.
	* configure.in:  Ditto.
	* carlton_runnamespace: Ditto.
	* carlton_runtest: Ditto.
	* configure: Regnerate.
@
text
@@


1.4
log
@Fix PR gdb/66.
* gdb.base/structs.exp: Replace skip for a29k with skip for
gdb,cannot_call_functions.
* gdb.base/call-ar-st.exp: Remove references to a29k in comments.
* gdb.base/callfuncs.exp: Ditto.
* gdb.base/call-rt-st.exp: Ditto.
* gdb.base/call-strs.exp: Ditto.
* gdb.base/callfwmall.exp: Ditto.
* gdb.base/scope.exp: Obsolete xfail a29k.
* gdb.c++/misc.exp: Ditto.
* gdb.c++/cplusfuncs.exp: Ditto.
* gdb.base/ptype.exp: Ditto.
* gdb.base/printcmds.exp: Ditto.
* gdb.base/opaque.exp: Ditto.
* gdb.base/list.exp: Ditto.
* gdb.base/funcargs.exp: Ditto.
* gdb.base/default.exp: Ditto.
@
text
@d1 1
a1 1
# Copyright (C) 1992, 1997, 1999, 2001 Free Software Foundation, Inc.
a321 7

    # OBSOLETE # # These tests don't work for COFF targets; don't even try them
    # OBSOLETE # if [istarget "a29k-*-udi"] then {
    # OBSOLETE #     setup_xfail "a29k-*-udi"
    # OBSOLETE #     fail "skipping operator tests"
    # OBSOLETE #     return
    # OBSOLETE #  }
@


1.3
log
@2001-11-01  Michael Snyder  <msnyder@@redhat.com>

	* gdb.c++/cplusfuncs.exp: Fix conflicts between operator names
	and regular expression operators by using quoting.
@
text
@d323 6
a328 6
    # These tests don't work for COFF targets; don't even try them
    if [istarget "a29k-*-udi"] then {
	setup_xfail "a29k-*-udi"
	fail "skipping operator tests"
	return
    }
@


1.2
log
@2001-02-11  Michael Chastain  <chastain@@redhat.com>

	* gdb.c++/cplusfuncs.cc (dm_type_char_star): New function.
	Helps the test script figure out which demangler is in use.
	(dm_type_foo_ref): Ditto.
	(dm_type_int_star): Ditto.
	(dm_type_long_star): Ditto.
	(dm_type_unsigned_int): Ditto.
	(dm_type_void): Ditto.
	(dm_type_void_star): Ditto.
	* gdb.base/cplusfuncs.exp (probe_demangler): New function.
	Probe the gdb demangler and set variables to accommodate
	formatting differences.
	(info_func_regexp): New function.  Same as info_func, but
	matches against a regexp.
	(info_func): Match against a literal string.
	(print_addr_2): New function.  Match against a literal string,
	which can be different from the input to gdb.
	(print_addr): Simply call print_addr_2 with the same argument twice.
	(test_lookup_operator_functions): Use demangler formatting variables.
	Blow away the xfails and workarounds for gnats gdb bug gdb/18.  Sort
	the tests in the same order as the C++ class declaration.
	(test_paddr_operator_functions): Ditto.
	(test_paddr_overloaded_functions): Ditto.
	(test_paddr_hairy_functions): Use demangler formatting variables.
	Add reference to gdb/19 for related tests.
	(do_tests): Call probe_demangler.
@
text
@d63 1
d75 1
d107 1
d318 1
d330 2
a331 1
    info_func "operator*("	"void foo::operator*($dm_type_foo_ref);"
d344 2
a345 1
    info_func "operator*=("	"void foo::operator*=($dm_type_foo_ref);"
d368 2
a369 1
    info_func "operator->*("	"void foo::operator->*($dm_type_foo_ref);"
d371 4
a374 2
    # operator[] needs backslashes to protect against TCL evaluation.
    info_func "operator\[\]("	"void foo::operator\[\]($dm_type_foo_ref);"
d383 1
a383 1
    info_func "operator $dm_type_char_star\(" \
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
# Copyright (C) 1992, 1997 Free Software Foundation, Inc.
d21 1
d27 1
a27 3
# Check to see if we have an executable to test.  If not, then either we
# haven't tried to compile one, or the compilation failed for some reason.
# In either case, just notify the user and skip the tests in this file.
d32 5
d42 14
a55 2
#  Cause gdb to lookup a specific C++ function and print the demangled
#  form.
d57 12
d70 1
a70 1
proc info_func { regex demangled } {
d72 84
d157 1
a157 1
    send_gdb "info function $regex\n"
d159 27
a185 2
	-re "File .*:\r\n$demangled\r\n$gdb_prompt $" {
	    pass "info function for \"$regex\""
d188 1
a188 1
	    fail "info function for \"$regex\""
d191 39
a229 1
	    fail "info function for \"$regex\" (timeout)"
d235 2
a236 4
#  Run print &'$arg' on the input arg and verify that we can correctly
#  lookup the fully qualified C++ function.
#  We ignore the return type of the function since we are only interested
#  in the rootname and arguments part.
d239 33
a271 1
proc print_addr_of { arg } {
d275 3
a277 2
    set pattern [string_to_regexp $arg]
    send_gdb "print &'$arg'\n"
d279 3
a281 1
	-re ".* = .* $hex <$pattern>\r\n$gdb_prompt $" { pass "print &'$arg'" }
d283 1
a283 1
	    fail "print &'$arg'"
d286 1
a286 1
	    fail "print &'$arg' (timeout)"
d292 8
d306 5
d313 5
d326 51
a376 65
    info_func "operator&&("  "void foo::operator&&\\(foo &\\);"
    info_func "operator&=("  "void foo::operator&=\\(foo &\\);"
    info_func "operator&("  "void foo::operator&\\(foo &\\);"
    info_func "operator/=("  "void foo::operator/=\\(foo &\\);"
    info_func "operator^=("  "void foo::operator.=\\(foo &\\);"
    info_func "operator<<=("  "void foo::operator<<=\\(foo &\\);"
    info_func "operator%=("  "void foo::operator%=\\(foo &\\);"
    info_func "operator-=("  "void foo::operator-=\\(foo &\\);"

    # There doesn't appear to be any way to get GDB to treat '*' as a
    # character to match, rather than as a regex special character.
    setup_xfail "*-*-*"
    info_func "operator\*=("  "void foo::operator\\*=\\(foo &\\);"

    info_func "operator|=("  "void foo::operator\\|=\\(foo &\\);"
    info_func "operator+=("  "void foo::operator.=\\(foo &\\);"
    info_func "operator>>=("  "void foo::operator\>\>=\\(foo &\\);"
    info_func "operator=("  "void foo::operator=\\(foo &\\);"
    info_func "operator()("  "void foo::operator\\(\\)\\(foo &\\);"

    # The function should be "operator," not "operator, ".  (note space)
    # This test will work; I've commented it out because it should not
    # count as a pass, since it is incorrect.  Ian Taylor.
    # info_func "operator, ("  "void foo::operator, \\(foo &\\);"
    setup_xfail "*-*-*"
    info_func "operator,("  "void foo::operator,\\(foo &\\);"

    info_func "operator~("  "void foo::operator~\\(void\\);"
    info_func "operator delete("  "void foo::operator delete\\(void \\*\\);"
    info_func "operator/("  "void foo::operator/\\(foo &\\);"
    info_func "operator==("  "void foo::operator==\\(foo &\\);"
    info_func "operator^("  "void foo::operator\\^\\(foo &\\);"

    info_func "operator>=("  "void foo::operator>=\\(foo &\\);"
    info_func "operator>("  "void foo::operator>\\(foo &\\);"
    info_func "operator<=("  "void foo::operator<=\\(foo &\\);"
    info_func "operator<<("  "void foo::operator<<\\(foo &\\);"
    info_func "operator<("  "void foo::operator<\\(foo &\\);"
    info_func "operator%("  "void foo::operator%\\(foo &\\);"
    info_func "operator-("  "void foo::operator-\\(foo &\\);"

    # There doesn't appear to be anyway to get '*' treated as a character
    # to match, rather than as a regex special character.
    setup_xfail "*-*-*"
    info_func "operator\*("  "void foo::operator\\*\\(foo &\\);"

    info_func "operator--("  "void foo::operator--\\(int\\);"
    info_func "operator!=("  "void foo::operator!=\\(foo &\\);"
    info_func "operator!("  "void foo::operator!\\(void\\);"
    info_func "operator new("  "void \\*foo::operator new\\(.*\\);"
    info_func "operator||("  "void foo::operator\\|\\|\\(foo &\\);"
    info_func "operator char \\*("  "char \\*foo::operator char \\*\\(void\\);"
    info_func "operator int("  "int foo::operator int\\(void\\);"
    info_func "operator|("  "void foo::operator\\|\\(foo &\\);"
    info_func "operator+("  "void foo::operator\\+\\(foo &\\);"
    info_func "operator++("  "void foo::operator\\+\\+\\(int\\);"
    info_func "operator->("  "void foo::operator->\\(void\\);"
    info_func "operator->\\*("  "void foo::operator->\\*\\(foo &\\);"
    info_func "operator>>("  "void foo::operator\>\>\\(foo &\\);"

    # GDB says "`operator \[\](' not supported".  I don't know why.
    setup_xfail "*-*-*"
    info_func "operator\\\[\\\](" "void foo::operator\\\[\\\]\\(foo &\\);"
    # But this works, for some reason.
    info_func ".perator\\\[\\\](" "void foo::operator\\\[\\\]\\(foo &\\);"
d382 47
a429 31
    print_addr_of "foo::operator&&(foo &)"
    print_addr_of "foo::operator&=(foo &)"
    print_addr_of "foo::operator&(foo &)"
    print_addr_of "foo::operator/=(foo &)"
    print_addr_of "foo::operator^=(foo &)"
    print_addr_of "foo::operator<<=(foo &)"
    print_addr_of "foo::operator%=(foo &)"
    print_addr_of "foo::operator-=(foo &)"
    print_addr_of "foo::operator*=(foo &)"
    print_addr_of "foo::operator|=(foo &)"
    print_addr_of "foo::operator+=(foo &)"
    print_addr_of "foo::operator>>=(foo &)"
    print_addr_of "foo::operator=(foo &)"
    print_addr_of "foo::operator()(foo &)"
    print_addr_of "foo::operator, (foo &)"
    print_addr_of "foo::operator~(void)"
    print_addr_of "foo::operator delete(void *)"
    print_addr_of "foo::operator/(foo &)"
    print_addr_of "foo::operator==(foo &)"
    print_addr_of "foo::operator^(foo &)"
    print_addr_of "foo::operator>=(foo &)"
    print_addr_of "foo::operator>(foo &)"
    print_addr_of "foo::operator<=(foo &)"
    print_addr_of "foo::operator<<(foo &)"
    print_addr_of "foo::operator<(foo &)"
    print_addr_of "foo::operator%(foo &)"
    print_addr_of "foo::operator-(foo &)"
    print_addr_of "foo::operator*(foo &)"
    print_addr_of "foo::operator--(int)"
    print_addr_of "foo::operator!=(foo &)"
    print_addr_of "foo::operator!(void)"
d431 10
a440 12
	" = .* $hex <foo::operator new\\(.*\\)>"
    print_addr_of "foo::operator||(foo &)"
    print_addr_of "foo::operator char *(void)"
    print_addr_of "foo::operator int(void)"
    print_addr_of "foo::operator|(foo &)"
    print_addr_of "foo::operator+(foo &)"
    print_addr_of "foo::operator++(int)"
    print_addr_of "foo::operator->(void)"
    print_addr_of "foo::operator->*(foo &)"
    print_addr_of "foo::operator>>(foo &)"
    gdb_test "print &'foo::operator\[\](foo &)'" \
	" = .*0x\[0-9a-f\]+ <foo::operator\\\[\\\]\\(foo &\\)>"
d448 27
a474 23
    print_addr_of "overload1arg(signed char)"
    print_addr_of "overload1arg(unsigned char)"
    print_addr_of "overload1arg(unsigned int)"
    print_addr_of "overload1arg(unsigned long)"
    print_addr_of "overload1arg(unsigned short)"
    print_addr_of "overload1arg(char)"
    print_addr_of "overload1arg(double)"
    print_addr_of "overload1arg(float)"
    print_addr_of "overload1arg(int)"
    print_addr_of "overload1arg(long)"
    print_addr_of "overload1arg(short)"
    print_addr_of "overload1arg(void)"
    print_addr_of "overloadargs(int)"
    print_addr_of "overloadargs(int, int)"
    print_addr_of "overloadargs(int, int, int)"
    print_addr_of "overloadargs(int, int, int, int)"
    print_addr_of "overloadargs(int, int, int, int, int)"
    print_addr_of "overloadargs(int, int, int, int, int, int)"
    print_addr_of "overloadargs(int, int, int, int, int, int, int)"
    print_addr_of "overloadargs(int, int, int, int, int, int, int, int)"
    print_addr_of "overloadargs(int, int, int, int, int, int, int, int, int)"
    print_addr_of "overloadargs(int, int, int, int, int, int, int, int, int, int)"
    print_addr_of "overloadargs(int, int, int, int, int, int, int, int, int, int, int)"
d478 16
a493 7
    print_addr_of "hairyfunc1(int)"
    print_addr_of "hairyfunc2(int (*)(char *))"
    print_addr_of "hairyfunc3(int (*)(short (*)(long *)))"
    print_addr_of "hairyfunc4(int (*)(short (*)(char *)))"
    print_addr_of "hairyfunc5(int (*(*)(char *))(long))"
    print_addr_of "hairyfunc6(int (*(*)(int *))(long))"
    print_addr_of "hairyfunc7(int (*(*)(int (*)(char *)))(long))"
d533 1
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-08-02 snapshot
@
text
@a36 4
if {[get_compiler_info $binfile "c++"] == -1} {
    return -1
}

d47 1
a47 4
	-re "File .*:\r\n$demangled\r\n.*$gdb_prompt $" {
	    pass "info function for \"$regex\""
	}
	-re "File .*:\r\nclass $demangled\r\n.*$gdb_prompt $" {
d128 1
a128 1
    info_func "operator delete("  "void foo::operator delete\\(void \\*\\)(| static);"
d149 1
a149 1
    info_func "operator new("  "void \\*foo::operator new\\(.*\\)(| static);"
d156 1
a156 1
    info_func "operator->("  "foo \\*foo::operator->\\(void\\);"
a169 1
    global hp_aCC_compiler
d187 1
a187 6
    if { !$hp_aCC_compiler } {
	print_addr_of "foo::operator delete(void *)"
    } else {
	gdb_test "print &'foo::operator delete(void *) static'" \
	    " = .*(0x\[0-9a-f\]+|) <foo::operator delete.*>"
    }
d203 1
a203 1
	" = .* $hex <foo::operator new\\(.*\\)(| static)>"
@


1.1.1.3
log
@import gdb-1999-09-08 snapshot
@
text
@d1 1
a1 1
# Copyright (C) 1992, 1997, 1999 Free Software Foundation, Inc.
d26 3
a28 1
if { [skip_cplus_tests] } { continue }
d33 3
d37 1
a37 1
if { [get_compiler_info $binfile "c++"] } {
a38 4
}

if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug c++}] != "" } {
     gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
@


