head	1.6;
access;
symbols
	cagney_x86i386-20030821-branch:1.5.0.60
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.58
	gdb_6_0-2003-06-23-branchpoint:1.5
	jimb-ppc64-linux-20030613-branch:1.5.0.56
	jimb-ppc64-linux-20030613-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.54
	cagney_writestrings-20030508-branchpoint:1.5
	jimb-ppc64-linux-20030528-branch:1.5.0.52
	jimb-ppc64-linux-20030528-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.50
	cagney_fileio-20030521-branchpoint:1.5
	kettenis_i386newframe-20030517-mergepoint:1.5
	jimb-ppc64-linux-20030509-branch:1.5.0.48
	jimb-ppc64-linux-20030509-branchpoint:1.5
	kettenis_i386newframe-20030504-mergepoint:1.5
	carlton_dictionary-20030430-merge:1.5
	kettenis_i386newframe-20030419-branch:1.5.0.46
	kettenis_i386newframe-20030419-branchpoint:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	kettenis_i386newframe-20030406-branch:1.5.0.44
	kettenis_i386newframe-20030406-branchpoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.42
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.40
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.38
	cagney_lazyid-20030317-branchpoint:1.5
	kettenis-i386newframe-20030316-mergepoint:1.5
	offbyone-20030313-branch:1.5.0.36
	offbyone-20030313-branchpoint:1.5
	kettenis-i386newframe-20030308-branch:1.5.0.34
	kettenis-i386newframe-20030308-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.32
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030203-mergepoint:1.5
	interps-20030202-branch:1.5.0.30
	interps-20030202-branchpoint:1.5
	cagney-unwind-20030108-branch:1.5.0.28
	cagney-unwind-20030108-branchpoint:1.5
	carlton_dictionary-20021223-merge:1.5
	gdb_5_3-2002-12-12-release:1.5
	carlton_dictionary-20021115-merge:1.5
	kseitz_interps-20021105-merge:1.5
	kseitz_interps-20021103-merge:1.5
	drow-cplus-merge-20021020:1.5
	drow-cplus-merge-20021025:1.5
	carlton_dictionary-20021025-merge:1.5
	carlton_dictionary-20021011-merge:1.5
	drow-cplus-branch:1.5.0.26
	drow-cplus-branchpoint:1.5
	kseitz_interps-20020930-merge:1.5
	carlton_dictionary-20020927-merge:1.5
	carlton_dictionary-branch:1.5.0.24
	carlton_dictionary-20020920-branchpoint:1.5
	gdb_5_3-branch:1.5.0.22
	gdb_5_3-2002-09-04-branchpoint:1.5
	kseitz_interps-20020829-merge:1.5
	cagney_sysregs-20020825-branch:1.5.0.20
	cagney_sysregs-20020825-branchpoint:1.5
	readline_4_3-import-branch:1.5.0.18
	readline_4_3-import-branchpoint:1.5
	gdb_5_2_1-2002-07-23-release:1.5
	kseitz_interps-20020528-branch:1.5.0.16
	kseitz_interps-20020528-branchpoint:1.5
	cagney_regbuf-20020515-branch:1.5.0.14
	cagney_regbuf-20020515-branchpoint:1.5
	jimb-macro-020506-branch:1.5.0.12
	jimb-macro-020506-branchpoint:1.5
	gdb_5_2-2002-04-29-release:1.5
	gdb_5_2-branch:1.5.0.10
	gdb_5_2-2002-03-03-branchpoint:1.5
	gdb_5_1_1-2002-01-24-release:1.5
	gdb_5_1_0_1-2002-01-03-release:1.5
	cygnus_cvs_20020108_pre:1.5
	gdb_5_1_0_1-2002-01-03-branch:1.5.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.5
	gdb_5_1-2001-11-21-release:1.5
	gdb_s390-2001-09-26-branch:1.5.0.6
	gdb_s390-2001-09-26-branchpoint:1.5
	gdb_5_1-2001-07-29-branch:1.5.0.4
	gdb_5_1-2001-07-29-branchpoint:1.5
	dberlin-typesystem-branch:1.5.0.2
	dberlin-typesystem-branchpoint:1.5
	gdb-post-ptid_t-2001-05-03:1.5
	gdb-pre-ptid_t-2001-05-03:1.5
	insight-precleanup-2001-01-01:1.3
	gdb-post-protoization-2000-07-29:1.3
	gdb-pre-protoization-2000-07-29:1.3
	gdb-premipsmulti-2000-06-06-branch:1.3.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb-post-params-removal-2000-06-04:1.2
	gdb-pre-params-removal-2000-06-04:1.2
	gdb-post-params-removal-2000-05-28:1.2
	gdb-pre-params-removal-2000-05-28:1.2
	gdb_5_0-2000-05-19-release:1.1.1.3.2.1
	gdb_4_18_2-2000-05-18-release:1.1.1.3.2.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.3.2.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.3
	gdb_5_0-2000-04-10-branch:1.1.1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.3
	repo-unification-2000-02-06:1.1.1.3
	insight-2000-02-04:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.3
	gdb-1999-12-06:1.1.1.3
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.3
	gdb-1999-10-18:1.1.1.3
	gdb-1999-10-11:1.1.1.3
	gdb-1999-10-04:1.1.1.3
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.3
	gdb-1999-09-08:1.1.1.3
	gdb-1999-08-30:1.1.1.3
	gdb-1999-08-23:1.1.1.3
	gdb-1999-08-16:1.1.1.3
	gdb-1999-08-09:1.1.1.3
	gdb-1999-08-02:1.1.1.3
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@// @;
expand	@o@;


1.6
date	2003.08.23.03.55.59;	author chastain;	state dead;
branches;
next	1.5;

1.5
date	2001.01.30.22.18.21;	author kevinb;	state Exp;
branches
	1.5.24.1
	1.5.26.1
	1.5.58.1;
next	1.4;

1.4
date	2001.01.30.16.45.23;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.05.20.47.28;	author dberlin;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.01.05.45.36;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.32;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.32;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.06.07.19.19.32;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.08.02.23.46.56;	author jsm;	state Exp;
branches
	1.1.1.3.2.1;
next	;

1.1.1.3.2.1
date	2000.05.01.05.45.32;	author cagney;	state Exp;
branches;
next	;

1.5.24.1
date	2003.08.30.03.40.34;	author chastain;	state dead;
branches;
next	;

1.5.26.1
date	2003.12.14.20.27.51;	author drow;	state dead;
branches;
next	;

1.5.58.1
date	2003.08.25.03.53.48;	author chastain;	state dead;
branches;
next	;


desc
@@


1.6
log
@2003-08-22  Michael Chastain  <mec@@shout.net>

	* gdb.cp: New directory.
	* gdb.cp/*: Copy from gdb.c++/*.
	* gdb.c++/*: Remove.
	* Makefile.in: Change gdb.c++ to gdb.cp.
	* configure.in:  Ditto.
	* configure: Regnerate.
@
text
@/* This test code is from Wendell Baker (wbaker@@comet.berkeley.edu) */

#include <stddef.h>

int a_i;
char a_c;
double a_d;

typedef void *Pix;

int
f(int i)
{ return 0; }

int
f(int i, char c)
{ return 0; }

int
f(int i, char c, double d)
{ return 0; }

int
f(int i, char c, double d, char *cs)
{ return 0; }

int
f(int i, char c, double d, char *cs, void (*fig)(int, char))
{ return 0; }

int
f(int i, char c, double d, char *cs, void (*fig)(char, int))
{ return 0; }

class R {
public:
    int i;
};
class S {
public:
    int i;
};
class T {
public:
    int i;
};

char g(char, const char, volatile char)
{ return 'c'; }
char g(R, char&, const char&, volatile char&)
{ return 'c'; }
char g(char*, const char*, volatile char*)
{ return 'c'; }
char g(S, char*&, const char*&, volatile char*&)
{ return 'c'; }

signed char g(T,signed char, const signed char, volatile signed char)
{ return 'c'; }
signed char g(T, R, signed char&, const signed char&, volatile signed char&)
{ return 'c'; }
signed char g(T, signed char*, const signed char*, volatile signed char*)
{ return 'c'; }
signed char g(T, S, signed char*&, const signed char*&, volatile signed char*&)
{ return 'c'; }

unsigned char g(unsigned char, const unsigned char, volatile unsigned char)
{ return 'c'; }
unsigned char g(R, unsigned char&, const unsigned char&, volatile unsigned char&)
{ return 'c'; }
unsigned char g(unsigned char*, const unsigned char*, volatile unsigned char*)
{ return 'c'; }
unsigned char g(S, unsigned char*&, const unsigned char*&, volatile unsigned char*&)
{ return 'c'; }

short g(short, const short, volatile short)
{ return 0; }
short g(R, short&, const short&, volatile short&)
{ return 0; }
short g(short*, const short*, volatile short*)
{ return 0; }
short g(S, short*&, const short*&, volatile short*&)
{ return 0; }

signed short g(T, signed short, const signed short, volatile signed short)
{ return 0; }
signed short g(T, R, signed short&, const signed short&, volatile signed short&)
{ return 0; }
signed short g(T, signed short*, const signed short*, volatile signed short*)
{ return 0; }
signed short g(T, S, double, signed short*&, const signed short*&, volatile signed short*&)
{ return 0; }

unsigned short g(unsigned short, const unsigned short, volatile unsigned short)
{ return 0; }
unsigned short g(R, unsigned short&, const unsigned short&, volatile unsigned short&)
{ return 0; }
unsigned short g(unsigned short*, const unsigned short*, volatile unsigned short*)
{ return 0; }
unsigned short g(S, unsigned short*&, const unsigned short*&, volatile unsigned short*&)
{ return 0; }

int g(int, const int, volatile int)
{ return 0; }
int g(R, int&, const int&, volatile int&)
{ return 0; }
int g(int*, const int*, volatile int*)
{ return 0; }
int g(S, int*&, const int*&, volatile int*&)
{ return 0; }

signed int g(T, signed int, const signed int, volatile signed int)
{ return 0; }
signed int g(T, R, signed int&, const signed int&, volatile signed int&)
{ return 0; }
signed int g(T, signed int*, const signed int*, volatile signed int*)
{ return 0; }
signed int g(T, S, signed int*&, const signed int*&, volatile signed int*&)
{ return 0; }

unsigned int g(unsigned int, const unsigned int, volatile unsigned int)
{ return 0; }
unsigned int g(R, unsigned int&, const unsigned int&, volatile unsigned int&)
{ return 0; }
unsigned int g(unsigned int*, const unsigned int*, volatile unsigned int*)
{ return 0; }
unsigned int g(S, unsigned int*&, const unsigned int*&, volatile unsigned int*&)
{ return 0; }

long g(long, const long, volatile long)
{ return 0; }
long g(R, long&, const long&, volatile long&)
{ return 0; }
long g(long*, const long*, volatile long*)
{ return 0; }
long g(S, long*&, const long*&, volatile long*&)
{ return 0; }

signed long g(T, signed long, const signed long, volatile signed long)
{ return 0; }
signed long g(T, R, signed long&, const signed long&, volatile signed long&)
{ return 0; }
signed long g(T, signed long*, const signed long*, volatile signed long*)
{ return 0; }
signed long g(T, S, signed long*&, const signed long*&, volatile signed long*&)
{ return 0; }

unsigned long g(unsigned long, const unsigned long, volatile unsigned long)
{ return 0; }
unsigned long g(S, unsigned long&, const unsigned long&, volatile unsigned long&)
{ return 0; }
unsigned long g(unsigned long*, const unsigned long*, volatile unsigned long*)
{ return 0; }
unsigned long g(S, unsigned long*&, const unsigned long*&, volatile unsigned long*&)
{ return 0; }

#ifdef __GNUC__
long long g(long long, const long long, volatile long long)
{ return 0; }
long long g(S, long long&, const long long&, volatile long long&)
{ return 0; }
long long g(long long*, const long long*, volatile long long*)
{ return 0; }
long long g(R, long long*&, const long long*&, volatile long long*&)
{ return 0; }

signed long long g(T, signed long long, const signed long long, volatile signed long long)
{ return 0; }
signed long long g(T, R, signed long long&, const signed long long&, volatile signed long long&)
{ return 0; }
signed long long g(T, signed long long*, const signed long long*, volatile signed long long*)
{ return 0; }
signed long long g(T, S, signed long long*&, const signed long long*&, volatile signed long long*&)
{ return 0; }

unsigned long long g(unsigned long long, const unsigned long long, volatile unsigned long long)
{ return 0; }
unsigned long long g(R, unsigned long long*, const unsigned long long*, volatile unsigned long long*)
{ return 0; }
unsigned long long g(unsigned long long&, const unsigned long long&, volatile unsigned long long&)
{ return 0; }
unsigned long long g(S, unsigned long long*&, const unsigned long long*&, volatile unsigned long long*&)
{ return 0; }
#endif

float g(float, const float, volatile float)
{ return 0; }
float g(char, float&, const float&, volatile float&)
{ return 0; }
float g(float*, const float*, volatile float*)
{ return 0; }
float g(char, float*&, const float*&, volatile float*&)
{ return 0; }

double g(double, const double, volatile double)
{ return 0; }
double g(char, double&, const double&, volatile double&)
{ return 0; }
double g(double*, const double*, volatile double*)
{ return 0; }
double g(char, double*&, const double*&, volatile double*&)
{ return 0; }

#ifdef __GNUC__
long double g(long double, const long double, volatile long double)
{ return 0; }
long double g(char, long double&, const long double&, volatile long double&)
{ return 0; }
long double g(long double*, const long double*, volatile long double*)
{ return 0; }
long double g(char, long double*&, const long double*&, volatile long double*&)
{ return 0; }
#endif

class c {
public:
    c(int) {};
    int i;
};

class c g(c, const c, volatile c)
{ return 0; }
c g(char, c&, const c&, volatile c&)
{ return 0; }
c g(c*, const c*, volatile c*)
{ return 0; }
c g(char, c*&, const c*&, volatile c*&)
{ return 0; }

/*
void h(char = 'a')
{ }
void h(char, signed char = 'a')
{ }
void h(unsigned char = 'a')
{ }
*/
/*
void h(char = (char)'a')
{ }
void h(char, signed char = (signed char)'a')
{ }
void h(unsigned char = (unsigned char)'a')
{ }


void h(short = (short)43)
{ }
void h(char, signed short = (signed short)43)
{ }
void h(unsigned short = (unsigned short)43)
{ }

void h(int = (int)43)
{ }
void h(char, signed int = (signed int)43)
{ }
void h(unsigned int = (unsigned int)43)
{ }


void h(long = (long)43)
{ }
void h(char, signed long = (signed long)43)
{ }
void h(unsigned long = (unsigned long)43)
{ }

#ifdef __GNUC__
void h(long long = 43)
{ }
void h(char, signed long long = 43)
{ }
void h(unsigned long long = 43)
{ }
#endif

void h(float = 4.3e-10)
{ }
void h(double = 4.3)
{ }
#ifdef __GNUC__
void h(long double = 4.33e33)
{ }
#endif
*/

/* An unneeded printf() definition - actually, just a stub - used to occupy
   this space.  It has been removed and replaced with this comment which
   exists to occupy some lines so that templates.exp won't need adjustment.  */

class T1 {
public:
    static void* operator new(size_t) throw ();
    static void operator delete(void *pointer);

    void operator=(const T1&);
    T1& operator=(int);

    int operator==(int) const;
    int operator==(const T1&) const;
    int operator!=(int) const;
    int operator!=(const T1&) const;

    int operator<=(int) const;
    int operator<=(const T1&) const;
    int operator<(int) const;
    int operator<(const T1&) const;
    int operator>=(int) const;
    int operator>=(const T1&) const;
    int operator>(int) const;
    int operator>(const T1&) const;

    void operator+(int) const;
    T1& operator+(const T1&) const;
    void operator+=(int) const;
    T1& operator+=(const T1&) const;

    T1& operator++() const;

    void operator-(int) const;
    T1& operator-(const T1&) const;
    void operator-=(int) const;
    T1& operator-=(const T1&) const;

    T1& operator--() const;

    void operator*(int) const;
    T1& operator*(const T1&) const;
    void operator*=(int) const;
    T1& operator*=(const T1&) const;

    void operator/(int) const;
    T1& operator/(const T1&) const;
    void operator/=(int) const;
    T1& operator/=(const T1&) const;

    void operator%(int) const;
    T1& operator%(const T1&) const;
    void operator%=(int) const;
    T1& operator%=(const T1&) const;

    void operator&&(int) const;
    T1& operator&&(const T1&) const;

    void operator||(int) const;
    T1& operator||(const T1&) const;

    void operator&(int) const;
    T1& operator&(const T1&) const;
    void operator&=(int) const;
    T1& operator&=(const T1&) const;

    void operator|(int) const;
    T1& operator|(const T1&) const;
    void operator|=(int) const;
    T1& operator|=(const T1&) const;

    void operator^(int) const;
    T1& operator^(const T1&) const;
    void operator^=(int) const;
    T1& operator^=(const T1&) const;

    T1& operator!() const;
    T1& operator~() const;
};

void* 
T1::operator new(size_t) throw ()
{ return 0; }

void
T1::operator delete(void *pointer)
{ }

class T2 {
public:
    T2(int i): integer(i)
	{ }
    int integer;
};

int operator==(const T2&, const T2&)
{ return 0; }
int operator==(const T2&, char)
{ return 0; }
int operator!=(const T2&, const T2&)
{ return 0; }
int operator!=(const T2&, char)
{ return 0; }

int operator<=(const T2&, const T2&)
{ return 0; }
int operator<=(const T2&, char)
{ return 0; }
int operator<(const T2&, const T2&)
{ return 0; }
int operator<(const T2&, char)
{ return 0; }
int operator>=(const T2&, const T2&)
{ return 0; }
int operator>=(const T2&, char)
{ return 0; }
int operator>(const T2&, const T2&)
{ return 0; }
int operator>(const T2&, char)
{ return 0; }

T2 operator+(const T2 t, int i)
{ return t.integer + i; }
T2 operator+(const T2 a, const T2& b)
{ return a.integer + b.integer; }
T2& operator+=(T2& t, int i)
{ t.integer += i; return t; }
T2& operator+=(T2& a, const T2& b)
{ a.integer += b.integer; return a; }

T2 operator-(const T2 t, int i)
{ return t.integer - i; }
T2 operator-(const T2 a, const T2& b)
{ return a.integer - b.integer; }
T2& operator-=(T2& t, int i)
{ t.integer -= i; return t; }
T2& operator-=(T2& a, const T2& b)
{ a.integer -= b.integer; return a; }

T2 operator*(const T2 t, int i)
{ return t.integer * i; }
T2 operator*(const T2 a, const T2& b)
{ return a.integer * b.integer; }
T2& operator*=(T2& t, int i)
{ t.integer *= i; return t; }
T2& operator*=(T2& a, const T2& b)
{ a.integer *= b.integer; return a; }

T2 operator/(const T2 t, int i)
{ return t.integer / i; }
T2 operator/(const T2 a, const T2& b)
{ return a.integer / b.integer; }
T2& operator/=(T2& t, int i)
{ t.integer /= i; return t; }
T2& operator/=(T2& a, const T2& b)
{ a.integer /= b.integer; return a; }

T2 operator%(const T2 t, int i)
{ return t.integer % i; }
T2 operator%(const T2 a, const T2& b)
{ return a.integer % b.integer; }
T2& operator%=(T2& t, int i)
{ t.integer %= i; return t; }
T2& operator%=(T2& a, const T2& b)
{ a.integer %= b.integer; return a; }

template<class T>
class T5 {
public:
    T5(int);
    T5(const T5<T>&);
    ~T5();
    static void* operator new(size_t) throw ();
    static void operator delete(void *pointer);
    int value();
    
    static T X;
    T x;
    int val;
};

template<class T>
T5<T>::T5(int v)
{ val = v; }

template<class T>
T5<T>::T5(const T5<T>&)
{}

template<class T>
T5<T>::~T5()
{}

template<class T>
void*
T5<T>::operator new(size_t) throw ()
{ return 0; }

template<class T>
void
T5<T>::operator delete(void *pointer)
{ }

template<class T>
int
T5<T>::value()
{ return val; }


#if ! defined(__GNUC__) || defined(GCC_BUG)
template<class T>
T T5<T>::X;
#endif




T5<char> t5c(1);
T5<int> t5i(2);
T5<int (*)(char, void *)> t5fi1(3);
T5<int (*)(int, double **, void *)> t5fi2(4);

 




class x {
public:
    int (*manage[5])(double,
		     void *(*malloc)(unsigned size),
		     void (*free)(void *pointer));
    int (*device[5])(int open(const char *, unsigned mode, unsigned perms, int extra), 
		     int *(*read)(int fd, void *place, unsigned size),
		     int *(*write)(int fd, void *place, unsigned size),
		     void (*close)(int fd));
};
T5<x> t5x(5);

#if !defined(__GNUC__) || (__GNUC__ > 2) || (__GNUC__ == 2 && __GNUC_MINOR__ >= 6)
template class T5<char>;
template class T5<int>;
template class T5<int (*)(char, void *)>;
template class T5<int (*)(int, double **, void *)>;
template class T5<x>;
#endif

class T7 {
public:
    static int get();
    static void put(int);
};

int
T7::get()
{ return 1; }

void
T7::put(int i)
{
    // nothing
}

// More template kinds.  GDB 4.16 didn't handle these, but
// Wildebeest does.  Note: Assuming HP aCC is used to compile
// this file; with g++ or HP cfront or other compilers the
// demangling may not get done correctly.

// Ordinary template, to be instantiated with different types
template<class T>
class Foo {
public:
  int x;
  T t;
  T foo (int, T);
};


template<class T> T Foo<T>::foo (int i, T tt)
{
  return tt;
}

// Template with int parameter

template<class T, int sz>
class Bar {
public:
  int x;
  T t;
  T bar (int, T);
};


template<class T, int sz> T Bar<T, sz>::bar (int i, T tt)
{
  if (i < sz)
    return tt;
  else
    return 0;
}

// function template with int parameter
template<class T> int dummy (T tt, int i)
{
  return tt;
}

// Template with partial specializations
template<class T1, class T2>
class Spec {
public:
  int x;
  T1 spec (T2);
};

template<class T1, class T2>
T1 Spec<T1, T2>::spec (T2 t2)
{
  return 0;
}

template<class T>
class Spec<T, T*> {
public:
  int x;
  T spec (T*);
};

template<class T>
T Spec<T, T*>::spec (T * tp)
{
  return *tp;
}

// Template with char parameter
template<class T, char sz>
class Baz {
public:
  int x;
  T t;
  T baz (int, T);
};

template<class T, char sz> T Baz<T, sz>::baz (int i, T tt)
{
  if (i < sz)
    return tt;
  else
    return 0;
}

// Template with char * parameter
template<class T, char * sz>
class Qux {
public:
  int x;
  T t;
  T qux (int, T);
};

template<class T, char * sz> T Qux<T, sz>::qux (int i, T tt)
{
  if (sz[0] == 'q')
    return tt;
  else
    return 0;
}

// Template with a function pointer parameter
template<class T, int (*f)(int) >
class Qux1 {
public:
  int x;
  T t;
  T qux (int, T);
};

template<class T, int (*f)(int)> T Qux1<T, f>::qux (int i, T tt)
{
  if (f != 0)
    return tt;
  else
    return 0;
}

// Some functions to provide as arguments to template
int gf1 (int a) {
  return a * 2 + 13;
}
int gf2 (int a) {
  return a * 2 + 26;
}

char string[3];


// Template for nested instantiations

template<class T>
class Garply {
public:
  int x;
  T t;
  T garply (int, T);
};

template<class T> T Garply<T>::garply (int i, T tt)
{
  if (i > x)
    return tt;
  else
    {
      x += i;
      return tt;
    }
}


int main()
{
    int i;
#ifdef usestubs
    set_debug_traps();
    breakpoint();
#endif
    i = i + 1;

    // New tests added here

  Foo<int> fint={0,0};
  Foo<char> fchar={0,0};
  Foo<volatile char *> fvpchar = {0, 0};

  Bar<int, 33> bint;
  Bar<int, (4 > 3)> bint2;

  Baz<int, 's'> bazint;
  Baz<char, 'a'> bazint2;

  Qux<char, string> quxint2;
  Qux<int, string> quxint;

  Qux1<int, gf1> qux11;

  int x = fint.foo(33, 47);
  char c = fchar.foo(33, 'x');
  volatile char * cp = fvpchar.foo(33, 0);
  
  int y = dummy<int> (400, 600);

  int z = bint.bar(55, 66);
  z += bint2.bar(55, 66);

  c = bazint2.baz(4, 'y');
  c = quxint2.qux(4, 'z');
  
  y = bazint.baz(4,3);
  y = quxint.qux(4, 22);
  y += qux11.qux(4, 22);

  y *= gf1(y) - gf2(y);
  
  Spec<int, char> sic;
  Spec<int, int *> siip;

  sic.spec ('c');
  siip.spec (&x);

  Garply<int> f;
  Garply<char> fc;
  f.x = 13;

  Garply<Garply<char> > nf;
  nf.x = 31;
  
  x = f.garply (3, 4);
  
  fc = nf.garply (3, fc);

  y = x + fc.x;
  

  return 0;
    
}













@


1.5
log
@Replace blanked lines from earlier commit with comment stating that
the reason why the space is empty.
@
text
@@


1.5.26.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.5.24.1
log
@2003-08-22  Michael Chastain  <mec@@shout.net>

	* gdb.cp: New directory.
	* gdb.cp/*: Copy from gdb.c++/*.
	* gdb.c++/*: Remove.
	* Makefile.in: Change gdb.c++ to gdb.cp.
	* configure.in:  Ditto.
	* carlton_runnamespace: Ditto.
	* carlton_runtest: Ditto.
	* configure: Regnerate.
@
text
@@


1.5.58.1
log
@2003-08-22  Michael Chastain  <mec@@shout.net>

	* gdb.cp: New directory.
	* gdb.cp/*: Copy from gdb.c++/*.
	* gdb.c++/*: Remove.
	* Makefile.in: Change gdb.c++ to gdb.cp.
	* configure.in:  Ditto.
	* configure: Regnerate.
@
text
@@


1.4
log
@Remove unused printf() definition.
@
text
@d287 3
a289 3



@


1.3
log
@New tests, fix old tests, make more tests work
@
text
@d286 4
a289 4
void printf(const char *format, ... )
{
    // elipsis
}
@


1.2
log
@From 2000-04-28 Andreas Jaeger <aj@@suse.de>:
Properly check for GCC version number.
@
text
@d717 2
a718 2
  Foo<int> fint;
  Foo<char> fchar;
@


1.1
log
@Initial revision
@
text
@d293 1
a293 1
    static void* operator new(size_t);
d368 1
a368 1
T1::operator new(size_t)
d459 1
a459 1
    static void* operator new(size_t);
d482 1
a482 1
T5<T>::operator new(size_t)
d519 1
a519 1
    int (*device[5])(int open(const char *, unsigned mode, unsigned perms, int extra = 0), 
d526 1
a526 1
#if !defined(__GNUC__) || (__GNUC__ >= 2 && __GNUC_MINOR__ >= 6)
d719 1
a719 1
  Foo<volatile char *> fvpchar;
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-06-07 snapshot
@
text
@d293 1
a293 1
    static void* operator new(size_t) throw ();
d368 1
a368 1
T1::operator new(size_t) throw ()
d459 1
a459 1
    static void* operator new(size_t) throw ();
d482 1
a482 1
T5<T>::operator new(size_t) throw ()
@


1.1.1.3
log
@import gdb-1999-08-02 snapshot
@
text
@d519 1
a519 1
    int (*device[5])(int open(const char *, unsigned mode, unsigned perms, int extra), 
d719 1
a719 1
  Foo<volatile char *> fvpchar = {0, 0};
@


1.1.1.3.2.1
log
@From 2000-04-28 Andreas Jaeger <aj@@suse.de>:
Properly check for GCC version number.
@
text
@d526 1
a526 1
#if !defined(__GNUC__) || (__GNUC__ > 2) || (__GNUC__ == 2 && __GNUC_MINOR__ >= 6)
@


