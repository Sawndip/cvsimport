head	1.20;
access;
symbols
	cagney_x86i386-20030821-branch:1.19.0.2
	cagney_x86i386-20030821-branchpoint:1.19
	carlton_dictionary-20030805-merge:1.19
	carlton_dictionary-20030627-merge:1.18
	gdb_6_0-branch:1.18.0.26
	gdb_6_0-2003-06-23-branchpoint:1.18
	jimb-ppc64-linux-20030613-branch:1.18.0.24
	jimb-ppc64-linux-20030613-branchpoint:1.18
	cagney_writestrings-20030508-branch:1.18.0.22
	cagney_writestrings-20030508-branchpoint:1.18
	jimb-ppc64-linux-20030528-branch:1.18.0.20
	jimb-ppc64-linux-20030528-branchpoint:1.18
	carlton_dictionary-20030523-merge:1.18
	cagney_fileio-20030521-branch:1.18.0.18
	cagney_fileio-20030521-branchpoint:1.18
	kettenis_i386newframe-20030517-mergepoint:1.18
	jimb-ppc64-linux-20030509-branch:1.18.0.16
	jimb-ppc64-linux-20030509-branchpoint:1.18
	kettenis_i386newframe-20030504-mergepoint:1.18
	carlton_dictionary-20030430-merge:1.18
	kettenis_i386newframe-20030419-branch:1.18.0.14
	kettenis_i386newframe-20030419-branchpoint:1.18
	carlton_dictionary-20030416-merge:1.18
	cagney_frameaddr-20030409-mergepoint:1.18
	kettenis_i386newframe-20030406-branch:1.18.0.12
	kettenis_i386newframe-20030406-branchpoint:1.18
	cagney_frameaddr-20030403-branchpoint:1.18
	cagney_frameaddr-20030403-branch:1.18.0.10
	cagney_framebase-20030330-mergepoint:1.18
	cagney_framebase-20030326-branch:1.18.0.8
	cagney_framebase-20030326-branchpoint:1.18
	cagney_lazyid-20030317-branch:1.18.0.6
	cagney_lazyid-20030317-branchpoint:1.18
	kettenis-i386newframe-20030316-mergepoint:1.18
	offbyone-20030313-branch:1.18.0.4
	offbyone-20030313-branchpoint:1.18
	kettenis-i386newframe-20030308-branch:1.18.0.2
	kettenis-i386newframe-20030308-branchpoint:1.18
	carlton_dictionary-20030305-merge:1.18
	cagney_offbyone-20030303-branch:1.17.0.2
	cagney_offbyone-20030303-branchpoint:1.17
	carlton_dictionary-20030207-merge:1.12
	interps-20030203-mergepoint:1.12
	interps-20030202-branch:1.12.0.22
	interps-20030202-branchpoint:1.12
	cagney-unwind-20030108-branch:1.12.0.20
	cagney-unwind-20030108-branchpoint:1.12
	carlton_dictionary-20021223-merge:1.12
	gdb_5_3-2002-12-12-release:1.12
	carlton_dictionary-20021115-merge:1.12
	kseitz_interps-20021105-merge:1.12
	kseitz_interps-20021103-merge:1.12
	drow-cplus-merge-20021020:1.12
	drow-cplus-merge-20021025:1.12
	carlton_dictionary-20021025-merge:1.12
	carlton_dictionary-20021011-merge:1.12
	drow-cplus-branch:1.12.0.18
	drow-cplus-branchpoint:1.12
	kseitz_interps-20020930-merge:1.12
	carlton_dictionary-20020927-merge:1.12
	carlton_dictionary-branch:1.12.0.16
	carlton_dictionary-20020920-branchpoint:1.12
	gdb_5_3-branch:1.12.0.14
	gdb_5_3-2002-09-04-branchpoint:1.12
	kseitz_interps-20020829-merge:1.12
	cagney_sysregs-20020825-branch:1.12.0.12
	cagney_sysregs-20020825-branchpoint:1.12
	readline_4_3-import-branch:1.12.0.10
	readline_4_3-import-branchpoint:1.12
	gdb_5_2_1-2002-07-23-release:1.12
	kseitz_interps-20020528-branch:1.12.0.8
	kseitz_interps-20020528-branchpoint:1.12
	cagney_regbuf-20020515-branch:1.12.0.6
	cagney_regbuf-20020515-branchpoint:1.12
	jimb-macro-020506-branch:1.12.0.4
	jimb-macro-020506-branchpoint:1.12
	gdb_5_2-2002-04-29-release:1.12
	gdb_5_2-branch:1.12.0.2
	gdb_5_2-2002-03-03-branchpoint:1.12
	gdb_5_1_1-2002-01-24-release:1.5
	gdb_5_1_0_1-2002-01-03-release:1.5
	cygnus_cvs_20020108_pre:1.10
	gdb_5_1_0_1-2002-01-03-branch:1.5.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.5
	gdb_5_1-2001-11-21-release:1.5
	gdb_s390-2001-09-26-branch:1.5.0.6
	gdb_s390-2001-09-26-branchpoint:1.5
	gdb_5_1-2001-07-29-branch:1.5.0.4
	gdb_5_1-2001-07-29-branchpoint:1.5
	dberlin-typesystem-branch:1.5.0.2
	dberlin-typesystem-branchpoint:1.5
	gdb-post-ptid_t-2001-05-03:1.5
	gdb-pre-ptid_t-2001-05-03:1.5
	insight-precleanup-2001-01-01:1.3
	gdb-post-protoization-2000-07-29:1.2
	gdb-pre-protoization-2000-07-29:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb-post-params-removal-2000-06-04:1.1.1.4
	gdb-pre-params-removal-2000-06-04:1.1.1.4
	gdb-post-params-removal-2000-05-28:1.1.1.4
	gdb-pre-params-removal-2000-05-28:1.1.1.4
	gdb_5_0-2000-05-19-release:1.1.1.4
	gdb_4_18_2-2000-05-18-release:1.1.1.4
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.4
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.4
	gdb_5_0-2000-04-10-branch:1.1.1.4.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.4
	repo-unification-2000-02-06:1.1.1.4
	insight-2000-02-04:1.1.1.4
	gdb-2000-02-04:1.1.1.4
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.3
	gdb-1999-12-06:1.1.1.3
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.3
	gdb-1999-10-18:1.1.1.3
	gdb-1999-10-11:1.1.1.3
	gdb-1999-10-04:1.1.1.3
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.3
	gdb-1999-09-08:1.1.1.3
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.20
date	2003.08.23.03.55.59;	author chastain;	state dead;
branches;
next	1.19;

1.19
date	2003.07.11.06.44.34;	author mludvig;	state Exp;
branches;
next	1.18;

1.18
date	2003.03.04.17.02.20;	author carlton;	state Exp;
branches
	1.18.26.1;
next	1.17;

1.17
date	2003.03.03.18.39.47;	author carlton;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.28.17.50.16;	author carlton;	state Exp;
branches;
next	1.15;

1.15
date	2003.02.26.20.30.05;	author carlton;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.26.20.23.13;	author carlton;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.13.21.33.20;	author chastain;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.23.20.57.10;	author chastain;	state Exp;
branches
	1.12.16.1
	1.12.18.1;
next	1.11;

1.11
date	2002.01.10.20.46.16;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.20.16.53.52;	author law;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.07.22.02.23;	author drow;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.13.18.54.40;	author msnyder;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.13.18.52.08;	author msnyder;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.08.19.21.54;	author msnyder;	state Exp;
branches;
next	1.5;

1.5
date	2001.04.24.17.47.42;	author jimb;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.06.08.21.54;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.09.23.29.20;	author fnasser;	state Exp;
branches;
next	1.2;

1.2
date	2000.06.05.20.47.28;	author dberlin;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.32;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.32;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.08.02.23.46.56;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.09.09.00.00.29;	author shebs;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.02.05.07.30.00;	author jsm;	state Exp;
branches;
next	;

1.12.16.1
date	2003.01.11.01.11.03;	author carlton;	state Exp;
branches;
next	1.12.16.2;

1.12.16.2
date	2003.03.06.00.56.36;	author carlton;	state Exp;
branches;
next	1.12.16.3;

1.12.16.3
date	2003.03.07.00.31.46;	author carlton;	state Exp;
branches;
next	1.12.16.4;

1.12.16.4
date	2003.08.05.17.13.24;	author carlton;	state Exp;
branches;
next	1.12.16.5;

1.12.16.5
date	2003.08.30.03.40.34;	author chastain;	state dead;
branches;
next	;

1.12.18.1
date	2002.10.30.23.17.30;	author drow;	state Exp;
branches;
next	1.12.18.2;

1.12.18.2
date	2002.11.01.16.24.08;	author drow;	state Exp;
branches;
next	1.12.18.3;

1.12.18.3
date	2003.12.14.20.27.51;	author drow;	state dead;
branches;
next	;

1.18.26.1
date	2003.07.11.06.44.24;	author mludvig;	state Exp;
branches;
next	1.18.26.2;

1.18.26.2
date	2003.08.25.03.53.48;	author chastain;	state dead;
branches;
next	;


desc
@@


1.20
log
@2003-08-22  Michael Chastain  <mec@@shout.net>

	* gdb.cp: New directory.
	* gdb.cp/*: Copy from gdb.c++/*.
	* gdb.c++/*: Remove.
	* Makefile.in: Change gdb.c++ to gdb.cp.
	* configure.in:  Ditto.
	* configure: Regnerate.
@
text
@# Copyright 1992, 1994, 1995, 1996, 1997, 1999, 2000, 2002, 2003
# Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@@prep.ai.mit.edu

# This file was written by Fred Fish. (fnf@@cygnus.com)

set ws "\[\r\n\t \]+"

if $tracelevel then {
	strace $tracelevel
}

if { [skip_cplus_tests] } { continue }

set testfile "templates"
set srcfile ${testfile}.cc
set binfile ${objdir}/${subdir}/${testfile}

# Create and source the file that provides information about the compiler
# used to compile the test case.
if [get_compiler_info ${binfile} "c++"] {
    return -1
}
source ${binfile}.ci

if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug c++}] != "" } {
     gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
}

#
#  Test printing of the types of templates.
#

proc test_ptype_of_templates {} {
    global gdb_prompt
    global ws

    send_gdb "ptype T5<int>\n"
    gdb_expect {
	-re "type = class T5<int> \{${ws}public:${ws}static int X;${ws}int x;${ws}int val;${ws}T5<int> & operator=\\(T5<int> const ?&\\);${ws}T5\\(int\\);${ws}T5\\((T5<int> const|const T5<int>) ?&\\);${ws}~T5\\((void|)\\);${ws}static void \\* operator new\\(unsigned( int| long)?\\);${ws}static void operator delete\\(void ?\\*\\);${ws}int value\\((void|)\\);${ws}\}\r\n$gdb_prompt $" {
	    pass "ptype T5<int>"
	}
	-re "type = class T5<int> \\{${ws}public:${ws}static int X;${ws}int x;${ws}int val;${ws}${ws}T5 \\(int\\);${ws}T5 \\(const class T5<int> &\\);${ws}void ~T5 \\(int\\);${ws}static void \\* new \\(unsigned int\\);${ws}static void delete \\(void ?\\*\\);${ws}int value \\((void|)\\);${ws}\\}${ws}$gdb_prompt $" { pass "ptype T5<int> -- new with unsigned int" }
	-re "type = class T5<int> \\{.*public:.*static int X;.*int x;.*int val;.*T5 \\(int\\);.*T5 \\(const class T5<int> &\\);.*void ~T5 \\(int\\);.*static void \\* new \\(unsigned long\\);.*static void delete \\(void ?\\*\\);.*int value \\((void|)\\);.*\\}\r\n$gdb_prompt $" { pass "ptype T5<int> -- new with unsigned long" }
	-re "type = class T5<int> \{${ws}public:${ws}static int X;${ws}int x;${ws}int val;((${ws}T5<int> & operator=\\(T5<int> const ?&\\);)|(${ws}T5\\(int\\);)|(${ws}T5\\((T5<int> const|const T5<int>) ?&\\);)|(${ws}~T5\\((void|)\\);)|(${ws}static void \\* operator new\\(unsigned( int| long)?\\);)|(${ws}static void operator delete\\(void ?\\*\\);)|(${ws}int value\\((void|)\\);))*${ws}\}\r\n$gdb_prompt $" {
	    pass "ptype T5<int> (obsolescent gcc or gdb)"
	}
	-re "type = class T5<int> \{${ws}public:${ws}static int X;${ws}int x;${ws}int val;${ws}void T5\\(int\\);${ws}void T5\\((T5<int> const|const T5<int>) ?&\\);${ws}~T5\\(int\\);${ws}static void \\* operator new\\(unsigned( long|)\\);${ws}static void operator delete\\(void ?\\*\\);${ws}int value\\((void|)\\);${ws}\}\r\n$gdb_prompt $" {
	    # This also triggers gdb/1113...
	    kfail "gdb/1111" "ptype T5<int>"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype T5<int>"
	}
	timeout {
	    fail "ptype T5<int> (timeout)"
	}
    }

    send_gdb "ptype t5i\n"
    gdb_expect {
        -re "type = class T5<int> \\{${ws}public:${ws}static int X;${ws}int x;${ws}int val;\r\n${ws}T5\\(int\\);${ws}T5\\(T5<int> const ?&\\);${ws}~T5\\((void|)\\);${ws}static void \\* operator new\\(unsigned( int| long)?\\);${ws}static void operator delete\\(void ?\\*\\);${ws}int value\\((void|)\\);${ws}\\}\r\n$gdb_prompt $" { pass "ptype T5<int> -- with several fixes from 4.17" }
        -re "type = class T5<int> \\{${ws}public:${ws}static int X;${ws}int x;${ws}int val;\r\n${ws}T5 \\(int\\);${ws}T5 \\(const class T5<int> &\\);${ws}void ~T5 \\(int\\);${ws}static void \\* new \\(unsigned int\\);${ws}static void delete \\(void ?\\*\\);${ws}int value \\((void|)\\);${ws}\\}\r\n$gdb_prompt $" { pass "ptype t5i<int> -- new with unsigned int" }
        -re "type = class T5<int> \\{${ws}public:${ws}static int X;${ws}int x;${ws}int val;\r\n${ws}T5 \\(int\\);${ws}T5 \\(const class T5<int> &\\);${ws}void ~T5 \\(int\\);${ws}static void \\* new \\(unsigned long\\);${ws}static void delete \\(void ?\\*\\);${ws}int value \\((void|)\\);${ws}\\}\r\n$gdb_prompt $" { pass "ptype t5i<int> -- new with unsigned long" }
        -re "type = class T5<int> \{.*public:.*static int X;.*int x;.*int val;.*.*T5 \\(int\\);.*.*void ~T5 \\(int\\).*.*.*int value \\((void|)\\);.*\}.*$gdb_prompt $" { 
            pass "ptype t5i"
        }
	-re "type = class T5<int> \{${ws}public:${ws}static int X;${ws}int x;${ws}int val;${ws}T5<int> & operator=\\(T5<int> const ?&\\);${ws}T5\\(int\\);${ws}T5\\((T5<int> const|const T5<int>) ?&\\);${ws}~T5\\((void|)\\);${ws}static void \\* operator new\\(unsigned( int| long)?\\);${ws}static void operator delete\\(void ?\\*\\);${ws}int value\\((void|)\\);${ws}\}\r\n$gdb_prompt $" {
	    pass "ptype t5i"
	}
	-re "type = class T5<int> \{${ws}public:${ws}static int X;${ws}int x;${ws}int val;((${ws}T5<int> & operator=\\(T5<int> const ?&\\);)|(${ws}T5\\(int\\);)|(${ws}T5\\(T5<int> const ?&\\);)|(${ws}~T5\\((void|)\\);)|(${ws}static void \\* operator new\\(unsigned( int| long)?\\);)|(${ws}static void operator delete\\(void ?\\*\\);)|(${ws}int value\\((void|)\\);))*${ws}\}\r\n$gdb_prompt $" {
	    pass "ptype t5i (obsolescent gcc or gdb)"
	}
	-re "type = class T5<int> \{${ws}public:${ws}static int X;${ws}int x;${ws}int val;${ws}void T5\\(int\\);${ws}void T5\\((T5<int> const|const T5<int>) ?&\\);${ws}~T5\\(int\\);${ws}static void \\* operator new\\(unsigned( long|)\\);${ws}static void operator delete\\(void ?\\*\\);${ws}int value\\((void|)\\);${ws}\}\r\n$gdb_prompt $" {
	    # This also triggers gdb/1113...
	    kfail "gdb/1111" "ptype T5<int>"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype t5i"
	}
	timeout {
	    fail "ptype t5i (timeout)"
	}
    }
}

#
#  Test breakpoint setting on template methods.
#

proc test_template_breakpoints {} {
    global gdb_prompt
    global testfile
    global srcdir
    global hp_aCC_compiler

    send_gdb "break T5<int>::T5\n"
    gdb_expect {
	-re "0. cancel.*\[\r\n\]*.1. all.*\[\r\n\]*.2. T5<int>::T5\\(int\\) at .*\[\r\n\]*.3. T5<int>::T5\\((T5<int> const|const T5<int>) ?&\\) at .*\[\r\n\]*> $" {
	    gdb_test "0" \
		"canceled" \
		"constructor breakpoint (obsolete format!)"
	}
	-re ".0. cancel\[\r\n\]*.1. all\[\r\n\]*.2. T5<int>::T5\\((T5<int> const|const T5<int>) ?&\\) at .*templates.cc:.*\[\r\n\]*.3. T5<int>::T5\\(int\\) at .*templates.cc:.*\[\r\n\]*> $" {
	    gdb_test "0" \
		"canceled" \
		"constructor breakpoint"
	}
	-re "0. cancel.*\[\r\n\]*.1. all.*\[\r\n\]*.2. T5 at .*\[\r\n\]*.3. T5 at .*\[\r\n\]*> $" {
	    setup_kfail "gdb/1062" "*-*-*"
	    gdb_test "0" \
		"nonsense intended to insure that this test fails" \
		"constructor breakpoint"
	}
        -re ".*\n> $" {
	    gdb_test "0" \
		    "nonsense intended to insure that this test fails" \
		    "constructor breakpoint (bad menu choices)"
	}
	-re ".*$gdb_prompt $" { fail "constructor breakpoint" }
	default { fail "constructor breakpoint (timeout)" }
    }
    
# See CLLbs14792
    if {$hp_aCC_compiler} {setup_xfail hppa*-*-* CLLbs14792}

    gdb_test_multiple "break T5<int>::~T5" "destructor_breakpoint" {
	-re "Breakpoint.*at.* file .*${testfile}.cc, line.*$gdb_prompt $"
	{
	    pass "destructor breakpoint"
	}
	-re "the class `T5<int>' does not have destructor defined\r\nHint: try 'T5<int>::~T5<TAB> or 'T5<int>::~T5<ESC-\\?>\r\n\\(Note leading single quote.\\)\r\n$gdb_prompt $"
	{
	    kfail "gdb/1112" "destructor breakpoint"
	}
    }
    
    gdb_test "break T5<int>::value" \
	"Breakpoint.*at.* file .*${testfile}.cc, line.*" \
	"value method breakpoint"

    delete_breakpoints
}

#
#  Test calling of template methods.
#

proc test_template_calls {} {
    global gdb_prompt
    global hp_aCC_compiler

    if [target_info exists gdb,cannot_call_functions] {
	setup_xfail "*-*-*" 2416
	fail "This target can not call functions"
	return
    }

    if {!$hp_aCC_compiler} {setup_xfail hppa*-*-*}
    send_gdb "print t5i.value()\n"
    gdb_expect {
	-re ".* = 2\[\r\n\]*$gdb_prompt $" { pass "print t5i.value()" }
	-re "Cannot invoke functions on this machine.*$gdb_prompt $" {
	    fail "print t5i.value()"
	}
        -re "Cannot resolve .* to any overloaded instance.*$gdb_prompt $" {
	    setup_xfail hppa*-*-* CLLbs16899
            xfail "print t5i.value"
	}
	-re ".*$gdb_prompt $" { fail "print t5i.value()" }
	timeout { fail "print t5i.value() (timeout)" }
    }
}


proc do_tests {} {
    global prms_id
    global bug_id
    global subdir
    global objdir
    global srcdir
    global binfile
    global gdb_prompt
    global supports_template_debugging

    set prms_id 0
    set bug_id 0

    # Start with a fresh gdb.

    gdb_exit
    gdb_start
    gdb_reinitialize_dir $srcdir/$subdir
    gdb_load $binfile

    if { !$supports_template_debugging } {
	warning "compiler lacks debugging info for templates; tests suppressed." 0
	return
    }

    runto_main

    test_ptype_of_templates
    test_template_breakpoints

    if [ runto_main] {
	test_template_calls
    }
}

do_tests


# More tests for different kinds of template parameters,
# templates with partial specializations, nested templates, etc.
# These have been tested only with HP aCC.  They probably won't
# work with other compilers because of differences in mangling
# schemes. 
# Added by Satish Pai <pai@@apollo.hp.com> 1997-09-25 
# As of 2000-06-03, C++ support has been improved to the point that g++ can
# pass all of theses, excluding what appears to be one that exposes a stabs bug. - djb

# I don't know how HP could be passing these tests without this. They
# weren't breakpointing past a point where the below expressions were
# initialized in the actual source. - djb

send_gdb "b 770\n"
gdb_expect {
		-re ".*$gdb_prompt $"
}
send_gdb "c\n"
gdb_expect {
		-re ".*$gdb_prompt $"
}
send_gdb "print fint\n"   
gdb_expect {   
   -re "\\$\[0-9\]* = \\{x = 0, t = 0\\}\r\n$gdb_prompt $" { pass "print fint" }
   -re "$gdb_prompt $"                     { fail "print fint" }
   timeout                             { fail "(timeout) print fint" }
}

send_gdb "print fvpchar\n"   
gdb_expect {   
   -re "\\$\[0-9\]* = \\{x = 0, t = 0x0\\}\r\n$gdb_prompt $" { pass "print fvpchar" }
   -re "$gdb_prompt $"                     { fail "print fvpchar" }
   timeout                             { fail "(timeout) print fvpchar" }
}

# Template Foo<T>

# Neither stabs nor DWARF-2 contains type information about templates
# (as opposed to instantiations of templates), so in those
# circumstances we expect GDB to not find a symbol.  HP has a debug
# format that contains more info, though, so it's also correct to
# print out template info.  (This affects several subsequent tests as
# well.)

# NOTE: carlton/2003-02-26: However, because of a bug in the way GDB
# handles nested types, we don't get this right in the DWARF-2 case.

send_gdb "ptype Foo\n"   
gdb_expect {   
    -re "type = template <(class |)T> (class |)Foo \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*T t;\r\n\\}\r\ntemplate instantiations:\r\n\[ \t\]*(class |)Foo<volatile char \\*>\r\n\[ \t\]*(class |)Foo<char>\r\n\[ \t\]*(class |)Foo<int>\r\n$gdb_prompt $" { pass "ptype Foo" }
    -re "type = template <(class |)T> (class |)Foo \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*T t;\r\n\\}\r\n$gdb_prompt $" { xfail "ptype Foo" }
    -re "type = class Foo<int> \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*int t;\r\n\r\n\[ \t\]*int foo\\(int, int\\);\r\n\\}\r\n$gdb_prompt $"
    { # GCC 3.1, DWARF-2 output.
	kfail "gdb/57" "ptype Foo" }
    -re "No symbol \"Foo\" in current context.\r\n$gdb_prompt $"
    { # GCC 2.95.3, stabs+ output.
	pass "ptype Foo" }
    -re "$gdb_prompt $"                     { fail "ptype Foo" }
    timeout                             { fail "(timeout) ptype Foo" }
}
#    -re "type = class Foo<int> \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*int t;\r\n\r\n\[ \t\]*int foo(int, int);\r\n\\}\r\n$gdb_prompt $"

# ptype Foo<int>

send_gdb "ptype fint\n"   
gdb_expect {   
   -re "type = (class |)Foo<int> \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*int t;\r\n\r\n\[ \t\]*.*int foo\\(int, int\\);\r\n\\}\r\n$gdb_prompt $" { pass "ptype fint" }
   -re "$gdb_prompt $"                     { fail "ptype fint" }
   timeout                             { fail "(timeout) ptype fint" }
}

# ptype Foo<char>

send_gdb "ptype fchar\n"   
gdb_expect {   
   -re "type = (class |)Foo<char> \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*char t;\r\n\r\n\[ \t\]*.*char foo\\(int, char\\);\r\n\\}\r\n$gdb_prompt $" { pass "ptype fchar" }
   -re "$gdb_prompt $"                     { fail "ptype fchar" }
   timeout                             { fail "(timeout) ptype fchar" }
}

# ptype Foo<volatile char *>

send_gdb "ptype fvpchar\n"   
gdb_expect {   
   -re "type = (class |)Foo<volatile char ?\\*> \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*.*char.*\\*t;\r\n\r\n\[ \t\]*.*char \\* foo\\(int,.*char.*\\*\\);\r\n\\}\r\n$gdb_prompt $" { pass "ptype fvpchar" }
   -re "$gdb_prompt $"                     { fail "ptype fvpchar" }
   timeout                             { fail "(timeout) ptype fvpchar" }
}

# print a function from Foo<volatile char *>

# This test is sensitive to whitespace matching, so we'll do it twice,
# varying the spacing, because of PR gdb/33.

send_gdb "print Foo<volatile char *>::foo\n"   
gdb_expect {   
    -re "\\$\[0-9\]* = \\{.*char \\*\\((class |)Foo<volatile char ?\\*> \\*(| const), int, .*char \\*\\)\\} $hex <Foo<.*char.*\\*>::foo\\(int, .*char.*\\*\\)>\r\n$gdb_prompt $" { pass "print Foo<volatile char *>::foo" }
    -re "No symbol \"Foo<volatile char \\*>\" in current context.\r\n$gdb_prompt $"
    {
	# This used to be a kfail gdb/33, but it shouldn't occur any more now.
	fail "print Foo<volatile char *>::foo"
    }
    -re "$gdb_prompt $"                     { fail "print Foo<volatile char *>::foo" }
    timeout                             { fail "(timeout) print Foo<volatile char *>::foo" }
}

send_gdb "print Foo<volatile char*>::foo\n"   
gdb_expect {   
    -re "\\$\[0-9\]* = \\{.*char \\*\\((class |)Foo<volatile char ?\\*> \\*(| const), int, .*char \\*\\)\\} $hex <Foo<.*char.*\\*>::foo\\(int, .*char.*\\*\\)>\r\n$gdb_prompt $" { pass "print Foo<volatile char*>::foo" }
    -re "No symbol \"Foo<volatile char\\*>\" in current context.\r\n$gdb_prompt $"
    {
	# This used to be a kfail gdb/33, but it shouldn't occur any more now.
	fail "print Foo<volatile char *>::foo"
    }
    -re "$gdb_prompt $"                     { fail "print Foo<volatile char*>::foo" }
    timeout                             { fail "(timeout) print Foo<volatile char*>::foo" }
}

# Template Bar<T, int>

# same as Foo for g++
send_gdb "ptype Bar\n"   
gdb_expect {   
    -re "type = template <(class |)T, (class |)sz> (class |)Bar \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*T t;\r\n\\}\r\ntemplate instantiations:\r\n\[ \t\]*(class |)Bar<int,(\\(int\\)|)1>\r\n\[ \t\]*(class |)Bar<int,(\\(int\\)|)33>\r\n$gdb_prompt $" { pass "ptype Bar" }
    -re "type = <(class |)T, (class |)sz> (class |)Bar \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*T t;\r\n\\}\r\n$gdb_prompt $" { xfail "ptype Bar" }
    -re "ptype Bar\r\ntype = class Bar<int,33> {\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*int t;\r\n\r\n\[ \t\]*int bar\\(int, int\\);\r\n}\r\n$gdb_prompt $"
    { # GCC 3.1, DWARF-2 output.
	kfail "gdb/57" "ptype Bar" }
    -re "No symbol \"Bar\" in current context.\r\n$gdb_prompt $"
    { # GCC 2.95.3, stabs+ output.
	pass "ptype Bar" }
    -re "$gdb_prompt $"                     { fail "ptype Bar" }
    timeout                             { fail "(timeout) ptype Bar" }
}


# ptype Bar<int,33>

send_gdb "ptype bint\n"   
gdb_expect {   
   -re "type = (class |)Bar<int,(\\(int\\)|)33> \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*int t;\r\n\r\n\[ \t\]*.*int bar\\(int, int\\);\r\n\\}\r\n$gdb_prompt $" { pass "ptype bint" }
   -re "$gdb_prompt $"                     { fail "ptype bint" }
   timeout                             { fail "(timeout) ptype bint" }
}

# ptype Bar<int, (4>3)>

send_gdb "ptype bint2\n"   
gdb_expect {   
   -re "type = (class |)Bar<int,(\\(int\\)|)1> \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*int t;\r\n\r\n\[ \t\]*.*int bar\\(int, int\\);\r\n\\}\r\n$gdb_prompt $" { pass "ptype bint2" }
   -re "$gdb_prompt $"                     { fail "ptype bint2" }
   timeout                             { fail "(timeout) ptype bint2" }
}

# Template Baz<T, char>

# Same as Foo, for g++
send_gdb "ptype Baz\n"   
gdb_expect {   
    -re "type = template <(class |)T, (class |)sz> (class |)Baz \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*T t;\r\n\\}\r\ntemplate instantiations:\r\n\[ \t\]*(class |)Baz<char,(\\(char\\)|)97>\r\n\[ \t\]*(class |)Baz<int,(\\(char\\)|)115>\r\n$gdb_prompt $" { pass "ptype Baz" }
    -re "type = <(class |)T, (class |)sz> (class |)Baz \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*T t;\r\n\\}\r\n$gdb_prompt $" { xfail "ptype Baz" }
    -re "type = class Baz<int,'s'> {\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*int t;\r\n\r\n\[ \t\]*int baz\\(int, int\\);\r\n}\r\n$gdb_prompt $"
    { # GCC 3.1, DWARF-2 output.
	kfail "gdb/57" "ptype Baz" }
    -re "No symbol \"Baz\" in current context.\r\n$gdb_prompt $"
    { # GCC 2.95.3, stabs+ output.
	pass "ptype Baz" }
    -re "$gdb_prompt $"                     { fail "ptype Baz" }
    timeout                             { fail "(timeout) ptype Baz" }
}


# ptype Baz<int, 's'>

send_gdb "ptype bazint\n"   
gdb_expect {   
   -re "type = (class |)Baz<int,(\\(char\\)|)(115|\\'s\\')> \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*int t;\r\n\r\n\[ \t\]*.*int baz\\(int, int\\);\r\n\\}\r\n$gdb_prompt $" { pass "ptype bazint" }
   -re "$gdb_prompt $"                     { fail "ptype bazint" }
   timeout                             { fail "(timeout) ptype bazint" }
}

# ptype Baz<char, 'a'>

send_gdb "ptype bazint2\n"   
gdb_expect {   
   -re "type = (class |)Baz<char,(\\(char\\)|)(97|\\'a\\')> \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*char t;\r\n\r\n\[ \t\]*.*char baz\\(int, char\\);\r\n\\}\r\n$gdb_prompt $" { pass "ptype bazint2" }
   -re "$gdb_prompt $"                     { fail "ptype bazint2" }
   timeout                             { fail "(timeout) ptype bazint2" }
}

# Template Qux<T, int (*f)(int) >
# Same as Foo for g++
send_gdb "ptype Qux\n"   
gdb_expect {   
    -re "type = template <(class |)T, (class |)sz> (class |)Qux \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*T t;\r\n\\}\r\ntemplate instantiations:\r\n\[ \t\]*(class |)Qux<int,&string>\r\n\[ \t\]*(class |)Qux<char,&string>\r\n$gdb_prompt $" { pass "ptype Qux" }
    -re ".*type = template <(class |)T.*, (class |)sz> (class |)Qux \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*T t;\r\n\\}.*$gdb_prompt $" { pass "ptype Qux" }
    -re "type = class Qux<char,&string> {\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*char t;\r\n\r\n\[ \t\]*char qux\\(int, char\\);\r\n}\r\n$gdb_prompt $"
    { # GCC 3.1, DWARF-2 output.
	kfail "gdb/57" "ptype Qux" }
    -re "No symbol \"Qux\" in current context.\r\n$gdb_prompt $"
    { # GCC 2.95.3, stabs+ output.
	pass "ptype Qux" }
    -re "$gdb_prompt $"                     { fail "ptype Qux" }
    timeout                             { fail "(timeout) ptype Qux" }
}

# pt Qux<int,&string>

send_gdb "ptype quxint\n"   
gdb_expect {   
   -re "type = class Qux<int,&string> \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*int t;\r\n\r\n\[ \t\]*.*int qux\\(int, int\\);\r\n\\}\r\n$gdb_prompt $" { pass "ptype quxint" }
   -re "$gdb_prompt $"                     { fail "ptype quxint" }
   timeout                             { fail "(timeout) ptype quxint" }
}

# pt Qux<char,0>

# commented out this as quxint2 declaration was commented out in
# templates.exp -- ovidiu
# send_gdb "ptype quxint2\n"   
# gdb_expect {   
#    -re "type = class Qux<char,&string> \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*char t;\r\n\r\n\[ \t\]*char qux\\(int, char\\);\r\n\\}\r\n$gdb_prompt $" { pass "ptype quxint2" }
#    -re "$gdb_prompt $"                     { fail "ptype quxint2" }
#    timeout                             { fail "(timeout) ptype quxint2" }
# }

# Template Spec<T1, T2>

# Same as Foo for g++
send_gdb "ptype Spec\n"   
gdb_expect {   
    -re "type = template <(class |)T1, (class |)T2> (class |)Spec \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\\}\r\ntemplate instantiations:\r\n\[ \t\]*(class |)Spec<int,int \\*>\r\n\[ \t\]*(class |)Spec<int,char>\r\n$gdb_prompt $" { pass "ptype Spec" }
    -re "type = <(class |)T1, (class |)T2> (class |)Spec \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\\}\r\n$gdb_prompt $" { xfail "ptype Spec" }
    -re "type = class Spec<int,char> {\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\r\n\[ \t\]*int spec\\(char\\);\r\n}\r\n$gdb_prompt $"
    { # GCC 3.1, DWARF-2 output.
	kfail "gdb/57" "ptype Spec" }
    -re "No symbol \"Spec\" in current context.\r\n$gdb_prompt $"
    { # GCC 2.95.3, stabs+ output.
	pass "ptype Spec" }
    -re "$gdb_prompt $"                     { fail "ptype Spec" }
    timeout                             { fail "(timeout) ptype Spec" }
}

# pt Spec<char,0>

send_gdb "ptype siip\n"   
gdb_expect {   
   -re "type = class Spec<int,int ?\\*> \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\r\n\[ \t\]*.*int spec\\(int ?\\*\\);\r\n\\}\r\n$gdb_prompt $" { pass "ptype siip" }
   -re "$gdb_prompt $"                     { fail "ptype siip" }
   timeout                             { fail "(timeout) ptype siip" }
}

# pt Garply<int>

send_gdb "ptype Garply<int>\n"   
gdb_expect {   
   -re "type = class Garply<int> \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*int t;\r\n\r\n\[ \t\]*.*int garply\\(int, int\\);\r\n\\}\r\n$gdb_prompt $" { pass "ptype Garply<int>" }
   -re "$gdb_prompt $"                     { fail "ptype Garply<int>" }
   timeout                             { fail "(timeout) ptype Garply<int>" }
}

# ptype of nested template name

send_gdb "ptype Garply<Garply<char> >\n"   
gdb_expect {   
   -re "type = (class |)Garply<Garply<char> > \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*.*(class |)Garply<char> t;\r\n\r\n\[ \t\]*.*(class |)Garply<char> garply\\(int, (class |)Garply<char>\\);\r\n\\}\r\n$gdb_prompt $" { pass "ptype Garply<Garply<char> >" }
   -re "$gdb_prompt $"                     { fail "ptype Garply<Garply<char> >" }
   timeout                             { fail "(timeout) ptype Garply<Garply<char> >" }
}

# print out a function from a nested template name

send_gdb "print Garply<Garply<char> >::garply\n"
gdb_expect {
   -re "\\$\[0-9\]* = \\{(class |)Garply<char> \\((class |)Garply<Garply<char> > \\*(| const), int, (class |)Garply<char>\\)\\} $hex <Garply<Garply<char>\[ \t\]*>::garply\\(int, (class |)Garply<char>\\)>\r\n$gdb_prompt $" { pass "print Garply<Garply<char> >::garply" }
   -re ".*$gdb_prompt $" { fail "print Garply<Garply<char> >::garply" }
   timeout { fail "print Garply<Garply<char> >::garply (timeout)" }
}

# djb - 06-03-2000
# Now should work fine
send_gdb "break Garply<Garply<char> >::garply\n"
gdb_expect {
   -re "Breakpoint \[0-9\]* at $hex: file .*templates.cc, line.*\r\n$gdb_prompt $" { pass "break Garply<Garply<char> >::garply" }
   -re ".*$gdb_prompt $" { fail "break Garply<Garply<char> >::garply" }
   timeout { fail "break Garply<Garply<char> >::garply (timeout)" }
}
@


1.19
log
@2003-07-09  Michal Ludvig  <mludvig@@suse.cz>

	* gdb.c++/templates.exp (test_ptype_of_templates): Recognize
	expansion of size_t to 'unsigned long', not only to 'unsigned'.
@
text
@@


1.18
log
@2003-03-04  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/templates.exp (do_tests): Accept valid const in "print
	Garply<Garply<char> >:: garply".
	(test_ptype_of_templates): KFAIL "ptype T5<int>" and "ptype t5i"
	with respect to PR c++/1111; note also PR c++/1113.
	(test_template_breakpoints): KFAIL "constructor breakpoint" with
	respect to PR c++/1062.
	KFAIL "destructor breakpoint" with respect to PR c++/1112.
@
text
@d64 1
a64 1
	-re "type = class T5<int> \{${ws}public:${ws}static int X;${ws}int x;${ws}int val;${ws}void T5\\(int\\);${ws}void T5\\((T5<int> const|const T5<int>) ?&\\);${ws}~T5\\(int\\);${ws}static void \\* operator new\\(unsigned\\);${ws}static void operator delete\\(void ?\\*\\);${ws}int value\\((void|)\\);${ws}\}\r\n$gdb_prompt $" {
d90 1
a90 1
	-re "type = class T5<int> \{${ws}public:${ws}static int X;${ws}int x;${ws}int val;${ws}void T5\\(int\\);${ws}void T5\\((T5<int> const|const T5<int>) ?&\\);${ws}~T5\\(int\\);${ws}static void \\* operator new\\(unsigned\\);${ws}static void operator delete\\(void ?\\*\\);${ws}int value\\((void|)\\);${ws}\}\r\n$gdb_prompt $" {
@


1.18.26.1
log
@2003-07-09  Michal Ludvig  <mludvig@@suse.cz>

	* gdb.c++/templates.exp (test_ptype_of_templates): Recognize
	expansion of size_t to 'unsigned long', not only to 'unsigned'.
@
text
@d64 1
a64 1
	-re "type = class T5<int> \{${ws}public:${ws}static int X;${ws}int x;${ws}int val;${ws}void T5\\(int\\);${ws}void T5\\((T5<int> const|const T5<int>) ?&\\);${ws}~T5\\(int\\);${ws}static void \\* operator new\\(unsigned( long|)\\);${ws}static void operator delete\\(void ?\\*\\);${ws}int value\\((void|)\\);${ws}\}\r\n$gdb_prompt $" {
d90 1
a90 1
	-re "type = class T5<int> \{${ws}public:${ws}static int X;${ws}int x;${ws}int val;${ws}void T5\\(int\\);${ws}void T5\\((T5<int> const|const T5<int>) ?&\\);${ws}~T5\\(int\\);${ws}static void \\* operator new\\(unsigned( long|)\\);${ws}static void operator delete\\(void ?\\*\\);${ws}int value\\((void|)\\);${ws}\}\r\n$gdb_prompt $" {
@


1.18.26.2
log
@2003-08-22  Michael Chastain  <mec@@shout.net>

	* gdb.cp: New directory.
	* gdb.cp/*: Copy from gdb.c++/*.
	* gdb.c++/*: Remove.
	* Makefile.in: Change gdb.c++ to gdb.cp.
	* configure.in:  Ditto.
	* configure: Regnerate.
@
text
@@


1.17
log
@2003-03-03  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/templates.exp (do_tests): Convert the KFAILs with
	respect to PR c++/33 into FAILs.
@
text
@d64 4
d90 4
d125 6
d142 11
a152 3
    gdb_test "break T5<int>::~T5" \
	"Breakpoint.*at.* file .*${testfile}.cc, line.*" \
	"destructor breakpoint"    
d504 1
a504 1
   -re "\\$\[0-9\]* = \\{(class |)Garply<char> \\((class |)Garply<Garply<char> > \\*, int, (class |)Garply<char>\\)\\} $hex <Garply<Garply<char>\[ \t\]*>::garply\\(int, (class |)Garply<char>\\)>\r\n$gdb_prompt $" { pass "print Garply<Garply<char> >::garply" }
@


1.16
log
@2003-02-28  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/templates.exp (do_tests): Allow const in the two
	Foo<volatile char *>::foo tests.
@
text
@d306 4
a309 1
    { kfail "gdb/33" "print Foo<volatile char *>::foo" }
d318 4
a321 1
    { kfail "gdb/33" "print Foo<volatile char*>::foo" }
@


1.15
log
@2003-02-26  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/templates.exp (do_tests): KFAIL the "print Foo<volatile
	char *>::foo" test with respect to PR c++/33.  Create a new test
	which is identical to that one except that it doesn't put the
	space between the "char" and the "*"; KFAIL it, too.
@
text
@d304 1
a304 1
    -re "\\$\[0-9\]* = \\{.*char \\*\\((class |)Foo<volatile char ?\\*> \\*, int, .*char \\*\\)\\} $hex <Foo<.*char.*\\*>::foo\\(int, .*char.*\\*\\)>\r\n$gdb_prompt $" { pass "print Foo<volatile char *>::foo" }
d313 1
a313 1
    -re "\\$\[0-9\]* = \\{.*char \\*\\((class |)Foo<volatile char ?\\*> \\*, int, .*char \\*\\)\\} $hex <Foo<.*char.*\\*>::foo\\(int, .*char.*\\*\\)>\r\n$gdb_prompt $" { pass "print Foo<volatile char*>::foo" }
@


1.14
log
@2003-02-26  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/templates.exp (do_tests): Convert XFAILs about printing
	template types into either PASSes or KFAILs (corresponding to PR
	c++/57).  Tweak indentation.  Update copyright.
@
text
@d299 3
d304 14
a317 3
   -re "\\$\[0-9\]* = \\{.*char \\*\\((class |)Foo<volatile char \\*> \\*, int, .*char \\*\\)\\} $hex <Foo<.*char.*\\*>::foo\\(int, .*char.*\\*\\)>\r\n$gdb_prompt $" { pass "print Foo<volatile char *>::foo" }
   -re "$gdb_prompt $"                     { fail "print Foo<volatile char *>::foo" }
   timeout                             { fail "(timeout) print Foo<volatile char *>::foo" }
@


1.13
log
@2003-02-12  Michael Chastain  <mec@@shout.net>

	* gdb.c++/classes.exp: Remove setup_xfail_format for DWARF 1.
	* gdb.c++/inherit.exp: Likewise.
	* gdb.c++/cplusfuncs.exp: Remove suppression logic for DWARF 1.
	* gdb.c++/templates.exp: Likewise.
	* gdb.c++/virtfunc.exp: Likewise.
@
text
@d1 1
a1 1
# Copyright 1992, 1994, 1995, 1996, 1997, 1999, 2000, 2002
d245 10
a254 4
setup_xfail hppa64-*-* CLLbs16092
# g++ can't do the template instantiation in debug info trick, so we
# fail this because it's not a real type.
if {!$hp_aCC_compiler} { setup_xfail *-*-* }
d257 10
a266 4
   -re "type = template <(class |)T> (class |)Foo \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*T t;\r\n\\}\r\ntemplate instantiations:\r\n\[ \t\]*(class |)Foo<volatile char \\*>\r\n\[ \t\]*(class |)Foo<char>\r\n\[ \t\]*(class |)Foo<int>\r\n$gdb_prompt $" { pass "ptype Foo" }
   -re "type = template <(class |)T> (class |)Foo \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*T t;\r\n\\}\r\n$gdb_prompt $" { xfail "ptype Foo" }
   -re "$gdb_prompt $"                     { fail "ptype Foo" }
   timeout                             { fail "(timeout) ptype Foo" }
d268 1
a307 1
setup_xfail hppa64-*-* CLLbs16092
a308 1
if {!$hp_aCC_compiler} { setup_xfail *-*-* }
d311 10
a320 4
   -re "type = template <(class |)T, (class |)sz> (class |)Bar \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*T t;\r\n\\}\r\ntemplate instantiations:\r\n\[ \t\]*(class |)Bar<int,(\\(int\\)|)1>\r\n\[ \t\]*(class |)Bar<int,(\\(int\\)|)33>\r\n$gdb_prompt $" { pass "ptype Bar" }
   -re "type = <(class |)T, (class |)sz> (class |)Bar \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*T t;\r\n\\}\r\n$gdb_prompt $" { xfail "ptype Bar" }
   -re "$gdb_prompt $"                     { fail "ptype Bar" }
   timeout                             { fail "(timeout) ptype Bar" }
a343 1
setup_xfail hppa64-*-* CLLbs16092
a344 1
if {!$hp_aCC_compiler} { setup_xfail *-*-* }
d347 10
a356 4
   -re "type = template <(class |)T, (class |)sz> (class |)Baz \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*T t;\r\n\\}\r\ntemplate instantiations:\r\n\[ \t\]*(class |)Baz<char,(\\(char\\)|)97>\r\n\[ \t\]*(class |)Baz<int,(\\(char\\)|)115>\r\n$gdb_prompt $" { pass "ptype Baz" }
   -re "type = <(class |)T, (class |)sz> (class |)Baz \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*T t;\r\n\\}\r\n$gdb_prompt $" { xfail "ptype Baz" }
   -re "$gdb_prompt $"                     { fail "ptype Baz" }
   timeout                             { fail "(timeout) ptype Baz" }
a379 1
if {!$hp_aCC_compiler} {setup_xfail *-*-*}
d382 10
a391 4
   -re "type = template <(class |)T, (class |)sz> (class |)Qux \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*T t;\r\n\\}\r\ntemplate instantiations:\r\n\[ \t\]*(class |)Qux<int,&string>\r\n\[ \t\]*(class |)Qux<char,&string>\r\n$gdb_prompt $" { pass "ptype Qux" }
   -re ".*type = template <(class |)T.*, (class |)sz> (class |)Qux \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*T t;\r\n\\}.*$gdb_prompt $" { pass "ptype Qux" }
   -re "$gdb_prompt $"                     { fail "ptype Qux" }
   timeout                             { fail "(timeout) ptype Qux" }
a415 1
setup_xfail hppa64-*-* CLLbs16092
a416 1
if {!$hp_aCC_compiler} { setup_xfail *-*-* }
d419 10
a428 4
   -re "type = template <(class |)T1, (class |)T2> (class |)Spec \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\\}\r\ntemplate instantiations:\r\n\[ \t\]*(class |)Spec<int,int \\*>\r\n\[ \t\]*(class |)Spec<int,char>\r\n$gdb_prompt $" { pass "ptype Spec" }
   -re "type = <(class |)T1, (class |)T2> (class |)Spec \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\\}\r\n$gdb_prompt $" { xfail "ptype Spec" }
   -re "$gdb_prompt $"                     { fail "ptype Spec" }
   timeout                             { fail "(timeout) ptype Spec" }
@


1.12
log
@2002-02-23  Michael Chastain  <mec@@shout.net>

	* gdb.c++/templates.exp: Remove setup_xfail_format "stabs" on
	test "ptype bint".  The test passes on all my stabs configurations.
@
text
@d195 1
a195 12
    # Get the debug format for the compiled test case.  If that
    # format is DWARF 1 then just skip all the tests since none of
    # them will pass.

    if [ runto_main] then {
	get_debug_format
	if [ setup_xfail_format "DWARF 1" ] then {
	    fail "C++ tests skipped due to limited C++ support in DWARF 1 debug format"
	    return
	}
	clear_xfail "*-*-*"
    }
@


1.12.16.1
log
@2003-01-10  David Carlton  <carlton@@math.stanford.edu>

	* objfiles.c (allocate_objfile): Always set name.
	* dwarf2read.c (scan_partial_symbols): Don't call
	add_partial_structure on unions.
	(add_partial_structure): Look for enclosing namespace names.
	(read_structure_scope): Look enclosing namespace/class names.
	(new_symbol): For C++ structures, always grab the name from the
	type's name.

2003-01-10  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/templates.exp (do_tests): Update some of the regexps to
	be a bit more generous.
@
text
@a290 1
   -re "type = class Foo<char volatile\\*> \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*.*char.*\\*t;\r\n\r\n\[ \t\]*.*char \\* foo\\(int,.*char.*\\*\\);\r\n\\}\r\n$gdb_prompt $" { pass "ptype fvpchar" }
d322 1
a322 1
   -re "type = (class |)Bar<int, ?(\\(int\\)|)33> \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*int t;\r\n\r\n\[ \t\]*.*int bar\\(int, int\\);\r\n\\}\r\n$gdb_prompt $" { pass "ptype bint" }
d331 1
a331 1
   -re "type = (class |)Bar<int, ?(\\(int\\)|)1> \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*int t;\r\n\r\n\[ \t\]*.*int bar\\(int, int\\);\r\n\\}\r\n$gdb_prompt $" { pass "ptype bint2" }
d354 1
a354 1
   -re "type = (class |)Baz<int, ?(\\(char\\)|)(115|\\'s\\')> \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*int t;\r\n\r\n\[ \t\]*.*int baz\\(int, int\\);\r\n\\}\r\n$gdb_prompt $" { pass "ptype bazint" }
d363 1
a363 1
   -re "type = (class |)Baz<char, ?(\\(char\\)|)(97|\\'a\\')> \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*char t;\r\n\r\n\[ \t\]*.*char baz\\(int, char\\);\r\n\\}\r\n$gdb_prompt $" { pass "ptype bazint2" }
d383 1
a383 1
   -re "type = class Qux<int, ?&\\(?string\\)?> \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*int t;\r\n\r\n\[ \t\]*.*int qux\\(int, int\\);\r\n\\}\r\n$gdb_prompt $" { pass "ptype quxint" }
d416 1
a416 1
   -re "type = class Spec<int, ?int ?\\*> \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\r\n\[ \t\]*.*int spec\\(int ?\\*\\);\r\n\\}\r\n$gdb_prompt $" { pass "ptype siip" }
@


1.12.16.2
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d1 1
a1 1
# Copyright 1992, 1994, 1995, 1996, 1997, 1999, 2000, 2002, 2003
a63 4
	-re "type = class T5<int> \{${ws}public:${ws}static int X;${ws}int x;${ws}int val;${ws}void T5\\(int\\);${ws}void T5\\((T5<int> const|const T5<int>) ?&\\);${ws}~T5\\(int\\);${ws}static void \\* operator new\\(unsigned\\);${ws}static void operator delete\\(void ?\\*\\);${ws}int value\\((void|)\\);${ws}\}\r\n$gdb_prompt $" {
	    # This also triggers gdb/1113...
	    kfail "gdb/1111" "ptype T5<int>"
	}
a85 4
	-re "type = class T5<int> \{${ws}public:${ws}static int X;${ws}int x;${ws}int val;${ws}void T5\\(int\\);${ws}void T5\\((T5<int> const|const T5<int>) ?&\\);${ws}~T5\\(int\\);${ws}static void \\* operator new\\(unsigned\\);${ws}static void operator delete\\(void ?\\*\\);${ws}int value\\((void|)\\);${ws}\}\r\n$gdb_prompt $" {
	    # This also triggers gdb/1113...
	    kfail "gdb/1111" "ptype T5<int>"
	}
a116 6
	-re "0. cancel.*\[\r\n\]*.1. all.*\[\r\n\]*.2. T5 at .*\[\r\n\]*.3. T5 at .*\[\r\n\]*> $" {
	    setup_kfail "gdb/1062" "*-*-*"
	    gdb_test "0" \
		"nonsense intended to insure that this test fails" \
		"constructor breakpoint"
	}
d128 3
a130 11

    gdb_test_multiple "break T5<int>::~T5" "destructor_breakpoint" {
	-re "Breakpoint.*at.* file .*${testfile}.cc, line.*$gdb_prompt $"
	{
	    pass "destructor breakpoint"
	}
	-re "the class `T5<int>' does not have destructor defined\r\nHint: try 'T5<int>::~T5<TAB> or 'T5<int>::~T5<ESC-\\?>\r\n\\(Note leading single quote.\\)\r\n$gdb_prompt $"
	{
	    kfail "gdb/1112" "destructor breakpoint"
	}
    }
d195 12
a206 1
    runto_main
d256 4
a259 10
# Neither stabs nor DWARF-2 contains type information about templates
# (as opposed to instantiations of templates), so in those
# circumstances we expect GDB to not find a symbol.  HP has a debug
# format that contains more info, though, so it's also correct to
# print out template info.  (This affects several subsequent tests as
# well.)

# NOTE: carlton/2003-02-26: However, because of a bug in the way GDB
# handles nested types, we don't get this right in the DWARF-2 case.

d262 4
a265 10
    -re "type = template <(class |)T> (class |)Foo \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*T t;\r\n\\}\r\ntemplate instantiations:\r\n\[ \t\]*(class |)Foo<volatile char \\*>\r\n\[ \t\]*(class |)Foo<char>\r\n\[ \t\]*(class |)Foo<int>\r\n$gdb_prompt $" { pass "ptype Foo" }
    -re "type = template <(class |)T> (class |)Foo \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*T t;\r\n\\}\r\n$gdb_prompt $" { xfail "ptype Foo" }
    -re "type = class Foo<int> \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*int t;\r\n\r\n\[ \t\]*int foo\\(int, int\\);\r\n\\}\r\n$gdb_prompt $"
    { # GCC 3.1, DWARF-2 output.
	kfail "gdb/57" "ptype Foo" }
    -re "No symbol \"Foo\" in current context.\r\n$gdb_prompt $"
    { # GCC 2.95.3, stabs+ output.
	pass "ptype Foo" }
    -re "$gdb_prompt $"                     { fail "ptype Foo" }
    timeout                             { fail "(timeout) ptype Foo" }
a266 1
#    -re "type = class Foo<int> \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*int t;\r\n\r\n\[ \t\]*int foo(int, int);\r\n\\}\r\n$gdb_prompt $"
a297 3
# This test is sensitive to whitespace matching, so we'll do it twice,
# varying the spacing, because of PR gdb/33.

d300 3
a302 20
    -re "\\$\[0-9\]* = \\{.*char \\*\\((class |)Foo<volatile char ?\\*> \\*(| const), int, .*char \\*\\)\\} $hex <Foo<.*char.*\\*>::foo\\(int, .*char.*\\*\\)>\r\n$gdb_prompt $" { pass "print Foo<volatile char *>::foo" }
    -re "No symbol \"Foo<volatile char \\*>\" in current context.\r\n$gdb_prompt $"
    {
	# This used to be a kfail gdb/33, but it shouldn't occur any more now.
	fail "print Foo<volatile char *>::foo"
    }
    -re "$gdb_prompt $"                     { fail "print Foo<volatile char *>::foo" }
    timeout                             { fail "(timeout) print Foo<volatile char *>::foo" }
}

send_gdb "print Foo<volatile char*>::foo\n"   
gdb_expect {   
    -re "\\$\[0-9\]* = \\{.*char \\*\\((class |)Foo<volatile char ?\\*> \\*(| const), int, .*char \\*\\)\\} $hex <Foo<.*char.*\\*>::foo\\(int, .*char.*\\*\\)>\r\n$gdb_prompt $" { pass "print Foo<volatile char*>::foo" }
    -re "No symbol \"Foo<volatile char\\*>\" in current context.\r\n$gdb_prompt $"
    {
	# This used to be a kfail gdb/33, but it shouldn't occur any more now.
	fail "print Foo<volatile char *>::foo"
    }
    -re "$gdb_prompt $"                     { fail "print Foo<volatile char*>::foo" }
    timeout                             { fail "(timeout) print Foo<volatile char*>::foo" }
d307 1
d309 1
d312 4
a315 10
    -re "type = template <(class |)T, (class |)sz> (class |)Bar \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*T t;\r\n\\}\r\ntemplate instantiations:\r\n\[ \t\]*(class |)Bar<int,(\\(int\\)|)1>\r\n\[ \t\]*(class |)Bar<int,(\\(int\\)|)33>\r\n$gdb_prompt $" { pass "ptype Bar" }
    -re "type = <(class |)T, (class |)sz> (class |)Bar \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*T t;\r\n\\}\r\n$gdb_prompt $" { xfail "ptype Bar" }
    -re "ptype Bar\r\ntype = class Bar<int,33> {\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*int t;\r\n\r\n\[ \t\]*int bar\\(int, int\\);\r\n}\r\n$gdb_prompt $"
    { # GCC 3.1, DWARF-2 output.
	kfail "gdb/57" "ptype Bar" }
    -re "No symbol \"Bar\" in current context.\r\n$gdb_prompt $"
    { # GCC 2.95.3, stabs+ output.
	pass "ptype Bar" }
    -re "$gdb_prompt $"                     { fail "ptype Bar" }
    timeout                             { fail "(timeout) ptype Bar" }
d339 1
d341 1
d344 4
a347 10
    -re "type = template <(class |)T, (class |)sz> (class |)Baz \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*T t;\r\n\\}\r\ntemplate instantiations:\r\n\[ \t\]*(class |)Baz<char,(\\(char\\)|)97>\r\n\[ \t\]*(class |)Baz<int,(\\(char\\)|)115>\r\n$gdb_prompt $" { pass "ptype Baz" }
    -re "type = <(class |)T, (class |)sz> (class |)Baz \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*T t;\r\n\\}\r\n$gdb_prompt $" { xfail "ptype Baz" }
    -re "type = class Baz<int,'s'> {\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*int t;\r\n\r\n\[ \t\]*int baz\\(int, int\\);\r\n}\r\n$gdb_prompt $"
    { # GCC 3.1, DWARF-2 output.
	kfail "gdb/57" "ptype Baz" }
    -re "No symbol \"Baz\" in current context.\r\n$gdb_prompt $"
    { # GCC 2.95.3, stabs+ output.
	pass "ptype Baz" }
    -re "$gdb_prompt $"                     { fail "ptype Baz" }
    timeout                             { fail "(timeout) ptype Baz" }
d371 1
d374 4
a377 10
    -re "type = template <(class |)T, (class |)sz> (class |)Qux \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*T t;\r\n\\}\r\ntemplate instantiations:\r\n\[ \t\]*(class |)Qux<int,&string>\r\n\[ \t\]*(class |)Qux<char,&string>\r\n$gdb_prompt $" { pass "ptype Qux" }
    -re ".*type = template <(class |)T.*, (class |)sz> (class |)Qux \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*T t;\r\n\\}.*$gdb_prompt $" { pass "ptype Qux" }
    -re "type = class Qux<char,&string> {\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*char t;\r\n\r\n\[ \t\]*char qux\\(int, char\\);\r\n}\r\n$gdb_prompt $"
    { # GCC 3.1, DWARF-2 output.
	kfail "gdb/57" "ptype Qux" }
    -re "No symbol \"Qux\" in current context.\r\n$gdb_prompt $"
    { # GCC 2.95.3, stabs+ output.
	pass "ptype Qux" }
    -re "$gdb_prompt $"                     { fail "ptype Qux" }
    timeout                             { fail "(timeout) ptype Qux" }
d402 1
d404 1
d407 4
a410 10
    -re "type = template <(class |)T1, (class |)T2> (class |)Spec \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\\}\r\ntemplate instantiations:\r\n\[ \t\]*(class |)Spec<int,int \\*>\r\n\[ \t\]*(class |)Spec<int,char>\r\n$gdb_prompt $" { pass "ptype Spec" }
    -re "type = <(class |)T1, (class |)T2> (class |)Spec \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\\}\r\n$gdb_prompt $" { xfail "ptype Spec" }
    -re "type = class Spec<int,char> {\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\r\n\[ \t\]*int spec\\(char\\);\r\n}\r\n$gdb_prompt $"
    { # GCC 3.1, DWARF-2 output.
	kfail "gdb/57" "ptype Spec" }
    -re "No symbol \"Spec\" in current context.\r\n$gdb_prompt $"
    { # GCC 2.95.3, stabs+ output.
	pass "ptype Spec" }
    -re "$gdb_prompt $"                     { fail "ptype Spec" }
    timeout                             { fail "(timeout) ptype Spec" }
d444 1
a444 1
   -re "\\$\[0-9\]* = \\{(class |)Garply<char> \\((class |)Garply<Garply<char> > \\*(| const), int, (class |)Garply<char>\\)\\} $hex <Garply<Garply<char>\[ \t\]*>::garply\\(int, (class |)Garply<char>\\)>\r\n$gdb_prompt $" { pass "print Garply<Garply<char> >::garply" }
@


1.12.16.3
log
@2003-03-06  David Carlton  <carlton@@math.stanford.edu>

	* minsyms.c (add_minsym_to_hash_table): Use SYMBOL_LINKAGE_NAME.
	(add_minsym_to_demangled_hash_table): Use SYMBOL_NATURAL_NAME.
	(build_minimal_symbol_hash_tables): Add all minsyms to demangled
	hash table.
	(install_minimal_symbols): Use SYMBOL_LINKAGE_NAME.
	(find_solib_trampoline_target): Ditto.
	(compare_minimal_symbols): Ditto.
	(compact_minimal_symbols): Ditto.
	* symtab.h (DEPRECATED_SYMBOL_MATCHES_NAME): Delete.
	* minsyms.c (lookup_minimal_symbol_text): Replace use of
	DEPRECATED_SYMBOL_MATCHES_NAME by strcmp on linkage name.
	(lookup_minimal_symbol_solib_trampoline): Ditto.
	* symtab.h: Declare lookup_minimal_symbol_linkage,
	lookup_minimal_symbol_natural.
	* minsyms.c (lookup_minimal_symbol_aux): New function.
	(lookup_minimal_symbol_linkage): Ditto.
	(lookup_minimal_symbol_natural): Ditto.
	(lookup_minimal_symbol): Move body into
	lookup_minimal_symbol_aux.

2003-03-06  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/templates.exp (do_tests): Make expressions for 'ptype
	Bar' and 'ptype Qux' more generous.
@
text
@d356 1
a356 1
    -re "ptype Bar\r\ntype = class Bar<int, ?33> {\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*int t;\r\n\r\n\[ \t\]*int bar\\(int, int\\);\r\n}\r\n$gdb_prompt $"
d464 1
a464 1
    -re "type = class Spec<int, ?char> {\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\r\n\[ \t\]*int spec\\(char\\);\r\n}\r\n$gdb_prompt $"
@


1.12.16.4
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d64 1
a64 1
	-re "type = class T5<int> \{${ws}public:${ws}static int X;${ws}int x;${ws}int val;${ws}void T5\\(int\\);${ws}void T5\\((T5<int> const|const T5<int>) ?&\\);${ws}~T5\\(int\\);${ws}static void \\* operator new\\(unsigned( long|)\\);${ws}static void operator delete\\(void ?\\*\\);${ws}int value\\((void|)\\);${ws}\}\r\n$gdb_prompt $" {
d90 1
a90 1
	-re "type = class T5<int> \{${ws}public:${ws}static int X;${ws}int x;${ws}int val;${ws}void T5\\(int\\);${ws}void T5\\((T5<int> const|const T5<int>) ?&\\);${ws}~T5\\(int\\);${ws}static void \\* operator new\\(unsigned( long|)\\);${ws}static void operator delete\\(void ?\\*\\);${ws}int value\\((void|)\\);${ws}\}\r\n$gdb_prompt $" {
@


1.12.16.5
log
@2003-08-22  Michael Chastain  <mec@@shout.net>

	* gdb.cp: New directory.
	* gdb.cp/*: Copy from gdb.c++/*.
	* gdb.c++/*: Remove.
	* Makefile.in: Change gdb.c++ to gdb.cp.
	* configure.in:  Ditto.
	* carlton_runnamespace: Ditto.
	* carlton_runtest: Ditto.
	* configure: Regnerate.
@
text
@@


1.12.18.1
log
@	* gdb.c++/method.exp (print this): Allow "A const".
	* gdb.c++/templates.exp (ptype fvpchar)
	(print Foo<volatile char *>::Foo): Allow consts after type names.
@
text
@d290 1
a290 1
   -re "type = (class |)Foo<volatile char ?\\*> \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*.*char.*\\*t;\r\n\r\n\[ \t\]*.*char.* \\* foo\\(int,.*char.*\\*\\);\r\n\\}\r\n$gdb_prompt $" { pass "ptype fvpchar" }
d299 1
a299 1
   -re "\\$\[0-9\]* = \\{.*char \\*\\((class |)Foo<volatile char ?\\*> \\*, int, .*char \\*\\)\\} $hex <Foo<.*char.*\\*>::foo\\(int, .*char.*\\*\\)>\r\n$gdb_prompt $" { pass "print Foo<(volatile char|char volatile) *>::foo" }
@


1.12.18.2
log
@	* gdb.c++/templates.exp: Correct some undoubled backslashes.
	Make a synthetic operator= optional.
	(print Garply<Garply<char> >::garply): Allow const THIS pointer.
@
text
@d56 1
a56 1
	-re "type = class T5<int> \\{${ws}public:${ws}static int X;${ws}int x;${ws}int val;${ws}(T5<int> & operator=\\(T5<int> const ?&\\);)?${ws}T5\\(int\\);${ws}T5\\((T5<int> const|const T5<int>) ?&\\);${ws}~T5\\((void|)\\);${ws}static void \\* operator new\\(unsigned( int| long)?\\);${ws}static void operator delete\\(void ?\\*\\);${ws}int value\\((void|)\\);${ws}\\}\r\n$gdb_prompt $" {
d61 1
a61 1
	-re "type = class T5<int> \\{${ws}public:${ws}static int X;${ws}int x;${ws}int val;((${ws}T5<int> & operator=\\(T5<int> const ?&\\);)|(${ws}T5\\(int\\);)|(${ws}T5\\((T5<int> const|const T5<int>) ?&\\);)|(${ws}~T5\\((void|)\\);)|(${ws}static void \\* operator new\\(unsigned( int| long)?\\);)|(${ws}static void operator delete\\(void ?\\*\\);)|(${ws}int value\\((void|)\\);))*${ws}\\}\r\n$gdb_prompt $" {
d77 1
a77 1
        -re "type = class T5<int> \\{.*public:.*static int X;.*int x;.*int val;.*.*T5 \\(int\\);.*.*void ~T5 \\(int\\).*.*.*int value \\((void|)\\);.*\\}.*$gdb_prompt $" { 
d80 1
a80 1
	-re "type = class T5<int> \\{${ws}public:${ws}static int X;${ws}int x;${ws}int val;${ws}T5<int> & operator=\\(T5<int> const ?&\\);${ws}T5\\(int\\);${ws}T5\\((T5<int> const|const T5<int>) ?&\\);${ws}~T5\\((void|)\\);${ws}static void \\* operator new\\(unsigned( int| long)?\\);${ws}static void operator delete\\(void ?\\*\\);${ws}int value\\((void|)\\);${ws}\\}\r\n$gdb_prompt $" {
d83 1
a83 1
	-re "type = class T5<int> \\{${ws}public:${ws}static int X;${ws}int x;${ws}int val;((${ws}T5<int> & operator=\\(T5<int> const ?&\\);)|(${ws}T5\\(int\\);)|(${ws}T5\\(T5<int> const ?&\\);)|(${ws}~T5\\((void|)\\);)|(${ws}static void \\* operator new\\(unsigned( int| long)?\\);)|(${ws}static void operator delete\\(void ?\\*\\);)|(${ws}int value\\((void|)\\);))*${ws}\\}\r\n$gdb_prompt $" {
d443 1
a443 1
   -re "\\$\[0-9\]* = \\{(class |)Garply<char> \\((class |)Garply<Garply<char> > \\*( const)?, int, (class |)Garply<char>\\)\\} $hex <Garply<Garply<char>\[ \t\]*>::garply\\(int, (class |)Garply<char>\\)>\r\n$gdb_prompt $" { pass "print Garply<Garply<char> >::garply" }
@


1.12.18.3
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.11
log
@        * gdb.c++/namespace.exp: Accept trailing const for 'this'.

        * gdb.c++/classes.exp: Accept 'A const' or 'const A' in copy
        constructors.
        * gdb.c++/derivation.exp: Likewise.
        * gdb.c++/templates.exp: Likewise.
        * gdb.c++/virtfunc.exp: Likewise.
@
text
@d319 1
a319 5
# stabs screws this test royally. 
# It thinks it has a badly mangled name.
# I blame stabs, the other formats get it right. -djb
get_debug_format
setup_xfail_format "stabs"
@


1.10
log
@        * gdb.c++/templates.exp: Use "hppa64-*-*", not "hppa2.0w-*-*"
@
text
@d1 1
a1 1
# Copyright 1992, 1994, 1995, 1996, 1997, 1999, 2000
d56 1
a56 1
	-re "type = class T5<int> \{${ws}public:${ws}static int X;${ws}int x;${ws}int val;${ws}T5<int> & operator=\\(T5<int> const ?&\\);${ws}T5\\(int\\);${ws}T5\\(T5<int> const ?&\\);${ws}~T5\\((void|)\\);${ws}static void \\* operator new\\(unsigned( int| long)?\\);${ws}static void operator delete\\(void ?\\*\\);${ws}int value\\((void|)\\);${ws}\}\r\n$gdb_prompt $" {
d61 1
a61 1
	-re "type = class T5<int> \{${ws}public:${ws}static int X;${ws}int x;${ws}int val;((${ws}T5<int> & operator=\\(T5<int> const ?&\\);)|(${ws}T5\\(int\\);)|(${ws}T5\\(T5<int> const ?&\\);)|(${ws}~T5\\((void|)\\);)|(${ws}static void \\* operator new\\(unsigned( int| long)?\\);)|(${ws}static void operator delete\\(void ?\\*\\);)|(${ws}int value\\((void|)\\);))*${ws}\}\r\n$gdb_prompt $" {
d80 1
a80 1
	-re "type = class T5<int> \{${ws}public:${ws}static int X;${ws}int x;${ws}int val;${ws}T5<int> & operator=\\(T5<int> const ?&\\);${ws}T5\\(int\\);${ws}T5\\(T5<int> const ?&\\);${ws}~T5\\((void|)\\);${ws}static void \\* operator new\\(unsigned( int| long)?\\);${ws}static void operator delete\\(void ?\\*\\);${ws}int value\\((void|)\\);${ws}\}\r\n$gdb_prompt $" {
d107 1
a107 1
	-re "0. cancel.*\[\r\n\]*.1. all.*\[\r\n\]*.2. T5<int>::T5\\(int\\) at .*\[\r\n\]*.3. T5<int>::T5\\(T5<int> const ?&\\) at .*\[\r\n\]*> $" {
d112 1
a112 1
	-re ".0. cancel\[\r\n\]*.1. all\[\r\n\]*.2. T5<int>::T5\\(T5<int> const ?&\\) at .*templates.cc:.*\[\r\n\]*.3. T5<int>::T5\\(int\\) at .*templates.cc:.*\[\r\n\]*> $" {
@


1.9
log
@        * gdb.c++/classes.exp, gdb.c++/derivation.exp,
        gdb.c++/inherit.exp, gdb.c++/method.exp,
        gdb.c++/namespace.exp, gdb.c++/templates.exp,
        gdb.c++/userdef.exp, gdb.c++/virtfunc.exp: Updates for v3 demangler
        and class layout support.
@
text
@d256 1
a256 1
setup_xfail hppa2.0w-*-* CLLbs16092
d306 1
a306 1
setup_xfail hppa2.0w-*-* CLLbs16092
d342 1
a342 1
setup_xfail hppa2.0w-*-* CLLbs16092
d405 1
a405 1
setup_xfail hppa2.0w-*-* CLLbs16092
@


1.8
log
@2001-11-07  Michael Snyder  <msnyder@@redhat.com>

        * gdb.c++/templates.exp (test_template_breakpoints):
	If we get an overload menu, but it does not match what
	we expect, we still need to issue the "cancel" command.
@
text
@d290 1
a290 1
   -re "type = (class |)Foo<volatile char \\*> \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*.*char.*\\*t;\r\n\r\n\[ \t\]*.*char \\* foo\\(int,.*char.*\\*\\);\r\n\\}\r\n$gdb_prompt $" { pass "ptype fvpchar" }
d420 1
a420 1
   -re "type = class Spec<int,int \\*> \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\r\n\[ \t\]*.*int spec\\(int \\*\\);\r\n\\}\r\n$gdb_prompt $" { pass "ptype siip" }
@


1.7
log
@2001-11-07  Michael Snyder  <msnyder@@redhat.com>

        * gdb.c++/templates.exp: Replace "void \\*" with "void ?\\*",
	making the whitespace optional.  Argument for "new" may be
	"unsigned" as well as "unsigned int/long".
@
text
@d117 5
a121 1
        -re ".*\n> $" { fail "constructor breakpoint" }
@


1.6
log
@2001-11-07  Michael Snyder  <msnyder@@redhat.com>

        * gdb.c++/templates.exp: Replace "const &" with "const ?&",
	making the whitespace optional.  Also replace "(void) with
	"((void|)), making the keyword "void" optional.
@
text
@d56 1
a56 1
	-re "type = class T5<int> \{${ws}public:${ws}static int X;${ws}int x;${ws}int val;${ws}T5<int> & operator=\\(T5<int> const ?&\\);${ws}T5\\(int\\);${ws}T5\\(T5<int> const ?&\\);${ws}~T5\\((void|)\\);${ws}static void \\* operator new\\(unsigned (int|long)\\);${ws}static void operator delete\\(void \\*\\);${ws}int value\\((void|)\\);${ws}\}\r\n$gdb_prompt $" {
d59 3
a61 3
	-re "type = class T5<int> \\{${ws}public:${ws}static int X;${ws}int x;${ws}int val;${ws}${ws}T5 \\(int\\);${ws}T5 \\(const class T5<int> &\\);${ws}void ~T5 \\(int\\);${ws}static void \\* new \\(unsigned int\\);${ws}static void delete \\(void \\*\\);${ws}int value \\((void|)\\);${ws}\\}${ws}$gdb_prompt $" { pass "ptype T5<int> -- new with unsigned int" }
	-re "type = class T5<int> \\{.*public:.*static int X;.*int x;.*int val;.*T5 \\(int\\);.*T5 \\(const class T5<int> &\\);.*void ~T5 \\(int\\);.*static void \\* new \\(unsigned long\\);.*static void delete \\(void \\*\\);.*int value \\((void|)\\);.*\\}\r\n$gdb_prompt $" { pass "ptype T5<int> -- new with unsigned long" }
	-re "type = class T5<int> \{${ws}public:${ws}static int X;${ws}int x;${ws}int val;((${ws}T5<int> & operator=\\(T5<int> const ?&\\);)|(${ws}T5\\(int\\);)|(${ws}T5\\(T5<int> const ?&\\);)|(${ws}~T5\\((void|)\\);)|(${ws}static void \\* operator new\\(unsigned (int|long)\\);)|(${ws}static void operator delete\\(void \\*\\);)|(${ws}int value\\((void|)\\);))*${ws}\}\r\n$gdb_prompt $" {
d74 3
a76 3
        -re "type = class T5<int> \\{${ws}public:${ws}static int X;${ws}int x;${ws}int val;\r\n${ws}T5\\(int\\);${ws}T5\\(T5<int> const ?&\\);${ws}~T5\\((void|)\\);${ws}static void \\* operator new\\(unsigned int\\);${ws}static void operator delete\\(void \\*\\);${ws}int value\\((void|)\\);${ws}\\}\r\n$gdb_prompt $" { pass "ptype T5<int> -- with several fixes from 4.17" }
        -re "type = class T5<int> \\{${ws}public:${ws}static int X;${ws}int x;${ws}int val;\r\n${ws}T5 \\(int\\);${ws}T5 \\(const class T5<int> &\\);${ws}void ~T5 \\(int\\);${ws}static void \\* new \\(unsigned int\\);${ws}static void delete \\(void \\*\\);${ws}int value \\((void|)\\);${ws}\\}\r\n$gdb_prompt $" { pass "ptype t5i<int> -- new with unsigned int" }
        -re "type = class T5<int> \\{${ws}public:${ws}static int X;${ws}int x;${ws}int val;\r\n${ws}T5 \\(int\\);${ws}T5 \\(const class T5<int> &\\);${ws}void ~T5 \\(int\\);${ws}static void \\* new \\(unsigned long\\);${ws}static void delete \\(void \\*\\);${ws}int value \\((void|)\\);${ws}\\}\r\n$gdb_prompt $" { pass "ptype t5i<int> -- new with unsigned long" }
d80 1
a80 1
	-re "type = class T5<int> \{${ws}public:${ws}static int X;${ws}int x;${ws}int val;${ws}T5<int> & operator=\\(T5<int> const ?&\\);${ws}T5\\(int\\);${ws}T5\\(T5<int> const ?&\\);${ws}~T5\\((void|)\\);${ws}static void \\* operator new\\(unsigned (int|long)\\);${ws}static void operator delete\\(void \\*\\);${ws}int value\\((void|)\\);${ws}\}\r\n$gdb_prompt $" {
d83 1
a83 1
	-re "type = class T5<int> \{${ws}public:${ws}static int X;${ws}int x;${ws}int val;((${ws}T5<int> & operator=\\(T5<int> const ?&\\);)|(${ws}T5\\(int\\);)|(${ws}T5\\(T5<int> const ?&\\);)|(${ws}~T5\\((void|)\\);)|(${ws}static void \\* operator new\\(unsigned (int|long)\\);)|(${ws}static void operator delete\\(void \\*\\);)|(${ws}int value\\((void|)\\);))*${ws}\}\r\n$gdb_prompt $" {
@


1.5
log
@* gdb.c++/templates.exp: If we see the prompt for the overload
list, but we haven't recognized any of the longer patterns,
arrange for this test to fail, not hang.
@
text
@d56 1
a56 1
	-re "type = class T5<int> \{${ws}public:${ws}static int X;${ws}int x;${ws}int val;${ws}T5<int> & operator=\\(T5<int> const &\\);${ws}T5\\(int\\);${ws}T5\\(T5<int> const &\\);${ws}~T5\\(void\\);${ws}static void \\* operator new\\(unsigned (int|long)\\);${ws}static void operator delete\\(void \\*\\);${ws}int value\\(void\\);${ws}\}\r\n$gdb_prompt $" {
d59 3
a61 3
	-re "type = class T5<int> \\{${ws}public:${ws}static int X;${ws}int x;${ws}int val;${ws}${ws}T5 \\(int\\);${ws}T5 \\(const class T5<int> &\\);${ws}void ~T5 \\(int\\);${ws}static void \\* new \\(unsigned int\\);${ws}static void delete \\(void \\*\\);${ws}int value \\(void\\);${ws}\\}${ws}$gdb_prompt $" { pass "ptype T5<int> -- new with unsigned int" }
	-re "type = class T5<int> \\{.*public:.*static int X;.*int x;.*int val;.*T5 \\(int\\);.*T5 \\(const class T5<int> &\\);.*void ~T5 \\(int\\);.*static void \\* new \\(unsigned long\\);.*static void delete \\(void \\*\\);.*int value \\(void\\);.*\\}\r\n$gdb_prompt $" { pass "ptype T5<int> -- new with unsigned long" }
	-re "type = class T5<int> \{${ws}public:${ws}static int X;${ws}int x;${ws}int val;((${ws}T5<int> & operator=\\(T5<int> const &\\);)|(${ws}T5\\(int\\);)|(${ws}T5\\(T5<int> const &\\);)|(${ws}~T5\\(void\\);)|(${ws}static void \\* operator new\\(unsigned (int|long)\\);)|(${ws}static void operator delete\\(void \\*\\);)|(${ws}int value\\(void\\);))*${ws}\}\r\n$gdb_prompt $" {
d74 4
a77 4
        -re "type = class T5<int> \\{${ws}public:${ws}static int X;${ws}int x;${ws}int val;\r\n${ws}T5\\(int\\);${ws}T5\\(T5<int> const &\\);${ws}~T5\\(void\\);${ws}static void \\* operator new\\(unsigned int\\);${ws}static void operator delete\\(void \\*\\);${ws}int value\\(void\\);${ws}\\}\r\n$gdb_prompt $" { pass "ptype T5<int> -- with several fixes from 4.17" }
        -re "type = class T5<int> \\{${ws}public:${ws}static int X;${ws}int x;${ws}int val;\r\n${ws}T5 \\(int\\);${ws}T5 \\(const class T5<int> &\\);${ws}void ~T5 \\(int\\);${ws}static void \\* new \\(unsigned int\\);${ws}static void delete \\(void \\*\\);${ws}int value \\(void\\);${ws}\\}\r\n$gdb_prompt $" { pass "ptype t5i<int> -- new with unsigned int" }
        -re "type = class T5<int> \\{${ws}public:${ws}static int X;${ws}int x;${ws}int val;\r\n${ws}T5 \\(int\\);${ws}T5 \\(const class T5<int> &\\);${ws}void ~T5 \\(int\\);${ws}static void \\* new \\(unsigned long\\);${ws}static void delete \\(void \\*\\);${ws}int value \\(void\\);${ws}\\}\r\n$gdb_prompt $" { pass "ptype t5i<int> -- new with unsigned long" }
        -re "type = class T5<int> \{.*public:.*static int X;.*int x;.*int val;.*.*T5 \\(int\\);.*.*void ~T5 \\(int\\).*.*.*int value \\(void\\);.*\}.*$gdb_prompt $" { 
d80 1
a80 1
	-re "type = class T5<int> \{${ws}public:${ws}static int X;${ws}int x;${ws}int val;${ws}T5<int> & operator=\\(T5<int> const &\\);${ws}T5\\(int\\);${ws}T5\\(T5<int> const &\\);${ws}~T5\\(void\\);${ws}static void \\* operator new\\(unsigned (int|long)\\);${ws}static void operator delete\\(void \\*\\);${ws}int value\\(void\\);${ws}\}\r\n$gdb_prompt $" {
d83 1
a83 1
	-re "type = class T5<int> \{${ws}public:${ws}static int X;${ws}int x;${ws}int val;((${ws}T5<int> & operator=\\(T5<int> const &\\);)|(${ws}T5\\(int\\);)|(${ws}T5\\(T5<int> const &\\);)|(${ws}~T5\\(void\\);)|(${ws}static void \\* operator new\\(unsigned (int|long)\\);)|(${ws}static void operator delete\\(void \\*\\);)|(${ws}int value\\(void\\);))*${ws}\}\r\n$gdb_prompt $" {
d107 1
a107 1
	-re "0. cancel.*\[\r\n\]*.1. all.*\[\r\n\]*.2. T5<int>::T5\\(int\\) at .*\[\r\n\]*.3. T5<int>::T5\\(T5<int> const &\\) at .*\[\r\n\]*> $" {
d112 1
a112 1
	-re ".0. cancel\[\r\n\]*.1. all\[\r\n\]*.2. T5<int>::T5\\(T5<int> const &\\) at .*templates.cc:.*\[\r\n\]*.3. T5<int>::T5\\(int\\) at .*templates.cc:.*\[\r\n\]*> $" {
@


1.4
log
@Update/correct copyright notices.
@
text
@d117 1
@


1.3
log
@2000-11-09  Fernando Nasser  <fnasser@@redhat.com>

        * gdb.c++/templates.exp (test_template_breakpoints): Change Britsh
        spelling "cancelled" to U.S. spelling "canceled" to match changes
        made to gdb.
        * gdb.c++/ovldbreak.exp: Ditto.
@
text
@d1 2
a2 1
# Copyright (C) 1992, 1996, 1997, 1999 Free Software Foundation, Inc.
@


1.2
log
@New tests, fix old tests, make more tests work
@
text
@d108 1
a108 1
		"cancelled" \
d113 1
a113 1
		"cancelled" \
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
# Copyright (C) 1992, 1996, 1997 Free Software Foundation, Inc.
d28 2
a40 8
# if we are on HPUX and we are not compiled with gcc, then skip these tests.

if [istarget hppa*-*-hpux*] {
    if {!$gcc_compiled} {
	continue 
    }
}

a44 2
source ${binfile}.ci

d55 1
a55 1
	-re "type = class T5<int> \{${ws}public:${ws}static int X;${ws}int x;${ws}int val;${ws}T5\\<int> & operator=\\(T5<int> const &\\);${ws}T5\\(int\\);${ws}T5\\(T5<int> const &\\);${ws}~T5\\(void\\);${ws}static void \\* operator new\\(unsigned (int|long)\\);${ws}static void operator delete\\(void \\*\\);${ws}int value\\(void\\);${ws}\}\r\n$gdb_prompt $" {
d58 3
a60 1
	-re "type = class T5<int> \{${ws}public:${ws}static int X;${ws}int x;${ws}int val;((${ws}T5\\<int> & operator=\\(T5<int> const &\\);)|(${ws}T5\\(int\\);)|(${ws}T5\\(T5<int> const &\\);)|(${ws}~T5\\(void\\);)|(${ws}static void \\* operator new\\(unsigned (int|long)\\);)|(${ws}static void operator delete\\(void \\*\\);)|(${ws}int value\\(void\\);))*${ws}\}\r\n$gdb_prompt $" {
d73 6
d102 1
d120 3
a122 1
   gdb_test "break T5<int>::~T5" \
d139 1
d147 1
d154 4
d159 1
a159 1
	default { fail "print t5i.value() (timeout)" }
d212 242
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-08-02 snapshot
@
text
@d39 8
d51 2
a65 2
	-re "type = class T5<int> \\{${ws}public:${ws}static int X;${ws}int x;${ws}int val;${ws}${ws}T5 \\(int\\);${ws}T5 \\(const class T5<int> &\\);${ws}void ~T5 \\(int\\);${ws}static void \\* new \\(unsigned int\\);${ws}static void delete \\(void \\*\\);${ws}int value \\(void\\);${ws}\\}${ws}$gdb_prompt $" { pass "ptype T5<int> -- new with unsigned int" }
	-re "type = class T5<int> \\{.*public:.*static int X;.*int x;.*int val;.*T5 \\(int\\);.*T5 \\(const class T5<int> &\\);.*void ~T5 \\(int\\);.*static void \\* new \\(unsigned long\\);.*static void delete \\(void \\*\\);.*int value \\(void\\);.*\\}\r\n$gdb_prompt $" { pass "ptype T5<int> -- new with unsigned long" }
a78 6
        -re "type = class T5<int> \\{${ws}public:${ws}static int X;${ws}int x;${ws}int val;\r\n${ws}T5\\(int\\);${ws}T5\\(T5<int> const &\\);${ws}~T5\\(void\\);${ws}static void \\* operator new\\(unsigned int\\);${ws}static void operator delete\\(void \\*\\);${ws}int value\\(void\\);${ws}\\}\r\n$gdb_prompt $" { pass "ptype T5<int> -- with several fixes from 4.17" }
        -re "type = class T5<int> \\{${ws}public:${ws}static int X;${ws}int x;${ws}int val;\r\n${ws}T5 \\(int\\);${ws}T5 \\(const class T5<int> &\\);${ws}void ~T5 \\(int\\);${ws}static void \\* new \\(unsigned int\\);${ws}static void delete \\(void \\*\\);${ws}int value \\(void\\);${ws}\\}\r\n$gdb_prompt $" { pass "ptype t5i<int> -- new with unsigned int" }
        -re "type = class T5<int> \\{${ws}public:${ws}static int X;${ws}int x;${ws}int val;\r\n${ws}T5 \\(int\\);${ws}T5 \\(const class T5<int> &\\);${ws}void ~T5 \\(int\\);${ws}static void \\* new \\(unsigned long\\);${ws}static void delete \\(void \\*\\);${ws}int value \\(void\\);${ws}\\}\r\n$gdb_prompt $" { pass "ptype t5i<int> -- new with unsigned long" }
        -re "type = class T5<int> \{.*public:.*static int X;.*int x;.*int val;.*.*T5 \\(int\\);.*.*void ~T5 \\(int\\).*.*.*int value \\(void\\);.*\}.*$gdb_prompt $" { 
            pass "ptype t5i"
        }
a101 1
    global hp_aCC_compiler
d119 1
a119 3
# See CLLbs14792
    if {$hp_aCC_compiler} {setup_xfail hppa*-*-* CLLbs14792}
    gdb_test "break T5<int>::~T5" \
a135 1
    global hp_aCC_compiler
a142 1
    if {!$hp_aCC_compiler} {setup_xfail hppa*-*-*}
a148 4
        -re "Cannot resolve .* to any overloaded instance.*$gdb_prompt $" {
	    setup_xfail hppa*-*-* CLLbs16899
            xfail "print t5i.value"
	}
d150 1
a150 1
	timeout { fail "print t5i.value() (timeout)" }
a202 215
if {!$hp_aCC_compiler} {continue}

# More tests for different kinds of template parameters,
# templates with partial specializations, nested templates, etc.
# These have been tested only with HP aCC.  They probably won't
# work with other compilers because of differences in mangling
# schemes. 
# Added by Satish Pai <pai@@apollo.hp.com> 1997-09-25 

send_gdb "print fint\n"   
gdb_expect {   
   -re "\\$\[0-9\]* = \\{x = 0, t = 0\\}\r\n$gdb_prompt $" { pass "print fint" }
   -re "$gdb_prompt $"                     { fail "print fint" }
   timeout                             { fail "(timeout) print fint" }
}

send_gdb "print fvpchar\n"   
gdb_expect {   
   -re "\\$\[0-9\]* = \\{x = 0, t = 0x0\\}\r\n$gdb_prompt $" { pass "print fvpchar" }
   -re "$gdb_prompt $"                     { fail "print fvpchar" }
   timeout                             { fail "(timeout) print fvpchar" }
}

# Template Foo<T>

setup_xfail hppa2.0w-*-* CLLbs16092
send_gdb "ptype Foo\n"   
gdb_expect {   
   -re "type = template <(class |)T> (class |)Foo \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*T t;\r\n\\}\r\ntemplate instantiations:\r\n\[ \t\]*(class |)Foo<volatile char \\*>\r\n\[ \t\]*(class |)Foo<char>\r\n\[ \t\]*(class |)Foo<int>\r\n$gdb_prompt $" { pass "ptype Foo" }
   -re "type = template <(class |)T> (class |)Foo \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*T t;\r\n\\}\r\n$gdb_prompt $" { xfail "ptype Foo" }
   -re "$gdb_prompt $"                     { fail "ptype Foo" }
   timeout                             { fail "(timeout) ptype Foo" }
}

# ptype Foo<int>

send_gdb "ptype fint\n"   
gdb_expect {   
   -re "type = (class |)Foo<int> \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*int t;\r\n\r\n\[ \t\]*int foo\\(int, int\\);\r\n\\}\r\n$gdb_prompt $" { pass "ptype fint" }
   -re "$gdb_prompt $"                     { fail "ptype fint" }
   timeout                             { fail "(timeout) ptype fint" }
}

# ptype Foo<char>

send_gdb "ptype fchar\n"   
gdb_expect {   
   -re "type = (class |)Foo<char> \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*char t;\r\n\r\n\[ \t\]*char foo\\(int, char\\);\r\n\\}\r\n$gdb_prompt $" { pass "ptype fchar" }
   -re "$gdb_prompt $"                     { fail "ptype fchar" }
   timeout                             { fail "(timeout) ptype fchar" }
}

# ptype Foo<volatile char *>

send_gdb "ptype fvpchar\n"   
gdb_expect {   
   -re "type = (class |)Foo<volatile char \\*> \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*volatile char \\*t;\r\n\r\n\[ \t\]*volatile char \\* foo\\(int, volatile char \\*\\);\r\n\\}\r\n$gdb_prompt $" { pass "ptype fvpchar" }
   -re "$gdb_prompt $"                     { fail "ptype fvpchar" }
   timeout                             { fail "(timeout) ptype fvpchar" }
}

# print a function from Foo<volatile char *>

send_gdb "print Foo<volatile char *>::foo\n"   
gdb_expect {   
   -re "\\$\[0-9\]* = \\{volatile char \\*\\((class |)Foo<volatile char \\*> \\*, int, volatile char \\*\\)\\} $hex <Foo<volatile char \\*>::foo\\(int, volatile char \\*\\)>\r\n$gdb_prompt $" { pass "print Foo<volatile char *>::foo" }
   -re "$gdb_prompt $"                     { fail "print Foo<volatile char *>::foo" }
   timeout                             { fail "(timeout) print Foo<volatile char *>::foo" }
}

# Template Bar<T, int>

setup_xfail hppa2.0w-*-* CLLbs16092
send_gdb "ptype Bar\n"   
gdb_expect {   
   -re "type = template <(class |)T, (class |)sz> (class |)Bar \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*T t;\r\n\\}\r\ntemplate instantiations:\r\n\[ \t\]*(class |)Bar<int,(\\(int\\)|)1>\r\n\[ \t\]*(class |)Bar<int,(\\(int\\)|)33>\r\n$gdb_prompt $" { pass "ptype Bar" }
   -re "type = <(class |)T, (class |)sz> (class |)Bar \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*T t;\r\n\\}\r\n$gdb_prompt $" { xfail "ptype Bar" }
   -re "$gdb_prompt $"                     { fail "ptype Bar" }
   timeout                             { fail "(timeout) ptype Bar" }
}


# ptype Bar<int,33>

send_gdb "ptype bint\n"   
gdb_expect {   
   -re "type = (class |)Bar<int,(\\(int\\)|)33> \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*int t;\r\n\r\n\[ \t\]*int bar\\(int, int\\);\r\n\\}\r\n$gdb_prompt $" { pass "ptype bint" }
   -re "$gdb_prompt $"                     { fail "ptype bint" }
   timeout                             { fail "(timeout) ptype bint" }
}

# ptype Bar<int, (4>3)>

send_gdb "ptype bint2\n"   
gdb_expect {   
   -re "type = (class |)Bar<int,(\\(int\\)|)1> \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*int t;\r\n\r\n\[ \t\]*int bar\\(int, int\\);\r\n\\}\r\n$gdb_prompt $" { pass "ptype bint2" }
   -re "$gdb_prompt $"                     { fail "ptype bint2" }
   timeout                             { fail "(timeout) ptype bint2" }
}

# Template Baz<T, char>

setup_xfail hppa2.0w-*-* CLLbs16092
send_gdb "ptype Baz\n"   
gdb_expect {   
   -re "type = template <(class |)T, (class |)sz> (class |)Baz \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*T t;\r\n\\}\r\ntemplate instantiations:\r\n\[ \t\]*(class |)Baz<char,(\\(char\\)|)97>\r\n\[ \t\]*(class |)Baz<int,(\\(char\\)|)115>\r\n$gdb_prompt $" { pass "ptype Baz" }
   -re "type = <(class |)T, (class |)sz> (class |)Baz \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*T t;\r\n\\}\r\n$gdb_prompt $" { xfail "ptype Baz" }
   -re "$gdb_prompt $"                     { fail "ptype Baz" }
   timeout                             { fail "(timeout) ptype Baz" }
}


# ptype Baz<int, 's'>

send_gdb "ptype bazint\n"   
gdb_expect {   
   -re "type = (class |)Baz<int,(\\(char\\)|)115> \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*int t;\r\n\r\n\[ \t\]*int baz\\(int, int\\);\r\n\\}\r\n$gdb_prompt $" { pass "ptype bazint" }
   -re "$gdb_prompt $"                     { fail "ptype bazint" }
   timeout                             { fail "(timeout) ptype bazint" }
}

# ptype Baz<char, 'a'>

send_gdb "ptype bazint2\n"   
gdb_expect {   
   -re "type = (class |)Baz<char,(\\(char\\)|)97> \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*char t;\r\n\r\n\[ \t\]*char baz\\(int, char\\);\r\n\\}\r\n$gdb_prompt $" { pass "ptype bazint2" }
   -re "$gdb_prompt $"                     { fail "ptype bazint2" }
   timeout                             { fail "(timeout) ptype bazint2" }
}

# Template Qux<T, int (*f)(int) >

send_gdb "ptype Qux\n"   
gdb_expect {   
   -re "type = template <(class |)T, (class |)sz> (class |)Qux \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*T t;\r\n\\}\r\ntemplate instantiations:\r\n\[ \t\]*(class |)Qux<int,&string>\r\n\[ \t\]*(class |)Qux<char,&string>\r\n$gdb_prompt $" { pass "ptype Qux" }
   -re ".*type = template <(class |)T.*, (class |)sz> (class |)Qux \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*T t;\r\n\\}.*$gdb_prompt $" { pass "ptype Qux" }
   -re "$gdb_prompt $"                     { fail "ptype Qux" }
   timeout                             { fail "(timeout) ptype Qux" }
}

# pt Qux<int,&string>

send_gdb "ptype quxint\n"   
gdb_expect {   
   -re "type = class Qux<int,&string> \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*int t;\r\n\r\n\[ \t\]*int qux\\(int, int\\);\r\n\\}\r\n$gdb_prompt $" { pass "ptype quxint" }
   -re "$gdb_prompt $"                     { fail "ptype quxint" }
   timeout                             { fail "(timeout) ptype quxint" }
}

# pt Qux<char,0>

# commented out this as quxint2 declaration was commented out in
# templates.exp -- ovidiu
# send_gdb "ptype quxint2\n"   
# gdb_expect {   
#    -re "type = class Qux<char,&string> \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*char t;\r\n\r\n\[ \t\]*char qux\\(int, char\\);\r\n\\}\r\n$gdb_prompt $" { pass "ptype quxint2" }
#    -re "$gdb_prompt $"                     { fail "ptype quxint2" }
#    timeout                             { fail "(timeout) ptype quxint2" }
# }

# Template Spec<T1, T2>

setup_xfail hppa2.0w-*-* CLLbs16092
send_gdb "ptype Spec\n"   
gdb_expect {   
   -re "type = template <(class |)T1, (class |)T2> (class |)Spec \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\\}\r\ntemplate instantiations:\r\n\[ \t\]*(class |)Spec<int,int \\*>\r\n\[ \t\]*(class |)Spec<int,char>\r\n$gdb_prompt $" { pass "ptype Spec" }
   -re "type = <(class |)T1, (class |)T2> (class |)Spec \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\\}\r\n$gdb_prompt $" { xfail "ptype Spec" }
   -re "$gdb_prompt $"                     { fail "ptype Spec" }
   timeout                             { fail "(timeout) ptype Spec" }
}

# pt Spec<char,0>

send_gdb "ptype siip\n"   
gdb_expect {   
   -re "type = class Spec<int,int \\*> \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\r\n\[ \t\]*int spec\\(int \\*\\);\r\n\\}\r\n$gdb_prompt $" { pass "ptype siip" }
   -re "$gdb_prompt $"                     { fail "ptype siip" }
   timeout                             { fail "(timeout) ptype siip" }
}

# pt Garply<int>

send_gdb "ptype Garply<int>\n"   
gdb_expect {   
   -re "type = class Garply<int> \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*int t;\r\n\r\n\[ \t\]*int garply\\(int, int\\);\r\n\\}\r\n$gdb_prompt $" { pass "ptype Garply<int>" }
   -re "$gdb_prompt $"                     { fail "ptype Garply<int>" }
   timeout                             { fail "(timeout) ptype Garply<int>" }
}

# ptype of nested template name

send_gdb "ptype Garply<Garply<char> >\n"   
gdb_expect {   
   -re "type = (class |)Garply<Garply<char> > \\{\r\n\[ \t\]*public:\r\n\[ \t\]*int x;\r\n\[ \t\]*(class |)Garply<char> t;\r\n\r\n\[ \t\]*(class |)Garply<char> garply\\(int, (class |)Garply<char>\\);\r\n\\}\r\n$gdb_prompt $" { pass "ptype Garply<Garply<char> >" }
   -re "$gdb_prompt $"                     { fail "ptype Garply<Garply<char> >" }
   timeout                             { fail "(timeout) ptype Garply<Garply<char> >" }
}

# print out a function from a nested template name

send_gdb "print Garply<Garply<char> >::garply\n"
gdb_expect {
   -re "\\$\[0-9\]* = \\{(class |)Garply<char> \\((class |)Garply<Garply<char> > \\*, int, (class |)Garply<char>\\)\\} $hex <Garply<Garply<char>>::garply\\(int, (class |)Garply<char>\\)>\r\n$gdb_prompt $" { pass "print Garply<Garply<char> >::garply" }
   -re ".*$gdb_prompt $" { fail "print Garply<Garply<char> >::garply" }
   timeout { fail "print Garply<Garply<char> >::garply (timeout)" }
}

# UNFORTUNATELY, "break Garply<Garply<char> >::garply" doesn't yet work.

#send_gdb "break Garply<Garply<char> >::garply
#gdb_expect {
#   -re "Breakpoint \[0-9\]* at $hex: file .*templates.cc, line.*\r\n$gdb_prompt $" { pass "break Garply<Garply<char> >::garply" }
#   -re ".*$gdb_prompt $" { fail "break Garply<Garply<char> >::garply" }
#   timeout { fail "break Garply<Garply<char> >::garply (timeout)" }
#}
@


1.1.1.3
log
@import gdb-1999-09-08 snapshot
@
text
@d1 1
a1 1
# Copyright (C) 1992, 1996, 1997, 1999 Free Software Foundation, Inc.
a26 2

if { [skip_cplus_tests] } { continue }
@


1.1.1.4
log
@import gdb-2000-02-04 snapshot
@
text
@d55 1
a55 1
	-re "type = class T5<int> \{${ws}public:${ws}static int X;${ws}int x;${ws}int val;${ws}T5<int> & operator=\\(T5<int> const &\\);${ws}T5\\(int\\);${ws}T5\\(T5<int> const &\\);${ws}~T5\\(void\\);${ws}static void \\* operator new\\(unsigned (int|long)\\);${ws}static void operator delete\\(void \\*\\);${ws}int value\\(void\\);${ws}\}\r\n$gdb_prompt $" {
d60 1
a60 1
	-re "type = class T5<int> \{${ws}public:${ws}static int X;${ws}int x;${ws}int val;((${ws}T5<int> & operator=\\(T5<int> const &\\);)|(${ws}T5\\(int\\);)|(${ws}T5\\(T5<int> const &\\);)|(${ws}~T5\\(void\\);)|(${ws}static void \\* operator new\\(unsigned (int|long)\\);)|(${ws}static void operator delete\\(void \\*\\);)|(${ws}int value\\(void\\);))*${ws}\}\r\n$gdb_prompt $" {
@


