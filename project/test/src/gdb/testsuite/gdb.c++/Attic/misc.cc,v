head	1.6;
access;
symbols
	cagney_x86i386-20030821-branch:1.5.0.52
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.50
	gdb_6_0-2003-06-23-branchpoint:1.5
	jimb-ppc64-linux-20030613-branch:1.5.0.48
	jimb-ppc64-linux-20030613-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.46
	cagney_writestrings-20030508-branchpoint:1.5
	jimb-ppc64-linux-20030528-branch:1.5.0.44
	jimb-ppc64-linux-20030528-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.42
	cagney_fileio-20030521-branchpoint:1.5
	kettenis_i386newframe-20030517-mergepoint:1.5
	jimb-ppc64-linux-20030509-branch:1.5.0.40
	jimb-ppc64-linux-20030509-branchpoint:1.5
	kettenis_i386newframe-20030504-mergepoint:1.5
	carlton_dictionary-20030430-merge:1.5
	kettenis_i386newframe-20030419-branch:1.5.0.38
	kettenis_i386newframe-20030419-branchpoint:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	kettenis_i386newframe-20030406-branch:1.5.0.36
	kettenis_i386newframe-20030406-branchpoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.34
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.32
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.30
	cagney_lazyid-20030317-branchpoint:1.5
	kettenis-i386newframe-20030316-mergepoint:1.5
	offbyone-20030313-branch:1.5.0.28
	offbyone-20030313-branchpoint:1.5
	kettenis-i386newframe-20030308-branch:1.5.0.26
	kettenis-i386newframe-20030308-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.24
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030203-mergepoint:1.5
	interps-20030202-branch:1.5.0.22
	interps-20030202-branchpoint:1.5
	cagney-unwind-20030108-branch:1.5.0.20
	cagney-unwind-20030108-branchpoint:1.5
	carlton_dictionary-20021223-merge:1.5
	gdb_5_3-2002-12-12-release:1.5
	carlton_dictionary-20021115-merge:1.5
	kseitz_interps-20021105-merge:1.5
	kseitz_interps-20021103-merge:1.5
	drow-cplus-merge-20021020:1.5
	drow-cplus-merge-20021025:1.5
	carlton_dictionary-20021025-merge:1.5
	carlton_dictionary-20021011-merge:1.5
	drow-cplus-branch:1.5.0.18
	drow-cplus-branchpoint:1.5
	kseitz_interps-20020930-merge:1.5
	carlton_dictionary-20020927-merge:1.5
	carlton_dictionary-branch:1.5.0.16
	carlton_dictionary-20020920-branchpoint:1.5
	gdb_5_3-branch:1.5.0.14
	gdb_5_3-2002-09-04-branchpoint:1.5
	kseitz_interps-20020829-merge:1.5
	cagney_sysregs-20020825-branch:1.5.0.12
	cagney_sysregs-20020825-branchpoint:1.5
	readline_4_3-import-branch:1.5.0.10
	readline_4_3-import-branchpoint:1.5
	gdb_5_2_1-2002-07-23-release:1.5
	kseitz_interps-20020528-branch:1.5.0.8
	kseitz_interps-20020528-branchpoint:1.5
	cagney_regbuf-20020515-branch:1.5.0.6
	cagney_regbuf-20020515-branchpoint:1.5
	jimb-macro-020506-branch:1.5.0.4
	jimb-macro-020506-branchpoint:1.5
	gdb_5_2-2002-04-29-release:1.5
	gdb_5_2-branch:1.5.0.2
	gdb_5_2-2002-03-03-branchpoint:1.5
	gdb_5_1_1-2002-01-24-release:1.4
	gdb_5_1_0_1-2002-01-03-release:1.4
	cygnus_cvs_20020108_pre:1.5
	gdb_5_1_0_1-2002-01-03-branch:1.4.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.4
	gdb_5_1-2001-11-21-release:1.4
	gdb_s390-2001-09-26-branch:1.4.0.6
	gdb_s390-2001-09-26-branchpoint:1.4
	gdb_5_1-2001-07-29-branch:1.4.0.4
	gdb_5_1-2001-07-29-branchpoint:1.4
	dberlin-typesystem-branch:1.4.0.2
	dberlin-typesystem-branchpoint:1.4
	gdb-post-ptid_t-2001-05-03:1.4
	gdb-pre-ptid_t-2001-05-03:1.4
	insight-precleanup-2001-01-01:1.4
	gdb-post-protoization-2000-07-29:1.4
	gdb-pre-protoization-2000-07-29:1.4
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb-post-params-removal-2000-06-04:1.1.1.3
	gdb-pre-params-removal-2000-06-04:1.1.1.3
	gdb-post-params-removal-2000-05-28:1.1.1.3
	gdb-pre-params-removal-2000-05-28:1.1.1.3
	gdb_5_0-2000-05-19-release:1.1.1.3
	gdb_4_18_2-2000-05-18-release:1.1.1.3
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.3
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.3
	gdb_5_0-2000-04-10-branch:1.1.1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.3
	repo-unification-2000-02-06:1.1.1.3
	insight-2000-02-04:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.3
	gdb-1999-12-06:1.1.1.3
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.3
	gdb-1999-10-18:1.1.1.3
	gdb-1999-10-11:1.1.1.3
	gdb-1999-10-04:1.1.1.3
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.3
	gdb-1999-09-08:1.1.1.3
	gdb-1999-08-30:1.1.1.3
	gdb-1999-08-23:1.1.1.3
	gdb-1999-08-16:1.1.1.3
	gdb-1999-08-09:1.1.1.3
	gdb-1999-08-02:1.1.1.3
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@// @;
expand	@o@;


1.6
date	2003.08.23.03.55.59;	author chastain;	state dead;
branches;
next	1.5;

1.5
date	2001.12.07.21.58.19;	author drow;	state Exp;
branches
	1.5.16.1
	1.5.18.1
	1.5.50.1;
next	1.4;

1.4
date	2000.07.09.05.16.11;	author nsd;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.09.05.10.13;	author nsd;	state Exp;
branches;
next	1.2;

1.2
date	2000.06.05.20.47.28;	author dberlin;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.32;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.32;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.27.25;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.08.02.23.46.55;	author jsm;	state Exp;
branches;
next	;

1.5.16.1
date	2003.08.30.03.40.34;	author chastain;	state dead;
branches;
next	;

1.5.18.1
date	2003.12.14.20.27.51;	author drow;	state dead;
branches;
next	;

1.5.50.1
date	2003.08.25.03.53.48;	author chastain;	state dead;
branches;
next	;


desc
@@


1.6
log
@2003-08-22  Michael Chastain  <mec@@shout.net>

	* gdb.cp: New directory.
	* gdb.cp/*: Copy from gdb.c++/*.
	* gdb.c++/*: Remove.
	* Makefile.in: Change gdb.c++ to gdb.cp.
	* configure.in:  Ditto.
	* configure: Regnerate.
@
text
@// Test various -*- C++ -*- things.

// ====================== basic C++ types  =======================
bool            v_bool;
bool            v_bool_array[2];

typedef struct fleep fleep;
struct fleep { int a; } s;

// ====================== simple class structures  =======================

struct default_public_struct {
 // defaults to public:
  int a;
  int b;
};

struct explicit_public_struct {
 public:
  int a;
  int b;
};

struct protected_struct {
 protected:
  int a;
  int b;
};

struct private_struct {
 private:
  int a;
  int b;
};

struct mixed_protection_struct {
 public:
  int a;
  int b;
 private:
  int c;
  int d;
 protected:
  int e;
  int f;
 public:
  int g;
 private:
  int h;
 protected:
  int i;
};

class public_class {
 public:
  int a;
  int b;
};

class protected_class {
 protected:
  int a;
  int b;
};

class default_private_class {
 // defaults to private:
  int a;
  int b;
};

class explicit_private_class {
 private:
  int a;
  int b;
};

class mixed_protection_class {
 public:
  int a;
  int b;
 private:
  int c;
  int d;
 protected:
  int e;
  int f;
 public:
  int g;
 private:
  int h;
 protected:
  int i;
};

class const_vol_method_class {
public:
  int a;
  int b;
  int foo (int &) const;
  int bar (int &) volatile;
  int baz (int &) const volatile;
};

int const_vol_method_class::foo (int & ir) const
{
  return ir + 3;
}
int const_vol_method_class::bar (int & ir) volatile
{
  return ir + 4;
}
int const_vol_method_class::baz (int & ir) const volatile
{
  return ir + 5;
}

// ========================= simple inheritance ==========================

class A {
 public:
  int a;
  int x;
};

A g_A;

class B : public A {
 public:
  int b;
  int x;
};

B g_B;

class C : public A {
 public:
  int c;
  int x;
};

C g_C;

class D : public B, public C {
 public:
  int d;
  int x;
};

D g_D;

class E : public D {
 public:
  int e;
  int x;
};

E g_E;

class class_with_anon_union
{
 public:
  int one;
  union
  {
    int a;
    long b;
  };
};

class_with_anon_union g_anon_union;

void inheritance2 (void)
{
}

void inheritance1 (void)
{
  int ival;
  int *intp;

  // {A::a, A::x}

  g_A.A::a = 1;
  g_A.A::x = 2;

  // {{A::a,A::x},B::b,B::x}

  g_B.A::a = 3;
  g_B.A::x = 4;
  g_B.B::b = 5;
  g_B.B::x = 6;

  // {{A::a,A::x},C::c,C::x}

  g_C.A::a = 7;
  g_C.A::x = 8;
  g_C.C::c = 9;
  g_C.C::x = 10;

  // {{{A::a,A::x},B::b,B::x},{{A::a,A::x},C::c,C::x},D::d,D::x}

  // The following initialization code is non-portable, but allows us
  // to initialize all members of g_D until we can fill in the missing
  // initialization code with legal C++ code.

  for (intp = (int *) &g_D, ival = 11;
       intp < ((int *) &g_D + sizeof (g_D) / sizeof (int));
       intp++, ival++)
    {
      *intp = ival;
    }

  // Overlay the nonportable initialization with legal initialization.

  // ????? = 11;  (g_D.A::a = 11; is ambiguous)
  // ????? = 12;  (g_D.A::x = 12; is ambiguous)
/* djb 6-3-2000

	This should take care of it. Rather than try to initialize using an ambiguous
	construct, use 2 unambiguous ones for each. Since the ambiguous a/x member is
	coming from C, and B, initialize D's C::a, and B::a, and D's C::x and B::x.
 */
  g_D.C::a = 15;
  g_D.C::x = 12;
  g_D.B::a = 11;
  g_D.B::x = 12;
  g_D.B::b = 13;
  g_D.B::x = 14;
  // ????? = 15;
  // ????? = 16;
  g_D.C::c = 17;
  g_D.C::x = 18;
  g_D.D::d = 19;
  g_D.D::x = 20;


  // {{{{A::a,A::x},B::b,B::x},{{A::a,A::x},C::c,C::x},D::d,D::x}},E::e,E::x}

  // The following initialization code is non-portable, but allows us
  // to initialize all members of g_D until we can fill in the missing
  // initialization code with legal C++ code.

  for (intp = (int *) &g_E, ival = 21;
       intp < ((int *) &g_E + sizeof (g_E) / sizeof (int));
       intp++, ival++)
  {
    *intp = ival;
  }

  // Overlay the nonportable initialization with legal initialization.

  // ????? = 21;  (g_E.A::a = 21; is ambiguous)
  // ????? = 22;  (g_E.A::x = 22; is ambiguous)
  g_E.B::b = 23;
  g_E.B::x = 24;
  // ????? = 25;
  // ????? = 26;
  g_E.C::c = 27;
  g_E.C::x = 28;
  g_E.D::d = 29;
  g_E.D::x = 30;
  g_E.E::e = 31;
  g_E.E::x = 32;

  g_anon_union.one = 1;
  g_anon_union.a = 2;

  inheritance2 ();	
}

// ======================== static member functions =====================

class Static {
public:
  static void ii(int, int);
};
void Static::ii (int, int) { }

// ======================== virtual base classes=========================

class vA {
 public:
  int va;
  int vx;
};

vA g_vA;

class vB : public virtual vA {
 public:
  int vb;
  int vx;
};

vB g_vB;

class vC : public virtual vA {
 public:
  int vc;
  int vx;
};

vC g_vC;

class vD : public virtual vB, public virtual vC {
 public:
  int vd;
  int vx;
};

vD g_vD;

class vE : public virtual vD {
 public:
  int ve;
  int vx;
};

vE g_vE;

void inheritance4 (void)
{
}

void inheritance3 (void)
{
  int ival;
  int *intp;

  // {vA::va, vA::vx}

  g_vA.vA::va = 1;
  g_vA.vA::vx = 2;

  // {{vA::va, vA::vx}, vB::vb, vB::vx}

  g_vB.vA::va = 3;
  g_vB.vA::vx = 4;
  g_vB.vB::vb = 5;
  g_vB.vB::vx = 6;

  // {{vA::va, vA::vx}, vC::vc, vC::vx}

  g_vC.vA::va = 7;
  g_vC.vA::vx = 8;
  g_vC.vC::vc = 9;
  g_vC.vC::vx = 10;

  // {{{{vA::va, vA::vx}, vB::vb, vB::vx}, vC::vc, vC::vx}, vD::vd,vD::vx}

  g_vD.vA::va = 11;
  g_vD.vA::vx = 12;
  g_vD.vB::vb = 13;
  g_vD.vB::vx = 14;
  g_vD.vC::vc = 15;
  g_vD.vC::vx = 16;
  g_vD.vD::vd = 17;
  g_vD.vD::vx = 18;


  // {{{{{vA::va,vA::vx},vB::vb,vB::vx},vC::vc,vC::vx},vD::vd,vD::vx},vE::ve,vE::vx}

  g_vD.vA::va = 19;
  g_vD.vA::vx = 20;
  g_vD.vB::vb = 21;
  g_vD.vB::vx = 22;
  g_vD.vC::vc = 23;
  g_vD.vC::vx = 24;
  g_vD.vD::vd = 25;
  g_vD.vD::vx = 26;
  g_vE.vE::ve = 27;
  g_vE.vE::vx = 28;

  inheritance4 ();	
}

// ======================================================================

class Base1 {
 public:
  int x;
  Base1(int i) { x = i; }
};

class Foo
{
 public:
  int x;
  int y;
  static int st;
  Foo (int i, int j) { x = i; y = j; }
  int operator! ();
  operator int ();
  int times (int y);
};

class Bar : public Base1, public Foo {
 public:
  int z;
  Bar (int i, int j, int k) : Base1 (10*k), Foo (i, j) { z = k; }
};

int Foo::operator! () { return !x; }

int Foo::times (int y) { return x * y; }

int Foo::st = 100;

Foo::operator int() { return x; }

Foo foo(10, 11);
Bar bar(20, 21, 22);

class ClassWithEnum {
public:
  enum PrivEnum { red, green, blue, yellow = 42 };
  PrivEnum priv_enum;
  int x;
};

void enums2 (void)
{
}

/* classes.exp relies on statement order in this function for testing
   enumeration fields.  */

void enums1 ()
{
  ClassWithEnum obj_with_enum;
  obj_with_enum.priv_enum = ClassWithEnum::red;
  obj_with_enum.x = 0;
  enums2 ();
  obj_with_enum.priv_enum = ClassWithEnum::green;
}

class ClassParam {
public:
  int Aptr_a (A *a) { return a->a; }
  int Aptr_x (A *a) { return a->x; }
  int Aref_a (A &a) { return a.a; }
  int Aref_x (A &a) { return a.x; }
  int Aval_a (A a) { return a.a; }
  int Aval_x (A a) { return a.x; }
};

ClassParam class_param;

class Contains_static_instance
{
 public:
  int x;
  int y;
  Contains_static_instance (int i, int j) { x = i; y = j; }
  static Contains_static_instance null;
};

Contains_static_instance Contains_static_instance::null(0,0);
Contains_static_instance csi(10,20);

class Contains_nested_static_instance
{
 public:
  class Nested
  {
   public:
    Nested(int i) : z(i) {}
    int z;
    static Contains_nested_static_instance xx;
  };

  Contains_nested_static_instance(int i, int j) : x(i), y(j) {}

  int x;
  int y;

  static Contains_nested_static_instance null;
  static Nested yy;
};

Contains_nested_static_instance Contains_nested_static_instance::null(0, 0);
Contains_nested_static_instance::Nested Contains_nested_static_instance::yy(5);
Contains_nested_static_instance
  Contains_nested_static_instance::Nested::xx(1,2);
Contains_nested_static_instance cnsi(30,40);

typedef struct {
  int one;
  int two;
} tagless_struct;
tagless_struct v_tagless;

/* Try to get the compiler to allocate a class in a register.  */
class small {
 public:
  int x;
  int method ();
};

int
small::method ()
{
  return x + 5;
}

void marker_reg1 () {}

int
register_class ()
{
  /* We don't call any methods for v, so gcc version cygnus-2.3.3-930220
     might put this variable in a register.  This is a lose, though, because
     it means that GDB can't call any methods for that variable.  */
  register small v;

  int i;

  /* Perform a computation sufficiently complicated that optimizing compilers
     won't optimized out the variable.  If some compiler constant-folds this
     whole loop, maybe using a parameter to this function here would help.  */
  v.x = 0;
  for (i = 0; i < 13; ++i)
    v.x += i;
  --v.x; /* v.x is now 77 */
  marker_reg1 ();
  return v.x + 5;
}

void dummy()
{
  v_bool = true;
  v_bool_array[0] = false;
  v_bool_array[1] = v_bool;
}

void use_methods ()
{
  /* Refer to methods so that they don't get optimized away. */
  int i;
  i = class_param.Aptr_a (&g_A);
  i = class_param.Aptr_x (&g_A);
  i = class_param.Aref_a (g_A);
  i = class_param.Aref_x (g_A);
  i = class_param.Aval_a (g_A);
  i = class_param.Aval_x (g_A);
}


int
main()
{
#ifdef usestubs
  set_debug_traps();
  breakpoint();
#endif
  dummy();
  inheritance1 ();
  inheritance3 ();
  enums1 ();
  register_class ();

  /* FIXME: pmi gets optimized out.  Need to do some more computation with
     it or something.  (No one notices, because the test is xfail'd anyway,
     but that probably won't always be true...).  */
  int Foo::* pmi = &Foo::y;

  /* Make sure the AIX linker doesn't remove the variable.  */
  v_tagless.one = 5;

  use_methods ();

  return foo.*pmi;
}

/* Create an instance for some classes, otherwise they get optimized away.  */

default_public_struct default_public_s;
explicit_public_struct explicit_public_s;
protected_struct protected_s;
private_struct private_s;
mixed_protection_struct mixed_protection_s;
public_class public_c;
protected_class protected_c;
default_private_class default_private_c;
explicit_private_class explicit_private_c;
mixed_protection_class mixed_protection_c;
@


1.5
log
@        * gdb.c++/classes.exp: Add test for static member function.
        * gdb.c++/misc.cc: Add class with static member function.
@
text
@@


1.5.18.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.5.16.1
log
@2003-08-22  Michael Chastain  <mec@@shout.net>

	* gdb.cp: New directory.
	* gdb.cp/*: Copy from gdb.c++/*.
	* gdb.c++/*: Remove.
	* Makefile.in: Change gdb.c++ to gdb.cp.
	* configure.in:  Ditto.
	* carlton_runnamespace: Ditto.
	* carlton_runtest: Ditto.
	* configure: Regnerate.
@
text
@@


1.5.50.1
log
@2003-08-22  Michael Chastain  <mec@@shout.net>

	* gdb.cp: New directory.
	* gdb.cp/*: Copy from gdb.c++/*.
	* gdb.c++/*: Remove.
	* Makefile.in: Change gdb.c++ to gdb.cp.
	* configure.in:  Ditto.
	* configure: Regnerate.
@
text
@@


1.4
log
@	* gdb.c++/misc.cc (class ClassParam, class_param): Define.
	(use_methods): New function.
	(main): Call use_methods().
	* gdb.c++/classes.exp (test_method_param_class): New procedure.
	(do_tests): Call test_method_param_class.
@
text
@d272 8
@


1.3
log
@	* gdb.c++/classes.exp (test_nonexistant_members): Fix name
	spelling.
	(test_enums): New procedure.  Move enum tests from end of script
	to here.  Set breakpoint on function name instead of line number.
	* gdb.c++/misc.cc (ClassWithEnum): Move past Foo definitions.
	(enums2): New marker function.
	(enums1): New function.
	(main): Call enums1().  Move enum tests to enums1().
@
text
@d430 12
d529 12
d562 2
@


1.2
log
@New tests, fix old tests, make more tests work
@
text
@a395 7
class ClassWithEnum {
public:
  enum PrivEnum { red, green, blue, yellow = 42 };
  PrivEnum priv_enum;
  int x;
};

d407 23
d528 1
a537 6

  /* Class with enumeration inside it */ 
  ClassWithEnum obj_with_enum;
  obj_with_enum.priv_enum = ClassWithEnum::red;
  obj_with_enum.x = 0;
  obj_with_enum.priv_enum = ClassWithEnum::green;
@


1.1
log
@Initial revision
@
text
@d3 4
d218 10
d494 8
d509 1
d524 2
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@a500 2
  obj_with_enum.priv_enum = ClassWithEnum::red;
  obj_with_enum.x = 0;
@


1.1.1.3
log
@import gdb-1999-08-02 snapshot
@
text
@a2 4
// ====================== basic C++ types  =======================
bool            v_bool;
bool            v_bool_array[2];

a479 8
void dummy()
{
  v_bool = true;
  v_bool_array[0] = false;
  v_bool_array[1] = v_bool;
}


a486 1
  dummy();
@


