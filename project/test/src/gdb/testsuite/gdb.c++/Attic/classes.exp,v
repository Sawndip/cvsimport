head	1.18;
access;
symbols
	cagney_x86i386-20030821-branch:1.17.0.30
	cagney_x86i386-20030821-branchpoint:1.17
	carlton_dictionary-20030805-merge:1.17
	carlton_dictionary-20030627-merge:1.17
	gdb_6_0-branch:1.17.0.28
	gdb_6_0-2003-06-23-branchpoint:1.17
	jimb-ppc64-linux-20030613-branch:1.17.0.26
	jimb-ppc64-linux-20030613-branchpoint:1.17
	cagney_writestrings-20030508-branch:1.17.0.24
	cagney_writestrings-20030508-branchpoint:1.17
	jimb-ppc64-linux-20030528-branch:1.17.0.22
	jimb-ppc64-linux-20030528-branchpoint:1.17
	carlton_dictionary-20030523-merge:1.17
	cagney_fileio-20030521-branch:1.17.0.20
	cagney_fileio-20030521-branchpoint:1.17
	kettenis_i386newframe-20030517-mergepoint:1.17
	jimb-ppc64-linux-20030509-branch:1.17.0.18
	jimb-ppc64-linux-20030509-branchpoint:1.17
	kettenis_i386newframe-20030504-mergepoint:1.17
	carlton_dictionary-20030430-merge:1.17
	kettenis_i386newframe-20030419-branch:1.17.0.16
	kettenis_i386newframe-20030419-branchpoint:1.17
	carlton_dictionary-20030416-merge:1.17
	cagney_frameaddr-20030409-mergepoint:1.17
	kettenis_i386newframe-20030406-branch:1.17.0.14
	kettenis_i386newframe-20030406-branchpoint:1.17
	cagney_frameaddr-20030403-branchpoint:1.17
	cagney_frameaddr-20030403-branch:1.17.0.12
	cagney_framebase-20030330-mergepoint:1.17
	cagney_framebase-20030326-branch:1.17.0.10
	cagney_framebase-20030326-branchpoint:1.17
	cagney_lazyid-20030317-branch:1.17.0.8
	cagney_lazyid-20030317-branchpoint:1.17
	kettenis-i386newframe-20030316-mergepoint:1.17
	offbyone-20030313-branch:1.17.0.6
	offbyone-20030313-branchpoint:1.17
	kettenis-i386newframe-20030308-branch:1.17.0.4
	kettenis-i386newframe-20030308-branchpoint:1.17
	carlton_dictionary-20030305-merge:1.17
	cagney_offbyone-20030303-branch:1.17.0.2
	cagney_offbyone-20030303-branchpoint:1.17
	carlton_dictionary-20030207-merge:1.13
	interps-20030203-mergepoint:1.13
	interps-20030202-branch:1.13.0.20
	interps-20030202-branchpoint:1.13
	cagney-unwind-20030108-branch:1.13.0.18
	cagney-unwind-20030108-branchpoint:1.13
	carlton_dictionary-20021223-merge:1.13
	gdb_5_3-2002-12-12-release:1.13
	carlton_dictionary-20021115-merge:1.13
	kseitz_interps-20021105-merge:1.13
	kseitz_interps-20021103-merge:1.13
	drow-cplus-merge-20021020:1.13
	drow-cplus-merge-20021025:1.13
	carlton_dictionary-20021025-merge:1.13
	carlton_dictionary-20021011-merge:1.13
	drow-cplus-branch:1.13.0.16
	drow-cplus-branchpoint:1.13
	kseitz_interps-20020930-merge:1.13
	carlton_dictionary-20020927-merge:1.13
	carlton_dictionary-branch:1.13.0.14
	carlton_dictionary-20020920-branchpoint:1.13
	gdb_5_3-branch:1.13.0.12
	gdb_5_3-2002-09-04-branchpoint:1.13
	kseitz_interps-20020829-merge:1.13
	cagney_sysregs-20020825-branch:1.13.0.10
	cagney_sysregs-20020825-branchpoint:1.13
	readline_4_3-import-branch:1.13.0.8
	readline_4_3-import-branchpoint:1.13
	gdb_5_2_1-2002-07-23-release:1.12
	kseitz_interps-20020528-branch:1.13.0.6
	kseitz_interps-20020528-branchpoint:1.13
	cagney_regbuf-20020515-branch:1.13.0.4
	cagney_regbuf-20020515-branchpoint:1.13
	jimb-macro-020506-branch:1.13.0.2
	jimb-macro-020506-branchpoint:1.13
	gdb_5_2-2002-04-29-release:1.12
	gdb_5_2-branch:1.12.0.2
	gdb_5_2-2002-03-03-branchpoint:1.12
	gdb_5_1_1-2002-01-24-release:1.8
	gdb_5_1_0_1-2002-01-03-release:1.8
	cygnus_cvs_20020108_pre:1.10
	gdb_5_1_0_1-2002-01-03-branch:1.8.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.8
	gdb_5_1-2001-11-21-release:1.8
	gdb_s390-2001-09-26-branch:1.8.0.6
	gdb_s390-2001-09-26-branchpoint:1.8
	gdb_5_1-2001-07-29-branch:1.8.0.4
	gdb_5_1-2001-07-29-branchpoint:1.8
	dberlin-typesystem-branch:1.8.0.2
	dberlin-typesystem-branchpoint:1.8
	gdb-post-ptid_t-2001-05-03:1.7
	gdb-pre-ptid_t-2001-05-03:1.7
	insight-precleanup-2001-01-01:1.4
	gdb-post-protoization-2000-07-29:1.3
	gdb-pre-protoization-2000-07-29:1.3
	gdb-premipsmulti-2000-06-06-branch:1.1.1.6.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.6
	gdb-post-params-removal-2000-06-04:1.1.1.6
	gdb-pre-params-removal-2000-06-04:1.1.1.6
	gdb-post-params-removal-2000-05-28:1.1.1.6
	gdb-pre-params-removal-2000-05-28:1.1.1.6
	gdb_5_0-2000-05-19-release:1.1.1.6
	gdb_4_18_2-2000-05-18-release:1.1.1.6
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.6
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.6
	gdb_5_0-2000-04-10-branch:1.1.1.6.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.6
	repo-unification-2000-02-06:1.1.1.6
	insight-2000-02-04:1.1.1.6
	gdb-2000-02-04:1.1.1.6
	gdb-2000-02-02:1.1.1.6
	gdb-2000-02-01:1.1.1.6
	gdb-2000-01-31:1.1.1.6
	gdb-2000-01-26:1.1.1.6
	gdb-2000-01-24:1.1.1.6
	gdb-2000-01-17:1.1.1.6
	gdb-2000-01-10:1.1.1.6
	gdb-2000-01-05:1.1.1.6
	gdb-1999-12-21:1.1.1.6
	gdb-1999-12-13:1.1.1.6
	gdb-1999-12-07:1.1.1.6
	gdb-1999-12-06:1.1.1.6
	gdb-1999-11-16:1.1.1.5
	gdb-1999-11-08:1.1.1.5
	gdb-1999-11-01:1.1.1.5
	gdb-1999-10-25:1.1.1.5
	gdb-1999-10-18:1.1.1.5
	gdb-1999-10-11:1.1.1.5
	gdb-1999-10-04:1.1.1.5
	gdb-1999-09-28:1.1.1.5
	gdb-1999-09-21:1.1.1.5
	gdb-1999-09-13:1.1.1.5
	gdb-1999-09-08:1.1.1.5
	gdb-1999-08-30:1.1.1.4
	gdb-1999-08-23:1.1.1.3
	gdb-1999-08-16:1.1.1.3
	gdb-1999-08-09:1.1.1.3
	gdb-1999-08-02:1.1.1.3
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.18
date	2003.08.23.03.55.59;	author chastain;	state dead;
branches;
next	1.17;

1.17
date	2003.03.03.18.48.31;	author carlton;	state Exp;
branches
	1.17.28.1;
next	1.16;

1.16
date	2003.02.28.17.59.18;	author carlton;	state Exp;
branches;
next	1.15;

1.15
date	2003.02.28.17.51.35;	author carlton;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.13.21.33.20;	author chastain;	state Exp;
branches;
next	1.13;

1.13
date	2002.04.03.01.35.23;	author drow;	state Exp;
branches
	1.13.14.1
	1.13.16.1;
next	1.12;

1.12
date	2002.01.20.19.22.13;	author drow;	state Exp;
branches;
next	1.11;

1.11
date	2002.01.10.20.46.16;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.07.22.02.23;	author drow;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.07.21.58.19;	author drow;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.03.19.52.46;	author msnyder;	state Exp;
branches;
next	1.7;

1.7
date	2001.04.24.17.39.14;	author jimb;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.06.08.21.52;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.18.19.59.57;	author chastain;	state Exp;
branches;
next	1.4;

1.4
date	2000.08.02.22.10.10;	author guo;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.09.05.16.11;	author nsd;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.09.05.10.13;	author nsd;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.32;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.32;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.27.20;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.08.02.23.46.52;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.08.31.01.08.40;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.09.09.00.00.27;	author shebs;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.12.07.03.56.17;	author jsm;	state Exp;
branches;
next	;

1.13.14.1
date	2003.03.06.00.56.36;	author carlton;	state Exp;
branches;
next	1.13.14.2;

1.13.14.2
date	2003.08.30.03.40.33;	author chastain;	state dead;
branches;
next	;

1.13.16.1
date	2003.12.14.20.27.50;	author drow;	state dead;
branches;
next	;

1.17.28.1
date	2003.08.25.03.53.47;	author chastain;	state dead;
branches;
next	;


desc
@@


1.18
log
@2003-08-22  Michael Chastain  <mec@@shout.net>

	* gdb.cp: New directory.
	* gdb.cp/*: Copy from gdb.c++/*.
	* gdb.c++/*: Remove.
	* Makefile.in: Change gdb.c++ to gdb.cp.
	* configure.in:  Ditto.
	* configure: Regnerate.
@
text
@# Copyright 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
# 2003 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@@prep.ai.mit.edu

# This file was written by Fred Fish. (fnf@@cygnus.com)

set ws "\[\r\n\t \]+"
set nl "\[\r\n\]+"

if $tracelevel then {
	strace $tracelevel
}

if { [skip_cplus_tests] } { continue }

set testfile "misc"
set srcfile ${testfile}.cc
set binfile ${objdir}/${subdir}/${testfile}

# Create and source the file that provides information about the compiler
# used to compile the test case.

if [get_compiler_info ${binfile} "c++"] {
    return -1
}

if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug c++}] != "" } {
     gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
}

#
# Test ptype of class objects.
#

proc test_ptype_class_objects {} {
    global gdb_prompt
    global ws
    global nl

    # Note that struct members are public by default, so we don't print
    # "public:" for the public members of structs.
    # Accept it if gdb just fails to distinguish between
    # class and struct, and everything else is OK.

    send_gdb "ptype struct default_public_struct\n"
    gdb_expect {
	-re "type = struct default_public_struct \{${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    pass "ptype struct default_public_struct"
	}
	-re "type = class default_public_struct \{$nl.*int a;${ws}int b;$nl.*\}$nl$gdb_prompt $" {
	    pass "ptype struct default_public_struct"
	}
	-re ".*$gdb_prompt $" { fail "ptype struct default_public_struct" }
	timeout { fail "ptype struct default_public_struct (timeout)" ; return }
    }

    # Note that struct members are public by default, so we don't print
    # "public:" for the public members of structs.
    # Accept it if gdb just fails to distinguish between
    # class and struct, and everything else is OK.

    send_gdb "ptype struct explicit_public_struct\n"
    gdb_expect {
	-re "type = struct explicit_public_struct \{${ws}int a;${ws}int b;$nl.*\}$nl$gdb_prompt $" {
	    pass "ptype struct explicit_public_struct"
	}
	-re "type = class explicit_public_struct \{$nl.*int a;${ws}int b;$nl.*\}$nl$gdb_prompt $" {
	    pass "ptype struct explicit_public_struct"
	}
	-re ".*$gdb_prompt $" { fail "ptype struct explicit_public_struct" }
	timeout { fail "ptype struct explicit_public_struct (timeout)" ; return }
    }

    # Accept it if gdb just fails to distinguish between
    # class and struct, and everything else is OK.

    send_gdb "ptype struct protected_struct\n"
    gdb_expect {
	-re "type = struct protected_struct \{${ws}protected:${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    pass "ptype struct protected_struct"
	}
	-re "type = class protected_struct \{${ws}protected:${ws}int a;${ws}int b;$nl.*\}$nl$gdb_prompt $" {
	    pass "ptype struct protected_struct"
	}
	-re ".*$gdb_prompt $" { fail "ptype struct protected_struct" }
	timeout { fail "ptype struct protected_struct (timeout)" ; return }
    }

    # Accept it if gdb just fails to distinguish between
    # class and struct, and everything else is OK.

    send_gdb "ptype struct private_struct\n"
    gdb_expect {
	-re "type = struct private_struct \{${ws}private:${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    pass "ptype struct private_struct"
	}
	-re "type = class private_struct \{${ws}private:${ws}int a;${ws}int b;$nl.*\}$nl$gdb_prompt $" { 
	    pass "ptype struct private_struct"
	}
	-re ".*$gdb_prompt $" { fail "ptype struct private_struct" }
	timeout { fail "ptype struct private_struct (timeout)" ; return }
    }

    # Accept it if gdb just fails to distinguish between
    # class and struct, and everything else is OK.

    send_gdb "ptype struct mixed_protection_struct\n"
    gdb_expect {
	-re "type = struct mixed_protection_struct \{${ws}int a;${ws}int b;${ws}private:${ws}int c;${ws}int d;${ws}protected:${ws}int e;${ws}int f;${ws}public:${ws}int g;${ws}private:${ws}int h;${ws}protected:${ws}int i;$nl\}$nl$gdb_prompt $" {
	    pass "ptype struct mixed_protection_struct"
	}
        -re "type = struct mixed_protection_struct \{${ws}public:${ws}int a;${ws}int b;${ws}private:${ws}int c;${ws}int d;${ws}protected:${ws}int e;${ws}int f;${ws}public:${ws}int g;${ws}private:${ws}int h;${ws}protected:${ws}int i;$nl.*\}$nl$gdb_prompt $" {
            pass "ptype struct mixed_protection_struct (extra public)"
        }
	-re "type = class mixed_protection_struct \{${ws}public:${ws}int a;${ws}int b;${ws}private:${ws}int c;${ws}int d;${ws}protected:${ws}int e;${ws}int f;${ws}public:${ws}int g;${ws}private:${ws}int h;${ws}protected:${ws}int i;$nl.*\}$nl$gdb_prompt $" {
	    pass "ptype struct mixed_protection_struct"
	}
	-re ".*$gdb_prompt $" { fail "ptype struct mixed_protection_struct" }
	timeout { fail "ptype struct mixed_protection_struct (timeout)" ; return }
    }

    # Accept it if gdb just fails to distinguish between
    # class and struct, and everything else is OK.

    send_gdb "ptype class public_class\n"
    gdb_expect {
	-re "type = class public_class \{${ws}public:${ws}int a;${ws}int b;$nl.*\}$nl$gdb_prompt $" {
	    pass "ptype class public_class"
	}
	-re "type = struct public_class \{${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    pass "ptype class public_class"
	}
	-re ".*$gdb_prompt $" { fail "ptype class public_class" }
	timeout { fail "ptype class public_class (timeout)" ; return }
    }

    send_gdb "ptype class protected_class\n"
    gdb_expect {
	-re "type = class protected_class \{${ws}protected:${ws}int a;${ws}int b;$nl.*\}$nl$gdb_prompt $" {
	    pass "ptype class protected_class"
	}
	-re "type = struct protected_class \{${ws}int a;${ws}int b;$nl\}$nl$gdb_prompt $" {
	    fail "ptype class protected_class"
	}
	-re ".*$gdb_prompt $" { fail "ptype class protected_class" }
	timeout { fail "ptype class protected_class (timeout)" ; return }
    }

    # Accept it if gdb just emits a superflous "private:"
    # attribute, since classes default to private and for consistency with
    # structs (where we don't print the "public:" attribute) we don't print
    # the "private:" attribute.

    send_gdb "ptype class default_private_class\n"
    gdb_expect {
	-re "type = class default_private_class \{${ws}int a;${ws}int b;$nl.*\}$nl$gdb_prompt $" {
	    pass "ptype class default_private_class"
	}
	-re "type = class default_private_class \{${ws}private:${ws}int a;${ws}int b;$nl.*\}$nl$gdb_prompt $" {
	    pass "ptype class default_private_class"
	}
	-re ".*$gdb_prompt $" { fail "ptype class default_private_class" }
	timeout { fail "ptype class default_private_class (timeout)" ; return }
    }

    send_gdb "ptype class explicit_private_class\n"
    gdb_expect {
	-re "type = class explicit_private_class \{${ws}private:${ws}int a;${ws}int b;$nl.*\}$nl$gdb_prompt $" {
	    pass "ptype class explicit_private_class"
	}
        -re "type = class explicit_private_class \{${ws}int a;${ws}int b;$nl.*\}$nl$gdb_prompt $" {
            pass "ptype class explicit_private_class"
        }
	-re "type = struct explicit_private_class \{${ws}int a;${ws}int b;$nl.*\}$nl$gdb_prompt $" {
	    fail "ptype class explicit_private_class"
	}
	-re ".*$gdb_prompt $" { fail "ptype class explicit_private_class" }
	timeout { fail "ptype class explicit_private_class (timeout)" ; return }
    }

    send_gdb "ptype class mixed_protection_class\n"
    gdb_expect {
	-re "type = class mixed_protection_class \{${ws}public:${ws}int a;${ws}int b;${ws}private:${ws}int c;${ws}int d;${ws}protected:${ws}int e;${ws}int f;${ws}public:${ws}int g;${ws}private:${ws}int h;${ws}protected:${ws}int i;$nl.*\}$nl$gdb_prompt $" {
	    pass "ptype class mixed_protection_class"
	}
	-re "type = struct mixed_protection_class \{${ws}int a;${ws}int b;${ws}int c;${ws}int d;${ws}int e;${ws}int f;${ws}int g;${ws}int h;${ws}int i;$nl.*\}$nl$gdb_prompt $" {
	    fail "ptype class mixed_protection_class"
	}
	-re ".*$gdb_prompt $" { fail "ptype class mixed_protection_class" }
	timeout { fail "ptype class mixed_protection_class (timeout)" ; return }
    }

    # This class does not use any C++-specific features, so it's fine for
    # it to print as "struct".
    send_gdb "ptype class A\n"
    gdb_expect {
	-re "type = (class|struct) A \{(${ws}public:|)${ws}int a;${ws}int x;((${ws}A & operator=\\(A const ?&\\);)|(${ws}A\\((A const|const A) ?&\\);)|(${ws}A\\((void|)\\);))*${ws}\}$nl$gdb_prompt $" {
	    pass "ptype class A"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype class A"
	}
	timeout {
	    fail "ptype class A (timeout)"
	    return
	}
    }

    send_gdb "ptype class B\n"
    gdb_expect {
	-re "type = class B : public A \{${ws}public:${ws}int b;${ws}int x;${ws}B & operator=\\(B const ?&\\);${ws}B\\((B const|const B) ?&\\);${ws}B\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype class B"
	}
	-re "type = class B : public A \{${ws}public:${ws}int b;${ws}int x;((${ws}B & operator=\\(B const ?&\\);)|(${ws}B\\(B const ?&\\);)|(${ws}B\\((void|)\\);))*${ws}\}$nl$gdb_prompt $" {
	    pass "ptype class B (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype class B"
	}
	timeout {
	    fail "ptype class B (timeout)"
	    return
	}
    }

    send_gdb "ptype class C\n"
    gdb_expect {
	-re "type = class C : public A \{${ws}public:${ws}int c;${ws}int x;${ws}C & operator=\\(C const ?&\\);${ws}C\\((C const|const C) ?&\\);${ws}C\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype class C"
	}
	-re "type = class C : public A \{${ws}public:${ws}int c;${ws}int x;((${ws}C & operator=\\(C const ?&\\);)|(${ws}C\\(C const ?&\\);)|(${ws}C\\((void|)\\);))*${ws}\}$nl$gdb_prompt $" {
	    pass "ptype class C (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype class C"
	}
	timeout {
	    fail "ptype class C (timeout)"
	    return
	}
    }

    send_gdb "ptype class D\n"
    gdb_expect {
	-re "type = class D : public B, public C \{${ws}public:${ws}int d;${ws}int x;${ws}D & operator=\\(D const ?&\\);${ws}D\\((D const|const D) ?&\\);${ws}D\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype class D"
	}
	-re "type = class D : public B, public C \{${ws}public:${ws}int d;${ws}int x;((${ws}D & operator=\\(D const ?&\\);)|(${ws}D\\(D const ?&\\);)|(${ws}D\\((void|)\\);))*${ws}\}$nl$gdb_prompt $" {
	    pass "ptype class D (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype class D"
	}
	timeout {
	    fail "ptype class D (timeout)"
	    return
	}
    }

    send_gdb "ptype class E\n"
    gdb_expect {
	-re "type = class E : public D \{${ws}public:${ws}int e;${ws}int x;${ws}E & operator=\\(E const ?&\\);${ws}E\\((E const|const E) ?&\\);${ws}E\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype class E"
	}
	-re "type = class E : public D \{${ws}public:${ws}int e;${ws}int x;((${ws}E & operator=\\(E const ?&\\);)|(${ws}E\\((E const|const E) ?&\\);)|(${ws}E\\((void|)\\);))*${ws}\}$nl$gdb_prompt $" {
	    pass "ptype class E"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype class E"
	}
	timeout {
	    fail "ptype class E (timeout)"
	    return
	}
    }

    # With g++ 2.x and stabs debug info, we misinterpret static methods
    # whose name matches their argument mangling.
    send_gdb "ptype class Static\n"
    gdb_expect {
	-re "type = (class|struct) Static \{(${ws}public:|)${ws}Static & operator=\\(Static const ?&\\);${ws}Static\\((Static const|const Static) ?&\\);${ws}Static\\((void|)\\);${ws}static void ii\\(int, int\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype class Static"
	}
	-re "type = (class|struct) Static \{(${ws}public:|)${ws}static void ii\\(int, int\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype class Static"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype class Static"
	}
	timeout {
	    fail "ptype class Static (timeout)"
	    return
	}
    }

    send_gdb "ptype class vA\n"
    gdb_expect {
	-re "type = (class|struct) vA \{(${ws}public:|)${ws}int va;${ws}int vx;${ws}\}$nl$gdb_prompt $" {
	    pass "ptype class vA"
	}
	-re "type = (class|struct) vA \{(${ws}public:|)${ws}int va;${ws}int vx;${ws}vA & operator=\\(vA const ?&\\);${ws}vA\\((vA const|const vA) ?&\\);${ws}vA\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype class vA"
	}
	-re "type = (class|struct) vA \{(${ws}public:|)${ws}int va;${ws}int vx;((${ws}vA & operator=\\(vA const ?&\\);)|(${ws}vA\\(vA const ?&\\);)|(${ws}vA\\((void|)\\);))*${ws}\}$nl$gdb_prompt $" {
	    pass "ptype class vA (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype class vA"
	}
	timeout {
	    fail "ptype class vA (timeout)"
	    return
	}
    }

    # Accept the form with embedded GNU style mangled virtual table constructs
    # for now, but with a FIXME.  At some future point, gdb should use a
    # portable representation for the virtual table constructs.

    # The format of a g++ virtual base pointer.
    set vbptr "(_vb\[$.\]|__vb_)\[0-9\]?"

    send_gdb "ptype class vB\n"
    gdb_expect {
	-re "type = class vB : public virtual vA \{${ws}public:${ws}int vb;${ws}int vx;${ws}vB & operator=\\(vB const ?&\\);${ws}vB\\((vB const|const vB) ?&\\);${ws}vB\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype class vB"
	}
	-re "type = class vB : public virtual vA \{${ws}private:${ws}vA \\*${vbptr}vA;${ws}public:${ws}int vb;${ws}int vx;${ws}vB & operator=\\(vB const ?&\\);${ws}vB\\(int, vB const ?&\\);${ws}vB\\(int\\);${ws}\}$nl$gdb_prompt $" {
	    setup_xfail "*-*-*"
	    fail "ptype class vB (FIXME: non-portable virtual table constructs)"
	}
        -re "type = class vB : public virtual vA \{${ws}public:${ws}int vb;${ws}int vx;${ws}\}$nl$gdb_prompt $" {
            pass "ptype class vB"
        }
	-re "type = class vB : public virtual vA \{${ws}private:${ws}vA \\*_vb.vA;${ws}public:${ws}int vb;${ws}int vx;((${ws}vB & operator=\\(vB const ?&\\);)|(${ws}vB\\(int, vB const ?&\\);)|(${ws}vB\\(int\\);))*${ws}\}$nl$gdb_prompt $" {
	    setup_xfail "*-*-*"
	    fail "ptype class vB (FIXME) (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype class vB"
	}
	timeout {
	    fail "ptype class vB (timeout)"
	    return
	}
    }

    # Accept the form with embedded GNU style mangled virtual table constructs
    # for now, but with a FIXME.  At some future point, gdb should use a
    # portable representation for the virtual table constructs.

    send_gdb "ptype class vC\n"
    gdb_expect {
	-re "type = class vC : public virtual vA \{${ws}public:${ws}int vc;${ws}int vx;${ws}vC & operator=\\(vC const ?&\\);${ws}vC\\((vC const|const vC) ?&\\);${ws}vC\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype class vC"
	}
	-re "type = class vC : public virtual vA \{${ws}private:${ws}vA \\*${vbptr}vA;${ws}public:${ws}int vc;${ws}int vx;${ws}vC & operator=\\(vC const ?&\\);${ws}vC\\(int, vC const ?&\\);${ws}vC\\(int\\);${ws}\}$nl$gdb_prompt $" {
	    setup_xfail "*-*-*"
	    fail "ptype class vC (FIXME: non-portable virtual table constructs)"
	}
        -re "type = class vC : public virtual vA \{${ws}public:${ws}int vc;${ws}int vx;${ws}\}$nl$gdb_prompt $" {
            pass "ptype class vC"
        }
	-re "type = class vC : public virtual vA \{${ws}private:${ws}vA \\*_vb.vA;${ws}public:${ws}int vc;${ws}int vx;((${ws}vC & operator=\\(vC const ?&\\);)|(${ws}vC\\(int, vC const ?&\\);)|(${ws}vC\\(int\\);))*${ws}\}$nl$gdb_prompt $" {
	    setup_xfail "*-*-*"
	    fail "ptype class vC (FIXME) (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype class vC"
	}
	timeout {
	    fail "ptype class vC (timeout)"
	    return
	}
    }

    # Accept the form with embedded GNU style mangled virtual table constructs
    # for now, but with a FIXME.  At some future point, gdb should use a
    # portable representation for the virtual table constructs.

    send_gdb "ptype class vD\n"
    gdb_expect {
	-re "type = class vD : public virtual vB, public virtual vC \{${ws}public:${ws}int vd;${ws}int vx;${ws}vD & operator=\\(vD const ?&\\);${ws}vD\\((vD const|const vD) ?&\\);${ws}vD\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype class vD"
	}
	-re "type = class vD : public virtual vB, public virtual vC \{${ws}private:${ws}vC \\*${vbptr}vC;${ws}vB \\*${vbptr}vB;${ws}public:${ws}int vd;${ws}int vx;${ws}vD & operator=\\(vD const ?&\\);${ws}vD\\(int, vD const ?&\\);${ws}vD\\(int\\);${ws}\}$nl$gdb_prompt $" {
	    setup_xfail "*-*-*"
	    fail "ptype class vD (FIXME: non-portable virtual table constructs)"
	}
        -re "type = class vD : public virtual vB, public virtual vC \{${ws}public:${ws}int vd;${ws}int vx;${ws}\}$nl$gdb_prompt $" {
            pass "ptype class vD"
        }
	-re "type = class vD : public virtual vB, public virtual vC \{${ws}private:${ws}vC \\*_vb.vC;${ws}vB \\*_vb.vB;${ws}public:${ws}int vd;${ws}int vx;((${ws}vD & operator=\\(vD const ?&\\);)|(${ws}vD\\(int, vD const ?&\\);)|(${ws}vD\\(int\\);))*${ws}\}$nl$gdb_prompt $" {
	    setup_xfail "*-*-*"
	    fail "ptype class vD (FIXME) (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype class vD"
	}
	timeout {
	    fail "ptype class vD (timeout)"
	    return
	}
    }

    # Accept the form with embedded GNU style mangled virtual table constructs
    # for now, but with a FIXME.  At some future point, gdb should use a
    # portable representation for the virtual table constructs.

    send_gdb "ptype class vE\n"
    gdb_expect {
	-re "type = class vE : public virtual vD \{${ws}public:${ws}int ve;${ws}int vx;${ws}vE & operator=\\(vE const ?&\\);${ws}vE\\((vE const|const vE) ?&\\);${ws}vE\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype class vE"
	}
	-re "type = class vE : public virtual vD \{${ws}private:${ws}vD \\*${vbptr}vD;${ws}public:${ws}int ve;${ws}int vx;${ws}vE & operator=\\(vE const ?&\\);${ws}vE\\(int, vE const ?&\\);${ws}vE\\(int\\);${ws}\}$nl$gdb_prompt $" {
	    setup_xfail "*-*-*"
	    fail "ptype class vE (FIXME: non-portable virtual table constructs)"
	}
        -re "type = class vE : public virtual vD \{${ws}public:${ws}int ve;${ws}int vx;${ws}\}$nl$gdb_prompt $" {
            pass "ptype class vE"
        }
	-re "type = class vE : public virtual vD \{${ws}private:${ws}vD \\*_vb.vD;${ws}public:${ws}int ve;${ws}int vx;((${ws}vE & operator=\\(vE const ?&\\);)|(${ws}vE\\(int, vE const ?&\\);)|(${ws}vE\\(int\\);))*${ws}\}$nl$gdb_prompt $" {
	    setup_xfail "*-*-*"
	    fail "ptype class vE (FIXME) (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype class vE"
	}
	timeout {
	    fail "ptype class vE (timeout)"
	    return
	}
    }

    send_gdb "ptype class Base1\n"
    gdb_expect {
	-re "type = class Base1 \{${ws}public:${ws}int x;${ws}Base1 & operator=\\(Base1 const ?&\\);${ws}Base1\\(((Base1 const)|(const Base1)) ?&\\);${ws}Base1\\(int\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype class Base1"
	}
	-re "type = class Base1 \{${ws}public:${ws}int x;${ws}Base1\\(int\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype class Base1"
	}
	-re "type = class Base1 \{${ws}public:${ws}int x;((${ws}Base1 & operator=\\(Base1 const ?&\\);)|(${ws}Base1\\(Base1 const ?&\\);)|(${ws}Base1\\(int\\);))*${ws}\}$nl$gdb_prompt $" {
	    pass "ptype class Base1 (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype class Base1"
	}
	timeout {
	    fail "ptype class Base1 (timeout)"
	    return
	}
    }

    send_gdb "ptype class Foo\n"
    gdb_expect {
        -re "type = class Foo \{${ws}public:${ws}int x;${ws}int y;${ws}static int st;\r\n${ws}Foo\\(int, int\\);${ws}int operator!\\((void|)\\);${ws}operator int\\((void|)\\);${ws}int times\\(int\\);$nl\}$nl$gdb_prompt $" {
            pass "ptype class Foo"
        }
	-re "type = class Foo \{${ws}public:${ws}int x;${ws}int y;${ws}static int st;${ws}Foo & operator=\\(Foo const ?&\\);${ws}Foo\\((Foo const|const Foo) ?&\\);${ws}Foo\\(int, int\\);${ws}int operator!\\((void|)\\);${ws}operator int\\((void|)\\);${ws}int times\\(int\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype class Foo"
	}
	-re "type = class Foo \{${ws}public:${ws}int x;${ws}int y;${ws}static int st;((${ws}Foo & operator=\\(Foo const ?&\\);)|(${ws}Foo\\(Foo const ?&\\);)|(${ws}Foo\\(int, int\\);)|(${ws}int operator!\\((void|)\\);)|(${ws}int operator int\\((void|)\\);)|(${ws}int times\\(int\\);))*${ws}\}$nl$gdb_prompt $" {
	    pass "ptype class Foo (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype class Foo"
	}
	timeout {
	    fail "ptype class Foo (timeout)"
	    return
	}
    }

    send_gdb "ptype class Bar\n"
    gdb_expect {
	-re "type = class Bar : public Base1, public Foo \{${ws}public:${ws}int z;${ws}Bar & operator=\\(Bar const ?&\\);${ws}Bar\\((Bar const|const Bar) ?&\\);${ws}Bar\\(int, int, int\\);${ws}\}$nl$gdb_prompt $" {
	    pass "ptype class Bar"
	}
	-re "type = class Bar : public Base1, public Foo \{${ws}public:${ws}int z;((${ws}Bar & operator=\\(Bar const ?&\\);)|(${ws}Bar\\(Bar const ?&\\);)|(${ws}Bar\\(int, int, int\\);))*${ws}\}$nl$gdb_prompt $" {
	    pass "ptype class Bar (obsolescent gcc or gdb)"
	}
	-re ".*$gdb_prompt $" {
	    fail "ptype class Bar"
	}
	timeout {
	    fail "ptype class Bar (timeout)"
	    return
	}
    }
}

#
# Test simple access to class members.
#

proc test_non_inherited_member_access {} {
    global gdb_prompt
    
    # Print non-inherited members of g_A.

    gdb_test "print g_A.a" ".* = 1" "g_A.a incorrect"

    gdb_test "print g_A.x" ".* = 2" "g_A.x incorrect"

    # Print non-inherited members of g_B.

    gdb_test "print g_B.b" ".* = 5" "g_B.b incorrect"

    gdb_test "print g_B.x" ".* = 6" "g_B.x incorrect"

    # Print non-inherited members of g_C.

    gdb_test "print g_C.c" ".* = 9" "g_C.c incorrect"

    gdb_test "print g_C.x" ".* = 10" "g_C.x incorrect"

    # Print non-inherited members of g_D.

    gdb_test "print g_D.d" ".* = 19" "g_D.d incorrect"

    gdb_test "print g_D.x" ".* = 20" "g_D.x incorrect"

    # Print non-inherited members of g_E.

    gdb_test "print g_E.e" ".* = 31" "g_E.e incorrect"

    gdb_test "print g_E.x" ".* = 32" "g_E.x incorrect"
}

#
# Try access to non-members that are members of another class.
# Should give errors.
#

proc test_wrong_class_members {} {
    global gdb_prompt

    gdb_test "print g_A.b" "There is no member( or method|) named b." "print g_A.b should be error"

    gdb_test "print g_B.c" "There is no member( or method|) named c." "print g_B.c should be error"

    gdb_test "print g_B.d" "There is no member( or method|) named d." "print g_B.d should be error"

    gdb_test "print g_C.b" "There is no member( or method|) named b." "print g_C.b should be error"

    gdb_test "print g_C.d" "There is no member( or method|) named d." "print g_C.d should be error"

    gdb_test "print g_D.e" "There is no member( or method|) named e." "print g_D.e should be error"
}

#
# Try access to non-members that are not members of any class.
# Should give errors.
#

proc test_nonexistent_members {} {
    global gdb_prompt

    gdb_test "print g_A.y" "There is no member( or method|) named y." "print g_A.y should be error"

    gdb_test "print g_B.z" "There is no member( or method|) named z." "print g_B.z should be error"

    gdb_test "print g_C.q" "There is no member( or method|) named q." "print g_C.q should be error"

    gdb_test "print g_D.p" "There is no member( or method|) named p." "print g_D.p should be error"
}

#
# Call a method that expects a base class parameter with base, inherited,
# and unrelated class arguments.
#

proc test_method_param_class {} {
    gdb_test "call class_param.Aptr_a (&g_A)" ".* = 1" "base class param->a"
    gdb_test "call class_param.Aptr_x (&g_A)" ".* = 2" "base class param->x"
    gdb_test "call class_param.Aptr_a (&g_B)" ".* = 3" "inherited class param->a"
    gdb_test "call class_param.Aptr_x (&g_B)" ".* = 4" "inherited class param->x"
    gdb_test "call class_param.Aref_a (g_A)" ".* = 1" "base class (&param)->a"
    gdb_test "call class_param.Aref_x (g_A)" ".* = 2" "base class (&param)->x"
    gdb_test "call class_param.Aref_a (g_B)" ".* = 3" "inherited class (&param)->a"
    gdb_test "call class_param.Aref_x (g_B)" ".* = 4" "inherited class (&param)->x"
    gdb_test "call class_param.Aval_a (g_A)" ".* = 1" "base class param.a"
    gdb_test "call class_param.Aval_x (g_A)" ".* = 2" "base class param.x"
    gdb_test "call class_param.Aval_a (g_B)" ".* = 3" "inherited class param.a"
    gdb_test "call class_param.Aval_x (g_B)" ".* = 4" "inherited class param.x"

    gdb_test "call class_param.Aptr_a (&foo)" "Cannot resolve .*" "unrelated class *param"
    gdb_test "call class_param.Aref_a (foo)" "Cannot resolve .*" "unrelated class &param"
    gdb_test "call class_param.Aval_a (foo)" "Cannot resolve .*" "unrelated class param"
}

#
# Examine a class with an enum field.
#

proc test_enums {} {
    global gdb_prompt
    global hp_aCC_compiler

    # print the object
    send_gdb "print obj_with_enum\n"
    gdb_expect {
	-re "\\$\[0-9\]* = \\{priv_enum = red, x = 0\\}.*$gdb_prompt $" { pass "print obj_with_enum (1)" }
	-re "$gdb_prompt $"                     { fail "print obj_with_enum (1)" }
	timeout                             { fail "(timeout) print obj_with_enum (1)" }
    }

    send_gdb "next\n"
    gdb_expect {
	-re "$gdb_prompt $"                     { pass "next" }
	timeout                             { fail "(timeout) next" }
    }

    # print the object again
    send_gdb "print obj_with_enum\n"
    gdb_expect {
	-re "\\$\[0-9\]* = \\{priv_enum = green, x = 0\\}.*$gdb_prompt $" { pass "print obj_with_enum (2)" }
	-re "$gdb_prompt $"                     { fail "print obj_with_enum (2)" }
	timeout                             { fail "(timeout) print obj_with_enum (2)" }
    }

    # print out the enum member
    send_gdb "print obj_with_enum.priv_enum\n"
    gdb_expect {
	-re "\\$\[0-9\]* = green.*$gdb_prompt $" { pass "print obj_with_enum.priv_enum" }
	-re "$gdb_prompt $"                     { fail "print obj_with_enum.priv_enum" }
	timeout                             { fail "(timeout) print obj_with_enum.priv_enum" }
    }

    # ptype on the enum member
    # The third success case is a little dubious, but it's not clear what
    # ought to be required of a ptype on a private enum... -sts 19990324
    send_gdb "ptype obj_with_enum.priv_enum\n"
    gdb_expect {
	-re "type = enum ClassWithEnum::PrivEnum \\{red, green, blue, yellow = 42\\}.*$gdb_prompt $" { pass "ptype obj_with_enum.priv_enum" }
	-re "type = enum PrivEnum \\{red, green, blue, yellow = 42\\}.*$gdb_prompt $" { pass "ptype obj_with_enum.priv_enum" }
	-re "type = enum \\{red, green, blue, yellow = 42\\}.*$gdb_prompt $" { pass "ptype obj_with_enum.priv_enum" }
	-re "$gdb_prompt $"                     { fail "ptype obj_with_enum.priv_enum" }
	timeout                             { fail "(timeout) ptype obj_with_enum.priv_enum" }
    }

    # ptype on the object
    send_gdb "ptype obj_with_enum\n"
    gdb_expect {
	-re "type = class ClassWithEnum \\{\r\n\[ \t\]*public:\r\n\[ \t\]*(enum |)ClassWithEnum::PrivEnum priv_enum;\r\n\[ \t\]*int x;\r\n\\}\r\n$gdb_prompt $" { pass "ptype obj_with_enum" }
	-re "type = class ClassWithEnum \\{\r\n\[ \t\]*public:\r\n\[ \t\]*(enum |)PrivEnum priv_enum;\r\n\[ \t\]*int x;.*\\}\r\n$gdb_prompt $"
	{
	    # NOTE: carlton/2003-02-28: One could certainly argue that
	    # this output is acceptable: PrivEnum is a member of
	    # ClassWithEnum, so there's no need to explicitly qualify
	    # its name with "ClassWithEnum::".  The truth, though, is
	    # that GDB is simply forgetting that PrivEnum is a member
	    # of ClassWithEnum, so we do that output for a bad reason
	    # instead of a good reason.  Under stabs, we probably
	    # can't get this right; under DWARF-2, we can.
	    kfail "gdb/57" "ptype obj_with_enum"
	}
	-re "$gdb_prompt $"                     { fail "ptype obj_with_enum" }
	timeout                             { fail "(timeout) ptype obj_with_enum" }
    }

    # We'll do this test twice, because of a parser bug: see
    # PR gdb/826.

    send_gdb "print (ClassWithEnum::PrivEnum) 42\n"
    gdb_expect {
	-re "\\$\[0-9\]* = yellow.*$gdb_prompt $" { pass "print (ClassWithEnum::PrivEnum) 42" }
	-re "A parse error in expression, near `42'.\r\n$gdb_prompt $"
	{ kfail "gdb/826" "print (ClassWithEnum::PrivEnum) 42" }
	-re "$gdb_prompt $"                     { fail "print (ClassWithEnum::PrivEnum) 42" }
	timeout                             { fail "(timeout) print (ClassWithEnum::PrivEnum) 42" }
    }

    send_gdb "print ('ClassWithEnum::PrivEnum') 42\n"
    gdb_expect {
	-re "\\$\[0-9\]* = yellow.*$gdb_prompt $" { pass "print ('ClassWithEnum::PrivEnum') 42" }
	-re "No symbol \"ClassWithEnum::PrivEnum\" in current context.\r\n$gdb_prompt $"
	{ kfail "gdb/57" "print ('ClassWithEnum::PrivEnum') 42" }
	-re "$gdb_prompt $"                     { fail "print ('ClassWithEnum::PrivEnum') 42" }
	timeout                             { fail "(timeout) print ('ClassWithEnum::PrivEnum') 42" }
    }
}

#
# Pointers to class members
#

proc test_pointers_to_class_members {} {
    global gdb_prompt
    global decimal
    global nl

    gdb_test "print Bar::z" ".* = .int\[ \]*\[( \]*Bar::&\[)\]+\[ \]*Bar::z" "print Bar::z"

    gdb_test "print &Foo::x" ".* = .int\[ \]*\[( \]*Foo::\[*)\]+\[ \]*&Foo::x" "print &Foo::x"

    gdb_test "print (int)&Foo::x" ".* = 0" "print (int)&Foo::x"

    send_gdb "print (int)&Bar::y == 2*sizeof(int)\n"
    gdb_expect {
	-re ".* = true$nl$gdb_prompt $" {
	    pass "print (int)&Bar::y == 2*sizeof(int)"
	}
	-re "There is no field named y.*$gdb_prompt $" {
	    setup_xfail "*-*-*"
	    fail "print (int)&Bar::y == 2*sizeof(int)"
	}
	-re ".*$gdb_prompt $" { fail "print (int)&Bar::y == 2*sizeof(int)" }
	timeout { fail "print (int)&Bar::y == 2*sizeof(int) (timeout)" ; return }
    }

    send_gdb "next 2\n"
    setup_xfail "*-*-*"
    gdb_expect {
	-re "$decimal\[ \t\]+inheritance3 \[)(\]+;$nl$gdb_prompt $" {}
	-re ".*$gdb_prompt $" { fail "next to inheritance3" ; return }
    }
    clear_xfail "*-*-*"

    gdb_test "print (int)pmi == sizeof(int)" ".* = false" "print (int)pmi == sizeof(int)"
}

#
# Test static members.
#

proc test_static_members {} {
    global gdb_prompt
    global hex
    global nl

    send_gdb "print Foo::st\n"
    gdb_expect {
	-re ".* = 100$nl$gdb_prompt $" {
	    pass "print Foo::st"
	}
	-re "There is no field named st.*$gdb_prompt $" {
	    setup_xfail "*-*-*"
	    fail "print Foo::st"
	}
	-re ".*$gdb_prompt $" { fail "print Foo::st" }
       timeout { fail "print Foo::st (timeout)" ; return }
    }

    send_gdb "set foo.st = 200\n"
    gdb_expect {
	-re ".*$gdb_prompt $" {}
    }

    send_gdb "print bar.st\n"
    gdb_expect {
	-re ".* = 200$nl$gdb_prompt $" {
	    pass "print bar.st"
	}
	-re "There is no member( or method|) named st.*$gdb_prompt $" {
	    setup_xfail "*-*-*"
	    fail "print bar.st"
	}
	-re ".*$gdb_prompt $" { fail "print bar.st" }
       timeout { fail "print bar.st (timeout)" ; return }
    }

    send_gdb "print &foo.st\n"
    gdb_expect {
	-re ".* = .int \[*)\]+ $hex$nl$gdb_prompt $" {
	    pass "print &foo.st"
	}
	-re "There is no member( or method|) named st.*$gdb_prompt $" {
	    setup_xfail "*-*-*"
	    fail "print &foo.st"
	}
	-re ".*$gdb_prompt $" { fail "print &foo.st" }
       timeout { fail "print &foo.st (timeout)" ; return }
    }

    set got_bar_st 0
    send_gdb "print &Bar::st\n"
    gdb_expect {
	-re ".* = .int \[*)\]+ $hex$nl$gdb_prompt $" {
	    pass "print &Bar::st"
	    set got_bar_st 1
	}
	-re "There is no field named st.*$gdb_prompt $" {
	    setup_xfail "*-*-*"
	    fail "print &Bar::st"
	}
	-re ".*$gdb_prompt $" { fail "print &Bar::st" }
       timeout { fail "print &Bar::st (timeout)" ; return }
    }

    if $got_bar_st then {
	gdb_test "print *\$" ".* = 200" "print *\$"
    }

    gdb_test "set print static-members off" ""
    gdb_test "print csi" \
	"{x = 10, y = 20}" \
	"print csi without static members"
    gdb_test "print cnsi" \
	"{x = 30, y = 40}" \
	"print cnsi without static members"

    gdb_test "set print static-members on" ""
    gdb_test "print csi" \
	"{x = 10, y = 20, static null = {x = 0, y = 0, static null = <same as static member of an already seen type>}}" \
	"print csi with static members"
    gdb_test "print cnsi" \
	"{x = 30, y = 40, static null = {x = 0, y = 0, static null = <same as static member of an already seen type>, static yy = {z = 5, static xx = {x = 1, y = 2, static null = <same as static member of an already seen type>, static yy = <same as static member of an already seen type>}}}, static yy = <same as static member of an already seen type>}" \
	"print cnsi with static members"
}

proc do_tests {} {
    global prms_id
    global bug_id
    global subdir
    global objdir
    global srcdir
    global binfile
    global gdb_prompt

    set prms_id 0
    set bug_id 0

    # Start with a fresh gdb.

    gdb_exit
    gdb_start
    gdb_reinitialize_dir $srcdir/$subdir
    gdb_load $binfile

    send_gdb "set language c++\n"
    gdb_expect -re "$gdb_prompt $"
    send_gdb "set width 0\n"
    gdb_expect -re "$gdb_prompt $"

    runto_main
    test_ptype_class_objects

    if [ runto 'inheritance2' ] then {
	test_non_inherited_member_access
	test_wrong_class_members
	test_nonexistent_members
	test_method_param_class
    }

    gdb_breakpoint enums2
    if [ gdb_continue "enums2(\\(\\)|)" ]==0 then {
	gdb_test "finish" "" ""
	test_enums
    }

    if [istarget "mips-idt-*"] then {
	# Restart because IDT/SIM runs out of file descriptors.
	gdb_exit
	gdb_start
	gdb_reinitialize_dir $srcdir/$subdir
	gdb_load $binfile
    }

    if [ runto_main ] then {
	test_pointers_to_class_members
	test_static_members
    }

    if [istarget "mips-idt-*"] then {
	# Restart because IDT/SIM runs out of file descriptors.
	gdb_exit
	gdb_start
	gdb_reinitialize_dir $srcdir/$subdir
	gdb_load $binfile
    }

    if [ runto marker_reg1 ] then {

	gdb_test "finish" "Run till exit from.*" "finish from marker_reg1"

	send_gdb "print v.method ()\n"
	gdb_expect {
	    -re "= 82.*$gdb_prompt $" {
		pass "calling method for small class"
	    }
	    -re "Address requested for identifier .v. which is in register.*$gdb_prompt $" {
		setup_xfail "*-*-*" 2972
		fail "calling method for small class"
	    }
	    -re ".*$gdb_prompt $" { fail "calling method for small class" }
	    timeout { fail "calling method for small class (timeout)" }
	    eof { fail "calling method for small class (eof)" }
	}
    }

}

do_tests

send_gdb "maint demangle inheritance1__Fv\n"
gdb_expect {
   -re "inheritance1\\(void\\).*$gdb_prompt $" { pass "demangle" }
   -re ".*$gdb_prompt $"   { fail "demangle" }
   timeout           { fail "(timeout) demangle" }
}
@


1.17
log
@2003-02-28  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/classes.exp (test_enums): KFAIL "ptype obj_with_enum"
	with respect to PR c++/57.
	KFAIL "print (ClassWithEnum::PrivEnum) 42" with respect to PR
	c++/826.
	Create "print ('ClassWithEnum::PrivEnum') 42"; KFAIL it with
	respect to PR c++/57.
@
text
@@


1.17.28.1
log
@2003-08-22  Michael Chastain  <mec@@shout.net>

	* gdb.cp: New directory.
	* gdb.cp/*: Copy from gdb.c++/*.
	* gdb.c++/*: Remove.
	* Makefile.in: Change gdb.c++ to gdb.cp.
	* configure.in:  Ditto.
	* configure: Regnerate.
@
text
@@


1.16
log
@Fix minor slip in previous patch.
@
text
@a659 2
    # g++ is putting out the wrong debug info.  This works with aCC
    if {!$hp_aCC_compiler} {setup_xfail "*-*-*"}
d663 12
d679 3
a681 2
    # g++ is putting out the wrong debug info.  This works with aCC
    if {!$hp_aCC_compiler} {setup_xfail "*-*-*"}
d685 2
d689 9
@


1.15
log
@2003-02-28  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/classes.exp (test_ptype_class_objects): Accept it if we
	print class instead of struct and/or superfluous protection
	specifiers, as long as the resulting output is equivalent to the
	source code.
	Delete FIXME from end of messages on tests that don't need
	fixing.
@
text
@d147 1
a147 1
	    fail "ptype class public_class"
@


1.14
log
@2003-02-12  Michael Chastain  <mec@@shout.net>

	* gdb.c++/classes.exp: Remove setup_xfail_format for DWARF 1.
	* gdb.c++/inherit.exp: Likewise.
	* gdb.c++/cplusfuncs.exp: Remove suppression logic for DWARF 1.
	* gdb.c++/templates.exp: Likewise.
	* gdb.c++/virtfunc.exp: Likewise.
@
text
@d58 1
a58 1
    # Accept it as an expected failure if gdb just fails to distinguish between
d67 1
a67 2
	    setup_xfail "*-*-*"
	    fail "ptype struct default_public_struct"
d75 1
a75 1
    # Accept it as an expected failure if gdb just fails to distinguish between
d84 1
a84 2
	    setup_xfail "*-*-*"
	    fail "ptype struct explicit_public_struct"
d90 1
a90 1
    # Accept it as an expected failure if gdb just fails to distinguish between
d96 1
a96 1
	    pass "ptype struct protected_struct (FIXME)"
d99 1
a99 2
	    setup_xfail "*-*-*"
	    fail "ptype struct protected_struct (FIXME)"
d105 1
a105 1
    # Accept it as an expected failure if gdb just fails to distinguish between
d111 1
a111 1
	    pass "ptype struct private_struct (FIXME)"
d114 1
a114 2
	    setup_xfail "*-*-*"
	    fail "ptype struct private_struct (FIXME)"
d120 1
a120 1
    # Accept it as an expected failure if gdb just fails to distinguish between
d126 1
a126 1
	    pass "ptype struct mixed_protection_struct (FIXME)"
d132 1
a132 2
	    setup_xfail "*-*-*"
	    fail "ptype struct mixed_protection_struct (FIXME)"
d138 1
a138 1
    # Accept it as an expected failure if gdb just fails to distinguish between
d144 1
a144 1
	    pass "ptype class public_class (FIXME)"
d147 1
a147 2
	    setup_xfail "*-*-*"
	    fail "ptype class public_class (FIXME)"
a158 1
	    setup_xfail "*-*-*"
d165 1
a165 1
    # Accept it as an expected failure if gdb just emits a superflous "private:"
d173 1
a173 1
	    pass "ptype class default_private_class (FIXME)"
d176 1
a176 2
	    setup_xfail "*-*-*"
	    fail "ptype class default_private_class (FIXME)"
d188 1
a188 1
            pass "ptype class explicit_private_class (OK for HP aCC)"
a190 1
	    setup_xfail "*-*-*"
a202 1
	    setup_xfail "*-*-*"
@


1.13
log
@2002-04-02  Daniel Jacobowitz  <drow@@mvista.com>

        * gdb.c++/classes.exp ("calling method for small class"): Match
        updated register output.
@
text
@d1 2
a2 2
# Copyright 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
# Free Software Foundation, Inc.
a94 1
    setup_xfail_format "DWARF 1"
a110 1
    setup_xfail_format "DWARF 1"
a126 1
    setup_xfail_format "DWARF 1"
a176 1
    setup_xfail_format "DWARF 1"
a234 1
    setup_xfail_format "DWARF 1"
a251 1
    setup_xfail_format "DWARF 1"
a268 1
    setup_xfail_format "DWARF 1"
a285 1
    setup_xfail_format "DWARF 1"
a348 1
    setup_xfail_format "DWARF 1"
a377 1
    setup_xfail_format "DWARF 1"
a406 1
    setup_xfail_format "DWARF 1"
a435 1
    setup_xfail_format "DWARF 1"
a460 1
    setup_xfail_format "DWARF 1"
a480 1
    setup_xfail_format "DWARF 1"
a500 1
    setup_xfail_format "DWARF 1"
a724 1
    setup_xfail_format "DWARF 1"
a808 1
    setup_xfail_format "DWARF 1"
a811 1
    setup_xfail_format "DWARF 1"
d841 1
a841 6
    # Get the debug format for the compiled test case.

    if [ runto_main ] then {
	get_debug_format
    }

@


1.13.16.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.13.14.1
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d1 2
a2 2
# Copyright 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
# 2003 Free Software Foundation, Inc.
d58 1
a58 1
    # Accept it if gdb just fails to distinguish between
d67 2
a68 1
	    pass "ptype struct default_public_struct"
d76 1
a76 1
    # Accept it if gdb just fails to distinguish between
d85 2
a86 1
	    pass "ptype struct explicit_public_struct"
d92 1
a92 1
    # Accept it if gdb just fails to distinguish between
d95 1
d99 1
a99 1
	    pass "ptype struct protected_struct"
d102 2
a103 1
	    pass "ptype struct protected_struct"
d109 1
a109 1
    # Accept it if gdb just fails to distinguish between
d112 1
d116 1
a116 1
	    pass "ptype struct private_struct"
d119 2
a120 1
	    pass "ptype struct private_struct"
d126 1
a126 1
    # Accept it if gdb just fails to distinguish between
d129 1
d133 1
a133 1
	    pass "ptype struct mixed_protection_struct"
d139 2
a140 1
	    pass "ptype struct mixed_protection_struct"
d146 1
a146 1
    # Accept it if gdb just fails to distinguish between
d152 1
a152 1
	    pass "ptype class public_class"
d155 2
a156 1
	    pass "ptype class public_class"
d168 1
d175 1
a175 1
    # Accept it if gdb just emits a superflous "private:"
d180 1
d184 1
a184 1
	    pass "ptype class default_private_class"
d187 2
a188 1
	    pass "ptype class default_private_class"
d200 1
a200 1
            pass "ptype class explicit_private_class"
d203 1
d216 1
d239 1
d257 1
d275 1
d293 1
d357 1
d387 1
d417 1
d447 1
d473 1
d494 1
d515 1
d685 2
a689 12
	-re "type = class ClassWithEnum \\{\r\n\[ \t\]*public:\r\n\[ \t\]*(enum |)PrivEnum priv_enum;\r\n\[ \t\]*int x;.*\\}\r\n$gdb_prompt $"
	{
	    # NOTE: carlton/2003-02-28: One could certainly argue that
	    # this output is acceptable: PrivEnum is a member of
	    # ClassWithEnum, so there's no need to explicitly qualify
	    # its name with "ClassWithEnum::".  The truth, though, is
	    # that GDB is simply forgetting that PrivEnum is a member
	    # of ClassWithEnum, so we do that output for a bad reason
	    # instead of a good reason.  Under stabs, we probably
	    # can't get this right; under DWARF-2, we can.
	    kfail "gdb/57" "ptype obj_with_enum"
	}
d694 2
a695 3
    # We'll do this test twice, because of a parser bug: see
    # PR gdb/826.

a698 2
	-re "A parse error in expression, near `42'.\r\n$gdb_prompt $"
	{ kfail "gdb/826" "print (ClassWithEnum::PrivEnum) 42" }
a701 9

    send_gdb "print ('ClassWithEnum::PrivEnum') 42\n"
    gdb_expect {
	-re "\\$\[0-9\]* = yellow.*$gdb_prompt $" { pass "print ('ClassWithEnum::PrivEnum') 42" }
	-re "No symbol \"ClassWithEnum::PrivEnum\" in current context.\r\n$gdb_prompt $"
	{ kfail "gdb/57" "print ('ClassWithEnum::PrivEnum') 42" }
	-re "$gdb_prompt $"                     { fail "print ('ClassWithEnum::PrivEnum') 42" }
	timeout                             { fail "(timeout) print ('ClassWithEnum::PrivEnum') 42" }
    }
d740 1
d825 1
d829 1
d859 6
a864 1
    runto_main
@


1.13.14.2
log
@2003-08-22  Michael Chastain  <mec@@shout.net>

	* gdb.cp: New directory.
	* gdb.cp/*: Copy from gdb.c++/*.
	* gdb.c++/*: Remove.
	* Makefile.in: Change gdb.c++ to gdb.cp.
	* configure.in:  Ditto.
	* carlton_runnamespace: Ditto.
	* carlton_runtest: Ditto.
	* configure: Regnerate.
@
text
@@


1.12
log
@2002-01-20  Daniel Jacobowitz  <drow@@mvista.com>

	* gdb.c++/classes.exp: Update for improved v3 support and skipping
	artificial methods/arguments.
	* gdb.c++/derivation.exp: Likewise.
	* gdb.c++/inherit.exp: Likewise.
	* gdb.c++/method.exp: Likewise.
	* gdb.c++/virtfunc.exp: Likewise.
@
text
@d910 1
a910 1
	    -re "Address requested for identifier .v. which is in a register.*$gdb_prompt $" {
@


1.11
log
@        * gdb.c++/namespace.exp: Accept trailing const for 'this'.

        * gdb.c++/classes.exp: Accept 'A const' or 'const A' in copy
        constructors.
        * gdb.c++/derivation.exp: Likewise.
        * gdb.c++/templates.exp: Likewise.
        * gdb.c++/virtfunc.exp: Likewise.
@
text
@d318 3
d332 3
d360 1
a360 1
	-re "type = class vB : public virtual vA \{${ws}public:${ws}int vb;${ws}int vx;${ws}vB & operator=\\(vB const ?&\\);${ws}vB\\((vB const|const vB) ?&\\);${ws}vB\\(\\);${ws}\}$nl$gdb_prompt $" {
d368 1
a368 1
            pass "ptype class vB (aCC)"
d390 1
a390 1
	-re "type = class vC : public virtual vA \{${ws}public:${ws}int vc;${ws}int vx;${ws}vC & operator=\\(vC const ?&\\);${ws}vC\\((vC const|const vC) ?&\\);${ws}vC\\(\\);${ws}\}$nl$gdb_prompt $" {
d398 1
a398 1
            pass "ptype class vC (aCC)"
d420 1
a420 1
	-re "type = class vD : public virtual vB, public virtual vC \{${ws}public:${ws}int vd;${ws}int vx;${ws}vD & operator=\\(vD const ?&\\);${ws}vD\\((vD const|const vD) ?&\\);${ws}vD\\(\\);${ws}\}$nl$gdb_prompt $" {
d428 1
a428 1
            pass "ptype class vD (aCC)"
d450 1
a450 1
	-re "type = class vE : public virtual vD \{${ws}public:${ws}int ve;${ws}int vx;${ws}vE & operator=\\(vE const ?&\\);${ws}vE\\((vE const|const vE) ?&\\);${ws}vE\\(\\);${ws}\}$nl$gdb_prompt $" {
d458 1
a458 1
            pass "ptype class vE (aCC)"
d479 3
d497 2
a498 2
        -re "type = class Foo \{${ws}public:${ws}int x;${ws}int y;${ws}static int st;\r\n${ws}Foo\\(int, int\\);${ws}int operator!.void.;${ws}operator int.void.;${ws}int times.int.;$nl\}$nl$gdb_prompt $" {
            pass "ptype class Foo(aCC)"
@


1.10
log
@        * gdb.c++/classes.exp, gdb.c++/derivation.exp,
        gdb.c++/inherit.exp, gdb.c++/method.exp,
        gdb.c++/namespace.exp, gdb.c++/templates.exp,
        gdb.c++/userdef.exp, gdb.c++/virtfunc.exp: Updates for v3 demangler
        and class layout support.
@
text
@d1 1
a1 1
# Copyright 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
d227 1
a227 1
	-re "type = (class|struct) A \{(${ws}public:|)${ws}int a;${ws}int x;((${ws}A & operator=\\(A const ?&\\);)|(${ws}A\\(A const ?&\\);)|(${ws}A\\((void|)\\);))*${ws}\}$nl$gdb_prompt $" {
d242 1
a242 1
	-re "type = class B : public A \{${ws}public:${ws}int b;${ws}int x;${ws}B & operator=\\(B const ?&\\);${ws}B\\(B const ?&\\);${ws}B\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
d260 1
a260 1
	-re "type = class C : public A \{${ws}public:${ws}int c;${ws}int x;${ws}C & operator=\\(C const ?&\\);${ws}C\\(C const ?&\\);${ws}C\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
d278 1
a278 1
	-re "type = class D : public B, public C \{${ws}public:${ws}int d;${ws}int x;${ws}D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
d296 1
a296 1
	-re "type = class E : public D \{${ws}public:${ws}int e;${ws}int x;${ws}E & operator=\\(E const ?&\\);${ws}E\\(E const ?&\\);${ws}E\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
d299 1
a299 1
	-re "type = class E : public D \{${ws}public:${ws}int e;${ws}int x;((${ws}E & operator=\\(E const ?&\\);)|(${ws}E\\(E const ?&\\);)|(${ws}E\\((void|)\\);))*${ws}\}$nl$gdb_prompt $" {
d315 1
a315 1
	-re "type = (class|struct) Static \{(${ws}public:|)${ws}Static & operator=\\(Static const ?&\\);${ws}Static\\(Static const ?&\\);${ws}Static\\((void|)\\);${ws}static void ii\\(int, int\\);${ws}\}$nl$gdb_prompt $" {
d329 1
a329 1
	-re "type = (class|struct) vA \{(${ws}public:|)${ws}int va;${ws}int vx;${ws}vA & operator=\\(vA const ?&\\);${ws}vA\\(vA const ?&\\);${ws}vA\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
d354 1
a354 1
	-re "type = class vB : public virtual vA \{${ws}public:${ws}int vb;${ws}int vx;${ws}vB & operator=\\(vB const ?&\\);${ws}vB\\(vB const ?&\\);${ws}vB\\(\\);${ws}\}$nl$gdb_prompt $" {
d384 1
a384 1
	-re "type = class vC : public virtual vA \{${ws}public:${ws}int vc;${ws}int vx;${ws}vC & operator=\\(vC const ?&\\);${ws}vC\\(vC const ?&\\);${ws}vC\\(\\);${ws}\}$nl$gdb_prompt $" {
d414 1
a414 1
	-re "type = class vD : public virtual vB, public virtual vC \{${ws}public:${ws}int vd;${ws}int vx;${ws}vD & operator=\\(vD const ?&\\);${ws}vD\\(vD const ?&\\);${ws}vD\\(\\);${ws}\}$nl$gdb_prompt $" {
d444 1
a444 1
	-re "type = class vE : public virtual vD \{${ws}public:${ws}int ve;${ws}int vx;${ws}vE & operator=\\(vE const ?&\\);${ws}vE\\(vE const ?&\\);${ws}vE\\(\\);${ws}\}$nl$gdb_prompt $" {
d470 1
a470 1
	-re "type = class Base1 \{${ws}public:${ws}int x;${ws}Base1 & operator=\\(Base1 const ?&\\);${ws}Base1\\(Base1 const ?&\\);${ws}Base1\\(int\\);${ws}\}$nl$gdb_prompt $" {
d491 1
a491 1
	-re "type = class Foo \{${ws}public:${ws}int x;${ws}int y;${ws}static int st;${ws}Foo & operator=\\(Foo const ?&\\);${ws}Foo\\(Foo const ?&\\);${ws}Foo\\(int, int\\);${ws}int operator!\\((void|)\\);${ws}operator int\\((void|)\\);${ws}int times\\(int\\);${ws}\}$nl$gdb_prompt $" {
d509 1
a509 1
	-re "type = class Bar : public Base1, public Foo \{${ws}public:${ws}int z;${ws}Bar & operator=\\(Bar const ?&\\);${ws}Bar\\(Bar const ?&\\);${ws}Bar\\(int, int, int\\);${ws}\}$nl$gdb_prompt $" {
@


1.9
log
@        * gdb.c++/classes.exp: Add test for static member function.
        * gdb.c++/misc.cc: Add class with static member function.
@
text
@d242 1
a242 1
	-re "type = class B : public A \{${ws}public:${ws}int b;${ws}int x;${ws}B & operator=\\(B const &\\);${ws}B\\(B const &\\);${ws}B\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
d245 1
a245 1
	-re "type = class B : public A \{${ws}public:${ws}int b;${ws}int x;((${ws}B & operator=\\(B const &\\);)|(${ws}B\\(B const &\\);)|(${ws}B\\((void|)\\);))*${ws}\}$nl$gdb_prompt $" {
d260 1
a260 1
	-re "type = class C : public A \{${ws}public:${ws}int c;${ws}int x;${ws}C & operator=\\(C const &\\);${ws}C\\(C const &\\);${ws}C\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
d263 1
a263 1
	-re "type = class C : public A \{${ws}public:${ws}int c;${ws}int x;((${ws}C & operator=\\(C const &\\);)|(${ws}C\\(C const &\\);)|(${ws}C\\((void|)\\);))*${ws}\}$nl$gdb_prompt $" {
d278 1
a278 1
	-re "type = class D : public B, public C \{${ws}public:${ws}int d;${ws}int x;${ws}D & operator=\\(D const &\\);${ws}D\\(D const &\\);${ws}D\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
d281 1
a281 1
	-re "type = class D : public B, public C \{${ws}public:${ws}int d;${ws}int x;((${ws}D & operator=\\(D const &\\);)|(${ws}D\\(D const &\\);)|(${ws}D\\((void|)\\);))*${ws}\}$nl$gdb_prompt $" {
d296 1
a296 1
	-re "type = class E : public D \{${ws}public:${ws}int e;${ws}int x;${ws}E & operator=\\(E const &\\);${ws}E\\(E const &\\);${ws}E\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
d299 1
a299 1
	-re "type = class E : public D \{${ws}public:${ws}int e;${ws}int x;((${ws}E & operator=\\(E const &\\);)|(${ws}E\\(E const &\\);)|(${ws}E\\((void|)\\);))*${ws}\}$nl$gdb_prompt $" {
d329 1
a329 1
	-re "type = (class|struct) vA \{(${ws}public:|)${ws}int va;${ws}int vx;${ws}vA & operator=\\(vA const &\\);${ws}vA\\(vA const &\\);${ws}vA\\((void|)\\);${ws}\}$nl$gdb_prompt $" {
d332 1
a332 1
	-re "type = (class|struct) vA \{(${ws}public:|)${ws}int va;${ws}int vx;((${ws}vA & operator=\\(vA const &\\);)|(${ws}vA\\(vA const &\\);)|(${ws}vA\\((void|)\\);))*${ws}\}$nl$gdb_prompt $" {
d354 4
a357 1
	-re "type = class vB : public virtual vA \{${ws}private:${ws}vA \\*${vbptr}vA;${ws}public:${ws}int vb;${ws}int vx;${ws}vB & operator=\\(vB const &\\);${ws}vB\\(int, vB const &\\);${ws}vB\\(int\\);${ws}\}$nl$gdb_prompt $" {
d364 1
a364 1
	-re "type = class vB : public virtual vA \{${ws}private:${ws}vA \\*_vb.vA;${ws}public:${ws}int vb;${ws}int vx;((${ws}vB & operator=\\(vB const &\\);)|(${ws}vB\\(int, vB const &\\);)|(${ws}vB\\(int\\);))*${ws}\}$nl$gdb_prompt $" {
d384 4
a387 1
	-re "type = class vC : public virtual vA \{${ws}private:${ws}vA \\*${vbptr}vA;${ws}public:${ws}int vc;${ws}int vx;${ws}vC & operator=\\(vC const &\\);${ws}vC\\(int, vC const &\\);${ws}vC\\(int\\);${ws}\}$nl$gdb_prompt $" {
d394 1
a394 1
	-re "type = class vC : public virtual vA \{${ws}private:${ws}vA \\*_vb.vA;${ws}public:${ws}int vc;${ws}int vx;((${ws}vC & operator=\\(vC const &\\);)|(${ws}vC\\(int, vC const &\\);)|(${ws}vC\\(int\\);))*${ws}\}$nl$gdb_prompt $" {
d414 4
a417 1
	-re "type = class vD : public virtual vB, public virtual vC \{${ws}private:${ws}vC \\*${vbptr}vC;${ws}vB \\*${vbptr}vB;${ws}public:${ws}int vd;${ws}int vx;${ws}vD & operator=\\(vD const &\\);${ws}vD\\(int, vD const &\\);${ws}vD\\(int\\);${ws}\}$nl$gdb_prompt $" {
d424 1
a424 1
	-re "type = class vD : public virtual vB, public virtual vC \{${ws}private:${ws}vC \\*_vb.vC;${ws}vB \\*_vb.vB;${ws}public:${ws}int vd;${ws}int vx;((${ws}vD & operator=\\(vD const &\\);)|(${ws}vD\\(int, vD const &\\);)|(${ws}vD\\(int\\);))*${ws}\}$nl$gdb_prompt $" {
d444 4
a447 1
	-re "type = class vE : public virtual vD \{${ws}private:${ws}vD \\*${vbptr}vD;${ws}public:${ws}int ve;${ws}int vx;${ws}vE & operator=\\(vE const &\\);${ws}vE\\(int, vE const &\\);${ws}vE\\(int\\);${ws}\}$nl$gdb_prompt $" {
d454 1
a454 1
	-re "type = class vE : public virtual vD \{${ws}private:${ws}vD \\*_vb.vD;${ws}public:${ws}int ve;${ws}int vx;((${ws}vE & operator=\\(vE const &\\);)|(${ws}vE\\(int, vE const &\\);)|(${ws}vE\\(int\\);))*${ws}\}$nl$gdb_prompt $" {
d470 1
a470 1
	-re "type = class Base1 \{${ws}public:${ws}int x;${ws}Base1 & operator=\\(Base1 const &\\);${ws}Base1\\(Base1 const &\\);${ws}Base1\\(int\\);${ws}\}$nl$gdb_prompt $" {
d473 1
a473 1
	-re "type = class Base1 \{${ws}public:${ws}int x;((${ws}Base1 & operator=\\(Base1 const &\\);)|(${ws}Base1\\(Base1 const &\\);)|(${ws}Base1\\(int\\);))*${ws}\}$nl$gdb_prompt $" {
d491 1
a491 1
	-re "type = class Foo \{${ws}public:${ws}int x;${ws}int y;${ws}static int st;${ws}Foo & operator=\\(Foo const &\\);${ws}Foo\\(Foo const &\\);${ws}Foo\\(int, int\\);${ws}int operator!\\((void|)\\);${ws}operator int\\((void|)\\);${ws}int times\\(int\\);${ws}\}$nl$gdb_prompt $" {
d494 1
a494 1
	-re "type = class Foo \{${ws}public:${ws}int x;${ws}int y;${ws}static int st;((${ws}Foo & operator=\\(Foo const &\\);)|(${ws}Foo\\(Foo const &\\);)|(${ws}Foo\\(int, int\\);)|(${ws}int operator!\\((void|)\\);)|(${ws}int operator int\\((void|)\\);)|(${ws}int times\\(int\\);))*${ws}\}$nl$gdb_prompt $" {
d509 1
a509 1
	-re "type = class Bar : public Base1, public Foo \{${ws}public:${ws}int z;${ws}Bar & operator=\\(Bar const &\\);${ws}Bar\\(Bar const &\\);${ws}Bar\\(int, int, int\\);${ws}\}$nl$gdb_prompt $" {
d512 1
a512 1
	-re "type = class Bar : public Base1, public Foo \{${ws}public:${ws}int z;((${ws}Bar & operator=\\(Bar const &\\);)|(${ws}Bar\\(Bar const &\\);)|(${ws}Bar\\(int, int, int\\);))*${ws}\}$nl$gdb_prompt $" {
d866 1
a866 1
    if [ gdb_continue enums2 ]==0 then {
@


1.8
log
@2001-07-03  Michael Snyder  <msnyder@@redhat.com>

	* gdb.c++/classes.exp: Accept both "foo(void)" and "foo()" in
	the output of the ptype command.
@
text
@d311 16
@


1.7
log
@* gdb.c++/classes.exp (ptype class A): Tolerate whitespace
variations.
@
text
@d227 1
a227 1
	-re "type = (class|struct) A \{(${ws}public:|)${ws}int a;${ws}int x;((${ws}A & operator=\\(A const ?&\\);)|(${ws}A\\(A const ?&\\);)|(${ws}A\\(void\\);))*${ws}\}$nl$gdb_prompt $" {
d242 1
a242 1
	-re "type = class B : public A \{${ws}public:${ws}int b;${ws}int x;${ws}B & operator=\\(B const &\\);${ws}B\\(B const &\\);${ws}B\\(void\\);${ws}\}$nl$gdb_prompt $" {
d245 1
a245 1
	-re "type = class B : public A \{${ws}public:${ws}int b;${ws}int x;((${ws}B & operator=\\(B const &\\);)|(${ws}B\\(B const &\\);)|(${ws}B\\(void\\);))*${ws}\}$nl$gdb_prompt $" {
d260 1
a260 1
	-re "type = class C : public A \{${ws}public:${ws}int c;${ws}int x;${ws}C & operator=\\(C const &\\);${ws}C\\(C const &\\);${ws}C\\(void\\);${ws}\}$nl$gdb_prompt $" {
d263 1
a263 1
	-re "type = class C : public A \{${ws}public:${ws}int c;${ws}int x;((${ws}C & operator=\\(C const &\\);)|(${ws}C\\(C const &\\);)|(${ws}C\\(void\\);))*${ws}\}$nl$gdb_prompt $" {
d278 1
a278 1
	-re "type = class D : public B, public C \{${ws}public:${ws}int d;${ws}int x;${ws}D & operator=\\(D const &\\);${ws}D\\(D const &\\);${ws}D\\(void\\);${ws}\}$nl$gdb_prompt $" {
d281 1
a281 1
	-re "type = class D : public B, public C \{${ws}public:${ws}int d;${ws}int x;((${ws}D & operator=\\(D const &\\);)|(${ws}D\\(D const &\\);)|(${ws}D\\(void\\);))*${ws}\}$nl$gdb_prompt $" {
d296 1
a296 1
	-re "type = class E : public D \{${ws}public:${ws}int e;${ws}int x;${ws}E & operator=\\(E const &\\);${ws}E\\(E const &\\);${ws}E\\(void\\);${ws}\}$nl$gdb_prompt $" {
d299 1
a299 1
	-re "type = class E : public D \{${ws}public:${ws}int e;${ws}int x;((${ws}E & operator=\\(E const &\\);)|(${ws}E\\(E const &\\);)|(${ws}E\\(void\\);))*${ws}\}$nl$gdb_prompt $" {
d313 1
a313 1
	-re "type = (class|struct) vA \{(${ws}public:|)${ws}int va;${ws}int vx;${ws}vA & operator=\\(vA const &\\);${ws}vA\\(vA const &\\);${ws}vA\\(void\\);${ws}\}$nl$gdb_prompt $" {
d316 1
a316 1
	-re "type = (class|struct) vA \{(${ws}public:|)${ws}int va;${ws}int vx;((${ws}vA & operator=\\(vA const &\\);)|(${ws}vA\\(vA const &\\);)|(${ws}vA\\(void\\);))*${ws}\}$nl$gdb_prompt $" {
d463 1
a463 1
	-re "type = class Foo \{${ws}public:${ws}int x;${ws}int y;${ws}static int st;${ws}Foo & operator=\\(Foo const &\\);${ws}Foo\\(Foo const &\\);${ws}Foo\\(int, int\\);${ws}int operator!\\(void\\);${ws}operator int\\(void\\);${ws}int times\\(int\\);${ws}\}$nl$gdb_prompt $" {
d466 1
a466 1
	-re "type = class Foo \{${ws}public:${ws}int x;${ws}int y;${ws}static int st;((${ws}Foo & operator=\\(Foo const &\\);)|(${ws}Foo\\(Foo const &\\);)|(${ws}Foo\\(int, int\\);)|(${ws}int operator!\\(void\\);)|(${ws}int operator int\\(void\\);)|(${ws}int times\\(int\\);))*${ws}\}$nl$gdb_prompt $" {
@


1.6
log
@Update/correct copyright notices.
@
text
@d227 1
a227 1
	-re "type = (class|struct) A \{(${ws}public:|)${ws}int a;${ws}int x;((${ws}A & operator=\\(A const &\\);)|(${ws}A\\(A const &\\);)|(${ws}A\\(void\\);))*${ws}\}$nl$gdb_prompt $" {
@


1.5
log
@2001-02-18  Michael Chastain  <chastain@@redhat.com>

	* gdb.c++/classes.exp (do_tests): Change runto statements
	from "runto 'foo(void)'" to "runto 'foo'".  This makes the
	statements demangler agnostic.
	* gdb.c++/virtfunc.exp (do_tests): Likewise.
	(gdb_virtfunc_restart): Likewise.
@
text
@d1 2
a2 1
# Copyright (C) 1992, 1994, 1995, 1997, 1999, 2001 Free Software Foundation, Inc.
@


1.4
log
@

* gdb.c++/classes.exp: Use gdb_test instead of send_gdb to
'finish', otherwise uncaptured gdb_prompt would potentially
throw remaining test points out of sync.
@
text
@d1 1
a1 1
# Copyright (C) 1992, 1994, 1995, 1997, 1999 Free Software Foundation, Inc.
d829 1
a829 1
    if [ runto 'inheritance2(void)' ] then {
@


1.3
log
@	* gdb.c++/misc.cc (class ClassParam, class_param): Define.
	(use_methods): New function.
	(main): Call use_methods().
	* gdb.c++/classes.exp (test_method_param_class): New procedure.
	(do_tests): Call test_method_param_class.
@
text
@d838 1
a838 1
	send_gdb "finish\n"
@


1.2
log
@	* gdb.c++/classes.exp (test_nonexistant_members): Fix name
	spelling.
	(test_enums): New procedure.  Move enum tests from end of script
	to here.  Set breakpoint on function name instead of line number.
	* gdb.c++/misc.cc (ClassWithEnum): Move past Foo definitions.
	(enums2): New marker function.
	(enums1): New function.
	(main): Call enums1().  Move enum tests to enums1().
@
text
@d573 24
d833 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
# Copyright (C) 1992, 1994, 1995, 1997 Free Software Foundation, Inc.
d29 1
a29 4

# Check to see if we have an executable to test.  If not, then either we
# haven't tried to compile one, or the compilation failed for some reason.
# In either case, just notify the user and skip the tests in this file.
a41 8
# if we are on HPUX and we are not compiled with gcc, then skip these tests.

if [istarget hppa*-*-hpux*] {
    if {!$gcc_compiled} {
	continue 
    }
}

d134 3
d198 3
d331 3
d337 1
a337 1
	-re "type = class vB : public virtual vA \{${ws}private:${ws}vA \\*_vb.vA;${ws}public:${ws}int vb;${ws}int vx;${ws}vB & operator=\\(vB const &\\);${ws}vB\\(int, vB const &\\);${ws}vB\\(int\\);${ws}\}$nl$gdb_prompt $" {
d341 3
d364 1
a364 1
	-re "type = class vC : public virtual vA \{${ws}private:${ws}vA \\*_vb.vA;${ws}public:${ws}int vc;${ws}int vx;${ws}vC & operator=\\(vC const &\\);${ws}vC\\(int, vC const &\\);${ws}vC\\(int\\);${ws}\}$nl$gdb_prompt $" {
d368 3
d391 1
a391 1
	-re "type = class vD : public virtual vB, public virtual vC \{${ws}private:${ws}vC \\*_vb.vC;${ws}vB \\*_vb.vB;${ws}public:${ws}int vd;${ws}int vx;${ws}vD & operator=\\(vD const &\\);${ws}vD\\(int, vD const &\\);${ws}vD\\(int\\);${ws}\}$nl$gdb_prompt $" {
d395 3
d418 1
a418 1
	-re "type = class vE : public virtual vD \{${ws}private:${ws}vD \\*_vb.vD;${ws}public:${ws}int ve;${ws}int vx;${ws}vE & operator=\\(vE const &\\);${ws}vE\\(int, vE const &\\);${ws}vE\\(int\\);${ws}\}$nl$gdb_prompt $" {
d422 3
d459 4
a462 1
	-re "type = class Foo \{${ws}public:${ws}int x;${ws}int y;${ws}static int st;${ws}Foo & operator=\\(Foo const &\\);${ws}Foo\\(Foo const &\\);${ws}Foo\\(int, int\\);${ws}int operator!\\(void\\);${ws}int operator int\\(void\\);${ws}int times\\(int\\);${ws}\}$nl$gdb_prompt $" {
d560 1
a560 1
proc test_nonexistant_members {} {
d573 70
d670 1
a670 1
    send_gdb "next\n"
d808 7
a814 1
	test_nonexistant_members
d837 1
a837 1
 
a860 72

# Some additional tests for enums inside classes


# set a breakpoint and go there
send_gdb "break 498\n"   
gdb_expect {   
   -re "Breakpoint \[0-9\] at.*$gdb_prompt $" { pass "set break 498" }
   -re "$gdb_prompt $"                     { fail "set break 498" }
   timeout                             { fail "(timeout) set break 498" }
}
send_gdb "continue\n"   
gdb_expect {   
   -re "Continuing\\.\r\n\r\nBreakpoint \[0-9\]*, main....at.*misc\\.cc:498\r\n498.*\r\n$gdb_prompt $" { pass "continue" }
   -re "$gdb_prompt $"                     { fail "continue" }
   timeout                             { fail "(timeout) continue" }
}

# print the object
send_gdb "print obj_with_enum\n"   
gdb_expect {   
   -re "\\$\[0-9\]* = \\{priv_enum = red, x = 0\\}.*$gdb_prompt $" { pass "print obj_with_enum (1)" }
   -re "$gdb_prompt $"                     { fail "print obj_with_enum (1)" }
   timeout                             { fail "(timeout) print obj_with_enum (1)" }
}

send_gdb "next\n"   
gdb_expect {   
   -re "$gdb_prompt $"                     { pass "next" }
   timeout                             { fail "(timeout) next" }
}

# print the object again
send_gdb "print obj_with_enum\n"   
gdb_expect {   
   -re "\\$\[0-9\]* = \\{priv_enum = green, x = 0\\}.*$gdb_prompt $" { pass "print obj_with_enum (2)" }
   -re "$gdb_prompt $"                     { fail "print obj_with_enum (2)" }
   timeout                             { fail "(timeout) print obj_with_enum (2)" }
}

# print out the enum member
send_gdb "print obj_with_enum.priv_enum\n"   
gdb_expect {   
   -re "\\$\[0-9\]* = green.*$gdb_prompt $" { pass "print obj_with_enum.priv_enum" }
   -re "$gdb_prompt $"                     { fail "print obj_with_enum.priv_enum" }
   timeout                             { fail "(timeout) print obj_with_enum.priv_enum" }
}

# ptype on the enum member
send_gdb "ptype obj_with_enum.priv_enum\n"   
gdb_expect {   
   -re "type = enum ClassWithEnum::PrivEnum \\{red, green, blue, yellow = 42\\}.*$gdb_prompt $" { pass "ptype obj_with_enum.priv_enum" }
   -re "$gdb_prompt $"                     { fail "ptype obj_with_enum.priv_enum" }
   timeout                             { fail "(timeout) ptype obj_with_enum.priv_enum" }
}

# ptype on the object
send_gdb "ptype obj_with_enum\n"   
gdb_expect {   
   -re "type = class ClassWithEnum \\{\r\n\[ \t\]*public:\r\n\[ \t\]*enum ClassWithEnum::PrivEnum priv_enum;\r\n\[ \t\]*int x;\r\n\\}\r\n$gdb_prompt $" { pass "ptype obj_with_enum" }
   -re "$gdb_prompt $"                     { fail "ptype obj_with_enum" }
   timeout                             { fail "(timeout) ptype obj_with_enum" }
}

send_gdb "print (ClassWithEnum::PrivEnum) 42\n"   
gdb_expect {   
   -re "\\$\[0-9\]* = yellow.*$gdb_prompt $" { pass "print (ClassWithEnum::PrivEnum) 42" }
   -re "$gdb_prompt $"                     { fail "print (ClassWithEnum::PrivEnum) 42" }
   timeout                             { fail "(timeout) print (ClassWithEnum::PrivEnum) 42" }
}


a866 1

@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d777 1
a777 1
send_gdb "break 503\n"   
d779 3
a781 3
   -re "Breakpoint \[0-9\] at.*$gdb_prompt $" { pass "set break 503" }
   -re "$gdb_prompt $"                     { fail "set break 503" }
   timeout                             { fail "(timeout) set break 503" }
d785 1
a785 1
   -re "Continuing\\.\r\n\r\nBreakpoint \[0-9\]*, main....at.*misc\\.cc:503\r\n503.*\r\n$gdb_prompt $" { pass "continue" }
a820 2
# The second success case is a little dubious, but it's not clear what
# ought to be required of a ptype on a private enum... -sts 19990324
a823 1
   -re "type = enum \\{red, green, blue, yellow = 42\\}.*$gdb_prompt $" { pass "ptype obj_with_enum.priv_enum" }
@


1.1.1.3
log
@import gdb-1999-08-02 snapshot
@
text
@d45 7
a144 3
        -re "type = struct mixed_protection_struct \{${ws}public:${ws}int a;${ws}int b;${ws}private:${ws}int c;${ws}int d;${ws}protected:${ws}int e;${ws}int f;${ws}public:${ws}int g;${ws}private:${ws}int h;${ws}protected:${ws}int i;$nl.*\}$nl$gdb_prompt $" {
            pass "ptype struct mixed_protection_struct (extra public)"
        }
a205 3
        -re "type = class explicit_private_class \{${ws}int a;${ws}int b;$nl.*\}$nl$gdb_prompt $" {
            pass "ptype class explicit_private_class (OK for HP aCC)"
        }
a342 3
        -re "type = class vB : public virtual vA \{${ws}public:${ws}int vb;${ws}int vx;${ws}\}$nl$gdb_prompt $" {
            pass "ptype class vB (aCC)"
        }
a366 3
        -re "type = class vC : public virtual vA \{${ws}public:${ws}int vc;${ws}int vx;${ws}\}$nl$gdb_prompt $" {
            pass "ptype class vC (aCC)"
        }
a390 3
        -re "type = class vD : public virtual vB, public virtual vC \{${ws}public:${ws}int vd;${ws}int vx;${ws}\}$nl$gdb_prompt $" {
            pass "ptype class vD (aCC)"
        }
a414 3
        -re "type = class vE : public virtual vD \{${ws}public:${ws}int ve;${ws}int vx;${ws}\}$nl$gdb_prompt $" {
            pass "ptype class vE (aCC)"
        }
a448 3
        -re "type = class Foo \{${ws}public:${ws}int x;${ws}int y;${ws}static int st;\r\n${ws}Foo\\(int, int\\);${ws}int operator!.void.;${ws}operator int.void.;${ws}int times.int.;$nl\}$nl$gdb_prompt $" {
            pass "ptype class Foo(aCC)"
        }
d587 1
a587 1
    send_gdb "next 2\n"
d777 1
a777 1
send_gdb "break 516\n"   
d779 3
a781 3
   -re "Breakpoint \[0-9\] at.*$gdb_prompt $" { pass "set break 516" }
   -re "$gdb_prompt $"                     { fail "set break 516" }
   timeout                             { fail "(timeout) set break 516" }
d785 1
a785 1
   -re "Continuing\\.\r\n\r\nBreakpoint \[0-9\]*, main....at.*misc\\.cc:516\r\n516.*\r\n$gdb_prompt $" { pass "continue" }
a831 2
# g++ is putting out the wrong debug info.  This works with aCC
if {!$hp_aCC_compiler} {setup_xfail "hppa*-*-*"}
d834 1
a834 1
   -re "type = class ClassWithEnum \\{\r\n\[ \t\]*public:\r\n\[ \t\]*(enum |)ClassWithEnum::PrivEnum priv_enum;\r\n\[ \t\]*int x;\r\n\\}\r\n$gdb_prompt $" { pass "ptype obj_with_enum" }
a838 2
# g++ is putting out the wrong debug info.  This works with aCC
if {!$hp_aCC_compiler} {setup_xfail "hppa*-*-*"}
@


1.1.1.4
log
@import gdb-1999-08-30 snapshot
@
text
@d847 1
a847 1
if {!$hp_aCC_compiler} {setup_xfail "*-*-*"}
d856 1
a856 1
if {!$hp_aCC_compiler} {setup_xfail "*-*-*"}
@


1.1.1.5
log
@import gdb-1999-09-08 snapshot
@
text
@d29 4
a32 1
if { [skip_cplus_tests] } { continue }
d44 1
@


1.1.1.6
log
@import gdb-1999-12-06 snapshot
@
text
@d1 1
a1 1
# Copyright (C) 1992, 1994, 1995, 1997, 1999 Free Software Foundation, Inc.
a330 3
    # The format of a g++ virtual base pointer.
    set vbptr "(_vb\[$.\]|__vb_)\[0-9\]?"

d334 1
a334 1
	-re "type = class vB : public virtual vA \{${ws}private:${ws}vA \\*${vbptr}vA;${ws}public:${ws}int vb;${ws}int vx;${ws}vB & operator=\\(vB const &\\);${ws}vB\\(int, vB const &\\);${ws}vB\\(int\\);${ws}\}$nl$gdb_prompt $" {
d361 1
a361 1
	-re "type = class vC : public virtual vA \{${ws}private:${ws}vA \\*${vbptr}vA;${ws}public:${ws}int vc;${ws}int vx;${ws}vC & operator=\\(vC const &\\);${ws}vC\\(int, vC const &\\);${ws}vC\\(int\\);${ws}\}$nl$gdb_prompt $" {
d388 1
a388 1
	-re "type = class vD : public virtual vB, public virtual vC \{${ws}private:${ws}vC \\*${vbptr}vC;${ws}vB \\*${vbptr}vB;${ws}public:${ws}int vd;${ws}int vx;${ws}vD & operator=\\(vD const &\\);${ws}vD\\(int, vD const &\\);${ws}vD\\(int\\);${ws}\}$nl$gdb_prompt $" {
d415 1
a415 1
	-re "type = class vE : public virtual vD \{${ws}private:${ws}vD \\*${vbptr}vD;${ws}public:${ws}int ve;${ws}int vx;${ws}vE & operator=\\(vE const &\\);${ws}vE\\(int, vE const &\\);${ws}vE\\(int\\);${ws}\}$nl$gdb_prompt $" {
d459 1
a459 1
	-re "type = class Foo \{${ws}public:${ws}int x;${ws}int y;${ws}static int st;${ws}Foo & operator=\\(Foo const &\\);${ws}Foo\\(Foo const &\\);${ws}Foo\\(int, int\\);${ws}int operator!\\(void\\);${ws}operator int\\(void\\);${ws}int times\\(int\\);${ws}\}$nl$gdb_prompt $" {
d831 1
a831 1
# The third success case is a little dubious, but it's not clear what
a835 1
   -re "type = enum PrivEnum \\{red, green, blue, yellow = 42\\}.*$gdb_prompt $" { pass "ptype obj_with_enum.priv_enum" }
@


