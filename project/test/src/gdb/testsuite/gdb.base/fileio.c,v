head	1.11;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.11
	gdb_7_6-2013-04-26-release:1.11
	gdb_7_6-branch:1.11.0.12
	gdb_7_6-2013-03-12-branchpoint:1.11
	gdb_7_5_1-2012-11-29-release:1.11
	gdb_7_5-2012-08-17-release:1.11
	gdb_7_5-branch:1.11.0.10
	gdb_7_5-2012-07-18-branchpoint:1.11
	gdb_7_4_1-2012-04-26-release:1.11
	gdb_7_4-2012-01-24-release:1.11
	gdb_7_4-branch:1.11.0.8
	gdb_7_4-2011-12-13-branchpoint:1.11
	gdb_7_3_1-2011-09-04-release:1.11
	gdb_7_3-2011-07-26-release:1.11
	gdb_7_3-branch:1.11.0.6
	gdb_7_3-2011-04-01-branchpoint:1.11
	gdb_7_2-2010-09-02-release:1.11
	gdb_7_2-branch:1.11.0.4
	gdb_7_2-2010-07-07-branchpoint:1.11
	gdb_7_1-2010-03-18-release:1.11
	gdb_7_1-branch:1.11.0.2
	gdb_7_1-2010-02-18-branchpoint:1.11
	gdb_7_0_1-2009-12-22-release:1.10
	gdb_7_0-2009-10-06-release:1.10
	gdb_7_0-branch:1.10.0.26
	gdb_7_0-2009-09-16-branchpoint:1.10
	arc-sim-20090309:1.10
	msnyder-checkpoint-072509-branch:1.10.0.24
	msnyder-checkpoint-072509-branchpoint:1.10
	arc-insight_6_8-branch:1.10.0.22
	arc-insight_6_8-branchpoint:1.10
	insight_6_8-branch:1.10.0.20
	insight_6_8-branchpoint:1.10
	reverse-20081226-branch:1.10.0.18
	reverse-20081226-branchpoint:1.10
	multiprocess-20081120-branch:1.10.0.16
	multiprocess-20081120-branchpoint:1.10
	reverse-20080930-branch:1.10.0.14
	reverse-20080930-branchpoint:1.10
	reverse-20080717-branch:1.10.0.12
	reverse-20080717-branchpoint:1.10
	msnyder-reverse-20080609-branch:1.10.0.10
	msnyder-reverse-20080609-branchpoint:1.10
	drow-reverse-20070409-branch:1.10.0.8
	drow-reverse-20070409-branchpoint:1.10
	gdb_6_8-2008-03-27-release:1.10
	gdb_6_8-branch:1.10.0.6
	gdb_6_8-2008-02-26-branchpoint:1.10
	gdb_6_7_1-2007-10-29-release:1.10
	gdb_6_7-2007-10-10-release:1.10
	gdb_6_7-branch:1.10.0.4
	gdb_6_7-2007-09-07-branchpoint:1.10
	insight_6_6-20070208-release:1.10
	gdb_6_6-2006-12-18-release:1.10
	gdb_6_6-branch:1.10.0.2
	gdb_6_6-2006-11-15-branchpoint:1.10
	insight_6_5-20061003-release:1.8
	gdb-csl-symbian-6_4_50_20060226-12:1.8
	gdb-csl-sourcerygxx-3_4_4-25:1.8
	nickrob-async-20060828-mergepoint:1.10
	gdb-csl-symbian-6_4_50_20060226-11:1.8
	gdb-csl-sourcerygxx-4_1-17:1.8.12.2
	gdb-csl-20060226-branch-local-2:1.8.12.2
	gdb-csl-sourcerygxx-4_1-14:1.8.12.2
	gdb-csl-sourcerygxx-4_1-13:1.8.12.2
	gdb-csl-sourcerygxx-4_1-12:1.8.12.2
	gdb-csl-sourcerygxx-3_4_4-21:1.8.12.2
	gdb_6_5-20060621-release:1.8
	gdb-csl-sourcerygxx-4_1-9:1.8.12.2
	gdb-csl-sourcerygxx-4_1-8:1.8.12.2
	gdb-csl-sourcerygxx-4_1-7:1.8.12.1
	gdb-csl-arm-2006q1-6:1.8.12.1
	gdb-csl-sourcerygxx-4_1-6:1.8.12.1
	gdb-csl-symbian-6_4_50_20060226-10:1.8
	gdb-csl-symbian-6_4_50_20060226-9:1.8
	gdb-csl-symbian-6_4_50_20060226-8:1.8
	gdb-csl-coldfire-4_1-11:1.8
	gdb-csl-sourcerygxx-3_4_4-19:1.8
	gdb-csl-coldfire-4_1-10:1.8
	gdb_6_5-branch:1.8.0.26
	gdb_6_5-2006-05-14-branchpoint:1.8
	gdb-csl-sourcerygxx-4_1-5:1.8
	nickrob-async-20060513-branch:1.8.0.24
	nickrob-async-20060513-branchpoint:1.8
	gdb-csl-sourcerygxx-4_1-4:1.8
	msnyder-reverse-20060502-branch:1.8.0.22
	msnyder-reverse-20060502-branchpoint:1.8
	gdb-csl-morpho-4_1-4:1.8
	gdb-csl-sourcerygxx-3_4_4-17:1.8
	readline_5_1-import-branch:1.8.0.20
	readline_5_1-import-branchpoint:1.8
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.8
	gdb-csl-symbian-20060226-branch:1.8.0.18
	gdb-csl-symbian-20060226-branchpoint:1.8
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.8
	msnyder-reverse-20060331-branch:1.8.0.16
	msnyder-reverse-20060331-branchpoint:1.8
	gdb-csl-available-20060303-branch:1.8.0.14
	gdb-csl-available-20060303-branchpoint:1.8
	gdb-csl-20060226-branch:1.8.0.12
	gdb-csl-20060226-branchpoint:1.8
	gdb_6_4-20051202-release:1.8
	msnyder-fork-checkpoint-branch:1.8.0.10
	msnyder-fork-checkpoint-branchpoint:1.8
	gdb-csl-gxxpro-6_3-branch:1.8.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.8
	gdb_6_4-branch:1.8.0.6
	gdb_6_4-2005-11-01-branchpoint:1.8
	gdb-csl-arm-20051020-branch:1.8.0.4
	gdb-csl-arm-20051020-branchpoint:1.8
	gdb-csl-arm-20050325-2005-q1b:1.8
	gdb-csl-arm-20050325-2005-q1a:1.8
	csl-arm-20050325-branch:1.8.0.2
	csl-arm-20050325-branchpoint:1.8
	gdb-post-i18n-errorwarning-20050211:1.8
	gdb-pre-i18n-errorwarning-20050211:1.8
	gdb_6_3-20041109-release:1.7
	gdb_6_3-branch:1.7.0.14
	gdb_6_3-20041019-branchpoint:1.7
	drow_intercu-merge-20040921:1.7
	drow_intercu-merge-20040915:1.7
	jimb-gdb_6_2-e500-branch:1.7.0.16
	jimb-gdb_6_2-e500-branchpoint:1.7
	gdb_6_2-20040730-release:1.7
	gdb_6_2-branch:1.7.0.12
	gdb_6_2-2004-07-10-gmt-branchpoint:1.7
	gdb_6_1_1-20040616-release:1.7
	gdb_6_1-2004-04-05-release:1.7
	drow_intercu-merge-20040402:1.7
	drow_intercu-merge-20040327:1.7
	ezannoni_pie-20040323-branch:1.7.0.10
	ezannoni_pie-20040323-branchpoint:1.7
	cagney_tramp-20040321-mergepoint:1.7
	cagney_tramp-20040309-branch:1.7.0.8
	cagney_tramp-20040309-branchpoint:1.7
	gdb_6_1-branch:1.7.0.6
	gdb_6_1-2004-03-01-gmt-branchpoint:1.7
	drow_intercu-20040221-branch:1.7.0.4
	drow_intercu-20040221-branchpoint:1.7
	cagney_bfdfile-20040213-branch:1.7.0.2
	cagney_bfdfile-20040213-branchpoint:1.7
	drow-cplus-merge-20040208:1.7
	carlton_dictionary-20040126-merge:1.6
	cagney_bigcore-20040122-branch:1.6.0.2
	cagney_bigcore-20040122-branchpoint:1.6
	drow-cplus-merge-20040113:1.6
	drow-cplus-merge-20031224:1.2
	drow-cplus-merge-20031220:1.2
	carlton_dictionary-20031215-merge:1.2
	drow-cplus-branch:1.2.0.12
	drow-cplus-merge-20031214:1.2
	carlton-dictionary-20031111-merge:1.2
	gdb_6_0-2003-10-04-release:1.2
	kettenis_sparc-20030918-branch:1.2.0.10
	kettenis_sparc-20030918-branchpoint:1.2
	carlton_dictionary-20030917-merge:1.2
	ezannoni_pie-20030916-branchpoint:1.2
	ezannoni_pie-20030916-branch:1.2.0.8
	cagney_x86i386-20030821-branch:1.2.0.6
	cagney_x86i386-20030821-branchpoint:1.2
	carlton_dictionary-20030805-merge:1.2
	carlton_dictionary-branch:1.2.0.4
	carlton_dictionary-20030627-merge:1.2
	gdb_6_0-branch:1.2.0.2
	gdb_6_0-2003-06-23-branchpoint:1.2
	jimb-ppc64-linux-20030613-branch:1.1.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.1;
locks; strict;
comment	@ * @;


1.11
date	2009.10.01.15.39.13;	author muller;	state Exp;
branches;
next	1.10;

1.10
date	2006.06.13.08.55.22;	author nathan;	state Exp;
branches;
next	1.9;

1.9
date	2006.06.13.08.46.17;	author nathan;	state Exp;
branches;
next	1.8;

1.8
date	2005.01.10.15.58.23;	author corinna;	state Exp;
branches
	1.8.12.1
	1.8.24.1;
next	1.7;

1.7
date	2004.02.01.18.51.29;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2004.01.07.16.39.02;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.07.16.02.27;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.02.22.53.12;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2004.01.02.17.35.01;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2003.06.14.16.51.42;	author cagney;	state Exp;
branches
	1.2.4.1
	1.2.8.1
	1.2.12.1;
next	1.1;

1.1
date	2003.06.10.14.38.04;	author corinna;	state Exp;
branches;
next	;

1.8.12.1
date	2006.06.05.15.36.02;	author nathan;	state Exp;
branches;
next	1.8.12.2;

1.8.12.2
date	2006.06.09.20.25.26;	author nathan;	state Exp;
branches;
next	;

1.8.24.1
date	2006.08.28.07.48.42;	author nickrob;	state Exp;
branches;
next	;

1.2.4.1
date	2003.06.27.21.50.20;	author carlton;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2004.01.26.19.11.41;	author carlton;	state Exp;
branches;
next	;

1.2.8.1
date	2004.03.23.20.12.32;	author ezannoni;	state Exp;
branches;
next	;

1.2.12.1
date	2003.12.14.20.27.47;	author drow;	state Exp;
branches;
next	1.2.12.2;

1.2.12.2
date	2004.01.13.16.12.11;	author drow;	state Exp;
branches;
next	1.2.12.3;

1.2.12.3
date	2004.02.09.19.43.55;	author drow;	state Exp;
branches;
next	;


desc
@@


1.11
log
@	* gdb.base/fileio.c (test_lseek): typecast ofs_t ret variable to
	long type.
	(test_unlink): Correct printf string.
	* gdb.base/checkpoint.c (main): Correct fprintf string for variable i.
	* gdb.threads/attachstop-mt.c: Add #include <string.h>.
@
text
@#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/errno.h>
#include <sys/types.h>
#include <sys/fcntl.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <errno.h>
#include <sys/wait.h>
#include <unistd.h>
/* TESTS :
 * - open(const char *pathname, int flags, mode_t mode);
1) Attempt to create file that already exists - EEXIST
2) Attempt to open a directory for writing - EISDIR
3) Pathname does not exist - ENOENT
4) Open for write but no write permission - EACCES   

read(int fd, void *buf, size_t count);
1) Read using invalid file descriptor - EBADF

write(int fd, const void *buf, size_t count);
1) Write using invalid file descriptor - EBADF
2) Attempt to write to read-only file - EBADF

lseek(int fildes, off_t offset, int whence);
1) Seeking on an invalid file descriptor - EBADF
2) Invalid "whence" (3rd param) value -  EINVAL

close(int fd);
1) Attempt to close an invalid file descriptor - EBADF

stat(const char *file_name, struct stat *buf);
1) Pathname is a null string -  ENOENT
2) Pathname does not exist - ENOENT

fstat(int filedes, struct stat *buf);
1) Attempt to stat using an invalid file descriptor - EBADF

isatty (int desc);
Not applicable. We will test that it returns 1 when expected and a case
where it should return 0.

rename(const char *oldpath, const char *newpath);
1) newpath is an existing directory, but oldpath is not a directory. - EISDIR
2) newpath is a non-empty directory. - ENOTEMPTY or EEXIST
3) newpath is a subdirectory of old path. - EINVAL
4) oldpath does not exist. - ENOENT

unlink(const char *pathname);
1) pathname does not have write access. - EACCES
2) pathname does not exist. - ENOENT

time(time_t *t);
Not applicable.

system (const char * string);
1) Invalid string/command. -  returns 127.  */
static const char *strerrno (int err);

#define FILENAME    "foo.fileio.test"
#define RENAMED     "bar.fileio.test"
#define NONEXISTANT "nofoo.fileio.test"
#define NOWRITE     "nowrt.fileio.test"
#define TESTDIR1     "dir1.fileio.test"
#define TESTDIR2     "dir2.fileio.test"
#define TESTSUBDIR   "dir1.fileio.test/subdir.fileio.test"

#define STRING      "Hello World"

static void stop () {}

int
test_open ()
{
  int ret;

  /* Test opening */
  errno = 0;
  ret = open (FILENAME, O_CREAT | O_TRUNC | O_RDWR, S_IWUSR | S_IRUSR);
  printf ("open 1: ret = %d, errno = %d %s\n", ret, errno,
	  ret >= 0 ? "OK" : "");
  
  if (ret >= 0)
    close (ret);
  stop ();
  /* Creating an already existing file (created by fileio.exp) */
  errno = 0;
  ret = open (FILENAME, O_CREAT | O_EXCL | O_WRONLY, S_IWUSR | S_IRUSR);
  printf ("open 2: ret = %d, errno = %d %s\n", ret, errno,
	  strerrno (errno));
  if (ret >= 0)
    close (ret);
  stop ();
  /* Open directory (for writing) */
  errno = 0;
  ret = open (".", O_WRONLY);
  printf ("open 3: ret = %d, errno = %d %s\n", ret, errno,
	  strerrno (errno));
  if (ret >= 0)
    close (ret);
  stop ();
  /* Opening nonexistant file */
  errno = 0;
  ret = open (NONEXISTANT, O_RDONLY);
  printf ("open 4: ret = %d, errno = %d %s\n", ret, errno,
	  strerrno (errno));
  if (ret >= 0)
    close (ret);
  stop ();
  /* Open for write but no write permission */
  errno = 0;
  ret = open (NOWRITE, O_CREAT | O_RDONLY, S_IRUSR);
  if (ret >= 0)
    {
      close (ret);
      stop ();
      errno = 0;
      ret = open (NOWRITE, O_WRONLY);
      printf ("open 5: ret = %d, errno = %d %s\n", ret, errno,
	      strerrno (errno));
      if (ret >= 0)
	close (ret);
    }
  else
    {
      stop ();
      printf ("open 5: ret = %d, errno = %d\n", ret, errno);
    }
  stop ();
}

int
test_write ()
{
  int fd, ret;

  /* Test writing */
  errno = 0;
  fd = open (FILENAME, O_WRONLY);
  if (fd >= 0)
    {
      errno = 0;
      ret = write (fd, STRING, strlen (STRING));
      printf ("write 1: ret = %d, errno = %d %s\n", ret, errno,
              ret == strlen (STRING) ? "OK" : "");
      close (fd);
    }
  else
    printf ("write 1: ret = %d, errno = %d\n", ret, errno);
  stop ();
  /* Write using invalid file descriptor */
  errno = 0;
  ret = write (999, STRING, strlen (STRING));
  printf ("write 2: ret = %d, errno = %d, %s\n", ret, errno,
	  strerrno (errno));
  stop ();
  /* Write to a read-only file */
  errno = 0;
  fd = open (FILENAME, O_RDONLY);
  if (fd >= 0)
    {
      errno = 0;
      ret = write (fd, STRING, strlen (STRING));
      printf ("write 3: ret = %d, errno = %d %s\n", ret, errno,
	      strerrno (errno));
    }
  else
    printf ("write 3: ret = %d, errno = %d\n", ret, errno);
  stop ();
}

int
test_read ()
{
  int fd, ret;
  char buf[16];

  /* Test reading */
  errno = 0;
  fd = open (FILENAME, O_RDONLY);
  if (fd >= 0)
    {
      memset (buf, 0, 16);
      errno = 0;
      ret = read (fd, buf, 16);
      buf[15] = '\0'; /* Don't trust anybody... */
      if (ret == strlen (STRING))
        printf ("read 1: %s %s\n", buf, !strcmp (buf, STRING) ? "OK" : "");
      else
	printf ("read 1: ret = %d, errno = %d\n", ret, errno);
      close (fd);
    }
  else
    printf ("read 1: ret = %d, errno = %d\n", ret, errno);
  stop ();
  /* Read using invalid file descriptor */
  errno = 0;
  ret = read (999, buf, 16);
  printf ("read 2: ret = %d, errno = %d %s\n", ret, errno,
	  strerrno (errno));
  stop ();
}

int
test_lseek ()
{
  int fd;
  off_t ret = 0;

  /* Test seeking */
  errno = 0;
  fd = open (FILENAME, O_RDONLY);
  if (fd >= 0)
    {
      errno = 0;
      ret = lseek (fd, 0, SEEK_CUR);
      printf ("lseek 1: ret = %ld, errno = %d, %s\n", (long) ret, errno,
              ret == 0 ? "OK" : "");
      stop ();
      errno = 0;
      ret = lseek (fd, 0, SEEK_END);
      printf ("lseek 2: ret = %ld, errno = %d, %s\n", (long) ret, errno,
              ret == 11 ? "OK" : "");
      stop ();
      errno = 0;
      ret = lseek (fd, 3, SEEK_SET);
      printf ("lseek 3: ret = %ld, errno = %d, %s\n", (long) ret, errno,
              ret == 3 ? "OK" : "");
      close (fd);
    }
  else
    {
      printf ("lseek 1: ret = %ld, errno = %d %s\n", (long) ret, errno,
	      strerrno (errno));
      stop ();
      printf ("lseek 2: ret = %ld, errno = %d %s\n", (long) ret, errno,
	      strerrno (errno));
      stop ();
      printf ("lseek 3: ret = %ld, errno = %d %s\n", (long) ret, errno,
	      strerrno (errno));
    }
  /* Seeking on an invalid file descriptor */
  stop ();
}

int
test_close ()
{
  int fd, ret;

  /* Test close */
  errno = 0;
  fd = open (FILENAME, O_RDONLY);
  if (fd >= 0)
    {
      errno = 0;
      ret = close (fd);
      printf ("close 1: ret = %d, errno = %d, %s\n", ret, errno,
              ret == 0 ? "OK" : "");
    }
  else
    printf ("close 1: ret = %d, errno = %d\n", ret, errno);
  stop ();
  /* Close an invalid file descriptor */
  errno = 0;
  ret = close (999);
  printf ("close 2: ret = %d, errno = %d, %s\n", ret, errno,
  	  strerrno (errno));
  stop ();
}

int
test_stat ()
{
  int ret;
  struct stat st;

  /* Test stat */
  errno = 0;
  ret = stat (FILENAME, &st);
  if (!ret)
    printf ("stat 1: ret = %d, errno = %d %s\n", ret, errno,
	    st.st_size == 11 ? "OK" : "");
  else
    printf ("stat 1: ret = %d, errno = %d\n", ret, errno);
  stop ();
  /* NULL pathname */
  errno = 0;
  ret = stat (NULL, &st);
  printf ("stat 2: ret = %d, errno = %d %s\n", ret, errno,
  	  strerrno (errno));
  stop ();
  /* Empty pathname */
  errno = 0;
  ret = stat ("", &st);
  printf ("stat 3: ret = %d, errno = %d %s\n", ret, errno,
  	  strerrno (errno));
  stop ();
  /* Nonexistant file */
  errno = 0;
  ret = stat (NONEXISTANT, &st);
  printf ("stat 4: ret = %d, errno = %d %s\n", ret, errno,
  	  strerrno (errno));
  stop ();
}

int
test_fstat ()
{
  int fd, ret;
  struct stat st;

  /* Test fstat */
  errno = 0;
  fd = open (FILENAME, O_RDONLY);
  if (fd >= 0)
    {
      errno = 0;
      ret = fstat (fd, &st);
      if (!ret)
	printf ("fstat 1: ret = %d, errno = %d %s\n", ret, errno,
		st.st_size == 11 ? "OK" : "");
      else
	printf ("fstat 1: ret = %d, errno = %d\n", ret, errno);
      close (fd);
    }
  else
    printf ("fstat 1: ret = %d, errno = %d\n", ret, errno);
  stop ();
  /* Fstat using invalid file descriptor */
  errno = 0;
  ret = fstat (999, &st);
  printf ("fstat 2: ret = %d, errno = %d %s\n", ret, errno,
  	  strerrno (errno));
  stop ();
}

int
test_isatty ()
{
  int fd;

  /* Check std I/O */
  printf ("isatty 1: stdin %s\n", isatty (0) ? "yes OK" : "no");
  stop ();
  printf ("isatty 2: stdout %s\n", isatty (1) ? "yes OK" : "no");
  stop ();
  printf ("isatty 3: stderr %s\n", isatty (2) ? "yes OK" : "no");
  stop ();
  /* Check invalid fd */
  printf ("isatty 4: invalid %s\n", isatty (999) ? "yes" : "no OK");
  stop ();
  /* Check open file */
  fd = open (FILENAME, O_RDONLY);
  if (fd >= 0)
    {
      printf ("isatty 5: file %s\n", isatty (fd) ? "yes" : "no OK");
      close (fd);
    }
  else
    printf ("isatty 5: file couldn't open\n");
  stop ();
}


int
test_system ()
{
  /*
   * Requires test framework to switch on "set remote system-call-allowed 1"
   */
  int ret;
  char sys[512];

  /* Test for shell */
  ret = system (NULL);
  printf ("system 1: ret = %d %s\n", ret, ret != 0 ? "OK" : "");
  stop ();
  /* This test prepares the directory for test_rename() */
  sprintf (sys, "mkdir -p %s %s", TESTSUBDIR, TESTDIR2);
  ret = system (sys);
  if (ret == 127)
    printf ("system 2: ret = %d /bin/sh unavailable???\n", ret);
  else
    printf ("system 2: ret = %d %s\n", ret, ret == 0 ? "OK" : "");
  stop ();
  /* Invalid command (just guessing ;-) ) */
  ret = system ("wrtzlpfrmpft");
  printf ("system 3: ret = %d %s\n", ret, WEXITSTATUS (ret) == 127 ? "OK" : "");
  stop ();
}

int
test_rename ()
{
  int ret;
  struct stat st;

  /* Test rename */
  errno = 0;
  ret = rename (FILENAME, RENAMED);
  if (!ret)
    {
      errno = 0;
      ret = stat (FILENAME, &st);
      if (ret && errno == ENOENT)
        {
	  errno = 0;
	  ret = stat (RENAMED, &st);
	  printf ("rename 1: ret = %d, errno = %d %s\n", ret, errno,
		  strerrno (errno));
	  errno = 0;
	}
      else
	printf ("rename 1: ret = %d, errno = %d\n", ret, errno);
    }
  else
    printf ("rename 1: ret = %d, errno = %d\n", ret, errno);
  stop ();
  /* newpath is existing directory, oldpath is not a directory */
  errno = 0;
  ret = rename (RENAMED, TESTDIR2);
  printf ("rename 2: ret = %d, errno = %d %s\n", ret, errno,
	  strerrno (errno));
  stop ();
  /* newpath is a non-empty directory */
  errno = 0;
  ret = rename (TESTDIR2, TESTDIR1);
  printf ("rename 3: ret = %d, errno = %d %s\n", ret, errno,
          strerrno (errno));
  stop ();
  /* newpath is a subdirectory of old path */
  errno = 0;
  ret = rename (TESTDIR1, TESTSUBDIR);
  printf ("rename 4: ret = %d, errno = %d %s\n", ret, errno,
	  strerrno (errno));
  stop ();
  /* oldpath does not exist */
  errno = 0;
  ret = rename (NONEXISTANT, FILENAME);
  printf ("rename 5: ret = %d, errno = %d %s\n", ret, errno,
	  strerrno (errno));
  stop ();
}

int
test_unlink ()
{
  int ret;
  char name[256];
  char sys[512];

  /* Test unlink */
  errno = 0;
  ret = unlink (RENAMED);
  printf ("unlink 1: ret = %d, errno = %d %s\n", ret, errno,
	  strerrno (errno));
  stop ();
  /* No write access */
  sprintf (name, "%s/%s", TESTDIR2, FILENAME);
  errno = 0;
  ret = open (name, O_CREAT | O_RDONLY, S_IRUSR | S_IWUSR);
  if (ret >= 0)
    {
      sprintf (sys, "chmod -w %s", TESTDIR2);
      ret = system (sys);
      if (!ret)
        {
	  errno = 0;
	  ret = unlink (name);
	  printf ("unlink 2: ret = %d, errno = %d %s\n", ret, errno,
		  strerrno (errno));
        }
      else
	printf ("unlink 2: ret = %d chmod failed, errno= %d\n", ret, errno);
    }
  else
    printf ("unlink 2: ret = %d, errno = %d\n", ret, errno);
  stop ();
  /* pathname doesn't exist */
  errno = 0;
  ret = unlink (NONEXISTANT);
  printf ("unlink 3: ret = %d, errno = %d %s\n", ret, errno,
          strerrno (errno));
  stop ();
}

int
test_time ()
{
  time_t ret, t;

  errno = 0;
  ret = time (&t);
  printf ("time 1: ret = %ld, errno = %d, t = %ld %s\n", (long) ret, errno, (long) t, ret == t ? "OK" : "");
  stop ();
  errno = 0;
  ret = time (NULL);
  printf ("time 2: ret = %ld, errno = %d, t = %ld %s\n",
	  (long) ret, errno, (long) t, ret >= t && ret < t + 10 ? "OK" : "");
  stop ();
}

static const char *
strerrno (int err)
{
  switch (err)
    {
    case 0: return "OK";
#ifdef EACCES
    case EACCES: return "EACCES";
#endif
#ifdef EBADF
    case EBADF: return "EBADF";
#endif
#ifdef EEXIST
    case EEXIST: return "EEXIST";
#endif
#ifdef EFAULT
    case EFAULT: return "EFAULT";
#endif
#ifdef EINVAL
    case EINVAL: return "EINVAL";
#endif
#ifdef EISDIR
    case EISDIR: return "EISDIR";
#endif
#ifdef ENOENT
    case ENOENT: return "ENOENT";
#endif
#ifdef ENOTEMPTY
    case ENOTEMPTY: return "ENOTEMPTY";
#endif
#ifdef EBUSY
    case EBUSY: return "EBUSY";
#endif
    default: return "E??";
    }
}

int
main ()
{
  /* Don't change the order of the calls.  They partly depend on each other */
  test_open ();
  test_write ();
  test_read ();
  test_lseek ();
  test_close ();
  test_stat ();
  test_fstat ();
  test_isatty ();
  test_system ();
  test_rename ();
  test_unlink ();
  test_time ();
  return 0;
}
@


1.10
log
@	gdb/
	* remote-file.io.c (remote_fileio_func_system): Treat zero length
	string as NULL.  Adjust for NULL pointer argument.
	* doc/gdb.texinfo (system): Document behaviour with zero length
	string.

	gdb/testsuite/
	* gdb.base/fileio.c: Add system(NULL) test.
	* gdb.base/fileio.exp: Check it.
@
text
@d234 1
a234 1
      printf ("lseek 1: ret = %d, errno = %d %s\n", ret, errno,
d237 1
a237 1
      printf ("lseek 2: ret = %d, errno = %d %s\n", ret, errno,
d240 1
a240 1
      printf ("lseek 3: ret = %d, errno = %d %s\n", ret, errno,
d476 1
a476 1
	printf ("unlink 2: ret = %d chmod failed\n", ret, errno);
@


1.9
log
@	* gdb.base/break.c: Add 10a breakpoint at }
	* gdb.base/break.exp: Add test for breakpoint at }
	* gdb.cp/anon-union.cc: Add code at end of function.
	* gdb.cp/anon-union.exp: Adjust end of function breakpoint.
	* gdb.mi/var-cmd.c: Add code at end of function.
	* gdb.mi/mi-var-display.exp: Adjust end of next.
	* gdb.mi/mi2-var-display.exp: Likewise.
	* gdb.base/fileio.c: Add stop function and insert calls at
	stopping places.
	* gdb.base/fileio.exp: Breakpoint stop function and remove
	explicit line number references.
@
text
@d376 4
d384 1
a384 1
    printf ("system 1: ret = %d /bin/sh unavailable???\n", ret);
d386 1
a386 1
    printf ("system 1: ret = %d %s\n", ret, ret == 0 ? "OK" : "");
d390 1
a390 1
  printf ("system 2: ret = %d %s\n", ret, WEXITSTATUS (ret) == 127 ? "OK" : "");
@


1.8
log
@	* gdb.base/fileio.c: Include unistd.h as required for lseek(2).
@
text
@d71 2
d83 1
d86 1
d94 1
d102 1
d110 1
d117 1
d126 5
a130 1
    printf ("open 5: ret = %d, errno = %d\n", ret, errno);
d151 1
d157 1
d170 1
d196 1
d202 1
d220 1
d225 1
d234 8
a241 3
      printf ("lseek 1: ret = %d, errno = %d\n", ret, errno);
      printf ("lseek 2: ret = %d, errno = %d\n", ret, errno);
      printf ("lseek 3: ret = %d, errno = %d\n", ret, errno);
d244 1
a244 1

d264 1
d270 1
d287 1
d293 1
d299 1
d305 1
d330 1
d336 1
d346 1
d348 1
d350 1
d353 1
d363 1
d383 1
d387 1
d416 1
d422 1
d428 1
d434 1
d440 1
d455 1
d476 1
d482 1
d493 1
d498 1
@


1.8.24.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@a70 2
static void stop () {}

a80 1
  
a82 1
  stop ();
a89 1
  stop ();
a96 1
  stop ();
a103 1
  stop ();
a109 1
      stop ();
d118 1
a118 5
    {
      stop ();
      printf ("open 5: ret = %d, errno = %d\n", ret, errno);
    }
  stop ();
a138 1
  stop ();
a143 1
  stop ();
a155 1
  stop ();
a180 1
  stop ();
a185 1
  stop ();
a202 1
      stop ();
a206 1
      stop ();
d215 3
a217 8
      printf ("lseek 1: ret = %d, errno = %d %s\n", ret, errno,
	      strerrno (errno));
      stop ();
      printf ("lseek 2: ret = %d, errno = %d %s\n", ret, errno,
	      strerrno (errno));
      stop ();
      printf ("lseek 3: ret = %d, errno = %d %s\n", ret, errno,
	      strerrno (errno));
d220 1
a220 1
  stop ();
a239 1
  stop ();
a244 1
  stop ();
a260 1
  stop ();
a265 1
  stop ();
a270 1
  stop ();
a275 1
  stop ();
a299 1
  stop ();
a304 1
  stop ();
a313 1
  stop ();
a314 1
  stop ();
a315 1
  stop ();
a317 1
  stop ();
a326 1
  stop ();
a338 4
  /* Test for shell */
  ret = system (NULL);
  printf ("system 1: ret = %d %s\n", ret, ret != 0 ? "OK" : "");
  stop ();
d343 1
a343 1
    printf ("system 2: ret = %d /bin/sh unavailable???\n", ret);
d345 1
a345 2
    printf ("system 2: ret = %d %s\n", ret, ret == 0 ? "OK" : "");
  stop ();
d348 1
a348 2
  printf ("system 3: ret = %d %s\n", ret, WEXITSTATUS (ret) == 127 ? "OK" : "");
  stop ();
a376 1
  stop ();
a381 1
  stop ();
a386 1
  stop ();
a391 1
  stop ();
a396 1
  stop ();
a410 1
  stop ();
a430 1
  stop ();
a435 1
  stop ();
a445 1
  stop ();
a449 1
  stop ();
@


1.8.12.1
log
@	* gdb/testsuite/gdb.asm/m68k.inc (gdbasm_call): Use jsr.
	* gdb/testsuite/gdb.base/fileio.c (stop): New.  Call it everywhere
	the debugger should stop.
	* gdb/testsuite/gdb.base/charset.exp: Add breakpoint to stop
	routine and adjust.
@
text
@a70 2
static void stop () {}

a80 1
  
a82 1
  stop ();
a89 1
  stop ();
a96 1
  stop ();
a103 1
  stop ();
a109 1
      stop ();
d118 1
a118 5
    {
      stop ();
      printf ("open 5: ret = %d, errno = %d\n", ret, errno);
    }
  stop ();
a138 1
  stop ();
a143 1
  stop ();
a155 1
  stop ();
a180 1
  stop ();
a185 1
  stop ();
a202 1
      stop ();
a206 1
      stop ();
d215 3
a217 8
      printf ("lseek 1: ret = %d, errno = %d %s\n", ret, errno,
	      strerrno (errno));
      stop ();
      printf ("lseek 2: ret = %d, errno = %d %s\n", ret, errno,
	      strerrno (errno));
      stop ();
      printf ("lseek 3: ret = %d, errno = %d %s\n", ret, errno,
	      strerrno (errno));
d220 1
a220 1
  stop ();
a239 1
  stop ();
a244 1
  stop ();
a260 1
  stop ();
a265 1
  stop ();
a270 1
  stop ();
a275 1
  stop ();
a299 1
  stop ();
a304 1
  stop ();
a313 1
  stop ();
a314 1
  stop ();
a315 1
  stop ();
a317 1
  stop ();
a326 1
  stop ();
a345 1
  stop ();
a348 1
  stop ();
a376 1
  stop ();
a381 1
  stop ();
a386 1
  stop ();
a391 1
  stop ();
a396 1
  stop ();
a410 1
  stop ();
a430 1
  stop ();
a435 1
  stop ();
a445 1
  stop ();
a449 1
  stop ();
@


1.8.12.2
log
@	gdb/
	* remote-file.io.c (remote_fileio_func_system): Treat zero length
	string as NULL.  Adjust for NULL pointer argument.
	* doc/gdb.texinfo (system): Document behaviour with zero length
	string.

	gdb/testsuite/
	* gdb.base/fileio.c: Add system(NULL) test.
	* gdb.base/fileio.exp: Check it.
@
text
@a387 4
  /* Test for shell */
  ret = system (NULL);
  printf ("system 3: ret = %d %s\n", ret, ret != 0 ? "OK" : "");
  stop ();
@


1.7
log
@* gdb.base/fileio.c (test_open): Replace O_RDONLY with O_RDWR such
that opening the file succeeds on OpenBSD.
@
text
@d11 1
a58 1

@


1.6
log
@2004-01-07  Andrew Cagney  <cagney@@redhat.com>

	* gdb.base/fileio.c (strerrno): Add "EBUSY".
@
text
@d78 1
a78 1
  ret = open (FILENAME, O_CREAT | O_TRUNC | O_RDONLY, S_IWUSR | S_IRUSR);
@


1.5
log
@2004-01-07  Andrew Cagney  <cagney@@redhat.com>

	* gdb.base/fileio.c (test_open): Do not pass S_IWUSR to "open"
	when creating the read-only file.  From analysis by Roland McGrath
	and Elena Zannoni.
@
text
@d482 3
@


1.4
log
@Revert accidental commit.
@
text
@d106 1
a106 1
  ret = open (NOWRITE, O_CREAT | O_RDONLY, S_IRUSR | S_IWUSR);
@


1.3
log
@2004-01-02  Andrew Cagney  <cagney@@redhat.com>

	* utils.c (do_my_cleanups): Make static, add forward declaration.
	* defs.h (do_my_cleanups): Delete declaration.
@
text
@d106 1
a106 1
  ret = open (NOWRITE, O_CREAT | O_RDONLY, S_IRUSR);
@


1.2
log
@2003-06-14  Andrew Cagney  <cagney@@redhat.com>

	* gdb.base/fileio.c: Include <errno.h>, and <sys/wait.h>.  Gag
	-Wformat errors.  Add lost line.  Use WEXITSTATUS to get system
	exit status.
	* gdb.base/fileio.exp: Disable target when nointerrupts and
	noinferiorio, instead of limiting it to remote.  Use remote_exec
	instead of system.
@
text
@d106 1
a106 1
  ret = open (NOWRITE, O_CREAT | O_RDONLY, S_IRUSR | S_IWUSR);
@


1.2.8.1
log
@merge mainline changes into branch
@
text
@d78 1
a78 1
  ret = open (FILENAME, O_CREAT | O_TRUNC | O_RDWR, S_IWUSR | S_IRUSR);
d106 1
a106 1
  ret = open (NOWRITE, O_CREAT | O_RDONLY, S_IRUSR);
a480 3
#endif
#ifdef EBUSY
    case EBUSY: return "EBUSY";
@


1.2.12.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.2.12.2
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d106 1
a106 1
  ret = open (NOWRITE, O_CREAT | O_RDONLY, S_IRUSR);
a480 3
#endif
#ifdef EBUSY
    case EBUSY: return "EBUSY";
@


1.2.12.3
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d78 1
a78 1
  ret = open (FILENAME, O_CREAT | O_TRUNC | O_RDWR, S_IWUSR | S_IRUSR);
@


1.2.4.1
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@@


1.2.4.2
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d106 1
a106 1
  ret = open (NOWRITE, O_CREAT | O_RDONLY, S_IRUSR);
a480 3
#endif
#ifdef EBUSY
    case EBUSY: return "EBUSY";
@


1.1
log
@	* gdb.base/fileio.c: New file, testing File-I/O.
	* gdb.base/fileio.exp: Ditto.
@
text
@d9 3
a11 2
/**************************************************************************
 * TESTS :
d57 1
a57 1
1) Invalid string/command. -  returns 127.
d59 1
a59 1
 ***************************************************************************/
a64 1

d87 1
a87 1
	  errno == EEXIST ? "OK" : "");
d94 1
a94 1
	  errno == EISDIR ? "OK" : "");
d101 1
a101 1
	  errno == ENOENT ? "OK" : "");
d113 1
a113 1
	      errno == EACCES ? "OK" : "");
d143 1
a143 1
	  errno == EBADF ? "OK" : "");
d152 1
a152 1
	      errno == EBADF ? "OK" : "");
d185 1
a185 1
	  errno == EBADF ? "OK" : "");
d192 1
a192 1
  off_t ret;
d201 1
a201 1
      printf ("lseek 1: ret = %ld, errno = %d, %s\n", ret, errno,
d205 1
a205 1
      printf ("lseek 2: ret = %ld, errno = %d, %s\n", ret, errno,
d209 1
a209 1
      printf ("lseek 3: ret = %ld, errno = %d, %s\n", ret, errno,
d235 1
a235 1
      printf ("close 1: ret = %ld, errno = %d, %s\n", ret, errno,
d243 2
a244 2
  printf ("close 2: ret = %ld, errno = %d, %s\n", ret, errno,
  	  errno == EBADF ? "OK" : "");
d265 1
a265 1
  	  errno == ENOENT ? "OK" : "");
d270 1
a270 1
  	  errno == ENOENT ? "OK" : "");
d275 1
a275 1
  	  errno == ENOENT ? "OK" : "");
d304 1
a304 1
	  errno == EBADF ? "OK" : "");
d329 1
d348 1
a348 1
  printf ("system 2: ret = %d %s\n", ret, ret == 127 ? "OK" : "");
d369 1
a369 1
		  errno == 0 ? "OK" : "");
d381 1
a381 1
          errno == EISDIR ? "OK" : "");
d386 1
a386 1
          errno == ENOTEMPTY || errno == EEXIST ? "OK" : "");
d391 1
a391 1
          errno == EINVAL ? "OK" : "");
d396 1
a396 1
          errno == ENOENT ? "OK" : "");
d410 1
a410 1
          errno == 0 ? "OK" : "");
d424 1
a424 1
		  errno == EACCES ? "OK" : "");
d435 1
a435 1
          errno == ENOENT ? "OK" : "");
d445 1
a445 1
  printf ("time 1: ret = %d, errno = %d, t = %d %s\n", ret, errno, t, ret == t ? "OK" : "");
d448 36
a483 2
  printf ("time 2: ret = %d, errno = %d, t = %d %s\n", ret, errno, t,
          ret >= t && ret < t + 10 ? "OK" : "");
@

