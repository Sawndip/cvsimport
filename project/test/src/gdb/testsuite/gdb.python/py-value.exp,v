head	1.34;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.33
	gdb_7_6-2013-04-26-release:1.33
	gdb_7_6-branch:1.33.0.2
	gdb_7_6-2013-03-12-branchpoint:1.33
	gdb_7_5_1-2012-11-29-release:1.28.2.1
	gdb_7_5-2012-08-17-release:1.28.2.1
	gdb_7_5-branch:1.28.0.2
	gdb_7_5-2012-07-18-branchpoint:1.28
	gdb_7_4_1-2012-04-26-release:1.25.2.1
	gdb_7_4-2012-01-24-release:1.25.2.1
	gdb_7_4-branch:1.25.0.2
	gdb_7_4-2011-12-13-branchpoint:1.25
	gdb_7_3_1-2011-09-04-release:1.19
	gdb_7_3-2011-07-26-release:1.19
	gdb_7_3-branch:1.19.0.2
	gdb_7_3-2011-04-01-branchpoint:1.19
	gdb_7_2-2010-09-02-release:1.13
	gdb_7_2-branch:1.13.0.2
	gdb_7_2-2010-07-07-branchpoint:1.13
	gdb_7_1-2010-03-18-release:1.6
	gdb_7_1-branch:1.6.0.2
	gdb_7_1-2010-02-18-branchpoint:1.6
	gdb_7_0_1-2009-12-22-release:1.1.2.1
	gdb_7_0-2009-10-06-release:1.1.2.1
	gdb_7_0-branch:1.1.0.2
	gdb_7_0-2009-09-16-branchpoint:1.1;
locks; strict;
comment	@# @;


1.34
date	2013.08.07.23.51.45;	author devans;	state Exp;
branches;
next	1.33;

1.33
date	2013.01.01.06.41.26;	author brobecke;	state Exp;
branches;
next	1.32;

1.32
date	2012.12.10.21.22.21;	author pkoning;	state Exp;
branches;
next	1.31;

1.31
date	2012.09.06.17.57.41;	author devans;	state Exp;
branches;
next	1.30;

1.30
date	2012.09.06.17.52.38;	author devans;	state Exp;
branches;
next	1.29;

1.29
date	2012.08.02.15.59.59;	author uweigand;	state Exp;
branches;
next	1.28;

1.28
date	2012.06.22.17.59.33;	author tromey;	state Exp;
branches
	1.28.2.1;
next	1.27;

1.27
date	2012.01.16.16.21.52;	author palves;	state Exp;
branches;
next	1.26;

1.26
date	2012.01.04.08.27.49;	author brobecke;	state Exp;
branches;
next	1.25;

1.25
date	2011.10.25.18.35.49;	author pkoning;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2011.10.03.16.15.26;	author pkoning;	state Exp;
branches;
next	1.23;

1.23
date	2011.10.01.11.02.11;	author jkratoch;	state Exp;
branches;
next	1.22;

1.22
date	2011.07.26.18.38.55;	author uweigand;	state Exp;
branches;
next	1.21;

1.21
date	2011.07.22.18.01.43;	author uweigand;	state Exp;
branches;
next	1.20;

1.20
date	2011.04.24.09.04.38;	author jkratoch;	state Exp;
branches;
next	1.19;

1.19
date	2011.01.01.15.33.49;	author brobecke;	state Exp;
branches;
next	1.18;

1.18
date	2010.11.12.20.49.43;	author tromey;	state Exp;
branches;
next	1.17;

1.17
date	2010.10.01.17.03.50;	author devans;	state Exp;
branches;
next	1.16;

1.16
date	2010.08.30.20.28.31;	author tromey;	state Exp;
branches;
next	1.15;

1.15
date	2010.08.23.20.29.19;	author tromey;	state Exp;
branches;
next	1.14;

1.14
date	2010.07.27.12.40.42;	author pmuldoon;	state Exp;
branches;
next	1.13;

1.13
date	2010.06.08.22.58.03;	author msnyder;	state Exp;
branches;
next	1.12;

1.12
date	2010.06.04.16.40.15;	author tromey;	state Exp;
branches;
next	1.11;

1.11
date	2010.06.03.23.54.18;	author msnyder;	state Exp;
branches;
next	1.10;

1.10
date	2010.06.02.21.50.56;	author msnyder;	state Exp;
branches;
next	1.9;

1.9
date	2010.05.14.11.11.28;	author pmuldoon;	state Exp;
branches;
next	1.8;

1.8
date	2010.04.08.10.28.42;	author pmuldoon;	state Exp;
branches;
next	1.7;

1.7
date	2010.02.24.11.11.16;	author pmuldoon;	state Exp;
branches;
next	1.6;

1.6
date	2010.02.16.21.13.10;	author drow;	state Exp;
branches;
next	1.5;

1.5
date	2010.01.14.08.03.37;	author pmuldoon;	state Exp;
branches;
next	1.4;

1.4
date	2010.01.01.07.32.06;	author brobecke;	state Exp;
branches;
next	1.3;

1.3
date	2009.12.03.18.30.02;	author tromey;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.21.09.32.28;	author pmuldoon;	state Exp;
branches;
next	1.1;

1.1
date	2009.09.09.17.45.42;	author brobecke;	state Exp;
branches
	1.1.2.1;
next	;

1.28.2.1
date	2012.08.02.16.00.51;	author uweigand;	state Exp;
branches;
next	;

1.25.2.1
date	2012.01.06.04.54.27;	author brobecke;	state Exp;
branches;
next	;

1.1.2.1
date	2009.09.21.10.20.00;	author pmuldoon;	state Exp;
branches;
next	;


desc
@@


1.34
log
@	* gdb.python/py-value-cc.cc: Renamed from py-value.cc.
	* gdb.python/py-value-cc.exp: Update.
	* gdb.python/py-value.exp: Use different names for .o files for
	C and C++.  Only perform C++ tests if !skip_cplus_tests.
@
text
@# Copyright (C) 2008-2013 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# This file is part of the GDB testsuite.  It tests the mechanism
# exposing values to Python.

load_lib gdb-python.exp

standard_testfile

# Build inferior to language specification.
# LANG is one of "c" or "c++".
proc build_inferior {exefile lang} {
  global srcdir subdir srcfile testfile hex

  # Use different names for .o files based on the language.
  # For Fission, the debug info goes in foo.dwo and we don't want,
  # for example, a C++ compile to clobber the dwo of a C compile.
  # ref: http://gcc.gnu.org/wiki/DebugFission
  switch ${lang} {
      "c" { set filename ${testfile}.o }
      "c++" { set filename ${testfile}-cxx.o }
  }
  set objfile [standard_output_file $filename]

  if { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${objfile}" object "debug $lang"] != ""
       || [gdb_compile "${objfile}" "${exefile}" executable "debug $lang"] != "" } {
      untested "Couldn't compile ${srcfile} in $lang mode"
      return -1
  }
  return 0
}

proc test_value_creation {} {
  global gdb_prompt
  global gdb_py_is_py3k

  gdb_py_test_silent_cmd "python i = gdb.Value (True)" "create boolean value" 1
  gdb_py_test_silent_cmd "python i = gdb.Value (5)" "create integer value" 1
  if { $gdb_py_is_py3k == 0 } {
    gdb_py_test_silent_cmd "python i = gdb.Value (5L)" "create long value" 1
  }
  gdb_py_test_silent_cmd "python f = gdb.Value (1.25)" "create double value" 1
  gdb_py_test_silent_cmd "python a = gdb.Value ('string test')" "create 8-bit string value" 1
  gdb_test "python print (a)" "\"string test\"" "print 8-bit string"
  gdb_test "python print (a.__class__)" "<(type|class) 'gdb.Value'>" "verify type of 8-bit string"
  if { $gdb_py_is_py3k == 0 } {
    gdb_py_test_silent_cmd "python a = gdb.Value (u'unicode test')" "create unicode value" 1
    gdb_test "python print (a)" "\"unicode test\"" "print Unicode string"
    gdb_test "python print (a.__class__)" "<(type|class) 'gdb.Value'>" "verify type of unicode string"
  }

  # Test address attribute is None in a non-addressable value
  gdb_test "python print ('result = %s' % i.address)" "= None" "Test address attribute in non-addressable value"
}

proc test_value_numeric_ops {} {
  global gdb_prompt

  gdb_py_test_silent_cmd "python i = gdb.Value (5)" "create first integer value" 0
  gdb_py_test_silent_cmd "python j = gdb.Value (2)" "create second integer value" 0
  gdb_py_test_silent_cmd "python f = gdb.Value (1.25)" "create first double value" 0
  gdb_py_test_silent_cmd "python g = gdb.Value (2.5)" "create second double value" 0
  gdb_test "python print ('result = ' + str(i+j))" " = 7" "add two integer values"
  gdb_test "python print ((i+j).__class__)" "<(type|class) 'gdb.Value'>" "verify type of integer add result"

  gdb_test "python print ('result = ' + str(f+g))" " = 3.75" "add two double values"
  gdb_test "python print ('result = ' + str(i-j))" " = 3" "subtract two integer values"
  gdb_test "python print ('result = ' + str(f-g))" " = -1.25" "subtract two double values"
  gdb_test "python print ('result = ' + str(i*j))" " = 10" "multiply two integer values"
  gdb_test "python print ('result = ' + str(f*g))" " = 3.125" "multiply two double values"
  gdb_test "python print ('result = ' + str(i/j))" " = 2" "divide two integer values"
  gdb_test "python print ('result = ' + str(f/g))" " = 0.5" "divide two double values"
  gdb_test "python print ('result = ' + str(i%j))" " = 1" "take remainder of two integer values"
  # Remainder of float is implemented in Python but not in GDB's value system.

  gdb_test "python print ('result = ' + str(i**j))" " = 25" "integer value raised to the power of another integer value"
  gdb_test "python print ('result = ' + str(g**j))" " = 6.25" "double value raised to the power of integer value"

  gdb_test "python print ('result = ' + str(-i))" " = -5" "negated integer value"
  gdb_test "python print ('result = ' + str(+i))" " = 5" "positive integer value"
  gdb_test "python print ('result = ' + str(-f))" " = -1.25" "negated double value"
  gdb_test "python print ('result = ' + str(+f))" " = 1.25" "positive double value"
  gdb_test "python print ('result = ' + str(abs(j-i)))" " = 3" "absolute of integer value"
  gdb_test "python print ('result = ' + str(abs(f-g)))" " = 1.25" "absolute of double value"

  # Test gdb.Value mixed with Python types.

  gdb_test "python print ('result = ' + str(i-1))" " = 4" "subtract integer value from python integer"
  gdb_test "python print ((i-1).__class__)" "<(type|class) 'gdb.Value'>" "verify type of mixed integer subtraction result"
  gdb_test "python print ('result = ' + str(f+1.5))" " = 2.75" "add double value with python float"

  gdb_test "python print ('result = ' + str(1-i))" " = -4" "subtract python integer from integer value"
  gdb_test "python print ('result = ' + str(1.5+f))" " = 2.75" "add python float with double value"

  # Conversion test.
  gdb_test "print evalue" " = TWO"
  gdb_test_no_output "python evalue = gdb.history (0)"
  gdb_test "python print (int (evalue))" "2"

  # Test pointer arithmethic

  # First, obtain the pointers
  gdb_test "print (void *) 2" ".*" ""
  gdb_test_no_output "python a = gdb.history (0)" ""
  gdb_test "print (void *) 5" ".*" ""
  gdb_test_no_output "python b = gdb.history (0)" ""

  gdb_test "python print ('result = ' + str(a+5))" " = 0x7( <.*>)?" "add pointer value with python integer"
  gdb_test "python print ('result = ' + str(b-2))" " = 0x3( <.*>)?" "subtract python integer from pointer value"
  gdb_test "python print ('result = ' + str(b-a))" " = 3" "subtract two pointer values"

  # Test some invalid operations.

  gdb_test_multiple "python print ('result = ' + str(i+'foo'))" "catch error in python type conversion" {
      -re "Argument to arithmetic operation not a number or boolean.*$gdb_prompt $"   {pass "catch error in python type conversion"}
      -re "result = .*$gdb_prompt $"		      {fail "catch error in python type conversion"}
      -re "$gdb_prompt $"			      {fail "catch error in python type conversion"}
  }

  gdb_test_multiple "python print ('result = ' + str(i+gdb.Value('foo')))" "catch throw of GDB error" {
      -re "Traceback.*$gdb_prompt $"  {pass "catch throw of GDB error"}
      -re "result = .*$gdb_prompt $"  {fail "catch throw of GDB error"}
      -re "$gdb_prompt $"	      {fail "catch throw of GDB error"}
  }
}

proc test_value_boolean {} {
  # First, define a useful function to test booleans.
  gdb_py_test_multiple "define function to test booleans" \
    "python" "" \
    "def test_bool (val):" "" \
    "  if val:" "" \
    "    print ('yay')" "" \
    "  else:" "" \
    "    print ('nay')" "" \
    "end" ""

  gdb_test "py test_bool (gdb.Value (True))" "yay" "check evaluation of true boolean value in expression"

  gdb_test "py test_bool (gdb.Value (False))" "nay" "check evaluation of false boolean value in expression"

  gdb_test "py test_bool (gdb.Value (5))" "yay" "check evaluation of true integer value in expression"

  gdb_test "py test_bool (gdb.Value (0))" "nay" "check evaluation of false integer value in expression"

  gdb_test "py test_bool (gdb.Value (5.2))" "yay" "check evaluation of true integer value in expression"

  gdb_test "py test_bool (gdb.Value (0.0))" "nay" "check evaluation of false integer value in expression"
}

proc test_value_compare {} {
  gdb_test "py print (gdb.Value (1) < gdb.Value (1))" "False" "less than, equal"
  gdb_test "py print (gdb.Value (1) < gdb.Value (2))" "True" "less than, less"
  gdb_test "py print (gdb.Value (2) < gdb.Value (1))" "False" "less than, greater"
  gdb_test "py print (gdb.Value (2) < None)" "False" "less than, None"

  gdb_test "py print (gdb.Value (1) <= gdb.Value (1))" "True" "less or equal, equal"
  gdb_test "py print (gdb.Value (1) <= gdb.Value (2))" "True" "less or equal, less"
  gdb_test "py print (gdb.Value (2) <= gdb.Value (1))" "False" "less or equal, greater"
  gdb_test "py print (gdb.Value (2) <= None)" "False" "less or equal, None"

  gdb_test "py print (gdb.Value (1) == gdb.Value (1))" "True" "equality of gdb.Values"
  gdb_test "py print (gdb.Value (1) == gdb.Value (2))" "False" "inequality of gdb.Values"
  gdb_test "py print (gdb.Value (1) == 1.0)" "True" "equality of gdb.Value with Python value"
  gdb_test "py print (gdb.Value (1) == 2)" "False" "inequality of gdb.Value with Python value"
  gdb_test "py print (gdb.Value (1) == None)" "False" "inequality of gdb.Value with None"

  gdb_test "py print (gdb.Value (1) != gdb.Value (1))" "False" "inequality, false"
  gdb_test "py print (gdb.Value (1) != gdb.Value (2))" "True" "inequality, true"
  gdb_test "py print (gdb.Value (1) != None)" "True" "inequality, None"

  gdb_test "py print (gdb.Value (1) > gdb.Value (1))" "False" "greater than, equal"
  gdb_test "py print (gdb.Value (1) > gdb.Value (2))" "False" "greater than, less"
  gdb_test "py print (gdb.Value (2) > gdb.Value (1))" "True" "greater than, greater"
  gdb_test "py print (gdb.Value (2) > None)" "True" "greater than, None"

  gdb_test "py print (gdb.Value (1) >= gdb.Value (1))" "True" "greater or equal, equal"
  gdb_test "py print (gdb.Value (1) >= gdb.Value (2))" "False" "greater or equal, less"
  gdb_test "py print (gdb.Value (2) >= gdb.Value (1))" "True" "greater or equal, greater"
  gdb_test "py print (gdb.Value (2) >= None)" "True" "greater or equal, None"
}

proc test_value_in_inferior {} {
  global gdb_prompt
  global testfile
  global gdb_py_is_py3k

  gdb_breakpoint [gdb_get_line_number "break to inspect struct and union"]

  gdb_continue_to_breakpoint "break to inspect struct and union"

  # Just get inferior variable s in the value history, available to python.
  gdb_test "print s" " = {a = 3, b = 5}" ""

  gdb_py_test_silent_cmd "python s = gdb.history (0)" "get value from history" 1

  gdb_test "python print ('result = ' + str(s\['a'\]))" " = 3" "access element inside struct using 8-bit string name"
  if { $gdb_py_is_py3k == 0 } {
    gdb_test "python print ('result = ' + str(s\[u'a'\]))" " = 3" "access element inside struct using unicode name"
  }

  # Test dereferencing the argv pointer

  # Just get inferior variable argv the value history, available to python.
  gdb_test "print argv" " = \\(char \\*\\*\\) 0x.*" ""

  gdb_py_test_silent_cmd "python argv = gdb.history (0)" "" 0
  gdb_py_test_silent_cmd "python arg0 = argv.dereference ()" "dereference value" 1

  # Check that the dereferenced value is sane
  if { ! [target_info exists noargs] } {
    gdb_test "python print (arg0)" "0x.*$testfile\"" "verify dereferenced value"
  }

  # Smoke-test is_optimized_out attribute
  gdb_test "python print ('result = %s' % arg0.is_optimized_out)" "= False" "Test is_optimized_out attribute"

  # Test address attribute
  gdb_test "python print ('result = %s' % arg0.address)" "= 0x\[\[:xdigit:\]\]+" "Test address attribute"

  # Test displaying a variable that is temporarily at a bad address.
  # But if we can examine what's at memory address 0, then we'll also be
  # able to display it without error.  Don't run the test in that case.
  set can_read_0 0
  gdb_test_multiple "x 0" "memory at address 0" {
      -re "0x0:\[ \t\]*Cannot access memory at address 0x0\r\n$gdb_prompt $" { }
      -re "0x0:\[ \t\]*Error accessing memory address 0x0\r\n$gdb_prompt $" { }
      -re "\r\n$gdb_prompt $" {
	  set can_read_0 1
      }
  }

  # Test memory error.
  set test "parse_and_eval with memory error"
  if {$can_read_0} {
    untested $test
  } else {
    gdb_test "python print (gdb.parse_and_eval('*(int*)0'))" "gdb.MemoryError: Cannot access memory at address 0x0.*" $test
  }

  # Test Python lazy value handling
  set test "memory error and lazy values"
  if {$can_read_0} {
    untested $test
  } else {
    gdb_test "python inval = gdb.parse_and_eval('*(int*)0')"
    gdb_test "python print (inval.is_lazy)" "True"
    gdb_test "python inval2 = inval+1" "gdb.MemoryError: Cannot access memory at address 0x0.*" $test
    gdb_test "python inval.fetch_lazy ()" "gdb.MemoryError: Cannot access memory at address 0x0.*" $test
  }
  gdb_test "python argc_lazy = gdb.parse_and_eval('argc')"
  gdb_test "python argc_notlazy = gdb.parse_and_eval('argc')"
  gdb_test "python argc_notlazy.fetch_lazy()"
  gdb_test "python print (argc_lazy.is_lazy)" "True"
  gdb_test "python print (argc_notlazy.is_lazy)" "False"
  gdb_test "print argc" " = 1" "sanity check argc"
  gdb_test "python print (argc_lazy.is_lazy)" "\r\nTrue"
  gdb_test_no_output "set argc=2"
  gdb_test "python print (argc_notlazy)" "\r\n1"
  gdb_test "python print (argc_lazy)" "\r\n2"
  gdb_test "python print (argc_lazy.is_lazy)" "False"

  # Test string fetches,  both partial and whole.
  gdb_test "print st" "\"divide et impera\""
  gdb_py_test_silent_cmd "python st = gdb.history (0)" "get value from history" 1
  gdb_test "python print (st.string ())"  "divide et impera"  "Test string with no length"
  gdb_test "python print (st.string (length = -1))" "divide et impera" "Test string (length = -1) is all of the string"
  gdb_test "python print (st.string (length = 6))" "divide"
  gdb_test "python print (\"---\"+st.string (length = 0)+\"---\")" "------" "Test string (length = 0) is empty"
  gdb_test "python print (len(st.string (length = 0)))" "0" "Test length is 0"


  # Fetch a string that has embedded nulls.
  gdb_test "print nullst" "\"divide\\\\000et\\\\000impera\".*"
  gdb_py_test_silent_cmd "python nullst = gdb.history (0)" "get value from history" 1
  gdb_test "python print (nullst.string ())" "divide" "Test string to first null"
  # Python cannot print strings that contain the null (\0) character.
  # For the purposes of this test, use repr()
  gdb_py_test_silent_cmd "python nullst = nullst.string (length = 9)" "get string beyond null" 1
  gdb_test "python print (repr(nullst))" "u?'divide\\\\x00et'"
}

proc test_lazy_strings {} {

  global hex

  gdb_test "print sptr" "\"pointer\""
  gdb_py_test_silent_cmd "python sptr = gdb.history (0)" "Get value from history" 1

  gdb_py_test_silent_cmd "python lstr = sptr.lazy_string()" "Aquire lazy string" 1
  gdb_test "python print (lstr.type)" "const char \*." "Test type name equality"
  gdb_test "python print (sptr.type)" "const char \*." "Test type name equality"
  gdb_test "print sn" "0x0"
  gdb_py_test_silent_cmd "python snptr = gdb.history (0)" "Get value from history" 1
  gdb_test "python snstr = snptr.lazy_string(length=5)" ".*Cannot create a lazy string with address.*" "Test lazy string"
  gdb_py_test_silent_cmd "python snstr = snptr.lazy_string(length=0)" "Succesfully create a lazy string" 1
  gdb_test "python print (snstr.length)" "0" "Test lazy string length"
  gdb_test "python print (snstr.address)" "0" "Test lazy string address"
}


proc test_inferior_function_call {} {
    global gdb_prompt hex decimal

    # Correct inferior call without arguments.
    gdb_test "p/x fp1" " = $hex.*"
    gdb_py_test_silent_cmd "python fp1 = gdb.history (0)" "get value from history" 1
    gdb_test "python fp1 = fp1.dereference()" ""
    gdb_test "python result = fp1()" ""
    gdb_test "python print (result)" "void"

    # Correct inferior call with arguments.
    gdb_test "p/x fp2" " = $hex.*"
    gdb_py_test_silent_cmd "python fp2 = gdb.history (0)" "get value from history" 1
    gdb_test "python fp2 = fp2.dereference()" ""
    gdb_test "python result2 = fp2(10,20)" ""
    gdb_test "python print (result2)" "30"

    # Incorrect to call an int value.
    gdb_test "p i" " = $decimal.*"
    gdb_py_test_silent_cmd "python i = gdb.history (0)" "get value from history" 1
    gdb_test "python result3 = i()" ".*Value is not callable.*"

    # Incorrect number of arguments.
    gdb_test "p/x fp2" " = $hex.*"
    gdb_py_test_silent_cmd "python fp3 = gdb.history (0)" "get value from history" 1
    gdb_test "python fp3 = fp3.dereference()" ""
    gdb_test "python result2 = fp3(10)" ".*Too few arguments in function call.*"
}

# A few objfile tests.
proc test_objfiles {} {
    gdb_test "python\nok=False\nfor file in gdb.objfiles():\n  if 'py-value' in file.filename:\n    ok=True\nprint (ok)\nend" "True" \
	     "py-value in file.filename"

    gdb_test "python print (gdb.objfiles()\[0\].pretty_printers)" "\\\[\\\]"

    gdb_test "python gdb.objfiles()\[0\].pretty_printers = 0" \
      "pretty_printers attribute must be a list.*Error while executing Python code."
}

proc test_value_after_death {} {
  # Construct a type while the inferior is still running.
  gdb_py_test_silent_cmd "python ptrtype = gdb.lookup_type('PTR')" \
    "create PTR type" 1

  # Kill the inferior and remove the symbols.
  gdb_test "kill" "" "kill the inferior" \
    "Kill the program being debugged. .y or n. $" \
    "y"
  gdb_test "file" "" "Discard the symbols" \
    "Discard symbol table from.*y or n. $" \
    "y"

  # Now create a value using that type.  Relies on arg0, created by
  # test_value_in_inferior.
  gdb_py_test_silent_cmd "python castval = arg0.cast(ptrtype.pointer())" \
    "cast arg0 to PTR" 1

  # Make sure the type is deleted.
  gdb_py_test_silent_cmd "python ptrtype = None" \
    "delete PTR type" 1

  # Now see if the value's type is still valid.
  gdb_test "python print (castval.type)" "PTR ." \
    "print value's type"
}

# Regression test for invalid subscript operations.  The bug was that
# the type of the value was not being checked before allowing a
# subscript operation to proceed.

proc test_subscript_regression {exefile lang} {
 # Start with a fresh gdb.
 clean_restart ${exefile}

 if ![runto_main ] then {
     perror "couldn't run to breakpoint"
     return
 }

 if {$lang == "c++"} {
     gdb_breakpoint [gdb_get_line_number "break to inspect pointer by reference"]
     gdb_continue_to_breakpoint "break to inspect pointer by reference"

     gdb_py_test_silent_cmd "print rptr_int" \
	 "Obtain address" 1
     gdb_py_test_silent_cmd "python rptr = gdb.history(0)" \
	 "Obtains value from GDB" 1
     gdb_test "python print (rptr\[0\])" "2" "Check pointer passed as reference"

     # Just the most basic test of dynamic_cast -- it is checked in
     # the C++ tests.
     gdb_test "python print (bool(gdb.parse_and_eval('base').dynamic_cast(gdb.lookup_type('Derived').pointer())))" \
	 True

     # Likewise.
     gdb_test "python print (gdb.parse_and_eval('base').dynamic_type)" \
	 "Derived \[*\]"
     # A static type case.
     gdb_test "python print (gdb.parse_and_eval('5').dynamic_type)" \
	 "int"
 }

 gdb_breakpoint [gdb_get_line_number "break to inspect struct and union"]
 gdb_continue_to_breakpoint "break to inspect struct and union"

 gdb_py_test_silent_cmd "python intv = gdb.Value(1)" \
     "Create a value for subscript test" 1
 gdb_py_test_silent_cmd "python stringv = gdb.Value(\"foo\")" \
     "Create a value for subscript test" 1

 # Try to access an int with a subscript.  This should fail.
 gdb_test "python print (intv)" "1" "Baseline print of a Python value"
 gdb_test "python print (intv\[0\])" "gdb.error: Cannot subscript requested type.*" \
     "Attempt to access an integer with a subscript"

 # Try to access a string with a subscript.  This should pass.
 gdb_test "python print (stringv)" "foo." "Baseline print of a Python value"
 gdb_test "python print (stringv\[0\])" "f." "Attempt to access a string with a subscript"

 # Try to access an int array via a pointer with a subscript.  This should pass.
 gdb_py_test_silent_cmd "print p" "Build pointer to array" 1
 gdb_py_test_silent_cmd "python pointer = gdb.history(0)" "" 1
 gdb_test "python print (pointer\[0\])" "1" "Access array via pointer with int subscript"
 gdb_test "python print (pointer\[intv\])" "2" "Access array via pointer with value subscript"

 # Try to access a single dimension array with a subscript to the
 # result.  This should fail.
 gdb_test "python print (pointer\[intv\]\[0\])" "gdb.error: Cannot subscript requested type.*" \
     "Attempt to access an integer with a subscript"

 # Lastly, test subscript access to an array with multiple
 # dimensions.  This should pass.
 gdb_py_test_silent_cmd "print {\"fu \",\"foo\",\"bar\"}" "Build array" 1
 gdb_py_test_silent_cmd "python marray = gdb.history(0)" "" 1
 gdb_test "python print (marray\[1\]\[2\])" "o." "Test multiple subscript"
}

# A few tests of gdb.parse_and_eval.
proc test_parse_and_eval {} {
  gdb_test "python print (gdb.parse_and_eval ('23'))" "23" \
    "parse_and_eval constant test"
  gdb_test "python print (gdb.parse_and_eval ('5 + 7'))" "12" \
    "parse_and_eval simple expression test"
  gdb_test "python print (type(gdb.parse_and_eval ('5 + 7')))" \
    ".(type|class) 'gdb.Value'."\
    "parse_and_eval type test"
}

# Test that values are hashable.
proc test_value_hash {} {
  gdb_py_test_multiple "Simple Python value dictionary" \
    "python" "" \
    "one = gdb.Value(1)" "" \
    "two = gdb.Value(2)" "" \
    "three = gdb.Value(3)" "" \
    "vdict = {one:\"one str\",two:\"two str\",three:\"three str\"}" "" \
    "end"
    gdb_test "python print (vdict\[one\])" "one str" "Test dictionary hash"
    gdb_test "python print (vdict\[two\])" "two str" "Test dictionary hash"
    gdb_test "python print (vdict\[three\])" "three str" "Test dictionary hash"
    gdb_test "python print (one.__hash__() == hash(one))" "True" "Test inbuilt hash"
}

# Build C version of executable.  C++ is built later.
if { [build_inferior "${binfile}" "c"] < 0 } {
    return -1
}

# Start with a fresh gdb.
clean_restart ${binfile}

# Skip all tests if Python scripting is not enabled.
if { [skip_python_tests] } { continue }

test_value_creation
test_value_numeric_ops
test_value_boolean
test_value_compare
test_objfiles
test_parse_and_eval
test_value_hash

# The following tests require execution.

if ![runto_main] then {
    fail "Can't run to main"
    return 0
}

test_value_in_inferior
test_inferior_function_call
test_lazy_strings
test_value_after_death

# Test either C or C++ values. 

test_subscript_regression "${binfile}" "c"

if ![skip_cplus_tests] {
    if { [build_inferior "${binfile}-cxx" "c++"] < 0 } {
	return -1
    }
    test_subscript_regression "${binfile}-cxx" "c++"
}
@


1.33
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d24 1
d28 12
a39 1
  if { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${exefile}" executable "debug $lang"] != "" } {
d43 1
d479 4
a482 3
# Build C and C++ versions of executable
build_inferior "${binfile}" "c"
build_inferior "${binfile}-cxx" "c++"
d511 1
d513 7
a519 1
test_subscript_regression "${binfile}-cxx" "c++"
@


1.32
log
@2012-12-10  Paul Koning  <paul_koning@@dell.com>

	* gdb.base/charset.exp: Change print syntax for Python 3
	compatibility.
	* gdb.python/py-block.exp: Ditto.
	* gdb.python/py-breakpoint.exp: Ditto.
	* gdb.python/py-cmd.exp: Ditto.
	* gdb.python/py-events.py: Ditto.
	* gdb.python/py-finish-breakpoint.py: Ditto.
	* gdb.python/py-finish-breakpoint2.exp: Ditto.
	* gdb.python/py-finish-breakpoint2.py: Ditto.
	* gdb.python/py-frame-inline.exp: Ditto.
	* gdb.python/py-frame.exp: Ditto.
	* gdb.python/py-infthread.exp: Ditto.
	* gdb.python/py-objfile.exp: Ditto.
	* gdb.python/py-parameter.exp: Ditto.
	* gdb.python/py-progspace.exp: Ditto.
	* gdb.python/py-prompt.exp: Ditto.
	* gdb.python/py-symbol.exp: Ditto.
	* gdb.python/py-symtab.exp: Ditto.
	* gdb.python/py-template.exp: Ditto.
	* gdb.python/py-value-cc.exp: Ditto.
	* gdb.python/python.exp: Ditto.
	* gdb.python/source2.py: Ditto.
	* gdb.python/lib-types.exp: Change print syntax for Python 3
	compatibility.
	Use sorted() function rather than sort() method.
	Accept either int or long values for enum values.
	* gdb.python/py-events.exp: Use exec(open(...).read()) instead of
	execfile for Python 3 compatibility.
	* gdb.python/py-evsignal.exp: Ditto.
	* gdb.python/py-evthreads.exp: Ditto.
	* gdb.python/py-mi.exp: Ditto.
	* gdb.python/py-pp-maint.exp: Ditto.
	* gdb.python/py-prettyprint.exp: Ditto.
	* gdb.python/py-finish-breakpoint.exp: Change print syntax for
	Python 3 compatibility.
	Skip tests for Python 2.4.
	* gdb.python/py-inferior.exp: Change print syntax for
	Python 3 compatibility.
	Use byte string rather than character string in memory write test
	if Python 3.
	* gdb.python/py-pp-maint.py: Change class declarations to "new
	class" syntax.
	* gdb.python/py-prettyprint.py: Change iterator class to generator
	function for Python 3 compatibility.
	Make all classes "new style".
	Fix indentation issue and stray semicolon.
	* gdb.python/py-shared.expChange print syntax for Python 3
	compatibility.
	Define "long" if Python 3.
	* gdb.python/py-type.exp: Change print syntax for Python 3
	compatibility.
	Accept either int or long values for enum values.
	* gdb.python/py-value.exp: Change print syntax for Python 3
	compatibility.
	Skip "long" and "unicode" tests if Python 3.
	Accept either "type" or "class" in type checks.
	* lib/gdb.exp (gdb_py_is_py3k): New flag set if Python 3.
	(gdb_py_is_py24): New flag set if Python 2.4 or 2.5.
@
text
@d1 1
a1 1
# Copyright (C) 2008-2012 Free Software Foundation, Inc.
@


1.31
log
@(test_subscript_regression): Remove no longer necessary globals,
from previous patch.
@
text
@d35 1
d39 3
a41 1
  gdb_py_test_silent_cmd "python i = gdb.Value (5L)" "create long value" 1
d44 7
a50 5
  gdb_test "python print a" "\"string test\"" "print 8-bit string"
  gdb_test "python print a.__class__" "<type 'gdb.Value'>" "verify type of 8-bit string"
  gdb_py_test_silent_cmd "python a = gdb.Value (u'unicode test')" "create unicode value" 1
  gdb_test "python print a" "\"unicode test\"" "print Unicode string"
  gdb_test "python print a.__class__" "<type 'gdb.Value'>" "verify type of unicode string"
d53 1
a53 1
  gdb_test "python print 'result =', i.address" "= None" "Test address attribute in non-addressable value"
d63 2
a64 2
  gdb_test "python print 'result = ' + str(i+j)" " = 7" "add two integer values"
  gdb_test "python print (i+j).__class__" "<type 'gdb.Value'>" "verify type of integer add result"
d66 8
a73 8
  gdb_test "python print 'result = ' + str(f+g)" " = 3.75" "add two double values"
  gdb_test "python print 'result = ' + str(i-j)" " = 3" "subtract two integer values"
  gdb_test "python print 'result = ' + str(f-g)" " = -1.25" "subtract two double values"
  gdb_test "python print 'result = ' + str(i*j)" " = 10" "multiply two integer values"
  gdb_test "python print 'result = ' + str(f*g)" " = 3.125" "multiply two double values"
  gdb_test "python print 'result = ' + str(i/j)" " = 2" "divide two integer values"
  gdb_test "python print 'result = ' + str(f/g)" " = 0.5" "divide two double values"
  gdb_test "python print 'result = ' + str(i%j)" " = 1" "take remainder of two integer values"
d76 2
a77 2
  gdb_test "python print 'result = ' + str(i**j)" " = 25" "integer value raised to the power of another integer value"
  gdb_test "python print 'result = ' + str(g**j)" " = 6.25" "double value raised to the power of integer value"
d79 6
a84 6
  gdb_test "python print 'result = ' + str(-i)" " = -5" "negated integer value"
  gdb_test "python print 'result = ' + str(+i)" " = 5" "positive integer value"
  gdb_test "python print 'result = ' + str(-f)" " = -1.25" "negated double value"
  gdb_test "python print 'result = ' + str(+f)" " = 1.25" "positive double value"
  gdb_test "python print 'result = ' + str(abs(j-i))" " = 3" "absolute of integer value"
  gdb_test "python print 'result = ' + str(abs(f-g))" " = 1.25" "absolute of double value"
d88 3
a90 3
  gdb_test "python print 'result = ' + str(i-1)" " = 4" "subtract integer value from python integer"
  gdb_test "python print (i-1).__class__" "<type 'gdb.Value'>" "verify type of mixed integer subtraction result"
  gdb_test "python print 'result = ' + str(f+1.5)" " = 2.75" "add double value with python float"
d92 2
a93 2
  gdb_test "python print 'result = ' + str(1-i)" " = -4" "subtract python integer from integer value"
  gdb_test "python print 'result = ' + str(1.5+f)" " = 2.75" "add python float with double value"
d98 1
a98 1
  gdb_test "python print int (evalue)" "2"
d108 3
a110 3
  gdb_test "python print 'result = ' + str(a+5)" " = 0x7( <.*>)?" "add pointer value with python integer"
  gdb_test "python print 'result = ' + str(b-2)" " = 0x3( <.*>)?" "subtract python integer from pointer value"
  gdb_test "python print 'result = ' + str(b-a)" " = 3" "subtract two pointer values"
d114 1
a114 1
  gdb_test_multiple "python print 'result = ' + str(i+'foo')" "catch error in python type conversion" {
d120 1
a120 1
  gdb_test_multiple "python print 'result = ' + str(i+gdb.Value('foo'))" "catch throw of GDB error" {
d133 1
a133 1
    "    print 'yay'" "" \
d135 1
a135 1
    "    print 'nay'" "" \
d152 29
a180 29
  gdb_test "py print gdb.Value (1) < gdb.Value (1)" "False" "less than, equal"
  gdb_test "py print gdb.Value (1) < gdb.Value (2)" "True" "less than, less"
  gdb_test "py print gdb.Value (2) < gdb.Value (1)" "False" "less than, greater"
  gdb_test "py print gdb.Value (2) < None" "False" "less than, None"

  gdb_test "py print gdb.Value (1) <= gdb.Value (1)" "True" "less or equal, equal"
  gdb_test "py print gdb.Value (1) <= gdb.Value (2)" "True" "less or equal, less"
  gdb_test "py print gdb.Value (2) <= gdb.Value (1)" "False" "less or equal, greater"
  gdb_test "py print gdb.Value (2) <= None" "False" "less or equal, None"

  gdb_test "py print gdb.Value (1) == gdb.Value (1)" "True" "equality of gdb.Values"
  gdb_test "py print gdb.Value (1) == gdb.Value (2)" "False" "inequality of gdb.Values"
  gdb_test "py print gdb.Value (1) == 1.0" "True" "equality of gdb.Value with Python value"
  gdb_test "py print gdb.Value (1) == 2" "False" "inequality of gdb.Value with Python value"
  gdb_test "py print gdb.Value (1) == None" "False" "inequality of gdb.Value with None"

  gdb_test "py print gdb.Value (1) != gdb.Value (1)" "False" "inequality, false"
  gdb_test "py print gdb.Value (1) != gdb.Value (2)" "True" "inequality, true"
  gdb_test "py print gdb.Value (1) != None" "True" "inequality, None"

  gdb_test "py print gdb.Value (1) > gdb.Value (1)" "False" "greater than, equal"
  gdb_test "py print gdb.Value (1) > gdb.Value (2)" "False" "greater than, less"
  gdb_test "py print gdb.Value (2) > gdb.Value (1)" "True" "greater than, greater"
  gdb_test "py print gdb.Value (2) > None" "True" "greater than, None"

  gdb_test "py print gdb.Value (1) >= gdb.Value (1)" "True" "greater or equal, equal"
  gdb_test "py print gdb.Value (1) >= gdb.Value (2)" "False" "greater or equal, less"
  gdb_test "py print gdb.Value (2) >= gdb.Value (1)" "True" "greater or equal, greater"
  gdb_test "py print gdb.Value (2) >= None" "True" "greater or equal, None"
d186 1
d197 4
a200 2
  gdb_test "python print 'result = ' + str(s\['a'\])" " = 3" "access element inside struct using 8-bit string name"
  gdb_test "python print 'result = ' + str(s\[u'a'\])" " = 3" "access element inside struct using unicode name"
d212 1
a212 1
    gdb_test "python print arg0" "0x.*$testfile\"" "verify dereferenced value"
d216 1
a216 1
  gdb_test "python print 'result =', arg0.is_optimized_out" "= False" "Test is_optimized_out attribute"
d219 1
a219 1
  gdb_test "python print 'result =', arg0.address" "= 0x\[\[:xdigit:\]\]+" "Test address attribute"
d238 1
a238 1
    gdb_test "python print gdb.parse_and_eval('*(int*)0')" "gdb.MemoryError: Cannot access memory at address 0x0.*" $test
d247 1
a247 1
    gdb_test "python print inval.is_lazy" "True"
d254 2
a255 2
  gdb_test "python print argc_lazy.is_lazy" "True"
  gdb_test "python print argc_notlazy.is_lazy" "False"
d257 1
a257 1
  gdb_test "python print argc_lazy.is_lazy" "\r\nTrue"
d259 3
a261 3
  gdb_test "python print argc_notlazy" "\r\n1"
  gdb_test "python print argc_lazy" "\r\n2"
  gdb_test "python print argc_lazy.is_lazy" "False"
d266 5
a270 5
  gdb_test "python print st.string ()"  "divide et impera"  "Test string with no length"
  gdb_test "python print st.string (length = -1)" "divide et impera" "Test string (length = -1) is all of the string"
  gdb_test "python print st.string (length = 6)" "divide"
  gdb_test "python print \"---\"+st.string (length = 0)+\"---\"" "------" "Test string (length = 0) is empty"
  gdb_test "python print len(st.string (length = 0))" "0" "Test length is 0"
d276 1
a276 1
  gdb_test "python print nullst.string ()" "divide" "Test string to first null"
d280 1
a280 1
  gdb_test "python print repr(nullst)" "u'divide\\\\x00et'"
d291 2
a292 2
  gdb_test "python print lstr.type" "const char \*." "Test type name equality"
  gdb_test "python print sptr.type" "const char \*." "Test type name equality"
d297 2
a298 2
  gdb_test "python print snstr.length" "0" "Test lazy string length"
  gdb_test "python print snstr.address" "0" "Test lazy string address"
d310 1
a310 1
    gdb_test "python print result" "void"
d317 1
a317 1
    gdb_test "python print result2" "30"
d333 1
a333 1
    gdb_test "python\nok=False\nfor file in gdb.objfiles():\n  if 'py-value' in file.filename:\n    ok=True\nprint ok\nend" "True" \
d336 1
a336 1
    gdb_test "python print gdb.objfiles()\[0\].pretty_printers" "\\\[\\\]"
d365 1
a365 1
  gdb_test "python print castval.type" "PTR ." \
d390 1
a390 1
     gdb_test "python print rptr\[0\]" "2" "Check pointer passed as reference"
d394 1
a394 1
     gdb_test "python print bool(gdb.parse_and_eval('base').dynamic_cast(gdb.lookup_type('Derived').pointer()))" \
d398 1
a398 1
     gdb_test "python print gdb.parse_and_eval('base').dynamic_type" \
d401 1
a401 1
     gdb_test "python print gdb.parse_and_eval('5').dynamic_type" \
d414 2
a415 2
 gdb_test "python print intv" "1" "Baseline print of a Python value"
 gdb_test "python print intv\[0\]" "gdb.error: Cannot subscript requested type.*" \
d419 2
a420 2
 gdb_test "python print stringv" "foo." "Baseline print of a Python value"
 gdb_test "python print stringv\[0\]" "f." "Attempt to access a string with a subscript"
d425 2
a426 2
 gdb_test "python print pointer\[0\]" "1" "Access array via pointer with int subscript"
 gdb_test "python print pointer\[intv\]" "2" "Access array via pointer with value subscript"
d430 1
a430 1
 gdb_test "python print pointer\[intv\]\[0\]" "gdb.error: Cannot subscript requested type.*" \
d437 1
a437 1
 gdb_test "python print marray\[1\]\[2\]" "o." "Test multiple subscript"
d442 1
a442 1
  gdb_test "python print gdb.parse_and_eval ('23')" "23" \
d444 1
a444 1
  gdb_test "python print gdb.parse_and_eval ('5 + 7')" "12" \
d446 2
a447 2
  gdb_test "python print type(gdb.parse_and_eval ('5 + 7'))" \
    ".type 'gdb.Value'."\
d460 4
a463 4
    gdb_test "python print vdict\[one\]" "one str" "Test dictionary hash"
    gdb_test "python print vdict\[two\]" "two str" "Test dictionary hash"
    gdb_test "python print vdict\[three\]" "three str" "Test dictionary hash"
    gdb_test "python print one.__hash__() == hash(one)" "True" "Test inbuilt hash"
@


1.30
log
@	* gdb.python/py-value.exp: Use clean_restart.
@
text
@a365 3

 global srcdir subdir

a462 1

@


1.29
log
@	* gdb.base/annota1.exp: Accept no frames-invalid notification
	when starting up the program.
	* gdb.python/py-value.exp (test_value_numeric_ops): Pointers may
	show a symbolic value as well.
	* gdb.server/server-exec-info.exp: Skip test when skipping
	gdbserver test and/or when skipping shared library tests.
	* gdb.threads/linux-dp.exp: Unset "seen" when done with it to
	avoid name conflicts with other tests.
@
text
@d370 1
a370 4
 gdb_exit
 gdb_start
 gdb_reinitialize_dir $srcdir/$subdir
 gdb_load ${exefile}
d467 1
a467 4
gdb_exit
gdb_start
gdb_reinitialize_dir $srcdir/$subdir
gdb_load ${binfile}
@


1.28
log
@	* gdb.python/lib-types.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.python/py-block.exp: Use standard_testfile.
	* gdb.python/py-breakpoint.exp: Use standard_testfile.
	* gdb.python/py-events.exp: Use standard_testfile,
	standard_output_file.
	* gdb.python/py-evsignal.exp: Use standard_testfile.
	* gdb.python/py-evethreads.exp: Use standard_testfile.
	* gdb.python/py-explore-cc.exp: Use standard_testfile.
	* gdb.python/py-explore.exp: Use standard_testfile.
	* gdb.python/py-finish-breakpoint.exp: Use standard_testfile,
	standard_output_file.
	* gdb.python/py-finish-breakpoint2.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.python/py-frame-inline.exp: Use standard_testfile.
	* gdb.python/py-frame.exp: Use standard_testfile.
	* gdb.python/py-inferior.exp: Use standard_testfile.
	* gdb.python/py-infthread.exp: Use standard_testfile.
	* gdb.python/py-mi.exp: Use standard_testfile.
	* gdb.python/py-objfile-script.exp: Use standard_testfile,
	build_executable.
	* gdb.python/py-objfile.exp: Use standard_testfile.
	* gdb.python/py-pp-maint.exp: Use standard_testfile,
	prepare_for_testing.
	* gdb.python/py-prettyprint.exp: Use standard_testfile.
	* gdb.python/py-progspace.exp: Use standard_testfile,
	build_executable.
	* gdb.python/py-prompt.exp: Use standard_testfile,
	build_executable.
	* gdb.python/py-section-script.exp: Use standard_testfile,
	build_executable.
	* gdb.python/py-shared.exp: Use standard_testfile,
	standard_output_file, clean_restart.
	* gdb.python/py-symbol.exp: Use standard_output_file,
	prepare_for_testing.
	* gdb.python/py-symtab.exp: Use standard_output_file,
	prepare_for_testing
	* gdb.python/py-template.exp: Use standard_testfile.
	* gdb.python/py-type.exp: Use standard_testfile.
	* gdb.python/py-value-cc.exp: Use standard_testfile.
	* gdb.python/py-value.exp: Use standard_testfile.
	* gdb.python/python.exp: Use standard_testfile, build_executable.
@
text
@d103 2
a104 2
  gdb_test "python print 'result = ' + str(a+5)" " = 0x7" "add pointer value with python integer"
  gdb_test "python print 'result = ' + str(b-2)" " = 0x3" "subtract python integer from pointer value"
@


1.28.2.1
log
@	* gdb.base/annota1.exp: Accept no frames-invalid notification
	when starting up the program.
	* gdb.python/py-value.exp (test_value_numeric_ops): Pointers may
	show a symbolic value as well.
	* gdb.server/server-exec-info.exp: Skip test when skipping
	gdbserver test and/or when skipping shared library tests.
	* gdb.threads/linux-dp.exp: Unset "seen" when done with it to
	avoid name conflicts with other tests.
@
text
@d103 2
a104 2
  gdb_test "python print 'result = ' + str(a+5)" " = 0x7( <.*>)?" "add pointer value with python integer"
  gdb_test "python print 'result = ' + str(b-2)" " = 0x3( <.*>)?" "subtract python integer from pointer value"
@


1.27
log
@2012-01-16  Pedro Alves  <palves@@redhat.com>

	Remove all calls to strace.
@
text
@d21 1
a21 3
set testfile "py-value"
set srcfile ${testfile}.c
set binfile ${objdir}/${subdir}/${testfile}
@


1.26
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@a18 4
if $tracelevel then {
    strace $tracelevel
}

@


1.25
log
@* gdb.python/py-value.exp: Add testcases for is_lazy attribute,
fetch_lazy method.
@
text
@d1 1
a1 1
# Copyright (C) 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.25.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d1 1
a1 1
# Copyright (C) 2008-2012 Free Software Foundation, Inc.
@


1.24
log
@* gdb.python/py-value.exp
(python inval = gdb.parse_and_eval('*(int*)0'))
(python argc_lazy = gdb.parse_and_eval('argc'), sanity check argc)
(set argc=2, python print argc_lazy): New tests.
@
text
@d239 2
a240 2
  # Test Python values are not lazy.
  set test "memory error occurs even for possibly lazy values"
d244 4
a247 1
    gdb_test "python inval = gdb.parse_and_eval('*(int*)0')" "gdb.MemoryError: Cannot access memory at address 0x0.*" $test
d250 4
d255 1
d257 3
a259 1
  gdb_test "python print argc_lazy" "\r\n1"
@


1.23
log
@gdb/testsuite/
	* gdb.python/py-value.exp (test_value_in_inferior): New variable
	can_read_0, test for it.
	(python print gdb.parse_and_eval('*(int*)0')): Rename to ...
	(parse_and_eval with memory error): ... here, make it untested if
	can_read_0.
@
text
@d239 12
@


1.22
log
@	* gdb.python/py-mi.exp: Avoid '+' in filenames.  Call C version of
	executable file "${binfile}", C++ version "${binfile}-cxx".
	* gdb.python/py-prettyprint.exp: Likewise.
	* gdb.python/py-symbol.exp: Likewise.
	* gdb.python/py-type.exp: Likewise.
	* gdb.python/py-value.exp: Likewise.
	* gdb.python/py-template.exp (test_template_arg): Pass full executable
	file name instead of just suffix.
@
text
@d219 12
d232 6
a237 1
  gdb_test "python print gdb.parse_and_eval('*(int*)0')" "gdb.MemoryError: Cannot access memory at address 0x0.*"
@


1.21
log
@	* gdb.python/py-mi.exp: Use different file names for different
	versions of the executable under test.
	* gdb.python/py-prettyprint.exp: Likewise.
	* gdb.python/py-symbol.exp: Likewise.
	* gdb.python/py-template.exp: Likewise.
	* gdb.python/py-type.exp: Likewise.
	* gdb.python/py-value.exp: Likewise.
@
text
@d28 9
a36 3
if { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug}] != "" } {
    untested "Couldn't compile ${srcfile}"
    return -1
d332 1
a332 1
proc test_subscript_regression {lang} {
d334 1
a334 5
 global srcdir subdir srcfile binfile testfile hex
 if { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}-${lang}" executable "debug $lang"] != "" } {
     untested "Couldn't compile ${srcfile} in $lang mode"
     return -1
 }
d340 1
a340 1
 gdb_load ${binfile}-${lang}
d431 3
d465 3
a467 4
# The following test recompiles the binary to test either C or C++
# values. 
test_subscript_regression "c++"
test_subscript_regression "c"
@


1.20
log
@gdb/testsuite/
	* gdb.python/py-value.exp (test_objfiles): Name the first test
	`py-value in file.filename'.
@
text
@d329 1
a329 1
 if { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable "debug $lang"] != "" } {
d338 1
a338 1
 gdb_load ${binfile}
@


1.19
log
@run copyright.sh for 2011.
@
text
@d286 2
a287 1
    gdb_test "python\nok=False\nfor file in gdb.objfiles():\n  if 'py-value' in file.filename:\n    ok=True\nprint ok\nend" "True"
@


1.18
log
@gdb
	* varobj.c (value_get_print_value): Rearrange.  Pass stream to
	apply_varobj_pretty_printer.
	* c-lang.c: Include exceptions.h.
	(c_get_string): Throw MEMORY_ERROR when appropriate.
	* python/py-prettyprint.c (enum string_repr_result): New.
	(print_stack_unless_memory_error): New function.
	(print_string_repr): Change return type.  Use
	print_stack_unless_memory_error.
	(print_children): Use print_stack_unless_memory_error.
	(apply_val_pretty_printer): Update.  Don't print children if
	string representation threw an exception.
	(apply_varobj_pretty_printer): Add 'stream' argument.  Use
	print_stack_unless_memory_error.
	* python/python.c (gdbpy_gdb_error, gdbpy_gdb_memory_error): New
	globals.
	(_initialize_python): Initialize them.
	* python/python-internal.h (GDB_PY_HANDLE_EXCEPTION): Use
	gdbpy_convert_exception.
	(GDB_PY_SET_HANDLE_EXCEPTION): Likewise.
	(gdbpy_gdb_error, gdbpy_gdb_memory_error): Declare.
	(gdbpy_convert_exception): Declare.
	(apply_varobj_pretty_printer): Update.
	* python/py-utils.c (gdbpy_convert_exception): New function.
gdb/doc
	* gdb.texinfo (Basic Python): Update.  Add xref.
	(Exception Handling): Document new exception classes.
	(Types In Python): Update.
	(Frames In Python): Update.
gdb/testsuite
	* gdb.python/py-prettyprint.c (main): Add new 'ns2' local.
	* gdb.python/py-prettyprint.exp (run_lang_tests): Add test for
	MemoryError.
	* gdb.python/python.exp (gdb_py_test_multiple): Update exception
	type.
	* gdb.python/py-value.exp (test_value_in_inferior): Add test for
	MemoryError.
	(test_subscript_regression): Update exception type.
@
text
@d1 1
a1 1
# Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.17
log
@	* lib/gdb-python.exp: New file.
	* gdb.python/py-block.exp: Use it.
	* gdb.python/py-breakpoint.exp: Ditto.
	* gdb.python/py-frame.exp: Ditto.
	* gdb.python/py-inferior.exp: Ditto.
	* gdb.python/py-param.exp: Ditto.
	* gdb.python/py-prettyprint.exp: Ditto.
	* gdb.python/py-shared.exp: Ditto.
	* gdb.python/py-symbol.exp: Ditto.
	* gdb.python/py-symtab.exp: Ditto.
	* gdb.python/py-type.exp: Ditto.
	* gdb.python/py-value.exp: Ditto.
	* gdb.python/python.exp: Ditto.
@
text
@d213 3
d377 1
a377 1
 gdb_test "python print intv\[0\]" "RuntimeError: Cannot subscript requested type.*" \
d392 1
a392 1
 gdb_test "python print pointer\[intv\]\[0\]" "RuntimeError: Cannot subscript requested type.*" \
@


1.16
log
@gdb
2010-08-30  Andre Poenitz  <andre.poenitz@@nokia.com>
	    Tom Tromey  <tromey@@redhat.com>

	PR python/11792:
	* python/py-value.c (valpy_get_dynamic_type): New function.
	(value_object_getset): Add "dynamic_type".
	(valpy_get_type): Fail on error.
gdb/doc
	PR python/11792:
	* gdb.texinfo (Values From Inferior): Document dynamic_type.
gdb/testsuite
	PR python/11792:
	* gdb.python/py-value.exp (test_subscript_regression): Add
	dynamic_type test.
@
text
@d23 2
a32 29
# Usage: gdb_py_test_multiple NAME INPUT RESULT {INPUT RESULT}...
# Run a test named NAME, consisting of multiple lines of input.
# After each input line INPUT, search for result line RESULT.
# Succeed if all results are seen; fail otherwise.
proc gdb_py_test_multiple {name args} {
    global gdb_prompt
    foreach {input result} $args {
	if {[gdb_test_multiple $input "$name - $input" {
	    -re "\[\r\n\]*($result)\[\r\n\]+($gdb_prompt | *>)$" {
		pass "$name - $input"
	    }
	}]} {
	    return 1
	}
    }
    return 0
}

# Run a command in GDB, and report a failure if a Python exception is thrown.
# If report_pass is true, report a pass if no exception is thrown.
proc gdb_py_test_silent_cmd {cmd name report_pass} {
  global gdb_prompt

  gdb_test_multiple $cmd $name {
      -re "Traceback.*$gdb_prompt $"  { fail $name }
      -re "$gdb_prompt $"	      { if $report_pass { pass $name } }
  }
}

@


1.15
log
@gdb
	PR python/11145:
	* python/py-value.c: Include expression.h.
	(valpy_do_cast): New function.
	(valpy_cast): Use it.
	(valpy_dynamic_cast): New function.
	(valpy_reinterpret_cast): Likewise.
	(value_object_methods): Add dynamic_cast, reinterpret_cast.
gdb/doc
	PR python/11145:
	* gdb.texinfo (Values From Inferior): Document dynamic_cast and
	reinterpret_cast methods.
gdb/testsuite
	PR python/11145:
	* gdb.python/py-value.c (Base, Derived): New types.
	(base): New global.
	* gdb.python/py-value.exp (test_subscript_regression): Add
	dynamic_cast test.
@
text
@d382 7
@


1.14
log
@2010-07-27  Phil Muldoon  <pmuldoon@@redhat.com>

	* python/py-value.c (valpy_call): New Function.

2010-07-27  Phil Muldoon  <pmuldoon@@redhat.com>

	* gdb.python/py-value.exp (test_inferior_function_call): New function.
	* gdb.python/py-value.c (func1): New function.
	(func2): Likewise.

2010-07-27  Phil Muldoon  <pmuldoon@@redhat.com>

	* gdb.texinfo (Values From Inferior): Add value inferior function
	call description.
@
text
@d377 5
@


1.13
log
@2010-06-08  Michael Snyder  <msnyder@@vmware.com>

	* gdb.ada/exec_changed.exp:
	Use ".*" instead of "" as wildcard regexp.

	* gdb.base/async.exp: Use ".*" instead of "" as wildcard regexp.
	* gdb.base/call-ar-st.exp: Ditto.
	* gdb.base/checkpoint.exp: Ditto.
	* gdb.base/default.exp: Ditto.
	* gdb.base/dump.exp: Ditto.
	* gdb.base/ending-run.exp: Ditto.
	* gdb.base/fileio.exp: Ditto.
	* gdb.base/miscexprs.exp: Ditto.
	* gdb.base/pointers.exp: Ditto.
	* gdb.base/readline.exp: Ditto.
	* gdb.base/reread.exp: Ditto.
	* gdb.base/restore.exp: Ditto.
	* gdb.base/shlib-call.exp: Ditto.
	* gdb.base/valgrind-db-attach.exp: Ditto.
	* gdb.base/volatile.exp: Ditto.
	* gdb.base/watchpoints.exp: Ditto.

	* gdb.cp/classes.exp: Use ".*" instead of "" as wildcard regexp.

	* gdb.python/py-frame.exp: Use ".*" instead of "" as wildcard regexp.
	* gdb.python/py-value.exp: Ditto.

	* gdb.trace/backtrace.exp: Use ".*" instead of "" as wildcard regexp.
	* gdb.trace/circ.exp: Ditto.
	* gdb.trace/collection.exp: Ditto.
	* gdb.trace/packetlen.exp: Ditto.
	* gdb.trace/passc-dyn.exp: Ditto.
	* gdb.trace/report.exp: Ditto.
	* gdb.trace/tfile.exp: Ditto.
	* gdb.trace/tfind.exp: Ditto.
	* gdb.trace/while-dyn.exp: Ditto.
@
text
@d279 29
d467 1
@


1.12
log
@	* gdb.python/py-value.exp (test_value_hash): Don't test equality
	of hash and id.
@
text
@d125 1
a125 1
  gdb_test "print (void *) 2" "" ""
d127 1
a127 1
  gdb_test "print (void *) 5" "" ""
@


1.11
log
@2010-06-03  Michael Snyder  <msnyder@@vmware.com>

	* gdb.base/commands.exp: Replace gdb_test with gdb_test_no_output.
	* gdb.base/display.exp: Ditto.
	* gdb.base/find.exp: Ditto.
	* gdb.base/ifelse.exp: Ditto.
	* gdb.base/multi-forks.exp: Ditto.
	* gdb.base/recurse.exp: Ditto.
	* gdb.base/setshow.exp: Ditto.
	* gdb.base/value-double-free.exp: Ditto.
	* gdb.base/watch-vfork.exp: Ditto.
	* gdb.base/watch_thread_num.exp: Ditto.
	* gdb.base/watchpoint-solib.exp: Ditto.
	* gdb.base/watchpoint.exp: Ditto.
	* gdb.base/watchpoints.exp: Ditto.

	* gdb.cp/classes.exp: Replace gdb_test with gdb_test_no_output.
	* gdb.cp/overload.exp: Ditto.
	* gdb.cp/virtfunc.exp: Ditto.

	* gdb.python/py-value.exp: Replace gdb_test with gdb_test_no_output.

	* gdb.reverse/watch-precsave.exp:
	Replace gdb_test with gdb_test_no_output.

	* gdb.threads/attach-into-signal.exp:
	Replace gdb_test with gdb_test_no_output.
	* gdb.threads/local-watch-wrong-thread.exp: Ditto.
	* gdb.threads/watchthreads.exp: Ditto.
	* gdb.threads/watchthreads2.exp: Ditto.

	* gdb.trace/deltrace.exp: Replace gdb_test with gdb_test_no_output.
	* gdb.trace/tfind.exp: Ditto.
@
text
@a408 1
    gdb_test "python print one.__hash__() == id(one)" "True" "Test inbuilt id"
@


1.10
log
@2010-06-02  Michael Snyder  <msnyder@@vmware.com>

	* gdb.python/py-block.exp: Use gdb_test_no_output.
	* gdb.python/py-prettyprint.exp: Ditto.
	* gdb.python/py-template.exp: Ditto.
	* gdb.python/py-value.exp: Ditto.

	* gdb.reverse/watch-precsave.exp: Use gdb_test_no_output.
	* gdb.reverse/watch-reverse.exp: Ditto.

	* gdb.server/ext-attach.exp: Use gdb_test_no_output.
	* gdb.server/ext-run.exp: Ditto.
@
text
@d126 1
a126 1
  gdb_test "python a = gdb.history (0)" "" ""
d128 1
a128 1
  gdb_test "python b = gdb.history (0)" "" ""
@


1.9
log
@2010-05-14  Phil Muldoon  <pmuldoon@@redhat.com>

 	PR python/11482

	* python/py-value.c (valpy_hash): New function.
	(value_object_type): Register valpy_hash.

2010-05-14  Phil Muldoon  <pmuldoon@@redhat.com>

 	PR python/11482

	* gdb.python/py-value.exp (test_value_hash): New function
@
text
@d119 1
a119 1
  gdb_test "python evalue = gdb.history (0)" ""
@


1.8
log
@2010-04-08  Phil Muldoon  <pmuldoon@@redhat.com>

	PR python/11417

	* python/py-lazy-string.c (stpy_convert_to_value): Check for
          a NULL address.
	  (gdbpy_create_lazy_string_object): Allow strings with a NULL
          address and a zero length.

2010-04-08  Phil Muldoon  <pmuldoon@@redhat.com>

	* gdb.python/py-value: Add null string variable.
	  (test_lazy_string): Test zero length, NULL address lazy
	  strings.
@
text
@d396 17
d429 1
@


1.7
log
@2010-02-24  Phil Muldoon  <pmuldoon@@redhat.com>

	PR python/11314
	* lib/gdb.exp (skip_python_tests): New function.
	* gdb.python/py-cmd.exp: Use skip_python_tests.
	* gdb.python/py-frame.exp: Likewise.
	* gdb.python/py-function.exp: Likewise.
	* gdb.python/py-prettyprint.exp: Likewise.
	* gdb.python/py-template.exp: Likewise.
	* gdb.python/py-type.exp: Likewise.
	* gdb.python/py-value.exp: Likewise.
@
text
@d270 6
@


1.6
log
@	* gdb.python/py-value.exp (test_value_in_inferior): Skip arg0 test
	if arguments are not supported.
@
text
@d397 2
a398 7
gdb_test_multiple "python print 'hello, world!'" "verify python support" {
    -re "not supported.*$gdb_prompt $"	{
      unsupported "python support is disabled"
      return -1
    }
    -re "$gdb_prompt $"	{}
}
@


1.5
log
@2010-01-13  Phil Muldoon  <pmuldoon@@redhat.com>

	PR python/10705

	* python/python-internal.h: Add lazy_string_object_type
	definition.
	(create_lazy_string_object, gdbpy_initialize_lazy_string)
	(gdbpy_is_lazystring, gdbpy_extract_lazy_string): Define.
	* python/py-value.c (valpy_lazy_string): New function.
	(convert_value_from_python): Add lazy string conversion.
	* python/py-prettyprint.c (pretty_print_one_value): Check if
	return is also a lazy string.
	(print_string_repr): Add lazy string printing branch.
	(print_children): Likewise.
	* python/py-lazy-string.c: New file. Implement lazy strings.
	* python/python.c (_initialize_python): Call
	gdbpy_initialize_lazy_string.
	* varobj.c (value_get_print_value): Add lazy string printing
	branch.  Account for encoding.
	* c-lang.c (c_printstr): Account for new encoding argument.  If
	encoding is NULL, find encoding suited for type, otherwise use
	user encoding.
	* language.h (language_defn): Add encoding argument.
	(LA_PRINT_STRING): Likewise.
	* language.c (unk_lang_printstr): Update to reflect new encoding
	argument to language_defn.
	* ada-lang.h (ada_printstr): Likewise.
	* c-lang.h (c_printstr): Likewise.
	* p-lang.h (pascal_printstr);
	* f-lang.c (f_printstr): Likewise.
	* m2-lang.c (m2_printstr): Likewise.
	* objc-lang.c (objc_printstr): Likewise.
	* p-lang.c (pascal_printstr): Likewise.
	* scm-lang.c (scm_printstr): Likewise.
	* c-valprint.c (c_val_print): Update LA_PRINT_STRING call for
	encoding argument.
	* ada-valprint.c (ada_printstr): Likewise.
	* f-valprint.c (f_val_print): Likewise
	* m2-valprint.c (m2_val_print): Likewise.
	* p-valprint.c (pascal_val_print): Likewise.
	* expprint.c (print_subexp_standard): Likewise.
	* valprint.c (val_print_string): Likewise.
	* Makefile.in (SUBDIR_PYTHON_OBS): Add py-lazy-string.
	(SUBDIR_PYTHON_SRCS): Likewise.
	(py-lazy-string.o): New rule.

2010-01-13  Phil Muldoon  <pmuldoon@@redhat.com>

	* gdb.texinfo (Values From Inferior): Document lazy_string value
	method.
	(Python API): Add Lazy strings menu item.
	(Lazy Strings In Python): New node.

2010-01-13  Phil Muldoon  <pmuldoon@@redhat.com>

	* gdb.python/py-value.exp (test_lazy_strings): Add lazy string test.
	* gdb.python/py-prettyprint.py (pp_ls): New printer.
	* gdb.python/py-prettyprint.exp (run_lang_tests): Add lazy string
	test.
	* gdb.python/py-prettyprint.c: Define lazystring test structure.
	* gdb.python/py-mi.exp: Add lazy string test.
@
text
@d230 3
a232 1
  gdb_test "python print arg0" "0x.*$testfile\"" "verify dereferenced value"
@


1.4
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d258 13
d418 1
@


1.3
log
@gdb
	* python/python.c (gdbpy_parse_and_eval): New function.
	(GdbMethods): Add "parse_and_eval".
gdb/testsuite
	* gdb.python/py-value.exp (test_parse_and_eval): New
	function.
gdb/doc
	* gdb.texinfo (Basic Python): Document gdb.parse_and_eval.
@
text
@d1 1
a1 1
# Copyright (C) 2008, 2009 Free Software Foundation, Inc.
@


1.2
log
@2009-09-21  Phil Muldoon <pmuldoon@@redhat.com>

	* python/py-value.c (valpy_getitem): Test value before allowing
	subscript operation.

2009-09-21  Phil Muldoon <pmuldoon@@redhat.com>

	* gdb.python/py-value.exp (test_subscript_regression): New
	function.  Test for invalid subscripts.
	* gdb.python/py-value.c (main): Add test array, and pointer to it.
	(ptr_ref): New function.
@
text
@d364 11
d395 1
@


1.1
log
@Checking in this patch for Thiago: Rename python-* files into py-*,
more 8+3 friendly.


gdb/
        * Makefile.in (py-cmd.o): Renamed from python-cmd.o.  Updated
        references.
        (py-frame.o): Renamed from python-frame.o.  Updated references.
        (py-function.o): Renamed from python-function.o.  Updated references.
        (py-objfile.o): Renamed from python-objfile.o.  Updated references.
        (py-prettyprint.o): Renamed from python-prettyprint.o.  Updated
+references.
        (py-type.o): Renamed from python-type.o.  Updated references.
        (py-utils.o): Renamed from python-utils.o.  Updated references.
        (py-value.o): Renamed from python-value.o.  Updated references.
        * py-cmd.o: Renamed from python-cmd.o.
        * py-frame.o: Renamed from python-frame.o.
        * py-function.o: Renamed from python-function.o.
        * py-objfile.o: Renamed from python-objfile.o.
        * py-prettyprint.o: Renamed from python-prettyprint.o.
        * py-type.o: Renamed from python-type.o.
        * py-utils.o: Renamed from python-utils.o.
        * py-value.o: Renamed from python-value.o.

gdb/testsuite/
        * gdb.python/Makefile.in (EXECUTABLES): Adjust to new executable
        names, add missing ones.
        * gdb.python/py-cmd.exp: Rename from python-cmd.exp.
        * gdb.python/py-frame.c: Rename from python-frame.c.
        * gdb.python/py-frame.exp: Rename from python-frame.exp.  Adjust
        testfile name.
        * gdb.python/py-function.exp: Rename from python-function.exp.
        * gdb.python/py-mi.exp: Rename from python-mi.exp.  Adjust
        testfile name.
        * gdb.python/py-prettyprint.c: Rename from python-prettyprint.c.
        * gdb.python/py-prettyprint.exp: Rename from python-prettyprint.exp.
        Adjust testfile name.
        * gdb.python/py-prettyprint.py: Rename from python-prettyprint.py.
        * gdb.python/py-template.cc: Rename from python-template.cc.
        * gdb.python/py-template.exp: Rename from python-template.exp.
        Adjust testfile name.
        * gdb.python/py-value.c: Rename from python-value.c.
        * gdb.python/py-value.exp: Rename from python-value.exp.  Adjust
        testfile name.
@
text
@d295 69
d394 5
@


1.1.2.1
log
@2009-09-21  Phil Muldoon  <pmuldoon@@redhat.com>

	* python/py-value.c (valpy_getitem): Test value before allowing
	subscript operation.

2009-09-21  Phil Muldoon  <pmuldoon@@redhat.com>

	* gdb.python/py-value.exp (test_subscript_regression): New
	function.  Test for invalid subscripts.
	* gdb.python/py-value.c (main): Add test array, and pointer to it.
	(ptr_ref): New function.
@
text
@a294 69
# Regression test for invalid subscript operations.  The bug was that
# the type of the value was not being checked before allowing a
# subscript operation to proceed.

proc test_subscript_regression {lang} {

 global srcdir subdir srcfile binfile testfile hex
 if { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable "debug $lang"] != "" } {
     untested "Couldn't compile ${srcfile} in $lang mode"
     return -1
 }

 # Start with a fresh gdb.
 gdb_exit
 gdb_start
 gdb_reinitialize_dir $srcdir/$subdir
 gdb_load ${binfile}

 if ![runto_main ] then {
     perror "couldn't run to breakpoint"
     return
 }

 if {$lang == "c++"} {
     gdb_breakpoint [gdb_get_line_number "break to inspect pointer by reference"]
     gdb_continue_to_breakpoint "break to inspect pointer by reference"

     gdb_py_test_silent_cmd "print rptr_int" \
	 "Obtain address" 1
     gdb_py_test_silent_cmd "python rptr = gdb.history(0)" \
	 "Obtains value from GDB" 1
     gdb_test "python print rptr\[0\]" "2" "Check pointer passed as reference"
 }

 gdb_breakpoint [gdb_get_line_number "break to inspect struct and union"]
 gdb_continue_to_breakpoint "break to inspect struct and union"

 gdb_py_test_silent_cmd "python intv = gdb.Value(1)" \
     "Create a value for subscript test" 1
 gdb_py_test_silent_cmd "python stringv = gdb.Value(\"foo\")" \
     "Create a value for subscript test" 1

 # Try to access an int with a subscript.  This should fail.
 gdb_test "python print intv" "1" "Baseline print of a Python value"
 gdb_test "python print intv\[0\]" "RuntimeError: Cannot subscript requested type.*" \
     "Attempt to access an integer with a subscript"

 # Try to access a string with a subscript.  This should pass.
 gdb_test "python print stringv" "foo." "Baseline print of a Python value"
 gdb_test "python print stringv\[0\]" "f." "Attempt to access a string with a subscript"

 # Try to access an int array via a pointer with a subscript.  This should pass.
 gdb_py_test_silent_cmd "print p" "Build pointer to array" 1
 gdb_py_test_silent_cmd "python pointer = gdb.history(0)" "" 1
 gdb_test "python print pointer\[0\]" "1" "Access array via pointer with int subscript"
 gdb_test "python print pointer\[intv\]" "2" "Access array via pointer with value subscript"

 # Try to access a single dimension array with a subscript to the
 # result.  This should fail.
 gdb_test "python print pointer\[intv\]\[0\]" "RuntimeError: Cannot subscript requested type.*" \
     "Attempt to access an integer with a subscript"

 # Lastly, test subscript access to an array with multiple
 # dimensions.  This should pass.
 gdb_py_test_silent_cmd "print {\"fu \",\"foo\",\"bar\"}" "Build array" 1
 gdb_py_test_silent_cmd "python marray = gdb.history(0)" "" 1
 gdb_test "python print marray\[1\]\[2\]" "o." "Test multiple subscript"
}

a324 5

# The following test recompiles the binary to test either C or C++
# values. 
test_subscript_regression "c++"
test_subscript_regression "c"
@


