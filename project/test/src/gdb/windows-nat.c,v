head	1.262;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.241
	gdb_7_6-2013-04-26-release:1.241
	gdb_7_6-branch:1.241.0.2
	gdb_7_6-2013-03-12-branchpoint:1.241
	gdb_7_5_1-2012-11-29-release:1.228
	gdb_7_5-2012-08-17-release:1.228
	gdb_7_5-branch:1.228.0.2
	gdb_7_5-2012-07-18-branchpoint:1.228
	gdb_7_4_1-2012-04-26-release:1.220.2.1
	gdb_7_4-2012-01-24-release:1.220.2.1
	gdb_7_4-branch:1.220.0.2
	gdb_7_4-2011-12-13-branchpoint:1.220
	gdb_7_3_1-2011-09-04-release:1.215
	gdb_7_3-2011-07-26-release:1.215
	gdb_7_3-branch:1.215.0.2
	gdb_7_3-2011-04-01-branchpoint:1.215
	gdb_7_2-2010-09-02-release:1.210
	gdb_7_2-branch:1.210.0.2
	gdb_7_2-2010-07-07-branchpoint:1.210
	gdb_7_1-2010-03-18-release:1.203
	gdb_7_1-branch:1.203.0.2
	gdb_7_1-2010-02-18-branchpoint:1.203
	gdb_7_0_1-2009-12-22-release:1.196.4.1
	gdb_7_0-2009-10-06-release:1.196.4.1
	gdb_7_0-branch:1.196.0.4
	gdb_7_0-2009-09-16-branchpoint:1.196
	msnyder-checkpoint-072509-branch:1.196.0.2
	msnyder-checkpoint-072509-branchpoint:1.196;
locks; strict;
comment	@ * @;
expand	@o@;


1.262
date	2013.09.30.11.50.12;	author luisgpm;	state Exp;
branches;
next	1.261;

1.261
date	2013.09.02.13.11.13;	author muller;	state Exp;
branches;
next	1.260;

1.260
date	2013.09.02.12.57.49;	author muller;	state Exp;
branches;
next	1.259;

1.259
date	2013.09.02.12.45.55;	author muller;	state Exp;
branches;
next	1.258;

1.258
date	2013.08.27.11.36.09;	author palves;	state Exp;
branches;
next	1.257;

1.257
date	2013.07.01.11.28.30;	author palves;	state Exp;
branches;
next	1.256;

1.256
date	2013.06.11.11.03.42;	author brobecke;	state Exp;
branches;
next	1.255;

1.255
date	2013.06.11.11.01.46;	author brobecke;	state Exp;
branches;
next	1.254;

1.254
date	2013.06.11.10.20.24;	author brobecke;	state Exp;
branches;
next	1.253;

1.253
date	2013.06.11.10.20.11;	author brobecke;	state Exp;
branches;
next	1.252;

1.252
date	2013.05.30.13.52.31;	author brobecke;	state Exp;
branches;
next	1.251;

1.251
date	2013.05.22.16.18.12;	author eliz;	state Exp;
branches;
next	1.250;

1.250
date	2013.05.20.10.27.26;	author brobecke;	state Exp;
branches;
next	1.249;

1.249
date	2013.05.04.13.36.18;	author eliz;	state Exp;
branches;
next	1.248;

1.248
date	2013.04.06.06.52.06;	author eliz;	state Exp;
branches;
next	1.247;

1.247
date	2013.03.27.08.57.09;	author muller;	state Exp;
branches;
next	1.246;

1.246
date	2013.03.26.23.40.08;	author brobecke;	state Exp;
branches;
next	1.245;

1.245
date	2013.03.23.10.48.23;	author eliz;	state Exp;
branches;
next	1.244;

1.244
date	2013.03.20.15.46.24;	author jkratoch;	state Exp;
branches;
next	1.243;

1.243
date	2013.03.20.08.51.06;	author corinna;	state Exp;
branches;
next	1.242;

1.242
date	2013.03.19.15.06.26;	author corinna;	state Exp;
branches;
next	1.241;

1.241
date	2013.02.27.19.42.26;	author corinna;	state Exp;
branches;
next	1.240;

1.240
date	2013.02.19.15.46.32;	author ktietz;	state Exp;
branches;
next	1.239;

1.239
date	2013.02.13.14.59.49;	author palves;	state Exp;
branches;
next	1.238;

1.238
date	2013.01.01.06.41.29;	author brobecke;	state Exp;
branches;
next	1.237;

1.237
date	2012.12.14.07.50.02;	author muller;	state Exp;
branches;
next	1.236;

1.236
date	2012.11.13.09.46.10;	author muller;	state Exp;
branches;
next	1.235;

1.235
date	2012.11.09.19.58.02;	author tromey;	state Exp;
branches;
next	1.234;

1.234
date	2012.10.24.13.40.16;	author brobecke;	state Exp;
branches;
next	1.233;

1.233
date	2012.09.26.21.23.11;	author muller;	state Exp;
branches;
next	1.232;

1.232
date	2012.08.22.16.24.39;	author tromey;	state Exp;
branches;
next	1.231;

1.231
date	2012.07.23.14.57.57;	author tromey;	state Exp;
branches;
next	1.230;

1.230
date	2012.07.23.14.56.10;	author tromey;	state Exp;
branches;
next	1.229;

1.229
date	2012.07.18.19.33.34;	author tromey;	state Exp;
branches;
next	1.228;

1.228
date	2012.05.24.16.51.36;	author palves;	state Exp;
branches;
next	1.227;

1.227
date	2012.05.24.16.39.12;	author palves;	state Exp;
branches;
next	1.226;

1.226
date	2012.05.04.18.36.30;	author brobecke;	state Exp;
branches;
next	1.225;

1.225
date	2012.03.02.05.38.51;	author jkratoch;	state Exp;
branches;
next	1.224;

1.224
date	2012.02.02.20.19.16;	author devans;	state Exp;
branches;
next	1.223;

1.223
date	2012.01.04.08.27.58;	author brobecke;	state Exp;
branches;
next	1.222;

1.222
date	2011.12.16.19.55.26;	author muller;	state Exp;
branches;
next	1.221;

1.221
date	2011.12.14.17.20.31;	author palves;	state Exp;
branches;
next	1.220;

1.220
date	2011.10.07.13.52.11;	author corinna;	state Exp;
branches
	1.220.2.1;
next	1.219;

1.219
date	2011.09.28.09.07.54;	author eliz;	state Exp;
branches;
next	1.218;

1.218
date	2011.05.09.14.25.37;	author palves;	state Exp;
branches;
next	1.217;

1.217
date	2011.04.19.18.04.07;	author tromey;	state Exp;
branches;
next	1.216;

1.216
date	2011.04.07.22.24.17;	author muller;	state Exp;
branches;
next	1.215;

1.215
date	2011.03.23.18.23.55;	author ktietz;	state Exp;
branches;
next	1.214;

1.214
date	2011.03.16.17.59.03;	author muller;	state Exp;
branches;
next	1.213;

1.213
date	2011.01.12.01.23.29;	author msnyder;	state Exp;
branches;
next	1.212;

1.212
date	2011.01.01.15.33.19;	author brobecke;	state Exp;
branches;
next	1.211;

1.211
date	2010.11.28.04.31.24;	author jkratoch;	state Exp;
branches;
next	1.210;

1.210
date	2010.05.31.07.00.41;	author muller;	state Exp;
branches;
next	1.209;

1.209
date	2010.05.25.07.38.18;	author muller;	state Exp;
branches;
next	1.208;

1.208
date	2010.04.16.07.49.35;	author muller;	state Exp;
branches;
next	1.207;

1.207
date	2010.03.10.15.57.07;	author cgf;	state Exp;
branches;
next	1.206;

1.206
date	2010.03.09.19.10.39;	author cgf;	state Exp;
branches;
next	1.205;

1.205
date	2010.03.06.19.27.09;	author cgf;	state Exp;
branches;
next	1.204;

1.204
date	2010.03.01.09.09.24;	author corinna;	state Exp;
branches;
next	1.203;

1.203
date	2010.02.15.17.35.49;	author jkratoch;	state Exp;
branches;
next	1.202;

1.202
date	2010.02.12.04.55.15;	author brobecke;	state Exp;
branches;
next	1.201;

1.201
date	2010.01.27.19.57.54;	author cgf;	state Exp;
branches;
next	1.200;

1.200
date	2010.01.25.10.54.58;	author gingold;	state Exp;
branches;
next	1.199;

1.199
date	2010.01.01.07.31.46;	author brobecke;	state Exp;
branches;
next	1.198;

1.198
date	2009.10.19.09.51.42;	author palves;	state Exp;
branches;
next	1.197;

1.197
date	2009.09.21.22.37.59;	author muller;	state Exp;
branches;
next	1.196;

1.196
date	2009.07.02.17.21.07;	author uweigand;	state Exp;
branches
	1.196.4.1;
next	1.195;

1.195
date	2009.06.17.18.44.23;	author uweigand;	state Exp;
branches;
next	1.194;

1.194
date	2009.06.16.18.49.25;	author ppluzhnikov;	state Exp;
branches;
next	1.193;

1.193
date	2009.06.07.16.46.48;	author palves;	state Exp;
branches;
next	1.192;

1.192
date	2009.05.24.12.27.35;	author muller;	state Exp;
branches;
next	1.191;

1.191
date	2009.05.21.15.48.41;	author palves;	state Exp;
branches;
next	1.190;

1.190
date	2009.05.14.09.37.00;	author muller;	state Exp;
branches;
next	1.189;

1.189
date	2009.04.17.15.44.28;	author muller;	state Exp;
branches;
next	1.188;

1.188
date	2009.04.01.16.35.40;	author brobecke;	state Exp;
branches;
next	1.187;

1.187
date	2009.03.22.22.13.21;	author cgf;	state Exp;
branches;
next	1.186;

1.186
date	2009.03.22.21.43.56;	author cgf;	state Exp;
branches;
next	1.185;

1.185
date	2009.03.22.21.27.30;	author cgf;	state Exp;
branches;
next	1.184;

1.184
date	2009.03.17.19.28.09;	author brobecke;	state Exp;
branches;
next	1.183;

1.183
date	2009.03.08.21.01.52;	author cgf;	state Exp;
branches;
next	1.182;

1.182
date	2009.02.24.15.27.58;	author muller;	state Exp;
branches;
next	1.181;

1.181
date	2009.02.23.00.03.50;	author palves;	state Exp;
branches;
next	1.180;

1.180
date	2009.02.20.10.52.23;	author muller;	state Exp;
branches;
next	1.179;

1.179
date	2009.02.06.22.21.26;	author palves;	state Exp;
branches;
next	1.178;

1.178
date	2009.01.14.05.27.48;	author brobecke;	state Exp;
branches;
next	1.177;

1.177
date	2009.01.13.04.14.07;	author cgf;	state Exp;
branches;
next	1.176;

1.176
date	2009.01.12.01.10.28;	author cgf;	state Exp;
branches;
next	1.175;

1.175
date	2009.01.11.13.10.44;	author brobecke;	state Exp;
branches;
next	1.174;

1.174
date	2009.01.11.04.13.55;	author brobecke;	state Exp;
branches;
next	1.173;

1.173
date	2009.01.09.10.58.26;	author brobecke;	state Exp;
branches;
next	1.172;

1.172
date	2009.01.09.10.48.36;	author brobecke;	state Exp;
branches;
next	1.171;

1.171
date	2009.01.09.10.45.42;	author brobecke;	state Exp;
branches;
next	1.170;

1.170
date	2009.01.09.10.43.37;	author brobecke;	state Exp;
branches;
next	1.169;

1.169
date	2009.01.09.10.39.15;	author brobecke;	state Exp;
branches;
next	1.168;

1.168
date	2009.01.09.10.36.00;	author brobecke;	state Exp;
branches;
next	1.167;

1.167
date	2009.01.03.05.57.54;	author brobecke;	state Exp;
branches;
next	1.166;

1.166
date	2008.11.09.11.27.18;	author vprus;	state Exp;
branches;
next	1.165;

1.165
date	2008.10.02.14.20.07;	author muller;	state Exp;
branches;
next	1.164;

1.164
date	2008.09.22.15.21.30;	author palves;	state Exp;
branches;
next	1.163;

1.163
date	2008.09.22.15.20.08;	author palves;	state Exp;
branches;
next	1.162;

1.162
date	2008.09.22.15.16.51;	author palves;	state Exp;
branches;
next	1.161;

1.161
date	2008.09.08.21.51.18;	author palves;	state Exp;
branches;
next	1.160;

1.160
date	2008.08.08.13.16.17;	author palves;	state Exp;
branches;
next	1.159;

1.159
date	2008.07.09.22.49.56;	author palves;	state Exp;
branches;
next	1.158;

1.158
date	2008.07.09.22.23.05;	author palves;	state Exp;
branches;
next	1.157;

1.157
date	2008.07.03.17.38.08;	author palves;	state Exp;
branches;
next	1.156;

1.156
date	2008.06.26.15.51.28;	author drow;	state Exp;
branches;
next	1.155;

1.155
date	2008.06.24.02.33.17;	author cgf;	state Exp;
branches;
next	1.154;

1.154
date	2008.06.19.06.36.45;	author muller;	state Exp;
branches;
next	1.153;

1.153
date	2008.06.18.06.27.34;	author muller;	state Exp;
branches;
next	1.152;

1.152
date	2008.05.20.18.36.36;	author brobecke;	state Exp;
branches;
next	1.151;

1.151
date	2008.03.11.05.21.38;	author deuling;	state Exp;
branches;
next	1.150;

1.150
date	2008.01.29.21.11.24;	author brobecke;	state Exp;
branches;
next	1.149;

1.149
date	2008.01.25.00.09.50;	author msnyder;	state Exp;
branches;
next	1.148;

1.148
date	2008.01.23.11.26.28;	author vprus;	state Exp;
branches;
next	1.147;

1.147
date	2008.01.14.08.01.15;	author muller;	state Exp;
branches;
next	1.146;

1.146
date	2008.01.06.06.59.14;	author cgf;	state Exp;
branches;
next	1.145;

1.145
date	2008.01.01.18.42.08;	author cgf;	state Exp;
branches;
next	1.144;

1.144
date	2007.12.22.22.09.56;	author muller;	state Exp;
branches;
next	1.143;

1.143
date	2007.12.06.11.17.03;	author muller;	state Exp;
branches;
next	1.142;

1.142
date	2007.12.02.21.32.46;	author muller;	state Exp;
branches;
next	1.141;

1.141
date	2007.12.02.05.45.08;	author cgf;	state Exp;
branches;
next	1.140;

1.140
date	2007.11.24.12.13.28;	author palves;	state Exp;
branches;
next	1.139;

1.139
date	2007.11.16.04.53.46;	author deuling;	state Exp;
branches;
next	1.138;

1.138
date	2007.10.16.18.43.24;	author palves;	state Exp;
branches;
next	1.137;

1.137
date	2007.09.04.01.12.18;	author palves;	state Exp;
branches;
next	1.136;

1.136
date	2007.09.03.23.06.35;	author palves;	state Exp;
branches;
next	1.135;

1.135
date	2007.08.23.18.08.47;	author brobecke;	state Exp;
branches;
next	1.134;

1.134
date	2007.08.14.11.09.45;	author vprus;	state Exp;
branches;
next	1.133;

1.133
date	2007.06.18.17.45.26;	author uweigand;	state Exp;
branches;
next	1.132;

1.132
date	2007.06.16.17.16.25;	author uweigand;	state Exp;
branches;
next	1.131;

1.131
date	2007.05.31.17.32.21;	author uweigand;	state Exp;
branches;
next	1.130;

1.130
date	2007.05.06.18.55.41;	author uweigand;	state Exp;
branches;
next	1.129;

1.129
date	2007.05.06.14.34.38;	author uweigand;	state Exp;
branches;
next	1.128;

1.128
date	2007.05.06.14.33.21;	author uweigand;	state Exp;
branches;
next	1.127;

1.127
date	2007.04.19.19.35.24;	author palves;	state Exp;
branches;
next	1.126;

1.126
date	2007.02.12.13.04.36;	author corinna;	state Exp;
branches;
next	1.125;

1.125
date	2007.01.09.17.58.59;	author drow;	state Exp;
branches;
next	1.124;

1.124
date	2006.12.09.09.12.59;	author corinna;	state Exp;
branches;
next	1.123;

1.123
date	2006.05.21.23.04.39;	author cgf;	state Exp;
branches;
next	1.122;

1.122
date	2006.04.10.21.43.45;	author cgf;	state Exp;
branches
	1.122.6.1;
next	1.121;

1.121
date	2006.04.10.16.13.01;	author cgf;	state Exp;
branches;
next	1.120;

1.120
date	2006.02.20.05.10.51;	author cgf;	state Exp;
branches;
next	1.119;

1.119
date	2006.01.24.22.09.28;	author drow;	state Exp;
branches;
next	1.118;

1.118
date	2005.12.17.22.34.03;	author eliz;	state Exp;
branches;
next	1.117;

1.117
date	2005.11.28.01.17.59;	author cgf;	state Exp;
branches;
next	1.116;

1.116
date	2005.11.01.14.07.00;	author cgf;	state Exp;
branches
	1.116.4.1;
next	1.115;

1.115
date	2005.11.01.05.08.28;	author cgf;	state Exp;
branches;
next	1.114;

1.114
date	2005.11.01.00.40.09;	author cgf;	state Exp;
branches;
next	1.113;

1.113
date	2005.10.31.22.50.58;	author cgf;	state Exp;
branches;
next	1.112;

1.112
date	2005.07.06.14.54.34;	author bobbybrasko;	state Exp;
branches
	1.112.2.1;
next	1.111;

1.111
date	2005.05.23.19.32.27;	author cagney;	state Exp;
branches;
next	1.110;

1.110
date	2005.03.27.05.21.12;	author cgf;	state Exp;
branches;
next	1.109;

1.109
date	2005.03.21.19.54.15;	author cgf;	state Exp;
branches;
next	1.108;

1.108
date	2005.02.18.15.25.31;	author cagney;	state Exp;
branches;
next	1.107;

1.107
date	2005.02.15.15.49.23;	author cagney;	state Exp;
branches;
next	1.106;

1.106
date	2005.02.14.18.10.10;	author cagney;	state Exp;
branches;
next	1.105;

1.105
date	2005.02.11.18.13.54;	author cagney;	state Exp;
branches;
next	1.104;

1.104
date	2005.02.11.04.06.09;	author cagney;	state Exp;
branches;
next	1.103;

1.103
date	2005.01.23.05.09.46;	author cgf;	state Exp;
branches;
next	1.102;

1.102
date	2005.01.12.18.31.34;	author cagney;	state Exp;
branches;
next	1.101;

1.101
date	2004.10.08.20.29.56;	author cagney;	state Exp;
branches;
next	1.100;

1.100
date	2004.10.05.21.53.33;	author cagney;	state Exp;
branches;
next	1.99;

1.99
date	2004.09.29.14.26.52;	author cagney;	state Exp;
branches;
next	1.98;

1.98
date	2004.09.29.13.54.33;	author cagney;	state Exp;
branches;
next	1.97;

1.97
date	2004.07.26.14.53.06;	author cagney;	state Exp;
branches;
next	1.96;

1.96
date	2004.07.24.01.00.21;	author cagney;	state Exp;
branches;
next	1.95;

1.95
date	2004.07.22.01.31.49;	author cagney;	state Exp;
branches;
next	1.94;

1.94
date	2004.07.01.21.34.02;	author msnyder;	state Exp;
branches;
next	1.93;

1.93
date	2004.06.29.15.37.31;	author corinna;	state Exp;
branches;
next	1.92;

1.92
date	2004.06.25.19.46.08;	author cagney;	state Exp;
branches;
next	1.91;

1.91
date	2004.06.24.21.51.49;	author cagney;	state Exp;
branches;
next	1.90;

1.90
date	2004.06.15.01.04.20;	author amodra;	state Exp;
branches;
next	1.89;

1.89
date	2004.05.25.14.58.31;	author cagney;	state Exp;
branches;
next	1.88;

1.88
date	2004.04.21.17.47.10;	author cagney;	state Exp;
branches;
next	1.87;

1.87
date	2004.01.05.19.53.08;	author cagney;	state Exp;
branches
	1.87.6.1;
next	1.86;

1.86
date	2003.12.26.14.56.45;	author cgf;	state Exp;
branches;
next	1.85;

1.85
date	2003.12.26.04.29.22;	author cgf;	state Exp;
branches;
next	1.84;

1.84
date	2003.12.26.00.39.04;	author cgf;	state Exp;
branches;
next	1.83;

1.83
date	2003.10.26.15.03.41;	author kettenis;	state Exp;
branches;
next	1.82;

1.82
date	2003.10.23.03.01.55;	author cagney;	state Exp;
branches;
next	1.81;

1.81
date	2003.09.21.01.26.46;	author cagney;	state Exp;
branches;
next	1.80;

1.80
date	2003.09.20.02.38.39;	author cgf;	state Exp;
branches;
next	1.79;

1.79
date	2003.09.13.16.46.21;	author cgf;	state Exp;
branches;
next	1.78;

1.78
date	2003.09.13.02.26.42;	author cgf;	state Exp;
branches;
next	1.77;

1.77
date	2003.07.06.19.48.54;	author cgf;	state Exp;
branches;
next	1.76;

1.76
date	2003.06.11.22.36.04;	author brobecke;	state Exp;
branches
	1.76.4.1;
next	1.75;

1.75
date	2003.06.06.23.33.00;	author mmitchel;	state Exp;
branches;
next	1.74;

1.74
date	2003.02.21.02.29.18;	author cgf;	state Exp;
branches;
next	1.73;

1.73
date	2003.02.15.03.24.54;	author cgf;	state Exp;
branches;
next	1.72;

1.72
date	2003.02.14.05.15.43;	author cgf;	state Exp;
branches;
next	1.71;

1.71
date	2003.02.06.20.37.55;	author cgf;	state Exp;
branches;
next	1.70;

1.70
date	2003.02.06.19.51.25;	author cgf;	state Exp;
branches;
next	1.69;

1.69
date	2003.01.30.01.39.52;	author cgf;	state Exp;
branches;
next	1.68;

1.68
date	2003.01.14.00.49.04;	author cagney;	state Exp;
branches;
next	1.67;

1.67
date	2003.01.10.20.14.02;	author corinna;	state Exp;
branches;
next	1.66;

1.66
date	2002.11.23.02.49.45;	author cgf;	state Exp;
branches;
next	1.65;

1.65
date	2002.11.22.07.34.54;	author cgf;	state Exp;
branches;
next	1.64;

1.64
date	2002.11.12.21.43.55;	author drow;	state Exp;
branches;
next	1.63;

1.63
date	2002.11.02.14.59.10;	author cagney;	state Exp;
branches;
next	1.62;

1.62
date	2002.09.14.03.28.23;	author cgf;	state Exp;
branches
	1.62.2.1
	1.62.4.1;
next	1.61;

1.61
date	2002.08.26.19.18.33;	author ciceron;	state Exp;
branches
	1.61.2.1;
next	1.60;

1.60
date	2002.07.11.13.50.49;	author cagney;	state Exp;
branches;
next	1.59;

1.59
date	2002.07.10.22.38.05;	author cagney;	state Exp;
branches;
next	1.58;

1.58
date	2002.03.22.05.03.22;	author cgf;	state Exp;
branches
	1.58.6.1;
next	1.57;

1.57
date	2002.03.06.06.28.34;	author cagney;	state Exp;
branches;
next	1.56;

1.56
date	2002.02.22.17.04.25;	author muller;	state Exp;
branches
	1.56.2.1;
next	1.55;

1.55
date	2002.02.22.01.35.59;	author cgf;	state Exp;
branches;
next	1.54;

1.54
date	2002.02.21.06.44.05;	author cgf;	state Exp;
branches;
next	1.53;

1.53
date	2002.02.21.04.59.36;	author cgf;	state Exp;
branches;
next	1.52;

1.52
date	2002.02.19.08.49.41;	author muller;	state Exp;
branches;
next	1.51;

1.51
date	2002.02.16.02.33.24;	author cgf;	state Exp;
branches;
next	1.50;

1.50
date	2002.02.08.23.12.16;	author cgf;	state Exp;
branches;
next	1.49;

1.49
date	2002.02.08.21.22.10;	author hunt;	state Exp;
branches;
next	1.48;

1.48
date	2002.02.08.19.31.38;	author muller;	state Exp;
branches;
next	1.47;

1.47
date	2002.02.06.09.27.29;	author muller;	state Exp;
branches;
next	1.46;

1.46
date	2002.02.06.09.14.50;	author muller;	state Exp;
branches;
next	1.45;

1.45
date	2002.02.05.08.04.22;	author muller;	state Exp;
branches;
next	1.44;

1.44
date	2002.02.04.11.00.05;	author muller;	state Exp;
branches;
next	1.43;

1.43
date	2002.01.19.03.32.41;	author cagney;	state Exp;
branches;
next	1.42;

1.42
date	2002.01.08.08.26.42;	author muller;	state Exp;
branches;
next	1.41;

1.41
date	2001.12.03.08.19.01;	author muller;	state Exp;
branches;
next	1.40;

1.40
date	2001.11.27.05.16.39;	author cgf;	state Exp;
branches;
next	1.39;

1.39
date	2001.11.27.05.15.56;	author cgf;	state Exp;
branches;
next	1.38;

1.38
date	2001.11.24.19.00.03;	author cgf;	state Exp;
branches;
next	1.37;

1.37
date	2001.11.24.18.21.26;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2001.11.01.16.17.08;	author fnf;	state Exp;
branches;
next	1.35;

1.35
date	2001.10.31.19.05.35;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2001.10.30.17.34.30;	author fnf;	state Exp;
branches;
next	1.33;

1.33
date	2001.10.26.09.29.31;	author corinna;	state Exp;
branches;
next	1.32;

1.32
date	2001.10.20.05.11.41;	author cgf;	state Exp;
branches;
next	1.31;

1.31
date	2001.10.16.04.50.21;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2001.10.13.01.20.29;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2001.10.12.04.32.15;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2001.10.11.01.55.58;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2001.05.04.04.15.28;	author kevinb;	state Exp;
branches
	1.27.4.1;
next	1.26;

1.26
date	2001.03.18.21.35.58;	author chastain;	state Exp;
branches;
next	1.25;

1.25
date	2001.03.06.08.21.18;	author kevinb;	state Exp;
branches;
next	1.24;

1.24
date	2001.03.01.01.39.22;	author cagney;	state Exp;
branches;
next	1.23;

1.23
date	2001.02.19.11.47.16;	author eliz;	state Exp;
branches;
next	1.22;

1.22
date	2001.02.06.05.04.40;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2001.02.06.05.01.04;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2001.01.27.19.32.32;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2001.01.25.22.35.01;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2000.12.15.01.01.51;	author kevinb;	state Exp;
branches;
next	1.17;

1.17
date	2000.11.28.17.27.38;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2000.11.15.19.58.14;	author kevinb;	state Exp;
branches;
next	1.15;

1.15
date	2000.08.27.04.21.35;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2000.08.06.23.25.32;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2000.07.30.01.48.28;	author kevinb;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.11.02.34.40;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2000.06.04.00.41.09;	author kevinb;	state Exp;
branches;
next	1.10;

1.10
date	2000.06.04.00.28.17;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.03.05.04.14;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.28.01.12.33;	author kevinb;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.21.14.24.45;	author ezannoni;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.21.02.26.14;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.25.02.26.21;	author cgf;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2000.02.28.06.43.20;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.28.06.31.36;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.09.08.52.47;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.07;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.220.2.1
date	2012.01.06.04.54.34;	author brobecke;	state Exp;
branches;
next	;

1.196.4.1
date	2009.09.30.07.40.10;	author muller;	state Exp;
branches;
next	;

1.122.6.1
date	2006.08.28.07.48.47;	author nickrob;	state Exp;
branches;
next	;

1.116.4.1
date	2006.01.26.18.10.22;	author drow;	state Exp;
branches;
next	;

1.112.2.1
date	2006.01.26.18.05.55;	author drow;	state Exp;
branches;
next	;

1.87.6.1
date	2004.09.16.17.01.27;	author drow;	state Exp;
branches;
next	;

1.76.4.1
date	2003.07.06.19.55.40;	author cgf;	state Exp;
branches;
next	1.76.4.2;

1.76.4.2
date	2003.09.13.02.26.52;	author cgf;	state Exp;
branches;
next	1.76.4.3;

1.76.4.3
date	2003.09.13.16.58.12;	author cgf;	state Exp;
branches;
next	1.76.4.4;

1.76.4.4
date	2003.09.20.02.39.49;	author cgf;	state Exp;
branches;
next	;

1.62.2.1
date	2002.11.15.19.19.01;	author carlton;	state Exp;
branches;
next	1.62.2.2;

1.62.2.2
date	2002.12.23.19.38.50;	author carlton;	state Exp;
branches;
next	1.62.2.3;

1.62.2.3
date	2003.02.07.19.17.54;	author carlton;	state Exp;
branches;
next	1.62.2.4;

1.62.2.4
date	2003.03.06.00.56.33;	author carlton;	state Exp;
branches;
next	1.62.2.5;

1.62.2.5
date	2003.06.27.21.50.13;	author carlton;	state Exp;
branches;
next	1.62.2.6;

1.62.2.6
date	2003.08.05.17.13.15;	author carlton;	state Exp;
branches;
next	1.62.2.7;

1.62.2.7
date	2003.09.17.21.28.36;	author carlton;	state Exp;
branches;
next	1.62.2.8;

1.62.2.8
date	2003.11.11.23.50.59;	author carlton;	state Exp;
branches;
next	1.62.2.9;

1.62.2.9
date	2004.01.26.19.11.34;	author carlton;	state Exp;
branches;
next	;

1.62.4.1
date	2003.12.14.20.27.34;	author drow;	state Exp;
branches;
next	1.62.4.2;

1.62.4.2
date	2004.01.13.16.12.03;	author drow;	state Exp;
branches;
next	;

1.61.2.1
date	2002.11.25.22.40.08;	author cgf;	state Exp;
branches;
next	;

1.58.6.1
date	2002.07.22.21.47.04;	author kseitz;	state Exp;
branches;
next	1.58.6.2;

1.58.6.2
date	2002.08.30.22.52.46;	author kseitz;	state Exp;
branches;
next	1.58.6.3;

1.58.6.3
date	2002.10.01.00.46.15;	author kseitz;	state Exp;
branches;
next	1.58.6.4;

1.58.6.4
date	2002.11.04.00.17.33;	author ezannoni;	state Exp;
branches;
next	;

1.56.2.1
date	2002.04.09.08.42.57;	author muller;	state Exp;
branches;
next	;

1.27.4.1
date	2001.10.11.02.13.08;	author cgf;	state Exp;
branches;
next	1.27.4.2;

1.27.4.2
date	2001.10.12.04.32.26;	author cgf;	state Exp;
branches;
next	1.27.4.3;

1.27.4.3
date	2001.10.13.01.21.05;	author cgf;	state Exp;
branches;
next	1.27.4.4;

1.27.4.4
date	2001.10.16.04.50.29;	author cgf;	state Exp;
branches;
next	1.27.4.5;

1.27.4.5
date	2001.10.20.05.13.17;	author cgf;	state Exp;
branches;
next	;

1.5.2.1
date	2000.04.21.04.33.50;	author cgf;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.07;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.25.51;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.07.20.11.14;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.08.16.19.54.17;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.08.31.01.06.22;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.10.05.23.09.03;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.10.12.04.37.25;	author jsm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	99.12.07.03.56.07;	author jsm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	99.12.22.21.45.11;	author jsm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2000.01.11.03.07.26;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.262
log
@	* aarch64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	Replace GET_LWP with ptid_get_lwp.
	* aix-thread.c (BUILD_THREAD, BUILD_LWP): Remove.
	Replace BUILD_THREAD with ptid_build.
	Replace BUILD_LWP with ptid_build.
	Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* alphabsd-nat.c: Replace PIDGET with ptid_get_pid.
	* amd64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* amd64bsd-nat.c: Replace PIDGET with ptid_get_pid.
	* arm-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	Replace GET_LWP with ptid_get_lwp.
	* armnbsd-nat.c: Replace PIDGET with ptid_get_pid.
	* auxv.c: Likewise.
	* breakpoint.c: Likewise.
	* common/ptid.c (ptid_is_pid): Condense check for
	null_ptid and minus_one_ptid.
	(ptid_lwp_p): New function.
	(ptid_tid_p): New function.
	* common/ptid.h: Update comments for accessors.
	(ptid_lwp_p): New prototype.
	(ptid_tid_p): New prototype.
	* defs.h (PIDGET, TIDGET, MERGEPID): Do not define.
	* gcore.c: Replace PIDGET with ptid_get_pid.
	* gdbthread.h: Likewise.
	* gnu-nat.c: Likewise.
	* hppa-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* hppabsd-nat.c: Replace PIDGET with ptid_get_pid.
	* hppanbsd-nat.c: Likewise.
	* i386-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* i386bsd-nat.c: Replace PIDGET with ptid_get_pid.
	* ia64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	* infcmd.c: Likewise.
	* inferior.h: Likewise.
	* inflow.c: Likewise.
	* infrun.c: Likewise.
	* linux-fork.c: Likewise.
	* linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace GET_PID with ptid_get_pid.
	Replace is_lwp with ptid_lwp_p.
	Replace GET_LWP with ptid_get_lwp.
	Replace BUILD_LWP with ptid_build.
@
text
@/* Target-vector operations for controlling windows child processes, for GDB.

   Copyright (C) 1995-2013 Free Software Foundation, Inc.

   Contributed by Cygnus Solutions, A Red Hat Company.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* Originally by Steve Chamberlain, sac@@cygnus.com */

#include "defs.h"
#include "frame.h"		/* required by inferior.h */
#include "inferior.h"
#include "target.h"
#include "exceptions.h"
#include "gdbcore.h"
#include "command.h"
#include "completer.h"
#include "regcache.h"
#include "top.h"
#include <signal.h>
#include <sys/types.h>
#include <fcntl.h>
#include <stdlib.h>
#include <windows.h>
#include <imagehlp.h>
#include <psapi.h>
#ifdef __CYGWIN__
#include <wchar.h>
#include <sys/cygwin.h>
#include <cygwin/version.h>
#endif
#include <signal.h>

#include "buildsym.h"
#include "filenames.h"
#include "symfile.h"
#include "objfiles.h"
#include "gdb_bfd.h"
#include "gdb_obstack.h"
#include "gdb_string.h"
#include "gdbthread.h"
#include "gdbcmd.h"
#include <unistd.h>
#include "exec.h"
#include "solist.h"
#include "solib.h"
#include "xml-support.h"

#include "i386-tdep.h"
#include "i387-tdep.h"

#include "windows-tdep.h"
#include "windows-nat.h"
#include "i386-nat.h"
#include "complaints.h"

#define AdjustTokenPrivileges		dyn_AdjustTokenPrivileges
#define DebugActiveProcessStop		dyn_DebugActiveProcessStop
#define DebugBreakProcess		dyn_DebugBreakProcess
#define DebugSetProcessKillOnExit	dyn_DebugSetProcessKillOnExit
#define EnumProcessModules		dyn_EnumProcessModules
#define GetModuleInformation		dyn_GetModuleInformation
#define LookupPrivilegeValueA		dyn_LookupPrivilegeValueA
#define OpenProcessToken		dyn_OpenProcessToken
#define GetConsoleFontSize		dyn_GetConsoleFontSize
#define GetCurrentConsoleFont		dyn_GetCurrentConsoleFont

static BOOL WINAPI (*AdjustTokenPrivileges)(HANDLE, BOOL, PTOKEN_PRIVILEGES,
					    DWORD, PTOKEN_PRIVILEGES, PDWORD);
static BOOL WINAPI (*DebugActiveProcessStop) (DWORD);
static BOOL WINAPI (*DebugBreakProcess) (HANDLE);
static BOOL WINAPI (*DebugSetProcessKillOnExit) (BOOL);
static BOOL WINAPI (*EnumProcessModules) (HANDLE, HMODULE *, DWORD,
					  LPDWORD);
static BOOL WINAPI (*GetModuleInformation) (HANDLE, HMODULE, LPMODULEINFO,
					    DWORD);
static BOOL WINAPI (*LookupPrivilegeValueA)(LPCSTR, LPCSTR, PLUID);
static BOOL WINAPI (*OpenProcessToken)(HANDLE, DWORD, PHANDLE);
static BOOL WINAPI (*GetCurrentConsoleFont) (HANDLE, BOOL,
					     CONSOLE_FONT_INFO *);
static COORD WINAPI (*GetConsoleFontSize) (HANDLE, DWORD);

static struct target_ops windows_ops;

#undef STARTUPINFO
#undef CreateProcess
#undef GetModuleFileNameEx

#ifndef __CYGWIN__
# define __PMAX	(MAX_PATH + 1)
  static DWORD WINAPI (*GetModuleFileNameEx) (HANDLE, HMODULE, LPSTR, DWORD);
# define STARTUPINFO STARTUPINFOA
# define CreateProcess CreateProcessA
# define GetModuleFileNameEx_name "GetModuleFileNameExA"
# define bad_GetModuleFileNameEx bad_GetModuleFileNameExA
#else
# define __PMAX	PATH_MAX
/* The starting and ending address of the cygwin1.dll text segment.  */
  static CORE_ADDR cygwin_load_start;
  static CORE_ADDR cygwin_load_end;
#   define __USEWIDE
    typedef wchar_t cygwin_buf_t;
    static DWORD WINAPI (*GetModuleFileNameEx) (HANDLE, HMODULE,
						LPWSTR, DWORD);
#   define STARTUPINFO STARTUPINFOW
#   define CreateProcess CreateProcessW
#   define GetModuleFileNameEx_name "GetModuleFileNameExW"
#   define bad_GetModuleFileNameEx bad_GetModuleFileNameExW
#endif

static int have_saved_context;	/* True if we've saved context from a
				   cygwin signal.  */
static CONTEXT saved_context;	/* Containes the saved context from a
				   cygwin signal.  */

/* If we're not using the old Cygwin header file set, define the
   following which never should have been in the generic Win32 API
   headers in the first place since they were our own invention...  */
#ifndef _GNU_H_WINDOWS_H
enum
  {
    FLAG_TRACE_BIT = 0x100,
    CONTEXT_DEBUGGER = (CONTEXT_FULL | CONTEXT_FLOATING_POINT)
  };
#endif

#ifndef CONTEXT_EXTENDED_REGISTERS
/* This macro is only defined on ia32.  It only makes sense on this target,
   so define it as zero if not already defined.  */
#define CONTEXT_EXTENDED_REGISTERS 0
#endif

#define CONTEXT_DEBUGGER_DR CONTEXT_DEBUGGER | CONTEXT_DEBUG_REGISTERS \
	| CONTEXT_EXTENDED_REGISTERS

static uintptr_t dr[8];
static int debug_registers_changed;
static int debug_registers_used;

static int windows_initialization_done;
#define DR6_CLEAR_VALUE 0xffff0ff0

/* The string sent by cygwin when it processes a signal.
   FIXME: This should be in a cygwin include file.  */
#ifndef _CYGWIN_SIGNAL_STRING
#define _CYGWIN_SIGNAL_STRING "cYgSiGw00f"
#endif

#define CHECK(x)	check (x, __FILE__,__LINE__)
#define DEBUG_EXEC(x)	if (debug_exec)		printf_unfiltered x
#define DEBUG_EVENTS(x)	if (debug_events)	printf_unfiltered x
#define DEBUG_MEM(x)	if (debug_memory)	printf_unfiltered x
#define DEBUG_EXCEPT(x)	if (debug_exceptions)	printf_unfiltered x

static void windows_stop (ptid_t);
static int windows_thread_alive (struct target_ops *, ptid_t);
static void windows_kill_inferior (struct target_ops *);

static void cygwin_set_dr (int i, CORE_ADDR addr);
static void cygwin_set_dr7 (unsigned long val);
static CORE_ADDR cygwin_get_dr (int i);
static unsigned long cygwin_get_dr6 (void);
static unsigned long cygwin_get_dr7 (void);

static enum gdb_signal last_sig = GDB_SIGNAL_0;
/* Set if a signal was received from the debugged process.  */

/* Thread information structure used to track information that is
   not available in gdb's thread structure.  */
typedef struct thread_info_struct
  {
    struct thread_info_struct *next;
    DWORD id;
    HANDLE h;
    CORE_ADDR thread_local_base;
    char *name;
    int suspended;
    int reload_context;
    CONTEXT context;
    STACKFRAME sf;
  }
thread_info;

static thread_info thread_head;

/* The process and thread handles for the above context.  */

static DEBUG_EVENT current_event;	/* The current debug event from
					   WaitForDebugEvent */
static HANDLE current_process_handle;	/* Currently executing process */
static thread_info *current_thread;	/* Info on currently selected thread */
static DWORD main_thread_id;		/* Thread ID of the main thread */

/* Counts of things.  */
static int exception_count = 0;
static int event_count = 0;
static int saw_create;
static int open_process_used = 0;

/* User options.  */
static int new_console = 0;
#ifdef __CYGWIN__
static int cygwin_exceptions = 0;
#endif
static int new_group = 1;
static int debug_exec = 0;		/* show execution */
static int debug_events = 0;		/* show events from kernel */
static int debug_memory = 0;		/* show target memory accesses */
static int debug_exceptions = 0;	/* show target exceptions */
static int useshell = 0;		/* use shell for subprocesses */

/* This vector maps GDB's idea of a register's number into an offset
   in the windows exception context vector.

   It also contains the bit mask needed to load the register in question.

   The contents of this table can only be computed by the units
   that provide CPU-specific support for Windows native debugging.
   These units should set the table by calling
   windows_set_context_register_offsets.

   One day we could read a reg, we could inspect the context we
   already have loaded, if it doesn't have the bit set that we need,
   we read that set of registers in using GetThreadContext.  If the
   context already contains what we need, we just unpack it.  Then to
   write a register, first we have to ensure that the context contains
   the other regs of the group, and then we copy the info in and set
   out bit.  */

static const int *mappings;

/* The function to use in order to determine whether a register is
   a segment register or not.  */
static segment_register_p_ftype *segment_register_p;

/* This vector maps the target's idea of an exception (extracted
   from the DEBUG_EVENT structure) to GDB's idea.  */

struct xlate_exception
  {
    int them;
    enum gdb_signal us;
  };

static const struct xlate_exception
  xlate[] =
{
  {EXCEPTION_ACCESS_VIOLATION, GDB_SIGNAL_SEGV},
  {STATUS_STACK_OVERFLOW, GDB_SIGNAL_SEGV},
  {EXCEPTION_BREAKPOINT, GDB_SIGNAL_TRAP},
  {DBG_CONTROL_C, GDB_SIGNAL_INT},
  {EXCEPTION_SINGLE_STEP, GDB_SIGNAL_TRAP},
  {STATUS_FLOAT_DIVIDE_BY_ZERO, GDB_SIGNAL_FPE},
  {-1, -1}};

/* Set the MAPPINGS static global to OFFSETS.
   See the description of MAPPINGS for more details.  */

void
windows_set_context_register_offsets (const int *offsets)
{
  mappings = offsets;
}

/* See windows-nat.h.  */

void
windows_set_segment_register_p (segment_register_p_ftype *fun)
{
  segment_register_p = fun;
}

static void
check (BOOL ok, const char *file, int line)
{
  if (!ok)
    printf_filtered ("error return %s:%d was %u\n", file, line,
		     (unsigned) GetLastError ());
}

/* Find a thread record given a thread id.  If GET_CONTEXT is not 0,
   then also retrieve the context for this thread.  If GET_CONTEXT is
   negative, then don't suspend the thread.  */
static thread_info *
thread_rec (DWORD id, int get_context)
{
  thread_info *th;

  for (th = &thread_head; (th = th->next) != NULL;)
    if (th->id == id)
      {
	if (!th->suspended && get_context)
	  {
	    if (get_context > 0 && id != current_event.dwThreadId)
	      {
		if (SuspendThread (th->h) == (DWORD) -1)
		  {
		    DWORD err = GetLastError ();

		    warning (_("SuspendThread (tid=0x%x) failed."
			       " (winerr %u)"),
			     (unsigned) id, (unsigned) err);
		    return NULL;
		  }
		th->suspended = 1;
	      }
	    else if (get_context < 0)
	      th->suspended = -1;
	    th->reload_context = 1;
	  }
	return th;
      }

  return NULL;
}

/* Add a thread to the thread list.  */
static thread_info *
windows_add_thread (ptid_t ptid, HANDLE h, void *tlb)
{
  thread_info *th;
  DWORD id;

  gdb_assert (ptid_get_tid (ptid) != 0);

  id = ptid_get_tid (ptid);

  if ((th = thread_rec (id, FALSE)))
    return th;

  th = XZALLOC (thread_info);
  th->id = id;
  th->h = h;
  th->thread_local_base = (CORE_ADDR) (uintptr_t) tlb;
  th->next = thread_head.next;
  thread_head.next = th;
  add_thread (ptid);
  /* Set the debug registers for the new thread if they are used.  */
  if (debug_registers_used)
    {
      /* Only change the value of the debug registers.  */
      th->context.ContextFlags = CONTEXT_DEBUG_REGISTERS;
      CHECK (GetThreadContext (th->h, &th->context));
      th->context.Dr0 = dr[0];
      th->context.Dr1 = dr[1];
      th->context.Dr2 = dr[2];
      th->context.Dr3 = dr[3];
      th->context.Dr6 = DR6_CLEAR_VALUE;
      th->context.Dr7 = dr[7];
      CHECK (SetThreadContext (th->h, &th->context));
      th->context.ContextFlags = 0;
    }
  return th;
}

/* Clear out any old thread list and reintialize it to a
   pristine state.  */
static void
windows_init_thread_list (void)
{
  thread_info *th = &thread_head;

  DEBUG_EVENTS (("gdb: windows_init_thread_list\n"));
  init_thread_list ();
  while (th->next != NULL)
    {
      thread_info *here = th->next;
      th->next = here->next;
      xfree (here);
    }
  thread_head.next = NULL;
}

/* Delete a thread from the list of threads.  */
static void
windows_delete_thread (ptid_t ptid, DWORD exit_code)
{
  thread_info *th;
  DWORD id;

  gdb_assert (ptid_get_tid (ptid) != 0);

  id = ptid_get_tid (ptid);

  if (info_verbose)
    printf_unfiltered ("[Deleting %s]\n", target_pid_to_str (ptid));
  else if (print_thread_events && id != main_thread_id)
    printf_unfiltered (_("[%s exited with code %u]\n"),
		       target_pid_to_str (ptid), (unsigned) exit_code);
  delete_thread (ptid);

  for (th = &thread_head;
       th->next != NULL && th->next->id != id;
       th = th->next)
    continue;

  if (th->next != NULL)
    {
      thread_info *here = th->next;
      th->next = here->next;
      xfree (here);
    }
}

static void
do_windows_fetch_inferior_registers (struct regcache *regcache, int r)
{
  char *context_offset = ((char *) &current_thread->context) + mappings[r];
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  long l;

  if (!current_thread)
    return;	/* Windows sometimes uses a non-existent thread id in its
		   events.  */

  if (current_thread->reload_context)
    {
#ifdef __COPY_CONTEXT_SIZE
      if (have_saved_context)
	{
	  /* Lie about where the program actually is stopped since
	     cygwin has informed us that we should consider the signal
	     to have occurred at another location which is stored in
	     "saved_context.  */
	  memcpy (&current_thread->context, &saved_context,
		  __COPY_CONTEXT_SIZE);
	  have_saved_context = 0;
	}
      else
#endif
	{
	  thread_info *th = current_thread;
	  th->context.ContextFlags = CONTEXT_DEBUGGER_DR;
	  GetThreadContext (th->h, &th->context);
	  /* Copy dr values from that thread.
	     But only if there were not modified since last stop.
	     PR gdb/2388 */
	  if (!debug_registers_changed)
	    {
	      dr[0] = th->context.Dr0;
	      dr[1] = th->context.Dr1;
	      dr[2] = th->context.Dr2;
	      dr[3] = th->context.Dr3;
	      dr[6] = th->context.Dr6;
	      dr[7] = th->context.Dr7;
	    }
	}
      current_thread->reload_context = 0;
    }

  if (r == I387_FISEG_REGNUM (tdep))
    {
      l = *((long *) context_offset) & 0xffff;
      regcache_raw_supply (regcache, r, (char *) &l);
    }
  else if (r == I387_FOP_REGNUM (tdep))
    {
      l = (*((long *) context_offset) >> 16) & ((1 << 11) - 1);
      regcache_raw_supply (regcache, r, (char *) &l);
    }
  else if (segment_register_p (r))
    {
      /* GDB treats segment registers as 32bit registers, but they are
	 in fact only 16 bits long.  Make sure we do not read extra
	 bits from our source buffer.  */
      l = *((long *) context_offset) & 0xffff;
      regcache_raw_supply (regcache, r, (char *) &l);
    }
  else if (r >= 0)
    regcache_raw_supply (regcache, r, context_offset);
  else
    {
      for (r = 0; r < gdbarch_num_regs (gdbarch); r++)
	do_windows_fetch_inferior_registers (regcache, r);
    }
}

static void
windows_fetch_inferior_registers (struct target_ops *ops,
				  struct regcache *regcache, int r)
{
  current_thread = thread_rec (ptid_get_tid (inferior_ptid), TRUE);
  /* Check if current_thread exists.  Windows sometimes uses a non-existent
     thread id in its events.  */
  if (current_thread)
    do_windows_fetch_inferior_registers (regcache, r);
}

static void
do_windows_store_inferior_registers (const struct regcache *regcache, int r)
{
  if (!current_thread)
    /* Windows sometimes uses a non-existent thread id in its events.  */;
  else if (r >= 0)
    regcache_raw_collect (regcache, r,
			  ((char *) &current_thread->context) + mappings[r]);
  else
    {
      for (r = 0; r < gdbarch_num_regs (get_regcache_arch (regcache)); r++)
	do_windows_store_inferior_registers (regcache, r);
    }
}

/* Store a new register value into the current thread context.  */
static void
windows_store_inferior_registers (struct target_ops *ops,
				  struct regcache *regcache, int r)
{
  current_thread = thread_rec (ptid_get_tid (inferior_ptid), TRUE);
  /* Check if current_thread exists.  Windows sometimes uses a non-existent
     thread id in its events.  */
  if (current_thread)
    do_windows_store_inferior_registers (regcache, r);
}

/* Get the name of a given module at given base address.  If base_address
   is zero return the first loaded module (which is always the name of the
   executable).  */
static int
get_module_name (LPVOID base_address, char *dll_name_ret)
{
  DWORD len;
  MODULEINFO mi;
  int i;
  HMODULE dh_buf[1];
  HMODULE *DllHandle = dh_buf;	/* Set to temporary storage for
				   initial query.  */
  DWORD cbNeeded;
#ifdef __CYGWIN__
  cygwin_buf_t pathbuf[__PMAX];	/* Temporary storage prior to converting to
				   posix form.  __PMAX is always enough
				   as long as SO_NAME_MAX_PATH_SIZE is defined
				   as 512.  */
#endif

  cbNeeded = 0;
  /* Find size of buffer needed to handle list of modules loaded in
     inferior.  */
  if (!EnumProcessModules (current_process_handle, DllHandle,
			   sizeof (HMODULE), &cbNeeded) || !cbNeeded)
    goto failed;

  /* Allocate correct amount of space for module list.  */
  DllHandle = (HMODULE *) alloca (cbNeeded);
  if (!DllHandle)
    goto failed;

  /* Get the list of modules.  */
  if (!EnumProcessModules (current_process_handle, DllHandle, cbNeeded,
				 &cbNeeded))
    goto failed;

  for (i = 0; i < (int) (cbNeeded / sizeof (HMODULE)); i++)
    {
      /* Get information on this module.  */
      if (!GetModuleInformation (current_process_handle, DllHandle[i],
				 &mi, sizeof (mi)))
	error (_("Can't get module info"));

      if (!base_address || mi.lpBaseOfDll == base_address)
	{
	  /* Try to find the name of the given module.  */
#ifdef __CYGWIN__
	  /* Cygwin prefers that the path be in /x/y/z format.  */
	  len = GetModuleFileNameEx (current_process_handle,
				      DllHandle[i], pathbuf, __PMAX);
	  if (len == 0)
	    error (_("Error getting dll name: %u."),
		   (unsigned) GetLastError ());
	  if (cygwin_conv_path (CCP_WIN_W_TO_POSIX, pathbuf, dll_name_ret,
				__PMAX) < 0)
	    error (_("Error converting dll name to POSIX: %d."), errno);
#else
	  len = GetModuleFileNameEx (current_process_handle,
				      DllHandle[i], dll_name_ret, __PMAX);
	  if (len == 0)
	    error (_("Error getting dll name: %u."),
		   (unsigned) GetLastError ());
#endif
	  return 1;	/* success */
	}
    }

failed:
  dll_name_ret[0] = '\0';
  return 0;		/* failure */
}

/* Encapsulate the information required in a call to
   symbol_file_add_args.  */
struct safe_symbol_file_add_args
{
  char *name;
  int from_tty;
  struct section_addr_info *addrs;
  int mainline;
  int flags;
  struct ui_file *err, *out;
  struct objfile *ret;
};

/* Maintain a linked list of "so" information.  */
struct lm_info
{
  LPVOID load_addr;
};

static struct so_list solib_start, *solib_end;

/* Call symbol_file_add with stderr redirected.  We don't care if there
   are errors.  */
static int
safe_symbol_file_add_stub (void *argv)
{
#define p ((struct safe_symbol_file_add_args *) argv)
  const int add_flags = ((p->from_tty ? SYMFILE_VERBOSE : 0)
                         | (p->mainline ? SYMFILE_MAINLINE : 0));
  p->ret = symbol_file_add (p->name, add_flags, p->addrs, p->flags);
  return !!p->ret;
#undef p
}

/* Restore gdb's stderr after calling symbol_file_add.  */
static void
safe_symbol_file_add_cleanup (void *p)
{
#define sp ((struct safe_symbol_file_add_args *)p)
  gdb_flush (gdb_stderr);
  gdb_flush (gdb_stdout);
  ui_file_delete (gdb_stderr);
  ui_file_delete (gdb_stdout);
  gdb_stderr = sp->err;
  gdb_stdout = sp->out;
#undef sp
}

/* symbol_file_add wrapper that prevents errors from being displayed.  */
static struct objfile *
safe_symbol_file_add (char *name, int from_tty,
		      struct section_addr_info *addrs,
		      int mainline, int flags)
{
  struct safe_symbol_file_add_args p;
  struct cleanup *cleanup;

  cleanup = make_cleanup (safe_symbol_file_add_cleanup, &p);

  p.err = gdb_stderr;
  p.out = gdb_stdout;
  gdb_flush (gdb_stderr);
  gdb_flush (gdb_stdout);
  gdb_stderr = ui_file_new ();
  gdb_stdout = ui_file_new ();
  p.name = name;
  p.from_tty = from_tty;
  p.addrs = addrs;
  p.mainline = mainline;
  p.flags = flags;
  catch_errors (safe_symbol_file_add_stub, &p, "", RETURN_MASK_ERROR);

  do_cleanups (cleanup);
  return p.ret;
}

static struct so_list *
windows_make_so (const char *name, LPVOID load_addr)
{
  struct so_list *so;
  char *p;
#ifndef __CYGWIN__
  char buf[__PMAX];
  char cwd[__PMAX];
  WIN32_FIND_DATA w32_fd;
  HANDLE h = FindFirstFile(name, &w32_fd);

  if (h == INVALID_HANDLE_VALUE)
    strcpy (buf, name);
  else
    {
      FindClose (h);
      strcpy (buf, name);
      if (GetCurrentDirectory (MAX_PATH + 1, cwd))
	{
	  p = strrchr (buf, '\\');
	  if (p)
	    p[1] = '\0';
	  SetCurrentDirectory (buf);
	  GetFullPathName (w32_fd.cFileName, MAX_PATH, buf, &p);
	  SetCurrentDirectory (cwd);
	}
    }
  if (strcasecmp (buf, "ntdll.dll") == 0)
    {
      GetSystemDirectory (buf, sizeof (buf));
      strcat (buf, "\\ntdll.dll");
    }
#else
  cygwin_buf_t buf[__PMAX];

  buf[0] = 0;
  if (access (name, F_OK) != 0)
    {
      if (strcasecmp (name, "ntdll.dll") == 0)
#ifdef __USEWIDE
	{
	  GetSystemDirectoryW (buf, sizeof (buf) / sizeof (wchar_t));
	  wcscat (buf, L"\\ntdll.dll");
	}
#else
	{
	  GetSystemDirectoryA (buf, sizeof (buf) / sizeof (wchar_t));
	  strcat (buf, "\\ntdll.dll");
	}
#endif
    }
#endif
  so = XZALLOC (struct so_list);
  so->lm_info = (struct lm_info *) xmalloc (sizeof (struct lm_info));
  so->lm_info->load_addr = load_addr;
  strcpy (so->so_original_name, name);
#ifndef __CYGWIN__
  strcpy (so->so_name, buf);
#else
  if (buf[0])
    cygwin_conv_path (CCP_WIN_W_TO_POSIX, buf, so->so_name,
		      SO_NAME_MAX_PATH_SIZE);
  else
    {
      char *rname = realpath (name, NULL);
      if (rname && strlen (rname) < SO_NAME_MAX_PATH_SIZE)
	{
	  strcpy (so->so_name, rname);
	  free (rname);
	}
      else
	error (_("dll path too long"));
    }
  /* Record cygwin1.dll .text start/end.  */
  p = strchr (so->so_name, '\0') - (sizeof ("/cygwin1.dll") - 1);
  if (p >= so->so_name && strcasecmp (p, "/cygwin1.dll") == 0)
    {
      bfd *abfd;
      asection *text = NULL;
      CORE_ADDR text_vma;

      abfd = gdb_bfd_open (so->so_name, "pei-i386", -1);

      if (!abfd)
	return so;

      if (bfd_check_format (abfd, bfd_object))
	text = bfd_get_section_by_name (abfd, ".text");

      if (!text)
	{
	  gdb_bfd_unref (abfd);
	  return so;
	}

      /* The symbols in a dll are offset by 0x1000, which is the
	 offset from 0 of the first byte in an image - because of the
	 file header and the section alignment.  */
      cygwin_load_start = (CORE_ADDR) (uintptr_t) ((char *)
						   load_addr + 0x1000);
      cygwin_load_end = cygwin_load_start + bfd_section_size (abfd, text);

      gdb_bfd_unref (abfd);
    }
#endif

  return so;
}

static char *
get_image_name (HANDLE h, void *address, int unicode)
{
#ifdef __CYGWIN__
  static char buf[__PMAX];
#else
  static char buf[(2 * __PMAX) + 1];
#endif
  DWORD size = unicode ? sizeof (WCHAR) : sizeof (char);
  char *address_ptr;
  int len = 0;
  char b[2];
  SIZE_T done;

  /* Attempt to read the name of the dll that was detected.
     This is documented to work only when actively debugging
     a program.  It will not work for attached processes.  */
  if (address == NULL)
    return NULL;

  /* See if we could read the address of a string, and that the
     address isn't null.  */
  if (!ReadProcessMemory (h, address,  &address_ptr,
			  sizeof (address_ptr), &done)
      || done != sizeof (address_ptr) || !address_ptr)
    return NULL;

  /* Find the length of the string.  */
  while (ReadProcessMemory (h, address_ptr + len++ * size, &b, size, &done)
	 && (b[0] != 0 || b[size - 1] != 0) && done == size)
    continue;

  if (!unicode)
    ReadProcessMemory (h, address_ptr, buf, len, &done);
  else
    {
      WCHAR *unicode_address = (WCHAR *) alloca (len * sizeof (WCHAR));
      ReadProcessMemory (h, address_ptr, unicode_address, len * sizeof (WCHAR),
			 &done);
#ifdef __CYGWIN__
      wcstombs (buf, unicode_address, __PMAX);
#else
      WideCharToMultiByte (CP_ACP, 0, unicode_address, len, buf, sizeof buf,
			   0, 0);
#endif
    }

  return buf;
}

/* Wait for child to do something.  Return pid of child, or -1 in case
   of error; store status through argument pointer OURSTATUS.  */
static int
handle_load_dll (void *dummy)
{
  LOAD_DLL_DEBUG_INFO *event = &current_event.u.LoadDll;
  char dll_buf[__PMAX];
  char *dll_name = NULL;

  dll_buf[0] = dll_buf[sizeof (dll_buf) - 1] = '\0';

  if (!get_module_name (event->lpBaseOfDll, dll_buf))
    dll_buf[0] = dll_buf[sizeof (dll_buf) - 1] = '\0';

  dll_name = dll_buf;

  if (*dll_name == '\0')
    dll_name = get_image_name (current_process_handle,
			       event->lpImageName, event->fUnicode);
  if (!dll_name)
    return 1;

  solib_end->next = windows_make_so (dll_name, event->lpBaseOfDll);
  solib_end = solib_end->next;

  DEBUG_EVENTS (("gdb: Loading dll \"%s\" at %s.\n", solib_end->so_name,
		 host_address_to_string (solib_end->lm_info->load_addr)));

  return 1;
}

static void
windows_free_so (struct so_list *so)
{
  if (so->lm_info)
    xfree (so->lm_info);
  xfree (so);
}

static int
handle_unload_dll (void *dummy)
{
  LPVOID lpBaseOfDll = current_event.u.UnloadDll.lpBaseOfDll;
  struct so_list *so;

  for (so = &solib_start; so->next != NULL; so = so->next)
    if (so->next->lm_info->load_addr == lpBaseOfDll)
      {
	struct so_list *sodel = so->next;

	so->next = sodel->next;
	if (!so->next)
	  solib_end = so;
	DEBUG_EVENTS (("gdb: Unloading dll \"%s\".\n", sodel->so_name));

	windows_free_so (sodel);
	return 1;
      }

  /* We did not find any DLL that was previously loaded at this address,
     so register a complaint.  We do not report an error, because we have
     observed that this may be happening under some circumstances.  For
     instance, running 32bit applications on x64 Windows causes us to receive
     4 mysterious UNLOAD_DLL_DEBUG_EVENTs during the startup phase (these
     events are apparently caused by the WOW layer, the interface between
     32bit and 64bit worlds).  */
  complaint (&symfile_complaints, _("dll starting at %s not found."),
	     host_address_to_string (lpBaseOfDll));

  return 0;
}

/* Clear list of loaded DLLs.  */
static void
windows_clear_solib (void)
{
  solib_start.next = NULL;
  solib_end = &solib_start;
}

/* Load DLL symbol info.  */
static void
dll_symbol_command (char *args, int from_tty)
{
  int n;
  dont_repeat ();

  if (args == NULL)
    error (_("dll-symbols requires a file name"));

  n = strlen (args);
  if (n > 4 && strcasecmp (args + n - 4, ".dll") != 0)
    {
      char *newargs = (char *) alloca (n + 4 + 1);
      strcpy (newargs, args);
      strcat (newargs, ".dll");
      args = newargs;
    }

  safe_symbol_file_add (args, from_tty, NULL, 0, OBJF_SHARED | OBJF_USERLOADED);
}

/* Handle DEBUG_STRING output from child process.
   Cygwin prepends its messages with a "cygwin:".  Interpret this as
   a Cygwin signal.  Otherwise just print the string as a warning.  */
static int
handle_output_debug_string (struct target_waitstatus *ourstatus)
{
  char *s = NULL;
  int retval = 0;

  if (!target_read_string
	((CORE_ADDR) (uintptr_t) current_event.u.DebugString.lpDebugStringData,
	&s, 1024, 0)
      || !s || !*s)
    /* nothing to do */;
  else if (strncmp (s, _CYGWIN_SIGNAL_STRING,
		    sizeof (_CYGWIN_SIGNAL_STRING) - 1) != 0)
    {
#ifdef __CYGWIN__
      if (strncmp (s, "cYg", 3) != 0)
#endif
	warning (("%s"), s);
    }
#ifdef __COPY_CONTEXT_SIZE
  else
    {
      /* Got a cygwin signal marker.  A cygwin signal is followed by
	 the signal number itself and then optionally followed by the
	 thread id and address to saved context within the DLL.  If
	 these are supplied, then the given thread is assumed to have
	 issued the signal and the context from the thread is assumed
	 to be stored at the given address in the inferior.  Tell gdb
	 to treat this like a real signal.  */
      char *p;
      int sig = strtol (s + sizeof (_CYGWIN_SIGNAL_STRING) - 1, &p, 0);
      int gotasig = gdb_signal_from_host (sig);

      ourstatus->value.sig = gotasig;
      if (gotasig)
	{
	  LPCVOID x;
	  SIZE_T n;

	  ourstatus->kind = TARGET_WAITKIND_STOPPED;
	  retval = strtoul (p, &p, 0);
	  if (!retval)
	    retval = main_thread_id;
	  else if ((x = (LPCVOID) (uintptr_t) strtoull (p, NULL, 0))
		   && ReadProcessMemory (current_process_handle, x,
					 &saved_context,
					 __COPY_CONTEXT_SIZE, &n)
		   && n == __COPY_CONTEXT_SIZE)
	    have_saved_context = 1;
	  current_event.dwThreadId = retval;
	}
    }
#endif

  if (s)
    xfree (s);
  return retval;
}

static int
display_selector (HANDLE thread, DWORD sel)
{
  LDT_ENTRY info;
  if (GetThreadSelectorEntry (thread, sel, &info))
    {
      int base, limit;
      printf_filtered ("0x%03x: ", (unsigned) sel);
      if (!info.HighWord.Bits.Pres)
	{
	  puts_filtered ("Segment not present\n");
	  return 0;
	}
      base = (info.HighWord.Bits.BaseHi << 24) +
	     (info.HighWord.Bits.BaseMid << 16)
	     + info.BaseLow;
      limit = (info.HighWord.Bits.LimitHi << 16) + info.LimitLow;
      if (info.HighWord.Bits.Granularity)
	limit = (limit << 12) | 0xfff;
      printf_filtered ("base=0x%08x limit=0x%08x", base, limit);
      if (info.HighWord.Bits.Default_Big)
	puts_filtered(" 32-bit ");
      else
	puts_filtered(" 16-bit ");
      switch ((info.HighWord.Bits.Type & 0xf) >> 1)
	{
	case 0:
	  puts_filtered ("Data (Read-Only, Exp-up");
	  break;
	case 1:
	  puts_filtered ("Data (Read/Write, Exp-up");
	  break;
	case 2:
	  puts_filtered ("Unused segment (");
	  break;
	case 3:
	  puts_filtered ("Data (Read/Write, Exp-down");
	  break;
	case 4:
	  puts_filtered ("Code (Exec-Only, N.Conf");
	  break;
	case 5:
	  puts_filtered ("Code (Exec/Read, N.Conf");
	  break;
	case 6:
	  puts_filtered ("Code (Exec-Only, Conf");
	  break;
	case 7:
	  puts_filtered ("Code (Exec/Read, Conf");
	  break;
	default:
	  printf_filtered ("Unknown type 0x%x",info.HighWord.Bits.Type);
	}
      if ((info.HighWord.Bits.Type & 0x1) == 0)
	puts_filtered(", N.Acc");
      puts_filtered (")\n");
      if ((info.HighWord.Bits.Type & 0x10) == 0)
	puts_filtered("System selector ");
      printf_filtered ("Priviledge level = %d. ", info.HighWord.Bits.Dpl);
      if (info.HighWord.Bits.Granularity)
	puts_filtered ("Page granular.\n");
      else
	puts_filtered ("Byte granular.\n");
      return 1;
    }
  else
    {
      DWORD err = GetLastError ();
      if (err == ERROR_NOT_SUPPORTED)
	printf_filtered ("Function not supported\n");
      else
	printf_filtered ("Invalid selector 0x%x.\n", (unsigned) sel);
      return 0;
    }
}

static void
display_selectors (char * args, int from_tty)
{
  if (!current_thread)
    {
      puts_filtered ("Impossible to display selectors now.\n");
      return;
    }
  if (!args)
    {

      puts_filtered ("Selector $cs\n");
      display_selector (current_thread->h,
	current_thread->context.SegCs);
      puts_filtered ("Selector $ds\n");
      display_selector (current_thread->h,
	current_thread->context.SegDs);
      puts_filtered ("Selector $es\n");
      display_selector (current_thread->h,
	current_thread->context.SegEs);
      puts_filtered ("Selector $ss\n");
      display_selector (current_thread->h,
	current_thread->context.SegSs);
      puts_filtered ("Selector $fs\n");
      display_selector (current_thread->h,
	current_thread->context.SegFs);
      puts_filtered ("Selector $gs\n");
      display_selector (current_thread->h,
	current_thread->context.SegGs);
    }
  else
    {
      int sel;
      sel = parse_and_eval_long (args);
      printf_filtered ("Selector \"%s\"\n",args);
      display_selector (current_thread->h, sel);
    }
}

#define DEBUG_EXCEPTION_SIMPLE(x)       if (debug_exceptions) \
  printf_unfiltered ("gdb: Target exception %s at %s\n", x, \
    host_address_to_string (\
      current_event.u.Exception.ExceptionRecord.ExceptionAddress))

static int
handle_exception (struct target_waitstatus *ourstatus)
{
  thread_info *th;
  DWORD code = current_event.u.Exception.ExceptionRecord.ExceptionCode;

  ourstatus->kind = TARGET_WAITKIND_STOPPED;

  /* Record the context of the current thread.  */
  th = thread_rec (current_event.dwThreadId, -1);

  switch (code)
    {
    case EXCEPTION_ACCESS_VIOLATION:
      DEBUG_EXCEPTION_SIMPLE ("EXCEPTION_ACCESS_VIOLATION");
      ourstatus->value.sig = GDB_SIGNAL_SEGV;
#ifdef __CYGWIN__
      {
	/* See if the access violation happened within the cygwin DLL
	   itself.  Cygwin uses a kind of exception handling to deal
	   with passed-in invalid addresses.  gdb should not treat
	   these as real SEGVs since they will be silently handled by
	   cygwin.  A real SEGV will (theoretically) be caught by
	   cygwin later in the process and will be sent as a
	   cygwin-specific-signal.  So, ignore SEGVs if they show up
	   within the text segment of the DLL itself.  */
	const char *fn;
	CORE_ADDR addr = (CORE_ADDR) (uintptr_t)
	  current_event.u.Exception.ExceptionRecord.ExceptionAddress;

	if ((!cygwin_exceptions && (addr >= cygwin_load_start
				    && addr < cygwin_load_end))
	    || (find_pc_partial_function (addr, &fn, NULL, NULL)
		&& strncmp (fn, "KERNEL32!IsBad",
			    strlen ("KERNEL32!IsBad")) == 0))
	  return 0;
      }
#endif
      break;
    case STATUS_STACK_OVERFLOW:
      DEBUG_EXCEPTION_SIMPLE ("STATUS_STACK_OVERFLOW");
      ourstatus->value.sig = GDB_SIGNAL_SEGV;
      break;
    case STATUS_FLOAT_DENORMAL_OPERAND:
      DEBUG_EXCEPTION_SIMPLE ("STATUS_FLOAT_DENORMAL_OPERAND");
      ourstatus->value.sig = GDB_SIGNAL_FPE;
      break;
    case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
      DEBUG_EXCEPTION_SIMPLE ("EXCEPTION_ARRAY_BOUNDS_EXCEEDED");
      ourstatus->value.sig = GDB_SIGNAL_FPE;
      break;
    case STATUS_FLOAT_INEXACT_RESULT:
      DEBUG_EXCEPTION_SIMPLE ("STATUS_FLOAT_INEXACT_RESULT");
      ourstatus->value.sig = GDB_SIGNAL_FPE;
      break;
    case STATUS_FLOAT_INVALID_OPERATION:
      DEBUG_EXCEPTION_SIMPLE ("STATUS_FLOAT_INVALID_OPERATION");
      ourstatus->value.sig = GDB_SIGNAL_FPE;
      break;
    case STATUS_FLOAT_OVERFLOW:
      DEBUG_EXCEPTION_SIMPLE ("STATUS_FLOAT_OVERFLOW");
      ourstatus->value.sig = GDB_SIGNAL_FPE;
      break;
    case STATUS_FLOAT_STACK_CHECK:
      DEBUG_EXCEPTION_SIMPLE ("STATUS_FLOAT_STACK_CHECK");
      ourstatus->value.sig = GDB_SIGNAL_FPE;
      break;
    case STATUS_FLOAT_UNDERFLOW:
      DEBUG_EXCEPTION_SIMPLE ("STATUS_FLOAT_UNDERFLOW");
      ourstatus->value.sig = GDB_SIGNAL_FPE;
      break;
    case STATUS_FLOAT_DIVIDE_BY_ZERO:
      DEBUG_EXCEPTION_SIMPLE ("STATUS_FLOAT_DIVIDE_BY_ZERO");
      ourstatus->value.sig = GDB_SIGNAL_FPE;
      break;
    case STATUS_INTEGER_DIVIDE_BY_ZERO:
      DEBUG_EXCEPTION_SIMPLE ("STATUS_INTEGER_DIVIDE_BY_ZERO");
      ourstatus->value.sig = GDB_SIGNAL_FPE;
      break;
    case STATUS_INTEGER_OVERFLOW:
      DEBUG_EXCEPTION_SIMPLE ("STATUS_INTEGER_OVERFLOW");
      ourstatus->value.sig = GDB_SIGNAL_FPE;
      break;
    case EXCEPTION_BREAKPOINT:
      DEBUG_EXCEPTION_SIMPLE ("EXCEPTION_BREAKPOINT");
      ourstatus->value.sig = GDB_SIGNAL_TRAP;
      break;
    case DBG_CONTROL_C:
      DEBUG_EXCEPTION_SIMPLE ("DBG_CONTROL_C");
      ourstatus->value.sig = GDB_SIGNAL_INT;
      break;
    case DBG_CONTROL_BREAK:
      DEBUG_EXCEPTION_SIMPLE ("DBG_CONTROL_BREAK");
      ourstatus->value.sig = GDB_SIGNAL_INT;
      break;
    case EXCEPTION_SINGLE_STEP:
      DEBUG_EXCEPTION_SIMPLE ("EXCEPTION_SINGLE_STEP");
      ourstatus->value.sig = GDB_SIGNAL_TRAP;
      break;
    case EXCEPTION_ILLEGAL_INSTRUCTION:
      DEBUG_EXCEPTION_SIMPLE ("EXCEPTION_ILLEGAL_INSTRUCTION");
      ourstatus->value.sig = GDB_SIGNAL_ILL;
      break;
    case EXCEPTION_PRIV_INSTRUCTION:
      DEBUG_EXCEPTION_SIMPLE ("EXCEPTION_PRIV_INSTRUCTION");
      ourstatus->value.sig = GDB_SIGNAL_ILL;
      break;
    case EXCEPTION_NONCONTINUABLE_EXCEPTION:
      DEBUG_EXCEPTION_SIMPLE ("EXCEPTION_NONCONTINUABLE_EXCEPTION");
      ourstatus->value.sig = GDB_SIGNAL_ILL;
      break;
    default:
      /* Treat unhandled first chance exceptions specially.  */
      if (current_event.u.Exception.dwFirstChance)
	return -1;
      printf_unfiltered ("gdb: unknown target exception 0x%08x at %s\n",
	(unsigned) current_event.u.Exception.ExceptionRecord.ExceptionCode,
	host_address_to_string (
	  current_event.u.Exception.ExceptionRecord.ExceptionAddress));
      ourstatus->value.sig = GDB_SIGNAL_UNKNOWN;
      break;
    }
  exception_count++;
  last_sig = ourstatus->value.sig;
  return 1;
}

/* Resume all artificially suspended threads if we are continuing
   execution.  */
static BOOL
windows_continue (DWORD continue_status, int id)
{
  int i;
  thread_info *th;
  BOOL res;

  DEBUG_EVENTS (("ContinueDebugEvent (cpid=%d, ctid=0x%x, %s);\n",
		  (unsigned) current_event.dwProcessId,
		  (unsigned) current_event.dwThreadId,
		  continue_status == DBG_CONTINUE ?
		  "DBG_CONTINUE" : "DBG_EXCEPTION_NOT_HANDLED"));

  for (th = &thread_head; (th = th->next) != NULL;)
    if ((id == -1 || id == (int) th->id)
	&& th->suspended)
      {
	if (debug_registers_changed)
	  {
	    th->context.ContextFlags |= CONTEXT_DEBUG_REGISTERS;
	    th->context.Dr0 = dr[0];
	    th->context.Dr1 = dr[1];
	    th->context.Dr2 = dr[2];
	    th->context.Dr3 = dr[3];
	    th->context.Dr6 = DR6_CLEAR_VALUE;
	    th->context.Dr7 = dr[7];
	  }
	if (th->context.ContextFlags)
	  {
	    CHECK (SetThreadContext (th->h, &th->context));
	    th->context.ContextFlags = 0;
	  }
	if (th->suspended > 0)
	  (void) ResumeThread (th->h);
	th->suspended = 0;
      }

  res = ContinueDebugEvent (current_event.dwProcessId,
			    current_event.dwThreadId,
			    continue_status);

  debug_registers_changed = 0;
  return res;
}

/* Called in pathological case where Windows fails to send a
   CREATE_PROCESS_DEBUG_EVENT after an attach.  */
static DWORD
fake_create_process (void)
{
  current_process_handle = OpenProcess (PROCESS_ALL_ACCESS, FALSE,
					current_event.dwProcessId);
  if (current_process_handle != NULL)
    open_process_used = 1;
  else
    {
      error (_("OpenProcess call failed, GetLastError = %u"),
       (unsigned) GetLastError ());
      /*  We can not debug anything in that case.  */
    }
  main_thread_id = current_event.dwThreadId;
  current_thread = windows_add_thread (
		     ptid_build (current_event.dwProcessId, 0,
				 current_event.dwThreadId),
		     current_event.u.CreateThread.hThread,
		     current_event.u.CreateThread.lpThreadLocalBase);
  return main_thread_id;
}

static void
windows_resume (struct target_ops *ops,
		ptid_t ptid, int step, enum gdb_signal sig)
{
  thread_info *th;
  DWORD continue_status = DBG_CONTINUE;

  /* A specific PTID means `step only this thread id'.  */
  int resume_all = ptid_equal (ptid, minus_one_ptid);

  /* If we're continuing all threads, it's the current inferior that
     should be handled specially.  */
  if (resume_all)
    ptid = inferior_ptid;

  if (sig != GDB_SIGNAL_0)
    {
      if (current_event.dwDebugEventCode != EXCEPTION_DEBUG_EVENT)
	{
	  DEBUG_EXCEPT(("Cannot continue with signal %d here.\n",sig));
	}
      else if (sig == last_sig)
	continue_status = DBG_EXCEPTION_NOT_HANDLED;
      else
#if 0
/* This code does not seem to work, because
  the kernel does probably not consider changes in the ExceptionRecord
  structure when passing the exception to the inferior.
  Note that this seems possible in the exception handler itself.  */
	{
	  int i;
	  for (i = 0; xlate[i].them != -1; i++)
	    if (xlate[i].us == sig)
	      {
		current_event.u.Exception.ExceptionRecord.ExceptionCode
		  = xlate[i].them;
		continue_status = DBG_EXCEPTION_NOT_HANDLED;
		break;
	      }
	  if (continue_status == DBG_CONTINUE)
	    {
	      DEBUG_EXCEPT(("Cannot continue with signal %d.\n",sig));
	    }
	}
#endif
	DEBUG_EXCEPT(("Can only continue with recieved signal %d.\n",
	  last_sig));
    }

  last_sig = GDB_SIGNAL_0;

  DEBUG_EXEC (("gdb: windows_resume (pid=%d, tid=%ld, step=%d, sig=%d);\n",
	       ptid_get_pid (ptid), ptid_get_tid (ptid), step, sig));

  /* Get context for currently selected thread.  */
  th = thread_rec (ptid_get_tid (inferior_ptid), FALSE);
  if (th)
    {
      if (step)
	{
	  /* Single step by setting t bit.  */
	  struct regcache *regcache = get_current_regcache ();
	  struct gdbarch *gdbarch = get_regcache_arch (regcache);
	  windows_fetch_inferior_registers (ops, regcache,
					    gdbarch_ps_regnum (gdbarch));
	  th->context.EFlags |= FLAG_TRACE_BIT;
	}

      if (th->context.ContextFlags)
	{
	  if (debug_registers_changed)
	    {
	      th->context.Dr0 = dr[0];
	      th->context.Dr1 = dr[1];
	      th->context.Dr2 = dr[2];
	      th->context.Dr3 = dr[3];
	      th->context.Dr6 = DR6_CLEAR_VALUE;
	      th->context.Dr7 = dr[7];
	    }
	  CHECK (SetThreadContext (th->h, &th->context));
	  th->context.ContextFlags = 0;
	}
    }

  /* Allow continuing with the same signal that interrupted us.
     Otherwise complain.  */

  if (resume_all)
    windows_continue (continue_status, -1);
  else
    windows_continue (continue_status, ptid_get_tid (ptid));
}

/* Ctrl-C handler used when the inferior is not run in the same console.  The
   handler is in charge of interrupting the inferior using DebugBreakProcess.
   Note that this function is not available prior to Windows XP.  In this case
   we emit a warning.  */
static BOOL WINAPI
ctrl_c_handler (DWORD event_type)
{
  const int attach_flag = current_inferior ()->attach_flag;

  /* Only handle Ctrl-C and Ctrl-Break events.  Ignore others.  */
  if (event_type != CTRL_C_EVENT && event_type != CTRL_BREAK_EVENT)
    return FALSE;

  /* If the inferior and the debugger share the same console, do nothing as
     the inferior has also received the Ctrl-C event.  */
  if (!new_console && !attach_flag)
    return TRUE;

  if (!DebugBreakProcess (current_process_handle))
    warning (_("Could not interrupt program.  "
	       "Press Ctrl-c in the program console."));

  /* Return true to tell that Ctrl-C has been handled.  */
  return TRUE;
}

/* Get the next event from the child.  Return 1 if the event requires
   handling by WFI (or whatever).  */
static int
get_windows_debug_event (struct target_ops *ops,
			 int pid, struct target_waitstatus *ourstatus)
{
  BOOL debug_event;
  DWORD continue_status, event_code;
  thread_info *th;
  static thread_info dummy_thread_info;
  int retval = 0;

  last_sig = GDB_SIGNAL_0;

  if (!(debug_event = WaitForDebugEvent (&current_event, 1000)))
    goto out;

  event_count++;
  continue_status = DBG_CONTINUE;

  event_code = current_event.dwDebugEventCode;
  ourstatus->kind = TARGET_WAITKIND_SPURIOUS;
  th = NULL;
  have_saved_context = 0;

  switch (event_code)
    {
    case CREATE_THREAD_DEBUG_EVENT:
      DEBUG_EVENTS (("gdb: kernel event for pid=%u tid=0x%x code=%s)\n",
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "CREATE_THREAD_DEBUG_EVENT"));
      if (saw_create != 1)
	{
	  struct inferior *inf;
	  inf = find_inferior_pid (current_event.dwProcessId);
	  if (!saw_create && inf->attach_flag)
	    {
	      /* Kludge around a Windows bug where first event is a create
		 thread event.  Caused when attached process does not have
		 a main thread.  */
	      retval = fake_create_process ();
	      if (retval)
		saw_create++;
	    }
	  break;
	}
      /* Record the existence of this thread.  */
      retval = current_event.dwThreadId;
      th = windows_add_thread (ptid_build (current_event.dwProcessId, 0,
					 current_event.dwThreadId),
			     current_event.u.CreateThread.hThread,
			     current_event.u.CreateThread.lpThreadLocalBase);

      break;

    case EXIT_THREAD_DEBUG_EVENT:
      DEBUG_EVENTS (("gdb: kernel event for pid=%u tid=0x%x code=%s)\n",
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "EXIT_THREAD_DEBUG_EVENT"));

      if (current_event.dwThreadId != main_thread_id)
	{
	  windows_delete_thread (ptid_build (current_event.dwProcessId, 0,
					     current_event.dwThreadId),
				 current_event.u.ExitThread.dwExitCode);
	  th = &dummy_thread_info;
	}
      break;

    case CREATE_PROCESS_DEBUG_EVENT:
      DEBUG_EVENTS (("gdb: kernel event for pid=%u tid=0x%x code=%s)\n",
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "CREATE_PROCESS_DEBUG_EVENT"));
      CloseHandle (current_event.u.CreateProcessInfo.hFile);
      if (++saw_create != 1)
	break;

      current_process_handle = current_event.u.CreateProcessInfo.hProcess;
      if (main_thread_id)
	windows_delete_thread (ptid_build (current_event.dwProcessId, 0,
					   main_thread_id),
			       0);
      main_thread_id = current_event.dwThreadId;
      /* Add the main thread.  */
      th = windows_add_thread (ptid_build (current_event.dwProcessId, 0,
					   current_event.dwThreadId),
	     current_event.u.CreateProcessInfo.hThread,
	     current_event.u.CreateProcessInfo.lpThreadLocalBase);
      retval = current_event.dwThreadId;
      break;

    case EXIT_PROCESS_DEBUG_EVENT:
      DEBUG_EVENTS (("gdb: kernel event for pid=%u tid=0x%x code=%s)\n",
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "EXIT_PROCESS_DEBUG_EVENT"));
      if (!windows_initialization_done)
	{
	  target_terminal_ours ();
	  target_mourn_inferior ();
	  error (_("During startup program exited with code 0x%x."),
		 (unsigned int) current_event.u.ExitProcess.dwExitCode);
	}
      else if (saw_create == 1)
	{
	  ourstatus->kind = TARGET_WAITKIND_EXITED;
	  ourstatus->value.integer = current_event.u.ExitProcess.dwExitCode;
	  retval = main_thread_id;
	}
      break;

    case LOAD_DLL_DEBUG_EVENT:
      DEBUG_EVENTS (("gdb: kernel event for pid=%u tid=0x%x code=%s)\n",
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "LOAD_DLL_DEBUG_EVENT"));
      CloseHandle (current_event.u.LoadDll.hFile);
      if (saw_create != 1)
	break;
      catch_errors (handle_load_dll, NULL, (char *) "", RETURN_MASK_ALL);
      ourstatus->kind = TARGET_WAITKIND_LOADED;
      ourstatus->value.integer = 0;
      retval = main_thread_id;
      break;

    case UNLOAD_DLL_DEBUG_EVENT:
      DEBUG_EVENTS (("gdb: kernel event for pid=%u tid=0x%x code=%s)\n",
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "UNLOAD_DLL_DEBUG_EVENT"));
      if (saw_create != 1)
	break;
      catch_errors (handle_unload_dll, NULL, (char *) "", RETURN_MASK_ALL);
      ourstatus->kind = TARGET_WAITKIND_LOADED;
      ourstatus->value.integer = 0;
      retval = main_thread_id;
      break;

    case EXCEPTION_DEBUG_EVENT:
      DEBUG_EVENTS (("gdb: kernel event for pid=%u tid=0x%x code=%s)\n",
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "EXCEPTION_DEBUG_EVENT"));
      if (saw_create != 1)
	break;
      switch (handle_exception (ourstatus))
	{
	case 0:
	  continue_status = DBG_EXCEPTION_NOT_HANDLED;
	  break;
	case 1:
	  retval = current_event.dwThreadId;
	  break;
	case -1:
	  last_sig = 1;
	  continue_status = -1;
	  break;
	}
      break;

    case OUTPUT_DEBUG_STRING_EVENT:	/* Message from the kernel.  */
      DEBUG_EVENTS (("gdb: kernel event for pid=%u tid=0x%x code=%s)\n",
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "OUTPUT_DEBUG_STRING_EVENT"));
      if (saw_create != 1)
	break;
      retval = handle_output_debug_string (ourstatus);
      break;

    default:
      if (saw_create != 1)
	break;
      printf_unfiltered ("gdb: kernel event for pid=%u tid=0x%x\n",
			 (unsigned) current_event.dwProcessId,
			 (unsigned) current_event.dwThreadId);
      printf_unfiltered ("                 unknown event code %u\n",
			 (unsigned) current_event.dwDebugEventCode);
      break;
    }

  if (!retval || saw_create != 1)
    {
      if (continue_status == -1)
	windows_resume (ops, minus_one_ptid, 0, 1);
      else
	CHECK (windows_continue (continue_status, -1));
    }
  else
    {
      inferior_ptid = ptid_build (current_event.dwProcessId, 0,
				  retval);
      current_thread = th ?: thread_rec (current_event.dwThreadId, TRUE);
    }

out:
  return retval;
}

/* Wait for interesting events to occur in the target process.  */
static ptid_t
windows_wait (struct target_ops *ops,
	      ptid_t ptid, struct target_waitstatus *ourstatus, int options)
{
  int pid = -1;

  target_terminal_ours ();

  /* We loop when we get a non-standard exception rather than return
     with a SPURIOUS because resume can try and step or modify things,
     which needs a current_thread->h.  But some of these exceptions mark
     the birth or death of threads, which mean that the current thread
     isn't necessarily what you think it is.  */

  while (1)
    {
      int retval;

      /* If the user presses Ctrl-c while the debugger is waiting
	 for an event, he expects the debugger to interrupt his program
	 and to get the prompt back.  There are two possible situations:

	   - The debugger and the program do not share the console, in
	     which case the Ctrl-c event only reached the debugger.
	     In that case, the ctrl_c handler will take care of interrupting
	     the inferior.  Note that this case is working starting with
	     Windows XP.  For Windows 2000, Ctrl-C should be pressed in the
	     inferior console.

	   - The debugger and the program share the same console, in which
	     case both debugger and inferior will receive the Ctrl-c event.
	     In that case the ctrl_c handler will ignore the event, as the
	     Ctrl-c event generated inside the inferior will trigger the
	     expected debug event.

	     FIXME: brobecker/2008-05-20: If the inferior receives the
	     signal first and the delay until GDB receives that signal
	     is sufficiently long, GDB can sometimes receive the SIGINT
	     after we have unblocked the CTRL+C handler.  This would
	     lead to the debugger stopping prematurely while handling
	     the new-thread event that comes with the handling of the SIGINT
	     inside the inferior, and then stop again immediately when
	     the user tries to resume the execution in the inferior.
	     This is a classic race that we should try to fix one day.  */
      SetConsoleCtrlHandler (&ctrl_c_handler, TRUE);
      retval = get_windows_debug_event (ops, pid, ourstatus);
      SetConsoleCtrlHandler (&ctrl_c_handler, FALSE);

      if (retval)
	return ptid_build (current_event.dwProcessId, 0, retval);
      else
	{
	  int detach = 0;

	  if (deprecated_ui_loop_hook != NULL)
	    detach = deprecated_ui_loop_hook (0);

	  if (detach)
	    windows_kill_inferior (ops);
	}
    }
}

static void
do_initial_windows_stuff (struct target_ops *ops, DWORD pid, int attaching)
{
  extern int stop_after_trap;
  int i;
  struct inferior *inf;
  struct thread_info *tp;

  last_sig = GDB_SIGNAL_0;
  event_count = 0;
  exception_count = 0;
  open_process_used = 0;
  debug_registers_changed = 0;
  debug_registers_used = 0;
  for (i = 0; i < sizeof (dr) / sizeof (dr[0]); i++)
    dr[i] = 0;
#ifdef __CYGWIN__
  cygwin_load_start = cygwin_load_end = 0;
#endif
  current_event.dwProcessId = pid;
  memset (&current_event, 0, sizeof (current_event));
  push_target (ops);
  disable_breakpoints_in_shlibs ();
  windows_clear_solib ();
  clear_proceed_status ();
  init_wait_for_inferior ();

  inf = current_inferior ();
  inferior_appeared (inf, pid);
  inf->attach_flag = attaching;

  /* Make the new process the current inferior, so terminal handling
     can rely on it.  When attaching, we don't know about any thread
     id here, but that's OK --- nothing should be referencing the
     current thread until we report an event out of windows_wait.  */
  inferior_ptid = pid_to_ptid (pid);

  terminal_init_inferior_with_pgrp (pid);
  target_terminal_inferior ();

  windows_initialization_done = 0;
  inf->control.stop_soon = STOP_QUIETLY;
  while (1)
    {
      stop_after_trap = 1;
      wait_for_inferior ();
      tp = inferior_thread ();
      if (tp->suspend.stop_signal != GDB_SIGNAL_TRAP)
	resume (0, tp->suspend.stop_signal);
      else
	break;
    }

  windows_initialization_done = 1;
  inf->control.stop_soon = NO_STOP_QUIETLY;
  stop_after_trap = 0;
  return;
}

/* Try to set or remove a user privilege to the current process.  Return -1
   if that fails, the previous setting of that privilege otherwise.

   This code is copied from the Cygwin source code and rearranged to allow
   dynamically loading of the needed symbols from advapi32 which is only
   available on NT/2K/XP.  */
static int
set_process_privilege (const char *privilege, BOOL enable)
{
  HANDLE token_hdl = NULL;
  LUID restore_priv;
  TOKEN_PRIVILEGES new_priv, orig_priv;
  int ret = -1;
  DWORD size;

  if (!OpenProcessToken (GetCurrentProcess (),
			 TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
			 &token_hdl))
    goto out;

  if (!LookupPrivilegeValueA (NULL, privilege, &restore_priv))
    goto out;

  new_priv.PrivilegeCount = 1;
  new_priv.Privileges[0].Luid = restore_priv;
  new_priv.Privileges[0].Attributes = enable ? SE_PRIVILEGE_ENABLED : 0;

  if (!AdjustTokenPrivileges (token_hdl, FALSE, &new_priv,
			      sizeof orig_priv, &orig_priv, &size))
    goto out;
#if 0
  /* Disabled, otherwise every `attach' in an unprivileged user session
     would raise the "Failed to get SE_DEBUG_NAME privilege" warning in
     windows_attach().  */
  /* AdjustTokenPrivileges returns TRUE even if the privilege could not
     be enabled.  GetLastError () returns an correct error code, though.  */
  if (enable && GetLastError () == ERROR_NOT_ALL_ASSIGNED)
    goto out;
#endif

  ret = orig_priv.Privileges[0].Attributes == SE_PRIVILEGE_ENABLED ? 1 : 0;

out:
  if (token_hdl)
    CloseHandle (token_hdl);

  return ret;
}

/* Attach to process PID, then initialize for debugging it.  */
static void
windows_attach (struct target_ops *ops, char *args, int from_tty)
{
  BOOL ok;
  DWORD pid;

  pid = parse_pid_to_attach (args);

  if (set_process_privilege (SE_DEBUG_NAME, TRUE) < 0)
    {
      printf_unfiltered ("Warning: Failed to get SE_DEBUG_NAME privilege\n");
      printf_unfiltered ("This can cause attach to "
			 "fail on Windows NT/2K/XP\n");
    }

  windows_init_thread_list ();
  ok = DebugActiveProcess (pid);
  saw_create = 0;

#ifdef __CYGWIN__
  if (!ok)
    {
      /* Try fall back to Cygwin pid.  */
      pid = cygwin_internal (CW_CYGWIN_PID_TO_WINPID, pid);

      if (pid > 0)
	ok = DebugActiveProcess (pid);
  }
#endif

  if (!ok)
    error (_("Can't attach to process."));

  DebugSetProcessKillOnExit (FALSE);

  if (from_tty)
    {
      char *exec_file = (char *) get_exec_file (0);

      if (exec_file)
	printf_unfiltered ("Attaching to program `%s', %s\n", exec_file,
			   target_pid_to_str (pid_to_ptid (pid)));
      else
	printf_unfiltered ("Attaching to %s\n",
			   target_pid_to_str (pid_to_ptid (pid)));

      gdb_flush (gdb_stdout);
    }

  do_initial_windows_stuff (ops, pid, 1);
  target_terminal_ours ();
}

static void
windows_detach (struct target_ops *ops, char *args, int from_tty)
{
  int detached = 1;

  ptid_t ptid = {-1};
  windows_resume (ops, ptid, 0, GDB_SIGNAL_0);

  if (!DebugActiveProcessStop (current_event.dwProcessId))
    {
      error (_("Can't detach process %u (error %u)"),
	     (unsigned) current_event.dwProcessId, (unsigned) GetLastError ());
      detached = 0;
    }
  DebugSetProcessKillOnExit (FALSE);

  if (detached && from_tty)
    {
      char *exec_file = get_exec_file (0);
      if (exec_file == 0)
	exec_file = "";
      printf_unfiltered ("Detaching from program: %s, Pid %u\n", exec_file,
			 (unsigned) current_event.dwProcessId);
      gdb_flush (gdb_stdout);
    }

  i386_cleanup_dregs ();
  inferior_ptid = null_ptid;
  detach_inferior (current_event.dwProcessId);

  unpush_target (ops);
}

static char *
windows_pid_to_exec_file (int pid)
{
  static char path[__PMAX];
#ifdef __CYGWIN__
  /* Try to find exe name as symlink target of /proc/<pid>/exe.  */
  int nchars;
  char procexe[sizeof ("/proc/4294967295/exe")];

  xsnprintf (procexe, sizeof (procexe), "/proc/%u/exe", pid);
  nchars = readlink (procexe, path, sizeof(path));
  if (nchars > 0 && nchars < sizeof (path))
    {
      path[nchars] = '\0';	/* Got it */
      return path;
    }
#endif

  /* If we get here then either Cygwin is hosed, this isn't a Cygwin version
     of gdb, or we're trying to debug a non-Cygwin windows executable.  */
  if (!get_module_name (0, path))
    path[0] = '\0';

  return path;
}

/* Print status information about what we're accessing.  */

static void
windows_files_info (struct target_ops *ignore)
{
  struct inferior *inf = current_inferior ();

  printf_unfiltered ("\tUsing the running image of %s %s.\n",
		     inf->attach_flag ? "attached" : "child",
		     target_pid_to_str (inferior_ptid));
}

static void
windows_open (char *arg, int from_tty)
{
  error (_("Use the \"run\" command to start a Unix child process."));
}

/* Modify CreateProcess parameters for use of a new separate console.
   Parameters are:
   *FLAGS: DWORD parameter for general process creation flags.
   *SI: STARTUPINFO structure, for which the console window size and
   console buffer size is filled in if GDB is running in a console.
   to create the new console.
   The size of the used font is not available on all versions of
   Windows OS.  Furthermore, the current font might not be the default
   font, but this is still better than before.
   If the windows and buffer sizes are computed,
   SI->DWFLAGS is changed so that this information is used
   by CreateProcess function.  */

static void
windows_set_console_info (STARTUPINFO *si, DWORD *flags)
{
  HANDLE hconsole = CreateFile ("CONOUT$", GENERIC_READ | GENERIC_WRITE,
				FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, 0);

  if (hconsole != INVALID_HANDLE_VALUE)
    {
      CONSOLE_SCREEN_BUFFER_INFO sbinfo;
      COORD font_size;
      CONSOLE_FONT_INFO cfi;

      GetCurrentConsoleFont (hconsole, FALSE, &cfi);
      font_size = GetConsoleFontSize (hconsole, cfi.nFont);
      GetConsoleScreenBufferInfo(hconsole, &sbinfo);
      si->dwXSize = sbinfo.srWindow.Right - sbinfo.srWindow.Left + 1;
      si->dwYSize = sbinfo.srWindow.Bottom - sbinfo.srWindow.Top + 1;
      if (font_size.X)
	si->dwXSize *= font_size.X;
      else
	si->dwXSize *= 8;
      if (font_size.Y)
	si->dwYSize *= font_size.Y;
      else
	si->dwYSize *= 12;
      si->dwXCountChars = sbinfo.dwSize.X;
      si->dwYCountChars = sbinfo.dwSize.Y;
      si->dwFlags |= STARTF_USESIZE | STARTF_USECOUNTCHARS;
    }
  *flags |= CREATE_NEW_CONSOLE;
}

#ifndef __CYGWIN__
/* Function called by qsort to sort environment strings.  */

static int
envvar_cmp (const void *a, const void *b)
{
  const char **p = (const char **) a;
  const char **q = (const char **) b;
  return strcasecmp (*p, *q);
}
#endif

#ifdef __CYGWIN__
static void
clear_win32_environment (char **env)
{
  int i;
  size_t len;
  wchar_t *copy = NULL, *equalpos;

  for (i = 0; env[i] && *env[i]; i++)
    {
      len = mbstowcs (NULL, env[i], 0) + 1;
      copy = (wchar_t *) xrealloc (copy, len * sizeof (wchar_t));
      mbstowcs (copy, env[i], len);
      equalpos = wcschr (copy, L'=');
      if (equalpos)
        *equalpos = L'\0';
      SetEnvironmentVariableW (copy, NULL);
    }
  xfree (copy);
}
#endif

/* Start an inferior windows child process and sets inferior_ptid to its pid.
   EXEC_FILE is the file to run.
   ALLARGS is a string containing the arguments to the program.
   ENV is the environment vector to pass.  Errors reported with error().  */

static void
windows_create_inferior (struct target_ops *ops, char *exec_file,
		       char *allargs, char **in_env, int from_tty)
{
  STARTUPINFO si;
#ifdef __CYGWIN__
  cygwin_buf_t real_path[__PMAX];
  cygwin_buf_t shell[__PMAX]; /* Path to shell */
  const char *sh;
  cygwin_buf_t *toexec;
  cygwin_buf_t *cygallargs;
  cygwin_buf_t *args;
  char **old_env = NULL;
  PWCHAR w32_env;
  size_t len;
  int tty;
  int ostdin, ostdout, ostderr;
#else
  char real_path[__PMAX];
  char shell[__PMAX]; /* Path to shell */
  char *toexec;
  char *args;
  size_t args_len;
  HANDLE tty;
  char *w32env;
  char *temp;
  size_t envlen;
  int i;
  size_t envsize;
  char **env;
#endif
  PROCESS_INFORMATION pi;
  BOOL ret;
  DWORD flags = 0;
  const char *inferior_io_terminal = get_inferior_io_terminal ();

  if (!exec_file)
    error (_("No executable specified, use `target exec'."));

  memset (&si, 0, sizeof (si));
  si.cb = sizeof (si);

  if (new_group)
    flags |= CREATE_NEW_PROCESS_GROUP;

  if (new_console)
    windows_set_console_info (&si, &flags);

#ifdef __CYGWIN__
  if (!useshell)
    {
      flags |= DEBUG_ONLY_THIS_PROCESS;
      if (cygwin_conv_path (CCP_POSIX_TO_WIN_W, exec_file, real_path,
			    __PMAX * sizeof (cygwin_buf_t)) < 0)
	error (_("Error starting executable: %d"), errno);
      toexec = real_path;
#ifdef __USEWIDE
      len = mbstowcs (NULL, allargs, 0) + 1;
      if (len == (size_t) -1)
	error (_("Error starting executable: %d"), errno);
      cygallargs = (wchar_t *) alloca (len * sizeof (wchar_t));
      mbstowcs (cygallargs, allargs, len);
#else
      cygallargs = allargs;
#endif
    }
  else
    {
      sh = getenv ("SHELL");
      if (!sh)
	sh = "/bin/sh";
      if (cygwin_conv_path (CCP_POSIX_TO_WIN_W, sh, shell, __PMAX) < 0)
      	error (_("Error starting executable via shell: %d"), errno);
#ifdef __USEWIDE
      len = sizeof (L" -c 'exec  '") + mbstowcs (NULL, exec_file, 0)
	    + mbstowcs (NULL, allargs, 0) + 2;
      cygallargs = (wchar_t *) alloca (len * sizeof (wchar_t));
      swprintf (cygallargs, len, L" -c 'exec %s %s'", exec_file, allargs);
#else
      len = (sizeof (" -c 'exec  '") + strlen (exec_file)
	     + strlen (allargs) + 2);
      cygallargs = (char *) alloca (len);
      xsnprintf (cygallargs, len, " -c 'exec %s %s'", exec_file, allargs);
#endif
      toexec = shell;
      flags |= DEBUG_PROCESS;
    }

#ifdef __USEWIDE
  args = (cygwin_buf_t *) alloca ((wcslen (toexec) + wcslen (cygallargs) + 2)
				  * sizeof (wchar_t));
  wcscpy (args, toexec);
  wcscat (args, L" ");
  wcscat (args, cygallargs);
#else
  args = (cygwin_buf_t *) alloca (strlen (toexec) + strlen (cygallargs) + 2);
  strcpy (args, toexec);
  strcat (args, " ");
  strcat (args, cygallargs);
#endif

#ifdef CW_CVT_ENV_TO_WINENV
  /* First try to create a direct Win32 copy of the POSIX environment. */
  w32_env = (PWCHAR) cygwin_internal (CW_CVT_ENV_TO_WINENV, in_env);
  if (w32_env != (PWCHAR) -1)
    flags |= CREATE_UNICODE_ENVIRONMENT;
  else
    /* If that fails, fall back to old method tweaking GDB's environment. */
#endif
    {
      /* Reset all Win32 environment variables to avoid leftover on next run. */
      clear_win32_environment (environ);
      /* Prepare the environment vars for CreateProcess.  */
      old_env = environ;
      environ = in_env;
      cygwin_internal (CW_SYNC_WINENV);
      w32_env = NULL;
    }

  if (!inferior_io_terminal)
    tty = ostdin = ostdout = ostderr = -1;
  else
    {
      tty = open (inferior_io_terminal, O_RDWR | O_NOCTTY);
      if (tty < 0)
	{
	  print_sys_errmsg (inferior_io_terminal, errno);
	  ostdin = ostdout = ostderr = -1;
	}
      else
	{
	  ostdin = dup (0);
	  ostdout = dup (1);
	  ostderr = dup (2);
	  dup2 (tty, 0);
	  dup2 (tty, 1);
	  dup2 (tty, 2);
	}
    }

  windows_init_thread_list ();
  ret = CreateProcess (0,
		       args,	/* command line */
		       NULL,	/* Security */
		       NULL,	/* thread */
		       TRUE,	/* inherit handles */
		       flags,	/* start flags */
		       w32_env,	/* environment */
		       NULL,	/* current directory */
		       &si,
		       &pi);
  if (w32_env)
    /* Just free the Win32 environment, if it could be created. */
    free (w32_env);
  else
    {
      /* Reset all environment variables to avoid leftover on next run. */
      clear_win32_environment (in_env);
      /* Restore normal GDB environment variables.  */
      environ = old_env;
      cygwin_internal (CW_SYNC_WINENV);
    }

  if (tty >= 0)
    {
      close (tty);
      dup2 (ostdin, 0);
      dup2 (ostdout, 1);
      dup2 (ostderr, 2);
      close (ostdin);
      close (ostdout);
      close (ostderr);
    }
#else
  toexec = exec_file;
  /* Build the command line, a space-separated list of tokens where
     the first token is the name of the module to be executed.
     To avoid ambiguities introduced by spaces in the module name,
     we quote it.  */
  args_len = strlen (toexec) + 2 /* quotes */ + strlen (allargs) + 2;
  args = alloca (args_len);
  xsnprintf (args, args_len, "\"%s\" %s", toexec, allargs);

  flags |= DEBUG_ONLY_THIS_PROCESS;

  if (!inferior_io_terminal)
    tty = INVALID_HANDLE_VALUE;
  else
    {
      SECURITY_ATTRIBUTES sa;
      sa.nLength = sizeof(sa);
      sa.lpSecurityDescriptor = 0;
      sa.bInheritHandle = TRUE;
      tty = CreateFileA (inferior_io_terminal, GENERIC_READ | GENERIC_WRITE,
			 0, &sa, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
      if (tty == INVALID_HANDLE_VALUE)
	warning (_("Warning: Failed to open TTY %s, error %#x."),
		 inferior_io_terminal, (unsigned) GetLastError ());
      else
	{
	  si.hStdInput = tty;
	  si.hStdOutput = tty;
	  si.hStdError = tty;
	  si.dwFlags |= STARTF_USESTDHANDLES;
	}
    }

  /* CreateProcess takes the environment list as a null terminated set of
     strings (i.e. two nulls terminate the list).  */

  /* Get total size for env strings.  */
  for (envlen = 0, i = 0; in_env[i] && *in_env[i]; i++)
    envlen += strlen (in_env[i]) + 1;

  envsize = sizeof (in_env[0]) * (i + 1);
  env = (char **) alloca (envsize);
  memcpy (env, in_env, envsize);
  /* Windows programs expect the environment block to be sorted.  */
  qsort (env, i, sizeof (char *), envvar_cmp);

  w32env = alloca (envlen + 1);

  /* Copy env strings into new buffer.  */
  for (temp = w32env, i = 0; env[i] && *env[i]; i++)
    {
      strcpy (temp, env[i]);
      temp += strlen (temp) + 1;
    }

  /* Final nil string to terminate new env.  */
  *temp = 0;

  windows_init_thread_list ();
  ret = CreateProcessA (0,
			args,	/* command line */
			NULL,	/* Security */
			NULL,	/* thread */
			TRUE,	/* inherit handles */
			flags,	/* start flags */
			w32env,	/* environment */
			NULL,	/* current directory */
			&si,
			&pi);
  if (tty != INVALID_HANDLE_VALUE)
    CloseHandle (tty);
#endif

  if (!ret)
    error (_("Error creating process %s, (error %u)."),
	   exec_file, (unsigned) GetLastError ());

  CloseHandle (pi.hThread);
  CloseHandle (pi.hProcess);

  if (useshell && shell[0] != '\0')
    saw_create = -1;
  else
    saw_create = 0;

  do_initial_windows_stuff (ops, pi.dwProcessId, 0);

  /* windows_continue (DBG_CONTINUE, -1); */
}

static void
windows_mourn_inferior (struct target_ops *ops)
{
  (void) windows_continue (DBG_CONTINUE, -1);
  i386_cleanup_dregs();
  if (open_process_used)
    {
      CHECK (CloseHandle (current_process_handle));
      open_process_used = 0;
    }
  unpush_target (ops);
  generic_mourn_inferior ();
}

/* Send a SIGINT to the process group.  This acts just like the user typed a
   ^C on the controlling terminal.  */

static void
windows_stop (ptid_t ptid)
{
  DEBUG_EVENTS (("gdb: GenerateConsoleCtrlEvent (CTRLC_EVENT, 0)\n"));
  CHECK (GenerateConsoleCtrlEvent (CTRL_C_EVENT, current_event.dwProcessId));
  registers_changed ();		/* refresh register state */
}

/* Helper for windows_xfer_partial that handles memory transfers.
   Arguments are like target_xfer_partial.  */

static LONGEST
windows_xfer_memory (gdb_byte *readbuf, const gdb_byte *writebuf,
		     ULONGEST memaddr, LONGEST len)
{
  SIZE_T done = 0;
  BOOL success;
  DWORD lasterror = 0;

  if (writebuf != NULL)
    {
      DEBUG_MEM (("gdb: write target memory, %s bytes at %s\n",
		  plongest (len), core_addr_to_string (memaddr)));
      success = WriteProcessMemory (current_process_handle,
				    (LPVOID) (uintptr_t) memaddr, writebuf,
				    len, &done);
      if (!success)
	lasterror = GetLastError ();
      FlushInstructionCache (current_process_handle,
			     (LPCVOID) (uintptr_t) memaddr, len);
    }
  else
    {
      DEBUG_MEM (("gdb: read target memory, %s bytes at %s\n",
		  plongest (len), core_addr_to_string (memaddr)));
      success = ReadProcessMemory (current_process_handle,
				   (LPCVOID) (uintptr_t) memaddr, readbuf,
				   len, &done);
      if (!success)
	lasterror = GetLastError ();
    }
  if (!success && lasterror == ERROR_PARTIAL_COPY && done > 0)
    return done;
  else
    return success ? done : TARGET_XFER_E_IO;
}

static void
windows_kill_inferior (struct target_ops *ops)
{
  CHECK (TerminateProcess (current_process_handle, 0));

  for (;;)
    {
      if (!windows_continue (DBG_CONTINUE, -1))
	break;
      if (!WaitForDebugEvent (&current_event, INFINITE))
	break;
      if (current_event.dwDebugEventCode == EXIT_PROCESS_DEBUG_EVENT)
	break;
    }

  target_mourn_inferior ();	/* Or just windows_mourn_inferior?  */
}

static void
windows_prepare_to_store (struct regcache *regcache)
{
  /* Do nothing, since we can store individual regs.  */
}

static int
windows_can_run (void)
{
  return 1;
}

static void
windows_close (void)
{
  DEBUG_EVENTS (("gdb: windows_close, inferior_ptid=%d\n",
		ptid_get_pid (inferior_ptid)));
}

/* Convert pid to printable format.  */
static char *
windows_pid_to_str (struct target_ops *ops, ptid_t ptid)
{
  static char buf[80];

  if (ptid_get_tid (ptid) != 0)
    {
      snprintf (buf, sizeof (buf), "Thread %d.0x%lx",
		ptid_get_pid (ptid), ptid_get_tid (ptid));
      return buf;
    }

  return normal_pid_to_str (ptid);
}

static LONGEST
windows_xfer_shared_libraries (struct target_ops *ops,
			     enum target_object object, const char *annex,
			     gdb_byte *readbuf, const gdb_byte *writebuf,
			     ULONGEST offset, LONGEST len)
{
  struct obstack obstack;
  const char *buf;
  LONGEST len_avail;
  struct so_list *so;

  if (writebuf)
    return -1;

  obstack_init (&obstack);
  obstack_grow_str (&obstack, "<library-list>\n");
  for (so = solib_start.next; so; so = so->next)
    windows_xfer_shared_library (so->so_name, (CORE_ADDR)
				 (uintptr_t) so->lm_info->load_addr,
				 target_gdbarch (), &obstack);
  obstack_grow_str0 (&obstack, "</library-list>\n");

  buf = obstack_finish (&obstack);
  len_avail = strlen (buf);
  if (offset >= len_avail)
    len= 0;
  else
    {
      if (len > len_avail - offset)
	len = len_avail - offset;
      memcpy (readbuf, buf + offset, len);
    }

  obstack_free (&obstack, NULL);
  return len;
}

static LONGEST
windows_xfer_partial (struct target_ops *ops, enum target_object object,
		    const char *annex, gdb_byte *readbuf,
		    const gdb_byte *writebuf, ULONGEST offset, LONGEST len)
{
  switch (object)
    {
    case TARGET_OBJECT_MEMORY:
      return windows_xfer_memory (readbuf, writebuf, offset, len);

    case TARGET_OBJECT_LIBRARIES:
      return windows_xfer_shared_libraries (ops, object, annex, readbuf,
					  writebuf, offset, len);

    default:
      if (ops->beneath != NULL)
	return ops->beneath->to_xfer_partial (ops->beneath, object, annex,
					      readbuf, writebuf, offset, len);
      return -1;
    }
}

/* Provide thread local base, i.e. Thread Information Block address.
   Returns 1 if ptid is found and sets *ADDR to thread_local_base.  */

static int
windows_get_tib_address (ptid_t ptid, CORE_ADDR *addr)
{
  thread_info *th;

  th = thread_rec (ptid_get_tid (ptid), 0);
  if (th == NULL)
    return 0;

  if (addr != NULL)
    *addr = th->thread_local_base;

  return 1;
}

static ptid_t
windows_get_ada_task_ptid (long lwp, long thread)
{
  return ptid_build (ptid_get_pid (inferior_ptid), 0, lwp);
}

static void
init_windows_ops (void)
{
  windows_ops.to_shortname = "child";
  windows_ops.to_longname = "Win32 child process";
  windows_ops.to_doc = "Win32 child process (started by the \"run\" command).";
  windows_ops.to_open = windows_open;
  windows_ops.to_close = windows_close;
  windows_ops.to_attach = windows_attach;
  windows_ops.to_attach_no_wait = 1;
  windows_ops.to_detach = windows_detach;
  windows_ops.to_resume = windows_resume;
  windows_ops.to_wait = windows_wait;
  windows_ops.to_fetch_registers = windows_fetch_inferior_registers;
  windows_ops.to_store_registers = windows_store_inferior_registers;
  windows_ops.to_prepare_to_store = windows_prepare_to_store;
  windows_ops.to_xfer_partial = windows_xfer_partial;
  windows_ops.to_files_info = windows_files_info;
  windows_ops.to_insert_breakpoint = memory_insert_breakpoint;
  windows_ops.to_remove_breakpoint = memory_remove_breakpoint;
  windows_ops.to_terminal_init = terminal_init_inferior;
  windows_ops.to_terminal_inferior = terminal_inferior;
  windows_ops.to_terminal_ours_for_output = terminal_ours_for_output;
  windows_ops.to_terminal_ours = terminal_ours;
  windows_ops.to_terminal_save_ours = terminal_save_ours;
  windows_ops.to_terminal_info = child_terminal_info;
  windows_ops.to_kill = windows_kill_inferior;
  windows_ops.to_create_inferior = windows_create_inferior;
  windows_ops.to_mourn_inferior = windows_mourn_inferior;
  windows_ops.to_can_run = windows_can_run;
  windows_ops.to_thread_alive = windows_thread_alive;
  windows_ops.to_pid_to_str = windows_pid_to_str;
  windows_ops.to_stop = windows_stop;
  windows_ops.to_stratum = process_stratum;
  windows_ops.to_has_all_memory = default_child_has_all_memory;
  windows_ops.to_has_memory = default_child_has_memory;
  windows_ops.to_has_stack = default_child_has_stack;
  windows_ops.to_has_registers = default_child_has_registers;
  windows_ops.to_has_execution = default_child_has_execution;
  windows_ops.to_pid_to_exec_file = windows_pid_to_exec_file;
  windows_ops.to_get_ada_task_ptid = windows_get_ada_task_ptid;
  windows_ops.to_get_tib_address = windows_get_tib_address;

  i386_use_watchpoints (&windows_ops);

  i386_dr_low.set_control = cygwin_set_dr7;
  i386_dr_low.set_addr = cygwin_set_dr;
  i386_dr_low.get_addr = cygwin_get_dr;
  i386_dr_low.get_status = cygwin_get_dr6;
  i386_dr_low.get_control = cygwin_get_dr7;

  /* i386_dr_low.debug_register_length field is set by
     calling i386_set_debug_register_length function
     in processor windows specific native file.  */

  windows_ops.to_magic = OPS_MAGIC;
}

static void
set_windows_aliases (char *argv0)
{
  add_info_alias ("dll", "sharedlibrary", 1);
}

/* -Wmissing-prototypes */
extern initialize_file_ftype _initialize_windows_nat;

void
_initialize_windows_nat (void)
{
  struct cmd_list_element *c;

  init_windows_ops ();

#ifdef __CYGWIN__
  cygwin_internal (CW_SET_DOS_FILE_WARNING, 0);
#endif

  c = add_com ("dll-symbols", class_files, dll_symbol_command,
	       _("Load dll library symbols from FILE."));
  set_cmd_completer (c, filename_completer);

  add_com_alias ("sharedlibrary", "dll-symbols", class_alias, 1);

  add_com_alias ("add-shared-symbol-files", "dll-symbols", class_alias, 1);

  add_com_alias ("assf", "dll-symbols", class_alias, 1);

#ifdef __CYGWIN__
  add_setshow_boolean_cmd ("shell", class_support, &useshell, _("\
Set use of shell to start subprocess."), _("\
Show use of shell to start subprocess."), NULL,
			   NULL,
			   NULL, /* FIXME: i18n: */
			   &setlist, &showlist);

  add_setshow_boolean_cmd ("cygwin-exceptions", class_support,
			   &cygwin_exceptions, _("\
Break when an exception is detected in the Cygwin DLL itself."), _("\
Show whether gdb breaks on exceptions in the Cygwin DLL itself."), NULL,
			   NULL,
			   NULL, /* FIXME: i18n: */
			   &setlist, &showlist);
#endif

  add_setshow_boolean_cmd ("new-console", class_support, &new_console, _("\
Set creation of new console when creating child process."), _("\
Show creation of new console when creating child process."), NULL,
			   NULL,
			   NULL, /* FIXME: i18n: */
			   &setlist, &showlist);

  add_setshow_boolean_cmd ("new-group", class_support, &new_group, _("\
Set creation of new group when creating child process."), _("\
Show creation of new group when creating child process."), NULL,
			   NULL,
			   NULL, /* FIXME: i18n: */
			   &setlist, &showlist);

  add_setshow_boolean_cmd ("debugexec", class_support, &debug_exec, _("\
Set whether to display execution in child process."), _("\
Show whether to display execution in child process."), NULL,
			   NULL,
			   NULL, /* FIXME: i18n: */
			   &setlist, &showlist);

  add_setshow_boolean_cmd ("debugevents", class_support, &debug_events, _("\
Set whether to display kernel events in child process."), _("\
Show whether to display kernel events in child process."), NULL,
			   NULL,
			   NULL, /* FIXME: i18n: */
			   &setlist, &showlist);

  add_setshow_boolean_cmd ("debugmemory", class_support, &debug_memory, _("\
Set whether to display memory accesses in child process."), _("\
Show whether to display memory accesses in child process."), NULL,
			   NULL,
			   NULL, /* FIXME: i18n: */
			   &setlist, &showlist);

  add_setshow_boolean_cmd ("debugexceptions", class_support,
			   &debug_exceptions, _("\
Set whether to display kernel exceptions in child process."), _("\
Show whether to display kernel exceptions in child process."), NULL,
			   NULL,
			   NULL, /* FIXME: i18n: */
			   &setlist, &showlist);

  init_w32_command_list ();

  add_cmd ("selector", class_info, display_selectors,
	   _("Display selectors infos."),
	   &info_w32_cmdlist);
  add_target (&windows_ops);
  deprecated_init_ui_hook = set_windows_aliases;
}

/* Hardware watchpoint support, adapted from go32-nat.c code.  */

/* Pass the address ADDR to the inferior in the I'th debug register.
   Here we just store the address in dr array, the registers will be
   actually set up when windows_continue is called.  */
static void
cygwin_set_dr (int i, CORE_ADDR addr)
{
  if (i < 0 || i > 3)
    internal_error (__FILE__, __LINE__,
		    _("Invalid register %d in cygwin_set_dr.\n"), i);
  dr[i] = addr;
  debug_registers_changed = 1;
  debug_registers_used = 1;
}

/* Pass the value VAL to the inferior in the DR7 debug control
   register.  Here we just store the address in D_REGS, the watchpoint
   will be actually set up in windows_wait.  */
static void
cygwin_set_dr7 (unsigned long val)
{
  dr[7] = (CORE_ADDR) val;
  debug_registers_changed = 1;
  debug_registers_used = 1;
}

/* Get the value of debug register I from the inferior.  */

static CORE_ADDR
cygwin_get_dr (int i)
{
  return dr[i];
}

/* Get the value of the DR6 debug status register from the inferior.
   Here we just return the value stored in dr[6]
   by the last call to thread_rec for current_event.dwThreadId id.  */
static unsigned long
cygwin_get_dr6 (void)
{
  return (unsigned long) dr[6];
}

/* Get the value of the DR7 debug status register from the inferior.
   Here we just return the value stored in dr[7] by the last call to
   thread_rec for current_event.dwThreadId id.  */

static unsigned long
cygwin_get_dr7 (void)
{
  return (unsigned long) dr[7];
}

/* Determine if the thread referenced by "ptid" is alive
   by "polling" it.  If WaitForSingleObject returns WAIT_OBJECT_0
   it means that the thread has died.  Otherwise it is assumed to be alive.  */
static int
windows_thread_alive (struct target_ops *ops, ptid_t ptid)
{
  int tid;

  gdb_assert (ptid_get_tid (ptid) != 0);
  tid = ptid_get_tid (ptid);

  return WaitForSingleObject (thread_rec (tid, FALSE)->h, 0) == WAIT_OBJECT_0
    ? FALSE : TRUE;
}

/* -Wmissing-prototypes */
extern initialize_file_ftype _initialize_check_for_gdb_ini;

void
_initialize_check_for_gdb_ini (void)
{
  char *homedir;
  if (inhibit_gdbinit)
    return;

  homedir = getenv ("HOME");
  if (homedir)
    {
      char *p;
      char *oldini = (char *) alloca (strlen (homedir) +
				      sizeof ("/gdb.ini"));
      strcpy (oldini, homedir);
      p = strchr (oldini, '\0');
      if (p > oldini && !IS_DIR_SEPARATOR (p[-1]))
	*p++ = '/';
      strcpy (p, "gdb.ini");
      if (access (oldini, 0) == 0)
	{
	  int len = strlen (oldini);
	  char *newini = alloca (len + 1);

	  xsnprintf (newini, len + 1, "%.*s.gdbinit",
		     (int) (len - (sizeof ("gdb.ini") - 1)), oldini);
	  warning (_("obsolete '%s' found. Rename to '%s'."), oldini, newini);
	}
    }
}

/* Define dummy functions which always return error for the rare cases where
   these functions could not be found.  */
static BOOL WINAPI
bad_DebugActiveProcessStop (DWORD w)
{
  return FALSE;
}
static BOOL WINAPI
bad_DebugBreakProcess (HANDLE w)
{
  return FALSE;
}
static BOOL WINAPI
bad_DebugSetProcessKillOnExit (BOOL w)
{
  return FALSE;
}
static BOOL WINAPI
bad_EnumProcessModules (HANDLE w, HMODULE *x, DWORD y, LPDWORD z)
{
  return FALSE;
}

#ifdef __USEWIDE
static DWORD WINAPI
bad_GetModuleFileNameExW (HANDLE w, HMODULE x, LPWSTR y, DWORD z)
{
  return 0;
}
#else
static DWORD WINAPI
bad_GetModuleFileNameExA (HANDLE w, HMODULE x, LPSTR y, DWORD z)
{
  return 0;
}
#endif

static BOOL WINAPI
bad_GetModuleInformation (HANDLE w, HMODULE x, LPMODULEINFO y, DWORD z)
{
  return FALSE;
}

static BOOL WINAPI
bad_OpenProcessToken (HANDLE w, DWORD x, PHANDLE y)
{
  return FALSE;
}

static BOOL WINAPI
bad_GetCurrentConsoleFont (HANDLE w, BOOL bMaxWindow, CONSOLE_FONT_INFO *f)
{
  f->nFont = 0;
  return 1;
}
static COORD WINAPI
bad_GetConsoleFontSize (HANDLE w, DWORD nFont)
{
  COORD size;
  size.X = 8;
  size.Y = 12;
  return size;
}
 
/* -Wmissing-prototypes */
extern initialize_file_ftype _initialize_loadable;

/* Load any functions which may not be available in ancient versions
   of Windows.  */

void
_initialize_loadable (void)
{
  HMODULE hm = NULL;

  hm = LoadLibrary ("kernel32.dll");
  if (hm)
    {
      DebugActiveProcessStop = (void *)
	GetProcAddress (hm, "DebugActiveProcessStop");
      DebugBreakProcess = (void *)
	GetProcAddress (hm, "DebugBreakProcess");
      DebugSetProcessKillOnExit = (void *)
	GetProcAddress (hm, "DebugSetProcessKillOnExit");
      GetConsoleFontSize = (void *) 
	GetProcAddress (hm, "GetConsoleFontSize");
      GetCurrentConsoleFont = (void *) 
	GetProcAddress (hm, "GetCurrentConsoleFont");
    }

  /* Set variables to dummy versions of these processes if the function
     wasn't found in kernel32.dll.  */
  if (!DebugBreakProcess)
    DebugBreakProcess = bad_DebugBreakProcess;
  if (!DebugActiveProcessStop || !DebugSetProcessKillOnExit)
    {
      DebugActiveProcessStop = bad_DebugActiveProcessStop;
      DebugSetProcessKillOnExit = bad_DebugSetProcessKillOnExit;
    }
  if (!GetConsoleFontSize)
    GetConsoleFontSize = bad_GetConsoleFontSize;
  if (!GetCurrentConsoleFont)
    GetCurrentConsoleFont = bad_GetCurrentConsoleFont;

  /* Load optional functions used for retrieving filename information
     associated with the currently debugged process or its dlls.  */
  hm = LoadLibrary ("psapi.dll");
  if (hm)
    {
      EnumProcessModules = (void *)
	GetProcAddress (hm, "EnumProcessModules");
      GetModuleInformation = (void *)
	GetProcAddress (hm, "GetModuleInformation");
      GetModuleFileNameEx = (void *)
	GetProcAddress (hm, GetModuleFileNameEx_name);
    }

  if (!EnumProcessModules || !GetModuleInformation || !GetModuleFileNameEx)
    {
      /* Set variables to dummy versions of these processes if the function
	 wasn't found in psapi.dll.  */
      EnumProcessModules = bad_EnumProcessModules;
      GetModuleInformation = bad_GetModuleInformation;
      GetModuleFileNameEx = bad_GetModuleFileNameEx;
      /* This will probably fail on Windows 9x/Me.  Let the user know
	 that we're missing some functionality.  */
      warning(_("\
cannot automatically find executable file or library to read symbols.\n\
Use \"file\" or \"dll\" command to load executable/libraries directly."));
    }

  hm = LoadLibrary ("advapi32.dll");
  if (hm)
    {
      OpenProcessToken = (void *) GetProcAddress (hm, "OpenProcessToken");
      LookupPrivilegeValueA = (void *)
	GetProcAddress (hm, "LookupPrivilegeValueA");
      AdjustTokenPrivileges = (void *)
	GetProcAddress (hm, "AdjustTokenPrivileges");
      /* Only need to set one of these since if OpenProcessToken fails nothing
	 else is needed.  */
      if (!OpenProcessToken || !LookupPrivilegeValueA
	  || !AdjustTokenPrivileges)
	OpenProcessToken = bad_OpenProcessToken;
    }
}
@


1.261
log
@ Fix small indentation error in last commit
@
text
@d2391 1
a2391 1
		PIDGET (inferior_ptid)));
@


1.260
log
@	* windows-nat.c (windows_xfer_memory): Handle ERROR_PARTIAL_COPY
	error code.
@
text
@d2337 1
a2337 1
       lasterror = GetLastError ();
d2349 1
a2349 1
       lasterror = GetLastError ();
@


1.259
log
@	* windows-nat.c (windows_xfer_memory): Fix compilation failure
	by use of plongest function.
@
text
@d2327 1
d2336 2
d2348 2
d2351 4
a2354 1
  return success ? done : TARGET_XFER_E_IO;
@


1.258
log
@windows-nat.c: Don't install a deprecated_xfer_memory method.

This stops another target from installing a
target_ops->deprecated_xfer_memory method.

Tested on native MinGW.

gdb/
2013-08-27  Pedro Alves  <palves@@redhat.com>

	* windows-nat.c (windows_xfer_memory): Adjust prototype to follow
	xfer_partial's interface.  Return TARGET_XFER_E_IO on error.
	(windows_xfer_partial): Defer TARGET_OBJECT_MEMORY handling to
	windows_xfer_memory directly.
	(init_windows_ops): Don't install a deprecated_xfer_memory method.
@
text
@d2330 2
a2331 2
      DEBUG_MEM (("gdb: write target memory, %d bytes at %s\n",
		  len, core_addr_to_string (memaddr)));
d2340 2
a2341 2
      DEBUG_MEM (("gdb: read target memory, %d bytes at %s\n",
		  len, core_addr_to_string (memaddr)));
@


1.257
log
@Normalize on PATH_MAX instead of MAXPATHLEN throughout.

With the pathmax gnulib module in place, we can use PATH_MAX
consistently throughout, instead of the current mixbag of PATH_MAX and
MAXPATHLEN uses.  It's no longer necessary to include sys/param.h
(supposedly, I can't check all ports touched here) for MAXPATHLEN.

Don't remove sys/param.h from GDB's configure.ac, as later tests in
the file use HAVE_SYS_PARAM_H checks.

Tested on x86_64 Fedora 17.

Also cross-built for --host=i686-w64-mingw32, and --host=i586-pc-msdosdjgpp.

gdb/
2013-07-01  Pedro Alves  <palves@@redhat.com>

	* defs.h: Include "pathmax.h".
	* utils.c: Don't include sys/param.h.
	(gdb_realpath): Remove code that checks for MAXPATHLEN.
	* solib-ia64-hpux.c (ia64_hpux_handle_load_event): Use PATH_MAX
	instead of MAXPATHLEN.
	* solib-sunos.c: Don't include sys/param.h.
	* xcoffread.c: Don't include sys/param.h.
	* bsd-kvm.c: Don't include sys/param.h.
	* darwin-nat.c: Don't include sys/param.h.
	(darwin_pid_to_exec_file): Use PATH_MAX instead of MAXPATHLEN.
	* darwin-nat-info.c: Don't include sys/param.h.
	* fbsd-nat.c (fbsd_pid_to_exec_file): Use PATH_MAX instead of
	MAXPATHLEN.
	* i386obsd-nat.c: Don't include sys/param.h.
	* inf-child.c: Don't include sys/param.h.
	(inf_child_fileio_readlink): Use PATH_MAX instead of MAXPATHLEN.
	* linux-fork.c: Don't include sys/param.h.
	(fork_save_infrun_state): Use PATH_MAX instead of MAXPATHLEN.
	* linux-nat.c: Don't include sys/param.h.
	(linux_child_pid_to_exec_file, linux_proc_pending_signals)
	(linux_proc_pending_signals): Use PATH_MAX instead of MAXPATHLEN.
	* m68klinux-nat.c: Don't include sys/param.h.
	* nbsd-nat.c: Don't include sys/param.h.
	(nbsd_pid_to_exec_file): Use PATH_MAX instead of MAXPATHLEN.
	* ppc-linux-nat.c: Don't include sys/param.h.
	* rs6000-nat.c: Don't include sys/param.h.
	* spu-linux-nat.c. Don't include sys/param.h.
	* windows-nat.c: Don't include sys/param.h.
	* xtensa-linux-nat.c: Don't include sys/param.h.
	* config/i386/nm-fbsd.h: Don't include sys/param.h.

gdb/gdbserver/
2013-07-01  Pedro Alves  <palves@@redhat.com>

	* server.h: Include "pathmax.h".
	* linux-low.c: Don't include sys/param.h.
	(linux_pid_exe_is_elf_64_file): Use PATH_MAX instead of
	MAXPATHLEN.
	* win32-low.c: Don't include sys/param.h.
	(win32_create_inferior): Use PATH_MAX instead of MAXPATHLEN.
@
text
@d2318 6
a2323 4
static int
windows_xfer_memory (CORE_ADDR memaddr, gdb_byte *our, int len,
		   int write, struct mem_attrib *mem,
		   struct target_ops *target)
d2326 3
a2328 1
  if (write)
d2332 3
a2334 4
      if (!WriteProcessMemory (current_process_handle,
			       (LPVOID) (uintptr_t) memaddr, our,
			       len, &done))
	done = 0;
d2342 3
a2344 4
      if (!ReadProcessMemory (current_process_handle,
			      (LPCVOID) (uintptr_t) memaddr, our,
			      len, &done))
	done = 0;
d2346 1
a2346 1
  return done;
d2447 1
a2447 7
      if (readbuf)
	return (*ops->deprecated_xfer_memory) (offset, readbuf,
					       len, 0/*read*/, NULL, ops);
      if (writebuf)
	return (*ops->deprecated_xfer_memory) (offset, (gdb_byte *) writebuf,
					       len, 1/*write*/, NULL, ops);
      return -1;
a2500 1
  windows_ops.deprecated_xfer_memory = windows_xfer_memory;
@


1.256
log
@windows-nat.c:thread_rec: Add missing empty line after var declaration.

gdb/ChangeLog:

        * window-nat.c (thread_rec): Add missing empty line after
        local variable declaration.
@
text
@a56 1
#include <sys/param.h>
@


1.255
log
@[windows] Fix accidental change of %u -> %d in SuspendThread warning.

While enhancing the warning printed in when SuspendThread fails,
I accidently changed the format used to print the error code
from %u to %d. This patch reverts it back.

gdb/ChangeLog:

        * windows-nat.c (thread_rec): Revert format used to print
        error code returned by SuspendThread from %d back to %u.
@
text
@d314 1
@


1.254
log
@windows: Prefix thread ID values with "0x" in debug traces

The windows-nat.c debug traces print the thread ID in base 16,
but give no indication of it. So, in a trace like the following...

    gdb: kernel event for pid=4816 tid=720 code=CREATE_THREAD_DEBUG_EVENT)

... where tid is "720", it's easy to be confused and think that
the thread ID is 720 rather than 0x720.  This patch avoids the
confusion by adding the usual "0x" prefix used for hexadecimal
values.

gdb/ChangeLog:

        * windows-nat.c (windows_continue): Add "0x" prefix for thread
        ID in debug trace.
        (get_windows_debug_event): Likewise, for all debug traces.
@
text
@d315 1
a315 1
			       " (winerr %d)"),
@


1.253
log
@windows: Add thread ID in SuspendThread error warning message.

This patch adds the thread ID to a warning printed when a call to
SuspendThread fails. It will help investigate issues, particularly
when correlated with the various debug traces provided by the
windows-nat module.

For the record, the output has been changed from...

    warning: SuspendThread failed. (winerr 6)

... to ...

    warning: SuspendThread (tid=0x720) failed. (winerr 6)

gdb/ChangeLog:

        * window-nat.c (thread_rec): Add thread ID in SuspendThread
        warning message.
@
text
@d1259 1
a1259 1
  DEBUG_EVENTS (("ContinueDebugEvent (cpid=%d, ctid=%x, %s);\n",
d1468 1
a1468 1
      DEBUG_EVENTS (("gdb: kernel event for pid=%u tid=%x code=%s)\n",
d1497 1
a1497 1
      DEBUG_EVENTS (("gdb: kernel event for pid=%u tid=%x code=%s)\n",
d1512 1
a1512 1
      DEBUG_EVENTS (("gdb: kernel event for pid=%u tid=%x code=%s)\n",
d1535 1
a1535 1
      DEBUG_EVENTS (("gdb: kernel event for pid=%u tid=%x code=%s)\n",
d1555 1
a1555 1
      DEBUG_EVENTS (("gdb: kernel event for pid=%u tid=%x code=%s)\n",
d1569 1
a1569 1
      DEBUG_EVENTS (("gdb: kernel event for pid=%u tid=%x code=%s)\n",
d1582 1
a1582 1
      DEBUG_EVENTS (("gdb: kernel event for pid=%u tid=%x code=%s)\n",
d1604 1
a1604 1
      DEBUG_EVENTS (("gdb: kernel event for pid=%u tid=%x code=%s)\n",
d1616 1
a1616 1
      printf_unfiltered ("gdb: kernel event for pid=%u tid=%x\n",
@


1.252
log
@windows_delete_thread: Add missing space in cast expression

gdb/ChangeLog:

	* windows-nat.c (windows_delete_thread): Add missing space
	in cast expression.
@
text
@d314 3
a316 2
		    warning (_("SuspendThread failed. (winerr %u)"),
			     (unsigned) err);
@


1.251
log
@Fix reporting of DLL unload events on MS-Windows.

 gdb/windows-nat.c (handle_unload_dll): Don't call solib_add for the
 unloaded DLL, it will be done by handle_solib_event.  See
 http://sourceware.org/ml/gdb-patches/2013-05/msg00713.html for the
 details.
@
text
@d402 1
a402 1
		       target_pid_to_str (ptid), (unsigned)exit_code);
@


1.250
log
@Add missing empty line after var declarations in handle_unload_dll

gdb/ChangeLog:

        * windows-nat.c (handle_unload_dll): Add missing empty line.
@
text
@a893 1
	solib_add (NULL, 0, NULL, auto_solib_add);
@


1.249
log
@Announce thread death on MS-Windows.

	* windows-nat.c (windows_delete_thread): Accept an additional
	argument, the thread's exit code, and announce thread death when
	print_thread_events is non-zero and we are deleting a thread that
	is not the main thread.
	(get_windows_debug_event): Pass thread exit code to
	windows_delete_thread.
@
text
@d887 1
@


1.248
log
@Unbreak Windows-hosted cross debugger builds.

	* windows-nat.c (windows_get_absolute_argv0): Move from here...
	* mingw-hdep.c (windows_get_absolute_argv0): ...to here.
	Include main.h.

	* windows-nat.h (windows_get_absolute_argv0): Move prototype from
	here...
	* main.h (windows_get_absolute_argv0): ...to here.
@
text
@d389 1
a389 1
windows_delete_thread (ptid_t ptid)
d400 3
d1504 2
a1505 1
					   current_event.dwThreadId));
d1522 2
a1523 1
					   main_thread_id));
@


1.247
log
@	* windows-nat.c (handle_output_debug_string): Avoid typecast
	from integer of different size warning.
@
text
@a599 12
/* Return an absolute file name of the running GDB, if possible, or
   ARGV0 if not.  The return value is in malloc'ed storage.  */
char *
windows_get_absolute_argv0 (const char *argv0)
{
  char full_name[PATH_MAX];

  if (GetModuleFileName (NULL, full_name, PATH_MAX))
    return xstrdup (full_name);
  return xstrdup (argv0);
}

@


1.246
log
@windows-nat.c: Add empty line after local block variable definitions.

gdb/ChangeLog:

        * windows-nat.c (handle_output_debug_string): Add empty line
        after local block variable definition.
@
text
@d995 1
a995 1
	  else if ((x = (LPCVOID) strtoull (p, NULL, 0))
@


1.245
log
@Fix relocation of directories in the MinGW build.

 windows-nat.c (windows_get_absolute_argv0): New function.
 windows-nat.h: Add its prototype.
 main.c (get_init_files): Use filename_ncmp instead of strncmp.
 Use IS_DIR_SEPARATOR instead of looking for a character inside
 SLASH_STRING.  Include filenames.h.
 (captured_main) [__MINGW32__]: Make argv[0] absolute, so that
 relocate_gdb_directory works when passed gdb_program_name.
 Include windows-nat.h.
@
text
@d984 1
d990 1
@


1.244
log
@gdb/
	Code cleanup.
	* bfd-target.c (target_bfd_xclose): Remove parameter quitting.
	* bsd-kvm.c (bsd_kvm_close): Likewise.
	* bsd-uthread.c (bsd_uthread_close): Likewise.
	* corelow.c (core_close): Likewise.
	(core_close_cleanup): Remove parameter quitting from a caller.
	* event-top.c (async_disconnect): Likewise.
	* exec.c (exec_close_1): Remove parameter quitting.
	* go32-nat.c (go32_close): Likewise.
	* linux-nat.c (linux_nat_close): Remove parameter quitting.  Remove
	parameter quitting from a caller.
	* mips-linux-nat.c (super_close): Remove parameter quitting from the
	variable.
	(mips_linux_close): Remove parameter quitting.  Remove parameter
	quitting from a caller.
	* monitor.c (monitor_close): Remove parameter quitting.
	* monitor.h (monitor_close): Likewise.
	* record-btrace.c (record_btrace_close): Likewise.
	* record-full.c (record_full_close): Likewise.
	* remote-m32r-sdi.c (m32r_close): Remove parameter quitting and remove
	it also from fprintf_unfiltered.
	* remote-mips.c (mips_close): Remove parameter quitting.
	(mips_detach): Remove parameter quitting from a caller.
	* remote-sim.c (gdbsim_close): Remove parameter quitting.
	(gdbsim_close): Remove duplicate function comment.  Remove parameter
	quitting and remove it also from printf_filtered.
	* remote.c (remote_close): Remove parameter quitting.
	* solib-svr4.c (enable_break): Remove parameter quitting from a caller.
	* target.c (update_current_target): Remove parameter int from to_close
	de_fault.
	(push_target, unpush_target, pop_target): Remove parameter quitting from
	a caller.
	(pop_all_targets_above, pop_all_targets): Remove parameter quitting.
	Remove parameter quitting from a caller.
	(target_preopen): Remove parameter quitting from a caller.
	(target_close): Remove parameter quitting.  Remove parameter quitting
	from a caller two times.  Remove parameter quitting also from
	fprintf_unfiltered.
	* target.h (struct target_ops): Remove parameter quitting and as int
	from fields to_xclose and to_close.
	(extern struct target_ops current_target):
	(target_close, pop_all_targets): Remove parameter quitting.  Update the
	comment.
	(pop_all_targets_above): Remove parameter quitting.
	* top.c (quit_target): Remove parameter quitting from a caller.
	* tracepoint.c (tfile_close): Remove parameter quitting.
	* windows-nat.c (windows_close): Remove parameter quitting.
@
text
@d600 12
@


1.243
log
@	* windows-nat.c (handle_output_debug_string): Replace call
	to string_to_core_addr with call to strtoull.
@
text
@d2370 1
a2370 1
windows_close (int x)
@


1.242
log
@	* windows-nat.c (handle_output_debug_string): Change type of n to
	SIZE_T to avoid crash on 64 bit systems.
@
text
@d981 1
a981 1
	  else if ((x = (LPCVOID) string_to_core_addr (p))
@


1.241
log
@	* windows-nat.c: Throughout, fix format strings and casts of
	printf-like functions to avoid type related warnings on all
	platforms.
	(handle_output_debug_string): Fetch context information address
	from debug string using string_to_core_addr.
@
text
@d976 1
a976 1
	  DWORD n;
@


1.240
log
@	* windows-nat.c (windows_xfer_memory): Fix debug-output
	for LLP64.
@
text
@d292 2
a293 2
    printf_filtered ("error return %s:%d was %lu\n", file, line,
		     GetLastError ());
d314 2
a315 2
		    warning (_("SuspendThread failed. (winerr %d)"),
			     (int) err);
d579 2
a580 1
	    error (_("Error getting dll name: %lu."), GetLastError ());
d981 1
a981 1
	  else if ((x = (LPCVOID) strtoul (p, &p, 0))
d1004 1
a1004 1
      printf_filtered ("0x%03lx: ", sel);
d1068 1
a1068 1
	printf_filtered ("Invalid selector 0x%lx.\n",sel);
d1232 2
a1233 2
      printf_unfiltered ("gdb: unknown target exception 0x%08lx at %s\n",
	current_event.u.Exception.ExceptionRecord.ExceptionCode,
d1253 3
a1255 2
  DEBUG_EVENTS (("ContinueDebugEvent (cpid=%ld, ctid=%lx, %s);\n",
		  current_event.dwProcessId, current_event.dwThreadId,
d1302 2
a1303 2
      error (_("OpenProcess call failed, GetLastError = %lud"),
       GetLastError ());
d1462 1
a1462 1
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%x code=%s)\n",
d1491 1
a1491 1
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%x code=%s)\n",
d1505 1
a1505 1
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%x code=%s)\n",
d1527 1
a1527 1
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%x code=%s)\n",
d1547 1
a1547 1
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%x code=%s)\n",
d1561 1
a1561 1
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%x code=%s)\n",
d1574 1
a1574 1
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%x code=%s)\n",
d1596 1
a1596 1
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%x code=%s)\n",
d1608 5
a1612 5
      printf_unfiltered ("gdb: kernel event for pid=%ld tid=%ld\n",
			 (DWORD) current_event.dwProcessId,
			 (DWORD) current_event.dwThreadId);
      printf_unfiltered ("                 unknown event code %ld\n",
			 current_event.dwDebugEventCode);
d1870 2
a1871 2
      error (_("Can't detach process %lu (error %lu)"),
	     current_event.dwProcessId, GetLastError ());
d1881 2
a1882 2
      printf_unfiltered ("Detaching from program: %s, Pid %lu\n", exec_file,
			 current_event.dwProcessId);
d2269 1
a2269 1
    error (_("Error creating process %s, (error %d)."),
@


1.239
log
@[native x86 GNU/Linux] Access debug register mirror from the corresponding process.

While reviewing the native AArch64 patch, I noticed a problem:

On 02/06/2013 08:46 PM, Pedro Alves wrote:
>
>> > +static void
>> > +aarch64_linux_prepare_to_resume (struct lwp_info *lwp)
>> > +{
>> > +  struct arch_lwp_info *info = lwp->arch_private;
>> > +
>> > +  /* NULL means this is the main thread still going through the shell,
>> > +     or, no watchpoint has been set yet.  In that case, there's
>> > +     nothing to do.  */
>> > +  if (info == NULL)
>> > +    return;
>> > +
>> > +  if (DR_HAS_CHANGED (info->dr_changed_bp)
>> > +      || DR_HAS_CHANGED (info->dr_changed_wp))
>> > +    {
>> > +      int tid = GET_LWP (lwp->ptid);
>> > +      struct aarch64_debug_reg_state *state = aarch64_get_debug_reg_state ();
> Hmm.  This is always fetching the debug_reg_state of
> the current inferior, but may not be the inferior of lwp.
> I see the same bug on x86.  Sorry about that.  I'll fix it.

A natural fix would be to make xxx_get_debug_reg_state take an
inferior argument, but that doesn't work because of the case where we
detach breakpoints/watchpoints from the child fork, at a time there's
no inferior for the child fork at all.  We do a nasty hack in
i386_inferior_data_get, but that relies on all callers pointing the
current inferior to the correct inferior, which isn't actually being
done by all callers, and I don't think we want to enforce that -- deep
in the bowls of linux-nat.c, there are many cases we resume lwps
behind the scenes, and it's be better to not have that code rely on
global state (as it doesn't today).

The fix is to decouple the watchpoints code from inferiors, making it
track target processes instead.  This way, we can freely keep track of
the watchpoint mirrors for these processes behind the core's back.
Checkpoints also play dirty tricks with swapping the process behind
the inferior, so they get special treatment too in the patch (which
just amounts to calling a new hook).  Instead of the old hack in
i386_inferior_data_get, where we returned a copy of the current
inferior's debug registers mirror, as soon as we detect a fork in the
target, we copy the debug register mirror from the parent to the child
process.

I don't have an old kernel handy to test, but I stepped through gdb doing
the watchpoint removal in the fork child in the watchpoint-fork test
seeing that the debug registers end up cleared in the child.

I didn't find the need for linux_nat_iterate_watchpoint_lwps.  If
we use plain iterate_over_lwps instead, what happens is that
when removing watchpoints, that iterate_over_lwps doesn't actually
iterate over anything, since the fork child is not added to the
lwp list until later, at detach time, in linux_child_follow_fork.
And if we don't iterate over that lwp, we don't mark its debug
registers as needing update.  But linux_child_follow_fork takes
care of doing that explicitly:

	  child_lp = add_lwp (inferior_ptid);
	  child_lp->stopped = 1;
	  child_lp->last_resume_kind = resume_stop;
	  make_cleanup (delete_lwp_cleanup, child_lp);

	  /* CHILD_LP has new PID, therefore linux_nat_new_thread is not called for it.
	     See i386_inferior_data_get for the Linux kernel specifics.
	     Ensure linux_nat_prepare_to_resume will reset the hardware debug
	     registers.  It is done by the linux_nat_new_thread call, which is
	     being skipped in add_lwp above for the first lwp of a pid.  */
	  gdb_assert (num_lwps (GET_PID (child_lp->ptid)) == 1);
	  if (linux_nat_new_thread != NULL)
	    linux_nat_new_thread (child_lp);

	  if (linux_nat_prepare_to_resume != NULL)
	    linux_nat_prepare_to_resume (child_lp);
	  ptrace (PTRACE_DETACH, child_pid, 0, 0);

so unless I'm missing something (quite possible) it ends up all
the same.  But, the !detach-on-fork, and the "follow-fork child" paths
should also call linux_nat_new_thread, and they don't presently.  It
seems to me in those cases we're not clearing debug regs correctly
when that's needed.  Instead of copying that bit that works around
add_lwp bypassing the linux_nat_new_thread call, I thought it'd
be better to add an add_initial_lwp call to be used in the case we
really need to bypass linux_nat_new_thread, and make
add_lwp always call linux_nat_new_thread.

i386_cleanup_dregs is rewritten to forget about the current process
debug mirrors, which takes cares of other i386 ports.  Only a couple
of extra tweaks here and there were needed, as some targets wheren't
actually calling i386_cleanup_dregs.

Tested on Fedora 17 x86_64 -m64/-m32.

GDBserver already fetches the i386_debug_reg_state from the right
process, and, it doesn't handle forks at all, so no fix is needed over
there.

gdb/
2013-02-13  Pedro Alves  <palves@@redhat.com>

	* amd64-linux-nat.c (update_debug_registers_callback):
	Update comment.
	(amd64_linux_dr_set_control, amd64_linux_dr_set_addr): Use
	iterate_over_lwps.
	(amd64_linux_prepare_to_resume): Pass the lwp's pid to
	i386_debug_reg_state.
	(amd64_linux_new_fork): New function.
	(_initialize_amd64_linux_nat): Install amd64_linux_new_fork as
	linux_nat_new_fork hook, and i386_forget_process as
	linux_nat_forget_process hook.
	* i386-linux-nat.c (update_debug_registers_callback):
	Update comment.
	(amd64_linux_dr_set_control, amd64_linux_dr_set_addr): Use
	iterate_over_lwps.
	(i386_linux_prepare_to_resume): Pass the lwp's pid to
	i386_debug_reg_state.
	(i386_linux_new_fork): New function.
	(_initialize_i386_linux_nat): Install i386_linux_new_fork as
	linux_nat_new_fork hook, and i386_forget_process as
	linux_nat_forget_process hook.
	* i386-nat.c (i386_init_dregs): Delete.
	(i386_inferior_data, struct i386_inferior_data):
	Delete.
	(struct i386_process_info): New.
	(i386_process_list): New global.
	(i386_find_process_pid, i386_add_process, i386_process_info_get):
	New functions.
	(i386_inferior_data_get): Delete.
	(i386_process_info_get): New function.
	(i386_debug_reg_state): New parameter 'pid'.  Reimplement.
	(i386_forget_process): New function.
	(i386_cleanup_dregs): Rewrite.
	(i386_update_inferior_debug_regs, i386_insert_watchpoint)
	(i386_remove_watchpoint, i386_region_ok_for_watchpoint)
	(i386_stopped_data_address, i386_insert_hw_breakpoint)
	(i386_remove_hw_breakpoint): Adjust to pass the current process id
	to i386_debug_reg_state.
	(i386_use_watchpoints): Don't register inferior data.
	* i386-nat.h (i386_debug_reg_state): Add new 'pid' parameter, and
	adjust comment.
	(i386_forget_process): Declare.
	* linux-fork.c (delete_fork): Call linux_nat_forget_process.
	* linux-nat.c (linux_nat_new_fork, linux_nat_forget_process_hook):
	New static globals.
	(linux_child_follow_fork): Don't call linux_nat_new_thread here.
	(add_initial_lwp): New, factored out from ...
	(add_lwp): ... this.  Don't check the number of lwps before
	calling linux_nat_new_thread.
	(linux_nat_iterate_watchpoint_lwps): Delete.
	(linux_nat_attach): Use add_initial_lwp instead of add_lwp.
	(linux_handle_extended_wait): Call the linux_nat_new_fork hook on
	forks and vforks.
	(linux_nat_wait_1): Use add_initial_lwp instead of add_lwp for the
	initial lwp.
	(linux_nat_kill, linux_nat_mourn_inferior): Call
	linux_nat_forget_process.
	(linux_nat_set_new_fork, linux_nat_set_forget_process)
	(linux_nat_forget_process): New functions.
	* linux-nat.h (linux_nat_iterate_watchpoint_lwps_ftype): Delete
	type.
	(linux_nat_iterate_watchpoint_lwps): Delete declaration.
	(linux_nat_new_fork_ftype, linux_nat_forget_process_ftype): New
	types.
	(linux_nat_set_new_fork, linux_nat_set_forget_process)
	(linux_nat_forget_process): New declarations.

	* amd64fbsd-nat.c (super_mourn_inferior): New global.
	(amd64fbsd_mourn_inferior): New function.
	(_initialize_amd64fbsd_nat): Override to_mourn_inferior.
	* windows-nat.c (windows_detach): Call i386_cleanup_dregs.
@
text
@d2316 2
a2317 2
      DEBUG_MEM (("gdb: write target memory, %d bytes at 0x%08lx\n",
		  len, (DWORD) (uintptr_t) memaddr));
d2327 2
a2328 2
      DEBUG_MEM (("gdb: read target memory, %d bytes at 0x%08lx\n",
		  len, (DWORD) (uintptr_t) memaddr));
@


1.238
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d1884 1
@


1.237
log
@	* windows-nat.c (windows_xfer_shared_libraries): Avoid
	memory leak when OFFSET >= LEN_AVAIL.
@
text
@d3 1
a3 1
   Copyright (C) 1995-2012 Free Software Foundation, Inc.
@


1.236
log
@	ARI fixes: Avoid sprintf function use rule.
	* charset.c (convert_between_encodings): Use xsnprintf.
	* cli-out.c (cli_field_int): Likewise.
	* cp-namespace.c (cp_lookup_nested_symbol): Likewise.
	* expprint.c (op_name_standard): Likewise.
	* frv-tdep.c (set_variant_num_gprs): Likewise.
	(set_variant_num_fprs): Likewise.
	* m68hc11-tdep.c (m68hc11_initialize_register_info): Likewise.
	* nto-tdep.c (nto_find_and_open_solib): Likewise.
	(nto_init_solib_absolute_prefix): Likewise.
	* source.c (init_source_path): Likewise.
	(print_source_lines_base): Likewise.
	* valprint.c (print_wchar): Likewise.
	* mi/mi-out.c (mi_field_int): Likewise.
	windows-nat.c (windows_pid_to_exec_file): Likewise.
	(windows_create_inferior): Likewise.
	(_initialize_check_for_gdb_ini): Likewise.
@
text
@d2414 7
a2420 5
    return 0;

  if (len > len_avail - offset)
    len = len_avail - offset;
  memcpy (readbuf, buf + offset, len);
@


1.235
log
@	* gdbarch.sh (target_gdbarch): Remove macro.
	(get_target_gdbarch): Rename to target_gdbarch.
	* gdbarch.c, gdbarch.h: Rebuild.
	* ada-tasks.c, aix-thread.c, amd64-linux-nat.c, arch-utils.c,
	arm-tdep.c, auxv.c, breakpoint.c, bsd-uthread.c, corefile.c,
	darwin-nat-info.c, dcache.c, dsrec.c, exec.c, fbsd-nat.c,
	filesystem.c, gcore.c, gnu-nat.c, i386-darwin-nat.c, i386-nat.c,
	ia64-vms-tdep.c, inf-ptrace.c, infcmd.c, jit.c, linux-nat.c,
	linux-tdep.c, linux-thread-db.c, m32r-rom.c, memattr.c,
	mep-tdep.c, microblaze-tdep.c, mips-linux-nat.c,
	mips-linux-tdep.c, mips-tdep.c, monitor.c, moxie-tdep.c,
	nto-procfs.c, nto-tdep.c, ppc-linux-nat.c, proc-service.c,
	procfs.c, progspace.c, ravenscar-thread.c, record.c,
	remote-m32r-sdi.c, remote-mips.c, remote-sim.c, remote.c,
	rl78-tdep.c, rs6000-nat.c, rx-tdep.c, s390-nat.c, sol-thread.c,
	solib-darwin.c, solib-dsbt.c, solib-frv.c, solib-ia64-hpux.c,
	solib-irix.c, solib-pa64.c, solib-som.c, solib-spu.c,
	solib-sunos.c, solib-svr4.c, solib.c, spu-linux-nat.c,
	spu-multiarch.c, spu-tdep.c, symfile-mem.c, symfile.c, symtab.c,
	target-descriptions.c, target.c, target.h, tracepoint.c,
	windows-nat.c, windows-tdep.c, xcoffsolib.c, cli/cli-dump.c,
	common/agent.c, mi/mi-interp.c, python/py-finishbreakpoint.c,
	python/py-inferior.c, python/python.c: Update.
@
text
@d1898 2
a1899 1
  sprintf (procexe, "/proc/%u/exe", pid);
d2097 4
a2100 4
      cygallargs = (char *)
	alloca (sizeof (" -c 'exec  '") + strlen (exec_file)
				    + strlen (allargs) + 2);
      sprintf (cygallargs, " -c 'exec %s %s'", exec_file, allargs);
d2728 3
a2730 2
	  sprintf (newini, "%.*s.gdbinit",
	    (int) (len - (sizeof ("gdb.ini") - 1)), oldini);
@


1.234
log
@[Windows] run program with space in path to exe.

The following works...

    % gdb c:\path to exe\foo.exe
    (gdb) start

... unless a file or directory called "c:\path" or "c:\path to" exist.
This is what happens in the latter case:

    (gdb) start
    [...]
    Error creating process C:\path to exe\foo.exe (error 193).

This is because we are calling CreateProcess (et al) without specifying
the lpApplicationName, so Windows determines the name of the executable
using the second argument, which is the entire command line.  This
command line is a space-separated list of tokens, so the space in
the path to the executable which potentially creates an ambiguity.
The ambiguity is automatically resolved unless we're in the situation
above.

The solution, as suggested by the MSDN documentation for CreateProcess
is to quote the executable name.

gdb/ChangeLog:

        * windows-nat.c (windows_create_inferior) [!__CYGWIN__]:
        New local variable args_len.
        Quote the name of the executable when computing the command line.
@
text
@d2407 1
a2407 1
				 target_gdbarch, &obstack);
@


1.233
log
@	* procfs.c: Add gdb_bfd header.
	* rs6000-nat.c: Likewise.
	* solib-pa64.c: Likewise.
	* spu-linux-nat.c: Likewise.
	* windows-nat.c: Likewise.
@
text
@d2039 1
d2192 7
a2198 4
  args = alloca (strlen (toexec) + strlen (allargs) + 2);
  strcpy (args, toexec);
  strcat (args, " ");
  strcat (args, allargs);
@


1.232
log
@	* windows-nat.c (windows_make_so): Use gdb_bfd_open.
	* symfile.c (bfd_open_maybe_remote): Use gdb_bfd_open.
	(symfile_bfd_open): Likewise.
	(generic_load): Likewise.
	* solib.c (solib_bfd_fopen): Use gdb_bfd_open.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Use
	gdb_bfd_open.
	* solib-darwin.c (darwin_solib_get_all_image_info_addr_at_init):
	Use gdb_bfd_open.
	* rs6000-nat.c (add_vmap): Use gdb_bfd_open.
	* remote-mips.c (mips_load_srec): Use gdb_bfd_open.
	(pmon_load_fast): Likewise.
	* remote-m32r-sdi.c (m32r_load): Use gdb_bfd_open.
	* procfs.c (insert_dbx_link_bpt_in_file): Use gdb_bfd_open.
	* machoread.c (macho_symfile_read_all_oso): Use gdb_bfd_open.
	(macho_check_dsym): Likewise.
	* m32r-rom.c (m32r_load): Use gdb_bfd_open.
	(m32r_upload_command): Likewise.
	* gdb_bfd.h (gdb_bfd_cache): Declare.
	* gdb_bfd.c (struct gdb_bfd_data): New.
	(gdb_bfd_cache): New global.
	(struct gdb_bfd_cache_search): New.
	(hash_bfd): New function.
	(eq_bfd): Likewise.
	(gdb_bfd_open): Likewise.
	(gdb_bfd_ref): Allocate a gdb_bfd_data and attach to the BFD.
	(gdb_bfd_unref): Remove closed BFD from cache.  Update for
	gdb_bfd_data.
	* exec.c (exec_file_attach): Use gdb_bfd_open.
	* dsrec.c (load_srec): Use gdb_bfd_open.
@
text
@d52 1
@


1.231
log
@	* cli/cli-dump.c (bfd_openr_with_cleanup): Use gdb_bfd_openr.
	(bfd_openw_with_cleanup): Use gdb_bfd_openw.
	* corelow.c (core_open): Use gdb_bfd_fopen.
	* dsrec.c (load_srec): Use gdb_bfd_openr.
	* exec.c (exec_file_attach): Use gdb_bfd_fopen.
	* gcore.c (gcore_memory_sections): Use gdb_bfd_openw.
	* gdb_bfd.c (gdb_bfd_fopen, gdb_bfd_openr, gdb_bfd_openw)
	(gdb_bfd_openr_iovec, gdb_bfd_openr_next_archived_file)
	(gdb_bfd_fdopenr): New functions.
	* gdb_bfd.h (gdb_bfd_fopen, gdb_bfd_openr, gdb_bfd_openw)
	(gdb_bfd_openr_iovec, gdb_bfd_openr_next_archived_file)
	(gdb_bfd_fdopenr): Declare.
	* jit.c (bfd_open_from_target_memory): Use gdb_bfd_openr_iovec.
	* m32-rom.c (m32r_load, m32r_upload_command): Use gdb_bfd_openr.
	* machoread.c (macho_symfile_read_all_oso): Use gdb_bfd_openr,
	gdb_bfd_openr_next_archived_file.
	(macho_check_dsym): Use gdb_bfd_openr.
	(macho_add_oso_symfile): Don't call gdb_bfd_stash_filename.
	* procfs.c (insert_dbx_link_bpt_in_file): Use gdb_bfd_fdopenr.
	* remote-m32r-sdi.c (m32r_load): Use gdb_bfd_openr.
	* remote-mips.c (mips_load_srec, pmon_load_fast): Use
	gdb_bfd_openr.
	* remote.c (remote_bfd_open): Use gdb_bfd_openr_iovec.
	* rs6000-nat.c (add_vmap): Use gdb_bfd_openr, gdb_bfd_fdopenr,
	gdb_bfd_openr_next_archived_file.
	* solib-darwin.c (darwin_solib_get_all_image_info_addr_at_init):
	Use gdb_bfd_openr.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Use
	gdb_bfd_openr.
	* solib-spu.c (spu_bfd_fopen): Use gdb_bfd_openr_iovec.
	* solib.c (solib_bfd_fopen): Use gdb_bfd_fopen.
	* spu-linux-nat.c (spu_bfd_open): Use gdb_bfd_openr_iovec.
	* symfile.c (bfd_open_maybe_remote): Use gdb_bfd_openr.
	(symfile_bfd_open): Use gdb_bfd_fopen.
	(generic_load): Use gdb_bfd_openr.
	* windows-nat.c (windows_make_so): Use gdb_bfd_openr.
@
text
@d755 1
a755 1
      abfd = gdb_bfd_openr (so->so_name, "pei-i386");
@


1.230
log
@	* bfd-target.c (target_bfd_reopen): Update.
	* cli/cli-dump.c (bfd_openr_with_cleanup)
	(bfd_openw_with_cleanup): Update.
	* corelow.c (core_open): Update.
	* dsrec.c (load_srec): Update.
	* exec.c (exec_file_attach): Update.
	* gcore.c (create_gcore_bfd): Update.
	* gdb_bfd.c (gdb_bfd_ref): Return void.
	(gdb_bfd_open): Update.
	* gdb_bfd.h (gdb_bfd_ref): Return void.
	Update comments.
	* jit.c (jit_bfd_try_read_symtab): Update.
	* m32r-rom.c (m32r_load, m32r_upload_command): Update.
	* machoread.c (macho_symfile_read_all_oso): Update.
	(macho_check_dsym): Update.
	* procfs.c (insert_dbx_link_bpt_in_file): Update.
	* remote-m32r-sdi.c (m32r_load): Update.
	* remote-mips.c (mips_load_srec, pmon_load_fast): Update.
	* rs6000-nat.c (add_vmap): Update.
	* solib-darwin.c (darwin_solib_get_all_image_info_addr_at_init):
	Update.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Update.
	* solib-spu.c (spu_bfd_open): Update.
	* solib.c (solib_bfd_fopen, solib_read_symbols): Update.
	* spu-linux-nat.c (spu_bfd_open): Update.
	* symfile.c (bfd_open_maybe_remote, symfile_bfd_open)
	(generic_load): Update.
	* windows-nat.c (windows_make_so): Update.
@
text
@d755 1
a755 2
      abfd = bfd_openr (so->so_name, "pei-i386");
      gdb_bfd_ref (abfd);
@


1.229
log
@	* dwarf2read.c (try_open_dwo_file): Use gdb_bfd_ref and
	gdb_bfd_unref.
	(free_dwo_file): Use gdb_bfd_unref.
	* cli/cli-dump.c: Include gdb_bfd.h.
	(bfd_openw_with_cleanup): Use gdb_bfd_ref.
	(bfd_openr_with_cleanup): Likewise.
	* windows-nat.c (windows_make_so): Use gdb_bfd_ref,
	gdb_bfd_unref.
	* utils.c: Include gdb_bfd.h.
	(do_bfd_close_cleanup): Use gdb_bfd_unref.
	* symfile.c: Include gdb_bfd.h.
	(separate_debug_file_exists): Use gdb_bfd_unref.
	(bfd_open_maybe_remote): Use gdb_bfd_ref.
	(symfile_bfd_open): Use gdb_bfd_ref, gdb_bfd_unref.
	(generic_load): Use gdb_bfd_ref.
	(reread_symbols): Use gdb_bfd_unref.
	* symfile-mem.c: Include gdb_bfd.h.
	(symbol_file_add_from_memory): Use make_cleanup_bfd_close.
	* spu-linux-nat.c (spu_bfd_open): Use gdb_bfd_ref, gdb_bfd_unref.
	* solib.c: Include gdb_bfd.h.
	(solib_bfd_fopen): Use gdb_bfd_ref.
	(solib_bfd_open): Use gdb_bfd_unref.
	(free_so_symbols): Use gdb_bfd_unref.
	(reload_shared_libraries_1): Use gdb_bfd_unref.
	* solib-spu.c: Include gdb_bfd.h.
	(spu_bfd_fopen): Use gdb_bfd_ref, gdb_bfd_unref.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Use gdb_bfd_ref,
	gdb_bfd_unref.
	* solib-frv.c: Include gdb_bfd.h.
	(enable_break2): Use gdb_bfd_unref.
	* solib-dsbt.c: Include gdb_bfd.h.
	(enable_break2): Use gdb_bfd_unref.
	* solib-darwin.c: Include gdb_bfd.h.
	(darwin_solib_get_all_image_info_addr_at_init): Use gdb_bfd_ref,
	gdb_bfd_unref.
	(darwin_bfd_open): Use gdb_bfd_unref.
	* rs6000-nat.c (add_vmap): Use gdb_bfd_ref, gdb_bfd_unref.
	* remote-mips.c: Include gdb_bfd.h.
	(mips_load_srec): Use gdb_bfd_ref.
	(pmon_load_fast): Use gdb_bfd_ref.
	* remote-m32r-sdi.c: Include gdb_bfd.h.
	(m32r_load): Use gdb_bfd_ref.
	* record.c: Include gdb_bfd.h.
	(record_save_cleanups): Use gdb_bfd_unref.
	(cmd_record_save): Use gdb_bfd_unref.
	* procfs.c (insert_dbx_link_bpt_in_file): Use gdb_bfd_ref,
	gdb_bfd_unref.
	* objfiles.h (gdb_bfd_close_or_warn): Remove.
	(gdb_bfd_ref, gdb_bfd_unref): Move to gdb_bfd.h.
	* objfiles.c: Include gdb_bfd.h.
	(free_objfile): Use gdb_bfd_unref.
	(gdb_bfd_close_or_warn, gdb_bfd_ref, gdb_bfd_unref): Move to
	gdb_bfd.c.
	* machoread.c (macho_add_oso_symfile): Use gdb_bfd_unref.
	(macho_symfile_read_all_oso): Use gdb_bfd_ref, gdb_bfd_unref.
	(macho_check_dsym): Likewise.
	* m32r-rom.c: Include gdb_bfd.h.
	(m32r_load): Use gdb_bfd_ref.
	(m32r_upload_command): Use gdb_bfd_ref.
	* jit.c: Include gdb_bfd.h.
	(jit_bfd_try_read_symtab): Use gdb_bfd_ref, gdb_bfd_unref.
	* gdb_bfd.h: New file.
	* gdb_bfd.c: New file.
	* gcore.c: Include gdb_bfd.h.
	(create_gcore_bfd): Use gdb_bfd_ref.
	(do_bfd_delete_cleanup): Use gdb_bfd_unref.
	(gcore_command): Use gdb_bfd_unref.
	* exec.c: Include gdb_bfd.h.
	(exec_close): Use gdb_bfd_unref.
	(exec_close_1): Use gdb_bfd_unref.
	(exec_file_attach): Use gdb_bfd_ref.
	* elfread.c: Include gdb_bfd.h.
	(build_id_verify): Use gdb_bfd_unref.
	* dsrec.c: Include gdb_bfd.h.
	(load_srec): Use gdb_bfd_ref.
	* corelow.c: Include gdb_bfd.h.
	(core_close): Use gdb_bfd_unref.
	(core_open): Use gdb_bfd_ref.
	* bfd-target.c: Include gdb_bfd.h.
	(target_bfd_xclose): Use gdb_bfd_unref.
	(target_bfd_reopen): Use gdb_bfd_ref.
	* Makefile.in (SFILES): Add gdb_bfd.c.
	(HFILES_NO_SRCDIR): Add gdb_bfd.h.
	(COMMON_OBS): Add gdb_bfd.o.
@
text
@d755 2
a756 1
      abfd = gdb_bfd_ref (bfd_openr (so->so_name, "pei-i386"));
@


1.228
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        * gdb/signals.def: Replace TARGET_SIGNAL_ with GDB_SIGNAL_
	throughout.

sim/arm/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/avr/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/cr16/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/d10v/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/erc32/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/m32c/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/ppc/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rl78/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rx/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.
@
text
@d755 1
a755 1
      abfd = bfd_openr (so->so_name, "pei-i386");
d765 1
a765 1
	  bfd_close (abfd);
d776 1
a776 1
      bfd_close (abfd);
@


1.227
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.
@
text
@d179 1
a179 1
static enum gdb_signal last_sig = TARGET_SIGNAL_0;
d262 6
a267 6
  {EXCEPTION_ACCESS_VIOLATION, TARGET_SIGNAL_SEGV},
  {STATUS_STACK_OVERFLOW, TARGET_SIGNAL_SEGV},
  {EXCEPTION_BREAKPOINT, TARGET_SIGNAL_TRAP},
  {DBG_CONTROL_C, TARGET_SIGNAL_INT},
  {EXCEPTION_SINGLE_STEP, TARGET_SIGNAL_TRAP},
  {STATUS_FLOAT_DIVIDE_BY_ZERO, TARGET_SIGNAL_FPE},
d1130 1
a1130 1
      ourstatus->value.sig = TARGET_SIGNAL_SEGV;
d1156 1
a1156 1
      ourstatus->value.sig = TARGET_SIGNAL_SEGV;
d1160 1
a1160 1
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
d1164 1
a1164 1
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
d1168 1
a1168 1
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
d1172 1
a1172 1
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
d1176 1
a1176 1
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
d1180 1
a1180 1
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
d1184 1
a1184 1
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
d1188 1
a1188 1
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
d1192 1
a1192 1
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
d1196 1
a1196 1
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
d1200 1
a1200 1
      ourstatus->value.sig = TARGET_SIGNAL_TRAP;
d1204 1
a1204 1
      ourstatus->value.sig = TARGET_SIGNAL_INT;
d1208 1
a1208 1
      ourstatus->value.sig = TARGET_SIGNAL_INT;
d1212 1
a1212 1
      ourstatus->value.sig = TARGET_SIGNAL_TRAP;
d1216 1
a1216 1
      ourstatus->value.sig = TARGET_SIGNAL_ILL;
d1220 1
a1220 1
      ourstatus->value.sig = TARGET_SIGNAL_ILL;
d1224 1
a1224 1
      ourstatus->value.sig = TARGET_SIGNAL_ILL;
d1234 1
a1234 1
      ourstatus->value.sig = TARGET_SIGNAL_UNKNOWN;
d1327 1
a1327 1
  if (sig != TARGET_SIGNAL_0)
d1361 1
a1361 1
  last_sig = TARGET_SIGNAL_0;
d1443 1
a1443 1
  last_sig = TARGET_SIGNAL_0;
d1703 1
a1703 1
  last_sig = TARGET_SIGNAL_0;
d1742 1
a1742 1
      if (tp->suspend.stop_signal != TARGET_SIGNAL_TRAP)
d1863 1
a1863 1
  windows_resume (ops, ptid, 0, TARGET_SIGNAL_0);
@


1.226
log
@Segment register reading on Windows targets.

This patch makes sure that the value of segment registers are
read properly as 16bit values on Windows.

gdb/ChangeLog:

        * windows-nat.h (segment_register_p_ftype): New typedef.
        (windows_set_segment_register_p): Add declaration.
        * windows-nat.c (segment_register_p): New static global.
        (windows_set_segment_register_p): New function.
        (do_windows_fetch_inferior_registers): Add special handling
        for segment registers.
        * amd64-windows-nat.c: #include "amd64-tdep.h".
        (amd64_windows_segment_register_p): New function.
        (_initialize_amd64_windows_nat): Call windows_set_segment_register_p.
        * i386-windows-nat.c: #include "i386-tdep.h".
        (i386_windows_segment_register_p): New function.
        (_initialize_i386_windows_nat): Call windows_set_segment_register_p.
@
text
@d179 1
a179 1
static enum target_signal last_sig = TARGET_SIGNAL_0;
d256 1
a256 1
    enum target_signal us;
d969 1
a969 1
      int gotasig = target_signal_from_host (sig);
d1314 1
a1314 1
		ptid_t ptid, int step, enum target_signal sig)
@


1.225
log
@gdb/
	Fix -Wmissing-prototypes build.
	* windows-nat.c (dll_symbol_command, ctrl_c_handler): Make them static.
	(_initialize_windows_nat, _initialize_check_for_gdb_ini)
	(_initialize_loadable): New prototypes.
@
text
@d246 4
d279 8
d471 8
@


1.224
log
@	* blockframe.c (find_pc_partial_function_gnu_ifunc): Change type of
	"name" parameter to const char ** from char **.  All callers updated.
	(find_pc_partial_function): Ditto.
	(cache_pc_function_name): Change type to const char * from char *.
	* symtab.h ((find_pc_partial_function_gnu_ifunc): Update.
	(find_pc_partial_function): Update.
	* alpha-tdep.h (struct gdbarch_tdep, member pc_in_sigtramp): Change
	type of "name" parameter to const char * from char *.
	All uses updated.
	* arch-utils.c (generic_in_solib_return_trampoline): Change
	type of "name" parameter to const char * from char *.
	* arch-utils.h (generic_in_solib_return_trampoline): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Change
	type of "name" parameter to const char * from char *.
	* gdbarch.sh (in_solib_return_trampoline): Ditto.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Update.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Update.
	* m32r-linux-tdep.c (m32r_linux_pc_in_sigtramp): Change
	type of "name" parameter to const char * from char *.
	* skip.c (skip_function_pc): Ditto.
	* sparc-sol2-tdep.c (sparc_sol2_pc_in_sigtramp): Ditto.
	* sparc-tdep.h (sparc_sol2_pc_in_sigtramp): Update.
	* sparc64fbsd-tdep.c (sparc64fbsd_pc_in_sigtramp): Ditto.
	* sparc64nbsd-tdep.c (sparc64nbsd_pc_in_sigtramp): Ditto.
	* sparc64obsd-tdep.c (sparc64obsd_pc_in_sigtramp): Ditto.
	* sparcnbsd-tdep.c (sparc32nbsd_pc_in_sigtramp): Ditto.
	* sparcobsd-tdep.c (sparc32obsd_pc_in_sigtramp): Ditto.
	* nbsd-tdep.c (nbsd_pc_in_sigtramp): Similary for "func_name".
	* nbsd-tdep.h (nbsd_pc_in_sigtramp): Update.
@
text
@d894 1
a894 1
void
d1389 1
a1389 1
BOOL WINAPI
d2515 3
d2677 3
d2773 3
d2778 1
@


1.223
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d1121 1
a1121 1
	char *fn;
@


1.222
log
@	* windows-nat.c (cygwin_get_dr, cygwin_get_dr7): Add missing
	prototypes.
@
text
@d3 1
a3 2
   Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
   2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.221
log
@gdb/
2011-12-14  Pedro Alves  <pedro@@codesourcery.com>

	PR threads/10729

	* linux-nat.c (linux_nat_new_thread): Change parameter to an lwp
	pointer.
	(linux_nat_prepare_to_resume): New global.
	(lwp_free): New.
	(purge_lwp_list): Use it.
	(add_lwp): Call linux_nat_new_thread even on the first LWP.
	Adjust to interface change.
	(delete_lwp): Call lwp_free instead of xfree.
	(detach_callback, linux_nat_detach, resume_lwp, linux_nat_resume)
	(linux_handle_syscall_trap, linux_handle_extended_wait)
	(linux_nat_filter_event, resume_stopped_resumed_lwps): Call
	linux_nat_prepare_to_resume before resuming.
	(linux_stop_lwp): New.
	(linux_nat_set_new_thread): Adjust.
	(linux_nat_set_prepare_to_resume): New.
	* linux-nat.h (struct arch_lwp_info): Forward declare.
	(struct lwp_info) <arch_private>: New field.
	(linux_stop_lwp): Declare.
	(linux_nat_set_new_thread): Adjust.
	(linux_nat_set_prepare_to_resume): New.

	* i386-nat.c (DR_NADDR, DR_STATUS, DR_CONTROL)
	(struct i386_debug_reg_state): Move to i386-nat.h.
	(dr_mirror): Comment.
	(i386_debug_reg_state): New.
	(i386_update_inferior_debug_regs): Simplify.
	(i386_stopped_data_address): Use the debug register state from the
	inferior, not from the local cache.
	* i386-nat.h (struct i386_dr_low_type): Delete reset_addr and
	unset_status fields.  New get_addr and get_control fields.
	(DR_FIRSTADDR, DR_LASTADDR, DR_CONTROL): Moved from i386-nat.c.
	(DR_NADDR, DR_STATUS): New.
	(struct i386_debug_reg_state): Moved from i386-nat.c.

	* amd64-linux-nat.c (struct arch_lwp_info): New.
	(amd64_linux_dr): Delete global.
	(amd64_linux_dr_get_addr): New.
	(amd64_linux_dr_get_control): New.
	(amd64_linux_dr_unset_status): Delete.
	(amd64_linux_dr_set_addr): Reimplement.
	(amd64_linux_dr_reset_addr): Delete.
	(update_debug_registers_callback): New.
	(amd64_linux_dr_set_control): Reimplement.
	(amd64_linux_dr_set_addr): Reimplement.
	(amd64_linux_prepare_to_resume): New.
	(amd64_linux_new_thread): Change parameter to an lwp pointer.
	Reimplement.
	(_initialize_amd64_linux_nat): No longer install
	i386_dr_low.reset_addr and i386_dr_low.unset_status.  Install
	amd64_linux_dr_get_control as i386_dr_low.get_control.  Install
	amd64_linux_dr_get_addr as i386_dr_low.get_addr.  Install
	amd64_linux_prepare_to_resume.
	* i386-linux-nat.c (DR_FIRSTADDR, DR_LASTADDR, DR_STATUS)
	(DR_CONTROL): Delete.
	(struct arch_lwp_info): New.
	(i386_linux_dr): Delete global.
	(i386_linux_dr_set_control): Reimplement.
	(i386_linux_dr_get_addr): New.
	(i386_linux_dr_set_addr): Reimplement.
	(i386_linux_dr_get_control): New.
	(update_debug_registers_callback): New.
	(i386_linux_dr_unset_status): Delete.
	(i386_linux_dr_set_addr): Reimplement.
	(i386_linux_prepare_to_resume): New.
	(i386_linux_new_thread): Change parameter to an lwp pointer.
	Reimplement.
	(_initialize_i386_linux_nat): No longer install
	i386_dr_low.reset_addr and i386_dr_low.unset_status.  Install
	i386_linux_dr_get_control as i386_dr_low.get_control.  Install
	i386_linux_dr_get_addr as i386_dr_low.get_addr.  Install
	i386_linux_prepare_to_resume.

	* arm-linux-nat.c (arm_linux_new_thread): Change parameter to an
	lwp pointer.  Adjust.
	* ia64-linux-nat.c (ia64_linux_new_thread): Likewise.
	* mips-linux-nat.c (mips_linux_new_thread): Likewise.
	* ppc-linux-nat.c (ppc_linux_new_thread): Likewise.
	* s390-nat.c (s390_fix_watch_points): Likewise.

	* i386-darwin-nat.c (DR_FIRSTADDR, DR_LASTADDR, DR_STATUS)
	(DR_CONTROL): Delete.
	(i386_darwin_dr_reset_addr): Delete.
	(i386_darwin_dr_get_addr): New.
	(i386_darwin_dr_get_control): New.
	* go32-nat.c
	(go32_get_dr7, go32_get_dr): New.
	(init_go32_ops): No longer install i386_dr_low.reset_addr.
	Install go32_get_dr7 as i386_dr_low.get_control.  Install
	go32_get_dr as i386_dr_low.get_addr.
	* i386bsd-nat.c (i386bsd_dr_get): New.
	(i386bsd_dr_reset_addr): Delete.
	(i386bsd_dr_get_addr): New.
	(i386bsd_dr_get_status): Use i386bsd_dr_get.
	(i386bsd_dr_get_control): New.
	* i386bsd-nat.h (i386bsd_dr_reset_addr): Delete.
	(i386bsd_dr_get_addr): New.
	(i386bsd_dr_get_control): New.
	* i386fbsd-nat.c (_initialize_i386fbsd_nat): No longer install
	i386_dr_low.reset_addr and i386_dr_low.unset_status.  Install
	i386bsd_dr_get_control as i386_dr_low.get_control.  Install
	i386bsd_dr_get_addr as i386_dr_low.get_addr.
	* windows-nat.c (init_windows_ops): No longer install
	i386_dr_low.reset_addr and i386_dr_low.unset_status.  Install
	cygwin_get_dr7 as i386_dr_low.get_control.  Install cygwin_get_dr
	as i386_dr_low.get_addr.
	(cygwin_get_dr): New.
	(cygwin_get_dr7): New.

gdb/testsuite/
2011-12-14  Pedro Alves  <pedro@@codesourcery.com>

	PR threads/10729

	* gdb.mi/watch-nonstop.c: New file.
 	* gdb.mi/mi-watch-nonstop.exp: New file.
@
text
@d176 1
d178 1
@


1.220
log
@	* windows-nat.c: Include wchar.h to avoid compiler warnings.
	(clear_win32_environment): New function for Cygwin to clear out
	Win32 environment.
	(windows_create_inferior): Prepare new environment from in_env
	for Cygwin, too.
@
text
@d2497 1
a2497 1
  i386_dr_low.reset_addr = NULL;
d2499 1
d2631 8
d2648 10
@


1.220.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 1
   Copyright (C) 1995-2012 Free Software Foundation, Inc.
@


1.219
log
@Support "set environment" and "unset environment" in MinGW builds.

	* windows-nat.c (env_sort) [!__CYGWIN__]: Function restored from
	before the change on 2006-12-09.
	(windows_create_inferior) [!__CYGWIN__]: Restore code that
	generates the environment block for CreateProcessA, modulo the
	Cygwin-specific parts that are not needed here.
@
text
@d43 1
d45 1
d1968 22
d2007 2
d2095 17
a2111 2
  /* Prepare the environment vars for CreateProcess.  */
  cygwin_internal (CW_SYNC_WINENV);
d2141 1
a2141 1
		       NULL,	/* environment */
d2145 12
@


1.218
log
@2011-05-09  Pedro Alves  <pedro@@codesourcery.com>

	* inferior.h (wait_for_inferior): Remove `thread_exec_as_sigtrap'
	parameter.
	* infrun.c (proceed, start_remote): Adjust.
	(wait_for_inferior): Remove `thread_exec_as_sigtrap' parameter,
	and adjust to not handle it.
	* solib-irix.c (irix_solib_create_inferior_hook): Adjust.
	* solib-osf.c (osf_solib_create_inferior_hook): Adjust.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Adjust.
	* solib-svr4.c (svr4_solib_create_inferior_hook): Adjust.
	* windows-nat.c (do_initial_windows_stuff): Adjust.
	* infcmd.c (attach_command): Adjust.
	(notice_new_inferior): Adjust.
@
text
@d1954 12
d1992 6
d2145 25
d2177 1
a2177 1
			NULL,	/* environment */
@


1.217
log
@gdb
	* windows-tdep.c (windows_xfer_shared_library):
	* windows-nat.c (get_module_name, windows_make_so):
	* v850-tdep.c (v850_handle_pushm):
	* utils.c (null_cleanup, gdb_realpath):
	* ui-out.c (get_next_header):
	* tracepoint.c (clear_traceframe_info):
	* symtab.c (lookup_symtab):
	* serial.h (struct serial_ops):
	* mipsread.c (read_alphacoff_dynamic_symtab):
	* infcmd.c (print_return_value):
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address):
	* f-exp.y (parse_number):
	* exceptions.c (catch_exceptions):
	* dummy-frame.c (dummy_frame_this_id):
	* defs.h (struct cleanup):
	* breakpoint.c (disable_breakpoints_in_unloaded_shlib):
	* arm-tdep.c (arm_push_dummy_call):
	* amd64-tdep.h (amd64_collect_xsave):
	* amd64-tdep.c (amd64_collect_xsave):
	* alpha-tdep.c (alpha_heuristic_frame_unwind_cache):
	* README (typing): Remove duplicate words.
	* cli/cli-decode.c (lookup_cmd_composition): Add comma.
	* infrun.c (siginfo_value_read): Fix typo.
	* solib-frv.c (frv_fdpic_find_global_pointer): Likewise.
	* top.c (source_line_number): Add comma.
gdb/doc
	* gdbint.texinfo (Register Information Functions): Remove
	duplicate "the".
	* gdb.texinfo (Emacs): Remove duplicate "to".
	(GDB/MI Variable Objects): Remove duplicate "the".
	(General Query Packets): Likewise.
gdb/testsuite
	* gdb.mi/mi-nsmoribund.exp:
	* gdb.hp/gdb.objdbg/objdbg01.exp:
	* gdb.base/structs.exp (test_struct_returns):
	* gdb.base/call-sc.exp (test_scalar_returns):
	* gdb.base/bigcore.exp: Remove duplicate words.
gdb/gdbserver
	* win32-low.c (handle_load_dll): Remove duplicate "the".
@
text
@d1717 1
a1717 1
      wait_for_inferior (0);
@


1.216
log
@	Remove support for old Cygwin 1.5 versions.
	* remote-fileio.c: Remove macros used to emulate new cygwin_conv_path
	function on old Cygwin version.
	* windows-nat.c: Remove cygwin version check and always define
	__USEWIDE for Cygwin compilation.
@
text
@d503 1
a503 1
/* Get the name of a given module at at given base address.  If base_address
d746 1
a746 1
      /* The symbols in a dll are offset by 0x1000, which is the the
@


1.215
log
@2011-03-23  Kai Tietz  <ktietz@@redhat.com>

	* breakpoint.c (clear_command): Use filename_cmp
	instead of strcmp for comparison.
	* buildsym.c (watch_main_source_file_lossage): Likewise.
	(patch_subfile_names): Use IS_DIR_SEPARATOR instead of
	checking just for slash.
	* dbxread.c (read_dbx_symtab): Use lbasename instead of
	strrchr and filename_cmp instead of strcmp for filenames.
	(add_old_header_file): Use filename_cmp
	instead of strcmp for comparison.
	* exec.c (exec_set_section_address): Likewise.
	* macrotab.c (macro_lookup_inclusion): Likewise.
	(macro_lookup_inclusion): Likewise.
	* elfread.c (_initialize_elfread): Likewise.
	(elfstab_offset_sections): Likewise.
	(elfstab_offset_sections): Use lbasename instead of
	strrchr.
	* mdebugread.c (parse_partial_symbols): Likewise.
	(arse_partial_symbols): Use filename_(n)cmp instead of
	str(n)cmp for comparison.
	* minsyms.c (lookup_minimal_symbol): Likewise.
	* psymtab.c (read_psymtabs_with_filename): Likewise.
	* solib.c (solib_read_symbols): Likewise.
	(reload_shared_libraries_1): Likewise.
	* symmisc.c (maintenance_print_symbols): Likewise.
	* symfile.c (separate_debug_file_exists): Likewise.
	(reread_symbols): Likewise.
	(find_separate_debug_file_by_debuglink): Likewise.
	* remote-fileio.c (remote_fileio_func_rename): Likewise.
	* source.c (add_path): Likewise.
	* symtab.c (filename_seen): Likewise.
	(file_matches): Likewise.
	(print_symbol_info): Likewise.
	(maybe_add_partial_symtab_filename): Likewise.
	(make_source_files_completion_list): Likewise.
	* xml-syscall.c (init_sysinfo): Likewise.
	* windows-nat.c (_initialize_check_for_gdb_ini): Use
	IS_DIR_SEPARATOR for checking for trailing path separator.
@
text
@a43 1
#include <cygwin/version.h>
a113 1
# if CYGWIN_VERSION_DLL_MAKE_COMBINED(CYGWIN_VERSION_API_MAJOR,CYGWIN_VERSION_API_MINOR) >= 181
a121 15
# else
#   define CCP_POSIX_TO_WIN_W 1
#   define CCP_WIN_W_TO_POSIX 3
#   define cygwin_conv_path(op, from, to, size)  \
         (op == CCP_WIN_W_TO_POSIX) ? \
         cygwin_conv_to_full_posix_path (from, to) : \
         cygwin_conv_to_win32_path (from, to)
    typedef char cygwin_buf_t;
    static DWORD WINAPI (*GetModuleFileNameEx) (HANDLE, HMODULE, LPSTR, DWORD);
#   define STARTUPINFO STARTUPINFOA
#   define CreateProcess CreateProcessA
#   define GetModuleFileNameEx_name "GetModuleFileNameExA"
#   define bad_GetModuleFileNameEx bad_GetModuleFileNameExA
#   define CW_SET_DOS_FILE_WARNING -1	/* no-op this for older Cygwin */
# endif
@


1.214
log
@	Fix ARI warnings about new lines at the end of messages, which
	are unneeded as there is a new line added at the end of the message
	automatically.
	* darwin-nat.c (darwin_stop_inferior): Ditto.
	* dec-thread.c (dec_thread_get_ada_task_ptid): Ditto.
	* dfp.c (decimal_to_number): Ditto.
	* exec.c (print_section_info): Ditto.
	* i386-darwin-nat.c (darwin_set_sstep): Ditto.
	* osdata.c (get_osdata): Ditto.
	* record.c (bfdcore_write): Ditto.
	* remote-mips.c (mips_readchar): Ditto.
	* remote.c (read_ptid): Ditto.
	* ser-mingw.c (ser_windows_raw): Ditto.
	* tracepoint.c (add_local_symbols): Ditto.
	* windows-nat.c (fake_create_process): Ditto.
@
text
@d49 1
d2590 1
a2590 1
      if (p > oldini && p[-1] != '/')
@


1.213
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* ui-file.c: Comment cleanup, mostly periods and spaces.
	* ui-file.h: Ditto.
	* ui-out.c: Ditto.
	* ui-out.h: Ditto.
	* utils.c: Ditto.
	* v850-tdep.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* value.h: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vax-tdep.c: Ditto.
	* vec.c: Ditto.
	* vec.h: Ditto.
	* version.h: Ditto.
	* windows-nat.c: Ditto.
	* windows-tdep.c: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xml-support.c: Ditto.
	* xstormy16-tdep.c: Ditto.
	* xtensa-tdep.c: Ditto.
	* xtensa-tdep.h: Ditto.
@
text
@d1292 1
a1292 1
      error (_("OpenProcess call failed, GetLastError = %lud\n"),
@


1.212
log
@run copyright.sh for 2011.
@
text
@d92 2
a93 1
static BOOL WINAPI (*GetCurrentConsoleFont) (HANDLE, BOOL, CONSOLE_FONT_INFO *);
d111 1
a111 1
/* The starting and ending address of the cygwin1.dll text segment. */
d117 2
a118 1
    static DWORD WINAPI (*GetModuleFileNameEx) (HANDLE, HMODULE, LPWSTR, DWORD);
d140 4
a143 2
static int have_saved_context;	/* True if we've saved context from a cygwin signal. */
static CONTEXT saved_context;	/* Containes the saved context from a cygwin signal. */
d147 1
a147 1
   headers in the first place since they were our own invention... */
d173 1
a173 1
   FIXME: This should be in a cygwin include file. */
d193 1
a193 1
/* Set if a signal was received from the debugged process */
d213 1
a213 1
/* The process and thread handles for the above context. */
d221 1
a221 1
/* Counts of things. */
d227 1
a227 1
/* User options. */
d252 1
a252 1
   context already contains what we need, we just unpack it. Then to
d255 1
a255 1
   out bit. */
d260 1
a260 1
   from the DEBUG_EVENT structure) to GDB's idea. */
d370 1
a370 1
   pristine state. */
d387 1
a387 1
/* Delete a thread from the list of threads */
d425 1
a425 1
		   events */
d432 6
a437 4
	  /* Lie about where the program actually is stopped since cygwin has informed us that
	     we should consider the signal to have occurred at another location which is stored
	     in "saved_context. */
	  memcpy (&current_thread->context, &saved_context, __COPY_CONTEXT_SIZE);
d447 2
a448 1
	     But only if there were not modified since last stop. PR gdb/2388 */
d487 1
a487 1
     thread id in its events */
d496 1
a496 1
    /* Windows sometimes uses a non-existent thread id in its events */;
d507 1
a507 1
/* Store a new register value into the current thread context */
d514 1
a514 1
     thread id in its events */
d529 2
a530 1
  HMODULE *DllHandle = dh_buf;	/* Set to temporary storage for initial query */
d536 1
a536 1
				   as 512. */
d540 2
a541 1
  /* Find size of buffer needed to handle list of modules loaded in inferior */
d546 1
a546 1
  /* Allocate correct amount of space for module list */
d551 1
a551 1
  /* Get the list of modules */
d558 1
a558 1
      /* Get information on this module */
d565 1
a565 1
	  /* Try to find the name of the given module */
d567 1
a567 1
	  /* Cygwin prefers that the path be in /x/y/z format */
d579 2
a580 1
	    error (_("Error getting dll name: %u."), (unsigned) GetLastError ());
d592 1
a592 1
   symbol_file_add_args */
d604 1
a604 1
/* Maintain a linked list of "so" information. */
d613 1
a613 1
   are errors. */
d625 1
a625 1
/* Restore gdb's stderr after calling symbol_file_add */
d639 1
a639 1
/* symbol_file_add wrapper that prevents errors from being displayed. */
d764 3
a766 2
	 file header and the section alignment. */
      cygwin_load_start = (CORE_ADDR) (uintptr_t) ((char *) load_addr + 0x1000);
d792 1
a792 1
     a program.  It will not work for attached processes. */
d797 3
a799 2
     address isn't null. */
  if (!ReadProcessMemory (h, address,  &address_ptr, sizeof (address_ptr), &done)
d803 1
a803 1
  /* Find the length of the string */
d898 1
a898 1
/* Clear list of loaded DLLs. */
d906 1
a906 1
/* Load DLL symbol info. */
d930 1
a930 1
   a Cygwin signal.  Otherwise just print the string as a warning. */
d942 2
a943 1
  else if (strncmp (s, _CYGWIN_SIGNAL_STRING, sizeof (_CYGWIN_SIGNAL_STRING) - 1) != 0)
d953 7
a959 5
      /* Got a cygwin signal marker.  A cygwin signal is followed by the signal number
	 itself and then optionally followed by the thread id and address to saved context
	 within the DLL.  If these are supplied, then the given thread is assumed to have
	 issued the signal and the context from the thread is assumed to be stored at the
	 given address in the inferior.  Tell gdb to treat this like a real signal.  */
d974 2
a975 1
					 &saved_context, __COPY_CONTEXT_SIZE, &n)
d1116 1
a1116 1
  /* Record the context of the current thread */
d1126 8
a1133 6
	/* See if the access violation happened within the cygwin DLL itself.  Cygwin uses
	   a kind of exception handling to deal with passed-in invalid addresses. gdb
	   should not treat these as real SEGVs since they will be silently handled by
	   cygwin.  A real SEGV will (theoretically) be caught by cygwin later in the process
	   and will be sent as a cygwin-specific-signal.  So, ignore SEGVs if they show up
	   within the text segment of the DLL itself. */
d1135 5
a1139 2
	CORE_ADDR addr = (CORE_ADDR) (uintptr_t) current_event.u.Exception.ExceptionRecord.ExceptionAddress;
	if ((!cygwin_exceptions && (addr >= cygwin_load_start && addr < cygwin_load_end))
d1141 2
a1142 1
		&& strncmp (fn, "KERNEL32!IsBad", strlen ("KERNEL32!IsBad")) == 0))
d1220 1
a1220 1
      /* Treat unhandled first chance exceptions specially. */
d1236 1
a1236 1
   execution */
d1339 2
a1340 2
		current_event.u.Exception.ExceptionRecord.ExceptionCode =
		  xlate[i].them;
d1359 1
a1359 1
  /* Get context for currently selected thread */
d1365 1
a1365 1
	  /* Single step by setting t bit */
d1390 1
a1390 1
     Otherwise complain. */
d1417 2
a1418 2
    warning (_("\
Could not interrupt program.  Press Ctrl-c in the program console."));
d1464 1
a1464 1
		 a main thread. */
d1471 1
a1471 1
      /* Record the existence of this thread */
d1508 1
a1508 1
      /* Add the main thread */
d1585 1
a1585 1
    case OUTPUT_DEBUG_STRING_EVENT:	/* message from the kernel */
d1637 1
a1637 1
     isn't necessarily what you think it is. */
d1650 2
a1651 2
	     the inferior. Note that this case is working starting with
	     Windows XP. For Windows 2000, Ctrl-C should be pressed in the
d1752 1
a1752 1
   available on NT/2K/XP. */
d1780 1
a1780 1
     windows_attach(). */
d1782 1
a1782 1
     be enabled. GetLastError () returns an correct error code, though. */
d1808 2
a1809 1
      printf_unfiltered ("This can cause attach to fail on Windows NT/2K/XP\n");
d1819 1
a1819 1
      /* Try fall back to Cygwin pid */
d1887 1
a1887 1
  /* Try to find exe name as symlink target of /proc/<pid>/exe */
d1900 1
a1900 1
     of gdb, or we're trying to debug a non-Cygwin windows executable. */
d2045 2
a2046 1
      cygallargs = (char *) alloca (sizeof (" -c 'exec  '") + strlen (exec_file)
d2190 1
a2190 1
   ^C on the controlling terminal. */
d2244 1
a2244 1
  target_mourn_inferior ();	/* or just windows_mourn_inferior? */
d2250 1
a2250 1
  /* Do nothing, since we can store individual regs */
d2266 1
a2266 1
/* Convert pid to printable format. */
d2299 2
a2300 1
    windows_xfer_shared_library (so->so_name, (CORE_ADDR) (uintptr_t) so->lm_info->load_addr,
d2462 2
a2463 1
  add_setshow_boolean_cmd ("cygwin-exceptions", class_support, &cygwin_exceptions, _("\
d2561 1
a2561 1
   it means that the thread has died.  Otherwise it is assumed to be alive. */
d2570 2
a2571 2
  return WaitForSingleObject (thread_rec (tid, FALSE)->h, 0) == WAIT_OBJECT_0 ?
    FALSE : TRUE;
d2604 1
a2604 1
   these functions could not be found. */
d2668 1
a2668 1
   of Windows. */
d2690 1
a2690 1
     wasn't found in kernel32.dll. */
d2704 1
a2704 1
     associated with the currently debugged process or its dlls. */
d2719 1
a2719 1
	 wasn't found in psapi.dll. */
d2723 5
a2727 3
      /* This will probably fail on Windows 9x/Me.  Let the user know that we're
	 missing some functionality. */
      warning(_("cannot automatically find executable file or library to read symbols.\nUse \"file\" or \"dll\" command to load executable/libraries directly."));
d2739 3
a2741 2
	 else is needed. */
      if (!OpenProcessToken || !LookupPrivilegeValueA || !AdjustTokenPrivileges)
@


1.211
log
@gdb/
	Rename and move inferior_thread_state and inferior_status.
	* gdbthread.h (struct thread_control_state): New struct, move fields
	step_range_start, step_range_end, step_frame_id, step_stack_frame_id,
	trap_expected, proceed_to_finish, in_infcall, step_over_calls,
	stop_step and stop_bpstat here from struct thread_info.
	(struct thread_suspend_state): New struct, move field stop_signal here
	from struct thread_info.
	(struct thread_info): Move the fields above from this struct.
	* inferior.h: Move the inferior_thread_state and inferior_status
	declarations comment to their definitions at infrun.c.
	(struct inferior_control_state): New struct, move field stop_soon from
	struct inferior here.
	(struct inferior_suspend_state): New empty struct.
	(struct inferior): New fields control and suspend.  Move out field
	stop_soon.
	* infrun.c (struct inferior_thread_state): Rename to ...
	(infcall_suspend_state): ... here.  Replace field stop_signal by
	fields thread_suspend and inferior_suspend.
	(save_inferior_thread_state): Rename to ...
	(save_infcall_suspend_state): ... here.  New variable inf.  Update the
	code for new fields.
	(restore_inferior_thread_state): Rename to ...
	(restore_infcall_suspend_state): ... here.  New variable inf.  Update
	the code for new fields.
	(do_restore_inferior_thread_state_cleanup): Rename to ...
	(do_restore_infcall_suspend_state_cleanup): ... here.
	(make_cleanup_restore_inferior_thread_state): Rename to ...
	(make_cleanup_restore_infcall_suspend_state): ... here.
	(discard_inferior_thread_state): Rename to ...
	(discard_infcall_suspend_state): ... here.
	(get_inferior_thread_state_regcache): Rename to ...
	(get_infcall_suspend_state_regcache): ... here.
	(struct inferior_status): Rename to ...
	(struct infcall_control_state): ... here.  Replace fields
	step_range_start, step_range_end, step_frame_id, step_stack_frame_id,
	trap_expected, proceed_to_finish, in_infcall, step_over_calls,
	stop_step, stop_bpstat and stop_soon by fields thread_control and
	inferior_control.
	(save_inferior_status): Rename to ...
	(save_infcall_control_state): ... here.  Update the code for new
	fields.
	(restore_inferior_status): Rename to ...
	(restore_infcall_control_state): ... here.  Update the code for new
	fields.
	(do_restore_inferior_status_cleanup): Rename to ...
	(do_restore_infcall_control_state_cleanup): ... here.
	(make_cleanup_restore_inferior_status): Rename to ...
	(make_cleanup_restore_infcall_control_state): ... here.
	(discard_inferior_status): Rename to ...
	(discard_infcall_control_state): ... here.
	* alpha-tdep.c, breakpoint.c, dummy-frame.c, dummy-frame.h,
	exceptions.c, fbsd-nat.c, gdbthread.h, infcall.c, infcmd.c,
	inferior.c, inferior.h, infrun.c, linux-nat.c, mi/mi-interp.c,
	mips-tdep.c, procfs.c, solib-irix.c, solib-osf.c, solib-spu.c,
	solib-sunos.c, solib-svr4.c, thread.c, windows-nat.c: Update all the
	references to the moved fields and renamed functions.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.210
log
@	* windows-nat.c (GetConsoleFontSize, GetCurrentConsoleFont):
	New macros.
	(windows_set_console_info): New function.
	(windows_create_inferior): Call windows_set_console_info
	if NEW_CONSOLE is true.
	(bad_GetCurrentConsoleFont, bad_GetConsoleFontSize): New functions.
	(_initialize_loadable): Initialize GetConsoleFontSize and
	GetCurrentConsoleFont.
@
text
@d1707 1
a1707 1
  inf->stop_soon = STOP_QUIETLY;
d1713 2
a1714 2
      if (tp->stop_signal != TARGET_SIGNAL_TRAP)
	resume (0, tp->stop_signal);
d1720 1
a1720 1
  inf->stop_soon = NO_STOP_QUIETLY;
@


1.209
log
@	* windows-nat.c (display_selector): Call GetLastError to give better
	failure explanation.
@
text
@d78 2
d92 2
d1902 45
d1989 1
a1989 1
    flags |= CREATE_NEW_CONSOLE;
d2626 15
d2657 4
d2672 4
@


1.208
log
@
	Support for Windows OS Thread Information Block.
	* NEWS: Document new feature.
	* remote.c (PACKET_qGetTIBAddr): New enum element.
	(remote_get_tib_address): New function.
	(init_remote_ops): Set to_get_tib_address field
	to remote_get_tib_address.
	(_initialize_remote): Add add_packet_config_cmd
	for PACKET_qGetTIBAddr.
	* target.c (update_current_target): Set default value for
	new to_get_tib_address field.
	* target.h (target_ops): New field to_get_tib_address.
	(target_get_tib_address): New macro.
	* windows-nat.c (thread_info): Add thread_local_base field.
	(windows_add_thread): Add tlb argument of type 'void *'.
	(fake_create_process): Adapt windows_add_thread call.
	(get_windows_debug_event): Idem.
	(windows_get_tib_address): New function.
	(init_windows_ops): Set to_get_tib_address field
	to remote_get_tib_address.
	(_initialize_windows_nat): Replace info_w32_cmdlist
	initialization by a call to init_w32_command_list.
	(info_w32_command, info_w32_cmdlist): Removed from here...
	to windows-tdep.c file.
	* windows-tdep.h (info_w32_cmdlist): Declare.
	(init_w32_command_list): New external function
	declaration.
	* windows-tdep.c: Add several headers.
	(info_w32_cmdlist): to here, made global.
	(thread_information_32): New struct.
	(thread_information_64): New struct.
	(TIB_NAME): New char array.
	(MAX_TIB32, MAX_TIB64, FULL_TIB_SIZE): New constants.
	(maint_display_all_tib): New static variable.
	(windows_get_tlb_type): New function.
	(tlb_value_read, tlb_value_write): New functions.
	(tlb_value_funcs): New static struct.
	(tlb_make_value): New function.
	(display_one_tib): New function.
	(display_tib): New function.
	(show_maint_show_all_tib):New function.
	(info_w32_command): Moved from windows-nat.c.
	(init_w32_command_list): New function.
	(_initialize_windows_tdep): New function.
	New "maint set/show show-all-tib" command
	New "$_tlb" internal variable.

gdbserver/ChangeLog entry:

	* server.c (handle_query): Handle 'qGetTIBAddr' query.
	* target.h (target_ops): New get_tib_address field.
	* win32-low.h (win32_thread_info): Add thread_local_base field.
	* win32-low.c (child_add_thread): Add tlb argument.
	Set thread_local_base field to TLB.
	(get_child_debug_event): Adapt to child_add_thread change.
	(win32_get_tib_address): New function.
	(win32_target_ops): Set get_tib_address field to
	win32_get_tib_address.
	* linux-low.c (linux_target_ops): Set get_tib_address field to NULL.

doc/ChangeLog entry:

	gdb.texinfo ($_tlb): Document new automatic convinience variable.
	(info w32 thread-information-block): Document new command.
	(qGetTIBAddress): Document new gdbserver query.
	(maint set/show show-all-tib): Document new command.
@
text
@d1035 5
a1039 1
      printf_filtered ("Invalid selector 0x%lx.\n",sel);
@


1.207
log
@* windows-nat.c (cygwin_conv_path): Remove old macro.
@
text
@d194 1
d324 1
a324 1
windows_add_thread (ptid_t ptid, HANDLE h)
d339 1
a1078 9
static struct cmd_list_element *info_w32_cmdlist = NULL;

static void
info_w32_command (char *args, int from_tty)
{
  help_list (info_w32_cmdlist, "info w32 ", class_info, gdb_stdout);
}


d1267 5
a1271 3
  current_thread = windows_add_thread (ptid_build (current_event.dwProcessId, 0,
						   current_event.dwThreadId),
				       current_event.u.CreateThread.hThread);
d1445 3
a1447 1
			     current_event.u.CreateThread.hThread);
d1481 2
a1482 1
			       current_event.u.CreateProcessInfo.hThread);
d2267 18
d2333 1
d2435 1
a2435 3
  add_prefix_cmd ("w32", class_info, info_w32_command,
		  _("Print information specific to Win32 debugging."),
		  &info_w32_cmdlist, "info w32 ", 0, &infolist);
@


1.206
log
@* windows-nat.c (cygwin_conv_path): Redefine to properly convert from/to
posix/win32.
(windows_make_so): Use non-Cygwin 1.7 specific function.
(windows_create_inferior): Make sure that cygallargs points to original args in
non Cygwin 1.7.  case.
@
text
@a123 1
#   define cygwin_conv_path(op, from, to, size) cygwin_conv_to_full_posix_path (from, to)
@


1.205
log
@* windows-nat.c: Reorganize #ifdef __CYGWIN__ considerations into one block.
Define helper macros to reduce ifdefs in code.
(get_module_name): Use cygwin_buf_t for buffer and __PMAX for buffer size.
Call unadorned GetModuleFileNameEx rather than GetModuleFileNameEx*.
(windows_make_so): Use __PMAX to denote maximum buffer size and cygwin_buf_t
for buffer type.  Use GetSystemDirectory{W,A} as appropriate.
(get_image_name): Use __PMAX to denote maximum buffer size.
(handle_load_dll): Likewise.
(windows_pid_to_exec_file): Likewise.
(windows_create_inferior): Add many accommodations for older Cygwin and
non-Cygwin.
(bad_GetModuleFileNameExW): Control inclusion of this function based on
__USEWIDE conditional.
(bad_GetModuleFileNameExA): Likewise.
(_initialize_loadable): Just use real function names without the dyn_ part
since they are defined earlier.
@
text
@d118 6
d131 1
d716 1
a716 1
      char *rname = canonicalize_file_name (name);
d1955 2
@


1.204
log
@	* remote-fileio.c (remote_fileio_func_rename): Use Cygwin 1.7
	cygwin_conv_path API rather than the deprecated
	cygwin_conv_to_full_posix_path.
	* windows-nat.c:
	(GetModuleFileNameExA): Undefine for Cygwin.
	(GetModuleFileNameExW): Define for Cygwin.
	(get_module_name): Change size of pathbuf to PATH_MAX for Cygwin.
	Call GetModuleFileNameExW and convert path to POSIX using
	cygwin_conv_path.
	(windows_make_so): Always define p.  Drop unused variable m.
	Don't use Win32 functions to check file existance, rather use
	access on Cygwin.  Fetch system directory using GetSystemDirectoryW.
	Use canonicalize_file_name to get full path.
	(get_image_name): Use wcstombs, rather than WideCharToMultiByte
	to convert Unicode pathname to multibyte on Cygwin.  Otherwise,
	use correct target buffer size in call to WideCharToMultiByte.
	(handle_load_dll): Change size of dll_buf to PATH_MAX for Cygwin.
	(windows_pid_to_exec_file): Change size of path to PATH_MAX for Cygwin.
	(windows_create_inferior): Convert all paths and arguments to wchar_t
	and use CreateProcessW on Cygwin.
	(_initialize_windows_nat): Disable DOS-style path warning on Cygwin.
	(bad_GetModuleFileNameExA): Undefine for Cygwin.
	(bad_GetModuleFileNameExW): Define for Cygwin.
	(_initialize_loadable): Load GetModuleFileNameExW into
	dyn_GetModuleFileNameExW on Cygwin.  Don't load ANSI function on Cygwin.
@
text
@d44 1
a74 5
#ifndef __CYGWIN__
#define GetModuleFileNameExA		dyn_GetModuleFileNameExA
#else
#define GetModuleFileNameExW		dyn_GetModuleFileNameExW
#endif
a85 7
#ifndef __CYGWIN__
static DWORD WINAPI (*GetModuleFileNameExA) (HANDLE, HMODULE, LPSTR,
					    DWORD);
#else
static DWORD WINAPI (*GetModuleFileNameExW) (HANDLE, HMODULE, LPWSTR,
					    DWORD);
#endif
d93 13
a105 1
#ifdef __CYGWIN__
d107 19
a125 2
static CORE_ADDR cygwin_load_start;
static CORE_ADDR cygwin_load_end;
d513 2
a514 2
  wchar_t pathbuf[PATH_MAX];	/* Temporary storage prior to converting to
				   posix form.  PATH_MAX is always enough
d547 2
a548 2
	  len = GetModuleFileNameExW (current_process_handle,
				      DllHandle[i], pathbuf, PATH_MAX);
d552 1
a552 1
				PATH_MAX) < 0)
d555 2
a556 2
	  len = GetModuleFileNameExA (current_process_handle,
				      DllHandle[i], dll_name_ret, MAX_PATH);
d651 2
a652 2
  char buf[MAX_PATH + 1];
  char cwd[MAX_PATH + 1];
d678 1
a678 1
  wchar_t buf[PATH_MAX];
d680 1
a680 1
  buf[0] = L'\0';
d684 1
d689 6
d757 1
a757 1
  static char buf[PATH_MAX];
d759 1
a759 1
  static char buf[(2 * MAX_PATH) + 1];
d792 1
a792 1
      wcstombs (buf, unicode_address, PATH_MAX);
d808 1
a808 5
#ifdef __CYGWIN__
  char dll_buf[PATH_MAX];
#else
  char dll_buf[MAX_PATH + 1];
#endif
d1452 1
d1850 1
a1851 2
  static char path[PATH_MAX];

a1861 2
#else
  static char path[MAX_PATH + 1];
d1899 1
d1901 2
a1902 3
  STARTUPINFOW si;
  wchar_t real_path[PATH_MAX];
  wchar_t shell[PATH_MAX]; /* Path to shell */
d1904 3
a1906 3
  wchar_t *toexec;
  wchar_t *cygallargs;
  wchar_t *args;
d1911 2
a1912 3
  STARTUPINFOA si;
  char real_path[PATH_MAX];
  char shell[MAX_PATH + 1]; /* Path to shell */
d1939 1
a1939 1
			    PATH_MAX * sizeof (wchar_t)) < 0)
d1942 1
d1948 1
d1955 1
a1955 1
      if (cygwin_conv_path (CCP_POSIX_TO_WIN_W, sh, shell, PATH_MAX) < 0)
d1957 1
d1962 5
d1970 4
a1973 2
  args = (wchar_t *) alloca ((wcslen (toexec) + wcslen (cygallargs) + 2)
			     * sizeof (wchar_t));
d1977 7
d2009 10
a2018 10
  ret = CreateProcessW (0,
			args,	/* command line */
			NULL,	/* Security */
			NULL,	/* thread */
			TRUE,	/* inherit handles */
			flags,	/* start flags */
			NULL,	/* environment */
			NULL,	/* current directory */
			&si,
			&pi);
d2030 1
a2035 1
  toexec = exec_file;
d2523 2
a2524 1
#ifndef __CYGWIN__
d2526 1
a2526 1
bad_GetModuleFileNameExA (HANDLE w, HMODULE x, LPSTR y, DWORD z)
d2532 1
a2532 1
bad_GetModuleFileNameExW (HANDLE w, HMODULE x, LPWSTR y, DWORD z)
d2537 1
d2560 1
a2560 1
      dyn_DebugActiveProcessStop = (void *)
d2562 1
a2562 1
      dyn_DebugBreakProcess = (void *)
d2564 1
a2564 1
      dyn_DebugSetProcessKillOnExit = (void *)
d2570 3
a2572 3
  if (!dyn_DebugBreakProcess)
    dyn_DebugBreakProcess = bad_DebugBreakProcess;
  if (!dyn_DebugActiveProcessStop || !dyn_DebugSetProcessKillOnExit)
d2574 2
a2575 2
      dyn_DebugActiveProcessStop = bad_DebugActiveProcessStop;
      dyn_DebugSetProcessKillOnExit = bad_DebugSetProcessKillOnExit;
d2583 1
a2583 1
      dyn_EnumProcessModules = (void *)
d2585 1
a2585 1
      dyn_GetModuleInformation = (void *)
d2587 2
a2588 7
#ifndef __CYGWIN__
      dyn_GetModuleFileNameExA = (void *)
	GetProcAddress (hm, "GetModuleFileNameExA");
#else
      dyn_GetModuleFileNameExW = (void *)
	GetProcAddress (hm, "GetModuleFileNameExW");
#endif
d2591 1
a2591 7
  if (!dyn_EnumProcessModules || !dyn_GetModuleInformation
#ifndef __CYGWIN__
      || !dyn_GetModuleFileNameExA
#else
      || !dyn_GetModuleFileNameExW
#endif
     )
d2595 3
a2597 7
      dyn_EnumProcessModules = bad_EnumProcessModules;
      dyn_GetModuleInformation = bad_GetModuleInformation;
#ifndef __CYGWIN__
      dyn_GetModuleFileNameExA = bad_GetModuleFileNameExA;
#else
      dyn_GetModuleFileNameExW = bad_GetModuleFileNameExW;
#endif
d2606 2
a2607 3
      dyn_OpenProcessToken = (void *)
	GetProcAddress (hm, "OpenProcessToken");
      dyn_LookupPrivilegeValueA = (void *)
d2609 1
a2609 1
      dyn_AdjustTokenPrivileges = (void *)
d2613 2
a2614 2
      if (!dyn_OpenProcessToken || !dyn_LookupPrivilegeValueA || !dyn_AdjustTokenPrivileges)
	dyn_OpenProcessToken = bad_OpenProcessToken;
@


1.203
log
@gdb/
	* defs.h (parse_pid_to_attach): New.
	* utils.c (parse_pid_to_attach): New.
	* darwin-nat.c (darwin_attach): Replace ARGS parsing by parse_pid.
	* gnu-nat.c (gnu_attach): Likewise.
	* nto-procfs.c (procfs_attach): Likewise.
	* procfs.c (procfs_attach): Likewise.
	* windows-nat.c (windows_attach): Likewise.
	* inf-ptrace.c (inf_ptrace_attach): Likewise.  Remove variable dummy.
	* inf-ttrace.c (inf_ttrace_attach): Likewise.
	* remote.c (extended_remote_attach_1): Likewise.  New comment on getpid
	check.

gdb/testsuite/
	* gdb.base/attach.exp (attach to nonsense is prohibited): Make the
	"Illegal process-id" expect string more exact.
	(attach to digits-starting nonsense is prohibited): New.
@
text
@d74 1
d76 3
d90 1
d93 4
d495 4
a498 4
  char pathbuf[PATH_MAX + 1];	/* Temporary storage prior to converting to
				   posix form */
#else
  char *pathbuf = dll_name_ret;	/* Just copy directly to passed-in arg */
d527 10
d538 1
a538 1
				      DllHandle[i], pathbuf, MAX_PATH);
a540 3
#ifdef __CYGWIN__
	  /* Cygwin prefers that the path be in /x/y/z format */
	  cygwin_conv_to_full_posix_path (pathbuf, dll_name_ret);
d631 2
a634 1
  char *p;
a636 1
  MEMORY_BASIC_INFORMATION m;
a653 1

d659 13
d679 14
a692 1
  cygwin_conv_to_posix_path (buf, so->so_name);
d731 3
d735 1
d766 6
a771 2

      WideCharToMultiByte (CP_ACP, 0, unicode_address, len, buf, len, 0, 0);
d783 3
d787 1
d1828 2
a1829 1
  static char path[MAX_PATH + 1];
a1830 1
#ifdef __CYGWIN__
d1841 2
d1880 4
a1883 8
  STARTUPINFO si;
  PROCESS_INFORMATION pi;
  BOOL ret;
  DWORD flags;
  char *args;
  char real_path[MAXPATHLEN];
  char *toexec;
  char shell[MAX_PATH + 1]; /* Path to shell */
d1885 4
a1888 1
#ifdef __CYGWIN__
d1892 5
d1899 3
d1910 6
d1919 4
a1922 2
      flags = DEBUG_ONLY_THIS_PROCESS;
      cygwin_conv_to_win32_path (exec_file, real_path);
d1924 5
a1931 1
      char *newallargs;
d1935 6
a1940 5
      cygwin_conv_to_win32_path (sh, shell);
      newallargs = alloca (sizeof (" -c 'exec  '") + strlen (exec_file)
			   + strlen (allargs) + 2);
      sprintf (newallargs, " -c 'exec %s %s'", exec_file, allargs);
      allargs = newallargs;
d1942 1
a1942 1
      flags = DEBUG_PROCESS;
d1944 5
a1948 17
#else
  toexec = exec_file;
  flags = DEBUG_ONLY_THIS_PROCESS;
#endif

  if (new_group)
    flags |= CREATE_NEW_PROCESS_GROUP;

  if (new_console)
    flags |= CREATE_NEW_CONSOLE;

  args = alloca (strlen (toexec) + strlen (allargs) + 2);
  strcpy (args, toexec);
  strcat (args, " ");
  strcat (args, allargs);

#ifdef __CYGWIN__
d1972 22
d1995 8
a2023 1
#endif
d2026 10
a2035 23
  ret = CreateProcess (0,
		       args,	/* command line */
		       NULL,	/* Security */
		       NULL,	/* thread */
		       TRUE,	/* inherit handles */
		       flags,	/* start flags */
		       NULL,	/* environment */
		       NULL,	/* current directory */
		       &si,
		       &pi);

#ifdef __CYGWIN__
  if (tty >= 0)
    {
      close (tty);
      dup2 (ostdin, 0);
      dup2 (ostdout, 1);
      dup2 (ostderr, 2);
      close (ostdin);
      close (ostdout);
      close (ostderr);
    }
#else
d2302 4
d2488 1
d2494 7
d2550 1
d2553 4
d2559 7
a2565 1
  if (!dyn_EnumProcessModules || !dyn_GetModuleInformation || !dyn_GetModuleFileNameExA)
d2571 1
d2573 3
@


1.202
log
@Spurious "dll not found" error messages on x64-windows.

        * windows-nat.c: Add include of complaints.h.
        (handle_unload_dll): Change dll-not-found error into a complaint.
@
text
@d1694 1
a1694 2
  if (!args)
    error_no_arg (_("process-id to attach"));
a1701 2
  pid = strtoul (args, 0, 0);		/* Windows pid */

@


1.201
log
@* windows-nat.c (windows_initialization_done): New variable.
(get_windows_debug_event): Issue error when process dies before completely
initializing.
(do_initial_windows_stuff): Set flag to indicate when we are done with the
initial steps of attaching to the child.
@
text
@d67 1
d787 9
a795 2
  error (_("Error: dll starting at %s not found."),
	   host_address_to_string (lpBaseOfDll));
@


1.200
log
@2010-01-25  gingold  <gingold@@adacore.com>

        * windows-nat.c (windows_continue): Use %x to print thread id.
        (get_windows_debug_event): Ditto.
@
text
@d126 2
d1404 13
a1416 5
      if (saw_create != 1)
	break;
      ourstatus->kind = TARGET_WAITKIND_EXITED;
      ourstatus->value.integer = current_event.u.ExitProcess.dwExitCode;
      retval = main_thread_id;
d1611 1
d1624 1
@


1.199
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d1131 1
a1131 1
  DEBUG_EVENTS (("ContinueDebugEvent (cpid=%ld, ctid=%ld, %s);\n",
d1364 1
a1364 1
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
d1377 1
a1377 1
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
d1398 1
a1398 1
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
d1410 1
a1410 1
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
d1424 1
a1424 1
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
d1437 1
a1437 1
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
d1459 1
a1459 1
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
@


1.198
log
@2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	Add base multi-executable/process support to GDB.

	gdb/
	* Makefile.in (SFILES): Add progspace.c.
	(COMMON_OBS): Add progspace.o.
	* progspace.h: New.
	* progspace.c: New.

	* breakpoint.h (struct bp_target_info) <placed_address_space>: New
	field.
	(struct bp_location) <pspace>: New field.
	(struct breakpoint) <pspace>: New field.
	(bpstat_stop_status, breakpoint_here_p)
	(moribund_breakpoint_here_p, breakpoint_inserted_here_p)
	(regular_breakpoint_inserted_here_p)
	(software_breakpoint_inserted_here_p, breakpoint_thread_match)
	(set_default_breakpoint): Adjust prototypes.
	(remove_breakpoints_pid, breakpoint_program_space_exit): Declare.
	(insert_single_step_breakpoint, deprecated_insert_raw_breakpoint):
	Adjust prototypes.
	* breakpoint.c (executing_startup): Delete.
	(default_breakpoint_sspace): New.
	(breakpoint_restore_shadows): Skip if the address space doesn't
	match.
	(update_watchpoint): Record the frame's program space in the
	breakpoint location.
	(insert_bp_location): Record the address space in target_info.
	Adjust to pass the symbol space to solib_name_from_address.
	(breakpoint_program_space_exit): New.
	(insert_breakpoint_locations): Switch the symbol space and thread
	when inserting breakpoints.  Don't insert breakpoints in a vfork
	parent waiting for vfork done if we're not attached to the vfork
	child.
	(remove_breakpoints_pid): New.
	(reattach_breakpoints): Switch to a thread of PID.  Ignore
	breakpoints of other symbol spaces.
	(create_internal_breakpoint): Store the symbol space in the sal.
	(create_longjmp_master_breakpoint): Iterate over all symbol
	spaces.
	(update_breakpoints_after_exec): Ignore breakpoints for other
	symbol spaces.
	(remove_breakpoint): Rename to ...
	(remove_breakpoint_1): ... this.  Pass the breakpoints symbol
	space to solib_name_from_address.
	(remove_breakpoint): New.
	(mark_breakpoints_out): Ignore breakpoints from other symbol
	spaces.
	(breakpoint_init_inferior): Ditto.
	(breakpoint_here_p): Add an address space argument and adjust to
	use breakpoint_address_match.
	(moribund_breakpoint_here_p): Ditto.
	(regular_breakpoint_inserted_here_p): Ditto.
	(breakpoint_inserted_here_p): Ditto.
	(software_breakpoint_inserted_here_p): Ditto.
	(breakpoint_thread_match): Ditto.
	(bpstat_check_location): Ditto.
	(bpstat_stop_status): Ditto.
	(print_breakpoint_location): If there's a location to print,
	switch the current symbol space.
	(print_one_breakpoint_location): Add `allflag' argument.
	(print_one_breakpoint): Ditto.	Adjust.
	(do_captured_breakpoint_query): Adjust.
	(breakpoint_1): Adjust.
	(breakpoint_has_pc): Also match the symbol space.
	(describe_other_breakpoints): Add a symbol space argument and
	adjust.
	(set_default_breakpoint): Add a symbol space argument.	Set
	default_breakpoint_sspace.
	(breakpoint_address_match): New.
	(check_duplicates_for): Add an address space argument, and adjust.
	(set_raw_breakpoint): Record the symbol space in the location and
	in the breakpoint.
	(set_longjmp_breakpoint): Skip longjmp master breakpoints from
	other symbol spaces.
	(remove_thread_event_breakpoints, remove_solib_event_breakpoints)
	(disable_breakpoints_in_shlibs): Skip breakpoints from other
	symbol spaces.
	(disable_breakpoints_in_unloaded_shlib): Match symbol spaces.
	(create_catchpoint): Set the symbol space in the sal.
	(disable_breakpoints_before_startup): Skip breakpoints from other
	symbol spaces.	Set executing_startup in the current symbol space.
	(enable_breakpoints_after_startup): Clear executing_startup in the
	current symbol space.  Skip breakpoints from other symbol spaces.
	(clone_momentary_breakpoint): Also copy the symbol space.
	(add_location_to_breakpoint): Set the location's symbol space.
	(bp_loc_is_permanent): Switch thread and symbol space.
	(create_breakpoint): Adjust.
	(expand_line_sal_maybe): Expand comment to mention symbol spaces.
	Switch thread and symbol space when reading memory.
	(parse_breakpoint_sals): Set the symbol space in the sal.
	(break_command_really): Ditto.
	(skip_prologue_sal): Switch and space.
	(resolve_sal_pc): Ditto.
	(watch_command_1): Record the symbol space in the sal.
	(create_ada_exception_breakpoint): Adjust.
	(clear_command): Adjust.  Match symbol spaces.
	(update_global_location_list): Use breakpoint_address_match.
	(breakpoint_re_set_one): Switch thread and space.
	(breakpoint_re_set): Save symbol space.
	(breakpoint_re_set_thread): Also reset the symbol space.
	(deprecated_insert_raw_breakpoint): Add an address space argument.
	Adjust.
	(insert_single_step_breakpoint): Ditto.
	(single_step_breakpoint_inserted_here_p): Ditto.
	(clear_syscall_counts): New.
	(_initialize_breakpoint): Install it as inferior_exit observer.

	* exec.h: Include "progspace.h".
	(exec_bfd, exec_bfd_mtime): New defines.
	(exec_close): Declare.
	* exec.c: Include "gdbthread.h" and "progspace.h".
	(exec_bfd, exec_bfd_mtime, current_target_sections_1): Delete.
	(using_exec_ops): New.
	(exec_close_1): Rename to exec_close, and make public.
	(exec_close): Rename to exec_close_1, and adjust all callers.  Add
	description.  Remove target sections and close executables from
	all program spaces.
	(exec_file_attach): Add comment.
	(add_target_sections): Check on `using_exec_ops' to check if the
	target should be pushed.
	(remove_target_sections): Only unpush the target if there are no
	more target sections in any symbol space.
	* gdbcore.h: Include "exec.h".
	(exec_bfd, exec_bfd_mtime): Remove declarations.

	* frame.h (get_frame_program_space, get_frame_address_space)
	(frame_unwind_program_space): Declare.
	* frame.c (struct frame_info) <pspace, aspace>: New fields.
	(create_sentinel_frame): Add program space argument.  Set the
	pspace and aspace fields of the frame object.
	(get_current_frame, create_new_frame): Adjust.
	(get_frame_program_space): New.
	(frame_unwind_program_space): New.
	(get_frame_address_space): New.
	* stack.c (print_frame_info): Adjust.
	(print_frame): Use the frame's program space.

	* gdbthread.h (any_live_thread_of_process): Declare.
	* thread.c (any_live_thread_of_process): New.
	(switch_to_thread): Switch the program space as well.
	(restore_selected_frame): Don't warn if trying to restore frame
	level 0.

	* inferior.h: Include "progspace.h".
	(detach_fork): Declare.
	(struct inferior) <removable, aspace, pspace>
	<vfork_parent, vfork_child, pending_detach>
	<waiting_for_vfork_done>: New fields.
	<terminal_info>: Remove field.
	<data, num_data>: New fields.
	(register_inferior_data, register_inferior_data_with_cleanup)
	(clear_inferior_data, set_inferior_data, inferior_data): Declare.
	(exit_inferior, exit_inferior_silent, exit_inferior_num_silent)
	(inferior_appeared): Declare.
	(find_inferior_pid): Typo.
	(find_inferior_id, find_inferior_for_program_space): Declare.
	(set_current_inferior, save_current_inferior, prune_inferiors)
	(number_of_inferiors): Declare.
	(inferior_list): Declare.
	* inferior.c: Include "gdbcore.h" and "symfile.h".
	(inferior_list): Make public.
	(delete_inferior_1): Always delete thread silently.
	(find_inferior_id): Make public.
	(current_inferior_): New.
	(current_inferior): Use it.
	(set_current_inferior): New.
	(restore_inferior): New.
	(save_current_inferior): New.
	(free_inferior): Free the per-inferior data.
	(add_inferior_silent): Allocate per-inferior data.
	Call inferior_appeared.
	(delete_threads_of_inferior): New.
	(delete_inferior_1): Adjust interface to take an inferior pointer.
	(delete_inferior): Adjust.
	(delete_inferior_silent): Adjust.
	(exit_inferior_1): New.
	(exit_inferior): New.
	(exit_inferior_silent): New.
	(exit_inferior_num_silent): New.
	(detach_inferior): Adjust.
	(inferior_appeared): New.
	(discard_all_inferiors): Adjust.
	(find_inferior_id): Make public.  Assert pid is not zero.
	(find_inferior_for_program_space): New.
	(have_inferiors): Check if we have any inferior with pid not zero.
	(have_live_inferiors): Go over all pushed targets looking for
	process_stratum.
	(prune_inferiors): New.
	(number_of_inferiors): New.
	(print_inferior): Add executable column.  Print vfork parent/child
	relationships.
	(inferior_command): Adjust to cope with not running inferiors.
	(remove_inferior_command): New.
	(add_inferior_command): New.
	(clone_inferior_command): New.
	(struct inferior_data): New.
	(struct inferior_data_registration): New.
	(struct inferior_data_registry): New.
	(inferior_data_registry): New.
	(register_inferior_data_with_cleanup): New.
	(register_inferior_data): New.
	(inferior_alloc_data): New.
	(inferior_free_data): New.
	(clear_inferior_data): New.
	(set_inferior_data): New.
	(inferior_data): New.
	(initialize_inferiors): New.
	(_initialize_inferiors): Register "add-inferior",
	"remove-inferior" and "clone-inferior" commands.

	* objfiles.h: Include "progspace.h".
	(struct objfile) <pspace>: New field.
	(symfile_objfile, object_files): Don't declare.
	(ALL_PSPACE_OBJFILES): New.
	(ALL_PSPACE_OBJFILES_SAFE): New.
	(ALL_OBJFILES, ALL_OBJFILES_SAFE): Adjust.
	(ALL_PSPACE_SYMTABS): New.
	(ALL_PRIMARY_SYMTABS): Adjust.
	(ALL_PSPACE_PRIMARY_SYMTABS): New.
	(ALL_PSYMTABS): Adjust.
	(ALL_PSPACE_PSYMTABS): New.
	* objfiles.c (object_files, symfile_objfile): Delete.
	(struct objfile_sspace_info): New.
	(objfiles_pspace_data): New.
	(objfiles_pspace_data_cleanup): New.
	(get_objfile_pspace_data): New.
	(objfiles_changed_p): Delete.
	(allocate_objfile): Set the objfile's program space.  Adjust to
	reference objfiles_changed_p in pspace data.
	(free_objfile): Adjust to reference objfiles_changed_p in pspace
	data.
	(objfile_relocate): Ditto.
	(update_section_map): Add pspace argument.  Adjust to iterate over
	objfiles in the passed in pspace.
	(find_pc_section): Delete sections and num_sections statics.
	Adjust to refer to program space's objfiles_changed_p.	Adjust to
	refer to sections and num_sections store in the objfile's pspace
	data.
	(objfiles_changed): Adjust to reference objfiles_changed_p in
	pspace data.
	(_initialize_objfiles): New.
	* linespec.c (decode_all_digits, decode_dollar): Set the sal's
	program space.
	* source.c (current_source_pspace): New.
	(get_current_source_symtab_and_line): Set the sal's program space.
	(set_current_source_symtab_and_line): Set current_source_pspace.
	(select_source_symtab): Ditto.	Use ALL_OBJFILES.
	(forget_cached_source_info): Iterate over all program spaces.
	* symfile.c (clear_symtab_users): Adjust.
	* symmisc.c (print_symbol_bcache_statistics): Iterate over all
	program spaces.
	(print_objfile_statistics): Ditto.
	(maintenance_print_msymbols): Ditto.
	(maintenance_print_objfiles): Ditto.
	(maintenance_info_symtabs): Ditto.
	(maintenance_info_psymtabs): Ditto.
	* symtab.h (SYMTAB_PSPACE): New.
	(struct symtab_and_line) <pspace>: New field.
	* symtab.c (init_sal): Clear the sal's program space.
	(find_pc_sect_symtab): Set the sal's program space.  Switch thread
	and space.
	(append_expanded_sal): Add program space argument.  Iterate over
	all program spaces.
	(expand_line_sal): Iterate over all program spaces.  Switch
	program space.

	* target.h (enum target_waitkind) <TARGET_WAITKIND_VFORK_DONE>: New.
	(struct target_ops) <to_thread_address_space>: New field.
	(target_thread_address_space): Define.
	* target.c (target_detach): Only remove breakpoints from the
	inferior we're detaching.
	(target_thread_address_space): New.

	* defs.h (initialize_progspace): Declare.
	* top.c (gdb_init): Call it.

	* solist.h (struct so_list) <sspace>: New field.
	* solib.h (struct program_space): Forward declare.
	(solib_name_from_address): Adjust prototype.
	* solib.c (so_list_head): Replace with a macro referencing the
	program space.
	(update_solib_list): Set the so's program space.
	(solib_name_from_address): Add a program space argument and adjust.

	* solib-svr4.c (struct svr4_info) <pid>: Delete field.
	<interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low>
	<interp_plt_sect_high>: New fields.
	(svr4_info_p, svr4_info): Delete.
	(solib_svr4_sspace_data): New.
	(get_svr4_info): Rewrite.
	(svr4_sspace_data_cleanup): New.
	(open_symbol_file_object): Adjust.
	(svr4_default_sos): Adjust.
	(svr4_fetch_objfile_link_map): Adjust.
	(interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low)
	(interp_plt_sect_high): Delete.
	(svr4_in_dynsym_resolve_code): Adjust.
	(enable_break): Adjust.
	(svr4_clear_solib): Revert bit that removed the svr4_info here,
	and reinstate clearing debug_base, debug_loader_offset_p,
	debug_loader_offset and debug_loader_name.
	(_initialize_svr4_solib): Register solib_svr4_pspace_data.  Don't
	install an inferior_exit observer anymore.

	* printcmd.c (struct display) <pspace>: New field.
	(display_command): Set the display's sspace.
	(do_one_display): Match the display's sspace.
	(display_uses_solib_p): Ditto.

	* linux-fork.c (detach_fork): Moved to infrun.c.
	(_initialize_linux_fork): Moved "detach-on-fork" command to
	infrun.c.
	* infrun.c (detach_fork): Moved from linux-fork.c.
	(proceed_after_vfork_done): New.
	(handle_vfork_child_exec_or_exit): New.
	(follow_exec_mode_replace, follow_exec_mode_keep)
	(follow_exec_mode_names, follow_exec_mode_string)
	(show_follow_exec_mode_string): New.
	(follow_exec): New.  Reinstate the mark_breakpoints_out call.
	Remove shared libraries before attaching new executable.  If user
	wants to keep the inferior, keep it.
	(displaced_step_fixup): Adjust to pass an address space to the
	breakpoints module.
	(resume): Ditto.
	(clear_proceed_status): In all-stop mode, always clear the proceed
	status of all threads.
	(prepare_to_proceed): Adjust to pass an address space to the
	breakpoints module.
	(proceed): Ditto.
	(adjust_pc_after_break): Ditto.
	(handle_inferior_event): When handling a process exit, switch the
	program space to the inferior's that had exited.  Call
	handle_vfork_child_exec_or_exit.  Adjust to pass an address space
	to the breakpoints module.  In non-stop mode, when following a
	fork and detach-fork is off, also resume the other branch.  Handle
	TARGET_WAITKIND_VFORK_DONE.  Set the program space in sals.
	(normal_stop): Prune inferiors.
	(_initialize_infrun): Install the new "follow-exec-mode" command.
	"detach-on-fork" moved here.

	* regcache.h (get_regcache_aspace): Declare.
	* regcache.c (struct regcache) <aspace>: New field.
	(regcache_xmalloc): Clear the aspace.
	(get_regcache_aspace): New.
	(regcache_cpy): Copy the aspace field.
	(regcache_cpy_no_passthrough): Ditto.
	(get_thread_regcache): Fetch the thread's address space from the
	target, and store it in the regcache.

	* infcall.c (call_function_by_hand): Set the sal's pspace.

	* arch-utils.c (default_has_shared_address_space): New.
	* arch-utils.h (default_has_shared_address_space): Declare.

	* gdbarch.sh (has_shared_address_space): New.
	* gdbarch.h, gdbarch.c: Regenerate.

	* linux-tdep.c: Include auxv.h, target.h, elf/common.h.
	(linux_has_shared_address_space): New.
	(_initialize_linux_tdep): Declare.

	* arm-tdep.c (arm_software_single_step): Pass the frame's address
	space to insert_single_step_breakpoint.
	* arm-linux-tdep.c (arm_linux_software_single_step): Pass the
	frame's pspace to breakpoint functions.
	* cris-tdep.c (crisv32_single_step_through_delay): Ditto.
	(cris_software_single_step): Ditto.
	* mips-tdep.c (deal_with_atomic_sequence): Add frame argument.
	Pass the frame's pspace to breakpoint functions.
	(mips_software_single_step): Adjust.
	(mips_single_step_through_delay): Adjust.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Adjust.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Adjust.
	* solib-irix.c (enable_break): Adjust to pass the current frame's
	address space to breakpoint functions.
	* sparc-tdep.c (sparc_software_single_step): Ditto.
	* spu-tdep.c (spu_software_single_step): Ditto.
	* alpha-tdep.c (alpha_software_single_step): Ditto.
	* record.c (record_wait): Adjust to pass an address space to the
	breakpoints module.

	* fork-child.c (fork_inferior): Set the new inferior's program and
	address spaces.
	* inf-ptrace.c (inf_ptrace_follow_fork): Copy the parent's program
	and address spaces.
	(inf_ptrace_attach): Set the inferior's program and address spaces.
	* linux-nat.c: Include "solib.h".
	(linux_child_follow_fork): Manage parent and child's program and
	address spaces.	 Clone the parent's program space if necessary.
	Don't wait for the vfork to be done here.  Refuse to resume if
	following the vfork parent while leaving the child stopped.
	(resume_callback): Don't resume a vfork parent.
	(linux_nat_resume): Also check for pending events in the
	lp->waitstatus field.
	(linux_handle_extended_wait): Report TARGET_WAITKIND_VFORK_DONE
	events to the core.
	(stop_wait_callback): Don't wait for SIGSTOP on vfork parents.
	(cancel_breakpoint): Adjust.
	* linux-thread-db.c (thread_db_wait): Don't remove thread event
	breakpoints here.
	(thread_db_mourn_inferior): Don't mark breakpoints out here.
	Remove thread event breakpoints after mourning.
	* corelow.c: Include progspace.h.
	(core_open): Set the inferior's program and address spaces.
	* remote.c (remote_add_inferior): Set the new inferior's program
	and address spaces.
	(remote_start_remote): Update address spaces.
	(extended_remote_create_inferior_1): Don't init the thread list if
	we already debugging other inferiors.
	* darwin-nat.c (darwin_attach): Set the new inferior's program and
	address spaces.
	* gnu-nat.c (gnu_attach): Ditto.
	* go32-nat.c (go32_create_inferior): Ditto.
	* inf-ttrace.c (inf_ttrace_follow_fork, inf_ttrace_attach): Ditto.
	* monitor.c (monitor_open): Ditto.
	* nto-procfs.c (procfs_attach, procfs_create_inferior): Ditto.
	* procfs.c (do_attach): Ditto.
	* windows-nat.c (do_initial_windows_stuff): Ditto.

	* inflow.c (inferior_process_group)
	(terminal_init_inferior_with_pgrp, terminal_inferior,
	(terminal_ours_1, inflow_inferior_exit, copy_terminal_info)
	(child_terminal_info, new_tty_postfork, set_sigint_trap): Adjust
	to use per-inferior data instead of inferior->terminal_info.
	(inflow_inferior_data): New.
	(inflow_new_inferior): Delete.
	(inflow_inferior_data_cleanup): New.
	(get_inflow_inferior_data): New.

	* mi/mi-interp.c (mi_new_inferior): Rename to...
	(mi_inferior_appeared): ... this.
	(mi_interpreter_init): Adjust.

	* tui/tui-disasm.c: Include "progspace.h".
	(tui_set_disassem_content): Pass an address space to
	breakpoint_here_p.

	* NEWS: Mention multi-program debugging support.  Mention new
	commands "add-inferior", "clone-inferior", "remove-inferior",
	"maint info program-spaces", and new option "set
	follow-exec-mode".

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* observer.texi (new_inferior): Rename to...
	(inferior_appeared): ... this.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/testsuite/
	* gdb.base/foll-vfork.exp: Adjust to spell out "follow-fork".
	* gdb.base/foll-exec.exp: Adjust to expect a process id before
	"Executing new program".
	* gdb.base/foll-fork.exp: Adjust to spell out "follow-fork".
	* gdb.base/multi-forks.exp: Ditto.  Adjust to the inferior being
	left listed after having been killed.
	* gdb.base/attach.exp: Adjust to spell out "symbol-file".
	* gdb.base/maint.exp: Adjust test.

	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* gdb.multi/Makefile.in: New.
	* gdb.multi/base.exp: New.
	* gdb.multi/goodbye.c: New.
	* gdb.multi/hangout.c: New.
	* gdb.multi/hello.c: New.
	* gdb.multi/bkpt-multi-exec.c: New.
	* gdb.multi/bkpt-multi-exec.exp: New.
	* gdb.multi/crashme.c: New.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Inferiors): Rename node to ...
	(Inferiors and Programs): ... this.  Mention running multiple
	programs in the same debug session.
	<info inferiors>: Mention the new 'Executable' column if "info
	inferiors".  Update examples.  Document the "add-inferior",
	"clone-inferior", "remove-inferior" and "maint info
	program-spaces" commands.
	(Process): Rename node to...
	(Forks): ... this.  Document "set|show follow-exec-mode".
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.197
log
@	* windows-nat.c (ctrl_c_handler): Also handle CTRL_BREAK_EVENT.
@
text
@d1588 2
a1589 1
  inf = add_inferior (pid);
@


1.196
log
@	* defs.h (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter.
	* utils.c (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter, use it instead of current_gdbarch.
	* ui-out.h (ui_out_field_core_addr): Add GDBARCH parameter.
	* ui-out.c (ui_out_field_core_addr): Add GDBARCH parameter,
	use it instead of current_gdbarch.

	Update calls to ui_out_field_core_addr to pass architecture:
	* ada-lang.c (print_one_exception): Update.
	* breakpoint.c (print_one_breakpoint_location,
	print_one_exception_catchpoint): Update.
	* disasm.c (dump_insns): Update.
	* darwin-nat-info.c (darwin_debug_regions_recurse): Update.
	* mi/mi-main.c (mi_cmd_data_read_memory): Update.
	* mi/mi-symbol-cmds.c: Include "objfiles.h".
	(mi_cmd_symbol_list_lines): Update.
	* stack.c (print_frame_info, print_frame): Update.

	Update callers of paddress to pass architecture:
	* ada-tasks.c (info_task): Update.
	* ada-valprint.c (ada_val_print_1): Update.
	* annotate.c (annotate_source, annotate_frame_begin): Update.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints,
	mention): Update.
	* cli/cli-cmds.c (edit_command, list_command, print_disassembly):
	Update.
	* corefile.c (memory_error): Update.
	* c-valprint.c (print_function_pointer_address, c_val_print): Update.
	* disasm.c (dis_asm_print_address): Update.
	* exec.c (print_section_info): Update.
	* f-valprint.c (f_val_print): Update.
	* infcmd.c: Include "arch-utils.h".
	(jump_command, program_info): Update.
	* linux-fork.c: Include "arch-utils.h".
	(info_forks_command): Update.
	* m2-valprint.c (print_function_pointer_address,
	print_unpacked_pointer, print_variable_at_address,
	m2_val_print): Update.
	* m32r-rom.c (m32r_load_section, m32r_load, m32r_upload_command):
	Update.
	* printcmd.c (print_address, print_address_demangle, address_info):
	Update.
	* p-valprint.c (pascal_val_print): Update.
	* source.c: Include "arch-utils.h".
	(line_info): Update.
	* stack.c (frame_info, print_block_frame_labels): Update.
	* symfile.c (add_symbol_file_command, list_overlays_command): Update.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1,
	print_symbol, print_partial_symbols, maintenance_info_psymtabs,
	maintenance_check_symtabs): Update.
	* symtab.c (find_pc_sect_symtab): Update.
	* target.c (deprecated_debug_xfer_memory): Update.
	* tracepoint.c (scope_info): Update.
	* tui/tui-stack.c (tui_make_status_line): Update.
	* valprint.c (val_print_string): Update.

	Update callers of paddr_nz to use paddress instead (keeping
	user-visible output identical):
	* alpha-tdep.c (alpha_heuristic_proc_start): Update.
	* amd64-tdep.c (fixup_riprel, amd64_displaced_step_copy_insn,
	amd64_displaced_step_fixup): Update.
	* arch-utils.c (simple_displaced_step_copy_insn): Update.
	* auxv.c (fprint_target_auxv): Update.
	* breakpoint.c (insert_single_step_breakpoint): Update.
	* buildsym.c (finish_block): Update.
	* cli/cli-dump.c (restore_section_callback): Update.
	* fbsd-nat.c (fbsd_find_memory_regions): Update.
	* frame.c (frame_unwind_register_value): Update.
	* gcore.c (gcore_create_callback): Update.
	* hppa-tdep.c (hppa_frame_cache, hppa_skip_trampoline_code): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_record_modrm,
	i386_record_lea_modrm_addr, i386_record_lea_modrm,
	i386_process_record): Update.
	* ia64-tdep.c (ia64_frame_this_id, ia64_sigtramp_frame_this_id,
	ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id,
	ia64_dummy_id, ia64_access_reg, ia64_access_rse_reg): Update.
	* infrun.c (displaced_step_prepare, displaced_step_fixup,
	handle_inferior_event, insert_step_resume_breakpoint_at_sal,
	insert_longjmp_resume_breakpoint): Update.
	* linux-nat.c (linux_nat_find_memory_regions): Update.
	* linux-record.c (record_linux_system_call): Update.
	* mips-tdep.c (heuristic_proc_start, mips_eabi_push_dummy_call,
	mips_n32n64_push_dummy_call, mips_o32_push_dummy_call,
	mips_o64_push_dummy_call): Update.
	* monitor.c (monitor_error, monitor_remove_breakpoint): Update.
	* record.c (record_arch_list_add_mem, record_wait,
	record_xfer_partial): Update.
	* remote-mips.c (mips_fetch_word, mips_check_lsi_error,
	mips_common_breakpoint): Update.
	* remote-sim.c (gdbsim_xfer_inferior_memory): Update.
	* rs6000-tdep.c (ppc_displaced_step_fixup): Update.
	* solib-som.c (som_current_sos): Update.
	* symfile.c (load_progress, generic_load): Update.
	* symfile-mem.c (add_vsyscall_page): Update.
	* valops.c (value_fetch_lazy): Update.
	* windows-tdep.c (windows_xfer_shared_library): Update.

	Update callers of paddr_nz to use paddress instead (changing
	user-visible output to make it more correct):
	* dwarf2loc.c (locexpr_describe_location): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint,
	ia64_memory_remove_breakpoint): Update.
	* jv-valprint.c (java_value_print): Update.
	* m32c-tdep.c (m32c_m16c_address_to_pointer): Update.
	* monitor.c (monitor_read_memory): Update.

	Update callers of paddr to use paddress instead (changing
	user-visible output to make it more correct):
	* arm-tdep.c (arm_push_dummy_call): Update.
	* breakpoint.c (insert_bp_location, create_thread_event_breakpoint,
	create_breakpoint): Update.
	* darwin-nat-info.c (darwin_debug_regions): Update.
	* dcache.c (dcache_info): Update.
	* dsrec.c (load_srec, make_srec): Update.
	* dwarf2-frame.c (dwarf2_restore_rule, execute_cfa_program,
	dwarf2_frame_cache): Update.
	* gcore.c (gcore_copy_callback): Update.
	* gnu-nat.c (gnu_xfer_memory): Update.
	* mips-linux-nat.c (mips_show_dr): Update.
	* monitor.c (monitor_write_memory, monitor_insert_breakpoint,
	monitor_remove_breakpoint): Update.
	* remote.c (compare_sections_command): Update.
	* remote-m32r-sdi.c (m32r_xfer_memory, m32r_insert_breakpoint,
	m32r_remove_breakpoint, m32r_insert_watchpoint,
	m32r_remove_watchpoint): Update.
	* sol-thread.c (info_cb): Update.
	* symfile.c (load_progress): Update.

	Update callers of paddress or paddr_nz to use hex_string instead
	(changes output of internal/error/debug messages only):
	* dwarf2read.c (dump_die_shallow): Update.
	* frame.c (fprint_field, fprint_frame, frame_pc_unwind,
	get_frame_func, create_new_frame): Update.
	* hppa-tdep.c (find_unwind_entry, unwind_command): Update.
	* ia64-tdep.c (get_kernel_table, ia64_find_proc_info_x,
	ia64_get_dyn_info_list): Update.
	* maint.c (maintenance_translate_address): Update.
	* mi/mi-cmd-var.c (mi_cmd_var_create): Update.
	* target.c (target_flash_erase): Update.

	Update callers of paddr/paddr_nz to use phex/phex_nz instead,
	using an appropriate address size.  Remove use of strlen_paddr.
	* exec.c (exec_files_info): Update.
	* i386-nat.c (i386_show_dr): Update.
	* remote.c (remote_flash_erase): Update.
	* m32r-rom.c (m32r_load_section): Update.
	* monitor.c (monitor_vsprintf, monitor_store_register): Update.
	* remote.c (remote_check_symbols, remote_search_memory): Update.
	* remote-mips.c (mips_request, mips_common_breakpoint): Update.
	* scm-valprint.c (scm_ipruk, scm_scmval_print): Update.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Update.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs,
	sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs,
	sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs,
	sh_dsp_show_regs): Update.
	* xcoffsolib.c (sharedlibrary_command): Update.


	* maint.c (maint_print_section_info): Add ADDR_SIZE parameter.
	Use hex_string_custom instead of paddr.
	(print_bfd_section_info): Pass address size.
	(print_objfile_section_info): Likewise.

	* annotate.h (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* annotate.c (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* source.c (identify_source_line): Update call to annotate_source.
	* stack.c (print_frame_info, print_frame): Update call to
	annotate_frame_begin.

	* breakpoint.c (describe_other_breakpoints): Add GDBARCH parameter.
	(create_breakpoint, create_ada_exception_breakpoint): Update call.

	* stack.c (print_block_frame_labels): Add GDBARCH parameter.
	(print_frame_label_vars): Update call.

	* symmisc.c (print_partial_symbols): Add GDBARCH parameter.
	(dump_psymtab): Update call to print_partial_symbols.
	(struct print_symbol_args): Add GDBARCH member.
	(dump_symtab_1): Set print_symbol_args architecture member.
	(print_symbol): Use it.

	* windows-tdep.h (windows_xfer_shared_library): Add GDBARCH
	parameter.
	* windows-tdep.c (windows_xfer_shared_library): Likewise.
	* i386-cygwin-tdep.c (struct cpms_data): Add GDBARCH member.
	(core_process_module_section): Pass architecture from cpms_data to
	windows_xfer_shared_library.
	(windows_core_xfer_shared_libraries): Initialize cmps_data
	architecture member.
	* windows-nat.c (windows_xfer_shared_libraries): Pass architecture
	to windows_xfer_shared_library.

	* defs.h (print_address): Add GDBARCH parameter.
	* printcmd.c (print_address): Add GDBARCH parameter.
	(print_scalar_formatted, do_examine): Update call.
	* findcmd.c (find_command): Update call.
	* tracepoint.c: Include "arch-utils.h".
	(trace_find_line_command): Update call.
	* tui/tui-disasm.c (tui_disassemble): Update call.

	* value.h (print_address_demangle): Add GDBARCH parameter.
	* printcmd.c (print_address_demangle): Add GDBARCH parameter.
	* c-valprint.c (print_function_pointer_address, c_val_print):
	Update call.
	* f-valprint.c (f_val_print): Update call.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update call.
	* jv-valprint.c (java_val_print): Update call.
	* m2-valprint.c (print_function_pointer_address, m2_val_print):
	Update call.
	* p-valprint.c (pascal_val_print): Update call.

	* disasm.c (gdb_disassemble_info): Install architecture into
	di.application_data field.

testsuite/ChangeLog:

	* gdb.threads/tls-shared.exp: Update to locexpr_describe_location
	change to prefix TLS offset in hex with 0x.

doc/ChangeLog:

	* gdbint.texinfo (Item Output Functions): Update signature
	for ui_out_field_core_addr.
@
text
@d1292 2
a1293 2
  /* Only handle Ctrl-C event.  Ignore others.  */
  if (event_type != CTRL_C_EVENT)
@


1.196.4.1
log
@	* windows-nat.c (ctrl_c_handler): Also handle CTRL_BREAK_EVENT.
	* doc/gdb.texinfo (Cygwin Native): Mention support for Ctrl-BREAK.
@
text
@d1292 2
a1293 2
  /* Only handle Ctrl-C and Ctrl-Break events.  Ignore others.  */
  if (event_type != CTRL_C_EVENT && event_type != CTRL_BREAK_EVENT)
@


1.195
log
@	* ada-tasks.c (read_known_tasks_array): Use target_gdbarch instead
	of current_gdbarch.
	* aix-thread.c (pd_enable): Likewise.
	* amd64-linux-nat.c (ps_get_thread_area): Likewise.
	* bsd-uthread.c (bsd_uthread_activate): Likewise.
	* linux-nat.c (linux_nat_info_proc_cmd): Likewise.
	* linux-thread-db.c (enable_thread_event): Likewise.
	* monitor.c (monitor_write_memory, monitor_read_memory): Likewise.
	* nto-procfs.c (procfs_open): Likewise.
	* procfs.c (invalidate_cache, procfs_insert_watchpoint,
	info_proc_mappings, info_mappings_callback): Likewise.
	* record.c (record_open): Likewise.
	* rs6000-nat.c (ARCH64): Likewise.
	* solib-darwin.c (darwin_solib_create_inferior_hook): Likewise.
	(darwin_bfd_open): Likewise.
	* memattr.c (mem_info_command): Likewise.

	* windows-nat.c (win32_resume): Use current regcache architecture
	instead of current_gdbarch.

	* dbug-rom.c (dbug_regname): Remove check against number of
	registers in current_gdbarch.
	* solib-pa64.c (read_dynamic_info): Remove unused variable.
@
text
@d2085 1
a2085 1
				 &obstack);
@


1.194
log
@2009-06-16  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* solib.c (symbol_add_stub): New FLAGS parameter.
	(solib_read_symbols): FROM_TTY -> FLAGS, call symbol_add_stub
	directly.
	(solib_add): Defer breakpoint_re_set until after all solibs.
	* bsd-uthread.c (bsd_uthread_solib_loaded): Adjust.
	* rs6000-nat.c (objfile_symbol_add): Adjust.
	* symfile.c (syms_from_objfile): Merge parameters into ADD_FLAGS.
	(new_symfile_objfile): Likewise.
	(symbol_file_add_with_addrs_or_offsets): Likewise.
	(symbol_file_add_from_bfd): Likewise.
	(symbol_file_add): Likewise.
	* symfile.h (enum symfile_add_flags): New. Adjust prototypes.
	* symfile-mem.c (symbol_file_add_from_memory): Adjust.
	* windows-nat.c (safe_symbol_file_add_stub): Adjust.
	* machoread.c (macho_oso_symfile, macho_symfile_read): Adjust.
@
text
@d1251 4
a1254 3
	  windows_fetch_inferior_registers (ops,
					    get_current_regcache (),
					    gdbarch_ps_regnum (current_gdbarch));
@


1.193
log
@	* target.h (struct target_ops): Make to_has_all_memory,
	to_has_memory, to_has_stack, to_has_registers and to_has_execution
	methods instead of variables.
	(target_has_all_memory_1, target_has_memory_1, target_has_stack_1)
	(target_has_registers_1, target_has_execution_1): Declare
	functions.
	(target_has_all_memory): Rewrite to call target_has_all_memory_1.
	(target_has_memory): Rewrite to call target_has_memory_1.
	(target_has_stack): Rewrite to call target_has_all_stack_1.
	(target_has_registers): Rewrite to call target_has_registers_1.
	(target_has_execution): Rewrite to call target_has_execution_1.
	(default_child_has_all_memory, default_child_has_memory)
	(default_child_has_stack, default_child_has_registers)
	(default_child_has_execution): Declare.
	(target_mark_running, target_mark_exited): Delete declarations.
	* target.c (default_child_has_all_memory,
	default_child_has_memory, default_child_has_stack,
	default_child_has_registers, default_child_has_execution): New.
	(target_has_all_memory_1, target_has_memory_1, target_has_stack_1,
	target_has_registers_1, target_has_execution_1): New.
	(add_target): Default the to_has_all_memory, to_has_all_memory,
	to_has_memory, to_has_stack, to_has_registers and to_has_execution
	callbacks to return 0.
	(update_current_target): Do not inherit to_has_all_memory,
	to_has_memory, to_has_stack, to_has_registers or to_has_execution.
	(target_mark_running, target_mark_exited): Delete.
	(memory_xfer_partial): Adjust.
	(target_read_memory, target_write_memory, target_search_memory):
	Dispatch to the the top-most target, not the flattened
	current_target.
	(target_info): Adjust.
	(init_dummy_target): Install return_zero as callback for
	to_has_all_memory, to_has_memory, to_has_stack, to_has_registers,
	to_has_execution.
	(set_maintenance_target_async_permitted): Use have_live_inferiors
	instead of target_has_execution.
	* target-memory.c (target_write_memory_blocks): Dispatch memory
	writes to the the top-most target, not the flattened
	current_target.

	* breakpoint.c (insert_breakpoints): Don't check for
	target_has_execution here.
	(update_global_location_list): Check if there are live inferiors
	to debug instead of target_has_execution.
	* infcmd.c (kill_command, detach_command): Check if there are
	inferiors instead of target_has_execution.
	* inferior.h (have_live_inferiors): Declare.
	* inferior.c (have_live_inferiors): New.
	* infrun.c (normal_stop): Don't check for target_has_execution to
	finish the thread states.
	* thread.c (is_thread_state, is_stopped, is_exited, is_running)
	(any_running, is_executing): Remove checks for
	target_has_execution.
	* top.c (kill_or_detach): Don't try to kill core inferiors.
	(quit_target): Don't check for target_has_execution.

	* corelow.c (core_has_memory, core_has_stack, core_has_registers):
	New.
	(init_core_ops): Install core_has_memory, core_has_stack and
	core_has_registers.
	* exec.c (exec_has_memory): New.
	(init_exec_ops): Install exec_has_memory.
	* remote.c (remote_add_inferior): Don't call target_mark_running.
	(remote_start_remote): Don't call target_mark_exited or call
	target_mark_running.
	(remote_open_1): Use have_inferiors instead of
	target_has_execution.  Don't use target_mark_exited.
	(init_remote_ops): Install deafult_child_has_all_memory,
	default_child_has_memory, default_child_has_stack,
	default_child_has_registers, default_child_has_execution.
	* bsd-kvm.c (bsd_kvm_return_one): New.
	(bsd_kvm_add_target): Register bsd_kvm_return_one as
	to_has_memory, to_has_stack and to_has_registers callbacks.
	* remote-m32r-sdi.c (m32r_return_one): New.
	(init_m32r_ops): Register it.
	* inf-child.c (inf_child_target): Adjust to register
	default_child_has_all_memory, default_child_has_memory,
	default_child_has_stack, default_child_has_registers,
	default_child_has_execution callbacks.
	* gnu-nat.c (init_gnu_ops): Likewise.
	* go32-nat.c (init_go32_ops): Likewise.
	* hpux-thread.c (init_hpux_thread_ops): Likewise.
	* monitor.c (init_base_monitor_ops): Likewise.
	* nto-procfs.c (init_procfs_ops): Likewise.
	* remote-mips.c (_initialize_remote_mips): Likewise.
	* windows-nat.c (init_windows_ops): Likewise.
	* remote-sim.c (gdbsim_create_inferior): Don't use
	target_mark_running or target_mark_exited.
	(gdbsim_mourn_inferior): Don't call target_mark_exited.
	(init_gdbsim_ops): Adjust to register
	default_child_has_all_memory, default_child_has_memory,
	default_child_has_stack, default_child_has_registers,
	default_child_has_execution callbacks.

	* linux-nat.c (linux_nat_xfer_partial): If reading memory, and
	there's no inferior selected, defer to a lower stratum.
@
text
@d559 3
a561 1
  p->ret = symbol_file_add (p->name, p->from_tty, p->addrs, p->mainline, p->flags);
@


1.192
log
@	* symfile.c (add_shared_symbol_files_command): Remove
	prototype and function.
	(_initialize _symfile): Move "add-shared-symbol-files"
	command and "assf" alias.
	* windows-nat.c (_initialize_windows_nat): to here.
	Change "add-shared-symbol-files" to alias.

	* config/i386/cygwin.mh: Remove NAT_FILE.
	* config/i386/mingw.mh: Remove NAT_FILE.
	* config/i386/mingw64.mh: Remove NAT_FILE.
	* config/i386/nm-cygwin.h: Remove file.
	* config/i386/nm-cygwin64.h: Remove file.
@
text
@d2167 5
a2171 5
  windows_ops.to_has_all_memory = 1;
  windows_ops.to_has_memory = 1;
  windows_ops.to_has_stack = 1;
  windows_ops.to_has_registers = 1;
  windows_ops.to_has_execution = 1;
@


1.191
log
@	* target.h (TARGET_WNOHANG): New.
	* target.c (target_wait): Add `options' argument.  Adjust.
	(struct target_ops) <to_wait>: Add `options' argument.
	(target_wait): Add `options' argument.
	* infrun.c (wait_for_inferior): Pass 0 as options to
	target_wait (blocking wait).
	(fetch_inferior_event): Pass TARGET_WNOHANG as options to
	target_wait.
	* fork-child.c (startup_inferior): Pass 0 as options to
	target_wait (blocking wait).
	* linux-nat.c (linux_nat_create_inferior): Remove async masking.
	(linux_nat_wait_1): Add `target_options' argument.  Use it instead
	of checking on target_can_async_p.
	(linux_nat_wait): Add `target_options' argument.  Adjust.
	* remote.c (remote_wait_ns): Add `options' argument.  Adjust to
	check on TARGET_WNOWAIT instead of checking on remote_is_async_p.
	(remote_wait_as): Add `options' argument.  Adjust to check on
	TARGET_WNOWAIT instead of checking on remote_is_async_p.  If doing
	a blocking wait, keep waiting until an interesting event comes
	out.
	(remote_wait): Add `options' argument.  Don't loop here if the
	target is in async mode, and a blocking wait has been requested.

	* top.c (deprecated_target_wait_hook): Add `options' argument.
	* linux-thread-db.c (thread_db_wait): Add `options' argument, and
	pass it down to the layer beneath.
	* inf-ptrace.c (inf_ptrace_wait): Add `options' argument.
	* record.c (record_beneath_to_wait): Add `options' argument.
	(record_wait): Add `options' argument, and pass it down to the
	layer beneath.
	* bsd-uthread.c (bsd_uthread_wait): Add `options' argument.
	* darwin-nat.c (darwin_wait): Likewise.
	* defs.h (deprecated_target_wait_hook): Likewise.
	* gnu-nat.c (gnu_wait): Add `options' argument.
	* go32-nat.c (go32_wait): Likewise.
	* hpux-thread.c (hpux_thread_wait): Add `options' argument, and
	pass it down to the layer beneath.
	* inf-ttrace.c (inf_ttrace_wait): Add `options' argument.
	* monitor.c (monitor_wait): Likewise.
	* nto-procfs.c (procfs_wait): Likewise.
	* remote-mips.c (mips_wait): Add `options' argument.
	* remote-sim.c (gdbsim_wait): Likewise.
	* rs6000-nat.c (rs6000_wait): Add `options' argument.
	* sol-thread.c (sol_thread_wait): Add `options' argument, and pass
	it down to the layer beneath.
	* spu-linux-nat.c (spu_child_wait): Add `options' argument.
	* windows-nat.c (windows_wait): Likewise.
	* tui/tui-hooks.c (tui_target_wait_hook): Likewise.  Adjust.
@
text
@d2208 4
@


1.190
log
@	Remove all i386 debug register low level macros in config nm files.
	(I386_DR_LOW_SET_ADDR, I386_DR_LOW_RESET_ADDR): Remove.
	(I386_DR_LOW_GET_STATUS, I386_DR_LOW_SET_CONTROL): Remove.
	(I386_USE_GENERIC_WATCHPOIINTS): Remove.

	* i386-nat.h: New file (adapted from config/i386/nm-i386.h).
	(struct i386_dr_low_type): New type.
	(i386_dr_low): New global variable.
	* i386-nat.c (TARGET_HAS_DR_LEN_8): Update macro.
	(i386_insert_aligned_watchpoint): Replace i386 dr low macros by
	i386_dr_low struct variable fields.
	(i386_remove_aligned_watchpoint): Likewise.
	(i386_stopped_data_address): Likewise.
	(i386_stopped_by_hwbp): Likewise.
	(show_debug_regs_command_added): New static variable.
	(add_show_debug_regs_command): New static function.
	(i386_use_watchpoints): Call add_show_debug_regs_command if not done.
	(i386_set_debug_register_length): New function.
	(_initialize_i386_nat): Delete.

	* amd64-linux-nat.c: Include "i386-nat.h".
	(amd64_linux_dr_set_control):  Change to static.
	(amd64_linux_dr_get_status): Change to static.
	(amd64_linux_dr_set_addr,amd64_linux_dr_reset_addr): Likewise.
	(_initialize_amd64_linux_nat): Set i386_dr_low variable fields.

	* go32-nat.c: Include "i386-nat.h".
	(go32_set_addr): Change to static.
	(go32_set_dr7): Change to static. Change arg type to unisgned long.
	(go32_get_dr6): Change to static. Change return type to unisnged long.
	(init_go32_ops):  Set i386_dr_low variable fields.
	* i386-linux-nat.c: Include "i386-nat.h".
	(i386_linux_dr_set_control, i386_linux_dr_get_status): Change to static.
	(i386_linux_dr_set_addr, i386_linux_dr_reset_addr): Idem.
	(_initialize_i386_linux_nat):  Set i386_dr_low variable fields.
	* i386bsd-nat.h: Declare functions used for
	i386_dr_low fields in i386fbsd-nat.c.
	* i386fbsd-nat.c: Include "i386-nat.h".
	(_initialize_i386fbsd_nat): Set i386_dr_low variable fields.
	* windows-nat.c: Include "i386-nat.h".
	(cygwin_set_dr, cygwin_get_dr6, cygwin_set_dr7): Add prototypes.
	Change to static.
	(cygwin_get_dr6): Change return type to unisnged long.
	(cygwin_set_dr7): Change arg type to unisgned long.
	(init_windows_ops): Set i386_dr_low function fields.

	* amd64-windows-nat.c (_initialize_amd64_windows_nat): Call
	i386_set_debug_register_length.
	* i386-windows-nat.c (_initialize_i386_windows_nat): Likewise.

	* config/i386/nm-cygwin.h: Remove all I386_* macros.
	* config/i386/nm-cygwin64.h: Likewise.
	* config/i386/nm-fbsd.h: Likewise.
	* config/i386/nm-linux.h: Likewise.
	* config/i386/nm-i386.h: Remove completely.
	* config/i386/nm-go32.h: Remove completely.
	* config/i386/nm-linux64.h: Remove completely.
	* config/i386/go32.mh (NAT_FILE): Remove entry.
	* config/i386/linux64.h (NAT_FILE): Change to config/nm-linux.h.
@
text
@d1497 1
a1497 1
	      ptid_t ptid, struct target_waitstatus *ourstatus)
@


1.189
log
@	ARI fix: Do not use %p, replace by call to host_address_to_string
	for host pointers.
	* darwin-nat.c (darwin_xfer_partial): Apply change.
	* gnu-nat.c (inf_continue, gnu_xfer_memory): Ditto.
	* gnu-nat.h (proc_debug): Ditto.
	* symmisc.c (maintenance_info_symtabs): Ditto.
	(maintenance_info_psymtabs): Ditto.
	* windows-nat.c (handle_load_dll): Ditto.
	(handle_unload_dll, info_w32_command, handle_exception): Ditto.
	* xtensa-tdep.c (xtensa_unwind_pc): Ditto.
@
text
@d66 1
d144 4
d2174 1
d2177 9
d2283 1
a2283 1
void
d2297 2
a2298 2
void
cygwin_set_dr7 (unsigned val)
d2300 1
a2300 1
  dr[7] = val;
d2308 1
a2308 1
unsigned
d2311 1
a2311 1
  return dr[6];
@


1.188
log
@        * windows-nat.c (+windows_get_ada_task_ptid): New function.
        (init_windows_ops): Set windows_ops.to_get_ada_task_ptid.
@
text
@d743 2
a744 2
  DEBUG_EVENTS (("gdb: Loading dll \"%s\" at %p.\n", solib_end->so_name,
		 solib_end->lm_info->load_addr));
d777 2
a778 1
  error (_("Error: dll starting at %p not found."), lpBaseOfDll);
d990 3
a992 2
  printf_unfiltered ("gdb: Target exception %s at %p\n", x, \
		     current_event.u.Exception.ExceptionRecord.ExceptionAddress)
d1103 4
a1106 3
      printf_unfiltered ("gdb: unknown target exception 0x%08lx at %p\n",
		    current_event.u.Exception.ExceptionRecord.ExceptionCode,
		    current_event.u.Exception.ExceptionRecord.ExceptionAddress);
@


1.187
log
@* windows-nat.c (AdjustTokenPrivileges): Implement macro wraparound for
dynamically loaded function.
(LookupPrivilegeValueA): Ditto.
(OpenProcessToken): Ditto.
(AdjustTokenPrivileges): Rename and define placeholder for address of
dynamically loaded function.
(LookupPrivilegeValueA): Ditto.
(OpenProcessToken): Ditto.
(set_process_privilege): Remove check for loaded functions.
(bad_OpenProcessToken): Define.
(_initialize_loadable): Load token functions from advapi here, setting
OpenProcessToken function to a dummy static function which always return error
if OS doesn't support this functionality.
@
text
@d2118 6
d2165 1
@


1.186
log
@* win32-nat.c (ctrl_c_handler): New function.
(win32_wait): Register ctrl_c_handler as Ctrl-C handler if the inferior is run
in a separate console.
@
text
@d67 1
d74 2
d77 2
a78 5
/* Since Windows XP, detaching from a process is supported by Windows.
   The following code tries loading the appropriate functions dynamically.
   If loading these functions succeeds use them to actually detach from
   the inferior process, otherwise behave as usual, pretending that
   detach has worked. */
d88 2
a1614 6
  static HMODULE advapi32 = NULL;
  static BOOL WINAPI (*OpenProcessToken)(HANDLE, DWORD, PHANDLE);
  static BOOL WINAPI (*LookupPrivilegeValue)(LPCSTR, LPCSTR, PLUID);
  static BOOL WINAPI (*AdjustTokenPrivileges)(HANDLE, BOOL, PTOKEN_PRIVILEGES,
					      DWORD, PTOKEN_PRIVILEGES, PDWORD);

a1620 23
  if (GetVersion () >= 0x80000000)  /* No security availbale on 9x/Me */
    return 0;

  if (!advapi32)
    {
      if (!(advapi32 = LoadLibrary ("advapi32.dll")))
	goto out;
      if (!OpenProcessToken)
	OpenProcessToken =
	  (void *) GetProcAddress (advapi32, "OpenProcessToken");
      if (!LookupPrivilegeValue)
	LookupPrivilegeValue =
	  (void *) GetProcAddress (advapi32, "LookupPrivilegeValueA");
      if (!AdjustTokenPrivileges)
	AdjustTokenPrivileges =
	  (void *) GetProcAddress (advapi32, "AdjustTokenPrivileges");
      if (!OpenProcessToken || !LookupPrivilegeValue || !AdjustTokenPrivileges)
	{
	  advapi32 = NULL;
	  goto out;
	}
    }

d1626 1
a1626 1
  if (!LookupPrivilegeValue (NULL, privilege, &restore_priv))
d2366 6
d2422 16
a2437 1
      warning(_("cannot automatically find executable file or library to read symbols.  Use \"file\" or \"dll\" command to load executable/libraries directly."));
@


1.185
log
@* windows-nat.c (DebugActiveProcessStop): Implement macro wraparound for
dynamically loaded function.
(DebugBreakProcess): Ditto.
(DebugSetProcessKillOnExit): Ditto.
(EnumProcessModules): Ditto.
(GetModuleFileNameExA): Ditto.
(GetModuleInformation): Ditto.
(DebugActiveProcessStop): Rename and define placeholder for address of
dynamically loaded function.  for dynamically loaded function.
(DebugBreakProcess): Ditto.
(DebugSetProcessKillOnExit): Ditto.
(EnumProcessModules): Ditto.
(GetModuleFileNameExA): Ditto.
(GetModuleInformation): Ditto.
(psapi_loaded): Delete.
(get_module_name): Don't check psapi_loaded, just rely on the fact that
dynamically loaded functions will return failure if they weren't previously
found.
(has_detach_ability): Delete.
(windows_attach): Remove call to has_detach_ability ().  Just rely on functions
being callable.
(bad_DebugActiveProcessStop): Define.
(bad_DebugBreakProcess): Ditto.
(bad_DebugSetProcessKillOnExit): Ditto.
(bad_EnumProcessModules): Ditto.
(bad_GetModuleFileNameExA): Ditto.
(bad_GetModuleInformation): Ditto.
(_initialize_loadable): Rename from _initialize_psapi.  Initialize all dynamic
storage here, setting nonexistent functions to dummy static functions which
always return error.
@
text
@d1270 26
d1297 1
a1297 2
   handling by WFI (or whatever).
 */
d1374 2
a1375 2
 	windows_delete_thread (ptid_build (current_event.dwProcessId, 0,
					 main_thread_id));
d1379 2
a1380 2
					 current_event.dwThreadId),
			     current_event.u.CreateProcessInfo.hThread);
d1503 27
a1529 14
      /* Ignore CTRL+C signals while waiting for a debug event.
	 FIXME: brobecker/2008-05-20: When the user presses CTRL+C while
	 the inferior is running, both the inferior and GDB receive the
	 associated signal.  If the inferior receives the signal first
	 and the delay until GDB receives that signal is sufficiently long,
	 GDB can sometimes receive the SIGINT after we have unblocked
	 the CTRL+C handler.  This would lead to the debugger to stop
	 prematurely while handling the new-thread event that comes
	 with the handling of the SIGINT inside the inferior, and then
	 stop again immediately when the user tries to resume the execution
	 in the inferior.  This is a classic race, and it would be nice
	 to find a better solution to that problem.  But in the meantime,
	 the current approach already greatly mitigate this issue.  */
      SetConsoleCtrlHandler (NULL, TRUE);
d1531 1
a1531 1
      SetConsoleCtrlHandler (NULL, FALSE);
@


1.184
log
@        Add a target_ops parameter to the to_kill method in struct target_ops.

        * target.h (struct target_ops): Add a "target_ops *" parameter to
        method to_kill.
        (target_kill): Remove macro. Add declaration.
        * target.c (debug_to_kill): Delete, no longer necessary.
        (target_kill): New function.
        (update_current_target):  Stop inheriting the to_kill method.
        Do not de_fault it to no_process either.
        (setup_target_debug): Do not set current_target.to_kill.
        * gnu-nat.c, go32-nat.c, hpux-thread.c, inf-ptrace.c, inf-ttrace.c,
        linux-nat.c, monitor.c, nto-procfs.c, procfs.c, remote-m32r-sdi.c,
        remote-mips.c, remote-sim.c, remote.c, windows-nat.c: Update
        accordingly.
@
text
@d41 1
d67 22
a109 1
#include <psapi.h>
d391 1
a391 1
	  /* Copy dr values from that thread. 
a462 8
static int psapi_loaded = 0;
static BOOL WINAPI (*psapi_EnumProcessModules) (HANDLE, HMODULE *, DWORD,
						LPDWORD);
static BOOL WINAPI (*psapi_GetModuleInformation) (HANDLE, HMODULE, LPMODULEINFO,
						  DWORD);
static DWORD WINAPI (*psapi_GetModuleFileNameExA) (HANDLE, HMODULE, LPSTR,
						   DWORD);

a481 5
  /* If psapi_loaded < 0 either psapi.dll is not available or it does not contain
     the needed functions. */
  if (psapi_loaded <= 0)
    goto failed;

d484 2
a485 2
  if (!psapi_EnumProcessModules (current_process_handle, DllHandle,
				 sizeof (HMODULE), &cbNeeded) || !cbNeeded)
d494 1
a494 1
  if (!psapi_EnumProcessModules (current_process_handle, DllHandle, cbNeeded,
d501 2
a502 2
      if (!psapi_GetModuleInformation (current_process_handle, DllHandle[i],
				       &mi, sizeof (mi)))
d508 2
a509 2
	  len = psapi_GetModuleFileNameExA (current_process_handle,
					    DllHandle[i], pathbuf, MAX_PATH);
d988 1
a988 1
          current_event.u.Exception.ExceptionRecord.ExceptionAddress)
d1101 1
a1101 1
	        current_event.u.Exception.ExceptionRecord.ExceptionAddress);
d1477 1
a1477 1
      
d1479 12
a1490 12
         FIXME: brobecker/2008-05-20: When the user presses CTRL+C while
         the inferior is running, both the inferior and GDB receive the
         associated signal.  If the inferior receives the signal first
         and the delay until GDB receives that signal is sufficiently long,
         GDB can sometimes receive the SIGINT after we have unblocked
         the CTRL+C handler.  This would lead to the debugger to stop
         prematurely while handling the new-thread event that comes
         with the handling of the SIGINT inside the inferior, and then
         stop again immediately when the user tries to resume the execution
         in the inferior.  This is a classic race, and it would be nice
         to find a better solution to that problem.  But in the meantime,
         the current approach already greatly mitigate this issue.  */
a1565 30
/* Since Windows XP, detaching from a process is supported by Windows.
   The following code tries loading the appropriate functions dynamically.
   If loading these functions succeeds use them to actually detach from
   the inferior process, otherwise behave as usual, pretending that
   detach has worked. */
static BOOL WINAPI (*kernel32_DebugSetProcessKillOnExit)(BOOL);
static BOOL WINAPI (*kernel32_DebugActiveProcessStop)(DWORD);

static int
has_detach_ability (void)
{
  static HMODULE kernel32 = NULL;

  if (!kernel32)
    kernel32 = LoadLibrary ("kernel32.dll");
  if (kernel32)
    {
      if (!kernel32_DebugSetProcessKillOnExit)
	kernel32_DebugSetProcessKillOnExit =
	  (void *) GetProcAddress (kernel32, "DebugSetProcessKillOnExit");
      if (!kernel32_DebugActiveProcessStop)
	kernel32_DebugActiveProcessStop =
	  (void *) GetProcAddress (kernel32, "DebugActiveProcessStop");
      if (kernel32_DebugSetProcessKillOnExit
	  && kernel32_DebugActiveProcessStop)
	return 1;
    }
  return 0;
}

d1596 1
a1596 1
          (void *) GetProcAddress (advapi32, "OpenProcessToken");
d1599 1
a1599 1
          (void *) GetProcAddress (advapi32, "LookupPrivilegeValueA");
d1602 1
a1602 1
          (void *) GetProcAddress (advapi32, "AdjustTokenPrivileges");
d1680 1
a1680 2
  if (has_detach_ability ())
    kernel32_DebugSetProcessKillOnExit (FALSE);
d1705 4
a1708 1
  if (has_detach_ability ())
d1710 5
a1714 2
      ptid_t ptid = {-1};
      windows_resume (ops, ptid, 0, TARGET_SIGNAL_0);
a1715 8
      if (!kernel32_DebugActiveProcessStop (current_event.dwProcessId))
	{
	  error (_("Can't detach process %lu (error %lu)"),
		 current_event.dwProcessId, GetLastError ());
	  detached = 0;
	}
      kernel32_DebugSetProcessKillOnExit (FALSE);
    }
d1973 1
a1973 1
      if (!WriteProcessMemory (current_process_handle, 
d1977 1
a1977 1
      FlushInstructionCache (current_process_handle, 
d1984 1
a1984 1
      if (!ReadProcessMemory (current_process_handle, 
d2322 35
d2358 1
a2358 1
_initialize_psapi (void)
d2360 23
d2385 2
a2386 1
  if (!psapi_loaded)
d2388 18
a2405 16
      HMODULE psapi_module_handle;

      psapi_loaded = -1;

      psapi_module_handle = LoadLibrary ("psapi.dll");
      if (psapi_module_handle)
	{
	  psapi_EnumProcessModules = (void *) GetProcAddress (psapi_module_handle, "EnumProcessModules");
	  psapi_GetModuleInformation = (void *) GetProcAddress (psapi_module_handle, "GetModuleInformation");
	  psapi_GetModuleFileNameExA = (void *) GetProcAddress (psapi_module_handle, "GetModuleFileNameExA");

	  if (psapi_EnumProcessModules != NULL
	      && psapi_GetModuleInformation != NULL
	      && psapi_GetModuleFileNameExA != NULL)
	    psapi_loaded = 1;
	}
a2406 5

  /* This will probably fail on Windows 9x/Me.  Let the user know that we're
     missing some functionality. */
  if (psapi_loaded < 0)
    warning(_("cannot automatically find executable file or library to read symbols.  Use \"file\" or \"dll\" command to load executable/libraries directly."));
@


1.183
log
@* windows-nat.c (dr): Redefine to use largest possible integer which holds a
pointer.
(cygwin_set_dr): Avoid coercion.
* windows-nat.c (windows_create_inferior): implement --tty handling on
non-cygwin.
@
text
@d117 1
a117 1
static void windows_kill_inferior (void);
d1496 1
a1496 1
	    windows_kill_inferior ();
d2017 1
a2017 1
windows_kill_inferior (void)
@


1.182
log
@	Fix windows-nat.c compilation failure.

	* windows-nat.c (windows_thread_alive): Fix forward declaration.
	(get_windows_debug_event): Add ops parameter to call to windows_resume.
@
text
@d98 1
a98 1
static unsigned dr[8];
d1818 1
d1821 3
d1893 22
d1940 3
d2277 1
a2277 1
  dr[i] = (unsigned) addr;
@


1.181
log
@	* corelow.c (get_core_registers): Adjust.
	(core_file_thread_alive): Rename to...
	(core_thread_alive): ... this.
	(core_pid_to_str): Try gdbarch_core_pid_to_str first.
	(init_core_ops): Adjust.
	(coreops_suppress_target): Delete.
	(_initialize_corelow): Unconditionally add core_ops.
	* procfs.c: Include "inf-child.h".
	(procfs_ops): Delete.
	(init_procfs_ops): Delete.  Reimplement as...
	(procfs_target): ... this, inheriting from inf-child.
	(procfs_attach, procfs_detach, procfs_fetch_registers): Adjust.
	(procfs_prepare_to_store): Delete.
	(procfs_store_registers, procfs_resume): Adjust.
	(procfs_open): Delete.
	(procfs_suppress_run): Delete.
	(procfs_can_run): Delete.
	(procfs_mourn_inferior): Adjust.
	(procfs_init_inferior): Add target_ops parameter.  Adjust.
	(procfs_create_inferior): Don't pass procfs_init_inferior to
	fork_inferior.  Instead call it after fork_inferior returns.
	(procfs_find_new_threads): Adjust.
	(_initialize_procfs): Adjust to use procfs_target instead of
	init_procfs_ops.
	* sol-thread.c (orig_core_ops, sol_core_ops): Delete.
	(lwp_to_thread): Use target_thread_alive.
	(sol_thread_open): Delete.
	(sol_thread_attach): Delete.
	(sol_thread_detach, sol_thread_resume, sol_thread_wait)
	(sol_thread_fetch_registers, sol_thread_store_registers): Adjust
	to use find_target_beneath.
	(sol_thread_prepare_to_store, sol_thread_xfer_memory): Delete.
	(sol_thread_xfer_partial): Adjust to use find_target_beneath.
	(sol_thread_files_info, sol_thread_kill_inferior): Delete.
	(check_for_thread_db): New.
	(sol_thread_notice_signals, sol_thread_create_inferior): Delete.
	(sol_thread_new_objfile): Call check_for_thread_db.
	(sol_thread_mourn_inferior): Adjust to use find_target_beneath.
	(sol_thread_can_run): Delete.
	(sol_thread_alive): Adjust to use find_target_beneath.
	(sol_thread_stop): Delete.
	(rw_common): Use target_write_memory or target_read_memory.
	(ps_lgetregs, ps_lgetfpregs): Use target_fetch_registers.
	(ps_lsetregs, ps_lsetfpregs): Use target_store_registers.
	(solaris_pid_to_str): Remove check for libthread_db initialization
	failing.
	(sol_find_new_threads): Remove check for libthread_db
	initialization failing, or for an invalid inferior_ptid.  Adjust
	to use find_target_beneath.
	(sol_core_open, sol_core_close, sol_core_detach,
	sol_core_files_info, sol_find_memory_regions,
	sol_make_note_section, ignore): Delete.
	(init_sol_thread_ops): Make it a thread_stratum target.  Remove
	unneeded callback settings.
	(init_sol_core_ops): Delete.
	(_initialize_sol_thread): No longer call init_sol_core_ops, set
	procfs_suppress_run, or hack with core_ops.

	* target.h (struct target_ops): Add a target_ops * parameter to
	to_resume, to_fetch_registers, to_store_registers, to_thread_alive
	and to_find_new_threads.
	(target_fetch_registers, target_store_registers)
	(target_thread_alive, target_find_new_threads): Redeclare as
	function.

	* target.c (update_current_target): Do not inherit or de_fault
	to_resume, to_fetch_registers, to_store_registers,
	to_thread_alive, to_find_new_threads.
	(target_resume): Adjust.
	(target_thread_alive, target_find_new_threads): New.
	(debug_to_resume, debug_to_fetch_registers): Delete.
	(target_fetch_registers): New.
	(debug_to_store_registers): Delete.
	(target_store_registers): New.
	(debug_to_thread_alive, debug_to_find_new_threads): Delete.
	(setup_target_debug): Adjust.

	* gdbcore.h (core_ops): Delete declaration.

	* inf-ptrace.c, linux-nat.c, remote.c, amd64-linux-nat.c,
	inf-child.c, linux-thread-db.c, bsd-uthread.c, inf-ttrace.c,
	i386-sol2-tdep.c, darwin-nat.c, gnu-nat.c, go32-nat.c,
	hpux-thread.c, i386-linux-nat.c, i386fbsd-nat.c, monitor.c,
	nto-procfs.c, remote-m32r-sdi.c, remote-mips.c, windows-nat.c,
	alphabsd-nat.c, amd64bsd-nat.c, arm-linux-nat.c, armnbsd-nat.c,
	bsd-kvm.c, hppa-hpux-nat.c, hppa-linux-nat.c, hppabsd-nat.c,
	hppanbsd-nat.c, i386-darwin-nat.c, i386bsd-nat.c,
	ia64-linux-nat.c, m32r-linux-nat.c, m68kbsd-nat.c,
	m68klinux-nat.c, m88kbsd-nat.c, mips-linux-nat.c,
	mips64obsd-nat.c, mipsnbsd-nat.c, ppc-linux-nat.c, ppcnbsd-nat.c,
	ppcobsd-nat.c, remote-sim.c, rs6000-nat.c, s390-nat.c,
	shnbsd-nat.c, sparc-nat.c, sparc-nat.h, spu-linux-nat.c,
	vaxbsd-nat.c, xtensa-linux-nat.c: Adjust to target_ops changes.

	* gdbarch.sh (core_pid_to_str): New gdbarch callback.
	* gdbarch.h, gdbarch.c: Regenerate.

	* sol2-tdep.c: Include "inferior.h".
	(sol2_core_pid_to_str): New.
	* sol2-tdep.h (sol2_core_pid_to_str): Declare.

	* amd64-sol2-tdep.c (amd64_sol2_init_abi): Set it.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Set it.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Set it.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Set it.
@
text
@d116 1
a116 1
static int windows_thread_alive (ptid_t);
d1435 1
a1435 1
	windows_resume (minus_one_ptid, 0, 1);
@


1.180
log
@	* Extend use of i386_use_watchpoints to all i386 native files
	using hardware watchpoints.
	go32-nat.c (init_go32_ops): Call i386_use_watchpoints.
	i386fbsd-nat.c (_initialize_i386fbsd_nat): Ditto.
	windows-nat.c (init_windows_ops): Ditto.
	config/i386/nm-cygwin.h: Define I386_WATCHPOINTS_IN_TARGET_VECTOR.
	config/i386/nm-cygwin64.h: Ditto.
	config/i386/nm-fbsd.h: Ditto.
	config/i386/nm-go32.h: Ditto.
@
text
@d404 2
a405 1
windows_fetch_inferior_registers (struct regcache *regcache, int r)
d431 2
a432 1
windows_store_inferior_registers (struct regcache *regcache, int r)
d1170 2
a1171 1
windows_resume (ptid_t ptid, int step, enum target_signal sig)
d1230 3
a1232 2
	  windows_fetch_inferior_registers (get_current_regcache (),
					  gdbarch_ps_regnum (current_gdbarch));
d1265 2
a1266 1
get_windows_debug_event (int pid, struct target_waitstatus *ourstatus)
d1483 1
a1483 1
      retval = get_windows_debug_event (pid, ourstatus);
d1730 1
a1730 1
      windows_resume (ptid, 0, TARGET_SIGNAL_0);
d2277 1
a2277 1
windows_thread_alive (ptid_t ptid)
@


1.179
log
@	* linux-nat.c (linux_nat_wait): Adjust.
	(linux_nat_pid_to_str): Adjust.  Remove call to thread_db_init.
	* linux-nat.h (thread_db_init): Delete declaration.
	* linux-thread-db.c (target_beneath): Delete.
	(thread_db_init): Delete.
	(thread_db_detach): Use find_target_beneath.
	(thread_db_wait): Adjust interface.  Use find_target_beneath.
	(thread_db_mourn_inferior): Use find_target_beneath.
	(thread_db_can_async_p, thread_db_is_async_p, thread_db_async)
	(thread_db_async_mask): Delete.
	(thread_db_pid_to_str): Adjust interface.  Use
	find_target_beneath.
	(thread_db_get_thread_local_address): Adjust interface.  Use
	find_target_beneath.
	(init_thread_db_ops): Delete references to delete functions.
	* target.c (update_current_target): Don't inherit or default
	to_wait.  Don't inherit to_pid_to_str and
	to_get_thread_local_address.
	(target_translate_tls_address): Look for a pushed target that
	implements to_get_thread_local_address, and use it instead of
	checking for target_get_thread_local_address_p.
	(target_wait, target_pid_to_str): Reimplement as functions.
	(dummy_pid_to_str): New.
	(init_dummy_target): Register it.
	(debug_to_wait): Delete.
	* target.h (struct target_ops): Make to_wait, to_pid_to_str and
	to_get_thread_local_address accept a pointer to struct target_ops.
	(target_wait): Delete macro, and declare as function.
	(target_pid_to_str): Likewise.
	(target_get_thread_local_address)
	(target_get_thread_local_address_p): Delete.
	(noprocess): Add NORETURN and ATTR_NORETURN tags.
	* inf-ptrace.c (inf_ptrace_wait): Adjust.
	(inf_ptrace_pid_to_str): New.
	(inf_ptrace_target): Use inf_ptrace_pid_to_str.
	* aix-thread.c (aix_thread_wait, aix_thread_pid_to_str): Adjust.
	* bsd-kvm.c (bsd_kvm_pid_to_str): Adjust.
	* bsd-uthread.c (bsd_uthread_wait, bsd_uthread_pid_to_str):
	Adjust.
	* corelow.c (core_pid_to_str): Adjust.
	* darwin-nat.c (darwin_wait, darwin_pid_to_str): Adjust.
	* dec-thread.c (dec_thread_wait, dec_thread_pid_to_str): Adjust.
	* gnu-nat.c (gnu_wait, gnu_pid_to_str): Adjust.
	* go32-nat.c (go32_wait, go32_pid_to_str): Adjust.
	* hpux-thread.c (hpux_thread_wait): Adjust.
	* inf-ttrace.c (inf_ttrace_wait, inf_ttrace_pid_to_str): Adjust.
	* monitor.c (monitor_wait, monitor_pid_to_str): Adjust.
	* nto-procfs.c (procfs_wait, procfs_pid_to_str): Adjust.
	* procfs.c (procfs_pid_to_str): Adjust.
	* remote-m32r-sdi.c (m32r_wait, m32r_pid_to_str): Adjust.
	* remote-mips.c (mips_wait): Adjust.
	* remote-sim.c (gdbsim_wait, gdbsim_pid_to_str): Adjust.
	* remote.c (remote_wait, remote_pid_to_str)
	(remote_get_thread_local_address): Adjust.
	* rs6000-nat.c (rs6000_wait): Adjust.
	* sol-thread.c (procfs_pid_to_str): Adjust declaration.
	(sol_thread_wait, solaris_pid_to_str): Adjust.
	* spu-linux-nat.c (spu_child_wait): Adjust.
	* windows-nat.c (windows_wait, windows_pid_to_str): Adjust.
@
text
@d2138 2
@


1.178
log
@        * windows-nat.c (handle_unload_dll): Use %p to print the DLL
        base address instead of casting it to DWORD.
@
text
@d1447 2
a1448 1
windows_wait (ptid_t ptid, struct target_waitstatus *ourstatus)
d2021 1
a2021 1
windows_pid_to_str (ptid_t ptid)
@


1.177
log
@* amd64-windows-nat.c Rename gdb-specific win32_* to windows_* throughout.
* i386-cygwin-tdep.c: Ditto.
* i386-windows-nat.c: Ditto.
* windows-nat.h: Ditto.
* windows-tdep.c: Ditto.
* windows-tdep.h: Ditto.
* windows-nat.c: Ditto.
(cygwin_load_start): Redefine as CORE_ADDR.
(cygwin_load_end): Ditto.
(windows_make_so): Coerce result of address arithmetic to to uintptr_t before
coercing to CORE_ADDR to avoid a compiler warning.
(handle_exception): Define addr as CORE_ADDR and coerce ExceptionAddress to
uintptr_t before assigining to avoid a compiler warning.
* config/djgpp/fnchange.lst: Add mappings for recently renamed windows files.
@
text
@d764 1
a764 1
  error (_("Error: dll starting at 0x%lx not found."), (DWORD) lpBaseOfDll);
@


1.176
log
@Fix linking with --enable-targets=all:
* Makefile.in (ALL_TARGET_OBS): Add windows-tdep.o.
(HFILES_NO_SRCDIR): Add windows-tdep.h.
(ALLDEPFILES): Add windows-tdep.c.
* win32-tdep.h: Delete.
* windows-tdep.h: Rename from win32-tdep.h.
* win32-nat.h: Delete.
* windows-nat.h: Rename from win32-nat.h.
* win32-nat.c: Delete.
* windows-nat.c: Rename from win32-nat.c.
* win32-termcap.c: Delete.
* windows-termcap.c: Rename from win32-termcap.c.
* amd64-windows-nat.c: Handle rename from win32-nat.h -> windows-nat.h.
* configure.ac: Handle rename from win32-termcap.c -> windows-termcap.c.
* configure: Regenerate.
* gdb_curses.h: Change comment to reflect rename from win32-termcap.c ->
windows-termcap.c.
* i386-cygwin-tdep.c: Handle rename from win32-tdep.h -> windows-tdep.h.
* i386-windows-nat.c: Refect rename from win32-nat.h -> windows-nat.h.
* windows-nat.c: Ditto.  Also reflect rename from from win32-tdep.h ->
windows-tdep.h.
(win32_make_so): Handle cygwin compiler warning due to change of load_addr from
DWORD to LPVOID.
(handle_load_dll): Use %p in format string to properly print address and avoid
a compiler warning.
(DEBUG_EXCEPTION_SIMPLE): Ditto.
(handle_exception): Ditto.
* windows-tdep.c: Handle rename from win32-tdep.h -> windows-tdep.h.
* config/i386/cygwin.mh: Handle rename from win32-nat.o -> windows-nat.o.
* config/i386/mingw.mh: Ditto.
* config/i386/mingw64.mh: Ditto.
@
text
@d1 1
a1 1
/* Target-vector operations for controlling win32 child processes, for GDB.
d66 1
a66 1
static struct target_ops win32_ops;
d70 2
a71 2
static bfd_vma cygwin_load_start;
static bfd_vma cygwin_load_end;
d115 3
a117 3
static void win32_stop (ptid_t);
static int win32_win32_thread_alive (ptid_t);
static void win32_kill_inferior (void);
d166 1
a166 1
   in the win32 exception context vector.
d173 1
a173 1
   win32_set_context_register_offsets.
d209 1
a209 1
win32_set_context_register_offsets (const int *offsets)
d258 1
a258 1
win32_add_thread (ptid_t ptid, HANDLE h)
d297 1
a297 1
win32_init_thread_list (void)
d301 1
a301 1
  DEBUG_EVENTS (("gdb: win32_init_thread_list\n"));
d314 1
a314 1
win32_delete_thread (ptid_t ptid)
d341 1
a341 1
do_win32_fetch_inferior_registers (struct regcache *regcache, int r)
d399 1
a399 1
	do_win32_fetch_inferior_registers (regcache, r);
d404 1
a404 1
win32_fetch_inferior_registers (struct regcache *regcache, int r)
d410 1
a410 1
    do_win32_fetch_inferior_registers (regcache, r);
d414 1
a414 1
do_win32_store_inferior_registers (const struct regcache *regcache, int r)
d424 1
a424 1
	do_win32_store_inferior_registers (regcache, r);
d430 1
a430 1
win32_store_inferior_registers (struct regcache *regcache, int r)
d436 1
a436 1
    do_win32_store_inferior_registers (regcache, r);
d589 1
a589 1
win32_make_so (const char *name, LPVOID load_addr)
d654 2
a655 2
      cygwin_load_start = (bfd_vma) ((char *) load_addr + 0x1000);
      cygwin_load_end = (bfd_vma) ((char *) cygwin_load_start + bfd_section_size (abfd, text));
d727 1
a727 1
  solib_end->next = win32_make_so (dll_name, event->lpBaseOfDll);
d737 1
a737 1
win32_free_so (struct so_list *so)
d759 1
a759 1
	win32_free_so (sodel);
d771 1
a771 1
win32_clear_solib (void)
d1004 1
a1004 2
	bfd_vma addr = (bfd_vma) (uintptr_t) current_event.u.Exception.
					     ExceptionRecord.ExceptionAddress;
d1102 1
a1102 1
win32_continue (DWORD continue_status, int id)
d1161 3
a1163 3
  current_thread = win32_add_thread (ptid_build (current_event.dwProcessId, 0,
						 current_event.dwThreadId),
				     current_event.u.CreateThread.hThread);
d1168 1
a1168 1
win32_resume (ptid_t ptid, int step, enum target_signal sig)
d1217 1
a1217 1
  DEBUG_EXEC (("gdb: win32_resume (pid=%d, tid=%ld, step=%d, sig=%d);\n",
d1227 1
a1227 1
	  win32_fetch_inferior_registers (get_current_regcache (),
d1252 1
a1252 1
    win32_continue (continue_status, -1);
d1254 1
a1254 1
    win32_continue (continue_status, ptid_get_tid (ptid));
d1261 1
a1261 1
get_win32_debug_event (int pid, struct target_waitstatus *ourstatus)
d1306 1
a1306 1
      th = win32_add_thread (ptid_build (current_event.dwProcessId, 0,
d1318 1
a1318 1
	  win32_delete_thread (ptid_build (current_event.dwProcessId, 0,
d1335 1
a1335 1
 	win32_delete_thread (ptid_build (current_event.dwProcessId, 0,
d1339 1
a1339 1
      th = win32_add_thread (ptid_build (current_event.dwProcessId, 0,
d1430 1
a1430 1
	win32_resume (minus_one_ptid, 0, 1);
d1432 1
a1432 1
	CHECK (win32_continue (continue_status, -1));
d1447 1
a1447 1
win32_wait (ptid_t ptid, struct target_waitstatus *ourstatus)
d1477 1
a1477 1
      retval = get_win32_debug_event (pid, ourstatus);
d1490 1
a1490 1
	    win32_kill_inferior ();
d1496 1
a1496 1
do_initial_win32_stuff (struct target_ops *ops, DWORD pid, int attaching)
d1518 1
a1518 1
  win32_clear_solib ();
d1528 1
a1528 1
     current thread until we report an event out of win32_wait.  */
d1643 1
a1643 1
     win32_attach(). */
d1661 1
a1661 1
win32_attach (struct target_ops *ops, char *args, int from_tty)
d1677 1
a1677 1
  win32_init_thread_list ();
d1712 1
a1712 1
  do_initial_win32_stuff (ops, pid, 1);
d1717 1
a1717 1
win32_detach (struct target_ops *ops, char *args, int from_tty)
d1724 1
a1724 1
      win32_resume (ptid, 0, TARGET_SIGNAL_0);
d1751 1
a1751 1
win32_pid_to_exec_file (int pid)
d1779 1
a1779 1
win32_files_info (struct target_ops *ignore)
d1789 1
a1789 1
win32_open (char *arg, int from_tty)
d1794 1
a1794 1
/* Start an inferior win32 child process and sets inferior_ptid to its pid.
d1800 1
a1800 1
win32_create_inferior (struct target_ops *ops, char *exec_file,
d1885 1
a1885 1
  win32_init_thread_list ();
d1922 1
a1922 1
  do_initial_win32_stuff (ops, pi.dwProcessId, 0);
d1924 1
a1924 1
  /* win32_continue (DBG_CONTINUE, -1); */
d1928 1
a1928 1
win32_mourn_inferior (struct target_ops *ops)
d1930 1
a1930 1
  (void) win32_continue (DBG_CONTINUE, -1);
d1945 1
a1945 1
win32_stop (ptid_t ptid)
d1953 1
a1953 1
win32_xfer_memory (CORE_ADDR memaddr, gdb_byte *our, int len,
d1982 1
a1982 1
win32_kill_inferior (void)
d1988 1
a1988 1
      if (!win32_continue (DBG_CONTINUE, -1))
d1996 1
a1996 1
  target_mourn_inferior ();	/* or just win32_mourn_inferior? */
d2000 1
a2000 1
win32_prepare_to_store (struct regcache *regcache)
d2006 1
a2006 1
win32_can_run (void)
d2012 1
a2012 1
win32_close (int x)
d2014 1
a2014 1
  DEBUG_EVENTS (("gdb: win32_close, inferior_ptid=%d\n",
d2020 1
a2020 1
win32_pid_to_str (ptid_t ptid)
d2035 1
a2035 1
win32_xfer_shared_libraries (struct target_ops *ops,
d2051 2
a2052 2
    win32_xfer_shared_library (so->so_name, (CORE_ADDR) so->lm_info->load_addr,
                               &obstack);
d2069 1
a2069 1
win32_xfer_partial (struct target_ops *ops, enum target_object object,
d2085 1
a2085 1
      return win32_xfer_shared_libraries (ops, object, annex, readbuf,
d2097 1
a2097 1
init_win32_ops (void)
d2099 39
a2137 39
  win32_ops.to_shortname = "child";
  win32_ops.to_longname = "Win32 child process";
  win32_ops.to_doc = "Win32 child process (started by the \"run\" command).";
  win32_ops.to_open = win32_open;
  win32_ops.to_close = win32_close;
  win32_ops.to_attach = win32_attach;
  win32_ops.to_attach_no_wait = 1;
  win32_ops.to_detach = win32_detach;
  win32_ops.to_resume = win32_resume;
  win32_ops.to_wait = win32_wait;
  win32_ops.to_fetch_registers = win32_fetch_inferior_registers;
  win32_ops.to_store_registers = win32_store_inferior_registers;
  win32_ops.to_prepare_to_store = win32_prepare_to_store;
  win32_ops.deprecated_xfer_memory = win32_xfer_memory;
  win32_ops.to_xfer_partial = win32_xfer_partial;
  win32_ops.to_files_info = win32_files_info;
  win32_ops.to_insert_breakpoint = memory_insert_breakpoint;
  win32_ops.to_remove_breakpoint = memory_remove_breakpoint;
  win32_ops.to_terminal_init = terminal_init_inferior;
  win32_ops.to_terminal_inferior = terminal_inferior;
  win32_ops.to_terminal_ours_for_output = terminal_ours_for_output;
  win32_ops.to_terminal_ours = terminal_ours;
  win32_ops.to_terminal_save_ours = terminal_save_ours;
  win32_ops.to_terminal_info = child_terminal_info;
  win32_ops.to_kill = win32_kill_inferior;
  win32_ops.to_create_inferior = win32_create_inferior;
  win32_ops.to_mourn_inferior = win32_mourn_inferior;
  win32_ops.to_can_run = win32_can_run;
  win32_ops.to_thread_alive = win32_win32_thread_alive;
  win32_ops.to_pid_to_str = win32_pid_to_str;
  win32_ops.to_stop = win32_stop;
  win32_ops.to_stratum = process_stratum;
  win32_ops.to_has_all_memory = 1;
  win32_ops.to_has_memory = 1;
  win32_ops.to_has_stack = 1;
  win32_ops.to_has_registers = 1;
  win32_ops.to_has_execution = 1;
  win32_ops.to_pid_to_exec_file = win32_pid_to_exec_file;
  win32_ops.to_magic = OPS_MAGIC;
d2141 1
a2141 1
set_win32_aliases (char *argv0)
d2147 1
a2147 1
_initialize_win32_nat (void)
d2151 1
a2151 1
  init_win32_ops ();
d2225 2
a2226 2
  add_target (&win32_ops);
  deprecated_init_ui_hook = set_win32_aliases;
d2233 1
a2233 1
   actually set up when win32_continue is called.  */
d2247 1
a2247 1
   will be actually set up in win32_wait.  */
d2269 1
a2269 1
win32_win32_thread_alive (ptid_t ptid)
@


1.175
log
@        * win32-tdep.h, win32-tdep.c: New files.
        * i386-cygwin-tdep.h: Delete.
        * i386-cygwin-tdep.c: Include win32-tdep.h instead of
        i386-cygwin-tdep.h.
        (win32_xfer_shared_library): Delete.  Moved to win32-tdep.c.
        * win32-nat.c: Likewise.
        * configure.tgt: Add win32-tdep.o to the list of target object
        files for i386-cygwin and i386-mingw targets.
@
text
@d63 2
a64 2
#include "win32-tdep.h"
#include "win32-nat.h"
d654 2
a655 2
      cygwin_load_start = load_addr + 0x1000;
      cygwin_load_end = cygwin_load_start + bfd_section_size (abfd, text);
d730 1
a730 1
  DEBUG_EVENTS (("gdb: Loading dll \"%s\" at 0x%lx.\n", solib_end->so_name,
d976 1
a976 1
  printf_unfiltered ("gdb: Target exception %s at 0x%08lx\n", x, \
d1089 1
a1089 1
      printf_unfiltered ("gdb: unknown target exception 0x%08lx at 0x%08lx\n",
@


1.174
log
@        * win32-nat.h: New file.
        * win32-nat.c (mappings): Initialize to NULL.
        (win32_set_context_register_offsets): New function.
        * i386-windows-nat.c: New file.
        (mappings): Moved here from win32-nat.c.
        (_initialize_i386_windows_nat): New function.
        * config/i386/mingw.mh (NATDEPFILES): Add i386-windows-nat.o.
        * config/i386/cygwin.mh (NATDEPFILES): Likewise.
@
text
@d63 1
a63 1
#include "i386-cygwin-tdep.h"
@


1.173
log
@        * win32-nat.c (get_module_name): Change the type of parameter
        "base_address" to LPVOID.  Remove unnecessary cast.
        (struct lm_info): Change type of load_addr to LPVOID.
        (win32_make_so): Change the type of parameter "load_addr"
        to LPVOID.  Remove some unnecessary casts.
        (handle_unload_dll): Change the type of "lpBaseOfDll" to LPVOID.
        (win32_xfer_shared_libraries): Add missing cast.
@
text
@d64 1
d165 1
a165 1
/* This vector maps GDB's idea of a register's number into an address
d170 5
d183 1
a183 49
#define context_offset(x) ((int)&(((CONTEXT *)NULL)->x))
static const int mappings[] =
{
  context_offset (Eax),
  context_offset (Ecx),
  context_offset (Edx),
  context_offset (Ebx),
  context_offset (Esp),
  context_offset (Ebp),
  context_offset (Esi),
  context_offset (Edi),
  context_offset (Eip),
  context_offset (EFlags),
  context_offset (SegCs),
  context_offset (SegSs),
  context_offset (SegDs),
  context_offset (SegEs),
  context_offset (SegFs),
  context_offset (SegGs),
  context_offset (FloatSave.RegisterArea[0 * 10]),
  context_offset (FloatSave.RegisterArea[1 * 10]),
  context_offset (FloatSave.RegisterArea[2 * 10]),
  context_offset (FloatSave.RegisterArea[3 * 10]),
  context_offset (FloatSave.RegisterArea[4 * 10]),
  context_offset (FloatSave.RegisterArea[5 * 10]),
  context_offset (FloatSave.RegisterArea[6 * 10]),
  context_offset (FloatSave.RegisterArea[7 * 10]),
  context_offset (FloatSave.ControlWord),
  context_offset (FloatSave.StatusWord),
  context_offset (FloatSave.TagWord),
  context_offset (FloatSave.ErrorSelector),
  context_offset (FloatSave.ErrorOffset),
  context_offset (FloatSave.DataSelector),
  context_offset (FloatSave.DataOffset),
  context_offset (FloatSave.ErrorSelector)
  /* XMM0-7 */ ,
  context_offset (ExtendedRegisters[10*16]),
  context_offset (ExtendedRegisters[11*16]),
  context_offset (ExtendedRegisters[12*16]),
  context_offset (ExtendedRegisters[13*16]),
  context_offset (ExtendedRegisters[14*16]),
  context_offset (ExtendedRegisters[15*16]),
  context_offset (ExtendedRegisters[16*16]),
  context_offset (ExtendedRegisters[17*16]),
  /* MXCSR */
  context_offset (ExtendedRegisters[24])
};

#undef context_offset
d205 9
@


1.172
log
@        * win32-nat.c (has_detach_ability, set_process_privilege):
        Cast the result of GetProcAddress to (void *) to avoid
        a compilation warning.
@
text
@d484 1
a484 1
get_module_name (DWORD base_address, char *dll_name_ret)
d527 1
a527 1
      if (!base_address || (DWORD) (mi.lpBaseOfDll) == base_address)
d563 1
a563 1
  DWORD load_addr;
d622 1
a622 1
win32_make_so (const char *name, DWORD load_addr)
d749 1
a749 1
  if (!get_module_name ((DWORD) event->lpBaseOfDll, dll_buf))
d760 1
a760 1
  solib_end->next = win32_make_so (dll_name, (DWORD) event->lpBaseOfDll);
d764 1
a764 1
		 (DWORD) solib_end->lm_info->load_addr));
d780 1
a780 1
  DWORD lpBaseOfDll = (DWORD) current_event.u.UnloadDll.lpBaseOfDll;
d2085 2
a2086 1
    win32_xfer_shared_library (so->so_name, so->lm_info->load_addr, &obstack);
@


1.171
log
@        * win32-nat.c (CONTEXT_EXTENDED_REGISTERS): Define to 0 if not
        already defined.
@
text
@d1603 2
a1604 2
	kernel32_DebugSetProcessKillOnExit = GetProcAddress (kernel32,
						 "DebugSetProcessKillOnExit");
d1606 2
a1607 2
	kernel32_DebugActiveProcessStop = GetProcAddress (kernel32,
						 "DebugActiveProcessStop");
d1644 2
a1645 1
	OpenProcessToken = GetProcAddress (advapi32, "OpenProcessToken");
d1647 2
a1648 2
	LookupPrivilegeValue = GetProcAddress (advapi32,
					       "LookupPrivilegeValueA");
d1650 2
a1651 2
	AdjustTokenPrivileges = GetProcAddress (advapi32,
						"AdjustTokenPrivileges");
@


1.170
log
@        * win32-nat.c (get_image_name, win32_xfer_memory): Fix type
        definition of local variable "done".
        (info_w32_command, handle_exception): Remove unnecessary cast.
@
text
@d88 6
@


1.169
log
@        * win32-nat.c (kernel32_DebugSetProcessKillOnExit): Renames
        DebugSetProcessKillOnExit.  Update all uses in this file.
        (kernel32_DebugActiveProcessStop): Renames DebugActiveProcessStop.
        Update all uses in this file.
@
text
@d699 1
a699 1
  DWORD done;
d1004 1
a1004 1
  (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress)
d1118 1
a1118 1
	(DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress);
d1984 1
a1984 1
  DWORD done = 0;
@


1.168
log
@        * win32-nat.c (do_initial_win32_stuff): Add new ops parameter,
        and use it when pushing the target.
        (win32_attach, win32_create_inferior): Update call to
        do_initial_win32_stuff.
        (win32_detach, win32_mourn_inferior): Use our ops parameter
        instead of the global win32_ops to unpush the target.
@
text
@d1584 2
a1585 2
static BOOL WINAPI (*DebugSetProcessKillOnExit)(BOOL);
static BOOL WINAPI (*DebugActiveProcessStop)(DWORD);
d1596 2
a1597 2
      if (!DebugSetProcessKillOnExit)
	DebugSetProcessKillOnExit = GetProcAddress (kernel32,
d1599 2
a1600 2
      if (!DebugActiveProcessStop)
	DebugActiveProcessStop = GetProcAddress (kernel32,
d1602 2
a1603 1
      if (DebugSetProcessKillOnExit && DebugActiveProcessStop)
d1723 1
a1723 1
    DebugSetProcessKillOnExit (FALSE);
d1753 1
a1753 1
      if (!DebugActiveProcessStop (current_event.dwProcessId))
d1759 1
a1759 1
      DebugSetProcessKillOnExit (FALSE);
@


1.167
log
@        Updated copyright notices for most files.
@
text
@d1524 1
a1524 1
do_initial_win32_stuff (DWORD pid, int attaching)
d1544 1
a1544 1
  push_target (&win32_ops);
d1738 1
a1738 1
  do_initial_win32_stuff (pid, 1);
d1773 1
a1773 1
  unpush_target (&win32_ops);
d1948 1
a1948 1
  do_initial_win32_stuff (pi.dwProcessId, 0);
d1963 1
a1963 1
  unpush_target (&win32_ops);
@


1.166
log
@	Kill pthread_ops_hack

	* target.h (struct target_ops): Make to_attach, to_detach,
	to_create_inferior and to_mourn_inferior accept a pointer
    	to struct target_ops.
	(target_attach, target_create_inferior, target_create_inferior):
	Convert from macros to function.  Find the right target to
	invoke a method of.
	(find_default_attach, find_default_create_inferior): New parameter
	ops.
	* corefile.c (core_file_command): Pass target to to_detach.
	* corelow.c (core_detach): Add 'ops' parameter.
	* fork-child.c (fork_inferior): Return the pid.  Allow
	init_trace_fun to be NULL.
	* inf-ptrace (ptrace_ops_hack): Remove.
	(inf_ptrace_him): Remove, moving all logic into....
	(inf_ptrace_create_inferior): ... here.  Push the target
	passed as parameter.
	(inf_ptrace_mourn_inferior, inf_ptrace_attach, inf_ptrace_detach):
	Push/pop target passed as parameter, no ptrace_ops_hack.
	(inf_ptrace_target): Don't remember result.
	* inferior.h (fork_inferior): Adjust prototype.
	* linux-nat.c (linux_nat_create_inferior, linux_nat_attach)
	(linux_nat_detach, linux_nat_mourn_inferior): New parameter ops.
	Pass it to linux_ops target.
	* linux-thread-db.c (thread_db_detach, thread_db_mourn_inferior):
	New parameter ops. Pass it to the target beneath.
	* remote.c (remote_mourn, extended_remote_mourn, remote_detach)
	(extended_remote_create_inferior): New parameter ops. Pass it
	further.
	* target.c (debug_to_attach, debug_to_detach)
	(debug_to_mourn_inferior): New parameter ops.
	(target_create_inferior): New.
	(update_current_target): Do not inherit to_attach, to_detach,
	to_create_inferiour, to_mourn_inferior.  Do not default
	to_detach and to_mourn_inferior.
	(target_detach): Find the right target to use.
	(target_mourn_inferior): New.
	(find_default_attach, find_default_create_inferior): New parameter
	ops.  Pass the found target when calling its method.
	(init_dummy_target): Provide fallback definition of to_detach.
	(target_attach): New.
	(debug_to_attach, debug_to_detach, debug_to_create_inferior)
	(debug_to_mourn_inferiour): New parameter ops.
        * aix-thread.c: Adjust.
        * bsd-uthread.c: Adjust.
        * gnu-nat.c: Adjust.
        * go32-nat.c: Adjust.
        * hpux-thread.c: Adjust.
        * inf-ttrace.c: Ajust.
        * monitor.c: Adjust.
        * nto-procfs.c: Adjust.
        * procfs.c: Adjust.
        * remote-m32r-sdi.c: Adjust.
        * remote-mips.c: Adjust.
        * remote-sim.c: Adjust.
        * rs6000-nat.c: Adjust.
        * sol-thread.c: Adjust.
        * win32-nat.c: Adjust.
	* dec-thread.c: Adjust.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.165
log
@	* win32-nat.c (do_initial_win32_stuff): Set inferior_ptid.
@
text
@d1687 1
a1687 1
win32_attach (char *args, int from_tty)
d1743 1
a1743 1
win32_detach (char *args, int from_tty)
d1826 2
a1827 2
win32_create_inferior (char *exec_file, char *allargs, char **in_env,
		       int from_tty)
d1954 1
a1954 1
win32_mourn_inferior (void)
@


1.164
log
@	Remove the attach_flag global, and make it per-inferior.

	* inferior.h (attach_flag): Delete.
	(inferior_process): Declare.
	* solib.c (update_solib_list): Adjust.
	* gnu-nat.c (gnu_create_inferior, gnu_attach): Adjust.
	* inf-ptrace.c (inf_ptrace_detach): Adjust.
	(inf_ptrace_files_info): Get it from the current inferior.
	* inf-ttrace.c (inf_ttrace_attach): Adjust.
	(inf_ttrace_files_info): Get it from the current
	inferior.
	* inflow.c (terminal_inferior, terminal_ours_1, set_sigint_trap)
	(clear_sigint_trap): Get it from the current process.
	* remote.c (extended_remote_attach_1)
	(extended_remote_create_inferior_1): Adjust.
	* top.c (quit_confirm, quit_target): Get it from the current inferior.
	* procfs.c (do_detach): Adjust.
	(procfs_wait): Get it from the event inferior.
	(procfs_files_info): Get it from the current inferior.
	* nto-procfs.c (procfs_files_info): Likewise.
	(procfs_attach): Adjust.  Set the attach_flag here.
	(do_attach): Don't set it here.
	(procfs_detach): Don't clear it.
	(procfs_mourn_inferior): Don't clear it.
	* solib-osf.c (osf_solib_create_inferior_hook): Adjust.
	* target.c (attach_flag): Delete.
	(generic_mourn_inferior): Don't clear it.
	* win32-nat.c (get_win32_debug_event): Get it from the event
	process.
	(do_initial_win32_stuff): Add attaching argument.  Set attach_flag
	in the inferior accordingly.
	(win32_attach): Don't set the attach_flag here.  Pass 1 to
	do_intial_win32_stuff.
	(win32_files_info): Get it from the current inferior.
	(win32_create_inferior): Dont clear attach_flag here.  Pass 0 to
	do_intial_win32_stuff.
@
text
@d1553 6
@


1.163
log
@	Make the stop_soon global be per-inferior instead.

	* infcmd.c (attach_command_post_wait): Adjust.
	(attach_command): Likewise.

	* inferior.h (stop_soon): Delete.
	(struct inferior): Add stop_soon member.

	* infrun.c (stop_soon): Delete.
	(clear_proceed_status, start_remote)
	(fetch_inferior_event, handle_inferior_event): Adjust.
	(signal_stop_state): Don't check stop_soon here.  Check in callers
	instead.
	(save_inferior_status, restore_inferior_status): Adjust.

	* linux-nat.c (linux_nat_resume, linux_nat_wait): Always pass
	signals to common code if starting up the inferior.

	* inferior.h (struct inferior_info): Added stop_soon member.
	* inferior.c (add_inferior) Clear stop_soon.

	* mips-tdep.c (heuristic_proc_start): Adjust.
	* nto-procfs.c (procfs_create_inferior): Adjust.
	* solib-irix.c (irix_solib_create_inferior_hook): Adjust.
	* solib-osf.c (osf_solib_create_inferior_hook): Adjust.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Adjust.
	* solib-svr4.c (svr4_solib_create_inferior_hook): Adjust.

	* win32-nat.c (do_initial_win32_stuff): Adjust.

	* alpha-tdep.c (alpha_heuristic_proc_start): Adjust.
@
text
@d1319 3
a1321 1
	  if (!saw_create && attach_flag)
d1327 2
a1328 2
	     if (retval)
	       saw_create++;
d1524 1
a1524 1
do_initial_win32_stuff (DWORD pid)
d1551 1
a1717 2
  attach_flag = 1;

d1732 1
a1732 1
  do_initial_win32_stuff (pid);
d1801 2
d1804 2
a1805 1
      attach_flag ? "attached" : "child", target_pid_to_str (inferior_ptid));
a1873 2
  attach_flag = 0;

d1942 1
a1942 1
  do_initial_win32_stuff (pi.dwProcessId);
@


1.162
log
@	* gnu-nat.c (gnu_attach): Add process to inferiors table.
	(gnu_detach): Remove it.
	* go32-nat.c (go32_create_inferior): Add process to gdb's inferior
	table.
	* inf-ptrace.c (inf_ptrace_follow_fork): Delete and add inferiors
	to inferior table accordingly.
	(inf_ptrace_attach): Add new process to inferior table.
	(inf_ptrace_detach): Remove it.
	* inf-ttrace.c (inf_ttrace_follow_fork): Delete and add inferiors
	to inferior table accordingly.
	(inf_ttrace_attach): Add process to inferior table.
	(inf_ttrace_detach): Remove it.
	* linux-fork.c (init_fork_list): Delete any left over inferior.
	(linux_fork_mourn_inferior, detach_fork_command): Also delete
	processes from inferior list.
	* monitor.c (monitor_open): Add process to inferior list.
	(monitor_close): Remove it.
	* nto-procfs.c (procfs_attach): Add process to inferior list.
	Find threads after pushing the target.
	(procfs_detach): Remove process from inferior list.
	(procfs_create_inferior): Add process to inferior list.
	* procfs.c (procfs_detach): Remove process from inferior list.
	(do_attach): Add process to inferior list.
	* remote-sim.c (sim_create_inferior): Add process to inferior list.
	(gdbsim_close): Remove it.
	* target.c (generic_mourn_inferior): If inferior_ptid is not
	null_ptid, remove the corresponding inferior from inferior list.
	* win32-nat.c (do_initial_win32_stuff): Add process to inferior list.
	(win32_detach): Remove it.
	* linux-nat.c (linux_child_follow_fork): Delete and add inferiors
	to inferior list accordingly.
	* fork-child.c (fork_inferior): Add process to inferior list.
	* corelow.c (CORELOW_PID): Define.
	(core_close): Remove core from inferior list.
	(core_open): Add it.
@
text
@d1526 1
d1548 1
a1548 1
  add_inferior (pid);
d1553 1
a1553 1
  stop_soon = STOP_QUIETLY;
d1565 1
a1565 1
  stop_soon = NO_STOP_QUIETLY;
@


1.161
log
@	Remove the global stop_signal in favour of a per-thread
	stop_signal.

	* inferior.h (stop_signal): Delete.
	* gdbthread.h (save_infrun_state, load_infrun_state): Remove
	stop_signal argument.
	* thread.c (load_infrun_state, save_infrun_state): Remove
	stop_signal argument.  Don't reference it.

	* infcmd.c (stop_signal): Delete.
	(program_info): Adjust.
	* infrun.c (resume): Clear stop_signal.
	(proceed): Adjust.  Pass the last stop_signal to the thread we're
	resuming.
	(context_switch): Don't context-switch stop_signal.
	(handle_inferior_event, keep_going): Adjust.
	(save_inferior_status, restore_inferior_status): Adjust.

	* fbsd-nat.c: Include "gdbthread.h".
	(find_signalled_thread, find_stop_signal): New.
	(fbsd_make_corefile_notes): Use it.
	* fork-child.c (startup_inferior): Adjust.

	* linux-nat.c (get_pending_status): Adjust.
	(linux_nat_do_thread_registers): Adjust.
	(find_signalled_thread, find_stop_signal): New.
	(linux_nat_do_thread_registers): Add stop_signal parameter.
	(struct linux_nat_corefile_thread_data): Add stop_signal member.
	(linux_nat_corefile_thread_callback): Pass stop_signal.
	(linux_nat_do_registers): Delete.
	(linux_nat_make_corefile_notes): Use find_stop_signal.  Assume
	there's always a thread.

	* procfs.c (find_signalled_thread, find_stop_signal): New.
	(find_stop_signal): New.
	(procfs_do_thread_registers): Add stop_signal parameter.
	(struct procfs_corefile_thread_data): Add stop_signal member.
	(procfs_corefile_thread_callback): Pass args->stop_signal.
	(procfs_make_note_section): Find the last stop_signal.

	* solib-irix.c: Include gdbthread.h.
	(irix_solib_create_inferior_hook): Adjust.
	* solib-osf.c: Include gdbthread.h.
	(osf_solib_create_inferior_hook): Adjust.
	* solib-sunos.c: Include gdbthread.h.
	(sunos_solib_create_inferior_hook): Adjust.
	* solib-svr4.c: Include gdbthread.h.
	(svr4_solib_create_inferior_hook): Adjust.

	* win32-nat.c (do_initial_win32_stuff): Adjust.
@
text
@d1547 2
d1761 1
d1763 2
@


1.160
log
@	Use ptid_t.tid to store thread ids instead of ptid_t.pid.

	* win32-nat.c (win32_add_thread): Change thread argument type to
	ptid_t.  Adjust.
	(win32_add_thread): Adjust.
	(win32_delete_thread): Change thread argument type to ptid_t.
	Adjust.
	(win32_fetch_inferior_registers, win32_store_inferior_registers)
	(win32_resume, get_win32_debug_event, get_win32_debug_event)
	(win32_wait, win32_pid_to_exec_file, win32_pid_to_str): Adjust.
	(init_win32_ops): Put to_magic last.
	(win32_win32_thread_alive): Adjust.
@
text
@d1526 1
d1555 3
a1557 2
      if (stop_signal != TARGET_SIGNAL_TRAP)
	resume (0, stop_signal);
@


1.159
log
@	Adjust all targets to new target_stop interface.

	* gnu-nat.c (gnu_stop): Add ptid argument.
	* go32-nat.c (go32_stop): Add ptid argument.
	(go32_create_inferior): Pass inferior_ptid to go32_stop.
	* hpux-thread.c (hpux_thread_stop): Add ptid argument.
	* monitor.c (monitor_stop): Add ptid argument.
	(monitor_open): Pass inferior_ptid to monitor_stop.
	(monitor_interrupt): Pass inferior_ptid to target_stop.
	(monitor_stop): Add ptid argument.
	* nto-procfs.c (nto_interrupt): Pass inferior_ptid to target_stop.
	(procfs_create_inferior): Add ptid argument.
	* procfs.c (procfs_stop): Add ptid argument.
	* remote-m32r-sdi.c (m32r_stop): Add ptid argument.
	* remote-sim.c (gdbsim_stop): Add ptid argument.
	* sol-thread.c (sol_thread_stop): Add ptid argument.
	* win32-nat.c (win32_stop): Add ptid argument.
@
text
@d283 1
a283 1
/* Add a thread to the thread list */
d285 1
a285 1
win32_add_thread (DWORD id, HANDLE h)
d288 5
d302 2
a303 2
  add_thread (pid_to_ptid (id));
  /* Set the debug registers for the new thread in they are used.  */
d341 1
a341 1
win32_delete_thread (DWORD id)
d344 5
d351 2
a352 2
    printf_unfiltered ("[Deleting %s]\n", target_pid_to_str (pid_to_ptid (id)));
  delete_thread (pid_to_ptid (id));
d433 1
a433 1
  current_thread = thread_rec (PIDGET (inferior_ptid), TRUE);
d459 1
a459 1
  current_thread = thread_rec (PIDGET (inferior_ptid), TRUE);
d1189 2
a1190 1
  current_thread = win32_add_thread (main_thread_id,
d1201 7
a1207 1
  int pid = PIDGET (ptid);
d1245 2
a1246 2
  DEBUG_EXEC (("gdb: win32_resume (pid=%d, step=%d, sig=%d);\n",
	       pid, step, sig));
d1249 1
a1249 1
  th = thread_rec (PIDGET (inferior_ptid), FALSE);
d1279 4
a1282 1
  win32_continue (continue_status, pid);
a1295 1
  ptid_t ptid = {-1};
d1331 3
a1333 1
      th = win32_add_thread (current_event.dwThreadId,
a1334 1
      retval = current_event.dwThreadId;
d1344 2
a1345 1
	  win32_delete_thread (current_event.dwThreadId);
d1361 2
a1362 1
	win32_delete_thread (main_thread_id);
d1365 2
a1366 1
      th = win32_add_thread (main_thread_id,
d1456 1
a1456 1
	win32_resume (ptid, 0, 1);
d1462 2
a1463 1
      inferior_ptid = pid_to_ptid (retval);
d1471 1
a1471 1
/* Wait for interesting events to occur in the target process. */
d1475 1
a1475 1
  int pid = PIDGET (ptid);
d1507 1
a1507 1
	return pid_to_ptid (retval);
d1770 1
a1770 1
  sprintf (procexe, "/proc/%lu/exe", current_event.dwProcessId);
a2032 1
  int pid = PIDGET (ptid);
d2034 8
a2041 5
  if ((DWORD) pid == current_event.dwProcessId)
    sprintf (buf, "process %d", pid);
  else
    sprintf (buf, "Thread %ld.0x%x", current_event.dwProcessId, pid);
  return buf;
d2145 1
a2146 1
  win32_ops.to_pid_to_exec_file = win32_pid_to_exec_file;
d2274 1
a2274 1
/* Determine if the thread referenced by "pid" is alive
d2276 1
a2276 1
   it means that the pid has died.  Otherwise it is assumed to be alive. */
d2280 4
a2283 1
  int pid = PIDGET (ptid);
d2285 1
a2285 1
  return WaitForSingleObject (thread_rec (pid, FALSE)->h, 0) == WAIT_OBJECT_0 ?
@


1.158
log
@	Adjust fork/vfork/exec to pass ptids around.

	* target.h (struct target_waitstatus): Store related_pid as a ptid.
	(inferior_has_forked, inferior_has_vforked, inferior_has_execd):
	Take a ptid_t.
	* breakpoint.h (struct breakpoint): Change forked_inferior_pid
	type to ptid.
	* breakpoint.c (print_it_typical, bpstat_check_location)
	(print_one_breakpoint_location, set_raw_breakpoint_without_location)
	(create_fork_vfork_event_catchpoint): Adjust.
	* infrun.c (fork_event): Change parent_pid and child_pid types to
	ptid.
	(follow_exec, inferior_has_forked, inferior_has_vforked)
	(inferior_has_execd): Take a ptid_t and don't trim it.
	* linux-thread-db.c (thread_db_wait): Don't trim the returned ptid.
	* linux-nat.c (linux_child_follow_fork): Adjust.
	* inf-ptrace.c (inf_ptrace_wait): Adjust.
	* inf-ttrace.c (inf_ttrace_wait): Adjust.
	* win32-nat.c (get_win32_debug_event): Don't set related_pid.
@
text
@d108 1
a108 1
static void win32_stop (void);
d1931 1
a1931 1
win32_stop (void)
@


1.157
log
@	* config/i386/nm-cygwin.h (ATTACH_NO_WAIT): Delete.
	* config/i386/nm-i386gnu.h (ATTACH_NO_WAIT): Delete.

	* target.h (struct target_ops): Add to_attach_no_wait member.
	(target_attach_no_wait): New.
	* target.c (update_current_target): Inherit to_attach_no_wait.

	* infcmd.c: Replace ATTACH_NO_WAIT compile time check by
	target_attach_no_wait runtime check.

	* gnu-nat.c (init_gnu_ops): Set to_attach_no_wait in gnu_ops.
	* win32-nat.c (init_win32_ops): Set to_attach_no_wait in
	win32_ops.
@
text
@d1305 1
a1305 1
	      retval = ourstatus->value.related_pid = fake_create_process ();
d1345 1
a1345 1
      retval = ourstatus->value.related_pid = current_event.dwThreadId;
@


1.156
log
@	* Makefile.in (GNULIB_H): Use GNULIB_STDINT_H.
	(gdb_stdint_h, gdb_stdint.h, stamp-int): Delete.  Remove
	all dependencies on $(gdb_stdint_h).
	(distclean): Do not delete gdb_stdint.h.
	* acinclude.m4: Do not use stdint.m4.
	* configure.ac: Set GNULIB_STDINT_H.  Remove tests for stdint.h,
	uintptr_t, and gdb_stdint.h.
	* defs.h: Include <stdint.h>.
	* gdb_thread_db.h: Assume stdint.h is already included.
	* breakpoint.c, findcmd.c, hppa-tdep.c, inf-ptrace.c, proc-service.c,
	rs6000-nat.c, spu-linux-nat.c, target.c, win32-nat.c: Do not
	include gdb_stdint.h.
	* configure, config.in: Regenerate.
@
text
@d2088 1
@


1.155
log
@* win32-nat.c (safe_symbol_file_add_stub): Remove unused variable.
(do_initial_win32_stuff): Fix problem with inability to set breakpoints when
first loading DLL with "dll" command.
@
text
@a50 1
#include "gdb_stdint.h"
@


1.154
log
@	* win32-nat.c (win32_pid_to_str): Use capital T for "Thread".
@
text
@a558 2
  struct so_list *so = &solib_start;

d1526 1
d1536 2
@


1.153
log
@	* win32-nat.c (handle_load_dll): Give dll name and load address
	if debug_events is on.
	(handle_unload_dll): Likewise.
@
text
@d2014 1
a2014 1
    sprintf (buf, "thread %ld.0x%x", current_event.dwProcessId, pid);
@


1.152
log
@        * win32-nat.c (win32_wait): Block the control-c event while
        waiting for a debug event.
@
text
@d750 3
d777 2
@


1.151
log
@
	* win32-nat.c (do_win32_fetch_inferior_registers): Use get_regcache_arch
	to get at the current architecture and at the target specific vector.
	Add target specific vector to I387_FISEG_REGNUM and I387_FOP_REGNUM and
	remove define of I387_ST0_REGNUM.

	* amd64-tdep.c (I387_ST0_REGNUM): Remove define.

	(amd64_supply_fxsave, amd64_collect_fxsave): Use get_regcache_arch to
	get at the current architecture
	(I387_FISEG_REGNUM, I387_FOSEG_REGNUM): Add target specific vector as
	parameter.

	* i386-tdep.c: Remove various define's and undef's of I387_ST0_REGNUM,
	I387_NUM_XMM_REGS and I387_MM0_REGNUM.

	(I387_NUM_XMM_REGS, I387_XMM0_REGNUM, I387_MXCSR_REGNUM,
	I387_ST0_REGNUM, I387_FCTRL_REGNUM, I387_MM0_REGNUM,
	(I387_FSTAT_REGNUM): Add target specific vector as parameter.

	(i386_register_name, i386_dbx_reg_to_regnum): Use gdbarch_tdep to get
	at the target specific vector.

	(i386_get_longjmp_target): Use get_frame_arch to get at the current
	architecture. Use gdbarch_tdep to get at the target specific vector.

	(i386_fp_regnum_p, i386_fpc_regnum_p): Add gdbarch as parameter and
	update caller. Use gdbarch_tdep to get at the target specific vector.

	(i386_register_to_value: Use get_frame_arch to get at the current
	architecture.

	* i386-tdep.h (i386_fp_regnum_p, i386_fpc_regnum_p): Add gdbarch as
	parameter.

	* i387-tdep.c (I387_FCTRL_REGNUM, I387_FSTAT_REGNUM, I387_FTAG_REGNUM,
	I387_FISEG_REGNUM, I387_FIOFF_REGNUM, I387_FOSEG_REGNUM
	I387_FOOFF_REGNUM, I387_FOP_REGNUM, I387_ST0_REGNUM, FSAVE_ADDR,
	FXSAVE_ADDR, I387_XMM0_REGNUM): Add target specific vector as parameter.

	(I387_ST0_REGNUM, I387_NUM_XMM_REGS): Remove various define's and
	undef's.

	(i387_convert_register_p, i387_register_to_value,
	i387_value_to_register): Update call for i386_fp_regnum_p.

	* i387-tdep.h: Remove comment.
	(I387_ST0_REGNUM, I387_NUM_XMM_REGS, I387_MM0_REGNUM): Add define.
	(I387_FCTRL_REGNUM, I387_FSTAT_REGNUM, I387_FTAG_REGNUM,
	I387_FISEG_REGNUM, I387_FIOFF_REGNUM, I387_FOSEG_REGNUM,
	I387_FOOFF_REGNUM, I387_FOP_REGNUM, I387_XMM0_REGNUM,
	I387_MXCSR_REGNUM): Add target specific vector as parameter.
@
text
@d1461 19
a1479 1
      int retval = get_win32_debug_event (pid, ourstatus);
@


1.150
log
@        * infrun.c (wait_for_inferior): Add treat_exec_as_sigtrap parameter
        and use it.
        (proceed, start_remote): Update call to wait_for_inferior.
        * inferior.h (wait_for_inferior): Update declaration.
        * fork-child.c, infcmd.c, solib-irix.c, solib-osf.c, solib-sunos.c,
        solib-svr4.c, win32-nat.c: Update calls to wait_for_inferior.
        * inf-ttrace.c (inf_ttrace_wait): Report TTEVT_EXEC events as
        TARGET_WAITKIND_EXECD instead of TARGET_WAITKIND_STOPPED.
@
text
@d362 2
d402 1
a402 3
#define I387_ST0_REGNUM I386_ST0_REGNUM

  if (r == I387_FISEG_REGNUM)
d407 1
a407 1
  else if (r == I387_FOP_REGNUM)
d416 1
a416 1
      for (r = 0; r < gdbarch_num_regs (get_regcache_arch (regcache)); r++)
a418 2

#undef I387_ST0_REGNUM
@


1.149
log
@2008-01-24  Michael Snyder  <msnyder@@specifix.com>

	* procfs.c (procfs_xfer_partial): Comment, cut/paste error.
	* win32-nat.c (win32_xfer_partial): Ditto.
	* target.c (default_xfer_partial): Minor whitespace adjustment.
@
text
@d1510 1
a1510 1
      wait_for_inferior ();
@


1.148
log
@        Inform about new thread in a single place.

        * thread.c (add_thread_silent): Renamed
        from add_thread.
        (print_thread_events): New variable definition.
        (show_print_thread_events): New function.
        (_initialize_thread): Add "set print thread-events" and
        "show print thread-events" commands.
        (add_thread): Announce new thread.
        * gdbthread.h (add_thread_silent): Declare.
        (print_thread_events): New variable declaration.
        * inf-ttrace.c (inf_ttrace_wait): Don't
        inform about new thread, as add_thread is always
        called too, and will take care of that.
        * infrun.c (handle_inferior_event): Likewise.
        * procfs.c (procfs_wait): Likewise.
        * remote.c (remote_currthread): Likewise.
        * sol-thread.c (sol_thread_wait): Likewise.
        * win32-nat.c (get_win32_debug_event): Likewise.
        * linux-thread-db.c (attach_thread): Likewise.
        Remove the verbose parameter.
        (check_event): Make detach_thread be verbose
        only if print_thread_events is set.
        * linux-nat.c (lin_lwp_attach_lwp): Don't inform
        about new thread.  This is called only from
        linux-thread-db.c:attach_thread, which will take care.
        Remove the verbose parameter.
        * linux-nat.h (lin_lwp_attach_lwp): Adjust prototype.
@
text
@d2040 1
a2040 1
					       len, 0/*write*/, NULL, ops);
@


1.147
log
@	* win32-nat.c (win32_create_inferior): Restore code calling
	CloseHandle on ProcessInformation structure.
@
text
@a1313 4
      if (info_verbose)
	printf_unfiltered ("[New %s]\n",
			   target_pid_to_str (
			     pid_to_ptid (current_event.dwThreadId)));
@


1.146
log
@* win32-nat.c (win32_make_so): Use cygwin-style path to avoid warnings when
using MS-DOS paths.
@
text
@d1883 3
@


1.145
log
@* win32-nat.c (psapi_module_handle): Remove static.
(get_module_name): Rename from psapi_get_dll_name.  Revamp slightly to return
first module found if base_address is zero.  Don't initialize psapi function
pointers here.  Convert to cygwin paths when appropriate.
(win32_pid_to_exec_file): Use Cygwin's /proc interface to determine executable
name.  Use get_module_name when that fails or when !__CYGWIN__.
(_initialize_psapi): New function.  Initialize psapi stuff before it is needed
or issue a warning if it is not found.  Move psapi_module_handle here.
@
text
@d659 1
a659 1
      abfd = bfd_openr (name, "pei-i386");
@


1.144
log
@2007-12-22  Pierre Muller  <muller@@ics.u-strasbg.fr>

	* win32-nat.c: Fix PR/2388.
	(do_win32_fetch_inferior_registers): Do not overwrite debug register
	array dr if debug_registers_changed variable is set.
@
text
@d4 1
a4 1
   2005, 2006, 2007 Free Software Foundation, Inc.
d460 10
a469 5
static HMODULE psapi_module_handle = NULL;
static BOOL WINAPI (*psapi_EnumProcessModules) (HANDLE, HMODULE *, DWORD, LPDWORD) = NULL;
static BOOL WINAPI (*psapi_GetModuleInformation) (HANDLE, HMODULE, LPMODULEINFO, DWORD) = NULL;
static DWORD WINAPI (*psapi_GetModuleFileNameExA) (HANDLE, HMODULE, LPSTR, DWORD) = NULL;

d471 1
a471 1
psapi_get_dll_name (DWORD BaseAddress, char *dll_name_ret)
d477 1
a477 1
  HMODULE *DllHandle = dh_buf;
d479 6
a484 1
  BOOL ok;
d486 4
a489 23
  if (!psapi_loaded ||
      psapi_EnumProcessModules == NULL ||
      psapi_GetModuleInformation == NULL ||
      psapi_GetModuleFileNameExA == NULL)
    {
      if (psapi_loaded)
	goto failed;
      psapi_loaded = 1;
      psapi_module_handle = LoadLibrary ("psapi.dll");
      if (!psapi_module_handle)
	{
	  /* printf_unfiltered ("error loading psapi.dll: %u", GetLastError ()); */
	  goto failed;
	}
      psapi_EnumProcessModules = GetProcAddress (psapi_module_handle, "EnumProcessModules");
      psapi_GetModuleInformation = GetProcAddress (psapi_module_handle, "GetModuleInformation");
      psapi_GetModuleFileNameExA = (void *) GetProcAddress (psapi_module_handle,
						    "GetModuleFileNameExA");
      if (psapi_EnumProcessModules == NULL ||
	  psapi_GetModuleInformation == NULL ||
	  psapi_GetModuleFileNameExA == NULL)
	goto failed;
    }
d492 3
a494 6
  ok = (*psapi_EnumProcessModules) (current_process_handle,
				    DllHandle,
				    sizeof (HMODULE),
				    &cbNeeded);

  if (!ok || !cbNeeded)
d497 1
d502 3
a504 5
  ok = (*psapi_EnumProcessModules) (current_process_handle,
				    DllHandle,
				    cbNeeded,
				    &cbNeeded);
  if (!ok)
d509 3
a511 4
      if (!(*psapi_GetModuleInformation) (current_process_handle,
					  DllHandle[i],
					  &mi,
					  sizeof (mi)))
d514 13
a526 9
      len = (*psapi_GetModuleFileNameExA) (current_process_handle,
					   DllHandle[i],
					   dll_name_ret,
					   MAX_PATH);
      if (len == 0)
	error (_("Error getting dll name: %u."), (unsigned) GetLastError ());

      if ((DWORD) (mi.lpBaseOfDll) == BaseAddress)
	return 1;
d531 1
a531 1
  return 0;
d738 1
a738 1
  if (!psapi_get_dll_name ((DWORD) (event->lpBaseOfDll), dll_buf))
a1722 4
  /* Try to find the process path using the Cygwin internal process list
     pid isn't a valid pid, unfortunately.  Use current_event.dwProcessId
     instead.  */

a1723 1
  char *path_ptr = NULL;
d1726 9
a1734 16
  /* TODO: Also find native Windows processes using CW_GETPINFO_FULL.  */
  int cpid;
  struct external_pinfo *pinfo;

  cygwin_internal (CW_LOCK_PINFO, 1000);
  for (cpid = 0;
       (pinfo = (struct external_pinfo *)
	cygwin_internal (CW_GETPINFO, cpid | CW_NEXTPID));
       cpid = pinfo->pid)
    {
      if (pinfo->dwProcessId == current_event.dwProcessId) /* Got it */
       {
	 cygwin_conv_to_full_posix_path (pinfo->progname, path);
	 path_ptr = path;
	 break;
       }
a1735 1
  cygwin_internal (CW_UNLOCK_PINFO);
d1738 6
a1743 1
  return path_ptr;
d2267 31
@


1.143
log
@2007-12-06  Pierre Muller  <muller@@ics.u-strasbg.fr>

	* win32-nat.c: Allow compilation if CORE_ADDR is 8 byte long.
	Add "gdb_stdint.h" dependency required for uintptr_t type use.
	(handle_output_debug_string): Use uintptr_t typecast.
	(handle_exception): Ditto.
	(win32_xfer_memory): Ditto.
	* Makefile.in (win32-nat.o): Add dependency to gdb_stdint header.
@
text
@d385 11
a395 7
	  /* Copy dr values from that thread.  */
	  dr[0] = th->context.Dr0;
	  dr[1] = th->context.Dr1;
	  dr[2] = th->context.Dr2;
	  dr[3] = th->context.Dr3;
	  dr[6] = th->context.Dr6;
	  dr[7] = th->context.Dr7;
@


1.142
log
@2007-12-02  Pierre Muller  <muller@@ics.u-strasbg.fr>

	* win32-nat.c (win32_resume): Set the trace bit
	in the thread identified by inferior_ptid.
@
text
@d51 1
d832 2
a833 1
    ((CORE_ADDR) current_event.u.DebugString.lpDebugStringData, &s, 1024, 0)
d1027 2
a1028 1
	bfd_vma addr = (bfd_vma) current_event.u.Exception.ExceptionRecord.ExceptionAddress;
d1941 3
a1943 2
		  len, (DWORD) memaddr));
      if (!WriteProcessMemory (current_process_handle, (LPVOID) memaddr, our,
d1946 2
a1947 1
      FlushInstructionCache (current_process_handle, (LPCVOID) memaddr, len);
d1952 3
a1954 2
		  len, (DWORD) memaddr));
      if (!ReadProcessMemory (current_process_handle, (LPCVOID) memaddr, our,
@


1.141
log
@*win32-nat.c (open_process_used): New static variable.
(win32_init_thread_list): Remove call to CloseHandle for thread.
(win32_delete_thread): Ditto.
(fake_create_process): Set open_process_used if OpenProcess call is successful.
(get_win32_debug_event): Do not close process handle.
(do_initial_win32_stuff): Set open_process_used to zero.
(win32_mourn_inferior): Call CloseHandle for current_process_handle if
open_process_used is set.
(win32_kill_inferior): Do not close process and main_thread handles.
@
text
@d1235 1
a1235 1
  th = thread_rec (current_event.dwThreadId, FALSE);
@


1.140
log
@	* win32-nat.c (DR6_CLEAR_VALUE): New define.
	(thread_info_struct): Rename suspend_count to suspended, to be
	used as a flag.
	(thread_rec): Only suspend the thread if it wasn't suspended by
	gdb before.  Warn if suspending failed.
	(win32_add_thread): Set Dr6 to DR6_CLEAR_VALUE.
	(win32_continue): Set Dr6 to DR6_CLEAR_VALUE.  Update usage of the
	`suspended' flag.  Do ContinueDebugEvent after resuming the
	suspended threads, not before.  Set threads' contexts before
	resuming them, not after.
	(win32_resume): Set Dr6 to DR6_CLEAR_VALUE.
@
text
@d144 1
a328 1
      (void) CloseHandle (here->h);
a352 1
      CloseHandle (here->h);
d1173 8
d1309 2
a1310 1
	      saw_create++;
d1343 1
a1343 4
	{
	  CloseHandle (current_event.u.CreateProcessInfo.hProcess);
	  break;
	}
a1363 1
      CloseHandle (current_process_handle);
d1495 1
a1893 3
  CloseHandle (pi.hThread);
  CloseHandle (pi.hProcess);

d1909 5
a1969 5
  CHECK (CloseHandle (current_process_handle));

  /* this may fail in an attached process so don't check. */
  if (current_thread && current_thread->h)
    (void) CloseHandle (current_thread->h);
@


1.139
log
@2007-11-16  Markus Deuling  <deuling@@de.ibm.com>

	* m32r-rom.c (m32r_supply_register): Use get_regcache_arch to get at
	the current architecture by regcache.
	* ppcnbsd-nat.c (ppcnbsd_supply_pcb): Likewise.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register)
	(fetch_register, supply_vrregset, fetch_ppc_registers)
	(store_altivec_register, store_spe_register, store_register)
	(fill_vrregset, store_ppc_registers): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers)
	(do_win32_store_inferior_registers): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers)
	(m32r_store_registers): Likewise.
	* remote-sim.c (gdbsim_fetch_register, gdbsim_store_register): Likewise.

	* trad-frame.c (trad_frame_alloc_saved_regs): Replace current_gdbarch by
	gdbarch.
	* user-regs.c (user_reg_map_name_to_regnum): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_return_value): Likewise.
	* m32c-tdep.c (m32c_register_reggroup_p): Likewise.
	* m2-lang.c (build_m2_types): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* rs6000-tdep.c (ppc_dwarf2_frame_init_reg): Likewise.

	* m68hc11-tdep.c (m68hc11_frame_unwind_cache): Use get_frame_arch to
	get at the current architecture by frame_info.
	* gcore.c (derive_stack_segment): Likewise.

	* shnbsd-nat.c (GETREGS_SUPPLIES): Add gdbarch parameter.
	(shnbsd_fetch_inferior_registers, shnbsd_store_inferior_registers): Add
	gdbarch to GETREGS_SUPPLIES call.
@
text
@d94 1
d116 1
a116 1
   not available in gdb's thread structure. */
d123 1
a123 1
    int suspend_count;
d248 3
a250 3
/* Find a thread record given a thread id.
   If get_context then also retrieve the context for this
   thread. */
d259 1
a259 1
	if (!th->suspend_count && get_context)
d262 10
a271 1
	      th->suspend_count = SuspendThread (th->h) + 1;
d273 1
a273 1
	      th->suspend_count = -1;
d307 1
a307 2
      /* th->context.Dr6 = dr[6];
      FIXME: should we set dr6 also ?? */
d1134 25
a1161 23
  if (res)
    for (th = &thread_head; (th = th->next) != NULL;)
      if (((id == -1) || (id == (int) th->id)) && th->suspend_count)
	{

	  for (i = 0; i < th->suspend_count; i++)
	    (void) ResumeThread (th->h);
	  th->suspend_count = 0;
	  if (debug_registers_changed)
	    {
	      /* Only change the value of the debug registers */
	      th->context.ContextFlags = CONTEXT_DEBUG_REGISTERS;
	      th->context.Dr0 = dr[0];
	      th->context.Dr1 = dr[1];
	      th->context.Dr2 = dr[2];
	      th->context.Dr3 = dr[3];
	      /* th->context.Dr6 = dr[6];
		 FIXME: should we set dr6 also ?? */
	      th->context.Dr7 = dr[7];
	      CHECK (SetThreadContext (th->h, &th->context));
	      th->context.ContextFlags = 0;
	    }
	}
d1247 1
a1247 2
	      /* th->context.Dr6 = dr[6];
	       FIXME: should we set dr6 also ?? */
@


1.138
log
@	* config/i386/mingw.mh, config/i386/mingw.mt: New files.
	* configure.tgt	(i[34567]86-*-mingw32*): Set gdb_target = mingw.
	* win32-nat.c: Only include cygwin.h on Cygwin host.  Don't
	include procfs.h.
	(cygwin_load_start, cygwin_load_end, cygwin_exceptions): Disable
	if not building on Cygwin.
	(win32_make_so, handle_output_debug_string, handle_exception)
	(do_initial_win32_stuff): Wrap Cygwin specific code in __CYGWIN__.
	(win32_attach): Only fallback to Cygwin pids if building on
	Cygwin.
	(win32_pid_to_exec_file): Disable Cygwin specific code, if not
	building on Cygwin.
	(win32_create_inferior): Disable starting the inferior through a
	shell, environment var processing and tty handling if not building
	on Cygwin.
	(cygwin_pid_to_str): Rename to ...
	(win32_pid_to_str): ... this.
	(init_win32_ops): Update use of win32_pid_to_str.  Disable "shell"
	and "cygwin-exceptions" commands if not building on Cygwin.
@
text
@d403 1
a403 1
      for (r = 0; r < gdbarch_num_regs (current_gdbarch); r++)
d430 1
a430 1
      for (r = 0; r < gdbarch_num_regs (current_gdbarch); r++)
@


1.137
log
@	* infcmd.c (post_create_inferior): Update comment.
	(run_command_1): Always call post_create_inferior with 0 as
	from_tty.

	* i386-cygwin-tdep.h: New.
	* i386-cygwin-tdep.c: Include "i386-cygwin-tdep.h".
	(win32_xfer_shared_library): Make it extern.

	* win32-nat.c: Include gdb_obstack.h and xml-support.h and
	i386-cygwin-tdep.h.
	(win32_so_ops): Delete.
	(get_relocated_section_addrs): Delete.
	(solib_symbols_add): Delete.
	(register_loaded_dll): Delete.
	(win32_make_so): New.
	(handle_load_dll): Use win32_make_so.
	(win32_free_so): Free the passed in so.
	(win32_relocate_section_addresses): Delete.
	(win32_solib_create_inferior_hook): Delete.
	(handle_unload_dll): Don't add PE offset here.  Free so with
	win32_free_so instead of free_so.
	(win32_special_symbol_handling): Delete.
	(get_win32_debug_event): Remove unneeded calls.  Set state to
	TARGET_WAITKIND_LOADED on a dll unload.
	(do_initial_win32_stuff): Clear cygwin_load_start and
	cygwin_load_end.
	(map_code_section_args): Delete.
	(dll_code_sections_add): Delete.
	(core_section_load_dll_symbols): Delete.
	(win32_xfer_shared_libraries): New.
	(win32_current_sos): Delete.
	(win32_xfer_partial): New.
	(open_symbol_file_object): Delete.
	(in_dynsym_resolve_code): Delete.
	(init_win32_ops): Set win32_xfer_partial as to_xfer_partial member
	of win32_ops.  Remove win32_so_ops settings.  Don't set
	current_target_so_ops here.

	* Makefile.in (i386_cygwin_tdep_h): New variable.
	(i386-cygwin-tdep.o): Update dependencies.
	(win32-nat.o): Update dependencies.
@
text
@a24 2
/* We assume we're being built with and will be used for cygwin.  */

d41 1
d43 1
d67 1
d71 1
a85 1
#include <sys/procfs.h>
d146 1
d148 1
d643 4
a647 2
  strcpy (so->so_original_name, name);

d678 1
d828 1
d830 1
d1008 1
d1023 1
d1485 1
d1487 1
d1640 1
d1648 2
d1651 2
a1652 3
      if (!ok)
	error (_("Can't attach to process."));
    }
a1713 1
  /* TODO: Also find native Windows processes using CW_GETPINFO_FULL.  */
d1717 3
d1737 2
d1785 1
d1806 4
d1824 1
d1848 1
d1861 2
d1873 1
d1982 1
a1982 1
cygwin_pid_to_str (ptid_t ptid)
d2086 1
a2086 1
  win32_ops.to_pid_to_str = cygwin_pid_to_str;
d2117 1
d2131 1
@


1.136
log
@	* gdbarch.sh (core_xfer_shared_libraries): New.

	* corelow.c (core_xfer_partial): Handle TARGET_OBJECT_LIBRARIES.

	* gdb_obstack.h (obstack_grow_str, obstack_grow_str0): New.

	* xml-support.c (gdb_xml_parse): Debug output tweaks.
	(xml_escape_text): New.
	* xml-support.h (xml_escape_text): Declare.

	* config/i386/cygwin.mh (NATDEPFILES): Move corelow.o to ...
	* config/i386/cygwin.mt (TDEPFILES): ... here.

	* win32-nat.c: (fetch_elf_core_registers): Delete.
	(win32_elf_core_fn): Delete.
	(_initialize_core_win32): Delete.

	* i386-cygwin-tdep.c: Include "regset.h", "gdb_objstack.h",
	"xml-support.h" and "gdbcore.h".
	(i386_win32_gregset_reg_offset): New.
	(I386_WIN32_SIZEOF_GREGSET): New.
	(i386_win32_regset_from_core_section): New.
	(win32_xfer_shared_library): New.
	(struct cpms_data): New.
	(core_process_module_section): New.
	(win32_core_xfer_shared_libraries): New.
	(i386_cygwin_skip_trampoline_code): Register gregset_reg_offset,
	gregset_num_regs, sizeof_gregset members of tdep.  Register
	regset_from_core_section and core_xfer_shared_libraries callbacks.

	* Makefile.in (i386-cygwin-tdep.o): Update dependencies.
	* gdbarch.h, gdbarch.c: Regenerate.
@
text
@d49 1
d58 1
d63 2
a65 1
static struct target_so_ops win32_so_ops;
d604 2
a605 117
/* Get the loaded address of all sections, given that .text was loaded
   at text_load. Assumes that all sections are subject to the same
   relocation offset. Returns NULL if problems occur or if the
   sections were not relocated. */

static struct section_addr_info *
get_relocated_section_addrs (bfd *abfd, CORE_ADDR text_load)
{
  struct section_addr_info *result = NULL;
  int section_count = bfd_count_sections (abfd);
  asection *text_section = bfd_get_section_by_name (abfd, ".text");
  CORE_ADDR text_vma;

  if (!text_section)
    {
      /* Couldn't get the .text section. Weird. */
    }
  else if (text_load == (text_vma = bfd_get_section_vma (abfd, text_section)))
    {
      /* DLL wasn't relocated. */
    }
  else
    {
      /* Figure out all sections' loaded addresses. The offset here is
	 such that taking a bfd_get_section_vma() result and adding
	 offset will give the real load address of the section. */

      CORE_ADDR offset = text_load - text_vma;

      struct section_table *table_start = NULL;
      struct section_table *table_end = NULL;
      struct section_table *iter = NULL;

      build_section_table (abfd, &table_start, &table_end);

      for (iter = table_start; iter < table_end; ++iter)
	{
	  /* Relocated addresses. */
	  iter->addr += offset;
	  iter->endaddr += offset;
	}

      result = build_section_addr_info_from_section_table (table_start,
							   table_end);

      xfree (table_start);
    }

  return result;
}

/* Add DLL symbol information. */
static void
solib_symbols_add (struct so_list *so, CORE_ADDR load_addr)
{
  struct section_addr_info *addrs = NULL;
  static struct objfile *result = NULL;
  char *name = so->so_name;
  bfd *abfd = NULL;
  char *p;

  /* The symbols in a dll are offset by 0x1000, which is the
     the offset from 0 of the first byte in an image - because
     of the file header and the section alignment. */

  if (!name || !name[0])
    return;

  abfd = bfd_openr (name, "pei-i386");

  if (!abfd)
    {
      /* pei failed - try pe */
      abfd = bfd_openr (name, "pe-i386");
    }

  if (abfd)
    {
      if (bfd_check_format (abfd, bfd_object))
	addrs = get_relocated_section_addrs (abfd, load_addr);
    }

  if (addrs)
    {
      result = safe_symbol_file_add (name, 0, addrs, 0, OBJF_SHARED);
      free_section_addr_info (addrs);
    }
  else
    {
      /* Fallback on handling just the .text section. */
      struct cleanup *my_cleanups;

      addrs = alloc_section_addr_info (1);
      my_cleanups = make_cleanup (xfree, addrs);
      addrs->other[0].name = ".text";
      addrs->other[0].addr = load_addr;

      result = safe_symbol_file_add (name, 0, addrs, 0, OBJF_SHARED);
      do_cleanups (my_cleanups);
    }

  p = strchr (so->so_name, '\0') - (sizeof ("/cygwin1.dll") - 1);
  if (p >= so->so_name && strcasecmp (p, "/cygwin1.dll") == 0)
    {
      asection *text = bfd_get_section_by_name (abfd, ".text");
      cygwin_load_start = bfd_section_vma (abfd, text);
      cygwin_load_end = cygwin_load_start + bfd_section_size (abfd, text);
    }

  bfd_close (abfd);

  so->symbols_loaded = !!result;
  return;
}

static char *
register_loaded_dll (const char *name, DWORD load_addr, int readsyms)
a613 1
  size_t len;
d641 11
a651 1
  strcpy (so->so_original_name, so->so_name);
d653 2
a654 5
  solib_end->next = so;
  solib_end = so;
  len = strlen (so->so_name);
  if (readsyms)
    solib_symbols_add (so, (CORE_ADDR) load_addr);
d656 19
a674 1
  return so->so_name;
d735 2
a736 1
    dll_name = get_image_name (current_process_handle, event->lpImageName, event->fUnicode);
d740 2
a741 1
  register_loaded_dll (dll_name, (DWORD) event->lpBaseOfDll + 0x1000, auto_solib_add);
d751 1
a751 15
}

static void
win32_relocate_section_addresses (struct so_list *so,
				  struct section_table *sec)
{
  /* FIXME */
  return;
}

static void
win32_solib_create_inferior_hook (void)
{
  solib_add (NULL, 0, NULL, auto_solib_add);
  return;
d757 1
a757 1
  DWORD lpBaseOfDll = (DWORD) current_event.u.UnloadDll.lpBaseOfDll + 0x1000;
d767 1
a767 1
	free_so (sodel);
a784 6
static void
win32_special_symbol_handling (void)
{
  return;
}

a1351 1
      registers_changed ();	/* mark all regs invalid */
a1354 1
      re_enable_breakpoints_in_shlibs ();
d1365 3
a1367 3
      registers_changed ();	/* mark all regs invalid */
      /* ourstatus->kind = TARGET_WAITKIND_UNLOADED;
	 does not exist yet. */
d1475 1
d1966 10
a1975 5
typedef struct
{
  struct target_ops *target;
  bfd_vma addr;
} map_code_section_args;
d1977 2
a1978 6
static void
map_single_dll_code_section (bfd *abfd, asection *sect, void *obj)
{
  int old;
  int update_coreops;
  struct section_table *new_target_sect_ptr;
d1980 9
a1988 49
  map_code_section_args *args = (map_code_section_args *) obj;
  struct target_ops *target = args->target;
  if (sect->flags & SEC_CODE)
    {
      update_coreops = core_ops.to_sections == target->to_sections;

      if (target->to_sections)
	{
	  old = target->to_sections_end - target->to_sections;
	  target->to_sections = (struct section_table *)
	    xrealloc ((char *) target->to_sections,
		      (sizeof (struct section_table)) * (1 + old));
	}
      else
	{
	  old = 0;
	  target->to_sections = (struct section_table *)
	    xmalloc ((sizeof (struct section_table)));
	}
      target->to_sections_end = target->to_sections + (1 + old);

      /* Update the to_sections field in the core_ops structure
	 if needed.  */
      if (update_coreops)
	{
	  core_ops.to_sections = target->to_sections;
	  core_ops.to_sections_end = target->to_sections_end;
	}
      new_target_sect_ptr = target->to_sections + old;
      new_target_sect_ptr->addr = args->addr + bfd_section_vma (abfd, sect);
      new_target_sect_ptr->endaddr = args->addr + bfd_section_vma (abfd, sect) +
	bfd_section_size (abfd, sect);;
      new_target_sect_ptr->the_bfd_section = sect;
      new_target_sect_ptr->bfd = abfd;
    }
}

static int
dll_code_sections_add (const char *dll_name, int base_addr, struct target_ops *target)
{
  bfd *dll_bfd;
  map_code_section_args map_args;
  asection *lowest_sect;
  char *name;
  if (dll_name == NULL || target == NULL)
    return 0;
  name = xstrdup (dll_name);
  dll_bfd = bfd_openr (name, "pei-i386");
  if (dll_bfd == NULL)
d1991 27
a2017 7
  if (bfd_check_format (dll_bfd, bfd_object))
    {
      lowest_sect = bfd_get_section_by_name (dll_bfd, ".text");
      if (lowest_sect == NULL)
	return 0;
      map_args.target = target;
      map_args.addr = base_addr - bfd_section_vma (dll_bfd, lowest_sect);
d2019 5
a2023 30
      bfd_map_over_sections (dll_bfd, &map_single_dll_code_section, (void *) (&map_args));
    }

  return 1;
}

static void
core_section_load_dll_symbols (bfd *abfd, asection *sect, void *obj)
{
  struct target_ops *target = (struct target_ops *) obj;

  DWORD base_addr;

  int dll_name_size;
  struct win32_pstatus *pstatus;
  struct so_list *so;
  char *dll_name;
  char *buf = NULL;
  char *p;
  struct objfile *objfile;
  const char *dll_basename;

  if (strncmp (sect->name, ".module", 7) != 0)
    return;

  buf = (char *) xmalloc (bfd_get_section_size (sect) + 1);
  if (!buf)
    {
      printf_unfiltered ("memory allocation failed for %s\n", sect->name);
      goto out;
a2024 79
  if (!bfd_get_section_contents (abfd, sect, buf, 0, bfd_get_section_size (sect)))
    goto out;

  pstatus = (struct win32_pstatus *) buf;

  memmove (&base_addr, &(pstatus->data.module_info.base_address), sizeof (base_addr));
  dll_name_size = pstatus->data.module_info.module_name_size;
  if (offsetof (struct win32_pstatus, data.module_info.module_name) + dll_name_size > bfd_get_section_size (sect))
      goto out;

  dll_name = pstatus->data.module_info.module_name;

  if (!(dll_basename = strrchr (dll_name, '/')))
    dll_basename = dll_name;
  else
    dll_basename++;

  ALL_OBJFILES (objfile)
  {
    char *objfile_basename = strrchr (objfile->name, '/');

    if (objfile_basename &&
	strcasecmp (dll_basename, objfile_basename + 1) == 0)
      goto out;
  }

  base_addr += 0x1000;
  dll_name = register_loaded_dll (dll_name, base_addr, 1);

  if (!dll_code_sections_add (dll_name, (DWORD) base_addr, target))
    printf_unfiltered ("%s: Failed to map dll code sections.\n", dll_name);

out:
  if (buf)
    xfree (buf);
  return;
}

static struct so_list *
win32_current_sos (void)
{
  struct so_list *sop;
  struct so_list *start = NULL;
  struct so_list *last = NULL;

  if (!solib_start.next && core_bfd)
    {
      win32_clear_solib ();
      bfd_map_over_sections (core_bfd, &core_section_load_dll_symbols,
			     &win32_ops);
    }

  for (sop = solib_start.next; sop; sop = sop->next)
    {
      struct so_list *new = XZALLOC (struct so_list);
      strcpy (new->so_name, sop->so_name);
      strcpy (new->so_original_name, sop->so_original_name);
      if (!start)
	last = start = new;
      else
	{
	  last->next = new;
	  last = new;
	}
    }

  return start;
}

static int
open_symbol_file_object (void *from_ttyp)
{
  return 0;
}

static int
in_dynsym_resolve_code (CORE_ADDR pc)
{
  return 0;
d2043 1
a2067 12

  win32_so_ops.relocate_section_addresses = win32_relocate_section_addresses;
  win32_so_ops.free_so = win32_free_so;
  win32_so_ops.clear_solib = win32_clear_solib;
  win32_so_ops.solib_create_inferior_hook = win32_solib_create_inferior_hook;
  win32_so_ops.special_symbol_handling = win32_special_symbol_handling;
  win32_so_ops.current_sos = win32_current_sos;
  win32_so_ops.open_symbol_file_object = open_symbol_file_object;
  win32_so_ops.in_dynsym_resolve_code = in_dynsym_resolve_code;

  /* FIXME: Don't do this here.  *_gdbarch_init() should set so_ops. */
  current_target_so_ops = &win32_so_ops;
@


1.135
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@a2244 17
static void
fetch_elf_core_registers (struct regcache *regcache,
			  char *core_reg_sect,
			  unsigned core_reg_size,
			  int which,
			  CORE_ADDR reg_addr)
{
  int r;
  if (core_reg_size < sizeof (CONTEXT))
    {
      error (_("Core file register section too small (%u bytes)."), core_reg_size);
      return;
    }
  for (r = 0; r < gdbarch_num_regs (current_gdbarch); r++)
    regcache_raw_supply (regcache, r, core_reg_sect + mappings[r]);
}

a2445 15
static struct core_fns win32_elf_core_fns =
{
  bfd_target_elf_flavour,
  default_check_format,
  default_core_sniffer,
  fetch_elf_core_registers,
  NULL
};

void
_initialize_core_win32 (void)
{
  deprecated_add_core_fns (&win32_elf_core_fns);
}

@


1.134
log
@	gdb/
	* breakpoint.c (disable_breakpoints_in_shlibs): Remove
	the 'silent' parameter and code to implement that.
	* breakpoint.h (disable_breakpoints_in_shlibs): Adjust
	prototype.
	* win32-nat.c: Adjust.
	* solib.c: Adjust.
@
text
@d12 1
a12 1
   the Free Software Foundation; either version 2 of the License, or
d16 1
a16 1
   but WITHOUT ANY WARRANTY; without eve nthe implied warranty of
d21 1
a21 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.133
log
@2007-06-18  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (SP_REGNUM): Replace by gdbarch_sp_regnum.
	* v850-tdep.c (v850_unwind_sp): Likewise.
	* std-regs.c (value_of_builtin_frame_sp_reg): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu, sh_push_dummy_call_nofpu)
	(sh_dwarf2_frame_init_reg, sh_frame_cache, sh_frame_prev_register)
	(sh_unwind_sp): Likewise.
	* sh64-tdep.c (sh64_push_dummy_call, sh64_frame_cache)
	(sh64_frame_prev_register, sh64_unwind_sp): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call, rs6000_unwind_dummy_id)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (store_register): Likewise.
	* remote-mips.c (mips_wait): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* m32r-rom.c (m32r_supply_register): Likewise.
	* frame.c (frame_sp_unwind): Likewise.
	* mips-tdep.c (mips_insn16_frame_cache)
	(mips_insn32_frame_cache): Likewise (comment).
	* m68klinux-nat.c (supply_gregset): Likewise.
	* m68k-tdep.c (m68k_get_longjmp_target): Likewise.
	* ia64-tdep.c (ia64_frame_prev_register): Likewise.
	* i386-tdep.c (i386_get_longjmp_target): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* cris-tdep.c (cris_regnums, cris_sigcontext_addr)
	(cris_sigtramp_frame_unwind_cache, cris_push_dummy_call)
	(cris_scan_prologue, crisv32_scan_prologue, cris_unwind_sp)
	(cris_register_type, crisv32_register_type)
	(cris_dwarf2_frame_init_reg): Likewise.
	* arch-utils.c (legacy_virtual_frame_pointer): Likewise.
	* amd64-tdep.c (amd64_frame_prev_register): Likewise.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Likewise.
	* libunwind-frame.c (libunwind_frame_cache): Likewise.

	* gdbarch.sh (PC_REGNUM): Replace by gdbarch_pc_regnum.
	* regcache.c (read_pc_pid, generic_target_write_pc): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_supply_gregset)
	(xtensa_unwind_pc, xtensa_frame_cache, xtensa_frame_prev_register)
	(xtensa_extract_return_value, xtensa_store_return_value): Likewise.
	* v850-tdep.c (v850_unwind_pc): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs)
	(sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs)
	(sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs)
	(sh_dwarf2_frame_init_reg, sh_frame_prev_register, sh_unwind_pc)
	(sh_dsp_show_regs): Likewise.
	* shnbsd-tdep.c (shnbsd_supply_gregset)
	(shnbsd_collect_gregset): Likewise.
	* shnbsd-nat.c (GETREGS_SUPPLIES): Likewise.
	* sh64-tdep.c (sh64_compact_reg_base_num, sh64_show_media_regs)
	(sh64_frame_prev_register, sh64_unwind_pc): Likewise.
	* rs6000-tdep.c (ppc_supply_gregset, ppc_collect_gregset)
	(6000_register_reggroup_p, rs6000_unwind_pc)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (regmap, rs6000_fetch_inferior_registers)
	(rs6000_store_inferior_registers): Likewise.
	* remote-mips.c (mips_wait, mips_load): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppcnbsd-nat.c (getregs_supplies, ppcnbsd_supply_pcb): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* ppc-linux-nat.c (ppc_register_u_addr, fetch_ppc_registers)
	(store_ppc_registers, fill_gregset): Likewise.
	* mips-tdep.c (mips_stub_frame_cache, mips_gdbarch_init): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg, mipsnbsd_fill_reg): Likewise.
	* mipsnbsd-nat.c (getregs_supplies): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.
	* irix5-nat.c (fill_gregset): Likewise.
	* i386-tdep.c (i386_unwind_pc): Likewise.
	* i386-linux-nat.c (i386_linux_resume): Likewise.
	* frame.c (get_prev_frame_1): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* cris-tdep.c (cris_sigtramp_frame_unwind_cache, cris_scan_prologue)
	(crisv32_scan_prologue, cris_unwind_pc, cris_register_size)
	(cris_register_type, crisv32_register_type, crisv32_register_name)
	(cris_dwarf2_frame_init_reg, find_step_target)
	(cris_software_single_step, cris_supply_gregset)
	(cris_regnums): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* aix-thread.c (special_register_p, supply_sprs64, supply_sprs32)
	(fill_sprs64, fill_sprs32, store_regs_user_thread): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.

	* gdbarch.sh (PS_REGNUM): Replace by gdbarch_ps_regnum.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* xtensa-tdep.c (xtensa_supply_gregset, xtensa_frame_cache)
	(xtensa_frame_prev_register, xtensa_push_dummy_call): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* std-regs.c (value_of_builtin_frame_ps_reg)
	(value_of_builtin_frame_pc_reg): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.

	* gdbarch.sh (FP0_REGNUM): Replace by gdbarch_fp0_regnum.
	* sh-tdep.c (sh_extract_return_value_fpu, sh_store_return_value_fpu)
	(sh2e_show_regs, sh2a_show_regs, sh3e_show_regs, sh4_show_regs)
	(sh_sh2a_register_type, sh_sh3e_register_type, sh_sh4_register_type)
	(fv_reg_base_num, dr_reg_base_num): Likewise.
	* sh64-tdep.c (sh64_fv_reg_base_num, sh64_dr_reg_base_num)
	(sh64_fpp_reg_base_num, sh64_compact_reg_base_num, sh64_push_dummy_call)
	(sh64_extract_return_value, sh64_store_return_value)
	(sh64_show_media_regs, sh64_show_compact_regs, sh64_register_type)
	(sh64_do_fp_register, sh64_media_print_registers_info): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers)
	(invalidate_cache): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_fpreg)
	(mipsnbsd_fill_fpreg): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers)
	(mipsnbsd_store_inferior_registers): Likewise.
	* mips-linux-tdep.c (mips_supply_fpregset, mips_fill_fpregset)
	(mips64_supply_fpregset, mips64_fill_fpregset): Likewise.
	* mips-linux-nat.c (mips64_linux_register_addr): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_convert_register_p): Likewise.
	* m68klinux-nat.c (getfpregs_supplies, supply_fpregset)
	(fill_fpregset): Likewise.
	* irix5-nat.c (supply_fpregset, fill_fpregset): Likewise.
	* i386-tdep.h (struct_return): Likewise (comment).
	* i386-nto-tdep.c (i386nto_register_area): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register)
	(go32_store_registers): Likewise.
	* alpha-tdep.c (alpha_next_pc): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers)
	(alphabsd_store_inferior_registers): Likewise.
	* core-regset.c (fetch_core_registers): Likewise.
	* i386v4-nat.c (supply_fpregset, fill_fpregset): Likewise.

	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d1588 1
a1588 1
  disable_breakpoints_in_shlibs (1);
@


1.132
log
@	* regcache.c (struct regcache): Add ptid_t member.
	(regcache_xmalloc): Initialize it.
	(regcache_cpy_no_passthrough): Do not refer to current_regcache.
	(regcache_dup): Likewise.
	(regcache_dup_no_passthrough): Likewise.
	(current_regcache): Make static.
	(registers_ptid): Remove variable.
	(get_thread_regcache): New function.
	(get_current_regcache): New function.
	(registers_changed): Implement by freeing current regcache.
	(regcache_raw_read): Do not refer to current_regcache.  Set
	inferior_ptid to regcache->ptid while calling target routines.
	(regcache_raw_write): Likewise.
	(regcache_raw_supply): Do not refer to current_regcache.
	(read_pc_pid): Use thread regcache.  Do not modify inferior_ptid.
	(write_pc_pid): Likewise.
	(build_regcache): Remove.
	(_initialize_regcache): Do not call DEPRECATED_REGISTER_GDBARCH_SWAP
	or deprecated_register_gdbarch_swap.  Do not initialize
	registers_ptid.
	* regcache.h (get_current_regcache): Add prototype.
	(get_thread_regcache): Likewise.
	(current_regcache): Remove declaration.

	* corelow.c (core_open): Replace current_regcache by
	get_current_regcache ().
	* frame.c (frame_pop): Likewise.
	(put_frame_register): Likewise.
	(get_current_frame, create_new_frame): Likewise.
	* mi/mi-main.c (mi_cmd_data_write_register_values): Likewise.
	* stack.c (return_command): Likewise.
	* infcall.c (call_function_by_hand): Likewise.
	* infrun.c (resume): Likewise.
	(save_inferior_status, restore_inferior_status): Likewise.
	* linux-fork.c (fork_load_infrun_state): Likewise.
	(fork_save_infrun_state): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* i386fbsd-nat.c (i386fbsd_resume): Likewise.
	* monitor.c (monitor_wait): Likewise.
	* remote.c (remote_wait): Likewise.
	* remote-mips.c (mips_wait): Likewise.

	* bsd-kvm.c (bsd_kvm_open): Likewise
	(bsd_kvm_proc_cmd, bsd_kvm_pcb_cmd): Likewise.
	* fbsd-nat.c (fbsd_make_corefile_notes): Likewise.
	* i386-linux-nat.c (i386_linux_resume): Likewise.
	* ia64-linux-nat.c (ia64_linux_insert_watchpoint): Likewise.
	(ia64_linux_stopped_data_address): Likewise.

	* frv-tdep.c (frv_fdpic_loadmap_addresses): Likewise.
	* m32c-tdep.c (m32c_virtual_frame_pointer): Likewise.
	* mep-tdep.c (current_me_module, current_options): Likewise.
	* mips-tdep.c (deprecated_mips_set_processor_regs_hack): Likewise.

	* linux-nat.c (linux_nat_do_thread_registers): Use thread
	regcache instead of current_regcache.  Call target_fetch_registers.
	(linux_nat_corefile_thread_callback): Update call site.
	(linux_nat_do_registers): Likewise.
	* procfs.c (procfs_do_thread_registers): Use thread regcache instead
	of current_regcache.
	(procfs_make_note_section): Likewise.
	* proc-service.c (ps_lgetregs, ps_lsetregs): Likewise.
	(ps_lgetfpregs, ps_lsetfpregs): Likewise.
	* sol-thread.c (ps_lgetregs, ps_lsetregs): Likewise.
	(ps_lgetfpregs, ps_lsetfpregs): Likewise.
@
text
@d1321 2
a1322 1
	  win32_fetch_inferior_registers (get_current_regcache (), PS_REGNUM);
@


1.131
log
@2007-05-31  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (NUM_REGS): Replace by gdbarch_num_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_registers)
	(inf_ptrace_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* i386-linux-nat.c (supply_gregset, fill_gregset)
	(i386_linux_fetch_inferior_registers)
	(i386_linux_store_inferior_registers): Likewise.
	* remote.c (init_remote_state,packet_reg_from_regnum)
	(packet_reg_from_pnum,process_g_packet,remote_fetch_registers)
	(remote_prepare_to_store,store_registers_using_G)
	(remote_store_registers,remote_arch_state): Likewise.
	* tracepoint.c (encode_actions): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* tui/tui-regs.c (tui_show_register_group)
	(tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* xtensa-tdep.c (xtensa_register_name,xtensa_register_type)
	(xtensa_reg_to_regnum,xtensa_pseudo_register_read)
	(xtensa_pseudo_register_write,xtensa_register_reggroup_p): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers)
	(do_win32_store_inferior_registers,fetch_elf_core_registers
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target-descriptions.c (tdesc_use_registers): Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_do_pseudo_register,sh64_print_register)
	(sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* rs6000-nat.c (fetch_register,store_register): Likewise.
	* remote-sim.c (one2one_register_sim_regno,gdbsim_fetch_register)
	(gdbsim_fetch_register,gdbsim_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers,mips_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers)
	(m32r_store_registers): Likewise.
	* reggroups.c (default_register_reggroup_p): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save)
	(regcache_restore,regcache_dump): Likewise.
	* monitor.c (monitor_fetch_registers,monitor_store_registers): Likewise.
	* mips-tdep.c (mips_xfer_register,mips_register_name)
	(mips_register_reggroup_p,mips_pseudo_register_read)
	(mips_pseudo_register_write,mips_convert_register_p,mips_register_type)
	(mips_unwind_pc,mips_unwind_sp,mips_unwind_dummy_id,set_reg_offset)
	(mips16_scan_prologue,mips_insn16_frame_cache,reset_saved_regs)
	(mips32_scan_prologue,mips_insn32_frame_cache,read_next_frame_reg)
	(mips_n32n64_return_value,mips_o32_return_value,mips_o64_return_value)
	(print_gp_register_row,mips_print_registers_info)
	(mips_stab_reg_to_regnum,mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_register_sim_regno): Likewise.
	* mips-linux-tdep.c (mips_linux_o32_sigframe_init)
	(mips_linux_n32n64_sigframe_init): Likewise.
	* mips-linux-nat.c (mips_linux_register_addr)
	(mips64_linux_register_addr): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* mips64obsd-tdep.c (mips64obsd_sigframe_init): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache(: Likewise.
	* m32r-tdep.c (m32r_frame_unwind_cache): Likewise.
	* ia64-linux-nat.c (ia64_register_addr,ia64_cannot_fetch_register)
	(ia64_cannot_store_register,ia64_linux_fetch_registers)
	(ia64_linux_store_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Likewise.
	* h8300-tdep.c (E_PSEUDO_CCR_REGNUM,E_PSEUDO_EXR_REGNUM)
	(h8300_init_frame_cache,h8300_frame_cache,h8300_frame_prev_register)
	(h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache)
	(dwarf2_frame_state_alloc_regs): Likewise.
	* cris-tdep.c (cris_register_size,cris_cannot_fetch_register)
	(cris_cannot_store_register,crisv32_cannot_fetch_register)
	(crisv32_cannot_store_register,cris_register_name): Likewise.
	* avr-tdep.c (avr_frame_unwind_cache): Likewise.
	* arch-utils.c (legacy_register_sim_regno)
	(legacy_virtual_frame_pointer): Likewise.
	* arm-tdep.c (arm_make_prologue_cache,arm_register_sim_regno):Likewise.
	* arm-tdep.h: Likewise (comment).
	* frv-tdep.c (frv_register_sim_regno): Likewise.
	* m68klinux-nat.c (old_fetch_inferior_registers)
	(old_store_inferior_registers): Likewise.
	* m32c-tdep.c (m32c_virtual_frame_pointer): Likewise.
	* irix5-nat.c (fetch_core_registers): Likewise.
	* hppa-tdep.c (hppa_frame_cache): Likewise.
	* hppa-linux-nat.c (hppa_linux_register_addr)
	(hppa_linux_fetch_inferior_registers)
	(hppa_linux_store_inferior_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_inferior_registers)
	(hppa_hpux_store_inferior_registers): Likewise.
	* amd64-nat.c (amd64_native_gregset_reg_offset)
	(amd64_supply_native_gregset,amd64_collect_native_gregset): Likewise.
	* dbug-rom.c (dbug_regname): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache)
	(HARD_PAGE_REGNUM (comment)): Likewise.
	* gdbarch.sh (NUM_PSEUDO_REGS): Replace by gdbarch_num_pseudo_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
	* tui/tui-regs.c (tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_print_register,sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save
	(regcache_restore,regcache_dump): Likewise.
	* mips-tdep.c (print_gp_register_row,mips_print_registers_info)
	(mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_stab_reg_to_regnum): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache): Likewise.
	* frame.h (SIZEOF_FRAME_SAVED_REGS): Likewise.
	* xtensa-tdep.c (xtensa_register_type,xtensa_reg_to_regnum)
	(xtensa_pseudo_register_read,xtensa_pseudo_register_write): Likewise.
	* parse.c: Remove comment.
	* gdbarch.c, gdbarch.h: Regenerate
@
text
@d1321 1
a1321 1
	  win32_fetch_inferior_registers (current_regcache, PS_REGNUM);
@


1.130
log
@	* target.h (struct target_ops): Add REGCACHE parameter to
	to_prepare_to_store.
	(target_prepare_to_store): Likewise.
	* target.c (debug_to_prepare_to_store): Add REGCACHE parameter.
	(update_current_target): Adapt prepare_to_store de_fault rule.

	* regcache.c (regcache_raw_write): Pass regcache to
	target_prepare_to_store.

	* inftarg.c (child_prepare_to_store): Add REGCACHE parameter.
	Do not call CHILD_PREPARE_TO_STORE.
	* gnu-nat.c (gnu_prepare_to_store): Likewise.
	* procfs.c (procfs_prepare_to_store): Likewise.

	* inf-child.c (inf_child_prepare_to_store): Add REGCACHE parameter.
	* go32-nat.c (go32_prepare_to_store): Likewise.
	* monitor.c (monitor_prepare_to_store): Likewise.
	* nto-procfs.c (procfs_prepare_to_store): Likewise.
	* remote-m32r-sdi.c (m32r_prepare_to_store): Likewise.
	* remote-mips.c (mips_prepare_to_store): Likewise.
	* remote-sim.c (gdbsim_prepare_to_store): Likewise.
	* win32-nat.c (win32_prepare_to_store): Likewise.

	* remote.c (remote_prepare_to_store): Add REGCACHE parameter.
	Use it instead of current_regcache.

	* hpux-thread.c (hpux_thread_prepare_to_store): Add REGCACHE
	parameter.  Pass it on to next target.
	* sol-thread.c (sol_thread_prepare_to_store): Likewise.
@
text
@d399 1
a399 1
      for (r = 0; r < NUM_REGS; r++)
d426 1
a426 1
      for (r = 0; r < NUM_REGS; r++)
d2259 1
a2259 1
  for (r = 0; r < NUM_REGS; r++)
@


1.129
log
@	* target.h (struct regcache): Add forward declaration.
	(struct target_ops): Add REGCACHE parameter to to_fetch_registers
	and to_store_registers target operations.
	(target_fetch_registers, target_store_registers): Update.

	* regcache.c (regcache_raw_read): Replace register_cached by
	regcache_valid_p.  Pass regcache to target_fetch_registers.
	(regcache_raw_write): Pass regcache to target_store_registers.

	* arm-linux-nat.c (store_fpregister, store_fpregs, store_register,
	store_regs, store_wmmx_regs): Replace register_cached by
	regcache_valid_p.

	* bsd-kvm.c (bsd_kvm_open, bsd_kvm_proc_cmd): Pass current_regcache
	to target_fetch_registers calls.
	* corelow.c (core_open): Likewise.
	* linux-nat.c (linux_nat_corefile_thread_callback): Likewise.
	* proc-service.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* sol-thread.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* ia64-tdep.c (ia64_store_return_value): Pass current_regcache
	to target_store_registers call.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.

	* inferior.h (store_inferior_registers): Update prototype.
	(fetch_inferior_registers): Likewise.
	* gnu-nat.c (gnu_store_registers, gnu_fetch_registers): Likewise.
	* mips-linux-nat.c (super_fetch_registers, super_store_registers):
	Update function pointer signatures.

	* aix-thread.c (aix_thread_fetch_registers): Add REGCACHE parameter,
	use it instead of current_regcache, update calls.
	(aix_thread_store_registers): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers): Likewise.
	(alphabsd_store_inferior_registers): Likewise.
	* amd64bsd-nat.c (amd64bsd_fetch_inferior_registers): Likewise.
	(amd64bsd_store_inferior_registers): Likewise.
	* amd64-linux-nat.c (amd64_linux_fetch_inferior_registers): Likewise.
	(amd64_linux_store_inferior_registers): Likewise.
	* arm-linux-nat.c (fetch_fpregister, fetch_fpregs, store_fpregister,
	store_fpregs, fetch_register, fetch_regs, store_register, store_regs,
	fetch_wmmx_regs, store_wmmx_regs): Likewise.
	(arm_linux_fetch_inferior_registers): Likewise.
	(arm_linux_store_inferior_registers): Likewise.
	* armnbsd-nat.c (fetch_register, fetch_regs, fetch_fp_register,
	fetch_fp_regs, armnbsd_fetch_registers): Likewise.
	(store_register, store_regs, store_fp_register, store_fp_regs,
	armnbsd_store_registers): Likewise.
	* bsd-kvm.c (bsd_kvm_fetch_pcb, bsd_kvm_fetch_registers): Likewise.
	* bsd-uthread.c (bsd_uthread_fetch_registers): Likewise.
	(bsd_uthread_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register,
	go32_store_registers): Likewise.
	* hppabsd-nat.c (hppabsd_fetch_registers): Likewise.
	(hppabsd_store_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register): Likewise.
	(hppa_hpux_fetch_inferior_registers): Likewise.
	(hppa_hpux_store_register): Likewise.
	(hppa_hpux_store_inferior_registers): Likewise.
	* hppa-linux-nat.c (fetch_register, store_register): Likewise.
	(hppa_linux_fetch_inferior_registers): Likewise.
	(hppa_linux_store_inferior_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers): Likewise.
	(hpux_thread_store_registers): Likewise.
	* i386bsd-nat.c (i386bsd_fetch_inferior_registers): Likewise.
	(i386bsd_store_inferior_registers): Likewise.
	* i386gnu-nat.c (fetch_fpregs, gnu_fetch_registers, store_fpregs,
	gnu_store_registers): Likewise.
	* i386-linux-nat.c (fetch_register, store_register, fetch_regs,
	store_regs, fetch_fpregs, store_fpregs, fetch_fpxregs, store_fpxregs):
	Likewise.
	(i386_linux_fetch_inferior_registers): Likewise.
	(i386_linux_store_inferior_registers): Likewise.
	* ia64-linux-nat.c (ia64_linux_fetch_register): Likewise.
	(ia64_linux_fetch_registers): Likewise.
	(ia64_linux_store_register): Likewise.
	(ia64_linux_store_registers): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	(inf_child_store_inferior_registers): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_register): Likewise.
	(inf_ptrace_fetch_registers): Likewise.
	(inf_ptrace_store_register): Likewise.
	(inf_ptrace_store_registers): Likewise.
	* infptrace.c (fetch_register, store_register): Likewise.
	(fetch_inferior_registers, store_inferior_registers): Likewise.
	* m32r-linux-nat.c (fetch_regs, store_regs): Likewise.
	(m32r_linux_fetch_inferior_registers): Likewise.
	(m32r_linux_store_inferior_registers): Likewise.
	* m68kbsd-nat.c (m68kbsd_fetch_inferior_registers): Likewise.
	(m68kbsd_store_inferior_registers): Likewise.
	* m68klinux-nat.c (fetch_register, old_fetch_inferior_registers,
	store_register, old_store_inferior_registers, fetch_regs, store_regs,
	fetch_fpregs, store_fpregs): Likewise.
	(m68k_linux_fetch_inferior_registers): Likewise.
	(m68k_linux_store_inferior_registers): Likewise.
	* m88kbsd-nat.c (m88kbsd_fetch_inferior_registers): Likewise.
	(m88kbsd_store_inferior_registers): Likewise.
	* mips64obsd-nat.c (mips64obsd_fetch_inferior_registers): Likewise.
	(mips64obsd_store_inferior_registers): Likewise.
	* mips-linux-nat.c (mips64_linux_regsets_fetch_registers): Likewise.
	(mips64_linux_regsets_store_registers): Likewise.
	(mips64_linux_fetch_registers): Likewise.
	(mips64_linux_store_registers): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers): Likewise.
	(mipsnbsd_store_inferior_registers): Likewise.
	* monitor.c (monitor_fetch_register, monitor_store_register): Likewise.
	(monitor_fetch_registers, monitor_store_registers): Likewise.
	* nto-procfs.c (procfs_fetch_registers): Likewise.
	(procfs_store_registers): Likewise.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register,
	fetch_register, supply_vrregset, fetch_altivec_registers,
	fetch_ppc_registers, ppc_linux_fetch_inferior_registers): Likewise.
	(store_altivec_register, store_spe_register, store_register,
	fill_vrregset, store_altivec_registers, store_ppc_registers,
	ppc_linux_store_inferior_registers): Likewise.
	* ppcnbsd-nat.c (ppcnbsd_fetch_inferior_registers): Likewise.
	(ppcnbsd_store_inferior_registers): Likewise.
	* ppcobsd-nat.c (ppcobsd_fetch_registers): Likewise.
	(ppcobsd_store_registers): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* remote.c (fetch_register_using_p, process_g_packet,
	fetch_registers_using_g, remote_fetch_registers): Likewise.
	(store_register_using_P, store_registers_using_G,
	remote_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers, m32r_fetch_register,
	m32r_store_register, m32r_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers, mips_store_registers): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	(gdbsim_store_register): Likewise.
	* rs6000-nat.c (fetch_register, store_register): Likewise.
	(rs6000_fetch_inferior_registers): Likewise.
	(rs6000_store_inferior_registers): Likewise.
	* s390-nat.c (fetch_regs, store_regs): Likewise.
	(fetch_fpregs, store_fpregs): Likewise.
	(s390_linux_fetch_inferior_registers): Likewise.
	(s390_linux_store_inferior_registers): Likewise.
	* shnbsd-nat.c (shnbsd_fetch_inferior_registers): Likewise.
	(shnbsd_store_inferior_registers): Likewise.
	* sol-thread.c (sol_thread_fetch_registers): Likewise.
	(sol_thread_store_registers): Likewise.
	* sparc-nat.c (fetch_inferior_registers): Likewise.
	(store_inferior_registers): Likewise.
	* spu-linux-nat.c (spu_fetch_inferior_registers): Likewise.
	(spu_store_inferior_registers): Likewise.
	* target.c (debug_print_register): Likewise.
	(debug_to_fetch_registers, debug_to_store_registers): Likewise.
	* vaxbsd-nat.c (vaxbsd_fetch_inferior_registers): Likewise.
	(vaxbsd_store_inferior_registers): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers): Likewise.
	(win32_fetch_inferior_registers): Likewise.
	(win32_store_inferior_registers): Likewise.
@
text
@d2042 1
a2042 1
win32_prepare_to_store (void)
@


1.128
log
@	* gdbcore.h (struct regcache): Add forward declaration.
	(struct core_fns): Add REGCACHE argument to core_read_registers
	callback.
	* corelow.c (get_core_register_section): Add REGCACHE argument,
	use it instead of current_regcache, pass it to core_read_registers
	callback.
	(get_core_registers): Add current_regcache as parameter to
	get_core_register_section calls.

	* alpha-nat.c (fetch_osf_core_registers): Add REGCACHE argument,
	use it instead of current_regcache.
	* armnbsd-nat.c (fetch_core_registers): Likewise.
	(fetch_elfcore_registers): Likewise.
	* core-regset.c (fetch_core_registers): Likewise.
	* cris-tdep.c (fetch_core_registers): Likewise.
	* irix5-nat.c (fetch_core_registers): Likewise.
	* m68klinux-nat.c (fetch_core_registers): Likewise.
	* mips-linux-tdep.c (fetch_core_registers): Likewise.
	* win32-nat.c (fetch_elf_core_registers): Likewise.
@
text
@d346 1
a346 1
do_win32_fetch_inferior_registers (int r)
d388 1
a388 1
      regcache_raw_supply (current_regcache, r, (char *) &l);
d393 1
a393 1
      regcache_raw_supply (current_regcache, r, (char *) &l);
d396 1
a396 1
    regcache_raw_supply (current_regcache, r, context_offset);
d400 1
a400 1
	do_win32_fetch_inferior_registers (r);
d407 1
a407 1
win32_fetch_inferior_registers (int r)
d413 1
a413 1
    do_win32_fetch_inferior_registers (r);
d417 1
a417 1
do_win32_store_inferior_registers (int r)
d422 1
a422 1
    regcache_raw_collect (current_regcache, r,
d427 1
a427 1
	do_win32_store_inferior_registers (r);
d433 1
a433 1
win32_store_inferior_registers (int r)
d439 1
a439 1
    do_win32_store_inferior_registers (r);
d1321 1
a1321 1
	  win32_fetch_inferior_registers (PS_REGNUM);
@


1.127
log
@	* win32-nat.c (win32_detach): Remove delete_command call.
	Resume inferior with win32_resume instead of win32_continue.
@
text
@d2247 2
a2248 1
fetch_elf_core_registers (char *core_reg_sect,
d2260 1
a2260 1
    regcache_raw_supply (current_regcache, r, core_reg_sect + mappings[r]);
@


1.126
log
@	* win32-nat.c (win32_wait): Reset terminal pgrp to GDB.
	(do_initial_win32_stuff): Call terminal_init_inferior_with_pgrp
	instead of target_terminal_init since inferior_ptid isn't set yet.
@
text
@d1778 3
a1780 2
      delete_command (NULL, 0);
      win32_continue (DBG_CONTINUE, -1);
@


1.125
log
@Copyright updates for 2007.
@
text
@d1545 2
d1592 1
a1592 1
  target_terminal_init ();
@


1.124
log
@	* win32-nat.c (env_sort): Remove.
	(win32_create_inferior): Remove code which creates a Windows
	environment.  Use Cygwin function call instead.  Propagate
	current environment to inferior process.
@
text
@d4 1
a4 2
   2005, 2006
   Free Software Foundation, Inc.
@


1.123
log
@(check in missing file)
* win32-nat.c (cygwin_exceptions): New variable.
(handle_exception): Treat a cygwin exception like a normal exception if
cygwin_exceptions is true.
(_initialize_win32_nat): Add "set cygwin-exceptions" handler.
@
text
@a1844 9
/* Function called by qsort to sort environment strings.  */
static int
env_sort (const void *a, const void *b)
{     
  const char **p = (const char **) a; 
  const char **q = (const char **) b;
  return strcasecmp (*p, *q);
}

a1853 4
  char *winenv;
  char *temp;
  int envlen;
  int i;
d1908 1
a1908 77
  {
    /* This code used to assume all env vars were file names and would
       translate them all to win32 style.  That obviously doesn't work in the
       general case.  The current rule is that we only translate PATH.
       We need to handle PATH because we're about to call CreateProcess and
       it uses PATH to find DLL's.  Fortunately PATH has a well-defined value
       in both posix and win32 environments.  cygwin.dll will change it back
       to posix style if necessary.  */

    static const char *conv_path_names[] =
    {
      "PATH=",
      0
    };

    /* CreateProcess takes the environment list as a null terminated set of
       strings (i.e. two nulls terminate the list).  */

    /* Get total size for env strings.  */
    for (envlen = 0, i = 0; in_env[i] && *in_env[i]; i++)
      {
	int j, len;

	for (j = 0; conv_path_names[j]; j++)
	  {
	    len = strlen (conv_path_names[j]);
	    if (strncmp (conv_path_names[j], in_env[i], len) == 0)
	      {
		if (cygwin_posix_path_list_p (in_env[i] + len))
		  envlen += len
		    + cygwin_posix_to_win32_path_list_buf_size (in_env[i] + len);
		else
		  envlen += strlen (in_env[i]) + 1;
		break;
	      }
	  }
	if (conv_path_names[j] == NULL)
	  envlen += strlen (in_env[i]) + 1;
      }

    size_t envsize = sizeof (in_env[0]) * (i + 1);
    char **env = (char **) alloca (envsize);
    memcpy (env, in_env, envsize);
    /* Windows programs expect the environment block to be sorted.  */
    qsort (env, i, sizeof (char *), env_sort);

    winenv = alloca (envlen + 1);

    /* Copy env strings into new buffer.  */
    for (temp = winenv, i = 0; env[i] && *env[i]; i++)
      {
	int j, len;

	for (j = 0; conv_path_names[j]; j++)
	  {
	    len = strlen (conv_path_names[j]);
	    if (strncmp (conv_path_names[j], env[i], len) == 0)
	      {
		if (cygwin_posix_path_list_p (env[i] + len))
		  {
		    memcpy (temp, env[i], len);
		    cygwin_posix_to_win32_path_list (env[i] + len, temp + len);
		  }
		else
		  strcpy (temp, env[i]);
		break;
	      }
	  }
	if (conv_path_names[j] == NULL)
	  strcpy (temp, env[i]);

	temp += strlen (temp) + 1;
      }

    /* Final nil string to terminate new env.  */
    *temp = 0;
  }
d1938 1
a1938 1
		       winenv,
@


1.122
log
@* win32-nat.c (open_symbol_file_object): New function.
(in_dynsym_resolve_code): Ditto.
(init_win32_ops): Fill in fields which ought not to be NULL.
@
text
@d145 1
d1118 1
a1118 1
	if ((addr >= cygwin_load_start && addr < cygwin_load_end)
d2441 7
@


1.122.6.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@a144 1
static int cygwin_exceptions = 0;
d1117 1
a1117 1
	if ((!cygwin_exceptions && (addr >= cygwin_load_start && addr < cygwin_load_end))
a2439 7
  add_setshow_boolean_cmd ("cygwin-exceptions", class_support, &cygwin_exceptions, _("\
Break when an exception is detected in the Cygwin DLL itself."), _("\
Show whether gdb breaks on exceptions in the Cygwin DLL itself."), NULL,
			   NULL,
			   NULL, /* FIXME: i18n: */
			   &setlist, &showlist);

@


1.121
log
@* win32-nat.c (do_win32_fetch_inferior_registers): Don't do anything with saved
context if __COPY_CONTEXT_SIZE is not defined.
(handle_output_debug_string): Ditto.
@
text
@d2348 12
d2407 2
a2408 2
  win32_so_ops.open_symbol_file_object = NULL;
  win32_so_ops.in_dynsym_resolve_code = NULL;
@


1.120
log
@* win32_nat.c (cygwin_load_start): New variable.
(cygwin_load_end): Ditto.
(have_saved_context): Ditto.
(saved_context): Ditto.
(max_dll_name_len): Delete obsolete variable.
(do_win32_fetch_inferior_registers): Use context saved from cygwin1.dll if we
are in a cygwin signal rather than a windows signal.
(solib_symbols_add): Detect and store beginning and end of cygwin DLL if dll
being loaded is the cygwin DLL.
(register_loaded_dll): Remove calculation of max_dll_name_len.
(win32_clear_solib): Ditto.
(handle_load_dll): Delete obsolete variable.  Remove unneeded call to
solib_add.
(handle_output_debug_string): Detect and store signal information sent by
Cygwin here.
(handle_exception): Silently pass on errors in the cygwin DLL.  Return -1 on
first pass exception.
(win32_continue): Remove spurious clearing of continue_status.
(get_win32_debug_event): Deal differently first chance exception.
@
text
@d357 1
d367 1
d933 1
d961 1
@


1.119
log
@	* infcmd.c: Include "observer.h".
	(post_create_inferior): New function.
	(run_command_1): Call it.  Also call proceed.
	* inferior.h (post_create_inferior): New prototype.
	* Makefile.in (infcmd.o): Update.

	* gnu-nat.c (gnu_create_inferior): Don't call proceed.
	* go32-nat.c (go32_create_inferior): Likewise.
	* nto-procfs.c (procfs_create_inferior): Likewise.
	* procfs.c (procfs_create_inferior): Likewise.
	* remote-sim.c (gdbsim_create_inferior): Likewise.
	* remote.c (extended_remote_create_inferior)
	(extended_remote_async_create_inferior): Likewise.
	* win32-nat.c (win32_create_inferior): Likewise.
	* wince.c (child_create_inferior): Likewise.

	* monitor.c (monitor_create_inferior): Don't call proceed.
	Set the PC manually.
	* ocd.c (ocd_create_inferior): Likewise.
	* remote-e7000.c (e7000_create_inferior): Likewise.
	* remote-m32r-sdi.c (m32r_create_inferior): Likewise.
	* remote-mips.c (mips_create_inferior): Likewise.
	* remote-rdp.c (remote_rdp_create_inferior): Likewise.
	* remote-sds.c (sds_create_inferior): Likewise.
	* remote-st.c (st2000_create_inferior): Likewise.

	* inf-ptrace.c (inf_ptrace_create_inferior): Don't call
	proceed or observer_notify_inferior_created.
	* inf-ttrace.c (inf_ttrace_create_inferior): Likewise.
	* inftarg.c (child_create_inferior): Likewise.
@
text
@d47 1
d67 7
d357 21
a377 10
      thread_info *th = current_thread;
      th->context.ContextFlags = CONTEXT_DEBUGGER_DR;
      GetThreadContext (th->h, &th->context);
      /* Copy dr values from that thread.  */
      dr[0] = th->context.Dr0;
      dr[1] = th->context.Dr1;
      dr[2] = th->context.Dr2;
      dr[3] = th->context.Dr3;
      dr[6] = th->context.Dr6;
      dr[7] = th->context.Dr7;
a617 1

a621 1

d660 1
a680 2

      bfd_close (abfd);
d702 10
a715 3
/* Remember the maximum DLL length for printing in info dll command. */
static int max_dll_name_len;

a758 2
  if (len > max_dll_name_len)
    max_dll_name_len = len;
d761 1
a813 1
  char *p;
a827 1
  solib_add (NULL, 0, NULL, auto_solib_add);
a882 1
  max_dll_name_len = sizeof ("DLL Name") - 1;
d919 2
a920 2
  char *s;
  int gotasig = FALSE;
d925 2
a926 3
    return gotasig;

  if (strncmp (s, _CYGWIN_SIGNAL_STRING, sizeof (_CYGWIN_SIGNAL_STRING) - 1) != 0)
d933 5
d940 1
a940 1
      gotasig = target_signal_from_host (sig);
d943 14
a956 1
	ourstatus->kind = TARGET_WAITKIND_STOPPED;
d959 3
a961 2
  xfree (s);
  return gotasig;
d1105 6
d1112 4
a1115 4
	if (find_pc_partial_function ((CORE_ADDR) current_event.u.Exception
				      .ExceptionRecord.ExceptionAddress,
				      &fn, NULL, NULL)
	    && strncmp (fn, "KERNEL32!IsBad", strlen ("KERNEL32!IsBad")) == 0)
d1192 1
d1194 1
a1194 1
	return 0;
a1221 1
  continue_status = 0;
d1263 81
d1355 1
d1368 1
d1482 13
a1494 4
      if (handle_exception (ourstatus))
	retval = current_event.dwThreadId;
      else
	continue_status = DBG_EXCEPTION_NOT_HANDLED;
d1504 1
a1504 2
      if (handle_output_debug_string (ourstatus))
	retval = main_thread_id;
d1519 6
a1524 1
    CHECK (win32_continue (continue_status, -1));
a2123 81
win32_resume (ptid_t ptid, int step, enum target_signal sig)
{
  thread_info *th;
  DWORD continue_status = DBG_CONTINUE;

  int pid = PIDGET (ptid);

  if (sig != TARGET_SIGNAL_0)
    {
      if (current_event.dwDebugEventCode != EXCEPTION_DEBUG_EVENT)
	{
	  DEBUG_EXCEPT(("Cannot continue with signal %d here.\n",sig));
	}
      else if (sig == last_sig)
	continue_status = DBG_EXCEPTION_NOT_HANDLED;
      else
#if 0
/* This code does not seem to work, because
  the kernel does probably not consider changes in the ExceptionRecord
  structure when passing the exception to the inferior.
  Note that this seems possible in the exception handler itself.  */
	{
	  int i;
	  for (i = 0; xlate[i].them != -1; i++)
	    if (xlate[i].us == sig)
	      {
		current_event.u.Exception.ExceptionRecord.ExceptionCode =
		  xlate[i].them;
		continue_status = DBG_EXCEPTION_NOT_HANDLED;
		break;
	      }
	  if (continue_status == DBG_CONTINUE)
	    {
	      DEBUG_EXCEPT(("Cannot continue with signal %d.\n",sig));
	    }
	}
#endif
	DEBUG_EXCEPT(("Can only continue with recieved signal %d.\n",
	  last_sig));
    }

  last_sig = TARGET_SIGNAL_0;

  DEBUG_EXEC (("gdb: win32_resume (pid=%d, step=%d, sig=%d);\n",
	       pid, step, sig));

  /* Get context for currently selected thread */
  th = thread_rec (current_event.dwThreadId, FALSE);
  if (th)
    {
      if (step)
	{
	  /* Single step by setting t bit */
	  win32_fetch_inferior_registers (PS_REGNUM);
	  th->context.EFlags |= FLAG_TRACE_BIT;
	}

      if (th->context.ContextFlags)
	{
	  if (debug_registers_changed)
	    {
	      th->context.Dr0 = dr[0];
	      th->context.Dr1 = dr[1];
	      th->context.Dr2 = dr[2];
	      th->context.Dr3 = dr[3];
	      /* th->context.Dr6 = dr[6];
	       FIXME: should we set dr6 also ?? */
	      th->context.Dr7 = dr[7];
	    }
	  CHECK (SetThreadContext (th->h, &th->context));
	  th->context.ContextFlags = 0;
	}
    }

  /* Allow continuing with the same signal that interrupted us.
     Otherwise complain. */

  win32_continue (continue_status, pid);
}

static void
@


1.118
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d3 2
a4 1
   Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
a1912 1
  proceed ((CORE_ADDR) - 1, TARGET_SIGNAL_0, 0);
@


1.117
log
@* win32-nat.c (env_sort): New function.
(win32_create_inferior): Rename env to in_env.  Sort environment before handing
it off to CreateProcess.
(win32_current_sos): Quiet a compiler warning.
@
text
@d3 1
a3 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
d22 2
a23 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.116
log
@* win32-nat.c (CYGWIN_SIGNAL_STRING): Delete.
(_CYGWIN_SIGNAL_STRING): Define if not already defined in cygwin.h.
(win32_add_thread): Use XZALLOC rather than xmalloc/memset.
(register_loaded_dll): Ditto.
(handle_load_dll): Call solib_add here.
(handle_unload_dll): Ditto.
(info_dll_command): Delete.
(handle_output_debug_string): Use official _CYGWIN_SIGNAL_STRING.
(win32_current_sos): Duplicate table to pass off to caller rather than deleting
our version.
(set_win32_aliases): New function.
(_initialize_win32_nat): Remove local handling of "info shared".  Set
deprecated_init_ui_hook to allow late setting of "info dll" alias.
@
text
@d1700 9
d1715 1
a1715 1
win32_create_inferior (char *exec_file, char *allargs, char **env,
d1795 1
a1795 1
    for (envlen = 0, i = 0; env[i] && *env[i]; i++)
d1802 1
a1802 1
	    if (strncmp (conv_path_names[j], env[i], len) == 0)
d1804 1
a1804 1
		if (cygwin_posix_path_list_p (env[i] + len))
d1806 1
a1806 1
		    + cygwin_posix_to_win32_path_list_buf_size (env[i] + len);
d1808 1
a1808 1
		  envlen += strlen (env[i]) + 1;
d1813 1
a1813 1
	  envlen += strlen (env[i]) + 1;
d1816 6
d2244 1
a2244 1
  struct so_list *last;
@


1.116.4.1
log
@	Backport:
	2006-01-24  Daniel Jacobowitz  <dan@@codesourcery.com>

	* infcmd.c: Include "observer.h".
	(post_create_inferior): New function.
	(run_command_1): Call it.  Also call proceed.
	* inferior.h (post_create_inferior): New prototype.
	* Makefile.in (infcmd.o): Update.
...
@
text
@d1897 1
@


1.115
log
@* win32-nat.c (get_relocated_section_addrs): Reinstate.
(solib_symbols_add): New function.
(lm_info): Remove end_addr field.
(register_loaded_dll): Don't try to find end_addr since gdb will do this
automatically now.  Make so_original_name == so_name for now.  Eliminate strcpy
by using so_name directly.  Read in symbols if new paramater "readsyms" is
true.
(handle_load_dll): Pass auto_solib_add to register_loaded_dll to control when
symbols should be read.
(win32_free_so): Don't free objfile here.
(win32_create_inferior_hook): New function.
(handle_unload_dll): Remove left-over cruft.
(win32_special_symbol_handling): New (dummy) function.
(map_single_dll_code_section): Reinstate.
(dll_code_sections_add): Reinstate.
(core_section_load_dll_symbols): Reinstate.  Don't issue an error on duplicate
attempts to read same dll.  Make sure that UNIX-like name is used to register
DLL.
(win32_current_sos): Handle core files.  Reset private list before passing
start of list pointer to gdb.
(init_win32_ops): Fill out (currently unused) solib_create_inferior_hook.  Fill
out special_symbol_handling.
* config/i386/tm-cygwin.h: Remove most special solib stuff.
@
text
@d87 3
a89 1
#define CYGWIN_SIGNAL_STRING "cygwin: signal"
d268 1
a268 2
  th = (thread_info *) xmalloc (sizeof (*th));
  memset (th, 0, sizeof (*th));
d726 1
a726 2
  so = (struct so_list *) xmalloc (sizeof (struct so_list));
  memset (so, 0, sizeof (*so));
d806 1
d847 1
d850 1
a892 16
/* List currently loaded DLLs. */
static void
info_dll_command (char *ignore, int from_tty)
{
  struct so_list *so = &solib_start;

  if (!so->next)
    return;

  printf_filtered ("%*s  Load Address\n", -max_dll_name_len, "DLL Name");
  while ((so = so->next) != NULL)
    printf_filtered ("%*s  %08lx\n", -max_dll_name_len, so->so_name, so->lm_info->load_addr);

  return;
}

d907 1
a907 1
  if (strncmp (s, CYGWIN_SIGNAL_STRING, sizeof (CYGWIN_SIGNAL_STRING) - 1) != 0)
d915 1
a915 1
      int sig = strtol (s + sizeof (CYGWIN_SIGNAL_STRING) - 1, &p, 0);
d2227 5
a2231 3
  struct so_list *head = solib_start.next;
  win32_clear_solib ();
  if (!head && core_bfd)
d2233 1
a2235 2
      head = solib_start.next;
      win32_clear_solib ();
d2237 16
a2252 1
  return head;
d2325 6
a2393 3
  add_info ("dll", info_dll_command, _("Status of loaded DLLs."));
  add_info_alias ("sharedlibrary", "dll", 1);

d2402 1
@


1.114
log
@* win32-nat.c: Remove comment intended only for debugging.
@
text
@d57 1
a520 1
  DWORD end_addr;
d580 108
d691 2
a692 2
static void
register_loaded_dll (const char *name, DWORD load_addr)
a694 1
  char ppath[MAX_PATH + 1];
d725 1
a725 2
  cygwin_conv_to_posix_path (buf, ppath);
  so = (struct so_list *) xmalloc (sizeof (struct so_list) + strlen (ppath) + 8 + 1);
d729 2
a730 8
  if (VirtualQueryEx (current_process_handle, (void *) load_addr, &m,
		      sizeof (m)))
    so->lm_info->end_addr = (DWORD) m.AllocationBase + m.RegionSize;
  else
    so->lm_info->end_addr = load_addr + 0x2000;	/* completely arbitrary */

  so->next = NULL;
  strcpy (so->so_name, ppath);
d734 1
a734 1
  len = strlen (ppath);
d737 3
d805 1
a805 1
  register_loaded_dll (dll_name, (DWORD) event->lpBaseOfDll + 0x1000);
a812 2
  if (so->objfile)
    free_objfile (so->objfile);
d817 3
a819 2
static struct so_list *
win32_current_sos (void)
d821 2
a822 1
  return solib_start.next;
d826 1
a826 2
win32_relocate_section_addresses (struct so_list *so,
				  struct section_table *sec)
d828 1
a828 1
  /* FIXME */
a856 2
  struct so_list *so, *so1 = solib_start.next;

d862 6
d1684 1
a1684 1
                       cygwin_internal (CW_GETPINFO, cpid | CW_NEXTPID));
d1689 3
a1691 3
         cygwin_conv_to_full_posix_path (pinfo->progname, path);
         path_ptr = path; 
         break;
d1695 1
a1695 1
  return path_ptr; 
d2096 172
d2312 2
a2313 2
  win32_so_ops.solib_create_inferior_hook = NULL;
  win32_so_ops.special_symbol_handling = NULL;
a2445 16
static void
fetch_elf_core_registers (char *core_reg_sect,
			  unsigned core_reg_size,
			  int which,
			  CORE_ADDR reg_addr)
{
  int r;
  if (core_reg_size < sizeof (CONTEXT))
    {
      error (_("Core file register section too small (%u bytes)."), core_reg_size);
      return;
    }
  for (r = 0; r < NUM_REGS; r++)
    regcache_raw_supply (current_regcache, r, core_reg_sect + mappings[r]);
}

@


1.113
log
@Change child_ to win32_ throughout.
* win32-nat.c (win32_ops): New variable.
(win32_so_ops): Ditto.
(psapi_get_dll_name): Make function static.
(struct so_stuff): Delete.
(struct lm_info): New struct.
(solib_start, solib_end): Redefine as struct so_list.
(safe_symbol_file_add_stub): Use so_list rather than so_stuff.
(register_loaded_dll): Ditto.  Special-case ntdll.dll.  Fill in lm_info field
of so_list with information previously stored in so_stuff.
(get_image_name): Make function static.
(max_dll_name_len): Make variable static.
(win32_free_so): New function.
(win32_current_sos): Ditto.
(win32_relocate_section_addresses): Ditto.
(handle_unload_dll): Use so_list rather than so_stuff.  Call free_so to delete
shared library.
(solib_address): Delete function.
(child_solib_loaded_library_pathname): Ditto.
(win32_clear_solib): Rename from child_clear_solibs.  Use so_list rather than
so_stuff.  Just clear win32-specific stuff.
(get_relocated_section_addrs): Delete.
(solib_symbols_add): Ditto.
(info_dll_command): Make static.  Use lm_info field from so_list to retrieve
load address.
(fake_create_process): Make function static.
(win32_xfer_memory): Ditto.
(win32_kill_inferior): Ditto.
(win32_resume): Ditto.
(cygwin_pid_to_str): Ditto.
(do_initial_win32_stuff): Use win32_ops rather than deprecated_child_ops.
(child_detach): Ditto.
(win32_mourn_inferior): Ditto.
(_initialize_win32_nat): Ditto.
(init_win32_ops): Ditto.  Fill out win32_so_ops and set current_target_so_ops
to win32_so_ops.
(core_dll_symbols_add): Delete.
(map_single_dll_code_section): Ditto.
(dll_code_sections_add): Ditto.
(core_section_load_dll_symbols): Ditto.
(child_solib_add): Ditto.
@
text
@a515 1
/*CGF*/
@


1.112
log
@Index: gdb/ChangeLog
+2005-07-06  Bob Rossi  <bob@@brasko.net>
+
+	* fork-child.c (fork-inferior): Use accessor function for
+	inferior_io_terminal.
+	* infcmd.c (inferior_io_terminal): Make static.
+	(set_inferior_io_terminal): New function.
+	(get_inferior_io_terminal): Ditto.
+	(tty_command): Use accessor function.
+	(_initialize_infcmd): Add inferior_tty setshow variable.
+	(_initialize_infcmd): Remove tty command.
+	(_initialize_infcmd): Add a tty command that is an alias.
+	* inferior.h (set_inferior_io_terminal): New prototype.
+	(get_inferior_io_terminal): Ditto.
+	(new_tty_prefork): Add const qualifier to parameter.
+	* inflow.c (inferior_thisrun_terminal): Add const qualifier.
+	(new_tty_prefork): Add const qualifier to parameter.
+	* nto-procfs (procfs_create_inferior): Use accessor function.
+	(procfs_create_inferior): Add const qualifier to locals.
+	* win32-nat.c (child_create_inferior): Ditto.
+	* mi/mi-cmd-env.c (mi_cmd_inferior_tty_set): New function.
+	(mi_cmd_inferior_tty_set): Ditto.
+	* mi/mi-cmds.c (mi_cmds): Add inferior-tty-set and inferior-tty-show
+	* mi/mi-cmds.h (mi_cmd_inferior_tty_set): Add prototype.
+	(mi_cmd_inferior_tty_show): Ditto.

Index: gdb/doc/ChangeLog
+2005-07-06  Bob Rossi  <bob@@brasko.net>
+
+	* gdb.texinfo (GDB/MI Miscellaneous Commands): Add -inferior-tty-set
+	and -inferior-tty-show.
+	(Input/Output): Document "set/show inferior-tty" and tty alias.

Index: gdb/testsuite/ChangeLog
+2005-07-06  Bob Rossi  <bob@@brasko.net>
+
+	* gdb.mi/mi-basics.exp (test_setshow_inferior_tty): Test MI tty
+	command.
+	(Copyright): Update copyright.
@
text
@d56 1
d61 3
d94 3
a96 3
static void child_stop (void);
static int win32_child_thread_alive (ptid_t);
void child_kill_inferior (void);
d258 1
a258 1
child_add_thread (DWORD id, HANDLE h)
d294 1
a294 1
child_init_thread_list (void)
d298 1
a298 1
  DEBUG_EVENTS (("gdb: child_init_thread_list\n"));
d312 1
a312 1
child_delete_thread (DWORD id)
d335 1
a335 1
do_child_fetch_inferior_registers (int r)
d376 1
a376 1
	do_child_fetch_inferior_registers (r);
d383 1
a383 1
child_fetch_inferior_registers (int r)
d389 1
a389 1
    do_child_fetch_inferior_registers (r);
d393 1
a393 1
do_child_store_inferior_registers (int r)
d403 1
a403 1
	do_child_store_inferior_registers (r);
d409 1
a409 1
child_store_inferior_registers (int r)
d415 1
a415 1
    do_child_store_inferior_registers (r);
d424 1
a424 1
int
d516 1
d518 1
a518 1
struct so_stuff
a519 1
  struct so_stuff *next;
d522 3
a524 4
  int loaded;
  struct objfile *objfile;
  char name[1];
} solib_start, *solib_end;
d531 2
a532 2
#define p ((struct safe_symbol_file_add_args *)argv)
  struct so_stuff *so = &solib_start;
a533 3
  while ((so = so->next))
    if (so->loaded && strcasecmp (so->name, p->name) == 0)
      return 0;
d582 1
a582 1
int max_dll_name_len;
d587 1
a587 1
  struct so_stuff *so;
d614 5
d620 4
a623 3
  so = (struct so_stuff *) xmalloc (sizeof (struct so_stuff) + strlen (ppath) + 8 + 1);
  so->loaded = 0;
  so->load_addr = load_addr;
d626 1
a626 1
    so->end_addr = (DWORD) m.AllocationBase + m.RegionSize;
d628 1
a628 1
    so->end_addr = load_addr + 0x2000;	/* completely arbitrary */
d631 1
a631 2
  so->objfile = NULL;
  strcpy (so->name, ppath);
d640 1
a640 1
char *
d708 23
d735 1
a735 1
  struct so_stuff *so;
d738 1
a738 1
    if (so->next->load_addr == lpBaseOfDll)
d740 1
a740 1
	struct so_stuff *sodel = so->next;
d744 1
a744 3
	if (sodel->objfile)
	  free_objfile (sodel->objfile);
	xfree(sodel);
a751 17
char *
solib_address (CORE_ADDR address)
{
  struct so_stuff *so;
  for (so = &solib_start; so->next != NULL; so = so->next)
    if (address >= so->load_addr && address <= so->end_addr)
      return so->name;
  return NULL;
}

/* Return name of last loaded DLL. */
char *
child_solib_loaded_library_pathname (int pid)
{
  return !solib_end || !solib_end->name[0] ? NULL : solib_end->name;
}

d753 2
a754 2
void
child_clear_solibs (void)
d756 1
a756 7
  struct so_stuff *so, *so1 = solib_start.next;

  while ((so = so1) != NULL)
    {
      so1 = so->next;
      xfree (so);
    }
a758 1
  solib_start.objfile = NULL;
a762 108
/* Get the loaded address of all sections, given that .text was loaded
   at text_load. Assumes that all sections are subject to the same
   relocation offset. Returns NULL if problems occur or if the
   sections were not relocated. */

static struct section_addr_info *
get_relocated_section_addrs (bfd *abfd, CORE_ADDR text_load)
{
  struct section_addr_info *result = NULL;
  int section_count = bfd_count_sections (abfd);
  asection *text_section = bfd_get_section_by_name (abfd, ".text");
  CORE_ADDR text_vma;

  if (!text_section)
    {
      /* Couldn't get the .text section. Weird. */
    }

  else if (text_load == (text_vma = bfd_get_section_vma (abfd, text_section)))
    {
      /* DLL wasn't relocated. */
    }

  else
    {
      /* Figure out all sections' loaded addresses. The offset here is
	 such that taking a bfd_get_section_vma() result and adding
	 offset will give the real load address of the section. */

      CORE_ADDR offset = text_load - text_vma;

      struct section_table *table_start = NULL;
      struct section_table *table_end = NULL;
      struct section_table *iter = NULL;

      build_section_table (abfd, &table_start, &table_end);

      for (iter = table_start; iter < table_end; ++iter)
	{
	  /* Relocated addresses. */
	  iter->addr += offset;
	  iter->endaddr += offset;
	}

      result = build_section_addr_info_from_section_table (table_start,
							   table_end);

      xfree (table_start);
    }

  return result;
}

/* Add DLL symbol information. */
static struct objfile *
solib_symbols_add (char *name, int from_tty, CORE_ADDR load_addr)
{
  struct section_addr_info *addrs = NULL;
  static struct objfile *result = NULL;
  bfd *abfd = NULL;

  /* The symbols in a dll are offset by 0x1000, which is the
     the offset from 0 of the first byte in an image - because
     of the file header and the section alignment. */

  if (!name || !name[0])
    return NULL;

  abfd = bfd_openr (name, "pei-i386");

  if (!abfd)
    {
      /* pei failed - try pe */
      abfd = bfd_openr (name, "pe-i386");
    }

  if (abfd)
    {
      if (bfd_check_format (abfd, bfd_object))
	{
	  addrs = get_relocated_section_addrs (abfd, load_addr);
	}

      bfd_close (abfd);
    }

  if (addrs)
    {
      result = safe_symbol_file_add (name, from_tty, addrs, 0, OBJF_SHARED);
      free_section_addr_info (addrs);
    }
  else
    {
      /* Fallback on handling just the .text section. */
      struct cleanup *my_cleanups;

      addrs = alloc_section_addr_info (1);
      my_cleanups = make_cleanup (xfree, addrs);
      addrs->other[0].name = ".text";
      addrs->other[0].addr = load_addr;

      result = safe_symbol_file_add (name, from_tty, addrs, 0, OBJF_SHARED);
      do_cleanups (my_cleanups);
    }

  return result;
}

d786 1
a786 1
void
d789 1
a789 1
  struct so_stuff *so = &solib_start;
d796 1
a796 1
    printf_filtered ("%*s  %08lx\n", -max_dll_name_len, so->name, so->load_addr);
d1072 1
a1072 1
child_continue (DWORD continue_status, int id)
d1116 1
a1116 1
DWORD
d1122 1
a1122 1
  current_thread = child_add_thread (main_thread_id,
d1131 1
a1131 1
get_child_debug_event (int pid, struct target_waitstatus *ourstatus)
d1171 1
a1171 1
      th = child_add_thread (current_event.dwThreadId,
d1187 1
a1187 1
	  child_delete_thread (current_event.dwThreadId);
d1206 1
a1206 1
	child_delete_thread (main_thread_id);
d1209 1
a1209 1
      th = child_add_thread (main_thread_id,
d1292 1
a1292 1
    CHECK (child_continue (continue_status, -1));
d1305 1
a1305 1
child_wait (ptid_t ptid, struct target_waitstatus *ourstatus)
d1317 1
a1317 1
      int retval = get_child_debug_event (pid, ourstatus);
d1328 1
a1328 1
	    child_kill_inferior ();
d1334 1
a1334 1
do_initial_child_stuff (DWORD pid)
d1348 1
a1348 1
  push_target (&deprecated_child_ops);
d1350 1
a1350 1
  child_clear_solibs ();
d1460 1
a1460 1
     child_attach(). */
d1478 1
a1478 1
child_attach (char *args, int from_tty)
d1494 1
a1494 1
  child_init_thread_list ();
d1529 1
a1529 1
  do_initial_child_stuff (pid);
d1534 1
a1534 1
child_detach (char *args, int from_tty)
d1541 1
a1541 1
      child_continue (DBG_CONTINUE, -1);
d1560 1
a1560 1
  unpush_target (&deprecated_child_ops);
d1563 2
a1564 2
char *
child_pid_to_exec_file (int pid)
d1596 1
a1596 1
child_files_info (struct target_ops *ignore)
d1603 1
a1603 1
child_open (char *arg, int from_tty)
d1614 1
a1614 1
child_create_inferior (char *exec_file, char *allargs, char **env,
d1768 1
a1768 1
  child_init_thread_list ();
d1802 1
a1802 1
  do_initial_child_stuff (pi.dwProcessId);
d1804 1
a1804 1
  /* child_continue (DBG_CONTINUE, -1); */
d1809 1
a1809 1
child_mourn_inferior (void)
d1811 1
a1811 1
  (void) child_continue (DBG_CONTINUE, -1);
d1813 1
a1813 1
  unpush_target (&deprecated_child_ops);
d1821 1
a1821 1
child_stop (void)
d1828 2
a1829 2
int
child_xfer_memory (CORE_ADDR memaddr, gdb_byte *our, int len,
d1854 2
a1855 2
void
child_kill_inferior (void)
d1861 1
a1861 1
      if (!child_continue (DBG_CONTINUE, -1))
d1874 1
a1874 1
  target_mourn_inferior ();	/* or just child_mourn_inferior? */
d1877 2
a1878 2
void
child_resume (ptid_t ptid, int step, enum target_signal sig)
d1921 1
a1921 1
  DEBUG_EXEC (("gdb: child_resume (pid=%d, step=%d, sig=%d);\n",
d1931 1
a1931 1
	  child_fetch_inferior_registers (PS_REGNUM);
d1955 1
a1955 1
  child_continue (continue_status, pid);
d1959 1
a1959 1
child_prepare_to_store (void)
d1965 1
a1965 1
child_can_run (void)
d1971 1
a1971 1
child_close (int x)
d1973 1
a1973 1
  DEBUG_EVENTS (("gdb: child_close, inferior_ptid=%d\n",
d1977 14
d1992 1
a1992 1
init_child_ops (void)
d1994 49
a2042 37
  deprecated_child_ops.to_shortname = "child";
  deprecated_child_ops.to_longname = "Win32 child process";
  deprecated_child_ops.to_doc = "Win32 child process (started by the \"run\" command).";
  deprecated_child_ops.to_open = child_open;
  deprecated_child_ops.to_close = child_close;
  deprecated_child_ops.to_attach = child_attach;
  deprecated_child_ops.to_detach = child_detach;
  deprecated_child_ops.to_resume = child_resume;
  deprecated_child_ops.to_wait = child_wait;
  deprecated_child_ops.to_fetch_registers = child_fetch_inferior_registers;
  deprecated_child_ops.to_store_registers = child_store_inferior_registers;
  deprecated_child_ops.to_prepare_to_store = child_prepare_to_store;
  deprecated_child_ops.deprecated_xfer_memory = child_xfer_memory;
  deprecated_child_ops.to_files_info = child_files_info;
  deprecated_child_ops.to_insert_breakpoint = memory_insert_breakpoint;
  deprecated_child_ops.to_remove_breakpoint = memory_remove_breakpoint;
  deprecated_child_ops.to_terminal_init = terminal_init_inferior;
  deprecated_child_ops.to_terminal_inferior = terminal_inferior;
  deprecated_child_ops.to_terminal_ours_for_output = terminal_ours_for_output;
  deprecated_child_ops.to_terminal_ours = terminal_ours;
  deprecated_child_ops.to_terminal_save_ours = terminal_save_ours;
  deprecated_child_ops.to_terminal_info = child_terminal_info;
  deprecated_child_ops.to_kill = child_kill_inferior;
  deprecated_child_ops.to_create_inferior = child_create_inferior;
  deprecated_child_ops.to_mourn_inferior = child_mourn_inferior;
  deprecated_child_ops.to_can_run = child_can_run;
  deprecated_child_ops.to_thread_alive = win32_child_thread_alive;
  deprecated_child_ops.to_pid_to_str = cygwin_pid_to_str;
  deprecated_child_ops.to_stop = child_stop;
  deprecated_child_ops.to_stratum = process_stratum;
  deprecated_child_ops.to_has_all_memory = 1;
  deprecated_child_ops.to_has_memory = 1;
  deprecated_child_ops.to_has_stack = 1;
  deprecated_child_ops.to_has_registers = 1;
  deprecated_child_ops.to_has_execution = 1;
  deprecated_child_ops.to_magic = OPS_MAGIC;
  deprecated_child_ops.to_pid_to_exec_file = child_pid_to_exec_file;
d2050 1
a2050 1
  init_child_ops ();
d2118 1
a2118 2

  add_target (&deprecated_child_ops);
d2125 1
a2125 1
   actually set up when child_continue is called.  */
d2139 1
a2139 1
   will be actually set up in child_wait.  */
d2161 1
a2161 1
win32_child_thread_alive (ptid_t ptid)
a2168 200
/* Convert pid to printable format. */
char *
cygwin_pid_to_str (ptid_t ptid)
{
  static char buf[80];
  int pid = PIDGET (ptid);

  if ((DWORD) pid == current_event.dwProcessId)
    sprintf (buf, "process %d", pid);
  else
    sprintf (buf, "thread %ld.0x%x", current_event.dwProcessId, pid);
  return buf;
}

static int
core_dll_symbols_add (char *dll_name, DWORD base_addr)
{
  struct objfile *objfile;
  char *objfile_basename;
  const char *dll_basename;

  if (!(dll_basename = strrchr (dll_name, '/')))
    dll_basename = dll_name;
  else
    dll_basename++;

  ALL_OBJFILES (objfile)
  {
    objfile_basename = strrchr (objfile->name, '/');

    if (objfile_basename &&
	strcmp (dll_basename, objfile_basename + 1) == 0)
      {
	printf_unfiltered ("%08lx:%s (symbols previously loaded)\n",
			   base_addr, dll_name);
	goto out;
      }
  }

  register_loaded_dll (dll_name, base_addr + 0x1000);
  solib_symbols_add (dll_name, 0, (CORE_ADDR) base_addr + 0x1000);

 out:
  return 1;
}

typedef struct
{
  struct target_ops *target;
  bfd_vma addr;
} map_code_section_args;

static void
map_single_dll_code_section (bfd * abfd, asection * sect, void *obj)
{
  int old;
  int update_coreops;
  struct section_table *new_target_sect_ptr;

  map_code_section_args *args = (map_code_section_args *) obj;
  struct target_ops *target = args->target;
  if (sect->flags & SEC_CODE)
    {
      update_coreops = core_ops.to_sections == target->to_sections;

      if (target->to_sections)
	{
	  old = target->to_sections_end - target->to_sections;
	  target->to_sections = (struct section_table *)
	    xrealloc ((char *) target->to_sections,
		      (sizeof (struct section_table)) * (1 + old));
	}
      else
	{
	  old = 0;
	  target->to_sections = (struct section_table *)
	    xmalloc ((sizeof (struct section_table)));
	}
      target->to_sections_end = target->to_sections + (1 + old);

      /* Update the to_sections field in the core_ops structure
	 if needed.  */
      if (update_coreops)
	{
	  core_ops.to_sections = target->to_sections;
	  core_ops.to_sections_end = target->to_sections_end;
	}
      new_target_sect_ptr = target->to_sections + old;
      new_target_sect_ptr->addr = args->addr + bfd_section_vma (abfd, sect);
      new_target_sect_ptr->endaddr = args->addr + bfd_section_vma (abfd, sect) +
	bfd_section_size (abfd, sect);;
      new_target_sect_ptr->the_bfd_section = sect;
      new_target_sect_ptr->bfd = abfd;
    }
}

static int
dll_code_sections_add (const char *dll_name, int base_addr, struct target_ops *target)
{
  bfd *dll_bfd;
  map_code_section_args map_args;
  asection *lowest_sect;
  char *name;
  if (dll_name == NULL || target == NULL)
    return 0;
  name = xstrdup (dll_name);
  dll_bfd = bfd_openr (name, "pei-i386");
  if (dll_bfd == NULL)
    return 0;

  if (bfd_check_format (dll_bfd, bfd_object))
    {
      lowest_sect = bfd_get_section_by_name (dll_bfd, ".text");
      if (lowest_sect == NULL)
	return 0;
      map_args.target = target;
      map_args.addr = base_addr - bfd_section_vma (dll_bfd, lowest_sect);

      bfd_map_over_sections (dll_bfd, &map_single_dll_code_section, (void *) (&map_args));
    }

  return 1;
}

static void
core_section_load_dll_symbols (bfd * abfd, asection * sect, void *obj)
{
  struct target_ops *target = (struct target_ops *) obj;

  DWORD base_addr;

  int dll_name_size;
  char *dll_name = NULL;
  char *buf = NULL;
  struct win32_pstatus *pstatus;
  char *p;

  if (strncmp (sect->name, ".module", 7))
    return;

  buf = (char *) xmalloc (bfd_get_section_size (sect) + 1);
  if (!buf)
    {
      printf_unfiltered ("memory allocation failed for %s\n", sect->name);
      goto out;
    }
  if (!bfd_get_section_contents (abfd, sect, buf, 0, bfd_get_section_size (sect)))
    goto out;

  pstatus = (struct win32_pstatus *) buf;

  memmove (&base_addr, &(pstatus->data.module_info.base_address), sizeof (base_addr));
  dll_name_size = pstatus->data.module_info.module_name_size;
  if (offsetof (struct win32_pstatus, data.module_info.module_name) + dll_name_size > bfd_get_section_size (sect))
      goto out;

  dll_name = (char *) xmalloc (dll_name_size + 1);
  if (!dll_name)
    {
      printf_unfiltered ("memory allocation failed for %s\n", sect->name);
      goto out;
    }
  strncpy (dll_name, pstatus->data.module_info.module_name, dll_name_size);

  while ((p = strchr (dll_name, '\\')))
    *p = '/';

  if (!core_dll_symbols_add (dll_name, (DWORD) base_addr))
    printf_unfiltered ("%s: Failed to load dll symbols.\n", dll_name);

  if (!dll_code_sections_add (dll_name, (DWORD) base_addr + 0x1000, target))
    printf_unfiltered ("%s: Failed to map dll code sections.\n", dll_name);

out:
  if (buf)
    xfree (buf);
  if (dll_name)
    xfree (dll_name);
  return;
}

void
child_solib_add (char *filename, int from_tty, struct target_ops *target,
		 int readsyms)
{
  if (!readsyms)
    return;
  if (core_bfd)
    {
      child_clear_solibs ();
      bfd_map_over_sections (core_bfd, &core_section_load_dll_symbols, target);
    }
  else
    {
      if (solib_end && solib_end->name)
	     solib_end->objfile = solib_symbols_add (solib_end->name, from_tty,
						solib_end->load_addr);
    }
}

@


1.112.2.1
log
@	Backport:
	2006-01-24  Daniel Jacobowitz  <dan@@codesourcery.com>

	* infcmd.c: Include "observer.h".
	(post_create_inferior): New function.
	(run_command_1): Call it.  Also call proceed.
	* inferior.h (post_create_inferior): New prototype.
	* Makefile.in (infcmd.o): Update.
...
@
text
@d1911 1
@


1.111
log
@2005-05-23  Andrew Cagney  <cagney@@gnu.org>

	* target.h (child_xfer_memory): Use gdb_byte for byte buffer
	parameters.
	* inftarg.c (child_xfer_partial): Update.
	* wince.c (child_xfer_memory): Update.
	* win32-nat.c (child_xfer_memory): Update.
	* rs6000-nat.c (child_xfer_memory): Update.
	* infptrace.c (child_xfer_memory): Update.
	* dcache.c (struct dcache_block): Use gdb_byte for the byte
	buffers.
	(dcache_read_line, dcache_xfer_memory, dcache_poke_byte)
	(dcache_peek_byte, dcache_write_line): Ditto.
@
text
@d1738 1
@


1.110
log
@* win32-nat.c (handle_exception): Treat win32 routines which check for valid
addresses as "special" and don't stop when a SEGV is detected.
(get_child_debug_event): Properly flag exception as unhandled.
@
text
@d1934 1
a1934 1
child_xfer_memory (CORE_ADDR memaddr, char *our, int len,
@


1.109
log
@* win32-nat.c (do_initial_child_stuff): Don't clear the thread list here.
(do_initial_child_stuff): Move clearing of thread list to a place before a
thread ould be created.
(child_attach): Ditto.
@
text
@d1080 8
d1371 2
@


1.108
log
@2005-02-18  Andrew Cagney  <cagney@@gnu.org>

	Use add_setshow_boolean_command through out.  Delete #ifdef 0'ed
	code adding set/show boolean commands.
	* cp-valprint.c, dcache.c, exec.c, gdbtypes.c, infrun.c: Update.
	* monitor.c, p-valprint.c, pa64solib.c, printcmd.c: Update.
	* proc-api.c, remote-mips.c, remote.c, solib.c: Update.
	* somsolib.c, symfile.c, top.c, utils.c, valops.c: Update.
	* valprint.c, win32-nat.c, wince.c, xcoffsolib.c: Update.
	* cli/cli-cmds.c: Update.
@
text
@a1444 1
  child_init_thread_list ();
d1590 1
d1863 1
@


1.107
log
@2005-02-15  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_com, add_info and add_prefix_cmd.
	* breakpoint.c, cp-support.c, dcache.c, dwarf2read.c: Update.
	* exec.c, f-valprint.c, frame.c, gcore.c, gnu-nat.c: Update.
	* go32-nat.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* kod.c, language.c, linux-nat.c, m32r-rom.c, macrocmd.c: Update.
	* maint.c, memattr.c, mips-tdep.c, nto-procfs.c, objc-lang.c: Update.
	* ocd.c, pa64solib.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote-e7000.c, remote-m32r-sdi.c, remote-mips.c: Update.
	* remote-sds.c, remote-sim.c, remote-st.c, remote-utils.c: Update.
	* remote.c, rs6000-tdep.c, ser-go32.c, serial.c: Update.
	* sh-tdep.c, solib.c, somsolib.c, source.c, stack.c: Update.
	* symfile.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, typeprint.c, utils.c, valprint.c: Update.
	* win32-nat.c, xcoffsolib.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-layout.c, tui/tui-regs.c: Update.
	* tui/tui-stack.c, tui/tui-win.c: Update.
@
text
@d2126 49
a2174 48
  deprecated_add_show_from_set
    (add_set_cmd ("shell", class_support, var_boolean,
		  (char *) &useshell,
		  "Set use of shell to start subprocess.",
		  &setlist),
     &showlist);

  deprecated_add_show_from_set
    (add_set_cmd ("new-console", class_support, var_boolean,
		  (char *) &new_console,
		  "Set creation of new console when creating child process.",
		  &setlist),
     &showlist);

  deprecated_add_show_from_set
    (add_set_cmd ("new-group", class_support, var_boolean,
		  (char *) &new_group,
		  "Set creation of new group when creating child process.",
		  &setlist),
     &showlist);

  deprecated_add_show_from_set
    (add_set_cmd ("debugexec", class_support, var_boolean,
		  (char *) &debug_exec,
		  "Set whether to display execution in child process.",
		  &setlist),
     &showlist);

  deprecated_add_show_from_set
    (add_set_cmd ("debugevents", class_support, var_boolean,
		  (char *) &debug_events,
		  "Set whether to display kernel events in child process.",
		  &setlist),
     &showlist);

  deprecated_add_show_from_set
    (add_set_cmd ("debugmemory", class_support, var_boolean,
		  (char *) &debug_memory,
		  "Set whether to display memory accesses in child process.",
		  &setlist),
     &showlist);

  deprecated_add_show_from_set
    (add_set_cmd ("debugexceptions", class_support, var_boolean,
		  (char *) &debug_exceptions,
		  "Set whether to display kernel exceptions in child process.",
		  &setlist),
     &showlist);
@


1.106
log
@2005-02-14  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_cmd.
	* arch-utils.c, avr-tdep.c, breakpoint.c, corefile.c: Update.
	* cp-abi.c, cp-namespace.c, cp-support.c, dummy-frame.c: Update.
	* exec.c, gnu-nat.c, go32-nat.c, hppa-tdep.c, infcmd.c: Update.
	* infrun.c, interps.c, macrocmd.c, maint.c, memattr.c: Update.
	* mips-tdep.c, ocd.c, osabi.c, printcmd.c, regcache.c: Update.
	* reggroups.c, remote-fileio.c, remote-rdi.c, remote.c: Update.
	* sol-thread.c, source.c, stack.c, symfile-mem.c: Update.
	* symfile.c, thread.c, tracepoint.c, valprint.c, value.c: Update.
	* win32-nat.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-regs.c: Update.
@
text
@d2121 1
a2121 1
	       "Load dll library symbols from FILE.");
d2175 1
a2175 1
  add_info ("dll", info_dll_command, "Status of loaded DLLs.");
d2179 1
a2179 1
		  "Print information specific to Win32 debugging.",
@


1.105
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d2183 1
a2183 1
	   "Display selectors infos.",
@


1.104
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d1581 1
a1581 1
    error_no_arg ("process-id to attach");
d2199 1
a2199 1
		    "Invalid register %d in cygwin_set_dr.\n", i);
@


1.103
log
@* win32-nat.c: Update copyright year.
(child_init_thread_list): Set thread linked list point to NULL so that it won't
be reused after clearing.
@
text
@d481 1
a481 1
	error ("Can't get module info");
d488 1
a488 1
	error ("Error getting dll name: %u\n", (unsigned) GetLastError ());
d721 1
a721 1
  error ("Error: dll starting at 0x%lx not found.\n", (DWORD) lpBaseOfDll);
d877 1
a877 1
    error ("dll-symbols requires a file name");
d924 1
a924 1
	warning ("%s", s);
d1603 1
a1603 1
	error ("Can't attach to process.");
d1640 1
a1640 1
	  error ("Can't detach process %lu (error %lu)",
d1701 1
a1701 1
  error ("Use the \"run\" command to start a Unix child process.");
d1730 1
a1730 1
    error ("No executable specified, use `target exec'.\n");
d1885 2
a1886 1
    error ("Error creating process %s, (error %d)\n", exec_file, (unsigned) GetLastError ());
d2446 1
a2446 1
      error ("Core file register section too small (%u bytes).", core_reg_size);
d2492 1
a2492 1
	  warning ("obsolete '%s' found. Rename to '%s'.", oldini, newini);
@


1.102
log
@2005-01-12  Andrew Cagney  <cagney@@gnu.org>

	* exceptions.h (enum return_reason, RETURN_MASK)
	(RETURN_MASK_QUIT, RETURN_MASK_ERROR, RETURN_MASK_ALL)
	(return_mask, throw_exception, catch_exceptions_ftype)
	(catch_exceptions_with_msg, catch_errors_ftype, catch_errors)
	(catch_command_errors_ftype, catch_command_errors): Move to
	exceptions.h.
	* exceptions.c, exceptions.h: New files.
	* top.c: Do not include <setjmp.h>.
	(SIGJMP_BUF, SIGSETJMP, SIGLONGJMP, catch_return)
	(throw_exception, catcher, catch_exceptions)
	(catch_exceptions_with_msg, struct catch_errors_args)
	(do_catch_errors, catch_errors, struct captured_command_args)
	(do_captured_command, catch_command_errors): Move to exceptions.c.
	* wrapper.c, wince.c, win32-nat.c, utils.c: Include "exceptions.h".
	* tui/tui-interp.c, top.c, thread.c, symmisc.c: Ditto.
	* symfile-mem.c, stack.c, solib.c, rs6000-nat.c: Ditto.
	* remote-sds.c, remote-mips.c, remote-fileio.c: Ditto.
	* remote-e7000.c, objc-lang.c, ocd.c: Ditto.
	* remote.c, nto-procfs.c, monitor.c, mi/mi-main.c: Ditto.
	* main.c, m32r-rom.c, infrun.c, inf-loop.c: Ditto.
	* hppa-hpux-tdep.c, frame.c, event-top.c, event-loop.c: Ditto.
	* corelow.c, corefile.c, cli/cli-interp.c, breakpoint.c: Ditto.
	* ada-valprint.c, ada-lang.c: Ditto.
	* Makefile.in (HFILES_NO_SRCDIR, COMMON_OBS): Add exceptions.h and
	exceptions.o.  Update all dependencies.
@
text
@d3 1
a3 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d303 1
@


1.101
log
@2004-10-08  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Rename to_xfer_memory to
	deprecated_xfer_memory.
	* target.c: Update.
	(deprecated_debug_xfer_memory): Rename debug_to_xfer_memory.
	* wince.c: Update.
	* win32-nat.c: Update.
	* v850ice.c: Update.
	* uw-thread.c: Update.
	* thread-db.c: Update.
	* sol-thread.c: Update.
	* remote.c: Update.
	* remote-vx.c: Update.
	* remote-st.c: Update.
	* remote-sim.c: Update.
	* remote-sds.c: Update.
	* remote-rdp.c: Update.
	* remote-rdi.c: Update.
	* remote-mips.c: Update.
	* remote-m32r-sdi.c: Update.
	* remote-e7000.c: Update.
	* procfs.c: Update.
	* ppc-bdm.c: Update.
	* nto-procfs.c: Update.
	* monitor.c: Update.
	* linux-nat.c: Update.
	* inftarg.c: Update.
	* hpux-thread.c: Update.
	* go32-nat.c: Update.
	* gnu-nat.c: Update.
	* exec.c: Update.
	* corelow.c: Update.
	* bsd-kvm.c: Update.
	* aix-thread.c: Update.
@
text
@d33 1
@


1.100
log
@2004-10-05  Andrew Cagney  <cagney@@gnu.org>

	* target.h (deprecated_child_ops): Rename child_ops.
	* wince.c: Update copyright.  Rename child_ops.
	* win32-nat.c: Rename child_ops.
	* target.c: Rename child_ops.
	* rs6000-nat.c: Rename child_ops.
	* linux-nat.c: Rename child_ops.
	* infttrace.c: Rename child_ops.
	* inftarg.c: Rename child_ops.
	* infptrace.c: Rename child_ops.
	* hppah-nat.c: Update copyright.  Rename child_ops.
	* hpux-thread.c: Update copyright.  Rename child_ops.
@
text
@d2083 1
a2083 1
  deprecated_child_ops.to_xfer_memory = child_xfer_memory;
@


1.99
log
@2004-09-29  Andrew Cagney  <cagney@@gnu.org>

	* wince.c (child_ops): Delete.
	* win32-nat.c (child_ops): Delete.
@
text
@d1442 1
a1442 1
  push_target (&child_ops);
d1654 1
a1654 1
  unpush_target (&child_ops);
d1904 1
a1904 1
  unpush_target (&child_ops);
d2071 37
a2107 37
  child_ops.to_shortname = "child";
  child_ops.to_longname = "Win32 child process";
  child_ops.to_doc = "Win32 child process (started by the \"run\" command).";
  child_ops.to_open = child_open;
  child_ops.to_close = child_close;
  child_ops.to_attach = child_attach;
  child_ops.to_detach = child_detach;
  child_ops.to_resume = child_resume;
  child_ops.to_wait = child_wait;
  child_ops.to_fetch_registers = child_fetch_inferior_registers;
  child_ops.to_store_registers = child_store_inferior_registers;
  child_ops.to_prepare_to_store = child_prepare_to_store;
  child_ops.to_xfer_memory = child_xfer_memory;
  child_ops.to_files_info = child_files_info;
  child_ops.to_insert_breakpoint = memory_insert_breakpoint;
  child_ops.to_remove_breakpoint = memory_remove_breakpoint;
  child_ops.to_terminal_init = terminal_init_inferior;
  child_ops.to_terminal_inferior = terminal_inferior;
  child_ops.to_terminal_ours_for_output = terminal_ours_for_output;
  child_ops.to_terminal_ours = terminal_ours;
  child_ops.to_terminal_save_ours = terminal_save_ours;
  child_ops.to_terminal_info = child_terminal_info;
  child_ops.to_kill = child_kill_inferior;
  child_ops.to_create_inferior = child_create_inferior;
  child_ops.to_mourn_inferior = child_mourn_inferior;
  child_ops.to_can_run = child_can_run;
  child_ops.to_thread_alive = win32_child_thread_alive;
  child_ops.to_pid_to_str = cygwin_pid_to_str;
  child_ops.to_stop = child_stop;
  child_ops.to_stratum = process_stratum;
  child_ops.to_has_all_memory = 1;
  child_ops.to_has_memory = 1;
  child_ops.to_has_stack = 1;
  child_ops.to_has_registers = 1;
  child_ops.to_has_execution = 1;
  child_ops.to_magic = OPS_MAGIC;
  child_ops.to_pid_to_exec_file = child_pid_to_exec_file;
d2183 1
a2183 1
  add_target (&child_ops);
@


1.98
log
@2004-09-29  Andrew Cagney  <cagney@@gnu.org>

	* target.h (child_ops): Declare.
	* inftarg.c (child_ops): Move from here ...
	* target.c (child_ops): ... to here.
	* wince.c (child_ops): Delete extern declaration.
	* win32-nat.c (child_ops): Delete extern declaration.
	* linux-nat.c (child_ops): Delete extern declaration.
	* hpux-thread.c (child_ops): Delete extern declaration.
@
text
@a2067 2
struct target_ops child_ops;

@


1.97
log
@2004-07-26  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (deprecated_add_show_from_set): Deprecate.
	* xcoffsolib.c (_initialize_xcoffsolib): Update.
	* wince.c (_initialize_wince): Update.
	* win32-nat.c (_initialize_win32_nat): Update.
	* varobj.c (_initialize_varobj): Update.
	* valops.c (_initialize_valops): Update.
	* utils.c (initialize_utils, initialize_utils): Update.
	* tui/tui-win.c (_initialize_tui_win): Update.
	* top.c (init_main): Update.
	* symfile.c (_initialize_symfile): Update.
	* source.c (_initialize_source): Update.
	* somsolib.c (_initialize_som_solib): Update.
	* solib.c (_initialize_solib): Update.
	* solib-frv.c (_initialize_frv_solib): Update.
	* serial.c (_initialize_serial): Update.
	* ser-go32.c (_initialize_ser_dos, _initialize_ser_dos): Update.
	* remote.c (_initialize_remote, _initialize_remote): Update.
	* remote-vx.c (_initialize_vx): Update.
	* remote-utils.c (_initialize_sr_support): Update.
	* remote-sds.c (_initialize_remote_sds): Update.
	* remote-mips.c (_initialize_remote_mips): Update.
	* remote-e7000.c (_initialize_remote_e7000): Update.
	* proc-api.c (_initialize_proc_api): Update.
	* printcmd.c: Update.
	* parse.c (_initialize_parse): Update.
	* pa64solib.c (_initialize_pa64_solib): Update.
	* p-valprint.c (_initialize_pascal_valprint): Update.
	* monitor.c (_initialize_remote_monitors): Update.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* mcore-tdep.c (_initialize_mcore_tdep): Update.
	* maint.c (_initialize_maint_cmds): Update.
	* lin-lwp.c (_initialize_lin_lwp): Update.
	* language.c (_initialize_language): Update.
	* kod.c (_initialize_kod): Update.
	* infrun.c (set_schedlock_func, _initialize_infrun): Update.
	* i386-tdep.c (_initialize_i386_tdep): Update.
	* gdbtypes.c (build_gdbtypes, _initialize_gdbtypes): Update.
	* gdbarch.sh: Update.
	* gdbarch.c: Re-generate.
	* gdb-events.sh: Update.
	* gdb-events.c: Re-generate.
	* frame.c (_initialize_frame): Update.
	* exec.c: Update.
	* demangle.c (_initialize_demangler): Update.
	* dcache.c (_initialize_dcache): Update.
	* cris-tdep.c (_initialize_cris_tdep, cris_version_update): Update.
	* cp-valprint.c (_initialize_cp_valprint): Update.
	* corefile.c (_initialize_core): Update.
	* command.h: Update.
	* cli/cli-decode.h: Update.
	* cli/cli-cmds.c (init_cli_cmds): Update.
	* charset.c (_initialize_charset): Update.
	* breakpoint.c (_initialize_breakpoint): Update.
	* arm-tdep.c (_initialize_arm_tdep_initialize_arm_tdep): Update.
	* alpha-tdep.c (_initialize_alpha_tdep): Update.
	* aix-thread.c (_initialize_aix_thread): Update.
@
text
@a88 3
/* Forward declaration */
extern struct target_ops child_ops;

@


1.96
log
@2004-07-23  Andrew Cagney  <cagney@@gnu.org>

	Use regcache_raw_collect instead of regcache_collect.
	* regcache.h (regcache_collect): Delete declaration.
	* regcache.c (regcache_colect): Delete function.
	* win32-nat.c (do_child_store_inferior_registers): Update.
	* sol-thread.c (sol_thread_store_registers): Update.
	* shnbsd-tdep.c (shnbsd_fill_reg): Update.
	* rs6000-nat.c (store_register): Update.
	* remote.c (store_register_using_P, remote_store_registers): Update.
	* ppcnbsd-tdep.c (ppcnbsd_fill_reg): Update.
	* ppc-linux-nat.c (store_altivec_register, store_spe_register)
	(fill_vrregset, store_spe_registers, fill_gregset)
	(fill_gregset): Update.
	* nto-procfs.c (procfs_store_registers): Update.
	* mipsnbsd-tdep.c (mipsnbsd_fill_reg): Update.
	* mips-linux-tdep.c (fill_gregset, mips64_fill_gregset): Update.
	* m68klinux-nat.c (store_register, fill_gregset): Update.
	* m68k-tdep.c (fill_gregset): Update.
	* infptrace.c (store_register): Update.
	* i386-nto-tdep.c (i386nto_regset_fill): Update.
	* i386-linux-nat.c (store_register, fill_gregset): Update.
	* hppa-linux-nat.c (fill_gregset): Update.
	* go32-nat.c (store_register): Update.
	* armnbsd-nat.c (store_register, store_regs, store_fp_register)
	(store_fp_regs): Update.
	* arm-linux-nat.c (store_nwfpe_single, store_nwfpe_double)
	(store_nwfpe_extended, store_fpregister, store_fpregs)
	(store_register, store_regs, fill_gregset, fill_fpregset): Update.
	* alpha-tdep.c (alpha_fill_int_regs, alpha_fill_fp_regs): Update.
	* aix-thread.c (fill_gprs64, fill_fprs, fill_sprs64, fill_sprs32)
	(store_regs_user_thread, store_regs_kernel_thread): Update.
@
text
@d2128 48
a2175 41
  add_show_from_set (add_set_cmd ("shell", class_support, var_boolean,
				  (char *) &useshell,
		 "Set use of shell to start subprocess.",
				  &setlist),
		     &showlist);

  add_show_from_set (add_set_cmd ("new-console", class_support, var_boolean,
				  (char *) &new_console,
		 "Set creation of new console when creating child process.",
				  &setlist),
		     &showlist);

  add_show_from_set (add_set_cmd ("new-group", class_support, var_boolean,
				  (char *) &new_group,
		   "Set creation of new group when creating child process.",
				  &setlist),
		     &showlist);

  add_show_from_set (add_set_cmd ("debugexec", class_support, var_boolean,
				  (char *) &debug_exec,
		       "Set whether to display execution in child process.",
				  &setlist),
		     &showlist);

  add_show_from_set (add_set_cmd ("debugevents", class_support, var_boolean,
				  (char *) &debug_events,
		   "Set whether to display kernel events in child process.",
				  &setlist),
		     &showlist);

  add_show_from_set (add_set_cmd ("debugmemory", class_support, var_boolean,
				  (char *) &debug_memory,
		 "Set whether to display memory accesses in child process.",
				  &setlist),
		     &showlist);

  add_show_from_set (add_set_cmd ("debugexceptions", class_support, var_boolean,
				  (char *) &debug_exceptions,
	       "Set whether to display kernel exceptions in child process.",
				  &setlist),
		     &showlist);
@


1.95
log
@2004-07-21  Andrew Cagney  <cagney@@gnu.org>

	Use regcache_raw_supply instead of supply_register.
	* regcache.h (supply_register): Delete declaration.
	* regcache.c (supply_register): Delete function.
	* wince.c (do_child_fetch_inferior_registers): Update.
	* win32-nat.c (do_child_fetch_inferior_registers)
	(fetch_elf_core_registers): Update.
	* v850ice.c (v850ice_fetch_registers): Update.
	* thread-db.c (thread_db_store_registers): Update.
	* sol-thread.c (sol_thread_store_registers): Update.
	* shnbsd-tdep.c (shnbsd_supply_reg): Update.
	* rs6000-nat.c (fetch_register): Update.
	* rom68k-rom.c (rom68k_supply_one_register): Update.
	* remote.c (remote_wait, remote_async_wait): Update.
	* remote-st.c (get_hex_regs): Update.
	* remote-sim.c (gdbsim_fetch_register): Update.
	* remote-sds.c (sds_fetch_registers): Update.
	* remote-rdp.c (remote_rdp_fetch_register): Update.
	* remote-rdi.c (arm_rdi_fetch_registers): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-hms.c (init_hms_cmds): Update.
	* remote-est.c (init_est_cmds): Update.
	* remote-e7000.c (get_hex_regs, fetch_regs_from_dump)
	(e7000_fetch_registers, sub2_from_pc, e7000_wait): Update.
	* ppcnbsd-tdep.c (ppcnbsd_supply_reg, ppcnbsd_supply_fpreg): Update.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register)
	(fetch_register, supply_vrregset, supply_vrregset)
	(fetch_spe_registers): Update.
	* ppc-bdm.c (bdm_ppc_fetch_registers): Update.
	* monitor.c (monitor_supply_register): Update.
	* mipsv4-nat.c (supply_gregset, supply_fpregset): Update.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg)
	(mipsnbsd_supply_fpreg): Update.
	* mips-nat.c (fetch_inferior_registers)
	(fetch_core_registers): Update.
	* mips-linux-tdep.c (supply_32bit_reg, supply_gregset)
	(supply_fpregset, mips64_supply_gregset)
	(mips64_supply_fpregset): Update.
	* m68klinux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* m68k-tdep.c (supply_gregset, supply_fpregset): Update.
	* m32r-rom.c (init_m32r_cmds, init_mon2000_cmds): Update.
	* lynx-nat.c (fetch_inferior_registers, fetch_core_registers): Update.
	* irix5-nat.c (supply_gregset, supply_fpregset): Update.
	* infptrace.c (fetch_register): Update.
	* ia64-linux-nat.c (supply_gregset, supply_fpregset): Update.
	* ia64-aix-nat.c (supply_gregset, supply_fpregset): Update.
	* i386gnu-nat.c (fetch_fpregs, supply_gregset)
	(gnu_fetch_registers, gnu_store_registers): Update.
	* i386-nto-tdep.c (i386nto_supply_gregset): Update.
	* i386-linux-nat.c (fetch_register, supply_gregset)
	(dummy_sse_values): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* hppah-nat.c (fetch_register): Update.
	* hppa-linux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* go32-nat.c (fetch_register): Update.
	* dve3900-rom.c (fetch_bitmapped_register)
	(_initialize_r3900_rom): Update.
	* cris-tdep.c (supply_gregset): Update.
	* abug-rom.c (init_abug_cmds): Update.
	* core-aout.c (fetch_core_registers): Update.
	* armnbsd-nat.c (supply_gregset, supply_fparegset)
	(fetch_register, fetch_fp_register): Update.
	* arm-linux-nat.c (fetch_nwfpe_single, fetch_nwfpe_none)
	(fetch_nwfpe_extended, fetch_fpregister, fetch_fpregs)
	(fetch_register, fetch_regs, supply_gregset, supply_fpregset): Update.
	* alphanbsd-tdep.c (fetch_core_registers): Update.
	* alpha-tdep.c (alpha_supply_int_regs, alpha_supply_fp_regs): Update.
	* alpha-nat.c (fetch_osf_core_registers)
	(fetch_osf_core_registers, fetch_osf_core_registers): Update.
	* aix-thread.c (supply_gprs64, supply_reg32, supply_fprs)
	(supply_sprs64, supply_sprs32, fetch_regs_kernel_thread): Update.
@
text
@d395 2
a396 1
    regcache_collect (r, ((char *) &current_thread->context) + mappings[r]);
@


1.94
log
@2004-07-01  Michael Snyder  <msnyder@@redhat.com>

        * win32-nat.c (core_dll_symbols_add): Re-indent a small section
        that seems to have gotten whacked out of line.
@
text
@d361 1
a361 1
      supply_register (r, (char *) &l);
d366 1
a366 1
      supply_register (r, (char *) &l);
d369 1
a369 1
    supply_register (r, context_offset);
d2444 1
a2444 1
    supply_register (r, core_reg_sect + mappings[r]);
@


1.93
log
@	* win32-nat.c (child_pid_to_exec_file): New function.
	(init_child_ops): Add child_pid_to_exec_file as to_pid_to_exec_file
	functionality.
@
text
@d2270 2
a2271 2
    register_loaded_dll (dll_name, base_addr + 0x1000);
    solib_symbols_add (dll_name, 0, (CORE_ADDR) base_addr + 0x1000);
d2273 53
a2325 53
  out:
    return 1;
  }

  typedef struct
  {
    struct target_ops *target;
    bfd_vma addr;
  } map_code_section_args;

  static void
  map_single_dll_code_section (bfd * abfd, asection * sect, void *obj)
  {
    int old;
    int update_coreops;
    struct section_table *new_target_sect_ptr;

    map_code_section_args *args = (map_code_section_args *) obj;
    struct target_ops *target = args->target;
    if (sect->flags & SEC_CODE)
      {
	update_coreops = core_ops.to_sections == target->to_sections;

	if (target->to_sections)
	  {
	    old = target->to_sections_end - target->to_sections;
	    target->to_sections = (struct section_table *)
	      xrealloc ((char *) target->to_sections,
			(sizeof (struct section_table)) * (1 + old));
	  }
	else
	  {
	    old = 0;
	    target->to_sections = (struct section_table *)
	      xmalloc ((sizeof (struct section_table)));
	  }
	target->to_sections_end = target->to_sections + (1 + old);

	/* Update the to_sections field in the core_ops structure
	   if needed.  */
	if (update_coreops)
	  {
	    core_ops.to_sections = target->to_sections;
	    core_ops.to_sections_end = target->to_sections_end;
	  }
	new_target_sect_ptr = target->to_sections + old;
	new_target_sect_ptr->addr = args->addr + bfd_section_vma (abfd, sect);
	new_target_sect_ptr->endaddr = args->addr + bfd_section_vma (abfd, sect) +
	  bfd_section_size (abfd, sect);;
	new_target_sect_ptr->the_bfd_section = sect;
	new_target_sect_ptr->bfd = abfd;
      }
  }
d2327 2
a2328 2
  static int
  dll_code_sections_add (const char *dll_name, int base_addr, struct target_ops *target)
@


1.92
log
@2004-06-25  Andrew Cagney  <cagney@@gnu.org>

	* defs.h (deprecated_ui_loop_hook): Deprecated.
	* wince.c (child_wait): Update.
	* win32-nat.c (child_wait): Update.
	* v850ice.c (v850ice_wait): Update.
	* top.c (deprecated_ui_loop_hook): Update.
	* serial.h: Update.
	* ser-unix.c (do_hardwire_readchar, do_hardwire_readchar)
	(do_unix_readchar): Update.
	* ser-tcp.c (net_open): Update.
	* remote-sim.c (gdb_os_poll_quit): Update.
	* rdi-share/ardi.c (angel_RDI_ExecuteOrStep): Update.
@
text
@d1659 30
d2111 1
@


1.91
log
@2004-06-24  Andrew Cagney  <cagney@@gnu.org>

	* defs.h (post_add_symbol_hook, pre_add_symbol_hook)
	(ui_loop_hook, selected_frame_level_changed_hook): Declare.
	* wince.c (ui_loop_hook): Delete extern declaration.
	* win32-nat.c (ui_loop_hook): Delete extern declaration..
	* v850ice.c (ui_loop_hook): Delete extern declaration..
	* ser-unix.c (ui_loop_hook): Delete extern declaration..
	* ser-tcp.c (ui_loop_hook): Delete extern declaration..
	* remote-sim.c (ui_loop_hook): Delete extern declaration..
	* rdi-share/ardi.c (angel_RDI_ExecuteOrStep): Delete extern.
	ui_loop_hook declaration.
@
text
@d1420 2
a1421 2
	  if (ui_loop_hook != NULL)
	    detach = ui_loop_hook (0);
@


1.90
log
@	* dsrec.c (load_srec, make_srec): Use bfd_get_section_size instead of
	bfd_get_section_size_before_reloc or _raw_size.
	* dwarf2-frame.c (dwarf2_build_frame_info): Likewise.
	* dwarf2read.c (dwarf2_locate_sections): Likewise.
	(dwarf2_read_section): Likewise.
	* elfread.c (elf_locate_sections): Likewise.
	* gcore.c (derive_heap_segment): Likewise.
	* mipsread.c (read_alphacoff_dynamic_symtab): Likewise.
	* remote-e7000.c (e7000_load): Likewise.
	* remote-m32r-sdi.c (m32r_load): Likewise.
	* remote-mips.c (mips_load_srec): Likewise.
	(pmon_load_fast): Likewise.
	* remote.c (compare_sections_command): Likewise.
	* symfile.c (add_section_size_callback): Likewise.
	(load_section_callback): Likewise.
	(pc_in_unmapped_range): Likewise.
	(pc_in_mapped_range): Likewise.
	(sections_overlap): Likewise.
	(list_overlays_command): Likewise.
	(simple_overlay_update_1): Likewise.
	(simple_overlay_update): Likewise.
	* tracepoint.c (remote_set_transparent_ranges): Likewise.
	* win32-nat.c (core_section_load_dll_symbols): Likewise.
@
text
@a58 3
/* The ui's event loop. */
extern int (*ui_loop_hook) (int signo);

@


1.89
log
@2004-05-25  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Add from_tty to
	to_create_inferior.
	(target_create_inferior, find_default_create_inferior): Update.
	* infcmd.c (run_command): Update.
	* wince.c (child_create_inferior): Update.
	* win32-nat.c (child_create_inferior): Update.
	* uw-thread.c (uw_thread_create_inferior): Update.
	* thread-db.c (thread_db_create_inferior): Update.
	* target.c (debug_to_create_inferior)
	(find_default_create_inferior): Update.
	(maybe_kill_then_create_inferior): Update.
	* sol-thread.c (sol_thread_create_inferior): Update.
	* remote.c (extended_remote_async_create_inferior)
	(extended_remote_create_inferior): Update.
	* remote-vx.c (vx_create_inferior): Update.
	* remote-st.c (st2000_create_inferior): Update.
	* remote-sim.c (gdbsim_create_inferior): Update.
	* remote-sds.c (sds_create_inferior): Update.
	* remote-rdp.c (remote_rdp_create_inferior): Update.
	* remote-rdi.c (arm_rdi_create_inferior): Update.
	* remote-m32r-sdi.c (m32r_create_inferior): Update.
	* remote-e7000.c (e7000_create_inferior): Update.
	* procfs.c (procfs_create_inferior): Update.
	* ocd.c (ocd_create_inferior): Update.
	* ocd.h (ocd_create_inferior): Update.
	* nto-procfs.c (procfs_create_inferior): Update.
	* monitor.c (monitor_create_inferior): Update.
	* lin-lwp.c (lin_lwp_create_inferior): Update.
	* inftarg.c (child_create_inferior): Update.
	* hpux-thread.c (hpux_thread_create_inferior): Update.
	* gnu-nat.c (gnu_create_inferior): Update.
@
text
@d3 2
a4 2
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free
   Software Foundation, Inc.
d2343 1
a2343 1
  buf = (char *) xmalloc (sect->_raw_size + 1);
d2349 1
a2349 1
  if (!bfd_get_section_contents (abfd, sect, buf, 0, sect->_raw_size))
d2356 1
a2356 1
  if (offsetof (struct win32_pstatus, data.module_info.module_name) + dll_name_size > sect->_raw_size)
@


1.88
log
@2004-04-21  Andrew Cagney  <cagney@@redhat.com>

	* gdbcore.h: Update copyright.
	(deprecated_add_core_fns): Rename add_core_fns.
	* win32-nat.c (_initialize_core_win32): Update.
	* sun3-nat.c (_initialize_core_sun3): Update.
	* shnbsd-tdep.c (_initialize_shnbsd_tdep): Update.
	* rs6000-nat.c (_initialize_core_rs6000): Update.
	* ppcnbsd-tdep.c (_initialize_ppcnbsd_tdep): Update.
	* nto-tdep.c (_initialize_nto_tdep): Update.
	* ns32knbsd-nat.c (_initialize_ns32knbsd_nat): Update.
	* mipsnbsd-tdep.c (_initialize_mipsnbsd_tdep): Update.
	* mips-nat.c (_initialize_core_mips): Update.
	* mips-linux-tdep.c (_initialize_mips_linux_tdep): Update.
	* m68knbsd-nat.c (_initialize_m68knbsd_nat): Update.
	* m68klinux-nat.c (_initialize_m68k_linux_nat): Update.
	* lynx-nat.c (_initialize_core_lynx): Update.
	* irix5-nat.c (_initialize_core_irix5): Update.
	* i386-interix-nat.c (_initialize_core_interix): Update.
	* cris-tdep.c (_initialize_cris_tdep): Update.
	* corelow.c (deprecated_add_core_fns): Update.
	* core-regset.c (_initialize_core_regset): Update.
	* core-aout.c (_initialize_core_aout): Update.
	* armnbsd-nat.c (_initialize_arm_netbsd_nat): Update.
	* alphanbsd-tdep.c (_initialize_alphanbsd_tdep): Update.
	* alpha-nat.c (_initialize_core_alpha): Update.
@
text
@d1683 2
a1684 1
child_create_inferior (char *exec_file, char *allargs, char **env)
@


1.87
log
@2004-01-05  Andrew Cagney  <cagney@@redhat.com>

	* libunwind-frame.h (struct frame_id): Add opaque declaration,
	move to start of file.
	* i386-tdep.h (struct regcache): Add opaque declaration.
	* config/ia64/nm-linux.h (struct target_ops): Add opaque
	declaration.
	* ia64-tdep.c (ia64_find_proc_info_x): Do not use __FUNCTION__.
	(ia64_gdbarch_init): Use "GNU/Linux" in comment.
	* win32-nat.c (fake_create_process): Use ISO C style definition.
	* stabsread.c (define_symbol): Delete #ifndef
	DEPRECATED_USE_REGISTER_NOT_ARG wrapper around
	stabs_argument_has_addr call, macro never defined.
@
text
@d2430 1
a2430 1
  add_core_fns (&win32_elf_core_fns);
@


1.87.6.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d3 2
a4 2
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
d59 3
d364 1
a364 1
      regcache_raw_supply (current_regcache, r, (char *) &l);
d369 1
a369 1
      regcache_raw_supply (current_regcache, r, (char *) &l);
d372 1
a372 1
    regcache_raw_supply (current_regcache, r, context_offset);
d398 1
a398 2
    regcache_raw_collect (current_regcache, r,
			  ((char *) &current_thread->context) + mappings[r]);
d1423 2
a1424 2
	  if (deprecated_ui_loop_hook != NULL)
	    detach = deprecated_ui_loop_hook (0);
a1661 30
char *
child_pid_to_exec_file (int pid)
{
  /* Try to find the process path using the Cygwin internal process list
     pid isn't a valid pid, unfortunately.  Use current_event.dwProcessId
     instead.  */
  /* TODO: Also find native Windows processes using CW_GETPINFO_FULL.  */

  static char path[MAX_PATH + 1];
  char *path_ptr = NULL;
  int cpid;
  struct external_pinfo *pinfo;

  cygwin_internal (CW_LOCK_PINFO, 1000);
  for (cpid = 0;
       (pinfo = (struct external_pinfo *)
                       cygwin_internal (CW_GETPINFO, cpid | CW_NEXTPID));
       cpid = pinfo->pid)
    {
      if (pinfo->dwProcessId == current_event.dwProcessId) /* Got it */
       {
         cygwin_conv_to_full_posix_path (pinfo->progname, path);
         path_ptr = path; 
         break;
       }
    }
  cygwin_internal (CW_UNLOCK_PINFO);
  return path_ptr; 
}

d1683 1
a1683 2
child_create_inferior (char *exec_file, char *allargs, char **env,
		       int from_tty)
a2082 1
  child_ops.to_pid_to_exec_file = child_pid_to_exec_file;
d2098 41
a2138 48
  deprecated_add_show_from_set
    (add_set_cmd ("shell", class_support, var_boolean,
		  (char *) &useshell,
		  "Set use of shell to start subprocess.",
		  &setlist),
     &showlist);

  deprecated_add_show_from_set
    (add_set_cmd ("new-console", class_support, var_boolean,
		  (char *) &new_console,
		  "Set creation of new console when creating child process.",
		  &setlist),
     &showlist);

  deprecated_add_show_from_set
    (add_set_cmd ("new-group", class_support, var_boolean,
		  (char *) &new_group,
		  "Set creation of new group when creating child process.",
		  &setlist),
     &showlist);

  deprecated_add_show_from_set
    (add_set_cmd ("debugexec", class_support, var_boolean,
		  (char *) &debug_exec,
		  "Set whether to display execution in child process.",
		  &setlist),
     &showlist);

  deprecated_add_show_from_set
    (add_set_cmd ("debugevents", class_support, var_boolean,
		  (char *) &debug_events,
		  "Set whether to display kernel events in child process.",
		  &setlist),
     &showlist);

  deprecated_add_show_from_set
    (add_set_cmd ("debugmemory", class_support, var_boolean,
		  (char *) &debug_memory,
		  "Set whether to display memory accesses in child process.",
		  &setlist),
     &showlist);

  deprecated_add_show_from_set
    (add_set_cmd ("debugexceptions", class_support, var_boolean,
		  (char *) &debug_exceptions,
		  "Set whether to display kernel exceptions in child process.",
		  &setlist),
     &showlist);
d2241 2
a2242 2
  register_loaded_dll (dll_name, base_addr + 0x1000);
  solib_symbols_add (dll_name, 0, (CORE_ADDR) base_addr + 0x1000);
d2244 3
a2246 3
 out:
  return 1;
}
d2248 5
a2252 5
typedef struct
{
  struct target_ops *target;
  bfd_vma addr;
} map_code_section_args;
d2254 12
a2265 6
static void
map_single_dll_code_section (bfd * abfd, asection * sect, void *obj)
{
  int old;
  int update_coreops;
  struct section_table *new_target_sect_ptr;
d2267 14
a2280 5
  map_code_section_args *args = (map_code_section_args *) obj;
  struct target_ops *target = args->target;
  if (sect->flags & SEC_CODE)
    {
      update_coreops = core_ops.to_sections == target->to_sections;
d2282 15
a2296 14
      if (target->to_sections)
	{
	  old = target->to_sections_end - target->to_sections;
	  target->to_sections = (struct section_table *)
	    xrealloc ((char *) target->to_sections,
		      (sizeof (struct section_table)) * (1 + old));
	}
      else
	{
	  old = 0;
	  target->to_sections = (struct section_table *)
	    xmalloc ((sizeof (struct section_table)));
	}
      target->to_sections_end = target->to_sections + (1 + old);
d2298 2
a2299 18
      /* Update the to_sections field in the core_ops structure
	 if needed.  */
      if (update_coreops)
	{
	  core_ops.to_sections = target->to_sections;
	  core_ops.to_sections_end = target->to_sections_end;
	}
      new_target_sect_ptr = target->to_sections + old;
      new_target_sect_ptr->addr = args->addr + bfd_section_vma (abfd, sect);
      new_target_sect_ptr->endaddr = args->addr + bfd_section_vma (abfd, sect) +
	bfd_section_size (abfd, sect);;
      new_target_sect_ptr->the_bfd_section = sect;
      new_target_sect_ptr->bfd = abfd;
    }
}

static int
dll_code_sections_add (const char *dll_name, int base_addr, struct target_ops *target)
d2342 1
a2342 1
  buf = (char *) xmalloc (bfd_get_section_size (sect) + 1);
d2348 1
a2348 1
  if (!bfd_get_section_contents (abfd, sect, buf, 0, bfd_get_section_size (sect)))
d2355 1
a2355 1
  if (offsetof (struct win32_pstatus, data.module_info.module_name) + dll_name_size > bfd_get_section_size (sect))
d2415 1
a2415 1
    regcache_raw_supply (current_regcache, r, core_reg_sect + mappings[r]);
d2430 1
a2430 1
  deprecated_add_core_fns (&win32_elf_core_fns);
@


1.86
log
@* win32-nat.c: Add some comments about below change.
@
text
@d1218 1
a1218 1
fake_create_process ()
@


1.85
log
@Fix for PR threads/1048
* win32-nat.c (thread_info_struct): Add reload_context flag.
(thread_rec): Don't reload thread context here.  Just set a flag.
(do_child_fetch_inferior_registers): Reload thread context here if appropriate.
Avoid doing anything if current_thread is NULL thanks to strange Windows
behavior.
(child_fetch_inferior_registers): Avoid doing anything if current_thread is
NULL.
(do_child_store_inferior_registers): Ditto.
(child_store_inferior_registers): Ditto.
(child_kill_inferior): Ditto.
(fake_create_process): Pretend to create a process for pathological windows
attach situation.
(get_child_debug_event): Call fake_create_process when the first event noticed
is thread creation rather than process creation.
(child_attach): Always set attach_flag when attaching.
(child_create_inferior): Set attach_flag to zero since we're not attaching.
@
text
@d341 2
a342 1
    return;
d386 2
d396 1
a396 1
    /* nothing to do */;
d411 2
d1215 2
d1263 3
@


1.84
log
@* win32-nat.c (get_child_debug_event): Keep main thread id around even after
thread exits since Windows insists on continuing to report events against it.
@
text
@d111 1
a231 1

d249 1
a249 13

	    th->context.ContextFlags = CONTEXT_DEBUGGER_DR;
	    GetThreadContext (th->h, &th->context);
	    if (id == current_event.dwThreadId)
	      {
		/* Copy dr values from that thread.  */
		dr[0] = th->context.Dr0;
		dr[1] = th->context.Dr1;
		dr[2] = th->context.Dr2;
		dr[3] = th->context.Dr3;
		dr[6] = th->context.Dr6;
		dr[7] = th->context.Dr7;
	      }
d340 18
d385 2
a386 1
  do_child_fetch_inferior_registers (r);
d392 3
a394 1
  if (r >= 0)
d408 2
a409 1
  do_child_store_inferior_registers (r);
d1192 1
a1192 1
	      /* Only change the value of the debug reisters */
d1210 11
d1253 8
a1260 1
	break;
a1275 2
      if (saw_create != 1)
	break;
a1383 1
      current_thread = th ? : thread_rec (current_event.dwThreadId, TRUE);
d1385 1
d1600 3
a1602 4
    {
      attach_flag = 1;
      DebugSetProcessKillOnExit (FALSE);
    }
d1724 2
d1927 2
a1928 1
  (void) CloseHandle (current_thread->h);
a2178 1

@


1.83
log
@* i386-tdep.h (FCS_REGNUM, FCOFF_REGNUM, FDS_REGNUM,
FDOFF_REGNUM): Remove defines.
* win32-nat.c (do_child_fetch_inferior_registers): Include
"i387-tdep.h".
(do_child_fetch_inferior_registers): Use I387_FISEG_ST0_REGNUM and
I387_FOP_REGNUM instead of FCS_REGNUM and FOP_REGNUM.  Define and
undefine I387_ST0_REGNUM.
@
text
@d79 2
a80 2
static int debug_registers_changed = 0;
static int debug_registers_used = 0;
d1208 1
a1208 1
  thread_info *th = NULL;
d1222 1
d1250 5
a1254 2
      child_delete_thread (current_event.dwThreadId);
      th = &dummy_thread_info;
d1270 2
a1273 4
#if 0
      th = child_add_thread (current_event.dwProcessId,
			     current_event.u.CreateProcessInfo.hProcess);
#endif
d2204 2
a2205 2
  register_loaded_dll (dll_name, base_addr + 0x1000);
  solib_symbols_add (dll_name, 0, (CORE_ADDR) base_addr + 0x1000);
d2207 3
a2209 3
out:
  return 1;
}
d2211 5
a2215 5
typedef struct
{
  struct target_ops *target;
  bfd_vma addr;
} map_code_section_args;
d2217 12
a2228 6
static void
map_single_dll_code_section (bfd * abfd, asection * sect, void *obj)
{
  int old;
  int update_coreops;
  struct section_table *new_target_sect_ptr;
d2230 14
a2243 5
  map_code_section_args *args = (map_code_section_args *) obj;
  struct target_ops *target = args->target;
  if (sect->flags & SEC_CODE)
    {
      update_coreops = core_ops.to_sections == target->to_sections;
d2245 15
a2259 14
      if (target->to_sections)
	{
	  old = target->to_sections_end - target->to_sections;
	  target->to_sections = (struct section_table *)
	    xrealloc ((char *) target->to_sections,
		      (sizeof (struct section_table)) * (1 + old));
	}
      else
	{
	  old = 0;
	  target->to_sections = (struct section_table *)
	    xmalloc ((sizeof (struct section_table)));
	}
      target->to_sections_end = target->to_sections + (1 + old);
d2261 2
a2262 18
      /* Update the to_sections field in the core_ops structure
	 if needed.  */
      if (update_coreops)
	{
	  core_ops.to_sections = target->to_sections;
	  core_ops.to_sections_end = target->to_sections_end;
	}
      new_target_sect_ptr = target->to_sections + old;
      new_target_sect_ptr->addr = args->addr + bfd_section_vma (abfd, sect);
      new_target_sect_ptr->endaddr = args->addr + bfd_section_vma (abfd, sect) +
	bfd_section_size (abfd, sect);;
      new_target_sect_ptr->the_bfd_section = sect;
      new_target_sect_ptr->bfd = abfd;
    }
}

static int
dll_code_sections_add (const char *dll_name, int base_addr, struct target_ops *target)
@


1.82
log
@2003-10-22  Andrew Cagney  <cagney@@redhat.com>

	* exec.h: New file.
	* win32-nat.c: Include "exec.h".
	* solib.c: Include "exec.h".
	* target.h (build_section_table): Delete declaration.
	* somsolib.c: Include "exec.h".
	(exec_ops): Delete extern declaration.
	* rs6000-nat.c: Update copyright.  Include "exec.h".
	(exec_ops): Delete extern declaration.
	* pa64solib.c: Update copyright.  Include "exec.h".
	(exec_ops): Delete extern declaration.
	* exec.c: Update copyright.  Include "exec.h".
	* corelow.c: Update dependencies.  Include "exec.h".
	* Makefile.in (exec_h): Define.
	(exec.o, somsolib.o): Update dependencies.
	(pa64solib.o, corelow.o): Update dependencies.
@
text
@a37 1
#include "i386-tdep.h"
d56 3
d351 4
a354 1
  if (r == FCS_REGNUM)
d359 1
a359 1
  else if (r == FOP_REGNUM)
d371 2
@


1.81
log
@2003-09-20  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.c: Eliminate ARGSUSED.
	* buildsym.c, cli/cli-cmds.c, cli/cli-script.c: Ditto.
	* coffread.c, corelow.c, dwarf2read.c, event-top.c: Ditto.
	* exec.c, gcore.c, hpux-thread.c, infcmd.c, inflow.c: Ditto.
	* infrun.c, inftarg.c, maint.c, ocd.c, printcmd.c: Ditto.
	* procfs.c, regcache.c, remote-rdi.c, remote-sds.c: Ditto.
	* remote.c, sol-thread.c, source.c, stabsread.c: Ditto.
	* stack.c, symfile.c, target.c, top.c, typeprint.c: Ditto.
	* utils.c, v850ice.c, valprint.c, values.c, win32-nat.c: Ditto.
	* wince.c, remote-vx.c: Ditto.
@
text
@d55 1
@


1.80
log
@* win32-nat.c (mappings): Remove HAVE_SSE conditional.
@
text
@a1625 1
/* ARGSUSED */
@


1.79
log
@* win32-nat.c: Just rely on CONTEXT_EXTENDED_REGISTER being defined for SSE
registers since gdb will not operate correctly without this.  Restore include
file ordering munged in previous change.
* config/i386/tm-cygwin.h: Remove HAVE_SSE_REGS define.
@
text
@a184 1
#ifdef HAVE_SSE_REGS
a195 1
#endif
@


1.78
log
@* win32-nat.c: Reorganize so that defines used by target headers are actually
defined by the system headers.
* config/i386/tm-cygwin.h: Check for CONTEXT_EXTENDED_REGISTERS rather than
HAVE_CONTEXT_EXTENDED_REGISTERS, since the latter actually exists.
@
text
@a28 7
#include <windows.h>
#include <signal.h>
#include <sys/types.h>
#include <fcntl.h>
#include <stdlib.h>
#include <imagehlp.h>
#include <sys/cygwin.h>
a29 1
#include "tm.h"			/* required for SSE registers */
d39 7
a71 1
#ifdef HAVE_SSE_REGS
a73 3
#else
#define CONTEXT_DEBUGGER_DR CONTEXT_DEBUGGER | CONTEXT_DEBUG_REGISTERS
#endif
@


1.77
log
@* win32-nat.c (solib_symbols_add): Use one variable for all section address
stuff.  Pass variable rather than address of variable to safe_symbol_file_add.
@
text
@d29 7
a46 7
#include <signal.h>
#include <sys/types.h>
#include <fcntl.h>
#include <stdlib.h>
#include <windows.h>
#include <imagehlp.h>
#include <sys/cygwin.h>
@


1.76
log
@        * win32-nat.c (solib_symbols_add): Fix a small compilation error.
@
text
@d640 1
a640 1
  if (!ReadProcessMemory (h, address,  &address_ptr, sizeof (address_ptr), &done) 
d805 1
a805 1
  struct section_addr_info *section_addrs_ptr = NULL;
d828 1
a828 1
	  section_addrs_ptr = get_relocated_section_addrs (abfd, load_addr);
d834 1
a834 1
  if (section_addrs_ptr)
d836 2
a837 4
      result = safe_symbol_file_add (name, from_tty, section_addrs_ptr,
				     0, OBJF_SHARED);

      free_section_addr_info (section_addrs_ptr);
a838 1

a841 1
      struct section_addr_info *section_addrs;
d844 4
a847 4
      section_addrs = alloc_section_addr_info (1);
      my_cleanups = make_cleanup (xfree, section_addrs);
      section_addrs->other[0].name = ".text";
      section_addrs->other[0].addr = load_addr;
d849 1
a849 2
      result = safe_symbol_file_add (name, from_tty, &section_addrs,
				     0, OBJF_SHARED);
d2213 1
a2213 2
}
map_code_section_args;
@


1.76.4.1
log
@* win32-nat.c (solib_symbols_add): Use one variable for all section address
stuff.  Pass variable rather than address of variable to safe_symbol_file_add.
@
text
@d805 1
a805 1
  struct section_addr_info *addrs = NULL;
d828 1
a828 1
	  addrs = get_relocated_section_addrs (abfd, load_addr);
d834 1
a834 1
  if (addrs)
d836 4
a839 2
      result = safe_symbol_file_add (name, from_tty, addrs, 0, OBJF_SHARED);
      free_section_addr_info (addrs);
d841 1
d845 1
d848 4
a851 4
      addrs = alloc_section_addr_info (1);
      my_cleanups = make_cleanup (xfree, addrs);
      addrs->other[0].name = ".text";
      addrs->other[0].addr = load_addr;
d853 2
a854 1
      result = safe_symbol_file_add (name, from_tty, addrs, 0, OBJF_SHARED);
d2218 2
a2219 1
} map_code_section_args;
@


1.76.4.2
log
@* win32-nat.c: Reorganize so that defines used by target headers are actually
defined by the system headers.
* config/i386/tm-cygwin.h: Check for CONTEXT_EXTENDED_REGISTERS rather than
HAVE_CONTEXT_EXTENDED_REGISTERS, since the latter actually exists.
@
text
@a28 7
#include <windows.h>
#include <signal.h>
#include <sys/types.h>
#include <fcntl.h>
#include <stdlib.h>
#include <imagehlp.h>
#include <sys/cygwin.h>
d40 7
@


1.76.4.3
log
@* win32-nat.c: Just rely on CONTEXT_EXTENDED_REGISTER being defined for SSE
registers since gdb will not operate correctly without this.  Restore include
file ordering munged in previous change.
* config/i386/tm-cygwin.h: Remove HAVE_SSE_REGS define.
@
text
@d29 7
d37 1
a46 7
#include <signal.h>
#include <sys/types.h>
#include <fcntl.h>
#include <stdlib.h>
#include <windows.h>
#include <imagehlp.h>
#include <sys/cygwin.h>
d73 1
d76 3
@


1.76.4.4
log
@* win32-nat.c (mappings): Remove HAVE_SSE conditional.
@
text
@d185 1
d197 1
@


1.75
log
@	* elfread.c (elf_symtab_read): Avoid use of SECT_OFF_MAX.
	(elfstab_offset_sections): Likewise.
	* gdb-stabs.h (stab_section_info): Likewise.
	* i386-interix-tdep.c (pei_adjust_objfile_offsets): Likewise.
	* objfiles.c (objfile_relocate): Likewise.
	* pa64solib.c (pa64_solib_add_solib_objfile): Likewise.
	* remote.c (get_offsets): Likewise.
	(remote_cisco_objfile_relocate): Likewise.
	* somread.c (som_symfile_offsets): Likewise.
	* symfile.c (alloc_section_addr_info): New function.
	(build_section_addr_info_from_section_tab): Use it.
	(free_section_addr_info): Adjust.
	(default_symfile_offsets): Avoid use of SECT_OFF_MAX.
	(syms_from_objfile): Allocate local_addr dynamically.
	(symbol_file_add_with_addrs_or_offsets): Allocate orig_addrs
	dynamically.
	(add_symbol_file_command): Allocate sect_opts dynamically.
	(reread_symbols): Avoid use of SECT_OFF_MAX.
	* symfile.h (section_addr_info): Do not use MAX_SECTIONS.
	(alloc_section_addr_info): Declare it.
	* symtab.h (SIZEOF_SECTION_OFFSETS): Remove.
	* win32-nat.c (solib_symbols_add): Allocate section_addrs
	dynamically.
	* xcoffread.c (xcoff_symfile_offsets): Avoid use of SECT_OFF_MAX.
@
text
@d850 2
a851 2
      section_addrs.other[0].name = ".text";
      section_addrs.other[0].addr = load_addr;
@


1.74
log
@* win32-nat.c (get_image_name): Check return value from ReadProcessMemory.
(child_xfer_memory): Ditto.
@
text
@d845 2
a846 1
      struct section_addr_info section_addrs;
d848 2
a849 1
      memset (&section_addrs, 0, sizeof (section_addrs));
d855 1
@


1.73
log
@white space
@
text
@a637 2
  ReadProcessMemory (h, address,  &address_ptr, sizeof (address_ptr), &done);

d640 2
a641 2

  if (done != sizeof (address_ptr) || !address_ptr)
d645 3
a647 6
  do
    {
      ReadProcessMemory (h, address_ptr + len * size, &b, size, &done);
      len++;
    }
  while ((b[0] != 0 || b[size - 1] != 0) && done == size);
d1861 1
a1861 1
  DWORD done;
d1866 3
a1868 2
      WriteProcessMemory (current_process_handle, (LPVOID) memaddr, our,
			  len, &done);
d1875 3
a1877 2
      ReadProcessMemory (current_process_handle, (LPCVOID) memaddr, our, len,
			 &done);
@


1.72
log
@* win32-nat.cc (register_loaded_dll): Correctly set address range for
just-loaded dll.
@
text
@d952 1
a952 1
       limit = (limit << 12) | 0xfff;
d1574 1
a1574 1
    error ("Can't attach to process.");
d1967 10
a1976 10
     if (debug_registers_changed)
       {
	  th->context.Dr0 = dr[0];
	  th->context.Dr1 = dr[1];
	  th->context.Dr2 = dr[2];
	  th->context.Dr3 = dr[3];
	  /* th->context.Dr6 = dr[6];
	   FIXME: should we set dr6 also ?? */
	  th->context.Dr7 = dr[7];
       }
@


1.71
log
@whitespace cleanup
@
text
@d605 2
a606 2
  if (!VirtualQueryEx (current_process_handle, (void *) load_addr, &m,
		       sizeof (m)))
@


1.70
log
@* win32-nat.c (get_relocated_section_addrs): New function.  Find section load
addresses for symbol handling in relocated DLLs.
(solib_symbols_add): Open a bfd and call get_relocated_section_addrs.
@
text
@d752 1
a752 1

d805 1
a805 1

d1504 1
a1504 1
        {
d1509 1
a1509 1
  
d1523 1
a1523 1
                              sizeof orig_priv, &orig_priv, &size))
@


1.69
log
@* win32-nat.c (cygwin_pid): Removed as unused.
(child_attach): Try fall back to Cygwin pid.
@
text
@d752 5
d758 48
d810 3
a812 1
  struct section_addr_info section_addrs;
d821 40
a860 4
  memset (&section_addrs, 0, sizeof (section_addrs));
  section_addrs.other[0].name = ".text";
  section_addrs.other[0].addr = load_addr;
  return safe_symbol_file_add (name, from_tty, &section_addrs, 0, OBJF_SHARED);
@


1.68
log
@2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* ax-gdb.c, c-valprint.c, charset.c, corefile.c: Update copyright.
	* demangle.c, disasm.c, dwarf2cfi.c, dwarfread.c: Update copyright.
	* elfread.c, eval.c, expprint.c, expression.h: Update copyright.
	* f-typeprint.c, findvar.c, gcore.c, gdb_mbuild.sh: Update copyright.
	* gdbtypes.h, gnu-v2-abi.c, inferior.h, inftarg.c: Update copyright.
	* language.c, language.h, m32r-tdep.c: Update copyright.
	* mn10200-tdep.c, scm-lang.c, scm-lang.h: Update copyright.
	* somsolib.c, somsolib.h, symfile.c, symtab.h: Update copyright.
	* thread-db.c, typeprint.c, utils.c, valarith.c: Update copyright.
	* values.c, win32-nat.c, x86-64-linux-nat.c: Update copyright.
	* x86-64-linux-tdep.c, z8k-tdep.c: Update copyright.
	* cli/cli-decode.h, config/h8500/tm-h8500.h: Update copyright.

Index: mi/ChangeLog
2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* mi-cmd-env.c: Update copyright.
@
text
@a126 1
static pid_t cygwin_pid;		/* pid of cygwin process */
d385 1
a385 1
    deprecated_read_register_gen (r, ((char *) &current_thread->context) + mappings[r]);
d852 4
a855 4
        {
          puts_filtered ("Segment not present\n");
          return 0;
        }
d864 1
a864 1
        puts_filtered(" 32-bit ");
d866 1
a866 1
        puts_filtered(" 16-bit ");
d870 2
a871 2
          puts_filtered ("Data (Read-Only, Exp-up");
          break;
d873 2
a874 2
          puts_filtered ("Data (Read/Write, Exp-up");
          break;
d876 2
a877 2
          puts_filtered ("Unused segment (");
          break;
d879 2
a880 2
          puts_filtered ("Data (Read/Write, Exp-down");
          break;
d882 2
a883 2
          puts_filtered ("Code (Exec-Only, N.Conf");
          break;
d885 1
a885 1
          puts_filtered ("Code (Exec/Read, N.Conf");
d888 1
a888 1
          puts_filtered ("Code (Exec-Only, Conf");
d891 1
a891 1
          puts_filtered ("Code (Exec/Read, Conf");
d897 1
a897 1
        puts_filtered(", N.Acc");
d903 1
a903 1
        puts_filtered ("Page granular.\n");
d928 1
a928 1
        current_thread->context.SegCs);
d931 1
a931 1
        current_thread->context.SegDs);
d934 1
a934 1
        current_thread->context.SegEs);
d937 1
a937 1
        current_thread->context.SegSs);
d943 1
a943 1
        current_thread->context.SegGs);
d1469 2
a1470 1
  pid = strtoul (args, 0, 0);
d1475 8
d1484 1
d2018 2
a2019 2
                  "Print information specific to Win32 debugging.",
                  &info_w32_cmdlist, "info w32 ", 0, &infolist);
d2022 1
a2022 1
           "Display selectors infos.",
@


1.67
log
@	* win32-nat.c (set_process_privilege): New function.
	(child_attach): Call set_process_privilege() to enable the
	SE_DEBUG_NAME user privilege if available in process token.
@
text
@d3 1
a3 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002 Free
@


1.66
log
@* win32-nat.c (child_attach): Reset saw_create counter or subsequent attach
will hang.
@
text
@d1377 77
d1463 6
@


1.65
log
@* win32-nat.c (psapi_get_dll_name): Fix a compiler warning.
(struct so_stuff): Add end_addr field.
(register_loaded_dll): Calculate and store end address of loaded dll.
(solib_address): New function.
(child_solib_loaded_library_pathname): Pass carefully constructed section info
to safe_symbol_file_add rather than ignoring it.
(get_child_debug_event): Call re_enable_breakpoints_in_shlibs when a DLL is
loaded.
(do_initial_child_stuff): Call disable_breakpoints_in_shlibs.
(child_create_inferior): Fix a compiler warning.
* config/i386/tm-cygwin.h (PC_SOLIB): Define new macro.
(solib_address): Declare new function.
@
text
@d1389 1
@


1.64
log
@	* gnu-nat.c (init_gnu_ops): Remove NULL initializations.
	* monitor.c (init_base_monitor_ops): Likewise.
	* ppc-bdm.c (init_bdm_ppc_ops): Likewise.
	* remote-array.c (init_array_ops): Likewise.
	* remote-e7000.c (init_e7000_ops): Likewise.
	* remote-es.c (init_es1800_ops): Likewise.
	(init_es1800_child_ops): Likewise.
	* remote-rdp.c (init_remote_rdp_ops): Likewise.
	* remote-sim.c (init_gdbsim_ops): Likewise.
	* remote-st.c (init_st2000_ops): Likewise.
	* sol-thread.c (init_sol_core_ops): Likewise.
	(init_sol_thread_ops): Likewise.
	* v850ice.c (init_850ice_ops): Likewise.
	* win32-nat.c (init_child_ops): Likewise.
	* wince.c (init_child_ops): Likewise.
@
text
@d476 1
a476 1
	error ("Error getting dll name: %u\n", GetLastError ());
d505 1
d582 1
d606 6
d719 10
d770 1
a770 1
  return safe_symbol_file_add (name, from_tty, NULL, 0, OBJF_SHARED);
d1219 1
d1327 1
d1641 1
a1641 1
    error ("Error creating process %s, (error %d)\n", exec_file, GetLastError ());
@


1.63
log
@2002-11-02  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (deprecated_read_register_gen): Rename
	read_register_gen.
	(deprecated_write_register_gen): Rename write_register_gen.
	* i387-tdep.c: Update.
	* x86-64-linux-nat.c: Update
	* wince.c: Update.
	* thread-db.c: Update.
	* win32-nat.c: Update.
	* mips-tdep.c: Update.
	* d10v-tdep.c: Update.
	* cris-tdep.c: Update.
	* remote-sim.c: Update.
	* remote-rdi.c: Update.
	* remote-rdp.c: Update.
	* frame.c: Update.
	* target.c: Update.
	* blockframe.c: Update.
	* x86-64-tdep.c: Update.
	* xstormy16-tdep.c: Update.
	* sh-tdep.c: Update.
	* s390-tdep.c: Update.
	* rs6000-tdep.c: Update.
	* sparc-tdep.c: Update.
	* i386-tdep.c: Update.
	* dwarf2cfi.c: Update.
	* regcache.c: Update.
@
text
@a1830 2
  child_ops.to_load = 0;
  child_ops.to_lookup_symbol = 0;
a1833 1
  child_ops.to_notice_signals = 0;
a1837 1
  child_ops.DONT_USE = 0;
a1842 2
  child_ops.to_sections = 0;
  child_ops.to_sections_end = 0;
@


1.62
log
@* win32-nat.c (child_create_inferior): Honor 'tty' command.
@
text
@d386 1
a386 1
    read_register_gen (r, ((char *) &current_thread->context) + mappings[r]);
@


1.62.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free
d30 1
d39 1
a55 4
#include "exec.h"

#include "i386-tdep.h"
#include "i387-tdep.h"
d73 1
d76 3
d127 1
d191 1
d203 1
d356 1
a356 4

#define I387_ST0_REGNUM I386_ST0_REGNUM

  if (r == I387_FISEG_REGNUM)
d361 1
a361 1
  else if (r == I387_FOP_REGNUM)
a372 2

#undef I387_ST0_REGNUM
d386 1
a386 1
    regcache_collect (r, ((char *) &current_thread->context) + mappings[r]);
d476 1
a476 1
	error ("Error getting dll name: %u\n", (unsigned) GetLastError ());
a504 1
  DWORD end_addr;
a580 1
  MEMORY_BASIC_INFORMATION m;
a603 6
  if (VirtualQueryEx (current_process_handle, (void *) load_addr, &m,
		      sizeof (m)))
    so->end_addr = (DWORD) m.AllocationBase + m.RegionSize;
  else
    so->end_addr = load_addr + 0x2000;	/* completely arbitrary */

d631 2
d635 2
a636 2
  if (!ReadProcessMemory (h, address,  &address_ptr, sizeof (address_ptr), &done)
      || done != sizeof (address_ptr) || !address_ptr)
d640 6
a645 3
  while (ReadProcessMemory (h, address_ptr + len++ * size, &b, size, &done)
	 && (b[0] != 0 || b[size - 1] != 0) && done == size)
    continue;
a710 10
char *
solib_address (CORE_ADDR address)
{
  struct so_stuff *so;
  for (so = &solib_start; so->next != NULL; so = so->next)
    if (address >= so->load_addr && address <= so->end_addr)
      return so->name;
  return NULL;
}

a735 53
/* Get the loaded address of all sections, given that .text was loaded
   at text_load. Assumes that all sections are subject to the same
   relocation offset. Returns NULL if problems occur or if the
   sections were not relocated. */

static struct section_addr_info *
get_relocated_section_addrs (bfd *abfd, CORE_ADDR text_load)
{
  struct section_addr_info *result = NULL;
  int section_count = bfd_count_sections (abfd);
  asection *text_section = bfd_get_section_by_name (abfd, ".text");
  CORE_ADDR text_vma;

  if (!text_section)
    {
      /* Couldn't get the .text section. Weird. */
    }

  else if (text_load == (text_vma = bfd_get_section_vma (abfd, text_section)))
    {
      /* DLL wasn't relocated. */
    }

  else
    {
      /* Figure out all sections' loaded addresses. The offset here is
	 such that taking a bfd_get_section_vma() result and adding
	 offset will give the real load address of the section. */

      CORE_ADDR offset = text_load - text_vma;

      struct section_table *table_start = NULL;
      struct section_table *table_end = NULL;
      struct section_table *iter = NULL;

      build_section_table (abfd, &table_start, &table_end);

      for (iter = table_start; iter < table_end; ++iter)
	{
	  /* Relocated addresses. */
	  iter->addr += offset;
	  iter->endaddr += offset;
	}

      result = build_section_addr_info_from_section_table (table_start,
							   table_end);

      xfree (table_start);
    }

  return result;
}

d740 1
a740 3
  struct section_addr_info *addrs = NULL;
  static struct objfile *result = NULL;
  bfd *abfd = NULL;
d749 4
a752 38
  abfd = bfd_openr (name, "pei-i386");

  if (!abfd)
    {
      /* pei failed - try pe */
      abfd = bfd_openr (name, "pe-i386");
    }

  if (abfd)
    {
      if (bfd_check_format (abfd, bfd_object))
	{
	  addrs = get_relocated_section_addrs (abfd, load_addr);
	}

      bfd_close (abfd);
    }

  if (addrs)
    {
      result = safe_symbol_file_add (name, from_tty, addrs, 0, OBJF_SHARED);
      free_section_addr_info (addrs);
    }
  else
    {
      /* Fallback on handling just the .text section. */
      struct cleanup *my_cleanups;

      addrs = alloc_section_addr_info (1);
      my_cleanups = make_cleanup (xfree, addrs);
      addrs->other[0].name = ".text";
      addrs->other[0].addr = load_addr;

      result = safe_symbol_file_add (name, from_tty, addrs, 0, OBJF_SHARED);
      do_cleanups (my_cleanups);
    }

  return result;
d835 4
a838 4
	{
	  puts_filtered ("Segment not present\n");
	  return 0;
	}
d844 1
a844 1
	limit = (limit << 12) | 0xfff;
d847 1
a847 1
	puts_filtered(" 32-bit ");
d849 1
a849 1
	puts_filtered(" 16-bit ");
d853 2
a854 2
	  puts_filtered ("Data (Read-Only, Exp-up");
	  break;
d856 2
a857 2
	  puts_filtered ("Data (Read/Write, Exp-up");
	  break;
d859 2
a860 2
	  puts_filtered ("Unused segment (");
	  break;
d862 2
a863 2
	  puts_filtered ("Data (Read/Write, Exp-down");
	  break;
d865 2
a866 2
	  puts_filtered ("Code (Exec-Only, N.Conf");
	  break;
d868 1
a868 1
	  puts_filtered ("Code (Exec/Read, N.Conf");
d871 1
a871 1
	  puts_filtered ("Code (Exec-Only, Conf");
d874 1
a874 1
	  puts_filtered ("Code (Exec/Read, Conf");
d880 1
a880 1
	puts_filtered(", N.Acc");
d886 1
a886 1
	puts_filtered ("Page granular.\n");
d911 1
a911 1
	current_thread->context.SegCs);
d914 1
a914 1
	current_thread->context.SegDs);
d917 1
a917 1
	current_thread->context.SegEs);
d920 1
a920 1
	current_thread->context.SegSs);
d926 1
a926 1
	current_thread->context.SegGs);
a1200 1
      re_enable_breakpoints_in_shlibs ();
a1307 1
  disable_breakpoints_in_shlibs (1);
a1356 77
/* Try to set or remove a user privilege to the current process.  Return -1
   if that fails, the previous setting of that privilege otherwise.

   This code is copied from the Cygwin source code and rearranged to allow
   dynamically loading of the needed symbols from advapi32 which is only
   available on NT/2K/XP. */
static int
set_process_privilege (const char *privilege, BOOL enable)
{
  static HMODULE advapi32 = NULL;
  static BOOL WINAPI (*OpenProcessToken)(HANDLE, DWORD, PHANDLE);
  static BOOL WINAPI (*LookupPrivilegeValue)(LPCSTR, LPCSTR, PLUID);
  static BOOL WINAPI (*AdjustTokenPrivileges)(HANDLE, BOOL, PTOKEN_PRIVILEGES,
					      DWORD, PTOKEN_PRIVILEGES, PDWORD);

  HANDLE token_hdl = NULL;
  LUID restore_priv;
  TOKEN_PRIVILEGES new_priv, orig_priv;
  int ret = -1;
  DWORD size;

  if (GetVersion () >= 0x80000000)  /* No security availbale on 9x/Me */
    return 0;

  if (!advapi32)
    {
      if (!(advapi32 = LoadLibrary ("advapi32.dll")))
	goto out;
      if (!OpenProcessToken)
	OpenProcessToken = GetProcAddress (advapi32, "OpenProcessToken");
      if (!LookupPrivilegeValue)
	LookupPrivilegeValue = GetProcAddress (advapi32,
					       "LookupPrivilegeValueA");
      if (!AdjustTokenPrivileges)
	AdjustTokenPrivileges = GetProcAddress (advapi32,
						"AdjustTokenPrivileges");
      if (!OpenProcessToken || !LookupPrivilegeValue || !AdjustTokenPrivileges)
	{
	  advapi32 = NULL;
	  goto out;
	}
    }

  if (!OpenProcessToken (GetCurrentProcess (),
			 TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
			 &token_hdl))
    goto out;

  if (!LookupPrivilegeValue (NULL, privilege, &restore_priv))
    goto out;

  new_priv.PrivilegeCount = 1;
  new_priv.Privileges[0].Luid = restore_priv;
  new_priv.Privileges[0].Attributes = enable ? SE_PRIVILEGE_ENABLED : 0;

  if (!AdjustTokenPrivileges (token_hdl, FALSE, &new_priv,
			      sizeof orig_priv, &orig_priv, &size))
    goto out;
#if 0
  /* Disabled, otherwise every `attach' in an unprivileged user session
     would raise the "Failed to get SE_DEBUG_NAME privilege" warning in
     child_attach(). */
  /* AdjustTokenPrivileges returns TRUE even if the privilege could not
     be enabled. GetLastError () returns an correct error code, though. */
  if (enable && GetLastError () == ERROR_NOT_ALL_ASSIGNED)
    goto out;
#endif

  ret = orig_priv.Privileges[0].Attributes == SE_PRIVILEGE_ENABLED ? 1 : 0;

out:
  if (token_hdl)
    CloseHandle (token_hdl);

  return ret;
}

d1367 1
a1367 8
  if (set_process_privilege (SE_DEBUG_NAME, TRUE) < 0)
    {
      printf_unfiltered ("Warning: Failed to get SE_DEBUG_NAME privilege\n");
      printf_unfiltered ("This can cause attach to fail on Windows NT/2K/XP\n");
    }

  pid = strtoul (args, 0, 0);		/* Windows pid */

a1368 1
  saw_create = 0;
d1371 1
a1371 10
    {
      /* Try fall back to Cygwin pid */
      pid = cygwin_internal (CW_CYGWIN_PID_TO_WINPID, pid);

      if (pid > 0)
	ok = DebugActiveProcess (pid);

      if (!ok)
	error ("Can't attach to process.");
    }
d1436 1
d1621 1
a1621 1
    error ("Error creating process %s, (error %d)\n", exec_file, (unsigned) GetLastError ());
d1662 1
a1662 1
  DWORD done = 0;
d1667 2
a1668 3
      if (!WriteProcessMemory (current_process_handle, (LPVOID) memaddr, our,
			       len, &done))
	done = 0;
d1675 2
a1676 3
      if (!ReadProcessMemory (current_process_handle, (LPCVOID) memaddr, our,
			      len, &done))
	done = 0;
d1763 10
a1772 10
	  if (debug_registers_changed)
	    {
	      th->context.Dr0 = dr[0];
	      th->context.Dr1 = dr[1];
	      th->context.Dr2 = dr[2];
	      th->context.Dr3 = dr[3];
	      /* th->context.Dr6 = dr[6];
	       FIXME: should we set dr6 also ?? */
	      th->context.Dr7 = dr[7];
	    }
d1831 2
d1836 1
d1841 1
d1847 2
d1911 2
a1912 2
		  "Print information specific to Win32 debugging.",
		  &info_w32_cmdlist, "info w32 ", 0, &infolist);
d1915 1
a1915 1
	   "Display selectors infos.",
d2020 2
a2021 1
} map_code_section_args;
@


1.62.4.2
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d79 2
a80 2
static int debug_registers_changed;
static int debug_registers_used;
a110 1
    int reload_context;
d231 1
d249 13
a261 1
	    th->reload_context = 1;
a351 19
  if (!current_thread)
    return;	/* Windows sometimes uses a non-existent thread id in its
		   events */

  if (current_thread->reload_context)
    {
      thread_info *th = current_thread;
      th->context.ContextFlags = CONTEXT_DEBUGGER_DR;
      GetThreadContext (th->h, &th->context);
      /* Copy dr values from that thread.  */
      dr[0] = th->context.Dr0;
      dr[1] = th->context.Dr1;
      dr[2] = th->context.Dr2;
      dr[3] = th->context.Dr3;
      dr[6] = th->context.Dr6;
      dr[7] = th->context.Dr7;
      current_thread->reload_context = 0;
    }

d379 1
a379 4
  /* Check if current_thread exists.  Windows sometimes uses a non-existent
     thread id in its events */
  if (current_thread)
    do_child_fetch_inferior_registers (r);
d385 1
a385 3
  if (!current_thread)
    /* Windows sometimes uses a non-existent thread id in its events */;
  else if (r >= 0)
d399 1
a399 4
  /* Check if current_thread exists.  Windows sometimes uses a non-existent
     thread id in its events */
  if (current_thread)
    do_child_store_inferior_registers (r);
d1182 1
a1182 1
	      /* Only change the value of the debug registers */
a1199 13
/* Called in pathological case where Windows fails to send a
   CREATE_PROCESS_DEBUG_EVENT after an attach.  */
DWORD
fake_create_process (void)
{
  current_process_handle = OpenProcess (PROCESS_ALL_ACCESS, FALSE,
					current_event.dwProcessId);
  main_thread_id = current_event.dwThreadId;
  current_thread = child_add_thread (main_thread_id,
				     current_event.u.CreateThread.hThread);
  return main_thread_id;
}

d1208 1
a1208 1
  thread_info *th;
a1221 1
  th = NULL;
d1231 1
a1231 11
	{
	  if (!saw_create && attach_flag)
	    {
	      /* Kludge around a Windows bug where first event is a create
		 thread event.  Caused when attached process does not have
		 a main thread. */
	      retval = ourstatus->value.related_pid = fake_create_process ();
	      saw_create++;
	    }
	  break;
	}
d1247 4
a1250 5
      if (current_event.dwThreadId != main_thread_id)
	{
	  child_delete_thread (current_event.dwThreadId);
	  th = &dummy_thread_info;
	}
a1265 2
      if (main_thread_id)
	child_delete_thread (main_thread_id);
d1268 4
d1356 1
a1357 1
      current_thread = th ?: thread_rec (current_event.dwThreadId, TRUE);
d1572 4
a1575 3
    DebugSetProcessKillOnExit (FALSE);

  attach_flag = 1;
a1696 2
  attach_flag = 0;

d1898 1
a1898 2
  if (current_thread && current_thread->h)
    (void) CloseHandle (current_thread->h);
d2150 1
d2202 2
a2203 2
    register_loaded_dll (dll_name, base_addr + 0x1000);
    solib_symbols_add (dll_name, 0, (CORE_ADDR) base_addr + 0x1000);
d2205 9
a2213 3
  out:
    return 1;
  }
d2215 6
a2220 5
  typedef struct
  {
    struct target_ops *target;
    bfd_vma addr;
  } map_code_section_args;
d2222 5
a2226 12
  static void
  map_single_dll_code_section (bfd * abfd, asection * sect, void *obj)
  {
    int old;
    int update_coreops;
    struct section_table *new_target_sect_ptr;

    map_code_section_args *args = (map_code_section_args *) obj;
    struct target_ops *target = args->target;
    if (sect->flags & SEC_CODE)
      {
	update_coreops = core_ops.to_sections == target->to_sections;
d2228 14
a2241 14
	if (target->to_sections)
	  {
	    old = target->to_sections_end - target->to_sections;
	    target->to_sections = (struct section_table *)
	      xrealloc ((char *) target->to_sections,
			(sizeof (struct section_table)) * (1 + old));
	  }
	else
	  {
	    old = 0;
	    target->to_sections = (struct section_table *)
	      xmalloc ((sizeof (struct section_table)));
	  }
	target->to_sections_end = target->to_sections + (1 + old);
d2243 15
a2257 15
	/* Update the to_sections field in the core_ops structure
	   if needed.  */
	if (update_coreops)
	  {
	    core_ops.to_sections = target->to_sections;
	    core_ops.to_sections_end = target->to_sections_end;
	  }
	new_target_sect_ptr = target->to_sections + old;
	new_target_sect_ptr->addr = args->addr + bfd_section_vma (abfd, sect);
	new_target_sect_ptr->endaddr = args->addr + bfd_section_vma (abfd, sect) +
	  bfd_section_size (abfd, sect);;
	new_target_sect_ptr->the_bfd_section = sect;
	new_target_sect_ptr->bfd = abfd;
      }
  }
d2259 2
a2260 2
  static int
  dll_code_sections_add (const char *dll_name, int base_addr, struct target_ops *target)
@


1.62.2.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d386 1
a386 1
    deprecated_read_register_gen (r, ((char *) &current_thread->context) + mappings[r]);
d1831 2
d1836 1
d1841 1
d1847 2
@


1.62.2.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d476 1
a476 1
	error ("Error getting dll name: %u\n", (unsigned) GetLastError ());
a504 1
  DWORD end_addr;
a580 1
  MEMORY_BASIC_INFORMATION m;
a603 6
  if (!VirtualQueryEx (current_process_handle, (void *) load_addr, &m,
		       sizeof (m)))
    so->end_addr = (DWORD) m.AllocationBase + m.RegionSize;
  else
    so->end_addr = load_addr + 0x2000;	/* completely arbitrary */

a710 10
char *
solib_address (CORE_ADDR address)
{
  struct so_stuff *so;
  for (so = &solib_start; so->next != NULL; so = so->next)
    if (address >= so->load_addr && address <= so->end_addr)
      return so->name;
  return NULL;
}

d752 1
a752 1
  return safe_symbol_file_add (name, from_tty, &section_addrs, 0, OBJF_SHARED);
a1200 1
      re_enable_breakpoints_in_shlibs ();
a1307 1
  disable_breakpoints_in_shlibs (1);
a1368 1
  saw_create = 0;
d1621 1
a1621 1
    error ("Error creating process %s, (error %d)\n", exec_file, (unsigned) GetLastError ());
@


1.62.2.3
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d3 1
a3 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free
d127 1
d386 1
a386 1
    regcache_collect (r, ((char *) &current_thread->context) + mappings[r]);
a753 53
/* Get the loaded address of all sections, given that .text was loaded
   at text_load. Assumes that all sections are subject to the same
   relocation offset. Returns NULL if problems occur or if the
   sections were not relocated. */

static struct section_addr_info *
get_relocated_section_addrs (bfd *abfd, CORE_ADDR text_load)
{
  struct section_addr_info *result = NULL;
  int section_count = bfd_count_sections (abfd);
  asection *text_section = bfd_get_section_by_name (abfd, ".text");
  CORE_ADDR text_vma;

  if (!text_section)
    {
      /* Couldn't get the .text section. Weird. */
    }

  else if (text_load == (text_vma = bfd_get_section_vma (abfd, text_section)))
    {
      /* DLL wasn't relocated. */
    }

  else
    {
      /* Figure out all sections' loaded addresses. The offset here is
	 such that taking a bfd_get_section_vma() result and adding
	 offset will give the real load address of the section. */

      CORE_ADDR offset = text_load - text_vma;

      struct section_table *table_start = NULL;
      struct section_table *table_end = NULL;
      struct section_table *iter = NULL;

      build_section_table (abfd, &table_start, &table_end);

      for (iter = table_start; iter < table_end; ++iter)
	{
	  /* Relocated addresses. */
	  iter->addr += offset;
	  iter->endaddr += offset;
	}

      result = build_section_addr_info_from_section_table (table_start,
							   table_end);

      xfree (table_start);
    }

  return result;
}

d758 1
a758 3
  struct section_addr_info *section_addrs_ptr = NULL;
  static struct objfile *result = NULL;
  bfd *abfd = NULL;
d767 4
a770 40
  abfd = bfd_openr (name, "pei-i386");

  if (!abfd)
    {
      /* pei failed - try pe */
      abfd = bfd_openr (name, "pe-i386");
    }

  if (abfd)
    {
      if (bfd_check_format (abfd, bfd_object))
	{
	  section_addrs_ptr = get_relocated_section_addrs (abfd, load_addr);
	}

      bfd_close (abfd);
    }

  if (section_addrs_ptr)
    {
      result = safe_symbol_file_add (name, from_tty, section_addrs_ptr,
				     0, OBJF_SHARED);

      free_section_addr_info (section_addrs_ptr);
    }

  else
    {
      /* Fallback on handling just the .text section. */
      struct section_addr_info section_addrs;

      memset (&section_addrs, 0, sizeof (section_addrs));
      section_addrs.other[0].name = ".text";
      section_addrs.other[0].addr = load_addr;

      result = safe_symbol_file_add (name, from_tty, &section_addrs,
				     0, OBJF_SHARED);
    }

  return result;
d853 4
a856 4
	{
	  puts_filtered ("Segment not present\n");
	  return 0;
	}
d865 1
a865 1
	puts_filtered(" 32-bit ");
d867 1
a867 1
	puts_filtered(" 16-bit ");
d871 2
a872 2
	  puts_filtered ("Data (Read-Only, Exp-up");
	  break;
d874 2
a875 2
	  puts_filtered ("Data (Read/Write, Exp-up");
	  break;
d877 2
a878 2
	  puts_filtered ("Unused segment (");
	  break;
d880 2
a881 2
	  puts_filtered ("Data (Read/Write, Exp-down");
	  break;
d883 2
a884 2
	  puts_filtered ("Code (Exec-Only, N.Conf");
	  break;
d886 1
a886 1
	  puts_filtered ("Code (Exec/Read, N.Conf");
d889 1
a889 1
	  puts_filtered ("Code (Exec-Only, Conf");
d892 1
a892 1
	  puts_filtered ("Code (Exec/Read, Conf");
d898 1
a898 1
	puts_filtered(", N.Acc");
d904 1
a904 1
	puts_filtered ("Page granular.\n");
d929 1
a929 1
	current_thread->context.SegCs);
d932 1
a932 1
	current_thread->context.SegDs);
d935 1
a935 1
	current_thread->context.SegEs);
d938 1
a938 1
	current_thread->context.SegSs);
d944 1
a944 1
	current_thread->context.SegGs);
a1376 77
/* Try to set or remove a user privilege to the current process.  Return -1
   if that fails, the previous setting of that privilege otherwise.

   This code is copied from the Cygwin source code and rearranged to allow
   dynamically loading of the needed symbols from advapi32 which is only
   available on NT/2K/XP. */
static int
set_process_privilege (const char *privilege, BOOL enable)
{
  static HMODULE advapi32 = NULL;
  static BOOL WINAPI (*OpenProcessToken)(HANDLE, DWORD, PHANDLE);
  static BOOL WINAPI (*LookupPrivilegeValue)(LPCSTR, LPCSTR, PLUID);
  static BOOL WINAPI (*AdjustTokenPrivileges)(HANDLE, BOOL, PTOKEN_PRIVILEGES,
					      DWORD, PTOKEN_PRIVILEGES, PDWORD);

  HANDLE token_hdl = NULL;
  LUID restore_priv;
  TOKEN_PRIVILEGES new_priv, orig_priv;
  int ret = -1;
  DWORD size;

  if (GetVersion () >= 0x80000000)  /* No security availbale on 9x/Me */
    return 0;

  if (!advapi32)
    {
      if (!(advapi32 = LoadLibrary ("advapi32.dll")))
	goto out;
      if (!OpenProcessToken)
	OpenProcessToken = GetProcAddress (advapi32, "OpenProcessToken");
      if (!LookupPrivilegeValue)
	LookupPrivilegeValue = GetProcAddress (advapi32,
					       "LookupPrivilegeValueA");
      if (!AdjustTokenPrivileges)
	AdjustTokenPrivileges = GetProcAddress (advapi32,
						"AdjustTokenPrivileges");
      if (!OpenProcessToken || !LookupPrivilegeValue || !AdjustTokenPrivileges)
	{
	  advapi32 = NULL;
	  goto out;
	}
    }

  if (!OpenProcessToken (GetCurrentProcess (),
			 TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
			 &token_hdl))
    goto out;

  if (!LookupPrivilegeValue (NULL, privilege, &restore_priv))
    goto out;

  new_priv.PrivilegeCount = 1;
  new_priv.Privileges[0].Luid = restore_priv;
  new_priv.Privileges[0].Attributes = enable ? SE_PRIVILEGE_ENABLED : 0;

  if (!AdjustTokenPrivileges (token_hdl, FALSE, &new_priv,
			      sizeof orig_priv, &orig_priv, &size))
    goto out;
#if 0
  /* Disabled, otherwise every `attach' in an unprivileged user session
     would raise the "Failed to get SE_DEBUG_NAME privilege" warning in
     child_attach(). */
  /* AdjustTokenPrivileges returns TRUE even if the privilege could not
     be enabled. GetLastError () returns an correct error code, though. */
  if (enable && GetLastError () == ERROR_NOT_ALL_ASSIGNED)
    goto out;
#endif

  ret = orig_priv.Privileges[0].Attributes == SE_PRIVILEGE_ENABLED ? 1 : 0;

out:
  if (token_hdl)
    CloseHandle (token_hdl);

  return ret;
}

d1387 1
a1387 8
  if (set_process_privilege (SE_DEBUG_NAME, TRUE) < 0)
    {
      printf_unfiltered ("Warning: Failed to get SE_DEBUG_NAME privilege\n");
      printf_unfiltered ("This can cause attach to fail on Windows NT/2K/XP\n");
    }

  pid = strtoul (args, 0, 0);		/* Windows pid */

a1391 8
    {
      /* Try fall back to Cygwin pid */
      pid = cygwin_internal (CW_CYGWIN_PID_TO_WINPID, pid);

      if (pid > 0)
	ok = DebugActiveProcess (pid);

      if (!ok)
a1392 1
    }
d1926 2
a1927 2
		  "Print information specific to Win32 debugging.",
		  &info_w32_cmdlist, "info w32 ", 0, &infolist);
d1930 1
a1930 1
	   "Display selectors infos.",
@


1.62.2.4
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d605 2
a606 2
  if (VirtualQueryEx (current_process_handle, (void *) load_addr, &m,
		      sizeof (m)))
d638 2
d642 2
a643 2
  if (!ReadProcessMemory (h, address,  &address_ptr, sizeof (address_ptr), &done) 
      || done != sizeof (address_ptr) || !address_ptr)
d647 6
a652 3
  while (ReadProcessMemory (h, address_ptr + len++ * size, &b, size, &done)
	 && (b[0] != 0 || b[size - 1] != 0) && done == size)
    continue;
d952 1
a952 1
	limit = (limit << 12) | 0xfff;
d1574 1
a1574 1
	error ("Can't attach to process.");
d1866 1
a1866 1
  DWORD done = 0;
d1871 2
a1872 3
      if (!WriteProcessMemory (current_process_handle, (LPVOID) memaddr, our,
			       len, &done))
	done = 0;
d1879 2
a1880 3
      if (!ReadProcessMemory (current_process_handle, (LPCVOID) memaddr, our,
			      len, &done))
	done = 0;
d1967 10
a1976 10
	  if (debug_registers_changed)
	    {
	      th->context.Dr0 = dr[0];
	      th->context.Dr1 = dr[1];
	      th->context.Dr2 = dr[2];
	      th->context.Dr3 = dr[3];
	      /* th->context.Dr6 = dr[6];
	       FIXME: should we set dr6 also ?? */
	      th->context.Dr7 = dr[7];
	    }
@


1.62.2.5
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d845 1
a845 2
      struct section_addr_info *section_addrs;
      struct cleanup *my_cleanups;
d847 3
a849 4
      section_addrs = alloc_section_addr_info (1);
      my_cleanups = make_cleanup (xfree, section_addrs);
      section_addrs->other[0].name = ".text";
      section_addrs->other[0].addr = load_addr;
a852 1
      do_cleanups (my_cleanups);
@


1.62.2.6
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d640 1
a640 1
  if (!ReadProcessMemory (h, address,  &address_ptr, sizeof (address_ptr), &done)
d805 1
a805 1
  struct section_addr_info *addrs = NULL;
d828 1
a828 1
	  addrs = get_relocated_section_addrs (abfd, load_addr);
d834 1
a834 1
  if (addrs)
d836 4
a839 2
      result = safe_symbol_file_add (name, from_tty, addrs, 0, OBJF_SHARED);
      free_section_addr_info (addrs);
d841 1
d845 1
d848 4
a851 4
      addrs = alloc_section_addr_info (1);
      my_cleanups = make_cleanup (xfree, addrs);
      addrs->other[0].name = ".text";
      addrs->other[0].addr = load_addr;
d853 2
a854 1
      result = safe_symbol_file_add (name, from_tty, addrs, 0, OBJF_SHARED);
d2218 2
a2219 1
} map_code_section_args;
@


1.62.2.7
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d30 1
d73 1
d76 3
@


1.62.2.8
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d38 1
a54 4
#include "exec.h"

#include "i386-tdep.h"
#include "i387-tdep.h"
d185 1
d197 1
d350 1
a350 4

#define I387_ST0_REGNUM I386_ST0_REGNUM

  if (r == I387_FISEG_REGNUM)
d355 1
a355 1
  else if (r == I387_FOP_REGNUM)
a366 2

#undef I387_ST0_REGNUM
d1628 1
@


1.62.2.9
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d79 2
a80 2
static int debug_registers_changed;
static int debug_registers_used;
a110 1
    int reload_context;
d231 1
d249 13
a261 1
	    th->reload_context = 1;
a351 19
  if (!current_thread)
    return;	/* Windows sometimes uses a non-existent thread id in its
		   events */

  if (current_thread->reload_context)
    {
      thread_info *th = current_thread;
      th->context.ContextFlags = CONTEXT_DEBUGGER_DR;
      GetThreadContext (th->h, &th->context);
      /* Copy dr values from that thread.  */
      dr[0] = th->context.Dr0;
      dr[1] = th->context.Dr1;
      dr[2] = th->context.Dr2;
      dr[3] = th->context.Dr3;
      dr[6] = th->context.Dr6;
      dr[7] = th->context.Dr7;
      current_thread->reload_context = 0;
    }

d379 1
a379 4
  /* Check if current_thread exists.  Windows sometimes uses a non-existent
     thread id in its events */
  if (current_thread)
    do_child_fetch_inferior_registers (r);
d385 1
a385 3
  if (!current_thread)
    /* Windows sometimes uses a non-existent thread id in its events */;
  else if (r >= 0)
d399 1
a399 4
  /* Check if current_thread exists.  Windows sometimes uses a non-existent
     thread id in its events */
  if (current_thread)
    do_child_store_inferior_registers (r);
d1182 1
a1182 1
	      /* Only change the value of the debug registers */
a1199 13
/* Called in pathological case where Windows fails to send a
   CREATE_PROCESS_DEBUG_EVENT after an attach.  */
DWORD
fake_create_process (void)
{
  current_process_handle = OpenProcess (PROCESS_ALL_ACCESS, FALSE,
					current_event.dwProcessId);
  main_thread_id = current_event.dwThreadId;
  current_thread = child_add_thread (main_thread_id,
				     current_event.u.CreateThread.hThread);
  return main_thread_id;
}

d1208 1
a1208 1
  thread_info *th;
a1221 1
  th = NULL;
d1231 1
a1231 11
	{
	  if (!saw_create && attach_flag)
	    {
	      /* Kludge around a Windows bug where first event is a create
		 thread event.  Caused when attached process does not have
		 a main thread. */
	      retval = ourstatus->value.related_pid = fake_create_process ();
	      saw_create++;
	    }
	  break;
	}
d1247 4
a1250 5
      if (current_event.dwThreadId != main_thread_id)
	{
	  child_delete_thread (current_event.dwThreadId);
	  th = &dummy_thread_info;
	}
a1265 2
      if (main_thread_id)
	child_delete_thread (main_thread_id);
d1268 4
d1356 1
a1357 1
      current_thread = th ?: thread_rec (current_event.dwThreadId, TRUE);
d1572 4
a1575 3
    DebugSetProcessKillOnExit (FALSE);

  attach_flag = 1;
a1696 2
  attach_flag = 0;

d1898 1
a1898 2
  if (current_thread && current_thread->h)
    (void) CloseHandle (current_thread->h);
d2150 1
d2202 2
a2203 2
    register_loaded_dll (dll_name, base_addr + 0x1000);
    solib_symbols_add (dll_name, 0, (CORE_ADDR) base_addr + 0x1000);
d2205 9
a2213 3
  out:
    return 1;
  }
d2215 6
a2220 5
  typedef struct
  {
    struct target_ops *target;
    bfd_vma addr;
  } map_code_section_args;
d2222 5
a2226 12
  static void
  map_single_dll_code_section (bfd * abfd, asection * sect, void *obj)
  {
    int old;
    int update_coreops;
    struct section_table *new_target_sect_ptr;

    map_code_section_args *args = (map_code_section_args *) obj;
    struct target_ops *target = args->target;
    if (sect->flags & SEC_CODE)
      {
	update_coreops = core_ops.to_sections == target->to_sections;
d2228 14
a2241 14
	if (target->to_sections)
	  {
	    old = target->to_sections_end - target->to_sections;
	    target->to_sections = (struct section_table *)
	      xrealloc ((char *) target->to_sections,
			(sizeof (struct section_table)) * (1 + old));
	  }
	else
	  {
	    old = 0;
	    target->to_sections = (struct section_table *)
	      xmalloc ((sizeof (struct section_table)));
	  }
	target->to_sections_end = target->to_sections + (1 + old);
d2243 15
a2257 15
	/* Update the to_sections field in the core_ops structure
	   if needed.  */
	if (update_coreops)
	  {
	    core_ops.to_sections = target->to_sections;
	    core_ops.to_sections_end = target->to_sections_end;
	  }
	new_target_sect_ptr = target->to_sections + old;
	new_target_sect_ptr->addr = args->addr + bfd_section_vma (abfd, sect);
	new_target_sect_ptr->endaddr = args->addr + bfd_section_vma (abfd, sect) +
	  bfd_section_size (abfd, sect);;
	new_target_sect_ptr->the_bfd_section = sect;
	new_target_sect_ptr->bfd = abfd;
      }
  }
d2259 2
a2260 2
  static int
  dll_code_sections_add (const char *dll_name, int base_addr, struct target_ops *target)
@


1.61
log
@	Fix PR gdb/393:
	* inflow.c (terminal_save_ours): New function to save terminal
	settings.
	* inferior.h (terminal_save_ours): Declare.
	* target.c (debug_to_terminal_save_ours): New function.
	(cleanup_target): Defaults to_terminal_save_ours.
	(update_current_target): Inherit to_terminal_save_ours.
	(setup_target_debug): Set to_terminal_save_ours.
	* target.h (target_terminal_save_ours): New to save terminal settings.
	(target_ops): New member to_terminal_save_ours.
	* gnu-nat.c (init_gnu_ops): Set to_terminal_save_ours.
	* hpux-thread.c (init_hpux_thread_ops): Likewise.
	* inftarg.c (init_child_ops): Likewise.
	* m3-nat.c (init_m3_ops): Likewise.
	* procfs.c (init_procfs_ops): Likewise.
	* wince.c (init_child_ops): Likewise.
	* win32-nat.c (init_child_ops): Likewise.
	* sol-thread.c (init_sol_thread_ops): Likewise.
@
text
@d1464 2
d1578 21
d1609 11
@


1.61.2.1
log
@* win32-nat.c (child_attach): Reset saw_create counter or subsequent attach
will hang.
* win32-nat.c (psapi_get_dll_name): Fix a compiler warning.
(struct so_stuff): Add end_addr field.
(register_loaded_dll): Calculate and store end address of loaded dll.
(solib_address): New function.
(child_solib_loaded_library_pathname): Pass carefully constructed section info
to safe_symbol_file_add rather than ignoring it.
(get_child_debug_event): Call re_enable_breakpoints_in_shlibs when a DLL is
loaded.
(do_initial_child_stuff): Call disable_breakpoints_in_shlibs.
(child_create_inferior): Fix a compiler warning.
* config/i386/tm-cygwin.h (PC_SOLIB): Define new macro.
(solib_address): Declare new function.
@
text
@d476 1
a476 1
	error ("Error getting dll name: %u\n", (unsigned) GetLastError ());
a504 1
  DWORD end_addr;
a580 1
  MEMORY_BASIC_INFORMATION m;
a603 6
  if (!VirtualQueryEx (current_process_handle, (void *) load_addr, &m,
		       sizeof (m)))
    so->end_addr = (DWORD) m.AllocationBase + m.RegionSize;
  else
    so->end_addr = load_addr + 0x2000;	/* completely arbitrary */

a710 10
char *
solib_address (CORE_ADDR address)
{
  struct so_stuff *so;
  for (so = &solib_start; so->next != NULL; so = so->next)
    if (address >= so->load_addr && address <= so->end_addr)
      return so->name;
  return NULL;
}

d752 1
a752 1
  return safe_symbol_file_add (name, from_tty, &section_addrs, 0, OBJF_SHARED);
a1200 1
      re_enable_breakpoints_in_shlibs ();
a1307 1
  disable_breakpoints_in_shlibs (1);
a1368 1
  saw_create = 0;
d1587 1
a1587 1
    error ("Error creating process %s, (error %d)\n", exec_file, (unsigned) GetLastError ());
@


1.60
log
@Fix some K&R isms.
@
text
@d1794 1
@


1.59
log
@* wince.c (_initialize_wince): Rename _initialize_inftarg.
* win32-nat.c (_initialize_win32_nat): Rename _initialize_inftarg.
@
text
@d1337 1
a1337 1
has_detach_ability ()
@


1.58
log
@* win32-nat.c (child_create_inferior): Check for proper shell to use here, in
case the user changes it on the fly.
(_initialize_inftarg): Remove shell path considerations.
@
text
@d1818 1
a1818 1
_initialize_inftarg (void)
@


1.58.6.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d1337 1
a1337 1
has_detach_ability (void)
d1818 1
a1818 1
_initialize_win32_nat (void)
@


1.58.6.2
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@a1793 1
  child_ops.to_terminal_save_ours = terminal_save_ours;
@


1.58.6.3
log
@Merge with kseitz_interps-20020930-merge.
@
text
@a1463 2
  int tty;
  int ostdin, ostdout, ostderr;
a1575 21
  if (!inferior_io_terminal)
    tty = ostdin = ostdout = ostderr = -1;
  else
    {
      tty = open (inferior_io_terminal, O_RDWR | O_NOCTTY);
      if (tty < 0)
	{
	  print_sys_errmsg (inferior_io_terminal, errno);
	  ostdin = ostdout = ostderr = -1;
	}
      else
	{
	  ostdin = dup (0);
	  ostdout = dup (1);
	  ostderr = dup (2);
	  dup2 (tty, 0);
	  dup2 (tty, 1);
	  dup2 (tty, 2);
	}
    }

a1585 11
  if (tty >= 0)
    {
      close (tty);
      dup2 (ostdin, 0);
      dup2 (ostdout, 1);
      dup2 (ostderr, 2);
      close (ostdin);
      close (ostdout);
      close (ostderr);
    }

@


1.58.6.4
log
@merge from mainline
@
text
@d386 1
a386 1
    deprecated_read_register_gen (r, ((char *) &current_thread->context) + mappings[r]);
@


1.57
log
@* cli/cli-decode.c (set_cmd_completer): New function.
* command.h (set_cmd_completer): Declare.
* cli/cli-decode.h (set_cmd_completer): Ditto.

* breakpoint.c (_initialize_breakpoint): Use set_cmd_completer.
* cli/cli-cmds.c (init_cli_cmds): Ditto.
* win32-nat.c (_initialize_inftarg): Ditto.
* remote-rdi.c (_initialize_remote_rdi): Ditto.
* proc-api.c (_initialize_proc_api): Ditto.
* hppa-tdep.c (_initialize_hppa_tdep): Ditto.
* source.c (_initialize_source): Ditto.
* exec.c (_initialize_exec): Ditto.
* solib.c (_initialize_solib): Ditto.
* top.c (init_main): Ditto.
* tracepoint.c (_initialize_tracepoint): Ditto.
* symfile.c (_initialize_symfile): Ditto.
* printcmd.c (_initialize_printcmd): Ditto.
* infcmd.c (_initialize_infcmd): Ditto.
* corefile.c (_initialize_core): Ditto.
@
text
@d126 2
a127 1
static DWORD main_thread_id;	/* Thread ID of the main thread */
a142 3
/* Path to shell */
static char shell[MAX_PATH + 1];

d1462 2
d1471 1
a1471 1
  if (!useshell || !shell[0])
d1479 7
a1485 2
      char *newallargs = alloca (sizeof (" -c 'exec  '") + strlen (exec_file)
				 + strlen (allargs) + 2);
d1505 1
a1505 1
    /* This code use to assume all env vars were file names and would
a1820 1
  const char *sh;
a1826 14

  sh = getenv ("SHELL");
  if (!sh)
    sh = "/bin/sh";
  if (access (sh, X_OK) != 0)
    {
      shell[0] = '\0';
      useshell = 0;
    }
  else
    {
      cygwin_conv_to_win32_path (sh, shell);
      useshell = 1;
    }
@


1.56
log
@2002-02-22  Pierre Muller  <muller@@ics.u-strasbg.fr>

	* win32-nat.c (child_create_inferior): Fix create flags setting bug.
@
text
@d1822 1
a1822 1
  c->completer = filename_completer;
@


1.56.2.1
log
@2002-04-08  Pierre Muller  <muller@@ics.u-strasbg.fr>

	from 2002-03-22  Christopher Faylor  <cgf@@redhat.com> patch
	in main branch.
	* win32-nat.c (child_create_inferior): Check for proper shell to use
	here, in case the user changes it on the fly.
	(_initialize_inftarg): Remove shell path considerations.
@
text
@d126 1
a126 2
static DWORD main_thread_id;		/* Thread ID of the main thread */
static pid_t cygwin_pid;		/* pid of cygwin process */
d142 3
a1463 2
  char shell[MAX_PATH + 1]; /* Path to shell */
  const char *sh;
d1471 1
a1471 1
  if (!useshell)
d1479 2
a1480 7
      char *newallargs;
      sh = getenv ("SHELL");
      if (!sh)
	sh = "/bin/sh";
      cygwin_conv_to_win32_path (sh, shell);
      newallargs = alloca (sizeof (" -c 'exec  '") + strlen (exec_file)
			   + strlen (allargs) + 2);
d1500 1
a1500 1
    /* This code used to assume all env vars were file names and would
d1816 1
d1823 14
@


1.55
log
@* win32-nat.c (register_loaded_dll): Just use raw name when we can't find the
complete path to a loaded DLL.
@
text
@a1470 8
  flags = 0;

  if (new_group)
    flags |= CREATE_NEW_PROCESS_GROUP;

  if (new_console)
    flags |= CREATE_NEW_CONSOLE;

d1479 2
a1480 1
      char *newallargs = alloca (sizeof (" -c 'exec  '") + strlen (exec_file) + strlen (allargs) + 2);
d1486 6
@


1.54
log
@* win32-nat.c (register_loaded_dll): Correctly check for invalid handle value.
@
text
@d585 3
a587 1
  if (h != INVALID_HANDLE_VALUE)
@


1.53
log
@* win32-nat.c (register_loaded_dll): Handle case where FindFirstFile fails.
@
text
@d585 1
a585 1
  if (h)
@


1.52
log
@2002-02-18  Pierre Muller  <muller@@ics.u-strasbg.fr>

	* win32-nat.c (display_selector): New function. Displays information
	about the information returned by GetThreadSelectorEntry API function.
	(display_selectors): New function. Displays the infomation of
	the selector given as argument, or of CS, DS ans FS selectors
	if no argument is given.
	( _initialize_inftarg): Add "w32" as info prefix command.
	Add "info w32 selector" as command calling display_selectors.
@
text
@d585 1
a585 3
  FindClose (h);
  strcpy (buf, name);
  if (GetCurrentDirectory (MAX_PATH + 1, cwd))
d587 11
a597 6
      p = strrchr (buf, '\\');
      if (p)
	p[1] = '\0';
      SetCurrentDirectory (buf);
      GetFullPathName (w32_fd.cFileName, MAX_PATH, buf, &p);
      SetCurrentDirectory (cwd);
@


1.51
log
@* win32-nat.c (get_image_name): New function.
(handle_load_dll): Use get_image_name function.
(get_child_debug_event): Avoid registering debug events until possibly execed
process is started.
(child_create_inferior): Allow invocation via shell so that command line
redirection, etc.  works ok.
(_initialize_inftarg): Add new command: "set shell" to control whether a shell
is used to start a process.
@
text
@d823 120
d1880 8
@


1.50
log
@* win32-nat.c (cygwin_pid_to_str): Revert 2002-02-08 change xasprintf changes.
(_initialize_check_for_gdb_ini): Ditto.
@
text
@d25 1
a25 1
/* by Steve Chamberlain, sac@@cygnus.com */
d89 1
a89 1
#define DEBUG_EXEC(x)	if (debug_exec)		printf_unfiltered x 
d131 1
d136 3
a138 3
static int debug_exec = 0;	/* show execution */
static int debug_events = 0;	/* show events from kernel */
static int debug_memory = 0;	/* show target memory accesses */
d140 4
d234 1
a234 1
    printf_filtered ("error return %s:%d was %lu\n", file, line, 
d292 1
a292 1
  /* Set the debug registers for the new thread in they are used.  */ 
d612 46
a663 2
  DWORD dll_name_ptr;
  DWORD done;
d675 2
a676 56
  /* Attempt to read the name of the dll that was detected.
     This is documented to work only when actively debugging
     a program.  It will not work for attached processes. */
  if (dll_name == NULL || *dll_name == '\0')
    {
      DWORD size = event->fUnicode ? sizeof (WCHAR) : sizeof (char);
      int len = 0;
      char b[2];

      ReadProcessMemory (current_process_handle,
			 (LPCVOID) event->lpImageName,
			 (char *) &dll_name_ptr,
			 sizeof (dll_name_ptr), &done);

      /* See if we could read the address of a string, and that the
	 address isn't null. */

      if (done != sizeof (dll_name_ptr) || !dll_name_ptr)
	return 1;

      do
	{
	  ReadProcessMemory (current_process_handle,
			     (LPCVOID) (dll_name_ptr + len * size),
			     &b,
			     size,
			     &done);
	  len++;
	}
      while ((b[0] != 0 || b[size - 1] != 0) && done == size);

      dll_name = alloca (len);

      if (event->fUnicode)
	{
	  WCHAR *unicode_dll_name = (WCHAR *) alloca (len * sizeof (WCHAR));
	  ReadProcessMemory (current_process_handle,
			     (LPCVOID) dll_name_ptr,
			     unicode_dll_name,
			     len * sizeof (WCHAR),
			     &done);

	  WideCharToMultiByte (CP_ACP, 0,
			       unicode_dll_name, len,
			       dll_name, len, 0, 0);
	}
      else
	{
	  ReadProcessMemory (current_process_handle,
			     (LPCVOID) dll_name_ptr,
			     dll_name,
			     len,
			     &done);
	}
    }

d783 1
a783 1
  printf_filtered ("%*s  Load Address\n", -max_dll_name_len, "DLL Name"); 
d941 1
a941 1
		  continue_status == DBG_CONTINUE ? 
d964 1
a964 1
	         FIXME: should we set dr6 also ?? */
d1005 2
d1022 2
d1034 6
a1040 1

d1057 2
d1071 2
d1085 2
d1098 2
d1109 2
d1116 2
d1126 1
a1126 1
  if (!retval)
d1178 1
a1178 1
  debug_registers_used = 0;  
a1327 1
  char real_path[MAXPATHLEN];
d1337 2
d1346 1
a1346 3
  cygwin_conv_to_win32_path (exec_file, real_path);

  flags = DEBUG_ONLY_THIS_PROCESS;
d1354 14
a1367 3
  args = alloca (strlen (real_path) + strlen (allargs) + 2);

  strcpy (args, real_path);
d1369 2
d1462 6
d1560 1
a1560 1
  structure when passing the exception to the inferior. 
d1578 1
a1578 1
	DEBUG_EXCEPT(("Can only continue with recieved signal %d.\n", 
d1602 7
a1608 7
          th->context.Dr0 = dr[0];
          th->context.Dr1 = dr[1];
          th->context.Dr2 = dr[2];
          th->context.Dr3 = dr[3];
          /* th->context.Dr6 = dr[6];
           FIXME: should we set dr6 also ?? */
          th->context.Dr7 = dr[7];
d1692 1
d1700 14
d1716 6
d2067 1
a2067 1
	  sprintf (newini, "%.*s.gdbinit", 
@


1.49
log
@2002-02-08  Martin M. Hunt  <hunt@@redhat.com>

	* win32-nat.c (cygwin_pid_to_str): Fix typo.
	xaprintf -> xasprintf.
@
text
@d1766 1
a1766 1
    xasprintf (buf, "process %d", pid);
d1768 1
a1768 1
    xasprintf (buf, "thread %ld.0x%x", current_event.dwProcessId, pid);
d2012 1
a2012 1
	  xasprintf (newini, "%.*s.gdbinit", 
@


1.48
log
@2002-02-08  Pierre Muller  <muller@@ics.u-strasbg.fr>

	* win32-nat.c: Remove use of printf and sprintf functions.
@
text
@d1766 1
a1766 1
    xaprintf (buf, "process %d", pid);
@


1.47
log
@2002-02-06  Pierre Muller  <muller@@ics.u-strasbg.fr>

	* win32-nat.c (_initialize_check_for_gdb_ini):
	Add typecast to sprintf argument to suppress a warning.
@
text
@d89 4
a92 4
#define DEBUG_EXEC(x)	if (debug_exec)		printf x
#define DEBUG_EVENTS(x)	if (debug_events)	printf x
#define DEBUG_MEM(x)	if (debug_memory)	printf x
#define DEBUG_EXCEPT(x)	if (debug_exceptions)	printf x
d788 1
a788 1
  printf ("%*s  Load Address\n", -max_dll_name_len, "DLL Name");
d829 1
a829 1
  printf ("gdb: Target exception %s at 0x%08lx\n", x, \
d1766 1
a1766 1
    sprintf (buf, "process %d", pid);
d1768 1
a1768 1
    sprintf (buf, "thread %ld.0x%x", current_event.dwProcessId, pid);
d2012 1
a2012 1
	  sprintf (newini, "%.*s.gdbinit", 
@


1.46
log
@2002-02-05  Pierre Muller  <muller@@ics.u-strasbg.fr>

	win32-nat.c (last_sig): Changed type of variable to target_signal,
	to allow easier handling of pass state.
	(DEBUG_EXCEPTION_SIMPLE): New macro, used in handle_exception,
	that gives exception name and address.
	(handle_exception): Use DEBUG_EXCEPTION_SIMPLE macro
	and set last_sig value to ourstatus->value.sig. Some missing
	exceptions added.
	(child_continue): Correctly report continue_status.
	(get_child_debug_event,do_initial_child_stuff): Set last_sig to
	TARGET_SIGNAL_0 (new default value).
	(child_resume): consider sig argument passed to decide if
	the exception should be passed to debuggee or not.
@
text
@d2012 2
a2013 1
	  sprintf (newini, "%.*s.gdbinit", len - (sizeof ("gdb.ini") - 1), oldini);
@


1.45
log
@2002-02-04  Pierre Muller  <muller@@ics.u-strasbg.fr>
          win32-nat.c (handle_exception): Handle Ctrl-Break exception.
@
text
@d101 3
a103 2
static int last_sig = 0;	/* Set if a signal was received from the
				   debugged process */
d222 1
d828 4
d846 5
a850 2
      DEBUG_EXCEPT (("gdb: Target exception ACCESS_VIOLATION at 0x%08lx\n",
       (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d852 24
a875 1
      last_sig = SIGSEGV;
d878 3
d882 3
a884 1
    case STATUS_FLOAT_OVERFLOW:
d886 1
a886 2
      DEBUG_EXCEPT (("gdb: Target exception STACK_OVERFLOW at 0x%08lx\n",
       (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
a887 1
      last_sig = SIGFPE;
d889 3
a891 4
    case STATUS_STACK_OVERFLOW:
      DEBUG_EXCEPT (("gdb: Target exception STACK_OVERFLOW at 0x%08lx\n",
       (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
      ourstatus->value.sig = TARGET_SIGNAL_SEGV;
d894 1
a894 2
      DEBUG_EXCEPT (("gdb: Target exception BREAKPOINT at 0x%08lx\n",
       (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d898 1
a898 2
      DEBUG_EXCEPT (("gdb: Target exception CONTROL_C at 0x%08lx\n",
       (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
a899 1
      last_sig = SIGINT;	/* FIXME - should check pass state */
d902 1
a902 2
      DEBUG_EXCEPT (("gdb: Target exception CONTROL_BREAK at 0x%08lx\n",
       (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
a903 1
      last_sig = SIGINT;	/* FIXME - should check pass state */
d906 1
a906 2
      DEBUG_EXCEPT (("gdb: Target exception SINGLE_STEP at 0x%08lx\n",
       (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d910 9
a918 2
      DEBUG_EXCEPT (("gdb: Target exception SINGLE_ILL at 0x%08lx\n",
       (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
a919 1
      last_sig = SIGILL;
d931 1
d944 4
a947 2
  DEBUG_EVENTS (("ContinueDebugEvent (cpid=%ld, ctid=%ld, DBG_CONTINUE);\n",
		 current_event.dwProcessId, current_event.dwThreadId));
d992 1
a992 1
  last_sig = 0;
d1158 1
a1158 1
  last_sig = 0;
d1510 2
a1511 2
  DWORD continue_status = last_sig > 0 && last_sig < NSIG ?
  DBG_EXCEPTION_NOT_HANDLED : DBG_CONTINUE;
d1514 35
a1548 1
  last_sig = 0;
@


1.44
log
@2002-02-04  Pierre Muller  <muller@@ics.u-strasbg.fr>

	Add support for hardware watchpoints on win32 native.
	* win32-nat.c (CONTEXT_DEBUG_DR macro): Add use of
	CONTEXT_DEBUG_REGISTERS.
	(dr variable): New variable. Static array containing a local copy
	of debug registers.
	(debug_registers_changed): New variable.  Reflects when debug registers
	are changed and need to be written to inferior.
	(debug_registers_used): New variable. Reflects when any debug register
	was set, used when new threads are created.
	(cygwin_set_dr, cygwin_set_dr7, cygwin_get_dr6): New functions used by
	i386-nat code.
	(thread_rec): Set dr array if id is the thread of current_event .
	(child_continue, child_resume): Change the debug registers for all
	threads if debug_registers_changed.
	(child_add_thread): Change the debug registers if debug_registers_used.
	* config/i386/cygwin.mh: Add use of i386-nat.o file.
	Link nm.h to new nm-cygwin.h file.
	+ config/i386/nm-cygwin.h: New file. Contains the macros used for use
	of hardware registers.
@
text
@d870 6
@


1.43
log
@Remove ATTRIBUTE_UNUSED.  Update (C).
@
text
@d74 2
a75 1
#define CONTEXT_DEBUGGER_DR CONTEXT_DEBUGGER | CONTEXT_EXTENDED_REGISTERS
d77 1
a77 1
#define CONTEXT_DEBUGGER_DR CONTEXT_DEBUGGER
d80 3
d223 9
d252 10
d285 16
a346 7
check (BOOL ok, const char *file, int line)
{
  if (!ok)
    printf_filtered ("error return %s:%d was %lu\n", file, line, GetLastError ());
}

static void
d913 1
d917 14
d933 1
d1113 1
d1118 4
d1401 1
d1489 10
d1631 37
@


1.42
log
@2002-01-06  Pierre Muller  <muller@@ics.u-strasbg.fr>

	* win32-nat.c: Add i386-tdep.h dependency.
@
text
@d2 4
a5 2
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d576 1
a576 1
handle_load_dll (void *dummy ATTRIBUTE_UNUSED)
d657 1
a657 1
handle_unload_dll (void *dummy ATTRIBUTE_UNUSED)
d681 1
a681 1
child_solib_loaded_library_pathname (int pid ATTRIBUTE_UNUSED)
d747 1
a747 1
info_dll_command (char *ignore ATTRIBUTE_UNUSED, int from_tty ATTRIBUTE_UNUSED)
d893 1
a893 1
get_child_debug_event (int pid ATTRIBUTE_UNUSED, struct target_waitstatus *ourstatus)
d1163 1
a1163 1
child_detach (char *args ATTRIBUTE_UNUSED, int from_tty)
d1195 1
a1195 1
child_files_info (struct target_ops *ignore ATTRIBUTE_UNUSED)
d1203 1
a1203 1
child_open (char *arg ATTRIBUTE_UNUSED, int from_tty ATTRIBUTE_UNUSED)
d1365 2
a1366 2
		   int write, struct mem_attrib *mem ATTRIBUTE_UNUSED,
		   struct target_ops *target ATTRIBUTE_UNUSED)
d1459 1
a1459 1
child_close (int x ATTRIBUTE_UNUSED)
d1763 2
a1764 1
child_solib_add (char *filename ATTRIBUTE_UNUSED, int from_tty, struct target_ops *target, int readsyms)
@


1.41
log
@2001-11-30  Pierre Muller  <muller@@ics.u-strasbg.fr>

	* win32-nat.c (mappings): Correct position of XMM registers,
	based on FXSAVE instruction structure.
@
text
@d37 1
@


1.40
log
@fix white space.
@
text
@d182 10
a191 10
  context_offset (ExtendedRegisters[0*16]),
  context_offset (ExtendedRegisters[1*16]),
  context_offset (ExtendedRegisters[2*16]),
  context_offset (ExtendedRegisters[3*16]),
  context_offset (ExtendedRegisters[4*16]),
  context_offset (ExtendedRegisters[5*16]),
  context_offset (ExtendedRegisters[6*16]),
  context_offset (ExtendedRegisters[7*16]),
  /* MXCSR untested */
  context_offset (ExtendedRegisters[8*16])
@


1.39
log
@* config/i386/tm-cygwin.h: Define HAVE_SSE_REGS if
HAVE_CONTEXT_EXTENDED_REGISTERS is defined.
* win32-nat.c: Define CONTEXT_DEBUGGER_DR that will also include extended
registers if HAVE_SSE_REGS is defined.
(mappings array): Add offset of extended registers.
(thread_rec): Use new CONTEXT_DEBUGGER_DR macro.
@
text
@d71 1
a71 1
#define CONTEXT_DEBUGGER_DR CONTEXT_DEBUGGER | CONTEXT_EXTENDED_REGISTERS 
d368 1
a368 1
int 
d604 1
a604 1
         address isn't null. */
d986 1
a986 1
         does not exist yet. */
d1169 1
a1169 1
        {
d1173 1
a1173 1
        }
d1459 1
a1459 1
                PIDGET (inferior_ptid)));
d1659 1
a1659 1
         if needed.  */
d1773 1
a1773 1
                                                solib_end->load_addr);
@


1.38
log
@* win32-nat.c (struct so_stuff): Add objfile *objfile field needed to be able
to remove the DLL when unloaded.  Remove unused last field.
(handle_unload_dll): New function to handle unloading of DLL.
(solib_symbols_add): Change return type to struct objfile *.
(get_child_debug_event): Call handle_unload_dll function.
@
text
@d28 1
d70 7
d180 13
d234 1
a234 1
	    th->context.ContextFlags = CONTEXT_DEBUGGER;
@


1.37
log
@* win32-nat.c (_initialize_check_for_gdb_ini): New function.
* config/i386/xm-cygwin.h: Remove obsolete handling of __CYGWIN32__.
(GDBINIT_FILENAME): Remove.
@
text
@d442 1
a442 1
  struct so_stuff *next, **last;
d445 1
d472 1
a472 1
  /* ui_file_delete (gdb_stderr); */
d474 1
a474 1
  /* gdb_stderr = sp->err; */
d494 1
a494 1
  /* gdb_stderr = ui_file_new (); */
d538 2
a543 1
  so->next = NULL;
d632 23
d675 1
d681 1
a681 1
static void
d691 1
a691 1
    return;
d696 1
a696 3
  safe_symbol_file_add (name, from_tty, NULL, 0, OBJF_SHARED);

  return;
d962 5
a966 1
      break;			/* FIXME: don't know what to do here */
d1751 2
a1752 1
	solib_symbols_add (solib_end->name, from_tty, solib_end->load_addr);
@


1.36
log
@Approved by kev@@cygnus.com
ChangeLog entry:

	2001-11-01  Fred Fish  <fnf@@redhat.com>

	* coff-solib.c (coff_solib_add): Add new readsyms arg.
	* irix5-nat.c (solib_add): Ditto.
	* osfsolib.c (solib_add): Ditto.
	* pa64solib.c (pa64_solib_add): Ditto.
	* pa64solib.c (add_to_solist): Ditto.
	* pa64solib.c (read_dld_descriptor): Ditto.
	* solib.c (solib_add): Ditto.
	* somsolib.c (som_solib_add): Ditto.
	* win32-nat.c (child_solib_add): Ditto.
	* xcoffsolib.c (solib_add): Ditto.

	* coff-solib.h (coff_solib_add): Add new readsyms arg to prototype.
	* pa64solib.c (add_to_solist): Ditto.
	* pa64solib.c (read_dld_descriptor): Ditto.
	* pa64solib.h (pa64_solib_add): Ditto.
	* solib.h (solib_add): Ditto.
	* somsolib.h (som_solib_add): Ditto.
	* config/i386/tm-cygwin.h (child_solib_add): Ditto.

	* coff-solib.c (coff_solib_add):  If readsyms is zero don't read
	symbols but do any other needed work for shared libs.
	* irix5-nat.c: Ditto.
	* osfsolib.c (solib_add): Ditto.
	* solib.c (solib_add): Ditto.
	* win32-nat.c (child_solib_add): Ditto.
	* xcoffsolib.c (solib_add): Ditto.

	* irix5-nat.c (sharedlibrary_command): Pass 1 as readsyms to
	solib_add to force reading of shared library symbols.
	* osfsolib.c (sharedlibrary_command;): Ditto.
	* pa64solib.c (pa64_solib_sharedlibrary_command): Ditto.
	* solib.c (sharedlibrary_command): Ditto.
	* somsolib.c (som_solib_sharedlibrary_command): Ditto.
	* xcoffsolib.c (sharedlibrary_command): Ditto.

	* coff-solib.c (coff_solib_create_inferior_hook): Call solib_add
	unconditionally with auto_solib_add.
	* irix5-nat.c (solib_create_inferior_hook): Ditto.
	* osfsolib.c (solib_create_inferior_hook): Ditto.
	* solib.c (solib_create_inferior_hook): Ditto.
	* solib-osf.c (osf_solib_create_inferior_hook): Ditto.
	* solib-svr4.c (enable_break): Ditto.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Ditto.

	* corelow.c (solib_add_stub): Add auto_solib_add to args passed
	via SOLIB_ADD.
	* sol-thread.c (sol_thread_attach): Ditto.
	* config/rs6000/nm-rs6000.h (SOLIB_ADD): Ditto.

	* infcmd.c (attach_command): Remove auto_solib_add decl.
	Call SOLIB_ADD directly with auto_solib_add.
	* infrun.c (handle_inferior_event): Ditto.

	* coff-solib.h (SOLIB_ADD): Add readsyms arg.
	* pa64solib.h (SOLIB_ADD): Ditto.
	* solib.h (SOLIB_ADD): Ditto.
	* somsolib.h (SOLIB_ADD): Ditto.
	* config/i386/tm-cygwin.h (SOLIB_ADD): Ditto.

	* fork-child.c (clone_and_follow_inferior): Remove unused
	auto_solib_add decl.

	* pa64solib.c (pa64_solib_add): Call add_to_solist with readsyms.
	(read_dld_descriptor): Ditto.
	(pa64_solib_add): Call read_dld_descriptor with	readsyms.
	(pa64_solib_in_dynamic_linker): Ditto.

	* corelow.c (symfile.h): Need this for auto_solib_add declaration.
	* sol-thread.c (symfile.h): Ditto.

Approved by eliz@@is.elta.co.il
doc/ChangeLog entry:

	2001-11-01  Fred Fish  <fnf@@redhat.com>

	* gdbint.texinfo (SOLIB_ADD): Document additional new
	"readsyms" arg.
@
text
@d35 1
d1756 28
@


1.35
log
@* win32-nat.c (register_loaded_dll): Attempt to ensure that the case of the
loaded DLL matches the on-disk case since the debugging API does not seem to
ensure this.  Calculate max name length here.
(handle_load_dll): Move max name length calculation to register_loaded_dll.
@
text
@d1710 1
a1710 1
child_solib_add (char *filename ATTRIBUTE_UNUSED, int from_tty, struct target_ops *target)
d1712 2
@


1.34
log
@	2001-10-30  Fred Fish  <fnf@@redhat.com>
	* somsolib.c (som_solib_add): A megabyte is 1024*1024 bytes.
	* pa64solib.c (add_to_solist): Ditto.
	* win32-nat.c (_initialize_inftarg): Remove unnecessary
	initialization of auto_solib_add, it defaults to 1.
@
text
@d513 20
a532 1
  cygwin_conv_to_posix_path (name, ppath);
d541 3
a555 1
  int len;
a623 3
  while ((p = strchr (dll_name, '\\')))
    *p = '/';

a624 3
  len = strlen (dll_name);
  if (len > max_dll_name_len)
    max_dll_name_len = len;
@


1.33
log
@        * win32-nat.c (DebugSetProcessKillOnExit): New static function
        pointer to Windows' DebugSetProcessKillOnExit() function.
        (DebugActiveProcessStop): Ditto for DebugActiveProcessStop().
        (has_detach_ability): New function.
        (child_attach): If system has detach ability, enable it.
        (child_detach): If system has detach ability, actually
        detach from process.
        Change tty output to Linux format.
@
text
@a1455 1
  auto_solib_add = 1;
@


1.32
log
@* win32-nat.c (handle_load_dll): Avoid strlwr'ing loaded DLLs or cygwin may not
be able to read them in certain situations.
@
text
@d1025 29
a1054 1

d1070 6
d1097 15
a1111 1
  if (from_tty)
d1116 2
a1117 2
      printf_unfiltered ("Detaching from program: %s %s\n", exec_file,
			 target_pid_to_str (inferior_ptid));
@


1.31
log
@* win32-nat.c (safe_symbol_file_add_stub): Improve logic for avoiding load of
already loaded DLL.
(register_loaded_dll): Convert loaded DLL name to "posix" format or it will
confuse subsequent opening of the filename due to dos paths.
(dll_symbol_command): Pass from_tty parameter to safe_symbol_file_add.
@
text
@a602 2
  (void) strlwr (dll_name);

@


1.30
log
@* win32-nat.c (safe_symbol_file_add_stub): Properly initialize linked list
pointer to beginning rather than one beyond beginning.
@
text
@d443 3
a445 3
  char name[0];
}
solib_start, *solib_end;
d456 1
a456 1
    if (strcasecmp (so->name, p->name) == 0)
d512 4
a515 1
  so = (struct so_stuff *) xmalloc (sizeof (struct so_stuff) + strlen (name) + 8 + 2);
d517 1
a517 1
  strcpy (so->name, name);
d656 1
a656 1
  safe_symbol_file_add (name, from_tty, 0, 0, OBJF_SHARED);
d663 1
a663 1
dll_symbol_command (char *args, int from_tty ATTRIBUTE_UNUSED)
d680 1
a680 1
  safe_symbol_file_add (args, 0, NULL, 0, OBJF_SHARED | OBJF_USERLOADED);
@


1.29
log
@* config/i386/tm-cygwin.h: include tm-i386.h instead of tm-i386v.h.  This fixes
errors in "long long" handling for 'finish' and 'return' commands.
* win32-nat.c (safe_symbol_file_add_stub): Avoid adding a shared library if it
has already been loaded.
(safe_symbol_file_add_cleanup): Don't mess with stderr or we won't see any
error messages.
(safe_symbol_file_add): Ditto.
(solib_symbols_add): Make static.  Accept 'from_tty' parameter.  Pass it to
safe_symbol_file_add.
(core_dll_symbols_add): Accomodate extra solib_symbols_add parameter.
(child_solib_add): Ditto.
* win32-nat.c (handle_exception): Don't print "first chance" exceptions.
(get_child_debug_event): Continue from exceptions if !handle_exception.
@
text
@d453 1
a453 1
  struct so_stuff *so = solib_start.next;
@


1.28
log
@* win32-nat.c (get_child_debug_event): Close file handles created after process
creation and DLL load.
(child_create_inferior): Close unneeded process/thread handle after thread
creation.
@
text
@d438 9
d453 5
d470 1
a470 1
  ui_file_delete (gdb_stderr);
d472 1
a472 1
  gdb_stderr = sp->err;
d492 1
a492 1
  gdb_stderr = ui_file_new ();
a504 9
/* Maintain a linked list of "so" information. */
struct so_stuff
{
  struct so_stuff *next, **last;
  DWORD load_addr;
  char name[0];
}
solib_start, *solib_end;

d638 2
a639 2
void
solib_symbols_add (char *name, CORE_ADDR load_addr)
d653 1
a653 1
  safe_symbol_file_add (name, 0, &section_addrs, 0, OBJF_SHARED);
d785 2
d928 2
a929 2
      handle_exception (ourstatus);
      retval = current_event.dwThreadId;
d1504 1
a1504 1
  solib_symbols_add (dll_name, (CORE_ADDR) base_addr + 0x1000);
d1647 1
a1647 1
child_solib_add (char *filename ATTRIBUTE_UNUSED, int from_tty ATTRIBUTE_UNUSED, struct target_ops *target)
d1657 1
a1657 1
	solib_symbols_add (solib_end->name, solib_end->load_addr);
@


1.27
log
@Phase 1 of the ptid_t changes.
@
text
@d871 1
d901 1
d1212 2
@


1.27.4.1
log
@* win32-nat.c (get_child_debug_event): Close file handles created after process
creation and DLL load.
(child_create_inferior): Close unneeded process/thread handle after thread
creation.
@
text
@a870 1
      CloseHandle (current_event.u.CreateProcessInfo.hFile);
a899 1
      CloseHandle (current_event.u.LoadDll.hFile);
a1209 2
  CloseHandle (pi.hThread);
  CloseHandle (pi.hProcess);
@


1.27.4.2
log
@* config/i386/tm-cygwin.h: include tm-i386.h instead of tm-i386v.h.  This fixes
errors in "long long" handling for 'finish' and 'return' commands.
* win32-nat.c (safe_symbol_file_add_stub): Avoid adding a shared library if it
has already been loaded.
(safe_symbol_file_add_cleanup): Don't mess with stderr or we won't see any
error messages.
(safe_symbol_file_add): Ditto.
(solib_symbols_add): Make static.  Accept 'from_tty' parameter.  Pass it to
safe_symbol_file_add.
(core_dll_symbols_add): Accomodate extra solib_symbols_add parameter.
(child_solib_add): Ditto.
* win32-nat.c (handle_exception): Don't print "first chance" exceptions.
(get_child_debug_event): Continue from exceptions if !handle_exception.
@
text
@a437 9
/* Maintain a linked list of "so" information. */
struct so_stuff
{
  struct so_stuff *next, **last;
  DWORD load_addr;
  char name[0];
}
solib_start, *solib_end;

a443 5
  struct so_stuff *so = solib_start.next;

  while ((so = so->next))
    if (strcasecmp (so->name, p->name) == 0)
      return 0;
d456 1
a456 1
  /* ui_file_delete (gdb_stderr); */
d458 1
a458 1
  /* gdb_stderr = sp->err; */
d478 1
a478 1
  /* gdb_stderr = ui_file_new (); */
d491 9
d633 2
a634 2
static void
solib_symbols_add (char *name, int from_tty, CORE_ADDR load_addr)
d648 1
a648 1
  safe_symbol_file_add (name, from_tty, 0, 0, OBJF_SHARED);
a779 2
      if (current_event.u.Exception.dwFirstChance)
	return 0;
d921 2
a922 2
      if (handle_exception (ourstatus))
	retval = current_event.dwThreadId;
d1497 1
a1497 1
  solib_symbols_add (dll_name, 0, (CORE_ADDR) base_addr + 0x1000);
d1640 1
a1640 1
child_solib_add (char *filename ATTRIBUTE_UNUSED, int from_tty, struct target_ops *target)
d1650 1
a1650 1
	solib_symbols_add (solib_end->name, from_tty, solib_end->load_addr);
@


1.27.4.3
log
@* win32-nat.c (safe_symbol_file_add_stub): Properly initialize linked list
pointer to beginning rather than one beyond beginning.
@
text
@d453 1
a453 1
  struct so_stuff *so = &solib_start;
@


1.27.4.4
log
@* win32-nat.c (safe_symbol_file_add_stub): Improve logic for avoiding load of
already loaded DLL.
(register_loaded_dll): Convert loaded DLL name to "posix" format or it will
confuse subsequent opening of the filename due to dos paths.
(dll_symbol_command): Pass from_tty parameter to safe_symbol_file_add.
@
text
@d443 3
a445 3
  int loaded;
  char name[1];
} solib_start, *solib_end;
d456 1
a456 1
    if (so->loaded && strcasecmp (so->name, p->name) == 0)
d512 1
a512 4
  char ppath[MAX_PATH + 1];
  cygwin_conv_to_posix_path (name, ppath);
  so = (struct so_stuff *) xmalloc (sizeof (struct so_stuff) + strlen (ppath) + 8 + 1);
  so->loaded = 0;
d514 1
a514 1
  strcpy (so->name, ppath);
d653 1
a653 1
  safe_symbol_file_add (name, from_tty, NULL, 0, OBJF_SHARED);
d660 1
a660 1
dll_symbol_command (char *args, int from_tty)
d677 1
a677 1
  safe_symbol_file_add (args, from_tty, NULL, 0, OBJF_SHARED | OBJF_USERLOADED);
@


1.27.4.5
log
@* win32-nat.c (handle_load_dll): Avoid strlwr'ing loaded DLLs or cygwin may not
be able to read them in certain situations.
@
text
@d603 2
@


1.26
log
@2001-03-17  Michael Chastain  <chastain@@redhat.com>

	* win32-nat.c (child_attach): check args for NULL before passing
	to strtoul.  This fixes PR gdb/43.
@
text
@d82 1
a82 1
static int win32_child_thread_alive (int);
d236 1
a236 1
  add_thread (id);
d265 2
a266 2
    printf_unfiltered ("[Deleting %s]\n", target_pid_to_str (id));
  delete_thread (id);
d316 1
a316 1
  current_thread = thread_rec (inferior_pid, TRUE);
d336 1
a336 1
  current_thread = thread_rec (inferior_pid, TRUE);
d852 2
a853 1
			   target_pid_to_str (current_event.dwThreadId));
d946 1
a946 1
      inferior_pid = retval;
d954 2
a955 2
static int
child_wait (int pid, struct target_waitstatus *ourstatus)
d957 2
d969 1
a969 1
	return retval;
d1038 1
a1038 1
			   target_pid_to_str (pid));
d1041 1
a1041 1
			   target_pid_to_str (pid));
d1059 1
a1059 1
			 target_pid_to_str (inferior_pid));
d1062 1
a1062 1
  inferior_pid = 0;
d1072 1
a1072 1
      attach_flag ? "attached" : "child", target_pid_to_str (inferior_pid));
d1082 1
a1082 1
/* Start an inferior win32 child process and sets inferior_pid to its pid.
d1282 1
a1282 1
child_resume (int pid, int step, enum target_signal sig)
d1287 1
d1333 2
a1334 1
  DEBUG_EVENTS (("gdb: child_close, inferior_pid=%d\n", inferior_pid));
d1445 1
a1445 1
win32_child_thread_alive (int pid)
d1447 2
d1455 1
a1455 1
cygwin_pid_to_str (int pid)
d1458 2
@


1.25
log
@Update/correct copyright notices.
@
text
@d1018 1
a1018 1
  DWORD pid = strtoul (args, 0, 0);
d1023 1
@


1.24
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 2
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001 Free Software
   Foundation, Inc.
@


1.23
log
@	* demangle.c (demangling_style_names): New variable.
	(_initialize_demangler): Fill demangling_style_names with the
	names of known demangling styles from libiberty_demanglers[].  Use
	add_set_enum_cmd instead of add_set_cmd, to get completion on
	demangling style names.

	* proc-api.c (_initialize_proc_api): Make `procfs-file' use
	file-name completion.

	* remote-rdi.c (_initialize_remote_rdi): Ditto for `rdilogfile'.

	* solib.c (_initialize_solib): Ditto for `solib-search-path' and
	`solib-absolute-prefix'.

	* tracepoint.c (_initialize_tracepoint): Ditto for
	`save-tracepoints'.

	* win32-nat.c (_initialize_inftarg): Ditto for `dll-symbols'.

	* cli/cli-cmds.c (init_cli_cmds): Make `shell' and `make' use
	file-name completion.

	* infcmd.c (_initialize_infcmd): Make the following commands use
	the file-name completer: `tty', `args', `path', `paths', and
	`run'.
@
text
@d2 2
a3 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
d21 1
a21 2
   Boston, MA 02111-1307, USA.
 */
d34 1
@


1.22
log
@Fix spacing.
@
text
@d33 1
d1381 2
d1385 3
a1387 2
  add_com ("dll-symbols", class_files, dll_symbol_command,
	   "Load dll library symbols from FILE.");
@


1.21
log
@* win32-nat.c: Change PTR to void * throughout.
@
text
@d1231 1
a1231 1
		   int write,  struct mem_attrib *mem ATTRIBUTE_UNUSED,
@


1.20
log
@* win32-nat.c (child_xfer_memory): Add missing argument required by 2001-01-23
change.
@
text
@d517 1
a517 1
handle_load_dll (PTR dummy ATTRIBUTE_UNUSED)
d1231 1
a1231 1
		   int write, struct mem_attrib *mem ATTRIBUTE_UNUSED,
d1492 1
a1492 1
map_single_dll_code_section (bfd * abfd, asection * sect, PTR obj)
d1557 1
a1557 1
      bfd_map_over_sections (dll_bfd, &map_single_dll_code_section, (PTR) (&map_args));
d1564 1
a1564 1
core_section_load_dll_symbols (bfd * abfd, asection * sect, PTR obj)
@


1.19
log
@* win32-nat.c (_initialize_core_win32): Prototype correctly.
@
text
@d1231 2
a1232 1
		   int write, struct target_ops *target ATTRIBUTE_UNUSED)
@


1.18
log
@Replace free() with xfree().
@
text
@d1660 1
a1660 1
_initialize_core_win32 ()
@


1.17
log
@* win32-nat.c (dll_code_sections_add): strdup -> xstrdup.
@
text
@d252 1
a252 1
      free (here);
d276 1
a276 1
      free (here);
d622 1
a622 1
      free (so);
d718 1
a718 1
  free (s);
d1613 1
a1613 1
    free (buf);
d1615 1
a1615 1
    free (dll_name);
@


1.16
log
@Protoization.
@
text
@d1543 1
a1543 1
  name = strdup (dll_name);
@


1.15
log
@* win32-nat.c (dll_symbol_command): Tack a .dll on the end of a supplied
argument if it is missing an extension.

* corelow.c: Define O_BINARY if it isn't defined.
(core_open): Open core file in binary mode.
* config/i386/tm-cygwin.h (child_clear_solibs): Rename from child_clear_solib.
* config/i386/cygwin.mh: Add dependency from corelow.o.
* win32-nat.c (register_loaded_dll): New function.  Add dll to the list of
currently loaded dlls.
(handle_load_dll): Use register_loaded_dll.
(child_solib_add): Distinguish between active process and core targets.
(solib_symbols_add): Load symbols from loaded dll.
(core_dll_symbols_add): New function.  Load symbols from dll referenced in
core.
(core_section_load_dll_symbols): New function.
(dll_code_sections_add): New function.
(map_single_dll_code_section): New function.
(fetch_elf_core_registers): New function.
(_initialize_core_win32): New function.
@
text
@a465 1

@


1.14
log
@* win32-nat.c: Perform various gcc warning cleanups.
(safe_symbol_file_add_cleanup): Reset stdout to saved stdout, not stderr.
(dll_symbol_command): Pass OBJF_USERLOADED to safe_symbol_file_add.
(get_child_debug_event): Always reset last_sig.  Always reset inferior pid
appropriately.
(do_initial_child_stuff): New function.  Called when attaching or starting a
new inferior process.
(child_attach): Use do_initial_child_stuff.
(child_create_inferior): Ditto.
* config/i386/cygwin.mh (NAT_FILE): Set to modern location.
* config/i386/tm-cygwin.h: Define ATTACH_NO_WAIT.
@
text
@d58 4
a61 4
{
  FLAG_TRACE_BIT = 0x100,
  CONTEXT_DEBUGGER = (CONTEXT_FULL | CONTEXT_FLOATING_POINT)
};
d63 2
d96 2
a97 1
  } thread_info;
d294 1
a294 1
      l = *((long *)context_offset) & 0xffff;
d299 1
a299 1
      l = (*((long *)context_offset) >> 16) & ((1 << 11) - 1);
a337 1
#include <psapi.h>
d340 3
a342 3
static BOOL  WINAPI (*psapi_EnumProcessModules)(HANDLE, HMODULE*, DWORD, LPDWORD)= NULL;
static BOOL  WINAPI (*psapi_GetModuleInformation) (HANDLE, HMODULE, LPMODULEINFO, DWORD)= NULL;
static DWORD WINAPI (*psapi_GetModuleFileNameExA) (HANDLE, HMODULE, LPSTR, DWORD)= NULL;
d344 2
a345 1
int psapi_get_dll_name (DWORD BaseAddress, char *dll_name_ret)
d350 2
a351 2
  HMODULE dh_buf [ 1 ];
  HMODULE* DllHandle = dh_buf;
d356 3
a358 3
       psapi_EnumProcessModules   == NULL ||
       psapi_GetModuleInformation == NULL ||
       psapi_GetModuleFileNameExA == NULL)
d360 2
a361 1
      if (psapi_loaded)goto failed;
d365 5
a369 5
        {
          /* printf_unfiltered ("error loading psapi.dll: %u", GetLastError ());*/
          goto failed;
        }
      psapi_EnumProcessModules   = GetProcAddress (psapi_module_handle, "EnumProcessModules" );
d372 4
a375 4
							    "GetModuleFileNameExA");
      if (psapi_EnumProcessModules   == NULL ||
           psapi_GetModuleInformation == NULL ||
           psapi_GetModuleFileNameExA == NULL)
d381 3
a383 3
				     DllHandle,
				     sizeof (HMODULE),
				     &cbNeeded);
d388 1
a388 1
  DllHandle = (HMODULE*) alloca (cbNeeded);
d393 3
a395 3
				     DllHandle,
				     cbNeeded,
				     &cbNeeded);
d402 3
a404 3
					     DllHandle [i],
					     &mi,
					     sizeof (mi)))
d408 3
a410 3
					    DllHandle [i],
					    dll_name_ret,
					    MAX_PATH);
d451 1
a451 1
# define sp ((struct safe_symbol_file_add_args *)p)
d458 1
a458 1
# undef sp
d496 2
a497 1
} solib_start, *solib_end;
d502 13
a523 1
  struct so_stuff *so;
d531 1
a531 1
    dll_buf[0] = dll_buf[sizeof(dll_buf) - 1] = '\0';
d599 1
a599 8
  so = (struct so_stuff *) xmalloc (sizeof (struct so_stuff) +  strlen (dll_name) + 8 + 2);
  so->load_addr = (DWORD) event->lpBaseOfDll + 0x1000;
  strcpy (so->name, dll_name);

  solib_end->next = so;
  solib_end = so;
  so->next = NULL;

d611 1
a611 1
  return !solib_end || !solib_end->name[0]? NULL : solib_end->name;
d633 1
a633 1
child_solib_add (char *filename ATTRIBUTE_UNUSED, int from_tty ATTRIBUTE_UNUSED, struct target_ops *t ATTRIBUTE_UNUSED)
d641 1
a641 1
  if (!solib_end || !solib_end->name[0])
d646 2
a647 2
  section_addrs.other[0].addr = solib_end->load_addr;
  safe_symbol_file_add (solib_end->name, 0, &section_addrs, 0, OBJF_SHARED);
d656 1
d658 1
a658 1
  
d662 9
d672 1
a672 1
} 
d738 1
a738 1
	       (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d747 1
a747 1
	       (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d753 1
a753 1
	       (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d758 1
a758 1
	       (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d763 1
a763 1
	       (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d769 1
a769 1
	       (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d774 1
a774 1
	       (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d781 1
a781 1
		(DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress);
d926 1
a926 1
      if (handle_output_debug_string ( ourstatus))
d943 1
a943 1
      current_thread = th ?: thread_rec (current_event.dwThreadId, TRUE);
d1207 1
a1207 1
  /* child_continue (DBG_CONTINUE, -1);*/
d1280 1
a1280 1
			  DBG_EXCEPTION_NOT_HANDLED : DBG_CONTINUE;
d1383 1
a1383 1
           "Load dll library symbols from FILE.");
d1385 1
d1389 4
a1392 4
		  (char *) &new_console,
		  "Set creation of new console when creating child process.",
		  &setlist),
     &showlist);
d1395 4
a1398 4
		  (char *) &new_group,
		  "Set creation of new group when creating child process.",
		  &setlist),
     &showlist);
d1401 4
a1404 4
		  (char *) &debug_exec,
		  "Set whether to display execution in child process.",
		  &setlist),
     &showlist);
d1407 4
a1410 4
		  (char *) &debug_events,
		  "Set whether to display kernel events in child process.",
		  &setlist),
     &showlist);
d1413 4
a1416 4
		  (char *) &debug_memory,
		  "Set whether to display memory accesses in child process.",
		  &setlist),
     &showlist);
d1419 4
a1422 4
		  (char *) &debug_exceptions,
		  "Set whether to display kernel exceptions in child process.",
		  &setlist),
     &showlist);
d1450 214
@


1.13
log
@Protoization.
@
text
@d57 5
a61 2
#define FLAG_TRACE_BIT 0x100
#define CONTEXT_DEBUGGER (CONTEXT_FULL | CONTEXT_FLOATING_POINT)
d447 1
a447 1
#define sp ((struct safe_symbol_file_add_args *)p)
d453 2
a454 1
  gdb_stdout = sp->err;
d506 1
a506 1
  struct so_stuff *so, *solast;
a507 1
  DWORD dll_base = 0;
d599 1
a599 1
child_solib_loaded_library_pathname (int pid)
d623 1
a623 1
child_solib_add (char *filename, int from_tty, struct target_ops *t)
d644 1
a644 1
dll_symbol_command (char *args, int from_tty)
a645 2
  struct section_addr_info section_addrs;

d651 1
a651 1
  safe_symbol_file_add (args, 0, NULL, 0, OBJF_SHARED);
d656 1
a656 1
info_dll_command (char *ignore, int from_tty)
a713 2
  last_sig = 0;

a801 1
  int breakout = 0;
d808 2
d851 1
a851 1
      main_thread_id = inferior_pid = current_event.dwThreadId;
d853 1
d856 2
a857 1
      th = child_add_thread (inferior_pid,
d859 1
a859 1
      retval = ourstatus->value.related_pid = current_event.dwProcessId;
d870 1
a870 1
      retval = current_event.dwProcessId;
d882 1
a882 1
      retval = current_event.dwProcessId;
d907 1
a907 1
	retval = current_event.dwProcessId;
d909 1
d922 4
a925 1
    current_thread = th ?: thread_rec (current_event.dwThreadId, TRUE);
d959 32
d997 1
d1002 1
a1002 3
  current_event.dwProcessId = strtoul (args, 0, 0);

  ok = DebugActiveProcess (current_event.dwProcessId);
a1006 6
  exception_count = 0;
  event_count = 0;

  child_init_thread_list ();
  child_clear_solibs ();

d1013 1
a1013 1
			   target_pid_to_str (current_event.dwProcessId));
d1016 1
a1016 1
			   target_pid_to_str (current_event.dwProcessId));
d1021 2
a1022 1
  push_target (&child_ops);
a1071 1
  struct target_waitstatus dummy;
a1074 1
  extern int stop_after_trap;
d1185 1
a1185 26
  exception_count = 0;
  event_count = 0;

  current_process_handle = pi.hProcess;
  current_event.dwProcessId = pi.dwProcessId;
  memset (&current_event, 0, sizeof (current_event));
  inferior_pid = current_event.dwThreadId = pi.dwThreadId;
  push_target (&child_ops);
  child_init_thread_list ();
  child_clear_solibs ();
  clear_proceed_status ();
  init_wait_for_inferior ();
  target_terminal_init ();
  target_terminal_inferior ();
  last_sig = 0;

  while (1)
    {
      stop_after_trap = 1;
      wait_for_inferior ();
      if (stop_signal != TARGET_SIGNAL_TRAP)
	resume (0, stop_signal);
      else
	break;
    }
  stop_after_trap = 0;
d1304 1
a1304 1
child_close (void)
@


1.12
log
@* win32-nat.c (safe_symbol_file_add_args): Store old gdb_stderr and gdb_stdout
here.
(safe_symbol_file_add_stub): Redirect gdb_stdout as well as stderr.
(safe_symbol_file_add_cleanup): Restore gdb_stdout.
(info_dll_command): Use the pager for displaying DLLs since there are often
quite a few.
@
text
@d235 1
a235 1
child_init_thread_list ()
d956 1
a956 3
child_attach (args, from_tty)
     char *args;
     int from_tty;
d1031 1
a1031 4
child_create_inferior (exec_file, allargs, env)
     char *exec_file;
     char *allargs;
     char **env;
d1187 1
a1187 1
child_mourn_inferior ()
d1198 1
a1198 1
child_stop ()
d1287 1
a1287 1
child_prepare_to_store ()
d1293 1
a1293 1
child_can_run ()
d1299 1
a1299 1
child_close ()
d1353 1
a1353 1
_initialize_inftarg ()
@


1.11
log
@Eliminate PARAMS from function pointer declarations.
@
text
@d425 1
d442 1
a442 1
safe_symbol_file_add_cleanup (void *gdb_stderrv)
d444 1
d446 1
d448 3
a450 1
  gdb_stderr = (struct ui_file *)gdb_stderrv;
d463 1
a463 1
  cleanup = make_cleanup (safe_symbol_file_add_cleanup, gdb_stderr);
d465 2
d468 1
d470 1
d664 1
a664 1
    printf_unfiltered ("%*s  %08lx\n", -max_dll_name_len, so->name, so->load_addr);
@


1.10
log
@* win32-nat.c (safe_symbol_file_add_cleanup): Ensure that gdb_stderr is flushed
before deleting and restoring it.
(safe_symbol_file_add): Ensure that gdb_stderr is flushed before reassigning
it.
(handle_load_dll): Split into two functions so that WFI can handle shared
library events.
(child_solib_loaded_library_pathname): New function.
(child_clear_solibs): New function.  Clears shared library list.
(child_solib_add): New function.  Adds shared library symbols.
(dll_symbol_command): New function.  Handles "dll-symbol" command.
(info_dll_command): New function.  Handles info "sharedlibrary" command.
(handle_exceptions): Eliminate 'ignore_trap' argument.
(get_child_debug_event): Eliminate two arguments.  Return "pid" when
appropriate.  Break out on most events to allow WFI to handle stuff.
(child_wait): Accomodate get_child_debug_event changes.
(child_attach): Clear thread list and list of loaded dlls.
(child_create_inferior): Clear list of loaded dlls.  Use wait_for_inferior in a
loop to look for first "trap".
(child_resume): Avoid accessing a possibly-freed thread pointer.
(_initialize_inftarg): Add "dll-symbols", "sharedlibrary", and "info
dll", and "info sharedlibrary" commands.
* config/i386/tm-cygwin.h: Add some shared library (aka DLL) hooks.
@
text
@d51 1
a51 1
extern int (*ui_loop_hook) PARAMS ((int signo));
@


1.9
log
@* win32-nat.c: Fix up gcc warnings throughout.
(handle_load_dll): Change DLL name to lower case.
(handle_exception): Add a second argument indicating whether a breakpoint
should be ignored.  Return a 0 if the breakpoint was ignored.
(get_child_debug_event): Pass argument to handle_exception to control whether a
breakpoint should be ignored.
(child_create_inferior): Use modern cygwin API.  Explicitly clear last_sig.
Pass FIRST_EXCEPTION to get_child_debug_event for detection of first
breakpoint.

* configure.in: Eliminate unneeded WINDRES/DLLTOOL tests left over after last change.
* configure: Regenerate.
@
text
@a60 2
#define FIRST_EXCEPTION 0xffffffff

d416 2
d428 2
d439 1
d443 1
d448 1
d460 1
d473 11
a485 1

d493 5
a497 2
  char *p, *dll_name = NULL;
  struct section_addr_info section_addrs;
a498 1
  memset (&section_addrs, 0, sizeof (section_addrs));
d570 45
d619 4
d624 32
a655 3
  section_addrs.other[0].addr = (int) event->lpBaseOfDll + 0x1000;
  safe_symbol_file_add (dll_name, 0, &section_addrs, 0, OBJF_SHARED);
  printf_unfiltered ("%lx:%s\n", (DWORD) event->lpBaseOfDll, dll_name);
d657 1
a657 1
  return 1;
d694 1
a694 1
handle_exception (struct target_waitstatus *ourstatus, int ignore_trap)
a698 3
  if (ignore_trap && code == EXCEPTION_BREAKPOINT)
    return 0;

d792 1
a792 2
get_child_debug_event (int pid ATTRIBUTE_UNUSED, struct target_waitstatus *ourstatus,
		       DWORD target_event_code, int *retval)
d799 1
a800 1
  *retval = 0;
d808 1
a808 1
  breakout = event_code == target_event_code;
d823 1
d844 2
d848 1
d859 1
a859 2
      *retval = current_event.dwProcessId;
      breakout = 1;
d869 3
d886 2
a887 4
      if (handle_exception (ourstatus, target_event_code == FIRST_EXCEPTION))
	*retval = current_event.dwThreadId;
      else
	breakout = -1;
d895 2
a896 1
      handle_output_debug_string ( ourstatus);
d907 3
a909 1
  if (breakout > 0)
a910 2
  else if (!breakout)
    CHECK (child_continue (continue_status, -1));
d913 1
a913 1
  return breakout;
a919 2
  int retval;

d927 7
a933 5
    if (get_child_debug_event (pid, ourstatus, EXCEPTION_DEBUG_EVENT, &retval))
      return retval;
    else
      {
	int detach = 0;
d935 2
a936 2
	if (ui_loop_hook != NULL)
	  detach = ui_loop_hook (0);
d938 4
a941 3
	if (detach)
	  child_kill_inferior ();
      }
d966 3
d1040 1
d1043 1
a1043 3
    {
      error ("No executable specified, use `target exec'.\n");
    }
d1160 2
a1162 1
  clear_proceed_status ();
d1167 10
a1176 4
  /* Run until process and threads are loaded */
  while (!get_child_debug_event (inferior_pid, &dummy,
				 FIRST_EXCEPTION, &ret))
    continue;
d1260 1
a1260 1
  if (step)
d1262 6
a1267 6
#ifdef i386
      /* Single step by setting t bit */
      child_fetch_inferior_registers (PS_REGNUM);
      th->context.EFlags |= FLAG_TRACE_BIT;
#endif
    }
d1269 5
a1273 4
  if (th->context.ContextFlags)
    {
      CHECK (SetThreadContext (th->h, &th->context));
      th->context.ContextFlags = 0;
d1353 6
a1358 2
  add_show_from_set
    (add_set_cmd ("new-console", class_support, var_boolean,
d1364 1
a1364 2
  add_show_from_set
    (add_set_cmd ("new-group", class_support, var_boolean,
d1370 1
a1370 2
  add_show_from_set
    (add_set_cmd ("debugexec", class_support, var_boolean,
d1376 1
a1376 2
  add_show_from_set
    (add_set_cmd ("debugevents", class_support, var_boolean,
d1382 1
a1382 2
  add_show_from_set
    (add_set_cmd ("debugmemory", class_support, var_boolean,
d1388 1
a1388 2
  add_show_from_set
    (add_set_cmd ("debugexceptions", class_support, var_boolean,
d1390 1
a1390 1
	       "Set whether to display kernel exceptions in child process.",
d1393 3
@


1.8
log
@PARAMS removal.
@
text
@a36 4

#ifdef _MSC_VER
#include "windefs.h"
#else /* other WIN32 compiler */
d39 1
a39 1
#endif
d61 2
d67 1
a67 1
#define CHECK(x) 	check (x, __FILE__,__LINE__)
a81 1

d95 1
a95 1
static thread_info thread_head = {NULL};
a103 2
static int ignore_first_first_chance = 0; /* True if we should ignore the
					     first first chance exception that we get. */
d280 1
a280 1
    printf_filtered ("error return %s:%d was %d\n", file, line, GetLastError ());
d394 1
a394 1
  for (i = 0; i < cbNeeded / sizeof (HMODULE); i++)
d407 1
a407 1
	error ("Error getting dll name: %u\n", GetLastError ()); 
d471 1
a471 1
handle_load_dll (PTR dummy)
a477 2
  struct objfile *objfile;
  MEMORY_BASIC_INFORMATION minfo;
d493 1
a493 1
      int size = event->fUnicode ? sizeof (WCHAR) : sizeof (char);
d547 2
d559 1
a559 1
  printf_unfiltered ("%x:%s\n", event->lpBaseOfDll, dll_name);
d581 1
a581 1
	warning (s);
d598 1
a598 1
handle_exception (struct target_waitstatus *ourstatus)
a599 2
  int i;
  int done = 0;
d601 4
a604 1
  int fc = ignore_first_first_chance;
a607 2
  ignore_first_first_chance = 0;

d613 1
a613 1
  switch (current_event.u.Exception.ExceptionRecord.ExceptionCode)
d616 2
a617 2
      DEBUG_EXCEPT (("gdb: Target exception ACCESS_VIOLATION at 0x%08x\n",
	       current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d625 2
a626 2
      DEBUG_EXCEPT (("gdb: Target exception STACK_OVERFLOW at 0x%08x\n",
	       current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d628 1
d631 2
a632 2
      DEBUG_EXCEPT (("gdb: Target exception STACK_OVERFLOW at 0x%08x\n",
	       current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d636 2
a637 8
      if (fc && current_event.u.Exception.dwFirstChance &&
	  ((DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress & 0xc0000000))
	{
	  last_sig = -1;
	  return 0;
	}
      DEBUG_EXCEPT (("gdb: Target exception BREAKPOINT at 0x%08x\n",
	       current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d641 2
a642 2
      DEBUG_EXCEPT (("gdb: Target exception CONTROL_C at 0x%08x\n",
	       current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d647 2
a648 2
      DEBUG_EXCEPT (("gdb: Target exception SINGLE_STEP at 0x%08x\n",
	       current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d652 2
a653 2
      DEBUG_EXCEPT (("gdb: Target exception SINGLE_ILL at 0x%08x\n",
	       current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d658 1
a658 1
      printf_unfiltered ("gdb: unknown target exception 0x%08x at 0x%08x\n",
d660 1
a660 1
		current_event.u.Exception.ExceptionRecord.ExceptionAddress);
d677 1
a677 1
  DEBUG_EVENTS (("ContinueDebugEvent (cpid=%d, ctid=%d, DBG_CONTINUE);\n",
d685 1
a685 1
      if (((id == -1) || (id == th->id)) && th->suspend_count)
d699 1
a699 1
get_child_debug_event (int pid, struct target_waitstatus *ourstatus,
d708 1
d710 1
a710 4
    {
      *retval = 0;
      goto out;
    }
a713 1
  *retval = 0;
d788 1
a788 1
      if (handle_exception (ourstatus))
d791 1
a791 5
	{
	  if (last_sig >= 0)
	    continue_status = DBG_EXCEPTION_NOT_HANDLED;
	  breakout = 0;
	}
d802 4
a805 4
      printf_unfiltered ("gdb: kernel event for pid=%d tid=%d\n",
			 current_event.dwProcessId,
			 current_event.dwThreadId);
      printf_unfiltered ("                 unknown event code %d\n",
d810 1
a810 1
  if (breakout)
d812 1
a812 1
  else
a822 1
  DWORD event_code;
d886 1
a886 3
child_detach (args, from_tty)
     char *args;
     int from_tty;
d904 1
a904 2
child_files_info (ignore)
     struct target_ops *ignore;
d912 1
a912 3
child_open (arg, from_tty)
     char *arg;
     int from_tty;
a938 1
  DWORD event_code;
d948 1
a948 1
  cygwin32_conv_to_win32_path (exec_file, real_path);
d994 1
a994 1
		if (cygwin32_posix_path_list_p (env[i] + len))
d996 1
a996 1
		    + cygwin32_posix_to_win32_path_list_buf_size (env[i] + len);
d1018 1
a1018 1
		if (cygwin32_posix_path_list_p (env[i] + len))
d1021 1
a1021 1
		    cygwin32_posix_to_win32_path_list (env[i] + len, temp + len);
d1064 1
a1064 2

  ignore_first_first_chance = 1;
d1068 1
a1068 1
				 CREATE_PROCESS_DEBUG_EVENT, &ret))
d1096 1
a1096 1
		   int write, struct target_ops *target)
d1101 2
a1102 2
      DEBUG_MEM (("gdb: write target memory, %d bytes at 0x%08x\n",
		  len, memaddr));
d1109 2
a1110 2
      DEBUG_MEM (("gdb: read target memory, %d bytes at 0x%08x\n",
		  len, memaddr));
d1305 1
a1305 1
  if (pid == current_event.dwProcessId)
d1308 1
a1308 1
    sprintf (buf, "thread %d.0x%x", current_event.dwProcessId, pid);
@


1.7
log
@2000-04-21  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* win32-nat.c  (handle_load_dll): Don't treat .text as a special
 	section anymore.
	* somread.c (som_symfile_offsets): Ditto.
	* somsolib.c (som_solib_add_solib_objfile): Ditto.
@
text
@d78 3
a80 3
static void child_stop PARAMS ((void));
static int win32_child_thread_alive PARAMS ((int));
void child_kill_inferior PARAMS ((void));
@


1.6
log
@* win32-nat.c (thread_rec): Be more defensive about suspending already
suspended threads.
(safe_symbol_file_add_stub): New function.
(safe_symbole_file_add_cleanup): New function.
(safe_symbol_file_add): New function.
(handle_load_dll): Use wrapper to add DLL symbol information to avoid bogus
errors from non-stabs DLLs.
(handle_exception): Add work around for detection of first exception breakpoint
which does not seem to occur on W2K.  Detect more "signals" that can be
effectively passed to the debuggee.  Reorganize to eliminate continue_status
global.
(child_continue): Reorganize to eliminate continue_status global.
(child_wait): Ditto.
(child_resume): Ditto.
(get_child_debug_event): Ditto.  Recognize when an a breakpoint exception
should be ignored.  Change method for signalling when an important event has
occured to the caller.
(child_create_inferior): Use new method for noticing when get_child_debug_event
has found something interesting.
@
text
@d561 2
a562 1
  section_addrs.text_addr = (int) event->lpBaseOfDll + 0x1000;
@


1.5
log
@* win32-nat.c: Back out special frame walking code.  It was broken.
(handle_exception): Correctly identify an illegal instruction.
* config/tm-cygwin.h: Eliminate special frame handling.  Just use normal i386
handling.
@
text
@d82 3
a99 3
/* The saved state for a continue after breaking back to gdb. */
static DWORD continue_status;

d107 2
d206 1
a206 1
	    if (get_context > 0)
d423 49
d559 1
a559 3
     of the file header and the section alignment.

     FIXME: Is this the real reason that we need the 0x1000 ? */
a560 1
  printf_unfiltered ("%x:%s", event->lpBaseOfDll, dll_name);
d562 2
a563 2
  symbol_file_add (dll_name, 0, &section_addrs, 0, OBJF_SHARED);
  printf_unfiltered ("\n");
d607 1
d611 2
d616 2
d624 1
a624 1
      continue_status = DBG_EXCEPTION_NOT_HANDLED;
a632 1
      continue_status = DBG_EXCEPTION_NOT_HANDLED;
a637 1
      continue_status = DBG_EXCEPTION_NOT_HANDLED;
d640 6
d654 1
a654 1
      continue_status = DBG_EXCEPTION_NOT_HANDLED;
d665 1
a667 8
      /* This may be a structured exception handling exception.  In
         that case, we want to let the program try to handle it, and
         only break if we see the exception a second time.
      if (current_event.u.Exception.dwFirstChance)

	return 0;
*/

a671 1
      continue_status = DBG_EXCEPTION_NOT_HANDLED;
d681 1
a681 1
child_continue (int id)
d705 3
d710 1
a710 1
		       DWORD *event_code, int *retval)
d712 1
d714 3
a716 1
  int breakout = 1;
d718 1
a718 1
  if (!(debug_event = WaitForDebugEvent (&current_event, 20)))
d720 1
a720 1
      breakout = *retval = *event_code = 0;
d728 4
a731 1
  switch (*event_code = current_event.dwDebugEventCode)
d735 3
a737 3
		    (unsigned) current_event.dwProcessId,
		    (unsigned) current_event.dwThreadId,
		    "CREATE_THREAD_DEBUG_EVENT"));
d739 2
a740 2
      child_add_thread (current_event.dwThreadId,
			current_event.u.CreateThread.hThread);
d743 1
a743 1
		      target_pid_to_str (current_event.dwThreadId));
d748 3
a750 3
		    (unsigned) current_event.dwProcessId,
		    (unsigned) current_event.dwThreadId,
		    "EXIT_THREAD_DEBUG_EVENT"));
d752 1
d757 3
a759 3
		    (unsigned) current_event.dwProcessId,
		    (unsigned) current_event.dwThreadId,
		    "CREATE_PROCESS_DEBUG_EVENT"));
d764 2
a765 2
      current_thread = child_add_thread (inferior_pid,
			 current_event.u.CreateProcessInfo.hThread);
d770 3
a772 3
		    (unsigned) current_event.dwProcessId,
		    (unsigned) current_event.dwThreadId,
		    "EXIT_PROCESS_DEBUG_EVENT"));
d777 2
a778 1
      goto out;
d782 4
a785 4
		    (unsigned) current_event.dwProcessId,
		    (unsigned) current_event.dwThreadId,
		    "LOAD_DLL_DEBUG_EVENT"));
      catch_errors (handle_load_dll, NULL, "", RETURN_MASK_ALL);
d791 4
a794 4
		    (unsigned) current_event.dwProcessId,
		    (unsigned) current_event.dwThreadId,
		    "UNLOAD_DLL_DEBUG_EVENT"));
      break;		/* FIXME: don't know what to do here */
d798 6
a803 4
		    (unsigned) current_event.dwProcessId,
		    (unsigned) current_event.dwThreadId,
		    "EXCEPTION_DEBUG_EVENT"));
      if (handle_exception (ourstatus))	/* sets continue_status */
d805 3
a807 2
	  *retval = current_event.dwThreadId;
	  goto out;
d811 1
a811 1
    case OUTPUT_DEBUG_STRING_EVENT:
d813 4
a816 8
		    (unsigned) current_event.dwProcessId,
		    (unsigned) current_event.dwThreadId,
		    "OUTPUT_DEBUG_STRING_EVENT"));
      if (handle_output_debug_string (ourstatus))
	{
	  *retval = main_thread_id;
	  goto out;
	}
d827 4
a830 3
  breakout = 0;
  CHECK (child_continue (-1));
  continue_status = 0;
a835 1

d850 5
a854 8
    {
      if (continue_status != 0)
	CHECK (child_continue (-1));
      if (get_child_debug_event (pid, ourstatus, &event_code, &retval))
	return retval;
      else
	{
	  int detach = 0;
d856 2
a857 2
	  if (ui_loop_hook != NULL)
	    detach = ui_loop_hook (0);
d859 3
a861 4
	  if (detach)
	    child_kill_inferior ();
	}
    }
d1089 2
d1092 3
a1094 6
  do
    get_child_debug_event (inferior_pid, &dummy, &event_code, &ret);
  while (event_code != EXCEPTION_DEBUG_EVENT);

  SymSetOptions (SYMOPT_DEFERRED_LOADS);
  SymInitialize (current_process_handle, NULL, TRUE);
d1096 1
d1103 1
a1103 2
  continue_status = DBG_CONTINUE;
  (void) child_continue (-1);
d1149 1
a1149 2
      continue_status = DBG_CONTINUE;
      if (!child_continue (-1))
a1166 1
  int i;
d1168 4
d1196 1
a1196 1
  child_continue (pid);
a1267 1
  struct cmd_list_element *c;
@


1.5.2.1
log
@* win32-nat.c (thread_rec): Be more defensive about suspending already
suspended threads.
(safe_symbol_file_add_stub): New function.
(safe_symbole_file_add_cleanup): New function.
(safe_symbol_file_add): New function.
(handle_load_dll): Use wrapper to add DLL symbol information to avoid bogus
errors from non-stabs DLLs.
(handle_exception): Add work around for detection of first exception breakpoint
which does not seem to occur on W2K.  Detect more "signals" that can be
effectively passed to the debuggee.  Reorganize to eliminate continue_status
global.
(child_continue): Reorganize to eliminate continue_status global.
(child_wait): Ditto.
(child_resume): Ditto.
(get_child_debug_event): Ditto.  Recognize when an a breakpoint exception
should be ignored.  Change method for signalling when an important event has
occured to the caller.
(child_create_inferior): Use new method for noticing when get_child_debug_event
has found something interesting.
@
text
@a81 3
static int last_sig = 0;	/* Set if a signal was received from the
				   debugged process */

d97 3
a106 2
static int ignore_first_first_chance = 0; /* True if we should ignore the
					     first first chance exception that we get. */
d204 1
a204 1
	    if (get_context > 0 && id != current_event.dwThreadId)
a420 49
struct safe_symbol_file_add_args
{
  char *name;
  int from_tty;
  struct section_addr_info *addrs;
  int mainline;
  int flags;
  struct objfile *ret;
};

static int
safe_symbol_file_add_stub (void *argv)
{
#define p ((struct safe_symbol_file_add_args *)argv)
  p->ret = symbol_file_add (p->name, p->from_tty, p->addrs, p->mainline, p->flags);
  return !!p->ret;
#undef p
}

static void
safe_symbol_file_add_cleanup (void *gdb_stderrv)
{
  ui_file_delete (gdb_stderr);
  gdb_stderr = (struct ui_file *)gdb_stderrv;
}

static struct objfile *
safe_symbol_file_add (char *name, int from_tty,
		      struct section_addr_info *addrs,
		      int mainline, int flags)

{
  struct safe_symbol_file_add_args p;
  struct cleanup *cleanup;

  cleanup = make_cleanup (safe_symbol_file_add_cleanup, gdb_stderr);

  gdb_stderr = ui_file_new ();
  p.name = name;
  p.from_tty = from_tty;
  p.addrs = addrs;
  p.mainline = mainline;
  p.flags = flags;
  catch_errors (safe_symbol_file_add_stub, &p, "", RETURN_MASK_ERROR);

  do_cleanups (cleanup);
  return p.ret;
}

d508 3
a510 1
     of the file header and the section alignment. */
d512 1
d514 2
a515 2
  safe_symbol_file_add (dll_name, 0, &section_addrs, 0, OBJF_SHARED);
  printf_unfiltered ("%x:%s\n", event->lpBaseOfDll, dll_name);
a558 1
  int fc = ignore_first_first_chance;
a561 2
  ignore_first_first_chance = 0;

a564 2
  last_sig = 0;

d571 1
a571 1
      last_sig = SIGSEGV;
d580 1
d586 1
a588 6
      if (fc && current_event.u.Exception.dwFirstChance &&
	  ((DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress & 0xc0000000))
	{
	  last_sig = -1;
	  return 0;
	}
d597 1
a597 1
      last_sig = SIGINT;	/* FIXME - should check pass state */
a607 1
      last_sig = SIGILL;
d610 8
d622 1
d632 1
a632 1
child_continue (DWORD continue_status, int id)
a655 3
/* Get the next event from the child.  Return 1 if the event requires
   handling by WFI (or whatever).
 */
d658 1
a658 1
		       DWORD target_event_code, int *retval)
a659 1
  int breakout = 0;
d661 1
a661 3
  DWORD continue_status, event_code;
  thread_info *th = NULL;
  static thread_info dummy_thread_info;
d663 1
a663 1
  if (!(debug_event = WaitForDebugEvent (&current_event, 1000)))
d665 1
a665 1
      *retval = 0;
d673 1
a673 4
  event_code = current_event.dwDebugEventCode;
  breakout = event_code == target_event_code;

  switch (event_code)
d677 3
a679 3
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "CREATE_THREAD_DEBUG_EVENT"));
d681 2
a682 2
      th = child_add_thread (current_event.dwThreadId,
			     current_event.u.CreateThread.hThread);
d685 1
a685 1
			   target_pid_to_str (current_event.dwThreadId));
d690 3
a692 3
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "EXIT_THREAD_DEBUG_EVENT"));
a693 1
      th = &dummy_thread_info;
d698 3
a700 3
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "CREATE_PROCESS_DEBUG_EVENT"));
d705 2
a706 2
      th = child_add_thread (inferior_pid,
			     current_event.u.CreateProcessInfo.hThread);
d711 3
a713 3
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "EXIT_PROCESS_DEBUG_EVENT"));
d718 1
a718 2
      breakout = 1;
      break;
d722 4
a725 4
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "LOAD_DLL_DEBUG_EVENT"));
      catch_errors (handle_load_dll, NULL, (char *) "", RETURN_MASK_ALL);
d731 4
a734 4
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "UNLOAD_DLL_DEBUG_EVENT"));
      break;			/* FIXME: don't know what to do here */
d738 4
a741 6
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "EXCEPTION_DEBUG_EVENT"));
      if (handle_exception (ourstatus))
	*retval = current_event.dwThreadId;
      else
d743 2
a744 3
	  if (last_sig >= 0)
	    continue_status = DBG_EXCEPTION_NOT_HANDLED;
	  breakout = 0;
d748 1
a748 1
    case OUTPUT_DEBUG_STRING_EVENT:	/* message from the kernel */
d750 8
a757 4
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "OUTPUT_DEBUG_STRING_EVENT"));
      handle_output_debug_string ( ourstatus);
d768 3
a770 4
  if (breakout)
    current_thread = th ?: thread_rec (current_event.dwThreadId, TRUE);
  else
    CHECK (child_continue (continue_status, -1));
d776 1
d791 8
a798 5
    if (get_child_debug_event (pid, ourstatus, EXCEPTION_DEBUG_EVENT, &retval))
      return retval;
    else
      {
	int detach = 0;
d800 2
a801 2
	if (ui_loop_hook != NULL)
	  detach = ui_loop_hook (0);
d803 4
a806 3
	if (detach)
	  child_kill_inferior ();
      }
d1034 4
a1037 1
  ignore_first_first_chance = 1;
d1039 2
a1040 4
  /* Run until process and threads are loaded */
  while (!get_child_debug_event (inferior_pid, &dummy,
				 CREATE_PROCESS_DEBUG_EVENT, &ret))
    continue;
a1041 1
  /* child_continue (DBG_CONTINUE, -1);*/
d1048 2
a1049 1
  (void) child_continue (DBG_CONTINUE, -1);
d1095 2
a1096 1
      if (!child_continue (DBG_CONTINUE, -1))
d1114 1
a1115 4
  DWORD continue_status = last_sig > 0 && last_sig < NSIG ?
			  DBG_EXCEPTION_NOT_HANDLED : DBG_CONTINUE;

  last_sig = 0;
d1140 1
a1140 1
  child_continue (continue_status, pid);
d1212 1
@


1.4
log
@* win32-nat.c: Remove unneeded header.
* wince.c: Ditto.
@
text
@d604 5
a1279 57
}

static LPVOID __stdcall
sfta(HANDLE h, DWORD d)
{
  return NULL;
}

static DWORD __stdcall
sgmb(HANDLE h, DWORD d)
{
#if 0
  return 4;
#else
  return SymGetModuleBase (h, d) ?: 4;
#endif
}

CORE_ADDR
child_frame_chain(struct frame_info *f)
{
  STACKFRAME *sf = (STACKFRAME *) f->extra_info;
  if (!StackWalk (IMAGE_FILE_MACHINE_I386, current_process_handle,
		  current_thread->h, sf, NULL, NULL, SymFunctionTableAccess, sgmb, NULL) ||
      !sf->AddrReturn.Offset)
    return 0;
  return sf->AddrFrame.Offset;
}

CORE_ADDR
child_frame_saved_pc(struct frame_info *f)
{
  STACKFRAME *sf = (STACKFRAME *) f->extra_info;
  return sf->AddrReturn.Offset;
}

void
child_init_frame(int leaf, struct frame_info *f)
{
  STACKFRAME *sf;

  if (f->next && f->next->extra_info)
    f->extra_info = f->next->extra_info;
  else if (f->prev && f->prev->extra_info)
    f->extra_info = f->prev->extra_info;
  else
    {
      sf = (STACKFRAME *) frame_obstack_alloc (sizeof (*sf));
      f->extra_info = (struct frame_extra_info *) sf;
      memset (sf, 0, sizeof(*sf));
      sf->AddrPC.Offset = f->pc;
      sf->AddrPC.Mode = AddrModeFlat;
      sf->AddrStack.Offset = current_thread->context.Esp;
      sf->AddrStack.Mode = AddrModeFlat;
      sf->AddrFrame.Offset = f->frame;
      sf->AddrFrame.Mode = AddrModeFlat;
    }
@


1.3
log
@Correct copyright.
@
text
@a30 1
#include "gdb_wait.h"
@


1.2
log
@Replace ../include/wait.h with gdb_wait.h.
@
text
@d2 2
a3 2
   Copyright 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
   Contributed by Cygnus Support.
@


1.1
log
@Initial revision
@
text
@d19 3
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
*/
d31 1
a31 1
#include "wait.h"
d43 1
d55 11
d81 1
a81 3

static int last_sig = 0;	/* Set if a signal was received from the
				   debugged process */
d86 9
a94 8
{
  struct thread_info_struct *next;
  DWORD id;
  HANDLE h;
  char *name;
  int suspend_count;
  CONTEXT context;
} thread_info;
d98 3
d107 1
a107 1
static DWORD main_thread_id;		/* Thread ID of the main thread */
d115 4
a118 4
static int new_group = 0;
static int debug_exec = 0;		/* show execution */
static int debug_events = 0;		/* show events from kernel */
static int debug_memory = 0;		/* show target memory accesses */
d137 32
a168 24
  context_offset(Eax),
  context_offset(Ecx),
  context_offset(Edx),
  context_offset(Ebx),
  context_offset(Esp),
  context_offset(Ebp),
  context_offset(Esi),
  context_offset(Edi),
  context_offset(Eip),
  context_offset(EFlags),
  context_offset(SegCs),
  context_offset(SegSs),
  context_offset(SegDs),
  context_offset(SegEs),
  context_offset(SegFs),
  context_offset(SegGs),
  context_offset(FloatSave.RegisterArea[0 * 10]),
  context_offset(FloatSave.RegisterArea[1 * 10]),
  context_offset(FloatSave.RegisterArea[2 * 10]),
  context_offset(FloatSave.RegisterArea[3 * 10]),
  context_offset(FloatSave.RegisterArea[4 * 10]),
  context_offset(FloatSave.RegisterArea[5 * 10]),
  context_offset(FloatSave.RegisterArea[6 * 10]),
  context_offset(FloatSave.RegisterArea[7 * 10]),
d171 2
d200 1
a200 1
  for (th = &thread_head; (th = th->next) != NULL; )
d221 1
a221 1
child_add_thread(DWORD id, HANDLE h)
d229 1
a229 1
  memset(th, 0, sizeof (*th));
d290 14
a303 2
  if (r >= 0)
    supply_register (r, ((char *) &current_thread->context) + mappings[r]);
d338 84
d428 1
a428 1
  LOAD_DLL_DEBUG_INFO * event = &current_event.u.LoadDll;
d432 1
a432 1
  char *p, *dll_name = NULL, *dll_basename;
d435 1
d437 2
a438 1
  dll_buf[0] = dll_buf[sizeof(dll_buf) - 1] = '\0';
d440 2
a441 10
  /* The following code attempts to find the name of the dll by reading the
     name from the processes memory.  Unfortunately it doesn't work right.
     Doing this the "right way" for Windows is very difficult.  FIXME */
#ifdef DOESNT_WORK
  memset (&minfo, 0, sizeof minfo);
  if (VirtualQueryEx (current_process_handle, (LPCVOID) event->lpBaseOfDll,
		      &minfo, sizeof(minfo)) && minfo.BaseAddress) {
      DWORD len;
      IMAGE_DOS_HEADER *hmm0 = (IMAGE_DOS_HEADER *) minfo.BaseAddress;
      HMODULE hmm = (HMODULE) (((DWORD) hmm0) + hmm0->e_lfanew);
d443 1
a443 7
      if ((len = GetModuleFileName (hmm, dll_buf, MAX_PATH)))
	{
	  dll_name = dll_buf;
	  dll_name[len] = '\0';
	}
  }
#endif
d460 1
a460 1
	 address isn't null. */
a506 22
  /* FIXME!! It would be nice to define one symbol which pointed to the
     front of the dll if we can't find any symbols. */

  if (!(dll_basename = strrchr(dll_name, '/')))
    dll_basename = dll_name;
  else
    dll_basename++;

  ALL_OBJFILES(objfile)
    {
      char *objfile_basename;
      objfile_basename = strrchr(objfile->name, '/');

      if (objfile_basename &&
	  strcmp(dll_basename, objfile_basename + 1) == 0)
	{
	  printf_unfiltered ("%x:%s (symbols previously loaded)\n",
			     event->lpBaseOfDll, dll_name);
	  goto out;
	}
  }

d514 2
a515 1
  symbol_file_add (dll_name, 0, (int) event->lpBaseOfDll + 0x1000, 0, 0, 0, 0, 1);
a517 1
out:
d531 1
a531 1
      ((CORE_ADDR) current_event.u.DebugString.lpDebugStringData, &s, 1024, 0)
d535 1
a535 1
  if (strncmp(s, CYGWIN_SIGNAL_STRING, sizeof(CYGWIN_SIGNAL_STRING) - 1))
d537 2
a538 1
      warning (s);
d543 4
a546 2
      /*last_sig = */strtol(s + sizeof(CYGWIN_SIGNAL_STRING) - 1, &p, 0);
      if (gotasig = (ourstatus->value.sig = target_signal_from_host (last_sig)))
d570 1
a570 1
		     current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d572 10
d585 1
a585 1
		     current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d587 1
d591 1
a591 1
		     current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d596 1
a596 1
		     current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d598 1
a598 2
      /* User typed CTRL-C.  Continue with this status */
      last_sig = SIGINT;	/* FIXME - should check pass state */
d602 1
a602 1
		     current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d607 2
a608 2
	 that case, we want to let the program try to handle it, and
	 only break if we see the exception a second time.  */
d610 1
d612 1
d615 2
a616 2
			 current_event.u.Exception.ExceptionRecord.ExceptionCode,
			 current_event.u.Exception.ExceptionRecord.ExceptionAddress);
d618 1
d628 1
a628 1
child_continue (DWORD continue_status, int id)
d636 6
a641 4
  if (res = ContinueDebugEvent (current_event.dwProcessId,
				current_event.dwThreadId,
			        continue_status))
    for (th = &thread_head; (th = th->next) != NULL; )
d653 122
d777 3
d788 7
a794 7
      DWORD continue_status;
      BOOL t = WaitForDebugEvent (&current_event, INFINITE);
      char *p;
      thread_info *th;
      int sig;

      event_count++;
d796 2
a797 1
      continue_status = DBG_CONTINUE;
d799 2
a800 80
      switch (current_event.dwDebugEventCode)
	{
	case CREATE_THREAD_DEBUG_EVENT:
	  DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%x code=%s)\n",
			current_event.dwProcessId, current_event.dwThreadId,
			"CREATE_THREAD_DEBUG_EVENT"));
	  /* Record the existence of this thread */
	  child_add_thread (current_event.dwThreadId,
			    current_event.u.CreateThread.hThread);
	  if (info_verbose)
	      printf_unfiltered ("[New %s]\n",
			       target_pid_to_str (current_event.dwThreadId));
	  break;

	case EXIT_THREAD_DEBUG_EVENT:
	  DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
			current_event.dwProcessId, current_event.dwThreadId,
			"EXIT_THREAD_DEBUG_EVENT"));
	  child_delete_thread (current_event.dwThreadId);
	  break;

	case CREATE_PROCESS_DEBUG_EVENT:
	  DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
			current_event.dwProcessId, current_event.dwThreadId,
			"CREATE_PROCESS_DEBUG_EVENT"));
	  current_process_handle = current_event.u.CreateProcessInfo.hProcess;

	  main_thread_id = inferior_pid = current_event.dwThreadId;
	  /* Add the main thread */
	  current_thread = child_add_thread (inferior_pid,
				current_event.u.CreateProcessInfo.hThread);
	  break;

	case EXIT_PROCESS_DEBUG_EVENT:
	  DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
			current_event.dwProcessId, current_event.dwThreadId,
			"EXIT_PROCESS_DEBUG_EVENT"));
	  ourstatus->kind = TARGET_WAITKIND_EXITED;
	  ourstatus->value.integer = current_event.u.ExitProcess.dwExitCode;
	  CloseHandle (current_process_handle);
	  return current_event.dwProcessId;
	  break;

	case LOAD_DLL_DEBUG_EVENT:
	  DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
			current_event.dwProcessId, current_event.dwThreadId,
			"LOAD_DLL_DEBUG_EVENT"));
          catch_errors (handle_load_dll, NULL, "", RETURN_MASK_ALL);
	  registers_changed();          /* mark all regs invalid */
	  break;

	case UNLOAD_DLL_DEBUG_EVENT:
	  DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
			current_event.dwProcessId, current_event.dwThreadId,
			"UNLOAD_DLL_DEBUG_EVENT"));
	  break;	/* FIXME: don't know what to do here */

	case EXCEPTION_DEBUG_EVENT:
	  DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
			current_event.dwProcessId, current_event.dwThreadId,
			"EXCEPTION_DEBUG_EVENT"));
	  if (handle_exception (ourstatus))
	    return current_event.dwThreadId;
	  continue_status = DBG_EXCEPTION_NOT_HANDLED;
	  break;

	case OUTPUT_DEBUG_STRING_EVENT: /* message from the kernel */
	  DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
			current_event.dwProcessId, current_event.dwThreadId,
			"OUTPUT_DEBUG_STRING_EVENT"));
	  if (handle_output_debug_string (ourstatus))
	    return main_thread_id;
	  break;
	default:
	  printf_unfiltered ("gdb: kernel event for pid=%d tid=%d\n",
			     current_event.dwProcessId,
			     current_event.dwThreadId);
	  printf_unfiltered ("                 unknown event code %d\n",
			     current_event.dwDebugEventCode);
	  break;
a801 2

      CHECK (child_continue (continue_status, -1));
d895 1
a895 1
  int  envlen;
a896 1

d903 1
d941 4
a944 4
      {
	"PATH=",
	0
      };
d1004 1
a1004 1
		       args, 	/* command line */
d1014 1
a1014 1
    error ("Error creating process %s, (error %d)\n", exec_file, GetLastError());
d1030 7
a1036 2
  /* Ignore the first trap */
  child_wait (inferior_pid, &dummy);
d1044 2
a1045 1
  (void) child_continue (DBG_CONTINUE, -1);
d1057 2
a1058 2
  CHECK (GenerateConsoleCtrlEvent (CTRL_C_EVENT, 0));
  registers_changed();		/* refresh register state */
d1091 2
a1092 1
      if (!child_continue (DBG_CONTINUE, -1))
d1104 1
a1104 1
  target_mourn_inferior();	/* or just child_mourn_inferior? */
a1111 2
  DWORD continue_status = last_sig > 0 && last_sig < NSIG ?
			  DBG_EXCEPTION_NOT_HANDLED : DBG_CONTINUE;
a1134 2
  if (sig && sig != last_sig)
    fprintf_unfiltered (gdb_stderr, "Can't send signals to the child.  signal %d\n", sig);
d1136 1
a1136 2
  last_sig = 0;
  child_continue (continue_status, pid);
d1157 1
a1157 1
struct target_ops child_ops ;
d1159 2
a1160 2
static void 
init_child_ops(void)
d1162 41
a1202 40
  child_ops.to_shortname =   "child";
  child_ops.to_longname =   "Win32 child process";
  child_ops.to_doc =   "Win32 child process (started by the \"run\" command).";
  child_ops.to_open =   child_open;
  child_ops.to_close =   child_close;
  child_ops.to_attach =   child_attach;
  child_ops.to_detach =   child_detach;
  child_ops.to_resume =   child_resume;
  child_ops.to_wait  =   child_wait;
  child_ops.to_fetch_registers  =   child_fetch_inferior_registers;
  child_ops.to_store_registers  =   child_store_inferior_registers;
  child_ops.to_prepare_to_store =   child_prepare_to_store;
  child_ops.to_xfer_memory  =   child_xfer_memory;
  child_ops.to_files_info  =   child_files_info;
  child_ops.to_insert_breakpoint =   memory_insert_breakpoint;
  child_ops.to_remove_breakpoint =   memory_remove_breakpoint;
  child_ops.to_terminal_init  =   terminal_init_inferior;
  child_ops.to_terminal_inferior =   terminal_inferior;
  child_ops.to_terminal_ours_for_output =   terminal_ours_for_output;
  child_ops.to_terminal_ours  =   terminal_ours;
  child_ops.to_terminal_info  =   child_terminal_info;
  child_ops.to_kill  =   child_kill_inferior;
  child_ops.to_load  =   0;
  child_ops.to_lookup_symbol =   0;
  child_ops.to_create_inferior =   child_create_inferior;
  child_ops.to_mourn_inferior =   child_mourn_inferior;
  child_ops.to_can_run  =   child_can_run;
  child_ops.to_notice_signals =   0;
  child_ops.to_thread_alive  =   win32_child_thread_alive;
  child_ops.to_stop  =   child_stop;
  child_ops.to_stratum =   process_stratum;
  child_ops.DONT_USE =   0;
  child_ops.to_has_all_memory =   1;
  child_ops.to_has_memory =   1;
  child_ops.to_has_stack =   1;
  child_ops.to_has_registers =   1;
  child_ops.to_has_execution =   1;
  child_ops.to_sections =   0;
  child_ops.to_sections_end =   0;
  child_ops.to_magic =   OPS_MAGIC;
d1209 1
a1209 1
  init_child_ops() ;
d1249 1
a1249 1
		  "Set whether to display kernel exceptions in child process.",
d1262 2
a1263 2
  return WaitForSingleObject(thread_rec (pid, FALSE)->h, 0) == WAIT_OBJECT_0 ?
	 FALSE : TRUE;
d1276 57
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@a52 11
/* The ui's event loop. */
extern int (*ui_loop_hook) PARAMS ((int signo));

/* If we're not using the old Cygwin header file set, define the
   following which never should have been in the generic Win32 API
   headers in the first place since they were our own invention... */
#ifndef _GNU_H_WINDOWS_H
#define FLAG_TRACE_BIT 0x100
#define CONTEXT_DEBUGGER (CONTEXT_FULL | CONTEXT_FLOATING_POINT)
#endif

a67 1
void child_kill_inferior PARAMS ((void));
d456 1
a456 3
      gotasig = target_signal_from_host (last_sig);
      ourstatus->value.sig = gotasig;
      if (gotasig)
d533 3
a535 4
  res = ContinueDebugEvent (current_event.dwProcessId,
			    current_event.dwThreadId,
			    continue_status);
  if (res)
d559 1
a559 1
      BOOL debug_event = WaitForDebugEvent (&current_event, 20);
d564 1
a564 3
      if (debug_event)
	{
	  event_count++;
d566 1
a566 1
	  continue_status = DBG_CONTINUE;
d568 80
a647 83
	  switch (current_event.dwDebugEventCode)
	    {
	    case CREATE_THREAD_DEBUG_EVENT:
	      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%x code=%s)\n",
			     current_event.dwProcessId, current_event.dwThreadId,
			     "CREATE_THREAD_DEBUG_EVENT"));
	      /* Record the existence of this thread */
	      child_add_thread (current_event.dwThreadId,
				current_event.u.CreateThread.hThread);
	      if (info_verbose)
		printf_unfiltered ("[New %s]\n",
				   target_pid_to_str (current_event.dwThreadId));
	      break;

	    case EXIT_THREAD_DEBUG_EVENT:
	      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
			     current_event.dwProcessId, current_event.dwThreadId,
			     "EXIT_THREAD_DEBUG_EVENT"));
	      child_delete_thread (current_event.dwThreadId);
	      break;

	    case CREATE_PROCESS_DEBUG_EVENT:
	      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
			     current_event.dwProcessId, current_event.dwThreadId,
			     "CREATE_PROCESS_DEBUG_EVENT"));
	      current_process_handle = current_event.u.CreateProcessInfo.hProcess;

	      main_thread_id = inferior_pid = current_event.dwThreadId;
	      /* Add the main thread */
	      current_thread = child_add_thread (inferior_pid,
						 current_event.u.CreateProcessInfo.hThread);
	      break;

	    case EXIT_PROCESS_DEBUG_EVENT:
	      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
			     current_event.dwProcessId, current_event.dwThreadId,
			     "EXIT_PROCESS_DEBUG_EVENT"));
	      ourstatus->kind = TARGET_WAITKIND_EXITED;
	      ourstatus->value.integer = current_event.u.ExitProcess.dwExitCode;
	      CloseHandle (current_process_handle);
	      return current_event.dwProcessId;
	      break;

	    case LOAD_DLL_DEBUG_EVENT:
	      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
			     current_event.dwProcessId, current_event.dwThreadId,
			     "LOAD_DLL_DEBUG_EVENT"));
	      catch_errors (handle_load_dll, NULL, "", RETURN_MASK_ALL);
	      registers_changed();          /* mark all regs invalid */
	      break;

	    case UNLOAD_DLL_DEBUG_EVENT:
	      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
			     current_event.dwProcessId, current_event.dwThreadId,
			     "UNLOAD_DLL_DEBUG_EVENT"));
	      break;	/* FIXME: don't know what to do here */

	    case EXCEPTION_DEBUG_EVENT:
	      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
			     current_event.dwProcessId, current_event.dwThreadId,
			     "EXCEPTION_DEBUG_EVENT"));
	      if (handle_exception (ourstatus))
		return current_event.dwThreadId;
	      continue_status = DBG_EXCEPTION_NOT_HANDLED;
	      break;

	    case OUTPUT_DEBUG_STRING_EVENT: /* message from the kernel */
	      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
			     current_event.dwProcessId, current_event.dwThreadId,
			     "OUTPUT_DEBUG_STRING_EVENT"));
	      if (handle_output_debug_string (ourstatus))
		return main_thread_id;
	      break;
	    default:
	      printf_unfiltered ("gdb: kernel event for pid=%d tid=%d\n",
				 current_event.dwProcessId,
				 current_event.dwThreadId);
	      printf_unfiltered ("                 unknown event code %d\n",
				 current_event.dwDebugEventCode);
	      break;
	    }

	  CHECK (child_continue (continue_status, -1));
a648 3
      else
	{
	  int detach = 0;
d650 1
a650 6
	  if (ui_loop_hook != NULL)
	    detach = ui_loop_hook (0);

	  if (detach)
	    child_kill_inferior ();
	}
@


1.1.1.3
log
@import gdb-1999-07-07 post reformat
@
text
@d19 2
a20 3
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.
 */
d87 8
a94 9
  {
    struct thread_info_struct *next;
    DWORD id;
    HANDLE h;
    char *name;
    int suspend_count;
    CONTEXT context;
  }
thread_info;
d96 1
a96 2
static thread_info thread_head =
{NULL};
d104 1
a104 1
static DWORD main_thread_id;	/* Thread ID of the main thread */
d113 3
a115 3
static int debug_exec = 0;	/* show execution */
static int debug_events = 0;	/* show events from kernel */
static int debug_memory = 0;	/* show target memory accesses */
d134 24
a157 24
  context_offset (Eax),
  context_offset (Ecx),
  context_offset (Edx),
  context_offset (Ebx),
  context_offset (Esp),
  context_offset (Ebp),
  context_offset (Esi),
  context_offset (Edi),
  context_offset (Eip),
  context_offset (EFlags),
  context_offset (SegCs),
  context_offset (SegSs),
  context_offset (SegDs),
  context_offset (SegEs),
  context_offset (SegFs),
  context_offset (SegGs),
  context_offset (FloatSave.RegisterArea[0 * 10]),
  context_offset (FloatSave.RegisterArea[1 * 10]),
  context_offset (FloatSave.RegisterArea[2 * 10]),
  context_offset (FloatSave.RegisterArea[3 * 10]),
  context_offset (FloatSave.RegisterArea[4 * 10]),
  context_offset (FloatSave.RegisterArea[5 * 10]),
  context_offset (FloatSave.RegisterArea[6 * 10]),
  context_offset (FloatSave.RegisterArea[7 * 10]),
d187 1
a187 1
  for (th = &thread_head; (th = th->next) != NULL;)
d208 1
a208 1
child_add_thread (DWORD id, HANDLE h)
d216 1
a216 1
  memset (th, 0, sizeof (*th));
d319 1
a319 1
  LOAD_DLL_DEBUG_INFO *event = &current_event.u.LoadDll;
d327 1
a327 1
  dll_buf[0] = dll_buf[sizeof (dll_buf) - 1] = '\0';
d335 1
a335 2
		      &minfo, sizeof (minfo)) && minfo.BaseAddress)
    {
d345 1
a345 1
    }
d363 1
a363 1
         address isn't null. */
d413 1
a413 1
  if (!(dll_basename = strrchr (dll_name, '/')))
d418 4
a421 4
  ALL_OBJFILES (objfile)
  {
    char *objfile_basename;
    objfile_basename = strrchr (objfile->name, '/');
d423 7
a429 7
    if (objfile_basename &&
	strcmp (dll_basename, objfile_basename + 1) == 0)
      {
	printf_unfiltered ("%x:%s (symbols previously loaded)\n",
			   event->lpBaseOfDll, dll_name);
	goto out;
      }
d456 1
a456 1
    ((CORE_ADDR) current_event.u.DebugString.lpDebugStringData, &s, 1024, 0)
d460 1
a460 1
  if (strncmp (s, CYGWIN_SIGNAL_STRING, sizeof (CYGWIN_SIGNAL_STRING) - 1))
d467 1
a467 1
      /*last_sig = */ strtol (s + sizeof (CYGWIN_SIGNAL_STRING) - 1, &p, 0);
d494 1
a494 1
	       current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d499 1
a499 1
	       current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d504 1
a504 1
	       current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d509 1
a509 1
	       current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d516 1
a516 1
	       current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d521 2
a522 2
         that case, we want to let the program try to handle it, and
         only break if we see the exception a second time.  */
d527 2
a528 2
		    current_event.u.Exception.ExceptionRecord.ExceptionCode,
		current_event.u.Exception.ExceptionRecord.ExceptionAddress);
d551 1
a551 1
    for (th = &thread_head; (th = th->next) != NULL;)
d589 1
a589 1
			current_event.dwProcessId, current_event.dwThreadId,
d596 1
a596 1
			      target_pid_to_str (current_event.dwThreadId));
d601 1
a601 1
			current_event.dwProcessId, current_event.dwThreadId,
d608 1
a608 1
			current_event.dwProcessId, current_event.dwThreadId,
d615 1
a615 1
				 current_event.u.CreateProcessInfo.hThread);
d620 1
a620 1
			current_event.dwProcessId, current_event.dwThreadId,
d630 1
a630 1
			current_event.dwProcessId, current_event.dwThreadId,
d633 1
a633 1
	      registers_changed ();	/* mark all regs invalid */
d638 1
a638 1
			current_event.dwProcessId, current_event.dwThreadId,
d640 1
a640 1
	      break;		/* FIXME: don't know what to do here */
d644 1
a644 1
			current_event.dwProcessId, current_event.dwThreadId,
d651 1
a651 1
	    case OUTPUT_DEBUG_STRING_EVENT:	/* message from the kernel */
d653 1
a653 1
			current_event.dwProcessId, current_event.dwThreadId,
d772 1
a772 1
  int envlen;
d818 4
a821 4
    {
      "PATH=",
      0
    };
d881 1
a881 1
		       args,	/* command line */
d891 1
a891 1
    error ("Error creating process %s, (error %d)\n", exec_file, GetLastError ());
d929 1
a929 1
  registers_changed ();		/* refresh register state */
d974 1
a974 1
  target_mourn_inferior ();	/* or just child_mourn_inferior? */
d983 1
a983 1
  DBG_EXCEPTION_NOT_HANDLED : DBG_CONTINUE;
d1032 1
a1032 1
struct target_ops child_ops;
d1034 2
a1035 2
static void
init_child_ops (void)
d1037 40
a1076 40
  child_ops.to_shortname = "child";
  child_ops.to_longname = "Win32 child process";
  child_ops.to_doc = "Win32 child process (started by the \"run\" command).";
  child_ops.to_open = child_open;
  child_ops.to_close = child_close;
  child_ops.to_attach = child_attach;
  child_ops.to_detach = child_detach;
  child_ops.to_resume = child_resume;
  child_ops.to_wait = child_wait;
  child_ops.to_fetch_registers = child_fetch_inferior_registers;
  child_ops.to_store_registers = child_store_inferior_registers;
  child_ops.to_prepare_to_store = child_prepare_to_store;
  child_ops.to_xfer_memory = child_xfer_memory;
  child_ops.to_files_info = child_files_info;
  child_ops.to_insert_breakpoint = memory_insert_breakpoint;
  child_ops.to_remove_breakpoint = memory_remove_breakpoint;
  child_ops.to_terminal_init = terminal_init_inferior;
  child_ops.to_terminal_inferior = terminal_inferior;
  child_ops.to_terminal_ours_for_output = terminal_ours_for_output;
  child_ops.to_terminal_ours = terminal_ours;
  child_ops.to_terminal_info = child_terminal_info;
  child_ops.to_kill = child_kill_inferior;
  child_ops.to_load = 0;
  child_ops.to_lookup_symbol = 0;
  child_ops.to_create_inferior = child_create_inferior;
  child_ops.to_mourn_inferior = child_mourn_inferior;
  child_ops.to_can_run = child_can_run;
  child_ops.to_notice_signals = 0;
  child_ops.to_thread_alive = win32_child_thread_alive;
  child_ops.to_stop = child_stop;
  child_ops.to_stratum = process_stratum;
  child_ops.DONT_USE = 0;
  child_ops.to_has_all_memory = 1;
  child_ops.to_has_memory = 1;
  child_ops.to_has_stack = 1;
  child_ops.to_has_registers = 1;
  child_ops.to_has_execution = 1;
  child_ops.to_sections = 0;
  child_ops.to_sections_end = 0;
  child_ops.to_magic = OPS_MAGIC;
d1083 1
a1083 1
  init_child_ops ();
d1123 1
a1123 1
	       "Set whether to display kernel exceptions in child process.",
d1136 2
a1137 2
  return WaitForSingleObject (thread_rec (pid, FALSE)->h, 0) == WAIT_OBJECT_0 ?
    FALSE : TRUE;
@


1.1.1.4
log
@import gdb-1999-08-16 snapshot
@
text
@d326 1
a326 1
  char *p, *dll_name = NULL;
d414 22
d446 1
@


1.1.1.5
log
@import gdb-1999-08-30 snapshot
@
text
@d52 1
@


1.1.1.6
log
@import gdb-1999-10-04 snapshot
@
text
@a327 1
  struct section_addr_info section_addrs;
a328 1
  memset (&section_addrs, 0, sizeof (section_addrs));
d420 1
a420 2
  section_addrs.text_addr = (int) event->lpBaseOfDll + 0x1000;
  symbol_file_add (dll_name, 0, &section_addrs, 0, 0, 0, 1);
d890 1
a890 1
  proceed ((CORE_ADDR) -1, TARGET_SIGNAL_0, 0);
@


1.1.1.7
log
@import gdb-1999-10-11 snapshot
@
text
@d423 1
a423 1
  symbol_file_add (dll_name, 0, &section_addrs, 0, OBJF_SHARED);
@


1.1.1.8
log
@import gdb-1999-12-06 snapshot
@
text
@a42 1
#include <imagehlp.h>
a51 1
#include <unistd.h>
d81 3
d94 2
a95 4
    STACKFRAME sf;
  } thread_info;

static thread_info thread_head = {NULL};
d97 2
a98 2
/* The saved state for a continue after breaking back to gdb. */
static DWORD continue_status;
d114 1
a114 1
static int new_group = 1;
a159 7
  context_offset (FloatSave.ControlWord),
  context_offset (FloatSave.StatusWord),
  context_offset (FloatSave.TagWord),
  context_offset (FloatSave.ErrorSelector),
  context_offset (FloatSave.ErrorOffset),
  context_offset (FloatSave.DataSelector),
  context_offset (FloatSave.DataOffset),
d279 1
a279 13
  char *context_offset = ((char *) &current_thread->context) + mappings[r];
  long l;
  if (r == FCS_REGNUM)
    {
      l = *((long *)context_offset) & 0xffff;
      supply_register (r, (char *) &l);
    }
  else if (r == FOP_REGNUM)
    {
      l = (*((long *)context_offset) >> 16) & ((1 << 11) - 1);
      supply_register (r, (char *) &l);
    }
  else if (r >= 0)
a314 84
#include <psapi.h>
static int psapi_loaded = 0;
static HMODULE psapi_module_handle = NULL;
static BOOL  WINAPI (*psapi_EnumProcessModules)(HANDLE, HMODULE*, DWORD, LPDWORD)= NULL;
static BOOL  WINAPI (*psapi_GetModuleInformation) (HANDLE, HMODULE, LPMODULEINFO, DWORD)= NULL;
static DWORD WINAPI (*psapi_GetModuleFileNameExA) (HANDLE, HMODULE, LPSTR, DWORD)= NULL;

int psapi_get_dll_name (DWORD BaseAddress, char *dll_name_ret)
{
  DWORD len;
  MODULEINFO mi;
  int i;
  HMODULE dh_buf [ 1 ];
  HMODULE* DllHandle = dh_buf;
  DWORD cbNeeded;
  BOOL ok;

  if (!psapi_loaded ||
       psapi_EnumProcessModules   == NULL ||
       psapi_GetModuleInformation == NULL ||
       psapi_GetModuleFileNameExA == NULL)
    {
      if (psapi_loaded)goto failed;
      psapi_loaded = 1;
      psapi_module_handle = LoadLibrary ("psapi.dll");
      if (!psapi_module_handle)
        {
          /* printf_unfiltered ("error loading psapi.dll: %u", GetLastError ());*/
          goto failed;
        }
      psapi_EnumProcessModules   = GetProcAddress (psapi_module_handle, "EnumProcessModules" );
      psapi_GetModuleInformation = GetProcAddress (psapi_module_handle, "GetModuleInformation");
      psapi_GetModuleFileNameExA = (void *) GetProcAddress (psapi_module_handle,
							    "GetModuleFileNameExA");
      if (psapi_EnumProcessModules   == NULL ||
           psapi_GetModuleInformation == NULL ||
           psapi_GetModuleFileNameExA == NULL)
	goto failed;
    }

  cbNeeded = 0;
  ok = (*psapi_EnumProcessModules) (current_process_handle,
				     DllHandle,
				     sizeof (HMODULE),
				     &cbNeeded);

  if (!ok || !cbNeeded)
    goto failed;

  DllHandle = (HMODULE*) alloca (cbNeeded);
  if (!DllHandle)
    goto failed;

  ok = (*psapi_EnumProcessModules) (current_process_handle,
				     DllHandle,
				     cbNeeded,
				     &cbNeeded);
  if (!ok)
    goto failed;

  for (i = 0; i < cbNeeded / sizeof (HMODULE); i++)
    {
      if (!(*psapi_GetModuleInformation) (current_process_handle,
					     DllHandle [i],
					     &mi,
					     sizeof (mi)))
	error ("Can't get module info");

      len = (*psapi_GetModuleFileNameExA) (current_process_handle,
					    DllHandle [i],
					    dll_name_ret,
					    MAX_PATH);
      if (len == 0)
	error ("Error getting dll name: %u\n", GetLastError ()); 

      if ((DWORD) (mi.lpBaseOfDll) == BaseAddress)
	return 1;
    }

failed:
  dll_name_ret[0] = '\0';
  return 0;
}

d333 11
a343 2
  if (!psapi_get_dll_name ((DWORD) (event->lpBaseOfDll), dll_buf))
    dll_buf[0] = dll_buf[sizeof(dll_buf) - 1] = '\0';
d345 7
a351 1
  dll_name = dll_buf;
d445 1
a445 2
      if (strncmp (s, "cYg", 3))
	warning (s);
d447 1
d450 2
a451 2
      int sig = strtol (s + sizeof (CYGWIN_SIGNAL_STRING) - 1, &p, 0);
      gotasig = target_signal_from_host (sig);
a478 1
      continue_status = DBG_EXCEPTION_NOT_HANDLED;
a483 1
      continue_status = DBG_EXCEPTION_NOT_HANDLED;
d494 2
a495 1
      continue_status = DBG_EXCEPTION_NOT_HANDLED;
a512 1
      continue_status = DBG_EXCEPTION_NOT_HANDLED;
d522 1
a522 1
child_continue (int id)
a532 1
  continue_status = 0;
a545 122
get_child_debug_event (int pid, struct target_waitstatus *ourstatus,
		       DWORD *event_code, int *retval)
{
  BOOL debug_event;
  int breakout = 1;

  if (!(debug_event = WaitForDebugEvent (&current_event, 20)))
    {
      breakout = *retval = *event_code = 0;
      goto out;
    }

  event_count++;
  continue_status = DBG_CONTINUE;
  *retval = 0;

  switch (*event_code = current_event.dwDebugEventCode)
    {
    case CREATE_THREAD_DEBUG_EVENT:
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%x code=%s)\n",
		    (unsigned) current_event.dwProcessId,
		    (unsigned) current_event.dwThreadId,
		    "CREATE_THREAD_DEBUG_EVENT"));
      /* Record the existence of this thread */
      child_add_thread (current_event.dwThreadId,
			current_event.u.CreateThread.hThread);
      if (info_verbose)
	printf_unfiltered ("[New %s]\n",
		      target_pid_to_str (current_event.dwThreadId));
      break;

    case EXIT_THREAD_DEBUG_EVENT:
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
		    (unsigned) current_event.dwProcessId,
		    (unsigned) current_event.dwThreadId,
		    "EXIT_THREAD_DEBUG_EVENT"));
      child_delete_thread (current_event.dwThreadId);
      break;

    case CREATE_PROCESS_DEBUG_EVENT:
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
		    (unsigned) current_event.dwProcessId,
		    (unsigned) current_event.dwThreadId,
		    "CREATE_PROCESS_DEBUG_EVENT"));
      current_process_handle = current_event.u.CreateProcessInfo.hProcess;

      main_thread_id = inferior_pid = current_event.dwThreadId;
      /* Add the main thread */
      current_thread = child_add_thread (inferior_pid,
			 current_event.u.CreateProcessInfo.hThread);
      break;

    case EXIT_PROCESS_DEBUG_EVENT:
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
		    (unsigned) current_event.dwProcessId,
		    (unsigned) current_event.dwThreadId,
		    "EXIT_PROCESS_DEBUG_EVENT"));
      ourstatus->kind = TARGET_WAITKIND_EXITED;
      ourstatus->value.integer = current_event.u.ExitProcess.dwExitCode;
      CloseHandle (current_process_handle);
      *retval = current_event.dwProcessId;
      goto out;

    case LOAD_DLL_DEBUG_EVENT:
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
		    (unsigned) current_event.dwProcessId,
		    (unsigned) current_event.dwThreadId,
		    "LOAD_DLL_DEBUG_EVENT"));
      catch_errors (handle_load_dll, NULL, "", RETURN_MASK_ALL);
      registers_changed ();	/* mark all regs invalid */
      break;

    case UNLOAD_DLL_DEBUG_EVENT:
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
		    (unsigned) current_event.dwProcessId,
		    (unsigned) current_event.dwThreadId,
		    "UNLOAD_DLL_DEBUG_EVENT"));
      break;		/* FIXME: don't know what to do here */

    case EXCEPTION_DEBUG_EVENT:
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
		    (unsigned) current_event.dwProcessId,
		    (unsigned) current_event.dwThreadId,
		    "EXCEPTION_DEBUG_EVENT"));
      if (handle_exception (ourstatus))	/* sets continue_status */
	{
	  *retval = current_event.dwThreadId;
	  goto out;
	}
      break;

    case OUTPUT_DEBUG_STRING_EVENT:
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
		    (unsigned) current_event.dwProcessId,
		    (unsigned) current_event.dwThreadId,
		    "OUTPUT_DEBUG_STRING_EVENT"));
      if (handle_output_debug_string (ourstatus))
	{
	  *retval = main_thread_id;
	  goto out;
	}
      break;
    default:
      printf_unfiltered ("gdb: kernel event for pid=%d tid=%d\n",
			 current_event.dwProcessId,
			 current_event.dwThreadId);
      printf_unfiltered ("                 unknown event code %d\n",
			 current_event.dwDebugEventCode);
      break;
    }

  breakout = 0;
  CHECK (child_continue (-1));
  continue_status = 0;

out:
  return breakout;
}


/* Wait for interesting events to occur in the target process. */
static int
a547 3
  DWORD event_code;
  int retval;

d556 96
a651 4
      if (continue_status != 0)
	CHECK (child_continue (-1));
      if (get_child_debug_event (pid, ourstatus, &event_code, &retval))
	return retval;
d757 1
a763 1
  DWORD event_code;
d890 2
a891 4
  /* Run until process and threads are loaded */
  do
    get_child_debug_event (inferior_pid, &dummy, &event_code, &ret);
  while (event_code != EXCEPTION_DEBUG_EVENT);
d893 1
a893 1
  proceed ((CORE_ADDR) - 1, TARGET_SIGNAL_0, 0);
d899 1
a899 2
  continue_status = DBG_CONTINUE;
  (void) child_continue (-1);
d911 1
a911 1
  CHECK (GenerateConsoleCtrlEvent (CTRL_C_EVENT, current_event.dwProcessId));
d945 1
a945 2
      continue_status = DBG_CONTINUE;
      if (!child_continue (-1))
d965 2
d990 2
d993 2
a994 1
  child_continue (pid);
a1133 37
#ifdef NOTYET
CORE_ADDR
win32_read_fp ()
{
  STACKFRAME *sf = current_thread->sf;
  
  memset (&sf, 0, sizeof(sf));
  sf->AddrPC.Offset = current_thread->context.Eip;
  sf->AddrPC.Mode = AddrModeFlat;
  sf->AddrStack.Offset = current_thread->context.Esp;
  sf->AddrStack.Mode = AddrModeFlat;
  sf->AddrFrame.Offset = current_thread->context.Ebp;
  if (!StackWalk (IMAGE_FILE_MACHINE_I386, current_process_handle,
		  current->thread->h, sf, NULL, NULL,
		  SymFunctionTableAccess, SymGetModuleBase, NULL))
    return NULL;
  return (CORE_ADDR) sf.AddrFrame.Offset;
}

CORE_ADDR
child_frame_chain(struct frame_info *thisframe)
{
  STACKFRAME *sf = current->thread->sf;
#if 0
  sf.AddrPC.Offset = thisframe->pc;
  sf.AddrPC.Mode = AddrModeFlat;
  sf.AddrStack.Offset = thisframe->;
  sf.AddrStack.Mode = AddrModeFlat;
  sf.AddrFrame.Offset = cx->Ebp;
#endif
  if (!StackWalk (IMAGE_FILE_MACHINE_I386, current_process_handle,
		  current->thread->h, &sf, NULL, NULL,
		  SymFunctionTableAccess, SymGetModuleBase, NULL))
    return NULL;
  return (CORE_ADDR) sf->AddrFrame.Offset;
}
#endif
@


1.1.1.9
log
@import gdb-1999-12-21 snapshot
@
text
@a167 1
  context_offset (FloatSave.ErrorSelector)
a169 2
#undef context_offset

d300 1
a300 1
    supply_register (r, context_offset);
d532 1
a532 1
  if (strncmp (s, CYGWIN_SIGNAL_STRING, sizeof (CYGWIN_SIGNAL_STRING) - 1) != 0)
d534 1
a534 1
      if (strncmp (s, "cYg", 3) != 0)
a536 1
  else
d595 1
a595 1
         only break if we see the exception a second time.
a596 1

a597 1
*/
a1019 3
  SymSetOptions (SYMOPT_DEFERRED_LOADS);
  SymInitialize (current_process_handle, NULL, TRUE);

a1172 1
  child_ops.to_pid_to_str = cygwin_pid_to_str;
d1258 3
a1260 3

static LPVOID __stdcall
sfta(HANDLE h, DWORD d)
d1262 13
a1274 1
  return NULL;
d1277 2
a1278 2
static DWORD __stdcall
sgmb(HANDLE h, DWORD d)
d1280 1
d1282 5
a1286 3
  return 4;
#else
  return SymGetModuleBase (h, d) ?: 4;
a1287 6
}

CORE_ADDR
child_frame_chain(struct frame_info *f)
{
  STACKFRAME *sf = (STACKFRAME *) f->extra_info;
d1289 4
a1292 34
		  current_thread->h, sf, NULL, NULL, SymFunctionTableAccess, sgmb, NULL) ||
      !sf->AddrReturn.Offset)
    return 0;
  return sf->AddrFrame.Offset;
}

CORE_ADDR
child_frame_saved_pc(struct frame_info *f)
{
  STACKFRAME *sf = (STACKFRAME *) f->extra_info;
  return sf->AddrReturn.Offset;
}

void
child_init_frame(int leaf, struct frame_info *f)
{
  STACKFRAME *sf;

  if (f->next && f->next->extra_info)
    f->extra_info = f->next->extra_info;
  else if (f->prev && f->prev->extra_info)
    f->extra_info = f->prev->extra_info;
  else
    {
      sf = (STACKFRAME *) frame_obstack_alloc (sizeof (*sf));
      f->extra_info = (struct frame_extra_info *) sf;
      memset (sf, 0, sizeof(*sf));
      sf->AddrPC.Offset = f->pc;
      sf->AddrPC.Mode = AddrModeFlat;
      sf->AddrStack.Offset = current_thread->context.Esp;
      sf->AddrStack.Mode = AddrModeFlat;
      sf->AddrFrame.Offset = f->frame;
      sf->AddrFrame.Mode = AddrModeFlat;
    }
d1294 1
@


1.1.1.10
log
@import gdb-2000-01-10 snapshot
@
text
@a573 9
    case STATUS_FLOAT_UNDERFLOW:
    case STATUS_FLOAT_DIVIDE_BY_ZERO:
    case STATUS_FLOAT_OVERFLOW:
    case STATUS_INTEGER_DIVIDE_BY_ZERO:
      DEBUG_EXCEPT (("gdb: Target exception STACK_OVERFLOW at 0x%08x\n",
	       current_event.u.Exception.ExceptionRecord.ExceptionAddress));
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
      continue_status = DBG_EXCEPTION_NOT_HANDLED;
      break;
@


