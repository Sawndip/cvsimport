head	1.583;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.528.2.7
	gdb_7_6-2013-04-26-release:1.528.2.6
	gdb_7_6-branch:1.528.0.2
	gdb_7_6-2013-03-12-branchpoint:1.528
	gdb_7_5_1-2012-11-29-release:1.502
	gdb_7_5-2012-08-17-release:1.502
	gdb_7_5-branch:1.502.0.2
	gdb_7_5-2012-07-18-branchpoint:1.502
	gdb_7_4_1-2012-04-26-release:1.473.2.3
	gdb_7_4-2012-01-24-release:1.473.2.1
	gdb_7_4-branch:1.473.0.2
	gdb_7_4-2011-12-13-branchpoint:1.473
	gdb_7_3_1-2011-09-04-release:1.441.2.5
	gdb_7_3-2011-07-26-release:1.441.2.5
	gdb_7_3-branch:1.441.0.2
	gdb_7_3-2011-04-01-branchpoint:1.441
	gdb_7_2-2010-09-02-release:1.419.2.1
	gdb_7_2-branch:1.419.0.2
	gdb_7_2-2010-07-07-branchpoint:1.419
	gdb_7_1-2010-03-18-release:1.385.2.1
	gdb_7_1-branch:1.385.0.2
	gdb_7_1-2010-02-18-branchpoint:1.385
	gdb_7_0_1-2009-12-22-release:1.372
	gdb_7_0-2009-10-06-release:1.372
	gdb_7_0-branch:1.372.0.2
	gdb_7_0-2009-09-16-branchpoint:1.372
	arc-sim-20090309:1.280.6.1
	msnyder-checkpoint-072509-branch:1.364.0.2
	msnyder-checkpoint-072509-branchpoint:1.364
	arc-insight_6_8-branch:1.280.0.6
	arc-insight_6_8-branchpoint:1.280
	insight_6_8-branch:1.280.0.4
	insight_6_8-branchpoint:1.280
	reverse-20081226-branch:1.335.0.2
	reverse-20081226-branchpoint:1.335
	multiprocess-20081120-branch:1.329.0.2
	multiprocess-20081120-branchpoint:1.329
	reverse-20080930-branch:1.310.0.2
	reverse-20080930-branchpoint:1.310
	reverse-20080717-branch:1.302.0.2
	reverse-20080717-branchpoint:1.302
	msnyder-reverse-20080609-branch:1.296.0.2
	msnyder-reverse-20080609-branchpoint:1.296
	drow-reverse-20070409-branch:1.247.0.2
	drow-reverse-20070409-branchpoint:1.247
	gdb_6_8-2008-03-27-release:1.280
	gdb_6_8-branch:1.280.0.2
	gdb_6_8-2008-02-26-branchpoint:1.280
	gdb_6_7_1-2007-10-29-release:1.266.2.2
	gdb_6_7-2007-10-10-release:1.266.2.2
	gdb_6_7-branch:1.266.0.2
	gdb_6_7-2007-09-07-branchpoint:1.266
	insight_6_6-20070208-release:1.237
	gdb_6_6-2006-12-18-release:1.237
	gdb_6_6-branch:1.237.0.2
	gdb_6_6-2006-11-15-branchpoint:1.237
	insight_6_5-20061003-release:1.210
	gdb-csl-symbian-6_4_50_20060226-12:1.202.2.3.2.15
	gdb-csl-sourcerygxx-3_4_4-25:1.195.6.2
	nickrob-async-20060828-mergepoint:1.226
	gdb-csl-symbian-6_4_50_20060226-11:1.202.2.3.2.14
	gdb-csl-sourcerygxx-4_1-17:1.202.2.8
	gdb-csl-20060226-branch-local-2:1.202.2.8
	gdb-csl-sourcerygxx-4_1-14:1.202.2.6
	gdb-csl-sourcerygxx-4_1-13:1.202.2.6
	gdb-csl-sourcerygxx-4_1-12:1.202.2.6
	gdb-csl-sourcerygxx-3_4_4-21:1.202.2.6
	gdb_6_5-20060621-release:1.210
	gdb-csl-sourcerygxx-4_1-9:1.202.2.6
	gdb-csl-sourcerygxx-4_1-8:1.202.2.6
	gdb-csl-sourcerygxx-4_1-7:1.202.2.6
	gdb-csl-arm-2006q1-6:1.202.2.5
	gdb-csl-sourcerygxx-4_1-6:1.202.2.5
	gdb-csl-symbian-6_4_50_20060226-10:1.202.2.3.2.14
	gdb-csl-symbian-6_4_50_20060226-9:1.202.2.3.2.12
	gdb-csl-symbian-6_4_50_20060226-8:1.202.2.3.2.9
	gdb-csl-coldfire-4_1-11:1.202.2.3
	gdb-csl-sourcerygxx-3_4_4-19:1.202.2.3
	gdb-csl-coldfire-4_1-10:1.202.2.3
	gdb_6_5-branch:1.210.0.4
	gdb_6_5-2006-05-14-branchpoint:1.210
	gdb-csl-sourcerygxx-4_1-5:1.202.2.3
	nickrob-async-20060513-branch:1.210.0.2
	nickrob-async-20060513-branchpoint:1.210
	gdb-csl-sourcerygxx-4_1-4:1.202.2.3
	msnyder-reverse-20060502-branch:1.209.0.2
	msnyder-reverse-20060502-branchpoint:1.209
	gdb-csl-morpho-4_1-4:1.202.2.3
	gdb-csl-sourcerygxx-3_4_4-17:1.202.2.3
	readline_5_1-import-branch:1.208.0.2
	readline_5_1-import-branchpoint:1.208
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.202.2.3
	gdb-csl-symbian-20060226-branch:1.202.2.3.0.2
	gdb-csl-symbian-20060226-branchpoint:1.202.2.3
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.202.2.3
	msnyder-reverse-20060331-branch:1.203.0.2
	msnyder-reverse-20060331-branchpoint:1.203
	gdb-csl-available-20060303-branch:1.202.0.4
	gdb-csl-available-20060303-branchpoint:1.202
	gdb-csl-20060226-branch:1.202.0.2
	gdb-csl-20060226-branchpoint:1.202
	gdb_6_4-20051202-release:1.195
	msnyder-fork-checkpoint-branch:1.195.0.8
	msnyder-fork-checkpoint-branchpoint:1.195
	gdb-csl-gxxpro-6_3-branch:1.195.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.195
	gdb_6_4-branch:1.195.0.4
	gdb_6_4-2005-11-01-branchpoint:1.195
	gdb-csl-arm-20051020-branch:1.195.0.2
	gdb-csl-arm-20051020-branchpoint:1.195
	msnyder-tracepoint-checkpoint-branch:1.192.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.192
	gdb-csl-arm-20050325-2005-q1b:1.178.2.1
	gdb-csl-arm-20050325-2005-q1a:1.178.2.1
	csl-arm-20050325-branch:1.178.0.2
	csl-arm-20050325-branchpoint:1.178
	gdb-post-i18n-errorwarning-20050211:1.165
	gdb-pre-i18n-errorwarning-20050211:1.164
	gdb_6_3-20041109-release:1.151.2.1
	gdb_6_3-branch:1.151.0.2
	gdb_6_3-20041019-branchpoint:1.151
	drow_intercu-merge-20040921:1.147
	drow_intercu-merge-20040915:1.147
	jimb-gdb_6_2-e500-branch:1.138.0.6
	jimb-gdb_6_2-e500-branchpoint:1.138
	gdb_6_2-20040730-release:1.138
	gdb_6_2-branch:1.138.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.138
	gdb_6_1_1-20040616-release:1.130
	gdb_6_1-2004-04-05-release:1.130
	drow_intercu-merge-20040402:1.132
	drow_intercu-merge-20040327:1.132
	ezannoni_pie-20040323-branch:1.132.0.2
	ezannoni_pie-20040323-branchpoint:1.132
	cagney_tramp-20040321-mergepoint:1.131
	cagney_tramp-20040309-branch:1.130.0.4
	cagney_tramp-20040309-branchpoint:1.130
	gdb_6_1-branch:1.130.0.2
	gdb_6_1-2004-03-01-gmt-branchpoint:1.130
	drow_intercu-20040221-branch:1.129.0.2
	drow_intercu-20040221-branchpoint:1.129
	cagney_bfdfile-20040213-branch:1.128.0.2
	cagney_bfdfile-20040213-branchpoint:1.128
	drow-cplus-merge-20040208:1.128
	carlton_dictionary-20040126-merge:1.127
	cagney_bigcore-20040122-branch:1.127.0.2
	cagney_bigcore-20040122-branchpoint:1.127
	drow-cplus-merge-20040113:1.124
	drow-cplus-merge-20031224:1.124
	drow-cplus-merge-20031220:1.124
	carlton_dictionary-20031215-merge:1.124
	drow-cplus-merge-20031214:1.124
	carlton-dictionary-20031111-merge:1.122
	gdb_6_0-2003-10-04-release:1.107.2.3
	kettenis_sparc-20030918-branch:1.114.0.2
	kettenis_sparc-20030918-branchpoint:1.114
	carlton_dictionary-20030917-merge:1.114
	ezannoni_pie-20030916-branchpoint:1.113
	ezannoni_pie-20030916-branch:1.113.0.4
	cagney_x86i386-20030821-branch:1.113.0.2
	cagney_x86i386-20030821-branchpoint:1.113
	carlton_dictionary-20030805-merge:1.113
	carlton_dictionary-20030627-merge:1.107
	gdb_6_0-branch:1.107.0.2
	gdb_6_0-2003-06-23-branchpoint:1.107
	jimb-ppc64-linux-20030613-branch:1.105.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.105
	cagney_convert-20030606-branch:1.101.0.2
	cagney_convert-20030606-branchpoint:1.101
	cagney_writestrings-20030508-branch:1.98.0.4
	cagney_writestrings-20030508-branchpoint:1.98
	jimb-ppc64-linux-20030528-branch:1.100.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.100
	carlton_dictionary-20030523-merge:1.100
	cagney_fileio-20030521-branch:1.100.0.2
	cagney_fileio-20030521-branchpoint:1.100
	kettenis_i386newframe-20030517-mergepoint:1.100
	jimb-ppc64-linux-20030509-branch:1.98.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.98
	kettenis_i386newframe-20030504-mergepoint:1.96
	carlton_dictionary-20030430-merge:1.96
	kettenis_i386newframe-20030419-branch:1.96.0.2
	kettenis_i386newframe-20030419-branchpoint:1.96
	carlton_dictionary-20030416-merge:1.95
	cagney_frameaddr-20030409-mergepoint:1.95
	kettenis_i386newframe-20030406-branch:1.95.0.14
	kettenis_i386newframe-20030406-branchpoint:1.95
	cagney_frameaddr-20030403-branchpoint:1.95
	cagney_frameaddr-20030403-branch:1.95.0.12
	cagney_framebase-20030330-mergepoint:1.95
	cagney_framebase-20030326-branch:1.95.0.10
	cagney_framebase-20030326-branchpoint:1.95
	cagney_lazyid-20030317-branch:1.95.0.8
	cagney_lazyid-20030317-branchpoint:1.95
	kettenis-i386newframe-20030316-mergepoint:1.95
	offbyone-20030313-branch:1.95.0.6
	offbyone-20030313-branchpoint:1.95
	kettenis-i386newframe-20030308-branch:1.95.0.4
	kettenis-i386newframe-20030308-branchpoint:1.95
	carlton_dictionary-20030305-merge:1.95
	cagney_offbyone-20030303-branch:1.95.0.2
	cagney_offbyone-20030303-branchpoint:1.95
	carlton_dictionary-20030207-merge:1.94
	interps-20030203-mergepoint:1.94
	interps-20030202-branch:1.94.0.4
	interps-20030202-branchpoint:1.94
	cagney-unwind-20030108-branch:1.94.0.2
	cagney-unwind-20030108-branchpoint:1.94
	carlton_dictionary-20021223-merge:1.94
	gdb_5_3-2002-12-12-release:1.93
	carlton_dictionary-20021115-merge:1.94
	kseitz_interps-20021105-merge:1.93
	kseitz_interps-20021103-merge:1.93
	drow-cplus-merge-20021020:1.93
	drow-cplus-merge-20021025:1.93
	carlton_dictionary-20021025-merge:1.93
	carlton_dictionary-20021011-merge:1.93
	drow-cplus-branch:1.93.0.10
	drow-cplus-branchpoint:1.93
	kseitz_interps-20020930-merge:1.93
	carlton_dictionary-20020927-merge:1.93
	carlton_dictionary-branch:1.93.0.8
	carlton_dictionary-20020920-branchpoint:1.93
	gdb_5_3-branch:1.93.0.6
	gdb_5_3-2002-09-04-branchpoint:1.93
	kseitz_interps-20020829-merge:1.93
	cagney_sysregs-20020825-branch:1.93.0.4
	cagney_sysregs-20020825-branchpoint:1.93
	readline_4_3-import-branch:1.93.0.2
	readline_4_3-import-branchpoint:1.93
	gdb_5_2_1-2002-07-23-release:1.77
	kseitz_interps-20020528-branch:1.84.0.2
	kseitz_interps-20020528-branchpoint:1.84
	cagney_regbuf-20020515-branch:1.81.0.2
	cagney_regbuf-20020515-branchpoint:1.81
	jimb-macro-020506-branch:1.79.0.2
	jimb-macro-020506-branchpoint:1.79
	gdb_5_2-2002-04-29-release:1.77
	gdb_5_2-branch:1.77.0.2
	gdb_5_2-2002-03-03-branchpoint:1.77
	gdb_5_1_1-2002-01-24-release:1.61.2.1
	gdb_5_1_0_1-2002-01-03-release:1.61.2.1
	cygnus_cvs_20020108_pre:1.72
	gdb_5_1_0_1-2002-01-03-branchpoint:1.61.2.1
	gdb_5_1_0_1-2002-01-03-branch:1.61.2.1.0.4
	gdb_5_1-2001-11-21-release:1.61.2.1
	gdb_s390-2001-09-26-branch:1.61.2.1.0.2
	gdb_s390-2001-09-26-branchpoint:1.61.2.1
	gdb_5_1-2001-07-29-branch:1.61.0.2
	gdb_5_1-2001-07-29-branchpoint:1.61
	dberlin-typesystem-branch:1.56.0.2
	dberlin-typesystem-branchpoint:1.56
	gdb-post-ptid_t-2001-05-03:1.47
	gdb-pre-ptid_t-2001-05-03:1.46
	insight-precleanup-2001-01-01:1.32
	gdb-post-protoization-2000-07-29:1.16
	gdb-pre-protoization-2000-07-29:1.15
	gdb-premipsmulti-2000-06-06-branch:1.12.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.12
	gdb-post-params-removal-2000-06-04:1.12
	gdb-pre-params-removal-2000-06-04:1.11
	gdb-post-params-removal-2000-05-28:1.11
	gdb-pre-params-removal-2000-05-28:1.10
	gdb_5_0-2000-05-19-release:1.7
	gdb_4_18_2-2000-05-18-release:1.7
	gdb_4_95_1-2000-05-11-snapshot:1.7
	gdb_4_95_0-2000-04-27-snapshot:1.7
	gdb_5_0-2000-04-10-branch:1.7.0.2
	gdb_5_0-2000-04-10-branchpoint:1.7
	repo-unification-2000-02-06:1.1.1.32
	insight-2000-02-04:1.1.1.32
	gdb-2000-02-04:1.1.1.32
	gdb-2000-02-02:1.1.1.32
	gdb-2000-02-01:1.1.1.31
	gdb-2000-01-31:1.1.1.30
	gdb-2000-01-26:1.1.1.30
	gdb-2000-01-24:1.1.1.30
	gdb-2000-01-17:1.1.1.30
	gdb-2000-01-10:1.1.1.30
	gdb-2000-01-05:1.1.1.29
	gdb-1999-12-21:1.1.1.29
	gdb-1999-12-13:1.1.1.28
	gdb-1999-12-07:1.1.1.27
	gdb-1999-12-06:1.1.1.27
	gdb-1999-11-16:1.1.1.26
	gdb-1999-11-08:1.1.1.26
	gdb-1999-11-01:1.1.1.25
	gdb-1999-10-25:1.1.1.25
	gdb-1999-10-18:1.1.1.24
	gdb-1999-10-11:1.1.1.23
	gdb-1999-10-04:1.1.1.22
	gdb-1999-09-28:1.1.1.21
	gdb-1999-09-21:1.1.1.20
	gdb-1999-09-13:1.1.1.19
	gdb-1999-09-08:1.1.1.18
	gdb-1999-08-30:1.1.1.17
	gdb-1999-08-23:1.1.1.16
	gdb-1999-08-16:1.1.1.15
	gdb-1999-08-09:1.1.1.14
	gdb-1999-08-02:1.1.1.13
	gdb-1999-07-26:1.1.1.13
	gdb-1999-07-19:1.1.1.12
	gdb-1999-07-12:1.1.1.11
	gdb-post-reformat-19990707:1.1.1.10
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.10
	gdb-pre-reformat-19990707:1.1.1.9
	gdb-1999-07-07:1.1.1.9
	gdb-1999-07-05:1.1.1.8
	gdb-1999-06-28:1.1.1.7
	gdb-1999-06-21:1.1.1.6
	gdb-1999-06-14:1.1.1.6
	gdb-1999-06-07:1.1.1.5
	gdb-1999-06-01:1.1.1.4
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.4
	gdb-1999-05-19:1.1.1.3
	gdb-1999-05-10:1.1.1.3
	gdb-19990504:1.1.1.3
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.583
date	2013.10.11.03.01.09;	author qiyao;	state Exp;
branches;
next	1.582;

1.582
date	2013.10.11.02.54.44;	author qiyao;	state Exp;
branches;
next	1.581;

1.581
date	2013.10.04.07.42.06;	author qiyao;	state Exp;
branches;
next	1.580;

1.580
date	2013.10.04.07.32.56;	author qiyao;	state Exp;
branches;
next	1.579;

1.579
date	2013.09.27.15.29.06;	author palves;	state Exp;
branches;
next	1.578;

1.578
date	2013.09.27.13.23.32;	author palves;	state Exp;
branches;
next	1.577;

1.577
date	2013.08.23.13.12.17;	author palves;	state Exp;
branches;
next	1.576;

1.576
date	2013.08.14.18.17.50;	author tromey;	state Exp;
branches;
next	1.575;

1.575
date	2013.08.14.18.17.13;	author tromey;	state Exp;
branches;
next	1.574;

1.574
date	2013.08.14.18.16.30;	author tromey;	state Exp;
branches;
next	1.573;

1.573
date	2013.08.14.18.15.48;	author tromey;	state Exp;
branches;
next	1.572;

1.572
date	2013.08.14.18.15.01;	author tromey;	state Exp;
branches;
next	1.571;

1.571
date	2013.08.14.18.08.48;	author tromey;	state Exp;
branches;
next	1.570;

1.570
date	2013.08.14.18.07.45;	author tromey;	state Exp;
branches;
next	1.569;

1.569
date	2013.08.14.18.06.49;	author tromey;	state Exp;
branches;
next	1.568;

1.568
date	2013.08.14.18.05.51;	author tromey;	state Exp;
branches;
next	1.567;

1.567
date	2013.08.14.18.04.52;	author tromey;	state Exp;
branches;
next	1.566;

1.566
date	2013.08.14.18.03.50;	author tromey;	state Exp;
branches;
next	1.565;

1.565
date	2013.08.14.18.03.00;	author tromey;	state Exp;
branches;
next	1.564;

1.564
date	2013.08.14.18.01.33;	author tromey;	state Exp;
branches;
next	1.563;

1.563
date	2013.08.14.18.00.34;	author tromey;	state Exp;
branches;
next	1.562;

1.562
date	2013.08.14.17.58.53;	author tromey;	state Exp;
branches;
next	1.561;

1.561
date	2013.08.14.17.57.09;	author tromey;	state Exp;
branches;
next	1.560;

1.560
date	2013.08.05.15.03.06;	author jkratoch;	state Exp;
branches;
next	1.559;

1.559
date	2013.07.31.12.44.33;	author aburgess;	state Exp;
branches;
next	1.558;

1.558
date	2013.06.30.17.14.59;	author jkratoch;	state Exp;
branches;
next	1.557;

1.557
date	2013.06.26.08.17.26;	author qiyao;	state Exp;
branches;
next	1.556;

1.556
date	2013.06.25.13.01.26;	author qiyao;	state Exp;
branches;
next	1.555;

1.555
date	2013.06.07.00.19.35;	author qiyao;	state Exp;
branches;
next	1.554;

1.554
date	2013.06.04.15.12.52;	author sergiodj;	state Exp;
branches;
next	1.553;

1.553
date	2013.06.04.13.10.53;	author gary;	state Exp;
branches;
next	1.552;

1.552
date	2013.05.30.09.29.18;	author qiyao;	state Exp;
branches;
next	1.551;

1.551
date	2013.05.30.00.40.21;	author qiyao;	state Exp;
branches;
next	1.550;

1.550
date	2013.05.29.11.57.48;	author palves;	state Exp;
branches;
next	1.549;

1.549
date	2013.05.23.17.15.34;	author palves;	state Exp;
branches;
next	1.548;

1.548
date	2013.05.23.17.13.57;	author palves;	state Exp;
branches;
next	1.547;

1.547
date	2013.05.14.20.33.36;	author tromey;	state Exp;
branches;
next	1.546;

1.546
date	2013.05.10.14.31.05;	author palves;	state Exp;
branches;
next	1.545;

1.545
date	2013.05.10.13.59.45;	author palves;	state Exp;
branches;
next	1.544;

1.544
date	2013.04.22.16.46.15;	author tromey;	state Exp;
branches;
next	1.543;

1.543
date	2013.04.19.15.27.06;	author palves;	state Exp;
branches;
next	1.542;

1.542
date	2013.04.19.15.09.46;	author palves;	state Exp;
branches;
next	1.541;

1.541
date	2013.04.12.16.04.07;	author jkratoch;	state Exp;
branches;
next	1.540;

1.540
date	2013.04.11.13.14.04;	author jkratoch;	state Exp;
branches;
next	1.539;

1.539
date	2013.04.09.12.18.34;	author palves;	state Exp;
branches;
next	1.538;

1.538
date	2013.04.07.10.23.34;	author qiyao;	state Exp;
branches;
next	1.537;

1.537
date	2013.04.02.14.09.08;	author jkratoch;	state Exp;
branches;
next	1.536;

1.536
date	2013.04.02.13.51.07;	author palves;	state Exp;
branches;
next	1.535;

1.535
date	2013.03.28.21.58.03;	author palves;	state Exp;
branches;
next	1.534;

1.534
date	2013.03.27.18.20.10;	author jkratoch;	state Exp;
branches;
next	1.533;

1.533
date	2013.03.26.20.19.31;	author palves;	state Exp;
branches;
next	1.532;

1.532
date	2013.03.22.20.39.28;	author jkratoch;	state Exp;
branches;
next	1.531;

1.531
date	2013.03.22.19.07.03;	author jkratoch;	state Exp;
branches;
next	1.530;

1.530
date	2013.03.20.15.46.24;	author jkratoch;	state Exp;
branches;
next	1.529;

1.529
date	2013.03.13.18.34.54;	author palves;	state Exp;
branches;
next	1.528;

1.528
date	2013.03.11.12.20.52;	author abidh;	state Exp;
branches
	1.528.2.1;
next	1.527;

1.527
date	2013.03.11.08.35.08;	author mmetzger;	state Exp;
branches;
next	1.526;

1.526
date	2013.03.08.15.06.34;	author abidh;	state Exp;
branches;
next	1.525;

1.525
date	2013.03.07.17.29.31;	author palves;	state Exp;
branches;
next	1.524;

1.524
date	2013.02.15.09.47.46;	author abidh;	state Exp;
branches;
next	1.523;

1.523
date	2013.02.15.03.37.12;	author qiyao;	state Exp;
branches;
next	1.522;

1.522
date	2013.01.25.17.25.59;	author palves;	state Exp;
branches;
next	1.521;

1.521
date	2013.01.14.18.06.21;	author palves;	state Exp;
branches;
next	1.520;

1.520
date	2013.01.01.06.32.50;	author brobecke;	state Exp;
branches;
next	1.519;

1.519
date	2012.12.15.03.50.22;	author qiyao;	state Exp;
branches;
next	1.518;

1.518
date	2012.12.15.03.34.03;	author qiyao;	state Exp;
branches;
next	1.517;

1.517
date	2012.12.15.03.14.22;	author qiyao;	state Exp;
branches;
next	1.516;

1.516
date	2012.11.26.13.19.18;	author qiyao;	state Exp;
branches;
next	1.515;

1.515
date	2012.11.09.19.58.00;	author tromey;	state Exp;
branches;
next	1.514;

1.514
date	2012.11.06.15.59.17;	author muller;	state Exp;
branches;
next	1.513;

1.513
date	2012.11.02.18.53.54;	author tromey;	state Exp;
branches;
next	1.512;

1.512
date	2012.10.23.06.20.49;	author qiyao;	state Exp;
branches;
next	1.511;

1.511
date	2012.09.22.13.04.55;	author qiyao;	state Exp;
branches;
next	1.510;

1.510
date	2012.09.12.20.01.10;	author wrighton;	state Exp;
branches;
next	1.509;

1.509
date	2012.08.28.14.08.41;	author qiyao;	state Exp;
branches;
next	1.508;

1.508
date	2012.08.22.17.48.52;	author tromey;	state Exp;
branches;
next	1.507;

1.507
date	2012.08.16.07.21.59;	author qiyao;	state Exp;
branches;
next	1.506;

1.506
date	2012.08.09.12.53.43;	author qiyao;	state Exp;
branches;
next	1.505;

1.505
date	2012.07.23.14.57.55;	author tromey;	state Exp;
branches;
next	1.504;

1.504
date	2012.07.19.16.01.13;	author qiyao;	state Exp;
branches;
next	1.503;

1.503
date	2012.07.18.19.34.57;	author tromey;	state Exp;
branches;
next	1.502;

1.502
date	2012.07.02.15.29.34;	author shebs;	state Exp;
branches;
next	1.501;

1.501
date	2012.06.28.16.34.03;	author palves;	state Exp;
branches;
next	1.500;

1.500
date	2012.06.05.21.22.31;	author jkratoch;	state Exp;
branches;
next	1.499;

1.499
date	2012.05.24.16.51.35;	author palves;	state Exp;
branches;
next	1.498;

1.498
date	2012.05.24.16.39.11;	author palves;	state Exp;
branches;
next	1.497;

1.497
date	2012.05.16.22.10.49;	author sergiodj;	state Exp;
branches;
next	1.496;

1.496
date	2012.04.12.00.56.05;	author qiyao;	state Exp;
branches;
next	1.495;

1.495
date	2012.03.20.18.14.16;	author palves;	state Exp;
branches;
next	1.494;

1.494
date	2012.03.13.13.25.50;	author palves;	state Exp;
branches;
next	1.493;

1.493
date	2012.03.08.12.49.15;	author qiyao;	state Exp;
branches;
next	1.492;

1.492
date	2012.03.07.19.25.37;	author palves;	state Exp;
branches;
next	1.491;

1.491
date	2012.03.05.11.37.32;	author gingold;	state Exp;
branches;
next	1.490;

1.490
date	2012.03.03.09.51.28;	author qiyao;	state Exp;
branches;
next	1.489;

1.489
date	2012.03.03.03.32.44;	author qiyao;	state Exp;
branches;
next	1.488;

1.488
date	2012.03.01.21.13.59;	author palves;	state Exp;
branches;
next	1.487;

1.487
date	2012.03.01.21.07.31;	author palves;	state Exp;
branches;
next	1.486;

1.486
date	2012.02.24.23.48.37;	author macro;	state Exp;
branches;
next	1.485;

1.485
date	2012.02.24.15.10.59;	author luisgpm;	state Exp;
branches;
next	1.484;

1.484
date	2012.02.24.15.09.41;	author luisgpm;	state Exp;
branches;
next	1.483;

1.483
date	2012.02.15.12.48.54;	author palves;	state Exp;
branches;
next	1.482;

1.482
date	2012.02.03.22.52.32;	author philippe;	state Exp;
branches;
next	1.481;

1.481
date	2012.02.02.18.04.29;	author palves;	state Exp;
branches;
next	1.480;

1.480
date	2012.01.28.18.08.18;	author jkratoch;	state Exp;
branches;
next	1.479;

1.479
date	2012.01.24.14.19.03;	author palves;	state Exp;
branches;
next	1.478;

1.478
date	2012.01.20.09.47.32;	author uweigand;	state Exp;
branches;
next	1.477;

1.477
date	2012.01.20.09.45.50;	author uweigand;	state Exp;
branches;
next	1.476;

1.476
date	2012.01.20.09.44.34;	author uweigand;	state Exp;
branches;
next	1.475;

1.475
date	2012.01.20.09.42.44;	author uweigand;	state Exp;
branches;
next	1.474;

1.474
date	2012.01.04.08.17.10;	author brobecke;	state Exp;
branches;
next	1.473;

1.473
date	2011.12.02.22.26.51;	author jkratoch;	state Exp;
branches
	1.473.2.1;
next	1.472;

1.472
date	2011.11.27.17.39.30;	author brobecke;	state Exp;
branches;
next	1.471;

1.471
date	2011.11.20.23.59.47;	author shebs;	state Exp;
branches;
next	1.470;

1.470
date	2011.11.18.15.38.58;	author tromey;	state Exp;
branches;
next	1.469;

1.469
date	2011.11.14.20.07.20;	author shebs;	state Exp;
branches;
next	1.468;

1.468
date	2011.11.14.15.18.54;	author qiyao;	state Exp;
branches;
next	1.467;

1.467
date	2011.11.14.14.11.35;	author qiyao;	state Exp;
branches;
next	1.466;

1.466
date	2011.11.02.23.44.19;	author shebs;	state Exp;
branches;
next	1.465;

1.465
date	2011.10.13.13.15.16;	author luisgpm;	state Exp;
branches;
next	1.464;

1.464
date	2011.10.07.12.06.46;	author uweigand;	state Exp;
branches;
next	1.463;

1.463
date	2011.09.14.12.26.29;	author palves;	state Exp;
branches;
next	1.462;

1.462
date	2011.09.07.10.34.15;	author palves;	state Exp;
branches;
next	1.461;

1.461
date	2011.08.14.13.03.12;	author qiyao;	state Exp;
branches;
next	1.460;

1.460
date	2011.08.04.19.10.12;	author palves;	state Exp;
branches;
next	1.459;

1.459
date	2011.07.26.20.57.53;	author philippe;	state Exp;
branches;
next	1.458;

1.458
date	2011.07.25.11.24.44;	author palves;	state Exp;
branches;
next	1.457;

1.457
date	2011.07.15.02.07.43;	author teawater;	state Exp;
branches;
next	1.456;

1.456
date	2011.07.14.04.46.42;	author teawater;	state Exp;
branches;
next	1.455;

1.455
date	2011.07.13.17.07.16;	author jkratoch;	state Exp;
branches;
next	1.454;

1.454
date	2011.07.07.13.32.55;	author teawater;	state Exp;
branches;
next	1.453;

1.453
date	2011.07.06.02.43.12;	author teawater;	state Exp;
branches;
next	1.452;

1.452
date	2011.06.23.15.08.01;	author qiyao;	state Exp;
branches;
next	1.451;

1.451
date	2011.06.16.02.19.44;	author teawater;	state Exp;
branches;
next	1.450;

1.450
date	2011.06.15.14.40.22;	author teawater;	state Exp;
branches;
next	1.449;

1.449
date	2011.06.06.12.47.07;	author palves;	state Exp;
branches;
next	1.448;

1.448
date	2011.06.03.23.47.46;	author brobecke;	state Exp;
branches;
next	1.447;

1.447
date	2011.05.30.21.16.35;	author palves;	state Exp;
branches;
next	1.446;

1.446
date	2011.05.12.12.09.16;	author kcy;	state Exp;
branches;
next	1.445;

1.445
date	2011.04.27.13.29.14;	author uweigand;	state Exp;
branches;
next	1.444;

1.444
date	2011.04.26.15.40.57;	author tromey;	state Exp;
branches;
next	1.443;

1.443
date	2011.04.20.17.54.08;	author palves;	state Exp;
branches;
next	1.442;

1.442
date	2011.04.04.18.13.04;	author tromey;	state Exp;
branches;
next	1.441;

1.441
date	2011.03.18.14.22.34;	author muller;	state Exp;
branches
	1.441.2.1;
next	1.440;

1.440
date	2011.03.16.17.59.02;	author muller;	state Exp;
branches;
next	1.439;

1.439
date	2011.03.14.15.43.50;	author muller;	state Exp;
branches;
next	1.438;

1.438
date	2011.03.08.12.46.51;	author palves;	state Exp;
branches;
next	1.437;

1.437
date	2011.03.04.20.02.50;	author msnyder;	state Exp;
branches;
next	1.436;

1.436
date	2011.03.01.00.34.27;	author msnyder;	state Exp;
branches;
next	1.435;

1.435
date	2011.02.21.15.56.16;	author muller;	state Exp;
branches;
next	1.434;

1.434
date	2011.02.14.11.22.29;	author palves;	state Exp;
branches;
next	1.433;

1.433
date	2011.02.14.11.13.11;	author palves;	state Exp;
branches;
next	1.432;

1.432
date	2011.02.02.16.12.58;	author palves;	state Exp;
branches;
next	1.431;

1.431
date	2011.01.25.11.54.00;	author palves;	state Exp;
branches;
next	1.430;

1.430
date	2011.01.25.09.49.59;	author palves;	state Exp;
branches;
next	1.429;

1.429
date	2011.01.11.15.10.01;	author msnyder;	state Exp;
branches;
next	1.428;

1.428
date	2011.01.10.20.38.50;	author msnyder;	state Exp;
branches;
next	1.427;

1.427
date	2011.01.05.22.22.50;	author msnyder;	state Exp;
branches;
next	1.426;

1.426
date	2011.01.01.15.33.13;	author brobecke;	state Exp;
branches;
next	1.425;

1.425
date	2010.11.04.04.48.21;	author teawater;	state Exp;
branches;
next	1.424;

1.424
date	2010.11.02.01.37.32;	author jkratoch;	state Exp;
branches;
next	1.423;

1.423
date	2010.10.20.09.10.48;	author vprus;	state Exp;
branches;
next	1.422;

1.422
date	2010.10.17.18.24.47;	author jkratoch;	state Exp;
branches;
next	1.421;

1.421
date	2010.07.28.20.20.26;	author tromey;	state Exp;
branches;
next	1.420;

1.420
date	2010.07.28.18.04.19;	author brobecke;	state Exp;
branches;
next	1.419;

1.419
date	2010.07.07.16.15.16;	author bauermann;	state Exp;
branches
	1.419.2.1;
next	1.418;

1.418
date	2010.07.01.10.36.09;	author palves;	state Exp;
branches;
next	1.417;

1.417
date	2010.06.12.00.05.21;	author shebs;	state Exp;
branches;
next	1.416;

1.416
date	2010.06.08.16.51.33;	author msnyder;	state Exp;
branches;
next	1.415;

1.415
date	2010.06.02.22.21.53;	author brobecke;	state Exp;
branches;
next	1.414;

1.414
date	2010.05.27.22.06.00;	author palves;	state Exp;
branches;
next	1.413;

1.413
date	2010.05.26.18.19.28;	author palves;	state Exp;
branches;
next	1.412;

1.412
date	2010.05.16.21.07.22;	author msnyder;	state Exp;
branches;
next	1.411;

1.411
date	2010.05.07.14.01.55;	author palves;	state Exp;
branches;
next	1.410;

1.410
date	2010.05.07.14.00.30;	author palves;	state Exp;
branches;
next	1.409;

1.409
date	2010.05.06.00.15.29;	author palves;	state Exp;
branches;
next	1.408;

1.408
date	2010.05.05.23.39.56;	author palves;	state Exp;
branches;
next	1.407;

1.407
date	2010.05.05.22.27.15;	author msnyder;	state Exp;
branches;
next	1.406;

1.406
date	2010.05.05.20.46.06;	author msnyder;	state Exp;
branches;
next	1.405;

1.405
date	2010.05.05.15.05.57;	author muller;	state Exp;
branches;
next	1.404;

1.404
date	2010.05.04.21.09.24;	author kettenis;	state Exp;
branches;
next	1.403;

1.403
date	2010.05.03.02.13.01;	author palves;	state Exp;
branches;
next	1.402;

1.402
date	2010.04.16.07.49.35;	author muller;	state Exp;
branches;
next	1.401;

1.401
date	2010.04.13.16.08.28;	author palves;	state Exp;
branches;
next	1.400;

1.400
date	2010.04.09.03.00.57;	author shebs;	state Exp;
branches;
next	1.399;

1.399
date	2010.04.02.01.18.34;	author palves;	state Exp;
branches;
next	1.398;

1.398
date	2010.04.01.23.13.24;	author hjl;	state Exp;
branches;
next	1.397;

1.397
date	2010.03.31.14.36.41;	author muller;	state Exp;
branches;
next	1.396;

1.396
date	2010.03.30.15.45.13;	author hjl;	state Exp;
branches;
next	1.395;

1.395
date	2010.03.29.23.45.05;	author shebs;	state Exp;
branches;
next	1.394;

1.394
date	2010.03.24.01.12.13;	author palves;	state Exp;
branches;
next	1.393;

1.393
date	2010.03.23.22.05.45;	author vprus;	state Exp;
branches;
next	1.392;

1.392
date	2010.03.23.22.01.46;	author vprus;	state Exp;
branches;
next	1.391;

1.391
date	2010.03.23.21.32.27;	author vprus;	state Exp;
branches;
next	1.390;

1.390
date	2010.03.18.21.23.33;	author shebs;	state Exp;
branches;
next	1.389;

1.389
date	2010.03.07.14.36.44;	author brobecke;	state Exp;
branches;
next	1.388;

1.388
date	2010.03.04.00.32.50;	author shebs;	state Exp;
branches;
next	1.387;

1.387
date	2010.02.24.17.01.58;	author palves;	state Exp;
branches;
next	1.386;

1.386
date	2010.02.22.23.35.16;	author palves;	state Exp;
branches;
next	1.385;

1.385
date	2010.02.15.17.35.49;	author jkratoch;	state Exp;
branches
	1.385.2.1;
next	1.384;

1.384
date	2010.02.03.18.30.04;	author hjl;	state Exp;
branches;
next	1.383;

1.383
date	2010.02.03.16.43.03;	author hjl;	state Exp;
branches;
next	1.382;

1.382
date	2010.02.01.16.09.20;	author drow;	state Exp;
branches;
next	1.381;

1.381
date	2010.01.15.22.37.17;	author shebs;	state Exp;
branches;
next	1.380;

1.380
date	2010.01.12.21.40.24;	author vprus;	state Exp;
branches;
next	1.379;

1.379
date	2010.01.07.19.17.46;	author shebs;	state Exp;
branches;
next	1.378;

1.378
date	2010.01.06.20.31.28;	author shebs;	state Exp;
branches;
next	1.377;

1.377
date	2010.01.06.04.20.26;	author shebs;	state Exp;
branches;
next	1.376;

1.376
date	2010.01.01.07.31.40;	author brobecke;	state Exp;
branches;
next	1.375;

1.375
date	2009.11.13.22.36.30;	author drow;	state Exp;
branches;
next	1.374;

1.374
date	2009.10.28.15.01.26;	author brobecke;	state Exp;
branches;
next	1.373;

1.373
date	2009.10.19.09.51.41;	author palves;	state Exp;
branches;
next	1.372;

1.372
date	2009.09.10.22.47.56;	author msnyder;	state Exp;
branches;
next	1.371;

1.371
date	2009.09.10.21.02.46;	author msnyder;	state Exp;
branches;
next	1.370;

1.370
date	2009.08.18.16.17.16;	author tromey;	state Exp;
branches;
next	1.369;

1.369
date	2009.08.14.00.32.32;	author palves;	state Exp;
branches;
next	1.368;

1.368
date	2009.08.13.18.27.56;	author palves;	state Exp;
branches;
next	1.367;

1.367
date	2009.08.12.23.00.27;	author msnyder;	state Exp;
branches;
next	1.366;

1.366
date	2009.07.31.22.15.15;	author msnyder;	state Exp;
branches;
next	1.365;

1.365
date	2009.07.31.21.33.39;	author msnyder;	state Exp;
branches;
next	1.364;

1.364
date	2009.07.14.21.40.30;	author shebs;	state Exp;
branches;
next	1.363;

1.363
date	2009.07.14.14.53.41;	author uweigand;	state Exp;
branches;
next	1.362;

1.362
date	2009.07.02.17.21.06;	author uweigand;	state Exp;
branches;
next	1.361;

1.361
date	2009.07.02.17.12.26;	author uweigand;	state Exp;
branches;
next	1.360;

1.360
date	2009.06.22.16.03.33;	author hjl;	state Exp;
branches;
next	1.359;

1.359
date	2009.06.07.16.46.48;	author palves;	state Exp;
branches;
next	1.358;

1.358
date	2009.05.22.00.52.05;	author palves;	state Exp;
branches;
next	1.357;

1.357
date	2009.05.21.16.00.13;	author palves;	state Exp;
branches;
next	1.356;

1.356
date	2009.05.21.15.48.41;	author palves;	state Exp;
branches;
next	1.355;

1.355
date	2009.05.19.00.23.49;	author palves;	state Exp;
branches;
next	1.354;

1.354
date	2009.04.16.19.31.03;	author palves;	state Exp;
branches;
next	1.353;

1.353
date	2009.04.01.17.42.03;	author palves;	state Exp;
branches;
next	1.352;

1.352
date	2009.03.31.15.23.57;	author palves;	state Exp;
branches;
next	1.351;

1.351
date	2009.03.28.01.15.13;	author palves;	state Exp;
branches;
next	1.350;

1.350
date	2009.03.25.22.27.49;	author palves;	state Exp;
branches;
next	1.349;

1.349
date	2009.03.25.21.42.34;	author palves;	state Exp;
branches;
next	1.348;

1.348
date	2009.03.18.02.24.02;	author palves;	state Exp;
branches;
next	1.347;

1.347
date	2009.03.18.01.29.27;	author palves;	state Exp;
branches;
next	1.346;

1.346
date	2009.03.17.19.28.09;	author brobecke;	state Exp;
branches;
next	1.345;

1.345
date	2009.03.14.01.38.07;	author palves;	state Exp;
branches;
next	1.344;

1.344
date	2009.03.04.22.50.59;	author palves;	state Exp;
branches;
next	1.343;

1.343
date	2009.02.25.02.14.22;	author teawater;	state Exp;
branches;
next	1.342;

1.342
date	2009.02.23.00.03.50;	author palves;	state Exp;
branches;
next	1.341;

1.341
date	2009.02.21.16.14.48;	author palves;	state Exp;
branches;
next	1.340;

1.340
date	2009.02.06.22.59.00;	author palves;	state Exp;
branches;
next	1.339;

1.339
date	2009.02.06.22.21.26;	author palves;	state Exp;
branches;
next	1.338;

1.338
date	2009.02.06.01.23.00;	author palves;	state Exp;
branches;
next	1.337;

1.337
date	2009.01.14.15.00.19;	author palves;	state Exp;
branches;
next	1.336;

1.336
date	2009.01.03.05.57.53;	author brobecke;	state Exp;
branches;
next	1.335;

1.335
date	2008.12.12.13.45.43;	author palves;	state Exp;
branches;
next	1.334;

1.334
date	2008.12.12.01.08.29;	author palves;	state Exp;
branches;
next	1.333;

1.333
date	2008.12.12.00.12.03;	author palves;	state Exp;
branches;
next	1.332;

1.332
date	2008.12.09.16.36.15;	author jkratoch;	state Exp;
branches;
next	1.331;

1.331
date	2008.12.02.07.57.36;	author vprus;	state Exp;
branches;
next	1.330;

1.330
date	2008.11.24.16.53.44;	author drow;	state Exp;
branches;
next	1.329;

1.329
date	2008.11.19.14.45.09;	author palves;	state Exp;
branches
	1.329.2.1;
next	1.328;

1.328
date	2008.11.09.11.27.18;	author vprus;	state Exp;
branches;
next	1.327;

1.327
date	2008.11.05.21.19.45;	author palves;	state Exp;
branches;
next	1.326;

1.326
date	2008.11.04.20.52.23;	author palves;	state Exp;
branches;
next	1.325;

1.325
date	2008.11.03.14.01.27;	author palves;	state Exp;
branches;
next	1.324;

1.324
date	2008.10.28.15.22.12;	author tromey;	state Exp;
branches;
next	1.323;

1.323
date	2008.10.27.12.43.24;	author palves;	state Exp;
branches;
next	1.322;

1.322
date	2008.10.24.20.38.26;	author palves;	state Exp;
branches;
next	1.321;

1.321
date	2008.10.17.19.43.47;	author msnyder;	state Exp;
branches;
next	1.320;

1.320
date	2008.10.17.01.08.08;	author palves;	state Exp;
branches;
next	1.319;

1.319
date	2008.10.16.14.39.54;	author palves;	state Exp;
branches;
next	1.318;

1.318
date	2008.10.16.14.03.17;	author palves;	state Exp;
branches;
next	1.317;

1.317
date	2008.10.15.21.39.53;	author palves;	state Exp;
branches;
next	1.316;

1.316
date	2008.10.10.14.46.31;	author palves;	state Exp;
branches;
next	1.315;

1.315
date	2008.10.09.18.45.44;	author palves;	state Exp;
branches;
next	1.314;

1.314
date	2008.10.09.03.24.51;	author palves;	state Exp;
branches;
next	1.313;

1.313
date	2008.10.08.19.16.31;	author palves;	state Exp;
branches;
next	1.312;

1.312
date	2008.10.08.15.00.29;	author palves;	state Exp;
branches;
next	1.311;

1.311
date	2008.10.03.16.36.10;	author ppluzhnikov;	state Exp;
branches;
next	1.310;

1.310
date	2008.09.22.15.21.30;	author palves;	state Exp;
branches
	1.310.2.1;
next	1.309;

1.309
date	2008.09.22.15.18.30;	author palves;	state Exp;
branches;
next	1.308;

1.308
date	2008.08.27.13.25.21;	author uweigand;	state Exp;
branches;
next	1.307;

1.307
date	2008.08.26.17.30.35;	author uweigand;	state Exp;
branches;
next	1.306;

1.306
date	2008.08.26.17.21.29;	author uweigand;	state Exp;
branches;
next	1.305;

1.305
date	2008.08.19.13.05.02;	author vprus;	state Exp;
branches;
next	1.304;

1.304
date	2008.08.12.15.18.30;	author sandra;	state Exp;
branches;
next	1.303;

1.303
date	2008.07.24.15.28.42;	author palves;	state Exp;
branches;
next	1.302;

1.302
date	2008.07.09.22.42.42;	author palves;	state Exp;
branches
	1.302.2.1;
next	1.301;

1.301
date	2008.07.09.22.16.14;	author palves;	state Exp;
branches;
next	1.300;

1.300
date	2008.06.27.18.56.34;	author jlarmour;	state Exp;
branches;
next	1.299;

1.299
date	2008.06.27.11.54.21;	author palves;	state Exp;
branches;
next	1.298;

1.298
date	2008.06.27.11.31.40;	author palves;	state Exp;
branches;
next	1.297;

1.297
date	2008.06.11.12.56.36;	author palves;	state Exp;
branches;
next	1.296;

1.296
date	2008.06.09.20.43.48;	author devans;	state Exp;
branches
	1.296.2.1;
next	1.295;

1.295
date	2008.06.05.21.35.00;	author palves;	state Exp;
branches;
next	1.294;

1.294
date	2008.06.05.21.13.58;	author palves;	state Exp;
branches;
next	1.293;

1.293
date	2008.06.05.16.17.54;	author drow;	state Exp;
branches;
next	1.292;

1.292
date	2008.05.17.11.28.30;	author palves;	state Exp;
branches;
next	1.291;

1.291
date	2008.05.09.17.45.58;	author devans;	state Exp;
branches;
next	1.290;

1.290
date	2008.05.09.17.02.01;	author devans;	state Exp;
branches;
next	1.289;

1.289
date	2008.05.08.19.48.55;	author uweigand;	state Exp;
branches;
next	1.288;

1.288
date	2008.05.08.16.08.10;	author drow;	state Exp;
branches;
next	1.287;

1.287
date	2008.05.07.11.54.41;	author jiez;	state Exp;
branches;
next	1.286;

1.286
date	2008.03.21.17.09.35;	author palves;	state Exp;
branches;
next	1.285;

1.285
date	2008.03.14.18.57.43;	author vprus;	state Exp;
branches;
next	1.284;

1.284
date	2008.03.14.17.44.43;	author vprus;	state Exp;
branches;
next	1.283;

1.283
date	2008.03.07.19.41.05;	author brobecke;	state Exp;
branches;
next	1.282;

1.282
date	2008.03.05.17.21.10;	author drow;	state Exp;
branches;
next	1.281;

1.281
date	2008.02.27.21.00.01;	author drow;	state Exp;
branches;
next	1.280;

1.280
date	2008.02.25.09.59.06;	author vprus;	state Exp;
branches
	1.280.6.1;
next	1.279;

1.279
date	2008.02.21.17.26.16;	author palves;	state Exp;
branches;
next	1.278;

1.278
date	2008.01.30.00.51.49;	author drow;	state Exp;
branches;
next	1.277;

1.277
date	2008.01.23.20.43.30;	author drow;	state Exp;
branches;
next	1.276;

1.276
date	2008.01.23.11.26.28;	author vprus;	state Exp;
branches;
next	1.275;

1.275
date	2008.01.01.22.53.12;	author drow;	state Exp;
branches;
next	1.274;

1.274
date	2007.12.31.18.38.43;	author drow;	state Exp;
branches;
next	1.273;

1.273
date	2007.12.07.15.02.12;	author macro;	state Exp;
branches;
next	1.272;

1.272
date	2007.11.30.21.50.18;	author drow;	state Exp;
branches;
next	1.271;

1.271
date	2007.10.08.12.55.09;	author uweigand;	state Exp;
branches;
next	1.270;

1.270
date	2007.10.05.21.36.00;	author drow;	state Exp;
branches;
next	1.269;

1.269
date	2007.10.01.00.17.58;	author drow;	state Exp;
branches;
next	1.268;

1.268
date	2007.09.26.18.32.54;	author jimb;	state Exp;
branches;
next	1.267;

1.267
date	2007.09.24.21.48.29;	author jimb;	state Exp;
branches;
next	1.266;

1.266
date	2007.08.23.18.08.36;	author brobecke;	state Exp;
branches
	1.266.2.1;
next	1.265;

1.265
date	2007.07.03.15.58.42;	author drow;	state Exp;
branches;
next	1.264;

1.264
date	2007.07.02.22.01.09;	author drow;	state Exp;
branches;
next	1.263;

1.263
date	2007.06.22.12.36.00;	author uweigand;	state Exp;
branches;
next	1.262;

1.262
date	2007.06.18.15.46.38;	author drow;	state Exp;
branches;
next	1.261;

1.261
date	2007.06.16.17.16.25;	author uweigand;	state Exp;
branches;
next	1.260;

1.260
date	2007.06.13.17.59.50;	author uweigand;	state Exp;
branches;
next	1.259;

1.259
date	2007.06.13.17.38.43;	author uweigand;	state Exp;
branches;
next	1.258;

1.258
date	2007.06.13.14.35.02;	author uweigand;	state Exp;
branches;
next	1.257;

1.257
date	2007.06.12.14.38.32;	author uweigand;	state Exp;
branches;
next	1.256;

1.256
date	2007.06.09.13.42.15;	author uweigand;	state Exp;
branches;
next	1.255;

1.255
date	2007.06.07.05.00.42;	author vprus;	state Exp;
branches;
next	1.254;

1.254
date	2007.05.31.17.32.21;	author uweigand;	state Exp;
branches;
next	1.253;

1.253
date	2007.05.11.19.55.19;	author uweigand;	state Exp;
branches;
next	1.252;

1.252
date	2007.05.11.19.16.04;	author uweigand;	state Exp;
branches;
next	1.251;

1.251
date	2007.05.10.21.19.41;	author palves;	state Exp;
branches;
next	1.250;

1.250
date	2007.05.06.19.37.30;	author uweigand;	state Exp;
branches;
next	1.249;

1.249
date	2007.05.06.18.55.41;	author uweigand;	state Exp;
branches;
next	1.248;

1.248
date	2007.05.06.14.34.38;	author uweigand;	state Exp;
branches;
next	1.247;

1.247
date	2007.03.27.19.11.10;	author uweigand;	state Exp;
branches
	1.247.2.1;
next	1.246;

1.246
date	2007.02.26.19.23.17;	author drow;	state Exp;
branches;
next	1.245;

1.245
date	2007.02.08.21.00.29;	author drow;	state Exp;
branches;
next	1.244;

1.244
date	2007.01.09.22.55.10;	author drow;	state Exp;
branches;
next	1.243;

1.243
date	2007.01.09.17.58.56;	author drow;	state Exp;
branches;
next	1.242;

1.242
date	2007.01.03.19.01.25;	author drow;	state Exp;
branches;
next	1.241;

1.241
date	2006.11.28.22.14.31;	author drow;	state Exp;
branches;
next	1.240;

1.240
date	2006.11.28.22.10.26;	author drow;	state Exp;
branches;
next	1.239;

1.239
date	2006.11.28.17.08.49;	author drow;	state Exp;
branches;
next	1.238;

1.238
date	2006.11.16.15.08.21;	author drow;	state Exp;
branches;
next	1.237;

1.237
date	2006.11.14.21.40.19;	author drow;	state Exp;
branches;
next	1.236;

1.236
date	2006.10.21.17.59.08;	author pbrook;	state Exp;
branches;
next	1.235;

1.235
date	2006.10.20.01.08.14;	author uweigand;	state Exp;
branches;
next	1.234;

1.234
date	2006.10.18.16.56.13;	author drow;	state Exp;
branches;
next	1.233;

1.233
date	2006.10.17.15.43.51;	author drow;	state Exp;
branches;
next	1.232;

1.232
date	2006.10.16.03.08.37;	author drow;	state Exp;
branches;
next	1.231;

1.231
date	2006.10.05.19.20.52;	author drow;	state Exp;
branches;
next	1.230;

1.230
date	2006.09.22.13.50.36;	author drow;	state Exp;
branches;
next	1.229;

1.229
date	2006.09.21.14.00.53;	author drow;	state Exp;
branches;
next	1.228;

1.228
date	2006.09.21.13.54.02;	author drow;	state Exp;
branches;
next	1.227;

1.227
date	2006.09.20.19.13.02;	author drow;	state Exp;
branches;
next	1.226;

1.226
date	2006.08.16.18.31.03;	author drow;	state Exp;
branches;
next	1.225;

1.225
date	2006.08.15.18.17.56;	author drow;	state Exp;
branches;
next	1.224;

1.224
date	2006.07.27.00.06.02;	author drow;	state Exp;
branches;
next	1.223;

1.223
date	2006.07.13.04.05.54;	author drow;	state Exp;
branches;
next	1.222;

1.222
date	2006.07.12.18.54.03;	author drow;	state Exp;
branches;
next	1.221;

1.221
date	2006.07.12.18.50.17;	author drow;	state Exp;
branches;
next	1.220;

1.220
date	2006.07.12.18.13.45;	author drow;	state Exp;
branches;
next	1.219;

1.219
date	2006.07.05.19.03.47;	author drow;	state Exp;
branches;
next	1.218;

1.218
date	2006.07.04.13.31.31;	author drow;	state Exp;
branches;
next	1.217;

1.217
date	2006.06.22.14.06.37;	author drow;	state Exp;
branches;
next	1.216;

1.216
date	2006.06.21.13.57.21;	author drow;	state Exp;
branches;
next	1.215;

1.215
date	2006.06.12.19.16.19;	author drow;	state Exp;
branches;
next	1.214;

1.214
date	2006.06.08.19.08.22;	author nathan;	state Exp;
branches;
next	1.213;

1.213
date	2006.06.08.19.04.08;	author nathan;	state Exp;
branches;
next	1.212;

1.212
date	2006.06.08.18.32.12;	author drow;	state Exp;
branches;
next	1.211;

1.211
date	2006.06.06.10.03.06;	author nathan;	state Exp;
branches;
next	1.210;

1.210
date	2006.05.05.20.08.45;	author drow;	state Exp;
branches
	1.210.2.1;
next	1.209;

1.209
date	2006.04.26.18.45.32;	author msnyder;	state Exp;
branches
	1.209.2.1;
next	1.208;

1.208
date	2006.04.18.19.20.06;	author drow;	state Exp;
branches;
next	1.207;

1.207
date	2006.04.12.14.27.40;	author drow;	state Exp;
branches;
next	1.206;

1.206
date	2006.04.07.16.15.58;	author drow;	state Exp;
branches;
next	1.205;

1.205
date	2006.03.30.16.56.30;	author drow;	state Exp;
branches;
next	1.204;

1.204
date	2006.03.30.16.25.06;	author drow;	state Exp;
branches;
next	1.203;

1.203
date	2006.03.17.00.25.45;	author msnyder;	state Exp;
branches
	1.203.2.1;
next	1.202;

1.202
date	2006.02.20.15.19.06;	author drow;	state Exp;
branches
	1.202.2.1
	1.202.4.1;
next	1.201;

1.201
date	2006.02.02.02.04.28;	author drow;	state Exp;
branches;
next	1.200;

1.200
date	2006.01.24.22.34.34;	author drow;	state Exp;
branches;
next	1.199;

1.199
date	2006.01.24.22.09.28;	author drow;	state Exp;
branches;
next	1.198;

1.198
date	2006.01.17.14.11.16;	author drow;	state Exp;
branches;
next	1.197;

1.197
date	2006.01.11.22.03.59;	author kettenis;	state Exp;
branches;
next	1.196;

1.196
date	2005.12.17.22.34.02;	author eliz;	state Exp;
branches;
next	1.195;

1.195
date	2005.07.20.02.56.43;	author woodzltc;	state Exp;
branches
	1.195.2.1
	1.195.6.1;
next	1.194;

1.194
date	2005.06.22.11.42.54;	author kettenis;	state Exp;
branches;
next	1.193;

1.193
date	2005.06.17.03.42.24;	author woodzltc;	state Exp;
branches;
next	1.192;

1.192
date	2005.05.28.18.57.13;	author drow;	state Exp;
branches
	1.192.2.1;
next	1.191;

1.191
date	2005.05.28.16.44.29;	author drow;	state Exp;
branches;
next	1.190;

1.190
date	2005.05.16.16.36.24;	author kettenis;	state Exp;
branches;
next	1.189;

1.189
date	2005.05.12.20.21.17;	author kettenis;	state Exp;
branches;
next	1.188;

1.188
date	2005.05.01.19.58.54;	author cagney;	state Exp;
branches;
next	1.187;

1.187
date	2005.04.28.18.15.16;	author kevinb;	state Exp;
branches;
next	1.186;

1.186
date	2005.04.26.14.57.21;	author cagney;	state Exp;
branches;
next	1.185;

1.185
date	2005.04.26.05.03.36;	author cagney;	state Exp;
branches;
next	1.184;

1.184
date	2005.04.15.21.16.09;	author kevinb;	state Exp;
branches;
next	1.183;

1.183
date	2005.04.15.20.55.56;	author kevinb;	state Exp;
branches;
next	1.182;

1.182
date	2005.04.15.19.58.59;	author kevinb;	state Exp;
branches;
next	1.181;

1.181
date	2005.04.15.17.44.53;	author kevinb;	state Exp;
branches;
next	1.180;

1.180
date	2005.04.15.17.13.23;	author kevinb;	state Exp;
branches;
next	1.179;

1.179
date	2005.03.25.20.39.45;	author green;	state Exp;
branches;
next	1.178;

1.178
date	2005.03.13.22.06.10;	author kettenis;	state Exp;
branches
	1.178.2.1;
next	1.177;

1.177
date	2005.03.08.14.30.46;	author nathan;	state Exp;
branches;
next	1.176;

1.176
date	2005.03.04.17.52.53;	author drow;	state Exp;
branches;
next	1.175;

1.175
date	2005.03.03.16.54.05;	author drow;	state Exp;
branches;
next	1.174;

1.174
date	2005.02.21.06.21.08;	author cagney;	state Exp;
branches;
next	1.173;

1.173
date	2005.02.18.15.25.27;	author cagney;	state Exp;
branches;
next	1.172;

1.172
date	2005.02.17.13.49.55;	author cagney;	state Exp;
branches;
next	1.171;

1.171
date	2005.02.16.17.20.58;	author cagney;	state Exp;
branches;
next	1.170;

1.170
date	2005.02.15.15.49.18;	author cagney;	state Exp;
branches;
next	1.169;

1.169
date	2005.02.14.18.10.10;	author cagney;	state Exp;
branches;
next	1.168;

1.168
date	2005.02.14.16.18.43;	author cagney;	state Exp;
branches;
next	1.167;

1.167
date	2005.02.12.00.39.21;	author cagney;	state Exp;
branches;
next	1.166;

1.166
date	2005.02.11.18.13.52;	author cagney;	state Exp;
branches;
next	1.165;

1.165
date	2005.02.11.04.06.03;	author cagney;	state Exp;
branches;
next	1.164;

1.164
date	2005.02.10.17.32.50;	author cagney;	state Exp;
branches;
next	1.163;

1.163
date	2005.01.19.21.15.44;	author cagney;	state Exp;
branches;
next	1.162;

1.162
date	2005.01.18.16.15.39;	author cagney;	state Exp;
branches;
next	1.161;

1.161
date	2005.01.14.22.59.33;	author cagney;	state Exp;
branches;
next	1.160;

1.160
date	2005.01.14.01.46.07;	author msnyder;	state Exp;
branches;
next	1.159;

1.159
date	2005.01.13.00.12.50;	author cagney;	state Exp;
branches;
next	1.158;

1.158
date	2005.01.12.18.31.32;	author cagney;	state Exp;
branches;
next	1.157;

1.157
date	2004.12.28.09.06.10;	author jimb;	state Exp;
branches;
next	1.156;

1.156
date	2004.12.21.21.24.56;	author jimb;	state Exp;
branches;
next	1.155;

1.155
date	2004.12.17.22.19.51;	author jimb;	state Exp;
branches;
next	1.154;

1.154
date	2004.12.07.20.21.32;	author jimb;	state Exp;
branches;
next	1.153;

1.153
date	2004.11.11.18.59.39;	author cagney;	state Exp;
branches;
next	1.152;

1.152
date	2004.10.27.20.03.50;	author jimb;	state Exp;
branches;
next	1.151;

1.151
date	2004.10.08.20.29.54;	author cagney;	state Exp;
branches
	1.151.2.1;
next	1.150;

1.150
date	2004.10.08.17.30.47;	author jjohnstn;	state Exp;
branches;
next	1.149;

1.149
date	2004.10.05.19.52.04;	author drow;	state Exp;
branches;
next	1.148;

1.148
date	2004.09.24.19.51.18;	author cagney;	state Exp;
branches;
next	1.147;

1.147
date	2004.09.13.18.26.30;	author cagney;	state Exp;
branches;
next	1.146;

1.146
date	2004.09.07.21.55.11;	author cagney;	state Exp;
branches;
next	1.145;

1.145
date	2004.08.03.02.02.23;	author cagney;	state Exp;
branches;
next	1.144;

1.144
date	2004.08.03.00.57.26;	author cagney;	state Exp;
branches;
next	1.143;

1.143
date	2004.07.28.19.42.01;	author cagney;	state Exp;
branches;
next	1.142;

1.142
date	2004.07.28.17.26.27;	author cagney;	state Exp;
branches;
next	1.141;

1.141
date	2004.07.26.14.53.04;	author cagney;	state Exp;
branches;
next	1.140;

1.140
date	2004.07.24.01.00.20;	author cagney;	state Exp;
branches;
next	1.139;

1.139
date	2004.07.22.01.31.49;	author cagney;	state Exp;
branches;
next	1.138;

1.138
date	2004.06.28.23.59.28;	author cagney;	state Exp;
branches;
next	1.137;

1.137
date	2004.06.15.01.04.19;	author amodra;	state Exp;
branches;
next	1.136;

1.136
date	2004.05.25.14.58.30;	author cagney;	state Exp;
branches;
next	1.135;

1.135
date	2004.05.10.04.20.46;	author cagney;	state Exp;
branches;
next	1.134;

1.134
date	2004.04.26.09.02.41;	author orjanf;	state Exp;
branches;
next	1.133;

1.133
date	2004.04.21.23.52.20;	author cagney;	state Exp;
branches;
next	1.132;

1.132
date	2004.03.23.15.14.02;	author drow;	state Exp;
branches;
next	1.131;

1.131
date	2004.03.15.20.38.08;	author cagney;	state Exp;
branches;
next	1.130;

1.130
date	2004.02.25.20.41.00;	author roland;	state Exp;
branches
	1.130.4.1;
next	1.129;

1.129
date	2004.02.15.15.22.06;	author cagney;	state Exp;
branches
	1.129.2.1;
next	1.128;

1.128
date	2004.01.26.23.07.00;	author cagney;	state Exp;
branches;
next	1.127;

1.127
date	2004.01.19.01.20.11;	author cagney;	state Exp;
branches;
next	1.126;

1.126
date	2004.01.18.03.38.32;	author drow;	state Exp;
branches;
next	1.125;

1.125
date	2004.01.18.03.37.03;	author drow;	state Exp;
branches;
next	1.124;

1.124
date	2003.12.08.17.00.06;	author kevinb;	state Exp;
branches;
next	1.123;

1.123
date	2003.12.06.22.58.27;	author cagney;	state Exp;
branches;
next	1.122;

1.122
date	2003.11.10.21.20.44;	author cagney;	state Exp;
branches;
next	1.121;

1.121
date	2003.10.31.15.25.34;	author cagney;	state Exp;
branches;
next	1.120;

1.120
date	2003.10.24.17.37.03;	author cagney;	state Exp;
branches;
next	1.119;

1.119
date	2003.10.17.18.24.49;	author cagney;	state Exp;
branches;
next	1.118;

1.118
date	2003.10.16.20.51.47;	author drow;	state Exp;
branches;
next	1.117;

1.117
date	2003.10.15.21.10.55;	author cagney;	state Exp;
branches;
next	1.116;

1.116
date	2003.10.02.20.28.30;	author cagney;	state Exp;
branches;
next	1.115;

1.115
date	2003.09.21.01.26.45;	author cagney;	state Exp;
branches;
next	1.114;

1.114
date	2003.09.17.14.24.30;	author cagney;	state Exp;
branches;
next	1.113;

1.113
date	2003.08.04.22.24.44;	author cagney;	state Exp;
branches;
next	1.112;

1.112
date	2003.08.04.20.52.27;	author cagney;	state Exp;
branches;
next	1.111;

1.111
date	2003.08.04.17.08.22;	author carlton;	state Exp;
branches;
next	1.110;

1.110
date	2003.06.30.15.50.52;	author cagney;	state Exp;
branches;
next	1.109;

1.109
date	2003.06.30.15.03.07;	author cagney;	state Exp;
branches;
next	1.108;

1.108
date	2003.06.29.21.17.22;	author cagney;	state Exp;
branches;
next	1.107;

1.107
date	2003.06.17.20.28.13;	author drow;	state Exp;
branches
	1.107.2.1;
next	1.106;

1.106
date	2003.06.17.18.18.57;	author drow;	state Exp;
branches;
next	1.105;

1.105
date	2003.06.10.14.37.04;	author corinna;	state Exp;
branches;
next	1.104;

1.104
date	2003.06.08.22.51.48;	author cagney;	state Exp;
branches;
next	1.103;

1.103
date	2003.06.08.18.27.14;	author cagney;	state Exp;
branches;
next	1.102;

1.102
date	2003.06.06.23.32.59;	author mmitchel;	state Exp;
branches;
next	1.101;

1.101
date	2003.06.04.04.31.37;	author troth;	state Exp;
branches;
next	1.100;

1.100
date	2003.05.17.05.59.58;	author cagney;	state Exp;
branches
	1.100.2.1;
next	1.99;

1.99
date	2003.05.15.22.58.38;	author cagney;	state Exp;
branches;
next	1.98;

1.98
date	2003.05.08.20.52.48;	author cagney;	state Exp;
branches
	1.98.4.1;
next	1.97;

1.97
date	2003.05.07.19.21.12;	author cagney;	state Exp;
branches;
next	1.96;

1.96
date	2003.04.18.00.21.38;	author rth;	state Exp;
branches
	1.96.2.1;
next	1.95;

1.95
date	2003.02.20.13.43.14;	author cagney;	state Exp;
branches;
next	1.94;

1.94
date	2002.11.14.00.25.03;	author cagney;	state Exp;
branches;
next	1.93;

1.93
date	2002.08.18.23.17.57;	author drow;	state Exp;
branches
	1.93.4.1
	1.93.8.1
	1.93.10.1;
next	1.92;

1.92
date	2002.08.16.14.52.12;	author graces;	state Exp;
branches;
next	1.91;

1.91
date	2002.08.09.16.41.24;	author graces;	state Exp;
branches;
next	1.90;

1.90
date	2002.08.08.19.45.50;	author graces;	state Exp;
branches;
next	1.89;

1.89
date	2002.07.23.18.55.06;	author msalter;	state Exp;
branches;
next	1.88;

1.88
date	2002.07.11.13.50.49;	author cagney;	state Exp;
branches;
next	1.87;

1.87
date	2002.06.15.22.05.32;	author cagney;	state Exp;
branches;
next	1.86;

1.86
date	2002.06.15.21.07.58;	author cagney;	state Exp;
branches;
next	1.85;

1.85
date	2002.06.15.18.45.31;	author cagney;	state Exp;
branches;
next	1.84;

1.84
date	2002.05.19.20.11.16;	author cagney;	state Exp;
branches
	1.84.2.1;
next	1.83;

1.83
date	2002.05.19.18.32.10;	author cagney;	state Exp;
branches;
next	1.82;

1.82
date	2002.05.19.16.56.03;	author cagney;	state Exp;
branches;
next	1.81;

1.81
date	2002.05.14.04.26.24;	author drow;	state Exp;
branches
	1.81.2.1;
next	1.80;

1.80
date	2002.05.12.01.02.58;	author cagney;	state Exp;
branches;
next	1.79;

1.79
date	2002.04.13.00.12.30;	author msnyder;	state Exp;
branches;
next	1.78;

1.78
date	2002.03.23.17.38.13;	author cagney;	state Exp;
branches;
next	1.77;

1.77
date	2002.02.27.01.18.39;	author cagney;	state Exp;
branches;
next	1.76;

1.76
date	2002.02.10.04.08.42;	author cagney;	state Exp;
branches;
next	1.75;

1.75
date	2002.02.05.04.37.22;	author cagney;	state Exp;
branches;
next	1.74;

1.74
date	2002.01.19.03.32.40;	author cagney;	state Exp;
branches;
next	1.73;

1.73
date	2002.01.17.22.15.17;	author cagney;	state Exp;
branches;
next	1.72;

1.72
date	2002.01.05.04.30.18;	author cagney;	state Exp;
branches;
next	1.71;

1.71
date	2001.12.20.17.39.58;	author cagney;	state Exp;
branches;
next	1.70;

1.70
date	2001.11.19.20.18.32;	author cagney;	state Exp;
branches;
next	1.69;

1.69
date	2001.11.15.20.58.38;	author cagney;	state Exp;
branches;
next	1.68;

1.68
date	2001.11.15.20.30.41;	author cagney;	state Exp;
branches;
next	1.67;

1.67
date	2001.11.15.06.43.10;	author cagney;	state Exp;
branches;
next	1.66;

1.66
date	2001.11.15.05.00.46;	author cagney;	state Exp;
branches;
next	1.65;

1.65
date	2001.11.15.02.56.29;	author cagney;	state Exp;
branches;
next	1.64;

1.64
date	2001.10.21.17.19.37;	author cagney;	state Exp;
branches;
next	1.63;

1.63
date	2001.09.30.16.16.16;	author cagney;	state Exp;
branches;
next	1.62;

1.62
date	2001.08.10.09.59.32;	author orjanf;	state Exp;
branches;
next	1.61;

1.61
date	2001.07.17.01.23.44;	author nsd;	state Exp;
branches
	1.61.2.1;
next	1.60;

1.60
date	2001.07.17.00.27.28;	author cagney;	state Exp;
branches;
next	1.59;

1.59
date	2001.07.16.23.32.14;	author nsd;	state Exp;
branches;
next	1.58;

1.58
date	2001.07.15.20.34.14;	author cagney;	state Exp;
branches;
next	1.57;

1.57
date	2001.07.11.17.52.32;	author cagney;	state Exp;
branches;
next	1.56;

1.56
date	2001.06.14.19.27.45;	author msnyder;	state Exp;
branches;
next	1.55;

1.55
date	2001.05.25.17.46.33;	author msnyder;	state Exp;
branches;
next	1.54;

1.54
date	2001.05.21.18.48.26;	author msnyder;	state Exp;
branches;
next	1.53;

1.53
date	2001.05.16.20.10.52;	author msnyder;	state Exp;
branches;
next	1.52;

1.52
date	2001.05.14.19.02.00;	author msnyder;	state Exp;
branches;
next	1.51;

1.51
date	2001.05.14.18.31.35;	author msnyder;	state Exp;
branches;
next	1.50;

1.50
date	2001.05.14.16.48.01;	author cagney;	state Exp;
branches;
next	1.49;

1.49
date	2001.05.10.19.06.19;	author msnyder;	state Exp;
branches;
next	1.48;

1.48
date	2001.05.10.19.00.35;	author msnyder;	state Exp;
branches;
next	1.47;

1.47
date	2001.05.04.04.15.27;	author kevinb;	state Exp;
branches;
next	1.46;

1.46
date	2001.04.26.22.10.41;	author msnyder;	state Exp;
branches;
next	1.45;

1.45
date	2001.04.17.20.31.00;	author msnyder;	state Exp;
branches;
next	1.44;

1.44
date	2001.04.03.01.42.17;	author jtc;	state Exp;
branches;
next	1.43;

1.43
date	2001.03.27.20.36.24;	author jtc;	state Exp;
branches;
next	1.42;

1.42
date	2001.03.19.21.01.06;	author cagney;	state Exp;
branches;
next	1.41;

1.41
date	2001.03.06.08.21.13;	author kevinb;	state Exp;
branches;
next	1.40;

1.40
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.39;

1.39
date	2001.02.16.23.40.39;	author msnyder;	state Exp;
branches;
next	1.38;

1.38
date	2001.02.08.06.03.53;	author cagney;	state Exp;
branches;
next	1.37;

1.37
date	2001.02.06.20.05.41;	author msnyder;	state Exp;
branches;
next	1.36;

1.36
date	2001.02.02.19.14.33;	author jtc;	state Exp;
branches;
next	1.35;

1.35
date	2001.01.23.22.48.56;	author jtc;	state Exp;
branches;
next	1.34;

1.34
date	2001.01.18.15.29.11;	author cagney;	state Exp;
branches;
next	1.33;

1.33
date	2001.01.09.00.12.48;	author nsd;	state Exp;
branches;
next	1.32;

1.32
date	2000.12.15.12.33.08;	author cagney;	state Exp;
branches;
next	1.31;

1.31
date	2000.12.15.01.01.49;	author kevinb;	state Exp;
branches;
next	1.30;

1.30
date	2000.11.27.02.18.44;	author cagney;	state Exp;
branches;
next	1.29;

1.29
date	2000.11.20.02.06.18;	author cagney;	state Exp;
branches;
next	1.28;

1.28
date	2000.11.14.13.45.38;	author cagney;	state Exp;
branches;
next	1.27;

1.27
date	2000.11.03.22.00.56;	author jtc;	state Exp;
branches;
next	1.26;

1.26
date	2000.10.23.22.49.28;	author davea;	state Exp;
branches;
next	1.25;

1.25
date	2000.10.18.03.29.25;	author kevinb;	state Exp;
branches;
next	1.24;

1.24
date	2000.10.13.21.41.21;	author fnasser;	state Exp;
branches;
next	1.23;

1.23
date	2000.09.01.00.12.10;	author jtc;	state Exp;
branches;
next	1.22;

1.22
date	2000.08.24.10.48.22;	author cagney;	state Exp;
branches;
next	1.21;

1.21
date	2000.08.18.22.52.23;	author jtc;	state Exp;
branches;
next	1.20;

1.20
date	2000.08.10.18.54.27;	author jtc;	state Exp;
branches;
next	1.19;

1.19
date	2000.08.07.15.02.48;	author ezannoni;	state Exp;
branches;
next	1.18;

1.18
date	2000.08.04.09.32.19;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2000.08.02.05.40.25;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2000.07.30.01.48.27;	author kevinb;	state Exp;
branches;
next	1.15;

1.15
date	2000.06.19.18.59.07;	author jtc;	state Exp;
branches;
next	1.14;

1.14
date	2000.06.12.01.33.49;	author kevinb;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.08.00.52.56;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.04.00.41.09;	author kevinb;	state Exp;
branches;
next	1.11;

1.11
date	2000.05.28.01.12.29;	author kevinb;	state Exp;
branches;
next	1.10;

1.10
date	2000.05.16.03.03.13;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2000.05.04.16.52.34;	author ezannoni;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.17.02.27.37;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.29.08.29.00;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.21.01.22.05;	author msnyder;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.18.17.00.18;	author ezannoni;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.09.08.52.47;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.09.03.28.18;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.09.02.51.55;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.04;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.528.2.1
date	2013.03.22.19.07.32;	author jkratoch;	state Exp;
branches;
next	1.528.2.2;

1.528.2.2
date	2013.03.22.20.41.45;	author jkratoch;	state Exp;
branches;
next	1.528.2.3;

1.528.2.3
date	2013.03.27.18.21.54;	author jkratoch;	state Exp;
branches;
next	1.528.2.4;

1.528.2.4
date	2013.04.02.13.54.21;	author palves;	state Exp;
branches;
next	1.528.2.5;

1.528.2.5
date	2013.04.02.14.11.00;	author jkratoch;	state Exp;
branches;
next	1.528.2.6;

1.528.2.6
date	2013.04.12.16.04.50;	author jkratoch;	state Exp;
branches;
next	1.528.2.7;

1.528.2.7
date	2013.05.10.13.51.48;	author palves;	state Exp;
branches;
next	;

1.473.2.1
date	2012.01.06.04.43.26;	author brobecke;	state Exp;
branches;
next	1.473.2.2;

1.473.2.2
date	2012.03.13.22.14.34;	author palves;	state Exp;
branches;
next	1.473.2.3;

1.473.2.3
date	2012.03.20.18.43.23;	author palves;	state Exp;
branches;
next	;

1.441.2.1
date	2011.04.26.15.38.21;	author tromey;	state Exp;
branches;
next	1.441.2.2;

1.441.2.2
date	2011.06.15.14.57.15;	author teawater;	state Exp;
branches;
next	1.441.2.3;

1.441.2.3
date	2011.06.16.02.22.18;	author teawater;	state Exp;
branches;
next	1.441.2.4;

1.441.2.4
date	2011.07.13.17.11.48;	author jkratoch;	state Exp;
branches;
next	1.441.2.5;

1.441.2.5
date	2011.07.15.02.04.29;	author teawater;	state Exp;
branches;
next	;

1.419.2.1
date	2010.07.28.20.20.12;	author tromey;	state Exp;
branches;
next	1.419.2.2;

1.419.2.2
date	2010.11.04.05.01.10;	author teawater;	state Exp;
branches;
next	1.419.2.3;

1.419.2.3
date	2011.03.08.12.11.49;	author palves;	state Exp;
branches;
next	;

1.385.2.1
date	2010.03.07.14.39.53;	author brobecke;	state Exp;
branches;
next	;

1.329.2.1
date	2008.11.21.02.31.57;	author shebs;	state Exp;
branches;
next	1.329.2.2;

1.329.2.2
date	2008.11.25.20.45.09;	author palves;	state Exp;
branches;
next	1.329.2.3;

1.329.2.3
date	2008.12.16.22.48.30;	author palves;	state Exp;
branches;
next	1.329.2.4;

1.329.2.4
date	2008.12.16.22.49.49;	author palves;	state Exp;
branches;
next	;

1.310.2.1
date	2008.09.30.23.38.49;	author msnyder;	state Exp;
branches;
next	1.310.2.2;

1.310.2.2
date	2008.10.04.18.56.36;	author msnyder;	state Exp;
branches;
next	1.310.2.3;

1.310.2.3
date	2008.10.06.23.21.02;	author msnyder;	state Exp;
branches;
next	1.310.2.4;

1.310.2.4
date	2008.10.08.00.26.28;	author msnyder;	state Exp;
branches;
next	1.310.2.5;

1.310.2.5
date	2008.10.19.22.15.10;	author msnyder;	state Exp;
branches;
next	;

1.302.2.1
date	2008.07.18.04.23.49;	author msnyder;	state Exp;
branches;
next	1.302.2.2;

1.302.2.2
date	2008.10.06.01.13.38;	author msnyder;	state Exp;
branches;
next	1.302.2.3;

1.302.2.3
date	2008.10.06.23.20.46;	author msnyder;	state Exp;
branches;
next	1.302.2.4;

1.302.2.4
date	2008.10.08.00.26.50;	author msnyder;	state Exp;
branches;
next	;

1.296.2.1
date	2008.06.10.02.11.17;	author msnyder;	state Exp;
branches;
next	;

1.280.6.1
date	2009.03.09.20.36.07;	author amylaar;	state Exp;
branches;
next	;

1.266.2.1
date	2007.09.24.21.48.05;	author jimb;	state Exp;
branches;
next	1.266.2.2;

1.266.2.2
date	2007.10.05.21.36.56;	author drow;	state Exp;
branches;
next	;

1.247.2.1
date	2008.06.10.00.13.15;	author msnyder;	state Exp;
branches;
next	;

1.210.2.1
date	2006.05.12.07.40.20;	author nickrob;	state Exp;
branches;
next	1.210.2.2;

1.210.2.2
date	2006.08.28.07.48.47;	author nickrob;	state Exp;
branches;
next	;

1.209.2.1
date	2006.05.03.00.27.27;	author msnyder;	state Exp;
branches;
next	;

1.203.2.1
date	2006.03.31.20.45.33;	author msnyder;	state Exp;
branches;
next	;

1.202.2.1
date	2006.03.31.15.50.07;	author nathan;	state Exp;
branches;
next	1.202.2.2;

1.202.2.2
date	2006.03.31.16.08.45;	author nathan;	state Exp;
branches;
next	1.202.2.3;

1.202.2.3
date	2006.04.03.00.47.40;	author drow;	state Exp;
branches
	1.202.2.3.2.1;
next	1.202.2.4;

1.202.2.4
date	2006.05.24.08.00.02;	author nathan;	state Exp;
branches;
next	1.202.2.5;

1.202.2.5
date	2006.06.05.17.31.50;	author nathan;	state Exp;
branches;
next	1.202.2.6;

1.202.2.6
date	2006.06.08.18.30.22;	author nathan;	state Exp;
branches;
next	1.202.2.7;

1.202.2.7
date	2006.07.03.15.58.50;	author drow;	state Exp;
branches;
next	1.202.2.8;

1.202.2.8
date	2006.07.04.13.42.10;	author drow;	state Exp;
branches;
next	;

1.202.2.3.2.1
date	2006.04.11.18.03.01;	author drow;	state Exp;
branches;
next	1.202.2.3.2.2;

1.202.2.3.2.2
date	2006.04.11.21.58.24;	author drow;	state Exp;
branches;
next	1.202.2.3.2.3;

1.202.2.3.2.3
date	2006.04.12.14.48.21;	author drow;	state Exp;
branches;
next	1.202.2.3.2.4;

1.202.2.3.2.4
date	2006.04.12.14.52.04;	author drow;	state Exp;
branches;
next	1.202.2.3.2.5;

1.202.2.3.2.5
date	2006.04.12.18.11.39;	author drow;	state Exp;
branches;
next	1.202.2.3.2.6;

1.202.2.3.2.6
date	2006.05.08.20.19.58;	author drow;	state Exp;
branches;
next	1.202.2.3.2.7;

1.202.2.3.2.7
date	2006.05.09.17.46.17;	author drow;	state Exp;
branches;
next	1.202.2.3.2.8;

1.202.2.3.2.8
date	2006.05.23.21.44.18;	author drow;	state Exp;
branches;
next	1.202.2.3.2.9;

1.202.2.3.2.9
date	2006.05.23.22.21.01;	author drow;	state Exp;
branches;
next	1.202.2.3.2.10;

1.202.2.3.2.10
date	2006.05.31.16.18.16;	author drow;	state Exp;
branches;
next	1.202.2.3.2.11;

1.202.2.3.2.11
date	2006.06.01.15.46.41;	author drow;	state Exp;
branches;
next	1.202.2.3.2.12;

1.202.2.3.2.12
date	2006.06.01.15.53.17;	author drow;	state Exp;
branches;
next	1.202.2.3.2.13;

1.202.2.3.2.13
date	2006.06.01.20.03.30;	author drow;	state Exp;
branches;
next	1.202.2.3.2.14;

1.202.2.3.2.14
date	2006.06.02.18.38.43;	author drow;	state Exp;
branches;
next	1.202.2.3.2.15;

1.202.2.3.2.15
date	2006.08.30.13.39.39;	author drow;	state Exp;
branches;
next	;

1.202.4.1
date	2006.03.03.20.46.37;	author drow;	state Exp;
branches;
next	1.202.4.2;

1.202.4.2
date	2006.03.23.21.49.58;	author drow;	state Exp;
branches;
next	1.202.4.3;

1.202.4.3
date	2006.03.31.18.15.57;	author drow;	state Exp;
branches;
next	1.202.4.4;

1.202.4.4
date	2006.03.31.21.54.54;	author drow;	state Exp;
branches;
next	1.202.4.5;

1.202.4.5
date	2006.04.02.21.47.50;	author drow;	state Exp;
branches;
next	;

1.195.2.1
date	2005.10.20.03.36.28;	author pbrook;	state Exp;
branches;
next	1.195.2.2;

1.195.2.2
date	2006.01.26.18.05.55;	author drow;	state Exp;
branches;
next	1.195.2.3;

1.195.2.3
date	2006.01.26.18.11.40;	author drow;	state Exp;
branches;
next	;

1.195.6.1
date	2006.01.26.18.10.22;	author drow;	state Exp;
branches;
next	1.195.6.2;

1.195.6.2
date	2006.01.26.18.11.52;	author drow;	state Exp;
branches;
next	;

1.192.2.1
date	2005.06.04.02.18.28;	author msnyder;	state Exp;
branches;
next	;

1.178.2.1
date	2005.03.29.02.52.05;	author pbrook;	state Exp;
branches;
next	;

1.151.2.1
date	2004.11.05.23.38.25;	author cagney;	state Exp;
branches;
next	;

1.130.4.1
date	2004.03.09.22.59.00;	author cagney;	state Exp;
branches;
next	1.130.4.2;

1.130.4.2
date	2004.03.16.16.05.55;	author cagney;	state Exp;
branches;
next	;

1.129.2.1
date	2004.03.27.17.37.50;	author drow;	state Exp;
branches;
next	1.129.2.2;

1.129.2.2
date	2004.09.16.17.01.18;	author drow;	state Exp;
branches;
next	;

1.107.2.1
date	2003.06.29.21.17.48;	author cagney;	state Exp;
branches;
next	1.107.2.2;

1.107.2.2
date	2003.06.30.15.03.55;	author cagney;	state Exp;
branches;
next	1.107.2.3;

1.107.2.3
date	2003.06.30.15.51.49;	author cagney;	state Exp;
branches;
next	;

1.100.2.1
date	2003.05.21.22.02.12;	author cagney;	state Exp;
branches;
next	;

1.98.4.1
date	2003.06.03.20.54.39;	author cagney;	state Exp;
branches;
next	;

1.96.2.1
date	2003.05.18.09.44.20;	author kettenis;	state Exp;
branches;
next	;

1.93.4.1
date	2002.08.29.18.22.44;	author cagney;	state Exp;
branches;
next	;

1.93.8.1
date	2002.11.15.19.18.54;	author carlton;	state Exp;
branches;
next	1.93.8.2;

1.93.8.2
date	2003.03.06.00.56.31;	author carlton;	state Exp;
branches;
next	1.93.8.3;

1.93.8.3
date	2003.03.07.22.52.54;	author carlton;	state Exp;
branches;
next	1.93.8.4;

1.93.8.4
date	2003.05.01.00.46.52;	author carlton;	state Exp;
branches;
next	1.93.8.5;

1.93.8.5
date	2003.05.23.18.40.44;	author carlton;	state Exp;
branches;
next	1.93.8.6;

1.93.8.6
date	2003.06.27.21.50.07;	author carlton;	state Exp;
branches;
next	1.93.8.7;

1.93.8.7
date	2003.08.05.17.13.13;	author carlton;	state Exp;
branches;
next	1.93.8.8;

1.93.8.8
date	2003.09.17.21.28.30;	author carlton;	state Exp;
branches;
next	1.93.8.9;

1.93.8.9
date	2003.11.11.23.50.53;	author carlton;	state Exp;
branches;
next	1.93.8.10;

1.93.8.10
date	2003.12.16.00.00.47;	author carlton;	state Exp;
branches;
next	1.93.8.11;

1.93.8.11
date	2004.01.26.19.11.29;	author carlton;	state Exp;
branches;
next	;

1.93.10.1
date	2003.12.14.20.27.29;	author drow;	state Exp;
branches;
next	1.93.10.2;

1.93.10.2
date	2004.02.09.19.43.46;	author drow;	state Exp;
branches;
next	;

1.84.2.1
date	2002.06.20.01.32.58;	author kseitz;	state Exp;
branches;
next	1.84.2.2;

1.84.2.2
date	2002.07.22.21.47.02;	author kseitz;	state Exp;
branches;
next	1.84.2.3;

1.84.2.3
date	2002.08.09.18.34.26;	author kseitz;	state Exp;
branches;
next	1.84.2.4;

1.84.2.4
date	2002.08.30.22.52.45;	author kseitz;	state Exp;
branches;
next	;

1.81.2.1
date	2002.06.15.16.42.54;	author cagney;	state Exp;
branches;
next	1.81.2.2;

1.81.2.2
date	2002.06.21.16.19.28;	author cagney;	state Exp;
branches;
next	;

1.61.2.1
date	2001.08.10.10.11.14;	author orjanf;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.04;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.25.07;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.05.05.14.42.50;	author shebs;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.05.25.18.03.09;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.06.07.19.17.47;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.06.14.18.07.57;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.06.28.16.00.51;	author jsm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	99.07.05.17.53.48;	author jsm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	99.07.07.17.22.59;	author jsm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	99.07.07.20.09.32;	author jsm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	99.07.12.11.06.52;	author jsm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	99.07.19.23.28.08;	author jsm;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	99.07.27.00.51.01;	author jsm;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	99.08.09.21.33.50;	author jsm;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	99.08.16.19.53.48;	author jsm;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	99.08.23.22.35.56;	author jsm;	state Exp;
branches;
next	1.1.1.17;

1.1.1.17
date	99.08.31.01.05.51;	author jsm;	state Exp;
branches;
next	1.1.1.18;

1.1.1.18
date	99.09.08.23.59.28;	author shebs;	state Exp;
branches;
next	1.1.1.19;

1.1.1.19
date	99.09.13.21.37.39;	author jsm;	state Exp;
branches;
next	1.1.1.20;

1.1.1.20
date	99.09.22.03.24.58;	author jsm;	state Exp;
branches;
next	1.1.1.21;

1.1.1.21
date	99.09.28.21.52.28;	author jsm;	state Exp;
branches;
next	1.1.1.22;

1.1.1.22
date	99.10.05.23.08.43;	author jsm;	state Exp;
branches;
next	1.1.1.23;

1.1.1.23
date	99.10.12.04.37.24;	author jsm;	state Exp;
branches;
next	1.1.1.24;

1.1.1.24
date	99.10.19.02.46.39;	author jsm;	state Exp;
branches;
next	1.1.1.25;

1.1.1.25
date	99.10.26.03.43.14;	author jsm;	state Exp;
branches;
next	1.1.1.26;

1.1.1.26
date	99.11.09.01.23.06;	author jsm;	state Exp;
branches;
next	1.1.1.27;

1.1.1.27
date	99.12.07.03.56.05;	author jsm;	state Exp;
branches;
next	1.1.1.28;

1.1.1.28
date	99.12.14.01.05.36;	author jsm;	state Exp;
branches;
next	1.1.1.29;

1.1.1.29
date	99.12.22.21.45.09;	author jsm;	state Exp;
branches;
next	1.1.1.30;

1.1.1.30
date	2000.01.11.03.07.24;	author jsm;	state Exp;
branches;
next	1.1.1.31;

1.1.1.31
date	2000.02.02.00.21.06;	author jsm;	state Exp;
branches;
next	1.1.1.32;

1.1.1.32
date	2000.02.03.04.14.34;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.583
log
@gdb/

	Typo fix in my previous commit.
@
text
@/* Remote target communications for serial-line targets in custom GDB protocol

   Copyright (C) 1988-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* See the GDB User Guide for details of the GDB remote protocol.  */

#include "defs.h"
#include "gdb_string.h"
#include <ctype.h>
#include <fcntl.h>
#include "inferior.h"
#include "bfd.h"
#include "symfile.h"
#include "exceptions.h"
#include "target.h"
/*#include "terminal.h" */
#include "gdbcmd.h"
#include "objfiles.h"
#include "gdb-stabs.h"
#include "gdbthread.h"
#include "remote.h"
#include "remote-notif.h"
#include "regcache.h"
#include "value.h"
#include "gdb_assert.h"
#include "observer.h"
#include "solib.h"
#include "cli/cli-decode.h"
#include "cli/cli-setshow.h"
#include "target-descriptions.h"
#include "gdb_bfd.h"
#include "filestuff.h"

#include <ctype.h>
#include <sys/time.h>

#include "event-loop.h"
#include "event-top.h"
#include "inf-loop.h"

#include <signal.h>
#include "serial.h"

#include "gdbcore.h" /* for exec_bfd */

#include "remote-fileio.h"
#include "gdb/fileio.h"
#include "gdb_stat.h"
#include "xml-support.h"

#include "memory-map.h"

#include "tracepoint.h"
#include "ax.h"
#include "ax-gdb.h"
#include "agent.h"
#include "btrace.h"

/* Temp hacks for tracepoint encoding migration.  */
static char *target_buf;
static long target_buf_size;

/* The size to align memory write packets, when practical.  The protocol
   does not guarantee any alignment, and gdb will generate short
   writes and unaligned writes, but even as a best-effort attempt this
   can improve bulk transfers.  For instance, if a write is misaligned
   relative to the target's data bus, the stub may need to make an extra
   round trip fetching data from the target.  This doesn't make a
   huge difference, but it's easy to do, so we try to be helpful.

   The alignment chosen is arbitrary; usually data bus width is
   important here, not the possibly larger cache line size.  */
enum { REMOTE_ALIGN_WRITES = 16 };

/* Prototypes for local functions.  */
static void async_cleanup_sigint_signal_handler (void *dummy);
static int getpkt_sane (char **buf, long *sizeof_buf, int forever);
static int getpkt_or_notif_sane (char **buf, long *sizeof_buf,
				 int forever, int *is_notif);

static void async_handle_remote_sigint (int);
static void async_handle_remote_sigint_twice (int);

static void remote_files_info (struct target_ops *ignore);

static void remote_prepare_to_store (struct regcache *regcache);

static void remote_open (char *name, int from_tty);

static void extended_remote_open (char *name, int from_tty);

static void remote_open_1 (char *, int, struct target_ops *, int extended_p);

static void remote_close (void);

static void remote_mourn (struct target_ops *ops);

static void extended_remote_restart (void);

static void extended_remote_mourn (struct target_ops *);

static void remote_mourn_1 (struct target_ops *);

static void remote_send (char **buf, long *sizeof_buf_p);

static int readchar (int timeout);

static void remote_serial_write (const char *str, int len);

static void remote_kill (struct target_ops *ops);

static int tohex (int nib);

static int remote_can_async_p (void);

static int remote_is_async_p (void);

static void remote_async (void (*callback) (enum inferior_event_type event_type,
					    void *context), void *context);

static void remote_detach (struct target_ops *ops, char *args, int from_tty);

static void sync_remote_interrupt_twice (int signo);

static void interrupt_query (void);

static void set_general_thread (struct ptid ptid);
static void set_continue_thread (struct ptid ptid);

static void get_offsets (void);

static void skip_frame (void);

static long read_frame (char **buf_p, long *sizeof_buf);

static int hexnumlen (ULONGEST num);

static void init_remote_ops (void);

static void init_extended_remote_ops (void);

static void remote_stop (ptid_t);

static int ishex (int ch, int *val);

static int stubhex (int ch);

static int hexnumstr (char *, ULONGEST);

static int hexnumnstr (char *, ULONGEST, int);

static CORE_ADDR remote_address_masked (CORE_ADDR);

static void print_packet (char *);

static void compare_sections_command (char *, int);

static void packet_command (char *, int);

static int stub_unpack_int (char *buff, int fieldlength);

static ptid_t remote_current_thread (ptid_t oldptid);

static void remote_find_new_threads (void);

static int fromhex (int a);

static int putpkt_binary (char *buf, int cnt);

static void check_binary_download (CORE_ADDR addr);

struct packet_config;

static void show_packet_config_cmd (struct packet_config *config);

static void update_packet_config (struct packet_config *config);

static void set_remote_protocol_packet_cmd (char *args, int from_tty,
					    struct cmd_list_element *c);

static void show_remote_protocol_packet_cmd (struct ui_file *file,
					     int from_tty,
					     struct cmd_list_element *c,
					     const char *value);

static char *write_ptid (char *buf, const char *endbuf, ptid_t ptid);
static ptid_t read_ptid (char *buf, char **obuf);

static void remote_set_permissions (void);

struct remote_state;
static int remote_get_trace_status (struct trace_status *ts);

static int remote_upload_tracepoints (struct uploaded_tp **utpp);

static int remote_upload_trace_state_variables (struct uploaded_tsv **utsvp);
  
static void remote_query_supported (void);

static void remote_check_symbols (void);

void _initialize_remote (void);

struct stop_reply;
static void stop_reply_xfree (struct stop_reply *);
static void remote_parse_stop_reply (char *, struct stop_reply *);
static void push_stop_reply (struct stop_reply *);
static void discard_pending_stop_replies_in_queue (struct remote_state *);
static int peek_stop_reply (ptid_t ptid);

static void remote_async_inferior_event_handler (gdb_client_data);

static void remote_terminal_ours (void);

static int remote_read_description_p (struct target_ops *target);

static void remote_console_output (char *msg);

static int remote_supports_cond_breakpoints (void);

static int remote_can_run_breakpoint_commands (void);

/* For "remote".  */

static struct cmd_list_element *remote_cmdlist;

/* For "set remote" and "show remote".  */

static struct cmd_list_element *remote_set_cmdlist;
static struct cmd_list_element *remote_show_cmdlist;

/* Stub vCont actions support.

   Each field is a boolean flag indicating whether the stub reports
   support for the corresponding action.  */

struct vCont_action_support
{
  /* vCont;t */
  int t;

  /* vCont;r */
  int r;
};

/* Controls whether GDB is willing to use range stepping.  */

static int use_range_stepping = 1;

#define OPAQUETHREADBYTES 8

/* a 64 bit opaque identifier */
typedef unsigned char threadref[OPAQUETHREADBYTES];

/* About this many threadisds fit in a packet.  */

#define MAXTHREADLISTRESULTS 32

/* Description of the remote protocol state for the currently
   connected target.  This is per-target state, and independent of the
   selected architecture.  */

struct remote_state
{
  /* A buffer to use for incoming packets, and its current size.  The
     buffer is grown dynamically for larger incoming packets.
     Outgoing packets may also be constructed in this buffer.
     BUF_SIZE is always at least REMOTE_PACKET_SIZE;
     REMOTE_PACKET_SIZE should be used to limit the length of outgoing
     packets.  */
  char *buf;
  long buf_size;

  /* True if we're going through initial connection setup (finding out
     about the remote side's threads, relocating symbols, etc.).  */
  int starting_up;

  /* If we negotiated packet size explicitly (and thus can bypass
     heuristics for the largest packet size that will not overflow
     a buffer in the stub), this will be set to that packet size.
     Otherwise zero, meaning to use the guessed size.  */
  long explicit_packet_size;

  /* remote_wait is normally called when the target is running and
     waits for a stop reply packet.  But sometimes we need to call it
     when the target is already stopped.  We can send a "?" packet
     and have remote_wait read the response.  Or, if we already have
     the response, we can stash it in BUF and tell remote_wait to
     skip calling getpkt.  This flag is set when BUF contains a
     stop reply packet and the target is not waiting.  */
  int cached_wait_status;

  /* True, if in no ack mode.  That is, neither GDB nor the stub will
     expect acks from each other.  The connection is assumed to be
     reliable.  */
  int noack_mode;

  /* True if we're connected in extended remote mode.  */
  int extended;

  /* True if the stub reported support for multi-process
     extensions.  */
  int multi_process_aware;

  /* True if we resumed the target and we're waiting for the target to
     stop.  In the mean time, we can't start another command/query.
     The remote server wouldn't be ready to process it, so we'd
     timeout waiting for a reply that would never come and eventually
     we'd close the connection.  This can happen in asynchronous mode
     because we allow GDB commands while the target is running.  */
  int waiting_for_stop_reply;

  /* True if the stub reports support for non-stop mode.  */
  int non_stop_aware;

  /* The status of the stub support for the various vCont actions.  */
  struct vCont_action_support supports_vCont;

  /* True if the stub reports support for conditional tracepoints.  */
  int cond_tracepoints;

  /* True if the stub reports support for target-side breakpoint
     conditions.  */
  int cond_breakpoints;

  /* True if the stub reports support for target-side breakpoint
     commands.  */
  int breakpoint_commands;

  /* True if the stub reports support for fast tracepoints.  */
  int fast_tracepoints;

  /* True if the stub reports support for static tracepoints.  */
  int static_tracepoints;

  /* True if the stub reports support for installing tracepoint while
     tracing.  */
  int install_in_trace;

  /* True if the stub can continue running a trace while GDB is
     disconnected.  */
  int disconnected_tracing;

  /* True if the stub reports support for enabling and disabling
     tracepoints while a trace experiment is running.  */
  int enable_disable_tracepoints;

  /* True if the stub can collect strings using tracenz bytecode.  */
  int string_tracing;

  /* True if the stub supports qXfer:libraries-svr4:read with a
     non-empty annex.  */
  int augmented_libraries_svr4_read;

  /* Nonzero if the user has pressed Ctrl-C, but the target hasn't
     responded to that.  */
  int ctrlc_pending_p;

  /* Descriptor for I/O to remote machine.  Initialize it to NULL so that
     remote_open knows that we don't have a file open when the program
     starts.  */
  struct serial *remote_desc;

  /* These are the threads which we last sent to the remote system.  The
     TID member will be -1 for all or -2 for not sent yet.  */
  ptid_t general_thread;
  ptid_t continue_thread;

  /* This is the traceframe which we last selected on the remote system.
     It will be -1 if no traceframe is selected.  */
  int remote_traceframe_number;

  char *last_pass_packet;

  /* The last QProgramSignals packet sent to the target.  We bypass
     sending a new program signals list down to the target if the new
     packet is exactly the same as the last we sent.  IOW, we only let
     the target know about program signals list changes.  */
  char *last_program_signals_packet;

  enum gdb_signal last_sent_signal;

  int last_sent_step;

  char *finished_object;
  char *finished_annex;
  ULONGEST finished_offset;

  /* Should we try the 'ThreadInfo' query packet?

     This variable (NOT available to the user: auto-detect only!)
     determines whether GDB will use the new, simpler "ThreadInfo"
     query or the older, more complex syntax for thread queries.
     This is an auto-detect variable (set to true at each connect,
     and set to false when the target fails to recognize it).  */
  int use_threadinfo_query;
  int use_threadextra_query;

  void (*async_client_callback) (enum inferior_event_type event_type,
				 void *context);
  void *async_client_context;

  /* This is set to the data address of the access causing the target
     to stop for a watchpoint.  */
  CORE_ADDR remote_watch_data_address;

  /* This is non-zero if target stopped for a watchpoint.  */
  int remote_stopped_by_watchpoint_p;

  threadref echo_nextthread;
  threadref nextthread;
  threadref resultthreadlist[MAXTHREADLISTRESULTS];

  /* The state of remote notification.  */
  struct remote_notif_state *notif_state;
};

/* Private data that we'll store in (struct thread_info)->private.  */
struct private_thread_info
{
  char *extra;
  int core;
};

static void
free_private_thread_info (struct private_thread_info *info)
{
  xfree (info->extra);
  xfree (info);
}

/* Returns true if the multi-process extensions are in effect.  */
static int
remote_multi_process_p (struct remote_state *rs)
{
  return rs->multi_process_aware;
}

/* This data could be associated with a target, but we do not always
   have access to the current target when we need it, so for now it is
   static.  This will be fine for as long as only one target is in use
   at a time.  */
static struct remote_state *remote_state;

static struct remote_state *
get_remote_state_raw (void)
{
  return remote_state;
}

/* Allocate a new struct remote_state with xmalloc, initialize it, and
   return it.  */

static struct remote_state *
new_remote_state (void)
{
  struct remote_state *result = XCNEW (struct remote_state);

  /* The default buffer size is unimportant; it will be expanded
     whenever a larger buffer is needed. */
  result->buf_size = 400;
  result->buf = xmalloc (result->buf_size);
  result->remote_traceframe_number = -1;
  result->last_sent_signal = GDB_SIGNAL_0;

  return result;
}

/* Description of the remote protocol for a given architecture.  */

struct packet_reg
{
  long offset; /* Offset into G packet.  */
  long regnum; /* GDB's internal register number.  */
  LONGEST pnum; /* Remote protocol register number.  */
  int in_g_packet; /* Always part of G packet.  */
  /* long size in bytes;  == register_size (target_gdbarch (), regnum);
     at present.  */
  /* char *name; == gdbarch_register_name (target_gdbarch (), regnum);
     at present.  */
};

struct remote_arch_state
{
  /* Description of the remote protocol registers.  */
  long sizeof_g_packet;

  /* Description of the remote protocol registers indexed by REGNUM
     (making an array gdbarch_num_regs in size).  */
  struct packet_reg *regs;

  /* This is the size (in chars) of the first response to the ``g''
     packet.  It is used as a heuristic when determining the maximum
     size of memory-read and memory-write packets.  A target will
     typically only reserve a buffer large enough to hold the ``g''
     packet.  The size does not include packet overhead (headers and
     trailers).  */
  long actual_register_packet_size;

  /* This is the maximum size (in chars) of a non read/write packet.
     It is also used as a cap on the size of read/write packets.  */
  long remote_packet_size;
};

/* Utility: generate error from an incoming stub packet.  */
static void
trace_error (char *buf)
{
  if (*buf++ != 'E')
    return;			/* not an error msg */
  switch (*buf)
    {
    case '1':			/* malformed packet error */
      if (*++buf == '0')	/*   general case: */
	error (_("remote.c: error in outgoing packet."));
      else
	error (_("remote.c: error in outgoing packet at field #%ld."),
	       strtol (buf, NULL, 16));
    default:
      error (_("Target returns error code '%s'."), buf);
    }
}

/* Utility: wait for reply from stub, while accepting "O" packets.  */
static char *
remote_get_noisy_reply (char **buf_p,
			long *sizeof_buf)
{
  do				/* Loop on reply from remote stub.  */
    {
      char *buf;

      QUIT;			/* Allow user to bail out with ^C.  */
      getpkt (buf_p, sizeof_buf, 0);
      buf = *buf_p;
      if (buf[0] == 'E')
	trace_error (buf);
      else if (strncmp (buf, "qRelocInsn:", strlen ("qRelocInsn:")) == 0)
	{
	  ULONGEST ul;
	  CORE_ADDR from, to, org_to;
	  char *p, *pp;
	  int adjusted_size = 0;
	  volatile struct gdb_exception ex;

	  p = buf + strlen ("qRelocInsn:");
	  pp = unpack_varlen_hex (p, &ul);
	  if (*pp != ';')
	    error (_("invalid qRelocInsn packet: %s"), buf);
	  from = ul;

	  p = pp + 1;
	  unpack_varlen_hex (p, &ul);
	  to = ul;

	  org_to = to;

	  TRY_CATCH (ex, RETURN_MASK_ALL)
	    {
	      gdbarch_relocate_instruction (target_gdbarch (), &to, from);
	    }
	  if (ex.reason >= 0)
	    {
	      adjusted_size = to - org_to;

	      xsnprintf (buf, *sizeof_buf, "qRelocInsn:%x", adjusted_size);
	      putpkt (buf);
	    }
	  else if (ex.reason < 0 && ex.error == MEMORY_ERROR)
	    {
	      /* Propagate memory errors silently back to the target.
		 The stub may have limited the range of addresses we
		 can write to, for example.  */
	      putpkt ("E01");
	    }
	  else
	    {
	      /* Something unexpectedly bad happened.  Be verbose so
		 we can tell what, and propagate the error back to the
		 stub, so it doesn't get stuck waiting for a
		 response.  */
	      exception_fprintf (gdb_stderr, ex,
				 _("warning: relocating instruction: "));
	      putpkt ("E01");
	    }
	}
      else if (buf[0] == 'O' && buf[1] != 'K')
	remote_console_output (buf + 1);	/* 'O' message from stub */
      else
	return buf;		/* Here's the actual reply.  */
    }
  while (1);
}

/* Handle for retreving the remote protocol data from gdbarch.  */
static struct gdbarch_data *remote_gdbarch_data_handle;

static struct remote_arch_state *
get_remote_arch_state (void)
{
  return gdbarch_data (target_gdbarch (), remote_gdbarch_data_handle);
}

/* Fetch the global remote target state.  */

static struct remote_state *
get_remote_state (void)
{
  /* Make sure that the remote architecture state has been
     initialized, because doing so might reallocate rs->buf.  Any
     function which calls getpkt also needs to be mindful of changes
     to rs->buf, but this call limits the number of places which run
     into trouble.  */
  get_remote_arch_state ();

  return get_remote_state_raw ();
}

static int
compare_pnums (const void *lhs_, const void *rhs_)
{
  const struct packet_reg * const *lhs = lhs_;
  const struct packet_reg * const *rhs = rhs_;

  if ((*lhs)->pnum < (*rhs)->pnum)
    return -1;
  else if ((*lhs)->pnum == (*rhs)->pnum)
    return 0;
  else
    return 1;
}

static int
map_regcache_remote_table (struct gdbarch *gdbarch, struct packet_reg *regs)
{
  int regnum, num_remote_regs, offset;
  struct packet_reg **remote_regs;

  for (regnum = 0; regnum < gdbarch_num_regs (gdbarch); regnum++)
    {
      struct packet_reg *r = &regs[regnum];

      if (register_size (gdbarch, regnum) == 0)
	/* Do not try to fetch zero-sized (placeholder) registers.  */
	r->pnum = -1;
      else
	r->pnum = gdbarch_remote_register_number (gdbarch, regnum);

      r->regnum = regnum;
    }

  /* Define the g/G packet format as the contents of each register
     with a remote protocol number, in order of ascending protocol
     number.  */

  remote_regs = alloca (gdbarch_num_regs (gdbarch)
			* sizeof (struct packet_reg *));
  for (num_remote_regs = 0, regnum = 0;
       regnum < gdbarch_num_regs (gdbarch);
       regnum++)
    if (regs[regnum].pnum != -1)
      remote_regs[num_remote_regs++] = &regs[regnum];

  qsort (remote_regs, num_remote_regs, sizeof (struct packet_reg *),
	 compare_pnums);

  for (regnum = 0, offset = 0; regnum < num_remote_regs; regnum++)
    {
      remote_regs[regnum]->in_g_packet = 1;
      remote_regs[regnum]->offset = offset;
      offset += register_size (gdbarch, remote_regs[regnum]->regnum);
    }

  return offset;
}

/* Given the architecture described by GDBARCH, return the remote
   protocol register's number and the register's offset in the g/G
   packets of GDB register REGNUM, in PNUM and POFFSET respectively.
   If the target does not have a mapping for REGNUM, return false,
   otherwise, return true.  */

int
remote_register_number_and_offset (struct gdbarch *gdbarch, int regnum,
				   int *pnum, int *poffset)
{
  int sizeof_g_packet;
  struct packet_reg *regs;
  struct cleanup *old_chain;

  gdb_assert (regnum < gdbarch_num_regs (gdbarch));

  regs = xcalloc (gdbarch_num_regs (gdbarch), sizeof (struct packet_reg));
  old_chain = make_cleanup (xfree, regs);

  sizeof_g_packet = map_regcache_remote_table (gdbarch, regs);

  *pnum = regs[regnum].pnum;
  *poffset = regs[regnum].offset;

  do_cleanups (old_chain);

  return *pnum != -1;
}

static void *
init_remote_state (struct gdbarch *gdbarch)
{
  struct remote_state *rs = get_remote_state_raw ();
  struct remote_arch_state *rsa;

  rsa = GDBARCH_OBSTACK_ZALLOC (gdbarch, struct remote_arch_state);

  /* Use the architecture to build a regnum<->pnum table, which will be
     1:1 unless a feature set specifies otherwise.  */
  rsa->regs = GDBARCH_OBSTACK_CALLOC (gdbarch,
				      gdbarch_num_regs (gdbarch),
				      struct packet_reg);

  /* Record the maximum possible size of the g packet - it may turn out
     to be smaller.  */
  rsa->sizeof_g_packet = map_regcache_remote_table (gdbarch, rsa->regs);

  /* Default maximum number of characters in a packet body.  Many
     remote stubs have a hardwired buffer size of 400 bytes
     (c.f. BUFMAX in m68k-stub.c and i386-stub.c).  BUFMAX-1 is used
     as the maximum packet-size to ensure that the packet and an extra
     NUL character can always fit in the buffer.  This stops GDB
     trashing stubs that try to squeeze an extra NUL into what is
     already a full buffer (As of 1999-12-04 that was most stubs).  */
  rsa->remote_packet_size = 400 - 1;

  /* This one is filled in when a ``g'' packet is received.  */
  rsa->actual_register_packet_size = 0;

  /* Should rsa->sizeof_g_packet needs more space than the
     default, adjust the size accordingly.  Remember that each byte is
     encoded as two characters.  32 is the overhead for the packet
     header / footer.  NOTE: cagney/1999-10-26: I suspect that 8
     (``$NN:G...#NN'') is a better guess, the below has been padded a
     little.  */
  if (rsa->sizeof_g_packet > ((rsa->remote_packet_size - 32) / 2))
    rsa->remote_packet_size = (rsa->sizeof_g_packet * 2 + 32);

  /* Make sure that the packet buffer is plenty big enough for
     this architecture.  */
  if (rs->buf_size < rsa->remote_packet_size)
    {
      rs->buf_size = 2 * rsa->remote_packet_size;
      rs->buf = xrealloc (rs->buf, rs->buf_size);
    }

  return rsa;
}

/* Return the current allowed size of a remote packet.  This is
   inferred from the current architecture, and should be used to
   limit the length of outgoing packets.  */
static long
get_remote_packet_size (void)
{
  struct remote_state *rs = get_remote_state ();
  struct remote_arch_state *rsa = get_remote_arch_state ();

  if (rs->explicit_packet_size)
    return rs->explicit_packet_size;

  return rsa->remote_packet_size;
}

static struct packet_reg *
packet_reg_from_regnum (struct remote_arch_state *rsa, long regnum)
{
  if (regnum < 0 && regnum >= gdbarch_num_regs (target_gdbarch ()))
    return NULL;
  else
    {
      struct packet_reg *r = &rsa->regs[regnum];

      gdb_assert (r->regnum == regnum);
      return r;
    }
}

static struct packet_reg *
packet_reg_from_pnum (struct remote_arch_state *rsa, LONGEST pnum)
{
  int i;

  for (i = 0; i < gdbarch_num_regs (target_gdbarch ()); i++)
    {
      struct packet_reg *r = &rsa->regs[i];

      if (r->pnum == pnum)
	return r;
    }
  return NULL;
}

static struct target_ops remote_ops;

static struct target_ops extended_remote_ops;

/* FIXME: cagney/1999-09-23: Even though getpkt was called with
   ``forever'' still use the normal timeout mechanism.  This is
   currently used by the ASYNC code to guarentee that target reads
   during the initial connect always time-out.  Once getpkt has been
   modified to return a timeout indication and, in turn
   remote_wait()/wait_for_inferior() have gained a timeout parameter
   this can go away.  */
static int wait_forever_enabled_p = 1;

/* Allow the user to specify what sequence to send to the remote
   when he requests a program interruption: Although ^C is usually
   what remote systems expect (this is the default, here), it is
   sometimes preferable to send a break.  On other systems such
   as the Linux kernel, a break followed by g, which is Magic SysRq g
   is required in order to interrupt the execution.  */
const char interrupt_sequence_control_c[] = "Ctrl-C";
const char interrupt_sequence_break[] = "BREAK";
const char interrupt_sequence_break_g[] = "BREAK-g";
static const char *const interrupt_sequence_modes[] =
  {
    interrupt_sequence_control_c,
    interrupt_sequence_break,
    interrupt_sequence_break_g,
    NULL
  };
static const char *interrupt_sequence_mode = interrupt_sequence_control_c;

static void
show_interrupt_sequence (struct ui_file *file, int from_tty,
			 struct cmd_list_element *c,
			 const char *value)
{
  if (interrupt_sequence_mode == interrupt_sequence_control_c)
    fprintf_filtered (file,
		      _("Send the ASCII ETX character (Ctrl-c) "
			"to the remote target to interrupt the "
			"execution of the program.\n"));
  else if (interrupt_sequence_mode == interrupt_sequence_break)
    fprintf_filtered (file,
		      _("send a break signal to the remote target "
			"to interrupt the execution of the program.\n"));
  else if (interrupt_sequence_mode == interrupt_sequence_break_g)
    fprintf_filtered (file,
		      _("Send a break signal and 'g' a.k.a. Magic SysRq g to "
			"the remote target to interrupt the execution "
			"of Linux kernel.\n"));
  else
    internal_error (__FILE__, __LINE__,
		    _("Invalid value for interrupt_sequence_mode: %s."),
		    interrupt_sequence_mode);
}

/* This boolean variable specifies whether interrupt_sequence is sent
   to the remote target when gdb connects to it.
   This is mostly needed when you debug the Linux kernel: The Linux kernel
   expects BREAK g which is Magic SysRq g for connecting gdb.  */
static int interrupt_on_connect = 0;

/* This variable is used to implement the "set/show remotebreak" commands.
   Since these commands are now deprecated in favor of "set/show remote
   interrupt-sequence", it no longer has any effect on the code.  */
static int remote_break;

static void
set_remotebreak (char *args, int from_tty, struct cmd_list_element *c)
{
  if (remote_break)
    interrupt_sequence_mode = interrupt_sequence_break;
  else
    interrupt_sequence_mode = interrupt_sequence_control_c;
}

static void
show_remotebreak (struct ui_file *file, int from_tty,
		  struct cmd_list_element *c,
		  const char *value)
{
}

/* This variable sets the number of bits in an address that are to be
   sent in a memory ("M" or "m") packet.  Normally, after stripping
   leading zeros, the entire address would be sent.  This variable
   restricts the address to REMOTE_ADDRESS_SIZE bits.  HISTORY: The
   initial implementation of remote.c restricted the address sent in
   memory packets to ``host::sizeof long'' bytes - (typically 32
   bits).  Consequently, for 64 bit targets, the upper 32 bits of an
   address was never sent.  Since fixing this bug may cause a break in
   some remote targets this variable is principly provided to
   facilitate backward compatibility.  */

static unsigned int remote_address_size;

/* Temporary to track who currently owns the terminal.  See
   remote_terminal_* for more details.  */

static int remote_async_terminal_ours_p;

/* The executable file to use for "run" on the remote side.  */

static char *remote_exec_file = "";


/* User configurable variables for the number of characters in a
   memory read/write packet.  MIN (rsa->remote_packet_size,
   rsa->sizeof_g_packet) is the default.  Some targets need smaller
   values (fifo overruns, et.al.) and some users need larger values
   (speed up transfers).  The variables ``preferred_*'' (the user
   request), ``current_*'' (what was actually set) and ``forced_*''
   (Positive - a soft limit, negative - a hard limit).  */

struct memory_packet_config
{
  char *name;
  long size;
  int fixed_p;
};

/* Compute the current size of a read/write packet.  Since this makes
   use of ``actual_register_packet_size'' the computation is dynamic.  */

static long
get_memory_packet_size (struct memory_packet_config *config)
{
  struct remote_state *rs = get_remote_state ();
  struct remote_arch_state *rsa = get_remote_arch_state ();

  /* NOTE: The somewhat arbitrary 16k comes from the knowledge (folk
     law?) that some hosts don't cope very well with large alloca()
     calls.  Eventually the alloca() code will be replaced by calls to
     xmalloc() and make_cleanups() allowing this restriction to either
     be lifted or removed.  */
#ifndef MAX_REMOTE_PACKET_SIZE
#define MAX_REMOTE_PACKET_SIZE 16384
#endif
  /* NOTE: 20 ensures we can write at least one byte.  */
#ifndef MIN_REMOTE_PACKET_SIZE
#define MIN_REMOTE_PACKET_SIZE 20
#endif
  long what_they_get;
  if (config->fixed_p)
    {
      if (config->size <= 0)
	what_they_get = MAX_REMOTE_PACKET_SIZE;
      else
	what_they_get = config->size;
    }
  else
    {
      what_they_get = get_remote_packet_size ();
      /* Limit the packet to the size specified by the user.  */
      if (config->size > 0
	  && what_they_get > config->size)
	what_they_get = config->size;

      /* Limit it to the size of the targets ``g'' response unless we have
	 permission from the stub to use a larger packet size.  */
      if (rs->explicit_packet_size == 0
	  && rsa->actual_register_packet_size > 0
	  && what_they_get > rsa->actual_register_packet_size)
	what_they_get = rsa->actual_register_packet_size;
    }
  if (what_they_get > MAX_REMOTE_PACKET_SIZE)
    what_they_get = MAX_REMOTE_PACKET_SIZE;
  if (what_they_get < MIN_REMOTE_PACKET_SIZE)
    what_they_get = MIN_REMOTE_PACKET_SIZE;

  /* Make sure there is room in the global buffer for this packet
     (including its trailing NUL byte).  */
  if (rs->buf_size < what_they_get + 1)
    {
      rs->buf_size = 2 * what_they_get;
      rs->buf = xrealloc (rs->buf, 2 * what_they_get);
    }

  return what_they_get;
}

/* Update the size of a read/write packet.  If they user wants
   something really big then do a sanity check.  */

static void
set_memory_packet_size (char *args, struct memory_packet_config *config)
{
  int fixed_p = config->fixed_p;
  long size = config->size;

  if (args == NULL)
    error (_("Argument required (integer, `fixed' or `limited')."));
  else if (strcmp (args, "hard") == 0
      || strcmp (args, "fixed") == 0)
    fixed_p = 1;
  else if (strcmp (args, "soft") == 0
	   || strcmp (args, "limit") == 0)
    fixed_p = 0;
  else
    {
      char *end;

      size = strtoul (args, &end, 0);
      if (args == end)
	error (_("Invalid %s (bad syntax)."), config->name);
#if 0
      /* Instead of explicitly capping the size of a packet to
         MAX_REMOTE_PACKET_SIZE or dissallowing it, the user is
         instead allowed to set the size to something arbitrarily
         large.  */
      if (size > MAX_REMOTE_PACKET_SIZE)
	error (_("Invalid %s (too large)."), config->name);
#endif
    }
  /* Extra checks?  */
  if (fixed_p && !config->fixed_p)
    {
      if (! query (_("The target may not be able to correctly handle a %s\n"
		   "of %ld bytes. Change the packet size? "),
		   config->name, size))
	error (_("Packet size not changed."));
    }
  /* Update the config.  */
  config->fixed_p = fixed_p;
  config->size = size;
}

static void
show_memory_packet_size (struct memory_packet_config *config)
{
  printf_filtered (_("The %s is %ld. "), config->name, config->size);
  if (config->fixed_p)
    printf_filtered (_("Packets are fixed at %ld bytes.\n"),
		     get_memory_packet_size (config));
  else
    printf_filtered (_("Packets are limited to %ld bytes.\n"),
		     get_memory_packet_size (config));
}

static struct memory_packet_config memory_write_packet_config =
{
  "memory-write-packet-size",
};

static void
set_memory_write_packet_size (char *args, int from_tty)
{
  set_memory_packet_size (args, &memory_write_packet_config);
}

static void
show_memory_write_packet_size (char *args, int from_tty)
{
  show_memory_packet_size (&memory_write_packet_config);
}

static long
get_memory_write_packet_size (void)
{
  return get_memory_packet_size (&memory_write_packet_config);
}

static struct memory_packet_config memory_read_packet_config =
{
  "memory-read-packet-size",
};

static void
set_memory_read_packet_size (char *args, int from_tty)
{
  set_memory_packet_size (args, &memory_read_packet_config);
}

static void
show_memory_read_packet_size (char *args, int from_tty)
{
  show_memory_packet_size (&memory_read_packet_config);
}

static long
get_memory_read_packet_size (void)
{
  long size = get_memory_packet_size (&memory_read_packet_config);

  /* FIXME: cagney/1999-11-07: Functions like getpkt() need to get an
     extra buffer size argument before the memory read size can be
     increased beyond this.  */
  if (size > get_remote_packet_size ())
    size = get_remote_packet_size ();
  return size;
}


/* Generic configuration support for packets the stub optionally
   supports.  Allows the user to specify the use of the packet as well
   as allowing GDB to auto-detect support in the remote stub.  */

enum packet_support
  {
    PACKET_SUPPORT_UNKNOWN = 0,
    PACKET_ENABLE,
    PACKET_DISABLE
  };

struct packet_config
  {
    const char *name;
    const char *title;
    enum auto_boolean detect;
    enum packet_support support;
  };

/* Analyze a packet's return value and update the packet config
   accordingly.  */

enum packet_result
{
  PACKET_ERROR,
  PACKET_OK,
  PACKET_UNKNOWN
};

static void
update_packet_config (struct packet_config *config)
{
  switch (config->detect)
    {
    case AUTO_BOOLEAN_TRUE:
      config->support = PACKET_ENABLE;
      break;
    case AUTO_BOOLEAN_FALSE:
      config->support = PACKET_DISABLE;
      break;
    case AUTO_BOOLEAN_AUTO:
      config->support = PACKET_SUPPORT_UNKNOWN;
      break;
    }
}

static void
show_packet_config_cmd (struct packet_config *config)
{
  char *support = "internal-error";

  switch (config->support)
    {
    case PACKET_ENABLE:
      support = "enabled";
      break;
    case PACKET_DISABLE:
      support = "disabled";
      break;
    case PACKET_SUPPORT_UNKNOWN:
      support = "unknown";
      break;
    }
  switch (config->detect)
    {
    case AUTO_BOOLEAN_AUTO:
      printf_filtered (_("Support for the `%s' packet "
			 "is auto-detected, currently %s.\n"),
		       config->name, support);
      break;
    case AUTO_BOOLEAN_TRUE:
    case AUTO_BOOLEAN_FALSE:
      printf_filtered (_("Support for the `%s' packet is currently %s.\n"),
		       config->name, support);
      break;
    }
}

static void
add_packet_config_cmd (struct packet_config *config, const char *name,
		       const char *title, int legacy)
{
  char *set_doc;
  char *show_doc;
  char *cmd_name;

  config->name = name;
  config->title = title;
  config->detect = AUTO_BOOLEAN_AUTO;
  config->support = PACKET_SUPPORT_UNKNOWN;
  set_doc = xstrprintf ("Set use of remote protocol `%s' (%s) packet",
			name, title);
  show_doc = xstrprintf ("Show current use of remote "
			 "protocol `%s' (%s) packet",
			 name, title);
  /* set/show TITLE-packet {auto,on,off} */
  cmd_name = xstrprintf ("%s-packet", title);
  add_setshow_auto_boolean_cmd (cmd_name, class_obscure,
				&config->detect, set_doc,
				show_doc, NULL, /* help_doc */
				set_remote_protocol_packet_cmd,
				show_remote_protocol_packet_cmd,
				&remote_set_cmdlist, &remote_show_cmdlist);
  /* The command code copies the documentation strings.  */
  xfree (set_doc);
  xfree (show_doc);
  /* set/show remote NAME-packet {auto,on,off} -- legacy.  */
  if (legacy)
    {
      char *legacy_name;

      legacy_name = xstrprintf ("%s-packet", name);
      add_alias_cmd (legacy_name, cmd_name, class_obscure, 0,
		     &remote_set_cmdlist);
      add_alias_cmd (legacy_name, cmd_name, class_obscure, 0,
		     &remote_show_cmdlist);
    }
}

static enum packet_result
packet_check_result (const char *buf)
{
  if (buf[0] != '\0')
    {
      /* The stub recognized the packet request.  Check that the
	 operation succeeded.  */
      if (buf[0] == 'E'
	  && isxdigit (buf[1]) && isxdigit (buf[2])
	  && buf[3] == '\0')
	/* "Enn"  - definitly an error.  */
	return PACKET_ERROR;

      /* Always treat "E." as an error.  This will be used for
	 more verbose error messages, such as E.memtypes.  */
      if (buf[0] == 'E' && buf[1] == '.')
	return PACKET_ERROR;

      /* The packet may or may not be OK.  Just assume it is.  */
      return PACKET_OK;
    }
  else
    /* The stub does not support the packet.  */
    return PACKET_UNKNOWN;
}

static enum packet_result
packet_ok (const char *buf, struct packet_config *config)
{
  enum packet_result result;

  result = packet_check_result (buf);
  switch (result)
    {
    case PACKET_OK:
    case PACKET_ERROR:
      /* The stub recognized the packet request.  */
      switch (config->support)
	{
	case PACKET_SUPPORT_UNKNOWN:
	  if (remote_debug)
	    fprintf_unfiltered (gdb_stdlog,
				    "Packet %s (%s) is supported\n",
				    config->name, config->title);
	  config->support = PACKET_ENABLE;
	  break;
	case PACKET_DISABLE:
	  internal_error (__FILE__, __LINE__,
			  _("packet_ok: attempt to use a disabled packet"));
	  break;
	case PACKET_ENABLE:
	  break;
	}
      break;
    case PACKET_UNKNOWN:
      /* The stub does not support the packet.  */
      switch (config->support)
	{
	case PACKET_ENABLE:
	  if (config->detect == AUTO_BOOLEAN_AUTO)
	    /* If the stub previously indicated that the packet was
	       supported then there is a protocol error..  */
	    error (_("Protocol error: %s (%s) conflicting enabled responses."),
		   config->name, config->title);
	  else
	    /* The user set it wrong.  */
	    error (_("Enabled packet %s (%s) not recognized by stub"),
		   config->name, config->title);
	  break;
	case PACKET_SUPPORT_UNKNOWN:
	  if (remote_debug)
	    fprintf_unfiltered (gdb_stdlog,
				"Packet %s (%s) is NOT supported\n",
				config->name, config->title);
	  config->support = PACKET_DISABLE;
	  break;
	case PACKET_DISABLE:
	  break;
	}
      break;
    }

  return result;
}

enum {
  PACKET_vCont = 0,
  PACKET_X,
  PACKET_qSymbol,
  PACKET_P,
  PACKET_p,
  PACKET_Z0,
  PACKET_Z1,
  PACKET_Z2,
  PACKET_Z3,
  PACKET_Z4,
  PACKET_vFile_open,
  PACKET_vFile_pread,
  PACKET_vFile_pwrite,
  PACKET_vFile_close,
  PACKET_vFile_unlink,
  PACKET_vFile_readlink,
  PACKET_qXfer_auxv,
  PACKET_qXfer_features,
  PACKET_qXfer_libraries,
  PACKET_qXfer_libraries_svr4,
  PACKET_qXfer_memory_map,
  PACKET_qXfer_spu_read,
  PACKET_qXfer_spu_write,
  PACKET_qXfer_osdata,
  PACKET_qXfer_threads,
  PACKET_qXfer_statictrace_read,
  PACKET_qXfer_traceframe_info,
  PACKET_qXfer_uib,
  PACKET_qGetTIBAddr,
  PACKET_qGetTLSAddr,
  PACKET_qSupported,
  PACKET_qTStatus,
  PACKET_QPassSignals,
  PACKET_QProgramSignals,
  PACKET_qSearch_memory,
  PACKET_vAttach,
  PACKET_vRun,
  PACKET_QStartNoAckMode,
  PACKET_vKill,
  PACKET_qXfer_siginfo_read,
  PACKET_qXfer_siginfo_write,
  PACKET_qAttached,
  PACKET_ConditionalTracepoints,
  PACKET_ConditionalBreakpoints,
  PACKET_BreakpointCommands,
  PACKET_FastTracepoints,
  PACKET_StaticTracepoints,
  PACKET_InstallInTrace,
  PACKET_bc,
  PACKET_bs,
  PACKET_TracepointSource,
  PACKET_QAllow,
  PACKET_qXfer_fdpic,
  PACKET_QDisableRandomization,
  PACKET_QAgent,
  PACKET_QTBuffer_size,
  PACKET_Qbtrace_off,
  PACKET_Qbtrace_bts,
  PACKET_qXfer_btrace,
  PACKET_MAX
};

static struct packet_config remote_protocol_packets[PACKET_MAX];

static void
set_remote_protocol_packet_cmd (char *args, int from_tty,
				struct cmd_list_element *c)
{
  struct packet_config *packet;

  for (packet = remote_protocol_packets;
       packet < &remote_protocol_packets[PACKET_MAX];
       packet++)
    {
      if (&packet->detect == c->var)
	{
	  update_packet_config (packet);
	  return;
	}
    }
  internal_error (__FILE__, __LINE__, _("Could not find config for %s"),
		  c->name);
}

static void
show_remote_protocol_packet_cmd (struct ui_file *file, int from_tty,
				 struct cmd_list_element *c,
				 const char *value)
{
  struct packet_config *packet;

  for (packet = remote_protocol_packets;
       packet < &remote_protocol_packets[PACKET_MAX];
       packet++)
    {
      if (&packet->detect == c->var)
	{
	  show_packet_config_cmd (packet);
	  return;
	}
    }
  internal_error (__FILE__, __LINE__, _("Could not find config for %s"),
		  c->name);
}

/* Should we try one of the 'Z' requests?  */

enum Z_packet_type
{
  Z_PACKET_SOFTWARE_BP,
  Z_PACKET_HARDWARE_BP,
  Z_PACKET_WRITE_WP,
  Z_PACKET_READ_WP,
  Z_PACKET_ACCESS_WP,
  NR_Z_PACKET_TYPES
};

/* For compatibility with older distributions.  Provide a ``set remote
   Z-packet ...'' command that updates all the Z packet types.  */

static enum auto_boolean remote_Z_packet_detect;

static void
set_remote_protocol_Z_packet_cmd (char *args, int from_tty,
				  struct cmd_list_element *c)
{
  int i;

  for (i = 0; i < NR_Z_PACKET_TYPES; i++)
    {
      remote_protocol_packets[PACKET_Z0 + i].detect = remote_Z_packet_detect;
      update_packet_config (&remote_protocol_packets[PACKET_Z0 + i]);
    }
}

static void
show_remote_protocol_Z_packet_cmd (struct ui_file *file, int from_tty,
				   struct cmd_list_element *c,
				   const char *value)
{
  int i;

  for (i = 0; i < NR_Z_PACKET_TYPES; i++)
    {
      show_packet_config_cmd (&remote_protocol_packets[PACKET_Z0 + i]);
    }
}

/* Tokens for use by the asynchronous signal handlers for SIGINT.  */
static struct async_signal_handler *async_sigint_remote_twice_token;
static struct async_signal_handler *async_sigint_remote_token;


/* Asynchronous signal handle registered as event loop source for
   when we have pending events ready to be passed to the core.  */

static struct async_event_handler *remote_async_inferior_event_token;



static ptid_t magic_null_ptid;
static ptid_t not_sent_ptid;
static ptid_t any_thread_ptid;

/* Find out if the stub attached to PID (and hence GDB should offer to
   detach instead of killing it when bailing out).  */

static int
remote_query_attached (int pid)
{
  struct remote_state *rs = get_remote_state ();
  size_t size = get_remote_packet_size ();

  if (remote_protocol_packets[PACKET_qAttached].support == PACKET_DISABLE)
    return 0;

  if (remote_multi_process_p (rs))
    xsnprintf (rs->buf, size, "qAttached:%x", pid);
  else
    xsnprintf (rs->buf, size, "qAttached");

  putpkt (rs->buf);
  getpkt (&rs->buf, &rs->buf_size, 0);

  switch (packet_ok (rs->buf,
		     &remote_protocol_packets[PACKET_qAttached]))
    {
    case PACKET_OK:
      if (strcmp (rs->buf, "1") == 0)
	return 1;
      break;
    case PACKET_ERROR:
      warning (_("Remote failure reply: %s"), rs->buf);
      break;
    case PACKET_UNKNOWN:
      break;
    }

  return 0;
}

/* Add PID to GDB's inferior table.  If FAKE_PID_P is true, then PID
   has been invented by GDB, instead of reported by the target.  Since
   we can be connected to a remote system before before knowing about
   any inferior, mark the target with execution when we find the first
   inferior.  If ATTACHED is 1, then we had just attached to this
   inferior.  If it is 0, then we just created this inferior.  If it
   is -1, then try querying the remote stub to find out if it had
   attached to the inferior or not.  */

static struct inferior *
remote_add_inferior (int fake_pid_p, int pid, int attached)
{
  struct inferior *inf;

  /* Check whether this process we're learning about is to be
     considered attached, or if is to be considered to have been
     spawned by the stub.  */
  if (attached == -1)
    attached = remote_query_attached (pid);

  if (gdbarch_has_global_solist (target_gdbarch ()))
    {
      /* If the target shares code across all inferiors, then every
	 attach adds a new inferior.  */
      inf = add_inferior (pid);

      /* ... and every inferior is bound to the same program space.
	 However, each inferior may still have its own address
	 space.  */
      inf->aspace = maybe_new_address_space ();
      inf->pspace = current_program_space;
    }
  else
    {
      /* In the traditional debugging scenario, there's a 1-1 match
	 between program/address spaces.  We simply bind the inferior
	 to the program space's address space.  */
      inf = current_inferior ();
      inferior_appeared (inf, pid);
    }

  inf->attach_flag = attached;
  inf->fake_pid_p = fake_pid_p;

  return inf;
}

/* Add thread PTID to GDB's thread list.  Tag it as executing/running
   according to RUNNING.  */

static void
remote_add_thread (ptid_t ptid, int running)
{
  add_thread (ptid);

  set_executing (ptid, running);
  set_running (ptid, running);
}

/* Come here when we learn about a thread id from the remote target.
   It may be the first time we hear about such thread, so take the
   opportunity to add it to GDB's thread list.  In case this is the
   first time we're noticing its corresponding inferior, add it to
   GDB's inferior list as well.  */

static void
remote_notice_new_inferior (ptid_t currthread, int running)
{
  /* If this is a new thread, add it to GDB's thread list.
     If we leave it up to WFI to do this, bad things will happen.  */

  if (in_thread_list (currthread) && is_exited (currthread))
    {
      /* We're seeing an event on a thread id we knew had exited.
	 This has to be a new thread reusing the old id.  Add it.  */
      remote_add_thread (currthread, running);
      return;
    }

  if (!in_thread_list (currthread))
    {
      struct inferior *inf = NULL;
      int pid = ptid_get_pid (currthread);

      if (ptid_is_pid (inferior_ptid)
	  && pid == ptid_get_pid (inferior_ptid))
	{
	  /* inferior_ptid has no thread member yet.  This can happen
	     with the vAttach -> remote_wait,"TAAthread:" path if the
	     stub doesn't support qC.  This is the first stop reported
	     after an attach, so this is the main thread.  Update the
	     ptid in the thread list.  */
	  if (in_thread_list (pid_to_ptid (pid)))
	    thread_change_ptid (inferior_ptid, currthread);
	  else
	    {
	      remote_add_thread (currthread, running);
	      inferior_ptid = currthread;
	    }
	  return;
	}

      if (ptid_equal (magic_null_ptid, inferior_ptid))
	{
	  /* inferior_ptid is not set yet.  This can happen with the
	     vRun -> remote_wait,"TAAthread:" path if the stub
	     doesn't support qC.  This is the first stop reported
	     after an attach, so this is the main thread.  Update the
	     ptid in the thread list.  */
	  thread_change_ptid (inferior_ptid, currthread);
	  return;
	}

      /* When connecting to a target remote, or to a target
	 extended-remote which already was debugging an inferior, we
	 may not know about it yet.  Add it before adding its child
	 thread, so notifications are emitted in a sensible order.  */
      if (!in_inferior_list (ptid_get_pid (currthread)))
	{
	  struct remote_state *rs = get_remote_state ();
	  int fake_pid_p = !remote_multi_process_p (rs);

	  inf = remote_add_inferior (fake_pid_p,
				     ptid_get_pid (currthread), -1);
	}

      /* This is really a new thread.  Add it.  */
      remote_add_thread (currthread, running);

      /* If we found a new inferior, let the common code do whatever
	 it needs to with it (e.g., read shared libraries, insert
	 breakpoints).  */
      if (inf != NULL)
	notice_new_inferior (currthread, running, 0);
    }
}

/* Return the private thread data, creating it if necessary.  */

static struct private_thread_info *
demand_private_info (ptid_t ptid)
{
  struct thread_info *info = find_thread_ptid (ptid);

  gdb_assert (info);

  if (!info->private)
    {
      info->private = xmalloc (sizeof (*(info->private)));
      info->private_dtor = free_private_thread_info;
      info->private->core = -1;
      info->private->extra = 0;
    }

  return info->private;
}

/* Call this function as a result of
   1) A halt indication (T packet) containing a thread id
   2) A direct query of currthread
   3) Successful execution of set thread */

static void
record_currthread (struct remote_state *rs, ptid_t currthread)
{
  rs->general_thread = currthread;
}

/* If 'QPassSignals' is supported, tell the remote stub what signals
   it can simply pass through to the inferior without reporting.  */

static void
remote_pass_signals (int numsigs, unsigned char *pass_signals)
{
  if (remote_protocol_packets[PACKET_QPassSignals].support != PACKET_DISABLE)
    {
      char *pass_packet, *p;
      int count = 0, i;
      struct remote_state *rs = get_remote_state ();

      gdb_assert (numsigs < 256);
      for (i = 0; i < numsigs; i++)
	{
	  if (pass_signals[i])
	    count++;
	}
      pass_packet = xmalloc (count * 3 + strlen ("QPassSignals:") + 1);
      strcpy (pass_packet, "QPassSignals:");
      p = pass_packet + strlen (pass_packet);
      for (i = 0; i < numsigs; i++)
	{
	  if (pass_signals[i])
	    {
	      if (i >= 16)
		*p++ = tohex (i >> 4);
	      *p++ = tohex (i & 15);
	      if (count)
		*p++ = ';';
	      else
		break;
	      count--;
	    }
	}
      *p = 0;
      if (!rs->last_pass_packet || strcmp (rs->last_pass_packet, pass_packet))
	{
	  char *buf = rs->buf;

	  putpkt (pass_packet);
	  getpkt (&rs->buf, &rs->buf_size, 0);
	  packet_ok (buf, &remote_protocol_packets[PACKET_QPassSignals]);
	  if (rs->last_pass_packet)
	    xfree (rs->last_pass_packet);
	  rs->last_pass_packet = pass_packet;
	}
      else
	xfree (pass_packet);
    }
}

/* If 'QProgramSignals' is supported, tell the remote stub what
   signals it should pass through to the inferior when detaching.  */

static void
remote_program_signals (int numsigs, unsigned char *signals)
{
  if (remote_protocol_packets[PACKET_QProgramSignals].support != PACKET_DISABLE)
    {
      char *packet, *p;
      int count = 0, i;
      struct remote_state *rs = get_remote_state ();

      gdb_assert (numsigs < 256);
      for (i = 0; i < numsigs; i++)
	{
	  if (signals[i])
	    count++;
	}
      packet = xmalloc (count * 3 + strlen ("QProgramSignals:") + 1);
      strcpy (packet, "QProgramSignals:");
      p = packet + strlen (packet);
      for (i = 0; i < numsigs; i++)
	{
	  if (signal_pass_state (i))
	    {
	      if (i >= 16)
		*p++ = tohex (i >> 4);
	      *p++ = tohex (i & 15);
	      if (count)
		*p++ = ';';
	      else
		break;
	      count--;
	    }
	}
      *p = 0;
      if (!rs->last_program_signals_packet
	  || strcmp (rs->last_program_signals_packet, packet) != 0)
	{
	  char *buf = rs->buf;

	  putpkt (packet);
	  getpkt (&rs->buf, &rs->buf_size, 0);
	  packet_ok (buf, &remote_protocol_packets[PACKET_QProgramSignals]);
	  xfree (rs->last_program_signals_packet);
	  rs->last_program_signals_packet = packet;
	}
      else
	xfree (packet);
    }
}

/* If PTID is MAGIC_NULL_PTID, don't set any thread.  If PTID is
   MINUS_ONE_PTID, set the thread to -1, so the stub returns the
   thread.  If GEN is set, set the general thread, if not, then set
   the step/continue thread.  */
static void
set_thread (struct ptid ptid, int gen)
{
  struct remote_state *rs = get_remote_state ();
  ptid_t state = gen ? rs->general_thread : rs->continue_thread;
  char *buf = rs->buf;
  char *endbuf = rs->buf + get_remote_packet_size ();

  if (ptid_equal (state, ptid))
    return;

  *buf++ = 'H';
  *buf++ = gen ? 'g' : 'c';
  if (ptid_equal (ptid, magic_null_ptid))
    xsnprintf (buf, endbuf - buf, "0");
  else if (ptid_equal (ptid, any_thread_ptid))
    xsnprintf (buf, endbuf - buf, "0");
  else if (ptid_equal (ptid, minus_one_ptid))
    xsnprintf (buf, endbuf - buf, "-1");
  else
    write_ptid (buf, endbuf, ptid);
  putpkt (rs->buf);
  getpkt (&rs->buf, &rs->buf_size, 0);
  if (gen)
    rs->general_thread = ptid;
  else
    rs->continue_thread = ptid;
}

static void
set_general_thread (struct ptid ptid)
{
  set_thread (ptid, 1);
}

static void
set_continue_thread (struct ptid ptid)
{
  set_thread (ptid, 0);
}

/* Change the remote current process.  Which thread within the process
   ends up selected isn't important, as long as it is the same process
   as what INFERIOR_PTID points to.

   This comes from that fact that there is no explicit notion of
   "selected process" in the protocol.  The selected process for
   general operations is the process the selected general thread
   belongs to.  */

static void
set_general_process (void)
{
  struct remote_state *rs = get_remote_state ();

  /* If the remote can't handle multiple processes, don't bother.  */
  if (!rs->extended || !remote_multi_process_p (rs))
    return;

  /* We only need to change the remote current thread if it's pointing
     at some other process.  */
  if (ptid_get_pid (rs->general_thread) != ptid_get_pid (inferior_ptid))
    set_general_thread (inferior_ptid);
}


/*  Return nonzero if the thread PTID is still alive on the remote
    system.  */

static int
remote_thread_alive (struct target_ops *ops, ptid_t ptid)
{
  struct remote_state *rs = get_remote_state ();
  char *p, *endp;

  if (ptid_equal (ptid, magic_null_ptid))
    /* The main thread is always alive.  */
    return 1;

  if (ptid_get_pid (ptid) != 0 && ptid_get_tid (ptid) == 0)
    /* The main thread is always alive.  This can happen after a
       vAttach, if the remote side doesn't support
       multi-threading.  */
    return 1;

  p = rs->buf;
  endp = rs->buf + get_remote_packet_size ();

  *p++ = 'T';
  write_ptid (p, endp, ptid);

  putpkt (rs->buf);
  getpkt (&rs->buf, &rs->buf_size, 0);
  return (rs->buf[0] == 'O' && rs->buf[1] == 'K');
}

/* About these extended threadlist and threadinfo packets.  They are
   variable length packets but, the fields within them are often fixed
   length.  They are redundent enough to send over UDP as is the
   remote protocol in general.  There is a matching unit test module
   in libstub.  */

/* WARNING: This threadref data structure comes from the remote O.S.,
   libstub protocol encoding, and remote.c.  It is not particularly
   changable.  */

/* Right now, the internal structure is int. We want it to be bigger.
   Plan to fix this.  */

typedef int gdb_threadref;	/* Internal GDB thread reference.  */

/* gdb_ext_thread_info is an internal GDB data structure which is
   equivalent to the reply of the remote threadinfo packet.  */

struct gdb_ext_thread_info
  {
    threadref threadid;		/* External form of thread reference.  */
    int active;			/* Has state interesting to GDB?
				   regs, stack.  */
    char display[256];		/* Brief state display, name,
				   blocked/suspended.  */
    char shortname[32];		/* To be used to name threads.  */
    char more_display[256];	/* Long info, statistics, queue depth,
				   whatever.  */
  };

/* The volume of remote transfers can be limited by submitting
   a mask containing bits specifying the desired information.
   Use a union of these values as the 'selection' parameter to
   get_thread_info.  FIXME: Make these TAG names more thread specific.  */

#define TAG_THREADID 1
#define TAG_EXISTS 2
#define TAG_DISPLAY 4
#define TAG_THREADNAME 8
#define TAG_MOREDISPLAY 16

#define BUF_THREAD_ID_SIZE (OPAQUETHREADBYTES * 2)

char *unpack_varlen_hex (char *buff, ULONGEST *result);

static char *unpack_nibble (char *buf, int *val);

static char *pack_nibble (char *buf, int nibble);

static char *pack_hex_byte (char *pkt, int /* unsigned char */ byte);

static char *unpack_byte (char *buf, int *value);

static char *pack_int (char *buf, int value);

static char *unpack_int (char *buf, int *value);

static char *unpack_string (char *src, char *dest, int length);

static char *pack_threadid (char *pkt, threadref *id);

static char *unpack_threadid (char *inbuf, threadref *id);

void int_to_threadref (threadref *id, int value);

static int threadref_to_int (threadref *ref);

static void copy_threadref (threadref *dest, threadref *src);

static int threadmatch (threadref *dest, threadref *src);

static char *pack_threadinfo_request (char *pkt, int mode,
				      threadref *id);

static int remote_unpack_thread_info_response (char *pkt,
					       threadref *expectedref,
					       struct gdb_ext_thread_info
					       *info);


static int remote_get_threadinfo (threadref *threadid,
				  int fieldset,	/*TAG mask */
				  struct gdb_ext_thread_info *info);

static char *pack_threadlist_request (char *pkt, int startflag,
				      int threadcount,
				      threadref *nextthread);

static int parse_threadlist_response (char *pkt,
				      int result_limit,
				      threadref *original_echo,
				      threadref *resultlist,
				      int *doneflag);

static int remote_get_threadlist (int startflag,
				  threadref *nextthread,
				  int result_limit,
				  int *done,
				  int *result_count,
				  threadref *threadlist);

typedef int (*rmt_thread_action) (threadref *ref, void *context);

static int remote_threadlist_iterator (rmt_thread_action stepfunction,
				       void *context, int looplimit);

static int remote_newthread_step (threadref *ref, void *context);


/* Write a PTID to BUF.  ENDBUF points to one-passed-the-end of the
   buffer we're allowed to write to.  Returns
   BUF+CHARACTERS_WRITTEN.  */

static char *
write_ptid (char *buf, const char *endbuf, ptid_t ptid)
{
  int pid, tid;
  struct remote_state *rs = get_remote_state ();

  if (remote_multi_process_p (rs))
    {
      pid = ptid_get_pid (ptid);
      if (pid < 0)
	buf += xsnprintf (buf, endbuf - buf, "p-%x.", -pid);
      else
	buf += xsnprintf (buf, endbuf - buf, "p%x.", pid);
    }
  tid = ptid_get_tid (ptid);
  if (tid < 0)
    buf += xsnprintf (buf, endbuf - buf, "-%x", -tid);
  else
    buf += xsnprintf (buf, endbuf - buf, "%x", tid);

  return buf;
}

/* Extract a PTID from BUF.  If non-null, OBUF is set to the to one
   passed the last parsed char.  Returns null_ptid on error.  */

static ptid_t
read_ptid (char *buf, char **obuf)
{
  char *p = buf;
  char *pp;
  ULONGEST pid = 0, tid = 0;

  if (*p == 'p')
    {
      /* Multi-process ptid.  */
      pp = unpack_varlen_hex (p + 1, &pid);
      if (*pp != '.')
	error (_("invalid remote ptid: %s"), p);

      p = pp;
      pp = unpack_varlen_hex (p + 1, &tid);
      if (obuf)
	*obuf = pp;
      return ptid_build (pid, 0, tid);
    }

  /* No multi-process.  Just a tid.  */
  pp = unpack_varlen_hex (p, &tid);

  /* Since the stub is not sending a process id, then default to
     what's in inferior_ptid, unless it's null at this point.  If so,
     then since there's no way to know the pid of the reported
     threads, use the magic number.  */
  if (ptid_equal (inferior_ptid, null_ptid))
    pid = ptid_get_pid (magic_null_ptid);
  else
    pid = ptid_get_pid (inferior_ptid);

  if (obuf)
    *obuf = pp;
  return ptid_build (pid, 0, tid);
}

/* Encode 64 bits in 16 chars of hex.  */

static const char hexchars[] = "0123456789abcdef";

static int
ishex (int ch, int *val)
{
  if ((ch >= 'a') && (ch <= 'f'))
    {
      *val = ch - 'a' + 10;
      return 1;
    }
  if ((ch >= 'A') && (ch <= 'F'))
    {
      *val = ch - 'A' + 10;
      return 1;
    }
  if ((ch >= '0') && (ch <= '9'))
    {
      *val = ch - '0';
      return 1;
    }
  return 0;
}

static int
stubhex (int ch)
{
  if (ch >= 'a' && ch <= 'f')
    return ch - 'a' + 10;
  if (ch >= '0' && ch <= '9')
    return ch - '0';
  if (ch >= 'A' && ch <= 'F')
    return ch - 'A' + 10;
  return -1;
}

static int
stub_unpack_int (char *buff, int fieldlength)
{
  int nibble;
  int retval = 0;

  while (fieldlength)
    {
      nibble = stubhex (*buff++);
      retval |= nibble;
      fieldlength--;
      if (fieldlength)
	retval = retval << 4;
    }
  return retval;
}

char *
unpack_varlen_hex (char *buff,	/* packet to parse */
		   ULONGEST *result)
{
  int nibble;
  ULONGEST retval = 0;

  while (ishex (*buff, &nibble))
    {
      buff++;
      retval = retval << 4;
      retval |= nibble & 0x0f;
    }
  *result = retval;
  return buff;
}

static char *
unpack_nibble (char *buf, int *val)
{
  *val = fromhex (*buf++);
  return buf;
}

static char *
pack_nibble (char *buf, int nibble)
{
  *buf++ = hexchars[(nibble & 0x0f)];
  return buf;
}

static char *
pack_hex_byte (char *pkt, int byte)
{
  *pkt++ = hexchars[(byte >> 4) & 0xf];
  *pkt++ = hexchars[(byte & 0xf)];
  return pkt;
}

static char *
unpack_byte (char *buf, int *value)
{
  *value = stub_unpack_int (buf, 2);
  return buf + 2;
}

static char *
pack_int (char *buf, int value)
{
  buf = pack_hex_byte (buf, (value >> 24) & 0xff);
  buf = pack_hex_byte (buf, (value >> 16) & 0xff);
  buf = pack_hex_byte (buf, (value >> 8) & 0x0ff);
  buf = pack_hex_byte (buf, (value & 0xff));
  return buf;
}

static char *
unpack_int (char *buf, int *value)
{
  *value = stub_unpack_int (buf, 8);
  return buf + 8;
}

#if 0			/* Currently unused, uncomment when needed.  */
static char *pack_string (char *pkt, char *string);

static char *
pack_string (char *pkt, char *string)
{
  char ch;
  int len;

  len = strlen (string);
  if (len > 200)
    len = 200;		/* Bigger than most GDB packets, junk???  */
  pkt = pack_hex_byte (pkt, len);
  while (len-- > 0)
    {
      ch = *string++;
      if ((ch == '\0') || (ch == '#'))
	ch = '*';		/* Protect encapsulation.  */
      *pkt++ = ch;
    }
  return pkt;
}
#endif /* 0 (unused) */

static char *
unpack_string (char *src, char *dest, int length)
{
  while (length--)
    *dest++ = *src++;
  *dest = '\0';
  return src;
}

static char *
pack_threadid (char *pkt, threadref *id)
{
  char *limit;
  unsigned char *altid;

  altid = (unsigned char *) id;
  limit = pkt + BUF_THREAD_ID_SIZE;
  while (pkt < limit)
    pkt = pack_hex_byte (pkt, *altid++);
  return pkt;
}


static char *
unpack_threadid (char *inbuf, threadref *id)
{
  char *altref;
  char *limit = inbuf + BUF_THREAD_ID_SIZE;
  int x, y;

  altref = (char *) id;

  while (inbuf < limit)
    {
      x = stubhex (*inbuf++);
      y = stubhex (*inbuf++);
      *altref++ = (x << 4) | y;
    }
  return inbuf;
}

/* Externally, threadrefs are 64 bits but internally, they are still
   ints.  This is due to a mismatch of specifications.  We would like
   to use 64bit thread references internally.  This is an adapter
   function.  */

void
int_to_threadref (threadref *id, int value)
{
  unsigned char *scan;

  scan = (unsigned char *) id;
  {
    int i = 4;
    while (i--)
      *scan++ = 0;
  }
  *scan++ = (value >> 24) & 0xff;
  *scan++ = (value >> 16) & 0xff;
  *scan++ = (value >> 8) & 0xff;
  *scan++ = (value & 0xff);
}

static int
threadref_to_int (threadref *ref)
{
  int i, value = 0;
  unsigned char *scan;

  scan = *ref;
  scan += 4;
  i = 4;
  while (i-- > 0)
    value = (value << 8) | ((*scan++) & 0xff);
  return value;
}

static void
copy_threadref (threadref *dest, threadref *src)
{
  int i;
  unsigned char *csrc, *cdest;

  csrc = (unsigned char *) src;
  cdest = (unsigned char *) dest;
  i = 8;
  while (i--)
    *cdest++ = *csrc++;
}

static int
threadmatch (threadref *dest, threadref *src)
{
  /* Things are broken right now, so just assume we got a match.  */
#if 0
  unsigned char *srcp, *destp;
  int i, result;
  srcp = (char *) src;
  destp = (char *) dest;

  result = 1;
  while (i-- > 0)
    result &= (*srcp++ == *destp++) ? 1 : 0;
  return result;
#endif
  return 1;
}

/*
   threadid:1,        # always request threadid
   context_exists:2,
   display:4,
   unique_name:8,
   more_display:16
 */

/* Encoding:  'Q':8,'P':8,mask:32,threadid:64 */

static char *
pack_threadinfo_request (char *pkt, int mode, threadref *id)
{
  *pkt++ = 'q';				/* Info Query */
  *pkt++ = 'P';				/* process or thread info */
  pkt = pack_int (pkt, mode);		/* mode */
  pkt = pack_threadid (pkt, id);	/* threadid */
  *pkt = '\0';				/* terminate */
  return pkt;
}

/* These values tag the fields in a thread info response packet.  */
/* Tagging the fields allows us to request specific fields and to
   add more fields as time goes by.  */

#define TAG_THREADID 1		/* Echo the thread identifier.  */
#define TAG_EXISTS 2		/* Is this process defined enough to
				   fetch registers and its stack?  */
#define TAG_DISPLAY 4		/* A short thing maybe to put on a window */
#define TAG_THREADNAME 8	/* string, maps 1-to-1 with a thread is.  */
#define TAG_MOREDISPLAY 16	/* Whatever the kernel wants to say about
				   the process.  */

static int
remote_unpack_thread_info_response (char *pkt, threadref *expectedref,
				    struct gdb_ext_thread_info *info)
{
  struct remote_state *rs = get_remote_state ();
  int mask, length;
  int tag;
  threadref ref;
  char *limit = pkt + rs->buf_size; /* Plausible parsing limit.  */
  int retval = 1;

  /* info->threadid = 0; FIXME: implement zero_threadref.  */
  info->active = 0;
  info->display[0] = '\0';
  info->shortname[0] = '\0';
  info->more_display[0] = '\0';

  /* Assume the characters indicating the packet type have been
     stripped.  */
  pkt = unpack_int (pkt, &mask);	/* arg mask */
  pkt = unpack_threadid (pkt, &ref);

  if (mask == 0)
    warning (_("Incomplete response to threadinfo request."));
  if (!threadmatch (&ref, expectedref))
    {			/* This is an answer to a different request.  */
      warning (_("ERROR RMT Thread info mismatch."));
      return 0;
    }
  copy_threadref (&info->threadid, &ref);

  /* Loop on tagged fields , try to bail if somthing goes wrong.  */

  /* Packets are terminated with nulls.  */
  while ((pkt < limit) && mask && *pkt)
    {
      pkt = unpack_int (pkt, &tag);	/* tag */
      pkt = unpack_byte (pkt, &length);	/* length */
      if (!(tag & mask))		/* Tags out of synch with mask.  */
	{
	  warning (_("ERROR RMT: threadinfo tag mismatch."));
	  retval = 0;
	  break;
	}
      if (tag == TAG_THREADID)
	{
	  if (length != 16)
	    {
	      warning (_("ERROR RMT: length of threadid is not 16."));
	      retval = 0;
	      break;
	    }
	  pkt = unpack_threadid (pkt, &ref);
	  mask = mask & ~TAG_THREADID;
	  continue;
	}
      if (tag == TAG_EXISTS)
	{
	  info->active = stub_unpack_int (pkt, length);
	  pkt += length;
	  mask = mask & ~(TAG_EXISTS);
	  if (length > 8)
	    {
	      warning (_("ERROR RMT: 'exists' length too long."));
	      retval = 0;
	      break;
	    }
	  continue;
	}
      if (tag == TAG_THREADNAME)
	{
	  pkt = unpack_string (pkt, &info->shortname[0], length);
	  mask = mask & ~TAG_THREADNAME;
	  continue;
	}
      if (tag == TAG_DISPLAY)
	{
	  pkt = unpack_string (pkt, &info->display[0], length);
	  mask = mask & ~TAG_DISPLAY;
	  continue;
	}
      if (tag == TAG_MOREDISPLAY)
	{
	  pkt = unpack_string (pkt, &info->more_display[0], length);
	  mask = mask & ~TAG_MOREDISPLAY;
	  continue;
	}
      warning (_("ERROR RMT: unknown thread info tag."));
      break;			/* Not a tag we know about.  */
    }
  return retval;
}

static int
remote_get_threadinfo (threadref *threadid, int fieldset,	/* TAG mask */
		       struct gdb_ext_thread_info *info)
{
  struct remote_state *rs = get_remote_state ();
  int result;

  pack_threadinfo_request (rs->buf, fieldset, threadid);
  putpkt (rs->buf);
  getpkt (&rs->buf, &rs->buf_size, 0);

  if (rs->buf[0] == '\0')
    return 0;

  result = remote_unpack_thread_info_response (rs->buf + 2,
					       threadid, info);
  return result;
}

/*    Format: i'Q':8,i"L":8,initflag:8,batchsize:16,lastthreadid:32   */

static char *
pack_threadlist_request (char *pkt, int startflag, int threadcount,
			 threadref *nextthread)
{
  *pkt++ = 'q';			/* info query packet */
  *pkt++ = 'L';			/* Process LIST or threadLIST request */
  pkt = pack_nibble (pkt, startflag);		/* initflag 1 bytes */
  pkt = pack_hex_byte (pkt, threadcount);	/* threadcount 2 bytes */
  pkt = pack_threadid (pkt, nextthread);	/* 64 bit thread identifier */
  *pkt = '\0';
  return pkt;
}

/* Encoding:   'q':8,'M':8,count:16,done:8,argthreadid:64,(threadid:64)* */

static int
parse_threadlist_response (char *pkt, int result_limit,
			   threadref *original_echo, threadref *resultlist,
			   int *doneflag)
{
  struct remote_state *rs = get_remote_state ();
  char *limit;
  int count, resultcount, done;

  resultcount = 0;
  /* Assume the 'q' and 'M chars have been stripped.  */
  limit = pkt + (rs->buf_size - BUF_THREAD_ID_SIZE);
  /* done parse past here */
  pkt = unpack_byte (pkt, &count);	/* count field */
  pkt = unpack_nibble (pkt, &done);
  /* The first threadid is the argument threadid.  */
  pkt = unpack_threadid (pkt, original_echo);	/* should match query packet */
  while ((count-- > 0) && (pkt < limit))
    {
      pkt = unpack_threadid (pkt, resultlist++);
      if (resultcount++ >= result_limit)
	break;
    }
  if (doneflag)
    *doneflag = done;
  return resultcount;
}

static int
remote_get_threadlist (int startflag, threadref *nextthread, int result_limit,
		       int *done, int *result_count, threadref *threadlist)
{
  struct remote_state *rs = get_remote_state ();
  int result = 1;

  /* Trancate result limit to be smaller than the packet size.  */
  if ((((result_limit + 1) * BUF_THREAD_ID_SIZE) + 10)
      >= get_remote_packet_size ())
    result_limit = (get_remote_packet_size () / BUF_THREAD_ID_SIZE) - 2;

  pack_threadlist_request (rs->buf, startflag, result_limit, nextthread);
  putpkt (rs->buf);
  getpkt (&rs->buf, &rs->buf_size, 0);

  if (*rs->buf == '\0')
    return 0;
  else
    *result_count =
      parse_threadlist_response (rs->buf + 2, result_limit,
				 &rs->echo_nextthread, threadlist, done);

  if (!threadmatch (&rs->echo_nextthread, nextthread))
    {
      /* FIXME: This is a good reason to drop the packet.  */
      /* Possably, there is a duplicate response.  */
      /* Possabilities :
         retransmit immediatly - race conditions
         retransmit after timeout - yes
         exit
         wait for packet, then exit
       */
      warning (_("HMM: threadlist did not echo arg thread, dropping it."));
      return 0;			/* I choose simply exiting.  */
    }
  if (*result_count <= 0)
    {
      if (*done != 1)
	{
	  warning (_("RMT ERROR : failed to get remote thread list."));
	  result = 0;
	}
      return result;		/* break; */
    }
  if (*result_count > result_limit)
    {
      *result_count = 0;
      warning (_("RMT ERROR: threadlist response longer than requested."));
      return 0;
    }
  return result;
}

/* This is the interface between remote and threads, remotes upper
   interface.  */

/* remote_find_new_threads retrieves the thread list and for each
   thread in the list, looks up the thread in GDB's internal list,
   adding the thread if it does not already exist.  This involves
   getting partial thread lists from the remote target so, polling the
   quit_flag is required.  */


static int
remote_threadlist_iterator (rmt_thread_action stepfunction, void *context,
			    int looplimit)
{
  struct remote_state *rs = get_remote_state ();
  int done, i, result_count;
  int startflag = 1;
  int result = 1;
  int loopcount = 0;

  done = 0;
  while (!done)
    {
      if (loopcount++ > looplimit)
	{
	  result = 0;
	  warning (_("Remote fetch threadlist -infinite loop-."));
	  break;
	}
      if (!remote_get_threadlist (startflag, &rs->nextthread,
				  MAXTHREADLISTRESULTS,
				  &done, &result_count, rs->resultthreadlist))
	{
	  result = 0;
	  break;
	}
      /* Clear for later iterations.  */
      startflag = 0;
      /* Setup to resume next batch of thread references, set nextthread.  */
      if (result_count >= 1)
	copy_threadref (&rs->nextthread,
			&rs->resultthreadlist[result_count - 1]);
      i = 0;
      while (result_count--)
	if (!(result = (*stepfunction) (&rs->resultthreadlist[i++], context)))
	  break;
    }
  return result;
}

static int
remote_newthread_step (threadref *ref, void *context)
{
  int pid = ptid_get_pid (inferior_ptid);
  ptid_t ptid = ptid_build (pid, 0, threadref_to_int (ref));

  if (!in_thread_list (ptid))
    add_thread (ptid);
  return 1;			/* continue iterator */
}

#define CRAZY_MAX_THREADS 1000

static ptid_t
remote_current_thread (ptid_t oldpid)
{
  struct remote_state *rs = get_remote_state ();

  putpkt ("qC");
  getpkt (&rs->buf, &rs->buf_size, 0);
  if (rs->buf[0] == 'Q' && rs->buf[1] == 'C')
    return read_ptid (&rs->buf[2], NULL);
  else
    return oldpid;
}

/* Find new threads for info threads command.
 * Original version, using John Metzler's thread protocol.
 */

static void
remote_find_new_threads (void)
{
  remote_threadlist_iterator (remote_newthread_step, 0,
			      CRAZY_MAX_THREADS);
}

#if defined(HAVE_LIBEXPAT)

typedef struct thread_item
{
  ptid_t ptid;
  char *extra;
  int core;
} thread_item_t;
DEF_VEC_O(thread_item_t);

struct threads_parsing_context
{
  VEC (thread_item_t) *items;
};

static void
start_thread (struct gdb_xml_parser *parser,
	      const struct gdb_xml_element *element,
	      void *user_data, VEC(gdb_xml_value_s) *attributes)
{
  struct threads_parsing_context *data = user_data;

  struct thread_item item;
  char *id;
  struct gdb_xml_value *attr;

  id = xml_find_attribute (attributes, "id")->value;
  item.ptid = read_ptid (id, NULL);

  attr = xml_find_attribute (attributes, "core");
  if (attr != NULL)
    item.core = *(ULONGEST *) attr->value;
  else
    item.core = -1;

  item.extra = 0;

  VEC_safe_push (thread_item_t, data->items, &item);
}

static void
end_thread (struct gdb_xml_parser *parser,
	    const struct gdb_xml_element *element,
	    void *user_data, const char *body_text)
{
  struct threads_parsing_context *data = user_data;

  if (body_text && *body_text)
    VEC_last (thread_item_t, data->items)->extra = xstrdup (body_text);
}

const struct gdb_xml_attribute thread_attributes[] = {
  { "id", GDB_XML_AF_NONE, NULL, NULL },
  { "core", GDB_XML_AF_OPTIONAL, gdb_xml_parse_attr_ulongest, NULL },
  { NULL, GDB_XML_AF_NONE, NULL, NULL }
};

const struct gdb_xml_element thread_children[] = {
  { NULL, NULL, NULL, GDB_XML_EF_NONE, NULL, NULL }
};

const struct gdb_xml_element threads_children[] = {
  { "thread", thread_attributes, thread_children,
    GDB_XML_EF_REPEATABLE | GDB_XML_EF_OPTIONAL,
    start_thread, end_thread },
  { NULL, NULL, NULL, GDB_XML_EF_NONE, NULL, NULL }
};

const struct gdb_xml_element threads_elements[] = {
  { "threads", NULL, threads_children,
    GDB_XML_EF_NONE, NULL, NULL },
  { NULL, NULL, NULL, GDB_XML_EF_NONE, NULL, NULL }
};

/* Discard the contents of the constructed thread info context.  */

static void
clear_threads_parsing_context (void *p)
{
  struct threads_parsing_context *context = p;
  int i;
  struct thread_item *item;

  for (i = 0; VEC_iterate (thread_item_t, context->items, i, item); ++i)
    xfree (item->extra);

  VEC_free (thread_item_t, context->items);
}

#endif

/*
 * Find all threads for info threads command.
 * Uses new thread protocol contributed by Cisco.
 * Falls back and attempts to use the older method (above)
 * if the target doesn't respond to the new method.
 */

static void
remote_threads_info (struct target_ops *ops)
{
  struct remote_state *rs = get_remote_state ();
  char *bufp;
  ptid_t new_thread;

  if (rs->remote_desc == 0)		/* paranoia */
    error (_("Command can only be used when connected to the remote target."));

#if defined(HAVE_LIBEXPAT)
  if (remote_protocol_packets[PACKET_qXfer_threads].support == PACKET_ENABLE)
    {
      char *xml = target_read_stralloc (&current_target,
					 TARGET_OBJECT_THREADS, NULL);

      struct cleanup *back_to = make_cleanup (xfree, xml);

      if (xml && *xml)
	{
	  struct threads_parsing_context context;

	  context.items = NULL;
	  make_cleanup (clear_threads_parsing_context, &context);

	  if (gdb_xml_parse_quick (_("threads"), "threads.dtd",
				   threads_elements, xml, &context) == 0)
	    {
	      int i;
	      struct thread_item *item;

	      for (i = 0;
		   VEC_iterate (thread_item_t, context.items, i, item);
		   ++i)
		{
		  if (!ptid_equal (item->ptid, null_ptid))
		    {
		      struct private_thread_info *info;
		      /* In non-stop mode, we assume new found threads
			 are running until proven otherwise with a
			 stop reply.  In all-stop, we can only get
			 here if all threads are stopped.  */
		      int running = non_stop ? 1 : 0;

		      remote_notice_new_inferior (item->ptid, running);

		      info = demand_private_info (item->ptid);
		      info->core = item->core;
		      info->extra = item->extra;
		      item->extra = NULL;
		    }
		}
	    }
	}

      do_cleanups (back_to);
      return;
    }
#endif

  if (rs->use_threadinfo_query)
    {
      putpkt ("qfThreadInfo");
      getpkt (&rs->buf, &rs->buf_size, 0);
      bufp = rs->buf;
      if (bufp[0] != '\0')		/* q packet recognized */
	{
	  struct cleanup *old_chain;
	  char *saved_reply;

	  /* remote_notice_new_inferior (in the loop below) may make
	     new RSP calls, which clobber rs->buf.  Work with a
	     copy.  */
	  bufp = saved_reply = xstrdup (rs->buf);
	  old_chain = make_cleanup (free_current_contents, &saved_reply);

	  while (*bufp++ == 'm')	/* reply contains one or more TID */
	    {
	      do
		{
		  new_thread = read_ptid (bufp, &bufp);
		  if (!ptid_equal (new_thread, null_ptid))
		    {
		      /* In non-stop mode, we assume new found threads
			 are running until proven otherwise with a
			 stop reply.  In all-stop, we can only get
			 here if all threads are stopped.  */
		      int running = non_stop ? 1 : 0;

		      remote_notice_new_inferior (new_thread, running);
		    }
		}
	      while (*bufp++ == ',');	/* comma-separated list */
	      free_current_contents (&saved_reply);
	      putpkt ("qsThreadInfo");
	      getpkt (&rs->buf, &rs->buf_size, 0);
	      bufp = saved_reply = xstrdup (rs->buf);
	    }
	  do_cleanups (old_chain);
	  return;	/* done */
	}
    }

  /* Only qfThreadInfo is supported in non-stop mode.  */
  if (non_stop)
    return;

  /* Else fall back to old method based on jmetzler protocol.  */
  rs->use_threadinfo_query = 0;
  remote_find_new_threads ();
  return;
}

/*
 * Collect a descriptive string about the given thread.
 * The target may say anything it wants to about the thread
 * (typically info about its blocked / runnable state, name, etc.).
 * This string will appear in the info threads display.
 *
 * Optional: targets are not required to implement this function.
 */

static char *
remote_threads_extra_info (struct thread_info *tp)
{
  struct remote_state *rs = get_remote_state ();
  int result;
  int set;
  threadref id;
  struct gdb_ext_thread_info threadinfo;
  static char display_buf[100];	/* arbitrary...  */
  int n = 0;                    /* position in display_buf */

  if (rs->remote_desc == 0)		/* paranoia */
    internal_error (__FILE__, __LINE__,
		    _("remote_threads_extra_info"));

  if (ptid_equal (tp->ptid, magic_null_ptid)
      || (ptid_get_pid (tp->ptid) != 0 && ptid_get_tid (tp->ptid) == 0))
    /* This is the main thread which was added by GDB.  The remote
       server doesn't know about it.  */
    return NULL;

  if (remote_protocol_packets[PACKET_qXfer_threads].support == PACKET_ENABLE)
    {
      struct thread_info *info = find_thread_ptid (tp->ptid);

      if (info && info->private)
	return info->private->extra;
      else
	return NULL;
    }

  if (rs->use_threadextra_query)
    {
      char *b = rs->buf;
      char *endb = rs->buf + get_remote_packet_size ();

      xsnprintf (b, endb - b, "qThreadExtraInfo,");
      b += strlen (b);
      write_ptid (b, endb, tp->ptid);

      putpkt (rs->buf);
      getpkt (&rs->buf, &rs->buf_size, 0);
      if (rs->buf[0] != 0)
	{
	  n = min (strlen (rs->buf) / 2, sizeof (display_buf));
	  result = hex2bin (rs->buf, (gdb_byte *) display_buf, n);
	  display_buf [result] = '\0';
	  return display_buf;
	}
    }

  /* If the above query fails, fall back to the old method.  */
  rs->use_threadextra_query = 0;
  set = TAG_THREADID | TAG_EXISTS | TAG_THREADNAME
    | TAG_MOREDISPLAY | TAG_DISPLAY;
  int_to_threadref (&id, ptid_get_tid (tp->ptid));
  if (remote_get_threadinfo (&id, set, &threadinfo))
    if (threadinfo.active)
      {
	if (*threadinfo.shortname)
	  n += xsnprintf (&display_buf[0], sizeof (display_buf) - n,
			  " Name: %s,", threadinfo.shortname);
	if (*threadinfo.display)
	  n += xsnprintf (&display_buf[n], sizeof (display_buf) - n,
			  " State: %s,", threadinfo.display);
	if (*threadinfo.more_display)
	  n += xsnprintf (&display_buf[n], sizeof (display_buf) - n,
			  " Priority: %s", threadinfo.more_display);

	if (n > 0)
	  {
	    /* For purely cosmetic reasons, clear up trailing commas.  */
	    if (',' == display_buf[n-1])
	      display_buf[n-1] = ' ';
	    return display_buf;
	  }
      }
  return NULL;
}


static int
remote_static_tracepoint_marker_at (CORE_ADDR addr,
				    struct static_tracepoint_marker *marker)
{
  struct remote_state *rs = get_remote_state ();
  char *p = rs->buf;

  xsnprintf (p, get_remote_packet_size (), "qTSTMat:");
  p += strlen (p);
  p += hexnumstr (p, addr);
  putpkt (rs->buf);
  getpkt (&rs->buf, &rs->buf_size, 0);
  p = rs->buf;

  if (*p == 'E')
    error (_("Remote failure reply: %s"), p);

  if (*p++ == 'm')
    {
      parse_static_tracepoint_marker_definition (p, &p, marker);
      return 1;
    }

  return 0;
}

static VEC(static_tracepoint_marker_p) *
remote_static_tracepoint_markers_by_strid (const char *strid)
{
  struct remote_state *rs = get_remote_state ();
  VEC(static_tracepoint_marker_p) *markers = NULL;
  struct static_tracepoint_marker *marker = NULL;
  struct cleanup *old_chain;
  char *p;

  /* Ask for a first packet of static tracepoint marker
     definition.  */
  putpkt ("qTfSTM");
  getpkt (&rs->buf, &rs->buf_size, 0);
  p = rs->buf;
  if (*p == 'E')
    error (_("Remote failure reply: %s"), p);

  old_chain = make_cleanup (free_current_marker, &marker);

  while (*p++ == 'm')
    {
      if (marker == NULL)
	marker = XCNEW (struct static_tracepoint_marker);

      do
	{
	  parse_static_tracepoint_marker_definition (p, &p, marker);

	  if (strid == NULL || strcmp (strid, marker->str_id) == 0)
	    {
	      VEC_safe_push (static_tracepoint_marker_p,
			     markers, marker);
	      marker = NULL;
	    }
	  else
	    {
	      release_static_tracepoint_marker (marker);
	      memset (marker, 0, sizeof (*marker));
	    }
	}
      while (*p++ == ',');	/* comma-separated list */
      /* Ask for another packet of static tracepoint definition.  */
      putpkt ("qTsSTM");
      getpkt (&rs->buf, &rs->buf_size, 0);
      p = rs->buf;
    }

  do_cleanups (old_chain);
  return markers;
}


/* Implement the to_get_ada_task_ptid function for the remote targets.  */

static ptid_t
remote_get_ada_task_ptid (long lwp, long thread)
{
  return ptid_build (ptid_get_pid (inferior_ptid), 0, lwp);
}


/* Restart the remote side; this is an extended protocol operation.  */

static void
extended_remote_restart (void)
{
  struct remote_state *rs = get_remote_state ();

  /* Send the restart command; for reasons I don't understand the
     remote side really expects a number after the "R".  */
  xsnprintf (rs->buf, get_remote_packet_size (), "R%x", 0);
  putpkt (rs->buf);

  remote_fileio_reset ();
}

/* Clean up connection to a remote debugger.  */

static void
remote_close (void)
{
  struct remote_state *rs = get_remote_state ();

  if (rs->remote_desc == NULL)
    return; /* already closed */

  /* Make sure we leave stdin registered in the event loop, and we
     don't leave the async SIGINT signal handler installed.  */
  remote_terminal_ours ();

  serial_close (rs->remote_desc);
  rs->remote_desc = NULL;

  /* We don't have a connection to the remote stub anymore.  Get rid
     of all the inferiors and their threads we were controlling.
     Reset inferior_ptid to null_ptid first, as otherwise has_stack_frame
     will be unable to find the thread corresponding to (pid, 0, 0).  */
  inferior_ptid = null_ptid;
  discard_all_inferiors ();

  /* We are closing the remote target, so we should discard
     everything of this target.  */
  discard_pending_stop_replies_in_queue (rs);

  if (remote_async_inferior_event_token)
    delete_async_event_handler (&remote_async_inferior_event_token);

  remote_notif_state_xfree (rs->notif_state);

  trace_reset_local_state ();
}

/* Query the remote side for the text, data and bss offsets.  */

static void
get_offsets (void)
{
  struct remote_state *rs = get_remote_state ();
  char *buf;
  char *ptr;
  int lose, num_segments = 0, do_sections, do_segments;
  CORE_ADDR text_addr, data_addr, bss_addr, segments[2];
  struct section_offsets *offs;
  struct symfile_segment_data *data;

  if (symfile_objfile == NULL)
    return;

  putpkt ("qOffsets");
  getpkt (&rs->buf, &rs->buf_size, 0);
  buf = rs->buf;

  if (buf[0] == '\000')
    return;			/* Return silently.  Stub doesn't support
				   this command.  */
  if (buf[0] == 'E')
    {
      warning (_("Remote failure reply: %s"), buf);
      return;
    }

  /* Pick up each field in turn.  This used to be done with scanf, but
     scanf will make trouble if CORE_ADDR size doesn't match
     conversion directives correctly.  The following code will work
     with any size of CORE_ADDR.  */
  text_addr = data_addr = bss_addr = 0;
  ptr = buf;
  lose = 0;

  if (strncmp (ptr, "Text=", 5) == 0)
    {
      ptr += 5;
      /* Don't use strtol, could lose on big values.  */
      while (*ptr && *ptr != ';')
	text_addr = (text_addr << 4) + fromhex (*ptr++);

      if (strncmp (ptr, ";Data=", 6) == 0)
	{
	  ptr += 6;
	  while (*ptr && *ptr != ';')
	    data_addr = (data_addr << 4) + fromhex (*ptr++);
	}
      else
	lose = 1;

      if (!lose && strncmp (ptr, ";Bss=", 5) == 0)
	{
	  ptr += 5;
	  while (*ptr && *ptr != ';')
	    bss_addr = (bss_addr << 4) + fromhex (*ptr++);

	  if (bss_addr != data_addr)
	    warning (_("Target reported unsupported offsets: %s"), buf);
	}
      else
	lose = 1;
    }
  else if (strncmp (ptr, "TextSeg=", 8) == 0)
    {
      ptr += 8;
      /* Don't use strtol, could lose on big values.  */
      while (*ptr && *ptr != ';')
	text_addr = (text_addr << 4) + fromhex (*ptr++);
      num_segments = 1;

      if (strncmp (ptr, ";DataSeg=", 9) == 0)
	{
	  ptr += 9;
	  while (*ptr && *ptr != ';')
	    data_addr = (data_addr << 4) + fromhex (*ptr++);
	  num_segments++;
	}
    }
  else
    lose = 1;

  if (lose)
    error (_("Malformed response to offset query, %s"), buf);
  else if (*ptr != '\0')
    warning (_("Target reported unsupported offsets: %s"), buf);

  offs = ((struct section_offsets *)
	  alloca (SIZEOF_N_SECTION_OFFSETS (symfile_objfile->num_sections)));
  memcpy (offs, symfile_objfile->section_offsets,
	  SIZEOF_N_SECTION_OFFSETS (symfile_objfile->num_sections));

  data = get_symfile_segment_data (symfile_objfile->obfd);
  do_segments = (data != NULL);
  do_sections = num_segments == 0;

  if (num_segments > 0)
    {
      segments[0] = text_addr;
      segments[1] = data_addr;
    }
  /* If we have two segments, we can still try to relocate everything
     by assuming that the .text and .data offsets apply to the whole
     text and data segments.  Convert the offsets given in the packet
     to base addresses for symfile_map_offsets_to_segments.  */
  else if (data && data->num_segments == 2)
    {
      segments[0] = data->segment_bases[0] + text_addr;
      segments[1] = data->segment_bases[1] + data_addr;
      num_segments = 2;
    }
  /* If the object file has only one segment, assume that it is text
     rather than data; main programs with no writable data are rare,
     but programs with no code are useless.  Of course the code might
     have ended up in the data segment... to detect that we would need
     the permissions here.  */
  else if (data && data->num_segments == 1)
    {
      segments[0] = data->segment_bases[0] + text_addr;
      num_segments = 1;
    }
  /* There's no way to relocate by segment.  */
  else
    do_segments = 0;

  if (do_segments)
    {
      int ret = symfile_map_offsets_to_segments (symfile_objfile->obfd, data,
						 offs, num_segments, segments);

      if (ret == 0 && !do_sections)
	error (_("Can not handle qOffsets TextSeg "
		 "response with this symbol file"));

      if (ret > 0)
	do_sections = 0;
    }

  if (data)
    free_symfile_segment_data (data);

  if (do_sections)
    {
      offs->offsets[SECT_OFF_TEXT (symfile_objfile)] = text_addr;

      /* This is a temporary kludge to force data and bss to use the
	 same offsets because that's what nlmconv does now.  The real
	 solution requires changes to the stub and remote.c that I
	 don't have time to do right now.  */

      offs->offsets[SECT_OFF_DATA (symfile_objfile)] = data_addr;
      offs->offsets[SECT_OFF_BSS (symfile_objfile)] = data_addr;
    }

  objfile_relocate (symfile_objfile, offs);
}

/* Callback for iterate_over_threads.  Set the STOP_REQUESTED flags in
   threads we know are stopped already.  This is used during the
   initial remote connection in non-stop mode --- threads that are
   reported as already being stopped are left stopped.  */

static int
set_stop_requested_callback (struct thread_info *thread, void *data)
{
  /* If we have a stop reply for this thread, it must be stopped.  */
  if (peek_stop_reply (thread->ptid))
    set_stop_requested (thread->ptid, 1);

  return 0;
}

/* Send interrupt_sequence to remote target.  */
static void
send_interrupt_sequence (void)
{
  struct remote_state *rs = get_remote_state ();

  if (interrupt_sequence_mode == interrupt_sequence_control_c)
    remote_serial_write ("\x03", 1);
  else if (interrupt_sequence_mode == interrupt_sequence_break)
    serial_send_break (rs->remote_desc);
  else if (interrupt_sequence_mode == interrupt_sequence_break_g)
    {
      serial_send_break (rs->remote_desc);
      remote_serial_write ("g", 1);
    }
  else
    internal_error (__FILE__, __LINE__,
		    _("Invalid value for interrupt_sequence_mode: %s."),
		    interrupt_sequence_mode);
}


/* If STOP_REPLY is a T stop reply, look for the "thread" register,
   and extract the PTID.  Returns NULL_PTID if not found.  */

static ptid_t
stop_reply_extract_thread (char *stop_reply)
{
  if (stop_reply[0] == 'T' && strlen (stop_reply) > 3)
    {
      char *p;

      /* Txx r:val ; r:val (...)  */
      p = &stop_reply[3];

      /* Look for "register" named "thread".  */
      while (*p != '\0')
	{
	  char *p1;

	  p1 = strchr (p, ':');
	  if (p1 == NULL)
	    return null_ptid;

	  if (strncmp (p, "thread", p1 - p) == 0)
	    return read_ptid (++p1, &p);

	  p1 = strchr (p, ';');
	  if (p1 == NULL)
	    return null_ptid;
	  p1++;

	  p = p1;
	}
    }

  return null_ptid;
}

/* Query the remote target for which is the current thread/process,
   add it to our tables, and update INFERIOR_PTID.  The caller is
   responsible for setting the state such that the remote end is ready
   to return the current thread.

   This function is called after handling the '?' or 'vRun' packets,
   whose response is a stop reply from which we can also try
   extracting the thread.  If the target doesn't support the explicit
   qC query, we infer the current thread from that stop reply, passed
   in in WAIT_STATUS, which may be NULL.  */

static void
add_current_inferior_and_thread (char *wait_status)
{
  struct remote_state *rs = get_remote_state ();
  int fake_pid_p = 0;
  ptid_t ptid = null_ptid;

  inferior_ptid = null_ptid;

  /* Now, if we have thread information, update inferior_ptid.  First
     if we have a stop reply handy, maybe it's a T stop reply with a
     "thread" register we can extract the current thread from.  If
     not, ask the remote which is the current thread, with qC.  The
     former method avoids a roundtrip.  Note we don't use
     remote_parse_stop_reply as that makes use of the target
     architecture, which we haven't yet fully determined at this
     point.  */
  if (wait_status != NULL)
    ptid = stop_reply_extract_thread (wait_status);
  if (ptid_equal (ptid, null_ptid))
    ptid = remote_current_thread (inferior_ptid);

  if (!ptid_equal (ptid, null_ptid))
    {
      if (!remote_multi_process_p (rs))
	fake_pid_p = 1;

      inferior_ptid = ptid;
    }
  else
    {
      /* Without this, some commands which require an active target
	 (such as kill) won't work.  This variable serves (at least)
	 double duty as both the pid of the target process (if it has
	 such), and as a flag indicating that a target is active.  */
      inferior_ptid = magic_null_ptid;
      fake_pid_p = 1;
    }

  remote_add_inferior (fake_pid_p, ptid_get_pid (inferior_ptid), -1);

  /* Add the main thread.  */
  add_thread_silent (inferior_ptid);
}

static void
remote_start_remote (int from_tty, struct target_ops *target, int extended_p)
{
  struct remote_state *rs = get_remote_state ();
  struct packet_config *noack_config;
  char *wait_status = NULL;

  immediate_quit++;		/* Allow user to interrupt it.  */
  QUIT;

  if (interrupt_on_connect)
    send_interrupt_sequence ();

  /* Ack any packet which the remote side has already sent.  */
  serial_write (rs->remote_desc, "+", 1);

  /* Signal other parts that we're going through the initial setup,
     and so things may not be stable yet.  */
  rs->starting_up = 1;

  /* The first packet we send to the target is the optional "supported
     packets" request.  If the target can answer this, it will tell us
     which later probes to skip.  */
  remote_query_supported ();

  /* If the stub wants to get a QAllow, compose one and send it.  */
  if (remote_protocol_packets[PACKET_QAllow].support != PACKET_DISABLE)
    remote_set_permissions ();

  /* Next, we possibly activate noack mode.

     If the QStartNoAckMode packet configuration is set to AUTO,
     enable noack mode if the stub reported a wish for it with
     qSupported.

     If set to TRUE, then enable noack mode even if the stub didn't
     report it in qSupported.  If the stub doesn't reply OK, the
     session ends with an error.

     If FALSE, then don't activate noack mode, regardless of what the
     stub claimed should be the default with qSupported.  */

  noack_config = &remote_protocol_packets[PACKET_QStartNoAckMode];

  if (noack_config->detect == AUTO_BOOLEAN_TRUE
      || (noack_config->detect == AUTO_BOOLEAN_AUTO
	  && noack_config->support == PACKET_ENABLE))
    {
      putpkt ("QStartNoAckMode");
      getpkt (&rs->buf, &rs->buf_size, 0);
      if (packet_ok (rs->buf, noack_config) == PACKET_OK)
	rs->noack_mode = 1;
    }

  if (extended_p)
    {
      /* Tell the remote that we are using the extended protocol.  */
      putpkt ("!");
      getpkt (&rs->buf, &rs->buf_size, 0);
    }

  /* Let the target know which signals it is allowed to pass down to
     the program.  */
  update_signals_program_target ();

  /* Next, if the target can specify a description, read it.  We do
     this before anything involving memory or registers.  */
  target_find_description ();

  /* Next, now that we know something about the target, update the
     address spaces in the program spaces.  */
  update_address_spaces ();

  /* On OSs where the list of libraries is global to all
     processes, we fetch them early.  */
  if (gdbarch_has_global_solist (target_gdbarch ()))
    solib_add (NULL, from_tty, target, auto_solib_add);

  if (non_stop)
    {
      if (!rs->non_stop_aware)
	error (_("Non-stop mode requested, but remote "
		 "does not support non-stop"));

      putpkt ("QNonStop:1");
      getpkt (&rs->buf, &rs->buf_size, 0);

      if (strcmp (rs->buf, "OK") != 0)
	error (_("Remote refused setting non-stop mode with: %s"), rs->buf);

      /* Find about threads and processes the stub is already
	 controlling.  We default to adding them in the running state.
	 The '?' query below will then tell us about which threads are
	 stopped.  */
      remote_threads_info (target);
    }
  else if (rs->non_stop_aware)
    {
      /* Don't assume that the stub can operate in all-stop mode.
	 Request it explicitly.  */
      putpkt ("QNonStop:0");
      getpkt (&rs->buf, &rs->buf_size, 0);

      if (strcmp (rs->buf, "OK") != 0)
	error (_("Remote refused setting all-stop mode with: %s"), rs->buf);
    }

  /* Upload TSVs regardless of whether the target is running or not.  The
     remote stub, such as GDBserver, may have some predefined or builtin
     TSVs, even if the target is not running.  */
  if (remote_get_trace_status (current_trace_status ()) != -1)
    {
      struct uploaded_tsv *uploaded_tsvs = NULL;

      remote_upload_trace_state_variables (&uploaded_tsvs);
      merge_uploaded_trace_state_variables (&uploaded_tsvs);
    }

  /* Check whether the target is running now.  */
  putpkt ("?");
  getpkt (&rs->buf, &rs->buf_size, 0);

  if (!non_stop)
    {
      ptid_t ptid;
      int fake_pid_p = 0;
      struct inferior *inf;

      if (rs->buf[0] == 'W' || rs->buf[0] == 'X')
	{
	  if (!extended_p)
	    error (_("The target is not running (try extended-remote?)"));

	  /* We're connected, but not running.  Drop out before we
	     call start_remote.  */
	  rs->starting_up = 0;
	  return;
	}
      else
	{
	  /* Save the reply for later.  */
	  wait_status = alloca (strlen (rs->buf) + 1);
	  strcpy (wait_status, rs->buf);
	}

      /* Let the stub know that we want it to return the thread.  */
      set_continue_thread (minus_one_ptid);

      add_current_inferior_and_thread (wait_status);

      /* init_wait_for_inferior should be called before get_offsets in order
	 to manage `inserted' flag in bp loc in a correct state.
	 breakpoint_init_inferior, called from init_wait_for_inferior, set
	 `inserted' flag to 0, while before breakpoint_re_set, called from
	 start_remote, set `inserted' flag to 1.  In the initialization of
	 inferior, breakpoint_init_inferior should be called first, and then
	 breakpoint_re_set can be called.  If this order is broken, state of
	 `inserted' flag is wrong, and cause some problems on breakpoint
	 manipulation.  */
      init_wait_for_inferior ();

      get_offsets ();		/* Get text, data & bss offsets.  */

      /* If we could not find a description using qXfer, and we know
	 how to do it some other way, try again.  This is not
	 supported for non-stop; it could be, but it is tricky if
	 there are no stopped threads when we connect.  */
      if (remote_read_description_p (target)
	  && gdbarch_target_desc (target_gdbarch ()) == NULL)
	{
	  target_clear_description ();
	  target_find_description ();
	}

      /* Use the previously fetched status.  */
      gdb_assert (wait_status != NULL);
      strcpy (rs->buf, wait_status);
      rs->cached_wait_status = 1;

      immediate_quit--;
      start_remote (from_tty); /* Initialize gdb process mechanisms.  */
    }
  else
    {
      /* Clear WFI global state.  Do this before finding about new
	 threads and inferiors, and setting the current inferior.
	 Otherwise we would clear the proceed status of the current
	 inferior when we want its stop_soon state to be preserved
	 (see notice_new_inferior).  */
      init_wait_for_inferior ();

      /* In non-stop, we will either get an "OK", meaning that there
	 are no stopped threads at this time; or, a regular stop
	 reply.  In the latter case, there may be more than one thread
	 stopped --- we pull them all out using the vStopped
	 mechanism.  */
      if (strcmp (rs->buf, "OK") != 0)
	{
	  struct notif_client *notif = &notif_client_stop;

	  /* remote_notif_get_pending_replies acks this one, and gets
	     the rest out.  */
	  rs->notif_state->pending_event[notif_client_stop.id]
	    = remote_notif_parse (notif, rs->buf);
	  remote_notif_get_pending_events (notif);

	  /* Make sure that threads that were stopped remain
	     stopped.  */
	  iterate_over_threads (set_stop_requested_callback, NULL);
	}

      if (target_can_async_p ())
	target_async (inferior_event_handler, 0);

      if (thread_count () == 0)
	{
	  if (!extended_p)
	    error (_("The target is not running (try extended-remote?)"));

	  /* We're connected, but not running.  Drop out before we
	     call start_remote.  */
	  rs->starting_up = 0;
	  return;
	}

      /* Let the stub know that we want it to return the thread.  */

      /* Force the stub to choose a thread.  */
      set_general_thread (null_ptid);

      /* Query it.  */
      inferior_ptid = remote_current_thread (minus_one_ptid);
      if (ptid_equal (inferior_ptid, minus_one_ptid))
	error (_("remote didn't report the current thread in non-stop mode"));

      get_offsets ();		/* Get text, data & bss offsets.  */

      /* In non-stop mode, any cached wait status will be stored in
	 the stop reply queue.  */
      gdb_assert (wait_status == NULL);

      /* Report all signals during attach/startup.  */
      remote_pass_signals (0, NULL);
    }

  /* If we connected to a live target, do some additional setup.  */
  if (target_has_execution)
    {
      if (exec_bfd) 	/* No use without an exec file.  */
	remote_check_symbols ();
    }

  /* Possibly the target has been engaged in a trace run started
     previously; find out where things are at.  */
  if (remote_get_trace_status (current_trace_status ()) != -1)
    {
      struct uploaded_tp *uploaded_tps = NULL;

      if (current_trace_status ()->running)
	printf_filtered (_("Trace is already running on the target.\n"));

      remote_upload_tracepoints (&uploaded_tps);

      merge_uploaded_tracepoints (&uploaded_tps);
    }

  /* The thread and inferior lists are now synchronized with the
     target, our symbols have been relocated, and we're merged the
     target's tracepoints with ours.  We're done with basic start
     up.  */
  rs->starting_up = 0;

  /* If breakpoints are global, insert them now.  */
  if (gdbarch_has_global_breakpoints (target_gdbarch ())
      && breakpoints_always_inserted_mode ())
    insert_breakpoints ();
}

/* Open a connection to a remote debugger.
   NAME is the filename used for communication.  */

static void
remote_open (char *name, int from_tty)
{
  remote_open_1 (name, from_tty, &remote_ops, 0);
}

/* Open a connection to a remote debugger using the extended
   remote gdb protocol.  NAME is the filename used for communication.  */

static void
extended_remote_open (char *name, int from_tty)
{
  remote_open_1 (name, from_tty, &extended_remote_ops, 1 /*extended_p */);
}

/* Generic code for opening a connection to a remote target.  */

static void
init_all_packet_configs (void)
{
  int i;

  for (i = 0; i < PACKET_MAX; i++)
    update_packet_config (&remote_protocol_packets[i]);
}

/* Symbol look-up.  */

static void
remote_check_symbols (void)
{
  struct remote_state *rs = get_remote_state ();
  char *msg, *reply, *tmp;
  struct minimal_symbol *sym;
  int end;

  /* The remote side has no concept of inferiors that aren't running
     yet, it only knows about running processes.  If we're connected
     but our current inferior is not running, we should not invite the
     remote target to request symbol lookups related to its
     (unrelated) current process.  */
  if (!target_has_execution)
    return;

  if (remote_protocol_packets[PACKET_qSymbol].support == PACKET_DISABLE)
    return;

  /* Make sure the remote is pointing at the right process.  Note
     there's no way to select "no process".  */
  set_general_process ();

  /* Allocate a message buffer.  We can't reuse the input buffer in RS,
     because we need both at the same time.  */
  msg = alloca (get_remote_packet_size ());

  /* Invite target to request symbol lookups.  */

  putpkt ("qSymbol::");
  getpkt (&rs->buf, &rs->buf_size, 0);
  packet_ok (rs->buf, &remote_protocol_packets[PACKET_qSymbol]);
  reply = rs->buf;

  while (strncmp (reply, "qSymbol:", 8) == 0)
    {
      tmp = &reply[8];
      end = hex2bin (tmp, (gdb_byte *) msg, strlen (tmp) / 2);
      msg[end] = '\0';
      sym = lookup_minimal_symbol (msg, NULL, NULL);
      if (sym == NULL)
	xsnprintf (msg, get_remote_packet_size (), "qSymbol::%s", &reply[8]);
      else
	{
	  int addr_size = gdbarch_addr_bit (target_gdbarch ()) / 8;
	  CORE_ADDR sym_addr = SYMBOL_VALUE_ADDRESS (sym);

	  /* If this is a function address, return the start of code
	     instead of any data function descriptor.  */
	  sym_addr = gdbarch_convert_from_func_ptr_addr (target_gdbarch (),
							 sym_addr,
							 &current_target);

	  xsnprintf (msg, get_remote_packet_size (), "qSymbol:%s:%s",
		     phex_nz (sym_addr, addr_size), &reply[8]);
	}
  
      putpkt (msg);
      getpkt (&rs->buf, &rs->buf_size, 0);
      reply = rs->buf;
    }
}

static struct serial *
remote_serial_open (char *name)
{
  static int udp_warning = 0;

  /* FIXME: Parsing NAME here is a hack.  But we want to warn here instead
     of in ser-tcp.c, because it is the remote protocol assuming that the
     serial connection is reliable and not the serial connection promising
     to be.  */
  if (!udp_warning && strncmp (name, "udp:", 4) == 0)
    {
      warning (_("The remote protocol may be unreliable over UDP.\n"
		 "Some events may be lost, rendering further debugging "
		 "impossible."));
      udp_warning = 1;
    }

  return serial_open (name);
}

/* Inform the target of our permission settings.  The permission flags
   work without this, but if the target knows the settings, it can do
   a couple things.  First, it can add its own check, to catch cases
   that somehow manage to get by the permissions checks in target
   methods.  Second, if the target is wired to disallow particular
   settings (for instance, a system in the field that is not set up to
   be able to stop at a breakpoint), it can object to any unavailable
   permissions.  */

void
remote_set_permissions (void)
{
  struct remote_state *rs = get_remote_state ();

  xsnprintf (rs->buf, get_remote_packet_size (), "QAllow:"
	     "WriteReg:%x;WriteMem:%x;"
	     "InsertBreak:%x;InsertTrace:%x;"
	     "InsertFastTrace:%x;Stop:%x",
	     may_write_registers, may_write_memory,
	     may_insert_breakpoints, may_insert_tracepoints,
	     may_insert_fast_tracepoints, may_stop);
  putpkt (rs->buf);
  getpkt (&rs->buf, &rs->buf_size, 0);

  /* If the target didn't like the packet, warn the user.  Do not try
     to undo the user's settings, that would just be maddening.  */
  if (strcmp (rs->buf, "OK") != 0)
    warning (_("Remote refused setting permissions with: %s"), rs->buf);
}

/* This type describes each known response to the qSupported
   packet.  */
struct protocol_feature
{
  /* The name of this protocol feature.  */
  const char *name;

  /* The default for this protocol feature.  */
  enum packet_support default_support;

  /* The function to call when this feature is reported, or after
     qSupported processing if the feature is not supported.
     The first argument points to this structure.  The second
     argument indicates whether the packet requested support be
     enabled, disabled, or probed (or the default, if this function
     is being called at the end of processing and this feature was
     not reported).  The third argument may be NULL; if not NULL, it
     is a NUL-terminated string taken from the packet following
     this feature's name and an equals sign.  */
  void (*func) (const struct protocol_feature *, enum packet_support,
		const char *);

  /* The corresponding packet for this feature.  Only used if
     FUNC is remote_supported_packet.  */
  int packet;
};

static void
remote_supported_packet (const struct protocol_feature *feature,
			 enum packet_support support,
			 const char *argument)
{
  if (argument)
    {
      warning (_("Remote qSupported response supplied an unexpected value for"
		 " \"%s\"."), feature->name);
      return;
    }

  if (remote_protocol_packets[feature->packet].support
      == PACKET_SUPPORT_UNKNOWN)
    remote_protocol_packets[feature->packet].support = support;
}

static void
remote_packet_size (const struct protocol_feature *feature,
		    enum packet_support support, const char *value)
{
  struct remote_state *rs = get_remote_state ();

  int packet_size;
  char *value_end;

  if (support != PACKET_ENABLE)
    return;

  if (value == NULL || *value == '\0')
    {
      warning (_("Remote target reported \"%s\" without a size."),
	       feature->name);
      return;
    }

  errno = 0;
  packet_size = strtol (value, &value_end, 16);
  if (errno != 0 || *value_end != '\0' || packet_size < 0)
    {
      warning (_("Remote target reported \"%s\" with a bad size: \"%s\"."),
	       feature->name, value);
      return;
    }

  if (packet_size > MAX_REMOTE_PACKET_SIZE)
    {
      warning (_("limiting remote suggested packet size (%d bytes) to %d"),
	       packet_size, MAX_REMOTE_PACKET_SIZE);
      packet_size = MAX_REMOTE_PACKET_SIZE;
    }

  /* Record the new maximum packet size.  */
  rs->explicit_packet_size = packet_size;
}

static void
remote_multi_process_feature (const struct protocol_feature *feature,
			      enum packet_support support, const char *value)
{
  struct remote_state *rs = get_remote_state ();

  rs->multi_process_aware = (support == PACKET_ENABLE);
}

static void
remote_non_stop_feature (const struct protocol_feature *feature,
			      enum packet_support support, const char *value)
{
  struct remote_state *rs = get_remote_state ();

  rs->non_stop_aware = (support == PACKET_ENABLE);
}

static void
remote_cond_tracepoint_feature (const struct protocol_feature *feature,
				       enum packet_support support,
				       const char *value)
{
  struct remote_state *rs = get_remote_state ();

  rs->cond_tracepoints = (support == PACKET_ENABLE);
}

static void
remote_cond_breakpoint_feature (const struct protocol_feature *feature,
				enum packet_support support,
				const char *value)
{
  struct remote_state *rs = get_remote_state ();

  rs->cond_breakpoints = (support == PACKET_ENABLE);
}

static void
remote_breakpoint_commands_feature (const struct protocol_feature *feature,
				    enum packet_support support,
				    const char *value)
{
  struct remote_state *rs = get_remote_state ();

  rs->breakpoint_commands = (support == PACKET_ENABLE);
}

static void
remote_fast_tracepoint_feature (const struct protocol_feature *feature,
				enum packet_support support,
				const char *value)
{
  struct remote_state *rs = get_remote_state ();

  rs->fast_tracepoints = (support == PACKET_ENABLE);
}

static void
remote_static_tracepoint_feature (const struct protocol_feature *feature,
				  enum packet_support support,
				  const char *value)
{
  struct remote_state *rs = get_remote_state ();

  rs->static_tracepoints = (support == PACKET_ENABLE);
}

static void
remote_install_in_trace_feature (const struct protocol_feature *feature,
				 enum packet_support support,
				 const char *value)
{
  struct remote_state *rs = get_remote_state ();

  rs->install_in_trace = (support == PACKET_ENABLE);
}

static void
remote_disconnected_tracing_feature (const struct protocol_feature *feature,
				     enum packet_support support,
				     const char *value)
{
  struct remote_state *rs = get_remote_state ();

  rs->disconnected_tracing = (support == PACKET_ENABLE);
}

static void
remote_enable_disable_tracepoint_feature (const struct protocol_feature *feature,
					  enum packet_support support,
					  const char *value)
{
  struct remote_state *rs = get_remote_state ();

  rs->enable_disable_tracepoints = (support == PACKET_ENABLE);
}

static void
remote_string_tracing_feature (const struct protocol_feature *feature,
			       enum packet_support support,
			       const char *value)
{
  struct remote_state *rs = get_remote_state ();

  rs->string_tracing = (support == PACKET_ENABLE);
}

static void
remote_augmented_libraries_svr4_read_feature
  (const struct protocol_feature *feature,
   enum packet_support support, const char *value)
{
  struct remote_state *rs = get_remote_state ();

  rs->augmented_libraries_svr4_read = (support == PACKET_ENABLE);
}

static const struct protocol_feature remote_protocol_features[] = {
  { "PacketSize", PACKET_DISABLE, remote_packet_size, -1 },
  { "qXfer:auxv:read", PACKET_DISABLE, remote_supported_packet,
    PACKET_qXfer_auxv },
  { "qXfer:features:read", PACKET_DISABLE, remote_supported_packet,
    PACKET_qXfer_features },
  { "qXfer:libraries:read", PACKET_DISABLE, remote_supported_packet,
    PACKET_qXfer_libraries },
  { "qXfer:libraries-svr4:read", PACKET_DISABLE, remote_supported_packet,
    PACKET_qXfer_libraries_svr4 },
  { "augmented-libraries-svr4-read", PACKET_DISABLE,
    remote_augmented_libraries_svr4_read_feature, -1 },
  { "qXfer:memory-map:read", PACKET_DISABLE, remote_supported_packet,
    PACKET_qXfer_memory_map },
  { "qXfer:spu:read", PACKET_DISABLE, remote_supported_packet,
    PACKET_qXfer_spu_read },
  { "qXfer:spu:write", PACKET_DISABLE, remote_supported_packet,
    PACKET_qXfer_spu_write },
  { "qXfer:osdata:read", PACKET_DISABLE, remote_supported_packet,
    PACKET_qXfer_osdata },
  { "qXfer:threads:read", PACKET_DISABLE, remote_supported_packet,
    PACKET_qXfer_threads },
  { "qXfer:traceframe-info:read", PACKET_DISABLE, remote_supported_packet,
    PACKET_qXfer_traceframe_info },
  { "QPassSignals", PACKET_DISABLE, remote_supported_packet,
    PACKET_QPassSignals },
  { "QProgramSignals", PACKET_DISABLE, remote_supported_packet,
    PACKET_QProgramSignals },
  { "QStartNoAckMode", PACKET_DISABLE, remote_supported_packet,
    PACKET_QStartNoAckMode },
  { "multiprocess", PACKET_DISABLE, remote_multi_process_feature, -1 },
  { "QNonStop", PACKET_DISABLE, remote_non_stop_feature, -1 },
  { "qXfer:siginfo:read", PACKET_DISABLE, remote_supported_packet,
    PACKET_qXfer_siginfo_read },
  { "qXfer:siginfo:write", PACKET_DISABLE, remote_supported_packet,
    PACKET_qXfer_siginfo_write },
  { "ConditionalTracepoints", PACKET_DISABLE, remote_cond_tracepoint_feature,
    PACKET_ConditionalTracepoints },
  { "ConditionalBreakpoints", PACKET_DISABLE, remote_cond_breakpoint_feature,
    PACKET_ConditionalBreakpoints },
  { "BreakpointCommands", PACKET_DISABLE, remote_breakpoint_commands_feature,
    PACKET_BreakpointCommands },
  { "FastTracepoints", PACKET_DISABLE, remote_fast_tracepoint_feature,
    PACKET_FastTracepoints },
  { "StaticTracepoints", PACKET_DISABLE, remote_static_tracepoint_feature,
    PACKET_StaticTracepoints },
  {"InstallInTrace", PACKET_DISABLE, remote_install_in_trace_feature,
   PACKET_InstallInTrace},
  { "DisconnectedTracing", PACKET_DISABLE, remote_disconnected_tracing_feature,
    -1 },
  { "ReverseContinue", PACKET_DISABLE, remote_supported_packet,
    PACKET_bc },
  { "ReverseStep", PACKET_DISABLE, remote_supported_packet,
    PACKET_bs },
  { "TracepointSource", PACKET_DISABLE, remote_supported_packet,
    PACKET_TracepointSource },
  { "QAllow", PACKET_DISABLE, remote_supported_packet,
    PACKET_QAllow },
  { "EnableDisableTracepoints", PACKET_DISABLE,
    remote_enable_disable_tracepoint_feature, -1 },
  { "qXfer:fdpic:read", PACKET_DISABLE, remote_supported_packet,
    PACKET_qXfer_fdpic },
  { "qXfer:uib:read", PACKET_DISABLE, remote_supported_packet,
    PACKET_qXfer_uib },
  { "QDisableRandomization", PACKET_DISABLE, remote_supported_packet,
    PACKET_QDisableRandomization },
  { "QAgent", PACKET_DISABLE, remote_supported_packet, PACKET_QAgent},
  { "QTBuffer:size", PACKET_DISABLE,
    remote_supported_packet, PACKET_QTBuffer_size},
  { "tracenz", PACKET_DISABLE,
    remote_string_tracing_feature, -1 },
  { "Qbtrace:off", PACKET_DISABLE, remote_supported_packet, PACKET_Qbtrace_off },
  { "Qbtrace:bts", PACKET_DISABLE, remote_supported_packet, PACKET_Qbtrace_bts },
  { "qXfer:btrace:read", PACKET_DISABLE, remote_supported_packet,
    PACKET_qXfer_btrace }
};

static char *remote_support_xml;

/* Register string appended to "xmlRegisters=" in qSupported query.  */

void
register_remote_support_xml (const char *xml)
{
#if defined(HAVE_LIBEXPAT)
  if (remote_support_xml == NULL)
    remote_support_xml = concat ("xmlRegisters=", xml, (char *) NULL);
  else
    {
      char *copy = xstrdup (remote_support_xml + 13);
      char *p = strtok (copy, ",");

      do
	{
	  if (strcmp (p, xml) == 0)
	    {
	      /* already there */
	      xfree (copy);
	      return;
	    }
	}
      while ((p = strtok (NULL, ",")) != NULL);
      xfree (copy);

      remote_support_xml = reconcat (remote_support_xml,
				     remote_support_xml, ",", xml,
				     (char *) NULL);
    }
#endif
}

static char *
remote_query_supported_append (char *msg, const char *append)
{
  if (msg)
    return reconcat (msg, msg, ";", append, (char *) NULL);
  else
    return xstrdup (append);
}

static void
remote_query_supported (void)
{
  struct remote_state *rs = get_remote_state ();
  char *next;
  int i;
  unsigned char seen [ARRAY_SIZE (remote_protocol_features)];

  /* The packet support flags are handled differently for this packet
     than for most others.  We treat an error, a disabled packet, and
     an empty response identically: any features which must be reported
     to be used will be automatically disabled.  An empty buffer
     accomplishes this, since that is also the representation for a list
     containing no features.  */

  rs->buf[0] = 0;
  if (remote_protocol_packets[PACKET_qSupported].support != PACKET_DISABLE)
    {
      char *q = NULL;
      struct cleanup *old_chain = make_cleanup (free_current_contents, &q);

      q = remote_query_supported_append (q, "multiprocess+");

      if (remote_support_xml)
	q = remote_query_supported_append (q, remote_support_xml);

      q = remote_query_supported_append (q, "qRelocInsn+");

      q = reconcat (q, "qSupported:", q, (char *) NULL);
      putpkt (q);

      do_cleanups (old_chain);

      getpkt (&rs->buf, &rs->buf_size, 0);

      /* If an error occured, warn, but do not return - just reset the
	 buffer to empty and go on to disable features.  */
      if (packet_ok (rs->buf, &remote_protocol_packets[PACKET_qSupported])
	  == PACKET_ERROR)
	{
	  warning (_("Remote failure reply: %s"), rs->buf);
	  rs->buf[0] = 0;
	}
    }

  memset (seen, 0, sizeof (seen));

  next = rs->buf;
  while (*next)
    {
      enum packet_support is_supported;
      char *p, *end, *name_end, *value;

      /* First separate out this item from the rest of the packet.  If
	 there's another item after this, we overwrite the separator
	 (terminated strings are much easier to work with).  */
      p = next;
      end = strchr (p, ';');
      if (end == NULL)
	{
	  end = p + strlen (p);
	  next = end;
	}
      else
	{
	  *end = '\0';
	  next = end + 1;

	  if (end == p)
	    {
	      warning (_("empty item in \"qSupported\" response"));
	      continue;
	    }
	}

      name_end = strchr (p, '=');
      if (name_end)
	{
	  /* This is a name=value entry.  */
	  is_supported = PACKET_ENABLE;
	  value = name_end + 1;
	  *name_end = '\0';
	}
      else
	{
	  value = NULL;
	  switch (end[-1])
	    {
	    case '+':
	      is_supported = PACKET_ENABLE;
	      break;

	    case '-':
	      is_supported = PACKET_DISABLE;
	      break;

	    case '?':
	      is_supported = PACKET_SUPPORT_UNKNOWN;
	      break;

	    default:
	      warning (_("unrecognized item \"%s\" "
			 "in \"qSupported\" response"), p);
	      continue;
	    }
	  end[-1] = '\0';
	}

      for (i = 0; i < ARRAY_SIZE (remote_protocol_features); i++)
	if (strcmp (remote_protocol_features[i].name, p) == 0)
	  {
	    const struct protocol_feature *feature;

	    seen[i] = 1;
	    feature = &remote_protocol_features[i];
	    feature->func (feature, is_supported, value);
	    break;
	  }
    }

  /* If we increased the packet size, make sure to increase the global
     buffer size also.  We delay this until after parsing the entire
     qSupported packet, because this is the same buffer we were
     parsing.  */
  if (rs->buf_size < rs->explicit_packet_size)
    {
      rs->buf_size = rs->explicit_packet_size;
      rs->buf = xrealloc (rs->buf, rs->buf_size);
    }

  /* Handle the defaults for unmentioned features.  */
  for (i = 0; i < ARRAY_SIZE (remote_protocol_features); i++)
    if (!seen[i])
      {
	const struct protocol_feature *feature;

	feature = &remote_protocol_features[i];
	feature->func (feature, feature->default_support, NULL);
      }
}

/* Remove any of the remote.c targets from target stack.  Upper targets depend
   on it so remove them first.  */

static void
remote_unpush_target (void)
{
  pop_all_targets_above (process_stratum - 1);
}

static void
remote_open_1 (char *name, int from_tty,
	       struct target_ops *target, int extended_p)
{
  struct remote_state *rs = get_remote_state ();

  if (name == 0)
    error (_("To open a remote debug connection, you need to specify what\n"
	   "serial device is attached to the remote system\n"
	   "(e.g. /dev/ttyS0, /dev/ttya, COM1, etc.)."));

  /* See FIXME above.  */
  if (!target_async_permitted)
    wait_forever_enabled_p = 1;

  /* If we're connected to a running target, target_preopen will kill it.
     Ask this question first, before target_preopen has a chance to kill
     anything.  */
  if (rs->remote_desc != NULL && !have_inferiors ())
    {
      if (from_tty
	  && !query (_("Already connected to a remote target.  Disconnect? ")))
	error (_("Still connected."));
    }

  /* Here the possibly existing remote target gets unpushed.  */
  target_preopen (from_tty);

  /* Make sure we send the passed signals list the next time we resume.  */
  xfree (rs->last_pass_packet);
  rs->last_pass_packet = NULL;

  /* Make sure we send the program signals list the next time we
     resume.  */
  xfree (rs->last_program_signals_packet);
  rs->last_program_signals_packet = NULL;

  remote_fileio_reset ();
  reopen_exec_file ();
  reread_symbols ();

  rs->remote_desc = remote_serial_open (name);
  if (!rs->remote_desc)
    perror_with_name (name);

  if (baud_rate != -1)
    {
      if (serial_setbaudrate (rs->remote_desc, baud_rate))
	{
	  /* The requested speed could not be set.  Error out to
	     top level after closing remote_desc.  Take care to
	     set remote_desc to NULL to avoid closing remote_desc
	     more than once.  */
	  serial_close (rs->remote_desc);
	  rs->remote_desc = NULL;
	  perror_with_name (name);
	}
    }

  serial_raw (rs->remote_desc);

  /* If there is something sitting in the buffer we might take it as a
     response to a command, which would be bad.  */
  serial_flush_input (rs->remote_desc);

  if (from_tty)
    {
      puts_filtered ("Remote debugging using ");
      puts_filtered (name);
      puts_filtered ("\n");
    }
  push_target (target);		/* Switch to using remote target now.  */

  /* Register extra event sources in the event loop.  */
  remote_async_inferior_event_token
    = create_async_event_handler (remote_async_inferior_event_handler,
				  NULL);
  rs->notif_state = remote_notif_state_allocate ();

  /* Reset the target state; these things will be queried either by
     remote_query_supported or as they are needed.  */
  init_all_packet_configs ();
  rs->cached_wait_status = 0;
  rs->explicit_packet_size = 0;
  rs->noack_mode = 0;
  rs->multi_process_aware = 0;
  rs->extended = extended_p;
  rs->non_stop_aware = 0;
  rs->waiting_for_stop_reply = 0;
  rs->ctrlc_pending_p = 0;

  rs->general_thread = not_sent_ptid;
  rs->continue_thread = not_sent_ptid;
  rs->remote_traceframe_number = -1;

  /* Probe for ability to use "ThreadInfo" query, as required.  */
  rs->use_threadinfo_query = 1;
  rs->use_threadextra_query = 1;

  if (target_async_permitted)
    {
      /* With this target we start out by owning the terminal.  */
      remote_async_terminal_ours_p = 1;

      /* FIXME: cagney/1999-09-23: During the initial connection it is
	 assumed that the target is already ready and able to respond to
	 requests.  Unfortunately remote_start_remote() eventually calls
	 wait_for_inferior() with no timeout.  wait_forever_enabled_p gets
	 around this.  Eventually a mechanism that allows
	 wait_for_inferior() to expect/get timeouts will be
	 implemented.  */
      wait_forever_enabled_p = 0;
    }

  /* First delete any symbols previously loaded from shared libraries.  */
  no_shared_libraries (NULL, 0);

  /* Start afresh.  */
  init_thread_list ();

  /* Start the remote connection.  If error() or QUIT, discard this
     target (we'd otherwise be in an inconsistent state) and then
     propogate the error on up the exception chain.  This ensures that
     the caller doesn't stumble along blindly assuming that the
     function succeeded.  The CLI doesn't have this problem but other
     UI's, such as MI do.

     FIXME: cagney/2002-05-19: Instead of re-throwing the exception,
     this function should return an error indication letting the
     caller restore the previous state.  Unfortunately the command
     ``target remote'' is directly wired to this function making that
     impossible.  On a positive note, the CLI side of this problem has
     been fixed - the function set_cmd_context() makes it possible for
     all the ``target ....'' commands to share a common callback
     function.  See cli-dump.c.  */
  {
    volatile struct gdb_exception ex;

    TRY_CATCH (ex, RETURN_MASK_ALL)
      {
	remote_start_remote (from_tty, target, extended_p);
      }
    if (ex.reason < 0)
      {
	/* Pop the partially set up target - unless something else did
	   already before throwing the exception.  */
	if (rs->remote_desc != NULL)
	  remote_unpush_target ();
	if (target_async_permitted)
	  wait_forever_enabled_p = 1;
	throw_exception (ex);
      }
  }

  if (target_async_permitted)
    wait_forever_enabled_p = 1;
}

/* This takes a program previously attached to and detaches it.  After
   this is done, GDB can be used to debug some other program.  We
   better not have left any breakpoints in the target program or it'll
   die when it hits one.  */

static void
remote_detach_1 (char *args, int from_tty, int extended)
{
  int pid = ptid_get_pid (inferior_ptid);
  struct remote_state *rs = get_remote_state ();

  if (args)
    error (_("Argument given to \"detach\" when remotely debugging."));

  if (!target_has_execution)
    error (_("No process to detach from."));

  if (from_tty)
    {
      char *exec_file = get_exec_file (0);
      if (exec_file == NULL)
	exec_file = "";
      printf_unfiltered (_("Detaching from program: %s, %s\n"), exec_file,
			 target_pid_to_str (pid_to_ptid (pid)));
      gdb_flush (gdb_stdout);
    }

  /* Tell the remote target to detach.  */
  if (remote_multi_process_p (rs))
    xsnprintf (rs->buf, get_remote_packet_size (), "D;%x", pid);
  else
    strcpy (rs->buf, "D");

  putpkt (rs->buf);
  getpkt (&rs->buf, &rs->buf_size, 0);

  if (rs->buf[0] == 'O' && rs->buf[1] == 'K')
    ;
  else if (rs->buf[0] == '\0')
    error (_("Remote doesn't know how to detach"));
  else
    error (_("Can't detach process."));

  if (from_tty && !extended)
    puts_filtered (_("Ending remote debugging.\n"));

  target_mourn_inferior ();
}

static void
remote_detach (struct target_ops *ops, char *args, int from_tty)
{
  remote_detach_1 (args, from_tty, 0);
}

static void
extended_remote_detach (struct target_ops *ops, char *args, int from_tty)
{
  remote_detach_1 (args, from_tty, 1);
}

/* Same as remote_detach, but don't send the "D" packet; just disconnect.  */

static void
remote_disconnect (struct target_ops *target, char *args, int from_tty)
{
  if (args)
    error (_("Argument given to \"disconnect\" when remotely debugging."));

  /* Make sure we unpush even the extended remote targets; mourn
     won't do it.  So call remote_mourn_1 directly instead of
     target_mourn_inferior.  */
  remote_mourn_1 (target);

  if (from_tty)
    puts_filtered ("Ending remote debugging.\n");
}

/* Attach to the process specified by ARGS.  If FROM_TTY is non-zero,
   be chatty about it.  */

static void
extended_remote_attach_1 (struct target_ops *target, char *args, int from_tty)
{
  struct remote_state *rs = get_remote_state ();
  int pid;
  char *wait_status = NULL;

  pid = parse_pid_to_attach (args);

  /* Remote PID can be freely equal to getpid, do not check it here the same
     way as in other targets.  */

  if (remote_protocol_packets[PACKET_vAttach].support == PACKET_DISABLE)
    error (_("This target does not support attaching to a process"));

  if (from_tty)
    {
      char *exec_file = get_exec_file (0);

      if (exec_file)
	printf_unfiltered (_("Attaching to program: %s, %s\n"), exec_file,
			   target_pid_to_str (pid_to_ptid (pid)));
      else
	printf_unfiltered (_("Attaching to %s\n"),
			   target_pid_to_str (pid_to_ptid (pid)));

      gdb_flush (gdb_stdout);
    }

  xsnprintf (rs->buf, get_remote_packet_size (), "vAttach;%x", pid);
  putpkt (rs->buf);
  getpkt (&rs->buf, &rs->buf_size, 0);

  if (packet_ok (rs->buf,
		 &remote_protocol_packets[PACKET_vAttach]) == PACKET_OK)
    {
      if (!non_stop)
	{
	  /* Save the reply for later.  */
	  wait_status = alloca (strlen (rs->buf) + 1);
	  strcpy (wait_status, rs->buf);
	}
      else if (strcmp (rs->buf, "OK") != 0)
	error (_("Attaching to %s failed with: %s"),
	       target_pid_to_str (pid_to_ptid (pid)),
	       rs->buf);
    }
  else if (remote_protocol_packets[PACKET_vAttach].support == PACKET_DISABLE)
    error (_("This target does not support attaching to a process"));
  else
    error (_("Attaching to %s failed"),
	   target_pid_to_str (pid_to_ptid (pid)));

  set_current_inferior (remote_add_inferior (0, pid, 1));

  inferior_ptid = pid_to_ptid (pid);

  if (non_stop)
    {
      struct thread_info *thread;

      /* Get list of threads.  */
      remote_threads_info (target);

      thread = first_thread_of_process (pid);
      if (thread)
	inferior_ptid = thread->ptid;
      else
	inferior_ptid = pid_to_ptid (pid);

      /* Invalidate our notion of the remote current thread.  */
      record_currthread (rs, minus_one_ptid);
    }
  else
    {
      /* Now, if we have thread information, update inferior_ptid.  */
      inferior_ptid = remote_current_thread (inferior_ptid);

      /* Add the main thread to the thread list.  */
      add_thread_silent (inferior_ptid);
    }

  /* Next, if the target can specify a description, read it.  We do
     this before anything involving memory or registers.  */
  target_find_description ();

  if (!non_stop)
    {
      /* Use the previously fetched status.  */
      gdb_assert (wait_status != NULL);

      if (target_can_async_p ())
	{
	  struct notif_event *reply
	    =  remote_notif_parse (&notif_client_stop, wait_status);

	  push_stop_reply ((struct stop_reply *) reply);

	  target_async (inferior_event_handler, 0);
	}
      else
	{
	  gdb_assert (wait_status != NULL);
	  strcpy (rs->buf, wait_status);
	  rs->cached_wait_status = 1;
	}
    }
  else
    gdb_assert (wait_status == NULL);
}

static void
extended_remote_attach (struct target_ops *ops, char *args, int from_tty)
{
  extended_remote_attach_1 (ops, args, from_tty);
}

/* Convert hex digit A to a number.  */

static int
fromhex (int a)
{
  if (a >= '0' && a <= '9')
    return a - '0';
  else if (a >= 'a' && a <= 'f')
    return a - 'a' + 10;
  else if (a >= 'A' && a <= 'F')
    return a - 'A' + 10;
  else
    error (_("Reply contains invalid hex digit %d"), a);
}

int
hex2bin (const char *hex, gdb_byte *bin, int count)
{
  int i;

  for (i = 0; i < count; i++)
    {
      if (hex[0] == 0 || hex[1] == 0)
	{
	  /* Hex string is short, or of uneven length.
	     Return the count that has been converted so far.  */
	  return i;
	}
      *bin++ = fromhex (hex[0]) * 16 + fromhex (hex[1]);
      hex += 2;
    }
  return i;
}

/* Convert number NIB to a hex digit.  */

static int
tohex (int nib)
{
  if (nib < 10)
    return '0' + nib;
  else
    return 'a' + nib - 10;
}

int
bin2hex (const gdb_byte *bin, char *hex, int count)
{
  int i;

  /* May use a length, or a nul-terminated string as input.  */
  if (count == 0)
    count = strlen ((char *) bin);

  for (i = 0; i < count; i++)
    {
      *hex++ = tohex ((*bin >> 4) & 0xf);
      *hex++ = tohex (*bin++ & 0xf);
    }
  *hex = 0;
  return i;
}

/* Check for the availability of vCont.  This function should also check
   the response.  */

static void
remote_vcont_probe (struct remote_state *rs)
{
  char *buf;

  strcpy (rs->buf, "vCont?");
  putpkt (rs->buf);
  getpkt (&rs->buf, &rs->buf_size, 0);
  buf = rs->buf;

  /* Make sure that the features we assume are supported.  */
  if (strncmp (buf, "vCont", 5) == 0)
    {
      char *p = &buf[5];
      int support_s, support_S, support_c, support_C;

      support_s = 0;
      support_S = 0;
      support_c = 0;
      support_C = 0;
      rs->supports_vCont.t = 0;
      rs->supports_vCont.r = 0;
      while (p && *p == ';')
	{
	  p++;
	  if (*p == 's' && (*(p + 1) == ';' || *(p + 1) == 0))
	    support_s = 1;
	  else if (*p == 'S' && (*(p + 1) == ';' || *(p + 1) == 0))
	    support_S = 1;
	  else if (*p == 'c' && (*(p + 1) == ';' || *(p + 1) == 0))
	    support_c = 1;
	  else if (*p == 'C' && (*(p + 1) == ';' || *(p + 1) == 0))
	    support_C = 1;
	  else if (*p == 't' && (*(p + 1) == ';' || *(p + 1) == 0))
	    rs->supports_vCont.t = 1;
	  else if (*p == 'r' && (*(p + 1) == ';' || *(p + 1) == 0))
	    rs->supports_vCont.r = 1;

	  p = strchr (p, ';');
	}

      /* If s, S, c, and C are not all supported, we can't use vCont.  Clearing
         BUF will make packet_ok disable the packet.  */
      if (!support_s || !support_S || !support_c || !support_C)
	buf[0] = 0;
    }

  packet_ok (buf, &remote_protocol_packets[PACKET_vCont]);
}

/* Helper function for building "vCont" resumptions.  Write a
   resumption to P.  ENDP points to one-passed-the-end of the buffer
   we're allowed to write to.  Returns BUF+CHARACTERS_WRITTEN.  The
   thread to be resumed is PTID; STEP and SIGGNAL indicate whether the
   resumed thread should be single-stepped and/or signalled.  If PTID
   equals minus_one_ptid, then all threads are resumed; if PTID
   represents a process, then all threads of the process are resumed;
   the thread to be stepped and/or signalled is given in the global
   INFERIOR_PTID.  */

static char *
append_resumption (char *p, char *endp,
		   ptid_t ptid, int step, enum gdb_signal siggnal)
{
  struct remote_state *rs = get_remote_state ();

  if (step && siggnal != GDB_SIGNAL_0)
    p += xsnprintf (p, endp - p, ";S%02x", siggnal);
  else if (step
	   /* GDB is willing to range step.  */
	   && use_range_stepping
	   /* Target supports range stepping.  */
	   && rs->supports_vCont.r
	   /* We don't currently support range stepping multiple
	      threads with a wildcard (though the protocol allows it,
	      so stubs shouldn't make an active effort to forbid
	      it).  */
	   && !(remote_multi_process_p (rs) && ptid_is_pid (ptid)))
    {
      struct thread_info *tp;

      if (ptid_equal (ptid, minus_one_ptid))
	{
	  /* If we don't know about the target thread's tid, then
	     we're resuming magic_null_ptid (see caller).  */
	  tp = find_thread_ptid (magic_null_ptid);
	}
      else
	tp = find_thread_ptid (ptid);
      gdb_assert (tp != NULL);

      if (tp->control.may_range_step)
	{
	  int addr_size = gdbarch_addr_bit (target_gdbarch ()) / 8;

	  p += xsnprintf (p, endp - p, ";r%s,%s",
			  phex_nz (tp->control.step_range_start,
				   addr_size),
			  phex_nz (tp->control.step_range_end,
				   addr_size));
	}
      else
	p += xsnprintf (p, endp - p, ";s");
    }
  else if (step)
    p += xsnprintf (p, endp - p, ";s");
  else if (siggnal != GDB_SIGNAL_0)
    p += xsnprintf (p, endp - p, ";C%02x", siggnal);
  else
    p += xsnprintf (p, endp - p, ";c");

  if (remote_multi_process_p (rs) && ptid_is_pid (ptid))
    {
      ptid_t nptid;

      /* All (-1) threads of process.  */
      nptid = ptid_build (ptid_get_pid (ptid), 0, -1);

      p += xsnprintf (p, endp - p, ":");
      p = write_ptid (p, endp, nptid);
    }
  else if (!ptid_equal (ptid, minus_one_ptid))
    {
      p += xsnprintf (p, endp - p, ":");
      p = write_ptid (p, endp, ptid);
    }

  return p;
}

/* Append a vCont continue-with-signal action for threads that have a
   non-zero stop signal.  */

static char *
append_pending_thread_resumptions (char *p, char *endp, ptid_t ptid)
{
  struct thread_info *thread;

  ALL_THREADS (thread)
    if (ptid_match (thread->ptid, ptid)
	&& !ptid_equal (inferior_ptid, thread->ptid)
	&& thread->suspend.stop_signal != GDB_SIGNAL_0
	&& signal_pass_state (thread->suspend.stop_signal))
      {
	p = append_resumption (p, endp, thread->ptid,
			       0, thread->suspend.stop_signal);
	thread->suspend.stop_signal = GDB_SIGNAL_0;
      }

  return p;
}

/* Resume the remote inferior by using a "vCont" packet.  The thread
   to be resumed is PTID; STEP and SIGGNAL indicate whether the
   resumed thread should be single-stepped and/or signalled.  If PTID
   equals minus_one_ptid, then all threads are resumed; the thread to
   be stepped and/or signalled is given in the global INFERIOR_PTID.
   This function returns non-zero iff it resumes the inferior.

   This function issues a strict subset of all possible vCont commands at the
   moment.  */

static int
remote_vcont_resume (ptid_t ptid, int step, enum gdb_signal siggnal)
{
  struct remote_state *rs = get_remote_state ();
  char *p;
  char *endp;

  if (remote_protocol_packets[PACKET_vCont].support == PACKET_SUPPORT_UNKNOWN)
    remote_vcont_probe (rs);

  if (remote_protocol_packets[PACKET_vCont].support == PACKET_DISABLE)
    return 0;

  p = rs->buf;
  endp = rs->buf + get_remote_packet_size ();

  /* If we could generate a wider range of packets, we'd have to worry
     about overflowing BUF.  Should there be a generic
     "multi-part-packet" packet?  */

  p += xsnprintf (p, endp - p, "vCont");

  if (ptid_equal (ptid, magic_null_ptid))
    {
      /* MAGIC_NULL_PTID means that we don't have any active threads,
	 so we don't have any TID numbers the inferior will
	 understand.  Make sure to only send forms that do not specify
	 a TID.  */
      append_resumption (p, endp, minus_one_ptid, step, siggnal);
    }
  else if (ptid_equal (ptid, minus_one_ptid) || ptid_is_pid (ptid))
    {
      /* Resume all threads (of all processes, or of a single
	 process), with preference for INFERIOR_PTID.  This assumes
	 inferior_ptid belongs to the set of all threads we are about
	 to resume.  */
      if (step || siggnal != GDB_SIGNAL_0)
	{
	  /* Step inferior_ptid, with or without signal.  */
	  p = append_resumption (p, endp, inferior_ptid, step, siggnal);
	}

      /* Also pass down any pending signaled resumption for other
	 threads not the current.  */
      p = append_pending_thread_resumptions (p, endp, ptid);

      /* And continue others without a signal.  */
      append_resumption (p, endp, ptid, /*step=*/ 0, GDB_SIGNAL_0);
    }
  else
    {
      /* Scheduler locking; resume only PTID.  */
      append_resumption (p, endp, ptid, step, siggnal);
    }

  gdb_assert (strlen (rs->buf) < get_remote_packet_size ());
  putpkt (rs->buf);

  if (non_stop)
    {
      /* In non-stop, the stub replies to vCont with "OK".  The stop
	 reply will be reported asynchronously by means of a `%Stop'
	 notification.  */
      getpkt (&rs->buf, &rs->buf_size, 0);
      if (strcmp (rs->buf, "OK") != 0)
	error (_("Unexpected vCont reply in non-stop mode: %s"), rs->buf);
    }

  return 1;
}

/* Tell the remote machine to resume.  */

static void
remote_resume (struct target_ops *ops,
	       ptid_t ptid, int step, enum gdb_signal siggnal)
{
  struct remote_state *rs = get_remote_state ();
  char *buf;

  /* In all-stop, we can't mark REMOTE_ASYNC_GET_PENDING_EVENTS_TOKEN
     (explained in remote-notif.c:handle_notification) so
     remote_notif_process is not called.  We need find a place where
     it is safe to start a 'vNotif' sequence.  It is good to do it
     before resuming inferior, because inferior was stopped and no RSP
     traffic at that moment.  */
  if (!non_stop)
    remote_notif_process (rs->notif_state, &notif_client_stop);

  rs->last_sent_signal = siggnal;
  rs->last_sent_step = step;

  /* The vCont packet doesn't need to specify threads via Hc.  */
  /* No reverse support (yet) for vCont.  */
  if (execution_direction != EXEC_REVERSE)
    if (remote_vcont_resume (ptid, step, siggnal))
      goto done;

  /* All other supported resume packets do use Hc, so set the continue
     thread.  */
  if (ptid_equal (ptid, minus_one_ptid))
    set_continue_thread (any_thread_ptid);
  else
    set_continue_thread (ptid);

  buf = rs->buf;
  if (execution_direction == EXEC_REVERSE)
    {
      /* We don't pass signals to the target in reverse exec mode.  */
      if (info_verbose && siggnal != GDB_SIGNAL_0)
	warning (_(" - Can't pass signal %d to target in reverse: ignored."),
		 siggnal);

      if (step 
	  && remote_protocol_packets[PACKET_bs].support == PACKET_DISABLE)
	error (_("Remote reverse-step not supported."));
      if (!step
	  && remote_protocol_packets[PACKET_bc].support == PACKET_DISABLE)
	error (_("Remote reverse-continue not supported."));

      strcpy (buf, step ? "bs" : "bc");
    }
  else if (siggnal != GDB_SIGNAL_0)
    {
      buf[0] = step ? 'S' : 'C';
      buf[1] = tohex (((int) siggnal >> 4) & 0xf);
      buf[2] = tohex (((int) siggnal) & 0xf);
      buf[3] = '\0';
    }
  else
    strcpy (buf, step ? "s" : "c");

  putpkt (buf);

 done:
  /* We are about to start executing the inferior, let's register it
     with the event loop.  NOTE: this is the one place where all the
     execution commands end up.  We could alternatively do this in each
     of the execution commands in infcmd.c.  */
  /* FIXME: ezannoni 1999-09-28: We may need to move this out of here
     into infcmd.c in order to allow inferior function calls to work
     NOT asynchronously.  */
  if (target_can_async_p ())
    target_async (inferior_event_handler, 0);

  /* We've just told the target to resume.  The remote server will
     wait for the inferior to stop, and then send a stop reply.  In
     the mean time, we can't start another command/query ourselves
     because the stub wouldn't be ready to process it.  This applies
     only to the base all-stop protocol, however.  In non-stop (which
     only supports vCont), the stub replies with an "OK", and is
     immediate able to process further serial input.  */
  if (!non_stop)
    rs->waiting_for_stop_reply = 1;
}


/* Set up the signal handler for SIGINT, while the target is
   executing, ovewriting the 'regular' SIGINT signal handler.  */
static void
async_initialize_sigint_signal_handler (void)
{
  signal (SIGINT, async_handle_remote_sigint);
}

/* Signal handler for SIGINT, while the target is executing.  */
static void
async_handle_remote_sigint (int sig)
{
  signal (sig, async_handle_remote_sigint_twice);
  mark_async_signal_handler (async_sigint_remote_token);
}

/* Signal handler for SIGINT, installed after SIGINT has already been
   sent once.  It will take effect the second time that the user sends
   a ^C.  */
static void
async_handle_remote_sigint_twice (int sig)
{
  signal (sig, async_handle_remote_sigint);
  mark_async_signal_handler (async_sigint_remote_twice_token);
}

/* Perform the real interruption of the target execution, in response
   to a ^C.  */
static void
async_remote_interrupt (gdb_client_data arg)
{
  if (remote_debug)
    fprintf_unfiltered (gdb_stdlog, "async_remote_interrupt called\n");

  target_stop (inferior_ptid);
}

/* Perform interrupt, if the first attempt did not succeed.  Just give
   up on the target alltogether.  */
static void
async_remote_interrupt_twice (gdb_client_data arg)
{
  if (remote_debug)
    fprintf_unfiltered (gdb_stdlog, "async_remote_interrupt_twice called\n");

  interrupt_query ();
}

/* Reinstall the usual SIGINT handlers, after the target has
   stopped.  */
static void
async_cleanup_sigint_signal_handler (void *dummy)
{
  signal (SIGINT, handle_sigint);
}

/* Send ^C to target to halt it.  Target will respond, and send us a
   packet.  */
static void (*ofunc) (int);

/* The command line interface's stop routine.  This function is installed
   as a signal handler for SIGINT.  The first time a user requests a
   stop, we call remote_stop to send a break or ^C.  If there is no
   response from the target (it didn't stop when the user requested it),
   we ask the user if he'd like to detach from the target.  */
static void
sync_remote_interrupt (int signo)
{
  /* If this doesn't work, try more severe steps.  */
  signal (signo, sync_remote_interrupt_twice);

  gdb_call_async_signal_handler (async_sigint_remote_token, 1);
}

/* The user typed ^C twice.  */

static void
sync_remote_interrupt_twice (int signo)
{
  signal (signo, ofunc);
  gdb_call_async_signal_handler (async_sigint_remote_twice_token, 1);
  signal (signo, sync_remote_interrupt);
}

/* Non-stop version of target_stop.  Uses `vCont;t' to stop a remote
   thread, all threads of a remote process, or all threads of all
   processes.  */

static void
remote_stop_ns (ptid_t ptid)
{
  struct remote_state *rs = get_remote_state ();
  char *p = rs->buf;
  char *endp = rs->buf + get_remote_packet_size ();

  if (remote_protocol_packets[PACKET_vCont].support == PACKET_SUPPORT_UNKNOWN)
    remote_vcont_probe (rs);

  if (!rs->supports_vCont.t)
    error (_("Remote server does not support stopping threads"));

  if (ptid_equal (ptid, minus_one_ptid)
      || (!remote_multi_process_p (rs) && ptid_is_pid (ptid)))
    p += xsnprintf (p, endp - p, "vCont;t");
  else
    {
      ptid_t nptid;

      p += xsnprintf (p, endp - p, "vCont;t:");

      if (ptid_is_pid (ptid))
	  /* All (-1) threads of process.  */
	nptid = ptid_build (ptid_get_pid (ptid), 0, -1);
      else
	{
	  /* Small optimization: if we already have a stop reply for
	     this thread, no use in telling the stub we want this
	     stopped.  */
	  if (peek_stop_reply (ptid))
	    return;

	  nptid = ptid;
	}

      write_ptid (p, endp, nptid);
    }

  /* In non-stop, we get an immediate OK reply.  The stop reply will
     come in asynchronously by notification.  */
  putpkt (rs->buf);
  getpkt (&rs->buf, &rs->buf_size, 0);
  if (strcmp (rs->buf, "OK") != 0)
    error (_("Stopping %s failed: %s"), target_pid_to_str (ptid), rs->buf);
}

/* All-stop version of target_stop.  Sends a break or a ^C to stop the
   remote target.  It is undefined which thread of which process
   reports the stop.  */

static void
remote_stop_as (ptid_t ptid)
{
  struct remote_state *rs = get_remote_state ();

  rs->ctrlc_pending_p = 1;

  /* If the inferior is stopped already, but the core didn't know
     about it yet, just ignore the request.  The cached wait status
     will be collected in remote_wait.  */
  if (rs->cached_wait_status)
    return;

  /* Send interrupt_sequence to remote target.  */
  send_interrupt_sequence ();
}

/* This is the generic stop called via the target vector.  When a target
   interrupt is requested, either by the command line or the GUI, we
   will eventually end up here.  */

static void
remote_stop (ptid_t ptid)
{
  if (remote_debug)
    fprintf_unfiltered (gdb_stdlog, "remote_stop called\n");

  if (non_stop)
    remote_stop_ns (ptid);
  else
    remote_stop_as (ptid);
}

/* Ask the user what to do when an interrupt is received.  */

static void
interrupt_query (void)
{
  target_terminal_ours ();

  if (target_can_async_p ())
    {
      signal (SIGINT, handle_sigint);
      quit ();
    }
  else
    {
      if (query (_("Interrupted while waiting for the program.\n\
Give up (and stop debugging it)? ")))
	{
	  remote_unpush_target ();
	  quit ();
	}
    }

  target_terminal_inferior ();
}

/* Enable/disable target terminal ownership.  Most targets can use
   terminal groups to control terminal ownership.  Remote targets are
   different in that explicit transfer of ownership to/from GDB/target
   is required.  */

static void
remote_terminal_inferior (void)
{
  if (!target_async_permitted)
    /* Nothing to do.  */
    return;

  /* FIXME: cagney/1999-09-27: Make calls to target_terminal_*()
     idempotent.  The event-loop GDB talking to an asynchronous target
     with a synchronous command calls this function from both
     event-top.c and infrun.c/infcmd.c.  Once GDB stops trying to
     transfer the terminal to the target when it shouldn't this guard
     can go away.  */
  if (!remote_async_terminal_ours_p)
    return;
  delete_file_handler (input_fd);
  remote_async_terminal_ours_p = 0;
  async_initialize_sigint_signal_handler ();
  /* NOTE: At this point we could also register our selves as the
     recipient of all input.  Any characters typed could then be
     passed on down to the target.  */
}

static void
remote_terminal_ours (void)
{
  if (!target_async_permitted)
    /* Nothing to do.  */
    return;

  /* See FIXME in remote_terminal_inferior.  */
  if (remote_async_terminal_ours_p)
    return;
  async_cleanup_sigint_signal_handler (NULL);
  add_file_handler (input_fd, stdin_event_handler, 0);
  remote_async_terminal_ours_p = 1;
}

static void
remote_console_output (char *msg)
{
  char *p;

  for (p = msg; p[0] && p[1]; p += 2)
    {
      char tb[2];
      char c = fromhex (p[0]) * 16 + fromhex (p[1]);

      tb[0] = c;
      tb[1] = 0;
      fputs_unfiltered (tb, gdb_stdtarg);
    }
  gdb_flush (gdb_stdtarg);
}

typedef struct cached_reg
{
  int num;
  gdb_byte data[MAX_REGISTER_SIZE];
} cached_reg_t;

DEF_VEC_O(cached_reg_t);

typedef struct stop_reply
{
  struct notif_event base;

  /* The identifier of the thread about this event  */
  ptid_t ptid;

  /* The remote state this event is associated with.  When the remote
     connection, represented by a remote_state object, is closed,
     all the associated stop_reply events should be released.  */
  struct remote_state *rs;

  struct target_waitstatus ws;

  /* Expedited registers.  This makes remote debugging a bit more
     efficient for those targets that provide critical registers as
     part of their normal status mechanism (as another roundtrip to
     fetch them is avoided).  */
  VEC(cached_reg_t) *regcache;

  int stopped_by_watchpoint_p;
  CORE_ADDR watch_data_address;

  int core;
} *stop_reply_p;

DECLARE_QUEUE_P (stop_reply_p);
DEFINE_QUEUE_P (stop_reply_p);
/* The list of already fetched and acknowledged stop events.  This
   queue is used for notification Stop, and other notifications
   don't need queue for their events, because the notification events
   of Stop can't be consumed immediately, so that events should be
   queued first, and be consumed by remote_wait_{ns,as} one per
   time.  Other notifications can consume their events immediately,
   so queue is not needed for them.  */
static QUEUE (stop_reply_p) *stop_reply_queue;

static void
stop_reply_xfree (struct stop_reply *r)
{
  notif_event_xfree ((struct notif_event *) r);
}

static void
remote_notif_stop_parse (struct notif_client *self, char *buf,
			 struct notif_event *event)
{
  remote_parse_stop_reply (buf, (struct stop_reply *) event);
}

static void
remote_notif_stop_ack (struct notif_client *self, char *buf,
		       struct notif_event *event)
{
  struct stop_reply *stop_reply = (struct stop_reply *) event;

  /* acknowledge */
  putpkt ((char *) self->ack_command);

  if (stop_reply->ws.kind == TARGET_WAITKIND_IGNORE)
      /* We got an unknown stop reply.  */
      error (_("Unknown stop reply"));

  push_stop_reply (stop_reply);
}

static int
remote_notif_stop_can_get_pending_events (struct notif_client *self)
{
  /* We can't get pending events in remote_notif_process for
     notification stop, and we have to do this in remote_wait_ns
     instead.  If we fetch all queued events from stub, remote stub
     may exit and we have no chance to process them back in
     remote_wait_ns.  */
  mark_async_event_handler (remote_async_inferior_event_token);
  return 0;
}

static void
stop_reply_dtr (struct notif_event *event)
{
  struct stop_reply *r = (struct stop_reply *) event;

  VEC_free (cached_reg_t, r->regcache);
}

static struct notif_event *
remote_notif_stop_alloc_reply (void)
{
  struct notif_event *r
    = (struct notif_event *) XMALLOC (struct stop_reply);

  r->dtr = stop_reply_dtr;

  return r;
}

/* A client of notification Stop.  */

struct notif_client notif_client_stop =
{
  "Stop",
  "vStopped",
  remote_notif_stop_parse,
  remote_notif_stop_ack,
  remote_notif_stop_can_get_pending_events,
  remote_notif_stop_alloc_reply,
  REMOTE_NOTIF_STOP,
};

/* A parameter to pass data in and out.  */

struct queue_iter_param
{
  void *input;
  struct stop_reply *output;
};

/* Remove stop replies in the queue if its pid is equal to the given
   inferior's pid.  */

static int
remove_stop_reply_for_inferior (QUEUE (stop_reply_p) *q,
				QUEUE_ITER (stop_reply_p) *iter,
				stop_reply_p event,
				void *data)
{
  struct queue_iter_param *param = data;
  struct inferior *inf = param->input;

  if (ptid_get_pid (event->ptid) == inf->pid)
    {
      stop_reply_xfree (event);
      QUEUE_remove_elem (stop_reply_p, q, iter);
    }

  return 1;
}

/* Discard all pending stop replies of inferior INF.  */

static void
discard_pending_stop_replies (struct inferior *inf)
{
  int i;
  struct queue_iter_param param;
  struct stop_reply *reply;
  struct remote_state *rs = get_remote_state ();
  struct remote_notif_state *rns = rs->notif_state;

  /* This function can be notified when an inferior exists.  When the
     target is not remote, the notification state is NULL.  */
  if (rs->remote_desc == NULL)
    return;

  reply = (struct stop_reply *) rns->pending_event[notif_client_stop.id];

  /* Discard the in-flight notification.  */
  if (reply != NULL && ptid_get_pid (reply->ptid) == inf->pid)
    {
      stop_reply_xfree (reply);
      rns->pending_event[notif_client_stop.id] = NULL;
    }

  param.input = inf;
  param.output = NULL;
  /* Discard the stop replies we have already pulled with
     vStopped.  */
  QUEUE_iterate (stop_reply_p, stop_reply_queue,
		 remove_stop_reply_for_inferior, &param);
}

/* If its remote state is equal to the given remote state,
   remove EVENT from the stop reply queue.  */

static int
remove_stop_reply_of_remote_state (QUEUE (stop_reply_p) *q,
				   QUEUE_ITER (stop_reply_p) *iter,
				   stop_reply_p event,
				   void *data)
{
  struct queue_iter_param *param = data;
  struct remote_state *rs = param->input;

  if (event->rs == rs)
    {
      stop_reply_xfree (event);
      QUEUE_remove_elem (stop_reply_p, q, iter);
    }

  return 1;
}

/* Discard the stop replies for RS in stop_reply_queue.  */

static void
discard_pending_stop_replies_in_queue (struct remote_state *rs)
{
  struct queue_iter_param param;

  param.input = rs;
  param.output = NULL;
  /* Discard the stop replies we have already pulled with
     vStopped.  */
  QUEUE_iterate (stop_reply_p, stop_reply_queue,
		 remove_stop_reply_of_remote_state, &param);
}

/* A parameter to pass data in and out.  */

static int
remote_notif_remove_once_on_match (QUEUE (stop_reply_p) *q,
				   QUEUE_ITER (stop_reply_p) *iter,
				   stop_reply_p event,
				   void *data)
{
  struct queue_iter_param *param = data;
  ptid_t *ptid = param->input;

  if (ptid_match (event->ptid, *ptid))
    {
      param->output = event;
      QUEUE_remove_elem (stop_reply_p, q, iter);
      return 0;
    }

  return 1;
}

/* Remove the first reply in 'stop_reply_queue' which matches
   PTID.  */

static struct stop_reply *
remote_notif_remove_queued_reply (ptid_t ptid)
{
  struct queue_iter_param param;

  param.input = &ptid;
  param.output = NULL;

  QUEUE_iterate (stop_reply_p, stop_reply_queue,
		 remote_notif_remove_once_on_match, &param);
  if (notif_debug)
    fprintf_unfiltered (gdb_stdlog,
			"notif: discard queued event: 'Stop' in %s\n",
			target_pid_to_str (ptid));

  return param.output;
}

/* Look for a queued stop reply belonging to PTID.  If one is found,
   remove it from the queue, and return it.  Returns NULL if none is
   found.  If there are still queued events left to process, tell the
   event loop to get back to target_wait soon.  */

static struct stop_reply *
queued_stop_reply (ptid_t ptid)
{
  struct stop_reply *r = remote_notif_remove_queued_reply (ptid);

  if (!QUEUE_is_empty (stop_reply_p, stop_reply_queue))
    /* There's still at least an event left.  */
    mark_async_event_handler (remote_async_inferior_event_token);

  return r;
}

/* Push a fully parsed stop reply in the stop reply queue.  Since we
   know that we now have at least one queued event left to pass to the
   core side, tell the event loop to get back to target_wait soon.  */

static void
push_stop_reply (struct stop_reply *new_event)
{
  QUEUE_enque (stop_reply_p, stop_reply_queue, new_event);

  if (notif_debug)
    fprintf_unfiltered (gdb_stdlog,
			"notif: push 'Stop' %s to queue %d\n",
			target_pid_to_str (new_event->ptid),
			QUEUE_length (stop_reply_p,
				      stop_reply_queue));

  mark_async_event_handler (remote_async_inferior_event_token);
}

static int
stop_reply_match_ptid_and_ws (QUEUE (stop_reply_p) *q,
			      QUEUE_ITER (stop_reply_p) *iter,
			      struct stop_reply *event,
			      void *data)
{
  ptid_t *ptid = data;

  return !(ptid_equal (*ptid, event->ptid)
	   && event->ws.kind == TARGET_WAITKIND_STOPPED);
}

/* Returns true if we have a stop reply for PTID.  */

static int
peek_stop_reply (ptid_t ptid)
{
  return !QUEUE_iterate (stop_reply_p, stop_reply_queue,
			 stop_reply_match_ptid_and_ws, &ptid);
}

/* Parse the stop reply in BUF.  Either the function succeeds, and the
   result is stored in EVENT, or throws an error.  */

static void
remote_parse_stop_reply (char *buf, struct stop_reply *event)
{
  struct remote_arch_state *rsa = get_remote_arch_state ();
  ULONGEST addr;
  char *p;

  event->ptid = null_ptid;
  event->rs = get_remote_state ();
  event->ws.kind = TARGET_WAITKIND_IGNORE;
  event->ws.value.integer = 0;
  event->stopped_by_watchpoint_p = 0;
  event->regcache = NULL;
  event->core = -1;

  switch (buf[0])
    {
    case 'T':		/* Status with PC, SP, FP, ...	*/
      /* Expedited reply, containing Signal, {regno, reg} repeat.  */
      /*  format is:  'Tssn...:r...;n...:r...;n...:r...;#cc', where
	    ss = signal number
	    n... = register number
	    r... = register contents
      */

      p = &buf[3];	/* after Txx */
      while (*p)
	{
	  char *p1;
	  char *p_temp;
	  int fieldsize;
	  LONGEST pnum = 0;

	  /* If the packet contains a register number, save it in
	     pnum and set p1 to point to the character following it.
	     Otherwise p1 points to p.  */

	  /* If this packet is an awatch packet, don't parse the 'a'
	     as a register number.  */

	  if (strncmp (p, "awatch", strlen("awatch")) != 0
	      && strncmp (p, "core", strlen ("core") != 0))
	    {
	      /* Read the ``P'' register number.  */
	      pnum = strtol (p, &p_temp, 16);
	      p1 = p_temp;
	    }
	  else
	    p1 = p;

	  if (p1 == p)	/* No register number present here.  */
	    {
	      p1 = strchr (p, ':');
	      if (p1 == NULL)
		error (_("Malformed packet(a) (missing colon): %s\n\
Packet: '%s'\n"),
		       p, buf);
	      if (strncmp (p, "thread", p1 - p) == 0)
		event->ptid = read_ptid (++p1, &p);
	      else if ((strncmp (p, "watch", p1 - p) == 0)
		       || (strncmp (p, "rwatch", p1 - p) == 0)
		       || (strncmp (p, "awatch", p1 - p) == 0))
		{
		  event->stopped_by_watchpoint_p = 1;
		  p = unpack_varlen_hex (++p1, &addr);
		  event->watch_data_address = (CORE_ADDR) addr;
		}
	      else if (strncmp (p, "library", p1 - p) == 0)
		{
		  p1++;
		  p_temp = p1;
		  while (*p_temp && *p_temp != ';')
		    p_temp++;

		  event->ws.kind = TARGET_WAITKIND_LOADED;
		  p = p_temp;
		}
	      else if (strncmp (p, "replaylog", p1 - p) == 0)
		{
		  event->ws.kind = TARGET_WAITKIND_NO_HISTORY;
		  /* p1 will indicate "begin" or "end", but it makes
		     no difference for now, so ignore it.  */
		  p_temp = strchr (p1 + 1, ';');
		  if (p_temp)
		    p = p_temp;
		}
	      else if (strncmp (p, "core", p1 - p) == 0)
		{
		  ULONGEST c;

		  p = unpack_varlen_hex (++p1, &c);
		  event->core = c;
		}
	      else
		{
		  /* Silently skip unknown optional info.  */
		  p_temp = strchr (p1 + 1, ';');
		  if (p_temp)
		    p = p_temp;
		}
	    }
	  else
	    {
	      struct packet_reg *reg = packet_reg_from_pnum (rsa, pnum);
	      cached_reg_t cached_reg;

	      p = p1;

	      if (*p != ':')
		error (_("Malformed packet(b) (missing colon): %s\n\
Packet: '%s'\n"),
		       p, buf);
	      ++p;

	      if (reg == NULL)
		error (_("Remote sent bad register number %s: %s\n\
Packet: '%s'\n"),
		       hex_string (pnum), p, buf);

	      cached_reg.num = reg->regnum;

	      fieldsize = hex2bin (p, cached_reg.data,
				   register_size (target_gdbarch (),
						  reg->regnum));
	      p += 2 * fieldsize;
	      if (fieldsize < register_size (target_gdbarch (),
					     reg->regnum))
		warning (_("Remote reply is too short: %s"), buf);

	      VEC_safe_push (cached_reg_t, event->regcache, &cached_reg);
	    }

	  if (*p != ';')
	    error (_("Remote register badly formatted: %s\nhere: %s"),
		   buf, p);
	  ++p;
	}

      if (event->ws.kind != TARGET_WAITKIND_IGNORE)
	break;

      /* fall through */
    case 'S':		/* Old style status, just signal only.  */
      event->ws.kind = TARGET_WAITKIND_STOPPED;
      event->ws.value.sig = (enum gdb_signal)
	(((fromhex (buf[1])) << 4) + (fromhex (buf[2])));
      break;
    case 'W':		/* Target exited.  */
    case 'X':
      {
	char *p;
	int pid;
	ULONGEST value;

	/* GDB used to accept only 2 hex chars here.  Stubs should
	   only send more if they detect GDB supports multi-process
	   support.  */
	p = unpack_varlen_hex (&buf[1], &value);

	if (buf[0] == 'W')
	  {
	    /* The remote process exited.  */
	    event->ws.kind = TARGET_WAITKIND_EXITED;
	    event->ws.value.integer = value;
	  }
	else
	  {
	    /* The remote process exited with a signal.  */
	    event->ws.kind = TARGET_WAITKIND_SIGNALLED;
	    event->ws.value.sig = (enum gdb_signal) value;
	  }

	/* If no process is specified, assume inferior_ptid.  */
	pid = ptid_get_pid (inferior_ptid);
	if (*p == '\0')
	  ;
	else if (*p == ';')
	  {
	    p++;

	    if (p == '\0')
	      ;
	    else if (strncmp (p,
			      "process:", sizeof ("process:") - 1) == 0)
	      {
		ULONGEST upid;

		p += sizeof ("process:") - 1;
		unpack_varlen_hex (p, &upid);
		pid = upid;
	      }
	    else
	      error (_("unknown stop reply packet: %s"), buf);
	  }
	else
	  error (_("unknown stop reply packet: %s"), buf);
	event->ptid = pid_to_ptid (pid);
      }
      break;
    }

  if (non_stop && ptid_equal (event->ptid, null_ptid))
    error (_("No process or thread specified in stop reply: %s"), buf);
}

/* When the stub wants to tell GDB about a new notification reply, it
   sends a notification (%Stop, for example).  Those can come it at
   any time, hence, we have to make sure that any pending
   putpkt/getpkt sequence we're making is finished, before querying
   the stub for more events with the corresponding ack command
   (vStopped, for example).  E.g., if we started a vStopped sequence
   immediately upon receiving the notification, something like this
   could happen:

    1.1) --> Hg 1
    1.2) <-- OK
    1.3) --> g
    1.4) <-- %Stop
    1.5) --> vStopped
    1.6) <-- (registers reply to step #1.3)

   Obviously, the reply in step #1.6 would be unexpected to a vStopped
   query.

   To solve this, whenever we parse a %Stop notification successfully,
   we mark the REMOTE_ASYNC_GET_PENDING_EVENTS_TOKEN, and carry on
   doing whatever we were doing:

    2.1) --> Hg 1
    2.2) <-- OK
    2.3) --> g
    2.4) <-- %Stop
      <GDB marks the REMOTE_ASYNC_GET_PENDING_EVENTS_TOKEN>
    2.5) <-- (registers reply to step #2.3)

   Eventualy after step #2.5, we return to the event loop, which
   notices there's an event on the
   REMOTE_ASYNC_GET_PENDING_EVENTS_TOKEN event and calls the
   associated callback --- the function below.  At this point, we're
   always safe to start a vStopped sequence. :

    2.6) --> vStopped
    2.7) <-- T05 thread:2
    2.8) --> vStopped
    2.9) --> OK
*/

void
remote_notif_get_pending_events (struct notif_client *nc)
{
  struct remote_state *rs = get_remote_state ();

  if (rs->notif_state->pending_event[nc->id] != NULL)
    {
      if (notif_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "notif: process: '%s' ack pending event\n",
			    nc->name);

      /* acknowledge */
      nc->ack (nc, rs->buf, rs->notif_state->pending_event[nc->id]);
      rs->notif_state->pending_event[nc->id] = NULL;

      while (1)
	{
	  getpkt (&rs->buf, &rs->buf_size, 0);
	  if (strcmp (rs->buf, "OK") == 0)
	    break;
	  else
	    remote_notif_ack (nc, rs->buf);
	}
    }
  else
    {
      if (notif_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "notif: process: '%s' no pending reply\n",
			    nc->name);
    }
}

/* Called when it is decided that STOP_REPLY holds the info of the
   event that is to be returned to the core.  This function always
   destroys STOP_REPLY.  */

static ptid_t
process_stop_reply (struct stop_reply *stop_reply,
		    struct target_waitstatus *status)
{
  ptid_t ptid;

  *status = stop_reply->ws;
  ptid = stop_reply->ptid;

  /* If no thread/process was reported by the stub, assume the current
     inferior.  */
  if (ptid_equal (ptid, null_ptid))
    ptid = inferior_ptid;

  if (status->kind != TARGET_WAITKIND_EXITED
      && status->kind != TARGET_WAITKIND_SIGNALLED)
    {
      struct remote_state *rs = get_remote_state ();

      /* Expedited registers.  */
      if (stop_reply->regcache)
	{
	  struct regcache *regcache
	    = get_thread_arch_regcache (ptid, target_gdbarch ());
	  cached_reg_t *reg;
	  int ix;

	  for (ix = 0;
	       VEC_iterate(cached_reg_t, stop_reply->regcache, ix, reg);
	       ix++)
	    regcache_raw_supply (regcache, reg->num, reg->data);
	  VEC_free (cached_reg_t, stop_reply->regcache);
	}

      rs->remote_stopped_by_watchpoint_p = stop_reply->stopped_by_watchpoint_p;
      rs->remote_watch_data_address = stop_reply->watch_data_address;

      remote_notice_new_inferior (ptid, 0);
      demand_private_info (ptid)->core = stop_reply->core;
    }

  stop_reply_xfree (stop_reply);
  return ptid;
}

/* The non-stop mode version of target_wait.  */

static ptid_t
remote_wait_ns (ptid_t ptid, struct target_waitstatus *status, int options)
{
  struct remote_state *rs = get_remote_state ();
  struct stop_reply *stop_reply;
  int ret;
  int is_notif = 0;

  /* If in non-stop mode, get out of getpkt even if a
     notification is received.	*/

  ret = getpkt_or_notif_sane (&rs->buf, &rs->buf_size,
			      0 /* forever */, &is_notif);
  while (1)
    {
      if (ret != -1 && !is_notif)
	switch (rs->buf[0])
	  {
	  case 'E':		/* Error of some sort.	*/
	    /* We're out of sync with the target now.  Did it continue
	       or not?  We can't tell which thread it was in non-stop,
	       so just ignore this.  */
	    warning (_("Remote failure reply: %s"), rs->buf);
	    break;
	  case 'O':		/* Console output.  */
	    remote_console_output (rs->buf + 1);
	    break;
	  default:
	    warning (_("Invalid remote reply: %s"), rs->buf);
	    break;
	  }

      /* Acknowledge a pending stop reply that may have arrived in the
	 mean time.  */
      if (rs->notif_state->pending_event[notif_client_stop.id] != NULL)
	remote_notif_get_pending_events (&notif_client_stop);

      /* If indeed we noticed a stop reply, we're done.  */
      stop_reply = queued_stop_reply (ptid);
      if (stop_reply != NULL)
	return process_stop_reply (stop_reply, status);

      /* Still no event.  If we're just polling for an event, then
	 return to the event loop.  */
      if (options & TARGET_WNOHANG)
	{
	  status->kind = TARGET_WAITKIND_IGNORE;
	  return minus_one_ptid;
	}

      /* Otherwise do a blocking wait.  */
      ret = getpkt_or_notif_sane (&rs->buf, &rs->buf_size,
				  1 /* forever */, &is_notif);
    }
}

/* Wait until the remote machine stops, then return, storing status in
   STATUS just as `wait' would.  */

static ptid_t
remote_wait_as (ptid_t ptid, struct target_waitstatus *status, int options)
{
  struct remote_state *rs = get_remote_state ();
  ptid_t event_ptid = null_ptid;
  char *buf;
  struct stop_reply *stop_reply;

 again:

  status->kind = TARGET_WAITKIND_IGNORE;
  status->value.integer = 0;

  stop_reply = queued_stop_reply (ptid);
  if (stop_reply != NULL)
    return process_stop_reply (stop_reply, status);

  if (rs->cached_wait_status)
    /* Use the cached wait status, but only once.  */
    rs->cached_wait_status = 0;
  else
    {
      int ret;
      int is_notif;

      if (!target_is_async_p ())
	{
	  ofunc = signal (SIGINT, sync_remote_interrupt);
	  /* If the user hit C-c before this packet, or between packets,
	     pretend that it was hit right here.  */
	  if (check_quit_flag ())
	    {
	      clear_quit_flag ();
	      sync_remote_interrupt (SIGINT);
	    }
	}

      /* FIXME: cagney/1999-09-27: If we're in async mode we should
	 _never_ wait for ever -> test on target_is_async_p().
	 However, before we do that we need to ensure that the caller
	 knows how to take the target into/out of async mode.  */
      ret = getpkt_or_notif_sane (&rs->buf, &rs->buf_size,
				  wait_forever_enabled_p, &is_notif);

      if (!target_is_async_p ())
	signal (SIGINT, ofunc);

      /* GDB gets a notification.  Return to core as this event is
	 not interesting.  */
      if (ret != -1 && is_notif)
	return minus_one_ptid;
    }

  buf = rs->buf;

  rs->remote_stopped_by_watchpoint_p = 0;

  /* We got something.  */
  rs->waiting_for_stop_reply = 0;

  /* Assume that the target has acknowledged Ctrl-C unless we receive
     an 'F' or 'O' packet.  */
  if (buf[0] != 'F' && buf[0] != 'O')
    rs->ctrlc_pending_p = 0;

  switch (buf[0])
    {
    case 'E':		/* Error of some sort.	*/
      /* We're out of sync with the target now.  Did it continue or
	 not?  Not is more likely, so report a stop.  */
      warning (_("Remote failure reply: %s"), buf);
      status->kind = TARGET_WAITKIND_STOPPED;
      status->value.sig = GDB_SIGNAL_0;
      break;
    case 'F':		/* File-I/O request.  */
      remote_fileio_request (buf, rs->ctrlc_pending_p);
      rs->ctrlc_pending_p = 0;
      break;
    case 'T': case 'S': case 'X': case 'W':
      {
	struct stop_reply *stop_reply
	  = (struct stop_reply *) remote_notif_parse (&notif_client_stop,
						      rs->buf);

	event_ptid = process_stop_reply (stop_reply, status);
	break;
      }
    case 'O':		/* Console output.  */
      remote_console_output (buf + 1);

      /* The target didn't really stop; keep waiting.  */
      rs->waiting_for_stop_reply = 1;

      break;
    case '\0':
      if (rs->last_sent_signal != GDB_SIGNAL_0)
	{
	  /* Zero length reply means that we tried 'S' or 'C' and the
	     remote system doesn't support it.  */
	  target_terminal_ours_for_output ();
	  printf_filtered
	    ("Can't send signals to this remote system.  %s not sent.\n",
	     gdb_signal_to_name (rs->last_sent_signal));
	  rs->last_sent_signal = GDB_SIGNAL_0;
	  target_terminal_inferior ();

	  strcpy ((char *) buf, rs->last_sent_step ? "s" : "c");
	  putpkt ((char *) buf);

	  /* We just told the target to resume, so a stop reply is in
	     order.  */
	  rs->waiting_for_stop_reply = 1;
	  break;
	}
      /* else fallthrough */
    default:
      warning (_("Invalid remote reply: %s"), buf);
      /* Keep waiting.  */
      rs->waiting_for_stop_reply = 1;
      break;
    }

  if (status->kind == TARGET_WAITKIND_IGNORE)
    {
      /* Nothing interesting happened.  If we're doing a non-blocking
	 poll, we're done.  Otherwise, go back to waiting.  */
      if (options & TARGET_WNOHANG)
	return minus_one_ptid;
      else
	goto again;
    }
  else if (status->kind != TARGET_WAITKIND_EXITED
	   && status->kind != TARGET_WAITKIND_SIGNALLED)
    {
      if (!ptid_equal (event_ptid, null_ptid))
	record_currthread (rs, event_ptid);
      else
	event_ptid = inferior_ptid;
    }
  else
    /* A process exit.  Invalidate our notion of current thread.  */
    record_currthread (rs, minus_one_ptid);

  return event_ptid;
}

/* Wait until the remote machine stops, then return, storing status in
   STATUS just as `wait' would.  */

static ptid_t
remote_wait (struct target_ops *ops,
	     ptid_t ptid, struct target_waitstatus *status, int options)
{
  ptid_t event_ptid;

  if (non_stop)
    event_ptid = remote_wait_ns (ptid, status, options);
  else
    event_ptid = remote_wait_as (ptid, status, options);

  if (target_can_async_p ())
    {
      /* If there are are events left in the queue tell the event loop
	 to return here.  */
      if (!QUEUE_is_empty (stop_reply_p, stop_reply_queue))
	mark_async_event_handler (remote_async_inferior_event_token);
    }

  return event_ptid;
}

/* Fetch a single register using a 'p' packet.  */

static int
fetch_register_using_p (struct regcache *regcache, struct packet_reg *reg)
{
  struct remote_state *rs = get_remote_state ();
  char *buf, *p;
  char regp[MAX_REGISTER_SIZE];
  int i;

  if (remote_protocol_packets[PACKET_p].support == PACKET_DISABLE)
    return 0;

  if (reg->pnum == -1)
    return 0;

  p = rs->buf;
  *p++ = 'p';
  p += hexnumstr (p, reg->pnum);
  *p++ = '\0';
  putpkt (rs->buf);
  getpkt (&rs->buf, &rs->buf_size, 0);

  buf = rs->buf;

  switch (packet_ok (buf, &remote_protocol_packets[PACKET_p]))
    {
    case PACKET_OK:
      break;
    case PACKET_UNKNOWN:
      return 0;
    case PACKET_ERROR:
      error (_("Could not fetch register \"%s\"; remote failure reply '%s'"),
	     gdbarch_register_name (get_regcache_arch (regcache), 
				    reg->regnum), 
	     buf);
    }

  /* If this register is unfetchable, tell the regcache.  */
  if (buf[0] == 'x')
    {
      regcache_raw_supply (regcache, reg->regnum, NULL);
      return 1;
    }

  /* Otherwise, parse and supply the value.  */
  p = buf;
  i = 0;
  while (p[0] != 0)
    {
      if (p[1] == 0)
	error (_("fetch_register_using_p: early buf termination"));

      regp[i++] = fromhex (p[0]) * 16 + fromhex (p[1]);
      p += 2;
    }
  regcache_raw_supply (regcache, reg->regnum, regp);
  return 1;
}

/* Fetch the registers included in the target's 'g' packet.  */

static int
send_g_packet (void)
{
  struct remote_state *rs = get_remote_state ();
  int buf_len;

  xsnprintf (rs->buf, get_remote_packet_size (), "g");
  remote_send (&rs->buf, &rs->buf_size);

  /* We can get out of synch in various cases.  If the first character
     in the buffer is not a hex character, assume that has happened
     and try to fetch another packet to read.  */
  while ((rs->buf[0] < '0' || rs->buf[0] > '9')
	 && (rs->buf[0] < 'A' || rs->buf[0] > 'F')
	 && (rs->buf[0] < 'a' || rs->buf[0] > 'f')
	 && rs->buf[0] != 'x')	/* New: unavailable register value.  */
    {
      if (remote_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "Bad register packet; fetching a new packet\n");
      getpkt (&rs->buf, &rs->buf_size, 0);
    }

  buf_len = strlen (rs->buf);

  /* Sanity check the received packet.  */
  if (buf_len % 2 != 0)
    error (_("Remote 'g' packet reply is of odd length: %s"), rs->buf);

  return buf_len / 2;
}

static void
process_g_packet (struct regcache *regcache)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct remote_state *rs = get_remote_state ();
  struct remote_arch_state *rsa = get_remote_arch_state ();
  int i, buf_len;
  char *p;
  char *regs;

  buf_len = strlen (rs->buf);

  /* Further sanity checks, with knowledge of the architecture.  */
  if (buf_len > 2 * rsa->sizeof_g_packet)
    error (_("Remote 'g' packet reply is too long: %s"), rs->buf);

  /* Save the size of the packet sent to us by the target.  It is used
     as a heuristic when determining the max size of packets that the
     target can safely receive.  */
  if (rsa->actual_register_packet_size == 0)
    rsa->actual_register_packet_size = buf_len;

  /* If this is smaller than we guessed the 'g' packet would be,
     update our records.  A 'g' reply that doesn't include a register's
     value implies either that the register is not available, or that
     the 'p' packet must be used.  */
  if (buf_len < 2 * rsa->sizeof_g_packet)
    {
      rsa->sizeof_g_packet = buf_len / 2;

      for (i = 0; i < gdbarch_num_regs (gdbarch); i++)
	{
	  if (rsa->regs[i].pnum == -1)
	    continue;

	  if (rsa->regs[i].offset >= rsa->sizeof_g_packet)
	    rsa->regs[i].in_g_packet = 0;
	  else
	    rsa->regs[i].in_g_packet = 1;
	}
    }

  regs = alloca (rsa->sizeof_g_packet);

  /* Unimplemented registers read as all bits zero.  */
  memset (regs, 0, rsa->sizeof_g_packet);

  /* Reply describes registers byte by byte, each byte encoded as two
     hex characters.  Suck them all up, then supply them to the
     register cacheing/storage mechanism.  */

  p = rs->buf;
  for (i = 0; i < rsa->sizeof_g_packet; i++)
    {
      if (p[0] == 0 || p[1] == 0)
	/* This shouldn't happen - we adjusted sizeof_g_packet above.  */
	internal_error (__FILE__, __LINE__,
			_("unexpected end of 'g' packet reply"));

      if (p[0] == 'x' && p[1] == 'x')
	regs[i] = 0;		/* 'x' */
      else
	regs[i] = fromhex (p[0]) * 16 + fromhex (p[1]);
      p += 2;
    }

  for (i = 0; i < gdbarch_num_regs (gdbarch); i++)
    {
      struct packet_reg *r = &rsa->regs[i];

      if (r->in_g_packet)
	{
	  if (r->offset * 2 >= strlen (rs->buf))
	    /* This shouldn't happen - we adjusted in_g_packet above.  */
	    internal_error (__FILE__, __LINE__,
			    _("unexpected end of 'g' packet reply"));
	  else if (rs->buf[r->offset * 2] == 'x')
	    {
	      gdb_assert (r->offset * 2 < strlen (rs->buf));
	      /* The register isn't available, mark it as such (at
		 the same time setting the value to zero).  */
	      regcache_raw_supply (regcache, r->regnum, NULL);
	    }
	  else
	    regcache_raw_supply (regcache, r->regnum,
				 regs + r->offset);
	}
    }
}

static void
fetch_registers_using_g (struct regcache *regcache)
{
  send_g_packet ();
  process_g_packet (regcache);
}

/* Make the remote selected traceframe match GDB's selected
   traceframe.  */

static void
set_remote_traceframe (void)
{
  int newnum;
  struct remote_state *rs = get_remote_state ();

  if (rs->remote_traceframe_number == get_traceframe_number ())
    return;

  /* Avoid recursion, remote_trace_find calls us again.  */
  rs->remote_traceframe_number = get_traceframe_number ();

  newnum = target_trace_find (tfind_number,
			      get_traceframe_number (), 0, 0, NULL);

  /* Should not happen.  If it does, all bets are off.  */
  if (newnum != get_traceframe_number ())
    warning (_("could not set remote traceframe"));
}

static void
remote_fetch_registers (struct target_ops *ops,
			struct regcache *regcache, int regnum)
{
  struct remote_arch_state *rsa = get_remote_arch_state ();
  int i;

  set_remote_traceframe ();
  set_general_thread (inferior_ptid);

  if (regnum >= 0)
    {
      struct packet_reg *reg = packet_reg_from_regnum (rsa, regnum);

      gdb_assert (reg != NULL);

      /* If this register might be in the 'g' packet, try that first -
	 we are likely to read more than one register.  If this is the
	 first 'g' packet, we might be overly optimistic about its
	 contents, so fall back to 'p'.  */
      if (reg->in_g_packet)
	{
	  fetch_registers_using_g (regcache);
	  if (reg->in_g_packet)
	    return;
	}

      if (fetch_register_using_p (regcache, reg))
	return;

      /* This register is not available.  */
      regcache_raw_supply (regcache, reg->regnum, NULL);

      return;
    }

  fetch_registers_using_g (regcache);

  for (i = 0; i < gdbarch_num_regs (get_regcache_arch (regcache)); i++)
    if (!rsa->regs[i].in_g_packet)
      if (!fetch_register_using_p (regcache, &rsa->regs[i]))
	{
	  /* This register is not available.  */
	  regcache_raw_supply (regcache, i, NULL);
	}
}

/* Prepare to store registers.  Since we may send them all (using a
   'G' request), we have to read out the ones we don't want to change
   first.  */

static void
remote_prepare_to_store (struct regcache *regcache)
{
  struct remote_arch_state *rsa = get_remote_arch_state ();
  int i;
  gdb_byte buf[MAX_REGISTER_SIZE];

  /* Make sure the entire registers array is valid.  */
  switch (remote_protocol_packets[PACKET_P].support)
    {
    case PACKET_DISABLE:
    case PACKET_SUPPORT_UNKNOWN:
      /* Make sure all the necessary registers are cached.  */
      for (i = 0; i < gdbarch_num_regs (get_regcache_arch (regcache)); i++)
	if (rsa->regs[i].in_g_packet)
	  regcache_raw_read (regcache, rsa->regs[i].regnum, buf);
      break;
    case PACKET_ENABLE:
      break;
    }
}

/* Helper: Attempt to store REGNUM using the P packet.  Return fail IFF
   packet was not recognized.  */

static int
store_register_using_P (const struct regcache *regcache, 
			struct packet_reg *reg)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct remote_state *rs = get_remote_state ();
  /* Try storing a single register.  */
  char *buf = rs->buf;
  gdb_byte regp[MAX_REGISTER_SIZE];
  char *p;

  if (remote_protocol_packets[PACKET_P].support == PACKET_DISABLE)
    return 0;

  if (reg->pnum == -1)
    return 0;

  xsnprintf (buf, get_remote_packet_size (), "P%s=", phex_nz (reg->pnum, 0));
  p = buf + strlen (buf);
  regcache_raw_collect (regcache, reg->regnum, regp);
  bin2hex (regp, p, register_size (gdbarch, reg->regnum));
  putpkt (rs->buf);
  getpkt (&rs->buf, &rs->buf_size, 0);

  switch (packet_ok (rs->buf, &remote_protocol_packets[PACKET_P]))
    {
    case PACKET_OK:
      return 1;
    case PACKET_ERROR:
      error (_("Could not write register \"%s\"; remote failure reply '%s'"),
	     gdbarch_register_name (gdbarch, reg->regnum), rs->buf);
    case PACKET_UNKNOWN:
      return 0;
    default:
      internal_error (__FILE__, __LINE__, _("Bad result from packet_ok"));
    }
}

/* Store register REGNUM, or all registers if REGNUM == -1, from the
   contents of the register cache buffer.  FIXME: ignores errors.  */

static void
store_registers_using_G (const struct regcache *regcache)
{
  struct remote_state *rs = get_remote_state ();
  struct remote_arch_state *rsa = get_remote_arch_state ();
  gdb_byte *regs;
  char *p;

  /* Extract all the registers in the regcache copying them into a
     local buffer.  */
  {
    int i;

    regs = alloca (rsa->sizeof_g_packet);
    memset (regs, 0, rsa->sizeof_g_packet);
    for (i = 0; i < gdbarch_num_regs (get_regcache_arch (regcache)); i++)
      {
	struct packet_reg *r = &rsa->regs[i];

	if (r->in_g_packet)
	  regcache_raw_collect (regcache, r->regnum, regs + r->offset);
      }
  }

  /* Command describes registers byte by byte,
     each byte encoded as two hex characters.  */
  p = rs->buf;
  *p++ = 'G';
  /* remote_prepare_to_store insures that rsa->sizeof_g_packet gets
     updated.  */
  bin2hex (regs, p, rsa->sizeof_g_packet);
  putpkt (rs->buf);
  getpkt (&rs->buf, &rs->buf_size, 0);
  if (packet_check_result (rs->buf) == PACKET_ERROR)
    error (_("Could not write registers; remote failure reply '%s'"), 
	   rs->buf);
}

/* Store register REGNUM, or all registers if REGNUM == -1, from the contents
   of the register cache buffer.  FIXME: ignores errors.  */

static void
remote_store_registers (struct target_ops *ops,
			struct regcache *regcache, int regnum)
{
  struct remote_arch_state *rsa = get_remote_arch_state ();
  int i;

  set_remote_traceframe ();
  set_general_thread (inferior_ptid);

  if (regnum >= 0)
    {
      struct packet_reg *reg = packet_reg_from_regnum (rsa, regnum);

      gdb_assert (reg != NULL);

      /* Always prefer to store registers using the 'P' packet if
	 possible; we often change only a small number of registers.
	 Sometimes we change a larger number; we'd need help from a
	 higher layer to know to use 'G'.  */
      if (store_register_using_P (regcache, reg))
	return;

      /* For now, don't complain if we have no way to write the
	 register.  GDB loses track of unavailable registers too
	 easily.  Some day, this may be an error.  We don't have
	 any way to read the register, either...  */
      if (!reg->in_g_packet)
	return;

      store_registers_using_G (regcache);
      return;
    }

  store_registers_using_G (regcache);

  for (i = 0; i < gdbarch_num_regs (get_regcache_arch (regcache)); i++)
    if (!rsa->regs[i].in_g_packet)
      if (!store_register_using_P (regcache, &rsa->regs[i]))
	/* See above for why we do not issue an error here.  */
	continue;
}


/* Return the number of hex digits in num.  */

static int
hexnumlen (ULONGEST num)
{
  int i;

  for (i = 0; num != 0; i++)
    num >>= 4;

  return max (i, 1);
}

/* Set BUF to the minimum number of hex digits representing NUM.  */

static int
hexnumstr (char *buf, ULONGEST num)
{
  int len = hexnumlen (num);

  return hexnumnstr (buf, num, len);
}


/* Set BUF to the hex digits representing NUM, padded to WIDTH characters.  */

static int
hexnumnstr (char *buf, ULONGEST num, int width)
{
  int i;

  buf[width] = '\0';

  for (i = width - 1; i >= 0; i--)
    {
      buf[i] = "0123456789abcdef"[(num & 0xf)];
      num >>= 4;
    }

  return width;
}

/* Mask all but the least significant REMOTE_ADDRESS_SIZE bits.  */

static CORE_ADDR
remote_address_masked (CORE_ADDR addr)
{
  unsigned int address_size = remote_address_size;

  /* If "remoteaddresssize" was not set, default to target address size.  */
  if (!address_size)
    address_size = gdbarch_addr_bit (target_gdbarch ());

  if (address_size > 0
      && address_size < (sizeof (ULONGEST) * 8))
    {
      /* Only create a mask when that mask can safely be constructed
         in a ULONGEST variable.  */
      ULONGEST mask = 1;

      mask = (mask << address_size) - 1;
      addr &= mask;
    }
  return addr;
}

/* Convert BUFFER, binary data at least LEN bytes long, into escaped
   binary data in OUT_BUF.  Set *OUT_LEN to the length of the data
   encoded in OUT_BUF, and return the number of bytes in OUT_BUF
   (which may be more than *OUT_LEN due to escape characters).  The
   total number of bytes in the output buffer will be at most
   OUT_MAXLEN.  */

static int
remote_escape_output (const gdb_byte *buffer, int len,
		      gdb_byte *out_buf, int *out_len,
		      int out_maxlen)
{
  int input_index, output_index;

  output_index = 0;
  for (input_index = 0; input_index < len; input_index++)
    {
      gdb_byte b = buffer[input_index];

      if (b == '$' || b == '#' || b == '}')
	{
	  /* These must be escaped.  */
	  if (output_index + 2 > out_maxlen)
	    break;
	  out_buf[output_index++] = '}';
	  out_buf[output_index++] = b ^ 0x20;
	}
      else
	{
	  if (output_index + 1 > out_maxlen)
	    break;
	  out_buf[output_index++] = b;
	}
    }

  *out_len = input_index;
  return output_index;
}

/* Convert BUFFER, escaped data LEN bytes long, into binary data
   in OUT_BUF.  Return the number of bytes written to OUT_BUF.
   Raise an error if the total number of bytes exceeds OUT_MAXLEN.

   This function reverses remote_escape_output.  It allows more
   escaped characters than that function does, in particular because
   '*' must be escaped to avoid the run-length encoding processing
   in reading packets.  */

static int
remote_unescape_input (const gdb_byte *buffer, int len,
		       gdb_byte *out_buf, int out_maxlen)
{
  int input_index, output_index;
  int escaped;

  output_index = 0;
  escaped = 0;
  for (input_index = 0; input_index < len; input_index++)
    {
      gdb_byte b = buffer[input_index];

      if (output_index + 1 > out_maxlen)
	{
	  warning (_("Received too much data from remote target;"
		     " ignoring overflow."));
	  return output_index;
	}

      if (escaped)
	{
	  out_buf[output_index++] = b ^ 0x20;
	  escaped = 0;
	}
      else if (b == '}')
	escaped = 1;
      else
	out_buf[output_index++] = b;
    }

  if (escaped)
    error (_("Unmatched escape character in target response."));

  return output_index;
}

/* Determine whether the remote target supports binary downloading.
   This is accomplished by sending a no-op memory write of zero length
   to the target at the specified address. It does not suffice to send
   the whole packet, since many stubs strip the eighth bit and
   subsequently compute a wrong checksum, which causes real havoc with
   remote_write_bytes.

   NOTE: This can still lose if the serial line is not eight-bit
   clean.  In cases like this, the user should clear "remote
   X-packet".  */

static void
check_binary_download (CORE_ADDR addr)
{
  struct remote_state *rs = get_remote_state ();

  switch (remote_protocol_packets[PACKET_X].support)
    {
    case PACKET_DISABLE:
      break;
    case PACKET_ENABLE:
      break;
    case PACKET_SUPPORT_UNKNOWN:
      {
	char *p;

	p = rs->buf;
	*p++ = 'X';
	p += hexnumstr (p, (ULONGEST) addr);
	*p++ = ',';
	p += hexnumstr (p, (ULONGEST) 0);
	*p++ = ':';
	*p = '\0';

	putpkt_binary (rs->buf, (int) (p - rs->buf));
	getpkt (&rs->buf, &rs->buf_size, 0);

	if (rs->buf[0] == '\0')
	  {
	    if (remote_debug)
	      fprintf_unfiltered (gdb_stdlog,
				  "binary downloading NOT "
				  "supported by target\n");
	    remote_protocol_packets[PACKET_X].support = PACKET_DISABLE;
	  }
	else
	  {
	    if (remote_debug)
	      fprintf_unfiltered (gdb_stdlog,
				  "binary downloading supported by target\n");
	    remote_protocol_packets[PACKET_X].support = PACKET_ENABLE;
	  }
	break;
      }
    }
}

/* Write memory data directly to the remote machine.
   This does not inform the data cache; the data cache uses this.
   HEADER is the starting part of the packet.
   MEMADDR is the address in the remote memory space.
   MYADDR is the address of the buffer in our space.
   LEN is the number of bytes.
   PACKET_FORMAT should be either 'X' or 'M', and indicates if we
   should send data as binary ('X'), or hex-encoded ('M').

   The function creates packet of the form
       <HEADER><ADDRESS>,<LENGTH>:<DATA>

   where encoding of <DATA> is termined by PACKET_FORMAT.

   If USE_LENGTH is 0, then the <LENGTH> field and the preceding comma
   are omitted.

   Returns the number of bytes transferred, or a negative value (an
   'enum target_xfer_error' value) for error.  Only transfer a single
   packet.  */

static LONGEST
remote_write_bytes_aux (const char *header, CORE_ADDR memaddr,
			const gdb_byte *myaddr, ssize_t len,
			char packet_format, int use_length)
{
  struct remote_state *rs = get_remote_state ();
  char *p;
  char *plen = NULL;
  int plenlen = 0;
  int todo;
  int nr_bytes;
  int payload_size;
  int payload_length;
  int header_length;

  if (packet_format != 'X' && packet_format != 'M')
    internal_error (__FILE__, __LINE__,
		    _("remote_write_bytes_aux: bad packet format"));

  if (len <= 0)
    return 0;

  payload_size = get_memory_write_packet_size ();

  /* The packet buffer will be large enough for the payload;
     get_memory_packet_size ensures this.  */
  rs->buf[0] = '\0';

  /* Compute the size of the actual payload by subtracting out the
     packet header and footer overhead: "$M<memaddr>,<len>:...#nn".  */

  payload_size -= strlen ("$,:#NN");
  if (!use_length)
    /* The comma won't be used.  */
    payload_size += 1;
  header_length = strlen (header);
  payload_size -= header_length;
  payload_size -= hexnumlen (memaddr);

  /* Construct the packet excluding the data: "<header><memaddr>,<len>:".  */

  strcat (rs->buf, header);
  p = rs->buf + strlen (header);

  /* Compute a best guess of the number of bytes actually transfered.  */
  if (packet_format == 'X')
    {
      /* Best guess at number of bytes that will fit.  */
      todo = min (len, payload_size);
      if (use_length)
	payload_size -= hexnumlen (todo);
      todo = min (todo, payload_size);
    }
  else
    {
      /* Num bytes that will fit.  */
      todo = min (len, payload_size / 2);
      if (use_length)
	payload_size -= hexnumlen (todo);
      todo = min (todo, payload_size / 2);
    }

  if (todo <= 0)
    internal_error (__FILE__, __LINE__,
		    _("minimum packet size too small to write data"));

  /* If we already need another packet, then try to align the end
     of this packet to a useful boundary.  */
  if (todo > 2 * REMOTE_ALIGN_WRITES && todo < len)
    todo = ((memaddr + todo) & ~(REMOTE_ALIGN_WRITES - 1)) - memaddr;

  /* Append "<memaddr>".  */
  memaddr = remote_address_masked (memaddr);
  p += hexnumstr (p, (ULONGEST) memaddr);

  if (use_length)
    {
      /* Append ",".  */
      *p++ = ',';

      /* Append <len>.  Retain the location/size of <len>.  It may need to
	 be adjusted once the packet body has been created.  */
      plen = p;
      plenlen = hexnumstr (p, (ULONGEST) todo);
      p += plenlen;
    }

  /* Append ":".  */
  *p++ = ':';
  *p = '\0';

  /* Append the packet body.  */
  if (packet_format == 'X')
    {
      /* Binary mode.  Send target system values byte by byte, in
	 increasing byte addresses.  Only escape certain critical
	 characters.  */
      payload_length = remote_escape_output (myaddr, todo, (gdb_byte *) p,
					     &nr_bytes, payload_size);

      /* If not all TODO bytes fit, then we'll need another packet.  Make
	 a second try to keep the end of the packet aligned.  Don't do
	 this if the packet is tiny.  */
      if (nr_bytes < todo && nr_bytes > 2 * REMOTE_ALIGN_WRITES)
	{
	  int new_nr_bytes;

	  new_nr_bytes = (((memaddr + nr_bytes) & ~(REMOTE_ALIGN_WRITES - 1))
			  - memaddr);
	  if (new_nr_bytes != nr_bytes)
	    payload_length = remote_escape_output (myaddr, new_nr_bytes,
						   (gdb_byte *) p, &nr_bytes,
						   payload_size);
	}

      p += payload_length;
      if (use_length && nr_bytes < todo)
	{
	  /* Escape chars have filled up the buffer prematurely,
	     and we have actually sent fewer bytes than planned.
	     Fix-up the length field of the packet.  Use the same
	     number of characters as before.  */
	  plen += hexnumnstr (plen, (ULONGEST) nr_bytes, plenlen);
	  *plen = ':';  /* overwrite \0 from hexnumnstr() */
	}
    }
  else
    {
      /* Normal mode: Send target system values byte by byte, in
	 increasing byte addresses.  Each byte is encoded as a two hex
	 value.  */
      nr_bytes = bin2hex (myaddr, p, todo);
      p += 2 * nr_bytes;
    }

  putpkt_binary (rs->buf, (int) (p - rs->buf));
  getpkt (&rs->buf, &rs->buf_size, 0);

  if (rs->buf[0] == 'E')
    return TARGET_XFER_E_IO;

  /* Return NR_BYTES, not TODO, in case escape chars caused us to send
     fewer bytes than we'd planned.  */
  return nr_bytes;
}

/* Write memory data directly to the remote machine.
   This does not inform the data cache; the data cache uses this.
   MEMADDR is the address in the remote memory space.
   MYADDR is the address of the buffer in our space.
   LEN is the number of bytes.

   Returns number of bytes transferred, or a negative value (an 'enum
   target_xfer_error' value) for error.  Only transfer a single
   packet.  */

static LONGEST
remote_write_bytes (CORE_ADDR memaddr, const gdb_byte *myaddr, ssize_t len)
{
  char *packet_format = 0;

  /* Check whether the target supports binary download.  */
  check_binary_download (memaddr);

  switch (remote_protocol_packets[PACKET_X].support)
    {
    case PACKET_ENABLE:
      packet_format = "X";
      break;
    case PACKET_DISABLE:
      packet_format = "M";
      break;
    case PACKET_SUPPORT_UNKNOWN:
      internal_error (__FILE__, __LINE__,
		      _("remote_write_bytes: bad internal state"));
    default:
      internal_error (__FILE__, __LINE__, _("bad switch"));
    }

  return remote_write_bytes_aux (packet_format,
				 memaddr, myaddr, len, packet_format[0], 1);
}

/* Read memory data directly from the remote machine.
   This does not use the data cache; the data cache uses this.
   MEMADDR is the address in the remote memory space.
   MYADDR is the address of the buffer in our space.
   LEN is the number of bytes.

   Returns number of bytes transferred, or a negative value (an 'enum
   target_xfer_error' value) for error.  */

static LONGEST
remote_read_bytes (CORE_ADDR memaddr, gdb_byte *myaddr, int len)
{
  struct remote_state *rs = get_remote_state ();
  int max_buf_size;		/* Max size of packet output buffer.  */
  char *p;
  int todo;
  int i;

  if (len <= 0)
    return 0;

  max_buf_size = get_memory_read_packet_size ();
  /* The packet buffer will be large enough for the payload;
     get_memory_packet_size ensures this.  */

  /* Number if bytes that will fit.  */
  todo = min (len, max_buf_size / 2);

  /* Construct "m"<memaddr>","<len>".  */
  memaddr = remote_address_masked (memaddr);
  p = rs->buf;
  *p++ = 'm';
  p += hexnumstr (p, (ULONGEST) memaddr);
  *p++ = ',';
  p += hexnumstr (p, (ULONGEST) todo);
  *p = '\0';
  putpkt (rs->buf);
  getpkt (&rs->buf, &rs->buf_size, 0);
  if (rs->buf[0] == 'E'
      && isxdigit (rs->buf[1]) && isxdigit (rs->buf[2])
      && rs->buf[3] == '\0')
    return TARGET_XFER_E_IO;
  /* Reply describes memory byte by byte, each byte encoded as two hex
     characters.  */
  p = rs->buf;
  i = hex2bin (p, myaddr, todo);
  /* Return what we have.  Let higher layers handle partial reads.  */
  return i;
}



/* Sends a packet with content determined by the printf format string
   FORMAT and the remaining arguments, then gets the reply.  Returns
   whether the packet was a success, a failure, or unknown.  */

static enum packet_result
remote_send_printf (const char *format, ...)
{
  struct remote_state *rs = get_remote_state ();
  int max_size = get_remote_packet_size ();
  va_list ap;

  va_start (ap, format);

  rs->buf[0] = '\0';
  if (vsnprintf (rs->buf, max_size, format, ap) >= max_size)
    internal_error (__FILE__, __LINE__, _("Too long remote packet."));

  if (putpkt (rs->buf) < 0)
    error (_("Communication problem with target."));

  rs->buf[0] = '\0';
  getpkt (&rs->buf, &rs->buf_size, 0);

  return packet_check_result (rs->buf);
}

static void
restore_remote_timeout (void *p)
{
  int value = *(int *)p;

  remote_timeout = value;
}

/* Flash writing can take quite some time.  We'll set
   effectively infinite timeout for flash operations.
   In future, we'll need to decide on a better approach.  */
static const int remote_flash_timeout = 1000;

static void
remote_flash_erase (struct target_ops *ops,
                    ULONGEST address, LONGEST length)
{
  int addr_size = gdbarch_addr_bit (target_gdbarch ()) / 8;
  int saved_remote_timeout = remote_timeout;
  enum packet_result ret;
  struct cleanup *back_to = make_cleanup (restore_remote_timeout,
                                          &saved_remote_timeout);

  remote_timeout = remote_flash_timeout;

  ret = remote_send_printf ("vFlashErase:%s,%s",
			    phex (address, addr_size),
			    phex (length, 4));
  switch (ret)
    {
    case PACKET_UNKNOWN:
      error (_("Remote target does not support flash erase"));
    case PACKET_ERROR:
      error (_("Error erasing flash with vFlashErase packet"));
    default:
      break;
    }

  do_cleanups (back_to);
}

static LONGEST
remote_flash_write (struct target_ops *ops,
                    ULONGEST address, LONGEST length,
                    const gdb_byte *data)
{
  int saved_remote_timeout = remote_timeout;
  LONGEST ret;
  struct cleanup *back_to = make_cleanup (restore_remote_timeout,
                                          &saved_remote_timeout);

  remote_timeout = remote_flash_timeout;
  ret = remote_write_bytes_aux ("vFlashWrite:", address, data, length, 'X', 0);
  do_cleanups (back_to);

  return ret;
}

static void
remote_flash_done (struct target_ops *ops)
{
  int saved_remote_timeout = remote_timeout;
  int ret;
  struct cleanup *back_to = make_cleanup (restore_remote_timeout,
                                          &saved_remote_timeout);

  remote_timeout = remote_flash_timeout;
  ret = remote_send_printf ("vFlashDone");
  do_cleanups (back_to);

  switch (ret)
    {
    case PACKET_UNKNOWN:
      error (_("Remote target does not support vFlashDone"));
    case PACKET_ERROR:
      error (_("Error finishing flash operation"));
    default:
      break;
    }
}

static void
remote_files_info (struct target_ops *ignore)
{
  puts_filtered ("Debugging a target over a serial line.\n");
}

/* Stuff for dealing with the packets which are part of this protocol.
   See comment at top of file for details.  */

/* Close/unpush the remote target, and throw a TARGET_CLOSE_ERROR
   error to higher layers.  Called when a serial error is detected.
   The exception message is STRING, followed by a colon and a blank,
   the system error message for errno at function entry and final dot
   for output compatibility with throw_perror_with_name.  */

static void
unpush_and_perror (const char *string)
{
  int saved_errno = errno;

  remote_unpush_target ();
  throw_error (TARGET_CLOSE_ERROR, "%s: %s.", string,
	       safe_strerror (saved_errno));
}

/* Read a single character from the remote end.  */

static int
readchar (int timeout)
{
  int ch;
  struct remote_state *rs = get_remote_state ();

  ch = serial_readchar (rs->remote_desc, timeout);

  if (ch >= 0)
    return ch;

  switch ((enum serial_rc) ch)
    {
    case SERIAL_EOF:
      remote_unpush_target ();
      throw_error (TARGET_CLOSE_ERROR, _("Remote connection closed"));
      /* no return */
    case SERIAL_ERROR:
      unpush_and_perror (_("Remote communication error.  "
			   "Target disconnected."));
      /* no return */
    case SERIAL_TIMEOUT:
      break;
    }
  return ch;
}

/* Wrapper for serial_write that closes the target and throws if
   writing fails.  */

static void
remote_serial_write (const char *str, int len)
{
  struct remote_state *rs = get_remote_state ();

  if (serial_write (rs->remote_desc, str, len))
    {
      unpush_and_perror (_("Remote communication error.  "
			   "Target disconnected."));
    }
}

/* Send the command in *BUF to the remote machine, and read the reply
   into *BUF.  Report an error if we get an error reply.  Resize
   *BUF using xrealloc if necessary to hold the result, and update
   *SIZEOF_BUF.  */

static void
remote_send (char **buf,
	     long *sizeof_buf)
{
  putpkt (*buf);
  getpkt (buf, sizeof_buf, 0);

  if ((*buf)[0] == 'E')
    error (_("Remote failure reply: %s"), *buf);
}

/* Return a pointer to an xmalloc'ed string representing an escaped
   version of BUF, of len N.  E.g. \n is converted to \\n, \t to \\t,
   etc.  The caller is responsible for releasing the returned
   memory.  */

static char *
escape_buffer (const char *buf, int n)
{
  struct cleanup *old_chain;
  struct ui_file *stb;
  char *str;

  stb = mem_fileopen ();
  old_chain = make_cleanup_ui_file_delete (stb);

  fputstrn_unfiltered (buf, n, 0, stb);
  str = ui_file_xstrdup (stb, NULL);
  do_cleanups (old_chain);
  return str;
}

/* Display a null-terminated packet on stdout, for debugging, using C
   string notation.  */

static void
print_packet (char *buf)
{
  puts_filtered ("\"");
  fputstr_filtered (buf, '"', gdb_stdout);
  puts_filtered ("\"");
}

int
putpkt (char *buf)
{
  return putpkt_binary (buf, strlen (buf));
}

/* Send a packet to the remote machine, with error checking.  The data
   of the packet is in BUF.  The string in BUF can be at most
   get_remote_packet_size () - 5 to account for the $, # and checksum,
   and for a possible /0 if we are debugging (remote_debug) and want
   to print the sent packet as a string.  */

static int
putpkt_binary (char *buf, int cnt)
{
  struct remote_state *rs = get_remote_state ();
  int i;
  unsigned char csum = 0;
  char *buf2 = alloca (cnt + 6);

  int ch;
  int tcount = 0;
  char *p;
  char *message;

  /* Catch cases like trying to read memory or listing threads while
     we're waiting for a stop reply.  The remote server wouldn't be
     ready to handle this request, so we'd hang and timeout.  We don't
     have to worry about this in synchronous mode, because in that
     case it's not possible to issue a command while the target is
     running.  This is not a problem in non-stop mode, because in that
     case, the stub is always ready to process serial input.  */
  if (!non_stop && target_can_async_p () && rs->waiting_for_stop_reply)
    error (_("Cannot execute this command while the target is running."));

  /* We're sending out a new packet.  Make sure we don't look at a
     stale cached response.  */
  rs->cached_wait_status = 0;

  /* Copy the packet into buffer BUF2, encapsulating it
     and giving it a checksum.  */

  p = buf2;
  *p++ = '$';

  for (i = 0; i < cnt; i++)
    {
      csum += buf[i];
      *p++ = buf[i];
    }
  *p++ = '#';
  *p++ = tohex ((csum >> 4) & 0xf);
  *p++ = tohex (csum & 0xf);

  /* Send it over and over until we get a positive ack.  */

  while (1)
    {
      int started_error_output = 0;

      if (remote_debug)
	{
	  struct cleanup *old_chain;
	  char *str;

	  *p = '\0';
	  str = escape_buffer (buf2, p - buf2);
	  old_chain = make_cleanup (xfree, str);
	  fprintf_unfiltered (gdb_stdlog, "Sending packet: %s...", str);
	  gdb_flush (gdb_stdlog);
	  do_cleanups (old_chain);
	}
      remote_serial_write (buf2, p - buf2);

      /* If this is a no acks version of the remote protocol, send the
	 packet and move on.  */
      if (rs->noack_mode)
        break;

      /* Read until either a timeout occurs (-2) or '+' is read.
	 Handle any notification that arrives in the mean time.  */
      while (1)
	{
	  ch = readchar (remote_timeout);

	  if (remote_debug)
	    {
	      switch (ch)
		{
		case '+':
		case '-':
		case SERIAL_TIMEOUT:
		case '$':
		case '%':
		  if (started_error_output)
		    {
		      putchar_unfiltered ('\n');
		      started_error_output = 0;
		    }
		}
	    }

	  switch (ch)
	    {
	    case '+':
	      if (remote_debug)
		fprintf_unfiltered (gdb_stdlog, "Ack\n");
	      return 1;
	    case '-':
	      if (remote_debug)
		fprintf_unfiltered (gdb_stdlog, "Nak\n");
	      /* FALLTHROUGH */
	    case SERIAL_TIMEOUT:
	      tcount++;
	      if (tcount > 3)
		return 0;
	      break;		/* Retransmit buffer.  */
	    case '$':
	      {
	        if (remote_debug)
		  fprintf_unfiltered (gdb_stdlog,
				      "Packet instead of Ack, ignoring it\n");
		/* It's probably an old response sent because an ACK
		   was lost.  Gobble up the packet and ack it so it
		   doesn't get retransmitted when we resend this
		   packet.  */
		skip_frame ();
		remote_serial_write ("+", 1);
		continue;	/* Now, go look for +.  */
	      }

	    case '%':
	      {
		int val;

		/* If we got a notification, handle it, and go back to looking
		   for an ack.  */
		/* We've found the start of a notification.  Now
		   collect the data.  */
		val = read_frame (&rs->buf, &rs->buf_size);
		if (val >= 0)
		  {
		    if (remote_debug)
		      {
			struct cleanup *old_chain;
			char *str;

			str = escape_buffer (rs->buf, val);
			old_chain = make_cleanup (xfree, str);
			fprintf_unfiltered (gdb_stdlog,
					    "  Notification received: %s\n",
					    str);
			do_cleanups (old_chain);
		      }
		    handle_notification (rs->notif_state, rs->buf);
		    /* We're in sync now, rewait for the ack.  */
		    tcount = 0;
		  }
		else
		  {
		    if (remote_debug)
		      {
			if (!started_error_output)
			  {
			    started_error_output = 1;
			    fprintf_unfiltered (gdb_stdlog, "putpkt: Junk: ");
			  }
			fputc_unfiltered (ch & 0177, gdb_stdlog);
			fprintf_unfiltered (gdb_stdlog, "%s", rs->buf);
		      }
		  }
		continue;
	      }
	      /* fall-through */
	    default:
	      if (remote_debug)
		{
		  if (!started_error_output)
		    {
		      started_error_output = 1;
		      fprintf_unfiltered (gdb_stdlog, "putpkt: Junk: ");
		    }
		  fputc_unfiltered (ch & 0177, gdb_stdlog);
		}
	      continue;
	    }
	  break;		/* Here to retransmit.  */
	}

#if 0
      /* This is wrong.  If doing a long backtrace, the user should be
         able to get out next time we call QUIT, without anything as
         violent as interrupt_query.  If we want to provide a way out of
         here without getting to the next QUIT, it should be based on
         hitting ^C twice as in remote_wait.  */
      if (quit_flag)
	{
	  quit_flag = 0;
	  interrupt_query ();
	}
#endif
    }
  return 0;
}

/* Come here after finding the start of a frame when we expected an
   ack.  Do our best to discard the rest of this packet.  */

static void
skip_frame (void)
{
  int c;

  while (1)
    {
      c = readchar (remote_timeout);
      switch (c)
	{
	case SERIAL_TIMEOUT:
	  /* Nothing we can do.  */
	  return;
	case '#':
	  /* Discard the two bytes of checksum and stop.  */
	  c = readchar (remote_timeout);
	  if (c >= 0)
	    c = readchar (remote_timeout);

	  return;
	case '*':		/* Run length encoding.  */
	  /* Discard the repeat count.  */
	  c = readchar (remote_timeout);
	  if (c < 0)
	    return;
	  break;
	default:
	  /* A regular character.  */
	  break;
	}
    }
}

/* Come here after finding the start of the frame.  Collect the rest
   into *BUF, verifying the checksum, length, and handling run-length
   compression.  NUL terminate the buffer.  If there is not enough room,
   expand *BUF using xrealloc.

   Returns -1 on error, number of characters in buffer (ignoring the
   trailing NULL) on success. (could be extended to return one of the
   SERIAL status indications).  */

static long
read_frame (char **buf_p,
	    long *sizeof_buf)
{
  unsigned char csum;
  long bc;
  int c;
  char *buf = *buf_p;
  struct remote_state *rs = get_remote_state ();

  csum = 0;
  bc = 0;

  while (1)
    {
      c = readchar (remote_timeout);
      switch (c)
	{
	case SERIAL_TIMEOUT:
	  if (remote_debug)
	    fputs_filtered ("Timeout in mid-packet, retrying\n", gdb_stdlog);
	  return -1;
	case '$':
	  if (remote_debug)
	    fputs_filtered ("Saw new packet start in middle of old one\n",
			    gdb_stdlog);
	  return -1;		/* Start a new packet, count retries.  */
	case '#':
	  {
	    unsigned char pktcsum;
	    int check_0 = 0;
	    int check_1 = 0;

	    buf[bc] = '\0';

	    check_0 = readchar (remote_timeout);
	    if (check_0 >= 0)
	      check_1 = readchar (remote_timeout);

	    if (check_0 == SERIAL_TIMEOUT || check_1 == SERIAL_TIMEOUT)
	      {
		if (remote_debug)
		  fputs_filtered ("Timeout in checksum, retrying\n",
				  gdb_stdlog);
		return -1;
	      }
	    else if (check_0 < 0 || check_1 < 0)
	      {
		if (remote_debug)
		  fputs_filtered ("Communication error in checksum\n",
				  gdb_stdlog);
		return -1;
	      }

	    /* Don't recompute the checksum; with no ack packets we
	       don't have any way to indicate a packet retransmission
	       is necessary.  */
	    if (rs->noack_mode)
	      return bc;

	    pktcsum = (fromhex (check_0) << 4) | fromhex (check_1);
	    if (csum == pktcsum)
              return bc;

	    if (remote_debug)
	      {
		struct cleanup *old_chain;
		char *str;

		str = escape_buffer (buf, bc);
		old_chain = make_cleanup (xfree, str);
		fprintf_unfiltered (gdb_stdlog,
				    "Bad checksum, sentsum=0x%x, "
				    "csum=0x%x, buf=%s\n",
				    pktcsum, csum, str);
		do_cleanups (old_chain);
	      }
	    /* Number of characters in buffer ignoring trailing
               NULL.  */
	    return -1;
	  }
	case '*':		/* Run length encoding.  */
          {
	    int repeat;

 	    csum += c;
	    c = readchar (remote_timeout);
	    csum += c;
	    repeat = c - ' ' + 3;	/* Compute repeat count.  */

	    /* The character before ``*'' is repeated.  */

	    if (repeat > 0 && repeat <= 255 && bc > 0)
	      {
		if (bc + repeat - 1 >= *sizeof_buf - 1)
		  {
		    /* Make some more room in the buffer.  */
		    *sizeof_buf += repeat;
		    *buf_p = xrealloc (*buf_p, *sizeof_buf);
		    buf = *buf_p;
		  }

		memset (&buf[bc], buf[bc - 1], repeat);
		bc += repeat;
		continue;
	      }

	    buf[bc] = '\0';
	    printf_filtered (_("Invalid run length encoding: %s\n"), buf);
	    return -1;
	  }
	default:
	  if (bc >= *sizeof_buf - 1)
	    {
	      /* Make some more room in the buffer.  */
	      *sizeof_buf *= 2;
	      *buf_p = xrealloc (*buf_p, *sizeof_buf);
	      buf = *buf_p;
	    }

	  buf[bc++] = c;
	  csum += c;
	  continue;
	}
    }
}

/* Read a packet from the remote machine, with error checking, and
   store it in *BUF.  Resize *BUF using xrealloc if necessary to hold
   the result, and update *SIZEOF_BUF.  If FOREVER, wait forever
   rather than timing out; this is used (in synchronous mode) to wait
   for a target that is is executing user code to stop.  */
/* FIXME: ezannoni 2000-02-01 this wrapper is necessary so that we
   don't have to change all the calls to getpkt to deal with the
   return value, because at the moment I don't know what the right
   thing to do it for those.  */
void
getpkt (char **buf,
	long *sizeof_buf,
	int forever)
{
  int timed_out;

  timed_out = getpkt_sane (buf, sizeof_buf, forever);
}


/* Read a packet from the remote machine, with error checking, and
   store it in *BUF.  Resize *BUF using xrealloc if necessary to hold
   the result, and update *SIZEOF_BUF.  If FOREVER, wait forever
   rather than timing out; this is used (in synchronous mode) to wait
   for a target that is is executing user code to stop.  If FOREVER ==
   0, this function is allowed to time out gracefully and return an
   indication of this to the caller.  Otherwise return the number of
   bytes read.  If EXPECTING_NOTIF, consider receiving a notification
   enough reason to return to the caller.  *IS_NOTIF is an output
   boolean that indicates whether *BUF holds a notification or not
   (a regular packet).  */

static int
getpkt_or_notif_sane_1 (char **buf, long *sizeof_buf, int forever,
			int expecting_notif, int *is_notif)
{
  struct remote_state *rs = get_remote_state ();
  int c;
  int tries;
  int timeout;
  int val = -1;

  /* We're reading a new response.  Make sure we don't look at a
     previously cached response.  */
  rs->cached_wait_status = 0;

  strcpy (*buf, "timeout");

  if (forever)
    timeout = watchdog > 0 ? watchdog : -1;
  else if (expecting_notif)
    timeout = 0; /* There should already be a char in the buffer.  If
		    not, bail out.  */
  else
    timeout = remote_timeout;

#define MAX_TRIES 3

  /* Process any number of notifications, and then return when
     we get a packet.  */
  for (;;)
    {
      /* If we get a timeout or bad checksm, retry up to MAX_TRIES
	 times.  */
      for (tries = 1; tries <= MAX_TRIES; tries++)
	{
	  /* This can loop forever if the remote side sends us
	     characters continuously, but if it pauses, we'll get
	     SERIAL_TIMEOUT from readchar because of timeout.  Then
	     we'll count that as a retry.

	     Note that even when forever is set, we will only wait
	     forever prior to the start of a packet.  After that, we
	     expect characters to arrive at a brisk pace.  They should
	     show up within remote_timeout intervals.  */
	  do
	    c = readchar (timeout);
	  while (c != SERIAL_TIMEOUT && c != '$' && c != '%');

	  if (c == SERIAL_TIMEOUT)
	    {
	      if (expecting_notif)
		return -1; /* Don't complain, it's normal to not get
			      anything in this case.  */

	      if (forever)	/* Watchdog went off?  Kill the target.  */
		{
		  QUIT;
		  remote_unpush_target ();
		  throw_error (TARGET_CLOSE_ERROR,
			       _("Watchdog timeout has expired.  "
				 "Target detached."));
		}
	      if (remote_debug)
		fputs_filtered ("Timed out.\n", gdb_stdlog);
	    }
	  else
	    {
	      /* We've found the start of a packet or notification.
		 Now collect the data.  */
	      val = read_frame (buf, sizeof_buf);
	      if (val >= 0)
		break;
	    }

	  remote_serial_write ("-", 1);
	}

      if (tries > MAX_TRIES)
	{
	  /* We have tried hard enough, and just can't receive the
	     packet/notification.  Give up.  */
	  printf_unfiltered (_("Ignoring packet error, continuing...\n"));

	  /* Skip the ack char if we're in no-ack mode.  */
	  if (!rs->noack_mode)
	    remote_serial_write ("+", 1);
	  return -1;
	}

      /* If we got an ordinary packet, return that to our caller.  */
      if (c == '$')
	{
	  if (remote_debug)
	    {
	     struct cleanup *old_chain;
	     char *str;

	     str = escape_buffer (*buf, val);
	     old_chain = make_cleanup (xfree, str);
	     fprintf_unfiltered (gdb_stdlog, "Packet received: %s\n", str);
	     do_cleanups (old_chain);
	    }

	  /* Skip the ack char if we're in no-ack mode.  */
	  if (!rs->noack_mode)
	    remote_serial_write ("+", 1);
	  if (is_notif != NULL)
	    *is_notif = 0;
	  return val;
	}

       /* If we got a notification, handle it, and go back to looking
	 for a packet.  */
      else
	{
	  gdb_assert (c == '%');

	  if (remote_debug)
	    {
	      struct cleanup *old_chain;
	      char *str;

	      str = escape_buffer (*buf, val);
	      old_chain = make_cleanup (xfree, str);
	      fprintf_unfiltered (gdb_stdlog,
				  "  Notification received: %s\n",
				  str);
	      do_cleanups (old_chain);
	    }
	  if (is_notif != NULL)
	    *is_notif = 1;

	  handle_notification (rs->notif_state, *buf);

	  /* Notifications require no acknowledgement.  */

	  if (expecting_notif)
	    return val;
	}
    }
}

static int
getpkt_sane (char **buf, long *sizeof_buf, int forever)
{
  return getpkt_or_notif_sane_1 (buf, sizeof_buf, forever, 0, NULL);
}

static int
getpkt_or_notif_sane (char **buf, long *sizeof_buf, int forever,
		      int *is_notif)
{
  return getpkt_or_notif_sane_1 (buf, sizeof_buf, forever, 1,
				 is_notif);
}


/* A helper function that just calls putpkt; for type correctness.  */

static int
putpkt_for_catch_errors (void *arg)
{
  return putpkt (arg);
}

static void
remote_kill (struct target_ops *ops)
{
  /* Use catch_errors so the user can quit from gdb even when we
     aren't on speaking terms with the remote system.  */
  catch_errors (putpkt_for_catch_errors, "k", "", RETURN_MASK_ERROR);

  /* Don't wait for it to die.  I'm not really sure it matters whether
     we do or not.  For the existing stubs, kill is a noop.  */
  target_mourn_inferior ();
}

static int
remote_vkill (int pid, struct remote_state *rs)
{
  if (remote_protocol_packets[PACKET_vKill].support == PACKET_DISABLE)
    return -1;

  /* Tell the remote target to detach.  */
  xsnprintf (rs->buf, get_remote_packet_size (), "vKill;%x", pid);
  putpkt (rs->buf);
  getpkt (&rs->buf, &rs->buf_size, 0);

  if (packet_ok (rs->buf,
		 &remote_protocol_packets[PACKET_vKill]) == PACKET_OK)
    return 0;
  else if (remote_protocol_packets[PACKET_vKill].support == PACKET_DISABLE)
    return -1;
  else
    return 1;
}

static void
extended_remote_kill (struct target_ops *ops)
{
  int res;
  int pid = ptid_get_pid (inferior_ptid);
  struct remote_state *rs = get_remote_state ();

  res = remote_vkill (pid, rs);
  if (res == -1 && !(rs->extended && remote_multi_process_p (rs)))
    {
      /* Don't try 'k' on a multi-process aware stub -- it has no way
	 to specify the pid.  */

      putpkt ("k");
#if 0
      getpkt (&rs->buf, &rs->buf_size, 0);
      if (rs->buf[0] != 'O' || rs->buf[0] != 'K')
	res = 1;
#else
      /* Don't wait for it to die.  I'm not really sure it matters whether
	 we do or not.  For the existing stubs, kill is a noop.  */
      res = 0;
#endif
    }

  if (res != 0)
    error (_("Can't kill process"));

  target_mourn_inferior ();
}

static void
remote_mourn (struct target_ops *ops)
{
  remote_mourn_1 (ops);
}

/* Worker function for remote_mourn.  */
static void
remote_mourn_1 (struct target_ops *target)
{
  unpush_target (target);

  /* remote_close takes care of doing most of the clean up.  */
  generic_mourn_inferior ();
}

static void
extended_remote_mourn_1 (struct target_ops *target)
{
  struct remote_state *rs = get_remote_state ();

  /* In case we got here due to an error, but we're going to stay
     connected.  */
  rs->waiting_for_stop_reply = 0;

  /* If the current general thread belonged to the process we just
     detached from or has exited, the remote side current general
     thread becomes undefined.  Considering a case like this:

     - We just got here due to a detach.
     - The process that we're detaching from happens to immediately
       report a global breakpoint being hit in non-stop mode, in the
       same thread we had selected before.
     - GDB attaches to this process again.
     - This event happens to be the next event we handle.

     GDB would consider that the current general thread didn't need to
     be set on the stub side (with Hg), since for all it knew,
     GENERAL_THREAD hadn't changed.

     Notice that although in all-stop mode, the remote server always
     sets the current thread to the thread reporting the stop event,
     that doesn't happen in non-stop mode; in non-stop, the stub *must
     not* change the current thread when reporting a breakpoint hit,
     due to the decoupling of event reporting and event handling.

     To keep things simple, we always invalidate our notion of the
     current thread.  */
  record_currthread (rs, minus_one_ptid);

  /* Unlike "target remote", we do not want to unpush the target; then
     the next time the user says "run", we won't be connected.  */

  /* Call common code to mark the inferior as not running.	*/
  generic_mourn_inferior ();

  if (!have_inferiors ())
    {
      if (!remote_multi_process_p (rs))
	{
	  /* Check whether the target is running now - some remote stubs
	     automatically restart after kill.	*/
	  putpkt ("?");
	  getpkt (&rs->buf, &rs->buf_size, 0);

	  if (rs->buf[0] == 'S' || rs->buf[0] == 'T')
	    {
	      /* Assume that the target has been restarted.  Set
		 inferior_ptid so that bits of core GDB realizes
		 there's something here, e.g., so that the user can
		 say "kill" again.  */
	      inferior_ptid = magic_null_ptid;
	    }
	}
    }
}

static void
extended_remote_mourn (struct target_ops *ops)
{
  extended_remote_mourn_1 (ops);
}

static int
extended_remote_supports_disable_randomization (void)
{
  return (remote_protocol_packets[PACKET_QDisableRandomization].support
	  == PACKET_ENABLE);
}

static void
extended_remote_disable_randomization (int val)
{
  struct remote_state *rs = get_remote_state ();
  char *reply;

  xsnprintf (rs->buf, get_remote_packet_size (), "QDisableRandomization:%x",
	     val);
  putpkt (rs->buf);
  reply = remote_get_noisy_reply (&target_buf, &target_buf_size);
  if (*reply == '\0')
    error (_("Target does not support QDisableRandomization."));
  if (strcmp (reply, "OK") != 0)
    error (_("Bogus QDisableRandomization reply from target: %s"), reply);
}

static int
extended_remote_run (char *args)
{
  struct remote_state *rs = get_remote_state ();
  int len;

  /* If the user has disabled vRun support, or we have detected that
     support is not available, do not try it.  */
  if (remote_protocol_packets[PACKET_vRun].support == PACKET_DISABLE)
    return -1;

  strcpy (rs->buf, "vRun;");
  len = strlen (rs->buf);

  if (strlen (remote_exec_file) * 2 + len >= get_remote_packet_size ())
    error (_("Remote file name too long for run packet"));
  len += 2 * bin2hex ((gdb_byte *) remote_exec_file, rs->buf + len, 0);

  gdb_assert (args != NULL);
  if (*args)
    {
      struct cleanup *back_to;
      int i;
      char **argv;

      argv = gdb_buildargv (args);
      back_to = make_cleanup ((void (*) (void *)) freeargv, argv);
      for (i = 0; argv[i] != NULL; i++)
	{
	  if (strlen (argv[i]) * 2 + 1 + len >= get_remote_packet_size ())
	    error (_("Argument list too long for run packet"));
	  rs->buf[len++] = ';';
	  len += 2 * bin2hex ((gdb_byte *) argv[i], rs->buf + len, 0);
	}
      do_cleanups (back_to);
    }

  rs->buf[len++] = '\0';

  putpkt (rs->buf);
  getpkt (&rs->buf, &rs->buf_size, 0);

  if (packet_ok (rs->buf, &remote_protocol_packets[PACKET_vRun]) == PACKET_OK)
    {
      /* We have a wait response.  All is well.  */
      return 0;
    }
  else if (remote_protocol_packets[PACKET_vRun].support == PACKET_DISABLE)
    /* It wasn't disabled before, but it is now.  */
    return -1;
  else
    {
      if (remote_exec_file[0] == '\0')
	error (_("Running the default executable on the remote target failed; "
		 "try \"set remote exec-file\"?"));
      else
	error (_("Running \"%s\" on the remote target failed"),
	       remote_exec_file);
    }
}

/* In the extended protocol we want to be able to do things like
   "run" and have them basically work as expected.  So we need
   a special create_inferior function.  We support changing the
   executable file and the command line arguments, but not the
   environment.  */

static void
extended_remote_create_inferior_1 (char *exec_file, char *args,
				   char **env, int from_tty)
{
  int run_worked;
  char *stop_reply;
  struct remote_state *rs = get_remote_state ();

  /* If running asynchronously, register the target file descriptor
     with the event loop.  */
  if (target_can_async_p ())
    target_async (inferior_event_handler, 0);

  /* Disable address space randomization if requested (and supported).  */
  if (extended_remote_supports_disable_randomization ())
    extended_remote_disable_randomization (disable_randomization);

  /* Now restart the remote server.  */
  run_worked = extended_remote_run (args) != -1;
  if (!run_worked)
    {
      /* vRun was not supported.  Fail if we need it to do what the
	 user requested.  */
      if (remote_exec_file[0])
	error (_("Remote target does not support \"set remote exec-file\""));
      if (args[0])
	error (_("Remote target does not support \"set args\" or run <ARGS>"));

      /* Fall back to "R".  */
      extended_remote_restart ();
    }

  if (!have_inferiors ())
    {
      /* Clean up from the last time we ran, before we mark the target
	 running again.  This will mark breakpoints uninserted, and
	 get_offsets may insert breakpoints.  */
      init_thread_list ();
      init_wait_for_inferior ();
    }

  /* vRun's success return is a stop reply.  */
  stop_reply = run_worked ? rs->buf : NULL;
  add_current_inferior_and_thread (stop_reply);

  /* Get updated offsets, if the stub uses qOffsets.  */
  get_offsets ();
}

static void
extended_remote_create_inferior (struct target_ops *ops, 
				 char *exec_file, char *args,
				 char **env, int from_tty)
{
  extended_remote_create_inferior_1 (exec_file, args, env, from_tty);
}


/* Given a location's target info BP_TGT and the packet buffer BUF,  output
   the list of conditions (in agent expression bytecode format), if any, the
   target needs to evaluate.  The output is placed into the packet buffer
   started from BUF and ended at BUF_END.  */

static int
remote_add_target_side_condition (struct gdbarch *gdbarch,
				  struct bp_target_info *bp_tgt, char *buf,
				  char *buf_end)
{
  struct agent_expr *aexpr = NULL;
  int i, ix;
  char *pkt;
  char *buf_start = buf;

  if (VEC_empty (agent_expr_p, bp_tgt->conditions))
    return 0;

  buf += strlen (buf);
  xsnprintf (buf, buf_end - buf, "%s", ";");
  buf++;

  /* Send conditions to the target and free the vector.  */
  for (ix = 0;
       VEC_iterate (agent_expr_p, bp_tgt->conditions, ix, aexpr);
       ix++)
    {
      xsnprintf (buf, buf_end - buf, "X%x,", aexpr->len);
      buf += strlen (buf);
      for (i = 0; i < aexpr->len; ++i)
	buf = pack_hex_byte (buf, aexpr->buf[i]);
      *buf = '\0';
    }

  VEC_free (agent_expr_p, bp_tgt->conditions);
  return 0;
}

static void
remote_add_target_side_commands (struct gdbarch *gdbarch,
				 struct bp_target_info *bp_tgt, char *buf)
{
  struct agent_expr *aexpr = NULL;
  int i, ix;

  if (VEC_empty (agent_expr_p, bp_tgt->tcommands))
    return;

  buf += strlen (buf);

  sprintf (buf, ";cmds:%x,", bp_tgt->persist);
  buf += strlen (buf);

  /* Concatenate all the agent expressions that are commands into the
     cmds parameter.  */
  for (ix = 0;
       VEC_iterate (agent_expr_p, bp_tgt->tcommands, ix, aexpr);
       ix++)
    {
      sprintf (buf, "X%x,", aexpr->len);
      buf += strlen (buf);
      for (i = 0; i < aexpr->len; ++i)
	buf = pack_hex_byte (buf, aexpr->buf[i]);
      *buf = '\0';
    }

  VEC_free (agent_expr_p, bp_tgt->tcommands);
}

/* Insert a breakpoint.  On targets that have software breakpoint
   support, we ask the remote target to do the work; on targets
   which don't, we insert a traditional memory breakpoint.  */

static int
remote_insert_breakpoint (struct gdbarch *gdbarch,
			  struct bp_target_info *bp_tgt)
{
  /* Try the "Z" s/w breakpoint packet if it is not already disabled.
     If it succeeds, then set the support to PACKET_ENABLE.  If it
     fails, and the user has explicitly requested the Z support then
     report an error, otherwise, mark it disabled and go on.  */

  if (remote_protocol_packets[PACKET_Z0].support != PACKET_DISABLE)
    {
      CORE_ADDR addr = bp_tgt->placed_address;
      struct remote_state *rs;
      char *p, *endbuf;
      int bpsize;
      struct condition_list *cond = NULL;

      /* Make sure the remote is pointing at the right process, if
	 necessary.  */
      if (!gdbarch_has_global_breakpoints (target_gdbarch ()))
	set_general_process ();

      gdbarch_remote_breakpoint_from_pc (gdbarch, &addr, &bpsize);

      rs = get_remote_state ();
      p = rs->buf;
      endbuf = rs->buf + get_remote_packet_size ();

      *(p++) = 'Z';
      *(p++) = '0';
      *(p++) = ',';
      addr = (ULONGEST) remote_address_masked (addr);
      p += hexnumstr (p, addr);
      xsnprintf (p, endbuf - p, ",%d", bpsize);

      if (remote_supports_cond_breakpoints ())
	remote_add_target_side_condition (gdbarch, bp_tgt, p, endbuf);

      if (remote_can_run_breakpoint_commands ())
	remote_add_target_side_commands (gdbarch, bp_tgt, p);

      putpkt (rs->buf);
      getpkt (&rs->buf, &rs->buf_size, 0);

      switch (packet_ok (rs->buf, &remote_protocol_packets[PACKET_Z0]))
	{
	case PACKET_ERROR:
	  return -1;
	case PACKET_OK:
	  bp_tgt->placed_address = addr;
	  bp_tgt->placed_size = bpsize;
	  return 0;
	case PACKET_UNKNOWN:
	  break;
	}
    }

  return memory_insert_breakpoint (gdbarch, bp_tgt);
}

static int
remote_remove_breakpoint (struct gdbarch *gdbarch,
			  struct bp_target_info *bp_tgt)
{
  CORE_ADDR addr = bp_tgt->placed_address;
  struct remote_state *rs = get_remote_state ();

  if (remote_protocol_packets[PACKET_Z0].support != PACKET_DISABLE)
    {
      char *p = rs->buf;
      char *endbuf = rs->buf + get_remote_packet_size ();

      /* Make sure the remote is pointing at the right process, if
	 necessary.  */
      if (!gdbarch_has_global_breakpoints (target_gdbarch ()))
	set_general_process ();

      *(p++) = 'z';
      *(p++) = '0';
      *(p++) = ',';

      addr = (ULONGEST) remote_address_masked (bp_tgt->placed_address);
      p += hexnumstr (p, addr);
      xsnprintf (p, endbuf - p, ",%d", bp_tgt->placed_size);

      putpkt (rs->buf);
      getpkt (&rs->buf, &rs->buf_size, 0);

      return (rs->buf[0] == 'E');
    }

  return memory_remove_breakpoint (gdbarch, bp_tgt);
}

static int
watchpoint_to_Z_packet (int type)
{
  switch (type)
    {
    case hw_write:
      return Z_PACKET_WRITE_WP;
      break;
    case hw_read:
      return Z_PACKET_READ_WP;
      break;
    case hw_access:
      return Z_PACKET_ACCESS_WP;
      break;
    default:
      internal_error (__FILE__, __LINE__,
		      _("hw_bp_to_z: bad watchpoint type %d"), type);
    }
}

static int
remote_insert_watchpoint (CORE_ADDR addr, int len, int type,
			  struct expression *cond)
{
  struct remote_state *rs = get_remote_state ();
  char *endbuf = rs->buf + get_remote_packet_size ();
  char *p;
  enum Z_packet_type packet = watchpoint_to_Z_packet (type);

  if (remote_protocol_packets[PACKET_Z0 + packet].support == PACKET_DISABLE)
    return 1;

  /* Make sure the remote is pointing at the right process, if
     necessary.  */
  if (!gdbarch_has_global_breakpoints (target_gdbarch ()))
    set_general_process ();

  xsnprintf (rs->buf, endbuf - rs->buf, "Z%x,", packet);
  p = strchr (rs->buf, '\0');
  addr = remote_address_masked (addr);
  p += hexnumstr (p, (ULONGEST) addr);
  xsnprintf (p, endbuf - p, ",%x", len);

  putpkt (rs->buf);
  getpkt (&rs->buf, &rs->buf_size, 0);

  switch (packet_ok (rs->buf, &remote_protocol_packets[PACKET_Z0 + packet]))
    {
    case PACKET_ERROR:
      return -1;
    case PACKET_UNKNOWN:
      return 1;
    case PACKET_OK:
      return 0;
    }
  internal_error (__FILE__, __LINE__,
		  _("remote_insert_watchpoint: reached end of function"));
}

static int
remote_watchpoint_addr_within_range (struct target_ops *target, CORE_ADDR addr,
				     CORE_ADDR start, int length)
{
  CORE_ADDR diff = remote_address_masked (addr - start);

  return diff < length;
}


static int
remote_remove_watchpoint (CORE_ADDR addr, int len, int type,
			  struct expression *cond)
{
  struct remote_state *rs = get_remote_state ();
  char *endbuf = rs->buf + get_remote_packet_size ();
  char *p;
  enum Z_packet_type packet = watchpoint_to_Z_packet (type);

  if (remote_protocol_packets[PACKET_Z0 + packet].support == PACKET_DISABLE)
    return -1;

  /* Make sure the remote is pointing at the right process, if
     necessary.  */
  if (!gdbarch_has_global_breakpoints (target_gdbarch ()))
    set_general_process ();

  xsnprintf (rs->buf, endbuf - rs->buf, "z%x,", packet);
  p = strchr (rs->buf, '\0');
  addr = remote_address_masked (addr);
  p += hexnumstr (p, (ULONGEST) addr);
  xsnprintf (p, endbuf - p, ",%x", len);
  putpkt (rs->buf);
  getpkt (&rs->buf, &rs->buf_size, 0);

  switch (packet_ok (rs->buf, &remote_protocol_packets[PACKET_Z0 + packet]))
    {
    case PACKET_ERROR:
    case PACKET_UNKNOWN:
      return -1;
    case PACKET_OK:
      return 0;
    }
  internal_error (__FILE__, __LINE__,
		  _("remote_remove_watchpoint: reached end of function"));
}


int remote_hw_watchpoint_limit = -1;
int remote_hw_watchpoint_length_limit = -1;
int remote_hw_breakpoint_limit = -1;

static int
remote_region_ok_for_hw_watchpoint (CORE_ADDR addr, int len)
{
  if (remote_hw_watchpoint_length_limit == 0)
    return 0;
  else if (remote_hw_watchpoint_length_limit < 0)
    return 1;
  else if (len <= remote_hw_watchpoint_length_limit)
    return 1;
  else
    return 0;
}

static int
remote_check_watch_resources (int type, int cnt, int ot)
{
  if (type == bp_hardware_breakpoint)
    {
      if (remote_hw_breakpoint_limit == 0)
	return 0;
      else if (remote_hw_breakpoint_limit < 0)
	return 1;
      else if (cnt <= remote_hw_breakpoint_limit)
	return 1;
    }
  else
    {
      if (remote_hw_watchpoint_limit == 0)
	return 0;
      else if (remote_hw_watchpoint_limit < 0)
	return 1;
      else if (ot)
	return -1;
      else if (cnt <= remote_hw_watchpoint_limit)
	return 1;
    }
  return -1;
}

static int
remote_stopped_by_watchpoint (void)
{
  struct remote_state *rs = get_remote_state ();

  return rs->remote_stopped_by_watchpoint_p;
}

static int
remote_stopped_data_address (struct target_ops *target, CORE_ADDR *addr_p)
{
  struct remote_state *rs = get_remote_state ();
  int rc = 0;

  if (remote_stopped_by_watchpoint ())
    {
      *addr_p = rs->remote_watch_data_address;
      rc = 1;
    }

  return rc;
}


static int
remote_insert_hw_breakpoint (struct gdbarch *gdbarch,
			     struct bp_target_info *bp_tgt)
{
  CORE_ADDR addr;
  struct remote_state *rs;
  char *p, *endbuf;
  char *message;

  /* The length field should be set to the size of a breakpoint
     instruction, even though we aren't inserting one ourselves.  */

  gdbarch_remote_breakpoint_from_pc
    (gdbarch, &bp_tgt->placed_address, &bp_tgt->placed_size);

  if (remote_protocol_packets[PACKET_Z1].support == PACKET_DISABLE)
    return -1;

  /* Make sure the remote is pointing at the right process, if
     necessary.  */
  if (!gdbarch_has_global_breakpoints (target_gdbarch ()))
    set_general_process ();

  rs = get_remote_state ();
  p = rs->buf;
  endbuf = rs->buf + get_remote_packet_size ();

  *(p++) = 'Z';
  *(p++) = '1';
  *(p++) = ',';

  addr = remote_address_masked (bp_tgt->placed_address);
  p += hexnumstr (p, (ULONGEST) addr);
  xsnprintf (p, endbuf - p, ",%x", bp_tgt->placed_size);

  if (remote_supports_cond_breakpoints ())
    remote_add_target_side_condition (gdbarch, bp_tgt, p, endbuf);

  if (remote_can_run_breakpoint_commands ())
    remote_add_target_side_commands (gdbarch, bp_tgt, p);

  putpkt (rs->buf);
  getpkt (&rs->buf, &rs->buf_size, 0);

  switch (packet_ok (rs->buf, &remote_protocol_packets[PACKET_Z1]))
    {
    case PACKET_ERROR:
      if (rs->buf[1] == '.')
        {
          message = strchr (rs->buf + 2, '.');
          if (message)
            error (_("Remote failure reply: %s"), message + 1);
        }
      return -1;
    case PACKET_UNKNOWN:
      return -1;
    case PACKET_OK:
      return 0;
    }
  internal_error (__FILE__, __LINE__,
		  _("remote_insert_hw_breakpoint: reached end of function"));
}


static int
remote_remove_hw_breakpoint (struct gdbarch *gdbarch,
			     struct bp_target_info *bp_tgt)
{
  CORE_ADDR addr;
  struct remote_state *rs = get_remote_state ();
  char *p = rs->buf;
  char *endbuf = rs->buf + get_remote_packet_size ();

  if (remote_protocol_packets[PACKET_Z1].support == PACKET_DISABLE)
    return -1;

  /* Make sure the remote is pointing at the right process, if
     necessary.  */
  if (!gdbarch_has_global_breakpoints (target_gdbarch ()))
    set_general_process ();

  *(p++) = 'z';
  *(p++) = '1';
  *(p++) = ',';

  addr = remote_address_masked (bp_tgt->placed_address);
  p += hexnumstr (p, (ULONGEST) addr);
  xsnprintf (p, endbuf  - p, ",%x", bp_tgt->placed_size);

  putpkt (rs->buf);
  getpkt (&rs->buf, &rs->buf_size, 0);

  switch (packet_ok (rs->buf, &remote_protocol_packets[PACKET_Z1]))
    {
    case PACKET_ERROR:
    case PACKET_UNKNOWN:
      return -1;
    case PACKET_OK:
      return 0;
    }
  internal_error (__FILE__, __LINE__,
		  _("remote_remove_hw_breakpoint: reached end of function"));
}

/* Verify memory using the "qCRC:" request.  */

static int
remote_verify_memory (struct target_ops *ops,
		      const gdb_byte *data, CORE_ADDR lma, ULONGEST size)
{
  struct remote_state *rs = get_remote_state ();
  unsigned long host_crc, target_crc;
  char *tmp;

  /* Make sure the remote is pointing at the right process.  */
  set_general_process ();

  /* FIXME: assumes lma can fit into long.  */
  xsnprintf (rs->buf, get_remote_packet_size (), "qCRC:%lx,%lx",
	     (long) lma, (long) size);
  putpkt (rs->buf);

  /* Be clever; compute the host_crc before waiting for target
     reply.  */
  host_crc = xcrc32 (data, size, 0xffffffff);

  getpkt (&rs->buf, &rs->buf_size, 0);
  if (rs->buf[0] == 'E')
    return -1;

  if (rs->buf[0] != 'C')
    error (_("remote target does not support this operation"));

  for (target_crc = 0, tmp = &rs->buf[1]; *tmp; tmp++)
    target_crc = target_crc * 16 + fromhex (*tmp);

  return (host_crc == target_crc);
}

/* compare-sections command

   With no arguments, compares each loadable section in the exec bfd
   with the same memory range on the target, and reports mismatches.
   Useful for verifying the image on the target against the exec file.  */

static void
compare_sections_command (char *args, int from_tty)
{
  asection *s;
  struct cleanup *old_chain;
  gdb_byte *sectdata;
  const char *sectname;
  bfd_size_type size;
  bfd_vma lma;
  int matched = 0;
  int mismatched = 0;
  int res;

  if (!exec_bfd)
    error (_("command cannot be used without an exec file"));

  /* Make sure the remote is pointing at the right process.  */
  set_general_process ();

  for (s = exec_bfd->sections; s; s = s->next)
    {
      if (!(s->flags & SEC_LOAD))
	continue;		/* Skip non-loadable section.  */

      size = bfd_get_section_size (s);
      if (size == 0)
	continue;		/* Skip zero-length section.  */

      sectname = bfd_get_section_name (exec_bfd, s);
      if (args && strcmp (args, sectname) != 0)
	continue;		/* Not the section selected by user.  */

      matched = 1;		/* Do this section.  */
      lma = s->lma;

      sectdata = xmalloc (size);
      old_chain = make_cleanup (xfree, sectdata);
      bfd_get_section_contents (exec_bfd, s, sectdata, 0, size);

      res = target_verify_memory (sectdata, lma, size);

      if (res == -1)
	error (_("target memory fault, section %s, range %s -- %s"), sectname,
	       paddress (target_gdbarch (), lma),
	       paddress (target_gdbarch (), lma + size));

      printf_filtered ("Section %s, range %s -- %s: ", sectname,
		       paddress (target_gdbarch (), lma),
		       paddress (target_gdbarch (), lma + size));
      if (res)
	printf_filtered ("matched.\n");
      else
	{
	  printf_filtered ("MIS-MATCHED!\n");
	  mismatched++;
	}

      do_cleanups (old_chain);
    }
  if (mismatched > 0)
    warning (_("One or more sections of the remote executable does not match\n\
the loaded file\n"));
  if (args && !matched)
    printf_filtered (_("No loaded section named '%s'.\n"), args);
}

/* Write LEN bytes from WRITEBUF into OBJECT_NAME/ANNEX at OFFSET
   into remote target.  The number of bytes written to the remote
   target is returned, or -1 for error.  */

static LONGEST
remote_write_qxfer (struct target_ops *ops, const char *object_name,
                    const char *annex, const gdb_byte *writebuf, 
                    ULONGEST offset, LONGEST len, 
                    struct packet_config *packet)
{
  int i, buf_len;
  ULONGEST n;
  struct remote_state *rs = get_remote_state ();
  int max_size = get_memory_write_packet_size (); 

  if (packet->support == PACKET_DISABLE)
    return -1;

  /* Insert header.  */
  i = snprintf (rs->buf, max_size, 
		"qXfer:%s:write:%s:%s:",
		object_name, annex ? annex : "",
		phex_nz (offset, sizeof offset));
  max_size -= (i + 1);

  /* Escape as much data as fits into rs->buf.  */
  buf_len = remote_escape_output 
    (writebuf, len, (gdb_byte *) rs->buf + i, &max_size, max_size);

  if (putpkt_binary (rs->buf, i + buf_len) < 0
      || getpkt_sane (&rs->buf, &rs->buf_size, 0) < 0
      || packet_ok (rs->buf, packet) != PACKET_OK)
    return -1;

  unpack_varlen_hex (rs->buf, &n);
  return n;
}

/* Read OBJECT_NAME/ANNEX from the remote target using a qXfer packet.
   Data at OFFSET, of up to LEN bytes, is read into READBUF; the
   number of bytes read is returned, or 0 for EOF, or -1 for error.
   The number of bytes read may be less than LEN without indicating an
   EOF.  PACKET is checked and updated to indicate whether the remote
   target supports this object.  */

static LONGEST
remote_read_qxfer (struct target_ops *ops, const char *object_name,
		   const char *annex,
		   gdb_byte *readbuf, ULONGEST offset, LONGEST len,
		   struct packet_config *packet)
{
  struct remote_state *rs = get_remote_state ();
  LONGEST i, n, packet_len;

  if (packet->support == PACKET_DISABLE)
    return -1;

  /* Check whether we've cached an end-of-object packet that matches
     this request.  */
  if (rs->finished_object)
    {
      if (strcmp (object_name, rs->finished_object) == 0
	  && strcmp (annex ? annex : "", rs->finished_annex) == 0
	  && offset == rs->finished_offset)
	return 0;

      /* Otherwise, we're now reading something different.  Discard
	 the cache.  */
      xfree (rs->finished_object);
      xfree (rs->finished_annex);
      rs->finished_object = NULL;
      rs->finished_annex = NULL;
    }

  /* Request only enough to fit in a single packet.  The actual data
     may not, since we don't know how much of it will need to be escaped;
     the target is free to respond with slightly less data.  We subtract
     five to account for the response type and the protocol frame.  */
  n = min (get_remote_packet_size () - 5, len);
  snprintf (rs->buf, get_remote_packet_size () - 4, "qXfer:%s:read:%s:%s,%s",
	    object_name, annex ? annex : "",
	    phex_nz (offset, sizeof offset),
	    phex_nz (n, sizeof n));
  i = putpkt (rs->buf);
  if (i < 0)
    return -1;

  rs->buf[0] = '\0';
  packet_len = getpkt_sane (&rs->buf, &rs->buf_size, 0);
  if (packet_len < 0 || packet_ok (rs->buf, packet) != PACKET_OK)
    return -1;

  if (rs->buf[0] != 'l' && rs->buf[0] != 'm')
    error (_("Unknown remote qXfer reply: %s"), rs->buf);

  /* 'm' means there is (or at least might be) more data after this
     batch.  That does not make sense unless there's at least one byte
     of data in this reply.  */
  if (rs->buf[0] == 'm' && packet_len == 1)
    error (_("Remote qXfer reply contained no data."));

  /* Got some data.  */
  i = remote_unescape_input ((gdb_byte *) rs->buf + 1,
			     packet_len - 1, readbuf, n);

  /* 'l' is an EOF marker, possibly including a final block of data,
     or possibly empty.  If we have the final block of a non-empty
     object, record this fact to bypass a subsequent partial read.  */
  if (rs->buf[0] == 'l' && offset + i > 0)
    {
      rs->finished_object = xstrdup (object_name);
      rs->finished_annex = xstrdup (annex ? annex : "");
      rs->finished_offset = offset + i;
    }

  return i;
}

static LONGEST
remote_xfer_partial (struct target_ops *ops, enum target_object object,
		     const char *annex, gdb_byte *readbuf,
		     const gdb_byte *writebuf, ULONGEST offset, LONGEST len)
{
  struct remote_state *rs;
  int i;
  char *p2;
  char query_type;

  set_remote_traceframe ();
  set_general_thread (inferior_ptid);

  rs = get_remote_state ();

  /* Handle memory using the standard memory routines.  */
  if (object == TARGET_OBJECT_MEMORY)
    {
      LONGEST xfered;

      /* If the remote target is connected but not running, we should
	 pass this request down to a lower stratum (e.g. the executable
	 file).  */
      if (!target_has_execution)
	return 0;

      if (writebuf != NULL)
	xfered = remote_write_bytes (offset, writebuf, len);
      else
	xfered = remote_read_bytes (offset, readbuf, len);

      return xfered;
    }

  /* Handle SPU memory using qxfer packets.  */
  if (object == TARGET_OBJECT_SPU)
    {
      if (readbuf)
	return remote_read_qxfer (ops, "spu", annex, readbuf, offset, len,
				  &remote_protocol_packets
				    [PACKET_qXfer_spu_read]);
      else
	return remote_write_qxfer (ops, "spu", annex, writebuf, offset, len,
				   &remote_protocol_packets
				     [PACKET_qXfer_spu_write]);
    }

  /* Handle extra signal info using qxfer packets.  */
  if (object == TARGET_OBJECT_SIGNAL_INFO)
    {
      if (readbuf)
	return remote_read_qxfer (ops, "siginfo", annex, readbuf, offset, len,
				  &remote_protocol_packets
				  [PACKET_qXfer_siginfo_read]);
      else
	return remote_write_qxfer (ops, "siginfo", annex,
				   writebuf, offset, len,
				   &remote_protocol_packets
				   [PACKET_qXfer_siginfo_write]);
    }

  if (object == TARGET_OBJECT_STATIC_TRACE_DATA)
    {
      if (readbuf)
	return remote_read_qxfer (ops, "statictrace", annex,
				  readbuf, offset, len,
				  &remote_protocol_packets
				  [PACKET_qXfer_statictrace_read]);
      else
	return -1;
    }

  /* Only handle flash writes.  */
  if (writebuf != NULL)
    {
      LONGEST xfered;

      switch (object)
	{
	case TARGET_OBJECT_FLASH:
	  return remote_flash_write (ops, offset, len, writebuf);

	default:
	  return -1;
	}
    }

  /* Map pre-existing objects onto letters.  DO NOT do this for new
     objects!!!  Instead specify new query packets.  */
  switch (object)
    {
    case TARGET_OBJECT_AVR:
      query_type = 'R';
      break;

    case TARGET_OBJECT_AUXV:
      gdb_assert (annex == NULL);
      return remote_read_qxfer (ops, "auxv", annex, readbuf, offset, len,
				&remote_protocol_packets[PACKET_qXfer_auxv]);

    case TARGET_OBJECT_AVAILABLE_FEATURES:
      return remote_read_qxfer
	(ops, "features", annex, readbuf, offset, len,
	 &remote_protocol_packets[PACKET_qXfer_features]);

    case TARGET_OBJECT_LIBRARIES:
      return remote_read_qxfer
	(ops, "libraries", annex, readbuf, offset, len,
	 &remote_protocol_packets[PACKET_qXfer_libraries]);

    case TARGET_OBJECT_LIBRARIES_SVR4:
      return remote_read_qxfer
	(ops, "libraries-svr4", annex, readbuf, offset, len,
	 &remote_protocol_packets[PACKET_qXfer_libraries_svr4]);

    case TARGET_OBJECT_MEMORY_MAP:
      gdb_assert (annex == NULL);
      return remote_read_qxfer (ops, "memory-map", annex, readbuf, offset, len,
				&remote_protocol_packets[PACKET_qXfer_memory_map]);

    case TARGET_OBJECT_OSDATA:
      /* Should only get here if we're connected.  */
      gdb_assert (rs->remote_desc);
      return remote_read_qxfer
       (ops, "osdata", annex, readbuf, offset, len,
        &remote_protocol_packets[PACKET_qXfer_osdata]);

    case TARGET_OBJECT_THREADS:
      gdb_assert (annex == NULL);
      return remote_read_qxfer (ops, "threads", annex, readbuf, offset, len,
				&remote_protocol_packets[PACKET_qXfer_threads]);

    case TARGET_OBJECT_TRACEFRAME_INFO:
      gdb_assert (annex == NULL);
      return remote_read_qxfer
	(ops, "traceframe-info", annex, readbuf, offset, len,
	 &remote_protocol_packets[PACKET_qXfer_traceframe_info]);

    case TARGET_OBJECT_FDPIC:
      return remote_read_qxfer (ops, "fdpic", annex, readbuf, offset, len,
				&remote_protocol_packets[PACKET_qXfer_fdpic]);

    case TARGET_OBJECT_OPENVMS_UIB:
      return remote_read_qxfer (ops, "uib", annex, readbuf, offset, len,
				&remote_protocol_packets[PACKET_qXfer_uib]);

    case TARGET_OBJECT_BTRACE:
      return remote_read_qxfer (ops, "btrace", annex, readbuf, offset, len,
        &remote_protocol_packets[PACKET_qXfer_btrace]);

    default:
      return -1;
    }

  /* Note: a zero OFFSET and LEN can be used to query the minimum
     buffer size.  */
  if (offset == 0 && len == 0)
    return (get_remote_packet_size ());
  /* Minimum outbuf size is get_remote_packet_size ().  If LEN is not
     large enough let the caller deal with it.  */
  if (len < get_remote_packet_size ())
    return -1;
  len = get_remote_packet_size ();

  /* Except for querying the minimum buffer size, target must be open.  */
  if (!rs->remote_desc)
    error (_("remote query is only available after target open"));

  gdb_assert (annex != NULL);
  gdb_assert (readbuf != NULL);

  p2 = rs->buf;
  *p2++ = 'q';
  *p2++ = query_type;

  /* We used one buffer char for the remote protocol q command and
     another for the query type.  As the remote protocol encapsulation
     uses 4 chars plus one extra in case we are debugging
     (remote_debug), we have PBUFZIZ - 7 left to pack the query
     string.  */
  i = 0;
  while (annex[i] && (i < (get_remote_packet_size () - 8)))
    {
      /* Bad caller may have sent forbidden characters.  */
      gdb_assert (isprint (annex[i]) && annex[i] != '$' && annex[i] != '#');
      *p2++ = annex[i];
      i++;
    }
  *p2 = '\0';
  gdb_assert (annex[i] == '\0');

  i = putpkt (rs->buf);
  if (i < 0)
    return i;

  getpkt (&rs->buf, &rs->buf_size, 0);
  strcpy ((char *) readbuf, rs->buf);

  return strlen ((char *) readbuf);
}

static int
remote_search_memory (struct target_ops* ops,
		      CORE_ADDR start_addr, ULONGEST search_space_len,
		      const gdb_byte *pattern, ULONGEST pattern_len,
		      CORE_ADDR *found_addrp)
{
  int addr_size = gdbarch_addr_bit (target_gdbarch ()) / 8;
  struct remote_state *rs = get_remote_state ();
  int max_size = get_memory_write_packet_size ();
  struct packet_config *packet =
    &remote_protocol_packets[PACKET_qSearch_memory];
  /* Number of packet bytes used to encode the pattern;
     this could be more than PATTERN_LEN due to escape characters.  */
  int escaped_pattern_len;
  /* Amount of pattern that was encodable in the packet.  */
  int used_pattern_len;
  int i;
  int found;
  ULONGEST found_addr;

  /* Don't go to the target if we don't have to.
     This is done before checking packet->support to avoid the possibility that
     a success for this edge case means the facility works in general.  */
  if (pattern_len > search_space_len)
    return 0;
  if (pattern_len == 0)
    {
      *found_addrp = start_addr;
      return 1;
    }

  /* If we already know the packet isn't supported, fall back to the simple
     way of searching memory.  */

  if (packet->support == PACKET_DISABLE)
    {
      /* Target doesn't provided special support, fall back and use the
	 standard support (copy memory and do the search here).  */
      return simple_search_memory (ops, start_addr, search_space_len,
				   pattern, pattern_len, found_addrp);
    }

  /* Make sure the remote is pointing at the right process.  */
  set_general_process ();

  /* Insert header.  */
  i = snprintf (rs->buf, max_size, 
		"qSearch:memory:%s;%s;",
		phex_nz (start_addr, addr_size),
		phex_nz (search_space_len, sizeof (search_space_len)));
  max_size -= (i + 1);

  /* Escape as much data as fits into rs->buf.  */
  escaped_pattern_len =
    remote_escape_output (pattern, pattern_len, (gdb_byte *) rs->buf + i,
			  &used_pattern_len, max_size);

  /* Bail if the pattern is too large.  */
  if (used_pattern_len != pattern_len)
    error (_("Pattern is too large to transmit to remote target."));

  if (putpkt_binary (rs->buf, i + escaped_pattern_len) < 0
      || getpkt_sane (&rs->buf, &rs->buf_size, 0) < 0
      || packet_ok (rs->buf, packet) != PACKET_OK)
    {
      /* The request may not have worked because the command is not
	 supported.  If so, fall back to the simple way.  */
      if (packet->support == PACKET_DISABLE)
	{
	  return simple_search_memory (ops, start_addr, search_space_len,
				       pattern, pattern_len, found_addrp);
	}
      return -1;
    }

  if (rs->buf[0] == '0')
    found = 0;
  else if (rs->buf[0] == '1')
    {
      found = 1;
      if (rs->buf[1] != ',')
	error (_("Unknown qSearch:memory reply: %s"), rs->buf);
      unpack_varlen_hex (rs->buf + 2, &found_addr);
      *found_addrp = found_addr;
    }
  else
    error (_("Unknown qSearch:memory reply: %s"), rs->buf);

  return found;
}

static void
remote_rcmd (char *command,
	     struct ui_file *outbuf)
{
  struct remote_state *rs = get_remote_state ();
  char *p = rs->buf;

  if (!rs->remote_desc)
    error (_("remote rcmd is only available after target open"));

  /* Send a NULL command across as an empty command.  */
  if (command == NULL)
    command = "";

  /* The query prefix.  */
  strcpy (rs->buf, "qRcmd,");
  p = strchr (rs->buf, '\0');

  if ((strlen (rs->buf) + strlen (command) * 2 + 8/*misc*/)
      > get_remote_packet_size ())
    error (_("\"monitor\" command ``%s'' is too long."), command);

  /* Encode the actual command.  */
  bin2hex ((gdb_byte *) command, p, 0);

  if (putpkt (rs->buf) < 0)
    error (_("Communication problem with target."));

  /* get/display the response */
  while (1)
    {
      char *buf;

      /* XXX - see also remote_get_noisy_reply().  */
      QUIT;			/* Allow user to bail out with ^C.  */
      rs->buf[0] = '\0';
      if (getpkt_sane (&rs->buf, &rs->buf_size, 0) == -1)
        { 
          /* Timeout.  Continue to (try to) read responses.
             This is better than stopping with an error, assuming the stub
             is still executing the (long) monitor command.
             If needed, the user can interrupt gdb using C-c, obtaining
             an effect similar to stop on timeout.  */
          continue;
        }
      buf = rs->buf;
      if (buf[0] == '\0')
	error (_("Target does not support this command."));
      if (buf[0] == 'O' && buf[1] != 'K')
	{
	  remote_console_output (buf + 1); /* 'O' message from stub.  */
	  continue;
	}
      if (strcmp (buf, "OK") == 0)
	break;
      if (strlen (buf) == 3 && buf[0] == 'E'
	  && isdigit (buf[1]) && isdigit (buf[2]))
	{
	  error (_("Protocol error with Rcmd"));
	}
      for (p = buf; p[0] != '\0' && p[1] != '\0'; p += 2)
	{
	  char c = (fromhex (p[0]) << 4) + fromhex (p[1]);

	  fputc_unfiltered (c, outbuf);
	}
      break;
    }
}

static VEC(mem_region_s) *
remote_memory_map (struct target_ops *ops)
{
  VEC(mem_region_s) *result = NULL;
  char *text = target_read_stralloc (&current_target,
				     TARGET_OBJECT_MEMORY_MAP, NULL);

  if (text)
    {
      struct cleanup *back_to = make_cleanup (xfree, text);

      result = parse_memory_map (text);
      do_cleanups (back_to);
    }

  return result;
}

static void
packet_command (char *args, int from_tty)
{
  struct remote_state *rs = get_remote_state ();

  if (!rs->remote_desc)
    error (_("command can only be used with remote target"));

  if (!args)
    error (_("remote-packet command requires packet text as argument"));

  puts_filtered ("sending: ");
  print_packet (args);
  puts_filtered ("\n");
  putpkt (args);

  getpkt (&rs->buf, &rs->buf_size, 0);
  puts_filtered ("received: ");
  print_packet (rs->buf);
  puts_filtered ("\n");
}

#if 0
/* --------- UNIT_TEST for THREAD oriented PACKETS ------------------- */

static void display_thread_info (struct gdb_ext_thread_info *info);

static void threadset_test_cmd (char *cmd, int tty);

static void threadalive_test (char *cmd, int tty);

static void threadlist_test_cmd (char *cmd, int tty);

int get_and_display_threadinfo (threadref *ref);

static void threadinfo_test_cmd (char *cmd, int tty);

static int thread_display_step (threadref *ref, void *context);

static void threadlist_update_test_cmd (char *cmd, int tty);

static void init_remote_threadtests (void);

#define SAMPLE_THREAD  0x05060708	/* Truncated 64 bit threadid.  */

static void
threadset_test_cmd (char *cmd, int tty)
{
  int sample_thread = SAMPLE_THREAD;

  printf_filtered (_("Remote threadset test\n"));
  set_general_thread (sample_thread);
}


static void
threadalive_test (char *cmd, int tty)
{
  int sample_thread = SAMPLE_THREAD;
  int pid = ptid_get_pid (inferior_ptid);
  ptid_t ptid = ptid_build (pid, 0, sample_thread);

  if (remote_thread_alive (ptid))
    printf_filtered ("PASS: Thread alive test\n");
  else
    printf_filtered ("FAIL: Thread alive test\n");
}

void output_threadid (char *title, threadref *ref);

void
output_threadid (char *title, threadref *ref)
{
  char hexid[20];

  pack_threadid (&hexid[0], ref);	/* Convert threead id into hex.  */
  hexid[16] = 0;
  printf_filtered ("%s  %s\n", title, (&hexid[0]));
}

static void
threadlist_test_cmd (char *cmd, int tty)
{
  int startflag = 1;
  threadref nextthread;
  int done, result_count;
  threadref threadlist[3];

  printf_filtered ("Remote Threadlist test\n");
  if (!remote_get_threadlist (startflag, &nextthread, 3, &done,
			      &result_count, &threadlist[0]))
    printf_filtered ("FAIL: threadlist test\n");
  else
    {
      threadref *scan = threadlist;
      threadref *limit = scan + result_count;

      while (scan < limit)
	output_threadid (" thread ", scan++);
    }
}

void
display_thread_info (struct gdb_ext_thread_info *info)
{
  output_threadid ("Threadid: ", &info->threadid);
  printf_filtered ("Name: %s\n ", info->shortname);
  printf_filtered ("State: %s\n", info->display);
  printf_filtered ("other: %s\n\n", info->more_display);
}

int
get_and_display_threadinfo (threadref *ref)
{
  int result;
  int set;
  struct gdb_ext_thread_info threadinfo;

  set = TAG_THREADID | TAG_EXISTS | TAG_THREADNAME
    | TAG_MOREDISPLAY | TAG_DISPLAY;
  if (0 != (result = remote_get_threadinfo (ref, set, &threadinfo)))
    display_thread_info (&threadinfo);
  return result;
}

static void
threadinfo_test_cmd (char *cmd, int tty)
{
  int athread = SAMPLE_THREAD;
  threadref thread;
  int set;

  int_to_threadref (&thread, athread);
  printf_filtered ("Remote Threadinfo test\n");
  if (!get_and_display_threadinfo (&thread))
    printf_filtered ("FAIL cannot get thread info\n");
}

static int
thread_display_step (threadref *ref, void *context)
{
  /* output_threadid(" threadstep ",ref); *//* simple test */
  return get_and_display_threadinfo (ref);
}

static void
threadlist_update_test_cmd (char *cmd, int tty)
{
  printf_filtered ("Remote Threadlist update test\n");
  remote_threadlist_iterator (thread_display_step, 0, CRAZY_MAX_THREADS);
}

static void
init_remote_threadtests (void)
{
  add_com ("tlist", class_obscure, threadlist_test_cmd,
	   _("Fetch and print the remote list of "
	     "thread identifiers, one pkt only"));
  add_com ("tinfo", class_obscure, threadinfo_test_cmd,
	   _("Fetch and display info about one thread"));
  add_com ("tset", class_obscure, threadset_test_cmd,
	   _("Test setting to a different thread"));
  add_com ("tupd", class_obscure, threadlist_update_test_cmd,
	   _("Iterate through updating all remote thread info"));
  add_com ("talive", class_obscure, threadalive_test,
	   _(" Remote thread alive test "));
}

#endif /* 0 */

/* Convert a thread ID to a string.  Returns the string in a static
   buffer.  */

static char *
remote_pid_to_str (struct target_ops *ops, ptid_t ptid)
{
  static char buf[64];
  struct remote_state *rs = get_remote_state ();

  if (ptid_equal (ptid, null_ptid))
    return normal_pid_to_str (ptid);
  else if (ptid_is_pid (ptid))
    {
      /* Printing an inferior target id.  */

      /* When multi-process extensions are off, there's no way in the
	 remote protocol to know the remote process id, if there's any
	 at all.  There's one exception --- when we're connected with
	 target extended-remote, and we manually attached to a process
	 with "attach PID".  We don't record anywhere a flag that
	 allows us to distinguish that case from the case of
	 connecting with extended-remote and the stub already being
	 attached to a process, and reporting yes to qAttached, hence
	 no smart special casing here.  */
      if (!remote_multi_process_p (rs))
	{
	  xsnprintf (buf, sizeof buf, "Remote target");
	  return buf;
	}

      return normal_pid_to_str (ptid);
    }
  else
    {
      if (ptid_equal (magic_null_ptid, ptid))
	xsnprintf (buf, sizeof buf, "Thread <main>");
      else if (rs->extended && remote_multi_process_p (rs))
	xsnprintf (buf, sizeof buf, "Thread %d.%ld",
		   ptid_get_pid (ptid), ptid_get_tid (ptid));
      else
	xsnprintf (buf, sizeof buf, "Thread %ld",
		   ptid_get_tid (ptid));
      return buf;
    }
}

/* Get the address of the thread local variable in OBJFILE which is
   stored at OFFSET within the thread local storage for thread PTID.  */

static CORE_ADDR
remote_get_thread_local_address (struct target_ops *ops,
				 ptid_t ptid, CORE_ADDR lm, CORE_ADDR offset)
{
  if (remote_protocol_packets[PACKET_qGetTLSAddr].support != PACKET_DISABLE)
    {
      struct remote_state *rs = get_remote_state ();
      char *p = rs->buf;
      char *endp = rs->buf + get_remote_packet_size ();
      enum packet_result result;

      strcpy (p, "qGetTLSAddr:");
      p += strlen (p);
      p = write_ptid (p, endp, ptid);
      *p++ = ',';
      p += hexnumstr (p, offset);
      *p++ = ',';
      p += hexnumstr (p, lm);
      *p++ = '\0';

      putpkt (rs->buf);
      getpkt (&rs->buf, &rs->buf_size, 0);
      result = packet_ok (rs->buf,
			  &remote_protocol_packets[PACKET_qGetTLSAddr]);
      if (result == PACKET_OK)
	{
	  ULONGEST result;

	  unpack_varlen_hex (rs->buf, &result);
	  return result;
	}
      else if (result == PACKET_UNKNOWN)
	throw_error (TLS_GENERIC_ERROR,
		     _("Remote target doesn't support qGetTLSAddr packet"));
      else
	throw_error (TLS_GENERIC_ERROR,
		     _("Remote target failed to process qGetTLSAddr request"));
    }
  else
    throw_error (TLS_GENERIC_ERROR,
		 _("TLS not supported or disabled on this target"));
  /* Not reached.  */
  return 0;
}

/* Provide thread local base, i.e. Thread Information Block address.
   Returns 1 if ptid is found and thread_local_base is non zero.  */

static int
remote_get_tib_address (ptid_t ptid, CORE_ADDR *addr)
{
  if (remote_protocol_packets[PACKET_qGetTIBAddr].support != PACKET_DISABLE)
    {
      struct remote_state *rs = get_remote_state ();
      char *p = rs->buf;
      char *endp = rs->buf + get_remote_packet_size ();
      enum packet_result result;

      strcpy (p, "qGetTIBAddr:");
      p += strlen (p);
      p = write_ptid (p, endp, ptid);
      *p++ = '\0';

      putpkt (rs->buf);
      getpkt (&rs->buf, &rs->buf_size, 0);
      result = packet_ok (rs->buf,
			  &remote_protocol_packets[PACKET_qGetTIBAddr]);
      if (result == PACKET_OK)
	{
	  ULONGEST result;

	  unpack_varlen_hex (rs->buf, &result);
	  if (addr)
	    *addr = (CORE_ADDR) result;
	  return 1;
	}
      else if (result == PACKET_UNKNOWN)
	error (_("Remote target doesn't support qGetTIBAddr packet"));
      else
	error (_("Remote target failed to process qGetTIBAddr request"));
    }
  else
    error (_("qGetTIBAddr not supported or disabled on this target"));
  /* Not reached.  */
  return 0;
}

/* Support for inferring a target description based on the current
   architecture and the size of a 'g' packet.  While the 'g' packet
   can have any size (since optional registers can be left off the
   end), some sizes are easily recognizable given knowledge of the
   approximate architecture.  */

struct remote_g_packet_guess
{
  int bytes;
  const struct target_desc *tdesc;
};
typedef struct remote_g_packet_guess remote_g_packet_guess_s;
DEF_VEC_O(remote_g_packet_guess_s);

struct remote_g_packet_data
{
  VEC(remote_g_packet_guess_s) *guesses;
};

static struct gdbarch_data *remote_g_packet_data_handle;

static void *
remote_g_packet_data_init (struct obstack *obstack)
{
  return OBSTACK_ZALLOC (obstack, struct remote_g_packet_data);
}

void
register_remote_g_packet_guess (struct gdbarch *gdbarch, int bytes,
				const struct target_desc *tdesc)
{
  struct remote_g_packet_data *data
    = gdbarch_data (gdbarch, remote_g_packet_data_handle);
  struct remote_g_packet_guess new_guess, *guess;
  int ix;

  gdb_assert (tdesc != NULL);

  for (ix = 0;
       VEC_iterate (remote_g_packet_guess_s, data->guesses, ix, guess);
       ix++)
    if (guess->bytes == bytes)
      internal_error (__FILE__, __LINE__,
		      _("Duplicate g packet description added for size %d"),
		      bytes);

  new_guess.bytes = bytes;
  new_guess.tdesc = tdesc;
  VEC_safe_push (remote_g_packet_guess_s, data->guesses, &new_guess);
}

/* Return 1 if remote_read_description would do anything on this target
   and architecture, 0 otherwise.  */

static int
remote_read_description_p (struct target_ops *target)
{
  struct remote_g_packet_data *data
    = gdbarch_data (target_gdbarch (), remote_g_packet_data_handle);

  if (!VEC_empty (remote_g_packet_guess_s, data->guesses))
    return 1;

  return 0;
}

static const struct target_desc *
remote_read_description (struct target_ops *target)
{
  struct remote_g_packet_data *data
    = gdbarch_data (target_gdbarch (), remote_g_packet_data_handle);

  /* Do not try this during initial connection, when we do not know
     whether there is a running but stopped thread.  */
  if (!target_has_execution || ptid_equal (inferior_ptid, null_ptid))
    return NULL;

  if (!VEC_empty (remote_g_packet_guess_s, data->guesses))
    {
      struct remote_g_packet_guess *guess;
      int ix;
      int bytes = send_g_packet ();

      for (ix = 0;
	   VEC_iterate (remote_g_packet_guess_s, data->guesses, ix, guess);
	   ix++)
	if (guess->bytes == bytes)
	  return guess->tdesc;

      /* We discard the g packet.  A minor optimization would be to
	 hold on to it, and fill the register cache once we have selected
	 an architecture, but it's too tricky to do safely.  */
    }

  return NULL;
}

/* Remote file transfer support.  This is host-initiated I/O, not
   target-initiated; for target-initiated, see remote-fileio.c.  */

/* If *LEFT is at least the length of STRING, copy STRING to
   *BUFFER, update *BUFFER to point to the new end of the buffer, and
   decrease *LEFT.  Otherwise raise an error.  */

static void
remote_buffer_add_string (char **buffer, int *left, char *string)
{
  int len = strlen (string);

  if (len > *left)
    error (_("Packet too long for target."));

  memcpy (*buffer, string, len);
  *buffer += len;
  *left -= len;

  /* NUL-terminate the buffer as a convenience, if there is
     room.  */
  if (*left)
    **buffer = '\0';
}

/* If *LEFT is large enough, hex encode LEN bytes from BYTES into
   *BUFFER, update *BUFFER to point to the new end of the buffer, and
   decrease *LEFT.  Otherwise raise an error.  */

static void
remote_buffer_add_bytes (char **buffer, int *left, const gdb_byte *bytes,
			 int len)
{
  if (2 * len > *left)
    error (_("Packet too long for target."));

  bin2hex (bytes, *buffer, len);
  *buffer += 2 * len;
  *left -= 2 * len;

  /* NUL-terminate the buffer as a convenience, if there is
     room.  */
  if (*left)
    **buffer = '\0';
}

/* If *LEFT is large enough, convert VALUE to hex and add it to
   *BUFFER, update *BUFFER to point to the new end of the buffer, and
   decrease *LEFT.  Otherwise raise an error.  */

static void
remote_buffer_add_int (char **buffer, int *left, ULONGEST value)
{
  int len = hexnumlen (value);

  if (len > *left)
    error (_("Packet too long for target."));

  hexnumstr (*buffer, value);
  *buffer += len;
  *left -= len;

  /* NUL-terminate the buffer as a convenience, if there is
     room.  */
  if (*left)
    **buffer = '\0';
}

/* Parse an I/O result packet from BUFFER.  Set RETCODE to the return
   value, *REMOTE_ERRNO to the remote error number or zero if none
   was included, and *ATTACHMENT to point to the start of the annex
   if any.  The length of the packet isn't needed here; there may
   be NUL bytes in BUFFER, but they will be after *ATTACHMENT.

   Return 0 if the packet could be parsed, -1 if it could not.  If
   -1 is returned, the other variables may not be initialized.  */

static int
remote_hostio_parse_result (char *buffer, int *retcode,
			    int *remote_errno, char **attachment)
{
  char *p, *p2;

  *remote_errno = 0;
  *attachment = NULL;

  if (buffer[0] != 'F')
    return -1;

  errno = 0;
  *retcode = strtol (&buffer[1], &p, 16);
  if (errno != 0 || p == &buffer[1])
    return -1;

  /* Check for ",errno".  */
  if (*p == ',')
    {
      errno = 0;
      *remote_errno = strtol (p + 1, &p2, 16);
      if (errno != 0 || p + 1 == p2)
	return -1;
      p = p2;
    }

  /* Check for ";attachment".  If there is no attachment, the
     packet should end here.  */
  if (*p == ';')
    {
      *attachment = p + 1;
      return 0;
    }
  else if (*p == '\0')
    return 0;
  else
    return -1;
}

/* Send a prepared I/O packet to the target and read its response.
   The prepared packet is in the global RS->BUF before this function
   is called, and the answer is there when we return.

   COMMAND_BYTES is the length of the request to send, which may include
   binary data.  WHICH_PACKET is the packet configuration to check
   before attempting a packet.  If an error occurs, *REMOTE_ERRNO
   is set to the error number and -1 is returned.  Otherwise the value
   returned by the function is returned.

   ATTACHMENT and ATTACHMENT_LEN should be non-NULL if and only if an
   attachment is expected; an error will be reported if there's a
   mismatch.  If one is found, *ATTACHMENT will be set to point into
   the packet buffer and *ATTACHMENT_LEN will be set to the
   attachment's length.  */

static int
remote_hostio_send_command (int command_bytes, int which_packet,
			    int *remote_errno, char **attachment,
			    int *attachment_len)
{
  struct remote_state *rs = get_remote_state ();
  int ret, bytes_read;
  char *attachment_tmp;

  if (!rs->remote_desc
      || remote_protocol_packets[which_packet].support == PACKET_DISABLE)
    {
      *remote_errno = FILEIO_ENOSYS;
      return -1;
    }

  putpkt_binary (rs->buf, command_bytes);
  bytes_read = getpkt_sane (&rs->buf, &rs->buf_size, 0);

  /* If it timed out, something is wrong.  Don't try to parse the
     buffer.  */
  if (bytes_read < 0)
    {
      *remote_errno = FILEIO_EINVAL;
      return -1;
    }

  switch (packet_ok (rs->buf, &remote_protocol_packets[which_packet]))
    {
    case PACKET_ERROR:
      *remote_errno = FILEIO_EINVAL;
      return -1;
    case PACKET_UNKNOWN:
      *remote_errno = FILEIO_ENOSYS;
      return -1;
    case PACKET_OK:
      break;
    }

  if (remote_hostio_parse_result (rs->buf, &ret, remote_errno,
				  &attachment_tmp))
    {
      *remote_errno = FILEIO_EINVAL;
      return -1;
    }

  /* Make sure we saw an attachment if and only if we expected one.  */
  if ((attachment_tmp == NULL && attachment != NULL)
      || (attachment_tmp != NULL && attachment == NULL))
    {
      *remote_errno = FILEIO_EINVAL;
      return -1;
    }

  /* If an attachment was found, it must point into the packet buffer;
     work out how many bytes there were.  */
  if (attachment_tmp != NULL)
    {
      *attachment = attachment_tmp;
      *attachment_len = bytes_read - (*attachment - rs->buf);
    }

  return ret;
}

/* Open FILENAME on the remote target, using FLAGS and MODE.  Return a
   remote file descriptor, or -1 if an error occurs (and set
   *REMOTE_ERRNO).  */

static int
remote_hostio_open (const char *filename, int flags, int mode,
		    int *remote_errno)
{
  struct remote_state *rs = get_remote_state ();
  char *p = rs->buf;
  int left = get_remote_packet_size () - 1;

  remote_buffer_add_string (&p, &left, "vFile:open:");

  remote_buffer_add_bytes (&p, &left, (const gdb_byte *) filename,
			   strlen (filename));
  remote_buffer_add_string (&p, &left, ",");

  remote_buffer_add_int (&p, &left, flags);
  remote_buffer_add_string (&p, &left, ",");

  remote_buffer_add_int (&p, &left, mode);

  return remote_hostio_send_command (p - rs->buf, PACKET_vFile_open,
				     remote_errno, NULL, NULL);
}

/* Write up to LEN bytes from WRITE_BUF to FD on the remote target.
   Return the number of bytes written, or -1 if an error occurs (and
   set *REMOTE_ERRNO).  */

static int
remote_hostio_pwrite (int fd, const gdb_byte *write_buf, int len,
		      ULONGEST offset, int *remote_errno)
{
  struct remote_state *rs = get_remote_state ();
  char *p = rs->buf;
  int left = get_remote_packet_size ();
  int out_len;

  remote_buffer_add_string (&p, &left, "vFile:pwrite:");

  remote_buffer_add_int (&p, &left, fd);
  remote_buffer_add_string (&p, &left, ",");

  remote_buffer_add_int (&p, &left, offset);
  remote_buffer_add_string (&p, &left, ",");

  p += remote_escape_output (write_buf, len, (gdb_byte *) p, &out_len,
			     get_remote_packet_size () - (p - rs->buf));

  return remote_hostio_send_command (p - rs->buf, PACKET_vFile_pwrite,
				     remote_errno, NULL, NULL);
}

/* Read up to LEN bytes FD on the remote target into READ_BUF
   Return the number of bytes read, or -1 if an error occurs (and
   set *REMOTE_ERRNO).  */

static int
remote_hostio_pread (int fd, gdb_byte *read_buf, int len,
		     ULONGEST offset, int *remote_errno)
{
  struct remote_state *rs = get_remote_state ();
  char *p = rs->buf;
  char *attachment;
  int left = get_remote_packet_size ();
  int ret, attachment_len;
  int read_len;

  remote_buffer_add_string (&p, &left, "vFile:pread:");

  remote_buffer_add_int (&p, &left, fd);
  remote_buffer_add_string (&p, &left, ",");

  remote_buffer_add_int (&p, &left, len);
  remote_buffer_add_string (&p, &left, ",");

  remote_buffer_add_int (&p, &left, offset);

  ret = remote_hostio_send_command (p - rs->buf, PACKET_vFile_pread,
				    remote_errno, &attachment,
				    &attachment_len);

  if (ret < 0)
    return ret;

  read_len = remote_unescape_input ((gdb_byte *) attachment, attachment_len,
				    read_buf, len);
  if (read_len != ret)
    error (_("Read returned %d, but %d bytes."), ret, (int) read_len);

  return ret;
}

/* Close FD on the remote target.  Return 0, or -1 if an error occurs
   (and set *REMOTE_ERRNO).  */

static int
remote_hostio_close (int fd, int *remote_errno)
{
  struct remote_state *rs = get_remote_state ();
  char *p = rs->buf;
  int left = get_remote_packet_size () - 1;

  remote_buffer_add_string (&p, &left, "vFile:close:");

  remote_buffer_add_int (&p, &left, fd);

  return remote_hostio_send_command (p - rs->buf, PACKET_vFile_close,
				     remote_errno, NULL, NULL);
}

/* Unlink FILENAME on the remote target.  Return 0, or -1 if an error
   occurs (and set *REMOTE_ERRNO).  */

static int
remote_hostio_unlink (const char *filename, int *remote_errno)
{
  struct remote_state *rs = get_remote_state ();
  char *p = rs->buf;
  int left = get_remote_packet_size () - 1;

  remote_buffer_add_string (&p, &left, "vFile:unlink:");

  remote_buffer_add_bytes (&p, &left, (const gdb_byte *) filename,
			   strlen (filename));

  return remote_hostio_send_command (p - rs->buf, PACKET_vFile_unlink,
				     remote_errno, NULL, NULL);
}

/* Read value of symbolic link FILENAME on the remote target.  Return
   a null-terminated string allocated via xmalloc, or NULL if an error
   occurs (and set *REMOTE_ERRNO).  */

static char *
remote_hostio_readlink (const char *filename, int *remote_errno)
{
  struct remote_state *rs = get_remote_state ();
  char *p = rs->buf;
  char *attachment;
  int left = get_remote_packet_size ();
  int len, attachment_len;
  int read_len;
  char *ret;

  remote_buffer_add_string (&p, &left, "vFile:readlink:");

  remote_buffer_add_bytes (&p, &left, (const gdb_byte *) filename,
			   strlen (filename));

  len = remote_hostio_send_command (p - rs->buf, PACKET_vFile_readlink,
				    remote_errno, &attachment,
				    &attachment_len);

  if (len < 0)
    return NULL;

  ret = xmalloc (len + 1);

  read_len = remote_unescape_input ((gdb_byte *) attachment, attachment_len,
				    (gdb_byte *) ret, len);
  if (read_len != len)
    error (_("Readlink returned %d, but %d bytes."), len, read_len);

  ret[len] = '\0';
  return ret;
}

static int
remote_fileio_errno_to_host (int errnum)
{
  switch (errnum)
    {
      case FILEIO_EPERM:
        return EPERM;
      case FILEIO_ENOENT:
        return ENOENT;
      case FILEIO_EINTR:
        return EINTR;
      case FILEIO_EIO:
        return EIO;
      case FILEIO_EBADF:
        return EBADF;
      case FILEIO_EACCES:
        return EACCES;
      case FILEIO_EFAULT:
        return EFAULT;
      case FILEIO_EBUSY:
        return EBUSY;
      case FILEIO_EEXIST:
        return EEXIST;
      case FILEIO_ENODEV:
        return ENODEV;
      case FILEIO_ENOTDIR:
        return ENOTDIR;
      case FILEIO_EISDIR:
        return EISDIR;
      case FILEIO_EINVAL:
        return EINVAL;
      case FILEIO_ENFILE:
        return ENFILE;
      case FILEIO_EMFILE:
        return EMFILE;
      case FILEIO_EFBIG:
        return EFBIG;
      case FILEIO_ENOSPC:
        return ENOSPC;
      case FILEIO_ESPIPE:
        return ESPIPE;
      case FILEIO_EROFS:
        return EROFS;
      case FILEIO_ENOSYS:
        return ENOSYS;
      case FILEIO_ENAMETOOLONG:
        return ENAMETOOLONG;
    }
  return -1;
}

static char *
remote_hostio_error (int errnum)
{
  int host_error = remote_fileio_errno_to_host (errnum);

  if (host_error == -1)
    error (_("Unknown remote I/O error %d"), errnum);
  else
    error (_("Remote I/O error: %s"), safe_strerror (host_error));
}

static void
remote_hostio_close_cleanup (void *opaque)
{
  int fd = *(int *) opaque;
  int remote_errno;

  remote_hostio_close (fd, &remote_errno);
}


static void *
remote_bfd_iovec_open (struct bfd *abfd, void *open_closure)
{
  const char *filename = bfd_get_filename (abfd);
  int fd, remote_errno;
  int *stream;

  gdb_assert (remote_filename_p (filename));

  fd = remote_hostio_open (filename + 7, FILEIO_O_RDONLY, 0, &remote_errno);
  if (fd == -1)
    {
      errno = remote_fileio_errno_to_host (remote_errno);
      bfd_set_error (bfd_error_system_call);
      return NULL;
    }

  stream = xmalloc (sizeof (int));
  *stream = fd;
  return stream;
}

static int
remote_bfd_iovec_close (struct bfd *abfd, void *stream)
{
  int fd = *(int *)stream;
  int remote_errno;

  xfree (stream);

  /* Ignore errors on close; these may happen if the remote
     connection was already torn down.  */
  remote_hostio_close (fd, &remote_errno);

  /* Zero means success.  */
  return 0;
}

static file_ptr
remote_bfd_iovec_pread (struct bfd *abfd, void *stream, void *buf,
			file_ptr nbytes, file_ptr offset)
{
  int fd = *(int *)stream;
  int remote_errno;
  file_ptr pos, bytes;

  pos = 0;
  while (nbytes > pos)
    {
      bytes = remote_hostio_pread (fd, (gdb_byte *) buf + pos, nbytes - pos,
				   offset + pos, &remote_errno);
      if (bytes == 0)
        /* Success, but no bytes, means end-of-file.  */
        break;
      if (bytes == -1)
	{
	  errno = remote_fileio_errno_to_host (remote_errno);
	  bfd_set_error (bfd_error_system_call);
	  return -1;
	}

      pos += bytes;
    }

  return pos;
}

static int
remote_bfd_iovec_stat (struct bfd *abfd, void *stream, struct stat *sb)
{
  /* FIXME: We should probably implement remote_hostio_stat.  */
  sb->st_size = INT_MAX;
  return 0;
}

int
remote_filename_p (const char *filename)
{
  return strncmp (filename,
		  REMOTE_SYSROOT_PREFIX,
		  sizeof (REMOTE_SYSROOT_PREFIX) - 1) == 0;
}

bfd *
remote_bfd_open (const char *remote_file, const char *target)
{
  bfd *abfd = gdb_bfd_openr_iovec (remote_file, target,
				   remote_bfd_iovec_open, NULL,
				   remote_bfd_iovec_pread,
				   remote_bfd_iovec_close,
				   remote_bfd_iovec_stat);

  return abfd;
}

void
remote_file_put (const char *local_file, const char *remote_file, int from_tty)
{
  struct cleanup *back_to, *close_cleanup;
  int retcode, fd, remote_errno, bytes, io_size;
  FILE *file;
  gdb_byte *buffer;
  int bytes_in_buffer;
  int saw_eof;
  ULONGEST offset;
  struct remote_state *rs = get_remote_state ();

  if (!rs->remote_desc)
    error (_("command can only be used with remote target"));

  file = gdb_fopen_cloexec (local_file, "rb");
  if (file == NULL)
    perror_with_name (local_file);
  back_to = make_cleanup_fclose (file);

  fd = remote_hostio_open (remote_file, (FILEIO_O_WRONLY | FILEIO_O_CREAT
					 | FILEIO_O_TRUNC),
			   0700, &remote_errno);
  if (fd == -1)
    remote_hostio_error (remote_errno);

  /* Send up to this many bytes at once.  They won't all fit in the
     remote packet limit, so we'll transfer slightly fewer.  */
  io_size = get_remote_packet_size ();
  buffer = xmalloc (io_size);
  make_cleanup (xfree, buffer);

  close_cleanup = make_cleanup (remote_hostio_close_cleanup, &fd);

  bytes_in_buffer = 0;
  saw_eof = 0;
  offset = 0;
  while (bytes_in_buffer || !saw_eof)
    {
      if (!saw_eof)
	{
	  bytes = fread (buffer + bytes_in_buffer, 1,
			 io_size - bytes_in_buffer,
			 file);
	  if (bytes == 0)
	    {
	      if (ferror (file))
		error (_("Error reading %s."), local_file);
	      else
		{
		  /* EOF.  Unless there is something still in the
		     buffer from the last iteration, we are done.  */
		  saw_eof = 1;
		  if (bytes_in_buffer == 0)
		    break;
		}
	    }
	}
      else
	bytes = 0;

      bytes += bytes_in_buffer;
      bytes_in_buffer = 0;

      retcode = remote_hostio_pwrite (fd, buffer, bytes,
				      offset, &remote_errno);

      if (retcode < 0)
	remote_hostio_error (remote_errno);
      else if (retcode == 0)
	error (_("Remote write of %d bytes returned 0!"), bytes);
      else if (retcode < bytes)
	{
	  /* Short write.  Save the rest of the read data for the next
	     write.  */
	  bytes_in_buffer = bytes - retcode;
	  memmove (buffer, buffer + retcode, bytes_in_buffer);
	}

      offset += retcode;
    }

  discard_cleanups (close_cleanup);
  if (remote_hostio_close (fd, &remote_errno))
    remote_hostio_error (remote_errno);

  if (from_tty)
    printf_filtered (_("Successfully sent file \"%s\".\n"), local_file);
  do_cleanups (back_to);
}

void
remote_file_get (const char *remote_file, const char *local_file, int from_tty)
{
  struct cleanup *back_to, *close_cleanup;
  int fd, remote_errno, bytes, io_size;
  FILE *file;
  gdb_byte *buffer;
  ULONGEST offset;
  struct remote_state *rs = get_remote_state ();

  if (!rs->remote_desc)
    error (_("command can only be used with remote target"));

  fd = remote_hostio_open (remote_file, FILEIO_O_RDONLY, 0, &remote_errno);
  if (fd == -1)
    remote_hostio_error (remote_errno);

  file = gdb_fopen_cloexec (local_file, "wb");
  if (file == NULL)
    perror_with_name (local_file);
  back_to = make_cleanup_fclose (file);

  /* Send up to this many bytes at once.  They won't all fit in the
     remote packet limit, so we'll transfer slightly fewer.  */
  io_size = get_remote_packet_size ();
  buffer = xmalloc (io_size);
  make_cleanup (xfree, buffer);

  close_cleanup = make_cleanup (remote_hostio_close_cleanup, &fd);

  offset = 0;
  while (1)
    {
      bytes = remote_hostio_pread (fd, buffer, io_size, offset, &remote_errno);
      if (bytes == 0)
	/* Success, but no bytes, means end-of-file.  */
	break;
      if (bytes == -1)
	remote_hostio_error (remote_errno);

      offset += bytes;

      bytes = fwrite (buffer, 1, bytes, file);
      if (bytes == 0)
	perror_with_name (local_file);
    }

  discard_cleanups (close_cleanup);
  if (remote_hostio_close (fd, &remote_errno))
    remote_hostio_error (remote_errno);

  if (from_tty)
    printf_filtered (_("Successfully fetched file \"%s\".\n"), remote_file);
  do_cleanups (back_to);
}

void
remote_file_delete (const char *remote_file, int from_tty)
{
  int retcode, remote_errno;
  struct remote_state *rs = get_remote_state ();

  if (!rs->remote_desc)
    error (_("command can only be used with remote target"));

  retcode = remote_hostio_unlink (remote_file, &remote_errno);
  if (retcode == -1)
    remote_hostio_error (remote_errno);

  if (from_tty)
    printf_filtered (_("Successfully deleted file \"%s\".\n"), remote_file);
}

static void
remote_put_command (char *args, int from_tty)
{
  struct cleanup *back_to;
  char **argv;

  if (args == NULL)
    error_no_arg (_("file to put"));

  argv = gdb_buildargv (args);
  back_to = make_cleanup_freeargv (argv);
  if (argv[0] == NULL || argv[1] == NULL || argv[2] != NULL)
    error (_("Invalid parameters to remote put"));

  remote_file_put (argv[0], argv[1], from_tty);

  do_cleanups (back_to);
}

static void
remote_get_command (char *args, int from_tty)
{
  struct cleanup *back_to;
  char **argv;

  if (args == NULL)
    error_no_arg (_("file to get"));

  argv = gdb_buildargv (args);
  back_to = make_cleanup_freeargv (argv);
  if (argv[0] == NULL || argv[1] == NULL || argv[2] != NULL)
    error (_("Invalid parameters to remote get"));

  remote_file_get (argv[0], argv[1], from_tty);

  do_cleanups (back_to);
}

static void
remote_delete_command (char *args, int from_tty)
{
  struct cleanup *back_to;
  char **argv;

  if (args == NULL)
    error_no_arg (_("file to delete"));

  argv = gdb_buildargv (args);
  back_to = make_cleanup_freeargv (argv);
  if (argv[0] == NULL || argv[1] != NULL)
    error (_("Invalid parameters to remote delete"));

  remote_file_delete (argv[0], from_tty);

  do_cleanups (back_to);
}

static void
remote_command (char *args, int from_tty)
{
  help_list (remote_cmdlist, "remote ", -1, gdb_stdout);
}

static int
remote_can_execute_reverse (void)
{
  if (remote_protocol_packets[PACKET_bs].support == PACKET_ENABLE
      || remote_protocol_packets[PACKET_bc].support == PACKET_ENABLE)
    return 1;
  else
    return 0;
}

static int
remote_supports_non_stop (void)
{
  return 1;
}

static int
remote_supports_disable_randomization (void)
{
  /* Only supported in extended mode.  */
  return 0;
}

static int
remote_supports_multi_process (void)
{
  struct remote_state *rs = get_remote_state ();

  /* Only extended-remote handles being attached to multiple
     processes, even though plain remote can use the multi-process
     thread id extensions, so that GDB knows the target process's
     PID.  */
  return rs->extended && remote_multi_process_p (rs);
}

static int
remote_supports_cond_tracepoints (void)
{
  struct remote_state *rs = get_remote_state ();

  return rs->cond_tracepoints;
}

static int
remote_supports_cond_breakpoints (void)
{
  struct remote_state *rs = get_remote_state ();

  return rs->cond_breakpoints;
}

static int
remote_supports_fast_tracepoints (void)
{
  struct remote_state *rs = get_remote_state ();

  return rs->fast_tracepoints;
}

static int
remote_supports_static_tracepoints (void)
{
  struct remote_state *rs = get_remote_state ();

  return rs->static_tracepoints;
}

static int
remote_supports_install_in_trace (void)
{
  struct remote_state *rs = get_remote_state ();

  return rs->install_in_trace;
}

static int
remote_supports_enable_disable_tracepoint (void)
{
  struct remote_state *rs = get_remote_state ();

  return rs->enable_disable_tracepoints;
}

static int
remote_supports_string_tracing (void)
{
  struct remote_state *rs = get_remote_state ();

  return rs->string_tracing;
}

static int
remote_can_run_breakpoint_commands (void)
{
  struct remote_state *rs = get_remote_state ();

  return rs->breakpoint_commands;
}

static void
remote_trace_init (void)
{
  putpkt ("QTinit");
  remote_get_noisy_reply (&target_buf, &target_buf_size);
  if (strcmp (target_buf, "OK") != 0)
    error (_("Target does not support this command."));
}

static void free_actions_list (char **actions_list);
static void free_actions_list_cleanup_wrapper (void *);
static void
free_actions_list_cleanup_wrapper (void *al)
{
  free_actions_list (al);
}

static void
free_actions_list (char **actions_list)
{
  int ndx;

  if (actions_list == 0)
    return;

  for (ndx = 0; actions_list[ndx]; ndx++)
    xfree (actions_list[ndx]);

  xfree (actions_list);
}

/* Recursive routine to walk through command list including loops, and
   download packets for each command.  */

static void
remote_download_command_source (int num, ULONGEST addr,
				struct command_line *cmds)
{
  struct remote_state *rs = get_remote_state ();
  struct command_line *cmd;

  for (cmd = cmds; cmd; cmd = cmd->next)
    {
      QUIT;	/* Allow user to bail out with ^C.  */
      strcpy (rs->buf, "QTDPsrc:");
      encode_source_string (num, addr, "cmd", cmd->line,
			    rs->buf + strlen (rs->buf),
			    rs->buf_size - strlen (rs->buf));
      putpkt (rs->buf);
      remote_get_noisy_reply (&target_buf, &target_buf_size);
      if (strcmp (target_buf, "OK"))
	warning (_("Target does not support source download."));

      if (cmd->control_type == while_control
	  || cmd->control_type == while_stepping_control)
	{
	  remote_download_command_source (num, addr, *cmd->body_list);

	  QUIT;	/* Allow user to bail out with ^C.  */
	  strcpy (rs->buf, "QTDPsrc:");
	  encode_source_string (num, addr, "cmd", "end",
				rs->buf + strlen (rs->buf),
				rs->buf_size - strlen (rs->buf));
	  putpkt (rs->buf);
	  remote_get_noisy_reply (&target_buf, &target_buf_size);
	  if (strcmp (target_buf, "OK"))
	    warning (_("Target does not support source download."));
	}
    }
}

static void
remote_download_tracepoint (struct bp_location *loc)
{
#define BUF_SIZE 2048

  CORE_ADDR tpaddr;
  char addrbuf[40];
  char buf[BUF_SIZE];
  char **tdp_actions;
  char **stepping_actions;
  int ndx;
  struct cleanup *old_chain = NULL;
  struct agent_expr *aexpr;
  struct cleanup *aexpr_chain = NULL;
  char *pkt;
  struct breakpoint *b = loc->owner;
  struct tracepoint *t = (struct tracepoint *) b;

  encode_actions_rsp (loc, &tdp_actions, &stepping_actions);
  old_chain = make_cleanup (free_actions_list_cleanup_wrapper,
			    tdp_actions);
  (void) make_cleanup (free_actions_list_cleanup_wrapper,
		       stepping_actions);

  tpaddr = loc->address;
  sprintf_vma (addrbuf, tpaddr);
  xsnprintf (buf, BUF_SIZE, "QTDP:%x:%s:%c:%lx:%x", b->number,
	     addrbuf, /* address */
	     (b->enable_state == bp_enabled ? 'E' : 'D'),
	     t->step_count, t->pass_count);
  /* Fast tracepoints are mostly handled by the target, but we can
     tell the target how big of an instruction block should be moved
     around.  */
  if (b->type == bp_fast_tracepoint)
    {
      /* Only test for support at download time; we may not know
	 target capabilities at definition time.  */
      if (remote_supports_fast_tracepoints ())
	{
	  int isize;

	  if (gdbarch_fast_tracepoint_valid_at (target_gdbarch (),
						tpaddr, &isize, NULL))
	    xsnprintf (buf + strlen (buf), BUF_SIZE - strlen (buf), ":F%x",
		       isize);
	  else
	    /* If it passed validation at definition but fails now,
	       something is very wrong.  */
	    internal_error (__FILE__, __LINE__,
			    _("Fast tracepoint not "
			      "valid during download"));
	}
      else
	/* Fast tracepoints are functionally identical to regular
	   tracepoints, so don't take lack of support as a reason to
	   give up on the trace run.  */
	warning (_("Target does not support fast tracepoints, "
		   "downloading %d as regular tracepoint"), b->number);
    }
  else if (b->type == bp_static_tracepoint)
    {
      /* Only test for support at download time; we may not know
	 target capabilities at definition time.  */
      if (remote_supports_static_tracepoints ())
	{
	  struct static_tracepoint_marker marker;

	  if (target_static_tracepoint_marker_at (tpaddr, &marker))
	    strcat (buf, ":S");
	  else
	    error (_("Static tracepoint not valid during download"));
	}
      else
	/* Fast tracepoints are functionally identical to regular
	   tracepoints, so don't take lack of support as a reason
	   to give up on the trace run.  */
	error (_("Target does not support static tracepoints"));
    }
  /* If the tracepoint has a conditional, make it into an agent
     expression and append to the definition.  */
  if (loc->cond)
    {
      /* Only test support at download time, we may not know target
	 capabilities at definition time.  */
      if (remote_supports_cond_tracepoints ())
	{
	  aexpr = gen_eval_for_expr (tpaddr, loc->cond);
	  aexpr_chain = make_cleanup_free_agent_expr (aexpr);
	  xsnprintf (buf + strlen (buf), BUF_SIZE - strlen (buf), ":X%x,",
		     aexpr->len);
	  pkt = buf + strlen (buf);
	  for (ndx = 0; ndx < aexpr->len; ++ndx)
	    pkt = pack_hex_byte (pkt, aexpr->buf[ndx]);
	  *pkt = '\0';
	  do_cleanups (aexpr_chain);
	}
      else
	warning (_("Target does not support conditional tracepoints, "
		   "ignoring tp %d cond"), b->number);
    }

  if (b->commands || *default_collect)
    strcat (buf, "-");
  putpkt (buf);
  remote_get_noisy_reply (&target_buf, &target_buf_size);
  if (strcmp (target_buf, "OK"))
    error (_("Target does not support tracepoints."));

  /* do_single_steps (t); */
  if (tdp_actions)
    {
      for (ndx = 0; tdp_actions[ndx]; ndx++)
	{
	  QUIT;	/* Allow user to bail out with ^C.  */
	  xsnprintf (buf, BUF_SIZE, "QTDP:-%x:%s:%s%c",
		     b->number, addrbuf, /* address */
		     tdp_actions[ndx],
		     ((tdp_actions[ndx + 1] || stepping_actions)
		      ? '-' : 0));
	  putpkt (buf);
	  remote_get_noisy_reply (&target_buf,
				  &target_buf_size);
	  if (strcmp (target_buf, "OK"))
	    error (_("Error on target while setting tracepoints."));
	}
    }
  if (stepping_actions)
    {
      for (ndx = 0; stepping_actions[ndx]; ndx++)
	{
	  QUIT;	/* Allow user to bail out with ^C.  */
	  xsnprintf (buf, BUF_SIZE, "QTDP:-%x:%s:%s%s%s",
		     b->number, addrbuf, /* address */
		     ((ndx == 0) ? "S" : ""),
		     stepping_actions[ndx],
		     (stepping_actions[ndx + 1] ? "-" : ""));
	  putpkt (buf);
	  remote_get_noisy_reply (&target_buf,
				  &target_buf_size);
	  if (strcmp (target_buf, "OK"))
	    error (_("Error on target while setting tracepoints."));
	}
    }

  if (remote_protocol_packets[PACKET_TracepointSource].support
      == PACKET_ENABLE)
    {
      if (b->addr_string)
	{
	  strcpy (buf, "QTDPsrc:");
	  encode_source_string (b->number, loc->address,
				"at", b->addr_string, buf + strlen (buf),
				2048 - strlen (buf));

	  putpkt (buf);
	  remote_get_noisy_reply (&target_buf, &target_buf_size);
	  if (strcmp (target_buf, "OK"))
	    warning (_("Target does not support source download."));
	}
      if (b->cond_string)
	{
	  strcpy (buf, "QTDPsrc:");
	  encode_source_string (b->number, loc->address,
				"cond", b->cond_string, buf + strlen (buf),
				2048 - strlen (buf));
	  putpkt (buf);
	  remote_get_noisy_reply (&target_buf, &target_buf_size);
	  if (strcmp (target_buf, "OK"))
	    warning (_("Target does not support source download."));
	}
      remote_download_command_source (b->number, loc->address,
				      breakpoint_commands (b));
    }

  do_cleanups (old_chain);
}

static int
remote_can_download_tracepoint (void)
{
  struct remote_state *rs = get_remote_state ();
  struct trace_status *ts;
  int status;

  /* Don't try to install tracepoints until we've relocated our
     symbols, and fetched and merged the target's tracepoint list with
     ours.  */
  if (rs->starting_up)
    return 0;

  ts = current_trace_status ();
  status = remote_get_trace_status (ts);

  if (status == -1 || !ts->running_known || !ts->running)
    return 0;

  /* If we are in a tracing experiment, but remote stub doesn't support
     installing tracepoint in trace, we have to return.  */
  if (!remote_supports_install_in_trace ())
    return 0;

  return 1;
}


static void
remote_download_trace_state_variable (struct trace_state_variable *tsv)
{
  struct remote_state *rs = get_remote_state ();
  char *p;

  xsnprintf (rs->buf, get_remote_packet_size (), "QTDV:%x:%s:%x:",
	     tsv->number, phex ((ULONGEST) tsv->initial_value, 8),
	     tsv->builtin);
  p = rs->buf + strlen (rs->buf);
  if ((p - rs->buf) + strlen (tsv->name) * 2 >= get_remote_packet_size ())
    error (_("Trace state variable name too long for tsv definition packet"));
  p += 2 * bin2hex ((gdb_byte *) (tsv->name), p, 0);
  *p++ = '\0';
  putpkt (rs->buf);
  remote_get_noisy_reply (&target_buf, &target_buf_size);
  if (*target_buf == '\0')
    error (_("Target does not support this command."));
  if (strcmp (target_buf, "OK") != 0)
    error (_("Error on target while downloading trace state variable."));
}

static void
remote_enable_tracepoint (struct bp_location *location)
{
  struct remote_state *rs = get_remote_state ();
  char addr_buf[40];

  sprintf_vma (addr_buf, location->address);
  xsnprintf (rs->buf, get_remote_packet_size (), "QTEnable:%x:%s",
	     location->owner->number, addr_buf);
  putpkt (rs->buf);
  remote_get_noisy_reply (&rs->buf, &rs->buf_size);
  if (*rs->buf == '\0')
    error (_("Target does not support enabling tracepoints while a trace run is ongoing."));
  if (strcmp (rs->buf, "OK") != 0)
    error (_("Error on target while enabling tracepoint."));
}

static void
remote_disable_tracepoint (struct bp_location *location)
{
  struct remote_state *rs = get_remote_state ();
  char addr_buf[40];

  sprintf_vma (addr_buf, location->address);
  xsnprintf (rs->buf, get_remote_packet_size (), "QTDisable:%x:%s",
	     location->owner->number, addr_buf);
  putpkt (rs->buf);
  remote_get_noisy_reply (&rs->buf, &rs->buf_size);
  if (*rs->buf == '\0')
    error (_("Target does not support disabling tracepoints while a trace run is ongoing."));
  if (strcmp (rs->buf, "OK") != 0)
    error (_("Error on target while disabling tracepoint."));
}

static void
remote_trace_set_readonly_regions (void)
{
  asection *s;
  bfd *abfd = NULL;
  bfd_size_type size;
  bfd_vma vma;
  int anysecs = 0;
  int offset = 0;

  if (!exec_bfd)
    return;			/* No information to give.  */

  strcpy (target_buf, "QTro");
  offset = strlen (target_buf);
  for (s = exec_bfd->sections; s; s = s->next)
    {
      char tmp1[40], tmp2[40];
      int sec_length;

      if ((s->flags & SEC_LOAD) == 0 ||
      /*  (s->flags & SEC_CODE) == 0 || */
	  (s->flags & SEC_READONLY) == 0)
	continue;

      anysecs = 1;
      vma = bfd_get_section_vma (abfd, s);
      size = bfd_get_section_size (s);
      sprintf_vma (tmp1, vma);
      sprintf_vma (tmp2, vma + size);
      sec_length = 1 + strlen (tmp1) + 1 + strlen (tmp2);
      if (offset + sec_length + 1 > target_buf_size)
	{
	  if (remote_protocol_packets[PACKET_qXfer_traceframe_info].support
	      != PACKET_ENABLE)
	    warning (_("\
Too many sections for read-only sections definition packet."));
	  break;
	}
      xsnprintf (target_buf + offset, target_buf_size - offset, ":%s,%s",
		 tmp1, tmp2);
      offset += sec_length;
    }
  if (anysecs)
    {
      putpkt (target_buf);
      getpkt (&target_buf, &target_buf_size, 0);
    }
}

static void
remote_trace_start (void)
{
  putpkt ("QTStart");
  remote_get_noisy_reply (&target_buf, &target_buf_size);
  if (*target_buf == '\0')
    error (_("Target does not support this command."));
  if (strcmp (target_buf, "OK") != 0)
    error (_("Bogus reply from target: %s"), target_buf);
}

static int
remote_get_trace_status (struct trace_status *ts)
{
  /* Initialize it just to avoid a GCC false warning.  */
  char *p = NULL;
  /* FIXME we need to get register block size some other way.  */
  extern int trace_regblock_size;
  volatile struct gdb_exception ex;
  enum packet_result result;

  if (remote_protocol_packets[PACKET_qTStatus].support == PACKET_DISABLE)
    return -1;

  trace_regblock_size = get_remote_arch_state ()->sizeof_g_packet;

  putpkt ("qTStatus");

  TRY_CATCH (ex, RETURN_MASK_ERROR)
    {
      p = remote_get_noisy_reply (&target_buf, &target_buf_size);
    }
  if (ex.reason < 0)
    {
      if (ex.error != TARGET_CLOSE_ERROR)
	{
	  exception_fprintf (gdb_stderr, ex, "qTStatus: ");
	  return -1;
	}
      throw_exception (ex);
    }

  result = packet_ok (p, &remote_protocol_packets[PACKET_qTStatus]);

  /* If the remote target doesn't do tracing, flag it.  */
  if (result == PACKET_UNKNOWN)
    return -1;

  /* We're working with a live target.  */
  ts->filename = NULL;

  if (*p++ != 'T')
    error (_("Bogus trace status reply from target: %s"), target_buf);

  /* Function 'parse_trace_status' sets default value of each field of
     'ts' at first, so we don't have to do it here.  */
  parse_trace_status (p, ts);

  return ts->running;
}

static void
remote_get_tracepoint_status (struct breakpoint *bp,
			      struct uploaded_tp *utp)
{
  struct remote_state *rs = get_remote_state ();
  char *reply;
  struct bp_location *loc;
  struct tracepoint *tp = (struct tracepoint *) bp;
  size_t size = get_remote_packet_size ();

  if (tp)
    {
      tp->base.hit_count = 0;
      tp->traceframe_usage = 0;
      for (loc = tp->base.loc; loc; loc = loc->next)
	{
	  /* If the tracepoint was never downloaded, don't go asking for
	     any status.  */
	  if (tp->number_on_target == 0)
	    continue;
	  xsnprintf (rs->buf, size, "qTP:%x:%s", tp->number_on_target,
		     phex_nz (loc->address, 0));
	  putpkt (rs->buf);
	  reply = remote_get_noisy_reply (&target_buf, &target_buf_size);
	  if (reply && *reply)
	    {
	      if (*reply == 'V')
		parse_tracepoint_status (reply + 1, bp, utp);
	    }
	}
    }
  else if (utp)
    {
      utp->hit_count = 0;
      utp->traceframe_usage = 0;
      xsnprintf (rs->buf, size, "qTP:%x:%s", utp->number,
		 phex_nz (utp->addr, 0));
      putpkt (rs->buf);
      reply = remote_get_noisy_reply (&target_buf, &target_buf_size);
      if (reply && *reply)
	{
	  if (*reply == 'V')
	    parse_tracepoint_status (reply + 1, bp, utp);
	}
    }
}

static void
remote_trace_stop (void)
{
  putpkt ("QTStop");
  remote_get_noisy_reply (&target_buf, &target_buf_size);
  if (*target_buf == '\0')
    error (_("Target does not support this command."));
  if (strcmp (target_buf, "OK") != 0)
    error (_("Bogus reply from target: %s"), target_buf);
}

static int
remote_trace_find (enum trace_find_type type, int num,
		   CORE_ADDR addr1, CORE_ADDR addr2,
		   int *tpp)
{
  struct remote_state *rs = get_remote_state ();
  char *endbuf = rs->buf + get_remote_packet_size ();
  char *p, *reply;
  int target_frameno = -1, target_tracept = -1;

  /* Lookups other than by absolute frame number depend on the current
     trace selected, so make sure it is correct on the remote end
     first.  */
  if (type != tfind_number)
    set_remote_traceframe ();

  p = rs->buf;
  strcpy (p, "QTFrame:");
  p = strchr (p, '\0');
  switch (type)
    {
    case tfind_number:
      xsnprintf (p, endbuf - p, "%x", num);
      break;
    case tfind_pc:
      xsnprintf (p, endbuf - p, "pc:%s", phex_nz (addr1, 0));
      break;
    case tfind_tp:
      xsnprintf (p, endbuf - p, "tdp:%x", num);
      break;
    case tfind_range:
      xsnprintf (p, endbuf - p, "range:%s:%s", phex_nz (addr1, 0),
		 phex_nz (addr2, 0));
      break;
    case tfind_outside:
      xsnprintf (p, endbuf - p, "outside:%s:%s", phex_nz (addr1, 0),
		 phex_nz (addr2, 0));
      break;
    default:
      error (_("Unknown trace find type %d"), type);
    }

  putpkt (rs->buf);
  reply = remote_get_noisy_reply (&(rs->buf), &rs->buf_size);
  if (*reply == '\0')
    error (_("Target does not support this command."));

  while (reply && *reply)
    switch (*reply)
      {
      case 'F':
	p = ++reply;
	target_frameno = (int) strtol (p, &reply, 16);
	if (reply == p)
	  error (_("Unable to parse trace frame number"));
	/* Don't update our remote traceframe number cache on failure
	   to select a remote traceframe.  */
	if (target_frameno == -1)
	  return -1;
	break;
      case 'T':
	p = ++reply;
	target_tracept = (int) strtol (p, &reply, 16);
	if (reply == p)
	  error (_("Unable to parse tracepoint number"));
	break;
      case 'O':		/* "OK"? */
	if (reply[1] == 'K' && reply[2] == '\0')
	  reply += 2;
	else
	  error (_("Bogus reply from target: %s"), reply);
	break;
      default:
	error (_("Bogus reply from target: %s"), reply);
      }
  if (tpp)
    *tpp = target_tracept;

  rs->remote_traceframe_number = target_frameno;
  return target_frameno;
}

static int
remote_get_trace_state_variable_value (int tsvnum, LONGEST *val)
{
  struct remote_state *rs = get_remote_state ();
  char *reply;
  ULONGEST uval;

  set_remote_traceframe ();

  xsnprintf (rs->buf, get_remote_packet_size (), "qTV:%x", tsvnum);
  putpkt (rs->buf);
  reply = remote_get_noisy_reply (&target_buf, &target_buf_size);
  if (reply && *reply)
    {
      if (*reply == 'V')
	{
	  unpack_varlen_hex (reply + 1, &uval);
	  *val = (LONGEST) uval;
	  return 1;
	}
    }
  return 0;
}

static int
remote_save_trace_data (const char *filename)
{
  struct remote_state *rs = get_remote_state ();
  char *p, *reply;

  p = rs->buf;
  strcpy (p, "QTSave:");
  p += strlen (p);
  if ((p - rs->buf) + strlen (filename) * 2 >= get_remote_packet_size ())
    error (_("Remote file name too long for trace save packet"));
  p += 2 * bin2hex ((gdb_byte *) filename, p, 0);
  *p++ = '\0';
  putpkt (rs->buf);
  reply = remote_get_noisy_reply (&target_buf, &target_buf_size);
  if (*reply == '\0')
    error (_("Target does not support this command."));
  if (strcmp (reply, "OK") != 0)
    error (_("Bogus reply from target: %s"), reply);
  return 0;
}

/* This is basically a memory transfer, but needs to be its own packet
   because we don't know how the target actually organizes its trace
   memory, plus we want to be able to ask for as much as possible, but
   not be unhappy if we don't get as much as we ask for.  */

static LONGEST
remote_get_raw_trace_data (gdb_byte *buf, ULONGEST offset, LONGEST len)
{
  struct remote_state *rs = get_remote_state ();
  char *reply;
  char *p;
  int rslt;

  p = rs->buf;
  strcpy (p, "qTBuffer:");
  p += strlen (p);
  p += hexnumstr (p, offset);
  *p++ = ',';
  p += hexnumstr (p, len);
  *p++ = '\0';

  putpkt (rs->buf);
  reply = remote_get_noisy_reply (&target_buf, &target_buf_size);
  if (reply && *reply)
    {
      /* 'l' by itself means we're at the end of the buffer and
	 there is nothing more to get.  */
      if (*reply == 'l')
	return 0;

      /* Convert the reply into binary.  Limit the number of bytes to
	 convert according to our passed-in buffer size, rather than
	 what was returned in the packet; if the target is
	 unexpectedly generous and gives us a bigger reply than we
	 asked for, we don't want to crash.  */
      rslt = hex2bin (target_buf, buf, len);
      return rslt;
    }

  /* Something went wrong, flag as an error.  */
  return -1;
}

static void
remote_set_disconnected_tracing (int val)
{
  struct remote_state *rs = get_remote_state ();

  if (rs->disconnected_tracing)
    {
      char *reply;

      xsnprintf (rs->buf, get_remote_packet_size (), "QTDisconnected:%x", val);
      putpkt (rs->buf);
      reply = remote_get_noisy_reply (&target_buf, &target_buf_size);
      if (*reply == '\0')
	error (_("Target does not support this command."));
      if (strcmp (reply, "OK") != 0)
        error (_("Bogus reply from target: %s"), reply);
    }
  else if (val)
    warning (_("Target does not support disconnected tracing."));
}

static int
remote_core_of_thread (struct target_ops *ops, ptid_t ptid)
{
  struct thread_info *info = find_thread_ptid (ptid);

  if (info && info->private)
    return info->private->core;
  return -1;
}

static void
remote_set_circular_trace_buffer (int val)
{
  struct remote_state *rs = get_remote_state ();
  char *reply;

  xsnprintf (rs->buf, get_remote_packet_size (), "QTBuffer:circular:%x", val);
  putpkt (rs->buf);
  reply = remote_get_noisy_reply (&target_buf, &target_buf_size);
  if (*reply == '\0')
    error (_("Target does not support this command."));
  if (strcmp (reply, "OK") != 0)
    error (_("Bogus reply from target: %s"), reply);
}

static struct traceframe_info *
remote_traceframe_info (void)
{
  char *text;

  text = target_read_stralloc (&current_target,
			       TARGET_OBJECT_TRACEFRAME_INFO, NULL);
  if (text != NULL)
    {
      struct traceframe_info *info;
      struct cleanup *back_to = make_cleanup (xfree, text);

      info = parse_traceframe_info (text);
      do_cleanups (back_to);
      return info;
    }

  return NULL;
}

/* Handle the qTMinFTPILen packet.  Returns the minimum length of
   instruction on which a fast tracepoint may be placed.  Returns -1
   if the packet is not supported, and 0 if the minimum instruction
   length is unknown.  */

static int
remote_get_min_fast_tracepoint_insn_len (void)
{
  struct remote_state *rs = get_remote_state ();
  char *reply;

  /* If we're not debugging a process yet, the IPA can't be
     loaded.  */
  if (!target_has_execution)
    return 0;

  /* Make sure the remote is pointing at the right process.  */
  set_general_process ();

  xsnprintf (rs->buf, get_remote_packet_size (), "qTMinFTPILen");
  putpkt (rs->buf);
  reply = remote_get_noisy_reply (&target_buf, &target_buf_size);
  if (*reply == '\0')
    return -1;
  else
    {
      ULONGEST min_insn_len;

      unpack_varlen_hex (reply, &min_insn_len);

      return (int) min_insn_len;
    }
}

static void
remote_set_trace_buffer_size (LONGEST val)
{
  if (remote_protocol_packets[PACKET_QTBuffer_size].support
      != PACKET_DISABLE)
    {
      struct remote_state *rs = get_remote_state ();
      char *buf = rs->buf;
      char *endbuf = rs->buf + get_remote_packet_size ();
      enum packet_result result;

      gdb_assert (val >= 0 || val == -1);
      buf += xsnprintf (buf, endbuf - buf, "QTBuffer:size:");
      /* Send -1 as literal "-1" to avoid host size dependency.  */
      if (val < 0)
	{
	  *buf++ = '-';
          buf += hexnumstr (buf, (ULONGEST) -val);
	}
      else
	buf += hexnumstr (buf, (ULONGEST) val);

      putpkt (rs->buf);
      remote_get_noisy_reply (&rs->buf, &rs->buf_size);
      result = packet_ok (rs->buf,
		  &remote_protocol_packets[PACKET_QTBuffer_size]);

      if (result != PACKET_OK)
	warning (_("Bogus reply from target: %s"), rs->buf);
    }
}

static int
remote_set_trace_notes (const char *user, const char *notes,
			const char *stop_notes)
{
  struct remote_state *rs = get_remote_state ();
  char *reply;
  char *buf = rs->buf;
  char *endbuf = rs->buf + get_remote_packet_size ();
  int nbytes;

  buf += xsnprintf (buf, endbuf - buf, "QTNotes:");
  if (user)
    {
      buf += xsnprintf (buf, endbuf - buf, "user:");
      nbytes = bin2hex ((gdb_byte *) user, buf, 0);
      buf += 2 * nbytes;
      *buf++ = ';';
    }
  if (notes)
    {
      buf += xsnprintf (buf, endbuf - buf, "notes:");
      nbytes = bin2hex ((gdb_byte *) notes, buf, 0);
      buf += 2 * nbytes;
      *buf++ = ';';
    }
  if (stop_notes)
    {
      buf += xsnprintf (buf, endbuf - buf, "tstop:");
      nbytes = bin2hex ((gdb_byte *) stop_notes, buf, 0);
      buf += 2 * nbytes;
      *buf++ = ';';
    }
  /* Ensure the buffer is terminated.  */
  *buf = '\0';

  putpkt (rs->buf);
  reply = remote_get_noisy_reply (&target_buf, &target_buf_size);
  if (*reply == '\0')
    return 0;

  if (strcmp (reply, "OK") != 0)
    error (_("Bogus reply from target: %s"), reply);

  return 1;
}

static int
remote_use_agent (int use)
{
  if (remote_protocol_packets[PACKET_QAgent].support != PACKET_DISABLE)
    {
      struct remote_state *rs = get_remote_state ();

      /* If the stub supports QAgent.  */
      xsnprintf (rs->buf, get_remote_packet_size (), "QAgent:%d", use);
      putpkt (rs->buf);
      getpkt (&rs->buf, &rs->buf_size, 0);

      if (strcmp (rs->buf, "OK") == 0)
	{
	  use_agent = use;
	  return 1;
	}
    }

  return 0;
}

static int
remote_can_use_agent (void)
{
  return (remote_protocol_packets[PACKET_QAgent].support != PACKET_DISABLE);
}

struct btrace_target_info
{
  /* The ptid of the traced thread.  */
  ptid_t ptid;
};

/* Check whether the target supports branch tracing.  */

static int
remote_supports_btrace (void)
{
  if (remote_protocol_packets[PACKET_Qbtrace_off].support != PACKET_ENABLE)
    return 0;
  if (remote_protocol_packets[PACKET_Qbtrace_bts].support != PACKET_ENABLE)
    return 0;
  if (remote_protocol_packets[PACKET_qXfer_btrace].support != PACKET_ENABLE)
    return 0;

  return 1;
}

/* Enable branch tracing.  */

static struct btrace_target_info *
remote_enable_btrace (ptid_t ptid)
{
  struct btrace_target_info *tinfo = NULL;
  struct packet_config *packet = &remote_protocol_packets[PACKET_Qbtrace_bts];
  struct remote_state *rs = get_remote_state ();
  char *buf = rs->buf;
  char *endbuf = rs->buf + get_remote_packet_size ();

  if (packet->support != PACKET_ENABLE)
    error (_("Target does not support branch tracing."));

  set_general_thread (ptid);

  buf += xsnprintf (buf, endbuf - buf, "%s", packet->name);
  putpkt (rs->buf);
  getpkt (&rs->buf, &rs->buf_size, 0);

  if (packet_ok (rs->buf, packet) == PACKET_ERROR)
    {
      if (rs->buf[0] == 'E' && rs->buf[1] == '.')
	error (_("Could not enable branch tracing for %s: %s"),
	       target_pid_to_str (ptid), rs->buf + 2);
      else
	error (_("Could not enable branch tracing for %s."),
	       target_pid_to_str (ptid));
    }

  tinfo = xzalloc (sizeof (*tinfo));
  tinfo->ptid = ptid;

  return tinfo;
}

/* Disable branch tracing.  */

static void
remote_disable_btrace (struct btrace_target_info *tinfo)
{
  struct packet_config *packet = &remote_protocol_packets[PACKET_Qbtrace_off];
  struct remote_state *rs = get_remote_state ();
  char *buf = rs->buf;
  char *endbuf = rs->buf + get_remote_packet_size ();

  if (packet->support != PACKET_ENABLE)
    error (_("Target does not support branch tracing."));

  set_general_thread (tinfo->ptid);

  buf += xsnprintf (buf, endbuf - buf, "%s", packet->name);
  putpkt (rs->buf);
  getpkt (&rs->buf, &rs->buf_size, 0);

  if (packet_ok (rs->buf, packet) == PACKET_ERROR)
    {
      if (rs->buf[0] == 'E' && rs->buf[1] == '.')
	error (_("Could not disable branch tracing for %s: %s"),
	       target_pid_to_str (tinfo->ptid), rs->buf + 2);
      else
	error (_("Could not disable branch tracing for %s."),
	       target_pid_to_str (tinfo->ptid));
    }

  xfree (tinfo);
}

/* Teardown branch tracing.  */

static void
remote_teardown_btrace (struct btrace_target_info *tinfo)
{
  /* We must not talk to the target during teardown.  */
  xfree (tinfo);
}

/* Read the branch trace.  */

static VEC (btrace_block_s) *
remote_read_btrace (struct btrace_target_info *tinfo,
		    enum btrace_read_type type)
{
  struct packet_config *packet = &remote_protocol_packets[PACKET_qXfer_btrace];
  struct remote_state *rs = get_remote_state ();
  VEC (btrace_block_s) *btrace = NULL;
  const char *annex;
  char *xml;

  if (packet->support != PACKET_ENABLE)
    error (_("Target does not support branch tracing."));

#if !defined(HAVE_LIBEXPAT)
  error (_("Cannot process branch tracing result. XML parsing not supported."));
#endif

  switch (type)
    {
    case btrace_read_all:
      annex = "all";
      break;
    case btrace_read_new:
      annex = "new";
      break;
    default:
      internal_error (__FILE__, __LINE__,
		      _("Bad branch tracing read type: %u."),
		      (unsigned int) type);
    }

  xml = target_read_stralloc (&current_target,
                              TARGET_OBJECT_BTRACE, annex);
  if (xml != NULL)
    {
      struct cleanup *cleanup = make_cleanup (xfree, xml);

      btrace = parse_xml_btrace (xml);
      do_cleanups (cleanup);
    }

  return btrace;
}

static int
remote_augmented_libraries_svr4_read (void)
{
  struct remote_state *rs = get_remote_state ();

  return rs->augmented_libraries_svr4_read;
}

static void
init_remote_ops (void)
{
  remote_ops.to_shortname = "remote";
  remote_ops.to_longname = "Remote serial target in gdb-specific protocol";
  remote_ops.to_doc =
    "Use a remote computer via a serial line, using a gdb-specific protocol.\n\
Specify the serial device it is connected to\n\
(e.g. /dev/ttyS0, /dev/ttya, COM1, etc.).";
  remote_ops.to_open = remote_open;
  remote_ops.to_close = remote_close;
  remote_ops.to_detach = remote_detach;
  remote_ops.to_disconnect = remote_disconnect;
  remote_ops.to_resume = remote_resume;
  remote_ops.to_wait = remote_wait;
  remote_ops.to_fetch_registers = remote_fetch_registers;
  remote_ops.to_store_registers = remote_store_registers;
  remote_ops.to_prepare_to_store = remote_prepare_to_store;
  remote_ops.to_files_info = remote_files_info;
  remote_ops.to_insert_breakpoint = remote_insert_breakpoint;
  remote_ops.to_remove_breakpoint = remote_remove_breakpoint;
  remote_ops.to_stopped_by_watchpoint = remote_stopped_by_watchpoint;
  remote_ops.to_stopped_data_address = remote_stopped_data_address;
  remote_ops.to_watchpoint_addr_within_range =
    remote_watchpoint_addr_within_range;
  remote_ops.to_can_use_hw_breakpoint = remote_check_watch_resources;
  remote_ops.to_insert_hw_breakpoint = remote_insert_hw_breakpoint;
  remote_ops.to_remove_hw_breakpoint = remote_remove_hw_breakpoint;
  remote_ops.to_region_ok_for_hw_watchpoint
     = remote_region_ok_for_hw_watchpoint;
  remote_ops.to_insert_watchpoint = remote_insert_watchpoint;
  remote_ops.to_remove_watchpoint = remote_remove_watchpoint;
  remote_ops.to_kill = remote_kill;
  remote_ops.to_load = generic_load;
  remote_ops.to_mourn_inferior = remote_mourn;
  remote_ops.to_pass_signals = remote_pass_signals;
  remote_ops.to_program_signals = remote_program_signals;
  remote_ops.to_thread_alive = remote_thread_alive;
  remote_ops.to_find_new_threads = remote_threads_info;
  remote_ops.to_pid_to_str = remote_pid_to_str;
  remote_ops.to_extra_thread_info = remote_threads_extra_info;
  remote_ops.to_get_ada_task_ptid = remote_get_ada_task_ptid;
  remote_ops.to_stop = remote_stop;
  remote_ops.to_xfer_partial = remote_xfer_partial;
  remote_ops.to_rcmd = remote_rcmd;
  remote_ops.to_log_command = serial_log_command;
  remote_ops.to_get_thread_local_address = remote_get_thread_local_address;
  remote_ops.to_stratum = process_stratum;
  remote_ops.to_has_all_memory = default_child_has_all_memory;
  remote_ops.to_has_memory = default_child_has_memory;
  remote_ops.to_has_stack = default_child_has_stack;
  remote_ops.to_has_registers = default_child_has_registers;
  remote_ops.to_has_execution = default_child_has_execution;
  remote_ops.to_has_thread_control = tc_schedlock;    /* can lock scheduler */
  remote_ops.to_can_execute_reverse = remote_can_execute_reverse;
  remote_ops.to_magic = OPS_MAGIC;
  remote_ops.to_memory_map = remote_memory_map;
  remote_ops.to_flash_erase = remote_flash_erase;
  remote_ops.to_flash_done = remote_flash_done;
  remote_ops.to_read_description = remote_read_description;
  remote_ops.to_search_memory = remote_search_memory;
  remote_ops.to_can_async_p = remote_can_async_p;
  remote_ops.to_is_async_p = remote_is_async_p;
  remote_ops.to_async = remote_async;
  remote_ops.to_terminal_inferior = remote_terminal_inferior;
  remote_ops.to_terminal_ours = remote_terminal_ours;
  remote_ops.to_supports_non_stop = remote_supports_non_stop;
  remote_ops.to_supports_multi_process = remote_supports_multi_process;
  remote_ops.to_supports_disable_randomization
    = remote_supports_disable_randomization;
  remote_ops.to_fileio_open = remote_hostio_open;
  remote_ops.to_fileio_pwrite = remote_hostio_pwrite;
  remote_ops.to_fileio_pread = remote_hostio_pread;
  remote_ops.to_fileio_close = remote_hostio_close;
  remote_ops.to_fileio_unlink = remote_hostio_unlink;
  remote_ops.to_fileio_readlink = remote_hostio_readlink;
  remote_ops.to_supports_enable_disable_tracepoint = remote_supports_enable_disable_tracepoint;
  remote_ops.to_supports_string_tracing = remote_supports_string_tracing;
  remote_ops.to_supports_evaluation_of_breakpoint_conditions = remote_supports_cond_breakpoints;
  remote_ops.to_can_run_breakpoint_commands = remote_can_run_breakpoint_commands;
  remote_ops.to_trace_init = remote_trace_init;
  remote_ops.to_download_tracepoint = remote_download_tracepoint;
  remote_ops.to_can_download_tracepoint = remote_can_download_tracepoint;
  remote_ops.to_download_trace_state_variable
    = remote_download_trace_state_variable;
  remote_ops.to_enable_tracepoint = remote_enable_tracepoint;
  remote_ops.to_disable_tracepoint = remote_disable_tracepoint;
  remote_ops.to_trace_set_readonly_regions = remote_trace_set_readonly_regions;
  remote_ops.to_trace_start = remote_trace_start;
  remote_ops.to_get_trace_status = remote_get_trace_status;
  remote_ops.to_get_tracepoint_status = remote_get_tracepoint_status;
  remote_ops.to_trace_stop = remote_trace_stop;
  remote_ops.to_trace_find = remote_trace_find;
  remote_ops.to_get_trace_state_variable_value
    = remote_get_trace_state_variable_value;
  remote_ops.to_save_trace_data = remote_save_trace_data;
  remote_ops.to_upload_tracepoints = remote_upload_tracepoints;
  remote_ops.to_upload_trace_state_variables
    = remote_upload_trace_state_variables;
  remote_ops.to_get_raw_trace_data = remote_get_raw_trace_data;
  remote_ops.to_get_min_fast_tracepoint_insn_len = remote_get_min_fast_tracepoint_insn_len;
  remote_ops.to_set_disconnected_tracing = remote_set_disconnected_tracing;
  remote_ops.to_set_circular_trace_buffer = remote_set_circular_trace_buffer;
  remote_ops.to_set_trace_buffer_size = remote_set_trace_buffer_size;
  remote_ops.to_set_trace_notes = remote_set_trace_notes;
  remote_ops.to_core_of_thread = remote_core_of_thread;
  remote_ops.to_verify_memory = remote_verify_memory;
  remote_ops.to_get_tib_address = remote_get_tib_address;
  remote_ops.to_set_permissions = remote_set_permissions;
  remote_ops.to_static_tracepoint_marker_at
    = remote_static_tracepoint_marker_at;
  remote_ops.to_static_tracepoint_markers_by_strid
    = remote_static_tracepoint_markers_by_strid;
  remote_ops.to_traceframe_info = remote_traceframe_info;
  remote_ops.to_use_agent = remote_use_agent;
  remote_ops.to_can_use_agent = remote_can_use_agent;
  remote_ops.to_supports_btrace = remote_supports_btrace;
  remote_ops.to_enable_btrace = remote_enable_btrace;
  remote_ops.to_disable_btrace = remote_disable_btrace;
  remote_ops.to_teardown_btrace = remote_teardown_btrace;
  remote_ops.to_read_btrace = remote_read_btrace;
  remote_ops.to_augmented_libraries_svr4_read =
    remote_augmented_libraries_svr4_read;
}

/* Set up the extended remote vector by making a copy of the standard
   remote vector and adding to it.  */

static void
init_extended_remote_ops (void)
{
  extended_remote_ops = remote_ops;

  extended_remote_ops.to_shortname = "extended-remote";
  extended_remote_ops.to_longname =
    "Extended remote serial target in gdb-specific protocol";
  extended_remote_ops.to_doc =
    "Use a remote computer via a serial line, using a gdb-specific protocol.\n\
Specify the serial device it is connected to (e.g. /dev/ttya).";
  extended_remote_ops.to_open = extended_remote_open;
  extended_remote_ops.to_create_inferior = extended_remote_create_inferior;
  extended_remote_ops.to_mourn_inferior = extended_remote_mourn;
  extended_remote_ops.to_detach = extended_remote_detach;
  extended_remote_ops.to_attach = extended_remote_attach;
  extended_remote_ops.to_kill = extended_remote_kill;
  extended_remote_ops.to_supports_disable_randomization
    = extended_remote_supports_disable_randomization;
}

static int
remote_can_async_p (void)
{
  struct remote_state *rs = get_remote_state ();

  if (!target_async_permitted)
    /* We only enable async when the user specifically asks for it.  */
    return 0;

  /* We're async whenever the serial device is.  */
  return serial_can_async_p (rs->remote_desc);
}

static int
remote_is_async_p (void)
{
  struct remote_state *rs = get_remote_state ();

  if (!target_async_permitted)
    /* We only enable async when the user specifically asks for it.  */
    return 0;

  /* We're async whenever the serial device is.  */
  return serial_is_async_p (rs->remote_desc);
}

/* Pass the SERIAL event on and up to the client.  One day this code
   will be able to delay notifying the client of an event until the
   point where an entire packet has been received.  */

static serial_event_ftype remote_async_serial_handler;

static void
remote_async_serial_handler (struct serial *scb, void *context)
{
  struct remote_state *rs = context;

  /* Don't propogate error information up to the client.  Instead let
     the client find out about the error by querying the target.  */
  rs->async_client_callback (INF_REG_EVENT, rs->async_client_context);
}

static void
remote_async_inferior_event_handler (gdb_client_data data)
{
  inferior_event_handler (INF_REG_EVENT, NULL);
}

static void
remote_async (void (*callback) (enum inferior_event_type event_type,
				void *context), void *context)
{
  struct remote_state *rs = get_remote_state ();

  if (callback != NULL)
    {
      serial_async (rs->remote_desc, remote_async_serial_handler, rs);
      rs->async_client_callback = callback;
      rs->async_client_context = context;
    }
  else
    serial_async (rs->remote_desc, NULL, NULL);
}

static void
set_remote_cmd (char *args, int from_tty)
{
  help_list (remote_set_cmdlist, "set remote ", -1, gdb_stdout);
}

static void
show_remote_cmd (char *args, int from_tty)
{
  /* We can't just use cmd_show_list here, because we want to skip
     the redundant "show remote Z-packet" and the legacy aliases.  */
  struct cleanup *showlist_chain;
  struct cmd_list_element *list = remote_show_cmdlist;
  struct ui_out *uiout = current_uiout;

  showlist_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "showlist");
  for (; list != NULL; list = list->next)
    if (strcmp (list->name, "Z-packet") == 0)
      continue;
    else if (list->type == not_set_cmd)
      /* Alias commands are exactly like the original, except they
	 don't have the normal type.  */
      continue;
    else
      {
	struct cleanup *option_chain
	  = make_cleanup_ui_out_tuple_begin_end (uiout, "option");

	ui_out_field_string (uiout, "name", list->name);
	ui_out_text (uiout, ":  ");
	if (list->type == show_cmd)
	  do_show_command ((char *) NULL, from_tty, list);
	else
	  cmd_func (list, NULL, from_tty);
	/* Close the tuple.  */
	do_cleanups (option_chain);
      }

  /* Close the tuple.  */
  do_cleanups (showlist_chain);
}


/* Function to be called whenever a new objfile (shlib) is detected.  */
static void
remote_new_objfile (struct objfile *objfile)
{
  struct remote_state *rs = get_remote_state ();

  if (rs->remote_desc != 0)		/* Have a remote connection.  */
    remote_check_symbols ();
}

/* Pull all the tracepoints defined on the target and create local
   data structures representing them.  We don't want to create real
   tracepoints yet, we don't want to mess up the user's existing
   collection.  */
  
static int
remote_upload_tracepoints (struct uploaded_tp **utpp)
{
  struct remote_state *rs = get_remote_state ();
  char *p;

  /* Ask for a first packet of tracepoint definition.  */
  putpkt ("qTfP");
  getpkt (&rs->buf, &rs->buf_size, 0);
  p = rs->buf;
  while (*p && *p != 'l')
    {
      parse_tracepoint_definition (p, utpp);
      /* Ask for another packet of tracepoint definition.  */
      putpkt ("qTsP");
      getpkt (&rs->buf, &rs->buf_size, 0);
      p = rs->buf;
    }
  return 0;
}

static int
remote_upload_trace_state_variables (struct uploaded_tsv **utsvp)
{
  struct remote_state *rs = get_remote_state ();
  char *p;

  /* Ask for a first packet of variable definition.  */
  putpkt ("qTfV");
  getpkt (&rs->buf, &rs->buf_size, 0);
  p = rs->buf;
  while (*p && *p != 'l')
    {
      parse_tsv_definition (p, utsvp);
      /* Ask for another packet of variable definition.  */
      putpkt ("qTsV");
      getpkt (&rs->buf, &rs->buf_size, 0);
      p = rs->buf;
    }
  return 0;
}

/* The "set/show range-stepping" show hook.  */

static void
show_range_stepping (struct ui_file *file, int from_tty,
		     struct cmd_list_element *c,
		     const char *value)
{
  fprintf_filtered (file,
		    _("Debugger's willingness to use range stepping "
		      "is %s.\n"), value);
}

/* The "set/show range-stepping" set hook.  */

static void
set_range_stepping (char *ignore_args, int from_tty,
		    struct cmd_list_element *c)
{
  struct remote_state *rs = get_remote_state ();

  /* Whene enabling, check whether range stepping is actually
     supported by the target, and warn if not.  */
  if (use_range_stepping)
    {
      if (rs->remote_desc != NULL)
	{
	  if (remote_protocol_packets[PACKET_vCont].support == PACKET_SUPPORT_UNKNOWN)
	    remote_vcont_probe (rs);

	  if (remote_protocol_packets[PACKET_vCont].support == PACKET_ENABLE
	      && rs->supports_vCont.r)
	    return;
	}

      warning (_("Range stepping is not supported by the current target"));
    }
}

void
_initialize_remote (void)
{
  struct remote_state *rs;
  struct cmd_list_element *cmd;
  const char *cmd_name;

  /* architecture specific data */
  remote_gdbarch_data_handle =
    gdbarch_data_register_post_init (init_remote_state);
  remote_g_packet_data_handle =
    gdbarch_data_register_pre_init (remote_g_packet_data_init);

  /* Initialize the per-target state.  At the moment there is only one
     of these, not one per target.  Only one target is active at a
     time.  */
  remote_state = new_remote_state ();

  init_remote_ops ();
  add_target (&remote_ops);

  init_extended_remote_ops ();
  add_target (&extended_remote_ops);

  /* Hook into new objfile notification.  */
  observer_attach_new_objfile (remote_new_objfile);
  /* We're no longer interested in notification events of an inferior
     when it exits.  */
  observer_attach_inferior_exit (discard_pending_stop_replies);

  /* Set up signal handlers.  */
  async_sigint_remote_token =
    create_async_signal_handler (async_remote_interrupt, NULL);
  async_sigint_remote_twice_token =
    create_async_signal_handler (async_remote_interrupt_twice, NULL);

#if 0
  init_remote_threadtests ();
#endif

  stop_reply_queue = QUEUE_alloc (stop_reply_p, stop_reply_xfree);
  /* set/show remote ...  */

  add_prefix_cmd ("remote", class_maintenance, set_remote_cmd, _("\
Remote protocol specific variables\n\
Configure various remote-protocol specific variables such as\n\
the packets being used"),
		  &remote_set_cmdlist, "set remote ",
		  0 /* allow-unknown */, &setlist);
  add_prefix_cmd ("remote", class_maintenance, show_remote_cmd, _("\
Remote protocol specific variables\n\
Configure various remote-protocol specific variables such as\n\
the packets being used"),
		  &remote_show_cmdlist, "show remote ",
		  0 /* allow-unknown */, &showlist);

  add_cmd ("compare-sections", class_obscure, compare_sections_command, _("\
Compare section data on target to the exec file.\n\
Argument is a single section name (default: all loaded sections)."),
	   &cmdlist);

  add_cmd ("packet", class_maintenance, packet_command, _("\
Send an arbitrary packet to a remote target.\n\
   maintenance packet TEXT\n\
If GDB is talking to an inferior via the GDB serial protocol, then\n\
this command sends the string TEXT to the inferior, and displays the\n\
response packet.  GDB supplies the initial `$' character, and the\n\
terminating `#' character and checksum."),
	   &maintenancelist);

  add_setshow_boolean_cmd ("remotebreak", no_class, &remote_break, _("\
Set whether to send break if interrupted."), _("\
Show whether to send break if interrupted."), _("\
If set, a break, instead of a cntrl-c, is sent to the remote target."),
			   set_remotebreak, show_remotebreak,
			   &setlist, &showlist);
  cmd_name = "remotebreak";
  cmd = lookup_cmd (&cmd_name, setlist, "", -1, 1);
  deprecate_cmd (cmd, "set remote interrupt-sequence");
  cmd_name = "remotebreak"; /* needed because lookup_cmd updates the pointer */
  cmd = lookup_cmd (&cmd_name, showlist, "", -1, 1);
  deprecate_cmd (cmd, "show remote interrupt-sequence");

  add_setshow_enum_cmd ("interrupt-sequence", class_support,
			interrupt_sequence_modes, &interrupt_sequence_mode,
			_("\
Set interrupt sequence to remote target."), _("\
Show interrupt sequence to remote target."), _("\
Valid value is \"Ctrl-C\", \"BREAK\" or \"BREAK-g\". The default is \"Ctrl-C\"."),
			NULL, show_interrupt_sequence,
			&remote_set_cmdlist,
			&remote_show_cmdlist);

  add_setshow_boolean_cmd ("interrupt-on-connect", class_support,
			   &interrupt_on_connect, _("\
Set whether interrupt-sequence is sent to remote target when gdb connects to."), _("		\
Show whether interrupt-sequence is sent to remote target when gdb connects to."), _("		\
If set, interrupt sequence is sent to remote target."),
			   NULL, NULL,
			   &remote_set_cmdlist, &remote_show_cmdlist);

  /* Install commands for configuring memory read/write packets.  */

  add_cmd ("remotewritesize", no_class, set_memory_write_packet_size, _("\
Set the maximum number of bytes per memory write packet (deprecated)."),
	   &setlist);
  add_cmd ("remotewritesize", no_class, show_memory_write_packet_size, _("\
Show the maximum number of bytes per memory write packet (deprecated)."),
	   &showlist);
  add_cmd ("memory-write-packet-size", no_class,
	   set_memory_write_packet_size, _("\
Set the maximum number of bytes per memory-write packet.\n\
Specify the number of bytes in a packet or 0 (zero) for the\n\
default packet size.  The actual limit is further reduced\n\
dependent on the target.  Specify ``fixed'' to disable the\n\
further restriction and ``limit'' to enable that restriction."),
	   &remote_set_cmdlist);
  add_cmd ("memory-read-packet-size", no_class,
	   set_memory_read_packet_size, _("\
Set the maximum number of bytes per memory-read packet.\n\
Specify the number of bytes in a packet or 0 (zero) for the\n\
default packet size.  The actual limit is further reduced\n\
dependent on the target.  Specify ``fixed'' to disable the\n\
further restriction and ``limit'' to enable that restriction."),
	   &remote_set_cmdlist);
  add_cmd ("memory-write-packet-size", no_class,
	   show_memory_write_packet_size,
	   _("Show the maximum number of bytes per memory-write packet."),
	   &remote_show_cmdlist);
  add_cmd ("memory-read-packet-size", no_class,
	   show_memory_read_packet_size,
	   _("Show the maximum number of bytes per memory-read packet."),
	   &remote_show_cmdlist);

  add_setshow_zinteger_cmd ("hardware-watchpoint-limit", no_class,
			    &remote_hw_watchpoint_limit, _("\
Set the maximum number of target hardware watchpoints."), _("\
Show the maximum number of target hardware watchpoints."), _("\
Specify a negative limit for unlimited."),
			    NULL, NULL, /* FIXME: i18n: The maximum
					   number of target hardware
					   watchpoints is %s.  */
			    &remote_set_cmdlist, &remote_show_cmdlist);
  add_setshow_zinteger_cmd ("hardware-watchpoint-length-limit", no_class,
			    &remote_hw_watchpoint_length_limit, _("\
Set the maximum length (in bytes) of a target hardware watchpoint."), _("\
Show the maximum length (in bytes) of a target hardware watchpoint."), _("\
Specify a negative limit for unlimited."),
			    NULL, NULL, /* FIXME: i18n: The maximum
                                           length (in bytes) of a target
                                           hardware watchpoint is %s.  */
			    &remote_set_cmdlist, &remote_show_cmdlist);
  add_setshow_zinteger_cmd ("hardware-breakpoint-limit", no_class,
			    &remote_hw_breakpoint_limit, _("\
Set the maximum number of target hardware breakpoints."), _("\
Show the maximum number of target hardware breakpoints."), _("\
Specify a negative limit for unlimited."),
			    NULL, NULL, /* FIXME: i18n: The maximum
					   number of target hardware
					   breakpoints is %s.  */
			    &remote_set_cmdlist, &remote_show_cmdlist);

  add_setshow_zuinteger_cmd ("remoteaddresssize", class_obscure,
			     &remote_address_size, _("\
Set the maximum size of the address (in bits) in a memory packet."), _("\
Show the maximum size of the address (in bits) in a memory packet."), NULL,
			     NULL,
			     NULL, /* FIXME: i18n: */
			     &setlist, &showlist);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_X],
			 "X", "binary-download", 1);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_vCont],
			 "vCont", "verbose-resume", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_QPassSignals],
			 "QPassSignals", "pass-signals", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_QProgramSignals],
			 "QProgramSignals", "program-signals", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_qSymbol],
			 "qSymbol", "symbol-lookup", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_P],
			 "P", "set-register", 1);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_p],
			 "p", "fetch-register", 1);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_Z0],
			 "Z0", "software-breakpoint", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_Z1],
			 "Z1", "hardware-breakpoint", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_Z2],
			 "Z2", "write-watchpoint", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_Z3],
			 "Z3", "read-watchpoint", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_Z4],
			 "Z4", "access-watchpoint", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_qXfer_auxv],
			 "qXfer:auxv:read", "read-aux-vector", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_qXfer_features],
			 "qXfer:features:read", "target-features", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_qXfer_libraries],
			 "qXfer:libraries:read", "library-info", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_qXfer_libraries_svr4],
			 "qXfer:libraries-svr4:read", "library-info-svr4", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_qXfer_memory_map],
			 "qXfer:memory-map:read", "memory-map", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_qXfer_spu_read],
                         "qXfer:spu:read", "read-spu-object", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_qXfer_spu_write],
                         "qXfer:spu:write", "write-spu-object", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_qXfer_osdata],
                        "qXfer:osdata:read", "osdata", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_qXfer_threads],
			 "qXfer:threads:read", "threads", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_qXfer_siginfo_read],
                         "qXfer:siginfo:read", "read-siginfo-object", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_qXfer_siginfo_write],
                         "qXfer:siginfo:write", "write-siginfo-object", 0);

  add_packet_config_cmd
    (&remote_protocol_packets[PACKET_qXfer_traceframe_info],
     "qXfer:traceframe-info:read", "traceframe-info", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_qXfer_uib],
			 "qXfer:uib:read", "unwind-info-block", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_qGetTLSAddr],
			 "qGetTLSAddr", "get-thread-local-storage-address",
			 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_qGetTIBAddr],
			 "qGetTIBAddr", "get-thread-information-block-address",
			 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_bc],
			 "bc", "reverse-continue", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_bs],
			 "bs", "reverse-step", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_qSupported],
			 "qSupported", "supported-packets", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_qSearch_memory],
			 "qSearch:memory", "search-memory", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_qTStatus],
			 "qTStatus", "trace-status", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_vFile_open],
			 "vFile:open", "hostio-open", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_vFile_pread],
			 "vFile:pread", "hostio-pread", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_vFile_pwrite],
			 "vFile:pwrite", "hostio-pwrite", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_vFile_close],
			 "vFile:close", "hostio-close", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_vFile_unlink],
			 "vFile:unlink", "hostio-unlink", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_vFile_readlink],
			 "vFile:readlink", "hostio-readlink", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_vAttach],
			 "vAttach", "attach", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_vRun],
			 "vRun", "run", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_QStartNoAckMode],
			 "QStartNoAckMode", "noack", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_vKill],
			 "vKill", "kill", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_qAttached],
			 "qAttached", "query-attached", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_ConditionalTracepoints],
			 "ConditionalTracepoints",
			 "conditional-tracepoints", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_ConditionalBreakpoints],
			 "ConditionalBreakpoints",
			 "conditional-breakpoints", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_BreakpointCommands],
			 "BreakpointCommands",
			 "breakpoint-commands", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_FastTracepoints],
			 "FastTracepoints", "fast-tracepoints", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_TracepointSource],
			 "TracepointSource", "TracepointSource", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_QAllow],
			 "QAllow", "allow", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_StaticTracepoints],
			 "StaticTracepoints", "static-tracepoints", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_InstallInTrace],
			 "InstallInTrace", "install-in-trace", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_qXfer_statictrace_read],
                         "qXfer:statictrace:read", "read-sdata-object", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_qXfer_fdpic],
			 "qXfer:fdpic:read", "read-fdpic-loadmap", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_QDisableRandomization],
			 "QDisableRandomization", "disable-randomization", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_QAgent],
			 "QAgent", "agent", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_QTBuffer_size],
			 "QTBuffer:size", "trace-buffer-size", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_Qbtrace_off],
       "Qbtrace:off", "disable-btrace", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_Qbtrace_bts],
       "Qbtrace:bts", "enable-btrace", 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_qXfer_btrace],
       "qXfer:btrace", "read-btrace", 0);

  /* Keep the old ``set remote Z-packet ...'' working.  Each individual
     Z sub-packet has its own set and show commands, but users may
     have sets to this variable in their .gdbinit files (or in their
     documentation).  */
  add_setshow_auto_boolean_cmd ("Z-packet", class_obscure,
				&remote_Z_packet_detect, _("\
Set use of remote protocol `Z' packets"), _("\
Show use of remote protocol `Z' packets "), _("\
When set, GDB will attempt to use the remote breakpoint and watchpoint\n\
packets."),
				set_remote_protocol_Z_packet_cmd,
				show_remote_protocol_Z_packet_cmd,
				/* FIXME: i18n: Use of remote protocol
				   `Z' packets is %s.  */
				&remote_set_cmdlist, &remote_show_cmdlist);

  add_prefix_cmd ("remote", class_files, remote_command, _("\
Manipulate files on the remote system\n\
Transfer files to and from the remote target system."),
		  &remote_cmdlist, "remote ",
		  0 /* allow-unknown */, &cmdlist);

  add_cmd ("put", class_files, remote_put_command,
	   _("Copy a local file to the remote system."),
	   &remote_cmdlist);

  add_cmd ("get", class_files, remote_get_command,
	   _("Copy a remote file to the local system."),
	   &remote_cmdlist);

  add_cmd ("delete", class_files, remote_delete_command,
	   _("Delete a remote file."),
	   &remote_cmdlist);

  remote_exec_file = xstrdup ("");
  add_setshow_string_noescape_cmd ("exec-file", class_files,
				   &remote_exec_file, _("\
Set the remote pathname for \"run\""), _("\
Show the remote pathname for \"run\""), NULL, NULL, NULL,
				   &remote_set_cmdlist, &remote_show_cmdlist);

  add_setshow_boolean_cmd ("range-stepping", class_run,
			   &use_range_stepping, _("\
Enable or disable range stepping."), _("\
Show whether target-assisted range stepping is enabled."), _("\
If on, and the target supports it, when stepping a source line, GDB\n\
tells the target to step the corresponding range of addresses itself instead\n\
of issuing multiple single-steps.  This speeds up source level\n\
stepping.  If off, GDB always issues single-steps, even if range\n\
stepping is supported by the target.  The default is on."),
			   set_range_stepping,
			   show_range_stepping,
			   &setlist,
			   &showlist);

  /* Eventually initialize fileio.  See fileio.c */
  initialize_remote_fileio (remote_set_cmdlist, remote_show_cmdlist);

  /* Take advantage of the fact that the LWP field is not used, to tag
     special ptids with it set to != 0.  */
  magic_null_ptid = ptid_build (42000, 1, -1);
  not_sent_ptid = ptid_build (42000, 1, -2);
  any_thread_ptid = ptid_build (42000, 1, 0);

  target_buf_size = 2048;
  target_buf = xmalloc (target_buf_size);
}

@


1.582
log
@gdb/

	* remote.c (discard_pending_stop_replies_in_queue): Update
	declaration.
	(struct stop_reply) <rs>: New field.
	(remove_stop_reply_of_remote_state): New function.
	(discard_pending_stop_replies_in_queue): Add parameter 'rs'.
	Callers update.  Pass remove_stop_reply_of_remote_state to
	QUEUE_iterate.
	(remote_parse_stop_reply): Initialize field 'rs'.
@
text
@d5277 1
a5277 1
  /* The remote state this event associated is with.  When the remote
@


1.581
log
@Move pending_event to remote_notif_state.

This patch moves pending_event to remote_notif_state.  All pending
events are destroyed in remote_notif_state_xfree.  However,
discard_pending_stop_replies release pending event too, so the pending
event of stop notification is released twice, we need some refactor
here.  We add a new function discard_pending_stop_replies_in_queue
which only discard events in stop_reply_queue, and let
remote_notif_state_xfree release pending event for all notif_client.

After this change, discard_pending_stop_replies is only attached to
ifnerior_exit observer, so the INF can't be NULL any more.  The
NULL checking is removed too.

gdb:

2013-10-04  Yao Qi  <yao@@codesourcery.com>

	* remote-notif.h (REMOTE_NOTIF_ID): New enum.
	(struct notif_client) <pending_event>: Moved
	to struct remote_notif_state.
	<id>: New field.
	(struct remote_notif_state) <pending_event>: New field.
	(notif_event_xfree): Declare.
	* remote-notif.c (handle_notification): Adjust.
	(notif_event_xfree): New function.
	(do_notif_event_xfree): Call notif_event_xfree.
	(remote_notif_state_xfree): Call notif_event_xfree to free
	each element in field pending_event.
	* remote.c (discard_pending_stop_replies): Remove declaration.
	(discard_pending_stop_replies_in_queue): Declare.
	(remote_close): Call discard_pending_stop_replies_in_queue
	instead of discard_pending_stop_replies.
	(remote_start_remote): Adjust.
	(stop_reply_xfree): Call notif_event_xfree.
	(notif_client_stop): Adjust initialization.
	(remote_notif_remove_all): Rename it to ...
	(remove_stop_reply_for_inferior): ... this.  Update comments.
	Don't check INF is NULL.
	(discard_pending_stop_replies): Return early if notif_state is
	NULL.  Adjust.  Don't check INF is NULL.
	(remote_notif_get_pending_events): Adjust.
 	(discard_pending_stop_replies_in_queue): New function.
	(remote_wait_ns): Likewise.
@
text
@d223 1
a223 1
static void discard_pending_stop_replies_in_queue (void);
d3072 1
a3072 1
  discard_pending_stop_replies_in_queue ();
d5277 5
d5442 22
a5463 1
/* Discard the stop replies in stop_reply_queue.  */
d5466 1
a5466 1
discard_pending_stop_replies_in_queue (void)
d5470 1
a5470 1
  param.input = NULL;
d5475 1
a5475 1
		 remove_stop_reply_for_inferior, &param);
d5588 1
@


1.580
log
@Move notif_queue and remote_async_get_pending_events_token to remote_state

This patch also removes notif_xfree, and don't pass it QUEUE_alloc, because
we don't have to free notif_client when the remote_notif_state is freed.

gdb:

2013-10-04  Yao Qi  <yao@@codesourcery.com>

	* remote-notif.c (DECLARE_QUEUE_P): Remove.
	(notif_queue): Remove.
	(remote_notif_process): Add one parameter 'notif_queue'.
	Update comments.  Callers update.
	(remote_async_get_pending_events_token): Remove.
	(remote_notif_register_async_event_handler): Remove.
	(remote_notif_unregister_async_event_handler): Remove.
	(handle_notification): Add parameter 'notif_queue'.  Update
	comments.  Callers update.
	(notif_xfree): Remove.
	(remote_notif_state_allocate): New function.
	(remote_notif_state_xfree): New function.
	(_initialize_notif): Remove code to allocate queue.
	* remote-notif.h (DECLARE_QUEUE_P): Moved from remote-notif.c.
	(struct remote_notif_state): New.
	(handle_notification): Update declaration.
	(remote_notif_process): Likewise.
	(remote_notif_register_async_event_handler): Remove.
	(remote_notif_unregister_async_event_handler): Remove.
	(remote_notif_state_allocate): Declare.
	(remote_notif_state_xfree): Declare.
	* remote.c (struct remote_state) <notif_state>: New field.
	(remote_close): Don't call
	remote_notif_unregister_async_event_handler.  Call
	remote_notif_state_xfree.
	(remote_open_1): Don't call
	remote_notif_register_async_event_handler.  Call
	remote_notif_state_allocate.
@
text
@d223 1
a223 1
static void discard_pending_stop_replies (struct inferior *);
d3070 3
a3072 5
  /* Stop replies may from inferiors which are still unknown to GDB.
     We are closing the remote target, so we should discard
     everything, including the stop replies from GDB-unknown
     inferiors.  */
  discard_pending_stop_replies (NULL);
d3573 1
a3573 1
	  notif_client_stop.pending_event
d5305 1
a5305 5
  if (r != NULL)
    {
      VEC_free (cached_reg_t, r->regcache);
      xfree (r);
    }
d5372 1
a5372 1
  NULL,
d5383 2
a5384 1
/* Remove all queue elements meet the condition it checks.  */
d5387 4
a5390 4
remote_notif_remove_all (QUEUE (stop_reply_p) *q,
			 QUEUE_ITER (stop_reply_p) *iter,
			 stop_reply_p event,
			 void *data)
d5395 1
a5395 1
  if (inf == NULL || ptid_get_pid (event->ptid) == inf->pid)
d5404 1
a5404 2
/* Discard all pending stop replies of inferior INF.  If INF is NULL,
   discard everything.  */
d5411 10
a5420 2
  struct stop_reply *reply
    = (struct stop_reply *) notif_client_stop.pending_event;
d5423 1
a5423 3
  if (reply != NULL
      && (inf == NULL
	  || ptid_get_pid (reply->ptid) == inf->pid))
d5426 1
a5426 1
      notif_client_stop.pending_event = NULL;
d5434 16
a5449 1
		 remote_notif_remove_all, &param);
d5805 1
a5805 1
  if (nc->pending_event)
d5813 2
a5814 2
      nc->ack (nc, rs->buf, nc->pending_event);
      nc->pending_event = NULL;
d5919 1
a5919 1
      if (notif_client_stop.pending_event != NULL)
@


1.579
log
@Fix regular /path/to/directory sysroots and target reported dll paths with drive specs.

I tried debugging a remote Windows program on Linux host, and pointed the
sysroot to "/some/path/" rather than "remote:", and I found GDB couldn't
find the dlls in the sysroot.  If the dll name is
"C:/Windows/system32/ntdll.dll", I end up with the sysroot+in_pathname
concatenated this way:

 (top-gdb) p temp_pathname
 $1 = 0x228b690 "/some/pathC:/Windows/system32/ntdll.dll"
                          ^^

That is, a directory separator is missing.  This is a regression.

The problem is that solib_find decides that since the target path has
a drive spec, a separator is not necessary, which is clearly wrong in
this case.  That check was added in
<https://sourceware.org/ml/gdb-patches/2013-06/msg00028.html>, to
handle the case of sysroot being "remote:".  This patch fixes that
original issue in a different way.  Instead of checking whether the
path has a drive spec, check whether the sysroot is "remote:".  The
patch adds a table that helps visualize the cases that need a
separator.  I also confirmed the original issue is still handled as
expected.  That is, that "set sysroot remote:" still does the right
thing.

remote_filename_p returns true if the filename is prefixed with
"remote:".  In this case, we need to check whether the filename is
exactly "remote:".  I thought of different ways or either changing
remote_filename_p or adding another convenience function to remote.c
to avoid exposing the "remote:" prefix out of remote.c.  But all
attempts turned out adding lot of over needless complication.  So the
patch just exposes the prefix behind a new macro, which allows using a
straighforward strcmp.

gdb/
2013-09-27  Pedro Alves  <palves@@redhat.com>

	* remote.h (REMOTE_SYSROOT_PREFIX): New define.
	(remote_filename_p): Add comment.
	* remote.c (remote_filename_p): Adjust to use
	REMOTE_SYSROOT_PREFIX.
	* solib.c (solib_find): When deciding whether we need to add a
	directory separator, check whether the sysroot is "remote:"
	instead of checking whether the patch has a drive spec.  Add
	comments.
@
text
@d428 3
d3079 1
a3079 1
  remote_notif_unregister_async_event_handler ();
d4343 1
a4343 1
  remote_notif_register_async_event_handler ();
d4937 1
a4937 1
    remote_notif_process (&notif_client_stop);
d7358 1
a7358 1
		    handle_notification (rs->buf);
d7744 1
a7744 1
	  handle_notification (*buf);
@


1.578
log
@remote.c: Remove unnecessary fields from 'struct stop_reply'.

I noticed these fields aren't really necessary -- if the T stop reply
indicated any we have any special event, the fallthrough doesn't
really do anything.

Tested on x86_64 Fedora 17 w/ local gdbserver, and also confirmed
"catch load" against a Windows gdbserver running under Wine, which
exercises TARGET_WAITKIND_LOADED, still works as expected.

gdb/
2013-09-27  Pedro Alves  <palves@@redhat.com>

	* remote.c (struct stop_reply) <solibs_changed, replay_event>:
	Delete fields.
	(remote_parse_stop_reply): Adjust, setting event->ws.kind
	directly.
@
text
@d10039 3
a10041 1
  return strncmp (filename, "remote:", 7) == 0;
@


1.577
log
@remote.c: don't install a deprecated_xfer_memory hook.

There's no need for deprecated_xfer_memory nowadays.  Memory access
goes through target_xfer_partial/TARGET_OBJECT_MEMORY, etc.  In fact,
the remote target already handles that, and is deferring to the same
helpers the deprecated_xfer_memory hook is.  Basically, only a few
adjustments to make these helper routines's interfaces closer to
target_xfer_partial's were necessary.

Tested on x86_64 Fedora 17 w/ gdbserver.

gdb/
2013-08-23  Pedro Alves  <palves@@redhat.com>

	* remote.c (remote_write_bytes_aux, remote_write_bytes)
	(remote_read_bytes): Change return type to LONGEST, and adjust to
	return a target_xfer_error on error.
	(remote_xfer_memory): Delete.
	(remote_flash_write): Change type of 'ret' local to LONGEST.
	(remote_xfer_partial, remote_xfer_partial): Adjust.
	(init_remote_ops): Don't install a deprecated_xfer_memory hook.
@
text
@a5286 3
  int solibs_changed;
  int replay_event;

a5545 2
  event->solibs_changed = 0;
  event->replay_event = 0;
d5609 1
a5609 1
		  event->solibs_changed = 1;
d5614 3
a5616 4
		  /* NO_HISTORY event.
		     p1 will indicate "begin" or "end", but
		     it makes no difference for now, so ignore it.  */
		  event->replay_event = 1;
d5672 4
d5678 3
a5680 10
      if (event->solibs_changed)
	event->ws.kind = TARGET_WAITKIND_LOADED;
      else if (event->replay_event)
	event->ws.kind = TARGET_WAITKIND_NO_HISTORY;
      else
	{
	  event->ws.kind = TARGET_WAITKIND_STOPPED;
	  event->ws.value.sig = (enum gdb_signal)
	    (((fromhex (buf[1])) << 4) + (fromhex (buf[2])));
	}
@


1.576
log
@move some static thread state into remote_state

This moves a few static variables from thread-info functions into
remote_state.  Pedro said on irc that these functions implement the
ancient thread-discovery method and that he wouldn't be surprised if
they had rotted; nevertheless it seems safer to me to make them
explicitly per-remote.

This necessitated moving a couple of macros and a typedef earlier in
the file.

	* remote.c (struct remote_state) <echo_nextthread, nextthread,
	resultthreadlist>: New fields.
	(OPAQUETHREADBYTES, threadref, MAXTHREADLISTRESULTS): Move earlier.
	(remote_get_threadlist, remote_threadlist_iterator): Use
	new fields.  Remove static variables.
@
text
@d6747 3
a6749 2
   Returns the number of bytes transferred, or 0 (setting errno) for
   error.  Only transfer a single packet.  */
d6751 1
a6751 1
static int
d6890 1
a6890 8
    {
      /* There is no correspondance between what the remote protocol
	 uses for errors and errno codes.  We would like a cleaner way
	 of representing errors (big enough to include errno codes,
	 bfd_error codes, and others).  But for now just return EIO.  */
      errno = EIO;
      return 0;
    }
d6903 3
a6905 2
   Returns number of bytes transferred, or 0 (setting errno) for
   error.  Only transfer a single packet.  */
d6907 1
a6907 1
static int
d6940 2
a6941 1
   Returns number of bytes transferred, or 0 for error.  */
d6943 1
a6943 1
static int
d6975 1
a6975 9
    {
      /* There is no correspondance between what the remote protocol
	 uses for errors and errno codes.  We would like a cleaner way
	 of representing errors (big enough to include errno codes,
	 bfd_error codes, and others).  But for now just return
	 EIO.  */
      errno = EIO;
      return 0;
    }
a6984 22
/* Read or write LEN bytes from inferior memory at MEMADDR,
   transferring to or from debugger address BUFFER.  Write to inferior
   if SHOULD_WRITE is nonzero.  Returns length of data written or
   read; 0 for error.  TARGET is unused.  */

static int
remote_xfer_memory (CORE_ADDR mem_addr, gdb_byte *buffer, int mem_len,
		    int should_write, struct mem_attrib *attrib,
		    struct target_ops *target)
{
  int res;

  set_remote_traceframe ();
  set_general_thread (inferior_ptid);

  if (should_write)
    res = remote_write_bytes (mem_addr, buffer, mem_len);
  else
    res = remote_read_bytes (mem_addr, buffer, mem_len);

  return res;
}
d7059 1
a7059 1
  int ret;
d8765 1
a8765 3
      int xfered;

      errno = 0;
d8778 1
a8778 6
      if (xfered > 0)
	return xfered;
      else if (xfered == 0 && errno == 0)
	return 0;
      else
	return -1;
d8827 1
a8827 8
	  xfered = remote_flash_write (ops, offset, len, writebuf);

	  if (xfered > 0)
	    return xfered;
	  else if (xfered == 0 && errno == 0)
	    return 0;
	  else
	    return -1;
a11436 1
  remote_ops.deprecated_xfer_memory = remote_xfer_memory;
@


1.575
log
@move remote_stopped_by_watchpoint_p and remote_watch_data_address into remote_state

This moves the globals remote_stopped_by_watchpoint_p and
remote_watch_data_address into remote_state.

	* remote.c (struct remote_state) <remote_stopped_by_watchpoint_p,
	remote_watch_data_address>: New fields.
	(remote_stopped_by_watchpoint_p, remote_watch_data_address): Remove.
	(process_stop_reply, remote_wait_as)
	(remote_check_watch_resources, remote_stopped_data_address): Update.
@
text
@d265 9
d424 4
a1888 5
#define OPAQUETHREADBYTES 8

/* a 64 bit opaque identifier */
typedef unsigned char threadref[OPAQUETHREADBYTES];

a2503 1
  static threadref echo_nextthread;
d2519 2
a2520 2
      parse_threadlist_response (rs->buf + 2, result_limit, &echo_nextthread,
                                 threadlist, done);
d2522 1
a2522 1
  if (!threadmatch (&echo_nextthread, nextthread))
a2562 4
/* About this many threadisds fit in a packet.  */

#define MAXTHREADLISTRESULTS 32

d2567 1
a2571 2
  static threadref nextthread;
  static threadref resultthreadlist[MAXTHREADLISTRESULTS];
d2582 3
a2584 2
      if (!remote_get_threadlist (startflag, &nextthread, MAXTHREADLISTRESULTS,
				  &done, &result_count, resultthreadlist))
d2593 2
a2594 1
	copy_threadref (&nextthread, &resultthreadlist[result_count - 1]);
d2597 1
a2597 1
	if (!(result = (*stepfunction) (&resultthreadlist[i++], context)))
@


1.574
log
@move async_client_callback and async_client_context into remote_state

This moves async_client_callback and async_client_context into
remote_state.

	* remote.c (struct remote_state) <async_client_callback,
	async_client_context>: New fields.
	(async_client_callback, async_client_context): Remove.
	(remote_async_serial_handler, remote_async): Update.
@
text
@d408 7
a798 11
/* FIXME: graces/2002-08-08: These variables should eventually be
   bound to an instance of the target object (as in gdbarch-tdep()),
   when such a thing exists.  */

/* This is set to the data address of the access causing the target
   to stop for a watchpoint.  */
static CORE_ADDR remote_watch_data_address;

/* This is non-zero if target stopped for a watchpoint.  */
static int remote_stopped_by_watchpoint_p;

d5842 2
d5859 2
a5860 2
      remote_stopped_by_watchpoint_p = stop_reply->stopped_by_watchpoint_p;
      remote_watch_data_address = stop_reply->watch_data_address;
d5986 1
a5986 1
  remote_stopped_by_watchpoint_p = 0;
d8427 3
a8429 1
  return remote_stopped_by_watchpoint_p;
d8435 1
d8440 1
a8440 1
      *addr_p = remote_watch_data_address;
@


1.573
log
@move sizeof_pkt into remote_trace_find

The global sizeof_pkt is only used in remote_trace_find, like so:

  reply = remote_get_noisy_reply (&(rs->buf), &sizeof_pkt);

I think in this situation it is more correct to use the recorded size
of the buffer.  Otherwise it seems that some skew could result.

	* remote.c (sizeof_pkt): Remove.
	(remote_trace_find): Use rs->buf_size, not sizeof_pkt.
@
text
@d404 4
a11641 3
static void (*async_client_callback) (enum inferior_event_type event_type,
				      void *context);
static void *async_client_context;
d11647 2
d11651 1
a11651 1
  async_client_callback (INF_REG_EVENT, async_client_context);
d11668 3
a11670 3
      serial_async (rs->remote_desc, remote_async_serial_handler, NULL);
      async_client_callback = callback;
      async_client_context = context;
@


1.572
log
@move use_threadinfo_query and use_threadextra_query into struct remote_state

This moves the use_threadextra_query and use_threadinfo_query globals
into remote_state.

	* remote.c (struct remote_state) <use_threadinfo_query,
	use_threadextra_query>: New fields.
	(remote_threads_info, remote_threads_extra_info)
	(remote_open_1): Update.
@
text
@a492 2
long sizeof_pkt = 2000;

d10972 1
a10972 1
  reply = remote_get_noisy_reply (&(rs->buf), &sizeof_pkt);
@


1.571
log
@move some statics from remote_read_qxfer into struct remote_state

This moves a few static variables out of remote_read_qxfer and into
remote_state.

	* remote.c (struct remote_state) <finished_object,
	finished_annex, finished_offset>: New fields.
	(remote_read_qxfer): Use remote_state fields; remove static
	variables.
@
text
@d394 10
a1446 11
/* Should we try the 'ThreadInfo' query packet?

   This variable (NOT available to the user: auto-detect only!)
   determines whether GDB will use the new, simpler "ThreadInfo"
   query or the older, more complex syntax for thread queries.
   This is an auto-detect variable (set to true at each connect,
   and set to false when the target fails to recognize it).  */

static int use_threadinfo_query;
static int use_threadextra_query;

d2796 1
a2796 1
  if (use_threadinfo_query)
d2844 1
a2844 1
  use_threadinfo_query = 0;
d2889 1
a2889 1
  if (use_threadextra_query)
d2910 1
a2910 1
  use_threadextra_query = 0;
d4357 2
a4358 2
  use_threadinfo_query = 1;
  use_threadextra_query = 1;
@


1.570
log
@push last_sent_step into struct remote_state

This moves the global last_sent_step into remote_state.

	* remote.c (struct remote_state) <last_sent_step>:
	New field.
	(last_sent_step): Remove.
	(remote_resume, remote_wait_as): Update.
@
text
@d390 4
a8707 4
  static char *finished_object;
  static char *finished_annex;
  static ULONGEST finished_offset;

d8716 1
a8716 1
  if (finished_object)
d8718 3
a8720 3
      if (strcmp (object_name, finished_object) == 0
	  && strcmp (annex ? annex : "", finished_annex) == 0
	  && offset == finished_offset)
d8725 4
a8728 4
      xfree (finished_object);
      xfree (finished_annex);
      finished_object = NULL;
      finished_annex = NULL;
d8767 3
a8769 3
      finished_object = xstrdup (object_name);
      finished_annex = xstrdup (annex ? annex : "");
      finished_offset = offset + i;
@


1.569
log
@push last_sent_signal into struct remote_state

This moves the global last_sent_signal into remote_state.

	* remote.c (struct remote_state) <last_sent_signal>:
	New field.
	(last_sent_signal): Remove.
	(new_remote_state, remote_resume, remote_wait_as): Update.
@
text
@d388 2
a4914 2
static int last_sent_step;

d4932 1
a4932 1
  last_sent_step = step;
d6034 1
a6034 1
	  strcpy ((char *) buf, last_sent_step ? "s" : "c");
@


1.568
log
@push last_program_signals_packet into struct remote_state

This moves the global last_program_signals_packet into remote_state.

	* remote.c (struct remote_state) <last_program_signals_packet>:
	New field.
	(last_program_signals_packet): Remove.
	(remote_program_signals, remote_open_1): Update.
@
text
@d386 2
d436 1
a4912 2
static enum gdb_signal last_sent_signal = GDB_SIGNAL_0;

d4931 1
a4931 1
  last_sent_signal = siggnal;
d6023 1
a6023 1
      if (last_sent_signal != GDB_SIGNAL_0)
d6030 2
a6031 2
	     gdb_signal_to_name (last_sent_signal));
	  last_sent_signal = GDB_SIGNAL_0;
@


1.567
log
@push last_pass_packet into struct remote_state

This moves the global last_pass_packet into remote_state.

	* remote.c (struct remote_state) <last_pass_packet>:
	New field.
	(last_pass_packet): Remove.
	(remote_pass_signals, remote_open_1): Update.
@
text
@d380 6
a1711 7
/* The last QProgramSignals packet sent to the target.  We bypass
   sending a new program signals list down to the target if the new
   packet is exactly the same as the last we sent.  IOW, we only let
   the target know about program signals list changes.  */

static char *last_program_signals_packet;

d1722 1
d1748 2
a1749 2
      if (!last_program_signals_packet
	  || strcmp (last_program_signals_packet, packet) != 0)
a1750 1
	  struct remote_state *rs = get_remote_state ();
d1756 2
a1757 2
	  xfree (last_program_signals_packet);
	  last_program_signals_packet = packet;
d4287 2
a4288 2
  xfree (last_program_signals_packet);
  last_program_signals_packet = NULL;
@


1.566
log
@push remote_traceframe_number into struct remote_state

This moves the global remote_traceframe_number into remote_state.

	* remote.c (struct remote_state) <remote_traceframe_number>:
	New field.
	(remote_traceframe_number): Remove.
	(new_remote_state, remote_open_1, set_remote_traceframe)
	(remote_trace_find): Update.
@
text
@d378 2
a1653 2
static char *last_pass_packet;

d1664 1
d1690 1
a1690 1
      if (!last_pass_packet || strcmp (last_pass_packet, pass_packet))
a1691 1
	  struct remote_state *rs = get_remote_state ();
d1697 3
a1699 3
	  if (last_pass_packet)
	    xfree (last_pass_packet);
	  last_pass_packet = pass_packet;
d4283 2
a4284 2
  xfree (last_pass_packet);
  last_pass_packet = NULL;
@


1.565
log
@push general_thread and continue_thread into struct remote_state

This moves the globals general_thread and continue_thread into
remote_state.

	* remote.c (struct remote_state) <general_thread, continue_thread>:
	New fields.
	(general_thread, continue_thread): Remove.
	(record_currthread, set_thread, set_general_process)
	(remote_open_1, extended_remote_attach_1, remote_wait_as)
	(extended_remote_mourn_1): Update.
@
text
@d374 4
d425 1
a1446 4
/* This is the traceframe which we last selected on the remote system.
   It will be -1 if no traceframe is selected.  */
static int remote_traceframe_number = -1;

d4347 1
a4347 1
  remote_traceframe_number = -1;
d6297 1
d6299 1
a6299 1
  if (remote_traceframe_number == get_traceframe_number ())
d6303 1
a6303 1
  remote_traceframe_number = get_traceframe_number ();
d11010 1
a11010 1
  remote_traceframe_number = target_frameno;
@


1.564
log
@push remote_desc into struct remote_state

This moves the "remote_desc" global into remote_state.

	* remote.c (struct remote_state) <remote_desc>: New field.
	(remote_desc): Remove.
	(remote_threads_info, remote_threads_extra_info, remote_close)
	(send_interrupt_sequence, remote_start_remote, remote_open_1)
	(readchar, remote_xfer_partial, remote_rcmd, packet_command)
	(remote_hostio_send_command, remote_file_put, remote_file_get)
	(remote_file_delete, remote_can_async_p, remote_is_async_p)
	(remote_async, remote_new_objfile, set_range_stepping): Update.
@
text
@a180 2
static void record_currthread (ptid_t currthread);

d369 5
a1441 6
/* These are the threads which we last sent to the remote system.  The
   TID member will be -1 for all or -2 for not sent yet.  */

static ptid_t general_thread;
static ptid_t continue_thread;

d1646 1
a1646 1
record_currthread (ptid_t currthread)
d1648 1
a1648 1
  general_thread = currthread;
d1772 1
a1772 1
  ptid_t state = gen ? general_thread : continue_thread;
d1792 1
a1792 1
    general_thread = ptid;
d1794 1
a1794 1
    continue_thread = ptid;
d1829 1
a1829 1
  if (ptid_get_pid (general_thread) != ptid_get_pid (inferior_ptid))
d4344 2
a4345 2
  general_thread = not_sent_ptid;
  continue_thread = not_sent_ptid;
d4563 1
a4563 1
      record_currthread (minus_one_ptid);
d6062 1
a6062 1
	record_currthread (event_ptid);
d6068 1
a6068 1
    record_currthread (minus_one_ptid);
d7919 1
a7919 1
  record_currthread (minus_one_ptid);
@


1.563
log
@Add new_remote_state

Add new_remote_state and change remote_state to be a pointer.  This is
a preparatory patch for a later series.  It could perhaps be omitted,
but new_remote_state also does some initialization that was previously
done for the globals.

	* remote.c (remote_state): Now a pointer.
	(get_remote_state_raw): Update.
	(new_remote_state): New function.
	(_initialize_remote): Use new_remote_state.
@
text
@d366 5
a848 5
/* Descriptor for I/O to remote machine.  Initialize it to NULL so that
   remote_open knows that we don't have a file open when the program
   starts.  */
static struct serial *remote_desc = NULL;

d2738 1
a2738 1
  if (remote_desc == 0)		/* paranoia */
d2864 1
a2864 1
  if (remote_desc == 0)		/* paranoia */
d3041 3
a3043 1
  if (remote_desc == NULL)
d3050 2
a3051 2
  serial_close (remote_desc);
  remote_desc = NULL;
d3252 2
d3257 1
a3257 1
    serial_send_break (remote_desc);
d3260 1
a3260 1
      serial_send_break (remote_desc);
d3377 1
a3377 1
  serial_write (remote_desc, "+", 1);
d4274 1
a4274 1
  if (remote_desc != NULL && !have_inferiors ())
d4297 2
a4298 2
  remote_desc = remote_serial_open (name);
  if (!remote_desc)
d4303 1
a4303 1
      if (serial_setbaudrate (remote_desc, baud_rate))
d4309 2
a4310 2
	  serial_close (remote_desc);
	  remote_desc = NULL;
d4315 1
a4315 1
  serial_raw (remote_desc);
d4319 1
a4319 1
  serial_flush_input (remote_desc);
d4402 1
a4402 1
	if (remote_desc != NULL)
d7152 1
d7154 1
a7154 1
  ch = serial_readchar (remote_desc, timeout);
d7181 3
a7183 1
  if (serial_write (remote_desc, str, len))
d8912 1
a8912 1
      gdb_assert (remote_desc);
d8955 1
a8955 1
  if (!remote_desc)
d9089 1
a9089 1
  if (!remote_desc)
d9175 1
a9175 1
  if (!remote_desc)
d9715 1
a9715 1
  if (!remote_desc
d10116 1
d10118 1
a10118 1
  if (!remote_desc)
d10205 1
d10207 1
a10207 1
  if (!remote_desc)
d10257 1
d10259 1
a10259 1
  if (!remote_desc)
d11615 2
d11622 1
a11622 1
  return serial_can_async_p (remote_desc);
d11628 2
d11635 1
a11635 1
  return serial_is_async_p (remote_desc);
d11665 2
d11669 1
a11669 1
      serial_async (remote_desc, remote_async_serial_handler, NULL);
d11674 1
a11674 1
    serial_async (remote_desc, NULL, NULL);
d11724 3
a11726 1
  if (remote_desc != 0)		/* Have a remote connection.  */
d11795 2
d11801 1
a11801 1
      if (remote_desc != NULL)
a11802 2
	  struct remote_state *rs = get_remote_state ();

@


1.562
log
@make remote_protocol_features "const"

This is a trivial patch to make remote_protocol_features "const".

	* remote.c (remote_protocol_features): Now const.
@
text
@d393 1
a393 1
static struct remote_state remote_state;
d398 17
a414 1
  return &remote_state;
d11812 2
a11813 5
     time.  The default buffer size is unimportant; it will be expanded
     whenever a larger buffer is needed.  */
  rs = get_remote_state_raw ();
  rs->buf_size = 400;
  rs->buf = xmalloc (rs->buf_size);
@


1.561
log
@use the libiberty crc code

gdb has a copy of some CRC code that also appears in libiberty.
This patch just removes the local copy.

You may notice that "crc32" returns unsigned long but "xcrc32" returns
unsigned int.  However, this does not matter, because crc32 actually
does all its operations in unsigned int type, and only the return
result is widened.  So, the difference does not matter.

	* remote.c (crc32_table, crc32): Remove.
	(remote_verify_memory): Use xcrc32.
@
text
@d3966 1
a3966 1
static struct protocol_feature remote_protocol_features[] = {
@


1.560
log
@gdb/
	Code cleanup.
	* remote.c (cleanup_sigint_signal_handler): Rename the declaration
	to ...
	(async_cleanup_sigint_signal_handler): ... this.
	(initialize_sigint_signal_handler): Remove declaration.
	(handle_remote_sigint): Rename the declaration to ...
	(async_handle_remote_sigint): ... this.
	(handle_remote_sigint_twice): Rename the declaration to ...
	(async_handle_remote_sigint_twice): ... this.
	(async_remote_interrupt, async_remote_interrupt_twice)
	(remote_interrupt): Remove the declarations.
	(remote_interrupt_twice): Rename the declaration ...
	(sync_remote_interrupt_twice): ... this.
	(sigint_remote_twice_token): Rename the variable to ...
	(async_sigint_remote_twice_token): ... this.
	(sigint_remote_token): Rename the variable to ...
	(async_sigint_remote_token): ... this.
	(initialize_sigint_signal_handler): Rename the function to ...
	(async_initialize_sigint_signal_handler): ... this.  Update the name
	inside.
	(handle_remote_sigint): Rename the function to ...
	(async_handle_remote_sigint): ... this.  Update the names inside.
	(handle_remote_sigint_twice): Rename the function to ...
	(async_handle_remote_sigint_twice): ... this.  Update the names inside.
	(cleanup_sigint_signal_handler): Rename the function to ...
	(async_cleanup_sigint_signal_handler): ... this.
	(remote_interrupt): Rename the function to ...
	(sync_remote_interrupt): this.  Update the names inside.
	(remote_interrupt_twice): Rename the function to ...
	(sync_remote_interrupt_twice): this.  Update the names inside.
	(remote_terminal_inferior, remote_terminal_ours, remote_wait_as)
	(_initialize_remote): Update the names inside.
@
text
@a8523 30
/* Table used by the crc32 function to calcuate the checksum.  */

static unsigned long crc32_table[256] =
{0, 0};

static unsigned long
crc32 (const unsigned char *buf, int len, unsigned int crc)
{
  if (!crc32_table[1])
    {
      /* Initialize the CRC table and the decoding table.  */
      int i, j;
      unsigned int c;

      for (i = 0; i < 256; i++)
	{
	  for (c = i << 24, j = 8; j > 0; --j)
	    c = c & 0x80000000 ? (c << 1) ^ 0x04c11db7 : (c << 1);
	  crc32_table[i] = c;
	}
    }

  while (len--)
    {
      crc = (crc << 8) ^ crc32_table[((crc >> 24) ^ *buf) & 255];
      buf++;
    }
  return crc;
}

d8544 1
a8544 1
  host_crc = crc32 (data, size, 0xffffffff);
@


1.559
log
@Replace most uses of deprecated_throw_reason with quit.

  http://sourceware.org/ml/gdb-patches/2013-07/msg00778.html

gdb/ChangeLog

        * monitor.c (monitor_interrupt_query): Replace use of
        deprecated_throw_reason with quit.
        * nto-procfs.c (interrupt_query): Likewise.
        * remote-fileio.c (remote_fileio_sig_exit): Likewise.
        * remote-mips.c (mips_kill): Likewise.
        * remote.c (interrupt_query): Likewise.
@
text
@d91 1
a91 2
static void cleanup_sigint_signal_handler (void *dummy);
static void initialize_sigint_signal_handler (void);
d96 2
a97 4
static void handle_remote_sigint (int);
static void handle_remote_sigint_twice (int);
static void async_remote_interrupt (gdb_client_data);
static void async_remote_interrupt_twice (gdb_client_data);
d138 1
a138 3
static void remote_interrupt (int signo);

static void remote_interrupt_twice (int signo);
d1408 2
a1409 2
static struct async_signal_handler *sigint_remote_twice_token;
static struct async_signal_handler *sigint_remote_token;
d4984 1
a4984 1
initialize_sigint_signal_handler (void)
d4986 1
a4986 1
  signal (SIGINT, handle_remote_sigint);
d4991 1
a4991 1
handle_remote_sigint (int sig)
d4993 2
a4994 2
  signal (sig, handle_remote_sigint_twice);
  mark_async_signal_handler (sigint_remote_token);
d5001 1
a5001 1
handle_remote_sigint_twice (int sig)
d5003 2
a5004 2
  signal (sig, handle_remote_sigint);
  mark_async_signal_handler (sigint_remote_twice_token);
d5032 1
a5032 1
cleanup_sigint_signal_handler (void *dummy)
d5047 1
a5047 1
remote_interrupt (int signo)
d5050 1
a5050 1
  signal (signo, remote_interrupt_twice);
d5052 1
a5052 1
  gdb_call_async_signal_handler (sigint_remote_token, 1);
d5058 1
a5058 1
remote_interrupt_twice (int signo)
d5061 2
a5062 2
  gdb_call_async_signal_handler (sigint_remote_twice_token, 1);
  signal (signo, remote_interrupt);
d5200 1
a5200 1
  initialize_sigint_signal_handler ();
d5216 1
a5216 1
  cleanup_sigint_signal_handler (NULL);
d5937 1
a5937 1
	  ofunc = signal (SIGINT, remote_interrupt);
d5943 1
a5943 1
	      remote_interrupt (SIGINT);
d11845 1
a11845 1
  sigint_remote_token =
d11847 1
a11847 1
  sigint_remote_twice_token =
@


1.558
log
@gdb/
	Code cleanup.
	* remote.c (async_remote_interrupt_twice): Make it static.
	* remote.h (async_remote_interrupt_twice): Remove the declaration.
@
text
@d5168 1
a5168 1
      deprecated_throw_reason (RETURN_QUIT);
d5176 1
a5176 1
	  deprecated_throw_reason (RETURN_QUIT);
@


1.557
log
@gdb/

2013-06-26  Pedro Alves  <pedro@@codesourcery.com>
	    Yao Qi  <yao@@codesourcery.com>

	* gdb.texinfo (GDB/MI Tracepoint Commands): Document
	-trace-frame-collected.
gdb:

2013-06-26  Pedro Alves  <pedro@@codesourcery.com>
	    Yao Qi  <yao@@codesourcery.com>

	* mi/mi-cmds.c (mi_cmds): Register -trace-frame-collected.
	* mi/mi-cmds.h (mi_cmd_trace_frame_collected): Declare.
	* mi/mi-main.c (print_variable_or_computed): New function.
	(mi_cmd_trace_frame_collected): New function.
	* tracepoint.c (find_trace_state_variable_by_number): New.
	(struct traceframe_info): Move to tracepoint.h
	(struct collection_list): Likewise.
	(do_collect_symbol): Include locals and arguments in the wholly
	collected variables list.
	(clear_collection_list): Clear wholly collected variables list
	and computed variables list.
	(append_exp): New function.
	(encode_actions_1): Include variables in the wholly
	collected variables list.  Include memory ranges and
	full-fledged expressions in the computed expressions list.
	(encode_actions): Move some code to ...
	Return the cleanup chain.
	(encode_actions_rsp): ... here.  New function.
	(get_traceframe_location, get_traceframe_info): Remove static.
	* tracepoint.h (struct memrange): Moved	from tracepoint.c.
	(struct collection_list): Moved from tracepoint.c.  Add two
	new fields 'wholly_collected' and 'computed'.
	(find_trace_state_variable_by_number): Declare.
	(encode_actions): Adjust declaration.
	(encode_actions_rsp): Declare.
	(get_traceframe_info, get_traceframe_location): Declare.

	* NEWS: Mention new MI command -trace-frame-collected.
@
text
@d100 1
a100 1
void async_remote_interrupt_twice (gdb_client_data);
d5025 1
a5025 1
void
@


1.556
log
@Upload tsv earlier in remote_start_remote

In extended-remote, when GDB connects the target, but target is not
running, the TSVs are not uploaded.  When GDB attaches to a process,
the TSVs are not uploaded either.  However, GDBserver has some
builtin or predefined TSV to upload, such as $trace_timestamp.  This
bug causes $trace_timestamp is never uploaded.

gdb/

2013-06-25  Yao Qi  <yao@@codesourcery.com>

        * remote.c (remote_start_remote): Move code to upload tsv
        earlier.

gdb/testsuite/

2013-06-25  Yao Qi  <yao@@codesourcery.com>

	* boards/native-extended-gdbserver.exp: Set board_info
	'gdb,predefined_tsv'.
	* boards/native-gdbserver.exp: Likewise.
	* boards/native-stdio-gdbserver.exp: Likewise.
	* gdb.server/ext-attach.exp: Load trace-support.exp.  Check
	uploaded TSVs if target supports tracing.
	* gdb.trace/tsv.exp: Check uploaded TSVs if target supports
	tracing and target has predefined tsv.

gdb/doc/

2013-06-25  Yao Qi  <yao@@codesourcery.com>

	* gdbint.texinfo (Testsuite): Document 'gdb,predefined_tsv'.
@
text
@d10530 1
a10530 1
  encode_actions (loc, &tdp_actions, &stepping_actions);
@


1.555
log
@gdb/

	* tracepoint.c (start_tracing): Move code to ...
	(trace_reset_local_state): ... here.  New.
	(disconnect_tracing): Don't call set_current_traceframe,
	set_tracepoint_num, and set_traceframe_context. Call
	trace_reset_local_state instead.
	(tfile_close): Call trace_reset_local_state.
	* ctf.c (ctf_close): Likewise.
	* remote.c (remote_close): Likewise.
	* tracepoint.h (trace_reset_local_state): Declare.
@
text
@d3455 11
a3604 1
      struct uploaded_tsv *uploaded_tsvs = NULL;
a3608 7
      /* Get trace state variables first, they may be checked when
	 parsing uploaded commands.  */

      remote_upload_trace_state_variables (&uploaded_tsvs);

      merge_uploaded_trace_state_variables (&uploaded_tsvs);

@


1.554
log
@GDB was not restoring the signal handler before returning when a notification
was received.  This patch fixes it.

2013-06-04  Sergio Durigan Junior  <sergiodj@@redhat.com>
	    Pedro Alves  <palves@@redhat.com>

	* remote.c (remote_wait_as): Restore signal handler before returning
	when GDB gets a notification.
@
text
@d3057 2
@


1.553
log
@2013-06-04  Gary Benson  <gbenson@@redhat.com>

	* target.h (target_ops): New field
	"to_augmented_libraries_svr4_read".
	(target_augmented_libraries_svr4_read): New macro.
	* target.c (update_current_target): Handle
	to_augmented_libraries_svr4_read.
	* remote.c (remote_state): New field
	"augmented_libraries_svr4_read".
	(remote_augmented_libraries_svr4_read_feature): New function.
	(remote_protocol_features): Add entry for
	"augmented-libraries-svr4-read".
	(remote_augmented_libraries_svr4_read): New function.
	(init_remote_ops): Initialize
	remote_ops.to_augmented_libraries_svr4_read.
@
text
@d5954 3
a5960 3

      if (!target_is_async_p ())
	signal (SIGINT, ofunc);
@


1.552
log
@gdb/
	* tracepoint.c (encode_actions_1): Remove parameter 't'.
	Caller update.
	(encode_actions): Likewise.
	* remote.c (remote_download_tracepoint): Caller update.
	* tracepoint.h (encode_actions): Update declaration.
@
text
@d364 4
d3956 10
d3976 2
d11458 8
d11588 2
@


1.551
log
@gdb/

	* remote.c (remote_check_symbols): Remove unused parameter
	'objfile'.
	Declaration update.
	(remote_start_remote, remote_new_objfile): Caller update.
@
text
@d10509 1
a10509 1
  encode_actions (loc->owner, loc, &tdp_actions, &stepping_actions);
@


1.550
log
@[remote] Insert breakpoints in the right process.

I noticed that gdb.multi/multi-arch.exp wasn't passing with
extended-remote GDBserver with my pending multi-process+multi-arch
series anymore on current mainline, while it used to pass before:

 (gdb) run
 Starting program: /home/pedro/gdb/mygit/build/gdb/testsuite/gdb.multi/ma-hangout
 Process /home/pedro/gdb/mygit/build/gdb/testsuite/gdb.multi/ma-hangout created; pid = 32067
 Warning:
 Cannot insert breakpoint 2.
 Error accessing memory address 0x4005c2: Unknown error -1.
 Cannot insert breakpoint -1.
 Temporarily disabling shared library breakpoints:
 breakpoint #-1

 (gdb) FAIL: gdb.multi/multi-arch.exp: starting inferior 2


Investigating manually, I found an easy way to reproduce.  You just
need breakpoints on distinct inferiors, and a way to have GDB install
them in one go:

 (gdb) set breakpoint always-inserted on
 (gdb) info breakpoints
 Num     Type           Disp Enb Address            What
 2       breakpoint     del  n   <MULTIPLE>
 2.1                         y     0x00000000004005c2 in main at ../../../src/gdb/testsuite/gdb.multi/hello.c:40 inf 1
 2.2                         y     0x08048475         in main at ../../../src/gdb/testsuite/gdb.multi/hangout.c:22 inf 2
 (gdb) enable 2
 Warning:
 Cannot insert breakpoint 2.
 Error accessing memory address 0x4005c2: Unknown error -1.

And turning on remote debugging, we see:

 (gdb) set debug remote 1
 (gdb) disable 2
 (gdb) enable 2
 Sending packet: $Z0,4005c2,1#71...Packet received: E01
 Sending packet: $Z0,8048475,1#87...Packet received: OK
 Warning:
 Cannot insert breakpoint 2.
 Error accessing memory address 0x4005c2: Unknown error -1.

Notice that each of those Z0 breakpoints should be set in different
processes.  However, no Hg packet to select a process has been sent in
between, so GDBserver tries to plant both on the same process that
happens to be current.  The first Z0 then not so surprisingly fails.
IOW, the blame is on GDB, for telling GDBserver to plant both
breakpoints in the same process.

remote.c has a lazy scheme where it keeps a local cache of the
remote's selected general thread, and delays updating it on the remote
side until necessary (memory/register reads/writes, etc.).  This is
done to reduce RSP traffic.  The bug is that the Zx breakpoint
insert/remove methods weren't committing the selected thread/process
back to the remote side:

 Breakpoint 3, remote_insert_breakpoint (gdbarch=0x1383ae0, bp_tgt=0x140c2b0) at ../../src/gdb/remote.c:8148
 8148      if (remote_protocol_packets[PACKET_Z0].support != PACKET_DISABLE)
 (top-gdb) p inferior_ptid
 $3 = {pid = 3670, lwp = 0, tid = 3670}
 (top-gdb) p general_thread
 $4 = {pid = 3671, lwp = 0, tid = 3671}

IOW, a call to set_general_process is missing.

I did some auditing over remote.c, and added calls to all places I
found missing it.

This only used to work by chance before.  breakpoint.c switches to a
thread of the target process before installing a breakpoint location.
That calls switch_to_thread.  Before:

 2012-07-27  Yao Qi  <yao@@codesourcery.com>

         * thread.c (switch_to_thread): Don't call registers_changed.

that caused the register caches to all be flushed and refetched before
installing the breakpoint location.  Given fetching registers commits
the remote general thread (with Hg), masking out the latent bug.

Tested on x86_64 Fedora 17 with GDBserver.

gdb/
2013-05-29  Pedro Alves  <palves@@redhat.com>

	* remote.c (remote_insert_breakpoint, remote_remove_breakpoint)
	(remote_insert_watchpoint, remote_remove_watchpoint)
	(remote_insert_hw_breakpoint, remote_remove_hw_breakpoint)
	(remote_verify_memory, compare_sections_command)
	(remote_search_memory): Set the general process/thread on the
	remote side.
@
text
@d222 1
a222 1
static void remote_check_symbols (struct objfile *objfile);
d3580 1
a3580 1
	remote_check_symbols (symfile_objfile);
d3649 1
a3649 1
remote_check_symbols (struct objfile *objfile)
d11697 1
a11697 1
    remote_check_symbols (objfile);
@


1.549
log
@range stepping: gdb

This patch teaches GDB to take advantage of target-assisted range
stepping.  It adds a new 'r ADDR1,ADDR2' action to vCont (vCont;r),
meaning, "step once, and keep stepping as long as the thread is in the
[ADDR1,ADDR2) range".

Rationale:

When user issues the "step" command on the following line of source,

   a = b + c + d * e - a;

GDB single-steps every single instruction until the program reaches a
new different line.  E.g., on x86_64, that line compiles to:

   0x08048434 <+65>:    mov    0x1c(%esp),%eax
   0x08048438 <+69>:    mov    0x30(%esp),%edx
   0x0804843c <+73>:    add    %eax,%edx
   0x0804843e <+75>:    mov    0x18(%esp),%eax
   0x08048442 <+79>:    imul   0x2c(%esp),%eax
   0x08048447 <+84>:    add    %edx,%eax
   0x08048449 <+86>:    sub    0x34(%esp),%eax
   0x0804844d <+90>:    mov    %eax,0x34(%esp)
   0x08048451 <+94>:    mov    0x1c(%esp),%eax

and the following is the RSP traffic between GDB and GDBserver:

 --> vCont;s:p2e13.2e13;c
 <-- T0505:68efffbf;04:30efffbf;08:3c840408;thread:p2e13.2e13;core:1;
 --> vCont;s:p2e13.2e13;c
 <-- T0505:68efffbf;04:30efffbf;08:3e840408;thread:p2e13.2e13;core:2;
 --> vCont;s:p2e13.2e13;c
 <-- T0505:68efffbf;04:30efffbf;08:42840408;thread:p2e13.2e13;core:2;
 --> vCont;s:p2e13.2e13;c
 <-- T0505:68efffbf;04:30efffbf;08:47840408;thread:p2e13.2e13;core:0;
 --> vCont;s:p2e13.2e13;c
 <-- T0505:68efffbf;04:30efffbf;08:49840408;thread:p2e13.2e13;core:0;
 --> vCont;s:p2e13.2e13;c
 <-- T0505:68efffbf;04:30efffbf;08:4d840408;thread:p2e13.2e13;core:0;
 --> vCont;s:p2e13.2e13;c
 <-- T0505:68efffbf;04:30efffbf;08:51840408;thread:p2e13.2e13;core:0;

IOW, a lot of roundtrips between GDB and GDBserver.

If we add a new command to the RSP, meaning "keep stepping and don't
report a stop until the program goes out of the [0x08048434,
0x08048451) address range", then the RSP traffic can be reduced down
to:

 --> vCont;r8048434,8048451:p2db0.2db0;c
 <-- T0505:68efffbf;04:30efffbf;08:51840408;thread:p2db0.2db0;core:1;

As number of packets is reduced dramatically, the performance of
stepping source lines is much improved.

In case something is wrong with range stepping on the stub side, the
debug info or even gdb, this adds a "set/show range-stepping" command
to be able to turn range stepping off.

gdb/
2013-05-23  Yao Qi  <yao@@codesourcery.com>
	    Pedro Alves  <palves@@redhat.com>

	* gdbthread.h (struct thread_control_state) <may_range_step>: New
	field.
	* infcmd.c (step_once, until_next_command): Enable range stepping.
	* infrun.c (displaced_step_prepare): Disable range stepping.
	(resume): Disable range stepping if stepping over a breakpoint or
	we have software watchpoints.  If range stepping is enabled,
	assert the thread is in the stepping range.
	(clear_proceed_status_thread): Clear may_range_step.
	(handle_inferior_event): Disable range stepping as soon as we know
	the thread that hit the event.  Re-enable it whenever we're going
	to step with a step range.
	* remote.c (struct vCont_action_support) <r>: New field.
	(use_range_stepping): New global.
	(remote_vcont_probe): Handle 'r' action.
	(append_resumption): Append an 'r' action if the thread may range
	step.
	(show_range_stepping): New function.
	(set_range_stepping): New function.
	(_initialize_remote): Call add_setshow_boolean_cmd to register the
	'set range-stepping' and 'show range-stepping' commands.
	* NEWS: Mention range stepping, the new vCont;r action, and the
	new "set/show range-stepping" commands.

gdb/doc/
2013-05-23  Yao Qi  <yao@@codesourcery.com>
	    Pedro Alves  <palves@@redhat.com>

	* gdb.texinfo (Packets): Document 'vCont;r'.
	(Continuing and Stepping): Document target-assisted range
	stepping, and the 'set range-stepping' and 'show range-stepping'
	commands.
@
text
@d8156 5
d8211 5
d8265 5
d8314 5
d8422 5
d8480 5
d8548 3
d8595 3
d9024 3
@


1.548
log
@Convert rs->support_vCont_t to a struct.

Convert the 'support_vCont_t' int field to a struct, in preparation
for adding more fields to it.

gdb/
2013-05-23  Yao Qi  <yao@@codesourcery.com>
	    Pedro Alves  <palves@@redhat.com>

	* remote.c (struct vCont_action_support): New struct.
	(struct remote_state) <support_vCont_t>: Remove field.
	<vCont_actions_support>: New field.
	(remote_vcont_probe, remote_stop_ns): Update.
@
text
@d263 3
d268 4
d4663 1
d4677 2
d4710 36
d11708 38
d12143 14
@


1.547
log
@	* remote.c (remote_set_trace_notes): Make arguments const.
	* target.c (update_current_target): Update cast.
	* target.h (to_set_trace_notes): Make arguments const.
@
text
@d254 11
d322 2
a323 2
  /* True if the stub reports support for vCont;t.  */
  int support_vCont_t;
d4655 1
a4655 1
      rs->support_vCont_t = 0;
d4668 1
a4668 1
	    rs->support_vCont_t = 1;
d5017 1
a5017 1
  if (!rs->support_vCont_t)
@


1.546
log
@Fix typo in "show remote traceframe-info-packet"

I noticed:

  (gdb) show remote traceframe-info-packet
  Support for the `qXfer:trace-frame-info:read' packet is auto-detected, currently unknown.
                         ^^^^^^^^^^^

The packet is actually qXfer:traceframe-info:read.

gdb/
2013-05-10  Pedro Alves  <palves@@redhat.com>

	* remote.c (_initialize_remote): Fix spelling of
	qXfer:traceframe-info:read packet in packet config command.
@
text
@d11129 2
a11130 1
remote_set_trace_notes (char *user, char *notes, char *stop_notes)
@


1.545
log
@PR remote/15455 - QTro remote packet broken

In the function remote_trace_set_readonly_regions in gdb/remote.c, the
local variable 'offset' does not account for "QTro" at the start of
the packet with the result that if there are any read-only regions,
the packet is sent -- but without the "QTro" -- causing the remote
stub to report that the packet is unsupported:

  Sending packet: $:0000000000400200,(...),00000000004560a4#ab...Packet received:

vs the expected:

  Sending packet: $QTro:0000000000400200,(...),00000000004560a4#31...Packet received: OK

We don't see the problem when testing with GDBserver, as that supports
qXfer:trace-frame-info:read, meaning GDBserver never needs to read
from the read-only sections directly itself.  This commit adds a test
that explicitly disables qXfer:trace-frame-info:read.

gdb/
2013-05-10  David Taylor  <dtaylor@@emc.com>

	PR remote/15455

	* remote.c (remote_trace_set_readonly_regions): Do not overwrite
	"QTro" at start of packet.

gdb/testsuite/
2013-05-10  Pedro Alves  <palves@@redhat.com>

	PR remote/15455

	* gdb.trace/qtro.c: New file.
	* gdb.trace/qtro.exp: New file.
@
text
@d11894 1
a11894 1
     "qXfer:trace-frame-info:read", "traceframe-info", 0);
@


1.544
log
@	PR gdb/7912:
	* Makefile.in (SFILES): Add filestuff.c
	(COMMON_OBS): Add filestuff.o.
	(filestuff.o): New target.
	* auto-load.c (auto_load_objfile_script_1): Use
	gdb_fopen_cloexec.
	* auxv.c (procfs_xfer_auxv): Use gdb_open_cloexec.
	* cli/cli-cmds.c (shell_escape): Call close_most_fds.
	* cli/cli-dump.c (fopen_with_cleanup): Use gdb_fopen_cloexec.
	* common/agent.c (gdb_connect_sync_socket): Use
	gdb_socket_cloexec.
	* common/filestuff.c: New file.
	* common/filestuff.h: New file.
	* common/linux-osdata.c (linux_common_core_of_thread)
	(command_from_pid, commandline_from_pid, print_source_lines)
	(linux_xfer_osdata_shm, linux_xfer_osdata_sem)
	(linux_xfer_osdata_msg, linux_xfer_osdata_modules): Use
	gdb_fopen_cloexec.
	* common/linux-procfs.c (linux_proc_get_int)
	(linux_proc_pid_has_state): Use gdb_fopen_cloexec.
	* config.in, configure: Rebuild.
	* configure.ac: Don't check for sys/socket.h.  Check for
	fdwalk, pipe2.
	* corelow.c (core_open): Use gdb_open_cloexec.
	* dwarf2read.c (write_psymtabs_to_index): Use gdb_fopen_cloexec.
	* fork-child.c (fork_inferior): Call close_most_fds.
	* gdb_bfd.c (gdb_bfd_open): Use gdb_open_cloexec.
	* inf-child.c (inf_child_fileio_readlink): Use gdb_open_cloexec.
	* linux-nat.c (linux_nat_thread_name, linux_proc_pending_signals):
	Use gdb_fopen_cloexec.
	(linux_proc_xfer_partial, linux_proc_xfer_spu): Use
	gdb_open_cloexec.
	(linux_async_pipe): Use gdb_pipe_cloexec.
	* remote-fileio.c (remote_fileio_func_open): Use
	gdb_open_cloexec.
	* remote.c (remote_file_put, remote_file_get): Use
	gdb_fopen_cloexec.
	* ser-pipe.c (pipe_open): Use gdb_socketpair_cloexec,
	close_most_fds.
	* ser-tcp.c (net_open): Use gdb_socket_cloexec.
	* ser-unix.c (hardwire_open): Use gdb_open_cloexec.
	* solib.c (solib_find): Use gdb_open_cloexec.
	* source.c (openp, find_and_open_source): Use gdb_open_cloexec.
	* tracepoint.c (tfile_start): Use gdb_fopen_cloexec.
	(tfile_open): Use gdb_open_cloexec.
	* tui/tui-io.c (tui_initialize_io): Use gdb_pipe_cloexec.
	* ui-file.c (gdb_fopen): Use gdb_fopen_cloexec.
	* xml-support.c (xml_fetch_content_from_file): Use
	gdb_fopen_cloexec.
	* main.c (captured_main): Call notice_open_fds.
gdbserver
	* Makefile.in (SFILES): Add filestuff.c.
	(OBS): Add filestuff.o.
	(filestuff.o): New target.
	* config.in, configure: Rebuild.
	* configure.ac: Check for fdwalk, pipe2.
@
text
@d10670 1
@


1.543
log
@gdb_byte for binary buffer, char for string: remote.c, tracepoint.c.

While the RSP is largely ASCII based (hence the packet buffer type is
char *), at places we pass around 8-bit binary packets in that buffer.
Functions like hex2bin or remote_escape_output conceptually are
handling binary buffers, so I left them as working with gdb_byte, and
added casts where necessary.  Whether these are host bytes or target
bytes is blurry at present, so this is largely a matter of taste.
Switching some of these functions to take "char *" or "void *" would
be equally good.

gdb/
2013-04-19  Pedro Alves  <palves@@redhat.com>

	* remote.c (remote_write_bytes_aux, compare_sections_command)
	(remote_read_qxfer)
	(remote_search_memory, remote_hostio_pwrite, remote_hostio_pread)
	(remote_hostio_readlink, remote_bfd_iovec_pread)
	(remote_set_trace_notes): Use gdb_byte when RSP buffer is used as
	binary buffer, and char when buffer is used as string.
	* tracepoint.c (encode_source_string, tfile_write_uploaded_tp)
	(trace_save, tfile_open, traceframe_walk_blocks)
	(tfile_fetch_registers): Likewise.
@
text
@d47 1
d10015 1
a10015 1
  file = fopen (local_file, "rb");
d10107 1
a10107 1
  file = fopen (local_file, "wb");
@


1.542
log
@-Wpointer-sign: char -> gdb_byte.

-Wpointer-sign catches all these cases across the codebase that should
be using gdb_byte for raw target bytes.  I think these are all
obvious, hence I've collapsed into a single patch.

gdb/
2013-04-19  Pedro Alves  <palves@@redhat.com>

	* aarch64-tdep.c (aarch64_default_breakpoint): Change type to
	gdb_byte[].
	(aarch64_breakpoint_from_pc): Change return type to gdb_byte *.
	* ada-lang.c (ada_value_assign): Use gdb_byte.
	* alphanbsd-tdep.c (sigtramp_retcode): Change type to gdb_byte[].
	(alphanbsd_sigtramp_offset): Use gdb_byte.
	* arm-linux-tdep.c (arm_linux_arm_le_breakpoint)
	(arm_linux_arm_be_breakpoint, eabi_linux_arm_le_breakpoint)
	(eabi_linux_arm_be_breakpoint, arm_linux_thumb_be_breakpoint)
	(arm_linux_thumb_le_breakpoint, arm_linux_thumb2_be_breakpoint)
	(arm_linux_thumb2_le_breakpoint): Change type to gdb_byte[].
	* arm-tdep.c (arm_stub_unwind_sniffer)
	(arm_displaced_init_closure): Use gdb_byte.
	(arm_default_arm_le_breakpoint, arm_default_arm_be_breakpoint)
	(arm_default_thumb_le_breakpoint)
	(arm_default_thumb_be_breakpoint): Change type to gdb_byte[].
	* arm-tdep.h (struct gdbarch_tdep) <arm_breakpoint,
	thumb_breakpoint, thumb2_breakpoint>: Change type to gdb_byte *.
	* arm-wince-tdep.c (arm_wince_le_breakpoint)
	(arm_wince_thumb_le_breakpoint): Change type to gdb_byte[].
	* armnbsd-tdep.c (arm_nbsd_arm_le_breakpoint)
	(arm_nbsd_arm_be_breakpoint, arm_nbsd_thumb_le_breakpoint)
	(arm_nbsd_thumb_be_breakpoint): Change type to gdb_byte[].
	* armobsd-tdep.c (arm_obsd_thumb_le_breakpoint)
	(arm_obsd_thumb_be_breakpoint): Change type to gdb_byte[].
	* cris-tdep.c (push_stack_item, cris_push_dummy_call)
	(cris_store_return_value, cris_extract_return_value): Use
	gdb_byte.
	(constraint): Change type of parameter to char * from signed
	char*.  Use gdb_byte.
	* dwarf2loc.c (read_pieced_value, write_pieced_value): Change type
	of local buffer to gdb_byte *.
	* dwarf2read.c (read_index_from_section): Use gdb_byte.
	(create_dwp_hash_table): Change type of locals to gdb_byte *.
	(add_address_entry): Change type of local buffer to gdb_byte[].
	* frv-tdep.c (frv_adjust_breakpoint_address, find_func_descr)
	(frv_push_dummy_call): Use gdb_byte.
	* hppa-hpux-tdep.c (hppa_hpux_push_dummy_code)
	(hppa_hpux_supply_ss_fpblock, hppa_hpux_supply_ss_wide)
	(hppa_hpux_supply_save_state): Use gdb_byte.
	* hppa-tdep.c (hppa32_push_dummy_call)
	(hppa64_convert_code_addr_to_fptr): Use gdb_byte.
	* ia64-tdep.c (extract_bit_field, replace_bit_field)
	(slotN_contents, replace_slotN_contents): Change type of parameter
	to gdb_byte *.
	(fetch_instruction, ia64_pseudo_register_write)
	(ia64_register_to_value, ia64_value_to_register)
	(ia64_extract_return_value, ia64_store_return_value)
	(ia64_push_dummy_call): Use gdb_byte.
	* m32c-tdep.c (m32c_return_value): Remove cast.
	* m68hc11-tdep.c (m68hc11_pseudo_register_write)
	(m68hc11_push_dummy_call, m68hc11_store_return_value): Use
	gdb_byte.
	* mipsnbsd-tdep.c (mipsnbsd_get_longjmp_target): Use gdb_byte.
	* mn10300-tdep.c (mn10300_store_return_value)
	(mn10300_breakpoint_from_pc, mn10300_push_dummy_call): Use
	gdb_byte.
	* moxie-tdep.c (moxie_process_readu): Use gdb_byte.
	(moxie_process_record): Remove casts.
	* ppc-ravenscar-thread.c (supply_register_at_address)
	(ppc_ravenscar_generic_store_registers): Use gdb_byte.
	* ravenscar-thread.c (get_running_thread_id): Use gdb_byte.
	* remote-m32r-sdi.c (m32r_fetch_register): Use gdb_byte.
	* remote-mips.c (mips_xfer_memory): Use gdb_byte.
	* remote.c (compare_sections_command): Use gdb_byte.
	* score-tdep.c (score7_free_memblock): Change type of parameter to
	gdb_byte *.
	* sh-tdep.c (sh_justify_value_in_reg): Change return type to
	gdb_byte *.  Use gdb_byte.
	(sh_push_dummy_call_fpu): Use gdb_byte.
	(sh_extract_return_value_nofpu, sh_extract_return_value_fpu)
	(sh_store_return_value_nofpu, sh_store_return_value_fpu)
	(sh_register_convert_to_virtual, sh_register_convert_to_raw):
	Change parameter type to 'gdb_byte *'.  Use gdb_byte.
	(sh_pseudo_register_read, sh_pseudo_register_write): Use gdb_byte.
	* sh64-tdep.c (sh64_push_dummy_call): Use gdb_byte.
	(sh64_store_return_value, sh64_register_convert_to_virtual):
	Change parameter type to 'gdb_byte *'.  Use gdb_byte.
	(sh64_pseudo_register_write): Use gdb_byte.
	* solib-darwin.c (darwin_current_sos): Add casts to 'gdb_byte *'.
	* solib-irix.c (fetch_lm_info): Likewise.  Use gdb_byte for byte
	buffer.
	(irix_current_sos): Use gdb_byte.
	* solib-som.c (som_current_sos): Use gdb_byte.
	* sparc-ravenscar-thread.c (supply_register_at_address)
	(sparc_ravenscar_generic_store_registers): Use gdb_byte.
	* spu-multiarch.c (spu_xfer_partial): Add cast to 'char *'.
	* spu-tdep.c (spu_get_overlay_table): Use gdb_byte.
	* tic6x-tdep.c (tic6x_breakpoint_from_pc): Change return type to
	'gdb_byte *'.
	* tic6x-tdep.h (struct gdbarch_tdep) <breakpoint>: Change type to
	'gdb_byte *'.
	* tracepoint.c (tfile_fetch_registers): Use gdb_byte.
	* xstormy16-tdep.c (xstormy16_extract_return_value)
	(xstormy16_store_return_value): Change parameter type to
	'gdb_byte *'.  Adjust.
	(xstormy16_push_dummy_call): Use gdb_byte.
	* xtensa-tdep.c (xtensa_scan_prologue, call0_ret)
	(call0_analyze_prologue, execute_code): Use gdb_byte.
@
text
@d6747 2
a6748 2
      payload_length = remote_escape_output (myaddr, todo, p, &nr_bytes,
					     payload_size);
d6761 1
a6761 1
						   p, &nr_bytes,
d8578 1
a8578 1
    (writebuf, len, (rs->buf + i), &max_size, max_size);
d8657 2
a8658 1
  i = remote_unescape_input (rs->buf + 1, packet_len - 1, readbuf, n);
d8939 1
a8939 1
    remote_escape_output (pattern, pattern_len, (rs->buf + i),
d9713 1
a9713 1
  p += remote_escape_output (write_buf, len, p, &out_len,
d9752 1
a9752 1
  read_len = remote_unescape_input (attachment, attachment_len,
d9826 2
a9827 2
  read_len = remote_unescape_input (attachment, attachment_len,
				    ret, len);
d9956 1
a9956 1
      bytes = remote_hostio_pread (fd, (char *)buf + pos, nbytes - pos,
d11139 1
a11139 1
      nbytes = bin2hex (user, buf, 0);
d11146 1
a11146 1
      nbytes = bin2hex (notes, buf, 0);
d11153 1
a11153 1
      nbytes = bin2hex (stop_notes, buf, 0);
@


1.541
log
@gdb/
	Fix GDB regression related to PR binutils/14813.
	* jit.c (mem_bfd_iovec_close): Return 0 for success.
	* minidebug.c (lzma_close): Add return value comment.
	* remote.c (remote_bfd_iovec_close): Return 0 for success.
	* solib-spu.c (spu_bfd_iovec_close): Likewise.
	* spu-linux-nat.c (spu_bfd_iovec_close): Likewise.
@
text
@d8493 1
a8493 1
  char *sectdata;
@


1.540
log
@
gdb/
	* remote.c (unpush_and_perror): Add output message final dot.
@
text
@d9940 2
a9941 1
  return 1;
@


1.539
log
@Avoid potencially-stale errno usage.

The current throw_perror_with_name/TARGET_CLOSE_ERROR calls assume
errno is still set to the right error, although remote_unpush_target
is called in between, which may well change errno.

Tested on x86_64 Fedora 17 w/ gdbserver.

gdb/
2013-04-09  Pedro Alves  <palves@@redhat.com>

	* remote.c (unpush_and_perror): New function.
	(readchar, remote_serial_write): Use it.
@
text
@d7039 2
a7040 1
   then the system error message for errno at function entry.  */
d7045 1
a7045 4
  char *errstr;

  errstr = xstrprintf ("%s: %s", string, safe_strerror (errno));
  make_cleanup (xfree, errstr);
d7048 2
a7049 1
  throw_error (TARGET_CLOSE_ERROR, "%s", errstr);
@


1.538
log
@gdb/
	* remote.c (remote_trace_find): Change type of parameters 'addr1'
	and 'addr2' to CORE_ADDR.
	* target.c (update_current_target): Update.
	* target.h (struct target_ops) <to_trace_find>: Change parameter
	type to CORE_ADDR.
	* tracepoint.c (tfind_1): Change type of parameters 'addr1' and
	'addr2' to CORE_ADDR.
	(tfile_trace_find): Likewise.
	(tfile_get_traceframe_address): Change return type to CORE_ADDR.
	Change local variable 'addr' to type CORE_ADDR.
	* tracepoint.h (tfind_1): Update declaration.
@
text
@d7036 17
d7072 2
a7073 4
      remote_unpush_target ();
      throw_perror_with_name (TARGET_CLOSE_ERROR,
			      _("Remote communication error.  "
				"Target disconnected."));
d7089 2
a7090 4
      remote_unpush_target ();
      throw_perror_with_name (TARGET_CLOSE_ERROR,
			      _("Remote communication error.  "
				"Target disconnected."));
@


1.537
log
@gdb/
	Revert this patch:
	PR gdb/15275
	* remote.c (remote_get_trace_status): Include putpkt in TRY_CATCH.
@
text
@d10811 1
a10811 1
		   ULONGEST addr1, ULONGEST addr2,
@


1.536
log
@unpush the remote target if serial_write fails.

PR gdb/15275 notes that when debugging with a remote connection over a
serial link and the link is disconnected, say by disconnecting USB
serial port, the GDB quit command no longer works:

 (gdb)
 tar ext /dev/ttyACM0
 &"tar ext /dev/ttyACM0\n"
 ~"Remote debugging using /dev/ttyACM0\n"
 ^done
 (gdb)
 set debug remote 1
 &"set debug remote 1\n"
 ^done
 (gdb)
 quit
 &"quit\n"
 &"Sending packet: $qTStatus#49..."
 &"putpkt: write failed: Input/output error.\n"
 ^error,msg="putpkt: write failed: Input/output error."
 (gdb)
 (gdb)
 quit
 &"quit\n"
 &"Sending packet: $qTStatus#49..."
 &"putpkt: write failed: Input/output error.\n"
 ^error,msg="putpkt: write failed: Input/output error."

This is not reproducible with TCP connections, as with that, sending
doesn't error out, but instead the error is detected on the subsequent
readchar.  When that read fails, we unpush the remote target, and
throw TARGET_CLOSE_ERROR.  To address PR gdb/15275, instead of
catching the error in remote_get_trace_status as presently done (which
leaves this same issue latent for another packet to trip on), or of
making ser-unix.c fake success too on failed writes, so we'd get to
readchar detecting the error on serial ports too, better let the error
propagate out of serial_write, and catch it at the remote.c level,
throwing away the target if writing fails too, instead of delaying
that until the next read.

gdb/
2013-04-02  Pedro Alves  <palves@@redhat.com>

	PR gdb/15275

	* remote.c (send_interrupt_sequence): Use remote_serial_write.
	(remote_serial_write): New function.
	(putpkt_binary, getpkt_or_notif_sane_1): Use remote_serial_write.
@
text
@d10716 2
a10719 1
      putpkt ("qTStatus");
@


1.535
log
@Stop sending qTStatus if the target doesn't recognize it; add packet configuration command.

GDB currently sends a qTStatus even if the target previously replied
an empty packet to a previous qTStatus.  If the target doesn't
recognize the packet, there's no point in trying again.

The machinery we have in place is packet_ok, which has the nice side
effect of forcing one to install a configuration command/knob for the
packet in question, which is often handy when you need to debug
things, and/or emulate a target that doesn't support the packet, or even,
it can be used as workaround for the old broken kgdb's that return error
to qTSTatus instead of an empty packet.

gdb/
2013-03-28  Pedro Alves  <palves@@redhat.com>

	* NEWS (New options): New section.
	(New options): Mention set/show remote trace-status-packet.
	* remote.c (PACKET_qTStatus): New enumeration value.
	(remote_get_trace_status): Skip sending qTStatus if the packet is
	disabled.  Use packet_ok.
	(_initialize_remote): Register a configuration command for
	qTStatus packet.

gdb/doc/
2013-03-28  Pedro Alves  <palves@@redhat.com>

	* gdb.texinfo (Remote Configuration) <set remote @@var{name}-packet
	table>: Add entry for "trace-status".
@
text
@d125 2
d3215 1
a3215 1
    serial_write (remote_desc, "\x03", 1);
d3221 1
a3221 1
      serial_write (remote_desc, "g", 1);
d7066 15
d7201 1
a7201 2
      if (serial_write (remote_desc, buf2, p - buf2))
	perror_with_name (_("putpkt: write failed"));
d7256 1
a7256 1
		serial_write (remote_desc, "+", 1);
d7611 1
a7611 1
	  serial_write (remote_desc, "-", 1);
d7622 1
a7622 1
	    serial_write (remote_desc, "+", 1);
d7642 1
a7642 1
	    serial_write (remote_desc, "+", 1);
@


1.534
log
@gdb/
	PR gdb/15275
	* remote.c (remote_get_trace_status): Include putpkt in TRY_CATCH.
@
text
@d1259 1
d10693 4
d10715 2
d10718 1
a10718 1
  if (*p == '\0')
d11886 3
@


1.533
log
@Make "set/show remoteaddresssize" a zuinteger command instead of uinteger.

It makes no sense to talk about an "unlimited" address size in this
context.

 (gdb) show remoteaddresssize
 The maximum size of the address (in bits) in a memory packet is 0.
 (gdb) set remoteaddresssize 0
 (gdb) show remoteaddresssize
 The maximum size of the address (in bits) in a memory packet is unlimited.

"set remoteaddresssize 0" mapping to UINT_MAX means you can't
force gdb through this path twice in the same GDB run:

  static CORE_ADDR
  remote_address_masked (CORE_ADDR addr)
  {
    unsigned int address_size = remote_address_size;

    /* If "remoteaddresssize" was not set, default to target address size.  */
    if (!address_size)
      address_size = gdbarch_addr_bit (target_gdbarch ());

gdb/
2013-03-26  Pedro Alves  <palves@@redhat.com>

	* remote.c (_initialize_remote): Make "set remoteaddresssize"
	a zuinteger command instead of uinteger.
@
text
@a10694 2
  putpkt ("qTStatus");

d10697 1
@


1.532
log
@gdb/
	* exceptions.h (enum errors): New entry TARGET_CLOSE_ERROR.
	* remote.c (trace_error): Remove the special handling of '2'.
	(readchar) <SERIAL_EOF>
	(readchar) <SERIAL_ERROR>
	(getpkt_or_notif_sane_1): Use TARGET_CLOSE_ERROR for them.
	(remote_get_trace_status): Call throw_exception if EX is
	TARGET_CLOSE_ERROR.
	* utils.c (perror_with_name): Rename to ...
	(throw_perror_with_name): ... here.  New parameter errcode, describe it
	in the function comment.
	(perror_with_name): New function wrapper.
	* utils.h (enum errors): New stub declaration.
	(throw_perror_with_name): New declaration.

gdb/testsuite/
	* gdb.server/server-kill.c: New file.
	* gdb.server/server-kill.exp: New file.
@
text
@d11776 2
a11777 2
  add_setshow_uinteger_cmd ("remoteaddresssize", class_obscure,
			    &remote_address_size, _("\
d11780 3
a11782 3
			    NULL,
			    NULL, /* FIXME: i18n: */
			    &setlist, &showlist);
@


1.531
log
@gdb/
	* remote.c (remote_unpush_target): New function.
	(remote_open_1): Remove two pop_target calls, update one comment, add
	comment to target_preopen call.  Replace pop_target call by
	remote_unpush_target call.
	(interrupt_query, readchar, getpkt_or_notif_sane_1): Replace
	pop_target calls by remote_unpush_target calls.
@
text
@a432 2
    case '2':
      error (_("trace API error 0x%s."), ++buf);
d7049 1
a7049 1
      error (_("Remote connection closed"));
d7053 3
a7055 2
      perror_with_name (_("Remote communication error.  "
			  "Target disconnected."));
d7578 3
a7580 1
		  error (_("Watchdog timeout has expired.  Target detached."));
d10703 6
a10708 2
      exception_fprintf (gdb_stderr, ex, "qTStatus: ");
      return -1;
@


1.530
log
@gdb/
	Code cleanup.
	* bfd-target.c (target_bfd_xclose): Remove parameter quitting.
	* bsd-kvm.c (bsd_kvm_close): Likewise.
	* bsd-uthread.c (bsd_uthread_close): Likewise.
	* corelow.c (core_close): Likewise.
	(core_close_cleanup): Remove parameter quitting from a caller.
	* event-top.c (async_disconnect): Likewise.
	* exec.c (exec_close_1): Remove parameter quitting.
	* go32-nat.c (go32_close): Likewise.
	* linux-nat.c (linux_nat_close): Remove parameter quitting.  Remove
	parameter quitting from a caller.
	* mips-linux-nat.c (super_close): Remove parameter quitting from the
	variable.
	(mips_linux_close): Remove parameter quitting.  Remove parameter
	quitting from a caller.
	* monitor.c (monitor_close): Remove parameter quitting.
	* monitor.h (monitor_close): Likewise.
	* record-btrace.c (record_btrace_close): Likewise.
	* record-full.c (record_full_close): Likewise.
	* remote-m32r-sdi.c (m32r_close): Remove parameter quitting and remove
	it also from fprintf_unfiltered.
	* remote-mips.c (mips_close): Remove parameter quitting.
	(mips_detach): Remove parameter quitting from a caller.
	* remote-sim.c (gdbsim_close): Remove parameter quitting.
	(gdbsim_close): Remove duplicate function comment.  Remove parameter
	quitting and remove it also from printf_filtered.
	* remote.c (remote_close): Remove parameter quitting.
	* solib-svr4.c (enable_break): Remove parameter quitting from a caller.
	* target.c (update_current_target): Remove parameter int from to_close
	de_fault.
	(push_target, unpush_target, pop_target): Remove parameter quitting from
	a caller.
	(pop_all_targets_above, pop_all_targets): Remove parameter quitting.
	Remove parameter quitting from a caller.
	(target_preopen): Remove parameter quitting from a caller.
	(target_close): Remove parameter quitting.  Remove parameter quitting
	from a caller two times.  Remove parameter quitting also from
	fprintf_unfiltered.
	* target.h (struct target_ops): Remove parameter quitting and as int
	from fields to_xclose and to_close.
	(extern struct target_ops current_target):
	(target_close, pop_all_targets): Remove parameter quitting.  Update the
	comment.
	(pop_all_targets_above): Remove parameter quitting.
	* top.c (quit_target): Remove parameter quitting from a caller.
	* tracepoint.c (tfile_close): Remove parameter quitting.
	* windows-nat.c (windows_close): Remove parameter quitting.
@
text
@d4191 8
d4216 2
a4217 3
     But if we're connected to a target system with no running process,
     then we will still be connected when it returns.  Ask this question
     first, before target_preopen has a chance to kill anything.  */
d4220 2
a4221 4
      if (!from_tty
	  || query (_("Already connected to a remote target.  Disconnect? ")))
	pop_target ();
      else
d4225 1
a4227 10
  unpush_target (target);

  /* This time without a query.  If we were connected to an
     extended-remote target and target_preopen killed the running
     process, we may still be connected.  If we are starting "target
     remote" now, the extended-remote target will not have been
     removed by unpush_target.  */
  if (remote_desc != NULL && !have_inferiors ())
    pop_target ();

d4347 1
a4347 1
	  pop_target ();
d5095 1
a5095 1
	  pop_target ();
d7050 1
a7050 1
      pop_target ();
d7054 1
a7054 1
      pop_target ();
d7578 1
a7578 1
		  pop_target ();
@


1.529
log
@Constify strings in tracepoint.c, lookup_cmd and the completers.

This is sort of a continuation of Keith's parse_exp_1 constification
patch.  It started out by undoing these bits:

  @@@@ -754,9 +754,12 @@@@ validate_actionline (char **line, struct
   	  tmp_p = p;
   	  for (loc = t->base.loc; loc; loc = loc->next)
   	    {
  -	      p = tmp_p;
  -	      exp = parse_exp_1 (&p, loc->address,
  +	      const char *q;
  +
  +	      q = tmp_p;
  +	      exp = parse_exp_1 (&q, loc->address,
   				 block_for_pc (loc->address), 1);
  +	      p = (char *) q;

and progressively making more things const upwards, fixing fallout,
rinse repeat, until GDB built again (--enable-targets=all).

That ended up constifying lookup_cmd/add_cmd and (lots of) friends,
and the completers.

I didn't try to constify the command hooks themselves, because I know
upfront there are commands that write to the command string argument,
and I think I managed to stop at a nice non-hacky split point already.

I think the only non-really-super-obvious changes are
tracepoint.c:validate_actionline, and tracepoint.c:trace_dump_actions.

The rest is just mostly about 'char *' => 'const char *', 'char **'=>
'const char **', and the occasional (e.g., deprecated_cmd_warning)
case of 'char **'=> 'const char *', where/when I noticed that nothing
actually cares about the pointer to pointer output.

Tested on x86_64 Fedora 17, native and gdbserver.

gdb/
2013-03-13  Pedro Alves  <palves@@redhat.com>

	* ada-lang.c (struct add_partial_datum) <text, text0, word>: Make
	fields const.
	(ada_make_symbol_completion_list): Make "text0" parameter const.
	* ax-gdb.c (agent_eval_command_one): Make "exp" parameter const.
	* breakpoint.c (condition_completer): Make "text" and "word"
	parameters const.  Adjust.
	(check_tracepoint_command): Adjust to validate_actionline
	prototype change.
	(catch_syscall_completer): Make "text" and "word" parameters
	const.
	* cli/cli-cmds.c (show_user): Make "comname" local const.
	(valid_command_p): Make "command" parameter const.
	(alias_command): Make "alias_prefix" and "command_prefix" locals
	const.
	* cli/cli-decode.c (add_cmd): Make "name" parameter const.
	(add_alias_cmd): Make "name" and "oldname" parameters const.
	Adjust.  No longer make copy of OLDNAME.
	(add_prefix_cmd, add_abbrev_prefix_cmd, add_set_or_show_cmd)
	(add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_string_noescape_cmd)
	(add_setshow_optional_filename_cmd, add_setshow_integer_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd)
	(add_setshow_zuinteger_unlimited_cmd, add_setshow_zuinteger_cmd)
	(delete_cmd, add_info, add_info_alias, add_com, add_com_alias):
	Make "name" parameter const.
	(help_cmd): Rename "command" parameter to "arg".  New const local
	"command".
	(find_cmd): Make "command" parameter const.
	(lookup_cmd_1): Make "text" parameter pointer to const.  Adjust to
	deprecated_cmd_warning prototype change.
	(undef_cmd_error): Make "cmdtype" parameter const.
	(lookup_cmd): Make "line" parameter const.
	(deprecated_cmd_warning): Change type of "text" parameter to
	pointer to const char, from pointer to pointer to char.  Adjust.
	(lookup_cmd_composition): Make "text" parameter const.
	(complete_on_cmdlist, complete_on_enum): Make "text" and "word"
	parameters const.
	* cli/cli-decode.h (struct cmd_list_element) <name>: Make field
	const.
	* cli/cli-script.c (validate_comname): Make "tem" local const.
	(define_command): New const local "tem_c".  Use it in calls to
	lookup_cmd.
	(document_command): Make "tem" and "comfull" locals const.
	(show_user_1): Make "prefix" and "name" parameters const.
	* cli-script.h (show_user_1): Make "prefix" and "name" parameters
	const.
	* command.h (add_cmd, add_alias_cmd, add_prefix_cmd)
	(add_abbrev_prefix_cmd, completer_ftype, lookup_cmd, lookup_cmd_1)
	(deprecated_cmd_warning, lookup_cmd_composition, add_com)
	(add_com_alias, add_info, add_info_alias, complete_on_cmdlist)
	(complete_on_enum, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_string_noescape_cmd)
	(add_setshow_optional_filename_cmd, add_setshow_integer_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd)
	(add_setshow_zuinteger_cmd, add_setshow_zuinteger_unlimited_cmd):
	Change prototypes, constifying strings.
	* completer.c (noop_completer, filename_completer): Make "text"
	and "prefix" parameters const.
	(location_completer, expression_completer)
	(complete_line_internal): Make "text" and "prefix" parameters
	const and adjust.
	(command_completer, signal_completer): Make "text" and "prefix"
	parameters const.
	* completer.h (noop_completer, filename_completer)
	(expression_completer, location_completer, command_completer)
	(signal_completer): Change prototypes.
	* corefile.c (complete_set_gnutarget): Make "text" and "word"
	parameters const.
	* cp-abi.c (cp_abi_completer): Likewise.
	* expression.h (parse_expression_for_completion): Change
	prototype.
	* f-lang.c (f_make_symbol_completion_list): Make "text" and "word"
	parameters const.
	* infcmd.c (_initialize_infcmd): Make "cmd_name" local const.
	* infrun.c (handle_completer): Make "text" and "word" parameters
	const.
	* interps.c (interpreter_completer): Make "text" and "word"
	parameters const.
	* language.h (struct language_defn)
	<la_make_symbol_completion_list>: Make "text" and "word"
	parameters const.
	* parse.c (parse_exp_1): Move const hack to parse_exp_in_context.
	(parse_exp_in_context): Rename to ...
	(parse_exp_in_context_1): ... this.
	(parse_exp_in_context): Reimplement, with const hack from
	parse_exp_1.
	(parse_expression_for_completion): Make "string" parameter const.
	* printcmd.c (decode_format): Make "string_ptr" parameter pointer
	to pointer to const char.  Adjust.
	(print_command_1): Make "exp" parameter const.
	(output_command): Rename to ...
	(output_command_const): ... this.  Make "exp" parameter const.
	(output_command): Reimplement.
	(x_command): Adjust.
	(display_command): Rename "exp" parameter to "arg".  New "exp"
	local, const version of "arg".
	* python/py-auto-load.c (gdbpy_initialize_auto_load): Make
	"cmd_name" local const.
	* python/py-cmd.c (cmdpy_destroyer): Cast const away in xfree
	call.
	(cmdpy_completer): Make "text" and "word" parameters const.
	(gdbpy_parse_command_name): Make "prefix_text2" local const.
	* python/py-param.c (add_setshow_generic): Make "tmp_name" local
	const.
	* remote.c (_initialize_remote): Make "cmd_name" local const.
	* symtab.c (language_search_unquoted_string): Make "text" and "p"
	parameters const.  Adjust.
	(completion_list_add_fields): Make "sym_text", "text" and "word"
	parameters const.
	(struct add_name_data) <sym_text, text, word>: Make fields const.
	(default_make_symbol_completion_list_break_on): Make "text" and
	"word" parameters const.  Adjust locals.
	(default_make_symbol_completion_list)
	(make_symbol_completion_list, make_symbol_completion_type)
	(make_symbol_completion_list_fn): Make "text" and "word"
	parameters const.
	(make_file_symbol_completion_list): Make "text", "word" and
	"srcfile" parameters const.  Adjust locals.
	(add_filename_to_list): Make "text" and "word" parameters const.
	(struct add_partial_filename_data) <text, word>: Make fields
	const.
	(make_source_files_completion_list): Make "text" and "word"
	parameters const.
	* symtab.h (default_make_symbol_completion_list_break_on)
	(default_make_symbol_completion_list, make_symbol_completion_list)
	(make_symbol_completion_type enum type_code)
	(make_symbol_completion_list_fn make_file_symbol_completion_list)
	(make_source_files_completion_list): Change prototype.
	* top.c (execute_command): Adjust to pass pointer to pointer to
	const char to lookup_cmd, and to deprecated_cmd_warning prototype
	change.
	(set_verbose): Make "cmdname" local const.
	* tracepoint.c (decode_agent_options): Make "exp" parameter const,
	and adjust.
	(validate_actionline): Make "line" parameter a pointer to const
	char, and adjust.
	(encode_actions_1): Make "action_exp" local const, and adjust.
	(encode_actions): Adjust.
	(replace_comma): Delete.
	(trace_dump_actions): Make "action_exp" and "next_comma" locals
	const, and adjust.  Don't frob the action string while splitting
	it at commas.  Instead, make a copy of each split substring in
	turn.
	(trace_dump_command): Adjust to validate_actionline prototype
	change.
	* tracepoint.h (decode_agent_options, decode_agent_options)
	(encode_actions, validate_actionline): Change prototypes.
	* valprint.h (output_command): Delete declaration.
	(output_command_const): Declare.
	* value.c (function_destroyer): Cast const away in xfree call.
@
text
@d111 1
a111 1
static void remote_close (int quitting);
d3004 1
a3004 1
remote_close (int quitting)
@


1.528
log
@2013-03-11  Hafiz Abid Qadeer  <abidh@@codesourcery.com>

	* remote.c (remote_set_trace_buffer_size): Move != operator
	to the start of next line to fix an ARI warning.
@
text
@d11615 1
a11615 1
  char *cmd_name;
@


1.528.2.1
log
@gdb/
	* remote.c (remote_unpush_target): New function.
	(remote_open_1): Remove two pop_target calls, update one comment, add
	comment to target_preopen call.  Replace pop_target call by
	remote_unpush_target call.
	(interrupt_query, readchar, getpkt_or_notif_sane_1): Replace
	pop_target calls by remote_unpush_target calls.
@
text
@a4190 8
/* Remove any of the remote.c targets from target stack.  Upper targets depend
   on it so remove them first.  */

static void
remote_unpush_target (void)
{
  pop_all_targets_above (process_stratum - 1, 0);
}
d4208 3
a4210 2
     Ask this question first, before target_preopen has a chance to kill
     anything.  */
d4213 4
a4216 2
      if (from_tty
	  && !query (_("Already connected to a remote target.  Disconnect? ")))
a4219 1
  /* Here the possibly existing remote target gets unpushed.  */
d4222 10
d4351 1
a4351 1
	  remote_unpush_target ();
d5099 1
a5099 1
	  remote_unpush_target ();
d7054 1
a7054 1
      remote_unpush_target ();
d7058 1
a7058 1
      remote_unpush_target ();
d7582 1
a7582 1
		  remote_unpush_target ();
@


1.528.2.2
log
@gdb/
	* exceptions.h (enum errors): New entry TARGET_CLOSE_ERROR.
	* remote.c (trace_error): Remove the special handling of '2'.
	(readchar) <SERIAL_EOF>
	(readchar) <SERIAL_ERROR>
	(getpkt_or_notif_sane_1): Use TARGET_CLOSE_ERROR for them.
	(remote_get_trace_status): Call throw_exception if EX is
	TARGET_CLOSE_ERROR.
	* utils.c (perror_with_name): Rename to ...
	(throw_perror_with_name): ... here.  New parameter errcode, describe it
	in the function comment.
	(perror_with_name): New function wrapper.
	* utils.h (enum errors): New stub declaration.
	(throw_perror_with_name): New declaration.

gdb/testsuite/
	* gdb.server/server-kill.c: New file.
	* gdb.server/server-kill.exp: New file.
@
text
@d433 2
d7051 1
a7051 1
      throw_error (TARGET_CLOSE_ERROR, _("Remote connection closed"));
d7055 2
a7056 3
      throw_perror_with_name (TARGET_CLOSE_ERROR,
			      _("Remote communication error.  "
				"Target disconnected."));
d7579 1
a7579 3
		  throw_error (TARGET_CLOSE_ERROR,
			       _("Watchdog timeout has expired.  "
				 "Target detached."));
d10702 2
a10703 6
      if (ex.error != TARGET_CLOSE_ERROR)
	{
	  exception_fprintf (gdb_stderr, ex, "qTStatus: ");
	  return -1;
	}
      throw_exception (ex);
@


1.528.2.3
log
@gdb/
	PR gdb/15275
	* remote.c (remote_get_trace_status): Include putpkt in TRY_CATCH.
@
text
@d10695 2
a10698 1
      putpkt ("qTStatus");
@


1.528.2.4
log
@unpush the remote target if serial_write fails.

PR gdb/15275 notes that when debugging with a remote connection over a
serial link and the link is disconnected, say by disconnecting USB
serial port, the GDB quit command no longer works:

 (gdb)
 tar ext /dev/ttyACM0
 &"tar ext /dev/ttyACM0\n"
 ~"Remote debugging using /dev/ttyACM0\n"
 ^done
 (gdb)
 set debug remote 1
 &"set debug remote 1\n"
 ^done
 (gdb)
 quit
 &"quit\n"
 &"Sending packet: $qTStatus#49..."
 &"putpkt: write failed: Input/output error.\n"
 ^error,msg="putpkt: write failed: Input/output error."
 (gdb)
 (gdb)
 quit
 &"quit\n"
 &"Sending packet: $qTStatus#49..."
 &"putpkt: write failed: Input/output error.\n"
 ^error,msg="putpkt: write failed: Input/output error."

This is not reproducible with TCP connections, as with that, sending
doesn't error out, but instead the error is detected on the subsequent
readchar.  When that read fails, we unpush the remote target, and
throw TARGET_CLOSE_ERROR.  To address PR gdb/15275, instead of
catching the error in remote_get_trace_status as presently done (which
leaves this same issue latent for another packet to trip on), or of
making ser-unix.c fake success too on failed writes, so we'd get to
readchar detecting the error on serial ports too, better let the error
propagate out of serial_write, and catch it at the remote.c level,
throwing away the target if writing fails too, instead of delaying
that until the next read.

gdb/
2013-04-02  Pedro Alves  <palves@@redhat.com>

	PR gdb/15275

	* remote.c (send_interrupt_sequence): Use remote_serial_write.
	(remote_serial_write): New function.
	(putpkt_binary, getpkt_or_notif_sane_1): Use remote_serial_write.
@
text
@a124 2
static void remote_serial_write (const char *str, int len);

d3212 1
a3212 1
    remote_serial_write ("\x03", 1);
d3218 1
a3218 1
      remote_serial_write ("g", 1);
a7062 15
/* Wrapper for serial_write that closes the target and throws if
   writing fails.  */

static void
remote_serial_write (const char *str, int len)
{
  if (serial_write (remote_desc, str, len))
    {
      remote_unpush_target ();
      throw_perror_with_name (TARGET_CLOSE_ERROR,
			      _("Remote communication error.  "
				"Target disconnected."));
    }
}

d7183 2
a7184 1
      remote_serial_write (buf2, p - buf2);
d7239 1
a7239 1
		remote_serial_write ("+", 1);
d7594 1
a7594 1
	  remote_serial_write ("-", 1);
d7605 1
a7605 1
	    remote_serial_write ("+", 1);
d7625 1
a7625 1
	    remote_serial_write ("+", 1);
@


1.528.2.5
log
@gdb/
	Revert this patch:
	PR gdb/15275
	* remote.c (remote_get_trace_status): Include putpkt in TRY_CATCH.
@
text
@a10710 2
  putpkt ("qTStatus");

d10713 1
@


1.528.2.6
log
@gdb/
	Fix GDB regression related to PR binutils/14813.
	* jit.c (mem_bfd_iovec_close): Return 0 for success.
	* minidebug.c (lzma_close): Add return value comment.
	* remote.c (remote_bfd_iovec_close): Return 0 for success.
	* solib-spu.c (spu_bfd_iovec_close): Likewise.
	* spu-linux-nat.c (spu_bfd_iovec_close): Likewise.
@
text
@d9927 1
a9927 2
  /* Zero means success.  */
  return 0;
@


1.528.2.7
log
@PR remote/15455 - QTro remote packet broken

In the function remote_trace_set_readonly_regions in gdb/remote.c, the
local variable 'offset' does not account for "QTro" at the start of
the packet with the result that if there are any read-only regions,
the packet is sent -- but without the "QTro" -- causing the remote
stub to report that the packet is unsupported:

  Sending packet: $:0000000000400200,(...),00000000004560a4#ab...Packet received:

vs the expected:

  Sending packet: $QTro:0000000000400200,(...),00000000004560a4#31...Packet received: OK

We don't see the problem when testing with GDBserver, as that supports
qXfer:trace-frame-info:read, meaning GDBserver never needs to read
from the read-only sections directly itself.  This commit adds a test
that explicitly disables qXfer:trace-frame-info:read.

gdb/
2013-05-10  David Taylor  <dtaylor@@emc.com>

	PR remote/15455

	* remote.c (remote_trace_set_readonly_regions): Do not overwrite
	"QTro" at start of packet.

gdb/testsuite/
2013-05-10  Pedro Alves  <palves@@redhat.com>

	PR remote/15455

	* gdb.trace/qtro.c: New file.
	* gdb.trace/qtro.exp: New file.
@
text
@a10654 1
  offset = strlen (target_buf);
@


1.527
log
@Add the gdb remote target operations for branch tracing.
We define the following packets:

  Qbtrace:bts         enable branch tracing for the current thread
                      returns "OK" or "Enn"

  Qbtrace:off         disable branch tracing for the current thread
                      returns "OK" or "Enn"

  qXfer:btrace:read   read the full branch trace data for the current thread

gdb/
	* target.h (enum target_object): Add TARGET_OBJECT_BTRACE.
	* remote.c: Include btrace.h.
	(struct btrace_target_info): New struct.
	(remote_supports_btrace): New function.
	(send_Qbtrace): New function.
	(remote_enable_btrace): New function.
	(remote_disable_btrace): New function.
	(remote_teardown_btrace): New function.
	(remote_read_btrace): New function.
	(init_remote_ops): Add btrace ops.
	(enum <unnamed>): Add btrace packets.
	(struct protocol_feature remote_protocol_features[]): Add btrace packets.
	(_initialize_remote): Add packet configuration for branch tracing.

gdbserver/
	* target.h (struct target_ops): Add btrace ops.
	(target_supports_btrace): New macro.
	(target_enable_btrace): New macro.
	(target_disable_btrace): New macro.
	(target_read_btrace): New macro.
	* gdbthread.h (struct thread_info): Add btrace field.
	* server.c: Include btrace-common.h.
	(handle_btrace_general_set): New function.
	(handle_btrace_enable): New function.
	(handle_btrace_disable): New function.
	(handle_general_set): Call handle_btrace_general_set.
	(handle_qxfer_btrace): New function.
	(struct qxfer qxfer_packets[]): Add btrace entry.
	* inferiors.c (remove_thread): Disable btrace.
	* linux-low: Include linux-btrace.h.
	(linux_low_enable_btrace): New function.
	(linux_low_read_btrace): New function.
	(linux_target_ops): Add btrace ops.
	* configure.srv (i[34567]86-*-linux*): Add linux-btrace.o.
	Add srv_linux_btrace=yes.
	(x86_64-*-linux*): Add linux-btrace.o.
	Add srv_linux_btrace=yes.
	* configure.ac: Define HAVE_LINUX_BTRACE.
	* config.in: Regenerated.
	* configure: Regenerated.
@
text
@d11059 2
a11060 2
  if (remote_protocol_packets[PACKET_QTBuffer_size].support !=
      PACKET_DISABLE)
@


1.526
log
@2012-03-08  Stan Shebs  <stan@@codesourcery.com>
	    Hafiz Abid Qadeer  <abidh@@codesourcery.com>

	gdb/
	* NEWS: Mention set and show trace-buffer-size commands.
	Mention new packet.
	* target.h (struct target_ops): New method
	to_set_trace_buffer_size.
	(target_set_trace_buffer_size): New macro.
	* target.c (update_current_target): Set up new method.
	* tracepoint.c (trace_buffer_size): New global.
	(start_tracing): Send it to the target.
	(set_trace_buffer_size): New function.
	(_initialize_tracepoint): Add new setshow for trace-buffer-size.
	* remote.c (remote_set_trace_buffer_size): New function.
	(_initialize_remote): Use it.
	(QTBuffer:size) New remote command.
	(PACKET_QTBuffer_size): New enum.
	(remote_protocol_features): Add an entry for
	PACKET_QTBuffer_size.

	gdb/gdbserver/
	* tracepoint.c (trace_buffer_size): New global.
	(DEFAULT_TRACE_BUFFER_SIZE): New define.
	(init_trace_buffer): Change to one-argument function. Allocate
	trace buffer memory.
	(handle_tracepoint_general_set): Call cmd_bigqtbuffer_size to
	handle QTBuffer:size packet.
	(cmd_bigqtbuffer_size): New function.
	(initialize_tracepoint): Call init_trace_buffer with
	DEFAULT_TRACE_BUFFER_SIZE.
	* server.c (handle_query): Add QTBuffer:size in the
	supported packets.

	gdb/doc/
	* gdb.texinfo (Starting and Stopping Trace Experiments): Document
	trace-buffer-size set and show commands.
	(Tracepoint Packets): Document QTBuffer:size.
	(General Query Packets): Document QTBuffer:size.

	gdb/testsuite/
	* gdb.trace/trace-buffer-size.exp: New file.
	* gdb.trace/trace-buffer-size.c: New file.
@
text
@d71 1
d1285 3
d4001 4
d8806 4
d11161 144
d11422 5
d11954 9
@


1.525
log
@hex2bin, bin2hex: move declarations to header.

Move the declarations to a header, rather than declaring them in
(multiple) .c files.

gdb/
2013-03-07  Pedro Alves  <palves@@redhat.com>

	* remote.c (hex2bin, bin2hex): Move extern declarations to ...
	* remote.h (hex2bin, bin2hex): ... here.
	* tracepoint.c (hex2bin, bin2hex): Remove extern declarations.
@
text
@d1283 1
d3993 2
d11044 32
d11253 1
d11790 3
@


1.524
log
@2013-02-15  Pedro Alves  <pedro@@codesourcery.com>
	    Hafiz Abid Qadeer  <abidh@@codesourcery.com>

	gdb/
	* NEWS: Mention new field "trace-file".
	* tracepoint.c (trace_status_mi): Output "trace-file" field.
	(tfile_open): Record the trace file's filename in the trace
	status.
	(tfile_files_info): Mention the name of the trace file.
	Check the "filename" field explicitely.
	(trace_status_command): Explicitely check "filename" field.
	(trace_find_command): Ditto.
	(trace_find_pc_command): Ditto.
	(trace_find_tracepoint_command): Ditto.
	(trace_find_line_command): Ditto.
	(trace_find_range_command): Ditto.
	(trace_find_outside_command): Ditto.
	* tracepoint.h (struct trace_status) <from_file>: Rename it
	to "filename" and make it hold the trace file's filename
	instead of a boolean.
	* remote.c (remote_get_trace_status): Initialize "filename"
	field with NULL instead	of 0.

	gdb/doc/
	* gdb.texinfo (GDB/MI Tracepoint Commands) <-trace-status>:
	Document the "trace-file" field.

	gdb/testsuite/
	* gdb.trace/tfile.exp: Add test for -trace-status command.
@
text
@a185 4
extern int hex2bin (const char *hex, gdb_byte *bin, int count);

extern int bin2hex (const gdb_byte *bin, char *hex, int count);

@


1.523
log
@gdb/
	* remote.c: Fix a typo.
@
text
@d10704 1
a10704 1
  ts->from_file = 0;
@


1.522
log
@Fix GDB internal error against targets that return a thread in T stop replies but don't support qC.

Yao writes:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

GDB gets an internal error when it connects to GDBserver started with
'--disable-packet=qC'.

Sending packet: $QNonStop:0#8c...Packet received: OK
Sending packet: $?#3f...Packet received: T0505:00000000;04:00f0ffbf;08:b0c2e44c;thread:p4255.4255;core:1;
Sending packet: $Hc-1#09...Packet received: E01
Sending packet: $qC#b4...Packet received:
Sending packet: $qAttached:a410#bf...Packet received: E01
Packet qAttached (query-attached) is supported
warning: Remote failure reply: E01
Sending packet: $qOffsets#4b...Packet received:
../../../git/gdb/target.c:3248: internal-error: Can't determine the current address space of thread Thread 16981

When start remote, the call chain is as follows,

remote_start_remote
  add_current_inferior_and_thread <--[1]
  ...
  start_remote
    wait_for_inferior
      remote_wait_as
        process_stop_reply
          get_thread_arch_regcache   <--[2]
          remote_notice_new_inferior <--[3]

GDB sends packet "qC" in [1] and adds the thread/inferior if the remote
stubs understands "qC".  In [2], GDB looks for the inferior to build a
regcache, and notices a new inferior in [3].  As we can see, GDB assumes
that the inferior can be found in [2].  Once the remote stub doesn't
support "qC", GDB can't look for the inferior in [2], and emits an
internal error.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Right after the initial connection, we query the target for its state,
with the ? packet.  We store the resulting wait status / stop reply
aside, and query the target for the current thread, using qC, which
fails, so we fake a ptid for the target's thread.  We then later,
after the initial setup, end up consuming that set-aside wait status,
parsing the T stop reply, which contains a "thread" "register" (which
was the thread the target would have replied to qC).  We get into
trouble because the ptid in that stop reply doesn't match our faked up
ptid in the initial setup, although the target threads are the same...

So we had the T stop reply handy all along.  We might as well extract
the thread's ptid from it, and avoid all the resulting issues.

qC is also used after vRun, in order to discover the new process'es
main thread.  But, vRun's reply is also a wait status, just like
'?''s, which is quite convenient.

This means that if we have a "Txx thread: ptid" reply, then we don't
really need qC.  The patch makes GDB look in the T reply first, and if
not found, try with qC.  The packet handling seems to have been added
in gdb-4.18 (1999), and I see that in that same release, "Txx thread:
ptid" didn't exist yet, which probably explains why nobody though of
doing this before.

Regression tested against a gdbserver with qC disabled (and then
enabled), on x86_64 Fedora 17.

2013-01-25  Pedro Alves  <palves@@redhat.com>

	* remote.c (stop_reply_extract_thread): New.
	(add_current_inferior_and_thread): New parameter 'wait_status'.
	Handle it.
	(remote_start_remote): Pass wait status to
	add_current_inferior_and_thread.
	(extended_remote_run): Update comment.
	(extended_remote_create_inferior_1): Pass wait status to
	add_current_inferior_and_thread.
@
text
@d5667 1
a5667 1
   To solve this, whenever we parse a %Stop notification sucessfully,
@


1.521
log
@2013-01-14  Richard Sharman  <richard_sharman@@mitel.com>
	    Pedro Alves  <palves@@redhat.com>

	PR remote/14786

	* remote.c (remote_threads_info): Make a copy of the reply from
	qfThreadInfo and use that instead of rs->buf.
@
text
@d3227 38
d3268 7
a3274 1
   to return the current thread.  */
d3277 1
a3277 1
add_current_inferior_and_thread (void)
d3281 1
a3281 1
  ptid_t ptid;
d3285 13
a3297 2
  /* Now, if we have thread information, update inferior_ptid.  */
  ptid = remote_current_thread (inferior_ptid);
d3458 1
a3458 1
      add_current_inferior_and_thread ();
d7894 1
a7894 1
      /* We have a wait response; we don't need it, though.  All is well.  */
d7921 4
d7935 2
a7936 1
  if (extended_remote_run (args) == -1)
d7958 3
a7960 1
  add_current_inferior_and_thread ();
@


1.520
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d2762 9
d2788 1
d2791 1
a2791 1
	      bufp = rs->buf;
d2793 1
@


1.519
log
@gdb/
2012-12-15  Yao Qi  <yao@@codesourcery.com>

	* Makefile.in (REMOTE_OBS): Add "remote-notif.o".
	(SFILES): Add "remote-notif.c".
	(HFILES_NO_SRCDIR): Add "remote-notif.h" and "common/queue.h".
	* remote-notif.c: New.  Factored out from remote.c.
	* remote-notif.h: New.
	* remote.c: Include "remote-notif.h".
	(stop_reply_xmalloc, do_stop_reply_xfree):
	(remote_parse_stop_reply, remote_get_pending_stop_replies):
	(remote_async_get_pending_events_handler): Remove declarations.
	(remote_parse_stop_reply): Declare.
	(pending_stop_reply): Remove.
	(remote_async_get_pending_events_token): Move to
	remote-notif.c.
	(remote_close): Replace 'delete_async_event_handler' with
	remote_notif_unregister_async_event_handler.
	Don't call discard_pending_stop_replies.
	(remote_start_remote): Replace code with remote_notif_parse
	and remote_notif_get_pending_replies.
	(remote_open_1): Replace 'create_async_event_handler' with
	remote_notif_register_async_event_handler.
	(extended_remote_attach_1): Call remote_notif_parse and
	notif_stop_reply_push.
	(struct stop_reply) <next>: Remove.
	<base>: New field.
	Callers update.
	(stop_reply_queue): Change its type.
	(stop_reply_xmalloc, do_stop_reply_xfree): Remove.
	(remote_notif_remove_all): New.
	(discard_pending_stop_replies): Update.
	(remote_notif_stop_ack, stop_reply_dtr): New.
	(remote_notif_stop_alloc_event): New.
	(notif_client_stop): New variable.
	(stop_reply_match_ptid, stop_reply_match_ptid_and_ws: New.
	(queued_stop_reply, peek_stop_reply): Adjust.
	(remote_get_pending_stop_replies): Rename to
	remote_notif_get_pending_events.
	(handle_notification): Move to remote-notif.c.
	(remote_async_get_pending_events_handler): Likewise.
	(remote_wait_as): Adjust to call remote_notif_parse.
	Call 'getpkt_or_notif_sane' instead of 'getpkt_sane'.
	Return minus_one_ptid early if gets a notification.
	(remote_wait): Call QUEUE_is_empty (notif_reply_p).
	(_initialize_remote): Call QUEUE_alloc.  Update caller.
	(remote_resume): Call 'remote_notif_process' in all-stop mode.
	* remote.h: Include "remote-notif.h".
	(remote_notif_get_pending_replies): Declare.
@
text
@d3 1
a3 1
   Copyright (C) 1988-2012 Free Software Foundation, Inc.
@


1.518
log
@gdb/
2012-12-15  Yao Qi  <yao@@codesourcery.com>

	* remote.c (discard_pending_stop_replies): Update declaration.
	(remote_detach_1, extended_remote_mourn_1): Likewise.
	(discard_pending_stop_replies): Change parameter from PID to
	INF.
	(remote_close): Update caller.
	(_initialize_remote): Attach discard_pending_stop_replies to
	inferior_exit observer.
@
text
@d37 1
a226 1
static struct stop_reply *stop_reply_xmalloc (void);
d228 1
a228 2
static void do_stop_reply_xfree (void *arg);
static void remote_parse_stop_reply (char *buf, struct stop_reply *);
a229 1
static void remote_get_pending_stop_replies (void);
a233 1
static void remote_async_get_pending_events_handler (gdb_client_data);
a244 5
/* The non-stop remote protocol provisions for one pending stop reply.
   This is where we keep it until it is acknowledged.  */

static struct stop_reply *pending_stop_reply = NULL;

a1396 6
/* Asynchronous signal handle registered as event loop source for when
   the remote sent us a %Stop notification.  The registered callback
   will do a vStopped sequence to pull the rest of the events out of
   the remote side into our event queue.  */

static struct async_event_handler *remote_async_get_pending_events_token;
d3019 2
a3020 2
  if (remote_async_get_pending_events_token)
    delete_async_event_handler (&remote_async_get_pending_events_token);
d3442 1
a3442 2
	  struct stop_reply *stop_reply;
	  struct cleanup *old_chain;
d3444 5
a3448 10
	  stop_reply = stop_reply_xmalloc ();
	  old_chain = make_cleanup (do_stop_reply_xfree, stop_reply);

	  remote_parse_stop_reply (rs->buf, stop_reply);
	  discard_cleanups (old_chain);

	  /* get_pending_stop_replies acks this one, and gets the rest
	     out.  */
	  pending_stop_reply = stop_reply;
	  remote_get_pending_stop_replies ();
d4208 1
a4208 3
  remote_async_get_pending_events_token
    = create_async_event_handler (remote_async_get_pending_events_handler,
				  NULL);
d4463 2
a4464 2
	  struct stop_reply *stop_reply;
	  struct cleanup *old_chain;
d4466 1
a4466 5
	  stop_reply = stop_reply_xmalloc ();
	  old_chain = make_cleanup (do_stop_reply_xfree, stop_reply);
	  remote_parse_stop_reply (wait_status, stop_reply);
	  discard_cleanups (old_chain);
	  push_stop_reply (stop_reply);
d4760 9
d5102 1
a5102 1
struct stop_reply
d5104 1
a5104 1
  struct stop_reply *next;
d5106 1
d5124 62
a5185 1
};
d5187 2
a5188 2
/* The list of already fetched and acknowledged stop events.  */
static struct stop_reply *stop_reply_queue;
d5190 2
a5191 2
static struct stop_reply *
stop_reply_xmalloc (void)
d5193 4
a5196 1
  struct stop_reply *r = XMALLOC (struct stop_reply);
a5197 1
  r->next = NULL;
d5201 28
a5228 2
static void
stop_reply_xfree (struct stop_reply *r)
d5230 4
a5233 1
  if (r != NULL)
d5235 2
a5236 2
      VEC_free (cached_reg_t, r->regcache);
      xfree (r);
d5238 2
d5248 4
a5251 1
  struct stop_reply *prev = NULL, *reply, *next;
d5254 1
a5254 1
  if (pending_stop_reply != NULL
d5256 1
a5256 1
	  || ptid_get_pid (pending_stop_reply->ptid) == inf->pid))
d5258 2
a5259 2
      stop_reply_xfree (pending_stop_reply);
      pending_stop_reply = NULL;
d5262 2
d5266 16
a5281 1
  for (reply = stop_reply_queue; reply; reply = next)
d5283 4
a5286 8
      next = reply->next;
      if (inf == NULL
	  || ptid_get_pid (reply->ptid) == inf->pid)
	{
	  if (reply == stop_reply_queue)
	    stop_reply_queue = reply->next;
	  else
	    prev->next = reply->next;
d5288 1
a5288 5
	  stop_reply_xfree (reply);
	}
      else
	prev = reply;
    }
d5291 2
a5292 1
/* Cleanup wrapper.  */
d5294 2
a5295 2
static void
do_stop_reply_xfree (void *arg)
d5297 11
a5307 1
  struct stop_reply *r = arg;
d5309 1
a5309 1
  stop_reply_xfree (r);
d5320 1
a5320 17
  struct stop_reply *it;
  struct stop_reply **it_link;

  it = stop_reply_queue;
  it_link = &stop_reply_queue;
  while (it)
    {
      if (ptid_match (it->ptid, ptid))
	{
	  *it_link = it->next;
	  it->next = NULL;
	  break;
	}

      it_link = &it->next;
      it = *it_link;
    }
d5322 1
a5322 1
  if (stop_reply_queue)
d5326 1
a5326 1
  return it;
d5336 8
a5343 1
  struct stop_reply *event;
d5345 2
a5346 6
  if (stop_reply_queue)
    {
      for (event = stop_reply_queue;
	   event && event->next;
	   event = event->next)
	;
d5348 7
a5354 4
      event->next = new_event;
    }
  else
    stop_reply_queue = new_event;
d5356 2
a5357 1
  mark_async_event_handler (remote_async_inferior_event_token);
d5365 2
a5366 10
  struct stop_reply *it;

  for (it = stop_reply_queue; it; it = it->next)
    if (ptid_equal (ptid, it->ptid))
      {
	if (it->ws.kind == TARGET_WAITKIND_STOPPED)
	  return 1;
      }

  return 0;
d5582 8
a5589 7
/* When the stub wants to tell GDB about a new stop reply, it sends a
   stop notification (%Stop).  Those can come it at any time, hence,
   we have to make sure that any pending putpkt/getpkt sequence we're
   making is finished, before querying the stub for more events with
   vStopped.  E.g., if we started a vStopped sequence immediatelly
   upon receiving the %Stop notification, something like this could
   happen:
d5624 2
a5625 2
static void
remote_get_pending_stop_replies (void)
d5629 1
a5629 1
  if (pending_stop_reply)
d5631 5
d5637 2
a5638 5
      putpkt ("vStopped");

      /* Now we can rely on it.	 */
      push_stop_reply (pending_stop_reply);
      pending_stop_reply = NULL;
d5646 1
a5646 20
	    {
	      struct cleanup *old_chain;
	      struct stop_reply *stop_reply = stop_reply_xmalloc ();

	      old_chain = make_cleanup (do_stop_reply_xfree, stop_reply);
	      remote_parse_stop_reply (rs->buf, stop_reply);

	      /* acknowledge */
	      putpkt ("vStopped");

	      if (stop_reply->ws.kind != TARGET_WAITKIND_IGNORE)
		{
		  /* Now we can rely on it.  */
		  discard_cleanups (old_chain);
		  push_stop_reply (stop_reply);
		}
	      else
		/* We got an unknown stop reply.  */
		do_cleanups (old_chain);
	    }
d5649 7
a5657 1

d5741 2
a5742 2
      if (pending_stop_reply != NULL)
	remote_get_pending_stop_replies ();
d5789 1
d5807 8
a5814 1
      ret = getpkt_sane (&rs->buf, &rs->buf_size, wait_forever_enabled_p);
d5846 3
a5848 2
	struct stop_reply *stop_reply;
	struct cleanup *old_chain;
a5849 4
	stop_reply = stop_reply_xmalloc ();
	old_chain = make_cleanup (do_stop_reply_xfree, stop_reply);
	remote_parse_stop_reply (buf, stop_reply);
	discard_cleanups (old_chain);
d5930 1
a5930 1
      if (stop_reply_queue)
a6824 46


/* Remote notification handler.  */

static void
handle_notification (char *buf)
{
  if (strncmp (buf, "Stop:", 5) == 0)
    {
      if (pending_stop_reply)
	{
	  /* We've already parsed the in-flight stop-reply, but the
	     stub for some reason thought we didn't, possibly due to
	     timeout on its side.  Just ignore it.  */
	  if (remote_debug)
	    fprintf_unfiltered (gdb_stdlog, "ignoring resent notification\n");
	}
      else
	{
	  struct cleanup *old_chain;
	  struct stop_reply *reply = stop_reply_xmalloc ();

	  old_chain = make_cleanup (do_stop_reply_xfree, reply);

	  remote_parse_stop_reply (buf + 5, reply);

	  discard_cleanups (old_chain);

	  /* Be careful to only set it after parsing, since an error
	     may be thrown then.  */
	  pending_stop_reply = reply;

	  /* Notify the event loop there's a stop reply to acknowledge
	     and that there may be more events to fetch.  */
	  mark_async_event_handler (remote_async_get_pending_events_token);

	  if (remote_debug)
	    fprintf_unfiltered (gdb_stdlog, "stop notification captured\n");
	}
    }
  else
    {
      /* We ignore notifications we don't recognize, for compatibility
	 with newer stubs.  */
    }
}
a11232 6
remote_async_get_pending_events_handler (gdb_client_data data)
{
  remote_get_pending_stop_replies ();
}

static void
d11387 1
@


1.517
log
@gdb/
2012-12-15  Yao Qi  <yao@@codesourcery.com>

	* remote.c (getpkt_or_notif_sane): Add one more argument in
	its declaration.
	(getpkt_or_notif_sane_1): Add one more argument.
	(getpkt_sane): Update caller.
	(getpkt_or_notif_sane): Likewise.  Update call
	togetpkt_or_notif_sane_1.
	(remote_wait_ns): Update caller.
@
text
@d232 1
a232 1
static void discard_pending_stop_replies (int pid);
d3025 5
a3029 2
  /* We're no longer interested in any of these events.  */
  discard_pending_stop_replies (-1);
a4356 1
  discard_pending_stop_replies (pid);
d5164 1
a5164 1
/* Discard all pending stop replies of inferior PID.  If PID is -1,
d5168 1
a5168 1
discard_pending_stop_replies (int pid)
d5174 2
a5175 2
      && (pid == -1
	  || ptid_get_pid (pending_stop_reply->ptid) == pid))
d5186 2
a5187 2
      if (pid == -1
	  || ptid_get_pid (reply->ptid) == pid)
a7669 3
  /* We're no longer interested in these events.  */
  discard_pending_stop_replies (ptid_get_pid (inferior_ptid));

d11346 3
@


1.516
log
@gdb/
2012-11-26  Yao Qi  <yao@@codesourcery.com>

	* remote.c (remote_start_remote): Typo fix.
@
text
@d92 1
a92 1
				 int forever);
d5637 1
d5643 1
a5643 1
			      0 /* forever */);
d5646 1
a5646 1
      if (ret != -1)
d5683 1
a5683 1
				  1 /* forever */);
d7414 3
a7416 1
   enough reason to return to the caller.  */
d7420 1
a7420 1
			int expecting_notif)
d7521 2
d7544 2
d7552 1
a7552 1
	    return -1;
d7560 1
a7560 1
  return getpkt_or_notif_sane_1 (buf, sizeof_buf, forever, 0);
d7564 2
a7565 1
getpkt_or_notif_sane (char **buf, long *sizeof_buf, int forever)
d7567 2
a7568 1
  return getpkt_or_notif_sane_1 (buf, sizeof_buf, forever, 1);
@


1.515
log
@	* gdbarch.sh (target_gdbarch): Remove macro.
	(get_target_gdbarch): Rename to target_gdbarch.
	* gdbarch.c, gdbarch.h: Rebuild.
	* ada-tasks.c, aix-thread.c, amd64-linux-nat.c, arch-utils.c,
	arm-tdep.c, auxv.c, breakpoint.c, bsd-uthread.c, corefile.c,
	darwin-nat-info.c, dcache.c, dsrec.c, exec.c, fbsd-nat.c,
	filesystem.c, gcore.c, gnu-nat.c, i386-darwin-nat.c, i386-nat.c,
	ia64-vms-tdep.c, inf-ptrace.c, infcmd.c, jit.c, linux-nat.c,
	linux-tdep.c, linux-thread-db.c, m32r-rom.c, memattr.c,
	mep-tdep.c, microblaze-tdep.c, mips-linux-nat.c,
	mips-linux-tdep.c, mips-tdep.c, monitor.c, moxie-tdep.c,
	nto-procfs.c, nto-tdep.c, ppc-linux-nat.c, proc-service.c,
	procfs.c, progspace.c, ravenscar-thread.c, record.c,
	remote-m32r-sdi.c, remote-mips.c, remote-sim.c, remote.c,
	rl78-tdep.c, rs6000-nat.c, rx-tdep.c, s390-nat.c, sol-thread.c,
	solib-darwin.c, solib-dsbt.c, solib-frv.c, solib-ia64-hpux.c,
	solib-irix.c, solib-pa64.c, solib-som.c, solib-spu.c,
	solib-sunos.c, solib-svr4.c, solib.c, spu-linux-nat.c,
	spu-multiarch.c, spu-tdep.c, symfile-mem.c, symfile.c, symtab.c,
	target-descriptions.c, target.c, target.h, tracepoint.c,
	windows-nat.c, windows-tdep.c, xcoffsolib.c, cli/cli-dump.c,
	common/agent.c, mi/mi-interp.c, python/py-finishbreakpoint.c,
	python/py-inferior.c, python/python.c: Update.
@
text
@d3365 1
a3365 1
	 Request it explicitely.  */
@


1.514
log
@	* remote.c (remote_insert_hw_breakpoint): ARI fix,
	add missing internalization markup.
@
text
@d400 1
a400 1
  /* long size in bytes;  == register_size (target_gdbarch, regnum);
d402 1
a402 1
  /* char *name; == gdbarch_register_name (target_gdbarch, regnum);
d487 1
a487 1
	      gdbarch_relocate_instruction (target_gdbarch, &to, from);
d528 1
a528 1
  return gdbarch_data (target_gdbarch, remote_gdbarch_data_handle);
d701 1
a701 1
  if (regnum < 0 && regnum >= gdbarch_num_regs (target_gdbarch))
d717 1
a717 1
  for (i = 0; i < gdbarch_num_regs (target_gdbarch); i++)
d1484 1
a1484 1
  if (gdbarch_has_global_solist (target_gdbarch))
d3341 1
a3341 1
  if (gdbarch_has_global_solist (target_gdbarch))
d3423 1
a3423 1
	  && gdbarch_target_desc (target_gdbarch) == NULL)
d3542 1
a3542 1
  if (gdbarch_has_global_breakpoints (target_gdbarch)
d3622 1
a3622 1
	  int addr_size = gdbarch_addr_bit (target_gdbarch) / 8;
d3627 1
a3627 1
	  sym_addr = gdbarch_convert_from_func_ptr_addr (target_gdbarch,
d5410 1
a5410 1
				   register_size (target_gdbarch,
d5413 1
a5413 1
	      if (fieldsize < register_size (target_gdbarch,
d5607 1
a5607 1
	    = get_thread_arch_regcache (ptid, target_gdbarch);
d6321 1
a6321 1
    address_size = gdbarch_addr_bit (target_gdbarch);
d6857 1
a6857 1
  int addr_size = gdbarch_addr_bit (target_gdbarch) / 8;
d8381 2
a8382 2
	       paddress (target_gdbarch, lma),
	       paddress (target_gdbarch, lma + size));
d8385 2
a8386 2
		       paddress (target_gdbarch, lma),
		       paddress (target_gdbarch, lma + size));
d8742 1
a8742 1
  int addr_size = gdbarch_addr_bit (target_gdbarch) / 8;
d9276 1
a9276 1
    = gdbarch_data (target_gdbarch, remote_g_packet_data_handle);
d9288 1
a9288 1
    = gdbarch_data (target_gdbarch, remote_g_packet_data_handle);
d10282 1
a10282 1
	  if (gdbarch_fast_tracepoint_valid_at (target_gdbarch,
@


1.513
log
@	* configure: Rebuild.
	* configure.ac (build_warnings): Add -Wempty-body.
	* m68k-tdep.c (m68k_gdbarch_init): Remove empty 'if'.
	* remote.c (handle_notification): Use braces for empty 'else' body.
	* s390-tdep.c (s390_analyze_prologue): Use braces for empty
	'else' body.
	* sh64-tdep.c (sh64_push_dummy_call): Use braces for empty
	'else' body.
	* solib-som.c (som_relocate_section_addresses): Use braces
	for empty 'else' body.
	* ui-file.c (stdio_file_write): Use braces for empty 'if' body.
	(stdio_file_write_async_safe, stdio_file_fputs): Likewise.
@
text
@d8225 1
a8225 1
            error ("Remote failure reply: %s", message + 1);
@


1.512
log
@gdb/
	* event-top.c (mark_async_signal_handler_wrapper): Remove.
	* event-top.h: Remove its declaration.
	(async_request_quit): Call mark_async_signal_handler instead of
	mark_async_signal_handler_wrapper.
	(async_do_nothing, async_disconnect): Likewise.
	(async_stop_sig): Likewise.
	* remote.c (handle_remote_sigint): Likewise.
	(handle_remote_sigint_twice): Likewise.
@
text
@d6784 4
a6787 3
    /* We ignore notifications we don't recognize, for compatibility
       with newer stubs.  */
    ;
@


1.511
log
@gdb/testsuite/

	* remote.c (remote_get_trace_status): Remove setting default
	values of fields of 'ts'.
@
text
@d4865 1
a4865 1
  mark_async_signal_handler_wrapper (sigint_remote_token);
d4875 1
a4875 1
  mark_async_signal_handler_wrapper (sigint_remote_twice_token);
@


1.510
log
@* gdb/remote.c (remote_insert_hw_breakpoint): Throw exception if
there is an error inserting hardware breakpoints and use the
error message from the target.

* gdb/breakpoint.c (insert_bp_location, insert_breakpoint_locations):
Catch this exception and print the error message contained within. Do not
print the default hardware error breakpoint message in this case.
@
text
@a10590 6
  /* Set some defaults.  */
  ts->running_known = 0;
  ts->stop_reason = trace_stop_reason_unknown;
  ts->traceframe_count = -1;
  ts->buffer_free = 0;

d10594 2
@


1.509
log
@gdb/
	* cli/cli-cmds.c (max_user_call_depth): Add 'unsigned'.
	(init_cmds): Call add_setshow_uinteger_cmd for command
	'max-user-call-depth'.
	* cli/cli-script.c (execute_user_command): Add 'unsigned' to the
	declaration of 'max_user_call_depth'.
	* frame.c (backtrace_limit): Add 'unsigned'.
	(_initialize_frame): Call add_setshow_uinteger_cmd for command
	'limit'.
	* remote.c (remoteaddresssize): Add 'unsigned'.
	(remote_address_masked): Change local var 'address_size' to
	'unsigned'.
	(_initialize_remote): Call add_setshow_uinteger_cmd for
	'remoteaddresssize'.
	* top.c (history_size): Add 'unsigned'.
	(show_commands): Change local variables to 'unsigned'.
	(set_history_size_command): Don't check history_size is negative.
	Adjust the condition to call unstifle_history and set history_size
	to UNIT_MAX.
@
text
@d7029 1
d8185 1
d8220 7
@


1.508
log
@	* defs.h (quit_flag): Don't declare.
	(clear_quit_flag, check_quit_flag, set_quit_flag): Declare.
	(QUIT): Use new functions.
	* event-top.c (command_handler): Use clear_quit_flag.
	(handle_sigint): Use set_quit_flag.
	(async_request_quit): Use check_quit_flag.  Don't check
	immediate_quit.
	* exceptions.c (throw_exception): Use clear_quit_flag.
	* main.c (captured_main): Use clear_quit_flag.
	* python/python.c (clear_quit_flag, set_quit_flag)
	(check_quit_flag): New functions.
	* remote-sim.c (gdb_os_poll_quit): Use check_quit_flag,
	clear_quit_flag.
	* remote.c (remote_wait_as): Use check_quit_flag,
	clear_quit_flag.
	(remote_start_remote): Call QUIT.
	* symfile.c (load_progress): Use check_quit_flag.
	* top.c (command_loop): Use clear_quit_flag.
	(command_line_input): Call QUIT.
	* utils.c (quit_flag): Conditionally define.
	(clear_quit_flag, check_quit_flag, set_quit_flag): New
	functions.
	(prompt_for_continue): Call QUIT.  Use quit, not
	async_request_quit.
	* remote-mips.c (mips_expect_timeout): Call QUIT.
	* monitor.c (monitor_expect): Call QUIT.
@
text
@d837 1
a837 1
static int remote_address_size;
d6317 1
a6317 1
  int address_size = remote_address_size;
d11464 2
a11465 2
  add_setshow_integer_cmd ("remoteaddresssize", class_obscure,
			   &remote_address_size, _("\
d11468 3
a11470 3
			   NULL,
			   NULL, /* FIXME: i18n: */
			   &setlist, &showlist);
@


1.507
log
@gdb/
	* remote.c (handle_notification): Remove parameter 'length'.
	(putpkt_binary, getpkt_or_notif_sane_1): Caller update.
@
text
@d3274 1
d5718 1
a5718 1
	  if (quit_flag)
d5720 1
a5720 1
	      quit_flag = 0;
@


1.506
log
@gdb/

	* cli/cli-decode.c (set_cmd_prefix): New.
	(lookup_cmd_for_prefixlist): New.
	(add_prefix_cmd): Call set_cmd_prefix and update field 'prefix'
	of each cmd_list_element in *prefixlist.
	(add_setshow_cmd_full): set_cmd_prefix.
	(add_alias_cmd): Likewise.
	* cli/cli-decode.h (struct cmd_list_element) <prefix>: New field.
	Declare 'auto_boolean_enums'.
	* cli/cli-setshow.c: Include "observer.h".
	(notify_command_param_changed_p): New.
	(add_setshow_auto_boolean_cmd): Move auto_boolean_enums out.
	Remove 'static'.
	(do_setshow_command): Split it to ...
	(do_set_command, do_show_command): ... them.  New.
	(do_set_command): Call observer_notify_command_param_changed if
	notify_command_param_changed_p returns true.
	(cmd_show_list): Caller update.
	* auto-load.c (set_auto_load_cmd): Likewise.
	* remote.c (show_remote_cmd): Likewise.
	* cli/cli-setshow.h: Update declarations.
	* top.c (execute_command): Call do_set_command and do_show_command.

	* NEWS: Mention new MI notification.
	* mi/mi-interp.c: Declare mi_command_param_changed.
	(mi_interpreter_init): Attach mi_command_param_changed to
	observer command_param_changed.
	(mi_command_param_changed): New.
	Remove mi_suppress_breakpoint_notifications.
	Define global variable mi_suppress_notification.
	(mi_breakpoint_created): Update.
	(mi_breakpoint_deleted): Likewise.
	(mi_breakpoint_modified): Likewise.
	* mi/mi-main.c (mi_cmd_execute): Likewise.  Check command
	'gdb-set' and set mi_suppress_notification.
	* mi/mi-main.h: (mi_suppress_notification): New struct.

gdb/doc/

	* observer.texi: New observer command_param_changed.
	* gdb.texinfo (GDB/MI Async Records): Doc for '=cmd-param-changed'.

gdb/testsuite/

	* gdb.mi/mi-cmd-param-changed.exp: New.
	* gdb.mi/mi-cli.exp: Update for MI notification "=cmd-param-changed".
	* gdb.mi/mi-var-rtti.exp, gdb.mi/mi2-cli.exp: Likewise.
	* gdb.mi/mi2-prompt.exp: Likewise.
@
text
@d6747 1
a6747 1
handle_notification (char *buf, size_t length)
d7159 1
a7159 1
		    handle_notification (rs->buf, val);
d7537 1
a7537 1
	  handle_notification (*buf, val);
@


1.505
log
@	* cli/cli-dump.c (bfd_openr_with_cleanup): Use gdb_bfd_openr.
	(bfd_openw_with_cleanup): Use gdb_bfd_openw.
	* corelow.c (core_open): Use gdb_bfd_fopen.
	* dsrec.c (load_srec): Use gdb_bfd_openr.
	* exec.c (exec_file_attach): Use gdb_bfd_fopen.
	* gcore.c (gcore_memory_sections): Use gdb_bfd_openw.
	* gdb_bfd.c (gdb_bfd_fopen, gdb_bfd_openr, gdb_bfd_openw)
	(gdb_bfd_openr_iovec, gdb_bfd_openr_next_archived_file)
	(gdb_bfd_fdopenr): New functions.
	* gdb_bfd.h (gdb_bfd_fopen, gdb_bfd_openr, gdb_bfd_openw)
	(gdb_bfd_openr_iovec, gdb_bfd_openr_next_archived_file)
	(gdb_bfd_fdopenr): Declare.
	* jit.c (bfd_open_from_target_memory): Use gdb_bfd_openr_iovec.
	* m32-rom.c (m32r_load, m32r_upload_command): Use gdb_bfd_openr.
	* machoread.c (macho_symfile_read_all_oso): Use gdb_bfd_openr,
	gdb_bfd_openr_next_archived_file.
	(macho_check_dsym): Use gdb_bfd_openr.
	(macho_add_oso_symfile): Don't call gdb_bfd_stash_filename.
	* procfs.c (insert_dbx_link_bpt_in_file): Use gdb_bfd_fdopenr.
	* remote-m32r-sdi.c (m32r_load): Use gdb_bfd_openr.
	* remote-mips.c (mips_load_srec, pmon_load_fast): Use
	gdb_bfd_openr.
	* remote.c (remote_bfd_open): Use gdb_bfd_openr_iovec.
	* rs6000-nat.c (add_vmap): Use gdb_bfd_openr, gdb_bfd_fdopenr,
	gdb_bfd_openr_next_archived_file.
	* solib-darwin.c (darwin_solib_get_all_image_info_addr_at_init):
	Use gdb_bfd_openr.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Use
	gdb_bfd_openr.
	* solib-spu.c (spu_bfd_fopen): Use gdb_bfd_openr_iovec.
	* solib.c (solib_bfd_fopen): Use gdb_bfd_fopen.
	* spu-linux-nat.c (spu_bfd_open): Use gdb_bfd_openr_iovec.
	* symfile.c (bfd_open_maybe_remote): Use gdb_bfd_openr.
	(symfile_bfd_open): Use gdb_bfd_fopen.
	(generic_load): Use gdb_bfd_openr.
	* windows-nat.c (windows_make_so): Use gdb_bfd_openr.
@
text
@d11235 1
a11235 1
	  do_setshow_command ((char *) NULL, from_tty, list);
@


1.504
log
@gdb/
	* command.h, remote.c: Fix a typo in comment.
@
text
@d9827 5
a9831 5
  bfd *abfd = bfd_openr_iovec (remote_file, target,
			       remote_bfd_iovec_open, NULL,
			       remote_bfd_iovec_pread,
			       remote_bfd_iovec_close,
			       remote_bfd_iovec_stat);
a9832 2
  if (abfd != NULL)
    gdb_bfd_stash_filename (abfd);
@


1.503
log
@	* symfile.c (symfile_bfd_open): Don't copy name.  Call
	gdb_bfd_stash_filename.
	(load_command): Open the new BFD before freeing the old.
	(bfd_open_maybe_remote): Call gdb_bfd_stash_filename.
	* symfile-mem.c (symbol_file_add_from_memory): Don't copy name.
	Call gdb_bfd_stash_filename.
	* spu-linux-nat.c (spu_bfd_open): Don't copy name.
	* solib-spu.c (spu_bfd_fopen): Don't copy name.  Call
	gdb_bfd_stash_filename.
	* solib-darwin.c (darwin_solib_get_all_image_info_addr_at_init):
	Free found_pathname.
	* rs6000-nat.c (add_vmap): Don't copy filename.  Call
	gdb_bfd_stash_filename.
	* remote.c (remote_bfd_open): Call gdb_bfd_stash_filename.
	* machoread.c (macho_add_oso_symfile): Call
	gdb_bfd_stash_filename.
	(macho_symfile_read_all_oso): Arrange to free archive_name.  Call
	gdb_bfd_stash_filename.
	(macho_check_dsym): Don't copy filename.  Call
	gdb_bfd_stash_filename.
	* jit.c (bfd_open_from_target_memory): Don't copy the filename.
	* gdb_bfd.c (gdb_bfd_stash_filename): New function.
	* gdb_bfd.h (gdb_bfd_stash_filename): Declare.
	* gcore.c (create_gcore_bfd): Call gdb_bfd_stash_filename.
	* exec.c (exec_close): Don't free the BFD's filename.
	(exec_file_attach): Don't copy the filename.  Call
	gdb_bfd_stash_filename.
	* corelow.c (core_close): Don't free the BFD's filename.
	(core_open): Call gdb_bfd_stash_filename.
	* corefile.c (reopen_exec_file): Remove #if 0 code.
	* solib.c (solib_bfd_fopen): Call gdb_bfd_stash_filename.  Free
	pathname.
	* dwarf2read.c (try_open_dwo_file): Call gdb_bfd_stash_filename.
@
text
@d1423 1
a1423 1
/* This the traceframe which we last selected on the remote system.
@


1.502
log
@	Add target-side support for dynamic printf.
	* NEWS: Mention the additional style.
	* breakpoint.h (struct bp_target_info): New fields tcommands, persist.
	(struct bp_location): New field cmd_bytecode.
	* breakpoint.c: Include format.h.
	(disconnected_dprintf): New global.
	(parse_cmd_to_aexpr): New function.
	(build_target_command_list): New function.
	(insert_bp_location): Call it.
	(remove_breakpoints_pid): Skip dprintf breakpoints.
	(print_one_breakpoint_location): Ditto.
	(dprintf_style_agent): New global.
	(dprintf_style_enums): Add dprintf_style_agent.
	(update_dprintf_command_list): Add agent case.
	(agent_printf_command): New function.
	(_initialize_breakpoint): Add new commands.
	* common/ax.def (printf): New bytecode.
	* ax.h (ax_string): Declare.
	* ax-gdb.h (gen_printf): Declare.
	* ax-gdb.c: Include cli-utils.h, format.h.
	(gen_printf): New function.
	(maint_agent_print_command): New function.
	(_initialize_ax_gdb): Add maint agent-printf command.
	* ax-general.c (ax_string): New function.
	(ax_print): Add printf disassembly.
	* Makefile.in (SFILES): Add format.c
	(COMMON_OBS): Add format.o.
	* common/format.h: New file.
	* common/format.c: New file.
	* printcmd.c: Include format.h.
	(ui_printf): Call parse_format_string.
	* remote.c (remote_state): New field breakpoint_commands.
	(PACKET_BreakpointCommands): New enum.
	(remote_breakpoint_commands_feature): New function.
	(remote_protocol_features): Add new BreakpointCommands entry.
	(remote_can_run_breakpoint_commands): New function.
	(remote_add_target_side_commands): New function.
	(remote_insert_breakpoint): Call it.
	(remote_insert_hw_breakpoint): Ditto.
	(_initialize_remote): Add new packet configuration for
	target-side breakpoint commands.
	* target.h (struct target_ops): New field
	to_can_run_breakpoint_commands.
	(target_can_run_breakpoint_commands): New macro.
	* target.c (update_current_target): Handle
	to_can_run_breakpoint_commands.

	[gdbserver]
	* Makefile.in (WARN_CFLAGS_NO_FORMAT): Define.
	(ax.o): Add it to build rule.
	(ax-ipa.o): Ditto.
	(OBS): Add format.o.
	(IPA_OBS): Add format.o.
	* server.c (handle_query): Claim support for breakpoint commands.
	(process_point_options): Add command case.
	(process_serial_event): Leave running if there are printfs in
	effect.
	* mem-break.h (any_persistent_commands): Declare.
	(add_breakpoint_commands): Declare.
	(gdb_no_commands_at_breakpoint): Declare.
	(run_breakpoint_commands): Declare.
	* mem-break.c (struct point_command_list): New struct.
	(struct breakpoint): New field command_list.
	(any_persistent_commands): New function.
	(add_commands_to_breakpoint): New function.
	(add_breakpoint_commands): New function.
	(gdb_no_commands_at_breakpoint): New function.
	(run_breakpoint_commands): New function.
	* linux-low.c (linux_wait_1): Test for and run breakpoint commands
	locally.
	* ax.c: Include format.h.
	(ax_printf): New function.
	(gdb_eval_agent_expr): Add printf opcode.

	[doc]
	* gdb.texinfo (Dynamic Printf): Mention agent style and
	disconnected dprintf.
	(Maintenance Commands): Describe maint agent-printf.
	(General Query Packets): Mention BreakpointCommands feature.
	(Packets): Document commands extension to Z0 packet.
	* agentexpr.texi (Bytecode Descriptions): Document printf
	bytecode.

	[testsuite]
	* gdb.base/dprintf.exp: Add agent style tests.
@
text
@d45 1
d9827 9
a9835 5
  return bfd_openr_iovec (remote_file, target,
			  remote_bfd_iovec_open, NULL,
			  remote_bfd_iovec_pread,
			  remote_bfd_iovec_close,
			  remote_bfd_iovec_stat);
@


1.501
log
@gdb/
2012-06-28  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	    Pedro Alves  <palves@@redhat.com>

	* gdbthread.h (ALL_THREADS): New macro.
	(thread_list): Declare.
	* infrun.c (handle_inferior_event) <spurious signal>: Don't keep
	going, but instead fall through to the stepping handling.
	* linux-nat.c (resume_lwp): New parameter 'signo'.  Resume with
	the passed in signal.  Adjust debug output.
	(resume_callback): Rename to ...
	(linux_nat_resume_callback): ... this.  Pass the thread's last
	stop signal, if in "pass" state.
	(linux_nat_resume): Adjust to rename.
	(stop_wait_callback): New assertion.  Don't respawn signals;
	instead let the LWP remain with SIGNALLED set.
	(linux_nat_wait_1): Remove flushing of pending SIGSTOPs.
	* remote.c (append_pending_thread_resumptions): New.
	(remote_vcont_resume): Call it.
	* target.h (target_resume): Extend comment.

gdb/testsuite/
2012-06-28  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	    Pedro Alves  <palves@@redhat.com>

	* gdb.threads/siginfo-threads.exp: New file.
	* gdb.threads/siginfo-threads.c: New file.
	* gdb.threads/sigstep-threads.exp: New file.
	* gdb.threads/sigstep-threads.c: New file.
@
text
@d245 2
d328 4
d1283 1
d3811 10
d3918 2
d7895 31
d7963 3
d8207 3
d10148 8
d11074 1
d11605 4
@


1.500
log
@gdb/
	* corefile.c (read_memory, read_stack, write_memory): Accept LEN
	argument as ssize_t.
	* gdbcore.h (read_memory, read_stack, write_memory): Likewise.
	* remote.c (remote_write_bytes_aux, remote_write_bytes): Likewise.
	* target.c (target_read_stack, target_write_memory)
	(target_write_raw_memory): Likewise.
	* target.h (target_read_stack, target_write_memory)
	(target_write_raw_memory): Likewise.
@
text
@d4647 22
d4721 4
@


1.499
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        * gdb/signals.def: Replace TARGET_SIGNAL_ with GDB_SIGNAL_
	throughout.

sim/arm/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/avr/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/cr16/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/d10v/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/erc32/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/m32c/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/ppc/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rl78/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rx/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.
@
text
@d6453 1
a6453 1
			const gdb_byte *myaddr, int len,
d6614 1
a6614 1
remote_write_bytes (CORE_ADDR memaddr, const gdb_byte *myaddr, int len)
@


1.498
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.
@
text
@d4619 1
a4619 1
  if (step && siggnal != TARGET_SIGNAL_0)
d4623 1
a4623 1
  else if (siggnal != TARGET_SIGNAL_0)
d4693 1
a4693 1
      if (step || siggnal != TARGET_SIGNAL_0)
d4700 1
a4700 1
      append_resumption (p, endp, ptid, /*step=*/ 0, TARGET_SIGNAL_0);
d4726 1
a4726 1
static enum gdb_signal last_sent_signal = TARGET_SIGNAL_0;
d4757 1
a4757 1
      if (info_verbose && siggnal != TARGET_SIGNAL_0)
d4770 1
a4770 1
  else if (siggnal != TARGET_SIGNAL_0)
d5706 1
a5706 1
      status->value.sig = TARGET_SIGNAL_0;
d5732 1
a5732 1
      if (last_sent_signal != TARGET_SIGNAL_0)
d5740 1
a5740 1
	  last_sent_signal = TARGET_SIGNAL_0;
@


1.497
log
@2012-05-16  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* coffread.c (cs_section_address): Passing proper argument for
	`bfd_get_section_vma'.
	* dwarf2read.c (dwarf2_locate_sections): Likewise, for
	`bfd_get_section_flags'.
	* remote.c (remote_trace_set_readonly_regions): Likewise, for
	`bfd_get_section_vma'.
@
text
@d4615 1
a4615 1
		   ptid_t ptid, int step, enum target_signal siggnal)
d4658 1
a4658 1
remote_vcont_resume (ptid_t ptid, int step, enum target_signal siggnal)
d4726 1
a4726 1
static enum target_signal last_sent_signal = TARGET_SIGNAL_0;
d4732 1
a4732 1
	       ptid_t ptid, int step, enum target_signal siggnal)
d5387 1
a5387 1
	  event->ws.value.sig = (enum target_signal)
d5413 1
a5413 1
	    event->ws.value.sig = (enum target_signal) value;
d5739 1
a5739 1
	     target_signal_to_name (last_sent_signal));
@


1.496
log
@gdb/
	* remote.c (async_remote_interrupt): Correct function name in
	debug message.
	(async_remote_interrupt_twice): Ditto.
@
text
@d10402 1
d10423 1
a10423 1
      vma = bfd_get_section_vma (,s);
@


1.495
log
@2012-03-20  Pedro Alves  <palves@@redhat.com>

	* remote.c (remote_start_remote): Clear `rs->starting_up' on early
	returns.
@
text
@d4837 1
a4837 1
    fprintf_unfiltered (gdb_stdlog, "remote_interrupt called\n");
d4848 1
a4848 1
    fprintf_unfiltered (gdb_stdlog, "remote_interrupt_twice called\n");
@


1.494
log
@2012-03-13  Pedro Alves  <palves@@redhat.com>
	    Hui Zhu  <teawater@@gmail.com>
	    Yao Qi  <yao@@codesourcery.com>

	* remote.c (struct remote_state): New field `starting_up'.
	(remote_start_remote): Set and clear it.
	(remote_can_download_tracepoint): If starting up, return false.
@
text
@d3381 1
d3473 1
@


1.493
log
@gdb/
	* remote.c (remote_get_noisy_reply): Replace `sprintf' with
	`xsnprintf'.
	(remote_query_attached): Likewise.
	(remote_static_tracepoint_marker_at): Likewise.
	(remote_set_permissions): Likewise.
	(remote_detach_1, extended_remote_attach_1): Likewise.
	(send_g_packet, remote_vkill): Likewise.
	(extended_remote_disable_randomization): Likewise.
	(remote_add_target_side_condition): Likewise.
	(remote_insert_breakpoint): Likewise.
	(remote_remove_breakpoint): Likewise.
	(remote_insert_watchpoint): Likewise.
	(remote_remove_watchpoint): Likewise.
	(remote_insert_hw_breakpoint): Likewise.
	(remote_insert_hw_breakpoint): Likewise.
	(remote_remove_hw_breakpoint): Likewise.
	(remote_download_command_source): Likewise.
	(remote_download_tracepoint): Likewise.
	(remote_download_trace_state_variable): Likewise.
	(remote_disable_tracepoint): Likewise.
	(remote_trace_set_readonly_regions): Likewise.
	(remote_get_tracepoint_status): Likewise.
	(remote_trace_find): Likewise.
	(remote_get_trace_state_variable_value): Likewise.
	(remote_set_disconnected_tracing): Likewise.
	(remote_set_circular_trace_buffer): Likewise.
	(remote_get_min_fast_tracepoint_insn_len): Likewise.
	(remote_use_agent): Likewise.
	(remote_add_target_side_condition): Add one parameter BUF_SIZE.
	Update callers.
@
text
@d274 4
d3273 4
d3524 6
d10315 12
a10326 2
  struct trace_status *ts = current_trace_status ();
  int status = remote_get_trace_status (ts);
@


1.492
log
@2012-03-07  Pedro Alves  <palves@@redhat.com>

	gdb/doc/
	* gdb.texinfo (General Query Packets): Document new
	QProgramSignals packet.
	* gdb.texinfo (Remote configuration): Mention
	"program-signals-packet".

	gdb/gdbserver/
	* linux-low.c (get_detach_signal): New.
	(linux_detach_one_lwp): Get rid of a pending SIGSTOP with SIGCONT.
	Pass on pending signals to PTRACE_DETACH.  Check the result of the
	ptrace call.
	* server.c (program_signals, program_signals_p): New.
	(handle_general_set): Handle QProgramSignals.
	* server.h (program_signals, program_signals_p): Declare.

	gdb/
	* NEWS: Mention QProgramSignals.
	* inferior.h (update_signals_program_target): Declare.
	* infrun.c: (update_signals_program_target): New.
	(handle_command): Update the target of the new program signals
	array changes.
	* remote.c (PACKET_QProgramSignals): New enum.
	(last_program_signals_packet): New global.
	(remote_program_signals): New.
	(remote_start_remote): Update the target with the program signals
	list.
	(remote_protocol_features): Add entry for QPassSignals.
	(remote_open_1): Free anc clear last_program_signals_packet.
	(init_remote_ops): Install remote_program_signals.
	* target.c (update_current_target): Adjust.
	(target_program_signals): New.
	* target.h (struct target_ops) <to_program_signals>: New field.
	(target_program_signals): Declare.
@
text
@d482 1
a482 1
	      sprintf (buf, "qRelocInsn:%x", adjusted_size);
d1422 1
d1428 1
a1428 1
    sprintf (rs->buf, "qAttached:%x", pid);
d1430 1
a1430 1
    sprintf (rs->buf, "qAttached");
d2896 1
a2896 1
  sprintf (p, "qTSTMat:");
d3650 7
a3656 7
  sprintf (rs->buf, "QAllow:"
	   "WriteReg:%x;WriteMem:%x;"
	   "InsertBreak:%x;InsertTrace:%x;"
	   "InsertFastTrace:%x;Stop:%x",
	   may_write_registers, may_write_memory,
	   may_insert_breakpoints, may_insert_tracepoints,
	   may_insert_fast_tracepoints, may_stop);
d4300 1
a4300 1
    sprintf (rs->buf, "D;%x", pid);
d4382 1
a4382 1
  sprintf (rs->buf, "vAttach;%x", pid);
d5860 1
a5860 1
  sprintf (rs->buf, "g");
d7525 1
a7525 1
  sprintf (rs->buf, "vKill;%x", pid);
d7668 2
a7669 1
  sprintf (rs->buf, "QDisableRandomization:%x", val);
d7799 1
a7799 1
   BUF.  */
d7803 2
a7804 1
				  struct bp_target_info *bp_tgt, char *buf)
d7815 1
a7815 1
  sprintf (buf, "%s", ";");
d7823 1
a7823 1
      sprintf (buf, "X%x,", aexpr->len);
d7851 1
a7851 1
      char *p;
d7859 1
d7866 1
a7866 1
      sprintf (p, ",%d", bpsize);
d7869 1
a7869 1
	remote_add_target_side_condition (gdbarch, bp_tgt, p);
d7900 1
d7908 1
a7908 1
      sprintf (p, ",%d", bp_tgt->placed_size);
d7944 1
d7951 1
a7951 1
  sprintf (rs->buf, "Z%x,", packet);
d7955 1
a7955 1
  sprintf (p, ",%x", len);
d7988 1
d7995 1
a7995 1
  sprintf (rs->buf, "z%x,", packet);
d7999 1
a7999 1
  sprintf (p, ",%x", len);
d8086 1
a8086 1
  char *p;
d8099 1
d8107 1
a8107 1
  sprintf (p, ",%x", bp_tgt->placed_size);
d8110 1
a8110 1
    remote_add_target_side_condition (gdbarch, bp_tgt, p);
d8135 1
d8146 1
a8146 1
  sprintf (p, ",%x", bp_tgt->placed_size);
d10124 1
d10128 1
a10128 1
  char buf[2048];
d10147 4
a10150 4
  sprintf (buf, "QTDP:%x:%s:%c:%lx:%x", b->number,
	   addrbuf, /* address */
	   (b->enable_state == bp_enabled ? 'E' : 'D'),
	   t->step_count, t->pass_count);
d10164 2
a10165 1
	    sprintf (buf + strlen (buf), ":F%x", isize);
d10209 2
a10210 1
	  sprintf (buf + strlen (buf), ":X%x,", aexpr->len);
d10235 5
a10239 5
	  sprintf (buf, "QTDP:-%x:%s:%s%c",
		   b->number, addrbuf, /* address */
		   tdp_actions[ndx],
		   ((tdp_actions[ndx + 1] || stepping_actions)
		    ? '-' : 0));
d10252 5
a10256 5
	  sprintf (buf, "QTDP:-%x:%s:%s%s%s",
		   b->number, addrbuf, /* address */
		   ((ndx == 0) ? "S" : ""),
		   stepping_actions[ndx],
		   (stepping_actions[ndx + 1] ? "-" : ""));
d10322 3
a10324 2
  sprintf (rs->buf, "QTDV:%x:%s:%x:",
	   tsv->number, phex ((ULONGEST) tsv->initial_value, 8), tsv->builtin);
d10345 2
a10346 1
  sprintf (rs->buf, "QTEnable:%x:%s", location->owner->number, addr_buf);
d10362 2
a10363 1
  sprintf (rs->buf, "QTDisable:%x:%s", location->owner->number, addr_buf);
d10409 2
a10410 1
      sprintf (target_buf + offset, ":%s,%s", tmp1, tmp2);
d10483 1
d10495 2
a10496 2
	  sprintf (rs->buf, "qTP:%x:%s", tp->number_on_target,
		   phex_nz (loc->address, 0));
d10510 2
a10511 1
      sprintf (rs->buf, "qTP:%x:%s", utp->number, phex_nz (utp->addr, 0));
d10539 1
d10555 1
a10555 1
      sprintf (p, "%x", num);
d10558 1
a10558 1
      sprintf (p, "pc:%s", phex_nz (addr1, 0));
d10561 1
a10561 1
      sprintf (p, "tdp:%x", num);
d10564 2
a10565 1
      sprintf (p, "range:%s:%s", phex_nz (addr1, 0), phex_nz (addr2, 0));
d10568 2
a10569 1
      sprintf (p, "outside:%s:%s", phex_nz (addr1, 0), phex_nz (addr2, 0));
d10624 1
a10624 1
  sprintf (rs->buf, "qTV:%x", tsvnum);
d10713 1
a10713 1
      sprintf (rs->buf, "QTDisconnected:%x", val);
d10741 1
a10741 1
  sprintf (rs->buf, "QTBuffer:circular:%x", val);
d10789 1
a10789 1
  sprintf (rs->buf, "qTMinFTPILen");
d10857 1
a10857 1
      sprintf (rs->buf, "QAgent:%d", use);
@


1.491
log
@2012-03-05  Tristan Gingold  <gingold@@adacore.com>

	* target.h (target_object): Add TARGET_OBJECT_OPENVMS_UIB.
	* remote.c (PACKET_qXfer_uib): New enum value.
	(remote_protocol_features): Add entry for PACKET_qXfer_uib.
	(remote_xfer_partial): Handle TARGET_OBJECT_OPENVMS_UIB.
	(_initialize_remote): Call add_packet_config_cmd for
	xfer:uib packet.

doc/
2012-03-05  Tristan Gingold  <gingold@@adacore.com>

	* gdb.texinfo (General Query Packets): Document xfer:uib:read.
@
text
@d1262 1
d1673 59
d3309 4
d3870 2
d4142 5
d10893 1
d11338 3
@


1.490
log
@gdb:
	* common/agent.c (agent_look_up_symbols): Add one parameter 'arg'.
	* common/agent.h: Update declaration.
	* inf-child.c (inf_child_use_agent): New.
	(inf_child_can_use_agent): New.
	(inf_child_target): Initialize fields `to_use_agent'
	and `to_can_use_agent'.
	* agent.c (agent_new_objfile): New.
        (_initialize_agent): Add agent_new_objfile to new_objfile
	observer.

	* linux-nat.c (linux_child_static_tracepoint_markers_by_strid):
	New.
        (linux_target_install_ops): Initialize field
	`to_static_tracepoint_markers_by_strid'.
	* remote.c (free_current_marker): Move it to ...
	* tracepoint.c (free_current_marker): ... here.  New.
	(cleanup_target_stop): New.
	* tracepoint.h: Declare free_current_marker.
	* NEWS: Add one entry about `info static-tracepoint-marker'.

gdb/gdbserver:
	* tracepoint.c (tracepoint_look_up_symbols): Update call to
	agent_look_up_symbols.

gdb/testsuite:
	* gdb.trace/strace.exp: run strace_info_marker in linux native gdb.
@
text
@d1257 1
d3838 2
d8490 5
d11327 3
@


1.489
log
@gdb:
	* target.h (struct target_ops) <to_use_agent>: New field.
	(struct target_ops) <to_can_use_agent>: New field.
	(target_use_agent, target_can_use_agent): New macro.
	* target.c (update_current_target): Update.
	* remote.c: New enum `PACKET_QAgent'.
	(remote_protocol_features): Add a new element.
	(remote_use_agent, remote_can_use_agent): New.
	(init_remote_ops): Initialize field `can_use_agent' with
	remote_can_use_agent.  Intiailize field `use_agent' with
	remote_use_agent.
	* common/agent.c (use_agent): New global.
	* common/agent.h: Declare it.
	* tracepoint.c (info_static_tracepoint_markers_command): Add
	comment.
	* Makefile.in (SFILES): Add common/agent.c and agent.c.
	(COMMON_OBS): Add common/agent.o and agent.o
	(common-agent.o): New rule.
	* agent.c: New.

gdb/doc:
	* gdb.texinfo (In-Process Agent): New node.
	Document new commands.
	(General Query Packets): Add packet `QAgent'.

gdb/gdbserver:
	* linux-low.c (linux_supports_agent): New.
	(linux_target_ops): Initialize field `supports_agent' with
	linux_supports_agent.
	* target.h (struct target_ops) <supports_agent>: New.
	(target_supports_agent): New macro.
	* server.c (handle_general_set): Handle packet 'QAgent'.
	(handle_query): Send `QAgent+'.
	* Makefile.in (server.o): Depends on agent.h.
@
text
@a2852 14
static void
free_current_marker (void *arg)
{
  struct static_tracepoint_marker **marker_p = arg;

  if (*marker_p != NULL)
    {
      release_static_tracepoint_marker (*marker_p);
      xfree (*marker_p);
    }
  else
    *marker_p = NULL;
}

@


1.488
log
@2012-03-01  Pedro Alves  <palves@@redhat.com>

	* amd64-linux-tdep.c (amd64_linux_record_signal): Make static.
	* breakpoint.c (create_exception_master_breakpoint, trace_command)
	(ftrace_command, strace_command): Make static.
	* d-lang.c (_initialize_d_language): Declare.
	* dwarf2expr.c (_initialize_dwarf2expr): Declare.
	* dwarf2loc.c (_initialize_dwarf2loc):
	* dwarf2read.c (process_psymtab_comp_unit): Make static.
	* exec.c (exec_get_section_table): Make static.
	* i386-linux-tdep.c (i386_linux_record_signal): Make static.
	* infcmd.c (ensure_valid_thread, ensure_not_tfind_mode): Make static.
	* inferior.c (remove_inferior_command, add_inferior_command)
	(clone_inferior_command): Make static.
	* linux-nat.c (linux_nat_thread_address_space)
	(linux_nat_core_of_thread): Make static.
	* linux-tdep.c (_initialize_linux_tdep): Declare.
	* objc-lang.c (_initialize_objc_lang): Declare.
	* opencl-lang.c (builtin_opencl_type, opencl_language_arch_info):
	Make static.
	(_initialize_opencl_language): Declare.
	* record.c (_initialize_record): Declare.
	* remote.c (demand_private_info, remote_get_tib_address)
	(remote_supports_cond_tracepoints)
	(remote_supports_fast_tracepoints, remote_get_tracepoint_status):
	Make static.
	* skip.c (_initialize_step_skip): Declare.
	* symtab.c (skip_prologue_using_lineinfo): Make static.
	* tracepoint.c (delete_trace_state_variable)
	(trace_variable_command, delete_trace_variable_command)
	(get_uploaded_tsv, find_matching_tracepoint_location)
	(find_matching_tsv, create_tsv_from_upload, get_traceframe_info):
	Make static.
	* value.c (pack_unsigned_long): Make static.
	* varobj.c (varobj_ensure_python_env): Make static.
	* windows-tdep.c (_initialize_windows_tdep): Declare.
	* xml-syscall.c (make_cleanup_free_syscalls_info): Make static.
@
text
@d68 1
d1280 1
d3853 1
d10763 28
d10903 2
d11418 3
@


1.487
log
@2012-03-01  Pedro Alves  <palves@@redhat.com>

	* remote.c (encode_actions): Delete declaration.
	* tracepoint.c (encode_actions): Make extern.
	* tracepoint.h (encode_actions): Declare.
@
text
@d1586 1
a1586 1
struct private_thread_info *
d8992 1
a8992 1
int
d9917 1
a9917 1
int
d9933 1
a9933 1
int
d10391 1
a10391 1
void
@


1.486
log
@	* remote.c (remote_watchpoint_addr_within_range): New function.
	(init_remote_ops): Use it.
@
text
@a71 3
/*static*/ void
encode_actions (struct breakpoint *t, struct bp_location *tloc,
		char ***tdp_actions, char ***stepping_actions);
@


1.485
log
@2012-02-24  Luis Machado  <lgustavo@@codesourcery.com>

	* remote.c (remote_supports_cond_breakpoints): New forward
	declaration.
	(remote_add_target_side_condition): New function.
	(remote_insert_breakpoint): Add target-side breakpoint
	conditional if supported.
	(remote_insert_hw_breakpoint): Likewise.
	(init_remote_ops): Set to_supports_evaluation_of_breakpoint_conditions
	hook.

	* target.c (update_current_target): Inherit
	to_supports_evaluation_of_breakpoint_conditions.
	Default to_supports_evaluation_of_breakpoint_conditions to return_zero.

	* target.h (struct target_ops)
	<to_supports_evaluation_of_breakpoint_conditions>: New field.
	(target_supports_evaluation_of_breakpoint_conditions): New #define.

	* breakpoint.c (get_first_locp_gte_addr): New forward declaration.
	(condition_evaluation_both, condition_evaluation_auto,
	condition_evaluation_host, condition_evaluation_target,
	condition_evaluation_enums, condition_evaluation_mode_1,
	condition_evaluation_mode): New	static globals.
	(translate_condition_evaluation_mode): New function.
	(breakpoint_condition_evaluation_mode): New function.
	(gdb_evaluates_breakpoint_condition_p): New function.
	(ALL_BP_LOCATIONS_AT_ADDR): New helper macro.
	(mark_breakpoint_modified): New function.
	(mark_breakpoint_location_modified): New function.
	(set_condition_evaluation_mode): New function.
	(show_condition_evaluation_mode): New function.
	(bp_location_compare_addrs): New function.
	(get_first_location_gte_addr): New helper function.
	(set_breakpoint_condition): Free condition bytecode if locations
	has become unconditional.  Call mark_breakpoint_modified (...).
	(condition_command): Call update_global_location_list (1) for
	breakpoints.
	(breakpoint_xfer_memory): Use is_breakpoint (...).
	(is_breakpoint): New function.
	(parse_cond_to_aexpr): New function.
	(build_target_condition_list): New function.
	(insert_bp_location): Handle target-side conditional
	breakpoints and call build_target_condition_list (...).
	(update_inserted_breakpoint_locations): New function.
	(insert_breakpoint_locations): Handle target-side conditional
	breakpoints.
	(bpstat_check_breakpoint_conditions): Add comment.
	(bp_condition_evaluator): New function.
	(bp_location_condition_evaluator): New function.
	(print_breakpoint_location): Print information on where the condition
	will be evaluated.
	(print_one_breakpoint_location): Likewise.
	(init_bp_location): Call mark_breakpoint_location_modified (...) for
	breakpoint location.
	(force_breakpoint_reinsertion): New functions.
	(update_global_location_list): Handle target-side breakpoint
	conditions.
	Reinsert locations that are already inserted if conditions have
	changed.
	(bp_location_dtor): Free agent expression bytecode.
	(disable_breakpoint): Call mark_breakpoint_modified (...).
	Call update_global_location_list (...) with parameter 1 for breakpoints.
	(disable_command): Call mark_breakpoint_location_modified (...).
	Call update_global_location_list (...) with parameter 1 for breakpoints.
	(enable_breakpoint_disp): Call mark_breakpoint_modified (...).
	(enable_command): mark_breakpoint_location_modified (...).
	(_initialize_breakpoint): Update documentation and add
	condition-evaluation breakpoint subcommand.

	* breakpoint.h: Include ax.h.
	(condition_list): New data structure.
	(condition_status): New enum.
	(bp_target_info) <cond_list>: New field.
	(bp_location) <condition_changed, cond_bytecode>: New fields.
	(is_breakpoint): New prototype.
@
text
@d7907 9
d10787 2
@


1.484
log
@2012-02-24  Luis Machado  <lgustavo@@codesourcery.com>

	* remote.c (remote_state) <cond_breakpoints>: New field.
	(PACKET_ConditionalBreakpoints): New enum.
	(remote_cond_breakpoint_feature): New function.
	(remote_protocol_features): Add new ConditionalBreakpoints entry.
	(remote_supports_cond_breakpoints): New function.
	(_initialize_remote): Add new packet configuration for
	target-side conditional breakpoints.
@
text
@d245 2
d7734 37
d7790 1
d7804 3
d8032 3
d10830 1
@


1.483
log
@gdb/
2012-02-15  Pedro Alves  <palves@@redhat.com>

	* remote.c (remote_detach_1, extended_remote_attach_1): Tweak
	output to be like native targets'.
	(remote_pid_to_str): Special case the null ptid.

gdb/testsuite/
2012-02-15  Pedro Alves  <palves@@redhat.com>

	Support extended-remote.  Avoid cascading timeouts.

	* gdb.base/attach.exp (do_attach_tests): Add expected output for
	the extended-remote target.  If attaching with no file fails, load
	the file manually.
	* gdb.server/ext-attach.exp: Adjust expected attach/detach output.
@
text
@d318 4
d1270 1
d3725 10
d3828 2
d9873 8
d11301 5
@


1.482
log
@
The remote stub can implement monitor commands which are not
known by gdb. Such monitor commands can take a long time
to execute. An example of this is the "leak_search" monitor
command implemented in the Valgrind gdbserver.

Currently, gdb will timeout on such a monitor command.
The remote stub however will continue to execute the
command and send the output later. Gdb and the remote
stub can then be desynchronised : gdb sends a packet,
and the reply read from the stub is a previous packet.

The change committed uses getpkt_sane to detect a timeout.
In this case, it continues the loop.
A QUIT; is inserted in the loop to allow the user
to stop handling the current command. possibly
still creating a desynchronisation between gdb and the stub
but that will be upon user request.
@
text
@d4208 10
d4234 2
a4235 13
  if (from_tty)
    {
      if (remote_multi_process_p (rs))
	printf_filtered (_("Detached from remote %s.\n"),
			 target_pid_to_str (pid_to_ptid (pid)));
      else
	{
	  if (extended)
	    puts_filtered (_("Detached from remote process.\n"));
	  else
	    puts_filtered (_("Ending remote debugging.\n"));
	}
    }
d4288 14
a4308 4
      if (from_tty)
	printf_unfiltered (_("Attached to %s\n"),
			   target_pid_to_str (pid_to_ptid (pid)));

d8835 3
a8837 1
  if (ptid_is_pid (ptid))
@


1.481
log
@gdbserver/
2012-02-02  Pedro Alves  <palves@@redhat.com>

	* tracepoint.c (cmd_qtminftpilen): Return 0 if there's no current
	inferior.

gdb/
2012-02-02  Pedro Alves  <palves@@redhat.com>

	* remote.c (remote_get_min_fast_tracepoint_insn_len): Return 0 if
	the current inferior has no execution.  Make sure the current
	remote process matches gdb's current inferior.
@
text
@d8593 1
d8595 9
a8603 1
      getpkt (&rs->buf, &rs->buf_size, 0);
@


1.480
log
@gdb/
	Code cleanup: Make 1440 bytes of data segment read-only.
	* arch-utils.c (endian_enum): Make it const char *const [].
	* arm-tdep.c (fp_model_strings, arm_abi_strings, arm_mode_strings):
	Likewise.
	* breakpoint.c (always_inserted_enums): Likewise.
	* cli/cli-cmds.c (script_ext_enums): Likewise.
	* cli/cli-decode.c (add_setshow_enum_cmd, complete_on_enum): Make the
	enumlist parameter const char *const *.
	* cli/cli-decode.h (struct cmd_list_element): Make the enums field
	const char *const *.
	* command.h (complete_on_enum, add_setshow_enum_cmd): Make the enumlist
	parameter const char *const *.
	* cris-tdep.c (cris_modes): Make it const char *const [].
	* filesystem.c (target_file_system_kinds): Likewise.
	* i386-tdep.c (valid_flavors, valid_conventions): Likewise.
	* infrun.c (follow_fork_mode_kind_names, follow_exec_mode_names)
	(can_use_displaced_stepping_enum, scheduler_enums)
	(exec_direction_names): Likewise.
	* language.c (_initialize_language): Make the type_or_range_names and
	case_sensitive_names variables const char *const [].
	* mips-tdep.c (mips_abi_strings): Make it const char *const [].
	* python/python.c (python_excp_enums): Likewise.
	* remote.c (interrupt_sequence_modes): Likewise.
	* rs6000-tdep.c (powerpc_vector_strings): Likewise.
	* serial.c (logbase_enums): Likewise.
	* sh-tdep.c (sh_cc_enum): Likewise.
	* stack.c (print_frame_arguments_choices, print_entry_values_choices):
	Likewise.
	* symtab.c (multiple_symbols_modes): Likewise.
	* tui/tui-win.c (tui_border_kind_enums, tui_border_mode_enums):
	Likewise.
	* utils.c (internal_problem_modes): Likewise.
@
text
@d10595 8
@


1.479
log
@2012-01-24  Pedro Alves  <palves@@redhat.com>

	* remote.c (remote_add_inferior): New `fake_pid_p' parameter.  Use
	it.
	(remote_notice_new_inferior): If the remote end doesn't support
	the multiprocess extensions, then the PID is fake.
	(add_current_inferior_and_thread): New.
	(remote_start_remote): Use it.
	(extended_remote_attach_1): Adjust.
	(extended_remote_create_inferior_1): Use
	add_current_inferior_and_thread.
@
text
@d745 1
a745 1
static const char *interrupt_sequence_modes[] =
@


1.478
log
@ChangeLog:

	* configure.ac [AC_CHECK_FUNCS]: Check for readlink.
	* config.in, configure: Regenerate.

	* target.h (struct target_ops): Add to_fileio_readlink.
	(target_fileio_readlink): Add prototype.
	* target.c (target_fileio_readlink): New function.

	* inf-child.c: Conditionally include <sys/param.h>.
	(inf_child_fileio_readlink): New function.
	(inf_child_target): Install it.

	* remote.c (PACKET_vFile_readlink): New enum value.
	(remote_hostio_readlink): New function.
	(init_remote_ops): Install it.
	(_initialize_remote): Handle vFile:readlink packet type.

doc/ChangeLog:

	* gdb.texinfo (Remote Configuration): Document
	"set remote hostio-readlink-packet" command.
	(General Query Packets): Document vFile:readlink packet.

gdbserver/ChangeLog:

	* hostio.c (handle_readlink): New function.
	(handle_vFile): Call it to handle "vFile:readlink" packets.
@
text
@d1443 8
a1450 7
/* Add PID to GDB's inferior table.  Since we can be connected to a
   remote system before before knowing about any inferior, mark the
   target with execution when we find the first inferior.  If ATTACHED
   is 1, then we had just attached to this inferior.  If it is 0, then
   we just created this inferior.  If it is -1, then try querying the
   remote stub to find out if it had attached to the inferior or
   not.  */
d1453 1
a1453 1
remote_add_inferior (int pid, int attached)
d1485 1
d1561 7
a1567 1
	inf = remote_add_inferior (ptid_get_pid (currthread), -1);
d3161 39
d3327 1
a3327 34
      inferior_ptid = minus_one_ptid;

      /* Now, if we have thread information, update inferior_ptid.  */
      ptid = remote_current_thread (inferior_ptid);
      if (!ptid_equal (ptid, minus_one_ptid))
	{
	  if (ptid_get_pid (ptid) == -1)
	    {
	      ptid = ptid_build (ptid_get_pid (magic_null_ptid),
				 ptid_get_lwp (ptid),
				 ptid_get_tid (ptid));
	      fake_pid_p = 1;
	    }

	  inferior_ptid = ptid;
	}
      else
	{
	  /* Without this, some commands which require an active
	     target (such as kill) won't work.  This variable serves
	     (at least) double duty as both the pid of the target
	     process (if it has such), and as a flag indicating that a
	     target is active.  These functions should be split out
	     into seperate variables, especially since GDB will
	     someday have a notion of debugging several processes.  */
	  inferior_ptid = magic_null_ptid;
	  fake_pid_p = 1;
	}

      inf = remote_add_inferior (ptid_get_pid (inferior_ptid), -1);
      inf->fake_pid_p = fake_pid_p;

      /* Always add the main thread.  */
      add_thread_silent (inferior_ptid);
d4317 1
a4317 1
  set_current_inferior (remote_add_inferior (pid, 1));
d7691 1
a7691 8
  /* Now mark the inferior as running before we do anything else.  */
  inferior_ptid = magic_null_ptid;

  /* Now, if we have thread information, update inferior_ptid.  */
  inferior_ptid = remote_current_thread (inferior_ptid);

  remote_add_inferior (ptid_get_pid (inferior_ptid), 0);
  add_thread_silent (inferior_ptid);
@


1.477
log
@2012-01-20  Pedro Alves  <palves@@redhat.com>
	    Ulrich Weigand  <ulrich.weigand@@linaro.org>

	* configure.ac [AC_CHECK_FUNCS]: Check for pread and pwrite.
	* config.in, configure: Regenerate.

	* target.h (struct target_ops): Add to_fileio_open, to_fileio_pwrite,
	to_fileio_pread, to_fileio_close, to_fileio_unlink.
	(target_fileio_open): Add prototype.
	(target_fileio_pwrite): Likewise.
	(target_fileio_pread): Likewise.
	(target_fileio_close): Likewise.
	(target_fileio_unlink): Likewise.
	(target_fileio_read_alloc): Likewise.
	(target_fileio_read_stralloc): Likewise.

	* target.c: Include "gdb/fileio.h".
	(target_read_stralloc): Accept trailing, but not embedded NUL bytes.
	(default_fileio_target): New function.
	(target_fileio_open): Likewise.
	(target_fileio_pwrite): Likewise.
	(target_fileio_pread): Likewise.
	(target_fileio_close): Likewise.
	(target_fileio_unlink): Likewise.
	(target_fileio_close_cleanup): Likewise.
	(target_fileio_read_alloc_1): Likewise.
	(target_fileio_read_alloc): Likewise.
	(target_fileio_read_stralloc): Likewise.

	* inf-child.c: Include "gdb/fileio.h", <sys/types.h>, <sys/stat.h>,
	<fcntl.h>, and <unistd.h>.
	(inf_child_fileio_open_flags_to_host): New function.
	(inf_child_errno_to_fileio_error): Likewise.
	(inf_child_fileio_open): Likewise.
	(inf_child_fileio_pwrite): Likewise.
	(inf_child_fileio_pread): Likewise.
	(inf_child_fileio_close): Likewise.
	(inf_child_fileio_unlink): Likewise.
	(inf_child_target): Install to_fileio routines.

	* remote.c (init_remote_ops): Install to_fileio routines.
@
text
@d1241 1
d9362 38
d10721 1
d11220 3
@


1.476
log
@2012-01-20  Pedro Alves  <palves@@redhat.com>
	    Ulrich Weigand  <ulrich.weigand@@linaro.org>

ChangeLog:

	* remote.c (remote_multi_process_p): Only check for multi-process
	protocol feature, do not check for extended protocol.
	(remote_supports_multi_process): Check for extended protocol here.
	(set_general_process): Likewise.
	(extended_remote_kill): Likewise.
	(remote_pid_to_str): Likewise.
	(remote_query_supported): Always query multiprocess mode.

gdbserver/ChangeLog:

	* server.c (handle_v_requests): Only support vAttach and vRun to
	start multiple processes when in extended protocol mode.
@
text
@d10677 5
@


1.475
log
@2012-01-20  Pedro Alves  <palves@@redhat.com>
	    Ulrich Weigand  <ulrich.weigand@@linaro.org>

	* inferior.h (struct inferior): Add fake_pid_p.
	* inferior.c (exit_inferior_1): Clear fake_pid_p.
	* remote.c (remote_start_remote): Set fake_pid_p if we have to use
	magic_null_ptid since the remote side doesn't provide a real PID.
@
text
@d362 1
a362 1
  return rs->extended && rs->multi_process_aware;
d1716 1
a1716 1
  if (!remote_multi_process_p (rs))
d3888 1
a3888 2
      if (rs->extended)
	q = remote_query_supported_append (q, "multiprocess+");
d7442 1
a7442 1
  if (res == -1 && !remote_multi_process_p (rs))
d8834 1
a8834 1
      else if (remote_multi_process_p (rs))
d9775 5
a9779 1
  return remote_multi_process_p (rs);
@


1.474
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3256 4
d3279 1
a3279 8
      /* Without this, some commands which require an active target
	 (such as kill) won't work.  This variable serves (at least)
	 double duty as both the pid of the target process (if it has
	 such), and as a flag indicating that a target is active.
	 These functions should be split out into seperate variables,
	 especially since GDB will someday have a notion of debugging
	 several processes.  */
      inferior_ptid = magic_null_ptid;
d3282 25
a3306 1
      inferior_ptid = remote_current_thread (inferior_ptid);
d3308 2
a3309 1
      remote_add_inferior (ptid_get_pid (inferior_ptid), -1);
@


1.473
log
@gdb/
	* Makefile.in (XMLFILES): Add library-list-svr4.dtd.
	* features/library-list-svr4.dtd: New file.
	* remote.c (PACKET_qXfer_libraries_svr4): New.
	(remote_protocol_features): new entry for PACKET_qXfer_libraries_svr4.
	(remote_xfer_partial): Handle TARGET_OBJECT_LIBRARIES_SVR4.
	* solib-svr4.c (struct svr4_library_list): New.
	[HAVE_LIBEXPAT]: Include xml-support.h.
	[HAVE_LIBEXPAT] (svr4_library_list_start_library)
	[HAVE_LIBEXPAT] (svr4_library_list_start_list, svr4_library_attributes)
	[HAVE_LIBEXPAT] (svr4_library_list_children)
	[HAVE_LIBEXPAT] (svr4_library_list_attributes)
	[HAVE_LIBEXPAT] (svr4_library_list_elements, svr4_parse_libraries)
	[HAVE_LIBEXPAT] (svr4_current_sos_via_xfer_libraries)
	[!HAVE_LIBEXPAT] (svr4_current_sos_via_xfer_libraries): New.
	(svr4_read_so_list): Extend the corruption message by addresses.
	(svr4_current_sos): New variable library_list, call
	svr4_current_sos_via_xfer_libraries.
	* target.h (enum target_object): New TARGET_OBJECT_LIBRARIES_SVR4.

gdb/gdbserver/
	* linux-low.c (get_phdr_phnum_from_proc_auxv, get_dynamic, get_r_debug)
	(read_one_ptr, struct link_map_offsets, linux_qxfer_libraries_svr4):
	New.
	(struct linux_target_ops): Install linux_qxfer_libraries_svr4.
	* linux-low.h (struct process_info_private): New member r_debug.
	* server.c (handle_qxfer_libraries): Call
	the_target->qxfer_libraries_svr4.
	(handle_qxfer_libraries_svr4): New function.
	(qxfer_packets): New entry "libraries-svr4".
	(handle_query): Check QXFER_LIBRARIES_SVR4 and report libraries-svr4.
	* target.h (struct target_ops): New member qxfer_libraries_svr4.
	* remote.c (remote_xfer_partial): Call add_packet_config_cmd for
	PACKET_qXfer_libraries_svr4.

gdb/doc/
	* gdb.texinfo (Requirements, Remote Protocol): Reference also `Library
	List Format for SVR4 Targets'.
	(General Query Packets): New item qXfer:libraries-svr4:read.
	(Library List Format for SVR4 Targets): New node.

gdb/testsuite/
	* gdb.base/solib-corrupted.exp: Suppress test on is_remote target.
	(corrupted list): Adjust the expectation.
@
text
@d3 1
a3 3
   Copyright (C) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997,
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
   2010, 2011 Free Software Foundation, Inc.
@


1.473.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 3
a5 1
   Copyright (C) 1988-2012 Free Software Foundation, Inc.
@


1.473.2.2
log
@2012-03-13  Pedro Alves  <palves@@redhat.com>
	    Hui Zhu  <teawater@@gmail.com>
	    Yao Qi  <yao@@codesourcery.com>

	* remote.c (struct remote_state): New field `starting_up'.
	(remote_start_remote): Set and clear it.
	(remote_can_download_tracepoint): If starting up, return false.
@
text
@a273 4
  /* True if we're going through initial connection setup (finding out
     about the remote side's threads, relocating symbols, etc.).  */
  int starting_up;

a3166 4
  /* Signal other parts that we're going through the initial setup,
     and so things may not be stable yet.  */
  rs->starting_up = 1;

a3420 6
  /* The thread and inferior lists are now synchronized with the
     target, our symbols have been relocated, and we're merged the
     target's tracepoints with ours.  We're done with basic start
     up.  */
  rs->starting_up = 0;

d10053 2
a10054 12
  struct remote_state *rs = get_remote_state ();
  struct trace_status *ts;
  int status;

  /* Don't try to install tracepoints until we've relocated our
     symbols, and fetched and merged the target's tracepoint list with
     ours.  */
  if (rs->starting_up)
    return 0;

  ts = current_trace_status ();
  status = remote_get_trace_status (ts);
@


1.473.2.3
log
@2012-03-20  Pedro Alves  <palves@@redhat.com>

	* remote.c (remote_start_remote): Clear `rs->starting_up' on early
	returns.
@
text
@a3270 1
	  rs->starting_up = 0;
a3376 1
	  rs->starting_up = 0;
@


1.472
log
@remove use of sprintf_vma in remote_get_tracepoint_status

This function takes a VMA and was forcing us to perform a cast to
compile without warning on one platform. Except that the cast caused
a warning on sparc-solaris.  This patch fixes the problem by using
phex_nz instead.

gdb/ChangeLog:

        * remote.c (remote_get_tracepoint_status): Delete addrbuf
        local variable.  Avoid use of sprintf_vma.
@
text
@d1246 1
d3752 2
d8362 5
d11089 3
@


1.471
log
@	* NEWS: Mention tracepoint additions.
	* breakpoint.h (struct tracepoint): New field traceframe_usage.
	* breakpoint.c (print_one_breakpoint_location): Identify
	tracepoints as such when reporting hit counts, report
	trace buffer usage.
	(create_tracepoint_from_upload): Copy status info.
	* tracepoint.h (struct trace_status): Rename error_desc to stop_desc,
	add fields user_name, notes, start_time, stop_time.
	(struct uploaded_tp): Add fields hit_count, traceframe_usage.
	* tracepoint.c (trace_user): New global.
	(trace_notes): New global.
	(trace_stop_notes): New global.
	(start_tracing): Add argument and trace note handling.
	(stop_tracing): Ditto.
	(trace_start_command): Add notes argument.
	(trace_stop_command): Ditto.
	(trace_status_command): Report additional status info.
	(trace_status_mi): Similarly.
	(trace_save): Update, record tracepoint status.
	(set_disconnected_tracing): Call target method directly.
	(send_disconnected_tracing_value): Remove.
	(set_trace_user): New function.
	(set_trace_notes): New function.
	(set_trace_stop_notes): New function.
	(parse_trace_status): Handle additional status.
	(parse_tracepoint_status): New function.
	(parse_tracepoint_definition): Call it.
	(tfile_get_tracepoint_status): New function.
	(init_tfile_ops): Use it.
	(_initialize_tracepoint): Add new setshows.
	* target.h (struct target_ops): New methods to_get_tracepoint_status
	and to_set_trace_notes.
	(target_get_tracepoint_status): New macro.
	(target_set_trace_notes): New macro.
	* target.c (update_current_target): Add new methods.
	* remote.c (remote_get_tracepoint_status): New function.
	(remote_set_trace_notes): New function.
	(init_remote_ops): Add them.
	* mi/mi-main.c (mi_cmd_trace_start): Add argument to call.
	(mi_cmd_trace_stop): Ditto.

	* tracepoint.c (struct tracepoint): New field traceframe_usage.
	(tracing_start_time): New global.
	(tracing_stop_time): New global.
	(tracing_user_name): New global.
	(tracing_notes): New global.
	(tracing_stop_note): New global.
	(cmd_qtstart): Set traceframe_usage, start_time.
	(stop_tracing): Set stop_time.
	(cmd_qtstatus): Report additional status.
	(cmd_qtp): New function.
	(handle_tracepoint_query): Call it.
	(cmd_qtnotes): New function.
	(handle_tracepoint_general_set): Call it.
	(get_timestamp): Rename from tsv_get_timestamp.

	* gdb.texinfo (Starting and Stopping Trace Experiments): Document
	note-related options and variables.
	(Tracepoint Packets): Document packet changes.

	* gdb.trace/tstatus.exp: New.
	* gdb.trace/actions.c: Include string.h.
@
text
@a10221 1
  char addrbuf[40];
d10236 2
a10237 2
	  sprintf_vma (addrbuf, loc->address);
	  sprintf (rs->buf, "qTP:%x:%s", tp->number_on_target, addrbuf);
d10251 1
a10251 2
      sprintf_vma (addrbuf, (long unsigned int) utp->addr);
      sprintf (rs->buf, "qTP:%x:%s", utp->number, addrbuf);
@


1.470
log
@	PR build/7196:
	* remote.c (putpkt_for_catch_errors): New function.
	(remote_kill): Use it.
@
text
@d10217 47
d10535 45
d10660 1
d10673 1
@


1.469
log
@2011-11-14  Stan Shebs  <stan@@codesourcery.com>
	    Kwok Cheung Yeung  <kcy@@codesourcery.com>

	* NEWS: Document shorter fast tracepoints and qTMinFTPILen packet.
	* i386-tdep.c (i386_fast_tracepoint_valid_at): Query target for
	the minimum instruction size for fast tracepoints.
	* target.h (struct target_ops): Add new method
	to_get_min_fast_tracepoint_insn_len.
	(target_get_min_fast_tracepoint_insn_len): New.
	* target.c (update_current_target): Set up new target operation.
	* remote.c (remote_write_bytes_aux): Fix typo.
	(remote_get_min_fast_tracepoint_insn_len): New.
	(init_remote_ops): Initialize new field.

	* gdb.texinfo (Create and Delete Tracepoints): Describe what is
	needed to get shorter fast tracepoints.
	(Tracepoint Packets): Document new qTMinFTPILen packet.

	* linux-x86-low.c (small_jump_insn): New.
	(i386_install_fast_tracepoint_jump_pad): Add arguments for
	trampoline and error message, build a trampoline and issue a small
	jump instruction to it.
	(x86_install_fast_tracepoint_jump_pad): Add arguments for
	trampoline and error message.
	(x86_get_min_fast_tracepoint_insn_len): New.
	(the_low_target): Add call to x86_get_min_fast_tracepoint_insn_len.
	* linux-low.h (struct linux_target_ops): Add arguments to
	install_fast_tracepoint_jump_pad operation, add new operation.
	* linux-low.c (linux_install_fast_tracepoint_jump_pad): Add
	arguments.
	(linux_get_min_fast_tracepoint_insn_len): New function.
	(linux_target_op): Add new operation.
	* tracepoint.c (gdb_trampoline_buffer): New IPA variable.
	(gdb_trampoline_buffer_end): Ditto.
	(gdb_trampoline_buffer_error): Ditto.
	(struct ipa_sym_addresses): Add fields for new IPA variables.
	(symbol_list): Add entries for new IPA variables.
	(struct tracepoint): Add fields to hold the address range of the
	trampoline used by the tracepoint.
	(trampoline_buffer_head): New static variable.
	(trampoline_buffer_tail): Ditto.
	(claim_trampoline_space): New function.
	(have_fast_tracepoint_trampoline_buffer): New function.
	(clone_fast_tracepoint): Fill in trampoline fields of tracepoint
	structure.
	(install_fast_tracepoint): Ditto, also add error buffer argument.
	(cmd_qtminftpilen): New function.
	(handle_tracepoint_query): Add response to qTMinFTPILen packet.
	(fast_tracepoint_from_trampoline_address): New function.
	(fast_tracepoint_collecting): Handle trampoline as part of jump
	pad space.
	(set_trampoline_buffer_space): New function.
	(initialize_tracepoint): Initialize new IPA variables.
	* target.h (struct target_ops): Add arguments to
	install_fast_tracepoint_jump_pad operation, add new
	get_min_fast_tracepoint_insn_len operation.
	(target_get_min_fast_tracepoint_insn_len): New.
	(install_fast_tracepoint_jump_pad): Add arguments.
	* server.h (IPA_BUFSIZ): Define.
	* linux-i386-ipa.c: Include extra header files.
	(initialize_fast_tracepoint_trampoline_buffer): New function.
	(initialize_low_tracepoint): Call it.
	* server.h (set_trampoline_buffer_space): Declare.
	(claim_trampoline_space): Ditto.
	(have_fast_tracepoint_trampoline_buffer): Ditto.

	* gdb.trace/ftrace.c: New.
	* gdb.trace/ftrace.exp: New.
@
text
@d7372 8
d7385 1
a7385 1
  catch_errors ((catch_errors_ftype *) putpkt, "k", "", RETURN_MASK_ERROR);
@


1.468
log
@gdb/
	* remote.c (struct remote_state): <install_in_trace> new field.
	(PACKET_InstallInTrace): New enum value.
	(remote_install_in_trace_feature): Support InstallInTrace.
	(remote_supports_install_in_trace): Likewise.
	(remote_protocol_features): Likewise.
	(_initialize_remote): Likewise.
	(remote_can_download_tracepoint): New.
	* target.h (struct target): New field
	`to_can_download_tracepoint'.
	(target_can_download_tracepoint): New macro.
	* target.c (update_current_target): Update.
	* breakpoint.h (struct bp_location): Add comment on field
	`duplicate'.
	(should_be_inserted): Don't differentiate breakpoint and tracepoint.
	(remove_breakpoints): Don't remove tracepoints.
	(tracepoint_locations_match ): New.
	(breakpoint_locations_match): Call it.
	(disable_breakpoints_in_unloaded_shlib): Handle tracepoint.
	(download_tracepoint_locations): New.
	(update_global_location_list): Call it.
	* tracepoint.c (find_matching_tracepoint): Delete.
	(find_matching_tracepoint_location): Renamed from
	find_matching_tracepoint.  Return bp_location rather than
	tracepoint.
	(merge_uploaded_tracepoints): Set `inserted' field to 1 if
	tracepoint is found.

gdb/doc/
	* gdb.texinfo (Create and Delete Tracepoints): Describe changed
	behavior of tracepoint.
	(General Query Packets): New feature InstallInTrace.
	(Remote Configuration): Document "set remote
	install-in-trace-packet".

gdb/gdbserver/
	* server.c (handle_query): Handle InstallInTrace for qSupported.
	* tracepoint.c (add_tracepoint): Sort list.
	(install_tracepoint, download_tracepoint): New.
	(cmd_qtdp): Call them to install and download tracepoints.
	(sort_tracepoints): Removed.
	(cmd_qtstart): Update.

gdb/testsuite/
	* gdb.trace/change-loc-1.c: New.
	* gdb.trace/change-loc-2.c: New.
	* gdb.trace/change-loc.c: New.
	* gdb.trace/change-loc.exp:  New.
	* gdb.trace/change-loc.h:  New.
	* gdb.trace/trace-break.c (marker): Define new symbol.
	* gdb.trace/trace-break.exp (break_trace_same_addr_5):
        New.
	(break_trace_same_addr_6): New.
@
text
@d6373 1
a6373 1
		    _("minumum packet size too small to write data"));
d10454 26
d10569 1
@


1.467
log
@	* target.h (struct target): <to_download_tracepoint> Change type
	of parameter from tracepoint to bp_location.
	* target.c (update_current_target): Update.
	* tracepoint.c (start_tracing): Update.
	* remote.c (remote_download_tracepoint): Remove loop for each location
	of a tracepoint.
@
text
@d326 4
d1268 1
d3704 10
d3779 2
d9768 8
d10036 18
d10526 1
d11044 3
@


1.466
log
@2011-11-02  Stan Shebs  <stan@@codesourcery.com>

	String collection for tracepoints.
	* NEWS: Mention string collection.
	* common/ax.def (tracenz): New bytecode.
	* ax-gdb.h (trace_string_kludge): Declare.
	* ax-gdb.c: Include valprint.h and c-lang.h.
	(trace_string_kludge): New global.
	(gen_traced_pop): Add string case.
	(agent_command): Add string case.
	* tracepoint.h (decode_agent_options): Declare.
	* tracepoint.c: Include cli-utils.h.
	(decode_agent_options): New function.
	(validate_actionline): Call it.
	(encode_actions_1): Ditto.
	* target.h (struct target_ops): New method to_supports_string_tracing.
	(target_supports_string_tracing): New macro.
	* target.c (update_current_target): Add to_supports_string_tracing.
	* remote.c (struct remote_state): New field string_tracing.
	(remote_string_tracing_feature): New function.
	(remote_protocol_features): New feature tracenz.
	(remote_supports_string_tracing): New function.
	(init_remote_ops): Set to_supports_string_tracing.

	* tracepoint.c (agent_mem_read_string): New function.
	(eval_agent_expr): Call it for tracenz.
	* server.c (handle_query): Report support for tracenz.

	* gdb.texinfo (Tracepoint Action Lists): Document collect/s.
	(General Query Packets): Describe tracenz feature.
	* agentexpr.texi (Bytecode Descriptions): Describe tracenz.

	* gdb.trace/collection.c: Add code using strings.
	* gdb.trace/collection.exp: Add tests of string collection.
@
text
@d9838 1
a9838 1
remote_download_tracepoint (struct breakpoint *b)
d9840 1
a9840 1
  struct bp_location *loc;
d9851 1
d9854 16
a9869 4
  /* Iterate over all the tracepoint locations.  It's up to the target to
     notice multiple tracepoint packets with the same number but different
     addresses, and treat them as multiple locations.  */
  for (loc = b->loc; loc; loc = loc->next)
d9871 3
a9873 16
      encode_actions (b, loc, &tdp_actions, &stepping_actions);
      old_chain = make_cleanup (free_actions_list_cleanup_wrapper,
				tdp_actions);
      (void) make_cleanup (free_actions_list_cleanup_wrapper,
			   stepping_actions);

      tpaddr = loc->address;
      sprintf_vma (addrbuf, tpaddr);
      sprintf (buf, "QTDP:%x:%s:%c:%lx:%x", b->number,
	       addrbuf, /* address */
	       (b->enable_state == bp_enabled ? 'E' : 'D'),
	       t->step_count, t->pass_count);
      /* Fast tracepoints are mostly handled by the target, but we can
	 tell the target how big of an instruction block should be moved
	 around.  */
      if (b->type == bp_fast_tracepoint)
d9875 5
a9879 16
	  /* Only test for support at download time; we may not know
	     target capabilities at definition time.  */
	  if (remote_supports_fast_tracepoints ())
	    {
	      int isize;

	      if (gdbarch_fast_tracepoint_valid_at (target_gdbarch,
						    tpaddr, &isize, NULL))
		sprintf (buf + strlen (buf), ":F%x", isize);
	      else
		/* If it passed validation at definition but fails now,
		   something is very wrong.  */
		internal_error (__FILE__, __LINE__,
				_("Fast tracepoint not "
				  "valid during download"));
	    }
d9881 5
a9885 5
	    /* Fast tracepoints are functionally identical to regular
	       tracepoints, so don't take lack of support as a reason to
	       give up on the trace run.  */
	    warning (_("Target does not support fast tracepoints, "
		       "downloading %d as regular tracepoint"), b->number);
d9887 12
a9898 1
      else if (b->type == bp_static_tracepoint)
d9900 4
a9903 11
	  /* Only test for support at download time; we may not know
	     target capabilities at definition time.  */
	  if (remote_supports_static_tracepoints ())
	    {
	      struct static_tracepoint_marker marker;

	      if (target_static_tracepoint_marker_at (tpaddr, &marker))
		strcat (buf, ":S");
	      else
		error (_("Static tracepoint not valid during download"));
	    }
d9905 1
a9905 4
	    /* Fast tracepoints are functionally identical to regular
	       tracepoints, so don't take lack of support as a reason
	       to give up on the trace run.  */
	    error (_("Target does not support static tracepoints"));
d9907 13
a9919 3
      /* If the tracepoint has a conditional, make it into an agent
	 expression and append to the definition.  */
      if (loc->cond)
d9921 8
a9928 16
	  /* Only test support at download time, we may not know target
	     capabilities at definition time.  */
	  if (remote_supports_cond_tracepoints ())
	    {
	      aexpr = gen_eval_for_expr (tpaddr, loc->cond);
	      aexpr_chain = make_cleanup_free_agent_expr (aexpr);
	      sprintf (buf + strlen (buf), ":X%x,", aexpr->len);
	      pkt = buf + strlen (buf);
	      for (ndx = 0; ndx < aexpr->len; ++ndx)
		pkt = pack_hex_byte (pkt, aexpr->buf[ndx]);
	      *pkt = '\0';
	      do_cleanups (aexpr_chain);
	    }
	  else
	    warning (_("Target does not support conditional tracepoints, "
		       "ignoring tp %d cond"), b->number);
d9930 4
d9936 5
a9940 5
	strcat (buf, "-");
      putpkt (buf);
      remote_get_noisy_reply (&target_buf, &target_buf_size);
      if (strcmp (target_buf, "OK"))
	error (_("Target does not support tracepoints."));
d9942 4
a9945 2
      /* do_single_steps (t); */
      if (tdp_actions)
d9947 11
a9957 14
	  for (ndx = 0; tdp_actions[ndx]; ndx++)
	    {
	      QUIT;	/* Allow user to bail out with ^C.  */
	      sprintf (buf, "QTDP:-%x:%s:%s%c",
		       b->number, addrbuf, /* address */
		       tdp_actions[ndx],
		       ((tdp_actions[ndx + 1] || stepping_actions)
			? '-' : 0));
	      putpkt (buf);
	      remote_get_noisy_reply (&target_buf,
				      &target_buf_size);
	      if (strcmp (target_buf, "OK"))
		error (_("Error on target while setting tracepoints."));
	    }
d9959 4
a9962 1
      if (stepping_actions)
d9964 11
a9974 14
	  for (ndx = 0; stepping_actions[ndx]; ndx++)
	    {
	      QUIT;	/* Allow user to bail out with ^C.  */
	      sprintf (buf, "QTDP:-%x:%s:%s%s%s",
		       b->number, addrbuf, /* address */
		       ((ndx == 0) ? "S" : ""),
		       stepping_actions[ndx],
		       (stepping_actions[ndx + 1] ? "-" : ""));
	      putpkt (buf);
	      remote_get_noisy_reply (&target_buf,
				      &target_buf_size);
	      if (strcmp (target_buf, "OK"))
		error (_("Error on target while setting tracepoints."));
	    }
d9976 1
d9978 4
a9981 2
      if (remote_protocol_packets[PACKET_TracepointSource].support
	  == PACKET_ENABLE)
d9983 9
a9991 25
	  if (b->addr_string)
	    {
	      strcpy (buf, "QTDPsrc:");
	      encode_source_string (b->number, loc->address,
				    "at", b->addr_string, buf + strlen (buf),
				    2048 - strlen (buf));

	      putpkt (buf);
	      remote_get_noisy_reply (&target_buf, &target_buf_size);
	      if (strcmp (target_buf, "OK"))
		warning (_("Target does not support source download."));
	    }
	  if (b->cond_string)
	    {
	      strcpy (buf, "QTDPsrc:");
	      encode_source_string (b->number, loc->address,
				    "cond", b->cond_string, buf + strlen (buf),
				    2048 - strlen (buf));
	      putpkt (buf);
	      remote_get_noisy_reply (&target_buf, &target_buf_size);
	      if (strcmp (target_buf, "OK"))
		warning (_("Target does not support source download."));
	    }
	  remote_download_command_source (b->number, loc->address,
					  breakpoint_commands (b));
d9993 14
d10008 1
a10008 2
      do_cleanups (old_chain);
    }
@


1.465
log
@2011-10-13  Luis Machado  <lgustavo@@codesourcery.com>

	* remote.c (remote_save_trace_data): Invert comparison.
@
text
@d334 3
d3718 10
d3780 2
d9758 8
d10485 1
@


1.464
log
@	* inferior.h (disable_randomization): Declare.
	* infrun.c (disable_randomization): New global variable.
	(show_disable_randomization): New function.
	(set_disable_randomization): Likewise.
	(_initialize_infrun): Install set/show disable-randomization
	commands.
	* linux-nat.c (disable_randomization): Remove.
	(show_disable_randomization): Likewise.
	(set_disable_randomization): Likewise.
	(_initialize_linux_nat): No longer install set/show
	disable-randomization commands here.
	(linux_nat_supports_disable_randomization): New function.
	(linux_nat_add_target): Install it.
	* remote.c (PACKET_QDisableRandomization): New enum value.
	(remote_protocol_packets): Support QDisableRandomization.
	(_initialize_remote): Likewise.
	(remote_supports_disable_randomization): New function.
	(init_remote_ops): Install it.
	(extended_remote_supports_disable_randomization): New function.
	(init_extended_remote_ops): Install it.
	(extended_remote_disable_randomization): New function.
	(extended_remote_create_inferior_1): Call it.
	* target.h (struct target_ops): Add to_supports_disable_randomization.
	(target_supports_disable_randomization): Add prototype.
	* target.c (target_supports_disable_randomization): New function.
	(find_default_supports_disable_randomization): Likewise.
	(init_dummy_target): Install it.

doc/
	* gdb.texinfo (Starting your Program): "set disable-randomization"
	is no longer Linux-specific.
	(Remote Configuration): Document "set remote
	disable-randomization-packet".
	(General Query Packets): Document "QDisableRandomization" packet
	and add it to "qSupported" list.

gdbserver/
	* configure.ac: Check support for personality routine.
	* configure: Regenerate.
	* config.in: Likewise.
	* linux-low.c: Include <sys/personality.h>.
	Define ADDR_NO_RANDOMIZE if necessary.
	(linux_create_inferior): Disable address space randomization when
	forking inferior, if requested.
	(linux_supports_disable_randomization): New function.
	(linux_target_ops): Install it.
	* server.h (disable_randomization): Declare.
	* server.c (disable_randomization): New global variable.
	(handle_general_set): Handle QDisableRandomization.
	(handle_query): Likewise for qSupported.
	(main): Support --disable-randomization and --no-disable-randomization
	command line arguments.
	* target.h (struct target_ops): Add supports_disable_randomization.
	(target_supports_disable_randomization): New macro.
@
text
@d10277 1
a10277 1
  if (*reply != '\0')
@


1.463
log
@2011-09-14  Pedro Alves  <pedro@@codesourcery.com>

	* infrun.c (prepare_for_detach, wait_for_inferior)
	(fetch_inferior_event): Don't flush the register cache.
	* remote.c (struct stop_reply) <regcache>: Add comment.
@
text
@d1266 1
d3765 2
d7490 22
d7587 4
d9697 7
d10459 2
d10513 2
d10987 3
@


1.462
log
@2011-09-07  Abhijit Halder  <abhijit.k.halder@@gmail.com>

	* remote.c (remote_console_output): Reindent.
@
text
@d4901 4
@


1.461
log
@        gdb/
        * remote.c (PACKET_qXfer_fdpic): New enum value.
        (remote_protocol_features): Add qXfer:fdpic:read packet.
        (remote_xfer_partial): Support TARGET_OBJECT_FDPIC.
        (_initialize_remote): Add set/show remote read-fdpic-loadmap command.
        * target.h (enum target_object): Add TARGET_OBJECT_FDPIC.

        gdb/gdbserver:
        * target.h (struct target_ops): Add read_loadmap.
        * linux-low.c (struct target_loadseg): New type.
        (struct target_loadmap): New type.
        (linux_read_loadmap): New function.
        (linux_target_ops): Add linux_read_loadmap.
        * server.c (handle_query): Support qXfer:fdpic:read packet.
	* win32-low.c (win32_target_ops): Initialize field `read_loadmap' to NULL.

        gdb/doc/
        * gdb.texinfo : Document qXfer:fdpic:read packet.
@
text
@d4882 2
a4883 2
    gdb_flush (gdb_stdtarg);
  }
@


1.460
log
@2011-08-04  Pedro Alves  <pedro@@codesourcery.com>

	* ui-out.h (uiout): Rename to ...
	(current_uiout): ... this.
	* ui-out.c (uiout): Rename to ...
	(current_uiout): ... this.
	* ada-lang.c (print_it_exception, print_one_exception)
	(print_mention_exception): Adjust.
	* breakpoint.c (watchpoint_check): Adjust.
	(print_breakpoint_location, print_one_breakpoint, breakpoint_1)
	(default_collect_info, watchpoints_info, print_one_catch_fork)
	(print_one_catch_vfork, print_one_catch_syscall)
	(print_one_catch_exec, mention, print_it_ranged_breakpoint)
	(print_one_ranged_breakpoint, print_mention_ranged_breakpoint)
	(print_it_watchpoint, print_mention_watchpoint)
	(print_it_masked_watchpoint, print_mention_masked_watchpoint)
	(print_it_exception_catchpoint, print_one_exception_catchpoint)
	(print_mention_exception_catchpoint, say_where, bkpt_print_it)
	(bkpt_print_mention, momentary_bkpt_print_it)
	(tracepoint_print_mention, update_static_tracepoint)
	(tracepoints_info, save_breakpoints): Adjust.
	* cli-out.c (field_separator): Adjust.
	* cp-abi.c (list_cp_abis, show_cp_abi_cmd): Adjust.
	* exceptions.c (catch_exceptions_with_msg, catch_errors): Adjust.
	* frame.c (get_current_frame): Adjust.
	* infcmd.c (run_command_1, print_return_value): Adjust.
	* inferior.c (inferior_command, info_inferiors_command): Adjust.
	* infrun.c (print_end_stepping_range_reason): Adjust.
	(print_signal_exited_reason, print_exited_reason): Adjust.
	(print_signal_received_reason, print_no_history_reason): Adjust.
	* interps.c (interp_set): Adjust.
	* osdata.c (info_osdata_command): Adjust.
	* progspace.c (maintenance_info_program_spaces_command): Adjust.
	* remote-fileio.c (remote_fileio_request): Adjust.
	* remote.c (show_remote_cmd): Adjust.
	* solib.c (info_sharedlibrary_command): Adjust.
	* source.c (print_source_lines_base): Adjust.
	* stack.c (print_stack_frame): Adjust.
	(do_gdb_disassembly, print_frame_info, print_frame): Adjust.
	* symfile-mem.c (add_vsyscall_page): Adjust.
	* symfile.c (load_progress, generic_load)
	(print_transfer_performance): Adjust.
	* thread.c (info_threads_command, restore_selected_frame)
	(thread_command): Adjust.
	* top.c (make_cleanup_restore_ui_file): Adjust.
	* tracepoint.c (tvariables_info_1, trace_status_mi, tfind_1)
	(print_one_static_tracepoint_marker): Adjust.
	* cli/cli-cmds.c (print_disassembly): Adjust.
	* cli/cli-decode.c (print_doc_line): Adjust.
	* cli/cli-interp.c (safe_execute_command): Adjust.
	* cli/cli-logging.c (set_logging_redirect, pop_output_files)
	(handle_redirections): Adjust.
	* cli/cli-script.c (show_user_1): Adjust.
	* cli/cli-setshow.c (do_setshow_command, cmd_show_list): Adjust.
	* mi/mi-cmd-break.c (breakpoint_notify): Adjust.
	* mi/mi-cmd-disas.c (mi_cmd_disassemble): Adjust.
	* mi/mi-cmd-env.c (mi_cmd_env_pwd, mi_cmd_env_path)
	(mi_cmd_env_dir): Adjust.
	* mi/mi-cmd-file.c (mi_cmd_file_list_exec_source_file)
	(print_partial_file_name, mi_cmd_file_list_exec_source_files): Adjust.
	* mi/mi-cmd-stack.c (mi_cmd_stack_list_frames)
	(mi_cmd_stack_info_depth, mi_cmd_stack_list_args)
	(list_args_or_locals): Adjust.
	* mi/mi-cmd-var.c (print_varobj, mi_cmd_var_create)
	(mi_cmd_var_delete, mi_cmd_var_set_format, mi_cmd_var_set_frozen)
	(mi_cmd_var_show_format, mi_cmd_var_info_num_children)
	(mi_cmd_var_list_children, mi_cmd_var_info_type)
	(mi_cmd_var_info_path_expression, mi_cmd_var_info_expression)
	(mi_cmd_var_show_attributes, mi_cmd_var_evaluate_expression)
	(mi_cmd_var_assign, mi_cmd_var_update, varobj_update_one): Adjust.
	* mi/mi-interp.c (mi_on_normal_stop): Adjust.
	* mi/mi-main.c (mi_cmd_gdb_exit, mi_cmd_thread_select)
	(mi_cmd_thread_list_ids, mi_cmd_thread_info, print_one_inferior)
	(list_available_thread_groups, mi_cmd_list_thread_groups)
	(mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers)
	(mi_cmd_data_list_register_values, get_register)
	(mi_cmd_data_evaluate_expression, mi_cmd_data_read_memory)
	(mi_cmd_data_read_memory_bytes, mi_cmd_list_features)
	(mi_cmd_list_target_features, mi_cmd_add_inferior)
	(mi_execute_command, mi_load_progress): Adjust.
	* mi/mi-symbol-cmds.c (mi_cmd_symbol_list_lines): Adjust.
	* python/py-auto-load.c (print_script, info_auto_load_scripts):
	Adjust.
	* python/py-breakpoint.c (bppy_get_commands): Adjust.
	* tui/tui-interp.c (tui_command_loop): Adjust.
	* tui/tui-io.c (tui_setup_io, tui_initialize_io): Adjust.
@
text
@d1265 1
d3762 2
d8308 4
d10940 3
@


1.459
log
@2011-07-26  Philippe Waroquiers  <philippe.waroquiers@@skynet.be>

	* remote.c (remote_region_ok_for_hw_watchpoint): New function.
	(remote_hw_watchpoint_length_limit): New variable.
	(_initialize_remote) add set,show cmds for this new variable.
	* gdb.texinfo: document these new commands.
	* NEWS: Mention these new commands.
@
text
@d10544 1
@


1.458
log
@2011-07-25  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* breakpoint.h (print_recreate_thread): Declare.
	(struct breakpoint): Move step_count, pass_count,
	number_on_target, static_trace_marker_id,
	static_trace_marker_id_idx ...
	(struct tracepoint): ... to this new struct.
	(get_tracepoint, get_tracepoint_by_number_on_target)
	(get_tracepoint_by_number): Change return type to struct
	tracepoint pointer.
	* breakpoint.c (is_tracepoint_type): New, factored out from
	is_tracepoint.
	(is_tracepoint): Adjust.
	(print_one_breakpoint_location): Cast to struct tracepoint as
	necessary, and adjust.
	(print_recreate_catch_fork, print_recreate_catch_vfork)
	(print_recreate_catch_syscall, print_recreate_catch_exec): Call
	print_recreate_thread.
	(init_breakpoint_sal): New, factored out from
	create_breakpoint_sal.
	(create_breakpoint_sal): Reimplement.
	(create_breakpoint): Allocate a struct tracecepoint if the caller
	wanted a tracepoint.  Use init_breakpoint_sal and
	install_breakpoint.
	(print_recreate_ranged_breakpoint, print_recreate_watchpoint)
	(print_recreate_masked_watchpoint)
	(print_recreate_exception_catchpoint): Call print_recreate_thread.
	(tracepoint_print_one_detail): Adjust.
	(tracepoint_print_recreate): Adjust.  Call print_recreate_thread.
	Dump the pass count here.
	(update_static_tracepoint): Adjust.
	(addr_string_to_sals): Adjust.
	(create_tracepoint_from_upload): Adjust.  Change return type to
	struct tracepoint pointer.
	(trace_pass_set_count): Change parameter type to struct tracepoint
	pointer, and adjust.
	(trace_pass_command): Adjust.
	(get_tracepoint, get_tracepoint_by_number_on_target)
	(get_tracepoint_by_number): Change return type to struct
	tracepoint pointer, and adjust.
	(print_recreate_thread): New, factored out from save_breakpoints.
	(save_breakpoints): Don't print thread and task and passcount
	recreation here.
	* remote.c (remote_download_tracepoint): Adjust.
	* tracepoint.c (trace_actions_command, validate_actionline)
	(start_tracing, tfind_1, trace_find_tracepoint_command)
	(trace_dump_command): Adjust.
	(find_matching_tracepoint): Change return type to struct
	tracepoint pointer, and adjust.
	(merge_uploaded_tracepoints, tfile_get_traceframe_address)
	(tfile_trace_find, tfile_fetch_registers): Adjust.
	* tracepoint.h (create_tracepoint_from_upload): Change return type
	to struct tracepoint pointer.
	* ada-lang.c (print_recreate_exception): Call
	print_recreate_thread.
	* mi/mi-cmd-break.c (mi_cmd_break_passcount): Adjust.
@
text
@d7766 1
d7770 13
d10373 2
d10770 9
@


1.457
log
@2011-07-15  Hui Zhu  <teawater@@gmail.com>

	* remote.c (remote_get_trace_status): Add comments.
@
text
@d9754 1
a9754 1
remote_download_tracepoint (struct breakpoint *t)
d9767 1
d9772 1
a9772 1
  for (loc = t->loc; loc; loc = loc->next)
d9774 1
a9774 1
      encode_actions (t, loc, &tdp_actions, &stepping_actions);
d9782 1
a9782 1
      sprintf (buf, "QTDP:%x:%s:%c:%lx:%x", t->number, 
d9784 1
a9784 1
	       (t->enable_state == bp_enabled ? 'E' : 'D'),
d9789 1
a9789 1
      if (t->type == bp_fast_tracepoint)
d9812 1
a9812 1
		       "downloading %d as regular tracepoint"), t->number);
d9814 1
a9814 1
      else if (t->type == bp_static_tracepoint)
d9852 1
a9852 1
		       "ignoring tp %d cond"), t->number);
d9855 1
a9855 1
  if (t->commands || *default_collect)
d9869 1
a9869 1
		       t->number, addrbuf, /* address */
d9886 1
a9886 1
		       t->number, addrbuf, /* address */
d9901 1
a9901 1
	  if (t->addr_string)
d9904 2
a9905 2
	      encode_source_string (t->number, loc->address,
				    "at", t->addr_string, buf + strlen (buf),
d9913 1
a9913 1
	  if (t->cond_string)
d9916 2
a9917 2
	      encode_source_string (t->number, loc->address,
				    "cond", t->cond_string, buf + strlen (buf),
d9924 2
a9925 2
	  remote_download_command_source (t->number, loc->address,
					  breakpoint_commands (t));
@


1.456
log
@2011-07-14  Hui Zhu  <teawater@@gmail.com>

	* remote.c (remote_get_trace_status): Initialize p.
@
text
@d10045 1
@


1.455
log
@gdb/
	Work around kgdb.
	* remote.c (remote_get_trace_status): New variable ex.  Put
	remote_get_noisy_reply into TRY_CATCH.  Call exception_fprintf for it.
@
text
@d10045 1
a10045 1
  char *p;
@


1.454
log
@2011-07-07  Hui Zhu  <teawater@@gmail.com>

	Revert:
	2011-07-06  Hui Zhu  <teawater@@gmail.com>
	* remote.c (remote_start_remote): Add TRY_CATCH for
	remote_get_trace_status.
	* tracepoint.c (disconnect_tracing): Ditto.
@
text
@d10048 1
d10053 10
a10062 1
  p = remote_get_noisy_reply (&target_buf, &target_buf_size);
@


1.453
log
@2011-07-06  Hui Zhu  <teawater@@gmail.com>

	* remote.c (remote_start_remote): Add TRY_CATCH for
	remote_get_trace_status.
	* tracepoint.c (disconnect_tracing): Ditto.
@
text
@a3148 2
  int ret = 0;
  volatile struct gdb_exception ex;
d3392 1
a3392 10
  TRY_CATCH (ex, RETURN_MASK_ERROR)
    {
      ret = remote_get_trace_status (current_trace_status ());
    }
  if (ex.reason < 0)
    {
      warning (_("%s"), ex.message);
      ret = -1;
    }
  if (ret != -1)
@


1.452
log
@2011-06-23  Yao Qi  <yao@@codesourcery.com>

	* infrun.c (start_remote): Move call init_wait_for_inferior to ...
	* remote.c (remote_start_remote): ... here.
	* monitor.c (monitor_open): ... here.
@
text
@d3149 2
d3394 10
a3403 1
  if (remote_get_trace_status (current_trace_status ()) != -1)
@


1.451
log
@2011-06-16  Hui Zhu  <teawater@@gmail.com>

	* remote.c (remote_trace_set_readonly_regions): Add check for
	remote_protocol_packets[PACKET_qXfer_traceframe_info].support before
	output warning.
@
text
@d3283 11
@


1.450
log
@2011-06-15  Hui Zhu  <teawater@@gmail.com>

	* remote.c (remote_trace_set_readonly_regions): Add a check for
	target_buf_size.
@
text
@d10004 3
a10006 1
	  warning (_("\
@


1.449
log
@2011-06-06  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* infcall.c (run_inferior_call): Don't mask async.  Instead force
	a synchronous wait, if the target can async.

	* target.h (struct target_ops): Delete to_async_mask.
	(target_async_mask): Delete.
	* target.c (update_current_target): Delete references to to_async_mask.
	* linux-nat.c (linux_nat_async_mask_value): Delete.
	(linux_nat_is_async_p, linux_nat_can_async_p): Remove references
	to linux_nat_async_mask_value.
	(linux_nat_async_mask): Delete.
	(linux_nat_async, linux_nat_close): Remove references to
	linux_nat_async_mask_value.
	* record.c (record_async_mask_value): Delete.
	(record_async): Remove references to record_async_mask_value.
	(record_async_mask): Delete.
	(record_can_async_p, record_is_async_p): Remove references to
	record_async_mask_value.
	(init_record_ops, init_record_core_ops): Remove references to
	record_async_mask.
	* remote.c (remote_async_mask_value): Delete.
	(init_remote_ops): Remove reference to remote_async_mask.
	(remote_can_async_p, remote_is_async_p): Remove references to
	remote_async_mask_value.
	(remote_async): Remove references to remote_async_mask_value.
	(remote_async_mask): Delete.

	* infrun.c (fetch_inferior_event): Don't claim registers changed
	if the current thread is already not executing.
@
text
@d9980 1
d9989 1
d10001 9
a10009 2
      sprintf (target_buf + strlen (target_buf), 
	       ":%s,%s", tmp1, tmp2);
@


1.448
log
@Various spelling fixes.

gdb/ChangeLog:

        From Stephen Kitt  <steve@@sk2.org>
        * breakpoint.c, breakpoint.h, cli/cli-dump.c, dwarf2expr.c,
        gdbarch.c, gdbarch.sh, remote.c: Various spelling fixes.

gdb/testsuite/ChangeLog:

        From Stephen Kitt  <steve@@sk2.org>
        * gdb.base/help.exp: Adjust following some spelling corrections
        in GDB.
@
text
@a136 2
static int remote_async_mask (int new_mask);

a721 2
static int remote_async_mask_value = 1;

a10357 1
  remote_ops.to_async_mask = remote_async_mask;
d10424 1
a10424 1
  return remote_async_mask_value && serial_can_async_p (remote_desc);
d10435 1
a10435 1
  return remote_async_mask_value && serial_is_async_p (remote_desc);
a10470 4
  if (remote_async_mask_value == 0)
    internal_error (__FILE__, __LINE__,
		    _("Calling remote_async when async is masked"));

a10480 9
static int
remote_async_mask (int new_mask)
{
  int curr_mask = remote_async_mask_value;

  remote_async_mask_value = new_mask;
  return curr_mask;
}

@


1.447
log
@2011-05-30  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* target.h (enum inferior_event_type): Delete INF_QUIT_REQ.
	* inf-loop.h (inferior_event_handler_wrapper): Delete.
	* inf-loop.c (inferior_event_handler_wrapper): Delete.
	(inferior_event_handler): Don't handle INF_QUIT_REQ.
	* remote.c (_initialize_remote): Register
	async_remote_interrupt_twice directly as
	sigint_remote_twice_token event.
@
text
@d6232 1
a6232 1
				  "binary downloading suppported by target\n");
@


1.446
log
@Add support for enabling and disabling tracepoints while a trace
experiment is still running.

gdb/
	* breakpoint.c (disable_breakpoint): Disable all locations
	associated with a tracepoint on target if a trace experiment is
	running.
	(disable_command): Disable a specific tracepoint location on target if
	a trace	experiment is running.
	(do_enable_breakpoint): Enable all locations associated with a
	tracepoint on target if a trace experiment is running.
	(enable_command) Enable a specific tracepoint location on target if a
	trace experiment is running.
	* target.c (update_current_target): Add INHERIT and de_fault clauses for
	to_supports_enable_disable_tracepoint, to_enable_tracepoint and
	to_disable_tracepoint.
	* target.h: Add declaration of struct bp_location.
	(struct target_ops): Add new functions
	to_supports_enable_disable_tracepoint, to_enable_tracepoint and
	to_disable_tracepoint to target operations.
	(target_supports_enable_disable_tracepoint): New macro.
	(target_enable_tracepoint): New macro.
	(target_disable_tracepoint): New macro.
	* remote.c (struct remote_state): Add new field.
	(remote_enable_disable_tracepoint_feature): New.
	(remote_protocol_features): Add new entry.
	(remote_supports_enable_disable_tracepoint): New.
	(remote_enable_tracepoint): New.
	(remote_disable_tracepoint): New.
	(init_remote_ops): Add remote_enable_tracepoint,
	remote_disable_tracepoint and remote_supports_enable_disable_tracepoint
	to remote operations.
	* tracepoint.c (start_tracing): Allow tracing to start without any
	tracepoints enabled with just a warning if they can be re-enabled
	later.
	* NEWS: Add news item for the new behaviour of the enable and disable
	GDB commands when applied to tracepoints.
	Add news items for the new remote packets QTEnable and QTDisable.

gdb/doc/
	* gdb.texinfo: Document change in the behaviour of the enable and
	disable GDB commands when applied to tracepoints.
	Document the EnableDisableTracepoints remote stub feature.
	Document QTEnable and QTDisable in the list of tracepoint packets.

gdb/gdbserver/
	* server.c (handle_query): Add EnableDisableTracepoints to the list
	of supported features.
	* tracepoint.c (clear_installed_tracepoints): Uninstall	disabled
	tracepoints.
	(cmd_qtenable_disable): New.
	(cmd_qtstart): Install tracepoints even if disabled.
	(handle_tracepoint_general_set): Add call to cmd_qtenable_disable on
	receiving a QTEnable or QTDisable packet.
	(gdb_collect): Skip data collection if fast tracepoint is disabled.
	(ust_marker_to_static_tracepoint): Do not ignore disabled static
	tracepoints.
	(gdb_probe): Skip data collection if static tracepoint is disabled.
@
text
@d10630 1
a10630 1
    create_async_signal_handler (inferior_event_handler_wrapper, NULL);
@


1.445
log
@	* target.h (struct target_ops): Remove to_notice_signals;
	add to_pass_signals.
	(target_notice_signals): Remove.
	(target_pass_signals): Add prototype.
	* target.c (update_current_target): Remove to_notice_signals;
	mention to_pass_signals.
	(target_pass_signals): New function.
	(debug_to_notice_signals): Remove.
	(setup_target_debug): Do not install debug_to_notice_signals.

	* infrun.c (signal_pass): New global.
	(resume): Call target_pass_signals.
	(handle_inferior_event): Report all signals while stepping over
	non-steppable watchpoint.  Reset trap_expected to ensure breakpoints
	are re-inserted when stepping over a signal handler.
	(signal_cache_update): New function.
	(signal_stop_update): Call it.
	(signal_print_update): Likewise.
	(signal_pass_update): Likewise.
	(handle_command): Call signal_cache_update and target_pass_signals
	instead of target_notice_signals.
	(_initialize_infrun): Initialize signal_pass.

	* linux-nat.c (pass_mask): New global.
	(linux_nat_pass_signals): New function.
	(linux_nat_create_inferior): Report all signals initially.
	(linux_nat_attach): Likewise.
	(linux_nat_resume): Use pass_mask to decide whether to directly
	handle an inferior signal.
	(linux_nat_wait_1): Likewise.
	(linux_nat_add_target): Install to_pass_signals callback.

	* nto-procfs.c (notice_signals): Remove.
	(procfs_resume): Do not call notice_signals.
	(procfs_notice_signals): Remove.
	(procfs_pass_signals): New function.
	(init_procfs_ops): Install to_pass_signals callback instead of
	to_notice_signals callback.
	(_initialize_procfs): Report all signals initially.

	* procfs.c (procfs_notice_signals): Remove.
	(procfs_pass_signals): New function.
	(procfs_target): Install to_pass_signals callback instead of
	to_notice_signals callback.
	(register_gdb_signals): Remove.
	(procfs_debug_inferior): Report all signals initially.
	(procfs_init_inferior): Remove redundant register_gdb_signals call.

	* remote.c (remote_pass_signals): Add numsigs and pass_signals
	parameters; use them instead of calling signal_..._state routines.
	(remote_notice_signals): Remove.
	(remote_start_remote): Report all signals initially.
	(remote_resume): Do not call remote_pass_signals.
	(_initialize_remote): Install to_pass_signals callback instead of
	to_notice_signals callback.
@
text
@d332 4
d3696 10
d3752 2
d9667 8
d9946 32
d10367 1
d10372 2
@


1.444
log
@2011-04-26  Michael Walle  <michael@@walle.cc>

	* remote.c (remote_start_remote): Ack packet after sending the
	interrupt sequence.
@
text
@d1599 1
a1599 1
remote_pass_signals (void)
a1603 1
      int numsigs = (int) TARGET_SIGNAL_LAST;
d1609 1
a1609 3
	  if (signal_stop_state (i) == 0
	      && signal_print_state (i) == 0
	      && signal_pass_state (i) == 1)
d1617 1
a1617 3
	  if (signal_stop_state (i) == 0
	      && signal_print_state (i) == 0
	      && signal_pass_state (i) == 1)
a1646 8
static void
remote_notice_signals (ptid_t ptid)
{
  /* Update the remote on signals to silently pass, if they've
     changed.  */
  remote_pass_signals ();
}

d3368 2
a3369 4
      /* Update the remote on signals to silently pass, or more
	 importantly, which to not ignore, in case a previous session
	 had set some different set of signals to be ignored.  */
      remote_pass_signals ();
a4536 3
  /* Update the inferior on signals to silently pass, if they've changed.  */
  remote_pass_signals ();

d10278 1
a10278 1
  remote_ops.to_notice_signals = remote_notice_signals;
@


1.443
log
@2011-04-20  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* regcache.c: Include remote.h.
	(enum regcache_dump_what) <regcache_dump_remote>: New enum value.
	(regcache_dump): Handle regcache_dump_remote.
	(maintenance_print_remote_registers): New function.
	(_initialize_regcache): Install "maint print remote-registers"
	command.
	* remote.c (map_regcache_remote_table): New function, factored out
	from ...
	(init_remote_state): ... here.
	(remote_register_number_and_offset): New.
	* remote.h (remote_register_number_and_offset): Declare.

	gdb/doc/
	* gdb.texinfo (Maintenance Commands): Document `maint print
	remote-registers'.
@
text
@d3165 3
a3170 3
  if (interrupt_on_connect)
    send_interrupt_sequence ();

@


1.442
log
@	* cli/cli-interp.c (struct captured_execute_command_args):
	Remove.
	(do_captured_execute_command): Remove.
	(safe_execute_command): Use TRY_CATCH.
	* cli/cli-script.c (struct wrapped_read_command_file_args):
	Remove.
	(wrapped_read_command_file): Remove.
	(script_from_file): Use TRY_CATCH.
	* exceptions.c (catch_exception): Remove.
	* exceptions.h (catch_exception): Remove.
	(deprecated_throw_reason): Update comment.
	* mi/mi-main.c (captured_mi_execute_command): Change 'data'
	argument to 'context'.
	(mi_execute_command): Use TRY_CATCH.
	* remote.c (struct start_remote_args): Remove.
	(remote_start_remote): Update; change arguments.
	(remote_open_1): Use TRY_CATCH.
@
text
@d538 2
a539 2
static void *
init_remote_state (struct gdbarch *gdbarch)
a541 2
  struct remote_state *rs = get_remote_state_raw ();
  struct remote_arch_state *rsa;
a543 7
  rsa = GDBARCH_OBSTACK_ZALLOC (gdbarch, struct remote_arch_state);

  /* Use the architecture to build a regnum<->pnum table, which will be
     1:1 unless a feature set specifies otherwise.  */
  rsa->regs = GDBARCH_OBSTACK_CALLOC (gdbarch,
				      gdbarch_num_regs (gdbarch),
				      struct packet_reg);
d546 1
a546 1
      struct packet_reg *r = &rsa->regs[regnum];
d562 1
a562 1
			  * sizeof (struct packet_reg *));
d566 2
a567 2
    if (rsa->regs[regnum].pnum != -1)
      remote_regs[num_remote_regs++] = &rsa->regs[regnum];
d579 46
d627 1
a627 1
  rsa->sizeof_g_packet = offset;
@


1.441
log
@	ARI fixes: Add missing internationalization markups throughout
	C source files.
	* darwin-nat-info.c: Ditto.
	* record.c: Ditto.
	* remote.c: Ditto.
	* mi/mi-main.c: Ditto.
@
text
@a3099 13
/* Stub for catch_exception.  */

struct start_remote_args
{
  int from_tty;

  /* The current target.  */
  struct target_ops *target;

  /* Non-zero if this is an extended-remote target.  */
  int extended_p;
};

d3120 1
a3120 1
remote_start_remote (struct ui_out *uiout, void *opaque)
a3121 1
  struct start_remote_args *args = opaque;
d3168 1
a3168 1
  if (args->extended_p)
d3186 1
a3186 1
    solib_add (NULL, args->from_tty, args->target, auto_solib_add);
d3204 1
a3204 1
      remote_threads_info (args->target);
d3225 1
a3225 1
	  if (!args->extended_p)
d3265 1
a3265 1
      if (remote_read_description_p (args->target)
d3278 1
a3278 1
      start_remote (args->from_tty); /* Initialize gdb process mechanisms.  */
d3320 1
a3320 1
	  if (!args->extended_p)
d4049 1
a4049 2
    struct gdb_exception ex;
    struct start_remote_args args;
d4051 4
a4054 5
    args.from_tty = from_tty;
    args.target = target;
    args.extended_p = extended_p;

    ex = catch_exception (uiout, remote_start_remote, &args, RETURN_MASK_ALL);
@


1.441.2.1
log
@2011-04-26  Michael Walle  <michael@@walle.cc>

	* remote.c (remote_start_remote): Ack packet after sending the
	interrupt sequence.
@
text
@d3142 3
a3147 3
  /* Ack any packet which the remote side has already sent.  */
  serial_write (remote_desc, "+", 1);

@


1.441.2.2
log
@2011-06-15  Hui Zhu  <teawater@@gmail.com>

	* remote.c (remote_trace_set_readonly_regions): Add a check for
	target_buf_size.
@
text
@a9924 1
  int offset = 0;
a9932 1
      int sec_length;
d9944 2
a9945 9
      sec_length = 1 + strlen (tmp1) + 1 + strlen (tmp2);
      if (offset + sec_length + 1 > target_buf_size)
	{
	  warning (_("\
Too many sections for read-only sections definition packet."));
	  break;
	}
      sprintf (target_buf + offset, ":%s,%s", tmp1, tmp2);
      offset += sec_length;
@


1.441.2.3
log
@2011-06-16  Hui Zhu  <teawater@@gmail.com>

	* remote.c (remote_trace_set_readonly_regions): Add check for
	remote_protocol_packets[PACKET_qXfer_traceframe_info].support before
	output warning.
@
text
@d9949 1
a9949 3
	  if (remote_protocol_packets[PACKET_qXfer_traceframe_info].support
	      != PACKET_ENABLE)
	    warning (_("\
@


1.441.2.4
log
@gdb/
	Work around kgdb.
	* remote.c (remote_get_trace_status): New variable ex.  Put
	remote_get_noisy_reply into TRY_CATCH.  Call exception_fprintf for it.
@
text
@a9981 1
  volatile struct gdb_exception ex;
d9986 1
a9986 10

  TRY_CATCH (ex, RETURN_MASK_ERROR)
    {
      p = remote_get_noisy_reply (&target_buf, &target_buf_size);
    }
  if (ex.reason < 0)
    {
      exception_fprintf (gdb_stderr, ex, "qTStatus: ");
      return -1;
    }
@


1.441.2.5
log
@2011-07-15  Hui Zhu  <teawater@@gmail.com>

	* remote.c (remote_get_trace_status): Initialize p.
@
text
@d9979 1
a9979 2
  /* Initialize it just to avoid a GCC false warning.  */
  char *p = NULL;
@


1.440
log
@	Fix ARI warnings about new lines at the end of messages, which
	are unneeded as there is a new line added at the end of the message
	automatically.
	* darwin-nat.c (darwin_stop_inferior): Ditto.
	* dec-thread.c (dec_thread_get_ada_task_ptid): Ditto.
	* dfp.c (decimal_to_number): Ditto.
	* exec.c (print_section_info): Ditto.
	* i386-darwin-nat.c (darwin_set_sstep): Ditto.
	* osdata.c (get_osdata): Ditto.
	* record.c (bfdcore_write): Ditto.
	* remote-mips.c (mips_readchar): Ditto.
	* remote.c (read_ptid): Ditto.
	* ser-mingw.c (ser_windows_raw): Ditto.
	* tracepoint.c (add_local_symbols): Ditto.
	* windows-nat.c (fake_create_process): Ditto.
@
text
@d3540 1
a3540 1
    warning ("Remote refused setting permissions with: %s", rs->buf);
d4552 1
a4552 1
	warning (" - Can't pass signal %d to target in reverse: ignored.\n",
@


1.439
log
@	Fix ARI warning about functions without parameters that do not
	use (void).
	* breakpoint.c (all_tracepoints): Replace () by (void).
	* f-exp.y (match_string_literal): Ditto.
	(yylex): Ditto.
	* m2-exp.y (yylex): Ditto.
	* mep-tdep.c (current_me_module): Ditto.
	(current_options): Ditto.
	(current_cop_data_bus_width): Ditto.
	(current_cr_names): Ditto.
	(current_cr_is_float): Ditto.
	(current_ccr_names): Ditto.
	* objc-exp.y (yylex): Ditto.
	* p-exp.y (yylex): Ditto.
	* remote.c (send_interrupt_sequence): Ditto.
	* tracepoint.c (current_trace_status): Ditto.
	* python/py-evts.c (gdbpy_initialize_py_events): Ditto.
	* python/py-prettyprint.c (push_dummy_python_frame): Ditto.
@
text
@d1879 1
a1879 1
	error (_("invalid remote ptid: %s\n"), p);
@


1.438
log
@gdb/
2011-03-08  Pedro Alves  <pedro@@codesourcery.com>

	* remote.c (remote_check_symbols): Skip if the target has no
	execution.

gdb/testsuite/
2011-03-08  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* gdb.server/ext-run.exp
	(load new file without any gdbserver inferior): New test.
@
text
@d3115 1
a3115 1
send_interrupt_sequence ()
@


1.437
log
@2011-03-04  Michael Snyder  <msnyder@@vmware.com>

	* remote.c (putpkt_binary): Document that case stmt falls through.
@
text
@d3438 8
d3449 2
a3450 1
  /* Make sure the remote is pointing at the right process.  */
@


1.436
log
@2011-02-28  Michael Snyder  <msnyder@@vmware.com>

	* remote.c (remote_get_noisy_reply): Discard unused value.
	(remote_vcont_resume): Ditto.
	(remote_stop_ns): Ditto.
@
text
@d6851 1
@


1.435
log
@	* remote.c (remote_close): Reset INFERIOR_PTID to NULL_PTID
	before calling discard_all_inferiors.
@
text
@d458 1
a458 1
	  pp = unpack_varlen_hex (p, &ul);
d4467 1
a4467 1
      p = append_resumption (p, endp, minus_one_ptid, step, siggnal);
d4482 1
a4482 1
      p = append_resumption (p, endp, ptid, /*step=*/ 0, TARGET_SIGNAL_0);
d4487 1
a4487 1
      p = append_resumption (p, endp, ptid, step, siggnal);
d4714 1
a4714 1
      p = write_ptid (p, endp, nptid);
@


1.434
log
@	gdb/
	* target.c (target_read_live_memory): New function.
	(memory_xfer_live_readonly_partial): New.
	(memory_xfer_partial): If reading from a traceframe, fallback to
	reading unavailable read-only memory from read-only regions of
	live target memory.
	* tracepoint.c (disconnect_tracing): Adjust.
	(set_current_traceframe): New, factored out from
	set_traceframe_number.
	(set_traceframe_number): Reimplement to only change the traceframe
	number on the GDB side.
	(do_restore_current_traceframe_cleanup): Adjust.
	(make_cleanup_restore_traceframe_number): New.
	(cur_traceframe_number): New global.
	(tfile_open): Set cur_traceframe_number to no traceframe.
	(set_tfile_traceframe): New function.
	(tfile_trace_find): If looking up a traceframe using any method
	other than by number, make sure the current tfile traceframe
	matches gdb's current traceframe.  Update the current tfile
	traceframe if the lookup succeeded.
	(tfile_fetch_registers, tfile_xfer_partial)
	(tfile_get_trace_state_variable_value): Make sure the remote
	traceframe matches gdb's current traceframe.
	* remote.c (remote_traceframe_number): New global.
	(remote_open_1): Set it to -1.
	(set_remote_traceframe): New function.
	(remote_fetch_registers, remote_store_registers)
	(remote_xfer_memory, remote_xfer_partial)
	(remote_get_trace_state_variable_value): Make sure the remote
	traceframe matches gdb's current traceframe.
	(remote_trace_find): If looking up a traceframe using any method
	other than by number, make sure the current remote traceframe
	matches gdb's current traceframe.  Update the current remote
	traceframe if the lookup succeeded.
	* infrun.c (fetch_inferior_event): Adjust.
	* tracepoint.h (set_current_traceframe): Declare.
	(get_traceframe_number, set_traceframe_number): Add describing
	comments.
@
text
@d2911 4
a2914 1
     of all the inferiors and their threads we were controlling.  */
a2915 1
  inferior_ptid = null_ptid;
@


1.433
log
@	gdb/
	* target.h (struct traceframe_info): Forward declare.
	(enum target_object): Add TARGET_OBJECT_TRACEFRAME_INFO.
	(struct target_ops) <to_traceframe_info>: New field.
	(target_traceframe_info): New.
	* target.c (update_current_target): Inherit and default
	to_traceframe_info.
	* remote.c (PACKET_qXfer_traceframe_info): New.
	(remote_protocol_features): Register qXfer:traceframe-info:read.
	(remote_xfer_partial): Handle TARGET_OBJECT_TRACEFRAME_INFO.
	(remote_traceframe_info): New.
	(init_remote_ops): Install it.
	(_initialize_remote): Install "set/show remote traceframe-info"
	commands.
	* tracepoint.h (parse_traceframe_info): Declare.
	* tracepoint.c (struct mem_range): New.
	(mem_range_s): New typedef.
	(struct traceframe_info): New.
	(traceframe_info): New global.
	(free_traceframe_info): New function.
	(clear_traceframe_info): New function.
	(start_tracing, tfind_1, set_traceframe_number): Clear traceframe
	info.
	(build_traceframe_info): New function.
	(tfile_traceframe_info): New function.
	(init_tfile_ops): Install tfile_traceframe_info.
	(traceframe_info_start_memory, free_result): New functions.
	(memory_attributes, traceframe_info_elements): New globals.
	(parse_traceframe_info, get_traceframe_info): New functions.
	* features/traceframe-info.dtd: New file.
	* Makefile.in (XMLFILES): Add traceframe-info.dtd.

	gdb/gdbserver/
	* server.c (handle_qxfer_traceframe_info): New.
	(qxfer_packets): Register "traceframe-info".
	(handle_query): Report support for qXfer:traceframe-info:read+.
	* tracepoint.c (match_blocktype): New.
	(traceframe_find_block_type): Rename to ...
	(traceframe_walk_blocks): ... this.  Add callback filter argument,
	and use it.
	(traceframe_find_block_type): New, reimplemented on top of
	traceframe_walk_blocks.
	(build_traceframe_info_xml): New.
	(traceframe_read_info): New.
	* server.h (traceframe_read_info): Declare.

	gdb/doc/
	* gdb.texinfo (Remote Configuration): Mention set/show remote
	traceframe-info.
	(Tools/Packages Optional for Building GDB): Mention that expat is
	used for traceframe info.
	(Remote Protocol) <Menu>: Add "Traceframe Info Format".
	(General Query Packets) <qSupported>: Describe the
	qXfer:traceframe-info:read feature.
	(qXfer::read): Describe qXfer:traceframe-info:read.
	(Traceframe Info Format): New section.
@
text
@d1356 4
d4009 1
d5778 22
d5807 1
d5965 1
d6534 1
d8117 1
d10006 6
d10049 2
d10071 2
d10083 2
@


1.432
log
@	* xml-support.c (xml_find_attribute): New.
	(xinclude_start_include): Use it.
	* xml-support.h (xml_find_attribute): Declare.
	* memory-map.c (memory_map_start_memory)
	(memory_map_start_property): Use xml_find_attribute.
	* osdata.c (osdata_start_osdata, osdata_start_column): Use
	xml_find_attribute.
	* remote.c (start_thread): Use xml_find_attribute.
	* solib-target.c (library_list_start_segment)
	(library_list_start_section, library_list_start_library)
	(library_list_start_list): Use xml_find_attribute.
	* xml-tdesc.c (tdesc_start_target, tdesc_start_feature)
	(tdesc_start_union, tdesc_start_struct, tdesc_start_flags)
	(tdesc_start_field): Use xml_find_attribute.
@
text
@d1208 1
d3687 2
d8217 5
d10168 20
d10279 1
d10702 4
@


1.431
log
@	Stop remote_read_bytes from handling partial reads itself.

	* remote-fileio.c: Include target.h.
	(remote_fileio_write_bytes): Delete.
	(remote_fileio_func_open, remote_fileio_func_write)
	(remote_fileio_func_rename, remote_fileio_func_unlink): Use
	target_read_memory.
	(remote_fileio_func_stat): Use target_read_memory and
	target_write_memory.
	(remote_fileio_func_gettimeofday): Use target_write_memory.
	(remote_fileio_func_system): Use target_read_memory.
	* remote.c (remote_write_bytes): Make it static.
	(remote_read_bytes): Don't handle partial reads here.
	* remote.h (remote_read_bytes): Delete declaration.
@
text
@d2508 1
d2510 1
a2510 1
  id = VEC_index (gdb_xml_value_s, attributes, 0)->value;
d2513 3
a2515 3
  if (VEC_length (gdb_xml_value_s, attributes) > 1)
    item.core = *(ULONGEST *) VEC_index (gdb_xml_value_s,
					 attributes, 1)->value;
@


1.430
log
@	Simplify XML parsing a bit.

	* xml-support.h (gdb_xml_parse_quick): Declare.
	* xml-support.c (gdb_xml_create_parser_and_cleanup_1): Renamed
	from gdb_xml_create_parser_and_cleanup, and added `old_chain'
	parameter.
	(gdb_xml_create_parser_and_cleanup): Reimplement on top of
	gdb_xml_create_parser_and_cleanup_1.
	(gdb_xml_parse_quick): New.
	* memory-map.c (parse_memory_map): Use gdb_xml_parse_quick.
	* osdata.c (osdata_parse): Ditto.
	* remote.c (remote_threads_info): Ditto.
	* solib-target.c (solib_target_parse_libraries): Ditto.
	* xml-syscall.c (syscall_parse_xml): Ditto.
	* xml-tdesc.c (tdesc_parse_xml): Ditto.
@
text
@d6359 1
a6359 1
int
d6394 1
a6394 8
/* NOTE: cagney/1999-10-18: This function (and its siblings in other
   remote targets) shouldn't attempt to read the entire buffer.
   Instead it should read a single packet worth of data and then
   return the byte size of that packet to the caller.  The caller (its
   caller and its callers caller ;-) already contains code for
   handling partial reads.  */

int
d6399 3
a6401 1
  int origlen;
d6410 2
a6411 8
  origlen = len;
  while (len > 0)
    {
      char *p;
      int todo;
      int i;

      todo = min (len, max_buf_size / 2);	/* num bytes that will fit.  */
d6413 21
a6433 39
      /* construct "m"<memaddr>","<len>" */
      /* sprintf (rs->buf, "m%lx,%x", (unsigned long) memaddr, todo); */
      memaddr = remote_address_masked (memaddr);
      p = rs->buf;
      *p++ = 'm';
      p += hexnumstr (p, (ULONGEST) memaddr);
      *p++ = ',';
      p += hexnumstr (p, (ULONGEST) todo);
      *p = '\0';

      putpkt (rs->buf);
      getpkt (&rs->buf, &rs->buf_size, 0);

      if (rs->buf[0] == 'E'
	  && isxdigit (rs->buf[1]) && isxdigit (rs->buf[2])
	  && rs->buf[3] == '\0')
	{
	  /* There is no correspondance between what the remote
	     protocol uses for errors and errno codes.  We would like
	     a cleaner way of representing errors (big enough to
	     include errno codes, bfd_error codes, and others).  But
	     for now just return EIO.  */
	  errno = EIO;
	  return 0;
	}

      /* Reply describes memory byte by byte,
         each byte encoded as two hex characters.  */

      p = rs->buf;
      if ((i = hex2bin (p, myaddr, todo)) < todo)
	{
	  /* Reply is short.  This means that we were able to read
	     only part of what we wanted to.  */
	  return i + (origlen - len);
	}
      myaddr += todo;
      memaddr += todo;
      len -= todo;
d6435 6
a6440 1
  return origlen;
@


1.429
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* arm-tdep.c: Internationalization.
	* c-lang.c: Ditto.
	* charset.c: Ditto.
	* fork-child.c: Ditto.
	* nto-procfs.c: Ditto.
	* ppc-sysv-tdep.c: Ditto.
	* procfs.c: Ditto.
	* remote-mips.c: Ditto.
	* remote.c: Ditto.
	* rs6000-nat.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* target.c: Ditto.
	* valops.c: Ditto.
	* value.c: Ditto.
	* xml-support.c: Ditto.
	* mi/mi-cmd-break.c: Ditto.
	* mi/mi-cmd-var.c: Ditto.
	* mi/mi-interp.c: Ditto.
	* mi/mi-main.c: Ditto.
@
text
@d2598 1
a2600 1
	  struct gdb_xml_parser *parser;
a2601 8
	  struct cleanup *clear_parsing_context;

	  context.items = 0;
	  /* Note: this parser cleanup is already guarded by BACK_TO
	     above.  */
	  parser = gdb_xml_create_parser_and_cleanup (_("threads"),
						      threads_elements,
						      &context);
d2603 2
a2604 1
	  gdb_xml_use_dtd (parser, "threads.dtd");
d2606 2
a2607 4
	  clear_parsing_context
	    = make_cleanup (clear_threads_parsing_context, &context);

	  if (gdb_xml_parse (parser, xml) == 0)
a2633 2

	  do_cleanups (clear_parsing_context);
@


1.428
log
@2011-01-10  Michael Snyder  <msnyder@@vmware.com>

	* nto-procfs.c: Comment cleanup, mostly periods and spaces.
	* nto-tdep.c: Ditto.
	* nto-tdep.h: Ditto.
	* objc-exp.y: Ditto.
	* objc-lang.c: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* observer.c: Ditto.
	* opencl-lang.c: Ditto.
	* osabi.c: Ditto.
	* parse.c: Ditto.
	* parser-defs.h: Ditto.
	* p-exp.y: Ditto.
	* p-lang.c: Ditto.
	* posix-hdep.c: Ditto.
	* ppcbug-rom.c: Ditto.
	* ppc-linux-nat.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* ppc-linux-tdep.h: Ditto.
	* ppcnbsd-tdep.c: Ditto.
	* ppcobsd-tdep.c: Ditto.
	* ppcobsd-tdep.h: Ditto.
	* ppc-sysv-tdep.c: Ditto.
	* ppc-tdep.h: Ditto.
	* printcmd.c: Ditto.
	* proc-abi.c: Ditto.
	* proc-flags.c: Ditto.
	* procfs.c: Ditto.
	* proc-utils.h: Ditto.
	* progspace.h: Ditto.
	* prologue-value.c: Ditto.
	* prologue-value.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* ravenscar-sparc-thread.c: Ditto.
	* ravenscar-thread.c: Ditto.
	* ravenscar-thread.h: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote.c: Ditto.
	* remote-fileio.c: Ditto.
	* remote-fileio.h: Ditto.
	* remote.h: Ditto.
	* remote-m32r-sdi.c: Ditto.
	* remote-mips.c: Ditto.
	* remote-sim.c: Ditto.
	* rs6000-aix-tdep.c: Ditto.
	* rs6000-nat.c: Ditto.
	* rs6000-tdep.c: Ditto.
@
text
@d1248 1
a1248 1
  internal_error (__FILE__, __LINE__, "Could not find config for %s",
d1269 1
a1269 1
  internal_error (__FILE__, __LINE__, "Could not find config for %s",
d3215 1
a3215 1
	error ("Remote refused setting non-stop mode with: %s", rs->buf);
d3231 1
a3231 1
	error ("Remote refused setting all-stop mode with: %s", rs->buf);
d5740 1
a5740 1
			"unexpected end of 'g' packet reply");
d5758 1
a5758 1
			    "unexpected end of 'g' packet reply");
d6225 1
a6225 1
		    "remote_write_bytes_aux: bad packet format");
d6561 1
a6561 1
    internal_error (__FILE__, __LINE__, "Too long remote packet.");
d8355 1
a8355 1
    error ("Pattern is too large to transmit to remote target.");
d8813 1
a8813 1
		      "Duplicate g packet description added for size %d",
d9752 2
a9753 1
				"Fast tracepoint not valid during download");
d10022 1
a10022 1
      error ("Unknown trace find type %d", type);
@


1.427
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d71 1
a71 1
/* temp hacks for tracepoint encoding migration */
d438 1
a438 1
      QUIT;			/* allow user to bail out with ^C */
d495 1
a495 1
	return buf;		/* here's the actual reply */
d592 1
a592 1
  /* Default maximum number of characters in a packet body. Many
d605 3
a607 3
     default, adjust the size accordingly. Remember that each byte is
     encoded as two characters. 32 is the overhead for the packet
     header / footer. NOTE: cagney/1999-10-26: I suspect that 8
d771 1
a771 1
   leading zeros, the entire address would be sent. This variable
d867 1
a867 1
/* Update the size of a read/write packet. If they user wants
d980 1
a980 1
   supports. Allows the user to specify the use of the packet as well
d1543 1
a1543 2
   3) Successful execution of set thread
 */
d1730 1
a1730 1
   libstub protocol encoding, and remote.c. it is not particularly
d1734 1
a1734 2
   Plan to fix this.
 */
d1756 1
a1756 2
   get_thread_info. FIXME: Make these TAG names more thread specific.
 */
d2083 1
a2083 1
   ints. This is due to a mismatch of specifications.  We would like
d4024 1
a4024 1
	 requests. Unfortunately remote_start_remote() eventually calls
d4026 1
a4026 1
	 around this. Eventually a mechanism that allows
d4569 2
a4570 2
     with the event loop. NOTE: this is the one place where all the
     execution commands end up. We could alternatively do this in each
d4627 1
a4627 1
/* Perform interrupt, if the first attempt did not succeed. Just give
d4650 3
a4652 3
/* The command line interface's stop routine. This function is installed
   as a signal handler for SIGINT. The first time a user requests a
   stop, we call remote_stop to send a break or ^C. If there is no
d4746 1
a4746 1
/* This is the generic stop called via the target vector. When a target
d5962 1
a5962 1
	 any way to read the register, either... */
d6139 1
a6139 1
   clean. In cases like this, the user should clear "remote
d6237 2
a6238 2
     packet header and footer overhead: "$M<memaddr>,<len>:...#nn".
     */
d6241 1
a6241 1
    /* The comma won't be used. */
d6433 1
a6433 1
      todo = min (len, max_buf_size / 2);	/* num bytes that will fit */
d7943 1
a7943 1
	continue;		/* skip non-loadable section */
d7947 1
a7947 1
	continue;		/* skip zero-length section */
d7951 1
a7951 1
	continue;		/* not the section selected by user */
d7953 1
a7953 1
      matched = 1;		/* do this section */
d8148 1
a8148 1
  /* Handle SPU memory using qxfer packets. */
d8256 1
a8256 1
  /* Minimum outbuf size is get_remote_packet_size (). If LEN is not
d8310 2
a8311 2
  /* number of packet bytes used to encode the pattern,
     this could be more than PATTERN_LEN due to escape characters */
d8313 1
a8313 1
  /* amount of pattern that was encodable in the packet */
d9674 1
a9674 1
      QUIT;	/* allow user to bail out with ^C */
d9689 1
a9689 1
	  QUIT;	/* allow user to bail out with ^C */
d9814 1
a9814 1
	      QUIT;	/* allow user to bail out with ^C */
d9831 1
a9831 1
	      QUIT;	/* allow user to bail out with ^C */
d9917 1
a9917 1
      /* (s->flags & SEC_CODE)     == 0 || */
d9951 1
a9951 1
  /* FIXME we need to get register block size some other way */
@


1.426
log
@run copyright.sh for 2011.
@
text
@d1045 2
a1046 1
      printf_filtered (_("Support for the `%s' packet is auto-detected, currently %s.\n"),
d1071 2
a1072 1
  show_doc = xstrprintf ("Show current use of remote protocol `%s' (%s) packet",
d1077 2
a1078 1
				&config->detect, set_doc, show_doc, NULL, /* help_doc */
d2351 2
a2352 1
  if ((((result_limit + 1) * BUF_THREAD_ID_SIZE) + 10) >= get_remote_packet_size ())
d2516 2
a2517 1
    item.core = *(ULONGEST *) VEC_index (gdb_xml_value_s, attributes, 1)->value;
d2624 3
a2626 1
	      for (i = 0; VEC_iterate (thread_item_t, context.items, i, item); ++i)
d3065 2
a3066 1
	error (_("Can not handle qOffsets TextSeg response with this symbol file"));
d3079 4
a3082 3
      /* This is a temporary kludge to force data and bss to use the same offsets
	 because that's what nlmconv does now.  The real solution requires changes
	 to the stub and remote.c that I don't have time to do right now.  */
d3211 2
a3212 1
	error (_("Non-stop mode requested, but remote does not support non-stop"));
d3501 3
a3503 3
      warning (_("\
The remote protocol may be unreliable over UDP.\n\
Some events may be lost, rendering further debugging impossible."));
d3872 2
a3873 1
	      warning (_("unrecognized item \"%s\" in \"qSupported\" response"), p);
d3914 2
a3915 1
remote_open_1 (char *name, int from_tty, struct target_ops *target, int extended_p)
d4183 2
a4184 1
  if (packet_ok (rs->buf, &remote_protocol_packets[PACKET_vAttach]) == PACKET_OK)
d6175 2
a6176 1
				  "binary downloading NOT suppported by target\n");
d6685 2
a6686 1
      perror_with_name (_("Remote communication error.  Target disconnected."));
d7063 2
a7064 2
				    "\
Bad checksum, sentsum=0x%x, csum=0x%x, buf=%s\n",
d7429 4
a7432 3
	      /* Assume that the target has been restarted.  Set inferior_ptid
		 so that bits of core GDB realizes there's something here, e.g.,
		 so that the user can say "kill" again.	 */
d8172 2
a8173 1
	return remote_write_qxfer (ops, "siginfo", annex, writebuf, offset, len,
d8181 2
a8182 1
	return remote_read_qxfer (ops, "statictrace", annex, readbuf, offset, len,
d8408 2
a8409 1
  if ((strlen (rs->buf) + strlen (command) * 2 + 8/*misc*/) > get_remote_packet_size ())
d8624 3
a8626 2
  add_com ("tlist", class_obscure, threadlist_test_cmd, _("\
Fetch and print the remote list of thread identifiers, one pkt only"));
d8708 2
a8709 1
      result = packet_ok (rs->buf, &remote_protocol_packets[PACKET_qGetTLSAddr]);
d9402 2
a9403 1
	  bytes = fread (buffer + bytes_in_buffer, 1, io_size - bytes_in_buffer,
d9425 2
a9426 1
      retcode = remote_hostio_pwrite (fd, buffer, bytes, offset, &remote_errno);
d9728 2
a9729 1
      (void) make_cleanup (free_actions_list_cleanup_wrapper, stepping_actions);
d9761 2
a9762 1
	    warning (_("Target does not support fast tracepoints, downloading %d as regular tracepoint"), t->number);
d9801 2
a9802 1
	    warning (_("Target does not support conditional tracepoints, ignoring tp %d cond"), t->number);
d9848 2
a9849 1
      if (remote_protocol_packets[PACKET_TracepointSource].support == PACKET_ENABLE)
d10245 1
a10245 1
  remote_ops.to_has_thread_control = tc_schedlock;	/* can lock scheduler */
d10263 2
a10264 1
  remote_ops.to_download_trace_state_variable = remote_download_trace_state_variable;
d10270 2
a10271 1
  remote_ops.to_get_trace_state_variable_value = remote_get_trace_state_variable_value;
d10274 2
a10275 1
  remote_ops.to_upload_trace_state_variables = remote_upload_trace_state_variables;
d10569 2
a10570 1
			interrupt_sequence_modes, &interrupt_sequence_mode, _("\
d10624 3
a10626 1
			    NULL, NULL, /* FIXME: i18n: The maximum number of target hardware watchpoints is %s.  */
d10633 3
a10635 1
			    NULL, NULL, /* FIXME: i18n: The maximum number of target hardware breakpoints is %s.  */
d10760 2
a10761 1
			 "ConditionalTracepoints", "conditional-tracepoints", 0);
d10788 3
a10790 1
				show_remote_protocol_Z_packet_cmd, /* FIXME: i18n: Use of remote protocol `Z' packets is %s.  */
@


1.425
log
@2010-11-04  Hui Zhu  <teawater@@gmail.com>

	* tracepoint.c (remote_trace_set_readonly_regions): Change lma to vma.
@
text
@d5 1
a5 1
   2010 Free Software Foundation, Inc.
@


1.424
log
@gdb/
	Revert:
	2010-10-17  Jan Kratochvil  <jan.kratochvil@@redhat.com>
		    Pedro Alves  <pedro@@codesourcery.com>
	* gdbthread.h (currently_stepping): New declaration.
	* infrun.c (currently_stepping): Remove the forward declaration.
	(currently_stepping): Make it global.
	* linux-nat.c (resume_callback) <lp->stopped && lp->status == 0>: New
	variables tp and step, initialized them.  Pass STEP to to_resume.
	Print also possibly "PTRACE_SINGLESTEP" if STEP.  Initialize LP->STEP.
	* remote.c (currently_stepping_callback): New.
	(remote_vcont_resume)
	<ptid_equal (ptid, minus_one_ptid) || ptid_is_pid (ptid)>:
	New variable tp.  Call currently_stepping_callback and step such
	thread.

gdb/testsuite/
	Revert:
	2010-10-17  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	* gdb.threads/sigstep-threads.exp: New file.
	* gdb.threads/sigstep-threads.c: New file.
@
text
@d9881 1
a9881 1
  bfd_vma lma;
d9898 1
a9898 1
      lma = s->lma;
d9900 2
a9901 2
      sprintf_vma (tmp1, lma);
      sprintf_vma (tmp2, lma + size);
@


1.423
log
@	* remote.c (remote_get_threadlist): If we got empty
	response, bail out immediately, and don't emit any
	warnings.
@
text
@a4418 6
static int
currently_stepping_callback (struct thread_info *tp, void *data)
{
  return currently_stepping (tp);
}

a4460 2
      struct thread_info *tp;

a4470 6
      tp = iterate_over_threads (currently_stepping_callback, NULL);
      if (tp && !ptid_equal (tp->ptid, inferior_ptid))
	{
	  p = append_resumption (p, endp, tp->ptid, 1, TARGET_SIGNAL_0);
	}

@


1.422
log
@gdb/
	* gdbthread.h (currently_stepping): New declaration.
	* infrun.c (currently_stepping): Remove the forward declaration.
	(currently_stepping): Make it global.
	* linux-nat.c (resume_callback) <lp->stopped && lp->status == 0>: New
	variables tp and step, initialized them.  Pass STEP to to_resume.
	Print also possibly "PTRACE_SINGLESTEP" if STEP.  Initialize LP->STEP.
	* remote.c (currently_stepping_callback): New.
	(remote_vcont_resume)
	<ptid_equal (ptid, minus_one_ptid) || ptid_is_pid (ptid)>:
	New variable tp.  Call currently_stepping_callback and step such
	thread.

gdb/testsuite/
	* gdb.threads/sigstep-threads.exp: New file.
	* gdb.threads/sigstep-threads.c: New file.
@
text
@d2356 1
a2356 1
    *result_count = 0;
@


1.421
log
@2010-07-28  Oleg Nesterov  <oleg@@redhat.com>

	* remote.c (readchar): Call pop_target in case of SERIAL_ERROR.
@
text
@d4419 6
d4467 2
d4479 6
@


1.420
log
@Add missing gettext markup.

gdb/ChangeLog:

        * remote.c (remote_download_tracepoint): Add missing gettext markup.
        * tracepoint.c (parse_static_tracepoint_marker_definition): Likewise.
@
text
@d6670 2
a6671 1
      perror_with_name (_("Remote communication error"));
@


1.419
log
@2010-07-07  Sergio Durigan Junior  <sergiodj@@linux.vnet.ibm.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	Support for hw accelerated condition watchpoints in booke powerpc.

	* breakpoint.c (fetch_watchpoint_value): Rename to fetch_subexp_value
	and move to eval.c.  Change callers.
	(insert_bp_location): Pass watchpoint condition in
	target_insert_watchpoint.
	(remove_breakpoint_1) Pass watchpoint condition in
	target_remove_watchpoint.
	(watchpoint_locations_match): Call
	target_can_accel_watchpoint_condition.
	* eval.c: Include wrapper.h.
	(fetch_subexp_value): Moved from breakpoint.c.
	* ppc-linux-nat.c (ppc_linux_region_ok_for_hw_watchpoint):
	Formatting fix.
	(can_use_watchpoint_cond_accel): New function.
	(calculate_dvc): Likewise.
	(num_memory_accesses): Likewise.
	(check_condition): Likewise.
	(ppc_linux_can_accel_watchpoint_condition): Likewise
	(ppc_linux_insert_watchpoint): Call can_use_watchpoint_cond_accel,
	check_condition and calculate_dvc.
	(ppc_linux_remove_watchpoint): Likewise.
	(_initialize_ppc_linux_nat): Set to_can_accel_watchpoint_condition to
	ppc_linux_can_accel_watchpoint_condition
	* target.c (debug_to_insert_watchpoint): Add argument for watchpoint
	condition.
	(debug_to_remove_watchpoint): Likewise.
	(debug_to_can_accel_watchpoint_condition): New function.
	(update_current_target): Set to_can_accel_watchpoint_condition.
	(setup_target_debug): Set to_can_accel_watchpoint_condition.
	* target.h: Add opaque declaration for struct expression.
	(struct target_ops) <to_insert_watchpoint>,
	<to_remove_watchpoint>: Add new arguments to pass the watchpoint
	<to_can_accel_watchpoint_condition>: New member.
	condition.  Update all callers and implementations.
	(target_can_accel_watchpoint_condition): New macro.
	* value.c (free_value_chain): New function.
	* value.h (fetch_subexp_value): New prototype.
	(free_value_chain): Likewise.
@
text
@d9749 1
a9749 1
		error ("Static tracepoint not valid during download");
@


1.419.2.1
log
@2010-07-28  Oleg Nesterov  <oleg@@redhat.com>

	* remote.c (readchar): Call pop_target in case of SERIAL_ERROR.
@
text
@d6670 1
a6670 2
      pop_target ();
      perror_with_name (_("Remote communication error.  Target disconnected."));
@


1.419.2.2
log
@2010-11-04  Hui Zhu  <teawater@@gmail.com>

	* tracepoint.c (remote_trace_set_readonly_regions): Change lma to vma.
@
text
@d9881 1
a9881 1
  bfd_vma vma;
d9898 1
a9898 1
      vma = bfd_get_section_vma (,s);
d9900 2
a9901 2
      sprintf_vma (tmp1, vma);
      sprintf_vma (tmp2, vma + size);
@


1.419.2.3
log
@gdb/
2011-03-08  Pedro Alves  <pedro@@codesourcery.com>

	* remote.c (remote_check_symbols): Skip if the target has no
	execution.

gdb/testsuite/
2011-03-08  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* gdb.server/ext-run.exp
	(load new file without any gdbserver inferior): New test.
@
text
@a3433 8
  /* The remote side has no concept of inferiors that aren't running
     yet, it only knows about running processes.  If we're connected
     but our current inferior is not running, we should not invite the
     remote target to request symbol lookups related to its
     (unrelated) current process.  */
  if (!target_has_execution)
    return;

d3437 1
a3437 2
  /* Make sure the remote is pointing at the right process.  Note
     there's no way to select "no process".  */
@


1.418
log
@	Static tracepoints support, and UST integration.

	gdb/gdbserver/
	* configure.ac: Handle --with-ust.  substitute ustlibs and ustinc.
	* mem-break.c (uninsert_all_breakpoints)
	(reinsert_all_breakpoints): New.
	* mem-break.h (reinsert_all_breakpoints, uninsert_all_breakpoints):
	* tracepoint.c (ust_loaded, helper_thread_id, cmd_buf): New.
	(gdb_agent_ust_loaded, helper_thread_id)
	(gdb_agent_helper_thread_id): New macros.
	(struct ipa_sym_addresses): Add addr_ust_loaded,
	addr_helper_thread_id, addr_cmd_buf.
	(symbol_list): Add ust_loaded, helper_thread_id, cmd_buf.
	(in_process_agent_loaded_ust): New.
	(write_e_ust_not_loaded): New.
	(maybe_write_ipa_ust_not_loaded): New.
	(struct collect_static_trace_data_action): New.
	(enum tracepoint_type) <static_tracepoint>: New.
	(struct tracepoint) <handle>: Mention static tracepoints.
	(struct static_tracepoint_ctx): New.
	(CMD_BUF_SIZE): New.
	(add_tracepoint_action): Handle static tracepoint actions.
	(unprobe_marker_at): New.
	(clear_installed_tracepoints): Handle static tracepoints.
	(cmd_qtdp): Handle static tracepoints.
	(probe_marker_at): New.
	(cmd_qtstart): Handle static tracepoints.
	(response_tracepoint): Handle static tracepoints.
	(cmd_qtfstm, cmd_qtsstm, cmd_qtstmat): New.
	(handle_tracepoint_query): Handle qTfSTM, qTsSTM and qTSTMat.
	(get_context_regcache): Handle static tracepoints.
	(do_action_at_tracepoint): Handle static tracepoint actions.
	(traceframe_find_block_type): Handle static trace data blocks.
	(traceframe_read_sdata): New.
	(download_tracepoints): Download static tracepoint actions.
	[HAVE_UST] Include ust/ust.h, dlfcn.h, sys/socket.h, and sys/un.h.
	(GDB_PROBE_NAME): New.
	(ust_ops): New.
	(GET_UST_SYM): New.
	(USTF): New.
	(dlsym_ust): New.
	(ust_marker_to_static_tracepoint): New.
	(gdb_probe): New.
	(collect_ust_data_at_tracepoint): New.
	(gdb_ust_probe): New.
	(UNIX_PATH_MAX, SOCK_DIR): New.
	(gdb_ust_connect_sync_socket): New.
	(resume_thread, stop_thread): New.
	(run_inferior_command): New.
	(init_named_socket): New.
	(gdb_ust_socket_init): New.
	(cstr_to_hexstr): New.
	(next_st): New.
	(first_marker, next_marker): New.
	(response_ust_marker): New.
	(cmd_qtfstm, cmd_qtsstm): New.
	(unprobe_marker_at, probe_marker_at): New.
	(cmd_qtstmat, gdb_ust_thread): New.
	(gdb_ust_init): New.
	(initialize_tracepoint_ftlib): Call gdb_ust_init.
	* linux-amd64-ipa.c [HAVE_UST]: Include ust/processor.h
	(ST_REGENTRY): New.
	(x86_64_st_collect_regmap): New.
	(X86_64_NUM_ST_COLLECT_GREGS): New.
	(AMD64_RIP_REGNUM): New.
	(supply_static_tracepoint_registers): New.
	* linux-i386-ipa.c [HAVE_UST]: Include ust/processor.h
	(ST_REGENTRY): New.
	(i386_st_collect_regmap): New.
	(i386_NUM_ST_COLLECT_GREGS): New.
	(supply_static_tracepoint_registers): New.
	* server.c (handle_query): Handle qXfer:statictrace:read.
	<qSupported>: Report support for StaticTracepoints, and
	qXfer:statictrace:read features.
	* server.h (traceframe_read_sdata)
	(supply_static_tracepoint_registers): Declare.
	* remote-utils.c (convert_int_to_ascii, hexchars, ishex, tohex)
	(unpack_varlen_hex): Include in IPA build.
	* Makefile.in (ustlibs, ustinc): New.
	(IPA_OBJS): Add remote-utils-ipa.o.
	($(IPA_LIB)): Link -ldl and -lpthread.
	(UST_CFLAGS): New.
	(IPAGENT_CFLAGS): Add UST_CFLAGS.
	* config.in, configure: Regenerate.

	gdb/
	* NEWS: Mention new support for static tracepoints.
	(New packets): Mention qTfSTM, qTsSTM, qTSTMat and
	qXfer:statictrace:read.
	(New features in the GDB remote stub, GDBserver): Mention static
	tracepoints support using an UST based backend.
	(New commands): Mention "info static-tracepoint-markers" and
	"strace".
	* breakpoint.c (is_marker_spec): New.
	(is_tracepoint): Handle static tracepoints.
	(validate_commands_for_breakpoint): Static tracepoints can't do
	while-stepping.
	(static_tracepoints_here): New.
	(bpstat_what): Handle static tracepoints.
	(print_one_breakpoint_location, allocate_bp_location, mention):
	Ditto.
	(create_breakpoint_sal): Ditto.
	(decode_static_tracepoint_spec): New.
	(create_breakpoint): Replace `hardwareflag', and `traceflag' with
	`type_wanted'.  Adjust.  Handle static tracepoint marker
	locations.
	(break_command_1): Adjust.
	(update_static_tracepoint): New.
	(update_breakpoint_locations): Handle static tracepoints.
	(breakpoint_re_set_one): Handle static tracepoint marker
	locations.
	(disable_command, enable_command): Handle static tracepoints.
	(trace_command, ftrace_command): Adjust.
	(strace_command): New.
	(create_tracepoint_from_upload): Adjust.
	(save_breakpoints): Handle static tracepoints.
	(_initialize_breakpoint): Install the "strace" command.
	* breakpoint.h (enum bptype): New bp_static_tracepoint type.
	(struct breakpoint): New fields static_trace_marker_id and
	static_trace_marker_id_idx.
	(breakpoints_here_p): Declare.
	(create_breakpoint): Adjust.
	(static_tracepoints_here): Declare.
	* remote.c (struct remote_state) <static_tracepoints>: New field.
	(PACKET_qXfer_statictrace_read, PACKET_StaticTracepoints): New.
	(remote_static_tracepoint_marker_at): New.
	(remote_static_tracepoint_markers_by_strid): New.
	(remote_static_tracepoint_feature): New.
	(remote_disconnected_tracing_feature): Handle "StaticTracepoints".
	(remote_xfer_partial): Handle TARGET_OBJECT_STATIC_TRACE_DATA.
	(remote_supports_static_tracepoints): New.
	(remote_download_tracepoint): Download static tracepoints.
	(init_remote_ops): Install remote_static_tracepoint_marker_at and
	remote_static_tracepoint_markers_by_strid.
	(_initialize_remote): Install set|show remote static-tracepoints,
	and set|show remote read-sdata-object commands.
	* target.c (update_current_target): Inherit and default
	to_static_tracepoint_marker_at, and
	to_static_tracepoint_markers_by_strid.
	* target.h (static_tracepoint_marker): Forward declare.
	(enum target_object): New object TARGET_OBJECT_STATIC_TRACE_DATA.
	(static_tracepoint_marker_p): New typedef.
	(DEF_VEC_P(static_tracepoint_marker_p)): New VEC type.
	(struct target_ops): New fields to_static_tracepoint_marker_at and
	to_static_tracepoint_markers_by_strid.
	(target_static_tracepoint_marker_at)
	(target_static_tracepoint_markers_by_strid): New.
	* tracepoint.c: Include source.h.
	(validate_actionline): Handle $_sdata.
	(struct collection_list): New field strace_data.
	(add_static_trace_data): New.
	(clear_collection_list): Clear strace_data.
	(stringify_collection_list): Account for a possible static trace
	data collection.
	(encode_actions_1): Encode an $_sdata collection.
	(parse_tracepoint_definition): Handle static tracepoints.
	(parse_static_tracepoint_marker_definition): New.
	(release_static_tracepoint_marker): New.
	(print_one_static_tracepoint_marker): New.
	(info_static_tracepoint_markers_command): New.
	(sdata_make_value): New.
	(_initialize_tracepoint): Create the $_sdata convenience variable.
	Add the "info static-tracepoint-markers" command.
	Mention $_sdata in the "collect" command's help output.
	* tracepoint.h (struct static_tracepoint_marker): New.
	(parse_static_tracepoint_marker_definition)
	(release_static_tracepoint_marker): Declare.
	* mi/mi-cmd-break.c (mi_cmd_break_insert): Adjust.
	* python/py-breakpoint.c (bppy_new): Adjust.

	doc/
	* gdb.texinfo (Convenience Variables): Document $_sdata.
	(Commands to Set Tracepoints): Describe static tracepoints.  Add
	`Listing Static Tracepoint Markers' menu entry.  Document
	"strace".
	(Tracepoint Action Lists): Document collecting $_sdata.
	(Listing Static Tracepoint Markers): New subsection.
	(Tracepoints support in gdbserver): Mention static tracepoints.
	(remote packets, enabling and disabling): Mention
	read-sdata-object.
	(General Query Packets) <qSupported>: Document qXfer:sdata:read
	and StaticTracepoint.
	Mention qTfSTM, qTsSTM and qTSTMat as tracepoint packets.
	Document qXfer:sdata:read.
	(Tracepoint packets): Document qTfSTM, qTsSTM and qTSTMat.
@
text
@d7649 2
a7650 1
remote_insert_watchpoint (CORE_ADDR addr, int len, int type)
d7683 2
a7684 1
remote_remove_watchpoint (CORE_ADDR addr, int len, int type)
@


1.417
log
@2010-06-11  Stan Shebs  <stan@@codesourcery.com>

	Add per-operation permission flags.

	* target.h (struct target_ops): New method to_set_permissions.
	(target_set_permissions): New macro.
	(target_insert_breakpoint): Change macro to function.
	(target_remove_breakpoint): Ditto.
	(target_stop): Ditto.
	(may_write_registers): Declare.
	(may_write_memory): Declare.
	(may_insert_breakpoints): Declare.
	(may_insert_tracepoints): Declare.
	(may_insert_fast_tracepoints): Declare.
	(may_stop): Declare.
	* target.c (may_write_registers, may_write_registers_1): New globals.
	(may_write_memory, may_write_memory_1): New globals.
	(may_insert_breakpoints, may_insert_breakpoints_1): New globals.
	(may_insert_tracepoints, may_insert_tracepoints_1): New globals.
	(may_insert_fast_tracepoints, may_insert_fast_tracepoints_1): New
	globals.
	(may_stop, may_stop_1): New global.
	(target_xfer_partial): Test for write permission.
	(target_store_registers): Ditto.
	(target_insert_breakpoint): New function.
	(target_remove_breakpoint): New function.
	(target_stop): New function.
	(_initialize_targets): Add new set/show variables.
	(set_write_memory_permission): New function.
	(update_target_permissions): New function.
	(set_target_permissions): New function.
	(update_current_target): Default to_set_permissions.
	(_initialize_targets): Use new globals and setter function.
	* tracepoint.c (start_tracing): Test for permission.
	* inferior.h (update_observer_mode): Declare.
	* infrun.c (non_stop_1): Define earlier.
	(observer_mode, observer_mode_1): New globals.
	(set_observer_mode, show_observer_mode): New functions.
	(update_observer_mode): New function.
	(_initialize_infrun): Define "set observer" command.
	* remote.c (PACKET_QAllow): New optional packet.
	(remote_protocol_features): Add QAllow.
	(remote_set_permissions): New function.
	(remote_start_remote): Call it.
	(init_remote_ops): Add it to target vector.
	(_initialize_remote): Add config command for QAllow.

	* gdb.texinfo (Observer Mode): New section.
	(General Query Packets): Document QAllow.

	* gdb.base/permissions.exp: New file.
@
text
@d325 3
d1204 1
d1219 1
d2780 92
d3652 10
d3703 2
d8158 10
d9600 8
d9736 19
d10250 4
d10732 6
@


1.416
log
@2010-06-08  Michael Snyder  <msnyder@@vmware.com>

	* remote.c (remote_close): Set inferior_ptid to null_ptid.
@
text
@d215 2
d1218 1
d3053 4
d3403 30
d3604 2
d10103 1
d10579 3
@


1.415
log
@Fix ARI warning in remote.c (no trailing \n in call to error)

        * remote.c (remote_get_noisy_reply): Remove trailing "\n" in call
        to error.
@
text
@d2814 1
@


1.414
log
@	* remote.c (unpack_varlen_hex): Remove forward declaration.
	(remote_console_output): Make static, and add forward declaration.
	* remote.h: Drop FIXME comment.
	(unpack_varlen_hex): Declare.
	(remote_console_output, remote_cisco_objfile_relocate)
	(deprecated_target_resume_hook, deprecated_target_wait_loop_hook):
	Delete declarations.
	* tracepoint.c: Include "remote.h".
	(unpack_varlen_hex): Delete declaration.
@
text
@d449 1
a449 1
	    error (_("invalid qRelocInsn packet: %s\n"), buf);
@


1.413
log
@gdb/
2010-05-26  Pedro Alves  <pedro@@codesourcery.com>

	* NEWS: Mention the `qRelocInsn' feature.
	* gdbarch.sh (relocate_instruction): New.
	* amd64-tdep.c (rip_relative_offset): New.
	(append_insns): New.
	(amd64_relocate_instruction): New.
	(amd64_init_abi): Install it.
	* i386-tdep.c (append_insns): New.
	(i386_relocate_instruction): New.
	(i386_gdbarch_init): Install it.
	* remote.c (remote_get_noisy_reply): Handle qRelocInsn requests.
	* gdbarch.h, gdbarch.c: Regenerate.

gdb/doc/
2010-05-26  Pedro Alves  <pedro@@codesourcery.com>

	* gdb.texinfo (General Query Packets) <qSupported>: Describe the
	`qRelocInsn' feature.
	(Relocate instruction reply packet): New subsection
	of `Tracepoint Packets'.
	(Tracepoint Packets): Mention that packets QTDP and QTStart
	support the qRelocInsn request, and add cross reference to new
	subsection.
@
text
@d245 1
a245 1
char *unpack_varlen_hex (char *buff, ULONGEST *result);
d4671 1
a4671 1
void
@


1.412
log
@2010-05-16  Michael Snyder  <msnyder@@vmware.com>

	* remote.c: White space.
	(process_g_packet): Remove orphan braces.
@
text
@d245 2
d438 49
d3638 4
a3641 7
      if (q)
	{
	  q = reconcat (q, "qSupported:", q, (char *) NULL);
	  putpkt (q);
	}
      else
	putpkt ("qSupported");
@


1.411
log
@	* remote.c (remote_query_supported_append): Use reconcat.
	(remote_query_supported): Install a cleanup.  Use reconcat.
@
text
@d430 1
d591 1
d601 1
d605 1
d819 1
d831 1
d913 1
d973 1
d1030 1
d1233 1
d1247 1
d2664 1
d3263 1
d3432 1
d3441 1
d3451 1
d3461 1
d3471 1
d4114 1
d4632 1
d4674 1
d4732 1
d4904 1
d5004 1
d5542 22
a5563 24
  {
    int i;
    for (i = 0; i < gdbarch_num_regs (gdbarch); i++)
      {
	struct packet_reg *r = &rsa->regs[i];
	if (r->in_g_packet)
	  {
	    if (r->offset * 2 >= strlen (rs->buf))
	      /* This shouldn't happen - we adjusted in_g_packet above.  */
	      internal_error (__FILE__, __LINE__,
			      "unexpected end of 'g' packet reply");
	    else if (rs->buf[r->offset * 2] == 'x')
	      {
		gdb_assert (r->offset * 2 < strlen (rs->buf));
		/* The register isn't available, mark it as such (at
                   the same time setting the value to zero).  */
		regcache_raw_supply (regcache, r->regnum, NULL);
	      }
	    else
	      regcache_raw_supply (regcache, r->regnum,
				   regs + r->offset);
	  }
      }
  }
d5585 1
d5701 1
d5707 1
d5742 1
d5792 1
d5821 1
d5832 1
d6290 1
d6347 1
a6348 1
  va_list ap;
d6368 1
a6383 1

d6386 1
d6862 1
a6863 1

d7554 1
d7913 1
d8215 1
d8232 1
d9373 1
d9381 1
d9389 1
d9692 1
d9911 1
d10112 1
d10143 1
@


1.410
log
@	* gdbarch.sh (qsupported): Delete.
	* gdbarch.h, gdbarch.c: Regenerate.
	* remote.c (remote_query_supported): Remove use of
	gdbarch_qsupported.
@
text
@d3526 3
a3528 3
      p = concat (remote_support_xml, ",", xml, (char *) NULL);
      xfree (remote_support_xml);
      remote_support_xml = p;
d3537 1
a3537 5
    {
      char *p = concat (msg, ";", append, (char *) NULL);
      xfree (msg);
      return p;
    }
d3561 1
d3571 2
a3572 4
	  char *p = concat ("qSupported:", q, (char *) NULL);
	  xfree (q);
	  putpkt (p);
	  xfree (p);
d3577 2
@


1.409
log
@	* remote.c (clear_threads_parsing_context): New.
	(remote_threads_info): Delete unused null_cleanup.  Install a
	cleanup to clear the threads_parsing_context in case parsing
	throws.
@
text
@a3564 1
      const char *qsupported = gdbarch_qsupported (target_gdbarch);
a3567 3
      
      if (qsupported)
	q = remote_query_supported_append (q, qsupported);
@


1.408
log
@	* remote.c (remote_threads_info): Really revert previous previous
	change.
@
text
@d2485 15
d2530 1
a2530 1
	  struct cleanup *back_to = make_cleanup (null_cleanup, NULL);
d2533 2
d2541 3
d2565 1
a2565 1
		      item->extra = 0;
a2566 1
		  xfree (item->extra);
d2570 1
a2570 1
	  VEC_free (thread_item_t, context.items);
@


1.407
log
@2010-05-05  Michael Snyder  <msnyder@@vmware.com>

	* remote.c (remote_threads_info): Revert questionable part of
	the previous change.
@
text
@d2515 1
a2515 1
	  struct cleanup back_to = make_cleanup (null_cleanup, NULL);
@


1.406
log
@2010-05-05  Michael Snyder  <msnyder@@vmware.com>

	* remote.c (remote_threads_info): Delete unused variable.
	(process_stop_reply): Delete unused variable.
	(remote_get_trace_status): Delete unused variables.
@
text
@d2515 1
a2516 1
	  make_cleanup (null_cleanup, NULL);
@


1.405
log
@	ARI fix: Remove ATTRIBUTE_UNUSED throughout.
	* arm-linux-tdep.c (arm_linux_cleanup_svc): Remove
	ATTRIBUTE_UNUSED.
	(cleanup_kernel_helper_return): Likewise.
	* arm-tdep.c (copy_unmodified): Likewise.
	(copy_preload): Likewise.
	(copy_copro_load_store): Likewise.
	(cleanup_branch): Likewise.
	(copy_b_bl_blx): Likewise.
	(copy_bx_blx_reg): Likewise.
	(copy_alu_imm): Likewise.
	(copy_alu_reg): Likewise.
	(copy_alu_shifted_reg): Likewise.
	(cleanup_load): Likewise.
	(cleanup_store): Likewise.
	(cleanup_block_load_pc): Likewise.
	(cleanup_svc): Likewise.
	(copy_undef): Likewise.
	(copy_unpred): Likewise.
	* remote.c (register_remote_support_xml): Likewise.
@
text
@a2514 1
	  struct cleanup *back_to = make_cleanup (null_cleanup, NULL);
d2516 1
a5081 1
  struct thread_info *info;
d9639 1
a9639 2
  char *p, *p1, *p_temp;
  ULONGEST val;
@


1.404
log
@* remote.c (register_remote_support_xml)
(remote_query_supported_append, remote_query_supported): Add cast
to NULL used as sentinel.
* tracepoint.c (tvariables_info_1): Likewise.
* utils.c (add_internal_problem_command): Likewise.
@
text
@d3485 1
a3485 1
register_remote_support_xml (const char *xml ATTRIBUTE_UNUSED)
@


1.403
log
@	* remote.c (remote_notice_signals): New.
	(remote_start_remote): In non-stop mode, update the remote end on
	which signals it can silently pass.
	(init_remote_ops): Install remote_notice_signals.
@
text
@d3489 1
a3489 1
    remote_support_xml = concat ("xmlRegisters=", xml, NULL);
d3507 1
a3507 1
      p = concat (remote_support_xml, ",", xml, NULL);
d3519 1
a3519 1
      char *p = concat (msg, ";", append, NULL);
d3559 1
a3559 1
	  char *p = concat ("qSupported:", q, NULL);
@


1.402
log
@
	Support for Windows OS Thread Information Block.
	* NEWS: Document new feature.
	* remote.c (PACKET_qGetTIBAddr): New enum element.
	(remote_get_tib_address): New function.
	(init_remote_ops): Set to_get_tib_address field
	to remote_get_tib_address.
	(_initialize_remote): Add add_packet_config_cmd
	for PACKET_qGetTIBAddr.
	* target.c (update_current_target): Set default value for
	new to_get_tib_address field.
	* target.h (target_ops): New field to_get_tib_address.
	(target_get_tib_address): New macro.
	* windows-nat.c (thread_info): Add thread_local_base field.
	(windows_add_thread): Add tlb argument of type 'void *'.
	(fake_create_process): Adapt windows_add_thread call.
	(get_windows_debug_event): Idem.
	(windows_get_tib_address): New function.
	(init_windows_ops): Set to_get_tib_address field
	to remote_get_tib_address.
	(_initialize_windows_nat): Replace info_w32_cmdlist
	initialization by a call to init_w32_command_list.
	(info_w32_command, info_w32_cmdlist): Removed from here...
	to windows-tdep.c file.
	* windows-tdep.h (info_w32_cmdlist): Declare.
	(init_w32_command_list): New external function
	declaration.
	* windows-tdep.c: Add several headers.
	(info_w32_cmdlist): to here, made global.
	(thread_information_32): New struct.
	(thread_information_64): New struct.
	(TIB_NAME): New char array.
	(MAX_TIB32, MAX_TIB64, FULL_TIB_SIZE): New constants.
	(maint_display_all_tib): New static variable.
	(windows_get_tlb_type): New function.
	(tlb_value_read, tlb_value_write): New functions.
	(tlb_value_funcs): New static struct.
	(tlb_make_value): New function.
	(display_one_tib): New function.
	(display_tib): New function.
	(show_maint_show_all_tib):New function.
	(info_w32_command): Moved from windows-nat.c.
	(init_w32_command_list): New function.
	(_initialize_windows_tdep): New function.
	New "maint set/show show-all-tib" command
	New "$_tlb" internal variable.

gdbserver/ChangeLog entry:

	* server.c (handle_query): Handle 'qGetTIBAddr' query.
	* target.h (target_ops): New get_tib_address field.
	* win32-low.h (win32_thread_info): Add thread_local_base field.
	* win32-low.c (child_add_thread): Add tlb argument.
	Set thread_local_base field to TLB.
	(get_child_debug_event): Adapt to child_add_thread change.
	(win32_get_tib_address): New function.
	(win32_target_ops): Set get_tib_address field to
	win32_get_tib_address.
	* linux-low.c (linux_target_ops): Set get_tib_address field to NULL.

doc/ChangeLog entry:

	gdb.texinfo ($_tlb): Document new automatic convinience variable.
	(info w32 thread-information-block): Document new command.
	(qGetTIBAddress): Document new gdbserver query.
	(maint set/show show-all-tib): Document new command.
@
text
@d1538 8
d3166 5
d9914 1
@


1.401
log
@	* remote.c (remote_get_noisy_reply): Don't error out on empty
	replies.
	(remote_start_remote): Update and merge tracepoints and trace
	state variables as long as the target supports tracepoints.
	(remote_trace_init): Fix prototype.
	(remote_download_trace_state_variable): Validate reply.
	(remote_trace_set_readonly_regions): Fix prototype.
	(remote_trace_start): Fix prototype.  Check for empty reply.
	(remote_get_trace_status): Small cleanup.
	(remote_trace_stop): Fix prototype.  Check for empty reply.
	(remote_trace_find): Check for empty reply.
	(remote_save_trace_data): Validate reply.
	(remote_set_disconnected_tracing): Check for empty reply, and
	validate reply.
	(remote_set_circular_trace_buffer): Ditto.
@
text
@d1139 1
d8441 42
d9950 1
d10370 4
@


1.400
log
@2010-04-08  Stan Shebs  <stan@@codesourcery.com>
	    Pedro Alves  <pedro@@codesourcery.com>

	* tracepoint.h (struct trace_status): New fields disconnected_tracing
	and circular_buffer.
	(disconnect_tracing): Rename from disconnect_or_stop_tracing.
	* tracepoint.c (trace_status_command): Display target's status for
	disconnected tracing and circular buffer.
	(disconnect_tracing): Rename from disconnect_or_stop_tracing, add
	query for non-disconnected-tracing case, remove the stop_tracing
	call.
	(tfile_open): Clear disconnected and circular buffer status.
	(trace_save): Save disconnected and circular buffer status.
	(parse_trace_status): Parse disconnected and circular buffer status,
	also recognize disconnected as a stop reason.
	* remote.c (remote_set_disconnected_tracing): Only set
	QTDisconnected if the remote end supports disconnected tracing.
	Warn otherwise, if trying to enable disconnected tracing.
	* infcmd.c (detach_command): Update disconnect_tracing call.
	* cli/cli-cmds.c (quit_command): Ditto.

	* gdb.texinfo (Tracepoint Packets): Describe disconn and circular
	trace status fields.
@
text
@d433 1
a433 3
      if (buf[0] == 0)
	error (_("Target does not support this command."));
      else if (buf[0] == 'E')
d435 1
a435 2
      else if (buf[0] == 'O' &&
	       buf[1] != 'K')
d3168 1
a3168 1
  if (rs->disconnected_tracing)
a3172 1
      remote_get_trace_status (current_trace_status ());
d9289 1
a9289 1
remote_trace_init ()
d9293 1
a9293 1
  if (strcmp (target_buf, "OK"))
d9528 4
d9535 1
a9535 1
remote_trace_set_readonly_regions ()
d9571 1
a9571 1
remote_trace_start ()
d9575 3
a9577 1
  if (strcmp (target_buf, "OK"))
d9591 1
a9591 4
  getpkt (&target_buf, &target_buf_size, 0);
  /* FIXME should handle more variety of replies */

  p = target_buf;
d9615 1
a9615 1
remote_trace_stop ()
d9619 3
a9621 1
  if (strcmp (target_buf, "OK"))
d9660 2
d9730 5
a9734 1
  remote_get_noisy_reply (&target_buf, &target_buf_size);
d9788 2
d9792 2
a9793 2
      remote_get_noisy_reply (&target_buf, &target_buf_size);
      if (strcmp (target_buf, "OK"))
d9795 2
d9815 1
d9819 2
a9820 2
  remote_get_noisy_reply (&target_buf, &target_buf_size);
  if (strcmp (target_buf, "OK"))
d9822 2
@


1.399
log
@	* breakpoint.h (struct counted_command_line): Moved definition to
	breakpoint.c, and forward declare.
	(breakpoint_commands): Declare.
	* breakpoint.c (struct counted_command_line): Moved here.
	(breakpoint_commands): New.
	* tracepoint.c (encode_actions): Use breakpoint_commands.
	* remote.c (remote_download_tracepoint): Ditto.
@
text
@d9779 10
a9788 5
  sprintf (rs->buf, "QTDisconnected:%x", val);
  putpkt (rs->buf);
  remote_get_noisy_reply (&target_buf, &target_buf_size);
  if (strcmp (target_buf, "OK"))
    error (_("Target does not support this command."));
@


1.398
log
@Use hex_string instead of phex_nz for error.

2010-04-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* remote.c (remote_parse_stop_reply): Use hex_string instead
	of phex_nz for error.
@
text
@d9510 1
a9510 1
					  t->commands->commands);
@


1.397
log
@	* src/gdb/remote.c (end_thread): ARI fix: Use xstrdup instead of strdup.
@
text
@d4887 1
a4887 1
		       phex_nz (pnum, 0), p, buf);
@


1.396
log
@Add xmlRegisters= to qSupported packet.

gdb/

2010-03-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* NEWS: Mention xmlRegisters= in qSupported packet.

	* i386-tdep.c: Include "remote.h".
	(_initialize_i386_tdep): Call register_remote_support_xml.

	* remote.c (remote_support_xml): New.
	(register_remote_support_xml): Likewise.
	(remote_query_supported_append): Likewise.
	(remote_query_supported): Support remote_support_xml.

	* remote.h (register_remote_support_xml): New.

gdb/doc/

2010-03-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* gdb.texinfo (General Query Packets): Add xmlRegisters.
@
text
@d2453 1
a2453 1
    VEC_last (thread_item_t, data->items)->extra = strdup (body_text);
@


1.395
log
@2010-03-29  Stan Shebs  <stan@@codesourcery.com>

	* tracepoint.h (struct uploaded_string): New struct.
	(struct uploaded_tp): New fields for source strings.
	* breakpoint.c (this_utp, next_cmd): New globals.
	(read_uploaded_action): New function.
	(create_tracepoint_from_upload): Fill in more parts
	of a tracepoint.
	* tracepoint.c (encode_source_string): New function.
	(trace_save): Write out source strings, fix error checks.
	(parse_tracepoint_definition): Add source string parsing.
	* remote.c (PACKET_TracepointSource): New packet type.
	(remote_download_command_source): New function.
	(remote_download_tracepoint): Download source pieces also.
	(_initialize_remote): Add packet config command.

	* gdb.texinfo (Tracepoint Packets): Describe QTDPsrc.
	(General Query Packets): Describe TracepointSource.
@
text
@d3470 47
d3535 1
d3537 4
d3542 6
d3549 1
a3549 6
	  char *q;
	  if (rs->extended)
	    q = concat ("qSupported:multiprocess+;", qsupported, NULL);
	  else
	    q = concat ("qSupported:", qsupported, NULL);
	  putpkt (q);
d3551 2
d3555 1
a3555 6
	{
	  if (rs->extended)
	    putpkt ("qSupported:multiprocess+");
	  else
	    putpkt ("qSupported");
	}
@


1.394
log
@	gdb/
	* remote.c (crc32): Constify `buf' parameter.
	(remote_verify_memory): New, abstracted out from...
	(compare_sections_command): ... this.  Remove hardcoded target
	checks.
	(init_remote_ops): Install remote_verify_memory.
	* target.c (target_verify_memory): New.
	* target.h (struct target_ops) <to_verify_memory>: New field.
	(target_verify_memory): Declare.
@
text
@d1157 1
d3466 2
d9273 40
d9318 1
a9318 1
  char tmp[40];
d9339 1
a9339 1
      sprintf_vma (tmp, (loc ? tpaddr : 0));
d9341 1
a9341 1
	       tmp, /* address */
a9397 3
  if (!t->commands && !*default_collect)
	continue;

d9405 1
a9405 1
		       t->number, tmp, /* address */
d9422 1
a9422 1
		       t->number, tmp, /* address */
d9433 30
d10304 3
@


1.393
log
@	Implement -trace-save.

	* mi-cmds.h (mi_cmds_trace_save): Declare.
	* mi-cmds.c (mi_cmds): Register -trace-save.
	* mi/mi-main.c (mi_cmd_trace_save): New.
	* remote.c (remote_save_trace_data): Take const parameter.
	* target.h (struct target_ops::to_save_trace_data): Take
	const parameter.
	* target.c (update_current_target): Adjust to the above.
	* tracepoint.c (trave_save): New, extracted from
	(trace_save_command): ...this.
	(tfile_trace_find): Remove message that is unnecessary now
	that 'tfind' reports found frame.
	* tracepoint.h (trace_save): Declare.
@
text
@a175 2
static unsigned long crc32 (unsigned char *, int, unsigned int);

d7543 1
a7543 1
crc32 (unsigned char *buf, int len, unsigned int crc)
d7567 32
d7603 1
a7603 7
   Useful for verifying the image on the target against the exec file.
   Depends on the target understanding the new "qCRC:" request.  */

/* FIXME: cagney/1999-10-26: This command should be broken down into a
   target method (target verify memory) and generic version of the
   actual command.  This will allow other high-level code (especially
   generic_load()) to make use of this target functionality.  */
a7607 1
  struct remote_state *rs = get_remote_state ();
a7608 1
  unsigned long host_crc, target_crc;
a7609 1
  char *tmp;
d7616 1
a7619 3
  if (!current_target.to_shortname ||
      strcmp (current_target.to_shortname, "remote") != 0)
    error (_("command can only be used with remote target"));
a7635 4
      /* FIXME: assumes lma can fit into long.  */
      xsnprintf (rs->buf, get_remote_packet_size (), "qCRC:%lx,%lx",
		 (long) lma, (long) size);
      putpkt (rs->buf);
a7636 2
      /* Be clever; compute the host_crc before waiting for target
	 reply.  */
a7639 1
      host_crc = crc32 ((unsigned char *) sectdata, size, 0xffffffff);
d7641 3
a7643 2
      getpkt (&rs->buf, &rs->buf_size, 0);
      if (rs->buf[0] == 'E')
a7646 5
      if (rs->buf[0] != 'C')
	error (_("remote target does not support this operation"));

      for (target_crc = 0, tmp = &rs->buf[1]; *tmp; tmp++)
	target_crc = target_crc * 16 + fromhex (*tmp);
d7651 1
a7651 1
      if (host_crc == target_crc)
d9767 1
@


1.392
log
@	Implement -trace-find.

	* mi/mi-cmds.c (mi_cmds): Register -trace-find.
	* mi/mi-cmds.h (mi_cmd_trace_find): Declare.
	* mi/mi-main.c (mi_cmd_trace_find): New.
	* target.h (struct target_ops): Document to_trace_find.
	* tracepoint.h (tfind_1): Declare.
	* tracepoint.c (finish_tfind_command): Rename to...
	(tfind_1): ...this.
	* remote.c (remote_trace_find): Return -1 if target say
	there's no frame.  Improve error diagnostics.
@
text
@d9586 1
a9586 1
remote_save_trace_data (char *filename)
@


1.391
log
@	Unify actions and commands

	* defs.h (read_command_lines, read_command_lines_1): New
	parameters validator and closure.
	* tracepoint.h (struct action_line): Remove.
	* breakpoint.h (struct breakpoint): Remove the 'actions'
	field.
	* defs.h (enum command_control_type): New value
	while_stepping_control.
	(struct command_line): Add comments.
	* breakpoint.c (breakoint_is_tracepoint): New.
	(breakpoint_set_commands): For tracepoints,
	verify the commands are permissible.
	(check_tracepoint_commands): New.
	(commands_command): Require that each new line is validated using
	check_tracepoint_command, if we set commands for a tracepoint.
	(create_tracepoint_from_upload): Likewise.
	(print_one_breakpoint_location): Remove the code to print
	actions specifically.
	(tracepoint_save_command): Relay to print_command_lines.
	* cli/cli-script.c (process_next_line): New parameters validator
	and closure. Handle 'while-stepping'. Call validator if not null.
	(read_command_lines, read_command_lines1): Likewise.
	(recurse_read_control_structure): New parameters validator and
	closure. Handle while_stepping_control.
	(print_command_lines): Handle while-stepping.
	(get_command_line, define_command, document_command): Adjust.
	* remote.c (remote_download_tracepoint): Adjust.
	* tracepoint.c (make_cleanup_free_actions, read_actions)
	(free_actions, do_free_actions_cleanup): Remove.
	(trace_actions_command): Use read_command_lines.
	(validate_actionline): Use error in one place.
	(encode_actions_1): New, extracted from...
	(encode_actions): ...this. Also use cleanups for exception
	safety.
	(trace_dump_command): Adjust.
	* mi/mi-cmd-break (mi_cmd_break_commands): Validate commands if
	it's tracepoint.
@
text
@d9536 6
a9541 2
	if ((target_frameno = (int) strtol (++reply, &reply, 16)) == -1)
	  error (_("Target failed to find requested trace frame."));
d9544 4
a9547 2
	if ((target_tracept = (int) strtol (++reply, &reply, 16)) == -1)
	  error (_("Target failed to find requested trace frame."));
@


1.390
log
@2010-03-18  Stan Shebs  <stan@@codesourcery.com>
	    Pedro Alves  <pedro@@codesourcery.com>

	* target.h (struct target_ops): New method
	to_set_circular_trace_buffer.
	(target_set_circular_trace_buffer): New macro.
	* target.c (update_current_target): Add
	to_set_circular_trace_buffer, fix to_set_disconnected_tracing
	default behavior.
	* remote.c (remote_set_circular_trace_buffer): New function.
	(init_remote_ops): Add it to vector.
	* tracepoint.h (struct trace_status): New field traceframes_created,
	change buffer_size and buffer_free to int.
	* tracepoint.c (circular_trace_buffer): New global.
	(start_tracing): Send values of disconnected tracing and circular
	trace buffer settings.
	(set_circular_trace_buffer): New function.
	(parse_trace_state): Handle total space and frames created.
	(trace_status_command): Display total space and total frames
	created.
	(trace_save): Write out new status values.
	(parse_trace_status): Set traceframe_count, traceframes_created,
	buffer_free and buffer_size to -1 by default.
	(_initialize_tracepoint): New setshow for circular-trace-buffer.
	* NEWS: Mention the circular trace buffer option.

	* gdb.texinfo (Starting and Stopping Trace Experiments): Describe
	circular-trace-buffer.
	(Tracepoint Packets): Describe QTBuffer, and details of the
	qTStatus reply.

	* gdb.trace/circ.exp: Test circular-trace-buffer.
	* gdb.trace/tfile.exp: Update tstatus test.
@
text
@d9340 1
a9340 1
      if (t->actions || *default_collect)
d9347 1
a9347 1
      if (!t->actions && !*default_collect)
@


1.389
log
@Assertion failure after Ada task switch (target remote).

        * remote.c (remote_get_ada_task_ptid): New function.
        (init_remote_ops): Set remote_ops.to_get_ada_task_ptid.
@
text
@d9662 12
d9751 1
@


1.388
log
@2010-03-03 Stan Shebs  <stan@@codesourcery.com>

	* remote.c (remote_download_tracepoint): Iterate over locations.
	* tracepoint.c (validate_actionline): Ditto.
	(encode_actions): Add location argument.
	(trace_dump_command): Check all locations to see if stepping
	frame.
@
text
@d2685 9
d9697 1
d10257 1
@


1.387
log
@	* inferior.h (ptid_match): Declare.
	* infrun.c (ptid_match): New.
	* remote.c (queued_stop_reply): Rewrite and use ptid_match.
	(handle_notification): Add debug output.
	* linux-nat.c (ptid_match): Delete.
@
text
@d75 2
a76 2
encode_actions (struct breakpoint *t, char ***tdp_actions,
		char ***stepping_actions);
d9256 1
d9268 59
a9326 25
  encode_actions (t, &tdp_actions, &stepping_actions);
  old_chain = make_cleanup (free_actions_list_cleanup_wrapper,
			    tdp_actions);
  (void) make_cleanup (free_actions_list_cleanup_wrapper, stepping_actions);

  tpaddr = t->loc->address;
  sprintf_vma (tmp, (t->loc ? tpaddr : 0));
  sprintf (buf, "QTDP:%x:%s:%c:%lx:%x", t->number, 
	   tmp, /* address */
	   (t->enable_state == bp_enabled ? 'E' : 'D'),
	   t->step_count, t->pass_count);
  /* Fast tracepoints are mostly handled by the target, but we can
     tell the target how big of an instruction block should be moved
     around.  */
  if (t->type == bp_fast_tracepoint)
    {
      /* Only test for support at download time; we may not know
	 target capabilities at definition time.  */
      if (remote_supports_fast_tracepoints ())
	{
	  int isize;

	  if (gdbarch_fast_tracepoint_valid_at (target_gdbarch,
						tpaddr, &isize, NULL))
	    sprintf (buf + strlen (buf), ":F%x", isize);
d9328 1
a9328 4
	    /* If it passed validation at definition but fails now,
	       something is very wrong.  */
	    internal_error (__FILE__, __LINE__,
			    "Fast tracepoint not valid during download");
a9329 26
      else
	/* Fast tracepoints are functionally identical to regular
	   tracepoints, so don't take lack of support as a reason to
	   give up on the trace run.  */
	warning (_("Target does not support fast tracepoints, downloading %d as regular tracepoint"), t->number);
    }
  /* If the tracepoint has a conditional, make it into an agent
     expression and append to the definition.  */
  if (t->loc->cond)
    {
      /* Only test support at download time, we may not know target
	 capabilities at definition time.  */
      if (remote_supports_cond_tracepoints ())
	{
	  aexpr = gen_eval_for_expr (t->loc->address, t->loc->cond);
	  aexpr_chain = make_cleanup_free_agent_expr (aexpr);
	  sprintf (buf + strlen (buf), ":X%x,", aexpr->len);
	  pkt = buf + strlen (buf);
	  for (ndx = 0; ndx < aexpr->len; ++ndx)
	    pkt = pack_hex_byte (pkt, aexpr->buf[ndx]);
	  *pkt = '\0';
	  do_cleanups (aexpr_chain);
	}
      else
	warning (_("Target does not support conditional tracepoints, ignoring tp %d cond"), t->number);
    }
d9331 6
a9336 6
  if (t->actions || *default_collect)
    strcat (buf, "-");
  putpkt (buf);
  remote_get_noisy_reply (&target_buf, &target_buf_size);
  if (strcmp (target_buf, "OK"))
    error (_("Target does not support tracepoints."));
d9338 2
a9339 2
  if (!t->actions && !*default_collect)
    return;
d9341 19
a9359 4
  /* do_single_steps (t); */
  if (tdp_actions)
    {
      for (ndx = 0; tdp_actions[ndx]; ndx++)
d9361 14
a9374 28
	  QUIT;	/* allow user to bail out with ^C */
	  sprintf (buf, "QTDP:-%x:%s:%s%c",
		   t->number, tmp, /* address */
		   tdp_actions[ndx],
		   ((tdp_actions[ndx + 1] || stepping_actions)
		    ? '-' : 0));
	  putpkt (buf);
	  remote_get_noisy_reply (&target_buf,
				  &target_buf_size);
	  if (strcmp (target_buf, "OK"))
	    error (_("Error on target while setting tracepoints."));
	}
    }
  if (stepping_actions)
    {
      for (ndx = 0; stepping_actions[ndx]; ndx++)
	{
	  QUIT;	/* allow user to bail out with ^C */
	  sprintf (buf, "QTDP:-%x:%s:%s%s%s",
		   t->number, tmp, /* address */
		   ((ndx == 0) ? "S" : ""),
		   stepping_actions[ndx],
		   (stepping_actions[ndx + 1] ? "-" : ""));
	  putpkt (buf);
	  remote_get_noisy_reply (&target_buf,
				  &target_buf_size);
	  if (strcmp (target_buf, "OK"))
	    error (_("Error on target while setting tracepoints."));
d9376 1
a9377 2
  do_cleanups (old_chain);
  return;
@


1.386
log
@2010-02-22  Pedro Alves  <pedro@@codesourcery.com>

	PR9605

	gdb/
	* breakpoint.c (insert_bp_location): If inserting the read
	watchpoint failed, fallback to an access watchpoint.
	(bpstat_check_watchpoint): Stop for read watchpoint triggers even
	if the value changed, if not watching the same memory for writes.
	(watchpoint_locations_match): Add comment.
	(update_global_location_list): Copy the location's watchpoint type.
	* i386-nat.c (i386_length_and_rw_bits): It's an internal error to
	handle read watchpoints here.
	(i386_insert_watchpoint): Read watchpoints aren't supported.
	* remote.c (remote_insert_watchpoint): Return 1 for unsupported
	packets.
	* target.h (target_insert_watchpoint): Update description.

2010-02-22  Pedro Alves  <pedro@@codesourcery.com>

	PR9605

	gdbserver/
	* i386-low.c (i386_length_and_rw_bits): Throw a fatal error if
	handing a read watchpoint.
	(i386_low_insert_watchpoint): Read watchpoints aren't supported.

2010-02-22  Pedro Alves  <pedro@@codesourcery.com>

	PR9605

	gdb/testsuite/
	* gdb.base/watch-read.c, gdb.base/watch-read.exp: New files.
@
text
@d4640 2
a4641 2
  struct stop_reply *it, *prev;
  struct stop_reply head;
d4643 10
a4652 9
  head.next = stop_reply_queue;
  prev = &head;

  it = head.next;

  if (!ptid_equal (ptid, minus_one_ptid))
    for (; it; prev = it, it = it->next)
      if (ptid_equal (ptid, it->ptid))
	break;
d4654 2
a4655 4
  if (it)
    {
      prev->next = it->next;
      it->next = NULL;
a4657 2
  stop_reply_queue = head.next;

d6169 7
a6175 4
	/* We've already parsed the in-flight stop-reply, but the stub
	   for some reason thought we didn't, possibly due to timeout
	   on its side.  Just ignore it.  */
	;
d6193 3
@


1.385
log
@gdb/
	* defs.h (parse_pid_to_attach): New.
	* utils.c (parse_pid_to_attach): New.
	* darwin-nat.c (darwin_attach): Replace ARGS parsing by parse_pid.
	* gnu-nat.c (gnu_attach): Likewise.
	* nto-procfs.c (procfs_attach): Likewise.
	* procfs.c (procfs_attach): Likewise.
	* windows-nat.c (windows_attach): Likewise.
	* inf-ptrace.c (inf_ptrace_attach): Likewise.  Remove variable dummy.
	* inf-ttrace.c (inf_ttrace_attach): Likewise.
	* remote.c (extended_remote_attach_1): Likewise.  New comment on getpid
	check.

gdb/testsuite/
	* gdb.base/attach.exp (attach to nonsense is prohibited): Make the
	"Illegal process-id" expect string more exact.
	(attach to digits-starting nonsense is prohibited): New.
@
text
@d7344 1
a7344 1
    return -1;
d7358 1
d7360 1
a7360 1
      return -1;
@


1.385.2.1
log
@Assertion failure after Ada task switch (target remote).

        * remote.c (remote_get_ada_task_ptid): New function.
        (init_remote_ops): Set remote_ops.to_get_ada_task_ptid.
@
text
@a2684 9
/* Implement the to_get_ada_task_ptid function for the remote targets.  */

static ptid_t
remote_get_ada_task_ptid (long lwp, long thread)
{
  return ptid_build (ptid_get_pid (inferior_ptid), 0, lwp);
}


a9677 1
  remote_ops.to_get_ada_task_ptid = remote_get_ada_task_ptid;
a10236 1

@


1.384
log
@Pass target_gdbarch to gdbarch_qsupported.

2010-02-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* remote.c (remote_state): Remove gdbarch.
	(init_remote_state): Don't set gdbarch.
	(remote_query_supported): Pass target_gdbarch instead of
	rs->gdbarch to gdbarch_qsupported.
@
text
@a3859 1
  char *dummy;
d3862 1
a3862 2
  if (!args)
    error_no_arg (_("process-id to attach"));
d3864 2
a3865 5
  dummy = args;
  pid = strtol (args, &dummy, 0);
  /* Some targets don't set errno on errors, grrr!  */
  if (pid == 0 && args == dummy)
    error (_("Illegal process-id: %s."), args);
@


1.383
log
@Add qsupported to gdbarch.

2010-02-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* gdbarch.sh: Add qsupported.

	* gdbarch.c: Regenerated.
	* gdbarch.h: Likewise.

	* remote.c (remote_state): Add gdbarch.
	(init_remote_state): Set gdbarch.
	(remote_query_supported): Support gdbarch_qsupported.
@
text
@a329 3

  /* GDBARCH associated with this target.  */
  struct gdbarch *gdbarch;
a568 3
  /* Record our GDBARCH.  */
  rs->gdbarch = gdbarch;

d3478 1
a3478 1
      const char *qsupported = gdbarch_qsupported (rs->gdbarch);
@


1.382
log
@	* arch-utils.c (default_remote_breakpoint_from_pc): New function.
	* arch-utils.h (default_remote_breakpoint_from_pc): Declare.
	* gdbarch.c, gdbarch.h: Regenerated.
	* gdbarch.sh (remote_breakpoint_from_pc): New architecture method.
	* remote.c (remote_insert_breakpoint, remote_insert_hw_breakpoint): Use
	gdbarch_remote_breakpoint_from_pc.

	doc/
	* gdb.texinfo (Architecture-Specific Protocol Details): New section.
	Document ARM breakpoint types.
	(Register Packet Format): Move into the new section.
	(Packets): Describe the KIND argument for Z0, z0, Z1, and z1 packets.
@
text
@d330 3
d572 3
d3484 11
a3494 2
      if (rs->extended)
	putpkt ("qSupported:multiprocess+");
d3496 6
a3501 1
	putpkt ("qSupported");
@


1.381
log
@	Add trace file support.
	* tracepoint.h (enum trace_stop_reason): New enum.
	(struct trace_status): New struct.
	(parse_trace_status): Declare.
	(struct uploaded_tp): Move here from remote.c,
	add fields for actions.
	(struct uploaded_tsv): New struct.
	* tracepoint.c (tfile_ops): New target vector.
	(trace_fd): New global.
	(tfile_open): New function.
	(tfile_close): New function.
	(tfile_files_info): New function.
	(tfile_get_trace_status): New function.
	(tfile_get_traceframe_address): New function.
	(tfile_trace_find): New function.
	(tfile_fetch_registers): New function.
	(tfile_xfer_partial): New function.
	(tfile_get_trace_state_variable_value): New function.
	(init_tfile_ops): New function.
	(_initialize_tracepoint): Call it, add tfile target.
	(trace_status): New global.
	(current_trace_status): New function.
	(trace_running_p): Remove, change all users to get from
	current_trace_status()->running.
	(get_trace_status): Remove.
	(trace_status_command): Call target_get_trace_status directly,
	report more detail including tracing stop reasons.
	(trace_find_command): Always allow tfind on a file.
	(trace_find_pc_command): Ditto.
	(trace_find_tracepoint_command): Ditto.
	(trace_find_line_command): Ditto.
	(trace_find_range_command): Ditto.
	(trace_find_outside_command): Ditto.
	(trace_frames_offset, cur_offset): Declare as off_t.
	(trace_regblock_size): Rename from reg_size, update users.
	(parse_trace_status): New function.
	(tfile_interp_line): New function.
	(disconnect_or_stop_tracing): Ensure current trace
	status before asking what to do.
	(stop_reason_names): New global.
	(trace_save_command): New command.
	(get_uploaded_tp): Move here from remote.c.
	(find_matching_tracepoint): Ditto.
	(merge_uploaded_tracepoints): New function.
	(parse_trace_status): Use stop_reason_names.
	(_initialize_tracepoint): Define tsave command.
	* target.h (target_ops): New fields to_save_trace_data,
	to_upload_tracepoints, to_upload_trace_state_variables,
	to_get_raw_trace_data, change to_get_trace_status
	to take a pointer to a status struct.
	(target_save_trace_data): New macro.
	(target_upload_tracepoints): New macro.
	(target_upload_trace_state_variables): New macro.
	(target_get_raw_trace_data): New macro.
	* target.c (update_current_target): Add new methods, change
	signature of to_get_trace_status.
	* remote.c (hex2bin): Make globally visible.
	(bin2hex): Ditto.
	(remote_download_trace_state_variable): Download name also.
	(remote_get_trace_status): Update parameter, use
	parse_trace_status.
	(remote_save_trace_data): New function.
	(remote_upload_tracepoints): New function.
	(remote_upload_trace_state_variables): New function.
	(remote_get_raw_trace_data): New function.
	(remote_start_remote): Use them.
	(_initialize_remote_ops): Add operations.
	* ax-gdb.c: Include breakpoint.h.
	* breakpoint.c (create_tracepoint_from_upload): Use
	break_command_really, return tracepoint, warn about unimplemented
	parts.
	* NEWS: Mention trace file addition.

	* gdb.texinfo (Trace Files): New section.
	(Tracepoint Packets): Document QTSave and qTBuffer.
	(Trace File Format): New appendix.

	* generic/gdbtk-bp.c (gdb_trace_status): Use current_trace_status.

	* gdb.trace/tfile.c: New file.
	* gdb.trace/tfile.exp: New file.
@
text
@d7248 1
a7248 1
      gdbarch_breakpoint_from_pc (gdbarch, &addr, &bpsize);
d7450 1
a7450 1
  gdbarch_breakpoint_from_pc
@


1.380
log
@	Implement core awareness.

	* bcache.c (compare_ints): Remove
	(print_percentage): Use compare_positive_ints.
	* defs.h (compare_positive_ints): Declare.
	* linux-nat.h (struct lin_lwp): New field core.
	(linux_nat_core_of_thread_1): Declare.
	* linux-nat.c (add_lwp): Init the 'core' field.
	(linux_nat_wait_1): Record the core.
	(linux_nat_core_of_thread_1, linux_nat_core_of_thread): New.
	(linux_nat_add_target): Register the above.
	* linux-thread-db.c (update_thread_core): New.
	(thread_db_find_new_threads): Update core information for
	every thread.
	* remote.c (struct private_thread_info): New.
	(free_private_thread_info, demand_private_info): New.
	(PACKET_qXfer_threads, use_osdata_threads): New.
	(struct thread_item, threads_parsing_context
	(start_thread, end_thread, thread_attributes)
	(thread_children, threads_children, threads_elements): New.
	(remote_threads_info): Try qXfer:threads before anything
	else.
	(remote_protocol_packets): Register qXfer:threads.
	(remote_open_1): Init use_osdata_threads.
	(struct stop_reply): New field 'core'.
	(remote_parse_stop_reply): Parse core number.
	(process_stop_reply): Record core number.
	(remote_xfer_partial): Handle qXfer:threads.
	(remote_core_of_thread): New.
	(init_remote_ops): Register remote_core_of_thread.
	(_initialize_remote): Register qXfer:read.
	* target.c (target_core_of_thread): New
	* target.h (enum target_object): New value TARGET_OBJECT_THREADS.
	(struct target_ops): New field to_core_of_threads.
	(target_core_of_thread): Declare.
	* gdbthread.h (struct thread_info): New field private_dtor.
	* thread.c (print_thread_info): Report the core.
	* ui-out.c (MAX_UI_OUT_LEVELS): Increase.
	* utils.c (compare_positive_ints): New.
	* features/threads.dtd: New.
	* mi/mi-interp.c (mi_on_normal_stop): Report the core.
	* mi/mi-main.c (struct collect_cores_data, collect_cores)
	(do_nothing, free_vector_of_osdata_items)
	(splay_tree_int_comparator, free_splay_tree): New.
	(print_one_inferior_data): Implemented printing of selected
	inferiors.  Collect and print cores.
	(output_cores): New.
	(mi_cmd_list_thread_groups): Support --recurse.  Permit specifying
	thread groups together with --available.
@
text
@d192 1
a192 1
static int hex2bin (const char *hex, gdb_byte *bin, int count);
d194 1
a194 1
static int bin2hex (const gdb_byte *bin, char *hex, int count);
d218 1
a218 1
static void remote_get_tracing_state (struct remote_state *);
d220 4
d3165 17
a3181 1
      remote_get_tracing_state (rs);
d3971 1
a3971 1
static int
d4001 1
a4001 1
static int
d8057 1
a8057 1
      /* XXX - see also tracepoint.c:remote_get_noisy_reply().  */
d9365 1
d9367 7
a9373 2
  sprintf (rs->buf, "QTDV:%x:%s",
	   tsv->number, phex ((ULONGEST) tsv->initial_value, 8));
d9424 1
a9424 1
remote_get_trace_status (int *stop_reason)
d9426 6
d9433 17
a9449 1
  remote_get_noisy_reply (&target_buf, &target_buf_size);
d9451 1
a9451 2
  if (target_buf[0] != 'T' ||
      (target_buf[1] != '0' && target_buf[1] != '1'))
d9454 3
a9456 1
  return (target_buf[1] == '1');
d9486 1
a9486 1
      sprintf (p, "pc:%s", paddress (target_gdbarch, addr1));
d9492 1
a9492 1
      sprintf (p, "range:%s:%s", paddress (target_gdbarch, addr1), paddress (target_gdbarch, addr2));
d9495 1
a9495 1
      sprintf (p, "outside:%s:%s", paddress (target_gdbarch, addr1), paddress (target_gdbarch, addr2));
d9551 61
d9705 4
d9861 7
a9867 19
/* Struct to collect random info about tracepoints on the target.  */

struct uploaded_tp {
  int number;
  enum bptype type;
  ULONGEST addr;
  int enabled;
  int step;
  int pass;
  int orig_size;
  char *cond;
  int cond_len;
  struct uploaded_tp *next;
};

struct uploaded_tp *uploaded_tps;

struct uploaded_tp *
get_uploaded_tp (int num)
d9869 2
a9870 1
  struct uploaded_tp *utp;
d9872 5
a9876 23
  for (utp = uploaded_tps; utp; utp = utp->next)
    if (utp->number == num)
      return utp;
  utp = (struct uploaded_tp *) xmalloc (sizeof (struct uploaded_tp));
  utp->number = num;
  utp->next = uploaded_tps;
  uploaded_tps = utp;
  return utp;
}

/* Look for an existing tracepoint that seems similar enough to the
   uploaded one.  Enablement isn't checked, because the user can
   toggle that freely, and may have done so in anticipation of the
   next trace run.  */

struct breakpoint *
find_matching_tracepoint (struct uploaded_tp *utp)
{
  VEC(breakpoint_p) *tp_vec = all_tracepoints ();
  int ix;
  struct breakpoint *t;

  for (ix = 0; VEC_iterate (breakpoint_p, tp_vec, ix, t); ix++)
d9878 5
a9882 7
      if (t->type == utp->type
	  && (t->loc && t->loc->address == utp->addr)
	  && t->step_count == utp->step
	  && t->pass_count == utp->pass
	  /* FIXME also test conditionals and actions */
	  )
	return t;
d9884 1
a9884 1
  return NULL;
d9887 2
a9888 6
/* Find out everything we can about the trace run that was already
   happening on the target.  This includes both running/stopped, and
   the tracepoints that were in use.  */

static void
remote_get_tracing_state (struct remote_state *rs)
d9890 1
a9891 11
  ULONGEST num, addr, step, pass, orig_size, xlen;
  int enabled, i;
  enum bptype type;
  char *cond;
  struct uploaded_tp *utp;
  struct breakpoint *t;
  extern void get_trace_status ();

  get_trace_status ();
  if (trace_running_p)
    printf_filtered (_("Trace is running on the target.\n"));
d9893 2
a9894 1
  putpkt ("qTfP");
d9897 1
a9897 1
  while (*p != '\0')
d9899 3
a9901 71
      if (*p == 'T')
	{
	  p++;
	  p = unpack_varlen_hex (p, &num);
	  p++;
	  p = unpack_varlen_hex (p, &addr);
	  p++;
	  enabled = (*p++ == 'E');
	  p++;
	  p = unpack_varlen_hex (p, &step);
	  p++;
	  p = unpack_varlen_hex (p, &pass);
	  p++;
	  type = bp_tracepoint;
	  cond = NULL;
	  while (*p)
	    {
	      if (*p == 'F')
		{
		  type = bp_fast_tracepoint;
		  p++;
		  p = unpack_varlen_hex (p, &orig_size);
		}
	      else if (*p == 'X')
		{
		  p++;
		  p = unpack_varlen_hex (p, &xlen);
		  p++;  /* skip the comma */
		  cond = (char *) xmalloc (xlen);
		  hex2bin (p, cond, xlen);
		  p += 2 * xlen;
		}
	      else
		/* Silently skip over anything else.  */
		p++;
	    }
	  utp = get_uploaded_tp (num);
	  utp->type = type;
	  utp->addr = addr;
	  utp->enabled = enabled;
	  utp->step = step;
	  utp->pass = pass;
	  utp->cond = cond;
	  utp->cond_len = xlen;
	}
      else if (*p == 'A')
	{
	  p++;
	  p = unpack_varlen_hex (p, &num);
	  p++;
	  p = unpack_varlen_hex (p, &addr);
	  p++;
	  utp = get_uploaded_tp (num);
	  /* FIXME save the action */
	}
      else if (*p == 'S')
	{
	  p++;
	  p = unpack_varlen_hex (p, &num);
	  p++;
	  p = unpack_varlen_hex (p, &addr);
	  p++;
	  utp = get_uploaded_tp (num);
	  /* FIXME save the action */
	}
      else if (*p == 'l')
	{
	  /* No more tracepoint info, get out of the loop.  */
	  break;
	}
      putpkt ("qTsP");
d9905 1
a9905 19
  /* Got all the tracepoint info, now look for matches among what we
     already have in GDB.  */
  for (utp = uploaded_tps; utp; utp = utp->next)
    {
      t = find_matching_tracepoint (utp);
      if (t)
	{
	  printf_filtered (_("Assuming tracepoint %d is same as target's tracepoint %d.\n"),
			   t->number, utp->number);
	  t->number_on_target = utp->number;
	}
      else
	{
	  extern void create_tracepoint_from_upload (int num, ULONGEST addr);
	  create_tracepoint_from_upload (utp->number, utp->addr);
	}
    }
  /* FIXME free all the space */
  uploaded_tps = NULL;
@


1.379
log
@	Make tracepoint operations go through target vector.
	* target.h (enum trace_find_type): New enum.
	(struct target_ops): New fields to_trace_init,
	to_download_tracepoint, to_download_trace_state_variable,
	to_trace_set_readonly_regions, to_trace_start, to_get_trace_status,
	to_trace_stop, to_trace_find, to_get_trace_state_variable_value,
	to_set_disconnected_tracing.
	(target_trace_init): New macro.
	(target_download_tracepoint): New macro.
	(target_download_trace_state_variable): New macro.
	(target_trace_start): New macro.
	(target_trace_set_readonly_regions): New macro.
	(target_get_trace_status): New macro.
	(target_trace_stop): New macro.
	(target_trace_find): New macro.
	(target_get_trace_state_variable_value): New macro.
	(target_set_disconnected_tracing): New macro.
	* target.c (update_current_target): Inherit and set defaults for
	tracepoint operations.
	* tracepoint.c (default_collect): Make globally visible.
	(target_is_remote): Remove, along with all calls.
	(tvariables_info): Call target_get_trace_state_variable_value.
	(remote_set_transparent_ranges): Remove.
	(trace_start_command): Call target_trace_init,
	target_download_tracepoint, etc.
	(download_tracepoint): Remove.
	(trace_stop_command): Simplify.
	(stop_tracing): Call target_trace_stop.
	(get_trace_status): Call target_get_trace_status.
	(trace_status_command): Add case for targets that cannot trace.
	(finish_tfind_command): Change to take numerical arguments, call
	target_trace_find.
	(trace_find_command): Update call to finish_tfind_command.
	(trace_find_pc_command): Ditto.
	(trace_find_tracepoint_command): Ditto.
	(trace_find_line_command): Ditto.
	(trace_find_range_command): Ditto.
	(trace_find_outside_command): Ditto.
	(set_disconnected_tracing_value): Call
	target_set_disconnected_tracing.
	* remote.c: Add protocol encoding bits from tracepoint.c.
	(trace_error): Move from tracepoint.c.
	(remote_get_noisy_reply): Ditto.
	(free_actions_list_cleanup_wrapper): Ditto.
	(free_actions_list): Ditto.
	(remote_trace_init): New function.
	(remote_download_tracepoint): New function.
	(remote_download_trace_state_variable): New function.
	(remote_trace_set_readonly_regions): New function.
	(remote_trace_start): New function.
	(remote_get_trace_status): New function.
	(remote_trace_stop): New function.
	(remote_trace_find): New function.
	(remote_download_trace_state_variable): New function.
	(remote_set_disconnected_tracing): New function.
	(init_remote_ops): Add tracepoint operations.
@
text
@d63 1
d328 14
d1139 1
d1414 1
a1414 1
 	  return;
d1424 1
a1424 1
  	  thread_change_ptid (inferior_ptid, currthread);
d1446 20
a1475 6

  if (ptid_equal (currthread, minus_one_ptid))
    /* We're just invalidating the local thread mirror.  */
    return;

  remote_notice_new_inferior (currthread, 0);
d2404 74
d2495 55
d2622 9
d3416 2
d4532 2
d4697 1
d4724 2
a4725 1
	  if (strncmp (p, "awatch", strlen("awatch")) != 0)
d4771 6
d4986 1
d5018 1
d7861 5
d9514 9
d9596 1
d10133 3
@


1.378
log
@	Support disconnected tracing.
	* infcmd.c (detach_command): Ask whether to stop tracing.
	* cli/cli-cmds.c (quit_command): Ditto.
	* breakpoint.h (struct breakpoint): New field number_on_target.
	* breakpoint.c (create_tracepoint_from_upload): New function.
	(get_tracepoint_by_number_on_target): New function.
	* remote.c (struct remote): New field disconnected_tracing.
	(remote_disconnected_tracing_feature): New function.
	(remote_protocol_features): Add DisconnectedTracing.
	(struct uploaded_tp): New struct.
	(uploaded_tps): New global.
	(get_uploaded_tp): New function.
	(find_matching_tracepoint): New function.
	(remote_get_tracing_state): New function.
	(remote_start_remote): Call it.
	* tracepoint.c (disconnected_tracing): New global.
	(trace_start_command): Initialize number_on_target.
	(stop_tracing): New function, split out from...
	(trace_stop_command): Call stop_tracing.
	(get_trace_status): New function, split out from...
	(trace_status_command): Call get_trace_status, add info on
	disconnection behavior.
	(disconnect_or_stop_tracing): New function.
	(finish_tfind_command): Translate from number on target.
	(trace_find_tracepoint_command): Translate to number on target.
	(send_disconnected_tracing_value): New function.
	(set_disconnected_tracing): New function.
	(_initialize_tracepoint): Add disconnected-tracing variable.
	* NEWS: Mention disconnected tracing.

	* gdb.texinfo (Starting and Stopping Trace Experiments): Document
	disconnected tracing.
	(Tracepoint Packets): Document new protocol.
@
text
@d66 11
d382 46
d9003 325
d9390 10
a9621 1
  extern unsigned long trace_running_p;
d10040 3
@


1.377
log
@	Add fast tracepoints.
	* arch-utils.h (default_fast_tracepoint_valid_at): Declare.
	* arch-utils.c (default_fast_tracepoint_valid_at): New function.
	* breakpoint.h (enum bptype): Add bp_fast_tracepoint.
	* breakpoint.c (tracepoint_type): New function.
	(ALL_TRACEPOINTS): Use it.
	(should_be_inserted): Ditto.
	(bpstat_check_location): Ditto.
	(print_one_breakpoint_location): Ditto.
	(user_settable_breakpoint): Ditto.
	(set_breakpoint_location_function): Ditto.
	(disable_breakpoints_in_shlibs): Ditto.
	(delete_trace_command): Ditto.
	(print_it_typical): Add bp_fast_tracepoint case.
	(bpstat_what): Ditto.
	(print_one_breakpoint_location): Ditto.
	(allocate_bp_location): Ditto.
	(mention): Ditto.
	(breakpoint_re_set_one): Ditto.
	(disable_command): Ditto.
	(enable_command): Ditto.
	(check_fast_tracepoint_sals): New function.
	(break_command_really): Call it.
	(ftrace_command): New function.
	(_initialize_breakpoint): Add ftrace command.
	* gdbarch.sh (fast_tracepoint_valid_at): New.
	* gdbarch.h, gdbarch.c: Regenerate.
	* i386-tdep.c (i386_fast_tracepoint_valid_at): New function.
	(i386_gdbarch_init): Use it.
	* remote.c (struct remote_state): New field fast_tracepoints.
	(PACKET_FastTracepoints): New packet config type.
	(remote_fast_tracepoint_feature): New function.
	(remote_protocol_features): Add FastTracepoints.
	(remote_supports_fast_tracepoints): New function.
	(_initialize_remote): Add FastTracepoints.
	* tracepoint.c (download_tracepoint): Add fast tracepoint option.
	* NEWS: Mention fast tracepoints.

	* gdb.texinfo (Create and Delete Tracepoints): Describe fast
	tracepoints.
	(Tracepoint Packets): Describe remote protocol for fast
	tracepoints.

	* gdb.trace/tracecmd.exp: Test ftrace.
@
text
@d205 3
d307 4
d2932 7
d3166 9
d3205 2
d9158 178
@


1.376
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d301 3
d1072 1
d3143 9
d3180 2
d8913 7
d9396 2
@


1.375
log
@2009-11-13  Kazu Hirata  <kazu@@codesourcery.com>
	    Maxim Kuvyrkov  <maxim@@codesourcery.com>

	* remote-fileio.c (remote_fileio_request): Send Ctrl-C if it is
	pending.
	* remote-fileio.h: Update the prototype for remote_fileio_request.
	* remote.c (struct remote_state): Add ctrlc_pending_p.
	(remote_open_1): Clear ctrlc_pending_p.
	(remote_stop_as): Set ctrlc_pending_p to 1.
	(remote_wait_as): Pass ctrlc_pending_p to remote_fileio_request.
@
text
@d4 2
a5 2
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
   Free Software Foundation, Inc.
@


1.374
log
@    gdb/:

    * remote.c (interrupt_sequence_control_c)
        (interrupt_sequence_break, interrupt_sequence_break_g)
        (interrupt_sequence_modes): New constants.
        (interrupt_sequence_mode, interrupt_on_connect): New variable.
        (show_interrupt_sequence): New function.
        (set_remotebreak, show_remotebreak): New function.
        (send_interrupt_sequence): New function.
        (remote_start_remote): Call send_interrupt_sequence if
        interrupt_on_connect is true.
        (remote_stop_as): Call send_interrupt_sequence.
        (_initialize_remote): Add interrupt-sequence and interrupt-on-connect,
        modify remotebreak to call set_remotebreak and show_remotebreak.
        * NEWS: Add entry for "set/show remote interrupt-sequence" and
        "set/show remote interrupt-on-connect". Also mention that
        "set/show remotebreak" is now deprecated.

    gdb/doc/:

        * gdb.texinfo (Remote Configuration): Add "set/show remote
        interrupt-sequence" and "set/show remote interrupt-on-connect" command.
@
text
@d300 4
d3401 1
d4130 2
d4858 5
d4873 2
a4874 1
      remote_fileio_request (buf);
@


1.373
log
@2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	Add base multi-executable/process support to GDB.

	gdb/
	* Makefile.in (SFILES): Add progspace.c.
	(COMMON_OBS): Add progspace.o.
	* progspace.h: New.
	* progspace.c: New.

	* breakpoint.h (struct bp_target_info) <placed_address_space>: New
	field.
	(struct bp_location) <pspace>: New field.
	(struct breakpoint) <pspace>: New field.
	(bpstat_stop_status, breakpoint_here_p)
	(moribund_breakpoint_here_p, breakpoint_inserted_here_p)
	(regular_breakpoint_inserted_here_p)
	(software_breakpoint_inserted_here_p, breakpoint_thread_match)
	(set_default_breakpoint): Adjust prototypes.
	(remove_breakpoints_pid, breakpoint_program_space_exit): Declare.
	(insert_single_step_breakpoint, deprecated_insert_raw_breakpoint):
	Adjust prototypes.
	* breakpoint.c (executing_startup): Delete.
	(default_breakpoint_sspace): New.
	(breakpoint_restore_shadows): Skip if the address space doesn't
	match.
	(update_watchpoint): Record the frame's program space in the
	breakpoint location.
	(insert_bp_location): Record the address space in target_info.
	Adjust to pass the symbol space to solib_name_from_address.
	(breakpoint_program_space_exit): New.
	(insert_breakpoint_locations): Switch the symbol space and thread
	when inserting breakpoints.  Don't insert breakpoints in a vfork
	parent waiting for vfork done if we're not attached to the vfork
	child.
	(remove_breakpoints_pid): New.
	(reattach_breakpoints): Switch to a thread of PID.  Ignore
	breakpoints of other symbol spaces.
	(create_internal_breakpoint): Store the symbol space in the sal.
	(create_longjmp_master_breakpoint): Iterate over all symbol
	spaces.
	(update_breakpoints_after_exec): Ignore breakpoints for other
	symbol spaces.
	(remove_breakpoint): Rename to ...
	(remove_breakpoint_1): ... this.  Pass the breakpoints symbol
	space to solib_name_from_address.
	(remove_breakpoint): New.
	(mark_breakpoints_out): Ignore breakpoints from other symbol
	spaces.
	(breakpoint_init_inferior): Ditto.
	(breakpoint_here_p): Add an address space argument and adjust to
	use breakpoint_address_match.
	(moribund_breakpoint_here_p): Ditto.
	(regular_breakpoint_inserted_here_p): Ditto.
	(breakpoint_inserted_here_p): Ditto.
	(software_breakpoint_inserted_here_p): Ditto.
	(breakpoint_thread_match): Ditto.
	(bpstat_check_location): Ditto.
	(bpstat_stop_status): Ditto.
	(print_breakpoint_location): If there's a location to print,
	switch the current symbol space.
	(print_one_breakpoint_location): Add `allflag' argument.
	(print_one_breakpoint): Ditto.	Adjust.
	(do_captured_breakpoint_query): Adjust.
	(breakpoint_1): Adjust.
	(breakpoint_has_pc): Also match the symbol space.
	(describe_other_breakpoints): Add a symbol space argument and
	adjust.
	(set_default_breakpoint): Add a symbol space argument.	Set
	default_breakpoint_sspace.
	(breakpoint_address_match): New.
	(check_duplicates_for): Add an address space argument, and adjust.
	(set_raw_breakpoint): Record the symbol space in the location and
	in the breakpoint.
	(set_longjmp_breakpoint): Skip longjmp master breakpoints from
	other symbol spaces.
	(remove_thread_event_breakpoints, remove_solib_event_breakpoints)
	(disable_breakpoints_in_shlibs): Skip breakpoints from other
	symbol spaces.
	(disable_breakpoints_in_unloaded_shlib): Match symbol spaces.
	(create_catchpoint): Set the symbol space in the sal.
	(disable_breakpoints_before_startup): Skip breakpoints from other
	symbol spaces.	Set executing_startup in the current symbol space.
	(enable_breakpoints_after_startup): Clear executing_startup in the
	current symbol space.  Skip breakpoints from other symbol spaces.
	(clone_momentary_breakpoint): Also copy the symbol space.
	(add_location_to_breakpoint): Set the location's symbol space.
	(bp_loc_is_permanent): Switch thread and symbol space.
	(create_breakpoint): Adjust.
	(expand_line_sal_maybe): Expand comment to mention symbol spaces.
	Switch thread and symbol space when reading memory.
	(parse_breakpoint_sals): Set the symbol space in the sal.
	(break_command_really): Ditto.
	(skip_prologue_sal): Switch and space.
	(resolve_sal_pc): Ditto.
	(watch_command_1): Record the symbol space in the sal.
	(create_ada_exception_breakpoint): Adjust.
	(clear_command): Adjust.  Match symbol spaces.
	(update_global_location_list): Use breakpoint_address_match.
	(breakpoint_re_set_one): Switch thread and space.
	(breakpoint_re_set): Save symbol space.
	(breakpoint_re_set_thread): Also reset the symbol space.
	(deprecated_insert_raw_breakpoint): Add an address space argument.
	Adjust.
	(insert_single_step_breakpoint): Ditto.
	(single_step_breakpoint_inserted_here_p): Ditto.
	(clear_syscall_counts): New.
	(_initialize_breakpoint): Install it as inferior_exit observer.

	* exec.h: Include "progspace.h".
	(exec_bfd, exec_bfd_mtime): New defines.
	(exec_close): Declare.
	* exec.c: Include "gdbthread.h" and "progspace.h".
	(exec_bfd, exec_bfd_mtime, current_target_sections_1): Delete.
	(using_exec_ops): New.
	(exec_close_1): Rename to exec_close, and make public.
	(exec_close): Rename to exec_close_1, and adjust all callers.  Add
	description.  Remove target sections and close executables from
	all program spaces.
	(exec_file_attach): Add comment.
	(add_target_sections): Check on `using_exec_ops' to check if the
	target should be pushed.
	(remove_target_sections): Only unpush the target if there are no
	more target sections in any symbol space.
	* gdbcore.h: Include "exec.h".
	(exec_bfd, exec_bfd_mtime): Remove declarations.

	* frame.h (get_frame_program_space, get_frame_address_space)
	(frame_unwind_program_space): Declare.
	* frame.c (struct frame_info) <pspace, aspace>: New fields.
	(create_sentinel_frame): Add program space argument.  Set the
	pspace and aspace fields of the frame object.
	(get_current_frame, create_new_frame): Adjust.
	(get_frame_program_space): New.
	(frame_unwind_program_space): New.
	(get_frame_address_space): New.
	* stack.c (print_frame_info): Adjust.
	(print_frame): Use the frame's program space.

	* gdbthread.h (any_live_thread_of_process): Declare.
	* thread.c (any_live_thread_of_process): New.
	(switch_to_thread): Switch the program space as well.
	(restore_selected_frame): Don't warn if trying to restore frame
	level 0.

	* inferior.h: Include "progspace.h".
	(detach_fork): Declare.
	(struct inferior) <removable, aspace, pspace>
	<vfork_parent, vfork_child, pending_detach>
	<waiting_for_vfork_done>: New fields.
	<terminal_info>: Remove field.
	<data, num_data>: New fields.
	(register_inferior_data, register_inferior_data_with_cleanup)
	(clear_inferior_data, set_inferior_data, inferior_data): Declare.
	(exit_inferior, exit_inferior_silent, exit_inferior_num_silent)
	(inferior_appeared): Declare.
	(find_inferior_pid): Typo.
	(find_inferior_id, find_inferior_for_program_space): Declare.
	(set_current_inferior, save_current_inferior, prune_inferiors)
	(number_of_inferiors): Declare.
	(inferior_list): Declare.
	* inferior.c: Include "gdbcore.h" and "symfile.h".
	(inferior_list): Make public.
	(delete_inferior_1): Always delete thread silently.
	(find_inferior_id): Make public.
	(current_inferior_): New.
	(current_inferior): Use it.
	(set_current_inferior): New.
	(restore_inferior): New.
	(save_current_inferior): New.
	(free_inferior): Free the per-inferior data.
	(add_inferior_silent): Allocate per-inferior data.
	Call inferior_appeared.
	(delete_threads_of_inferior): New.
	(delete_inferior_1): Adjust interface to take an inferior pointer.
	(delete_inferior): Adjust.
	(delete_inferior_silent): Adjust.
	(exit_inferior_1): New.
	(exit_inferior): New.
	(exit_inferior_silent): New.
	(exit_inferior_num_silent): New.
	(detach_inferior): Adjust.
	(inferior_appeared): New.
	(discard_all_inferiors): Adjust.
	(find_inferior_id): Make public.  Assert pid is not zero.
	(find_inferior_for_program_space): New.
	(have_inferiors): Check if we have any inferior with pid not zero.
	(have_live_inferiors): Go over all pushed targets looking for
	process_stratum.
	(prune_inferiors): New.
	(number_of_inferiors): New.
	(print_inferior): Add executable column.  Print vfork parent/child
	relationships.
	(inferior_command): Adjust to cope with not running inferiors.
	(remove_inferior_command): New.
	(add_inferior_command): New.
	(clone_inferior_command): New.
	(struct inferior_data): New.
	(struct inferior_data_registration): New.
	(struct inferior_data_registry): New.
	(inferior_data_registry): New.
	(register_inferior_data_with_cleanup): New.
	(register_inferior_data): New.
	(inferior_alloc_data): New.
	(inferior_free_data): New.
	(clear_inferior_data): New.
	(set_inferior_data): New.
	(inferior_data): New.
	(initialize_inferiors): New.
	(_initialize_inferiors): Register "add-inferior",
	"remove-inferior" and "clone-inferior" commands.

	* objfiles.h: Include "progspace.h".
	(struct objfile) <pspace>: New field.
	(symfile_objfile, object_files): Don't declare.
	(ALL_PSPACE_OBJFILES): New.
	(ALL_PSPACE_OBJFILES_SAFE): New.
	(ALL_OBJFILES, ALL_OBJFILES_SAFE): Adjust.
	(ALL_PSPACE_SYMTABS): New.
	(ALL_PRIMARY_SYMTABS): Adjust.
	(ALL_PSPACE_PRIMARY_SYMTABS): New.
	(ALL_PSYMTABS): Adjust.
	(ALL_PSPACE_PSYMTABS): New.
	* objfiles.c (object_files, symfile_objfile): Delete.
	(struct objfile_sspace_info): New.
	(objfiles_pspace_data): New.
	(objfiles_pspace_data_cleanup): New.
	(get_objfile_pspace_data): New.
	(objfiles_changed_p): Delete.
	(allocate_objfile): Set the objfile's program space.  Adjust to
	reference objfiles_changed_p in pspace data.
	(free_objfile): Adjust to reference objfiles_changed_p in pspace
	data.
	(objfile_relocate): Ditto.
	(update_section_map): Add pspace argument.  Adjust to iterate over
	objfiles in the passed in pspace.
	(find_pc_section): Delete sections and num_sections statics.
	Adjust to refer to program space's objfiles_changed_p.	Adjust to
	refer to sections and num_sections store in the objfile's pspace
	data.
	(objfiles_changed): Adjust to reference objfiles_changed_p in
	pspace data.
	(_initialize_objfiles): New.
	* linespec.c (decode_all_digits, decode_dollar): Set the sal's
	program space.
	* source.c (current_source_pspace): New.
	(get_current_source_symtab_and_line): Set the sal's program space.
	(set_current_source_symtab_and_line): Set current_source_pspace.
	(select_source_symtab): Ditto.	Use ALL_OBJFILES.
	(forget_cached_source_info): Iterate over all program spaces.
	* symfile.c (clear_symtab_users): Adjust.
	* symmisc.c (print_symbol_bcache_statistics): Iterate over all
	program spaces.
	(print_objfile_statistics): Ditto.
	(maintenance_print_msymbols): Ditto.
	(maintenance_print_objfiles): Ditto.
	(maintenance_info_symtabs): Ditto.
	(maintenance_info_psymtabs): Ditto.
	* symtab.h (SYMTAB_PSPACE): New.
	(struct symtab_and_line) <pspace>: New field.
	* symtab.c (init_sal): Clear the sal's program space.
	(find_pc_sect_symtab): Set the sal's program space.  Switch thread
	and space.
	(append_expanded_sal): Add program space argument.  Iterate over
	all program spaces.
	(expand_line_sal): Iterate over all program spaces.  Switch
	program space.

	* target.h (enum target_waitkind) <TARGET_WAITKIND_VFORK_DONE>: New.
	(struct target_ops) <to_thread_address_space>: New field.
	(target_thread_address_space): Define.
	* target.c (target_detach): Only remove breakpoints from the
	inferior we're detaching.
	(target_thread_address_space): New.

	* defs.h (initialize_progspace): Declare.
	* top.c (gdb_init): Call it.

	* solist.h (struct so_list) <sspace>: New field.
	* solib.h (struct program_space): Forward declare.
	(solib_name_from_address): Adjust prototype.
	* solib.c (so_list_head): Replace with a macro referencing the
	program space.
	(update_solib_list): Set the so's program space.
	(solib_name_from_address): Add a program space argument and adjust.

	* solib-svr4.c (struct svr4_info) <pid>: Delete field.
	<interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low>
	<interp_plt_sect_high>: New fields.
	(svr4_info_p, svr4_info): Delete.
	(solib_svr4_sspace_data): New.
	(get_svr4_info): Rewrite.
	(svr4_sspace_data_cleanup): New.
	(open_symbol_file_object): Adjust.
	(svr4_default_sos): Adjust.
	(svr4_fetch_objfile_link_map): Adjust.
	(interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low)
	(interp_plt_sect_high): Delete.
	(svr4_in_dynsym_resolve_code): Adjust.
	(enable_break): Adjust.
	(svr4_clear_solib): Revert bit that removed the svr4_info here,
	and reinstate clearing debug_base, debug_loader_offset_p,
	debug_loader_offset and debug_loader_name.
	(_initialize_svr4_solib): Register solib_svr4_pspace_data.  Don't
	install an inferior_exit observer anymore.

	* printcmd.c (struct display) <pspace>: New field.
	(display_command): Set the display's sspace.
	(do_one_display): Match the display's sspace.
	(display_uses_solib_p): Ditto.

	* linux-fork.c (detach_fork): Moved to infrun.c.
	(_initialize_linux_fork): Moved "detach-on-fork" command to
	infrun.c.
	* infrun.c (detach_fork): Moved from linux-fork.c.
	(proceed_after_vfork_done): New.
	(handle_vfork_child_exec_or_exit): New.
	(follow_exec_mode_replace, follow_exec_mode_keep)
	(follow_exec_mode_names, follow_exec_mode_string)
	(show_follow_exec_mode_string): New.
	(follow_exec): New.  Reinstate the mark_breakpoints_out call.
	Remove shared libraries before attaching new executable.  If user
	wants to keep the inferior, keep it.
	(displaced_step_fixup): Adjust to pass an address space to the
	breakpoints module.
	(resume): Ditto.
	(clear_proceed_status): In all-stop mode, always clear the proceed
	status of all threads.
	(prepare_to_proceed): Adjust to pass an address space to the
	breakpoints module.
	(proceed): Ditto.
	(adjust_pc_after_break): Ditto.
	(handle_inferior_event): When handling a process exit, switch the
	program space to the inferior's that had exited.  Call
	handle_vfork_child_exec_or_exit.  Adjust to pass an address space
	to the breakpoints module.  In non-stop mode, when following a
	fork and detach-fork is off, also resume the other branch.  Handle
	TARGET_WAITKIND_VFORK_DONE.  Set the program space in sals.
	(normal_stop): Prune inferiors.
	(_initialize_infrun): Install the new "follow-exec-mode" command.
	"detach-on-fork" moved here.

	* regcache.h (get_regcache_aspace): Declare.
	* regcache.c (struct regcache) <aspace>: New field.
	(regcache_xmalloc): Clear the aspace.
	(get_regcache_aspace): New.
	(regcache_cpy): Copy the aspace field.
	(regcache_cpy_no_passthrough): Ditto.
	(get_thread_regcache): Fetch the thread's address space from the
	target, and store it in the regcache.

	* infcall.c (call_function_by_hand): Set the sal's pspace.

	* arch-utils.c (default_has_shared_address_space): New.
	* arch-utils.h (default_has_shared_address_space): Declare.

	* gdbarch.sh (has_shared_address_space): New.
	* gdbarch.h, gdbarch.c: Regenerate.

	* linux-tdep.c: Include auxv.h, target.h, elf/common.h.
	(linux_has_shared_address_space): New.
	(_initialize_linux_tdep): Declare.

	* arm-tdep.c (arm_software_single_step): Pass the frame's address
	space to insert_single_step_breakpoint.
	* arm-linux-tdep.c (arm_linux_software_single_step): Pass the
	frame's pspace to breakpoint functions.
	* cris-tdep.c (crisv32_single_step_through_delay): Ditto.
	(cris_software_single_step): Ditto.
	* mips-tdep.c (deal_with_atomic_sequence): Add frame argument.
	Pass the frame's pspace to breakpoint functions.
	(mips_software_single_step): Adjust.
	(mips_single_step_through_delay): Adjust.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Adjust.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Adjust.
	* solib-irix.c (enable_break): Adjust to pass the current frame's
	address space to breakpoint functions.
	* sparc-tdep.c (sparc_software_single_step): Ditto.
	* spu-tdep.c (spu_software_single_step): Ditto.
	* alpha-tdep.c (alpha_software_single_step): Ditto.
	* record.c (record_wait): Adjust to pass an address space to the
	breakpoints module.

	* fork-child.c (fork_inferior): Set the new inferior's program and
	address spaces.
	* inf-ptrace.c (inf_ptrace_follow_fork): Copy the parent's program
	and address spaces.
	(inf_ptrace_attach): Set the inferior's program and address spaces.
	* linux-nat.c: Include "solib.h".
	(linux_child_follow_fork): Manage parent and child's program and
	address spaces.	 Clone the parent's program space if necessary.
	Don't wait for the vfork to be done here.  Refuse to resume if
	following the vfork parent while leaving the child stopped.
	(resume_callback): Don't resume a vfork parent.
	(linux_nat_resume): Also check for pending events in the
	lp->waitstatus field.
	(linux_handle_extended_wait): Report TARGET_WAITKIND_VFORK_DONE
	events to the core.
	(stop_wait_callback): Don't wait for SIGSTOP on vfork parents.
	(cancel_breakpoint): Adjust.
	* linux-thread-db.c (thread_db_wait): Don't remove thread event
	breakpoints here.
	(thread_db_mourn_inferior): Don't mark breakpoints out here.
	Remove thread event breakpoints after mourning.
	* corelow.c: Include progspace.h.
	(core_open): Set the inferior's program and address spaces.
	* remote.c (remote_add_inferior): Set the new inferior's program
	and address spaces.
	(remote_start_remote): Update address spaces.
	(extended_remote_create_inferior_1): Don't init the thread list if
	we already debugging other inferiors.
	* darwin-nat.c (darwin_attach): Set the new inferior's program and
	address spaces.
	* gnu-nat.c (gnu_attach): Ditto.
	* go32-nat.c (go32_create_inferior): Ditto.
	* inf-ttrace.c (inf_ttrace_follow_fork, inf_ttrace_attach): Ditto.
	* monitor.c (monitor_open): Ditto.
	* nto-procfs.c (procfs_attach, procfs_create_inferior): Ditto.
	* procfs.c (do_attach): Ditto.
	* windows-nat.c (do_initial_windows_stuff): Ditto.

	* inflow.c (inferior_process_group)
	(terminal_init_inferior_with_pgrp, terminal_inferior,
	(terminal_ours_1, inflow_inferior_exit, copy_terminal_info)
	(child_terminal_info, new_tty_postfork, set_sigint_trap): Adjust
	to use per-inferior data instead of inferior->terminal_info.
	(inflow_inferior_data): New.
	(inflow_new_inferior): Delete.
	(inflow_inferior_data_cleanup): New.
	(get_inflow_inferior_data): New.

	* mi/mi-interp.c (mi_new_inferior): Rename to...
	(mi_inferior_appeared): ... this.
	(mi_interpreter_init): Adjust.

	* tui/tui-disasm.c: Include "progspace.h".
	(tui_set_disassem_content): Pass an address space to
	breakpoint_here_p.

	* NEWS: Mention multi-program debugging support.  Mention new
	commands "add-inferior", "clone-inferior", "remove-inferior",
	"maint info program-spaces", and new option "set
	follow-exec-mode".

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* observer.texi (new_inferior): Rename to...
	(inferior_appeared): ... this.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/testsuite/
	* gdb.base/foll-vfork.exp: Adjust to spell out "follow-fork".
	* gdb.base/foll-exec.exp: Adjust to expect a process id before
	"Executing new program".
	* gdb.base/foll-fork.exp: Adjust to spell out "follow-fork".
	* gdb.base/multi-forks.exp: Ditto.  Adjust to the inferior being
	left listed after having been killed.
	* gdb.base/attach.exp: Adjust to spell out "symbol-file".
	* gdb.base/maint.exp: Adjust test.

	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* gdb.multi/Makefile.in: New.
	* gdb.multi/base.exp: New.
	* gdb.multi/goodbye.c: New.
	* gdb.multi/hangout.c: New.
	* gdb.multi/hello.c: New.
	* gdb.multi/bkpt-multi-exec.c: New.
	* gdb.multi/bkpt-multi-exec.exp: New.
	* gdb.multi/crashme.c: New.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Inferiors): Rename node to ...
	(Inferiors and Programs): ... this.  Mention running multiple
	programs in the same debug session.
	<info inferiors>: Mention the new 'Executable' column if "info
	inferiors".  Update examples.  Document the "add-inferior",
	"clone-inferior", "remove-inferior" and "maint info
	program-spaces" commands.
	(Process): Rename node to...
	(Forks): ... this.  Document "set|show follow-exec-mode".
@
text
@d549 17
d567 24
a590 4
/* This variable chooses whether to send a ^C or a break when the user
   requests program interruption.  Although ^C is usually what remote
   systems expect, and that is the default here, sometimes a break is
   preferable instead.  */
d592 9
d603 16
d2669 19
d2701 3
d4131 2
a4132 6
  /* Send a break or a ^C, depending on user preference.  */

  if (remote_break)
    serial_send_break (remote_desc);
  else
    serial_write (remote_desc, "\003", 1);
d9102 2
d9171 1
a9171 1
			   NULL, NULL, /* FIXME: i18n: Whether to send break if interrupted is %s.  */
d9173 23
@


1.372
log
@Fix typo.
@
text
@d1186 20
a1205 1
  inf = add_inferior (pid);
d2661 4
d3512 1
a3512 1
  remote_add_inferior (pid, 1);
d6805 8
a6812 5
  /* Clean up from the last time we ran, before we mark the target
     running again.  This will mark breakpoints uninserted, and
     get_offsets may insert breakpoints.  */
  init_thread_list ();
  init_wait_for_inferior ();
@


1.371
log
@2009-09-10  Michael Snyder  <msnyder@@vmware.com>

	* remote.c (PACKET_bc, PACKET_bs): New enums.
	(remote_protocol_features): Add ReverseStep, ReverseContinue.
	(remote_resume): Check for reverse capability.
	(_initialize_remote): Add packet config for "bs" and "bc" packets.
	* NEWS (new options): Mention set/show for "bs" and "bc" packets.
@
text
@d3835 1
a3835 1
	error ("_(Remote reverse-continue not supported."));
@


1.370
log
@	* utils.c (add_internal_problem_command): Free set_doc and
	show_doc.
	* remote.c (add_packet_config_cmd): Free set_doc and show_doc.
	* language.c (add_language): Free language_set_doc.
@
text
@d1003 2
d3056 4
d3810 4
a3813 2
  if (remote_vcont_resume (ptid, step, siggnal))
    goto done;
d3829 8
a8748 2
static int remote_target_can_reverse = 1;

d8752 5
a8756 1
  return remote_target_can_reverse;
d9186 6
@


1.369
log
@	* ui-file.h (ui_file_xstrdup): Mention that the length argument
	may be NULL.
	* ui-file.c (ui_file_xstrdup): Don't dereference LENGTH if it is
	NULL.
	* aix-thread.c (aix_thread_extra_thread_info): Pass NULL as length
	parameter to ui_file_xstrdup.
	* arm-tdep.c (_initialize_arm_tdep): Ditto.
	* infrun.c (print_target_wait_results): Ditto.
	* language.c (add_language): Ditto.
	* linespec.c (cplusplus_error): Ditto.
	* remote.c (escape_buffer): Ditto.
	* typeprint.c (type_to_string): Ditto.
	* utils.c (error_stream): Ditto.
	* varobj.c (value_get_print_value): Ditto.
	* xtensa-tdep.c (xtensa_verify_config): Replace `dummy' local with
	`length' local.  Pass it to ui_file_xstrdup, and avoid an strlen
	call.
	* gdbarch.sh (verify_gdbarch): Ditto.
	* gdbarch.c: Regenerate.
	* cli/cli-setshow.c (do_setshow_command): Pass NULL as length
	parameter to ui_file_xstrdup.
	* python/python-frame.c (frapy_str): Ditto.
	* python/python-type.c (typy_str): Use the length local instead of
	calling strlen.
	* python/python-value.c (valpy_str): Pass NULL as length parameter
	to ui_file_xstrdup.
@
text
@d868 3
@


1.368
log
@	* remote.c (remote_pid_to_str): If printing a process id and we
	don't know what the remote pid could be, output "Remote target";
	otherwise, use normal_pid_to_str.
@
text
@a5949 1
  long length;
d5955 1
a5955 1
  str = ui_file_xstrdup (stb, &length);
@


1.367
log
@2009-08-12  Michael Snyder  <msnyder@@vmware.com>

	* remote.c (remote_add_inferior): Remove unused local.
	(remote_add_thread): Ditto.
	(read_ptid): Ditto.
	(remote_current_thread): Ditto.
	(remote_stop_ns): Ditto.
	(remote_parse_stop_reply): Ditto.
	(remote_get_pending_stop_replies): Ditto.
	(remote_wait_ns): Ditto.
	(remote_wait_as): Ditto.
	(send_g_packet): Ditto.
	(remote_fetch_registers): Ditto.
	(store_register_using_P): Ditto.
	(remote_store_registers): Ditto.
	(remote_remove_breakpoint): Ditto.
	(remote_write_qxfer): Ditto.
	(remote_read_qxfer): Ditto.
@
text
@d7838 1
a7838 1
  if (ptid_equal (magic_null_ptid, ptid))
d7840 18
a7857 2
      xsnprintf (buf, sizeof buf, "Thread <main>");
      return buf;
d7859 1
a7859 2
  else if (remote_multi_process_p (rs)
	   && ptid_get_tid (ptid) != 0 && ptid_get_pid (ptid) != 0)
d7861 8
a7868 2
      xsnprintf (buf, sizeof buf, "Thread %d.%ld",
		 ptid_get_pid (ptid), ptid_get_tid (ptid));
a7870 8
  else if (ptid_get_tid (ptid) != 0)
    {
      xsnprintf (buf, sizeof buf, "Thread %ld",
		 ptid_get_tid (ptid));
      return buf;
    }

  return normal_pid_to_str (ptid);
@


1.366
log
@2009-07-31  Michael Snyder  <msnyder@@vmware.com>

	* remote.c (store_register_using_P): Make error msg more verbose.
	(store_registers_using_G): Ditto.
	(fetch_register_using_p): Ditto.
@
text
@a1172 1
  struct remote_state *rs = get_remote_state ();
a1208 2
  struct remote_state *rs = get_remote_state ();

a1425 1
  int tid = ptid_get_tid (ptid);
a1600 1
  ptid_t ptid;
a2195 3
  char *p = rs->buf;
  int tid;
  int pid;
a3948 1
  struct stop_reply *reply, *next;
d4303 18
a4320 2
      {
	gdb_byte regs[MAX_REGISTER_SIZE];
d4322 2
a4323 6
	/* Expedited reply, containing Signal, {regno, reg} repeat.  */
	/*  format is:  'Tssn...:r...;n...:r...;n...:r...;#cc', where
	   ss = signal number
	   n... = register number
	   r... = register contents
	*/
d4325 8
a4332 11
	p = &buf[3];	/* after Txx */
	while (*p)
	  {
	    char *p1;
	    char *p_temp;
	    int fieldsize;
	    LONGEST pnum = 0;

	    /* If the packet contains a register number, save it in
	       pnum and set p1 to point to the character following it.
	       Otherwise p1 points to p.  */
d4334 5
a4338 17
	    /* If this packet is an awatch packet, don't parse the 'a'
	       as a register number.  */

	    if (strncmp (p, "awatch", strlen("awatch")) != 0)
	      {
		/* Read the ``P'' register number.  */
		pnum = strtol (p, &p_temp, 16);
		p1 = p_temp;
	      }
	    else
	      p1 = p;

	    if (p1 == p)	/* No register number present here.  */
	      {
		p1 = strchr (p, ':');
		if (p1 == NULL)
		  error (_("Malformed packet(a) (missing colon): %s\n\
d4340 17
a4356 17
			 p, buf);
		if (strncmp (p, "thread", p1 - p) == 0)
		  event->ptid = read_ptid (++p1, &p);
		else if ((strncmp (p, "watch", p1 - p) == 0)
			 || (strncmp (p, "rwatch", p1 - p) == 0)
			 || (strncmp (p, "awatch", p1 - p) == 0))
		  {
		    event->stopped_by_watchpoint_p = 1;
		    p = unpack_varlen_hex (++p1, &addr);
		    event->watch_data_address = (CORE_ADDR) addr;
		  }
		else if (strncmp (p, "library", p1 - p) == 0)
		  {
		    p1++;
		    p_temp = p1;
		    while (*p_temp && *p_temp != ';')
		      p_temp++;
d4358 18
a4375 1
		    event->solibs_changed = 1;
d4377 6
a4382 23
		  }
		else if (strncmp (p, "replaylog", p1 - p) == 0)
		  {
		    /* NO_HISTORY event.
		       p1 will indicate "begin" or "end", but
		       it makes no difference for now, so ignore it.  */
		    event->replay_event = 1;
		    p_temp = strchr (p1 + 1, ';');
		    if (p_temp)
		      p = p_temp;
		  }
		else
		  {
		    /* Silently skip unknown optional info.  */
		    p_temp = strchr (p1 + 1, ';');
		    if (p_temp)
		      p = p_temp;
		  }
	      }
	    else
	      {
		struct packet_reg *reg = packet_reg_from_pnum (rsa, pnum);
		cached_reg_t cached_reg;
d4384 1
a4384 1
		p = p1;
d4386 2
a4387 2
		if (*p != ':')
		  error (_("Malformed packet(b) (missing colon): %s\n\
d4389 2
a4390 2
			 p, buf);
		++p;
d4392 2
a4393 2
		if (reg == NULL)
		  error (_("Remote sent bad register number %s: %s\n\
d4395 1
a4395 1
			 phex_nz (pnum, 0), p, buf);
d4397 1
a4397 1
		cached_reg.num = reg->regnum;
d4399 7
a4405 7
		fieldsize = hex2bin (p, cached_reg.data,
				     register_size (target_gdbarch,
						    reg->regnum));
		p += 2 * fieldsize;
		if (fieldsize < register_size (target_gdbarch,
					       reg->regnum))
		  warning (_("Remote reply is too short: %s"), buf);
d4407 2
a4408 2
		VEC_safe_push (cached_reg_t, event->regcache, &cached_reg);
	      }
d4410 5
a4414 6
	    if (*p != ';')
	      error (_("Remote register badly formatted: %s\nhere: %s"),
		     buf, p);
	    ++p;
	  }
      }
a4529 1
  int ret;
a4622 2
  struct remote_arch_state *rsa = get_remote_arch_state ();
  ptid_t event_ptid = null_ptid;
a4680 1
  struct remote_arch_state *rsa = get_remote_arch_state ();
d4682 1
a4682 3
  ULONGEST addr;
  int solibs_changed = 0;
  char *buf, *p;
d4903 1
a4903 3
  int i, buf_len;
  char *p;
  char *regs;
a5033 1
  struct remote_state *rs = get_remote_state ();
a5109 1
  struct remote_arch_state *rsa = get_remote_arch_state ();
a5187 1
  struct remote_state *rs = get_remote_state ();
a6677 1
  char *p;
a6848 1
  int bp_size;
a7213 1
  gdb_byte *wbuf;
a7257 1
  unsigned int total = 0;
d8588 1
a8588 1
  int retcode, fd, remote_errno, bytes, io_size;
@


1.365
log
@2009-07-29  Michael Snyder  <msnyder@@vmware.com>

	* remote.c (store_register_using_P): Call putpkt and getpkt
	directly instead of calling remote_send.
	(store_register_using_G): Ditto.
	(fetch_register_using_p): Ditto.
@
text
@d4888 4
a4891 2
      error (_("Could not fetch register \"%s\""),
	     gdbarch_register_name (get_regcache_arch (regcache), reg->regnum));
d5156 2
a5157 2
      error (_("Could not write register \"%s\""),
	     gdbarch_register_name (gdbarch, reg->regnum));
d5200 2
a5201 1
    error (_("Could not write registers"));
@


1.364
log
@	gdb/
	Conditional tracepoints.
	* ax-gdb.h (gen_eval_for_expr): Declare.
	* ax-gdb.c (gen_expr): Generate bytecodes for BINOP_EQUAL
	and other comparisons.
	(gen_eval_for_expr): New function.
	(agent_eval_command): New maintenance command.
	(_initialize_ax_gdb): Define the command.
	* remote.c (struct remote_state): New field cond_tracepoints.
	(PACKET_ConditionalTracepoints): New packet config type.
	(remote_cond_tracepoint_feature): New function.
	(remote_protocol_features): Add ConditionalTracepoints.
	(remote_supports_cond_tracepoints): New function.
	(_initialize_remote): Add ConditionalTracepoints.
	* tracepoint.c (download_tracepoint): Add conditional.
	* NEWS: Mention conditional tracepoints.

	gdb/doc/
	* gdb.texinfo (Tracepoint Conditions): New section.
	(General Query Packets): Describe ConditionalTracepoints.
	(Tracepoint Packets): Describe condition field.
	(Maintenance Commands): Describe maint agent-eval.
	* agentexpr.texi (Using Agent Expressions): Mention eval usage.

	gdb/testsuite/
	* gdb.trace/tracecmd.exp: Add basic test of tracepoint conditions.
@
text
@d4876 2
a4877 1
  remote_send (&rs->buf, &rs->buf_size);
d5125 2
a5126 1
store_register_using_P (const struct regcache *regcache, struct packet_reg *reg)
d5146 2
a5147 1
  remote_send (&rs->buf, &rs->buf_size);
d5195 4
a5198 1
  remote_send (&rs->buf, &rs->buf_size);
@


1.363
log
@	* remote.c (process_stop_reply): Access expedited target registers
	in target_gdbarch.
@
text
@d297 3
d999 1
d3022 9
d3057 2
d8758 7
d9208 3
@


1.362
log
@	* defs.h (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter.
	* utils.c (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter, use it instead of current_gdbarch.
	* ui-out.h (ui_out_field_core_addr): Add GDBARCH parameter.
	* ui-out.c (ui_out_field_core_addr): Add GDBARCH parameter,
	use it instead of current_gdbarch.

	Update calls to ui_out_field_core_addr to pass architecture:
	* ada-lang.c (print_one_exception): Update.
	* breakpoint.c (print_one_breakpoint_location,
	print_one_exception_catchpoint): Update.
	* disasm.c (dump_insns): Update.
	* darwin-nat-info.c (darwin_debug_regions_recurse): Update.
	* mi/mi-main.c (mi_cmd_data_read_memory): Update.
	* mi/mi-symbol-cmds.c: Include "objfiles.h".
	(mi_cmd_symbol_list_lines): Update.
	* stack.c (print_frame_info, print_frame): Update.

	Update callers of paddress to pass architecture:
	* ada-tasks.c (info_task): Update.
	* ada-valprint.c (ada_val_print_1): Update.
	* annotate.c (annotate_source, annotate_frame_begin): Update.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints,
	mention): Update.
	* cli/cli-cmds.c (edit_command, list_command, print_disassembly):
	Update.
	* corefile.c (memory_error): Update.
	* c-valprint.c (print_function_pointer_address, c_val_print): Update.
	* disasm.c (dis_asm_print_address): Update.
	* exec.c (print_section_info): Update.
	* f-valprint.c (f_val_print): Update.
	* infcmd.c: Include "arch-utils.h".
	(jump_command, program_info): Update.
	* linux-fork.c: Include "arch-utils.h".
	(info_forks_command): Update.
	* m2-valprint.c (print_function_pointer_address,
	print_unpacked_pointer, print_variable_at_address,
	m2_val_print): Update.
	* m32r-rom.c (m32r_load_section, m32r_load, m32r_upload_command):
	Update.
	* printcmd.c (print_address, print_address_demangle, address_info):
	Update.
	* p-valprint.c (pascal_val_print): Update.
	* source.c: Include "arch-utils.h".
	(line_info): Update.
	* stack.c (frame_info, print_block_frame_labels): Update.
	* symfile.c (add_symbol_file_command, list_overlays_command): Update.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1,
	print_symbol, print_partial_symbols, maintenance_info_psymtabs,
	maintenance_check_symtabs): Update.
	* symtab.c (find_pc_sect_symtab): Update.
	* target.c (deprecated_debug_xfer_memory): Update.
	* tracepoint.c (scope_info): Update.
	* tui/tui-stack.c (tui_make_status_line): Update.
	* valprint.c (val_print_string): Update.

	Update callers of paddr_nz to use paddress instead (keeping
	user-visible output identical):
	* alpha-tdep.c (alpha_heuristic_proc_start): Update.
	* amd64-tdep.c (fixup_riprel, amd64_displaced_step_copy_insn,
	amd64_displaced_step_fixup): Update.
	* arch-utils.c (simple_displaced_step_copy_insn): Update.
	* auxv.c (fprint_target_auxv): Update.
	* breakpoint.c (insert_single_step_breakpoint): Update.
	* buildsym.c (finish_block): Update.
	* cli/cli-dump.c (restore_section_callback): Update.
	* fbsd-nat.c (fbsd_find_memory_regions): Update.
	* frame.c (frame_unwind_register_value): Update.
	* gcore.c (gcore_create_callback): Update.
	* hppa-tdep.c (hppa_frame_cache, hppa_skip_trampoline_code): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_record_modrm,
	i386_record_lea_modrm_addr, i386_record_lea_modrm,
	i386_process_record): Update.
	* ia64-tdep.c (ia64_frame_this_id, ia64_sigtramp_frame_this_id,
	ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id,
	ia64_dummy_id, ia64_access_reg, ia64_access_rse_reg): Update.
	* infrun.c (displaced_step_prepare, displaced_step_fixup,
	handle_inferior_event, insert_step_resume_breakpoint_at_sal,
	insert_longjmp_resume_breakpoint): Update.
	* linux-nat.c (linux_nat_find_memory_regions): Update.
	* linux-record.c (record_linux_system_call): Update.
	* mips-tdep.c (heuristic_proc_start, mips_eabi_push_dummy_call,
	mips_n32n64_push_dummy_call, mips_o32_push_dummy_call,
	mips_o64_push_dummy_call): Update.
	* monitor.c (monitor_error, monitor_remove_breakpoint): Update.
	* record.c (record_arch_list_add_mem, record_wait,
	record_xfer_partial): Update.
	* remote-mips.c (mips_fetch_word, mips_check_lsi_error,
	mips_common_breakpoint): Update.
	* remote-sim.c (gdbsim_xfer_inferior_memory): Update.
	* rs6000-tdep.c (ppc_displaced_step_fixup): Update.
	* solib-som.c (som_current_sos): Update.
	* symfile.c (load_progress, generic_load): Update.
	* symfile-mem.c (add_vsyscall_page): Update.
	* valops.c (value_fetch_lazy): Update.
	* windows-tdep.c (windows_xfer_shared_library): Update.

	Update callers of paddr_nz to use paddress instead (changing
	user-visible output to make it more correct):
	* dwarf2loc.c (locexpr_describe_location): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint,
	ia64_memory_remove_breakpoint): Update.
	* jv-valprint.c (java_value_print): Update.
	* m32c-tdep.c (m32c_m16c_address_to_pointer): Update.
	* monitor.c (monitor_read_memory): Update.

	Update callers of paddr to use paddress instead (changing
	user-visible output to make it more correct):
	* arm-tdep.c (arm_push_dummy_call): Update.
	* breakpoint.c (insert_bp_location, create_thread_event_breakpoint,
	create_breakpoint): Update.
	* darwin-nat-info.c (darwin_debug_regions): Update.
	* dcache.c (dcache_info): Update.
	* dsrec.c (load_srec, make_srec): Update.
	* dwarf2-frame.c (dwarf2_restore_rule, execute_cfa_program,
	dwarf2_frame_cache): Update.
	* gcore.c (gcore_copy_callback): Update.
	* gnu-nat.c (gnu_xfer_memory): Update.
	* mips-linux-nat.c (mips_show_dr): Update.
	* monitor.c (monitor_write_memory, monitor_insert_breakpoint,
	monitor_remove_breakpoint): Update.
	* remote.c (compare_sections_command): Update.
	* remote-m32r-sdi.c (m32r_xfer_memory, m32r_insert_breakpoint,
	m32r_remove_breakpoint, m32r_insert_watchpoint,
	m32r_remove_watchpoint): Update.
	* sol-thread.c (info_cb): Update.
	* symfile.c (load_progress): Update.

	Update callers of paddress or paddr_nz to use hex_string instead
	(changes output of internal/error/debug messages only):
	* dwarf2read.c (dump_die_shallow): Update.
	* frame.c (fprint_field, fprint_frame, frame_pc_unwind,
	get_frame_func, create_new_frame): Update.
	* hppa-tdep.c (find_unwind_entry, unwind_command): Update.
	* ia64-tdep.c (get_kernel_table, ia64_find_proc_info_x,
	ia64_get_dyn_info_list): Update.
	* maint.c (maintenance_translate_address): Update.
	* mi/mi-cmd-var.c (mi_cmd_var_create): Update.
	* target.c (target_flash_erase): Update.

	Update callers of paddr/paddr_nz to use phex/phex_nz instead,
	using an appropriate address size.  Remove use of strlen_paddr.
	* exec.c (exec_files_info): Update.
	* i386-nat.c (i386_show_dr): Update.
	* remote.c (remote_flash_erase): Update.
	* m32r-rom.c (m32r_load_section): Update.
	* monitor.c (monitor_vsprintf, monitor_store_register): Update.
	* remote.c (remote_check_symbols, remote_search_memory): Update.
	* remote-mips.c (mips_request, mips_common_breakpoint): Update.
	* scm-valprint.c (scm_ipruk, scm_scmval_print): Update.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Update.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs,
	sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs,
	sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs,
	sh_dsp_show_regs): Update.
	* xcoffsolib.c (sharedlibrary_command): Update.


	* maint.c (maint_print_section_info): Add ADDR_SIZE parameter.
	Use hex_string_custom instead of paddr.
	(print_bfd_section_info): Pass address size.
	(print_objfile_section_info): Likewise.

	* annotate.h (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* annotate.c (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* source.c (identify_source_line): Update call to annotate_source.
	* stack.c (print_frame_info, print_frame): Update call to
	annotate_frame_begin.

	* breakpoint.c (describe_other_breakpoints): Add GDBARCH parameter.
	(create_breakpoint, create_ada_exception_breakpoint): Update call.

	* stack.c (print_block_frame_labels): Add GDBARCH parameter.
	(print_frame_label_vars): Update call.

	* symmisc.c (print_partial_symbols): Add GDBARCH parameter.
	(dump_psymtab): Update call to print_partial_symbols.
	(struct print_symbol_args): Add GDBARCH member.
	(dump_symtab_1): Set print_symbol_args architecture member.
	(print_symbol): Use it.

	* windows-tdep.h (windows_xfer_shared_library): Add GDBARCH
	parameter.
	* windows-tdep.c (windows_xfer_shared_library): Likewise.
	* i386-cygwin-tdep.c (struct cpms_data): Add GDBARCH member.
	(core_process_module_section): Pass architecture from cpms_data to
	windows_xfer_shared_library.
	(windows_core_xfer_shared_libraries): Initialize cmps_data
	architecture member.
	* windows-nat.c (windows_xfer_shared_libraries): Pass architecture
	to windows_xfer_shared_library.

	* defs.h (print_address): Add GDBARCH parameter.
	* printcmd.c (print_address): Add GDBARCH parameter.
	(print_scalar_formatted, do_examine): Update call.
	* findcmd.c (find_command): Update call.
	* tracepoint.c: Include "arch-utils.h".
	(trace_find_line_command): Update call.
	* tui/tui-disasm.c (tui_disassemble): Update call.

	* value.h (print_address_demangle): Add GDBARCH parameter.
	* printcmd.c (print_address_demangle): Add GDBARCH parameter.
	* c-valprint.c (print_function_pointer_address, c_val_print):
	Update call.
	* f-valprint.c (f_val_print): Update call.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update call.
	* jv-valprint.c (java_val_print): Update call.
	* m2-valprint.c (print_function_pointer_address, m2_val_print):
	Update call.
	* p-valprint.c (pascal_val_print): Update call.

	* disasm.c (gdb_disassemble_info): Install architecture into
	di.application_data field.

testsuite/ChangeLog:

	* gdb.threads/tls-shared.exp: Update to locexpr_describe_location
	change to prefix TLS offset in hex with 0x.

doc/ChangeLog:

	* gdbint.texinfo (Item Output Functions): Update signature
	for ui_out_field_core_addr.
@
text
@d4594 2
d4602 1
a4602 2
	    regcache_raw_supply (get_thread_regcache (ptid),
				 reg->num, reg->data);
@


1.361
log
@	* breakpoint.h (struct breakpoint): New member GDBARCH.
	* breakpoint.c: Include "arch-utils.h".
	(set_raw_breakpoint_without_location): Add GDBARCH parameter.
	Use it to set breakpoint architecture.
	(set_raw_breakpoint): Add GDBARCH parameter.
	(create_internal_breakpoint): Likewise.
	(create_catchpoint): Likewise.
	(create_fork_vfork_event_catchpoint): Likewise.
	(create_breakpoint): Likewise.
	(create_breakpoints): Likewise.
	(break_command_really): Likewise.
	(create_ada_exception_breakpoint): Likewise.
	Update local callers to pass architecture:
	(create_internal_breakpoint): Update.
	(create_overlay_event_breakpoint): Update.
	(create_longjmp_master_breakpoint): Update.
	(create_thread_event_breakpoint): Update.
	(create_solib_event_breakpoint): Update.
	(create_catchpoint): Update.
	(create_fork_vfork_event_catchpoint): Update.
	(set_momentary_breakpoint): Update.
	(clone_momentary_breakpoint): Update.
	(create_breakpoint): Update.
	(create_breakpoints): Update.
	(break_command_really): Update.
	(break_command_1): Update.
	(set_breakpoint): Update.
	(watch_command_1): Update.
	(catch_fork_command_1): Update.
	(catch_exec_commnd_1): Update.
	(handle_gnu_v3_exceptions): Update.
	(create_ada_exception_breakpoint): Update.
	(catch_ada_exception_command): Update.
	(catch_assert_command): Update.
	(trace_command): Update.

	* breakpoint.h (struct bp_location): New member GDBARCH.
	* breakpoint.c (get_sal_arch): New function.
	(set_raw_breakpoint): Set location architecture.
	(add_location_to_breakpoint): Likewise.
	(clone_momentary_breakpoint): Likewise.
	(watch_command_1): Likewise.
	(update_watchpoint): Likewise.
	(bp_loc_is_permanent): Use location architecture instead of
	current_gdbarch.
	(adjust_breakpoint_address): Add GDBARCH parameter; use it
	instead of current_gdbarch.
	Update callers of adjust_breakpoint_address to pass
	breakpoint location architecture:
	(set_raw_breakpoint): Update.
	(watch_command_1): Update.

        * tracepoint.c: (collect_symbol): Add GDBARCH parameter, use instead
	of current_gdbarch.
	(add_local_symbols): Add GDBARCH parameter.  Pass to collect_symbol.
	(encode_actions): Pass tracepoint architecture to add_local_symbols
	(encode_actions): Use tracepoint architecture instead of
	current_gdbarch.  Pass it to add_local_symbols and collect_symbol.

	* breakpoint.h (struct breakpoint_ops): Replace last_addr parameter
	of print_one callback with last_loc.
	* breakpoint.c (print_one_breakpoint_location): Replace last_addr
	parameter with last_loc.
	(print_one_breakpoint): Likewise.
	(do_captured_breakpoint_query): Update call.
	(breakpoint_1): Pass last_loc instead of last_addr to
	print_one_breakpoint.  Pass last location architecture instead of
	current_gdbarch to set_next_address.
	Update all implementations of the print_one callback:
	* breakpoint.c (print_one_catch_fork): Update.
	(print_one_catch_vfork): Update.
	(print_one_catch_exec): Update.
	(print_one_exception_catchpoint): Update.
	* ada-lang.c (print_one_exception): Update.
	(print_one_catch_exception): Update.
	(print_one_catch_exception_unhandled): Update.
	(print_one_catch_assert): Update.

	* breakpoint.c (print_one_breakpoint_location): Add PRINT_ADDRESS_BITS
	parameter.  Use it instead of gdbarch_addr_bit (current_gdbarch).
	(print_one_breakpoint): Add PRINT_ADDRESS_BITS parameter and pass it
	to print_one_breakpoint_location.
	(breakpoint_address_bits): New function.
	(do_captured_breakpoint_query): Compute number of address bits to print
	and pass it to print_one_breakpoint.
	(breakpoint_1): Likewise.  Use it instead of current_gdbarch.

	* breakpoint.h (create_thread_event_breakpoint): Add GDBARCH.
	* breakpoint.c (create_thread_event_breakpoint): Likewise.
	Update callers to create_thread_event_breakpoint:
	* aix-thread.c (pd_enable): Update.
	* linux-thread-db.c (enable_thread_event): Update.

	* breakpoint.h (create_solib_event_breakpoint): Add GDBARCH.
	* breakpoint.c (create_solib_event_breakpoint): Likewise.
	Update callers to create_solib_event_breakpoint:
	* solib-frv.c (enable_break, enable_break2): Update.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Update.
	* solib-som.c (som_solib_create_inferior_hook): Update.
	* solib-darwin.c (darwin_solib_create_inferior_hook): Update.
	* solib-svr4.c (enable_break): Update.

	* breakpoint.h (insert_single_step_breakpoint): Add GDBARCH.
	* breakpoint.c (insert_single_step_breakpoint): Likewise.
	Update callers to insert_single_step_breakpoint:
	* alpha-tdep.c (alpha_software_single_step): Update.
	* arm-linux-tdep.c (arm_linux_software_single_step): Update.
	* arm-tdep.c (arm_software_single_step): Update.
	* cris-tdep.c (cris_software_single_step): Update.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Update.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Update.
	* sparc-tdep.c (sparc_software_single_step): Update.
	* spu-tdep.c (spu_software_single_step): Update.
	* mips-tdep.c (deal_with_atomic_sequence): Add GDBARCH parameter.
	Pass it to insert_single_step_breakpoint.
	(mips_software_single_step): Pass architecture to
	deal_with_atomic_sequence and insert_single_step_breakpoint.

	* breakpoint.h (deprecated_insert_raw_breakpoint): Add GDBARCH.
	(deprecated_remove_raw_breakpoint): Likewise.
	* breakpoint.c (deprecated_insert_raw_breakpoint): Add GDBARCH.
	(deprecated_remove_raw_breakpoint): Likewise.
	Update callers to deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint:
	* breakpoint.c (single_step_gdbarch): New static variable.
	(insert_single_step_breakpoint): Pass GDBARCH parameter to
	deprecated_insert_raw_breakpoint.  Store it in single_step_gdbarch.
	(remove_single_step_breakpoints): Pass architecture stored in
	single_step_gdbarch to deprecated_remove_raw_breakpoint.
	* rs6000-nat.c (exec_one_dummy_insn): Update.
	* solib-irix.c (enable_break, disable_break): Update.
	* procfs.c (procfs_mourn_inferior): Update.
	(remove_dbx_link_breakpoint): Update.

	* breakpoint.h (set_breakpoint): Add GDBARCH parameter.
	(set_momentary_breakpoint, set_momentary_breakpoint_at_pc): Likewise.
	* breakpoint.c (set_breakpoint): Add GDBARCH parameter.
	(set_momentary_breakpoint, set_momentary_breakpoint_at_pc): Likewise.
	Update callers to set_breakpoint, set_momentary_breakpoint and
	set_momentary_breakpoint_at_pc:
	* breakpoint.c (set_momentary_breakpoint_at_pc): Update.
	(until_break_command): Update.
	* infcall.c (call_function_by_hand): Update.
	* infcmd.c (finish_backward, finish_forward): Update.
	* infrun.c (insert_step_resume_breakpoint_at_sal): Add GDBARCH
	parameter.  Pass it to set_momentary_breakpoint.
	(insert_longjmp_resume_breakpoint): Add GDBARCH parameter.
	Pass it to set_momentary_breakpoint_at_pc.
	(handle_inferior_event): Update.
	(insert_step_resume_breakpoint_at_frame): Update.
	(insert_step_resume_breakpoint_at_caller): Update..
	* mi/mi-cmd-break.c: Include "arch-utils.h".
	(mi_cmd_break_insert): Update.

	* target.h (struct target_ops): Add GDBARCH parameter to
	to_insert_breakpoint, to_remove_breakpoint, to_insert_hw_breakpoint,
	and to_remove_hw_breakpoint members.
	(target_insert_breakpoint, target_remove_breakpoint,
	target_insert_hw_breakpoint, target_remove_hw_breakpoint): Add GDBARCH
	parameter, pass to target routine.
	(memory_remove_breakpoint, memory_insert_breakpoint): Add GDBARCH
	parameter.
	* target.c (debug_to_insert_breakpoint, debug_to_remove_breakpoint,
	debug_to_insert_hw_breakpoint, debug_to_remove_hw_breakpoint): Add
	GDBARCH parameter, pass to target routine.
	(update_current_target): Update function signature.
	* breakpoint.c (insert_bp_location, remove_breakpoint,
	deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint):
	Pass architecture to target_ routines.
	Update all implementations of the target breakpoint routines to take
	GDBARCH parameter and use it instead of GDBARCH as appropriate:
	* corelow.c (ignore): Update.
	* exec.c (ignore): Update.
	* mem-break.c (memory_insert_breakpoint): Update.
	(memory_remove_breakpoint): Update.
	* monitor.c (monitor_insert_breakpoint): Update.
	(monitor_remove_breakpoint): Update.
	* record.c (record_insert_breakpoint): Update.
	(record_beneath_to_insert_breakpoint): Update.
	(record_remove_breakpoint): Update.
	(record_beneath_to_remove_breakpoint): Update.
	* remote.c (remote_insert_breakpoint): Update.
	(remote_remove_breakpoint): Update.
	(remote_insert_hw_breakpoint): Update.
	(remote_remove_hw_breakpoint): Update.
	* remote-m32r-sdi.c (m32r_insert_breakpoint): Update.
	(m32r_remove_breakpoint): Update.
	* remote-mips.c (mips_insert_breakpoint): Update.
	(mips_remove_breakpoint): Update.
	* i386-nat.c (i386_insert_hw_breakpoint): Update.
	(i386_remove_hw_breakpoint): Update.
	* nto-procfs.c (procfs_insert_breakpoint):  Update.
	(procfs_remove_breakpoint): Update.
	(procfs_insert_hw_breakpoint): Update.
	(procfs_remove_hw_breakpoint): Update.

doc/ChangeLog:

	* gdbint.texi (Examples of Use of @@code{ui_out} functions):
	Update example code extrated from breakpoint.c.
@
text
@d2880 1
d2890 1
a2890 1
		     paddr_nz (sym_addr), &reply[8]);
d5822 1
d5831 1
a5831 1
			    paddr (address),
d7174 3
a7176 2
	error (_("target memory fault, section %s, range 0x%s -- 0x%s"),
	       sectname, paddr (lma), paddr (lma + size));
d7183 3
a7185 2
      printf_filtered ("Section %s, range 0x%s -- 0x%s: ",
		       sectname, paddr (lma), paddr (lma + size));
d7505 1
d7544 1
a7544 1
		paddr_nz (start_addr),
@


1.360
log
@2009-06-22  H.J. Lu  <hongjiu.lu@@intel.com>

	PR server/10306
	* remote.c (getpkt_or_notif_sane_1): Initialize val to -1.
@
text
@d6795 2
a6796 1
remote_insert_breakpoint (struct bp_target_info *bp_tgt)
d6810 1
a6810 1
      gdbarch_breakpoint_from_pc (target_gdbarch, &addr, &bpsize);
d6838 1
a6838 1
  return memory_insert_breakpoint (bp_tgt);
d6842 2
a6843 1
remote_remove_breakpoint (struct bp_target_info *bp_tgt)
d6867 1
a6867 1
  return memory_remove_breakpoint (bp_tgt);
d7003 2
a7004 1
remote_insert_hw_breakpoint (struct bp_target_info *bp_tgt)
d7014 1
a7014 1
    (target_gdbarch, &bp_tgt->placed_address, &bp_tgt->placed_size);
d7047 2
a7048 1
remote_remove_hw_breakpoint (struct bp_target_info *bp_tgt)
@


1.359
log
@	* target.h (struct target_ops): Make to_has_all_memory,
	to_has_memory, to_has_stack, to_has_registers and to_has_execution
	methods instead of variables.
	(target_has_all_memory_1, target_has_memory_1, target_has_stack_1)
	(target_has_registers_1, target_has_execution_1): Declare
	functions.
	(target_has_all_memory): Rewrite to call target_has_all_memory_1.
	(target_has_memory): Rewrite to call target_has_memory_1.
	(target_has_stack): Rewrite to call target_has_all_stack_1.
	(target_has_registers): Rewrite to call target_has_registers_1.
	(target_has_execution): Rewrite to call target_has_execution_1.
	(default_child_has_all_memory, default_child_has_memory)
	(default_child_has_stack, default_child_has_registers)
	(default_child_has_execution): Declare.
	(target_mark_running, target_mark_exited): Delete declarations.
	* target.c (default_child_has_all_memory,
	default_child_has_memory, default_child_has_stack,
	default_child_has_registers, default_child_has_execution): New.
	(target_has_all_memory_1, target_has_memory_1, target_has_stack_1,
	target_has_registers_1, target_has_execution_1): New.
	(add_target): Default the to_has_all_memory, to_has_all_memory,
	to_has_memory, to_has_stack, to_has_registers and to_has_execution
	callbacks to return 0.
	(update_current_target): Do not inherit to_has_all_memory,
	to_has_memory, to_has_stack, to_has_registers or to_has_execution.
	(target_mark_running, target_mark_exited): Delete.
	(memory_xfer_partial): Adjust.
	(target_read_memory, target_write_memory, target_search_memory):
	Dispatch to the the top-most target, not the flattened
	current_target.
	(target_info): Adjust.
	(init_dummy_target): Install return_zero as callback for
	to_has_all_memory, to_has_memory, to_has_stack, to_has_registers,
	to_has_execution.
	(set_maintenance_target_async_permitted): Use have_live_inferiors
	instead of target_has_execution.
	* target-memory.c (target_write_memory_blocks): Dispatch memory
	writes to the the top-most target, not the flattened
	current_target.

	* breakpoint.c (insert_breakpoints): Don't check for
	target_has_execution here.
	(update_global_location_list): Check if there are live inferiors
	to debug instead of target_has_execution.
	* infcmd.c (kill_command, detach_command): Check if there are
	inferiors instead of target_has_execution.
	* inferior.h (have_live_inferiors): Declare.
	* inferior.c (have_live_inferiors): New.
	* infrun.c (normal_stop): Don't check for target_has_execution to
	finish the thread states.
	* thread.c (is_thread_state, is_stopped, is_exited, is_running)
	(any_running, is_executing): Remove checks for
	target_has_execution.
	* top.c (kill_or_detach): Don't try to kill core inferiors.
	(quit_target): Don't check for target_has_execution.

	* corelow.c (core_has_memory, core_has_stack, core_has_registers):
	New.
	(init_core_ops): Install core_has_memory, core_has_stack and
	core_has_registers.
	* exec.c (exec_has_memory): New.
	(init_exec_ops): Install exec_has_memory.
	* remote.c (remote_add_inferior): Don't call target_mark_running.
	(remote_start_remote): Don't call target_mark_exited or call
	target_mark_running.
	(remote_open_1): Use have_inferiors instead of
	target_has_execution.  Don't use target_mark_exited.
	(init_remote_ops): Install deafult_child_has_all_memory,
	default_child_has_memory, default_child_has_stack,
	default_child_has_registers, default_child_has_execution.
	* bsd-kvm.c (bsd_kvm_return_one): New.
	(bsd_kvm_add_target): Register bsd_kvm_return_one as
	to_has_memory, to_has_stack and to_has_registers callbacks.
	* remote-m32r-sdi.c (m32r_return_one): New.
	(init_m32r_ops): Register it.
	* inf-child.c (inf_child_target): Adjust to register
	default_child_has_all_memory, default_child_has_memory,
	default_child_has_stack, default_child_has_registers,
	default_child_has_execution callbacks.
	* gnu-nat.c (init_gnu_ops): Likewise.
	* go32-nat.c (init_go32_ops): Likewise.
	* hpux-thread.c (init_hpux_thread_ops): Likewise.
	* monitor.c (init_base_monitor_ops): Likewise.
	* nto-procfs.c (init_procfs_ops): Likewise.
	* remote-mips.c (_initialize_remote_mips): Likewise.
	* windows-nat.c (init_windows_ops): Likewise.
	* remote-sim.c (gdbsim_create_inferior): Don't use
	target_mark_running or target_mark_exited.
	(gdbsim_mourn_inferior): Don't call target_mark_exited.
	(init_gdbsim_ops): Adjust to register
	default_child_has_all_memory, default_child_has_memory,
	default_child_has_stack, default_child_has_registers,
	default_child_has_execution callbacks.

	* linux-nat.c (linux_nat_xfer_partial): If reading memory, and
	there's no inferior selected, defer to a lower stratum.
@
text
@d6383 1
a6383 1
  int val;
@


1.358
log
@	* remote.c (compare_sections_command): Don't declare exec_bfd.
	* tracepoint.c: Include "gdbcore.h".
	(remote_set_transparent_ranges): Don't declare exec_bfd.
@
text
@a1181 9
  /* This may be the first inferior we hear about.  */
  if (!target_has_execution)
    {
      if (rs->extended)
	target_mark_running (&extended_remote_ops);
      else
	target_mark_running (&remote_ops);
    }

d2682 1
a2682 8
	  if (args->extended_p)
	    {
	      /* We're connected, but not running.  Drop out before we
		 call start_remote.  */
	      target_mark_exited (args->target);
	      return;
	    }
	  else
d2684 4
d2777 1
a2777 8
	  if (args->extended_p)
	    {
	      /* We're connected, but not running.  Drop out before we
		 call start_remote.  */
	      target_mark_exited (args->target);
	      return;
	    }
	  else
d2779 4
a2784 3
      if (args->extended_p)
	target_mark_running (args->target);

d3194 1
a3194 1
  if (remote_desc != NULL && !target_has_execution)
d3212 1
a3212 1
  if (remote_desc != NULL && !target_has_execution)
a3254 4
  /* Assume that the target is not running, until we learn otherwise.  */
  if (extended_p)
    target_mark_exited (target);

a6660 6
	  else
	    {
	      /* Mark this (still pushed) target as not executable until we
		 restart it.  */
	      target_mark_exited (target);
	    }
a6661 3
      else
	/* Always remove execution if this was the last process.  */
	target_mark_exited (target);
d8775 5
a8779 5
  remote_ops.to_has_all_memory = 1;
  remote_ops.to_has_memory = 1;
  remote_ops.to_has_stack = 1;
  remote_ops.to_has_registers = 1;
  remote_ops.to_has_execution = 1;
@


1.357
log
@	* linux-nat.c (linux_nat_terminal_inferior)
	(linux_nat_terminal_ours): Don't check sync_execution.
	* remote.c (remote_terminal_inferior, remote_terminal_ours):
	Don't check sync_execution.  Update comments.
	* target.c (target_terminal_inferior): New.
	* target.h (target_terminal_inferior): Delete macro, and declare
	as function.
	* event-top.c (async_disable_stdin): Make idempotent.  Don't give
	the target the terminal here.
	* inflow.c (terminal_ours_1): Don't return early without setting
	`terminal_is_ours'.
@
text
@a7154 1
  extern bfd *exec_bfd;
@


1.356
log
@	* target.h (TARGET_WNOHANG): New.
	* target.c (target_wait): Add `options' argument.  Adjust.
	(struct target_ops) <to_wait>: Add `options' argument.
	(target_wait): Add `options' argument.
	* infrun.c (wait_for_inferior): Pass 0 as options to
	target_wait (blocking wait).
	(fetch_inferior_event): Pass TARGET_WNOHANG as options to
	target_wait.
	* fork-child.c (startup_inferior): Pass 0 as options to
	target_wait (blocking wait).
	* linux-nat.c (linux_nat_create_inferior): Remove async masking.
	(linux_nat_wait_1): Add `target_options' argument.  Use it instead
	of checking on target_can_async_p.
	(linux_nat_wait): Add `target_options' argument.  Adjust.
	* remote.c (remote_wait_ns): Add `options' argument.  Adjust to
	check on TARGET_WNOWAIT instead of checking on remote_is_async_p.
	(remote_wait_as): Add `options' argument.  Adjust to check on
	TARGET_WNOWAIT instead of checking on remote_is_async_p.  If doing
	a blocking wait, keep waiting until an interesting event comes
	out.
	(remote_wait): Add `options' argument.  Don't loop here if the
	target is in async mode, and a blocking wait has been requested.

	* top.c (deprecated_target_wait_hook): Add `options' argument.
	* linux-thread-db.c (thread_db_wait): Add `options' argument, and
	pass it down to the layer beneath.
	* inf-ptrace.c (inf_ptrace_wait): Add `options' argument.
	* record.c (record_beneath_to_wait): Add `options' argument.
	(record_wait): Add `options' argument, and pass it down to the
	layer beneath.
	* bsd-uthread.c (bsd_uthread_wait): Add `options' argument.
	* darwin-nat.c (darwin_wait): Likewise.
	* defs.h (deprecated_target_wait_hook): Likewise.
	* gnu-nat.c (gnu_wait): Add `options' argument.
	* go32-nat.c (go32_wait): Likewise.
	* hpux-thread.c (hpux_thread_wait): Add `options' argument, and
	pass it down to the layer beneath.
	* inf-ttrace.c (inf_ttrace_wait): Add `options' argument.
	* monitor.c (monitor_wait): Likewise.
	* nto-procfs.c (procfs_wait): Likewise.
	* remote-mips.c (mips_wait): Add `options' argument.
	* remote-sim.c (gdbsim_wait): Likewise.
	* rs6000-nat.c (rs6000_wait): Add `options' argument.
	* sol-thread.c (sol_thread_wait): Add `options' argument, and pass
	it down to the layer beneath.
	* spu-linux-nat.c (spu_child_wait): Add `options' argument.
	* windows-nat.c (windows_wait): Likewise.
	* tui/tui-hooks.c (tui_target_wait_hook): Likewise.  Adjust.
@
text
@d4081 6
a4086 13
  /* FIXME: cagney/1999-09-27: Shouldn't need to test for
     sync_execution here.  This function should only be called when
     GDB is resuming the inferior in the forground.  A background
     resume (``run&'') should leave GDB in control of the terminal and
     consequently should not call this code.  */
  if (!sync_execution)
    return;
  /* FIXME: cagney/1999-09-27: Closely related to the above.  Make
     calls target_terminal_*() idenpotent. The event-loop GDB talking
     to an asynchronous target with a synchronous command calls this
     function from both event-top.c and infrun.c/infcmd.c.  Once GDB
     stops trying to transfer the terminal to the target when it
     shouldn't this guard can go away.  */
a4104 3
  if (!sync_execution)
    return;
  /* See FIXME in remote_terminal_inferior.  */
@


1.355
log
@	* breakpoint.c (insert_breakpoints, breakpoint_init_inferior)
	(update_global_location_list): Use gdbarch_has_global_breakpoints
	instead of gdbarch_has_global_solist and
	target_supports_multi_process.
	* dicos-tdep.c (dicos_init_abi): Set
	gdbarch_has_global_breakpoints.
	* gdbarch.sh (has_global_solist): Update comment.
	(has_global_breakpoints): New.
	* remote.c (remote_start_remote): Use
	gdbarch_has_global_breakpoints instead of
	gdbarch_has_global_solist.
	* target.c (target_detach): Use gdbarch_has_global_breakpoints
	instead of gdbarch_has_global_solist.
	* infcmd.c (attach_command): Use gdbarch_has_global_solist instead
	of target_supports_multi_process.
@
text
@d4649 1
a4649 1
remote_wait_ns (ptid_t ptid, struct target_waitstatus *status)
d4691 1
a4691 1
      /* Still no event.  If we're in asynchronous mode, then just
d4693 1
a4693 1
      if (remote_is_async_p ())
d4699 1
a4699 2
      /* Otherwise, asynchronous mode is masked, so do a blocking
	 wait.  */
d4709 1
a4709 1
remote_wait_as (ptid_t ptid, struct target_waitstatus *status)
d4719 2
d4823 8
a4830 2
    /* Nothing interesting happened.  */
    return minus_one_ptid;
d4851 1
a4851 1
	     ptid_t ptid, struct target_waitstatus *status)
d4856 1
a4856 1
    event_ptid = remote_wait_ns (ptid, status);
d4858 1
a4858 11
    {
      /* In synchronous mode, keep waiting until the target stops.  In
	 asynchronous mode, always return to the event loop.  */

      do
	{
	  event_ptid = remote_wait_as (ptid, status);
	}
      while (status->kind == TARGET_WAITKIND_IGNORE
	     && !target_can_async_p ());
    }
@


1.354
log
@	* remote.c (remote_query_attached): Fix pasto in packet_ok result
	checking.
@
text
@d2827 2
a2828 3
  /* If code is shared between processes, then breakpoints are global
     too; Insert them now.  */
  if (gdbarch_has_global_solist (target_gdbarch)
@


1.353
log
@	* remote.c (append_resumption): New.
	(remote_vcont_resume): Use it.
@
text
@d1142 1
a1142 1
		     &remote_protocol_packets[PACKET_qAttached]) == PACKET_OK)
@


1.352
log
@	* remote.c (remote_notice_new_inferior): Use ptid_is_pid.  Check
	if the thread's ptid without a thread id field is in the list
	before calling thread_change_ptid.
	(extended_remote_attach_1): In non-stop mode, do not rely on
	querying the current thread, instead, query the thread list, and
	select the first thread of the process.
	* gdbthread.h (first_thread_of_process): Declare.
	* thread.c (first_thread_of_process): Define.
@
text
@d3675 44
d3749 2
d3757 1
a3757 8
      if (step && siggnal != TARGET_SIGNAL_0)
	xsnprintf (p, endp - p, "vCont;S%02x", siggnal);
      else if (step)
	xsnprintf (p, endp - p, "vCont;s");
      else if (siggnal != TARGET_SIGNAL_0)
	xsnprintf (p, endp - p, "vCont;C%02x", siggnal);
      else
	xsnprintf (p, endp - p, "vCont;c");
d3759 1
a3759 1
  else if (ptid_equal (ptid, minus_one_ptid))
d3761 5
a3765 2
      /* Resume all threads, with preference for INFERIOR_PTID.  */
      if (step && siggnal != TARGET_SIGNAL_0)
d3767 2
a3768 21
	  /* Step inferior_ptid with signal.  */
	  p += xsnprintf (p, endp - p, "vCont;S%02x:", siggnal);
	  p = write_ptid (p, endp, inferior_ptid);
	  /* And continue others.  */
	  p += xsnprintf (p, endp - p, ";c");
	}
      else if (step)
	{
	  /* Step inferior_ptid.  */
	  p += xsnprintf (p, endp - p, "vCont;s:");
	  p = write_ptid (p, endp, inferior_ptid);
	  /* And continue others.  */
	  p += xsnprintf (p, endp - p, ";c");
	}
      else if (siggnal != TARGET_SIGNAL_0)
	{
	  /* Continue inferior_ptid with signal.  */
	  p += xsnprintf (p, endp - p, "vCont;C%02x:", siggnal);
	  p = write_ptid (p, endp, inferior_ptid);
	  /* And continue others.  */
	  p += xsnprintf (p, endp - p, ";c");
d3770 3
a3772 2
      else
	xsnprintf (p, endp - p, "vCont;c");
d3777 1
a3777 24
      if (step && siggnal != TARGET_SIGNAL_0)
	{
	  /* Step ptid with signal.  */
	  p += xsnprintf (p, endp - p, "vCont;S%02x:", siggnal);
	  p = write_ptid (p, endp, ptid);
	}
      else if (step)
	{
	  /* Step ptid.  */
	  p += xsnprintf (p, endp - p, "vCont;s:");
	  p = write_ptid (p, endp, ptid);
	}
      else if (siggnal != TARGET_SIGNAL_0)
	{
	  /* Continue ptid with signal.  */
	  p += xsnprintf (p, endp - p, "vCont;C%02x:", siggnal);
	  p = write_ptid (p, endp, ptid);
	}
      else
	{
	  /* Continue ptid.  */
	  p += xsnprintf (p, endp - p, "vCont;c:");
	  p = write_ptid (p, endp, ptid);
	}
@


1.351
log
@	* remote.c (remote_stop_ns): If multi-process extensions are off,
	and GDB is requesting the whole process to stop, sent "vCont;t",
	not "vCont;t:-1"
@
text
@d1231 1
d1233 2
a1234 1
      if (ptid_equal (pid_to_ptid (ptid_get_pid (currthread)), inferior_ptid))
d1241 7
a1247 1
  	  thread_change_ptid (inferior_ptid, currthread);
d3495 2
d3499 6
a3504 2
  /* Now, if we have thread information, update inferior_ptid.  */
  inferior_ptid = remote_current_thread (inferior_ptid);
d3506 5
a3510 1
  remote_add_inferior (pid, 1);
d3512 3
a3514 3
  if (non_stop)
    /* Get list of threads.  */
    remote_threads_info (target);
d3516 7
a3522 2
    /* Add the main thread to the thread list.  */
    add_thread_silent (inferior_ptid);
@


1.350
log
@	* remote.c (remote_start_remote): In non-stop mode, call
	init_wait_for_inferior before adding threads and inferiors.
@
text
@d3948 2
a3949 1
  if (ptid_equal (ptid, minus_one_ptid))
a3954 1
      /* Step inferior_ptid.  */
@


1.349
log
@	* infrun.c (normal_stop): Use has_stack_frames instead of
	target_has_stack.
	* mi/mi-main.c (mi_execute_command): Avoid calling inferior_thread
	when there is no thread selected.
	(mi_cmd_execute): Don't special case commands that can run without
	a valid selected thread.
	* top.c (execute_command): Don't special case commands that can
	run without a valid selected thread.  Use has_stack_frames.
	* infcmd.c (ensure_valid_thread): New.
	(continue_1, step_1, jump_command, signal_command): Use it.
	(detach_command): Error out if there's no selected thread/inferior.
	* thread.c (print_thread_info): Allow having no thread selected.
	(switch_to_thread): Don't read the PC if there is no current thread.
	(do_restore_current_thread_cleanup): Don't record the current
	frame if there is no current thread.
	(make_cleanup_restore_current_thread): Don't read frame info if
	there is no selected thread.
	(_initialize_thread): Don't mark commands as
	"no_selected_thread_ok".
	* frame.c (get_current_frame): Error out if there is no valid
	selected thread.
	(has_stack_frames): Return false if there is no valid
	selected thread.
	* cli/cli-cmds.c (init_cli_cmds): Don't mark commands as
	"no_selected_thread_ok".
	* cli/cli-decode.c (set_cmd_no_selected_thread_ok)
	(get_cmd_no_selected_thread_ok): Delete.
	* cli/cli-decode.h (CMD_NO_SELECTED_THREAD_OK): Delete.
	(set_cmd_no_selected_thread_ok, get_cmd_no_selected_thread_ok):
	Delete declaration.
	* stack.c (get_selected_block): Use has_stack_frames.
@
text
@d2743 7
a2809 2

      init_wait_for_inferior ();
@


1.348
log
@	* remote.c (remote_close): Don't call generic_mourn_inferior.
	(remote_mourn_1): Call generic_mourn_inferior after closing the
	target.
@
text
@a6608 13
static int
select_new_thread_callback (struct thread_info *th, void* data)
{
  if (!is_exited (th->ptid))
    {
      switch_to_thread (th->ptid);
      printf_filtered (_("[Switching to %s]\n"),
		       target_pid_to_str (inferior_ptid));
      return 1;
    }
  return 0;
}

d6652 1
a6652 10
  if (have_inferiors ())
    {
      extern void nullify_last_target_wait_ptid ();
      /* Multi-process case.  The current process has exited, but
	 there are other processes to debug.  Switch to the first
	 available.  */
      iterate_over_threads (select_new_thread_callback, NULL);
      nullify_last_target_wait_ptid ();
    }
  else
@


1.347
log
@	* remote.c (remote_start_remote): Add missing call to
	init_wait_for_inferior in non-stop mode.
@
text
@a2400 2

  generic_mourn_inferior ();
d6605 2
a6606 1
  /* remote_close takes care of cleaning up.  */
@


1.346
log
@        Add a target_ops parameter to the to_kill method in struct target_ops.

        * target.h (struct target_ops): Add a "target_ops *" parameter to
        method to_kill.
        (target_kill): Remove macro. Add declaration.
        * target.c (debug_to_kill): Delete, no longer necessary.
        (target_kill): New function.
        (update_current_target):  Stop inheriting the to_kill method.
        Do not de_fault it to no_process either.
        (setup_target_debug): Do not set current_target.to_kill.
        * gnu-nat.c, go32-nat.c, hpux-thread.c, inf-ptrace.c, inf-ttrace.c,
        linux-nat.c, monitor.c, nto-procfs.c, procfs.c, remote-m32r-sdi.c,
        remote-mips.c, remote-sim.c, remote.c, windows-nat.c: Update
        accordingly.
@
text
@d2805 2
@


1.345
log
@2009-03-14  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* remote.c (PACKET_qAttached): New.
	(remote_query_attached): New.
	(remote_add_inferior): Add new `attached' argument.  Handle it.
	(remote_notice_new_inferior, remote_start_remote): Adjust to pass
	-1 to remote_add_inferior in new parameter.
	(extended_remote_attach_1): Adjust to pass 1 to
	remote_add_inferior in the new parameter.
	(extended_remote_create_inferior_1): Adjust to pass 0 to
	remote_add_inferior in the new parameter.
	(_initialize_remote): Add "set/show remote query-attached-packet"
	commands.

2009-03-14  Pedro Alves  <pedro@@codesourcery.com>

	gdb/gdbserver/
	* server.c (handle_query): Handle "qAttached".

2009-03-14  Pedro Alves  <pedro@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Remote Configuration): Document query-attached.
        (General Query Packets): Document qAttached.
@
text
@d114 1
a114 1
static void remote_kill (void);
d6531 1
a6531 1
remote_kill (void)
d6563 1
a6563 1
extended_remote_kill (void)
@


1.344
log
@	* inferior.h (notice_new_inferior): Declare.
	* infcmd.c (notice_new_inferior): New.
	* remote.c (remote_add_inferior, remote_add_thread): New.
	(notice_new_inferiors): Rename to...
	(remote_notice_new_inferior): ... this.  Add RUNNING argument.
	Use remote_add_thread instead of add_thread, passing it the
	RUNNING argument.  Add an inferior with remote_add_inferior.  If
	we just learned about an inferior, call notice_new_inferior.
	(record_currthread): Adjust.
	(remote_threads_info): Adjust to use remote_notice_new_inferior.
	(remote_start_remote, extended_remote_attach_1): Use remote_add_inferior.
	(process_stop_reply): Adjust.  Call remote_notice_new_inferior
	after handling expedited registers and watchpoint state.
	(extended_remote_create_inferior_1): Use remote_add_inferior.
@
text
@d995 1
d1122 36
d1160 5
a1164 1
   target with execution when we find the first inferior.  */
d1167 1
a1167 1
remote_add_inferior (int pid)
d1172 6
d1180 2
d1259 1
a1259 1
	inf = remote_add_inferior (ptid_get_pid (currthread));
d2717 1
a2717 1
      remote_add_inferior (ptid_get_pid (inferior_ptid));
a3441 1
  struct inferior *inf;
d3487 1
a3487 2
  inf = remote_add_inferior (pid);
  inf->attach_flag = 1;
d6811 1
a6811 1
  remote_add_inferior (ptid_get_pid (inferior_ptid));
d9211 3
@


1.343
log
@2009-02-25  Hui Zhu  <teawater@@gmail.com>

	* cli/cli-script.c (define_command): Add _() to query.
	* gnu-nat.c (inf_validate_task_sc): Ditto.
	* infcmd.c (kill_if_already_running): Ditto.
	(jump_command): Ditto.
	(attach_command): Ditto.
	* inflow.c (kill_command): Ditto.
	* infrun.c (handle_command): Ditto.
	* maint.c (maintenance_dump_me): Ditto.
	* memattr.c (mem_delete_command): Ditto.
	* monitor.c (monitor_interrupt_query): Ditto.
	* nto-procfs.c (interrupt_query): Ditto.
	* printcmd.c (undisplay_command): Ditto.
	* remote-mips.c (mips_kill): Ditto.
	* remote.c (interrupt_query): Ditto.
	* solib-irix.c (irix_open_symbol_file_object): Ditto.
	* solib-osf.c (osf_open_symbol_file_object): Ditto.
	* solib-pa64.c (pa64_open_symbol_file_object): Ditto.
	* solib-som.c (som_open_symbol_file_object): Ditto.
	* solib-svr4.c (open_symbol_file_object): Ditto.
	* symfile.c (symbol_file_add_with_addrs_or_offsets): Ditto.
	* target.c (kill_or_be_killed): Ditto.
	* tracepoint.c (delete_trace_command): Ditto.
	* top.c (quit_confirm): Add _() to s that will be used
	in query.
@
text
@d1121 27
d1149 1
a1149 1
notice_new_inferiors (ptid_t currthread)
d1151 17
d1175 1
a1175 1
      add_thread (currthread);
d1181 2
d1210 1
a1210 1
	add_inferior (ptid_get_pid (currthread));
d1213 7
a1219 1
      add_thread (currthread);
d1238 1
a1238 1
  notice_new_inferiors (currthread);
d2201 1
a2201 3
		  if (!ptid_equal (new_thread, null_ptid)
		      && (!in_thread_list (new_thread)
			  || is_exited (new_thread)))
a2202 11
		      /* When connected to a multi-process aware stub,
			 "info threads" may show up threads of
			 inferiors we didn't know about yet.  Add them
			 now, and before adding any of its child
			 threads, so notifications are emitted in a
			 sensible order.  */
		      if (!in_inferior_list (ptid_get_pid (new_thread)))
			add_inferior (ptid_get_pid (new_thread));

		      add_thread (new_thread);

d2204 1
a2204 1
			 are running until we proven otherwise with a
d2207 3
a2209 2
		      set_executing (new_thread, non_stop ? 1 : 0);
		      set_running (new_thread, non_stop ? 1 : 0);
a2647 3
	  if (args->extended_p)
	    target_mark_running (args->target);

d2668 1
a2668 1
      add_inferior (ptid_get_pid (inferior_ptid));
a3433 1
  target_mark_running (target);
d3439 1
a3439 1
  inf = add_inferior (pid);
a4546 2
      notice_new_inferiors (ptid);

d4563 2
d6764 1
a6764 1
  add_inferior (ptid_get_pid (inferior_ptid));
a6766 2
  target_mark_running (&extended_remote_ops);

@


1.342
log
@	* corelow.c (get_core_registers): Adjust.
	(core_file_thread_alive): Rename to...
	(core_thread_alive): ... this.
	(core_pid_to_str): Try gdbarch_core_pid_to_str first.
	(init_core_ops): Adjust.
	(coreops_suppress_target): Delete.
	(_initialize_corelow): Unconditionally add core_ops.
	* procfs.c: Include "inf-child.h".
	(procfs_ops): Delete.
	(init_procfs_ops): Delete.  Reimplement as...
	(procfs_target): ... this, inheriting from inf-child.
	(procfs_attach, procfs_detach, procfs_fetch_registers): Adjust.
	(procfs_prepare_to_store): Delete.
	(procfs_store_registers, procfs_resume): Adjust.
	(procfs_open): Delete.
	(procfs_suppress_run): Delete.
	(procfs_can_run): Delete.
	(procfs_mourn_inferior): Adjust.
	(procfs_init_inferior): Add target_ops parameter.  Adjust.
	(procfs_create_inferior): Don't pass procfs_init_inferior to
	fork_inferior.  Instead call it after fork_inferior returns.
	(procfs_find_new_threads): Adjust.
	(_initialize_procfs): Adjust to use procfs_target instead of
	init_procfs_ops.
	* sol-thread.c (orig_core_ops, sol_core_ops): Delete.
	(lwp_to_thread): Use target_thread_alive.
	(sol_thread_open): Delete.
	(sol_thread_attach): Delete.
	(sol_thread_detach, sol_thread_resume, sol_thread_wait)
	(sol_thread_fetch_registers, sol_thread_store_registers): Adjust
	to use find_target_beneath.
	(sol_thread_prepare_to_store, sol_thread_xfer_memory): Delete.
	(sol_thread_xfer_partial): Adjust to use find_target_beneath.
	(sol_thread_files_info, sol_thread_kill_inferior): Delete.
	(check_for_thread_db): New.
	(sol_thread_notice_signals, sol_thread_create_inferior): Delete.
	(sol_thread_new_objfile): Call check_for_thread_db.
	(sol_thread_mourn_inferior): Adjust to use find_target_beneath.
	(sol_thread_can_run): Delete.
	(sol_thread_alive): Adjust to use find_target_beneath.
	(sol_thread_stop): Delete.
	(rw_common): Use target_write_memory or target_read_memory.
	(ps_lgetregs, ps_lgetfpregs): Use target_fetch_registers.
	(ps_lsetregs, ps_lsetfpregs): Use target_store_registers.
	(solaris_pid_to_str): Remove check for libthread_db initialization
	failing.
	(sol_find_new_threads): Remove check for libthread_db
	initialization failing, or for an invalid inferior_ptid.  Adjust
	to use find_target_beneath.
	(sol_core_open, sol_core_close, sol_core_detach,
	sol_core_files_info, sol_find_memory_regions,
	sol_make_note_section, ignore): Delete.
	(init_sol_thread_ops): Make it a thread_stratum target.  Remove
	unneeded callback settings.
	(init_sol_core_ops): Delete.
	(_initialize_sol_thread): No longer call init_sol_core_ops, set
	procfs_suppress_run, or hack with core_ops.

	* target.h (struct target_ops): Add a target_ops * parameter to
	to_resume, to_fetch_registers, to_store_registers, to_thread_alive
	and to_find_new_threads.
	(target_fetch_registers, target_store_registers)
	(target_thread_alive, target_find_new_threads): Redeclare as
	function.

	* target.c (update_current_target): Do not inherit or de_fault
	to_resume, to_fetch_registers, to_store_registers,
	to_thread_alive, to_find_new_threads.
	(target_resume): Adjust.
	(target_thread_alive, target_find_new_threads): New.
	(debug_to_resume, debug_to_fetch_registers): Delete.
	(target_fetch_registers): New.
	(debug_to_store_registers): Delete.
	(target_store_registers): New.
	(debug_to_thread_alive, debug_to_find_new_threads): Delete.
	(setup_target_debug): Adjust.

	* gdbcore.h (core_ops): Delete declaration.

	* inf-ptrace.c, linux-nat.c, remote.c, amd64-linux-nat.c,
	inf-child.c, linux-thread-db.c, bsd-uthread.c, inf-ttrace.c,
	i386-sol2-tdep.c, darwin-nat.c, gnu-nat.c, go32-nat.c,
	hpux-thread.c, i386-linux-nat.c, i386fbsd-nat.c, monitor.c,
	nto-procfs.c, remote-m32r-sdi.c, remote-mips.c, windows-nat.c,
	alphabsd-nat.c, amd64bsd-nat.c, arm-linux-nat.c, armnbsd-nat.c,
	bsd-kvm.c, hppa-hpux-nat.c, hppa-linux-nat.c, hppabsd-nat.c,
	hppanbsd-nat.c, i386-darwin-nat.c, i386bsd-nat.c,
	ia64-linux-nat.c, m32r-linux-nat.c, m68kbsd-nat.c,
	m68klinux-nat.c, m88kbsd-nat.c, mips-linux-nat.c,
	mips64obsd-nat.c, mipsnbsd-nat.c, ppc-linux-nat.c, ppcnbsd-nat.c,
	ppcobsd-nat.c, remote-sim.c, rs6000-nat.c, s390-nat.c,
	shnbsd-nat.c, sparc-nat.c, sparc-nat.h, spu-linux-nat.c,
	vaxbsd-nat.c, xtensa-linux-nat.c: Adjust to target_ops changes.

	* gdbarch.sh (core_pid_to_str): New gdbarch callback.
	* gdbarch.h, gdbarch.c: Regenerate.

	* sol2-tdep.c: Include "inferior.h".
	(sol2_core_pid_to_str): New.
	* sol2-tdep.h (sol2_core_pid_to_str): Declare.

	* amd64-sol2-tdep.c (amd64_sol2_init_abi): Set it.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Set it.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Set it.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Set it.
@
text
@d3947 2
a3948 2
      if (query ("Interrupted while waiting for the program.\n\
Give up (and stop debugging it)? "))
@


1.341
log
@2008-02-21  Pedro Alves  <pedro@@codesorcery.com>

	Silence a few -Wmissing-prototypes warnings.

	PR build/9877:
	* amd64-nat.c: Include "amd64-nat.h".
	* fork-child.c (_initialize_fork_child): Ditto.
	* gcore.c (_initialize_gcore): Ditto.
	* inf-ptrace.c: Include "inf-ptrace.h".
	(inf_ptrace_store_registers): Make it static.
	* linux-nat.c (linux_nat_terminal_ours): Make it static.
	(_initialize_linux_nat): Declare before definition.
	* linux-tdep.c: Include "linux-tdep.h".
	* linux-thread-db.c (_initialize_thread_db): Declare before
	definition.
	* proc-service.c (_initialize_proc_service): Ditto.
	* remote.c (remote_send_printf): Make it static.
	* solib.c: Include "solib.h".
	* symfile-mem.c (_initialize_symfile_mem): Declare before
	definition.
	* ada-lang.c (ada_la_decode, ada_match_name)
	(ada_suppress_symbol_printing, ada_is_array_type)
	(ada_value_ptr_subscript, ada_array_length)
	(ada_to_static_fixed_value): Make them static.
	(_initialize_ada_language): Declare before definition.
	* ada-tasks.c (ada_get_task_number, ada_get_environment_task)
	(ada_task_list_changed, ada_new_objfile_observer): Make them
	static.
	(_initialize_tasks): Declare before definition.
	* addrmap.c (_initialize_addrmap): Declare before definition.
	* auxv.c (default_auxv_parse): Make it static.
	* bfd-target.c (target_bfd_xfer_partial, target_bfd_xclose): Make
	them static.
	* breakpoint.c (remove_sal): Add line break.
	(expand_line_sal_maybe): Make it static.
	* cp-name-parser.y: Include "cp-support.h".
	* cp-valprint.c (cp_find_class_member): Make it static.
	* eval.c (value_f90_subarray): Ditto.
	* exceptions.c (print_any_exception): Ditto.
	* findcmd.c (_initialize_mem_search): Declare before definition.
	* frame.c (frame_observer_target_changed): Make it static.
	* gnu-v3-abi.c (gnuv3_find_method_in): Make it static.
	* inf-child.c: Include "inf-child.h".
	* inferior.h (valid_inferior_id): Rename to ...
	(valid_gdb_inferior_id): ... this.
	* infrun.c (infrun_thread_stop_requested, siginfo_make_value):
	Make them static.
	* jv-lang.c (java_language_arch_info): Make it static.
	* m2-typeprint.c (m2_get_discrete_bounds): Ditto.
	* osdata.c (info_osdata_command): Make it static.
	* regcache.c (regcache_observer_target_changed): Make it static.
	* reverse.c (_initialize_reverse): Declare before definition.
	* stabsread.c (cleanup_undefined_types_noname)
	(cleanup_undefined_types_1): Make them static.
	* symfile.c (place_section): Make it static.
	* symtab.c (find_pc_sect_psymtab_closer): Make it static.
	* target-descriptions.c (_initialize_target_descriptions): Declare
	before definition.
	* target.c (default_get_ada_task_ptid, find_default_can_async_p)
	(find_default_is_async_p, find_default_supports_non_stop): Make
	them static.
	(target_supports_non_stop): Add prototype.
	(dummy_pid_to_str): Make it static.
	* utils.c (_initialize_utils): Declare before definition.
	* ada-exp.y (_initialize_ada_exp): Declare before definition.
	* solib-svr4.c (HAS_LM_DYNAMIC_FROM_LINK_MAP): Add a prototype.
	* target.h (struct target_ops): Add a prototype to the
	to_can_execute_reverse callback.
	* macroscope.c (_initialize_macroscope): Declare before definition.
	* cp-namespace.c (_initialize_cp_namespace): Declare before definition.
	* python/python.c (_initialize_python): Declare before definition.
	* tui/tui-command.c: Include "tui/tui-command.h".
	* tui/tui-data.c (init_content_element, init_win_info): Make them
	static.
	* tui/tui-disasm.c: Include "tui/tui-disasm.h".
	* tui/tui-interp.c (_initialize_tui_interp): Declare before
	definition.
	* tui/tui-layout.c: Include "tui/tui-layout.h".
	(_initialize_tui_layout): Declare before definition.
	* tui/tui-regs.c: Include "tui/tui-regs.h".
	(tui_display_reg_element_at_line): Make it static.
	(_initialize_tui_regs): Declare before definition.
	* tui/tui-stack.c (_initialize_tui_stack): Declare before
	definition.
	* tui/tui-win.c: Include "tui/tui-win.h".
	(_initialize_tui_win): Declare before definition.
	(tui_sigwinch_handler): Make it static.  Wrap in ifdef SIGWINCH.
	* tui/tui-win.h (tui_sigwinch_handler): Delete declaration.
	(tui_get_cmd_list): Add a prototype.
	* tui/tui-windata.c: Include tui-windata.h.
	* tui/tui-wingeneral.c (box_win): Make it static.
	* cli/cli-logging.c (show_logging_command): Make it static.
	(_initialize_cli_logging): Declare before definition.
	* mi/mi-common.c (_initialize_gdb_mi_common): Declare before
	definition.
@
text
@a93 4
static void remote_fetch_registers (struct regcache *regcache, int regno);

static void remote_resume (ptid_t ptid, int step,
                           enum target_signal siggnal);
a101 2
static void remote_store_registers (struct regcache *regcache, int regno);

a137 2
static int remote_thread_alive (ptid_t);

d1322 1
a1322 1
remote_thread_alive (ptid_t ptid)
d2128 1
a2128 1
remote_threads_info (void)
d2575 1
a2575 1
      remote_threads_info ();
d3408 1
a3408 1
    remote_threads_info ();
d3691 2
a3692 1
remote_resume (ptid_t ptid, int step, enum target_signal siggnal)
d4956 2
a4957 1
remote_fetch_registers (struct regcache *regcache, int regnum)
d5106 2
a5107 1
remote_store_registers (struct regcache *regcache, int regnum)
@


1.340
log
@2009-02-06  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* target.h (enum target_object): Add new TARGET_OBJECT_SIGNAL_INFO.
	* infrun.c (siginfo_value_read, siginfo_value_write): New.
	(siginfo_value_funcs): New.
	(siginfo_make_value): New.
	(_initialize_infrun): Create the $_siginfo convenience variable.
	* gdbtypes.h (append_composite_type_field_aligned): Declare.
	* gdbtypes.c (append_composite_type_field): Rename to...
	(append_composite_type_field_aligned): ... this.  Add ALIGNMENT
	argument.  Handle it.
	(append_composite_type_field): Rewrite on top of
	append_composite_type_field_aligned.
	* value.h (internalvar_make_value): New typedef.
	(struct internalvar) <make_value>: New field.
	(create_internalvar_type_lazy): Declare.
	* value.c (create_internalvar): Clear make_value.
	(create_internalvar_type_lazy): New.
	(value_of_internalvar): If make_value is set use it.
	(preserve_values): Skip internal variables that don't have a
	value.
	* gdbarch.sh (get_siginfo_type): New.
	* gdbarch.h, gdbarch.c: Regenerate.

	* linux-tdep.h, linux-tdep.c: New.
	* amd64-linux-tdep.c: Include "linux-tdep.h".
	(amd64_linux_init_abi): Register linux_get_siginfo_type and
	linux_get_siginfo_mapper.
	* i386-linux-tdep.c: Include "linux-tdep.h".
	(i386_linux_init_abi): Register linux_get_siginfo_type and
	linux_get_siginfo_mapper.
	* arm-linux-tdep.c: Include "linux-tdep.h".
	(i386_linux_init_abi): Register linux_get_siginfo_type and
	linux_get_siginfo_mapper.

	* linux-nat.c (linux_xfer_siginfo): New.
	(linux_nat_xfer_partial): Handle TARGET_OBJECT_SIGNAL_INFO.
	* remote.c (PACKET_qXfer_siginfo_read)
	(PACKET_qXfer_siginfo_write): New.
	(feature remote_protocol_features): Add "qXfer:siginfo:read" and
	"qXfer:siginfo:write" features.
	(remote_xfer_partial): Handle TARGET_OBJECT_SIGNAL_INFO.
	(_initialize_remote): Add "set/show remote read-siginfo-object"
	and "set/show remote write-siginfo-object" commands.

	* Makefile.in (ALL_TARGET_OBS): Add linux-tdep.o.
	(HFILES_NO_SRCDIR): Add linux-tdep.h.
	(ALLDEPFILES): Add linux-tdep.c.

	* configure.tgt (arm*-*-linux* | arm*-*-uclinux*)
	(i[34567]86-*-linux*, x86_64-*-linux*): Add linux-tdep.o to
	gdb_target_obs.

2009-02-06  Pedro Alves  <pedro@@codesourcery.com>

	gdb/gdbserver/
	* server.c (handle_query): Report qXfer:siginfo:read and
	qXfer:siginfo:write as supported and handle them.
	* target.h (struct target_ops) <qxfer_siginfo>: New field.
	* linux-low.c (linux_xfer_siginfo): New.
	(linux_target_ops): Set it.

2009-02-06  Pedro Alves  <pedro@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Signals): Document $_siginfo.
	(Convenience Variables): Mention $_siginfo.
	(Remote Configuration): Document qXfer:siginfo:read,
	qXfer:siginfo:write packets, and the read-siginfo-object,
	write-siginfo-object commands.

2009-02-06  Pedro Alves  <pedro@@codesourcery.com>

	gdb/testsuite/
	* gdb.base/siginfo-obj.c, gdb.base/siginfo-obj.exp: New.
@
text
@d5712 1
a5712 1
enum packet_result
@


1.339
log
@	* linux-nat.c (linux_nat_wait): Adjust.
	(linux_nat_pid_to_str): Adjust.  Remove call to thread_db_init.
	* linux-nat.h (thread_db_init): Delete declaration.
	* linux-thread-db.c (target_beneath): Delete.
	(thread_db_init): Delete.
	(thread_db_detach): Use find_target_beneath.
	(thread_db_wait): Adjust interface.  Use find_target_beneath.
	(thread_db_mourn_inferior): Use find_target_beneath.
	(thread_db_can_async_p, thread_db_is_async_p, thread_db_async)
	(thread_db_async_mask): Delete.
	(thread_db_pid_to_str): Adjust interface.  Use
	find_target_beneath.
	(thread_db_get_thread_local_address): Adjust interface.  Use
	find_target_beneath.
	(init_thread_db_ops): Delete references to delete functions.
	* target.c (update_current_target): Don't inherit or default
	to_wait.  Don't inherit to_pid_to_str and
	to_get_thread_local_address.
	(target_translate_tls_address): Look for a pushed target that
	implements to_get_thread_local_address, and use it instead of
	checking for target_get_thread_local_address_p.
	(target_wait, target_pid_to_str): Reimplement as functions.
	(dummy_pid_to_str): New.
	(init_dummy_target): Register it.
	(debug_to_wait): Delete.
	* target.h (struct target_ops): Make to_wait, to_pid_to_str and
	to_get_thread_local_address accept a pointer to struct target_ops.
	(target_wait): Delete macro, and declare as function.
	(target_pid_to_str): Likewise.
	(target_get_thread_local_address)
	(target_get_thread_local_address_p): Delete.
	(noprocess): Add NORETURN and ATTR_NORETURN tags.
	* inf-ptrace.c (inf_ptrace_wait): Adjust.
	(inf_ptrace_pid_to_str): New.
	(inf_ptrace_target): Use inf_ptrace_pid_to_str.
	* aix-thread.c (aix_thread_wait, aix_thread_pid_to_str): Adjust.
	* bsd-kvm.c (bsd_kvm_pid_to_str): Adjust.
	* bsd-uthread.c (bsd_uthread_wait, bsd_uthread_pid_to_str):
	Adjust.
	* corelow.c (core_pid_to_str): Adjust.
	* darwin-nat.c (darwin_wait, darwin_pid_to_str): Adjust.
	* dec-thread.c (dec_thread_wait, dec_thread_pid_to_str): Adjust.
	* gnu-nat.c (gnu_wait, gnu_pid_to_str): Adjust.
	* go32-nat.c (go32_wait, go32_pid_to_str): Adjust.
	* hpux-thread.c (hpux_thread_wait): Adjust.
	* inf-ttrace.c (inf_ttrace_wait, inf_ttrace_pid_to_str): Adjust.
	* monitor.c (monitor_wait, monitor_pid_to_str): Adjust.
	* nto-procfs.c (procfs_wait, procfs_pid_to_str): Adjust.
	* procfs.c (procfs_pid_to_str): Adjust.
	* remote-m32r-sdi.c (m32r_wait, m32r_pid_to_str): Adjust.
	* remote-mips.c (mips_wait): Adjust.
	* remote-sim.c (gdbsim_wait, gdbsim_pid_to_str): Adjust.
	* remote.c (remote_wait, remote_pid_to_str)
	(remote_get_thread_local_address): Adjust.
	* rs6000-nat.c (rs6000_wait): Adjust.
	* sol-thread.c (procfs_pid_to_str): Adjust declaration.
	(sol_thread_wait, solaris_pid_to_str): Adjust.
	* spu-linux-nat.c (spu_child_wait): Adjust.
	* windows-nat.c (windows_wait, windows_pid_to_str): Adjust.
@
text
@d1001 2
d2967 4
d7332 13
d9092 6
@


1.338
log
@	* remote.c (extended_remote_can_run): Delete.
	(init_remote_ops): Don't register it.
	* target.c (target_get_osdata): Don't check for target_can_run.
	Instead any target that has already been pushed, otherwise
	fallback to the default run target..
@
text
@a119 3
static ptid_t remote_wait (ptid_t ptid,
			   struct target_waitstatus *status);

d4733 2
a4734 1
remote_wait (ptid_t ptid, struct target_waitstatus *status)
d7770 1
a7770 1
remote_pid_to_str (ptid_t ptid)
d7801 2
a7802 1
remote_get_thread_local_address (ptid_t ptid, CORE_ADDR lm, CORE_ADDR offset)
@


1.337
log
@	* remote.c (extended_remote_mourn_1): Invalidate our notion of
	current general thread.
@
text
@a8676 9
static int
extended_remote_can_run (void)
{
  if (remote_desc != NULL)
    return 1;

  return 0;
}

a8761 1
  extended_remote_ops.to_can_run = extended_remote_can_run;
@


1.336
log
@        Updated copyright notices for most files.
@
text
@d6551 25
@


1.335
log
@	* remote.c (extended_remote_mourn_1): Always call
	generic_mourn_inferior.
@
text
@d4 1
a4 1
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
@


1.334
log
@	* remote.c (remote_detach_1): Don't delete the inferior here.
	(process_stop_reply): Ditto.
	(extended_remote_kill): Ditto.
@
text
@d6554 3
a6567 4
      struct remote_state *rs = get_remote_state ();

      /* Call common code to mark the inferior as not running.	*/
      generic_mourn_inferior ();
@


1.333
log
@	* remote.c (read_ptid): If we don't know about any inferior yet,
	use the pid of magic_null_ptid.
	(remote_start_remote): In the non-stop mode case, don't set
	inferior_ptid to magic_null_ptid here.
@
text
@a3318 1
  detach_inferior (pid);
d4512 2
a4513 2
  if (status->kind == TARGET_WAITKIND_EXITED
      || status->kind == TARGET_WAITKIND_SIGNALLED)
d4515 7
a4521 5
      int pid = ptid_get_pid (ptid);
      delete_inferior (pid);
    }
  else
    notice_new_inferiors (ptid);
d4523 7
a4529 5
  /* Expedited registers.  */
  if (stop_reply->regcache)
    {
      cached_reg_t *reg;
      int ix;
d4531 2
a4532 6
      for (ix = 0;
	   VEC_iterate(cached_reg_t, stop_reply->regcache, ix, reg);
	   ix++)
	regcache_raw_supply (get_thread_regcache (ptid),
			     reg->num, reg->data);
      VEC_free (cached_reg_t, stop_reply->regcache);
a4534 3
  remote_stopped_by_watchpoint_p = stop_reply->stopped_by_watchpoint_p;
  remote_watch_data_address = stop_reply->watch_data_address;

a6507 1
  delete_inferior (pid);
@


1.332
log
@	* remote.c (remote_parse_stop_reply): Use REG only after its NULL check.
@
text
@d1530 7
a1536 2
     what's in inferior_ptid.  */
  pid = ptid_get_pid (inferior_ptid);
a2583 7

      /* If we're not using the multi-process extensions, there's no
	 way to know the pid of the reported threads; use the magic
	 number.  */
      if (!remote_multi_process_p (rs))
	inferior_ptid = magic_null_ptid;

@


1.331
log
@	Implement -list-thread-groups --available

        * Makefile.in (XMLFILES): Add osdata.dtd.
        (SFILES): Add osdata.c.
        (COMMON_OBS): Add osdata.o.
        * linux-nat.c: Include pwd.h, sys/types.h, gdb_dirent.h and xml-support.h.
        (linux_nat_xfer_osdata): New function.
        (linux_xfer_partial): Handle TARGET_OBJECT_OSDATA.
        * osdata.c: New file.
        * osdata.h: New file.
        * remote.c (PACKET_qXfer_osdata): New packet enum.
        (remote_protocol_features): Add "qXfer:osdata:read".
        (remote_read_qxfer): Handle TARGET_OBJECT_OSDATA.
        (extended_remote_can_run): New.
        (init_extended_remote_ops): Set to_can_run to
        extended_remote_can_run.
        (_initialize_remote): Add packet config command for
        "qXfer:osdata:read".
        * xml-support.c (obstack_xml_printf): New function.
        * xml-support.h (obstack_xml_printf): Declare.
        * target.c (target_get_osdata): New function.
        * target.h (enum target_object): Add TARGET_OBJECT_OSDATA.
        (target_os_data): Declare.
        * features/osdata.dtd: New file.
        * mi/mi-main.c (mi_list_thread_groups): Handle the --available
        option.
@
text
@a4307 2
		cached_reg.num = reg->regnum;

d4321 2
@


1.330
log
@	PR gdb/2474
	* remote.c (remote_read_description_p): New function.
	(remote_start_remote): Try to fetch the target description
	before adding shared libraries.  Try again later if the
	target is running but stopped.
	(remote_open_1): Mark extended targets as exited by default.
	(remote_read_description): Check target_has_execution.
@
text
@d995 1
d2962 2
d7361 7
d8660 9
d8754 1
d9064 3
@


1.329
log
@	* remote.c (escape_buffer): New.
	(putpkt_binary, read_frame, getpkt_or_notif_sane_1): Use it.  Make
	sure debug output printing a packet buffer goes through a single
	fprintf_unfiltered call.
	* utils.c (vfprintf_unfiltered): If outputting timestamps, end
	output with a newline if it wasn't going to already.
@
text
@d237 2
d2554 4
a2562 4
  /* Next, if the target can specify a description, read it.  We do
     this before anything involving memory or registers.  */
  target_find_description ();

d2648 11
d3179 3
a3181 2
  /* Assume that the target is running, unless we learn otherwise.  */
  target_mark_running (target);
d7869 15
d7890 5
@


1.329.2.1
log
@2008-11-20  Stan Shebs  <stan@@codesourcery.com>

	Multi-process (primarily multi-exec) support.

	2008-10-14  Stan Shebs  <stan@@codesourcery.com>

	* blockframe.c (get_frame_block): Get inferior from frame.
	* block.c (block_for_pc_inf): New function.
	* block.h (block_for_pc_inf): Declare.
	* symfile.c (find_pc_inf_sect): New function.
	* symfile.h (find_pc_inf_sect): Declare.
	* symtab.c (find_pc_inf_line): New function.
	* symtab.h (find_pc_inf_line): Declare.
	* frame.c (struct frame_info) New field inferior.
	(fprint_frame_id): Display inferior.
	(get_frame_id): Set inferior_num from inferior.
	(frame_id_eq): Compare inferiors.
	(create_sentinel_frame): Set inferior.
	(create_new_frame): Copy inferior from sentinel.
	(get_prev_frame_raw): Copy inferior from next frame.
	(find_frame_sal): Use find_pc_inf_line.
	(get_frame_inferior): New function.
	* frame.h (struct frame_id): New field inferior_num.

	* breakpoint.c (expand_sals_by_inferiors): Copy section from input
	sal to expanded sals.
	* symtab.c (expand_line_sal): Ditto.

	2008-10-10  Stan Shebs  <stan@@codesourcery.com>

	* remote.c (discard_pending_stop_replies): Initialize prev.
	* infrun.c (infrun_thread_stop_requested): Ditto.

	2008-10-08  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (struct inferior): Rename environ field to inf_environ.
	* inferior.c (print_inferior): Ditto.

	2008-10-01  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (detach_fork): Declare here...
	* linux-fork.h (detach_fork): ...instead of here.
	* linux-fork.c (detach_fork): Move to...
	* infrun.c (detach_fork): ...here.
	* remote.c (detach_fork): Remove decl.

	2008-09-30  Stan Shebs  <stan@@codesourcery.com>

	* linespec.c (decode_line_1): Better default for one-exec case.
	* remote (remote_start_remote): Use the exec in the one-exec case.

	2008-09-29  Stan Shebs  <stan@@codesourcery.com>

	* infcmd.c (attach_command): If only one exec, assume it is the
	attached inferior's exec.
	(attach_command_post_wait): Set inferior's exec from
	the one that was found.
	* inf-ptrace.c (inf_ptrace_attach): Only report exec file if
	if there is just one present.
	(inf_ptrace_detach): Use inferior to get correct exec name.

	2008-09-29  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (print_inferior): Use exec short names, and drop
	unused address space display.

	2008-09-26  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (should_be_inserted): Test for no inferior.
	(clone_breakpoint_location): New function, broken out from...
	(update_breakpoint_inferiors): ...here, also tweak conditions
	for adding a location.
	(insert_breakpoint_location): Don't count non-running inferiors.
	(remove_breakpoint): Set tmp_inf.
	(print_one_breakpoint_location): Add allflag arg, use to always
	show inf.
	(print_one_breakpoint): Add allflag arg.
	(do_captured_breakpoint_query): Fix caller.
	(breakpoint_1): Ditto.
	* exec.c (create_exec): Save full pathname as exec name.
	(find_exec_by_name): Use find_exec_by_substr.
	* fork-child.c (fork_inferior): Warn if exec not found for new
	inferior.

	2008-09-25  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (should_be_inserted): Don't insert in inferiors
	that are not running.
	(update_breakpoint_inferiors): New function.
	(insert_breakpoints): Call it.
	(insert_breakpoint_locations): Don't insert in inferiors that are
	not running.
	(set_raw_breakpoint_without_location): Set trigger set from
	current itset here...
	(set_raw_breakpoint): Instead of here. Also add default fillins
	for the location's inferior.
	(add_location_to_breakpoint): Similarly.
	(expand_sals_by_inferiors): New function.
	(breakpoint_re_set_one): Call it.
	(resolve_sal_pc): Don't set sal inferior.
	* breakpoint.h (struct breakpoint): Remove exec field, never used.
	* inferior.h (inferior_list): Declare.
	* inferior.c (inferior_list): Make public.
	(add_inferior_to_itset): Auto-add inferiors after exec's inferior.
	(first_inferior_in_set): Check for zero-length vector.
	* exec.c (xfer_memory): Use tmp_inf as inferior if set.
	* infcmd.c (focus_command): Improve user feedback.
	* linespec.c (build_canonical_line_spec): Record exec name as part
	of canonical spec.
	(symbol_found): Canonicalize specs more.
	(decode_indirect): Revert rewrite from 2008-09-14.
	(decode_sharp): Use find_exec_by_substr, better error messages.
	* minsyms.c (lookup_minimal_symbol_in_exec): New function.
	(lookup_minimal_symbol_in_exec_1): New function, body of
	lookup_minimal_symbol.
	* symtab.h (lookup_minimal_symbol_in_exec): Declare.
	* symtab.c (find_function_start_sal): Set inferior to use.
	(append_expanded_sal): Return pointer to the new sal.
	* remote.c (remote_xfer_memory): Better parms to ptid_build, remove
	debug print.
	(remote_xfer_partial): Ditto.

	2008-09-22  Pedro Alves  <pedro@@codesourcery.com>

	* inferior.c (itset_member): Fix typo.

	2008-09-22  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (current_inf): Remove declaration.
	(tmp_inf): Declare.
	* inferior.c (current_inf): Remove.
	(tmp_inf): New global, hack to bypass passing inferior throughout
	target stack.
	(print_inferior): Don't report current_inf.
	(add_inferior_command): Don't use current_inf.
	(name_inferior_command): Use first inferior of current_itset.
	(update_itset): Handle NULL case.
	(add_inferior_itset): Recursively add all inferiors derived from
	an exec if the exec's own inferior is present.
	(first_inferior_in_set): New function.
	(free_inferior): Comment out until references cleared reliably.
	* infcmd.c (focus_command): Don't set current_inf.
	(get_inferior_args): Use first_inferior_in_set instead of
	current_inf.
	(set_inferior_args): Ditto.
	(set_inferior_args_vector): Ditto.
	(notice_args_set): Ditto.
	* breakpoint.c (insert_breakpoint_locations): Remove insertion test
	using current_inf, set tmp_inf.
	(reattach_breakpoints): Set tmp_inf.
	(bpstat_check_breakpoint_conditions): Test trigger set here...
	(bpstat_stop_status): ... instead of here.
	(bpstat_check_trigger_set): Add special case for exec's own
	inferior.
	(print_one_breakpoint_location): Also test for multiple inferiors
	before displaying location's inferior, flag trigger set with "i/t"
	instead of "focus".
	(check_duplicates): Pass location's inferior to...
	(check_duplicates_for): Add inferior arg and use.
	(set_raw_breakpoint): Override sal inferior with one from the
	trigger set.
	(add_location_to_breakpoint): Ditto.
	* remote.c (remote_xfer_memory): Switch inferiors if tmp_inf is
	set to something different from inferior_ptid.
	(remote_xfer_partial): Ditto.
	* top.c (execute_command): Always update the current itset.

	2008-09-19  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (set_inferior_exec): New function.
	(set_inferior_exec_command): New command.
	* inferior.h: Declare set_inferior_exec.
	* fork-child.c (fork_inferior): Set the inferior's exec.
	* remote.c (extended_remote_create_inferior_1): Ditto.
	gdb/doc/
	* gdb.texinfo (Debugging Multiple Programs): Describe set-exec.

	2008-09-18  Stan Shebs  <stan@@codesourcery.com>

	* target.c (target_resize_to_sections): Adjust execs' section
	tables too.

	2008-09-17  Stan Shebs  <stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Invoking GDB): Describe multiple program args.
	(File Options): Describe multi-program effects.
	(Multiple Programs): New section, multi-program debugging.
	(Forks): Rename section from "Processes".
	(Specify Location): Describe the #-syntax.
	(Variables): Describe the #-syntax.
	(Files): Describe add-file and add-exec-file.
	(Maintenance Commands): Describe maint print execs.

	2008-09-15  Stan Shebs  <stan@@codesourcery.com>

	* exec.c (addr_space_info_command): Don't try to display host address.

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* c-exp.y: (yylex): Accept '#' in identifiers.
	* linespec.c (decode_sharp): New function.
	(decode_line_1): Use it for #-syntax.
	(decode_indirect): Rewrite to accept exec arg and iterate over
	inferiors.
	(struct d_i_data): New struct for inferior iteration.
	(decode_indirect_callback): New function.
	(decode_variable): Pass in exec, use in symbol lookup.

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.h (struct bp_location): Add inferior field instead
	of address space field.
	* breakpoint.c (insert_breakpoint_locations): Only insert in
	appropriate inferior.
	(bpstat_check_trigger_set): New function.
	(bpstat_stop_status): Call it, check location's inferior also.
	(print_one_breakpoint_location): Report location's inferior.
	(set_raw_breakpoint): Set location inferior, clear an experiment.
	(add_location_to_breakpoint): Ditto.
	(expand_line_sal_maybe): Check for non-NULL original function.
	(resolve_sal_pc): Set sal inferior.
	(clear_command): Be careful to not clear anything twice.
	* symtab.h: Update declarations of symbol lookups.
	(struct symtab_and_line): Change address space to inferior field.
	* symtab.c (init_sal): Clear inferior field.
	(append_expanded_sal): Set inferior.
	(lookup_symbol_in_language_1): New function.
	(lookup_symbol_in_language): Call it.
	(lookup_symbol_in_exec_in_language): New function.
	(lookup_symbol): Detect #-syntax and find exec to use.
	(lookup_symbol_aux): Add exec argument and use it.
	(lookup_symbol_aux_symtabs): Ditto.
	(lookup_symbol_aux_psymtabs): Ditto.
	(basic_lookup_symbol_nonlocal): Ditto.
	(lookup_symbol_static): Ditto.
	(lookup_symbol_global): Ditto.
	* ada-lang.c (cp_lookup_symbol_nonlocal): Ditto.
	* cp-support.h (cp_lookup_symbol_nonlocal): Ditto.
	* cp-namespace.c (cp_lookup_symbol_nonlocal): Ditto.
	* language.h (struct language_defn): Ditto.
	* scm-valprint.c (scm_inferior_print): Add exec arg to
	lookup_symbol_global.
	* source.c (select_source_symtab): Use current_exec.
	* addrspace.h (struct addr_space): New field num.
	* exec.h (struct exec): New fields sections and sections_end.
	* exec.c (exec_file_attach_1): Set them from exec_ops, set
	inferior's address space name from exec.
	(find_exec_by_substr): New function.
	(build_section_table): Don't free old table.
	(print_section_info): Use exec's section table.
	(next_address_space_num): New global, numbering for address spaces.
	(new_address_space): Use it.
	(addr_space_info_command): Display it.
	* infcmd.c (set_current_exec): Set exec_ops section table.
	* inferior.h (update_itset): Declare.
	* inferior.c (add_inferior_silent): Set address space.
	(print_inferior): Display it.
	(number_of_inferiors): New function.
	(itset_member): New function.

	2008-09-04  Stan Shebs  <stan@@codesourcery.com>

	* corefile.c (close_exec_file): Remove #if 0 block.
	(validate_files): Use first_exec instead of exec_bfd.
	(get_exec_file): Ditto.
	* corelow.c (core_open): Ditto.
	* utils.c (string_to_core_addr): Ditto.
	* arch-utils.c (gdbarch_update_p): Ditto.
	* linux-thread-db.c (enable_thread_event): Ditto.
	(thread_db_get_thread_local_address ): Ditto.
	* exec.c (find_exec_by_name): Test short name also.
	(file_command): Set current exec.

	2008-09-03  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (add_threads_to_itset): Default to including all
	of an inferior's threads.

	2008-08-31  Stan Shebs  <stan@@codesourcery.com>

	Parsing for i/t sets.
	* inferior.h (struct itset_entry): New struct.
	(struct itset): Make thread lists be per-inferior, add parse state
	variables.
	* inferior.c: (add_inferior_command): Add error checking and
	confirmation.
	(remove_inferior_command): Update for itset restructuring.
	(new_itset): Don't pass in dynamic-ness, call parse_itset_spec.
	(update_itset): Similarly.
	(parse_itset_spec): New, parsing of itset spec.
	(parse_itset_list, parse_itset_range, etc): New.
	(make_itset_from_spec): Rewrite.
	(dump_itset): Rewrite to reflect itset structure.
	* infcmd.c (focus_command): Similarly.

	2008-08-25  Stan Shebs  <stan@@codesourcery.com>

	First part of multiprocess support.
	* Makefile.in (COMMON_OBS): Add inferior.o.
	* addrspace.h: New file.
	* breakpoints.h (struct bp_location): Add address space field.
	(struct breakpoint): Add trigger set and exec fields.
	* breakpoints.c (print_one_breakpoint_location): Display trigger
	set.
	(set_raw_breakpoint): Set trigger set from current itset.
	* corefile.c (reopen_exec_file): Rewrite for multiple execs.
	(get_exec_file): Add case for current_exec.
	* corelow.c (is_core_file): New function.
	(core_files_info): Pass additional arg to print_section_info.
	* exec.h (struct exec): New struct.
	* exec.c (execs): New global.
	(exec_bfd_mtime): Remove.
	(last_exec_created, current_exec, first_exec): New globals.
	(exec_close): Clear all exec objects.
	(exec_file_clear): Tweak user message.
	(exec_file_add): New function.
	(exec_file_attach_1): New function, body of exec_file_attach,
	plus new code to handle multiple execs.
	(exec_file_attach): Call it.
	(exec_file_update): New function.
	(create_exec, find_exec_by_name, number_of_execs): New functions.
	(exec_file_command): Rephrase query, set current exec.
	(add_exec_file_command): New command.
	(add_file_command): New command.
	(print_section_info): Add exec argument.
	(exec_files_info): Rewrite for multiple execs.
	(maintenance_print_execs): New function.
	(new_address_space): New function.
	(addr_space_info_command): New command.
	* gdbcore.h (exec_bfd_mtime): Remove decl.
	(exec_file_add): Declare.
	* infcmd.c: Include exec.h.
	(current_itset): New global.
	(set_current_exec): New function.
	(focus_command): New command.
	(get_inferior_args): Maybe get from the current inferior.
	(set_inferior_args): Also set in current inferior.
	(set_inferior_args_vector): Similarly.
	(notice_args_set): Similarly.
	(attach_command): Rephrase query.
	* inferior.h (struct inferior): New struct.
	(struct itset): New struct.
	* inferior.c: New file, management of multiple inferiors.
	* main.c (captured_main): Rewrite to allow multiple executables,
	pids, and corefiles on the command line.
	* maint.c (maintenance_info_sections): Rewrite for multiple execs.
	* objfiles.h (struct objfile): New field for exec.
	(ALL_OBJFILES_FOR_EXEC, ALL_PRIMARY_SYMTABS_FOR_EXEC,
	ALL_PSYMTABS_FOR_EXEC): New macros.
	* objfiles.c (allocate_objfile): Clear exec field.
	* solib.c (clear_solib): Use first_exec instead of exec_bfd.
	* source.c (select_source_symtab): Use ALL_OBJFILES_FOR_EXEC.
	(find_source_lines): Use mtime from exec.
	* symfile.c (syms_from_objfile): Don't clear objfile if multiple
	execs.
	(new_symfile_objfile): Get objfile's exec from last_exec_created.
	(symbol_file_clear): Rephrase messages.
	(reread_symbols): Update objfile's exec if necessary.
	* symmisc.c (dump_objfile): Dump objfile's exec also.
	(maintenance_print_objfiles): Report symfile_objfile.
	* symtab.h (struct symtab_and_line): Add address space field.
	* symtab.c (find_pc_sect_psymtab): Look for a plausible exec, and
	then use it.
	(lookup_symbol_aux_symtabs): Use current exec.
	(lookup_symbol_aux_symtabs): Ditto.
	(basic_lookup_transparent_type): Ditto.
	(find_pc_sect_symtab): Ditto.
	* target.h (print_section_info): Add arg to decl.
	* tui/tui-win.c: Rename "focus" command to "ffocus".

gdb/testsuite:

2008-11-20  Stan Shebs  <stan@@codesourcery.com>

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* gdb.gdb/selftest.exp: Update to reflect current sources.
	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* configure.ac (AC_OUTPUT): Add gdb.multi/Makefile.
	* configure: Regenerate.

	* gdb.multi/Makefile.in: New.
	* gdb.multi/hello.c, hangout.c, goodbye.c: New source files.
	* gdb.multi/base.exp: New file, basic multiprocess tests.

	2008-08-25  Stan Shebs  <stan@@codesourcery.com>

	* config/monitor.exp: Match on rephrased message.
	* gdb.base/attach.exp: Ditto.
	* gdb.base/default.exp: Ditto.
	* lib/gdb.exp: Ditto.
@
text
@a27 1
#include "exec.h"
a2507 1
  struct inferior *inf;
d5683 1
a5683 8
  if (tmp_inf && tmp_inf->pid != ptid_get_pid (inferior_ptid))
    {
      ptid_t tmp_ptid;
      tmp_ptid = ptid_build (tmp_inf->pid, 0, 0);
      set_general_thread (tmp_ptid);
    }
  else
    set_general_thread (inferior_ptid);
a6663 2
  struct inferior *inf;

d6695 1
a6695 4
  inf = add_inferior (ptid_get_pid (inferior_ptid));

  set_inferior_exec (inf, find_exec_by_name (exec_file));

d7252 1
a7252 9
  
  if (tmp_inf && tmp_inf->pid != ptid_get_pid (inferior_ptid))
    {
      ptid_t tmp_ptid;
      tmp_ptid = ptid_build (tmp_inf->pid, 0, 0);
      set_general_thread (tmp_ptid);
    }
  else
    set_general_thread (inferior_ptid);
@


1.329.2.2
log
@2008-11-25  Pedro Alves  <pedro@@codesourcery.com>

	2008-11-25  Pedro Alves  <pedro@@codesourcery.com>

	* linux-fork.c (detach_fork): Delete declaration.
	(_initialize_linux_fork): Move "set detach-on-fork"
	command to ...
	* infrun.c (_initialize_infrun): ... here.
	* inferior.h (detach_fork): Declare.

	2008-11-10  Pedro Alves  <pedro@@codesourcery.com>

	* remote.c (read_ptid): If we don't know about any inferior yet,
	use the pid of magic_null_ptid.
	(remote_start_remote): Don't set inferior_ptid to magic_null_ptid
	here.

	2008-10-14  Pedro Alves  <pedro@@codesourcery.com>

	* remote.c (remote_start_remote): Mask async mode while collecting
	the initial event, use notice_new_inferior.

	2008-10-12  Pedro Alves  <pedro@@codesourcery.com>

	* infcmd.c (attach_command_post_wait): Set the inferior exec here.
	(attach_command): Don't set the inferior exec here.
	(notice_new_inferior): New.
	* inferior.h (notice_new_inferior): Declare.
	* remote.c (notice_new_inferiors): Add `stopping' argument.  Add
	the inferior before adding the threads.  Call notice_new_inferior.
	(record_currthread): Adjust.
	(remote_threads_info): Add the inferior before adding the thread.
	Call notice_new_inferior.

	2008-10-09  Pedro Alves  <pedro@@codesourcery.com>

	* remote.c (notice_new_inferiors): If there's only one exec, set
	it in the new inferior.
	(set_thread): If setting the thread failed, assume the thread has
	terminated.

	2008-09-17  Pedro Alves  <pedro@@codesourcery.com>

	* inferior.c (delete_inferior_1): Free the inferior after freeing
	its threads.

	2008-09-16  Pedro Alves  <pedro@@codesourcery.com>

	* inferior.h (discard_all_inferiors): Declare.
	* inferior.c (delete_inferior): Rename to...
	(delete_inferior_1): ...this.  Add 'silent' argument.  If this
	inferior is has pid not zero, delete its threads.
	(delete_inferior): New, as wrapper around delete_inferior_1.
	(delete_inferior_by_pid_1): Reimplement.
	(discard_all_inferiors): New.

	2008-09-15  Pedro Alves  <pedro@@codesourcery.com>

	* remote.c (extended_remote_attach_1): Don't set target_attach_no_wait.

	2008-09-15  Pedro Alves  <pedro@@codesourcery.com>

	* frame.c (get_current_frame, has_stack_frames): Check for
	null_ptid.
	* top.c (execute_command): Likewise.

	2008-08-29  Pedro Alves  <pedro@@codesourcery.com>

	* inferior.c (have_real_inferiors): New.
	* inferior.h (have_real_inferiors): Declare.
	* remote.c (extended_remote_mourn_1): Use it.
	* top.c (quit_target): Use it.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* remote.c (parse_stop_reply): Handle Y;exec.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* infcmd.c (struct exec_file_attach_wrapper_args): New.
	(exec_file_attach_wrapper): New.
	(attach_command_post_wait): If there's a sysroot, prepend it to
	the target reported exec file path.  Continue attaching to the
	inferior event if attaching to the exec file fails.

	* remote.c (remote_pid_to_exec_file): Rebustify.  Expect
	"QExecFile:PID;" in the reply.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* remote.c (record_currthread): If setting the current thread to
	minus_one_ptid, don't pass that to the stub.
	(remote_parse_stop_reply): Handle 'Y' stop reply.
	(remote_wait_as): Likewise.  If remote process exited, invalidate
	the current thread.
	(remote_detach_pid): New.
	(remote_follow_fork): New.
	(init_remote_ops): Register it.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* remote.c (remote_pid_to_exec_file): New.
	(init_remote_ops): Register it.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* infcmd.c (kill_if_already_running): If target supports
	multi-process, allow multi-runs.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* remote.c (extended_remote_create_inferior_1): Don't clear the
	thread list.
@
text
@d1129 1
a1129 1
notice_new_inferiors (ptid_t currthread, int running)
a1130 3
  struct remote_state *rs = get_remote_state ();
  struct inferior *inf = NULL;

a1135 15
      int pid = ptid_get_pid (currthread);
      if (!in_inferior_list (pid))
	{
	  inf = add_inferior (pid);

	  /* This may be the first inferior we hear about.  */
	  if (!target_has_execution)
	    {
	      if (rs->extended)
		target_mark_running (&extended_remote_ops);
	      else
		target_mark_running (&remote_ops);
	    }
	}

d1139 2
d1142 1
a1142 4
      set_executing (currthread, running);
      set_running (currthread, running);
    }
  else if (!in_thread_list (currthread))
d1149 4
a1152 2
	     after an attach, so this is the main thread.  */
	  thread_change_ptid (inferior_ptid, currthread);
d1154 2
a1155 1
      else if (ptid_equal (magic_null_ptid, inferior_ptid))
d1162 2
a1163 1
	  thread_change_ptid (inferior_ptid, currthread);
a1164 9
      else
	{
	  /* When connecting to a target remote, or to a target
	     extended-remote which already was debugging an inferior, we
	     may not know about it yet.  Add it before adding its child
	     thread, so notifications are emitted in a sensible order.  */
	  if (!in_inferior_list (ptid_get_pid (currthread)))
	    {
	      inf = add_inferior (ptid_get_pid (currthread));
d1166 6
a1171 9
	      /* This may be the first inferior we hear about.  */
	      if (!target_has_execution)
		{
		  if (rs->extended)
	        target_mark_running (&extended_remote_ops);
		  else
		    target_mark_running (&remote_ops);
		}
	    }
d1173 2
a1174 5
	  /* This is really a new thread.  Add it.  */
	  add_thread (currthread);
	  set_executing (currthread, running);
	  set_running (currthread, running);
	}
a1175 4

  if (inf)
    /* Do whatever is needed to do with a new inferior.  */
    notice_new_inferior (currthread, !running, 0);
d1193 1
a1193 1
  notice_new_inferiors (currthread, 0);
a1281 17

  if (rs->buf[0]
      && strcmp (rs->buf, "OK") != 0)
    {
      /* If we get an error setting a thread, it's because it is no
	 longer valid.  */
      if (!ptid_equal (minus_one_ptid, ptid)
	  && !ptid_equal (null_ptid, ptid)
	  && !ptid_equal (any_thread_ptid, ptid)
	  && !ptid_is_pid (ptid))
	{
	  int num = pid_to_thread_id (ptid);
	  delete_thread (ptid);
	  error (_("Thread ID %d has terminated."), num);
	}
    }

d1528 2
a1529 7
     what's in inferior_ptid, unless it's null at this point.  If so,
     then since there's no way to know the pid of the reported
     threads, use the magic number.  */
  if (ptid_equal (inferior_ptid, null_ptid))
    pid = ptid_get_pid (magic_null_ptid);
  else
    pid = ptid_get_pid (inferior_ptid);
d2151 3
a2153 1
		  if (!ptid_equal (new_thread, null_ptid))
d2155 11
d2167 1
a2167 1
			 are running until proven otherwise with a
d2170 2
a2171 3
		      int running = non_stop ? 1 : 0;

		      notice_new_inferiors (new_thread, running);
d2579 6
a2603 2
      int saved_async = 0;

d2641 1
a2641 1
      inf = add_inferior (ptid_get_pid (inferior_ptid));
a2645 1
      /* TODO: This should be done in notice_new_inferiors.  */
d2654 1
a2654 31
      init_wait_for_inferior ();

      /* We know the inferior is stopped already, as we have a pending
	 wait status.  We need to force this event through
	 handle_inferior_event.  Pretend the inferior is running, so
	 notice_new_inferior will force a target_stop and a
	 target_wait, to collect the event.  remote_stop_as
	 (target_stop) will notice we have a cached wait status and
	 will not pass the request to the remote.  */
      {
	struct cleanup *old_chain;
	old_chain = make_cleanup_restore_integer (&suppress_resume_observer);

	/* Don't output '*running'.  */
	suppress_resume_observer = 1;

	set_executing (inferior_ptid, 1);
	set_running (inferior_ptid, 1);

	suppress_resume_observer = 0;
      }

      /* Collect the pending event synchronously, instead of going
	 through the event loop.  */
      if (target_can_async_p ())
	saved_async = target_async_mask (0);

      notice_new_inferior (inferior_ptid, 1, args->from_tty);

      if (saved_async)
	target_async_mask (saved_async);
a2712 2
      /* TODO: This should be done whenever we notice a new
	 inferior.  */
d2716 1
a2716 2
	 the stop reply queue.  Also, we can only reach here if
	 threads were found.  */
a4386 1
	break;
a4387 57
    case 'Y':
      {
	char *p = buf + 1;
	if (*p != ';')
	  error (_("unknown stop reply packet: %s"), buf);

	p++;
	if (strncmp (p, "fork;", 5) == 0)
	  {
	    p += 5;
	    event->ws.kind = TARGET_WAITKIND_FORKED;
	  }
	else if (strncmp (p, "vfork;", 6) == 0)
	  {
	    p += 6;
	    event->ws.kind = TARGET_WAITKIND_VFORKED;
	  }
	else if (strncmp (p, "exec;", 5) == 0)
	  {
	    p += 5;
	    event->ws.kind = TARGET_WAITKIND_EXECD;
	  }
	else
	  error (_("unknown stop reply packet: %s"), buf);

	event->ptid = read_ptid (p, &p);

	if (*p != ';')
	  error (_("unknown stop reply packet: %s"), buf);
	p++;

	if (event->ws.kind == TARGET_WAITKIND_EXECD)
	  {
	    struct cleanup *old_chain;
	    int result;
	    char *buf;

	    buf = xmalloc (strlen (p) + 1);
	    result = hex2bin (p, (gdb_byte *) buf, strlen (p));
	    buf [result] = '\0';
	    event->ws.value.execd_pathname = buf;

	    /* At this point, all inserted breakpoints are gone.
	       Doing this as soon as we detect an exec prevents the
	       badness of deleting a breakpoint writing the current
	       "shadow contents" to lift the bp.  That shadow is NOT
	       valid after an exec.  */

	    old_chain = save_inferior_ptid ();
	    inferior_ptid = event->ptid;
	    mark_breakpoints_out ();
	    do_cleanups (old_chain);
	  }
	else
	  event->ws.value.related_pid = read_ptid (p, &p);
      }

d4507 1
a4507 1
    notice_new_inferiors (ptid, 0);
d4658 1
a4658 1
    case 'T': case 'S': case 'X': case 'W': case 'Y':
d4684 1
a4684 1
	    ("Can't send signals to this remote system.	 %s not sent.\n",
d6553 1
a6553 1
  if (have_real_inferiors ())
a6693 3
#if 0
  /* FIXME: How does this look with itsets?  */

a6698 1
#endif
d6719 1
a6719 1
extended_remote_create_inferior (struct target_ops *ops,
d7266 1
a8637 211
char *
remote_pid_to_exec_file (int pid)
{
  struct remote_state *rs;

  rs = get_remote_state ();

  sprintf (rs->buf, "qExecFile:%x", pid);
  putpkt (rs->buf);
  getpkt (&rs->buf, &rs->buf_size, 0);
  if (*rs->buf == '\0')
    /* Not supported */ ;
  else if (strncmp (rs->buf, "QExecFile:", 10) == 0)
    {
      static char *buf = NULL;
      int n, result;
      char *p;

      p = strchr (rs->buf + 10, ';');

      if (p == NULL)
	{
	  warning (_("Invalid qExecFile reply: %s"), rs->buf);
	  return NULL;
	}

      p++;

      if (buf == NULL)
	make_final_cleanup (xfree, buf);
      else
	xfree (buf);

      buf = xmalloc (strlen (p) + 1);
      result = hex2bin (p, (gdb_byte *) buf, strlen (p));
      buf [result] = '\0';

      return buf;
    }
  else if (*rs->buf == 'E')
    ;
  else
    warning (_("Invalid qExecFile reply: %s"), rs->buf);

  return NULL;
}

static void
remote_detach_pid (int pid)
{
  struct remote_state *rs = get_remote_state ();

  /* Tell the remote target to detach.  */
  sprintf (rs->buf, "D;%x", pid);

  putpkt (rs->buf);
  getpkt (&rs->buf, &rs->buf_size, 0);

  if (strcmp (rs->buf, "OK") == 0)
    ;
  else if (rs->buf[0] == '\0')
    error (_("Remote doesn't know how to detach"));
  else
    error (_("Can't detach process."));
}

static int
remote_follow_fork (struct target_ops *ops, int follow_child)
{
  ptid_t last_ptid;
  struct target_waitstatus last_status;
  int has_vforked;
  int parent_pid, child_pid;

  get_last_target_status (&last_ptid, &last_status);
  has_vforked = (last_status.kind == TARGET_WAITKIND_VFORKED);
  parent_pid = ptid_get_tid (last_ptid);
  if (parent_pid == 0)
    parent_pid = ptid_get_pid (last_ptid);
  child_pid = PIDGET (last_status.value.related_pid);

  if (! follow_child)
    {
      /* We're already attached to the parent, by default.  */

      /* Before detaching from the child, remove all breakpoints from
         it.  (This won't actually modify the breakpoint list, but
         will physically remove the breakpoints from the child.)  */
      /* If we vforked this will remove the breakpoints from the
	 parent also, but they'll be reinserted below.  */
      set_general_thread (last_status.value.related_pid);
      detach_breakpoints (child_pid);

      /* Detach new forked process?  */
      if (detach_fork)
	{
	  if (info_verbose || remote_debug)
	    {
	      target_terminal_ours ();
	      fprintf_filtered (gdb_stdlog,
				"Detaching after fork from child process %d.\n",
				child_pid);
	    }

	  /* Tell the remote target to detach.  */
	  remote_detach_pid (child_pid);
	}
      else
	{
	  /* Add process to GDB's tables.  */
	  add_inferior (child_pid);
	}

      set_general_thread (last_ptid);

      if (has_vforked)
	{
	  /* TODO here: Wait for linux's VFORK_DONE, or HPUX's
	     TTEVT_VFORK, or equivalent.  */

	  /* Since we vforked, breakpoints were removed in the parent
	     too.  Put them back.  */
	  reattach_breakpoints (parent_pid);
	}
    }
  else
    {
      struct thread_info *last_tp = find_thread_pid (last_ptid);
      struct thread_info *tp;

      /* Copy user stepping state to the new inferior thread.  */
      struct breakpoint *step_resume_breakpoint = last_tp->step_resume_breakpoint;
      CORE_ADDR step_range_start = last_tp->step_range_start;
      CORE_ADDR step_range_end = last_tp->step_range_end;
      struct frame_id step_frame_id = last_tp->step_frame_id;

      last_tp->step_range_start = 0;
      last_tp->step_range_end = last_tp->step_range_end  = 0;
      last_tp->step_frame_id = null_frame_id;

      /* Otherwise, deleting the parent would get rid of this
	 breakpoint.  */
      last_tp->step_resume_breakpoint = NULL;

      /* Needed to keep the breakpoint lists in sync.  */
      if (! has_vforked)
	{
	  set_general_thread (last_status.value.related_pid);
	  detach_breakpoints (child_pid);
	}

      /* Before detaching from the parent, remove all breakpoints from it. */
      set_general_thread (last_ptid);
      remove_breakpoints ();

      if (info_verbose || remote_debug)
	{
	  target_terminal_ours ();
	  fprintf_filtered (gdb_stdlog,
			    "Attaching after fork to child process %d.\n",
			    child_pid);
	}

      /* If we're vforking, we may want to hold on to the parent until
	 the child exits or execs.  At exec time we can remove the old
	 breakpoints from the parent and detach it; at exit time we
	 could do the same (or even, sneakily, resume debugging it - the
	 child's exec has failed, or something similar).

	 The holding part is very easy if we have VFORKDONE events;
	 but keeping track of both processes is beyond GDB at the
	 moment.  So we don't expose the parent to the rest of GDB.
	 Instead we quietly hold onto it until such time as we can
	 safely resume it.  */

      if (has_vforked)
	{
	  /* TODO: handle this correctly.

	  remote_fork_parent_pid = parent_pid;

	  */
	  detach_inferior (parent_pid);
	}
      else if (detach_fork)
	{
	  remote_detach_pid (parent_pid);
	  detach_inferior (parent_pid);
	}

      add_inferior (child_pid);

      inferior_ptid = ptid_build (child_pid, 0, 0);
      set_general_thread (inferior_ptid);
      inferior_ptid = remote_current_thread (inferior_ptid);
      set_general_thread (inferior_ptid);

      tp = add_thread (inferior_ptid);

      tp->step_resume_breakpoint = step_resume_breakpoint;
      tp->step_range_start = step_range_start;
      tp->step_range_end = step_range_end;
      tp->step_frame_id = step_frame_id;

      /* Reset breakpoints in the child as appropriate.  */
      follow_inferior_reset_breakpoints ();
    }

  return 0;
}

a8700 2
  remote_ops.to_pid_to_exec_file = remote_pid_to_exec_file;
  remote_ops.to_follow_fork = remote_follow_fork;
@


1.329.2.3
log
@	Merge from head:
	2008-12-12  Pedro Alves  <pedro@@codesourcery.com>

	* remote.c (remote_detach_1): Don't delete the inferior here.
	(process_stop_reply): Ditto.
	(extended_remote_kill): Ditto.
@
text
@d3380 1
d4632 2
a4633 2
  if (status->kind != TARGET_WAITKIND_EXITED
      && status->kind != TARGET_WAITKIND_SIGNALLED)
d4635 5
a4639 5
      /* Expedited registers.  */
      if (stop_reply->regcache)
	{
	  cached_reg_t *reg;
	  int ix;
d4641 5
a4645 7
	  for (ix = 0;
	       VEC_iterate(cached_reg_t, stop_reply->regcache, ix, reg);
	       ix++)
	    regcache_raw_supply (get_thread_regcache (ptid),
				 reg->num, reg->data);
	  VEC_free (cached_reg_t, stop_reply->regcache);
	}
d4647 7
a4653 1
      notice_new_inferiors (ptid, 0);
d4655 2
a4656 3
      remote_stopped_by_watchpoint_p = stop_reply->stopped_by_watchpoint_p;
      remote_watch_data_address = stop_reply->watch_data_address;
    }
d6638 1
@


1.329.2.4
log
@	Merge from head:
	2008-12-12  Pedro Alves  <pedro@@codesourcery.com>

	* remote.c (extended_remote_mourn_1): Always call
	generic_mourn_inferior.
@
text
@a6679 3
  /* Call common code to mark the inferior as not running.    */
  generic_mourn_inferior ();

d6691 4
@


1.328
log
@	Kill pthread_ops_hack

	* target.h (struct target_ops): Make to_attach, to_detach,
	to_create_inferior and to_mourn_inferior accept a pointer
    	to struct target_ops.
	(target_attach, target_create_inferior, target_create_inferior):
	Convert from macros to function.  Find the right target to
	invoke a method of.
	(find_default_attach, find_default_create_inferior): New parameter
	ops.
	* corefile.c (core_file_command): Pass target to to_detach.
	* corelow.c (core_detach): Add 'ops' parameter.
	* fork-child.c (fork_inferior): Return the pid.  Allow
	init_trace_fun to be NULL.
	* inf-ptrace (ptrace_ops_hack): Remove.
	(inf_ptrace_him): Remove, moving all logic into....
	(inf_ptrace_create_inferior): ... here.  Push the target
	passed as parameter.
	(inf_ptrace_mourn_inferior, inf_ptrace_attach, inf_ptrace_detach):
	Push/pop target passed as parameter, no ptrace_ops_hack.
	(inf_ptrace_target): Don't remember result.
	* inferior.h (fork_inferior): Adjust prototype.
	* linux-nat.c (linux_nat_create_inferior, linux_nat_attach)
	(linux_nat_detach, linux_nat_mourn_inferior): New parameter ops.
	Pass it to linux_ops target.
	* linux-thread-db.c (thread_db_detach, thread_db_mourn_inferior):
	New parameter ops. Pass it to the target beneath.
	* remote.c (remote_mourn, extended_remote_mourn, remote_detach)
	(extended_remote_create_inferior): New parameter ops. Pass it
	further.
	* target.c (debug_to_attach, debug_to_detach)
	(debug_to_mourn_inferior): New parameter ops.
	(target_create_inferior): New.
	(update_current_target): Do not inherit to_attach, to_detach,
	to_create_inferiour, to_mourn_inferior.  Do not default
	to_detach and to_mourn_inferior.
	(target_detach): Find the right target to use.
	(target_mourn_inferior): New.
	(find_default_attach, find_default_create_inferior): New parameter
	ops.  Pass the found target when calling its method.
	(init_dummy_target): Provide fallback definition of to_detach.
	(target_attach): New.
	(debug_to_attach, debug_to_detach, debug_to_create_inferior)
	(debug_to_mourn_inferiour): New parameter ops.
        * aix-thread.c: Adjust.
        * bsd-uthread.c: Adjust.
        * gnu-nat.c: Adjust.
        * go32-nat.c: Adjust.
        * hpux-thread.c: Adjust.
        * inf-ttrace.c: Ajust.
        * monitor.c: Adjust.
        * nto-procfs.c: Adjust.
        * procfs.c: Adjust.
        * remote-m32r-sdi.c: Adjust.
        * remote-mips.c: Adjust.
        * remote-sim.c: Adjust.
        * rs6000-nat.c: Adjust.
        * sol-thread.c: Adjust.
        * win32-nat.c: Adjust.
	* dec-thread.c: Adjust.
@
text
@d5850 22
d5944 3
d5948 3
a5950 3
	  fprintf_unfiltered (gdb_stdlog, "Sending packet: ");
	  fputstrn_unfiltered (buf2, p - buf2, 0, gdb_stdlog);
	  fprintf_unfiltered (gdb_stdlog, "...");
d5952 1
d6026 9
a6034 3
			fprintf_unfiltered (gdb_stdlog, "  Notification received: ");
			fputstrn_unfiltered (rs->buf, val, 0, gdb_stdlog);
			fprintf_unfiltered (gdb_stdlog, "\n");
d6198 10
a6207 5
		fprintf_filtered (gdb_stdlog,
			      "Bad checksum, sentsum=0x%x, csum=0x%x, buf=",
				  pktcsum, csum);
		fputstrn_filtered (buf, bc, 0, gdb_stdlog);
		fputs_filtered ("\n", gdb_stdlog);
d6380 7
a6386 3
	      fprintf_unfiltered (gdb_stdlog, "Packet received: ");
	      fputstrn_unfiltered (*buf, val, 0, gdb_stdlog);
	      fprintf_unfiltered (gdb_stdlog, "\n");
d6403 9
a6411 3
	      fprintf_unfiltered (gdb_stdlog, "  Notification received: ");
	      fputstrn_unfiltered (*buf, val, 0, gdb_stdlog);
	      fprintf_unfiltered (gdb_stdlog, "\n");
@


1.327
log
@	* remote.c (notice_new_inferiors): Add a new inferior only when
	we're going to add a new thread.
@
text
@d108 1
a108 1
static void remote_mourn (void);
d112 1
a112 1
static void extended_remote_mourn (void);
d136 1
a136 1
static void remote_detach (char *args, int from_tty);
d3309 1
a3309 1
remote_detach (char *args, int from_tty)
d3315 1
a3315 1
extended_remote_detach (char *args, int from_tty)
d3438 1
a3438 1
extended_remote_attach (char *args, int from_tty)
d3440 1
a3440 1
  extended_remote_attach_1 (&extended_remote_ops, args, from_tty);
d6455 1
a6455 1
remote_mourn (void)
d6457 1
a6457 1
  remote_mourn_1 (&remote_ops);
d6540 1
a6540 1
extended_remote_mourn (void)
d6542 1
a6542 1
  extended_remote_mourn_1 (&extended_remote_ops);
d6658 2
a6659 1
extended_remote_create_inferior (char *exec_file, char *args,
@


1.326
log
@	* inf-loop.c (inferior_event_handler): On INF_ERROR and
	INF_REG_EVENT throwing, don't call target_async or pop_target.
	Call pop_all_targets_above.
	* remote.c (remote_close): Call remote_terminal_ours.  Don't call
	signal or target_async.
@
text
@a1129 7
  /* When connecting to a target remote, or to a target
     extended-remote which already was debugging an inferior, we may
     not know about it yet.  Add it before adding its child thread, so
     notifications are emitted in a sensible order.  */
  if (!in_inferior_list (ptid_get_pid (currthread)))
    add_inferior (ptid_get_pid (currthread));

d1165 7
@


1.325
log
@	* remote.c (remote_start_remote): If the solib list is global,
	fetch libraries and insert breakpoints after connecting.
	* infcmd.c (post_create_inferior): If the solist is shared between
	inferiors, no need to refetch it on every new inferior.
	(detach_command): If the shared library list is shared between
	inferiors, then don't clear it on every inferior detach.
	* gdbarch.sh (has_global_solist): New.
	* i386-dicos-tdep.c (i386_dicos_init_abi): Set
	gdbarch_has_global_solist.
	* target.c (target_pre_inferior): If the shared library list is
	shared between inferiors, then don't clear it here, neither
	invalidate the memory regions or clear the target description.
	(target_detach): If the shared library list is shared between
	inferiors, then don't remove breakpoints from the target here.
	(target_disconnect): Comment.
	* solib.c (update_solib_list): Check for null_ptid.
	* breakpoint.c (insert_breakpoints, update_global_location_list):
	If the shared library list is shared between inferiors, insert
	breakpoints even if there's no execution.
	(breakpoint_init_inferior): If the shared library list is shared
	between inferiors, don't delete breakpoints or mark them
	uninserted here.

	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d235 2
d2292 6
a2297 8
  if (remote_desc)
    {
      /* Unregister the file descriptor from the event loop.  */
      if (target_is_async_p ())
	target_async (NULL, 0);
      serial_close (remote_desc);
      remote_desc = NULL;
    }
d2299 2
a2300 3
  /* Make sure we don't leave the async SIGINT signal handler
     installed.  */
  signal (SIGINT, handle_sigint);
@


1.324
log
@	* cli/cli-script.c (do_fclose_cleanup): Remove.
	(script_from_file): Use make_cleanup_fclose.
	* xml-tdesc.c (do_cleanup_fclose): Remove.
	(fetch_xml_from_file): Use make_cleanup_fclose.
	* tracepoint.c (tracepoint_save_command): Use
	make_cleanup_fclose.  Always free pathname.
	* source.c (print_source_lines_base): Use make_cleanup_fclose.
	* remote.c (fclose_cleanup): Remove.
	(remote_file_put): Use make_cleanup_fclose.
	(remote_file_get): Likewise.
	* linux-nat.c (linux_nat_find_memory_regions): Use
	make_cleanup_fclose.
	(linux_nat_info_proc_cmd): Likewise.
	(linux_proc_pending_signals): Likewise.
	* fbsd-nat.c (fbsd_find_memory_regions): Use make_cleanup_fclose.
	Free file name.
	* cli/cli-dump.c (do_fclose_cleanup): Remove.
	(make_cleanup_fclose): Remove.
	* defs.h (make_cleanup_fclose): Declare.
	* utils.c (do_fclose_cleanup): New function.
	(make_cleanup_fclose): Likewise.
@
text
@d2553 5
d2725 6
@


1.323
log
@	* target.h (struct target_ops) <to_supports_multi_process>: New
	field.
	(target_supports_multi_process): New define.
	* target.c (update_current_target): Inherit and de_fault
	to_supports_multi_process.
	* infcmd.c (attach_command): Allow attaching to multiple processes
	if the target supports it.
	(detach_command): If the target claims there is still execution,
	don't clear the thread list.
	* remote.c (remote_supports_multi_process): New.
	(init_remote_ops): Register remote_supports_multi_process.
@
text
@a8215 6
fclose_cleanup (void *file)
{
  fclose (file);
}

static void
d8332 1
a8332 1
  back_to = make_cleanup (fclose_cleanup, file);
d8422 1
a8422 1
  back_to = make_cleanup (fclose_cleanup, file);
@


1.322
log
@	Remote non-stop mode support.

	* remote.c (pending_stop_reply): New.
	(struct remote_state) <non_stop_aware, support_vCont_t>: New
	fields.
	(remote_async_inferior_event_token)
	(remote_async_get_pending_events_token): New.
	(notice_new_inferiors): New, abstracted out from record_currthread.
	(record_currthread): Call it.
	(remote_threads_info): Default threads to running in non-stop
	mode.  In non-stop mode, only qfThreadInfo is supported.
	(remote_close): Discard all pending stop_replies.  Close the event
	sources.
	(set_stop_requested_callback): New.
	(remote_start_remote): Implement non-stop mode startup.  In
	all-stop, don't clear the thread list here.
	(remote_non_stop_feature): New.
	(remote_protocol_features): Add a "QNonStop" feature.
	(remote_open_1): Clear cached_wait_status and non_stop_aware.
	Clear the thread list here.
	(remote_detach_1): Discard pending stop replies of the process we
	detached from.
	(extended_remote_attach_1): Implement non-stop mode.
	(remote_vcont_probe): Recognize `vCont;t'.
	(remote_vcont_resume): Implement non-stop mode.
	(remote_resume): Don't set waiting_for_stop_reply in non-stop
	mode.
	(remote_stop_ns): New.
	(remote_stop): Rename to ...
	(remote_stop_as): ... this.  If we have a cached wait status,
	don't bother interrupting the remote.
	(remote_stop): Reimplement as wrapper around remote_stop_as and
	remote_stop_ns.
	(interrupt_query): Don't query in async mode.
	(struct cached_reg, cahed_reg_t): New.
	(struct stop_reply): New.
	(stop_reply_queue): New.
	(stop_reply_xmalloc, stop_reply_xfree)
	(discard_pending_stop_replies, do_stop_reply_xfree)
	(queued_stop_reply, push_stop_reply, peek_stop_reply)
	(remote_parse_stop_reply, remote_get_pending_stop_replies)
	(process_stop_reply): New.
	(remote_wait_ns): New.
	(remote_wait_as): Use remote_parse_stop_reply.  Invalidate the
	notion of current general thread is a process exit was reported.
	(remote_wait): Call remote_wait_ns in non-stop mode.
	(handle_notification): New.
	(putpkt_binary): Handle notifications.  Don't care for
	waiting_for_stop_reply in non-stop mode.
	(getpkt_sane): Rename to ...
	(getpkt_or_notif_sane_1): ... this.  Add `expecting_notif'
	argument.  Handle it.  Handle notifications.
	(getpkt_sane): Reimplement as wrapper around getpkt_or_notif_sane_1.
	(getpkt_or_notif_sane): New.
	(select_new_thread_callback): Check for exited state instead of
	comparing the ptid against minus_one_ptid.
	(extended_remote_create_inferior_1): Query the remote about the
	current thread.
	(remote_supports_non_stop): New.
	(init_remote_ops): Register it.
	(remote_async_inferior_event_handler): New.
	(remote_async_get_pending_events_handler): New.

	* infcmd.c (proceed_thread_callback): Comment.
	(proceed_after_attach_callback, proceed_after_attach): New.
	(attach_command_post_wait): In background attach, resume all
	threads, but only if they are unsignalled, and not explicitly
	stopped.  In foreground attach, in non-stop mode, make sure to
	stop all threads of the just attached to process.
	(attach_command): In non-stop mode: If doing a background attach,
	stop at least one thread.  If a foreground attach, stop all
	threads.
@
text
@d8557 7
d8626 1
@


1.321
log
@2008-10-17  Michael Snyder  <msnyder@@vmware.com>
	Target interface for reverse debugging.
	* target.h (enum target_waitkind):
	Add new wait event, TARGET_WAITKIND_NO_HISTORY.
	(struct target_ops): New method to_can_execute_reverse.
	(target_can_execute_reverse): New macro.
	* target.c (update_current_target): Inherit to_can_execute_reverse.

	Remote interface for reverse debugging.
	* remote.c (remote_can_execute_reverse): New target method.
	(remote_resume): Check for reverse exec direction, and send
	appropriate command to target.
	(remote_wait_as): Check target response for NO_HISTORY status.
	Also check for empty reply (target doesn't understand "bs" or "bc).
	(remote_vcont_resume): Jump out if attempting reverse execution.

	Event handling interface for reverse debugging.
	* infrun.c (execution_direction): New state variable.
	(enum inferior_stop_reason): Add NO_HISTORY reason.
	(handle_inferior_event): Handle TARGET_WAITKIND_NO_HISTORY.
	Handle stepping over a function call in reverse.
	Handle stepping thru a line range in reverse.
	Handle setting a step-resume breakpoint in reverse.
	Handle stepping into a function in reverse.
	Handle stepping between line ranges in reverse.
	(print_stop_reason): Print reason for NO_HISTORY.
	(step_into_function): Rename to handle_step_into_function.
	(handle_step_into_function_backward): New function.
	(set_exec_direction_func, show_exec_direction_func): New funcs.
	(proceed): No need to singlestep over a breakpoint
	when resuming in reverse.

	* inferior.h (enum exec_direction_kind): New enum.
	(execution_direction): Export new execution state variable.

	* breakpoint.c (make_breakpoint_silent): New function.
	* breakpoint.h (make_breakpoint_silent): Export.
	* infcmd.c (finish_command): Check for reverse exec direction.
	(finish_backward): New function, handle finish cmd in reverse.

	User interface for reverse execution.
	* Makefile.in (reverse.c): New file.
	* reverse.c: New file.  User interface for reverse execution.
@
text
@d82 2
d222 18
d298 6
d1102 12
a1124 7

/* Call this function as a result of
   1) A halt indication (T packet) containing a thread id
   2) A direct query of currthread
   3) Successful execution of set thread
 */

d1126 1
a1126 1
record_currthread (ptid_t currthread)
a1127 2
  general_thread = currthread;

d1175 18
d2162 7
d2180 4
d2307 8
d2475 15
d2557 35
d2596 1
a2596 1
  if (rs->buf[0] == 'W' || rs->buf[0] == 'X')
d2598 1
a2598 1
      if (args->extended_p)
d2600 9
a2608 4
	  /* We're connected, but not running.  Drop out before we
	     call start_remote.  */
	  target_mark_exited (args->target);
	  return;
d2611 38
a2648 1
	error (_("The target is not running (try extended-remote?)"));
d2652 15
a2666 2
      if (args->extended_p)
	target_mark_running (args->target);
d2668 4
a2671 4
      /* Save the reply for later.  */
      wait_status = alloca (strlen (rs->buf) + 1);
      strcpy (wait_status, rs->buf);
    }
d2673 4
a2676 2
  /* Start afresh.  */
  init_thread_list ();
d2678 2
a2679 2
  /* Let the stub know that we want it to return the thread.  */
  set_continue_thread (minus_one_ptid);
d2681 12
a2692 8
  /* Without this, some commands which require an active target
     (such as kill) won't work.  This variable serves (at least)
     double duty as both the pid of the target process (if it has
     such), and as a flag indicating that a target is active.
     These functions should be split out into seperate variables,
     especially since GDB will someday have a notion of debugging
     several processes.  */
  inferior_ptid = magic_null_ptid;
d2694 2
a2695 2
  /* Now, if we have thread information, update inferior_ptid.  */
  inferior_ptid = remote_current_thread (inferior_ptid);
d2697 1
a2697 1
  add_inferior (ptid_get_pid (inferior_ptid));
d2699 2
a2700 2
  /* Always add the main thread.  */
  add_thread_silent (inferior_ptid);
d2702 4
a2705 1
  get_offsets ();		/* Get text, data & bss offsets.  */
d2707 1
a2707 4
  /* Use the previously fetched status.  */
  gdb_assert (wait_status != NULL);
  strcpy (rs->buf, wait_status);
  rs->cached_wait_status = 1;
d2709 4
a2712 2
  immediate_quit--;
  start_remote (args->from_tty); /* Initialize gdb process mechanisms.  */
d2916 8
d2943 1
d3159 8
d3170 1
d3175 1
d3203 3
d3293 1
d3361 10
a3370 3
      /* Save the reply for later.  */
      wait_status = alloca (strlen (rs->buf) + 1);
      strcpy (wait_status, rs->buf);
d3387 6
a3392 2
  /* Now, add the main thread to the thread list.  */
  add_thread_silent (inferior_ptid);
d3398 27
a3424 4
  /* Use the previously fetched status.  */
  gdb_assert (wait_status != NULL);
  strcpy (rs->buf, wait_status);
  rs->cached_wait_status = 1;
d3518 1
d3530 2
d3652 10
d3729 6
a3734 2
     because the stub wouldn't be ready to process it.  */
  rs->waiting_for_stop_reply = 1;
d3822 75
d3900 1
a3903 1
  /* Send a break or a ^C, depending on user preference.  */
d3907 2
a3908 2
  if (remote_break)
    serial_send_break (remote_desc);
d3910 1
a3910 1
    serial_write (remote_desc, "\003", 1);
d3920 1
a3920 2
  if (query ("Interrupted while waiting for the program.\n\
Give up (and stop debugging it)? "))
d3922 1
a3922 1
      pop_target ();
d3925 9
d4004 47
a4050 1
  gdb_flush (gdb_stdtarg);
d4053 2
a4054 2
/* Wait until the remote machine stops, then return,
   storing status in STATUS just as `wait' would.  */
d4056 2
a4057 2
static ptid_t
remote_wait_as (ptid_t ptid, struct target_waitstatus *status)
d4059 1
a4059 7
  struct remote_state *rs = get_remote_state ();
  struct remote_arch_state *rsa = get_remote_arch_state ();
  ptid_t event_ptid = null_ptid;
  ULONGEST addr;
  int solibs_changed = 0;
  int replay_event = 0;
  char *buf, *p;
d4061 8
a4068 2
  status->kind = TARGET_WAITKIND_IGNORE;
  status->value.integer = 0;
d4070 3
a4072 4
  if (rs->cached_wait_status)
    /* Use the cached wait status, but only once.  */
    rs->cached_wait_status = 0;
  else
d4074 3
a4076 1
      if (!target_is_async_p ())
d4078 6
a4083 8
	  ofunc = signal (SIGINT, remote_interrupt);
	  /* If the user hit C-c before this packet, or between
	     packets, pretend that it was hit right here.  */
	  if (quit_flag)
	    {
	      quit_flag = 0;
	      remote_interrupt (SIGINT);
	    }
d4085 39
a4123 7
      /* FIXME: cagney/1999-09-27: If we're in async mode we should
	 _never_ wait for ever -> test on target_is_async_p().
	 However, before we do that we need to ensure that the caller
	 knows how to take the target into/out of async mode.  */
      getpkt (&rs->buf, &rs->buf_size, wait_forever_enabled_p);
      if (!target_is_async_p ())
	signal (SIGINT, ofunc);
d4126 8
a4133 1
  buf = rs->buf;
d4135 3
a4137 1
  remote_stopped_by_watchpoint_p = 0;
d4139 4
a4142 2
  /* We got something.  */
  rs->waiting_for_stop_reply = 0;
d4144 1
a4144 1
  switch (buf[0])
d4146 47
a4192 9
    case 'E':		/* Error of some sort.  */
      /* We're out of sync with the target now.  Did it continue or
	 not?  Not is more likely, so report a stop.  */
      warning (_("Remote failure reply: %s"), buf);
      status->kind = TARGET_WAITKIND_STOPPED;
      status->value.sig = TARGET_SIGNAL_0;
      break;
    case 'F':		/* File-I/O request.  */
      remote_fileio_request (buf);
d4194 3
a4196 5
      /* This stop reply is special.  We reply back to the stub,
	 and keep waiting for the target to stop.  */
      rs->waiting_for_stop_reply = 1;
      break;
    case 'T':		/* Status with PC, SP, FP, ...  */
d4202 3
a4204 3
	    ss = signal number
	    n... = register number
	    r... = register contents
d4206 1
a4207 1

d4219 2
a4220 2
	    /* If this packet is an awatch packet, don't parse the
	       'a' as a register number.  */
d4239 1
a4239 1
		  event_ptid = read_ptid (++p1, &p);
d4244 1
a4244 1
		    remote_stopped_by_watchpoint_p = 1;
d4246 1
a4246 1
		    remote_watch_data_address = (CORE_ADDR)addr;
d4255 1
a4255 1
		    solibs_changed = 1;
d4263 1
a4263 1
		    replay_event = 1;
d4279 4
d4296 1
a4296 1
		fieldsize = hex2bin (p, regs,
d4303 2
a4304 2
		regcache_raw_supply (get_current_regcache (),
				     reg->regnum, regs);
d4315 4
a4318 4
      if (solibs_changed)
	status->kind = TARGET_WAITKIND_LOADED;
      else if (replay_event)
            status->kind = TARGET_WAITKIND_NO_HISTORY;
d4321 2
a4322 2
	  status->kind = TARGET_WAITKIND_STOPPED;
	  status->value.sig = (enum target_signal)
d4341 2
a4342 2
	    status->kind = TARGET_WAITKIND_EXITED;
	    status->value.integer = value;
d4347 2
a4348 2
	    status->kind = TARGET_WAITKIND_SIGNALLED;
	    status->value.sig = (enum target_signal) value;
d4374 282
a4655 1
	event_ptid = pid_to_ptid (pid);
a4692 1
  /* Nothing interesting happened.  */
d4694 1
d4696 2
a4697 8

  if (status->kind == TARGET_WAITKIND_EXITED
      || status->kind == TARGET_WAITKIND_SIGNALLED)
    {
      int pid = ptid_get_pid (event_ptid);
      delete_inferior (pid);
    }
  else
d4704 3
d4711 3
d4719 14
a4732 2
  /* In synchronous mode, keep waiting until the target stops.  In
     asynchronous mode, always return to the event loop.  */
d4734 1
a4734 1
  do
d4736 4
a4739 1
      event_ptid = remote_wait_as (ptid, status);
a4740 2
  while (status->kind == TARGET_WAITKIND_IGNORE
	 && !target_can_async_p ());
d5622 39
d5880 3
a5882 2
     running.  */
  if (target_can_async_p () && rs->waiting_for_stop_reply)
d5926 2
a5927 1
      /* Read until either a timeout occurs (-2) or '+' is read.  */
d5940 1
d5976 38
d6238 4
a6241 2
   indication of this to the caller.  Otherwise return the number
   of bytes read.  */
d6243 2
a6244 1
getpkt_sane (char **buf, long *sizeof_buf, int forever)
d6259 4
a6262 4
    {
      timeout = watchdog > 0 ? watchdog : -1;
    }

d6268 20
a6287 15
  for (tries = 1; tries <= MAX_TRIES; tries++)
    {
      /* This can loop forever if the remote side sends us characters
         continuously, but if it pauses, we'll get a zero from
         readchar because of timeout.  Then we'll count that as a
         retry.  */

      /* Note that we will only wait forever prior to the start of a
         packet.  After that, we expect characters to arrive at a
         brisk pace.  They should show up within remote_timeout
         intervals.  */

      do
	{
	  c = readchar (timeout);
d6291 4
a6302 1
	      goto retry;
d6304 10
a6314 1
      while (c != '$');
d6316 5
a6320 1
      /* We've found the start of a packet, now collect the data.  */
d6322 5
a6326 1
      val = read_frame (buf, sizeof_buf);
d6328 2
a6329 1
      if (val >= 0)
d6344 20
a6363 5
      /* Try the whole thing again.  */
    retry:
      /* Skip the nack char if we're in no-ack mode.  */
      if (!rs->noack_mode)
	serial_write (remote_desc, "-", 1);
d6365 1
d6367 5
a6371 2
  /* We have tried hard enough, and just can't receive the packet.
     Give up.  */
d6373 5
a6377 1
  printf_unfiltered (_("Ignoring packet error, continuing...\n"));
a6378 5
  /* Skip the ack char if we're in no-ack mode.  */
  if (!rs->noack_mode)
    serial_write (remote_desc, "+", 1);
  return -1;
}
d6462 1
a6462 1
  if (!ptid_equal (th->ptid, minus_one_ptid))
d6481 3
d6635 3
d8551 6
d8618 1
d8683 12
@


1.320
log
@	* remote.c (record_currthread): Add inferior before child threads.
	(remote_threads_info): Check for exited threads.  Mention
	notification order.
@
text
@d3446 9
a3454 1
  if (siggnal != TARGET_SIGNAL_0)
d3682 1
d3798 10
d3853 2
d7652 8
d7708 1
@


1.319
log
@	* remote.c (set_general_process): New.
	(remote_check_symbols): Use it.
@
text
@d1099 7
a1143 6

  if (!in_inferior_list (ptid_get_pid (currthread)))
    /* When connecting to a target remote, or to a target
       extended-remote which already was debugging an inferior, we may
       not know about it yet --- add it.  */
    add_inferior (ptid_get_pid (currthread));
d2102 2
a2103 1
		      && !in_thread_list (new_thread))
d2105 6
a2111 4
			/* When connected to a multi-process aware
			   stub, "info threads" may show up threads of
			   inferiors we didn't know about yet.  Add
			   them.  */
@


1.318
log
@	* remote.c (push_remote_target): Delete.
	* target.h (push_remote_target): Delete declaration.
@
text
@d1249 24
d2580 3
@


1.317
log
@	* remote.c (remote_close): Unregister remote_desc from the event
	loop.  Always restore the SIGINT handler.  Discard all inferiors
	here.
	(remote_detach_1, remote_disconnect): Don't unregister the file
	descriptor from the event loop here.
	(interrupt_query, readchar, getpkt_sane): Pop the target instead
	of morning the current inferior.
	(remote_kill): Don't unregister the file descriptor from the event
	loop here.
	(remote_mourn_1): Don't discard inferiors here.
@
text
@a5997 17
/* Some targets are only capable of doing downloads, and afterwards
   they switch to the remote serial protocol.  This function provides
   a clean way to get from the download target to the remote target.
   It's basically just a wrapper so that we don't have to expose any
   of the internal workings of remote.c.

   Prior to calling this routine, you should shutdown the current
   target code, else you will get the "A program is being debugged
   already..." message.  Usually a call to pop_target() suffices.  */

void
push_remote_target (char *name, int from_tty)
{
  printf_filtered (_("Switching to remote protocol\n"));
  remote_open (name, from_tty);
}

@


1.316
log
@	* remote.c (remote_start_remote): Always tell the stub if we're in
	extended-remote.
@
text
@d2205 17
a2221 2
    serial_close (remote_desc);
  remote_desc = NULL;
a3046 4
  /* Unregister the file descriptor from the event loop.  */
  if (target_is_async_p ())
    serial_async (remote_desc, NULL, 0);

a3084 4
  /* Unregister the file descriptor from the event loop.  */
  if (target_is_async_p ())
    serial_async (remote_desc, NULL, 0);

d3556 1
a3556 2
      target_mourn_inferior ();
      signal (SIGINT, handle_sigint);
d4963 1
a4963 1
      target_mourn_inferior ();
d5396 1
a5396 1
		  target_mourn_inferior ();
a5445 4
  /* Unregister the file descriptor from the event loop.  */
  if (target_is_async_p ())
    serial_async (remote_desc, NULL, 0);

d5517 1
a5517 3
  /* Get rid of all the inferiors and their threads we were
     controlling.  */
  discard_all_inferiors ();
d5519 1
a5519 2
  unpush_target (target);
  generic_mourn_inferior ();
@


1.315
log
@	* remote.c (remote_wait): Rename to...
	(remote_wait_as): ... this.  Don't loop here.  If the remote
	didn't stop, return TARGET_WAITKIND_IGNORE.
	(remote_wait): New, reimplemented on top of remote_wait_as.
@
text
@d2422 7
a2491 7
  if (args->extended_p)
    {
      /* Tell the remote that we are using the extended protocol.  */
      putpkt ("!");
      getpkt (&rs->buf, &rs->buf_size, 0);
    }

@


1.314
log
@	* remote.c (remote_open_1): Move acknowledging any pending ack,
	querying supported features, activating noack mode, finding the
	target description, enabling extended remote, and checking remote
	symbols from here ...
	(remote_start_remote): ... to here.
	(remote_open_1): Don't pop the target if it is already gone.
	* target.c (unpush_target): Check for the dummy target.
@
text
@d3630 1
a3630 1
remote_wait (ptid_t ptid, struct target_waitstatus *status)
d3637 1
d3639 1
a3639 1
  status->kind = TARGET_WAITKIND_EXITED;
d3642 4
a3645 1
  while (1)
d3647 1
a3647 6
      char *buf, *p;

      if (rs->cached_wait_status)
	/* Use the cached wait status, but only once.  */
	rs->cached_wait_status = 0;
      else
d3649 4
a3652 1
	  if (!target_is_async_p ())
d3654 2
a3655 8
	      ofunc = signal (SIGINT, remote_interrupt);
	      /* If the user hit C-c before this packet, or between packets,
		 pretend that it was hit right here.  */
	      if (quit_flag)
		{
		  quit_flag = 0;
		  remote_interrupt (SIGINT);
		}
a3656 7
	  /* FIXME: cagney/1999-09-27: If we're in async mode we should
	     _never_ wait for ever -> test on target_is_async_p().
	     However, before we do that we need to ensure that the caller
	     knows how to take the target into/out of async mode.  */
	  getpkt (&rs->buf, &rs->buf_size, wait_forever_enabled_p);
	  if (!target_is_async_p ())
	    signal (SIGINT, ofunc);
d3658 12
d3671 2
a3672 1
      buf = rs->buf;
d3674 11
a3684 1
      remote_stopped_by_watchpoint_p = 0;
d3686 7
a3692 2
      /* We got something.  */
      rs->waiting_for_stop_reply = 0;
d3694 7
a3700 11
      switch (buf[0])
	{
	case 'E':		/* Error of some sort.  */
	  /* We're out of sync with the target now.  Did it continue or not?
	     Not is more likely, so report a stop.  */
	  warning (_("Remote failure reply: %s"), buf);
	  status->kind = TARGET_WAITKIND_STOPPED;
	  status->value.sig = TARGET_SIGNAL_0;
	  goto got_status;
	case 'F':		/* File-I/O request.  */
	  remote_fileio_request (buf);
d3702 1
a3702 5
	  /* This stop reply is special.  We reply back to the stub,
	     and keep waiting for the target to stop.  */
	  rs->waiting_for_stop_reply = 1;
	  continue;
	case 'T':		/* Status with PC, SP, FP, ...  */
d3704 8
a3711 1
	    gdb_byte regs[MAX_REGISTER_SIZE];
d3713 2
a3714 7
	    /* Expedited reply, containing Signal, {regno, reg} repeat.  */
	    /*  format is:  'Tssn...:r...;n...:r...;n...:r...;#cc', where
	       ss = signal number
	       n... = register number
	       r... = register contents
	     */
	    p = &buf[3];	/* after Txx */
d3716 1
a3716 1
	    while (*p)
d3718 6
a3723 8
		char *p1;
		char *p_temp;
		int fieldsize;
		LONGEST pnum = 0;

		/* If the packet contains a register number, save it
		   in pnum and set p1 to point to the character
		   following it.  Otherwise p1 points to p.  */
d3725 12
a3736 4
		/* If this packet is an awatch packet, don't parse the
		   'a' as a register number.  */

		if (strncmp (p, "awatch", strlen("awatch")) != 0)
d3738 3
a3740 3
		    /* Read the ``P'' register number.  */
		    pnum = strtol (p, &p_temp, 16);
		    p1 = p_temp;
d3742 6
a3747 2
		else
		  p1 = p;
d3749 2
a3750 34
		if (p1 == p)	/* No register number present here.  */
		  {
		    p1 = strchr (p, ':');
		    if (p1 == NULL)
		      error (_("Malformed packet(a) (missing colon): %s\n\
Packet: '%s'\n"),
			     p, buf);
		    if (strncmp (p, "thread", p1 - p) == 0)
		      event_ptid = read_ptid (++p1, &p);
		    else if ((strncmp (p, "watch", p1 - p) == 0)
			     || (strncmp (p, "rwatch", p1 - p) == 0)
			     || (strncmp (p, "awatch", p1 - p) == 0))
		      {
			remote_stopped_by_watchpoint_p = 1;
			p = unpack_varlen_hex (++p1, &addr);
			remote_watch_data_address = (CORE_ADDR)addr;
		      }
		    else if (strncmp (p, "library", p1 - p) == 0)
		      {
			p1++;
			p_temp = p1;
			while (*p_temp && *p_temp != ';')
			  p_temp++;

			solibs_changed = 1;
			p = p_temp;
		      }
		    else
 		      {
 			/* Silently skip unknown optional info.  */
 			p_temp = strchr (p1 + 1, ';');
 			if (p_temp)
			  p = p_temp;
 		      }
d3754 10
a3763 2
		    struct packet_reg *reg = packet_reg_from_pnum (rsa, pnum);
		    p = p1;
d3765 2
a3766 2
		    if (*p != ':')
		      error (_("Malformed packet(b) (missing colon): %s\n\
d3768 2
a3769 2
			     p, buf);
                    ++p;
d3771 2
a3772 2
		    if (reg == NULL)
		      error (_("Remote sent bad register number %s: %s\n\
d3774 12
a3785 1
			     phex_nz (pnum, 0), p, buf);
d3787 28
a3814 10
		    fieldsize = hex2bin (p, regs,
					 register_size (target_gdbarch,
							reg->regnum));
		    p += 2 * fieldsize;
		    if (fieldsize < register_size (target_gdbarch,
						   reg->regnum))
		      warning (_("Remote reply is too short: %s"), buf);
		    regcache_raw_supply (get_current_regcache (),
					 reg->regnum, regs);
		  }
d3816 5
a3820 5
		if (*p != ';')
		  error (_("Remote register badly formatted: %s\nhere: %s"),
			 buf, p);
                ++p;
	      }
d3822 1
a3822 13
	  /* fall through */
	case 'S':		/* Old style status, just signal only.  */
	  if (solibs_changed)
	    status->kind = TARGET_WAITKIND_LOADED;
	  else
	    {
	      status->kind = TARGET_WAITKIND_STOPPED;
	      status->value.sig = (enum target_signal)
		(((fromhex (buf[1])) << 4) + (fromhex (buf[2])));
	    }
	  goto got_status;
	case 'W':		/* Target exited.  */
	case 'X':
d3824 4
a3827 8
	    char *p;
	    int pid;
	    ULONGEST value;

	    /* GDB used to accept only 2 hex chars here.  Stubs should
	       only send more if they detect GDB supports
	       multi-process support.  */
	    p = unpack_varlen_hex (&buf[1], &value);
d3829 7
a3835 12
	    if (buf[0] == 'W')
	      {
		/* The remote process exited.  */
		status->kind = TARGET_WAITKIND_EXITED;
		status->value.integer = value;
	      }
	    else
	      {
		/* The remote process exited with a signal.  */
		status->kind = TARGET_WAITKIND_SIGNALLED;
		status->value.sig = (enum target_signal) value;
	      }
d3837 1
a3837 3
	    /* If no process is specified, assume inferior_ptid.  */
	    pid = ptid_get_pid (inferior_ptid);
	    if (*p == '\0')
d3839 2
a3840 1
	    else if (*p == ';')
d3842 4
a3845 14
		p++;

		if (p == '\0')
		  ;
		else if (strncmp (p,
				  "process:", sizeof ("process:") - 1) == 0)
		  {
		    ULONGEST upid;
		    p += sizeof ("process:") - 1;
		    unpack_varlen_hex (p, &upid);
		    pid = upid;
		  }
		else
		  error (_("unknown stop reply packet: %s"), buf);
a3848 2
	    event_ptid = ptid_build (pid, 0, 0);
	    goto got_status;
d3850 23
a3872 2
	case 'O':		/* Console output.  */
	  remote_console_output (buf + 1);
d3874 2
a3875 2
	  /* The target didn't really stop; keep waiting.  */
	  rs->waiting_for_stop_reply = 1;
d3877 2
a3878 33
	  if (target_can_async_p ())
	    {
	      /* Return immediately to the event loop. The event loop
              	 will still be waiting on the inferior afterwards.  */
	      status->kind = TARGET_WAITKIND_IGNORE;
	      goto got_status;
	    }
	  else
	    continue;
	case '\0':
	  if (last_sent_signal != TARGET_SIGNAL_0)
	    {
	      /* Zero length reply means that we tried 'S' or 'C' and
	         the remote system doesn't support it.  */
	      target_terminal_ours_for_output ();
	      printf_filtered
		("Can't send signals to this remote system.  %s not sent.\n",
		 target_signal_to_name (last_sent_signal));
	      last_sent_signal = TARGET_SIGNAL_0;
	      target_terminal_inferior ();

	      strcpy ((char *) buf, last_sent_step ? "s" : "c");
	      putpkt ((char *) buf);

	      /* We just told the target to resume, so a stop reply is
		 in order.  */
	      rs->waiting_for_stop_reply = 1;
	      continue;
	    }
	  /* else fallthrough */
	default:
	  warning (_("Invalid remote reply: %s"), buf);
	  /* Keep waiting.  */
d3880 1
a3880 1
	  continue;
d3882 6
d3889 5
a3893 1
got_status:
d3911 18
@


1.313
log
@	* remote.c (struct remote_state) <waiting_for_stop_reply>: New
	field.
	(remote_open_1): Clear waiting_for_stop_reply.
	(remote_resume): Set waiting_for_stop_reply.
	(remote_wait): Clear or set waiting_for_stop_reply accordingly.
	(putpkt_binary): If we're in async mode and waiting for a stop
	reply, bail out with an error.
	(extended_remote_mourn_1): Clear waiting_for_stop_reply.
@
text
@d214 4
d2382 1
d2384 1
a2384 1
  struct start_remote_args *args = opaque;
d2389 37
d2484 14
a2846 1
  struct packet_config *noack_config;
a2940 37
  /* Ack any packet which the remote side has already sent.  */
  serial_write (remote_desc, "+", 1);

  /* The first packet we send to the target is the optional "supported
     packets" request.  If the target can answer this, it will tell us
     which later probes to skip.  */
  remote_query_supported ();

  /* Next, we possibly activate noack mode.

     If the QStartNoAckMode packet configuration is set to AUTO,
     enable noack mode if the stub reported a wish for it with
     qSupported.

     If set to TRUE, then enable noack mode even if the stub didn't
     report it in qSupported.  If the stub doesn't reply OK, the
     session ends with an error.

     If FALSE, then don't activate noack mode, regardless of what the
     stub claimed should be the default with qSupported.  */

  noack_config = &remote_protocol_packets[PACKET_QStartNoAckMode];

  if (noack_config->detect == AUTO_BOOLEAN_TRUE
      || (noack_config->detect == AUTO_BOOLEAN_AUTO
	  && noack_config->support == PACKET_ENABLE))
    {
      putpkt ("QStartNoAckMode");
      getpkt (&rs->buf, &rs->buf_size, 0);
      if (packet_ok (rs->buf, noack_config) == PACKET_OK)
	rs->noack_mode = 1;
    }

  /* Next, if the target can specify a description, read it.  We do
     this before anything involving memory or registers.  */
  target_find_description ();

d2985 4
a2988 1
	pop_target ();
a2996 14

  if (extended_p)
    {
      /* Tell the remote that we are using the extended protocol.  */
      putpkt ("!");
      getpkt (&rs->buf, &rs->buf_size, 0);
    }

  /* If we connected to a live target, do some additional setup.  */
  if (target_has_execution)
    {
      if (exec_bfd) 	/* No use without an exec file.  */
	remote_check_symbols (symfile_objfile);
    }
@


1.312
log
@	* remote.c (remote_get_thread_info): If the remote doesn't support
	the query, bail out.
@
text
@d266 8
d2877 1
d3423 6
d3667 3
d3681 4
d3853 4
d3880 4
d3889 2
d5003 9
d5524 4
@


1.311
log
@2008-10-03  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* utils.c, defs.h (gdb_buildargv): New fn. Wrap buildargv
	and check for out-of-memory condition.
	* exec.c (exec_file_command): Call it.
	* infrun.c (handle_command, xdb_handle_command): Likewise.
	* interps.c (interpreter_exec_cmd): Likewise.
	* linux-nat.c (linux_nat_info_proc_cmd): Likewise.
	* procfs.c (info_proc_cmd): Likewise.
	* remote-mips.c (common_open): Likewise.
	* remote-sim.c (gdbsim_kill, gdbsim_create_inferior)
	(gdbsim_open): Likewise.
	* remote.c (extended_remote_run, remote_put_command)
	(remote_get_command, remote_delete_command): Likewise.
	* ser-mingw.c (pipe_windows_open): Likesise.
	* source.c (add_path, show_substitute_path_command)
	(unset_substitute_path_command, set_substitute_path_command):
	Likewise.
	* stack.c (backtrace_command): Likewise.
	* symfile.c (symbol_file_command, generic_load)
	(add_symbol_file_command): Likesise.
	* symmisc.c (maintenance_print_symbols, maintenance_print_psymbols)
	(maintenance_print_msymbols): Likewise.
@
text
@d1834 4
@


1.310
log
@	Remove the attach_flag global, and make it per-inferior.

	* inferior.h (attach_flag): Delete.
	(inferior_process): Declare.
	* solib.c (update_solib_list): Adjust.
	* gnu-nat.c (gnu_create_inferior, gnu_attach): Adjust.
	* inf-ptrace.c (inf_ptrace_detach): Adjust.
	(inf_ptrace_files_info): Get it from the current inferior.
	* inf-ttrace.c (inf_ttrace_attach): Adjust.
	(inf_ttrace_files_info): Get it from the current
	inferior.
	* inflow.c (terminal_inferior, terminal_ours_1, set_sigint_trap)
	(clear_sigint_trap): Get it from the current process.
	* remote.c (extended_remote_attach_1)
	(extended_remote_create_inferior_1): Adjust.
	* top.c (quit_confirm, quit_target): Get it from the current inferior.
	* procfs.c (do_detach): Adjust.
	(procfs_wait): Get it from the event inferior.
	(procfs_files_info): Get it from the current inferior.
	* nto-procfs.c (procfs_files_info): Likewise.
	(procfs_attach): Adjust.  Set the attach_flag here.
	(do_attach): Don't set it here.
	(procfs_detach): Don't clear it.
	(procfs_mourn_inferior): Don't clear it.
	* solib-osf.c (osf_solib_create_inferior_hook): Adjust.
	* target.c (attach_flag): Delete.
	(generic_mourn_inferior): Don't clear it.
	* win32-nat.c (get_win32_debug_event): Get it from the event
	process.
	(do_initial_win32_stuff): Add attaching argument.  Set attach_flag
	in the inferior accordingly.
	(win32_attach): Don't set the attach_flag here.  Pass 1 to
	do_intial_win32_stuff.
	(win32_files_info): Get it from the current inferior.
	(win32_create_inferior): Dont clear attach_flag here.  Pass 0 to
	do_intial_win32_stuff.
@
text
@d5549 1
d5556 1
a5556 1
      argv = buildargv (args);
d7495 4
a7498 3
  argv = buildargv (args);
  if (argv == NULL)
    nomem (0);
d7514 4
a7517 3
  argv = buildargv (args);
  if (argv == NULL)
    nomem (0);
d7533 4
a7536 3
  argv = buildargv (args);
  if (argv == NULL)
    nomem (0);
@


1.310.2.1
log
@2008-09-30  Michael Snyder  <msnyder@@vmware.com>

	Remote interface for reverse debugging.
	* remote.c (remote_get_execdir, remote_set_execdir): New methods.
	(remote_vcont_resume): Jump out if attempting reverse execution.
	(remote_resume): Check for reverse exec direction, and send
	appropriate command to target.
	(remote_wait): Check target response for NO_HISTORY status.
	Also check for empty reply (target doesn't understand "bs" or "bc).
	(_initialize_remote): Add new methods to remote target vector.
@
text
@d3388 1
a3388 9
  if (target_get_execution_direction () == EXEC_REVERSE)
    {
      /* We don't pass signals to the target in reverse exec mode.  */
      if (info_verbose && siggnal != TARGET_SIGNAL_0)
	warning (" - Can't pass signal %d to target in reverse: ignored.\n",
		 siggnal);
      strcpy (buf, step ? "bs" : "bc");
    }
  else if (siggnal != TARGET_SIGNAL_0)
d3654 2
a3655 9
	  if (buf[1] == '0' && buf[2] == '6')
	    {
	      status->kind = TARGET_WAITKIND_NO_HISTORY;
	    }
	  else
	    {
	      status->kind = TARGET_WAITKIND_STOPPED;
	      status->value.sig = TARGET_SIGNAL_0;
	    }
a7547 29
/* Reverse execution.
   TODO: set up as a capability.  */
static enum exec_direction_kind remote_execdir = EXEC_FORWARD;

static enum exec_direction_kind remote_get_execdir (void)
{
  if (remote_debug && info_verbose)
    printf_filtered ("remote execdir is %s\n",
		     remote_execdir == EXEC_FORWARD ? "forward" :
		     remote_execdir == EXEC_REVERSE ? "reverse" :
		     "unknown");
  return remote_execdir;
}

static int remote_set_execdir (enum exec_direction_kind dir)
{
  if (remote_debug && info_verbose)
    printf_filtered ("Set remote execdir: %s\n",
		     dir == EXEC_FORWARD ? "forward" :
		     dir == EXEC_REVERSE ? "reverse" :
		     "bad direction");

  /* TODO: check target for capability.  */
  if (dir == EXEC_FORWARD || dir == EXEC_REVERSE)
    return (remote_execdir = dir);
  else
    return EXEC_ERROR;
}

a7595 2
  remote_ops.to_get_execdir = remote_get_execdir;
  remote_ops.to_set_execdir = remote_set_execdir;
@


1.310.2.2
log
@2008-10-04  Michael Snyder  <msnyder@@vmware.com>

	* target.c, target.h: Rename execdir to exec_direction.
	* record.c, record.h: Ditto.
	* reverse.c: Ditto.
	* remote.c: Ditto.

	* reverse.c (show_exec_direction_func): Don't error, just inform.
@
text
@d7565 1
a7565 1
static enum exec_direction_kind remote_exec_direction = EXEC_FORWARD;
d7567 1
a7567 1
static enum exec_direction_kind remote_get_exec_direction (void)
d7570 3
a7572 3
    printf_filtered ("remote exec direction is %s\n",
		     remote_exec_direction == EXEC_FORWARD ? "forward" :
		     remote_exec_direction == EXEC_REVERSE ? "reverse" :
d7574 1
a7574 1
  return remote_exec_direction;
d7577 1
a7577 1
static int remote_set_exec_direction (enum exec_direction_kind dir)
d7580 1
a7580 1
    printf_filtered ("Set remote exec direction: %s\n",
d7587 1
a7587 1
    return (remote_exec_direction = dir);
d7640 2
a7641 2
  remote_ops.to_get_exec_direction = remote_get_exec_direction;
  remote_ops.to_set_exec_direction = remote_set_exec_direction;
@


1.310.2.3
log
@2008-10-06  Michael Snyder  <msnyder@@vmware.com>

	* remote.c (remote_get_exec_direction): Use i18n macros.
	(remote_set_exec_direction): Ditto.
@
text
@d7571 2
a7572 2
		     remote_exec_direction == EXEC_FORWARD ? _("forward") :
		     remote_exec_direction == EXEC_REVERSE ? _("reverse") :
d7581 2
a7582 2
		     dir == EXEC_FORWARD ? _("forward") :
		     dir == EXEC_REVERSE ? _("reverse") :
@


1.310.2.4
log
@2008-10-07  Michael Snyder  <msnyder@@vmware.com>

	* target.h (to_set_exec_direction, to_get_exec_direction): Remove.
	(to_can_execute_reverse): New method.
	(enum exec_direction_kind): Move to inferior.h.
	* target.c (update_current_target): Inherit to_can_execute_reverse.
	Remove to_set_exec_direction, to_get_exec_direction.
	* inferior.h (enum exec_direction_kind): Move from target.h.

	* infrun.c (set_exec_direction_func): Move here from reverse.c.
	(show_exec_direction_func): Ditto.
	(proceed): Consult global execution_direction instead of
	target method.
	(handle_inferior_event): Ditto.

	* reverse.c (set_exec_direction_func): Move to infrun.c
	(show_exec_direction_func): Ditto.
	(exec_direction_default): Set infrun global variable.
	(exec_reverse_once): Consult infrun global direction variable.

	* infcmd.c (step_1): Consult infrun global direction variable.
	(step_once): Ditto.
	(until_next_command): Ditto.
	(finish_command): Ditto.

	* record.h (record_exec_direction): Delete.
	(RECORD_IS_REPLAY): Consult infrun global direction variable.

	* record.c: (record_wait_cleanups): Use infrun state variable.
	(record_wait): Ditto.
	(record_get_exec_direction, record_set_exec_direction): Remove.
	(record_can_execute_reverse): New target method.

	* remote.c (remote_resume): Use infrun state variable.
	(remote_get_exec_direction, remote_set_exec_direction): Remove.
	(remote_can_execute_reverse): New target method.
@
text
@d3388 1
a3388 1
  if (execution_direction == EXEC_REVERSE)
d7563 27
a7589 6
static int remote_target_can_reverse = 1;

static int
remote_can_execute_reverse (void)
{
  return remote_target_can_reverse;
d7640 2
a7641 1
  remote_ops.to_can_execute_reverse = remote_can_execute_reverse;
@


1.310.2.5
log
@2008-10-13  Michael Snyder  <msnyder@@vmware.com>

	* remote.c (remote_wait): Remove handling of "E6" no_history error.

2008-10-10  Michael Snyder  <msnyder@@vmware.com>

	* remote.c (remote_wait): Recognize "replaylog" reply as part
	of 'T' stop event (NO_HISTORY).
	Declare "end of replay history" error reply as deprecated.
@
text
@a3618 1
  int replay_event = 0;
d3662 9
a3670 2
	  status->kind = TARGET_WAITKIND_STOPPED;
	  status->value.sig = TARGET_SIGNAL_0;
a3736 10
		    else if (strncmp (p, "replaylog", p1 - p) == 0)
		      {
			/* NO_HISTORY event.
			   p1 will indicate "begin" or "end", but
			   it makes no difference for now, so ignore it.  */
			replay_event = 1;
			p_temp = strchr (p1 + 1, ';');
			if (p_temp)
			  p = p_temp;
		      }
a3781 2
	  else if (replay_event)
	    status->kind = TARGET_WAITKIND_NO_HISTORY;
@


1.309
log
@	Implement remote multi-process extensions.

	* remote.c (struct remote_state): Add extended and
	multi_process_aware fields.
	(remote_multi_process_p): New.
	(PACKET_vKill): New.
	(record_currthread): Use thread_change_ptid.  Notice new
	inferiors.
	(set_thread, remote_thread_alive): Use write_ptid.
	(write_ptid, read_ptid): New.
	(remote_current_thread, remote_threads_extra_info): Use them.
	(remote_threads_info): Likewise.  Detect new inferiors.
	(remote_start_remote): Add inferior to inferior list.
	(remote_multi_process_feature): New.
	(remote_protocol_features): Add "multiprocess" feature.
	(remote_query_supported): Pass "multiprocess+" as supported
	features.
	(remote_open_1): Clear multi_process_aware.  Set extended
	accordingly.
	(remote_detach_1): Detach current process.  Use extended packet
	format for extended-remote multi-process.  Detach process from the
	inferior list.  Only mourn after printing output.
	(extended_remote_attach_1): Add process to the inferior list.
	(remote_vcont_resume): Use write_ptid to pass the thread ids.
	(remote_wait): Use read_ptid.  Implement the extended
	multi-process extension format of the 'W' and 'X' reply packets.
	Remove exited inferiors from inferior list.
	(remote_xfer_memory): Set general thread.
	(remote_vkill): New.
	(extended_remote_kill): New.
	(remote_mourn_1): Discard all inferiors.
	(select_new_thread_callback): New.
	(extended_remote_mourn_1): If there are more processes to debug,
	switch to a thread in another process, and don't pop the target.
	(extended_remote_create_inferior_1): Add the new process to the
	inferior list.
	(remote_stopped_by_watchpoint): Indenting.
	(remote_xfer_partial): Set the general thread.
	(remote_pid_to_str): If the remote is multi-process aware, print
	the process id as well as the thread id.
	(remote_get_thread_local_address): Use write_ptid.
	(init_extended_remote_ops): Register extended_remote_kill.
	(_initialize_remote): Register new packets.  Change
	magic_null_ptid's, not_sent_ptid's and any_thread_ptid's pid
	member to 42000.

	* thread.c (thread_change_ptid): Also account for the inferior pid
	changing.

	* inferior.h (discard_all_inferiors): Declare.
	* inferior.c (discard_all_inferiors): New.
@
text
@d3077 1
d3117 2
a3118 1
  add_inferior (pid);
a3122 2
  attach_flag = 1;

a5626 1
  attach_flag = 0;
@


1.308
log
@	* remote.c: Include "gdb_stat.h".
@
text
@d211 3
d259 7
d268 7
d960 1
d1089 9
d1107 2
a1108 2
	  struct thread_info *th = find_thread_pid (inferior_ptid);
	  inferior_ptid = th->ptid = currthread;
d1110 2
a1111 1
      else if (ptid_equal (magic_null_ptid, inferior_ptid))
d1118 2
a1119 2
	  struct thread_info *th = find_thread_pid (inferior_ptid);
	  inferior_ptid = th->ptid = currthread;
d1121 3
a1123 3
      else
	/* This is really a new thread.  Add it.  */
	add_thread (currthread);
d1125 6
d1216 1
a1216 7
    {
      int tid = ptid_get_tid (ptid);
      if (tid < 0)
	xsnprintf (buf, endbuf - buf, "-%x", -tid);
      else
	xsnprintf (buf, endbuf - buf, "%x", tid);
    }
d1246 1
d1258 6
a1263 4
  if (tid < 0)
    xsnprintf (rs->buf, get_remote_packet_size (), "T-%08x", -tid);
  else
    xsnprintf (rs->buf, get_remote_packet_size (), "T%08x", tid);
d1384 65
d2015 1
a2015 10
    {
      /* Use strtoul here, so we'll correctly parse values whose
	 highest bit is set.  The protocol carries them as a simple
	 series of hex digits; in the absence of a sign, strtol will
	 see such values as positive numbers out of range for signed
	 'long', and return LONG_MAX to indicate an overflow.  */
      tid = strtoul (&rs->buf[2], NULL, 16);
      pid = ptid_get_pid (oldpid);
      return ptid_build (pid, 0, tid);
    }
a2042 2
  int tid;
  int pid;
d2059 13
a2071 11
		  /* Use strtoul here, so we'll correctly parse values
		     whose highest bit is set.  The protocol carries
		     them as a simple series of hex digits; in the
		     absence of a sign, strtol will see such values as
		     positive numbers out of range for signed 'long',
		     and return LONG_MAX to indicate an overflow.  */
		  tid = strtoul (bufp, &bufp, 16);
		  pid = ptid_get_pid (inferior_ptid);
		  new_thread = ptid_build (pid, 0, tid);
		  if (tid != 0 && !in_thread_list (new_thread))
		    add_thread (new_thread);
d2120 7
a2126 2
      xsnprintf (rs->buf, get_remote_packet_size (), "qThreadExtraInfo,%lx",
		 ptid_get_tid (tp->ptid));
d2416 2
d2615 8
d2641 1
d2662 5
a2666 1
      putpkt ("qSupported");
d2863 2
d2987 1
d2997 5
a3001 1
  strcpy (rs->buf, "D");
d3005 5
a3009 1
  if (rs->buf[0] == 'E')
a3015 1
  target_mourn_inferior ();
d3018 3
a3020 2
      if (extended)
	puts_filtered ("Detached from remote process.\n");
d3022 6
a3027 1
	puts_filtered ("Ending remote debugging.\n");
d3029 3
d3116 2
d3262 2
a3263 2
  char *outbuf;
  struct cleanup *old_cleanup;
d3271 3
d3285 1
a3285 1
	outbuf = xstrprintf ("vCont;S%02x", siggnal);
d3287 1
a3287 1
	outbuf = xstrprintf ("vCont;s");
d3289 1
a3289 1
	outbuf = xstrprintf ("vCont;C%02x", siggnal);
d3291 1
a3291 1
	outbuf = xstrprintf ("vCont;c");
a3295 1
      int tid = ptid_get_tid (inferior_ptid);
d3297 7
a3303 1
	outbuf = xstrprintf ("vCont;S%02x:%x;c", siggnal, tid);
d3305 7
a3311 1
	outbuf = xstrprintf ("vCont;s:%x;c", tid);
d3313 7
a3319 1
	outbuf = xstrprintf ("vCont;C%02x:%x;c", siggnal, tid);
d3321 1
a3321 1
	outbuf = xstrprintf ("vCont;c");
a3325 1
      int tid = ptid_get_tid (ptid);
d3327 5
a3331 1
	outbuf = xstrprintf ("vCont;S%02x:%x", siggnal, tid);
d3333 5
a3337 1
	outbuf = xstrprintf ("vCont;s:%x", tid);
d3339 5
a3343 1
	outbuf = xstrprintf ("vCont;C%02x:%x", siggnal, tid);
d3345 5
a3349 1
	outbuf = xstrprintf ("vCont;c:%x", tid);
d3352 2
a3353 6
  gdb_assert (outbuf && strlen (outbuf) < get_remote_packet_size ());
  old_cleanup = make_cleanup (xfree, outbuf);

  putpkt (outbuf);

  do_cleanups (old_cleanup);
d3608 1
a3608 2
  ULONGEST thread_num = -1;
  ULONGEST process_num = -1;
d3703 1
a3703 4
		      {
			p_temp = unpack_varlen_hex (++p1, &thread_num);
			p = p_temp;
		      }
d3775 1
d3777 46
a3822 3
	    /* The remote process exited.  */
	    status->kind = TARGET_WAITKIND_EXITED;
	    status->value.integer = (fromhex (buf[1]) << 4) + fromhex (buf[2]);
a3824 6
	case 'X':
	  status->kind = TARGET_WAITKIND_SIGNALLED;
	  status->value.sig = (enum target_signal)
	    (((fromhex (buf[1])) << 4) + (fromhex (buf[2])));

	  goto got_status;
d3859 7
a3865 1
  if (thread_num != -1)
d3867 4
a3870 4
      ptid_t ptid;
      ptid = ptid_build (ptid_get_pid (inferior_ptid), 0, thread_num);
      record_currthread (ptid);
      return ptid;
d3873 1
a3873 1
  return inferior_ptid;
d4765 2
d5391 52
d5453 4
d5461 13
d5482 1
a5482 9
  /* Call common code to mark the inferior as not running.  */
  generic_mourn_inferior ();

  /* Check whether the target is running now - some remote stubs
     automatically restart after kill.  */
  putpkt ("?");
  getpkt (&rs->buf, &rs->buf_size, 0);

  if (rs->buf[0] == 'S' || rs->buf[0] == 'T')
d5484 6
a5489 5
      /* Assume that the target has been restarted.  Set inferior_ptid
	 so that bits of core GDB realizes there's something here, e.g.,
	 so that the user can say "kill" again.  */
      inferior_ptid = remote_current_thread (magic_null_ptid);
      add_thread_silent (inferior_ptid);
d5493 28
a5520 3
      /* Mark this (still pushed) target as not executable until we
	 restart it.  */
      target_mark_exited (target);
d5630 1
d5840 1
a5840 1
    return remote_stopped_by_watchpoint_p;
d6198 1
a6198 1
  struct remote_state *rs = get_remote_state ();
d6203 4
d6685 1
d6692 7
d6719 1
d6724 1
a6724 1
      p += hexnumstr (p, ptid_get_tid (ptid));
d7630 1
d7962 3
d8009 3
a8011 3
  magic_null_ptid = ptid_build (0, 1, -1);
  not_sent_ptid = ptid_build (0, 1, -2);
  any_thread_ptid = ptid_build (0, 1, 0);
@


1.307
log
@ChangeLog:

	* remote.h (remote_filename_p, remote_bfd_open): Add prototypes.
	* remote.c (remote_bfd_iovec_open, remote_bfd_iovec_close,
	remote_bfd_iovec_pread, remote_bfd_iovec_stat, remote_filename_p,
	remote_bfd_open): New functions.
	(remote_hostio_send_command): Fail safely if remote connection
	is not set up.

	* solist.h (solib_open): Remove prototype.
	(solib_bfd_open): Add prototype.
	* solib.c: Include "remote.h".
	(solib_open): Remove, replace by ...
	(solib_bfd_open): ... this new function.  Handle remote BFDs.
	(solib_map_sections): Replace solib_open by solib_bfd_open.
	* solib-frv.c: Include "exceptions.h".
	(enable_break2): Replace solib_open by solib_bfd_open.
	* solib-svr4.c: Include "exceptions.h".
	(enable_break): Replace solib_open by solib_bfd_open.

	* symfile.c: Include "remote.h".
	(build_id_verify): Handle remote BFDs.
	(separate_debug_file_exists): Use BFD to access file.  Handle
	remote BFDs.
	(symfile_bfd_open): Handle remote BFDs.
	(reread_symbols): Handle remote BFDs.

	* NEWS: Mention "remote:" argument prefix to "set sysroot".

doc/ChangeLog:

	* gdb.texinfo (Commands to Specify Files): Document "remote:"
	argument prefix to "set sysroot".
@
text
@d62 1
@


1.306
log
@	* gdbarch.sh (target_gdbarch): New global variable.
	(deprecated_current_gdbarch_select_hack): Set it.
	* gdbarch.c, gdbarch.h: Regenerate.

	* arch-utils.c (gdbarch_update_p): Use target_gdbarch instead
	of current_gdbarch.
	* target-descriptions.c (target_find_description): Likewise.
	* arm-tdep.c (arm_update_current_architecture): Likewise.
	(show_fp_model, arm_show_abi, arm_show_fallback_mode,
	arm_show_force_mode): Likewise.
	* mips-tdep.c (show_mask_address, show_mipsfpu_command,
	show_mips_abi): Likewise.
	* mep-tdep.c (me_module_register_set, current_me_module): Likewise.

	* target.c (target_translate_tls_address): Use target_gdbarch
	instead of current_gdbarch.
	* remote.c (struct packet_reg): Likewise.
	(get_remote_arch_state, packet_reg_from_regnum,
	packet_reg_from_pnum, remote_check_symbols, remote_wait,
	remote_address_masked, remote_insert_breakpoint,
	remote_insert_hw_breakpoint, remote_read_description): Likewise.
	* remote-m32r-sdi.c (m32r_resume, m32r_wait): Likewise.
	* remote-mips.c (mips_open, mips_common_breakpoint): Likewise.
	* cris-tdep.c (cris_can_use_hardware_watchpoint): Likewise.

	* solib.c (solib_open, solib_map_sections, solib_read_symbols,
	solib_add, info_sharedlibrary_command, solib_address,
	solib_create_inferior_hook, in_solib_dynsym_resolve_code,
	solib_global_lookup): Likewise.
	* solib-frv.c (enable_break2, frv_relocate_main_executable): Likewise.
	* solib-irix.c (irix_current_sos, irix_open_symbol_file_object):
	Likewise.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Likewise.
	* solib-svr4.c (exec_entry_point, enable_break, svr4_free_so,
	set_solib_svr4_fetch_link_map_offsets, svr4_fetch_link_map_offsets):
	Likewise.
	* nto-tdep.c (nto_find_and_open_solib, nto_init_solib_absolute_prefix,
	nto_truncate_ptr): Likewise.
	* mips-linux-tdep.c (mips_linux_in_dynsym_stub): Likewise.
@
text
@d6671 2
a6672 1
  if (remote_protocol_packets[which_packet].support == PACKET_DISABLE)
d6936 91
@


1.305
log
@	* target.c (target_async_permitted, target_async_permitted_1)
        (set_maintenance_target_async_permitted)
        (show_maintenance_target_async_permitted): New.
        (initialize_targets): Register 'set target-async'.
        * target.h (target_async_permitted): Declare.
        * linux-nat.c (linux_nat_async_enabled)
        (linux_nat_async_permitted, set_maintenance_linux_async_permitted)
        (show_maintenance_linux_async_permitted): Remove.
        (sigchld_handler, linux_nat_is_async_p, linux_nat_can_async_p)
        (get_pending_events, linux_nat_async): Use target_async_permitted.
        (linux_nat_set_async_mode): Remove, moving the only used bits
        into...
        (linux_nat_setup_async): This.
        (_initialize_linux_nat): Do not register 'maint set linux-async'.
        Use linux_nat_setup_async.
        * remote.c (remote_async_permitted, remote_async_permitted_set)
        (set_maintenance_remote_async_permitted)
        (show_maintenance_remote_async_permitted): Remove.
        (remote_open_1, remote_terminal_inferior, remote_can_async_p)
        (remote_is_async_p): Use target_async_permitted.
        (_initialize_remote): Don't register 'main set remote-async'.
        * mi/mi-cmds.c (mi_cmds): Register -list-target-features.
        * mi/mi-cmds.h (mi_cmd_list_target_features): New.
        * mi/mi-main.c (mi_cmd_list_target_features): New.
@
text
@d277 1
a277 1
  /* long size in bytes;  == register_size (current_gdbarch, regnum);
d279 1
a279 1
  /* char *name; == gdbarch_register_name (current_gdbarch, regnum);
d312 1
a312 1
  return gdbarch_data (current_gdbarch, remote_gdbarch_data_handle);
d448 1
a448 1
  if (regnum < 0 && regnum >= gdbarch_num_regs (current_gdbarch))
d462 1
a462 1
  for (i = 0; i < gdbarch_num_regs (current_gdbarch); i++)
d2403 1
a2403 1
	  sym_addr = gdbarch_convert_from_func_ptr_addr (current_gdbarch,
d3591 1
a3591 1
					 register_size (current_gdbarch,
d3594 1
a3594 1
		    if (fieldsize < register_size (current_gdbarch,
d4108 1
a4108 1
    address_size = gdbarch_addr_bit (current_gdbarch);
d5376 1
a5376 2
      gdbarch_breakpoint_from_pc
	(current_gdbarch, &addr, &bpsize);
d5578 1
a5578 1
    (current_gdbarch, &bp_tgt->placed_address, &bp_tgt->placed_size);
d6507 1
a6507 1
    = gdbarch_data (current_gdbarch, remote_g_packet_data_handle);
@


1.304
log
@gdb/doc/
2008-08-12  Sandra Loosemore  <sandra@@codesourcery.com>

	* gdb.texinfo (Remote Configuration): Document set remote noack-packet.
	(Remote Protocol): Add Packet Acknowledgment to menu.
	(Overview): Mention +/- can be disabled, and point to new section
	where this is discussed in detail.
	(General Query Packets): Document QStartNoAckMode packet, and
	corresponding qSupported reply.
	(Packet Acknowledgment): New section.

gdb/
2008-08-12  Pedro Alves  <pedro@@codesourcery.com>

	Add no-ack mode to the remote protocol --- optionally stop ACKing
	packets and responses when we have a reliable communication
	medium.

	Based on Apple's GDB, by Jason Molenda <jmolenda@@apple.com>

	* remote.c (struct remote_state): Add noack_mode field.
	(PACKET_QStartNoAckMode): New.
	(remote_start_remote): Don't any outstanding packet here.
	(remote_open_1): Clear noack_mode.  Ack any outstanding packet
	here.  Activate noack mode if requested.
	(remote_protocol_features): Add QStartNoAckMode.
	(remote_open_1):
	(putpkt_binary): Don't send ack in noack mode.
	(read_frame): Don't recompute the checksum in noack mode.
	(getpkt_sane): Skip sending ack if in noack mode.
	(_initialize_remote): Add set/show remote noack mode.
	* NEWS:  Note the new features.

gdb/gdbserver/
2008-08-12  Pedro Alves  <pedro@@codesourcery.com>

	* remote-utils.c (noack_mode, transport_is_reliable): New globals.
	(remote_open): Set or clear transport_is_reliable.
	(putpkt_binary): Don't expect acks in noack mode.
	(getpkt): Don't send ack/nac in noack mode.
	* server.c (handle_general_set): Handle QStartNoAckMode.
	(handle_query): If connected by tcp pass QStartNoAckMode+ in
	qSupported.
	(main): Reset noack_mode on every connection.
	* server.h (noack_mode): Declare.
@
text
@a211 27
/* Controls if async mode is permitted.  */
static int remote_async_permitted = 0;

static int remote_async_permitted_set = 0;

static void
set_maintenance_remote_async_permitted (char *args, int from_tty,
					struct cmd_list_element *c)
{
  if (target_has_execution)
    {
      remote_async_permitted_set = remote_async_permitted; /* revert */
      error (_("Cannot change this setting while the inferior is running."));
    }

  remote_async_permitted = remote_async_permitted_set;
}

static void
show_maintenance_remote_async_permitted (struct ui_file *file, int from_tty,
					 struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("\
Controlling the remote inferior in asynchronous mode is %s.\n"),
		    value);
}

d2679 1
a2679 1
  if (!remote_async_permitted)
d2800 1
a2800 1
  if (remote_async_permitted)
d2845 1
a2845 1
	if (remote_async_permitted)
d2851 1
a2851 1
  if (remote_async_permitted)
d3379 1
a3379 1
  if (!remote_async_permitted)
d3409 1
a3409 1
  if (!remote_async_permitted)
d7241 1
a7241 1
  if (!remote_async_permitted)
d7252 1
a7252 1
  if (!remote_async_permitted)
a7605 11
  add_setshow_boolean_cmd ("remote-async", class_maintenance,
			   &remote_async_permitted_set, _("\
Set whether gdb controls the remote inferior in asynchronous mode."), _("\
Show whether gdb controls the remote inferior in asynchronous mode."), _("\
Tells gdb whether to control the remote inferior in asynchronous mode."),
			   set_maintenance_remote_async_permitted,
			   show_maintenance_remote_async_permitted,
			   &maintenance_set_cmdlist,
			   &maintenance_show_cmdlist);


@


1.303
log
@	* remote.c (remote_threads_extra_info): Don't query the remote
	server about info on the internally added main thread.
@
text
@d277 5
d968 1
a2305 3
  /* Ack any packet which the remote side has already sent.  */
  serial_write (remote_desc, "+", 1);

d2563 2
d2698 2
d2781 1
d2790 3
d2798 25
d4828 5
d4909 1
d4965 1
d5011 6
d5175 4
a5178 1
	  serial_write (remote_desc, "+", 1);
d5184 3
a5186 1
      serial_write (remote_desc, "-", 1);
d5193 4
a5196 1
  serial_write (remote_desc, "+", 1);
d7591 3
@


1.302
log
@	Non-stop inferior control.

	* infrun.c (resume): In non-stop mode, always resume just one
	thread.
	(proceed): Don't call prepare_to_proceed in non-stop mode.
	(fetch_inferior_event): In non-stop mode, switch context before
	handling the event.
	(error_is_running, ensure_not_running): New.
	(handle_inferior_event): In non-stop mode: Mark only the event
	thread as stopped.  Require that the target module manages adding
	threads to the thread list.  Assert that there isn't a
	deferred_step_ptid set.  Don't switch to infwait_thread_hop_state.
	(normal_stop): Only mark not-running if inferior hasn't exited.
	In non-stop mode, only mark the event thread.

	* thread.c:Include "cli/cli-decode.h".
	(print_thread_info): Don't read from a running thread.
	Output "(running)" if thread is running.
	(switch_to_thread): Don't read stop_pc if thread is executing.
	(do_restore_current_thread_cleanup): Don't write to a running
	thread.
	(thread_apply_all_command): Don't read from a running thread.  In
	non-stop mode, do a full context-switch instead of just switching
	threads.
	(thread_apply_command): In non-stop mode, do a full context-switch
	instead of just switching threads.
	(do_captured_thread_select): Likewise.  Inform user if selected
	thread is running.
	(_initialize_thread): Mark "info threads" and "thread" and
	async_ok.

	* inf-loop.c (inferior_event_handler): In non-stop mode, don't
	unregister the target from the event loop.

	* infcmd.c (continue_command, step_1, jump_command)
	(signal_command): Ensure the selected thread isn't running.
	(interrupt_target_command): In non-stop mode, interrupt only the
	selected thread.

	* inferior.h (error_is_running, ensure_not_running): Declare.

	* target.h (struct target_ops): Add ptid argument to the to_stop
	member.
	(target_stop): Add ptid_t argument.

	* target.c (update_current_target): Add ptid argument to to_stop's
	type.
	(debug_to_stop): Add ptid_t argument.
	(debug_to_rcmd): Set to_stop_ptid.

	* remote.c (remote_stop): Add ptid_t argument.
	(async_remote_interrupt): Add inferior_ptid to target_stop.
	* inf-ptrace.c (inf_ptrace_stop): Add ptid argument.

	* Makefile.in (thread.o): Depend on $(cli_decode_h).
@
text
@d2045 6
@


1.302.2.1
log
@2008-07-17  Michael Snyder  <msnyder@@specifix.com>
	2006-05-02  Michael Snyder  <msnyder@@redhat.com>

	* Target interface for reverse execution.
	* target.h (enum target_waitkind):
	Add new wait event, TARGET_WAITKIND_NO_HISTORY.
	(enum exec_direction_kind): New enum.
	(struct target_ops): New methods to_set_execdir, to_get_execdir.
	* target.c (target_get_execdir): New generic method.
	(target_set_execdir): Ditto.
	* remote.c (remote_get_execdir, remote_set_execdir): New methods.
	(remote_vcont_resume): Jump out if attempting reverse execution.
	(remote_resume): Check for reverse exec direction, and send
	appropriate command to target.
	(remote_wait): Check target response for NO_HISTORY status.
	Also check for empty reply (target doesn't understand "bs" or "bc).
	(_initialize_remote): Add new methods to remote target vector.

	* breakpoint.h (breakpoint_silence): Export.
	* breakpoint.c (breakpoint_silence): New function.
	* infcmd.c (finish_command): Check for reverse exec direction.
	(finish_backward): New function, handle finish cmd in reverse.
	* infrun.c (enum inferior_stop_reason): Add NO_HISTORY reason.
	(handle_inferior_event): Handle TARGET_WAITKIND_NO_HISTORY.
	Handle stepping over a function call in reverse.
	Handle stepping thru a line range in reverse.
	Handle setting a step-resume breakpoint in reverse.
	Handle stepping into a function in reverse.
	Handle stepping between line ranges in reverse.
	(print_stop_reason): Print reason for NO_HISTORY.

	2006-03-31  Michael Snyder  <msnyder@@redhat.com>
	User interface for reverse execution.
	* Makefile.in (reverse.c): New file.
	* reverse.c: New file.  User interface for reverse execution.

	2007-04-18  Daniel Jacobowitz  <dan@@codesourcery.com>

	* infcmd.c (finish_backwards): Correct check for whether to back
	up after finishing.

	* arm-tdep.c (arm_scan_epilogue): New.
	(arm_make_prologue_cache): Use it.
	(arm_epilogue_unwind_sniffer): New.
	(arm_gdbarch_init): Register it.
@
text
@d3213 1
a3213 9
  if (target_get_execution_direction () == EXEC_REVERSE)
    {
      /* We don't pass signals to the target in reverse exec mode.  */
      if (info_verbose && siggnal != TARGET_SIGNAL_0)
	warning (" - Can't pass signal %d to target in reverse: ignored.\n",
		 siggnal);
      strcpy (buf, step ? "bs" : "bc");
    }
  else if (siggnal != TARGET_SIGNAL_0)
d3480 2
a3481 9
	  if (buf[1] == '0' && buf[2] == '6')
	    {
	      status->kind = TARGET_WAITKIND_NO_HISTORY;
	    }
	  else
	    {
	      status->kind = TARGET_WAITKIND_STOPPED;
	      status->value.sig = TARGET_SIGNAL_0;
	    }
a7118 29
/* Reverse execution.
   FIXME: set up as a capability.  */
static enum exec_direction_kind remote_execdir = EXEC_FORWARD;

static enum exec_direction_kind remote_get_execdir (void)
{
  if (remote_debug && info_verbose)
    printf_filtered ("remote execdir is %s\n",
		     remote_execdir == EXEC_FORWARD ? "forward" :
		     remote_execdir == EXEC_REVERSE ? "reverse" :
		     "unknown");
  return remote_execdir;
}

static int remote_set_execdir (enum exec_direction_kind dir)
{
  if (remote_debug && info_verbose)
    printf_filtered ("Set remote execdir: %s\n",
		     dir == EXEC_FORWARD ? "forward" :
		     dir == EXEC_REVERSE ? "reverse" :
		     "bad direction");

  /* FIXME: check target for capability.  */
  if (dir == EXEC_FORWARD || dir == EXEC_REVERSE)
    return (remote_execdir = dir);
  else
    return EXEC_ERROR;
}

a7166 2
  remote_ops.to_get_execdir = remote_get_execdir;
  remote_ops.to_set_execdir = remote_set_execdir;
@


1.302.2.2
log
@2008-10-05  Michael Snyder  <msnyder@@vmware.com>

	* target.c, target.h: Rename execdir to exec_direction.
	* record.c, record.h: Ditto.
	* reverse.c: Ditto.
	* remote.c: Ditto.
@
text
@d7136 1
a7136 1
static enum exec_direction_kind remote_exec_direction = EXEC_FORWARD;
d7138 1
a7138 1
static enum exec_direction_kind remote_get_exec_direction (void)
d7141 3
a7143 3
    printf_filtered ("remote exec_direction is %s\n",
		     remote_exec_direction == EXEC_FORWARD ? "forward" :
		     remote_exec_direction == EXEC_REVERSE ? "reverse" :
d7145 1
a7145 1
  return remote_exec_direction;
d7148 1
a7148 1
static int remote_set_exec_direction (enum exec_direction_kind dir)
d7151 1
a7151 1
    printf_filtered ("Set remote exec_direction: %s\n",
d7158 1
a7158 1
    return (remote_exec_direction = dir);
d7211 2
a7212 2
  remote_ops.to_get_exec_direction = remote_get_exec_direction;
  remote_ops.to_set_exec_direction = remote_set_exec_direction;
@


1.302.2.3
log
@2008-10-06  Michael Snyder  <msnyder@@vmware.com>

	* remote.c (remote_get_exec_direction): Use i18n macros.
	(remote_set_exec_direction): Ditto.
@
text
@d7138 1
a7138 2
static enum exec_direction_kind 
remote_get_exec_direction (void)
d7142 3
a7144 3
		     remote_exec_direction == EXEC_FORWARD ? _("forward") :
		     remote_exec_direction == EXEC_REVERSE ? _("reverse") :
		     _("unknown"));
d7152 3
a7154 3
		     dir == EXEC_FORWARD ? _("forward") :
		     dir == EXEC_REVERSE ? _("reverse") :
		     _("bad direction"));
@


1.302.2.4
log
@2008-10-07  Michael Snyder  <msnyder@@vmware.com>

	* target.h (to_set_exec_direction, to_get_exec_direction): Remove.
	(to_can_execute_reverse): New method.
	(enum exec_direction_kind): Move to inferior.h.
	* target.c (update_current_target): Inherit to_can_execute_reverse.
	Remove to_set_exec_direction, to_get_exec_direction.
	* inferior.h (enum exec_direction_kind): Move from target.h.

	* infrun.c (set_exec_direction_func): Move here from reverse.c.
	(show_exec_direction_func): Ditto.
	(proceed): Consult global execution_direction instead of
	target method.
	(handle_inferior_event): Ditto.

	* reverse.c (set_exec_direction_func): Move to infrun.c
	(show_exec_direction_func): Ditto.
	(exec_direction_default): Set infrun global variable.
	(exec_reverse_once): Consult infrun global direction variable.

	* infcmd.c (step_1): Consult infrun global direction variable.
	(step_once): Ditto.
	(until_next_command): Ditto.
	(finish_command): Ditto.

	* record.h (record_exec_direction): Delete.
	(RECORD_IS_REPLAY): Consult infrun global direction variable.

	* record.c: (record_wait_cleanups): Use infrun state variable.
	(record_wait): Ditto.
	(record_get_exec_direction, record_set_exec_direction): Remove.
	(record_can_execute_reverse): New target method.

	* remote.c (remote_resume): Use infrun state variable.
	(remote_get_exec_direction, remote_set_exec_direction): Remove.
	(remote_can_execute_reverse): New target method.
@
text
@d3213 1
a3213 1
  if (execution_direction == EXEC_REVERSE)
d7134 28
a7161 6
static int remote_target_can_reverse = 1;

static int
remote_can_execute_reverse (void)
{
  return remote_target_can_reverse;
d7212 2
a7213 1
  remote_ops.to_can_execute_reverse = remote_can_execute_reverse;
@


1.301
log
@	Add "executing" property to threads.

	* inferior.h (target_executing): Delete.
	* gdbthread.h (struct thread_info): Add executing_ field.
	(set_executing, is_executing): New.
	* thread.c (main_thread_executing): New.
	(init_thread_list): Clear it and also main_thread_running.
	(is_running): Return false if target has no execution.
	(any_running, is_executing, set_executing): New.

	* top.c: Include "gdbthread.h".
	(target_executing): Delete.
	(execute_command): Replace target_executing check by any_running.
	* event-top.c: Include "gdbthread.h".
	(display_gdb_prompt, command_handler): Replace target_executing by
	is_running.
	* inf-loop.c: Include "gdbthread.h".  Don't mark as not executing
	here.  Replace target_executing by is_running.
	* infrun.c (handle_inferior_event): Mark all threads as
	not-executing.
	* linux-nat.c (linux_nat_resume): Don't mark thread as executing
	here.
	* stack.c (get_selected_block): Return null if inferior is
	executing.
	* target.c (target_resume): Mark resumed ptid as executing.
	* breakpoint.c (until_break_command): Replace target_executing
	check by is_executing.
	* remote.c (remote_async_resume): Don't mark inferior as executing
	here.
	* mi/mi-interp.c (mi_cmd_interpreter_exec): Replace target_executing
	by any_running.

	* mi/mi-main.c (mi_cmd_exec_interrupt, mi_cmd_execute)
	(mi_execute_async_cli_command): Replace target_executing by
	is_running.

	* frame.c (get_current_frame): Error out if the current thread is
	executing.
	(has_stack_frames): New.
	(get_selected_frame, deprecated_safe_get_selected_frame): Check
	has_stack_frames.

	* Makefile.in (event-top.o, frame.o, inf-loop.o, top.o): Depend on
	$(gdbthread_h).
@
text
@d158 1
a158 1
static void remote_stop (void);
d3272 1
a3272 1
  target_stop ();
d3326 1
a3326 1
remote_stop (void)
@


1.300
log
@        * remote.c (remote_insert_breakpoint): Ensure that if Z0
        unsupported and we fall back to memory_insert_breakpoint, we
        use the unmodified requested address.
@
text
@a3234 7
  /* Tell the world that the target is now executing.  */
  /* FIXME: cagney/1999-09-23: Is it the targets responsibility to set
     this?  Instead, should the client of target just assume (for
     async targets) that the target is going to start executing?  Is
     this information already found in the continuation block?  */
  if (target_is_async_p ())
    target_executing = 1;
@


1.299
log
@	* infrun.c (start_remote): Don't clear thread list here.
	* monitor.c (monitor_open): Include "gdbthread.h".  Clear thread
	list here.
	* remote.c (record_currthread): Upgrade the main thread and its
	entry in the thread list if this is the first time we hear about
	threads.
	(remote_thread_alive): Consider magic_null_ptid or a ptid without
	a tid member always alive.
	(remote_find_new_threads): Don't update the main thread here.
	(remote_start_remote): Clear thread list here.  Always add the
	main thread.
	(extended_remote_attach_1): Add the main thread here.
	(extended_remote_mourn_1): Re-add the main thread here.
	(extended_remote_create_inferior_1): Add a main thread.

	* Makefile.in (monitor.o): Depend on $(gdbthread_h).
@
text
@d5342 1
a5342 1
      CORE_ADDR addr;
d5345 1
d5348 1
a5348 1
	(current_gdbarch, &bp_tgt->placed_address, &bp_tgt->placed_size);
d5356 1
a5356 1
      addr = (ULONGEST) remote_address_masked (bp_tgt->placed_address);
d5358 1
a5358 1
      sprintf (p, ",%d", bp_tgt->placed_size);
d5368 2
@


1.298
log
@	Use ptid_t.tid to store thread ids instead of ptid_t.pid.

	* remote.c (magic_null_ptid, not_sent_ptid, any_thread_ptid): New
	globals.
	(general_thread, continue_thread): Change type to ptid_t.
	(record_currthread): Take a ptid_t parameter instead of an
	integer.
	(MAGIC_NULL_PID): Delete.
	(set_thread): Take a ptid_t parameter and adjust.
	(set_general_thread, set_continue_thread): New.
	(remote_thread_alive, remote_newthread_step)
	(remote_current_thread, remote_find_new_threads)
	(remote_threads_info, remote_start_remote, remote_vcont_resume)
	(remote_resume_1, remote_wait, extended_remote_create_inferior_1)
	(threadalive_test, remote_pid_to_str)
	(remote_get_thread_local_address): Adjust.
	(_initialize_remote): Initialize magic_null_ptid, not_sent_ptid
	and any_thread_ptid.
@
text
@d1092 25
a1116 1
    add_thread (currthread);
d1239 10
a1961 3
  if (ptid_equal (inferior_ptid, magic_null_ptid))
    /* We don't know the current thread yet.  Query it.  */
    inferior_ptid = remote_current_thread (inferior_ptid);
d2323 3
d2341 3
d2974 3
d5195 2
a5196 1
      inferior_ptid = magic_null_ptid;
d5311 3
@


1.297
log
@	* NEWS: Mention support removal of undocumented S AA p PID stop
	reply packet.

	* remote.c (remote_wait): Remove undocumented S AA p PID support.
@
text
@d141 2
a142 1
static void set_thread (int, int);
d184 1
a184 1
static void record_currthread (int currthread);
d1067 9
a1076 4
/* These are the threads which we last sent to the remote system.
   -1 for all or -2 for not sent yet.  */
static int general_thread;
static int continue_thread;
d1085 1
a1085 1
record_currthread (int currthread)
d1091 2
a1092 2
  if (!in_thread_list (pid_to_ptid (currthread)))
    add_thread (pid_to_ptid (currthread));
d1154 4
a1157 2
#define MAGIC_NULL_PID 42000

d1159 1
a1159 1
set_thread (int th, int gen)
d1162 1
d1164 1
a1164 1
  int state = gen ? general_thread : continue_thread;
d1166 1
a1166 1
  if (state == th)
d1169 9
a1177 3
  buf[0] = 'H';
  buf[1] = gen ? 'g' : 'c';
  if (th == MAGIC_NULL_PID)
d1179 5
a1183 2
      buf[2] = '0';
      buf[3] = '\0';
d1185 1
a1185 5
  else if (th < 0)
    xsnprintf (&buf[2], get_remote_packet_size () - 2, "-%x", -th);
  else
    xsnprintf (&buf[2], get_remote_packet_size () - 2, "%x", th);
  putpkt (buf);
d1188 1
a1188 1
    general_thread = th;
d1190 1
a1190 1
    continue_thread = th;
d1192 13
d1206 2
a1207 1
/*  Return nonzero if the thread TH is still alive on the remote system.  */
d1213 1
a1213 1
  int tid = PIDGET (ptid);
d1833 1
a1833 1
   ading the thread if it does not already exist.  This involves
d1884 2
a1885 3
  ptid_t ptid;

  ptid = pid_to_ptid (threadref_to_int (ref));
d1898 3
d1905 10
a1914 6
    /* Use strtoul here, so we'll correctly parse values whose highest
       bit is set.  The protocol carries them as a simple series of
       hex digits; in the absence of a sign, strtol will see such
       values as positive numbers out of range for signed 'long', and
       return LONG_MAX to indicate an overflow.  */
    return pid_to_ptid (strtoul (&rs->buf[2], NULL, 16));
d1928 2
a1929 1
  if (PIDGET (inferior_ptid) == MAGIC_NULL_PID)	/* ack ack ack */
d1946 2
d1970 4
a1973 2
		  if (tid != 0 && !in_thread_list (pid_to_ptid (tid)))
		    add_thread (pid_to_ptid (tid));
d2016 2
a2017 2
      xsnprintf (rs->buf, get_remote_packet_size (), "qThreadExtraInfo,%x",
		 PIDGET (tp->ptid));
d2033 1
a2033 1
  int_to_threadref (&id, PIDGET (tp->ptid));
d2293 1
a2293 1
  set_thread (-1, 0);
d2302 1
a2302 1
  inferior_ptid = pid_to_ptid (MAGIC_NULL_PID);
d2732 2
a2733 2
  general_thread = -2;
  continue_thread = -2;
d2933 4
d3066 4
a3069 4
   resumed thread should be single-stepped and/or signalled.  If PTID's
   PID is -1, then all threads are resumed; the thread to be stepped and/or
   signalled is given in the global INFERIOR_PTID.  This function returns
   non-zero iff it resumes the inferior.
a3077 1
  int pid = PIDGET (ptid);
d3091 1
a3091 1
  if (PIDGET (inferior_ptid) == MAGIC_NULL_PID)
d3093 4
a3096 3
      /* MAGIC_NULL_PTID means that we don't have any active threads, so we
	 don't have any PID numbers the inferior will understand.  Make sure
	 to only send forms that do not specify a PID.  */
d3106 1
a3106 1
  else if (pid == -1)
d3109 1
d3111 1
a3111 2
	outbuf = xstrprintf ("vCont;S%02x:%x;c", siggnal,
			     PIDGET (inferior_ptid));
d3113 1
a3113 1
	outbuf = xstrprintf ("vCont;s:%x;c", PIDGET (inferior_ptid));
d3115 1
a3115 2
	outbuf = xstrprintf ("vCont;C%02x:%x;c", siggnal,
			     PIDGET (inferior_ptid));
d3122 1
d3124 1
a3124 1
	outbuf = xstrprintf ("vCont;S%02x:%x", siggnal, pid);
d3126 1
a3126 1
	outbuf = xstrprintf ("vCont;s:%x", pid);
d3128 1
a3128 1
	outbuf = xstrprintf ("vCont;C%02x:%x", siggnal, pid);
d3130 1
a3130 1
	outbuf = xstrprintf ("vCont;c:%x", pid);
a3153 1
  int pid = PIDGET (ptid);
d3165 4
a3168 3
  /* All other supported resume packets do use Hc, so call set_thread.  */
  if (pid == -1)
    set_thread (0, 0);		/* Run any thread.  */
d3170 1
a3170 1
    set_thread (pid, 0);	/* Run this thread.  */
d3393 1
a3393 3
   storing status in STATUS just as `wait' would.
   Returns "pid", which in the case of a multi-threaded
   remote OS, is the thread-id.  */
d3401 1
a3497 1
			record_currthread (thread_num);
d3619 4
a3622 1
      return pid_to_ptid (thread_num);
d3624 1
d3827 1
a3827 1
  set_thread (PIDGET (inferior_ptid), 1);
d3976 1
a3976 1
  set_thread (PIDGET (inferior_ptid), 1);
d5155 1
a5155 1
      inferior_ptid = pid_to_ptid (MAGIC_NULL_PID);
d5269 1
a5269 1
  inferior_ptid = pid_to_ptid (MAGIC_NULL_PID);
d6191 1
a6191 1
  set_thread (sample_thread, 1);
d6199 2
d6202 1
a6202 1
  if (remote_thread_alive (pid_to_ptid (sample_thread)))
d6315 1
a6315 1
  static char buf[32];
d6317 13
a6329 2
  xsnprintf (buf, sizeof buf, "Thread %d", ptid_get_pid (ptid));
  return buf;
d6346 1
a6346 1
      p += hexnumstr (p, PIDGET (ptid));
d7540 6
@


1.296
log
@	* remote.c (remote_wait): Include beginning of malformed packet
	in error output.
@
text
@a3527 6

	  if (buf[3] == 'p')
	    {
	      thread_num = strtol ((const char *) &buf[4], NULL, 16);
	      record_currthread (thread_num);
	    }
@


1.296.2.1
log
@Reverse execution branch

2008-06-09  Michael Snyder  <msnyder@@specifix.com>
	2006-05-02  Michael Snyder  <msnyder@@redhat.com>

	* Target interface for reverse execution.
	* target.h (enum target_waitkind):
	Add new wait event, TARGET_WAITKIND_NO_HISTORY.
	(enum exec_direction_kind): New enum.
	(struct target_ops): New methods to_set_execdir, to_get_execdir.
	* target.c (target_get_execdir): New generic method.
	(target_set_execdir): Ditto.
	* remote.c (remote_get_execdir, remote_set_execdir): New methods.
	(remote_vcont_resume): Jump out if attempting reverse execution.
	(remote_resume): Check for reverse exec direction, and send
	appropriate command to target.
	(remote_wait): Check target response for NO_HISTORY status.
	Also check for empty reply (target doesn't understand "bs" or "bc).
	(_initialize_remote): Add new methods to remote target vector.

	* breakpoint.h (breakpoint_silence): Export.
	* breakpoint.c (breakpoint_silence): New function.
	* infcmd.c (finish_command): Check for reverse exec direction.
	(finish_backward): New function, handle finish cmd in reverse.
	* infrun.c (enum inferior_stop_reason): Add NO_HISTORY reason.
	(handle_inferior_event): Handle TARGET_WAITKIND_NO_HISTORY.
	Handle stepping over a function call in reverse.
	Handle stepping thru a line range in reverse.
	Handle setting a step-resume breakpoint in reverse.
	Handle stepping into a function in reverse.
	Handle stepping between line ranges in reverse.
	(print_stop_reason): Print reason for NO_HISTORY.

	2006-03-31  Michael Snyder  <msnyder@@redhat.com>
	User interface for reverse execution.
	* Makefile.in (reverse.c): New file.
	* reverse.c: New file.  User interface for reverse execution.
@
text
@d3130 1
a3130 9
  if (target_get_execution_direction () == EXEC_REVERSE)
    {
      /* We don't pass signals to the target in reverse exec mode.  */
      if (info_verbose && siggnal != TARGET_SIGNAL_0)
	warning (" - Can't pass signal %d to target in reverse: ignored.\n",
		 siggnal);
      strcpy (buf, step ? "bs" : "bc");
    }
  else if (siggnal != TARGET_SIGNAL_0)
d3405 2
a3406 9
	  if (buf[1] == '0' && buf[2] == '6')
	    {
	      status->kind = TARGET_WAITKIND_NO_HISTORY;
	    }
	  else
	    {
	      status->kind = TARGET_WAITKIND_STOPPED;
	      status->value.sig = TARGET_SIGNAL_0;
	    }
a7026 29
/* Reverse execution.
   FIXME: set up as a capability.  */
static enum exec_direction_kind remote_execdir = EXEC_FORWARD;

static enum exec_direction_kind remote_get_execdir (void)
{
  if (remote_debug && info_verbose)
    printf_filtered ("remote execdir is %s\n",
		     remote_execdir == EXEC_FORWARD ? "forward" :
		     remote_execdir == EXEC_REVERSE ? "reverse" :
		     "unknown");
  return remote_execdir;
}

static int remote_set_execdir (enum exec_direction_kind dir)
{
  if (remote_debug && info_verbose)
    printf_filtered ("Set remote execdir: %s\n",
		     dir == EXEC_FORWARD ? "forward" :
		     dir == EXEC_REVERSE ? "reverse" :
		     "bad direction");

  /* FIXME: check target for capability.  */
  if (dir == EXEC_FORWARD || dir == EXEC_REVERSE)
    return (remote_execdir = dir);
  else
    return EXEC_ERROR;
}

a7074 2
  remote_ops.to_get_execdir = remote_get_execdir;
  remote_ops.to_set_execdir = remote_set_execdir;
@


1.295
log
@	Replace 'target async' by 'maintenance set remote-async' and
	'target remote' combination.

	* remote.c (remote_async_wait): Merge into remote_wait, and
	remove.
	(remote_async_permitted, remote_async_permitted_set): New
	variables.
	(set_maintenance_remote_async_permitted)
	(show_maintenance_remote_async_permitted): New functions.
	(remote_async_ops, extended_async_remote_ops): Delete.
	(remote_async_open, extended_remote_async_open): Delete.
	(remote_open_1): Drop async_p parameter.  Update callers.  Replace
	async_p with remote_async_permitted checks.
	(extended_async_remote_attach): Delete.
	(remote_resume, remote_async_resume): Merge and leave remote_resume.
	(remote_async_terminal_inferior): Rename to...
	(remote_terminal_inferior): ... this, and add
	remote_async_termitted check.
	(remote_async_terminal_ours): Rename to...
	(remote_terminal_ours): ... this, and add remote_async_termitted
	check.
	(remote_wait, remote_async_wait): Merge and leave remote_wait
	only.
	(remote_kill, remote_async_kill): Merge and leave remote_kill
	only.
	(remote_async_mourn, extended_async_remote_mourn): Delete.
	(extended_remote_create_inferior_1): Drop async_p parameter.
	Update callers.  Always use extended_remote_ops.
	(extended_remote_async_create_inferior): Delete.
	(remote_return_zero): Delete.
	(init_remote_ops): Register remote_can_async_p, remote_async,
	remote_async_mask, remote_terminal_inferior and
	remote_terminal_ours.
	(remote_can_async_p, remote_is_async_p): Check for
	remote_async_permitted.
	(init_remote_async_ops, init_extended_async_remote_ops): Remove.
	(set_remote_cmd): Don't add async and extended-async targets.
	(_initialize_remote): Add set/show remote-async maintenance
	commands.

	gdb/doc/
	* gdb.texinfo (-target-select): Remove reference to target async.
	(Maintenance Commands): Document "maint set/show remote-async".
@
text
@d3490 1
a3490 1
		    if (*p++ != ':')
d3494 1
d3512 1
a3512 1
		if (*p++ != ';')
d3515 1
@


1.294
log
@	* remote.c (kill_kludge): Delete.
	(remote_wait, remote_async_wait): Don't set it.
	(remote_kill, remote_async_kill): Don't do anything with it.
@
text
@a94 2
static void remote_async_resume (ptid_t ptid, int step,
				 enum target_signal siggnal);
a95 1
static void remote_async_open (char *name, int from_tty);
a97 1
static void extended_remote_async_open (char *name, int from_tty);
d99 1
a99 2
static void remote_open_1 (char *, int, struct target_ops *, int extended_p,
			   int async_p);
a105 1
static void remote_async_mourn (void);
d118 1
a118 3
                                 struct target_waitstatus *status);
static ptid_t remote_async_wait (ptid_t ptid,
                                       struct target_waitstatus *status);
a120 1
static void remote_async_kill (void);
d124 9
d211 27
a506 4
/* Temporary target ops. Just like the remote_ops and
   extended_remote_ops, but with asynchronous support.  */
static struct target_ops remote_async_ops;

a508 2
static struct target_ops extended_async_remote_ops;

d544 2
a545 2
/* Tempoary to track who currently owns the terminal.  See
   target_async_terminal_* for more details.  */
d2285 1
a2285 8
  remote_open_1 (name, from_tty, &remote_ops, 0, 0);
}

/* Just like remote_open, but with asynchronous support.  */
static void
remote_async_open (char *name, int from_tty)
{
  remote_open_1 (name, from_tty, &remote_async_ops, 0, 1);
d2294 1
a2294 10
  remote_open_1 (name, from_tty, &extended_remote_ops, 1 /*extended_p */,
		 0 /* async_p */);
}

/* Just like extended_remote_open, but with asynchronous support.  */
static void
extended_remote_async_open (char *name, int from_tty)
{
  remote_open_1 (name, from_tty, &extended_async_remote_ops,
		 1 /*extended_p */, 1 /* async_p */);
d2608 1
a2608 2
remote_open_1 (char *name, int from_tty, struct target_ops *target,
	       int extended_p, int async_p)
d2617 1
a2617 1
  if (!async_p)
d2709 1
a2709 1
  if (async_p)
d2754 1
a2754 1
	if (async_p)
d2760 1
a2760 1
  if (async_p)
a2911 6
static void
extended_async_remote_attach (char *args, int from_tty)
{
  extended_remote_attach_1 (&extended_async_remote_ops, args, from_tty);
}

d3121 1
a3121 1
    return;
a3140 7
}

/* Same as remote_resume, but with async support.  */
static void
remote_async_resume (ptid_t ptid, int step, enum target_signal siggnal)
{
  remote_resume (ptid, step, siggnal);
d3142 1
d3286 1
a3286 1
remote_async_terminal_inferior (void)
d3288 4
d3316 1
a3316 1
remote_async_terminal_ours (void)
d3318 5
a3322 1
  /* See FIXME in remote_async_terminal_inferior.  */
d3325 1
a3325 1
  /* See FIXME in remote_async_terminal_inferior.  */
a3374 220
	  ofunc = signal (SIGINT, remote_interrupt);
	  /* If the user hit C-c before this packet, or between packets,
	     pretend that it was hit right here.  */
	  if (quit_flag)
	    {
	      quit_flag = 0;
	      remote_interrupt (SIGINT);
	    }
	  getpkt (&rs->buf, &rs->buf_size, 1);
	  signal (SIGINT, ofunc);
	}

      buf = rs->buf;

      remote_stopped_by_watchpoint_p = 0;

      switch (buf[0])
	{
	case 'E':		/* Error of some sort.  */
	  /* We're out of sync with the target now.  Did it continue or not?
	     Not is more likely, so report a stop.  */
	  warning (_("Remote failure reply: %s"), buf);
	  status->kind = TARGET_WAITKIND_STOPPED;
	  status->value.sig = TARGET_SIGNAL_0;
	  goto got_status;
	case 'F':		/* File-I/O request.  */
	  remote_fileio_request (buf);
	  continue;
	case 'T':		/* Status with PC, SP, FP, ...  */
	  {
	    gdb_byte regs[MAX_REGISTER_SIZE];

	    /* Expedited reply, containing Signal, {regno, reg} repeat.  */
	    /*  format is:  'Tssn...:r...;n...:r...;n...:r...;#cc', where
	       ss = signal number
	       n... = register number
	       r... = register contents
	     */
	    p = &buf[3];	/* after Txx */

	    while (*p)
	      {
		char *p1;
		char *p_temp;
		int fieldsize;
		LONGEST pnum = 0;

		/* If the packet contains a register number save it in
		   pnum and set p1 to point to the character following
		   it.  Otherwise p1 points to p.  */

		/* If this packet is an awatch packet, don't parse the
		   'a' as a register number.  */

		if (strncmp (p, "awatch", strlen("awatch")) != 0)
		  {
		    /* Read the ``P'' register number.  */
		    pnum = strtol (p, &p_temp, 16);
		    p1 = p_temp;
		  }
		else
		  p1 = p;

		if (p1 == p)	/* No register number present here.  */
		  {
		    p1 = strchr (p, ':');
		    if (p1 == NULL)
		      error (_("Malformed packet(a) (missing colon): %s\n\
Packet: '%s'\n"),
			     p, buf);
		    if (strncmp (p, "thread", p1 - p) == 0)
		      {
			p_temp = unpack_varlen_hex (++p1, &thread_num);
			record_currthread (thread_num);
			p = p_temp;
		      }
		    else if ((strncmp (p, "watch", p1 - p) == 0)
			     || (strncmp (p, "rwatch", p1 - p) == 0)
			     || (strncmp (p, "awatch", p1 - p) == 0))
		      {
			remote_stopped_by_watchpoint_p = 1;
			p = unpack_varlen_hex (++p1, &addr);
			remote_watch_data_address = (CORE_ADDR)addr;
		      }
		    else if (strncmp (p, "library", p1 - p) == 0)
		      {
			p1++;
			p_temp = p1;
			while (*p_temp && *p_temp != ';')
			  p_temp++;

			solibs_changed = 1;
			p = p_temp;
		      }
		    else
 		      {
 			/* Silently skip unknown optional info.  */
 			p_temp = strchr (p1 + 1, ';');
 			if (p_temp)
			  p = p_temp;
 		      }
		  }
		else
		  {
		    struct packet_reg *reg = packet_reg_from_pnum (rsa, pnum);
		    p = p1;

		    if (*p++ != ':')
		      error (_("Malformed packet(b) (missing colon): %s\n\
Packet: '%s'\n"),
			     p, buf);

		    if (reg == NULL)
		      error (_("Remote sent bad register number %s: %s\n\
Packet: '%s'\n"),
			     phex_nz (pnum, 0), p, buf);

		    fieldsize = hex2bin (p, regs,
					 register_size (current_gdbarch,
							reg->regnum));
		    p += 2 * fieldsize;
		    if (fieldsize < register_size (current_gdbarch,
						   reg->regnum))
		      warning (_("Remote reply is too short: %s"), buf);
		    regcache_raw_supply (get_current_regcache (),
					 reg->regnum, regs);
		  }

		if (*p++ != ';')
		  error (_("Remote register badly formatted: %s\nhere: %s"),
			 buf, p);
	      }
	  }
	  /* fall through */
	case 'S':		/* Old style status, just signal only.  */
	  if (solibs_changed)
	    status->kind = TARGET_WAITKIND_LOADED;
	  else
	    {
	      status->kind = TARGET_WAITKIND_STOPPED;
	      status->value.sig = (enum target_signal)
		(((fromhex (buf[1])) << 4) + (fromhex (buf[2])));
	    }

	  if (buf[3] == 'p')
	    {
	      thread_num = strtol ((const char *) &buf[4], NULL, 16);
	      record_currthread (thread_num);
	    }
	  goto got_status;
	case 'W':		/* Target exited.  */
	  {
	    /* The remote process exited.  */
	    status->kind = TARGET_WAITKIND_EXITED;
	    status->value.integer = (fromhex (buf[1]) << 4) + fromhex (buf[2]);
	    goto got_status;
	  }
	case 'X':
	  status->kind = TARGET_WAITKIND_SIGNALLED;
	  status->value.sig = (enum target_signal)
	    (((fromhex (buf[1])) << 4) + (fromhex (buf[2])));

	  goto got_status;
	case 'O':		/* Console output.  */
	  remote_console_output (buf + 1);
	  continue;
	case '\0':
	  if (last_sent_signal != TARGET_SIGNAL_0)
	    {
	      /* Zero length reply means that we tried 'S' or 'C' and
	         the remote system doesn't support it.  */
	      target_terminal_ours_for_output ();
	      printf_filtered
		("Can't send signals to this remote system.  %s not sent.\n",
		 target_signal_to_name (last_sent_signal));
	      last_sent_signal = TARGET_SIGNAL_0;
	      target_terminal_inferior ();

	      strcpy ((char *) buf, last_sent_step ? "s" : "c");
	      putpkt ((char *) buf);
	      continue;
	    }
	  /* else fallthrough */
	default:
	  warning (_("Invalid remote reply: %s"), buf);
	  continue;
	}
    }
got_status:
  if (thread_num != -1)
    {
      return pid_to_ptid (thread_num);
    }
  return inferior_ptid;
}

/* Async version of remote_wait.  */
static ptid_t
remote_async_wait (ptid_t ptid, struct target_waitstatus *status)
{
  struct remote_state *rs = get_remote_state ();
  struct remote_arch_state *rsa = get_remote_arch_state ();
  ULONGEST thread_num = -1;
  ULONGEST addr;
  int solibs_changed = 0;

  status->kind = TARGET_WAITKIND_EXITED;
  status->value.integer = 0;

  remote_stopped_by_watchpoint_p = 0;

  while (1)
    {
      char *buf, *p;

      if (rs->cached_wait_status)
	/* Use the cached wait status, but only once.  */
	rs->cached_wait_status = 0;
      else
	{
d3397 2
d3428 1
a3428 1
		long pnum = 0;
d3434 2
a3435 2
		/* If this packet is an awatch packet, don't parse the 'a'
		   as a register number.  */
d3439 1
a3439 1
		    /* Read the register number.  */
a3484 1

d3489 1
d3496 1
a3496 1
		      error (_("Remote sent bad register number %ld: %s\n\
d3498 1
a3498 1
			     pnum, p, buf);
d3548 9
a3556 4
	  /* Return immediately to the event loop. The event loop will
             still be waiting on the inferior afterwards.  */
          status->kind = TARGET_WAITKIND_IGNORE;
          goto got_status;
a5065 13
  /* Use catch_errors so the user can quit from gdb even when we aren't on
     speaking terms with the remote system.  */
  catch_errors ((catch_errors_ftype *) putpkt, "k", "", RETURN_MASK_ERROR);

  /* Don't wait for it to die.  I'm not really sure it matters whether
     we do or not.  For the existing stubs, kill is a noop.  */
  target_mourn_inferior ();
}

/* Async version of remote_kill.  */
static void
remote_async_kill (void)
{
a5084 6
static void
remote_async_mourn (void)
{
  remote_mourn_1 (&remote_async_ops);
}

a5129 6
static void
extended_async_remote_mourn (void)
{
  extended_remote_mourn_1 (&extended_async_remote_ops);
}

d5199 1
a5199 2
				   char **env, int from_tty,
				   int async_p)
d5203 1
a5203 1
  if (async_p && target_can_async_p ())
d5229 1
a5229 4
  if (async_p)
    target_mark_running (&extended_async_remote_ops);
  else
    target_mark_running (&extended_remote_ops);
d5239 1
a5239 8
  extended_remote_create_inferior_1 (exec_file, args, env, from_tty, 0);
}

static void
extended_remote_async_create_inferior (char *exec_file, char *args,
				       char **env, int from_tty)
{
  extended_remote_create_inferior_1 (exec_file, args, env, from_tty, 1);
a7024 6
static int
remote_return_zero (void)
{
  return 0;
}

d7079 6
a7084 2
  remote_ops.to_can_async_p = remote_return_zero;
  remote_ops.to_is_async_p = remote_return_zero;
d7111 4
d7122 4
a7172 89
/* Target async and target extended-async.

   This are temporary targets, until it is all tested.  Eventually
   async support will be incorporated int the usual 'remote'
   target.  */

static void
init_remote_async_ops (void)
{
  remote_async_ops.to_shortname = "async";
  remote_async_ops.to_longname =
    "Remote serial target in async version of the gdb-specific protocol";
  remote_async_ops.to_doc =
    "Use a remote computer via a serial line, using a gdb-specific protocol.\n\
Specify the serial device it is connected to (e.g. /dev/ttya).";
  remote_async_ops.to_open = remote_async_open;
  remote_async_ops.to_close = remote_close;
  remote_async_ops.to_detach = remote_detach;
  remote_async_ops.to_disconnect = remote_disconnect;
  remote_async_ops.to_resume = remote_async_resume;
  remote_async_ops.to_wait = remote_async_wait;
  remote_async_ops.to_fetch_registers = remote_fetch_registers;
  remote_async_ops.to_store_registers = remote_store_registers;
  remote_async_ops.to_prepare_to_store = remote_prepare_to_store;
  remote_async_ops.deprecated_xfer_memory = remote_xfer_memory;
  remote_async_ops.to_files_info = remote_files_info;
  remote_async_ops.to_insert_breakpoint = remote_insert_breakpoint;
  remote_async_ops.to_remove_breakpoint = remote_remove_breakpoint;
  remote_async_ops.to_can_use_hw_breakpoint = remote_check_watch_resources;
  remote_async_ops.to_insert_hw_breakpoint = remote_insert_hw_breakpoint;
  remote_async_ops.to_remove_hw_breakpoint = remote_remove_hw_breakpoint;
  remote_async_ops.to_insert_watchpoint = remote_insert_watchpoint;
  remote_async_ops.to_remove_watchpoint = remote_remove_watchpoint;
  remote_async_ops.to_stopped_by_watchpoint = remote_stopped_by_watchpoint;
  remote_async_ops.to_stopped_data_address = remote_stopped_data_address;
  remote_async_ops.to_terminal_inferior = remote_async_terminal_inferior;
  remote_async_ops.to_terminal_ours = remote_async_terminal_ours;
  remote_async_ops.to_kill = remote_async_kill;
  remote_async_ops.to_load = generic_load;
  remote_async_ops.to_mourn_inferior = remote_async_mourn;
  remote_async_ops.to_thread_alive = remote_thread_alive;
  remote_async_ops.to_find_new_threads = remote_threads_info;
  remote_async_ops.to_pid_to_str = remote_pid_to_str;
  remote_async_ops.to_extra_thread_info = remote_threads_extra_info;
  remote_async_ops.to_stop = remote_stop;
  remote_async_ops.to_xfer_partial = remote_xfer_partial;
  remote_async_ops.to_rcmd = remote_rcmd;
  remote_async_ops.to_get_thread_local_address 
    = remote_get_thread_local_address;
  remote_async_ops.to_stratum = process_stratum;
  remote_async_ops.to_has_all_memory = 1;
  remote_async_ops.to_has_memory = 1;
  remote_async_ops.to_has_stack = 1;
  remote_async_ops.to_has_registers = 1;
  remote_async_ops.to_has_execution = 1;
  remote_async_ops.to_has_thread_control = tc_schedlock;	/* can lock scheduler */
  remote_async_ops.to_can_async_p = remote_can_async_p;
  remote_async_ops.to_is_async_p = remote_is_async_p;
  remote_async_ops.to_async = remote_async;
  remote_async_ops.to_async_mask = remote_async_mask;
  remote_async_ops.to_magic = OPS_MAGIC;
  remote_async_ops.to_memory_map = remote_memory_map;
  remote_async_ops.to_flash_erase = remote_flash_erase;
  remote_async_ops.to_flash_done = remote_flash_done;
  remote_async_ops.to_read_description = remote_read_description;
  remote_async_ops.to_search_memory = remote_search_memory;
}

/* Set up the async extended remote vector by making a copy of the standard
   remote vector and adding to it.  */

static void
init_extended_async_remote_ops (void)
{
  extended_async_remote_ops = remote_async_ops;

  extended_async_remote_ops.to_shortname = "extended-async";
  extended_async_remote_ops.to_longname =
    "Extended remote serial target in async gdb-specific protocol";
  extended_async_remote_ops.to_doc =
    "Use a remote computer via a serial line, using an async gdb-specific protocol.\n\
Specify the serial device it is connected to (e.g. /dev/ttya).",
    extended_async_remote_ops.to_open = extended_remote_async_open;
  extended_async_remote_ops.to_create_inferior = extended_remote_async_create_inferior;
  extended_async_remote_ops.to_mourn_inferior = extended_async_remote_mourn;
  extended_async_remote_ops.to_detach = extended_remote_detach;
  extended_async_remote_ops.to_attach = extended_async_remote_attach;
}

a7246 6
  init_remote_async_ops ();
  add_target (&remote_async_ops);

  init_extended_async_remote_ops ();
  add_target (&extended_async_remote_ops);

d7473 11
@


1.293
log
@	* remote.c (get_offsets): Handle a single segment.
	* symfile.c (symfile_map_offsets_to_segments): Allow more bases
	than segments.
@
text
@a3332 4
/* If nonzero, ignore the next kill.  */

int kill_kludge;

a3535 1
	  kill_kludge = 1;
a3761 1
	  kill_kludge = 1;
a5278 9
  /* For some mysterious reason, wait_for_inferior calls kill instead of
     mourn after it gets TARGET_WAITKIND_SIGNALLED.  Work around it.  */
  if (kill_kludge)
    {
      kill_kludge = 0;
      target_mourn_inferior ();
      return;
    }

a5295 9
  /* For some mysterious reason, wait_for_inferior calls kill instead of
     mourn after it gets TARGET_WAITKIND_SIGNALLED.  Work around it.  */
  if (kill_kludge)
    {
      kill_kludge = 0;
      target_mourn_inferior ();
      return;
    }

@


1.292
log
@	* remote.c (init_extended_remote_ops): Fix typo.
@
text
@d2137 10
@


1.291
log
@	* remote.c (remote_search_memory): Fix capilization in error messages.
@
text
@d7365 2
a7366 2
Specify the serial device it is connected to (e.g. /dev/ttya).",
    extended_remote_ops.to_open = extended_remote_open;
@


1.290
log
@	New "find" command.
	* NEWS: Document find command and qSearch:memory packet.
	* Makefile.in (SFILES): Add findcmd.c.
	(COMMON_OBJS): Add findcmd.o.
	(findcmd.o): New rule.
	* findcmd.c: New file.
	* target.h (target_ops): New member to_search_memory.
	(simple_search_memory): Declare.
	(target_search_memory): Declare.
	* target.c (simple_search_memory): New fn.
	(target_search_memory): New fn.
	* remote.c (PACKET_qSearch_memory): New packet kind.
	(remote_search_memory): New fn.
	(init_remote_ops): Init to_search_memory.
	(init_extended_remote_ops): Ditto.
	(_initialize_remote): Add qSearch:memory packet config command.

	* gdbserver/server.h (decode_search_memory_packet): Declare.
	* gdbserver/remote-utils.c (decode_search_memory_packet): New fn.
	* gdbserver/server.c (handle_search_memory_1): New fn.
	(handle_search_memory): New fn.
	(handle_query): Process qSearch:memory packets.

	* doc/gdb.texinfo: Document "find" command, qSearch:memory packet.

	* testsuite/gdb.base/find.exp: New file.
	* testsuite/gdb.base/find.c: New file.
@
text
@d6254 1
a6254 1
    error ("pattern is too large to transmit to remote target");
d6276 1
a6276 1
	error (_("unknown qSearch:memory reply: %s"), rs->buf);
d6281 1
a6281 1
    error (_("unknown qSearch:memory reply: %s"), rs->buf);
@


1.289
log
@	* remote.c (extended_remote_attach_1): Call target_find_description.
@
text
@d938 1
d6199 87
d7347 1
d7495 1
d7762 3
@


1.288
log
@	* remote.c (extended_remote_create_inferior_1): Clean up
	before marking the target running.
@
text
@d2843 1
d2867 3
a2869 2
      /* We have a wait response; reuse it.  */
      rs->cached_wait_status = 1;
d2880 9
@


1.287
log
@	* remote.c (remote_insert_breakpoint): Call get_remote_state
	after gdbarch_breakpoint_from_pc is called.
	(remote_insert_hw_breakpoint): Likewise.
@
text
@d5461 6
a5476 4

  /* Clean up from the last time we were running.  */
  init_thread_list ();
  init_wait_for_inferior ();
@


1.286
log
@gdb/
	* target.h (struct target_ops): Delete to_async_mask_value and add
	to_async_mask.
	(target_is_async_p, target_async): Formatting.
	(target_async_mask_value): Delete.
	(target_async_mask): Delete function declaration, and add new
	target macro with the same name.

	* target.c (update_current_target): Replace to_async_mask_value by
	to_async_mask.  Default to_async_mask to return_one.
	(target_async_mask): Delete.
	(find_default_can_async_p, find_default_is_async_p): New.
	(init_dummy_target): register find_default_can_async_p and
	find_default_is_async_p on the dummy target.

	* linux-nat.c: Include inf-loop.h, event-loop.h and event-top.h.
	(debug_linux_nat_async): New global.
	(show_debug_linux_nat_async): New function.
	(linux_nat_async_enabled, linux_nat_async_mask_value)
	(linux_nat_event_pipe, linux_nat_num_queued_events)
	(linux_nat_async_events_enabled): New globals.
	(struct waitpid_result): New struct.
	(waitpid_queue): New global.
	(queued_waitpid, push_waitpid, drain_queued_events): New.
	(my_waitpid): Call queued_waitpid.
	(linux_child_follow_fork): Disable async events during the call.
	(blocked_mask): Delete.
	(sync_sigchld_action, async_sigchld_action): New globals.
	(lin_lwp_attach_lwp): In sync mode, don't reblock SIGCHLD.  In
	async mode, block events during the call.
	(linux_nat_create_inferior): New.
	(linux_nat_attach): In sync mode, restore the mask states.  In
	async mode, wake the event loop immediatelly.
	(detach_callback): Drain all queued events of the lwp we're
	detaching from.
	(linux_nat_detach): Block async mode, and drain events of the main
	process.
	(linux_nat_resume): If in async mode, mask async events during the
	call.  If short circuiting, force event loop to wake up.  If
	resuming, set target_executing, and register target events in the
	event loop.
	(pipe_to_local_event_queue, local_event_queue_to_pipe): New.
	(linux_nat_wait): In async mode, block events during the call.
	Only enable/disable passing SIGINT to the inferior in sync mode.
	Get events from local waitpid queue.  If no interesting events was
	found, return to events loop.  Reregister target events in the
	event loop on exit.  In sync mode, no need to reblock SIGCHLD.
	(linux_nat_kill): Disable events on entry.
	(linux_nat_mourn_inferior): In sync mode, don't restore the masks
	here.  Detach async mode from the event loop if there are no more
	forks available, otherwise leave it on.
	(sigchld_handler): Assure this is called only in sync mode.
	(linux_async_permitted, linux_async_permitted_1): New globals.
	(set_maintenance_linux_async_permitted)
	(show_maintenance_linux_async_permitted): New functions.
	(linux_nat_is_async_p, linux_nat_can_async_p)
	(linux_nat_async_mask): New.
	(linux_nat_event_pipe_pop, linux_nat_event_pipe_push): New.
	(get_pending_events, async_sigchld_handler): New.
	(linux_nat_async_events): New.
	(async_terminal_is_ours): New global.
	(linux_nat_terminal_inferior, linux_nat_terminal_ours): New.
	(async_client_callback, async_client_context): New.
	(linux_nat_async_file_handler, linux_nat_async)
	(linux_nat_disable_async, linux_nat_enable_async): New.
	(linux_nat_add_target): Register linux_nat_create_inferior,
	linux_nat_can_async_p, linux_nat_is_async_p, linux_nat_async,
	linux_nat_async_mask, linux_nat_terminal_inferior and
	linux_nat_terminal_ours.
	(_initialize_linux_nat): Remove local action variable, and update
	code that used it to use sync_sigchld_action.  Add new
	"lin-lwp-async" debug set/show command.  Put the "lin-lwp" debug
	set/show command in the maintenance class.  Add new "linux-async"
	maintenance set/show command.  Block SIGCHLD by default.  Setup
	async_sichld_action, and sync_sigchld_action.  Install the default
	async mode.
	(lin_thread_get_thread_signals): Use a local sigset_t for blocking
	the cancel signals.

	* linux-thread-db.c (re_check_for_thread_db): New.
	(clear_lwpid_callback): Handle TARGET_WAITKIND_IGNORE.
	(thread_db_can_async_p, thread_db_is_async_p, thread_db_async)
	(thread_db_async_mask): New.
	(init_thread_db_ops): Register thread_db_can_async_p,
	thread_db_is_async_p, thread_db_async and thread_db_async_mask.

	* remote.c (remote_async_mask_value): New.
	(remote_return_zero): New.
	(init_remote_ops): Register remote_return_zero as callbacks of
	to_can_async_p and to_is_async_p.
	(remote_can_async_p, remote_is_async_p, remote_async): Update to
	use remote_async_mask_value.
	(remote_async_mask): New.
	(init_remote_async_ops): Remove to_async_mask_value setting and
	register remote_async_mask as to_async_mask callback in
	remote_async_ops.

	* Makefile.in (linux-nat.o): Update.

gdb/doc/
	* gdb.texinfo (Debugging Output): Document
	"set/show debug lin-lwp-async".
	(Maintenance Commands): Document "maint set/show linux-async".
@
text
@a5498 3
  CORE_ADDR addr = bp_tgt->placed_address;
  struct remote_state *rs = get_remote_state ();

d5506 9
a5514 1
      char *p = rs->buf;
a5518 2
      gdbarch_breakpoint_from_pc
	(current_gdbarch, &bp_tgt->placed_address, &bp_tgt->placed_size);
d5704 2
a5705 2
  struct remote_state *rs = get_remote_state ();
  char *p = rs->buf;
d5716 3
@


1.285
log
@	Async mode fixes.
        * Makefile.in (infcmd.o, inf-loop.o): Update dependencies.
        * breakpoint.c (bpstat_do_actions): In async mode,
        don't jump to top expecting stop_bpstat to be already
        updated.
        * event-loop.c (start_event_loop): Call async_enable_stdin
        on exception.
        * event-top.c (async_enable_stdin): Do nothing if sync_execution
        is not set.
        (command_handler): Do not setup continuation here.
        (command_line_handler_continuation): Move to...
        * top.c (command_line_handler_continuation): ... here.
        (execute_command): In async mode, register continuation.
        Don't check frame's language in running in async mode.
        * exceptions.c (throw_exception): Don't do exec_error_cleanups.
        * inf-loop.c (complete_execution): Inline into...
        (inferior_event_handler): ... here.  Clear target_executing before
        doing any cleanups.  Don't try to show prompt if the target was
        resumed.
        * infcmd.c (signal_command): Add support for async mode.
        (finish_command): Only add continuation if the target was
        successfully resumed.
        * remote.c (init_async_opts): Register to_get_thread_local_address
        handler.
        * mi/mi-interp.c (mi_cmd_interpreter_exec): Don't mess
        with sync_execution.
        * tui/tui-interp.c (tui_command_loop): Call async_enable_stdin
        on exception.
@
text
@d484 2
d7181 6
d7240 2
d7269 1
a7269 1
  return (current_target.to_async_mask_value) && serial_can_async_p (remote_desc);
d7276 1
a7276 1
  return (current_target.to_async_mask_value) && serial_is_async_p (remote_desc);
d7300 1
a7300 1
  if (current_target.to_async_mask_value == 0)
d7314 8
d7381 1
a7381 1
  remote_async_ops.to_async_mask_value = 1;
@


1.284
log
@	Remove unused remote.c hooks.
        * remote.c (deprecated_target_resume_hook)
        (deprecated_target_wait_loop_hook): Remove.
        (remote_resume): Do not call deprecated_target_resume_hook.
        (remote_wait): Do not call deprecated_target_wait_loop_hook.
        (remote_async_wait): Likewise.
@
text
@d7351 2
@


1.283
log
@        * remote.c (extended_remote_attach_1): Make local variable pid an int
        instead of a pid_t.
@
text
@a1039 5
/* These are pointers to hook functions that may be set in order to
   modify resume/wait behavior for a particular architecture.  */

void (*deprecated_target_resume_hook) (void);
void (*deprecated_target_wait_loop_hook) (void);
a3093 5
  /* A hook for when we need to do something at the last moment before
     resumption.  */
  if (deprecated_target_resume_hook)
    (*deprecated_target_resume_hook) ();

a3368 5
      /* This is a hook for when we need to do something (perhaps the
         collection of trace data) every time the target stops.  */
      if (deprecated_target_wait_loop_hook)
	(*deprecated_target_wait_loop_hook) ();

a3597 5
      /* This is a hook for when we need to do something (perhaps the
         collection of trace data) every time the target stops.  */
      if (deprecated_target_wait_loop_hook)
	(*deprecated_target_wait_loop_hook) ();

@


1.282
log
@	* Makefile.in (mingw-hdep.o, posix-hdep.o, remote-fileio.o): Update.
	* event-loop.c (call_async_signal_handler): New.
	* event-loop.h (call_async_signal_handler)
	(gdb_call_async_signal_handler): Declare.
	(mark_async_signal_handler): Add comments.
	* event-top.c (handle_sigint): Use gdb_call_async_signal_handler.
	* mingw-hdep.c (sigint_event, sigint_handler): New.
	(gdb_select): Use them.  Wait for the readline signal handler
	to finish.
	(gdb_call_async_signal_handler, _initialize_mingw_hdep): New functions.
	* posix-hdep.c (gdb_call_async_signal_handler): New function.
	* remote-fileio.c (sigint_fileio_token, async_remote_fileio_interrupt):
	New.
	(remote_fileio_ctrl_c_signal_handler): Use
	gdb_call_async_signal_handler.
	(initialize_remote_fileio): Initialize sigint_fileio_token.
	* remote.c (initialize_sigint_signal_handler, handle_remote_sigint): Do
	not initialize tokens here.
	(handle_remote_sigint_twice): Likewise.  Reinstall
	handle_remote_sigint.
	(async_remote_interrupt_twice): Just call interrupt_query.
	(cleanup_sigint_signal_handler): Do not delete tokens.
	(remote_interrupt, remote_interrupt_twice): Use
	gdb_call_async_signal_handler.
	(interrupt_query): Reinstall the default signal handler.
	(_initialize_remote): Initialize tokens here.
@
text
@d2844 1
a2844 1
  pid_t pid;
@


1.281
log
@	* remote.c (remote_wait, remote_async_wait): Stop if we receive
	an error.
@
text
@a3160 2
  sigint_remote_token =
    create_async_signal_handler (async_remote_interrupt, NULL);
a3168 2
  sigint_remote_twice_token =
    create_async_signal_handler (async_remote_interrupt_twice, NULL);
d3178 1
a3178 3
  signal (sig, handle_sigint);
  sigint_remote_twice_token =
    create_async_signal_handler (inferior_event_handler_wrapper, NULL);
d3200 2
a3201 7
  /* Do something only if the target was not killed by the previous
     cntl-C.  */
  if (target_executing)
    {
      interrupt_query ();
      signal (SIGINT, handle_remote_sigint);
    }
a3209 4
  if (sigint_remote_twice_token)
    delete_async_signal_handler (&sigint_remote_twice_token);
  if (sigint_remote_token)
    delete_async_signal_handler (&sigint_remote_token);
d3227 1
a3227 4
  if (remote_debug)
    fprintf_unfiltered (gdb_stdlog, "remote_interrupt called\n");

  target_stop ();
d3236 1
a3236 1
  interrupt_query ();
d3267 1
d7493 6
@


1.280
log
@       * remote.c (remote_get_threadlist): If the response
       is empty, don't try to parse it.
@
text
@d3406 2
d3409 3
a3411 1
	  continue;
d3638 2
d3641 3
a3643 1
	  continue;
@


1.280.6.1
log
@Check in ARCompact simulator.  A valid configuration is arc-elf.
This is not quite finished and has most likely a few files that are
obsolete & not used, but it's good enough to run gcc regression tests.
@
text
@a2763 1
  observer_notify_inferior_created (&current_target, from_tty);
@


1.279
log
@	* remote.c (extended_remote_attach_1): Set attach_flag.
	(extended_remote_create_inferior_1): Clear attach_flag.
@
text
@d1743 6
a1748 3
  *result_count =
    parse_threadlist_response (rs->buf + 2, result_limit, &echo_nextthread,
			       threadlist, done);
@


1.278
log
@	* linux-low.c (linux_attach_lwp): Do not _exit after errors.
	(linux_kill, linux_detach): Clean up the process list.
	* remote-utils.c (remote_open): Improve port number parsing.
	(putpkt_binary, input_interrupt): Only send interrupts if the target
	is running.
	* server.c (extended_protocol): Make static.
	(attached): Define earlier.
	(exit_requested, response_needed, program_argv): New variables.
	(target_running): New.
	(start_inferior): Clear attached here.
	(attach_inferior): Set attached here.
	(require_running): Define.
	(handle_query): Use require_running and target_running.  Implement
	"monitor exit".
	(handle_v_attach, handle_v_run): New.
	(handle_v_requests): Use require_running.  Handle vAttach and vRun.
	(gdbserver_usage): Update.
	(main): Redo argument parsing.  Handle --debug and --multi.  Handle
	--attach along with other options or after the port.  Save
	program_argv.  Support no initial program.  Resynchronize
	communication with GDB after an error.  Handle "monitor exit".
	Use require_running and target_running.  Always allow the extended
	protocol.  Do not error out for Hc0 or Hc-1.  Do not automatically
	restart in extended mode.
	* README: Refer to the GDB manual.  Update --attach usage.

	* remote.c (struct remote_state): Add cached_wait_status.
	(remote_exec_file): New variable.
	(PACKET_vAttach, PACKET_vRun): New constants.
	(extended_remote_restart): Do not query for status.
	(struct start_remote_args): New.
	(remote_start_remote): Take it as a second argument.  Check
	whether the target is running.  Issue an error for non-running
	non-extended targets.  Cache the wait status.  Set inferior_ptid
	here.
	(remote_open_1): Prompt to disconnect non-running targets.  Make
	sure the target is marked running.  Do not set inferior_ptid here.
	Update call to remote_start_remote.  Do not call remote_check_symbols
	if the target is not running.
	(remote_detach_1): Rename from remote_detach.  Take an EXTENDED
	argument.  Handle a non-running target.
	(remote_detach): Use it.
	(extended_remote_detach): New.
	(remote_disconnect): Fix typo.  Use remoute_mourn_1.
	(extended_remote_attach_1, extended_remote_attach)
	(extended_async_remote_attach): New.
	(remote_vcont_resume): Remove unused variable.
	(remote_wait, remote_async_wait): Use any cached wait status.
	(putpkt_binary, getpkt): Clear any cached wait status.
	(extended_remoute_mourn_1): New.
	(extended_remote_mourn): Use it.
	(extended_async_remote_mourn, extended_remote_run): New.
	(extended_remote_create_inferior_1): New.
	(extended_remote_create_inferior): Use it.
	(extended_remote_async_create_inferior): Likewise.
	(remote_xfer_partial): Skip for non-executing targets.
	(init_extended_remote_ops): Set to_detach and to_attach.
	(init_extended_async_remote_ops): Likewise.  Use
	extended_async_remote_mourn.
	(_initialize_remote): Register vAttach, vRun, and
	set remote exec-file.
	* NEWS: Mention vAttach, vRun, and gdbserver extended-remote support.

	* gdb.server/ext-attach.c, gdb.server/ext-attach.exp,
	gdb.server/ext-run.exp: New files.
	* lib/gdbserver-support.exp (gdbserver_download): New.
	(gdbserver_start): New.  Update gdbserver expected
	output.
	(gdbserver_spawn): Use them.
	(gdbserver_start_extended): New.

	* gdb.texinfo (Using the `gdbserver' Program): Add security
	warning.  Rearrange into subsections and subsubsections.  Document
	--multi and --debug.  Correct --with-sysroot typo.  Update --attach
	usage.  Make load reference clearer.  Document monitor exit.
	(Remote Configuration): Document set remote exec-file, attach-packet,
	and run-packet.
	(Packets): Document vAttach and vRun.
@
text
@d2877 1
d5486 1
@


1.277
log
@	* remote.c (remote_wait): Handle SIGINT between packets.
	(remote_async_wait): Likewise.
@
text
@d240 9
d526 4
d936 2
a2010 5

  /* Now query for status so this looks just like we restarted
     gdbserver from scratch.  */
  putpkt ("?");
  getpkt (&rs->buf, &rs->buf_size, 0);
d2172 11
d2184 1
a2184 1
remote_start_remote (struct ui_out *uiout, void *from_tty_p)
d2186 3
a2188 1
  int from_tty = * (int *) from_tty_p;
d2195 26
d2224 10
d2238 5
a2242 1
  putpkt ("?");			/* Initiate a query from remote machine.  */
d2244 1
a2244 2

  start_remote (from_tty);	/* Initialize gdb process mechanisms.  */
d2605 13
d2622 8
d2670 3
a2693 9
  /* Without this, some commands which require an active target (such
     as kill) won't work.  This variable serves (at least) double duty
     as both the pid of the target process (if it has such), and as a
     flag indicating that a target is active.  These functions should
     be split out into seperate variables, especially since GDB will
     someday have a notion of debugging several processes.  */

  inferior_ptid = pid_to_ptid (MAGIC_NULL_PID);

d2728 8
a2735 3
    struct gdb_exception ex
      = catch_exception (uiout, remote_start_remote, &from_tty,
			 RETURN_MASK_ALL);
d2755 6
a2760 2
  if (exec_bfd) 	/* No use without an exec file.  */
    remote_check_symbols (symfile_objfile);
d2769 1
a2769 1
remote_detach (char *args, int from_tty)
d2776 3
d2793 18
a2810 1
    puts_filtered ("Ending remote debugging.\n");
d2819 1
a2819 1
    error (_("Argument given to \"detach\" when remotely debugging."));
d2825 5
a2829 1
  target_mourn_inferior ();
d2834 57
d3015 1
a3015 1
  char *buf = NULL, *outbuf;
d3373 4
a3376 4
      ofunc = signal (SIGINT, remote_interrupt);
      /* If the user hit C-c before this packet, or between packets,
	 pretend that it was hit right here.  */
      if (quit_flag)
d3378 10
a3387 2
	  quit_flag = 0;
	  remote_interrupt (SIGINT);
a3388 2
      getpkt (&rs->buf, &rs->buf_size, 1);
      signal (SIGINT, ofunc);
d3595 4
a3598 1
      if (!target_is_async_p ())
d3600 1
a3600 4
	  ofunc = signal (SIGINT, remote_interrupt);
	  /* If the user hit C-c before this packet, or between packets,
	     pretend that it was hit right here.  */
	  if (quit_flag)
d3602 8
a3609 2
	      quit_flag = 0;
	      remote_interrupt (SIGINT);
d3611 7
a3618 7
      /* FIXME: cagney/1999-09-27: If we're in async mode we should
         _never_ wait for ever -> test on target_is_async_p().
         However, before we do that we need to ensure that the caller
         knows how to take the target into/out of async mode.  */
      getpkt (&rs->buf, &rs->buf_size, wait_forever_enabled_p);
      if (!target_is_async_p ())
	signal (SIGINT, ofunc);
d4887 1
d4896 4
d5201 1
d5207 4
d5342 1
d5344 1
a5344 1
extended_remote_mourn (void)
d5346 2
a5347 8
  /* We do _not_ want to mourn the target like this; this will
     remove the extended remote target  from the target stack,
     and the next time the user says "run" it'll fail.

     FIXME: What is the right thing to do here?  */
#if 0
  remote_mourn_1 (&extended_remote_ops);
#endif
a5349 1
/* Worker function for remote_mourn.  */
d5351 1
a5351 1
remote_mourn_1 (struct target_ops *target)
d5353 6
a5358 1
  unpush_target (target);
d5360 19
d5381 5
a5385 3
/* In the extended protocol we want to be able to do things like
   "run" and have them basically work as expected.  So we need
   a special create_inferior function.
d5387 5
a5391 2
   FIXME: One day add support for changing the exec file
   we're debugging, arguments and an environment.  */
d5393 2
a5394 3
static void
extended_remote_create_inferior (char *exec_file, char *args,
				 char **env, int from_tty)
d5396 11
a5406 3
  /* Rip out the breakpoints; we'll reinsert them after restarting
     the remote server.  */
  remove_breakpoints ();
d5408 23
a5430 2
  /* Now restart the remote server.  */
  extended_remote_restart ();
d5432 2
a5433 11
  /* NOTE: We don't need to recheck for a target description here; but
     if we gain the ability to switch the remote executable we may
     need to, if for instance we are running a process which requested
     different emulated hardware from the operating system.  A
     concrete example of this is ARM GNU/Linux, where some binaries
     will have a legacy FPA coprocessor emulated and others may have
     access to a hardware VFP unit.  */

  /* Now put the breakpoints back in.  This way we're safe if the
     restart function works via a unix fork on the remote side.  */
  insert_breakpoints ();
d5435 17
a5451 2
  /* Clean up from the last time we were running.  */
  clear_proceed_status ();
d5454 6
a5459 1
/* Async version of extended_remote_create_inferior.  */
d5461 3
a5463 2
extended_remote_async_create_inferior (char *exec_file, char *args,
				       char **env, int from_tty)
a5464 4
  /* Rip out the breakpoints; we'll reinsert them after restarting
     the remote server.  */
  remove_breakpoints ();

d5467 1
a5467 1
  if (target_can_async_p ())
d5471 12
a5482 1
  extended_remote_restart ();
d5484 9
a5492 11
  /* NOTE: We don't need to recheck for a target description here; but
     if we gain the ability to switch the remote executable we may
     need to, if for instance we are running a process which requested
     different emulated hardware from the operating system.  A
     concrete example of this is ARM GNU/Linux, where some binaries
     will have a legacy FPA coprocessor emulated and others may have
     access to a hardware VFP unit.  */

  /* Now put the breakpoints back in.  This way we're safe if the
     restart function works via a unix fork on the remote side.  */
  insert_breakpoints ();
d5495 16
a5510 1
  clear_proceed_status ();
d6068 6
d7275 2
d7409 3
a7411 1
  extended_async_remote_ops.to_mourn_inferior = extended_remote_mourn;
d7666 6
d7704 7
@


1.276
log
@        Inform about new thread in a single place.

        * thread.c (add_thread_silent): Renamed
        from add_thread.
        (print_thread_events): New variable definition.
        (show_print_thread_events): New function.
        (_initialize_thread): Add "set print thread-events" and
        "show print thread-events" commands.
        (add_thread): Announce new thread.
        * gdbthread.h (add_thread_silent): Declare.
        (print_thread_events): New variable declaration.
        * inf-ttrace.c (inf_ttrace_wait): Don't
        inform about new thread, as add_thread is always
        called too, and will take care of that.
        * infrun.c (handle_inferior_event): Likewise.
        * procfs.c (procfs_wait): Likewise.
        * remote.c (remote_currthread): Likewise.
        * sol-thread.c (sol_thread_wait): Likewise.
        * win32-nat.c (get_win32_debug_event): Likewise.
        * linux-thread-db.c (attach_thread): Likewise.
        Remove the verbose parameter.
        (check_event): Make detach_thread be verbose
        only if print_thread_events is set.
        * linux-nat.c (lin_lwp_attach_lwp): Don't inform
        about new thread.  This is called only from
        linux-thread-db.c:attach_thread, which will take care.
        Remove the verbose parameter.
        * linux-nat.h (lin_lwp_attach_lwp): Adjust prototype.
@
text
@d3207 7
d3423 10
a3432 1
	ofunc = signal (SIGINT, remote_interrupt);
@


1.275
log
@	Updated copyright notices for most files.
@
text
@d1052 1
a1052 6
    {
      add_thread (pid_to_ptid (currthread));
      ui_out_text (uiout, "[New ");
      ui_out_text (uiout, target_pid_to_str (pid_to_ptid (currthread)));
      ui_out_text (uiout, "]\n");
    }
@


1.274
log
@	* remote.c (unpack_nibble): Use fromhex.
	* symtab.c (find_line_common): Always set exact_match.
@
text
@d4 1
a4 1
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
@


1.273
log
@* target.c (update_current_target): Inherit to_log_command.
* target.h (struct target_ops). Add to_log_command.
(target_log_command): New macro.
* top.c (execute_command): Call target_log_command() rather than
serial_log_command().
* monitor.c (init_base_monitor_ops): Initialize to_log_command.
* remote-m32r-sdi.c (init_m32r_ops): Likewise.
* remote-mips.c (_initialize_remote_mips): Likewise.
* remote.c (init_remote_ops): Likewise.
@
text
@d1356 1
a1356 1
  ishex (*buf++, val);
@


1.272
log
@	* remote.c (remote_cmdlist): New variable.
	(PACKET_vFile_open, PACKET_vFile_pread, PACKET_vFile_pwrite)
	(PACKET_vFile_close, PACKET_vFile_unlink): New constants.
	(remote_buffer_add_string, remote_buffer_add_bytes)
	(remote_buffer_add_int, remote_hostio_parse_result)
	(remote_hostio_send_command, remote_hostio_open, remote_hostio_pwrite)
	(remote_hostio_pread, remote_hostio_close, remote_hostio_unlink)
	(remote_fileio_errno_to_host, remote_hostio_error, fclose_cleanup)
	(remote_hostio_close_cleanup, remote_file_put, remote_file_get)
	(remote_file_delete, remote_put_command, remote_get_command)
	(remote_delete_command, remote_command): New functions.
	(_initialize_remote): Register new packets and commands.
	* Makefile.in (gdb_fileio_h): New variable.
	(remote.o): Update.
	(SUBDIR_MI_OBS): Add mi-cmd-target.o.
	(SUBDIR_MI_SRCS): Add mi/mi-cmd-target.c.
	(mi-cmd-target.o): New rule.
	* mi/mi-cmd-target.c: New file.
	* mi/mi-cmds.c (mi_cmds): Add target-file-delete, target-file-get,
	and target-file-put.
	* mi/mi-cmds.h (mi_cmd_target_file_get, mi_cmd_target_file_put)
	(mi_cmd_target_file_delete): Declare.
	* remote.h (remote_file_put, remote_file_get, remote_file_delete):
	Declare.
	* NEWS: Describe new file transfer support.

	* gdb.texinfo (Debugging Programs with Multiple Processes): Correct
	formatting.
	(Remote Debugging): Add File Transfer section.
	(Remote Configuration): Document Host I/O packets.
	(GDB/MI): Add GDB/MI File Transfer Commands section.
	(Remote Protocol): Add Host I/O Packets section.
	(Packets): Add vFile.

	* Makefile.in (OBS): Add hostio.o.
	(hostio.o): New rule.
	* server.h (handle_vFile): Declare.
	* hostio.c: New file.
	* server.c (handle_v_requests): Take packet_len and new_packet_len
	for binary packets.  Call handle_vFile.
	(main): Update call to handle_v_requests.

	* gdb.server/file-transfer.exp, gdb.server/transfer.txt,
	gdb.mi/mi-file-transfer.exp: New.
@
text
@d6953 1
@


1.271
log
@2007-10-08  Markus Deuling  <deuling@@de.ibm.com>

	* remote.c (init_remote_state, fetch_register_using_p)
	(process_g_packet, remote_fetch_registers, remote_prepare_to_store)
	(store_register_using_P, store_registers_using_G)
	(remote_store_registers): Use get_regcache_arch or get_frame_arch to
	get at the current architecture by regcache or by frame, respectively.
@
text
@d61 1
d211 4
d909 5
d6289 625
d7357 15
d7386 18
@


1.270
log
@	* remote.c (get_offsets): Only call free_symfile_segment_data if
	data was allocated.
@
text
@d337 1
a337 1
				      gdbarch_num_regs (current_gdbarch),
d339 1
a339 1
  for (regnum = 0; regnum < gdbarch_num_regs (current_gdbarch); regnum++)
d343 1
a343 1
      if (register_size (current_gdbarch, regnum) == 0)
d356 2
a357 2
  remote_regs = alloca (gdbarch_num_regs (current_gdbarch) 
			* sizeof (struct packet_reg *));
d359 1
a359 1
       regnum < gdbarch_num_regs (current_gdbarch);
d371 1
a371 1
      offset += register_size (current_gdbarch, remote_regs[regnum]->regnum);
d3639 1
a3639 1
	     gdbarch_register_name (current_gdbarch, reg->regnum));
d3703 1
d3730 1
a3730 1
      for (i = 0; i < gdbarch_num_regs (current_gdbarch); i++)
d3768 1
a3768 1
    for (i = 0; i < gdbarch_num_regs (current_gdbarch); i++)
d3835 1
a3835 1
  for (i = 0; i < gdbarch_num_regs (current_gdbarch); i++)
d3861 1
a3861 1
      for (i = 0; i < gdbarch_num_regs (current_gdbarch); i++)
d3876 1
d3893 1
a3893 1
  bin2hex (regp, p, register_size (current_gdbarch, reg->regnum));
d3902 1
a3902 1
	     gdbarch_register_name (current_gdbarch, reg->regnum));
d3927 1
a3927 1
    for (i = 0; i < gdbarch_num_regs (current_gdbarch); i++)
d3982 1
a3982 1
  for (i = 0; i < gdbarch_num_regs (current_gdbarch); i++)
@


1.269
log
@2007-09-16  Daniel Jacobowitz  <dan@@codesourcery.com>
	    Jeff Johnston  <jjohnstn@@redhat.com>

	* breakpoint.c (watchpoints_triggered): New.
	(bpstat_stop_status): Remove STOPPED_BY_WATCHPOINT argument.
	Check watchpoint_triggered instead.  Combine handling for software
	and hardware watchpoints.  Do not use target_stopped_data_address
	here.  Always check a watchpoint if its scope breakpoint triggers.
	Do not stop for thread or overlay events.  Improve check for
	triggered watchpoints without a value change.
	(watch_command_1): Insert the scope breakpoint first.  Link the
	scope breakpoint to the watchpoint.
	* breakpoint.h (enum watchpoint_triggered): New.
	(struct breakpoint): Add watchpoint_triggered.
	(bpstat_stop_status): Update prototype.
	(watchpoints_triggered): Declare.
	* infrun.c (enum infwait_status): Add infwait_step_watch_state.
	(stepped_after_stopped_by_watchpoint): Delete.
	(handle_inferior_event): Make stepped_after_stopped_by_watchpoint
	local.  Handle infwait_step_watch_state.  Update calls to
	bpstat_stop_status.  Use watchpoints_triggered to check
	watchpoints.
	* remote.c (stepped_after_stopped_by_watchpoint): Remove extern.
	(remote_stopped_data_address): Do not check it.

	* gdb.texinfo (Setting Watchpoints): Adjust warning text about
	multi-threaded watchpoints.
	* gdbint.texinfo (Watchpoints): Describe how watchpoints are
	checked.  Describe sticky notification.  Expand description
	of steppable and continuable watchpoints.
	(Watchpoints and Threads): New subsection.

	* gdb.threads/watchthreads.c (thread_function): Sleep between
	iterations.
	* gdb.threads/watchthreads.exp: Allow two watchpoints to trigger
	at once for S/390.  Generate matching fails and passes.
@
text
@d2137 2
a2138 1
  free_symfile_segment_data (data);
@


1.268
log
@* remote.c (getpkt_sane): Fix error message.  No animals were
harmed in the making of this debugger.
@
text
@a5408 2
extern int stepped_after_stopped_by_watchpoint;

d5413 1
a5413 2
  if (remote_stopped_by_watchpoint ()
      || stepped_after_stopped_by_watchpoint)
@


1.267
log
@* symfile.h (struct symfile_segment_data): Doc fixes.
* symfile.c (symfile_map_offsets_to_segments): Doc fixes.
Assert that we were passed some loaded segment addresses,
and that sections' segment numbers are valid.
Simplify offset calculation.
* remote.c (get_offsets): Clarify selection of relocate-by-segment
strategy, and set num_segments correctly.  Delete redundant
assignments to do_sections.
@
text
@d5032 1
a5032 1
		  error (_("Watchdog has expired.  Target detached."));
@


1.266
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d2106 1
a2106 17
  /* Text= and Data= specify offsets for the text and data sections,
     but symfile_map_offsets_to_segments expects base addresses
     instead of offsets.  If we have two segments, we can still
     try to relocate the whole segments instead of just ".text"
     and ".data".  */
  if (num_segments == 0)
    {
      do_sections = 1;
      if (data == NULL || data->num_segments != 2)
	do_segments = 0;
      else
	{
	  segments[0] = data->segment_bases[0] + text_addr;
	  segments[1] = data->segment_bases[1] + data_addr;
	}
    }
  else
a2107 1
      do_sections = 0;
d2111 13
@


1.266.2.1
log
@* symfile.h (struct symfile_segment_data): Doc fixes.
* symfile.c (symfile_map_offsets_to_segments): Doc fixes.
Assert that we were passed some loaded segment addresses,
and that sections' segment numbers are valid.
Simplify offset calculation.
* remote.c (get_offsets): Clarify selection of relocate-by-segment
strategy, and set num_segments correctly.  Delete redundant
assignments to do_sections.
@
text
@d2106 17
a2122 1
  if (num_segments > 0)
d2124 1
a2127 13
  /* If we have two segments, we can still try to relocate everything
     by assuming that the .text and .data offsets apply to the whole
     text and data segments.  Convert the offsets given in the packet
     to base addresses for symfile_map_offsets_to_segments.  */
  else if (data && data->num_segments == 2)
    {
      segments[0] = data->segment_bases[0] + text_addr;
      segments[1] = data->segment_bases[1] + data_addr;
      num_segments = 2;
    }
  /* There's no way to relocate by segment.  */
  else
    do_segments = 0;
@


1.266.2.2
log
@	* remote.c (get_offsets): Only call free_symfile_segment_data if
	data was allocated.
@
text
@d2137 1
a2137 2
  if (data)
    free_symfile_segment_data (data);
@


1.265
log
@2007-07-03  Paul Gilliam  <pgilliam@@us.ibm.com>
	    Thiago Bauermann  <bauerman@@br.ibm.com>
	    Joseph S. Myers  <joseph@@codesourcery.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	gdb/
	* remote.c (remote_check_symbols): Use
	gdbarch_convert_from_func_ptr_addr.
	* infcall.c (find_function_addr): Handle function descriptors
	without debugging information.
	* ppc-linux-tdep.c (ppc_linux_convert_from_func_ptr_addr): Renamed
	from ppc64_linux_convert_from_func_ptr_addr.  Handle -msecure-plt.
	(ppc_linux_init_abi): Always set convert_from_func_ptr_addr.
	* solib-svr4.c (solib_break_names): Remove "._dl_debug_state".
	(bfd_lookup_symbol): Do not take a SECT_FLAGS argument.  Always
	allow SEC_CODE and SEC_DATA.
	(enable_break): Update calls.  Pass current_target to solib_add.
	Use gdbarch_convert_from_func_ptr_addr.

	gdb/gdbserver/
	* remote-utils.c (look_up_one_symbol): Handle 'm' packets.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d20 1
a20 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.264
log
@	* Makefile.in (XMLFILES): Add library-list.dtd.
	(ALLDEPFILES): Add solib-target.o.
	(solib-target.o): New rule.
	* remote.c (PACKET_qXfer_libraries): New constant.
	(remote_protocol_features): Add qXfer:libraries:read.
	(remote_wait): Recognize library stop replies.
	(remote_async_wait): Likewise.  Fix typo.
	(remote_xfer_partial): Handle TARGET_OBJECT_LIBRARIES.
	(init_remote_async_ops): Fix typo.
	(_initialize_remote): Register "set remote library-info-packet".
	* solib-som.c (som_current_sos): Set addr_low and addr_high.
	* solib-target.c: New file.
	* solib.c (solib_map_sections): Use addr_low and addr_high instead
	of textsection.
	(info_sharedlibrary_command): Likewise.
	(solib_add_library, solib_remove_library): New.
	* solist.h (struct so_list): Replace textsection with addr_low and
	addr_high.
	* target.h (enum target_object): Add TARGET_OBJECT_LIBRARIES.
	* NEWS: Describe new qXfer:libraries:read and shared library
	event support.
	* features/library-list.dtd: New.

	* gdb.texinfo (Remote Configuration): Document library-info-packet.
	Add other missing entries.  Adjust the table size to fit.
	(Stop Reply Packets): Use @@itemize instead of @@enumerate.  Document
	stop reasons including the new "library" event.
	(General Query Packets): Adjust table widths for qSupported.  Mention
	qXfer:libraries:read reply to qSupported and document the new packet.
	(Library List Format): New section.
@
text
@d2262 13
a2274 3
	xsnprintf (msg, get_remote_packet_size (), "qSymbol:%s:%s",
		   paddr_nz (SYMBOL_VALUE_ADDRESS (sym)),
		   &reply[8]);
@


1.263
log
@	* remote.c (remote_address_masked): If remote_address_size is zero,
	default to target address size.
	(build_remote_gdbarch_data): Remove.
	(_initialize_remote): Do not swap remote_address_size.
@
text
@d908 1
d2380 2
d3187 1
d3273 10
d3324 8
a3331 3
	  status->kind = TARGET_WAITKIND_STOPPED;
	  status->value.sig = (enum target_signal)
	    (((fromhex (buf[1])) << 4) + (fromhex (buf[2])));
d3394 1
d3456 1
a3456 1
		if (!strncmp (p, "awatch", strlen ("awatch")) != 0)
d3486 10
d3537 8
a3544 3
	  status->kind = TARGET_WAITKIND_STOPPED;
	  status->value.sig = (enum target_signal)
	    (((fromhex (buf[1])) << 4) + (fromhex (buf[2])));
d5837 5
d6459 1
a6459 1
  remote_ops.to_read_description = remote_read_description;
d6699 3
@


1.262
log
@	* coffread.c (coff_sym_fns): Add default_symfile_segments.
	* dbxread.c (start_psymtab): Check HAVE_ELF.
	(aout_sym_fns): Likewise.
	* elfread.c (elf_symfile_segments): New.
	(elf_sym_fns): Add elf_symfile_segments.
	* mipsread.c (ecoff_sym_fns): Add default_symfile_segments.
	* remote.c (get_offsets): Use symfile_map_offsets_to_segments.
	Skip if there is no symfile_objfile.  Handle TextSeg and DataSeg.
	* somread.c (som_sym_fns): Use default_symfile_segments.
	* symfile.c (find_sym_fns): Take a BFD and return the sym_fns.
	(init_objfile_sect_indices): Call symfile_find_segment_sections.
	(default_symfile_segments): New function.
	(syms_from_objfile): Update call to find_sym_fns.
	(symfile_get_segment_data, free_symfile_segment_data): New.
	(symfile_map_offsets_to_segments): New.
	(symfile_find_segment_sections): New.
	* symfile.h (struct symfile_segment_data): New.
	(struct sym_fns): Add sym_segments.
	(default_symfile_segments, symfile_get_segment_data)
	(free_symfile_segment_data): New prototypes.
	(symfile_map_offsets_to_segments): Likewise.
	* xcoffread.c (xcoff_sym_fns): Add default_symfile_segments.
	* Makefile.in (COMMON_OBS): Remove elfread.o.
	(elf_internal_h): New.
	(elfread.o): Update.
	* configure.ac: Add elfread.o to COMMON_OBS if bfd/elf.o was
	compiled.
	* config.in, configure: Regenerated.
	* NEWS: Mention qOffsets changes.

	* gdb.texinfo (General Query Packets): Document qOffsets changes.

	* Makefile.def: Add dependency from configure-gdb to all-bfd.
	* Makefile.in: Regenerated.
@
text
@a87 2
static void build_remote_gdbarch_data (void);

d3994 7
a4000 2
  if (remote_address_size > 0
      && remote_address_size < (sizeof (ULONGEST) * 8))
d4005 1
a4005 1
      mask = (mask << remote_address_size) - 1;
a6480 5
static void
build_remote_gdbarch_data (void)
{
  remote_address_size = gdbarch_addr_bit (current_gdbarch);
}
a6500 5
  /* Old tacky stuff.  NOTE: This comes after the remote protocol so
     that the remote protocol has been initialized.  */
  DEPRECATED_REGISTER_GDBARCH_SWAP (remote_address_size);
  deprecated_register_gdbarch_swap (NULL, 0, build_remote_gdbarch_data);

@


1.261
log
@	* regcache.c (struct regcache): Add ptid_t member.
	(regcache_xmalloc): Initialize it.
	(regcache_cpy_no_passthrough): Do not refer to current_regcache.
	(regcache_dup): Likewise.
	(regcache_dup_no_passthrough): Likewise.
	(current_regcache): Make static.
	(registers_ptid): Remove variable.
	(get_thread_regcache): New function.
	(get_current_regcache): New function.
	(registers_changed): Implement by freeing current regcache.
	(regcache_raw_read): Do not refer to current_regcache.  Set
	inferior_ptid to regcache->ptid while calling target routines.
	(regcache_raw_write): Likewise.
	(regcache_raw_supply): Do not refer to current_regcache.
	(read_pc_pid): Use thread regcache.  Do not modify inferior_ptid.
	(write_pc_pid): Likewise.
	(build_regcache): Remove.
	(_initialize_regcache): Do not call DEPRECATED_REGISTER_GDBARCH_SWAP
	or deprecated_register_gdbarch_swap.  Do not initialize
	registers_ptid.
	* regcache.h (get_current_regcache): Add prototype.
	(get_thread_regcache): Likewise.
	(current_regcache): Remove declaration.

	* corelow.c (core_open): Replace current_regcache by
	get_current_regcache ().
	* frame.c (frame_pop): Likewise.
	(put_frame_register): Likewise.
	(get_current_frame, create_new_frame): Likewise.
	* mi/mi-main.c (mi_cmd_data_write_register_values): Likewise.
	* stack.c (return_command): Likewise.
	* infcall.c (call_function_by_hand): Likewise.
	* infrun.c (resume): Likewise.
	(save_inferior_status, restore_inferior_status): Likewise.
	* linux-fork.c (fork_load_infrun_state): Likewise.
	(fork_save_infrun_state): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* i386fbsd-nat.c (i386fbsd_resume): Likewise.
	* monitor.c (monitor_wait): Likewise.
	* remote.c (remote_wait): Likewise.
	* remote-mips.c (mips_wait): Likewise.

	* bsd-kvm.c (bsd_kvm_open): Likewise
	(bsd_kvm_proc_cmd, bsd_kvm_pcb_cmd): Likewise.
	* fbsd-nat.c (fbsd_make_corefile_notes): Likewise.
	* i386-linux-nat.c (i386_linux_resume): Likewise.
	* ia64-linux-nat.c (ia64_linux_insert_watchpoint): Likewise.
	(ia64_linux_stopped_data_address): Likewise.

	* frv-tdep.c (frv_fdpic_loadmap_addresses): Likewise.
	* m32c-tdep.c (m32c_virtual_frame_pointer): Likewise.
	* mep-tdep.c (current_me_module, current_options): Likewise.
	* mips-tdep.c (deprecated_mips_set_processor_regs_hack): Likewise.

	* linux-nat.c (linux_nat_do_thread_registers): Use thread
	regcache instead of current_regcache.  Call target_fetch_registers.
	(linux_nat_corefile_thread_callback): Update call site.
	(linux_nat_do_registers): Likewise.
	* procfs.c (procfs_do_thread_registers): Use thread regcache instead
	of current_regcache.
	(procfs_make_note_section): Likewise.
	* proc-service.c (ps_lgetregs, ps_lsetregs): Likewise.
	(ps_lgetfpregs, ps_lsetfpregs): Likewise.
	* sol-thread.c (ps_lgetregs, ps_lsetregs): Likewise.
	(ps_lgetfpregs, ps_lsetfpregs): Likewise.
@
text
@d2019 2
a2020 2
  int lose;
  CORE_ADDR text_addr, data_addr, bss_addr;
d2022 4
d2054 21
d2076 1
a2076 4
  else
    lose = 1;

  if (!lose && strncmp (ptr, ";Data=", 6) == 0)
d2078 2
a2079 1
      ptr += 6;
d2081 2
a2082 4
	data_addr = (data_addr << 4) + fromhex (*ptr++);
    }
  else
    lose = 1;
d2084 7
a2090 5
  if (!lose && strncmp (ptr, ";Bss=", 5) == 0)
    {
      ptr += 5;
      while (*ptr && *ptr != ';')
	bss_addr = (bss_addr << 4) + fromhex (*ptr++);
d2097 2
a2098 3

  if (symfile_objfile == NULL)
    return;
d2105 34
a2138 1
  offs->offsets[SECT_OFF_TEXT (symfile_objfile)] = text_addr;
d2140 3
a2142 3
  /* This is a temporary kludge to force data and bss to use the same offsets
     because that's what nlmconv does now.  The real solution requires changes
     to the stub and remote.c that I don't have time to do right now.  */
d2144 13
a2156 2
  offs->offsets[SECT_OFF_DATA (symfile_objfile)] = data_addr;
  offs->offsets[SECT_OFF_BSS (symfile_objfile)] = data_addr;
@


1.260
log
@2007-06-13  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_ADDR_BIT): Replace by gdbarch_addr_bit.
	* valops.c (value_cast): Likewise.
	* utils.c (strlen_paddr, paddr, paddr_nz, paddress): Likewise.
	* ui-out.c (ui_out_field_core_addr): Likewise.
	* tracepoint.c (tracepoints_info): Likewise.
	* symtab.c (print_msymbol_info): Likewise.
	* solib-irix.c (irix_current_sos)
	(irix_open_symbol_file_object): Likewise.
	* remote.c (build_remote_gdbarch_data): Likewise.
	* prologue-value.c (make_pv_area): Likewise.
	* procfs.c (info_mappings_callback): Likewise.
	* printcmd.c (print_scalar_formatted)
	(deprecated_print_address_numeric): Likewise.
	* memattr.c (mem_info_command): Likewise.
	* linux-nat.c (linux_nat_info_proc_cmd): Likewise.
	* gdbtypes.c (build_flt, gdbtypes_post_init): Likewise.
	* exec.c (print_section_info): Likewise.
	* dwarf2read.c (read_subrange_type): Likewise.
	* dwarf2loc.c (find_location_expression): Likewise.
	* dwarf2expr.c (dwarf2_read_address, unsigned_address_type)
	(signed_address_type, execute_stack_op): Likewise.
	* breakpoint.c (print_one_breakpoint, breakpoint_1): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d3235 1
a3235 1
		    regcache_raw_supply (current_regcache,
d3432 2
a3433 1
		    regcache_raw_supply (current_regcache, reg->regnum, regs);
@


1.259
log
@2007-06-13  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (BREAKPOINT_FROM_PC): Replace by
	gdbarch_breakpoint_from_pc.
	* s390-tdep.c (s390_gdbarch_init): Likewise (comment).
	* remote.c (remote_insert_breakpoint)
	(remote_insert_hw_breakpoint): Likewise.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Likewise.
	* mips-tdep.c (mips_breakpoint_from_pc): Likewise (comment).
	* breakpoint.h (bp_target_info): Likewise (comment).
	* breakpoint.c (read_memory_nobpt): Likewise.
	* mem-break.c (default_memory_insert_breakpoint): Likewise.
	(symtab.h, breakpoint.h): Remove include. Remove unnecessary comment.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d6414 1
a6414 1
  remote_address_size = TARGET_ADDR_BIT;
@


1.258
log
@	* remote.c (remote_protocol_features): Add qXfer:spu:read and
	qXfer:spu:write packet types.
@
text
@d5131 2
a5132 1
      BREAKPOINT_FROM_PC (&bp_tgt->placed_address, &bp_tgt->placed_size);
d5327 2
a5328 1
  BREAKPOINT_FROM_PC (&bp_tgt->placed_address, &bp_tgt->placed_size);
@


1.257
log
@ChangeLog:

	* remote.c (remote_write_qxfer): New function.
	(remote_xfer_partial): Add handling for TARGET_OBJECT_SPU.
	(remote_read_qxfer): Do not cache empty objects.
	(_initialize_remote): Add PACKET_qXfer_spu_read and
	PACKET_qXfer_spu_write.

doc/ChangeLog:

	* gdb.texinfo (General Query Packets): Document qXfer:spu:read
	and qXfer:spu:write packets and mention them under qSupported.

gdbserver/ChangeLog:

	* remote-utils.c (decode_xfer_write): New function.
	* server.h (decode_xfer_write): Add prototype.
	* server.c (handle_query): Add PACKET_LEN argument.  Support
	qXfer:spu:read and qXfer:spu:write packets.
	(main): Pass packet_len to handle_query.
	* spu-low.c (spu_target_ops): Add spu_proc_xfer_spu.
	* target.h (target_ops): Add qxfer_spu.
@
text
@d2317 4
@


1.256
log
@2007-06-09  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (REGISTER_NAME): Replace by gdbarch_register_name.
	* tracepoint.c (scope_info): Likewise.
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_register_reggroup_p): Likewise.
	* sh64-tdep.c (sh64_do_fp_register, sh64_do_register)
	(sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_reggroup_p): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	* remote.c (packet_reg): Likewise (comment).
	* reggroups.c (default_register_reggroup_p): Likewise.
	* regcache.c (regcache_dump): Likewise.
	* printcmd.c (address_info): Likewise.
	* ppc-linux-nat.c (fetch_register, store_register): Likewise.
	* mt-dep.c (mt_registers_info): Likewise.
	* mn10300-tdep.c (mn10300_dwarf2_reg_to_regnum): Likewise (comment).
	* mips-tdep.c (mips_register_reggroup_p, mips_read_fp_register_single)
	(mips_read_fp_register_double, mips_print_fp_register)
	(mips_print_register, print_gp_register_row, mips_print_registers_info)
	(mips_register_sim_regno): Likewise.
	* m68klinux-nat.c (regmap, fetch_register, store_register): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_register)
	(inf_ptrace_store_register): Likewise.
	* infcmd.c (default_print_registers_info): Likewise.
	* ia64-linux-nat.c (ia64_linux_fetch_register)
	(ia64_linux_store_register): Likewise.
	* i386-linux-nat.c (fetch_register, store_register): Likewise.
	* i386gnu-nat.c (gnu_fetch_registers, gnu_store_registers): Likewise.
	* hppa-linux-nat.c (fetch_register, store_register): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register)
	(hppa_hpux_store_register): Likewise.
	* findvar.c (locate_var_value): Likewise.
	* dwarf2loc.c (locexpr_describe_location): Likewise.
	* dwarf2-frame.c (execute_cfa_program): Likewise.
	* arm-tdep.c (arm_push_dummy_call): Likewise.
	* arch-utils.c (legacy_register_sim_regno): Likewise.
	* alpha-tdep.c (alpha_register_reggroup_p): Likewise.
	* alpha-nat.c (fetch_osf_core_registers): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers, mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d911 2
d5521 39
d5632 3
a5634 3
     or possibly empty.  Record it to bypass the next read, if one is
     issued.  */
  if (rs->buf[0] == 'l')
d5673 13
d6596 6
@


1.255
log
@	* remote.c (process_g_packet): Don't check size.
	* gdbarch.sh: Remove register_bytes_ok.
	* gdbarch.c: Regenerated.
	* gdbarch.h: Regenerated.
	* m68k-tdep.c (REGISTER_BYTES_NOFP): Remove.
	(m68k_register_bytes_ok): Remove.
	(m68k_gdbarch_init): Don't register m68k_register_bytes_ok.
@
text
@d263 2
a264 1
  /* char *name; == REGISTER_NAME (regnum); at present.  */
@


1.254
log
@2007-05-31  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (NUM_REGS): Replace by gdbarch_num_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_registers)
	(inf_ptrace_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* i386-linux-nat.c (supply_gregset, fill_gregset)
	(i386_linux_fetch_inferior_registers)
	(i386_linux_store_inferior_registers): Likewise.
	* remote.c (init_remote_state,packet_reg_from_regnum)
	(packet_reg_from_pnum,process_g_packet,remote_fetch_registers)
	(remote_prepare_to_store,store_registers_using_G)
	(remote_store_registers,remote_arch_state): Likewise.
	* tracepoint.c (encode_actions): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* tui/tui-regs.c (tui_show_register_group)
	(tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* xtensa-tdep.c (xtensa_register_name,xtensa_register_type)
	(xtensa_reg_to_regnum,xtensa_pseudo_register_read)
	(xtensa_pseudo_register_write,xtensa_register_reggroup_p): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers)
	(do_win32_store_inferior_registers,fetch_elf_core_registers
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target-descriptions.c (tdesc_use_registers): Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_do_pseudo_register,sh64_print_register)
	(sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* rs6000-nat.c (fetch_register,store_register): Likewise.
	* remote-sim.c (one2one_register_sim_regno,gdbsim_fetch_register)
	(gdbsim_fetch_register,gdbsim_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers,mips_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers)
	(m32r_store_registers): Likewise.
	* reggroups.c (default_register_reggroup_p): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save)
	(regcache_restore,regcache_dump): Likewise.
	* monitor.c (monitor_fetch_registers,monitor_store_registers): Likewise.
	* mips-tdep.c (mips_xfer_register,mips_register_name)
	(mips_register_reggroup_p,mips_pseudo_register_read)
	(mips_pseudo_register_write,mips_convert_register_p,mips_register_type)
	(mips_unwind_pc,mips_unwind_sp,mips_unwind_dummy_id,set_reg_offset)
	(mips16_scan_prologue,mips_insn16_frame_cache,reset_saved_regs)
	(mips32_scan_prologue,mips_insn32_frame_cache,read_next_frame_reg)
	(mips_n32n64_return_value,mips_o32_return_value,mips_o64_return_value)
	(print_gp_register_row,mips_print_registers_info)
	(mips_stab_reg_to_regnum,mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_register_sim_regno): Likewise.
	* mips-linux-tdep.c (mips_linux_o32_sigframe_init)
	(mips_linux_n32n64_sigframe_init): Likewise.
	* mips-linux-nat.c (mips_linux_register_addr)
	(mips64_linux_register_addr): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* mips64obsd-tdep.c (mips64obsd_sigframe_init): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache(: Likewise.
	* m32r-tdep.c (m32r_frame_unwind_cache): Likewise.
	* ia64-linux-nat.c (ia64_register_addr,ia64_cannot_fetch_register)
	(ia64_cannot_store_register,ia64_linux_fetch_registers)
	(ia64_linux_store_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Likewise.
	* h8300-tdep.c (E_PSEUDO_CCR_REGNUM,E_PSEUDO_EXR_REGNUM)
	(h8300_init_frame_cache,h8300_frame_cache,h8300_frame_prev_register)
	(h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache)
	(dwarf2_frame_state_alloc_regs): Likewise.
	* cris-tdep.c (cris_register_size,cris_cannot_fetch_register)
	(cris_cannot_store_register,crisv32_cannot_fetch_register)
	(crisv32_cannot_store_register,cris_register_name): Likewise.
	* avr-tdep.c (avr_frame_unwind_cache): Likewise.
	* arch-utils.c (legacy_register_sim_regno)
	(legacy_virtual_frame_pointer): Likewise.
	* arm-tdep.c (arm_make_prologue_cache,arm_register_sim_regno):Likewise.
	* arm-tdep.h: Likewise (comment).
	* frv-tdep.c (frv_register_sim_regno): Likewise.
	* m68klinux-nat.c (old_fetch_inferior_registers)
	(old_store_inferior_registers): Likewise.
	* m32c-tdep.c (m32c_virtual_frame_pointer): Likewise.
	* irix5-nat.c (fetch_core_registers): Likewise.
	* hppa-tdep.c (hppa_frame_cache): Likewise.
	* hppa-linux-nat.c (hppa_linux_register_addr)
	(hppa_linux_fetch_inferior_registers)
	(hppa_linux_store_inferior_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_inferior_registers)
	(hppa_hpux_store_inferior_registers): Likewise.
	* amd64-nat.c (amd64_native_gregset_reg_offset)
	(amd64_supply_native_gregset,amd64_collect_native_gregset): Likewise.
	* dbug-rom.c (dbug_regname): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache)
	(HARD_PAGE_REGNUM (comment)): Likewise.
	* gdbarch.sh (NUM_PSEUDO_REGS): Replace by gdbarch_num_pseudo_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
	* tui/tui-regs.c (tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_print_register,sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save
	(regcache_restore,regcache_dump): Likewise.
	* mips-tdep.c (print_gp_register_row,mips_print_registers_info)
	(mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_stab_reg_to_regnum): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache): Likewise.
	* frame.h (SIZEOF_FRAME_SAVED_REGS): Likewise.
	* xtensa-tdep.c (xtensa_register_type,xtensa_reg_to_regnum)
	(xtensa_pseudo_register_read,xtensa_pseudo_register_write): Likewise.
	* parse.c: Remove comment.
	* gdbarch.c, gdbarch.h: Regenerate
@
text
@a3599 2
  if (REGISTER_BYTES_OK_P () && !REGISTER_BYTES_OK (buf_len / 2))
    error (_("Remote 'g' packet reply is wrong length: %s"), rs->buf);
@


1.253
log
@doc/ChangeLog:

	* observer.texi (GDB Observers): New observer "new_objfile".

ChangeLog:

	* observer.sh: Add "struct objfile" forward declaration.
	* target.h (deprecated_target_new_objfile_hook): Remove.
	* symfile.c (deprecated_target_new_objfile_hook): Remove.
	(clear_symtab_users): Call observer_notify_new_objfile.
	(symbol_file_add_with_addrs_or_offsets): Likewise.
	* rs6000-nat.c: Include "observer.h".
	(vmap_ldinfo): Call observer_notify_new_objfile.
	(xcoff_relocate_core): Likewise.
	* remote.c (remote_new_objfile_chain): Remove.
	(remote_new_objfile): Do not call remote_new_objfile_chain.
	(_initialize_remote): Use observer_attach_new_objfile.
	* tui/tui-hooks.c (tui_target_new_objfile_chain): Remove.
	(tui_new_objfile_hook): Do not call tui_target_new_objfile_chain.
	(_initialize_tui_hooks): Use observer_attach_new_objfile.
	* aix-thread.c: Include "observer.h".
	(target_new_objfile_chain): Remove.
	(new_objfile): Do not call target_new_objfile_chain.
	(_initialize_aix_thread): Use observer_attach_new_objfile.
	* hpux-thread.c: Include "observer.h"
	(target_new_objfile_chain): Remove.
	(hpux_thread_new_objfile): Make static.  Do not call
	target_new_objfile_chain.
	(_initialize_hpux_thread): Use observer_attach_new_objfile.
	* linux-thread-db.c: Include "observer.h".
	(target_new_objfile_chain): Remove.
	(thread_db_new_objfile): Do not call target_new_objfile_chain.
	(_initialize_thread_db): Use observer_attach_new_objfile.
	* sol-thread.c: Include "observer.h".
	(target_new_objfile_chain): Remove.
	(sol_thread_new_objfile): Make static.  Do not call
	target_new_objfile_chain.
	(_initialize_sol_thread): Use observer_attach_new_objfile.
	* Makefile.in (aix-thread.o, hpux-thread.o, linux-thread-db.o,
	rs6000-nat.o, sol-thread.o, tui-hooks.o): Add dependency on
	$(observer_h).
@
text
@d272 1
a272 1
     (making an array NUM_REGS in size).  */
d339 4
a342 2
  rsa->regs = GDBARCH_OBSTACK_CALLOC (gdbarch, NUM_REGS, struct packet_reg);
  for (regnum = 0; regnum < NUM_REGS; regnum++)
d359 5
a363 2
  remote_regs = alloca (NUM_REGS * sizeof (struct packet_reg *));
  for (num_remote_regs = 0, regnum = 0; regnum < NUM_REGS; regnum++)
d431 1
a431 1
  if (regnum < 0 && regnum >= NUM_REGS)
d445 1
a445 1
  for (i = 0; i < NUM_REGS; i++)
d3619 1
a3619 1
      for (i = 0; i < NUM_REGS; i++)
d3657 1
a3657 1
    for (i = 0; i < NUM_REGS; i++)
d3724 1
a3724 1
  for (i = 0; i < NUM_REGS; i++)
d3750 1
a3750 1
      for (i = 0; i < NUM_REGS; i++)
d3815 1
a3815 1
    for (i = 0; i < NUM_REGS; i++)
d3870 1
a3870 1
  for (i = 0; i < NUM_REGS; i++)
@


1.252
log
@	* gdbarch.sh (remote_translate_xfer_address): Remove.
	* gdbarch.h, gdbarch.c: Regenerate.
	* arch-utils.c (generic_remote_translate_xfer_address): Remove.
	* arch-utils.h (generic_remote_translate_xfer_address): Remove.
	* remote.c (remote_write_bytes_aux, remote_read_bytes): Do not
	call gdbarch_remote_translate_xfer_address.
	* frv-tdep.c (frv_gdbarch_init): Do not call
	set_gdbarch_remote_translate_xfer_address.
	* ia64-tdep.c (ia64_remote_translate_xfer_address): Remove.
	(ia64_gdbarch_init): Do not install it.
@
text
@a6352 3
/* Saved pointer to previous owner of the new_objfile event.  */
static void (*remote_new_objfile_chain) (struct objfile *);

d6358 1
a6358 6
    {
      remote_check_symbols (objfile);
    }
  /* Call predecessor on chain, if any.  */
  if (remote_new_objfile_chain)
    remote_new_objfile_chain (objfile);
d6398 1
a6398 2
  remote_new_objfile_chain = deprecated_target_new_objfile_hook;
  deprecated_target_new_objfile_hook  = remote_new_objfile;
@


1.251
log
@	* remote.c (remote_detach): Error out if remote can't detach.
@
text
@a4110 6
  /* Should this be the selected frame?  */
  gdbarch_remote_translate_xfer_address (current_gdbarch,
					 current_regcache,
					 memaddr, len,
					 &memaddr, &len);

a4302 6
  /* Should this be the selected frame?  */
  gdbarch_remote_translate_xfer_address (current_gdbarch,
					 current_regcache,
					 memaddr, len,
					 &memaddr, &len);

@


1.250
log
@	* regcache.c (regcache_invalidate): New function.
	(register_cached): Remove.
	(set_register_cached): Remove.
	(deprecated_registers_fetched): Remove.
	(registers_changed): Use regcache_invalidate instead
	of set_register_cached.
	(regcache_raw_read): Update comment.

	* regcache.h (regcache_invalidate): Add prototype.
	(register_cached): Remove.
	(set_register_cached): Remove.
	(deprecated_registers_fetched): Remove.

	* findvar.c (value_of_register): Do not call register_cached.
	* frame.c (frame_register): Likewise.
	* tui/tui-regs.c (tui_get_register): Likewise.

	* remote.c (fetch_register_using_p): Do not call set_register_cached.
	(process_g_packet): Likewise.
	(remote_fetch_registers): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	* mt-tdep.c (mt_select_coprocessor): Replace set_register_cached call
	by regcache_invalidate.
	(mt_pseudo_register_write): Likewise.
	* sh-tdep.c (sh_pseudo_register_write): Likewise.

	* corelow.c (get_core_registers): Replace deprecated_registers_fetched
	call by loop over regcache_raw_supply (..., NULL).
@
text
@d2603 5
a2607 1
  remote_send (&rs->buf, &rs->buf_size);
@


1.249
log
@	* target.h (struct target_ops): Add REGCACHE parameter to
	to_prepare_to_store.
	(target_prepare_to_store): Likewise.
	* target.c (debug_to_prepare_to_store): Add REGCACHE parameter.
	(update_current_target): Adapt prepare_to_store de_fault rule.

	* regcache.c (regcache_raw_write): Pass regcache to
	target_prepare_to_store.

	* inftarg.c (child_prepare_to_store): Add REGCACHE parameter.
	Do not call CHILD_PREPARE_TO_STORE.
	* gnu-nat.c (gnu_prepare_to_store): Likewise.
	* procfs.c (procfs_prepare_to_store): Likewise.

	* inf-child.c (inf_child_prepare_to_store): Add REGCACHE parameter.
	* go32-nat.c (go32_prepare_to_store): Likewise.
	* monitor.c (monitor_prepare_to_store): Likewise.
	* nto-procfs.c (procfs_prepare_to_store): Likewise.
	* remote-m32r-sdi.c (m32r_prepare_to_store): Likewise.
	* remote-mips.c (mips_prepare_to_store): Likewise.
	* remote-sim.c (gdbsim_prepare_to_store): Likewise.
	* win32-nat.c (win32_prepare_to_store): Likewise.

	* remote.c (remote_prepare_to_store): Add REGCACHE parameter.
	Use it instead of current_regcache.

	* hpux-thread.c (hpux_thread_prepare_to_store): Add REGCACHE
	parameter.  Pass it on to next target.
	* sol-thread.c (sol_thread_prepare_to_store): Likewise.
@
text
@a3524 1
      set_register_cached (reg->regnum, -1);
a3662 1
		set_register_cached (i, -1);
a3708 1
      set_register_cached (reg->regnum, -1);
a3720 1
	  set_register_cached (i, -1);
@


1.248
log
@	* target.h (struct regcache): Add forward declaration.
	(struct target_ops): Add REGCACHE parameter to to_fetch_registers
	and to_store_registers target operations.
	(target_fetch_registers, target_store_registers): Update.

	* regcache.c (regcache_raw_read): Replace register_cached by
	regcache_valid_p.  Pass regcache to target_fetch_registers.
	(regcache_raw_write): Pass regcache to target_store_registers.

	* arm-linux-nat.c (store_fpregister, store_fpregs, store_register,
	store_regs, store_wmmx_regs): Replace register_cached by
	regcache_valid_p.

	* bsd-kvm.c (bsd_kvm_open, bsd_kvm_proc_cmd): Pass current_regcache
	to target_fetch_registers calls.
	* corelow.c (core_open): Likewise.
	* linux-nat.c (linux_nat_corefile_thread_callback): Likewise.
	* proc-service.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* sol-thread.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* ia64-tdep.c (ia64_store_return_value): Pass current_regcache
	to target_store_registers call.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.

	* inferior.h (store_inferior_registers): Update prototype.
	(fetch_inferior_registers): Likewise.
	* gnu-nat.c (gnu_store_registers, gnu_fetch_registers): Likewise.
	* mips-linux-nat.c (super_fetch_registers, super_store_registers):
	Update function pointer signatures.

	* aix-thread.c (aix_thread_fetch_registers): Add REGCACHE parameter,
	use it instead of current_regcache, update calls.
	(aix_thread_store_registers): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers): Likewise.
	(alphabsd_store_inferior_registers): Likewise.
	* amd64bsd-nat.c (amd64bsd_fetch_inferior_registers): Likewise.
	(amd64bsd_store_inferior_registers): Likewise.
	* amd64-linux-nat.c (amd64_linux_fetch_inferior_registers): Likewise.
	(amd64_linux_store_inferior_registers): Likewise.
	* arm-linux-nat.c (fetch_fpregister, fetch_fpregs, store_fpregister,
	store_fpregs, fetch_register, fetch_regs, store_register, store_regs,
	fetch_wmmx_regs, store_wmmx_regs): Likewise.
	(arm_linux_fetch_inferior_registers): Likewise.
	(arm_linux_store_inferior_registers): Likewise.
	* armnbsd-nat.c (fetch_register, fetch_regs, fetch_fp_register,
	fetch_fp_regs, armnbsd_fetch_registers): Likewise.
	(store_register, store_regs, store_fp_register, store_fp_regs,
	armnbsd_store_registers): Likewise.
	* bsd-kvm.c (bsd_kvm_fetch_pcb, bsd_kvm_fetch_registers): Likewise.
	* bsd-uthread.c (bsd_uthread_fetch_registers): Likewise.
	(bsd_uthread_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register,
	go32_store_registers): Likewise.
	* hppabsd-nat.c (hppabsd_fetch_registers): Likewise.
	(hppabsd_store_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register): Likewise.
	(hppa_hpux_fetch_inferior_registers): Likewise.
	(hppa_hpux_store_register): Likewise.
	(hppa_hpux_store_inferior_registers): Likewise.
	* hppa-linux-nat.c (fetch_register, store_register): Likewise.
	(hppa_linux_fetch_inferior_registers): Likewise.
	(hppa_linux_store_inferior_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers): Likewise.
	(hpux_thread_store_registers): Likewise.
	* i386bsd-nat.c (i386bsd_fetch_inferior_registers): Likewise.
	(i386bsd_store_inferior_registers): Likewise.
	* i386gnu-nat.c (fetch_fpregs, gnu_fetch_registers, store_fpregs,
	gnu_store_registers): Likewise.
	* i386-linux-nat.c (fetch_register, store_register, fetch_regs,
	store_regs, fetch_fpregs, store_fpregs, fetch_fpxregs, store_fpxregs):
	Likewise.
	(i386_linux_fetch_inferior_registers): Likewise.
	(i386_linux_store_inferior_registers): Likewise.
	* ia64-linux-nat.c (ia64_linux_fetch_register): Likewise.
	(ia64_linux_fetch_registers): Likewise.
	(ia64_linux_store_register): Likewise.
	(ia64_linux_store_registers): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	(inf_child_store_inferior_registers): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_register): Likewise.
	(inf_ptrace_fetch_registers): Likewise.
	(inf_ptrace_store_register): Likewise.
	(inf_ptrace_store_registers): Likewise.
	* infptrace.c (fetch_register, store_register): Likewise.
	(fetch_inferior_registers, store_inferior_registers): Likewise.
	* m32r-linux-nat.c (fetch_regs, store_regs): Likewise.
	(m32r_linux_fetch_inferior_registers): Likewise.
	(m32r_linux_store_inferior_registers): Likewise.
	* m68kbsd-nat.c (m68kbsd_fetch_inferior_registers): Likewise.
	(m68kbsd_store_inferior_registers): Likewise.
	* m68klinux-nat.c (fetch_register, old_fetch_inferior_registers,
	store_register, old_store_inferior_registers, fetch_regs, store_regs,
	fetch_fpregs, store_fpregs): Likewise.
	(m68k_linux_fetch_inferior_registers): Likewise.
	(m68k_linux_store_inferior_registers): Likewise.
	* m88kbsd-nat.c (m88kbsd_fetch_inferior_registers): Likewise.
	(m88kbsd_store_inferior_registers): Likewise.
	* mips64obsd-nat.c (mips64obsd_fetch_inferior_registers): Likewise.
	(mips64obsd_store_inferior_registers): Likewise.
	* mips-linux-nat.c (mips64_linux_regsets_fetch_registers): Likewise.
	(mips64_linux_regsets_store_registers): Likewise.
	(mips64_linux_fetch_registers): Likewise.
	(mips64_linux_store_registers): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers): Likewise.
	(mipsnbsd_store_inferior_registers): Likewise.
	* monitor.c (monitor_fetch_register, monitor_store_register): Likewise.
	(monitor_fetch_registers, monitor_store_registers): Likewise.
	* nto-procfs.c (procfs_fetch_registers): Likewise.
	(procfs_store_registers): Likewise.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register,
	fetch_register, supply_vrregset, fetch_altivec_registers,
	fetch_ppc_registers, ppc_linux_fetch_inferior_registers): Likewise.
	(store_altivec_register, store_spe_register, store_register,
	fill_vrregset, store_altivec_registers, store_ppc_registers,
	ppc_linux_store_inferior_registers): Likewise.
	* ppcnbsd-nat.c (ppcnbsd_fetch_inferior_registers): Likewise.
	(ppcnbsd_store_inferior_registers): Likewise.
	* ppcobsd-nat.c (ppcobsd_fetch_registers): Likewise.
	(ppcobsd_store_registers): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* remote.c (fetch_register_using_p, process_g_packet,
	fetch_registers_using_g, remote_fetch_registers): Likewise.
	(store_register_using_P, store_registers_using_G,
	remote_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers, m32r_fetch_register,
	m32r_store_register, m32r_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers, mips_store_registers): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	(gdbsim_store_register): Likewise.
	* rs6000-nat.c (fetch_register, store_register): Likewise.
	(rs6000_fetch_inferior_registers): Likewise.
	(rs6000_store_inferior_registers): Likewise.
	* s390-nat.c (fetch_regs, store_regs): Likewise.
	(fetch_fpregs, store_fpregs): Likewise.
	(s390_linux_fetch_inferior_registers): Likewise.
	(s390_linux_store_inferior_registers): Likewise.
	* shnbsd-nat.c (shnbsd_fetch_inferior_registers): Likewise.
	(shnbsd_store_inferior_registers): Likewise.
	* sol-thread.c (sol_thread_fetch_registers): Likewise.
	(sol_thread_store_registers): Likewise.
	* sparc-nat.c (fetch_inferior_registers): Likewise.
	(store_inferior_registers): Likewise.
	* spu-linux-nat.c (spu_fetch_inferior_registers): Likewise.
	(spu_store_inferior_registers): Likewise.
	* target.c (debug_print_register): Likewise.
	(debug_to_fetch_registers, debug_to_store_registers): Likewise.
	* vaxbsd-nat.c (vaxbsd_fetch_inferior_registers): Likewise.
	(vaxbsd_store_inferior_registers): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers): Likewise.
	(win32_fetch_inferior_registers): Likewise.
	(win32_store_inferior_registers): Likewise.
@
text
@d92 1
a92 1
static void remote_prepare_to_store (void);
d3733 1
a3733 1
remote_prepare_to_store (void)
d3747 1
a3747 1
	  regcache_raw_read (current_regcache, rsa->regs[i].regnum, buf);
@


1.247
log
@	* config/sh/tm-sh.h (DEPRECATED_BIG_REMOTE_BREAKPOINT,
	DEPRECATED_LITTLE_REMOTE_BREAKPOINT): Remove.
	* remote.c: Remove code under #ifdef DEPRECATED_REMOTE_BREAKPOINT,
	DEPRECATED_BIG_REMOTE_BREAKPOINT, DEPRECATED_LITTLE_REMOTE_BREAKPOINT.
	* sh-tdep.c (sh_breakpoint_from_pc): Return remote breakpoint
	sequence if target_shortname is "remote".

doc/ChangeLog:

	* gdbint.texinfo (Target Conditionals): Remove mention of
	DEPRECATED_REMOTE_BREAKPOINT, DEPRECATED_BIG_REMOTE_BREAKPOINT,
	and DEPRECATED_LITTLE_REMOTE_BREAKPOINT.
@
text
@d94 1
a94 1
static void remote_fetch_registers (int regno);
d111 1
a111 1
static void remote_store_registers (int regno);
d3489 1
a3489 1
fetch_register_using_p (struct packet_reg *reg)
d3524 1
a3524 1
      regcache_raw_supply (current_regcache, reg->regnum, NULL);
d3540 1
a3540 1
  regcache_raw_supply (current_regcache, reg->regnum, regp);
d3581 1
a3581 1
process_g_packet (void)
d3663 1
a3663 1
		regcache_raw_supply (current_regcache, r->regnum, NULL);
d3667 1
a3667 1
	      regcache_raw_supply (current_regcache, r->regnum,
d3675 1
a3675 1
fetch_registers_using_g (void)
d3678 1
a3678 1
  process_g_packet ();
d3682 1
a3682 1
remote_fetch_registers (int regnum)
d3701 1
a3701 1
	  fetch_registers_using_g ();
d3706 1
a3706 1
      if (fetch_register_using_p (reg))
d3710 1
a3710 1
      regcache_raw_supply (current_regcache, reg->regnum, NULL);
d3716 1
a3716 1
  fetch_registers_using_g ();
d3720 1
a3720 1
      if (!fetch_register_using_p (&rsa->regs[i]))
d3723 1
a3723 1
	  regcache_raw_supply (current_regcache, i, NULL);
d3758 1
a3758 1
store_register_using_P (struct packet_reg *reg)
d3775 1
a3775 1
  regcache_raw_collect (current_regcache, reg->regnum, regp);
d3797 1
a3797 1
store_registers_using_G (void)
d3814 1
a3814 1
	  regcache_raw_collect (current_regcache, r->regnum, regs + r->offset);
d3832 1
a3832 1
remote_store_registers (int regnum)
d3849 1
a3849 1
      if (store_register_using_P (reg))
d3859 1
a3859 1
      store_registers_using_G ();
d3863 1
a3863 1
  store_registers_using_G ();
d3867 1
a3867 1
      if (!store_register_using_P (&rsa->regs[i]))
@


1.247.2.1
log
@Daniel Jacobowitz' update to Michael Snyder's reverse debugging patches
@
text
@d2854 1
a2854 9
  if (target_get_execution_direction () == EXEC_REVERSE)
    {
      /* We don't pass signals to the target in reverse exec mode.  */
      if (info_verbose && siggnal != TARGET_SIGNAL_0)
	warning (" - Can't pass signal %d to target in reverse: ignored.\n",
		 siggnal);
      strcpy (buf, step ? "bs" : "bc");
    }
  else if (siggnal != TARGET_SIGNAL_0)
a3127 5
	  if (buf[1] == '0' && buf[2] == '6')
	    {
	      status->kind = TARGET_WAITKIND_NO_HISTORY;
	      goto got_status;
	    }
a6112 41
/* Reverse execution.
   FIXME: set up as a capability.  */
static enum exec_direction_kind remote_execdir = EXEC_FORWARD;

static enum exec_direction_kind remote_get_execdir (void)
{
  if (remote_debug && info_verbose)
    printf_filtered ("remote execdir is %s\n",
		     remote_execdir == EXEC_FORWARD ? "forward" :
		     remote_execdir == EXEC_REVERSE ? "reverse" :
		     "unknown");
  return remote_execdir;
}

static int remote_set_execdir (enum exec_direction_kind dir)
{
  if (remote_debug && info_verbose)
    printf_filtered ("Set remote execdir: %s\n",
		     dir == EXEC_FORWARD ? "forward" :
		     dir == EXEC_REVERSE ? "reverse" :
		     "bad direction");

  /* FIXME: check target for capability.  */
  if (dir == EXEC_FORWARD || dir == EXEC_REVERSE)
    return (remote_execdir = dir);
  else
    return EXEC_ERROR;
}

static void
remote_doing_call (int starting)
{
  struct remote_state *rs = get_remote_state ();

  if (starting)
    strcpy (rs->buf, "QStartCall");
  else
    strcpy (rs->buf, "QEndCall");
  remote_send (&rs->buf, &rs->buf_size);
}

a6159 2
  remote_ops.to_get_execdir = remote_get_execdir;
  remote_ops.to_set_execdir = remote_set_execdir;
a6164 1
  remote_ops.to_doing_call = remote_doing_call;
d6297 1
a6297 2
  remote_async_ops.to_read_description = remote_read_description;
  remote_async_ops.to_doing_call = remote_doing_call;
@


1.246
log
@	* remote.c (init_remote_state): Add special handling for placeholder
	registers.
@
text
@a5110 29
/* On some machines, e.g. 68k, we may use a different breakpoint
   instruction than other targets; in those use
   DEPRECATED_REMOTE_BREAKPOINT instead of just BREAKPOINT_FROM_PC.
   Also, bi-endian targets may define
   DEPRECATED_LITTLE_REMOTE_BREAKPOINT and
   DEPRECATED_BIG_REMOTE_BREAKPOINT.  If none of these are defined, we
   just call the standard routines that are in mem-break.c.  */

/* NOTE: cagney/2003-06-08: This is silly.  A remote and simulator
   target should use an identical BREAKPOINT_FROM_PC.  As for native,
   the ARCH-OS-tdep.c code can override the default.  */

#if defined (DEPRECATED_LITTLE_REMOTE_BREAKPOINT) && defined (DEPRECATED_BIG_REMOTE_BREAKPOINT) && !defined(DEPRECATED_REMOTE_BREAKPOINT)
#define DEPRECATED_REMOTE_BREAKPOINT
#endif

#ifdef DEPRECATED_REMOTE_BREAKPOINT

/* If the target isn't bi-endian, just pretend it is.  */
#if !defined (DEPRECATED_LITTLE_REMOTE_BREAKPOINT) && !defined (DEPRECATED_BIG_REMOTE_BREAKPOINT)
#define DEPRECATED_LITTLE_REMOTE_BREAKPOINT DEPRECATED_REMOTE_BREAKPOINT
#define DEPRECATED_BIG_REMOTE_BREAKPOINT DEPRECATED_REMOTE_BREAKPOINT
#endif

static unsigned char big_break_insn[] = DEPRECATED_BIG_REMOTE_BREAKPOINT;
static unsigned char little_break_insn[] = DEPRECATED_LITTLE_REMOTE_BREAKPOINT;

#endif /* DEPRECATED_REMOTE_BREAKPOINT */

a5119 3
#ifdef DEPRECATED_REMOTE_BREAKPOINT
  int val;
#endif
a5151 16
#ifdef DEPRECATED_REMOTE_BREAKPOINT
  bp_tgt->placed_size = bp_tgt->shadow_len = sizeof big_break_insn;
  val = target_read_memory (addr, bp_tgt->shadow_contents, bp_tgt->shadow_len);

  if (val == 0)
    {
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
	val = target_write_memory (addr, (char *) big_break_insn,
				   sizeof big_break_insn);
      else
	val = target_write_memory (addr, (char *) little_break_insn,
				   sizeof little_break_insn);
    }

  return val;
#else
a5152 1
#endif /* DEPRECATED_REMOTE_BREAKPOINT */
a5179 4
#ifdef DEPRECATED_REMOTE_BREAKPOINT
  return target_write_memory (bp_tgt->placed_address, bp_tgt->shadow_contents,
			      bp_tgt->shadow_len);
#else
a5180 1
#endif /* DEPRECATED_REMOTE_BREAKPOINT */
@


1.245
log
@	* Makefile.in (arm-tdep.o, eval.o, target-descriptions.o)
	(xml-tdesc.o): Update.
	* xml-support.c: Add a comment.
	(gdb_xml_enums_boolean): New variable.
	(gdb_xml_parse_attr_enum): Use strcasecmp.
	* xml-support.h (gdb_xml_enums_boolean): Declare.
	* xml-tdesc.c (struct tdesc_parsing_data): Record current_feature,
	next_regnum, and current_union.
	(tdesc_start_feature, tdesc_start_reg, tdesc_start_union)
	(tdesc_end_union, tdesc_start_field, tdesc_start_vector)
	(field_attributes, union_children, reg_attributes, union_attributes)
	(vector_attributes, feature_attributes, feature_children): New.
	(target_children): Make static.  Add <feature>.
	(tdesc_elements): Make static.
	* target-descriptions.c (struct tdesc_reg, tdesc_reg_p, type_p)
	(struct tdesc_feature, tdesc_feature_p): New types.
	(struct target_desc): Add features member.
	(struct tdesc_arch_data, tdesc_data): New.
	(target_find_description): Clarify error message.  Warn about
	ignored register descriptions.
	(tdesc_has_registers, tdesc_find_feature, tdesc_feature_name)
	(tdesc_named_type, tdesc_data_init, tdesc_data_alloc)
	(tdesc_data_cleanup, tdesc_numbered_register)
	(tdesc_numbered_register_choices, tdesc_find_register)
	(tdesc_register_name, tdesc_register_type)
	(tdesc_remote_register_number, tdesc_register_reggroup_p)
	(set_tdesc_pseudo_register_name, set_tdesc_pseudo_register_type)
	(set_tdesc_pseudo_register_reggroup_p, tdesc_use_registers)
	(tdesc_free_reg, tdesc_create_reg, tdesc_free_feature)
	(tdesc_create_feature, tdesc_record_type): New.
	(free_target_description): Free features.
	(_initialize_target_descriptions): Initialize tdesc_data.
	* arch-utils.c (default_remote_register_number): New.
	* arch-utils.h (default_remote_register_number): New prototype.
	* target-descriptions.h (set_tdesc_pseudo_register_name)
	(set_tdesc_pseudo_register_type, set_tdesc_pseudo_register_reggroup_p)
	(tdesc_use_registers, tdesc_data_alloc, tdesc_data_cleanup)
	(tdesc_numbered_register, tdesc_numbered_register_choices)
	(tdesc_has_registers, tdesc_find_feature, tdesc_feature_name)
	(tdesc_named_type, tdesc_create_feature, tdesc_record_type)
	(tdesc_create_reg): Declare.
	* gdbarch.sh (remote_register_number): New entry.
	* gdbarch.c, gdbarch.h: Regenerate.
	* remote.c (init_remote_state): Use gdbarch_remote_register_number.
	* features/gdb-target.dtd: Add feature, reg, vector, union, and field.

	* arm-tdep.c (arm_register_aliases): New.
	(arm_register_name_strings): Rename to...
	(arm_register_names): ...this.  Make const.  Delete the old version.
	(current_option, arm_register_byte): Delete.
	(set_disassembly_style): Simplify.  Do not adjust arm_register_names.
	(value_of_arm_user_reg): New.
	(arm_gdbarch_init): Verify any described registers.  Call
	tdesc_use_registers.  Don't use arm_register_byte.  Create aliases
	for standard register names.
	(_initialize_arm_tdep): Do not adjust arm_register_names.
	* user-regs.c (struct user_reg): Add baton member.
	(append_user_reg, user_reg_add_builtin, user_regs_init)
	(user_reg_add, value_of_user_reg): Use a baton for user
	register functions.
	* std-regs.c: Update.
	* user-regs.h (user_reg_read_ftype, user_reg_add_builtin)
	(user_reg_add): Add baton argument.
	* NEWS: Mention target description register support.
	* features/arm-core.xml, features/arm-fpa.xml: New.
	* eval.c (evaluate_subexp_standard): Allow ptype $register
	when the program is not running.

	* gdb.texinfo (-target-disconnect): Use @@smallexample.
	(Requirements): Add anchor for Expat.  Update description.
	(Target Descriptions): Mention Expat.
	(Target Description Format): Document new elements.  Use
	@@smallexample.
	(Predefined Target Types, Standard Target Features): New sections.
	* doc/gdbint.texinfo (Target Descriptions): New section.

	* gdb.xml/single-reg.xml, gdb.xml/tdesc-regs.exp,
	gdb.xml/core-only.xml, gdb.xml/extra-regs.xml: New files.
@
text
@d343 7
a349 1
      r->pnum = gdbarch_remote_register_number (gdbarch, regnum);
@


1.244
log
@XML feature description support.

	* NEWS: Mention target descriptions, "set tdesc filename",
	"unset tdesc filename", "show tdesc filename", and
	qXfer:features:read.
	* arch-utils.c (choose_architecture_for_target): New function.
	(gdbarch_info_fill): Call it.
	* target-descriptions.c (struct property): Make members non-const.
	(struct target_desc): Add arch member.
	(target_description_filename): New variable.
	(target_find_description): Try via XML first.
	(tdesc_architecture): New.
	(free_target_description, make_cleanup_free_target_description): New.
	(set_tdesc_property): Call xstrdup.
	(set_tdesc_architecture, tdesc_set_cmdlist, tdesc_show_cmdlist)
	(tdesc_unset_cmdlist, unset_tdesc_cmd, unset_tdesc_filename_cmd)
	(set_tdesc_cmd, show_tdesc_cmd, set_tdesc_filename_cmd)
	(show_tdesc_filename_cmd, _initialize_target_descriptions): New.
	* target-descriptions.h (tdesc_architecture)
	(make_cleanup_free_target_description, set_tdesc_architecture): New
	prototypes.
	* Makefile.in (SFILES): Add xml-tdesc.c.
	(COMMON_OBS): Add xml-tdesc.o.
	(target-descriptions.o): Update.
	(xml-tdesc.o): New rule.
	* xml-tdesc.c, xml-tdesc.h: New files.
	* remote.c (PACKET_qXfer_features): New enum.
	(remote_protocol_features): Add qXfer:features:read.
	(remote_xfer_partial): Handle TARGET_OBJECT_AVAILABLE_FEATURES.
	(_initialize_remote): Register qXfer:features:read.
	* target.h (enum target_object): Add TARGET_OBJECT_AVAILABLE_FEATURES.
	* features/gdb-target.dtd: New file.

	* linux-i386-low.c (the_low_target): Set arch_string.
	* linux-x86-64-low.c (the_low_target): Likewise.
	* linux-low.c (linux_arch_string): New.
	(linux_target_ops): Add it.
	* linux-low.h (struct linux_target_ops): Add arch_string.
	* server.c (write_qxfer_response): Use const void * for DATA.
	(get_features_xml): New.
	(handle_query): Handle qXfer:features:read.  Report it for qSupported.
	* target.h (struct target_ops): Add arch_string method.

	* gdb.texinfo (Target Descriptions): New section.
	(General Query Packets): Add QPassSignals anchor.  Mention
	qXfer:features:read under qSupported.  Expand mentions of
	qXfer:memory-map:read and QPassSignals.  Document
	qXfer:features:read.
@
text
@d337 2
a338 1
  /* Assume a 1:1 regnum<->pnum table.  */
d343 1
a343 1
      r->pnum = regnum;
@


1.243
log
@Copyright updates for 2007.
@
text
@d896 1
d2298 2
d5722 5
d6600 3
@


1.242
log
@	Warning fixes.
	* ada-lang.c (find_struct_field): Initialize *byte_offset_p.
	* breakpoint.c (do_enable_breakpoint): Ignore both mem_cnt and i.
	* c-typeprint.c (c_type_print_varspec_suffix): Don't test length
	greater than or equal to zero.
	* m2-typeprint.c (m2_array): Likewise.
	* p-typeprint.c (pascal_type_print_varspec_prefix): Likewise.
	* gdbtypes.c (copy_type_recursive): Correct == typo.
	* i386-tdep.c (i386_skip_prologue): Remove stray semicolon.
	* linux-nat.c (linux_nat_info_proc_cmd): Don't compare a pointer
	greater than zero.
	* macroscope.c (sal_macro_scope): Don't name a local variable "main".
	(default_macro_scope): Remove unused variable.
	* prologue-value.h (pv_area_find_reg): Don't name an argument
	"register".
	* remote-fileio.c (remote_fio_func_map): Add missing braces.
	* remote.c (sigint_remote_twice_token, sigint_remote_token): Change
	type.
	(cleanup_sigint_signal_handler): Remove casts.
	* valprint.c (val_print): Use a volatile local for the modified
	argument.
	* varobj.c (languages): Remove extra array dimension.
	(varobj_create): Correct access to languages array.
	* mi/mi-cmd-break.c (mi_cmd_break_insert, mi_cmd_break_watch): Add
	missing braces.
	* mi/mi-cmd-disas.c (mi_cmd_disassemble): Likewise.
	* mi/mi-cmd-env.c (mi_cmd_env_path, mi_cmd_env_dir): Likewise.
	* mi/mi-getopt.c (mi_valid_noargs): Likewise.
	* mi/mi-main.c (mi_cmd_data_read_memory): Likewise.
	(mi_cmd_data_write_memory): Likewise.
	* signals/signals.c (target_signal_to_string): Cast to int before
	comparing.
	* tui/tui-layout.c (init_and_make_win): Take and return a void *.
	Update all callers.
@
text
@d3 2
a4 2
   Copyright (C) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
@


1.241
log
@	* Makefile.in (mips-tdep.o, target-descriptions.o): Update.
	* target-descriptions.c (struct property): New.
	(struct target_desc): Add properties member.
	(tdesc_property, set_tdesc_property): New.
	* target-descriptions.h (tdesc_property, set_tdesc_property):
	Declare.
	* mips-tdep.c (PROPERTY_GP32, PROPERTY_GP64): New constants.
	(struct gdbarch_tdep): Add register_size_valid_p and register_size.
	(mips_isa_regsize): Use them.
	(mips_register_g_packet_guesses): New.
	(mips_gdbarch_init): Call it.  If a target description is supplied,
	check for internal properties.  Check for register size mismatches.
	* remote.c (send_g_packet, process_g_packet): New functions, split
	out from fetch_registers_using_g.
	(fetch_registers_using_g): Use them.
	(struct remote_g_packet_guess, remote_g_packet_guess_s)
	(struct remote_g_packet_data, remote_g_packet_data_handle)
	(remote_g_packet_data_init, register_remote_g_packet_guess)
	(remote_read_description): New.
	(init_remote_ops, init_remote_async_ops): Set to_read_description.
	(_initialize_remote): Register remote_g_packet_data_handle.
	* remote.h (register_remote_g_packet_guess): Declare.
@
text
@d999 2
a1000 2
static void *sigint_remote_twice_token;
static void *sigint_remote_token;
d2948 1
a2948 2
    delete_async_signal_handler ((struct async_signal_handler **)
				 &sigint_remote_twice_token);
d2950 1
a2950 2
    delete_async_signal_handler ((struct async_signal_handler **)
				 &sigint_remote_token);
@


1.240
log
@	* Makefile.in (SFILES): Add new and missed files.
	(target_descriptions_h): New.
	(COMMON_OBS): Add target-descriptions.o.
	(arch-utils.o, infcmd.o, remote.o, target.o): Update.
	(target-descriptions.o): New.
	* arch-utils.c (gdbarch_info_fill): Check for a target
	description.
	* target-descriptions.c, target-descriptions.h: New files.
	* gdbarch.sh: Add target_desc to info.  Declare it in gdbarch.h.
	Correct typos.
	(gdbarch_list_lookup_by_info): Check target_desc.
	* gdbarch.c, gdbarch.h: Regenerated.
	* target.c (update_current_target): Mention to_read_description.
	(target_pre_inferior): Call target_clear_description.
	(target_read_description): New.
	* target.h (struct target_ops): Add to_read_description.
	(target_read_description): New prototype.
	* infcmd.c (post_create_inferior): Call target_find_description.
	* remote.c (remote_open_1): Likewise.
	(extended_remote_create_inferior): Add a comment.
	(extended_remote_async_create_inferior): Likewise.
@
text
@d3538 2
a3539 2
static void
fetch_registers_using_g (void)
a3541 1
  struct remote_arch_state *rsa = get_remote_arch_state ();
d3549 14
d3568 16
a3619 14
  /* We can get out of synch in various cases.  If the first character
     in the buffer is not a hex character, assume that has happened
     and try to fetch another packet to read.  */
  while ((rs->buf[0] < '0' || rs->buf[0] > '9')
	 && (rs->buf[0] < 'A' || rs->buf[0] > 'F')
	 && (rs->buf[0] < 'a' || rs->buf[0] > 'f')
	 && rs->buf[0] != 'x')	/* New: unavailable register value.  */
    {
      if (remote_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "Bad register packet; fetching a new packet\n");
      getpkt (&rs->buf, &rs->buf_size, 0);
    }

d3667 7
d6077 77
d6205 1
d6338 1
d6430 2
@


1.239
log
@	* remote.c (struct remote_arch_state): Doc fix.
	(compare_pnums): New function.
	(init_remote_state): Only allocate packet_reg structures for raw
	registers.  Define the g/G packet format separately from creating
	packet_reg.  Don't use DEPRECATED_REGISTER_BYTE.
	(packet_reg_from_regnum, packet_reg_from_pnum): Only iterate over
	raw registers.
	(register_bytes_found): Delete.
	(fetch_register_using_p): Take a struct packet_reg.  Handle disabled
	'p' packet here.  Use packet_ok.
	(fetch_registers_using_g): New function, split out of
	remote_fetch_registers.  Check the 'g' packet more strictly.  Save
	its actual size and contents.  Eliminate BUF.  Only iterate over
	raw registers.
	(remote_fetch_registers): Use the new functions for 'p' and 'g'.
	Mark unavailable registers.
	(store_register_using_P): Likewise to fetch_register_using_p.
	(store_registers_using_G): New function, split out of
	remote_store_registers.  Only iterate over raw registers.  Don't
	use register_bytes_found.
	(remote_store_registers): Likewise to remote_fetch_registers.
@
text
@d48 1
d2505 4
d5031 8
d5064 8
@


1.238
log
@gdb/
	* remote.c (PACKET_QPassSignals): New.
	(last_pass_packet, remote_pass_signals): New.
	(remote_protocol_features): Add QPassSignals.
	(remote_query_supported): Correct an infinite loop.
	(remote_open_1): Reset last_pass_packet.
	(remote_resume): Call remote_pass_signals.
	(_initialize_remote): Register "set remote pass-signals".
gdb/doc/
	* gdb.texinfo (Remote configuration): Mention
	"pass-signals-packet".
	(General Query Packets): Document QPassSignals.  Fix
	a typo.
gdb/gdbserver/
	* linux-low.c (linux_wait_for_event): Reformat.  Use the
	pass_signals array.
	* remote-utils.c (decode_address_to_semicolon): New.
	* server.c (pass_signals, handle_general_set): New.
	(handle_query): Mention QPassSignals for qSupported.
	(main): Call handle_general_set.
	* server.h (pass_signals, decode_address_to_semicolon): New.
@
text
@d271 1
a271 1
     (making an array of NUM_REGS + NUM_PSEUDO_REGS in size).  */
d312 14
d329 1
a329 1
  int regnum;
d332 1
a335 2
  rsa->sizeof_g_packet = 0;

d337 2
a338 3
  rsa->regs = GDBARCH_OBSTACK_CALLOC (gdbarch, NUM_REGS + NUM_PSEUDO_REGS,
				      struct packet_reg);
  for (regnum = 0; regnum < NUM_REGS + NUM_PSEUDO_REGS; regnum++)
a342 7
      r->offset = DEPRECATED_REGISTER_BYTE (regnum);
      r->in_g_packet = (regnum < NUM_REGS);
      /* ...name = REGISTER_NAME (regnum); */

      /* Compute packet size by accumulating the size of all registers.  */
      if (regnum < NUM_REGS)
	rsa->sizeof_g_packet += register_size (current_gdbarch, regnum);
d345 23
d418 1
a418 1
  if (regnum < 0 && regnum >= NUM_REGS + NUM_PSEUDO_REGS)
d432 1
a432 1
  for (i = 0; i < NUM_REGS + NUM_PSEUDO_REGS; i++)
d3473 1
a3473 6
/* Number of bytes of registers this stub implements.  */

static int register_bytes_found;

/* Read the remote registers into the block REGS.  */
/* Currently we just read all the registers, so we don't use regnum.  */
d3476 1
a3476 1
fetch_register_using_p (int regnum)
d3483 6
d3491 1
a3491 1
  p += hexnumstr (p, regnum);
d3497 10
a3506 4
  /* If the stub didn't recognize the packet, or if we got an error,
     tell our caller.  */
  if (buf[0] == '\0' || buf[0] == 'E')
    return 0;
d3511 2
a3512 2
      regcache_raw_supply (current_regcache, regnum, NULL);
      set_register_cached (regnum, -1);
d3522 1
a3522 4
        {
          error (_("fetch_register_using_p: early buf termination"));
          return 0;
        }
d3527 1
a3527 1
  regcache_raw_supply (current_regcache, regnum, regp);
d3531 2
d3534 1
a3534 1
remote_fetch_registers (int regnum)
d3538 1
a3538 2
  char *buf;
  int i;
d3540 4
a3543 1
  char *regs = alloca (rsa->sizeof_g_packet);
d3545 15
a3559 1
  set_thread (PIDGET (inferior_ptid), 1);
d3561 5
a3565 1
  if (regnum >= 0)
d3567 3
a3569 8
      struct packet_reg *reg = packet_reg_from_regnum (rsa, regnum);
      gdb_assert (reg != NULL);
      if (!reg->in_g_packet)
	internal_error (__FILE__, __LINE__,
			_("Attempt to fetch a non G-packet register when this "
			"remote.c does not support the p-packet."));
    }
      switch (remote_protocol_packets[PACKET_p].support)
d3571 5
a3575 14
	case PACKET_DISABLE:
	  break;
	case PACKET_ENABLE:
	  if (fetch_register_using_p (regnum))
	    return;
	  else
	    error (_("Protocol error: p packet not recognized by stub"));
	case PACKET_SUPPORT_UNKNOWN:
	  if (fetch_register_using_p (regnum))
	    {
	      /* The stub recognized the 'p' packet.  Remember this.  */
	      remote_protocol_packets[PACKET_p].support = PACKET_ENABLE;
	      return;
	    }
d3577 1
a3577 7
	    {
	      /* The stub does not support the 'P' packet.  Use 'G'
	         instead, and don't try using 'P' in the future (it
	         will just waste our time).  */
	      remote_protocol_packets[PACKET_p].support = PACKET_DISABLE;
	      break;
	    }
d3579 1
d3581 1
a3581 9
  sprintf (rs->buf, "g");
  remote_send (&rs->buf, &rs->buf_size);
  buf = rs->buf;

  /* Save the size of the packet sent to us by the target.  Its used
     as a heuristic when determining the max size of packets that the
     target can safely receive.  */
  if ((rsa->actual_register_packet_size) == 0)
    (rsa->actual_register_packet_size) = strlen (buf);
d3589 4
a3592 4
  while ((buf[0] < '0' || buf[0] > '9')
	 && (buf[0] < 'A' || buf[0] > 'F')
	 && (buf[0] < 'a' || buf[0] > 'f')
	 && buf[0] != 'x')	/* New: unavailable register value.  */
a3597 1
      buf = rs->buf;
d3604 1
a3604 1
  p = buf;
d3607 5
a3611 9
      if (p[0] == 0)
	break;
      if (p[1] == 0)
	{
	  warning (_("Remote reply is of odd length: %s"), buf);
	  /* Don't change register_bytes_found in this case, and don't
	     print a second warning.  */
	  goto supply_them;
	}
a3618 9
  if (i != register_bytes_found)
    {
      register_bytes_found = i;
      if (REGISTER_BYTES_OK_P ()
	  && !REGISTER_BYTES_OK (i))
	warning (_("Remote reply is wrong length: %s"), buf);
    }

 supply_them:
d3621 1
a3621 1
    for (i = 0; i < NUM_REGS + NUM_PSEUDO_REGS; i++)
d3626 5
a3630 7
	    if (r->offset * 2 >= strlen (buf))
	      /* A short packet that didn't include the register's
                 value, this implies that the register is zero (and
                 not that the register is unavailable).  Supply that
                 zero value.  */
	      regcache_raw_supply (current_regcache, r->regnum, NULL);
	    else if (buf[r->offset * 2] == 'x')
d3632 1
a3632 1
		gdb_assert (r->offset * 2 < strlen (buf));
d3646 47
d3723 1
a3723 1
store_register_using_P (int regnum)
a3726 1
  struct packet_reg *reg = packet_reg_from_regnum (rsa, regnum);
d3732 6
d3744 12
a3755 1
  return rs->buf[0] != '\0';
a3757 1

d3762 1
a3762 1
remote_store_registers (int regnum)
a3768 31
  set_thread (PIDGET (inferior_ptid), 1);

  if (regnum >= 0)
    {
      switch (remote_protocol_packets[PACKET_P].support)
	{
	case PACKET_DISABLE:
	  break;
	case PACKET_ENABLE:
	  if (store_register_using_P (regnum))
	    return;
	  else
	    error (_("Protocol error: P packet not recognized by stub"));
	case PACKET_SUPPORT_UNKNOWN:
	  if (store_register_using_P (regnum))
	    {
	      /* The stub recognized the 'P' packet.  Remember this.  */
	      remote_protocol_packets[PACKET_P].support = PACKET_ENABLE;
	      return;
	    }
	  else
	    {
	      /* The stub does not support the 'P' packet.  Use 'G'
	         instead, and don't try using 'P' in the future (it
	         will just waste our time).  */
	      remote_protocol_packets[PACKET_P].support = PACKET_DISABLE;
	      break;
	    }
	}
    }

d3775 1
a3775 1
    for (i = 0; i < NUM_REGS + NUM_PSEUDO_REGS; i++)
d3787 3
a3789 2
  /* remote_prepare_to_store insures that register_bytes_found gets set.  */
  bin2hex (regs, p, register_bytes_found);
d3792 44
@


1.237
log
@gdb/
	* remote.c (set_remote_cmd): Call help_list.
	(show_remote_cmd): Skip legacy aliases.  Handle non-show_cmd
	entries.  Add missed cleanup.
	* cli/cli-setshow.c (cmd_show_list): Handle non-show_cmd entries.
gdb/doc/
	* gdb.texinfo (Remote configuration): Rewrite documentation for
	packet configuration commands.
	(OS Information): Adjust reference to qXfer:auxv:read.
	(General Query Packets): Remove references to read-aux-vector-packet
	and set remote get-thread-local-storage-address.
@
text
@d870 1
d1008 59
d2269 3
a2271 1
    PACKET_qXfer_memory_map }
d2325 3
a2332 3

	  *end = '\0';
	  next = end + 1;
d2419 4
d2797 3
d6353 3
@


1.236
log
@2006-10-21  Paul Brook  <paul@@codesourcery.com>

	* remote.c (remote_fetch_registers): Fix error message.
@
text
@d6085 1
d6092 1
a6092 1
     the redundant "show remote Z-packet".  */
d6100 5
a6104 1
    else if (list->type == show_cmd)
d6110 4
a6113 1
	do_setshow_command ((char *) NULL, from_tty, list);
d6117 3
@


1.235
log
@	* linux-thread-db.c (check_for_thread_db): Don't attempt to use
	thread_db for remote targets.
	* remote.c (remote_new_objfile): Always call predecessor on
	new_objfile event chain.
@
text
@d3533 1
a3533 1
	warning (_("Remote reply is too short: %s"), buf);
@


1.234
log
@	* inferior.h (start_remote): Update prototype.
	* infrun.c (start_remote): Take FROM_TTY.  Call
	post_create_inferior.
	* monitor.c (monitor_open): Update call to start_remote.
	* remote-sds.c (sds_start_remote, sds_open): Likewise.
	* remote.c (remote_start_remote): Likewise.
	(remote_start_remote_dummy): Removed.
	(remote_open): Update call to remote_start_remote.  Do not call
	post_create_inferior here.
@
text
@d6129 1
a6129 2
  if (remote_new_objfile_chain != 0 &&
      remote_desc == 0)
@


1.233
log
@	* remote.c (remote_pid_to_str): Capitalize "Thread".
@
text
@d1990 1
a1990 1
/* Stub for catch_errors.  */
d1992 2
a1993 2
static int
remote_start_remote_dummy (struct ui_out *uiout, void *dummy)
d1995 1
a1995 5
  start_remote ();		/* Initialize gdb process mechanisms.  */
  /* NOTE: Return something >=0.  A -ve value is reserved for
     catch_exceptions.  */
  return 1;
}
a1996 3
static void
remote_start_remote (struct ui_out *uiout, void *dummy)
{
d2012 1
a2012 1
  remote_start_remote_dummy (uiout, dummy);
d2454 2
a2455 1
      = catch_exception (uiout, remote_start_remote, NULL, RETURN_MASK_ALL);
a2474 2
  post_create_inferior (&current_target, from_tty);

@


1.232
log
@	PR remote/2158
	* remote.c (remote_write_bytes): Throttle packet alignment
	for small packets.
@
text
@d5837 1
a5837 1
  xsnprintf (buf, sizeof buf, "thread %d", ptid_get_pid (ptid));
@


1.231
log
@	* remote.c (get_remote_state_raw): Renamed from get_remote_state.
	(get_remote_state): New function.
	(init_remote_state, _initialize_remote): Use get_remote_state_raw.
@
text
@d4016 3
a4018 2
	 a second try to keep the end of the packet aligned.  */
      if (nr_bytes < todo)
@


1.230
log
@	* remote.c (remote_write_bytes_aux): Doc fix.
@
text
@d247 1
a247 1
get_remote_state (void)
d297 15
d316 1
a316 1
  struct remote_state *rs = get_remote_state ();
d6159 1
a6159 1
  rs = get_remote_state ();
@


1.229
log
@	* Makefile.in (SFILES): Add target-memory.c.
	(COMMON_OBS): Add target-memory.o.
	* memattr.c (lookup_mem_region): Adjust handling for
	the top of memory.  Improve comments.
	* remote.c (packet_check_result): New function, split out
	from packet_ok.  Recognize "E." as an error prefix.
	(packet_ok): Use it.
	(remote_write_bytes_aux): New function, renamed from
	remote_write_bytes.  Take packet header, packet format,
	and length flag as arguments.
	(remote_write_bytes): Rewrite to use remote_write_bytes_aux.
	(remote_send_printf, restore_remote_timeout)
	(remote_flash_timeout, remote_flash_erase, remote_flash_write)
	(remote_flash_done): New.
	(remote_xfer_partial): Handle flash writes.
	(init_remote_ops, init_remote_async_ops): Set to_flash_erase
	and to_flash_done.
	* symfile.c (struct load_section_data): Include a pointer to
	the cumulative stats and a request queue.  Move most members
	to other types.
	(struct load_progress_data, struct load_progress_section_data): New
	types.
	(load_progress): Handle a NULL baton and zero bytes.  Update for
	type changes.
	(load_section_callback): Create memory write requests instead of
	writing to memory.  Don't print the progress message here.
	(clear_memory_write_data): New function.
	(generic_load): Use target_write_memory_blocks.
	* target-memory.c: New file.
	* target.c (update_current_target): Mention new uninherited methods.
	(memory_xfer_partial): Issue an error for flash writes.
	(target_flash_erase, target_flash_done): New functions.
	(target_write_with_progress): Call the progress callback at the
	start also.
	* target.h (enum target_object): Add TARGET_OBJECT_FLASH.
	(target_write_with_progress): Update comment.
	(struct target_ops): Add to_flash_erase and to_flash_done.
	(target_flash_erase, target_flash_done, struct memory_write_request)
	(memory_write_request_s, enum flash_preserve_mode)
	(target_write_memory_blocks): New, including a vector type
	for memory_write_request_s.
@
text
@a3891 2

   Returns number of bytes transferred, or 0 (setting errno) for
@


1.228
log
@gdb/
2006-09-21  Vladimir Prus  <vladimir@@codesourcery.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>
	    Nathan Sidwell  <nathan@@codesourcery.com>

	* Makefile.in (SFILES): Add memory-map.c and xml-support.c.
	(memory_map_h, xml_support_h): New.
	(target_h): Add vec_h dependency.
	(COMMON_OBS): Add memory-map.o and xml-support.o.
	(memory-map.o, xml-support.o): New rules.
	(remote.o): Update.
	* exceptions.h (enum errors): Add XML_PARSE_ERROR.
	* infcmd.c (run_command_1, attach_command): Call target_pre_inferior.
	* memattr.c (default_mem_attrib): Initialize blocksize.
	(target_mem_region_list, mem_use_target)
	(target_mem_regions_valid, mem_region_cmp, mem_region_init)
	(require_user_regions, require_target_regions)
	(invalidate_target_mem_regions): New.
	(create_mem_region): Use mem_region_init.
	(mem_clear): Move higher.
	(lookup_mem_region): Use require_target_regions.
	(mem_command): Implement "mem auto".
	(mem_info_command): Handle target-supplied regions and flash
	attributes.
	(mem_enable_command, mem_disable_command, mem_delete_command): Use
	require_user_regions.
	(_initialize_mem): Mention "mem auto" in help.
	* memattr.h (enum mem_access_mode): Add MEM_FLASH.
	(struct mem_attrib): Add blocksize.
	(invalidate_target_mem_regions, mem_region_init, mem_region_cmp): New
	prototypes.
	* remote.c: Include "memory-map.h".
	(PACKET_qXfer_memory_map): New enum value.
	(remote_protocol_features): Add qXfer:memory-map:read.
	(remote_xfer_partial): Handle memory maps.
	(remote_memory_map): New.
	(init_remote_ops, init_remote_async_ops): Set to_memory_map.
	(_initialize_remote): Register qXfer:memory-map:read.
	* target.c (update_current_target): Mention to_memory_map.
	(target_memory_map, target_pre_inferior): New.
	(target_preopen): Call target_pre_inferior.
	* target.h: Include "vec.h".
	(enum target_object): Add TARGET_OBJECT_MEMORY_MAP.
	(struct target_ops): Add to_memory_map.
	(target_memory_map, target_pre_inferior): New prototypes.
	* memory-map.c, memory-map.h, xml-support.c, xml-support.h: New files.
gdb/doc/
2006-09-21  Vladimir Prus  <vladimir@@codesourcery.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdb.texinfo (Memory Region Attributes): Mention target-supplied
	memory regions and "mem auto".
@
text
@d756 1
a756 1
packet_ok (const char *buf, struct packet_config *config)
d762 30
d808 2
a809 13
      if (buf[0] == 'O' && buf[1] == 'K' && buf[2] == '\0')
	/* "OK" - definitly OK.  */
	return PACKET_OK;
      if (buf[0] == 'E'
	  && isxdigit (buf[1]) && isxdigit (buf[2])
	  && buf[3] == '\0')
	/* "Enn"  - definitly an error.  */
	return PACKET_ERROR;
      /* The packet may or may not be OK.  Just assume it is.  */
      return PACKET_OK;
    }
  else
    {
d834 1
a834 1
      return PACKET_UNKNOWN;
d836 2
d3876 1
d3880 12
d3896 4
a3899 2
int
remote_write_bytes (CORE_ADDR memaddr, const gdb_byte *myaddr, int len)
d3903 2
a3904 2
  char *plen;
  int plenlen;
d3909 5
a3923 3
  /* Verify that the target can support a binary download.  */
  check_binary_download (memaddr);

d3928 1
d3933 6
a3938 1
  payload_size -= strlen ("$M,:#NN");
d3941 4
a3944 1
  /* Construct the packet header: "[MX]<memaddr>,<len>:".   */
d3946 2
a3947 4
  /* Append "[XM]".  Compute a best guess of the number of bytes
     actually transfered.  */
  p = rs->buf;
  switch (remote_protocol_packets[PACKET_X].support)
a3948 2
    case PACKET_ENABLE:
      *p++ = 'X';
d3951 2
a3952 1
      payload_size -= hexnumlen (todo);
d3954 3
a3956 3
      break;
    case PACKET_DISABLE:
      *p++ = 'M';
d3959 2
a3960 1
      payload_size -= hexnumlen (todo);
a3961 6
      break;
    case PACKET_SUPPORT_UNKNOWN:
      internal_error (__FILE__, __LINE__,
		      _("remote_write_bytes: bad internal state"));
    default:
      internal_error (__FILE__, __LINE__, _("bad switch"));
d3963 1
d3977 4
a3980 2
  /* Append ",".  */
  *p++ = ',';
d3982 6
a3987 5
  /* Append <len>.  Retain the location/size of <len>.  It may need to
     be adjusted once the packet body has been created.  */
  plen = p;
  plenlen = hexnumstr (p, (ULONGEST) todo);
  p += plenlen;
d3994 1
a3994 1
  switch (remote_protocol_packets[PACKET_X].support)
a3995 1
    case PACKET_ENABLE:
d4017 1
a4017 1
      if (nr_bytes < todo)
d4026 3
a4028 2
      break;
    case PACKET_DISABLE:
a4033 6
      break;
    case PACKET_SUPPORT_UNKNOWN:
      internal_error (__FILE__, __LINE__,
		      _("remote_write_bytes: bad internal state"));
    default:
      internal_error (__FILE__, __LINE__, _("bad switch"));
d4054 36
d4197 105
d5481 21
a5501 3
  /* Only handle reads.  */
  if (writebuf != NULL || readbuf == NULL)
    return -1;
d5921 2
d6053 2
@


1.227
log
@	PR remote/2154
	* remote.c (remote_thread_alive): Remove local buf.
	(remote_get_threadinfo): Remove local threadinfo_pkt.
	(remote_get_threadlist): Remove unused threadlist_packet.
	(remote_current_thread): Remove local buf.
	(remote_threads_info): Set bufp after getpkt.
	(remote_threads_extra_info): Remove local bufp.
	(get_offsets): Set buf after getpkt.
	(remote_check_symbols): Set reply after getpkt.
	(remote_vcont_probe): Set buf after getpkt.
	(remote_resume): Set buf after set_thread.
	(remote_wait, remote_async_wait): Set buf after getpkt.
	(fetch_register_using_p): Set buf after remote_send.
	(remote_fetch_registers): Likewise.
	(store_register_using_P): Don't use buf after remote_send.
	(check_binary_download, remote_write_bytes)
	(remote_read_bytes, remote_rcmd): Remove local buf.
@
text
@d63 2
d831 1
d2178 3
a2180 1
    PACKET_qXfer_auxv }
d5320 5
d5435 17
d5724 1
d5854 1
d6095 3
@


1.226
log
@	* remote.c, target.c: Strip trailing whitespace.
@
text
@a1005 1
  char *buf = rs->buf;
d1008 1
a1008 1
    xsnprintf (buf, get_remote_packet_size (), "T-%08x", -tid);
d1010 2
a1011 2
    xsnprintf (buf, get_remote_packet_size (), "T%08x", tid);
  putpkt (buf);
d1013 1
a1013 1
  return (buf[0] == 'O' && buf[1] == 'K');
a1511 1
  char *threadinfo_pkt = rs->buf;
d1513 2
a1514 2
  pack_threadinfo_request (threadinfo_pkt, fieldset, threadid);
  putpkt (threadinfo_pkt);
d1516 1
a1516 1
  result = remote_unpack_thread_info_response (threadinfo_pkt + 2,
a1571 1
  char *threadlist_packet = rs->buf;
a1687 1
  char *buf = rs->buf;
d1691 1
a1691 1
  if (buf[0] == 'Q' && buf[1] == 'C')
d1697 1
a1697 1
    return pid_to_ptid (strtoul (&buf[2], NULL, 16));
d1735 1
a1736 1
      getpkt (&rs->buf, &rs->buf_size, 0);
d1755 1
a1756 1
	      getpkt (&rs->buf, &rs->buf_size, 0);
d1794 1
a1794 3
      char *bufp = rs->buf;

      xsnprintf (bufp, get_remote_packet_size (), "qThreadExtraInfo,%x",
d1796 1
a1796 1
      putpkt (bufp);
d1798 1
a1798 1
      if (bufp[0] != 0)
d1800 2
a1801 2
	  n = min (strlen (bufp) / 2, sizeof (display_buf));
	  result = hex2bin (bufp, (gdb_byte *) display_buf, n);
d1873 1
a1873 1
  char *buf = rs->buf;
d1881 1
a2043 2
  reply = rs->buf;

d2049 1
d2065 1
d2557 1
a2557 1
  char *buf = rs->buf;
d2559 2
a2560 2
  strcpy (buf, "vCont?");
  putpkt (buf);
d2562 1
d2687 1
a2687 1
  char *buf = rs->buf;
d2708 1
a2958 1
  char *buf = rs->buf;
d2967 1
a2967 1
      char *p;
d2973 2
a3149 1
  char *buf = rs->buf;
d3160 1
a3160 1
      char *p;
d3172 2
d3354 1
a3354 1
  char *buf = rs->buf, *p;
d3358 1
a3358 1
  p = buf;
d3364 2
d3402 1
a3402 1
  char *buf = rs->buf;
d3444 1
a3444 1
  sprintf (buf, "g");
d3446 1
d3469 1
d3579 1
a3579 1
  return buf[0] != '\0';
a3815 1
	char *buf = rs->buf;
d3818 1
a3818 1
	p = buf;
d3826 1
a3826 1
	putpkt_binary (buf, (int) (p - buf));
d3829 1
a3829 1
	if (buf[0] == '\0')
a3860 1
  char *buf;
a3884 1
  buf = rs->buf;
d3896 1
a3896 1
  p = buf;
d3994 1
a3994 1
  putpkt_binary (buf, (int) (p - buf));
d3997 1
a3997 1
  if (buf[0] == 'E')
a4030 1
  char *buf;
a4045 1
  buf = rs->buf;
d4057 1
a4057 1
      /* sprintf (buf, "m%lx,%x", (unsigned long) memaddr, todo); */
d4059 1
a4059 1
      p = buf;
d4066 1
a4066 1
      putpkt (buf);
d4069 3
a4071 3
      if (buf[0] == 'E'
	  && isxdigit (buf[1]) && isxdigit (buf[2])
	  && buf[3] == '\0')
d4085 1
a4085 1
      p = buf;
d5371 1
a5371 2
  char *buf = rs->buf;
  char *p = buf;
d5381 2
a5382 2
  strcpy (buf, "qRcmd,");
  p = strchr (buf, '\0');
d5384 1
a5384 1
  if ((strlen (buf) + strlen (command) * 2 + 8/*misc*/) > get_remote_packet_size ())
d5396 2
d5399 1
a5399 1
      buf[0] = '\0';
d5401 1
@


1.225
log
@	* remote.c (remote_write_bytes): Take a const buffer argument.
	Do the checks from remote_xfer_memory.
	(remote_read_bytes): Do the checks from remote_xfer_memory.
	(remote_xfer_memory): Remove checks pushed into lower level
	functions.
	(remote_xfer_partial): Call remote_write_bytes and remote_read_bytes
	directly.
	* remote.h (remote_write_bytes): Update prototype.
@
text
@d258 1
a258 1
  /* long size in bytes;  == register_size (current_gdbarch, regnum); 
d1044 1
a1044 1
    int active;			/* Has state interesting to GDB? 
d1046 1
a1046 1
    char display[256];		/* Brief state display, name, 
d1049 1
a1049 1
    char more_display[256];	/* Long info, statistics, queue depth, 
d1095 1
a1095 1
static char *pack_threadinfo_request (char *pkt, int mode, 
d1104 1
a1104 1
static int remote_get_threadinfo (threadref *threadid, 
d1115 1
a1115 1
				      threadref *resultlist, 
d1122 1
a1122 1
				  int *result_count, 
d1822 1
a1822 1
	  n += xsnprintf (&display_buf[0], sizeof (display_buf) - n, 
d1825 1
a1825 1
	  n += xsnprintf (&display_buf[n], sizeof (display_buf) - n, 
d1828 1
a1828 1
	  n += xsnprintf (&display_buf[n], sizeof (display_buf) - n, 
d1856 1
a1856 1
  
d2816 1
a2816 1
    delete_async_signal_handler ((struct async_signal_handler **) 
d2819 1
a2819 1
    delete_async_signal_handler ((struct async_signal_handler **) 
d3072 1
a3072 1
					 register_size (current_gdbarch, 
d3075 1
a3075 1
		    if (fieldsize < register_size (current_gdbarch, 
d3078 1
a3078 1
		    regcache_raw_supply (current_regcache, 
d3083 1
a3083 1
		  error (_("Remote register badly formatted: %s\nhere: %s"), 
d3268 1
a3268 1
					 register_size (current_gdbarch, 
d3271 1
a3271 1
		    if (fieldsize < register_size (current_gdbarch, 
d3881 1
a3881 1
  
d4277 1
a4277 1
		  fprintf_unfiltered (gdb_stdlog, 
d4403 1
a4403 1
		  fputs_filtered ("Timeout in checksum, retrying\n", 
d4410 1
a4410 1
		  fputs_filtered ("Communication error in checksum\n", 
d4577 1
a4577 1
  /* We have tried hard enough, and just can't receive the packet.  
d4992 1
a4992 1
  
d5736 1
a5736 1
static void (*async_client_callback) (enum inferior_event_type event_type, 
d5750 1
a5750 1
remote_async (void (*callback) (enum inferior_event_type event_type, 
d5777 1
a5777 1
  remote_async_ops.to_longname = 
d5905 1
a5905 1
  remote_gdbarch_data_handle = 
@


1.224
log
@	* remote.c (remote_protocol_features): Correct qPart to qXfer.
@
text
@d3856 1
a3856 1
remote_write_bytes (CORE_ADDR memaddr, gdb_byte *myaddr, int len)
d3868 9
d4035 9
a4110 2
  CORE_ADDR targ_addr;
  int targ_len;
a4112 8
  /* Should this be the selected frame?  */
  gdbarch_remote_translate_xfer_address (current_gdbarch, 
					 current_regcache,
					 mem_addr, mem_len,
					 &targ_addr, &targ_len);
  if (targ_len <= 0)
    return 0;

d4114 1
a4114 1
    res = remote_write_bytes (targ_addr, buffer, targ_len);
d4116 1
a4116 1
    res = remote_read_bytes (targ_addr, buffer, targ_len);
d5281 1
a5281 1
  /* Handle memory using remote_xfer_memory.  */
d5288 1
a5288 7
	{
	  void *buffer = xmalloc (len);
	  struct cleanup *cleanup = make_cleanup (xfree, buffer);
	  memcpy (buffer, writebuf, len);
	  xfered = remote_xfer_memory (offset, buffer, len, 1, NULL, ops);
	  do_cleanups (cleanup);
	}
d5290 1
a5290 1
	xfered = remote_xfer_memory (offset, readbuf, len, 0, NULL, ops);
@


1.223
log
@	* remote.c (unpack_varlen_hex): Correct type of retval.
	Reported by Zhigang Gong <zhigang.gong@@gmail.com>.
@
text
@d2179 1
a2179 1
  { "qPart:auxv:read", PACKET_DISABLE, remote_supported_packet,
@


1.222
log
@	* remote.c (REMOTE_ALIGN_WRITES): New.
	(remote_write_bytes): Align large write packets.  Remove unused
	payload_start variable.
@
text
@d1191 1
a1191 1
  int retval = 0;
@


1.221
log
@gdb/
	* remote.c (PACKET_qXfer_auxv): New, renamed from PACKET_qPart_auxv.
	(remote_supported_packet): Remove #if 0.
	(remote_protocol_features): Add qPart:auxv:read.
	(remote_unescape_input): New function.
	(readchar): Don't mask off the high bit.
	(read_frame): Use fputstrn_filtered for packet data.
	(getpkt_sane): Return the number of bytes read or -1.  Use
	fputstrn_unfiltered.
	(remote_read_qxfer): New.
	(remote_xfer_partial): Use it for TARGET_OBJECT_AUXV.
	(_initialize_remote): Update packet registration.
	* defs.h (fputstrn_filtered): New prototype.
	* utils.c (fputstrn_filtered): New.
	* NEWS: Mention qXfer.
gdb/doc/
	* gdb.texinfo (OS Information): Update qPart reference to
	qXfer.
	(Remote configuration): Likewise.
	(Overview): Move @@cindex to the start of a paragraph.  Talk
	about binary data encoding.
	(Packets): Refer to the overview for the details of the X
	packet encoding.
	(General Query Packets): Remove qPart description.  Add qXfer
	description.  Add an anchor to qSupported.  Correct feature
	table title.  Add a new feature for qXfer:auxv:read.
	(Interrupts): Add a missing parenthesis.
gdb/gdbserver/
	* server.c (decode_xfer_read, write_qxfer_response): New.
	(handle_query): Take a packet length argument.  Handle
	qXfer:auxv:read instead of qPart:auxv:read.  Mention it in
	the qSupported response.
	(main): Update call to handle_query.
@
text
@d63 12
d3866 1
a3866 1
  char *payload_start;
d3914 5
a3936 1
  payload_start = p;
d3943 18
a3960 1
      p += remote_escape_output (myaddr, todo, p, &nr_bytes, payload_size);
@


1.220
log
@	* target.c (target_read): Stop if target_read_partial returns 0
	when some bytes have already been read.
	(target_write): Likewise for target_write_partial.
	(target_read_partial, target_write_partial): Make static.
	(target_read_alloc): New.
	* target.h: Doc fixes.
	(target_read_partial, target_write_partial): Delete prototypes.
	(target_read_alloc): New prototype.

	* auxv.c (target_auxv_read): Delete.
	(target_auxv_search, fprint_target_auxv): Use target_read_alloc.
	* auxv.h (target_auxv_read): Delete prototype.
	* avr-tdep.c (avr_io_reg_read_command): Use target_read_alloc.
	* ia64-tdep.c (getunwind_table, get_kernel_table): Likewise.
	* linux-nat.c (linux_nat_make_corefile_notes): Likewise.
	* procfs.c (procfs_make_note_section): Likewise.
	* remote.c (remote_xfer_partial): Don't loop here.
	* sparc-tdep.c (sparc_fetch_wcookie): Use target_read.
@
text
@d816 1
a816 1
  PACKET_qPart_auxv,
a2108 1
#if 0
a2124 1
#endif
d2166 3
a2168 1
  { "PacketSize", PACKET_DISABLE, remote_packet_size, -1 }
d3731 46
d4089 1
a4089 2
/* Read a single character from the remote end, masking it down to 7
   bits.  */
d4099 1
a4099 1
    return (ch & 0x7f);
d4383 1
a4383 1
		fputs_filtered (buf, gdb_stdlog);
d4462 2
a4463 1
   indication of this to the caller.  */
d4524 1
a4524 1
	      fputstr_unfiltered (*buf, 0, gdb_stdlog);
d4528 1
a4528 1
	  return 0;
d4541 1
a4541 1
  return 1;
d5146 84
d5278 3
a5280 21
      if (remote_protocol_packets[PACKET_qPart_auxv].support != PACKET_DISABLE)
	{
	  LONGEST n = min ((get_remote_packet_size () - 2) / 2, len);
	  snprintf (rs->buf, get_remote_packet_size (),
		    "qPart:auxv:read::%s,%s",
		    phex_nz (offset, sizeof offset),
		    phex_nz (n, sizeof n));
	  i = putpkt (rs->buf);
	  if (i < 0)
	    return i;
	  rs->buf[0] = '\0';
	  getpkt (&rs->buf, &rs->buf_size, 0);
	  if (packet_ok (rs->buf, &remote_protocol_packets[PACKET_qPart_auxv])
	      != PACKET_OK)
	    return -1;
	  if (strcmp (rs->buf, "OK") == 0)
	    return 0;		/* Got EOF indicator.  */
	  /* Got some data.  */
	  return hex2bin (rs->buf, readbuf, len);
	}
      return -1;
d6028 2
a6029 2
  add_packet_config_cmd (&remote_protocol_packets[PACKET_qPart_auxv],
			 "qPart:auxv", "read-aux-vector", 0);
@


1.219
log
@gdb/
	* remote.c (remote_xfer_partial): Remove KOD support.
	* target.h (enum target_object): Remove TARGET_OBJECT_KOD.
	* MAINTAINERS: Move Kernel Object Display entry to past maintainers.
	* Makefile.in (SFILES, kod_h, COMMON_OBS, kod.o, kod-cisco.o): Remove KOD
	support.
	* mi/mi-cmds.c (mi_cmds): Remove dummy KOD commands.
	* NEWS: Mention KOD.
	* kod.h, kod.c, kod-cisco.c: Delete files.
gdb/doc/
	* doc/gdb.texinfo (KOD): Remove node.
	(GDB/MI Kod Commands): Remove commented out node.
@
text
@d5150 17
a5166 29
	  unsigned int total = 0;
	  while (len > 0)
	    {
	      LONGEST n = min ((get_remote_packet_size () - 2) / 2, len);
	      snprintf (rs->buf, get_remote_packet_size (),
			"qPart:auxv:read::%s,%s",
			phex_nz (offset, sizeof offset),
			phex_nz (n, sizeof n));
	      i = putpkt (rs->buf);
	      if (i < 0)
		return total > 0 ? total : i;
	      rs->buf[0] = '\0';
	      getpkt (&rs->buf, &rs->buf_size, 0);
	      if (packet_ok (rs->buf, &remote_protocol_packets[PACKET_qPart_auxv])
		  != PACKET_OK)
		return total > 0 ? total : -1;
	      if (strcmp (rs->buf, "OK") == 0)
		break;		/* Got EOF indicator.  */
	      /* Got some data.  */
	      i = hex2bin (rs->buf, readbuf, len);
	      if (i > 0)
		{
		  readbuf = (void *) ((char *) readbuf + i);
		  offset += i;
		  len -= i;
		  total += i;
		}
	    }
	  return total;
@


1.218
log
@	* remote.c (init_remote_state): Use xrealloc instead of xmalloc.
@
text
@a5142 3
    case TARGET_OBJECT_KOD:
      query_type = 'K';
      break;
@


1.217
log
@	* remote.c (remote_escape_output): New function.
	(remote_write_bytes): Use remote_escape_output.
@
text
@d337 1
a337 1
      rs->buf = xmalloc (rs->buf_size);
@


1.216
log
@gdb/
	* NEWS: Mention qSupported.
	* remote.c (struct remote_state): Add explicit_packet_size.
	(get_remote_packet_size): Check explicit_packet_size.
	(get_memory_packet_size): Likewise.
	(PACKET_qSupported): New enum value.
	(struct protocol_feature, remote_supported_packet)
	(remote_packet_size, remote_protocol_features)
	(remote_query_supported): New.
	(remote_open_1): Reset explicit_packet_size.  Call
	remote_query_supported.
	(_initialize_remote): Register qSupported.
gdb/doc/
	* gdb.texinfo (Remote configuration): Document set / show
	remote supported-packets.
	(General Query Packets): Document qSupported packet.
gdb/gdbserver/
	* server.c (handle_query): Handle qSupported.
@
text
@d3692 39
d3881 1
a3881 18
      for (nr_bytes = 0;
	   (nr_bytes < todo) && (p - payload_start) < payload_size;
	   nr_bytes++)
	{
	  switch (myaddr[nr_bytes] & 0xff)
	    {
	    case '$':
	    case '#':
	    case 0x7d:
	      /* These must be escaped.  */
	      *p++ = 0x7d;
	      *p++ = (myaddr[nr_bytes] & 0xff) ^ 0x20;
	      break;
	    default:
	      *p++ = myaddr[nr_bytes] & 0xff;
	      break;
	    }
	}
@


1.215
log
@	* remote.c (set_remote_protocol_packet_cmd)
	(show_remote_protocol_packet_cmd): New prototypes.
	(remote_set_cmdlist, remote_show_cmdlist): Move higher.
	(struct packet_config): Make name and title const.
	(add_packet_config_cmd): Remove unnecessary arguments.
	(_initialize_remote): Update calls.
@
text
@d218 6
d349 1
d352 3
d497 7
a503 4
      /* Limit it to the size of the targets ``g'' response.  */
      if ((rsa->actual_register_packet_size) > 0
	  && what_they_get > (rsa->actual_register_packet_size))
	what_they_get = (rsa->actual_register_packet_size);
d818 1
d2082 216
d2352 2
d2355 1
d2364 5
d5916 3
@


1.214
log
@	* remote-fileio.c (remote_fileio_reset): New.
	* remote-fileio.h (remote_fileio_reset): Prototype.
	* remote.c (extended_remote_restart, remote_open_1): Call it.
@
text
@d189 8
d199 5
d630 2
a631 2
    char *name;
    char *title;
d694 2
a695 8
add_packet_config_cmd (struct packet_config *config,
		       char *name,
		       char *title,
		       cmd_sfunc_ftype *set_func,
		       show_value_ftype *show_func,
		       struct cmd_list_element **set_remote_list,
		       struct cmd_list_element **show_remote_list,
		       int legacy)
d713 3
a715 2
				set_func, show_func,
				set_remote_list, show_remote_list);
d722 1
a722 1
		     set_remote_list);
d724 1
a724 1
		     show_remote_list);
a5454 3
static struct cmd_list_element *remote_set_cmdlist;
static struct cmd_list_element *remote_show_cmdlist;

d5642 1
a5642 5
			 "X", "binary-download",
			 set_remote_protocol_packet_cmd,
			 show_remote_protocol_packet_cmd,
			 &remote_set_cmdlist, &remote_show_cmdlist,
			 1);
d5645 1
a5645 5
			 "vCont", "verbose-resume",
			 set_remote_protocol_packet_cmd,
			 show_remote_protocol_packet_cmd,
			 &remote_set_cmdlist, &remote_show_cmdlist,
			 0);
d5648 1
a5648 5
			 "qSymbol", "symbol-lookup",
			 set_remote_protocol_packet_cmd,
			 show_remote_protocol_packet_cmd,
			 &remote_set_cmdlist, &remote_show_cmdlist,
			 0);
d5651 1
a5651 5
			 "P", "set-register",
			 set_remote_protocol_packet_cmd,
			 show_remote_protocol_packet_cmd,
			 &remote_set_cmdlist, &remote_show_cmdlist,
			 1);
d5654 1
a5654 5
			 "p", "fetch-register",
			 set_remote_protocol_packet_cmd,
			 show_remote_protocol_packet_cmd,
			 &remote_set_cmdlist, &remote_show_cmdlist,
			 1);
d5657 1
a5657 5
			 "Z0", "software-breakpoint",
			 set_remote_protocol_packet_cmd,
			 show_remote_protocol_packet_cmd,
			 &remote_set_cmdlist, &remote_show_cmdlist,
			 0);
d5660 1
a5660 5
			 "Z1", "hardware-breakpoint",
			 set_remote_protocol_packet_cmd,
			 show_remote_protocol_packet_cmd,
			 &remote_set_cmdlist, &remote_show_cmdlist,
			 0);
d5663 1
a5663 5
			 "Z2", "write-watchpoint",
			 set_remote_protocol_packet_cmd,
			 show_remote_protocol_packet_cmd,
			 &remote_set_cmdlist, &remote_show_cmdlist,
			 0);
d5666 1
a5666 5
			 "Z3", "read-watchpoint",
			 set_remote_protocol_packet_cmd,
			 show_remote_protocol_packet_cmd,
			 &remote_set_cmdlist, &remote_show_cmdlist,
			 0);
d5669 1
a5669 5
			 "Z4", "access-watchpoint",
			 set_remote_protocol_packet_cmd,
			 show_remote_protocol_packet_cmd,
			 &remote_set_cmdlist, &remote_show_cmdlist,
			 0);
d5672 1
a5672 5
			 "qPart_auxv", "read-aux-vector",
			 set_remote_protocol_packet_cmd,
			 show_remote_protocol_packet_cmd,
			 &remote_set_cmdlist, &remote_show_cmdlist,
			 0);
a5675 3
			 set_remote_protocol_packet_cmd,
			 show_remote_protocol_packet_cmd,
			 &remote_set_cmdlist, &remote_show_cmdlist,
@


1.213
log
@	* gdb/remote.c (remote_open_1): Do preopen tasks before
	irreversably destroying state.
@
text
@d1821 2
d2078 1
@


1.212
log
@	* (struct remote_state): New type, only containing
	buf and buf_size.
	(remote_state): New variable.
	(get_remote_state): New function.
	(struct remote_arch_state): Renamed from struct remote_state.
	Removed buf and buf_size.
	(get_remote_arch_state): Renamed from get_remote_state.  All
	necessary callers updated to call this function.
	(init_remote_state): Initialize the architecture-specific state.
	Update the target-specific state if necessary.
	(get_remote_packet_size): New function.  All previous references
	changed to use this accessor function.
	(packet_reg_from_regnum, packet_reg_from_pnum): Take a
	remote_arch_state instead of a remote_state.  All callers changed.
	(_initialize_remote): Initialize the packet buffer here.
@
text
@a2071 3
  reopen_exec_file ();
  reread_symbols ();

d2076 3
@


1.211
log
@	* gdb/remote.c (remote_insert_watchpoint): Return -1, rather than
	fatal error if packet is disabled.
	(remote_remove_watchpoint, remote_insert_hw_breakpoint,
	remote_remove_hw_breakpoint): Likewise.
@
text
@d191 29
a219 6
/* Description of the remote protocol.  Strictly speaking, when the
   target is open()ed, remote.c should create a per-target description
   of the remote protocol using that target's architecture.
   Unfortunately, the target stack doesn't include local state.  For
   the moment keep the information in the target's architecture
   object.  Sigh..  */
d232 1
a232 1
struct remote_state
a251 9

  /* A buffer to use for incoming packets, and its current size.  The
     buffer is grown dynamically for larger incoming packets.
     Outgoing packets may also be constructed in this buffer.
     BUF_SIZE is always at least REMOTE_PACKET_SIZE;
     REMOTE_PACKET_SIZE should be used to limit the length of outgoing
     packets.  */
  char *buf;
  long buf_size;
d258 2
a259 2
static struct remote_state *
get_remote_state (void)
d268 2
a269 1
  struct remote_state *rs = GDBARCH_OBSTACK_ZALLOC (gdbarch, struct remote_state);
d271 3
a273 1
  rs->sizeof_g_packet = 0;
d276 2
a277 2
  rs->regs = GDBARCH_OBSTACK_CALLOC (gdbarch, NUM_REGS + NUM_PSEUDO_REGS,
				     struct packet_reg);
d280 1
a280 1
      struct packet_reg *r = &rs->regs[regnum];
d289 1
a289 1
	rs->sizeof_g_packet += register_size (current_gdbarch, regnum);
d298 5
a302 2
     already a full buffer (As of 1999-12-04 that was most stubs.  */
  rs->remote_packet_size = 400 - 1;
d304 1
a304 1
  /* Should rs->sizeof_g_packet needs more space than the
d310 10
a319 2
  if (rs->sizeof_g_packet > ((rs->remote_packet_size - 32) / 2))
    rs->remote_packet_size = (rs->sizeof_g_packet * 2 + 32);
d321 2
a322 2
  /* This one is filled in when a ``g'' packet is received.  */
  rs->actual_register_packet_size = 0;
d324 7
a330 7
  /* Create the buffer at a default size.  Note that this would
     leak memory if the gdbarch were ever destroyed; there's no
     way to register a destructor for it, and we can't realloc
     using the gdbarch obstack.  But gdbarches are never
     destroyed.  */
  rs->buf_size = rs->remote_packet_size;
  rs->buf = xmalloc (rs->buf_size);
d332 1
a332 1
  return rs;
d336 1
a336 1
packet_reg_from_regnum (struct remote_state *rs, long regnum)
d342 1
a342 1
      struct packet_reg *r = &rs->regs[regnum];
d349 1
a349 1
packet_reg_from_pnum (struct remote_state *rs, LONGEST pnum)
d354 1
a354 1
      struct packet_reg *r = &rs->regs[i];
d424 2
a425 2
   memory read/write packet.  MIN (rs->remote_packet_size,
   rs->sizeof_g_packet) is the default.  Some targets need smaller
d445 2
d469 1
a469 1
      what_they_get = rs->remote_packet_size;
d475 3
a477 3
      if ((rs->actual_register_packet_size) > 0
	  && what_they_get > (rs->actual_register_packet_size))
	what_they_get = (rs->actual_register_packet_size);
a593 1
  struct remote_state *rs = get_remote_state ();
d597 3
a599 3
     increased beyond RS->remote_packet_size.  */
  if (size > rs->remote_packet_size)
    size = rs->remote_packet_size;
d954 1
a954 1
    xsnprintf (&buf[2], rs->remote_packet_size - 2, "-%x", -th);
d956 1
a956 1
    xsnprintf (&buf[2], rs->remote_packet_size - 2, "%x", th);
d975 1
a975 1
    xsnprintf (buf, rs->remote_packet_size, "T-%08x", -tid);
d977 1
a977 1
    xsnprintf (buf, rs->remote_packet_size, "T%08x", tid);
d1544 2
a1545 2
  if ((((result_limit + 1) * BUF_THREAD_ID_SIZE) + 10) >= rs->remote_packet_size)
    result_limit = (rs->remote_packet_size / BUF_THREAD_ID_SIZE) - 2;
d1766 1
a1766 1
      xsnprintf (bufp, rs->remote_packet_size, "qThreadExtraInfo,%x", 
d1818 1
a1818 1
  xsnprintf (rs->buf, rs->remote_packet_size, "R%x", 0);
d2011 1
a2011 1
  msg = alloca (rs->remote_packet_size);
d2028 1
a2028 1
	xsnprintf (msg, rs->remote_packet_size, "qSymbol::%s", &reply[8]);
d2030 1
a2030 1
	xsnprintf (msg, rs->remote_packet_size, "qSymbol:%s:%s",
d2410 1
a2410 1
  gdb_assert (outbuf && strlen (outbuf) < rs->remote_packet_size);
d2700 1
d2797 1
a2797 1
		    struct packet_reg *reg = packet_reg_from_pnum (rs, pnum);
d2890 1
d2994 1
a2994 1
		    struct packet_reg *reg = packet_reg_from_pnum (rs, pnum);
d3139 1
d3143 1
a3143 1
  char *regs = alloca (rs->sizeof_g_packet);
d3149 1
a3149 1
      struct packet_reg *reg = packet_reg_from_regnum (rs, regnum);
d3188 2
a3189 2
  if ((rs->actual_register_packet_size) == 0)
    (rs->actual_register_packet_size) = strlen (buf);
d3192 1
a3192 1
  memset (regs, 0, rs->sizeof_g_packet);
d3213 1
a3213 1
  for (i = 0; i < rs->sizeof_g_packet; i++)
d3244 1
a3244 1
	struct packet_reg *r = &rs->regs[i];
d3276 1
a3276 1
  struct remote_state *rs = get_remote_state ();
d3287 2
a3288 2
	if (rs->regs[i].in_g_packet)
	  regcache_raw_read (current_regcache, rs->regs[i].regnum, buf);
d3302 2
a3303 1
  struct packet_reg *reg = packet_reg_from_regnum (rs, regnum);
d3309 1
a3309 1
  xsnprintf (buf, rs->remote_packet_size, "P%s=", phex_nz (reg->pnum, 0));
d3326 1
d3365 2
a3366 2
    regs = alloca (rs->sizeof_g_packet);
    memset (regs, 0, rs->sizeof_g_packet);
d3369 1
a3369 1
	struct packet_reg *r = &rs->regs[i];
d3835 1
a3835 1
   RS->remote_packet_size - 5 to account for the $, # and checksum,
a3841 1
  struct remote_state *rs = get_remote_state ();
d4789 1
a4789 1
      xsnprintf (rs->buf, rs->remote_packet_size, "qCRC:%lx,%lx",
d4885 2
a4886 2
	      LONGEST n = min ((rs->remote_packet_size - 2) / 2, len);
	      snprintf (rs->buf, rs->remote_packet_size,
d4921 2
a4922 2
    return (rs->remote_packet_size);
  /* Minimum outbuf size is RS->remote_packet_size. If LEN is not
d4924 1
a4924 1
  if (len < rs->remote_packet_size)
d4926 1
a4926 1
  len = rs->remote_packet_size;
d4945 1
a4945 1
  while (annex[i] && (i < (rs->remote_packet_size - 8)))
d4984 1
a4984 1
  if ((strlen (buf) + strlen (command) * 2 + 8/*misc*/) > rs->remote_packet_size)
d5502 2
d5513 8
@


1.210
log
@	* remote.c (remote_disconnect): Add TARGET argument.
	* target.c (debug_to_disconnect): Delete.
	(update_current_target): Do not inherit to_disconnect.
	(target_disconnect): Search for a target to implement to_disconnect.
	(setup_target_debug): Do not reference to_disconnect.
	* target.h (struct target_ops): Add target argument to
	to_disconnect.
@
text
@d4480 1
a4480 3
    error (_("Can't set hardware watchpoints without the '%s' (%s) packet."),
	   remote_protocol_packets[PACKET_Z0 + packet].name,
	   remote_protocol_packets[PACKET_Z0 + packet].title);
d4512 1
a4512 3
    error (_("Can't clear hardware watchpoints without the '%s' (%s) packet."),
	   remote_protocol_packets[PACKET_Z0 + packet].name,
	   remote_protocol_packets[PACKET_Z0 + packet].title);
d4600 2
a4601 4
    error (_("Can't set hardware breakpoint without the '%s' (%s) packet."),
	   remote_protocol_packets[PACKET_Z1].name,
	   remote_protocol_packets[PACKET_Z1].title);

d4634 1
a4634 3
    error (_("Can't clear hardware breakpoint without the '%s' (%s) packet."),
	   remote_protocol_packets[PACKET_Z1].name,
	   remote_protocol_packets[PACKET_Z1].title);
@


1.210.2.1
log
@2006-05-13    Changes based on Apple GDB (CVS repository 5th Sept 2005)

	* async-nat-inferior.c, async-nat-inferior.h,
	* async-nat-sigthread.c, async-nat-sigthread.h: New files

	* linux-nat.c: Include async-nat-inferior.h.
	(linux_nat_wait): Add extra argument.  If target_can_async_p
	do something completely different.

	* interps.h (interp_set, interp_set_quiet): New externs.

	* interps.c (interp_set): Make asynchronous.
	(interp_set_quiet): Don't make static.
	(current_interp_command_loop): Call functions with new arguments.

	* target.h (target_wait): Add extra argument.
	(gdb_override_async, gdb_set_async_override) New externs.
	(target_can_async_p): Make conditional on gdb_override_async.

	* target.c (gdb_override_async): New variable.
	(gdb_set_async_override, do_restore_target_async_mask):
	New functions.
	(debug_to_wait): Add extra argument.

	* linux-thread-db.c (thread_db_wait): Add extra argument.

	* wrapper.h (safe_execute_command): Declare structure.

	* top.c (*deprecated_target_wait_hook): Add extra argument.
	(read_command_file): Make asynchronous.

	* remote.c (remote_wait, remote_async_wait): Add extra argument.

	* infrun.c: Include event-top.h
	(wait_for_inferior, fetch_inferior_event): Add extra argument to
	target_wait.
	(proceed): Set target_executing = 0.
	(handle_inferior_event): Call async_disable_stdin if async.

	* inf-ptrace.c: Include inf-loop.h, async-nat-inferior.h.
	(inf_ptrace_him): Create a signal thread.
	(inf_ptrace_wait): Add extra argument to target_wait.

	* inf-loop.c (inferior_event_handler, complete_execution):
	Changes for asynchronous operation (copied verbatim).

	* inf-child.c: Include async-nat-inferior.h.
	(inf_child_target): Use methods async_terminal_inferior
	and async_terminal_ours.

	* i386-linux-nat.c: Include inf-loop.h, async-nat-inferior.h.
	(i386_linux_resume): Call gdb_process_events and then
	async methods.

	* exec.c: Include event-loop.h, async-nat-inferior.h.
	(async_file_handler, standard_async, standard_is_async_p)
	(standard_can_async_p): New functions.
	(init_exec_ops): Initialise above methods.

	* event-top.h (cli_command_loop): Make argument void*.

	* event-top.c (display_gdb_prompt, async_enable_stdin)
	(async_disable_stdin, handle_sigint, async_request_quit)
	(gdb_setup_readline, _initialize_event_loop):
	Changes for asynchronous operation (copied verbatim).
	(cli_command_loop): Make argument void*.

	* event-loop.h (gdb_client_data): Move typedef to defs.h.
	(gdb_create_event): Declare.
	(event_handler_func): Move typedef from event-loop.c.

	* event-loop.c (use_poll): Set to 0.
	(gdb_queue_event, gdb_create_event): New functions.
	(async_queue_event): Don't make static.
	(create_file_event): Use gdb_create_event.
	(gdb_event): Change component from int to void*.
	(process_event, handle_file_event, handle_timer_event):
	Change according to gdb_event.
	(event_handler_func): Move typedef to event-loop.c.

	* defs.h: (gdb_mi_run_status, event_loop_p): New externs.
	(gdb_client_data): Move typedef from event-loop.h.
	(*deprecated_command_loop_hook): Make argument void*.
	(*deprecated_target_wait_hook): Add argument.

	* cli-out.h (cli_quoted_out_new): Declare.

	* cli-out.c (cli_quoted_out_new): New function.
	Include mi/mi-console.h.

	* cli/cli-interp.c: Include inferior.h, mi/mi-console.h.
	(safe_execute_command): Make static.
	(cli_interpreter_resume, cli_interpreter_exec):
	Make asynchronous.
	(cli_quoted_interpreter_resume): New function.
	(_initialize_cli_interp): Add li_command_loop to procs.
	Initialize the console-quoted interpreter.

	* tui/tui-hooks.c (tui_target_wait_hook): Add extra argument.

	* mi/mi-main.h (mi_dont_register_continuation)
	(current_command_token,  mi_interp, mi_interpreter_exec_continuation)
	(mi_continuation_arg): New externs.
	(mi_setup_continuation_arg): Declare.

	* mi/mi-main.c: Include wrapper.h.
	(struct mi_continuation_arg): New structure.
	(mi_interpreter_exec_continuation): Move to mi-interp.c.
	(mi_execute_async_cli_command)
	(mi_exec_async_cli_cmd_continuation): Make asynchronous.
	(mi_setup_continuation_arg): New function.

	* mi/mi-interp.c (mi_interpreter_exec_continuation):
	Move from mi-main.c
	(mi_cmd_interpreter_exec): Switch interpreters.  Make
	asynchronous.
	(mi1_command_loop, mi2_command_loop, mi3_command_loop):
	Make argument void*.

	* Makefile.in (async_nat_inferior_h, async_nat_sigthread_h):
	New variables.
	(gdb$(EXEEXT), $(TUI)$(EXEEXT)): Link with libpthread.
	(async-nat-inferior.o, async-nat-sigthread.o): New rules.
	(COMMON_OBS): Add above object files.
	(exec.o, i386-linux-nat.o, inf-ptrace.o, linux-nat.o):
	Update dependencies.

2006-05-13  Nick Roberts  <nickrob@@snap.net.nz>

	* main.c: (event_loop_p): Re-instate variable.
	(captured_main): Re-instate async/noasync option.
	(print_gdb_help): Describe option again.

	* exec.c(init_exec_ops): Only initialise async methods with async
	option.

	* inf-ptrace.c (inf_ptrace_him): Only reate a signal thread with
	async option.

	* README.async, TODO.async, PROBLEMS.async: New files.
@
text
@d111 4
a114 4
static ptid_t remote_wait
 (ptid_t ptid, struct target_waitstatus *status, gdb_client_data client_data);
static ptid_t remote_async_wait
 (ptid_t ptid, struct target_waitstatus *status, gdb_client_data client_data);
d2668 1
a2668 1
remote_wait (ptid_t ptid, struct target_waitstatus *status, gdb_client_data client_data)
d2857 1
a2857 1
remote_async_wait (ptid_t ptid, struct target_waitstatus *status, gdb_client_data client_data)
@


1.210.2.2
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@a62 12
/* The size to align memory write packets, when practical.  The protocol
   does not guarantee any alignment, and gdb will generate short
   writes and unaligned writes, but even as a best-effort attempt this
   can improve bulk transfers.  For instance, if a write is misaligned
   relative to the target's data bus, the stub may need to make an extra
   round trip fetching data from the target.  This doesn't make a
   huge difference, but it's easy to do, so we try to be helpful.

   The alignment chosen is arbitrary; usually data bus width is
   important here, not the possibly larger cache line size.  */
enum { REMOTE_ALIGN_WRITES = 16 };

a188 8
static void set_remote_protocol_packet_cmd (char *args, int from_tty,
					    struct cmd_list_element *c);

static void show_remote_protocol_packet_cmd (struct ui_file *file,
					     int from_tty,
					     struct cmd_list_element *c,
					     const char *value);

d191 6
a196 40
/* For "set remote" and "show remote".  */

static struct cmd_list_element *remote_set_cmdlist;
static struct cmd_list_element *remote_show_cmdlist;

/* Description of the remote protocol state for the currently
   connected target.  This is per-target state, and independent of the
   selected architecture.  */

struct remote_state
{
  /* A buffer to use for incoming packets, and its current size.  The
     buffer is grown dynamically for larger incoming packets.
     Outgoing packets may also be constructed in this buffer.
     BUF_SIZE is always at least REMOTE_PACKET_SIZE;
     REMOTE_PACKET_SIZE should be used to limit the length of outgoing
     packets.  */
  char *buf;
  long buf_size;

  /* If we negotiated packet size explicitly (and thus can bypass
     heuristics for the largest packet size that will not overflow
     a buffer in the stub), this will be set to that packet size.
     Otherwise zero, meaning to use the guessed size.  */
  long explicit_packet_size;
};

/* This data could be associated with a target, but we do not always
   have access to the current target when we need it, so for now it is
   static.  This will be fine for as long as only one target is in use
   at a time.  */
static struct remote_state remote_state;

static struct remote_state *
get_remote_state (void)
{
  return &remote_state;
}

/* Description of the remote protocol for a given architecture.  */
d204 1
a204 1
  /* long size in bytes;  == register_size (current_gdbarch, regnum);
d209 1
a209 1
struct remote_arch_state
d229 9
d244 2
a245 2
static struct remote_arch_state *
get_remote_arch_state (void)
d254 1
a254 2
  struct remote_state *rs = get_remote_state ();
  struct remote_arch_state *rsa;
d256 1
a256 3
  rsa = GDBARCH_OBSTACK_ZALLOC (gdbarch, struct remote_arch_state);

  rsa->sizeof_g_packet = 0;
d259 2
a260 2
  rsa->regs = GDBARCH_OBSTACK_CALLOC (gdbarch, NUM_REGS + NUM_PSEUDO_REGS,
				      struct packet_reg);
d263 1
a263 1
      struct packet_reg *r = &rsa->regs[regnum];
d272 1
a272 1
	rsa->sizeof_g_packet += register_size (current_gdbarch, regnum);
d281 2
a282 5
     already a full buffer (As of 1999-12-04 that was most stubs).  */
  rsa->remote_packet_size = 400 - 1;

  /* This one is filled in when a ``g'' packet is received.  */
  rsa->actual_register_packet_size = 0;
d284 1
a284 1
  /* Should rsa->sizeof_g_packet needs more space than the
d290 2
a291 2
  if (rsa->sizeof_g_packet > ((rsa->remote_packet_size - 32) / 2))
    rsa->remote_packet_size = (rsa->sizeof_g_packet * 2 + 32);
d293 2
a294 7
  /* Make sure that the packet buffer is plenty big enough for
     this architecture.  */
  if (rs->buf_size < rsa->remote_packet_size)
    {
      rs->buf_size = 2 * rsa->remote_packet_size;
      rs->buf = xrealloc (rs->buf, rs->buf_size);
    }
d296 7
a302 11
  return rsa;
}

/* Return the current allowed size of a remote packet.  This is
   inferred from the current architecture, and should be used to
   limit the length of outgoing packets.  */
static long
get_remote_packet_size (void)
{
  struct remote_state *rs = get_remote_state ();
  struct remote_arch_state *rsa = get_remote_arch_state ();
d304 1
a304 4
  if (rs->explicit_packet_size)
    return rs->explicit_packet_size;

  return rsa->remote_packet_size;
d308 1
a308 1
packet_reg_from_regnum (struct remote_arch_state *rsa, long regnum)
d314 1
a314 1
      struct packet_reg *r = &rsa->regs[regnum];
d321 1
a321 1
packet_reg_from_pnum (struct remote_arch_state *rsa, LONGEST pnum)
d326 1
a326 1
      struct packet_reg *r = &rsa->regs[i];
d396 2
a397 2
   memory read/write packet.  MIN (rsa->remote_packet_size,
   rsa->sizeof_g_packet) is the default.  Some targets need smaller
a416 2
  struct remote_arch_state *rsa = get_remote_arch_state ();

d439 1
a439 1
      what_they_get = get_remote_packet_size ();
d444 4
a447 7

      /* Limit it to the size of the targets ``g'' response unless we have
	 permission from the stub to use a larger packet size.  */
      if (rs->explicit_packet_size == 0
	  && rsa->actual_register_packet_size > 0
	  && what_they_get > rsa->actual_register_packet_size)
	what_they_get = rsa->actual_register_packet_size;
d564 1
d568 3
a570 3
     increased beyond this.  */
  if (size > get_remote_packet_size ())
    size = get_remote_packet_size ();
d588 2
a589 2
    const char *name;
    const char *title;
d652 8
a659 2
add_packet_config_cmd (struct packet_config *config, const char *name,
		       const char *title, int legacy)
d677 2
a678 3
				set_remote_protocol_packet_cmd,
				show_remote_protocol_packet_cmd,
				&remote_set_cmdlist, &remote_show_cmdlist);
d685 1
a685 1
		     &remote_set_cmdlist);
d687 1
a687 1
		     &remote_show_cmdlist);
d766 1
a766 1
  PACKET_qXfer_auxv,
a767 1
  PACKET_qSupported,
d925 1
a925 1
    xsnprintf (&buf[2], get_remote_packet_size () - 2, "-%x", -th);
d927 1
a927 1
    xsnprintf (&buf[2], get_remote_packet_size () - 2, "%x", th);
d946 1
a946 1
    xsnprintf (buf, get_remote_packet_size (), "T-%08x", -tid);
d948 1
a948 1
    xsnprintf (buf, get_remote_packet_size (), "T%08x", tid);
d981 1
a981 1
    int active;			/* Has state interesting to GDB?
d983 1
a983 1
    char display[256];		/* Brief state display, name,
d986 1
a986 1
    char more_display[256];	/* Long info, statistics, queue depth,
d1032 1
a1032 1
static char *pack_threadinfo_request (char *pkt, int mode,
d1041 1
a1041 1
static int remote_get_threadinfo (threadref *threadid,
d1052 1
a1052 1
				      threadref *resultlist,
d1059 1
a1059 1
				  int *result_count,
d1128 1
a1128 1
  ULONGEST retval = 0;
d1515 2
a1516 2
  if ((((result_limit + 1) * BUF_THREAD_ID_SIZE) + 10) >= get_remote_packet_size ())
    result_limit = (get_remote_packet_size () / BUF_THREAD_ID_SIZE) - 2;
d1737 1
a1737 1
      xsnprintf (bufp, get_remote_packet_size (), "qThreadExtraInfo,%x",
d1759 1
a1759 1
	  n += xsnprintf (&display_buf[0], sizeof (display_buf) - n,
d1762 1
a1762 1
	  n += xsnprintf (&display_buf[n], sizeof (display_buf) - n,
d1765 1
a1765 1
	  n += xsnprintf (&display_buf[n], sizeof (display_buf) - n,
d1789 1
a1789 1
  xsnprintf (rs->buf, get_remote_packet_size (), "R%x", 0);
a1791 2
  remote_fileio_reset ();

d1982 1
a1982 1
  msg = alloca (get_remote_packet_size ());
d1999 1
a1999 1
	xsnprintf (msg, get_remote_packet_size (), "qSymbol::%s", &reply[8]);
d2001 1
a2001 1
	xsnprintf (msg, get_remote_packet_size (), "qSymbol:%s:%s",
a2028 216
/* This type describes each known response to the qSupported
   packet.  */
struct protocol_feature
{
  /* The name of this protocol feature.  */
  const char *name;

  /* The default for this protocol feature.  */
  enum packet_support default_support;

  /* The function to call when this feature is reported, or after
     qSupported processing if the feature is not supported.
     The first argument points to this structure.  The second
     argument indicates whether the packet requested support be
     enabled, disabled, or probed (or the default, if this function
     is being called at the end of processing and this feature was
     not reported).  The third argument may be NULL; if not NULL, it
     is a NUL-terminated string taken from the packet following
     this feature's name and an equals sign.  */
  void (*func) (const struct protocol_feature *, enum packet_support,
		const char *);

  /* The corresponding packet for this feature.  Only used if
     FUNC is remote_supported_packet.  */
  int packet;
};

static void
remote_supported_packet (const struct protocol_feature *feature,
			 enum packet_support support,
			 const char *argument)
{
  if (argument)
    {
      warning (_("Remote qSupported response supplied an unexpected value for"
		 " \"%s\"."), feature->name);
      return;
    }

  if (remote_protocol_packets[feature->packet].support
      == PACKET_SUPPORT_UNKNOWN)
    remote_protocol_packets[feature->packet].support = support;
}

static void
remote_packet_size (const struct protocol_feature *feature,
		    enum packet_support support, const char *value)
{
  struct remote_state *rs = get_remote_state ();

  int packet_size;
  char *value_end;

  if (support != PACKET_ENABLE)
    return;

  if (value == NULL || *value == '\0')
    {
      warning (_("Remote target reported \"%s\" without a size."),
	       feature->name);
      return;
    }

  errno = 0;
  packet_size = strtol (value, &value_end, 16);
  if (errno != 0 || *value_end != '\0' || packet_size < 0)
    {
      warning (_("Remote target reported \"%s\" with a bad size: \"%s\"."),
	       feature->name, value);
      return;
    }

  if (packet_size > MAX_REMOTE_PACKET_SIZE)
    {
      warning (_("limiting remote suggested packet size (%d bytes) to %d"),
	       packet_size, MAX_REMOTE_PACKET_SIZE);
      packet_size = MAX_REMOTE_PACKET_SIZE;
    }

  /* Record the new maximum packet size.  */
  rs->explicit_packet_size = packet_size;
}

static struct protocol_feature remote_protocol_features[] = {
  { "PacketSize", PACKET_DISABLE, remote_packet_size, -1 },
  { "qXfer:auxv:read", PACKET_DISABLE, remote_supported_packet,
    PACKET_qXfer_auxv }
};

static void
remote_query_supported (void)
{
  struct remote_state *rs = get_remote_state ();
  char *next;
  int i;
  unsigned char seen [ARRAY_SIZE (remote_protocol_features)];

  /* The packet support flags are handled differently for this packet
     than for most others.  We treat an error, a disabled packet, and
     an empty response identically: any features which must be reported
     to be used will be automatically disabled.  An empty buffer
     accomplishes this, since that is also the representation for a list
     containing no features.  */

  rs->buf[0] = 0;
  if (remote_protocol_packets[PACKET_qSupported].support != PACKET_DISABLE)
    {
      putpkt ("qSupported");
      getpkt (&rs->buf, &rs->buf_size, 0);

      /* If an error occured, warn, but do not return - just reset the
	 buffer to empty and go on to disable features.  */
      if (packet_ok (rs->buf, &remote_protocol_packets[PACKET_qSupported])
	  == PACKET_ERROR)
	{
	  warning (_("Remote failure reply: %s"), rs->buf);
	  rs->buf[0] = 0;
	}
    }

  memset (seen, 0, sizeof (seen));

  next = rs->buf;
  while (*next)
    {
      enum packet_support is_supported;
      char *p, *end, *name_end, *value;

      /* First separate out this item from the rest of the packet.  If
	 there's another item after this, we overwrite the separator
	 (terminated strings are much easier to work with).  */
      p = next;
      end = strchr (p, ';');
      if (end == NULL)
	{
	  end = p + strlen (p);
	  next = end;
	}
      else
	{
	  if (end == p)
	    {
	      warning (_("empty item in \"qSupported\" response"));
	      continue;
	    }

	  *end = '\0';
	  next = end + 1;
	}

      name_end = strchr (p, '=');
      if (name_end)
	{
	  /* This is a name=value entry.  */
	  is_supported = PACKET_ENABLE;
	  value = name_end + 1;
	  *name_end = '\0';
	}
      else
	{
	  value = NULL;
	  switch (end[-1])
	    {
	    case '+':
	      is_supported = PACKET_ENABLE;
	      break;

	    case '-':
	      is_supported = PACKET_DISABLE;
	      break;

	    case '?':
	      is_supported = PACKET_SUPPORT_UNKNOWN;
	      break;

	    default:
	      warning (_("unrecognized item \"%s\" in \"qSupported\" response"), p);
	      continue;
	    }
	  end[-1] = '\0';
	}

      for (i = 0; i < ARRAY_SIZE (remote_protocol_features); i++)
	if (strcmp (remote_protocol_features[i].name, p) == 0)
	  {
	    const struct protocol_feature *feature;

	    seen[i] = 1;
	    feature = &remote_protocol_features[i];
	    feature->func (feature, is_supported, value);
	    break;
	  }
    }

  /* If we increased the packet size, make sure to increase the global
     buffer size also.  We delay this until after parsing the entire
     qSupported packet, because this is the same buffer we were
     parsing.  */
  if (rs->buf_size < rs->explicit_packet_size)
    {
      rs->buf_size = rs->explicit_packet_size;
      rs->buf = xrealloc (rs->buf, rs->buf_size);
    }

  /* Handle the defaults for unmentioned features.  */
  for (i = 0; i < ARRAY_SIZE (remote_protocol_features); i++)
    if (!seen[i])
      {
	const struct protocol_feature *feature;

	feature = &remote_protocol_features[i];
	feature->func (feature, feature->default_support, NULL);
      }
}


d2043 3
a2049 4
  remote_fileio_reset ();
  reopen_exec_file ();
  reread_symbols ();

a2081 2
  /* Reset the target state; these things will be queried either by
     remote_query_supported or as they are needed.  */
a2082 1
  rs->explicit_packet_size = 0;
a2090 5
  /* The first packet we send to the target is the optional "supported
     packets" request.  If the target can answer this, it will tell us
     which later probes to skip.  */
  remote_query_supported ();

d2381 1
a2381 1
  gdb_assert (outbuf && strlen (outbuf) < get_remote_packet_size ());
d2526 1
a2526 1
    delete_async_signal_handler ((struct async_signal_handler **)
d2529 1
a2529 1
    delete_async_signal_handler ((struct async_signal_handler **)
a2670 1
  struct remote_arch_state *rsa = get_remote_arch_state ();
d2767 1
a2767 1
		    struct packet_reg *reg = packet_reg_from_pnum (rsa, pnum);
d2781 1
a2781 1
					 register_size (current_gdbarch,
d2784 1
a2784 1
		    if (fieldsize < register_size (current_gdbarch,
d2787 1
a2787 1
		    regcache_raw_supply (current_regcache,
d2792 1
a2792 1
		  error (_("Remote register badly formatted: %s\nhere: %s"),
a2859 1
  struct remote_arch_state *rsa = get_remote_arch_state ();
d2963 1
a2963 1
		    struct packet_reg *reg = packet_reg_from_pnum (rsa, pnum);
d2976 1
a2976 1
					 register_size (current_gdbarch,
d2979 1
a2979 1
		    if (fieldsize < register_size (current_gdbarch,
a3107 1
  struct remote_arch_state *rsa = get_remote_arch_state ();
d3111 1
a3111 1
  char *regs = alloca (rsa->sizeof_g_packet);
d3117 1
a3117 1
      struct packet_reg *reg = packet_reg_from_regnum (rsa, regnum);
d3156 2
a3157 2
  if ((rsa->actual_register_packet_size) == 0)
    (rsa->actual_register_packet_size) = strlen (buf);
d3160 1
a3160 1
  memset (regs, 0, rsa->sizeof_g_packet);
d3181 1
a3181 1
  for (i = 0; i < rsa->sizeof_g_packet; i++)
d3212 1
a3212 1
	struct packet_reg *r = &rsa->regs[i];
d3244 1
a3244 1
  struct remote_arch_state *rsa = get_remote_arch_state ();
d3255 2
a3256 2
	if (rsa->regs[i].in_g_packet)
	  regcache_raw_read (current_regcache, rsa->regs[i].regnum, buf);
d3270 1
a3270 2
  struct remote_arch_state *rsa = get_remote_arch_state ();
  struct packet_reg *reg = packet_reg_from_regnum (rsa, regnum);
d3276 1
a3276 1
  xsnprintf (buf, get_remote_packet_size (), "P%s=", phex_nz (reg->pnum, 0));
a3292 1
  struct remote_arch_state *rsa = get_remote_arch_state ();
d3331 2
a3332 2
    regs = alloca (rsa->sizeof_g_packet);
    memset (regs, 0, rsa->sizeof_g_packet);
d3335 1
a3335 1
	struct packet_reg *r = &rsa->regs[i];
a3408 85
/* Convert BUFFER, binary data at least LEN bytes long, into escaped
   binary data in OUT_BUF.  Set *OUT_LEN to the length of the data
   encoded in OUT_BUF, and return the number of bytes in OUT_BUF
   (which may be more than *OUT_LEN due to escape characters).  The
   total number of bytes in the output buffer will be at most
   OUT_MAXLEN.  */

static int
remote_escape_output (const gdb_byte *buffer, int len,
		      gdb_byte *out_buf, int *out_len,
		      int out_maxlen)
{
  int input_index, output_index;

  output_index = 0;
  for (input_index = 0; input_index < len; input_index++)
    {
      gdb_byte b = buffer[input_index];

      if (b == '$' || b == '#' || b == '}')
	{
	  /* These must be escaped.  */
	  if (output_index + 2 > out_maxlen)
	    break;
	  out_buf[output_index++] = '}';
	  out_buf[output_index++] = b ^ 0x20;
	}
      else
	{
	  if (output_index + 1 > out_maxlen)
	    break;
	  out_buf[output_index++] = b;
	}
    }

  *out_len = input_index;
  return output_index;
}

/* Convert BUFFER, escaped data LEN bytes long, into binary data
   in OUT_BUF.  Return the number of bytes written to OUT_BUF.
   Raise an error if the total number of bytes exceeds OUT_MAXLEN.

   This function reverses remote_escape_output.  It allows more
   escaped characters than that function does, in particular because
   '*' must be escaped to avoid the run-length encoding processing
   in reading packets.  */

static int
remote_unescape_input (const gdb_byte *buffer, int len,
		       gdb_byte *out_buf, int out_maxlen)
{
  int input_index, output_index;
  int escaped;

  output_index = 0;
  escaped = 0;
  for (input_index = 0; input_index < len; input_index++)
    {
      gdb_byte b = buffer[input_index];

      if (output_index + 1 > out_maxlen)
	{
	  warning (_("Received too much data from remote target;"
		     " ignoring overflow."));
	  return output_index;
	}

      if (escaped)
	{
	  out_buf[output_index++] = b ^ 0x20;
	  escaped = 0;
	}
      else if (b == '}')
	escaped = 1;
      else
	out_buf[output_index++] = b;
    }

  if (escaped)
    error (_("Unmatched escape character in target response."));

  return output_index;
}

d3476 1
a3476 1
remote_write_bytes (CORE_ADDR memaddr, const gdb_byte *myaddr, int len)
d3486 1
a3486 10
  int payload_length;

  /* Should this be the selected frame?  */
  gdbarch_remote_translate_xfer_address (current_gdbarch,
					 current_regcache,
					 memaddr, len,
					 &memaddr, &len);

  if (len <= 0)
    return 0;
d3492 1
a3492 1

a3533 5
  /* If we already need another packet, then try to align the end
     of this packet to a useful boundary.  */
  if (todo > 2 * REMOTE_ALIGN_WRITES && todo < len)
    todo = ((memaddr + todo) & ~(REMOTE_ALIGN_WRITES - 1)) - memaddr;

d3552 1
d3559 3
a3561 6
      payload_length = remote_escape_output (myaddr, todo, p, &nr_bytes,
					     payload_size);

      /* If not all TODO bytes fit, then we'll need another packet.  Make
	 a second try to keep the end of the packet aligned.  */
      if (nr_bytes < todo)
d3563 13
a3575 8
	  int new_nr_bytes;

	  new_nr_bytes = (((memaddr + nr_bytes) & ~(REMOTE_ALIGN_WRITES - 1))
			  - memaddr);
	  if (new_nr_bytes != nr_bytes)
	    payload_length = remote_escape_output (myaddr, new_nr_bytes,
						   p, &nr_bytes,
						   payload_size);
a3576 2

      p += payload_length;
a3641 9
  /* Should this be the selected frame?  */
  gdbarch_remote_translate_xfer_address (current_gdbarch,
					 current_regcache,
					 memaddr, len,
					 &memaddr, &len);

  if (len <= 0)
    return 0;

d3709 2
d3713 8
d3722 1
a3722 1
    res = remote_write_bytes (mem_addr, buffer, mem_len);
d3724 1
a3724 1
    res = remote_read_bytes (mem_addr, buffer, mem_len);
d3738 2
a3739 1
/* Read a single character from the remote end.  */
d3749 1
a3749 1
    return ch;
d3801 1
a3801 1
   get_remote_packet_size () - 5 to account for the $, # and checksum,
d3808 1
d3887 1
a3887 1
		  fprintf_unfiltered (gdb_stdlog,
d4013 1
a4013 1
		  fputs_filtered ("Timeout in checksum, retrying\n",
d4020 1
a4020 1
		  fputs_filtered ("Communication error in checksum\n",
d4034 1
a4034 1
		fputstrn_filtered (buf, bc, 0, gdb_stdlog);
d4113 1
a4113 2
   indication of this to the caller.  Otherwise return the number
   of bytes read.  */
d4174 1
a4174 1
	      fputstrn_unfiltered (*buf, val, 0, gdb_stdlog);
d4178 1
a4178 1
	  return val;
d4186 1
a4186 1
  /* We have tried hard enough, and just can't receive the packet.
d4191 1
a4191 1
  return -1;
d4480 3
a4482 1
    return -1;
d4514 3
a4516 1
    return -1;
d4604 3
a4606 1
    return -1;
d4640 3
a4642 1
    return -1;
d4764 1
a4764 1
      xsnprintf (rs->buf, get_remote_packet_size (), "qCRC:%lx,%lx",
a4803 84
/* Read OBJECT_NAME/ANNEX from the remote target using a qXfer packet.
   Data at OFFSET, of up to LEN bytes, is read into READBUF; the
   number of bytes read is returned, or 0 for EOF, or -1 for error.
   The number of bytes read may be less than LEN without indicating an
   EOF.  PACKET is checked and updated to indicate whether the remote
   target supports this object.  */

static LONGEST
remote_read_qxfer (struct target_ops *ops, const char *object_name,
		   const char *annex,
		   gdb_byte *readbuf, ULONGEST offset, LONGEST len,
		   struct packet_config *packet)
{
  static char *finished_object;
  static char *finished_annex;
  static ULONGEST finished_offset;

  struct remote_state *rs = get_remote_state ();
  unsigned int total = 0;
  LONGEST i, n, packet_len;

  if (packet->support == PACKET_DISABLE)
    return -1;

  /* Check whether we've cached an end-of-object packet that matches
     this request.  */
  if (finished_object)
    {
      if (strcmp (object_name, finished_object) == 0
	  && strcmp (annex ? annex : "", finished_annex) == 0
	  && offset == finished_offset)
	return 0;

      /* Otherwise, we're now reading something different.  Discard
	 the cache.  */
      xfree (finished_object);
      xfree (finished_annex);
      finished_object = NULL;
      finished_annex = NULL;
    }

  /* Request only enough to fit in a single packet.  The actual data
     may not, since we don't know how much of it will need to be escaped;
     the target is free to respond with slightly less data.  We subtract
     five to account for the response type and the protocol frame.  */
  n = min (get_remote_packet_size () - 5, len);
  snprintf (rs->buf, get_remote_packet_size () - 4, "qXfer:%s:read:%s:%s,%s",
	    object_name, annex ? annex : "",
	    phex_nz (offset, sizeof offset),
	    phex_nz (n, sizeof n));
  i = putpkt (rs->buf);
  if (i < 0)
    return -1;

  rs->buf[0] = '\0';
  packet_len = getpkt_sane (&rs->buf, &rs->buf_size, 0);
  if (packet_len < 0 || packet_ok (rs->buf, packet) != PACKET_OK)
    return -1;

  if (rs->buf[0] != 'l' && rs->buf[0] != 'm')
    error (_("Unknown remote qXfer reply: %s"), rs->buf);

  /* 'm' means there is (or at least might be) more data after this
     batch.  That does not make sense unless there's at least one byte
     of data in this reply.  */
  if (rs->buf[0] == 'm' && packet_len == 1)
    error (_("Remote qXfer reply contained no data."));

  /* Got some data.  */
  i = remote_unescape_input (rs->buf + 1, packet_len - 1, readbuf, n);

  /* 'l' is an EOF marker, possibly including a final block of data,
     or possibly empty.  Record it to bypass the next read, if one is
     issued.  */
  if (rs->buf[0] == 'l')
    {
      finished_object = xstrdup (object_name);
      finished_annex = xstrdup (annex ? annex : "");
      finished_offset = offset + i;
    }

  return i;
}

d4814 1
a4814 1
  /* Handle memory using the standard memory routines.  */
d4821 7
a4827 1
	xfered = remote_write_bytes (offset, writebuf, len);
d4829 1
a4829 1
	xfered = remote_read_bytes (offset, readbuf, len);
d4847 3
d4855 33
a4887 3
      gdb_assert (annex == NULL);
      return remote_read_qxfer (ops, "auxv", annex, readbuf, offset, len,
				&remote_protocol_packets[PACKET_qXfer_auxv]);
d4896 2
a4897 2
    return (get_remote_packet_size ());
  /* Minimum outbuf size is get_remote_packet_size (). If LEN is not
d4899 1
a4899 1
  if (len < get_remote_packet_size ())
d4901 1
a4901 1
  len = get_remote_packet_size ();
d4920 1
a4920 1
  while (annex[i] && (i < (get_remote_packet_size () - 8)))
d4959 1
a4959 1
  if ((strlen (buf) + strlen (command) * 2 + 8/*misc*/) > get_remote_packet_size ())
d5308 1
a5308 1
static void (*async_client_callback) (enum inferior_event_type event_type,
d5322 1
a5322 1
remote_async (void (*callback) (enum inferior_event_type event_type,
d5349 1
a5349 1
  remote_async_ops.to_longname =
d5419 3
a5476 2
  struct remote_state *rs;

d5478 1
a5478 1
  remote_gdbarch_data_handle =
a5485 8
  /* Initialize the per-target state.  At the moment there is only one
     of these, not one per target.  Only one target is active at a
     time.  The default buffer size is unimportant; it will be expanded
     whenever a larger buffer is needed.  */
  rs = get_remote_state ();
  rs->buf_size = 400;
  rs->buf = xmalloc (rs->buf_size);

d5599 5
a5603 1
			 "X", "binary-download", 1);
d5606 5
a5610 1
			 "vCont", "verbose-resume", 0);
d5613 5
a5617 1
			 "qSymbol", "symbol-lookup", 0);
d5620 5
a5624 1
			 "P", "set-register", 1);
d5627 5
a5631 1
			 "p", "fetch-register", 1);
d5634 5
a5638 1
			 "Z0", "software-breakpoint", 0);
d5641 5
a5645 1
			 "Z1", "hardware-breakpoint", 0);
d5648 5
a5652 1
			 "Z2", "write-watchpoint", 0);
d5655 5
a5659 1
			 "Z3", "read-watchpoint", 0);
d5662 5
a5666 1
			 "Z4", "access-watchpoint", 0);
d5668 6
a5673 2
  add_packet_config_cmd (&remote_protocol_packets[PACKET_qXfer_auxv],
			 "qXfer:auxv:read", "read-aux-vector", 0);
d5677 3
a5681 3
  add_packet_config_cmd (&remote_protocol_packets[PACKET_qSupported],
			 "qSupported", "supported-packets", 0);

@


1.209
log
@2006-04-20  Michael Snyder  <msnyder@@redhat.com>

	* remote.c: Fix spelling error in comment.
@
text
@d2190 1
a2190 1
remote_disconnect (char *args, int from_tty)
@


1.209.2.1
log
@2006-05-02  Michael Snyder  <msnyder@@redhat.com>

	* Target interface for reverse execution.
	* target.h (enum target_waitkind):
	Add new wait event, TARGET_WAITKIND_NO_HISTORY.
	(enum exec_direction_kind): New enum.
	(struct target_ops): New methods to_set_execdir, to_get_execdir.
	* target.c (target_get_execdir): New generic method.
	(target_set_execdir): Ditto.
	* remote.c (remote_get_execdir, remote_set_execdir): New methods.
	(remote_vcont_resume): Jump out if attempting reverse execution.
	(remote_resume): Check for reverse exec direction, and send
	appropriate command to target.
	(remote_wait): Check target response for NO_HISTORY status.
	Also check for empty reply (target doesn't understand "bs" or "bc).
	(_initialize_remote): Add new methods to remote target vector.
@
text
@a2329 4
  /* vCont does not currently support reverse execution.  */
  if (target_get_execdir () == EXEC_REVERSE)
    return 0;

d2422 1
a2422 9
  if (target_get_execdir () == EXEC_REVERSE)
    {
      /* We don't pass signals to the target in reverse exec mode.  */
      if (info_verbose && siggnal != TARGET_SIGNAL_0)
	warning (_(" - Can't pass signal %d to target in reverse: ignored.\n"),
		 siggnal);
      strcpy (buf, step ? "bs" : "bc");
    }
  else if (siggnal != TARGET_SIGNAL_0)
a2695 6
	  if (buf[1] == '0' && buf[2] == '6' 
	      && target_get_execdir () == EXEC_REVERSE)
	    {
	      status->kind = TARGET_WAITKIND_NO_HISTORY;
	      goto got_status;
	    }
a2825 2
	  /* Zero length reply may mean that we tried 'S' or 'C' and
	     the remote system doesn't support it.  */
d2828 2
a2840 6
	  /* Or, it may mean that we tried "bs" or "bc" and
	     the remote system doesn't support that.  */
	  else if (target_get_execdir () == EXEC_REVERSE)
	    {
	      error (_("Target does not support reverse execution."));
	    }
d2843 2
a2844 2
	  error (_("Invalid remote reply: %s"), buf);
	  break;	/* Lint.  */
a5220 34
/* Reverse execution.  
   FIXME: set up as a capability.  */
static enum exec_direction_kind remote_execdir = EXEC_FORWARD;

static enum exec_direction_kind 
remote_get_execdir (void)
{
  if (remote_debug && info_verbose)
    printf_filtered ("remote execdir is %s\n", 
		     remote_execdir == EXEC_FORWARD ? "forward" :
		     remote_execdir == EXEC_REVERSE ? "reverse" :
		     "unknown");
  return remote_execdir;
}

static enum exec_direction_kind 
remote_set_execdir (enum exec_direction_kind dir)
{
  if (remote_debug && info_verbose)
    printf_filtered ("Set remote execdir: %s\n",
		     dir == EXEC_FORWARD ? "forward" :
		     dir == EXEC_REVERSE ? "reverse" :
		     "bad direction");

  /* FIXME: check target for capability.  */
  if (dir == EXEC_FORWARD || dir == EXEC_REVERSE)
    {
      remote_execdir = dir;
      return dir;
    }
  else
    return EXEC_ERROR;
}

a5267 2
  remote_ops.to_get_execdir = remote_get_execdir;
  remote_ops.to_set_execdir = remote_set_execdir;
@


1.208
log
@gdb/
	* breakpoint.c (deprecated_read_memory_nobpt): Update to use
	shadow_len.
	(insert_bp_location, reattach_breakpoints, remove_breakpoint)
	(delete_breakpoint): Update calls to changed methods.
	(deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint)
	(single_step_breakpoints, insert_single_step_breakpoint)
	(remove_single_step_breakpoints): New.
	* breakpoint.h (struct bp_target_info): New.
	(struct bp_location): Replace shadow_contents with
	target_info and overlay_target_info.
	(deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint)
	(insert_single_step_breakpoint, remove_single_step_breakpoints): New
	prototypes.
	* gdbarch.sh: Forward declare struct bp_target_info in gdbarch.h.
	(memory_insert_breakpoint, memory_remove_breakpoint): Update second
	argument.
	* mem-break.c (default_memory_insert_breakpoint): Update.  Set
	placed_address, placed_size, and shadow_len.
	(default_memory_remove_breakpoint): Update.  Don't use
	BREAKPOINT_FROM_PC.
	(memory_insert_breakpoint, memory_remove_breakpoint): Update.
	* target.c (update_current_target): Update prototypes for changed
	functions.
	(debug_to_insert_breakpoint, debug_to_remove_breakpoint)
	(debug_to_insert_hw_breakpoint, debug_to_remove_hw_breakpoint):
	Update.
	* target.h: Forward declare struct bp_target_info.
	(struct target_ops): Use a bp_target_info argument for
	to_insert_breakpoint, to_remove_breakpoint,
	to_insert_hw_breakpoint, and to_remove_hw_breakpoint.
	(target_insert_breakpoint, target_remove_breakpoint)
	(target_insert_hw_breakpoint, target_remove_hw_breakpoint)
	(memory_insert_breakpoint, memory_remove_breakpoint)
	(default_memory_insert_breakpoint, default_memory_remove_breakpoint):
	Update.
	* config/i386/nm-i386.h: Forward declare struct bp_target_info.
	(i386_insert_hw_breakpoint, i386_remove_hw_breakpoint): Update.
	(target_insert_hw_breakpoint, target_remove_hw_breakpoint): Likewise.

	* gdbarch.c, gdbarch.h: Regenerated.

	* alpha-tdep.c (alpha_software_single_step): Use
	insert_single_step_breakpoint and remove_single_step_breakpoints.
	Remove unused statics.
	* arm-tdep.c (arm_software_single_step): Likewise.  Add a note.
	* cris-tdep.c (cris_software_single_step): Likewise.
	* mips-tdep.c (mips_software_single_step): Likewise.
	* rs6000-tdep.c (rs6000_software_single_step): Likewise.
	* sparc-tdep.c (sparc_software_single_step): Likewise.
	* wince.c (struct thread_info_struct): Remove step_prev.
	(undoSStep): Use remove_single_step_breakpoints.
	(wince_software_single_step): Use insert_single_step_breakpoint.

	* corelow.c (ignore): Remove unneeded prototype.  Update arguments.
	* exec.c (ignore): Likewise.
	* sol-thread.c (ignore): Likewise.

	* procfs.c (dbx_link_shadow_contents): Delete.
	(dbx_link_bpt): New.
	(procfs_mourn_inferior): Remove it if necessary.
	(remove_dbx_link_breakpoint): Use it.
	(insert_dbx_link_bpt_in_file): Set it.
	(procfs_init_inferior): Don't update dbx_link_bpt_addr.
	* rs6000-nat.c (exec_one_dummy_insn): Use
	deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint.
	* solib-irix.c (shadow_contents, breakpoint_addr): Delete.
	(base_breakpoint): New.
	(disable_break): Use it.
	(enable_break): Set it.

	* i386-nat.c (i386_insert_hw_breakpoint, i386_remove_hw_breakpoint):
	Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint)
	(ia64_memory_remove_breakpoint): Likewise.
	* m32r-tdep.c (m32r_memory_insert_breakpoint)
	(m32r_memory_remove_breakpoint): Likewise.
	* monitor.c (monitor_insert_breakpoint, monitor_remove_breakpoint):
	Likewise.  Remove unnecessary prototypes.  Use placed_address
	and placed_size.  Removed useless read from memory.
	* nto-procfs.c (procfs_insert_breakpoint)
	(procfs_remove_breakpoint, procfs_insert_hw_breakpoint)
	(procfs_remove_hw_breakpoint): Update.
	* ocd.c (ocd_insert_breakpoint, ocd_remove_breakpoint): Likewise.
	* ocd.h (ocd_insert_breakpoint, ocd_remove_breakpoint): Likewise.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Likewise.
	* ppc-tdep.h (ppc_linux_memory_remove_breakpoint): Likewise.
	* remote-e7000.c (e7000_insert_breakpoint)
	(e7000_remove_breakpoint): Likewise.
	* remote-m32r-sdi.c (m32r_insert_breakpoint)
	(m32r_remove_breakpoint): Likewise.
	* remote-mips.c (mips_insert_breakpoint)
	(mips_remove_breakpoint): Likewise.
	* remote-rdp.c (remote_rdp_insert_breakpoint)
	(remote_rdp_remove_breakpoint): Likewise.
	(rdp_step): Use deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint.
	* remote-sds.c (sds_insert_breakpoint, sds_remove_breakpoint):
	Update.
	* remote-sim.c (gdbsim_insert_breakpoint, gdbsim_remove_breakpoint):
	Delete.
	(init_gdbsim_ops): Use memory_insert_breakpoint and
	memory_remove_breakpoint.
	* remote-st.c (st2000_insert_breakpoint)
	(st2000_remove_breakpoint): Update.  Remove unused
	BREAKPOINT_FROM_PC.
	* remote.c (remote_insert_breakpoint, remote_remove_breakpoint):
	Update.  Use placed_address and placed_size.
	(remote_insert_hw_breakpoint, remote_remove_hw_breakpoint): Likewise.
gdb/doc/
	* gdbint.texinfo (x86 Watchpoints, Target Conditionals): Update insert
	and remove breakpoint prototypes.
	(Watchpoints): Move description of target_insert_hw_breakpoint and
	target_remove_hw_breakpoint ...
	(Breakpoints): ... to here.  Document target_insert_breakpoint and
	target_remove_breakpoint.
@
text
@d976 1
a976 1
   equivalint to the reply of the remote threadinfo packet.  */
@


1.207
log
@	* remote.c (extended_remote_restart): Pass the correct length
	to getpkt.
@
text
@a138 4
static int remote_insert_breakpoint (CORE_ADDR, bfd_byte *);

static int remote_remove_breakpoint (CORE_ADDR, bfd_byte *);

d4355 3
a4357 7
/* Insert a breakpoint on targets that don't have any better
   breakpoint support.  We read the contents of the target location
   and stash it, then overwrite it with a breakpoint instruction.
   ADDR is the target location in the target machine.  CONTENTS_CACHE
   is a pointer to memory allocated for saving the target contents.
   It is guaranteed by the caller to be long enough to save the number
   of bytes returned by BREAKPOINT_FROM_PC.  */
d4360 1
a4360 1
remote_insert_breakpoint (CORE_ADDR addr, bfd_byte *contents_cache)
d4362 1
a4366 1
  int bp_size;
a4376 1
      addr = remote_address_masked (addr);
d4380 4
a4383 3
      p += hexnumstr (p, (ULONGEST) addr);
      BREAKPOINT_FROM_PC (&addr, &bp_size);
      sprintf (p, ",%d", bp_size);
d4400 2
a4401 1
  val = target_read_memory (addr, contents_cache, sizeof big_break_insn);
d4415 1
a4415 1
  return memory_insert_breakpoint (addr, contents_cache);
d4420 1
a4420 1
remote_remove_breakpoint (CORE_ADDR addr, bfd_byte *contents_cache)
d4422 1
d4434 3
a4436 4
      addr = remote_address_masked (addr);
      p += hexnumstr (p, (ULONGEST) addr);
      BREAKPOINT_FROM_PC (&addr, &bp_size);
      sprintf (p, ",%d", bp_size);
d4445 2
a4446 1
  return target_write_memory (addr, contents_cache, sizeof big_break_insn);
d4448 1
a4448 1
  return memory_remove_breakpoint (addr, contents_cache);
d4592 1
a4592 1
remote_insert_hw_breakpoint (CORE_ADDR addr, gdb_byte *shadow)
d4594 1
a4594 1
  int len = 0;
d4599 1
a4599 1
     instruction.  */
d4601 1
a4601 1
  BREAKPOINT_FROM_PC (&addr, &len);
d4612 1
a4612 1
  addr = remote_address_masked (addr);
d4614 1
a4614 1
  sprintf (p, ",%x", len);
d4633 1
a4633 1
remote_remove_hw_breakpoint (CORE_ADDR addr, gdb_byte *shadow)
d4635 1
a4635 1
  int len;
a4638 5
  /* The length field should be set to the size of a breakpoint
     instruction.  */

  BREAKPOINT_FROM_PC (&addr, &len);

d4648 1
a4648 1
  addr = remote_address_masked (addr);
d4650 1
a4650 1
  sprintf (p, ",%x", len);
@


1.206
log
@	* remote.c (remote_wait): Convert warning to error before
	parsing corrupt packets.
@
text
@d1799 1
a1799 1
  getpkt (&rs->buf, &rs->remote_packet_size, 0);
@


1.205
log
@2006-03-30  Vladimir Prus  <ghost@@cs.msu.su>

	* remote.c (watchpoint_to_Z_packet): Use values of Z_packet_type enum
	instead of hardcoded integer literals.
@
text
@d2744 1
a2744 1
		      warning (_("Malformed packet(a) (missing colon): %s\n\
d2746 1
a2746 1
			       p, buf);
@


1.204
log
@	* remote.c (struct remote_state): Add BUF and BUF_SIZE.
	(init_remote_state): Initialize the new fields.
	(get_memory_packet_size): Update BUF and BUF_SIZE if necessary.
	(set_thread, remote_thread_alive, remote_unpack_thread_info_response)
	(remote_get_threadinfo, parse_threadlist_response)
	(remote_get_threadlist, remote_current_thread, remote_threads_info)
	(remote_threads_extra_info, extended_remote_restart, get_offsets)
	(remote_check_symbols, remote_open_1, remote_detach)
	(remove_vcont_probe, remote_vcont_resume, remote_resume)
	(remote_wait, remote_async_wait, fetch_register_using_p)
	(remote_fetch_registers, store_register_using_P)
	(remote_store_registers, check_binary_download, remote_write_bytes)
	(remote_read_bytes, remote_insert_breakpoint)
	(remote_remove_breakpoint, remote_insert_watchpoint)
	(remote_remove_watchpoint, remote_insert_hw_breakpoint)
	(remote_remove_hw_breakpoint, compare_sections_command)
	(remote_xfer_partial, remote_rcmd, packet_command)
	(remote_get_thread_local_address): Use the global incoming buffer
	instead of alloca or xmalloc.  Limit outgoing packets to
	rs->remote_packet_size and incoming packets to rs->buf_size.
	Update calls to getpkt and remote_send.
	(remote_send): Take arguments by reference.
	(putpkt_binary): Eliminate junkbuf.  Use skip_frame.
	(skip_frame): New function.
	(read_frame): Take arguments by reference.  Expand the packet
	buffer instead of issuing an error.
	(getpkt, getpkt_sane): Take arguments by reference.
	* remote.h (getpkt): Update prototype and doc.
	* tracepoint.c (remote_get_noisy_reply): Take arguments by
	reference.
	(target_buf): Change from array to pointer.
	(target_buf_size): New variable.
	(remote_set_transparent_ranges): Update call to getpkt.
	(trace_start_command, trace_stop_command, trace_status_command):
	Update calls to remote_get_noisy_reply.
	(finish_tfind_command): Take arguments by reference.
	(trace_find_command, trace_find_pc_command)
	(trace_find_tracepoint_command, trace_find_line_command):
	(trace_find_range_command, trace_find_outside_command): Update
	calls to finish_tfind_command.
	(_initialize_tracepoint): Initialize target_buf_size and target_buf.
@
text
@d4464 1
a4464 1
      return 2;
d4467 1
a4467 1
      return 3;
d4470 1
a4470 1
      return 4;
@


1.203
log
@2006-03-16  Michael Snyder  <msnyder@@redhat.com>

	* remote.c (remote_watch_data_address): Fix typo in comment.
@
text
@d66 1
a66 1
static int getpkt_sane (char *buf, long sizeof_buf, int forever);
d107 1
a107 1
static void remote_send (char *buf, long sizeof_buf);
d135 3
a137 1
static long read_frame (char *buf, long sizeof_buf);
d233 9
d300 8
d457 9
d915 1
a915 1
  char *buf = alloca (rs->remote_packet_size);
d933 1
a933 1
  getpkt (buf, rs->remote_packet_size, 0);
d945 1
d947 1
a947 1
  char buf[16];
d950 1
a950 1
    xsnprintf (buf, sizeof (buf), "T-%08x", -tid);
d952 1
a952 1
    xsnprintf (buf, sizeof (buf), "T%08x", tid);
d954 1
a954 1
  getpkt (buf, sizeof (buf), 0);
d1363 1
a1363 1
  char *limit = pkt + rs->remote_packet_size; /* Plausible parsing limit.  */
d1454 1
a1454 1
  char *threadinfo_pkt = alloca (rs->remote_packet_size);
d1458 1
a1458 1
  getpkt (threadinfo_pkt, rs->remote_packet_size, 0);
d1492 1
a1492 1
  limit = pkt + (rs->remote_packet_size - BUF_THREAD_ID_SIZE);
d1515 1
a1515 2
  char *threadlist_packet = alloca (rs->remote_packet_size);
  char *t_response = alloca (rs->remote_packet_size);
d1522 3
a1524 4
  pack_threadlist_request (threadlist_packet,
			   startflag, result_limit, nextthread);
  putpkt (threadlist_packet);
  getpkt (t_response, rs->remote_packet_size, 0);
d1527 1
a1527 1
    parse_threadlist_response (t_response + 2, result_limit, &echo_nextthread,
d1632 1
a1632 1
  char *buf = alloca (rs->remote_packet_size);
d1635 1
a1635 1
  getpkt (buf, rs->remote_packet_size, 0);
a1670 1
  char *buf = alloca (rs->remote_packet_size);
d1680 2
a1681 2
      bufp = buf;
      getpkt (bufp, rs->remote_packet_size, 0);
d1700 2
a1701 2
	      bufp = buf;
	      getpkt (bufp, rs->remote_packet_size, 0);
a1730 1
  char *bufp = alloca (rs->remote_packet_size);
d1739 2
d1744 1
a1744 1
      getpkt (bufp, rs->remote_packet_size, 0);
a1789 1
  char *buf = alloca (rs->remote_packet_size);
d1793 2
a1794 2
  xsnprintf (buf, rs->remote_packet_size, "R%x", 0);
  putpkt (buf);
d1799 1
a1799 1
  getpkt (buf, rs->remote_packet_size, 0);
d1818 1
a1818 1
  char *buf = alloca (rs->remote_packet_size);
d1825 1
a1825 1
  getpkt (buf, rs->remote_packet_size, 0);
d1984 5
a1988 2
  msg   = alloca (rs->remote_packet_size);
  reply = alloca (rs->remote_packet_size);
d1993 2
a1994 2
  getpkt (reply, rs->remote_packet_size, 0);
  packet_ok (reply, &remote_protocol_packets[PACKET_qSymbol]);
d2009 1
a2009 1
      getpkt (reply, rs->remote_packet_size, 0);
a2154 1
      char *buf = alloca (rs->remote_packet_size);
d2156 1
a2156 1
      getpkt (buf, rs->remote_packet_size, 0);
a2173 1
  char *buf = alloca (rs->remote_packet_size);
d2179 2
a2180 2
  strcpy (buf, "D");
  remote_send (buf, rs->remote_packet_size);
d2274 1
a2274 1
remote_vcont_probe (struct remote_state *rs, char *buf)
d2276 2
d2280 1
a2280 1
  getpkt (buf, rs->remote_packet_size, 0);
a2333 3
  buf = xmalloc (rs->remote_packet_size);
  old_cleanup = make_cleanup (xfree, buf);

d2335 1
a2335 1
    remote_vcont_probe (rs, buf);
d2338 1
a2338 4
    {
      do_cleanups (old_cleanup);
      return 0;
    }
d2386 1
a2386 1
  make_cleanup (xfree, outbuf);
d2405 1
a2405 1
  char *buf = alloca (rs->remote_packet_size);
d2675 1
a2675 1
  char *buf = alloca (rs->remote_packet_size);
d2687 1
a2687 1
      getpkt (buf, rs->remote_packet_size, 1);
d2864 1
a2864 1
  char *buf = alloca (rs->remote_packet_size);
d2883 1
a2883 1
      getpkt (buf, rs->remote_packet_size, wait_forever_enabled_p);
d3067 1
a3067 1
  char *buf = alloca (rs->remote_packet_size), *p;
d3075 1
a3075 1
  remote_send (buf, rs->remote_packet_size);
d3112 1
a3112 1
  char *buf = alloca (rs->remote_packet_size);
d3155 1
a3155 1
  remote_send (buf, rs->remote_packet_size);
d3177 1
a3177 1
      getpkt (buf, rs->remote_packet_size, 0);
d3276 1
a3276 1
  char *buf = alloca (rs->remote_packet_size);
d3284 1
a3284 1
  remote_send (buf, rs->remote_packet_size);
a3296 1
  char *buf;
d3347 1
a3347 2
  buf = alloca (rs->remote_packet_size);
  p = buf;
d3351 1
a3351 1
  remote_send (buf, rs->remote_packet_size);
d3437 1
a3437 1
	char *buf = alloca (rs->remote_packet_size);
d3449 1
a3449 1
	getpkt (buf, rs->remote_packet_size, 0);
d3482 1
a3485 1
  long sizeof_buf;
d3497 3
a3499 4
  /* Compute the size, and then allocate space for the largest
     possible packet.  Include space for an extra trailing NUL.  */
  sizeof_buf = payload_size + 1;
  buf = alloca (sizeof_buf);
d3606 1
a3606 1
  getpkt (buf, sizeof_buf, 0);
d3641 1
a3643 1
  long sizeof_buf;
a3645 1
  /* Create a buffer big enough for this packet.  */
d3647 3
a3649 2
  sizeof_buf = max_buf_size + 1; /* Space for trailing NULL.  */
  buf = alloca (sizeof_buf);
d3671 1
a3671 1
      getpkt (buf, sizeof_buf, 0);
d3770 4
a3773 2
/* Send the command in BUF to the remote machine, and read the reply
   into BUF.  Report an error if we get an error reply.  */
d3776 2
a3777 2
remote_send (char *buf,
	     long sizeof_buf)
d3779 1
a3779 1
  putpkt (buf);
d3782 2
a3783 2
  if (buf[0] == 'E')
    error (_("Remote failure reply: %s"), buf);
a3815 2
  long sizeof_junkbuf = rs->remote_packet_size;
  char *junkbuf = alloca (sizeof_junkbuf);
d3897 1
a3897 1
		read_frame (junkbuf, sizeof_junkbuf);
d3931 36
d3968 3
a3970 3
   into BUF, verifying the checksum, length, and handling run-length
   compression.  No more than sizeof_buf-1 characters are read so that
   the buffer can be NUL terminated.
d3977 2
a3978 2
read_frame (char *buf,
	    long sizeof_buf)
d3983 1
a3989 1
      /* ASSERT (bc < sizeof_buf - 1) - space for trailing NULL.  */
d4056 1
a4056 3
	    if (repeat > 0 && repeat <= 255
		&& bc > 0
                && bc + repeat - 1 < sizeof_buf - 1)
d4058 8
d4072 1
a4072 4
	    printf_filtered (_("Repeat count %d too large for buffer: "), 
			     repeat);
	    puts_filtered (buf);
	    puts_filtered ("\n");
d4076 1
a4076 1
	  if (bc < sizeof_buf - 1)
d4078 4
a4081 3
	      buf[bc++] = c;
	      csum += c;
	      continue;
d4084 3
a4086 6
	  buf[bc] = '\0';
	  puts_filtered ("Remote packet too long: ");
	  puts_filtered (buf);
	  puts_filtered ("\n");

	  return -1;
d4092 4
a4095 3
   store it in BUF.  If FOREVER, wait forever rather than timing out;
   this is used (in synchronous mode) to wait for a target that is is
   executing user code to stop.  */
d4101 2
a4102 2
getpkt (char *buf,
	long sizeof_buf,
d4112 6
a4117 5
   store it in BUF.  If FOREVER, wait forever rather than timing out;
   this is used (in synchronous mode) to wait for a target that is is
   executing user code to stop. If FOREVER == 0, this function is
   allowed to time out gracefully and return an indication of this to
   the caller.  */
d4119 1
a4119 3
getpkt_sane (char *buf,
	long sizeof_buf,
	int forever)
d4126 1
a4126 1
  strcpy (buf, "timeout");
d4178 1
a4178 1
	      fputstr_unfiltered (buf, 0, gdb_stdlog);
d4383 1
a4383 2
      char *buf = alloca (rs->remote_packet_size);
      char *p = buf;
d4393 2
a4394 2
      putpkt (buf);
      getpkt (buf, rs->remote_packet_size, 0);
d4396 1
a4396 1
      switch (packet_ok (buf, &remote_protocol_packets[PACKET_Z0]))
d4434 1
a4434 2
      char *buf = alloca (rs->remote_packet_size);
      char *p = buf;
d4445 2
a4446 2
      putpkt (buf);
      getpkt (buf, rs->remote_packet_size, 0);
d4448 1
a4448 1
      return (buf[0] == 'E');
a4481 1
  char *buf = alloca (rs->remote_packet_size);
d4490 2
a4491 2
  sprintf (buf, "Z%x,", packet);
  p = strchr (buf, '\0');
d4496 2
a4497 2
  putpkt (buf);
  getpkt (buf, rs->remote_packet_size, 0);
d4499 1
a4499 1
  switch (packet_ok (buf, &remote_protocol_packets[PACKET_Z0 + packet]))
a4515 1
  char *buf = alloca (rs->remote_packet_size);
d4524 2
a4525 2
  sprintf (buf, "z%x,", packet);
  p = strchr (buf, '\0');
d4529 2
a4530 2
  putpkt (buf);
  getpkt (buf, rs->remote_packet_size, 0);
d4532 1
a4532 1
  switch (packet_ok (buf, &remote_protocol_packets[PACKET_Z0 + packet]))
d4602 1
a4602 2
  char *buf = alloca (rs->remote_packet_size);
  char *p = buf;
d4622 2
a4623 2
  putpkt (buf);
  getpkt (buf, rs->remote_packet_size, 0);
d4625 1
a4625 1
  switch (packet_ok (buf, &remote_protocol_packets[PACKET_Z1]))
d4643 1
a4643 2
  char *buf = alloca (rs->remote_packet_size);
  char *p = buf;
d4663 2
a4664 2
  putpkt(buf);
  getpkt (buf, rs->remote_packet_size, 0);
d4666 1
a4666 1
  switch (packet_ok (buf, &remote_protocol_packets[PACKET_Z1]))
a4747 1
  char *buf = alloca (rs->remote_packet_size);
d4775 1
a4775 1
      xsnprintf (buf, rs->remote_packet_size, "qCRC:%lx,%lx", 
d4777 1
a4777 1
      putpkt (buf);
d4786 2
a4787 2
      getpkt (buf, rs->remote_packet_size, 0);
      if (buf[0] == 'E')
d4790 1
a4790 1
      if (buf[0] != 'C')
d4793 1
a4793 1
      for (target_crc = 0, tmp = &buf[1]; *tmp; tmp++)
d4822 1
a4822 2
  char *buf2 = alloca (rs->remote_packet_size);
  char *p2 = &buf2[0];
d4872 1
a4872 1
	      snprintf (buf2, rs->remote_packet_size,
d4876 1
a4876 1
	      i = putpkt (buf2);
d4879 3
a4881 3
	      buf2[0] = '\0';
	      getpkt (buf2, rs->remote_packet_size, 0);
	      if (packet_ok (buf2, &remote_protocol_packets[PACKET_qPart_auxv])
d4884 1
a4884 1
	      if (buf2[0] == 'O' && buf2[1] == 'K' && buf2[2] == '\0')
d4887 1
a4887 1
	      i = hex2bin (buf2, readbuf, len);
d4921 1
d4941 1
a4941 1
  i = putpkt (buf2);
d4945 2
a4946 1
  getpkt ((char *) readbuf, len, 0);
d4956 1
a4956 1
  char *buf = alloca (rs->remote_packet_size);
d4976 1
a4976 1
  if (putpkt (buf) < 0)
d4984 1
a4984 1
      getpkt (buf, rs->remote_packet_size, 0);
a5011 1
  char *buf = alloca (rs->remote_packet_size);
d5024 1
a5024 1
  getpkt (buf, rs->remote_packet_size, 0);
d5026 1
a5026 1
  print_packet (buf);
d5196 1
a5196 2
      char *buf = alloca (rs->remote_packet_size);
      char *p = buf;
d5208 3
a5210 3
      putpkt (buf);
      getpkt (buf, rs->remote_packet_size, 0);
      result = packet_ok (buf, &remote_protocol_packets[PACKET_qGetTLSAddr]);
d5215 1
a5215 1
	  unpack_varlen_hex (buf, &result);
@


1.203.2.1
log
@2006-03-31  Michael Snyder  <msnyder@@redhat.com>

	Target interface for reverse execution.
	* remote.c (remote_get_execdir, remote_set_execdir): New methods.
	(_initialize_remote): Add new methods to remote target vector.
	(remote_resume): Check for reverse exec direction, and send
	appropriate command to target.
	(remote_wait): Check target response for NO_HISTORY status.
@
text
@d2403 1
a2403 9
  if (target_get_execution_direction () == EXEC_REVERSE)
    {
      /* We don't pass signals to the target in reverse exec mode.  */
      if (info_verbose && siggnal != TARGET_SIGNAL_0)
	warning (" - Can't pass signal %d to target in reverse: ignored.\n",
		 siggnal);
      strcpy (buf, step ? "bs" : "bc");
    }
  else if (siggnal != TARGET_SIGNAL_0)
a2676 5
	  if (buf[1] == '0' && buf[2] == '6')
	    {
	      status->kind = TARGET_WAITKIND_NO_HISTORY;
	      goto got_status;
	    }
a5182 29
/* Reverse execution.  
   FIXME: set up as a capability.  */
static enum exec_direction_kind remote_execdir = EXEC_FORWARD;

static enum exec_direction_kind remote_get_execdir (void)
{
  if (remote_debug && info_verbose)
    printf_filtered ("remote execdir is %s\n", 
		     remote_execdir == EXEC_FORWARD ? "forward" :
		     remote_execdir == EXEC_REVERSE ? "reverse" :
		     "unknown");
  return remote_execdir;
}

static int remote_set_execdir (enum exec_direction_kind dir)
{
  if (remote_debug && info_verbose)
    printf_filtered ("Set remote execdir: %s\n",
		     dir == EXEC_FORWARD ? "forward" :
		     dir == EXEC_REVERSE ? "reverse" :
		     "bad direction");

  /* FIXME: check target for capability.  */
  if (dir == EXEC_FORWARD || dir == EXEC_REVERSE)
    return (remote_execdir = dir);
  else
    return EXEC_ERROR;
}

a5229 2
  remote_ops.to_get_execdir = remote_get_execdir;
  remote_ops.to_set_execdir = remote_set_execdir;
@


1.202
log
@	* remote.c: Add an enumeration for configurable remote
	packets.
	(remote_protocol_packets, set_remote_protocol_packet_cmd)
	(show_remote_protocol_packet_cmd): New.
	(remote_protocol_vcont)
	(set_remote_protocol_vcont_packet_cmd)
	(show_remote_protocol_vcont_packet_cmd)
	(remote_protocol_qSymbol)
	(set_remote_protocol_qSymbol_packet_cmd)
	(show_remote_protocol_qSymbol_packet_cmd)
	(remote_protocol_P, set_remote_protocol_P_packet_cmd)
	(show_remote_protocol_P_packet_cmd)
	(remote_protocol_Z)
	(set_remote_protocol_Z_software_bp_packet_cmd)
	(show_remote_protocol_Z_software_bp_packet_cmd)
	(set_remote_protocol_Z_hardware_bp_packet_cmd)
	(show_remote_protocol_Z_hardware_bp_packet_cmd)
	(set_remote_protocol_Z_write_wp_packet_cmd)
	(show_remote_protocol_Z_write_wp_packet_cmd)
	(set_remote_protocol_Z_read_wp_packet_cmd)
	(show_remote_protocol_Z_read_wp_packet_cmd)
	(set_remote_protocol_Z_access_wp_packet_cmd)
	(show_remote_protocol_Z_access_wp_packet_cmd)
	(remote_protocol_binary_download)
	(set_remote_protocol_binary_download_cmd)
	(show_remote_protocol_binary_download_cmd)
	(remote_protocol_qPart_auxv)
	(set_remote_protocol_qPart_auxv_packet_cmd)
	(show_remote_protocol_qPart_auxv_packet_cmd)
	(remote_protocol_qGetTLSAddr)
	(set_remote_protocol_qGetTLSAddr_packet_cmd)
	(show_remote_protocol_qGetTLSAddr_packet_cmd)
	(remote_protocol_p)
	(set_remote_protocol_p_packet_cmd)
	(show_remote_protocol_p_packet_cmd): Delete.

	(init_all_packet_configs): Simplify.
	(set_remote_protocol_Z_packet_cmd)
	(show_remote_protocol_Z_packet_cmd)
	(remote_check_symbols, remote_vcont_probe, remote_vcont_resume)
	(remote_fetch_registers, remote_prepare_to_store)
	(remote_store_registers, check_binary_download)
	(remote_write_bytes, remote_insert_breakpoint)
	(remote_remove_breakpoint, remote_insert_watchpoint)
	(remote_remove_watchpoint, remote_insert_hw_breakpoint)
	(remote_remove_hw_breakpoint, remote_xfer_partial)
	(remote_get_thread_local_address): Update for packet array.
	(_initialize_remote): Likewise; also update for common
	set/show commands.
@
text
@d326 1
a326 1
/* This is non-zero if taregt stopped for a watchpoint.  */
a328 1

@


1.202.2.1
log
@	* gdb/remote.c (remote_fetch_registers): Don't warn about short
	register packet if we've not set the expected value.
@
text
@d3181 1
a3181 1
  if (register_bytes_found && i != register_bytes_found)
@


1.202.2.2
log
@	* gdb/remote.c (remote_fetch_registers): Revert bogus change.
@
text
@d3181 1
a3181 1
  if (i != register_bytes_found)
@


1.202.2.3
log
@Merge XML and VFP support to this branch.
@
text
@a47 1
#include "available.h"
a190 8
static void set_remote_protocol_packet_cmd (char *args, int from_tty,
					    struct cmd_list_element *c);

static void show_remote_protocol_packet_cmd (struct ui_file *file,
					     int from_tty,
					     struct cmd_list_element *c,
					     const char *value);

a192 5
/* For "set remote" and "show remote".  */

static struct cmd_list_element *remote_set_cmdlist;
static struct cmd_list_element *remote_show_cmdlist;

d217 1
a217 1
     (making an array NUM_REGS in size).  */
a230 4

  /* This flag is set if we negotiated packet size explicitly (and
     can bypass various heuristics).  */
  int explicit_packet_size;
a242 14
static int
compare_pnums (const void *lhs_, const void *rhs_)
{
  const struct packet_reg * const *lhs = lhs_;
  const struct packet_reg * const *rhs = rhs_;

  if ((*lhs)->pnum < (*rhs)->pnum)
    return -1;
  else if ((*lhs)->pnum == (*rhs)->pnum)
    return 0;
  else
    return 1;
}

d246 1
a246 1
  int regnum, num_remote_regs, offset;
a247 1
  struct packet_reg **remote_regs;
d249 6
a254 4
  /* Assume a 1:1 regnum<->pnum table unless the available registers
     interface informs us otherwise.  */
  rs->regs = GDBARCH_OBSTACK_CALLOC (gdbarch, NUM_REGS, struct packet_reg);
  for (regnum = 0; regnum < NUM_REGS; regnum++)
d257 1
a257 1
      r->pnum = available_register_target_regnum (gdbarch, regnum);
d259 7
a267 23
  /* Define the g/G packet format as the contents of each register
     with a remote protocol number, in order of ascending protocol
     number.  */

  remote_regs = alloca (NUM_REGS * sizeof (struct packet_reg *));
  for (num_remote_regs = 0, regnum = 0; regnum < NUM_REGS; regnum++)
    if (rs->regs[regnum].pnum != -1)
      remote_regs[num_remote_regs++] = &rs->regs[regnum];

  qsort (remote_regs, num_remote_regs, sizeof (struct packet_reg *),
	 compare_pnums);

  for (regnum = 0, offset = 0; regnum < num_remote_regs; regnum++)
    {
      remote_regs[regnum]->in_g_packet = 1;
      remote_regs[regnum]->offset = offset;
      offset += register_size (current_gdbarch, remote_regs[regnum]->regnum);
    }

  /* Record the maximum possible size of the g packet - it may turn out
     to be smaller.  */
  rs->sizeof_g_packet = offset;

d295 1
a295 1
  if (regnum < 0 && regnum >= NUM_REGS)
d309 1
a309 1
  for (i = 0; i < NUM_REGS; i++)
d430 4
a433 7

      /* Limit it to the size of the targets ``g'' response unless we have
	 permission from the stub to use a larger packet size.  */
      if (!rs->explicit_packet_size
	  && rs->actual_register_packet_size > 0
	  && what_they_get > rs->actual_register_packet_size)
	what_they_get = rs->actual_register_packet_size;
a568 1
    int must_be_reported;
d632 5
a636 2
		       int legacy,
		       int must_be_reported)
a645 1
  config->must_be_reported = must_be_reported;
d654 2
a655 3
				set_remote_protocol_packet_cmd,
				show_remote_protocol_packet_cmd,
				&remote_set_cmdlist, &remote_show_cmdlist);
d662 1
a662 1
		     &remote_set_cmdlist);
d664 1
a664 1
		     &remote_show_cmdlist);
a734 1
  PACKET_qOffsets,
a743 1
  PACKET_qPart_features,
a1798 3
  if (remote_protocol_packets[PACKET_qOffsets].support == PACKET_DISABLE)
    return;

d1802 4
a1805 1
  switch (packet_ok (buf, &remote_protocol_packets[PACKET_qOffsets]))
a1806 6
    case PACKET_OK:
      break;
    case PACKET_UNKNOWN:
      return;			/* Return silently.  Stub doesn't support
				   this command.  */
    case PACKET_ERROR:
a2005 102
remote_query_packet_info (void)
{
  struct remote_state *rs = get_remote_state ();
  char *reply, *next;
  int i;

  reply = alloca (rs->remote_packet_size);

  putpkt ("qPacketInfo");
  getpkt (reply, rs->remote_packet_size, 0);

  next = reply;
  while (*next)
    {
      enum packet_support is_supported;
      char *p, *end, *name_end;

      p = next;
      end = strchr (p, ';');
      if (end == NULL)
	{
	  end = p + strlen (p);
	  next = end;
	}
      else
	{
	  if (end == p)
	    {
	      warning (_("empty item in \"qPacketInfo\" response"));
	      continue;
	    }

	  *end = '\0';
	  next = end + 1;
	}

      name_end = strchr (p, '=');
      if (name_end)
	{
	  /* This is a name=value entry.  */
	  char *value;

	  value = name_end + 1;
	  *name_end = '\0';

	  if (strcmp (p, "PacketSize") == 0)
	    {
	      int packet_size;
	      char *value_end;

	      packet_size = strtol (value, &value_end, 16);
	      if (*value != '\0' && *value_end == '\0')
		{
		  /* MERGE WARNING: This needs the infinite length
		     incoming packet support, which in turn needs us
		     to adjust rs->buf_size here.  */
		  if (packet_size > MAX_REMOTE_PACKET_SIZE)
		    {
		      warning (_("limiting remote suggested packet size (%d bytes) to %d"),
			       packet_size, MAX_REMOTE_PACKET_SIZE);
		      packet_size = MAX_REMOTE_PACKET_SIZE;
		    }
		  rs->remote_packet_size = packet_size;
		  rs->explicit_packet_size = 1;

		  continue;
		}
	    }

	  /* Should we even warn about this?  For testing, at least, yes.  */
	  warning (_("unrecognized item \"%s=%s\" in \"qPacketInfo\" response"),
		   p, value);
	  continue;
	}

      if (end[-1] != '+' && end[-1] != '-')
	{
	  warning (_("unrecognized item \"%s\" in \"qPacketInfo\" response"), p);
	  continue;
	}

      is_supported = (end[-1] == '+') ? PACKET_ENABLE : PACKET_DISABLE;
      end[-1] = '\0';

      for (i = 0; i < PACKET_MAX; i++)
	if (strcmp (remote_protocol_packets[i].name, p) == 0)
	  {
	    if (remote_protocol_packets[i].support == PACKET_SUPPORT_UNKNOWN)
	      remote_protocol_packets[i].support = is_supported;
	    break;
	  }
    }

  /* Default some unmentioned packets to unsupported.  */
  for (i = 0; i < PACKET_MAX; i++)
    if (remote_protocol_packets[i].must_be_reported
	&& remote_protocol_packets[i].support == PACKET_SUPPORT_UNKNOWN)
      remote_protocol_packets[i].support = PACKET_DISABLE;
}


static void
a2066 5
  /* The first packet we send to the target is the optional "supported
     packets" request.  If the target can answer this, it will tell us
     which later probes to skip.  */
  remote_query_packet_info ();

a2090 8
  /* FIXME: This is a hack.  Default to an architecture with no
     available features here, and set the real one further down.
     Ideally, we ought to set the real architecture here (and
     also in remote_create_inferior maybe?) but not redo it
     in post_inferior_created below.  That will take some rearranging
     that I don't have time for right now.  */
  arch_set_available_features (NULL);

d3034 6
a3039 1
/* Fetch a single register using a 'p' packet.  */
d3042 1
a3042 1
fetch_register_using_p (struct packet_reg *reg)
a3048 6
  if (remote_protocol_packets[PACKET_p].support == PACKET_DISABLE)
    return 0;

  if (reg->pnum == -1)
    return 0;

d3051 1
a3051 1
  p += hexnumstr (p, reg->pnum);
d3055 4
a3058 10
  switch (packet_ok (buf, &remote_protocol_packets[PACKET_p]))
    {
    case PACKET_OK:
      break;
    case PACKET_UNKNOWN:
      return 0;
    case PACKET_ERROR:
      error (_("Could not fetch register \"%s\""),
	     gdbarch_register_name (current_gdbarch, reg->regnum));
    }
d3060 1
d3063 2
a3064 2
      regcache_raw_supply (current_regcache, reg->regnum, NULL);
      set_register_cached (reg->regnum, -1);
d3068 1
d3074 5
a3078 1
	error (_("fetch_register_using_p: early buf termination"));
d3082 1
a3082 1
  regcache_raw_supply (current_regcache, reg->regnum, regp);
a3085 2
/* Fetch the registers included in the target's 'g' packet.  */

d3087 1
a3087 1
fetch_registers_using_g (void)
d3091 1
a3091 1
  int i, buf_len;
d3093 1
a3093 1
  char *regs;
d3097 35
d3135 1
a3135 9
  buf_len = strlen (buf);

  /* Sanity check the received packet.  */
  if (buf_len % 2 != 0)
    error (_("Remote 'g' packet reply is of odd length: %s"), buf);
  if (REGISTER_BYTES_OK_P () && !REGISTER_BYTES_OK (buf_len / 2))
    error (_("Remote 'g' packet reply is too short: %s"), buf);

  /* Save the size of the packet sent to us by the target.  It is used
d3138 2
a3139 30
  if (rs->actual_register_packet_size == 0)
    rs->actual_register_packet_size = buf_len;

  /* If this is smaller than we guessed the 'g' packet would be,
     update our records.  A 'g' reply that doesn't include a register's
     value implies either that the register is not available, or that
     the 'p' packet must be used.  */
  /* FIXME: Allow bigger, too.  We have no choice.  We might not have the right
     architecture selected, because we haven't yet sent qPart:features, and
     in turn that means we might clobber the no-features architecture
     with the g packet from a feature-ful architecture.  Really, sending a
     g packet at all before we know the target features is asking for
     trouble.  Order of initialization needs to be changed.  */
  if (buf_len != 2 * rs->sizeof_g_packet)
    {
      rs->sizeof_g_packet = buf_len / 2;

      for (i = 0; i < NUM_REGS; i++)
	{
	  if (rs->regs[i].pnum == -1)
	    continue;

	  if (rs->regs[i].offset >= rs->sizeof_g_packet)
	    rs->regs[i].in_g_packet = 0;
	  else
	    rs->regs[i].in_g_packet = 1;
	}
    }

  regs = alloca (rs->sizeof_g_packet);
d3165 9
a3173 5
      if (p[0] == 0 || p[1] == 0)
	/* This shouldn't happen - we adjusted sizeof_g_packet above.  */
	internal_error (__FILE__, __LINE__,
			"unexpected end of 'g' packet reply");

d3181 9
d3192 1
a3192 1
    for (i = 0; i < NUM_REGS; i++)
d3198 5
a3202 3
	      /* This shouldn't happen - we adjusted in_g_packet above.  */
	      internal_error (__FILE__, __LINE__,
			      "unexpected end of 'g' packet reply");
a3218 46
static void
remote_fetch_registers (int regnum)
{
  struct remote_state *rs = get_remote_state ();
  int i;

  set_thread (PIDGET (inferior_ptid), 1);

  if (regnum >= 0)
    {
      struct packet_reg *reg = packet_reg_from_regnum (rs, regnum);
      gdb_assert (reg != NULL);

      /* If this register might be in the 'g' packet, try that first -
	 we are likely to read more than one register.  If this is the
	 first 'g' packet, we might be overly optimistic about its
	 contents, so fall back to 'p'.  */
      if (reg->in_g_packet)
	{
	  fetch_registers_using_g ();
	  if (reg->in_g_packet)
	    return;
	}

      if (fetch_register_using_p (reg))
	return;

      /* This register is not available.  */
      regcache_raw_supply (current_regcache, reg->regnum, NULL);
      set_register_cached (reg->regnum, -1);

      return;
    }

  fetch_registers_using_g ();

  for (i = 0; i < NUM_REGS; i++)
    if (!rs->regs[i].in_g_packet)
      if (!fetch_register_using_p (&rs->regs[i]))
	{
	  /* This register is not available.  */
	  regcache_raw_supply (current_regcache, i, NULL);
	  set_register_cached (i, -1);
	}
}

d3249 1
a3249 1
store_register_using_P (struct packet_reg *reg)
d3252 1
a3257 6
  if (remote_protocol_packets[PACKET_P].support == PACKET_DISABLE)
    return 0;

  if (reg->pnum == -1)
    return 0;

d3264 1
a3264 12
  switch (packet_ok (buf, &remote_protocol_packets[PACKET_P]))
    {
    case PACKET_OK:
      return 1;
    case PACKET_ERROR:
      error (_("Could not write register \"%s\""),
	     gdbarch_register_name (current_gdbarch, reg->regnum));
    case PACKET_UNKNOWN:
      return 0;
    default:
      internal_error (__FILE__, __LINE__, _("Bad result from packet_ok"));
    }
d3267 1
d3272 1
a3272 1
store_registers_using_G ()
d3279 31
d3316 1
a3316 1
    for (i = 0; i < NUM_REGS; i++)
d3329 2
a3330 3
  /* remote_prepare_to_store insures that rs->sizeof_g_packet gets
     updated.  */
  bin2hex (regs, p, rs->sizeof_g_packet);
a3332 43

/* Store register REGNUM, or all registers if REGNUM == -1, from the contents
   of the register cache buffer.  FIXME: ignores errors.  */

static void
remote_store_registers (int regnum)
{
  struct remote_state *rs = get_remote_state ();
  int i;

  set_thread (PIDGET (inferior_ptid), 1);

  if (regnum >= 0)
    {
      struct packet_reg *reg = packet_reg_from_regnum (rs, regnum);
      gdb_assert (reg != NULL);

      /* Always prefer to store registers using the 'P' packet if
	 possible; we often change only a small number of registers.
         Sometimes we change a larger number; we'd need help from a
	 higher layer to know to use 'G'.  */
      if (store_register_using_P (reg))
	return;

      /* For now, don't complain if we have no way to write the
	 register.  GDB loses track of unavailable registers too
	 easily.  Some day, this may be an error.  We don't have
	 any way to read the register, either... */
      if (!reg->in_g_packet)
	return;

      store_registers_using_G ();
      return;
    }

  store_registers_using_G ();

  for (i = 0; i < NUM_REGS; i++)
    if (!rs->regs[i].in_g_packet)
      if (!store_register_using_P (&rs->regs[i]))
	/* See above for why we do not issue an error here.  */
	continue;
}
a4765 43
/* Read OBJECT_NAME/ANNEX from the remote target using a qPart packet.
   Data at OFFSET, of up to LEN bytes, is read into READBUF; the
   number of bytes read is returned, or 0 for EOF, or -1 for error.
   The number of bytes read may be less than LEN without indicating an
   EOF.  PACKET is checked and updated to indicate whether the remote
   target supports this object.  */

static LONGEST
remote_read_qpart (struct target_ops *ops, const char *object_name,
		   const char *annex,
		   gdb_byte *readbuf, ULONGEST offset, LONGEST len,
		   struct packet_config *packet)
{
  struct remote_state *rs = get_remote_state ();
  char *buf2 = alloca (rs->remote_packet_size);
  unsigned int total = 0;
  LONGEST i, n;

  if (packet->support == PACKET_DISABLE)
    return -1;

  n = min ((rs->remote_packet_size - 2) / 2, len);
  snprintf (buf2, rs->remote_packet_size, "qPart:%s:read:%s:%s,%s",
	    object_name, annex ? annex : "",
	    phex_nz (offset, sizeof offset),
	    phex_nz (n, sizeof n));
  i = putpkt (buf2);
  if (i < 0)
    return -1;

  buf2[0] = '\0';
  getpkt (buf2, rs->remote_packet_size, 0);
  if (packet_ok (buf2, packet) != PACKET_OK)
    return -1;

  if (buf2[0] == 'O' && buf2[1] == 'K' && buf2[2] == '\0')
    return 0;		/* Got EOF indicator.  */

  /* Got some data.  */
  i = hex2bin (buf2, readbuf, len);
  return i;
}

d4773 2
a4774 1
  char *buf2, *p2;
d4818 33
a4850 7
      gdb_assert (annex == NULL);
      return remote_read_qpart (ops, "auxv", annex, readbuf, offset, len,
				&remote_protocol_packets[PACKET_qPart_auxv]);

    case TARGET_OBJECT_AVAILABLE_FEATURES:
      return remote_read_qpart (ops, "features", annex, readbuf, offset, len,
				&remote_protocol_packets[PACKET_qPart_features]);
a4872 3
  buf2 = alloca (rs->remote_packet_size);
  p2 = &buf2[0];

a5223 1
  remote_ops.to_available_features = available_features_from_target_object;
a5348 2
  remote_async_ops.to_available_features
    = available_features_from_target_object;
d5382 3
d5562 5
a5566 1
			 "X", "binary-download", 1, 0);
d5569 5
a5573 4
			 "vCont", "verbose-resume", 0, 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_qOffsets],
			 "qOffsets", "load-offsets", 0, 0);
d5576 5
a5580 1
			 "qSymbol", "symbol-lookup", 0, 0);
d5583 5
a5587 1
			 "P", "set-register", 1, 0);
d5590 5
a5594 1
			 "p", "fetch-register", 1, 0);
d5597 5
a5601 1
			 "Z0", "software-breakpoint", 0, 0);
d5604 5
a5608 1
			 "Z1", "hardware-breakpoint", 0, 0);
d5611 5
a5615 1
			 "Z2", "write-watchpoint", 0, 0);
d5618 5
a5622 1
			 "Z3", "read-watchpoint", 0, 0);
d5625 5
a5629 1
			 "Z4", "access-watchpoint",  0, 0);
d5632 5
a5636 4
			 "qPart:auxv", "read-aux-vector", 0, 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_qPart_features],
			 "qPart:features", "target-features", 0, 1);
d5640 4
a5643 1
			 0, 0);
@


1.202.2.4
log
@	* gdb/remote-fileio.c (remote_fileio_reset): New.
	* gdb/remote-fileio.h (remote_fileio_reset): Prototype.
	* gdb/remote.c (extended_remote_restart, remote_open_1): Call it.
@
text
@a1822 2
  remote_fileio_reset ();
  
a2178 2
  remote_fileio_reset ();
  
@


1.202.2.5
log
@	* gdb/remote.c (remote_insert_watchpoint): Return -1, rather than
	fatal error if packet is disabled.
	(remote_remove_watchpoint, remote_insert_hw_breakpoint,
	remote_remove_hw_breakpoint): Likewise.
	Revert my 2006-06-01  Nathan Sidwell  <nathan@@codesourcery.com>
	change to breakpoint.c
@
text
@d4673 3
a4675 1
    return -1;
d4708 4
a4711 2
    return -1;
  
d4799 4
a4802 2
    return -1;
  
d4841 3
a4843 1
    return -1;
@


1.202.2.6
log
@	* gdb/remote.c (remote_open_1): Do preopen tasks before
	irreversably destroying state.
@
text
@a2180 4
  target_preopen (from_tty);

  unpush_target (target);

d2186 4
@


1.202.2.7
log
@Backport rs->buf patch from HEAD.
@
text
@d67 1
a67 1
static int getpkt_sane (char **buf, long *sizeof_buf, int forever);
d108 1
a108 1
static void remote_send (char **buf, long *sizeof_buf_p);
d136 1
a136 3
static void skip_frame (void);

static long read_frame (char **buf_p, long *sizeof_buf);
a245 9
  /* A buffer to use for incoming packets, and its current size.  The
     buffer is grown dynamically for larger incoming packets.
     Outgoing packets may also be constructed in this buffer.
     BUF_SIZE is always at least REMOTE_PACKET_SIZE;
     REMOTE_PACKET_SIZE should be used to limit the length of outgoing
     packets.  */
  char *buf;
  long buf_size;

a335 8
  /* Create the buffer at a default size.  Note that this would
     leak memory if the gdbarch were ever destroyed; there's no
     way to register a destructor for it, and we can't realloc
     using the gdbarch obstack.  But gdbarches are never
     destroyed.  */
  rs->buf_size = rs->remote_packet_size;
  rs->buf = xmalloc (rs->buf_size);

a488 9

  /* Make sure there is room in the global buffer for this packet
     (including its trailing NUL byte).  */
  if (rs->buf_size < what_they_get + 1)
    {
      rs->buf_size = 2 * what_they_get;
      rs->buf = xrealloc (rs->buf, 2 * what_they_get);
    }

d940 1
a940 1
  char *buf = rs->buf;
d958 1
a958 1
  getpkt (&rs->buf, &rs->buf_size, 0);
a969 1
  struct remote_state *rs = get_remote_state ();
d971 1
a971 1
  char *buf = rs->buf;
d974 1
a974 1
    xsnprintf (buf, rs->remote_packet_size, "T-%08x", -tid);
d976 1
a976 1
    xsnprintf (buf, rs->remote_packet_size, "T%08x", tid);
d978 1
a978 1
  getpkt (&rs->buf, &rs->buf_size, 0);
d1387 1
a1387 1
  char *limit = pkt + rs->buf_size; /* Plausible parsing limit.  */
d1478 1
a1478 1
  char *threadinfo_pkt = rs->buf;
d1482 1
a1482 1
  getpkt (&rs->buf, &rs->buf_size, 0);
d1516 1
a1516 1
  limit = pkt + (rs->buf_size - BUF_THREAD_ID_SIZE);
d1539 2
a1540 1
  char *threadlist_packet = rs->buf;
d1547 4
a1550 3
  pack_threadlist_request (rs->buf, startflag, result_limit, nextthread);
  putpkt (rs->buf);
  getpkt (&rs->buf, &rs->buf_size, 0);
d1553 1
a1553 1
    parse_threadlist_response (rs->buf + 2, result_limit, &echo_nextthread,
d1658 1
a1658 1
  char *buf = rs->buf;
d1661 1
a1661 1
  getpkt (&rs->buf, &rs->buf_size, 0);
d1697 1
d1707 2
a1708 2
      bufp = rs->buf;
      getpkt (&rs->buf, &rs->buf_size, 0);
d1727 2
a1728 2
	      bufp = rs->buf;
	      getpkt (&rs->buf, &rs->buf_size, 0);
d1758 1
a1766 2
      char *bufp = rs->buf;

d1770 1
a1770 1
      getpkt (&rs->buf, &rs->buf_size, 0);
d1816 1
d1820 2
a1821 2
  xsnprintf (rs->buf, rs->remote_packet_size, "R%x", 0);
  putpkt (rs->buf);
d1828 1
a1828 1
  getpkt (&rs->buf, &rs->buf_size, 0);
d1847 1
a1847 1
  char *buf = rs->buf;
d1857 1
a1857 1
  getpkt (&rs->buf, &rs->buf_size, 0);
d2019 2
a2020 5
  /* Allocate a message buffer.  We can't reuse the input buffer in RS,
     because we need both at the same time.  */
  msg = alloca (rs->remote_packet_size);

  reply = rs->buf;
d2025 2
a2026 2
  getpkt (&rs->buf, &rs->buf_size, 0);
  packet_ok (rs->buf, &remote_protocol_packets[PACKET_qSymbol]);
d2041 1
a2041 1
      getpkt (&rs->buf, &rs->buf_size, 0);
d2069 1
a2069 1
  char *next;
d2072 2
d2075 1
a2075 1
  getpkt (&rs->buf, &rs->buf_size, 0);
d2077 1
a2077 1
  next = rs->buf;
d2119 3
a2158 10
  /* If we increased the packet size, make sure to increase the global
     buffer size also.  We delay this until after parsing the entire
     qSupported packet, because this is the same buffer we were
     parsing.  */
  if (rs->buf_size < rs->remote_packet_size)
    {
      rs->buf_size = rs->remote_packet_size;
      rs->buf = xrealloc (rs->buf, rs->buf_size);
    }

d2304 1
d2306 1
a2306 1
      getpkt (&rs->buf, &rs->buf_size, 0);
d2324 1
d2330 2
a2331 2
  strcpy (rs->buf, "D");
  remote_send (&rs->buf, &rs->buf_size);
d2425 1
a2425 1
remote_vcont_probe (struct remote_state *rs)
a2426 2
  char *buf = rs->buf;

d2429 1
a2429 1
  getpkt (&rs->buf, &rs->buf_size, 0);
d2483 3
d2487 1
a2487 1
    remote_vcont_probe (rs);
d2490 4
a2493 1
    return 0;
d2541 1
a2541 1
  old_cleanup = make_cleanup (xfree, outbuf);
d2560 1
a2560 1
  char *buf = rs->buf;
d2830 1
a2830 1
  char *buf = rs->buf;
d2842 1
a2842 1
      getpkt (&rs->buf, &rs->buf_size, 1);
d3019 1
a3019 1
  char *buf = rs->buf;
d3038 1
a3038 1
      getpkt (&rs->buf, &rs->buf_size, wait_forever_enabled_p);
d3217 1
a3217 1
  char *buf = rs->buf, *p;
d3231 1
a3231 1
  remote_send (&rs->buf, &rs->buf_size);
d3270 1
d3277 2
a3278 2
  sprintf (rs->buf, "g");
  remote_send (&rs->buf, &rs->buf_size);
d3280 1
a3280 1
  buf_len = strlen (rs->buf);
d3284 1
a3284 1
    error (_("Remote 'g' packet reply is of odd length: %s"), rs->buf);
d3286 1
a3286 1
    error (_("Remote 'g' packet reply is too short: %s"), rs->buf);
d3328 4
a3331 4
  while ((rs->buf[0] < '0' || rs->buf[0] > '9')
	 && (rs->buf[0] < 'A' || rs->buf[0] > 'F')
	 && (rs->buf[0] < 'a' || rs->buf[0] > 'f')
	 && rs->buf[0] != 'x')	/* New: unavailable register value.  */
d3336 1
a3336 1
      getpkt (&rs->buf, &rs->buf_size, 0);
d3343 1
a3343 1
  p = rs->buf;
d3365 1
a3365 1
	    if (r->offset * 2 >= strlen (rs->buf))
d3369 1
a3369 1
	    else if (rs->buf[r->offset * 2] == 'x')
d3371 1
a3371 1
		gdb_assert (r->offset * 2 < strlen (rs->buf));
d3465 1
a3465 1
  char *buf = rs->buf;
d3479 1
a3479 1
  remote_send (&rs->buf, &rs->buf_size);
d3502 1
d3522 2
a3523 1
  p = rs->buf;
d3528 1
a3528 1
  remote_send (&rs->buf, &rs->buf_size);
d3657 1
a3657 1
	char *buf = rs->buf;
d3669 1
a3669 1
	getpkt (&rs->buf, &rs->buf_size, 0);
a3701 1
  struct remote_state *rs = get_remote_state ();
d3705 1
d3717 4
a3720 3
  /* The packet buffer will be large enough for the payload;
     get_memory_packet_size ensures this.  */
  buf = rs->buf;
d3827 1
a3827 1
  getpkt (&rs->buf, &rs->buf_size, 0);
a3861 1
  struct remote_state *rs = get_remote_state ();
d3864 1
d3867 1
d3869 2
a3870 3
  /* The packet buffer will be large enough for the payload;
     get_memory_packet_size ensures this.  */
  buf = rs->buf;
d3892 1
a3892 1
      getpkt (&rs->buf, &rs->buf_size, 0);
d3991 2
a3992 4
/* Send the command in *BUF to the remote machine, and read the reply
   into *BUF.  Report an error if we get an error reply.  Resize
   *BUF using xrealloc if necessary to hold the result, and update
   *SIZEOF_BUF.  */
d3995 2
a3996 2
remote_send (char **buf,
	     long *sizeof_buf)
d3998 1
a3998 1
  putpkt (*buf);
d4001 2
a4002 2
  if ((*buf)[0] == 'E')
    error (_("Remote failure reply: %s"), *buf);
d4035 2
d4118 1
a4118 1
		skip_frame ();
a4151 36
/* Come here after finding the start of a frame when we expected an
   ack.  Do our best to discard the rest of this packet.  */

static void
skip_frame (void)
{
  int c;

  while (1)
    {
      c = readchar (remote_timeout);
      switch (c)
	{
	case SERIAL_TIMEOUT:
	  /* Nothing we can do.  */
	  return;
	case '#':
	  /* Discard the two bytes of checksum and stop.  */
	  c = readchar (remote_timeout);
	  if (c >= 0)
	    c = readchar (remote_timeout);

	  return;
	case '*':		/* Run length encoding.  */
	  /* Discard the repeat count.  */
	  c = readchar (remote_timeout);
	  if (c < 0)
	    return;
	  break;
	default:
	  /* A regular character.  */
	  break;
	}
    }
}

d4153 3
a4155 3
   into *BUF, verifying the checksum, length, and handling run-length
   compression.  NUL terminate the buffer.  If there is not enough room,
   expand *BUF using xrealloc.
d4162 2
a4163 2
read_frame (char **buf_p,
	    long *sizeof_buf)
a4167 1
  char *buf = *buf_p;
d4174 1
d4241 3
a4243 1
	    if (repeat > 0 && repeat <= 255 && bc > 0)
a4244 8
		if (bc + repeat - 1 >= *sizeof_buf - 1)
		  {
		    /* Make some more room in the buffer.  */
		    *sizeof_buf += repeat;
		    *buf_p = xrealloc (*buf_p, *sizeof_buf);
		    buf = *buf_p;
		  }

d4251 4
a4254 1
	    printf_filtered (_("Invalid run length encoding: %s\n"), buf);
d4258 1
a4258 1
	  if (bc >= *sizeof_buf - 1)
d4260 3
a4262 4
	      /* Make some more room in the buffer.  */
	      *sizeof_buf *= 2;
	      *buf_p = xrealloc (*buf_p, *sizeof_buf);
	      buf = *buf_p;
d4265 6
a4270 3
	  buf[bc++] = c;
	  csum += c;
	  continue;
d4276 3
a4278 4
   store it in *BUF.  Resize *BUF using xrealloc if necessary to hold
   the result, and update *SIZEOF_BUF.  If FOREVER, wait forever
   rather than timing out; this is used (in synchronous mode) to wait
   for a target that is is executing user code to stop.  */
d4284 2
a4285 2
getpkt (char **buf,
	long *sizeof_buf,
d4295 5
a4299 6
   store it in *BUF.  Resize *BUF using xrealloc if necessary to hold
   the result, and update *SIZEOF_BUF.  If FOREVER, wait forever
   rather than timing out; this is used (in synchronous mode) to wait
   for a target that is is executing user code to stop.  If FOREVER ==
   0, this function is allowed to time out gracefully and return an
   indication of this to the caller.  */
d4301 3
a4303 1
getpkt_sane (char **buf, long *sizeof_buf, int forever)
d4310 1
a4310 1
  strcpy (*buf, "timeout");
d4362 1
a4362 1
	      fputstr_unfiltered (*buf, 0, gdb_stdlog);
d4567 2
a4568 1
      char *p = rs->buf;
d4578 2
a4579 2
      putpkt (rs->buf);
      getpkt (&rs->buf, &rs->buf_size, 0);
d4581 1
a4581 1
      switch (packet_ok (rs->buf, &remote_protocol_packets[PACKET_Z0]))
d4619 2
a4620 1
      char *p = rs->buf;
d4631 2
a4632 2
      putpkt (rs->buf);
      getpkt (&rs->buf, &rs->buf_size, 0);
d4634 1
a4634 1
      return (rs->buf[0] == 'E');
d4668 1
d4675 2
a4676 2
  sprintf (rs->buf, "Z%x,", packet);
  p = strchr (rs->buf, '\0');
d4681 2
a4682 2
  putpkt (rs->buf);
  getpkt (&rs->buf, &rs->buf_size, 0);
d4684 1
a4684 1
  switch (packet_ok (rs->buf, &remote_protocol_packets[PACKET_Z0 + packet]))
d4701 1
d4708 2
a4709 2
  sprintf (rs->buf, "z%x,", packet);
  p = strchr (rs->buf, '\0');
d4713 2
a4714 2
  putpkt (rs->buf);
  getpkt (&rs->buf, &rs->buf_size, 0);
d4716 1
a4716 1
  switch (packet_ok (rs->buf, &remote_protocol_packets[PACKET_Z0 + packet]))
d4786 2
a4787 1
  char *p = rs->buf;
d4805 2
a4806 2
  putpkt (rs->buf);
  getpkt (&rs->buf, &rs->buf_size, 0);
d4808 1
a4808 1
  switch (packet_ok (rs->buf, &remote_protocol_packets[PACKET_Z1]))
d4826 2
a4827 1
  char *p = rs->buf;
d4845 2
a4846 2
  putpkt (rs->buf);
  getpkt (&rs->buf, &rs->buf_size, 0);
d4848 1
a4848 1
  switch (packet_ok (rs->buf, &remote_protocol_packets[PACKET_Z1]))
d4930 1
d4958 1
a4958 1
      xsnprintf (rs->buf, rs->remote_packet_size, "qCRC:%lx,%lx",
d4960 1
a4960 1
      putpkt (rs->buf);
d4969 2
a4970 2
      getpkt (&rs->buf, &rs->buf_size, 0);
      if (rs->buf[0] == 'E')
d4973 1
a4973 1
      if (rs->buf[0] != 'C')
d4976 1
a4976 1
      for (target_crc = 0, tmp = &rs->buf[1]; *tmp; tmp++)
d5012 1
d5020 1
a5020 1
  snprintf (rs->buf, rs->remote_packet_size, "qPart:%s:read:%s:%s,%s",
d5024 1
a5024 1
  i = putpkt (rs->buf);
d5028 3
a5030 3
  rs->buf[0] = '\0';
  getpkt (&rs->buf, &rs->buf_size, 0);
  if (packet_ok (rs->buf, packet) != PACKET_OK)
d5033 1
a5033 1
  if (rs->buf[0] == 'O' && rs->buf[1] == 'K' && rs->buf[2] == '\0')
d5037 1
a5037 1
  i = hex2bin (rs->buf, readbuf, len);
d5048 1
a5048 1
  char *p2;
d5121 3
a5123 1
  p2 = rs->buf;
d5143 1
a5143 1
  i = putpkt (rs->buf);
d5147 1
a5147 2
  getpkt (&rs->buf, &rs->buf_size, 0);
  strcpy ((char *) readbuf, rs->buf);
d5157 1
a5157 1
  char *buf = rs->buf;
d5177 1
a5177 1
  if (putpkt (rs->buf) < 0)
d5185 1
a5185 1
      getpkt (&rs->buf, &rs->buf_size, 0);
d5213 1
d5226 1
a5226 1
  getpkt (&rs->buf, &rs->buf_size, 0);
d5228 1
a5228 1
  print_packet (rs->buf);
d5398 2
a5399 1
      char *p = rs->buf;
d5411 3
a5413 3
      putpkt (rs->buf);
      getpkt (&rs->buf, &rs->buf_size, 0);
      result = packet_ok (rs->buf, &remote_protocol_packets[PACKET_qGetTLSAddr]);
d5418 1
a5418 1
	  unpack_varlen_hex (rs->buf, &result);
@


1.202.2.8
log
@Backport get_remote_packet_size from HEAD.
@
text
@d209 6
a214 35
/* Description of the remote protocol state for the currently
   connected target.  This is per-target state, and independent of the
   selected architecture.  */

struct remote_state
{
  /* A buffer to use for incoming packets, and its current size.  The
     buffer is grown dynamically for larger incoming packets.
     Outgoing packets may also be constructed in this buffer.
     BUF_SIZE is always at least REMOTE_PACKET_SIZE;
     REMOTE_PACKET_SIZE should be used to limit the length of outgoing
     packets.  */
  char *buf;
  long buf_size;

  /* If we negotiated packet size explicitly (and thus can bypass
     heuristics for the largest packet size that will not overflow
     a buffer in the stub), this will be set to that packet size.
     Otherwise zero, meaning to use the guessed size.  */
  long explicit_packet_size;
};

/* This data could be associated with a target, but we do not always
   have access to the current target when we need it, so for now it is
   static.  This will be fine for as long as only one target is in use
   at a time.  */
static struct remote_state remote_state;

static struct remote_state *
get_remote_state (void)
{
  return &remote_state;
}

/* Description of the remote protocol for a given architecture.  */
d227 1
a227 1
struct remote_arch_state
d247 13
d266 2
a267 2
static struct remote_arch_state *
get_remote_arch_state (void)
d290 1
a290 2
  struct remote_state *rs = get_remote_state ();
  struct remote_arch_state *rsa;
a292 2
  rsa = GDBARCH_OBSTACK_ZALLOC (gdbarch, struct remote_arch_state);

d295 1
a295 1
  rsa->regs = GDBARCH_OBSTACK_CALLOC (gdbarch, NUM_REGS, struct packet_reg);
d298 1
a298 1
      struct packet_reg *r = &rsa->regs[regnum];
d309 2
a310 2
    if (rsa->regs[regnum].pnum != -1)
      remote_regs[num_remote_regs++] = &rsa->regs[regnum];
d324 1
a324 1
  rsa->sizeof_g_packet = offset;
d332 2
a333 2
     already a full buffer (As of 1999-12-04 that was most stubs).  */
  rsa->remote_packet_size = 400 - 1;
d335 1
a335 4
  /* This one is filled in when a ``g'' packet is received.  */
  rsa->actual_register_packet_size = 0;

  /* Should rsa->sizeof_g_packet needs more space than the
d341 2
a342 2
  if (rsa->sizeof_g_packet > ((rsa->remote_packet_size - 32) / 2))
    rsa->remote_packet_size = (rsa->sizeof_g_packet * 2 + 32);
d344 2
a345 7
  /* Make sure that the packet buffer is plenty big enough for
     this architecture.  */
  if (rs->buf_size < rsa->remote_packet_size)
    {
      rs->buf_size = 2 * rsa->remote_packet_size;
      rs->buf = xrealloc (rs->buf, rs->buf_size);
    }
d347 7
a353 2
  return rsa;
}
d355 1
a355 13
/* Return the current allowed size of a remote packet.  This is
   inferred from the current architecture, and should be used to
   limit the length of outgoing packets.  */
static long
get_remote_packet_size (void)
{
  struct remote_state *rs = get_remote_state ();
  struct remote_arch_state *rsa = get_remote_arch_state ();

  if (rs->explicit_packet_size)
    return rs->explicit_packet_size;

  return rsa->remote_packet_size;
d359 1
a359 1
packet_reg_from_regnum (struct remote_arch_state *rsa, long regnum)
d365 1
a365 1
      struct packet_reg *r = &rsa->regs[regnum];
d372 1
a372 1
packet_reg_from_pnum (struct remote_arch_state *rsa, LONGEST pnum)
d377 1
a377 1
      struct packet_reg *r = &rsa->regs[i];
d448 2
a449 2
   memory read/write packet.  MIN (rsa->remote_packet_size,
   rsa->sizeof_g_packet) is the default.  Some targets need smaller
a468 2
  struct remote_arch_state *rsa = get_remote_arch_state ();

d491 1
a491 1
      what_they_get = get_remote_packet_size ();
d499 4
a502 4
      if (rs->explicit_packet_size == 0
	  && rsa->actual_register_packet_size > 0
	  && what_they_get > rsa->actual_register_packet_size)
	what_they_get = rsa->actual_register_packet_size;
d619 1
d623 3
a625 3
     increased beyond this.  */
  if (size > get_remote_packet_size ())
    size = get_remote_packet_size ();
d982 1
a982 1
    xsnprintf (&buf[2], get_remote_packet_size () - 2, "-%x", -th);
d984 1
a984 1
    xsnprintf (&buf[2], get_remote_packet_size () - 2, "%x", th);
d1003 1
a1003 1
    xsnprintf (buf, get_remote_packet_size (), "T-%08x", -tid);
d1005 1
a1005 1
    xsnprintf (buf, get_remote_packet_size (), "T%08x", tid);
d1572 2
a1573 2
  if ((((result_limit + 1) * BUF_THREAD_ID_SIZE) + 10) >= get_remote_packet_size ())
    result_limit = (get_remote_packet_size () / BUF_THREAD_ID_SIZE) - 2;
d1794 1
a1794 1
      xsnprintf (bufp, get_remote_packet_size (), "qThreadExtraInfo,%x",
d1846 1
a1846 1
  xsnprintf (rs->buf, get_remote_packet_size (), "R%x", 0);
d2047 1
a2047 1
  msg = alloca (get_remote_packet_size ());
d2064 1
a2064 1
	xsnprintf (msg, get_remote_packet_size (), "qSymbol::%s", &reply[8]);
d2066 1
a2066 1
	xsnprintf (msg, get_remote_packet_size (), "qSymbol:%s:%s",
d2152 2
a2153 1
		  rs->explicit_packet_size = packet_size;
d2187 1
a2187 1
  if (rs->buf_size < rs->explicit_packet_size)
d2189 1
a2189 1
      rs->buf_size = rs->explicit_packet_size;
a2256 1
  rs->explicit_packet_size = 0;
d2568 1
a2568 1
  gdb_assert (outbuf && strlen (outbuf) < get_remote_packet_size ());
a2857 1
  struct remote_arch_state *rsa = get_remote_arch_state ();
d2954 1
a2954 1
		    struct packet_reg *reg = packet_reg_from_pnum (rsa, pnum);
a3046 1
  struct remote_arch_state *rsa = get_remote_arch_state ();
d3150 1
a3150 1
		    struct packet_reg *reg = packet_reg_from_pnum (rsa, pnum);
a3297 1
  struct remote_arch_state *rsa = get_remote_arch_state ();
d3318 2
a3319 2
  if (rsa->actual_register_packet_size == 0)
    rsa->actual_register_packet_size = buf_len;
d3331 1
a3331 1
  if (buf_len != 2 * rsa->sizeof_g_packet)
d3333 1
a3333 1
      rsa->sizeof_g_packet = buf_len / 2;
d3337 1
a3337 1
	  if (rsa->regs[i].pnum == -1)
d3340 2
a3341 2
	  if (rsa->regs[i].offset >= rsa->sizeof_g_packet)
	    rsa->regs[i].in_g_packet = 0;
d3343 1
a3343 1
	    rsa->regs[i].in_g_packet = 1;
d3347 1
a3347 1
  regs = alloca (rsa->sizeof_g_packet);
d3350 1
a3350 1
  memset (regs, 0, rsa->sizeof_g_packet);
d3371 1
a3371 1
  for (i = 0; i < rsa->sizeof_g_packet; i++)
d3389 1
a3389 1
	struct packet_reg *r = &rsa->regs[i];
a3415 1
  struct remote_arch_state *rsa = get_remote_arch_state ();
d3422 1
a3422 1
      struct packet_reg *reg = packet_reg_from_regnum (rsa, regnum);
d3449 2
a3450 2
    if (!rsa->regs[i].in_g_packet)
      if (!fetch_register_using_p (&rsa->regs[i]))
d3465 1
a3465 1
  struct remote_arch_state *rsa = get_remote_arch_state ();
d3476 2
a3477 2
	if (rsa->regs[i].in_g_packet)
	  regcache_raw_read (current_regcache, rsa->regs[i].regnum, buf);
d3502 1
a3502 1
  xsnprintf (buf, get_remote_packet_size (), "P%s=", phex_nz (reg->pnum, 0));
a3528 1
  struct remote_arch_state *rsa = get_remote_arch_state ();
d3536 2
a3537 2
    regs = alloca (rsa->sizeof_g_packet);
    memset (regs, 0, rsa->sizeof_g_packet);
d3540 1
a3540 1
	struct packet_reg *r = &rsa->regs[i];
d3550 1
a3550 1
  /* remote_prepare_to_store insures that rsa->sizeof_g_packet gets
d3552 1
a3552 1
  bin2hex (regs, p, rsa->sizeof_g_packet);
a3562 1
  struct remote_arch_state *rsa = get_remote_arch_state ();
d3569 1
a3569 1
      struct packet_reg *reg = packet_reg_from_regnum (rsa, regnum);
d3593 2
a3594 2
    if (!rsa->regs[i].in_g_packet)
      if (!store_register_using_P (&rsa->regs[i]))
d4050 1
a4050 1
   get_remote_packet_size () - 5 to account for the $, # and checksum,
d4057 1
d5012 1
a5012 1
      xsnprintf (rs->buf, get_remote_packet_size (), "qCRC:%lx,%lx",
d5072 2
a5073 2
  n = min ((get_remote_packet_size () - 2) / 2, len);
  snprintf (rs->buf, get_remote_packet_size (), "qPart:%s:read:%s:%s,%s",
d5160 2
a5161 2
    return (get_remote_packet_size ());
  /* Minimum outbuf size is get_remote_packet_size (). If LEN is not
d5163 1
a5163 1
  if (len < get_remote_packet_size ())
d5165 1
a5165 1
  len = get_remote_packet_size ();
d5184 1
a5184 1
  while (annex[i] && (i < (get_remote_packet_size () - 8)))
d5223 1
a5223 1
  if ((strlen (buf) + strlen (command) * 2 + 8/*misc*/) > get_remote_packet_size ())
a5740 2
  struct remote_state *rs;

a5749 8
  /* Initialize the per-target state.  At the moment there is only one
     of these, not one per target.  Only one target is active at a
     time.  The default buffer size is unimportant; it will be expanded
     whenever a larger buffer is needed.  */
  rs = get_remote_state ();
  rs->buf_size = 400;
  rs->buf = xmalloc (rs->buf_size);

@


1.202.2.3.2.1
log
@	Backport:
	2006-04-07  Daniel Jacobowitz  <dan@@codesourcery.com>
	* remote.c (remote_wait): Convert warning to error before
	parsing corrupt packets.
@
text
@d2895 1
a2895 1
		      error (_("Malformed packet(a) (missing colon): %s\n\
@


1.202.2.3.2.2
log
@Merge to branch:
  http://sourceware.org/ml/gdb-patches/2006-04/msg00139.html
@
text
@d138 4
d4542 4
a4545 3
   ADDR is the target location in the target machine.  BPT is the breakpoint
   being inserted or removed, which contains memory for saving the
   target contents.  */
d4548 1
a4548 1
remote_insert_breakpoint (CORE_ADDR addr, struct bp_location *bpt)
d4554 1
d4566 1
d4570 3
a4572 5
      bpt->placed_address = addr;
      BREAKPOINT_FROM_PC (&bpt->placed_address, &bpt->placed_size);
      addr = (ULONGEST) remote_address_masked (bpt->placed_address);
      p += hexnumstr (p, addr);
      sprintf (p, ",%d", bpt->placed_size);
d4589 1
a4589 1
  val = target_read_memory (addr, bpt->shadow_contents, sizeof big_break_insn);
d4603 1
a4603 1
  return memory_insert_breakpoint (addr, bpt);
d4608 1
a4608 1
remote_remove_breakpoint (CORE_ADDR addr, struct bp_location *bpt)
d4622 4
a4625 3
      addr = (ULONGEST) remote_address_masked (bpt->placed_address);
      p += hexnumstr (p, addr);
      sprintf (p, ",%d", bpt->placed_size);
d4634 1
a4634 1
  return target_write_memory (addr, bpt->shadow_contents, sizeof big_break_insn);
d4636 1
a4636 1
  return memory_remove_breakpoint (addr, bpt);
d4782 1
a4782 1
remote_insert_hw_breakpoint (CORE_ADDR addr, struct bp_location *bpt)
d4784 1
d4792 1
a4792 2
  bpt->placed_address = addr;
  BREAKPOINT_FROM_PC (&bpt->placed_address, &bpt->placed_size);
d4803 1
a4803 1
  addr = remote_address_masked (bpt->placed_address);
d4805 1
a4805 1
  sprintf (p, ",%x", bpt->placed_size);
d4824 1
a4824 1
remote_remove_hw_breakpoint (CORE_ADDR addr, struct bp_location *bpt)
d4826 1
d4834 2
d4845 1
a4845 1
  addr = remote_address_masked (bpt->placed_address);
d4847 1
a4847 1
  sprintf (p, ",%x", bpt->placed_size);
@


1.202.2.3.2.3
log
@Actually include patch, not just changelog.
@
text
@d67 1
a67 1
static int getpkt_sane (char **buf, long *sizeof_buf, int forever);
d108 1
a108 1
static void remote_send (char **buf, long *sizeof_buf_p);
d136 1
a136 3
static void skip_frame (void);

static long read_frame (char **buf_p, long *sizeof_buf);
a244 9

  /* A buffer to use for incoming packets, and its current size.  The
     buffer is grown dynamically for larger incoming packets.
     Outgoing packets may also be constructed in this buffer.
     BUF_SIZE is always at least REMOTE_PACKET_SIZE;
     REMOTE_PACKET_SIZE should be used to limit the length of outgoing
     packets.  */
  char *buf;
  long buf_size;
a331 8
  /* Create the buffer at a default size.  Note that this would
     leak memory if the gdbarch were ever destroyed; there's no
     way to register a destructor for it, and we can't realloc
     using the gdbarch obstack.  But gdbarches are never
     destroyed.  */
  rs->buf_size = rs->remote_packet_size;
  rs->buf = xmalloc (rs->buf_size);

a484 9

  /* Make sure there is room in the global buffer for this packet
     (including its trailing NUL byte).  */
  if (rs->buf_size < what_they_get + 1)
    {
      rs->buf_size = what_they_get + 1;
      rs->buf = xrealloc (rs->buf, what_they_get + 1);
    }

d936 1
a936 1
  char *buf = rs->buf;
d954 1
a954 1
  getpkt (&rs->buf, &rs->buf_size, 0);
a965 1
  struct remote_state *rs = get_remote_state ();
d967 1
a967 1
  char *buf = rs->buf;
d970 1
a970 1
    xsnprintf (buf, rs->remote_packet_size, "T-%08x", -tid);
d972 1
a972 1
    xsnprintf (buf, rs->remote_packet_size, "T%08x", tid);
d974 1
a974 1
  getpkt (&rs->buf, &rs->buf_size, 0);
d1383 1
a1383 1
  char *limit = pkt + rs->buf_size; /* Plausible parsing limit.  */
d1474 1
a1474 1
  char *threadinfo_pkt = rs->buf;
d1478 1
a1478 1
  getpkt (&rs->buf, &rs->buf_size, 0);
d1512 1
a1512 1
  limit = pkt + (rs->buf_size - BUF_THREAD_ID_SIZE);
d1535 2
a1536 1
  char *threadlist_packet = rs->buf;
d1543 4
a1546 3
  pack_threadlist_request (rs->buf, startflag, result_limit, nextthread);
  putpkt (rs->buf);
  getpkt (&rs->buf, &rs->buf_size, 0);
d1549 1
a1549 1
    parse_threadlist_response (rs->buf + 2, result_limit, &echo_nextthread,
d1654 1
a1654 1
  char *buf = rs->buf;
d1657 1
a1657 1
  getpkt (&rs->buf, &rs->buf_size, 0);
d1693 1
d1703 2
a1704 2
      bufp = rs->buf;
      getpkt (&rs->buf, &rs->buf_size, 0);
d1723 2
a1724 2
	      bufp = rs->buf;
	      getpkt (&rs->buf, &rs->buf_size, 0);
d1754 1
a1762 2
      char *bufp = rs->buf;

d1766 1
a1766 1
      getpkt (&rs->buf, &rs->buf_size, 0);
a1805 31
/* Mark OPS as a running target.  This should restore the target to its
   original state, undoing any effects of remote_mark_killed.  */

static void
remote_mark_running (struct target_ops *ops)
{
  ops->to_has_execution = 1;
  ops->to_has_all_memory = 1;
  ops->to_has_memory = 1;
  ops->to_has_stack = 1;
  ops->to_has_registers = 1;

  update_current_target ();
}

/* Mark OPS as a dead target, undoing any effects of remote_mark_running.
   The target is still on the stack, and GDB is still connected to it,
   but the process we were debugging has exited.  */

static void
remote_mark_killed (struct target_ops *ops)
{
  ops->to_has_execution = 0;
  ops->to_has_all_memory = 0;
  ops->to_has_memory = 0;
  ops->to_has_stack = 0;
  ops->to_has_registers = 0;

  update_current_target ();
}

d1812 1
d1816 2
a1817 2
  xsnprintf (rs->buf, rs->remote_packet_size, "R%x", 0);
  putpkt (rs->buf);
d1822 1
a1822 1
  getpkt (&rs->buf, &rs->buf_size, 0);
d1841 1
a1841 1
  char *buf = rs->buf;
d1843 1
a1843 1
  int lose, seen_text_seg = 0;
d1851 1
a1851 1
  getpkt (&rs->buf, &rs->buf_size, 0);
d1879 3
d1883 8
a1890 8
      if (strncmp (ptr, ";Data=", 6) == 0)
	{
	  ptr += 6;
	  while (*ptr && *ptr != ';')
	    data_addr = (data_addr << 4) + fromhex (*ptr++);
	}
      else
	lose = 1;
d1892 1
a1892 10
      if (!lose && strncmp (ptr, ";Bss=", 5) == 0)
	{
	  ptr += 5;
	  while (*ptr && *ptr != ';')
	    bss_addr = (bss_addr << 4) + fromhex (*ptr++);
	}
      else
	lose = 1;
    }
  else if (strncmp (ptr, "TextSeg=", 8) == 0)
d1894 1
a1894 2
      ptr += 8;
      /* Don't use strtol, could lose on big values.  */
d1896 1
a1896 11
	text_addr = (text_addr << 4) + fromhex (*ptr++);
      seen_text_seg = 1;

      if (strncmp (ptr, ";DataSeg=", 9) == 0)
	{
	  ptr += 9;
	  while (*ptr && *ptr != ';')
	    data_addr = (data_addr << 4) + fromhex (*ptr++);
	}
      else
	lose = 1;
d1912 1
a1912 9
  if (seen_text_seg)
    {
      if (! symfile_map_offsets_to_segments (symfile_objfile, offs,
					     text_addr, data_addr))
	error (_("Can not handle qOffsets TextSeg response with this symbol file"));
    }
  else
    {
      offs->offsets[SECT_OFF_TEXT (symfile_objfile)] = text_addr;
d1914 3
a1916 3
      /* This is a temporary kludge to force data and bss to use the same offsets
	 because that's what nlmconv does now.  The real solution requires changes
	 to the stub and remote.c that I don't have time to do right now.  */
d1918 2
a1919 3
      offs->offsets[SECT_OFF_DATA (symfile_objfile)] = data_addr;
      offs->offsets[SECT_OFF_BSS (symfile_objfile)] = data_addr;
    }
d2013 2
a2014 5
  /* Allocate a message buffer.  We can't reuse the input buffer in RS,
     because we need both at the same time.  */
  msg = alloca (rs->remote_packet_size);

  reply = rs->buf;
d2019 2
a2020 2
  getpkt (&rs->buf, &rs->buf_size, 0);
  packet_ok (rs->buf, &remote_protocol_packets[PACKET_qSymbol]);
d2035 1
a2035 1
      getpkt (&rs->buf, &rs->buf_size, 0);
d2063 1
a2063 1
  char *next;
d2066 2
d2069 1
a2069 1
  getpkt (&rs->buf, &rs->buf_size, 0);
d2071 1
a2071 1
  next = rs->buf;
a2181 4
  /* We're about to connect; assume that the target will be running
     when we do so.  */
  remote_mark_running (target);

d2296 1
d2298 1
a2298 1
      getpkt (&rs->buf, &rs->buf_size, 0);
d2316 1
d2322 2
a2323 2
  strcpy (rs->buf, "D");
  remote_send (&rs->buf, &rs->buf_size);
d2337 1
a2337 1
remote_disconnect (struct target_ops *target, char *args, int from_tty)
d2340 1
a2340 1
    error (_("Argument given to \"disconnect\" when remotely debugging."));
d2346 1
a2346 5
  /* Make sure we unpush even the extended remote targets; mourn
     won't do it.  So call remote_mourn_1 directly instead of
     target_mourn_inferior.  */
  remote_mourn_1 (target);

d2417 1
a2417 1
remote_vcont_probe (struct remote_state *rs)
a2418 2
  char *buf = rs->buf;

d2421 1
a2421 1
  getpkt (&rs->buf, &rs->buf_size, 0);
d2475 3
d2479 1
a2479 1
    remote_vcont_probe (rs);
d2482 4
a2485 1
    return 0;
d2533 1
a2533 1
  old_cleanup = make_cleanup (xfree, outbuf);
d2552 1
a2552 1
  char *buf = rs->buf;
d2822 1
a2822 1
  char *buf = rs->buf;
d2834 1
a2834 1
      getpkt (&rs->buf, &rs->buf_size, 1);
d3011 1
a3011 1
  char *buf = rs->buf;
d3030 1
a3030 1
      getpkt (&rs->buf, &rs->buf_size, wait_forever_enabled_p);
d3209 1
a3209 1
  char *buf = rs->buf, *p;
d3223 1
a3223 1
  remote_send (&rs->buf, &rs->buf_size);
d3262 1
a3262 1
  char *buf = rs->buf;
d3270 1
a3270 1
  remote_send (&rs->buf, &rs->buf_size);
d3328 1
a3328 1
      getpkt (&rs->buf, &rs->buf_size, 0);
d3457 1
a3457 1
  char *buf = rs->buf;
d3471 1
a3471 1
  remote_send (&rs->buf, &rs->buf_size);
d3494 1
d3514 2
a3515 1
  p = rs->buf;
d3520 1
a3520 1
  remote_send (&rs->buf, &rs->buf_size);
d3649 1
a3649 1
	char *buf = rs->buf;
d3661 1
a3661 1
	getpkt (&rs->buf, &rs->buf_size, 0);
a3693 1
  struct remote_state *rs = get_remote_state ();
d3697 1
d3709 4
a3712 3
  /* The packet buffer will be large enough for the payload;
     get_memory_packet_size ensures this.  */
  buf = rs->buf;
d3819 1
a3819 1
  getpkt (&rs->buf, &rs->buf_size, 0);
a3853 1
  struct remote_state *rs = get_remote_state ();
d3856 1
d3859 1
d3861 2
a3862 3
  /* The packet buffer will be large enough for the payload;
     get_memory_packet_size ensures this.  */
  buf = rs->buf;
d3884 1
a3884 1
      getpkt (&rs->buf, &rs->buf_size, 0);
d3983 2
a3984 4
/* Send the command in *BUF to the remote machine, and read the reply
   into *BUF.  Report an error if we get an error reply.  Resize
   *BUF using xrealloc if necessary to hold the result, and update
   *SIZEOF_BUF.  */
d3987 2
a3988 2
remote_send (char **buf,
	     long *sizeof_buf)
d3990 1
a3990 1
  putpkt (*buf);
d3993 2
a3994 2
  if ((*buf)[0] == 'E')
    error (_("Remote failure reply: %s"), *buf);
d4027 2
d4110 1
a4110 1
		skip_frame ();
a4143 36
/* Come here after finding the start of a frame when we expected an
   ack.  Do our best to discard the rest of this packet.  */

static void
skip_frame (void)
{
  int c;

  while (1)
    {
      c = readchar (remote_timeout);
      switch (c)
	{
	case SERIAL_TIMEOUT:
	  /* Nothing we can do.  */
	  return;
	case '#':
	  /* Discard the two bytes of checksum and stop.  */
	  c = readchar (remote_timeout);
	  if (c >= 0)
	    c = readchar (remote_timeout);

	  return;
	case '*':		/* Run length encoding.  */
	  /* Discard the repeat count.  */
	  c = readchar (remote_timeout);
	  if (c < 0)
	    return;
	  break;
	default:
	  /* A regular character.  */
	  break;
	}
    }
}

d4145 3
a4147 3
   into *BUF, verifying the checksum, length, and handling run-length
   compression.  NUL terminate the buffer.  If there is not enough room,
   expand *BUF using xrealloc.
d4154 2
a4155 2
read_frame (char **buf_p,
	    long *sizeof_buf)
a4159 1
  char *buf = *buf_p;
d4166 1
d4233 3
a4235 1
	    if (repeat > 0 && repeat <= 255 && bc > 0)
a4236 8
		if (bc + repeat - 1 >= *sizeof_buf - 1)
		  {
		    /* Make some more room in the buffer.  */
		    *sizeof_buf += repeat;
		    *buf_p = xrealloc (*buf_p, *sizeof_buf);
		    buf = *buf_p;
		  }

d4243 4
a4246 1
	    printf_filtered (_("Invalid run length encoding: %s\n"), buf);
d4250 1
a4250 1
	  if (bc >= *sizeof_buf - 1)
d4252 3
a4254 4
	      /* Make some more room in the buffer.  */
	      *sizeof_buf *= 2;
	      *buf_p = xrealloc (*buf_p, *sizeof_buf);
	      buf = *buf_p;
d4257 6
a4262 3
	  buf[bc++] = c;
	  csum += c;
	  continue;
d4268 3
a4270 4
   store it in *BUF.  Resize *BUF using xrealloc if necessary to hold
   the result, and update *SIZEOF_BUF.  If FOREVER, wait forever
   rather than timing out; this is used (in synchronous mode) to wait
   for a target that is is executing user code to stop.  */
d4276 2
a4277 2
getpkt (char **buf,
	long *sizeof_buf,
d4287 5
a4291 6
   store it in *BUF.  Resize *BUF using xrealloc if necessary to hold
   the result, and update *SIZEOF_BUF.  If FOREVER, wait forever
   rather than timing out; this is used (in synchronous mode) to wait
   for a target that is is executing user code to stop.  If FOREVER ==
   0, this function is allowed to time out gracefully and return an
   indication of this to the caller.  */
d4293 3
a4295 1
getpkt_sane (char **buf, long *sizeof_buf, int forever)
d4302 1
a4302 1
  strcpy (*buf, "timeout");
d4354 1
a4354 1
	      fputstr_unfiltered (*buf, 0, gdb_stdlog);
d4436 3
a4438 3
  /* We do not want to unpush the target; then the next time the
     user says "run", we won't be connected.  Just mark ourselves
     as not executing.  */
d4440 4
a4443 13
  generic_mourn_inferior ();
  remote_mark_killed (&extended_remote_ops);
}

static void
extended_async_remote_mourn (void)
{
  /* We do not want to unpush the target; then the next time the
     user says "run", we won't be connected.  Just mark ourselves
     as not executing.  */

  generic_mourn_inferior ();
  remote_mark_killed (&extended_async_remote_ops);
a4477 2

  remote_mark_running (&extended_remote_ops);
a4502 2

  remote_mark_running (&extended_async_remote_ops);
d4557 2
a4558 1
      char *p = rs->buf;
d4569 2
a4570 2
      putpkt (rs->buf);
      getpkt (&rs->buf, &rs->buf_size, 0);
d4572 1
a4572 1
      switch (packet_ok (rs->buf, &remote_protocol_packets[PACKET_Z0]))
d4610 2
a4611 1
      char *p = rs->buf;
d4621 2
a4622 2
      putpkt (rs->buf);
      getpkt (&rs->buf, &rs->buf_size, 0);
d4624 1
a4624 1
      return (rs->buf[0] == 'E');
d4658 1
d4667 2
a4668 2
  sprintf (rs->buf, "Z%x,", packet);
  p = strchr (rs->buf, '\0');
d4673 2
a4674 2
  putpkt (rs->buf);
  getpkt (&rs->buf, &rs->buf_size, 0);
d4676 1
a4676 1
  switch (packet_ok (rs->buf, &remote_protocol_packets[PACKET_Z0 + packet]))
d4693 1
d4702 2
a4703 2
  sprintf (rs->buf, "z%x,", packet);
  p = strchr (rs->buf, '\0');
d4707 2
a4708 2
  putpkt (rs->buf);
  getpkt (&rs->buf, &rs->buf_size, 0);
d4710 1
a4710 1
  switch (packet_ok (rs->buf, &remote_protocol_packets[PACKET_Z0 + packet]))
d4755 1
a4755 1
  return remote_stopped_by_watchpoint_p;
d4779 2
a4780 1
  char *p = rs->buf;
d4801 2
a4802 2
  putpkt (rs->buf);
  getpkt (&rs->buf, &rs->buf_size, 0);
d4804 1
a4804 1
  switch (packet_ok (rs->buf, &remote_protocol_packets[PACKET_Z1]))
d4821 2
a4822 1
  char *p = rs->buf;
d4840 2
a4841 2
  putpkt (rs->buf);
  getpkt (&rs->buf, &rs->buf_size, 0);
d4843 1
a4843 1
  switch (packet_ok (rs->buf, &remote_protocol_packets[PACKET_Z1]))
d4875 1
a4875 1
  {0, 0};
d4904 4
a4907 4
With no arguments, compares each loadable section in the exec bfd
with the same memory range on the target, and reports mismatches.
Useful for verifying the image on the target against the exec file.
Depends on the target understanding the new "qCRC:" request.  */
d4925 1
d4953 1
a4953 1
      xsnprintf (rs->buf, rs->remote_packet_size, "qCRC:%lx,%lx",
d4955 1
a4955 1
      putpkt (rs->buf);
d4964 2
a4965 2
      getpkt (&rs->buf, &rs->buf_size, 0);
      if (rs->buf[0] == 'E')
d4968 1
a4968 1
      if (rs->buf[0] != 'C')
d4971 1
a4971 1
      for (target_crc = 0, tmp = &rs->buf[1]; *tmp; tmp++)
d5007 1
d5015 1
a5015 1
  snprintf (rs->buf, rs->remote_packet_size, "qPart:%s:read:%s:%s,%s",
d5019 1
a5019 1
  i = putpkt (rs->buf);
d5023 3
a5025 2
  getpkt (&rs->buf, &rs->buf_size, 0);
  if (packet_ok (rs->buf, packet) != PACKET_OK)
d5028 1
a5028 1
  if (rs->buf[0] == 'O' && rs->buf[1] == 'K' && rs->buf[2] == '\0')
d5032 1
a5032 1
  i = hex2bin (rs->buf, readbuf, len);
d5043 1
a5043 1
  char *p2;
d5116 3
a5118 1
  p2 = rs->buf;
d5138 1
a5138 1
  i = putpkt (rs->buf);
d5142 1
a5142 2
  getpkt (&rs->buf, &rs->buf_size, 0);
  strcpy ((char *) readbuf, rs->buf);
d5152 1
a5152 1
  char *buf = rs->buf;
d5172 1
a5172 1
  if (putpkt (rs->buf) < 0)
d5180 1
a5180 1
      getpkt (&rs->buf, &rs->buf_size, 0);
d5208 1
d5221 1
a5221 1
  getpkt (&rs->buf, &rs->buf_size, 0);
d5223 1
a5223 1
  print_packet (rs->buf);
d5393 2
a5394 1
      char *p = rs->buf;
d5406 3
a5408 3
      putpkt (rs->buf);
      getpkt (&rs->buf, &rs->buf_size, 0);
      result = packet_ok (rs->buf, &remote_protocol_packets[PACKET_qGetTLSAddr]);
d5413 1
a5413 1
	  unpack_varlen_hex (rs->buf, &result);
d5551 3
a5553 3
This are temporary targets, until it is all tested.  Eventually
async support will be incorporated int the usual 'remote'
target.  */
d5628 1
a5628 1
  extended_async_remote_ops.to_mourn_inferior = extended_async_remote_mourn;
@


1.202.2.3.2.4
log
@No, really, check in the RIGHT patch!
[Revert half of changes from previous commit.]
@
text
@d1833 31
d1900 1
a1900 1
  int lose;
d1936 18
d1955 1
a1955 4
  else
    lose = 1;

  if (!lose && strncmp (ptr, ";Data=", 6) == 0)
d1957 2
a1958 1
      ptr += 6;
d1960 2
a1961 4
	data_addr = (data_addr << 4) + fromhex (*ptr++);
    }
  else
    lose = 1;
d1963 8
a1970 5
  if (!lose && strncmp (ptr, ";Bss=", 5) == 0)
    {
      ptr += 5;
      while (*ptr && *ptr != ';')
	bss_addr = (bss_addr << 4) + fromhex (*ptr++);
d1986 9
a1994 1
  offs->offsets[SECT_OFF_TEXT (symfile_objfile)] = text_addr;
d1996 3
a1998 3
  /* This is a temporary kludge to force data and bss to use the same offsets
     because that's what nlmconv does now.  The real solution requires changes
     to the stub and remote.c that I don't have time to do right now.  */
d2000 3
a2002 2
  offs->offsets[SECT_OFF_DATA (symfile_objfile)] = data_addr;
  offs->offsets[SECT_OFF_BSS (symfile_objfile)] = data_addr;
d2266 4
d2423 1
a2423 1
remote_disconnect (char *args, int from_tty)
d2426 1
a2426 1
    error (_("Argument given to \"detach\" when remotely debugging."));
d2432 5
a2436 1
  target_mourn_inferior ();
d4556 3
a4558 3
  /* We do _not_ want to mourn the target like this; this will
     remove the extended remote target  from the target stack,
     and the next time the user says "run" it'll fail.
d4560 13
a4572 4
     FIXME: What is the right thing to do here?  */
#if 0
  remote_mourn_1 (&extended_remote_ops);
#endif
d4607 2
d4634 2
d4884 1
a4884 1
    return remote_stopped_by_watchpoint_p;
d5002 1
a5002 1
{0, 0};
d5031 4
a5034 4
   With no arguments, compares each loadable section in the exec bfd
   with the same memory range on the target, and reports mismatches.
   Useful for verifying the image on the target against the exec file.
   Depends on the target understanding the new "qCRC:" request.  */
d5672 3
a5674 3
   This are temporary targets, until it is all tested.  Eventually
   async support will be incorporated int the usual 'remote'
   target.  */
d5749 1
a5749 1
  extended_async_remote_ops.to_mourn_inferior = extended_remote_mourn;
@


1.202.2.3.2.5
log
@Add experimental support for SymbianOS-related protocol features.
@
text
@a45 1
#include "solist.h"
a441 4
/* The executable file to use for "run" on the remote side.  */

static char *remote_exec_file = "";

a820 3
  PACKET_vAttach,
  PACKET_vRun,
  PACKET_qfDllInfo,
a1832 31
/* Mark OPS as a running target.  This should restore the target to its
   original state, undoing any effects of remote_mark_killed.  */

static void
remote_mark_running (struct target_ops *ops)
{
  ops->to_has_execution = 1;
  ops->to_has_all_memory = 1;
  ops->to_has_memory = 1;
  ops->to_has_stack = 1;
  ops->to_has_registers = 1;

  update_current_target ();
}

/* Mark OPS as a dead target, undoing any effects of remote_mark_running.
   The target is still on the stack, and GDB is still connected to it,
   but the process we were debugging has exited.  */

static void
remote_mark_killed (struct target_ops *ops)
{
  ops->to_has_execution = 0;
  ops->to_has_all_memory = 0;
  ops->to_has_memory = 0;
  ops->to_has_stack = 0;
  ops->to_has_registers = 0;

  update_current_target ();
}

d1845 4
a1848 2
  /* We used to query for status here ("?"), but we just discarded the
     result; there's no point to that.  */
d1869 1
a1869 1
  int lose, seen_text_seg = 0;
d1905 3
d1909 8
a1916 8
      if (strncmp (ptr, ";Data=", 6) == 0)
	{
	  ptr += 6;
	  while (*ptr && *ptr != ';')
	    data_addr = (data_addr << 4) + fromhex (*ptr++);
	}
      else
	lose = 1;
d1918 1
a1918 10
      if (!lose && strncmp (ptr, ";Bss=", 5) == 0)
	{
	  ptr += 5;
	  while (*ptr && *ptr != ';')
	    bss_addr = (bss_addr << 4) + fromhex (*ptr++);
	}
      else
	lose = 1;
    }
  else if (strncmp (ptr, "TextSeg=", 8) == 0)
d1920 1
a1920 2
      ptr += 8;
      /* Don't use strtol, could lose on big values.  */
d1922 1
a1922 11
	text_addr = (text_addr << 4) + fromhex (*ptr++);
      seen_text_seg = 1;

      if (strncmp (ptr, ";DataSeg=", 9) == 0)
	{
	  ptr += 9;
	  while (*ptr && *ptr != ';')
	    data_addr = (data_addr << 4) + fromhex (*ptr++);
	}
      else
	lose = 1;
d1938 1
a1938 9
  if (seen_text_seg)
    {
      if (! symfile_map_offsets_to_segments (symfile_objfile, offs,
					     text_addr, data_addr))
	error (_("Can not handle qOffsets TextSeg response with this symbol file"));
    }
  else
    {
      offs->offsets[SECT_OFF_TEXT (symfile_objfile)] = text_addr;
d1940 3
a1942 3
      /* This is a temporary kludge to force data and bss to use the same offsets
	 because that's what nlmconv does now.  The real solution requires changes
	 to the stub and remote.c that I don't have time to do right now.  */
d1944 2
a1945 3
      offs->offsets[SECT_OFF_DATA (symfile_objfile)] = data_addr;
      offs->offsets[SECT_OFF_BSS (symfile_objfile)] = data_addr;
    }
a1949 155
/* Parse a load or unload message for a DLL.  Loads are required to
   have all fields, unloads must have at least one.  P is not
   necessarily NUL terminated, but it is always either NUL or semicolon
   terminated (i.e. *P_END is either NUL or a semicolon) and the containing
   string is NUL terminated.  */

int
parse_load_response (const char *p, const char *p_end, int is_load)
{
  const char *name_start;
  char *name;
  CORE_ADDR text_addr, data_addr;
  int i;

  name = NULL;
  text_addr = ~(CORE_ADDR) 0;
  data_addr = ~(CORE_ADDR) 0;

  if (p < p_end && strncmp (p, "Name=", 5) == 0)
    {
      p += 5;

      name_start = p;
      while (p < p_end && *p != ',')
	p++;

      if ((p - name_start) % 2 != 0)
	return -1;

      name = alloca ((p - name_start) / 2 + 1);
      i = hex2bin (name_start, name, (p - name_start) / 2);
      name[i] = '\0';

      if (p < p_end)
	p++;
    }
  else if (is_load)
    return -1;

  if (p < p_end && strncmp (p, "TextSeg=", 8) == 0)
    {
      p += 8;

      text_addr = 0;
      while (p < p_end && *p != ',')
	text_addr = (text_addr << 4) + fromhex (*p++);

      if (p < p_end)
	p++;
    }
  else if (is_load)
    return -1;

  if (p < p_end && strncmp (p, "DataSeg=", 8) == 0)
    {
      p += 8;

      data_addr = 0;
      while (p < p_end && *p != ',')
	data_addr = (data_addr << 4) + fromhex (*p++);

      if (p < p_end)
	p++;
    }
  else if (is_load)
    return -1;

  if (is_load)
    current_target_so_ops->add_one_solib (name, text_addr, data_addr);
  else
    {
      if (text_addr == ~(CORE_ADDR) 0
	  && data_addr == ~(CORE_ADDR) 0
	  && name == NULL)
	return -1;

      current_target_so_ops->remove_one_solib (name, text_addr, data_addr);
    }

  return 0;
}

/* Query the remote side for loaded solibs.  */

static void
remote_get_shared_libraries (struct target_ops *ops)
{
  struct remote_state *rs = get_remote_state ();
  int added = 0;

  /* If this target doesn't support remote DLLs, nothing to do.  */
  if (current_target_so_ops->add_one_solib == NULL)
    return;

  /* If qfDllInfo is not available, nothing to do.  */
  if (remote_protocol_packets[PACKET_qfDllInfo].support == PACKET_DISABLE)
    return;

  putpkt ("qfDllInfo");
  getpkt (&rs->buf, &rs->buf_size, 0);

  if (packet_ok (rs->buf, &remote_protocol_packets[PACKET_qfDllInfo]) == PACKET_ERROR)
    {
      warning (_("Remote failure reply: %s"), rs->buf);
      return;
    }
  else if (remote_protocol_packets[PACKET_qfDllInfo].support == PACKET_DISABLE)
    /* It wasn't disabled before, but it is now.  */
    return;

  while (rs->buf[0] == 'm')
    {
      char *p = rs->buf + 1;

      while (1)
	{
	  char *p_end = p;

	  while (*p_end && *p_end != ';')
	    p_end++;

	  if (parse_load_response (p, p_end, 1) != 0)
	    {
	      warning (_("Malformed response to DLL query, %s"), rs->buf);
	      return;
	    }

	  added = 1;

	  if (*p_end == ';')
	    p = p_end + 1;
	  else
	    break;
	}

      putpkt ("qsDllInfo");
      getpkt (&rs->buf, &rs->buf_size, 0);
    }

  if (strcmp (rs->buf, "l") != 0)
    {
      warning (_("Malformed response to DLL query, %s"), rs->buf);
      return;
    }

  if (added)
    {
#ifdef SOLIB_ADD
      SOLIB_ADD (NULL, 0, &current_target, auto_solib_add);
#else
      solib_add (NULL, 0, &current_target, auto_solib_add);
#endif
    }
}

d1962 1
a1962 1
remote_start_remote (struct ui_out *uiout, void *target_)
a1963 2
  struct target_ops *target = target_;

a1968 22
  if (target)
    {
      struct remote_state *rs = get_remote_state ();
      char *buf = alloca (rs->remote_packet_size);

      /* In extended mode, check whether the target is running now.  This
         duplicates the ? request/response, which is a shame; a FIXME
	 is to cache the response for later.  */
      putpkt ("?");
      getpkt (&buf, &rs->buf_size, 0);

      if (buf[0] == 'W' || buf[0] == 'X')
	{
	  remote_mark_killed (target);
	  /* FIXME: This bypasses start_remote; mostly this is OK,
	     but do we need to call init_wait_for_inferior somewhere?  */
	  return;
	}
      else
	remote_mark_running (target);
    }

a1971 10
  /* Without this, some commands which require an active target
     (such as kill) won't work.  This variable serves (at least)
     double duty as both the pid of the target process (if it has
     such), and as a flag indicating that a target is active.
     These functions should be split out into seperate variables,
     especially since GDB will someday have a notion of debugging
     several processes.  */
  inferior_ptid = pid_to_ptid (MAGIC_NULL_PID);

  /* Now, if we have thread information, update inferior_ptid.  */
d1979 1
a1979 1
  remote_start_remote_dummy (uiout, NULL);
a2208 4
  /* We're about to connect; assume that the target will be running
     when we do so.  */
  remote_mark_running (target);

d2255 9
d2307 1
a2307 2
      = catch_exception (uiout, remote_start_remote,
			 extended_p ? target : NULL, RETURN_MASK_ALL);
d2327 1
a2327 4
  /* If we connected to a live target, do some additional setup.  */
  if (target_has_execution)
    {
      post_create_inferior (&current_target, from_tty);
d2329 2
a2330 3
      if (exec_bfd) 	/* No use without an exec file.  */
	remote_check_symbols (symfile_objfile);
    }
d2339 1
a2339 1
remote_detach_1 (char *args, int from_tty, int extended)
a2345 3
  if (!target_has_execution)
    error (_("No process to detach from."));

a2354 1

d2356 1
a2356 18
    {
      if (extended)
	puts_filtered ("Detached from remote process.\n");
      else
	puts_filtered ("Ending remote debugging.\n");
    }
}

static void
remote_detach (char *args, int from_tty)
{
  remote_detach_1 (args, from_tty, 0);
}

static void
extended_remote_detach (char *args, int from_tty)
{
  remote_detach_1 (args, from_tty, 1);
d2362 1
a2362 1
remote_disconnect (struct target_ops *target, char *args, int from_tty)
d2365 1
a2365 1
    error (_("Argument given to \"disconnect\" when remotely debugging."));
d2371 1
a2371 5
  /* Make sure we unpush even the extended remote targets; mourn
     won't do it.  So call remote_mourn_1 directly instead of
     target_mourn_inferior.  */
  remote_mourn_1 (target);

a2375 59
/* Attach to the process specified by ARGS.  If FROM_TTY is non-zero,
   be chatty about it.  */

static void
extended_remote_attach_1 (struct target_ops *target, char *args, int from_tty)
{
  struct remote_state *rs = get_remote_state ();
  pid_t pid;
  char *dummy, *buf;

  if (!args)
    error_no_arg (_("process-id to attach"));

  dummy = args;
  pid = strtol (args, &dummy, 0);
  /* Some targets don't set errno on errors, grrr!  */
  if (pid == 0 && args == dummy)
    error (_("Illegal process-id: %s."), args);

  if (remote_protocol_packets[PACKET_vAttach].support == PACKET_DISABLE)
    error (_("This target does not support attaching to a process"));

  buf = alloca (rs->remote_packet_size);
  sprintf (buf, "vAttach;%x", pid);
  putpkt (buf);
  getpkt (&rs->buf, &rs->buf_size, 0);

  if (packet_ok (buf, &remote_protocol_packets[PACKET_vAttach]) == PACKET_OK)
    {
      if (from_tty)
	printf_unfiltered (_("Attached to %s\n"),
			   target_pid_to_str (pid_to_ptid (pid)));

      /* We have a wait response.  We could reuse it, which is a FIXME,
	 but for now just request the target to send it again.  */
      putpkt ("?");
    }
  else if (remote_protocol_packets[PACKET_vAttach].support == PACKET_DISABLE)
    error (_("This target does not support attaching to a process"));
  else
    error (_("Attaching to %s failed"),
	   target_pid_to_str (pid_to_ptid (pid)));

  remote_mark_running (target);
  inferior_ptid = pid_to_ptid (pid);
}

static void
extended_remote_attach (char *args, int from_tty)
{
  extended_remote_attach_1 (&extended_remote_ops, args, from_tty);
}

static void
extended_async_remote_attach (char *args, int from_tty)
{
  extended_remote_attach_1 (&extended_async_remote_ops, args, from_tty);
}

a2845 1
  int solibs_changed = 0;
a2928 24
		    else if (strncmp (p, "load", p1 - p) == 0)
		      {
			p1++;
			p_temp = p1;
			while (*p_temp && *p_temp != ';')
			  p_temp++;

			parse_load_response (p1, p_temp, 1);

			solibs_changed = 1;
			p = p_temp;
		      }
		    else if (strncmp (p, "unload", p1 - p) == 0)
		      {
			p1++;
			p_temp = p1;
			while (*p_temp && *p_temp != ';')
			  p_temp++;

			parse_load_response (p1, p_temp, 0);

			solibs_changed = 1;
			p = p_temp;
		      }
a3019 3
  if (solibs_changed)
    status->kind = TARGET_WAITKIND_LOADED;

d4488 13
d4509 3
a4511 16
static void
extended_remote_mourn_1 (struct target_ops *target)
{
  struct remote_state *rs = get_remote_state ();
  char *buf = alloca (rs->remote_packet_size);

  /* Unlike "target remote", we do not want to unpush the target; then
     the next time the user says "run", we won't be connected.  */

  /* Call common code to mark the inferior as not running.  */
  generic_mourn_inferior ();

  /* Check whether the target is running now - some remote stubs
     automatically restart after kill.  */
  putpkt ("?");
  getpkt (&rs->buf, &rs->buf_size, 0);
d4513 2
a4514 14
  if (buf[0] == 'S' || buf[0] == 'T')
    {
      /* Assume that the target has been restarted.  Set inferior_ptid
	 so that bits of core GDB realizes there's something here, e.g.,
	 so that the user can say "kill" again.  */
      inferior_ptid = pid_to_ptid (MAGIC_NULL_PID);
    }
  else
    {
      /* Mark this (still pushed) target as not executable until we
	 restart it.  */
      remote_mark_killed (target);
    }
}
d4517 2
a4518 1
extended_remote_mourn (void)
d4520 3
a4522 2
  extended_remote_mourn_1 (&extended_remote_ops);
}
d4524 2
a4525 12
static void
extended_async_remote_mourn (void)
{
  extended_remote_mourn_1 (&extended_async_remote_ops);
}

int
extended_remote_run (char *args)
{
  struct remote_state *rs = get_remote_state ();
  char *buf, *p;
  int len;
d4527 3
a4529 1
  buf = alloca (rs->remote_packet_size);
d4531 2
a4532 47
  strcpy (buf, "vRun;");
  len = strlen (buf);

  if (strlen (remote_exec_file) * 2 + len >= rs->remote_packet_size)
    error (_("Remote file name too long for run packet"));
  len += 2 * bin2hex ((gdb_byte *) remote_exec_file, buf + len, 0);

  if (*args)
    {
      struct cleanup *back_to;
      int i;
      char **argv;

      argv = buildargv (args);
      back_to = make_cleanup ((void (*) (void *)) freeargv, argv);
      for (i = 0; argv[i] != NULL; i++)
	{
	  if (strlen (argv[i]) * 2 + 1 + len >= rs->remote_packet_size)
	    error (_("Argument list too long for run packet"));
	  buf[len++] = ';';
	  len += 2 * bin2hex ((gdb_byte *) argv[i], buf + len, 0);
	}
      do_cleanups (back_to);
    }

  buf[len++] = '\0';

  putpkt (buf);
  getpkt (&rs->buf, &rs->buf_size, 0);

  if (packet_ok (buf, &remote_protocol_packets[PACKET_vRun]) == PACKET_OK)
    {
      /* We have a wait response; we don't need it, though.  All is well.  */
      return 0;
    }
  else if (remote_protocol_packets[PACKET_vRun].support == PACKET_DISABLE)
    /* It wasn't disabled before, but it is now.  */
    return -1;
  else
    {
      if (remote_exec_file == NULL)
	error (_("Running the default executable on the remote target failed; "
		 "try \"set remote exec-file\"?"));
      else
	error (_("Running \"%s\" on the remote target failed"),
	       remote_exec_file);
    }
d4535 1
a4535 6
/* In the extended protocol we want to be able to do things like
   "run" and have them basically work as expected.  So we need
   a special create_inferior function.

   FIXME: One day add support for an environment?  */

d4537 2
a4538 3
extended_remote_create_inferior_1 (char *exec_file, char *args,
				   char **env, int from_tty,
				   int async_p)
d4540 4
d4546 1
a4546 1
  if (async_p && target_can_async_p ())
d4550 1
a4550 21
  if (remote_protocol_packets[PACKET_vRun].support == PACKET_DISABLE)
    extended_remote_restart ();
  else if (extended_remote_run (args) == -1)
    {
      /* vRun was not supported.  Fail if we need it to do what the
	 user requested.  */
      if (remote_exec_file[0])
	error (_("Remote target does not support \"set remote exec-file\""));
      if (args[0])
	error (_("Remote target does not support \"set args\" or run <ARGS>"));

      /* Fall back to "R".  */
      extended_remote_restart ();
    }

  /* Now mark the inferior as running before we do anything else.  */
  inferior_ptid = pid_to_ptid (MAGIC_NULL_PID);
  if (async_p)
    remote_mark_running (&extended_async_remote_ops);
  else
    remote_mark_running (&extended_remote_ops);
d4552 3
a4554 2
  /* Get updated offsets, if the stub uses qOffsets.  */
  get_offsets ();
d4557 1
a4557 16
  init_thread_list ();
  init_wait_for_inferior ();
}

static void
extended_remote_create_inferior (char *exec_file, char *args,
				 char **env, int from_tty)
{
  extended_remote_create_inferior_1 (exec_file, args, env, from_tty, 0);
}

static void
extended_remote_async_create_inferior (char *exec_file, char *args,
				       char **env, int from_tty)
{
  extended_remote_create_inferior_1 (exec_file, args, env, from_tty, 1);
d4806 1
a4806 1
  return remote_stopped_by_watchpoint_p;
d4924 1
a4924 1
  {0, 0};
d4953 4
a4956 4
With no arguments, compares each loadable section in the exec bfd
with the same memory range on the target, and reports mismatches.
Useful for verifying the image on the target against the exec file.
Depends on the target understanding the new "qCRC:" request.  */
a5512 1
  remote_ops.to_get_shared_libraries = remote_get_shared_libraries;
a5540 2
  extended_remote_ops.to_detach = extended_remote_detach;
  extended_remote_ops.to_attach = extended_remote_attach;
d5594 3
a5596 3
This are temporary targets, until it is all tested.  Eventually
async support will be incorporated int the usual 'remote'
target.  */
a5638 1
  remote_async_ops.to_get_shared_libraries = remote_get_shared_libraries;
d5671 1
a5671 3
  extended_async_remote_ops.to_mourn_inferior = extended_async_remote_mourn;
  extended_async_remote_ops.to_detach = extended_remote_detach;
  extended_async_remote_ops.to_attach = extended_async_remote_attach;
a5892 9
  add_packet_config_cmd (&remote_protocol_packets[PACKET_vAttach],
			 "vAttach", "attach", 0, 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_vRun],
			 "vRun", "run", 0, 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_qfDllInfo],
			 "qfDllInfo", "dll-info", 0, 0);

a5906 7
  remote_exec_file = xstrdup ("");
  add_setshow_string_noescape_cmd ("exec-file", class_files,
				   &remote_exec_file, _("\
Set the remote pathname for \"run\""), _("\
Show the remote pathname for \"run\""), NULL, NULL, NULL,
				   &remote_set_cmdlist, &remote_show_cmdlist);

@


1.202.2.3.2.6
log
@	* gdb/remote.c (remote_get_shared_libraries): Check for NULL ops.
	(remote_wait): Handle ",nop" on DLL packets and "dll:dll" response.
@
text
@d2158 1
a2158 5
  /* If OPS is set, we were called from the target vector and should handle
     adding shared libraries now.  If it is NULL, we were called as part of
     a TARGET_WAITKIND_LOADED event, and the libraries will be added momentarily,
     so we don't need to do it now.  */
  if (added && ops != NULL)
d3273 1
a3273 12
			if (p_temp - p1 > 4
			    && strncmp (p_temp - 4, ",nop", 4) == 0)
			  {
			    /* For now, ignore no-op unload events.  Later,
			       maybe report them?  */
			  }
			else
			  {
			    parse_load_response (p1, p_temp, 1);

			    solibs_changed = 1;
			  }
d3275 1
d3285 1
a3285 12
			if (p_temp - p1 > 4
			    && strncmp (p_temp - 4, ",nop", 4) == 0)
			  {
			    /* For now, ignore no-op unload events.  Later,
			       maybe report them?  */
			  }
			else
			  {
			    parse_load_response (p1, p_temp, 0);

			    solibs_changed = 1;
			  }
d3287 1
a3287 10
			p = p_temp;
		      }
		    else if (strncmp (p, "dll", p1 - p) == 0)
		      {
			p1++;
			p_temp = p1;
			while (*p_temp && *p_temp != ';')
			  p_temp++;

			solibs_changed = -1;
d3381 1
a3381 4
  if (solibs_changed == -1)
    remote_get_shared_libraries (NULL);
  
  if (solibs_changed != 0)
@


1.202.2.3.2.7
log
@	* gdb/bsd-uthread.c (bsd_uthread_solib_loaded): Always pass 0 for
	from_tty.
	* gdb/remote.c (remote_get_shared_libraries): Don't call solib_add.
	* gdb/solib.c: Include "exceptions.h".
	(solib_map_sections): Throw NOT_FOUND_ERROR if appropriate.
	(symbol_add_stub): Delete.
	(solib_read_symbols): Use TRY_CATCH.  Inline symbol_add_stub.
	Use current from_tty, not a copy from the so_list.  Don't warn
	a second time for a missing library.
	(update_solib_list): Don't save from_tty.  Use TRY_CATCH.  Print
	out a single warning for all missing libraries.
	* gdb/solist.h (struct so_list): Remove from_tty.
	* gdb/Makefile.in (solib.o): Update.
@
text
@d2101 1
d2140 2
d2158 12
a2169 2
  /* We don't need to call solib_add here, because we're being called from
     ->current_sos ().  */
@


1.202.2.3.2.8
log
@	* gdb/remote.c: Include "gdb/fileio.h".
	(PACKET_Fopen, PACKET_Fread, PACKET_Fwrite, PACKET_Fclose): New
	enums.
	(remote_escape_output, remote_unescape_input): New functions.
	(remote_write_bytes): Use remote_escape_output.
	(readchar): Do not mask off the high bit.
	(read_frame): Print binary packets correctly.
	(getpkt_sane): Likewise.  Return the number of bytes read
	or -1.
	(remote_buffer_add_string, remote_buffer_add_bytes)
	(remote_buffer_add_int, remote_hostio_parse_result)
	(remote_hostio_send_command, remote_hostio_open)
	(remote_hostio_write, remote_hostio_read)
	(remote_hostio_close, remote_fileio_errno_to_host)
	(remote_hostio_error, fclose_cleanup, remote_download_command)
	(remote_upload_command): New functions.
	(_initialize_remote): Register new packets and remote-upload
	and remote-download commands.

	* gdb/doc/gdb.texinfo (File Transfer): New section.
	(Remote Configuration): Document Host I/O packet commands.
	(Host I/O Packets): New section.
	(Packets): Mention overloading of F prefix.

	* gdb/gdbserver/Makefile.in (OBS): Add hostio.o.
	(hostio.o): New rule.
	* gdb/gdbserver/hostio.c: New file.
	* gdb/gdbserver/remote-utils.c (putpkt_binary): New function,
	broken out from putpkt.
	(putpkt): Use it.
	(readchar): Do not mask the high bits.  Correct the buffer
	type.
	* gdb/gdbserver/server.c (main): Leave space for a trailing
	zero in the packet buffer.  Save the length of the
	received packet.  Handle Host I/O requests.  Optionally call
	putpkt_binary.
	* gdb/gdbserver/server.h (handle_f_hostio, putpkt_binary): New
	prototypes.
@
text
@a64 2
#include "gdb/fileio.h"

a825 4
  PACKET_Fopen,
  PACKET_Fread,
  PACKET_Fwrite,
  PACKET_Fclose,
a4088 81
/* Convert BUFFER, binary data at least LEN bytes long, into escaped
   binary data in OUT_BUF.  Set *OUT_LEN to the length of the data
   encoded in OUT_BUF, and return the number of bytes in OUT_BUF
   (which may be more than *OUT_LEN due to escape characters).  The
   total number of bytes in the output buffer will be at most
   OUT_MAXLEN.  */

static int
remote_escape_output (const gdb_byte *buffer, int len,
		      gdb_byte *out_buf, int *out_len,
		      int out_maxlen)
{
  int input_index, output_index;

  output_index = 0;
  for (input_index = 0; input_index < len; input_index++)
    {
      gdb_byte b = buffer[input_index];

      if (b == '$' || b == '#' || b == '}')
	{
	  /* These must be escaped.  */
	  if (output_index + 2 > out_maxlen)
	    break;
	  out_buf[output_index++] = '}';
	  out_buf[output_index++] = b ^ 0x20;
	}
      else
	{
	  if (output_index + 1 > out_maxlen)
	    break;
	  out_buf[output_index++] = b;
	}
    }

  *out_len = input_index;
  return output_index;
}

/* Convert BUFFER, escaped data LEN bytes long, into binary data
   in OUT_BUF.  Return the number of bytes written to OUT_BUF.
   Raise an error if the total number of bytes exceeds OUT_MAXLEN.

   This function reverses remote_escape_output.  It allows more
   escaped characters than that function does, in particular because
   '*' must be escaped to avoid the run-length encoding processing
   in reading packets.  */

static int
remote_unescape_input (const gdb_byte *buffer, int len,
		       gdb_byte *out_buf, int out_maxlen)
{
  int input_index, output_index;
  int escaped;

  output_index = 0;
  escaped = 0;
  for (input_index = 0; input_index < len; input_index++)
    {
      gdb_byte b = buffer[input_index];

      if (output_index + 1 > out_maxlen)
	error (_("Received too much data from the target."));

      if (escaped)
	{
	  out_buf[output_index++] = b ^ 0x20;
	  escaped = 0;
	}
      else if (b == '}')
	escaped = 1;
      else
	out_buf[output_index++] = b;
    }

  if (escaped)
    error (_("Unmatched escape character in target response."));

  return output_index;
}

d4182 18
a4199 1
      p += remote_escape_output (myaddr, todo, p, &nr_bytes, payload_size);
d4361 2
a4362 1
/* Read a single character from the remote end.  */
d4372 1
a4372 1
    return ch;
d4657 1
a4657 1
		fputstrn_unfiltered (buf, bc, 0, gdb_stdlog);
d4736 1
a4736 2
   indication of this (-1) to the caller.  Otherwise return the number
   of bytes read.  */
d4797 1
a4797 1
	      fputstrn_unfiltered (*buf, val, 0, gdb_stdlog);
d4801 1
a4801 1
	  return val;
d4814 1
a4814 1
  return -1;
a5959 495
/* Remote file transfer support.  This is host-initiated I/O, not
   target-initiated; for target-initiated, see remote-fileio.c.  */

/* If *LEFT is at least the length of STRING, copy STRING to
   *BUFFER, update *BUFFER to point to the new end of the buffer, and
   decrease *LEFT.  Otherwise raise an error.  */

static void
remote_buffer_add_string (char **buffer, int *left, char *string)
{
  int len = strlen (string);

  if (len > *left)
    error (_("Packet too long for target."));

  memcpy (*buffer, string, len);
  *buffer += len;
  *left -= len;

  /* NUL-terminate the buffer as a convenience, if there is
     room.  */
  if (*left)
    **buffer = '\0';
}

/* If *LEFT is large enough, hex encode LEN bytes from BYTES into
   *BUFFER, update *BUFFER to point to the new end of the buffer, and
   decrease *LEFT.  Otherwise raise an error.  */

static void
remote_buffer_add_bytes (char **buffer, int *left, const gdb_byte *bytes,
			 int len)
{
  if (2 * len > *left)
    error (_("Packet too long for target."));

  bin2hex (bytes, *buffer, len);
  *buffer += 2 * len;
  *left -= 2 * len;

  /* NUL-terminate the buffer as a convenience, if there is
     room.  */
  if (*left)
    **buffer = '\0';
}

/* If *LEFT is large enough, convert VALUE to hex and add it to
   *BUFFER, update *BUFFER to point to the new end of the buffer, and
   decrease *LEFT.  Otherwise raise an error.  */

static void
remote_buffer_add_int (char **buffer, int *left, ULONGEST value)
{
  int len = hexnumlen (value);

  if (len > *left)
    error (_("Packet too long for target."));

  hexnumstr (*buffer, value);
  *buffer += len;
  *left -= len;

  /* NUL-terminate the buffer as a convenience, if there is
     room.  */
  if (*left)
    **buffer = '\0';
}

/* Parse an I/O result packet from BUFFER.  Set RETCODE to the return
   value, *REMOTE_ERRNO to the remote error number or zero if none
   was included, and *ATTACHMENT to point to the start of the annex
   if any.  The length of the packet isn't needed here; there may
   be NUL bytes in BUFFER, but they will be after *ATTACHMENT.

   Return 0 if the packet could be parsed, -1 if it could not.  If
   -1 is returned, the other variables may not be initialized.  */

static int
remote_hostio_parse_result (char *buffer, int *retcode,
			    int *remote_errno, char **attachment)
{
  char *p, *p2;

  *remote_errno = 0;
  *attachment = NULL;

  if (buffer[0] != 'F')
    return -1;

  *retcode = strtol (&buffer[1], &p, 16);
  if (p == &buffer[1])
    return -1;

  /* Check for ",errno".  */
  if (*p == ',')
    {
      *remote_errno = strtol (p + 1, &p2, 16);
      if (p + 1 == p2)
	return -1;
      p = p2;
    }

  /* Check for ";attachment".  If there is no attachment, the
     packet should end here.  */
  if (*p == ';')
    {
      *attachment = p + 1;
      return 0;
    }
  else if (*p == '\0')
    return 0;
  else
    return -1;
}

/* Send a prepared I/O packet to the target and read its response.
   The prepared packet is in the global RS->BUF before this function
   is called, and the answer is there when we return.

   COMMAND_BYTES is the length of the request to send, which may include
   binary data.  WHICH_PACKET is the packet configuration to check
   before attempting a packet.  If an error occurs, *REMOTE_ERRNO
   is set to the error number and -1 is returned.  Otherwise the value
   returned by the function is returned.

   ATTACHMENT and ATTACHMENT_LEN should be non-NULL if and only if an
   attachment is expected; an error will be reported if there's a
   mismatch.  If one is found, *ATTACHMENT will be set to point into
   the packet buffer and *ATTACHMENT_LEN will be set to the
   attachment's length.  */

static int
remote_hostio_send_command (int command_bytes, int which_packet,
			    int *remote_errno, char **attachment,
			    int *attachment_len)
{
  struct remote_state *rs = get_remote_state ();
  int ret, bytes_read;
  char *attachment_tmp;

  if (remote_protocol_packets[which_packet].support == PACKET_DISABLE)
    {
      *remote_errno = FILEIO_ENOSYS;
      return -1;
    }

  putpkt_binary (rs->buf, command_bytes);
  bytes_read = getpkt_sane (&rs->buf, &rs->buf_size, 0);

  /* If it timed out, something is wrong.  Don't try to parse the
     buffer.  */
  if (bytes_read < 0)
    {
      *remote_errno = FILEIO_EINVAL;
      return -1;
    }

  switch (packet_ok (rs->buf, &remote_protocol_packets[which_packet]))
    {
    case PACKET_ERROR:
      *remote_errno = FILEIO_EINVAL;
      return -1;
    case PACKET_UNKNOWN:
      *remote_errno = FILEIO_ENOSYS;
      return -1;
    case PACKET_OK:
      break;
    }

  if (remote_hostio_parse_result (rs->buf, &ret, remote_errno,
				  &attachment_tmp))
    {
      *remote_errno = FILEIO_EINVAL;
      return -1;
    }

  /* Make sure we saw an attachment if and only if we expected one.  */
  if ((attachment_tmp == NULL && attachment != NULL)
      || (attachment_tmp != NULL && attachment == NULL))
    {
      *remote_errno = FILEIO_EINVAL;
      return -1;
    }

  /* If an attachment was found, it must point into the packet buffer;
     work out how many bytes there were.  */
  if (attachment_tmp != NULL)
    {
      *attachment = attachment_tmp;
      *attachment_len = bytes_read - (*attachment - rs->buf);
    }

  return ret;
}

/* Open FILENAME on the remote target, using FLAGS and MODE.  Return a
   remote file descriptor, or -1 if an error occurs (and set
   *REMOTE_ERRNO).  */

static int
remote_hostio_open (const char *filename, int flags, int mode,
		    int *remote_errno)
{
  struct remote_state *rs = get_remote_state ();
  char *p = rs->buf;
  int left = rs->remote_packet_size - 1;

  remote_buffer_add_string (&p, &left, "Fopen,");

  remote_buffer_add_bytes (&p, &left, (const gdb_byte *) filename,
			   strlen (filename));
  remote_buffer_add_string (&p, &left, ",");

  remote_buffer_add_int (&p, &left, flags);
  remote_buffer_add_string (&p, &left, ",");

  remote_buffer_add_int (&p, &left, mode);

  return remote_hostio_send_command (p - rs->buf, PACKET_Fopen,
				     remote_errno, NULL, NULL);
}

/* Write up to LEN bytes from WRITE_BUF to FD on the remote target.
   Return the number of bytes written, or -1 if an error occurs (and
   set *REMOTE_ERRNO).  */

static int
remote_hostio_write (int fd, const gdb_byte *write_buf, int len,
		     int *remote_errno)
{
  struct remote_state *rs = get_remote_state ();
  char *p = rs->buf;
  int left = rs->remote_packet_size;
  int out_len;

  remote_buffer_add_string (&p, &left, "Fwrite,");

  remote_buffer_add_int (&p, &left, fd);
  remote_buffer_add_string (&p, &left, ",");

  p += remote_escape_output (write_buf, len, p, &out_len,
			     rs->remote_packet_size - strlen (p));

  return remote_hostio_send_command (p - rs->buf, PACKET_Fwrite,
				     remote_errno, NULL, NULL);
}

/* Read up to LEN bytes FD on the remote target into READ_BUF
   Return the number of bytes read, or -1 if an error occurs (and
   set *REMOTE_ERRNO).  */

static int
remote_hostio_read (int fd, gdb_byte *read_buf, int len,
		    int *remote_errno)
{
  struct remote_state *rs = get_remote_state ();
  char *p = rs->buf;
  char *attachment;
  int left = rs->remote_packet_size;
  int ret, attachment_len;
  int read_len;

  remote_buffer_add_string (&p, &left, "Fread,");

  remote_buffer_add_int (&p, &left, fd);
  remote_buffer_add_string (&p, &left, ",");

  remote_buffer_add_int (&p, &left, len);

  ret = remote_hostio_send_command (p - rs->buf, PACKET_Fwrite,
				    remote_errno, &attachment,
				    &attachment_len);

  if (ret < 0)
    return ret;

  read_len = remote_unescape_input (attachment, attachment_len,
				    read_buf, len);
  if (read_len != ret)
    error (_("Read returned %d, but %d bytes."), ret, (int) read_len);

  return ret;
}

/* Close FD on the remote target.  Return 0, or -1 if an error occurs
   (and set *REMOTE_ERRNO).  */

static int
remote_hostio_close (int fd, int *remote_errno)
{
  struct remote_state *rs = get_remote_state ();
  char *p = rs->buf;
  int left = rs->remote_packet_size - 1;

  remote_buffer_add_string (&p, &left, "Fclose,");

  remote_buffer_add_int (&p, &left, fd);

  return remote_hostio_send_command (p - rs->buf, PACKET_Fclose,
				     remote_errno, NULL, NULL);
}

static int
remote_fileio_errno_to_host (int error)
{
  switch (error)
    {
      case FILEIO_EPERM:
        return EPERM;
      case FILEIO_ENOENT:
        return ENOENT;
      case FILEIO_EINTR:
        return EINTR;
      case FILEIO_EIO:
        return EIO;
      case FILEIO_EBADF:
        return EBADF;
      case FILEIO_EACCES:
        return EACCES;
      case FILEIO_EFAULT:
        return EFAULT;
      case FILEIO_EBUSY:
        return EBUSY;
      case FILEIO_EEXIST:
        return EEXIST;
      case FILEIO_ENODEV:
        return ENODEV;
      case FILEIO_ENOTDIR:
        return ENOTDIR;
      case FILEIO_EISDIR:
        return EISDIR;
      case FILEIO_EINVAL:
        return EINVAL;
      case FILEIO_ENFILE:
        return ENFILE;
      case FILEIO_EMFILE:
        return EMFILE;
      case FILEIO_EFBIG:
        return EFBIG;
      case FILEIO_ENOSPC:
        return ENOSPC;
      case FILEIO_ESPIPE:
        return ESPIPE;
      case FILEIO_EROFS:
        return EROFS;
      case FILEIO_ENOSYS:
        return ENOSYS;
      case FILEIO_ENAMETOOLONG:
        return ENAMETOOLONG;
    }
  return -1;
}

static char *
remote_hostio_error (int error)
{
  int host_error = remote_fileio_errno_to_host (error);

  if (host_error == -1)
    error (_("Unknown remote I/O error %d"), error);
  else
    error (_("Remote I/O error: %s"), safe_strerror (host_error));
}

static void
fclose_cleanup (void *file)
{
  fclose (file);
}

static void
remote_download_command (char *args, int from_tty)
{
  struct cleanup *cleanups;
  char **argv;
  int retcode, fd, remote_errno, bytes;
  FILE *file;
  gdb_byte *buffer;
  int bytes_in_buffer;

  if (!remote_desc)
    error (_("command can only be used with remote target"));

  argv = buildargv (args);
  if (argv == NULL)
    nomem (0);
  cleanups = make_cleanup_freeargv (argv);
  if (argv[0] == NULL || argv[1] == NULL || argv[2] != NULL)
    error (_("Invalid parameters to remote-download"));

  file = fopen (argv[0], "rb");
  if (file == NULL)
    perror_with_name (argv[0]);
  make_cleanup (fclose_cleanup, file);

  fd = remote_hostio_open (argv[1], FILEIO_O_WRONLY | FILEIO_O_CREAT, 0700,
			   &remote_errno);
  if (fd == -1)
    remote_hostio_error (remote_errno);

  /* FIXME: Adjust to the requested packet and memory transfer size,
     batch I/O better.  */
  buffer = xmalloc (1024);
  make_cleanup (xfree, buffer);

  bytes_in_buffer = 0;
  while (1)
    {
      bytes = fread (buffer, 1, 1024 - bytes_in_buffer, file);
      if (bytes == 0)
	{
	  if (ferror (file))
	    error (_("Error reading %s."), argv[0]);
	  else
	    /* EOF */
	    break;
	}

      bytes += bytes_in_buffer;
      bytes_in_buffer = 0;

      retcode = remote_hostio_write (fd, buffer, bytes, &remote_errno);

      if (retcode < 0)
	remote_hostio_error (remote_errno);
      else if (retcode == 0)
	error (_("Remote write of %d bytes returned 0!"), bytes);
      else if (retcode < bytes)
	{
	  /* Short write.  Save the rest of the read data for the next
	     write.  */
	  bytes_in_buffer = bytes - retcode;
	  memmove (buffer, buffer + retcode, bytes_in_buffer);
	}
    }

  if (remote_hostio_close (fd, &remote_errno))
    remote_hostio_error (remote_errno);

  do_cleanups (cleanups);
}

static void
remote_upload_command (char *args, int from_tty)
{
  struct cleanup *cleanups;
  char **argv;
  int retcode, fd, remote_errno, bytes;
  FILE *file;
  gdb_byte *buffer;

  if (!remote_desc)
    error (_("command can only be used with remote target"));

  argv = buildargv (args);
  if (argv == NULL)
    nomem (0);
  cleanups = make_cleanup_freeargv (argv);
  if (argv[0] == NULL || argv[1] == NULL || argv[2] != NULL)
    error (_("Invalid parameters to remote-upload"));

  fd = remote_hostio_open (argv[0], FILEIO_O_RDONLY, 0, &remote_errno);
  if (fd == -1)
    remote_hostio_error (remote_errno);

  file = fopen (argv[1], "wb");
  if (file == NULL)
    perror_with_name (argv[1]);
  make_cleanup (fclose_cleanup, file);

  /* FIXME: Adjust to the requested packet and memory transfer size,
     batch I/O better.  */
  buffer = xmalloc (1024);
  make_cleanup (xfree, buffer);

  while (1)
    {
      bytes = remote_hostio_read (fd, buffer, 1024, &remote_errno);
      if (bytes == 0)
	/* Success, but no bytes, means end-of-file.  */
	break;
      if (bytes == -1)
	remote_hostio_error (remote_errno);

      bytes = fwrite (buffer, 1, bytes, file);
      if (bytes == 0)
	perror_with_name (argv[1]);
    }

  if (remote_hostio_close (fd, &remote_errno))
    remote_hostio_error (remote_errno);

  do_cleanups (cleanups);
}

a6394 28
  add_packet_config_cmd (&remote_protocol_packets[PACKET_Fopen],
			 "Fopen", "hostio-open",
			 set_remote_protocol_packet_cmd,
			 show_remote_protocol_packet_cmd,
			 &remote_set_cmdlist, &remote_show_cmdlist,
			 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_Fread],
			 "Fread", "hostio-read",
			 set_remote_protocol_packet_cmd,
			 show_remote_protocol_packet_cmd,
			 &remote_set_cmdlist, &remote_show_cmdlist,
			 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_Fwrite],
			 "Fwrite", "hostio-write",
			 set_remote_protocol_packet_cmd,
			 show_remote_protocol_packet_cmd,
			 &remote_set_cmdlist, &remote_show_cmdlist,
			 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_Fclose],
			 "Fclose", "hostio-close",
			 set_remote_protocol_packet_cmd,
			 show_remote_protocol_packet_cmd,
			 &remote_set_cmdlist, &remote_show_cmdlist,
			 0);

a6415 10
  add_cmd ("remote-download", class_support /* ??? */,
	   remote_download_command,
	   _("Copy a local file to the remote system."),
	   &cmdlist);

  add_cmd ("remote-upload", class_support /* ??? */,
	   remote_upload_command,
	   _("Copy a remote file to the local system."),
	   &cmdlist);

@


1.202.2.3.2.9
log
@	* gdb/remote.c (remote_fileio_errno_to_host)
	(remote_hostio_error): Rename argument to errnum.
	(_initialize_remote): Update calls to add_packet_config_cmd.
@
text
@d6333 1
a6333 1
remote_fileio_errno_to_host (int errnum)
d6335 1
a6335 1
  switch (errnum)
d6384 1
a6384 1
remote_hostio_error (int errnum)
d6386 1
a6386 1
  int host_error = remote_fileio_errno_to_host (errnum);
d6389 1
a6389 1
    error (_("Unknown remote I/O error %d"), errnum);
d6961 5
a6965 1
			 "Fopen", "hostio-open", 0, 0);
d6968 5
a6972 1
			 "Fread", "hostio-read", 0, 0);
d6975 5
a6979 1
			 "Fwrite", "hostio-write", 0, 0);
d6982 5
a6986 1
			 "Fclose", "hostio-close", 0, 0);
@


1.202.2.3.2.10
log
@	* gdb/remote.c (remote_download_command): Correct short write
	handling.
@
text
@a6408 1
  int saw_eof;
d6436 1
a6436 2
  saw_eof = 0;
  while (bytes_in_buffer || !saw_eof)
d6438 2
a6439 1
      if (!saw_eof)
d6441 5
a6445 15
	  bytes = fread (buffer + bytes_in_buffer, 1, 1024 - bytes_in_buffer,
			 file);
	  if (bytes == 0)
	    {
	      if (ferror (file))
		error (_("Error reading %s."), argv[0]);
	      else
		{
		  /* EOF.  Unless there is something still in the
		     buffer from the last iteration, we are done.  */
		  saw_eof = 1;
		  if (bytes_in_buffer == 0)
		    break;
		}
	    }
a6446 2
      else
	bytes = 0;
@


1.202.2.3.2.11
log
@	* gdb/remote.c (remote_hostio_parse_result): Check for strtol
	errors.
@
text
@a6118 1
  errno = 0;
d6120 1
a6120 1
  if (errno != 0 || p == &buffer[1])
a6125 1
      errno = 0;
d6127 1
a6127 1
      if (errno != 0 || p + 1 == p2)
@


1.202.2.3.2.12
log
@	* gdb/remote.c (remote_download_command): Use FILEIO_O_TRUNC.
@
text
@d6428 2
a6429 3
  fd = remote_hostio_open (argv[1], (FILEIO_O_WRONLY | FILEIO_O_CREAT
				     | FILEIO_O_TRUNC),
			   0700, &remote_errno);
@


1.202.2.3.2.13
log
@	* gdb/exec.c (exec_set_section_address): Always update the
	section's address.
	* gdb/objfiles.c (objfile_relocate): Also relocate the
	target sections table.
	* gdb/Makefile.in (objfiles.o): Update.

	* gdb/remote.c (remote_xfer_partial): Fail if the target is not
	running.
@
text
@a5654 6
      /* If the remote target is connected but not running, we should
	 pass this request down to a lower stratum (e.g. the executable
	 file).  */
      if (!target_has_execution)
	return 0;

@


1.202.2.3.2.14
log
@	* gdb/remote.c (remote_hostio_write): Correct buffer length
	calculation.
@
text
@d6279 1
a6279 1
			     rs->remote_packet_size - (p - rs->buf));
@


1.202.2.3.2.15
log
@        * remote.c (remote_start_remote, extended_remote_attach_1)
        (extended_remote_mourn_1, extended_remote_run): Use only rs->buf.
@
text
@d2189 1
a2189 1
      char *buf = rs->buf;
d2195 1
a2195 1
      getpkt (&rs->buf, &rs->buf_size, 0);
d2658 1
a2658 1
  char *dummy;
d2672 3
a2674 2
  sprintf (rs->buf, "vAttach;%x", pid);
  putpkt (rs->buf);
d2677 1
a2677 1
  if (packet_ok (rs->buf, &remote_protocol_packets[PACKET_vAttach]) == PACKET_OK)
d4958 1
d4971 1
a4971 1
  if (rs->buf[0] == 'S' || rs->buf[0] == 'T')
d5002 1
a5002 1
  char *p;
d5005 4
a5008 2
  strcpy (rs->buf, "vRun;");
  len = strlen (rs->buf);
d5012 1
a5012 1
  len += 2 * bin2hex ((gdb_byte *) remote_exec_file, rs->buf + len, 0);
d5026 2
a5027 2
	  rs->buf[len++] = ';';
	  len += 2 * bin2hex ((gdb_byte *) argv[i], rs->buf + len, 0);
d5032 1
a5032 1
  rs->buf[len++] = '\0';
d5034 1
a5034 1
  putpkt (rs->buf);
d5037 1
a5037 1
  if (packet_ok (rs->buf, &remote_protocol_packets[PACKET_vRun]) == PACKET_OK)
@


1.202.4.1
log
@Initial version of available features support.
@
text
@a47 1
#include "available.h"
d217 1
a217 1
     (making an array NUM_REGS in size).  */
a247 6
  int num_g_regs;

  if (gdbarch_remote_num_g_packet_regs_p (gdbarch))
    num_g_regs = gdbarch_remote_num_g_packet_regs (gdbarch);
  else
    num_g_regs = NUM_REGS;
d251 4
a254 4
  /* Assume a 1:1 regnum<->pnum table unless the available registers
     interface informs us otherwise.  */
  rs->regs = GDBARCH_OBSTACK_CALLOC (gdbarch, NUM_REGS, struct packet_reg);
  for (regnum = 0; regnum < NUM_REGS; regnum++)
d257 1
a257 1
      r->pnum = available_register_target_regnum (gdbarch, regnum);
d260 1
a260 1
      r->in_g_packet = (regnum < num_g_regs);
d264 1
a264 1
      if (r->in_g_packet)
d295 1
a295 1
  if (regnum < 0 && regnum >= NUM_REGS)
d309 1
a309 1
  for (i = 0; i < NUM_REGS; i++)
a743 1
  PACKET_qPart_features,
d3034 6
a3039 1
/* Fetch a single register using a 'p' packet.  */
d3042 1
a3042 1
fetch_register_using_p (struct packet_reg *reg)
a3048 3
  if (remote_protocol_packets[PACKET_p].support == PACKET_DISABLE)
    return 0;

d3051 1
a3051 1
  p += hexnumstr (p, reg->pnum);
d3055 4
a3058 10
  switch (packet_ok (buf, &remote_protocol_packets[PACKET_p]))
    {
    case PACKET_OK:
      break;
    case PACKET_UNKNOWN:
      return 0;
    case PACKET_ERROR:
      error (_("Could not fetch register \"%s\""),
	     gdbarch_register_name (current_gdbarch, reg->regnum));
    }
d3060 1
d3063 2
a3064 2
      regcache_raw_supply (current_regcache, reg->regnum, NULL);
      set_register_cached (reg->regnum, -1);
d3068 1
d3074 5
a3078 1
	error (_("fetch_register_using_p: early buf termination"));
d3082 1
a3082 1
  regcache_raw_supply (current_regcache, reg->regnum, regp);
a3085 6
/* Number of bytes of registers this stub implements.  */

static int register_bytes_found;

/* Fetch the registers included in the target's 'g' packet.  */

d3087 1
a3087 1
fetch_registers_using_g (void)
d3097 35
d3192 1
a3192 1
    for (i = 0; i < NUM_REGS; i++)
a3218 33
static void
remote_fetch_registers (int regnum)
{
  struct remote_state *rs = get_remote_state ();
  int i;

  set_thread (PIDGET (inferior_ptid), 1);

  if (regnum >= 0)
    {
      struct packet_reg *reg = packet_reg_from_regnum (rs, regnum);
      gdb_assert (reg != NULL);

      if (fetch_register_using_p (reg))
	return;

      if (!reg->in_g_packet)
	error (_("Protocol error: register \"%s\" not supported by stub"),
	       gdbarch_register_name (current_gdbarch, reg->regnum));

      fetch_registers_using_g ();
      return;
    }

  fetch_registers_using_g ();

  for (i = 0; i < NUM_REGS; i++)
    if (!rs->regs[i].in_g_packet)
      if (!fetch_register_using_p (&rs->regs[i]))
	error (_("Protocol error: register \"%s\" not supported by stub"),
	       gdbarch_register_name (current_gdbarch, rs->regs[i].regnum));
}

d3249 1
a3249 1
store_register_using_P (struct packet_reg *reg)
d3252 1
a3257 3
  if (remote_protocol_packets[PACKET_P].support == PACKET_DISABLE)
    return 0;

d3264 1
a3264 12
  switch (packet_ok (buf, &remote_protocol_packets[PACKET_P]))
    {
    case PACKET_OK:
      return 1;
    case PACKET_ERROR:
      error (_("Could not write register \"%s\""),
	     gdbarch_register_name (current_gdbarch, reg->regnum));
    case PACKET_UNKNOWN:
      return 0;
    default:
      internal_error (__FILE__, __LINE__, _("Bad result from packet_ok"));
    }
d3267 1
d3272 1
a3272 1
store_registers_using_G ()
d3279 31
d3316 1
a3316 1
    for (i = 0; i < NUM_REGS; i++)
a3332 36

/* Store register REGNUM, or all registers if REGNUM == -1, from the contents
   of the register cache buffer.  FIXME: ignores errors.  */

static void
remote_store_registers (int regnum)
{
  struct remote_state *rs = get_remote_state ();
  int i;

  set_thread (PIDGET (inferior_ptid), 1);

  if (regnum >= 0)
    {
      struct packet_reg *reg = packet_reg_from_regnum (rs, regnum);
      gdb_assert (reg != NULL);

      if (store_register_using_P (reg))
	return;

      if (!reg->in_g_packet)
	error (_("Protocol error: register \"%s\" not supported by stub"),
	       gdbarch_register_name (current_gdbarch, reg->regnum));

      store_registers_using_G ();
      return;
    }

  store_registers_using_G ();

  for (i = 0; i < NUM_REGS; i++)
    if (!rs->regs[i].in_g_packet)
      if (!store_register_using_P (&rs->regs[i]))
	error (_("Protocol error: register \"%s\" not supported by stub"),
	       gdbarch_register_name (current_gdbarch, rs->regs[i].regnum));
}
a4765 43
/* Read OBJECT_NAME/ANNEX from the remote target using a qPart packet.
   Data at OFFSET, of up to LEN bytes, is read into READBUF; the
   number of bytes read is returned, or 0 for EOF, or -1 for error.
   The number of bytes read may be less than LEN without indicating an
   EOF.  PACKET is checked and updated to indicate whether the remote
   target supports this object.  */

static LONGEST
remote_read_qpart (struct target_ops *ops, const char *object_name,
		   const char *annex,
		   gdb_byte *readbuf, ULONGEST offset, LONGEST len,
		   struct packet_config *packet)
{
  struct remote_state *rs = get_remote_state ();
  char *buf2 = alloca (rs->remote_packet_size);
  unsigned int total = 0;
  LONGEST i, n;

  if (packet->support == PACKET_DISABLE)
    return -1;

  n = min ((rs->remote_packet_size - 2) / 2, len);
  snprintf (buf2, rs->remote_packet_size, "qPart:%s:read:%s:%s,%s",
	    object_name, annex ? annex : "",
	    phex_nz (offset, sizeof offset),
	    phex_nz (n, sizeof n));
  i = putpkt (buf2);
  if (i < 0)
    return -1;

  buf2[0] = '\0';
  getpkt (buf2, rs->remote_packet_size, 0);
  if (packet_ok (buf2, packet) != PACKET_OK)
    return -1;

  if (buf2[0] == 'O' && buf2[1] == 'K' && buf2[2] == '\0')
    return 0;		/* Got EOF indicator.  */

  /* Got some data.  */
  i = hex2bin (buf2, readbuf, len);
  return i;
}

d4773 2
a4774 1
  char *buf2, *p2;
d4818 33
a4850 7
      gdb_assert (annex == NULL);
      return remote_read_qpart (ops, "auxv", annex, readbuf, offset, len,
				&remote_protocol_packets[PACKET_qPart_auxv]);

    case TARGET_OBJECT_AVAILABLE_FEATURES:
      return remote_read_qpart (ops, "features", annex, readbuf, offset, len,
				&remote_protocol_packets[PACKET_qPart_features]);
a4872 3
  buf2 = alloca (rs->remote_packet_size);
  p2 = &buf2[0];

a5223 1
  remote_ops.to_available_features = available_features_from_target_object;
a5348 2
  remote_async_ops.to_available_features
    = available_features_from_target_object;
a5637 7
  add_packet_config_cmd (&remote_protocol_packets[PACKET_qPart_features],
			 "qPart_features", "target-features",
			 set_remote_protocol_packet_cmd,
			 show_remote_protocol_packet_cmd,
			 &remote_set_cmdlist, &remote_show_cmdlist,
			 0);

@


1.202.4.2
log
@Update g/G packet support.
@
text
@d244 2
a245 2
static int
compare_pnums (const void *lhs_, const void *rhs_)
d247 3
a249 2
  const struct packet_reg * const *lhs = lhs_;
  const struct packet_reg * const *rhs = rhs_;
d251 2
a252 4
  if ((*lhs)->pnum < (*rhs)->pnum)
    return -1;
  else if ((*lhs)->pnum == (*rhs)->pnum)
    return 0;
d254 1
a254 2
    return 1;
}
d256 1
a256 6
static void *
init_remote_state (struct gdbarch *gdbarch)
{
  int regnum, num_remote_regs, offset;
  struct remote_state *rs = GDBARCH_OBSTACK_ZALLOC (gdbarch, struct remote_state);
  struct packet_reg **remote_regs;
d266 7
a274 23
  /* Define the g/G packet format as the contents of each register
     with a remote protocol number, in order of ascending protocol
     number.  */

  remote_regs = alloca (NUM_REGS * sizeof (struct packet_reg *));
  for (num_remote_regs = 0, regnum = 0; regnum < NUM_REGS; regnum++)
    if (rs->regs[regnum].pnum != -1)
      remote_regs[num_remote_regs++] = &rs->regs[regnum];

  qsort (remote_regs, num_remote_regs, sizeof (struct packet_reg *),
	 compare_pnums);

  for (regnum = 0, offset = 0; regnum < num_remote_regs; regnum++)
    {
      remote_regs[regnum]->in_g_packet = 1;
      remote_regs[regnum]->offset = offset;
      offset += register_size (current_gdbarch, remote_regs[regnum]->regnum);
    }

  /* Record the maximum possible size of the g packet - it may turn out
     to be smaller.  */
  rs->sizeof_g_packet = offset;

a3054 3
  if (reg->pnum == -1)
    return 0;

d3092 4
d3103 1
a3103 1
  int i, buf_len;
d3105 1
a3105 1
  char *regs;
d3112 1
a3112 11
  buf_len = strlen (buf);

  /* Sanity check the received packet.  */
  if (buf_len > 2 * rs->sizeof_g_packet)
    error (_("remote 'g' packet reply is too large: %s"), buf);
  if (buf_len % 2 != 0)
    error (_("Remote 'g' packet reply is of odd length: %s"), buf);
  if (REGISTER_BYTES_OK_P () && !REGISTER_BYTES_OK (i))
    error (_("Remote 'g' packet reply is too short: %s"), buf);

  /* Save the size of the packet sent to us by the target.  It is used
d3115 2
a3116 18
  if (rs->actual_register_packet_size == 0)
    rs->actual_register_packet_size = buf_len;

  /* If this is smaller than we guessed the 'g' packet would be,
     update our records.  A 'g' reply that doesn't include a register's
     value implies either that the register is not available, or that
     the 'p' packet must be used.  */
  if (buf_len < 2 * rs->sizeof_g_packet)
    {
      rs->sizeof_g_packet = buf_len / 2;

      for (i = 0; i < NUM_REGS; i++)
	if (rs->regs[i].in_g_packet
	    && rs->regs[i].offset >= rs->sizeof_g_packet)
	  rs->regs[i].in_g_packet = 0;
    }

  regs = alloca (rs->sizeof_g_packet);
d3142 9
a3150 5
      if (p[0] == 0 || p[1] == 0)
	/* This shouldn't happen - we adjusted sizeof_g_packet above.  */
	internal_error (__FILE__, __LINE__,
			"unexpected end of 'g' packet reply");

d3158 9
d3175 5
a3179 3
	      /* This shouldn't happen - we adjusted in_g_packet above.  */
	      internal_error (__FILE__, __LINE__,
			      "unexpected end of 'g' packet reply");
a3208 11
      /* If this register might be in the 'g' packet, try that first -
	 we are likely to read more than one register.  If this is the
	 first 'g' packet, we might be overly optimistic about its
	 contents, so fall back to 'p'.  */
      if (reg->in_g_packet)
	{
	  fetch_registers_using_g ();
	  if (reg->in_g_packet)
	    return;
	}

d3212 3
a3214 3
      /* This register is not available.  */
      regcache_raw_supply (current_regcache, reg->regnum, NULL);
      set_register_cached (reg->regnum, -1);
d3216 1
d3225 2
a3226 5
	{
	  /* This register is not available.  */
	  regcache_raw_supply (current_regcache, i, NULL);
	  set_register_cached (i, -1);
	}
a3269 3
  if (reg->pnum == -1)
    return 0;

d3320 2
a3321 3
  /* remote_prepare_to_store insures that rs->sizeof_g_packet gets
     updated.  */
  bin2hex (regs, p, rs->sizeof_g_packet);
a3340 4
      /* Always prefer to store registers using the 'P' packet if
	 possible; we often change only a small number of registers.
         Sometimes we change a larger number; we'd need help from a
	 higher layer to know to use 'G'.  */
a3343 4
      /* For now, don't complain if we have no way to write the
	 register.  GDB loses track of unavailable registers too
	 easily.  Some day, this may be an error.  We don't have
	 any way to read the register, either... */
d3345 2
a3346 1
	return;
d3357 2
a3358 2
	/* See above for why we do not issue an error here.  */
	continue;
@


1.202.4.3
log
@qPacketInfo support for the branch (pending for mainline)
@
text
@a191 8
static void set_remote_protocol_packet_cmd (char *args, int from_tty,
					    struct cmd_list_element *c);

static void show_remote_protocol_packet_cmd (struct ui_file *file,
					     int from_tty,
					     struct cmd_list_element *c,
					     const char *value);

a193 5
/* For "set remote" and "show remote".  */

static struct cmd_list_element *remote_set_cmdlist;
static struct cmd_list_element *remote_show_cmdlist;

a231 4

  /* This flag is set if we negotiated packet size explicitly (and
     can bypass various heuristics).  */
  int explicit_packet_size;
d460 4
a463 7

      /* Limit it to the size of the targets ``g'' response unless we have
	 permission from the stub to use a larger packet size.  */
      if (!rs->explicit_packet_size
	  && rs->actual_register_packet_size > 0
	  && what_they_get > rs->actual_register_packet_size)
	what_they_get = rs->actual_register_packet_size;
a598 1
    int must_be_reported;
d662 5
a666 2
		       int legacy,
		       int must_be_reported)
a675 1
  config->must_be_reported = must_be_reported;
d684 2
a685 3
				set_remote_protocol_packet_cmd,
				show_remote_protocol_packet_cmd,
				&remote_set_cmdlist, &remote_show_cmdlist);
d692 1
a692 1
		     &remote_set_cmdlist);
d694 1
a694 1
		     &remote_show_cmdlist);
a764 1
  PACKET_qOffsets,
a1829 3
  if (remote_protocol_packets[PACKET_qOffsets].support == PACKET_DISABLE)
    return;

d1833 4
a1836 1
  switch (packet_ok (buf, &remote_protocol_packets[PACKET_qOffsets]))
a1837 6
    case PACKET_OK:
      break;
    case PACKET_UNKNOWN:
      return;			/* Return silently.  Stub doesn't support
				   this command.  */
    case PACKET_ERROR:
a2036 102
remote_query_packet_info (void)
{
  struct remote_state *rs = get_remote_state ();
  char *reply, *next;
  int i;

  reply = alloca (rs->remote_packet_size);

  putpkt ("qPacketInfo");
  getpkt (reply, rs->remote_packet_size, 0);

  next = reply;
  while (*next)
    {
      enum packet_support is_supported;
      char *p, *end, *name_end;

      p = next;
      end = strchr (p, ';');
      if (end == NULL)
	{
	  end = p + strlen (p);
	  next = end;
	}
      else
	{
	  if (end == p)
	    {
	      warning (_("empty item in \"qPacketInfo\" response"));
	      continue;
	    }

	  *end = '\0';
	  next = end + 1;
	}

      name_end = strchr (p, '=');
      if (name_end)
	{
	  /* This is a name=value entry.  */
	  char *value;

	  value = name_end + 1;
	  *name_end = '\0';

	  if (strcmp (p, "PacketSize") == 0)
	    {
	      int packet_size;
	      char *value_end;

	      packet_size = strtol (value, &value_end, 16);
	      if (*value != '\0' && *value_end == '\0')
		{
		  /* MERGE WARNING: This needs the infinite length
		     incoming packet support, which in turn needs us
		     to adjust rs->buf_size here.  */
		  if (packet_size >= MAX_REMOTE_PACKET_SIZE)
		    {
		      warning (_("limiting remote suggested packet size (%d bytes) to %d"),
			       packet_size, MAX_REMOTE_PACKET_SIZE);
		      packet_size = MAX_REMOTE_PACKET_SIZE;
		    }
		  rs->remote_packet_size = packet_size;
		  rs->explicit_packet_size = 1;

		  continue;
		}
	    }

	  /* Should we even warn about this?  For testing, at least, yes.  */
	  warning (_("unrecognized item \"%s=%s\" in \"qPacketInfo\" response"),
		   p, value);
	  continue;
	}

      if (end[-1] != '+' && end[-1] != '-')
	{
	  warning (_("unrecognized item \"%s\" in \"qPacketInfo\" response"), p);
	  continue;
	}

      is_supported = (end[-1] == '+') ? PACKET_ENABLE : PACKET_DISABLE;
      end[-1] = '\0';

      for (i = 0; i < PACKET_MAX; i++)
	if (strcmp (remote_protocol_packets[i].name, p) == 0)
	  {
	    if (remote_protocol_packets[i].support == PACKET_SUPPORT_UNKNOWN)
	      remote_protocol_packets[i].support = is_supported;
	    break;
	  }
    }

  /* Default some unmentioned packets to unsupported.  */
  for (i = 0; i < PACKET_MAX; i++)
    if (remote_protocol_packets[i].must_be_reported
	&& remote_protocol_packets[i].support == PACKET_SUPPORT_UNKNOWN)
      remote_protocol_packets[i].support = PACKET_DISABLE;
}


static void
a2097 5
  /* The first packet we send to the target is the optional "supported
     packets" request.  If the target can answer this, it will tell us
     which later probes to skip.  */
  remote_query_packet_info ();

d3141 1
a3141 1
  if (REGISTER_BYTES_OK_P () && !REGISTER_BYTES_OK (buf_len / 2))
d5488 3
d5668 5
a5672 1
			 "X", "binary-download", 1, 0);
d5675 5
a5679 4
			 "vCont", "verbose-resume", 0, 0);

  add_packet_config_cmd (&remote_protocol_packets[PACKET_qOffsets],
			 "qOffsets", "load-offsets", 0, 0);
d5682 5
a5686 1
			 "qSymbol", "symbol-lookup", 0, 0);
d5689 5
a5693 1
			 "P", "set-register", 1, 0);
d5696 5
a5700 1
			 "p", "fetch-register", 1, 0);
d5703 5
a5707 1
			 "Z0", "software-breakpoint", 0, 0);
d5710 5
a5714 1
			 "Z1", "hardware-breakpoint", 0, 0);
d5717 5
a5721 1
			 "Z2", "write-watchpoint", 0, 0);
d5724 5
a5728 1
			 "Z3", "read-watchpoint", 0, 0);
d5731 5
a5735 1
			 "Z4", "access-watchpoint",  0, 0);
d5738 5
a5742 1
			 "qPart:auxv", "read-aux-vector", 0, 0);
d5745 5
a5749 1
			 "qPart:features", "target-features", 0, 1);
d5753 4
a5756 1
			 0, 0);
@


1.202.4.4
log
@Typo fix.
@
text
@d2120 1
a2120 1
		  if (packet_size > MAX_REMOTE_PACKET_SIZE)
@


1.202.4.5
log
@Make switching targets a little more robust.
@
text
@a2255 8
  /* FIXME: This is a hack.  Default to an architecture with no
     available features here, and set the real one further down.
     Ideally, we ought to set the real architecture here (and
     also in remote_create_inferior maybe?) but not redo it
     in post_inferior_created below.  That will take some rearranging
     that I don't have time for right now.  */
  arch_set_available_features (NULL);

d3271 2
d3288 1
a3288 7
  /* FIXME: Allow bigger, too.  We have no choice.  We might not have the right
     architecture selected, because we haven't yet sent qPart:features, and
     in turn that means we might clobber the no-features architecture
     with the g packet from a feature-ful architecture.  Really, sending a
     g packet at all before we know the target features is asking for
     trouble.  Order of initialization needs to be changed.  */
  if (buf_len != 2 * rs->sizeof_g_packet)
d3293 3
a3295 9
	{
	  if (rs->regs[i].pnum == -1)
	    continue;

	  if (rs->regs[i].offset >= rs->sizeof_g_packet)
	    rs->regs[i].in_g_packet = 0;
	  else
	    rs->regs[i].in_g_packet = 1;
	}
@


1.201
log
@	* Makefile.in (remote.o): Update.
	* remote.c (show_packet_config_cmd): Shorten messages.
	(remote_set_cmdlist, remote_show_cmdlist): Make file-static.
	(show_remote_cmd): Iterate.
	(_initialize_remote): Remove remote_set_cmdlist,
	remote_show_cmdlist.
@
text
@d732 15
a746 2
/* Should we try the 'vCont' (descriptive resume) request?  */
static struct packet_config remote_protocol_vcont;
d748 1
a748 6
static void
set_remote_protocol_vcont_packet_cmd (char *args, int from_tty,
				      struct cmd_list_element *c)
{
  update_packet_config (&remote_protocol_vcont);
}
d751 2
a752 3
show_remote_protocol_vcont_packet_cmd (struct ui_file *file, int from_tty,
				       struct cmd_list_element *c,
				       const char *value)
d754 1
a754 2
  show_packet_config_cmd (&remote_protocol_vcont);
}
d756 12
a767 8
/* Should we try the 'qSymbol' (target symbol lookup service) request?  */
static struct packet_config remote_protocol_qSymbol;

static void
set_remote_protocol_qSymbol_packet_cmd (char *args, int from_tty,
				  struct cmd_list_element *c)
{
  update_packet_config (&remote_protocol_qSymbol);
d771 3
a773 3
show_remote_protocol_qSymbol_packet_cmd (struct ui_file *file, int from_tty,
					 struct cmd_list_element *c,
					 const char *value)
d775 1
a775 2
  show_packet_config_cmd (&remote_protocol_qSymbol);
}
d777 12
a788 17
/* Should we try the 'P' (set register) request?  */

static struct packet_config remote_protocol_P;

static void
set_remote_protocol_P_packet_cmd (char *args, int from_tty,
				  struct cmd_list_element *c)
{
  update_packet_config (&remote_protocol_P);
}

static void
show_remote_protocol_P_packet_cmd (struct ui_file *file, int from_tty,
				   struct cmd_list_element *c,
				   const char *value)
{
  show_packet_config_cmd (&remote_protocol_P);
a802 80
static struct packet_config remote_protocol_Z[NR_Z_PACKET_TYPES];

/* FIXME: Instead of having all these boiler plate functions, the
   command callback should include a context argument.  */

static void
set_remote_protocol_Z_software_bp_packet_cmd (char *args, int from_tty,
					      struct cmd_list_element *c)
{
  update_packet_config (&remote_protocol_Z[Z_PACKET_SOFTWARE_BP]);
}

static void
show_remote_protocol_Z_software_bp_packet_cmd (struct ui_file *file, int from_tty,
					       struct cmd_list_element *c,
					       const char *value)
{
  show_packet_config_cmd (&remote_protocol_Z[Z_PACKET_SOFTWARE_BP]);
}

static void
set_remote_protocol_Z_hardware_bp_packet_cmd (char *args, int from_tty,
					      struct cmd_list_element *c)
{
  update_packet_config (&remote_protocol_Z[Z_PACKET_HARDWARE_BP]);
}

static void
show_remote_protocol_Z_hardware_bp_packet_cmd (struct ui_file *file, int from_tty,
					       struct cmd_list_element *c,
					       const char *value)
{
  show_packet_config_cmd (&remote_protocol_Z[Z_PACKET_HARDWARE_BP]);
}

static void
set_remote_protocol_Z_write_wp_packet_cmd (char *args, int from_tty,
					      struct cmd_list_element *c)
{
  update_packet_config (&remote_protocol_Z[Z_PACKET_WRITE_WP]);
}

static void
show_remote_protocol_Z_write_wp_packet_cmd (struct ui_file *file, int from_tty,
					    struct cmd_list_element *c,
					    const char *value)
{
  show_packet_config_cmd (&remote_protocol_Z[Z_PACKET_WRITE_WP]);
}

static void
set_remote_protocol_Z_read_wp_packet_cmd (char *args, int from_tty,
					      struct cmd_list_element *c)
{
  update_packet_config (&remote_protocol_Z[Z_PACKET_READ_WP]);
}

static void
show_remote_protocol_Z_read_wp_packet_cmd (struct ui_file *file, int from_tty,
					   struct cmd_list_element *c,
					   const char *value)
{
  show_packet_config_cmd (&remote_protocol_Z[Z_PACKET_READ_WP]);
}

static void
set_remote_protocol_Z_access_wp_packet_cmd (char *args, int from_tty,
					      struct cmd_list_element *c)
{
  update_packet_config (&remote_protocol_Z[Z_PACKET_ACCESS_WP]);
}

static void
show_remote_protocol_Z_access_wp_packet_cmd (struct ui_file *file, int from_tty,
					     struct cmd_list_element *c,
					     const char *value)
{
  show_packet_config_cmd (&remote_protocol_Z[Z_PACKET_ACCESS_WP]);
}

d815 2
a816 2
      remote_protocol_Z[i].detect = remote_Z_packet_detect;
      update_packet_config (&remote_protocol_Z[i]);
d828 1
a828 1
      show_packet_config_cmd (&remote_protocol_Z[i]);
a831 12
/* Should we try the 'X' (remote binary download) packet?

   This variable (available to the user via "set remote X-packet")
   dictates whether downloads are sent in binary (via the 'X' packet).
   We assume that the stub can, and attempt to do it. This will be
   cleared if the stub does not understand it. This switch is still
   needed, though in cases when the packet is supported in the stub,
   but the connection does not allow it (i.e., 7-bit serial connection
   only).  */

static struct packet_config remote_protocol_binary_download;

a842 71
static void
set_remote_protocol_binary_download_cmd (char *args,
					 int from_tty,
					 struct cmd_list_element *c)
{
  update_packet_config (&remote_protocol_binary_download);
}

static void
show_remote_protocol_binary_download_cmd (struct ui_file *file, int from_tty,
					  struct cmd_list_element *c,
					  const char *value)
{
  show_packet_config_cmd (&remote_protocol_binary_download);
}

/* Should we try the 'qPart:auxv' (target auxiliary vector read) request?  */
static struct packet_config remote_protocol_qPart_auxv;

static void
set_remote_protocol_qPart_auxv_packet_cmd (char *args, int from_tty,
					   struct cmd_list_element *c)
{
  update_packet_config (&remote_protocol_qPart_auxv);
}

static void
show_remote_protocol_qPart_auxv_packet_cmd (struct ui_file *file, int from_tty,
					    struct cmd_list_element *c,
					    const char *value)
{
  show_packet_config_cmd (&remote_protocol_qPart_auxv);
}

/* Should we try the 'qGetTLSAddr' (Get Thread Local Storage Address) request? */
static struct packet_config remote_protocol_qGetTLSAddr;

static void
set_remote_protocol_qGetTLSAddr_packet_cmd (char *args, int from_tty,
				  struct cmd_list_element *c)
{
  update_packet_config (&remote_protocol_qGetTLSAddr);
}

static void
show_remote_protocol_qGetTLSAddr_packet_cmd (struct ui_file *file, int from_tty,
					     struct cmd_list_element *c,
					     const char *value)
{
  show_packet_config_cmd (&remote_protocol_qGetTLSAddr);
}

static struct packet_config remote_protocol_p;

static void
set_remote_protocol_p_packet_cmd (char *args, int from_tty,
				  struct cmd_list_element *c)
{
  update_packet_config (&remote_protocol_p);
}

static void
show_remote_protocol_p_packet_cmd (struct ui_file *file, int from_tty,
				   struct cmd_list_element *c,
				   const char *value)
{
  show_packet_config_cmd (&remote_protocol_p);
}



d1942 2
a1943 11
  update_packet_config (&remote_protocol_P);
  update_packet_config (&remote_protocol_p);
  update_packet_config (&remote_protocol_qSymbol);
  update_packet_config (&remote_protocol_vcont);
  for (i = 0; i < NR_Z_PACKET_TYPES; i++)
    update_packet_config (&remote_protocol_Z[i]);
  /* Force remote_write_bytes to check whether target supports binary
     downloading.  */
  update_packet_config (&remote_protocol_binary_download);
  update_packet_config (&remote_protocol_qPart_auxv);
  update_packet_config (&remote_protocol_qGetTLSAddr);
d1956 1
a1956 1
  if (remote_protocol_qSymbol.support == PACKET_DISABLE)
d1966 1
a1966 1
  packet_ok (reply, &remote_protocol_qSymbol);
d2285 1
a2285 1
  packet_ok (buf, &remote_protocol_vcont);
d2309 1
a2309 1
  if (remote_protocol_vcont.support == PACKET_SUPPORT_UNKNOWN)
d2312 1
a2312 1
  if (remote_protocol_vcont.support == PACKET_DISABLE)
d3106 1
a3106 1
      switch (remote_protocol_p.support)
d3119 1
a3119 1
	      remote_protocol_p.support = PACKET_ENABLE;
d3127 1
a3127 1
	      remote_protocol_p.support = PACKET_DISABLE;
d3231 1
a3231 1
  switch (remote_protocol_P.support)
d3283 1
a3283 1
      switch (remote_protocol_P.support)
d3296 1
a3296 1
	      remote_protocol_P.support = PACKET_ENABLE;
d3304 1
a3304 1
	      remote_protocol_P.support = PACKET_DISABLE;
d3409 1
a3409 1
  switch (remote_protocol_binary_download.support)
d3436 1
a3436 1
	    remote_protocol_binary_download.support = PACKET_DISABLE;
d3443 1
a3443 1
	    remote_protocol_binary_download.support = PACKET_ENABLE;
d3493 1
a3493 1
  switch (remote_protocol_binary_download.support)
d3538 1
a3538 1
  switch (remote_protocol_binary_download.support)
d4325 1
a4325 1
  if (remote_protocol_Z[Z_PACKET_SOFTWARE_BP].support != PACKET_DISABLE)
d4341 1
a4341 1
      switch (packet_ok (buf, &remote_protocol_Z[Z_PACKET_SOFTWARE_BP]))
d4377 1
a4377 1
  if (remote_protocol_Z[Z_PACKET_SOFTWARE_BP].support != PACKET_DISABLE)
d4432 1
a4432 1
  if (remote_protocol_Z[packet].support == PACKET_DISABLE)
d4434 2
a4435 2
	   remote_protocol_Z[packet].name,
	   remote_protocol_Z[packet].title);
d4446 1
a4446 1
  switch (packet_ok (buf, &remote_protocol_Z[packet]))
d4467 1
a4467 1
  if (remote_protocol_Z[packet].support == PACKET_DISABLE)
d4469 2
a4470 2
	   remote_protocol_Z[packet].name,
	   remote_protocol_Z[packet].title);
d4480 1
a4480 1
  switch (packet_ok (buf, &remote_protocol_Z[packet]))
d4558 1
a4558 1
  if (remote_protocol_Z[Z_PACKET_HARDWARE_BP].support == PACKET_DISABLE)
d4560 2
a4561 2
	   remote_protocol_Z[Z_PACKET_HARDWARE_BP].name,
	   remote_protocol_Z[Z_PACKET_HARDWARE_BP].title);
d4574 1
a4574 1
  switch (packet_ok (buf, &remote_protocol_Z[Z_PACKET_HARDWARE_BP]))
d4600 1
a4600 1
  if (remote_protocol_Z[Z_PACKET_HARDWARE_BP].support == PACKET_DISABLE)
d4602 2
a4603 2
	   remote_protocol_Z[Z_PACKET_HARDWARE_BP].name,
	   remote_protocol_Z[Z_PACKET_HARDWARE_BP].title);
d4616 1
a4616 1
  switch (packet_ok (buf, &remote_protocol_Z[Z_PACKET_HARDWARE_BP]))
d4818 1
a4818 1
      if (remote_protocol_qPart_auxv.support != PACKET_DISABLE)
d4833 2
a4834 1
	      if (packet_ok (buf2, &remote_protocol_qPart_auxv) != PACKET_OK)
d5144 1
a5144 1
  if (remote_protocol_qGetTLSAddr.support != PACKET_DISABLE)
d5162 1
a5162 1
      result = packet_ok (buf, &remote_protocol_qGetTLSAddr);
d5561 1
a5561 1
  add_packet_config_cmd (&remote_protocol_binary_download,
d5563 2
a5564 2
			 set_remote_protocol_binary_download_cmd,
			 show_remote_protocol_binary_download_cmd,
d5568 1
a5568 1
  add_packet_config_cmd (&remote_protocol_vcont,
d5570 2
a5571 2
			 set_remote_protocol_vcont_packet_cmd,
			 show_remote_protocol_vcont_packet_cmd,
d5575 1
a5575 1
  add_packet_config_cmd (&remote_protocol_qSymbol,
d5577 2
a5578 2
			 set_remote_protocol_qSymbol_packet_cmd,
			 show_remote_protocol_qSymbol_packet_cmd,
d5582 1
a5582 1
  add_packet_config_cmd (&remote_protocol_P,
d5584 2
a5585 2
			 set_remote_protocol_P_packet_cmd,
			 show_remote_protocol_P_packet_cmd,
d5589 1
a5589 1
  add_packet_config_cmd (&remote_protocol_p,
d5591 2
a5592 2
			 set_remote_protocol_p_packet_cmd,
			 show_remote_protocol_p_packet_cmd,
d5596 1
a5596 1
  add_packet_config_cmd (&remote_protocol_Z[Z_PACKET_SOFTWARE_BP],
d5598 2
a5599 2
			 set_remote_protocol_Z_software_bp_packet_cmd,
			 show_remote_protocol_Z_software_bp_packet_cmd,
d5603 1
a5603 1
  add_packet_config_cmd (&remote_protocol_Z[Z_PACKET_HARDWARE_BP],
d5605 2
a5606 2
			 set_remote_protocol_Z_hardware_bp_packet_cmd,
			 show_remote_protocol_Z_hardware_bp_packet_cmd,
d5610 1
a5610 1
  add_packet_config_cmd (&remote_protocol_Z[Z_PACKET_WRITE_WP],
d5612 2
a5613 2
			 set_remote_protocol_Z_write_wp_packet_cmd,
			 show_remote_protocol_Z_write_wp_packet_cmd,
d5617 1
a5617 1
  add_packet_config_cmd (&remote_protocol_Z[Z_PACKET_READ_WP],
d5619 2
a5620 2
			 set_remote_protocol_Z_read_wp_packet_cmd,
			 show_remote_protocol_Z_read_wp_packet_cmd,
d5624 1
a5624 1
  add_packet_config_cmd (&remote_protocol_Z[Z_PACKET_ACCESS_WP],
d5626 2
a5627 2
			 set_remote_protocol_Z_access_wp_packet_cmd,
			 show_remote_protocol_Z_access_wp_packet_cmd,
d5631 1
a5631 1
  add_packet_config_cmd (&remote_protocol_qPart_auxv,
d5633 2
a5634 2
			 set_remote_protocol_qPart_auxv_packet_cmd,
			 show_remote_protocol_qPart_auxv_packet_cmd,
d5638 1
a5638 1
  add_packet_config_cmd (&remote_protocol_qGetTLSAddr,
d5640 2
a5641 2
			 set_remote_protocol_qGetTLSAddr_packet_cmd,
			 show_remote_protocol_qGetTLSAddr_packet_cmd,
@


1.200
log
@	PR gdb/1914
	* fork-child.c (fork_inferior): Don't call
	solib_create_inferior_hook.
	* infcmd.c (post_create_inferior): Call solib_add,
	solib_create_inferior_hook, and re_enable_breakpoints_in_shlibs.
	(attach_command): Don't call solib_add or
	re_enable_breakpoints_in_shlibs.  Call post_create_inferior
	instead.
	* remote.c (remote_open_1): Don't call solib_create_inferior_hook
	or observer_notify_inferior_created.  Call post_create_inferior
	instead.
	* corelow.c: Don't include "observer.h".
	(solib_add_stub): Deleted.
	(core_open): Don't call observer_notify_inferior_created or
	solib_add_stub.  Call post_create_inferior instead.
	* inf-ptrace.c: Don't include "observer.h".
	(inf_ptrace_attach): Don't call observer_notify_inferior_created.
	* inf-ttrace.c: Don't include "observer.h".
	(inf_ttrace_attach): Don't call observer_notify_inferior_created.
	* inferior.h (solib_create_inferior_hook): Remove redundant
	prototype.
	* inftarg.c: Don't include "observer.h".
	(child_attach): Don't call observer_notify_inferior_created.
	* Makefile.in: Update dependencies.
@
text
@d46 2
d617 2
a618 2
      printf_filtered (_("Support for remote protocol `%s' (%s) packet is auto-detected, currently %s.\n"),
		       config->name, config->title, support);
d622 2
a623 2
      printf_filtered (_("Support for remote protocol `%s' (%s) packet is currently %s.\n"),
		       config->name, config->title, support);
d5549 3
d5560 19
a5578 10
  /* FIXME: cagney/2002-06-15: This function should iterate over
     remote_show_cmdlist for a list of sub commands to show.  */
  show_remote_protocol_Z_packet_cmd (gdb_stdout, from_tty, NULL, NULL);
  show_remote_protocol_P_packet_cmd (gdb_stdout, from_tty, NULL, NULL);
  show_remote_protocol_p_packet_cmd (gdb_stdout, from_tty, NULL, NULL);
  show_remote_protocol_qSymbol_packet_cmd (gdb_stdout, from_tty, NULL, NULL);
  show_remote_protocol_vcont_packet_cmd (gdb_stdout, from_tty, NULL, NULL);
  show_remote_protocol_binary_download_cmd (gdb_stdout, from_tty, NULL, NULL);
  show_remote_protocol_qPart_auxv_packet_cmd (gdb_stdout, from_tty, NULL, NULL);
  show_remote_protocol_qGetTLSAddr_packet_cmd (gdb_stdout, from_tty, NULL, NULL);
a5606 3
  static struct cmd_list_element *remote_set_cmdlist;
  static struct cmd_list_element *remote_show_cmdlist;

d5812 4
a5815 1
  /* Keep the old ``set remote Z-packet ...'' working.  */
@


1.199
log
@	* infcmd.c: Include "observer.h".
	(post_create_inferior): New function.
	(run_command_1): Call it.  Also call proceed.
	* inferior.h (post_create_inferior): New prototype.
	* Makefile.in (infcmd.o): Update.

	* gnu-nat.c (gnu_create_inferior): Don't call proceed.
	* go32-nat.c (go32_create_inferior): Likewise.
	* nto-procfs.c (procfs_create_inferior): Likewise.
	* procfs.c (procfs_create_inferior): Likewise.
	* remote-sim.c (gdbsim_create_inferior): Likewise.
	* remote.c (extended_remote_create_inferior)
	(extended_remote_async_create_inferior): Likewise.
	* win32-nat.c (win32_create_inferior): Likewise.
	* wince.c (child_create_inferior): Likewise.

	* monitor.c (monitor_create_inferior): Don't call proceed.
	Set the PC manually.
	* ocd.c (ocd_create_inferior): Likewise.
	* remote-e7000.c (e7000_create_inferior): Likewise.
	* remote-m32r-sdi.c (m32r_create_inferior): Likewise.
	* remote-mips.c (mips_create_inferior): Likewise.
	* remote-rdp.c (remote_rdp_create_inferior): Likewise.
	* remote-sds.c (sds_create_inferior): Likewise.
	* remote-st.c (st2000_create_inferior): Likewise.

	* inf-ptrace.c (inf_ptrace_create_inferior): Don't call
	proceed or observer_notify_inferior_created.
	* inf-ttrace.c (inf_ttrace_create_inferior): Likewise.
	* inftarg.c (child_create_inferior): Likewise.
@
text
@d2298 1
a2298 5
  /* FIXME: need a master target_open vector from which all
     remote_opens can be called, so that stuff like this can
     go there.  Failing that, the following code must be copied
     to the open function for any remote target that wants to
     support svr4 shared libraries.  */
a2299 1
  /* Set up to detect and load shared libraries.  */
d2301 1
a2301 10
    {
#ifdef SOLIB_CREATE_INFERIOR_HOOK
      SOLIB_CREATE_INFERIOR_HOOK (PIDGET (inferior_ptid));
#else
      solib_create_inferior_hook ();
#endif
      remote_check_symbols (symfile_objfile);
    }

  observer_notify_inferior_created (&current_target, from_tty);
@


1.198
log
@	* remote-fileio.c (remote_fileio_return_success): Take a gdb_byte
	argument.
	(remote_fileio_func_open, remote_fileio_func_rename)
	(remote_fileio_func_unlink, remote_fileio_func_stat)
	(remote_fileio_func_fstat, remote_fileio_func_gettimeofday)
	(remote_fileio_func_system): Cast the arguments to
	remote_read_bytes and remote_write_bytes.
	(remote_fileio_func_read, remote_fileio_func_write): Use a
	gdb_byte buffer.
	* remote.h (remote_read_bytes, remote_write_bytes): Update
	prototypes.
	* remote.c (hex2bin, bin2hex): Use gdb_byte for the BIN argument.
	(threadref_to_int): Replace bogus char * cast.
	(remote_unpack_thread_info_response): Use int for tag.
	(remote_threads_extra_info, remote_check_symbols): Cast string
	arguments to hex2bin.
	(remote_wait): Use a char buffer for packets and a gdb_byte
	buffer for registers.
	(remote_async_wait): Likewise.
	(remote_prepare_to_store, store_register_using_P)
	(remote_store_registers): Use gdb_byte buffers.
	(remote_write_bytes, remote_read_bytes): Use a gdb_byte pointer
	for MYADDR and char buffers for strings.
	(remote_xfer_partial): Add casts for string operations on READBUF.
	(remote_rcmd): Cast strings passed to bin2hex.
@
text
@a4425 3

  /* Let the remote process run.  */
  proceed (-1, TARGET_SIGNAL_0, 0);
a4450 3

  /* Let the remote process run.  */
  proceed (-1, TARGET_SIGNAL_0, 0);
@


1.197
log
@* remote.c (get_memory_packet_size, set_thread)
(remote_unpack_thread_info_response, remote_get_threadinfo)
(parse_threadlist_response, remote_get_threadlist)
(remote_current_thread, remote_threads_info)
(remote_threads_extra_info, extended_remote_restart, get_offsets)
(remote_check_symbols, remote_open_1, remote_detach)
(remote_async_wait, remote_fetch_registers)
(remote_store_registers, check_binary_download, putpkt_binary)
(remote_insert_breakpoint, remote_insert_watchpoint)
(remote_remove_watchpoint, remote_insert_hw_breakpoint)
(remote_remove_hw_breakpoint, remote_xfer_partial, remote_rcmd)
(packet_command): Remove redundant parenthesis.
@
text
@d175 1
a175 1
static int hex2bin (const char *hex, char *bin, int count);
d177 1
a177 1
static int bin2hex (const char *bin, char *hex, int count);
d1412 1
a1412 1
  scan = (char *) ref;
d1490 1
a1490 1
  unsigned int tag;
d1879 1
a1879 1
	  result = hex2bin (bufp, display_buf, n);
d2137 1
a2137 1
      end = hex2bin (tmp, msg, strlen (tmp) / 2);
d2378 1
a2378 1
hex2bin (const char *hex, char *bin, int count)
d2408 1
a2408 1
bin2hex (const char *bin, char *hex, int count)
d2413 1
a2413 1
    count = strlen (bin);
d2833 1
a2833 1
  unsigned char *buf = alloca (rs->remote_packet_size);
d2842 1
a2842 1
      unsigned char *p;
d2865 1
a2865 1
	    char regs[MAX_REGISTER_SIZE];
d2877 1
a2877 1
		unsigned char *p1;
d2893 1
a2893 1
		    p1 = (unsigned char *) p_temp;
d2900 1
a2900 1
		    p1 = (unsigned char *) strchr (p, ':');
d2909 1
a2909 1
			p = (unsigned char *) p_temp;
d2924 1
a2924 1
			  p = (unsigned char *) p_temp;
d2942 1
a2942 1
		    fieldsize = hex2bin (p, regs, 
d3022 1
a3022 1
  unsigned char *buf = alloca (rs->remote_packet_size);
d3033 1
a3033 1
      unsigned char *p;
d3060 1
a3060 1
	    char regs[MAX_REGISTER_SIZE];
d3072 1
a3072 1
		unsigned char *p1;
d3088 1
a3088 1
		    p1 = (unsigned char *) p_temp;
d3095 1
a3095 1
		    p1 = (unsigned char *) strchr (p, ':');
d3104 1
a3104 1
			p = (unsigned char *) p_temp;
d3117 1
a3117 1
 			p_temp = (unsigned char *) strchr (p1 + 1, ';');
d3137 1
a3137 1
		    fieldsize = hex2bin (p, regs, 
d3408 1
a3408 1
  char buf[MAX_REGISTER_SIZE];
d3435 1
a3435 1
  char regp[MAX_REGISTER_SIZE];
d3456 1
a3456 1
  char *regs;
d3640 1
a3640 1
remote_write_bytes (CORE_ADDR memaddr, char *myaddr, int len)
d3642 3
a3644 3
  unsigned char *buf;
  unsigned char *p;
  unsigned char *plen;
d3650 1
a3650 1
  unsigned char *payload_start;
d3800 1
a3800 1
remote_read_bytes (CORE_ADDR memaddr, char *myaddr, int len)
d5081 1
a5081 1
  getpkt (readbuf, len, 0);
d5083 1
a5083 1
  return strlen (readbuf);
d5109 1
a5109 1
  bin2hex (command, p, 0);
@


1.196
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d4 1
a4 1
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
d380 1
a380 1
   memory read/write packet.  MIN ((rs->remote_packet_size),
d382 1
a382 1
   values (fifo overruns, et.al.)  and some users need larger values
d423 1
a423 1
      what_they_get = (rs->remote_packet_size);
d543 3
a545 3
     increased beyond (rs->remote_packet_size).  */
  if (size > (rs->remote_packet_size))
    size = (rs->remote_packet_size);
d1063 1
a1063 1
  getpkt (buf, (rs->remote_packet_size), 0);
d1492 1
a1492 1
  char *limit = pkt + (rs->remote_packet_size);	/* plausible parsing limit */
d1587 1
a1587 1
  getpkt (threadinfo_pkt, (rs->remote_packet_size), 0);
d1621 1
a1621 1
  limit = pkt + ((rs->remote_packet_size) - BUF_THREAD_ID_SIZE);
d1649 2
a1650 2
  if ((((result_limit + 1) * BUF_THREAD_ID_SIZE) + 10) >= (rs->remote_packet_size))
    result_limit = ((rs->remote_packet_size) / BUF_THREAD_ID_SIZE) - 2;
d1655 1
a1655 1
  getpkt (t_response, (rs->remote_packet_size), 0);
d1766 1
a1766 1
  getpkt (buf, (rs->remote_packet_size), 0);
d1813 1
a1813 1
      getpkt (bufp, (rs->remote_packet_size), 0);
d1833 1
a1833 1
	      getpkt (bufp, (rs->remote_packet_size), 0);
d1875 1
a1875 1
      getpkt (bufp, (rs->remote_packet_size), 0);
a1912 1

d1915 1
a1915 1
/*  Restart the remote side; this is an extended protocol operation.  */
d1931 1
a1931 1
  getpkt (buf, (rs->remote_packet_size), 0);
d1957 1
a1957 2

  getpkt (buf, (rs->remote_packet_size), 0);
d2131 1
a2131 1
  getpkt (reply, (rs->remote_packet_size), 0);
d2147 1
a2147 1
      getpkt (reply, (rs->remote_packet_size), 0);
d2295 1
a2295 1
      getpkt (buf, (rs->remote_packet_size), 0);
d2334 1
a2334 1
  remote_send (buf, (rs->remote_packet_size));
d2845 1
a2845 1
      getpkt (buf, (rs->remote_packet_size), 1);
d3041 1
a3041 1
      getpkt (buf, (rs->remote_packet_size), wait_forever_enabled_p);
d3313 1
a3313 1
  remote_send (buf, (rs->remote_packet_size));
d3335 1
a3335 1
      getpkt (buf, (rs->remote_packet_size), 0);
d3511 1
a3511 1
  remote_send (buf, (rs->remote_packet_size));
d3588 1
d3609 1
a3609 1
	getpkt (buf, (rs->remote_packet_size), 0);
d3964 1
a3964 1
   (rs->remote_packet_size) - 5 to account for the $, # and checksum,
d3975 1
a3975 1
  long sizeof_junkbuf = (rs->remote_packet_size);
d4525 1
a4525 1
      getpkt (buf, (rs->remote_packet_size), 0);
d4578 1
a4578 1
      getpkt (buf, (rs->remote_packet_size), 0);
d4630 1
a4630 1
  getpkt (buf, (rs->remote_packet_size), 0);
d4664 1
a4664 1
  getpkt (buf, (rs->remote_packet_size), 0);
d4758 1
a4758 1
  getpkt (buf, (rs->remote_packet_size), 0);
d4800 1
a4800 1
  getpkt (buf, (rs->remote_packet_size), 0);
d4923 1
a4923 1
      getpkt (buf, (rs->remote_packet_size), 0);
d5045 3
a5047 3
  /* Minimum outbuf size is (rs->remote_packet_size) - if bufsiz is
     not large enough let the caller.  */
  if (len < (rs->remote_packet_size))
d5067 1
a5067 1
  while (annex[i] && (i < ((rs->remote_packet_size) - 8)))
d5105 1
a5105 1
  if ((strlen (buf) + strlen (command) * 2 + 8/*misc*/) > (rs->remote_packet_size))
d5119 1
a5119 1
      getpkt (buf, (rs->remote_packet_size), 0);
d5160 1
a5160 1
  getpkt (buf, (rs->remote_packet_size), 0);
@


1.195
log
@* remote.c (remote_pid_to_str): Use xsnprintf instead of snprintf.
@
text
@d3 1
a3 1
   Copyright 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
d21 2
a22 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.195.6.1
log
@	Backport:
	2006-01-24  Daniel Jacobowitz  <dan@@codesourcery.com>

	* infcmd.c: Include "observer.h".
	(post_create_inferior): New function.
	(run_command_1): Call it.  Also call proceed.
	* inferior.h (post_create_inferior): New prototype.
	* Makefile.in (infcmd.o): Update.
...
@
text
@d4427 3
d4455 3
@


1.195.6.2
log
@	Backport:
	2006-01-24  Daniel Jacobowitz  <dan@@codesourcery.com>

	PR gdb/1914
	* fork-child.c (fork_inferior): Don't call
	solib_create_inferior_hook.
	* infcmd.c (post_create_inferior): Call solib_add,
	solib_create_inferior_hook, and re_enable_breakpoints_in_shlibs.
	(attach_command): Don't call solib_add or
	re_enable_breakpoints_in_shlibs.  Call post_create_inferior
	instead.
...
@
text
@d2300 5
a2304 1
  post_create_inferior (&current_target, from_tty);
d2306 1
d2308 10
a2317 1
    remote_check_symbols (symfile_objfile);
@


1.195.2.1
log
@2005-03-30  Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdb/Makefile.in (arm-linux-nat.o): Update dependencies.
	* gdb/arm-linux-nat.c: Include "gdb_assert.h".
	(PTRACE_GETWMMXREGS, PTRACE_SETWMMXREGS): Define.
	(arm_linux_has_wmmx_registers): New flag.
	(GET_THREAD_ID): Remove stray punctuation.
	(IWMMXT_REGS_SIZE): Define.
	(fetch_wmmx_regs, store_wmmx_regs): New functions.
	(fetch_inferior_registers, store_inferior_registers): Call them.
	(arm_linux_available_registers): New function.
	* gdb/inftarg.c (child_xfer_partial): Handle
	TARGET_OBJECT_AVAILABLE_REGISTERS.
	* gdb/config/arm/nm-linux.h (arm_linux_available_registers): Add
	prototype.
	(NATIVE_XFER_AVAILABLE_REGISTERS): Define.

	* gdb/gdbserver/linux-arm-low.c (arm_fill_wmmxregset)
	(arm_store_wmmxregset): Remove stray text.
	(arm_available_registers): Remove debugging output.  Use hex.
	* gdb/gdbserver/regcache.c (num_registers): Make global.
	* gdb/gdbserver/server.c (handle_p_packet, handle_P_packet): Check
	the value of regnum.

2005-03-28  Paul Brook  <paul@@codesourcery.com>
	Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdb/Makefile.in: arm-tdep.o depends on $(observer_h).
	* gdb/arm-linux-nat.c (fetch_fpregister, fetch_fpregs,
	store_fpregister, store_fpregs): Rename...
	(fetch_fpa_register, fetch_fpa_regs, store_fpa_register,
	store_fpa_regs): ... to this.
	* gdb/arm-linux-tdep.c (arm_linux_init_abi): Provide ABI specific
	overrides.
	* gdb/arm-tdep.c: Include opserver.h.
	(struct gdbarch_tdep_info): Add.
	(arm_push_dummy_call): Handle doubleword alignment.
	(arm_register_type): Handle iWMMXt and VFP regs.
	(arm_register_byte): Ditto.
	(arm_pseudo_register_read): New function.
	(arm_pseudo_register_write): New function.
	(arm_dwarf_reg_to_regnum): New function.
	(arm_register_sim_regno): Handle iWMMXT regs.
	(arm_register_remote_regno): New function.
	(arm_extract_return_value): Use new macro names.
	(arm_register_name): Handle iWMMXt and VFP registers.
	(arm_sim_available_registers): New function.
	(arm_update_architecture): New function.
	(arm_gdbarch_init): Handle optional register sets.  Register new
	hooks.  Fix misleading error message.
	(_initialize_arm_tdep): Call observer_attach_inferior_created.
	* gdb/arm-tdep.h (ARM_NUM_FP_ARG_REGS, ARM_LAST_FP_ARG_REGNUM,
	FP_REGISTER_SIZE, NUM_FREGS): Rename ...
	(ARM_NUM_FPA_ARG_REGS, ARM_LAST_FPA_ARG_REGNUM, FPA_REGISTER_SIZE,
	NUM_FPA_REGS): ... to this.
	(NUM_IWMMXT_COP0REGS, NUM_IWMMXT_COP1REGS, NUM_IWMMXT_REGS,
	IWMMXT_COP0_REGSIZE, IWMMXT_COP1_REGSIZE, NUM_VFP_XREGS,
	VFP_XREG_SIZE, NUM_VFP_SREGS, VFP_SREG_SIZE, NUM_VFP_PSEUDOS): Define.
	(struct gdbarch_tdep): Add target_has_iwmmxt_regs,
	target_has_vfp_regs, first_iwmmxt_regnum, target_iwmmxt_regnum,
	first_vfp_regnum, first_vfp_pseudo and target_vfp_regnum.
	* gdb/gdbarch.c (struct gdbarch): Add remote_num_g_packet_regs,
	sim_available_registers and register_remote_regno.
	(startup_gdbarch, verify_gdbarch): Ditto.
	(gdbarch_dump): Dump new fields.
	(gdbarch_remote_num_g_packet_regs_p, gdbarch_remote_num_g_packet_regs,
	set_gdbarch_remote_num_g_packet_regs,
	gdbarch_sim_available_registers_p, gdbarch_sim_available_registers,
	set_gdbarch_sim_available_registers, gdbarch_register_remote_regno_p,
	gdbarch_register_remote_regno, set_gdbarch_register_remote_regno):
	New functions.
	* gdb/gdbarch.h: Add prototypes.
	* gdb/gdbarch.sh: Add new fields.
	(deprecated_current_gdbarch_select_hack): Call flush_cached_frames.
	* gdb/remote-sim.h (gdbsim_create_inferior): Call
	observer_notify_inferior_created.
	(gdbsim_xfer_partial): New function.
	(init_gdbsim_ops): Use it.
	* gdb/remote.c (struct remote_state): Add num_g_regs.
	(init_remote_state): Only consider hard regs.  Allow target to provide
	register mapping.
	(packet_reg_from_regnum): Don't check pseudo regs.
	(packet_reg_from_pnum): Ditto.
	(remote_protocol_qPart_availableRegisters): Add.
	(set_remote_protocol_qPart_availableRegisters_packet_cmd,
	show_remote_protocol_qPart_availableRegisters_packet_cmd): New
	functions.
	(fetch_register_using_p, store_register_using_P): Handle arbitrary
	register mappings.
	(fetch_registers_using_g): New function.
	(remote_fetch_registers): Use it.
	(store_registers_using_G): New function.
	(remote_store_registers): Use it.
	(remote_xfer_partial): Handle TARGET_OBJECT_AVAILABLE_REGISTERS.
	(show_remote_cmd): Display availableRegisters.
	(_initialize_remote): Register qPart_availableRegisters.
	* gdb/target.h (enum target_object): Add
	TARGET_OBJECT_AVAILABLE_REGISTERS.
	* gdb/gdbserver/configure.srv (arm*-*-linux*): set
	srv_linux_regsets=yes.
	* gdb/gdbserver/linux-arm-low.c (PTRACE_GETWMMXREGS,
	PTRACE_SETWMMXREGS): Define.
	(arm_fill_gregset, arm_store_gregset, arm_fill_wmmxregset,
	arm_store_wmmxregset, arm_available_registers): New functions.
	(target_regsets): Add.
	(the_low_target): Use arm_available_registers.
	* gdb/gdbserver/linux-low.c (linux_available_registers): New function.
	(linux_target_op): Use it.
	* gdb/gdbserver/linux-low.h (gdbserver/linux-low.h): Add
	available_registers.
	(use_regsets_p): Declare.
	* gdb/gdbserver/regcache.c (g_register_bytes): Add.
	(regcache_invalidate, registers_to_string, registers_from_string):
	Use it.
	(set_register_cache): Set g_register_bytes.
	(supply_register_as_string): New function.
	* gdb/gdbserver/regcache.h (supply_register_as_string): Add prototype.
	* gdb/gdbserver/server.c (handle_query): Handle
	qPart:availableRegisters.
	(handle_p_packet, handle_P_packet): New functions.
	(main): Handle 'p' and 'P' packets.
	* gdb/gdbserver/target.h (struct target_ops): Add available_registers.
	* gdb/regformats/reg-arm.dat: Add last_g_reg and iWMMXT regs.
	* gdb/regformats/regdat.sh: Handle last_g_reg.
	* gdb/regformats/regdef.h (set_register_cache): Update prototype.
@
text
@a212 1
  long num_g_regs;
d215 1
a215 1
     (making an array NUM_REGS in size).  */
a245 6
  int num_g_regs;

  if (gdbarch_remote_num_g_packet_regs_p (gdbarch))
    num_g_regs = gdbarch_remote_num_g_packet_regs (gdbarch);
  else
    num_g_regs = NUM_REGS;
d250 3
a252 2
  rs->regs = GDBARCH_OBSTACK_CALLOC (gdbarch, NUM_REGS, struct packet_reg);
  for (regnum = 0; regnum < NUM_REGS; regnum++)
d255 1
a255 6

      if (gdbarch_register_remote_regno_p (gdbarch))
	r->pnum = gdbarch_register_remote_regno (gdbarch, regnum);
      else
	r->pnum = regnum;

d258 1
a258 1
      r->in_g_packet = (regnum < num_g_regs);
d262 2
a263 1
      rs->sizeof_g_packet += register_size (current_gdbarch, regnum);
d293 1
a293 1
  if (regnum < 0 && regnum >= NUM_REGS)
d307 1
a307 1
  for (i = 0; i < NUM_REGS; i++)
a980 20
/* FIXME: Kill these duplicated functions.  */
/* Should we try the 'qPart:availableRegisters' request? */
static struct packet_config remote_protocol_qPart_availableRegisters;

static void
set_remote_protocol_qPart_availableRegisters_packet_cmd (char *args, int from_tty,
					   struct cmd_list_element *c)
{
  update_packet_config (&remote_protocol_qPart_availableRegisters);
}

static void
show_remote_protocol_qPart_availableRegisters_packet_cmd (struct ui_file *file, int from_tty,
					    struct cmd_list_element *c,
					    const char * value)
{
  deprecated_show_value_hack (file, from_tty, c, value);
  show_packet_config_cmd (&remote_protocol_qPart_availableRegisters);
}

a2111 1
  update_packet_config (&remote_protocol_qPart_availableRegisters);
d3216 6
a3221 1
/* Fetch a single register using a 'p' packet.  */
d3224 1
a3224 1
fetch_register_using_p (struct packet_reg *reg)
a3230 3
  if (remote_protocol_p.support == PACKET_DISABLE)
    return 0;

d3233 1
a3233 1
  p += hexnumstr (p, reg->pnum);
d3237 4
a3240 15
  if (buf[0] == 0)
    {
      if (remote_protocol_p.support == PACKET_ENABLE)
	error ("Protocol error: p packet enabled but not recognized by stub");
      else
	{
	  /* The stub does not support the 'P' packet.  Use 'G'
	     instead, and don't try using 'P' in the future (it
	     will just waste our time).  */
	  remote_protocol_p.support = PACKET_DISABLE;
	  return 0;
  	}
      }
  
  remote_protocol_p.support = PACKET_ENABLE;
d3242 1
d3245 2
a3246 2
      regcache_raw_supply (current_regcache, reg->regnum, NULL);
      set_register_cached (reg->regnum, -1);
d3250 1
d3256 5
a3260 1
	error("fetch_register_using_p: early buf termination");
d3264 1
a3264 1
  regcache_raw_supply (current_regcache, reg->regnum, regp);
a3267 6
/* Number of bytes of registers this stub implements.  */

static int register_bytes_found;

/* Fetch the registers included in the target's 'g' packet.  */

d3269 1
a3269 1
fetch_registers_using_g (void)
d3279 35
d3374 1
a3374 1
    for (i = 0; i < NUM_REGS; i++)
a3400 32
static void
remote_fetch_registers (int regnum)
{
  struct remote_state *rs = get_remote_state ();
  int i;

  set_thread (PIDGET (inferior_ptid), 1);

  if (regnum >= 0)
    {
      struct packet_reg *reg = packet_reg_from_regnum (rs, regnum);
      gdb_assert (reg != NULL);

      if (fetch_register_using_p (reg))
	return;

      if (!reg->in_g_packet)
	error ("Protocol error: register %ld not supported by stub", reg->regnum);

      fetch_registers_using_g ();
      return;
    }

  fetch_registers_using_g ();

  for (i = 0; i < NUM_REGS; i++)
    if (!rs->regs[i].in_g_packet)
      if (!fetch_register_using_p (&rs->regs[i]))
	error ("Protocol error: register %ld not supported by stub",
	       rs->regs[i].regnum);
}

d3431 1
a3431 1
store_register_using_P (struct packet_reg *reg)
d3434 1
a3439 3
  if (remote_protocol_P.support == PACKET_DISABLE)
    return 0;

d3446 1
a3446 15
  if (buf[0] == 0)
    {
      if (remote_protocol_P.support == PACKET_ENABLE)
	error ("Protocol error: P packet enabled but not recognized by stub");
      else
	{
	  /* The stub does not support the 'P' packet.  Use 'G'
	     instead, and don't try using 'P' in the future (it
	     will just waste our time).  */
	  remote_protocol_P.support = PACKET_DISABLE;
	  return 0;
	}
    }
  
  return 1;
d3449 1
d3453 2
a3454 2
void
store_registers_using_G (void)
d3461 31
d3498 1
a3498 1
    for (i = 0; i < NUM_REGS; i++)
a4458 35

/* Store register REGNUM, or all registers if REGNUM == -1, from the contents
   of the register cache buffer.  FIXME: ignores errors.  */

static void
remote_store_registers (int regnum)
{
  struct remote_state *rs = get_remote_state ();
  int i;

  set_thread (PIDGET (inferior_ptid), 1);

  if (regnum >= 0)
    {
      struct packet_reg *reg = packet_reg_from_regnum (rs, regnum);
      gdb_assert (reg != NULL);

      if (store_register_using_P (reg))
	return;

      if (!reg->in_g_packet)
	error ("Protocol error: register %ld not supported by stub", reg->regnum);

      store_registers_using_G ();
      return;
    }

  store_registers_using_G ();

  for (i = 0; i < NUM_REGS; i++)
    if (!rs->regs[i].in_g_packet)
      if (!store_register_using_P (&rs->regs[i]))
	error ("Protocol error: register %ld not supported by stub",
	       rs->regs[i].regnum);
}
a5037 38
      /* FIXME:
	 - Currently hex encoded.  Should this be just a string?
	 - One way or another remove the copy/paste.
      */
    case TARGET_OBJECT_AVAILABLE_REGISTERS:
      if (remote_protocol_qPart_availableRegisters.support != PACKET_DISABLE)
	{
	  unsigned int total = 0;
	  while (len > 0)
	    {
	      LONGEST n = min ((rs->remote_packet_size - 2) / 2, len);
	      snprintf (buf2, rs->remote_packet_size,
			"qPart:availableRegisters:read::%s,%s",
			phex_nz (offset, sizeof offset),
			phex_nz (n, sizeof n));
	      i = putpkt (buf2);
	      if (i < 0)
		return total > 0 ? total : i;
	      buf2[0] = '\0';
	      getpkt (buf2, rs->remote_packet_size, 0);
	      if (packet_ok (buf2, &remote_protocol_qPart_availableRegisters) != PACKET_OK)
		return total > 0 ? total : -1;
	      if (buf2[0] == 'O' && buf2[1] == 'K' && buf2[2] == '\0')
		break;		/* Got EOF indicator.  */
	      /* Got some data.  */
	      i = hex2bin (buf2, readbuf, len);
	      if (i > 0)
		{
		  readbuf = (void *) ((char *) readbuf + i);
		  offset += i;
		  len -= i;
		  total += i;
		}
	    }
	  return total;
	}
      return -1;

a5585 1
  show_remote_protocol_qPart_availableRegisters_packet_cmd (gdb_stdout, from_tty, NULL, NULL);
a5821 7
  add_packet_config_cmd (&remote_protocol_qPart_availableRegisters,
			 "qPart_availableRegisters", "available-registers",
			 set_remote_protocol_qPart_availableRegisters_packet_cmd,
			 show_remote_protocol_qPart_availableRegisters_packet_cmd,
			 &remote_set_cmdlist, &remote_show_cmdlist,
			 0);

@


1.195.2.2
log
@	Backport:
	2006-01-24  Daniel Jacobowitz  <dan@@codesourcery.com>

	* infcmd.c: Include "observer.h".
	(post_create_inferior): New function.
	(run_command_1): Call it.  Also call proceed.
	* inferior.h (post_create_inferior): New prototype.
	* Makefile.in (infcmd.o): Update.
...
@
text
@d4448 3
d4476 3
@


1.195.2.3
log
@	Backport:
	2006-01-24  Daniel Jacobowitz  <dan@@codesourcery.com>

	PR gdb/1914
	* fork-child.c (fork_inferior): Don't call
	solib_create_inferior_hook.
	* infcmd.c (post_create_inferior): Call solib_add,
	solib_create_inferior_hook, and re_enable_breakpoints_in_shlibs.
	(attach_command): Don't call solib_add or
	re_enable_breakpoints_in_shlibs.  Call post_create_inferior
	instead.
...
@
text
@d2331 5
a2335 1
  post_create_inferior (&current_target, from_tty);
d2337 1
d2339 10
a2348 1
    remote_check_symbols (symfile_objfile);
@


1.194
log
@* remote.c (extended_remote_restart): Pass buffer in call to
xsnprintf instead of a pointer to the buffer.
@
text
@a5318 1
  int size;
d5320 1
a5320 2
  size = snprintf (buf, sizeof buf, "thread %d", ptid_get_pid (ptid));
  gdb_assert (size < sizeof buf);
@


1.193
log
@	* remote.c (set_thread, remote_thread_alive): Replace sprintf
	call with xsnprintf.
	(remote_threads_extra_info, extended_remote_restart)
	(remote_check_symbols, store_register_using_P)
	(compare_sections_command): Ditto.
@
text
@d1926 1
a1926 1
  xsnprintf (&buf, rs->remote_packet_size, "R%x", 0);
@


1.192
log
@	From Wu Zhou <woodzltc@@cn.ibm.com>:
	* remote.c (struct gdb_ext_thread_info): Fix a comment typo.
	(remote_unpack_thread_info_response): Likewise.
@
text
@d1059 1
a1059 1
    sprintf (&buf[2], "-%x", -th);
d1061 1
a1061 1
    sprintf (&buf[2], "%x", th);
d1079 1
a1079 1
    sprintf (buf, "T-%08x", -tid);
d1081 1
a1081 1
    sprintf (buf, "T%08x", tid);
d1872 2
a1873 1
      sprintf (bufp, "qThreadExtraInfo,%x", PIDGET (tp->ptid));
d1894 2
a1895 1
	  n += sprintf(&display_buf[0], " Name: %s,", threadinfo.shortname);
d1897 2
a1898 1
	  n += sprintf(&display_buf[n], " State: %s,", threadinfo.display);
d1900 2
a1901 2
	  n += sprintf(&display_buf[n], " Priority: %s",
		       threadinfo.more_display);
d1926 1
a1926 2
  buf[0] = 'R';
  sprintf (&buf[1], "%x", 0);
d2143 1
a2143 1
	sprintf (msg, "qSymbol::%s", &reply[8]);
d2145 3
a2147 3
	sprintf (msg, "qSymbol:%s:%s",
		 paddr_nz (SYMBOL_VALUE_ADDRESS (sym)),
		 &reply[8]);
d3440 1
a3440 1
  sprintf (buf, "P%s=", phex_nz (reg->pnum, 0));
d4913 2
a4914 1
      sprintf (buf, "qCRC:%lx,%lx", (long) lma, (long) size);
@


1.192.2.1
log
@2005-06-03  Michael Snyder  <msnyder@@redhat.com>

	* tracepoint.c, remote.c, target.c, target.h, etc.:
	Begin moving tracepoint methods into the target vector,
	and migrating some of the remote protocol stuff from
	tracepoint.c into remote.c.
@
text
@a60 2
#include "tracepoint.h"

a5368 35
static int
remote_start_tracepoints (char *args, int from_tty)
{
  fprintf_unfiltered (gdb_stdout, "remote to_start_tracepoints\n");
  return 0;
}

static int
remote_stop_tracepoints (char *args, int from_tty)
{
  fprintf_unfiltered (gdb_stdout, "remote to_stop_tracepoints\n");
  return 0;
}

static int
remote_tracepoint_status (char *args, int from_tty)
{
  struct remote_state *rs = get_remote_state ();
  char *buf = alloca (rs->remote_packet_size);

  if (from_tty && info_verbose)
    fprintf_unfiltered (gdb_stdout, "remote to_tracepoint_status\n");
  putpkt ("qTStatus");
  /* FIXME: How about async?  See tracepoint.c, get_noisy_reply.  */
  getpkt (buf, rs->remote_packet_size, 0);

  if (buf[0] != 'T' ||
      (buf[1] != '0' && buf[1] != '1'))
    return 0;	/* Target does not support.  */

  /* Exported for use by the GUI.  */
  trace_running_p = (buf[1] == '1');
  return 1;
}

a5415 3
  remote_ops.to_start_tracepoints = remote_start_tracepoints;
  remote_ops.to_stop_tracepoints = remote_stop_tracepoints;
  remote_ops.to_tracepoint_status = remote_tracepoint_status;
a5544 3
  remote_async_ops.to_start_tracepoints = remote_start_tracepoints;
  remote_async_ops.to_stop_tracepoints = remote_stop_tracepoints;
  remote_async_ops.to_tracepoint_status = remote_tracepoint_status;
@


1.191
log
@	* dwarf2-frame.c (dwarf2_frame_prev_register): Use gdb_byte.
	* i386-linux-nat.c (fetch_register, store_register, supply_gregset)
	(fill_gregset): Likewise.
	* i386-tdep.c (i386_frame_prev_register)
	(i386_sigtramp_frame_prev_register): Likewise.
	* linux-nat.c (linux_nat_xfer_memory, linux_nat_make_corefile_notes):
	Likewise.
	* linux-thread-db.c (thread_db_xfer_memory): Likewise.
	* remote.c (remote_insert_hw_breakpoint, remote_remove_hw_breakpoint):
	Likewise.
	* target.c (debug_to_insert_hw_breakpoint)
	(debug_to_remove_hw_breakpoint, update_current_target): Likewise.
@
text
@d1117 1
a1117 1
				   blocked/syspended.  */
d1492 1
a1492 1
  char *limit = pkt + (rs->remote_packet_size);	/* plausable parsing limit */
@


1.190
log
@* corelow.c (core_xfer_partial): Change type of readbuf and
writebuf to `gdb_byte *'.
* sparc-nat.c (sparc_xfer_wcookie, sparc_xfer_partial): Change
type of readbuf and writebuf to `gdb_byte *'.
* bsd-uthread.c (bsd_uthread_xfer_partial): Change type of readbuf
and writebuf to `gdb_byte *'.
* inf-ptrace.c (inf_ptrace_xfer_partial): Change type of readbuf
and writebuf to `gdb_byte *'.
* bsd-kvm.c (bsd_kvm_xfer_memory): Replace.
(bsd_kvm_xfer_partial): New function.
(bsd_kvm_add_target): Set to_xfer_partial instead of
to_xfer_memory.
* bfd-target.c (target_bfd_xfer_partial): Change type of readbuf
and writebuf to `gdb_byte *'.
* target.c (deprecated_debug_xfer_memory): Remove prototype.
(deprecated_debug_xfer_memory): Change type of second argument to
`gdb_byte *'.
* remote.c (remote_xfer_memory): Remove prototype.
(remote_xfer_memory): Change type of second argument to `gdb_byte
*'.
(remote_xfer_partial): Change type of readbuf and writebuf to
`gdb_byte *'.
@
text
@d4731 1
a4731 1
remote_insert_hw_breakpoint (CORE_ADDR addr, char *shadow)
d4773 1
a4773 1
remote_remove_hw_breakpoint (CORE_ADDR addr, char *shadow)
@


1.189
log
@* solib.h (CLEAR_SOLIB, SOLIB_ADD)
(SOLIB_CREATE_INFERIOR_HOOK, SOLIB_REMOVE_INFERIOR_HOOK)
(SOLIB_IN_DYNAMIC_LINKER, SOLIB_RESTART)
(DISABLE_UNSETTABLE_BREAK, PC_SOLIB)
(IN_SOLIB_DYNSYM_RESOLVE_CODE): Remove defines and orphaned
comments.
* breakpoint.c: Include "solib.h".
(insert_bp_location) [!DISABLE_UNSETTABLE_BREAK]: Call
solib_address.
(remove_solib_event_breakpoints, create_solib_event_breakpoint)
(disable_breakpoints_in_shlibs)
(disable_breakpoints_in_unloaded_shlib)
(re_enable_breakpoints_in_shlibs): Compile if SOLIB_ADD isn't
defined. If PC_SOLIB isn't defined, call solib_address.
(_initialize_breakpoint): Unconditionally install observer.
* corelow.c: Include "solib.h".
[SOLIB_ADD] (solib_add_stub): Remove prototype.
(core_close) [!CLEAR_SOLIB]: Call clear_solib.
(solib_add_stub) [!SOLIB_ADD] Call solib_add.
(core_open): Unconditionally call solib_add_stub.
* fork-child.c: Include "solib.h".
(fork_inferior) [!SOLIB_CREATE_INFERIOR_HOOK]: Call
solib_create_inferior_hook.
* infcmd.c: Include "solib.h".
(attach_command) [!SOLIB_ADD]: Call shlib_rescan.  Unconditionally
call re_enable_breakpoints_in_shlibs.
* infrun.c: Include "solib.h".
(SOLIB_IN_SYNSYM_RESOLVE_CODE): Don't define if not already
defined.
(stop_on_solib_events, show_stop_on_solib_events): Include
unconditionally.
(follow_exec) [!SOLIB_CREATE_INFERIOR_HOOK]: Call
solib_create_inferior_hook.
(handle_inferior_event) [!SOLIB_ADD]: Call shlib_add.
[!IN_SOLIB_DYNSYM_RESOLVE_CODE]: Call in_solib_dynsym_resolve_code.
(_initialize_infrun): Unconditionally add "stop_on_solib-events"
command.
* remote.c: Include "solib.h".
(remote_open_1): Unconditionally call no_shared_libraries.
[!SOLIB_CREATE_INFERIOR_HOOK] Call solib_create_inferior_hook.
* stack.c: Include "solib.h".
(print_frame) [!PC_SOLIB] Call shlib_for_pc.
* xcoffsolib.c (no_shared_libraries): Remove function.
* Makefile.in (SFILES): Add solib.c.
(ALLDEPFILES): Remove solib.c.
(COMMON_OBS): Add solib.o.
(breakpoint.o, corelow.o, fork-chiled.o, infcmd.o, infrun.o)
(remote.o, stack.o): Update dependencies.
@
text
@a74 5
static int remote_xfer_memory (CORE_ADDR memaddr, char *myaddr,
			       int len, int should_write,
			       struct mem_attrib *attrib,
			       struct target_ops *target);

d3869 1
a3869 1
remote_xfer_memory (CORE_ADDR mem_addr, char *buffer, int mem_len,
d4952 2
a4953 2
		     const char *annex, void *readbuf, const void *writebuf,
		     ULONGEST offset, LONGEST len)
@


1.188
log
@2005-05-01  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (deprecated_extract_return_value)
	(breakpoint_from_pc, deprecated_store_return_value)
	(memory_insert_breakpoint, memory_remove_breakpoint): Change type
	of buffer to a bfd_byte pointer.
	* gdbarch.h, gdbarch.c: Re-generate.
	* mem-break.c (memory_insert_breakpoint)
	(memory_remove_breakpoint, default_memory_insert_breakpoint)
	(default_memory_remove_breakpoint): Update.
	* target.h (memory_insert_breakpoint)
	(memory_remove_breakpoint, default_memory_insert_breakpoint)
	(default_memory_remove_breakpoint): Update declarations.
	(struct target_ops): Update to_insert_breakpoint and
	to_remove_breakpoint.
	* target.c (debug_to_remove_breakpoint)
	(debug_to_insert_breakpoint): Update.
	* remote-m32r-sdi.c (m32r_remove_breakpoint)
	(m32r_insert_breakpoint): Update.
	* m32r-tdep.c (m32r_memory_insert_breakpoint)
	(m32r_memory_remove_breakpoint): Update.
	* remote-e7000.c (e7000_insert_breakpoint)
	(e7000_remove_breakpoint): Update.
	* remote-rdi.c (arm_rdi_insert_breakpoint)
	(arm_rdi_remove_breakpoint): Update.
	* remote-sim.c (gdbsim_insert_breakpoint)
	(gdbsim_remove_breakpoint): Update.
	* exec.c (ignore): Update.
	* rs6000-tdep.c (rs6000_extract_return_value): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint)
	(ia64_memory_remove_breakpoint): Update.
	* remote-rdp.c (remote_rdp_insert_breakpoint)
	(remote_rdp_remove_breakpoint): Update.
@
text
@d45 1
a2261 1
#ifdef SOLIB_CREATE_INFERIOR_HOOK
a2263 1
#endif
d2302 1
a2302 1
#ifdef SOLIB_CREATE_INFERIOR_HOOK
d2312 1
d2314 3
a2318 1
#endif
@


1.187
log
@	* remote.c (init_remote_state): Eliminate use of
	deprecated_register_bytes().
@
text
@d139 1
a139 1
static int remote_insert_breakpoint (CORE_ADDR, char *);
d141 1
a141 1
static int remote_remove_breakpoint (CORE_ADDR, char *);
d4500 1
a4500 1
remote_insert_breakpoint (CORE_ADDR addr, char *contents_cache)
d4560 1
a4560 1
remote_remove_breakpoint (CORE_ADDR addr, char *contents_cache)
@


1.186
log
@2005-04-26  Andrew Cagney  <cagney@@gnu.org>

	* remote.c (remote_open_1): Move "ex"'s declaration to where it is
	used.
	(remote_get_thread_local_address): Use throw_error, include a
	printed string.
	* linux-thread-db.c (thread_db_get_thread_local_address): Ditto.
	* dwarf2loc.c (dwarf_expr_tls_address): Ditto.
	* cli/cli-script.c (script_from_file): Mark up throw_error message.
	* linespec.c (symtab_from_filename, decode_variable): Ditto.
@
text
@d251 1
a251 4
  if (deprecated_register_bytes () != 0)
    rs->sizeof_g_packet = deprecated_register_bytes ();
  else
    rs->sizeof_g_packet = 0;
d266 2
a267 2
      if (deprecated_register_bytes () == 0)
        rs->sizeof_g_packet += register_size (current_gdbarch, regnum);
@


1.185
log
@2005-04-26  Andrew Cagney  <cagney@@gnu.org>

	Rename 'struct exception' to 'struct gdb_exception'.
	* wrapper.c: Update.
	* varobj.c: Update.
	* tui/tui-interp.c: Update.
	* remote.c: Update.
	* mi/mi-main.c: Update.
	* mi/mi-interp.c: Update.
	* linux-thread-db.c: Update.
	* interps.h: Update.
	* interps.c: Update.
	* exceptions.h: Update.
	* exceptions.c: Update.
	* dwarf2loc.c: Update.
	* cli/cli-interp.c: Update.
	* cli/cli-script.c: Update.
	* breakpoint.c: Update.
@
text
@a2181 1
  struct gdb_exception ex;
d2284 11
a2294 8
  ex = catch_exception (uiout, remote_start_remote, NULL, RETURN_MASK_ALL);
  if (ex.reason < 0)
    {
      pop_target ();
      if (async_p)
	wait_forever_enabled_p = 1;
      throw_exception (ex);
    }
d5362 2
a5363 6
	{
	  struct gdb_exception e
	    = { RETURN_ERROR, TLS_GENERIC_ERROR,
		"Remote target doesn't support qGetTLSAddr packet" };
	  throw_exception (e);
	}
d5365 2
a5366 7
	{
	  struct gdb_exception e
	    = { RETURN_ERROR, TLS_GENERIC_ERROR,
		"Remote target failed to process qGetTLSAddr request" };
	  throw_exception (e);

	}
d5369 2
a5370 6
    {
      struct gdb_exception e
	= { RETURN_ERROR, TLS_GENERIC_ERROR,
	    "TLS not supported or disabled on this target" };
      throw_exception (e);
    }
@


1.184
log
@Delete unused variables.
@
text
@d2182 1
a2182 1
  struct exception ex;
d5361 1
a5361 1
	  struct exception e
d5368 1
a5368 1
	  struct exception e
d5377 1
a5377 1
      struct exception e
@


1.183
log
@	* remote.c (remote_get_thread_local_address): Throw a more
	meaningful exception when remote target doesn't have support
	for the qGetTLSAddr packet.
@
text
@a2353 3
  struct remote_state *rs = get_remote_state ();
  char *buf = alloca (rs->remote_packet_size);

a2568 1
  char *p;
a2868 1
	    int i;
a3063 1
	    int i;
a3440 1
  int i;
a3460 1
  int i;
a5092 1
  int i;
a5631 1
  struct cmd_list_element *tmpcmd;
@


1.182
log
@Add remote TLS support.
@
text
@d5347 1
d5360 2
a5361 1
      if (packet_ok (buf, &remote_protocol_qGetTLSAddr) == PACKET_OK)
d5368 7
@


1.181
log
@	* remote.c (add_packet_config_cmd): Delete unused variables.
@
text
@d970 18
d2116 1
d5336 50
d5425 1
d5601 1
d5832 7
@


1.180
log
@Eliminate calls to deprecated_show_value_hack().  This also eliminates the
printing of redundant information.
@
text
@a642 2
  struct cmd_list_element *set_cmd;
  struct cmd_list_element *show_cmd;
a644 2
  char *help_doc;
  char *print;
d646 1
a654 2
  print = xstrprintf ("Current use of remote protocol `%s' (%s) is %%s",
		      name, title);
@


1.179
log
@Fix memset thinkos.
@
text
@a756 1
  deprecated_show_value_hack (file, from_tty, c, value);
a774 1
  deprecated_show_value_hack (file, from_tty, c, value);
a793 1
  deprecated_show_value_hack (file, from_tty, c, value);
a825 1
  deprecated_show_value_hack (file, from_tty, c, value);
a840 1
  deprecated_show_value_hack (file, from_tty, c, value);
a855 1
  deprecated_show_value_hack (file, from_tty, c, value);
a870 1
  deprecated_show_value_hack (file, from_tty, c, value);
a885 1
  deprecated_show_value_hack (file, from_tty, c, value);
a953 1
  deprecated_show_value_hack (file, from_tty, c, value);
a971 1
  deprecated_show_value_hack (file, from_tty, c, value);
a988 1
  deprecated_show_value_hack (file, from_tty, c, value);
@


1.178
log
@* inf-ttrace.c (inf_ttrace_pid_to_str): Use snprintf instead of
sprintf.
* target.c (normal_pid_to_str): Likewise.
* remote.c (remote_pid_to_str): Use snprint instead of sprintf.
Change capitalization of "thread".  Use ptid_get_pid instead of
GETPID.
@
text
@d3504 1
a3504 1
    memset (regs, rs->sizeof_g_packet, 0);
@


1.178.2.1
log
@2005-03-28  Paul Brook  <paul@@codesourcery.com>
	Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdb/Makefile.in: arm-tdep.o depends on $(observer_h).
	* gdb/arm-linux-nat.c (fetch_fpregister, fetch_fpregs,
	store_fpregister, store_fpregs): Rename...
	(fetch_fpa_register, fetch_fpa_regs, store_fpa_register,
	store_fpa_regs): ... to this.
	* gdb/arm-linux-tdep.c (arm_linux_init_abi): Provide ABI specific
	overrides.
	* gdb/arm-tdep.c: Include opserver.h.
	(struct gdbarch_tdep_info): Add.
	(arm_push_dummy_call): Handle doubleword alignment.
	(arm_register_type): Handle iWMMXt and VFP regs.
	(arm_register_byte): Ditto.
	(arm_pseudo_register_read): New function.
	(arm_pseudo_register_write): New function.
	(arm_dwarf_reg_to_regnum): New function.
	(arm_register_sim_regno): Handle iWMMXT regs.
	(arm_register_remote_regno): New function.
	(arm_extract_return_value): Use new macro names.
	(arm_register_name): Handle iWMMXt and VFP registers.
	(arm_sim_available_registers): New function.
	(arm_update_architecture): New function.
	(arm_gdbarch_init): Handle optional register sets.  Register new
	hooks.  Fix misleading error message.
	(_initialize_arm_tdep): Call observer_attach_inferior_created.
	* gdb/arm-tdep.h (ARM_NUM_FP_ARG_REGS, ARM_LAST_FP_ARG_REGNUM,
	FP_REGISTER_SIZE, NUM_FREGS): Rename ...
	(ARM_NUM_FPA_ARG_REGS, ARM_LAST_FPA_ARG_REGNUM, FPA_REGISTER_SIZE,
	NUM_FPA_REGS): ... to this.
	(NUM_IWMMXT_COP0REGS, NUM_IWMMXT_COP1REGS, NUM_IWMMXT_REGS,
	IWMMXT_COP0_REGSIZE, IWMMXT_COP1_REGSIZE, NUM_VFP_XREGS,
	VFP_XREG_SIZE, NUM_VFP_SREGS, VFP_SREG_SIZE, NUM_VFP_PSEUDOS): Define.
	(struct gdbarch_tdep): Add target_has_iwmmxt_regs,
	target_has_vfp_regs, first_iwmmxt_regnum, target_iwmmxt_regnum,
	first_vfp_regnum, first_vfp_pseudo and target_vfp_regnum.
	* gdb/gdbarch.c (struct gdbarch): Add remote_num_g_packet_regs,
	sim_available_registers and register_remote_regno.
	(startup_gdbarch, verify_gdbarch): Ditto.
	(gdbarch_dump): Dump new fields.
	(gdbarch_remote_num_g_packet_regs_p, gdbarch_remote_num_g_packet_regs,
	set_gdbarch_remote_num_g_packet_regs,
	gdbarch_sim_available_registers_p, gdbarch_sim_available_registers,
	set_gdbarch_sim_available_registers, gdbarch_register_remote_regno_p,
	gdbarch_register_remote_regno, set_gdbarch_register_remote_regno):
	New functions.
	* gdb/gdbarch.h: Add prototypes.
	* gdb/gdbarch.sh: Add new fields.
	(deprecated_current_gdbarch_select_hack): Call flush_cached_frames.
	* gdb/remote-sim.h (gdbsim_create_inferior): Call
	observer_notify_inferior_created.
	(gdbsim_xfer_partial): New function.
	(init_gdbsim_ops): Use it.
	* gdb/remote.c (struct remote_state): Add num_g_regs.
	(init_remote_state): Only consider hard regs.  Allow target to provide
	register mapping.
	(packet_reg_from_regnum): Don't check pseudo regs.
	(packet_reg_from_pnum): Ditto.
	(remote_protocol_qPart_availableRegisters): Add.
	(set_remote_protocol_qPart_availableRegisters_packet_cmd,
	show_remote_protocol_qPart_availableRegisters_packet_cmd): New
	functions.
	(fetch_register_using_p, store_register_using_P): Handle arbitrary
	register mappings.
	(fetch_registers_using_g): New function.
	(remote_fetch_registers): Use it.
	(store_registers_using_G): New function.
	(remote_store_registers): Use it.
	(remote_xfer_partial): Handle TARGET_OBJECT_AVAILABLE_REGISTERS.
	(show_remote_cmd): Display availableRegisters.
	(_initialize_remote): Register qPart_availableRegisters.
	* gdb/target.h (enum target_object): Add
	TARGET_OBJECT_AVAILABLE_REGISTERS.
	* gdb/gdbserver/configure.srv (arm*-*-linux*): set
	srv_linux_regsets=yes.
	* gdb/gdbserver/linux-arm-low.c (PTRACE_GETWMMXREGS,
	PTRACE_SETWMMXREGS): Define.
	(arm_fill_gregset, arm_store_gregset, arm_fill_wmmxregset,
	arm_store_wmmxregset, arm_available_registers): New functions.
	(target_regsets): Add.
	(the_low_target): Use arm_available_registers.
	* gdb/gdbserver/linux-low.c (linux_available_registers): New function.
	(linux_target_op): Use it.
	* gdb/gdbserver/linux-low.h (gdbserver/linux-low.h): Add
	available_registers.
	(use_regsets_p): Declare.
	* gdb/gdbserver/regcache.c (g_register_bytes): Add.
	(regcache_invalidate, registers_to_string, registers_from_string):
	Use it.
	(set_register_cache): Set g_register_bytes.
	(supply_register_as_string): New function.
	* gdb/gdbserver/regcache.h (supply_register_as_string): Add prototype.
	* gdb/gdbserver/server.c (handle_query): Handle
	qPart:availableRegisters.
	(handle_p_packet, handle_P_packet): New functions.
	(main): Handle 'p' and 'P' packets.
	* gdb/gdbserver/target.h (struct target_ops): Add available_registers.
	* gdb/regformats/reg-arm.dat: Add last_g_reg and iWMMXT regs.
	* gdb/regformats/regdat.sh: Handle last_g_reg.
	* gdb/regformats/regdef.h (set_register_cache): Update prototype.
@
text
@a216 1
  long num_g_regs;
d219 1
a219 1
     (making an array NUM_REGS in size).  */
a249 1
  int num_g_regs;
d251 2
a252 2
  if (gdbarch_remote_num_g_packet_regs_p (gdbarch))
    num_g_regs = gdbarch_remote_num_g_packet_regs (gdbarch);
d254 1
a254 3
    num_g_regs = NUM_REGS;

  rs->sizeof_g_packet = 0;
d257 3
a259 2
  rs->regs = GDBARCH_OBSTACK_CALLOC (gdbarch, NUM_REGS, struct packet_reg);
  for (regnum = 0; regnum < NUM_REGS; regnum++)
d262 1
a262 6

      if (gdbarch_register_remote_regno_p (gdbarch))
	r->pnum = gdbarch_register_remote_regno (gdbarch, regnum);
      else
	r->pnum = regnum;

d265 1
a265 1
      r->in_g_packet = (regnum < num_g_regs);
d269 2
a270 1
      rs->sizeof_g_packet += register_size (current_gdbarch, regnum);
a272 4
  if (!gdbarch_remote_num_g_packet_regs_p (gdbarch)
      && deprecated_register_bytes () != 0)
    gdb_assert (rs->sizeof_g_packet == deprecated_register_bytes ());

d300 1
a300 1
  if (regnum < 0 && regnum >= NUM_REGS)
d314 1
a314 1
  for (i = 0; i < NUM_REGS; i++)
a984 20
/* FIXME: Kill these duplicated functions.  */
/* Should we try the 'qPart:availableRegisters' request? */
static struct packet_config remote_protocol_qPart_availableRegisters;

static void
set_remote_protocol_qPart_availableRegisters_packet_cmd (char *args, int from_tty,
					   struct cmd_list_element *c)
{
  update_packet_config (&remote_protocol_qPart_availableRegisters);
}

static void
show_remote_protocol_qPart_availableRegisters_packet_cmd (struct ui_file *file, int from_tty,
					    struct cmd_list_element *c,
					    const char * value)
{
  deprecated_show_value_hack (file, from_tty, c, value);
  show_packet_config_cmd (&remote_protocol_qPart_availableRegisters);
}

a2113 1
  update_packet_config (&remote_protocol_qPart_availableRegisters);
d3221 6
a3226 1
/* Fetch a single register using a 'p' packet.  */
d3229 1
a3229 1
fetch_register_using_p (struct packet_reg *reg)
a3235 3
  if (remote_protocol_p.support == PACKET_DISABLE)
    return 0;

d3238 1
a3238 1
  p += hexnumstr (p, reg->pnum);
d3242 4
a3245 15
  if (buf[0] == 0)
    {
      if (remote_protocol_p.support == PACKET_ENABLE)
	error ("Protocol error: p packet enabled but not recognized by stub");
      else
	{
	  /* The stub does not support the 'P' packet.  Use 'G'
	     instead, and don't try using 'P' in the future (it
	     will just waste our time).  */
	  remote_protocol_p.support = PACKET_DISABLE;
	  return 0;
  	}
      }
  
  remote_protocol_p.support = PACKET_ENABLE;
d3247 1
d3250 2
a3251 2
      regcache_raw_supply (current_regcache, reg->regnum, NULL);
      set_register_cached (reg->regnum, -1);
d3255 1
d3261 5
a3265 1
	error("fetch_register_using_p: early buf termination");
d3269 1
a3269 1
  regcache_raw_supply (current_regcache, reg->regnum, regp);
a3272 6
/* Number of bytes of registers this stub implements.  */

static int register_bytes_found;

/* Fetch the registers included in the target's 'g' packet.  */

d3274 1
a3274 1
fetch_registers_using_g (void)
d3284 35
d3379 1
a3379 1
    for (i = 0; i < NUM_REGS; i++)
a3405 32
static void
remote_fetch_registers (int regnum)
{
  struct remote_state *rs = get_remote_state ();
  int i;

  set_thread (PIDGET (inferior_ptid), 1);

  if (regnum >= 0)
    {
      struct packet_reg *reg = packet_reg_from_regnum (rs, regnum);
      gdb_assert (reg != NULL);

      if (fetch_register_using_p (reg))
	return;

      if (!reg->in_g_packet)
	error ("Protocol error: register %ld not supported by stub", reg->regnum);

      fetch_registers_using_g ();
      return;
    }

  fetch_registers_using_g ();

  for (i = 0; i < NUM_REGS; i++)
    if (!rs->regs[i].in_g_packet)
      if (!fetch_register_using_p (&rs->regs[i]))
	error ("Protocol error: register %ld not supported by stub",
	       rs->regs[i].regnum);
}

d3436 1
a3436 1
store_register_using_P (struct packet_reg *reg)
d3439 1
a3445 3
  if (remote_protocol_P.support == PACKET_DISABLE)
    return 0;

d3452 1
a3452 15
  if (buf[0] == 0)
    {
      if (remote_protocol_P.support == PACKET_ENABLE)
	error ("Protocol error: P packet enabled but not recognized by stub");
      else
	{
	  /* The stub does not support the 'P' packet.  Use 'G'
	     instead, and don't try using 'P' in the future (it
	     will just waste our time).  */
	  remote_protocol_P.support = PACKET_DISABLE;
	  return 0;
	}
    }
  
  return 1;
d3455 1
d3459 2
a3460 2
void
store_registers_using_G (void)
d3468 31
d3505 1
a3505 1
    for (i = 0; i < NUM_REGS; i++)
a4465 35

/* Store register REGNUM, or all registers if REGNUM == -1, from the contents
   of the register cache buffer.  FIXME: ignores errors.  */

static void
remote_store_registers (int regnum)
{
  struct remote_state *rs = get_remote_state ();
  int i;

  set_thread (PIDGET (inferior_ptid), 1);

  if (regnum >= 0)
    {
      struct packet_reg *reg = packet_reg_from_regnum (rs, regnum);
      gdb_assert (reg != NULL);

      if (store_register_using_P (reg))
	return;

      if (!reg->in_g_packet)
	error ("Protocol error: register %ld not supported by stub", reg->regnum);

      store_registers_using_G ();
      return;
    }

  store_registers_using_G ();

  for (i = 0; i < NUM_REGS; i++)
    if (!rs->regs[i].in_g_packet)
      if (!store_register_using_P (&rs->regs[i]))
	error ("Protocol error: register %ld not supported by stub",
	       rs->regs[i].regnum);
}
a5043 38
      /* FIXME:
	 - Currently hex encoded.  Should this be just a string?
	 - One way or another remove the copy/paste.
      */
    case TARGET_OBJECT_AVAILABLE_REGISTERS:
      if (remote_protocol_qPart_availableRegisters.support != PACKET_DISABLE)
	{
	  unsigned int total = 0;
	  while (len > 0)
	    {
	      LONGEST n = min ((rs->remote_packet_size - 2) / 2, len);
	      snprintf (buf2, rs->remote_packet_size,
			"qPart:availableRegisters:read::%s,%s",
			phex_nz (offset, sizeof offset),
			phex_nz (n, sizeof n));
	      i = putpkt (buf2);
	      if (i < 0)
		return total > 0 ? total : i;
	      buf2[0] = '\0';
	      getpkt (buf2, rs->remote_packet_size, 0);
	      if (packet_ok (buf2, &remote_protocol_qPart_availableRegisters) != PACKET_OK)
		return total > 0 ? total : -1;
	      if (buf2[0] == 'O' && buf2[1] == 'K' && buf2[2] == '\0')
		break;		/* Got EOF indicator.  */
	      /* Got some data.  */
	      i = hex2bin (buf2, readbuf, len);
	      if (i > 0)
		{
		  readbuf = (void *) ((char *) readbuf + i);
		  offset += i;
		  len -= i;
		  total += i;
		}
	    }
	  return total;
	}
      return -1;

a5546 1
  show_remote_protocol_qPart_availableRegisters_packet_cmd (gdb_stdout, from_tty, NULL, NULL);
a5776 7
  add_packet_config_cmd (&remote_protocol_qPart_availableRegisters,
			 "qPart_availableRegisters", "available-registers",
			 set_remote_protocol_qPart_availableRegisters_packet_cmd,
			 show_remote_protocol_qPart_availableRegisters_packet_cmd,
			 &remote_set_cmdlist, &remote_show_cmdlist,
			 0);

@


1.177
log
@	* remote.c (MIN_REMOTE_PACKET_SIZE): Set to 20.
	(remote_fetch_registers): Allow uppercase hex when resyncing.
	(remote_write_bytes): Only call get_memory_write_packet_size once.
	Robustify packet size calculation for very small packets. Check
	that at least one byte will be written.
@
text
@d5325 2
a5326 1
  static char buf[30];
d5328 2
a5329 1
  sprintf (buf, "Thread %d", PIDGET (ptid));
@


1.176
log
@	* Makefile.in (remote.o): Update dependencies.
	* remote.c: Include "observer.h".
@
text
@d416 1
a416 1
  /* NOTE: 16 is just chosen at random.  */
d418 1
a418 1
#define MIN_REMOTE_PACKET_SIZE 16
d3335 1
d3663 2
d3666 2
a3667 2
     possible packet.  Include space for an extra trailing NULL.  */
  sizeof_buf = get_memory_write_packet_size () + 1;
d3671 4
a3674 4
     packet header and footer overhead: "$M<memaddr>,<len>:...#nn".  */
  payload_size = (get_memory_write_packet_size () - (strlen ("$M,:#NN")
						     + hexnumlen (memaddr)
						     + hexnumlen (len)));
d3687 2
d3694 2
d3703 3
@


1.175
log
@	* remote.c (remote_open_1): Call observer_notify_inferior_created.
@
text
@d44 1
@


1.174
log
@2005-02-21  Andrew Cagney  <cagney@@gnu.org>

	Add more uses of add_setshow_string_cmd, add_setshow_integer_cmd,
	and add_setshow_string_noescape_cmd.
	* cli/cli-setshow.c (deprecated_show_value_hack): Do not print a
	NULL command's value.
	* kod.c, language.c, ocd.c, remote-e7000.c, remote-mips.c: Update.
	* remote-sds.c, remote.c, symfile.c, top.c: Update.
@
text
@d4 1
a4 1
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d2314 2
@


1.173
log
@2005-02-18  Andrew Cagney  <cagney@@gnu.org>

	Use add_setshow_boolean_command through out.  Delete #ifdef 0'ed
	code adding set/show boolean commands.
	* cp-valprint.c, dcache.c, exec.c, gdbtypes.c, infrun.c: Update.
	* monitor.c, p-valprint.c, pa64solib.c, printcmd.c: Update.
	* proc-api.c, remote-mips.c, remote.c, solib.c: Update.
	* somsolib.c, symfile.c, top.c, utils.c, valops.c: Update.
	* valprint.c, win32-nat.c, wince.c, xcoffsolib.c: Update.
	* cli/cli-cmds.c: Update.
@
text
@d5677 7
a5683 7
  deprecated_add_show_from_set
    (add_set_cmd ("remoteaddresssize", class_obscure,
		  var_integer, (char *) &remote_address_size,
		  "Set the maximum size of the address (in bits) \
in a memory packet.\n",
		  &setlist),
     &showlist);
@


1.172
log
@2005-02-17  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Delete
	fprint_setshow parameter.
	* command.h (fprint_setshow_ftype): Delete.
	(add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Delete
	fprint_setshow parameter.
	* aix-thread.c, alpha-tdep.c, arm-tdep.c, breakpoint.c: Update.
	* complaints.c, cris-tdep.c, dwarf2read.c, frame.c: Update.
	* hppa-tdep.c, infcall.c, m32r-rom.c, maint.c: Update.
	* mips-tdep.c, nto-tdep.c, observer.c, remote-rdi.c: Update
	* remote.c, target.c, cli/cli-logging.c: Update.
@
text
@a5690 9
#if 0
  /* XXXX - should ``set remotebinarydownload'' be retained for
     compatibility.  */
  deprecated_add_show_from_set
    (add_set_cmd ("remotebinarydownload", no_class,
		  var_boolean, (char *) &remote_binary_download,
		  "Set binary downloads.\n", &setlist),
     &showlist);
#endif
@


1.171
log
@2005-02-16  Andrew Cagney  <cagney@@gnu.org>

	Merge setshow print and show parameters.
	* command.h (show_value_ftype): Define.
	(deprecated_show_value_hack): Declare.
	(add_setshow_enum_cmd, add_setshow_auto_boolean_cmd)
	(add_setshow_boolean_cmd, add_setshow_filename_cmd)
	(add_setshow_string_cmd, add_setshow_uinteger_cmd)
	(add_setshow_zinteger_cmd): Change type of show_func to
	show_value_ftype.
	* cli/cli-decode.h (struct cmd_list_element): Replace
	fprint_setshow with show_value_func.
	* cli/cli-decode.c (add_setshow_cmd_full): Update show_func
	parameter.  Set show_value_func.  Do not set cmd_sfunc.
	(add_setshow_enum_cmd, add_setshow_auto_boolean_cmd)
	(add_setshow_boolean_cmd, add_setshow_filename_cmd)
	(add_setshow_string_cmd, add_setshow_uinteger_cmd)
	(add_setshow_zinteger_cmd): Update.
	* complaints.c (complaints_show_value): Replace
	fprint_setshow_complaints.
	(_initialize_complaints): Update.
	* mips-tdep.c (show_mask_address): Update.
	* arm-tdep.c (show_fp_model): Update.
	* cli/cli-setshow.c (do_setshow_command): Call show_value_func
	instead of fprint_setshow.  Use deprecated_show_value_hack.
	(deprecated_show_value_hack): New function.
	* remote.c (add_packet_config_cmd, show_remote_cmd):
	(show_remote_protocol_P_packet_cmd)
	(show_remote_protocol_P_packet_cmd)
	(show_remote_protocol_Z_access_wp_packet_cmd)
	(show_remote_protocol_Z_hardware_bp_packet_cmd)
	(show_remote_protocol_Z_packet_cmd)
	(show_remote_protocol_Z_read_wp_packet_cmd)
	(show_remote_protocol_Z_software_bp_packet_cmd)
	(show_remote_protocol_Z_write_wp_packet_cmd)
	(show_remote_protocol_binary_download_cmd)
	(show_remote_protocol_p_packet_cmd)
	(show_remote_protocol_qPart_auxv_packet_cmd)
	(show_remote_protocol_qSymbol_packet_cmd)
	(show_remote_protocol_vcont_packet_cmd): Update.
@
text
@d662 1
a662 2
				&config->detect, set_doc, show_doc,
				"", NULL /* FIXME: i18n: Print message is? */,
d5626 1
a5626 2
			   NULL, /* FIXME: i18n: Whether to send break if interrupted is %s.  */
			   NULL, NULL,
d5667 1
a5667 2
			    NULL, /* FIXME: i18n: The maximum number of target hardware watchpoints is %s.  */
			    NULL, NULL,
d5674 1
a5674 2
			    NULL, /* FIXME: i18n: The maximum number of target hardware breakpoints is %s.  */
			    NULL, NULL,
a5777 1
				NULL, /* FIXME: i18n: Use of remote protocol `Z' packets is %s.  */
d5779 1
a5779 1
				show_remote_protocol_Z_packet_cmd,
@


1.170
log
@2005-02-15  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_com, add_info and add_prefix_cmd.
	* breakpoint.c, cp-support.c, dcache.c, dwarf2read.c: Update.
	* exec.c, f-valprint.c, frame.c, gcore.c, gnu-nat.c: Update.
	* go32-nat.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* kod.c, language.c, linux-nat.c, m32r-rom.c, macrocmd.c: Update.
	* maint.c, memattr.c, mips-tdep.c, nto-procfs.c, objc-lang.c: Update.
	* ocd.c, pa64solib.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote-e7000.c, remote-m32r-sdi.c, remote-mips.c: Update.
	* remote-sds.c, remote-sim.c, remote-st.c, remote-utils.c: Update.
	* remote.c, rs6000-tdep.c, ser-go32.c, serial.c: Update.
	* sh-tdep.c, solib.c, somsolib.c, source.c, stack.c: Update.
	* symfile.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, typeprint.c, utils.c, valprint.c: Update.
	* win32-nat.c, xcoffsolib.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-layout.c, tui/tui-regs.c: Update.
	* tui/tui-stack.c, tui/tui-win.c: Update.
@
text
@d637 1
a637 1
		       cmd_sfunc_ftype *show_func,
d753 3
a755 2
show_remote_protocol_vcont_packet_cmd (char *args, int from_tty,
				       struct cmd_list_element *c)
d757 1
d772 3
a774 2
show_remote_protocol_qSymbol_packet_cmd (char *args, int from_tty,
					 struct cmd_list_element *c)
d776 1
d792 3
a794 2
show_remote_protocol_P_packet_cmd (char *args, int from_tty,
				   struct cmd_list_element *c)
d796 1
d825 3
a827 2
show_remote_protocol_Z_software_bp_packet_cmd (char *args, int from_tty,
					       struct cmd_list_element *c)
d829 1
d841 3
a843 2
show_remote_protocol_Z_hardware_bp_packet_cmd (char *args, int from_tty,
					       struct cmd_list_element *c)
d845 1
d857 3
a859 2
show_remote_protocol_Z_write_wp_packet_cmd (char *args, int from_tty,
					    struct cmd_list_element *c)
d861 1
d873 3
a875 2
show_remote_protocol_Z_read_wp_packet_cmd (char *args, int from_tty,
					   struct cmd_list_element *c)
d877 1
d889 3
a891 2
show_remote_protocol_Z_access_wp_packet_cmd (char *args, int from_tty,
					     struct cmd_list_element *c)
d893 1
d915 3
a917 2
show_remote_protocol_Z_packet_cmd (char *args, int from_tty,
				   struct cmd_list_element *c)
d958 3
a960 2
show_remote_protocol_binary_download_cmd (char *args, int from_tty,
					  struct cmd_list_element *c)
d962 1
d977 3
a979 2
show_remote_protocol_qPart_auxv_packet_cmd (char *args, int from_tty,
					    struct cmd_list_element *c)
d981 1
d995 3
a997 2
show_remote_protocol_p_packet_cmd (char *args, int from_tty,
				   struct cmd_list_element *c)
d999 1
d5526 7
a5532 7
  show_remote_protocol_Z_packet_cmd (args, from_tty, NULL);
  show_remote_protocol_P_packet_cmd (args, from_tty, NULL);
  show_remote_protocol_p_packet_cmd (args, from_tty, NULL);
  show_remote_protocol_qSymbol_packet_cmd (args, from_tty, NULL);
  show_remote_protocol_vcont_packet_cmd (args, from_tty, NULL);
  show_remote_protocol_binary_download_cmd (args, from_tty, NULL);
  show_remote_protocol_qPart_auxv_packet_cmd (args, from_tty, NULL);
@


1.169
log
@2005-02-14  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_cmd.
	* arch-utils.c, avr-tdep.c, breakpoint.c, corefile.c: Update.
	* cp-abi.c, cp-namespace.c, cp-support.c, dummy-frame.c: Update.
	* exec.c, gnu-nat.c, go32-nat.c, hppa-tdep.c, infcmd.c: Update.
	* infrun.c, interps.c, macrocmd.c, maint.c, memattr.c: Update.
	* mips-tdep.c, ocd.c, osabi.c, printcmd.c, regcache.c: Update.
	* reggroups.c, remote-fileio.c, remote-rdi.c, remote.c: Update.
	* sol-thread.c, source.c, stack.c, symfile-mem.c: Update.
	* symfile.c, thread.c, tracepoint.c, valprint.c, value.c: Update.
	* win32-nat.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-regs.c: Update.
@
text
@d5270 2
a5271 2
  add_com ("tlist", class_obscure, threadlist_test_cmd,
     "Fetch and print the remote list of thread identifiers, one pkt only");
d5273 1
a5273 1
	   "Fetch and display info about one thread");
d5275 1
a5275 1
	   "Test setting to a different thread");
d5277 1
a5277 1
	   "Iterate through updating all remote thread info");
d5279 1
a5279 1
	   " Remote thread alive test ");
d5573 1
a5573 1
  add_prefix_cmd ("remote", class_maintenance, set_remote_cmd, "\
d5576 1
a5576 1
the packets being used",
d5579 1
a5579 1
  add_prefix_cmd ("remote", class_maintenance, show_remote_cmd, "\
d5582 1
a5582 1
the packets being used",
@


1.168
log
@2005-02-14  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_setshow functions, replace "PRINT:" comment prefix
	with "FIXME: i18n:".
	* aix-thread.c, alpha-tdep.c, arm-tdep.c, breakpoint.c: Update.
	* cris-tdep.c, dwarf2read.c, frame.c, hppa-tdep.c: Update.
	* infcall.c, m32r-rom.c, maint.c, mips-tdep.c: Update.
	* nto-tdep.c, observer.c, remote-rdi.c, remote.c: Update.
	* target.c, cli/cli-logging.c: Update.
@
text
@d5586 3
a5588 3
  add_cmd ("compare-sections", class_obscure, compare_sections_command,
	   "Compare section data on target to the exec file.\n\
Argument is a single section name (default: all loaded sections).",
d5591 2
a5592 2
  add_cmd ("packet", class_maintenance, packet_command,
	   "Send an arbitrary packet to a remote target.\n\
d5597 1
a5597 1
terminating `#' character and checksum.",
d5610 2
a5611 2
  add_cmd ("remotewritesize", no_class, set_memory_write_packet_size,
	   "Set the maximum number of bytes per memory write packet (deprecated).\n",
d5613 2
a5614 2
  add_cmd ("remotewritesize", no_class, show_memory_write_packet_size,
	   "Show the maximum number of bytes per memory write packet (deprecated).\n",
d5617 6
a5622 6
	   set_memory_write_packet_size,
	   "Set the maximum number of bytes per memory-write packet.\n"
	   "Specify the number of bytes in a packet or 0 (zero) for the\n"
	   "default packet size.  The actual limit is further reduced\n"
	   "dependent on the target.  Specify ``fixed'' to disable the\n"
	   "further restriction and ``limit'' to enable that restriction\n",
d5625 6
a5630 6
	   set_memory_read_packet_size,
	   "Set the maximum number of bytes per memory-read packet.\n"
	   "Specify the number of bytes in a packet or 0 (zero) for the\n"
	   "default packet size.  The actual limit is further reduced\n"
	   "dependent on the target.  Specify ``fixed'' to disable the\n"
	   "further restriction and ``limit'' to enable that restriction\n",
d5634 1
a5634 1
	   "Show the maximum number of bytes per memory-write packet.\n",
d5638 1
a5638 1
	   "Show the maximum number of bytes per memory-read packet.\n",
@


1.167
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up some of printf_filtered and printf_unfiltered.
	* ada-lang.c, annotate.c, arch-utils.c, breakpoint.c: Update.
	* corelow.c, cp-namespace.c, cp-support.c, dcache.c: Update.
	* demangle.c, dsrec.c, dwarf2read.c, dwarfread.c: Update.
	* event-loop.c, event-top.c, exec.c, f-valprint.c: Update.
	* gdbtypes.c, inf-loop.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcmd.c, inflow.c, infrun.c, inftarg.c, language.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, maint.c: Update.
	* mdebugread.c, memattr.c, monitor.c, objc-lang.c: Update.
	* ocd.c, osabi.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote.c, solib-som.c, solib.c, somsolib.c, source.c: Update.
	* stack.c, symfile.c, symmisc.c, target.c, thread.c: Update.
	* top.c, utils.c, valprint.c, value.c, cli/cli-cmds.c: Update.
	* cli/cli-dump.c, cli/cli-logging.c, tui/tui-hooks.c: Update.
	* tui/tui-regs.c, tui/tui-win.c: Update.
@
text
@d663 1
a663 1
				"", NULL /*print*/,
d5600 5
a5604 5
  add_setshow_boolean_cmd ("remotebreak", no_class, &remote_break, "\
Set whether to send break if interrupted.", "\
Show whether to send break if interrupted.", "\
If set, a break, instead of a cntrl-c, is sent to the remote target.",
			   NULL, /* PRINT: Whether to send break if interrupted is %s.  */
d5642 5
a5646 5
			    &remote_hw_watchpoint_limit, "\
Set the maximum number of target hardware watchpoints.", "\
Show the maximum number of target hardware watchpoints.", "\
Specify a negative limit for unlimited.",
			    NULL, /* PRINT: The maximum number of target hardware watchpoints is %s.  */
d5650 5
a5654 5
			    &remote_hw_breakpoint_limit, "\
Set the maximum number of target hardware breakpoints.", "\
Show the maximum number of target hardware breakpoints.", "\
Specify a negative limit for unlimited.",
			    NULL, /* PRINT: The maximum number of target hardware breakpoints is %s.  */
d5754 3
a5756 3
				&remote_Z_packet_detect, "\
Set use of remote protocol `Z' packets", "\
Show use of remote protocol `Z' packets ", "\
d5758 2
a5759 2
packets.",
				NULL, /* PRINT: Use of remote protocol `Z' packets is %s.  */
@


1.166
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d493 1
a493 1
  printf_filtered ("The %s is %ld. ", config->name, config->size);
d495 1
a495 1
    printf_filtered ("Packets are fixed at %ld bytes.\n",
d498 1
a498 1
    printf_filtered ("Packets are limited to %ld bytes.\n",
d621 1
a621 1
      printf_filtered ("Support for remote protocol `%s' (%s) packet is auto-detected, currently %s.\n",
d626 1
a626 1
      printf_filtered ("Support for remote protocol `%s' (%s) packet is currently %s.\n",
d4164 1
a4164 1
	    printf_filtered ("Repeat count %d too large for buffer: ", 
d4290 1
a4290 1
  printf_unfiltered ("Ignoring packet error, continuing...\n");
d4800 1
a4800 1
  printf_filtered ("Switching to remote protocol\n");
d4921 1
a4921 1
    printf_filtered ("No loaded section named '%s'.\n", args);
d5167 1
a5167 1
  printf_filtered ("Remote threadset test\n");
@


1.165
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d480 2
a481 2
      if (! query ("The target may not be able to correctly handle a %s\n"
		   "of %ld bytes. Change the packet size? ",
d696 1
a696 1
			  "packet_ok: attempt to use a disabled packet");
d1850 1
a1850 1
		    "remote_threads_extra_info");
d3265 2
a3266 2
			"Attempt to fetch a non G-packet register when this "
			"remote.c does not support the p-packet.");
d3667 1
a3667 1
		      "remote_write_bytes: bad internal state");
d3669 1
a3669 1
      internal_error (__FILE__, __LINE__, "bad switch");
d3734 1
a3734 1
		      "remote_write_bytes: bad internal state");
d3736 1
a3736 1
      internal_error (__FILE__, __LINE__, "bad switch");
d3896 1
a3896 1
      perror_with_name ("Remote communication error");
d3985 1
a3985 1
	perror_with_name ("putpkt: write failed");
d4579 1
a4579 1
		      "hw_bp_to_z: bad watchpoint type %d", type);
d4614 1
a4614 1
		  "remote_insert_watchpoint: reached end of function");
d4648 1
a4648 1
		  "remote_remove_watchpoint: reached end of function");
d4742 1
a4742 1
		  "remote_insert_hw_breakpoint: reached end of function");
d4784 1
a4784 1
		  "remote_remove_hw_breakpoint: reached end of function");
d5401 1
a5401 1
		    "Calling remote_async when async is masked");
@


1.164
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_enum_cmd, add_setshow_cmd_full)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Replace
	print string parameter with fprint_setshow function.
	* command.h (fprint_setshow_ftype): Define.  Update declarations.
	* cli/cli-setshow.c (do_setshow_command): When fprint_setshow is
	available, use that.
	* cli/cli-decode.h (struct cmd_list_element): Add field
	fprint_setshow.
	* complaints.c (fprint_setshow_complaints): New function.
	(_initialize_complaints): Pass to add_setshow_zinteger_cmd.
	* hppa-tdep.c (_initialize_hppa_tdep): Replace "print" parameter
	with NULL.
	* mips-tdep.c (_initialize_mips_tdep): Ditto.
	* m32r-rom.c (_initialize_m32r_rom): Ditto.
	* cris-tdep.c (_initialize_cris_tdep): Ditto.
	* arm-tdep.c (_initialize_arm_tdep): Ditto.
	* remote-rdi.c (_initialize_remote_rdi): Ditto.
	* alpha-tdep.c (_initialize_alpha_tdep): Ditto.
	* dwarf2read.c (_initialize_dwarf2_read): Ditto.
	* frame.c (_initialize_frame): Ditto.
	* target.c (initialize_targets): Ditto.
	* maint.c (_initialize_maint_cmds): Ditto.
	* observer.c (_initialize_observer): Ditto.
	* infcall.c (_initialize_infcall): Ditto.
	* breakpoint.c (_initialize_breakpoint): Ditto.
	* cli/cli-logging.c (_initialize_cli_logging): Ditto.
	* remote.c (add_packet_config_cmd, _initialize_remote): Ditto.
@
text
@d455 1
a455 1
    error ("Argument required (integer, `fixed' or `limited').");
d467 1
a467 1
	error ("Invalid %s (bad syntax).", config->name);
d474 1
a474 1
	error ("Invalid %s (too large).", config->name);
d483 1
a483 1
	error ("Packet size not changed.");
d721 1
a721 1
	    error ("Protocol error: %s (%s) conflicting enabled responses.",
d725 1
a725 1
	    error ("Enabled packet %s (%s) not recognized by stub",
d1489 1
a1489 1
    warning ("Incomplete response to threadinfo request\n");
d1492 1
a1492 1
      warning ("ERROR RMT Thread info mismatch\n");
d1506 1
a1506 1
	  warning ("ERROR RMT: threadinfo tag mismatch\n");
d1514 1
a1514 1
	      warning ("ERROR RMT: length of threadid is not 16\n");
d1529 1
a1529 1
	      warning ("ERROR RMT: 'exists' length too long\n");
d1553 1
a1553 1
      warning ("ERROR RMT: unknown thread info tag\n");
d1653 1
a1653 1
      warning ("HMM: threadlist did not echo arg thread, dropping it\n");
d1660 1
a1660 1
	  warning ("RMT ERROR : failed to get remote thread list\n");
d1668 1
a1668 1
      warning ("RMT ERROR: threadlist response longer than requested\n");
d1705 1
a1705 1
	  warning ("Remote fetch threadlist -infinite loop-\n");
d1789 1
a1789 1
    error ("Command can only be used when connected to the remote target.");
d1946 1
a1946 1
      warning ("Remote failure reply: %s", buf);
d1987 1
a1987 1
    error ("Malformed response to offset query, %s", buf);
d2143 3
a2145 3
      warning ("The remote protocol may be unreliable over UDP.");
      warning ("Some events may be lost, rendering further debugging "
	       "impossible.");
d2159 1
a2159 1
    error ("To open a remote debug connection, you need to specify what\n"
d2161 1
a2161 1
	   "(e.g. /dev/ttyS0, /dev/ttya, COM1, etc.).");
d2306 1
a2306 1
    error ("Argument given to \"detach\" when remotely debugging.");
d2330 1
a2330 1
    error ("Argument given to \"detach\" when remotely debugging.");
d2353 1
a2353 1
    error ("Reply contains invalid hex digit %d", a);
d2838 1
a2838 1
	  warning ("Remote failure reply: %s", buf);
d2883 2
a2884 2
		      warning ("Malformed packet(a) (missing colon): %s\n\
Packet: '%s'\n",
d2914 2
a2915 2
		      error ("Malformed packet(b) (missing colon): %s\n\
Packet: '%s'\n",
d2919 2
a2920 2
		      error ("Remote sent bad register number %s: %s\n\
Packet: '%s'\n",
d2929 1
a2929 1
		      warning ("Remote reply is too short: %s", buf);
d2935 1
a2935 1
		  error ("Remote register badly formatted: %s\nhere: %s", 
d2986 1
a2986 1
	  warning ("Invalid remote reply: %s", buf);
d3034 1
a3034 1
	  warning ("Remote failure reply: %s", buf);
d3079 2
a3080 2
		      error ("Malformed packet(a) (missing colon): %s\n\
Packet: '%s'\n",
d3110 2
a3111 2
		      error ("Malformed packet(b) (missing colon): %s\n\
Packet: '%s'\n",
d3115 2
a3116 2
		      error ("Remote sent bad register number %ld: %s\n\
Packet: '%s'\n",
d3125 1
a3125 1
		      warning ("Remote reply is too short: %s", buf);
d3130 1
a3130 1
		  error ("Remote register badly formatted: %s\nhere: %s",
d3184 1
a3184 1
	  warning ("Invalid remote reply: %s", buf);
d3237 1
a3237 1
          error ("fetch_register_using_p: early buf termination");
d3276 1
a3276 1
	    error ("Protocol error: p packet not recognized by stub");
d3330 1
a3330 1
	  warning ("Remote reply is of odd length: %s", buf);
d3347 1
a3347 1
	warning ("Remote reply is too short: %s", buf);
d3454 1
a3454 1
	    error ("Protocol error: P packet not recognized by stub");
d3893 1
a3893 1
      error ("Remote connection closed");
d3915 1
a3915 1
    error ("Remote failure reply: %s", buf);
d4257 1
a4257 1
		  error ("Watchdog has expired.  Target detached.\n");
d4592 1
a4592 1
    error ("Can't set hardware watchpoints without the '%s' (%s) packet\n",
d4627 1
a4627 1
    error ("Can't clear hardware watchpoints without the '%s' (%s) packet\n",
d4718 1
a4718 1
    error ("Can't set hardware breakpoint without the '%s' (%s) packet\n",
d4760 1
a4760 1
    error ("Can't clear hardware breakpoint without the '%s' (%s) packet\n",
d4864 1
a4864 1
    error ("command cannot be used without an exec file");
d4867 1
a4867 1
    error ("command can only be used with remote target");
d4897 1
a4897 1
	error ("target memory fault, section %s, range 0x%s -- 0x%s",
d4900 1
a4900 1
	error ("remote target does not support this operation");
d4918 2
a4919 2
    warning ("One or more sections of the remote executable does not match\n\
the loaded file\n");
d5025 1
a5025 1
    error ("remote query is only available after target open");
d5068 1
a5068 1
    error ("remote rcmd is only available after target open");
d5079 1
a5079 1
    error ("\"monitor\" command ``%s'' is too long\n", command);
d5085 1
a5085 1
    error ("Communication problem with target\n");
d5094 1
a5094 1
	error ("Target does not support this command\n");
d5105 1
a5105 1
	  error ("Protocol error with Rcmd");
d5123 1
a5123 1
    error ("command can only be used with remote target");
d5126 1
a5126 1
    error ("remote-packet command requires packet text as argument");
@


1.163
log
@2005-01-19  Andrew Cagney  <cagney@@gnu.org>

	* exceptions.h (deprecated_throw_reason): Rename throw_reason.
	* exceptions.c (deprecated_throw_reason): Rename throw_reason.
	* utils.c (internal_verror, quit): Update.
	* remote-sds.c (interrupt_query): Update.
	* remote-mips.c (mips_error, mips_kill): Update.
	* remote-fileio.c (remote_fileio_ctrl_c_signal_handler): Update.
	* remote.c (interrupt_query): Update.
	* ocd.c (interrupt_query): Update.
	* nto-procfs.c (interrupt_query): Update.
	* monitor.c (monitor_interrupt_query): Update.
	* breakpoint.c (break_command_1): Update.
@
text
@d663 1
a663 1
				"", print,
d5603 2
a5604 2
If set, a break, instead of a cntrl-c, is sent to the remote target.", "\
Whether to send break if interrupted is %s.",
d5645 2
a5646 2
Specify a negative limit for unlimited.", "\
The maximum number of target hardware watchpoints is %s.",
d5653 2
a5654 2
Specify a negative limit for unlimited.", "\
The maximum number of target hardware breakpoints is %s.",
d5758 2
a5759 2
packets.", "\
Use of remote protocol `Z' packets is %s",
@


1.162
log
@2005-01-18  Andrew Cagney  <cagney@@gnu.org>

	* remote.c (remote_open_1): Use throw_exception.
@
text
@d2733 1
a2733 1
      throw_reason (RETURN_QUIT);
@


1.161
log
@2005-01-14  Andrew Cagney  <cagney@@gnu.org>

	* exceptions.h (exception_fprintf): Declare.
	(exception_print): Drop pre_print parameter.
	* mi/mi-main.c (mi_execute_command): Update exception_print call.
	* cli/cli-interp.c (safe_execute_command): Update exception_print
	call.
	* remote.c (remote_open_1): Instead of passing an error prefix to
	catch_exceptions, use catch_exceptions and exception_fprintf.
	(remote_start_remote): Change return type to void.
	* breakpoint.c (insert_bp_location): Instead of passing an error
	prefix to catch_exceptions, use catch_exceptions and
	exception_fprintf.
	(insert_catchpoint): Change return type to void.
	(break_command_1): Update exception_print call.
	* exceptions.c (exception_fprintf): New function.
	(print_exception): New function.
	(exception_print): Use print_exception.
@
text
@a2259 2
  exception_fprintf (gdb_stderr, ex, "Couldn't establish connection to remote"
		     " target\n");
d2265 1
a2265 1
      throw_reason (ex.reason);
@


1.160
log
@2005-01-13  Michael Snyder  <msnyder@@redhat.com>

	* remote.c: Whitespace tweaks.
@
text
@a85 2
static int remote_start_remote (struct ui_out *uiout, void *dummy);

d2020 1
a2020 1
static int
d2038 1
a2038 3
  /* NOTE: See comment above in remote_start_remote_dummy().  This
     function returns something >=0.  */
  return remote_start_remote_dummy (uiout, dummy);
d2156 1
a2156 1
  int ex;
d2259 4
a2262 6
  ex = catch_exceptions (uiout,
			 remote_start_remote, NULL,
			 "Couldn't establish connection to remote"
			 " target\n",
			 RETURN_MASK_ALL);
  if (ex < 0)
d2267 1
a2267 1
      throw_reason (ex);
@


1.159
log
@2005-01-12  Andrew Cagney  <cagney@@gnu.org>

	* exceptions.h (throw_reason): Rename throw_exception.
	(enum errors, struct exception): Define.
	(catch_exception_ftype): Define.
	(catch_exception, throw_exception): Declare.
	* exceptions.c (throw_exception): Rewrite.
	(throw_reason): New function.
	(struct catcher, catcher_state_machine): Replace "reason" with
	"exception", delete "gdberrmsg".
	(catch_exception): New function.
	(catcher_init): Replace "gdberrmsg" parameter with "exception".
	(catch_errors, catch_exceptions_with_msg): Re-implement passing
	exception to catcher_init.
	* utils.c (error_silent, error_stream_1): Use throw_reason.
	(internal_verror, quit): Ditto.
	* breakpoint.c (insert_catchpoint, break_command_1): Ditto.
	* remote-fileio.c (remote_fileio_ctrl_c_signal_handler): Ditto.
	* remote.c (remote_open_1, interrupt_query): Ditto.
@
text
@d24 1
a24 1
/* See the GDB User Guide for details of the GDB remote protocol. */
d59 1
a59 1
/* Prototypes for local functions */
d209 2
a210 1
  /* long size in bytes;  == register_size (current_gdbarch, regnum); at present.  */
d228 1
a228 1
     trailers). */
d232 1
a232 1
     It is also used as a cap on the size of read/write packets. */
d269 1
a269 1
      /* Compute packet size by accumulating the size of all registers. */
d280 1
a280 1
     already a full buffer (As of 1999-12-04 that was most stubs. */
d288 1
a288 1
     little. */
d292 1
a292 1
  /* This one is filled in when a ``g'' packet is received. */
d332 1
a332 1
/* This is non-zero if taregt stopped for a watchpoint. */
d341 1
a341 1
   extended_remote_ops, but with asynchronous support. */
d352 1
a352 1
   this can go away. */
d377 1
a377 1
   facilitate backward compatibility. */
d393 1
a393 1
   (Positive - a soft limit, negative - a hard limit). */
d413 1
a413 1
     be lifted or removed. */
d417 1
a417 1
  /* NOTE: 16 is just chosen at random. */
d432 1
a432 1
      /* Limit the packet to the size specified by the user. */
d436 1
a436 1
      /* Limit it to the size of the targets ``g'' response. */
d449 1
a449 1
   something really big then do a sanity check. */
d474 1
a474 1
         large. */
d479 1
a479 1
  /* Extra checks? */
d487 1
a487 1
  /* Update the config. */
d551 1
a551 1
     increased beyond (rs->remote_packet_size). */
d560 1
a560 1
   as allowing GDB to auto-detect support in the remote stub. */
d578 1
a578 1
   accordingly. */
d668 1
a668 1
  /* set/show remote NAME-packet {auto,on,off} -- legacy */
d686 1
a686 1
	 operation succeeded. */
d704 1
a704 1
	/* "OK" - definitly OK. */
d709 1
a709 1
	/* "Enn"  - definitly an error. */
d711 1
a711 1
      /* The packet may or may not be OK.  Just assume it is */
d716 1
a716 1
      /* The stub does not support the packet. */
d722 1
a722 1
	       supported then there is a protocol error.. */
d726 1
a726 1
	    /* The user set it wrong. */
d744 1
a744 1
/* Should we try the 'vCont' (descriptive resume) request? */
d761 1
a761 1
/* Should we try the 'qSymbol' (target symbol lookup service) request? */
d811 1
a811 1
   command callback should include a context argument. */
d884 1
a884 1
   Z-packet ...'' command that updates all the Z packet types. */
d919 1
a919 1
   only). */
d949 1
a949 1
/* Should we try the 'qPart:auxv' (target auxiliary vector read) request? */
d984 1
a984 1
/* Tokens for use by the asynchronous signal handlers for SIGINT */
d1082 3
a1084 2
/* WARNING: This threadref data structure comes from the remote O.S., libstub
   protocol encoding, and remote.c. it is not particularly changable */
d1090 1
a1090 1
typedef int gdb_threadref;	/* internal GDB thread reference */
d1093 1
a1093 1
   equivalint to the reply of the remote threadinfo packet */
d1097 8
a1104 5
    threadref threadid;		/* External form of thread reference */
    int active;			/* Has state interesting to GDB? , regs, stack */
    char display[256];		/* Brief state display, name, blocked/syspended */
    char shortname[32];		/* To be used to name threads */
    char more_display[256];	/* Long info, statistics, queue depth, whatever */
d1119 1
a1119 1
#define BUF_THREAD_ID_SIZE (OPAQUETHREADBYTES*2)
d1127 1
a1127 1
static char *pack_hex_byte (char *pkt, int /*unsigned char */ byte);
d1137 1
a1137 1
static char *pack_threadid (char *pkt, threadref * id);
d1139 1
a1139 1
static char *unpack_threadid (char *inbuf, threadref * id);
d1141 1
a1141 1
void int_to_threadref (threadref * id, int value);
d1143 1
a1143 1
static int threadref_to_int (threadref * ref);
d1145 1
a1145 1
static void copy_threadref (threadref * dest, threadref * src);
d1147 1
a1147 1
static int threadmatch (threadref * dest, threadref * src);
d1149 2
a1150 1
static char *pack_threadinfo_request (char *pkt, int mode, threadref * id);
d1153 1
a1153 1
					       threadref * expectedref,
d1158 2
a1159 1
static int remote_get_threadinfo (threadref * threadid, int fieldset,	/*TAG mask */
d1164 1
a1164 1
				      threadref * nextthread);
d1168 3
a1170 2
				      threadref * original_echo,
				      threadref * resultlist, int *doneflag);
d1173 1
a1173 1
				  threadref * nextthread,
d1176 2
a1177 1
				  int *result_count, threadref * threadlist);
d1179 1
a1179 1
typedef int (*rmt_thread_action) (threadref * ref, void *context);
d1184 1
a1184 1
static int remote_newthread_step (threadref * ref, void *context);
d1186 1
a1186 1
/* encode 64 bits in 16 chars of hex */
d1303 1
a1303 1
#if 0				/* currently unused, uncomment when needed */
d1314 1
a1314 1
    len = 200;			/* Bigger than most GDB packets, junk??? */
d1320 1
a1320 1
	ch = '*';		/* Protect encapsulation */
d1420 1
a1420 1
  /* things are broken right now, so just assume we got a match */
d1448 3
a1450 3
  *pkt++ = 'q';			/* Info Query */
  *pkt++ = 'P';			/* process or thread info */
  pkt = pack_int (pkt, mode);	/* mode */
d1452 1
a1452 1
  *pkt = '\0';			/* terminate */
d1456 1
a1456 1
/* These values tag the fields in a thread info response packet */
d1458 1
a1458 1
   add more fields as time goes by */
d1460 1
a1460 1
#define TAG_THREADID 1		/* Echo the thread identifier */
d1462 1
a1462 1
				   fetch registers and its stack */
d1464 1
a1464 1
#define TAG_THREADNAME 8	/* string, maps 1-to-1 with a thread is */
d1466 1
a1466 1
				   the process */
d1479 1
a1479 1
  /* info->threadid = 0; FIXME: implement zero_threadref */
d1485 2
a1486 1
  /* Assume the characters indicating the packet type have been stripped */
d1493 1
a1493 1
    {				/* This is an answer to a different request */
d1499 1
a1499 1
  /* Loop on tagged fields , try to bail if somthing goes wrong */
d1501 2
a1502 1
  while ((pkt < limit) && mask && *pkt)		/* packets are terminated with nulls */
d1505 2
a1506 2
      pkt = unpack_byte (pkt, &length);		/* length */
      if (!(tag & mask))	/* tags out of synch with mask */
d1556 1
a1556 1
      break;			/* Not a tag we know about */
d1572 2
a1573 2
  result = remote_unpack_thread_info_response (threadinfo_pkt + 2, threadid,
					       info);
d1585 1
a1585 1
  pkt = pack_nibble (pkt, startflag);	/* initflag 1 bytes */
d1605 2
a1606 1
  limit = pkt + ((rs->remote_packet_size) - BUF_THREAD_ID_SIZE);		/* done parse past here */
d1632 1
a1632 1
  /* Trancate result limit to be smaller than the packet size */
d1647 2
a1648 2
      /* FIXME: This is a good reason to drop the packet */
      /* Possably, there is a duplicate response */
d1656 1
a1656 1
      return 0;			/* I choose simply exiting */
d1676 2
a1677 1
/* This is the interface between remote and threads, remotes upper interface */
d1686 1
a1686 1
/* About this many threadisds fit in a packet. */
d1716 1
a1716 1
      /* clear for later iterations */
d1823 1
a1823 1
  /* Else fall back to old method based on jmetzler protocol. */
d1846 1
a1846 1
  static char display_buf[100];	/* arbitrary... */
d1886 1
a1886 1
	    /* for purely cosmetic reasons, clear up trailing commas */
d1927 1
a1927 1
/* Query the remote side for the text, data and bss offsets. */
d1945 1
a1945 1
				   this command. */
d2016 1
a2016 1
  start_remote ();		/* Initialize gdb process mechanisms */
d2025 1
a2025 1
  immediate_quit++;		/* Allow user to interrupt it */
d2035 1
a2035 1
  get_offsets ();		/* Get text, data & bss offsets */
d2037 1
a2037 1
  putpkt ("?");			/* initiate a query from remote machine */
d2054 1
a2054 1
/* Just like remote_open, but with asynchronous support. */
d2071 1
a2071 1
/* Just like extended_remote_open, but with asynchronous support. */
d2092 1
a2092 1
     downloading. */
d2097 1
a2097 1
/* Symbol look-up. */
d2113 1
a2113 1
  /* Invite target to request symbol lookups. */
d2167 1
a2167 1
  /* See FIXME above */
d2208 1
a2208 1
  push_target (target);		/* Switch to using remote target now */
d2230 1
a2230 1
      /* With this target we start out by owning the terminal. */
d2239 1
a2239 1
	 implemented. */
d2244 1
a2244 1
  /* First delete any symbols previously loaded from shared libraries. */
d2293 2
a2294 2
  /* Set up to detect and load shared libraries. */
  if (exec_bfd) 	/* No use without an exec file. */
d2320 1
a2320 1
  /* Unregister the file descriptor from the event loop. */
d2340 1
a2340 1
  /* Unregister the file descriptor from the event loop. */
d2374 1
a2374 1
	     Return the count that has been converted so far. */
d2398 1
a2398 1
  /* May use a length, or a nul-terminated string as input. */
d2568 1
a2568 1
    set_thread (0, 0);		/* run any thread */
d2570 1
a2570 1
    set_thread (pid, 0);	/* run this thread */
d2585 1
a2585 1
/* Same as remote_resume, but with async support. */
d2594 1
a2594 1
     of the execution commands in infcmd.c.*/
d2597 1
a2597 1
     NOT asynchronously. */
d2600 1
a2600 1
  /* Tell the world that the target is now executing. */
d2611 1
a2611 1
   executing, ovewriting the 'regular' SIGINT signal handler. */
d2620 1
a2620 1
/* Signal handler for SIGINT, while the target is executing. */
d2632 1
a2632 1
   a ^C. */
d2643 1
a2643 1
   to a ^C. */
d2654 1
a2654 1
   up on the target alltogether. */
d2661 1
a2661 1
     cntl-C. */
d2670 1
a2670 1
   stopped. */
d2676 2
a2677 1
    delete_async_signal_handler ((struct async_signal_handler **) & sigint_remote_twice_token);
d2679 2
a2680 1
    delete_async_signal_handler ((struct async_signal_handler **) & sigint_remote_token);
d2691 1
a2691 1
   we ask the user if he'd like to detach from the target. */
d2695 1
a2695 1
  /* If this doesn't work, try more severe steps. */
d2716 1
a2716 1
   will eventually end up here. */
d2750 1
a2750 1
   is required. */
d2759 1
a2759 1
     consequently should not call this code. */
d2775 1
a2775 1
     passed on down to the target. */
d2781 1
a2781 1
  /* See FIXME in remote_async_terminal_inferior. */
d2784 1
a2784 1
  /* See FIXME in remote_async_terminal_inferior. */
d2845 1
a2845 1
	case 'E':		/* Error of some sort */
d2848 1
a2848 1
	case 'F':		/* File-I/O request */
d2851 1
a2851 1
	case 'T':		/* Status with PC, SP, FP, ... */
d2856 1
a2856 1
	    /* Expedited reply, containing Signal, {regno, reg} repeat */
d2871 3
a2873 3
		/* If the packet contains a register number save it in pnum
		   and set p1 to point to the character following it.
		   Otherwise p1 points to p.  */
d2875 2
a2876 2
		/* If this packet is an awatch packet, don't parse the 'a'
		   as a register number.  */
d2887 1
a2887 1
		if (p1 == p)	/* No register number present here */
d2922 2
a2923 1
		      error ("Malformed packet(b) (missing colon): %s\nPacket: '%s'\n",
d2927 2
a2928 1
		      error ("Remote sent bad register number %s: %s\nPacket: '%s'\n",
d2931 3
a2933 1
		    fieldsize = hex2bin (p, regs, register_size (current_gdbarch, reg->regnum));
d2935 2
a2936 1
		    if (fieldsize < register_size (current_gdbarch, reg->regnum))
d2938 2
a2939 1
		    regcache_raw_supply (current_regcache, reg->regnum, regs);
d2943 2
a2944 1
		  error ("Remote register badly formatted: %s\nhere: %s", buf, p);
d2948 1
a2948 1
	case 'S':		/* Old style status, just signal only */
d2959 1
a2959 1
	case 'W':		/* Target exited */
d2973 1
a2973 1
	case 'O':		/* Console output */
d3006 1
a3006 1
/* Async version of remote_wait. */
d3029 1
a3029 1
         knows how to take the target into/out of async mode. */
d3041 1
a3041 1
	case 'E':		/* Error of some sort */
d3044 1
a3044 1
	case 'F':		/* File-I/O request */
d3047 1
a3047 1
	case 'T':		/* Status with PC, SP, FP, ... */
d3052 1
a3052 1
	    /* Expedited reply, containing Signal, {regno, reg} repeat */
d3067 3
a3069 3
		/* If the packet contains a register number, save it in pnum
		   and set p1 to point to the character following it.
		   Otherwise p1 points to p.  */
d3083 1
a3083 1
		if (p1 == p)	/* No register number present here */
d3087 2
a3088 1
		      error ("Malformed packet(a) (missing colon): %s\nPacket: '%s'\n",
d3118 2
a3119 1
		      error ("Malformed packet(b) (missing colon): %s\nPacket: '%s'\n",
d3123 2
a3124 1
		      error ("Remote sent bad register number %ld: %s\nPacket: '%s'\n",
d3127 3
a3129 1
		    fieldsize = hex2bin (p, regs, register_size (current_gdbarch, reg->regnum));
d3131 2
a3132 1
		    if (fieldsize < register_size (current_gdbarch, reg->regnum))
d3143 1
a3143 1
	case 'S':		/* Old style status, just signal only */
d3154 1
a3154 1
	case 'W':		/* Target exited */
d3168 1
a3168 1
	case 'O':		/* Console output */
d3171 1
a3171 1
             still be waiting on the inferior afterwards. */
d3245 1
a3245 1
          error("fetch_register_using_p: early buf termination");
d3307 1
a3307 1
     target can safely receive. */
d3319 1
a3319 1
	 && buf[0] != 'x')	/* New: unavailable register value */
d3415 1
a3415 1
   packet was not recognized. */
d3438 2
a3439 2
/* Store register REGNUM, or all registers if REGNUM == -1, from the contents
   of the register cache buffer.  FIXME: ignores errors.  */
d3547 1
a3547 1
/* Mask all but the least significant REMOTE_ADDRESS_SIZE bits. */
d3556 1
a3556 1
         in a ULONGEST variable. */
d3567 3
a3569 2
   the whole packet, since many stubs strip the eighth bit and subsequently
   compute a wrong checksum, which causes real havoc with remote_write_bytes.
d3573 1
a3573 1
   X-packet". */
d3627 1
a3627 1
   error.  Only transfer a single packet. */
d3646 1
a3646 1
     possible packet.  Include space for an extra trailing NUL.  */
d3659 1
a3659 1
     actually transfered. */
d3665 1
a3665 1
      /* Best guess at number of bytes that will fit. */
d3670 1
a3670 1
      /* num bytes that will fit */
d3714 1
a3714 1
	      /* These must be escaped */
d3760 2
a3761 2
  /* Return NR_BYTES, not TODO, in case escape chars caused us to send fewer
     bytes than we'd planned.  */
d3778 1
a3778 1
   handling partial reads. */
d3784 1
a3784 1
  int max_buf_size;		/* Max size of packet output buffer */
d3788 1
a3788 1
  /* Create a buffer big enough for this packet. */
d3790 1
a3790 1
  sizeof_buf = max_buf_size + 1; /* Space for trailing NUL */
d3819 5
a3823 4
	  /* There is no correspondance between what the remote protocol uses
	     for errors and errno codes.  We would like a cleaner way of
	     representing errors (big enough to include errno codes, bfd_error
	     codes, and others).  But for now just return EIO.  */
d3835 1
a3835 1
	     only part of what we wanted to. */
d3846 3
a3848 3
   transferring to or from debugger address BUFFER.  Write to inferior if
   SHOULD_WRITE is nonzero.  Returns length of data written or read; 0
   for error.  TARGET is unused.  */
d3860 2
a3861 1
  gdbarch_remote_translate_xfer_address (current_gdbarch, current_regcache,
d3884 2
a3885 1
/* Read a single character from the remote end, masking it down to 7 bits. */
d3944 4
a3947 3
   of the packet is in BUF.  The string in BUF can be at most  (rs->remote_packet_size) - 5
   to account for the $, # and checksum, and for a possible /0 if we are
   debugging (remote_debug) and want to print the sent packet as a string */
d3995 1
a3995 1
      /* read until either a timeout occurs (-2) or '+' is read */
d4029 1
a4029 1
	      break;		/* Retransmit buffer */
d4033 2
a4034 1
		  fprintf_unfiltered (gdb_stdlog, "Packet instead of Ack, ignoring it\n");
d4041 1
a4041 1
		continue;	/* Now, go look for + */
d4055 1
a4055 1
	  break;		/* Here to retransmit */
d4080 1
a4080 1
   SERIAL status indications). */
d4095 1
a4095 1
      /* ASSERT (bc < sizeof_buf - 1) - space for trailing NUL */
d4107 1
a4107 1
	  return -1;		/* Start a new packet, count retries */
d4123 2
a4124 1
		  fputs_filtered ("Timeout in checksum, retrying\n", gdb_stdlog);
d4130 2
a4131 1
		  fputs_filtered ("Communication error in checksum\n", gdb_stdlog);
d4148 1
a4148 1
               NUL. */
d4151 1
a4151 1
	case '*':		/* Run length encoding */
d4158 1
a4158 1
	    repeat = c - ' ' + 3;	/* Compute repeat count */
d4160 1
a4160 1
	    /* The character before ``*'' is repeated. */
d4172 2
a4173 1
	    printf_filtered ("Repeat count %d too large for buffer: ", repeat);
d4203 1
a4203 1
   thing to do it for those. */
d4220 1
a4220 1
   the caller. */
d4246 8
a4253 6
         continuously, but if it pauses, we'll get a zero from readchar
         because of timeout.  Then we'll count that as a retry.  */

      /* Note that we will only wait forever prior to the start of a packet.
         After that, we expect characters to arrive at a brisk pace.  They
         should show up within remote_timeout intervals.  */
d4261 1
a4261 1
	      if (forever)	/* Watchdog went off?  Kill the target. */
d4295 2
a4296 1
  /* We have tried hard enough, and just can't receive the packet.  Give up. */
d4324 1
a4324 1
/* Async version of remote_kill. */
d4328 1
a4328 1
  /* Unregister the file descriptor from the event loop. */
d4341 2
a4342 2
  /* Use catch_errors so the user can quit from gdb even when we aren't on
     speaking terms with the remote system.  */
d4391 2
a4392 2
extended_remote_create_inferior (char *exec_file, char *args, char **env,
				 int from_tty)
d4412 1
a4412 1
/* Async version of extended_remote_create_inferior. */
d4414 2
a4415 2
extended_remote_async_create_inferior (char *exec_file, char *args, char **env,
				       int from_tty)
d4422 1
a4422 1
     with the event loop. */
d4490 1
a4490 1
     report an error, otherwise, mark it disabled and go on. */
d4812 1
a4812 1
/* Table used by the crc32 function to calcuate the checksum. */
d4822 1
a4822 1
      /* Initialize the CRC table and the decoding table. */
d4852 1
a4852 1
   generic_load()) to make use of this target functionality. */
d4892 1
a4892 1
      /* FIXME: assumes lma can fit into long */
d4896 2
a4897 1
      /* be clever; compute the host_crc before waiting for target reply */
d5031 1
a5031 1
  /* except for querying the minimum buffer size, target must be open */
d5041 5
a5045 4
  /* we used one buffer char for the remote protocol q command and another
     for the query type.  As the remote protocol encapsulation uses 4 chars
     plus one extra in case we are debugging (remote_debug),
     we have PBUFZIZ - 7 left to pack the query string */
d5078 1
a5078 1
  /* Send a NULL command across as an empty command */
d5082 1
a5082 1
  /* The query prefix */
d5089 1
a5089 1
  /* Encode the actual command */
d5098 1
a5098 1
      /* XXX - see also tracepoint.c:remote_get_noisy_reply() */
d5105 1
a5105 1
	  remote_console_output (buf + 1); /* 'O' message from stub */
d5148 1
a5148 1
/* --------- UNIT_TEST for THREAD oriented PACKETS ------------------------- */
d5158 1
a5158 1
int get_and_display_threadinfo (threadref * ref);
d5162 1
a5162 1
static int thread_display_step (threadref * ref, void *context);
d5168 1
a5168 1
#define SAMPLE_THREAD  0x05060708	/* Truncated 64 bit threadid */
d5191 1
a5191 1
void output_threadid (char *title, threadref * ref);
d5198 1
a5198 1
  pack_threadid (&hexid[0], ref);	/* Convert threead id into hex */
d5375 1
a5375 1
  /* We're async whenever the serial device is. */
d5382 1
a5382 1
  /* We're async whenever the serial device is. */
d5388 1
a5388 1
   point where an entire packet has been received. */
d5390 2
a5391 1
static void (*async_client_callback) (enum inferior_event_type event_type, void *context);
d5404 2
a5405 1
remote_async (void (*callback) (enum inferior_event_type event_type, void *context), void *context)
d5425 1
a5425 1
   target. */
d5431 2
a5432 1
  remote_async_ops.to_longname = "Remote serial target in async version of the gdb-specific protocol";
d5526 1
a5526 1
/* Saved pointer to previous owner of the new_objfile event. */
d5529 1
a5529 1
/* Function to be called whenever a new objfile (shlib) is detected. */
d5533 1
a5533 1
  if (remote_desc != 0)		/* Have a remote connection */
d5537 1
a5537 1
  /* Call predecessor on chain, if any. */
d5551 2
a5552 1
  remote_gdbarch_data_handle = gdbarch_data_register_post_init (init_remote_state);
d5579 1
a5579 1
  /* set/show remote ... */
d5586 1
a5586 1
		  0/*allow-unknown*/, &setlist);
d5592 1
a5592 1
		  0/*allow-unknown*/, &showlist);
d5616 1
a5616 1
  /* Install commands for configuring memory read/write packets. */
d5682 1
a5682 1
     compatibility. */
d5760 1
a5760 1
  /* Keep the old ``set remote Z-packet ...'' working. */
@


1.158
log
@2005-01-12  Andrew Cagney  <cagney@@gnu.org>

	* exceptions.h (enum return_reason, RETURN_MASK)
	(RETURN_MASK_QUIT, RETURN_MASK_ERROR, RETURN_MASK_ALL)
	(return_mask, throw_exception, catch_exceptions_ftype)
	(catch_exceptions_with_msg, catch_errors_ftype, catch_errors)
	(catch_command_errors_ftype, catch_command_errors): Move to
	exceptions.h.
	* exceptions.c, exceptions.h: New files.
	* top.c: Do not include <setjmp.h>.
	(SIGJMP_BUF, SIGSETJMP, SIGLONGJMP, catch_return)
	(throw_exception, catcher, catch_exceptions)
	(catch_exceptions_with_msg, struct catch_errors_args)
	(do_catch_errors, catch_errors, struct captured_command_args)
	(do_captured_command, catch_command_errors): Move to exceptions.c.
	* wrapper.c, wince.c, win32-nat.c, utils.c: Include "exceptions.h".
	* tui/tui-interp.c, top.c, thread.c, symmisc.c: Ditto.
	* symfile-mem.c, stack.c, solib.c, rs6000-nat.c: Ditto.
	* remote-sds.c, remote-mips.c, remote-fileio.c: Ditto.
	* remote-e7000.c, objc-lang.c, ocd.c: Ditto.
	* remote.c, nto-procfs.c, monitor.c, mi/mi-main.c: Ditto.
	* main.c, m32r-rom.c, infrun.c, inf-loop.c: Ditto.
	* hppa-hpux-tdep.c, frame.c, event-top.c, event-loop.c: Ditto.
	* corelow.c, corefile.c, cli/cli-interp.c, breakpoint.c: Ditto.
	* ada-valprint.c, ada-lang.c: Ditto.
	* Makefile.in (HFILES_NO_SRCDIR, COMMON_OBS): Add exceptions.h and
	exceptions.o.  Update all dependencies.
@
text
@d2260 1
a2260 1
      throw_exception (ex);
d2726 1
a2726 1
      throw_exception (RETURN_QUIT);
@


1.157
log
@* remote.c (fetch_register_using_p): Recognize a register value
starting with 'x' as indicating an unfetchable register.
@
text
@d33 1
@


1.156
log
@* remote.c (fetch_register_using_p): Fix formatting.
@
text
@d3195 8
a3202 1
  if (buf[0] != 0 && buf[0] != 'E')
d3204 2
a3205 13
      p = buf;
      i = 0;
      while (p[0] != 0)
	{
	  if (p[1] == 0)
	    {
	      error ("fetch_register_using_p: early buf termination");
	      return 0;
	    }
	  regp[i++] = fromhex (p[0]) * 16 + fromhex (p[1]);
	  p += 2;
	}
      regcache_raw_supply (current_regcache, regnum, regp);
d3209 16
a3224 1
  return 0;
@


1.155
log
@* remote.c (fetch_register_using_p): Indentation cleanup.
@
text
@d3195 16
a3210 10
  if (buf[0] != 0 && buf[0] != 'E') {
    p = buf;
    i = 0;
    while (p[0] != 0) {
      if (p[1] == 0) {
        error("fetch_register_using_p: early buf termination");
        return 0;
      }
      regp[i++] = fromhex (p[0]) * 16 + fromhex (p[1]);
      p += 2;
a3211 3
    regcache_raw_supply (current_regcache, regnum, regp);
    return 1;
  }
@


1.154
log
@* remote.c (remote_threads_info, remote_current_thread): Use
strtoul to parse thread ID numbers.
@
text
@d3196 9
a3204 9
     p = buf;
     i = 0;
     while (p[0] != 0) {
	if (p[1] == 0) {
		error("fetch_register_using_p: early buf termination");
		return 0;
	}
	regp[i++] = fromhex (p[0]) * 16 + fromhex (p[1]);
        p += 2;
d3208 1
a3208 1
 }
d3210 1
a3210 1
 return 0;
@


1.153
log
@2004-11-05  Jon Beniston <jon@@beniston.com>

	* remote.c (putpkt_binary) Fix PR gdb/1806. Send an ACK
	when an unexpected packet is received, as the target stubs
	continually retransmit the same packet until ACKed.
@
text
@d1738 6
a1743 1
    return pid_to_ptid (strtol (&buf[2], NULL, 16));
d1790 7
a1796 1
		  tid = strtol (bufp, &bufp, 16);
@


1.152
log
@* remote.c (fetch_register_using_p): Construct 'p' packet in a
manner independent of the host byte order.
@
text
@d3975 4
a3978 2
		/* It's probably an old response, and we're out of sync.
		   Just gobble up the packet and ignore it.  */
d3980 1
@


1.151
log
@2004-10-08  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Rename to_xfer_memory to
	deprecated_xfer_memory.
	* target.c: Update.
	(deprecated_debug_xfer_memory): Rename debug_to_xfer_memory.
	* wince.c: Update.
	* win32-nat.c: Update.
	* v850ice.c: Update.
	* uw-thread.c: Update.
	* thread-db.c: Update.
	* sol-thread.c: Update.
	* remote.c: Update.
	* remote-vx.c: Update.
	* remote-st.c: Update.
	* remote-sim.c: Update.
	* remote-sds.c: Update.
	* remote-rdp.c: Update.
	* remote-rdi.c: Update.
	* remote-mips.c: Update.
	* remote-m32r-sdi.c: Update.
	* remote-e7000.c: Update.
	* procfs.c: Update.
	* ppc-bdm.c: Update.
	* nto-procfs.c: Update.
	* monitor.c: Update.
	* linux-nat.c: Update.
	* inftarg.c: Update.
	* hpux-thread.c: Update.
	* go32-nat.c: Update.
	* gnu-nat.c: Update.
	* exec.c: Update.
	* corelow.c: Update.
	* bsd-kvm.c: Update.
	* aix-thread.c: Update.
@
text
@d3179 4
a3182 3
  buf[0] = 'p';
  bin2hex((char *) &regnum, &buf[1], sizeof(regnum));
  buf[9] = 0;
@


1.151.2.1
log
@2004-11-05  Andrew Cagney  <cagney@@gnu.org>

	Backport 2004-10-27 Jim Blandy <jimb@@redhat.com>
	* remote.c (fetch_register_using_p): Construct 'p' packet in a
	manner independent of the host byte order.
@
text
@d3179 3
a3181 4
  p = buf;
  *p++ = 'p';
  p += hexnumstr (p, regnum);
  *p++ = '\0';
@


1.150
log
@
2004-10-08  Jeff Johnston  <jjohnstn@@redhat.com>

        * target.h (to_stopped_data_address): Change prototype to
        take a CORE_ADDR pointer and return an int.
        * target.c (update_current_target): Change to_stopped_data_address
        to match new prototype.
        (debug_to_stopped_data_address): Change appropriately.
        * breakpoint.c (bpstat_stop_status): Change call to
        target_stopped_data_address to use new prototype.
        * frv-tdep.c (frv_have_stopped_data_address): New function.
        (frv_stopped_data_address): Change to new prototype and
        functionality.
        * ia64-linux-nat.c (ia64_stopped_data_address): Change to new
        prototype and functionality.
        (ia64_stopped_by_watchpoint): New function.
        * i386-nat.c (i386_stopped_data_address): Change to new
        prototype and functionality.
        (i386_stopped_by_watchpoint): New function.
        * remote.c (remote_stopped_data_address): Change to new prototype
        and functionality.
        * remote-m32r-sdi.c (m32r_stopped_data_address): Ditto.
        * config/frv/tm-frv.h (frv_stopped_data_address): Change prototype.
        (STOPPED_BY_WATCHPOINT): Change to use frv_have_stopped_data_address.
        * config/i386/nm-i386.h (STOPPED_BY_WATCHPOINT): Change to use
        new i386_stopped_by_watchpoint function.
        (i386_stopped_by_watchpoint): New prototype.
        (i386_stoppped_data_address): Change to new prototype.
        * config/ia64/nm-linux.h (STOPPED_BY_WATCHPOINT): Change to use
        new ia64_stopped_by_watchpoint function.
        (ia64_stopped_by_watchpoint): New prototype.
        (ia64_stopped_data_address): Ditto.
@
text
@d5250 1
a5250 1
  remote_ops.to_xfer_memory = remote_xfer_memory;
d5370 1
a5370 1
  remote_async_ops.to_xfer_memory = remote_xfer_memory;
@


1.149
log
@	* remote.c (remote_xfer_partial): Handle TARGET_OBJECT_MEMORY.
@
text
@d4627 2
a4628 2
static CORE_ADDR
remote_stopped_data_address (void)
d4630 1
d4633 6
a4638 2
    return remote_watch_data_address;
  return (CORE_ADDR)0;
@


1.148
log
@2004-09-24  Robert Picco <Robert.Picco@@hp.com>

	Committed by Andrew Cagney.
	* remote.c (set_remote_protocol_p_packet_cmd, remote_protocol_p)
	(show_remote_protocol_p_packet_cmd): New.  Implement 'p' packet.
	configuration.
	(fetch_register_using_p): Implement 'p' packet.  Based on code by
	Fernando Nasser.
	(remote_fetch_registers): Call fetch_register_using_p.
	(init_all_packet_configs, show_remote_cmd)
	(_initialize_remote): Add p-packet.
@
text
@d4867 25
@


1.147
log
@2004-09-13  Andrew Cagney  <cagney@@gnu.org>

	Eliminate event_loop_p, always has the value 1.
	* defs.h (event_loop_p): Delete macro.
	* breakpoint.c (until_break_command): Simplify.
	* utils.c (prompt_for_continue): Simplify.
	* tracepoint.c (read_actions): Simplify.
	* top.c (throw_exception, execute_command, gdb_readline_wrapper)
	(gdb_rl_operate_and_get_next, command_line_input, get_prompt)
	(set_prompt, init_main): Simplify.
	(init_signals, disconnect): Delete, unused.
	* remote.c (remote_async_resume)
	(extended_remote_async_create_inferior): Simplify.
	* mi/mi-interp.c (mi_input): Delete, unused.
	(mi_interpreter_resume, mi_command_loop): Simplify.
	* interps.c (current_interp_command_loop): Simplify.
	* infrun.c (proceed): Simplify.
	* infcmd.c (run_command, continue_command, step_1, jump_command)
	(until_command, advance_command, finish_command)
	(interrupt_target_command): Simplify.
	* event-top.c (gdb_setup_readline, gdb_disable_readline): Simplify.
@
text
@d964 17
d2061 1
d3171 30
d3221 25
d5408 1
d5605 7
@


1.146
log
@2004-09-07  Andrew Cagney  <cagney@@gnu.org>

	* vx-share/wait.h: Delete #ifdef USG.
	* utils.c (request_quit): Ditto.
	* tui/tui.c (tui_reset): Ditto.
	* remote.c: Ditto.
	* remote-sds.c: Ditto.
	* remote-rdi.c: Ditto.
	* mdebugread.c: Ditto.
	* m68klinux-nat.c: Ditto.
	* infttrace.c: Ditto.
	* infptrace.c: Ditto.
	* i386v-nat.c: Ditto.
	* exec.c: Ditto.
	* dbxread.c: Ditto.
	* core-aout.c: Ditto.
@
text
@d2555 1
a2555 1
  if (event_loop_p && target_can_async_p ())
d4280 1
a4280 1
  if (event_loop_p && target_can_async_p ())
@


1.145
log
@2004-08-02  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (deprecated_register_bytes): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* regcache.c (deprecated_register_bytes): New function.
	* regcache.h (deprecated_register_bytes): Declare.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init_32082): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* remote.c (init_remote_state): Update.
	* remote-vx.c (vx_prepare_to_store): Update.
	* remote-sds.c (sds_fetch_registers, sds_prepare_to_store): Update.
	* irix5-nat.c (fetch_core_registers): Update.
	* cris-tdep.c (cris_register_bytes_ok): Update.
	* config/nm-gnu.h (CHILD_PREPARE_TO_STORE): Update.
@
text
@a45 3
#ifdef USG
#include <sys/types.h>
#endif
@


1.144
log
@2004-08-02  Andrew Cagney  <cagney@@gnu.org>

	Replace DEPRECATED_REGISTER_RAW_SIZE with register_size.
	* rs6000-tdep.c (rs6000_push_dummy_call)
	(rs6000_extract_return_value): Use register_size.
	* xstormy16-tdep.c (xstormy16_get_saved_register)
	(xstormy16_extract_return_value): Ditto.
	* valops.c (value_assign): Ditto.
	* v850ice.c (v850ice_fetch_registers, v850ice_store_registers):
	* v850-tdep.c (v850_extract_return_value): Ditto.
	* tracepoint.c (collect_symbol): Ditto.
	* target.c (debug_print_register): Ditto.
	* stack.c (frame_info): Ditto.
	* rs6000-nat.c (ARCH64, fetch_register, store_register): Ditto.
	* rom68k-rom.c (rom68k_supply_one_register): Ditto.
	* remote.c (struct packet_reg, remote_wait, remote_async_wait)
	(store_register_using_P): Ditto.
	* remote-vxmips.c (vx_read_register, vx_write_register): Ditto.
	* remote-sim.c (gdbsim_fetch_register, gdbsim_store_register): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump, sub2_from_pc): Ditto.
	* regcache.c (deprecated_read_register_bytes)
	(deprecated_write_register_bytes, read_register)
	(write_register): Ditto.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_register)
	(supply_vrregset, store_altivec_register, fill_vrregset): Ditto.
	* monitor.c (monitor_supply_register, monitor_fetch_register)
	(monitor_store_register): Ditto.
	* mn10300-tdep.c (mn10300_pop_frame_regular)
	(mn10300_print_register): Ditto.
	* mipsv4-nat.c (fill_fpregset): Ditto.
	* mips-linux-tdep.c (supply_32bit_reg, fill_fpregset)
	(mips64_fill_fpregset): Ditto.
	* mi/mi-main.c (register_changed_p, get_register)
	(mi_cmd_data_write_register_values): Ditto.
	* lynx-nat.c (fetch_inferior_registers, store_inferior_registers):
	* irix5-nat.c (fill_gregset, fetch_core_registers):
	* infrun.c (write_inferior_status_register): Ditto.
	* infptrace.c (fetch_register, store_register): Ditto.
	* infcmd.c (default_print_registers_info): Ditto.
	* ia64-linux-nat.c (COPY_REG, fill_fpregset): Ditto.
	* ia64-aix-nat.c (COPY_REG, fill_gregset): Ditto.
	* i386gnu-nat.c (gnu_store_registers, fill): Ditto.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Ditto.
	* hppah-nat.c (store_inferior_registers, fetch_register):
	* findvar.c (value_from_register): Ditto.
	* dve3900-rom.c (fetch_bitmapped_register):
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* alpha-tdep.h: Ditto.
	* aix-thread.c (pd_enable, fill_sprs64, fill_sprs32): Ditto.
@
text
@d253 2
a254 2
  if (DEPRECATED_REGISTER_BYTES != 0)
    rs->sizeof_g_packet = DEPRECATED_REGISTER_BYTES;
d271 1
a271 1
      if (DEPRECATED_REGISTER_BYTES == 0)
@


1.143
log
@2004-07-28  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_cmd): Delete function.
	(add_setshow_cmd_full): Make static.
	* command.h (add_setshow_cmd, add_setshow_cmd_full): Delete.
	(add_setshow_filename_cmd, add_setshow_string_cmd): Declare.
	* cli/cli-decode.c (add_setshow_filename_cmd)
	(add_setshow_string_cmd): New functions.
	* nto-tdep.c (_initialize_nto_tdep): Update.  Fix parameters.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* m32r-rom.c (_initialize_m32r_rom): Update.  Update copyright.
	* cli/cli-logging.c (_initialize_cli_logging): Update.
	* complaints.c (_initialize_complaints): Update.
	* remote.c (_initialize_remote): Update.
@
text
@d211 1
a211 1
  /* long size in bytes;  == DEPRECATED_REGISTER_RAW_SIZE (regnum); at present.  */
d2887 1
a2887 1
		    fieldsize = hex2bin (p, regs, DEPRECATED_REGISTER_RAW_SIZE (reg->regnum));
d2889 1
a2889 1
		    if (fieldsize < DEPRECATED_REGISTER_RAW_SIZE (reg->regnum))
d3075 1
a3075 1
		    fieldsize = hex2bin (p, regs, DEPRECATED_REGISTER_RAW_SIZE (reg->regnum));
d3077 1
a3077 1
		    if (fieldsize < DEPRECATED_REGISTER_RAW_SIZE (reg->regnum))
d3306 1
a3306 1
  bin2hex (regp, p, DEPRECATED_REGISTER_RAW_SIZE (reg->regnum));
@


1.142
log
@2004-07-28  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_zinteger_cmd)
	(add_setshow_cmd, add_setshow_auto_boolean_cmd)
	(add_setshow_boolean_cmd, add_setshow_cmd_full): Add help_doc and
	print parameters.  Make string parameters constant.
	* command.h: Update.  Update copyright.
	* remote.c (add_packet_config_cmd, _initialize_remote): Ditto.
	* observer.c (_initialize_observer): Ditto.
	* frame.c (_initialize_frame): Ditto.
	* complaints.c (_initialize_complaints): Ditto.
	* maint.c (_initialize_maint_cmds): Ditto.
	* target.c (initialize_targets): Ditto.
	* cli/cli-logging.c (_initialize_cli_logging): Ditto.
	* infcall.c (_initialize_infcall): Ditto.
	* arm-tdep.c (_initialize_arm_tdep): Ditto.
	* m32r-rom.c (_initialize_m32r_rom): Ditto.
	* remote-rdi.c (_initialize_remote_rdi): Ditto.
	* d10v-tdep.c (_initialize_d10v_tdep): Ditto.
	* mips-tdep.c (_initialize_mips_tdep): Ditto.
@
text
@d5472 2
a5473 2
  add_setshow_cmd ("hardware-watchpoint-limit", no_class,
		   var_zinteger, &remote_hw_watchpoint_limit, "\
d5478 4
a5481 3
		   NULL, NULL, &remote_set_cmdlist, &remote_show_cmdlist);
  add_setshow_cmd ("hardware-breakpoint-limit", no_class,
		   var_zinteger, &remote_hw_breakpoint_limit, "\
d5486 2
a5487 1
		   NULL, NULL, &remote_set_cmdlist, &remote_show_cmdlist);
@


1.141
log
@2004-07-26  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (deprecated_add_show_from_set): Deprecate.
	* xcoffsolib.c (_initialize_xcoffsolib): Update.
	* wince.c (_initialize_wince): Update.
	* win32-nat.c (_initialize_win32_nat): Update.
	* varobj.c (_initialize_varobj): Update.
	* valops.c (_initialize_valops): Update.
	* utils.c (initialize_utils, initialize_utils): Update.
	* tui/tui-win.c (_initialize_tui_win): Update.
	* top.c (init_main): Update.
	* symfile.c (_initialize_symfile): Update.
	* source.c (_initialize_source): Update.
	* somsolib.c (_initialize_som_solib): Update.
	* solib.c (_initialize_solib): Update.
	* solib-frv.c (_initialize_frv_solib): Update.
	* serial.c (_initialize_serial): Update.
	* ser-go32.c (_initialize_ser_dos, _initialize_ser_dos): Update.
	* remote.c (_initialize_remote, _initialize_remote): Update.
	* remote-vx.c (_initialize_vx): Update.
	* remote-utils.c (_initialize_sr_support): Update.
	* remote-sds.c (_initialize_remote_sds): Update.
	* remote-mips.c (_initialize_remote_mips): Update.
	* remote-e7000.c (_initialize_remote_e7000): Update.
	* proc-api.c (_initialize_proc_api): Update.
	* printcmd.c: Update.
	* parse.c (_initialize_parse): Update.
	* pa64solib.c (_initialize_pa64_solib): Update.
	* p-valprint.c (_initialize_pascal_valprint): Update.
	* monitor.c (_initialize_remote_monitors): Update.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* mcore-tdep.c (_initialize_mcore_tdep): Update.
	* maint.c (_initialize_maint_cmds): Update.
	* lin-lwp.c (_initialize_lin_lwp): Update.
	* language.c (_initialize_language): Update.
	* kod.c (_initialize_kod): Update.
	* infrun.c (set_schedlock_func, _initialize_infrun): Update.
	* i386-tdep.c (_initialize_i386_tdep): Update.
	* gdbtypes.c (build_gdbtypes, _initialize_gdbtypes): Update.
	* gdbarch.sh: Update.
	* gdbarch.c: Re-generate.
	* gdb-events.sh: Update.
	* gdb-events.c: Re-generate.
	* frame.c (_initialize_frame): Update.
	* exec.c: Update.
	* demangle.c (_initialize_demangler): Update.
	* dcache.c (_initialize_dcache): Update.
	* cris-tdep.c (_initialize_cris_tdep, cris_version_update): Update.
	* cp-valprint.c (_initialize_cp_valprint): Update.
	* corefile.c (_initialize_core): Update.
	* command.h: Update.
	* cli/cli-decode.h: Update.
	* cli/cli-cmds.c (init_cli_cmds): Update.
	* charset.c (_initialize_charset): Update.
	* breakpoint.c (_initialize_breakpoint): Update.
	* arm-tdep.c (_initialize_arm_tdep_initialize_arm_tdep): Update.
	* alpha-tdep.c (_initialize_alpha_tdep): Update.
	* aix-thread.c (_initialize_aix_thread): Update.
@
text
@d649 2
d660 2
d666 1
d5431 5
a5435 3
  add_setshow_boolean_cmd ("remotebreak", no_class, &remote_break,
			   "Set whether to send break if interrupted.\n",
			   "Show whether to send break if interrupted.\n",
d5474 2
a5475 1
Set the maximum number of target hardware watchpoints.\n\
d5477 1
a5477 1
Show the maximum number of target hardware watchpoints.\n",
d5481 2
a5482 1
Set the maximum number of target hardware breakpoints.\n\
d5484 1
a5484 1
Show the maximum number of target hardware breakpoints.\n",
d5577 5
a5581 2
Set use of remote protocol `Z' packets",
				"Show use of remote protocol `Z' packets ",
@


1.140
log
@2004-07-23  Andrew Cagney  <cagney@@gnu.org>

	Use regcache_raw_collect instead of regcache_collect.
	* regcache.h (regcache_collect): Delete declaration.
	* regcache.c (regcache_colect): Delete function.
	* win32-nat.c (do_child_store_inferior_registers): Update.
	* sol-thread.c (sol_thread_store_registers): Update.
	* shnbsd-tdep.c (shnbsd_fill_reg): Update.
	* rs6000-nat.c (store_register): Update.
	* remote.c (store_register_using_P, remote_store_registers): Update.
	* ppcnbsd-tdep.c (ppcnbsd_fill_reg): Update.
	* ppc-linux-nat.c (store_altivec_register, store_spe_register)
	(fill_vrregset, store_spe_registers, fill_gregset)
	(fill_gregset): Update.
	* nto-procfs.c (procfs_store_registers): Update.
	* mipsnbsd-tdep.c (mipsnbsd_fill_reg): Update.
	* mips-linux-tdep.c (fill_gregset, mips64_fill_gregset): Update.
	* m68klinux-nat.c (store_register, fill_gregset): Update.
	* m68k-tdep.c (fill_gregset): Update.
	* infptrace.c (store_register): Update.
	* i386-nto-tdep.c (i386nto_regset_fill): Update.
	* i386-linux-nat.c (store_register, fill_gregset): Update.
	* hppa-linux-nat.c (fill_gregset): Update.
	* go32-nat.c (store_register): Update.
	* armnbsd-nat.c (store_register, store_regs, store_fp_register)
	(store_fp_regs): Update.
	* arm-linux-nat.c (store_nwfpe_single, store_nwfpe_double)
	(store_nwfpe_extended, store_fpregister, store_fpregs)
	(store_register, store_regs, fill_gregset, fill_fpregset): Update.
	* alpha-tdep.c (alpha_fill_int_regs, alpha_fill_fp_regs): Update.
	* aix-thread.c (fill_gprs64, fill_fprs, fill_sprs64, fill_sprs32)
	(store_regs_user_thread, store_regs_kernel_thread): Update.
@
text
@d5478 1
a5478 1
  add_show_from_set
d5495 1
a5495 1
  add_show_from_set
@


1.139
log
@2004-07-21  Andrew Cagney  <cagney@@gnu.org>

	Use regcache_raw_supply instead of supply_register.
	* regcache.h (supply_register): Delete declaration.
	* regcache.c (supply_register): Delete function.
	* wince.c (do_child_fetch_inferior_registers): Update.
	* win32-nat.c (do_child_fetch_inferior_registers)
	(fetch_elf_core_registers): Update.
	* v850ice.c (v850ice_fetch_registers): Update.
	* thread-db.c (thread_db_store_registers): Update.
	* sol-thread.c (sol_thread_store_registers): Update.
	* shnbsd-tdep.c (shnbsd_supply_reg): Update.
	* rs6000-nat.c (fetch_register): Update.
	* rom68k-rom.c (rom68k_supply_one_register): Update.
	* remote.c (remote_wait, remote_async_wait): Update.
	* remote-st.c (get_hex_regs): Update.
	* remote-sim.c (gdbsim_fetch_register): Update.
	* remote-sds.c (sds_fetch_registers): Update.
	* remote-rdp.c (remote_rdp_fetch_register): Update.
	* remote-rdi.c (arm_rdi_fetch_registers): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-hms.c (init_hms_cmds): Update.
	* remote-est.c (init_est_cmds): Update.
	* remote-e7000.c (get_hex_regs, fetch_regs_from_dump)
	(e7000_fetch_registers, sub2_from_pc, e7000_wait): Update.
	* ppcnbsd-tdep.c (ppcnbsd_supply_reg, ppcnbsd_supply_fpreg): Update.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register)
	(fetch_register, supply_vrregset, supply_vrregset)
	(fetch_spe_registers): Update.
	* ppc-bdm.c (bdm_ppc_fetch_registers): Update.
	* monitor.c (monitor_supply_register): Update.
	* mipsv4-nat.c (supply_gregset, supply_fpregset): Update.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg)
	(mipsnbsd_supply_fpreg): Update.
	* mips-nat.c (fetch_inferior_registers)
	(fetch_core_registers): Update.
	* mips-linux-tdep.c (supply_32bit_reg, supply_gregset)
	(supply_fpregset, mips64_supply_gregset)
	(mips64_supply_fpregset): Update.
	* m68klinux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* m68k-tdep.c (supply_gregset, supply_fpregset): Update.
	* m32r-rom.c (init_m32r_cmds, init_mon2000_cmds): Update.
	* lynx-nat.c (fetch_inferior_registers, fetch_core_registers): Update.
	* irix5-nat.c (supply_gregset, supply_fpregset): Update.
	* infptrace.c (fetch_register): Update.
	* ia64-linux-nat.c (supply_gregset, supply_fpregset): Update.
	* ia64-aix-nat.c (supply_gregset, supply_fpregset): Update.
	* i386gnu-nat.c (fetch_fpregs, supply_gregset)
	(gnu_fetch_registers, gnu_store_registers): Update.
	* i386-nto-tdep.c (i386nto_supply_gregset): Update.
	* i386-linux-nat.c (fetch_register, supply_gregset)
	(dummy_sse_values): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* hppah-nat.c (fetch_register): Update.
	* hppa-linux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* go32-nat.c (fetch_register): Update.
	* dve3900-rom.c (fetch_bitmapped_register)
	(_initialize_r3900_rom): Update.
	* cris-tdep.c (supply_gregset): Update.
	* abug-rom.c (init_abug_cmds): Update.
	* core-aout.c (fetch_core_registers): Update.
	* armnbsd-nat.c (supply_gregset, supply_fparegset)
	(fetch_register, fetch_fp_register): Update.
	* arm-linux-nat.c (fetch_nwfpe_single, fetch_nwfpe_none)
	(fetch_nwfpe_extended, fetch_fpregister, fetch_fpregs)
	(fetch_register, fetch_regs, supply_gregset, supply_fpregset): Update.
	* alphanbsd-tdep.c (fetch_core_registers): Update.
	* alpha-tdep.c (alpha_supply_int_regs, alpha_supply_fp_regs): Update.
	* alpha-nat.c (fetch_osf_core_registers)
	(fetch_osf_core_registers, fetch_osf_core_registers): Update.
	* aix-thread.c (supply_gprs64, supply_reg32, supply_fprs)
	(supply_sprs64, supply_sprs32, fetch_regs_kernel_thread): Update.
@
text
@d3300 1
a3300 1
  regcache_collect (reg->regnum, regp);
d3361 1
a3361 1
	  regcache_collect (r->regnum, regs + r->offset);
@


1.138
log
@2004-06-26  Andrew Cagney  <cagney@@gnu.org>

	* xcoffsolib.c (xcoff_solib_address): Replace xasprintf with
	xstrprintf.
	* varobj.c (varobj_gen_name, create_child, c_name_of_child)
	(c_value_of_variable): Ditto.
	* utils.c (internal_vproblem): Ditto.
	* solib-aix5.c (build_so_list_from_mapfile): Ditto.
	* remote.c (add_packet_config_cmd): Ditto.
	* remote-rdp.c (rdp_set_command_line): Ditto.
	* regcache.c (regcache_dump): Ditto.
	* frv-tdep.c (new_variant, new_variant): Ditto.
	* fbsd-proc.c (child_pid_to_exec_file): Ditto.
	(fbsd_find_memory_regions): Ditto.
	* breakpoint.c (create_thread_event_breakpoint)
	(create_breakpoints): Ditto.
	* aix-thread.c (aix_thread_pid_to_str): Ditto.
	* ada-lang.c (is_package_name): Ditto.  Also delete xmalloc call.

Index: doc/ChangeLog
2004-06-26  Andrew Cagney  <cagney@@gnu.org>

	* gdbint.texinfo (Coding): Replace xasprintf with xstrprintf.
@
text
@d2886 1
a2886 1
		    supply_register (reg->regnum, regs);
d3074 1
a3074 1
		    supply_register (reg->regnum, regs);
@


1.137
log
@	* dsrec.c (load_srec, make_srec): Use bfd_get_section_size instead of
	bfd_get_section_size_before_reloc or _raw_size.
	* dwarf2-frame.c (dwarf2_build_frame_info): Likewise.
	* dwarf2read.c (dwarf2_locate_sections): Likewise.
	(dwarf2_read_section): Likewise.
	* elfread.c (elf_locate_sections): Likewise.
	* gcore.c (derive_heap_segment): Likewise.
	* mipsread.c (read_alphacoff_dynamic_symtab): Likewise.
	* remote-e7000.c (e7000_load): Likewise.
	* remote-m32r-sdi.c (m32r_load): Likewise.
	* remote-mips.c (mips_load_srec): Likewise.
	(pmon_load_fast): Likewise.
	* remote.c (compare_sections_command): Likewise.
	* symfile.c (add_section_size_callback): Likewise.
	(load_section_callback): Likewise.
	(pc_in_unmapped_range): Likewise.
	(pc_in_mapped_range): Likewise.
	(sections_overlap): Likewise.
	(list_overlays_command): Likewise.
	(simple_overlay_update_1): Likewise.
	(simple_overlay_update): Likewise.
	* tracepoint.c (remote_set_transparent_ranges): Likewise.
	* win32-nat.c (core_section_load_dll_symbols): Likewise.
@
text
@d654 4
a657 4
  xasprintf (&set_doc, "Set use of remote protocol `%s' (%s) packet",
	     name, title);
  xasprintf (&show_doc, "Show current use of remote protocol `%s' (%s) packet",
	     name, title);
d659 1
a659 1
  xasprintf (&cmd_name, "%s-packet", title);
d668 1
a668 1
      xasprintf (&legacy_name, "%s-packet", name);
@


1.136
log
@2004-05-25  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Add from_tty to
	to_create_inferior.
	(target_create_inferior, find_default_create_inferior): Update.
	* infcmd.c (run_command): Update.
	* wince.c (child_create_inferior): Update.
	* win32-nat.c (child_create_inferior): Update.
	* uw-thread.c (uw_thread_create_inferior): Update.
	* thread-db.c (thread_db_create_inferior): Update.
	* target.c (debug_to_create_inferior)
	(find_default_create_inferior): Update.
	(maybe_kill_then_create_inferior): Update.
	* sol-thread.c (sol_thread_create_inferior): Update.
	* remote.c (extended_remote_async_create_inferior)
	(extended_remote_create_inferior): Update.
	* remote-vx.c (vx_create_inferior): Update.
	* remote-st.c (st2000_create_inferior): Update.
	* remote-sim.c (gdbsim_create_inferior): Update.
	* remote-sds.c (sds_create_inferior): Update.
	* remote-rdp.c (remote_rdp_create_inferior): Update.
	* remote-rdi.c (arm_rdi_create_inferior): Update.
	* remote-m32r-sdi.c (m32r_create_inferior): Update.
	* remote-e7000.c (e7000_create_inferior): Update.
	* procfs.c (procfs_create_inferior): Update.
	* ocd.c (ocd_create_inferior): Update.
	* ocd.h (ocd_create_inferior): Update.
	* nto-procfs.c (procfs_create_inferior): Update.
	* monitor.c (monitor_create_inferior): Update.
	* lin-lwp.c (lin_lwp_create_inferior): Update.
	* inftarg.c (child_create_inferior): Update.
	* hpux-thread.c (hpux_thread_create_inferior): Update.
	* gnu-nat.c (gnu_create_inferior): Update.
@
text
@d4732 1
a4732 1
      size = bfd_get_section_size_before_reloc (s);
@


1.135
log
@2004-05-09  Andrew Cagney  <cagney@@redhat.com>

	* remote-vx.c (net_step): Delete step-range code.
	* remote.c (remote_resume, init_all_packet_configs)
	(set_remote_protocol_E_packet_cmd)
	(show_remote_protocol_E_packet_cmd)
	(remote_protocol_E, show_remote_cmd, _initialize_remote)
	(remote_protocol_e, set_remote_protocol_e_packet_cmd)
	(show_remote_protocol_e_packet_cmd): Ditto.
@
text
@a109 3
static void extended_remote_create_inferior (char *, char *, char **);
static void extended_remote_async_create_inferior (char *, char *, char **);

d4246 2
a4247 1
extended_remote_create_inferior (char *exec_file, char *args, char **env)
d4269 2
a4270 1
extended_remote_async_create_inferior (char *exec_file, char *args, char **env)
@


1.134
log
@2004-04-26  Orjan Friberg <orjanf@@axis.com>

	From Paul Koning <pkoning@@equallogic.com>:
	* breakpoint.c (free_valchain): New function.
	(insert_bp_location, delete_breakpoint): Use free_valchain.
	(remove_breakpoint): Do not remove the valchain.
	(bpstat_stop_status): If not stopped by watchpoint, skip
	watchpoints when generating stop status list.
	* infrun.c (handle_inferior_event): Make
	stepped_after_stopped_by_watchpoint a global variable.
	* remote.c (remote_stopped_data_address): Return watch data
	address rather than zero if stepped_after_stopped_by_watchpoint is
	set.
@
text
@a776 36
/* Should we try the 'e' (step over range) request? */
static struct packet_config remote_protocol_e;

static void
set_remote_protocol_e_packet_cmd (char *args, int from_tty,
				  struct cmd_list_element *c)
{
  update_packet_config (&remote_protocol_e);
}

static void
show_remote_protocol_e_packet_cmd (char *args, int from_tty,
				   struct cmd_list_element *c)
{
  show_packet_config_cmd (&remote_protocol_e);
}


/* Should we try the 'E' (step over range / w signal #) request? */
static struct packet_config remote_protocol_E;

static void
set_remote_protocol_E_packet_cmd (char *args, int from_tty,
				  struct cmd_list_element *c)
{
  update_packet_config (&remote_protocol_E);
}

static void
show_remote_protocol_E_packet_cmd (char *args, int from_tty,
				   struct cmd_list_element *c)
{
  show_packet_config_cmd (&remote_protocol_E);
}


a2043 2
  update_packet_config (&remote_protocol_e);
  update_packet_config (&remote_protocol_E);
a2529 54
  /* The s/S/c/C packets do not return status.  So if the target does
     not support the S or C packets, the debug agent returns an empty
     string which is detected in remote_wait().  This protocol defect
     is fixed in the e/E packets. */

  if (step && step_range_end)
    {
      /* If the target does not support the 'E' packet, we try the 'S'
	 packet.  Ideally we would fall back to the 'e' packet if that
	 too is not supported.  But that would require another copy of
	 the code to issue the 'e' packet (and fall back to 's' if not
	 supported) in remote_wait().  */

      if (siggnal != TARGET_SIGNAL_0)
	{
	  if (remote_protocol_E.support != PACKET_DISABLE)
	    {
	      p = buf;
	      *p++ = 'E';
	      *p++ = tohex (((int) siggnal >> 4) & 0xf);
	      *p++ = tohex (((int) siggnal) & 0xf);
	      *p++ = ',';
	      p += hexnumstr (p, (ULONGEST) step_range_start);
	      *p++ = ',';
	      p += hexnumstr (p, (ULONGEST) step_range_end);
	      *p++ = 0;

	      putpkt (buf);
	      getpkt (buf, (rs->remote_packet_size), 0);

	      if (packet_ok (buf, &remote_protocol_E) == PACKET_OK)
		return;
	    }
	}
      else
	{
	  if (remote_protocol_e.support != PACKET_DISABLE)
	    {
	      p = buf;
	      *p++ = 'e';
	      p += hexnumstr (p, (ULONGEST) step_range_start);
	      *p++ = ',';
	      p += hexnumstr (p, (ULONGEST) step_range_end);
	      *p++ = 0;

	      putpkt (buf);
	      getpkt (buf, (rs->remote_packet_size), 0);

	      if (packet_ok (buf, &remote_protocol_e) == PACKET_OK)
		return;
	    }
	}
    }

a5332 2
  show_remote_protocol_e_packet_cmd (args, from_tty, NULL);
  show_remote_protocol_E_packet_cmd (args, from_tty, NULL);
a5515 22

  add_packet_config_cmd (&remote_protocol_e,
			 "e", "step-over-range",
			 set_remote_protocol_e_packet_cmd,
			 show_remote_protocol_e_packet_cmd,
			 &remote_set_cmdlist, &remote_show_cmdlist,
			 0);
  /* Disable by default.  The ``e'' packet has nasty interactions with
     the threading code - it relies on global state.  */
  remote_protocol_e.detect = AUTO_BOOLEAN_FALSE;
  update_packet_config (&remote_protocol_e);

  add_packet_config_cmd (&remote_protocol_E,
			 "E", "step-over-range-w-signal",
			 set_remote_protocol_E_packet_cmd,
			 show_remote_protocol_E_packet_cmd,
			 &remote_set_cmdlist, &remote_show_cmdlist,
			 0);
  /* Disable by default.  The ``e'' packet has nasty interactions with
     the threading code - it relies on global state.  */
  remote_protocol_E.detect = AUTO_BOOLEAN_FALSE;
  update_packet_config (&remote_protocol_E);
@


1.133
log
@2004-04-21  Andrew Cagney  <cagney@@redhat.com>

	* annotate.h (deprecated_annotate_starting_hook)
	(deprecated_annotate_stopped_hook)
	(deprecated_annotate_exited_hook)
	(deprecated_annotate_signal_hook)
	(deprecated_annotate_signalled_hook): Deprecate.
	* tracepoint.h (deprecated_create_tracepoint_hook)
	(deprecated_delete_tracepoint_hook)
	(deprecated_modify_tracepoint_hook)
	(deprecated_trace_find_hook)
	(deprecated_trace_start_stop_hook): Deprecate.
	* target.h (deprecated_target_new_objfile_hook): Deprecate.
	* remote.h (deprecated_target_resume_hook)
	(deprecated_target_wait_loop_hook): Deprecate.
	* gdbcore.h (deprecated_exec_file_display_hook)
	(deprecated_file_changed_hook): Deprecate.
	* frame.h (deprecated_selected_frame_level_changed_hook): Deprecate.
	* defs.h (deprecated_modify_breakpoint_hook)
	(deprecated_command_loop_hook, deprecated_show_load_progress)
	(deprecated_print_frame_info_listing_hook)
	(deprecated_query_hook, deprecated_warning_hook)
	(deprecated_flush_hook, deprecated_create_breakpoint_hook)
	(deprecated_delete_breakpoint_hook)
	(deprecated_interactive_hook, deprecated_registers_changed_hook)
	(deprecated_readline_begin_hook, deprecated_readline_hook)
	(deprecated_readline_end_hook, deprecated_register_changed_hook)
	(deprecated_memory_changed_hook, deprecated_init_ui_hook)
	(deprecated_context_hook, deprecated_target_wait_hook)
	(deprecated_attach_hook, deprecated_detach_hook)
	(deprecated_call_command_hook, deprecated_set_hook)
	(deprecated_error_hook, deprecated_error_begin_hook)
	(deprecated_ui_load_progress_hook): Deprecate.
	* valops.c, uw-thread.c, utils.c, tui/tui-io.c: Update.
	* tui/tui-hooks.c, tracepoint.c, top.c, thread-db.c: Update.
	* target.c, symfile.c, stack.c, sol-thread.c, rs6000-nat.c: Update.
	* remote.c, remote-mips.c, regcache.c, mi/mi-interp.c: Update.
	* main.c, interps.c, infcmd.c, hpux-thread.c, frame.c: Update.
	* exec.c, dsrec.c, d10v-tdep.c, corefile.c, complaints.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, breakpoint.c: Update.
	* annotate.c, aix-thread.c: Update.
@
text
@d4643 2
d4648 2
a4649 1
  if (remote_stopped_by_watchpoint ())
@


1.132
log
@	* remote.c (remote_open_1): Reopen the exec file and reread symbols
	if necessary.
@
text
@d1009 2
a1010 2
void (*target_resume_hook) (void);
void (*target_wait_loop_hook) (void);
d2555 2
a2556 2
  if (target_resume_hook)
    (*target_resume_hook) ();
d2886 2
a2887 2
      if (target_wait_loop_hook)
	(*target_wait_loop_hook) ();
d3077 2
a3078 2
      if (target_wait_loop_hook)
	(*target_wait_loop_hook) ();
d5482 2
a5483 2
  remote_new_objfile_chain = target_new_objfile_hook;
  target_new_objfile_hook  = remote_new_objfile;
@


1.131
log
@2004-03-15  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (gdbarch_data_pre_init_fytpe)
	(gdbarch_data_register_pre_init, gdbarch_data_post_init_fytpe)
	(gdbarch_data_register_post_init): Replace gdbarch_data_init_ftype
	and register_gdbarch_data.
	(deprecated_set_gdbarch_data): Rename set_gdbarch_data.
	(struct gdbarch_data): Replace "init" by "pre_init" and
	"post_init".
	* gdbarch.h, gdbarch.c: Re-generate.
	* dwarf2-frame.c (dwarf2_frame_init): Replace "gdbarch" paramter
	with"obstack", use OBSTACK_ZALLOC.
	(dwarf2_frame_ops): Delete.
	(dwarf2_frame_set_init_reg): Use gdbarch_data.
	(dwarf2_frame_init_reg): Use gdbarch_data.
	(_initialize_dwarf2_frame): Use gdbarch_data_register_pre_init.
	* solib-svr4.c (set_solib_svr4_fetch_link_map_offsets)
	(_initialize_svr4_solib): Update.
	* user-regs.c (_initialize_user_regs): Update.
	* reggroups.c (_initialize_reggroup): Update.
	* regcache.c (_initialize_regcache): Update.
	* mips-linux-tdep.c (_initialize_mips_linux_tdep): Update.
	* libunwind-frame.c (_initialize_libunwind_frame): Update.
	* gnu-v3-abi.c (init_gnuv3_ops): Update.
	* frame-unwind.c (_initialize_frame_unwind): Update.
	* frame-base.c (_initialize_frame_base): Update.
	* user-regs.c (user_reg_add): Update.
	* reggroups.c (reggroup_add): Update.
	* mips-linux-tdep.c (set_mips_linux_register_addr): Update.
	* libunwind-frame.c (libunwind_frame_set_descr): Update.
	* frame-unwind.c (frame_unwind_append_sniffer): Update.
	* frame-base.c (frame_base_table): Update.
	* remote.c (_initialize_remote): Update.
	* gdb_obstack.h (OBSTACK_ZALLOC, OBSTACK_CALLOC): Define.
@
text
@d2167 3
@


1.130
log
@2004-02-25  Roland McGrath  <roland@@redhat.com>

	* remote.c (remote_protocol_qPart_auxv): New variable.
	(init_all_packet_configs): Initialize it.
	(set_remote_protocol_qPart_auxv_packet_cmd): New function.
	(show_remote_protocol_qPart_auxv_packet_cmd): New function.
	(show_remote_cmd): Call it.
	(_initialize_remote): Initialize commands.
	(remote_xfer_partial): If enabled, use qPart:auxv:read:... query to
	service TARGET_OBJECT_AUXV requests.
@
text
@d5459 1
a5459 1
  remote_gdbarch_data_handle = register_gdbarch_data (init_remote_state);
@


1.130.4.1
log
@Jumbo patch.  Experiments with tramp-frame.
@
text
@d5459 1
a5459 1
  remote_gdbarch_data_handle = register_gdbarch_data (NULL, init_remote_state);
@


1.130.4.2
log
@Dump of tramp-frame stuff.
@
text
@d5459 1
a5459 1
  remote_gdbarch_data_handle = gdbarch_data_register_post_init (init_remote_state);
@


1.129
log
@2004-02-15  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (deprecated_register_gdbarch_swap): Rename
	register_gdbarch_swap.
	(DEPRECATED_REGISTER_GDBARCH_SWAP): Rename REGISTER_GDBARCH_SWAP.
	* f-lang.c (_initialize_f_language): Update, use
	DEPRECATED_REGISTER_GDBARCH_SWAP.
	* remote.c (_initialize_remote): Ditto.
	* regcache.c (_initialize_regcache): Ditto.
	* parse.c (_initialize_parse): Ditto.
	* infrun.c (_initialize_infrun): Ditto.
	* mi/mi-main.c (_initialize_mi_main): Ditto.
	* gdbtypes.c (_initialize_gdbtypes): Ditto.
@
text
@d295 1
a295 1
  
d793 1
a793 1
  
d811 1
a811 1
  
d963 1
a963 1
   This is an auto-detect variable (set to true at each connect, 
d984 17
d1475 1
a1475 1
#define TAG_MOREDISPLAY 16	/* Whatever the kernel wants to say about 
d1763 2
a1764 2
/* Find new threads for info threads command.  
 * Original version, using John Metzler's thread protocol.  
d1800 1
a1800 1
	{	
d1824 1
a1824 1
/* 
d1829 1
a1829 1
 * 
d1989 1
a1989 1
  offs = ((struct section_offsets *) 
d1991 1
a1991 1
  memcpy (offs, symfile_objfile->section_offsets, 
d2090 1
d2124 1
a2124 1
	sprintf (msg, "qSymbol:%s:%s", 
d2204 1
a2204 1
  
d2280 2
a2281 2
  /* FIXME: need a master target_open vector from which all 
     remote_opens can be called, so that stuff like this can 
d2283 1
a2283 1
     to the open function for any remote target that wants to 
d2577 1
a2577 1
      
d2859 1
a2859 1
   Returns "pid", which in the case of a multi-threaded 
d2917 1
a2917 1
		   and set p1 to point to the character following it. 
d2929 1
a2929 1
		else 
d3106 1
a3106 1
		   and set p1 to point to the character following it. 
d3111 1
a3111 1
		
d3118 1
a3118 1
		else 
d3149 1
a3149 1
		
d3550 1
a3550 1
	
d3558 1
a3558 1
	
d3640 1
a3640 1
  
d3647 1
a3647 1
  
d3657 1
a3657 1
  
d3686 1
a3686 1
	  /* Escape chars have filled up the buffer prematurely, 
d3707 1
a3707 1
  
d3710 1
a3710 1
  
d3720 1
a3720 1
  
d4072 1
a4072 1
	    
d4113 1
a4113 1
	    if (repeat > 0 && repeat <= 255 
d4314 1
a4314 1
     and the next time the user says "run" it'll fail. 
d4332 1
a4332 1
   a special create_inferior function. 
d4429 1
a4429 1
#endif  
d4436 1
a4436 1
  
d4441 1
a4441 1
      
d4449 1
a4449 1
      
d4464 1
a4464 1
#ifdef DEPRECATED_REMOTE_BREAKPOINT  
d4493 1
a4493 1
      
d4502 1
a4502 1
      
d4548 1
a4548 1
  
d4554 1
a4554 1
  
d4583 1
a4583 1
  
d4656 1
a4656 1
      
d4660 1
a4660 1
  BREAKPOINT_FROM_PC (&addr, &len);  
d4666 1
a4666 1
  
d4670 1
a4670 1
  
d4691 1
a4691 1
static int 
d4708 1
a4708 1
  
d4712 1
a4712 1
  
d4719 1
a4719 1
  
d4893 35
d5425 1
d5666 7
@


1.129.2.1
log
@Merge mainline to intercu branch.
@
text
@d295 1
a295 1

d793 1
a793 1

d811 1
a811 1

d963 1
a963 1
   This is an auto-detect variable (set to true at each connect,
a983 17
/* Should we try the 'qPart:auxv' (target auxiliary vector read) request? */
static struct packet_config remote_protocol_qPart_auxv;

static void
set_remote_protocol_qPart_auxv_packet_cmd (char *args, int from_tty,
					   struct cmd_list_element *c)
{
  update_packet_config (&remote_protocol_qPart_auxv);
}

static void
show_remote_protocol_qPart_auxv_packet_cmd (char *args, int from_tty,
					    struct cmd_list_element *c)
{
  show_packet_config_cmd (&remote_protocol_qPart_auxv);
}

d1458 1
a1458 1
#define TAG_MOREDISPLAY 16	/* Whatever the kernel wants to say about
d1746 2
a1747 2
/* Find new threads for info threads command.
 * Original version, using John Metzler's thread protocol.
d1783 1
a1783 1
	{
d1807 1
a1807 1
/*
d1812 1
a1812 1
 *
d1972 1
a1972 1
  offs = ((struct section_offsets *)
d1974 1
a1974 1
  memcpy (offs, symfile_objfile->section_offsets,
a2072 1
  update_packet_config (&remote_protocol_qPart_auxv);
d2106 1
a2106 1
	sprintf (msg, "qSymbol:%s:%s",
a2148 3
  reopen_exec_file ();
  reread_symbols ();

d2186 1
a2186 1

d2262 2
a2263 2
  /* FIXME: need a master target_open vector from which all
     remote_opens can be called, so that stuff like this can
d2265 1
a2265 1
     to the open function for any remote target that wants to
d2559 1
a2559 1

d2841 1
a2841 1
   Returns "pid", which in the case of a multi-threaded
d2899 1
a2899 1
		   and set p1 to point to the character following it.
d2911 1
a2911 1
		else
d3088 1
a3088 1
		   and set p1 to point to the character following it.
d3093 1
a3093 1

d3100 1
a3100 1
		else
d3131 1
a3131 1

d3532 1
a3532 1

d3540 1
a3540 1

d3622 1
a3622 1

d3629 1
a3629 1

d3639 1
a3639 1

d3668 1
a3668 1
	  /* Escape chars have filled up the buffer prematurely,
d3689 1
a3689 1

d3692 1
a3692 1

d3702 1
a3702 1

d4054 1
a4054 1

d4095 1
a4095 1
	    if (repeat > 0 && repeat <= 255
d4296 1
a4296 1
     and the next time the user says "run" it'll fail.
d4314 1
a4314 1
   a special create_inferior function.
d4411 1
a4411 1
#endif
d4418 1
a4418 1

d4423 1
a4423 1

d4431 1
a4431 1

d4446 1
a4446 1
#ifdef DEPRECATED_REMOTE_BREAKPOINT
d4475 1
a4475 1

d4484 1
a4484 1

d4530 1
a4530 1

d4536 1
a4536 1

d4565 1
a4565 1

d4638 1
a4638 1

d4642 1
a4642 1
  BREAKPOINT_FROM_PC (&addr, &len);
d4648 1
a4648 1

d4652 1
a4652 1

d4673 1
a4673 1
static int
d4690 1
a4690 1

d4694 1
a4694 1

d4701 1
a4701 1

a4874 35

    case TARGET_OBJECT_AUXV:
      if (remote_protocol_qPart_auxv.support != PACKET_DISABLE)
	{
	  unsigned int total = 0;
	  while (len > 0)
	    {
	      LONGEST n = min ((rs->remote_packet_size - 2) / 2, len);
	      snprintf (buf2, rs->remote_packet_size,
			"qPart:auxv:read::%s,%s",
			phex_nz (offset, sizeof offset),
			phex_nz (n, sizeof n));
	      i = putpkt (buf2);
	      if (i < 0)
		return total > 0 ? total : i;
	      buf2[0] = '\0';
	      getpkt (buf2, rs->remote_packet_size, 0);
	      if (packet_ok (buf2, &remote_protocol_qPart_auxv) != PACKET_OK)
		return total > 0 ? total : -1;
	      if (buf2[0] == 'O' && buf2[1] == 'K' && buf2[2] == '\0')
		break;		/* Got EOF indicator.  */
	      /* Got some data.  */
	      i = hex2bin (buf2, readbuf, len);
	      if (i > 0)
		{
		  readbuf = (void *) ((char *) readbuf + i);
		  offset += i;
		  len -= i;
		  total += i;
		}
	    }
	  return total;
	}
      return -1;

a5371 1
  show_remote_protocol_qPart_auxv_packet_cmd (args, from_tty, NULL);
d5405 1
a5405 1
  remote_gdbarch_data_handle = gdbarch_data_register_post_init (init_remote_state);
a5611 7
			 &remote_set_cmdlist, &remote_show_cmdlist,
			 0);

  add_packet_config_cmd (&remote_protocol_qPart_auxv,
			 "qPart_auxv", "read-aux-vector",
			 set_remote_protocol_qPart_auxv_packet_cmd,
			 show_remote_protocol_qPart_auxv_packet_cmd,
@


1.129.2.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d46 3
d110 3
d214 1
a214 1
  /* long size in bytes;  == register_size (current_gdbarch, regnum); at present.  */
d256 2
a257 2
  if (deprecated_register_bytes () != 0)
    rs->sizeof_g_packet = deprecated_register_bytes ();
d274 1
a274 1
      if (deprecated_register_bytes () == 0)
a651 2
  char *help_doc;
  char *print;
d657 4
a660 6
  set_doc = xstrprintf ("Set use of remote protocol `%s' (%s) packet",
			name, title);
  show_doc = xstrprintf ("Show current use of remote protocol `%s' (%s) packet",
			 name, title);
  print = xstrprintf ("Current use of remote protocol `%s' (%s) is %%s",
		      name, title);
d662 1
a662 1
  cmd_name = xstrprintf ("%s-packet", title);
a664 1
				"", print,
d671 1
a671 1
      legacy_name = xstrprintf ("%s-packet", name);
d777 36
d1009 2
a1010 2
void (*deprecated_target_resume_hook) (void);
void (*deprecated_target_wait_loop_hook) (void);
d2080 2
d2555 2
a2556 2
  if (deprecated_target_resume_hook)
    (*deprecated_target_resume_hook) ();
d2568 54
d2648 1
a2648 1
  if (target_can_async_p ())
d2886 2
a2887 2
      if (deprecated_target_wait_loop_hook)
	(*deprecated_target_wait_loop_hook) ();
d2977 1
a2977 1
		    fieldsize = hex2bin (p, regs, register_size (current_gdbarch, reg->regnum));
d2979 1
a2979 1
		    if (fieldsize < register_size (current_gdbarch, reg->regnum))
d2981 1
a2981 1
		    regcache_raw_supply (current_regcache, reg->regnum, regs);
d3077 2
a3078 2
      if (deprecated_target_wait_loop_hook)
	(*deprecated_target_wait_loop_hook) ();
d3165 1
a3165 1
		    fieldsize = hex2bin (p, regs, register_size (current_gdbarch, reg->regnum));
d3167 1
a3167 1
		    if (fieldsize < register_size (current_gdbarch, reg->regnum))
d3169 1
a3169 1
		    regcache_raw_supply (current_regcache, reg->regnum, regs);
d3395 2
a3396 2
  regcache_raw_collect (current_regcache, reg->regnum, regp);
  bin2hex (regp, p, register_size (current_gdbarch, reg->regnum));
d3456 1
a3456 1
	  regcache_raw_collect (current_regcache, r->regnum, regs + r->offset);
d4341 1
a4341 2
extended_remote_create_inferior (char *exec_file, char *args, char **env,
				 int from_tty)
d4363 1
a4363 2
extended_remote_async_create_inferior (char *exec_file, char *args, char **env,
				       int from_tty)
d4371 1
a4371 1
  if (target_can_async_p ())
a4642 2
extern int stepped_after_stopped_by_watchpoint;

d4646 1
a4646 2
  if (remote_stopped_by_watchpoint ()
      || stepped_after_stopped_by_watchpoint)
d4822 1
a4822 1
      size = bfd_get_section_size (s);
d5422 2
d5482 2
a5483 2
  remote_new_objfile_chain = deprecated_target_new_objfile_hook;
  deprecated_target_new_objfile_hook  = remote_new_objfile;
d5518 3
a5520 5
  add_setshow_boolean_cmd ("remotebreak", no_class, &remote_break, "\
Set whether to send break if interrupted.", "\
Show whether to send break if interrupted.", "\
If set, a break, instead of a cntrl-c, is sent to the remote target.", "\
Whether to send break if interrupted is %s.",
d5557 3
a5559 4
  add_setshow_zinteger_cmd ("hardware-watchpoint-limit", no_class,
			    &remote_hw_watchpoint_limit, "\
Set the maximum number of target hardware watchpoints.", "\
Show the maximum number of target hardware watchpoints.", "\
d5561 5
a5565 7
The maximum number of target hardware watchpoints is %s.",
			    NULL, NULL,
			    &remote_set_cmdlist, &remote_show_cmdlist);
  add_setshow_zinteger_cmd ("hardware-breakpoint-limit", no_class,
			    &remote_hw_breakpoint_limit, "\
Set the maximum number of target hardware breakpoints.", "\
Show the maximum number of target hardware breakpoints.", "\
d5567 2
a5568 3
The maximum number of target hardware breakpoints is %s.",
			    NULL, NULL,
			    &remote_set_cmdlist, &remote_show_cmdlist);
d5570 1
a5570 1
  deprecated_add_show_from_set
d5587 1
a5587 1
  deprecated_add_show_from_set
d5608 22
d5682 2
a5683 5
Set use of remote protocol `Z' packets", "\
Show use of remote protocol `Z' packets ", "\
When set, GDB will attempt to use the remote breakpoint and watchpoint\n\
packets.", "\
Use of remote protocol `Z' packets is %s",
@


1.128
log
@Index: ChangeLog
2004-01-26  Andrew Cagney  <cagney@@redhat.com>

	* remote.c (echo_check, quit_flag): Delete variables.
	(cisco_kernel_mode): Delete variable.
	(minitelnet_return, tty_input, escape_count): Delete variables.
	(remote_cisco_mode): Delete variable.
	(remote_cisco_open, remote_cisco_close): Delete function.
	(remote_cisco_mourn, remote_cisco_wait): Delete function.
	(init_remote_cisco_ops): Delete function.
	(_initialize_remote): Do not install "remote cisco" code.
	(read_frame): Delete cisco specific code.
	(remote_info_process): Delete function.
	(remote_wait): Delete cisco specific code.
	(remote_cisco_section_offsets): Delete function.
	(remote_cisco_objfile_relocate): Delete function.
	(remote_async_wait): Delete cisco specific code.
	(minitelnet, readtty, readsocket): Delete function.

Index: doc/ChangeLog
2004-01-26  Andrew Cagney  <cagney@@redhat.com>

	* gdb.texinfo (Overview): Delete references to the cisco protocol
	including the "N" response.
@
text
@d5409 2
a5410 3
  register_gdbarch_swap (&remote_address_size, 
                         sizeof (&remote_address_size), NULL);
  register_gdbarch_swap (NULL, 0, build_remote_gdbarch_data);
@


1.127
log
@2004-01-18  Andrew Cagney  <cagney@@redhat.com>

	* remote-sds.c (tohex): Delete unused function.  Update copyright.
	* xstormy16-tdep.c (xstormy16_register_virtual_size): Ditto.
	* v850-tdep.c (v850_register_virtual_size): Ditto.
	* target.c (normal_target_post_startup_inferior): Ditto.
	* source.c (ambiguous_line_spec): Ditto.
	* remote.c (adapt_remote_get_threadinfo): Ditto.
	* mi/mi-out.c (out_field_fmt): Ditto.
	* mi/mi-interp.c (mi_interp_read_one_line_hook): Ditto.
	(output_control_change_notification): Ditto.
	* m68k-tdep.c (m68k_register_byte): Ditto.
	(m68k_remote_breakpoint_from_pc): Ditto.
	* ui-out.c (init_ui_out_state): Delete unused declaration.
	* stabsread.c (search_value): Ditto.
	* mi/mi-cmd-env.c (env_cli_command): Ditto.
	* maint.c (print_section_table): Ditto.
	* infrun.c (set_follow_fork_mode_command): Ditto.
@
text
@a154 4
static void init_remote_cisco_ops (void);

static struct target_ops remote_cisco_ops;

a371 4
/* This is set by the target (thru the 'S' message)
   to denote that the target is in kernel mode.  */
static int cisco_kernel_mode = 0;

a1988 117
/*
 * Cisco version of section offsets:
 *
 * Instead of having GDB query the target for the section offsets,
 * Cisco lets the target volunteer the information!  It's also in
 * a different format, so here are the functions that will decode
 * a section offset packet from a Cisco target.
 */

/* 
 * Function: remote_cisco_section_offsets
 *
 * Returns:  zero for success, non-zero for failure 
 */

static int
remote_cisco_section_offsets (bfd_vma text_addr,
			      bfd_vma data_addr,
			      bfd_vma bss_addr,
			      bfd_signed_vma *text_offs,
			      bfd_signed_vma *data_offs,
			      bfd_signed_vma *bss_offs)
{
  bfd_vma text_base, data_base, bss_base;
  struct minimal_symbol *start;
  asection *sect;
  bfd *abfd;
  int len;

  if (symfile_objfile == NULL)
    return -1;			/* no can do nothin' */

  start = lookup_minimal_symbol ("_start", NULL, NULL);
  if (start == NULL)
    return -1;			/* Can't find "_start" symbol */

  data_base = bss_base = 0;
  text_base = SYMBOL_VALUE_ADDRESS (start);

  abfd = symfile_objfile->obfd;
  for (sect = abfd->sections;
       sect != 0;
       sect = sect->next)
    {
      const char *p = bfd_get_section_name (abfd, sect);
      len = strlen (p);
      if (strcmp (p + len - 4, "data") == 0)	/* ends in "data" */
	if (data_base == 0 ||
	    data_base > bfd_get_section_vma (abfd, sect))
	  data_base = bfd_get_section_vma (abfd, sect);
      if (strcmp (p + len - 3, "bss") == 0)	/* ends in "bss" */
	if (bss_base == 0 ||
	    bss_base > bfd_get_section_vma (abfd, sect))
	  bss_base = bfd_get_section_vma (abfd, sect);
    }
  *text_offs = text_addr - text_base;
  *data_offs = data_addr - data_base;
  *bss_offs = bss_addr - bss_base;
  if (remote_debug)
    {
      char tmp[128];

      sprintf (tmp, "VMA:          text = 0x");
      sprintf_vma (tmp + strlen (tmp), text_addr);
      sprintf (tmp + strlen (tmp), " data = 0x");
      sprintf_vma (tmp + strlen (tmp), data_addr);
      sprintf (tmp + strlen (tmp), " bss = 0x");
      sprintf_vma (tmp + strlen (tmp), bss_addr);
      fputs_filtered (tmp, gdb_stdlog);
      fprintf_filtered (gdb_stdlog,
			"Reloc offset: text = 0x%s data = 0x%s bss = 0x%s\n",
			paddr_nz (*text_offs),
			paddr_nz (*data_offs),
			paddr_nz (*bss_offs));
    }

  return 0;
}

/*
 * Function: remote_cisco_objfile_relocate
 *
 * Relocate the symbol file for a remote target. 
 */

void
remote_cisco_objfile_relocate (bfd_signed_vma text_off, bfd_signed_vma data_off,
			       bfd_signed_vma bss_off)
{
  struct section_offsets *offs;

  if (text_off != 0 || data_off != 0 || bss_off != 0)
    {
      /* FIXME: This code assumes gdb-stabs.h is being used; it's
         broken for xcoff, dwarf, sdb-coff, etc.  But there is no
         simple canonical representation for this stuff.  */

      offs = (struct section_offsets *) 
	alloca (SIZEOF_N_SECTION_OFFSETS (symfile_objfile->num_sections));
      memcpy (offs, symfile_objfile->section_offsets, 
	      SIZEOF_N_SECTION_OFFSETS (symfile_objfile->num_sections));

      offs->offsets[SECT_OFF_TEXT (symfile_objfile)] = text_off;
      offs->offsets[SECT_OFF_DATA (symfile_objfile)] = data_off;
      offs->offsets[SECT_OFF_BSS (symfile_objfile)] = bss_off;

      /* First call the standard objfile_relocate.  */
      objfile_relocate (symfile_objfile, offs);

      /* Now we need to fix up the section entries already attached to
         the exec target.  These entries will control memory transfers
         from the exec file.  */

      exec_set_section_offsets (text_off, data_off, bss_off);
    }
}

a2974 7
	      /* Export Cisco kernel mode as a convenience variable
	         (so that it can be used in the GDB prompt if desired). */

	      if (cisco_kernel_mode == 1)
		set_internalvar (lookup_internalvar ("cisco_kernel_mode"),
				 value_from_string ("PDEBUG-"));
	      cisco_kernel_mode = 0;
a2977 10
	  else if (buf[3] == 'k')
	    {
	      /* Export Cisco kernel mode as a convenience variable
	         (so that it can be used in the GDB prompt if desired). */

	      if (cisco_kernel_mode == 1)
		set_internalvar (lookup_internalvar ("cisco_kernel_mode"),
				 value_from_string ("KDEBUG-"));
	      cisco_kernel_mode = 1;
	    }
a2978 43
	case 'N':		/* Cisco special: status and offsets */
	  {
	    bfd_vma text_addr, data_addr, bss_addr;
	    bfd_signed_vma text_off, data_off, bss_off;
	    unsigned char *p1;

	    status->kind = TARGET_WAITKIND_STOPPED;
	    status->value.sig = (enum target_signal)
	      (((fromhex (buf[1])) << 4) + (fromhex (buf[2])));

	    if (symfile_objfile == NULL)
	      {
		warning ("Relocation packet received with no symbol file.  \
Packet Dropped");
		goto got_status;
	      }

	    /* Relocate object file.  Buffer format is NAATT;DD;BB
	     * where AA is the signal number, TT is the new text
	     * address, DD * is the new data address, and BB is the
	     * new bss address.  */

	    p = &buf[3];
	    text_addr = strtoul (p, (char **) &p1, 16);
	    if (p1 == p || *p1 != ';')
	      warning ("Malformed relocation packet: Packet '%s'", buf);
	    p = p1 + 1;
	    data_addr = strtoul (p, (char **) &p1, 16);
	    if (p1 == p || *p1 != ';')
	      warning ("Malformed relocation packet: Packet '%s'", buf);
	    p = p1 + 1;
	    bss_addr = strtoul (p, (char **) &p1, 16);
	    if (p1 == p)
	      warning ("Malformed relocation packet: Packet '%s'", buf);

	    if (remote_cisco_section_offsets (text_addr, data_addr, bss_addr,
					      &text_off, &data_off, &bss_off)
		== 0)
	      if (text_off != 0 || data_off != 0 || bss_off != 0)
		remote_cisco_objfile_relocate (text_off, data_off, bss_off);

	    goto got_status;
	  }
a3163 7
	      /* Export Cisco kernel mode as a convenience variable
	         (so that it can be used in the GDB prompt if desired). */

	      if (cisco_kernel_mode == 1)
		set_internalvar (lookup_internalvar ("cisco_kernel_mode"),
				 value_from_string ("PDEBUG-"));
	      cisco_kernel_mode = 0;
a3166 10
	  else if (buf[3] == 'k')
	    {
	      /* Export Cisco kernel mode as a convenience variable
	         (so that it can be used in the GDB prompt if desired). */

	      if (cisco_kernel_mode == 1)
		set_internalvar (lookup_internalvar ("cisco_kernel_mode"),
				 value_from_string ("KDEBUG-"));
	      cisco_kernel_mode = 1;
	    }
a3167 43
	case 'N':		/* Cisco special: status and offsets */
	  {
	    bfd_vma text_addr, data_addr, bss_addr;
	    bfd_signed_vma text_off, data_off, bss_off;
	    unsigned char *p1;

	    status->kind = TARGET_WAITKIND_STOPPED;
	    status->value.sig = (enum target_signal)
	      (((fromhex (buf[1])) << 4) + (fromhex (buf[2])));

	    if (symfile_objfile == NULL)
	      {
		warning ("Relocation packet recieved with no symbol file.  \
Packet Dropped");
		goto got_status;
	      }

	    /* Relocate object file.  Buffer format is NAATT;DD;BB
	     * where AA is the signal number, TT is the new text
	     * address, DD * is the new data address, and BB is the
	     * new bss address.  */

	    p = &buf[3];
	    text_addr = strtoul (p, (char **) &p1, 16);
	    if (p1 == p || *p1 != ';')
	      warning ("Malformed relocation packet: Packet '%s'", buf);
	    p = p1 + 1;
	    data_addr = strtoul (p, (char **) &p1, 16);
	    if (p1 == p || *p1 != ';')
	      warning ("Malformed relocation packet: Packet '%s'", buf);
	    p = p1 + 1;
	    bss_addr = strtoul (p, (char **) &p1, 16);
	    if (p1 == p)
	      warning ("Malformed relocation packet: Packet '%s'", buf);

	    if (remote_cisco_section_offsets (text_addr, data_addr, bss_addr,
					      &text_off, &data_off, &bss_off)
		== 0)
	      if (text_off != 0 || data_off != 0 || bss_off != 0)
		remote_cisco_objfile_relocate (text_off, data_off, bss_off);

	    goto got_status;
	  }
a4007 2
static int remote_cisco_mode;

d4089 3
a4091 18
	    if (remote_cisco_mode == 0)
	      {
		c = readchar (remote_timeout);
		csum += c;
		repeat = c - ' ' + 3;	/* Compute repeat count */
	      }
	    else 
	      { 
		/* Cisco's run-length encoding variant uses two 
		   hex chars to represent the repeat count. */

		c = readchar (remote_timeout);
		csum += c;
		repeat  = fromhex (c) << 4;
		c = readchar (remote_timeout);
		csum += c;
		repeat += fromhex (c);
	      }
a5228 403
/*
 * Command: info remote-process
 *
 * This implements Cisco's version of the "info proc" command.
 *
 * This query allows the target stub to return an arbitrary string
 * (or strings) giving arbitrary information about the target process.
 * This is optional; the target stub isn't required to implement it.
 *
 * Syntax: qfProcessInfo        request first string
 *         qsProcessInfo        request subsequent string
 * reply:  'O'<hex-encoded-string>
 *         'l'                  last reply (empty)
 */

static void
remote_info_process (char *args, int from_tty)
{
  struct remote_state *rs = get_remote_state ();
  char *buf = alloca (rs->remote_packet_size);

  if (remote_desc == 0)
    error ("Command can only be used when connected to the remote target.");

  putpkt ("qfProcessInfo");
  getpkt (buf, (rs->remote_packet_size), 0);
  if (buf[0] == 0)
    return;			/* Silently: target does not support this feature. */

  if (buf[0] == 'E')
    error ("info proc: target error.");

  while (buf[0] == 'O')		/* Capitol-O packet */
    {
      remote_console_output (&buf[1]);
      putpkt ("qsProcessInfo");
      getpkt (buf, (rs->remote_packet_size), 0);
    }
}

/*
 * Target Cisco 
 */

static void
remote_cisco_open (char *name, int from_tty)
{
  int ex;
  if (name == 0)
    error ("To open a remote debug connection, you need to specify what \n"
	   "device is attached to the remote system (e.g. host:port).");

  /* See FIXME above */
  wait_forever_enabled_p = 1;

  target_preopen (from_tty);

  unpush_target (&remote_cisco_ops);

  remote_desc = remote_serial_open (name);
  if (!remote_desc)
    perror_with_name (name);

  /*
   * If a baud rate was specified on the gdb  command line it will
   * be greater than the initial value of -1.  If it is, use it otherwise
   * default to 9600
   */

  baud_rate = (baud_rate > 0) ? baud_rate : 9600;
  if (serial_setbaudrate (remote_desc, baud_rate))
    {
      /* The requested speed could not be set.  Error out to
	 top level after closing remote_desc.  Take care to
	 set remote_desc to NULL to avoid closing remote_desc
	 more than once.  */
      serial_close (remote_desc);
      remote_desc = NULL;
      perror_with_name (name);
    }

  serial_raw (remote_desc);

  /* If there is something sitting in the buffer we might take it as a
     response to a command, which would be bad.  */
  serial_flush_input (remote_desc);

  if (from_tty)
    {
      puts_filtered ("Remote debugging using ");
      puts_filtered (name);
      puts_filtered ("\n");
    }

  remote_cisco_mode = 1;

  push_target (&remote_cisco_ops);	/* Switch to using cisco target now */

  init_all_packet_configs ();

  general_thread = -2;
  continue_thread = -2;

  /* Probe for ability to use "ThreadInfo" query, as required.  */
  use_threadinfo_query = 1;
  use_threadextra_query = 1;
  
  /* Without this, some commands which require an active target (such
     as kill) won't work.  This variable serves (at least) double duty
     as both the pid of the target process (if it has such), and as a
     flag indicating that a target is active.  These functions should
     be split out into seperate variables, especially since GDB will
     someday have a notion of debugging several processes.  */
  inferior_ptid = pid_to_ptid (MAGIC_NULL_PID);

  /* Start the remote connection; if error, discard this target.  See
     the comments in remote_open_1() for further details such as the
     need to re-throw the exception.  */
  ex = catch_exceptions (uiout,
			 remote_start_remote_dummy, NULL,
			 "Couldn't establish connection to remote"
			 " target\n",
			 RETURN_MASK_ALL);
  if (ex < 0)
    {
      pop_target ();
      throw_exception (ex);
    }
}

static void
remote_cisco_close (int quitting)
{
  remote_cisco_mode = 0;
  remote_close (quitting);
}

static void
remote_cisco_mourn (void)
{
  remote_mourn_1 (&remote_cisco_ops);
}

enum
{
  READ_MORE,
  FATAL_ERROR,
  ENTER_DEBUG,
  DISCONNECT_TELNET
}
minitelnet_return;

/* Shared between readsocket() and readtty().  The size is arbitrary,
   however all targets are known to support a 400 character packet.  */
static char tty_input[400];

static int escape_count;
static int echo_check;
extern int quit_flag;

static int
readsocket (void)
{
  int data;

  /* Loop until the socket doesn't have any more data */

  while ((data = readchar (0)) >= 0)
    {
      /* Check for the escape sequence */
      if (data == '|')
	{
	  /* If this is the fourth escape, get out */
	  if (++escape_count == 4)
	    {
	      return ENTER_DEBUG;
	    }
	  else
	    {			/* This is a '|', but not the fourth in a row. 
				   Continue without echoing it.  If it isn't actually 
				   one of four in a row, it'll be echoed later.  */
	      continue;
	    }
	}
      else
	/* Not a '|' */
	{
	  /* Ensure any pending '|'s are flushed.  */

	  for (; escape_count > 0; escape_count--)
	    putchar ('|');
	}

      if (data == '\r')		/* If this is a return character, */
	continue;		/*  - just supress it. */

      if (echo_check != -1)	/* Check for echo of user input.  */
	{
	  if (tty_input[echo_check] == data)
	    {
	      gdb_assert (echo_check <= sizeof (tty_input));
	      echo_check++;	/* Character matched user input: */
	      continue;		/* Continue without echoing it.  */
	    }
	  else if ((data == '\n') && (tty_input[echo_check] == '\r'))
	    {			/* End of the line (and of echo checking).  */
	      echo_check = -1;	/* No more echo supression */
	      continue;		/* Continue without echoing.  */
	    }
	  else
	    {			/* Failed check for echo of user input.
				   We now have some suppressed output to flush!  */
	      int j;

	      for (j = 0; j < echo_check; j++)
		putchar (tty_input[j]);
	      echo_check = -1;
	    }
	}
      putchar (data);		/* Default case: output the char.  */
    }

  if (data == SERIAL_TIMEOUT)	/* Timeout returned from readchar.  */
    return READ_MORE;		/* Try to read some more */
  else
    return FATAL_ERROR;		/* Trouble, bail out */
}

static int
readtty (void)
{
  int tty_bytecount;

  /* First, read a buffer full from the terminal */
  tty_bytecount = read (fileno (stdin), tty_input, sizeof (tty_input) - 1);
  if (tty_bytecount == -1)
    {
      perror ("readtty: read failed");
      return FATAL_ERROR;
    }

  /* Remove a quoted newline.  */
  if (tty_input[tty_bytecount - 1] == '\n' &&
      tty_input[tty_bytecount - 2] == '\\')	/* line ending in backslash */
    {
      tty_input[--tty_bytecount] = 0;	/* remove newline */
      tty_input[--tty_bytecount] = 0;	/* remove backslash */
    }

  /* Turn trailing newlines into returns */
  if (tty_input[tty_bytecount - 1] == '\n')
    tty_input[tty_bytecount - 1] = '\r';

  /* If the line consists of a ~, enter debugging mode.  */
  if ((tty_input[0] == '~') && (tty_bytecount == 2))
    return ENTER_DEBUG;

  /* Make this a zero terminated string and write it out */
  tty_input[tty_bytecount] = 0;
  if (serial_write (remote_desc, tty_input, tty_bytecount))
    {
      perror_with_name ("readtty: write failed");
      return FATAL_ERROR;
    }

  return READ_MORE;
}

static int
minitelnet (void)
{
  fd_set input;			/* file descriptors for select */
  int tablesize;		/* max number of FDs for select */
  int status;
  int quit_count = 0;

  escape_count = 0;
  echo_check = -1;

  tablesize = 8 * sizeof (input);

  for (;;)
    {
      /* Check for anything from our socket - doesn't block. Note that
         this must be done *before* the select as there may be
         buffered I/O waiting to be processed.  */

      if ((status = readsocket ()) == FATAL_ERROR)
	{
	  error ("Debugging terminated by communications error");
	}
      else if (status != READ_MORE)
	{
	  return (status);
	}

      fflush (stdout);		/* Flush output before blocking */

      /* Now block on more socket input or TTY input */

      FD_ZERO (&input);
      FD_SET (fileno (stdin), &input);
      FD_SET (deprecated_serial_fd (remote_desc), &input);

      status = select (tablesize, &input, 0, 0, 0);
      if ((status == -1) && (errno != EINTR))
	{
	  error ("Communications error on select %d", errno);
	}

      /* Handle Control-C typed */

      if (quit_flag)
	{
	  if ((++quit_count) == 2)
	    {
	      if (query ("Interrupt GDB? "))
		{
		  printf_filtered ("Interrupted by user.\n");
		  throw_exception (RETURN_QUIT);
		}
	      quit_count = 0;
	    }
	  quit_flag = 0;

	  if (remote_break)
	    serial_send_break (remote_desc);
	  else
	    serial_write (remote_desc, "\003", 1);

	  continue;
	}

      /* Handle console input */

      if (FD_ISSET (fileno (stdin), &input))
	{
	  quit_count = 0;
	  echo_check = 0;
	  status = readtty ();
	  if (status == READ_MORE)
	    continue;

	  return status;	/* telnet session ended */
	}
    }
}

static ptid_t
remote_cisco_wait (ptid_t ptid, struct target_waitstatus *status)
{
  if (minitelnet () != ENTER_DEBUG)
    {
      error ("Debugging session terminated by protocol error");
    }
  putpkt ("?");
  return remote_wait (ptid, status);
}

static void
init_remote_cisco_ops (void)
{
  remote_cisco_ops.to_shortname = "cisco";
  remote_cisco_ops.to_longname = "Remote serial target in cisco-specific protocol";
  remote_cisco_ops.to_doc =
    "Use a remote machine via TCP, using a cisco-specific protocol.\n\
Specify the serial device it is connected to (e.g. host:2020).";
  remote_cisco_ops.to_open = remote_cisco_open;
  remote_cisco_ops.to_close = remote_cisco_close;
  remote_cisco_ops.to_detach = remote_detach;
  remote_cisco_ops.to_disconnect = remote_disconnect;
  remote_cisco_ops.to_resume = remote_resume;
  remote_cisco_ops.to_wait = remote_cisco_wait;
  remote_cisco_ops.to_fetch_registers = remote_fetch_registers;
  remote_cisco_ops.to_store_registers = remote_store_registers;
  remote_cisco_ops.to_prepare_to_store = remote_prepare_to_store;
  remote_cisco_ops.to_xfer_memory = remote_xfer_memory;
  remote_cisco_ops.to_files_info = remote_files_info;
  remote_cisco_ops.to_insert_breakpoint = remote_insert_breakpoint;
  remote_cisco_ops.to_remove_breakpoint = remote_remove_breakpoint;  
  remote_cisco_ops.to_remove_hw_breakpoint = remote_remove_hw_breakpoint;
  remote_cisco_ops.to_insert_hw_breakpoint = remote_insert_hw_breakpoint;
  remote_cisco_ops.to_insert_watchpoint = remote_insert_watchpoint;
  remote_cisco_ops.to_remove_watchpoint = remote_remove_watchpoint;
  remote_cisco_ops.to_stopped_by_watchpoint = remote_stopped_by_watchpoint;
  remote_cisco_ops.to_stopped_data_address = remote_stopped_data_address;
  remote_cisco_ops.to_can_use_hw_breakpoint = remote_check_watch_resources;
  remote_cisco_ops.to_kill = remote_kill;
  remote_cisco_ops.to_load = generic_load;
  remote_cisco_ops.to_mourn_inferior = remote_cisco_mourn;
  remote_cisco_ops.to_thread_alive = remote_thread_alive;
  remote_cisco_ops.to_find_new_threads = remote_threads_info;
  remote_cisco_ops.to_pid_to_str = remote_pid_to_str;
  remote_cisco_ops.to_extra_thread_info = remote_threads_extra_info;
  remote_cisco_ops.to_stratum = process_stratum;
  remote_cisco_ops.to_has_all_memory = 1;
  remote_cisco_ops.to_has_memory = 1;
  remote_cisco_ops.to_has_stack = 1;
  remote_cisco_ops.to_has_registers = 1;
  remote_cisco_ops.to_has_execution = 1;
  remote_cisco_ops.to_magic = OPS_MAGIC;
}

a5424 3
  init_remote_cisco_ops ();
  add_target (&remote_cisco_ops);

a5536 3

  add_info ("remote-process", remote_info_process,
	    "Query the remote system for process info.");
@


1.126
log
@	* remote.c: Update copyright years.
@
text
@a1164 4
static int adapt_remote_get_threadinfo (gdb_threadref * ref,
					int selection,
					struct gdb_ext_thread_info *info);

a1573 13
}

/* Unfortunately, 61 bit thread-ids are bigger than the internal
   representation of a threadid.  */

static int
adapt_remote_get_threadinfo (gdb_threadref *ref, int selection,
			     struct gdb_ext_thread_info *info)
{
  threadref lclref;

  int_to_threadref (&lclref, *ref);
  return remote_get_threadinfo (&lclref, selection, info);
@


1.125
log
@	* remote.c (remote_vcont_resume): Use xstrprintf instead of sprintf.
@
text
@d4 2
a5 1
   1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
@


1.124
log
@	* remote.c (remote_open_1, remote_cisco_open): Avoid closing
	remote_desc more than once.
@
text
@d2586 1
a2586 1
  char *buf = NULL;
d2611 1
a2611 1
	sprintf (buf, "vCont;S%02x", siggnal);
d2613 1
a2613 1
	sprintf (buf, "vCont;s");
d2615 1
a2615 1
	sprintf (buf, "vCont;C%02x", siggnal);
d2617 1
a2617 1
	sprintf (buf, "vCont;c");
d2623 2
a2624 1
	sprintf (buf, "vCont;S%02x:%x;c", siggnal, PIDGET (inferior_ptid));
d2626 1
a2626 1
	sprintf (buf, "vCont;s:%x;c", PIDGET (inferior_ptid));
d2628 2
a2629 1
	sprintf (buf, "vCont;C%02x:%x;c", siggnal, PIDGET (inferior_ptid));
d2631 1
a2631 1
	sprintf (buf, "vCont;c");
d2637 1
a2637 1
	sprintf (buf, "vCont;S%02x:%x", siggnal, pid);
d2639 1
a2639 1
	sprintf (buf, "vCont;s:%x", pid);
d2641 1
a2641 1
	sprintf (buf, "vCont;C%02x:%x", siggnal, pid);
d2643 1
a2643 1
	sprintf (buf, "vCont;c:%x", pid);
d2646 4
a2649 1
  putpkt (buf);
@


1.123
log
@2003-12-06  Andrew Cagney  <cagney@@redhat.com>

	* remote.c (remote_fetch_registers): For short packets, explicitly
	supply a zero value.  Use regcache_raw_supply.  Fix suggested by
	Jonathan Larmour.
@
text
@d2302 4
d2307 1
d5574 4
d5579 1
@


1.122
log
@2003-11-10  Andrew Cagney  <cagney@@redhat.com>

	* target.h (struct target_ops): Order xfer buffer parameters "read
	write" not "write read".
	* bfd-target.c (target_bfd_xfer_partial): Update.
	* remote.c (remote_xfer_partial): Update.
	* inftarg.c (child_xfer_partial): Update.
	* target.c (default_xfer_partial): Update.
	(target_read_partial, target_write_partial): Update.
	(debug_to_xfer_partial): Update.
@
text
@d3561 17
a3577 3
	    supply_register (r->regnum, regs + r->offset);
	    if (buf[r->offset * 2] == 'x')
	      set_register_cached (i, -1);
@


1.121
log
@2003-10-31  Andrew Cagney  <cagney@@redhat.com>

	* target.h (struct target_ops): Replace "to_read_partial" and
	"to_write_partial" with "to_xfer_partial".  Update comments.
	* target.c (debug_to_write_partial): Delete function.
	(debug_to_xfer_partial): Replace debug_to_read_partial.
	(add_target, update_current_target, setup_target_debug): Set
	"to_xfer_partial" instead of "to_read_partial" and
	"to_write_partial".
	(default_xfer_partial): Replace "default_write_partial".
	(default_read_partial): Delete.
	(target_read_partial, target_write_partial): Call
	"to_xfer_partial".
	* remote.c (init_remote_ops): Set "to_xfer_partial".
	(init_remote_async_ops): Ditto.
	(remote_xfer_partial): Replace "remote_read_partial".
@
text
@d5106 1
a5106 1
		     const char *annex, const void *writebuf, void *readbuf,
@


1.120
log
@Index: mi/ChangeLog
2003-10-24  Andrew Cagney  <cagney@@redhat.com>

	* tui-out.c: Fix "fortunatly"[sic].

Index: doc/ChangeLog
2003-10-24  Andrew Cagney  <cagney@@redhat.com>

	* annotate.texinfo: Fix "fortunatly"[sic].

2003-10-24  Andrew Cagney  <cagney@@redhat.com>

	* osabi.c (gdbarch_init_osabi): Fix typos, and "fortunatly"[sic].
	* PROBLEMS, arch-utils.c, cli-out.c, command.h: Ditto.
	* complaints.c, cris-tdep.c, disasm.c, dwarf2-frame.c: Ditto.
	* frame.c, frame.h, infcall.c, infcmd.c, infrun.c: Ditto.
	* kod.c, mips-tdep.c, regcache.c, regcache.h, remote.c: Ditto.
@
text
@d5105 2
a5106 2
remote_read_partial (struct target_ops *ops, enum target_object object,
		     const char *annex, void *buf,
d5115 4
d5133 1
a5133 1
  /* Note: a zero BUF, OFFSET and LEN can be used to query the minimum
d5135 1
a5135 1
  if (buf == NULL && offset == 0 && len == 0)
d5148 1
a5148 1
  gdb_assert (buf != NULL);
d5172 1
a5172 1
  getpkt (buf, len, 0);
d5174 1
a5174 1
  return strlen (buf);
d5452 1
a5452 1
  remote_ops.to_read_partial = remote_read_partial;
d5972 1
a5972 1
  remote_async_ops.to_read_partial = remote_read_partial;
@


1.119
log
@2003-10-17  Andrew Cagney  <cagney@@redhat.com>

	* target.h (struct target_ops): Add "to_read_partial" and
	"to_write_partial", delete "to_query".
	(target_read_partial, target_write_partial): Declare.
	(target_read, target_write): Declare.
	(target_query): Delete macro.
	* target.c (target_read_partial): New function.
	(target_write_partial, target_read, target_write): New function.
	(update_current_target): Delete inheritance of "to_query".  Add
	comments about "to_read_partial" and "to_write_partial".
	(debug_to_partial_read, debug_to_partial_write): New functions.
	(debug_to_query): Delete function.
	(setup_target_debug): Set "to_read_partial" and "to_write_partial"
	instead of "to_query".
	* remote.c (remote_read_partial): Replace "remote_query".
	(init_remote_ops): Set "to_read_partial" instead of "to_query".
	(init_remote_async_ops): Ditto.
	* kod.c (gdb_kod_query): Make "bufsize" a LONGEST.  Use
	"target_read_partial" instead of "target_query".
	* avr-tdep.c (avr_io_reg_read_command): Make "bufsize" a LONGEST.
	Use "target_read_partial" instead of "target_query".
@
text
@d207 1
a207 1
   Unfortunatly, the target stack doesn't include local state.  For
d2368 1
a2368 1
     caller restore the previous state.  Unfortunatly the command
@


1.118
log
@	* remote.c (remote_protocol_vcont): New variable.
	(set_remote_protocol_vcont_packet_cmd): New function.
	(show_remote_protocol_vcont_packet_cmd): New function.
	(init_all_packet_configs): Handle remote_protocol_vcont.
	(remote_vcont_probe): New function.
	(remote_vcont_resume): New function.
	(remote_resume): Use it.
	(remote_async_resume): Call remote_resume.
	(_initialize_remote): Add verbose-resume packet commands.
@
text
@a163 2
static int remote_query (int /*char */ , char *, char *, int *);

d5104 4
a5107 2
static int
remote_query (int query_type, char *buf, char *outbuf, int *bufsiz)
d5113 1
d5115 3
a5117 7
  if (!bufsiz)
    error ("null pointer to remote bufer size specified");

  /* minimum outbuf size is (rs->remote_packet_size) - if bufsiz is not large enough let 
     the caller know and return what the minimum size is   */
  /* Note: a zero bufsiz can be used to query the minimum buffer size */
  if (*bufsiz < (rs->remote_packet_size))
d5119 7
a5125 1
      *bufsiz = (rs->remote_packet_size);
d5129 10
d5143 2
a5144 11
  /* we only take uppercase letters as query types, at least for now */
  if ((query_type < 'A') || (query_type > 'Z'))
    error ("invalid remote query type");

  if (!buf)
    error ("null remote query specified");

  if (!outbuf)
    error ("remote query requires a buffer to receive data");

  outbuf[0] = '\0';
d5154 1
a5154 1
  while (buf[i] && (i < ((rs->remote_packet_size) - 8)))
d5156 3
a5158 5
      /* bad caller may have sent forbidden characters */
      if ((!isprint (buf[i])) || (buf[i] == '$') || (buf[i] == '#'))
	error ("illegal characters in query string");

      *p2++ = buf[i];
d5161 2
a5162 4
  *p2 = buf[i];

  if (buf[i])
    error ("query larger than available buffer");
d5168 1
a5168 1
  getpkt (outbuf, *bufsiz, 0);
d5170 1
a5170 1
  return 0;
d5448 1
a5448 1
  remote_ops.to_query = remote_query;
d5968 1
a5968 1
  remote_async_ops.to_query = remote_query;
@


1.117
log
@2003-10-15  Andrew Cagney  <cagney@@redhat.com>

	* remote.c (remote_search): Delete function.
	* target.h (target_search): Delete disabled macro.
	(struct target_ops): Delete disabled field "to_search".
@
text
@d752 17
d2210 1
d2524 2
a2525 5
/* Tell the remote machine to resume.  */

static enum target_signal last_sent_signal = TARGET_SIGNAL_0;

static int last_sent_step;
d2528 1
a2528 1
remote_resume (ptid_t ptid, int step, enum target_signal siggnal)
d2530 3
a2532 4
  struct remote_state *rs = get_remote_state ();
  char *buf = alloca (rs->remote_packet_size);
  int pid = PIDGET (ptid);
  char *p;
d2534 5
a2538 4
  if (pid == -1)
    set_thread (0, 0);		/* run any thread */
  else
    set_thread (pid, 0);	/* run this thread */
d2540 15
a2554 2
  last_sent_signal = siggnal;
  last_sent_step = step;
d2556 2
a2557 4
  /* A hook for when we need to do something at the last moment before
     resumption.  */
  if (target_resume_hook)
    (*target_resume_hook) ();
d2559 5
d2565 9
a2573 4
  /* The s/S/c/C packets do not return status.  So if the target does
     not support the S or C packets, the debug agent returns an empty
     string which is detected in remote_wait().  This protocol defect
     is fixed in the e/E packets. */
d2575 2
a2576 21
  if (step && step_range_end)
    {
      /* If the target does not support the 'E' packet, we try the 'S'
	 packet.  Ideally we would fall back to the 'e' packet if that
	 too is not supported.  But that would require another copy of
	 the code to issue the 'e' packet (and fall back to 's' if not
	 supported) in remote_wait().  */
      
      if (siggnal != TARGET_SIGNAL_0)
	{
	  if (remote_protocol_E.support != PACKET_DISABLE)
	    {
	      p = buf;
	      *p++ = 'E';
	      *p++ = tohex (((int) siggnal >> 4) & 0xf);
	      *p++ = tohex (((int) siggnal) & 0xf);
	      *p++ = ',';
	      p += hexnumstr (p, (ULONGEST) step_range_start);
	      *p++ = ',';
	      p += hexnumstr (p, (ULONGEST) step_range_end);
	      *p++ = 0;
d2578 7
a2584 2
	      putpkt (buf);
	      getpkt (buf, (rs->remote_packet_size), 0);
d2586 2
a2587 14
	      if (packet_ok (buf, &remote_protocol_E) == PACKET_OK)
		return;
	    }
	}
      else
	{
	  if (remote_protocol_e.support != PACKET_DISABLE)
	    {
	      p = buf;
	      *p++ = 'e';
	      p += hexnumstr (p, (ULONGEST) step_range_start);
	      *p++ = ',';
	      p += hexnumstr (p, (ULONGEST) step_range_end);
	      *p++ = 0;
d2589 2
a2590 2
	      putpkt (buf);
	      getpkt (buf, (rs->remote_packet_size), 0);
d2592 4
a2595 4
	      if (packet_ok (buf, &remote_protocol_e) == PACKET_OK)
		return;
	    }
	}
d2598 19
a2616 1
  if (siggnal != TARGET_SIGNAL_0)
d2618 9
a2626 4
      buf[0] = step ? 'S' : 'C';
      buf[1] = tohex (((int) siggnal >> 4) & 0xf);
      buf[2] = tohex (((int) siggnal) & 0xf);
      buf[3] = '\0';
d2629 11
a2639 1
    strcpy (buf, step ? "s" : "c");
d2642 4
d2648 6
a2653 1
/* Same as remote_resume, but with async support. */
d2655 1
a2655 1
remote_async_resume (ptid_t ptid, int step, enum target_signal siggnal)
a2661 5
  if (pid == -1)
    set_thread (0, 0);		/* run any thread */
  else
    set_thread (pid, 0);	/* run this thread */

d2670 10
d2711 1
a2711 1
		goto register_event_loop;
d2729 1
a2729 1
		goto register_event_loop;
d2738 1
a2738 1
      buf[2] = tohex ((int) siggnal & 0xf);
d2743 1
a2743 1
  
d2745 7
a2752 1
register_event_loop:
d6018 1
d6191 7
@


1.116
log
@2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_RAW_SIZE): Rename
	REGISTER_RAW_SIZE.
	* gdbarch.h, gdbarch.c: Re-generate.
	* aix-thread.c, alpha-tdep.h, arm-tdep.c, core-sol2.c: Update.
	* cris-tdep.c, dve3900-rom.c, findvar.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, ia64-tdep.c, infcmd.c, infptrace.c: Update.
	* infrun.c, irix5-nat.c, lynx-nat.c, mips-linux-tdep.c: Update.
	* mips-nat.c, mips-tdep.c, mipsv4-nat.c, mn10300-tdep.c: Update.
	* monitor.c, ns32k-tdep.c, ppc-linux-nat.c, regcache.c: Update.
	* remote-e7000.c, remote-mips.c, remote-sim.c: Update.
	* remote-vxmips.c, remote-vxsparc.c, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, rs6000-tdep.c, s390-tdep.c: Update.
	* sh64-tdep.c, sparc-nat.c, sparc-tdep.c, stack.c: Update.
	* target.c, tracepoint.c, v850-tdep.c, v850ice.c, valops.c: Update.
	* vax-tdep.c, vax-tdep.h, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-vx68.h: Update.
	* config/sparc/tm-sparc.h, config/sparc/tm-sparclynx.h: Update.

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	REGISTER_RAW_SIZE to DEPRECATED_REGISTER_RAW_SIZE.
	* gdb.texinfo (Packets, Stop Reply Packets): Ditto.
	* gdbint.texinfo (Target Architecture Definition): Rename

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c: Rename REGISTER_RAW_SIZE to
	DEPRECATED_REGISTER_RAW_SIZE.
@
text
@a3991 67

#if 0
/* Enable after 4.12.  */

void
remote_search (int len, char *data, char *mask, CORE_ADDR startaddr,
	       int increment, CORE_ADDR lorange, CORE_ADDR hirange,
	       CORE_ADDR *addr_found, char *data_found)
{
  if (increment == -4 && len == 4)
    {
      long mask_long, data_long;
      long data_found_long;
      CORE_ADDR addr_we_found;
      char *buf = alloca (rs->remote_packet_size);
      long returned_long[2];
      char *p;

      mask_long = extract_unsigned_integer (mask, len);
      data_long = extract_unsigned_integer (data, len);
      sprintf (buf, "t%x:%x,%x", startaddr, data_long, mask_long);
      putpkt (buf);
      getpkt (buf, (rs->remote_packet_size), 0);
      if (buf[0] == '\0')
	{
	  /* The stub doesn't support the 't' request.  We might want to
	     remember this fact, but on the other hand the stub could be
	     switched on us.  Maybe we should remember it only until
	     the next "target remote".  */
	  generic_search (len, data, mask, startaddr, increment, lorange,
			  hirange, addr_found, data_found);
	  return;
	}

      if (buf[0] == 'E')
	/* There is no correspondance between what the remote protocol uses
	   for errors and errno codes.  We would like a cleaner way of
	   representing errors (big enough to include errno codes, bfd_error
	   codes, and others).  But for now just use EIO.  */
	memory_error (EIO, startaddr);
      p = buf;
      addr_we_found = 0;
      while (*p != '\0' && *p != ',')
	addr_we_found = (addr_we_found << 4) + fromhex (*p++);
      if (*p == '\0')
	error ("Protocol error: short return for search");

      data_found_long = 0;
      while (*p != '\0' && *p != ',')
	data_found_long = (data_found_long << 4) + fromhex (*p++);
      /* Ignore anything after this comma, for future extensions.  */

      if (addr_we_found < lorange || addr_we_found >= hirange)
	{
	  *addr_found = 0;
	  return;
	}

      *addr_found = addr_we_found;
      *data_found = store_unsigned_integer (data_we_found, len);
      return;
    }
  generic_search (len, data, mask, startaddr, increment, lorange,
		  hirange, addr_found, data_found);
}
#endif /* 0 */

@


1.115
log
@2003-09-20  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.c: Eliminate ARGSUSED.
	* buildsym.c, cli/cli-cmds.c, cli/cli-script.c: Ditto.
	* coffread.c, corelow.c, dwarf2read.c, event-top.c: Ditto.
	* exec.c, gcore.c, hpux-thread.c, infcmd.c, inflow.c: Ditto.
	* infrun.c, inftarg.c, maint.c, ocd.c, printcmd.c: Ditto.
	* procfs.c, regcache.c, remote-rdi.c, remote-sds.c: Ditto.
	* remote.c, sol-thread.c, source.c, stabsread.c: Ditto.
	* stack.c, symfile.c, target.c, top.c, typeprint.c: Ditto.
	* utils.c, v850ice.c, valprint.c, values.c, win32-nat.c: Ditto.
	* wince.c, remote-vx.c: Ditto.
@
text
@d219 1
a219 1
  /* long size in bytes;  == REGISTER_RAW_SIZE (regnum); at present.  */
d3026 1
a3026 1
		    fieldsize = hex2bin (p, regs, REGISTER_RAW_SIZE (reg->regnum));
d3028 1
a3028 1
		    if (fieldsize < REGISTER_RAW_SIZE (reg->regnum))
d3274 1
a3274 1
		    fieldsize = hex2bin (p, regs, REGISTER_RAW_SIZE (reg->regnum));
d3276 1
a3276 1
		    if (fieldsize < REGISTER_RAW_SIZE (reg->regnum))
d3551 1
a3551 1
  bin2hex (regp, p, REGISTER_RAW_SIZE (reg->regnum));
@


1.114
log
@2003-09-17  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_BYTE): Rename REGISTER_BYTE.
	* gdbarch.h, gdbarch.c: Regenerate.
	* arm-linux-tdep.c, core-sol2.c, cris-tdep.c: Update.
	* d10v-tdep.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, irix5-nat.c, lynx-nat.c, m68knbsd-nat.c: Update.
	* mcore-tdep.c, mips-linux-tdep.c, mips-tdep.c: Update.
	* mipsv4-nat.c, mn10300-tdep.c, ns32k-tdep.c: Update.
	* ns32knbsd-nat.c, ppc-bdm.c, regcache.c, remote-sds.c: Update.
	* remote-vx68.c, remote-vxmips.c, remote-vxsparc.c: Update.
	* remote.c, rs6000-tdep.c, s390-tdep.c, sh64-tdep.c: Update.
	* sparc-nat.c, sparc-tdep.c, sun3-nat.c, v850-tdep.c: Update.
	* v850ice.c, vax-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-cisco.h, config/m68k/tm-delta68.h: Update.
	* config/pa/nm-hppah.h: Update.

2003-09-17  Andrew Cagney  <cagney@@redhat.com>

	* mi/mi-main.c: Rename REGISTER_BYTE to DEPRECATED_REGISTER_BYTE.
@
text
@a1905 1
/* ARGSUSED */
a3414 1
/* ARGSUSED */
a3967 1
/* ARGSUSED */
@


1.113
log
@2003-08-04  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (gdbarch_data_free_ftype): Delete declaration.
	(register_gdbarch_data): Delete "free" parameter.  Update
	comments.
	* gdbarch.h, gdbarch.c: Re-generate.
	* reggroups.c (_initialize_reggroup): Update.
	* gnu-v3-abi.c (init_gnuv3_ops): Update.
	* frame-base.c (_initialize_frame_base): Update.
	* frame-unwind.c (_initialize_frame_unwind): Update.
	* user-regs.c (_initialize_user_regs): Update.
	* remote.c (_initialize_remote): Update.
	* regcache.c (_initialize_regcache): Update.
@
text
@d274 1
a274 1
      r->offset = REGISTER_BYTE (regnum);
@


1.112
log
@2003-08-04  Andrew Cagney  <cagney@@redhat.com>

	* remote.c (free_remote_state): Delete function.
	(_initialize_remote): Update register_gdbarch_data.
	(init_remote_state): Use GDBARCH_OBSTACK_XALLOC and
	GDBARCH_OBSTACK_CALLOC instead of xmalloc / xcalloc.
@
text
@d6059 1
a6059 1
  remote_gdbarch_data_handle = register_gdbarch_data (init_remote_state, NULL);
@


1.111
log
@2003-08-04  David Carlton  <carlton@@kealia.com>

	* charset.c (cached_iconv_convert): Add __FILE__ and __LINE__ args
	to internal_error call.
	* source.c (forward_search_command): Add "%s" format argument.
	(reverse_search_command): Ditto.
	* top.c (quit_confirm): Ditto.
	* cli/cli-setshow.c (do_setshow_command): Ditto.
	* cp-valprint.c (cp_print_class_method): Replace
	{f,}printf_{un,}filtered by {f,}puts_{un,}filtered.
	(cp_print_class_member): Ditto.
	* event-top.c (command_line_handler): Ditto.
	* linux-proc.c (linux_info_proc_cmd): Ditto.
	* p-typeprint.c (pascal_type_print_base): Ditto.
	* p-valprint.c (pascal_object_print_class_method): Ditto.
	(pascal_object_print_class_member): Ditto.
	* printcmd.c (print_scalar_formatted,printf_command): Ditto.
	* remote.c (remote_cisco_section_offsets): Ditto.
	* top.c (command_line_input): Ditto.
	* utils.c (vwarning,error_stream,quit): Ditto.
	* valprint.c (print_floating,print_binary_chars)
	(print_octal_chars,print_decimal_chars,print_hex_chars): Ditto.

2003-08-04  David Carlton  <carlton@@kealia.com>

	* mi-main.c (mi_error_last_message): Add "%s" second argument to
	xasprintf call.

2003-08-04  David Carlton  <carlton@@kealia.com>

	* generic/gdbtk.c (gdbtk_source_start_file): Add "%s" first
	argument to error call.
	(tk_command): Ditto.
	(view_command): Ditto.
@
text
@d259 1
a259 1
  struct remote_state *rs = xmalloc (sizeof (struct remote_state));
d267 2
a268 1
  rs->regs = xcalloc (NUM_REGS + NUM_PSEUDO_REGS, sizeof (struct packet_reg));
a306 8
static void
free_remote_state (struct gdbarch *gdbarch, void *pointer)
{
  struct remote_state *data = pointer;
  xfree (data->regs);
  xfree (data);
}

d6059 1
a6059 2
  remote_gdbarch_data_handle = register_gdbarch_data (init_remote_state,
						      free_remote_state);
@


1.110
log
@2003-06-30  Andrew Cagney  <cagney@@redhat.com>

	* remote.c (remote_write_bytes): Explicitly compute and then use
	the payload size.  Update comments to reflect.  Fixes problem of
	GDB not sending small packets as found by Fred Fish.
@
text
@d2074 1
a2074 1
      fprintf_filtered (gdb_stdlog, tmp);
@


1.109
log
@2003-06-30  Andrew Cagney  <cagney@@redhat.com>

	* remote.c (remote_async_wait): Fix -Wformat problem.
@
text
@a3760 1
  int max_buf_size;		/* Max size of packet output buffer */
d3767 2
d3770 1
a3770 1
  /* Verify that the target can support a binary download */
d3773 3
a3775 3
  /* Determine the max packet size. */
  max_buf_size = get_memory_write_packet_size ();
  sizeof_buf = max_buf_size + 1; /* Space for trailing NUL */
d3778 5
a3782 2
  /* Subtract header overhead from max payload size -  $M<memaddr>,<len>:#nn */
  max_buf_size -= 2 + hexnumlen (memaddr + len - 1) + 1 + hexnumlen (len) + 4;
d3784 1
a3784 3
  /* construct "M"<memaddr>","<len>":" */
  /* sprintf (buf, "M%lx,%x:", (unsigned long) memaddr, todo); */
  p = buf;
d3786 1
a3786 1
  /* Append [XM].  Compute a best guess of the number of bytes
d3788 1
d3794 1
a3794 1
      todo = min (len, max_buf_size);
d3799 1
a3799 1
      todo = min (len, max_buf_size / 2);
d3808 1
a3808 1
  /* Append <memaddr> */
d3811 2
d3815 2
a3816 2
  /* Append <len>.  Retain the location/size of <len>.  It may
     need to be adjusted once the packet body has been created. */
d3820 2
d3825 2
a3826 1
  /* Append the packet body. */
d3834 1
a3834 1
	   (nr_bytes < todo) && (p - buf) < (max_buf_size - 2);
a3856 1
	  
@


1.108
log
@2003-06-29  Andrew Cagney  <cagney@@redhat.com>

	* remote.c (remote_wait): Call error, and not warning, when the
	packet is corrupt.
	(remote_async_wait): Ditto.
@
text
@d3290 2
a3291 1
		  error ("Remote register badly formatted: %s\nhere:", buf, p);
@


1.107
log
@gdb/
        * NEWS: Mention gdbserver detach change and "disconnect" command.
        * infcmd.c (disconnect_command): New function.
        (_initialize_infcmd): Add ``disconnect'' command.
        * remote.c (remote_async_detach): Delete.
        (remote_detach): Merge remote_async_detach.
        (remote_disconnect): New.
        (init_remote_ops): Set to_disconnect.
        (init_remote_cisco_ops): Likewise.
        (init_remote_async_ops): Likewise.  Use remote_detach.
        * target.c (cleanup_target): Default to_disconnect.
        (update_current_target): Inherit to_disconnect.
        (target_disconnect, debug_to_disconnect): New functions.
        (setup_target_debug): Set to_disconnect.
        * target.h (struct target_ops): Add to_disconnect.
        (target_disconnect): Add prototype.
gdbserver/
	* linux-low.c: Move comment to linux_thread_alive where it belonged.
	(linux_detach_one_process, linux_detach): New functions.
	(linux_target_ops): Add linux_detach.
	* server.c (main): Handle 'D' packet.
	* target.h (struct target_ops): Add "detach" member.
	(detach_inferior): Define.
mi/
        * mi-cmds.c (mi_cmds): Add "-target-disconnect".
@
text
@d3027 2
a3028 3
		      warning ("Malformed packet(b) (missing colon): %s\n\
Packet: '%s'\n",
			       p, buf);
d3031 2
a3032 3
		      warning ("Remote sent bad register number %s: %s\n\
Packet: '%s'\n",
			       phex_nz (pnum, 0), p, buf);
d3042 1
a3042 4
		  {
		    warning ("Remote register badly formatted: %s", buf);
		    warning ("            here: %s", p);
		  }
d3245 2
a3246 3
		      warning ("Malformed packet(a) (missing colon): %s\n\
Packet: '%s'\n",
			       p, buf);
d3275 2
a3276 3
		      warning ("Malformed packet(b) (missing colon): %s\n\
Packet: '%s'\n",
			       p, buf);
d3279 2
a3280 3
		      warning ("Remote sent bad register number %ld: %s\n\
Packet: '%s'\n",
			       pnum, p, buf);
d3290 1
a3290 4
		  {
		    warning ("Remote register badly formatted: %s", buf);
		    warning ("            here: %s", p);
		  }
@


1.107.2.1
log
@2003-06-29  Andrew Cagney  <cagney@@redhat.com>

	* remote.c (remote_wait): Call error, and not warning, when the
	packet is corrupt.
	(remote_async_wait): Ditto.
@
text
@d3027 3
a3029 2
		      error ("Malformed packet(b) (missing colon): %s\nPacket: '%s'\n",
			     p, buf);
d3032 3
a3034 2
		      error ("Remote sent bad register number %s: %s\nPacket: '%s'\n",
			     phex_nz (pnum, 0), p, buf);
d3044 4
a3047 1
		  error ("Remote register badly formatted: %s\nhere: %s", buf, p);
d3250 3
a3252 2
		      error ("Malformed packet(a) (missing colon): %s\nPacket: '%s'\n",
			     p, buf);
d3281 3
a3283 2
		      error ("Malformed packet(b) (missing colon): %s\nPacket: '%s'\n",
			     p, buf);
d3286 3
a3288 2
		      error ("Remote sent bad register number %ld: %s\nPacket: '%s'\n",
			     pnum, p, buf);
d3298 4
a3301 1
		  error ("Remote register badly formatted: %s\nhere:", buf, p);
@


1.107.2.2
log
@2003-06-30  Andrew Cagney  <cagney@@redhat.com>

	* remote.c (remote_async_wait): Fix -Wformat problem.
@
text
@d3290 1
a3290 2
		  error ("Remote register badly formatted: %s\nhere: %s",
			 buf, p);
@


1.107.2.3
log
@2003-06-30  Andrew Cagney  <cagney@@redhat.com>

	* remote.c (remote_write_bytes): Explicitly compute and then use
	the payload size.  Update comments to reflect.  Fixes problem of
	GDB not sending small packets as found by Fred Fish.
@
text
@d3761 1
a3767 2
  int payload_size;
  unsigned char *payload_start;
d3769 1
a3769 1
  /* Verify that the target can support a binary download.  */
d3772 3
a3774 3
  /* Compute the size, and then allocate space for the largest
     possible packet.  Include space for an extra trailing NUL.  */
  sizeof_buf = get_memory_write_packet_size () + 1;
d3777 2
a3778 5
  /* Compute the size of the actual payload by subtracting out the
     packet header and footer overhead: "$M<memaddr>,<len>:...#nn".  */
  payload_size = (get_memory_write_packet_size () - (strlen ("$M,:#NN")
						     + hexnumlen (memaddr)
						     + hexnumlen (len)));
d3780 3
a3782 1
  /* Construct the packet header: "[MX]<memaddr>,<len>:".   */
d3784 1
a3784 1
  /* Append "[XM]".  Compute a best guess of the number of bytes
a3785 1
  p = buf;
d3791 1
a3791 1
      todo = min (len, payload_size);
d3796 1
a3796 1
      todo = min (len, payload_size / 2);
d3805 1
a3805 1
  /* Append "<memaddr>".  */
a3807 2

  /* Append ",".  */
d3810 2
a3811 2
  /* Append <len>.  Retain the location/size of <len>.  It may need to
     be adjusted once the packet body has been created.  */
a3814 2

  /* Append ":".  */
d3818 1
a3818 2
  /* Append the packet body.  */
  payload_start = p;
d3826 1
a3826 1
	   (nr_bytes < todo) && (p - payload_start) < payload_size;
d3849 1
@


1.106
log
@	* remote.c (remote_prepare_to_store): Replace call to
	deprecated_read_register_bytes with multiple regcache_raw_read
	calls.
@
text
@a128 1
static void remote_async_detach (char *args, int from_tty);
d2423 4
d2430 1
d2432 1
a2432 1
}
a2433 1
/* Same as remote_detach, but with async support. */
d2435 1
a2435 1
remote_async_detach (char *args, int from_tty)
a2442 4
  /* Tell the remote target to detach.  */
  strcpy (buf, "D");
  remote_send (buf, (rs->remote_packet_size));

d5440 1
d5861 1
d5957 2
a5958 1
  remote_async_ops.to_detach = remote_async_detach;
@


1.105
log
@	* Makefile.in: Add dependencies for remote-fileio.o.
	* remote-fileio.c: New file implementing the remote File-I/O protocol.
	* remote-fileio.h: New header file defining remote File-I/O interface.
	* remote.c (remote_write_bytes, remote_read_bytes): Remove
	static storage class.
	(remote_wait, remote_async_wait): Call remote_fileio_request() on
	'F' packet.
	(_initialize_remote): Call initialize_remote_fileio().
	* remote.h: Declare remote_write_bytes() and remote_read_bytes().

	* Makefile.in (REMOTE_OBS): Add remote-fileio.o
	(SFILES): Add remote-fileio.c.
	Add dependencies for building remote-fileio.o.  Add remote-fileio.h to
	dependencies for building remote.o.
	* defs.h: Declare gdb_stdin, gdb_stdtargerr and gdb_stdtargin.
	* main.c: New ui_file gdb_stdin, gdb_stdtargerr and gdb_stdtargin.
	(captured_main): Initialize new ui_files.
	* ui-file.c: Add read and fgets input functions.
	(ui_file_new): set ui_file_fputs and ui_file_read to null functions.
	(null_file_read): New function.
	(ui_file_read): New function.
	(set_ui_file_read): New function.
	(stdio_file_read): New function.
	* ui-file.h: New type ui_file_read_ftype.
	(set_ui_file_read): Declare.
	(ui_file_read): Declare.
@
text
@d3535 4
d3544 4
a3547 5
      /* NOTE: This isn't rs->sizeof_g_packet because here, we are
         forcing the register cache to read its and not the target
         registers.  */
      deprecated_read_register_bytes (0, (char *) NULL,
				      DEPRECATED_REGISTER_BYTES); /* OK */
@


1.104
log
@2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	Deprecate BIG_REMOTE_BREAKPOINT, LITTLE_REMOTE_BREAKPOINT and
	REMOTE_BREAKPOINT.
	* remote.c: Update.
	* config/sh/tm-sh.h (DEPRECATED_BIG_REMOTE_BREAKPOINT): Update.
	(DEPRECATED_LITTLE_REMOTE_BREAKPOINT): Update.
	* config/m68k/tm-sun3.h: Update.
	* config/m68k/tm-m68klynx.h: Update.
	* config/h8300/tm-h8300.h (DEPRECATED_REMOTE_BREAKPOINT): Update.
@
text
@d58 2
a71 4
static int remote_write_bytes (CORE_ADDR memaddr, char *myaddr, int len);

static int remote_read_bytes (CORE_ADDR memaddr, char *myaddr, int len);

d2954 3
d3208 3
d3765 1
a3765 1
static int
d3909 1
a3909 1
static int
d6283 3
@


1.103
log
@2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* acinclude.m4 (gcc_AC_CHECK_DECL, (gcc_AC_CHECK_DECL): Stolen
	from GCC's acinclude.m4.
	* configure.in: Check for getopt's delcaration.
	* aclocal.m4, config.in, configure: Re-generate.
	* main.c (error_init): Delete declaration.
	* defs.h (error_init): Declare.
	* rs6000-tdep.c (rs6000_fetch_pointer_argument): Make static.
	(rs6000_convert_from_func_ptr_addr): Make static.
	(_initialize_rs6000_tdep): Add declaration.
	* cli/cli-cmds.c (dont_repeat): Delete declaration.
	(show_commands, set_verbose, show_history): Delete declaration.
	* top.h (set_verbose): Add declaration.
	(show_history, set_history, show_commands): Add declaration.
	(do_restore_instream_cleanup): Add declaration.
	* objc-lang.c (specialcmp): Make static.
	(print_object_command): Make static.
	(find_objc_msgsend): Make static.
	(find_objc_msgcall_submethod_helper): Make static.
	(find_objc_msgcall_submethod): Make static.
	(_initialize_objc_language): Add declaration.
	(find_implementation_from_class): Make static.
	(find_implementation): Make static.
	* objc-exp.y (yylex): Delete lookup_struct_typedef declaration.
	* objc-lang.h (lookup_struct_typedef): Add declaration.
	* cli/cli-interp.c (_initialize_cli_interp): Add declaration.
	* cli/cli-script.c (clear_hook_in_cleanup): Make static.
	(do_restore_user_call_depth): Make static.
	(do_restore_instream_cleanup): Delete declaration.
	(dont_repeat): Delete declaration.
	* cli/cli-decode.c (add_abbrev_cmd): Delete function.
	* cli/cli-dump.c (_initialize_cli_dump): Add declaration.
	* reggroups.c (_initialize_reggroup): Add declaration.
	* cp-support.c (_initialize_cp_support): Add declaration.
	* cp-abi.c (_initialize_cp_abi): Add declaration.
	* hpacc-abi.c (_initialize_hpacc_abi): Add declaration.
	* gnu-v3-abi.c (gnuv3_baseclass_offset): Make static.
	(_initialize_gnu_v3_abi): Add declaration.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Make static.
	(_initialize_gnu_v2_abi): Add declaration.
	* frame-base.c (_initialize_frame_base): Add declaration.
	* doublest.c (floatformat_from_length): Make static.
	* frame-unwind.c (_initialize_frame_unwind): Add declaration.
	* frame.c (create_sentinel_frame): Make static.
	(_initialize_frame): Add declaration.
	* top.c (do_catch_errors): Make static.
	(gdb_rl_operate_and_get_next_completion): Make static.
	* typeprint.c: Include "typeprint.h".
	* sentinel-frame.c (sentinel_frame_prev_register): Make static.
	(sentinel_frame_this_id): Make static.
	* p-valprint.c (_initialize_pascal_valprint): Add declaration.
	* ui-out.c (make_cleanup_ui_out_begin_end): Delete function.
	* dwarf2-frame.c (dwarf2_frame_cache): Make static.
	* p-exp.y (push_current_type, pop_current_type): ISO C declaration.
	* dwarf2expr.h (dwarf_expr_context): ISO C declaration.
	* maint.c (maintenance_print_architecture): Make static.
	* signals/signals.c (_initialize_signals): Add declaration.
	* std-regs.c (_initialize_frame_reg): Add declaration.
	* jv-exp.y (push_variable): ISO C definition.
	(push_qualified_expression_name): Ditto.
	* memattr.c (_initialize_mem): Add declaration.
	* remote.c (remote_check_watch_resources): Make static.
	(remote_stopped_by_watchpoint): Make static.
	(remote_stopped_data_address): Make static.
	* d10v-tdep.c (nr_dmap_regs): Make static.
	(a0_regnum): Make static.
	(d10v_frame_unwind_cache): Make static.
	(d10v_frame_p): Make static.
	* osabi.c (show_osabi): Make static.
	(_initialize_gdb_osabi): Add extern declaration.
	* gdbtypes.c (make_qualified_type): Make static.
	(safe_parse_type): Make static.
	* macrocmd.c (_initialize_macrocmd): Add extern declaration.
	* macrotab.c (macro_bcache_free): Make static.
	* interps.c (interp_set_quiet): Make static.
	(interpreter_exec_cmd): Make static.
	* stack.h (select_frame_command): New file.
	* stack.c: Include "stack.h".
	(select_frame_command_wrapper): Delete function.
	(select_frame_command): Make global.
	* infcall.c: Include "infcall.h".
	* linespec.c: Include "linespec.h".
	* symfile.c (sections_overlap): Make static.
	* cp-support.h (cp_initialize_namespace): ISO C declaration.
	* charset.c (_initialize_charset): Add missing prototype.
	* regcache.c (init_legacy_regcache_descr): Make static.
	(do_regcache_xfree): Make static.
	(regcache_xfer_part): Make static.
	(_initialize_regcache): Add missing prototype.
	* breakpoint.c (parse_breakpoint_sals): Make static.
	(breakpoint_sals_to_pc): Make static.
	* interps.h (clear_interpreter_hooks): ISO C declaration.
	* Makefile.in (stack_h): Define.
	(stack.o, typeprint.o, mi-main.o): Update dependencies.
	(mi-cmd-stack.o, infcall.o, linespec.o): Update dependencies.

Index: mi/ChangeLog
2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* mi-parse.c (_initialize_mi_parse): Delete function.
	* mi-main.c: Include "mi-main.h".
	* mi-interp.c (_initialize_mi_interp): Add declaration.
	* mi-cmd-stack.c: Include "stack.h".
	(select_frame_command_wrapper): Delete extern declaration.
	(mi_cmd_stack_select_frame): Replace select_frame_command_wrapper
	with select_frame_command.
@
text
@d4636 10
a4645 10
   instruction than other targets; in those use REMOTE_BREAKPOINT
   instead of just BREAKPOINT_FROM_PC.  Also, bi-endian targets may
   define LITTLE_REMOTE_BREAKPOINT and BIG_REMOTE_BREAKPOINT.  If none
   of these are defined, we just call the standard routines that are
   in mem-break.c.  */

/* FIXME, these ought to be done in a more dynamic fashion.  For instance,
   the choice of breakpoint instruction affects target program design and
   vice versa, and by making it user-tweakable, the special code here
   goes away and we need fewer special GDB configurations.  */
d4647 2
a4648 2
#if defined (LITTLE_REMOTE_BREAKPOINT) && defined (BIG_REMOTE_BREAKPOINT) && !defined(REMOTE_BREAKPOINT)
#define REMOTE_BREAKPOINT
d4651 1
a4651 1
#ifdef REMOTE_BREAKPOINT
d4654 3
a4656 3
#if !defined (LITTLE_REMOTE_BREAKPOINT) && !defined (BIG_REMOTE_BREAKPOINT)
#define LITTLE_REMOTE_BREAKPOINT REMOTE_BREAKPOINT
#define BIG_REMOTE_BREAKPOINT REMOTE_BREAKPOINT
d4659 2
a4660 2
static unsigned char big_break_insn[] = BIG_REMOTE_BREAKPOINT;
static unsigned char little_break_insn[] = LITTLE_REMOTE_BREAKPOINT;
d4662 1
a4662 1
#endif /* REMOTE_BREAKPOINT */
d4676 1
a4676 1
#ifdef REMOTE_BREAKPOINT
d4713 1
a4713 1
#ifdef REMOTE_BREAKPOINT  
d4729 1
a4729 1
#endif /* REMOTE_BREAKPOINT */
d4758 1
a4758 1
#ifdef REMOTE_BREAKPOINT
d4762 1
a4762 1
#endif /* REMOTE_BREAKPOINT */
@


1.102
log
@	* elfread.c (elf_symtab_read): Avoid use of SECT_OFF_MAX.
	(elfstab_offset_sections): Likewise.
	* gdb-stabs.h (stab_section_info): Likewise.
	* i386-interix-tdep.c (pei_adjust_objfile_offsets): Likewise.
	* objfiles.c (objfile_relocate): Likewise.
	* pa64solib.c (pa64_solib_add_solib_objfile): Likewise.
	* remote.c (get_offsets): Likewise.
	(remote_cisco_objfile_relocate): Likewise.
	* somread.c (som_symfile_offsets): Likewise.
	* symfile.c (alloc_section_addr_info): New function.
	(build_section_addr_info_from_section_tab): Use it.
	(free_section_addr_info): Adjust.
	(default_symfile_offsets): Avoid use of SECT_OFF_MAX.
	(syms_from_objfile): Allocate local_addr dynamically.
	(symbol_file_add_with_addrs_or_offsets): Allocate orig_addrs
	dynamically.
	(add_symbol_file_command): Allocate sect_opts dynamically.
	(reread_symbols): Avoid use of SECT_OFF_MAX.
	* symfile.h (section_addr_info): Do not use MAX_SECTIONS.
	(alloc_section_addr_info): Declare it.
	* symtab.h (SIZEOF_SECTION_OFFSETS): Remove.
	* win32-nat.c (solib_symbols_add): Allocate section_addrs
	dynamically.
	* xcoffread.c (xcoff_symfile_offsets): Avoid use of SECT_OFF_MAX.
@
text
@d4857 1
a4857 1
int
d4883 1
a4883 1
int
d4889 1
a4889 1
CORE_ADDR
@


1.101
log
@* remote.c (init_remote_state): Compute sizeof_g_packet by
accumulation of the size of all registers instead of blindly using
DEPRECATED_REGISTER_BYTES.
@
text
@d1992 4
a1995 2
  offs = (struct section_offsets *) alloca (SIZEOF_SECTION_OFFSETS);
  memcpy (offs, symfile_objfile->section_offsets, SIZEOF_SECTION_OFFSETS);
d2106 4
a2109 2
      offs = (struct section_offsets *) alloca (SIZEOF_SECTION_OFFSETS);
      memcpy (offs, symfile_objfile->section_offsets, SIZEOF_SECTION_OFFSETS);
@


1.100
log
@2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_BYTES): Rename REGISTER_BYTES.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arm-linux-tdep.c (arm_linux_extract_return_value): Delete reference.
	* TODO (REGISTER_BYTES): Delete reference.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init_32082): Update.
	(ns32k_gdbarch_init_32382): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* i386-linux-tdep.c (i386_linux_init_abi): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* sparc-tdep.c (sparc_pop_frame): Update.
	* rs6000-tdep.c (rs6000_pop_frame): Update.
	* remote.c (init_remote_state): Update.
	(remote_prepare_to_store): Update.
	* remote-vx.c (vx_prepare_to_store): Update.
	* remote-sds.c (sds_fetch_registers): Update.
	(sds_prepare_to_store): Update.
	* remote-array.c: Update.
	* regcache.c (init_legacy_regcache_descr): Update.
	(init_regcache_descr): Update.
	* mips-tdep.c (mips_eabi_extract_return_value): Update.
	(mips_o64_extract_return_value): Update.
	* irix5-nat.c (fetch_core_registers): Update.
	* irix4-nat.c (fetch_core_registers): Update.
	* i386-tdep.h: Update.
	* hppa-tdep.c (pa_do_registers_info): Update.
	(pa_do_strcat_registers_info): Update.
	* cris-tdep.c (cris_register_bytes_ok): Update.
	* config/nm-gnu.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/sparc/nm-sun4sol2.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/nm-sun4os4.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/nm-nbsd.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/s390/tm-s390.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/pa/tm-hppa64.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-mips.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-irix6.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-irix5.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/m68k/tm-sun3.h (DEPRECATED_REGISTER_BYTES): Update.
	(REGISTER_BYTES_OK): Update.
	* config/m68k/nm-sun3.h (CHILD_PREPARE_TO_STORE): Update.
	* config/ia64/tm-ia64.h (DEPRECATED_REGISTER_BYTES): Update.

Index: doc/ChangeLog
2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	REGISTER_BYTES with DEPRECATED_REGISTER_BYTES.  Fix typo,
	DEPRECATED_REGISTER_SIZE instead of REGISTER_BYTE.

Index: mi/ChangeLog
2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (mi_setup_architecture_data):
@
text
@d264 4
a267 3
  /* Start out by having the remote protocol mimic the existing
     behavour - just copy in the description of the register cache.  */
  rs->sizeof_g_packet = DEPRECATED_REGISTER_BYTES; /* OK */
a277 1
      /* ...size = REGISTER_RAW_SIZE (regnum); */
d279 4
@


1.100.2.1
log
@2003-05-21  Andrew Cagney  <cagney@@redhat.com>

	* fileio.c: Include "gdb_wait.h".

	2003-03-10  Corinna Vinschen  <vinschen@@redhat.com>
        * fileio.c: New file implementing the remote File-I/O protocol.
	* fileio.h: New header file defining remote File-I/O interface.
        * remote.c (remote_write_bytes, remote_read_bytes): Remove
	static storage class.
	(remote_wait, remote_async_wait): Call remote_fileio_request() on
        'F' packet.
        (_initialize_remote): Call initialize_remote_fileio().
	* remote.h: Declare remote_write_bytes() and remote_read_bytes().

	2002-11-21  Martin M. Hunt  <hunt@@redhat.com>
	* Makefile.in (REMOTE_OBS): Add fileio.o
	(SFILES): Add fileio.c.
	Add dependencies for building fileio.o.  Add fileio.h to
	dependencies for building remote.o.
        * defs.h: Declare gdb_stdin, gdb_stdtargerr and gdb_stdtargin.
        * main.c: New ui_file gdb_stdin, gdb_stdtargerr and gdb_stdtargin.
        (captured_main): Initialize new ui_files.
        * ui-file.c: Add read and fgets input functions.
        (ui_file_new): set ui_file_fputs and ui_file_read to null functions.
        (null_file_read): New function.
        (ui_file_read): New function.
        (set_ui_file_read): New function.
        (stdio_file_read): New function.
        * ui-file.h: New type ui_file_read_ftype.
        (set_ui_file_read): Declare.
        (ui_file_read): Declare.
@
text
@a57 2
#include "fileio.h"

d70 4
a2947 3
	case 'F':		/* File-I/O request */
	  remote_fileio_request (buf);
	  continue;
a3198 3
	case 'F':		/* File-I/O request */
	  remote_fileio_request (buf);
	  continue;
d3753 1
a3753 1
int
d3897 1
a3897 1
int
a6270 3

  /* Eventually initialize fileio.  See fileio.c */
  initialize_remote_fileio (remote_set_cmdlist, remote_show_cmdlist);
@


1.99
log
@2003-05-15  Andrew Cagney  <cagney@@redhat.com>

	* arch-utils.h (legacy_breakpoint_from_pc): Delete declaration.
	* target.h (memory_breakpoint_from_pc): Delete declaration.
	* mem-break.c (memory_breakpoint_from_pc): Delete function.
	* arch-utils.c (legacy_breakpoint_from_pc): Delete function.
	* monitor.c (monitor_insert_breakpoint): Use
	gdbarch_breakpoint_from_pc instead of memory_breakpoint_from_pc.
	* gdbarch.sh (BREAKPOINT_FROM_PC): Do not provide a default.
	* gdbarch.h, gdbarch.c: Re-generate.
	* sparc-tdep.c (sparc_breakpoint_from_pc): New function.
	(sparc_gdbarch_init): Set breakpoint_from_pc to
	sparc_breakpoint_from_pc.
	* config/sparc/tm-sparc.h (BREAKPOINT): Delete macro.
	(BREAKPOINT_FROM_PC): Define.
	(sparc_breakpoint_from_pc): Declare.
	* hppa-tdep.c (hppa_breakpoint_from_pc): New function.
	* config/pa/tm-hppa.h (hppa_breakpoint_from_pc): Declare.
	(BREAKPOINT_FROM_PC): Define.
	(BREAKPOINT): Delete macro.
	* target.h: Update comment.
	* s390-tdep.c (s390_gdbarch_init): Update comments.
	* remote.c: Update comments.
	* remote-mips.c: Update comments.
	* proc-api.c (write_with_trace): Do not check for a breakpoint.
	* mem-break.c: Update comment.
	* ia64-tdep.c (IA64_BREAKPOINT): Rename BREAKPOINT.
	(ia64_memory_insert_breakpoint): Update.
	* config/sparc/tm-sparc.h: Update comment.
	* config/pa/tm-hppa64.h: Update comment.
	* rs6000-tdep.c (BIG_BREAKPOINT, LITTLE_BREAKPOINT): Delete macro.
	(rs6000_breakpoint_from_pc): Update.
	* mips-tdep.c (BIG_BREAKPOINT, LITTLE_BREAKPOINT): Delete macro.
	(PMON_BIG_BREAKPOINT, PMON_LITTLE_BREAKPOINT): Delete macro.
	(IDT_LITTLE_BREAKPOINT, IDT_LITTLE_BREAKPOINT): Delete macro.
	(MIPS16_LITTLE_BREAKPOINT, MIPS16_BIG_BREAKPOINT): Delete macro.
	(mips_breakpoint_from_pc): Update.
	(mips_dump_tdep): Update.
@
text
@d266 1
a266 1
  rs->sizeof_g_packet = REGISTER_BYTES; /* OK use.   */
d3532 1
a3532 1
				      REGISTER_BYTES); /* OK use.  */
@


1.98
log
@2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Delete references to MAX_REGISTER_RAW_SIZE.
	* gdbarch.h: Re-generate.
	* defs.h (MAX_REGISTER_RAW_SIZE): Delete macro.
	(legacy_max_register_raw_size): Delete declaration.
	* regcache.c (legacy_max_register_raw_size): Delete function.
	* valops.c: Replace MAX_REGISTER_RAW_SIZE with MAX_REGISTER_SIZE.
	* target.c, stack.c, sparc-tdep.c, sh-tdep.c: Update.
	* rs6000-tdep.c, rs6000-nat.c, remote.c, remote-sim.c: Update.
	* remote-rdp.c, remote-array.c, regcache.c: Update.
	* ppc-linux-nat.c, monitor.c, mn10300-tdep.c: Update.
	* mips-tdep.c, mips-linux-tdep.c, m68klinux-nat.c: Update.
	* infptrace.c, ia64-tdep.c, i386-tdep.c, frame.c: Update.
	* findvar.c, dwarf2cfi.c: Update.

Index: tui/ChangeLog
2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* tuiRegs.c: Use MAX_REGISTER_SIZE instead of
	MAX_REGISTER_RAW_SIZE.

Index: mi/ChangeLog
2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (register_changed_p): Use MAX_REGISTER_SIZE instead of
	MAX_REGISTER_RAW_SIZE.
@
text
@d4627 6
a4632 5
/* On some machines, e.g. 68k, we may use a different breakpoint instruction
   than other targets; in those use REMOTE_BREAKPOINT instead of just
   BREAKPOINT.  Also, bi-endian targets may define LITTLE_REMOTE_BREAKPOINT
   and BIG_REMOTE_BREAKPOINT.  If none of these are defined, we just call
   the standard routines that are in mem-break.c.  */
d4656 7
a4662 7
/* Insert a breakpoint on targets that don't have any better breakpoint
   support.  We read the contents of the target location and stash it,
   then overwrite it with a breakpoint instruction.  ADDR is the target
   location in the target machine.  CONTENTS_CACHE is a pointer to 
   memory allocated for saving the target contents.  It is guaranteed
   by the caller to be long enough to save sizeof BREAKPOINT bytes (this
   is accomplished via BREAKPOINT_MAX).  */
@


1.98.4.1
log
@Snap const char * mess.
@
text
@d91 2
a92 2
static void remote_open (const char *name, int from_tty);
static void remote_async_open (const char *name, int from_tty);
d94 2
a95 2
static void extended_remote_open (const char *name, int from_tty);
static void extended_remote_async_open (const char *name, int from_tty);
d97 2
a98 2
static void remote_open_1 (const char *, int, struct target_ops *,
			   int extended_p, int async_p);
d130 2
a131 2
static void remote_detach (const char *args, int from_tty);
static void remote_async_detach (const char *args, int from_tty);
d175 1
a175 1
static void print_packet (const char *);
d179 1
a179 1
static void compare_sections_command (const char *, int);
d181 1
a181 1
static void packet_command (const char *, int);
d197 1
a197 1
static int putpkt_binary (const char *buf, int cnt);
d471 1
a471 1
set_memory_packet_size (const char *args, struct memory_packet_config *config)
d529 1
a529 1
set_memory_write_packet_size (const char *args, int from_tty)
d535 1
a535 1
show_memory_write_packet_size (const char *args, int from_tty)
d552 1
a552 1
set_memory_read_packet_size (const char *args, int from_tty)
d558 1
a558 1
show_memory_read_packet_size (const char *args, int from_tty)
d762 2
a763 2
set_remote_protocol_qSymbol_packet_cmd (const char *args, int from_tty,
					struct cmd_list_element *c)
d769 1
a769 1
show_remote_protocol_qSymbol_packet_cmd (const char *args, int from_tty,
d779 1
a779 1
set_remote_protocol_e_packet_cmd (const char *args, int from_tty,
d786 1
a786 1
show_remote_protocol_e_packet_cmd (const char *args, int from_tty,
d797 1
a797 1
set_remote_protocol_E_packet_cmd (const char *args, int from_tty,
d804 1
a804 1
show_remote_protocol_E_packet_cmd (const char *args, int from_tty,
d816 1
a816 1
set_remote_protocol_P_packet_cmd (const char *args, int from_tty,
d823 1
a823 1
show_remote_protocol_P_packet_cmd (const char *args, int from_tty,
d847 1
a847 1
set_remote_protocol_Z_software_bp_packet_cmd (const char *args, int from_tty,
d854 1
a854 1
show_remote_protocol_Z_software_bp_packet_cmd (const char *args, int from_tty,
d861 1
a861 1
set_remote_protocol_Z_hardware_bp_packet_cmd (const char *args, int from_tty,
d868 1
a868 1
show_remote_protocol_Z_hardware_bp_packet_cmd (const char *args, int from_tty,
d875 2
a876 2
set_remote_protocol_Z_write_wp_packet_cmd (const char *args, int from_tty,
					   struct cmd_list_element *c)
d882 1
a882 1
show_remote_protocol_Z_write_wp_packet_cmd (const char *args, int from_tty,
d889 2
a890 2
set_remote_protocol_Z_read_wp_packet_cmd (const char *args, int from_tty,
					  struct cmd_list_element *c)
d896 1
a896 1
show_remote_protocol_Z_read_wp_packet_cmd (const char *args, int from_tty,
d903 2
a904 2
set_remote_protocol_Z_access_wp_packet_cmd (const char *args, int from_tty,
					    struct cmd_list_element *c)
d910 1
a910 1
show_remote_protocol_Z_access_wp_packet_cmd (const char *args, int from_tty,
d922 1
a922 1
set_remote_protocol_Z_packet_cmd (const char *args, int from_tty,
d934 1
a934 1
show_remote_protocol_Z_packet_cmd (const char *args, int from_tty,
d968 1
a968 1
set_remote_protocol_binary_download_cmd (const char *args,
d976 1
a976 1
show_remote_protocol_binary_download_cmd (const char *args, int from_tty,
d2156 1
a2156 1
remote_open (const char *name, int from_tty)
d2163 1
a2163 1
remote_async_open (const char *name, int from_tty)
d2172 1
a2172 1
extended_remote_open (const char *name, int from_tty)
d2180 1
a2180 1
extended_remote_async_open (const char *name, int from_tty)
d2243 1
a2243 1
remote_serial_open (const char *name)
d2263 1
a2263 1
remote_open_1 (const char *name, int from_tty, struct target_ops *target,
d2406 1
a2406 1
remote_detach (const char *args, int from_tty)
d2426 1
a2426 1
remote_async_detach (const char *args, int from_tty)
d4112 1
a4112 1
print_packet (const char *buf)
d4120 1
a4120 1
putpkt (const char *buf)
d4131 1
a4131 1
putpkt_binary (const char *buf, int cnt)
d5032 1
a5032 1
compare_sections_command (const char *args, int from_tty)
d5176 1
a5176 1
remote_rcmd (const char *command,
d5234 1
a5234 1
packet_command (const char *args, int from_tty)
d5261 1
a5261 1
static void threadset_test_cmd (const char *cmd, int tty);
d5263 1
a5263 1
static void threadalive_test (const char *cmd, int tty);
d5265 1
a5265 1
static void threadlist_test_cmd (const char *cmd, int tty);
d5269 1
a5269 1
static void threadinfo_test_cmd (const char *cmd, int tty);
d5273 1
a5273 1
static void threadlist_update_test_cmd (const char *cmd, int tty);
d5280 1
a5280 1
threadset_test_cmd (const char *cmd, int tty)
d5313 1
a5313 1
threadlist_test_cmd (const char *cmd, int tty)
d5358 1
a5358 1
threadinfo_test_cmd (const char *cmd, int tty)
d5378 1
a5378 1
threadlist_update_test_cmd (const char *cmd, int tty)
d5496 1
a5496 1
remote_info_process (const char *args, int from_tty)
d5525 1
a5525 1
remote_cisco_open (const char *name, int from_tty)
d6003 1
a6003 1
set_remote_cmd (const char *args, int from_tty)
d6008 1
a6008 1
show_remote_cmd (const char *args, int from_tty)
@


1.97
log
@Index: gdb/ChangeLog
2003-05-07  Andrew Cagney  <cagney@@redhat.com>

	* d10v-tdep.c (remote_d10v_translate_xfer_address): Add
	"regcache".
	(d10v_print_registers_info): Update.
	(d10v_dmap_register, d10v_imap_register): Delete functions.
	(struct gdbarch_tdep): Add "regcache" parameter to "dmap_register"
	and "imap_register".
	(d10v_ts2_dmap_register, d10v_ts2_imap_register): Add "regcache".
	(d10v_ts3_dmap_register, d10v_ts3_imap_register): Add "regcache".
	* arch-utils.c (generic_remote_translate_xfer_address): Add
	"regcache" and "gdbarch" parameters.
	* gdbarch.sh (REMOTE_TRANSLATE_XFER_ADDRESS): Add "regcache"
	parameter.  Change class to multi-arch.
	* gdbarch.h, gdbarch.c: Re-generate.
	* remote.c (remote_xfer_memory): Use
	gdbarch_remote_translate_xfer_address.

Index: include/gdb/ChangeLog
2003-05-07  Andrew Cagney  <cagney@@redhat.com>

	* sim-d10v.h (sim_d10v_translate_addr): Add regcache parameter.
	(sim_d10v_translate_imap_addr): Add regcache parameter.
	(sim_d10v_translate_dmap_addr): Ditto.

Index: sim/d10v/ChangeLog
2003-05-07  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_d10v_translate_addr): Add "regcache" parameter.
	(sim_d10v_translate_imap_addr): Ditto.
	(sim_d10v_translate_dmap_addr): Ditto.
	(xfer_mem): Pass NULL regcache to sim_d10v_translate_addr.
	(dmem_addr): Pass NULL regcache to sim_d10v_translate_dmap_addr.
	(dmap_register, imap_register): Add "regcache" parameter.
	(imem_addr): Pass NULL regcache to sim_d10v_translate_imap_addr.
	(sim_fetch_register): Pass NULL regcache to imap_register and
	dmap_register.
@
text
@d2951 1
a2951 1
	    char* regs = (char*) alloca (MAX_REGISTER_RAW_SIZE);
d3202 1
a3202 1
	    char* regs = (char*) alloca (MAX_REGISTER_RAW_SIZE);
d3549 1
a3549 1
  char *regp = alloca (MAX_REGISTER_RAW_SIZE);
@


1.96
log
@	* remote.c (minitelnet): Don't redeclare escape_count, echo_check.
@
text
@d3976 4
a3979 1
  REMOTE_TRANSLATE_XFER_ADDRESS (mem_addr, mem_len, &targ_addr, &targ_len);
@


1.96.2.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d266 1
a266 1
  rs->sizeof_g_packet = DEPRECATED_REGISTER_BYTES; /* OK */
d2951 1
a2951 1
	    char regs[MAX_REGISTER_SIZE];
d3202 1
a3202 1
	    char regs[MAX_REGISTER_SIZE];
d3532 1
a3532 1
				      DEPRECATED_REGISTER_BYTES); /* OK */
d3549 1
a3549 1
  char regp[MAX_REGISTER_SIZE];
d3976 1
a3976 4
  /* Should this be the selected frame?  */
  gdbarch_remote_translate_xfer_address (current_gdbarch, current_regcache,
					 mem_addr, mem_len,
					 &targ_addr, &targ_len);
d4624 5
a4628 6
/* On some machines, e.g. 68k, we may use a different breakpoint
   instruction than other targets; in those use REMOTE_BREAKPOINT
   instead of just BREAKPOINT_FROM_PC.  Also, bi-endian targets may
   define LITTLE_REMOTE_BREAKPOINT and BIG_REMOTE_BREAKPOINT.  If none
   of these are defined, we just call the standard routines that are
   in mem-break.c.  */
d4652 7
a4658 7
/* Insert a breakpoint on targets that don't have any better
   breakpoint support.  We read the contents of the target location
   and stash it, then overwrite it with a breakpoint instruction.
   ADDR is the target location in the target machine.  CONTENTS_CACHE
   is a pointer to memory allocated for saving the target contents.
   It is guaranteed by the caller to be long enough to save the number
   of bytes returned by BREAKPOINT_FROM_PC.  */
@


1.95
log
@2003-02-20  Andrew Cagney  <ac131313@@redhat.com>

	* remote.c (_initialize_remote): Add commands "set/show remote
	hardware-watchpoint-limit" and "set/show remote
	hardware-breakpoint-limit".
	(remote_hw_watchpoint_limit): Initialize to -1.
	(remote_hw_breakpoint_limit): Ditto.
	(remote_check_watch_resources): Treat a limit of -1 as unlimited.

Index: doc/ChangeLog
2003-02-20  Andrew Cagney  <ac131313@@redhat.com>

	* gdb.texinfo (Set Breaks): Add cross reference to "set remote
	hardware-breakpoint-limit".
	(Set Watchpoints): Add cross reference to "set remote
	hardware-watchpoint-limit".
	(Remote configuration options): New section.
@
text
@a5747 3
  extern int escape_count;	/* global shared by readsocket */
  extern int echo_check;	/* ditto */

@


1.94
log
@2002-11-13  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (deprecated_read_register_bytes): Rename
	read_register_bytes.
	(deprecated_write_register_bytes): Rename write_register_bytes.
	* alpha-tdep.c, arm-tdep.c, cris-tdep.c, d10v-tdep.c: Update.
	* dwarf2cfi.c, frv-tdep.c, hppa-tdep.c, ia64-tdep.c: Update.
	* m68k-tdep.c, mcore-tdep.c, mips-tdep.c, mn10300-tdep.c: Update.
	* ns32k-tdep.c, regcache.c, remote-sds.c, remote-vx.c: Update.
	* remote.c, rs6000-tdep.c, s390-tdep.c, sh-tdep.c: Update.
	* sparc-tdep.c, v850-tdep.c, vax-tdep.c, x86-64-tdep.c: Update.
	* xstormy16-tdep.c, z8k-tdep.c, config/nm-gnu.h: Update.
	* config/nm-m3.h, config/h8500/tm-h8500.h: Update.
	* config/i386/nm-ptx4.h, config/i386/nm-symmetry.h: Update.
	* config/m32r/tm-m32r.h, config/m68k/nm-sun3.h: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-linux.h: Update.
	* config/mn10200/tm-mn10200.h, config/pa/tm-hppa64.h: Update.
	* config/sparc/nm-nbsd.h, config/sparc/nm-sun4os4.h: Update.
	* config/sparc/nm-sun4sol2.h, config/sparc/tm-sparclet.h: Update.

2002-11-13  Andrew Cagney  <ac131313@@redhat.com>

	* mi-main.c (mi_cmd_data_write_register_values): Use
	deprecated_write_register_bytes instead of write_register_bytes.
@
text
@d4842 2
a4843 2
int remote_hw_watchpoint_limit = 0;
int remote_hw_breakpoint_limit = 0;
d4852 2
d4861 2
d6150 13
@


1.93
log
@        * remote.c (remote_open_1): Add async_p.
        (remote_async_open_1): Delete.
        (open_remote_target): Delete.
        (remote_open, extended_remote_open): Update calls to remote_open_1.
        (remote_async_open, extended_remote_async_open): Call
        remote_open_1 instead of remote_async_open_1.
@
text
@d3531 2
a3532 1
      read_register_bytes (0, (char *) NULL, REGISTER_BYTES); /* OK use.  */
@


1.93.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a57 2
#include "remote-fileio.h"

d70 4
d131 1
d167 2
d212 1
a212 1
   Unfortunately, the target stack doesn't include local state.  For
d222 1
a222 1
  /* long size in bytes;  == DEPRECATED_REGISTER_RAW_SIZE (regnum); at present.  */
d262 1
a262 1
  struct remote_state *rs = GDBARCH_OBSTACK_ZALLOC (gdbarch, struct remote_state);
d264 3
a266 4
  if (DEPRECATED_REGISTER_BYTES != 0)
    rs->sizeof_g_packet = DEPRECATED_REGISTER_BYTES;
  else
    rs->sizeof_g_packet = 0;
d269 1
a269 2
  rs->regs = GDBARCH_OBSTACK_CALLOC (gdbarch, NUM_REGS + NUM_PSEUDO_REGS,
				     struct packet_reg);
d275 1
a275 1
      r->offset = DEPRECATED_REGISTER_BYTE (regnum);
d277 1
a278 4

      /* Compute packet size by accumulating the size of all registers. */
      if (DEPRECATED_REGISTER_BYTES == 0)
        rs->sizeof_g_packet += register_size (current_gdbarch, regnum);
d305 8
a757 17
/* Should we try the 'vCont' (descriptive resume) request? */
static struct packet_config remote_protocol_vcont;

static void
set_remote_protocol_vcont_packet_cmd (char *args, int from_tty,
				      struct cmd_list_element *c)
{
  update_packet_config (&remote_protocol_vcont);
}

static void
show_remote_protocol_vcont_packet_cmd (char *args, int from_tty,
				       struct cmd_list_element *c)
{
  show_packet_config_cmd (&remote_protocol_vcont);
}

d1912 1
d1988 2
a1989 4
  offs = ((struct section_offsets *) 
	  alloca (SIZEOF_N_SECTION_OFFSETS (symfile_objfile->num_sections)));
  memcpy (offs, symfile_objfile->section_offsets, 
	  SIZEOF_N_SECTION_OFFSETS (symfile_objfile->num_sections));
d2071 1
a2071 1
      fputs_filtered (tmp, gdb_stdlog);
d2100 2
a2101 4
      offs = (struct section_offsets *) 
	alloca (SIZEOF_N_SECTION_OFFSETS (symfile_objfile->num_sections));
      memcpy (offs, symfile_objfile->section_offsets, 
	      SIZEOF_N_SECTION_OFFSETS (symfile_objfile->num_sections));
a2195 1
  update_packet_config (&remote_protocol_vcont);
a2288 4
	  /* The requested speed could not be set.  Error out to
	     top level after closing remote_desc.  Take care to
	     set remote_desc to NULL to avoid closing remote_desc
	     more than once.  */
a2289 1
	  remote_desc = NULL;
d2355 1
a2355 1
     caller restore the previous state.  Unfortunately the command
a2417 4
  /* Unregister the file descriptor from the event loop. */
  if (target_is_async_p ())
    serial_async (remote_desc, NULL, 0);

d2421 1
d2424 1
a2424 2
/* Same as remote_detach, but don't send the "D" packet; just disconnect.  */

d2426 1
a2426 1
remote_disconnect (char *args, int from_tty)
d2434 4
d2509 5
a2513 2
/* Check for the availability of vCont.  This function should also check
   the response.  */
d2516 1
a2516 1
remote_vcont_probe (struct remote_state *rs, char *buf)
d2518 4
a2521 3
  strcpy (buf, "vCont?");
  putpkt (buf);
  getpkt (buf, rs->remote_packet_size, 0);
d2523 4
a2526 5
  /* Make sure that the features we assume are supported.  */
  if (strncmp (buf, "vCont", 5) == 0)
    {
      char *p = &buf[5];
      int support_s, support_S, support_c, support_C;
d2528 2
a2529 15
      support_s = 0;
      support_S = 0;
      support_c = 0;
      support_C = 0;
      while (p && *p == ';')
	{
	  p++;
	  if (*p == 's' && (*(p + 1) == ';' || *(p + 1) == 0))
	    support_s = 1;
	  else if (*p == 'S' && (*(p + 1) == ';' || *(p + 1) == 0))
	    support_S = 1;
	  else if (*p == 'c' && (*(p + 1) == ';' || *(p + 1) == 0))
	    support_c = 1;
	  else if (*p == 'C' && (*(p + 1) == ';' || *(p + 1) == 0))
	    support_C = 1;
d2531 4
a2534 2
	  p = strchr (p, ';');
	}
a2535 5
      /* If s, S, c, and C are not all supported, we can't use vCont.  Clearing
         BUF will make packet_ok disable the packet.  */
      if (!support_s || !support_S || !support_c || !support_C)
	buf[0] = 0;
    }
d2537 4
a2540 2
  packet_ok (buf, &remote_protocol_vcont);
}
d2542 21
a2562 6
/* Resume the remote inferior by using a "vCont" packet.  The thread
   to be resumed is PTID; STEP and SIGGNAL indicate whether the
   resumed thread should be single-stepped and/or signalled.  If PTID's
   PID is -1, then all threads are resumed; the thread to be stepped and/or
   signalled is given in the global INFERIOR_PTID.  This function returns
   non-zero iff it resumes the inferior.
d2564 2
a2565 2
   This function issues a strict subset of all possible vCont commands at the
   moment.  */
d2567 14
a2580 7
static int
remote_vcont_resume (ptid_t ptid, int step, enum target_signal siggnal)
{
  struct remote_state *rs = get_remote_state ();
  int pid = PIDGET (ptid);
  char *buf = NULL;
  struct cleanup *old_cleanup;
d2582 2
a2583 2
  buf = xmalloc (rs->remote_packet_size);
  old_cleanup = make_cleanup (xfree, buf);
d2585 4
a2588 7
  if (remote_protocol_vcont.support == PACKET_SUPPORT_UNKNOWN)
    remote_vcont_probe (rs, buf);

  if (remote_protocol_vcont.support == PACKET_DISABLE)
    {
      do_cleanups (old_cleanup);
      return 0;
d2591 1
a2591 19
  /* If we could generate a wider range of packets, we'd have to worry
     about overflowing BUF.  Should there be a generic
     "multi-part-packet" packet?  */

  if (PIDGET (inferior_ptid) == MAGIC_NULL_PID)
    {
      /* MAGIC_NULL_PTID means that we don't have any active threads, so we
	 don't have any PID numbers the inferior will understand.  Make sure
	 to only send forms that do not specify a PID.  */
      if (step && siggnal != TARGET_SIGNAL_0)
	sprintf (buf, "vCont;S%02x", siggnal);
      else if (step)
	sprintf (buf, "vCont;s");
      else if (siggnal != TARGET_SIGNAL_0)
	sprintf (buf, "vCont;C%02x", siggnal);
      else
	sprintf (buf, "vCont;c");
    }
  else if (pid == -1)
d2593 4
a2596 9
      /* Resume all threads, with preference for INFERIOR_PTID.  */
      if (step && siggnal != TARGET_SIGNAL_0)
	sprintf (buf, "vCont;S%02x:%x;c", siggnal, PIDGET (inferior_ptid));
      else if (step)
	sprintf (buf, "vCont;s:%x;c", PIDGET (inferior_ptid));
      else if (siggnal != TARGET_SIGNAL_0)
	sprintf (buf, "vCont;C%02x:%x;c", siggnal, PIDGET (inferior_ptid));
      else
	sprintf (buf, "vCont;c");
d2599 1
a2599 11
    {
      /* Scheduler locking; resume only PTID.  */
      if (step && siggnal != TARGET_SIGNAL_0)
	sprintf (buf, "vCont;S%02x:%x", siggnal, pid);
      else if (step)
	sprintf (buf, "vCont;s:%x", pid);
      else if (siggnal != TARGET_SIGNAL_0)
	sprintf (buf, "vCont;C%02x:%x", siggnal, pid);
      else
	sprintf (buf, "vCont;c:%x", pid);
    }
a2601 4

  do_cleanups (old_cleanup);

  return 1;
d2604 1
a2604 6
/* Tell the remote machine to resume.  */

static enum target_signal last_sent_signal = TARGET_SIGNAL_0;

static int last_sent_step;

d2606 1
a2606 1
remote_resume (ptid_t ptid, int step, enum target_signal siggnal)
d2613 5
a2625 10
  /* The vCont packet doesn't need to specify threads via Hc.  */
  if (remote_vcont_resume (ptid, step, siggnal))
    return;

  /* All other supported resume packets do use Hc, so call set_thread.  */
  if (pid == -1)
    set_thread (0, 0);		/* run any thread */
  else
    set_thread (pid, 0);	/* run this thread */

d2657 1
a2657 1
		return;
d2675 1
a2675 1
		return;
d2684 1
a2684 1
      buf[2] = tohex (((int) siggnal) & 0xf);
d2689 1
a2689 1

a2690 7
}

/* Same as remote_resume, but with async support. */
static void
remote_async_resume (ptid_t ptid, int step, enum target_signal siggnal)
{
  remote_resume (ptid, step, siggnal);
d2692 1
a2947 3
	case 'F':		/* File-I/O request */
	  remote_fileio_request (buf);
	  continue;
d2951 1
a2951 1
	    char regs[MAX_REGISTER_SIZE];
d3019 3
a3021 2
		      error ("Malformed packet(b) (missing colon): %s\nPacket: '%s'\n",
			     p, buf);
d3024 3
a3026 2
		      error ("Remote sent bad register number %s: %s\nPacket: '%s'\n",
			     phex_nz (pnum, 0), p, buf);
d3028 1
a3028 1
		    fieldsize = hex2bin (p, regs, DEPRECATED_REGISTER_RAW_SIZE (reg->regnum));
d3030 1
a3030 1
		    if (fieldsize < DEPRECATED_REGISTER_RAW_SIZE (reg->regnum))
d3036 4
a3039 1
		  error ("Remote register badly formatted: %s\nhere: %s", buf, p);
a3198 3
	case 'F':		/* File-I/O request */
	  remote_fileio_request (buf);
	  continue;
d3202 1
a3202 1
	    char regs[MAX_REGISTER_SIZE];
d3239 3
a3241 2
		      error ("Malformed packet(a) (missing colon): %s\nPacket: '%s'\n",
			     p, buf);
d3270 3
a3272 2
		      error ("Malformed packet(b) (missing colon): %s\nPacket: '%s'\n",
			     p, buf);
d3275 3
a3277 2
		      error ("Remote sent bad register number %ld: %s\nPacket: '%s'\n",
			     pnum, p, buf);
d3279 1
a3279 1
		    fieldsize = hex2bin (p, regs, DEPRECATED_REGISTER_RAW_SIZE (reg->regnum));
d3281 1
a3281 1
		    if (fieldsize < DEPRECATED_REGISTER_RAW_SIZE (reg->regnum))
d3287 4
a3290 2
		  error ("Remote register badly formatted: %s\nhere: %s",
			 buf, p);
d3422 1
d3508 3
a3510 17
	    if (r->offset * 2 >= strlen (buf))
	      /* A short packet that didn't include the register's
                 value, this implies that the register is zero (and
                 not that the register is unavailable).  Supply that
                 zero value.  */
	      regcache_raw_supply (current_regcache, r->regnum, NULL);
	    else if (buf[r->offset * 2] == 'x')
	      {
		gdb_assert (r->offset * 2 < strlen (buf));
		/* The register isn't available, mark it as such (at
                   the same time setting the value to zero).  */
		regcache_raw_supply (current_regcache, r->regnum, NULL);
		set_register_cached (i, -1);
	      }
	    else
	      regcache_raw_supply (current_regcache, r->regnum,
				   regs + r->offset);
a3522 4
  struct remote_state *rs = get_remote_state ();
  int i;
  char buf[MAX_REGISTER_SIZE];

d3528 4
a3531 4
      /* Make sure all the necessary registers are cached.  */
      for (i = 0; i < NUM_REGS; i++)
	if (rs->regs[i].in_g_packet)
	  regcache_raw_read (current_regcache, rs->regs[i].regnum, buf);
d3548 1
a3548 1
  char regp[MAX_REGISTER_SIZE];
d3555 1
a3555 1
  bin2hex (regp, p, DEPRECATED_REGISTER_RAW_SIZE (reg->regnum));
d3752 1
a3752 1
int
d3756 1
a3762 2
  int payload_size;
  unsigned char *payload_start;
d3764 1
a3764 1
  /* Verify that the target can support a binary download.  */
d3767 3
a3769 3
  /* Compute the size, and then allocate space for the largest
     possible packet.  Include space for an extra trailing NUL.  */
  sizeof_buf = get_memory_write_packet_size () + 1;
d3772 2
a3773 5
  /* Compute the size of the actual payload by subtracting out the
     packet header and footer overhead: "$M<memaddr>,<len>:...#nn".  */
  payload_size = (get_memory_write_packet_size () - (strlen ("$M,:#NN")
						     + hexnumlen (memaddr)
						     + hexnumlen (len)));
d3775 3
a3777 1
  /* Construct the packet header: "[MX]<memaddr>,<len>:".   */
d3779 1
a3779 1
  /* Append "[XM]".  Compute a best guess of the number of bytes
a3780 1
  p = buf;
d3786 1
a3786 1
      todo = min (len, payload_size);
d3791 1
a3791 1
      todo = min (len, payload_size / 2);
d3800 1
a3800 1
  /* Append "<memaddr>".  */
a3802 2

  /* Append ",".  */
d3805 2
a3806 2
  /* Append <len>.  Retain the location/size of <len>.  It may need to
     be adjusted once the packet body has been created.  */
a3809 2

  /* Append ":".  */
d3813 1
a3813 2
  /* Append the packet body.  */
  payload_start = p;
d3821 1
a3821 1
	   (nr_bytes < todo) && (p - payload_start) < payload_size;
d3844 1
d3896 1
a3896 1
int
d3965 1
d3975 1
a3975 4
  /* Should this be the selected frame?  */
  gdbarch_remote_translate_xfer_address (current_gdbarch, current_regcache,
					 mem_addr, mem_len,
					 &targ_addr, &targ_len);
d3987 67
d4623 10
a4632 11
/* On some machines, e.g. 68k, we may use a different breakpoint
   instruction than other targets; in those use
   DEPRECATED_REMOTE_BREAKPOINT instead of just BREAKPOINT_FROM_PC.
   Also, bi-endian targets may define
   DEPRECATED_LITTLE_REMOTE_BREAKPOINT and
   DEPRECATED_BIG_REMOTE_BREAKPOINT.  If none of these are defined, we
   just call the standard routines that are in mem-break.c.  */

/* NOTE: cagney/2003-06-08: This is silly.  A remote and simulator
   target should use an identical BREAKPOINT_FROM_PC.  As for native,
   the ARCH-OS-tdep.c code can override the default.  */
d4634 2
a4635 2
#if defined (DEPRECATED_LITTLE_REMOTE_BREAKPOINT) && defined (DEPRECATED_BIG_REMOTE_BREAKPOINT) && !defined(DEPRECATED_REMOTE_BREAKPOINT)
#define DEPRECATED_REMOTE_BREAKPOINT
d4638 1
a4638 1
#ifdef DEPRECATED_REMOTE_BREAKPOINT
d4641 3
a4643 3
#if !defined (DEPRECATED_LITTLE_REMOTE_BREAKPOINT) && !defined (DEPRECATED_BIG_REMOTE_BREAKPOINT)
#define DEPRECATED_LITTLE_REMOTE_BREAKPOINT DEPRECATED_REMOTE_BREAKPOINT
#define DEPRECATED_BIG_REMOTE_BREAKPOINT DEPRECATED_REMOTE_BREAKPOINT
d4646 2
a4647 2
static unsigned char big_break_insn[] = DEPRECATED_BIG_REMOTE_BREAKPOINT;
static unsigned char little_break_insn[] = DEPRECATED_LITTLE_REMOTE_BREAKPOINT;
d4649 1
a4649 1
#endif /* DEPRECATED_REMOTE_BREAKPOINT */
d4651 7
a4657 7
/* Insert a breakpoint on targets that don't have any better
   breakpoint support.  We read the contents of the target location
   and stash it, then overwrite it with a breakpoint instruction.
   ADDR is the target location in the target machine.  CONTENTS_CACHE
   is a pointer to memory allocated for saving the target contents.
   It is guaranteed by the caller to be long enough to save the number
   of bytes returned by BREAKPOINT_FROM_PC.  */
d4663 1
a4663 1
#ifdef DEPRECATED_REMOTE_BREAKPOINT
d4700 1
a4700 1
#ifdef DEPRECATED_REMOTE_BREAKPOINT  
d4716 1
a4716 1
#endif /* DEPRECATED_REMOTE_BREAKPOINT */
d4745 1
a4745 1
#ifdef DEPRECATED_REMOTE_BREAKPOINT
d4749 1
a4749 1
#endif /* DEPRECATED_REMOTE_BREAKPOINT */
d4841 2
a4842 2
int remote_hw_watchpoint_limit = -1;
int remote_hw_breakpoint_limit = -1;
d4844 1
a4844 1
static int
a4850 2
      else if (remote_hw_breakpoint_limit < 0)
	return 1;
a4857 2
      else if (remote_hw_watchpoint_limit < 0)
	return 1;
d4866 1
a4866 1
static int
d4872 1
a4872 1
static CORE_ADDR
d5100 2
a5101 4
static LONGEST
remote_xfer_partial (struct target_ops *ops, enum target_object object,
		     const char *annex, void *readbuf, const void *writebuf,
		     ULONGEST offset, LONGEST len)
a5106 1
  char query_type;
d5108 7
a5114 7
  /* Only handle reads.  */
  if (writebuf != NULL || readbuf == NULL)
    return -1;

  /* Map pre-existing objects onto letters.  DO NOT do this for new
     objects!!!  Instead specify new query packets.  */
  switch (object)
d5116 1
a5116 7
    case TARGET_OBJECT_KOD:
      query_type = 'K';
      break;
    case TARGET_OBJECT_AVR:
      query_type = 'R';
      break;
    default:
a5119 10
  /* Note: a zero OFFSET and LEN can be used to query the minimum
     buffer size.  */
  if (offset == 0 && len == 0)
    return (rs->remote_packet_size);
  /* Minimum outbuf size is (rs->remote_packet_size) - if bufsiz is
     not large enough let the caller.  */
  if (len < (rs->remote_packet_size))
    return -1;
  len = rs->remote_packet_size;

d5124 11
a5134 2
  gdb_assert (annex != NULL);
  gdb_assert (readbuf != NULL);
d5144 1
a5144 1
  while (annex[i] && (i < ((rs->remote_packet_size) - 8)))
d5146 5
a5150 3
      /* Bad caller may have sent forbidden characters.  */
      gdb_assert (isprint (annex[i]) && annex[i] != '$' && annex[i] != '#');
      *p2++ = annex[i];
d5153 4
a5156 2
  *p2 = '\0';
  gdb_assert (annex[i] == '\0');
d5162 1
a5162 1
  getpkt (readbuf, len, 0);
d5164 1
a5164 1
  return strlen (readbuf);
a5416 1
  remote_ops.to_disconnect = remote_disconnect;
d5441 1
a5441 1
  remote_ops.to_xfer_partial = remote_xfer_partial;
a5543 4
      /* The requested speed could not be set.  Error out to
	 top level after closing remote_desc.  Take care to
	 set remote_desc to NULL to avoid closing remote_desc
	 more than once.  */
a5544 1
      remote_desc = NULL;
d5743 3
a5839 1
  remote_cisco_ops.to_disconnect = remote_disconnect;
d5935 1
a5935 2
  remote_async_ops.to_detach = remote_detach;
  remote_async_ops.to_disconnect = remote_disconnect;
d5962 1
a5962 1
  remote_async_ops.to_xfer_partial = remote_xfer_partial;
a6011 1
  show_remote_protocol_vcont_packet_cmd (args, from_tty, NULL);
d6046 2
a6047 1
  remote_gdbarch_data_handle = register_gdbarch_data (init_remote_state);
a6145 13
  add_setshow_cmd ("hardware-watchpoint-limit", no_class,
		   var_zinteger, &remote_hw_watchpoint_limit, "\
Set the maximum number of target hardware watchpoints.\n\
Specify a negative limit for unlimited.", "\
Show the maximum number of target hardware watchpoints.\n",
		   NULL, NULL, &remote_set_cmdlist, &remote_show_cmdlist);
  add_setshow_cmd ("hardware-breakpoint-limit", no_class,
		   var_zinteger, &remote_hw_breakpoint_limit, "\
Set the maximum number of target hardware breakpoints.\n\
Specify a negative limit for unlimited.", "\
Show the maximum number of target hardware breakpoints.\n",
		   NULL, NULL, &remote_set_cmdlist, &remote_show_cmdlist);

a6172 7
  add_packet_config_cmd (&remote_protocol_vcont,
			 "vCont", "verbose-resume",
			 set_remote_protocol_vcont_packet_cmd,
			 show_remote_protocol_vcont_packet_cmd,
			 &remote_set_cmdlist, &remote_show_cmdlist,
			 0);

a6251 3

  /* Eventually initialize fileio.  See fileio.c */
  initialize_remote_fileio (remote_set_cmdlist, remote_show_cmdlist);
@


1.93.10.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d4 1
a4 2
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
d154 4
d375 4
d1164 4
d1579 13
d2013 117
d2586 1
a2586 1
  char *buf = NULL, *outbuf;
d2611 1
a2611 1
	outbuf = xstrprintf ("vCont;S%02x", siggnal);
d2613 1
a2613 1
	outbuf = xstrprintf ("vCont;s");
d2615 1
a2615 1
	outbuf = xstrprintf ("vCont;C%02x", siggnal);
d2617 1
a2617 1
	outbuf = xstrprintf ("vCont;c");
d2623 1
a2623 2
	outbuf = xstrprintf ("vCont;S%02x:%x;c", siggnal,
			     PIDGET (inferior_ptid));
d2625 1
a2625 1
	outbuf = xstrprintf ("vCont;s:%x;c", PIDGET (inferior_ptid));
d2627 1
a2627 2
	outbuf = xstrprintf ("vCont;C%02x:%x;c", siggnal,
			     PIDGET (inferior_ptid));
d2629 1
a2629 1
	outbuf = xstrprintf ("vCont;c");
d2635 1
a2635 1
	outbuf = xstrprintf ("vCont;S%02x:%x", siggnal, pid);
d2637 1
a2637 1
	outbuf = xstrprintf ("vCont;s:%x", pid);
d2639 1
a2639 1
	outbuf = xstrprintf ("vCont;C%02x:%x", siggnal, pid);
d2641 1
a2641 1
	outbuf = xstrprintf ("vCont;c:%x", pid);
d2644 1
a2644 4
  gdb_assert (outbuf && strlen (outbuf) < rs->remote_packet_size);
  make_cleanup (xfree, outbuf);

  putpkt (outbuf);
d3111 7
d3121 10
d3132 43
d3360 7
d3370 10
d3381 43
d4264 2
d4347 18
a4364 3
	    c = readchar (remote_timeout);
	    csum += c;
	    repeat = c - ' ' + 3;	/* Compute repeat count */
d5502 403
d6101 3
d6216 3
@


1.93.8.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d3531 1
a3531 2
      deprecated_read_register_bytes (0, (char *) NULL,
				      REGISTER_BYTES); /* OK use.  */
@


1.93.8.2
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d4842 2
a4843 2
int remote_hw_watchpoint_limit = -1;
int remote_hw_breakpoint_limit = -1;
a4851 2
      else if (remote_hw_breakpoint_limit < 0)
	return 1;
a4858 2
      else if (remote_hw_watchpoint_limit < 0)
	return 1;
a6145 13

  add_setshow_cmd ("hardware-watchpoint-limit", no_class,
		   var_zinteger, &remote_hw_watchpoint_limit, "\
Set the maximum number of target hardware watchpoints.\n\
Specify a negative limit for unlimited.", "\
Show the maximum number of target hardware watchpoints.\n",
		   NULL, NULL, &remote_set_cmdlist, &remote_show_cmdlist);
  add_setshow_cmd ("hardware-breakpoint-limit", no_class,
		   var_zinteger, &remote_hw_breakpoint_limit, "\
Set the maximum number of target hardware breakpoints.\n\
Specify a negative limit for unlimited.", "\
Show the maximum number of target hardware breakpoints.\n",
		   NULL, NULL, &remote_set_cmdlist, &remote_show_cmdlist);
@


1.93.8.3
log
@2003-03-07  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_partial_symbol): Replace uses of
	SYMBOL_MATCHES_NATURAL_NAME by equivalent uses of
	SYMBOL_NATURAL_NAME, strcmp_iw.
	* symtab.h (SYMBOL_MATCHES_NATURAL_NAME): Delete.
	* minsyms.c (lookup_minimal_symbol_linkage): Make static.
	(lookup_minimal_symbol_natural): Ditto.
	(lookup_minimal_symbol): Only search on linkage names; rename
	first argument to 'linkage_name'.
	(lookup_minimal_symbol_linkage): Delete.
	(lookup_minimal_symbol_natural): Delete.
	(add_minsym_to_demangled_hash_table): Go back to using
	SYMBOL_DEMANGLED_NAME instead of SYMBOL_NATURAL_NAME.
	(lookup_minimal_symbol_aux): Don't use
	SYMBOL_MATCHES_NATURAL_NAME: do a strcmp_iw on
	SYMBOL_DEMANGLED_NAME instead.  Add comment.
	(build_minimal_symbol_hash_tables): Go back to only adding to
	demangled has table if SYMBOL_DEMANGLED_NAME is non-NULL.
	* symtab.h: Delete declarations for lookup_minimal_symbol_linkage
	and lookup_minimal_symbol_natural.
	* valops.c (find_function_in_inferior): Use lookup_symbol_linkage
	instead of lookup_symbol.  Change comment.
	* remote.c (remote_check_symbols): Use
	lookup_minimal_symbol_linkage_or_natural instead of
	lookup_minimal_symbol, but add FIXME comment as well.
	* objc-lang.c: Ditto.
	* c-exp.y: Use lookup_minimal_symbol_linkage_or_natural instead of
	lookup_minimal_symbol.
	* p-exp.y: Ditto.
	* objc-exp.y: Ditto.
	* m2-exp.y: Ditto.
	* jv-exp.y (push_expression_name): Ditto.
	* f-exp.y: Ditto.
	* printcmd.c (address_info): Ditto.
	* symtab.h: Declare lookup_minimal_symbol_linkage_or_natural.
	* minsyms.c (lookup_minimal_symbol_linkage_or_natural): New.
	* ax-gdb.c (gen_var_ref): Use SYMBOL_LINKAGE_NAME instead of
	DEPRECATED_SYMBOL_NAME.
	* tracepoint.c (scope_info): Ditto.
	* symtab.c (find_pc_sect_line): Ditto.
	* stabsread.c (define_symbol): Ditto.
	* sol-thread.c (info_cb): Ditto.
	* printcmd.c (address_info): Ditto.
	* hppa-tdep.c (hppa_fix_call_dummy): Ditto.
	(hppa_in_solib_call_trampoline): Ditto.
	* findvar.c (read_var_value): Ditto.
@
text
@d2230 1
a2230 4
      /* FIXME: carlton/2003-03-07: I have no idea if natural names
	 are allowed here; allowing them is safest.  Somebody else
	 should look at this.  */
      sym = lookup_minimal_symbol_linkage_or_natural (msg);
@


1.93.8.4
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@d5751 3
@


1.93.8.5
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d266 1
a266 1
  rs->sizeof_g_packet = DEPRECATED_REGISTER_BYTES; /* OK */
d2954 1
a2954 1
	    char regs[MAX_REGISTER_SIZE];
d3205 1
a3205 1
	    char regs[MAX_REGISTER_SIZE];
d3535 1
a3535 1
				      DEPRECATED_REGISTER_BYTES); /* OK */
d3552 1
a3552 1
  char regp[MAX_REGISTER_SIZE];
d3979 1
a3979 4
  /* Should this be the selected frame?  */
  gdbarch_remote_translate_xfer_address (current_gdbarch, current_regcache,
					 mem_addr, mem_len,
					 &targ_addr, &targ_len);
d4627 5
a4631 6
/* On some machines, e.g. 68k, we may use a different breakpoint
   instruction than other targets; in those use REMOTE_BREAKPOINT
   instead of just BREAKPOINT_FROM_PC.  Also, bi-endian targets may
   define LITTLE_REMOTE_BREAKPOINT and BIG_REMOTE_BREAKPOINT.  If none
   of these are defined, we just call the standard routines that are
   in mem-break.c.  */
d4655 7
a4661 7
/* Insert a breakpoint on targets that don't have any better
   breakpoint support.  We read the contents of the target location
   and stash it, then overwrite it with a breakpoint instruction.
   ADDR is the target location in the target machine.  CONTENTS_CACHE
   is a pointer to memory allocated for saving the target contents.
   It is guaranteed by the caller to be long enough to save the number
   of bytes returned by BREAKPOINT_FROM_PC.  */
@


1.93.8.6
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@a57 2
#include "remote-fileio.h"

d70 4
d131 1
d264 3
a266 4
  if (DEPRECATED_REGISTER_BYTES != 0)
    rs->sizeof_g_packet = DEPRECATED_REGISTER_BYTES;
  else
    rs->sizeof_g_packet = 0;
d277 1
a278 4

      /* Compute packet size by accumulating the size of all registers. */
      if (DEPRECATED_REGISTER_BYTES == 0)
        rs->sizeof_g_packet += register_size (current_gdbarch, regnum);
d1988 2
a1989 4
  offs = ((struct section_offsets *) 
	  alloca (SIZEOF_N_SECTION_OFFSETS (symfile_objfile->num_sections)));
  memcpy (offs, symfile_objfile->section_offsets, 
	  SIZEOF_N_SECTION_OFFSETS (symfile_objfile->num_sections));
d2100 2
a2101 4
      offs = (struct section_offsets *) 
	alloca (SIZEOF_N_SECTION_OFFSETS (symfile_objfile->num_sections));
      memcpy (offs, symfile_objfile->section_offsets, 
	      SIZEOF_N_SECTION_OFFSETS (symfile_objfile->num_sections));
a2420 4
  /* Unregister the file descriptor from the event loop. */
  if (target_is_async_p ())
    serial_async (remote_desc, NULL, 0);

d2424 1
d2427 1
a2427 2
/* Same as remote_detach, but don't send the "D" packet; just disconnect.  */

d2429 1
a2429 1
remote_disconnect (char *args, int from_tty)
d2437 4
a2950 3
	case 'F':		/* File-I/O request */
	  remote_fileio_request (buf);
	  continue;
a3201 3
	case 'F':		/* File-I/O request */
	  remote_fileio_request (buf);
	  continue;
a3525 4
  struct remote_state *rs = get_remote_state ();
  int i;
  char buf[MAX_REGISTER_SIZE];

d3531 5
a3535 4
      /* Make sure all the necessary registers are cached.  */
      for (i = 0; i < NUM_REGS; i++)
	if (rs->regs[i].in_g_packet)
	  regcache_raw_read (current_regcache, rs->regs[i].regnum, buf);
d3756 1
a3756 1
int
d3900 1
a3900 1
int
d4631 10
a4640 10
   instruction than other targets; in those use
   DEPRECATED_REMOTE_BREAKPOINT instead of just BREAKPOINT_FROM_PC.
   Also, bi-endian targets may define
   DEPRECATED_LITTLE_REMOTE_BREAKPOINT and
   DEPRECATED_BIG_REMOTE_BREAKPOINT.  If none of these are defined, we
   just call the standard routines that are in mem-break.c.  */

/* NOTE: cagney/2003-06-08: This is silly.  A remote and simulator
   target should use an identical BREAKPOINT_FROM_PC.  As for native,
   the ARCH-OS-tdep.c code can override the default.  */
d4642 2
a4643 2
#if defined (DEPRECATED_LITTLE_REMOTE_BREAKPOINT) && defined (DEPRECATED_BIG_REMOTE_BREAKPOINT) && !defined(DEPRECATED_REMOTE_BREAKPOINT)
#define DEPRECATED_REMOTE_BREAKPOINT
d4646 1
a4646 1
#ifdef DEPRECATED_REMOTE_BREAKPOINT
d4649 3
a4651 3
#if !defined (DEPRECATED_LITTLE_REMOTE_BREAKPOINT) && !defined (DEPRECATED_BIG_REMOTE_BREAKPOINT)
#define DEPRECATED_LITTLE_REMOTE_BREAKPOINT DEPRECATED_REMOTE_BREAKPOINT
#define DEPRECATED_BIG_REMOTE_BREAKPOINT DEPRECATED_REMOTE_BREAKPOINT
d4654 2
a4655 2
static unsigned char big_break_insn[] = DEPRECATED_BIG_REMOTE_BREAKPOINT;
static unsigned char little_break_insn[] = DEPRECATED_LITTLE_REMOTE_BREAKPOINT;
d4657 1
a4657 1
#endif /* DEPRECATED_REMOTE_BREAKPOINT */
d4671 1
a4671 1
#ifdef DEPRECATED_REMOTE_BREAKPOINT
d4708 1
a4708 1
#ifdef DEPRECATED_REMOTE_BREAKPOINT  
d4724 1
a4724 1
#endif /* DEPRECATED_REMOTE_BREAKPOINT */
d4753 1
a4753 1
#ifdef DEPRECATED_REMOTE_BREAKPOINT
d4757 1
a4757 1
#endif /* DEPRECATED_REMOTE_BREAKPOINT */
d4852 1
a4852 1
static int
d4878 1
a4878 1
static int
d4884 1
a4884 1
static CORE_ADDR
a5428 1
  remote_ops.to_disconnect = remote_disconnect;
a5848 1
  remote_cisco_ops.to_disconnect = remote_disconnect;
d5944 1
a5944 2
  remote_async_ops.to_detach = remote_detach;
  remote_async_ops.to_disconnect = remote_disconnect;
a6273 3

  /* Eventually initialize fileio.  See fileio.c */
  initialize_remote_fileio (remote_set_cmdlist, remote_show_cmdlist);
@


1.93.8.7
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d259 1
a259 1
  struct remote_state *rs = GDBARCH_OBSTACK_ZALLOC (gdbarch, struct remote_state);
d267 1
a267 2
  rs->regs = GDBARCH_OBSTACK_CALLOC (gdbarch, NUM_REGS + NUM_PSEUDO_REGS,
				     struct packet_reg);
d306 8
d2074 1
a2074 1
      fputs_filtered (tmp, gdb_stdlog);
d3030 3
a3032 2
		      error ("Malformed packet(b) (missing colon): %s\nPacket: '%s'\n",
			     p, buf);
d3035 3
a3037 2
		      error ("Remote sent bad register number %s: %s\nPacket: '%s'\n",
			     phex_nz (pnum, 0), p, buf);
d3047 4
a3050 1
		  error ("Remote register badly formatted: %s\nhere: %s", buf, p);
d3253 3
a3255 2
		      error ("Malformed packet(a) (missing colon): %s\nPacket: '%s'\n",
			     p, buf);
d3284 3
a3286 2
		      error ("Malformed packet(b) (missing colon): %s\nPacket: '%s'\n",
			     p, buf);
d3289 3
a3291 2
		      error ("Remote sent bad register number %ld: %s\nPacket: '%s'\n",
			     pnum, p, buf);
d3301 4
a3304 2
		  error ("Remote register badly formatted: %s\nhere: %s",
			 buf, p);
d3774 1
a3780 2
  int payload_size;
  unsigned char *payload_start;
d3782 1
a3782 1
  /* Verify that the target can support a binary download.  */
d3785 3
a3787 3
  /* Compute the size, and then allocate space for the largest
     possible packet.  Include space for an extra trailing NUL.  */
  sizeof_buf = get_memory_write_packet_size () + 1;
d3790 2
a3791 5
  /* Compute the size of the actual payload by subtracting out the
     packet header and footer overhead: "$M<memaddr>,<len>:...#nn".  */
  payload_size = (get_memory_write_packet_size () - (strlen ("$M,:#NN")
						     + hexnumlen (memaddr)
						     + hexnumlen (len)));
d3793 3
a3795 1
  /* Construct the packet header: "[MX]<memaddr>,<len>:".   */
d3797 1
a3797 1
  /* Append "[XM]".  Compute a best guess of the number of bytes
a3798 1
  p = buf;
d3804 1
a3804 1
      todo = min (len, payload_size);
d3809 1
a3809 1
      todo = min (len, payload_size / 2);
d3818 1
a3818 1
  /* Append "<memaddr>".  */
a3820 2

  /* Append ",".  */
d3823 2
a3824 2
  /* Append <len>.  Retain the location/size of <len>.  It may need to
     be adjusted once the packet body has been created.  */
a3827 2

  /* Append ":".  */
d3831 1
a3831 2
  /* Append the packet body.  */
  payload_start = p;
d3839 1
a3839 1
	   (nr_bytes < todo) && (p - payload_start) < payload_size;
d3862 1
d6072 2
a6073 1
  remote_gdbarch_data_handle = register_gdbarch_data (init_remote_state);
@


1.93.8.8
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d274 1
a274 1
      r->offset = DEPRECATED_REGISTER_BYTE (regnum);
@


1.93.8.9
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d164 2
d209 1
a209 1
   Unfortunately, the target stack doesn't include local state.  For
d219 1
a219 1
  /* long size in bytes;  == DEPRECATED_REGISTER_RAW_SIZE (regnum); at present.  */
a751 17
/* Should we try the 'vCont' (descriptive resume) request? */
static struct packet_config remote_protocol_vcont;

static void
set_remote_protocol_vcont_packet_cmd (char *args, int from_tty,
				      struct cmd_list_element *c)
{
  update_packet_config (&remote_protocol_vcont);
}

static void
show_remote_protocol_vcont_packet_cmd (char *args, int from_tty,
				       struct cmd_list_element *c)
{
  show_packet_config_cmd (&remote_protocol_vcont);
}

d1906 1
a2193 1
  update_packet_config (&remote_protocol_vcont);
d2356 1
a2356 1
     caller restore the previous state.  Unfortunately the command
d2510 5
a2514 2
/* Check for the availability of vCont.  This function should also check
   the response.  */
d2517 1
a2517 1
remote_vcont_probe (struct remote_state *rs, char *buf)
d2519 4
a2522 3
  strcpy (buf, "vCont?");
  putpkt (buf);
  getpkt (buf, rs->remote_packet_size, 0);
d2524 4
a2527 5
  /* Make sure that the features we assume are supported.  */
  if (strncmp (buf, "vCont", 5) == 0)
    {
      char *p = &buf[5];
      int support_s, support_S, support_c, support_C;
d2529 2
a2530 15
      support_s = 0;
      support_S = 0;
      support_c = 0;
      support_C = 0;
      while (p && *p == ';')
	{
	  p++;
	  if (*p == 's' && (*(p + 1) == ';' || *(p + 1) == 0))
	    support_s = 1;
	  else if (*p == 'S' && (*(p + 1) == ';' || *(p + 1) == 0))
	    support_S = 1;
	  else if (*p == 'c' && (*(p + 1) == ';' || *(p + 1) == 0))
	    support_c = 1;
	  else if (*p == 'C' && (*(p + 1) == ';' || *(p + 1) == 0))
	    support_C = 1;
d2532 4
a2535 2
	  p = strchr (p, ';');
	}
a2536 5
      /* If s, S, c, and C are not all supported, we can't use vCont.  Clearing
         BUF will make packet_ok disable the packet.  */
      if (!support_s || !support_S || !support_c || !support_C)
	buf[0] = 0;
    }
d2538 4
a2541 2
  packet_ok (buf, &remote_protocol_vcont);
}
d2543 21
a2563 6
/* Resume the remote inferior by using a "vCont" packet.  The thread
   to be resumed is PTID; STEP and SIGGNAL indicate whether the
   resumed thread should be single-stepped and/or signalled.  If PTID's
   PID is -1, then all threads are resumed; the thread to be stepped and/or
   signalled is given in the global INFERIOR_PTID.  This function returns
   non-zero iff it resumes the inferior.
d2565 2
a2566 2
   This function issues a strict subset of all possible vCont commands at the
   moment.  */
d2568 14
a2581 7
static int
remote_vcont_resume (ptid_t ptid, int step, enum target_signal siggnal)
{
  struct remote_state *rs = get_remote_state ();
  int pid = PIDGET (ptid);
  char *buf = NULL;
  struct cleanup *old_cleanup;
d2583 2
a2584 2
  buf = xmalloc (rs->remote_packet_size);
  old_cleanup = make_cleanup (xfree, buf);
d2586 4
a2589 7
  if (remote_protocol_vcont.support == PACKET_SUPPORT_UNKNOWN)
    remote_vcont_probe (rs, buf);

  if (remote_protocol_vcont.support == PACKET_DISABLE)
    {
      do_cleanups (old_cleanup);
      return 0;
d2592 1
a2592 19
  /* If we could generate a wider range of packets, we'd have to worry
     about overflowing BUF.  Should there be a generic
     "multi-part-packet" packet?  */

  if (PIDGET (inferior_ptid) == MAGIC_NULL_PID)
    {
      /* MAGIC_NULL_PTID means that we don't have any active threads, so we
	 don't have any PID numbers the inferior will understand.  Make sure
	 to only send forms that do not specify a PID.  */
      if (step && siggnal != TARGET_SIGNAL_0)
	sprintf (buf, "vCont;S%02x", siggnal);
      else if (step)
	sprintf (buf, "vCont;s");
      else if (siggnal != TARGET_SIGNAL_0)
	sprintf (buf, "vCont;C%02x", siggnal);
      else
	sprintf (buf, "vCont;c");
    }
  else if (pid == -1)
d2594 4
a2597 9
      /* Resume all threads, with preference for INFERIOR_PTID.  */
      if (step && siggnal != TARGET_SIGNAL_0)
	sprintf (buf, "vCont;S%02x:%x;c", siggnal, PIDGET (inferior_ptid));
      else if (step)
	sprintf (buf, "vCont;s:%x;c", PIDGET (inferior_ptid));
      else if (siggnal != TARGET_SIGNAL_0)
	sprintf (buf, "vCont;C%02x:%x;c", siggnal, PIDGET (inferior_ptid));
      else
	sprintf (buf, "vCont;c");
d2600 1
a2600 11
    {
      /* Scheduler locking; resume only PTID.  */
      if (step && siggnal != TARGET_SIGNAL_0)
	sprintf (buf, "vCont;S%02x:%x", siggnal, pid);
      else if (step)
	sprintf (buf, "vCont;s:%x", pid);
      else if (siggnal != TARGET_SIGNAL_0)
	sprintf (buf, "vCont;C%02x:%x", siggnal, pid);
      else
	sprintf (buf, "vCont;c:%x", pid);
    }
a2602 4

  do_cleanups (old_cleanup);

  return 1;
d2605 1
a2605 6
/* Tell the remote machine to resume.  */

static enum target_signal last_sent_signal = TARGET_SIGNAL_0;

static int last_sent_step;

d2607 1
a2607 1
remote_resume (ptid_t ptid, int step, enum target_signal siggnal)
d2614 5
a2626 10
  /* The vCont packet doesn't need to specify threads via Hc.  */
  if (remote_vcont_resume (ptid, step, siggnal))
    return;

  /* All other supported resume packets do use Hc, so call set_thread.  */
  if (pid == -1)
    set_thread (0, 0);		/* run any thread */
  else
    set_thread (pid, 0);	/* run this thread */

d2658 1
a2658 1
		return;
d2676 1
a2676 1
		return;
d2685 1
a2685 1
      buf[2] = tohex (((int) siggnal) & 0xf);
d2690 1
a2690 1

a2691 7
}

/* Same as remote_resume, but with async support. */
static void
remote_async_resume (ptid_t ptid, int step, enum target_signal siggnal)
{
  remote_resume (ptid, step, siggnal);
d2693 1
d3030 1
a3030 1
		    fieldsize = hex2bin (p, regs, DEPRECATED_REGISTER_RAW_SIZE (reg->regnum));
d3032 1
a3032 1
		    if (fieldsize < DEPRECATED_REGISTER_RAW_SIZE (reg->regnum))
d3278 1
a3278 1
		    fieldsize = hex2bin (p, regs, DEPRECATED_REGISTER_RAW_SIZE (reg->regnum));
d3280 1
a3280 1
		    if (fieldsize < DEPRECATED_REGISTER_RAW_SIZE (reg->regnum))
d3419 1
d3556 1
a3556 1
  bin2hex (regp, p, DEPRECATED_REGISTER_RAW_SIZE (reg->regnum));
d3973 1
d3998 67
d5116 2
a5117 4
static LONGEST
remote_xfer_partial (struct target_ops *ops, enum target_object object,
		     const char *annex, void *readbuf, const void *writebuf,
		     ULONGEST offset, LONGEST len)
a5122 1
  char query_type;
d5124 7
a5130 7
  /* Only handle reads.  */
  if (writebuf != NULL || readbuf == NULL)
    return -1;

  /* Map pre-existing objects onto letters.  DO NOT do this for new
     objects!!!  Instead specify new query packets.  */
  switch (object)
d5132 1
a5132 7
    case TARGET_OBJECT_KOD:
      query_type = 'K';
      break;
    case TARGET_OBJECT_AVR:
      query_type = 'R';
      break;
    default:
a5135 10
  /* Note: a zero OFFSET and LEN can be used to query the minimum
     buffer size.  */
  if (offset == 0 && len == 0)
    return (rs->remote_packet_size);
  /* Minimum outbuf size is (rs->remote_packet_size) - if bufsiz is
     not large enough let the caller.  */
  if (len < (rs->remote_packet_size))
    return -1;
  len = rs->remote_packet_size;

d5140 11
a5150 2
  gdb_assert (annex != NULL);
  gdb_assert (readbuf != NULL);
d5160 1
a5160 1
  while (annex[i] && (i < ((rs->remote_packet_size) - 8)))
d5162 5
a5166 3
      /* Bad caller may have sent forbidden characters.  */
      gdb_assert (isprint (annex[i]) && annex[i] != '$' && annex[i] != '#');
      *p2++ = annex[i];
d5169 4
a5172 2
  *p2 = '\0';
  gdb_assert (annex[i] == '\0');
d5178 1
a5178 1
  getpkt (readbuf, len, 0);
d5180 1
a5180 1
  return strlen (readbuf);
d5458 1
a5458 1
  remote_ops.to_xfer_partial = remote_xfer_partial;
d5978 1
a5978 1
  remote_async_ops.to_xfer_partial = remote_xfer_partial;
a6027 1
  show_remote_protocol_vcont_packet_cmd (args, from_tty, NULL);
a6199 7

  add_packet_config_cmd (&remote_protocol_vcont,
			 "vCont", "verbose-resume",
			 set_remote_protocol_vcont_packet_cmd,
			 show_remote_protocol_vcont_packet_cmd,
			 &remote_set_cmdlist, &remote_show_cmdlist,
			 0);
@


1.93.8.10
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@a2304 4
	  /* The requested speed could not be set.  Error out to
	     top level after closing remote_desc.  Take care to
	     set remote_desc to NULL to avoid closing remote_desc
	     more than once.  */
a2305 1
	  remote_desc = NULL;
d3564 3
a3566 17
	    if (r->offset * 2 >= strlen (buf))
	      /* A short packet that didn't include the register's
                 value, this implies that the register is zero (and
                 not that the register is unavailable).  Supply that
                 zero value.  */
	      regcache_raw_supply (current_regcache, r->regnum, NULL);
	    else if (buf[r->offset * 2] == 'x')
	      {
		gdb_assert (r->offset * 2 < strlen (buf));
		/* The register isn't available, mark it as such (at
                   the same time setting the value to zero).  */
		regcache_raw_supply (current_regcache, r->regnum, NULL);
		set_register_cached (i, -1);
	      }
	    else
	      regcache_raw_supply (current_regcache, r->regnum,
				   regs + r->offset);
a5557 4
      /* The requested speed could not be set.  Error out to
	 top level after closing remote_desc.  Take care to
	 set remote_desc to NULL to avoid closing remote_desc
	 more than once.  */
a5558 1
      remote_desc = NULL;
@


1.93.8.11
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d4 1
a4 2
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
d1164 4
d1579 13
d2589 1
a2589 1
  char *buf = NULL, *outbuf;
d2614 1
a2614 1
	outbuf = xstrprintf ("vCont;S%02x", siggnal);
d2616 1
a2616 1
	outbuf = xstrprintf ("vCont;s");
d2618 1
a2618 1
	outbuf = xstrprintf ("vCont;C%02x", siggnal);
d2620 1
a2620 1
	outbuf = xstrprintf ("vCont;c");
d2626 1
a2626 2
	outbuf = xstrprintf ("vCont;S%02x:%x;c", siggnal,
			     PIDGET (inferior_ptid));
d2628 1
a2628 1
	outbuf = xstrprintf ("vCont;s:%x;c", PIDGET (inferior_ptid));
d2630 1
a2630 2
	outbuf = xstrprintf ("vCont;C%02x:%x;c", siggnal,
			     PIDGET (inferior_ptid));
d2632 1
a2632 1
	outbuf = xstrprintf ("vCont;c");
d2638 1
a2638 1
	outbuf = xstrprintf ("vCont;S%02x:%x", siggnal, pid);
d2640 1
a2640 1
	outbuf = xstrprintf ("vCont;s:%x", pid);
d2642 1
a2642 1
	outbuf = xstrprintf ("vCont;C%02x:%x", siggnal, pid);
d2644 1
a2644 1
	outbuf = xstrprintf ("vCont;c:%x", pid);
d2647 1
a2647 4
  gdb_assert (outbuf && strlen (outbuf) < rs->remote_packet_size);
  make_cleanup (xfree, outbuf);

  putpkt (outbuf);
@


1.93.4.1
log
@2002-08-28  Andrew Cagney  <cagney@@redhat.com>

	* osabi.c (gdbarch_init_osabi): Allow a NULL abfd.
	(gdb_osabi_names): Add "RedBoot".
	* osabi.h (gdb_osabi): Add GDB_OSABI_REDBOOT.
	* i386-tdep.c (i386_gdbarch_init): Force RedBoot OSABI.

	* i386-tdep.h (i386_pseudo_register_read): Declare.
	(i386_pseudo_register_write): Declare.
	(i386_register_virtual_type): Declare.
	(i386_register_reggroup_p): Declare.
	* i386-tdep.c (i386_pseudo_register_read): Make global.
	(i386_pseudo_register_write): Make global.
	(i386_register_reggroup_p): Make global.
	(i386_register_virtual_type): Make global.

	* config/i386/embed.mt (TDEPFILES): Add i386-rb-tdep.c.
	(TM_FILE): Set to tm-embed.h.
	* config/i386/tm-embed.h: New file.
	* i386-rb-tdep.c: New file.  Based on code by Fernando Nasser.

	* remote.c (remote_fetch_registers): Call fetch_register_using_p.
	(fetch_register_using_p): New function.
	(init_remote_state): If defined, use GPACKET_UPPER_BOUND_HACK to
	identify a register that isn't in the G packet.
@
text
@a275 3
#ifdef GPACKET_UPPER_BOUND_HACK
      r->in_g_packet = (regnum < GPACKET_UPPER_BOUND_HACK (gdbarch));
#else
a276 1
#endif
a3418 59
/* Helper for remote_fetch_registers.  Fetch a register using the
   ``p'' packet.  */

static void
fetch_register_using_p (int regnum)
{
  struct remote_state *rs = get_remote_state ();
  char *regs;
  char *buf;
  int i;
  char *p;

  buf = alloca (rs->remote_packet_size);
  sprintf (buf, "p%x", regnum);
  remote_send (buf, rs->remote_packet_size);

  /* We can get out of synch in various cases.  If the first character
     in the buffer is not a hex character, assume that has happened
     and try to fetch another packet to read.  */
  while ((buf[0] < '0' || buf[0] > '9')
	 && (buf[0] < 'a' || buf[0] > 'f')
	 && buf[0] != 'x')	/* New: unavailable register value */
    {
      if (remote_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "Bad register packet; fetching a new packet\n");
      getpkt (buf, rs->remote_packet_size, 0);
    }

  /* Reply describes registers byte by byte, each byte encoded as two
     hex characters.  Suck them all up, then supply them to the
     register cacheing/storage mechanism.  */

  regs = alloca (REGISTER_RAW_SIZE (regnum));
  memset (regs, REGISTER_RAW_SIZE (regnum), 0);
  p = buf;
  for (i = 0; i < REGISTER_RAW_SIZE (regnum); i++)
    {
      if (p[0] == 0)
	break;
      if (p[1] == 0)
	{
	  warning ("Remote reply is of odd length: %s", buf);
	  /* Don't change register_bytes_found in this case, and don't
	     print a second warning.  */
	  break;
	}
      if (p[0] == 'x' && p[1] == 'x')
	regs[i] = 0;		/* 'x' */
      else
	regs[i] = fromhex (p[0]) * 16 + fromhex (p[1]);
      p += 2;
    }

  supply_register (regnum, &regs[0]);
  if (buf[0] == 'x')
    register_valid[i] = -1;	/* register value not available */
}

a3437 7
#if 1
      if (!reg->in_g_packet)
	{
	  fetch_register_using_p (regnum);
	  return;
	}
#else
a3441 1
#endif
@


1.92
log
@	* remote.c (remote_insert_hw_breakpoint)
	(remote_remove_hw_breakpoint): Fix calculation of length field
	for Z-packet.
@
text
@d97 2
a98 3
static void remote_open_1 (char *, int, struct target_ops *, int extended_p);
static void remote_async_open_1 (char *, int, struct target_ops *,
				 int extended_p);
a206 4
/* Define the target subroutine names */

void open_remote_target (char *, int, struct target_ops *, int);

d2158 1
a2158 1
  remote_open_1 (name, from_tty, &remote_ops, 0);
d2165 1
a2165 1
  remote_async_open_1 (name, from_tty, &remote_async_ops, 0);
d2174 2
a2175 1
  remote_open_1 (name, from_tty, &extended_remote_ops, 1 /*extended_p */ );
d2182 2
a2183 1
  remote_async_open_1 (name, from_tty, &extended_async_remote_ops, 1 /*extended_p */ );
d2264 1
a2264 1
	       int extended_p)
d2274 2
a2275 1
  wait_forever_enabled_p = 1;
d2325 16
d2369 2
d2374 2
a2375 117
  if (extended_p)
    {
      /* Tell the remote that we are using the extended protocol.  */
      char *buf = alloca (rs->remote_packet_size);
      putpkt ("!");
      getpkt (buf, (rs->remote_packet_size), 0);
    }
#ifdef SOLIB_CREATE_INFERIOR_HOOK
  /* FIXME: need a master target_open vector from which all 
     remote_opens can be called, so that stuff like this can 
     go there.  Failing that, the following code must be copied
     to the open function for any remote target that wants to 
     support svr4 shared libraries.  */

  /* Set up to detect and load shared libraries. */
  if (exec_bfd) 	/* No use without an exec file. */
    {
      SOLIB_CREATE_INFERIOR_HOOK (PIDGET (inferior_ptid));
      remote_check_symbols (symfile_objfile);
    }
#endif
}

/* Just like remote_open but with asynchronous support. */
static void
remote_async_open_1 (char *name, int from_tty, struct target_ops *target,
		     int extended_p)
{
  int ex;
  struct remote_state *rs = get_remote_state ();
  if (name == 0)
    error ("To open a remote debug connection, you need to specify what\n"
	   "serial device is attached to the remote system\n"
	   "(e.g. /dev/ttyS0, /dev/ttya, COM1, etc.).");

  target_preopen (from_tty);

  unpush_target (target);

  remote_desc = remote_serial_open (name);
  if (!remote_desc)
    perror_with_name (name);

  if (baud_rate != -1)
    {
      if (serial_setbaudrate (remote_desc, baud_rate))
	{
	  serial_close (remote_desc);
	  perror_with_name (name);
	}
    }

  serial_raw (remote_desc);

  /* If there is something sitting in the buffer we might take it as a
     response to a command, which would be bad.  */
  serial_flush_input (remote_desc);

  if (from_tty)
    {
      puts_filtered ("Remote debugging using ");
      puts_filtered (name);
      puts_filtered ("\n");
    }

  push_target (target);		/* Switch to using remote target now */

  init_all_packet_configs ();

  general_thread = -2;
  continue_thread = -2;

  /* Probe for ability to use "ThreadInfo" query, as required.  */
  use_threadinfo_query = 1;
  use_threadextra_query = 1;

  /* Without this, some commands which require an active target (such
     as kill) won't work.  This variable serves (at least) double duty
     as both the pid of the target process (if it has such), and as a
     flag indicating that a target is active.  These functions should
     be split out into seperate variables, especially since GDB will
     someday have a notion of debugging several processes.  */
  inferior_ptid = pid_to_ptid (MAGIC_NULL_PID);

  /* With this target we start out by owning the terminal. */
  remote_async_terminal_ours_p = 1;

  /* FIXME: cagney/1999-09-23: During the initial connection it is
     assumed that the target is already ready and able to respond to
     requests. Unfortunately remote_start_remote() eventually calls
     wait_for_inferior() with no timeout.  wait_forever_enabled_p gets
     around this. Eventually a mechanism that allows
     wait_for_inferior() to expect/get timeouts will be
     implemented. */
  wait_forever_enabled_p = 0;

#ifdef SOLIB_CREATE_INFERIOR_HOOK
  /* First delete any symbols previously loaded from shared libraries. */
  no_shared_libraries (NULL, 0);
#endif

  /* Start the remote connection; if error, discard this target.  See
     the comments in remote_open_1() for further details such as the
     need to re-throw the exception.  */
  ex = catch_exceptions (uiout,
			 remote_start_remote, NULL,
			 "Couldn't establish connection to remote"
			 " target\n",
			 RETURN_MASK_ALL);
  if (ex < 0)
    {
      pop_target ();
      wait_forever_enabled_p = 1;
      throw_exception (ex);
    }

  wait_forever_enabled_p = 1;
a4978 12
}

/* Other targets want to use the entire remote serial module but with
   certain remote_ops overridden. */

void
open_remote_target (char *name, int from_tty, struct target_ops *target,
		    int extended_p)
{
  printf_filtered ("Selecting the %sremote protocol\n",
		   (extended_p ? "extended-" : ""));
  remote_open_1 (name, from_tty, target, extended_p);
@


1.91
log
@        * remote.c: (remote_wait, remote_async_wait): Add check for awatch
        T-packets; the 'a' is not taken as a register number.
	(remote_check_watch_resources, remote_stopped_by_watchpoint)
        (remote_stopped_data_address): New functions; add to target
        vector.
        (remote_insert_hw_breakpoint, remote_remove_hw_breakpoint): Change
        prototypes to match other implementations of this
        function. replace integer argument with pointer -- the length
        field in the Z-packet is the length of what is pointed to or 1 if
        pointer is null. Add to target vector.
        (remote_insert_watchpoint, remote_remove_watchpoint): Add to
        target vector.

        From Mark Salter:
        * remote.c (remote_wait): Add support to extract optional
        watchpoint information from T-packet. Ignore unrecognized
        optional info in T-packet.
        (remote_async_wait): Ditto.
doc:
	From Mark Salter:
	* gdb.texinfo (Protocol): Document T packet extension to
	allow watchpoint address reporting.
@
text
@d4988 4
a4991 2
  /* The length field should be set to soething so that the packet is
     well formed.  */
a4992 2
  len = strlen (shadow);
  len = len ? len : 1;
d5029 6
a5034 2
  
  len = sizeof (shadow);
@


1.90
log
@* remote.c (remote_wait, remote_async_wait): Change
thread_num from int to ULONGEST.
(unpack_varlen_hex): Change result parameter from
int * to ULONGEST *.
@
text
@d253 1
d344 11
a354 1
/* */
d3022 1
d3040 2
d3065 5
d3071 11
a3081 3
		/* Read the ``P'' register number.  */
		LONGEST pnum = strtol ((const char *) p, &p_temp, 16);
		p1 = (unsigned char *) p_temp;
d3085 1
a3085 1
		    p1 = (unsigned char *) strchr ((const char *) p, ':');
d3090 1
a3090 1
		    if (strncmp ((const char *) p, "thread", p1 - p) == 0)
d3096 15
d3267 1
d3272 2
d3316 1
d3318 15
a3332 3
		/* Read the register number */
		long pnum = strtol ((const char *) p, &p_temp, 16);
		p1 = (unsigned char *) p_temp;
d3336 1
a3336 1
		    p1 = (unsigned char *) strchr ((const char *) p, ':');
d3341 1
a3341 1
		    if (strncmp ((const char *) p, "thread", p1 - p) == 0)
d3347 15
d3363 1
d4871 1
a4871 4
/* FIXME: This function should be static and a member of the remote
   target vector. */

int
a4904 2
/* FIXME: This function should be static and a member of the remote
   target vector. */
d4906 1
a4906 1
int
d4939 3
a4941 2
/* FIXME: This function should be static and a member of the remote
   target vector. */
d4944 1
a4944 1
remote_insert_hw_breakpoint (CORE_ADDR addr, int len)
d4946 38
d4988 5
d5018 1
a5018 1
		  "remote_remove_watchpoint: reached end of function");
a5020 2
/* FIXME: This function should be static and a member of the remote
   target vector. */
d5022 2
a5023 2
int 
remote_remove_hw_breakpoint (CORE_ADDR addr, int len)
d5025 1
d5030 1
d5056 1
a5056 1
		  "remote_remove_watchpoint: reached end of function");
d5533 7
d5955 8
a5962 1
  remote_cisco_ops.to_remove_breakpoint = remote_remove_breakpoint;
d6052 7
@


1.89
log
@Fix error check in remote_read_bytes
@
text
@d1110 1
a1110 1
char *unpack_varlen_hex (char *buff, int *result);
d1231 1
a1231 1
		   int *result)
d3010 1
a3010 1
  int thread_num = -1;
d3224 1
a3224 1
  int thread_num = -1;
@


1.88
log
@Fix some K&R isms.
@
text
@d3956 3
a3958 1
      if (buf[0] == 'E')
@


1.87
log
@* command.h (add_setshow_auto_boolean_cmd): Replace
add_set_auto_boolean_cmd.
* cli/cli-decode.c (add_setshow_auto_boolean_cmd): Replace
add_set_auto_boolean_cmd.
* cli/cli-decode.h (add_set_auto_boolean_cmd): Delete declaration.
* mips-tdep.c (_initialize_mips_tdep): Update ``set mips
mask-address'' command.
(show_mask_address): Add cmd parameter.
* remote.c (add_packet_config_cmd): Update.  Change type of
set_func and show_func to cmd_sfunc_ftype.
(_initialize_remote): Update `set remote Z-packet'
(show_remote_protocol_qSymbol_packet_cmd): Add cmd parameter.
(show_remote_protocol_e_packet_cmd): Ditto.
(show_remote_protocol_E_packet_cmd): Ditto.
(show_remote_protocol_P_packet_cmd): Ditto.
(show_remote_protocol_Z_software_bp_packet_cmd): Ditto.
(show_remote_protocol_Z_hardware_bp_packet_cmd): Ditto.
(show_remote_protocol_Z_write_wp_packet_cmd): Ditto.
(show_remote_protocol_Z_read_wp_packet_cmd): Ditto.
(show_remote_protocol_Z_access_wp_packet_cmd): Ditto.
(show_remote_protocol_Z_packet_cmd): Ditto.
(show_remote_protocol_binary_download_cmd): Ditto.
(show_remote_cmd): Pass NULL to all of above.
@
text
@d257 1
a257 1
get_remote_state ()
@


1.86
log
@* cli/cli-decode.c (add_setshow_boolean_cmd): Replace
add_set_boolean_cmd.
(add_setshow_cmd): New function.
* command.h (add_setshow_boolean_cmd): Replace
add_set_boolean_cmd.
* remote-rdi.c (_initialize_remote_rdi): Update ``set rdiheartbeat''
and ``set rdiromatzero''.
* maint.c (_initialize_maint_cmds): Update commented out code.
* cli/cli-decode.h (add_set_boolean_cmd): Delete declaration.
* target.c (initialize_targets): Update `set
trust-readonly-sections'.
* remote.c (_initialize_remote): Update `set remotebreak'.
@
text
@d651 2
a652 5
		       void (*set_func) (char *args, int from_tty,
					 struct cmd_list_element *
					 c),
		       void (*show_func) (char *name,
					  int from_tty),
d672 4
a675 6
  set_cmd = add_set_auto_boolean_cmd (cmd_name, class_obscure,
				&config->detect, set_doc,
				set_remote_list);
  set_cmd_sfunc (set_cmd, set_func);
  show_cmd = add_cmd (cmd_name, class_obscure, show_func, show_doc,
		      show_remote_list);
d763 2
a764 1
show_remote_protocol_qSymbol_packet_cmd (char *args, int from_tty)
d780 2
a781 1
show_remote_protocol_e_packet_cmd (char *args, int from_tty)
d798 2
a799 1
show_remote_protocol_E_packet_cmd (char *args, int from_tty)
d817 2
a818 1
show_remote_protocol_P_packet_cmd (char *args, int from_tty)
d848 2
a849 1
show_remote_protocol_Z_software_bp_packet_cmd (char *args, int from_tty)
d862 2
a863 1
show_remote_protocol_Z_hardware_bp_packet_cmd (char *args, int from_tty)
d876 2
a877 1
show_remote_protocol_Z_write_wp_packet_cmd (char *args, int from_tty)
d890 2
a891 1
show_remote_protocol_Z_read_wp_packet_cmd (char *args, int from_tty)
d904 2
a905 1
show_remote_protocol_Z_access_wp_packet_cmd (char *args, int from_tty)
d928 2
a929 1
show_remote_protocol_Z_packet_cmd (char *args, int from_tty)
d970 2
a971 2
show_remote_protocol_binary_download_cmd (char *args,
					  int from_tty)
d5976 8
a5983 7
  
  show_remote_protocol_Z_packet_cmd (args, from_tty);
  show_remote_protocol_e_packet_cmd (args, from_tty);
  show_remote_protocol_E_packet_cmd (args, from_tty);
  show_remote_protocol_P_packet_cmd (args, from_tty);
  show_remote_protocol_qSymbol_packet_cmd (args, from_tty);
  show_remote_protocol_binary_download_cmd (args, from_tty);
d6216 7
a6222 8
  tmpcmd = add_set_auto_boolean_cmd ("Z-packet", class_obscure,
				     &remote_Z_packet_detect,
				     "\
Set use of remote protocol `Z' packets", &remote_set_cmdlist);
  set_cmd_sfunc (tmpcmd, set_remote_protocol_Z_packet_cmd);
  add_cmd ("Z-packet", class_obscure, show_remote_protocol_Z_packet_cmd,
	   "Show use of remote protocol `Z' packets ",
	   &remote_show_cmdlist);
@


1.85
log
@* defs.h (auto_boolean): Declare enum.
* command.h (cmd_auto_boolean): Delete enum.
* mips-tdep.c (mask_address_var): Update.
(mips_mask_address_p): Update.
(show_mask_address): Update.
* remote.c (struct packet_config): Update.
(update_packet_config): Update.
(show_packet_config_cmd): Update.
(packet_ok): Update.
(add_packet_config_cmd): Update.
(_initialize_remote):
* command.h: Update.
* cli/cli-setshow.c (parse_auto_binary_operation): Update.
(do_setshow_command): Update.
* cli/cli-decode.c (add_set_auto_boolean_cmd): Update.
* cli/cli-decode.h: Update.
@
text
@d6072 5
a6076 5
  add_show_from_set
    (add_set_boolean_cmd ("remotebreak", no_class, &remote_break,
			  "Set whether to send break if interrupted.\n",
			  &setlist),
     &showlist);
@


1.84
log
@From Fernando Nasser:
* remote.c (remote_async_open_1): Re-throw the exception when the
connection fails.
(remote_cisco_open): Ditto.
(remote_open_1): Ditto.
@
text
@d586 1
a586 1
    enum cmd_auto_boolean detect;
d605 1
a605 1
    case CMD_AUTO_BOOLEAN_TRUE:
d608 1
a608 1
    case CMD_AUTO_BOOLEAN_FALSE:
d611 1
a611 1
    case CMD_AUTO_BOOLEAN_AUTO:
d635 1
a635 1
    case CMD_AUTO_BOOLEAN_AUTO:
d639 2
a640 2
    case CMD_AUTO_BOOLEAN_TRUE:
    case CMD_AUTO_BOOLEAN_FALSE:
d667 1
a667 1
  config->detect = CMD_AUTO_BOOLEAN_AUTO;
d733 1
a733 1
	  if (config->detect == CMD_AUTO_BOOLEAN_AUTO)
d909 1
a909 1
static enum cmd_auto_boolean remote_Z_packet_detect;
d6153 1
a6153 1
  remote_protocol_e.detect = CMD_AUTO_BOOLEAN_FALSE;
d6164 1
a6164 1
  remote_protocol_E.detect = CMD_AUTO_BOOLEAN_FALSE;
@


1.84.2.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d586 1
a586 1
    enum auto_boolean detect;
d605 1
a605 1
    case AUTO_BOOLEAN_TRUE:
d608 1
a608 1
    case AUTO_BOOLEAN_FALSE:
d611 1
a611 1
    case AUTO_BOOLEAN_AUTO:
d635 1
a635 1
    case AUTO_BOOLEAN_AUTO:
d639 2
a640 2
    case AUTO_BOOLEAN_TRUE:
    case AUTO_BOOLEAN_FALSE:
d651 5
a655 2
		       cmd_sfunc_ftype *set_func,
		       cmd_sfunc_ftype *show_func,
d667 1
a667 1
  config->detect = AUTO_BOOLEAN_AUTO;
d675 6
a680 4
  add_setshow_auto_boolean_cmd (cmd_name, class_obscure,
				&config->detect, set_doc, show_doc,
				set_func, show_func,
				set_remote_list, show_remote_list);
d733 1
a733 1
	  if (config->detect == AUTO_BOOLEAN_AUTO)
d768 1
a768 2
show_remote_protocol_qSymbol_packet_cmd (char *args, int from_tty,
					 struct cmd_list_element *c)
d784 1
a784 2
show_remote_protocol_e_packet_cmd (char *args, int from_tty,
				   struct cmd_list_element *c)
d801 1
a801 2
show_remote_protocol_E_packet_cmd (char *args, int from_tty,
				   struct cmd_list_element *c)
d819 1
a819 2
show_remote_protocol_P_packet_cmd (char *args, int from_tty,
				   struct cmd_list_element *c)
d849 1
a849 2
show_remote_protocol_Z_software_bp_packet_cmd (char *args, int from_tty,
					       struct cmd_list_element *c)
d862 1
a862 2
show_remote_protocol_Z_hardware_bp_packet_cmd (char *args, int from_tty,
					       struct cmd_list_element *c)
d875 1
a875 2
show_remote_protocol_Z_write_wp_packet_cmd (char *args, int from_tty,
					    struct cmd_list_element *c)
d888 1
a888 2
show_remote_protocol_Z_read_wp_packet_cmd (char *args, int from_tty,
					   struct cmd_list_element *c)
d901 1
a901 2
show_remote_protocol_Z_access_wp_packet_cmd (char *args, int from_tty,
					     struct cmd_list_element *c)
d909 1
a909 1
static enum auto_boolean remote_Z_packet_detect;
d924 1
a924 2
show_remote_protocol_Z_packet_cmd (char *args, int from_tty,
				   struct cmd_list_element *c)
d965 2
a966 2
show_remote_protocol_binary_download_cmd (char *args, int from_tty,
					  struct cmd_list_element *c)
d5971 7
a5977 8
  /* FIXME: cagney/2002-06-15: This function should iterate over
     remote_show_cmdlist for a list of sub commands to show.  */
  show_remote_protocol_Z_packet_cmd (args, from_tty, NULL);
  show_remote_protocol_e_packet_cmd (args, from_tty, NULL);
  show_remote_protocol_E_packet_cmd (args, from_tty, NULL);
  show_remote_protocol_P_packet_cmd (args, from_tty, NULL);
  show_remote_protocol_qSymbol_packet_cmd (args, from_tty, NULL);
  show_remote_protocol_binary_download_cmd (args, from_tty, NULL);
d6072 5
a6076 5
  add_setshow_boolean_cmd ("remotebreak", no_class, &remote_break,
			   "Set whether to send break if interrupted.\n",
			   "Show whether to send break if interrupted.\n",
			   NULL, NULL,
			   &setlist, &showlist);
d6153 1
a6153 1
  remote_protocol_e.detect = AUTO_BOOLEAN_FALSE;
d6164 1
a6164 1
  remote_protocol_E.detect = AUTO_BOOLEAN_FALSE;
d6210 8
a6217 7
  add_setshow_auto_boolean_cmd ("Z-packet", class_obscure,
				&remote_Z_packet_detect, "\
Set use of remote protocol `Z' packets",
				"Show use of remote protocol `Z' packets ",
				set_remote_protocol_Z_packet_cmd,
				show_remote_protocol_Z_packet_cmd,
				&remote_set_cmdlist, &remote_show_cmdlist);
@


1.84.2.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d257 1
a257 1
get_remote_state (void)
@


1.84.2.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@a252 1

d343 1
a343 11
/* FIXME: graces/2002-08-08: These variables should eventually be
   bound to an instance of the target object (as in gdbarch-tdep()),
   when such a thing exists.  */

/* This is set to the data address of the access causing the target
   to stop for a watchpoint.  */
static CORE_ADDR remote_watch_data_address;

/* This is non-zero if taregt stopped for a watchpoint. */
static int remote_stopped_by_watchpoint_p;

d1110 1
a1110 1
char *unpack_varlen_hex (char *buff, ULONGEST *result);
d1231 1
a1231 1
		   ULONGEST *result)
d3010 1
a3010 2
  ULONGEST thread_num = -1;
  ULONGEST addr;
a3027 2
      remote_stopped_by_watchpoint_p = 0;

a3050 8
		LONGEST pnum = 0;

		/* If the packet contains a register number save it in pnum
		   and set p1 to point to the character following it. 
		   Otherwise p1 points to p.  */

		/* If this packet is an awatch packet, don't parse the 'a'
		   as a register number.  */
d3052 3
a3054 8
		if (strncmp (p, "awatch", strlen("awatch")) != 0)
		  {
		    /* Read the ``P'' register number.  */
		    pnum = strtol (p, &p_temp, 16);
		    p1 = (unsigned char *) p_temp;
		  }
		else 
		  p1 = p;
d3058 1
a3058 1
		    p1 = (unsigned char *) strchr (p, ':');
d3063 1
a3063 1
		    if (strncmp (p, "thread", p1 - p) == 0)
a3068 15
		    else if ((strncmp (p, "watch", p1 - p) == 0)
			     || (strncmp (p, "rwatch", p1 - p) == 0)
			     || (strncmp (p, "awatch", p1 - p) == 0))
		      {
			remote_stopped_by_watchpoint_p = 1;
			p = unpack_varlen_hex (++p1, &addr);
			remote_watch_data_address = (CORE_ADDR)addr;
		      }
		    else
 		      {
 			/* Silently skip unknown optional info.  */
 			p_temp = strchr (p1 + 1, ';');
 			if (p_temp)
			  p = (unsigned char *) p_temp;
 		      }
d3224 1
a3224 2
  ULONGEST thread_num = -1;
  ULONGEST addr;
a3228 2
  remote_stopped_by_watchpoint_p = 0;

a3270 1
		long pnum = 0;
d3272 3
a3274 15
		/* If the packet contains a register number, save it in pnum
		   and set p1 to point to the character following it. 
		   Otherwise p1 points to p.  */

		/* If this packet is an awatch packet, don't parse the 'a'
		   as a register number.  */
		
		if (!strncmp (p, "awatch", strlen ("awatch")) != 0)
		  {
		    /* Read the register number.  */
		    pnum = strtol (p, &p_temp, 16);
		    p1 = (unsigned char *) p_temp;
		  }
		else 
		  p1 = p;
d3278 1
a3278 1
		    p1 = (unsigned char *) strchr (p, ':');
d3283 1
a3283 1
		    if (strncmp (p, "thread", p1 - p) == 0)
a3288 15
		    else if ((strncmp (p, "watch", p1 - p) == 0)
			     || (strncmp (p, "rwatch", p1 - p) == 0)
			     || (strncmp (p, "awatch", p1 - p) == 0))
		      {
			remote_stopped_by_watchpoint_p = 1;
			p = unpack_varlen_hex (++p1, &addr);
			remote_watch_data_address = (CORE_ADDR)addr;
		      }
		    else
 		      {
 			/* Silently skip unknown optional info.  */
 			p_temp = (unsigned char *) strchr (p1 + 1, ';');
 			if (p_temp)
			  p = p_temp;
 		      }
a3289 1
		
d3956 1
a3956 3
      if (buf[0] == 'E'
	  && isxdigit (buf[1]) && isxdigit (buf[2])
	  && buf[3] == '\0')
d4795 4
a4798 1
static int
d4832 2
d4835 1
a4835 1
static int
d4868 2
a4869 25

int remote_hw_watchpoint_limit = 0;
int remote_hw_breakpoint_limit = 0;

int
remote_check_watch_resources (int type, int cnt, int ot)
{
  if (type == bp_hardware_breakpoint)
    {
      if (remote_hw_breakpoint_limit == 0)
	return 0;
      else if (cnt <= remote_hw_breakpoint_limit)
	return 1;
    }
  else
    {
      if (remote_hw_watchpoint_limit == 0)
	return 0;
      else if (ot)
	return -1;
      else if (cnt <= remote_hw_watchpoint_limit)
	return 1;
    }
  return -1;
}
d4872 1
a4872 1
remote_stopped_by_watchpoint (void)
a4873 16
    return remote_stopped_by_watchpoint_p;
}

CORE_ADDR
remote_stopped_data_address (void)
{
  if (remote_stopped_by_watchpoint ())
    return remote_watch_data_address;
  return (CORE_ADDR)0;
}


static int
remote_insert_hw_breakpoint (CORE_ADDR addr, char *shadow)
{
  int len = 0;
a4877 5
  /* The length field should be set to soething so that the packet is
     well formed.  */

  len = strlen (shadow);
  len = len ? len : 1;
d4903 1
a4903 1
		  "remote_insert_hw_breakpoint: reached end of function");
d4906 2
d4909 2
a4910 2
static int 
remote_remove_hw_breakpoint (CORE_ADDR addr, char *shadow)
a4911 1
  int len;
a4915 1
  len = sizeof (shadow);
d4941 1
a4941 1
		  "remote_remove_hw_breakpoint: reached end of function");
a5417 7
  remote_ops.to_stopped_by_watchpoint = remote_stopped_by_watchpoint;
  remote_ops.to_stopped_data_address = remote_stopped_data_address;
  remote_ops.to_can_use_hw_breakpoint = remote_check_watch_resources;
  remote_ops.to_insert_hw_breakpoint = remote_insert_hw_breakpoint;
  remote_ops.to_remove_hw_breakpoint = remote_remove_hw_breakpoint;
  remote_ops.to_insert_watchpoint = remote_insert_watchpoint;
  remote_ops.to_remove_watchpoint = remote_remove_watchpoint;
d5833 1
a5833 8
  remote_cisco_ops.to_remove_breakpoint = remote_remove_breakpoint;  
  remote_cisco_ops.to_remove_hw_breakpoint = remote_remove_hw_breakpoint;
  remote_cisco_ops.to_insert_hw_breakpoint = remote_insert_hw_breakpoint;
  remote_cisco_ops.to_insert_watchpoint = remote_insert_watchpoint;
  remote_cisco_ops.to_remove_watchpoint = remote_remove_watchpoint;
  remote_cisco_ops.to_stopped_by_watchpoint = remote_stopped_by_watchpoint;
  remote_cisco_ops.to_stopped_data_address = remote_stopped_data_address;
  remote_cisco_ops.to_can_use_hw_breakpoint = remote_check_watch_resources;
a5922 7
  remote_async_ops.to_can_use_hw_breakpoint = remote_check_watch_resources;
  remote_async_ops.to_insert_hw_breakpoint = remote_insert_hw_breakpoint;
  remote_async_ops.to_remove_hw_breakpoint = remote_remove_hw_breakpoint;
  remote_async_ops.to_insert_watchpoint = remote_insert_watchpoint;
  remote_async_ops.to_remove_watchpoint = remote_remove_watchpoint;
  remote_async_ops.to_stopped_by_watchpoint = remote_stopped_by_watchpoint;
  remote_async_ops.to_stopped_data_address = remote_stopped_data_address;
@


1.84.2.4
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d97 3
a99 2
static void remote_open_1 (char *, int, struct target_ops *, int extended_p,
			   int async_p);
d208 4
d2163 1
a2163 1
  remote_open_1 (name, from_tty, &remote_ops, 0, 0);
d2170 1
a2170 1
  remote_open_1 (name, from_tty, &remote_async_ops, 0, 1);
d2179 1
a2179 2
  remote_open_1 (name, from_tty, &extended_remote_ops, 1 /*extended_p */,
		 0 /* async_p */);
d2186 1
a2186 2
  remote_open_1 (name, from_tty, &extended_async_remote_ops,
		 1 /*extended_p */, 1 /* async_p */);
d2267 1
a2267 1
	       int extended_p, int async_p)
d2277 1
a2277 2
  if (!async_p)
    wait_forever_enabled_p = 1;
a2326 16

  if (async_p)
    {
      /* With this target we start out by owning the terminal. */
      remote_async_terminal_ours_p = 1;

      /* FIXME: cagney/1999-09-23: During the initial connection it is
	 assumed that the target is already ready and able to respond to
	 requests. Unfortunately remote_start_remote() eventually calls
	 wait_for_inferior() with no timeout.  wait_forever_enabled_p gets
	 around this. Eventually a mechanism that allows
	 wait_for_inferior() to expect/get timeouts will be
	 implemented. */
      wait_forever_enabled_p = 0;
    }

a2354 2
      if (async_p)
	wait_forever_enabled_p = 1;
d2358 117
a2474 2
  if (async_p)
    wait_forever_enabled_p = 1;
d4988 2
a4989 4
  /* The length field should be set to the size of a breakpoint
     instruction.  */

  BREAKPOINT_FROM_PC (&addr, &len);  
d4991 2
d5029 2
a5030 6

  /* The length field should be set to the size of a breakpoint
     instruction.  */

  BREAKPOINT_FROM_PC (&addr, &len);

d5074 12
@


1.83
log
@* remote.c (remote_start_remote_dummy): Add uiout parameter.
(remote_start_remote): Add uiout parameter.  Pass through to
remote_start_remote_dummy.
(remote_open_1): Use catch_exception instead of catch_errors.
(remote_async_open_1): Ditto.
(remote_cisco_open): Ditto.
@
text
@d2317 5
a2321 1
     target (we'd otherwise be in an inconsistent state).
d2339 1
a2339 1
      return;
d2444 2
a2445 1
     the comments in remote_open_1() for further details.  */
d2455 1
a2455 1
      return;
d5563 2
a5564 1
     the comments in remote_open_1() for further details.  */
d5573 1
a5573 1
      return;
@


1.82
log
@* remote.c (remote_start_remote): Replace PTR with void pointer.
(sigint_remote_twice_token, sigint_remote_token): Ditto.  Make
static.
@
text
@d89 1
a89 1
static int remote_start_remote (void *);
d2110 1
a2110 1
remote_start_remote_dummy (void *dummy)
d2113 2
d2119 1
a2119 1
remote_start_remote (void *dummy)
d2136 3
a2138 1
  return remote_start_remote_dummy (dummy);
d2253 1
d2316 17
a2332 6
  /* Start the remote connection; if error (0), discard this target.
     In particular, if the user quits, be sure to discard it
     (we'd be in an inconsistent state otherwise).  */
  if (!catch_errors (remote_start_remote, NULL,
		     "Couldn't establish connection to remote target\n",
		     RETURN_MASK_ALL))
d2366 1
d2439 8
a2446 6
  /* Start the remote connection; if error (0), discard this target.
     In particular, if the user quits, be sure to discard it
     (we'd be in an inconsistent state otherwise).  */
  if (!catch_errors (remote_start_remote, NULL,
		     "Couldn't establish connection to remote target\n",
		     RETURN_MASK_ALL))
d5494 1
d5557 8
a5564 5
  /* Start the remote connection; if error (0), discard this target. */

  if (!catch_errors (remote_start_remote_dummy, (char *) 0,
		     "Couldn't establish connection to remote target\n",
		     RETURN_MASK_ALL))
@


1.81
log
@2002-05-14  Daniel Jacobowitz  <drow@@mvista.com>

        * ser-tcp.c: Include <netinet/udp.h>.  Rename tcp_open
        and tcp_close to net_open and net_close.
        (net_open): Accept "udp:" and "tcp:" specifications.  Connect
        using UDP if requested.  Don't try to disable Nagle on UDP
        sockets.
        * remote.c (remote_serial_open): New function.  Warn about UDP.
        (remote_open_1, remote_async_open_1, remote_cisco_open): Call it.

2002-05-14  Daniel Jacobowitz  <drow@@mvista.com>

        * gdb.texinfo (Debug Session): Document new `udp:' and `tcp:'
        options for `target remote'.
@
text
@d89 1
a89 1
static int remote_start_remote (PTR);
d973 2
a974 2
PTR sigint_remote_twice_token;
PTR sigint_remote_token;
d2117 1
a2117 1
remote_start_remote (PTR dummy)
@


1.81.2.1
log
@merge from trunk
@
text
@d89 1
a89 1
static int remote_start_remote (struct ui_out *uiout, void *dummy);
d973 2
a974 2
static void *sigint_remote_twice_token;
static void *sigint_remote_token;
d2110 1
a2110 1
remote_start_remote_dummy (struct ui_out *uiout, void *dummy)
a2112 2
  /* NOTE: Return something >=0.  A -ve value is reserved for
     catch_exceptions.  */
d2117 1
a2117 1
remote_start_remote (struct ui_out *uiout, void *dummy)
d2134 1
a2134 3
  /* NOTE: See comment above in remote_start_remote_dummy().  This
     function returns something >=0.  */
  return remote_start_remote_dummy (uiout, dummy);
a2248 1
  int ex;
d2311 6
a2316 21
  /* Start the remote connection.  If error() or QUIT, discard this
     target (we'd otherwise be in an inconsistent state) and then
     propogate the error on up the exception chain.  This ensures that
     the caller doesn't stumble along blindly assuming that the
     function succeeded.  The CLI doesn't have this problem but other
     UI's, such as MI do.

     FIXME: cagney/2002-05-19: Instead of re-throwing the exception,
     this function should return an error indication letting the
     caller restore the previous state.  Unfortunatly the command
     ``target remote'' is directly wired to this function making that
     impossible.  On a positive note, the CLI side of this problem has
     been fixed - the function set_cmd_context() makes it possible for
     all the ``target ....'' commands to share a common callback
     function.  See cli-dump.c.  */
  ex = catch_exceptions (uiout,
			 remote_start_remote, NULL,
			 "Couldn't establish connection to remote"
			 " target\n",
			 RETURN_MASK_ALL);
  if (ex < 0)
d2319 1
a2319 1
      throw_exception (ex);
a2349 1
  int ex;
d2422 6
a2427 9
  /* Start the remote connection; if error, discard this target.  See
     the comments in remote_open_1() for further details such as the
     need to re-throw the exception.  */
  ex = catch_exceptions (uiout,
			 remote_start_remote, NULL,
			 "Couldn't establish connection to remote"
			 " target\n",
			 RETURN_MASK_ALL);
  if (ex < 0)
d2431 1
a2431 1
      throw_exception (ex);
a5474 1
  int ex;
d5537 5
a5541 9
  /* Start the remote connection; if error, discard this target.  See
     the comments in remote_open_1() for further details such as the
     need to re-throw the exception.  */
  ex = catch_exceptions (uiout,
			 remote_start_remote_dummy, NULL,
			 "Couldn't establish connection to remote"
			 " target\n",
			 RETURN_MASK_ALL);
  if (ex < 0)
d5544 1
a5544 1
      throw_exception (ex);
@


1.81.2.2
log
@Merge with trunk.
@
text
@d586 1
a586 1
    enum auto_boolean detect;
d605 1
a605 1
    case AUTO_BOOLEAN_TRUE:
d608 1
a608 1
    case AUTO_BOOLEAN_FALSE:
d611 1
a611 1
    case AUTO_BOOLEAN_AUTO:
d635 1
a635 1
    case AUTO_BOOLEAN_AUTO:
d639 2
a640 2
    case AUTO_BOOLEAN_TRUE:
    case AUTO_BOOLEAN_FALSE:
d651 5
a655 2
		       cmd_sfunc_ftype *set_func,
		       cmd_sfunc_ftype *show_func,
d667 1
a667 1
  config->detect = AUTO_BOOLEAN_AUTO;
d675 6
a680 4
  add_setshow_auto_boolean_cmd (cmd_name, class_obscure,
				&config->detect, set_doc, show_doc,
				set_func, show_func,
				set_remote_list, show_remote_list);
d733 1
a733 1
	  if (config->detect == AUTO_BOOLEAN_AUTO)
d768 1
a768 2
show_remote_protocol_qSymbol_packet_cmd (char *args, int from_tty,
					 struct cmd_list_element *c)
d784 1
a784 2
show_remote_protocol_e_packet_cmd (char *args, int from_tty,
				   struct cmd_list_element *c)
d801 1
a801 2
show_remote_protocol_E_packet_cmd (char *args, int from_tty,
				   struct cmd_list_element *c)
d819 1
a819 2
show_remote_protocol_P_packet_cmd (char *args, int from_tty,
				   struct cmd_list_element *c)
d849 1
a849 2
show_remote_protocol_Z_software_bp_packet_cmd (char *args, int from_tty,
					       struct cmd_list_element *c)
d862 1
a862 2
show_remote_protocol_Z_hardware_bp_packet_cmd (char *args, int from_tty,
					       struct cmd_list_element *c)
d875 1
a875 2
show_remote_protocol_Z_write_wp_packet_cmd (char *args, int from_tty,
					    struct cmd_list_element *c)
d888 1
a888 2
show_remote_protocol_Z_read_wp_packet_cmd (char *args, int from_tty,
					   struct cmd_list_element *c)
d901 1
a901 2
show_remote_protocol_Z_access_wp_packet_cmd (char *args, int from_tty,
					     struct cmd_list_element *c)
d909 1
a909 1
static enum auto_boolean remote_Z_packet_detect;
d924 1
a924 2
show_remote_protocol_Z_packet_cmd (char *args, int from_tty,
				   struct cmd_list_element *c)
d965 2
a966 2
show_remote_protocol_binary_download_cmd (char *args, int from_tty,
					  struct cmd_list_element *c)
d5971 7
a5977 8
  /* FIXME: cagney/2002-06-15: This function should iterate over
     remote_show_cmdlist for a list of sub commands to show.  */
  show_remote_protocol_Z_packet_cmd (args, from_tty, NULL);
  show_remote_protocol_e_packet_cmd (args, from_tty, NULL);
  show_remote_protocol_E_packet_cmd (args, from_tty, NULL);
  show_remote_protocol_P_packet_cmd (args, from_tty, NULL);
  show_remote_protocol_qSymbol_packet_cmd (args, from_tty, NULL);
  show_remote_protocol_binary_download_cmd (args, from_tty, NULL);
d6072 5
a6076 5
  add_setshow_boolean_cmd ("remotebreak", no_class, &remote_break,
			   "Set whether to send break if interrupted.\n",
			   "Show whether to send break if interrupted.\n",
			   NULL, NULL,
			   &setlist, &showlist);
d6153 1
a6153 1
  remote_protocol_e.detect = AUTO_BOOLEAN_FALSE;
d6164 1
a6164 1
  remote_protocol_E.detect = AUTO_BOOLEAN_FALSE;
d6210 8
a6217 7
  add_setshow_auto_boolean_cmd ("Z-packet", class_obscure,
				&remote_Z_packet_detect, "\
Set use of remote protocol `Z' packets",
				"Show use of remote protocol `Z' packets ",
				set_remote_protocol_Z_packet_cmd,
				show_remote_protocol_Z_packet_cmd,
				&remote_set_cmdlist, &remote_show_cmdlist);
@


1.80
log
@* gdbarch.sh (gdbarch_data): Add gdbarch parameter.
* gdbarch.h, gdbarch.c: Regenerate.
* gnu-v3-abi.c: Update copyright.
(vtable_address_point_offset): Update.
(gnuv3_rtti_type): Update.
(gnuv3_baseclass_offset): Update.
* solib-svr4.c (svr4_fetch_link_map_offsets): Update.
(init_fetch_link_map_offsets): Update.
* remote.c (get_remote_state): Update.
@
text
@d2225 20
d2262 1
a2262 1
  remote_desc = serial_open (name);
d2360 1
a2360 1
  remote_desc = serial_open (name);
d5486 1
a5486 1
  remote_desc = serial_open (name);
@


1.79
log
@2002-04-12  Michael Snyder  <msnyder@@redhat.com>

        * Remote.c: Spelling fix.
@
text
@d259 1
a259 1
  return gdbarch_data (remote_gdbarch_data_handle);
@


1.78
log
@* defs.h (error): Add printf format attribute.
* thread-db.c (thread_from_lwp): Fix error format string.
* stack.c (parse_frame_specification): Ditto.
* cli/cli-decode.c (undef_cmd_error): Ditto.
* scm-lang.c (scm_lookup_name): Ditto.
* tracepoint.c (trace_error): Ditto.
* remote-utils.c (usage): Ditto.
* remote.c (compare_sections_command): Ditto.
Fix PR gdb/328.
@
text
@d214 1
a214 1
/* Description of the remote protocol.  Strictly speeking, when the
@


1.77
log
@* remote.c (_initialize_remote): By default, disable ``e'' and
``E'' step out-of-range packets.
@
text
@d5016 2
a5017 2
	error ("target memory fault, section %s, range 0x%08x -- 0x%08x",
	       sectname, lma, lma + size);
@


1.76
log
@* defs.h (throw_exception): Rename return_to_top_level.  Update
comments.
* utils.c (error_stream, internal_verror, quit): Ditto.
* top.c (throw_exception, catcher): Ditto.
* sparclet-rom.c (sparclet_load): Ditto.
* remote.c (interrupt_query, minitelnet): Ditto.
* remote-sds.c (interrupt_query): Ditto.
* remote-mips.c (mips_error, mips_kill): Ditto.
* ocd.c (interrupt_query): Ditto.
* monitor.c (monitor_interrupt_query): Ditto.
* m3-nat.c (suspend_all_threads, thread_resume_command): Ditto.
* target.h: Update comment.

* m3-nat.c, ocd.c, sparclet-rom.c: Update copyright.
@
text
@d6102 4
d6113 4
@


1.75
log
@* cli/cli-decode.c (do_cfunc, set_cmd_cfunc): New functions.
(do_sfunc, set_cmd_sfunc): New functions.

* command.h (struct cmd_list_element): Add field func.
* cli/cli-decode.h (struct cmd_list_element): Ditto.
* command.h (set_cmd_sfunc, set_cmd_cfunc): Declare.
* cli/cli-decode.h: Ditto.

* cli/cli-decode.c (help_cmd): Test for func not cfunc/sfunc.
(help_all, help_cmd_list): Ditto.
(find_cmd, complete_on_cmdlist): Ditto.
* top.c (execute_command): Ditto.

* cli/cli-setshow.c (do_setshow_command): Call func instead of
function.sfunc.

* infcmd.c (notice_args_read): Fix function signature.

* cli/cli-cmds.c (init_cli_cmds): Use set_cmd_sfunc.
* cli/cli-decode.c (add_set_cmd): Ditto.
* utils.c (initialize_utils): Ditto.
* maint.c (_initialize_maint_cmds): Ditto.
* infrun.c (_initialize_infrun): Ditto.
* demangle.c (_initialize_demangler): Ditto.
* remote.c (add_packet_config_cmd): Ditto.
* mips-tdep.c (_initialize_mips_tdep): Ditto.
* cris-tdep.c (_initialize_cris_tdep): Ditto.
* proc-api.c (_initialize_proc_api): Ditto.
* kod.c (_initialize_kod): Ditto.
* valprint.c (_initialize_valprint): Ditto.
* top.c (init_main): Ditto.
* infcmd.c (_initialize_infcmd): Ditto.
* corefile.c (_initialize_core): Ditto.
* arm-tdep.c (_initialize_arm_tdep): Ditto.
* arch-utils.c (initialize_current_architecture): Ditto.
(_initialize_gdbarch_utils): Ditto.
* alpha-tdep.c (_initialize_alpha_tdep): Ditto.

* cli/cli-decode.c (add_cmd): Use set_cmd_cfunc.
* wince.c (_initialize_inftarg): Ditto.
* symfile.c (_initialize_symfile): Ditto.
* mips-tdep.c (_initialize_mips_tdep): Ditto.
* language.c (_initialize_language): Ditto.
* arc-tdep.c (_initialize_arc_tdep): Ditto.
@
text
@d2880 1
a2880 1
      return_to_top_level (RETURN_QUIT);
d5720 1
a5720 1
		  return_to_top_level (RETURN_QUIT);
@


1.74
log
@Remove ATTRIBUTE_UNUSED.  Update (C).
@
text
@d678 1
a678 1
  set_cmd->function.sfunc = set_func;
d6157 1
a6157 1
  tmpcmd->function.sfunc = set_remote_protocol_Z_packet_cmd;
@


1.73
log
@Remove else clause to #if UI_OUT.
@
text
@d3942 1
a3942 2
		    int should_write,
		    struct mem_attrib *attrib ATTRIBUTE_UNUSED,
@


1.72
log
@s/BIG_ENDIAN/BFD_ENDIAN_BIG/
@
text
@d2 3
a4 2
   Copyright 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997,
   1998, 1999, 2000, 2001 Free Software Foundation, Inc.
a1004 1
#ifdef UI_OUT
a1007 4
#else
      printf_filtered ("[New %s]\n",
                       target_pid_to_str (pid_to_ptid (currthread)));
#endif
@


1.71
log
@* remote.c (struct packet_reg): Add field in_g_packet.
(struct remote_state): Rename field g_packet to regs;
(free_remote_state): Update.
(init_remote_state): Add pseudo-registers to table.  Initialize
in_g_packet.  Drop sentinal from table.
(packet_reg_from_regnum, packet_reg_from_pnum): Update.
(remote_fetch_registers): Handle registers not in the g-packet.
(remote_store_registers): Ditto.
@
text
@d4684 1
a4684 1
      if (TARGET_BYTE_ORDER == BIG_ENDIAN)
@


1.70
log
@Use ISO C long strings.
@
text
@d225 1
d234 4
a237 1
  struct packet_reg *g_packet; /* NULL terminated.  */
d271 9
a279 10
  /* Since, for the moment, the regcache is still being direct mapped,
     there are exactly NUM_REGS.  Zero allocate a buffer adding space
     for a sentinal.  */
  rs->g_packet = xcalloc (NUM_REGS + 1, sizeof (struct packet_reg));
  rs->g_packet[NUM_REGS].offset = -1;
  for (regnum = 0; regnum < NUM_REGS; regnum++)
    {
      rs->g_packet[regnum].pnum = regnum;
      rs->g_packet[regnum].regnum = regnum;
      rs->g_packet[regnum].offset = REGISTER_BYTE (regnum);
d312 1
a312 1
  xfree (data->g_packet);
d319 3
a321 2
  struct packet_reg *reg;
  for (reg = rs->g_packet; reg->offset >= 0; reg++)
d323 3
a325 2
      if (reg->regnum == regnum)
	return reg;
a326 1
  return NULL;
d332 2
a333 2
  struct packet_reg *reg;
  for (reg = rs->g_packet; reg->offset >= 0; reg++)
d335 3
a337 2
      if (reg->pnum == pnum)
	return reg;
d3414 10
d3480 1
a3480 1
supply_them:
d3482 2
a3483 2
    struct packet_reg *g;
    for (g = rs->g_packet; g->offset >= 0; g++)
d3485 7
a3491 3
	supply_register (g->regnum, regs + g->offset);
	if (buf[g->offset * 2] == 'x')
	  set_register_cached (i, -1);
d3588 1
a3588 1
    struct packet_reg *g;
d3591 1
a3591 1
    for (g = rs->g_packet; g->offset >= 0; g++)
d3593 3
a3595 1
	regcache_collect (g->regnum, regs + g->offset);
@


1.69
log
@* remote.c (struct packet_reg): Declare.
(struct remote_state): Add fields sizeof_g_packet and g_packet.
(init_remote_state): Initialize sizeof_g_packet and g_packet.
(free_remote_state): Free g_packet.
(packet_reg_from_pnum, packet_reg_by_regnum): New functions.
(remote_wait): Use above instead of gdbarch methods
REGISTER_RAW_SIZE and REGISTER_BYTES.
(remote_async_wait): Ditto.
(remote_fetch_registers, remote_store_registers): Ditto.
(store_register_using_P): Ditto.
@
text
@d2230 3
a2232 3
    error ("To open a remote debug connection, you need to specify what\n\
serial device is attached to the remote system\n\
(e.g. /dev/ttyS0, /dev/ttya, COM1, etc.).");
d2331 3
a2333 3
    error ("To open a remote debug connection, you need to specify what\n\
serial device is attached to the remote system\n\
(e.g. /dev/ttyS0, /dev/ttya, COM1, etc.).");
d5440 2
a5441 3
    error (
	    "To open a remote debug connection, you need to specify what \n\
device is attached to the remote system (e.g. host:port).");
@


1.68
log
@Really zap tty_input from multi-arch swap.
@
text
@d220 9
d231 4
d263 18
d290 4
a293 4
  /* Should REGISTER_BYTES needs more space than the default, adjust
     the size accordingly. Remember that each byte is encoded as two
     characters. 32 is the overhead for the packet header /
     footer. NOTE: cagney/1999-10-26: I suspect that 8
d296 2
a297 2
  if (REGISTER_BYTES > ((rs->remote_packet_size - 32) / 2))
    rs->remote_packet_size = (REGISTER_BYTES * 2 + 32);
d308 27
a334 2
  struct remote_state *state = pointer;
  xfree (state);
d395 6
a400 6
   memory read/write packet.  MIN ((rs->remote_packet_size), g-packet-size) is the
   default.  Some targets need smaller values (fifo overruns, et.al.)
   and some users need larger values (speed up transfers).  The
   variables ``preferred_*'' (the user request), ``current_*'' (what
   was actually set) and ``forced_*'' (Positive - a soft limit,
   negative - a hard limit). */
a2985 1
	    long regno;
d3002 2
a3003 2
		/* Read the register number */
		regno = strtol ((const char *) p, &p_temp, 16);
d3022 1
d3030 2
a3031 2
		    if (regno >= NUM_REGS)
		      warning ("Remote sent bad register number %ld: %s\n\
d3033 1
a3033 1
			       regno, p, buf);
d3035 1
a3035 1
		    fieldsize = hex2bin (p, regs, REGISTER_RAW_SIZE (regno));
d3037 1
a3037 1
		    if (fieldsize < REGISTER_RAW_SIZE (regno))
d3039 1
a3039 1
		    supply_register (regno, regs);
a3205 1
	    long regno;
d3223 1
a3223 1
		regno = strtol ((const char *) p, &p_temp, 16);
d3242 1
a3243 1

d3249 1
a3249 1
		    if (regno >= NUM_REGS)
d3252 1
a3252 1
			       regno, p, buf);
d3254 1
a3254 1
		    fieldsize = hex2bin (p, regs, REGISTER_RAW_SIZE (regno));
d3256 1
a3256 1
		    if (fieldsize < REGISTER_RAW_SIZE (regno))
d3258 1
a3258 1
		    supply_register (regno, regs);
d3395 1
a3395 1
/* Currently we just read all the registers, so we don't use regno.  */
d3399 1
a3399 1
remote_fetch_registers (int regno)
d3405 1
a3405 1
  char *regs = alloca (REGISTER_BYTES);
d3419 1
a3419 1
  memset (regs, 0, REGISTER_BYTES);
d3439 1
a3439 1
  for (i = 0; i < REGISTER_BYTES; i++)
d3466 9
a3474 6
  for (i = 0; i < NUM_REGS; i++)
    {
      supply_register (i, &regs[REGISTER_BYTE (i)]);
      if (buf[REGISTER_BYTE (i) * 2] == 'x')
	set_register_cached (i, -1);
    }
d3489 4
a3492 1
      read_register_bytes (0, (char *) NULL, REGISTER_BYTES);
d3499 1
a3499 1
/* Helper: Attempt to store REGNO using the P packet.  Return fail IFF
d3503 1
a3503 1
store_register_using_P (int regno)
d3506 1
d3513 1
a3513 1
  sprintf (buf, "P%x=", regno);
d3515 3
a3517 3
  regcache_collect (regno, regp);
  bin2hex (regp, p, REGISTER_RAW_SIZE (regno));
  remote_send (buf, (rs->remote_packet_size));
d3523 1
a3523 1
/* Store register REGNO, or all registers if REGNO == -1, from the contents
d3527 1
a3527 1
remote_store_registers (int regno)
d3537 1
a3537 1
  if (regno >= 0)
d3544 1
a3544 1
	  if (store_register_using_P (regno))
d3549 1
a3549 1
	  if (store_register_using_P (regno))
d3569 4
a3572 4
    int i;
    regs = alloca (REGISTER_BYTES);
    memset (regs, REGISTER_BYTES, 0);
    for (i = 0; i < NUM_REGS; i++)
d3574 1
a3574 1
	regcache_collect (i, regs + REGISTER_BYTE (i));
@


1.67
log
@* TODO (register_buffer): Delete.
* regcache.c (register_buffer): Make static.
(regcache_collect): New function.
* regcache.h (register_buffer): Delete declaration.
(regcache_collect): Declare.
* remote.c (store_register_using_P): Rewrite using
regcache_collect.
(remote_store_registers): Ditto.
* go32-nat.c (store_register): Ditto.
@
text
@a5889 1
  register_gdbarch_swap (&tty_input, sizeof (&tty_input), NULL);
@


1.66
log
@Move global state variables to ``struct remote_state''.
@
text
@d3447 1
a3447 1
  char *regp;
d3453 1
a3453 1
  regp = register_buffer (regno);
d3468 2
a3469 1
  char *buf = alloca (rs->remote_packet_size);
a3471 1
  char *regs;
d3504 11
a3514 1
  buf[0] = 'G';
d3518 3
a3520 3

  regs = register_buffer (-1);
  p = buf + 1;
@


1.65
log
@* remote.c: Include "gdb_assert.h".
(tty_input): Wire buffer to 400 bytes.
(readsocket): Check tty_input doesn't overflow.
(build_remote_gdbarch_data, _initialize_remote): Don't multi-arch
tty_input.
@
text
@d213 68
a337 16
/* This is the size (in chars) of the first response to the ``g''
   packet.  It is used as a heuristic when determining the maximum
   size of memory-read and memory-write packets.  A target will
   typically only reserve a buffer large enough to hold the ``g''
   packet.  The size does not include packet overhead (headers and
   trailers). */

static long actual_register_packet_size;

/* This is the maximum size (in chars) of a non read/write packet.  It
   is also used as a cap on the size of read/write packets. */

static long remote_packet_size;
/* compatibility. */
#define PBUFSIZ (remote_packet_size)

d339 1
a339 1
   memory read/write packet.  MIN (PBUFSIZ, g-packet-size) is the
d359 1
d382 1
a382 1
      what_they_get = remote_packet_size;
d388 3
a390 3
      if (actual_register_packet_size > 0
	  && what_they_get > actual_register_packet_size)
	what_they_get = actual_register_packet_size;
d498 1
d502 3
a504 3
     increased beyond PBUFSIZ. */
  if (size > PBUFSIZ)
    size = PBUFSIZ;
a507 34
/* Register packet size initialization. Since the bounds change when
   the architecture changes (namely REGISTER_BYTES) this all needs to
   be multi-arched.  */

static void
register_remote_packet_sizes (void)
{
  REGISTER_GDBARCH_SWAP (remote_packet_size);
  REGISTER_GDBARCH_SWAP (actual_register_packet_size);
}

static void
build_remote_packet_sizes (void)
{
  /* Default maximum number of characters in a packet body. Many
     remote stubs have a hardwired buffer size of 400 bytes
     (c.f. BUFMAX in m68k-stub.c and i386-stub.c).  BUFMAX-1 is used
     as the maximum packet-size to ensure that the packet and an extra
     NUL character can always fit in the buffer.  This stops GDB
     trashing stubs that try to squeeze an extra NUL into what is
     already a full buffer (As of 1999-12-04 that was most stubs. */
  remote_packet_size = 400 - 1;
  /* Should REGISTER_BYTES needs more space than the default, adjust
     the size accordingly. Remember that each byte is encoded as two
     characters. 32 is the overhead for the packet header /
     footer. NOTE: cagney/1999-10-26: I suspect that 8
     (``$NN:G...#NN'') is a better guess, the below has been padded a
     little. */
  if (REGISTER_BYTES > ((remote_packet_size - 32) / 2))
    remote_packet_size = (REGISTER_BYTES * 2 + 32);
  
  /* This one is filled in when a ``g'' packet is received. */
  actual_register_packet_size = 0;
}
d959 2
a960 1
  char *buf = alloca (PBUFSIZ);
d978 1
a978 1
  getpkt (buf, PBUFSIZ, 0);
d1399 1
d1403 1
a1403 1
  char *limit = pkt + PBUFSIZ;	/* plausable parsing limit */
d1490 1
d1492 1
a1492 1
  char *threadinfo_pkt = alloca (PBUFSIZ);
d1496 1
a1496 1
  getpkt (threadinfo_pkt, PBUFSIZ, 0);
d1537 1
d1543 1
a1543 1
  limit = pkt + (PBUFSIZ - BUF_THREAD_ID_SIZE);		/* done parse past here */
d1563 1
d1565 2
a1566 2
  char *threadlist_packet = alloca (PBUFSIZ);
  char *t_response = alloca (PBUFSIZ);
d1570 2
a1571 2
  if ((((result_limit + 1) * BUF_THREAD_ID_SIZE) + 10) >= PBUFSIZ)
    result_limit = (PBUFSIZ / BUF_THREAD_ID_SIZE) - 2;
d1576 1
a1576 1
  getpkt (t_response, PBUFSIZ, 0);
d1682 2
a1683 1
  char *buf = alloca (PBUFSIZ);
d1686 1
a1686 1
  getpkt (buf, PBUFSIZ, 0);
d1716 2
a1717 1
  char *buf = alloca (PBUFSIZ);
d1728 1
a1728 1
      getpkt (bufp, PBUFSIZ, 0);
d1742 1
a1742 1
	      getpkt (bufp, PBUFSIZ, 0);
d1766 1
d1772 1
a1772 1
  char *bufp = alloca (PBUFSIZ);
d1783 1
a1783 1
      getpkt (bufp, PBUFSIZ, 0);
d1827 2
a1828 1
  char *buf = alloca (PBUFSIZ);
d1839 1
a1839 1
  getpkt (buf, PBUFSIZ, 0);
d1858 2
a1859 1
  char *buf = alloca (PBUFSIZ);
d1867 1
a1867 1
  getpkt (buf, PBUFSIZ, 0);
d2134 1
d2142 2
a2143 2
  msg   = alloca (PBUFSIZ);
  reply = alloca (PBUFSIZ);
d2148 1
a2148 1
  getpkt (reply, PBUFSIZ, 0);
d2164 1
a2164 1
      getpkt (reply, PBUFSIZ, 0);
d2172 1
d2248 1
a2248 1
      char *buf = alloca (PBUFSIZ);
d2250 1
a2250 1
      getpkt (buf, PBUFSIZ, 0);
d2273 1
d2362 1
a2362 1
      char *buf = alloca (PBUFSIZ);
d2364 1
a2364 1
      getpkt (buf, PBUFSIZ, 0);
d2390 2
a2391 1
  char *buf = alloca (PBUFSIZ);
d2398 1
a2398 1
  remote_send (buf, PBUFSIZ);
d2410 2
a2411 1
  char *buf = alloca (PBUFSIZ);
d2418 1
a2418 1
  remote_send (buf, PBUFSIZ);
d2500 2
a2501 1
  char *buf = alloca (PBUFSIZ);
d2547 1
a2547 1
	      getpkt (buf, PBUFSIZ, 0);
d2565 1
a2565 1
	      getpkt (buf, PBUFSIZ, 0);
d2590 2
a2591 1
  char *buf = alloca (PBUFSIZ);
d2636 1
a2636 1
	      getpkt (buf, PBUFSIZ, 0);
d2654 1
a2654 1
	      getpkt (buf, PBUFSIZ, 0);
d2902 2
a2903 1
  unsigned char *buf = alloca (PBUFSIZ);
d2914 1
a2914 1
      getpkt (buf, PBUFSIZ, 1);
d3116 2
a3117 1
  unsigned char *buf = alloca (PBUFSIZ);
d3133 1
a3133 1
      getpkt (buf, PBUFSIZ, wait_forever_enabled_p);
d3346 2
a3347 1
  char *buf = alloca (PBUFSIZ);
d3355 1
a3355 1
  remote_send (buf, PBUFSIZ);
d3360 2
a3361 2
  if (actual_register_packet_size == 0)
    actual_register_packet_size = strlen (buf);
d3376 1
a3376 1
      getpkt (buf, PBUFSIZ, 0);
d3444 1
d3446 1
a3446 1
  char *buf = alloca (PBUFSIZ);
d3455 1
a3455 1
  remote_send (buf, PBUFSIZ);
d3467 2
a3468 1
  char *buf = alloca (PBUFSIZ);
d3513 1
a3513 1
  remote_send (buf, PBUFSIZ);
d3588 1
d3597 1
a3597 1
	char *buf = alloca (PBUFSIZ);
d3609 1
a3609 1
	getpkt (buf, PBUFSIZ, 0);
d3887 1
a3887 1
      char *buf = alloca (PBUFSIZ);
d3895 1
a3895 1
      getpkt (buf, PBUFSIZ, 0);
d4008 1
a4008 1
   of the packet is in BUF.  The string in BUF can be at most  PBUFSIZ - 5
d4015 1
d4019 1
a4019 1
  long sizeof_junkbuf = PBUFSIZ;
d4548 1
d4561 1
a4561 1
      char *buf = alloca (PBUFSIZ);
d4573 1
a4573 1
      getpkt (buf, PBUFSIZ, 0);
d4608 1
d4613 1
a4613 1
      char *buf = alloca (PBUFSIZ);
d4626 1
a4626 1
      getpkt (buf, PBUFSIZ, 0);
d4664 2
a4665 1
  char *buf = alloca (PBUFSIZ);
d4681 1
a4681 1
  getpkt (buf, PBUFSIZ, 0);
d4701 2
a4702 1
  char *buf = alloca (PBUFSIZ);
d4717 1
a4717 1
  getpkt (buf, PBUFSIZ, 0);
d4737 2
a4738 1
  char *buf = alloca (PBUFSIZ);
d4755 1
a4755 1
  getpkt (buf, PBUFSIZ, 0);
d4775 2
a4776 1
  char *buf = alloca (PBUFSIZ);
d4793 1
a4793 1
  getpkt (buf, PBUFSIZ, 0);
d4881 1
d4889 1
a4889 1
  char *buf = alloca (PBUFSIZ);
d4926 1
a4926 1
      getpkt (buf, PBUFSIZ, 0);
d4958 1
d4960 1
a4960 1
  char *buf2 = alloca (PBUFSIZ);
d4966 1
a4966 1
  /* minimum outbuf size is PBUFSIZ - if bufsiz is not large enough let 
d4969 1
a4969 1
  if (*bufsiz < PBUFSIZ)
d4971 1
a4971 1
      *bufsiz = PBUFSIZ;
d4999 1
a4999 1
  while (buf[i] && (i < (PBUFSIZ - 8)))
d5026 1
d5028 1
a5028 1
  char *buf = alloca (PBUFSIZ);
d5042 1
a5042 1
  if ((strlen (buf) + strlen (command) * 2 + 8/*misc*/) > PBUFSIZ)
d5056 1
a5056 1
      getpkt (buf, PBUFSIZ, 0);
d5083 2
a5084 1
  char *buf = alloca (PBUFSIZ);
d5097 1
a5097 1
  getpkt (buf, PBUFSIZ, 0);
d5338 2
a5339 1
  char *buf = alloca (PBUFSIZ);
d5345 1
a5345 1
  getpkt (buf, PBUFSIZ, 0);
d5356 1
a5356 1
      getpkt (buf, PBUFSIZ, 0);
a5846 1
  build_remote_packet_sizes ();
d5875 6
a5880 2
  build_remote_gdbarch_data ();
  register_remote_packet_sizes ();
@


1.64
log
@Add explicit #include of "value.h".
@
text
@d40 1
d5408 3
a5410 2
/* shared between readsocket() and readtty()  */
static char *tty_input;
d5456 1
a5792 3

  /* Cisco stuff */
  tty_input = xmalloc (PBUFSIZ);
a5821 1
  register_gdbarch_swap (&tty_input, sizeof (&tty_input), NULL);
@


1.63
log
@* cli/cli-decode.c (add_set_boolean_cmd): Define.
* cli/cli-decode.h (add_set_boolean_cmd): Declare.
* command.h (add_set_boolean_cmd): Ditto.
* remote.c (_initialize_remote): Use add_set_boolean_cmd for "set
remotebreak"
@
text
@d39 1
@


1.62
log
@2001-08-10  Orjan Friberg  <orjanf@@axis.com>

	* remote.c (read_frame): Correct off-by-one error in condition.
@
text
@d5880 3
a5882 4
    (add_set_cmd ("remotebreak", no_class,
		  var_boolean, (char *) &remote_break,
		  "Set whether to send break if interrupted.\n",
		  &setlist),
@


1.61
log
@	* remote.c (init_remote_ops, init_remote_cisco_ops,
	init_remote_async_ops): Set to_pid_to_str and
	to_extra_thread_info correctly and in the same order as declared
	in target.h.
@
text
@d4192 1
a4192 1
                && bc + repeat < sizeof_buf - 1)
@


1.61.2.1
log
@2001-08-10  Orjan Friberg  <orjanf@@axis.com>

	* remote.c (read_frame): Correct off-by-one error in condition.
@
text
@d4192 1
a4192 1
                && bc + repeat - 1 < sizeof_buf - 1)
@


1.60
log
@Revert previous, included more than intended.
@
text
@d5230 1
a5231 1
  remote_ops.to_pid_to_str = remote_pid_to_str;
d5639 2
a5640 1
  remote_ops.to_extra_thread_info = remote_threads_extra_info;
d5730 2
a5731 1
  remote_ops.to_extra_thread_info = remote_threads_extra_info;
@


1.59
log
@	* remote.c (init_remote_ops, init_remote_cisco_ops,
	init_remote_async_ops): Set to_pid_to_str and
	to_extra_thread_info correctly and in the same order as declared
	in target.h.
@
text
@a4515 1
      CORE_ADDR addr2;
d4517 1
a4517 4
      addr2 = remote_address_masked (addr);
      if (ADJUST_REMOTE_Z_BREAKPOINT_P ())
	ADJUST_REMOTE_Z_BREAKPOINT (&addr2);

d4521 2
a4522 2
      p += hexnumstr (p, (ULONGEST) addr2);
      BREAKPOINT_FROM_PC (&addr2, &bp_size);
a4566 1
      CORE_ADDR addr2;
d4572 3
a4574 6
      addr2 = remote_address_masked (addr);
      if (ADJUST_REMOTE_Z_BREAKPOINT_P ())
	ADJUST_REMOTE_Z_BREAKPOINT (&addr2);

      p += hexnumstr (p, (ULONGEST) addr2);
      BREAKPOINT_FROM_PC (&addr2, &bp_size);
d5230 1
a5231 1
  remote_ops.to_extra_thread_info = remote_threads_extra_info;
d5639 1
a5639 2
  remote_cisco_ops.to_pid_to_str = remote_pid_to_str;
  remote_cisco_ops.to_extra_thread_info = remote_threads_extra_info;
d5729 1
a5729 2
  remote_async_ops.to_pid_to_str = remote_pid_to_str;
  remote_async_ops.to_extra_thread_info = remote_threads_extra_info;
@


1.58
log
@* serial.h (SERIAL_ASYNC): Delete.
(DEPRECATED_SERIAL_FD): Delete.
(SERIAL_DEBUG): Delete.
(SERIAL_DEBUG_P): Delete.
(SERIAL_DRAIN_OUTPUT): Delete.
(SERIAL_FLUSH_OUTPUT): Delete.
(SERIAL_FLUSH_INPUT): Delete.
(SERIAL_SEND_BREAK): Delete.
(SERIAL_RAW): Delete.
(SERIAL_GET_TTY_STATE): Delete.
(SERIAL_SET_TTY_STATE): Delete.
(SERIAL_PRINT_TTY_STATE): Delete.
(SERIAL_NOFLUSH_SET_TTY_STATE): Delete.
(SERIAL_SETBAUDRATE): Delete.
(SERIAL_SETSTOPBITS): Delete.
(SERIAL_CAN_ASYNC_P): Delete.
(SERIAL_IS_ASYNC_P): Delete.
(SERIAL_UN_FDOPEN): Delete.
(SERIAL_READCHAR): Delete.
(SERIAL_CLOSE): Delete.
(SERIAL_FDOPEN): Delete.
(SERIAL_OPEN): Delete.
@
text
@d4516 1
d4518 4
a4521 1
      addr = remote_address_masked (addr);
d4525 2
a4526 2
      p += hexnumstr (p, (ULONGEST) addr);
      BREAKPOINT_FROM_PC (&addr, &bp_size);
d4571 1
d4577 6
a4582 3
      addr = remote_address_masked (addr);
      p += hexnumstr (p, (ULONGEST) addr);
      BREAKPOINT_FROM_PC (&addr, &bp_size);
d5238 1
a5239 1
  remote_ops.to_pid_to_str = remote_pid_to_str;
d5647 2
a5648 1
  remote_ops.to_extra_thread_info = remote_threads_extra_info;
d5738 2
a5739 1
  remote_ops.to_extra_thread_info = remote_threads_extra_info;
@


1.57
log
@s/typedef serial_t/struct serial */
@
text
@d1818 1
a1818 1
    SERIAL_CLOSE (remote_desc);
d2033 1
a2033 1
  SERIAL_WRITE (remote_desc, "+", 1);
d2151 1
a2151 1
  remote_desc = SERIAL_OPEN (name);
d2157 1
a2157 1
      if (SERIAL_SETBAUDRATE (remote_desc, baud_rate))
d2159 1
a2159 1
	  SERIAL_CLOSE (remote_desc);
d2164 1
a2164 1
  SERIAL_RAW (remote_desc);
d2168 1
a2168 1
  SERIAL_FLUSH_INPUT (remote_desc);
d2248 1
a2248 1
  remote_desc = SERIAL_OPEN (name);
d2254 1
a2254 1
      if (SERIAL_SETBAUDRATE (remote_desc, baud_rate))
d2256 1
a2256 1
	  SERIAL_CLOSE (remote_desc);
d2261 1
a2261 1
  SERIAL_RAW (remote_desc);
d2265 1
a2265 1
  SERIAL_FLUSH_INPUT (remote_desc);
d2385 1
a2385 1
    SERIAL_ASYNC (remote_desc, NULL, 0);
d2768 1
a2768 1
    SERIAL_SEND_BREAK (remote_desc);
d2770 1
a2770 1
    SERIAL_WRITE (remote_desc, "\003", 1);
d3911 1
a3911 1
  ch = SERIAL_READCHAR (remote_desc, timeout);
d4009 1
a4009 1
      if (SERIAL_WRITE (remote_desc, buf2, p - buf2))
d4311 1
a4311 1
	  SERIAL_WRITE (remote_desc, "+", 1);
d4317 1
a4317 1
      SERIAL_WRITE (remote_desc, "-", 1);
d4323 1
a4323 1
  SERIAL_WRITE (remote_desc, "+", 1);
d4354 1
a4354 1
    SERIAL_ASYNC (remote_desc, NULL, 0);
d5322 1
a5322 1
  remote_desc = SERIAL_OPEN (name);
d5333 1
a5333 1
  if (SERIAL_SETBAUDRATE (remote_desc, baud_rate))
d5335 1
a5335 1
      SERIAL_CLOSE (remote_desc);
d5339 1
a5339 1
  SERIAL_RAW (remote_desc);
d5343 1
a5343 1
  SERIAL_FLUSH_INPUT (remote_desc);
d5511 1
a5511 1
  if (SERIAL_WRITE (remote_desc, tty_input, tty_bytecount))
d5557 1
a5557 1
      FD_SET (DEPRECATED_SERIAL_FD (remote_desc), &input);
d5581 1
a5581 1
	    SERIAL_SEND_BREAK (remote_desc);
d5583 1
a5583 1
	    SERIAL_WRITE (remote_desc, "\003", 1);
d5653 1
a5653 1
  return (current_target.to_async_mask_value) && SERIAL_CAN_ASYNC_P (remote_desc);
d5660 1
a5660 1
  return (current_target.to_async_mask_value) && SERIAL_IS_ASYNC_P (remote_desc);
d5688 1
a5688 1
      SERIAL_ASYNC (remote_desc, remote_async_serial_handler, NULL);
d5693 1
a5693 1
    SERIAL_ASYNC (remote_desc, NULL, NULL);
@


1.56
log
@2001-06-14  Michael Snyder  <msnyder@@redhat.com>

	* remote.c (show_remote_protocol_qSymbol_packet_cmd,
	set_remote_protocol_qSymbol_packet_cmd): New functions.
	(init_all_packet_configs, show_remote_cmd): Add qSymbol packet.
	(remote_check_symbols): New function.  Implement qSymbol packet,
	allowing target to request symbol lookup service from gdb.
	(remote_open_1, remote_async_open_1): Call remote_check_symbols,
	allowing symbol lookup from exec_bfd on connection to target.
	(remote_new_objfile): New function.  Catch new objfile notifications
	from shared library module, and call remote_check_symbols.
	(_initialize_remote): Hook remote_new_objfile into the shared
	library notification chain.  Add "set remote symbol-lookup" command.
@
text
@d243 1
a243 1
static serial_t remote_desc = NULL;
d5672 1
a5672 1
remote_async_serial_handler (serial_t scb, void *context)
@


1.55
log
@2001-05-25  Michael Snyder  <msnyder@@redhat.com>

	* remote.c (remote_write_bytes): Update 'p' packet pointer.
@
text
@d191 1
a191 1
static int hex2bin (const char *hex, char *bin, int);
d193 1
a193 1
static int bin2hex (const char *bin, char *hex, int);
d673 16
d2089 1
d2097 38
d2227 4
a2230 1
    SOLIB_CREATE_INFERIOR_HOOK (PIDGET (inferior_ptid));
d2340 4
a2343 1
    SOLIB_CREATE_INFERIOR_HOOK (PIDGET (inferior_ptid));
a5768 1
  
d5779 1
d5793 17
d5840 4
d5943 7
@


1.54
log
@2001-05-21  Michael Snyder  <msnyder@@redhat.com>

	* remote.c (remote_async_wait): Added new variable fieldsize.
	Add fieldsize (return value of hex2bin) to string pointer p.
@
text
@d3635 1
@


1.53
log
@2001-05-15  John S Kallal  <jskallal@@home.com>

        * remote.c (remote_wait): Added new variable fieldsize.
        Add fieldsize (return value of hex2bin) to string pointer p.
@
text
@d3063 1
d3097 3
a3099 2
		    if (hex2bin (p, regs, REGISTER_RAW_SIZE (regno)) 
			< REGISTER_RAW_SIZE (regno))
@


1.52
log
@2001-05-14  Michael Snyder  <msnyder@@redhat.com>

	* remote.c (hex2bin):   Make first argument const.
	Require explicit count, don't accept null-terminated str.
	(remote_resume, remote_async_resume): White space fix-up.
@
text
@d2844 1
d2878 3
a2880 2
		    if (hex2bin (p, regs, REGISTER_RAW_SIZE (regno))
			< REGISTER_RAW_SIZE (regno))
@


1.51
log
@2001-05-14  Michael Snyder  <msnyder@@redhat.com>

	* remote.c (remote_write_bytes): Set nr_bytes to return value of
	bin2hex.
@
text
@d193 2
a2350 4
  /* May use a length, or a nul-terminated string as input. */
  if (count == 0)
    count = strlen (hex) / 2;

d2377 1
a2377 1
bin2hex (char *bin, char *hex, int count)
d2450 1
a2450 1
	      if (packet_ok(buf, &remote_protocol_E) == PACKET_OK)
d2468 1
a2468 1
	      if (packet_ok(buf, &remote_protocol_e) == PACKET_OK)
d2538 1
a2538 1
	      if (packet_ok(buf, &remote_protocol_E) == PACKET_OK)
d2556 1
a2556 1
	      if (packet_ok(buf, &remote_protocol_e) == PACKET_OK)
@


1.50
log
@* remote.c (remote_write_bytes): Set nr_bytes before returning it.
* solib.h (no_shared_libraries): Declare.
@
text
@d3632 1
a3632 2
      bin2hex (myaddr, p, todo);
      nr_bytes = todo;
@


1.49
log
@2001-05-10  Michael Snyder  <msnyder@@redhat.com>

	* remote.c (remote_open_1): Call no_shared_libraries, so that
	symbols for shared libraries can be reloaded per session.
	(remote_async_open_1): Ditto.
@
text
@d3633 1
@


1.48
log
@2001-05-10  Michael Snyder  <msnyder@@redhat.com>

	* remote.c (bin2hex, hex2bin): New functions.  Factor out these
	two conversions which are coded for repeatedly in this module.
	(remote_threads_extra_info, remote_wait, remote_async_wait,
	store_register_using_P, remote_store_registers, remote_write_bytes,
	remote_read_bytes, remote_rcmd): Use bin2hex and hex2bin instead
	of coding the conversions inline.
	(fromhex): Not exported, change from extern to static.
@
text
@d2138 5
d2161 1
d2167 2
a2168 1
#ifdef SOLIB_CREATE_INFERIOR_HOOK
d2245 5
d2271 1
d2277 2
a2278 1
#ifdef SOLIB_CREATE_INFERIOR_HOOK
@


1.47
log
@Phase 1 of the ptid_t changes.
@
text
@d189 1
a189 1
/* exported functions */
d191 1
a191 1
extern int fromhex (int a);
d1738 3
a1740 11
	  char *p;

	  for (p = display_buf; 
	       p < display_buf + sizeof(display_buf) - 1 &&
		 bufp[0] != 0 &&
		 bufp[1] != 0;
	       p++, bufp+=2)
	    {
	      *p = fromhex (bufp[0]) * 16 + fromhex (bufp[1]);
	    }
	  *p = 0;
d2317 1
a2317 1
int
d2330 23
d2363 17
d2865 3
a2867 7
		    for (i = 0; i < REGISTER_RAW_SIZE (regno); i++)
		      {
			if (p[0] == 0 || p[1] == 0)
			  warning ("Remote reply is too short: %s", buf);
			regs[i] = fromhex (p[0]) * 16 + fromhex (p[1]);
			p += 2;
		      }
d3082 3
a3084 7
		    for (i = 0; i < REGISTER_RAW_SIZE (regno); i++)
		      {
			if (p[0] == 0 || p[1] == 0)
			  warning ("Remote reply is too short: %s", buf);
			regs[i] = fromhex (p[0]) * 16 + fromhex (p[1]);
			p += 2;
		      }
d3334 1
a3334 6
  for (i = 0; i < REGISTER_RAW_SIZE (regno); ++i)
    {
      *p++ = tohex ((regp[i] >> 4) & 0xf);
      *p++ = tohex (regp[i] & 0xf);
    }
  *p = '\0';
d3391 1
a3391 7
  for (i = 0; i < register_bytes_found; i++)
    {
      *p++ = tohex ((regs[i] >> 4) & 0xf);
      *p++ = tohex (regs[i] & 0xf);
    }
  *p = '\0';

d3618 1
a3618 6
      for (nr_bytes = 0; nr_bytes < todo; nr_bytes++)
	{
	  *p++ = tohex ((myaddr[nr_bytes] >> 4) & 0xf);
	  *p++ = tohex (myaddr[nr_bytes] & 0xf);
	}
      *p = '\0';
d3709 1
a3709 1
      for (i = 0; i < todo; i++)
d3711 3
a3713 6
	  if (p[0] == 0 || p[1] == 0)
	    /* Reply is short.  This means that we were able to read
	       only part of what we wanted to.  */
	    return i + (origlen - len);
	  myaddr[i] = fromhex (p[0]) * 16 + fromhex (p[1]);
	  p += 2;
d4913 1
a4913 6
  for (i = 0; command[i]; i++)
    {
      *p++ = tohex ((command[i] >> 4) & 0xf);
      *p++ = tohex (command[i] & 0xf);
    }
  *p = '\0';
@


1.46
log
@2001-04-26  Michael Snyder  <msnyder@@redhat.com>

	* target.c (normal_pid_to_str): Get rid of an ancient hack.
	* remote.c (remote_pid_to_str): New function for remote target.
@
text
@d82 3
a84 2
static void remote_resume (int pid, int step, enum target_signal siggnal);
static void remote_async_resume (int pid, int step,
d118 4
a121 2
static int remote_wait (int pid, struct target_waitstatus *status);
static int remote_async_wait (int pid, struct target_waitstatus *status);
d139 1
a139 1
static int remote_thread_alive (int);
d183 1
a183 1
static int remote_current_thread (int oldpid);
d900 1
a900 1
  if (!in_thread_list (currthread))
d902 1
a902 1
      add_thread (currthread);
d905 1
a905 1
      ui_out_text (uiout, target_pid_to_str (currthread));
d908 2
a909 1
      printf_filtered ("[New %s]\n", target_pid_to_str (currthread));
d947 1
a947 1
remote_thread_alive (int tid)
d949 1
d1623 1
a1623 1
  int pid;
d1625 4
a1628 3
  pid = threadref_to_int (ref);
  if (!in_thread_list (pid))
    add_thread (pid);
d1634 2
a1635 2
static int
remote_current_thread (int oldpid)
d1642 1
a1642 1
    return strtol (&buf[2], NULL, 16);
d1656 2
a1657 2
  if (inferior_pid == MAGIC_NULL_PID)	/* ack ack ack */
    inferior_pid = remote_current_thread (inferior_pid);
d1689 2
a1690 2
		  if (tid != 0 && !in_thread_list (tid))
		    add_thread (tid);
d1733 1
a1733 1
      sprintf (bufp, "qThreadExtraInfo,%x", tp->pid);
d1757 1
a1757 1
  int_to_threadref (&id, tp->pid);
d2028 1
a2028 1
  inferior_pid = remote_current_thread (inferior_pid);
d2145 1
a2145 1
  inferior_pid = MAGIC_NULL_PID;
d2171 1
a2171 1
    SOLIB_CREATE_INFERIOR_HOOK (inferior_pid);
d2232 1
a2232 1
  inferior_pid = MAGIC_NULL_PID;
d2274 1
a2274 1
    SOLIB_CREATE_INFERIOR_HOOK (inferior_pid);
d2356 1
a2356 1
remote_resume (int pid, int step, enum target_signal siggnal)
d2359 1
d2445 1
a2445 1
remote_async_resume (int pid, int step, enum target_signal siggnal)
d2448 1
d2755 2
a2756 2
static int
remote_wait (int pid, struct target_waitstatus *status)
d2964 1
a2964 1
      return thread_num;
d2966 1
a2966 1
  return inferior_pid;
d2970 2
a2971 2
static int
remote_async_wait (int pid, struct target_waitstatus *status)
d3188 1
a3188 1
      return thread_num;
d3190 1
a3190 1
  return inferior_pid;
d3209 1
a3209 1
  set_thread (inferior_pid, 1);
d3333 1
a3333 1
  set_thread (inferior_pid, 1);
d5007 1
a5007 1
  if (remote_thread_alive (sample_thread))
d5118 1
a5118 1
remote_pid_to_str (int pid)
d5122 1
a5122 1
  sprintf (buf, "Thread %d", pid);
d5293 1
a5293 1
  inferior_pid = MAGIC_NULL_PID;
d5525 2
a5526 2
static int
remote_cisco_wait (int pid, struct target_waitstatus *status)
d5533 1
a5533 1
  return remote_wait (pid, status);
@


1.45
log
@2001-04-17  Michael Snyder  <msnyder@@redhat.com>

	* remote.c (remote_open_1): On opening the remote target, activate
	the solib_create_inferior_hook, so that it can detect when the
	target loads shared libraries.
	(remote_async_open_1): Ditto.
@
text
@d5106 12
d5145 1
@


1.44
log
@* remote.c (remote_protocol_e, remote_protocol_E): Define.
(set_remote_protocol_e_packet_cmd)
(set_remote_protocol_E_packet_cmd)
(show_remote_protocol_e_packet_command)
(show_remote_protocol_E_packet_command): New functions.
(init_all_packet_configs): Initialize remote_protocol_e and
remote_protocol_E.
(remote_resume, remote_async_resume): Support e/E command
packets.
(show_remote_cmd): Show state of remote_protocol_e and
remote_protocol_E.
(_initialize_remote): Add "set remote step-over-range-packet"
and "set remote step-over-range-w-signal-packet" to CLI.
-------------------------------------------------------------------
@
text
@d53 2
d2153 1
a2153 1
      /* tell the remote that we're using the extended protocol.  */
d2158 9
d2256 1
a2256 1
      /* tell the remote that we're using the extended protocol.  */
d2261 9
@


1.43
log
@* arch-utils.c (#include "gdbthread.h"): Removed.
(#include "symfile.h"): Removed.
(XMALLOC): Removed unused macro.
* breakpoint.c (tbreak_command): Removed local declaration.
(awatch_command, do_enable_breakpoint, set_breakpoint_count):
Remove duplicate declarations.
(bpstat_should_step, bpstat_have_active_hw_watchpoints)
(remove_solib_event_breakpoints): Fix indentation botch.
* c-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* ch-exp.c (ch_terminal_match_float_literal, parse_expr)
(parse_primval, parse_untyped_expr, parse_opt_untyped_expr):
Removed duplicate declarations.
* ch-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* corefile.c (#include "frame.h"): Removed
(#include "symfile.h"): Removed.
(#include "language.h"): Removed.
* dbxread.c (#include "command.h"): Removed.
* environ.c (#include "gdbcore.h"): Removed.
* event-loop.c (#include "top.h"): Removed.
* f-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
(#include "language.h"): Removed.
(#include "typeprint.h"): Removed.
(#include "frame.h"): Removed.
* gdbtypes.h (print_type_scalar): Removed declaration.
* infcmd.c (#include "completer.h"): Removed.
* language.c (#include "frame.h"): Removed.
* m2-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
(#include "language.h"): Removed.
* m2-valprint.c (#include "valprint.h"): Removed.
* p-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* p-valprint.c (#include "typeprint.h"): Removed.
* parse.c (#include "linespec.h"): Removed.
* regcache.c (#include "frame.h"): Removed.
* remote.c (#include "frame.h"): Removed.
(getpkt_sane): Make static.
* source.c (#include "completer.h"): Removed.
* stack.c (#include "symfile.h"): Removed.
(#include "objfiles.h"): Removed.
* symfile.c (#include "completer.h"): Removed.
* tracepoint.c (#include "completer.h"): Removed.
* values.c (#include "frame.h"): Removed.
* varobj.c (#include "valprint.h"): Removed.
* wrapper.c (#include "frame.h"): Removed.

* memattr.c (create_mem_region): Removed unused variable.
* remote-nrom.c: Removed spurious semicolon after init_nrom_ops.
-------------------------------------------------------------------
@
text
@d666 34
d2068 2
d2333 1
d2348 55
d2407 1
a2407 1
      buf[2] = tohex ((int) siggnal & 0xf);
d2421 1
d2436 54
d2499 2
d2502 1
a2518 1
  putpkt (buf);
d5656 1
d5658 2
d5803 14
@


1.42
log
@* remote.c (remote_cisco_section_offsets): Do not cast result from
bfd_get_section_name.
(compare_sections_command): Ditto.
(remote_cisco_section_offsets): Make ``p'' a const pointer.
(compare_sections_command): Ditto for ``sectname''.
@
text
@a27 1
#include "frame.h"
d3988 1
a3988 1
int
@


1.41
log
@Update/correct copyright notices.
@
text
@a1879 1
  char *p;
d1896 1
a1896 1
      p = (unsigned char *) bfd_get_section_name (abfd, sect);
d4576 1
a4576 1
  char *sectname;
d4598 1
a4598 1
      sectname = (char *) bfd_get_section_name (exec_bfd, s);
@


1.40
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 1
   Copyright 1988, 1991-2000, 2001 Free Software Foundation, Inc.
@


1.39
log
@2001-02-16  Michael Snyder  <msnyder@@mvstp600e.cygnus.com>

	* remote.c (build_remote_gdbarch_data): Use new TARGET_ADDR_BIT
	instead of TARGET_PTR_BIT (to support Harvard architectures).
@
text
@d38 1
@


1.38
log
@Add __FILE__ and __LINE__ parameter to internal_error() /
internal_verror().
@
text
@d5519 1
a5519 1
  remote_address_size = TARGET_PTR_BIT;
@


1.37
log
@2001-02-06  Michael Snyder  <msnyder@@makita.cygnus.com>
	Submitted by Paul Hilfinger (hilfingr@@gnat.com)
	and Andrei Petrov (and@@genesyslab.com).
	* findvar.c: Buffers of size MAX_REGISTER_RAW_SIZE or REGISTER_BYTES
	must be allocated dynamically, since these are no longer constants.
	* infcmd.c: Ditto.
	* regcache.c: Ditto.
	* remote.c: Ditto.
	* sol-thread.c: Ditto.
	* valops.c: Ditto.
	* config/sparc/sun4sol2.mh (MH_CFLAGS): Add -I/usr/include/v9, as a
	work-around for a missing Sun header file in solaris for sparc64.
@
text
@d618 2
a619 1
	  internal_error ("packet_ok: attempt to use a disabled packet");
d1685 2
a1686 1
    internal_error ("remote_threads_extra_info");
d3369 2
a3370 2
      internal_error ("%s:%d: remote_write_bytes: bad internal state",
		      __FILE__, __LINE__);
d3372 1
a3372 1
      internal_error ("%s:%d: bad switch", __FILE__, __LINE__);
d3436 2
a3437 2
      internal_error ("%s:%d: remote_write_bytes: bad internal state",
		      __FILE__, __LINE__);
d3439 1
a3439 1
      internal_error ("%s:%d: bad switch", __FILE__, __LINE__);
d4345 2
a4346 1
      internal_error ("hw_bp_to_z: bad watchpoint type %d", type);
d4382 2
a4383 1
  internal_error ("remote_insert_watchpoint: reached end of function");
d4417 2
a4418 1
  internal_error ("remote_remove_watchpoint: reached end of function");
d4454 2
a4455 1
  internal_error ("remote_remove_watchpoint: reached end of function");
d4491 2
a4492 1
  internal_error ("remote_remove_watchpoint: reached end of function");
d5415 2
a5416 1
    internal_error ("Calling remote_async when async is masked");
@


1.36
log
@* monitor.c (#include "gdb_wait.h"): Removed.
* ocd.c: Likewise.
* ppc-bdm.c: Likewise.
* remote-adapt.c: Likewise.
* remote-array.c: Likewise.
* remote-bug.c: Likewise.
* remote-e7000.c: Likewise.
* remote-eb.c: Likewise.
* remote-es.c: Likewise.
* remote-mips.c: Likewise.
* remote-mm.c: Likewise.
* remote-nindy.c: Likewise.
* remote-os9k.c: Likewise.
* remote-rdi.c: Likewise.
* remote-rdp.c: Likewise.
* remote-sds.c: Likewise.
* remote-sim.c: Likewise.
* remote-st.c: Likewise.
* remote-udi.c: Likewise.
* remote-vx.c: Likewise.
* remote-vx29k.c: Likewise.
* remote-vx68.c: Likewise.
* remote-vx960.c: Likewise.
* remote-vxmips.c: Likewise.
* remote-vxsparc.c: Likewise.
* remote.c: Likewise.
* ser-pipe.c: Likewise.
* ser-unix.c: Likewise.
* Makefile.in: Updated dependencies.
-------------------------------------------------------------------
@
text
@d2607 1
a2607 1
	    char regs[MAX_REGISTER_RAW_SIZE];
d2828 1
a2828 1
	    char regs[MAX_REGISTER_RAW_SIZE];
@


1.35
log
@* exec.c (xfer_memory): Add attrib argument.
* infptrace.c (child_xfer_memory): Likewise.
* monitor.c (monitor_xfer_memory): Likewise.
* remote-adapt.c (adapt_xfer_inferior_memory): Likewise.
* remote-array.c (array_xfer_memory): Likewise.
* remote-bug.c (bug_xfer_memory): Likewise.
* remote-e7000.c (e7000_xfer_inferior_memory): Likewise.
* remote-eb.c (eb_xfer_inferior_memory): Likewise.
* remote-es.c (es1800_xfer_inferior_memory): Likewise.
* remote-mips.c (mips_xfer_memory): Likewise.
* remote-mm.c (mm_xfer_inferior_memory): Likewise.
* remote-nindy.c (nindy_xfer_inferior_memory): Likewise.
* remote-os9k.c (rombug_xfer_inferior_memory): Likewise.
* remote-rdi.c (arm_rdi_xfer_memory): Likewise.
* remote-rdp.c (remote_rdp_xfer_inferior_memory): Likewise.
* remote-sds.c (sds_xfer_memory): Likewise.
* remote-sim.c (gdbsim_xfer_inferior_memory): Likewise.
* remote-st.c (st2000_xfer_inferior_memory): Likewise.
* remote-udi.c (udi_xfer_inferior_memory): Likewise.
* remote-vx.c (vx_xfer_memory): Likewise.
* remote.c (remote_xfer_memory): Likewise.
* target.c (debug_to_xfer_memory, do_xfer_memory): Likewise.
* target.h (child_xfer_memory, do_xfer_memory, xfer_memory): Likewise.

* target.h (#include "memattr.h"): Added.
(target_ops.to_xfer_memory): Add attrib argument.

* wince.c (_initialize_inftarg): Removed call to set_dcache_state.
* dcache.h (set_dcache_state): Removed declaration.
* dcache.c (set_dcache_state): Removed definition

* dcache.c: Update module comment, as dcache is now enabled and
disabled with memory region attributes instead of by the global
variable "remotecache".  Add comment describing the interaction
between dcache and memory region attributes.
(dcache_xfer_memory): Add comment describing benefits of moving
cache writeback to a higher level.
(dcache_struct): Removed cache_has_stuff field.  This was used to
record whether the cache had been accessed in order to invalidate
it when it was disabled.  However, this is not needed because the
cache is write through and the code that enables, disables, and
deletes memory regions invalidate the cache.  Add comment which
suggests that we could be more selective and only invalidate those
cache lines containing data from those memory regions.
(dcache_invalidate): Updated.
(dcache_xfer_memory): Updated.

(dcache_alloc): Don't abort() if dcache_enabled_p is clear.
(dcache_xfer_memory): Removed code that called do_xfer_memory() to
perform a uncached transfer if dcache_enabled_p was clear.  This
function is now only called if caching is enabled for the memory
region.
(dcache_info): Always print cache info.

* target.c (do_xfer_memory): Add attrib argument.
(target_xfer_memory, target_xfer_memory_partial): Break transfer
into chunks defined by memory regions, pass region attributes to
do_xfer_memory().
* dcache.c (dcache_read_line, dcache_write_line): Likewise.

* Makefile.in (SFILES): Add memattr.c.
(COMMON_OBS): Add memattr.o.
(dcache.o): Add target.h to dependencies.
* memattr.c: New file.
* memattr.h: Likewise.
@
text
@a31 1
#include "gdb_wait.h"
@


1.34
log
@From Mark Salter, fix hw-breakpoint packet format.
@
text
@d2 1
a2 1
   Copyright 1988, 1991-2000 Free Software Foundation, Inc.
d73 1
d3547 3
a3549 1
		    int should_write, struct target_ops *target)
@


1.33
log
@	* regcache.c (set_register_cached, register_buffer,
	real_register, pseudo_register fetch_register, store_register):
	New functions.
	(register_changed, read_relative_register_raw_bytes_for_frame,
	registers_changed, registers_fetched, read_register_bytes,
	read_register_gen, write_register_gen, read_register,
	read_signed_register, write_register, supply_register): Replace
	register_valid[] with register_cached() and
	set_register_cached().
	(read_register_bytes, read_register_gen, write_register_gen,
	read_register, read_signed_register, write_register,
	supply_register): Replace registers[] with register_buffer().
	(read_register_bytes, read_register_gen, read_register,
	read_signed_register): Call fetch_register().
	(write_register_gen, write_register): Call real_register() and
	store_register().
	(write_register_bytes): Call store_register().
	* value.h (set_register_cached, register_buffer): Prototype.
	* remote.c (remote_fetch_registers): Allocate regs[] with a
	run-time size.  Replace register_valid[] with
	set_register_cached().
	(store_register_using_P, remote_store_registers): Replace
	registers[] with register_buffer().
@
text
@d4434 1
a4434 1
  *p = '\0';
d4470 1
a4470 1
  *p = '\0';
@


1.32
log
@Multi-arch REGISTER_BYTES_OK.
@
text
@d3028 1
a3028 1
  char regs[REGISTER_BYTES];
d3093 1
a3093 1
	register_valid[i] = -1;	/* register value not available */
d3130 1
a3130 1
  regp = &registers[REGISTER_BYTE (regno)];
d3144 1
a3144 1
   of REGISTERS.  FIXME: ignores errors.  */
d3152 1
d3190 1
d3195 2
a3196 2
      *p++ = tohex ((registers[i] >> 4) & 0xf);
      *p++ = tohex (registers[i] & 0xf);
@


1.31
log
@Replace free() with xfree().
@
text
@d3083 2
a3084 2
#ifdef REGISTER_BYTES_OK
      if (!REGISTER_BYTES_OK (i))
a3085 1
#endif
@


1.30
log
@* remote.c (remote_write_bytes): Add default case to switch
initializing ``todo''. Ditto for ``nr_bytes''.
* top.c (catch_errors): Always initialize ``val''.
* solib.c (info_sharedlibrary_command): Handle bfd_get_arch_size
returning an unknown size.
* gdbtypes.c (count_virtual_fns): Always initialize ``vfuncs''.
* breakpoint.c (break_at_finish_at_depth_command_1): Initialise
extra_args to NULL.
(break_at_finish_command_1): Ditto.
@
text
@d4599 1
a4599 1
      old_chain = make_cleanup (free, sectdata);
@


1.29
log
@Replace asprintf() / vasprintf() with xasprintf() xvasprintf().
@
text
@d3366 4
a3369 1
      internal_error ("remote_write_bytes: bad switch");
d3433 4
a3436 1
      internal_error ("remote_write_bytes: bad switch");
@


1.28
log
@Fix ``show remotewritesize'' was doing a set.
@
text
@d577 4
a580 4
  asprintf (&set_doc, "Set use of remote protocol `%s' (%s) packet",
	    name, title);
  asprintf (&show_doc, "Show current use of remote protocol `%s' (%s) packet",
	    name, title);
d582 1
a582 1
  asprintf (&cmd_name, "%s-packet", title);
d593 1
a593 1
      asprintf (&legacy_name, "%s-packet", name);
@


1.27
log
@* TODO: Note abstraction layer violation where "ocd reset" command
must invalidate the dcache, and how this might be fixed.

* monitor.c (#include "dcache.h"): Removed.
(remote_dcache): Removed.
(monitor_open): Removed code that created local dcache.
(flush_monitor_dcache): Removed (unused function).
(monitor_resume): Removed call to dcache_invd().
(monitor_load): Likewise.
(monitor_xfer_memory): Changed to call monitor_write_memory(),
monitor_write_memory_block(), and monitor_read_memory() instead
of dcache_xfer_memory().
* monitor.h (flush_monitor_dcache): Removed (unused function).
* ocd.c (#include "dcache.h"): Removed.
(ocd_dcache): Removed.
(ocd_open): Removed code that created local dcache.
(ocd_resume): Removed call to dcache_invd().
(ocd_xfer_memory): Changed to call ocd_write_bytes() and
ocd_read_bytes() instead of dcache_xfer_memory().
(bdm_reset_command): Invalidate target dcache.
* remote-bug.c (bug_load): Remove call to dcache_invd().
(bug_resume): Likewise.
(bug_settings): Remove dcache, readfunc, and writefunc fields
from initializer.
(bug_xfer_memory): Changed to call bug_read_memory() and
bug_write_memory() instead of dcache_xfer_memory().
* remote-nindy.c (#include "dcache.h"): Removed.
(nindy_dcache): Removed.
(nindy_open): Removed code that created local dcache.
(nindy_resume): Removed call to dcache_invd().
(nindy_load): Likewise.
(nindy_xfer_inferior_memory): Changed to call ninMemPut() and
ninMemGet() instead of dcache_xfer_memory().
* remote-sds.c (#include "dcache.h"): Removed.
(sds_dcache): Removed.
(sds_open): Removed code that created local dcache.
(sds_resume): Removed call to dcache_invd().
(sds_xfer_memory): Changed to call sds_write_bytes() and
sds_read_bytes() instead of dcache_xfer_memory().
* remote-utils.c (gr_open): Removed code that created local dcache.
* remote-utils.h (#include "dcache.h"): Removed.
(struct gr_settings): Removed dcache, readfunc, and writefunc fields.
(gr_get_dcache, gr_set_dcache): Removed macro definitions.
* remote.c (#include "dcache.h"): Removed.
(remote_dcache): Removed.
(remote_open_1): Removed code that created local dcache.
(remote_async_open_1): Likewise.
(remote_resume): Removed call to dcache_invd().
(remote_async_resume): Likewise.
(remote_xfer_memory): Changed to call remote_write_bytes() and
remote_read_bytes() instead of dcache_xfer_memory().
* wince.c (#include "dcache.h"): Removed.
(remote_dcache): Removed.
(child_create_inferior): Removed code that created local dcache.
(child_xfer_memory): Changed to call remote_write_bytes() and
remote_read_bytes() instead of dcache_xfer_memory().
(child_resume): Removed call to dcache_invd().

* target.c (target_dcache): Added.
(target_load): Invalidate target_dcache.
(do_xfer_memory): New function.
(target_xfer_memory): Reimplement in terms of dcache_xfer_memory().
(target_xfer_memory_partial): Likewise.
(initialize_targets): Create target_dcache.
* target.h (#include "dcache.h"): Added.
(target_open): Invalidate target_dcache.
(target_resume): Likewise.
(do_xfer_memory): New declaration.

* dcache.c (dcache_init): Removed reading and writing arguments.
(dcache_struct): Removed read_memory and write_memory fields.
(dcache_write_line): Call do_xfer_memory.
(dcache_read_line): Likewise.
(dcache_xfer_memory): Likewise.
(dcache_invalidate): Renamed from dcache_invd.
(dcache_init): Updated.
(dcache_xfer_memory): Updated.
* dcache.h (memxferfunc): Removed definition.
@
text
@d5580 1
a5580 1
  add_cmd ("remotewritesize", no_class, set_memory_write_packet_size,
@


1.26
log
@
Corrected spelling errors in comments
@
text
@a39 2
#include "dcache.h"

a2027 2
static DCACHE *remote_dcache;

a2055 5
  if (!remote_dcache)
    remote_dcache = dcache_init (remote_read_bytes, remote_write_bytes);
  else
    dcache_invd (remote_dcache);

a2133 2
  remote_dcache = dcache_init (remote_read_bytes, remote_write_bytes);

a2300 2
  dcache_invd (remote_dcache);

a2332 2
  dcache_invd (remote_dcache);

d3543 2
d3549 6
a3554 2
  return dcache_xfer_memory (remote_dcache, targ_addr, buffer,
			     targ_len, should_write);
a5036 5

  if (!remote_dcache)
    remote_dcache = dcache_init (remote_read_bytes, remote_write_bytes);
  else
    dcache_invd (remote_dcache);
@


1.25
log
@Protoization.
@
text
@d2195 1
a2195 1
     requests. Unfortunatly remote_start_remote() eventually calls
@


1.24
log
@2000-10-13  Fernando Nasser  <fnasser@@cygnus.com>

	* remote.c (putpkt_binary): Call read_frame, not getpkt. Log message.
	(read_frame): Do not call error() on communication error when
	reading checksum, but return failure instead and log message.
@
text
@d3549 1
a3549 1
   for error.  */
d3553 2
a3554 6
remote_xfer_memory (mem_addr, buffer, mem_len, should_write, target)
     CORE_ADDR mem_addr;
     char *buffer;
     int mem_len;
     int should_write;
     struct target_ops *target;	/* ignored */
d3571 3
a3573 11
remote_search (len, data, mask, startaddr, increment, lorange, hirange
	       addr_found, data_found)
     int len;
     char *data;
     char *mask;
     CORE_ADDR startaddr;
     int increment;
     CORE_ADDR lorange;
     CORE_ADDR hirange;
     CORE_ADDR *addr_found;
     char *data_found;
@


1.23
log
@* dcache.c (dcache_info): Output a cache line's state vector so it
lines up under the data vector.

* dcache.c (dcache_read_line): New function.
(dcache_peek_byte): Use it.
(dcache_alloc): Return NULL if write of reclaimed cache line fails.
(dcache_peek_byte, dcache_poke_byte): Return failure if
dcache_alloc() returns a NULL data block pointer.
(dcache_xfer_memory): Don't force writeback unless we were writing.

* monitor.c (monitor_expect): Change places where immediate_quit
is set to 1 or 0 to increments and decrements respectively.  This
allows such changes to nest properly.
* ocd.c (ocd_start_remote): Likewise.
* remote-adapt.c (expect): Likewise.
* remote-array.c (expect): Likewise.
* remote-eb.c (expect): Likewise.
* remote-e7000.c (e7000_start_remote): Likewise.
* remote-mips.c (mips_expect_timeout, mips_getstring): Likewise.
* remote-nrom.c (expect): Likewise.
* remote-os9k.c (expect): Likewise.
* remote-sds.c (sds_start_remote): Likewise.
* remote-st.c (expect): Likewise.
* remote-utils.c (sr_expect): Likewise.
* remote.c (remote_start_remote): Likewise.
* tracepoint.c (read_actions): Likewise.

* remote-mips.c (mips_getstring): Balance changes to immediate_quit.
@
text
@d3799 2
d3803 1
a3803 1
		getpkt (junkbuf, sizeof_junkbuf, 0);
d3892 5
a3896 1
	      error ("Communication error in checksum");
@


1.22
log
@2000-08-20  Michael Chastain  <chastain@@redhat.com>

      * remote.c (read_frame): Handle SERIAL_TIMEOUT while reading
      checksum.
@
text
@d1978 1
a1978 1
  immediate_quit = 1;		/* Allow user to interrupt it */
d1991 1
a1991 1
  immediate_quit = 0;
@


1.21
log
@* MAINTAINERS: Add myself as dcache.c maintainer.

* remote-nindy.c (nindy_load): Invalidate dcache.

* dcache.c (dcache_invd): Renamed from dcache_flush.  The term
flush with respect to caches usually implies that data will be
written to memory.
(dcache_init, dcache_xfer_memory): Updated.
* monitor.c (flush_monitor_dcache, monitor_resume, monitor_load):
Updated.
* ocd.c (ocd_open, ocd_resume, bdm_reset_command): Updated.
* remote-bug.c (bug_load, bug_resume): Updated.
* remote-nindy.c (nindy_open, nindy_resume): Updated.
* remote-sds.c (sds_open, sds_resume): Updated.
* remote-utils.c (gr_open): Updated.
* remote.c (remote_open_1, remote_resume, remote_async_resume,
remote_cisco_open): Updated.
* wince.c (child_create_inferior, child_resume): Updated.

* monitor.c (monitor_open): Free dcache before creating a new one.
* dcache.c (dcache_free): New function.
* dcache.h (dcache_free): New prototype.
-------------------------------------------------------------------
@
text
@d3874 2
d3879 12
a3890 2
	    pktcsum = fromhex (readchar (remote_timeout)) << 4;
	    pktcsum |= fromhex (readchar (remote_timeout));
d3892 1
@


1.20
log
@* monitor.c (monitor_open): If a dcache has already been created,
invalidate it rather than creating another.
* ocd.c (ocd_open): Likewise.
* remote-nindy.c (nindy_open): Likewise.
* remote-sds.c (sds_open): Likewise.
* remote-utils.c (gr_open): Likewise.
* remote.c (remote_open_1, remote_cisco_open): Likewise.

* dcache.c (dcache_alloc): Changed to take address of line as an
argument, and to invalidate cache line before returning.
(dcache_peek_byte): Updated.
(dcache_poke_byte): Updated.
-------------------------------------------------------------------
@
text
@d2063 1
a2063 1
    dcache_flush (remote_dcache);
d2312 1
a2312 1
  dcache_flush (remote_dcache);
d2346 1
a2346 1
  dcache_flush (remote_dcache);
d5043 1
a5043 1
    dcache_flush (remote_dcache);
@


1.19
log
@2000-08-07  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* objfiles.h (SECT_OFF_BSS): Don't detect invalid sect_index_bss
 	here, let the users of the macro do it.
	* symtab.h (ANOFFSET): Detect here if the section index is not
 	initialized.
	* xcoffread.c (find_targ_sec): Don't treat .bss as special,
 	because some objfiles may not have that section at all.
	* coffread.c (cs_to_section): Ditto.
	* elfread.c (elf_symtab_read): Detect an uninitialized index
 	value.
	(elfstab_offset_sections): The macro ANOFFSET cannot be used as an
 	lvalue anymore.
	* remote.c (get_offsets, remote_cisco_objfile_relocate): Don't use
 	ANOFFSET as an lvalue.
	* objfiles.c (objfile_relocate, objfile_relocate): Don't use
 	ANOFFSET as an lvalue.
	* symfile.c (default_symfile_offsets): Don't use ANOFFSET as an
 	lvalue.
@
text
@d2060 4
a2063 1
  remote_dcache = dcache_init (remote_read_bytes, remote_write_bytes);
d5040 4
a5043 1
  remote_dcache = dcache_init (remote_read_bytes, remote_write_bytes);
@


1.18
log
@Re-implement ``set/show remote Z-packet ...'' commands so that each Z
packet sub-type can be explicitly controled.
@
text
@d1838 1
a1838 1
  ANOFFSET (offs, SECT_OFF_TEXT (symfile_objfile)) = text_addr;
d1844 2
a1845 2
  ANOFFSET (offs, SECT_OFF_DATA (symfile_objfile)) = data_addr;
  ANOFFSET (offs, SECT_OFF_BSS (symfile_objfile)) = data_addr;
d1951 3
a1953 3
      ANOFFSET (offs, SECT_OFF_TEXT (symfile_objfile)) = text_off;
      ANOFFSET (offs, SECT_OFF_DATA (symfile_objfile)) = data_off;
      ANOFFSET (offs, SECT_OFF_BSS (symfile_objfile)) = bss_off;
@


1.17
log
@Use add_set_auto_boolean_cmd() to implement ``set remote ?-packet''
command.
@
text
@d197 1
a197 30
static void set_packet_config_cmd (struct packet_config *config,
				   struct cmd_list_element *c);

static void add_packet_config_cmd (struct packet_config *config,
				   char *name,
				   char *title,
				   void (*set_func) (char *args, int from_tty,
						     struct cmd_list_element *
						     c),
				   void (*show_func) (char *name,
						      int from_tty),
				   struct cmd_list_element **setlist,
				   struct cmd_list_element **showlist);

static void init_packet_config (struct packet_config *config);

static void set_remote_protocol_P_packet_cmd (char *args,
					      int from_tty,
					      struct cmd_list_element *c);

static void show_remote_protocol_P_packet_cmd (char *args, int from_tty);

static void set_remote_protocol_Z_packet_cmd (char *args,
					      int from_tty,
					      struct cmd_list_element *c);

static void show_remote_protocol_Z_packet_cmd (char *args, int from_tty);



d500 10
d511 1
a511 1
set_packet_config_cmd (struct packet_config *config, struct cmd_list_element *c)
d513 12
a524 1
  init_packet_config (config);
d558 11
a568 9
add_packet_config_cmd (config, name, title, set_func, show_func,
		       setlist, showlist)
     struct packet_config *config;
     char *name;
     char *title;
     void (*set_func) (char *args, int from_tty, struct cmd_list_element * c);
     void (*show_func) (char *name, int from_tty);
     struct cmd_list_element **setlist;
     struct cmd_list_element **showlist;
d570 2
a571 1
  struct cmd_list_element *c;
d574 1
a574 1
  char *full_name;
d583 18
a600 5
  asprintf (&full_name, "%s-packet", name);
  c = add_set_auto_boolean_cmd (full_name, class_obscure,
				&config->detect, set_doc, setlist);
  c->function.sfunc = set_func;
  add_cmd (full_name, class_obscure, show_func, show_doc, showlist);
d603 34
a636 4
static void
init_packet_config (struct packet_config *config)
{
  switch (config->detect)
d638 25
a662 9
    case CMD_AUTO_BOOLEAN_TRUE:
      config->support = PACKET_ENABLE;
      break;
    case CMD_AUTO_BOOLEAN_FALSE:
      config->support = PACKET_DISABLE;
      break;
    case CMD_AUTO_BOOLEAN_AUTO:
      config->support = PACKET_SUPPORT_UNKNOWN;
      break;
d674 1
a674 1
  set_packet_config_cmd (&remote_protocol_P, c);
d683 1
a683 1
/* Should we try the 'Z' (set breakpoint) request?  */
d685 84
a768 1
static struct packet_config remote_protocol_Z;
d774 6
a779 1
  set_packet_config_cmd (&remote_protocol_Z, c);
d785 5
a789 1
  show_packet_config_cmd (&remote_protocol_Z);
d820 1
a820 1
  set_packet_config_cmd (&remote_protocol_binary_download, c);
d2033 12
d2089 1
a2089 2
  init_packet_config (&remote_protocol_P);
  init_packet_config (&remote_protocol_Z);
a2093 4
  /* Force remote_write_bytes to check whether target supports
     binary downloading. */
  init_packet_config (&remote_protocol_binary_download);

d2170 1
a2170 2
  init_packet_config (&remote_protocol_P);
  init_packet_config (&remote_protocol_Z);
a2174 4
  /* Force remote_write_bytes to check whether target supports
     binary downloading. */
  init_packet_config (&remote_protocol_binary_download);

d4235 4
a4238 4
  /* Try the "Z" packet if it is not already disabled.
     If it succeeds, then set the support to PACKET_ENABLE.
     If it fails, and the user has explicitly requested the Z support 
     then report an error, otherwise, mark it disabled and go on. */
d4240 1
a4240 2
  if ((remote_protocol_Z.support == PACKET_ENABLE)
      || (remote_protocol_Z.support == PACKET_SUPPORT_UNKNOWN)) 
d4256 1
a4256 1
      if (buf[0] != '\0')
d4258 6
a4263 16
	  remote_protocol_Z.support = PACKET_ENABLE;
	  return (buf[0] == 'E');
	}
      
      /* The stub does not support the 'Z' request.  If the user has
         explicitly requested the Z support, or if the stub previously
	 said it supported the packet, this is an error,
         otherwise, mark it disabled. */
      
      else if (remote_protocol_Z.support == PACKET_ENABLE)
	{
	  error ("Protocol error: Z packet not recognized by stub");
	}
      else
	{
	  remote_protocol_Z.support = PACKET_DISABLE;
d4291 1
a4291 2
  if ((remote_protocol_Z.support == PACKET_ENABLE)
      || (remote_protocol_Z.support == PACKET_SUPPORT_UNKNOWN))
d4318 22
a4339 1
#ifdef TARGET_HAS_HARDWARE_WATCHPOINTS
d4345 1
d4347 4
a4350 2
  if (remote_protocol_Z.support == PACKET_DISABLE)
    error ("Can't set hardware watchpoints without the 'Z' packet\n");
d4352 1
a4352 1
  sprintf (buf, "Z%x,", type + 2 );
d4361 10
a4370 2
  if (buf[0] == '\0' || buf [0] == 'E')
    return -1;
d4372 2
a4373 2
  return 0;
}
d4380 6
d4387 1
a4387 1
  sprintf (buf, "z%x,", type + 2 );
d4395 10
a4404 2
  if (buf[0] == '\0' || buf [0] == 'E')
    return -1;
d4406 2
a4407 2
  return 0;
}
d4415 5
a4419 3
  if (remote_protocol_Z.support == PACKET_DISABLE)
    error ("Can't set hardware breakpoints without the 'Z' packet\n");

d4431 10
a4440 2
  if (buf[0] == '\0' || buf [0] == 'E')
    return -1;
d4442 2
a4443 2
  return 0;
}
d4451 5
d4467 9
a4475 4
  if (buf[0] == '\0' || buf [0] == 'E')
    return -1;

  return 0;
a4476 1
#endif
d5073 1
a5073 2
  init_packet_config (&remote_protocol_P);
  init_packet_config (&remote_protocol_Z);
a5077 4
  /* Force remote_write_bytes to check whether target supports
     binary downloading. */
  init_packet_config (&remote_protocol_binary_download);

d5488 7
d5540 2
d5548 1
a5548 1
  add_prefix_cmd ("remote", class_maintenance, set_remote_cmd, "\
d5621 2
a5622 1
			 &remote_set_cmdlist, &remote_show_cmdlist);
d5636 2
a5637 1
  add_packet_config_cmd (&remote_protocol_P, "P", "set-register",
d5640 2
a5641 1
			 &remote_set_cmdlist, &remote_show_cmdlist);
d5643 44
a5686 4
  add_packet_config_cmd (&remote_protocol_Z, "Z", "breakpoint",
			 set_remote_protocol_Z_packet_cmd,
			 show_remote_protocol_Z_packet_cmd,
			 &remote_set_cmdlist, &remote_show_cmdlist);
@


1.16
log
@Protoization.
@
text
@a520 6
enum packet_detect
  {
    PACKET_AUTO_DETECT = 0,
    PACKET_MANUAL_DETECT
  };

a522 1
    const char *state;
d525 1
a525 1
    enum packet_detect detect;
a528 11
static const char packet_support_auto[] = "auto";
static const char packet_enable[] = "enable";
static const char packet_disable[] = "disable";
static const char *packet_support_enums[] =
{
  packet_support_auto,
  packet_enable,
  packet_disable,
  0,
};

d532 1
a532 17
  if (config->state == packet_enable)
    {
      config->detect = PACKET_MANUAL_DETECT;
      config->support = PACKET_ENABLE;
    }
  else if (config->state == packet_disable)
    {
      config->detect = PACKET_MANUAL_DETECT;
      config->support = PACKET_DISABLE;
    }
  else if (config->state == packet_support_auto)
    {
      config->detect = PACKET_AUTO_DETECT;
      config->support = PACKET_SUPPORT_UNKNOWN;
    }
  else
    internal_error ("Bad enum value");
d553 1
a553 1
    case PACKET_AUTO_DETECT:
d557 3
a559 2
    case PACKET_MANUAL_DETECT:
      printf_filtered ("Support for remote protocol `%s' (%s) is currently %s.\n",
d561 1
d582 2
d589 2
a590 4
  c = add_set_enum_cmd (full_name,
			class_obscure, packet_support_enums,
			&config->state,
			set_doc, setlist);
d600 7
a606 1
    case PACKET_AUTO_DETECT:
a607 3
      break;
    case PACKET_MANUAL_DETECT:
      /* let the user beware */
@


1.15
log
@* remote-nindy.c (nindy_fetch_word, nindy_store_word): Removed
(nindy_xfer_inferior_memory): Use dcache_xfer_memory() instead of
breaking transfer into chunks and using nindy_fetch_word() and
nindy_store_word().

* remote-bug.c (bug_xfer_memory): Use dcache_xfer_memory() instead
of breaking transfer into chunks and using gr_fetch_word() and
gr_store_word().

* remote.c (remote_fetch_word, remote_store_word): Removed.

* remote-utils.h (gr_fetch_word, gr_store_word): Removed.
* remote-utils.c (gr_fetch_word, gr_store_word): Removed.

* dcache.h (dcache_fetch, dcache_poke, dcache_poke_block): Removed.
* dcache.c (dcache_fetch, dcache_poke): Removed.
@
text
@d548 1
a548 3
set_packet_config_cmd (config, c)
     struct packet_config *config;
     struct cmd_list_element *c;
d570 1
a570 2
show_packet_config_cmd (config)
     struct packet_config *config;
d628 1
a628 2
init_packet_config (config)
     struct packet_config *config;
d646 2
a647 4
set_remote_protocol_P_packet_cmd (args, from_tty, c)
     char *args;
     int from_tty;
     struct cmd_list_element *c;
d653 1
a653 3
show_remote_protocol_P_packet_cmd (args, from_tty)
     char *args;
     int from_tty;
d663 2
a664 4
set_remote_protocol_Z_packet_cmd (args, from_tty, c)
     char *args;
     int from_tty;
     struct cmd_list_element *c;
d670 1
a670 3
show_remote_protocol_Z_packet_cmd (args, from_tty)
     char *args;
     int from_tty;
d738 1
a738 2
record_currthread (currthread)
     int currthread;
d760 1
a760 3
set_thread (th, gen)
     int th;
     int gen;
d790 1
a790 2
remote_thread_alive (tid)
     int tid;
d919 1
a919 3
ishex (ch, val)
     int ch;
     int *val;
d940 1
a940 2
stubhex (ch)
     int ch;
d952 1
a952 3
stub_unpack_int (buff, fieldlength)
     char *buff;
     int fieldlength;
d969 2
a970 3
unpack_varlen_hex (buff, result)
     char *buff;		/* packet to parse */
     int *result;
d986 1
a986 3
unpack_nibble (buf, val)
     char *buf;
     int *val;
d993 1
a993 3
pack_nibble (buf, nibble)
     char *buf;
     int nibble;
d1000 1
a1000 3
pack_hex_byte (pkt, byte)
     char *pkt;
     int byte;
d1008 1
a1008 3
unpack_byte (buf, value)
     char *buf;
     int *value;
d1015 1
a1015 3
pack_int (buf, value)
     char *buf;
     int value;
d1025 1
a1025 3
unpack_int (buf, value)
     char *buf;
     int *value;
d1035 1
a1035 3
pack_string (pkt, string)
     char *pkt;
     char *string;
d1056 1
a1056 4
unpack_string (src, dest, length)
     char *src;
     char *dest;
     int length;
d1065 1
a1065 3
pack_threadid (pkt, id)
     char *pkt;
     threadref *id;
d1079 1
a1079 3
unpack_threadid (inbuf, id)
     char *inbuf;
     threadref *id;
d1102 1
a1102 3
int_to_threadref (id, value)
     threadref *id;
     int value;
d1119 1
a1119 2
threadref_to_int (ref)
     threadref *ref;
d1133 1
a1133 3
copy_threadref (dest, src)
     threadref *dest;
     threadref *src;
d1146 1
a1146 3
threadmatch (dest, src)
     threadref *dest;
     threadref *src;
d1174 1
a1174 4
pack_threadinfo_request (pkt, mode, id)
     char *pkt;
     int mode;
     threadref *id;
d1197 2
a1198 4
remote_unpack_thread_info_response (pkt, expectedref, info)
     char *pkt;
     threadref *expectedref;
     struct gdb_ext_thread_info *info;
d1287 2
a1288 4
remote_get_threadinfo (threadid, fieldset, info)
     threadref *threadid;
     int fieldset;		/* TAG mask */
     struct gdb_ext_thread_info *info;
d1305 2
a1306 4
adapt_remote_get_threadinfo (ref, selection, info)
     gdb_threadref *ref;
     int selection;
     struct gdb_ext_thread_info *info;
d1317 2
a1318 5
pack_threadlist_request (pkt, startflag, threadcount, nextthread)
     char *pkt;
     int startflag;
     int threadcount;
     threadref *nextthread;
d1332 3
a1334 7
parse_threadlist_response (pkt, result_limit, original_echo, resultlist,
			   doneflag)
     char *pkt;
     int result_limit;
     threadref *original_echo;
     threadref *resultlist;
     int *doneflag;
d1358 2
a1359 9
remote_get_threadlist (startflag, nextthread, result_limit,
		       done, result_count, threadlist)
     int startflag;
     threadref *nextthread;
     int result_limit;
     int *done;
     int *result_count;
     threadref *threadlist;

d1424 2
a1425 4
remote_threadlist_iterator (stepfunction, context, looplimit)
     rmt_thread_action stepfunction;
     void *context;
     int looplimit;
d1463 1
a1463 3
remote_newthread_step (ref, context)
     threadref *ref;
     void *context;
d1476 1
a1476 2
remote_current_thread (oldpid)
     int oldpid;
d1493 1
a1493 1
remote_find_new_threads ()
d1625 1
a1625 1
extended_remote_restart ()
d1645 1
a1645 2
remote_close (quitting)
     int quitting;
d1655 1
a1655 1
get_offsets ()
d1820 2
a1821 4
remote_cisco_objfile_relocate (text_off, data_off, bss_off)
     bfd_signed_vma text_off;
     bfd_signed_vma data_off;
     bfd_signed_vma bss_off;
d1859 1
a1859 2
remote_start_remote (dummy)
     PTR dummy;
d1883 1
a1883 3
remote_open (name, from_tty)
     char *name;
     int from_tty;
d1890 1
a1890 3
remote_async_open (name, from_tty)
     char *name;
     int from_tty;
d1899 1
a1899 3
extended_remote_open (name, from_tty)
     char *name;
     int from_tty;
d1906 1
a1906 3
extended_remote_async_open (name, from_tty)
     char *name;
     int from_tty;
d1916 2
a1917 5
remote_open_1 (name, from_tty, target, extended_p)
     char *name;
     int from_tty;
     struct target_ops *target;
     int extended_p;
d2004 2
a2005 5
remote_async_open_1 (name, from_tty, target, extended_p)
     char *name;
     int from_tty;
     struct target_ops *target;
     int extended_p;
d2109 1
a2109 3
remote_detach (args, from_tty)
     char *args;
     int from_tty;
d2128 1
a2128 3
remote_async_detach (args, from_tty)
     char *args;
     int from_tty;
d2151 1
a2151 2
fromhex (a)
     int a;
d2166 1
a2166 2
tohex (nib)
     int nib;
d2181 1
a2181 3
remote_resume (pid, step, siggnal)
     int pid, step;
     enum target_signal siggnal;
d2215 1
a2215 3
remote_async_resume (pid, step, siggnal)
     int pid, step;
     enum target_signal siggnal;
d2267 1
a2267 1
initialize_sigint_signal_handler ()
d2276 1
a2276 2
handle_remote_sigint (sig)
     int sig;
d2288 1
a2288 2
handle_remote_sigint_twice (sig)
     int sig;
d2299 1
a2299 2
async_remote_interrupt (arg)
     gdb_client_data arg;
d2310 1
a2310 2
async_remote_interrupt_twice (arg)
     gdb_client_data arg;
d2345 1
a2345 2
remote_interrupt (signo)
     int signo;
d2359 1
a2359 2
remote_interrupt_twice (signo)
     int signo;
d2370 1
a2370 1
remote_stop ()
d2385 1
a2385 1
interrupt_query ()
d2470 1
a2470 3
remote_wait (pid, status)
     int pid;
     struct target_waitstatus *status;
d2685 1
a2685 3
remote_async_wait (pid, status)
     int pid;
     struct target_waitstatus *status;
d2916 1
a2916 2
remote_fetch_registers (regno)
     int regno;
d2996 1
a2996 1
remote_prepare_to_store ()
d3041 1
a3041 2
remote_store_registers (regno)
     int regno;
d3099 1
a3099 2
hexnumlen (num)
     ULONGEST num;
d3112 1
a3112 3
hexnumstr (buf, num)
     char *buf;
     ULONGEST num;
d3122 1
a3122 4
hexnumnstr (buf, num, width)
     char *buf;
     ULONGEST num;
     int width;
d3140 1
a3140 2
remote_address_masked (addr)
     CORE_ADDR addr;
d3165 1
a3165 2
check_binary_download (addr)
     CORE_ADDR addr;
d3360 1
a3360 4
remote_read_bytes (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
d3524 1
a3524 2
remote_files_info (ignore)
     struct target_ops *ignore;
d3535 1
a3535 2
readchar (timeout)
     int timeout;
d3577 1
a3577 2
print_packet (buf)
     char *buf;
d3585 1
a3585 2
putpkt (buf)
     char *buf;
d3596 1
a3596 3
putpkt_binary (buf, cnt)
     char *buf;
     int cnt;
d3937 1
a3937 1
remote_kill ()
d3959 1
a3959 1
remote_async_kill ()
d3984 1
a3984 1
remote_mourn ()
d3990 1
a3990 1
remote_async_mourn ()
d3996 1
a3996 1
extended_remote_mourn ()
d4010 1
a4010 2
remote_mourn_1 (target)
     struct target_ops *target;
d4024 1
a4024 4
extended_remote_create_inferior (exec_file, args, env)
     char *exec_file;
     char *args;
     char **env;
d4046 1
a4046 4
extended_remote_async_create_inferior (exec_file, args, env)
     char *exec_file;
     char *args;
     char **env;
d4109 1
a4109 3
remote_insert_breakpoint (addr, contents_cache)
     CORE_ADDR addr;
     char *contents_cache;
d4179 1
a4179 3
remote_remove_breakpoint (addr, contents_cache)
     CORE_ADDR addr;
     char *contents_cache;
d4213 1
a4213 4
remote_insert_watchpoint (addr, len, type)
     CORE_ADDR addr;
     int len;
     int type;
d4237 1
a4237 4
remote_remove_watchpoint (addr, len, type)
     CORE_ADDR addr;
     int len;
     int type;
d4257 1
a4257 3
remote_insert_hw_breakpoint (addr, len)
     CORE_ADDR addr;
     int len;
d4283 1
a4283 3
remote_remove_hw_breakpoint (addr, len)
     CORE_ADDR addr;
     int len;
d4317 1
a4317 3
push_remote_target (name, from_tty)
     char *name;
     int from_tty;
d4327 2
a4328 5
open_remote_target (name, from_tty, target, extended_p)
     char *name;
     int from_tty;
     struct target_ops *target;
     int extended_p;
d4341 1
a4341 4
crc32 (buf, len, crc)
     unsigned char *buf;
     int len;
     unsigned int crc;
d4378 1
a4378 3
compare_sections_command (args, from_tty)
     char *args;
     int from_tty;
d4454 1
a4454 5
remote_query (query_type, buf, outbuf, bufsiz)
     int query_type;
     char *buf;
     char *outbuf;
     int *bufsiz;
d4582 1
a4582 3
packet_command (args, from_tty)
     char *args;
     int from_tty;
d4627 1
a4627 3
threadset_test_cmd (cmd, tty)
     char *cmd;
     int tty;
d4637 1
a4637 3
threadalive_test (cmd, tty)
     char *cmd;
     int tty;
d4650 1
a4650 3
output_threadid (title, ref)
     char *title;
     threadref *ref;
d4660 1
a4660 3
threadlist_test_cmd (cmd, tty)
     char *cmd;
     int tty;
d4682 1
a4682 2
display_thread_info (info)
     struct gdb_ext_thread_info *info;
d4691 1
a4691 2
get_and_display_threadinfo (ref)
     threadref *ref;
d4705 1
a4705 3
threadinfo_test_cmd (cmd, tty)
     char *cmd;
     int tty;
d4718 1
a4718 3
thread_display_step (ref, context)
     threadref *ref;
     void *context;
d4725 1
a4725 3
threadlist_update_test_cmd (cmd, tty)
     char *cmd;
     int tty;
d4749 1
a4749 1
init_remote_ops ()
d4792 1
a4792 1
init_extended_remote_ops ()
d5165 1
a5165 1
init_remote_cisco_ops ()
d5323 1
a5323 1
build_remote_gdbarch_data ()
d5333 1
a5333 1
_initialize_remote ()
@


1.14
log
@Eliminate use of PARAMS.
@
text
@a3211 34

/* Use of the data cache *used* to be disabled because it loses for looking
   at and changing hardware I/O ports and the like.  Accepting `volatile'
   would perhaps be one way to fix it.  Another idea would be to use the
   executable file for the text segment (for all SEC_CODE sections?
   For all SEC_READONLY sections?).  This has problems if you want to
   actually see what the memory contains (e.g. self-modifying code,
   clobbered memory, user downloaded the wrong thing).  

   Because it speeds so much up, it's now enabled, if you're playing
   with registers you turn it of (set remotecache 0).  */

/* Read a word from remote address ADDR and return it.
   This goes through the data cache.  */

#if 0				/* unused? */
static int
remote_fetch_word (addr)
     CORE_ADDR addr;
{
  return dcache_fetch (remote_dcache, addr);
}

/* Write a word WORD into remote address ADDR.
   This goes through the data cache.  */

static void
remote_store_word (addr, word)
     CORE_ADDR addr;
     int word;
{
  dcache_poke (remote_dcache, addr, word);
}
#endif /* 0 (unused?) */
a3212 1

@


1.13
log
@Change signature of function add_set_enum_cmd() so that it uses
constant character pointers.  Update everything.
As a consequence fix infrun's follow-fork plugging a small memory leak.
@
text
@d5165 1
a5165 2
  remote_cisco_mourn
PARAMS ((void))
@


1.12
log
@Eliminate PARAMS from function pointer declarations.
@
text
@d529 1
a529 1
    char *state;
d536 4
a539 4
static char packet_support_auto[] = "auto";
static char packet_enable[] = "enable";
static char packet_disable[] = "disable";
static char *packet_support_enums[] =
@


1.11
log
@PARAMS removal.
@
text
@d606 2
a607 3
     void (*set_func) PARAMS ((char *args, int from_tty,
			       struct cmd_list_element * c));
     void (*show_func) PARAMS ((char *name, int from_tty));
d733 2
a734 2
void (*target_resume_hook) PARAMS ((void));
void (*target_wait_loop_hook) PARAMS ((void));
d2447 1
a2447 1
static void (*ofunc) PARAMS ((int));
@


1.10
log
@Fix signature of add_set_enum_cmd.  Change VAR parameter to char**.
Cleanup signature of add_set_cmd.  Change VAR parameter to void*.
@
text
@d60 4
a63 4
static void handle_remote_sigint PARAMS ((int));
static void handle_remote_sigint_twice PARAMS ((int));
static void async_remote_interrupt PARAMS ((gdb_client_data));
void async_remote_interrupt_twice PARAMS ((gdb_client_data));
d65 1
a65 1
static void build_remote_gdbarch_data PARAMS ((void));
d69 1
a69 2
static int remote_read_bytes PARAMS ((CORE_ADDR memaddr,
				      char *myaddr, int len));
d71 1
a71 1
static void remote_files_info PARAMS ((struct target_ops * ignore));
d73 3
a75 3
static int remote_xfer_memory PARAMS ((CORE_ADDR memaddr, char *myaddr,
				       int len, int should_write,
				       struct target_ops * target));
d77 1
a77 1
static void remote_prepare_to_store PARAMS ((void));
d79 1
a79 1
static void remote_fetch_registers PARAMS ((int regno));
d81 4
a84 5
static void remote_resume PARAMS ((int pid, int step,
				   enum target_signal siggnal));
static void remote_async_resume PARAMS ((int pid, int step,
					 enum target_signal siggnal));
static int remote_start_remote PARAMS ((PTR));
d86 2
a87 2
static void remote_open PARAMS ((char *name, int from_tty));
static void remote_async_open PARAMS ((char *name, int from_tty));
d89 2
a90 2
static void extended_remote_open PARAMS ((char *name, int from_tty));
static void extended_remote_async_open PARAMS ((char *name, int from_tty));
d92 3
a94 4
static void remote_open_1 PARAMS ((char *, int, struct target_ops *,
				   int extended_p));
static void remote_async_open_1 PARAMS ((char *, int, struct target_ops *,
					 int extended_p));
d96 1
a96 1
static void remote_close PARAMS ((int quitting));
d98 1
a98 1
static void remote_store_registers PARAMS ((int regno));
d100 2
a101 2
static void remote_mourn PARAMS ((void));
static void remote_async_mourn PARAMS ((void));
d103 1
a103 1
static void extended_remote_restart PARAMS ((void));
d105 1
a105 1
static void extended_remote_mourn PARAMS ((void));
d107 2
a108 2
static void extended_remote_create_inferior PARAMS ((char *, char *, char **));
static void extended_remote_async_create_inferior PARAMS ((char *, char *, char **));
d110 1
a110 1
static void remote_mourn_1 PARAMS ((struct target_ops *));
d114 1
a114 1
static int readchar PARAMS ((int timeout));
d116 2
a117 2
static int remote_wait PARAMS ((int pid, struct target_waitstatus * status));
static int remote_async_wait PARAMS ((int pid, struct target_waitstatus * status));
d119 2
a120 2
static void remote_kill PARAMS ((void));
static void remote_async_kill PARAMS ((void));
d122 1
a122 1
static int tohex PARAMS ((int nib));
d124 2
a125 2
static void remote_detach PARAMS ((char *args, int from_tty));
static void remote_async_detach PARAMS ((char *args, int from_tty));
d127 1
a127 1
static void remote_interrupt PARAMS ((int signo));
d129 1
a129 1
static void remote_interrupt_twice PARAMS ((int signo));
d131 1
a131 1
static void interrupt_query PARAMS ((void));
d133 1
a133 1
static void set_thread PARAMS ((int, int));
d135 1
a135 1
static int remote_thread_alive PARAMS ((int));
d137 1
a137 1
static void get_offsets PARAMS ((void));
d141 1
a141 1
static int remote_insert_breakpoint PARAMS ((CORE_ADDR, char *));
d143 1
a143 1
static int remote_remove_breakpoint PARAMS ((CORE_ADDR, char *));
d145 1
a145 1
static int hexnumlen PARAMS ((ULONGEST num));
d147 1
a147 1
static void init_remote_ops PARAMS ((void));
d149 1
a149 1
static void init_extended_remote_ops PARAMS ((void));
d151 1
a151 1
static void init_remote_cisco_ops PARAMS ((void));
d155 1
a155 1
static void remote_stop PARAMS ((void));
d157 1
a157 1
static int ishex PARAMS ((int ch, int *val));
d159 1
a159 1
static int stubhex PARAMS ((int ch));
d161 1
a161 1
static int remote_query PARAMS ((int /*char */ , char *, char *, int *));
d163 1
a163 1
static int hexnumstr PARAMS ((char *, ULONGEST));
d165 1
a165 1
static int hexnumnstr PARAMS ((char *, ULONGEST, int));
d167 1
a167 1
static CORE_ADDR remote_address_masked PARAMS ((CORE_ADDR));
d169 1
a169 1
static void print_packet PARAMS ((char *));
d171 1
a171 1
static unsigned long crc32 PARAMS ((unsigned char *, int, unsigned int));
d173 1
a173 1
static void compare_sections_command PARAMS ((char *, int));
d175 1
a175 1
static void packet_command PARAMS ((char *, int));
d177 1
a177 1
static int stub_unpack_int PARAMS ((char *buff, int fieldlength));
d179 1
a179 1
static int remote_current_thread PARAMS ((int oldpid));
d181 1
a181 1
static void remote_find_new_threads PARAMS ((void));
d183 1
a183 1
static void record_currthread PARAMS ((int currthread));
d187 1
a187 1
extern int fromhex PARAMS ((int a));
d189 1
a189 1
static int putpkt_binary PARAMS ((char *buf, int cnt));
d191 1
a191 1
static void check_binary_download PARAMS ((CORE_ADDR addr));
d195 1
a195 1
static void show_packet_config_cmd PARAMS ((struct packet_config * config));
d197 2
a198 2
static void set_packet_config_cmd PARAMS ((struct packet_config * config,
					      struct cmd_list_element * c));
d200 22
a221 20
static void add_packet_config_cmd PARAMS ((struct packet_config * config,
					   char *name,
					   char *title,
   void (*set_func) (char *args, int from_tty, struct cmd_list_element * c),
			       void (*show_func) (char *name, int from_tty),
					   struct cmd_list_element **setlist,
					   struct cmd_list_element **showlist));

static void init_packet_config PARAMS ((struct packet_config * config));

static void set_remote_protocol_P_packet_cmd PARAMS ((char *args,
						      int from_tty,
					      struct cmd_list_element * c));

static void show_remote_protocol_P_packet_cmd PARAMS ((char *args,
						       int from_tty));

static void set_remote_protocol_Z_packet_cmd PARAMS ((char *args,
						      int from_tty,
					      struct cmd_list_element * c));
d223 1
a223 2
static void show_remote_protocol_Z_packet_cmd PARAMS ((char *args,
						       int from_tty));
d230 1
a230 1
void open_remote_target PARAMS ((char *, int, struct target_ops *, int));
d232 1
a232 1
void _initialize_remote PARAMS ((void));
d866 1
a866 1
char *unpack_varlen_hex PARAMS ((char *buff, int *result));
d868 1
a868 1
static char *unpack_nibble PARAMS ((char *buf, int *val));
d870 1
a870 1
static char *pack_nibble PARAMS ((char *buf, int nibble));
d872 1
a872 1
static char *pack_hex_byte PARAMS ((char *pkt, int /*unsigned char */ byte));
d874 1
a874 1
static char *unpack_byte PARAMS ((char *buf, int *value));
d876 1
a876 1
static char *pack_int PARAMS ((char *buf, int value));
d878 1
a878 1
static char *unpack_int PARAMS ((char *buf, int *value));
d880 1
a880 1
static char *unpack_string PARAMS ((char *src, char *dest, int length));
d882 1
a882 1
static char *pack_threadid PARAMS ((char *pkt, threadref * id));
d884 1
a884 1
static char *unpack_threadid PARAMS ((char *inbuf, threadref * id));
d886 1
a886 1
void int_to_threadref PARAMS ((threadref * id, int value));
d888 1
a888 1
static int threadref_to_int PARAMS ((threadref * ref));
d890 1
a890 1
static void copy_threadref PARAMS ((threadref * dest, threadref * src));
d892 1
a892 1
static int threadmatch PARAMS ((threadref * dest, threadref * src));
d894 1
a894 2
static char *pack_threadinfo_request PARAMS ((char *pkt, int mode,
					      threadref * id));
d896 4
a899 3
static int remote_unpack_thread_info_response PARAMS ((char *pkt,
						    threadref * expectedref,
					struct gdb_ext_thread_info * info));
d902 2
a903 3
static int remote_get_threadinfo PARAMS ((threadref * threadid,
					  int fieldset,		/*TAG mask */
					struct gdb_ext_thread_info * info));
d905 3
a907 3
static int adapt_remote_get_threadinfo PARAMS ((gdb_threadref * ref,
						int selection,
					struct gdb_ext_thread_info * info));
d909 3
a911 3
static char *pack_threadlist_request PARAMS ((char *pkt, int startflag,
					      int threadcount,
					      threadref * nextthread));
d913 4
a916 5
static int parse_threadlist_response PARAMS ((char *pkt,
					      int result_limit,
					      threadref * original_echo,
					      threadref * resultlist,
					      int *doneflag));
d918 5
a922 6
static int remote_get_threadlist PARAMS ((int startflag,
					  threadref * nextthread,
					  int result_limit,
					  int *done,
					  int *result_count,
					  threadref * threadlist));
d926 2
a927 2
static int remote_threadlist_iterator PARAMS ((rmt_thread_action stepfunction,
					     void *context, int looplimit));
d929 1
a929 1
static int remote_newthread_step PARAMS ((threadref * ref, void *context));
d1067 1
a1067 1
static char *pack_string PARAMS ((char *pkt, char *string));
d4814 1
a4814 1
static void display_thread_info PARAMS ((struct gdb_ext_thread_info * info));
d4816 1
a4816 1
static void threadset_test_cmd PARAMS ((char *cmd, int tty));
d4818 1
a4818 1
static void threadalive_test PARAMS ((char *cmd, int tty));
d4820 1
a4820 1
static void threadlist_test_cmd PARAMS ((char *cmd, int tty));
d4822 1
a4822 1
int get_and_display_threadinfo PARAMS ((threadref * ref));
d4824 1
a4824 1
static void threadinfo_test_cmd PARAMS ((char *cmd, int tty));
d4826 1
a4826 1
static int thread_display_step PARAMS ((threadref * ref, void *context));
d4828 1
a4828 1
static void threadlist_update_test_cmd PARAMS ((char *cmd, int tty));
d4830 1
a4830 1
static void init_remote_threadtests PARAMS ((void));
d4859 1
a4859 1
void output_threadid PARAMS ((char *title, threadref * ref));
@


1.9
log
@Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * objfiles.h (SECT_OFF_DATA, SECT_OFF_TEXT, SECT_OFF_BSS,
        SECT_OFF_RODATA): Define as functions of OBJFILE.  Add
        sect_index_text, sect_index_data, sect_index_rodata,
        sect_index_bss to objfile structure.
        * gdb-stabs.h (SECT_OFF_DATA, SECT_OFF_TEXT, SECT_OFF_BSS,
        SECT_OFF_RODATA): Remove.
        * objfiles.c (allocate_objfile): Initialize
        sect_index_{text,data,bss,rodata} to -1, for error detection.

        * symfile.c (default_symfile_offsets): Initialize
        sect_index_{text,data,bss,rodata} from bfd information.
        * xcoffread.c (xcoff_symfile_offsets): Ditto.
        * somread.c (som_symfile_offsets): Initialize
        sect_index_{text,data,bss,rodata}.

        * coffread.c, dbxread.c, elfread.c, hp-psymtab-read.c,
        hp-symtab-read.c, hpread.c, mdebugread.c, minsyms.c,
        mipsread.c, objfiles.c, os9kread.c, pa64solib.c, partial-stab.h,
        remote-os9k.c, remote-vx.c, remote.c, rs6000-nat.c, somsolib.c,
        stabsread.c, symfile.c, xcoffread.c:
        Update use of SECT_OFF_{TEXT,DATA,BSS,RODATA} to depend on the
        current objfile.

        * xcoffread.c: Add new field objfile to find_targ_sec_arg.
@
text
@d627 1
a627 1
			(char *) &config->state,
@


1.8
log
@* remote.c (REMOTE_TRANSLATE_XFER_ADDRESS), mem-break.c
(MEMORY_INSERT_BREAKPOINT, MEMORY_REMOVE_BREAKPOINT), target.h
(BREAKPOINT_FROM_PC), valops.c (COERCE_FLOAT_TO_DOUBLE),
gdbarch.sh (D10V_MAKE_DADDR, D10V_MAKE_IADDR,
FRAMELESS_FUNCTION_INVOCATION, REGISTER_CONVERTIBLE,
REGISTER_CONVERT_TO_VIRTUAL, REGISTER_CONVERT_TO_RAW,
REGISTER_NAME), findvar.c (POINTER_TO_ADDRESS,
ADDRESS_TO_POINTER): Delete default definition.  Handled by
gdbarch.

* gdbarch.sh: Make multi-arch defaults, defaults for non-
multi-arch targets.
(REGISTER_NAME, COERCE_FLOAT_TO_DOUBLE, REGISTER_CONVERTIBLE,
REGISTER_CONVERT_TO_VIRTUAL, REGISTER_CONVERT_TO_RAW,
D10V_MAKE_DADDR, D10V_MAKE_IADDR, BREAKPOINT_FROM_PC,
MEMORY_INSERT_BREAKPOINT, MEMORY_REMOVE_BREAKPOINT,
REMOTE_TRANSLATE_XFER_ADDRESS, FRAMELESS_FUNCTION_INVOCATION):
Provide default/legacy implementation.
(REGISTER_NAMES, CALL_DUMMY): Allow legacy definition.
* gdbarch.h, gdbarch.c: Re-generate.
@
text
@d1806 1
a1806 1
  ANOFFSET (offs, SECT_OFF_TEXT) = text_addr;
d1812 2
a1813 2
  ANOFFSET (offs, SECT_OFF_DATA) = data_addr;
  ANOFFSET (offs, SECT_OFF_BSS) = data_addr;
d1921 3
a1923 3
      ANOFFSET (offs, SECT_OFF_TEXT) = text_off;
      ANOFFSET (offs, SECT_OFF_DATA) = data_off;
      ANOFFSET (offs, SECT_OFF_BSS) = bss_off;
@


1.7
log
@Fix thread-extra-info name.  qfThreadExtraInfo ->qThreadExtraInfo.
@
text
@a3598 5
#ifndef REMOTE_TRANSLATE_XFER_ADDRESS
#define REMOTE_TRANSLATE_XFER_ADDRESS(MEM_ADDR, MEM_LEN, TARG_ADDR, TARG_LEN) \
   (*(TARG_ADDR) = (MEM_ADDR), *(TARG_LEN) = (MEM_LEN))
#endif

@


1.6
log
@2000-03-20  Michael Snyder  <msnyder@@cleaver.cygnus.com>

        * remote.c (remote_threads_extra_info): new function.
        Implement the extra thread info query for "info threads".
        (remote_threads_info): clean up a bit.
        (use_threadinfo_query, use_threadextra_query): new variables.
        Control whether GDB will use the new or old protocol for
        thread info queries.
        (remote_open_1): initialize new variables.
        (remote_async_open_1): ditto.
        (remote_cisco_open): ditto.
@
text
@d1657 1
a1657 1
      sprintf (bufp, "qfThreadExtraInfo,%x", tp->pid);
@


1.5
log
@2000-02-18  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* remote.c (remote_async_detach): Use target_mourn_inferior(), to
 	make sure that all is cleaned up after we disconnect from the
 	target.
	(remote_detach): Ditto.
@
text
@d702 11
d842 1
a842 1
/*  gdb_ext_thread_info is an internal GDB data structure which is
d1572 3
a1574 1
/* Find new threads for info threads command.  */
d1585 7
d1602 73
a1674 7
  putpkt ("qfThreadInfo");
  bufp = buf;
  getpkt (bufp, PBUFSIZ, 0);
  if (bufp[0] == '\0')		/* q packet not recognized! */
    {				/* try old jmetzler method  */
      remote_find_new_threads ();
      return;
d1676 8
a1683 2
  else				/* try new 'q' method */
    while (*bufp++ == 'm')	/* reply contains one or more TID */
d1685 9
a1693 1
	do
d1695 4
a1698 3
	    tid = strtol (bufp, &bufp, 16);
	    if (tid != 0 && !in_thread_list (tid))
	      add_thread (tid);
a1699 4
	while (*bufp++ == ',');	/* comma-separated list */
	putpkt ("qsThreadInfo");
	bufp = buf;
	getpkt (bufp, PBUFSIZ, 0);
d1701 1
d1703 1
d2069 4
d2158 4
d5008 1
d5145 4
d5424 1
d5513 1
@


1.4
log
@Replace ../include/wait.h with gdb_wait.h.
@
text
@d2117 1
a2117 1
  pop_target ();
d2142 1
a2142 1
  pop_target ();
@


1.3
log
@From JTC: Reduce default remote_timeout to two.  Flush defunct code.
@
text
@d32 1
a32 1
#include "wait.h"
@


1.2
log
@From JTC: Handle NAK from target stub.
@
text
@a247 9
/* This was 5 seconds, which is a long time to sit and wait.
   Unless this is going though some terminal server or multiplexer or
   other form of hairy serial connection, I would think 2 seconds would
   be plenty.  */

/* Changed to allow option to set timeout value.
   was static int remote_timeout = 2; */
extern int remote_timeout;

a5512 7

  add_show_from_set
    (add_set_cmd ("remotetimeout", no_class,
		  var_integer, (char *) &remote_timeout,
		  "Set timeout value for remote read.\n",
		  &setlist),
     &showlist);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 2
   Copyright 1988, 91, 92, 93, 94, 95, 96, 97, 1998 
   Free Software Foundation, Inc.
d4 1
a4 1
This file is part of GDB.
d6 14
a19 177
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* Remote communication protocol.

   A debug packet whose contents are <data>
   is encapsulated for transmission in the form:

	$ <data> # CSUM1 CSUM2

	<data> must be ASCII alphanumeric and cannot include characters
	'$' or '#'.  If <data> starts with two characters followed by
	':', then the existing stubs interpret this as a sequence number.

	CSUM1 and CSUM2 are ascii hex representation of an 8-bit 
	checksum of <data>, the most significant nibble is sent first.
	the hex digits 0-9,a-f are used.

   Receiver responds with:

	+	- if CSUM is correct and ready for next packet
	-	- if CSUM is incorrect

   <data> is as follows:
   Most values are encoded in ascii hex digits.  Signal numbers are according
   to the numbering in target.h.

	Request		Packet

	set thread	Hct...		Set thread for subsequent operations.
					c = 'c' for thread used in step and 
					continue; t... can be -1 for all
					threads.
					c = 'g' for thread used in other
					operations.  If zero, pick a thread,
					any thread.
	reply		OK		for success
			ENN		for an error.

	read registers  g
	reply		XX....X		Each byte of register data
					is described by two hex digits.
					Registers are in the internal order
					for GDB, and the bytes in a register
					are in the same order the machine uses.
			or ENN		for an error.

	write regs	GXX..XX		Each byte of register data
					is described by two hex digits.
	reply		OK		for success
			ENN		for an error

        write reg	Pn...=r...	Write register n... with value r...,
					which contains two hex digits for each
					byte in the register (target byte
					order).
	reply		OK		for success
			ENN		for an error
	(not supported by all stubs).

	read mem	mAA..AA,LLLL	AA..AA is address, LLLL is length.
	reply		XX..XX		XX..XX is mem contents
					Can be fewer bytes than requested
					if able to read only part of the data.
			or ENN		NN is errno

	write mem	MAA..AA,LLLL:XX..XX
					AA..AA is address,
					LLLL is number of bytes,
					XX..XX is data
	reply		OK		for success
			ENN		for an error (this includes the case
					where only part of the data was
					written).

        write mem       XAA..AA,LLLL:XX..XX
         (binary)                       AA..AA is address,
                                        LLLL is number of bytes,
                                        XX..XX is binary data
        reply           OK              for success
                        ENN             for an error

	continue	cAA..AA		AA..AA is address to resume
					If AA..AA is omitted,
					resume at same address.

	step		sAA..AA		AA..AA is address to resume
					If AA..AA is omitted,
					resume at same address.

	continue with	Csig;AA..AA	Continue with signal sig (hex signal
	signal				number).  If ;AA..AA is omitted, 
					resume at same address.

	step with	Ssig;AA..AA	Like 'C' but step not continue.
	signal

	last signal     ?               Reply the current reason for stopping.
                                        This is the same reply as is generated
					for step or cont : SAA where AA is the
					signal number.

	detach          D               Reply OK.

	There is no immediate reply to step or cont.
	The reply comes when the machine stops.
	It is		SAA		AA is the signal number.

	or...		TAAn...:r...;n...:r...;n...:r...;
					AA = signal number
					n... = register number (hex)
					  r... = register contents
					n... = `thread'
					  r... = thread process ID.  This is
						 a hex integer.
					n... = other string not starting 
					    with valid hex digit.
					  gdb should ignore this n,r pair
					  and go on to the next.  This way
					  we can extend the protocol.
	or...		WAA		The process exited, and AA is
					the exit status.  This is only
					applicable for certains sorts of
					targets.
	or...		XAA		The process terminated with signal
					AA.
        or...           OXX..XX	XX..XX  is hex encoding of ASCII data. This
					can happen at any time while the 
					program is running and the debugger 
					should continue to wait for 
					'W', 'T', etc.

	thread alive	TXX		Find out if the thread XX is alive.
	reply		OK		thread is still alive
			ENN		thread is dead
	
	remote restart	RXX		Restart the remote server

	extended ops 	!		Use the extended remote protocol.
					Sticky -- only needs to be set once.

	kill request	k

	toggle debug	d		toggle debug flag (see 386 & 68k stubs)
	reset		r		reset -- see sparc stub.
	reserved	<other>		On other requests, the stub should
					ignore the request and send an empty
					response ($#<checksum>).  This way
					we can extend the protocol and GDB
					can tell whether the stub it is
					talking to uses the old or the new.
	search		tAA:PP,MM	Search backwards starting at address
					AA for a match with pattern PP and
					mask MM.  PP and MM are 4 bytes.
					Not supported by all stubs.

	general query	qXXXX		Request info about XXXX.
	general set	QXXXX=yyyy	Set value of XXXX to yyyy.
	query sect offs	qOffsets	Get section offsets.  Reply is
					Text=xxx;Data=yyy;Bss=zzz

	Responses can be run-length encoded to save space.  A '*' means that
	the next character is an ASCII encoding giving a repeat count which
	stands for that many repititions of the character preceding the '*'.
	The encoding is n+29, yielding a printable character where n >=3 
	(which is where rle starts to win).  Don't use an n > 126.
d21 1
a21 2
	So 
	"0* " means the same as "0000".  */
d33 1
a33 1
/*#include "terminal.h"*/
d38 1
d42 2
d48 4
d56 8
d65 3
a67 2
static int remote_write_bytes PARAMS ((CORE_ADDR memaddr,
				       char *myaddr, int len));
d72 1
a72 1
static void remote_files_info PARAMS ((struct target_ops *ignore));
d74 1
a74 1
static int remote_xfer_memory PARAMS ((CORE_ADDR memaddr, char * myaddr,
d84 2
a85 1

d89 1
d92 1
d96 2
d104 1
d111 1
d115 1
a115 1
static void remote_send PARAMS ((char *buf));
d120 1
d123 1
d128 1
d132 2
d142 1
a142 1
static int read_frame PARAMS ((char *));
d154 4
d164 1
a164 1
static int remote_query PARAMS ((int/*char*/, char *, char *, int *));
d168 2
d182 1
a182 1
char *unpack_varlen_hex PARAMS ((char *buff, int *result));
d184 1
a184 1
static char *unpack_nibble PARAMS ((char *buf, int *val));
d186 1
a186 1
static char *pack_nibble PARAMS ((char *buf, int nibble));
d188 1
a188 1
static char *pack_hex_byte PARAMS ((char *pkt, int/*unsigned char*/ byte));
d190 1
a190 1
static char *unpack_byte PARAMS ((char *buf, int *value));
d192 1
a192 1
static char *pack_int PARAMS ((char *buf, int value));
d194 1
a194 15
static char *unpack_int PARAMS ((char *buf, int *value));

static char *unpack_string PARAMS ((char *src, char *dest, int length));

static char *pack_threadid PARAMS ((char *pkt, threadref *id));

static char *unpack_threadid PARAMS ((char *inbuf, threadref *id));

void int_to_threadref PARAMS ((threadref *id, int value));

static int threadref_to_int PARAMS ((threadref *ref));

static void copy_threadref PARAMS ((threadref *dest, threadref *src));

static int threadmatch PARAMS ((threadref *dest, threadref *src));
d196 1
a196 34
static char *pack_threadinfo_request PARAMS ((char *pkt, int mode,
					      threadref *id));

static int remote_unpack_thread_info_response PARAMS ((char *pkt,
						       threadref *expectedref,
						       struct gdb_ext_thread_info *info));


static int remote_get_threadinfo PARAMS ((threadref *threadid,
					  int fieldset,	/*TAG mask */
					  struct gdb_ext_thread_info *info));

static int adapt_remote_get_threadinfo PARAMS ((gdb_threadref *ref,
						int selection,
						struct gdb_ext_thread_info *info));

static char *pack_threadlist_request PARAMS ((char *pkt, int startflag,
					      int threadcount,
					      threadref *nextthread));

static int parse_threadlist_response PARAMS ((char *pkt,
					      int result_limit,
					      threadref *original_echo,
					      threadref *resultlist,
					      int *doneflag));

static int remote_get_threadlist PARAMS ((int startflag,
					  threadref *nextthread,
					  int result_limit,
					  int *done,
					  int *result_count,
					  threadref *threadlist));

typedef int (*rmt_thread_action) (threadref *ref, void *context);
d198 1
a198 6
static int remote_threadlist_iterator PARAMS ((rmt_thread_action stepfunction,
					       void *context, int looplimit));

static int remote_newthread_step PARAMS ((threadref *ref, void *context));

static int remote_current_thread PARAMS ((int oldpid));
d200 2
a201 1
int remote_find_new_threads PARAMS ((void));
d203 7
a209 1
static void record_currthread PARAMS ((int currthread));
d211 1
a211 1
static void init_remote_threads PARAMS ((void));
d213 3
a215 1
/* exported functions */
d217 2
a218 1
extern int fromhex PARAMS ((int a));
d220 3
a222 1
extern void getpkt PARAMS ((char *buf, int forever));
d224 2
a225 1
extern int putpkt PARAMS ((char *buf));
a226 1
static int putpkt_binary PARAMS ((char *buf, int cnt));
a227 1
void remote_console_output PARAMS ((char *));
a228 1
static void check_binary_download PARAMS ((CORE_ADDR addr));
d242 5
a246 1
static struct target_thread_vector remote_thread_vec;
d257 10
a273 5
/* Has the user attempted to interrupt the target? If so, then offer
   the user the opportunity to bail out completely if he interrupts
   again. */
static int interrupted_already = 0;

d279 3
a281 38
/* This variable (available to the user via "set remotebinarydownload")
   dictates whether downloads are sent in binary (via the 'X' packet).
   We assume that the stub can, and attempt to do it. This will be cleared if
   the stub does not understand it. This switch is still needed, though
   in cases when the packet is supported in the stub, but the connection
   does not allow it (i.e., 7-bit serial connection only). */
static int remote_binary_download = 1;
 
/* Have we already checked whether binary downloads work? */
static int remote_binary_checked;

/* Having this larger than 400 causes us to be incompatible with m68k-stub.c
   and i386-stub.c.  Normally, no one would notice because it only matters
   for writing large chunks of memory (e.g. in downloads).  Also, this needs
   to be more than 400 if required to hold the registers (see below, where
   we round it up based on REGISTER_BYTES).  */
#define	PBUFSIZ	400

/* Maximum number of bytes to read/write at once.  The value here
   is chosen to fill up a packet (the headers account for the 32).  */
#define MAXBUFBYTES ((PBUFSIZ-32)/2)

/* Round up PBUFSIZ to hold all the registers, at least.  */
/* The blank line after the #if seems to be required to work around a
   bug in HP's PA compiler.  */
#if REGISTER_BYTES > MAXBUFBYTES

#undef PBUFSIZ
#define	PBUFSIZ	(REGISTER_BYTES * 2 + 32)
#endif


/* This variable sets the number of bytes to be written to the target
   in a single packet.  Normally PBUFSIZ is satisfactory, but some
   targets need smaller values (perhaps because the receiving end
   is slow).  */

static int remote_write_size = PBUFSIZ;
d296 434
a729 10
/* This is the size (in chars) of the first response to the `g' command.  This
   is used to limit the size of the memory read and write commands to prevent
   stub buffers from overflowing.  The size does not include headers and
   trailers, it is only the payload size. */

static int remote_register_buf_size = 0;

/* Should we try the 'P' request?  If this is set to one when the stub
   doesn't support 'P', the only consequence is some unnecessary traffic.  */
static int stub_supports_P = 1;
d736 1
a737 1

d742 1
a742 1
static int cont_thread;
a753 3
#if 0	/* target_wait must not modify inferior_pid! */
  inferior_pid = currthread;
#endif
d755 1
a755 4
#if 0	/* setting cont_thread has a different meaning 
	   from having the target report its thread id.  */
  cont_thread = currthread;
#endif
d759 10
a768 1
    add_thread (currthread);
d778 2
a779 2
  char buf[PBUFSIZ];
  int state = gen ? general_thread : cont_thread;
d796 1
a796 1
  getpkt (buf, 0);
d800 1
a800 1
    cont_thread = th;
d806 2
a807 2
remote_thread_alive (th)
     int th;
d809 1
a809 1
  char buf[PBUFSIZ];
d811 2
a812 3
  buf[0] = 'T';
  if (th < 0)
    sprintf (&buf[1], "-%08x", -th);
d814 1
a814 1
    sprintf (&buf[1], "%08x", th);
d816 1
a816 1
  getpkt (buf, 0);
d826 38
d866 27
a892 1
/* encode 64 bits in 16 chars of hex */
d894 43
a936 1
static const char hexchars[] = "0123456789abcdef";
d1069 1
a1069 1
#if 0 /* currently unused, uncomment when needed */
d1218 6
a1223 6
  threadid:1,        # always request threadid
  context_exists:2,
  display:4,
  unique_name:8,
  more_display:16
*/
d1245 7
a1251 7
#define TAG_THREADID 1      /* Echo the thread identifier */
#define TAG_EXISTS 2        /* Is this process defined enough to
			       fetch registers and its stack */
#define TAG_DISPLAY 4       /* A short thing maybe to put on a window */
#define TAG_THREADNAME 8    /* string, maps 1-to-1 with a thread is */
#define TAG_MOREDISPLAY 16  /* Whatever the kernel wants to say about 
			       the process*/
d1262 1
a1262 1
  char *limit = pkt + PBUFSIZ;  /* plausable parsing limit */
d1286 1
a1286 1
  while ((pkt < limit) && mask && *pkt)	/* packets are terminated with nulls */
d1352 1
a1352 1
  char threadinfo_pkt[PBUFSIZ];
d1356 1
a1356 1
  getpkt (threadinfo_pkt, 0);
d1411 1
a1411 1
  limit = pkt + (PBUFSIZ - BUF_THREAD_ID_SIZE);	/* done parse past here */
d1439 2
a1440 2
  char threadlist_packet[PBUFSIZ];
  char t_response[PBUFSIZ];
d1450 1
a1450 1
  getpkt (t_response, 0);
d1560 1
a1560 1
  char buf[PBUFSIZ];
d1563 1
a1563 1
  getpkt (buf, 0);
d1570 3
a1572 1
int
d1575 2
a1576 4
  int ret;

  ret = remote_threadlist_iterator (remote_newthread_step, 0, 
				    CRAZY_MAX_THREADS);
a1578 1
  return ret;
a1580 3
/* Initialize the thread vector which is used by threads.c */
/* The thread stub is a package, it has an initializer */

d1582 1
a1582 1
init_remote_threads ()
d1584 29
a1612 2
  remote_thread_vec.find_new_threads = remote_find_new_threads;
  remote_thread_vec.get_thread_info = adapt_remote_get_threadinfo;
d1614 1
a1615 1

d1621 1
a1621 1
  char buf[PBUFSIZ];
d1632 1
a1632 1
  getpkt (buf, 0);
d1652 2
a1653 1
  char buf[PBUFSIZ], *ptr;
d1660 1
a1660 1
  getpkt (buf, 0);
d1713 2
a1714 7
  offs = (struct section_offsets *) alloca (sizeof (struct section_offsets)
					    + symfile_objfile->num_sections
					    * sizeof (offs->offsets));
  memcpy (offs, symfile_objfile->section_offsets,
	  sizeof (struct section_offsets)
	  + symfile_objfile->num_sections
	  * sizeof (offs->offsets));
d1728 118
d1849 7
d1874 1
a1874 2
  start_remote ();		/* Initialize gdb process mechanisms */
  return 1;
d1888 9
d1905 10
a1914 1
  remote_open_1 (name, from_tty, &extended_remote_ops, 1/*extended_p*/);
d1930 5
a1934 1
serial device is attached to the remote system (e.g. /dev/ttya).");
d1955 83
a2050 1
  push_target (target);	/* Switch to using remote target now */
d2052 4
a2055 10
  /* The target vector does not have the thread functions in it yet,
     so we use this function to call back into the thread module and
     register the thread vector and its contained functions. */
  bind_target_thread_vector (&remote_thread_vec);

  /* Start out by trying the 'P' request to set registers.  We set
     this each time that we open a new target so that if the user
     switches from one stub to another, we can (if the target is
     closed and reopened) cope.  */
  stub_supports_P = 1;
d2058 1
a2058 1
  cont_thread = -2;
d2062 1
a2062 1
  remote_binary_checked = 0;
d2070 13
a2083 1
  inferior_pid = MAGIC_NULL_PID;
d2087 2
a2088 2
  if (!catch_errors (remote_start_remote, NULL, 
		     "Couldn't establish connection to remote target\n", 
d2092 1
d2096 2
d2101 1
a2101 1
      char buf[PBUFSIZ];
d2103 1
a2103 1
      getpkt (buf, 0);
d2117 22
a2138 1
  char buf[PBUFSIZ];
d2145 5
a2149 1
  remote_send (buf);
d2168 1
a2168 1
  else 
d2179 1
a2179 1
    return '0'+nib;
d2181 1
a2181 1
    return 'a'+nib-10;
d2195 1
a2195 1
  char buf[PBUFSIZ];
d2215 2
a2216 2
      buf[1] = tohex (((int)siggnal >> 4) & 0xf);
      buf[2] = tohex ((int)siggnal & 0xf);
d2220 1
a2220 1
    strcpy (buf, step ? "s": "c");
a2223 5

/* Send ^C to target to halt it.  Target will respond, and send us a
   packet.  */

static void (*ofunc) PARAMS ((int));
d2225 1
d2227 3
a2229 2
remote_interrupt (signo)
     int signo;
d2231 11
a2241 11
  remote_stop ();
  signal (signo, remote_interrupt);
}
  
static void
remote_stop ()
{
  if (!interrupted_already)
    {
      /* Send a break or a ^C, depending on user preference.  */
      interrupted_already = 1;
d2243 4
a2246 2
      if (remote_debug)
        printf_unfiltered ("remote_stop called\n");
d2248 6
a2253 4
      if (remote_break)
        SERIAL_SEND_BREAK (remote_desc);
      else
        SERIAL_WRITE (remote_desc, "\003", 1);
d2256 19
a2274 6
    {
      signal (SIGINT, ofunc);
      interrupt_query ();
      signal (SIGINT, remote_interrupt);
      interrupted_already = 0;
    }
d2276 1
d2278 9
a2286 1
/* Ask the user what to do when an interrupt is received.  */
d2288 1
d2290 2
a2291 1
interrupt_query ()
d2293 5
a2297 1
  target_terminal_ours ();
d2299 11
a2309 8
  if (query ("Interrupted while waiting for the program.\n\
Give up (and stop debugging it)? "))
    {
      target_mourn_inferior ();
      return_to_top_level (RETURN_QUIT);
    }

  target_terminal_inferior ();
d2312 8
a2319 1
/* If nonzero, ignore the next kill.  */
d2321 2
a2322 1
int kill_kludge;
d2324 2
d2327 143
a2469 2
remote_console_output (msg)
     char *msg;
d2473 1
a2473 1
  for (p = msg; *p; p +=2) 
d2479 1
a2479 4
      if (target_output_hook)
	target_output_hook (tb);
      else 
	fputs_filtered (tb, gdb_stdout);
d2481 1
d2484 4
a2487 3
/* Wait until the remote machine stops, then return, storing status in
   STATUS just as `wait' would.  Returns "pid" (though it's not clear
   what, if anything, that means in the case of this target).  */
d2494 1
a2494 1
  unsigned char buf[PBUFSIZ];
a2503 1
      interrupted_already = 0;
d2505 1
a2505 1
      getpkt ((char *) buf, 1);
d2509 1
a2509 1
	 collection of trace data) every time the target stops.  */
d2526 4
a2529 4
		ss = signal number
		n... = register number
		r... = register contents
		*/
d2539 1
a2539 1
		p1 = (unsigned char *)p_temp;
d2541 1
a2541 1
		if (p1 == p) /* No register number present here */
d2582 1
a2582 1
		    warning ("            here: %s",p);
d2592 22
d2615 43
d2679 1
a2679 1
		 the remote system doesn't support it.  */
d2697 1
a2697 1
 got_status:
d2700 221
a2920 8
      /* Initial thread value can only be acquired via wait, so deal with
	 this marker which is used before the first thread value is
	 acquired.  */
      if (inferior_pid == MAGIC_NULL_PID)
	{
	  inferior_pid = thread_num;
	  if (!in_thread_list (inferior_pid))
	    add_thread (inferior_pid);
d2922 4
d2943 1
a2943 1
  char buf[PBUFSIZ];
d2951 1
a2951 1
  remote_send (buf);
d2953 5
a2957 2
  if (remote_register_buf_size == 0)
    remote_register_buf_size = strlen (buf);
d2970 3
a2972 2
	printf_unfiltered ("Bad register packet; fetching a new packet\n");
      getpkt (buf, 0);
d2992 1
a2992 1
	regs[i] = 0;	/* 'x' */
d3006 2
a3007 2
  
  supply_them:
d3009 5
a3013 5
  {
    supply_register (i, &regs[REGISTER_BYTE(i)]);
    if (buf[REGISTER_BYTE(i) * 2] == 'x')
      register_valid[i] = -1;	/* register value not available */
  }
d3020 1
a3020 1
static void 
d3024 9
a3032 1
  read_register_bytes (0, (char *)NULL, REGISTER_BYTES);
d3035 27
d3069 1
a3069 1
  char buf[PBUFSIZ];
d3075 1
a3075 1
  if (regno >= 0 && stub_supports_P)
d3077 1
a3077 7
      /* Try storing a single register.  */
      char *regp;

      sprintf (buf, "P%x=", regno);
      p = buf + strlen (buf);
      regp = &registers[REGISTER_BYTE (regno)];
      for (i = 0; i < REGISTER_RAW_SIZE (regno); ++i)
d3079 22
a3100 2
	  *p++ = tohex ((regp[i] >> 4) & 0xf);
	  *p++ = tohex (regp[i] & 0xf);
a3101 12
      *p = '\0';
      remote_send (buf);
      if (buf[0] != '\0')
	{
	  /* The stub understands the 'P' request.  We are done.  */
	  return;
	}

      /* The stub does not support the 'P' request.  Use 'G' instead,
	 and don't try using 'P' in the future (it will just waste our
	 time).  */
      stub_supports_P = 0;
d3118 1
a3118 1
  remote_send (buf);
d3135 1
a3135 1
#if 0	/* unused? */
d3153 2
a3154 1
#endif	/* 0 (unused?) */
a3155 1

d3171 1
a3171 1
/* Set BUF to the hex digits representing NUM.  */
d3178 13
a3191 1
  int len = hexnumlen (num);
d3193 1
a3193 1
  buf[len] = '\0';
d3195 1
a3195 1
  for (i = len - 1; i >= 0; i--)
d3197 1
a3197 1
      buf[i] = "0123456789abcdef" [(num & 0xf)];
d3201 1
a3201 1
  return len;
d3226 6
a3231 1
   compute a wrong checksum, which causes real havoc with remote_write_bytes. */
d3236 1
a3236 1
  if (remote_binary_download && !remote_binary_checked)
d3238 19
a3256 2
      char buf[PBUFSIZ], *p;
      remote_binary_checked = 1;
d3258 16
a3273 21
      p = buf;
      *p++ = 'X';
      p += hexnumstr (p, (ULONGEST) addr);
      *p++ = ',';
      p += hexnumstr (p, (ULONGEST) 0);
      *p++ = ':';
      *p = '\0';

      putpkt_binary (buf, (int) (p - buf));
      getpkt (buf, 0);

      if (buf[0] == '\0')
	remote_binary_download = 0;
    }

  if (remote_debug)
    {
      if (remote_binary_download)
	printf_unfiltered ("binary downloading suppported by target\n");
      else
	printf_unfiltered ("binary downloading NOT suppported by target\n");
d3283 2
a3284 1
   Returns number of bytes transferred, or 0 for error.  */
d3287 1
a3287 4
remote_write_bytes (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
d3289 1
d3291 6
a3296 1
  int origlen;
d3301 4
a3304 1
  /* Chop the transfer down if necessary */
d3306 2
a3307 3
  max_buf_size = min (remote_write_size, PBUFSIZ);
  if (remote_register_buf_size != 0)
    max_buf_size = min (max_buf_size, remote_register_buf_size);
d3309 3
a3311 2
  /* Subtract header overhead from max payload size - $M<memaddr>,<len>:#nn */
  max_buf_size -= 2 + hexnumlen (memaddr + len - 1) + 1 + hexnumlen (len) + 4;
d3313 33
a3345 2
  origlen = len;
  while (len > 0)
d3347 7
a3353 10
      unsigned char buf[PBUFSIZ];
      unsigned char *p, *plen;
      int todo;
      int i;

      /* construct "M"<memaddr>","<len>":" */
      /* sprintf (buf, "M%lx,%x:", (unsigned long) memaddr, todo); */
      memaddr = remote_address_masked (memaddr);
      p = buf;
      if (remote_binary_download)
d3355 1
a3355 44
	  *p++ = 'X';
	  todo = min (len, max_buf_size);
	}
      else
	{
	  *p++ = 'M';
	  todo = min (len, max_buf_size / 2); /* num bytes that will fit */
	}

      p += hexnumstr (p, (ULONGEST) memaddr);
      *p++ = ',';

      plen = p;		/* remember where len field goes */
      p += hexnumstr (p, (ULONGEST) todo);
      *p++ = ':';
      *p = '\0';

      /* We send target system values byte by byte, in increasing byte
	 addresses, each byte encoded as two hex characters (or one
	 binary character).  */
      if (remote_binary_download)
	{
          int escaped = 0;
          for (i = 0; 
	       (i < todo) && (i + escaped) < (max_buf_size - 2);
	       i++) 
            {
              switch (myaddr[i] & 0xff)
                {
                case '$':
                case '#':
                case 0x7d:
                  /* These must be escaped */
                  escaped++;
                  *p++ = 0x7d;
                  *p++ = (myaddr[i] & 0xff) ^ 0x20;
                  break;
                default:
                  *p++ = myaddr[i] & 0xff;
                  break;
                }
            }

	  if (i < todo)
d3357 10
a3366 9
	      /* Escape chars have filled up the buffer prematurely, 
		 and we have actually sent fewer bytes than planned.
		 Fix-up the length field of the packet.  */

	      /* FIXME: will fail if new len is a shorter string than 
		 old len.  */

	      plen += hexnumstr (plen, (ULONGEST) i);
	      *plen++ = ':';
d3369 1
a3369 1
      else
d3371 7
a3377 6
	  for (i = 0; i < todo; i++)
	    {
	      *p++ = tohex ((myaddr[i] >> 4) & 0xf);
	      *p++ = tohex (myaddr[i] & 0xf);
	    }
	  *p = '\0';
d3379 6
a3384 5

      putpkt_binary (buf, (int) (p - buf));
      getpkt (buf, 0);

      if (buf[0] == 'E')
d3386 2
a3387 6
	  /* There is no correspondance between what the remote protocol uses
	     for errors and errno codes.  We would like a cleaner way of
	     representing errors (big enough to include errno codes, bfd_error
	     codes, and others).  But for now just return EIO.  */
	  errno = EIO;
	  return 0;
d3389 17
a3405 6

      /* Increment by i, not by todo, in case escape chars 
	 caused us to send fewer bytes than we'd planned.  */
      myaddr  += i;
      memaddr += i;
      len     -= i;
d3407 4
a3410 1
  return origlen;
d3421 7
d3434 1
d3436 1
d3439 4
a3442 5
  /* Chop the transfer down if necessary */

  max_buf_size = min (remote_write_size, PBUFSIZ);
  if (remote_register_buf_size != 0)
    max_buf_size = min (max_buf_size, remote_register_buf_size);
a3446 1
      char buf[PBUFSIZ];
d3451 1
a3451 1
      todo = min (len, max_buf_size / 2); /* num bytes that will fit */
d3464 1
a3464 1
      getpkt (buf, 0);
d3476 2
a3477 2
  /* Reply describes memory byte by byte,
     each byte encoded as two hex characters.  */
d3497 8
a3504 3
   transferring to or from debugger address MYADDR.  Write to inferior
   if SHOULD_WRITE is nonzero.  Returns length of data written or
   read; 0 for error.  */
d3508 4
a3511 4
remote_xfer_memory (memaddr, myaddr, len, should_write, target)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
d3513 1
a3513 1
     struct target_ops *target;			/* ignored */
d3515 4
a3518 5
#ifdef REMOTE_TRANSLATE_XFER_ADDRESS
  CORE_ADDR targaddr;
  int targlen;
  REMOTE_TRANSLATE_XFER_ADDRESS (memaddr, len, targaddr, targlen);
  if (targlen == 0)
a3519 3
  memaddr = targaddr;
  len = targlen;
#endif
d3521 2
a3522 2
  return dcache_xfer_memory (remote_dcache, memaddr, myaddr,
			     len, should_write);
d3525 1
a3525 1
   
d3547 1
a3547 1
      char buf[PBUFSIZ];
d3555 1
a3555 1
      getpkt (buf, 0);
d3620 4
a3623 1
  switch (ch)
d3626 1
d3628 1
d3631 1
d3633 1
a3633 3
      return ch;
    default:
      return ch & 0x7f;
d3635 1
d3642 2
a3643 2
remote_send (buf)
     char *buf;
d3646 1
a3646 1
  getpkt (buf, 0);
d3660 1
a3660 2
  while (*buf)
    gdb_printchar (*buf++, gdb_stdout, '"');
d3683 4
a3686 1
  char buf2[PBUFSIZ];
a3693 3
  if (cnt > (int) sizeof (buf2) - 5)		/* Prosanity check */
    abort ();

d3715 4
a3718 2
	  printf_unfiltered ("Sending packet: %s...", buf2);
	  gdb_flush (gdb_stdout);
d3728 1
a3728 1
 	  if (remote_debug)
d3733 1
d3748 1
a3748 1
		printf_unfiltered ("Ack\n");
d3750 3
d3754 1
a3754 1
	      tcount ++;
d3760 4
a3763 6
		char junkbuf[PBUFSIZ];

	      /* It's probably an old response, and we're out of sync.
		 Just gobble up the packet and ignore it.  */
		getpkt (junkbuf, 0);
		continue;		/* Now, go look for + */
d3771 1
a3771 1
		      printf_unfiltered ("putpkt: Junk: ");
d3773 1
a3773 1
		  putchar_unfiltered (ch & 0177);
d3782 4
a3785 4
	 able to get out next time we call QUIT, without anything as
	 violent as interrupt_query.  If we want to provide a way out of
	 here without getting to the next QUIT, it should be based on
	 hitting ^C twice as in remote_wait.  */
d3795 2
d3799 2
a3800 1
   compression.  Returns 0 on any error, 1 on success.  */
d3802 7
a3808 3
static int
read_frame (buf)
     char *buf;
d3811 1
a3811 1
  char *bp;
d3815 1
a3815 1
  bp = buf;
d3819 1
a3820 1

d3825 2
a3826 2
	    puts_filtered ("Timeout in mid-packet, retrying\n");
	  return 0;
d3829 3
a3831 2
	    puts_filtered ("Saw new packet start in middle of old one\n");
	  return 0;		/* Start a new packet, count retries */
d3836 1
a3836 1
	    *bp = '\000';
d3842 1
a3842 1
	      return 1;
d3844 1
a3844 1
	    if (remote_debug) 
d3846 5
a3850 4
		printf_filtered ("Bad checksum, sentsum=0x%x, csum=0x%x, buf=",
				 pktcsum, csum);
		puts_filtered (buf);
		puts_filtered ("\n");
d3852 3
a3854 1
	    return 0;
d3857 3
a3859 4
	  csum += c;
	  c = readchar (remote_timeout);
	  csum += c;
	  c = c - ' ' + 3;	/* Compute repeat count */
d3861 18
d3880 1
a3880 6
	  if (c > 0 && c < 255 && bp + c - 1 < buf + PBUFSIZ - 1)
	    {
	      memset (bp, *(bp - 1), c);
	      bp += c;
	      continue;
	    }
d3882 8
a3889 5
	  *bp = '\0';
	  printf_filtered ("Repeat count %d too large for buffer: ", c);
	  puts_filtered (buf);
	  puts_filtered ("\n");
	  return 0;
d3891 6
d3898 1
a3898 1
	  if (bp < buf + PBUFSIZ - 1)
d3900 1
a3900 1
	      *bp++ = c;
d3905 1
a3905 1
	  *bp = '\0';
d3910 1
a3910 1
	  return 0;
d3916 17
a3932 3
   store it in BUF.  BUF is expected to be of size PBUFSIZ.  If
   FOREVER, wait forever rather than timing out; this is used while
   the target is executing user code.  */
d3934 10
a3943 4
void
getpkt (buf, forever)
     char *buf;
     int forever;
d3950 1
a3950 1
  strcpy (buf,"timeout");
a3953 1
#ifdef MAINTENANCE_CMDS
a3954 3
#else
      timeout = -1;
#endif
d3965 2
a3966 2
	 continuously, but if it pauses, we'll get a zero from readchar
	 because of timeout.  Then we'll count that as a retry.  */
d3969 2
a3970 2
	 After that, we expect characters to arrive at a brisk pace.  They
	 should show up within remote_timeout intervals.  */
d3978 1
a3978 2
#ifdef MAINTENANCE_CMDS
	      if (forever)	/* Watchdog went off.  Kill the target. */
d3980 1
a3983 1
#endif
d3985 1
a3985 1
		puts_filtered ("Timed out.\n");
d3993 1
a3993 1
      val = read_frame (buf);
d3995 1
a3995 1
      if (val == 1)
d3998 5
a4002 1
	    fprintf_unfiltered (gdb_stdout, "Packet received: %s\n", buf);
d4004 1
a4004 1
	  return;
d4016 1
d4040 26
d4073 6
d4131 29
d4161 1
d4205 45
d4251 1
d4275 23
d4305 105
d4446 2
a4447 1
static unsigned long crc32_table[256] = {0, 0};
d4455 1
a4455 1
  if (! crc32_table[1])
d4462 5
a4466 5
        {
          for (c = i << 24, j = 8; j > 0; --j)
            c = c & 0x80000000 ? (c << 1) ^ 0x04c11db7 : (c << 1);
          crc32_table[i] = c;
        }
d4484 5
d4498 4
a4501 1
  char *tmp, *sectdata, *sectname, buf[PBUFSIZ];
d4513 1
a4513 1
  for (s = exec_bfd->sections; s; s = s->next) 
d4516 1
a4516 1
	continue;	/* skip non-loadable section */
d4520 1
a4520 1
	continue;	/* skip zero-length section */
d4524 1
a4524 1
	continue;	/* not the section selected by user */
d4526 1
a4526 1
      matched = 1;	/* do this section */
d4538 1
a4538 1
      getpkt (buf, 0);
d4548 2
a4549 2
      printf_filtered ("Section %s, range 0x%08x -- 0x%08x: ",
		       sectname, lma, lma + size);
d4553 4
a4556 4
       {
	 printf_filtered ("MIS-MATCHED!\n");
	 mismatched++;
       }
d4575 1
a4575 1
  char buf2[PBUFSIZ];
a4576 1
  char *p = buf;
d4578 1
a4578 1
  if (! bufsiz)
d4581 1
a4581 1
  /* minimum outbuf size is PBUFSIZE - if bufsiz is not large enough let 
d4584 1
a4584 1
  if ( *bufsiz < PBUFSIZ )
d4591 1
a4591 1
  if (! remote_desc)
d4595 1
a4595 1
  if ( (query_type < 'A') || (query_type > 'Z') )
d4598 1
a4598 1
  if (! buf)
d4601 1
a4601 1
  if (! outbuf)
d4614 1
a4614 1
  while ( buf[i] && (i < (PBUFSIZ - 8)) )
d4617 10
a4626 2
      if ( (!isprint(buf[i])) || (buf[i] == '$') || (buf[i] == '#') )
        error ("illegal characters in query string");
d4628 68
a4695 2
      *p2++ = buf[i];
      i++;
a4696 11
  *p2 = buf[i];

  if ( buf[i] )
    error ("query larger than available buffer");

  i = putpkt (buf2);
  if ( i < 0 ) return i;

  getpkt (outbuf, 0);

  return 0;
d4704 1
a4704 1
  char buf[PBUFSIZ];
d4706 1
a4706 1
  if (! remote_desc)
d4709 1
a4709 1
  if (! args)
d4717 1
a4717 1
  getpkt (buf, 0);
d4726 1
a4726 1
static void display_thread_info PARAMS ((struct gdb_ext_thread_info *info));
d4734 1
a4734 1
int get_and_display_threadinfo PARAMS ((threadref *ref));
d4738 1
a4738 1
static int thread_display_step PARAMS ((threadref *ref, void *context));
d4744 1
a4744 1
#define SAMPLE_THREAD  0x05060708  /* Truncated 64 bit threadid */
d4887 1
a4887 1
  remote_ops.to_shortname = "remote";		
d4889 1
a4889 1
  remote_ops.to_doc = 
d4891 4
a4894 3
Specify the serial device it is connected to (e.g. /dev/ttya).";  
  remote_ops.to_open = remote_open;		
  remote_ops.to_close = remote_close;		
d4896 1
a4896 1
  remote_ops.to_resume = remote_resume;	
d4901 2
a4902 2
  remote_ops.to_xfer_memory = remote_xfer_memory;	
  remote_ops.to_files_info = remote_files_info;	
d4905 2
a4906 2
  remote_ops.to_kill = remote_kill;		
  remote_ops.to_load = generic_load;		
d4909 1
d4912 1
d4914 7
a4920 7
  remote_ops.to_has_all_memory = 1;	
  remote_ops.to_has_memory = 1;	
  remote_ops.to_has_stack = 1;	
  remote_ops.to_has_registers = 1;	
  remote_ops.to_has_execution = 1;	
  remote_ops.to_has_thread_control = tc_schedlock; /* can lock scheduler */
  remote_ops.to_magic = OPS_MAGIC;	
d4931 2
a4932 2
  extended_remote_ops.to_shortname = "extended-remote";	
  extended_remote_ops.to_longname = 
d4934 1
a4934 1
  extended_remote_ops.to_doc = 
d4937 1
a4937 1
  extended_remote_ops.to_open = extended_remote_open;	
d4940 521
a5460 1
} 
d5465 12
d5482 10
a5491 1
  init_remote_threads ();
d5496 14
a5509 1
  add_cmd ("compare-sections", class_obscure, compare_sections_command, 
d5511 1
a5511 1
Argument is a single section name (default: all loaded sections).", 
d5523 1
a5523 1
  add_show_from_set 
d5525 1
a5525 1
		  var_integer, (char *)&remote_timeout,
d5530 1
a5530 1
  add_show_from_set 
d5532 1
a5532 1
		  var_integer, (char *)&remote_break,
d5537 32
a5568 6
  add_show_from_set 
    (add_set_cmd ("remotewritesize", no_class,
		  var_integer, (char *)&remote_write_size,
		  "Set the maximum number of bytes per memory write packet.\n",
		  &setlist),
     &showlist);
d5570 1
a5570 2
  remote_address_size = TARGET_PTR_BIT;
  add_show_from_set 
d5572 1
a5572 1
		  var_integer, (char *)&remote_address_size,
d5576 19
a5594 1
     &showlist);  
d5596 9
a5604 4
  add_show_from_set (add_set_cmd ("remotebinarydownload", no_class,
				  var_boolean, (char *) &remote_binary_download,
				  "Set binary downloads.\n", &setlist),
		     &showlist);
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@a205 1
#include <ctype.h>
a270 2
static void remote_interrupt_twice PARAMS ((int signo));

d433 5
a1615 5
/* The command line interface's stop routine. This function is installed
   as a signal handler for SIGINT. The first time a user requests a
   stop, we call remote_stop to send a break or ^C. If there is no
   response from the target (it didn't stop when the user requested it),
   we ask the user if he'd like to detach from the target. */
d1620 1
a1620 17
  /* If this doesn't work, try more severe steps. */
  signal (signo, remote_interrupt_twice);

  if (remote_debug)
    printf_unfiltered ("remote_interrupt called\n");

  target_stop ();
}

/* The user typed ^C twice.  */

static void
remote_interrupt_twice (signo)
     int signo;
{
  signal (signo, ofunc);
  interrupt_query ();
d1623 1
a1623 4

/* This is the generic stop called via the target vector. When a target
   interrupt is requested, either by the command line or the GUI, we
   will eventually end up here. */
d1627 7
a1633 3
  /* Send a break or a ^C, depending on user preference.  */
  if (remote_debug)
    printf_unfiltered ("remote_stop called\n");
d1635 5
a1639 2
  if (remote_break)
    SERIAL_SEND_BREAK (remote_desc);
d1641 6
a1646 1
    SERIAL_WRITE (remote_desc, "\003", 1);
d1708 1
d2096 1
a2096 4
   compute a wrong checksum, which causes real havoc with remote_write_bytes.

   NOTE: This can still lose if the serial line is not eight-bit clean. In
   cases like this, the user should clear "remotebinarydownload". */
d2156 1
a2156 1
  /* Subtract header overhead from max payload size -  $M<memaddr>,<len>:#nn */
d2185 1
a2185 1
      plen = p;			/* remember where len field goes */
d2195 2
a2196 2
	  int escaped = 0;
          for (i = 0;
d2198 1
a2198 1
	       i++)
d2216 5
a2220 5
          if (i < todo)
            {
              /* Escape chars have filled up the buffer prematurely, 
                 and we have actually sent fewer bytes than planned.
                 Fix-up the length field of the packet.  */
d2225 3
a2227 3
              plen += hexnumstr (plen, (ULONGEST) i);
              *plen++ = ':';
            }
d2734 1
d2736 3
d2762 1
d2768 1
d2813 1
a2813 1
  catch_errors ((catch_errors_ftype*) putpkt, "k", "", RETURN_MASK_ERROR);
@


1.1.1.3
log
@import gdb-19990504 snapshot
@
text
@a3386 1
  remote_ops.to_find_new_threads = remote_find_new_threads;
d3475 4
a3478 5
  add_show_from_set 
    (add_set_cmd ("remotebinarydownload", no_class,
		  var_boolean, (char *) &remote_binary_download,
		  "Set binary downloads.\n", &setlist),
     &showlist);
@


1.1.1.4
log
@import gdb-1999-05-25 snapshot
@
text
@d2350 3
a2352 8
   transferring to or from debugger address BUFFER.  Write to inferior if
   SHOULD_WRITE is nonzero.  Returns length of data written or read; 0
   for error.  */

#ifndef REMOTE_TRANSLATE_XFER_ADDRESS
#define REMOTE_TRANSLATE_XFER_ADDRESS(MEM_ADDR, MEM_LEN, TARG_ADDR, TARG_LEN) \
   (*(TARG_ADDR) = (MEM_ADDR), *(TARG_LEN) = (MEM_LEN))
#endif
d2356 4
a2359 4
remote_xfer_memory (mem_addr, buffer, mem_len, should_write, target)
     CORE_ADDR mem_addr;
     char *buffer;
     int mem_len;
d2363 5
a2367 4
  CORE_ADDR targ_addr;
  int targ_len;
  REMOTE_TRANSLATE_XFER_ADDRESS (mem_addr, mem_len, &targ_addr, &targ_len);
  if (targ_len <= 0)
d2369 3
d2373 2
a2374 2
  return dcache_xfer_memory (remote_dcache, targ_addr, buffer,
			     targ_len, should_write);
d3387 1
a3387 1
  remote_ops.to_find_new_threads = (void*) remote_find_new_threads;
@


1.1.1.5
log
@import gdb-1999-06-07 snapshot
@
text
@d316 68
d386 1
a386 1
static void remote_find_new_threads PARAMS ((void));
d390 2
d418 2
a451 4
/* Maximum number of bytes to read/write at once.  The value here
   is chosen to fill up a packet (the headers account for the 32).  */
#define MAXBUFBYTES(N) (((N)-32)/2)

d457 6
d464 7
a470 3
#define	PBUFSIZ ((REGISTER_BYTES > MAXBUFBYTES (400)) \
		 ? (REGISTER_BYTES * 2 + 32) \
		 : 400)
d478 1
a478 1
static int remote_write_size;
d515 1
a515 1
static int continue_thread;
d527 3
d531 4
a534 1

d549 1
a549 1
  int state = gen ? general_thread : continue_thread;
d568 1
a568 1
    general_thread  = th;
d570 1
a570 1
    continue_thread = th;
d576 2
a577 2
remote_thread_alive (tid)
     int tid;
d579 1
a579 1
  char buf[16];
d581 3
a583 2
  if (tid < 0)
    sprintf (buf, "T-%08x", -tid);
d585 1
a585 1
    sprintf (buf, "T%08x", tid);
a596 38
#define OPAQUETHREADBYTES 8

/* a 64 bit opaque identifier */
typedef unsigned char threadref[OPAQUETHREADBYTES];

/* WARNING: This threadref data structure comes from the remote O.S., libstub
   protocol encoding, and remote.c. it is not particularly changable */

/* Right now, the internal structure is int. We want it to be bigger.
   Plan to fix this.
   */

typedef int gdb_threadref; /* internal GDB thread reference */

/*  gdb_ext_thread_info is an internal GDB data structure which is
   equivalint to the reply of the remote threadinfo packet */

struct gdb_ext_thread_info
{
  threadref threadid;	  /* External form of thread reference */
  int active;		  /* Has state interesting to GDB? , regs, stack */
  char display[256];	  /* Brief state display, name, blocked/syspended */
  char shortname[32];	  /* To be used to name threads */
  char more_display[256]; /* Long info, statistics, queue depth, whatever */
};

/* The volume of remote transfers can be limited by submitting
   a mask containing bits specifying the desired information.
   Use a union of these values as the 'selection' parameter to
   get_thread_info. FIXME: Make these TAG names more thread specific.
   */

#define TAG_THREADID 1
#define TAG_EXISTS 2
#define TAG_DISPLAY 4
#define TAG_THREADNAME 8
#define TAG_MOREDISPLAY 16 

a598 68
char *unpack_varlen_hex PARAMS ((char *buff, int *result));

static char *unpack_nibble PARAMS ((char *buf, int *val));

static char *pack_nibble PARAMS ((char *buf, int nibble));

static char *pack_hex_byte PARAMS ((char *pkt, int/*unsigned char*/ byte));

static char *unpack_byte PARAMS ((char *buf, int *value));

static char *pack_int PARAMS ((char *buf, int value));

static char *unpack_int PARAMS ((char *buf, int *value));

static char *unpack_string PARAMS ((char *src, char *dest, int length));

static char *pack_threadid PARAMS ((char *pkt, threadref *id));

static char *unpack_threadid PARAMS ((char *inbuf, threadref *id));

void int_to_threadref PARAMS ((threadref *id, int value));

static int threadref_to_int PARAMS ((threadref *ref));

static void copy_threadref PARAMS ((threadref *dest, threadref *src));

static int threadmatch PARAMS ((threadref *dest, threadref *src));

static char *pack_threadinfo_request PARAMS ((char *pkt, int mode,
					      threadref *id));

static int remote_unpack_thread_info_response PARAMS ((char *pkt,
						       threadref *expectedref,
						       struct gdb_ext_thread_info *info));


static int remote_get_threadinfo PARAMS ((threadref *threadid,
					  int fieldset,	/*TAG mask */
					  struct gdb_ext_thread_info *info));

static int adapt_remote_get_threadinfo PARAMS ((gdb_threadref *ref,
						int selection,
						struct gdb_ext_thread_info *info));

static char *pack_threadlist_request PARAMS ((char *pkt, int startflag,
					      int threadcount,
					      threadref *nextthread));

static int parse_threadlist_response PARAMS ((char *pkt,
					      int result_limit,
					      threadref *original_echo,
					      threadref *resultlist,
					      int *doneflag));

static int remote_get_threadlist PARAMS ((int startflag,
					  threadref *nextthread,
					  int result_limit,
					  int *done,
					  int *result_count,
					  threadref *threadlist));

typedef int (*rmt_thread_action) (threadref *ref, void *context);

static int remote_threadlist_iterator PARAMS ((rmt_thread_action stepfunction,
					       void *context, int looplimit));

static int remote_newthread_step PARAMS ((threadref *ref, void *context));

d1235 1
a1235 3
/* Find new threads for info threads command.  */

static void
d1238 3
a1240 1
  remote_threadlist_iterator (remote_newthread_step, 0, 
d1244 11
d1470 5
d1481 2
a1482 2
  general_thread  = -2;
  continue_thread = -2;
d3124 1
a3124 1
  /* minimum outbuf size is PBUFSIZ - if bufsiz is not large enough let 
d3388 1
a3388 1
  remote_ops.to_find_new_threads = remote_find_new_threads;
a3422 3
  /* runtime constants */
  remote_write_size = PBUFSIZ;

d3428 1
a3428 1

@


1.1.1.6
log
@import gdb-1999-06-14 snapshot
@
text
@a143 11
	or (obsolete)	NAA;tttttttt;dddddddd;bbbbbbbb
					AA = signal number
					tttttttt = address of symbol "_start"
					dddddddd = base of data section
					bbbbbbbb = base of bss  section.
					Note: only used by Cisco Systems 
					targets.  The difference between this
					reply and the "qOffsets" query is that
					the 'N' packet may arrive spontaneously
					whereas the 'qOffsets' is a query
					initiated by the host debugger.
a215 2
static void build_remote_gdbarch_data PARAMS ((void));

a293 4
static void init_remote_cisco_ops PARAMS ((void));

static struct target_ops remote_cisco_ops;

a368 4
/* This is set by the target (thru the 'S' message)
   to denote that the target is in kernel mode.  */
static int cisco_kernel_mode = 0;

d454 1
a454 4
    {
      add_thread (currthread);
      printf_filtered ("[New %s]\n", target_pid_to_str (currthread));
    }
a1266 29
static void
remote_threads_info (void)
{
  char buf[PBUFSIZ], *bufp;
  int tid;

  if (remote_desc == 0)		/* paranoia */
    error ("Command can only be used when connected to the remote target.");

  putpkt ("qfThreadInfo");
  getpkt (bufp = buf, 0);
  if (bufp[0] == '\0')		/* q packet not recognized! */
    {				/* try old jmetzler method  */
      remote_find_new_threads ();
      return;
    }
  else				/* try new 'q' method */
    while (*bufp++ == 'm')		/* reply contains one or more TID */
      {
	do {
	  tid = strtol(bufp, &bufp, 16);
	  if (tid != 0 && !in_thread_list (tid))
	    add_thread (tid);
	} while (*bufp++ == ',');		/* comma-separated list */
	putpkt ("qsThreadInfo");
	getpkt (bufp = buf, 0);
      }
}

a1383 125
/*
 * Cisco version of section offsets:
 *
 * Instead of having GDB query the target for the section offsets,
 * Cisco lets the target volunteer the information!  It's also in
 * a different format, so here are the functions that will decode
 * a section offset packet from a Cisco target.
 */

/* 
 * Function: remote_cisco_section_offsets
 *
 * Returns:  zero for success, non-zero for failure 
 */

static int 
remote_cisco_section_offsets (text_addr, data_addr, bss_addr, 
			      text_offs, data_offs, bss_offs)
     bfd_vma text_addr;
     bfd_vma data_addr;
     bfd_vma bss_addr;
     bfd_signed_vma * text_offs;
     bfd_signed_vma * data_offs;
     bfd_signed_vma * bss_offs;
{
  bfd_vma text_base, data_base, bss_base;
  struct minimal_symbol *start;
  asection *sect;
  bfd * abfd;
  int len;
  char *p;

  if (symfile_objfile == NULL)
    return -1;		/* no can do nothin' */

  start = lookup_minimal_symbol ("_start", NULL, NULL);
  if (start == NULL)
    return -1;		/* Can't find "_start" symbol */

  data_base = bss_base = 0;
  text_base = SYMBOL_VALUE_ADDRESS (start);

  abfd = symfile_objfile->obfd;
    for (sect = abfd->sections; 
       sect != 0;
       sect = sect->next)
    {
      p   = (unsigned char *) bfd_get_section_name (abfd, sect);
      len = strlen (p);
      if (strcmp (p + len - 4, "data") == 0)	/* ends in "data" */
	if (data_base == 0 ||
	    data_base > bfd_get_section_vma (abfd, sect))
	  data_base = bfd_get_section_vma (abfd, sect);
      if (strcmp (p + len - 3, "bss") == 0)	/* ends in "bss" */
	if (bss_base == 0 || 
	    bss_base > bfd_get_section_vma (abfd, sect))
	  bss_base = bfd_get_section_vma (abfd, sect);
    }
  *text_offs = text_addr - text_base;
  *data_offs = data_addr - data_base;
  *bss_offs  = bss_addr  - bss_base;
  if (remote_debug)
    {
      char tmp[128];

      sprintf (tmp, "VMA:          text = 0x");
      sprintf_vma (tmp + strlen (tmp), text_addr);
      sprintf     (tmp + strlen (tmp), " data = 0x");
      sprintf_vma (tmp + strlen (tmp), data_addr);
      sprintf     (tmp + strlen (tmp), " bss = 0x");
      sprintf_vma (tmp + strlen (tmp), bss_addr);
      fprintf_filtered (gdb_stdlog, tmp);
      fprintf_filtered (gdb_stdlog,
			"Reloc offset: text = 0x%x data = 0x%x bss = 0x%x\n",
		       (long) *text_offs, (long) *data_offs, (long) *bss_offs);
    }

  return 0;
}

/*
 * Function: remote_cisco_objfile_relocate
 *
 * Relocate the symbol file for a remote target. 
 */

static void
remote_cisco_objfile_relocate (text_off, data_off, bss_off)
     bfd_signed_vma text_off;
     bfd_signed_vma data_off;
     bfd_signed_vma bss_off;
{
  struct section_offsets *offs;

  if (text_off != 0 || data_off != 0 || bss_off  != 0)
    {
      /* FIXME: This code assumes gdb-stabs.h is being used; it's
	 broken for xcoff, dwarf, sdb-coff, etc.  But there is no
	 simple canonical representation for this stuff.  */

      offs = ((struct section_offsets *)
	      alloca (sizeof (struct section_offsets)
		      + (symfile_objfile->num_sections
			 * sizeof (offs->offsets))));

      memcpy (offs, symfile_objfile->section_offsets,
	      (sizeof (struct section_offsets)
	       + (symfile_objfile->num_sections
		  * sizeof (offs->offsets))));

      ANOFFSET (offs, SECT_OFF_TEXT) = text_off;
      ANOFFSET (offs, SECT_OFF_DATA) = data_off;
      ANOFFSET (offs, SECT_OFF_BSS)  = bss_off;

      /* First call the standard objfile_relocate.  */
      objfile_relocate (symfile_objfile, offs);

      /* Now we need to fix up the section entries already attached to
	 the exec target.  These entries will control memory transfers
	 from the exec file.  */

      exec_set_section_offsets (text_off, data_off, bss_off);
    }
}

a1386 8
remote_start_remote_dummy (dummy)
     char *dummy;
{
  start_remote ();		/* Initialize gdb process mechanisms */
  return 1;
}

static int
d1405 2
a1406 1
  return remote_start_remote_dummy (dummy);
d1632 1
a1632 1
    fprintf_unfiltered (gdb_stdlog, "remote_interrupt called\n");
d1656 1
a1656 1
    fprintf_unfiltered (gdb_stdlog, "remote_stop called\n");
d1704 3
a1706 4
/* Wait until the remote machine stops, then return,
   storing status in STATUS just as `wait' would.
   Returns "pid", which in the case of a multi-threaded 
   remote OS, is the thread-id.  */
a1810 22
	  if (buf[3] == 'p')
	    {
	      /* Export Cisco kernel mode as a convenience variable
		 (so that it can be used in the GDB prompt if desired). */

	      if (cisco_kernel_mode == 1)
		set_internalvar (lookup_internalvar ("cisco_kernel_mode"), 
				 value_from_string ("PDEBUG-"));
	      cisco_kernel_mode = 0;
	      thread_num = strtol ((const char *) &buf[4], NULL, 16);
	      record_currthread (thread_num);
	    }
	  else if (buf[3] == 'k')
	    {
	      /* Export Cisco kernel mode as a convenience variable
		 (so that it can be used in the GDB prompt if desired). */

	      if (cisco_kernel_mode == 1)
		set_internalvar (lookup_internalvar ("cisco_kernel_mode"), 
				 value_from_string ("KDEBUG-"));
	      cisco_kernel_mode = 1;
	    }
a1811 43
	case 'N':		/* Cisco special: status and offsets */
	  {
	    bfd_vma text_addr, data_addr, bss_addr;
	    bfd_signed_vma text_off, data_off, bss_off;
	    unsigned char *p1;

	    status->kind = TARGET_WAITKIND_STOPPED;
	    status->value.sig = (enum target_signal)
	      (((fromhex (buf[1])) << 4) + (fromhex (buf[2])));

	    if (symfile_objfile == NULL) 
	      {
		warning ("Relocation packet recieved with no symbol file.  \
Packet Dropped");
		goto got_status;
	      }

	    /* Relocate object file.  Buffer format is NAATT;DD;BB
	     * where AA is the signal number, TT is the new text
	     * address, DD * is the new data address, and BB is the
	     * new bss address.  */

	    p = &buf[3];
	    text_addr = strtoul (p, (char **) &p1, 16);
	    if (p1 == p || *p1 != ';')
	      warning ("Malformed relocation packet: Packet '%s'", buf);
	    p = p1 + 1;
	    data_addr = strtoul (p, (char **) &p1, 16);
	    if (p1 == p || *p1 != ';')
	      warning ("Malformed relocation packet: Packet '%s'", buf);
	    p = p1 + 1;
	    bss_addr = strtoul (p, (char **) &p1, 16);
	    if (p1 == p) 
	      warning ("Malformed relocation packet: Packet '%s'", buf);

	    if (remote_cisco_section_offsets (text_addr, data_addr, bss_addr,
					      &text_off, &data_off, &bss_off)
		== 0)
	      if (text_off != 0 || data_off != 0 || bss_off  != 0) 
		remote_cisco_objfile_relocate (text_off, data_off, bss_off);

	    goto got_status;
	  }
d1854 9
d1904 1
a1904 2
	fprintf_unfiltered (gdb_stdlog,
			    "Bad register packet; fetching a new packet\n");
d2141 1
a2141 2
	fprintf_unfiltered (gdb_stdlog,
			    "binary downloading suppported by target\n");
d2143 1
a2143 2
	fprintf_unfiltered (gdb_stdlog,
			    "binary downloading NOT suppported by target\n");
d2569 2
a2570 2
	  fprintf_unfiltered (gdb_stdlog, "Sending packet: %s...", buf2);
	  gdb_flush (gdb_stdlog);
d2599 1
a2599 1
		fprintf_unfiltered (gdb_stdlog, "Ack\n");
d2621 1
a2621 1
		      fprintf_unfiltered (gdb_stdlog, "putpkt: Junk: ");
d2623 1
a2623 1
		  fputc_unfiltered (ch & 0177, gdb_stdlog);
a2644 26
static int remote_cisco_mode;

static void remote_cisco_expand (src, dest)
     char *src;
     char *dest;
{
  int i;
  int repeat;

  do {
    if (*src == '*') 
      {
	repeat = (fromhex (src[1]) << 4) + fromhex (src[2]);
	for (i = 0; i < repeat; i++) 
	  {
	    *dest++ = *(src-1);
	  }
	src += 2;
      }
    else 
      {
	*dest++ = *src;
      }
  } while (*src++);
}

d2668 1
a2668 1
	    fputs_filtered ("Timeout in mid-packet, retrying\n", gdb_stdlog);
d2672 1
a2672 2
	    fputs_filtered ("Saw new packet start in middle of old one\n",
			    gdb_stdlog);
d2684 1
a2684 10
	      {
		if (remote_cisco_mode)	/* variant run-length-encoding */
		  {
		    char tmp_buf[PBUFSIZ];

		    remote_cisco_expand (buf, tmp_buf);
		    strcpy (buf, tmp_buf);
		  }
		return 1;
	      }
d2688 4
a2691 5
		fprintf_filtered (gdb_stdlog,
				  "Bad checksum, sentsum=0x%x, csum=0x%x, buf=",
				  pktcsum, csum);
		fputs_filtered (buf, gdb_stdlog);
		fputs_filtered ("\n", gdb_stdlog);
d2696 7
a2702 1
	  if (remote_cisco_mode == 0)	/* variant run-length-encoding */
d2704 4
a2707 4
	      csum += c;
	      c = readchar (remote_timeout);
	      csum += c;
	      c = c - ' ' + 3;	/* Compute repeat count */
d2709 5
a2713 6
	      if (c > 0 && c < 255 && bp + c - 1 < buf + PBUFSIZ - 1)
		{
		  memset (bp, *(bp - 1), c);
		  bp += c;
		  continue;
		}
a2714 7
	      *bp = '\0';
	      printf_filtered ("Repeat count %d too large for buffer: ", c);
	      puts_filtered (buf);
	      puts_filtered ("\n");
	      return 0;
	    }
	  /* else fall thru to treat like default */
d2782 1
a2782 1
		fputs_filtered ("Timed out.\n", gdb_stdlog);
d2795 1
a2795 1
	    fprintf_unfiltered (gdb_stdlog, "Packet received: %s\n", buf);
d3393 1
a3393 1
  remote_ops.to_find_new_threads = remote_threads_info;
d3414 1
a3414 1
  extended_remote_ops.to_shortname = "extended-remote";
d3420 1
a3420 1
  extended_remote_ops.to_open = extended_remote_open;
d3423 1
a3423 399
}

/*
 * Command: info remote-process
 *
 * This implements Cisco's version of the "info proc" command.
 *
 * This query allows the target stub to return an arbitrary string
 * (or strings) giving arbitrary information about the target process.
 * This is optional; the target stub isn't required to implement it.
 *
 * Syntax: qfProcessInfo        request first string
 *         qsProcessInfo        request subsequent string
 * reply:  'O'<hex-encoded-string>
 *         'l'                  last reply (empty)
 */

static void
remote_info_process (args, from_tty)
     char *args;
     int from_tty;
{
  char buf[PBUFSIZ];

  if (remote_desc == 0)
    error ("Command can only be used when connected to the remote target.");

  putpkt ("qfProcessInfo");
  getpkt (buf, 0);
  if (buf[0] == 0)
    return;             /* Silently: target does not support this feature. */

  if (buf[0] == 'E')
    error ("info proc: target error.");

  while (buf[0] == 'O') /* Capitol-O packet */
    {
      remote_console_output (&buf[1]);
      putpkt ("qsProcessInfo");
      getpkt (buf, 0);
    }
}

/*
 * Target Cisco 
 */

static void
remote_cisco_open (name, from_tty)
     char *name;
     int from_tty;
{
  if (name == 0)
    error (
"To open a remote debug connection, you need to specify what \n\
device is attached to the remote system (e.g. host:port).");

  target_preopen (from_tty);

  unpush_target (&remote_cisco_ops);

  remote_dcache = dcache_init (remote_read_bytes, remote_write_bytes);

  remote_desc = SERIAL_OPEN (name);
  if (!remote_desc)
    perror_with_name (name);

  /*
   * If a baud rate was specified on the gdb  command line it will
   * be greater than the initial value of -1.  If it is, use it otherwise
   * default to 9600
   */

  baud_rate = (baud_rate > 0) ? baud_rate : 9600;
  if (SERIAL_SETBAUDRATE (remote_desc, baud_rate)) 
    {
      SERIAL_CLOSE (remote_desc);
      perror_with_name (name);
    }

  SERIAL_RAW (remote_desc);

  /* If there is something sitting in the buffer we might take it as a
     response to a command, which would be bad.  */
  SERIAL_FLUSH_INPUT (remote_desc);

  if (from_tty)
    {
      puts_filtered ("Remote debugging using ");
      puts_filtered (name);
      puts_filtered ("\n");
    }

  remote_cisco_mode = 1;

  push_target (&remote_cisco_ops);	/* Switch to using cisco target now */

  /* Start out by trying the 'P' request to set registers.  We set this each
     time that we open a new target so that if the user switches from one
     stub to another, we can (if the target is closed and reopened) cope.  */
  stub_supports_P = 1;

  general_thread  = -2;
  continue_thread = -2;

  /* Force remote_write_bytes to check whether target supports
     binary downloading. */
  remote_binary_checked = 0;

  /* Without this, some commands which require an active target (such
     as kill) won't work.  This variable serves (at least) double duty
     as both the pid of the target process (if it has such), and as a
     flag indicating that a target is active.  These functions should
     be split out into seperate variables, especially since GDB will
     someday have a notion of debugging several processes.  */
  inferior_pid = MAGIC_NULL_PID;

  /* Start the remote connection; if error (0), discard this target. */

  if (!catch_errors (remote_start_remote_dummy, (char *) 0, 
		     "Couldn't establish connection to remote target\n", 
		     RETURN_MASK_ALL))
    {
      pop_target ();
      return;
    }
}

static void
remote_cisco_close (quitting)
     int quitting;
{
  remote_cisco_mode = 0;
  remote_close (quitting);
}

static void 
remote_cisco_mourn PARAMS ((void))
{
  remote_mourn_1 (&remote_cisco_ops);
}

enum {
  READ_MORE, 
  FATAL_ERROR, 
  ENTER_DEBUG, 
  DISCONNECT_TELNET
} minitelnet_return;

/* shared between readsocket() and readtty()  */
static char *tty_input;

static int escape_count;
static int echo_check;
extern int quit_flag;

static int
readsocket ()
{
  int data;

  /* Loop until the socket doesn't have any more data */

  while ((data = readchar (0)) >= 0) 
    {
      /* Check for the escape sequence */
      if (data == '|') 
	{
	  /* If this is the fourth escape, get out */
	  if (++escape_count == 4) 
	    {
	      return ENTER_DEBUG;
	    }
	  else 
	    { /* This is a '|', but not the fourth in a row. 
		 Continue without echoing it.  If it isn't actually 
		 one of four in a row, it'll be echoed later.  */
	      continue;
	    }
	}
      else /* Not a '|' */
	{ 
	  /* Ensure any pending '|'s are flushed.  */

	  for ( ; escape_count > 0; escape_count--)
	    putchar('|');
	}
		
      if (data == '\r')			/* If this is a return character, */
	continue;			/*  - just supress it. */

      if (echo_check != -1) 		/* Check for echo of user input.  */
	{
	  if (tty_input[echo_check] == data)
	    {
	      echo_check++;		/* Character matched user input: */
	      continue;			/* Continue without echoing it.  */
	    }
	  else if ((data == '\n') && (tty_input[echo_check] == '\r')) 
	    { /* End of the line (and of echo checking).  */
	      echo_check = -1;		/* No more echo supression */
	      continue;			/* Continue without echoing.  */
	    }
	  else
	    { /* Failed check for echo of user input.
		 We now have some suppressed output to flush!  */
	      int j;

	      for (j = 0; j < echo_check; j++) 
		putchar (tty_input[j]);
	      echo_check = -1;
	    }
	}
      putchar (data);			/* Default case: output the char.  */
    }

  if (data == SERIAL_TIMEOUT)		/* Timeout returned from readchar.  */
    return READ_MORE;			/* Try to read some more */
  else 
    return FATAL_ERROR;			/* Trouble, bail out */
}

static int
readtty ()
{
  int status;
  int tty_bytecount;

  /* First, read a buffer full from the terminal */
  tty_bytecount = read (fileno (stdin), tty_input, sizeof (tty_input) - 1);
  if (tty_bytecount == -1) 
    {
      perror ("readtty: read failed");
      return FATAL_ERROR;
    }

  /* Remove a quoted newline.  */
  if (tty_input[tty_bytecount - 1] == '\n' &&
      tty_input[tty_bytecount - 2] == '\\')	/* line ending in backslash */
    {
      tty_input[--tty_bytecount] = 0;		/* remove newline */
      tty_input[--tty_bytecount] = 0;		/* remove backslash */
    }

  /* Turn trailing newlines into returns */
  if (tty_input[tty_bytecount - 1] == '\n')
    tty_input[tty_bytecount - 1]   =  '\r';

  /* If the line consists of a ~, enter debugging mode.  */
  if ((tty_input[0] == '~') && (tty_bytecount == 2))
    return ENTER_DEBUG;

  /* Make this a zero terminated string and write it out */
  tty_input[tty_bytecount] = 0;
  if (SERIAL_WRITE (remote_desc, tty_input, tty_bytecount)) 
    {
      perror_with_name ("readtty: write failed");
      return FATAL_ERROR;
    }

  return READ_MORE;
}

static int
minitelnet ()
{
  fd_set input;			/* file descriptors for select */
  int    tablesize;		/* max number of FDs for select */
  int    status;
  int    quit_count = 0;

  extern int escape_count;	/* global shared by readsocket */
  extern int echo_check;	/* ditto */

  escape_count = 0;
  echo_check   = -1;

  tablesize = 8 * sizeof (input);

  for (;;) 
    {
      /* Check for anything from our socket - doesn't block. Note that
	 this must be done *before* the select as there may be
	 buffered I/O waiting to be processed.  */

      if ((status = readsocket ()) == FATAL_ERROR) 
	{
	  error ("Debugging terminated by communications error");
	}
      else if (status != READ_MORE) 
	{
	  return (status);
	}

      fflush(stdout);			/* Flush output before blocking */

      /* Now block on more socket input or TTY input */
    
      FD_ZERO (&input);
      FD_SET (fileno(stdin), &input);
      FD_SET (remote_desc->fd, &input);

      status = select (tablesize, &input, 0, 0, 0);
      if ((status == -1) && (errno != EINTR)) 
	{
	  error ("Communications error on select %d", errno);
	}

      /* Handle Control-C typed */

      if (quit_flag) 
	{
	  if ((++quit_count) == 2)
	    {
	      if (query ("Interrupt GDB? "))
		{
		  printf_filtered ("Interrupted by user.\n");
		  return_to_top_level (RETURN_QUIT);
		}
	      quit_count = 0;
	    }
	  quit_flag = 0;

	  if (remote_break)
	    SERIAL_SEND_BREAK (remote_desc);
	  else
	    SERIAL_WRITE (remote_desc, "\003", 1);

	  continue;
	}

      /* Handle console input */

      if (FD_ISSET (fileno (stdin), &input)) 
	{
	  quit_count = 0;
	  echo_check = 0;
	  status = readtty ();
	  if (status == READ_MORE)
	    continue;

	  return status;	/* telnet session ended */
	}
    }
}

static int
remote_cisco_wait (pid, status)
     int pid;
     struct target_waitstatus *status;
{
  if (minitelnet() != ENTER_DEBUG) 
    {
      error ("Debugging session terminated by protocol error");
    }
  putpkt ("?");
  return remote_wait (pid, status);
}

static void
init_remote_cisco_ops ()
{
  remote_cisco_ops.to_shortname = "cisco";
  remote_cisco_ops.to_longname  = "Remote serial target in cisco-specific protocol";
  remote_cisco_ops.to_doc       = 
    "Use a remote machine via TCP, using a cisco-specific protocol.\n\
Specify the serial device it is connected to (e.g. host:2020).";
  remote_cisco_ops.to_open              = remote_cisco_open;
  remote_cisco_ops.to_close             = remote_cisco_close;
  remote_cisco_ops.to_detach            = remote_detach;
  remote_cisco_ops.to_resume            = remote_resume;
  remote_cisco_ops.to_wait              = remote_cisco_wait;
  remote_cisco_ops.to_fetch_registers   = remote_fetch_registers;
  remote_cisco_ops.to_store_registers   = remote_store_registers;
  remote_cisco_ops.to_prepare_to_store  = remote_prepare_to_store;
  remote_cisco_ops.to_xfer_memory       = remote_xfer_memory;
  remote_cisco_ops.to_files_info        = remote_files_info;
  remote_cisco_ops.to_insert_breakpoint = remote_insert_breakpoint;
  remote_cisco_ops.to_remove_breakpoint = remote_remove_breakpoint;
  remote_cisco_ops.to_kill              = remote_kill;
  remote_cisco_ops.to_load              = generic_load;
  remote_cisco_ops.to_mourn_inferior    = remote_cisco_mourn;
  remote_cisco_ops.to_thread_alive      = remote_thread_alive;
  remote_cisco_ops.to_find_new_threads  = remote_threads_info;
  remote_cisco_ops.to_stratum           = process_stratum;
  remote_cisco_ops.to_has_all_memory    = 1;
  remote_cisco_ops.to_has_memory        = 1;
  remote_cisco_ops.to_has_stack         = 1;
  remote_cisco_ops.to_has_registers     = 1;
  remote_cisco_ops.to_has_execution     = 1;
  remote_cisco_ops.to_magic             = OPS_MAGIC;
}

static void
build_remote_gdbarch_data ()
{
  tty_input = xmalloc (PBUFSIZ);
}

d3428 1
a3428 7
  /* architecture specific data */
  build_remote_gdbarch_data ();
  register_gdbarch_swap (&tty_input, sizeof (&tty_input), NULL);
  register_gdbarch_swap (NULL, 0, build_remote_gdbarch_data);

  /* runtime constants - we retain the value of remote_write_size
     across architecture swaps. */
a3436 3
  init_remote_cisco_ops ();
  add_target (&remote_cisco_ops);

a3489 4

  add_info ("remote-process", remote_info_process,
	    "Query the remote system for process info.");

@


1.1.1.7
log
@import gdb-1999-06-28 snapshot
@
text
@d488 1
a488 1
  char *buf = alloca (PBUFSIZ);
d1062 1
a1062 1
  char *threadinfo_pkt = alloca (PBUFSIZ);
d1149 2
a1150 2
  char *threadlist_packet = alloca (PBUFSIZ);
  char *t_response = alloca (PBUFSIZ);
d1270 1
a1270 1
  char *buf = alloca (PBUFSIZ);
d1294 1
a1294 2
  char *buf = alloca (PBUFSIZ);
  char *bufp;
d1326 1
a1326 1
  char *buf = alloca (PBUFSIZ);
d1357 1
a1357 2
  char *buf = alloca (PBUFSIZ);
  char *ptr;
d1417 1
a1417 1
  offs = alloca (sizeof (struct section_offsets)
d1700 1
a1700 1
      char *buf = alloca (PBUFSIZ);
d1716 1
a1716 1
  char *buf = alloca (PBUFSIZ);
d1769 1
a1769 1
  char *buf = alloca (PBUFSIZ);
d1899 1
a1899 1
  unsigned char *buf = alloca (PBUFSIZ);
d2122 1
a2122 1
  char *buf = alloca (PBUFSIZ);
d2210 1
a2210 1
  char *buf = alloca (PBUFSIZ);
d2363 1
a2363 2
      char *buf = alloca (PBUFSIZ);
      char *p;
a2405 1
  unsigned char *buf = alloca (PBUFSIZ);
d2424 1
a2536 1
  char *buf = alloca (PBUFSIZ);
d2549 1
d2650 1
a2650 1
      char *buf = alloca (PBUFSIZ);
d2782 1
a2782 3
  char *buf2 = alloca (PBUFSIZ);
  char *junkbuf = alloca (PBUFSIZ);

d2853 2
d2959 1
a2959 1
		    char *tmp_buf = alloca (PBUFSIZ);
d3332 1
a3332 4
  char *tmp;
  char *sectdata;
  char *sectname;
  char *buf = alloca (PBUFSIZ);
d3406 1
a3406 1
  char *buf2 = alloca (PBUFSIZ);
d3473 1
a3473 1
  char *buf = alloca (PBUFSIZ);
d3729 1
a3729 1
  char *buf = alloca (PBUFSIZ);
@


1.1.1.8
log
@import gdb-1999-07-05 snapshot
@
text
@d2 1
a2 1
   Copyright 1988, 91, 92, 93, 94, 95, 96, 97, 98, 1999 
a221 6
#ifdef HAVE_SYS_SELECT_H
#include <sys/select.h>
#endif

#include "event-loop.h"

a225 7
static void initialize_sigint_signal_handler PARAMS ((void));
static void handle_remote_sigint PARAMS ((int));
static void handle_remote_sigint_twice PARAMS ((int));
static void async_remote_interrupt PARAMS ((gdb_client_data));
static void async_remote_interrupt_twice PARAMS ((gdb_client_data));

static void set_extended_protocol PARAMS ((struct continuation_arg *));
a246 2
static void remote_async_resume PARAMS ((int pid, int step,
				   enum target_signal siggnal));
a250 1
static void remote_async_open PARAMS ((char *name, int from_tty));
a252 1
static void extended_remote_async_open PARAMS ((char *name, int from_tty));
a255 2
static void remote_async_open_1 PARAMS ((char *, int, struct target_ops *,
				   int extended_p));
a267 1
static void extended_remote_async_create_inferior PARAMS ((char *, char *, char **));
a275 1
static int remote_async_wait PARAMS ((int pid, struct target_waitstatus * status));
a277 1
static void remote_async_kill PARAMS ((void));
a281 1
static void remote_async_detach PARAMS ((char *args, int from_tty));
a364 6
/* Temporary target ops. Just like the remote_ops and
   extended_remote_ops, but with asynchronous support. */
static struct target_ops remote_async_ops;

static struct target_ops extended_async_remote_ops;

a446 4
/* Tokens for use by the asynchronous signal handlers for SIGINT */
PTR sigint_remote_twice_token;
PTR sigint_remote_token;

a1606 9
/* Just like remote_open, but with asynchronous support. */
static void
remote_async_open (name, from_tty)
     char *name;
     int from_tty;
{
  remote_async_open_1 (name, from_tty, &remote_async_ops, 0);
}

a1617 9
/* Just like extended_remote_open, but with asynchronous support. */
static void
extended_remote_async_open (name, from_tty)
     char *name;
     int from_tty;
{
  remote_async_open_1 (name, from_tty, &extended_async_remote_ops, 1/*extended_p*/);
}

d1652 1
a1707 118
/* Just like remote_open but with asynchronous support. */
static void
remote_async_open_1 (name, from_tty, target, extended_p)
     char *name;
     int from_tty;
     struct target_ops *target;
     int extended_p;
{
  if (name == 0)
    error ("To open a remote debug connection, you need to specify what\n\
serial device is attached to the remote system (e.g. /dev/ttya).");

  target_preopen (from_tty);

  unpush_target (target);

  remote_dcache = dcache_init (remote_read_bytes, remote_write_bytes);

  remote_desc = SERIAL_OPEN (name);
  if (!remote_desc)
    perror_with_name (name);

  if (baud_rate != -1)
    {
      if (SERIAL_SETBAUDRATE (remote_desc, baud_rate))
	{
	  SERIAL_CLOSE (remote_desc);
	  perror_with_name (name);
	}
    }

  SERIAL_RAW (remote_desc);

  /* If there is something sitting in the buffer we might take it as a
     response to a command, which would be bad.  */
  SERIAL_FLUSH_INPUT (remote_desc);

  if (from_tty)
    {
      puts_filtered ("Remote debugging using ");
      puts_filtered (name);
      puts_filtered ("\n");
    }

  /* If running in asynchronous mode, register the target with the
     event loop.  Set things up so that when there is an event on the
     file descriptor, the event loop will call fetch_inferior_event,
     which will do the proper analysis to determine what happened. */
  if (async_p)
    add_file_handler (remote_desc->fd, (file_handler_func *) fetch_inferior_event, 0);

  push_target (target);	/* Switch to using remote target now */

  /* Start out by trying the 'P' request to set registers.  We set
     this each time that we open a new target so that if the user
     switches from one stub to another, we can (if the target is
     closed and reopened) cope.  */
  stub_supports_P = 1;

  general_thread  = -2;
  continue_thread = -2;

  /* Force remote_write_bytes to check whether target supports
     binary downloading. */
  remote_binary_checked = 0;

  /* If running asynchronously, set things up for telling the target
     to use the extended protocol. This will happen only after the
     target has been connected to, in fetch_inferior_event. */
  if (extended_p && async_p)
    add_continuation (set_extended_protocol, NULL);

  /* Without this, some commands which require an active target (such
     as kill) won't work.  This variable serves (at least) double duty
     as both the pid of the target process (if it has such), and as a
     flag indicating that a target is active.  These functions should
     be split out into seperate variables, especially since GDB will
     someday have a notion of debugging several processes.  */

  inferior_pid = MAGIC_NULL_PID;
  /* Start the remote connection; if error (0), discard this target.
     In particular, if the user quits, be sure to discard it
     (we'd be in an inconsistent state otherwise).  */
  if (!catch_errors (remote_start_remote, NULL, 
		     "Couldn't establish connection to remote target\n", 
		     RETURN_MASK_ALL))
    {
      /* Unregister the file descriptor from the event loop. */
      if (async_p)
	delete_file_handler (remote_desc->fd);
      pop_target ();
      return;
    }

  if (!async_p)
    {
    if (extended_p)
      {
	/* tell the remote that we're using the extended protocol.  */
	char *buf = alloca (PBUFSIZ);
	putpkt ("!");
	getpkt (buf, 0);
      }
    }
}

/* This will be called by fetch_inferior_event, via the
   cmd_continuation pointer, only after the target has stopped. */
static void 
set_extended_protocol (arg)
     struct continuation_arg * arg;
{
  /* tell the remote that we're using the extended protocol.  */
  char *buf = alloca (PBUFSIZ);
  putpkt ("!");
  getpkt (buf, 0);
}

a1731 24
/* Same as remote_detach, but with async support. */
static void
remote_async_detach (args, from_tty)
     char *args;
     int from_tty;
{
  char *buf = alloca (PBUFSIZ);

  if (args)
    error ("Argument given to \"detach\" when remotely debugging.");

  /* Tell the remote target to detach.  */
  strcpy (buf, "D");
  remote_send (buf);

  /* Unregister the file descriptor from the event loop. */
  if (async_p)
    delete_file_handler (remote_desc->fd);

  pop_target ();
  if (from_tty)
    puts_filtered ("Ending remote debugging.\n");
}

a1799 56

/* Same as remote_resume, but with async support. */
static void
remote_async_resume (pid, step, siggnal)
     int pid, step;
     enum target_signal siggnal;
{
  char *buf = alloca (PBUFSIZ);

  if (pid == -1)
    set_thread (0, 0);		/* run any thread */
  else
    set_thread (pid, 0);	/* run this thread */

  dcache_flush (remote_dcache);

  last_sent_signal = siggnal;
  last_sent_step = step;

  /* A hook for when we need to do something at the last moment before
     resumption.  */
  if (target_resume_hook)
    (*target_resume_hook) ();

  /* Set things up before execution starts for async commands. */
  /* This function can be entered more than once for the same execution
     command, because it is also called by handle_inferior_event. So
     we make sure that we don't do the initialization for sync
     execution more than once. */
  if (async_p && !target_executing)
    {
      target_executing = 1;

      /* If the command must look synchronous, fake it, by making gdb
         display an empty prompt after the command has completed. Also
         disable input. */
      if (sync_execution)
	{
	  push_prompt ("", "", "");
	  delete_file_handler (input_fd);
	  initialize_sigint_signal_handler ();
	}
    }

  if (siggnal != TARGET_SIGNAL_0)
    {
      buf[0] = step ? 'S' : 'C';
      buf[1] = tohex (((int)siggnal >> 4) & 0xf);
      buf[2] = tohex ((int)siggnal & 0xf);
      buf[3] = '\0';
    }
  else
    strcpy (buf, step ? "s": "c");

  putpkt (buf);
}
a1800 69

/* Set up the signal handler for SIGINT, while the target is
   executing, ovewriting the 'regular' SIGINT signal handler. */
static void
initialize_sigint_signal_handler ()
{
  sigint_remote_token = 
    create_async_signal_handler (async_remote_interrupt, NULL);
  signal (SIGINT, handle_remote_sigint);
}

/* Signal handler for SIGINT, while the target is executing. */
static void
handle_remote_sigint (sig)
     int sig;
{
  signal (sig, handle_remote_sigint_twice);
  sigint_remote_twice_token = 
    create_async_signal_handler (async_remote_interrupt_twice, NULL);
  mark_async_signal_handler_wrapper (sigint_remote_token);
}

/* Signal handler for SIGINT, installed after SIGINT has already been
   sent once.  It will take effect the second time that the user sends
   a ^C. */
static void
handle_remote_sigint_twice (sig)
     int sig;
{
  signal (sig, handle_sigint);
  sigint_remote_twice_token = 
    create_async_signal_handler (async_remote_interrupt, NULL);
  mark_async_signal_handler_wrapper (sigint_remote_twice_token);
}

/* Perform the real interruption of hte target execution, in response
   to a ^C. */
static void 
async_remote_interrupt (arg)
     gdb_client_data arg;
{
  if (remote_debug)
    fprintf_unfiltered (gdb_stdlog, "remote_interrupt called\n");

  target_stop ();
}

/* Perform interrupt, if the first attempt did not succeed. Just give
   up on the target alltogether. */
static void 
async_remote_interrupt_twice (arg)
     gdb_client_data arg;
{
  interrupt_query ();
  signal (SIGINT, handle_remote_sigint);
}

/* Reinstall the usual SIGINT handlers, after the target has
   stopped. */
void
cleanup_sigint_signal_handler ()
{
  signal (SIGINT, handle_sigint);
  if (sigint_remote_twice_token)
    delete_async_signal_handler ((async_signal_handler**) &sigint_remote_twice_token);
  if (sigint_remote_token)
    delete_async_signal_handler ((async_signal_handler**) &sigint_remote_token);
}

d1803 1
d1878 1
a1878 1
  for (p = msg; p[0] && p[1]; p +=2) 
d1884 4
a1887 1
      fputs_unfiltered (tb, gdb_stdtarg);
a2111 219
/* Async version of remote_wait. */
static int
remote_async_wait (pid, status)
     int pid;
     struct target_waitstatus *status;
{
  unsigned char *buf = alloca (PBUFSIZ);
  int thread_num = -1;

  status->kind = TARGET_WAITKIND_EXITED;
  status->value.integer = 0;

  while (1)
    {
      unsigned char *p;
      
      if (!async_p)
	ofunc = signal (SIGINT, remote_interrupt);
      getpkt ((char *) buf, 1);
      if (!async_p)
	signal (SIGINT, ofunc);

      /* This is a hook for when we need to do something (perhaps the
	 collection of trace data) every time the target stops.  */
      if (target_wait_loop_hook)
	(*target_wait_loop_hook) ();

      switch (buf[0])
	{
	case 'E':		/* Error of some sort */
	  warning ("Remote failure reply: %s", buf);
	  continue;
	case 'T':		/* Status with PC, SP, FP, ... */
	  {
	    int i;
	    long regno;
	    char regs[MAX_REGISTER_RAW_SIZE];

	    /* Expedited reply, containing Signal, {regno, reg} repeat */
	    /*  format is:  'Tssn...:r...;n...:r...;n...:r...;#cc', where
		ss = signal number
		n... = register number
		r... = register contents
		*/
	    p = &buf[3];	/* after Txx */

	    while (*p)
	      {
		unsigned char *p1;
		char *p_temp;

		/* Read the register number */
		regno = strtol ((const char *) p, &p_temp, 16);
		p1 = (unsigned char *)p_temp;

		if (p1 == p) /* No register number present here */
		  {
		    p1 = (unsigned char *) strchr ((const char *) p, ':');
		    if (p1 == NULL)
		      warning ("Malformed packet(a) (missing colon): %s\n\
Packet: '%s'\n",
			       p, buf);
		    if (strncmp ((const char *) p, "thread", p1 - p) == 0)
		      {
			p_temp = unpack_varlen_hex (++p1, &thread_num);
			record_currthread (thread_num);
			p = (unsigned char *) p_temp;
		      }
		  }
		else
		  {
		    p = p1;

		    if (*p++ != ':')
		      warning ("Malformed packet(b) (missing colon): %s\n\
Packet: '%s'\n",
			       p, buf);

		    if (regno >= NUM_REGS)
		      warning ("Remote sent bad register number %ld: %s\n\
Packet: '%s'\n",
			       regno, p, buf);

		    for (i = 0; i < REGISTER_RAW_SIZE (regno); i++)
		      {
			if (p[0] == 0 || p[1] == 0)
			  warning ("Remote reply is too short: %s", buf);
			regs[i] = fromhex (p[0]) * 16 + fromhex (p[1]);
			p += 2;
		      }
		    supply_register (regno, regs);
		  }

		if (*p++ != ';')
		  {
		    warning ("Remote register badly formatted: %s", buf);
		    warning ("            here: %s",p);
		  }
	      }
	  }
	  /* fall through */
	case 'S':		/* Old style status, just signal only */
	  status->kind = TARGET_WAITKIND_STOPPED;
	  status->value.sig = (enum target_signal)
	    (((fromhex (buf[1])) << 4) + (fromhex (buf[2])));

	  if (buf[3] == 'p')
	    {
	      /* Export Cisco kernel mode as a convenience variable
		 (so that it can be used in the GDB prompt if desired). */

	      if (cisco_kernel_mode == 1)
		set_internalvar (lookup_internalvar ("cisco_kernel_mode"), 
				 value_from_string ("PDEBUG-"));
	      cisco_kernel_mode = 0;
	      thread_num = strtol ((const char *) &buf[4], NULL, 16);
	      record_currthread (thread_num);
	    }
	  else if (buf[3] == 'k')
	    {
	      /* Export Cisco kernel mode as a convenience variable
		 (so that it can be used in the GDB prompt if desired). */

	      if (cisco_kernel_mode == 1)
		set_internalvar (lookup_internalvar ("cisco_kernel_mode"), 
				 value_from_string ("KDEBUG-"));
	      cisco_kernel_mode = 1;
	    }
	  goto got_status;
	case 'N':		/* Cisco special: status and offsets */
	  {
	    bfd_vma text_addr, data_addr, bss_addr;
	    bfd_signed_vma text_off, data_off, bss_off;
	    unsigned char *p1;

	    status->kind = TARGET_WAITKIND_STOPPED;
	    status->value.sig = (enum target_signal)
	      (((fromhex (buf[1])) << 4) + (fromhex (buf[2])));

	    if (symfile_objfile == NULL) 
	      {
		warning ("Relocation packet recieved with no symbol file.  \
Packet Dropped");
		goto got_status;
	      }

	    /* Relocate object file.  Buffer format is NAATT;DD;BB
	     * where AA is the signal number, TT is the new text
	     * address, DD * is the new data address, and BB is the
	     * new bss address.  */

	    p = &buf[3];
	    text_addr = strtoul (p, (char **) &p1, 16);
	    if (p1 == p || *p1 != ';')
	      warning ("Malformed relocation packet: Packet '%s'", buf);
	    p = p1 + 1;
	    data_addr = strtoul (p, (char **) &p1, 16);
	    if (p1 == p || *p1 != ';')
	      warning ("Malformed relocation packet: Packet '%s'", buf);
	    p = p1 + 1;
	    bss_addr = strtoul (p, (char **) &p1, 16);
	    if (p1 == p) 
	      warning ("Malformed relocation packet: Packet '%s'", buf);

	    if (remote_cisco_section_offsets (text_addr, data_addr, bss_addr,
					      &text_off, &data_off, &bss_off)
		== 0)
	      if (text_off != 0 || data_off != 0 || bss_off  != 0) 
		remote_cisco_objfile_relocate (text_off, data_off, bss_off);

	    goto got_status;
	  }
	case 'W':		/* Target exited */
	  {
	    /* The remote process exited.  */
	    status->kind = TARGET_WAITKIND_EXITED;
	    status->value.integer = (fromhex (buf[1]) << 4) + fromhex (buf[2]);
	    goto got_status;
	  }
	case 'X':
	  status->kind = TARGET_WAITKIND_SIGNALLED;
	  status->value.sig = (enum target_signal)
	    (((fromhex (buf[1])) << 4) + (fromhex (buf[2])));
	  kill_kludge = 1;

	  goto got_status;
	case 'O':		/* Console output */
	  remote_console_output (buf + 1);
	  continue;
	case '\0':
	  if (last_sent_signal != TARGET_SIGNAL_0)
	    {
	      /* Zero length reply means that we tried 'S' or 'C' and
		 the remote system doesn't support it.  */
	      target_terminal_ours_for_output ();
	      printf_filtered
		("Can't send signals to this remote system.  %s not sent.\n",
		 target_signal_to_name (last_sent_signal));
	      last_sent_signal = TARGET_SIGNAL_0;
	      target_terminal_inferior ();

	      strcpy ((char *) buf, last_sent_step ? "s" : "c");
	      putpkt ((char *) buf);
	      continue;
	    }
	  /* else fallthrough */
	default:
	  warning ("Invalid remote reply: %s", buf);
	  continue;
	}
    }
 got_status:
  if (thread_num != -1)
    {
      return thread_num;
    }
  return inferior_pid;
}

d2795 1
a2795 1
  if (cnt > BUFSIZ - 5)		/* Prosanity check */
a3118 26
/* Async version of remote_kill. */
static void
remote_async_kill ()
{
  /* Unregister the file descriptor from the event loop. */
  if (async_p)
    delete_file_handler (remote_desc->fd);

  /* For some mysterious reason, wait_for_inferior calls kill instead of
     mourn after it gets TARGET_WAITKIND_SIGNALLED.  Work around it.  */
  if (kill_kludge)
    {
      kill_kludge = 0;
      target_mourn_inferior ();
      return;
    }

  /* Use catch_errors so the user can quit from gdb even when we aren't on
     speaking terms with the remote system.  */
  catch_errors ((catch_errors_ftype*) putpkt, "k", "", RETURN_MASK_ERROR);

  /* Don't wait for it to die.  I'm not really sure it matters whether
     we do or not.  For the existing stubs, kill is a noop.  */
  target_mourn_inferior ();
}

a3177 30
/* Async version of extended_remote_create_inferior. */
static void
extended_remote_async_create_inferior (exec_file, args, env)
     char *exec_file;
     char *args;
     char **env;
{
  /* Rip out the breakpoints; we'll reinsert them after restarting
     the remote server.  */
  remove_breakpoints ();

  /* If running asynchronously, register the target file descriptor
     with the event loop. */
  if (async_p)
    add_file_handler (remote_desc->fd, (file_handler_func *) fetch_inferior_event, 0);

  /* Now restart the remote server.  */
  extended_remote_restart ();

  /* Now put the breakpoints back in.  This way we're safe if the
     restart function works via a unix fork on the remote side.  */
  insert_breakpoints ();

  /* Clean up from the last time we were running.  */
  clear_proceed_status ();

  /* Let the remote process run.  */
  proceed (-1, TARGET_SIGNAL_0, 0);
}

a4105 63
/* Target async and target extended-async.

   This are temporary targets, until it is all tested.  Eventually
   async support will be incorporated int the usual 'remote'
   target. */

static void
init_remote_async_ops ()
{
  remote_async_ops.to_shortname = "async";
  remote_async_ops.to_longname  = "Remote serial target in async version of the gdb-specific protocol";
  remote_async_ops.to_doc       = 
    "Use a remote computer via a serial line, using a gdb-specific protocol.\n\
Specify the serial device it is connected to (e.g. /dev/ttya).";
  remote_async_ops.to_open              = remote_async_open;
  remote_async_ops.to_close             = remote_close;
  remote_async_ops.to_detach            = remote_async_detach;
  remote_async_ops.to_resume            = remote_async_resume;
  remote_async_ops.to_wait              = remote_async_wait;
  remote_async_ops.to_fetch_registers   = remote_fetch_registers;
  remote_async_ops.to_store_registers   = remote_store_registers;
  remote_async_ops.to_prepare_to_store  = remote_prepare_to_store;
  remote_async_ops.to_xfer_memory       = remote_xfer_memory;
  remote_async_ops.to_files_info        = remote_files_info;
  remote_async_ops.to_insert_breakpoint = remote_insert_breakpoint;
  remote_async_ops.to_remove_breakpoint = remote_remove_breakpoint;
  remote_async_ops.to_kill              = remote_async_kill;
  remote_async_ops.to_load              = generic_load;
  remote_async_ops.to_mourn_inferior    = remote_mourn;
  remote_async_ops.to_thread_alive      = remote_thread_alive;
  remote_async_ops.to_find_new_threads  = remote_threads_info;
  remote_async_ops.to_stop = remote_stop;
  remote_async_ops.to_query = remote_query;
  remote_async_ops.to_stratum           = process_stratum;
  remote_async_ops.to_has_all_memory    = 1;
  remote_async_ops.to_has_memory        = 1;
  remote_async_ops.to_has_stack         = 1;
  remote_async_ops.to_has_registers     = 1;
  remote_async_ops.to_has_execution     = 1;
  remote_async_ops.to_has_thread_control = tc_schedlock; /* can lock scheduler */
  remote_async_ops.to_has_async_exec    = 1;
  remote_async_ops.to_magic             = OPS_MAGIC;
}

/* Set up the async extended remote vector by making a copy of the standard
   remote vector and adding to it.  */

static void
init_extended_async_remote_ops ()
{
  extended_async_remote_ops = remote_async_ops;

  extended_async_remote_ops.to_shortname = "extended-async";
  extended_async_remote_ops.to_longname = 
    "Extended remote serial target in async gdb-specific protocol";
  extended_async_remote_ops.to_doc = 
    "Use a remote computer via a serial line, using an async gdb-specific protocol.\n\
Specify the serial device it is connected to (e.g. /dev/ttya).",
  extended_async_remote_ops.to_open = extended_remote_async_open;
  extended_async_remote_ops.to_create_inferior = extended_remote_async_create_inferior;
  extended_async_remote_ops.to_mourn_inferior = extended_remote_mourn;
}

d4112 1
a4129 6

  init_remote_async_ops ();
  add_target (&remote_async_ops);

  init_extended_async_remote_ops ();
  add_target (&extended_async_remote_ops);
@


1.1.1.9
log
@import gdb-1999-07-07 pre reformat
@
text
@a20 1
/* *INDENT-OFF* */
a197 1
/* *INDENT-ON* */
a217 1
#include <sys/time.h>
d220 4
@


1.1.1.10
log
@import gdb-1999-07-07 post reformat
@
text
@d5 15
a19 1
   This file is part of GDB.
a20 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
a200 3



d211 1
a211 1
/*#include "terminal.h" */
d247 1
a247 1
static void remote_files_info PARAMS ((struct target_ops * ignore));
d249 1
a249 1
static int remote_xfer_memory PARAMS ((CORE_ADDR memaddr, char *myaddr,
d260 1
a260 1
					 enum target_signal siggnal));
d273 1
a273 1
					 int extended_p));
d339 1
a339 1
static int remote_query PARAMS ((int /*char */ , char *, char *, int *));
d425 1
a425 1

d484 1
a486 1

d540 1
a540 1
    general_thread = th;
d578 1
a578 1
 */
d580 1
a580 1
typedef int gdb_threadref;	/* internal GDB thread reference */
d586 7
a592 7
  {
    threadref threadid;		/* External form of thread reference */
    int active;			/* Has state interesting to GDB? , regs, stack */
    char display[256];		/* Brief state display, name, blocked/syspended */
    char shortname[32];		/* To be used to name threads */
    char more_display[256];	/* Long info, statistics, queue depth, whatever */
  };
d598 1
a598 1
 */
d604 1
a604 1
#define TAG_MOREDISPLAY 16
d614 1
a614 1
static char *pack_hex_byte PARAMS ((char *pkt, int /*unsigned char */ byte));
d624 1
a624 1
static char *pack_threadid PARAMS ((char *pkt, threadref * id));
d626 1
a626 1
static char *unpack_threadid PARAMS ((char *inbuf, threadref * id));
d628 1
a628 1
void int_to_threadref PARAMS ((threadref * id, int value));
d630 1
a630 1
static int threadref_to_int PARAMS ((threadref * ref));
d632 1
a632 1
static void copy_threadref PARAMS ((threadref * dest, threadref * src));
d634 1
a634 1
static int threadmatch PARAMS ((threadref * dest, threadref * src));
d637 1
a637 1
					      threadref * id));
d640 2
a641 2
						    threadref * expectedref,
					struct gdb_ext_thread_info * info));
d644 3
a646 3
static int remote_get_threadinfo PARAMS ((threadref * threadid,
					  int fieldset,		/*TAG mask */
					struct gdb_ext_thread_info * info));
d648 1
a648 1
static int adapt_remote_get_threadinfo PARAMS ((gdb_threadref * ref,
d650 1
a650 1
					struct gdb_ext_thread_info * info));
d654 1
a654 1
					      threadref * nextthread));
d658 2
a659 2
					      threadref * original_echo,
					      threadref * resultlist,
d663 1
a663 1
					  threadref * nextthread,
d667 1
a667 1
					  threadref * threadlist));
d669 1
a669 1
typedef int (*rmt_thread_action) (threadref * ref, void *context);
d672 1
a672 1
					     void *context, int looplimit));
d674 1
a674 1
static int remote_newthread_step PARAMS ((threadref * ref, void *context));
d811 1
a811 1
#if 0				/* currently unused, uncomment when needed */
d960 6
a965 6
   threadid:1,        # always request threadid
   context_exists:2,
   display:4,
   unique_name:8,
   more_display:16
 */
d987 7
a993 7
#define TAG_THREADID 1		/* Echo the thread identifier */
#define TAG_EXISTS 2		/* Is this process defined enough to
				   fetch registers and its stack */
#define TAG_DISPLAY 4		/* A short thing maybe to put on a window */
#define TAG_THREADNAME 8	/* string, maps 1-to-1 with a thread is */
#define TAG_MOREDISPLAY 16	/* Whatever the kernel wants to say about 
				   the process */
d1004 1
a1004 1
  char *limit = pkt + PBUFSIZ;	/* plausable parsing limit */
d1028 1
a1028 1
  while ((pkt < limit) && mask && *pkt)		/* packets are terminated with nulls */
d1153 1
a1153 1
  limit = pkt + (PBUFSIZ - BUF_THREAD_ID_SIZE);		/* done parse past here */
d1317 2
a1318 2
  remote_threadlist_iterator (remote_newthread_step, 0,
			      CRAZY_MAX_THREADS);
d1341 1
a1341 1
    while (*bufp++ == 'm')	/* reply contains one or more TID */
d1343 5
a1347 7
	do
	  {
	    tid = strtol (bufp, &bufp, 16);
	    if (tid != 0 && !in_thread_list (tid))
	      add_thread (tid);
	  }
	while (*bufp++ == ',');	/* comma-separated list */
d1352 1
a1353 1

d1452 2
a1453 2
		 + symfile_objfile->num_sections
		 * sizeof (offs->offsets));
d1486 2
a1487 2
static int
remote_cisco_section_offsets (text_addr, data_addr, bss_addr,
d1492 3
a1494 3
     bfd_signed_vma *text_offs;
     bfd_signed_vma *data_offs;
     bfd_signed_vma *bss_offs;
d1499 1
a1499 1
  bfd *abfd;
d1504 1
a1504 1
    return -1;			/* no can do nothin' */
d1508 1
a1508 1
    return -1;			/* Can't find "_start" symbol */
d1514 1
a1514 1
  for (sect = abfd->sections;
d1518 1
a1518 1
      p = (unsigned char *) bfd_get_section_name (abfd, sect);
d1525 1
a1525 1
	if (bss_base == 0 ||
d1531 1
a1531 1
  *bss_offs = bss_addr - bss_base;
d1538 1
a1538 1
      sprintf (tmp + strlen (tmp), " data = 0x");
d1540 1
a1540 1
      sprintf (tmp + strlen (tmp), " bss = 0x");
d1545 1
a1545 1
		    (long) *text_offs, (long) *data_offs, (long) *bss_offs);
d1565 1
a1565 1
  if (text_off != 0 || data_off != 0 || bss_off != 0)
d1568 2
a1569 2
         broken for xcoff, dwarf, sdb-coff, etc.  But there is no
         simple canonical representation for this stuff.  */
d1583 1
a1583 1
      ANOFFSET (offs, SECT_OFF_BSS) = bss_off;
d1589 2
a1590 2
         the exec target.  These entries will control memory transfers
         from the exec file.  */
d1656 1
a1656 1
  remote_open_1 (name, from_tty, &extended_remote_ops, 1 /*extended_p */ );
d1665 1
a1665 1
  remote_async_open_1 (name, from_tty, &extended_async_remote_ops, 1 /*extended_p */ );
d1714 1
a1714 1
  push_target (target);		/* Switch to using remote target now */
d1722 1
a1722 1
  general_thread = -2;
d1740 2
a1741 2
  if (!catch_errors (remote_start_remote, NULL,
		     "Couldn't establish connection to remote target\n",
d1808 1
a1808 1
  push_target (target);		/* Switch to using remote target now */
d1816 1
a1816 1
  general_thread = -2;
d1840 2
a1841 2
  if (!catch_errors (remote_start_remote, NULL,
		     "Couldn't establish connection to remote target\n",
d1853 7
a1859 7
      if (extended_p)
	{
	  /* tell the remote that we're using the extended protocol.  */
	  char *buf = alloca (PBUFSIZ);
	  putpkt ("!");
	  getpkt (buf, 0);
	}
d1865 1
a1865 1
static void
d1867 1
a1867 1
     struct continuation_arg *arg;
d1935 1
a1935 1
  else
d1946 1
a1946 1
    return '0' + nib;
d1948 1
a1948 1
    return 'a' + nib - 10;
d1982 2
a1983 2
      buf[1] = tohex (((int) siggnal >> 4) & 0xf);
      buf[2] = tohex ((int) siggnal & 0xf);
d1987 1
a1987 1
    strcpy (buf, step ? "s" : "c");
d2038 2
a2039 2
      buf[1] = tohex (((int) siggnal >> 4) & 0xf);
      buf[2] = tohex ((int) siggnal & 0xf);
d2043 1
a2043 1
    strcpy (buf, step ? "s" : "c");
d2054 1
a2054 1
  sigint_remote_token =
d2065 1
a2065 1
  sigint_remote_twice_token =
d2078 1
a2078 1
  sigint_remote_twice_token =
d2085 1
a2085 1
static void
d2097 1
a2097 1
static void
d2112 1
a2112 1
    delete_async_signal_handler ((async_signal_handler **) & sigint_remote_twice_token);
d2114 1
a2114 1
    delete_async_signal_handler ((async_signal_handler **) & sigint_remote_token);
d2193 1
a2193 1
  for (p = msg; p[0] && p[1]; p += 2)
d2228 1
a2228 1
         collection of trace data) every time the target stops.  */
d2245 4
a2248 4
	       ss = signal number
	       n... = register number
	       r... = register contents
	     */
d2258 1
a2258 1
		p1 = (unsigned char *) p_temp;
d2260 1
a2260 1
		if (p1 == p)	/* No register number present here */
d2301 1
a2301 1
		    warning ("            here: %s", p);
d2314 1
a2314 1
	         (so that it can be used in the GDB prompt if desired). */
d2317 1
a2317 1
		set_internalvar (lookup_internalvar ("cisco_kernel_mode"),
d2326 1
a2326 1
	         (so that it can be used in the GDB prompt if desired). */
d2329 1
a2329 1
		set_internalvar (lookup_internalvar ("cisco_kernel_mode"),
d2344 1
a2344 1
	    if (symfile_objfile == NULL)
d2366 1
a2366 1
	    if (p1 == p)
d2372 1
a2372 1
	      if (text_off != 0 || data_off != 0 || bss_off != 0)
d2398 1
a2398 1
	         the remote system doesn't support it.  */
d2416 1
a2416 1
got_status:
d2439 1
a2439 1

d2447 1
a2447 1
         collection of trace data) every time the target stops.  */
d2464 4
a2467 4
	       ss = signal number
	       n... = register number
	       r... = register contents
	     */
d2477 1
a2477 1
		p1 = (unsigned char *) p_temp;
d2479 1
a2479 1
		if (p1 == p)	/* No register number present here */
d2520 1
a2520 1
		    warning ("            here: %s", p);
d2533 1
a2533 1
	         (so that it can be used in the GDB prompt if desired). */
d2536 1
a2536 1
		set_internalvar (lookup_internalvar ("cisco_kernel_mode"),
d2545 1
a2545 1
	         (so that it can be used in the GDB prompt if desired). */
d2548 1
a2548 1
		set_internalvar (lookup_internalvar ("cisco_kernel_mode"),
d2563 1
a2563 1
	    if (symfile_objfile == NULL)
d2585 1
a2585 1
	    if (p1 == p)
d2591 1
a2591 1
	      if (text_off != 0 || data_off != 0 || bss_off != 0)
d2617 1
a2617 1
	         the remote system doesn't support it.  */
d2635 1
a2635 1
got_status:
d2701 1
a2701 1
	regs[i] = 0;		/* 'x' */
d2715 2
a2716 2

supply_them:
d2718 5
a2722 5
    {
      supply_register (i, &regs[REGISTER_BYTE (i)]);
      if (buf[REGISTER_BYTE (i) * 2] == 'x')
	register_valid[i] = -1;	/* register value not available */
    }
d2729 1
a2729 1
static void
d2733 1
a2733 1
  read_register_bytes (0, (char *) NULL, REGISTER_BYTES);
d2771 2
a2772 2
         and don't try using 'P' in the future (it will just waste our
         time).  */
d2807 1
a2807 1
#if 0				/* unused? */
d2825 2
a2826 1
#endif /* 0 (unused?) */
a2828 1

d2857 1
a2857 1
      buf[i] = "0123456789abcdef"[(num & 0xf)];
d2975 1
a2975 1
	  todo = min (len, max_buf_size / 2);	/* num bytes that will fit */
d2987 2
a2988 2
         addresses, each byte encoded as two hex characters (or one
         binary character).  */
d2992 1
a2992 1
	  for (i = 0;
d2995 22
a3016 22
	    {
	      switch (myaddr[i] & 0xff)
		{
		case '$':
		case '#':
		case 0x7d:
		  /* These must be escaped */
		  escaped++;
		  *p++ = 0x7d;
		  *p++ = (myaddr[i] & 0xff) ^ 0x20;
		  break;
		default:
		  *p++ = myaddr[i] & 0xff;
		  break;
		}
	    }

	  if (i < todo)
	    {
	      /* Escape chars have filled up the buffer prematurely, 
	         and we have actually sent fewer bytes than planned.
	         Fix-up the length field of the packet.  */
d3019 1
a3019 1
	         old len.  */
d3021 3
a3023 3
	      plen += hexnumstr (plen, (ULONGEST) i);
	      *plen++ = ':';
	    }
d3049 2
a3050 2
         caused us to send fewer bytes than we'd planned.  */
      myaddr += i;
d3052 1
a3052 1
      len -= i;
d3088 1
a3088 1
      todo = min (len, max_buf_size / 2);	/* num bytes that will fit */
d3113 2
a3114 2
      /* Reply describes memory byte by byte,
         each byte encoded as two hex characters.  */
d3150 1
a3150 1
     struct target_ops *target;	/* ignored */
d3162 1
a3162 1

d3361 1
a3361 1
	  if (remote_debug)
d3383 1
a3383 1
	      tcount++;
d3389 2
a3390 2
		/* It's probably an old response, and we're out of sync.
		   Just gobble up the packet and ignore it.  */
d3392 1
a3392 1
		continue;	/* Now, go look for + */
d3411 4
a3414 4
         able to get out next time we call QUIT, without anything as
         violent as interrupt_query.  If we want to provide a way out of
         here without getting to the next QUIT, it should be based on
         hitting ^C twice as in remote_wait.  */
d3426 1
a3426 2
static void
remote_cisco_expand (src, dest)
d3433 15
a3447 17
  do
    {
      if (*src == '*')
	{
	  repeat = (fromhex (src[1]) << 4) + fromhex (src[2]);
	  for (i = 0; i < repeat; i++)
	    {
	      *dest++ = *(src - 1);
	    }
	  src += 2;
	}
      else
	{
	  *dest++ = *src;
	}
    }
  while (*src++);
d3501 1
a3501 1
	    if (remote_debug)
d3504 1
a3504 1
			      "Bad checksum, sentsum=0x%x, csum=0x%x, buf=",
d3566 1
a3566 1
  strcpy (buf, "timeout");
d3581 2
a3582 2
         continuously, but if it pauses, we'll get a zero from readchar
         because of timeout.  Then we'll count that as a retry.  */
d3585 2
a3586 2
         After that, we expect characters to arrive at a brisk pace.  They
         should show up within remote_timeout intervals.  */
d3643 1
a3643 1
  catch_errors ((catch_errors_ftype *) putpkt, "k", "", RETURN_MASK_ERROR);
d3669 1
a3669 1
  catch_errors ((catch_errors_ftype *) putpkt, "k", "", RETURN_MASK_ERROR);
d3764 1
a3765 1

d3876 1
a3876 2
static unsigned long crc32_table[256] =
{0, 0};
d3884 1
a3884 1
  if (!crc32_table[1])
d3891 5
a3895 5
	{
	  for (c = i << 24, j = 8; j > 0; --j)
	    c = c & 0x80000000 ? (c << 1) ^ 0x04c11db7 : (c << 1);
	  crc32_table[i] = c;
	}
d3937 1
a3937 1
  for (s = exec_bfd->sections; s; s = s->next)
d3940 1
a3940 1
	continue;		/* skip non-loadable section */
d3944 1
a3944 1
	continue;		/* skip zero-length section */
d3948 1
a3948 1
	continue;		/* not the section selected by user */
d3950 1
a3950 1
      matched = 1;		/* do this section */
d3977 4
a3980 4
	{
	  printf_filtered ("MIS-MATCHED!\n");
	  mismatched++;
	}
d4003 1
a4003 1
  if (!bufsiz)
d4009 1
a4009 1
  if (*bufsiz < PBUFSIZ)
d4016 1
a4016 1
  if (!remote_desc)
d4020 1
a4020 1
  if ((query_type < 'A') || (query_type > 'Z'))
d4023 1
a4023 1
  if (!buf)
d4026 1
a4026 1
  if (!outbuf)
d4039 1
a4039 1
  while (buf[i] && (i < (PBUFSIZ - 8)))
d4042 2
a4043 2
      if ((!isprint (buf[i])) || (buf[i] == '$') || (buf[i] == '#'))
	error ("illegal characters in query string");
d4050 1
a4050 1
  if (buf[i])
d4054 1
a4054 2
  if (i < 0)
    return i;
d4068 1
a4068 1
  if (!remote_desc)
d4071 1
a4071 1
  if (!args)
d4088 1
a4088 1
static void display_thread_info PARAMS ((struct gdb_ext_thread_info * info));
d4096 1
a4096 1
int get_and_display_threadinfo PARAMS ((threadref * ref));
d4100 1
a4100 1
static int thread_display_step PARAMS ((threadref * ref, void *context));
d4106 1
a4106 1
#define SAMPLE_THREAD  0x05060708	/* Truncated 64 bit threadid */
d4249 1
a4249 1
  remote_ops.to_shortname = "remote";
d4251 1
a4251 1
  remote_ops.to_doc =
d4253 3
a4255 3
Specify the serial device it is connected to (e.g. /dev/ttya).";
  remote_ops.to_open = remote_open;
  remote_ops.to_close = remote_close;
d4257 1
a4257 1
  remote_ops.to_resume = remote_resume;
d4262 2
a4263 2
  remote_ops.to_xfer_memory = remote_xfer_memory;
  remote_ops.to_files_info = remote_files_info;
d4266 2
a4267 2
  remote_ops.to_kill = remote_kill;
  remote_ops.to_load = generic_load;
d4274 7
a4280 7
  remote_ops.to_has_all_memory = 1;
  remote_ops.to_has_memory = 1;
  remote_ops.to_has_stack = 1;
  remote_ops.to_has_registers = 1;
  remote_ops.to_has_execution = 1;
  remote_ops.to_has_thread_control = tc_schedlock;	/* can lock scheduler */
  remote_ops.to_magic = OPS_MAGIC;
d4292 1
a4292 1
  extended_remote_ops.to_longname =
d4294 1
a4294 1
  extended_remote_ops.to_doc =
d4297 1
a4297 1
    extended_remote_ops.to_open = extended_remote_open;
d4330 1
a4330 1
    return;			/* Silently: target does not support this feature. */
d4335 1
a4335 1
  while (buf[0] == 'O')		/* Capitol-O packet */
d4354 1
a4354 1
	    "To open a remote debug connection, you need to specify what \n\
d4374 1
a4374 1
  if (SERIAL_SETBAUDRATE (remote_desc, baud_rate))
d4402 1
a4402 1
  general_thread = -2;
d4419 2
a4420 2
  if (!catch_errors (remote_start_remote_dummy, (char *) 0,
		     "Couldn't establish connection to remote target\n",
d4436 2
a4437 3
static void
  remote_cisco_mourn
PARAMS ((void))
d4442 4
a4445 5
enum
{
  READ_MORE,
  FATAL_ERROR,
  ENTER_DEBUG,
d4447 1
a4447 2
}
minitelnet_return;
d4463 1
a4463 1
  while ((data = readchar (0)) >= 0)
d4466 1
a4466 1
      if (data == '|')
d4469 1
a4469 1
	  if (++escape_count == 4)
d4473 4
a4476 4
	  else
	    {			/* This is a '|', but not the fourth in a row. 
				   Continue without echoing it.  If it isn't actually 
				   one of four in a row, it'll be echoed later.  */
d4480 2
a4481 3
      else
	/* Not a '|' */
	{
d4484 2
a4485 2
	  for (; escape_count > 0; escape_count--)
	    putchar ('|');
d4487 3
d4491 1
a4491 4
      if (data == '\r')		/* If this is a return character, */
	continue;		/*  - just supress it. */

      if (echo_check != -1)	/* Check for echo of user input.  */
d4495 2
a4496 2
	      echo_check++;	/* Character matched user input: */
	      continue;		/* Continue without echoing it.  */
d4498 4
a4501 4
	  else if ((data == '\n') && (tty_input[echo_check] == '\r'))
	    {			/* End of the line (and of echo checking).  */
	      echo_check = -1;	/* No more echo supression */
	      continue;		/* Continue without echoing.  */
d4504 2
a4505 2
	    {			/* Failed check for echo of user input.
				   We now have some suppressed output to flush!  */
d4508 1
a4508 1
	      for (j = 0; j < echo_check; j++)
d4513 1
a4513 1
      putchar (data);		/* Default case: output the char.  */
d4516 4
a4519 4
  if (data == SERIAL_TIMEOUT)	/* Timeout returned from readchar.  */
    return READ_MORE;		/* Try to read some more */
  else
    return FATAL_ERROR;		/* Trouble, bail out */
d4530 1
a4530 1
  if (tty_bytecount == -1)
d4540 2
a4541 2
      tty_input[--tty_bytecount] = 0;	/* remove newline */
      tty_input[--tty_bytecount] = 0;	/* remove backslash */
d4546 1
a4546 1
    tty_input[tty_bytecount - 1] = '\r';
d4554 1
a4554 1
  if (SERIAL_WRITE (remote_desc, tty_input, tty_bytecount))
d4567 3
a4569 3
  int tablesize;		/* max number of FDs for select */
  int status;
  int quit_count = 0;
d4575 1
a4575 1
  echo_check = -1;
d4579 1
a4579 1
  for (;;)
d4582 2
a4583 2
         this must be done *before* the select as there may be
         buffered I/O waiting to be processed.  */
d4585 1
a4585 1
      if ((status = readsocket ()) == FATAL_ERROR)
d4589 1
a4589 1
      else if (status != READ_MORE)
d4594 1
a4594 1
      fflush (stdout);		/* Flush output before blocking */
d4597 1
a4597 1

d4599 1
a4599 1
      FD_SET (fileno (stdin), &input);
d4603 1
a4603 1
      if ((status == -1) && (errno != EINTR))
d4610 1
a4610 1
      if (quit_flag)
d4633 1
a4633 1
      if (FD_ISSET (fileno (stdin), &input))
d4651 1
a4651 1
  if (minitelnet () != ENTER_DEBUG)
d4663 2
a4664 2
  remote_cisco_ops.to_longname = "Remote serial target in cisco-specific protocol";
  remote_cisco_ops.to_doc =
d4667 10
a4676 10
  remote_cisco_ops.to_open = remote_cisco_open;
  remote_cisco_ops.to_close = remote_cisco_close;
  remote_cisco_ops.to_detach = remote_detach;
  remote_cisco_ops.to_resume = remote_resume;
  remote_cisco_ops.to_wait = remote_cisco_wait;
  remote_cisco_ops.to_fetch_registers = remote_fetch_registers;
  remote_cisco_ops.to_store_registers = remote_store_registers;
  remote_cisco_ops.to_prepare_to_store = remote_prepare_to_store;
  remote_cisco_ops.to_xfer_memory = remote_xfer_memory;
  remote_cisco_ops.to_files_info = remote_files_info;
d4679 12
a4690 12
  remote_cisco_ops.to_kill = remote_kill;
  remote_cisco_ops.to_load = generic_load;
  remote_cisco_ops.to_mourn_inferior = remote_cisco_mourn;
  remote_cisco_ops.to_thread_alive = remote_thread_alive;
  remote_cisco_ops.to_find_new_threads = remote_threads_info;
  remote_cisco_ops.to_stratum = process_stratum;
  remote_cisco_ops.to_has_all_memory = 1;
  remote_cisco_ops.to_has_memory = 1;
  remote_cisco_ops.to_has_stack = 1;
  remote_cisco_ops.to_has_registers = 1;
  remote_cisco_ops.to_has_execution = 1;
  remote_cisco_ops.to_magic = OPS_MAGIC;
d4703 2
a4704 2
  remote_async_ops.to_longname = "Remote serial target in async version of the gdb-specific protocol";
  remote_async_ops.to_doc =
d4707 10
a4716 10
  remote_async_ops.to_open = remote_async_open;
  remote_async_ops.to_close = remote_close;
  remote_async_ops.to_detach = remote_async_detach;
  remote_async_ops.to_resume = remote_async_resume;
  remote_async_ops.to_wait = remote_async_wait;
  remote_async_ops.to_fetch_registers = remote_fetch_registers;
  remote_async_ops.to_store_registers = remote_store_registers;
  remote_async_ops.to_prepare_to_store = remote_prepare_to_store;
  remote_async_ops.to_xfer_memory = remote_xfer_memory;
  remote_async_ops.to_files_info = remote_files_info;
d4719 5
a4723 5
  remote_async_ops.to_kill = remote_async_kill;
  remote_async_ops.to_load = generic_load;
  remote_async_ops.to_mourn_inferior = remote_mourn;
  remote_async_ops.to_thread_alive = remote_thread_alive;
  remote_async_ops.to_find_new_threads = remote_threads_info;
d4726 9
a4734 9
  remote_async_ops.to_stratum = process_stratum;
  remote_async_ops.to_has_all_memory = 1;
  remote_async_ops.to_has_memory = 1;
  remote_async_ops.to_has_stack = 1;
  remote_async_ops.to_has_registers = 1;
  remote_async_ops.to_has_execution = 1;
  remote_async_ops.to_has_thread_control = tc_schedlock;	/* can lock scheduler */
  remote_async_ops.to_has_async_exec = 1;
  remote_async_ops.to_magic = OPS_MAGIC;
d4746 1
a4746 1
  extended_async_remote_ops.to_longname =
d4748 1
a4748 1
  extended_async_remote_ops.to_doc =
d4751 1
a4751 1
    extended_async_remote_ops.to_open = extended_remote_async_open;
d4793 1
a4793 1
  add_cmd ("compare-sections", class_obscure, compare_sections_command,
d4795 1
a4795 1
Argument is a single section name (default: all loaded sections).",
d4807 1
a4807 1
  add_show_from_set
d4809 1
a4809 1
		  var_integer, (char *) &remote_timeout,
d4814 1
a4814 1
  add_show_from_set
d4816 1
a4816 1
		  var_integer, (char *) &remote_break,
d4821 1
a4821 1
  add_show_from_set
d4823 2
a4824 2
		  var_integer, (char *) &remote_write_size,
	       "Set the maximum number of bytes per memory write packet.\n",
d4829 1
a4829 1
  add_show_from_set
d4831 1
a4831 1
		  var_integer, (char *) &remote_address_size,
d4835 1
a4835 1
     &showlist);
d4837 1
a4837 1
  add_show_from_set
@


1.1.1.11
log
@import gdb-1999-07-12 snapshot
@
text
@d3297 2
a3298 1
  fputstr_filtered (buf, '"', gdb_stdout);
d3355 1
a3355 3
	  fprintf_unfiltered (gdb_stdlog, "Sending packet: ");
	  fputstrn_unfiltered (buf2, p - buf2, 0, gdb_stdlog);
	  fprintf_unfiltered (gdb_stdlog, "...", buf2);
d3621 1
a3621 5
	    {
	      fprintf_unfiltered (gdb_stdlog, "Packet received: ");
	      fputstr_unfiltered (buf, 0, gdb_stdlog);
	      fprintf_unfiltered (gdb_stdlog, "\n");
	    }
@


1.1.1.12
log
@import gdb-1999-07-19 snapshot
@
text
@d4835 1
a4835 1
		  var_boolean, (char *) &remote_break,
@


1.1.1.13
log
@import gdb-1999-07-26 snapshot
@
text
@a377 29
#if __STDC__
struct packet_config;
#endif

static void show_packet_config_cmd PARAMS ((struct packet_config * config));

static void set_packet_config_cmd PARAMS ((struct packet_config * config,
					      struct cmd_list_element * c));

static void add_packet_config_cmd PARAMS ((struct packet_config * config,
					   char *name,
					   char *title,
   void (*set_func) (char *args, int from_tty, struct cmd_list_element * c),
			       void (*show_func) (char *name, int from_tty),
					   struct cmd_list_element **setlist,
					   struct cmd_list_element **showlist));

static void init_packet_config PARAMS ((struct packet_config * config));

static void set_remote_protocol_P_packet_cmd PARAMS ((char *args,
						      int from_tty,
					      struct cmd_list_element * c));

static void show_remote_protocol_P_packet_cmd PARAMS ((char *args,
						       int from_tty));




d474 3
a476 157
/* Generic configuration support for packets the stub optionally
   supports. Allows the user to specify the use of the packet as well
   as allowing GDB to auto-detect support in the remote stub. */

enum packet_support
  {
    PACKET_SUPPORT_UNKNOWN = 0,
    PACKET_ENABLE,
    PACKET_DISABLE
  };

enum packet_detect
  {
    PACKET_AUTO_DETECT = 0,
    PACKET_MANUAL_DETECT
  };

struct packet_config
  {
    char *state;
    char *name;
    char *title;
    enum packet_detect detect;
    enum packet_support support;
  };

static char packet_support_auto[] = "auto";
static char packet_enable[] = "enable";
static char packet_disable[] = "disable";
static char *packet_support_enums[] =
{
  packet_support_auto,
  packet_enable,
  packet_disable,
  0,
};

static void
set_packet_config_cmd (config, c)
     struct packet_config *config;
     struct cmd_list_element *c;
{
  if (config->state == packet_enable)
    {
      config->detect = PACKET_MANUAL_DETECT;
      config->support = PACKET_ENABLE;
    }
  else if (config->state == packet_disable)
    {
      config->detect = PACKET_MANUAL_DETECT;
      config->support = PACKET_DISABLE;
    }
  else if (config->state == packet_support_auto)
    {
      config->detect = PACKET_AUTO_DETECT;
      config->support = PACKET_SUPPORT_UNKNOWN;
    }
  else
    fatal ("Bad enum value");
}

static void
show_packet_config_cmd (config)
     struct packet_config *config;
{
  char *support = "internal-error";
  switch (config->support)
    {
    case PACKET_ENABLE:
      support = "enabled";
      break;
    case PACKET_DISABLE:
      support = "disabled";
      break;
    case PACKET_SUPPORT_UNKNOWN:
      support = "unknown";
      break;
    }
  switch (config->detect)
    {
    case PACKET_AUTO_DETECT:
      printf_filtered ("Support for remote protocol `%s' (%s) packet is auto-detected, currently %s.\n",
		       config->name, config->title, support);
      break;
    case PACKET_MANUAL_DETECT:
      printf_filtered ("Support for remote protocol `%s' (%s) is currently %s.\n",
		       config->name, config->title, support);
    }
}

static void
add_packet_config_cmd (config, name, title, set_func, show_func,
		       setlist, showlist)
     struct packet_config *config;
     char *name;
     char *title;
     void (*set_func) PARAMS ((char *args, int from_tty,
			       struct cmd_list_element * c));
     void (*show_func) PARAMS ((char *name, int from_tty));
     struct cmd_list_element **setlist;
     struct cmd_list_element **showlist;
{
  struct cmd_list_element *c;
  char *set_doc;
  char *show_doc;
  char *full_name;
  config->name = name;
  config->title = title;
  asprintf (&set_doc, "Set use of remote protocol `%s' (%s) packet",
	    name, title);
  asprintf (&show_doc, "Show current use of remote protocol `%s' (%s) packet",
	    name, title);
  asprintf (&full_name, "%s-packet", name);
  c = add_set_enum_cmd (full_name,
			class_obscure, packet_support_enums,
			(char *) &config->state,
			set_doc, setlist);
  c->function.sfunc = set_func;
  add_cmd (full_name, class_obscure, show_func, show_doc, showlist);
}

static void
init_packet_config (config)
     struct packet_config *config;
{
  switch (config->detect)
    {
    case PACKET_AUTO_DETECT:
      config->support = PACKET_SUPPORT_UNKNOWN;
      break;
    case PACKET_MANUAL_DETECT:
      /* let the user beware */
      break;
    }
}

/* Should we try the 'P' (set register) request?  */

static struct packet_config remote_protocol_P;

static void
set_remote_protocol_P_packet_cmd (args, from_tty, c)
     char *args;
     int from_tty;
     struct cmd_list_element *c;
{
  set_packet_config_cmd (&remote_protocol_P, c);
}

static void
show_remote_protocol_P_packet_cmd (args, from_tty)
     char *args;
     int from_tty;
{
  show_packet_config_cmd (&remote_protocol_P);
}

d1721 5
a1725 1
  init_packet_config (&remote_protocol_P);
d1815 5
a1819 1
  init_packet_config (&remote_protocol_P);
d2738 1
a2738 9
  switch (remote_protocol_P.support)
    {
    case PACKET_DISABLE:
    case PACKET_SUPPORT_UNKNOWN:
      read_register_bytes (0, (char *) NULL, REGISTER_BYTES);
      break;
    case PACKET_ENABLE:
      break;
    }
a2740 28
/* Helper: Attempt to store REGNO using the P packet.  Return fail IFF
   packet was not recognized. */

static int
store_register_using_P (regno)
     int regno;
{
  /* Try storing a single register.  */
  char *buf = alloca (PBUFSIZ);
  char *regp;
  char *p;
  int i;

  sprintf (buf, "P%x=", regno);
  p = buf + strlen (buf);
  regp = &registers[REGISTER_BYTE (regno)];
  for (i = 0; i < REGISTER_RAW_SIZE (regno); ++i)
    {
      *p++ = tohex ((regp[i] >> 4) & 0xf);
      *p++ = tohex (regp[i] & 0xf);
    }
  *p = '\0';
  remote_send (buf);

  return buf[0] != '\0';
}


d2754 1
a2754 1
  if (regno >= 0)
d2756 14
a2769 1
      switch (remote_protocol_P.support)
d2771 2
a2772 22
	case PACKET_DISABLE:
	  break;
	case PACKET_ENABLE:
	  if (store_register_using_P (regno))
	    return;
	  else
	    error ("Protocol error: P packet not recognized by stub");
	case PACKET_SUPPORT_UNKNOWN:
	  if (store_register_using_P (regno))
	    {
	      /* The stub recognized the 'P' packet.  Remember this.  */
	      remote_protocol_P.support = PACKET_ENABLE;
	      return;
	    }
	  else
	    {
	      /* The stub does not support the 'P' packet.  Use 'G'
	         instead, and don't try using 'P' in the future (it
	         will just waste our time).  */
	      remote_protocol_P.support = PACKET_DISABLE;
	      break;
	    }
d2774 5
d4412 4
a4415 1
  init_packet_config (&remote_protocol_P);
a4775 9
set_remote_cmd (args, from_tty)
     char *args;
     int from_tty;
{
  
}


static void
a4783 3
  static struct cmd_list_element *remote_set_cmdlist;
  static struct cmd_list_element *remote_show_cmdlist;

a4811 13
  add_prefix_cmd ("remote", class_maintenance, set_remote_cmd, "\
Remote protocol specific variables\n\
Configure various remote-protocol specific variables such as\n\
the packets being used",
		  &remote_set_cmdlist, "remote ",
		  0/*allow-unknown*/, &setlist);
  add_prefix_cmd ("remote", class_maintenance, set_remote_cmd, "\
Remote protocol specific variables\n\
Configure various remote-protocol specific variables such as\n\
the packets being used",
		  &remote_show_cmdlist, "remote ",
		  0/*allow-unknown*/, &showlist);

a4864 4
  add_packet_config_cmd (&remote_protocol_P, "P", "set-register",
			 set_remote_protocol_P_packet_cmd,
			 show_remote_protocol_P_packet_cmd,
			 &remote_set_cmdlist, &remote_show_cmdlist);
@


1.1.1.14
log
@import gdb-1999-08-09 snapshot
@
text
@d21 181
a202 1
/* See the GDB User Guide for details of the GDB remote protocol. */
a403 7
static void set_remote_protocol_Z_packet_cmd PARAMS ((char *args,
						      int from_tty,
					      struct cmd_list_element * c));

static void show_remote_protocol_Z_packet_cmd PARAMS ((char *args,
						       int from_tty));

d450 11
d561 1
a561 1
    internal_error ("Bad enum value");
a659 48
/* Should we try the 'Z' (set breakpoint) request?  */

static struct packet_config remote_protocol_Z;

static void
set_remote_protocol_Z_packet_cmd (args, from_tty, c)
     char *args;
     int from_tty;
     struct cmd_list_element *c;
{
  set_packet_config_cmd (&remote_protocol_Z, c);
}

static void
show_remote_protocol_Z_packet_cmd (args, from_tty)
     char *args;
     int from_tty;
{
  show_packet_config_cmd (&remote_protocol_Z);
}

/* Should we try the 'X' (remote binary download) packet?

   This variable (available to the user via "set remote X-packet")
   dictates whether downloads are sent in binary (via the 'X' packet).
   We assume that the stub can, and attempt to do it. This will be
   cleared if the stub does not understand it. This switch is still
   needed, though in cases when the packet is supported in the stub,
   but the connection does not allow it (i.e., 7-bit serial connection
   only). */

static struct packet_config remote_protocol_binary_download;

static void
set_remote_protocol_binary_download_cmd (char *args,
					 int from_tty,
					 struct cmd_list_element *c)
{
  set_packet_config_cmd (&remote_protocol_binary_download, c);
}

static void
show_remote_protocol_binary_download_cmd (char *args,
					  int from_tty)
{
  show_packet_config_cmd (&remote_protocol_binary_download);
}

d1745 1
a1745 1
void
d1905 1
a1905 2
  init_packet_config (&remote_protocol_Z);
  
d1911 1
a1911 1
  init_packet_config (&remote_protocol_binary_download);
a1994 1
  init_packet_config (&remote_protocol_Z);
d2001 1
a2001 1
  init_packet_config (&remote_protocol_binary_download);
a2076 1

d3106 2
a3107 4
   NOTE: This can still lose if the serial line is not eight-bit
   clean. In cases like this, the user should clear "remote
   X-packet". */

d3112 1
a3112 1
  switch (remote_protocol_binary_download.support)
d3114 18
a3131 19
    case PACKET_DISABLE:
      break;
    case PACKET_ENABLE:
      break;
    case PACKET_SUPPORT_UNKNOWN:
      {
	char *buf = alloca (PBUFSIZ);
	char *p;
	
	p = buf;
	*p++ = 'X';
	p += hexnumstr (p, (ULONGEST) addr);
	*p++ = ',';
	p += hexnumstr (p, (ULONGEST) 0);
	*p++ = ':';
	*p = '\0';
	
	putpkt_binary (buf, (int) (p - buf));
	getpkt (buf, 0);
d3133 8
a3140 16
	if (buf[0] == '\0')
	  {
	    if (remote_debug)
	      fprintf_unfiltered (gdb_stdlog,
				  "binary downloading NOT suppported by target\n");
	    remote_protocol_binary_download.support = PACKET_DISABLE;
	  }
	else
	  {
	    if (remote_debug)
	      fprintf_unfiltered (gdb_stdlog,
				  "binary downloading suppported by target\n");
	    remote_protocol_binary_download.support = PACKET_ENABLE;
	  }
	break;
      }
d3185 1
a3185 1
      switch (remote_protocol_binary_download.support)
a3186 1
	case PACKET_ENABLE:
d3189 3
a3191 2
	  break;
	case PACKET_DISABLE:
a3193 3
	  break;
	case PACKET_SUPPORT_UNKNOWN:
	  internal_error ("remote_write_bytes: bad switch");
d3207 1
a3207 1
      switch (remote_protocol_binary_download.support)
d3209 42
a3250 49
	case PACKET_ENABLE:
	  {
	    int escaped = 0;
	    for (i = 0;
		 (i < todo) && (i + escaped) < (max_buf_size - 2);
		 i++)
	      {
		switch (myaddr[i] & 0xff)
		  {
		  case '$':
		  case '#':
		  case 0x7d:
		    /* These must be escaped */
		    escaped++;
		    *p++ = 0x7d;
		    *p++ = (myaddr[i] & 0xff) ^ 0x20;
		    break;
		  default:
		    *p++ = myaddr[i] & 0xff;
		    break;
		  }
	      }
	    
	    if (i < todo)
	      {
		/* Escape chars have filled up the buffer prematurely, 
		   and we have actually sent fewer bytes than planned.
		   Fix-up the length field of the packet.  */
		
		/* FIXME: will fail if new len is a shorter string than 
		   old len.  */
		
		plen += hexnumstr (plen, (ULONGEST) i);
		*plen++ = ':';
	      }
	    break;
	  }
	case PACKET_DISABLE:
	  {
	    for (i = 0; i < todo; i++)
	      {
		*p++ = tohex ((myaddr[i] >> 4) & 0xf);
		*p++ = tohex (myaddr[i] & 0xf);
	      }
	    *p = '\0';
	    break;
	  }
	case PACKET_SUPPORT_UNKNOWN:
	  internal_error ("remote_write_bytes: bad switch");
a4034 44
#endif  
  int bp_size;

  /* Try the "Z" packet if it is not already disabled.
     If it succeeds, then set the support to PACKET_ENABLE.
     If it fails, and the user has explicitly requested the Z support 
     then report an error, otherwise, mark it disabled and go on. */
  
  if ((remote_protocol_Z.support == PACKET_ENABLE)
      || (remote_protocol_Z.support == PACKET_SUPPORT_UNKNOWN)) 
    {
      char buf[PBUFSIZ], *p = buf;
      
      addr = remote_address_masked (addr);
      *(p++) = 'Z';
      *(p++) = '0';
      *(p++) = ',';
      p += hexnumstr (p, (ULONGEST) addr);
      BREAKPOINT_FROM_PC (&addr, &bp_size);
      sprintf (p, ",%d", bp_size);
      
      putpkt (buf);
      getpkt (buf, 0);

      if (buf[0] != '\0')
	{
	  remote_protocol_Z.support = PACKET_ENABLE;
	  return (buf[0] == 'E');
	}
      
      /* The stub does not support the 'Z' request.  If the user has
         explicitly requested the Z support, or if the stub previously
	 said it supported the packet, this is an error,
         otherwise, mark it disabled. */
      
      else if (remote_protocol_Z.support == PACKET_ENABLE)
	{
	  error ("Protocol error: Z packet not recognized by stub");
	}
      else
	{
	  remote_protocol_Z.support = PACKET_DISABLE;
	}
    }
a4035 1
#ifdef REMOTE_BREAKPOINT  
a4058 23
  char buf[PBUFSIZ];
  int bp_size;

  if ((remote_protocol_Z.support == PACKET_ENABLE)
      || (remote_protocol_Z.support == PACKET_SUPPORT_UNKNOWN))
    {
      char buf[PBUFSIZ], *p = buf;
      
      *(p++) = 'z';
      *(p++) = '0';
      *(p++) = ',';

      addr = remote_address_masked (addr);
      p += hexnumstr (p, (ULONGEST) addr);
      BREAKPOINT_FROM_PC (&addr, &bp_size);
      sprintf (p, ",%d", bp_size);
      
      putpkt (buf);
      getpkt (buf, 0);

      return (buf[0] == 'E');
    }

a4065 101
#ifdef TARGET_HAS_HARDWARE_WATCHPOINTS
int
remote_insert_watchpoint (addr, len, type)
     CORE_ADDR addr;
     int len;
     int type;
{
  char buf[PBUFSIZ], *p;

  if (remote_protocol_Z.support == PACKET_DISABLE)
    error ("Can't set hardware watchpoints without the 'Z' packet\n");
  
  sprintf (buf, "Z%x,", type + 2 );
  p = strchr (buf, '\0');
  addr = remote_address_masked (addr);
  p += hexnumstr (p, (ULONGEST) addr);
  sprintf (p, ",%lx", len);
  
  putpkt (buf);
  getpkt (buf, 0);

  if (buf[0] == '\0' || buf [0] == 'E')
    return -1;

  return 0;
}

int
remote_remove_watchpoint (addr, len, type)
     CORE_ADDR addr;
     int len;
     int type;
{
  char buf[PBUFSIZ], *p;
  
  sprintf (buf, "z%x,", type + 2 );
  p = strchr (buf, '\0');
  addr = remote_address_masked (addr);
  p += hexnumstr (p, (ULONGEST) addr);
  sprintf (p, ",%lx", len);
  putpkt (buf);
  getpkt (buf, 0);

  if (buf[0] == '\0' || buf [0] == 'E')
    return -1;

  return 0;
}

int
remote_insert_hw_breakpoint (addr, len)
     CORE_ADDR addr;
     int len;
{
  char buf[PBUFSIZ], *p = buf;
      
  if (remote_protocol_Z.support == PACKET_DISABLE)
    error ("Can't set hardware breakpoints without the 'Z' packet\n");

  *(p++) = 'Z';
  *(p++) = '1';
  *(p++) = ',';
  
  addr = remote_address_masked (addr);
  p += hexnumstr (p, (ULONGEST) addr);
  *p = '\0';

  putpkt (buf);
  getpkt (buf, 0);

  if (buf[0] == '\0' || buf [0] == 'E')
    return -1;

  return 0;
}

int 
remote_remove_hw_breakpoint (addr, len)
     CORE_ADDR addr;
     int len;
{
  char buf[PBUFSIZ], *p = buf;
  
  *(p++) = 'z';
  *(p++) = '1';
  *(p++) = ',';
  
  addr = remote_address_masked (addr);
  p += hexnumstr (p, (ULONGEST) addr);
  *p = '\0';

  putpkt(buf);
  getpkt (buf, 0);
  
  if (buf[0] == '\0' || buf [0] == 'E')
    return -1;

  return 0;
}
#endif

a4289 53
remote_rcmd (char *command,
	     struct gdb_file *outbuf)
{
  int i;
  char *buf = alloca (PBUFSIZ);
  char *p = buf;

  if (!remote_desc)
    error ("remote rcmd is only available after target open");

  /* The query prefix */
  strcpy (buf, "qRcmd,");
  p = strchr (buf, '\0');

  if ((strlen (buf) + strlen (command) * 2 + 8/*misc*/) > PBUFSIZ)
    error ("\"monitor\" command ``%s'' is too long\n", command);

  /* Encode the actual command */
  for (i = 0; command[i]; i++)
    {
      *p++ = tohex ((command[i] >> 4) & 0xf);
      *p++ = tohex (command[i] & 0xf);
    }
  *p = '\0';

  if (putpkt (buf) < 0)
    error ("Communication problem with target\n");

  /* get/display the response */
  while (1)
    {
      /* XXX - see also tracepoint.c:remote_get_noisy_reply() */
      buf[0] = '\0';
      getpkt (buf, 0);
      if (buf[0] == '\0')
	error ("Target does not support this command\n");
      if (buf[0] == 'O' && buf[1] != 'K')
	{
	  remote_console_output (buf + 1); /* 'O' message from stub */
	  continue;
	}
      if (strcmp (buf, "OK") == 0)
	break;
      for (p = buf; p[0] != '\0' && p[1] != '\0'; p += 2)
	{
	  char c = (fromhex (p[0]) << 4) + fromhex (p[1]);
	  fputc_unfiltered (c, outbuf);
	}
      break;
    }
}

static void
a4500 1
  remote_ops.to_rcmd = remote_rcmd;
a4625 1
  init_packet_config (&remote_protocol_Z);
d4632 1
a4632 1
  init_packet_config (&remote_protocol_binary_download);
a4954 1
  remote_async_ops.to_rcmd = remote_rcmd;
a5090 8
  add_packet_config_cmd (&remote_protocol_binary_download,
			 "X", "binary-download",
			 set_remote_protocol_binary_download_cmd,
			 show_remote_protocol_binary_download_cmd,
			 &remote_set_cmdlist, &remote_show_cmdlist);
#if 0
  /* XXXX - should ``set remotebinarydownload'' be retained for
     compatibility. */
a5095 1
#endif
a5102 5
			 &remote_set_cmdlist, &remote_show_cmdlist);

  add_packet_config_cmd (&remote_protocol_Z, "Z", "breakpoint",
			 set_remote_protocol_Z_packet_cmd,
			 show_remote_protocol_Z_packet_cmd,
@


1.1.1.15
log
@import gdb-1999-08-16 snapshot
@
text
@d1855 1
a1855 1
    add_file_handler (remote_desc->fd, fetch_inferior_event, 0);
d3863 1
a3863 1
    add_file_handler (remote_desc->fd, fetch_inferior_event, 0);
a4356 4
  /* Send a NULL command across as an empty command */
  if (command == NULL)
    command = "";

a4389 5
      if (strlen (buf) == 3 && buf[0] == 'E'
	  && isdigit (buf[1]) && isdigit (buf[2]))
	{
	  error ("Protocol error with Rcmd");
	}
@


1.1.1.16
log
@import gdb-1999-08-23 snapshot
@
text
@a102 1
static void remote_async_mourn PARAMS ((void));
a3796 6
remote_async_mourn ()
{
  remote_mourn_1 (&remote_async_ops);
}

static void
d5071 1
a5071 1
  remote_async_ops.to_mourn_inferior = remote_async_mourn;
@


1.1.1.17
log
@import gdb-1999-08-30 snapshot
@
text
@d199 1
d201 1
@


1.1.1.18
log
@import gdb-1999-09-08 snapshot
@
text
@d1502 7
a1508 2
  offs = (struct section_offsets *) alloca (SIZEOF_SECTION_OFFSETS);
  memcpy (offs, symfile_objfile->section_offsets, SIZEOF_SECTION_OFFSETS);
d1595 2
a1596 4
			"Reloc offset: text = 0x%s data = 0x%s bss = 0x%s\n",
			paddr_nz (*text_offs),
			paddr_nz (*data_offs),
			paddr_nz (*bss_offs));
d1622 9
a1630 2
      offs = (struct section_offsets *) alloca (SIZEOF_SECTION_OFFSETS);
      memcpy (offs, symfile_objfile->section_offsets, SIZEOF_SECTION_OFFSETS);
d2392 1
a2392 1
		warning ("Relocation packet received with no symbol file.  \
d3456 1
a3456 1
	  fprintf_unfiltered (gdb_stdlog, "...");
d3997 1
d4043 1
a4043 1
  sprintf (p, ",%x", len);
d4066 1
a4066 1
  sprintf (p, ",%x", len);
d4261 2
a4262 2
      printf_filtered ("Section %s, range 0x%s -- 0x%s: ",
		       sectname, paddr (lma), paddr (lma + size));
d4290 1
d4880 1
@


1.1.1.19
log
@import gdb-1999-09-13 snapshot
@
text
@d5152 1
a5152 1
		  &remote_set_cmdlist, "set remote ",
d5158 1
a5158 1
		  &remote_show_cmdlist, "show remote ",
@


1.1.1.20
log
@import gdb-1999-09-21
@
text
@a38 1
#include "remote.h"
a48 1
#include "event-top.h"
d189 4
d195 2
d1843 2
a1844 4
  if (async_p && SERIAL_CAN_ASYNC_P (remote_desc))
    SERIAL_ASYNC (remote_desc, inferior_event_handler, 0);
  if (remote_debug && SERIAL_IS_ASYNC_P (remote_desc))
    fputs_unfiltered ("Async mode.\n", gdb_stdlog);
d1861 1
a1861 1
  if (extended_p && SERIAL_IS_ASYNC_P (remote_desc))
d1880 2
a1881 2
      if (SERIAL_IS_ASYNC_P (remote_desc))
	SERIAL_ASYNC (remote_desc, NULL, 0);
d1886 1
a1886 1
  if (!SERIAL_IS_ASYNC_P (remote_desc))
d1951 2
a1952 2
  if (SERIAL_IS_ASYNC_P (remote_desc))
    SERIAL_ASYNC (remote_desc, NULL, 0);
d2056 1
a2056 1
  if (SERIAL_IS_ASYNC_P (remote_desc) && !target_executing)
d2148 1
a2148 1
    delete_async_signal_handler ((struct async_signal_handler **) & sigint_remote_twice_token);
d2150 1
a2150 1
    delete_async_signal_handler ((struct async_signal_handler **) & sigint_remote_token);
d2476 1
a2476 1
      if (!SERIAL_IS_ASYNC_P (remote_desc))
d2479 1
a2479 1
      if (!SERIAL_IS_ASYNC_P (remote_desc))
d3522 27
d3589 10
a3598 1
              return 1;
d3611 6
a3616 3
          {
	    int repeat;
 	    csum += c;
d3618 6
a3623 18
	    if (remote_cisco_mode == 0)
	      {
		c = readchar (remote_timeout);
		csum += c;
		repeat = c - ' ' + 3;	/* Compute repeat count */
	      }
	    else 
	      { 
		/* Cisco's run-length encoding variant uses two 
		   hex chars to represent the repeat count. */

		c = readchar (remote_timeout);
		csum += c;
		repeat  = fromhex (c) << 4;
		c = readchar (remote_timeout);
		csum += c;
		repeat += fromhex (c);
	      }
d3625 7
a3631 14
	    if (repeat > 0 && repeat <= 255 
                && bp + repeat - 1 < buf + PBUFSIZ - 1)
	      {
		memset (bp, *(bp - 1), repeat);
		bp += c;
		continue;
	      }

	    *bp = '\0';
	    printf_filtered ("Repeat count %d too large for buffer: ", repeat);
	    puts_filtered (buf);
	    puts_filtered ("\n");
	    return 0;
	  }
d3758 2
a3759 2
  if (SERIAL_IS_ASYNC_P (remote_desc))
    SERIAL_ASYNC (remote_desc, NULL, 0);
d3857 2
a3858 2
  if (async_p && SERIAL_CAN_ASYNC_P (remote_desc))
    SERIAL_ASYNC (remote_desc, inferior_event_handler, 0);
d4942 1
a4942 1
      FD_SET (DEPRECATED_SERIAL_FD (remote_desc), &input);
@


1.1.1.21
log
@import gdb-1999-09-28 snapshot
@
text
@d56 1
a56 3
static void cleanup_sigint_signal_handler (void *dummy);
static void initialize_sigint_signal_handler (void);

d86 1
a255 10
/* FIXME: cagney/1999-09-23: Even though getpkt was called with
   ``forever'' still use the normal timeout mechanism.  This is
   currently used by the ASYNC code to guarentee that target reads
   during the initial connect always time-out.  Once getpkt has been
   modified to return a timeout indication and, in turn
   remote_wait()/wait_for_inferior() have gained a timeout parameter
   this can go away. */
static int wait_forever_enabled_p = 1;


a313 5
/* Tempoary to track who currently owns the terminal.  See
   target_async_terminal_* for more details.  */

static int remote_async_terminal_ours_p;

a1719 3
  /* See FIXME above */
  wait_forever_enabled_p = 1;

d1835 9
d1856 6
d1868 1
a1869 13

  /* With this target we start out by owning the terminal. */
  remote_async_terminal_ours_p = 1;

  /* FIXME: cagney/1999-09-23: During the initial connection it is
     assumed that the target is already ready and able to respond to
     requests. Unfortunatly remote_start_remote() eventually calls
     wait_for_inferior() with no timeout.  wait_forever_enabled_p gets
     around this. Eventually a mechanism that allows
     wait_for_inferior() to expect/get timeouts will be
     implemented. */
  wait_forever_enabled_p = 0;

d1877 3
a1880 1
      wait_forever_enabled_p = 1;
d1884 1
a1884 3
  wait_forever_enabled_p = 1;

  if (extended_p)
d1886 7
a1892 4
      /* tell the remote that we're using the extended protocol.  */
      char *buf = alloca (PBUFSIZ);
      putpkt ("!");
      getpkt (buf, 0);
d1894 1
d1896 10
a1905 11
  /* If running in asynchronous mode, register the target with the
     event loop.  Set things up so that when there is an event on the
     file descriptor, the event loop will call fetch_inferior_event,
     which will do the proper analysis to determine what happened. */
  /* FIXME: cagney/1999-09-26: We shouldn't just put the target into
     async mode.  Instead we should leave the target synchronous and
     then leave it to the client to flip modes. */
  if (event_loop_p && target_can_async_p ())
    target_async (inferior_event_handler, 0);
  if (remote_debug && SERIAL_IS_ASYNC_P (remote_desc))
    fputs_unfiltered ("Serial put into async mode.\n", gdb_stdlog);
d2049 19
a2067 7
  /* Tell the world that the target is now executing. */
  /* FIXME: cagney/1999-09-23: Is it the targets responsibility to set
     this?  Instead, should the client of target just assume (for
     async targets) that the target is going to start executing?  Is
     this information already found in the continuation block?  */
  if (SERIAL_IS_ASYNC_P (remote_desc))
    target_executing = 1;
d2113 1
a2113 1
    create_async_signal_handler (async_remote_interrupt_twice, NULL);
d2117 1
a2117 1
/* Perform the real interruption of the target execution, in response
d2135 2
a2136 7
  /* Do something only if the target was not killed by the previous
     cntl-C. */
  if (target_executing)
    {
      interrupt_query ();
      signal (SIGINT, handle_remote_sigint);
    }
d2141 2
a2142 2
static void
cleanup_sigint_signal_handler (void *dummy)
a2216 45
/* Enable/disable target terminal ownership.  Most targets can use
   terminal groups to control terminal ownership.  Remote targets are
   different in that explicit transfer of ownership to/from GDB/target
   is required. */

static void
remote_async_terminal_inferior (void)
{
  /* FIXME: cagney/1999-09-27: Shouldn't need to test for
     sync_execution here.  This function should only be called when
     GDB is resuming the inferior in the forground.  A background
     resume (``run&'') should leave GDB in control of the terminal and
     consequently should not call this code. */
  if (!sync_execution)
    return;
  /* FIXME: cagney/1999-09-27: Closely related to the above.  Make
     calls target_terminal_*() idenpotent. The event-loop GDB talking
     to an asynchronous target with a synchronous command calls this
     function from both event-top.c and infrun.c/infcmd.c.  Once GDB
     stops trying to transfer the terminal to the target when it
     shouldn't this guard can go away.  */
  if (!remote_async_terminal_ours_p)
    return;
  delete_file_handler (input_fd);
  remote_async_terminal_ours_p = 0;
  initialize_sigint_signal_handler ();
  /* NOTE: At this point we could also register our selves as the
     recipient of all input.  Any characters typed could then be
     passed on down to the target. */
}

static void
remote_async_terminal_ours (void)
{
  /* See FIXME in remote_async_terminal_inferior. */
  if (!sync_execution)
    return;
  /* See FIXME in remote_async_terminal_inferior. */
  if (remote_async_terminal_ours_p)
    return;
  cleanup_sigint_signal_handler (NULL);
  add_file_handler (input_fd, stdin_event_handler, 0);
  remote_async_terminal_ours_p = 1;
}

d2476 1
a2476 5
      /* FIXME: cagney/1999-09-27: If we're in async mode we should
         _never_ wait for ever -> test on target_is_async_p().
         However, before we do that we need to ensure that the caller
         knows how to take the target into/out of async mode. */
      getpkt ((char *) buf, wait_forever_enabled_p);
d3835 1
a3835 1
  if (event_loop_p && SERIAL_CAN_ASYNC_P (remote_desc))
a4675 3
  /* See FIXME above */
  wait_forever_enabled_p = 1;

a5012 20
static int
remote_can_async_p (void)
{
  /* We're async whenever the serial device is. */
  return SERIAL_CAN_ASYNC_P (remote_desc);
}

static int
remote_is_async_p (void)
{
  /* We're async whenever the serial device is. */
  return SERIAL_IS_ASYNC_P (remote_desc);
}

static void
remote_async (void (*callback) (int error, void *context, int fd), void *context)
{
  SERIAL_ASYNC (remote_desc, callback, context);
}

a5038 2
  remote_async_ops.to_terminal_inferior = remote_async_terminal_inferior;
  remote_async_ops.to_terminal_ours = remote_async_terminal_ours;
d5054 1
a5054 3
  remote_async_ops.to_can_async_p = remote_can_async_p;
  remote_async_ops.to_is_async_p = remote_is_async_p;
  remote_async_ops.to_async = remote_async;
@


1.1.1.22
log
@import gdb-1999-10-04 snapshot
@
text
@a50 1
#include "inf-loop.h"
d64 2
d1907 12
d2062 8
a2079 16
  /* We are about to start executing the inferior, let's register it
     with the event loop. NOTE: this is the one place where all the
     execution commands end up. We could alternatively do this in each
     of the execution commands in infcmd.c.*/
  /* FIXME: ezannoni 1999-09-28: We may need to move this out of here
     into infcmd.c in order to allow inferior function calls to work
     NOT asynchronously. */
  if (event_loop_p && SERIAL_CAN_ASYNC_P (remote_desc))
    target_async (inferior_event_handler, 0);
  /* Tell the world that the target is now executing. */
  /* FIXME: cagney/1999-09-23: Is it the targets responsibility to set
     this?  Instead, should the client of target just assume (for
     async targets) that the target is going to start executing?  Is
     this information already found in the continuation block?  */
  if (SERIAL_IS_ASYNC_P (remote_desc))
    target_executing = 1;
d3405 1
a3405 4
  if (ch >= 0)
    return (ch & 0x7f);

  switch ((enum serial_rc) ch)
a3407 1
      target_mourn_inferior ();
a3408 1
      /* no return */
a3410 1
      /* no return */
d3412 3
a3414 1
      break;
a3415 1
  return ch;
d3726 1
a3726 1
	      if (forever)	/* Watchdog went off?  Kill the target. */
a3727 1
		  QUIT;
d3890 2
a3891 2
  if (event_loop_p && target_can_async_p ())
    target_async (inferior_event_handler, 0);
a5084 8
/* Pass the SERIAL event on and up to the client.  One day this code
   will be able to delay notifying the client of an event until the
   point where an entire packet has been received. */

static void (*async_client_callback) (enum inferior_event_type event_type, void *context);
static void *async_client_context;
static serial_event_ftype remote_async_serial_handler;

d5086 1
a5086 1
remote_async_serial_handler (serial_t scb, void *context)
d5088 1
a5088 16
  /* Don't propogate error information up to the client.  Instead let
     the client find out about the error by querying the target.  */
  async_client_callback (INF_REG_EVENT, async_client_context);
}

static void
remote_async (void (*callback) (enum inferior_event_type event_type, void *context), void *context)
{
  if (callback != NULL)
    {
      SERIAL_ASYNC (remote_desc, remote_async_serial_handler, NULL);
      async_client_callback = callback;
      async_client_context = context;
    }
  else
    SERIAL_ASYNC (remote_desc, NULL, NULL);
@


1.1.1.23
log
@import gdb-1999-10-11 snapshot
@
text
@d63 1
a63 1
void async_remote_interrupt_twice PARAMS ((gdb_client_data));
a168 2
static int hexnumnstr PARAMS ((char *, ULONGEST, int));

d2109 1
a2109 1
    create_async_signal_handler (inferior_event_handler_wrapper, NULL);
d2127 1
a2127 1
void
a2130 2
  if (remote_debug)
    fprintf_unfiltered (gdb_stdlog, "remote_interrupt_twice called\n");
d2965 1
a2965 1
/* Set BUF to the minimum number of hex digits representing NUM.  */
d2972 1
a2973 3
  return hexnumnstr (buf, num, len);
}

d2975 1
a2975 1
/* Set BUF to the hex digits representing NUM, padded to WIDTH characters.  */
d2977 1
a2977 11
static int
hexnumnstr (buf, num, width)
     char *buf;
     ULONGEST num;
     int width;
{
  int i;

  buf[width] = '\0';

  for (i = width - 1; i >= 0; i--)
d2983 1
a2983 1
  return width;
a3092 1
      int plenlen;
d3118 1
a3118 2
      plenlen = hexnumstr (p, (ULONGEST) todo);
      p += plenlen;
d3154 4
a3157 2
		   Fix-up the length field of the packet.  Use the same
		   number of characters as before.  */
d3159 2
a3160 2
		plen += hexnumnstr (plen, (ULONGEST) i, plenlen);
		*plen = ':';  /* overwrite \0 from hexnumnstr() */
@


1.1.1.24
log
@import gdb-1999-10-18 snapshot
@
text
@d67 2
a68 1
static int remote_write_bytes (CORE_ADDR memaddr, char *myaddr, int len);
d2272 2
a2273 1
remote_console_output (char *msg)
a2284 1
  gdb_flush (gdb_stdtarg);
d3081 1
a3081 2
   Returns number of bytes transferred, or 0 (setting errno) for
   error.  Only transfer a single packet. */
d3084 4
a3087 1
remote_write_bytes (CORE_ADDR memaddr, char *myaddr, int len)
d3089 1
a3089 1
  unsigned char *buf;
d3091 1
a3091 5
  unsigned char *p;
  unsigned char *plen;
  int plenlen;
  int todo;
  int nr_bytes;
d3096 2
a3097 1
  /* Determine the max packet size. */
a3100 1
  buf = alloca (max_buf_size + 1);
d3105 2
a3106 7
  /* construct "M"<memaddr>","<len>":" */
  /* sprintf (buf, "M%lx,%x:", (unsigned long) memaddr, todo); */
  p = buf;

  /* Append [XM].  Compute a best guess of the number of bytes
     actually transfered. */
  switch (remote_protocol_binary_download.support)
d3108 10
a3117 37
    case PACKET_ENABLE:
      *p++ = 'X';
      /* Best guess at number of bytes that will fit. */
      todo = min (len, max_buf_size);
      break;
    case PACKET_DISABLE:
      *p++ = 'M';
      /* num bytes that will fit */
      todo = min (len, max_buf_size / 2);
      break;
    case PACKET_SUPPORT_UNKNOWN:
      internal_error ("remote_write_bytes: bad switch");
    }
  
  /* Append <memaddr> */
  memaddr = remote_address_masked (memaddr);
  p += hexnumstr (p, (ULONGEST) memaddr);
  *p++ = ',';
  
  /* Append <len>.  Retain the location/size of <len>.  It may
     need to be adjusted once the packet body has been created. */
  plen = p;
  plenlen = hexnumstr (p, (ULONGEST) todo);
  p += plenlen;
  *p++ = ':';
  *p = '\0';
  
  /* Append the packet body. */
  switch (remote_protocol_binary_download.support)
    {
    case PACKET_ENABLE:
      /* Binary mode.  Send target system values byte by byte, in
	 increasing byte addresses.  Only escape certain critical
	 characters.  */
      for (nr_bytes = 0;
	   (nr_bytes < todo) && (p - buf) < (max_buf_size - 2);
	   nr_bytes++)
d3119 10
a3128 13
	  switch (myaddr[nr_bytes] & 0xff)
	    {
	    case '$':
	    case '#':
	    case 0x7d:
	      /* These must be escaped */
	      *p++ = 0x7d;
	      *p++ = (myaddr[nr_bytes] & 0xff) ^ 0x20;
	      break;
	    default:
	      *p++ = myaddr[nr_bytes] & 0xff;
	      break;
	    }
d3130 14
a3143 1
      if (nr_bytes < todo)
d3145 47
a3191 7
	  /* Escape chars have filled up the buffer prematurely, 
	     and we have actually sent fewer bytes than planned.
	     Fix-up the length field of the packet.  Use the same
	     number of characters as before.  */
	  
	  plen += hexnumnstr (plen, (ULONGEST) nr_bytes, plenlen);
	  *plen = ':';  /* overwrite \0 from hexnumnstr() */
d3193 5
a3197 6
      break;
    case PACKET_DISABLE:
      /* Normal mode: Send target system values byte by byte, in
	 increasing byte addresses.  Each byte is encoded as a two hex
	 value.  */
      for (nr_bytes = 0; nr_bytes < todo; nr_bytes++)
d3199 6
a3204 2
	  *p++ = tohex ((myaddr[nr_bytes] >> 4) & 0xf);
	  *p++ = tohex (myaddr[nr_bytes] & 0xf);
d3206 6
a3211 17
      *p = '\0';
      break;
    case PACKET_SUPPORT_UNKNOWN:
      internal_error ("remote_write_bytes: bad switch");
    }
  
  putpkt_binary (buf, (int) (p - buf));
  getpkt (buf, 0);
  
  if (buf[0] == 'E')
    {
      /* There is no correspondance between what the remote protocol
	 uses for errors and errno codes.  We would like a cleaner way
	 of representing errors (big enough to include errno codes,
	 bfd_error codes, and others).  But for now just return EIO.  */
      errno = EIO;
      return 0;
d3213 1
a3213 4
  
  /* Return NR_BYTES, not TODO, in case escape chars caused us to send fewer
     bytes than we'd planned.  */
  return nr_bytes;
a3222 7

/* NOTE: cagney/1999-10-18: This function (and its siblings in other
   remote targets) shouldn't attempt to read the entire buffer.
   Instead it should read a single packet worth of data and then
   return the byte size of that packet to the caller.  The caller (its
   caller and its callers caller ;-) already contains code for
   handling partial reads. */
@


1.1.1.25
log
@import gdb-1999-10-25 snapshot
@
text
@d3980 1
a3980 2
      char *buf = alloca (PBUFSIZ);
      char *p = buf;
d4043 1
a4043 2
      char *buf = alloca (PBUFSIZ);
      char *p = buf;
d4074 1
a4074 2
  char *buf = alloca (PBUFSIZ);
  char *p;
d4100 1
a4100 2
  char *buf = alloca (PBUFSIZ);
  char *p;
d4121 1
a4121 2
  char *buf = alloca (PBUFSIZ);
  char *p = buf;
d4148 1
a4148 2
  char *buf = alloca (PBUFSIZ);
  char *p = buf;
a4240 5

/* FIXME: cagney/1999-10-26: This command should be broken down into a
   target method (target verify memory) and generic version of the
   actual command.  This will allow other high-level code (especially
   generic_load()) to make use of this target functionality. */
@


1.1.1.26
log
@import gdb-1999-11-08 snapshot
@
text
@d283 22
d318 7
a329 215

/* This is the size (in chars) of the first response to the ``g''
   packet.  It is used as a heuristic when determining the maximum
   size of memory-read and memory-write packets.  A target will
   typically only reserve a buffer large enough to hold the ``g''
   packet.  The size does not include packet overhead (headers and
   trailers). */

static long actual_register_packet_size;

/* This is the maximum size (in chars) of a non read/write packet.  It
   is also used as a cap on the size of read/write packets. */

static long remote_packet_size;
/* compatibility. */
#define PBUFSIZ (remote_packet_size)

/* User configurable variables for the number of characters in a
   memory read/write packet.  MIN (PBUFSIZ, g-packet-size) is the
   default.  Some targets need smaller values (fifo overruns, et.al.)
   and some users need larger values (speed up transfers).  The
   variables ``preferred_*'' (the user request), ``current_*'' (what
   was actually set) and ``forced_*'' (Positive - a soft limit,
   negative - a hard limit). */

struct memory_packet_config
{
  char *name;
  long size;
  int fixed_p;
};

/* Compute the current size of a read/write packet.  Since this makes
   use of ``actual_register_packet_size'' the computation is dynamic.  */

static long
get_memory_packet_size (struct memory_packet_config *config)
{
  /* NOTE: The somewhat arbitrary 16k comes from the knowledge (folk
     law?) that some hosts don't cope very well with large alloca()
     calls.  Eventually the alloca() code will be replaced by calls to
     xmalloc() and make_cleanups() allowing this restriction to either
     be lifted or removed. */
#ifndef MAX_REMOTE_PACKET_SIZE
#define MAX_REMOTE_PACKET_SIZE 16384
#endif
  /* NOTE: 16 is just chosen at random. */
#ifndef MIN_REMOTE_PACKET_SIZE
#define MIN_REMOTE_PACKET_SIZE 16
#endif
  long what_they_get;
  if (config->fixed_p)
    {
      if (config->size <= 0)
	what_they_get = MAX_REMOTE_PACKET_SIZE;
      else
	what_they_get = config->size;
    }
  else
    {
      what_they_get = remote_packet_size;
      /* Limit the packet to the size specified by the user. */
      if (config->size > 0
	  && what_they_get > config->size)
	what_they_get = config->size;
      /* Limit it to the size of the targets ``g'' response. */
      if (actual_register_packet_size > 0
	  && what_they_get > actual_register_packet_size)
	what_they_get = actual_register_packet_size;
    }
  if (what_they_get > MAX_REMOTE_PACKET_SIZE)
    what_they_get = MAX_REMOTE_PACKET_SIZE;
  if (what_they_get < MIN_REMOTE_PACKET_SIZE)
    what_they_get = MIN_REMOTE_PACKET_SIZE;
  return what_they_get;
}

/* Update the size of a read/write packet. If they user wants
   something really big then do a sanity check. */

static void
set_memory_packet_size (char *args, struct memory_packet_config *config)
{
  int fixed_p = config->fixed_p;
  long size = config->size;
  if (args == NULL)
    error ("Argument required (integer, `fixed' or `limited').");
  else if (strcmp (args, "hard") == 0
      || strcmp (args, "fixed") == 0)
    fixed_p = 1;
  else if (strcmp (args, "soft") == 0
	   || strcmp (args, "limit") == 0)
    fixed_p = 0;
  else
    {
      char *end;
      size = strtoul (args, &end, 0);
      if (args == end)
	error ("Invalid %s (bad syntax).", config->name);
#if 0
      /* Instead of explicitly capping the size of a packet to
         MAX_REMOTE_PACKET_SIZE or dissallowing it, the user is
         instead allowed to set the size to something arbitrarily
         large. */
      if (size > MAX_REMOTE_PACKET_SIZE)
	error ("Invalid %s (too large).", config->name);
#endif
    }
  /* Extra checks? */
  if (fixed_p && !config->fixed_p)
    {
      if (! query ("The target may not be able to correctly handle a %s\n"
		   "of %ld bytes. Change the packet size? ",
		   config->name, size))
	error ("Packet size not changed.");
    }
  /* Update the config. */
  config->fixed_p = fixed_p;
  config->size = size;
}

static void
show_memory_packet_size (struct memory_packet_config *config)
{
  printf_filtered ("The %s is %ld. ", config->name, config->size);
  if (config->fixed_p)
    printf_filtered ("Packets are fixed at %ld bytes.\n",
		     get_memory_packet_size (config));
  else
    printf_filtered ("Packets are limited to %ld bytes.\n",
		     get_memory_packet_size (config));
}

static struct memory_packet_config memory_write_packet_config =
{
  "memory-write-packet-size",
};

static void
set_memory_write_packet_size (char *args, int from_tty)
{
  set_memory_packet_size (args, &memory_write_packet_config);
}

static void
show_memory_write_packet_size (char *args, int from_tty)
{
  show_memory_packet_size (&memory_write_packet_config);
}

static long
get_memory_write_packet_size (void)
{
  return get_memory_packet_size (&memory_write_packet_config);
}

static struct memory_packet_config memory_read_packet_config =
{
  "memory-read-packet-size",
};

static void
set_memory_read_packet_size (char *args, int from_tty)
{
  set_memory_packet_size (args, &memory_read_packet_config);
}

static void
show_memory_read_packet_size (char *args, int from_tty)
{
  show_memory_packet_size (&memory_read_packet_config);
}

static long
get_memory_read_packet_size (void)
{
  long size = get_memory_packet_size (&memory_read_packet_config);
  /* FIXME: cagney/1999-11-07: Functions like getpkt() need to get an
     extra buffer size argument before the memory read size can be
     increased beyond PBUFSIZ. */
  if (size > PBUFSIZ)
    size = PBUFSIZ;
  return size;
}

/* Register packet size initialization. Since the bounds change when
   the architecture changes (namely REGISTER_BYTES) this all needs to
   be multi-arched.  */

static void
register_remote_packet_sizes (void)
{
  REGISTER_GDBARCH_SWAP (remote_packet_size);
  REGISTER_GDBARCH_SWAP (actual_register_packet_size);
}

static void
build_remote_packet_sizes (void)
{
  /* Maximum number of characters in a packet. This default m68k-stub.c and
     i386-stub.c stubs. */
  remote_packet_size = 400;
  /* Should REGISTER_BYTES needs more space than the default, adjust
     the size accordingly. Remember that each byte is encoded as two
     characters. 32 is the overhead for the packet header /
     footer. NOTE: cagney/1999-10-26: I suspect that 8
     (``$NN:G...#NN'') is a better guess, the below has been padded a
     little. */
  if (REGISTER_BYTES > ((remote_packet_size - 32) / 2))
    remote_packet_size = (REGISTER_BYTES * 2 + 32);
  
  /* This one is filled in when a ``g'' packet is received. */
  actual_register_packet_size = 0;
}

d2752 2
a2753 5
  /* Save the size of the packet sent to us by the target.  Its used
     as a heuristic when determining the max size of packets that the
     target can safely receive. */
  if (actual_register_packet_size == 0)
    actual_register_packet_size = strlen (buf);
d3098 3
a3100 1
  max_buf_size = get_memory_write_packet_size ();
d3231 1
a3231 1
  char *buf;
d3235 5
a3239 3
  /* Create a buffer big enough for this packet. */
  max_buf_size = get_memory_read_packet_size ();
  buf = alloca (max_buf_size);
d3480 1
a3480 1
  char *buf2 = alloca (cnt + 6);
d3490 3
a5222 3
  build_remote_packet_sizes ();

  /* Cisco stuff */
a5223 1
  remote_address_size = TARGET_PTR_BIT;
a5230 1
  struct cmd_list_element *tmpcmd;
a5234 3
  register_remote_packet_sizes ();
  register_gdbarch_swap (&remote_address_size, 
                         sizeof (&remote_address_size), NULL);
d5237 4
d5301 6
a5306 32
  /* Install commands for configuring memory read/write packets. */

  add_cmd ("remotewritesize", no_class, set_memory_write_packet_size,
	   "Set the maximum number of bytes per memory write packet (deprecated).\n",
	   &setlist);
  add_cmd ("remotewritesize", no_class, set_memory_write_packet_size,
	   "Show the maximum number of bytes per memory write packet (deprecated).\n",
	   &showlist);
  add_cmd ("memory-write-packet-size", no_class,
	   set_memory_write_packet_size,
	   "Set the maximum number of bytes per memory-write packet.\n"
	   "Specify the number of bytes in a packet or 0 (zero) for the\n"
	   "default packet size.  The actual limit is further reduced\n"
	   "dependent on the target.  Specify ``fixed'' to disable the\n"
	   "further restriction and ``limit'' to enable that restriction\n",
	   &remote_set_cmdlist);
  add_cmd ("memory-read-packet-size", no_class,
	   set_memory_read_packet_size,
	   "Set the maximum number of bytes per memory-read packet.\n"
	   "Specify the number of bytes in a packet or 0 (zero) for the\n"
	   "default packet size.  The actual limit is further reduced\n"
	   "dependent on the target.  Specify ``fixed'' to disable the\n"
	   "further restriction and ``limit'' to enable that restriction\n",
	   &remote_set_cmdlist);
  add_cmd ("memory-write-packet-size", no_class,
	   show_memory_write_packet_size,
	   "Show the maximum number of bytes per memory-write packet.\n",
	   &remote_show_cmdlist);
  add_cmd ("memory-read-packet-size", no_class,
	   show_memory_read_packet_size,
	   "Show the maximum number of bytes per memory-read packet.\n",
	   &remote_show_cmdlist);
d5308 1
@


1.1.1.27
log
@import gdb-1999-12-06 snapshot
@
text
@d115 1
a115 1
static void remote_send (char *buf, long sizeof_buf);
d142 1
a142 1
static long read_frame (char *buf, long sizeof_buf);
d500 3
a502 8
  /* Default maximum number of characters in a packet body. Many
     remote stubs have a hardwired buffer size of 400 bytes
     (c.f. BUFMAX in m68k-stub.c and i386-stub.c).  BUFMAX-1 is used
     as the maximum packet-size to ensure that the packet and an extra
     NUL character can always fit in the buffer.  This stops GDB
     trashing stubs that try to squeeze an extra NUL into what is
     already a full buffer (As of 1999-12-04 that was most stubs. */
  remote_packet_size = 400 - 1;
d785 1
a785 1
  getpkt (buf, PBUFSIZ, 0);
d805 1
a805 1
  getpkt (buf, sizeof (buf), 0);
d1345 1
a1345 1
  getpkt (threadinfo_pkt, PBUFSIZ, 0);
d1439 1
a1439 1
  getpkt (t_response, PBUFSIZ, 0);
d1552 1
a1552 1
  getpkt (buf, PBUFSIZ, 0);
d1581 1
a1581 2
  bufp = buf;
  getpkt (bufp, PBUFSIZ, 0);
d1598 1
a1598 2
	bufp = buf;
	getpkt (bufp, PBUFSIZ, 0);
d1619 1
a1619 1
  getpkt (buf, PBUFSIZ, 0);
d1647 1
a1647 1
  getpkt (buf, PBUFSIZ, 0);
d1731 8
a1738 6
remote_cisco_section_offsets (bfd_vma text_addr,
			      bfd_vma data_addr,
			      bfd_vma bss_addr,
			      bfd_signed_vma *text_offs,
			      bfd_signed_vma *data_offs,
			      bfd_signed_vma *bss_offs)
d1838 2
a1839 1
remote_start_remote_dummy (void *dummy)
d1992 1
a1992 1
      getpkt (buf, PBUFSIZ, 0);
d2091 1
a2091 1
      getpkt (buf, PBUFSIZ, 0);
d2112 1
a2112 1
  remote_send (buf, PBUFSIZ);
d2133 1
a2133 1
  remote_send (buf, PBUFSIZ);
d2493 1
a2493 1
      getpkt (buf, PBUFSIZ, 1);
d2715 1
a2715 1
      getpkt (buf, PBUFSIZ, wait_forever_enabled_p);
d2936 1
a2936 1
  remote_send (buf, PBUFSIZ);
d2957 1
a2957 1
      getpkt (buf, PBUFSIZ, 0);
d3024 2
a3025 1
store_register_using_P (int regno)
d3042 1
a3042 1
  remote_send (buf, PBUFSIZ);
d3104 1
a3104 1
  remote_send (buf, PBUFSIZ);
d3242 1
a3242 1
	getpkt (buf, PBUFSIZ, 0);
a3278 1
  long sizeof_buf;
d3288 1
a3288 2
  sizeof_buf = max_buf_size + 1; /* Space for trailing NUL */
  buf = alloca (sizeof_buf);
d3380 1
a3380 1
  getpkt (buf, sizeof_buf, 0);
a3419 1
  long sizeof_buf;
d3424 1
a3424 2
  sizeof_buf = max_buf_size + 1; /* Space for trailing NUL */
  buf = alloca (sizeof_buf);
d3446 1
a3446 1
      getpkt (buf, sizeof_buf, 0);
d3537 1
a3537 1
      getpkt (buf, PBUFSIZ, 0);
d3624 2
a3625 2
remote_send (char *buf,
	     long sizeof_buf)
d3628 1
a3628 1
  getpkt (buf, sizeof_buf, 0);
d3666 1
a3666 2
  long sizeof_junkbuf = PBUFSIZ;
  char *junkbuf = alloca (sizeof_junkbuf);
d3739 1
a3739 1
		getpkt (junkbuf, sizeof_junkbuf, 0);
d3776 1
a3776 2
   compression.  No more than sizeof_buf-1 characters are read so that
   the buffer can be NUL terminated.
d3778 3
a3780 7
   Returns -1 on error, number of characters in buffer (ignoring the
   trailing NULL) on success. (could be extended to return one of the
   SERIAL status indications). */

static long
read_frame (char *buf,
	    long sizeof_buf)
d3783 1
a3783 1
  long bc;
d3787 1
a3787 1
  bc = 0;
a3790 1
      /* ASSERT (bc < sizeof_buf - 1) - space for trailing NUL */
d3792 1
d3798 1
a3798 1
	  return -1;
d3803 1
a3803 1
	  return -1;		/* Start a new packet, count retries */
d3808 1
a3808 1
	    buf[bc] = '\0';
d3814 1
a3814 1
              return bc;
d3824 1
a3824 3
	    /* Number of characters in buffer ignoring trailing
               NUL. */
	    return -1;
a3849 2
	    /* The character before ``*'' is repeated. */

d3851 1
a3851 2
		&& bc > 0
                && bc + repeat < sizeof_buf - 1)
d3853 2
a3854 2
		memset (&buf[bc], buf[bc - 1], repeat);
		bc += repeat;
d3858 1
a3858 1
	    buf[bc] = '\0';
d3862 1
a3862 1
	    return -1;
d3865 1
a3865 1
	  if (bc < sizeof_buf - 1)
d3867 1
a3867 1
	      buf[bc++] = c;
d3872 1
a3872 1
	  buf[bc] = '\0';
d3877 1
a3877 1
	  return -1;
d3883 3
a3885 3
   store it in BUF.  If FOREVER, wait forever rather than timing out;
   this is used (in synchronous mode) to wait for a target that is is
   executing user code to stop.  */
d3888 3
a3890 3
getpkt (char *buf,
	long sizeof_buf,
	int forever)
d3940 1
a3940 1
      val = read_frame (buf, sizeof_buf);
d3942 1
a3942 1
      if (val >= 0)
d4174 1
a4174 1
      getpkt (buf, PBUFSIZ, 0);
d4239 1
a4239 1
      getpkt (buf, PBUFSIZ, 0);
d4271 1
a4271 1
  getpkt (buf, PBUFSIZ, 0);
d4294 1
a4294 1
  getpkt (buf, PBUFSIZ, 0);
d4322 1
a4322 1
  getpkt (buf, PBUFSIZ, 0);
d4347 1
a4347 1
  getpkt (buf, PBUFSIZ, 0);
d4484 1
a4484 1
      getpkt (buf, PBUFSIZ, 0);
d4578 1
a4578 1
  getpkt (outbuf, *bufsiz, 0);
d4621 1
a4621 1
      getpkt (buf, PBUFSIZ, 0);
d4663 1
a4663 1
  getpkt (buf, PBUFSIZ, 0);
d4903 3
a4905 1
remote_info_process (char *args, int from_tty)
d4913 1
a4913 1
  getpkt (buf, PBUFSIZ, 0);
d4924 1
a4924 1
      getpkt (buf, PBUFSIZ, 0);
d4933 3
a4935 1
remote_cisco_open (char *name, int from_tty)
d5015 2
a5016 1
remote_cisco_close (int quitting)
d5046 1
a5046 1
readsocket (void)
d5113 1
a5113 1
readtty (void)
d5153 1
a5153 1
minitelnet (void)
d5236 3
a5238 1
remote_cisco_wait (int pid, struct target_waitstatus *status)
d5332 1
a5332 1
init_remote_async_ops (void)
d5378 1
a5378 1
init_extended_async_remote_ops (void)
d5394 3
a5396 1
set_remote_cmd (char *args, int from_tty)
@


1.1.1.28
log
@import gdb-1999-12-13 snapshot
@
text
@d2889 1
a2889 4
	  /* Return immediately to the event loop. The event loop will
             still be waiting on the inferior afterwards. */
          status->kind = TARGET_WAITKIND_IGNORE;
          goto got_status;
@


1.1.1.29
log
@import gdb-1999-12-21 snapshot
@
text
@d2140 1
a2140 1
  if (target_is_async_p ())
d2257 1
a2257 1
  if (event_loop_p && target_can_async_p ())
d2264 1
a2264 1
  if (target_is_async_p ())
d2713 1
a2713 1
      if (!target_is_async_p ())
d2720 1
a2720 1
      if (!target_is_async_p ())
d4012 1
a4012 1
  if (target_is_async_p ())
d5300 1
a5300 1
  return (current_target.to_async_mask_value) && SERIAL_CAN_ASYNC_P (remote_desc);
d5307 1
a5307 1
  return (current_target.to_async_mask_value) && SERIAL_IS_ASYNC_P (remote_desc);
a5328 3
  if (current_target.to_async_mask_value == 0)
    internal_error ("Calling remote_async when async is masked");

a5384 1
  remote_async_ops.to_async_mask_value = 1;
@


1.1.1.30
log
@import gdb-2000-01-10 snapshot
@
text
@d1924 1
a1924 2
serial device is attached to the remote system\n\
(e.g. /dev/ttyS0, /dev/ttya, COM1, etc.).");
d2010 1
a2010 2
serial device is attached to the remote system\n\
(e.g. /dev/ttyS0, /dev/ttya, COM1, etc.).");
d4858 1
a4858 2
Specify the serial device it is connected to\n\
(e.g. /dev/ttyS0, /dev/ttya, COM1, etc.).";
@


1.1.1.31
log
@import gdb-2000-02-01 snapshot
@
text
@d2 2
a3 1
   Copyright 1988, 1991-2000 Free Software Foundation, Inc.
a58 1
static int getpkt_sane (char *buf, long sizeof_buf, int forever);
d3909 1
a3909 4
/* FIXME: ezannoni 2000-02-01 this wrapper is necessary so that we
   don't have to change all the calls to getpkt to deal with the
   return value, because at the moment I don't know what the right
   thing to do it for those. */
a3914 17
  int timed_out;

  timed_out = getpkt_sane (buf, sizeof_buf, forever);
}


/* Read a packet from the remote machine, with error checking, and
   store it in BUF.  If FOREVER, wait forever rather than timing out;
   this is used (in synchronous mode) to wait for a target that is is
   executing user code to stop. If FOREVER == 0, this function is
   allowed to time out gracefully and return an indication of this to
   the caller. */
int
getpkt_sane (char *buf,
	long sizeof_buf,
	int forever)
{
d3974 1
a3974 1
	  return 0;
a3985 1
  return 1;
d4608 1
a4608 1
	     struct ui_file *outbuf)
@


1.1.1.32
log
@import gdb-2000-02-02 snapshot
@
text
@a760 5
#ifdef UI_OUT
      ui_out_text (uiout, "[New ");
      ui_out_text (uiout, target_pid_to_str (currthread));
      ui_out_text (uiout, "]\n");
#else
a761 1
#endif
@


