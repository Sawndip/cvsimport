head	1.49;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.41
	gdb_7_6-2013-04-26-release:1.41
	gdb_7_6-branch:1.41.0.2
	gdb_7_6-2013-03-12-branchpoint:1.41
	gdb_7_5_1-2012-11-29-release:1.37
	gdb_7_5-2012-08-17-release:1.37
	gdb_7_5-branch:1.37.0.2
	gdb_7_5-2012-07-18-branchpoint:1.37
	gdb_7_4_1-2012-04-26-release:1.29.2.1
	gdb_7_4-2012-01-24-release:1.29.2.1
	gdb_7_4-branch:1.29.0.2
	gdb_7_4-2011-12-13-branchpoint:1.29
	gdb_7_3_1-2011-09-04-release:1.24
	gdb_7_3-2011-07-26-release:1.24
	gdb_7_3-branch:1.24.0.2
	gdb_7_3-2011-04-01-branchpoint:1.24
	gdb_7_2-2010-09-02-release:1.19
	gdb_7_2-branch:1.19.0.4
	gdb_7_2-2010-07-07-branchpoint:1.19
	gdb_7_1-2010-03-18-release:1.19
	gdb_7_1-branch:1.19.0.2
	gdb_7_1-2010-02-18-branchpoint:1.19
	gdb_7_0_1-2009-12-22-release:1.13.4.1
	gdb_7_0-2009-10-06-release:1.13.4.1
	gdb_7_0-branch:1.13.0.4
	gdb_7_0-2009-09-16-branchpoint:1.13
	msnyder-checkpoint-072509-branch:1.13.0.2
	msnyder-checkpoint-072509-branchpoint:1.13
	reverse-20081226-branch:1.1.0.2
	reverse-20081226-branchpoint:1.1;
locks; strict;
comment	@ * @;


1.49
date	2013.08.27.11.05.39;	author palves;	state Exp;
branches;
next	1.48;

1.48
date	2013.07.01.11.28.30;	author palves;	state Exp;
branches;
next	1.47;

1.47
date	2013.06.07.14.39.30;	author palves;	state Exp;
branches;
next	1.46;

1.46
date	2013.05.10.17.01.00;	author tromey;	state Exp;
branches;
next	1.45;

1.45
date	2013.05.06.12.41.14;	author brobecke;	state Exp;
branches;
next	1.44;

1.44
date	2013.05.06.12.37.52;	author brobecke;	state Exp;
branches;
next	1.43;

1.43
date	2013.05.06.12.35.46;	author brobecke;	state Exp;
branches;
next	1.42;

1.42
date	2013.05.01.14.54.18;	author brobecke;	state Exp;
branches;
next	1.41;

1.41
date	2013.01.07.11.14.37;	author brobecke;	state Exp;
branches;
next	1.40;

1.40
date	2013.01.02.21.06.30;	author vapier;	state Exp;
branches;
next	1.39;

1.39
date	2013.01.01.06.32.41;	author brobecke;	state Exp;
branches;
next	1.38;

1.38
date	2012.08.02.09.36.37;	author qiyao;	state Exp;
branches;
next	1.37;

1.37
date	2012.05.24.16.51.34;	author palves;	state Exp;
branches;
next	1.36;

1.36
date	2012.05.24.16.39.07;	author palves;	state Exp;
branches;
next	1.35;

1.35
date	2012.04.11.13.42.44;	author gingold;	state Exp;
branches;
next	1.34;

1.34
date	2012.04.11.13.17.05;	author gingold;	state Exp;
branches;
next	1.33;

1.33
date	2012.04.10.15.31.29;	author gingold;	state Exp;
branches;
next	1.32;

1.32
date	2012.04.02.11.57.30;	author gingold;	state Exp;
branches;
next	1.31;

1.31
date	2012.03.14.01.46.59;	author brobecke;	state Exp;
branches;
next	1.30;

1.30
date	2012.01.04.08.17.00;	author brobecke;	state Exp;
branches;
next	1.29;

1.29
date	2011.09.27.15.30.18;	author gingold;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2011.09.22.10.22.28;	author gingold;	state Exp;
branches;
next	1.27;

1.27
date	2011.08.01.14.07.09;	author gingold;	state Exp;
branches;
next	1.26;

1.26
date	2011.07.01.18.36.28;	author brobecke;	state Exp;
branches;
next	1.25;

1.25
date	2011.07.01.18.36.12;	author brobecke;	state Exp;
branches;
next	1.24;

1.24
date	2011.03.18.13.09.47;	author muller;	state Exp;
branches;
next	1.23;

1.23
date	2011.03.16.17.59.02;	author muller;	state Exp;
branches;
next	1.22;

1.22
date	2011.01.07.19.36.15;	author msnyder;	state Exp;
branches;
next	1.21;

1.21
date	2011.01.01.15.32.59;	author brobecke;	state Exp;
branches;
next	1.20;

1.20
date	2010.08.18.19.13.33;	author devans;	state Exp;
branches;
next	1.19;

1.19
date	2010.02.15.17.35.49;	author jkratoch;	state Exp;
branches;
next	1.18;

1.18
date	2010.02.04.12.45.49;	author gingold;	state Exp;
branches;
next	1.17;

1.17
date	2010.01.01.07.31.30;	author brobecke;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.20.11.23.28;	author palves;	state Exp;
branches;
next	1.15;

1.15
date	2009.10.19.09.51.40;	author palves;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.06.07.23.05;	author gingold;	state Exp;
branches;
next	1.13;

1.13
date	2009.06.22.08.24.29;	author gingold;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	2009.06.19.14.32.19;	author gingold;	state Exp;
branches;
next	1.11;

1.11
date	2009.06.19.14.30.30;	author gingold;	state Exp;
branches;
next	1.10;

1.10
date	2009.06.10.21.08.27;	author palves;	state Exp;
branches;
next	1.9;

1.9
date	2009.05.21.15.48.41;	author palves;	state Exp;
branches;
next	1.8;

1.8
date	2009.04.17.15.44.28;	author muller;	state Exp;
branches;
next	1.7;

1.7
date	2009.03.24.07.19.46;	author muller;	state Exp;
branches;
next	1.6;

1.6
date	2009.03.16.15.57.08;	author brobecke;	state Exp;
branches;
next	1.5;

1.5
date	2009.03.12.22.29.30;	author brobecke;	state Exp;
branches;
next	1.4;

1.4
date	2009.02.23.00.03.48;	author palves;	state Exp;
branches;
next	1.3;

1.3
date	2009.02.06.22.21.26;	author palves;	state Exp;
branches;
next	1.2;

1.2
date	2009.01.03.05.57.51;	author brobecke;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.27.09.23.01;	author gingold;	state Exp;
branches;
next	;

1.29.2.1
date	2012.01.06.04.43.06;	author brobecke;	state Exp;
branches;
next	;

1.13.4.1
date	2009.10.06.15.06.26;	author brobecke;	state Exp;
branches;
next	;


desc
@@


1.49
log
@darwin-nat.c: Don't install a deprecated_xfer_memory method.

darwin_xfer_partial already handles TARGET_OBJECT_MEMORY, so this
method is not necessary.

gdb/
2013-08-27  Pedro Alves  <palves@@redhat.com>

	* darwin-nat.c (darwin_xfer_memory): Delete.
	(_initialize_darwin_inferior): Don't install a
	deprecated_xfer_memory method.
@
text
@/* Darwin support for GDB, the GNU debugger.
   Copyright (C) 2008-2013 Free Software Foundation, Inc.

   Contributed by AdaCore.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "top.h"
#include "inferior.h"
#include "target.h"
#include "symfile.h"
#include "symtab.h"
#include "objfiles.h"
#include "gdb.h"
#include "gdbcmd.h"
#include "gdbcore.h"
#include "gdbthread.h"
#include "regcache.h"
#include "event-top.h"
#include "inf-loop.h"
#include "gdb_stat.h"
#include "exceptions.h"
#include "inf-child.h"
#include "value.h"
#include "arch-utils.h"
#include "bfd.h"
#include "bfd/mach-o.h"

#include <sys/ptrace.h>
#include <sys/signal.h>
#include <machine/setjmp.h>
#include <sys/types.h>
#include <unistd.h>
#include <signal.h>
#include <string.h>
#include <ctype.h>
#include <sys/sysctl.h>
#include <sys/proc.h>
#include <libproc.h>
#include <sys/syscall.h>
#include <spawn.h>

#include <mach/mach_error.h>
#include <mach/mach_vm.h>
#include <mach/mach_init.h>
#include <mach/vm_map.h>
#include <mach/task.h>
#include <mach/mach_port.h>
#include <mach/thread_act.h>
#include <mach/port.h>

#include "darwin-nat.h"
#include "common/filestuff.h"

/* Quick overview.
   Darwin kernel is Mach + BSD derived kernel.  Note that they share the
   same memory space and are linked together (ie there is no micro-kernel).

   Although ptrace(2) is available on Darwin, it is not complete.  We have
   to use Mach calls to read and write memory and to modify registers.  We
   also use Mach to get inferior faults.  As we cannot use select(2) or
   signals with Mach port (the Mach communication channel), signals are
   reported to gdb as an exception.  Furthermore we detect death of the
   inferior through a Mach notification message.  This way we only wait
   on Mach ports.

   Some Mach documentation is available for Apple xnu source package or
   from the web.  */


#define PTRACE(CMD, PID, ADDR, SIG) \
 darwin_ptrace(#CMD, CMD, (PID), (ADDR), (SIG))

extern boolean_t exc_server (mach_msg_header_t *in, mach_msg_header_t *out);

static void darwin_stop (ptid_t);

static void darwin_resume_to (struct target_ops *ops, ptid_t ptid, int step,
                              enum gdb_signal signal);
static void darwin_resume (ptid_t ptid, int step,
			   enum gdb_signal signal);

static ptid_t darwin_wait_to (struct target_ops *ops, ptid_t ptid,
                              struct target_waitstatus *status, int options);
static ptid_t darwin_wait (ptid_t ptid, struct target_waitstatus *status);

static void darwin_mourn_inferior (struct target_ops *ops);

static void darwin_kill_inferior (struct target_ops *ops);

static void darwin_ptrace_me (void);

static void darwin_ptrace_him (int pid);

static void darwin_create_inferior (struct target_ops *ops, char *exec_file,
				    char *allargs, char **env, int from_tty);

static void darwin_files_info (struct target_ops *ops);

static char *darwin_pid_to_str (struct target_ops *ops, ptid_t tpid);

static int darwin_thread_alive (struct target_ops *ops, ptid_t tpid);

/* Target operations for Darwin.  */
static struct target_ops *darwin_ops;

/* Task identifier of gdb.  */
static task_t gdb_task;

/* A copy of mach_host_self ().  */
mach_port_t darwin_host_self;

/* Exception port.  */
mach_port_t darwin_ex_port;

/* Port set.  */
mach_port_t darwin_port_set;

/* Page size.  */
static vm_size_t mach_page_size;

/* If Set, catch all mach exceptions (before they are converted to signals
   by the kernel).  */
static int enable_mach_exceptions;

/* Inferior that should report a fake stop event.  */
static struct inferior *darwin_inf_fake_stop;

#define PAGE_TRUNC(x) ((x) & ~(mach_page_size - 1))
#define PAGE_ROUND(x) PAGE_TRUNC((x) + mach_page_size - 1)

/* This controls output of inferior debugging.  */
static unsigned int darwin_debug_flag = 0;

/* Create a __TEXT __info_plist section in the executable so that gdb could
   be signed.  This is required to get an authorization for task_for_pid.

   Once gdb is built, you can either:
   * make it setgid procmod
   * or codesign it with any system-trusted signing authority.
   See taskgated(8) for details.  */
static const unsigned char info_plist[]
__attribute__ ((section ("__TEXT,__info_plist"),used)) =
  "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
  "<!DOCTYPE plist PUBLIC \"-//Apple Computer//DTD PLIST 1.0//EN\""
  " \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n"
  "<plist version=\"1.0\">\n"
  "<dict>\n"
  "  <key>CFBundleIdentifier</key>\n"
  "  <string>org.gnu.gdb</string>\n"
  "  <key>CFBundleName</key>\n"
  "  <string>gdb</string>\n"
  "  <key>CFBundleVersion</key>\n"
  "  <string>1.0</string>\n"
  "  <key>SecTaskAccess</key>\n"
  "  <array>\n"
  "    <string>allowed</string>\n"
  "    <string>debug</string>\n"
  "  </array>\n"
  "</dict>\n"
  "</plist>\n";

static void
inferior_debug (int level, const char *fmt, ...)
{
  va_list ap;

  if (darwin_debug_flag < level)
    return;

  va_start (ap, fmt);
  printf_unfiltered (_("[%d inferior]: "), getpid ());
  vprintf_unfiltered (fmt, ap);
  va_end (ap);
}

void
mach_check_error (kern_return_t ret, const char *file,
                  unsigned int line, const char *func)
{
  if (ret == KERN_SUCCESS)
    return;
  if (func == NULL)
    func = _("[UNKNOWN]");

  warning (_("Mach error at \"%s:%u\" in function \"%s\": %s (0x%lx)"),
	   file, line, func, mach_error_string (ret), (unsigned long) ret);
}

static const char *
unparse_exception_type (unsigned int i)
{
  static char unknown_exception_buf[32];

  switch (i)
    {
    case EXC_BAD_ACCESS:
      return "EXC_BAD_ACCESS";
    case EXC_BAD_INSTRUCTION:
      return "EXC_BAD_INSTRUCTION";
    case EXC_ARITHMETIC:
      return "EXC_ARITHMETIC";
    case EXC_EMULATION:
      return "EXC_EMULATION";
    case EXC_SOFTWARE:
      return "EXC_SOFTWARE";
    case EXC_BREAKPOINT:
      return "EXC_BREAKPOINT";
    case EXC_SYSCALL:
      return "EXC_SYSCALL";
    case EXC_MACH_SYSCALL:
      return "EXC_MACH_SYSCALL";
    case EXC_RPC_ALERT:
      return "EXC_RPC_ALERT";
    case EXC_CRASH:
      return "EXC_CRASH";
    default:
      snprintf (unknown_exception_buf, 32, _("unknown (%d)"), i);
      return unknown_exception_buf;
    }
}

/* Set errno to zero, and then call ptrace with the given arguments.
   If inferior debugging traces are on, then also print a debug
   trace.

   The returned value is the same as the value returned by ptrace,
   except in the case where that value is -1 but errno is zero.
   This case is documented to be a non-error situation, so we
   return zero in that case. */

static int
darwin_ptrace (const char *name,
	       int request, int pid, PTRACE_TYPE_ARG3 arg3, int arg4)
{
  int ret;

  errno = 0;
  ret = ptrace (request, pid, (caddr_t) arg3, arg4);
  if (ret == -1 && errno == 0)
    ret = 0;

  inferior_debug (4, _("ptrace (%s, %d, 0x%x, %d): %d (%s)\n"),
                  name, pid, arg3, arg4, ret,
                  (ret != 0) ? safe_strerror (errno) : _("no error"));
  return ret;
}

static int
cmp_thread_t (const void *l, const void *r)
{
  thread_t tl = *(const thread_t *)l;
  thread_t tr = *(const thread_t *)r;
  return (int)(tl - tr);
}

static void
darwin_check_new_threads (struct inferior *inf)
{
  kern_return_t kret;
  unsigned int i;
  thread_array_t thread_list;
  unsigned int new_nbr;
  unsigned int old_nbr;
  unsigned int new_ix, old_ix;
  darwin_inferior *darwin_inf = inf->private;
  VEC (darwin_thread_t) *thread_vec;

  /* Get list of threads.  */
  kret = task_threads (darwin_inf->task, &thread_list, &new_nbr);
  MACH_CHECK_ERROR (kret);
  if (kret != KERN_SUCCESS)
    return;

  /* Sort the list.  */
  if (new_nbr > 1)
    qsort (thread_list, new_nbr, sizeof (thread_t), cmp_thread_t);

  if (darwin_inf->threads)
    old_nbr = VEC_length (darwin_thread_t, darwin_inf->threads);
  else
    old_nbr = 0;

  /* Quick check for no changes.  */
  if (old_nbr == new_nbr)
    {
      for (i = 0; i < new_nbr; i++)
	if (thread_list[i]
	    != VEC_index (darwin_thread_t, darwin_inf->threads, i)->gdb_port)
	  break;
      if (i == new_nbr)
	{
	  kret = vm_deallocate (gdb_task, (vm_address_t) thread_list,
				new_nbr * sizeof (int));
	  MACH_CHECK_ERROR (kret);
	  return;
	}
    }

  thread_vec = VEC_alloc (darwin_thread_t, new_nbr);

  for (new_ix = 0, old_ix = 0; new_ix < new_nbr || old_ix < old_nbr;)
    {
      thread_t new_id = (new_ix < new_nbr) ?
	thread_list[new_ix] : THREAD_NULL;
      darwin_thread_t *old = (old_ix < old_nbr) ?
	VEC_index (darwin_thread_t, darwin_inf->threads, old_ix) : NULL;
      thread_t old_id = old ? old->gdb_port : THREAD_NULL;

      inferior_debug
	(12, _(" new_ix:%d/%d, old_ix:%d/%d, new_id:0x%x old_id:0x%x\n"),
	 new_ix, new_nbr, old_ix, old_nbr, new_id, old_id);

      if (old_id == new_id)
	{
	  /* Thread still exist.  */
	  VEC_safe_push (darwin_thread_t, thread_vec, old);
	  new_ix++;
	  old_ix++;

	  kret = mach_port_deallocate (gdb_task, old_id);
	  MACH_CHECK_ERROR (kret);
	  continue;
	}
      if (new_ix < new_nbr && new_id == MACH_PORT_DEAD)
	{
	  /* Ignore dead ports.
	     In some weird cases, we might get dead ports.  They should
	     correspond to dead thread so they could safely be ignored.  */
	  new_ix++;
	  continue;
	}
      if (new_ix < new_nbr && (old_ix == old_nbr || new_id < old_id))
	{
	  /* A thread was created.  */
	  struct thread_info *tp;
	  struct private_thread_info *pti;

	  pti = XZALLOC (struct private_thread_info);
	  pti->gdb_port = new_id;
	  pti->msg_state = DARWIN_RUNNING;

	  /* Add a new thread unless this is the first one ever met.  */
	  if (!(old_nbr == 0 && new_ix == 0))
	    tp = add_thread_with_info (ptid_build (inf->pid, 0, new_id), pti);
	  else
	    {
	      tp = find_thread_ptid (ptid_build (inf->pid, 0, 0));
	      gdb_assert (tp);
	      tp->private = pti;
	    }
	  VEC_safe_push (darwin_thread_t, thread_vec, pti);
	  new_ix++;
	  continue;
	}
      if (old_ix < old_nbr && (new_ix == new_nbr || new_id > old_id))
	{
	  /* A thread was removed.  */
	  delete_thread (ptid_build (inf->pid, 0, old_id));
	  kret = mach_port_deallocate (gdb_task, old_id);
	  MACH_CHECK_ERROR (kret);
	  old_ix++;
	  continue;
	}
      gdb_assert_not_reached ("unexpected thread case");
    }

  if (darwin_inf->threads)
    VEC_free (darwin_thread_t, darwin_inf->threads);
  darwin_inf->threads = thread_vec;

  kret = vm_deallocate (gdb_task, (vm_address_t) thread_list,
			new_nbr * sizeof (int));
  MACH_CHECK_ERROR (kret);
}

static int
find_inferior_task_it (struct inferior *inf, void *port_ptr)
{
  return inf->private->task == *(task_t*)port_ptr;
}

static int
find_inferior_notify_it (struct inferior *inf, void *port_ptr)
{
  return inf->private->notify_port == *(task_t*)port_ptr;
}

/* Return an inferior by task port.  */
static struct inferior *
darwin_find_inferior_by_task (task_t port)
{
  return iterate_over_inferiors (&find_inferior_task_it, &port);
}

/* Return an inferior by notification port.  */
static struct inferior *
darwin_find_inferior_by_notify (mach_port_t port)
{
  return iterate_over_inferiors (&find_inferior_notify_it, &port);
}

/* Return a thread by port.  */
static darwin_thread_t *
darwin_find_thread (struct inferior *inf, thread_t thread)
{
  darwin_thread_t *t;
  int k;

  for (k = 0;
       VEC_iterate (darwin_thread_t, inf->private->threads, k, t);
       k++)
    if (t->gdb_port == thread)
      return t;
  return NULL;
}

/* Suspend (ie stop) an inferior at Mach level.  */

static void
darwin_suspend_inferior (struct inferior *inf)
{
  if (!inf->private->suspended)
    {
      kern_return_t kret;

      kret = task_suspend (inf->private->task);
      MACH_CHECK_ERROR (kret);

      inf->private->suspended = 1;
    }
}

/* Resume an inferior at Mach level.  */

static void
darwin_resume_inferior (struct inferior *inf)
{
  if (inf->private->suspended)
    {
      kern_return_t kret;

      kret = task_resume (inf->private->task);
      MACH_CHECK_ERROR (kret);

      inf->private->suspended = 0;
    }
}

/* Iterator functions.  */

static int
darwin_suspend_inferior_it (struct inferior *inf, void *arg)
{
  darwin_suspend_inferior (inf);
  darwin_check_new_threads (inf);
  return 0;
}

static int
darwin_resume_inferior_it (struct inferior *inf, void *arg)
{
  darwin_resume_inferior (inf);
  return 0;
}

static void
darwin_dump_message (mach_msg_header_t *hdr, int disp_body)
{
  printf_unfiltered (_("message header:\n"));
  printf_unfiltered (_(" bits: 0x%x\n"), hdr->msgh_bits);
  printf_unfiltered (_(" size: 0x%x\n"), hdr->msgh_size);
  printf_unfiltered (_(" remote-port: 0x%x\n"), hdr->msgh_remote_port);
  printf_unfiltered (_(" local-port: 0x%x\n"), hdr->msgh_local_port);
  printf_unfiltered (_(" reserved: 0x%x\n"), hdr->msgh_reserved);
  printf_unfiltered (_(" id: 0x%x\n"), hdr->msgh_id);

  if (disp_body)
    {
      const unsigned char *data;
      const unsigned long *ldata;
      int size;
      int i;

      data = (unsigned char *)(hdr + 1);
      size = hdr->msgh_size - sizeof (mach_msg_header_t);

      if (hdr->msgh_bits & MACH_MSGH_BITS_COMPLEX)
	{
	  mach_msg_body_t *bod = (mach_msg_body_t*)data;
	  mach_msg_port_descriptor_t *desc =
	    (mach_msg_port_descriptor_t *)(bod + 1);
	  int k;
	  NDR_record_t *ndr;
	  printf_unfiltered (_("body: descriptor_count=%u\n"),
			     bod->msgh_descriptor_count);
	  data += sizeof (mach_msg_body_t);
	  size -= sizeof (mach_msg_body_t);
	  for (k = 0; k < bod->msgh_descriptor_count; k++)
	    switch (desc[k].type)
	      {
	      case MACH_MSG_PORT_DESCRIPTOR:
		printf_unfiltered
		  (_(" descr %d: type=%u (port) name=0x%x, dispo=%d\n"),
		   k, desc[k].type, desc[k].name, desc[k].disposition);
		break;
	      default:
		printf_unfiltered (_(" descr %d: type=%u\n"),
				   k, desc[k].type);
		break;
	      }
	  data += bod->msgh_descriptor_count
	    * sizeof (mach_msg_port_descriptor_t);
	  size -= bod->msgh_descriptor_count
	    * sizeof (mach_msg_port_descriptor_t);
	  ndr = (NDR_record_t *)(desc + bod->msgh_descriptor_count);
	  printf_unfiltered
	    (_("NDR: mig=%02x if=%02x encod=%02x "
	       "int=%02x char=%02x float=%02x\n"),
	     ndr->mig_vers, ndr->if_vers, ndr->mig_encoding,
	     ndr->int_rep, ndr->char_rep, ndr->float_rep);
	  data += sizeof (NDR_record_t);
	  size -= sizeof (NDR_record_t);
	}

      printf_unfiltered (_("  data:"));
      ldata = (const unsigned long *)data;
      for (i = 0; i < size / sizeof (unsigned long); i++)
	printf_unfiltered (" %08lx", ldata[i]);
      printf_unfiltered (_("\n"));
    }
}

static int
darwin_decode_exception_message (mach_msg_header_t *hdr,
				 struct inferior **pinf,
				 darwin_thread_t **pthread)
{
  mach_msg_body_t *bod = (mach_msg_body_t*)(hdr + 1);
  mach_msg_port_descriptor_t *desc = (mach_msg_port_descriptor_t *)(bod + 1);
  NDR_record_t *ndr;
  integer_t *data;
  struct inferior *inf;
  darwin_thread_t *thread;
  task_t task_port;
  thread_t thread_port;
  kern_return_t kret;
  int i;

  /* Check message identifier.  2401 is exc.  */
  if (hdr->msgh_id != 2401)
    return -1;

  /* Check message header.  */
  if (!(hdr->msgh_bits & MACH_MSGH_BITS_COMPLEX))
    return -1;

  /* Check descriptors.  */
  if (hdr->msgh_size < (sizeof (*hdr) + sizeof (*bod) + 2 * sizeof (*desc)
			+ sizeof (*ndr) + 2 * sizeof (integer_t))
      || bod->msgh_descriptor_count != 2
      || desc[0].type != MACH_MSG_PORT_DESCRIPTOR
      || desc[0].disposition != MACH_MSG_TYPE_MOVE_SEND
      || desc[1].type != MACH_MSG_PORT_DESCRIPTOR
      || desc[1].disposition != MACH_MSG_TYPE_MOVE_SEND)
    return -1;

  /* Check data representation.  */
  ndr = (NDR_record_t *)(desc + 2);
  if (ndr->mig_vers != NDR_PROTOCOL_2_0
      || ndr->if_vers != NDR_PROTOCOL_2_0
      || ndr->mig_encoding != NDR_record.mig_encoding
      || ndr->int_rep != NDR_record.int_rep
      || ndr->char_rep != NDR_record.char_rep
      || ndr->float_rep != NDR_record.float_rep)
    return -1;

  /* Ok, the hard work.  */
  data = (integer_t *)(ndr + 1);

  /* Find process by port.  */
  task_port = desc[1].name;
  thread_port = desc[0].name;
  inf = darwin_find_inferior_by_task (task_port);
  if (inf == NULL)
    return -1;
  *pinf = inf;

  /* Find thread by port.  */
  /* Check for new threads.  Do it early so that the port in the exception
     message can be deallocated.  */
  darwin_check_new_threads (inf);

  /* We got new rights to the task and the thread.  Get rid of them.  */
  kret = mach_port_deallocate (mach_task_self (), task_port);
  MACH_CHECK_ERROR (kret);
  kret = mach_port_deallocate (mach_task_self (), thread_port);
  MACH_CHECK_ERROR (kret);

  thread = darwin_find_thread (inf, thread_port);
  if (thread == NULL)
    return -1;
  *pthread = thread;

  /* The thread should be running.  However we have observed cases where a thread
     got a SIGTTIN message after being stopped.  */
  gdb_assert (thread->msg_state != DARWIN_MESSAGE);

  /* Finish decoding.  */
  thread->event.header = *hdr;
  thread->event.thread_port = thread_port;
  thread->event.task_port = task_port;
  thread->event.ex_type = data[0];
  thread->event.data_count = data[1];

  if (hdr->msgh_size < (sizeof (*hdr) + sizeof (*bod) + 2 * sizeof (*desc)
			+ sizeof (*ndr) + 2 * sizeof (integer_t)
			+ data[1] * sizeof (integer_t)))
      return -1;
  for (i = 0; i < data[1]; i++)
    thread->event.ex_data[i] = data[2 + i];

  thread->msg_state = DARWIN_MESSAGE;

  return 0;
}

static void
darwin_encode_reply (mig_reply_error_t *reply, mach_msg_header_t *hdr,
		     integer_t code)
{
  mach_msg_header_t *rh = &reply->Head;
  rh->msgh_bits = MACH_MSGH_BITS(MACH_MSGH_BITS_REMOTE(hdr->msgh_bits), 0);
  rh->msgh_remote_port = hdr->msgh_remote_port;
  rh->msgh_size = (mach_msg_size_t)sizeof(mig_reply_error_t);
  rh->msgh_local_port = MACH_PORT_NULL;
  rh->msgh_id = hdr->msgh_id + 100;

  reply->NDR = NDR_record;
  reply->RetCode = code;
}

static void
darwin_send_reply (struct inferior *inf, darwin_thread_t *thread)
{
  kern_return_t kret;
  mig_reply_error_t reply;

  darwin_encode_reply (&reply, &thread->event.header, KERN_SUCCESS);

  kret = mach_msg (&reply.Head, MACH_SEND_MSG | MACH_SEND_INTERRUPT,
		   reply.Head.msgh_size, 0,
		   MACH_PORT_NULL, MACH_MSG_TIMEOUT_NONE,
		   MACH_PORT_NULL);
  MACH_CHECK_ERROR (kret);

  inf->private->pending_messages--;
}

static void
darwin_resume_thread (struct inferior *inf, darwin_thread_t *thread,
		      int step, int nsignal)
{
  kern_return_t kret;
  int res;

  inferior_debug
    (3, _("darwin_resume_thread: state=%d, thread=0x%x, step=%d nsignal=%d\n"),
     thread->msg_state, thread->gdb_port, step, nsignal);

  switch (thread->msg_state)
    {
    case DARWIN_MESSAGE:
      if (thread->event.ex_type == EXC_SOFTWARE
	  && thread->event.ex_data[0] == EXC_SOFT_SIGNAL)
	{
	  /* Either deliver a new signal or cancel the signal received.  */
	  res = PTRACE (PT_THUPDATE, inf->pid,
			(void *)(uintptr_t)thread->gdb_port, nsignal);
	  if (res < 0)
	    inferior_debug (1, _("ptrace THUP: res=%d\n"), res);
	}
      else if (nsignal)
	{
	  /* Note: ptrace is allowed only if the process is stopped.
	     Directly send the signal to the thread.  */
	  res = syscall (SYS___pthread_kill, thread->gdb_port, nsignal);
	  inferior_debug (4, _("darwin_resume_thread: kill 0x%x %d: %d\n"),
			  thread->gdb_port, nsignal, res);
	  thread->signaled = 1;
	}

      /* Set or reset single step.  */
      if (step != thread->single_step)
	{
	  inferior_debug (4, _("darwin_set_sstep (thread=0x%x, enable=%d)\n"),
			  thread->gdb_port, step);
	  darwin_set_sstep (thread->gdb_port, step);
	  thread->single_step = step;
	}

      darwin_send_reply (inf, thread);
      thread->msg_state = DARWIN_RUNNING;
      break;

    case DARWIN_RUNNING:
      break;

    case DARWIN_STOPPED:
      kret = thread_resume (thread->gdb_port);
      MACH_CHECK_ERROR (kret);

      thread->msg_state = DARWIN_RUNNING;
      break;
    }
}

/* Resume all threads of the inferior.  */

static void
darwin_resume_inferior_threads (struct inferior *inf, int step, int nsignal)
{
  darwin_thread_t *thread;
  int k;

  for (k = 0;
       VEC_iterate (darwin_thread_t, inf->private->threads, k, thread);
       k++)
    darwin_resume_thread (inf, thread, step, nsignal);
}

struct resume_inferior_threads_param
{
  int step;
  int nsignal;
};

static int
darwin_resume_inferior_threads_it (struct inferior *inf, void *param)
{
  int step = ((struct resume_inferior_threads_param *)param)->step;
  int nsignal = ((struct resume_inferior_threads_param *)param)->nsignal;

  darwin_resume_inferior_threads (inf, step, nsignal);

  return 0;
}

/* Suspend all threads of INF.  */

static void
darwin_suspend_inferior_threads (struct inferior *inf)
{
  darwin_thread_t *thread;
  kern_return_t kret;
  int k;

  for (k = 0;
       VEC_iterate (darwin_thread_t, inf->private->threads, k, thread);
       k++)
    switch (thread->msg_state)
      {
      case DARWIN_STOPPED:
      case DARWIN_MESSAGE:
	break;
      case DARWIN_RUNNING:
	kret = thread_suspend (thread->gdb_port);
	MACH_CHECK_ERROR (kret);
	thread->msg_state = DARWIN_STOPPED;
	break;
      }
}

static void
darwin_resume (ptid_t ptid, int step, enum gdb_signal signal)
{
  struct target_waitstatus status;
  int pid;

  kern_return_t kret;
  int res;
  int nsignal;
  struct inferior *inf;

  inferior_debug
    (2, _("darwin_resume: pid=%d, tid=0x%x, step=%d, signal=%d\n"),
     ptid_get_pid (ptid), ptid_get_tid (ptid), step, signal);

  if (signal == GDB_SIGNAL_0)
    nsignal = 0;
  else
    nsignal = gdb_signal_to_host (signal);

  /* Don't try to single step all threads.  */
  if (step)
    ptid = inferior_ptid;

  /* minus_one_ptid is RESUME_ALL.  */
  if (ptid_equal (ptid, minus_one_ptid))
    {
      struct resume_inferior_threads_param param;

      param.nsignal = nsignal;
      param.step = step;

      /* Resume threads.  */
      iterate_over_inferiors (darwin_resume_inferior_threads_it, &param);
      /* Resume tasks.  */
      iterate_over_inferiors (darwin_resume_inferior_it, NULL);
    }
  else
    {
      struct inferior *inf = find_inferior_pid (ptid_get_pid (ptid));
      long tid = ptid_get_tid (ptid);

      /* Stop the inferior (should be useless).  */
      darwin_suspend_inferior (inf);

      if (tid == 0)
        darwin_resume_inferior_threads (inf, step, nsignal);
      else
        {
          darwin_thread_t *thread;

          /* Suspend threads of the task.  */
          darwin_suspend_inferior_threads (inf);

          /* Resume the selected thread.  */
          thread = darwin_find_thread (inf, tid);
          gdb_assert (thread);
          darwin_resume_thread (inf, thread, step, nsignal);
        }

      /* Resume the task.  */
      darwin_resume_inferior (inf);
    }
}

static void
darwin_resume_to (struct target_ops *ops, ptid_t ptid, int step,
                  enum gdb_signal signal)
{
  return darwin_resume (ptid, step, signal);
}

static ptid_t
darwin_decode_message (mach_msg_header_t *hdr,
		       darwin_thread_t **pthread,
		       struct inferior **pinf,
		       struct target_waitstatus *status)
{
  darwin_thread_t *thread;
  struct inferior *inf;

  /* Exception message.  */
  if (hdr->msgh_local_port == darwin_ex_port)
    {
      int res;

      /* Decode message.  */
      res = darwin_decode_exception_message (hdr, &inf, &thread);

      if (res < 0)
	{
	  /* Should not happen...  */
	  printf_unfiltered
	    (_("darwin_wait: ill-formatted message (id=0x%x)\n"), hdr->msgh_id);
	  /* FIXME: send a failure reply?  */
	  status->kind = TARGET_WAITKIND_SPURIOUS;
	  return minus_one_ptid;
	}
      *pinf = inf;
      *pthread = thread;
      inf->private->pending_messages++;

      status->kind = TARGET_WAITKIND_STOPPED;
      thread->msg_state = DARWIN_MESSAGE;

      inferior_debug (4, _("darwin_wait: thread=0x%x, got %s\n"),
		      thread->gdb_port,
		      unparse_exception_type (thread->event.ex_type));

      switch (thread->event.ex_type)
	{
	case EXC_BAD_ACCESS:
	  status->value.sig = TARGET_EXC_BAD_ACCESS;
	  break;
	case EXC_BAD_INSTRUCTION:
	  status->value.sig = TARGET_EXC_BAD_INSTRUCTION;
	  break;
	case EXC_ARITHMETIC:
	  status->value.sig = TARGET_EXC_ARITHMETIC;
	  break;
	case EXC_EMULATION:
	  status->value.sig = TARGET_EXC_EMULATION;
	  break;
	case EXC_SOFTWARE:
	  if (thread->event.ex_data[0] == EXC_SOFT_SIGNAL)
	    {
	      status->value.sig =
		gdb_signal_from_host (thread->event.ex_data[1]);
	      inferior_debug (5, _("  (signal %d: %s)\n"),
			      thread->event.ex_data[1],
			      gdb_signal_to_name (status->value.sig));

	      /* If the thread is stopped because it has received a signal
		 that gdb has just sent, continue.  */
	      if (thread->signaled)
		{
		  thread->signaled = 0;
		  darwin_send_reply (inf, thread);
		  thread->msg_state = DARWIN_RUNNING;
		  status->kind = TARGET_WAITKIND_IGNORE;
		}
	    }
	  else
	    status->value.sig = TARGET_EXC_SOFTWARE;
	  break;
	case EXC_BREAKPOINT:
	  /* Many internal GDB routines expect breakpoints to be reported
	     as GDB_SIGNAL_TRAP, and will report TARGET_EXC_BREAKPOINT
	     as a spurious signal.  */
	  status->value.sig = GDB_SIGNAL_TRAP;
	  break;
	default:
	  status->value.sig = GDB_SIGNAL_UNKNOWN;
	  break;
	}

      return ptid_build (inf->pid, 0, thread->gdb_port);
    }

  *pinf = NULL;
  *pthread = NULL;

  inf = darwin_find_inferior_by_notify (hdr->msgh_local_port);
  if (inf != NULL)
    {
      if (!inf->private->no_ptrace)
	{
	  pid_t res;
	  int wstatus;

	  res = wait4 (inf->pid, &wstatus, 0, NULL);
	  if (res < 0 || res != inf->pid)
	    {
	      printf_unfiltered (_("wait4: res=%d: %s\n"),
				 res, safe_strerror (errno));
	      status->kind = TARGET_WAITKIND_SPURIOUS;
	      return minus_one_ptid;
	    }
	  if (WIFEXITED (wstatus))
	    {
	      status->kind = TARGET_WAITKIND_EXITED;
	      status->value.integer = WEXITSTATUS (wstatus);
	    }
	  else
	    {
	      status->kind = TARGET_WAITKIND_SIGNALLED;
	      status->value.sig = WTERMSIG (wstatus);
	    }

	  inferior_debug (4, _("darwin_wait: pid=%d exit, status=0x%x\n"),
			  res, wstatus);

	  /* Looks necessary on Leopard and harmless...  */
	  wait4 (inf->pid, &wstatus, 0, NULL);

	  return ptid_build (inf->pid, 0, 0);
	}
      else
	{
	  inferior_debug (4, _("darwin_wait: pid=%d\n"), inf->pid);
	  status->kind = TARGET_WAITKIND_EXITED;
	  status->value.integer = 0; /* Don't know.  */
	  return ptid_build (inf->pid, 0, 0);
	}
    }

  printf_unfiltered (_("Bad local-port: 0x%x\n"), hdr->msgh_local_port);
  status->kind = TARGET_WAITKIND_SPURIOUS;
  return minus_one_ptid;
}

static int
cancel_breakpoint (ptid_t ptid)
{
  /* Arrange for a breakpoint to be hit again later.  We will handle
     the current event, eventually we will resume this thread, and this
     breakpoint will trap again.

     If we do not do this, then we run the risk that the user will
     delete or disable the breakpoint, but the thread will have already
     tripped on it.  */

  struct regcache *regcache = get_thread_regcache (ptid);
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  CORE_ADDR pc;

  pc = regcache_read_pc (regcache) - gdbarch_decr_pc_after_break (gdbarch);
  if (breakpoint_inserted_here_p (get_regcache_aspace (regcache), pc))
    {
      inferior_debug (4, "cancel_breakpoint for thread 0x%x\n",
		      ptid_get_tid (ptid));

      /* Back up the PC if necessary.  */
      if (gdbarch_decr_pc_after_break (gdbarch))
	regcache_write_pc (regcache, pc);

      return 1;
    }
  return 0;
}

static ptid_t
darwin_wait (ptid_t ptid, struct target_waitstatus *status)
{
  kern_return_t kret;
  union
  {
    mach_msg_header_t hdr;
    char data[0x100];
  } msgin;
  mach_msg_header_t *hdr = &msgin.hdr;
  ptid_t res;
  darwin_thread_t *thread;
  struct inferior *inf;

  inferior_debug
    (2, _("darwin_wait: waiting for a message pid=%d thread=%lx\n"),
     ptid_get_pid (ptid), ptid_get_tid (ptid));

  /* Handle fake stop events at first.  */
  if (darwin_inf_fake_stop != NULL)
    {
      inf = darwin_inf_fake_stop;
      darwin_inf_fake_stop = NULL;

      status->kind = TARGET_WAITKIND_STOPPED;
      status->value.sig = GDB_SIGNAL_TRAP;
      thread = VEC_index (darwin_thread_t, inf->private->threads, 0);
      thread->msg_state = DARWIN_STOPPED;
      return ptid_build (inf->pid, 0, thread->gdb_port);
    }

  do
    {
      /* set_sigint_trap (); */

      /* Wait for a message.  */
      kret = mach_msg (&msgin.hdr, MACH_RCV_MSG | MACH_RCV_INTERRUPT, 0,
		       sizeof (msgin.data), darwin_port_set, 0, MACH_PORT_NULL);

      /* clear_sigint_trap (); */

      if (kret == MACH_RCV_INTERRUPTED)
	{
	  status->kind = TARGET_WAITKIND_IGNORE;
	  return minus_one_ptid;
	}

      if (kret != MACH_MSG_SUCCESS)
	{
	  inferior_debug (5, _("mach_msg: ret=0x%x\n"), kret);
	  status->kind = TARGET_WAITKIND_SPURIOUS;
	  return minus_one_ptid;
	}

      /* Debug: display message.  */
      if (darwin_debug_flag > 10)
	darwin_dump_message (hdr, darwin_debug_flag > 11);

      res = darwin_decode_message (hdr, &thread, &inf, status);

      if (inf == NULL)
	return res;
    }
  while (status->kind == TARGET_WAITKIND_IGNORE);

  /* Stop all tasks.  */
  iterate_over_inferiors (darwin_suspend_inferior_it, NULL);

  /* Read pending messages.  */
  while (1)
    {
      struct target_waitstatus status2;
      ptid_t ptid2;

      kret = mach_msg (&msgin.hdr,
		       MACH_RCV_MSG | MACH_RCV_TIMEOUT, 0,
		       sizeof (msgin.data), darwin_port_set, 1, MACH_PORT_NULL);

      if (kret == MACH_RCV_TIMED_OUT)
	break;
      if (kret != MACH_MSG_SUCCESS)
	{
	  inferior_debug
	    (5, _("darwin_wait: mach_msg(pending) ret=0x%x\n"), kret);
	  break;
	}

      ptid2 = darwin_decode_message (hdr, &thread, &inf, &status2);

      if (inf != NULL && thread != NULL
	  && thread->event.ex_type == EXC_BREAKPOINT)
	{
	  if (thread->single_step
	      || cancel_breakpoint (ptid_build (inf->pid, 0, thread->gdb_port)))
	    {
	      gdb_assert (thread->msg_state == DARWIN_MESSAGE);
	      darwin_send_reply (inf, thread);
	      thread->msg_state = DARWIN_RUNNING;
	    }
	  else
	    inferior_debug
	      (3, _("darwin_wait: thread 0x%x hit a non-gdb breakpoint\n"),
	       thread->gdb_port);
	}
      else
	inferior_debug (3, _("darwin_wait: unhandled pending message\n"));
    }
  return res;
}

static ptid_t
darwin_wait_to (struct target_ops *ops, 
                ptid_t ptid, struct target_waitstatus *status, int options)
{
  return darwin_wait (ptid, status);
}

static void
darwin_stop (ptid_t t)
{
  struct inferior *inf = current_inferior ();

  /* FIXME: handle in no_ptrace mode.  */
  gdb_assert (!inf->private->no_ptrace);
  kill (inf->pid, SIGINT);
}

static void
darwin_mourn_inferior (struct target_ops *ops)
{
  struct inferior *inf = current_inferior ();
  kern_return_t kret;
  mach_port_t prev;
  int i;

  unpush_target (darwin_ops);

  /* Deallocate threads.  */
  if (inf->private->threads)
    {
      int k;
      darwin_thread_t *t;
      for (k = 0;
	   VEC_iterate (darwin_thread_t, inf->private->threads, k, t);
	   k++)
	{
	  kret = mach_port_deallocate (gdb_task, t->gdb_port);
	  MACH_CHECK_ERROR (kret);
	}
      VEC_free (darwin_thread_t, inf->private->threads);
      inf->private->threads = NULL;
    }

  kret = mach_port_move_member (gdb_task,
				inf->private->notify_port, MACH_PORT_NULL);
  MACH_CHECK_ERROR (kret);

  kret = mach_port_request_notification (gdb_task, inf->private->task,
					 MACH_NOTIFY_DEAD_NAME, 0,
					 MACH_PORT_NULL,
					 MACH_MSG_TYPE_MAKE_SEND_ONCE,
					 &prev);
  /* This can fail if the task is dead.  */
  inferior_debug (4, "task=0x%x, prev=0x%x, notify_port=0x%x\n",
		  inf->private->task, prev, inf->private->notify_port);

  if (kret == KERN_SUCCESS)
    {
      kret = mach_port_deallocate (gdb_task, prev);
      MACH_CHECK_ERROR (kret);
    }

  kret = mach_port_destroy (gdb_task, inf->private->notify_port);
  MACH_CHECK_ERROR (kret);


  /* Deallocate saved exception ports.  */
  for (i = 0; i < inf->private->exception_info.count; i++)
    {
      kret = mach_port_deallocate
	(gdb_task, inf->private->exception_info.ports[i]);
      MACH_CHECK_ERROR (kret);
    }
  inf->private->exception_info.count = 0;

  kret = mach_port_deallocate (gdb_task, inf->private->task);
  MACH_CHECK_ERROR (kret);

  xfree (inf->private);
  inf->private = NULL;

  generic_mourn_inferior ();
}

static void
darwin_reply_to_all_pending_messages (struct inferior *inf)
{
  int k;
  darwin_thread_t *t;

  for (k = 0;
       VEC_iterate (darwin_thread_t, inf->private->threads, k, t);
       k++)
    {
      if (t->msg_state == DARWIN_MESSAGE)
	darwin_resume_thread (inf, t, 0, 0);
    }
}

static void
darwin_stop_inferior (struct inferior *inf)
{
  struct target_waitstatus wstatus;
  ptid_t ptid;
  kern_return_t kret;
  int status;
  int res;

  gdb_assert (inf != NULL);

  darwin_suspend_inferior (inf);

  darwin_reply_to_all_pending_messages (inf);

  if (inf->private->no_ptrace)
    return;

  res = kill (inf->pid, SIGSTOP);
  if (res != 0)
    warning (_("cannot kill: %s"), safe_strerror (errno));

  /* Wait until the process is really stopped.  */
  while (1)
    {
      ptid = darwin_wait (inferior_ptid, &wstatus);
      if (wstatus.kind == TARGET_WAITKIND_STOPPED
	  && wstatus.value.sig == GDB_SIGNAL_STOP)
	break;
    }
}

static kern_return_t
darwin_save_exception_ports (darwin_inferior *inf)
{
  kern_return_t kret;

  inf->exception_info.count =
    sizeof (inf->exception_info.ports) / sizeof (inf->exception_info.ports[0]);

  kret = task_get_exception_ports
    (inf->task, EXC_MASK_ALL, inf->exception_info.masks,
     &inf->exception_info.count, inf->exception_info.ports,
     inf->exception_info.behaviors, inf->exception_info.flavors);
  return kret;
}

static kern_return_t
darwin_restore_exception_ports (darwin_inferior *inf)
{
  int i;
  kern_return_t kret;

  for (i = 0; i < inf->exception_info.count; i++)
    {
      kret = task_set_exception_ports
        (inf->task, inf->exception_info.masks[i], inf->exception_info.ports[i],
	 inf->exception_info.behaviors[i], inf->exception_info.flavors[i]);
      if (kret != KERN_SUCCESS)
        return kret;
    }

  return KERN_SUCCESS;
}

static void
darwin_kill_inferior (struct target_ops *ops)
{
  struct inferior *inf = current_inferior ();
  struct target_waitstatus wstatus;
  ptid_t ptid;
  kern_return_t kret;
  int status;
  int res;

  if (ptid_equal (inferior_ptid, null_ptid))
    return;

  gdb_assert (inf != NULL);

  kret = darwin_restore_exception_ports (inf->private);
  MACH_CHECK_ERROR (kret);

  darwin_reply_to_all_pending_messages (inf);

  res = kill (inf->pid, 9);

  if (res == 0)
    {
      darwin_resume_inferior (inf);
	  
      ptid = darwin_wait (inferior_ptid, &wstatus);
    }
  else if (errno != ESRCH)
    warning (_("Failed to kill inferior: kill (%d, 9) returned [%s]"),
	     inf->pid, safe_strerror (errno));

  target_mourn_inferior ();
}

static void
darwin_attach_pid (struct inferior *inf)
{
  kern_return_t kret;
  mach_port_t prev_port;
  int traps_expected;
  mach_port_t prev_not;
  exception_mask_t mask;

  inf->private = XZALLOC (darwin_inferior);

  kret = task_for_pid (gdb_task, inf->pid, &inf->private->task);
  if (kret != KERN_SUCCESS)
    {
      int status;

      if (!inf->attach_flag)
	{
	  kill (inf->pid, 9);
	  waitpid (inf->pid, &status, 0);
	}

      error (_("Unable to find Mach task port for process-id %d: %s (0x%lx).\n"
	       " (please check gdb is codesigned - see taskgated(8))"),
             inf->pid, mach_error_string (kret), (unsigned long) kret);
    }

  inferior_debug (2, _("inferior task: 0x%x, pid: %d\n"),
		  inf->private->task, inf->pid);

  if (darwin_ex_port == MACH_PORT_NULL)
    {
      /* Create a port to get exceptions.  */
      kret = mach_port_allocate (gdb_task, MACH_PORT_RIGHT_RECEIVE,
				 &darwin_ex_port);
      if (kret != KERN_SUCCESS)
	error (_("Unable to create exception port, mach_port_allocate "
		 "returned: %d"),
	       kret);

      kret = mach_port_insert_right (gdb_task, darwin_ex_port, darwin_ex_port,
				     MACH_MSG_TYPE_MAKE_SEND);
      if (kret != KERN_SUCCESS)
	error (_("Unable to create exception port, mach_port_insert_right "
		 "returned: %d"),
	       kret);

      /* Create a port set and put ex_port in it.  */
      kret = mach_port_allocate (gdb_task, MACH_PORT_RIGHT_PORT_SET,
				 &darwin_port_set);
      if (kret != KERN_SUCCESS)
	error (_("Unable to create port set, mach_port_allocate "
		 "returned: %d"),
	       kret);

      kret = mach_port_move_member (gdb_task, darwin_ex_port, darwin_port_set);
      if (kret != KERN_SUCCESS)
	error (_("Unable to move exception port into new port set, "
		 "mach_port_move_member\n"
		 "returned: %d"),
	       kret);
    }

  /* Create a port to be notified when the child task terminates.  */
  kret = mach_port_allocate (gdb_task, MACH_PORT_RIGHT_RECEIVE,
			     &inf->private->notify_port);
  if (kret != KERN_SUCCESS)
    error (_("Unable to create notification port, mach_port_allocate "
	     "returned: %d"),
	   kret);

  kret = mach_port_move_member (gdb_task,
				inf->private->notify_port, darwin_port_set);
  if (kret != KERN_SUCCESS)
    error (_("Unable to move notification port into new port set, "
	     "mach_port_move_member\n"
	     "returned: %d"),
	   kret);

  kret = mach_port_request_notification (gdb_task, inf->private->task,
					 MACH_NOTIFY_DEAD_NAME, 0,
					 inf->private->notify_port,
					 MACH_MSG_TYPE_MAKE_SEND_ONCE,
					 &prev_not);
  if (kret != KERN_SUCCESS)
    error (_("Termination notification request failed, "
	     "mach_port_request_notification\n"
	     "returned: %d"),
	   kret);
  if (prev_not != MACH_PORT_NULL)
    {
      /* This is unexpected, as there should not be any previously
	 registered notification request.  But this is not a fatal
	 issue, so just emit a warning.  */
      warning (_("\
A task termination request was registered before the debugger registered\n\
its own.  This is unexpected, but should otherwise not have any actual\n\
impact on the debugging session."));
    }

  kret = darwin_save_exception_ports (inf->private);
  if (kret != KERN_SUCCESS)
    error (_("Unable to save exception ports, task_get_exception_ports"
	     "returned: %d"),
	   kret);

  /* Set exception port.  */
  if (enable_mach_exceptions)
    mask = EXC_MASK_ALL;
  else
    mask = EXC_MASK_SOFTWARE | EXC_MASK_BREAKPOINT;
  kret = task_set_exception_ports (inf->private->task, mask, darwin_ex_port,
				   EXCEPTION_DEFAULT, THREAD_STATE_NONE);
  if (kret != KERN_SUCCESS)
    error (_("Unable to set exception ports, task_set_exception_ports"
	     "returned: %d"),
	   kret);

  push_target (darwin_ops);
}

static void
darwin_init_thread_list (struct inferior *inf)
{
  darwin_thread_t *thread;
  ptid_t new_ptid;

  darwin_check_new_threads (inf);

  gdb_assert (inf->private->threads
	      && VEC_length (darwin_thread_t, inf->private->threads) > 0);
  thread = VEC_index (darwin_thread_t, inf->private->threads, 0);

  /* Note: fork_inferior automatically add a thead but it uses a wrong ptid.
     Fix up.  */
  new_ptid = ptid_build (inf->pid, 0, thread->gdb_port);
  thread_change_ptid (inferior_ptid, new_ptid);
  inferior_ptid = new_ptid;
}

/* The child must synchronize with gdb: gdb must set the exception port
   before the child call PTRACE_SIGEXC.  We use a pipe to achieve this.
   FIXME: is there a lighter way ?  */
static int ptrace_fds[2];

static void
darwin_ptrace_me (void)
{
  int res;
  char c;

  /* Close write end point.  */
  close (ptrace_fds[1]);

  /* Wait until gdb is ready.  */
  res = read (ptrace_fds[0], &c, 1);
  if (res != 0)
    error (_("unable to read from pipe, read returned: %d"), res);
  close (ptrace_fds[0]);

  /* Get rid of privileges.  */
  setegid (getgid ());

  /* Set TRACEME.  */
  PTRACE (PT_TRACE_ME, 0, 0, 0);

  /* Redirect signals to exception port.  */
  PTRACE (PT_SIGEXC, 0, 0, 0);
}

/* Dummy function to be sure fork_inferior uses fork(2) and not vfork(2).  */
static void
darwin_pre_ptrace (void)
{
  if (pipe (ptrace_fds) != 0)
    {
      ptrace_fds[0] = -1;
      ptrace_fds[1] = -1;
      error (_("unable to create a pipe: %s"), safe_strerror (errno));
    }

  mark_fd_no_cloexec (ptrace_fds[0]);
  mark_fd_no_cloexec (ptrace_fds[1]);
}

static void
darwin_ptrace_him (int pid)
{
  task_t itask;
  kern_return_t kret;
  mach_port_t prev_port;
  int traps_expected;
  struct inferior *inf = current_inferior ();

  darwin_attach_pid (inf);

  /* Let's the child run.  */
  close (ptrace_fds[0]);
  close (ptrace_fds[1]);

  unmark_fd_no_cloexec (ptrace_fds[0]);
  unmark_fd_no_cloexec (ptrace_fds[1]);

  darwin_init_thread_list (inf);

  startup_inferior (START_INFERIOR_TRAPS_EXPECTED);
}

static void
darwin_execvp (const char *file, char * const argv[], char * const env[])
{
  posix_spawnattr_t attr;
  short ps_flags = 0;
  int res;

  res = posix_spawnattr_init (&attr);
  if (res != 0)
    {
      fprintf_unfiltered
        (gdb_stderr, "Cannot initialize attribute for posix_spawn\n");
      return;
    }

  /* Do like execve: replace the image.  */
  ps_flags = POSIX_SPAWN_SETEXEC;

  /* Disable ASLR.  The constant doesn't look to be available outside the
     kernel include files.  */
#ifndef _POSIX_SPAWN_DISABLE_ASLR
#define _POSIX_SPAWN_DISABLE_ASLR 0x0100
#endif
  ps_flags |= _POSIX_SPAWN_DISABLE_ASLR;
  res = posix_spawnattr_setflags (&attr, ps_flags);
  if (res != 0)
    {
      fprintf_unfiltered (gdb_stderr, "Cannot set posix_spawn flags\n");
      return;
    }

  posix_spawnp (NULL, argv[0], NULL, &attr, argv, env);
}

static void
darwin_create_inferior (struct target_ops *ops, char *exec_file,
			char *allargs, char **env, int from_tty)
{
  /* Do the hard work.  */
  fork_inferior (exec_file, allargs, env, darwin_ptrace_me, darwin_ptrace_him,
		 darwin_pre_ptrace, NULL, darwin_execvp);

  /* Return now in case of error.  */
  if (ptid_equal (inferior_ptid, null_ptid))
    return;
}


/* Set things up such that the next call to darwin_wait will immediately
   return a fake stop event for inferior INF.

   This assumes that the inferior's thread list has been initialized,
   as it will suspend the inferior's first thread.  */

static void
darwin_setup_fake_stop_event (struct inferior *inf)
{
  darwin_thread_t *thread;
  kern_return_t kret;

  gdb_assert (darwin_inf_fake_stop == NULL);
  darwin_inf_fake_stop = inf;

  /* When detecting a fake pending stop event, darwin_wait returns
     an event saying that the first thread is in a DARWIN_STOPPED
     state.  To make that accurate, we need to suspend that thread
     as well.  Otherwise, we'll try resuming it when resuming the
     inferior, and get a warning because the thread's suspend count
     is already zero, making the resume request useless.  */
  thread = VEC_index (darwin_thread_t, inf->private->threads, 0);
  kret = thread_suspend (thread->gdb_port);
  MACH_CHECK_ERROR (kret);
}

/* Attach to process PID, then initialize for debugging it
   and wait for the trace-trap that results from attaching.  */
static void
darwin_attach (struct target_ops *ops, char *args, int from_tty)
{
  pid_t pid;
  pid_t pid2;
  int wstatus;
  int res;
  struct inferior *inf;
  kern_return_t kret;

  pid = parse_pid_to_attach (args);

  if (pid == getpid ())		/* Trying to masturbate?  */
    error (_("I refuse to debug myself!"));

  if (from_tty)
    {
      char *exec_file = get_exec_file (0);

      if (exec_file)
	printf_unfiltered (_("Attaching to program: %s, %s\n"), exec_file,
			   target_pid_to_str (pid_to_ptid (pid)));
      else
	printf_unfiltered (_("Attaching to %s\n"),
			   target_pid_to_str (pid_to_ptid (pid)));

      gdb_flush (gdb_stdout);
    }

  if (pid == 0 || kill (pid, 0) < 0)
    error (_("Can't attach to process %d: %s (%d)"),
           pid, safe_strerror (errno), errno);

  inferior_ptid = pid_to_ptid (pid);
  inf = current_inferior ();
  inferior_appeared (inf, pid);
  inf->attach_flag = 1;

  /* Always add a main thread.  */
  add_thread_silent (inferior_ptid);

  darwin_attach_pid (inf);

  darwin_suspend_inferior (inf);

  darwin_init_thread_list (inf);

  darwin_check_osabi (inf->private, ptid_get_tid (inferior_ptid));

  darwin_setup_fake_stop_event (inf);

  inf->private->no_ptrace = 1;
}

/* Take a program previously attached to and detaches it.
   The program resumes execution and will no longer stop
   on signals, etc.  We'd better not have left any breakpoints
   in the program or it'll die when it hits one.  For this
   to work, it may be necessary for the process to have been
   previously attached.  It *might* work if the program was
   started via fork.  */
static void
darwin_detach (struct target_ops *ops, char *args, int from_tty)
{
  pid_t pid = ptid_get_pid (inferior_ptid);
  struct inferior *inf = current_inferior ();
  kern_return_t kret;
  int res;

  /* Display message.  */
  if (from_tty)
    {
      char *exec_file = get_exec_file (0);
      if (exec_file == 0)
	exec_file = "";
      printf_unfiltered (_("Detaching from program: %s, %s\n"), exec_file,
			 target_pid_to_str (pid_to_ptid (pid)));
      gdb_flush (gdb_stdout);
    }

  /* If ptrace() is in use, stop the process.  */
  if (!inf->private->no_ptrace)
    darwin_stop_inferior (inf);

  kret = darwin_restore_exception_ports (inf->private);
  MACH_CHECK_ERROR (kret);

  if (!inf->private->no_ptrace)
    {
      res = PTRACE (PT_DETACH, inf->pid, 0, 0);
      if (res != 0)
	printf_unfiltered (_("Unable to detach from process-id %d: %s (%d)"),
			   inf->pid, safe_strerror (errno), errno);
    }

  darwin_reply_to_all_pending_messages (inf);

  /* When using ptrace, we have just performed a PT_DETACH, which
     resumes the inferior.  On the other hand, when we are not using
     ptrace, we need to resume its execution ourselves.  */
  if (inf->private->no_ptrace)
    darwin_resume_inferior (inf);

  darwin_mourn_inferior (ops);
}

static void
darwin_files_info (struct target_ops *ops)
{
}

static char *
darwin_pid_to_str (struct target_ops *ops, ptid_t ptid)
{
  static char buf[80];
  long tid = ptid_get_tid (ptid);

  if (tid != 0)
    {
      snprintf (buf, sizeof (buf), _("Thread 0x%lx of process %u"),
		tid, ptid_get_pid (ptid));
      return buf;
    }

  return normal_pid_to_str (ptid);
}

static int
darwin_thread_alive (struct target_ops *ops, ptid_t ptid)
{
  return 1;
}

/* If RDADDR is not NULL, read inferior task's LEN bytes from ADDR and
   copy it to RDADDR in gdb's address space.
   If WRADDR is not NULL, write gdb's LEN bytes from WRADDR and copy it
   to ADDR in inferior task's address space.
   Return 0 on failure; number of bytes read / writen otherwise.  */
static int
darwin_read_write_inferior (task_t task, CORE_ADDR addr,
			    gdb_byte *rdaddr, const gdb_byte *wraddr,
			    int length)
{
  kern_return_t kret;
  mach_vm_address_t offset = addr & (mach_page_size - 1);
  mach_vm_address_t low_address = (mach_vm_address_t) (addr - offset);
  mach_vm_size_t aligned_length = (mach_vm_size_t) PAGE_ROUND (offset + length);
  pointer_t copied;
  mach_msg_type_number_t copy_count;
  mach_vm_size_t remaining_length;
  mach_vm_address_t region_address;
  mach_vm_size_t region_length;

  inferior_debug (8, _("darwin_read_write_inferior(task=0x%x, %s, len=%d)\n"),
		  task, core_addr_to_string (addr), length);

  /* Get memory from inferior with page aligned addresses.  */
  kret = mach_vm_read (task, low_address, aligned_length,
		      &copied, &copy_count);
  if (kret != KERN_SUCCESS)
    {
      inferior_debug
	(1, _("darwin_read_write_inferior: mach_vm_read failed at %s: %s"),
	 core_addr_to_string (addr), mach_error_string (kret));
      return 0;
    }

  if (rdaddr != NULL)
    memcpy (rdaddr, (char *)copied + offset, length);

  if (wraddr == NULL)
    goto out;

  memcpy ((char *)copied + offset, wraddr, length);

  /* Do writes atomically.
     First check for holes and unwritable memory.  */
  for (region_address = low_address, remaining_length = aligned_length;
       region_address < low_address + aligned_length;
       region_address += region_length, remaining_length -= region_length)
    {
      vm_region_submap_short_info_data_64_t info;
      mach_vm_address_t region_start = region_address;
      mach_msg_type_number_t count;
      natural_t region_depth;

      region_depth = 100000;
      count = VM_REGION_SUBMAP_SHORT_INFO_COUNT_64;
      kret = mach_vm_region_recurse
	(task, &region_start, &region_length, &region_depth,
	 (vm_region_recurse_info_t) &info, &count);

      if (kret != KERN_SUCCESS)
	{
	  inferior_debug (1, _("darwin_read_write_inferior: "
			       "mach_vm_region_recurse failed at %s: %s\n"),
			  core_addr_to_string (region_address),
			  mach_error_string (kret));
	  goto out;
	}

      inferior_debug
	(9, _("darwin_read_write_inferior: "
	      "mach_vm_region_recurse addr=%s, start=%s, len=%s\n"),
	 core_addr_to_string (region_address),
	 core_addr_to_string (region_start),
	 core_addr_to_string (region_length));

      /* Check for holes in memory.  */
      if (region_start > region_address)
	{
	  warning (_("No memory at %s (vs %s+0x%x).  Nothing written"),
		   core_addr_to_string (region_address),
		   core_addr_to_string (region_start),
		   (unsigned)region_length);
	  length = 0;
	  goto out;
	}

      /* Adjust the length.  */
      region_length -= (region_address - region_start);

      if (!(info.max_protection & VM_PROT_WRITE))
	{
	  kret = mach_vm_protect
	    (task, region_address, region_length,
	     TRUE, info.max_protection | VM_PROT_WRITE | VM_PROT_COPY);
	  if (kret != KERN_SUCCESS)
	    {
	      warning (_("darwin_read_write_inf: "
			 "mach_vm_protect max failed at %s: %s"),
		       core_addr_to_string (region_address),
		       mach_error_string (kret));
	      length = 0;
	      goto out;
	    }
	}

      if (!(info.protection & VM_PROT_WRITE))
	{
	  kret = mach_vm_protect (task, region_address, region_length,
				 FALSE, info.protection | VM_PROT_WRITE);
	  if (kret != KERN_SUCCESS)
	    {
	      warning (_("darwin_read_write_inf: "
			 "mach_vm_protect failed at %s (len=0x%lx): %s"),
		       core_addr_to_string (region_address),
		       (unsigned long)region_length, mach_error_string (kret));
	      length = 0;
	      goto out;
	    }
	}
    }

  kret = mach_vm_write (task, low_address, copied, aligned_length);

  if (kret != KERN_SUCCESS)
    {
      warning (_("darwin_read_write_inferior: mach_vm_write failed: %s"),
	       mach_error_string (kret));
      length = 0;
    }
out:
  mach_vm_deallocate (mach_task_self (), copied, copy_count);
  return length;
}

/* Read LENGTH bytes at offset ADDR of task_dyld_info for TASK, and copy them
   to RDADDR.
   Return 0 on failure; number of bytes read / written otherwise.  */

#ifdef TASK_DYLD_INFO_COUNT
/* This is not available in Darwin 9.  */
static int
darwin_read_dyld_info (task_t task, CORE_ADDR addr, gdb_byte *rdaddr,
		       int length)
{
  struct task_dyld_info task_dyld_info;
  mach_msg_type_number_t count = TASK_DYLD_INFO_COUNT;
  int sz = TASK_DYLD_INFO_COUNT * sizeof (natural_t);
  kern_return_t kret;

  if (addr >= sz)
    return 0;

  kret = task_info (task, TASK_DYLD_INFO, (task_info_t) &task_dyld_info, &count);
  MACH_CHECK_ERROR (kret);
  if (kret != KERN_SUCCESS)
    return -1;
  /* Truncate.  */
  if (addr + length > sz)
    length = sz - addr;
  memcpy (rdaddr, (char *)&task_dyld_info + addr, length);
  return length;
}
#endif



static LONGEST
darwin_xfer_partial (struct target_ops *ops,
		     enum target_object object, const char *annex,
		     gdb_byte *readbuf, const gdb_byte *writebuf,
		     ULONGEST offset, LONGEST len)
{
  struct inferior *inf = current_inferior ();

  inferior_debug
    (8, _("darwin_xfer_partial(%s, %d, rbuf=%s, wbuf=%s) pid=%u\n"),
     core_addr_to_string (offset), (int)len,
     host_address_to_string (readbuf), host_address_to_string (writebuf),
     inf->pid);

  switch (object)
    {
    case TARGET_OBJECT_MEMORY:
      return darwin_read_write_inferior (inf->private->task, offset,
                                         readbuf, writebuf, len);
#ifdef TASK_DYLD_INFO_COUNT
    case TARGET_OBJECT_DARWIN_DYLD_INFO:
      if (writebuf != NULL || readbuf == NULL)
        {
          /* Support only read.  */
          return -1;
        }
      return darwin_read_dyld_info (inf->private->task, offset, readbuf, len);
#endif
    default:
      return -1;
    }

}

static void
set_enable_mach_exceptions (char *args, int from_tty,
			    struct cmd_list_element *c)
{
  if (!ptid_equal (inferior_ptid, null_ptid))
    {
      struct inferior *inf = current_inferior ();
      exception_mask_t mask;
      kern_return_t kret;

      if (enable_mach_exceptions)
	mask = EXC_MASK_ALL;
      else
	{
	  darwin_restore_exception_ports (inf->private);
	  mask = EXC_MASK_SOFTWARE | EXC_MASK_BREAKPOINT;
	}
      kret = task_set_exception_ports (inf->private->task, mask, darwin_ex_port,
				       EXCEPTION_DEFAULT, THREAD_STATE_NONE);
      MACH_CHECK_ERROR (kret);
    }
}

static char *
darwin_pid_to_exec_file (int pid)
{
  char *path;
  int res;

  path = xmalloc (PATH_MAX);
  make_cleanup (xfree, path);

  res = proc_pidinfo (pid, PROC_PIDPATHINFO, 0, path, PATH_MAX);
  if (res >= 0)
    return path;
  else
    return NULL;
}

static ptid_t
darwin_get_ada_task_ptid (long lwp, long thread)
{
  int i;
  darwin_thread_t *t;
  int k;
  struct inferior *inf = current_inferior ();
  kern_return_t kret;
  mach_port_name_array_t names;
  mach_msg_type_number_t names_count;
  mach_port_type_array_t types;
  mach_msg_type_number_t types_count;
  long res = 0;

  /* First linear search.  */
  for (k = 0;
       VEC_iterate (darwin_thread_t, inf->private->threads, k, t);
       k++)
    if (t->inf_port == lwp)
      return ptid_build (ptid_get_pid (inferior_ptid), 0, t->gdb_port);

  /* Maybe the port was never extract.  Do it now.  */

  /* First get inferior port names.  */
  kret = mach_port_names (inf->private->task, &names, &names_count, &types,
			  &types_count);
  MACH_CHECK_ERROR (kret);
  if (kret != KERN_SUCCESS)
    return null_ptid;

  /* For each name, copy the right in the gdb space and then compare with
     our view of the inferior threads.  We don't forget to deallocate the
     right.  */
  for (i = 0; i < names_count; i++)
    {
      mach_port_t local_name;
      mach_msg_type_name_t local_type;

      /* We just need to know the corresponding name in gdb name space.
	 So extract and deallocate the right.  */
      kret = mach_port_extract_right (inf->private->task, names[i],
				      MACH_MSG_TYPE_COPY_SEND,
				      &local_name, &local_type);
      if (kret != KERN_SUCCESS)
	continue;
      mach_port_deallocate (gdb_task, local_name);

      for (k = 0;
	   VEC_iterate (darwin_thread_t, inf->private->threads, k, t);
	   k++)
	if (t->gdb_port == local_name)
	  {
	    t->inf_port = names[i];
	    if (names[i] == lwp)
	      res = t->gdb_port;
	  }
    }

  vm_deallocate (gdb_task, (vm_address_t) names,
                 names_count * sizeof (mach_port_t));

  if (res)
    return ptid_build (ptid_get_pid (inferior_ptid), 0, res);
  else
    return null_ptid;
}

static int
darwin_supports_multi_process (void)
{
  return 1;
}

/* -Wmissing-prototypes */
extern initialize_file_ftype _initialize_darwin_inferior;

void
_initialize_darwin_inferior (void)
{
  kern_return_t kret;

  gdb_task = mach_task_self ();
  darwin_host_self = mach_host_self ();

  /* Read page size.  */
  kret = host_page_size (darwin_host_self, &mach_page_size);
  if (kret != KERN_SUCCESS)
    {
      mach_page_size = 0x1000;
      MACH_CHECK_ERROR (kret);
    }

  darwin_ops = inf_child_target ();

  darwin_ops->to_shortname = "darwin-child";
  darwin_ops->to_longname = _("Darwin child process");
  darwin_ops->to_doc =
    _("Darwin child process (started by the \"run\" command).");
  darwin_ops->to_create_inferior = darwin_create_inferior;
  darwin_ops->to_attach = darwin_attach;
  darwin_ops->to_attach_no_wait = 0;
  darwin_ops->to_detach = darwin_detach;
  darwin_ops->to_files_info = darwin_files_info;
  darwin_ops->to_wait = darwin_wait_to;
  darwin_ops->to_mourn_inferior = darwin_mourn_inferior;
  darwin_ops->to_kill = darwin_kill_inferior;
  darwin_ops->to_stop = darwin_stop;
  darwin_ops->to_resume = darwin_resume_to;
  darwin_ops->to_thread_alive = darwin_thread_alive;
  darwin_ops->to_pid_to_str = darwin_pid_to_str;
  darwin_ops->to_pid_to_exec_file = darwin_pid_to_exec_file;
  darwin_ops->to_load = NULL;
  darwin_ops->to_xfer_partial = darwin_xfer_partial;
  darwin_ops->to_supports_multi_process = darwin_supports_multi_process;
  darwin_ops->to_get_ada_task_ptid = darwin_get_ada_task_ptid;

  darwin_complete_target (darwin_ops);

  add_target (darwin_ops);

  inferior_debug (2, _("GDB task: 0x%lx, pid: %d\n"), mach_task_self (),
                  getpid ());

  add_setshow_zuinteger_cmd ("darwin", class_obscure,
			     &darwin_debug_flag, _("\
Set if printing inferior communication debugging statements."), _("\
Show if printing inferior communication debugging statements."), NULL,
			     NULL, NULL,
			     &setdebuglist, &showdebuglist);

  add_setshow_boolean_cmd ("mach-exceptions", class_support,
			   &enable_mach_exceptions, _("\
Set if mach exceptions are caught."), _("\
Show if mach exceptions are caught."), _("\
When this mode is on, all low level exceptions are reported before being\n\
reported by the kernel."),
			   &set_enable_mach_exceptions, NULL,
			   &setlist, &showlist);
}
@


1.48
log
@Normalize on PATH_MAX instead of MAXPATHLEN throughout.

With the pathmax gnulib module in place, we can use PATH_MAX
consistently throughout, instead of the current mixbag of PATH_MAX and
MAXPATHLEN uses.  It's no longer necessary to include sys/param.h
(supposedly, I can't check all ports touched here) for MAXPATHLEN.

Don't remove sys/param.h from GDB's configure.ac, as later tests in
the file use HAVE_SYS_PARAM_H checks.

Tested on x86_64 Fedora 17.

Also cross-built for --host=i686-w64-mingw32, and --host=i586-pc-msdosdjgpp.

gdb/
2013-07-01  Pedro Alves  <palves@@redhat.com>

	* defs.h: Include "pathmax.h".
	* utils.c: Don't include sys/param.h.
	(gdb_realpath): Remove code that checks for MAXPATHLEN.
	* solib-ia64-hpux.c (ia64_hpux_handle_load_event): Use PATH_MAX
	instead of MAXPATHLEN.
	* solib-sunos.c: Don't include sys/param.h.
	* xcoffread.c: Don't include sys/param.h.
	* bsd-kvm.c: Don't include sys/param.h.
	* darwin-nat.c: Don't include sys/param.h.
	(darwin_pid_to_exec_file): Use PATH_MAX instead of MAXPATHLEN.
	* darwin-nat-info.c: Don't include sys/param.h.
	* fbsd-nat.c (fbsd_pid_to_exec_file): Use PATH_MAX instead of
	MAXPATHLEN.
	* i386obsd-nat.c: Don't include sys/param.h.
	* inf-child.c: Don't include sys/param.h.
	(inf_child_fileio_readlink): Use PATH_MAX instead of MAXPATHLEN.
	* linux-fork.c: Don't include sys/param.h.
	(fork_save_infrun_state): Use PATH_MAX instead of MAXPATHLEN.
	* linux-nat.c: Don't include sys/param.h.
	(linux_child_pid_to_exec_file, linux_proc_pending_signals)
	(linux_proc_pending_signals): Use PATH_MAX instead of MAXPATHLEN.
	* m68klinux-nat.c: Don't include sys/param.h.
	* nbsd-nat.c: Don't include sys/param.h.
	(nbsd_pid_to_exec_file): Use PATH_MAX instead of MAXPATHLEN.
	* ppc-linux-nat.c: Don't include sys/param.h.
	* rs6000-nat.c: Don't include sys/param.h.
	* spu-linux-nat.c. Don't include sys/param.h.
	* windows-nat.c: Don't include sys/param.h.
	* xtensa-linux-nat.c: Don't include sys/param.h.
	* config/i386/nm-fbsd.h: Don't include sys/param.h.

gdb/gdbserver/
2013-07-01  Pedro Alves  <palves@@redhat.com>

	* server.h: Include "pathmax.h".
	* linux-low.c: Don't include sys/param.h.
	(linux_pid_exe_is_elf_64_file): Use PATH_MAX instead of
	MAXPATHLEN.
	* win32-low.c: Don't include sys/param.h.
	(win32_create_inferior): Use PATH_MAX instead of MAXPATHLEN.
@
text
@a1919 20
/* Return 0 on failure, number of bytes handled otherwise.  TARGET
   is ignored.  */
static int
darwin_xfer_memory (CORE_ADDR memaddr, gdb_byte *myaddr, int len, int write,
		    struct mem_attrib *attrib, struct target_ops *target)
{
  struct inferior *inf = current_inferior ();
  task_t task = inf->private->task;

  if (task == MACH_PORT_NULL)
    return 0;

  inferior_debug (8, _("darwin_xfer_memory(%s, %d, %c)\n"),
		  core_addr_to_string (memaddr), len, write ? 'w' : 'r');

  if (write)
    return darwin_read_write_inferior (task, memaddr, NULL, myaddr, len);
  else
    return darwin_read_write_inferior (task, memaddr, myaddr, NULL, len);
}
a2105 1
  darwin_ops->deprecated_xfer_memory = darwin_xfer_memory;
@


1.47
log
@Fix formating in copyright headers.

File list found with:
$ grep "along with this program" * -A 1 -rn \
	| grep "*/" \
	| grep -v "along with this program" \
	| sed 's,-[0-9]\+-.*,,g'

Tested on x86_64 Fedora 17.

gdb/
2013-06-07  Pedro Alves  <palves@@redhat.com>

	* darwin-nat.c: Fix formating in copyright header.
	* darwin-nat.h: Likewise.
	* gnu-nat.c: Likewise.
	* machoread.c: Likewise.

gdb/testsuite/
2013-06-07  Pedro Alves  <palves@@redhat.com>

	* gdb.ada/info_types.c: Fix formating in copyright header.
	* gdb.base/break-on-linker-gcd-function.cc: Likewise.
	* gdb.base/float.c: Likewise.
	* gdb.base/inferior-died.c: Likewise.
	* gdb.base/interp.c: Likewise.
	* gdb.base/jit-main.c: Likewise.
	* gdb.base/jit-solib.c: Likewise.
	* gdb.base/long_long.c: Likewise.
	* gdb.base/longjmp.c: Likewise.
	* gdb.base/nextoverexit.c: Likewise.
	* gdb.base/pr11022.c: Likewise.
	* gdb.base/prelink-lib.c: Likewise.
	* gdb.base/prelink.c: Likewise.
	* gdb.base/prologue.c: Likewise.
	* gdb.base/restore.c: Likewise.
	* gdb.base/sigchld.c: Likewise.
	* gdb.base/solib-search-lib1.c: Likewise.
	* gdb.base/solib-search-lib2.c: Likewise.
	* gdb.base/solib-search.c: Likewise.
	* gdb.base/solib-search.h: Likewise.
	* gdb.base/whatis.c: Likewise.
	* gdb.cp/abstract-origin.cc: Likewise.
	* gdb.cp/anon-struct.cc: Likewise.
	* gdb.cp/baseenum.cc: Likewise.
	* gdb.cp/bs15503.cc: Likewise.
	* gdb.cp/call-c-1.c: Likewise.
	* gdb.cp/call-c.cc: Likewise.
	* gdb.cp/class2.cc: Likewise.
	* gdb.cp/classes.cc: Likewise.
	* gdb.cp/cttiadd.cc: Likewise.
	* gdb.cp/cttiadd1.cc: Likewise.
	* gdb.cp/cttiadd2.cc: Likewise.
	* gdb.cp/cttiadd3.cc: Likewise.
	* gdb.cp/derivation.cc: Likewise.
	* gdb.cp/derivation2.cc: Likewise.
	* gdb.cp/dispcxx.cc: Likewise.
	* gdb.cp/exception.cc: Likewise.
	* gdb.cp/gdb2384-base.cc: Likewise.
	* gdb.cp/gdb2384-base.h: Likewise.
	* gdb.cp/gdb2384.cc: Likewise.
	* gdb.cp/gdb2495.cc: Likewise.
	* gdb.cp/mb-inline.h: Likewise.
	* gdb.cp/mb-inline1.cc: Likewise.
	* gdb.cp/mb-inline2.cc: Likewise.
	* gdb.cp/member-name.cc: Likewise.
	* gdb.cp/member-ptr.cc: Likewise.
	* gdb.cp/misc.cc: Likewise.
	* gdb.cp/namespace1.cc: Likewise.
	* gdb.cp/nextoverthrow.cc: Likewise.
	* gdb.cp/pr-574.cc: Likewise.
	* gdb.cp/pr9631.cc: Likewise.
	* gdb.cp/printmethod.cc: Likewise.
	* gdb.cp/psmang1.cc: Likewise.
	* gdb.cp/psmang2.cc: Likewise.
	* gdb.cp/psymtab-parameter.cc: Likewise.
	* gdb.cp/ptype-flags.cc: Likewise.
	* gdb.cp/ref-params.cc: Likewise.
	* gdb.cp/ref-types.cc: Likewise.
	* gdb.cp/smartp.cc: Likewise.
	* gdb.cp/try_catch.cc: Likewise.
	* gdb.cp/userdef.cc: Likewise.
	* gdb.cp/using-crash.cc: Likewise.
	* gdb.cp/virtfunc.cc: Likewise.
	* gdb.cp/virtfunc2.cc: Likewise.
	* gdb.dwarf2/callframecfa.S: Likewise.
	* gdb.dwarf2/dw2-ranges.c: Likewise.
	* gdb.dwarf2/dw2-ranges2.c: Likewise.
	* gdb.dwarf2/dw2-ranges3.c: Likewise.
	* gdb.dwarf2/dw2-restore.S: Likewise.
	* gdb.dwarf2/pieces.S: Likewise.
	* gdb.dwarf2/valop.S: Likewise.
	* gdb.java/jnpe.java: Likewise.
	* gdb.mi/mi-stepn.c: Likewise.
	* gdb.mi/mi-var-cp.cc: Likewise.
	* gdb.mi/mi-var-rtti.cc: Likewise.
	* gdb.mi/ns-stale-regcache.c: Likewise.
	* gdb.mi/pr11022.c: Likewise.
	* gdb.mi/solib-lib.c: Likewise.
	* gdb.mi/solib-main.c: Likewise.
	* gdb.python/py-arch.c: Likewise.
	* gdb.python/py-block.c: Likewise.
	* gdb.python/py-breakpoint.c: Likewise.
	* gdb.python/py-events.c: Likewise.
	* gdb.python/py-evthreads.c: Likewise.
	* gdb.python/py-explore.c: Likewise.
	* gdb.python/py-explore.cc: Likewise.
	* gdb.python/py-finish-breakpoint.c: Likewise.
	* gdb.python/py-finish-breakpoint2.cc: Likewise.
	* gdb.python/py-symbol.c: Likewise.
	* gdb.threads/execl.c: Likewise.
	* gdb.threads/execl1.c: Likewise.
@
text
@a50 1
#include <sys/param.h>
d2004 1
a2004 1
  path = xmalloc (MAXPATHLEN);
d2007 1
a2007 1
  res = proc_pidinfo (pid, PROC_PIDPATHINFO, 0, path, MAXPATHLEN);
@


1.46
log
@2013-05-10  Joel Brobecker  <brobecker@@adacore.com>
	    Tom Tromey  <tromey@@redhat.com>

	* common/filestuff.c (mark_fd_no_cloexec, unmark_fd_no_cloexec):
	New functions.
	* common/filestuff.c (mark_fd_no_cloexec, unmark_fd_no_cloexec):
	Declare.
	* darwin-nat.c (darwin_pre_ptrace): Use mark_fd_no_cloexec.
	(darwin_ptrace_him): Use unmark_fd_no_cloexec.
	* inf-ttrace.c (do_cleanup_pfds): Use unmark_fd_no_cloexec.
	(inf_ttrace_prepare): Use mark_fd_no_cloexec.
@
text
@d19 1
a19 2
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
@


1.45
log
@darwin: warning resuming inferior after attach

This patch avoids a warning when resuming the execution of a program
that we attached to. For instance:

    (gdb) attach 29989
    (gdb) continue
    Continuing.
    warning: Mach error at "/[...]/darwin-nat.c:738" in function
             "darwin_resume_thread": (os/kern) failure (0x5)

The warning is relatively harmless, but worrisome for the average
user.  The warning comes from the fact that darwin_wait recorded
that the fake stop event corresponding to the suspend action was
caused by the main thread being suspended on a SIGTRAP. As a result
of this, when resuming the program's execution, we try to resume
the thread's execution as well.  This is where the issue occurs,
as the thread was not in fact suspended, thus triggering the warning.

gdb/ChangeLog:

        * darwin-nat.c (darwin_setup_fake_stop_event): New function.
        (darwin_attach): Adjust using darwin_setup_fake_stop_event.
@
text
@d69 1
d1520 3
d1540 3
@


1.44
log
@darwin-nat: Print all hex values with 0x prefix.

gdb/ChangeLog:

        * darwin-nat.c: Replace all "%x" instances in format strings
        into "0x%x" throughout.
@
text
@d1589 26
d1666 2
a1667 2
  gdb_assert (darwin_inf_fake_stop == NULL);
  darwin_inf_fake_stop = inf;
@


1.43
log
@darwin-nat.c: Do not use gdb_assert on system call outcomes.

There were many cases were we make a system call which could fail
due to reasons outside of the debugger control. We should handle
these situations a little more gracefully than triggering an
internal error.

gdb/ChangeLog:

        * darwin-nat.c (darwin_mourn_inferior): Replace call to
        gdb_assert by call to MACH_CHECK_ERROR.
        (darwin_attach_pid): Raise an error rather than a failed
        assertion when various system calls failed.  Report a warning
        instead of raising a failed assertion when PREV_NOT is not NULL
        after call to mach_port_request_notification.
        (darwin_ptrace_me): Raise an error rather than a failed
        assertion when read returns nonzero.
@
text
@d326 1
a326 1
	(12, _(" new_ix:%d/%d, old_ix:%d/%d, new_id:%x old_id:%x\n"),
d711 1
a711 1
	  inferior_debug (4, _("darwin_set_sstep (thread=%x, enable=%d)\n"),
d881 2
a882 2
	  printf_unfiltered (_("darwin_wait: ill-formatted message (id=%x)\n"),
			     hdr->msgh_id);
d894 1
a894 1
      inferior_debug (4, _("darwin_wait: thread=%x, got %s\n"),
d978 1
a978 1
	  inferior_debug (4, _("darwin_wait: pid=%d exit, status=%x\n"),
d995 1
a995 1
  printf_unfiltered (_("Bad local-port: %x\n"), hdr->msgh_local_port);
d1018 1
a1018 1
      inferior_debug (4, "cancel_breakpoint for thread %x\n",
d1079 1
a1079 1
	  inferior_debug (5, _("mach_msg: ret=%x\n"), kret);
d1113 1
a1113 1
	    (5, _("darwin_wait: mach_msg(pending) ret=%x\n"), kret);
d1131 1
a1131 1
	      (3, _("darwin_wait: thread %x hit a non-gdb breakpoint\n"),
d1193 1
a1193 1
  inferior_debug (4, "task=%x, prev=%x, notify_port=%x\n",
d1744 1
a1744 1
  inferior_debug (8, _("darwin_read_write_inferior(task=%x, %s, len=%d)\n"),
@


1.42
log
@Fix various -Wpointer-sign warnings in darwin-nat.c

gdb/ChangeLog:

        * darwin-nat.c (darwin_read_write_inferior): Change types
        of parameters rdaddr and wraddr to "gdb_byte *". Change type
        of copy_count to "mach_msg_type_number_t".
        (darwin_read_dyld_info): Change type of parameter
        rdaddr to "gdb_byte *".
@
text
@d1185 1
a1185 1
  gdb_assert (kret == KERN_SUCCESS);
d1374 4
a1377 1
      gdb_assert (kret == KERN_SUCCESS);
d1381 4
a1384 1
      gdb_assert (kret == KERN_SUCCESS);
d1389 4
a1392 1
      gdb_assert (kret == KERN_SUCCESS);
d1395 5
a1399 1
      gdb_assert (kret == KERN_SUCCESS);
d1405 4
a1408 1
  gdb_assert (kret == KERN_SUCCESS);
d1412 5
a1416 1
  gdb_assert (kret == KERN_SUCCESS);
d1423 15
a1437 2
  gdb_assert (kret == KERN_SUCCESS);
  gdb_assert (prev_not == MACH_PORT_NULL);
d1440 4
a1443 1
  gdb_assert (kret == KERN_SUCCESS);
d1452 4
a1455 1
  gdb_assert (kret == KERN_SUCCESS);
d1495 2
a1496 1
  gdb_assert (res == 0);
@


1.41
log
@Fix build failure on darwin due to darwin_read_dyld_info not being defined.

gdb/ChangeLog:

        * darwin-nat.c: Fix typo in TASK_DYLD_INFO_COUNT macro test
        used to decide whether to define darwin_read_dyld_info or not.
@
text
@d1691 2
a1692 1
			    char *rdaddr, const char *wraddr, int length)
d1699 1
a1699 1
  int copy_count;
d1825 2
a1826 1
darwin_read_dyld_info (task_t task, CORE_ADDR addr, char *rdaddr, int length)
@


1.40
log
@gdb: fix building on Darwin 9

TASK_DYLD_INFO_COUNT etc. are not defined.
@
text
@d1821 1
a1821 1
#ifndef TASK_DYLD_INFO_COUNT
@


1.39
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d1819 1
a1819 1
   Return 0 on failure; number of bytes read / writen otherwise.  */
d1821 2
d1844 1
d1887 1
d1895 1
@


1.38
log
@gdb/
	* dwarf2loc.c (entry_values_debug): Add 'unsigned'.
	(_initialize_dwarf2loc): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* dwarf2loc.h: Update the declaration of 'entry_values_debug'.
	* dwarf2read.c (dwarf2_die_debug): Add 'unsigned'.
	(_initialize_dwarf2_read): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* darwin-nat.c (dwarwin_debug_flag): Add 'unsigned'.
	(_initialize_darwin_inferior): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* frame.c (frame_debug): Add 'unsigned'.
	(_intialize_frame): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* frame.h: Update the declaration of 'frame_debug'.
	* gdbtypes.c (overload_debug): Add 'unsigned'.
	(_initialize_gdbtypes): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* inferior.h: Update declaration of 'debug_infrun'.
	* infrun.c (debug_infrun): Add 'unsigned'.
	(_initialize_infrun): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* jit.c (jit_debug): Add 'unsigned'.
	(_initialize_jit): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* linux-nat.c (debug_linux_nat): Add 'unsigned'.
	(_initialize_linux_nat): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* linux-thread-db.c (libthread_db_debug): Add 'unsigned'.
	(_initialize_thread_db): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* machoread.c (mach_o_debug_level): Add 'unsigned'.
	(_initialize_machoread): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* mi/mi-cmd-var.c: Update the declaration of 'varobjdebug'.
	* microblaze-tdep.c (microblaze_debug_flag): Add 'unsigned'.
	(_initialize_microblaze_tdep): Call add_setshow_zuinteger_cmd
	intead of add_setshow_zinteger_cmd.
	* mips-tdep.c (mips_debug): Add 'unsigned'.
	(_initialize_mips_tdep): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* monitor.c (monitor_debug): Add 'unsigned'.
	(_initialize_remote_monitors): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* observer.c (observer_debug): Add 'unsigned'.
	(_initialize_observer): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* parse.c (expressiondebug): Add 'unsigned'.
	(_initialize_parse): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* record.c (record_debug): Add 'unsigned'.
	(_initialize_record): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* record.h: Update the declaration of 'record_debug'.
	* stap-probe.c (stap_expression_debug): Add 'unsigned'.
	(_initialize_stap_probe): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* serial.c (global_serial_debug_p): Add 'unsigned'.
	(_initialize_serial): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* solib-dsbt.c (solib_dsbt_debug): Add 'unsigned'.
	(_initialize_dsbt_solib): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* solib-frv.c (solib_frv_debug): Add 'unsigned'.
	(_initialize_frv_solib): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* target.c (targetdebug): Add 'unsigned'.
	(initialize_targets): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* valops.c (overload_debug): Add 'unsigned'.
	* varobj.c (varobjdebug): Add 'unsigned'.
	(_initialize_varobj): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* xtensa-tdep.c (xtensa_debug_level): Add 'unsigned'.
	(_initialize_xtensa_tdep): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.

	* arch-utils.h: Remove the declaration of 'gdbarch_debug'.
	* gdbarch.sh (gdbarch_debug): Add 'unsigned'.
	(extern void _initialize_gdbarch): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* gdbarch.c, gdbarch.h: Re-generated.
@
text
@d2 1
a2 1
   Copyright (C) 2008-2012 Free Software Foundation, Inc.
@


1.37
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        * gdb/signals.def: Replace TARGET_SIGNAL_ with GDB_SIGNAL_
	throughout.

sim/arm/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/avr/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/cr16/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/d10v/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/erc32/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/m32c/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/ppc/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rl78/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rx/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.
@
text
@d148 1
a148 1
static int darwin_debug_flag = 0;
d2060 2
a2061 2
  add_setshow_zinteger_cmd ("darwin", class_obscure,
			    &darwin_debug_flag, _("\
d2064 2
a2065 2
			    NULL, NULL,
			    &setdebuglist, &showdebuglist);
@


1.36
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.
@
text
@d804 1
a804 1
  if (signal == TARGET_SIGNAL_0)
d936 1
a936 1
	     as TARGET_SIGNAL_TRAP, and will report TARGET_EXC_BREAKPOINT
d938 1
a938 1
	  status->value.sig = TARGET_SIGNAL_TRAP;
d941 1
a941 1
	  status->value.sig = TARGET_SIGNAL_UNKNOWN;
d1055 1
a1055 1
      status->value.sig = TARGET_SIGNAL_TRAP;
d1266 1
a1266 1
	  && wstatus.value.sig == TARGET_SIGNAL_STOP)
@


1.35
log
@2012-04-11  Tristan Gingold  <gingold@@adacore.com>

	PR gdb/13901
	* darwin-nat.c (darwin_execvp): Revert previous patch.
@
text
@d94 1
a94 1
                              enum target_signal signal);
d96 1
a96 1
			   enum target_signal signal);
d790 1
a790 1
darwin_resume (ptid_t ptid, int step, enum target_signal signal)
d807 1
a807 1
    nsignal = target_signal_to_host (signal);
d856 1
a856 1
                  enum target_signal signal)
d916 1
a916 1
		target_signal_from_host (thread->event.ex_data[1]);
d919 1
a919 1
			      target_signal_to_name (status->value.sig));
@


1.34
log
@2012-04-11  Tristan Gingold  <gingold@@adacore.com>

	PR gdb/13901
	* darwin-nat.c (darwin_resume_thread): Call darwin_set_sstep only
	in case of change.
@
text
@a1531 16
  /* Specify the same binary preference to spawn the shell as the
     exec binary.  This avoids spawning a 64bit shell while debugging
     a 32bit program, which may confuse gdb.
     Also, this slightly breaks internal layers as we suppose the binary
     is Mach-O.  Doesn't harm in practice.  */
  if (exec_bfd != NULL)
    {
      cpu_type_t pref;
      size_t ocount;

      pref = bfd_mach_o_get_data (exec_bfd)->header.cputype;
      res = posix_spawnattr_setbinpref_np (&attr, 1, &pref, &ocount);
      if (res != 0 || ocount != 1)
	fprintf_unfiltered (gdb_stderr, "Cannot set posix_spawn binpref\n");
    }

@


1.33
log
@2012-04-10  Tristan Gingold  <gingold@@adacore.com>

	* darwin-nat.c (darwin_kill_inferior): Always use the no ptrace
	code to kill the inferior.
@
text
@d708 8
a715 5
      /* Set single step.  */
      inferior_debug (4, _("darwin_set_sstep (thread=%x, enable=%d)\n"),
                      thread->gdb_port, step);
      darwin_set_sstep (thread->gdb_port, step);
      thread->single_step = step;
@


1.32
log
@2012-04-02  Tristan Gingold  <gingold@@adacore.com>

	PR gdb/13901
	* darwin-nat.c (darwin_execvp): Sey binary preference.
@
text
@d1316 2
a1317 3
  if (!inf->private->no_ptrace)
    {
      darwin_stop_inferior (inf);
d1319 1
a1319 5
      res = PTRACE (PT_KILL, inf->pid, 0, 0);
      if (res != 0)
        warning (_("Failed to kill inferior: ptrace returned %d "
	           "[%s] (pid=%d)"),
		 res, safe_strerror (errno), inf->pid);
d1321 1
a1321 3
      darwin_reply_to_all_pending_messages (inf);

      darwin_resume_inferior (inf);
d1323 1
a1323 3
      ptid = darwin_wait (inferior_ptid, &wstatus);
    }
  else
a1324 5
      kret = darwin_restore_exception_ports (inf->private);
      MACH_CHECK_ERROR (kret);

      darwin_reply_to_all_pending_messages (inf);

d1326 1
a1326 3

      res = kill (inf->pid, 9);

d1329 3
@


1.31
log
@Fix -Wmissing-prototypes build warnings on Darwin.

gdb/
2012-03-13  Josh Matthews  <josh@@joshmatthews.net>

	* darwin-nat-info.c (_initialize_darwin_info_commands): Add
	prototype.
	(darwin_debug_port_info): Make static.
	* darwin-nat.c (_initialize_darwin_inferior): Add prototype.
	* machoread.c (_initialize_machoread): Add prototype.
	* i386-darwin-nat.c (i386_darwin_dr_set, i386_darwin_dr_get)
	(i386_darwin_set_control, i386_darwin_get_control)
	i386_darwin_dr_set_addr, i386_darwin_get_addr)
	i386_darwin_get_status, i386_darwin_get_control):
	Comment out with HW_WATCHPOINT_NOT_YET_ENABLED macro.
@
text
@d42 1
d1542 16
@


1.30
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2018 3
@


1.29
log
@2011-09-27  Tristan Gingold  <gingold@@adacore.com>

	* target.h (enum target_object): Add TARGET_OBJECT_DARWIN_DYLD_INFO.
	* solib-darwin.c (DYLD_VERSION_MAX): Update number.
	(darwin_solib_get_all_image_info_addr_at_init): New function.
	(darwin_solib_read_all_image_info_addr): Likewise.
	(darwin_solib_create_inferior_hook): Use the above two functions.
	* darwin-nat.c (darwin_execvp): Renames retval to res.
	(darwin_read_write_inferior): Update comment.
	(darwin_read_dyld_info): New function.
	(darwin_xfer_partial): Handle DYLD_INFO.
@
text
@d2 1
a2 1
   Copyright (C) 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.29.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 1
a2 1
   Copyright (C) 2008-2012 Free Software Foundation, Inc.
@


1.28
log
@2011-09-22  Tristan Gingold  <gingold@@adacore.com>

	* fork-child.c (fork_inferior): Add exec_fun parameter.
	Call exec_fun or execvp.
	* inferior.h: Adjust prototype.
	* gnu-nat.c (gnu_create_inferior): Adjust fork_inferior call.
	* inf-ttrace.c (inf_ttrace_create_inferior): Ditto.
	* inf-ptrace.c (inf_ptrace_create_inferior): Ditto.
	* procfs.c (procfs_create_inferior): Ditto.
	* darwin-nat.c (darwin_execvp): New function.
	(darwin_create_inferior): Use it.
@
text
@d1515 1
a1515 1
  int retval;
d1517 2
a1518 2
  retval = posix_spawnattr_init (&attr);
  if (retval != 0)
d1534 2
a1535 2
  retval = posix_spawnattr_setflags (&attr, ps_flags);
  if (retval != 0)
d1537 1
a1537 2
      fprintf_unfiltered
        (gdb_stderr, "Cannot set posix_spawn flags\n");
d1697 1
a1697 1
   Return 0 on failure; number of bytes read / writen  otherwise.  */
d1826 26
d1888 15
a1902 2
  if (object != TARGET_OBJECT_MEMORY)
    return -1;
a1903 2
  return darwin_read_write_inferior (inf->private->task, offset,
				     readbuf, writebuf, len);
@


1.27
log
@2011-08-01  Tristan Gingold  <gingold@@adacore.com>

	* darwin-nat.c (darwin_decode_exception_message): Adjust assertion.
@
text
@d56 1
d1511 35
d1551 1
a1551 1
		 darwin_pre_ptrace, NULL);
@


1.26
log
@[Darwin] Do not crash (failed assertion) after PT_KILL ptrace error

It might not be a debugger bug that caused the PT_KILL ptrace operation
to fail.  So emit a warning instead, and try to continue.

This patch also tries to handle the case where ptrace return -1,
but left errno set to zero.  According to the ptrace man page,
it is possible for some ptrace operations to return -1 in non-error
situations, and to detect those situations, it explains that errno
should be set prior to calling ptrace, and then checked again after.

gdb/ChangeLog:

        * darwin-nat.c (darwin_ptrace): Add documentation.
        Set errno to zero before calling ptrace.  If ptrace returns
        -1 and errno is zero, then change then return zero.
        (darwin_kill_inferior): Issue a warning instead of triggering
        a failed assertion when the PT_KILL ptrace operations returned
        nonzero.
@
text
@d618 4
a622 1
  gdb_assert (thread->msg_state == DARWIN_RUNNING);
@


1.25
log
@Darwin/detach: Do not resume inferior after ptrace detach

When trying to detach from an inferior that we start from the debugger,
GDB prints the following warning:

    (gdb) detach
    Detaching from program: /[...]/foo, process 74593
    warning: Mach error at "/[...]/darwin-nat.c:445" in function "darwin_resume_inferior": (os/kern) failure (0x5)

The warning comes from the following code in darwin_detach:

     darwin_resume_inferior (inf);

This is because the process has already been resumed by the
PT_DETACH ptrace operation that has just been performed.

On the other hand, when trying to detach from an inferior that
was started outside of debugger control (thus after having attached
the debugger to that inferior), things go smoothly.  That's because
we don't use ptrace to control the process in that case, and so
the resume is perfectly justified.

This patch makes sure that we resume the inferior during the detach
only when we're NOT using ptrace.

gdb/ChangeLog:

        * darwin-nat.c (darwin_detach): Call darwin_resume_inferior
        only when inf->private->no_ptrace.
@
text
@d236 9
d251 1
d253 2
d1316 4
a1319 1
      gdb_assert (res == 0);
@


1.24
log
@	ARI fixes: Messages should have no trailing new lines.
	* darwin-nat.c (mach_check_error): Remove trailing new line from
	warning function call message.
	* record.c (bfdcore_read): Idem for error call.
@
text
@d1604 5
a1608 1
  darwin_resume_inferior (inf);
@


1.23
log
@	Fix ARI warnings about new lines at the end of messages, which
	are unneeded as there is a new line added at the end of the message
	automatically.
	* darwin-nat.c (darwin_stop_inferior): Ditto.
	* dec-thread.c (dec_thread_get_ada_task_ptid): Ditto.
	* dfp.c (decimal_to_number): Ditto.
	* exec.c (print_section_info): Ditto.
	* i386-darwin-nat.c (darwin_set_sstep): Ditto.
	* osdata.c (get_osdata): Ditto.
	* record.c (bfdcore_write): Ditto.
	* remote-mips.c (mips_readchar): Ditto.
	* remote.c (read_ptid): Ditto.
	* ser-mingw.c (ser_windows_raw): Ditto.
	* tracepoint.c (add_local_symbols): Ditto.
	* windows-nat.c (fake_create_process): Ditto.
@
text
@d199 1
a199 1
  warning (_("Mach error at \"%s:%u\" in function \"%s\": %s (0x%lx)\n"),
@


1.22
log
@2011-01-07  Michael Snyder  <msnyder@@vmware.com>

	* ada-lang.c: Comment cleanup, mostly periods and spaces.
	* ada-lang.h: Ditto.
	* ada-tasks.c: Ditto.
	* ada-valprint.c: Ditto.
	* aix-threads.c: Ditto.
	* alpha-linux-nat.c: Ditto.
	* alpha-linux-tdep.c: Ditto.
	* alpha-mdebug-tdep.c: Ditto.
	* alpha-nat.c: Ditto.
	* alpha-osf1-tdep.c: Ditto.
	* alpha-tdep.c: Ditto.
	* alphabsd-nat.c: Ditto.
	* alphabsd-tdep.c: Ditto.
	* amd64-darwin-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* amd64-sol2-tdep.c: Ditto.
	* amd64-tdep.c: Ditto.
	* amd64-fbsd-tdep.c: Ditto.
	* amd64-nbsd-tdep.c: Ditto.
	* amd64-obsd-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* arm-tdep.c: Ditto.
	* arm-tdep.h: Ditto.
	* armnbsd-nat.c: Ditto.
	* avr-tdep.c: Ditto.
	* bfin-tdep.c: Ditto.
	* bsd-kvm.c: Ditto.
	* c-typeprintc: Ditto.
	* c-valprint.c: Ditto.
	* coff-pe-read.h: Ditto.
	* coffreead.c: Ditto.
	* cris-tdep.c: Ditto.
	* d-lang.c: Ditto.
	* darwin-nat-info.c: Ditto.
	* darwin-nat.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* dcache.c: Ditto.
	* dcache.h: Ditto.
	* dec-thread.c: Ditto.
	* defs.h: Ditto.
	* demangle.c: Ditto.
	* dicos-tdep.c: Ditto.
	* dictionary.c: Ditto.
	* dictionary.h: Ditto.
	* dink32-rom.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dsrec.c: Ditto.
	* dummy-frame.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* environ.c: Ditto.
	* eval.c: Ditto.
	* event-top.h: Ditto.
	* exceptions.c: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-exp.y: Ditto.
	* f-lang.c: Ditto.
	* f-lang.h: Ditto.
	* f-typeprint.c: Ditto.
	* f-valprint.c: Ditto.
	* fbsd-nat.c: Ditto.
	* findvar.c: Ditto.
	* fork-child.c: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* frv-linux-tdep.c: Ditto.
	* frv-tdep.c: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_string.h: Ditto.
	* gdb_thread_db.h: Ditto.
	* gdb_wait.h: Ditto.
	* gdbarch.sh: Ditto.
	* gdbcore.h: Ditto.
	* gdbthread.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* gnu-nat.c: Ditto.
	* gnu-nat.h: Ditto.
	* gnu-v2-abi.c: Ditto.
	* gnu-v3-abi.c: Ditto.
	* go32-nat.c: Ditto.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
@
text
@d1239 1
a1239 1
    warning (_("cannot kill: %s\n"), safe_strerror (errno));
@


1.21
log
@run copyright.sh for 2011.
@
text
@d132 1
a132 1
/* Page size. */
d917 1
a917 1
	     as a spurious signal. */
d983 1
a983 1
  /* Arrange for a breakpoint to be hit again later. We will handle
d1658 1
a1658 1
  /* Get memory from inferior with page aligned addresses */
d1710 1
a1710 1
      /* Check for holes in memory */
d1713 1
a1713 1
	  warning (_("No memory at %s (vs %s+0x%x). Nothing written"),
d1771 1
a1771 1
   is ignored. */
@


1.20
log
@	* gdb_assert.h (gdb_assert_not_reached): New macro.
	(gdb_assert_fail): Fix typo in comment.
	* avr-tdep.c (avr_return_value): Use gdb_assert_not_reached instead of
	gdb_assert (0).
	* darwin-nat.c (darwin_check_new_threads): Ditto.
	* dwarf2read.c (dwarf2_get_section_info): Ditto.
	(munmap_section_buffer): Ditto.
	* m32c-tdep.c (make_types): Ditto.
	(m32c_decode_srcdest4, m32c_decode_sd23, m32c_frame_base): Ditto.
	* macroexp.c (get_character_constant): Ditto.
	(get_string_literal): Ditto.
	* mep-tdep.c (mep_pseudo_cr_size): Ditto.
	(mep_pseudo_cr_index, mep_register_type): Ditto.
	(mep_pseudo_register_read, mep_pseudo_register_write): Ditto.
	(mep_get_insn, mep_analyze_prologue): Ditto.
	* objfiles.c (qsort_cmp): Ditto.
	* prologue-value.c (pv_is_identical): Ditto.
	* record.c (record_get_loc): Ditto.
	* value.c (value_static_field): Ditto.
	* xtensa-tdep.c (call0_track_op): Ditto.
@
text
@d2 1
a2 1
   Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.19
log
@gdb/
	* defs.h (parse_pid_to_attach): New.
	* utils.c (parse_pid_to_attach): New.
	* darwin-nat.c (darwin_attach): Replace ARGS parsing by parse_pid.
	* gnu-nat.c (gnu_attach): Likewise.
	* nto-procfs.c (procfs_attach): Likewise.
	* procfs.c (procfs_attach): Likewise.
	* windows-nat.c (windows_attach): Likewise.
	* inf-ptrace.c (inf_ptrace_attach): Likewise.  Remove variable dummy.
	* inf-ttrace.c (inf_ttrace_attach): Likewise.
	* remote.c (extended_remote_attach_1): Likewise.  New comment on getpid
	check.

gdb/testsuite/
	* gdb.base/attach.exp (attach to nonsense is prohibited): Make the
	"Illegal process-id" expect string more exact.
	(attach to digits-starting nonsense is prohibited): New.
@
text
@d366 1
a366 1
      gdb_assert (0);
@


1.18
log
@2010-02-04  Tristan Gingold  <gingold@@adacore.com>

	* machoread.c (macho_add_oso): Renamed to macho_register_oso.
	(macho_symtab_read): Adjust calls to macho_add_oso.
	(macho_oso_symfile): Renamed to macho_symfile_read_all_oso.
	(macho_symfile_read): Adjust call to macho_oso_symfile.
	(macho_new_init): Move this function after declarations.
	(macho_symfile_init): Ditto.
	* darwin-nat-info.c (darwin_lib_gdb_ports): Remove.
	* darwin-nat.c (darwin_lookup_task): Remove unused prototype.
@
text
@d1517 1
a1517 2
  if (!args)
    error_no_arg (_("process-id to attach"));
d1519 1
a1519 3
  pid = atoi (args);

  if (pid == getpid ())		/* Trying to masturbate? */
@


1.17
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@a101 2
static int darwin_lookup_task (char *args, task_t * ptask, int *ppid);

@


1.16
log
@	* darwin-nat.c (cancel_breakpoint): Pass the regcache's address
	space to breakpoint_inserted_here_p.
@
text
@d2 1
a2 1
   Copyright (C) 2008, 2009 Free Software Foundation, Inc.
@


1.15
log
@2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	Add base multi-executable/process support to GDB.

	gdb/
	* Makefile.in (SFILES): Add progspace.c.
	(COMMON_OBS): Add progspace.o.
	* progspace.h: New.
	* progspace.c: New.

	* breakpoint.h (struct bp_target_info) <placed_address_space>: New
	field.
	(struct bp_location) <pspace>: New field.
	(struct breakpoint) <pspace>: New field.
	(bpstat_stop_status, breakpoint_here_p)
	(moribund_breakpoint_here_p, breakpoint_inserted_here_p)
	(regular_breakpoint_inserted_here_p)
	(software_breakpoint_inserted_here_p, breakpoint_thread_match)
	(set_default_breakpoint): Adjust prototypes.
	(remove_breakpoints_pid, breakpoint_program_space_exit): Declare.
	(insert_single_step_breakpoint, deprecated_insert_raw_breakpoint):
	Adjust prototypes.
	* breakpoint.c (executing_startup): Delete.
	(default_breakpoint_sspace): New.
	(breakpoint_restore_shadows): Skip if the address space doesn't
	match.
	(update_watchpoint): Record the frame's program space in the
	breakpoint location.
	(insert_bp_location): Record the address space in target_info.
	Adjust to pass the symbol space to solib_name_from_address.
	(breakpoint_program_space_exit): New.
	(insert_breakpoint_locations): Switch the symbol space and thread
	when inserting breakpoints.  Don't insert breakpoints in a vfork
	parent waiting for vfork done if we're not attached to the vfork
	child.
	(remove_breakpoints_pid): New.
	(reattach_breakpoints): Switch to a thread of PID.  Ignore
	breakpoints of other symbol spaces.
	(create_internal_breakpoint): Store the symbol space in the sal.
	(create_longjmp_master_breakpoint): Iterate over all symbol
	spaces.
	(update_breakpoints_after_exec): Ignore breakpoints for other
	symbol spaces.
	(remove_breakpoint): Rename to ...
	(remove_breakpoint_1): ... this.  Pass the breakpoints symbol
	space to solib_name_from_address.
	(remove_breakpoint): New.
	(mark_breakpoints_out): Ignore breakpoints from other symbol
	spaces.
	(breakpoint_init_inferior): Ditto.
	(breakpoint_here_p): Add an address space argument and adjust to
	use breakpoint_address_match.
	(moribund_breakpoint_here_p): Ditto.
	(regular_breakpoint_inserted_here_p): Ditto.
	(breakpoint_inserted_here_p): Ditto.
	(software_breakpoint_inserted_here_p): Ditto.
	(breakpoint_thread_match): Ditto.
	(bpstat_check_location): Ditto.
	(bpstat_stop_status): Ditto.
	(print_breakpoint_location): If there's a location to print,
	switch the current symbol space.
	(print_one_breakpoint_location): Add `allflag' argument.
	(print_one_breakpoint): Ditto.	Adjust.
	(do_captured_breakpoint_query): Adjust.
	(breakpoint_1): Adjust.
	(breakpoint_has_pc): Also match the symbol space.
	(describe_other_breakpoints): Add a symbol space argument and
	adjust.
	(set_default_breakpoint): Add a symbol space argument.	Set
	default_breakpoint_sspace.
	(breakpoint_address_match): New.
	(check_duplicates_for): Add an address space argument, and adjust.
	(set_raw_breakpoint): Record the symbol space in the location and
	in the breakpoint.
	(set_longjmp_breakpoint): Skip longjmp master breakpoints from
	other symbol spaces.
	(remove_thread_event_breakpoints, remove_solib_event_breakpoints)
	(disable_breakpoints_in_shlibs): Skip breakpoints from other
	symbol spaces.
	(disable_breakpoints_in_unloaded_shlib): Match symbol spaces.
	(create_catchpoint): Set the symbol space in the sal.
	(disable_breakpoints_before_startup): Skip breakpoints from other
	symbol spaces.	Set executing_startup in the current symbol space.
	(enable_breakpoints_after_startup): Clear executing_startup in the
	current symbol space.  Skip breakpoints from other symbol spaces.
	(clone_momentary_breakpoint): Also copy the symbol space.
	(add_location_to_breakpoint): Set the location's symbol space.
	(bp_loc_is_permanent): Switch thread and symbol space.
	(create_breakpoint): Adjust.
	(expand_line_sal_maybe): Expand comment to mention symbol spaces.
	Switch thread and symbol space when reading memory.
	(parse_breakpoint_sals): Set the symbol space in the sal.
	(break_command_really): Ditto.
	(skip_prologue_sal): Switch and space.
	(resolve_sal_pc): Ditto.
	(watch_command_1): Record the symbol space in the sal.
	(create_ada_exception_breakpoint): Adjust.
	(clear_command): Adjust.  Match symbol spaces.
	(update_global_location_list): Use breakpoint_address_match.
	(breakpoint_re_set_one): Switch thread and space.
	(breakpoint_re_set): Save symbol space.
	(breakpoint_re_set_thread): Also reset the symbol space.
	(deprecated_insert_raw_breakpoint): Add an address space argument.
	Adjust.
	(insert_single_step_breakpoint): Ditto.
	(single_step_breakpoint_inserted_here_p): Ditto.
	(clear_syscall_counts): New.
	(_initialize_breakpoint): Install it as inferior_exit observer.

	* exec.h: Include "progspace.h".
	(exec_bfd, exec_bfd_mtime): New defines.
	(exec_close): Declare.
	* exec.c: Include "gdbthread.h" and "progspace.h".
	(exec_bfd, exec_bfd_mtime, current_target_sections_1): Delete.
	(using_exec_ops): New.
	(exec_close_1): Rename to exec_close, and make public.
	(exec_close): Rename to exec_close_1, and adjust all callers.  Add
	description.  Remove target sections and close executables from
	all program spaces.
	(exec_file_attach): Add comment.
	(add_target_sections): Check on `using_exec_ops' to check if the
	target should be pushed.
	(remove_target_sections): Only unpush the target if there are no
	more target sections in any symbol space.
	* gdbcore.h: Include "exec.h".
	(exec_bfd, exec_bfd_mtime): Remove declarations.

	* frame.h (get_frame_program_space, get_frame_address_space)
	(frame_unwind_program_space): Declare.
	* frame.c (struct frame_info) <pspace, aspace>: New fields.
	(create_sentinel_frame): Add program space argument.  Set the
	pspace and aspace fields of the frame object.
	(get_current_frame, create_new_frame): Adjust.
	(get_frame_program_space): New.
	(frame_unwind_program_space): New.
	(get_frame_address_space): New.
	* stack.c (print_frame_info): Adjust.
	(print_frame): Use the frame's program space.

	* gdbthread.h (any_live_thread_of_process): Declare.
	* thread.c (any_live_thread_of_process): New.
	(switch_to_thread): Switch the program space as well.
	(restore_selected_frame): Don't warn if trying to restore frame
	level 0.

	* inferior.h: Include "progspace.h".
	(detach_fork): Declare.
	(struct inferior) <removable, aspace, pspace>
	<vfork_parent, vfork_child, pending_detach>
	<waiting_for_vfork_done>: New fields.
	<terminal_info>: Remove field.
	<data, num_data>: New fields.
	(register_inferior_data, register_inferior_data_with_cleanup)
	(clear_inferior_data, set_inferior_data, inferior_data): Declare.
	(exit_inferior, exit_inferior_silent, exit_inferior_num_silent)
	(inferior_appeared): Declare.
	(find_inferior_pid): Typo.
	(find_inferior_id, find_inferior_for_program_space): Declare.
	(set_current_inferior, save_current_inferior, prune_inferiors)
	(number_of_inferiors): Declare.
	(inferior_list): Declare.
	* inferior.c: Include "gdbcore.h" and "symfile.h".
	(inferior_list): Make public.
	(delete_inferior_1): Always delete thread silently.
	(find_inferior_id): Make public.
	(current_inferior_): New.
	(current_inferior): Use it.
	(set_current_inferior): New.
	(restore_inferior): New.
	(save_current_inferior): New.
	(free_inferior): Free the per-inferior data.
	(add_inferior_silent): Allocate per-inferior data.
	Call inferior_appeared.
	(delete_threads_of_inferior): New.
	(delete_inferior_1): Adjust interface to take an inferior pointer.
	(delete_inferior): Adjust.
	(delete_inferior_silent): Adjust.
	(exit_inferior_1): New.
	(exit_inferior): New.
	(exit_inferior_silent): New.
	(exit_inferior_num_silent): New.
	(detach_inferior): Adjust.
	(inferior_appeared): New.
	(discard_all_inferiors): Adjust.
	(find_inferior_id): Make public.  Assert pid is not zero.
	(find_inferior_for_program_space): New.
	(have_inferiors): Check if we have any inferior with pid not zero.
	(have_live_inferiors): Go over all pushed targets looking for
	process_stratum.
	(prune_inferiors): New.
	(number_of_inferiors): New.
	(print_inferior): Add executable column.  Print vfork parent/child
	relationships.
	(inferior_command): Adjust to cope with not running inferiors.
	(remove_inferior_command): New.
	(add_inferior_command): New.
	(clone_inferior_command): New.
	(struct inferior_data): New.
	(struct inferior_data_registration): New.
	(struct inferior_data_registry): New.
	(inferior_data_registry): New.
	(register_inferior_data_with_cleanup): New.
	(register_inferior_data): New.
	(inferior_alloc_data): New.
	(inferior_free_data): New.
	(clear_inferior_data): New.
	(set_inferior_data): New.
	(inferior_data): New.
	(initialize_inferiors): New.
	(_initialize_inferiors): Register "add-inferior",
	"remove-inferior" and "clone-inferior" commands.

	* objfiles.h: Include "progspace.h".
	(struct objfile) <pspace>: New field.
	(symfile_objfile, object_files): Don't declare.
	(ALL_PSPACE_OBJFILES): New.
	(ALL_PSPACE_OBJFILES_SAFE): New.
	(ALL_OBJFILES, ALL_OBJFILES_SAFE): Adjust.
	(ALL_PSPACE_SYMTABS): New.
	(ALL_PRIMARY_SYMTABS): Adjust.
	(ALL_PSPACE_PRIMARY_SYMTABS): New.
	(ALL_PSYMTABS): Adjust.
	(ALL_PSPACE_PSYMTABS): New.
	* objfiles.c (object_files, symfile_objfile): Delete.
	(struct objfile_sspace_info): New.
	(objfiles_pspace_data): New.
	(objfiles_pspace_data_cleanup): New.
	(get_objfile_pspace_data): New.
	(objfiles_changed_p): Delete.
	(allocate_objfile): Set the objfile's program space.  Adjust to
	reference objfiles_changed_p in pspace data.
	(free_objfile): Adjust to reference objfiles_changed_p in pspace
	data.
	(objfile_relocate): Ditto.
	(update_section_map): Add pspace argument.  Adjust to iterate over
	objfiles in the passed in pspace.
	(find_pc_section): Delete sections and num_sections statics.
	Adjust to refer to program space's objfiles_changed_p.	Adjust to
	refer to sections and num_sections store in the objfile's pspace
	data.
	(objfiles_changed): Adjust to reference objfiles_changed_p in
	pspace data.
	(_initialize_objfiles): New.
	* linespec.c (decode_all_digits, decode_dollar): Set the sal's
	program space.
	* source.c (current_source_pspace): New.
	(get_current_source_symtab_and_line): Set the sal's program space.
	(set_current_source_symtab_and_line): Set current_source_pspace.
	(select_source_symtab): Ditto.	Use ALL_OBJFILES.
	(forget_cached_source_info): Iterate over all program spaces.
	* symfile.c (clear_symtab_users): Adjust.
	* symmisc.c (print_symbol_bcache_statistics): Iterate over all
	program spaces.
	(print_objfile_statistics): Ditto.
	(maintenance_print_msymbols): Ditto.
	(maintenance_print_objfiles): Ditto.
	(maintenance_info_symtabs): Ditto.
	(maintenance_info_psymtabs): Ditto.
	* symtab.h (SYMTAB_PSPACE): New.
	(struct symtab_and_line) <pspace>: New field.
	* symtab.c (init_sal): Clear the sal's program space.
	(find_pc_sect_symtab): Set the sal's program space.  Switch thread
	and space.
	(append_expanded_sal): Add program space argument.  Iterate over
	all program spaces.
	(expand_line_sal): Iterate over all program spaces.  Switch
	program space.

	* target.h (enum target_waitkind) <TARGET_WAITKIND_VFORK_DONE>: New.
	(struct target_ops) <to_thread_address_space>: New field.
	(target_thread_address_space): Define.
	* target.c (target_detach): Only remove breakpoints from the
	inferior we're detaching.
	(target_thread_address_space): New.

	* defs.h (initialize_progspace): Declare.
	* top.c (gdb_init): Call it.

	* solist.h (struct so_list) <sspace>: New field.
	* solib.h (struct program_space): Forward declare.
	(solib_name_from_address): Adjust prototype.
	* solib.c (so_list_head): Replace with a macro referencing the
	program space.
	(update_solib_list): Set the so's program space.
	(solib_name_from_address): Add a program space argument and adjust.

	* solib-svr4.c (struct svr4_info) <pid>: Delete field.
	<interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low>
	<interp_plt_sect_high>: New fields.
	(svr4_info_p, svr4_info): Delete.
	(solib_svr4_sspace_data): New.
	(get_svr4_info): Rewrite.
	(svr4_sspace_data_cleanup): New.
	(open_symbol_file_object): Adjust.
	(svr4_default_sos): Adjust.
	(svr4_fetch_objfile_link_map): Adjust.
	(interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low)
	(interp_plt_sect_high): Delete.
	(svr4_in_dynsym_resolve_code): Adjust.
	(enable_break): Adjust.
	(svr4_clear_solib): Revert bit that removed the svr4_info here,
	and reinstate clearing debug_base, debug_loader_offset_p,
	debug_loader_offset and debug_loader_name.
	(_initialize_svr4_solib): Register solib_svr4_pspace_data.  Don't
	install an inferior_exit observer anymore.

	* printcmd.c (struct display) <pspace>: New field.
	(display_command): Set the display's sspace.
	(do_one_display): Match the display's sspace.
	(display_uses_solib_p): Ditto.

	* linux-fork.c (detach_fork): Moved to infrun.c.
	(_initialize_linux_fork): Moved "detach-on-fork" command to
	infrun.c.
	* infrun.c (detach_fork): Moved from linux-fork.c.
	(proceed_after_vfork_done): New.
	(handle_vfork_child_exec_or_exit): New.
	(follow_exec_mode_replace, follow_exec_mode_keep)
	(follow_exec_mode_names, follow_exec_mode_string)
	(show_follow_exec_mode_string): New.
	(follow_exec): New.  Reinstate the mark_breakpoints_out call.
	Remove shared libraries before attaching new executable.  If user
	wants to keep the inferior, keep it.
	(displaced_step_fixup): Adjust to pass an address space to the
	breakpoints module.
	(resume): Ditto.
	(clear_proceed_status): In all-stop mode, always clear the proceed
	status of all threads.
	(prepare_to_proceed): Adjust to pass an address space to the
	breakpoints module.
	(proceed): Ditto.
	(adjust_pc_after_break): Ditto.
	(handle_inferior_event): When handling a process exit, switch the
	program space to the inferior's that had exited.  Call
	handle_vfork_child_exec_or_exit.  Adjust to pass an address space
	to the breakpoints module.  In non-stop mode, when following a
	fork and detach-fork is off, also resume the other branch.  Handle
	TARGET_WAITKIND_VFORK_DONE.  Set the program space in sals.
	(normal_stop): Prune inferiors.
	(_initialize_infrun): Install the new "follow-exec-mode" command.
	"detach-on-fork" moved here.

	* regcache.h (get_regcache_aspace): Declare.
	* regcache.c (struct regcache) <aspace>: New field.
	(regcache_xmalloc): Clear the aspace.
	(get_regcache_aspace): New.
	(regcache_cpy): Copy the aspace field.
	(regcache_cpy_no_passthrough): Ditto.
	(get_thread_regcache): Fetch the thread's address space from the
	target, and store it in the regcache.

	* infcall.c (call_function_by_hand): Set the sal's pspace.

	* arch-utils.c (default_has_shared_address_space): New.
	* arch-utils.h (default_has_shared_address_space): Declare.

	* gdbarch.sh (has_shared_address_space): New.
	* gdbarch.h, gdbarch.c: Regenerate.

	* linux-tdep.c: Include auxv.h, target.h, elf/common.h.
	(linux_has_shared_address_space): New.
	(_initialize_linux_tdep): Declare.

	* arm-tdep.c (arm_software_single_step): Pass the frame's address
	space to insert_single_step_breakpoint.
	* arm-linux-tdep.c (arm_linux_software_single_step): Pass the
	frame's pspace to breakpoint functions.
	* cris-tdep.c (crisv32_single_step_through_delay): Ditto.
	(cris_software_single_step): Ditto.
	* mips-tdep.c (deal_with_atomic_sequence): Add frame argument.
	Pass the frame's pspace to breakpoint functions.
	(mips_software_single_step): Adjust.
	(mips_single_step_through_delay): Adjust.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Adjust.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Adjust.
	* solib-irix.c (enable_break): Adjust to pass the current frame's
	address space to breakpoint functions.
	* sparc-tdep.c (sparc_software_single_step): Ditto.
	* spu-tdep.c (spu_software_single_step): Ditto.
	* alpha-tdep.c (alpha_software_single_step): Ditto.
	* record.c (record_wait): Adjust to pass an address space to the
	breakpoints module.

	* fork-child.c (fork_inferior): Set the new inferior's program and
	address spaces.
	* inf-ptrace.c (inf_ptrace_follow_fork): Copy the parent's program
	and address spaces.
	(inf_ptrace_attach): Set the inferior's program and address spaces.
	* linux-nat.c: Include "solib.h".
	(linux_child_follow_fork): Manage parent and child's program and
	address spaces.	 Clone the parent's program space if necessary.
	Don't wait for the vfork to be done here.  Refuse to resume if
	following the vfork parent while leaving the child stopped.
	(resume_callback): Don't resume a vfork parent.
	(linux_nat_resume): Also check for pending events in the
	lp->waitstatus field.
	(linux_handle_extended_wait): Report TARGET_WAITKIND_VFORK_DONE
	events to the core.
	(stop_wait_callback): Don't wait for SIGSTOP on vfork parents.
	(cancel_breakpoint): Adjust.
	* linux-thread-db.c (thread_db_wait): Don't remove thread event
	breakpoints here.
	(thread_db_mourn_inferior): Don't mark breakpoints out here.
	Remove thread event breakpoints after mourning.
	* corelow.c: Include progspace.h.
	(core_open): Set the inferior's program and address spaces.
	* remote.c (remote_add_inferior): Set the new inferior's program
	and address spaces.
	(remote_start_remote): Update address spaces.
	(extended_remote_create_inferior_1): Don't init the thread list if
	we already debugging other inferiors.
	* darwin-nat.c (darwin_attach): Set the new inferior's program and
	address spaces.
	* gnu-nat.c (gnu_attach): Ditto.
	* go32-nat.c (go32_create_inferior): Ditto.
	* inf-ttrace.c (inf_ttrace_follow_fork, inf_ttrace_attach): Ditto.
	* monitor.c (monitor_open): Ditto.
	* nto-procfs.c (procfs_attach, procfs_create_inferior): Ditto.
	* procfs.c (do_attach): Ditto.
	* windows-nat.c (do_initial_windows_stuff): Ditto.

	* inflow.c (inferior_process_group)
	(terminal_init_inferior_with_pgrp, terminal_inferior,
	(terminal_ours_1, inflow_inferior_exit, copy_terminal_info)
	(child_terminal_info, new_tty_postfork, set_sigint_trap): Adjust
	to use per-inferior data instead of inferior->terminal_info.
	(inflow_inferior_data): New.
	(inflow_new_inferior): Delete.
	(inflow_inferior_data_cleanup): New.
	(get_inflow_inferior_data): New.

	* mi/mi-interp.c (mi_new_inferior): Rename to...
	(mi_inferior_appeared): ... this.
	(mi_interpreter_init): Adjust.

	* tui/tui-disasm.c: Include "progspace.h".
	(tui_set_disassem_content): Pass an address space to
	breakpoint_here_p.

	* NEWS: Mention multi-program debugging support.  Mention new
	commands "add-inferior", "clone-inferior", "remove-inferior",
	"maint info program-spaces", and new option "set
	follow-exec-mode".

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* observer.texi (new_inferior): Rename to...
	(inferior_appeared): ... this.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/testsuite/
	* gdb.base/foll-vfork.exp: Adjust to spell out "follow-fork".
	* gdb.base/foll-exec.exp: Adjust to expect a process id before
	"Executing new program".
	* gdb.base/foll-fork.exp: Adjust to spell out "follow-fork".
	* gdb.base/multi-forks.exp: Ditto.  Adjust to the inferior being
	left listed after having been killed.
	* gdb.base/attach.exp: Adjust to spell out "symbol-file".
	* gdb.base/maint.exp: Adjust test.

	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* gdb.multi/Makefile.in: New.
	* gdb.multi/base.exp: New.
	* gdb.multi/goodbye.c: New.
	* gdb.multi/hangout.c: New.
	* gdb.multi/hello.c: New.
	* gdb.multi/bkpt-multi-exec.c: New.
	* gdb.multi/bkpt-multi-exec.exp: New.
	* gdb.multi/crashme.c: New.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Inferiors): Rename node to ...
	(Inferiors and Programs): ... this.  Mention running multiple
	programs in the same debug session.
	<info inferiors>: Mention the new 'Executable' column if "info
	inferiors".  Update examples.  Document the "add-inferior",
	"clone-inferior", "remove-inferior" and "maint info
	program-spaces" commands.
	(Process): Rename node to...
	(Forks): ... this.  Document "set|show follow-exec-mode".
@
text
@d998 1
a998 1
  if (breakpoint_inserted_here_p (pc))
@


1.14
log
@2009-10-06  Tristan Gingold  <gingold@@adacore.com>

	* darwin-nat.c: Add __TEXT __info_plist content.
	(darwin_attach_pid): Update error message.
@
text
@d1546 2
a1547 1
  inf = add_inferior (pid);
d1549 1
@


1.13
log
@(committed as obvious)
2009-06-22  Tristan Gingold  <gingold@@adacore.com>

	* darwin-nat.c (darwin_xfer_partial): Use host_address_to_string
	instead of "%p".
@
text
@d150 28
d1354 1
a1354 1
	       " (please check gdb is setgid procmod)"),
@


1.13.4.1
log
@[checked in for Tristan Gingold]
        * darwin-nat.c: Add __TEXT __info_plist content.
        (darwin_attach_pid): Update error message.
@
text
@a149 28
/* Create a __TEXT __info_plist section in the executable so that gdb could
   be signed.  This is required to get an authorization for task_for_pid.

   Once gdb is built, you can either:
   * make it setgid procmod
   * or codesign it with any system-trusted signing authority.
   See taskgated(8) for details.  */
static const unsigned char info_plist[]
__attribute__ ((section ("__TEXT,__info_plist"),used)) =
  "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
  "<!DOCTYPE plist PUBLIC \"-//Apple Computer//DTD PLIST 1.0//EN\""
  " \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n"
  "<plist version=\"1.0\">\n"
  "<dict>\n"
  "  <key>CFBundleIdentifier</key>\n"
  "  <string>org.gnu.gdb</string>\n"
  "  <key>CFBundleName</key>\n"
  "  <string>gdb</string>\n"
  "  <key>CFBundleVersion</key>\n"
  "  <string>1.0</string>\n"
  "  <key>SecTaskAccess</key>\n"
  "  <array>\n"
  "    <string>allowed</string>\n"
  "    <string>debug</string>\n"
  "  </array>\n"
  "</dict>\n"
  "</plist>\n";

d1326 1
a1326 1
	       " (please check gdb is codesigned - see taskgated(8))"),
@


1.12
log
@2009-06-19  Tristan Gingold  <gingold@@adacore.com>

	* darwin-nat.c (_initialize_darwin_inferior): Remove commented-out
	line.
@
text
@d1775 4
a1778 2
    (8, _("darwin_xfer_partial(%s, %d, rbuf=%p, wbuf=%p) pid=%u\n"),
     core_addr_to_string (offset), (int)len, readbuf, writebuf, inf->pid);
@


1.11
log
@2009-06-19  Tristan Gingold  <gingold@@adacore.com>

	* machoread.c (macho_symtab_read): Adjust for bfd changes.
	* darwin-nat.h (struct darwin_exception_msg): New type to describe
	a mach exception.
	(struct private_thread_info): New type to describe the state of the
	thread.
	(DEF_VEC_I thread_t): Removed, replaced by ...
	(DEF_VEC_O darwin_thread_t): ... this new type.
	(struct darwin_inferior): Renamed to ...
	(struct private_inferior): ... this type.  Fields added.
	(darwin_not_port): Moved into the private inferior structure.
	* darwin-nat.c: Add includes, improve comments.
	Rewrite to handle multiple threads and processes.
	(darwin_resume_to): New function and protype.
	(darwin_resume, darwin_wait_to, darwin_wait): Ditto.
	(darwin_kill_inferior): Add ops argument.
	(darwin_pid_to_str): New function.
	(darwin_thread_alive): Ditto.
	(darwin_inf, darwin_not_port): Removed.
	(darwin_inf_fake_stop): New variable.
	(msgin, msgout, msg_state, exc_msg): Removed.
	(mach_check_error): Use warning instead of error.
	(darwin_ptrace): Adjust debug level.
	(cmp_thread_t): Fix names (typo).
	(darwin_check_new_threads): Argument is now an inferior,
	adjust for new structures, add no change check, ignore dead ports,
	handle first thread case.
	(find_inferior_task_it): New function.
	(find_inferior_notify_it): Ditto.
	(darwin_find_inferior_by_task): Ditto.
	(darwin_find_inferior_by_notify): Ditto.
	(darwin_find_thread): Ditto.
	(darwin_suspend_inferior): Ditto.
	(darwin_resume_inferior): Ditto.
	(catch_exception_raise_state): Removed.
	(catch_exception_raise_state_identity): Removed.
	(darwin_suspend_inferior_it): New function.
	(darwin_resume_inferior_it): Ditto.
	(darwin_dump_message): New function, extracted from darwin_wait.
	(darwin_decode_exception_message): New function.
	(darwin_encode_reply): New function.
	(catch_exception_raise): Removed.
	(darwin_send_reply): New function, extracted from darwin_resume.
	(darwin_resume_thread): New function, extracted from darwin_resume.
	(struct resume_inferior_threads_param): New type.
	(darwin_resume_inferior_threads_it): New function.
	(darwin_resume_inferior_threads): New function.
	(darwin_suspend_inferior_threads): New function.
	(darwin_resume): Mostly rewritten to handle multiple threads and
	some corner cases.
	(darwin_decode_message): New function extracted from darwin_wait.
	(cancel_breakpoint): New function.
	(darwin_wait): Mostly rewritten.  Handle multiple threads.
	(darwin_mourn_inferior): Adjust for per process structures.
	(darwin_reply_to_all_pending_messages): New function.
	(darwin_stop_inferior): Adjust for per inferior structures.
	(darwin_attach_pid): Ditto.
	(darwin_init_thread_list): Ditto.
	(darwin_attach): Ditto.
	(darwin_detach): Ditto.
	(darwin_files_info): Now empty.
	(darwin_pid_to_str): Adjust returns string to match one expected by
	the testsuite.
	(darwin_read_write_inferior): Rename err variable to match other uses.
	Adjust debug message.  Handle submaps.
	(darwin_xfer_memory): Adjust for per inferior structures.
	(set_enable_mach_exceptions): Ditto.
	(darwin_pid_to_exec_file): New function.
	(darwin_get_ada_task_ptid): Ditto.
	(darwin_supports_multi_process): Ditto.
	(_initialize_darwin_inferior): Remove useless assertion, adjust for
	per inferior structures.  Add new target operations.
@
text
@a1936 1
  /* darwin_ops->to_has_thread_control = tc_schedlock | tc_switch */;
@


1.10
log
@2009-06-10  Jonas Maebe  <jonas.maebe@@elis.ugent.be>

	* darwin-nat.c (darwin_stop_inferior): Pass 0 as options to
	darwin_wait (blocking wait).
	(darwin_kill_inferior): Likewise.
@
text
@d54 2
d91 9
d115 3
a117 2
/* Current inferior.  */
darwin_inferior *darwin_inf = NULL;
a130 3
/* Notification port.  */
mach_port_t darwin_not_port;

d141 3
d147 1
a147 38
/* Buffer containing received message and to be sent message.  */
static union
{
  mach_msg_header_t hdr;
  char data[1024];
} msgin, msgout;

/* Current message state.
   If the kernel has sent a message it expects a reply and the inferior
   can't be killed before.  */
static enum msg_state { NO_MESSAGE, GOT_MESSAGE, REPLY_SENT } msg_state;

/* Unmarshalled received message.  */
static struct exc_msg
{
  /* Receive port.  */
  mach_port_t port;

  /* Thread and task taking the exception.  */
  mach_port_t thread_port;
  mach_port_t task_port;

  /* Type of the exception.  */
  exception_type_t ex_type;

  /* Machine dependent details.  */
  mach_msg_type_number_t data_count;
  integer_t ex_data[4];
} exc_msg;


/* This controls output of inferior debugging.
   1 = basic exception handling
   2 = task management
   3 = thread management
   4 = pending_event_handler
   6 = most chatty level.  */

d172 3
a174 3
  
  error (_("error on line %u of \"%s\" in function \"%s\": %s (0x%lx)\n"),
         line, file, func, mach_error_string (ret), (unsigned long) ret);
d218 1
a218 1
  inferior_debug (2, _("ptrace (%s, %d, 0x%x, %d): %d (%s)\n"),
d227 3
a229 3
  thread_t lt = *(const thread_t *)l;
  thread_t lr = *(const thread_t *)r;
  return (int)(lr - lt);
d233 1
a233 1
darwin_check_new_threads (darwin_inferior *inf)
d241 2
a242 1
  VEC (thread_t) *thread_vec;
d245 1
a245 1
  kret = task_threads (inf->task, &thread_list, &new_nbr);
d250 1
d254 2
a255 4
  thread_vec = VEC_alloc (thread_t, new_nbr);

  if (inf->threads)
    old_nbr = VEC_length (thread_t, inf->threads);
d259 18
d281 7
a287 2
      thread_t old_id = (old_ix < old_nbr) ?
	VEC_index (thread_t, inf->threads, old_ix) : THREAD_NULL;
d292 1
a292 1
	  VEC_safe_push (thread_t, thread_vec, old_id);
d300 9
a308 1
      if (new_id < old_id || old_ix == old_nbr)
d312 1
d314 14
a327 2
	  tp = add_thread (ptid_build (inf->pid, 0, new_id));
	  VEC_safe_push (thread_t, thread_vec, new_id);
d331 1
a331 1
      if (new_id > old_id || new_ix == new_nbr)
d338 1
d340 1
d343 3
a345 3
  if (inf->threads)
    VEC_free (thread_t, inf->threads);
  inf->threads = thread_vec;
d352 43
d396 1
a396 1
darwin_stop (ptid_t t)
d398 6
a403 1
  int ret;
d405 2
a406 1
  ret = kill (ptid_get_pid (inferior_ptid), SIGINT);
d409 2
d412 1
a412 2
darwin_resume (struct target_ops *ops,
	       ptid_t ptid, int step, enum target_signal signal)
d414 6
a419 5
  struct target_waitstatus status;
  int pid;
  thread_t thread;
  kern_return_t kret;
  int res;
d421 3
a423 3
  /* minus_one_ptid is RESUME_ALL.  */
  if (ptid_equal (ptid, minus_one_ptid))
    ptid = inferior_ptid;
d425 1
a425 2
  pid = ptid_get_pid (ptid);
  thread = ptid_get_tid (ptid);
d427 7
a433 3
  inferior_debug
    (2, _("darwin_resume: state=%d, thread=0x%x, step=%d signal=%d\n"),
     msg_state, thread, step, signal);
d435 6
a440 15
  switch (msg_state)
    {
    case GOT_MESSAGE:
      switch (exc_msg.ex_type)
	{
	case EXC_SOFTWARE:
	  if (exc_msg.ex_data[0] == EXC_SOFT_SIGNAL)
	    {
	      int nsignal = target_signal_to_host (signal);
	      res = PTRACE (PT_THUPDATE, pid,
			    (void *)(uintptr_t)exc_msg.thread_port, nsignal);
	      if (res < 0)
		printf_unfiltered (_("ptrace THUP: res=%d\n"), res);
	    }
	  break;
d442 17
a458 17
	default:
	  break;
	}
	  
      if (thread != 0)
	{
	  inferior_debug (2, _("darwin_set_sstep (thread=%x, enable=%d)\n"),
			  thread, step);
	  darwin_set_sstep (thread, step);
	}

      kret = mach_msg (&msgout.hdr, MACH_SEND_MSG | MACH_SEND_INTERRUPT,
		       msgout.hdr.msgh_size, 0,
		       MACH_PORT_NULL, MACH_MSG_TIMEOUT_NONE,
		       MACH_PORT_NULL);
      if (kret != 0)
	printf_unfiltered (_("mach_msg (reply) ret=%d\n"), kret);
d460 2
a461 2
      msg_state = REPLY_SENT;
      break;
d463 37
a499 6
    case NO_MESSAGE:
      if (step)
	res = PTRACE (PT_STEP, pid, (caddr_t)1, 0);
      else
	res = PTRACE (PT_CONTINUE, pid, (caddr_t)1, 0);
      break;
d501 5
a505 2
    default:
      gdb_assert (0);
d509 13
a521 19
kern_return_t
catch_exception_raise_state
  (mach_port_t port,
   exception_type_t exception_type, mach_exception_data_t exception_data,
   mach_msg_type_number_t data_count, thread_state_flavor_t * state_flavor,
   thread_state_t in_state, mach_msg_type_number_t in_state_count,
   thread_state_t out_state, mach_msg_type_number_t out_state_count)
{
  return KERN_FAILURE;
}

kern_return_t
catch_exception_raise_state_identity
  (mach_port_t port, mach_port_t thread_port, mach_port_t task_port,
   exception_type_t exception_type, mach_exception_data_t exception_data,
   mach_msg_type_number_t data_count, thread_state_flavor_t * state_flavor,
   thread_state_t in_state, mach_msg_type_number_t in_state_count,
   thread_state_t out_state, mach_msg_type_number_t out_state_count)
{
d523 32
d556 14
d575 23
a597 1
  return KERN_FAILURE;
d600 17
a616 7
kern_return_t
catch_exception_raise (mach_port_t port,
		       mach_port_t thread_port,
		       mach_port_t task_port,
		       exception_type_t exception_type,
		       exception_data_t exception_data,
		       mach_msg_type_number_t data_count)
d619 3
a621 2
  int i;
  int res;
d623 4
a626 2
  /* We got new rights to the task.  Get rid of it.  */
  kret = mach_port_deallocate (mach_task_self (), task_port);
d629 10
d640 2
a641 18
    (7, _("catch_exception_raise: exception_type=%d, data_count=%d\n"),
     exception_type, data_count);
  if (darwin_debug_flag > 7)
    {
      for (i = 0; i < data_count; i++)
	printf_unfiltered (" %08x", exception_data[i]);
      printf_unfiltered ("\n");
    }

  /* Save the message.
     FIXME: this should be in a per-thread variable.  */
  exc_msg.port = port;
  exc_msg.thread_port = thread_port;
  exc_msg.task_port = task_port;
  exc_msg.ex_type = exception_type;
  exc_msg.data_count = data_count;
  for (i = 0; i < data_count && i < 4; i++)
    exc_msg.ex_data[i] = exception_data[i];
d643 98
a740 1
  return KERN_SUCCESS;
d743 2
a744 3
static ptid_t
darwin_wait (struct target_ops *ops,
	     ptid_t ptid, struct target_waitstatus *status, int options)
d746 3
d750 3
a752 2
  mach_msg_header_t *hdr = &msgin.hdr;
  pid_t pid = ptid_get_pid (inferior_ptid); /* FIXME.  */
d754 3
a756 1
  gdb_assert (msg_state != GOT_MESSAGE);
d758 4
a761 1
  inferior_debug (6, _("darwin_wait: waiting for a message\n"));
d763 3
a765 3
  /* Wait for a message.  */
  kret = mach_msg (&msgin.hdr, MACH_RCV_MSG | MACH_RCV_INTERRUPT, 0,
		   sizeof (msgin.data), darwin_port_set, 0, MACH_PORT_NULL);
d767 2
a768 1
  if (kret == MACH_RCV_INTERRUPTED)
d770 9
a778 2
      status->kind = TARGET_WAITKIND_IGNORE;
      return minus_one_ptid;
d780 13
d794 11
a804 5
  if (kret != MACH_MSG_SUCCESS)
    {
      inferior_debug (1, _("mach_msg: ret=%x\n"), kret);
      status->kind = TARGET_WAITKIND_SPURIOUS;
      return minus_one_ptid;
d806 1
d808 6
a813 12
  /* Debug: display message.  */
  if (darwin_debug_flag > 10)
   {
     const unsigned long *buf = (unsigned long *) hdr;
     unsigned int i;
     
     printf_unfiltered (_(" bits: 0x%x"), hdr->msgh_bits);
     printf_unfiltered (_(", size: 0x%x"), hdr->msgh_size);
     printf_unfiltered (_(", remote-port: 0x%x"), hdr->msgh_remote_port);
     printf_unfiltered (_(", local-port: 0x%x"), hdr->msgh_local_port);
     printf_unfiltered (_(", reserved: 0x%x"), hdr->msgh_reserved);
     printf_unfiltered (_(", id: 0x%x\n"), hdr->msgh_id);
d815 8
a822 8
     if (darwin_debug_flag > 11)
	{
	  printf_unfiltered (_("  data:"));
	  for (i = 0; i < hdr->msgh_size; i++)
	    printf_unfiltered (" %08lx", buf[i]);
	  printf_unfiltered (_("\n"));
	}
   }
d827 6
a832 2
      /* Handle it via the exception server.  */
      if (!exc_server (&msgin.hdr, &msgout.hdr))
d834 2
a835 1
	  printf_unfiltered (_("exc_server: unknown message (id=%x)\n"),
d837 1
d841 3
d846 5
d852 1
a852 5
      inferior_debug (2, _("darwin_wait: thread=%x, got %s\n"),
		      exc_msg.thread_port, 
		      unparse_exception_type (exc_msg.ex_type));
  
      switch (exc_msg.ex_type)
d867 1
a867 1
	  if (exc_msg.ex_data[0] == EXC_SOFT_SIGNAL)
d869 4
a872 3
	      status->value.sig = target_signal_from_host (exc_msg.ex_data[1]);
	      inferior_debug (2, _("  (signal %d: %s)\n"),
			      exc_msg.ex_data[1],
d874 10
d886 1
a886 1
            status->value.sig = TARGET_EXC_SOFTWARE;
d899 13
a911 1
      msg_state = GOT_MESSAGE;
d913 34
a946 1
      return ptid_build (pid, 0, exc_msg.thread_port);
d948 23
a970 1
  else if (hdr->msgh_local_port == darwin_not_port)
d972 6
a977 2
      pid_t res;
      int wstatus;
d979 108
a1086 6
      /* FIXME: translate task port to pid.  */
      res = wait4 (pid, &wstatus, 0, NULL);
      if (res != pid)
	{
	  printf_unfiltered (_("wait4: res=%x\n"), res);
	  wstatus = 0;
d1088 5
a1092 2
      status->kind = TARGET_WAITKIND_EXITED;
      status->value.integer = WEXITSTATUS (wstatus);
d1094 6
a1099 2
      inferior_debug (2, _("darwin_wait: pid=%d exit, status=%x\n"),
		      pid, wstatus);
d1101 4
a1104 1
      msg_state = NO_MESSAGE;
d1106 3
a1108 8
      return ptid;
    }
  else
    {
      printf_unfiltered (_("Bad local-port: %x\n"), hdr->msgh_local_port);
      status->kind = TARGET_WAITKIND_SPURIOUS;
      return minus_one_ptid;
    }
d1122 1
a1122 1
  if (darwin_inf->threads)
d1125 4
a1128 2
      thread_t t;
      for (k = 0; VEC_iterate (thread_t, darwin_inf->threads, k, t); k++)
d1130 1
a1130 1
	  kret = mach_port_deallocate (gdb_task, t);
d1133 2
a1134 2
      VEC_free (thread_t, darwin_inf->threads);
      darwin_inf->threads = NULL;
d1137 5
a1141 1
  kret = mach_port_request_notification (gdb_task, darwin_inf->task,
d1143 1
a1143 1
					 darwin_inf->prev_not_port,
d1147 3
d1156 4
d1161 1
a1161 1
  for (i = 0; i < darwin_inf->exception_info.count; i++)
d1164 1
a1164 1
	(gdb_task, darwin_inf->exception_info.ports[i]);
d1167 1
a1167 1
  darwin_inf->exception_info.count = 0;
d1169 1
a1169 1
  kret = mach_port_deallocate (gdb_task, darwin_inf->task);
d1172 2
a1173 2
  darwin_inf->task = 0;
  darwin_inf->pid = 0;
d1179 1
a1179 1
darwin_stop_inferior (struct target_ops *ops, darwin_inferior *inf)
d1181 2
a1182 5
  struct target_waitstatus wstatus;
  ptid_t ptid;
  kern_return_t kret;
  int status;
  int res;
d1184 7
a1190 14
  gdb_assert (inf != NULL);

  kret = task_suspend (inf->task);
  MACH_CHECK_ERROR (kret);

  if (msg_state == GOT_MESSAGE)
    darwin_resume (darwin_ops, inferior_ptid, 0, 0);

  res = kill (inf->pid, SIGSTOP);
  if (res != 0)
    warning (_("cannot kill: %s\n"), safe_strerror (errno));

  ptid = darwin_wait (ops, inferior_ptid, &wstatus, 0);
  gdb_assert (wstatus.kind = TARGET_WAITKIND_STOPPED);
d1194 1
a1194 1
darwin_kill_inferior (struct target_ops *ops)
d1202 1
a1202 1
  gdb_assert (darwin_inf != NULL);
d1204 1
a1204 2
  if (ptid_equal (inferior_ptid, null_ptid))
    return;
d1206 1
a1206 1
  darwin_stop_inferior (ops, darwin_inf);
d1208 2
a1209 2
  res = PTRACE (PT_KILL, darwin_inf->pid, 0, 0);
  gdb_assert (res == 0);
d1211 3
a1213 48
  if (msg_state == GOT_MESSAGE)
    {
      exc_msg.ex_type = 0;
      darwin_resume (ops, inferior_ptid, 0, 0);
    }

  kret = task_resume (darwin_inf->task);
  MACH_CHECK_ERROR (kret);

  ptid = darwin_wait (ops, inferior_ptid, &wstatus, 0);

  /* This double wait seems required...  */
  res = waitpid (darwin_inf->pid, &status, 0);
  gdb_assert (res == darwin_inf->pid);

  msg_state = NO_MESSAGE;

  target_mourn_inferior ();
}

/* The child must synchronize with gdb: gdb must set the exception port
   before the child call PTRACE_SIGEXC.  We use a pipe to achieve this.
   FIXME: is there a lighter way ?  */
static int ptrace_fds[2];

static void
darwin_ptrace_me (void)
{
  int res;
  char c;

  /* Close write end point.  */
  close (ptrace_fds[1]);

  /* Wait until gdb is ready.  */
  res = read (ptrace_fds[0], &c, 1);
  gdb_assert (res == 0);
  close (ptrace_fds[0]);

  /* Get rid of privileges.  */
  setegid (getgid ());

  /* Set TRACEME.  */
  PTRACE (PT_TRACE_ME, 0, 0, 0);

  /* Redirect signals to exception port.  */
  PTRACE (PT_SIGEXC, 0, 0, 0);
}
d1215 2
a1216 5
/* Dummy function to be sure fork_inferior uses fork(2) and not vfork(2).  */
static void
darwin_pre_ptrace (void)
{
  if (pipe (ptrace_fds) != 0)
d1218 4
a1221 3
      ptrace_fds[0] = -1;
      ptrace_fds[1] = -1;
      error (_("unable to create a pipe: %s"), safe_strerror (errno));
d1259 46
a1304 1
darwin_attach_pid (int pid)
a1305 1
  task_t itask;
d1309 1
d1312 3
a1314 1
  kret = task_for_pid (gdb_task, pid, &itask);
a1317 1
      struct inferior *inf = current_inferior ();
d1321 2
a1322 2
	  kill (pid, 9);
	  waitpid (pid, &status, 0);
d1327 1
a1327 1
             pid, mach_error_string (kret), (unsigned long) kret);
d1330 2
a1331 1
  inferior_debug (2, _("inferior task: 0x%08x, pid: %d\n"), itask, pid);
d1351 1
d1353 4
a1356 4
      /* Create a port to be notified when the child task terminates.  */
      kret = mach_port_allocate (gdb_task, MACH_PORT_RIGHT_RECEIVE,
				 &darwin_not_port);
      gdb_assert (kret == KERN_SUCCESS);
d1358 3
a1360 7
      kret = mach_port_insert_right (gdb_task, darwin_not_port, darwin_not_port,
				     MACH_MSG_TYPE_MAKE_SEND);
      gdb_assert (kret == KERN_SUCCESS);

      kret = mach_port_move_member (gdb_task, darwin_not_port, darwin_port_set);
      gdb_assert (kret == KERN_SUCCESS);
    }
d1362 1
a1362 1
  kret = mach_port_request_notification (gdb_task, itask,
d1364 1
a1364 1
					 darwin_not_port,
d1366 1
a1366 1
					 &darwin_inf->prev_not_port);
d1368 1
d1370 1
a1370 4
  darwin_inf->task = itask;
  darwin_inf->pid = pid;

  kret = darwin_save_exception_ports (darwin_inf);
d1377 3
a1379 3
    mask = EXC_MASK_SOFTWARE;
  kret = task_set_exception_ports
    (itask, mask, darwin_ex_port, EXCEPTION_DEFAULT, THREAD_STATE_NONE);
d1386 1
a1386 1
darwin_init_thread_list (darwin_inferior *inf)
d1388 2
a1389 1
  thread_t thread;
d1393 50
a1442 3
  gdb_assert (inf->threads && VEC_length (thread_t, inf->threads) > 0);
  thread = VEC_index (thread_t, inf->threads, 0);
  inferior_ptid = ptid_build (inf->pid, 0, thread);
d1452 1
d1454 1
a1454 1
  darwin_attach_pid (pid);
d1460 2
a1461 4
  /* fork_inferior automatically add a thread - but it uses a wrong tid.  */
  delete_thread_silent (inferior_ptid);
  darwin_init_thread_list (darwin_inf);
  
d1472 1
a1472 1
  
d1489 1
a1489 2

  gdb_assert (msg_state == NO_MESSAGE);
d1500 12
a1511 1
    printf_unfiltered (_("Attaching to pid %d\n"), pid);
d1513 3
a1515 4
  res = PTRACE (PT_ATTACHEXC, pid, 0, 0);
  if (res != 0)
    error (_("Unable to attach to process-id %d: %s (%d)"),
	   pid, safe_strerror (errno), errno);
d1517 1
d1520 4
d1525 1
a1525 1
  darwin_attach_pid (pid);
d1527 7
a1533 15
  pid2 = wait4 (pid, &wstatus, WUNTRACED, NULL);
  gdb_assert (pid2 == pid);
  inferior_debug (1, _("darwin_attach: wait4 pid=%d, status=0x%x\n"),
		  pid2, wstatus);

  
  darwin_init_thread_list (darwin_inf);

  darwin_check_osabi (darwin_inf, ptid_get_tid (inferior_ptid));

  /* Looks strange, but the kernel doesn't stop the process...
     (Bug in Leopard ?)
     Do it manually.  */
  /* FIXME: doesn't look to work with multi-threads!!  */
  kill (pid, SIGSTOP);
d1546 2
d1551 1
d1557 2
a1558 2
      printf_unfiltered (_("Detaching from program: %s, %d\n"), exec_file,
			 ptid_get_pid (inferior_ptid));
d1562 3
a1564 1
  darwin_stop_inferior (ops, darwin_inf);
d1566 1
a1566 1
  kret = darwin_restore_exception_ports (darwin_inf);
d1569 1
a1569 1
  if (msg_state == GOT_MESSAGE)
d1571 4
a1574 2
      exc_msg.ex_type = 0;
      darwin_resume (ops, inferior_ptid, 0, 0);
d1577 1
a1577 7
  kret = task_resume (darwin_inf->task);
  gdb_assert (kret == KERN_SUCCESS);

  res = PTRACE (PT_DETACH, darwin_inf->pid, 0, 0);
  if (res != 0)
    printf_unfiltered (_("Unable to detach from process-id %d: %s (%d)"),
		       darwin_inf->pid, safe_strerror (errno), errno);
d1579 1
a1579 1
  msg_state = NO_MESSAGE;
a1586 1
  gdb_assert (darwin_inf != NULL);
d1592 9
a1600 1
  static char buf[128];
d1602 1
a1602 5
  snprintf (buf, sizeof (buf),
	    _("process %d gdb-thread 0x%lx"),
	    (unsigned) ptid_get_pid (ptid),
	    (unsigned long) ptid_get_tid (ptid));
  return buf;
d1620 1
a1620 1
  kern_return_t err;
d1630 3
a1632 3
  inferior_debug (8, _("darwin_read_write_inferior(%s, len=%d)\n"),
		  core_addr_to_string (addr), length);
  
d1634 1
a1634 1
  err = mach_vm_read (task, low_address, aligned_length,
d1636 1
a1636 1
  if (err != KERN_SUCCESS)
d1638 3
a1640 2
      warning (_("darwin_read_write_inferior: vm_read failed: %s"), 
	       mach_error_string (err));
d1658 2
a1659 3
      vm_region_basic_info_data_64_t info;
      mach_port_t object_name;
      mach_vm_address_t old_address = region_address;
d1661 9
a1669 8
      
      region_length = remaining_length;
      count = VM_REGION_BASIC_INFO_COUNT_64;
      err = mach_vm_region (task, &region_address, &region_length,
			    VM_REGION_BASIC_INFO_64,
			    (vm_region_info_t) &info, &count, &object_name);
      
      if (err != KERN_SUCCESS)
d1671 4
a1674 2
	  warning (_("darwin_write_inferior: mach_vm_region failed: %s"), 
		   mach_error_string (err));
d1678 7
d1686 1
a1686 1
      if (region_address > old_address)
a1688 1
		   core_addr_to_string (old_address),
d1690 1
d1696 3
d1701 12
a1712 4
	  warning (_("Memory at address %s is unwritable. Nothing written"),
		   core_addr_to_string (old_address));
	  length = 0;
	  goto out;
d1717 1
a1717 1
	  err = mach_vm_protect (task, old_address, region_length,
d1719 1
a1719 1
	  if (err != KERN_SUCCESS)
d1721 4
a1724 3
	      warning
		(_("darwin_read_write_inferior: mach_vm_protect failed: %s"), 
		 mach_error_string (err));
d1731 1
a1731 1
  err = mach_vm_write (task, low_address, copied, aligned_length);
d1733 1
a1733 1
  if (err != KERN_SUCCESS)
d1736 1
a1736 1
	       mach_error_string (err));
d1751 2
a1752 1
  task_t task = darwin_inf->task;
d1772 5
a1776 4
  inferior_debug (8, _("darwin_xfer_partial(%s, %d, rbuf=%s, wbuf=%s)\n"),
		  core_addr_to_string (offset), (int)len, 
		  host_address_to_string (readbuf),
		  host_address_to_string (writebuf));
d1781 1
a1781 1
  return darwin_read_write_inferior (darwin_inf->task, offset,
d1789 1
a1789 1
  if (darwin_inf && darwin_inf->task != TASK_NULL)
d1791 1
d1799 2
a1800 2
	  darwin_restore_exception_ports (darwin_inf);
	  mask = EXC_MASK_SOFTWARE;
d1802 1
a1802 1
      kret = task_set_exception_ports (darwin_inf->task, mask, darwin_ex_port,
d1808 89
d1898 1
a1898 1
_initialize_darwin_inferior ()
a1901 2
  gdb_assert (darwin_inf == NULL);
  
a1912 5
  darwin_inf = (struct darwin_inferior *)
    xmalloc (sizeof (struct darwin_inferior));

  memset (darwin_inf, 0, sizeof (*darwin_inf));

d1924 1
a1924 1
  darwin_ops->to_wait = darwin_wait;
d1928 1
a1928 1
  darwin_ops->to_resume = darwin_resume;
d1931 1
d1935 3
a1937 1
  darwin_ops->to_has_thread_control = tc_schedlock /*| tc_switch */;
@


1.9
log
@	* target.h (TARGET_WNOHANG): New.
	* target.c (target_wait): Add `options' argument.  Adjust.
	(struct target_ops) <to_wait>: Add `options' argument.
	(target_wait): Add `options' argument.
	* infrun.c (wait_for_inferior): Pass 0 as options to
	target_wait (blocking wait).
	(fetch_inferior_event): Pass TARGET_WNOHANG as options to
	target_wait.
	* fork-child.c (startup_inferior): Pass 0 as options to
	target_wait (blocking wait).
	* linux-nat.c (linux_nat_create_inferior): Remove async masking.
	(linux_nat_wait_1): Add `target_options' argument.  Use it instead
	of checking on target_can_async_p.
	(linux_nat_wait): Add `target_options' argument.  Adjust.
	* remote.c (remote_wait_ns): Add `options' argument.  Adjust to
	check on TARGET_WNOWAIT instead of checking on remote_is_async_p.
	(remote_wait_as): Add `options' argument.  Adjust to check on
	TARGET_WNOWAIT instead of checking on remote_is_async_p.  If doing
	a blocking wait, keep waiting until an interesting event comes
	out.
	(remote_wait): Add `options' argument.  Don't loop here if the
	target is in async mode, and a blocking wait has been requested.

	* top.c (deprecated_target_wait_hook): Add `options' argument.
	* linux-thread-db.c (thread_db_wait): Add `options' argument, and
	pass it down to the layer beneath.
	* inf-ptrace.c (inf_ptrace_wait): Add `options' argument.
	* record.c (record_beneath_to_wait): Add `options' argument.
	(record_wait): Add `options' argument, and pass it down to the
	layer beneath.
	* bsd-uthread.c (bsd_uthread_wait): Add `options' argument.
	* darwin-nat.c (darwin_wait): Likewise.
	* defs.h (deprecated_target_wait_hook): Likewise.
	* gnu-nat.c (gnu_wait): Add `options' argument.
	* go32-nat.c (go32_wait): Likewise.
	* hpux-thread.c (hpux_thread_wait): Add `options' argument, and
	pass it down to the layer beneath.
	* inf-ttrace.c (inf_ttrace_wait): Add `options' argument.
	* monitor.c (monitor_wait): Likewise.
	* nto-procfs.c (procfs_wait): Likewise.
	* remote-mips.c (mips_wait): Add `options' argument.
	* remote-sim.c (gdbsim_wait): Likewise.
	* rs6000-nat.c (rs6000_wait): Add `options' argument.
	* sol-thread.c (sol_thread_wait): Add `options' argument, and pass
	it down to the layer beneath.
	* spu-linux-nat.c (spu_child_wait): Add `options' argument.
	* windows-nat.c (windows_wait): Likewise.
	* tui/tui-hooks.c (tui_target_wait_hook): Likewise.  Adjust.
@
text
@d691 1
a691 1
  ptid = darwin_wait (ops, inferior_ptid, &wstatus);
d723 1
a723 1
  ptid = darwin_wait (ops, inferior_ptid, &wstatus);
@


1.8
log
@	ARI fix: Do not use %p, replace by call to host_address_to_string
	for host pointers.
	* darwin-nat.c (darwin_xfer_partial): Apply change.
	* gnu-nat.c (inf_continue, gnu_xfer_memory): Ditto.
	* gnu-nat.h (proc_debug): Ditto.
	* symmisc.c (maintenance_info_symtabs): Ditto.
	(maintenance_info_psymtabs): Ditto.
	* windows-nat.c (handle_load_dll): Ditto.
	(handle_unload_dll, info_w32_command, handle_exception): Ditto.
	* xtensa-tdep.c (xtensa_unwind_pc): Ditto.
@
text
@d479 1
a479 1
	     ptid_t ptid, struct target_waitstatus *status)
@


1.7
log
@	ARI fix: "strerror" rule.
	* darwin-nat.c (darwin_ptrace): Use safe_strerror.
	(darwin_stop_inferior, darwin_attach, darwin_detach): Ditto.
@
text
@d1200 4
a1203 2
  inferior_debug (8, _("darwin_xfer_partial(%s, %d, rbuf=%p, wbuf=%p)\n"),
		  core_addr_to_string (offset), (int)len, readbuf, writebuf);
@


1.6
log
@        * darwin-nat.c (darwin_resume): Fix a compiler warning when
        building on x86_64-darwin.
@
text
@d245 1
a245 1
                  (ret != 0) ? strerror (errno) : _("no error"));
d689 1
a689 1
    warning (_("cannot kill: %s\n"), strerror (errno));
d967 1
a967 1
	   pid, strerror (errno), errno);
d1031 1
a1031 1
		       darwin_inf->pid, strerror (errno), errno);
@


1.5
log
@        Fix a build failure on Darwin following some changes in
        the profile of some target_ops methods.

        * darwin-nat.c (darwin_kill_inferior): Add target_ops parameter
        where missing.
        (darwin_stop_inferior, darwin_detach): Likewise.
@
text
@d370 1
a370 1
				   (void *)exc_msg.thread_port, nsignal);
@


1.4
log
@	* corelow.c (get_core_registers): Adjust.
	(core_file_thread_alive): Rename to...
	(core_thread_alive): ... this.
	(core_pid_to_str): Try gdbarch_core_pid_to_str first.
	(init_core_ops): Adjust.
	(coreops_suppress_target): Delete.
	(_initialize_corelow): Unconditionally add core_ops.
	* procfs.c: Include "inf-child.h".
	(procfs_ops): Delete.
	(init_procfs_ops): Delete.  Reimplement as...
	(procfs_target): ... this, inheriting from inf-child.
	(procfs_attach, procfs_detach, procfs_fetch_registers): Adjust.
	(procfs_prepare_to_store): Delete.
	(procfs_store_registers, procfs_resume): Adjust.
	(procfs_open): Delete.
	(procfs_suppress_run): Delete.
	(procfs_can_run): Delete.
	(procfs_mourn_inferior): Adjust.
	(procfs_init_inferior): Add target_ops parameter.  Adjust.
	(procfs_create_inferior): Don't pass procfs_init_inferior to
	fork_inferior.  Instead call it after fork_inferior returns.
	(procfs_find_new_threads): Adjust.
	(_initialize_procfs): Adjust to use procfs_target instead of
	init_procfs_ops.
	* sol-thread.c (orig_core_ops, sol_core_ops): Delete.
	(lwp_to_thread): Use target_thread_alive.
	(sol_thread_open): Delete.
	(sol_thread_attach): Delete.
	(sol_thread_detach, sol_thread_resume, sol_thread_wait)
	(sol_thread_fetch_registers, sol_thread_store_registers): Adjust
	to use find_target_beneath.
	(sol_thread_prepare_to_store, sol_thread_xfer_memory): Delete.
	(sol_thread_xfer_partial): Adjust to use find_target_beneath.
	(sol_thread_files_info, sol_thread_kill_inferior): Delete.
	(check_for_thread_db): New.
	(sol_thread_notice_signals, sol_thread_create_inferior): Delete.
	(sol_thread_new_objfile): Call check_for_thread_db.
	(sol_thread_mourn_inferior): Adjust to use find_target_beneath.
	(sol_thread_can_run): Delete.
	(sol_thread_alive): Adjust to use find_target_beneath.
	(sol_thread_stop): Delete.
	(rw_common): Use target_write_memory or target_read_memory.
	(ps_lgetregs, ps_lgetfpregs): Use target_fetch_registers.
	(ps_lsetregs, ps_lsetfpregs): Use target_store_registers.
	(solaris_pid_to_str): Remove check for libthread_db initialization
	failing.
	(sol_find_new_threads): Remove check for libthread_db
	initialization failing, or for an invalid inferior_ptid.  Adjust
	to use find_target_beneath.
	(sol_core_open, sol_core_close, sol_core_detach,
	sol_core_files_info, sol_find_memory_regions,
	sol_make_note_section, ignore): Delete.
	(init_sol_thread_ops): Make it a thread_stratum target.  Remove
	unneeded callback settings.
	(init_sol_core_ops): Delete.
	(_initialize_sol_thread): No longer call init_sol_core_ops, set
	procfs_suppress_run, or hack with core_ops.

	* target.h (struct target_ops): Add a target_ops * parameter to
	to_resume, to_fetch_registers, to_store_registers, to_thread_alive
	and to_find_new_threads.
	(target_fetch_registers, target_store_registers)
	(target_thread_alive, target_find_new_threads): Redeclare as
	function.

	* target.c (update_current_target): Do not inherit or de_fault
	to_resume, to_fetch_registers, to_store_registers,
	to_thread_alive, to_find_new_threads.
	(target_resume): Adjust.
	(target_thread_alive, target_find_new_threads): New.
	(debug_to_resume, debug_to_fetch_registers): Delete.
	(target_fetch_registers): New.
	(debug_to_store_registers): Delete.
	(target_store_registers): New.
	(debug_to_thread_alive, debug_to_find_new_threads): Delete.
	(setup_target_debug): Adjust.

	* gdbcore.h (core_ops): Delete declaration.

	* inf-ptrace.c, linux-nat.c, remote.c, amd64-linux-nat.c,
	inf-child.c, linux-thread-db.c, bsd-uthread.c, inf-ttrace.c,
	i386-sol2-tdep.c, darwin-nat.c, gnu-nat.c, go32-nat.c,
	hpux-thread.c, i386-linux-nat.c, i386fbsd-nat.c, monitor.c,
	nto-procfs.c, remote-m32r-sdi.c, remote-mips.c, windows-nat.c,
	alphabsd-nat.c, amd64bsd-nat.c, arm-linux-nat.c, armnbsd-nat.c,
	bsd-kvm.c, hppa-hpux-nat.c, hppa-linux-nat.c, hppabsd-nat.c,
	hppanbsd-nat.c, i386-darwin-nat.c, i386bsd-nat.c,
	ia64-linux-nat.c, m32r-linux-nat.c, m68kbsd-nat.c,
	m68klinux-nat.c, m88kbsd-nat.c, mips-linux-nat.c,
	mips64obsd-nat.c, mipsnbsd-nat.c, ppc-linux-nat.c, ppcnbsd-nat.c,
	ppcobsd-nat.c, remote-sim.c, rs6000-nat.c, s390-nat.c,
	shnbsd-nat.c, sparc-nat.c, sparc-nat.h, spu-linux-nat.c,
	vaxbsd-nat.c, xtensa-linux-nat.c: Adjust to target_ops changes.

	* gdbarch.sh (core_pid_to_str): New gdbarch callback.
	* gdbarch.h, gdbarch.c: Regenerate.

	* sol2-tdep.c: Include "inferior.h".
	(sol2_core_pid_to_str): New.
	* sol2-tdep.h (sol2_core_pid_to_str): Declare.

	* amd64-sol2-tdep.c (amd64_sol2_init_abi): Set it.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Set it.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Set it.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Set it.
@
text
@d93 1
a93 1
static void darwin_kill_inferior (void);
d671 1
a671 1
darwin_stop_inferior (darwin_inferior *inf)
d691 1
a691 1
  ptid = darwin_wait (inferior_ptid, &wstatus);
d709 1
a709 1
  darwin_stop_inferior (darwin_inf);
d723 1
a723 1
  ptid = darwin_wait (inferior_ptid, &wstatus);
d1014 1
a1014 1
  darwin_stop_inferior (darwin_inf);
@


1.3
log
@	* linux-nat.c (linux_nat_wait): Adjust.
	(linux_nat_pid_to_str): Adjust.  Remove call to thread_db_init.
	* linux-nat.h (thread_db_init): Delete declaration.
	* linux-thread-db.c (target_beneath): Delete.
	(thread_db_init): Delete.
	(thread_db_detach): Use find_target_beneath.
	(thread_db_wait): Adjust interface.  Use find_target_beneath.
	(thread_db_mourn_inferior): Use find_target_beneath.
	(thread_db_can_async_p, thread_db_is_async_p, thread_db_async)
	(thread_db_async_mask): Delete.
	(thread_db_pid_to_str): Adjust interface.  Use
	find_target_beneath.
	(thread_db_get_thread_local_address): Adjust interface.  Use
	find_target_beneath.
	(init_thread_db_ops): Delete references to delete functions.
	* target.c (update_current_target): Don't inherit or default
	to_wait.  Don't inherit to_pid_to_str and
	to_get_thread_local_address.
	(target_translate_tls_address): Look for a pushed target that
	implements to_get_thread_local_address, and use it instead of
	checking for target_get_thread_local_address_p.
	(target_wait, target_pid_to_str): Reimplement as functions.
	(dummy_pid_to_str): New.
	(init_dummy_target): Register it.
	(debug_to_wait): Delete.
	* target.h (struct target_ops): Make to_wait, to_pid_to_str and
	to_get_thread_local_address accept a pointer to struct target_ops.
	(target_wait): Delete macro, and declare as function.
	(target_pid_to_str): Likewise.
	(target_get_thread_local_address)
	(target_get_thread_local_address_p): Delete.
	(noprocess): Add NORETURN and ATTR_NORETURN tags.
	* inf-ptrace.c (inf_ptrace_wait): Adjust.
	(inf_ptrace_pid_to_str): New.
	(inf_ptrace_target): Use inf_ptrace_pid_to_str.
	* aix-thread.c (aix_thread_wait, aix_thread_pid_to_str): Adjust.
	* bsd-kvm.c (bsd_kvm_pid_to_str): Adjust.
	* bsd-uthread.c (bsd_uthread_wait, bsd_uthread_pid_to_str):
	Adjust.
	* corelow.c (core_pid_to_str): Adjust.
	* darwin-nat.c (darwin_wait, darwin_pid_to_str): Adjust.
	* dec-thread.c (dec_thread_wait, dec_thread_pid_to_str): Adjust.
	* gnu-nat.c (gnu_wait, gnu_pid_to_str): Adjust.
	* go32-nat.c (go32_wait, go32_pid_to_str): Adjust.
	* hpux-thread.c (hpux_thread_wait): Adjust.
	* inf-ttrace.c (inf_ttrace_wait, inf_ttrace_pid_to_str): Adjust.
	* monitor.c (monitor_wait, monitor_pid_to_str): Adjust.
	* nto-procfs.c (procfs_wait, procfs_pid_to_str): Adjust.
	* procfs.c (procfs_pid_to_str): Adjust.
	* remote-m32r-sdi.c (m32r_wait, m32r_pid_to_str): Adjust.
	* remote-mips.c (mips_wait): Adjust.
	* remote-sim.c (gdbsim_wait, gdbsim_pid_to_str): Adjust.
	* remote.c (remote_wait, remote_pid_to_str)
	(remote_get_thread_local_address): Adjust.
	* rs6000-nat.c (rs6000_wait): Adjust.
	* sol-thread.c (procfs_pid_to_str): Adjust declaration.
	(sol_thread_wait, solaris_pid_to_str): Adjust.
	* spu-linux-nat.c (spu_child_wait): Adjust.
	* windows-nat.c (windows_wait, windows_pid_to_str): Adjust.
@
text
@a88 3
static void darwin_resume (ptid_t ptid, int step,
			   enum target_signal signal);

a103 2
static int darwin_thread_alive (ptid_t tpid);

d340 2
a341 1
darwin_resume (ptid_t ptid, int step, enum target_signal signal)
d685 1
a685 1
    darwin_resume (inferior_ptid, 0, 0);
d696 1
a696 1
darwin_kill_inferior (void)
d717 1
a717 1
      darwin_resume (inferior_ptid, 0, 0);
d1022 1
a1022 1
      darwin_resume (inferior_ptid, 0, 0);
d1057 1
a1057 1
darwin_thread_alive (ptid_t ptid)
@


1.2
log
@        Updated copyright notices for most files.
@
text
@a91 2
static ptid_t darwin_wait (ptid_t ptid, struct target_waitstatus *status);

a106 2
static char *darwin_pid_to_str (ptid_t tpid);

d482 2
a483 1
darwin_wait (ptid_t ptid, struct target_waitstatus *status)
d1049 1
a1049 1
darwin_pid_to_str (ptid_t ptid)
@


1.1
log
@gdb:
2008-11-27  Tristan Gingold  <gingold@@adacore.com>

	* NEWS: Add entry for new native configuration: Darwin.
	* configure.host: Add Darwin host.
	* configure.tgt: Add Darwin target.
	* defs.h (enum gdb_osabi): Add GDB_OSABI_DARWIN.
	* osabi.c (gdb_osabi_names): Add name for Darwin abi.
	* i386-darwin-nat.c: New file.
	* i386-darwin-tdep.c: New file.
	* machoread.c: New file.
	* darwin-nat-info.c: New file.
	* darwin-nat.c: New file.
	* darwin-nat.h: New file.
	* darwin.defs: New file.
	* config/i386/darwin.mh: New file.

gdb/doc:
2008-11-27  Tristan Gingold  <gingold@@adacore.com>

	* gdb.texinfo (Darwin): Document Darwin specific features.
@
text
@d2 1
a2 1
   Copyright (C) 2008 Free Software Foundation, Inc.
@

